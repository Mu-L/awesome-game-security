Project Path: arc_ro0ti_CS2-Offsets_56c7leeq

Source Tree:

```txt
arc_ro0ti_CS2-Offsets_56c7leeq
├── README.md
└── SDK
    ├── animationsystem.dll.cs
    ├── animationsystem.dll.hpp
    ├── animationsystem.dll.json
    ├── animationsystem.dll.py
    ├── animationsystem.dll.rs
    ├── client.dll.cs
    ├── client.dll.hpp
    ├── client.dll.json
    ├── client.dll.py
    ├── client.dll.rs
    ├── engine2.dll.cs
    ├── engine2.dll.hpp
    ├── engine2.dll.json
    ├── engine2.dll.py
    ├── engine2.dll.rs
    ├── host.dll.cs
    ├── host.dll.hpp
    ├── host.dll.json
    ├── host.dll.py
    ├── host.dll.rs
    ├── interfaces.cs
    ├── interfaces.hpp
    ├── interfaces.json
    ├── interfaces.py
    ├── interfaces.rs
    ├── materialsystem2.dll.cs
    ├── materialsystem2.dll.hpp
    ├── materialsystem2.dll.json
    ├── materialsystem2.dll.py
    ├── materialsystem2.dll.rs
    ├── networksystem.dll.cs
    ├── networksystem.dll.hpp
    ├── networksystem.dll.json
    ├── networksystem.dll.py
    ├── networksystem.dll.rs
    ├── offsets.cs
    ├── offsets.hpp
    ├── offsets.json
    ├── offsets.py
    ├── offsets.rs
    ├── particles.dll.cs
    ├── particles.dll.hpp
    ├── particles.dll.json
    ├── particles.dll.py
    ├── particles.dll.rs
    ├── pulse_system.dll.cs
    ├── pulse_system.dll.hpp
    ├── pulse_system.dll.json
    ├── pulse_system.dll.py
    ├── pulse_system.dll.rs
    ├── rendersystemdx11.dll.cs
    ├── rendersystemdx11.dll.hpp
    ├── rendersystemdx11.dll.json
    ├── rendersystemdx11.dll.py
    ├── rendersystemdx11.dll.rs
    ├── resourcesystem.dll.cs
    ├── resourcesystem.dll.hpp
    ├── resourcesystem.dll.json
    ├── resourcesystem.dll.py
    ├── resourcesystem.dll.rs
    ├── scenesystem.dll.cs
    ├── scenesystem.dll.hpp
    ├── scenesystem.dll.json
    ├── scenesystem.dll.py
    ├── scenesystem.dll.rs
    ├── schemasystem.dll.cs
    ├── schemasystem.dll.hpp
    ├── schemasystem.dll.json
    ├── schemasystem.dll.py
    ├── schemasystem.dll.rs
    ├── server.dll.cs
    ├── server.dll.hpp
    ├── server.dll.json
    ├── server.dll.py
    ├── server.dll.rs
    ├── soundsystem.dll.cs
    ├── soundsystem.dll.hpp
    ├── soundsystem.dll.json
    ├── soundsystem.dll.py
    ├── soundsystem.dll.rs
    ├── vphysics2.dll.cs
    ├── vphysics2.dll.hpp
    ├── vphysics2.dll.json
    ├── vphysics2.dll.py
    ├── vphysics2.dll.rs
    ├── worldrenderer.dll.cs
    ├── worldrenderer.dll.hpp
    ├── worldrenderer.dll.json
    ├── worldrenderer.dll.py
    └── worldrenderer.dll.rs

```

`README.md`:

```md
# CS2 Offsets
I will try to get updated after every update.

# Quick Offsets
```cs
public static class ClientDll {
    public const nint dwBaseEntityModel_setModel = 0x584690;
    public const nint dwEntityList = 0x17B5200;
    public const nint dwForceBackward = 0x16B57E0;
    public const nint dwForceCrouch = 0x16B5AB0;
    public const nint dwForceForward = 0x16B5750;
    public const nint dwForceJump = 0x16B5A20;
    public const nint dwForceLeft = 0x16B5870;
    public const nint dwForceRight = 0x16B5900;
    public const nint dwGameEntitySystem_getBaseEntity = 0x607BE0;
    public const nint dwGameEntitySystem_getHighestEntityIndex = 0x5F9910;
    public const nint dwGameRules = 0x1810EB0;
    public const nint dwGlobalVars = 0x16B1670;
    public const nint dwGlowManager = 0x1810ED8;
    public const nint dwInterfaceLinkList = 0x190E578;
    public const nint dwLocalPlayerController = 0x1804518;
    public const nint dwLocalPlayerPawn = 0x16BC598;
    public const nint dwPlantedC4 = 0x1818478;
    public const nint dwViewAngles = 0x1872890;
    public const nint dwViewMatrix = 0x1813840;
    public const nint dwViewRender = 0x18140C0;
}

public static class Engine2Dll {
    public const nint dwBuildNumber = 0x48B514;
    public const nint dwNetworkGameClient = 0x48AAC0;
    public const nint dwNetworkGameClient_getLocalPlayer = 0xF0;
    public const nint dwNetworkGameClient_maxClients = 0x250;
    public const nint dwNetworkGameClient_signOnState = 0x240;
    public const nint dwWindowHeight = 0x541DBC;
    public const nint dwWindowWidth = 0x541DB8;
}
```

# Credits
- Dumper - [a2x](https://github.com/a2x/cs2-dumper/)
- Updates - [ro0ti](https://github.com/ro0ti/)
```

`SDK/animationsystem.dll.cs`:

```cs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.318137100 UTC
 */

public static class AimMatrixOpFixedSettings_t {
    public const nint m_attachment = 0x0; // CAnimAttachment
    public const nint m_damping = 0x80; // CAnimInputDamping
    public const nint m_poseCacheHandles = 0x90; // CPoseHandle[10]
    public const nint m_eBlendMode = 0xB8; // AimMatrixBlendMode
    public const nint m_fAngleIncrement = 0xBC; // float
    public const nint m_nSequenceMaxFrame = 0xC0; // int32_t
    public const nint m_nBoneMaskIndex = 0xC4; // int32_t
    public const nint m_bTargetIsPosition = 0xC8; // bool
}

public static class AnimComponentID {
    public const nint m_id = 0x0; // uint32_t
}

public static class AnimNodeID {
    public const nint m_id = 0x0; // uint32_t
}

public static class AnimNodeOutputID {
    public const nint m_id = 0x0; // uint32_t
}

public static class AnimParamID {
    public const nint m_id = 0x0; // uint32_t
}

public static class AnimScriptHandle {
    public const nint m_id = 0x0; // uint32_t
}

public static class AnimStateID {
    public const nint m_id = 0x0; // uint32_t
}

public static class AnimTagID {
    public const nint m_id = 0x0; // uint32_t
}

public static class AnimationDecodeDebugDumpElement_t {
    public const nint m_nEntityIndex = 0x0; // int32_t
    public const nint m_modelName = 0x8; // CUtlString
    public const nint m_poseParams = 0x10; // CUtlVector<CUtlString>
    public const nint m_decodeOps = 0x28; // CUtlVector<CUtlString>
    public const nint m_internalOps = 0x40; // CUtlVector<CUtlString>
    public const nint m_decodedAnims = 0x58; // CUtlVector<CUtlString>
}

public static class AnimationDecodeDebugDump_t {
    public const nint m_processingType = 0x0; // AnimationProcessingType_t
    public const nint m_elems = 0x8; // CUtlVector<AnimationDecodeDebugDumpElement_t>
}

public static class AnimationSnapshotBase_t {
    public const nint m_flRealTime = 0x0; // float
    public const nint m_rootToWorld = 0x10; // matrix3x4a_t
    public const nint m_bBonesInWorldSpace = 0x40; // bool
    public const nint m_boneSetupMask = 0x48; // CUtlVector<uint32_t>
    public const nint m_boneTransforms = 0x60; // CUtlVector<matrix3x4a_t>
    public const nint m_flexControllers = 0x78; // CUtlVector<float>
    public const nint m_SnapshotType = 0x90; // AnimationSnapshotType_t
    public const nint m_bHasDecodeDump = 0x94; // bool
    public const nint m_DecodeDump = 0x98; // AnimationDecodeDebugDumpElement_t
}

public static class AnimationSnapshot_t {
    public const nint m_nEntIndex = 0x110; // int32_t
    public const nint m_modelName = 0x118; // CUtlString
}

public static class AttachmentHandle_t {
    public const nint m_Value = 0x0; // uint8_t
}

public static class BlendItem_t {
    public const nint m_tags = 0x0; // CUtlVector<TagSpan_t>
    public const nint m_pChild = 0x18; // CAnimUpdateNodeRef
    public const nint m_hSequence = 0x28; // HSequence
    public const nint m_vPos = 0x2C; // Vector2D
    public const nint m_flDuration = 0x34; // float
    public const nint m_bUseCustomDuration = 0x38; // bool
}

public static class BoneDemoCaptureSettings_t {
    public const nint m_boneName = 0x0; // CUtlString
    public const nint m_flChainLength = 0x8; // float
}

public static class CActionComponentUpdater {
    public const nint m_actions = 0x30; // CUtlVector<CSmartPtr<CAnimActionUpdater>>
}

public static class CAddUpdateNode {
    public const nint m_footMotionTiming = 0x8C; // BinaryNodeChildOption
    public const nint m_bApplyToFootMotion = 0x90; // bool
    public const nint m_bApplyChannelsSeparately = 0x91; // bool
    public const nint m_bUseModelSpace = 0x92; // bool
}

public static class CAimConstraint {
    public const nint m_qAimOffset = 0x70; // Quaternion
    public const nint m_nUpType = 0x80; // uint32_t
}

public static class CAimMatrixUpdateNode {
    public const nint m_opFixedSettings = 0x70; // AimMatrixOpFixedSettings_t
    public const nint m_target = 0x148; // AnimVectorSource
    public const nint m_paramIndex = 0x14C; // CAnimParamHandle
    public const nint m_hSequence = 0x150; // HSequence
    public const nint m_bResetChild = 0x154; // bool
    public const nint m_bLockWhenWaning = 0x155; // bool
}

public static class CAnimActivity {
    public const nint m_name = 0x0; // CBufferString
    public const nint m_nActivity = 0x10; // int32_t
    public const nint m_nFlags = 0x14; // int32_t
    public const nint m_nWeight = 0x18; // int32_t
}

public static class CAnimAttachment {
    public const nint m_influenceRotations = 0x0; // Quaternion[3]
    public const nint m_influenceOffsets = 0x30; // VectorAligned[3]
    public const nint m_influenceIndices = 0x60; // int32_t[3]
    public const nint m_influenceWeights = 0x6C; // float[3]
    public const nint m_numInfluences = 0x78; // uint8_t
}

public static class CAnimBone {
    public const nint m_name = 0x0; // CBufferString
    public const nint m_parent = 0x10; // int32_t
    public const nint m_pos = 0x14; // Vector
    public const nint m_quat = 0x20; // QuaternionStorage
    public const nint m_scale = 0x30; // float
    public const nint m_qAlignment = 0x34; // QuaternionStorage
    public const nint m_flags = 0x44; // int32_t
}

public static class CAnimBoneDifference {
    public const nint m_name = 0x0; // CBufferString
    public const nint m_parent = 0x10; // CBufferString
    public const nint m_posError = 0x20; // Vector
    public const nint m_bHasRotation = 0x2C; // bool
    public const nint m_bHasMovement = 0x2D; // bool
}

public static class CAnimComponentUpdater {
    public const nint m_name = 0x18; // CUtlString
    public const nint m_id = 0x20; // AnimComponentID
    public const nint m_networkMode = 0x24; // AnimNodeNetworkMode
    public const nint m_bStartEnabled = 0x28; // bool
}

public static class CAnimData {
    public const nint m_name = 0x10; // CBufferString
    public const nint m_animArray = 0x20; // CUtlVector<CAnimDesc>
    public const nint m_decoderArray = 0x38; // CUtlVector<CAnimDecoder>
    public const nint m_nMaxUniqueFrameIndex = 0x50; // int32_t
    public const nint m_segmentArray = 0x58; // CUtlVector<CAnimFrameSegment>
}

public static class CAnimDataChannelDesc {
    public const nint m_szChannelClass = 0x0; // CBufferString
    public const nint m_szVariableName = 0x10; // CBufferString
    public const nint m_nFlags = 0x20; // int32_t
    public const nint m_nType = 0x24; // int32_t
    public const nint m_szGrouping = 0x28; // CBufferString
    public const nint m_szDescription = 0x38; // CBufferString
    public const nint m_szElementNameArray = 0x48; // CUtlVector<CBufferString>
    public const nint m_nElementIndexArray = 0x60; // CUtlVector<int32_t>
    public const nint m_nElementMaskArray = 0x78; // CUtlVector<uint32_t>
}

public static class CAnimDecoder {
    public const nint m_szName = 0x0; // CBufferString
    public const nint m_nVersion = 0x10; // int32_t
    public const nint m_nType = 0x14; // int32_t
}

public static class CAnimDemoCaptureSettings {
    public const nint m_rangeBoneChainLength = 0x0; // Vector2D
    public const nint m_rangeMaxSplineErrorRotation = 0x8; // Vector2D
    public const nint m_flMaxSplineErrorTranslation = 0x10; // float
    public const nint m_flMaxSplineErrorScale = 0x14; // float
    public const nint m_flIkRotation_MaxSplineError = 0x18; // float
    public const nint m_flIkTranslation_MaxSplineError = 0x1C; // float
    public const nint m_flMaxQuantizationErrorRotation = 0x20; // float
    public const nint m_flMaxQuantizationErrorTranslation = 0x24; // float
    public const nint m_flMaxQuantizationErrorScale = 0x28; // float
    public const nint m_flIkRotation_MaxQuantizationError = 0x2C; // float
    public const nint m_flIkTranslation_MaxQuantizationError = 0x30; // float
    public const nint m_baseSequence = 0x38; // CUtlString
    public const nint m_nBaseSequenceFrame = 0x40; // int32_t
    public const nint m_boneSelectionMode = 0x44; // EDemoBoneSelectionMode
    public const nint m_bones = 0x48; // CUtlVector<BoneDemoCaptureSettings_t>
    public const nint m_ikChains = 0x60; // CUtlVector<IKDemoCaptureSettings_t>
}

public static class CAnimDesc {
    public const nint m_name = 0x0; // CBufferString
    public const nint m_flags = 0x10; // CAnimDesc_Flag
    public const nint fps = 0x18; // float
    public const nint m_Data = 0x20; // CAnimEncodedFrames
    public const nint m_movementArray = 0xF8; // CUtlVector<CAnimMovement>
    public const nint m_eventArray = 0x110; // CUtlVector<CAnimEventDefinition>
    public const nint m_activityArray = 0x128; // CUtlVector<CAnimActivity>
    public const nint m_hierarchyArray = 0x140; // CUtlVector<CAnimLocalHierarchy>
    public const nint framestalltime = 0x158; // float
    public const nint m_vecRootMin = 0x15C; // Vector
    public const nint m_vecRootMax = 0x168; // Vector
    public const nint m_vecBoneWorldMin = 0x178; // CUtlVector<Vector>
    public const nint m_vecBoneWorldMax = 0x190; // CUtlVector<Vector>
    public const nint m_sequenceParams = 0x1A8; // CAnimSequenceParams
}

public static class CAnimDesc_Flag {
    public const nint m_bLooping = 0x0; // bool
    public const nint m_bAllZeros = 0x1; // bool
    public const nint m_bHidden = 0x2; // bool
    public const nint m_bDelta = 0x3; // bool
    public const nint m_bLegacyWorldspace = 0x4; // bool
    public const nint m_bModelDoc = 0x5; // bool
    public const nint m_bImplicitSeqIgnoreDelta = 0x6; // bool
    public const nint m_bAnimGraphAdditive = 0x7; // bool
}

public static class CAnimEncodeDifference {
    public const nint m_boneArray = 0x0; // CUtlVector<CAnimBoneDifference>
    public const nint m_morphArray = 0x18; // CUtlVector<CAnimMorphDifference>
    public const nint m_userArray = 0x30; // CUtlVector<CAnimUserDifference>
    public const nint m_bHasRotationBitArray = 0x48; // CUtlVector<uint8_t>
    public const nint m_bHasMovementBitArray = 0x60; // CUtlVector<uint8_t>
    public const nint m_bHasMorphBitArray = 0x78; // CUtlVector<uint8_t>
    public const nint m_bHasUserBitArray = 0x90; // CUtlVector<uint8_t>
}

public static class CAnimEncodedFrames {
    public const nint m_fileName = 0x0; // CBufferString
    public const nint m_nFrames = 0x10; // int32_t
    public const nint m_nFramesPerBlock = 0x14; // int32_t
    public const nint m_frameblockArray = 0x18; // CUtlVector<CAnimFrameBlockAnim>
    public const nint m_usageDifferences = 0x30; // CAnimEncodeDifference
}

public static class CAnimEnum {
    public const nint m_value = 0x0; // uint8_t
}

public static class CAnimEventDefinition {
    public const nint m_nFrame = 0x8; // int32_t
    public const nint m_flCycle = 0xC; // float
    public const nint m_EventData = 0x10; // KeyValues3
    public const nint m_sLegacyOptions = 0x20; // CBufferString
    public const nint m_sEventName = 0x30; // CGlobalSymbol
}

public static class CAnimFoot {
    public const nint m_name = 0x0; // CUtlString
    public const nint m_vBallOffset = 0x8; // Vector
    public const nint m_vHeelOffset = 0x14; // Vector
    public const nint m_ankleBoneIndex = 0x20; // int32_t
    public const nint m_toeBoneIndex = 0x24; // int32_t
}

public static class CAnimFrameBlockAnim {
    public const nint m_nStartFrame = 0x0; // int32_t
    public const nint m_nEndFrame = 0x4; // int32_t
    public const nint m_segmentIndexArray = 0x8; // CUtlVector<int32_t>
}

public static class CAnimFrameSegment {
    public const nint m_nUniqueFrameIndex = 0x0; // int32_t
    public const nint m_nLocalElementMasks = 0x4; // uint32_t
    public const nint m_nLocalChannel = 0x8; // int32_t
    public const nint m_container = 0x10; // CUtlBinaryBlock
}

public static class CAnimGraphDebugReplay {
    public const nint m_animGraphFileName = 0x40; // CUtlString
    public const nint m_frameList = 0x48; // CUtlVector<CSmartPtr<CAnimReplayFrame>>
    public const nint m_startIndex = 0x60; // int32_t
    public const nint m_writeIndex = 0x64; // int32_t
    public const nint m_frameCount = 0x68; // int32_t
}

public static class CAnimGraphModelBinding {
    public const nint m_modelName = 0x8; // CUtlString
    public const nint m_pSharedData = 0x10; // CSmartPtr<CAnimUpdateSharedData>
}

public static class CAnimGraphNetworkSettings {
    public const nint m_bNetworkingEnabled = 0x20; // bool
}

public static class CAnimGraphSettingsManager {
    public const nint m_settingsGroups = 0x18; // CUtlVector<CSmartPtr<CAnimGraphSettingsGroup>>
}

public static class CAnimInputDamping {
    public const nint m_speedFunction = 0x8; // DampingSpeedFunction
    public const nint m_fSpeedScale = 0xC; // float
}

public static class CAnimKeyData {
    public const nint m_name = 0x0; // CBufferString
    public const nint m_boneArray = 0x10; // CUtlVector<CAnimBone>
    public const nint m_userArray = 0x28; // CUtlVector<CAnimUser>
    public const nint m_morphArray = 0x40; // CUtlVector<CBufferString>
    public const nint m_nChannelElements = 0x58; // int32_t
    public const nint m_dataChannelArray = 0x60; // CUtlVector<CAnimDataChannelDesc>
}

public static class CAnimLocalHierarchy {
    public const nint m_sBone = 0x0; // CBufferString
    public const nint m_sNewParent = 0x10; // CBufferString
    public const nint m_nStartFrame = 0x20; // int32_t
    public const nint m_nPeakFrame = 0x24; // int32_t
    public const nint m_nTailFrame = 0x28; // int32_t
    public const nint m_nEndFrame = 0x2C; // int32_t
}

public static class CAnimMorphDifference {
    public const nint m_name = 0x0; // CBufferString
}

public static class CAnimMotorUpdaterBase {
    public const nint m_name = 0x10; // CUtlString
    public const nint m_bDefault = 0x18; // bool
}

public static class CAnimMovement {
    public const nint endframe = 0x0; // int32_t
    public const nint motionflags = 0x4; // int32_t
    public const nint v0 = 0x8; // float
    public const nint v1 = 0xC; // float
    public const nint angle = 0x10; // float
    public const nint vector = 0x14; // Vector
    public const nint position = 0x20; // Vector
}

public static class CAnimNodePath {
    public const nint m_path = 0x0; // AnimNodeID[11]
    public const nint m_nCount = 0x2C; // int32_t
}

public static class CAnimParamHandle {
    public const nint m_type = 0x0; // AnimParamType_t
    public const nint m_index = 0x1; // uint8_t
}

public static class CAnimParamHandleMap {
    public const nint m_list = 0x0; // CUtlHashtable<uint16_t,int16_t>
}

public static class CAnimParameterBase {
    public const nint m_name = 0x18; // CGlobalSymbol
    public const nint m_group = 0x20; // CUtlString
    public const nint m_id = 0x28; // AnimParamID
    public const nint m_componentName = 0x40; // CUtlString
    public const nint m_bNetworkingRequested = 0x4C; // bool
    public const nint m_bIsReferenced = 0x4D; // bool
}

public static class CAnimParameterManagerUpdater {
    public const nint m_parameters = 0x18; // CUtlVector<CSmartPtr<CAnimParameterBase>>
    public const nint m_idToIndexMap = 0x30; // CUtlHashtable<AnimParamID,int32_t>
    public const nint m_nameToIndexMap = 0x50; // CUtlHashtable<CUtlString,int32_t>
    public const nint m_indexToHandle = 0x70; // CUtlVector<CAnimParamHandle>
    public const nint m_autoResetParams = 0x88; // CUtlVector<CUtlPair<CAnimParamHandle,CAnimVariant>>
    public const nint m_autoResetMap = 0xA0; // CUtlHashtable<CAnimParamHandle,int16_t>
}

public static class CAnimReplayFrame {
    public const nint m_inputDataBlocks = 0x10; // CUtlVector<CUtlBinaryBlock>
    public const nint m_instanceData = 0x28; // CUtlBinaryBlock
    public const nint m_startingLocalToWorldTransform = 0x40; // CTransform
    public const nint m_localToWorldTransform = 0x60; // CTransform
    public const nint m_timeStamp = 0x80; // float
}

public static class CAnimScriptComponentUpdater {
    public const nint m_hScript = 0x30; // AnimScriptHandle
}

public static class CAnimScriptManager {
    public const nint m_scriptInfo = 0x10; // CUtlVector<ScriptInfo_t>
}

public static class CAnimSequenceParams {
    public const nint m_flFadeInTime = 0x0; // float
    public const nint m_flFadeOutTime = 0x4; // float
}

public static class CAnimSkeleton {
    public const nint m_localSpaceTransforms = 0x10; // CUtlVector<CTransform>
    public const nint m_modelSpaceTransforms = 0x28; // CUtlVector<CTransform>
    public const nint m_boneNames = 0x40; // CUtlVector<CUtlString>
    public const nint m_children = 0x58; // CUtlVector<CUtlVector<int32_t>>
    public const nint m_parents = 0x70; // CUtlVector<int32_t>
    public const nint m_feet = 0x88; // CUtlVector<CAnimFoot>
    public const nint m_morphNames = 0xA0; // CUtlVector<CUtlString>
    public const nint m_lodBoneCounts = 0xB8; // CUtlVector<int32_t>
}

public static class CAnimStateMachineUpdater {
    public const nint m_states = 0x8; // CUtlVector<CStateUpdateData>
    public const nint m_transitions = 0x20; // CUtlVector<CTransitionUpdateData>
    public const nint m_startStateIndex = 0x50; // int32_t
}

public static class CAnimTagBase {
    public const nint m_name = 0x18; // CGlobalSymbol
    public const nint m_group = 0x20; // CGlobalSymbol
    public const nint m_tagID = 0x28; // AnimTagID
    public const nint m_bIsReferenced = 0x2C; // bool
}

public static class CAnimTagManagerUpdater {
    public const nint m_tags = 0x18; // CUtlVector<CSmartPtr<CAnimTagBase>>
}

public static class CAnimUpdateNodeBase {
    public const nint m_nodePath = 0x18; // CAnimNodePath
    public const nint m_networkMode = 0x48; // AnimNodeNetworkMode
    public const nint m_name = 0x50; // CUtlString
}

public static class CAnimUpdateNodeRef {
    public const nint m_nodeIndex = 0x8; // int32_t
}

public static class CAnimUpdateSharedData {
    public const nint m_nodes = 0x10; // CUtlVector<CSmartPtr<CAnimUpdateNodeBase>>
    public const nint m_nodeIndexMap = 0x28; // CUtlHashtable<CAnimNodePath,int32_t>
    public const nint m_components = 0x48; // CUtlVector<CSmartPtr<CAnimComponentUpdater>>
    public const nint m_pParamListUpdater = 0x60; // CSmartPtr<CAnimParameterManagerUpdater>
    public const nint m_pTagManagerUpdater = 0x68; // CSmartPtr<CAnimTagManagerUpdater>
    public const nint m_scriptManager = 0x70; // CSmartPtr<CAnimScriptManager>
    public const nint m_settings = 0x78; // CAnimGraphSettingsManager
    public const nint m_pStaticPoseCache = 0xA8; // CSmartPtr<CStaticPoseCacheBuilder>
    public const nint m_pSkeleton = 0xB0; // CSmartPtr<CAnimSkeleton>
    public const nint m_rootNodePath = 0xB8; // CAnimNodePath
}

public static class CAnimUser {
    public const nint m_name = 0x0; // CBufferString
    public const nint m_nType = 0x10; // int32_t
}

public static class CAnimUserDifference {
    public const nint m_name = 0x0; // CBufferString
    public const nint m_nType = 0x10; // int32_t
}

public static class CAnimationGraphVisualizerAxis {
    public const nint m_xWsTransform = 0x40; // CTransform
    public const nint m_flAxisSize = 0x60; // float
}

public static class CAnimationGraphVisualizerLine {
    public const nint m_vWsPositionStart = 0x40; // VectorAligned
    public const nint m_vWsPositionEnd = 0x50; // VectorAligned
    public const nint m_Color = 0x60; // Color
}

public static class CAnimationGraphVisualizerPie {
    public const nint m_vWsCenter = 0x40; // VectorAligned
    public const nint m_vWsStart = 0x50; // VectorAligned
    public const nint m_vWsEnd = 0x60; // VectorAligned
    public const nint m_Color = 0x70; // Color
}

public static class CAnimationGraphVisualizerPrimitiveBase {
    public const nint m_Type = 0x8; // CAnimationGraphVisualizerPrimitiveType
    public const nint m_OwningAnimNodePaths = 0xC; // AnimNodeID[11]
    public const nint m_nOwningAnimNodePathCount = 0x38; // int32_t
}

public static class CAnimationGraphVisualizerSphere {
    public const nint m_vWsPosition = 0x40; // VectorAligned
    public const nint m_flRadius = 0x50; // float
    public const nint m_Color = 0x54; // Color
}

public static class CAnimationGraphVisualizerText {
    public const nint m_vWsPosition = 0x40; // VectorAligned
    public const nint m_Color = 0x50; // Color
    public const nint m_Text = 0x58; // CUtlString
}

public static class CAnimationGroup {
    public const nint m_nFlags = 0x10; // uint32_t
    public const nint m_name = 0x18; // CBufferString
    public const nint m_localHAnimArray_Handle = 0x60; // CUtlVector<CStrongHandle<InfoForResourceTypeCAnimData>>
    public const nint m_includedGroupArray_Handle = 0x78; // CUtlVector<CStrongHandle<InfoForResourceTypeCAnimationGroup>>
    public const nint m_directHSeqGroup_Handle = 0x90; // CStrongHandle<InfoForResourceTypeCSequenceGroupData>
    public const nint m_decodeKey = 0x98; // CAnimKeyData
    public const nint m_szScripts = 0x110; // CUtlVector<CBufferString>
}

public static class CAttachment {
    public const nint m_name = 0x0; // CUtlString
    public const nint m_influenceNames = 0x8; // CUtlString[3]
    public const nint m_vInfluenceRotations = 0x20; // Quaternion[3]
    public const nint m_vInfluenceOffsets = 0x50; // Vector[3]
    public const nint m_influenceWeights = 0x74; // float[3]
    public const nint m_bInfluenceRootTransform = 0x80; // bool[3]
    public const nint m_nInfluences = 0x83; // uint8_t
    public const nint m_bIgnoreRotation = 0x84; // bool
}

public static class CAudioAnimTag {
    public const nint m_clipName = 0x38; // CUtlString
    public const nint m_attachmentName = 0x40; // CUtlString
    public const nint m_flVolume = 0x48; // float
    public const nint m_bStopWhenTagEnds = 0x4C; // bool
    public const nint m_bStopWhenGraphEnds = 0x4D; // bool
    public const nint m_bPlayOnServer = 0x4E; // bool
    public const nint m_bPlayOnClient = 0x4F; // bool
}

public static class CBaseConstraint {
    public const nint m_name = 0x28; // CUtlString
    public const nint m_vUpVector = 0x30; // Vector
    public const nint m_slaves = 0x40; // CUtlVector<CConstraintSlave>
    public const nint m_targets = 0x58; // CUtlVector<CConstraintTarget>
}

public static class CBinaryUpdateNode {
    public const nint m_pChild1 = 0x58; // CAnimUpdateNodeRef
    public const nint m_pChild2 = 0x68; // CAnimUpdateNodeRef
    public const nint m_timingBehavior = 0x78; // BinaryNodeTiming
    public const nint m_flTimingBlend = 0x7C; // float
    public const nint m_bResetChild1 = 0x80; // bool
    public const nint m_bResetChild2 = 0x81; // bool
}

public static class CBlend2DUpdateNode {
    public const nint m_items = 0x60; // CUtlVector<BlendItem_t>
    public const nint m_tags = 0x78; // CUtlVector<TagSpan_t>
    public const nint m_paramSpans = 0x90; // CParamSpanUpdater
    public const nint m_nodeItemIndices = 0xA8; // CUtlVector<int32_t>
    public const nint m_damping = 0xC0; // CAnimInputDamping
    public const nint m_blendSourceX = 0xD0; // AnimValueSource
    public const nint m_paramX = 0xD4; // CAnimParamHandle
    public const nint m_blendSourceY = 0xD8; // AnimValueSource
    public const nint m_paramY = 0xDC; // CAnimParamHandle
    public const nint m_eBlendMode = 0xE0; // Blend2DMode
    public const nint m_playbackSpeed = 0xE4; // float
    public const nint m_bLoop = 0xE8; // bool
    public const nint m_bLockBlendOnReset = 0xE9; // bool
    public const nint m_bLockWhenWaning = 0xEA; // bool
    public const nint m_bAnimEventsAndTagsOnMostWeightedOnly = 0xEB; // bool
}

public static class CBlendCurve {
    public const nint m_flControlPoint1 = 0x0; // float
    public const nint m_flControlPoint2 = 0x4; // float
}

public static class CBlendUpdateNode {
    public const nint m_children = 0x60; // CUtlVector<CAnimUpdateNodeRef>
    public const nint m_sortedOrder = 0x78; // CUtlVector<uint8_t>
    public const nint m_targetValues = 0x90; // CUtlVector<float>
    public const nint m_blendValueSource = 0xAC; // AnimValueSource
    public const nint m_paramIndex = 0xB0; // CAnimParamHandle
    public const nint m_damping = 0xB8; // CAnimInputDamping
    public const nint m_blendKeyType = 0xC8; // BlendKeyType
    public const nint m_bLockBlendOnReset = 0xCC; // bool
    public const nint m_bSyncCycles = 0xCD; // bool
    public const nint m_bLoop = 0xCE; // bool
    public const nint m_bLockWhenWaning = 0xCF; // bool
}

public static class CBodyGroupAnimTag {
    public const nint m_nPriority = 0x38; // int32_t
    public const nint m_bodyGroupSettings = 0x40; // CUtlVector<CBodyGroupSetting>
}

public static class CBodyGroupSetting {
    public const nint m_BodyGroupName = 0x0; // CUtlString
    public const nint m_nBodyGroupOption = 0x8; // int32_t
}

public static class CBoneConstraintDotToMorph {
    public const nint m_sBoneName = 0x28; // CUtlString
    public const nint m_sTargetBoneName = 0x30; // CUtlString
    public const nint m_sMorphChannelName = 0x38; // CUtlString
    public const nint m_flRemap = 0x40; // float[4]
}

public static class CBoneConstraintPoseSpaceBone {
    public const nint m_inputList = 0x70; // CUtlVector<CBoneConstraintPoseSpaceBone::Input_t>
}

public static class CBoneConstraintPoseSpaceBone_Input_t {
    public const nint m_inputValue = 0x0; // Vector
    public const nint m_outputTransformList = 0x10; // CUtlVector<CTransform>
}

public static class CBoneConstraintPoseSpaceMorph {
    public const nint m_sBoneName = 0x28; // CUtlString
    public const nint m_sAttachmentName = 0x30; // CUtlString
    public const nint m_outputMorph = 0x38; // CUtlVector<CUtlString>
    public const nint m_inputList = 0x50; // CUtlVector<CBoneConstraintPoseSpaceMorph::Input_t>
    public const nint m_bClamp = 0x68; // bool
}

public static class CBoneConstraintPoseSpaceMorph_Input_t {
    public const nint m_inputValue = 0x0; // Vector
    public const nint m_outputWeightList = 0x10; // CUtlVector<float>
}

public static class CBoneMaskUpdateNode {
    public const nint m_nWeightListIndex = 0x8C; // int32_t
    public const nint m_flRootMotionBlend = 0x90; // float
    public const nint m_blendSpace = 0x94; // BoneMaskBlendSpace
    public const nint m_footMotionTiming = 0x98; // BinaryNodeChildOption
    public const nint m_bUseBlendScale = 0x9C; // bool
    public const nint m_blendValueSource = 0xA0; // AnimValueSource
    public const nint m_hBlendParameter = 0xA4; // CAnimParamHandle
}

public static class CBonePositionMetricEvaluator {
    public const nint m_nBoneIndex = 0x50; // int32_t
}

public static class CBoneVelocityMetricEvaluator {
    public const nint m_nBoneIndex = 0x50; // int32_t
}

public static class CBoolAnimParameter {
    public const nint m_bDefaultValue = 0x60; // bool
}

public static class CCPPScriptComponentUpdater {
    public const nint m_scriptsToRun = 0x30; // CUtlVector<CGlobalSymbol>
}

public static class CCachedPose {
    public const nint m_transforms = 0x8; // CUtlVector<CTransform>
    public const nint m_morphWeights = 0x20; // CUtlVector<float>
    public const nint m_hSequence = 0x38; // HSequence
    public const nint m_flCycle = 0x3C; // float
}

public static class CChoiceUpdateNode {
    public const nint m_children = 0x58; // CUtlVector<CAnimUpdateNodeRef>
    public const nint m_weights = 0x70; // CUtlVector<float>
    public const nint m_blendTimes = 0x88; // CUtlVector<float>
    public const nint m_choiceMethod = 0xA0; // ChoiceMethod
    public const nint m_choiceChangeMethod = 0xA4; // ChoiceChangeMethod
    public const nint m_blendMethod = 0xA8; // ChoiceBlendMethod
    public const nint m_blendTime = 0xAC; // float
    public const nint m_bCrossFade = 0xB0; // bool
    public const nint m_bResetChosen = 0xB1; // bool
    public const nint m_bDontResetSameSelection = 0xB2; // bool
}

public static class CClothSettingsAnimTag {
    public const nint m_flStiffness = 0x38; // float
    public const nint m_flEaseIn = 0x3C; // float
    public const nint m_flEaseOut = 0x40; // float
    public const nint m_nVertexSet = 0x48; // CUtlString
}

public static class CCompressorGroup {
    public const nint m_nTotalElementCount = 0x0; // int32_t
    public const nint m_szChannelClass = 0x8; // CUtlVector<char*>
    public const nint m_szVariableName = 0x20; // CUtlVector<char*>
    public const nint m_nType = 0x38; // CUtlVector<fieldtype_t>
    public const nint m_nFlags = 0x50; // CUtlVector<int32_t>
    public const nint m_szGrouping = 0x68; // CUtlVector<CUtlString>
    public const nint m_nCompressorIndex = 0x80; // CUtlVector<int32_t>
    public const nint m_szElementNames = 0x98; // CUtlVector<CUtlVector<char*>>
    public const nint m_nElementUniqueID = 0xB0; // CUtlVector<CUtlVector<int32_t>>
    public const nint m_nElementMask = 0xC8; // CUtlVector<uint32_t>
    public const nint m_vectorCompressor = 0xF8; // CUtlVector<CCompressor<Vector>*>
    public const nint m_quaternionCompressor = 0x110; // CUtlVector<CCompressor<QuaternionStorage>*>
    public const nint m_intCompressor = 0x128; // CUtlVector<CCompressor<int32_t>*>
    public const nint m_boolCompressor = 0x140; // CUtlVector<CCompressor<bool>*>
    public const nint m_colorCompressor = 0x158; // CUtlVector<CCompressor<Color>*>
    public const nint m_vector2DCompressor = 0x170; // CUtlVector<CCompressor<Vector2D>*>
    public const nint m_vector4DCompressor = 0x188; // CUtlVector<CCompressor<Vector4D>*>
}

public static class CConcreteAnimParameter {
    public const nint m_previewButton = 0x50; // AnimParamButton_t
    public const nint m_eNetworkSetting = 0x54; // AnimParamNetworkSetting
    public const nint m_bUseMostRecentValue = 0x58; // bool
    public const nint m_bAutoReset = 0x59; // bool
    public const nint m_bGameWritable = 0x5A; // bool
    public const nint m_bGraphWritable = 0x5B; // bool
}

public static class CConstraintSlave {
    public const nint m_qBaseOrientation = 0x0; // Quaternion
    public const nint m_vBasePosition = 0x10; // Vector
    public const nint m_nBoneHash = 0x1C; // uint32_t
    public const nint m_flWeight = 0x20; // float
    public const nint m_sName = 0x28; // CUtlString
}

public static class CConstraintTarget {
    public const nint m_qOffset = 0x20; // Quaternion
    public const nint m_vOffset = 0x30; // Vector
    public const nint m_nBoneHash = 0x3C; // uint32_t
    public const nint m_sName = 0x40; // CUtlString
    public const nint m_flWeight = 0x48; // float
    public const nint m_bIsAttachment = 0x59; // bool
}

public static class CCycleBase {
    public const nint m_flCycle = 0x0; // float
}

public static class CCycleControlClipUpdateNode {
    public const nint m_tags = 0x60; // CUtlVector<TagSpan_t>
    public const nint m_hSequence = 0x7C; // HSequence
    public const nint m_duration = 0x80; // float
    public const nint m_valueSource = 0x84; // AnimValueSource
    public const nint m_paramIndex = 0x88; // CAnimParamHandle
}

public static class CCycleControlUpdateNode {
    public const nint m_valueSource = 0x68; // AnimValueSource
    public const nint m_paramIndex = 0x6C; // CAnimParamHandle
}

public static class CDampedPathAnimMotorUpdater {
    public const nint m_flAnticipationTime = 0x2C; // float
    public const nint m_flMinSpeedScale = 0x30; // float
    public const nint m_hAnticipationPosParam = 0x34; // CAnimParamHandle
    public const nint m_hAnticipationHeadingParam = 0x36; // CAnimParamHandle
    public const nint m_flSpringConstant = 0x38; // float
    public const nint m_flMinSpringTension = 0x3C; // float
    public const nint m_flMaxSpringTension = 0x40; // float
}

public static class CDampedValueComponentUpdater {
    public const nint m_items = 0x30; // CUtlVector<CDampedValueUpdateItem>
}

public static class CDampedValueUpdateItem {
    public const nint m_damping = 0x0; // CAnimInputDamping
    public const nint m_hParamIn = 0x18; // CAnimParamHandle
    public const nint m_hParamOut = 0x1A; // CAnimParamHandle
}

public static class CDemoSettingsComponentUpdater {
    public const nint m_settings = 0x30; // CAnimDemoCaptureSettings
}

public static class CDirectPlaybackTagData {
    public const nint m_sequenceName = 0x0; // CUtlString
    public const nint m_tags = 0x8; // CUtlVector<TagSpan_t>
}

public static class CDirectPlaybackUpdateNode {
    public const nint m_bFinishEarly = 0x6C; // bool
    public const nint m_bResetOnFinish = 0x6D; // bool
    public const nint m_allTags = 0x70; // CUtlVector<CDirectPlaybackTagData>
}

public static class CDirectionalBlendUpdateNode {
    public const nint m_hSequences = 0x5C; // HSequence[8]
    public const nint m_damping = 0x80; // CAnimInputDamping
    public const nint m_blendValueSource = 0x90; // AnimValueSource
    public const nint m_paramIndex = 0x94; // CAnimParamHandle
    public const nint m_playbackSpeed = 0x98; // float
    public const nint m_duration = 0x9C; // float
    public const nint m_bLoop = 0xA0; // bool
    public const nint m_bLockBlendOnReset = 0xA1; // bool
}

public static class CDistanceRemainingMetricEvaluator {
    public const nint m_flMaxDistance = 0x50; // float
    public const nint m_flMinDistance = 0x54; // float
    public const nint m_flStartGoalFilterDistance = 0x58; // float
    public const nint m_flMaxGoalOvershootScale = 0x5C; // float
    public const nint m_bFilterFixedMinDistance = 0x60; // bool
    public const nint m_bFilterGoalDistance = 0x61; // bool
    public const nint m_bFilterGoalOvershoot = 0x62; // bool
}

public static class CDrawCullingData {
    public const nint m_vConeApex = 0x0; // Vector
    public const nint m_ConeAxis = 0xC; // int8_t[3]
    public const nint m_ConeCutoff = 0xF; // int8_t
}

public static class CEmitTagActionUpdater {
    public const nint m_nTagIndex = 0x18; // int32_t
    public const nint m_bIsZeroDuration = 0x1C; // bool
}

public static class CEnumAnimParameter {
    public const nint m_defaultValue = 0x68; // uint8_t
    public const nint m_enumOptions = 0x70; // CUtlVector<CUtlString>
}

public static class CExpressionActionUpdater {
    public const nint m_hParam = 0x18; // CAnimParamHandle
    public const nint m_eParamType = 0x1A; // AnimParamType_t
    public const nint m_hScript = 0x1C; // AnimScriptHandle
}

public static class CFingerBone {
    public const nint m_boneName = 0x0; // CUtlString
    public const nint m_hingeAxis = 0x8; // Vector
    public const nint m_vCapsulePos1 = 0x14; // Vector
    public const nint m_vCapsulePos2 = 0x20; // Vector
    public const nint m_flMinAngle = 0x2C; // float
    public const nint m_flMaxAngle = 0x30; // float
    public const nint m_flRadius = 0x34; // float
}

public static class CFingerChain {
    public const nint m_targets = 0x0; // CUtlVector<CFingerSource>
    public const nint m_bones = 0x18; // CUtlVector<CFingerBone>
    public const nint m_name = 0x30; // CUtlString
    public const nint m_tipParentBoneName = 0x38; // CUtlString
    public const nint m_vTipOffset = 0x40; // Vector
    public const nint m_metacarpalBoneName = 0x50; // CUtlString
    public const nint m_vSplayHingeAxis = 0x58; // Vector
    public const nint m_flSplayMinAngle = 0x64; // float
    public const nint m_flSplayMaxAngle = 0x68; // float
    public const nint m_flFingerScaleRatio = 0x6C; // float
}

public static class CFingerSource {
    public const nint m_nFingerIndex = 0x0; // AnimVRFinger_t
    public const nint m_flFingerWeight = 0x4; // float
}

public static class CFlexController {
    public const nint m_szName = 0x0; // CUtlString
    public const nint m_szType = 0x8; // CUtlString
    public const nint min = 0x10; // float
    public const nint max = 0x14; // float
}

public static class CFlexDesc {
    public const nint m_szFacs = 0x0; // CUtlString
}

public static class CFlexOp {
    public const nint m_OpCode = 0x0; // FlexOpCode_t
    public const nint m_Data = 0x4; // int32_t
}

public static class CFlexRule {
    public const nint m_nFlex = 0x0; // int32_t
    public const nint m_FlexOps = 0x8; // CUtlVector<CFlexOp>
}

public static class CFloatAnimParameter {
    public const nint m_fDefaultValue = 0x60; // float
    public const nint m_fMinValue = 0x64; // float
    public const nint m_fMaxValue = 0x68; // float
    public const nint m_bInterpolate = 0x6C; // bool
}

public static class CFollowAttachmentUpdateNode {
    public const nint m_opFixedData = 0x70; // FollowAttachmentSettings_t
}

public static class CFollowPathUpdateNode {
    public const nint m_flBlendOutTime = 0x6C; // float
    public const nint m_bBlockNonPathMovement = 0x70; // bool
    public const nint m_bStopFeetAtGoal = 0x71; // bool
    public const nint m_bScaleSpeed = 0x72; // bool
    public const nint m_flScale = 0x74; // float
    public const nint m_flMinAngle = 0x78; // float
    public const nint m_flMaxAngle = 0x7C; // float
    public const nint m_flSpeedScaleBlending = 0x80; // float
    public const nint m_turnDamping = 0x88; // CAnimInputDamping
    public const nint m_facingTarget = 0x98; // AnimValueSource
    public const nint m_hParam = 0x9C; // CAnimParamHandle
    public const nint m_flTurnToFaceOffset = 0xA0; // float
    public const nint m_bTurnToFace = 0xA4; // bool
}

public static class CFootAdjustmentUpdateNode {
    public const nint m_clips = 0x70; // CUtlVector<HSequence>
    public const nint m_hBasePoseCacheHandle = 0x88; // CPoseHandle
    public const nint m_facingTarget = 0x8C; // CAnimParamHandle
    public const nint m_flTurnTimeMin = 0x90; // float
    public const nint m_flTurnTimeMax = 0x94; // float
    public const nint m_flStepHeightMax = 0x98; // float
    public const nint m_flStepHeightMaxAngle = 0x9C; // float
    public const nint m_bResetChild = 0xA0; // bool
    public const nint m_bAnimationDriven = 0xA1; // bool
}

public static class CFootCycleDefinition {
    public const nint m_vStancePositionMS = 0x0; // Vector
    public const nint m_vMidpointPositionMS = 0xC; // Vector
    public const nint m_flStanceDirectionMS = 0x18; // float
    public const nint m_vToStrideStartPos = 0x1C; // Vector
    public const nint m_stanceCycle = 0x28; // CAnimCycle
    public const nint m_footLiftCycle = 0x2C; // CFootCycle
    public const nint m_footOffCycle = 0x30; // CFootCycle
    public const nint m_footStrikeCycle = 0x34; // CFootCycle
    public const nint m_footLandCycle = 0x38; // CFootCycle
}

public static class CFootCycleMetricEvaluator {
    public const nint m_footIndices = 0x50; // CUtlVector<int32_t>
}

public static class CFootDefinition {
    public const nint m_name = 0x0; // CUtlString
    public const nint m_ankleBoneName = 0x8; // CUtlString
    public const nint m_toeBoneName = 0x10; // CUtlString
    public const nint m_vBallOffset = 0x18; // Vector
    public const nint m_vHeelOffset = 0x24; // Vector
    public const nint m_flFootLength = 0x30; // float
    public const nint m_flBindPoseDirectionMS = 0x34; // float
    public const nint m_flTraceHeight = 0x38; // float
    public const nint m_flTraceRadius = 0x3C; // float
}

public static class CFootFallAnimTag {
    public const nint m_foot = 0x38; // FootFallTagFoot_t
}

public static class CFootLockUpdateNode {
    public const nint m_opFixedSettings = 0x68; // FootLockPoseOpFixedSettings
    public const nint m_footSettings = 0xD0; // CUtlVector<FootFixedSettings>
    public const nint m_hipShiftDamping = 0xE8; // CAnimInputDamping
    public const nint m_rootHeightDamping = 0xF8; // CAnimInputDamping
    public const nint m_flStrideCurveScale = 0x108; // float
    public const nint m_flStrideCurveLimitScale = 0x10C; // float
    public const nint m_flStepHeightIncreaseScale = 0x110; // float
    public const nint m_flStepHeightDecreaseScale = 0x114; // float
    public const nint m_flHipShiftScale = 0x118; // float
    public const nint m_flBlendTime = 0x11C; // float
    public const nint m_flMaxRootHeightOffset = 0x120; // float
    public const nint m_flMinRootHeightOffset = 0x124; // float
    public const nint m_flTiltPlanePitchSpringStrength = 0x128; // float
    public const nint m_flTiltPlaneRollSpringStrength = 0x12C; // float
    public const nint m_bApplyFootRotationLimits = 0x130; // bool
    public const nint m_bApplyHipShift = 0x131; // bool
    public const nint m_bModulateStepHeight = 0x132; // bool
    public const nint m_bResetChild = 0x133; // bool
    public const nint m_bEnableVerticalCurvedPaths = 0x134; // bool
    public const nint m_bEnableRootHeightDamping = 0x135; // bool
}

public static class CFootMotion {
    public const nint m_strides = 0x0; // CUtlVector<CFootStride>
    public const nint m_name = 0x18; // CUtlString
    public const nint m_bAdditive = 0x20; // bool
}

public static class CFootPinningUpdateNode {
    public const nint m_poseOpFixedData = 0x70; // FootPinningPoseOpFixedData_t
    public const nint m_eTimingSource = 0xA0; // FootPinningTimingSource
    public const nint m_params = 0xA8; // CUtlVector<CAnimParamHandle>
    public const nint m_bResetChild = 0xC0; // bool
}

public static class CFootPositionMetricEvaluator {
    public const nint m_footIndices = 0x50; // CUtlVector<int32_t>
    public const nint m_bIgnoreSlope = 0x68; // bool
}

public static class CFootStepTriggerUpdateNode {
    public const nint m_triggers = 0x68; // CUtlVector<FootStepTrigger>
    public const nint m_flTolerance = 0x84; // float
}

public static class CFootStride {
    public const nint m_definition = 0x0; // CFootCycleDefinition
    public const nint m_trajectories = 0x40; // CFootTrajectories
}

public static class CFootTrajectories {
    public const nint m_trajectories = 0x0; // CUtlVector<CFootTrajectory>
}

public static class CFootTrajectory {
    public const nint m_vOffset = 0x0; // Vector
    public const nint m_flRotationOffset = 0xC; // float
    public const nint m_flProgression = 0x10; // float
}

public static class CFootstepLandedAnimTag {
    public const nint m_FootstepType = 0x38; // FootstepLandedFootSoundType_t
    public const nint m_OverrideSoundName = 0x40; // CUtlString
    public const nint m_DebugAnimSourceString = 0x48; // CUtlString
    public const nint m_BoneName = 0x50; // CUtlString
}

public static class CFutureFacingMetricEvaluator {
    public const nint m_flDistance = 0x50; // float
    public const nint m_flTime = 0x54; // float
}

public static class CFutureVelocityMetricEvaluator {
    public const nint m_flDistance = 0x50; // float
    public const nint m_flStoppingDistance = 0x54; // float
    public const nint m_flTargetSpeed = 0x58; // float
    public const nint m_eMode = 0x5C; // VelocityMetricMode
}

public static class CHitBox {
    public const nint m_name = 0x0; // CUtlString
    public const nint m_sSurfaceProperty = 0x8; // CUtlString
    public const nint m_sBoneName = 0x10; // CUtlString
    public const nint m_vMinBounds = 0x18; // Vector
    public const nint m_vMaxBounds = 0x24; // Vector
    public const nint m_flShapeRadius = 0x30; // float
    public const nint m_nBoneNameHash = 0x34; // uint32_t
    public const nint m_nGroupId = 0x38; // int32_t
    public const nint m_nShapeType = 0x3C; // uint8_t
    public const nint m_bTranslationOnly = 0x3D; // bool
    public const nint m_CRC = 0x40; // uint32_t
    public const nint m_cRenderColor = 0x44; // Color
    public const nint m_nHitBoxIndex = 0x48; // uint16_t
}

public static class CHitBoxSet {
    public const nint m_name = 0x0; // CUtlString
    public const nint m_nNameHash = 0x8; // uint32_t
    public const nint m_HitBoxes = 0x10; // CUtlVector<CHitBox>
    public const nint m_SourceFilename = 0x28; // CUtlString
}

public static class CHitBoxSetList {
    public const nint m_HitBoxSets = 0x0; // CUtlVector<CHitBoxSet>
}

public static class CHitReactUpdateNode {
    public const nint m_opFixedSettings = 0x68; // HitReactFixedSettings_t
    public const nint m_triggerParam = 0xB4; // CAnimParamHandle
    public const nint m_hitBoneParam = 0xB6; // CAnimParamHandle
    public const nint m_hitOffsetParam = 0xB8; // CAnimParamHandle
    public const nint m_hitDirectionParam = 0xBA; // CAnimParamHandle
    public const nint m_hitStrengthParam = 0xBC; // CAnimParamHandle
    public const nint m_flMinDelayBetweenHits = 0xC0; // float
    public const nint m_bResetChild = 0xC4; // bool
}

public static class CIntAnimParameter {
    public const nint m_defaultValue = 0x60; // int32_t
    public const nint m_minValue = 0x64; // int32_t
    public const nint m_maxValue = 0x68; // int32_t
}

public static class CJiggleBoneUpdateNode {
    public const nint m_opFixedData = 0x68; // JiggleBoneSettingsList_t
}

public static class CJumpHelperUpdateNode {
    public const nint m_hTargetParam = 0xA8; // CAnimParamHandle
    public const nint m_flOriginalJumpMovement = 0xAC; // Vector
    public const nint m_flOriginalJumpDuration = 0xB8; // float
    public const nint m_flJumpStartCycle = 0xBC; // float
    public const nint m_flJumpEndCycle = 0xC0; // float
    public const nint m_eCorrectionMethod = 0xC4; // JumpCorrectionMethod
    public const nint m_bTranslationAxis = 0xC8; // bool[3]
    public const nint m_bScaleSpeed = 0xCB; // bool
}

public static class CLODComponentUpdater {
    public const nint m_nServerLOD = 0x30; // int32_t
}

public static class CLeanMatrixUpdateNode {
    public const nint m_frameCorners = 0x5C; // int32_t[3][3]
    public const nint m_poses = 0x80; // CPoseHandle[9]
    public const nint m_damping = 0xA8; // CAnimInputDamping
    public const nint m_blendSource = 0xB8; // AnimVectorSource
    public const nint m_paramIndex = 0xBC; // CAnimParamHandle
    public const nint m_verticalAxis = 0xC0; // Vector
    public const nint m_horizontalAxis = 0xCC; // Vector
    public const nint m_hSequence = 0xD8; // HSequence
    public const nint m_flMaxValue = 0xDC; // float
    public const nint m_nSequenceMaxFrame = 0xE0; // int32_t
}

public static class CLookAtUpdateNode {
    public const nint m_opFixedSettings = 0x70; // LookAtOpFixedSettings_t
    public const nint m_target = 0x138; // AnimVectorSource
    public const nint m_paramIndex = 0x13C; // CAnimParamHandle
    public const nint m_weightParamIndex = 0x13E; // CAnimParamHandle
    public const nint m_bResetChild = 0x140; // bool
    public const nint m_bLockWhenWaning = 0x141; // bool
}

public static class CLookComponentUpdater {
    public const nint m_hLookHeading = 0x34; // CAnimParamHandle
    public const nint m_hLookHeadingVelocity = 0x36; // CAnimParamHandle
    public const nint m_hLookPitch = 0x38; // CAnimParamHandle
    public const nint m_hLookDistance = 0x3A; // CAnimParamHandle
    public const nint m_hLookDirection = 0x3C; // CAnimParamHandle
    public const nint m_hLookTarget = 0x3E; // CAnimParamHandle
    public const nint m_hLookTargetWorldSpace = 0x40; // CAnimParamHandle
    public const nint m_bNetworkLookTarget = 0x42; // bool
}

public static class CMaterialAttributeAnimTag {
    public const nint m_AttributeName = 0x38; // CUtlString
    public const nint m_AttributeType = 0x40; // MatterialAttributeTagType_t
    public const nint m_flValue = 0x44; // float
    public const nint m_Color = 0x48; // Color
}

public static class CMaterialDrawDescriptor {
    public const nint m_nPrimitiveType = 0x0; // RenderPrimitiveType_t
    public const nint m_nBaseVertex = 0x4; // int32_t
    public const nint m_nVertexCount = 0x8; // int32_t
    public const nint m_nStartIndex = 0xC; // int32_t
    public const nint m_nIndexCount = 0x10; // int32_t
    public const nint m_flUvDensity = 0x14; // float
    public const nint m_vTintColor = 0x18; // Vector
    public const nint m_flAlpha = 0x24; // float
    public const nint m_nFirstMeshlet = 0x2C; // uint32_t
    public const nint m_nNumMeshlets = 0x30; // uint16_t
    public const nint m_indexBuffer = 0xB8; // CRenderBufferBinding
    public const nint m_material = 0xE0; // CStrongHandle<InfoForResourceTypeIMaterial2>
}

public static class CMeshletDescriptor {
    public const nint m_PackedAABB = 0x0; // PackedAABB_t
    public const nint m_CullingData = 0x8; // CDrawCullingData
}

public static class CModelConfig {
    public const nint m_ConfigName = 0x0; // CUtlString
    public const nint m_Elements = 0x8; // CUtlVector<CModelConfigElement*>
    public const nint m_bTopLevel = 0x20; // bool
}

public static class CModelConfigElement {
    public const nint m_ElementName = 0x8; // CUtlString
    public const nint m_NestedElements = 0x10; // CUtlVector<CModelConfigElement*>
}

public static class CModelConfigElement_AttachedModel {
    public const nint m_InstanceName = 0x48; // CUtlString
    public const nint m_EntityClass = 0x50; // CUtlString
    public const nint m_hModel = 0x58; // CStrongHandle<InfoForResourceTypeCModel>
    public const nint m_vOffset = 0x60; // Vector
    public const nint m_aAngOffset = 0x6C; // QAngle
    public const nint m_AttachmentName = 0x78; // CUtlString
    public const nint m_LocalAttachmentOffsetName = 0x80; // CUtlString
    public const nint m_AttachmentType = 0x88; // ModelConfigAttachmentType_t
    public const nint m_bBoneMergeFlex = 0x8C; // bool
    public const nint m_bUserSpecifiedColor = 0x8D; // bool
    public const nint m_bUserSpecifiedMaterialGroup = 0x8E; // bool
    public const nint m_bAcceptParentMaterialDrivenDecals = 0x8F; // bool
    public const nint m_BodygroupOnOtherModels = 0x90; // CUtlString
    public const nint m_MaterialGroupOnOtherModels = 0x98; // CUtlString
}

public static class CModelConfigElement_Command {
    public const nint m_Command = 0x48; // CUtlString
    public const nint m_Args = 0x50; // KeyValues3
}

public static class CModelConfigElement_RandomColor {
    public const nint m_Gradient = 0x48; // CColorGradient
}

public static class CModelConfigElement_RandomPick {
    public const nint m_Choices = 0x48; // CUtlVector<CUtlString>
    public const nint m_ChoiceWeights = 0x60; // CUtlVector<float>
}

public static class CModelConfigElement_SetBodygroup {
    public const nint m_GroupName = 0x48; // CUtlString
    public const nint m_nChoice = 0x50; // int32_t
}

public static class CModelConfigElement_SetBodygroupOnAttachedModels {
    public const nint m_GroupName = 0x48; // CUtlString
    public const nint m_nChoice = 0x50; // int32_t
}

public static class CModelConfigElement_SetMaterialGroup {
    public const nint m_MaterialGroupName = 0x48; // CUtlString
}

public static class CModelConfigElement_SetMaterialGroupOnAttachedModels {
    public const nint m_MaterialGroupName = 0x48; // CUtlString
}

public static class CModelConfigElement_SetRenderColor {
    public const nint m_Color = 0x48; // Color
}

public static class CModelConfigElement_UserPick {
    public const nint m_Choices = 0x48; // CUtlVector<CUtlString>
}

public static class CModelConfigList {
    public const nint m_bHideMaterialGroupInTools = 0x0; // bool
    public const nint m_bHideRenderColorInTools = 0x1; // bool
    public const nint m_Configs = 0x8; // CUtlVector<CModelConfig*>
}

public static class CMoodVData {
    public const nint m_sModelName = 0x0; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    public const nint m_nMoodType = 0xE0; // MoodType_t
    public const nint m_animationLayers = 0xE8; // CUtlVector<MoodAnimationLayer_t>
}

public static class CMorphBundleData {
    public const nint m_flULeftSrc = 0x0; // float
    public const nint m_flVTopSrc = 0x4; // float
    public const nint m_offsets = 0x8; // CUtlVector<float>
    public const nint m_ranges = 0x20; // CUtlVector<float>
}

public static class CMorphConstraint {
    public const nint m_sTargetMorph = 0x70; // CUtlString
    public const nint m_nSlaveChannel = 0x78; // int32_t
    public const nint m_flMin = 0x7C; // float
    public const nint m_flMax = 0x80; // float
}

public static class CMorphData {
    public const nint m_name = 0x0; // CUtlString
    public const nint m_morphRectDatas = 0x8; // CUtlVector<CMorphRectData>
}

public static class CMorphRectData {
    public const nint m_nXLeftDst = 0x0; // int16_t
    public const nint m_nYTopDst = 0x2; // int16_t
    public const nint m_flUWidthSrc = 0x4; // float
    public const nint m_flVHeightSrc = 0x8; // float
    public const nint m_bundleDatas = 0x10; // CUtlVector<CMorphBundleData>
}

public static class CMorphSetData {
    public const nint m_nWidth = 0x10; // int32_t
    public const nint m_nHeight = 0x14; // int32_t
    public const nint m_bundleTypes = 0x18; // CUtlVector<MorphBundleType_t>
    public const nint m_morphDatas = 0x30; // CUtlVector<CMorphData>
    public const nint m_pTextureAtlas = 0x48; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_FlexDesc = 0x50; // CUtlVector<CFlexDesc>
    public const nint m_FlexControllers = 0x68; // CUtlVector<CFlexController>
    public const nint m_FlexRules = 0x80; // CUtlVector<CFlexRule>
}

public static class CMotionDataSet {
    public const nint m_groups = 0x0; // CUtlVector<CMotionGraphGroup>
    public const nint m_nDimensionCount = 0x18; // int32_t
}

public static class CMotionGraph {
    public const nint m_paramSpans = 0x10; // CParamSpanUpdater
    public const nint m_tags = 0x28; // CUtlVector<TagSpan_t>
    public const nint m_pRootNode = 0x40; // CSmartPtr<CMotionNode>
    public const nint m_nParameterCount = 0x48; // int32_t
    public const nint m_nConfigStartIndex = 0x4C; // int32_t
    public const nint m_nConfigCount = 0x50; // int32_t
    public const nint m_bLoop = 0x54; // bool
}

public static class CMotionGraphConfig {
    public const nint m_paramValues = 0x0; // float[4]
    public const nint m_flDuration = 0x10; // float
    public const nint m_nMotionIndex = 0x14; // MotionIndex
    public const nint m_nSampleStart = 0x18; // int32_t
    public const nint m_nSampleCount = 0x1C; // int32_t
}

public static class CMotionGraphGroup {
    public const nint m_searchDB = 0x0; // CMotionSearchDB
    public const nint m_motionGraphs = 0xB8; // CUtlVector<CSmartPtr<CMotionGraph>>
    public const nint m_motionGraphConfigs = 0xD0; // CUtlVector<CMotionGraphConfig>
    public const nint m_sampleToConfig = 0xE8; // CUtlVector<int32_t>
    public const nint m_hIsActiveScript = 0x100; // AnimScriptHandle
}

public static class CMotionGraphUpdateNode {
    public const nint m_pMotionGraph = 0x58; // CSmartPtr<CMotionGraph>
}

public static class CMotionMatchingUpdateNode {
    public const nint m_dataSet = 0x58; // CMotionDataSet
    public const nint m_metrics = 0x78; // CUtlVector<CSmartPtr<CMotionMetricEvaluator>>
    public const nint m_weights = 0x90; // CUtlVector<float>
    public const nint m_bSearchEveryTick = 0xE0; // bool
    public const nint m_flSearchInterval = 0xE4; // float
    public const nint m_bSearchWhenClipEnds = 0xE8; // bool
    public const nint m_bSearchWhenGoalChanges = 0xE9; // bool
    public const nint m_blendCurve = 0xEC; // CBlendCurve
    public const nint m_flSampleRate = 0xF4; // float
    public const nint m_flBlendTime = 0xF8; // float
    public const nint m_bLockClipWhenWaning = 0xFC; // bool
    public const nint m_flSelectionThreshold = 0x100; // float
    public const nint m_flReselectionTimeWindow = 0x104; // float
    public const nint m_bEnableRotationCorrection = 0x108; // bool
    public const nint m_bGoalAssist = 0x109; // bool
    public const nint m_flGoalAssistDistance = 0x10C; // float
    public const nint m_flGoalAssistTolerance = 0x110; // float
    public const nint m_distanceScale_Damping = 0x118; // CAnimInputDamping
    public const nint m_flDistanceScale_OuterRadius = 0x128; // float
    public const nint m_flDistanceScale_InnerRadius = 0x12C; // float
    public const nint m_flDistanceScale_MaxScale = 0x130; // float
    public const nint m_flDistanceScale_MinScale = 0x134; // float
    public const nint m_bEnableDistanceScaling = 0x138; // bool
}

public static class CMotionMetricEvaluator {
    public const nint m_means = 0x18; // CUtlVector<float>
    public const nint m_standardDeviations = 0x30; // CUtlVector<float>
    public const nint m_flWeight = 0x48; // float
    public const nint m_nDimensionStartIndex = 0x4C; // int32_t
}

public static class CMotionNode {
    public const nint m_name = 0x18; // CUtlString
    public const nint m_id = 0x20; // AnimNodeID
}

public static class CMotionNodeBlend1D {
    public const nint m_blendItems = 0x28; // CUtlVector<MotionBlendItem>
    public const nint m_nParamIndex = 0x40; // int32_t
}

public static class CMotionNodeSequence {
    public const nint m_tags = 0x28; // CUtlVector<TagSpan_t>
    public const nint m_hSequence = 0x40; // HSequence
    public const nint m_flPlaybackSpeed = 0x44; // float
}

public static class CMotionSearchDB {
    public const nint m_rootNode = 0x0; // CMotionSearchNode
    public const nint m_residualQuantizer = 0x80; // CProductQuantizer
    public const nint m_codeIndices = 0xA0; // CUtlVector<MotionDBIndex>
}

public static class CMotionSearchNode {
    public const nint m_children = 0x0; // CUtlVector<CMotionSearchNode*>
    public const nint m_quantizer = 0x18; // CVectorQuantizer
    public const nint m_sampleCodes = 0x38; // CUtlVector<CUtlVector<SampleCode>>
    public const nint m_sampleIndices = 0x50; // CUtlVector<CUtlVector<int32_t>>
    public const nint m_selectableSamples = 0x68; // CUtlVector<int32_t>
}

public static class CMovementComponentUpdater {
    public const nint m_movementModes = 0x30; // CUtlVector<CMovementMode>
    public const nint m_motors = 0x48; // CUtlVector<CSmartPtr<CAnimMotorUpdaterBase>>
    public const nint m_facingDamping = 0x60; // CAnimInputDamping
    public const nint m_eDefaultFacingMode = 0x70; // FacingMode
    public const nint m_nDefaultMotorIndex = 0x7C; // int32_t
    public const nint m_bMoveVarsDisabled = 0x80; // bool
    public const nint m_bNetworkPath = 0x81; // bool
    public const nint m_bNetworkFacing = 0x82; // bool
    public const nint m_paramHandles = 0x83; // CAnimParamHandle[30]
}

public static class CMovementMode {
    public const nint m_name = 0x0; // CUtlString
    public const nint m_flSpeed = 0x8; // float
}

public static class CMoverUpdateNode {
    public const nint m_damping = 0x70; // CAnimInputDamping
    public const nint m_facingTarget = 0x80; // AnimValueSource
    public const nint m_hMoveVecParam = 0x84; // CAnimParamHandle
    public const nint m_hMoveHeadingParam = 0x86; // CAnimParamHandle
    public const nint m_hTurnToFaceParam = 0x88; // CAnimParamHandle
    public const nint m_flTurnToFaceOffset = 0x8C; // float
    public const nint m_flTurnToFaceLimit = 0x90; // float
    public const nint m_bAdditive = 0x94; // bool
    public const nint m_bApplyMovement = 0x95; // bool
    public const nint m_bOrientMovement = 0x96; // bool
    public const nint m_bApplyRotation = 0x97; // bool
    public const nint m_bLimitOnly = 0x98; // bool
}

public static class CParamSpanUpdater {
    public const nint m_spans = 0x0; // CUtlVector<ParamSpan_t>
}

public static class CParticleAnimTag {
    public const nint m_hParticleSystem = 0x38; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    public const nint m_particleSystemName = 0x40; // CUtlString
    public const nint m_configName = 0x48; // CUtlString
    public const nint m_bDetachFromOwner = 0x50; // bool
    public const nint m_bStopWhenTagEnds = 0x51; // bool
    public const nint m_bTagEndStopIsInstant = 0x52; // bool
    public const nint m_attachmentName = 0x58; // CUtlString
    public const nint m_attachmentType = 0x60; // ParticleAttachment_t
    public const nint m_attachmentCP1Name = 0x68; // CUtlString
    public const nint m_attachmentCP1Type = 0x70; // ParticleAttachment_t
}

public static class CPathAnimMotorUpdaterBase {
    public const nint m_bLockToPath = 0x20; // bool
}

public static class CPathHelperUpdateNode {
    public const nint m_flStoppingRadius = 0x68; // float
    public const nint m_flStoppingSpeedScale = 0x6C; // float
}

public static class CPathMetricEvaluator {
    public const nint m_pathTimeSamples = 0x50; // CUtlVector<float>
    public const nint m_flDistance = 0x68; // float
    public const nint m_bExtrapolateMovement = 0x6C; // bool
    public const nint m_flMinExtrapolationSpeed = 0x70; // float
}

public static class CPhysSurfaceProperties {
    public const nint m_name = 0x0; // CUtlString
    public const nint m_nameHash = 0x8; // uint32_t
    public const nint m_baseNameHash = 0xC; // uint32_t
    public const nint m_bHidden = 0x18; // bool
    public const nint m_description = 0x20; // CUtlString
    public const nint m_physics = 0x28; // CPhysSurfacePropertiesPhysics
    public const nint m_audioSounds = 0x48; // CPhysSurfacePropertiesSoundNames
    public const nint m_audioParams = 0x88; // CPhysSurfacePropertiesAudio
}

public static class CPhysSurfacePropertiesAudio {
    public const nint m_reflectivity = 0x0; // float
    public const nint m_hardnessFactor = 0x4; // float
    public const nint m_roughnessFactor = 0x8; // float
    public const nint m_roughThreshold = 0xC; // float
    public const nint m_hardThreshold = 0x10; // float
    public const nint m_hardVelocityThreshold = 0x14; // float
    public const nint m_flStaticImpactVolume = 0x18; // float
    public const nint m_flOcclusionFactor = 0x1C; // float
}

public static class CPhysSurfacePropertiesPhysics {
    public const nint m_friction = 0x0; // float
    public const nint m_elasticity = 0x4; // float
    public const nint m_density = 0x8; // float
    public const nint m_thickness = 0xC; // float
    public const nint m_softContactFrequency = 0x10; // float
    public const nint m_softContactDampingRatio = 0x14; // float
    public const nint m_wheelDrag = 0x18; // float
}

public static class CPhysSurfacePropertiesSoundNames {
    public const nint m_impactSoft = 0x0; // CUtlString
    public const nint m_impactHard = 0x8; // CUtlString
    public const nint m_scrapeSmooth = 0x10; // CUtlString
    public const nint m_scrapeRough = 0x18; // CUtlString
    public const nint m_bulletImpact = 0x20; // CUtlString
    public const nint m_rolling = 0x28; // CUtlString
    public const nint m_break = 0x30; // CUtlString
    public const nint m_strain = 0x38; // CUtlString
}

public static class CPlayerInputAnimMotorUpdater {
    public const nint m_sampleTimes = 0x20; // CUtlVector<float>
    public const nint m_flSpringConstant = 0x3C; // float
    public const nint m_flAnticipationDistance = 0x40; // float
    public const nint m_hAnticipationPosParam = 0x44; // CAnimParamHandle
    public const nint m_hAnticipationHeadingParam = 0x46; // CAnimParamHandle
    public const nint m_bUseAcceleration = 0x48; // bool
}

public static class CPoseHandle {
    public const nint m_nIndex = 0x0; // uint16_t
    public const nint m_eType = 0x2; // PoseType_t
}

public static class CProductQuantizer {
    public const nint m_subQuantizers = 0x0; // CUtlVector<CVectorQuantizer>
    public const nint m_nDimensions = 0x18; // int32_t
}

public static class CQuaternionAnimParameter {
    public const nint m_defaultValue = 0x60; // Quaternion
    public const nint m_bInterpolate = 0x70; // bool
}

public static class CRagdollAnimTag {
    public const nint m_nPoseControl = 0x38; // AnimPoseControl
    public const nint m_flFrequency = 0x3C; // float
    public const nint m_flDampingRatio = 0x40; // float
    public const nint m_flDecayDuration = 0x44; // float
    public const nint m_flDecayBias = 0x48; // float
    public const nint m_bDestroy = 0x4C; // bool
}

public static class CRagdollComponentUpdater {
    public const nint m_ragdollNodePaths = 0x30; // CUtlVector<CAnimNodePath>
    public const nint m_boneIndices = 0x48; // CUtlVector<int32_t>
    public const nint m_boneNames = 0x60; // CUtlVector<CUtlString>
    public const nint m_weightLists = 0x78; // CUtlVector<WeightList>
    public const nint m_flSpringFrequencyMin = 0x90; // float
    public const nint m_flSpringFrequencyMax = 0x94; // float
    public const nint m_flMaxStretch = 0x98; // float
}

public static class CRagdollUpdateNode {
    public const nint m_nWeightListIndex = 0x68; // int32_t
    public const nint m_poseControlMethod = 0x6C; // RagdollPoseControl
}

public static class CRenderBufferBinding {
    public const nint m_hBuffer = 0x0; // uint64_t
    public const nint m_nBindOffsetBytes = 0x10; // uint32_t
}

public static class CRenderMesh {
    public const nint m_sceneObjects = 0x10; // CUtlVectorFixedGrowable<CSceneObjectData>
    public const nint m_constraints = 0xA0; // CUtlVector<CBaseConstraint*>
    public const nint m_skeleton = 0xB8; // CRenderSkeleton
}

public static class CRenderSkeleton {
    public const nint m_bones = 0x0; // CUtlVector<RenderSkeletonBone_t>
    public const nint m_boneParents = 0x30; // CUtlVector<int32_t>
    public const nint m_nBoneWeightCount = 0x48; // int32_t
}

public static class CSceneObjectData {
    public const nint m_vMinBounds = 0x0; // Vector
    public const nint m_vMaxBounds = 0xC; // Vector
    public const nint m_drawCalls = 0x18; // CUtlVector<CMaterialDrawDescriptor>
    public const nint m_drawBounds = 0x30; // CUtlVector<AABB_t>
    public const nint m_meshlets = 0x48; // CUtlVector<CMeshletDescriptor>
    public const nint m_vTintColor = 0x60; // Vector4D
}

public static class CSelectorUpdateNode {
    public const nint m_children = 0x58; // CUtlVector<CAnimUpdateNodeRef>
    public const nint m_tags = 0x70; // CUtlVector<int8_t>
    public const nint m_blendCurve = 0x8C; // CBlendCurve
    public const nint m_flBlendTime = 0x94; // CAnimValue<float>
    public const nint m_hParameter = 0x9C; // CAnimParamHandle
    public const nint m_eTagBehavior = 0xA0; // SelectorTagBehavior_t
    public const nint m_bResetOnChange = 0xA4; // bool
    public const nint m_bSyncCyclesOnChange = 0xA5; // bool
}

public static class CSeqAutoLayer {
    public const nint m_nLocalReference = 0x0; // int16_t
    public const nint m_nLocalPose = 0x2; // int16_t
    public const nint m_flags = 0x4; // CSeqAutoLayerFlag
    public const nint m_start = 0xC; // float
    public const nint m_peak = 0x10; // float
    public const nint m_tail = 0x14; // float
    public const nint m_end = 0x18; // float
}

public static class CSeqAutoLayerFlag {
    public const nint m_bPost = 0x0; // bool
    public const nint m_bSpline = 0x1; // bool
    public const nint m_bXFade = 0x2; // bool
    public const nint m_bNoBlend = 0x3; // bool
    public const nint m_bLocal = 0x4; // bool
    public const nint m_bPose = 0x5; // bool
    public const nint m_bFetchFrame = 0x6; // bool
    public const nint m_bSubtract = 0x7; // bool
}

public static class CSeqBoneMaskList {
    public const nint m_sName = 0x0; // CBufferString
    public const nint m_nLocalBoneArray = 0x10; // CUtlVector<int16_t>
    public const nint m_flBoneWeightArray = 0x28; // CUtlVector<float>
    public const nint m_flDefaultMorphCtrlWeight = 0x40; // float
    public const nint m_morphCtrlWeightArray = 0x48; // CUtlVector<CUtlPair<CBufferString,float>>
}

public static class CSeqCmdLayer {
    public const nint m_cmd = 0x0; // int16_t
    public const nint m_nLocalReference = 0x2; // int16_t
    public const nint m_nLocalBonemask = 0x4; // int16_t
    public const nint m_nDstResult = 0x6; // int16_t
    public const nint m_nSrcResult = 0x8; // int16_t
    public const nint m_bSpline = 0xA; // bool
    public const nint m_flVar1 = 0xC; // float
    public const nint m_flVar2 = 0x10; // float
    public const nint m_nLineNumber = 0x14; // int16_t
}

public static class CSeqCmdSeqDesc {
    public const nint m_sName = 0x0; // CBufferString
    public const nint m_flags = 0x10; // CSeqSeqDescFlag
    public const nint m_transition = 0x1C; // CSeqTransition
    public const nint m_nFrameRangeSequence = 0x24; // int16_t
    public const nint m_nFrameCount = 0x26; // int16_t
    public const nint m_flFPS = 0x28; // float
    public const nint m_nSubCycles = 0x2C; // int16_t
    public const nint m_numLocalResults = 0x2E; // int16_t
    public const nint m_cmdLayerArray = 0x30; // CUtlVector<CSeqCmdLayer>
    public const nint m_eventArray = 0x48; // CUtlVector<CAnimEventDefinition>
    public const nint m_activityArray = 0x60; // CUtlVector<CAnimActivity>
    public const nint m_poseSettingArray = 0x78; // CUtlVector<CSeqPoseSetting>
}

public static class CSeqIKLock {
    public const nint m_flPosWeight = 0x0; // float
    public const nint m_flAngleWeight = 0x4; // float
    public const nint m_nLocalBone = 0x8; // int16_t
    public const nint m_bBonesOrientedAlongPositiveX = 0xA; // bool
}

public static class CSeqMultiFetch {
    public const nint m_flags = 0x0; // CSeqMultiFetchFlag
    public const nint m_localReferenceArray = 0x8; // CUtlVector<int16_t>
    public const nint m_nGroupSize = 0x20; // int32_t[2]
    public const nint m_nLocalPose = 0x28; // int32_t[2]
    public const nint m_poseKeyArray0 = 0x30; // CUtlVector<float>
    public const nint m_poseKeyArray1 = 0x48; // CUtlVector<float>
    public const nint m_nLocalCyclePoseParameter = 0x60; // int32_t
    public const nint m_bCalculatePoseParameters = 0x64; // bool
}

public static class CSeqMultiFetchFlag {
    public const nint m_bRealtime = 0x0; // bool
    public const nint m_bCylepose = 0x1; // bool
    public const nint m_b0D = 0x2; // bool
    public const nint m_b1D = 0x3; // bool
    public const nint m_b2D = 0x4; // bool
    public const nint m_b2D_TRI = 0x5; // bool
}

public static class CSeqPoseParamDesc {
    public const nint m_sName = 0x0; // CBufferString
    public const nint m_flStart = 0x10; // float
    public const nint m_flEnd = 0x14; // float
    public const nint m_flLoop = 0x18; // float
    public const nint m_bLooping = 0x1C; // bool
}

public static class CSeqPoseSetting {
    public const nint m_sPoseParameter = 0x0; // CBufferString
    public const nint m_sAttachment = 0x10; // CBufferString
    public const nint m_sReferenceSequence = 0x20; // CBufferString
    public const nint m_flValue = 0x30; // float
    public const nint m_bX = 0x34; // bool
    public const nint m_bY = 0x35; // bool
    public const nint m_bZ = 0x36; // bool
    public const nint m_eType = 0x38; // int32_t
}

public static class CSeqS1SeqDesc {
    public const nint m_sName = 0x0; // CBufferString
    public const nint m_flags = 0x10; // CSeqSeqDescFlag
    public const nint m_fetch = 0x20; // CSeqMultiFetch
    public const nint m_nLocalWeightlist = 0x88; // int32_t
    public const nint m_autoLayerArray = 0x90; // CUtlVector<CSeqAutoLayer>
    public const nint m_IKLockArray = 0xA8; // CUtlVector<CSeqIKLock>
    public const nint m_transition = 0xC0; // CSeqTransition
    public const nint m_SequenceKeys = 0xC8; // KeyValues3
    public const nint m_LegacyKeyValueText = 0xD8; // CBufferString
    public const nint m_activityArray = 0xE8; // CUtlVector<CAnimActivity>
    public const nint m_footMotion = 0x100; // CUtlVector<CFootMotion>
}

public static class CSeqScaleSet {
    public const nint m_sName = 0x0; // CBufferString
    public const nint m_bRootOffset = 0x10; // bool
    public const nint m_vRootOffset = 0x14; // Vector
    public const nint m_nLocalBoneArray = 0x20; // CUtlVector<int16_t>
    public const nint m_flBoneScaleArray = 0x38; // CUtlVector<float>
}

public static class CSeqSeqDescFlag {
    public const nint m_bLooping = 0x0; // bool
    public const nint m_bSnap = 0x1; // bool
    public const nint m_bAutoplay = 0x2; // bool
    public const nint m_bPost = 0x3; // bool
    public const nint m_bHidden = 0x4; // bool
    public const nint m_bMulti = 0x5; // bool
    public const nint m_bLegacyDelta = 0x6; // bool
    public const nint m_bLegacyWorldspace = 0x7; // bool
    public const nint m_bLegacyCyclepose = 0x8; // bool
    public const nint m_bLegacyRealtime = 0x9; // bool
    public const nint m_bModelDoc = 0xA; // bool
}

public static class CSeqSynthAnimDesc {
    public const nint m_sName = 0x0; // CBufferString
    public const nint m_flags = 0x10; // CSeqSeqDescFlag
    public const nint m_transition = 0x1C; // CSeqTransition
    public const nint m_nLocalBaseReference = 0x24; // int16_t
    public const nint m_nLocalBoneMask = 0x26; // int16_t
    public const nint m_activityArray = 0x28; // CUtlVector<CAnimActivity>
}

public static class CSeqTransition {
    public const nint m_flFadeInTime = 0x0; // float
    public const nint m_flFadeOutTime = 0x4; // float
}

public static class CSequenceFinishedAnimTag {
    public const nint m_sequenceName = 0x38; // CUtlString
}

public static class CSequenceGroupData {
    public const nint m_sName = 0x10; // CBufferString
    public const nint m_nFlags = 0x20; // uint32_t
    public const nint m_localSequenceNameArray = 0x28; // CUtlVector<CBufferString>
    public const nint m_localS1SeqDescArray = 0x40; // CUtlVector<CSeqS1SeqDesc>
    public const nint m_localMultiSeqDescArray = 0x58; // CUtlVector<CSeqS1SeqDesc>
    public const nint m_localSynthAnimDescArray = 0x70; // CUtlVector<CSeqSynthAnimDesc>
    public const nint m_localCmdSeqDescArray = 0x88; // CUtlVector<CSeqCmdSeqDesc>
    public const nint m_localBoneMaskArray = 0xA0; // CUtlVector<CSeqBoneMaskList>
    public const nint m_localScaleSetArray = 0xB8; // CUtlVector<CSeqScaleSet>
    public const nint m_localBoneNameArray = 0xD0; // CUtlVector<CBufferString>
    public const nint m_localNodeName = 0xE8; // CBufferString
    public const nint m_localPoseParamArray = 0xF8; // CUtlVector<CSeqPoseParamDesc>
    public const nint m_keyValues = 0x110; // KeyValues3
    public const nint m_localIKAutoplayLockArray = 0x120; // CUtlVector<CSeqIKLock>
}

public static class CSequenceUpdateNode {
    public const nint m_paramSpans = 0x60; // CParamSpanUpdater
    public const nint m_tags = 0x78; // CUtlVector<TagSpan_t>
    public const nint m_hSequence = 0x94; // HSequence
    public const nint m_playbackSpeed = 0x98; // float
    public const nint m_duration = 0x9C; // float
    public const nint m_bLoop = 0xA0; // bool
}

public static class CSetFacingUpdateNode {
    public const nint m_facingMode = 0x68; // FacingMode
    public const nint m_bResetChild = 0x6C; // bool
}

public static class CSetParameterActionUpdater {
    public const nint m_hParam = 0x18; // CAnimParamHandle
    public const nint m_value = 0x1A; // CAnimVariant
}

public static class CSingleFrameUpdateNode {
    public const nint m_actions = 0x58; // CUtlVector<CSmartPtr<CAnimActionUpdater>>
    public const nint m_hPoseCacheHandle = 0x70; // CPoseHandle
    public const nint m_hSequence = 0x74; // HSequence
    public const nint m_flCycle = 0x78; // float
}

public static class CSkeletalInputUpdateNode {
    public const nint m_fixedOpData = 0x58; // SkeletalInputOpFixedSettings_t
}

public static class CSlopeComponentUpdater {
    public const nint m_flTraceDistance = 0x34; // float
    public const nint m_hSlopeAngle = 0x38; // CAnimParamHandle
    public const nint m_hSlopeAngleFront = 0x3A; // CAnimParamHandle
    public const nint m_hSlopeAngleSide = 0x3C; // CAnimParamHandle
    public const nint m_hSlopeHeading = 0x3E; // CAnimParamHandle
    public const nint m_hSlopeNormal = 0x40; // CAnimParamHandle
    public const nint m_hSlopeNormal_WorldSpace = 0x42; // CAnimParamHandle
}

public static class CSlowDownOnSlopesUpdateNode {
    public const nint m_flSlowDownStrength = 0x68; // float
}

public static class CSolveIKChainUpdateNode {
    public const nint m_targetHandles = 0x68; // CUtlVector<CSolveIKTargetHandle_t>
    public const nint m_opFixedData = 0x80; // SolveIKChainPoseOpFixedSettings_t
}

public static class CSolveIKTargetHandle_t {
    public const nint m_positionHandle = 0x0; // CAnimParamHandle
    public const nint m_orientationHandle = 0x2; // CAnimParamHandle
}

public static class CSpeedScaleUpdateNode {
    public const nint m_paramIndex = 0x68; // CAnimParamHandle
}

public static class CStanceOverrideUpdateNode {
    public const nint m_footStanceInfo = 0x68; // CUtlVector<StanceInfo_t>
    public const nint m_pStanceSourceNode = 0x80; // CAnimUpdateNodeRef
    public const nint m_hParameter = 0x90; // CAnimParamHandle
    public const nint m_eMode = 0x94; // StanceOverrideMode
}

public static class CStanceScaleUpdateNode {
    public const nint m_hParam = 0x68; // CAnimParamHandle
}

public static class CStateActionUpdater {
    public const nint m_pAction = 0x0; // CSmartPtr<CAnimActionUpdater>
    public const nint m_eBehavior = 0x8; // StateActionBehavior
}

public static class CStateMachineComponentUpdater {
    public const nint m_stateMachine = 0x30; // CAnimStateMachineUpdater
}

public static class CStateMachineUpdateNode {
    public const nint m_stateMachine = 0x68; // CAnimStateMachineUpdater
    public const nint m_stateData = 0xC0; // CUtlVector<CStateNodeStateData>
    public const nint m_transitionData = 0xD8; // CUtlVector<CStateNodeTransitionData>
    public const nint m_bBlockWaningTags = 0xF4; // bool
    public const nint m_bLockStateWhenWaning = 0xF5; // bool
}

public static class CStateNodeStateData {
    public const nint m_pChild = 0x0; // CAnimUpdateNodeRef
    public const nint m_bExclusiveRootMotion = 0x0; // bitfield:1
}

public static class CStateNodeTransitionData {
    public const nint m_curve = 0x0; // CBlendCurve
    public const nint m_blendDuration = 0x8; // CAnimValue<float>
    public const nint m_resetCycleValue = 0x10; // CAnimValue<float>
    public const nint m_bReset = 0x0; // bitfield:1
    public const nint m_resetCycleOption = 0x0; // bitfield:3
}

public static class CStateUpdateData {
    public const nint m_name = 0x0; // CUtlString
    public const nint m_hScript = 0x8; // AnimScriptHandle
    public const nint m_transitionIndices = 0x10; // CUtlVector<int32_t>
    public const nint m_actions = 0x28; // CUtlVector<CStateActionUpdater>
    public const nint m_stateID = 0x40; // AnimStateID
    public const nint m_bIsStartState = 0x0; // bitfield:1
    public const nint m_bIsEndState = 0x0; // bitfield:1
    public const nint m_bIsPassthrough = 0x0; // bitfield:1
}

public static class CStaticPoseCache {
    public const nint m_poses = 0x10; // CUtlVector<CCachedPose>
    public const nint m_nBoneCount = 0x28; // int32_t
    public const nint m_nMorphCount = 0x2C; // int32_t
}

public static class CStepsRemainingMetricEvaluator {
    public const nint m_footIndices = 0x50; // CUtlVector<int32_t>
    public const nint m_flMinStepsRemaining = 0x68; // float
}

public static class CStopAtGoalUpdateNode {
    public const nint m_flOuterRadius = 0x6C; // float
    public const nint m_flInnerRadius = 0x70; // float
    public const nint m_flMaxScale = 0x74; // float
    public const nint m_flMinScale = 0x78; // float
    public const nint m_damping = 0x80; // CAnimInputDamping
}

public static class CSubtractUpdateNode {
    public const nint m_footMotionTiming = 0x8C; // BinaryNodeChildOption
    public const nint m_bApplyToFootMotion = 0x90; // bool
    public const nint m_bApplyChannelsSeparately = 0x91; // bool
    public const nint m_bUseModelSpace = 0x92; // bool
}

public static class CTiltTwistConstraint {
    public const nint m_nTargetAxis = 0x70; // int32_t
    public const nint m_nSlaveAxis = 0x74; // int32_t
}

public static class CTimeRemainingMetricEvaluator {
    public const nint m_bMatchByTimeRemaining = 0x50; // bool
    public const nint m_flMaxTimeRemaining = 0x54; // float
    public const nint m_bFilterByTimeRemaining = 0x58; // bool
    public const nint m_flMinTimeRemaining = 0x5C; // float
}

public static class CToggleComponentActionUpdater {
    public const nint m_componentID = 0x18; // AnimComponentID
    public const nint m_bSetEnabled = 0x1C; // bool
}

public static class CTransitionUpdateData {
    public const nint m_srcStateIndex = 0x0; // uint8_t
    public const nint m_destStateIndex = 0x1; // uint8_t
    public const nint m_bDisabled = 0x0; // bitfield:1
}

public static class CTurnHelperUpdateNode {
    public const nint m_facingTarget = 0x6C; // AnimValueSource
    public const nint m_turnStartTimeOffset = 0x70; // float
    public const nint m_turnDuration = 0x74; // float
    public const nint m_bMatchChildDuration = 0x78; // bool
    public const nint m_manualTurnOffset = 0x7C; // float
    public const nint m_bUseManualTurnOffset = 0x80; // bool
}

public static class CTwistConstraint {
    public const nint m_bInverse = 0x70; // bool
    public const nint m_qParentBindRotation = 0x80; // Quaternion
    public const nint m_qChildBindRotation = 0x90; // Quaternion
}

public static class CTwoBoneIKUpdateNode {
    public const nint m_opFixedData = 0x70; // TwoBoneIKSettings_t
}

public static class CUnaryUpdateNode {
    public const nint m_pChildNode = 0x58; // CAnimUpdateNodeRef
}

public static class CVPhysXSurfacePropertiesList {
    public const nint m_surfacePropertiesList = 0x0; // CUtlVector<CPhysSurfaceProperties*>
}

public static class CVRInputComponentUpdater {
    public const nint m_FingerCurl_Thumb = 0x34; // CAnimParamHandle
    public const nint m_FingerCurl_Index = 0x36; // CAnimParamHandle
    public const nint m_FingerCurl_Middle = 0x38; // CAnimParamHandle
    public const nint m_FingerCurl_Ring = 0x3A; // CAnimParamHandle
    public const nint m_FingerCurl_Pinky = 0x3C; // CAnimParamHandle
    public const nint m_FingerSplay_Thumb_Index = 0x3E; // CAnimParamHandle
    public const nint m_FingerSplay_Index_Middle = 0x40; // CAnimParamHandle
    public const nint m_FingerSplay_Middle_Ring = 0x42; // CAnimParamHandle
    public const nint m_FingerSplay_Ring_Pinky = 0x44; // CAnimParamHandle
}

public static class CVectorAnimParameter {
    public const nint m_defaultValue = 0x60; // Vector
    public const nint m_bInterpolate = 0x6C; // bool
}

public static class CVectorQuantizer {
    public const nint m_centroidVectors = 0x0; // CUtlVector<float>
    public const nint m_nCentroids = 0x18; // int32_t
    public const nint m_nDimensions = 0x1C; // int32_t
}

public static class CVirtualAnimParameter {
    public const nint m_expressionString = 0x50; // CUtlString
    public const nint m_eParamType = 0x58; // AnimParamType_t
}

public static class CVrSkeletalInputSettings {
    public const nint m_wristBones = 0x0; // CUtlVector<CWristBone>
    public const nint m_fingers = 0x18; // CUtlVector<CFingerChain>
    public const nint m_name = 0x30; // CUtlString
    public const nint m_outerKnuckle1 = 0x38; // CUtlString
    public const nint m_outerKnuckle2 = 0x40; // CUtlString
    public const nint m_eHand = 0x48; // AnimVRHand_t
}

public static class CWayPointHelperUpdateNode {
    public const nint m_flStartCycle = 0x6C; // float
    public const nint m_flEndCycle = 0x70; // float
    public const nint m_bOnlyGoals = 0x74; // bool
    public const nint m_bPreventOvershoot = 0x75; // bool
    public const nint m_bPreventUndershoot = 0x76; // bool
}

public static class CWristBone {
    public const nint m_name = 0x0; // CUtlString
    public const nint m_vForwardLS = 0x8; // Vector
    public const nint m_vUpLS = 0x14; // Vector
    public const nint m_vOffset = 0x20; // Vector
}

public static class ChainToSolveData_t {
    public const nint m_nChainIndex = 0x0; // int32_t
    public const nint m_SolverSettings = 0x4; // IKSolverSettings_t
    public const nint m_TargetSettings = 0x10; // IKTargetSettings_t
    public const nint m_DebugSetting = 0x38; // SolveIKChainAnimNodeDebugSetting
    public const nint m_flDebugNormalizedValue = 0x3C; // float
    public const nint m_vDebugOffset = 0x40; // VectorAligned
}

public static class ConfigIndex {
    public const nint m_nGroup = 0x0; // uint16_t
    public const nint m_nConfig = 0x2; // uint16_t
}

public static class FingerBone_t {
    public const nint m_boneIndex = 0x0; // int32_t
    public const nint m_hingeAxis = 0x4; // Vector
    public const nint m_vCapsulePos1 = 0x10; // Vector
    public const nint m_vCapsulePos2 = 0x1C; // Vector
    public const nint m_flMinAngle = 0x28; // float
    public const nint m_flMaxAngle = 0x2C; // float
    public const nint m_flRadius = 0x30; // float
}

public static class FingerChain_t {
    public const nint m_targets = 0x0; // CUtlVector<FingerSource_t>
    public const nint m_bones = 0x18; // CUtlVector<FingerBone_t>
    public const nint m_vTipOffset = 0x30; // Vector
    public const nint m_vSplayHingeAxis = 0x3C; // Vector
    public const nint m_tipParentBoneIndex = 0x48; // int32_t
    public const nint m_metacarpalBoneIndex = 0x4C; // int32_t
    public const nint m_flSplayMinAngle = 0x50; // float
    public const nint m_flSplayMaxAngle = 0x54; // float
    public const nint m_flFingerScaleRatio = 0x58; // float
}

public static class FingerSource_t {
    public const nint m_nFingerIndex = 0x0; // AnimVRFinger_t
    public const nint m_flFingerWeight = 0x4; // float
}

public static class FollowAttachmentSettings_t {
    public const nint m_attachment = 0x0; // CAnimAttachment
    public const nint m_boneIndex = 0x80; // int32_t
    public const nint m_bMatchTranslation = 0x84; // bool
    public const nint m_bMatchRotation = 0x85; // bool
}

public static class FootFixedData_t {
    public const nint m_vToeOffset = 0x0; // VectorAligned
    public const nint m_vHeelOffset = 0x10; // VectorAligned
    public const nint m_nTargetBoneIndex = 0x20; // int32_t
    public const nint m_nAnkleBoneIndex = 0x24; // int32_t
    public const nint m_nIKAnchorBoneIndex = 0x28; // int32_t
    public const nint m_ikChainIndex = 0x2C; // int32_t
    public const nint m_flMaxIKLength = 0x30; // float
    public const nint m_nFootIndex = 0x34; // int32_t
    public const nint m_nTagIndex = 0x38; // int32_t
    public const nint m_flMaxRotationLeft = 0x3C; // float
    public const nint m_flMaxRotationRight = 0x40; // float
}

public static class FootFixedSettings {
    public const nint m_traceSettings = 0x0; // TraceSettings_t
    public const nint m_vFootBaseBindPosePositionMS = 0x10; // VectorAligned
    public const nint m_flFootBaseLength = 0x20; // float
    public const nint m_flMaxRotationLeft = 0x24; // float
    public const nint m_flMaxRotationRight = 0x28; // float
    public const nint m_footstepLandedTagIndex = 0x2C; // int32_t
    public const nint m_bEnableTracing = 0x30; // bool
    public const nint m_flTraceAngleBlend = 0x34; // float
    public const nint m_nDisableTagIndex = 0x38; // int32_t
    public const nint m_nFootIndex = 0x3C; // int32_t
}

public static class FootLockPoseOpFixedSettings {
    public const nint m_footInfo = 0x0; // CUtlVector<FootFixedData_t>
    public const nint m_hipDampingSettings = 0x18; // CAnimInputDamping
    public const nint m_nHipBoneIndex = 0x28; // int32_t
    public const nint m_ikSolverType = 0x2C; // IKSolverType
    public const nint m_bApplyTilt = 0x30; // bool
    public const nint m_bApplyHipDrop = 0x31; // bool
    public const nint m_bAlwaysUseFallbackHinge = 0x32; // bool
    public const nint m_bApplyFootRotationLimits = 0x33; // bool
    public const nint m_bApplyLegTwistLimits = 0x34; // bool
    public const nint m_flMaxFootHeight = 0x38; // float
    public const nint m_flExtensionScale = 0x3C; // float
    public const nint m_flMaxLegTwist = 0x40; // float
    public const nint m_bEnableLockBreaking = 0x44; // bool
    public const nint m_flLockBreakTolerance = 0x48; // float
    public const nint m_flLockBlendTime = 0x4C; // float
    public const nint m_bEnableStretching = 0x50; // bool
    public const nint m_flMaxStretchAmount = 0x54; // float
    public const nint m_flStretchExtensionScale = 0x58; // float
}

public static class FootPinningPoseOpFixedData_t {
    public const nint m_footInfo = 0x0; // CUtlVector<FootFixedData_t>
    public const nint m_flBlendTime = 0x18; // float
    public const nint m_flLockBreakDistance = 0x1C; // float
    public const nint m_flMaxLegTwist = 0x20; // float
    public const nint m_nHipBoneIndex = 0x24; // int32_t
    public const nint m_bApplyLegTwistLimits = 0x28; // bool
    public const nint m_bApplyFootRotationLimits = 0x29; // bool
}

public static class FootStepTrigger {
    public const nint m_tags = 0x0; // CUtlVector<int32_t>
    public const nint m_nFootIndex = 0x18; // int32_t
    public const nint m_triggerPhase = 0x1C; // StepPhase
}

public static class HSequence {
    public const nint m_Value = 0x0; // int32_t
}

public static class HitReactFixedSettings_t {
    public const nint m_nWeightListIndex = 0x0; // int32_t
    public const nint m_nEffectedBoneCount = 0x4; // int32_t
    public const nint m_flMaxImpactForce = 0x8; // float
    public const nint m_flMinImpactForce = 0xC; // float
    public const nint m_flWhipImpactScale = 0x10; // float
    public const nint m_flCounterRotationScale = 0x14; // float
    public const nint m_flDistanceFadeScale = 0x18; // float
    public const nint m_flPropagationScale = 0x1C; // float
    public const nint m_flWhipDelay = 0x20; // float
    public const nint m_flSpringStrength = 0x24; // float
    public const nint m_flWhipSpringStrength = 0x28; // float
    public const nint m_flMaxAngleRadians = 0x2C; // float
    public const nint m_nHipBoneIndex = 0x30; // int32_t
    public const nint m_flHipBoneTranslationScale = 0x34; // float
    public const nint m_flHipDipSpringStrength = 0x38; // float
    public const nint m_flHipDipImpactScale = 0x3C; // float
    public const nint m_flHipDipDelay = 0x40; // float
}

public static class IKBoneNameAndIndex_t {
    public const nint m_Name = 0x0; // CUtlString
}

public static class IKDemoCaptureSettings_t {
    public const nint m_parentBoneName = 0x0; // CUtlString
    public const nint m_eMode = 0x8; // IKChannelMode
    public const nint m_ikChainName = 0x10; // CUtlString
    public const nint m_oneBoneStart = 0x18; // CUtlString
    public const nint m_oneBoneEnd = 0x20; // CUtlString
}

public static class IKSolverSettings_t {
    public const nint m_SolverType = 0x0; // IKSolverType
    public const nint m_nNumIterations = 0x4; // int32_t
}

public static class IKTargetSettings_t {
    public const nint m_TargetSource = 0x0; // IKTargetSource
    public const nint m_Bone = 0x8; // IKBoneNameAndIndex_t
    public const nint m_AnimgraphParameterNamePosition = 0x18; // AnimParamID
    public const nint m_AnimgraphParameterNameOrientation = 0x1C; // AnimParamID
    public const nint m_TargetCoordSystem = 0x20; // IKTargetCoordinateSystem
}

public static class JiggleBoneSettingsList_t {
    public const nint m_boneSettings = 0x0; // CUtlVector<JiggleBoneSettings_t>
}

public static class JiggleBoneSettings_t {
    public const nint m_nBoneIndex = 0x0; // int32_t
    public const nint m_flSpringStrength = 0x4; // float
    public const nint m_flMaxTimeStep = 0x8; // float
    public const nint m_flDamping = 0xC; // float
    public const nint m_vBoundsMaxLS = 0x10; // Vector
    public const nint m_vBoundsMinLS = 0x1C; // Vector
    public const nint m_eSimSpace = 0x28; // JiggleBoneSimSpace
}

public static class LookAtBone_t {
    public const nint m_index = 0x0; // int32_t
    public const nint m_weight = 0x4; // float
}

public static class LookAtOpFixedSettings_t {
    public const nint m_attachment = 0x0; // CAnimAttachment
    public const nint m_damping = 0x80; // CAnimInputDamping
    public const nint m_bones = 0x90; // CUtlVector<LookAtBone_t>
    public const nint m_flYawLimit = 0xA8; // float
    public const nint m_flPitchLimit = 0xAC; // float
    public const nint m_flHysteresisInnerAngle = 0xB0; // float
    public const nint m_flHysteresisOuterAngle = 0xB4; // float
    public const nint m_bRotateYawForward = 0xB8; // bool
    public const nint m_bMaintainUpDirection = 0xB9; // bool
    public const nint m_bTargetIsPosition = 0xBA; // bool
    public const nint m_bUseHysteresis = 0xBB; // bool
}

public static class MaterialGroup_t {
    public const nint m_name = 0x0; // CUtlString
    public const nint m_materials = 0x8; // CUtlVector<CStrongHandle<InfoForResourceTypeIMaterial2>>
}

public static class ModelBoneFlexDriverControl_t {
    public const nint m_nBoneComponent = 0x0; // ModelBoneFlexComponent_t
    public const nint m_flexController = 0x8; // CUtlString
    public const nint m_flexControllerToken = 0x10; // uint32_t
    public const nint m_flMin = 0x14; // float
    public const nint m_flMax = 0x18; // float
}

public static class ModelBoneFlexDriver_t {
    public const nint m_boneName = 0x0; // CUtlString
    public const nint m_boneNameToken = 0x8; // uint32_t
    public const nint m_controls = 0x10; // CUtlVector<ModelBoneFlexDriverControl_t>
}

public static class ModelSkeletonData_t {
    public const nint m_boneName = 0x0; // CUtlVector<CUtlString>
    public const nint m_nParent = 0x18; // CUtlVector<int16_t>
    public const nint m_boneSphere = 0x30; // CUtlVector<float>
    public const nint m_nFlag = 0x48; // CUtlVector<uint32_t>
    public const nint m_bonePosParent = 0x60; // CUtlVector<Vector>
    public const nint m_boneRotParent = 0x78; // CUtlVector<QuaternionStorage>
    public const nint m_boneScaleParent = 0x90; // CUtlVector<float>
}

public static class MoodAnimationLayer_t {
    public const nint m_sName = 0x0; // CUtlString
    public const nint m_bActiveListening = 0x8; // bool
    public const nint m_bActiveTalking = 0x9; // bool
    public const nint m_layerAnimations = 0x10; // CUtlVector<MoodAnimation_t>
    public const nint m_flIntensity = 0x28; // CRangeFloat
    public const nint m_flDurationScale = 0x30; // CRangeFloat
    public const nint m_bScaleWithInts = 0x38; // bool
    public const nint m_flNextStart = 0x3C; // CRangeFloat
    public const nint m_flStartOffset = 0x44; // CRangeFloat
    public const nint m_flEndOffset = 0x4C; // CRangeFloat
    public const nint m_flFadeIn = 0x54; // float
    public const nint m_flFadeOut = 0x58; // float
}

public static class MoodAnimation_t {
    public const nint m_sName = 0x0; // CUtlString
    public const nint m_flWeight = 0x8; // float
}

public static class MotionBlendItem {
    public const nint m_pChild = 0x0; // CSmartPtr<CMotionNode>
    public const nint m_flKeyValue = 0x8; // float
}

public static class MotionDBIndex {
    public const nint m_nIndex = 0x0; // uint32_t
}

public static class MotionIndex {
    public const nint m_nGroup = 0x0; // uint16_t
    public const nint m_nMotion = 0x2; // uint16_t
}

public static class ParamSpanSample_t {
    public const nint m_value = 0x0; // CAnimVariant
    public const nint m_flCycle = 0x14; // float
}

public static class ParamSpan_t {
    public const nint m_samples = 0x0; // CUtlVector<ParamSpanSample_t>
    public const nint m_hParam = 0x18; // CAnimParamHandle
    public const nint m_eParamType = 0x1A; // AnimParamType_t
    public const nint m_flStartCycle = 0x1C; // float
    public const nint m_flEndCycle = 0x20; // float
}

public static class PermModelDataAnimatedMaterialAttribute_t {
    public const nint m_AttributeName = 0x0; // CUtlString
    public const nint m_nNumChannels = 0x8; // int32_t
}

public static class PermModelData_t {
    public const nint m_name = 0x0; // CUtlString
    public const nint m_modelInfo = 0x8; // PermModelInfo_t
    public const nint m_ExtParts = 0x60; // CUtlVector<PermModelExtPart_t>
    public const nint m_refMeshes = 0x78; // CUtlVector<CStrongHandle<InfoForResourceTypeCRenderMesh>>
    public const nint m_refMeshGroupMasks = 0x90; // CUtlVector<uint64_t>
    public const nint m_refPhysGroupMasks = 0xA8; // CUtlVector<uint64_t>
    public const nint m_refLODGroupMasks = 0xC0; // CUtlVector<uint8_t>
    public const nint m_lodGroupSwitchDistances = 0xD8; // CUtlVector<float>
    public const nint m_refPhysicsData = 0xF0; // CUtlVector<CStrongHandle<InfoForResourceTypeCPhysAggregateData>>
    public const nint m_refPhysicsHitboxData = 0x108; // CUtlVector<CStrongHandle<InfoForResourceTypeCPhysAggregateData>>
    public const nint m_refAnimGroups = 0x120; // CUtlVector<CStrongHandle<InfoForResourceTypeCAnimationGroup>>
    public const nint m_refSequenceGroups = 0x138; // CUtlVector<CStrongHandle<InfoForResourceTypeCSequenceGroupData>>
    public const nint m_meshGroups = 0x150; // CUtlVector<CUtlString>
    public const nint m_materialGroups = 0x168; // CUtlVector<MaterialGroup_t>
    public const nint m_nDefaultMeshGroupMask = 0x180; // uint64_t
    public const nint m_modelSkeleton = 0x188; // ModelSkeletonData_t
    public const nint m_remappingTable = 0x230; // CUtlVector<int16_t>
    public const nint m_remappingTableStarts = 0x248; // CUtlVector<uint16_t>
    public const nint m_boneFlexDrivers = 0x260; // CUtlVector<ModelBoneFlexDriver_t>
    public const nint m_pModelConfigList = 0x278; // CModelConfigList*
    public const nint m_BodyGroupsHiddenInTools = 0x280; // CUtlVector<CUtlString>
    public const nint m_refAnimIncludeModels = 0x298; // CUtlVector<CStrongHandle<InfoForResourceTypeCModel>>
    public const nint m_AnimatedMaterialAttributes = 0x2B0; // CUtlVector<PermModelDataAnimatedMaterialAttribute_t>
}

public static class PermModelExtPart_t {
    public const nint m_Transform = 0x0; // CTransform
    public const nint m_Name = 0x20; // CUtlString
    public const nint m_nParent = 0x28; // int32_t
    public const nint m_refModel = 0x30; // CStrongHandle<InfoForResourceTypeCModel>
}

public static class PermModelInfo_t {
    public const nint m_nFlags = 0x0; // uint32_t
    public const nint m_vHullMin = 0x4; // Vector
    public const nint m_vHullMax = 0x10; // Vector
    public const nint m_vViewMin = 0x1C; // Vector
    public const nint m_vViewMax = 0x28; // Vector
    public const nint m_flMass = 0x34; // float
    public const nint m_vEyePosition = 0x38; // Vector
    public const nint m_flMaxEyeDeflection = 0x44; // float
    public const nint m_sSurfaceProperty = 0x48; // CUtlString
    public const nint m_keyValueText = 0x50; // CUtlString
}

public static class PhysSoftbodyDesc_t {
    public const nint m_ParticleBoneHash = 0x0; // CUtlVector<uint32_t>
    public const nint m_Particles = 0x18; // CUtlVector<RnSoftbodyParticle_t>
    public const nint m_Springs = 0x30; // CUtlVector<RnSoftbodySpring_t>
    public const nint m_Capsules = 0x48; // CUtlVector<RnSoftbodyCapsule_t>
    public const nint m_InitPose = 0x60; // CUtlVector<CTransform>
    public const nint m_ParticleBoneName = 0x78; // CUtlVector<CUtlString>
}

public static class RenderSkeletonBone_t {
    public const nint m_boneName = 0x0; // CUtlString
    public const nint m_parentName = 0x8; // CUtlString
    public const nint m_invBindPose = 0x10; // matrix3x4_t
    public const nint m_bbox = 0x40; // SkeletonBoneBounds_t
    public const nint m_flSphereRadius = 0x58; // float
}

public static class SampleCode {
    public const nint m_subCode = 0x0; // uint8_t[8]
}

public static class ScriptInfo_t {
    public const nint m_code = 0x0; // CUtlString
    public const nint m_paramsModified = 0x8; // CUtlVector<CAnimParamHandle>
    public const nint m_proxyReadParams = 0x20; // CUtlVector<int32_t>
    public const nint m_proxyWriteParams = 0x38; // CUtlVector<int32_t>
    public const nint m_eScriptType = 0x50; // AnimScriptType
}

public static class SkeletalInputOpFixedSettings_t {
    public const nint m_wristBones = 0x0; // CUtlVector<WristBone_t>
    public const nint m_fingers = 0x18; // CUtlVector<FingerChain_t>
    public const nint m_outerKnuckle1 = 0x30; // int32_t
    public const nint m_outerKnuckle2 = 0x34; // int32_t
    public const nint m_eHand = 0x38; // AnimVRHand_t
    public const nint m_eMotionRange = 0x3C; // AnimVRHandMotionRange_t
    public const nint m_eTransformSource = 0x40; // AnimVrBoneTransformSource_t
    public const nint m_bEnableIK = 0x44; // bool
    public const nint m_bEnableCollision = 0x45; // bool
}

public static class SkeletonBoneBounds_t {
    public const nint m_vecCenter = 0x0; // Vector
    public const nint m_vecSize = 0xC; // Vector
}

public static class SolveIKChainPoseOpFixedSettings_t {
    public const nint m_ChainsToSolveData = 0x0; // CUtlVector<ChainToSolveData_t>
    public const nint m_bMatchTargetOrientation = 0x18; // bool
}

public static class StanceInfo_t {
    public const nint m_vPosition = 0x0; // Vector
    public const nint m_flDirection = 0xC; // float
}

public static class TagSpan_t {
    public const nint m_tagIndex = 0x0; // int32_t
    public const nint m_startCycle = 0x4; // float
    public const nint m_endCycle = 0x8; // float
}

public static class TraceSettings_t {
    public const nint m_flTraceHeight = 0x0; // float
    public const nint m_flTraceRadius = 0x4; // float
}

public static class TwoBoneIKSettings_t {
    public const nint m_endEffectorType = 0x0; // IkEndEffectorType
    public const nint m_endEffectorAttachment = 0x10; // CAnimAttachment
    public const nint m_targetType = 0x90; // IkTargetType
    public const nint m_targetAttachment = 0xA0; // CAnimAttachment
    public const nint m_targetBoneIndex = 0x120; // int32_t
    public const nint m_hPositionParam = 0x124; // CAnimParamHandle
    public const nint m_hRotationParam = 0x126; // CAnimParamHandle
    public const nint m_bAlwaysUseFallbackHinge = 0x128; // bool
    public const nint m_vLsFallbackHingeAxis = 0x130; // VectorAligned
    public const nint m_nFixedBoneIndex = 0x140; // int32_t
    public const nint m_nMiddleBoneIndex = 0x144; // int32_t
    public const nint m_nEndBoneIndex = 0x148; // int32_t
    public const nint m_bMatchTargetOrientation = 0x14C; // bool
    public const nint m_bConstrainTwist = 0x14D; // bool
    public const nint m_flMaxTwist = 0x150; // float
}

public static class VPhysXAggregateData_t {
    public const nint m_nFlags = 0x0; // uint16_t
    public const nint m_nRefCounter = 0x2; // uint16_t
    public const nint m_bonesHash = 0x8; // CUtlVector<uint32_t>
    public const nint m_boneNames = 0x20; // CUtlVector<CUtlString>
    public const nint m_indexNames = 0x38; // CUtlVector<uint16_t>
    public const nint m_indexHash = 0x50; // CUtlVector<uint16_t>
    public const nint m_bindPose = 0x68; // CUtlVector<matrix3x4a_t>
    public const nint m_parts = 0x80; // CUtlVector<VPhysXBodyPart_t>
    public const nint m_constraints2 = 0x98; // CUtlVector<VPhysXConstraint2_t>
    public const nint m_joints = 0xB0; // CUtlVector<VPhysXJoint_t>
    public const nint m_pFeModel = 0xC8; // PhysFeModelDesc_t*
    public const nint m_boneParents = 0xD0; // CUtlVector<uint16_t>
    public const nint m_surfacePropertyHashes = 0xE8; // CUtlVector<uint32_t>
    public const nint m_collisionAttributes = 0x100; // CUtlVector<VPhysXCollisionAttributes_t>
    public const nint m_debugPartNames = 0x118; // CUtlVector<CUtlString>
    public const nint m_embeddedKeyvalues = 0x130; // CUtlString
}

public static class VPhysXBodyPart_t {
    public const nint m_nFlags = 0x0; // uint32_t
    public const nint m_flMass = 0x4; // float
    public const nint m_rnShape = 0x8; // VPhysics2ShapeDef_t
    public const nint m_nCollisionAttributeIndex = 0x80; // uint16_t
    public const nint m_nReserved = 0x82; // uint16_t
    public const nint m_flInertiaScale = 0x84; // float
    public const nint m_flLinearDamping = 0x88; // float
    public const nint m_flAngularDamping = 0x8C; // float
    public const nint m_bOverrideMassCenter = 0x90; // bool
    public const nint m_vMassCenterOverride = 0x94; // Vector
}

public static class VPhysXCollisionAttributes_t {
    public const nint m_CollisionGroup = 0x0; // uint32_t
    public const nint m_InteractAs = 0x8; // CUtlVector<uint32_t>
    public const nint m_InteractWith = 0x20; // CUtlVector<uint32_t>
    public const nint m_InteractExclude = 0x38; // CUtlVector<uint32_t>
    public const nint m_CollisionGroupString = 0x50; // CUtlString
    public const nint m_InteractAsStrings = 0x58; // CUtlVector<CUtlString>
    public const nint m_InteractWithStrings = 0x70; // CUtlVector<CUtlString>
    public const nint m_InteractExcludeStrings = 0x88; // CUtlVector<CUtlString>
}

public static class VPhysXConstraint2_t {
    public const nint m_nFlags = 0x0; // uint32_t
    public const nint m_nParent = 0x4; // uint16_t
    public const nint m_nChild = 0x6; // uint16_t
    public const nint m_params = 0x8; // VPhysXConstraintParams_t
}

public static class VPhysXConstraintParams_t {
    public const nint m_nType = 0x0; // int8_t
    public const nint m_nTranslateMotion = 0x1; // int8_t
    public const nint m_nRotateMotion = 0x2; // int8_t
    public const nint m_nFlags = 0x3; // int8_t
    public const nint m_anchor = 0x4; // Vector[2]
    public const nint m_axes = 0x1C; // QuaternionStorage[2]
    public const nint m_maxForce = 0x3C; // float
    public const nint m_maxTorque = 0x40; // float
    public const nint m_linearLimitValue = 0x44; // float
    public const nint m_linearLimitRestitution = 0x48; // float
    public const nint m_linearLimitSpring = 0x4C; // float
    public const nint m_linearLimitDamping = 0x50; // float
    public const nint m_twistLowLimitValue = 0x54; // float
    public const nint m_twistLowLimitRestitution = 0x58; // float
    public const nint m_twistLowLimitSpring = 0x5C; // float
    public const nint m_twistLowLimitDamping = 0x60; // float
    public const nint m_twistHighLimitValue = 0x64; // float
    public const nint m_twistHighLimitRestitution = 0x68; // float
    public const nint m_twistHighLimitSpring = 0x6C; // float
    public const nint m_twistHighLimitDamping = 0x70; // float
    public const nint m_swing1LimitValue = 0x74; // float
    public const nint m_swing1LimitRestitution = 0x78; // float
    public const nint m_swing1LimitSpring = 0x7C; // float
    public const nint m_swing1LimitDamping = 0x80; // float
    public const nint m_swing2LimitValue = 0x84; // float
    public const nint m_swing2LimitRestitution = 0x88; // float
    public const nint m_swing2LimitSpring = 0x8C; // float
    public const nint m_swing2LimitDamping = 0x90; // float
    public const nint m_goalPosition = 0x94; // Vector
    public const nint m_goalOrientation = 0xA0; // QuaternionStorage
    public const nint m_goalAngularVelocity = 0xB0; // Vector
    public const nint m_driveSpringX = 0xBC; // float
    public const nint m_driveSpringY = 0xC0; // float
    public const nint m_driveSpringZ = 0xC4; // float
    public const nint m_driveDampingX = 0xC8; // float
    public const nint m_driveDampingY = 0xCC; // float
    public const nint m_driveDampingZ = 0xD0; // float
    public const nint m_driveSpringTwist = 0xD4; // float
    public const nint m_driveSpringSwing = 0xD8; // float
    public const nint m_driveSpringSlerp = 0xDC; // float
    public const nint m_driveDampingTwist = 0xE0; // float
    public const nint m_driveDampingSwing = 0xE4; // float
    public const nint m_driveDampingSlerp = 0xE8; // float
    public const nint m_solverIterationCount = 0xEC; // int32_t
    public const nint m_projectionLinearTolerance = 0xF0; // float
    public const nint m_projectionAngularTolerance = 0xF4; // float
}

public static class VPhysXJoint_t {
    public const nint m_nType = 0x0; // uint16_t
    public const nint m_nBody1 = 0x2; // uint16_t
    public const nint m_nBody2 = 0x4; // uint16_t
    public const nint m_nFlags = 0x6; // uint16_t
    public const nint m_Frame1 = 0x10; // CTransform
    public const nint m_Frame2 = 0x30; // CTransform
    public const nint m_bEnableCollision = 0x50; // bool
    public const nint m_bEnableLinearLimit = 0x51; // bool
    public const nint m_LinearLimit = 0x54; // VPhysXRange_t
    public const nint m_bEnableLinearMotor = 0x5C; // bool
    public const nint m_vLinearTargetVelocity = 0x60; // Vector
    public const nint m_flMaxForce = 0x6C; // float
    public const nint m_bEnableSwingLimit = 0x70; // bool
    public const nint m_SwingLimit = 0x74; // VPhysXRange_t
    public const nint m_bEnableTwistLimit = 0x7C; // bool
    public const nint m_TwistLimit = 0x80; // VPhysXRange_t
    public const nint m_bEnableAngularMotor = 0x88; // bool
    public const nint m_vAngularTargetVelocity = 0x8C; // Vector
    public const nint m_flMaxTorque = 0x98; // float
    public const nint m_flLinearFrequency = 0x9C; // float
    public const nint m_flLinearDampingRatio = 0xA0; // float
    public const nint m_flAngularFrequency = 0xA4; // float
    public const nint m_flAngularDampingRatio = 0xA8; // float
    public const nint m_flFriction = 0xAC; // float
}

public static class VPhysXRange_t {
    public const nint m_flMin = 0x0; // float
    public const nint m_flMax = 0x4; // float
}

public static class VPhysics2ShapeDef_t {
    public const nint m_spheres = 0x0; // CUtlVector<RnSphereDesc_t>
    public const nint m_capsules = 0x18; // CUtlVector<RnCapsuleDesc_t>
    public const nint m_hulls = 0x30; // CUtlVector<RnHullDesc_t>
    public const nint m_meshes = 0x48; // CUtlVector<RnMeshDesc_t>
    public const nint m_CollisionAttributeIndices = 0x60; // CUtlVector<uint16_t>
}

public static class WeightList {
    public const nint m_name = 0x0; // CUtlString
    public const nint m_weights = 0x8; // CUtlVector<float>
}

public static class WristBone_t {
    public const nint m_xOffsetTransformMS = 0x0; // CTransform
    public const nint m_boneIndex = 0x20; // int32_t
}
```

`SDK/animationsystem.dll.hpp`:

```hpp
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.266748400 UTC
 */

#pragma once

#include <cstddef>

namespace AimMatrixOpFixedSettings_t {
    constexpr std::ptrdiff_t m_attachment = 0x0; // CAnimAttachment
    constexpr std::ptrdiff_t m_damping = 0x80; // CAnimInputDamping
    constexpr std::ptrdiff_t m_poseCacheHandles = 0x90; // CPoseHandle[10]
    constexpr std::ptrdiff_t m_eBlendMode = 0xB8; // AimMatrixBlendMode
    constexpr std::ptrdiff_t m_fAngleIncrement = 0xBC; // float
    constexpr std::ptrdiff_t m_nSequenceMaxFrame = 0xC0; // int32_t
    constexpr std::ptrdiff_t m_nBoneMaskIndex = 0xC4; // int32_t
    constexpr std::ptrdiff_t m_bTargetIsPosition = 0xC8; // bool
}

namespace AnimComponentID {
    constexpr std::ptrdiff_t m_id = 0x0; // uint32_t
}

namespace AnimNodeID {
    constexpr std::ptrdiff_t m_id = 0x0; // uint32_t
}

namespace AnimNodeOutputID {
    constexpr std::ptrdiff_t m_id = 0x0; // uint32_t
}

namespace AnimParamID {
    constexpr std::ptrdiff_t m_id = 0x0; // uint32_t
}

namespace AnimScriptHandle {
    constexpr std::ptrdiff_t m_id = 0x0; // uint32_t
}

namespace AnimStateID {
    constexpr std::ptrdiff_t m_id = 0x0; // uint32_t
}

namespace AnimTagID {
    constexpr std::ptrdiff_t m_id = 0x0; // uint32_t
}

namespace AnimationDecodeDebugDumpElement_t {
    constexpr std::ptrdiff_t m_nEntityIndex = 0x0; // int32_t
    constexpr std::ptrdiff_t m_modelName = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_poseParams = 0x10; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_decodeOps = 0x28; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_internalOps = 0x40; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_decodedAnims = 0x58; // CUtlVector<CUtlString>
}

namespace AnimationDecodeDebugDump_t {
    constexpr std::ptrdiff_t m_processingType = 0x0; // AnimationProcessingType_t
    constexpr std::ptrdiff_t m_elems = 0x8; // CUtlVector<AnimationDecodeDebugDumpElement_t>
}

namespace AnimationSnapshotBase_t {
    constexpr std::ptrdiff_t m_flRealTime = 0x0; // float
    constexpr std::ptrdiff_t m_rootToWorld = 0x10; // matrix3x4a_t
    constexpr std::ptrdiff_t m_bBonesInWorldSpace = 0x40; // bool
    constexpr std::ptrdiff_t m_boneSetupMask = 0x48; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_boneTransforms = 0x60; // CUtlVector<matrix3x4a_t>
    constexpr std::ptrdiff_t m_flexControllers = 0x78; // CUtlVector<float>
    constexpr std::ptrdiff_t m_SnapshotType = 0x90; // AnimationSnapshotType_t
    constexpr std::ptrdiff_t m_bHasDecodeDump = 0x94; // bool
    constexpr std::ptrdiff_t m_DecodeDump = 0x98; // AnimationDecodeDebugDumpElement_t
}

namespace AnimationSnapshot_t {
    constexpr std::ptrdiff_t m_nEntIndex = 0x110; // int32_t
    constexpr std::ptrdiff_t m_modelName = 0x118; // CUtlString
}

namespace AttachmentHandle_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // uint8_t
}

namespace BlendItem_t {
    constexpr std::ptrdiff_t m_tags = 0x0; // CUtlVector<TagSpan_t>
    constexpr std::ptrdiff_t m_pChild = 0x18; // CAnimUpdateNodeRef
    constexpr std::ptrdiff_t m_hSequence = 0x28; // HSequence
    constexpr std::ptrdiff_t m_vPos = 0x2C; // Vector2D
    constexpr std::ptrdiff_t m_flDuration = 0x34; // float
    constexpr std::ptrdiff_t m_bUseCustomDuration = 0x38; // bool
}

namespace BoneDemoCaptureSettings_t {
    constexpr std::ptrdiff_t m_boneName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_flChainLength = 0x8; // float
}

namespace CActionComponentUpdater {
    constexpr std::ptrdiff_t m_actions = 0x30; // CUtlVector<CSmartPtr<CAnimActionUpdater>>
}

namespace CAddUpdateNode {
    constexpr std::ptrdiff_t m_footMotionTiming = 0x8C; // BinaryNodeChildOption
    constexpr std::ptrdiff_t m_bApplyToFootMotion = 0x90; // bool
    constexpr std::ptrdiff_t m_bApplyChannelsSeparately = 0x91; // bool
    constexpr std::ptrdiff_t m_bUseModelSpace = 0x92; // bool
}

namespace CAimConstraint {
    constexpr std::ptrdiff_t m_qAimOffset = 0x70; // Quaternion
    constexpr std::ptrdiff_t m_nUpType = 0x80; // uint32_t
}

namespace CAimMatrixUpdateNode {
    constexpr std::ptrdiff_t m_opFixedSettings = 0x70; // AimMatrixOpFixedSettings_t
    constexpr std::ptrdiff_t m_target = 0x148; // AnimVectorSource
    constexpr std::ptrdiff_t m_paramIndex = 0x14C; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hSequence = 0x150; // HSequence
    constexpr std::ptrdiff_t m_bResetChild = 0x154; // bool
    constexpr std::ptrdiff_t m_bLockWhenWaning = 0x155; // bool
}

namespace CAnimActivity {
    constexpr std::ptrdiff_t m_name = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_nActivity = 0x10; // int32_t
    constexpr std::ptrdiff_t m_nFlags = 0x14; // int32_t
    constexpr std::ptrdiff_t m_nWeight = 0x18; // int32_t
}

namespace CAnimAttachment {
    constexpr std::ptrdiff_t m_influenceRotations = 0x0; // Quaternion[3]
    constexpr std::ptrdiff_t m_influenceOffsets = 0x30; // VectorAligned[3]
    constexpr std::ptrdiff_t m_influenceIndices = 0x60; // int32_t[3]
    constexpr std::ptrdiff_t m_influenceWeights = 0x6C; // float[3]
    constexpr std::ptrdiff_t m_numInfluences = 0x78; // uint8_t
}

namespace CAnimBone {
    constexpr std::ptrdiff_t m_name = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_parent = 0x10; // int32_t
    constexpr std::ptrdiff_t m_pos = 0x14; // Vector
    constexpr std::ptrdiff_t m_quat = 0x20; // QuaternionStorage
    constexpr std::ptrdiff_t m_scale = 0x30; // float
    constexpr std::ptrdiff_t m_qAlignment = 0x34; // QuaternionStorage
    constexpr std::ptrdiff_t m_flags = 0x44; // int32_t
}

namespace CAnimBoneDifference {
    constexpr std::ptrdiff_t m_name = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_parent = 0x10; // CBufferString
    constexpr std::ptrdiff_t m_posError = 0x20; // Vector
    constexpr std::ptrdiff_t m_bHasRotation = 0x2C; // bool
    constexpr std::ptrdiff_t m_bHasMovement = 0x2D; // bool
}

namespace CAnimComponentUpdater {
    constexpr std::ptrdiff_t m_name = 0x18; // CUtlString
    constexpr std::ptrdiff_t m_id = 0x20; // AnimComponentID
    constexpr std::ptrdiff_t m_networkMode = 0x24; // AnimNodeNetworkMode
    constexpr std::ptrdiff_t m_bStartEnabled = 0x28; // bool
}

namespace CAnimData {
    constexpr std::ptrdiff_t m_name = 0x10; // CBufferString
    constexpr std::ptrdiff_t m_animArray = 0x20; // CUtlVector<CAnimDesc>
    constexpr std::ptrdiff_t m_decoderArray = 0x38; // CUtlVector<CAnimDecoder>
    constexpr std::ptrdiff_t m_nMaxUniqueFrameIndex = 0x50; // int32_t
    constexpr std::ptrdiff_t m_segmentArray = 0x58; // CUtlVector<CAnimFrameSegment>
}

namespace CAnimDataChannelDesc {
    constexpr std::ptrdiff_t m_szChannelClass = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_szVariableName = 0x10; // CBufferString
    constexpr std::ptrdiff_t m_nFlags = 0x20; // int32_t
    constexpr std::ptrdiff_t m_nType = 0x24; // int32_t
    constexpr std::ptrdiff_t m_szGrouping = 0x28; // CBufferString
    constexpr std::ptrdiff_t m_szDescription = 0x38; // CBufferString
    constexpr std::ptrdiff_t m_szElementNameArray = 0x48; // CUtlVector<CBufferString>
    constexpr std::ptrdiff_t m_nElementIndexArray = 0x60; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_nElementMaskArray = 0x78; // CUtlVector<uint32_t>
}

namespace CAnimDecoder {
    constexpr std::ptrdiff_t m_szName = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_nVersion = 0x10; // int32_t
    constexpr std::ptrdiff_t m_nType = 0x14; // int32_t
}

namespace CAnimDemoCaptureSettings {
    constexpr std::ptrdiff_t m_rangeBoneChainLength = 0x0; // Vector2D
    constexpr std::ptrdiff_t m_rangeMaxSplineErrorRotation = 0x8; // Vector2D
    constexpr std::ptrdiff_t m_flMaxSplineErrorTranslation = 0x10; // float
    constexpr std::ptrdiff_t m_flMaxSplineErrorScale = 0x14; // float
    constexpr std::ptrdiff_t m_flIkRotation_MaxSplineError = 0x18; // float
    constexpr std::ptrdiff_t m_flIkTranslation_MaxSplineError = 0x1C; // float
    constexpr std::ptrdiff_t m_flMaxQuantizationErrorRotation = 0x20; // float
    constexpr std::ptrdiff_t m_flMaxQuantizationErrorTranslation = 0x24; // float
    constexpr std::ptrdiff_t m_flMaxQuantizationErrorScale = 0x28; // float
    constexpr std::ptrdiff_t m_flIkRotation_MaxQuantizationError = 0x2C; // float
    constexpr std::ptrdiff_t m_flIkTranslation_MaxQuantizationError = 0x30; // float
    constexpr std::ptrdiff_t m_baseSequence = 0x38; // CUtlString
    constexpr std::ptrdiff_t m_nBaseSequenceFrame = 0x40; // int32_t
    constexpr std::ptrdiff_t m_boneSelectionMode = 0x44; // EDemoBoneSelectionMode
    constexpr std::ptrdiff_t m_bones = 0x48; // CUtlVector<BoneDemoCaptureSettings_t>
    constexpr std::ptrdiff_t m_ikChains = 0x60; // CUtlVector<IKDemoCaptureSettings_t>
}

namespace CAnimDesc {
    constexpr std::ptrdiff_t m_name = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_flags = 0x10; // CAnimDesc_Flag
    constexpr std::ptrdiff_t fps = 0x18; // float
    constexpr std::ptrdiff_t m_Data = 0x20; // CAnimEncodedFrames
    constexpr std::ptrdiff_t m_movementArray = 0xF8; // CUtlVector<CAnimMovement>
    constexpr std::ptrdiff_t m_eventArray = 0x110; // CUtlVector<CAnimEventDefinition>
    constexpr std::ptrdiff_t m_activityArray = 0x128; // CUtlVector<CAnimActivity>
    constexpr std::ptrdiff_t m_hierarchyArray = 0x140; // CUtlVector<CAnimLocalHierarchy>
    constexpr std::ptrdiff_t framestalltime = 0x158; // float
    constexpr std::ptrdiff_t m_vecRootMin = 0x15C; // Vector
    constexpr std::ptrdiff_t m_vecRootMax = 0x168; // Vector
    constexpr std::ptrdiff_t m_vecBoneWorldMin = 0x178; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_vecBoneWorldMax = 0x190; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_sequenceParams = 0x1A8; // CAnimSequenceParams
}

namespace CAnimDesc_Flag {
    constexpr std::ptrdiff_t m_bLooping = 0x0; // bool
    constexpr std::ptrdiff_t m_bAllZeros = 0x1; // bool
    constexpr std::ptrdiff_t m_bHidden = 0x2; // bool
    constexpr std::ptrdiff_t m_bDelta = 0x3; // bool
    constexpr std::ptrdiff_t m_bLegacyWorldspace = 0x4; // bool
    constexpr std::ptrdiff_t m_bModelDoc = 0x5; // bool
    constexpr std::ptrdiff_t m_bImplicitSeqIgnoreDelta = 0x6; // bool
    constexpr std::ptrdiff_t m_bAnimGraphAdditive = 0x7; // bool
}

namespace CAnimEncodeDifference {
    constexpr std::ptrdiff_t m_boneArray = 0x0; // CUtlVector<CAnimBoneDifference>
    constexpr std::ptrdiff_t m_morphArray = 0x18; // CUtlVector<CAnimMorphDifference>
    constexpr std::ptrdiff_t m_userArray = 0x30; // CUtlVector<CAnimUserDifference>
    constexpr std::ptrdiff_t m_bHasRotationBitArray = 0x48; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_bHasMovementBitArray = 0x60; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_bHasMorphBitArray = 0x78; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_bHasUserBitArray = 0x90; // CUtlVector<uint8_t>
}

namespace CAnimEncodedFrames {
    constexpr std::ptrdiff_t m_fileName = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_nFrames = 0x10; // int32_t
    constexpr std::ptrdiff_t m_nFramesPerBlock = 0x14; // int32_t
    constexpr std::ptrdiff_t m_frameblockArray = 0x18; // CUtlVector<CAnimFrameBlockAnim>
    constexpr std::ptrdiff_t m_usageDifferences = 0x30; // CAnimEncodeDifference
}

namespace CAnimEnum {
    constexpr std::ptrdiff_t m_value = 0x0; // uint8_t
}

namespace CAnimEventDefinition {
    constexpr std::ptrdiff_t m_nFrame = 0x8; // int32_t
    constexpr std::ptrdiff_t m_flCycle = 0xC; // float
    constexpr std::ptrdiff_t m_EventData = 0x10; // KeyValues3
    constexpr std::ptrdiff_t m_sLegacyOptions = 0x20; // CBufferString
    constexpr std::ptrdiff_t m_sEventName = 0x30; // CGlobalSymbol
}

namespace CAnimFoot {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_vBallOffset = 0x8; // Vector
    constexpr std::ptrdiff_t m_vHeelOffset = 0x14; // Vector
    constexpr std::ptrdiff_t m_ankleBoneIndex = 0x20; // int32_t
    constexpr std::ptrdiff_t m_toeBoneIndex = 0x24; // int32_t
}

namespace CAnimFrameBlockAnim {
    constexpr std::ptrdiff_t m_nStartFrame = 0x0; // int32_t
    constexpr std::ptrdiff_t m_nEndFrame = 0x4; // int32_t
    constexpr std::ptrdiff_t m_segmentIndexArray = 0x8; // CUtlVector<int32_t>
}

namespace CAnimFrameSegment {
    constexpr std::ptrdiff_t m_nUniqueFrameIndex = 0x0; // int32_t
    constexpr std::ptrdiff_t m_nLocalElementMasks = 0x4; // uint32_t
    constexpr std::ptrdiff_t m_nLocalChannel = 0x8; // int32_t
    constexpr std::ptrdiff_t m_container = 0x10; // CUtlBinaryBlock
}

namespace CAnimGraphDebugReplay {
    constexpr std::ptrdiff_t m_animGraphFileName = 0x40; // CUtlString
    constexpr std::ptrdiff_t m_frameList = 0x48; // CUtlVector<CSmartPtr<CAnimReplayFrame>>
    constexpr std::ptrdiff_t m_startIndex = 0x60; // int32_t
    constexpr std::ptrdiff_t m_writeIndex = 0x64; // int32_t
    constexpr std::ptrdiff_t m_frameCount = 0x68; // int32_t
}

namespace CAnimGraphModelBinding {
    constexpr std::ptrdiff_t m_modelName = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_pSharedData = 0x10; // CSmartPtr<CAnimUpdateSharedData>
}

namespace CAnimGraphNetworkSettings {
    constexpr std::ptrdiff_t m_bNetworkingEnabled = 0x20; // bool
}

namespace CAnimGraphSettingsManager {
    constexpr std::ptrdiff_t m_settingsGroups = 0x18; // CUtlVector<CSmartPtr<CAnimGraphSettingsGroup>>
}

namespace CAnimInputDamping {
    constexpr std::ptrdiff_t m_speedFunction = 0x8; // DampingSpeedFunction
    constexpr std::ptrdiff_t m_fSpeedScale = 0xC; // float
}

namespace CAnimKeyData {
    constexpr std::ptrdiff_t m_name = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_boneArray = 0x10; // CUtlVector<CAnimBone>
    constexpr std::ptrdiff_t m_userArray = 0x28; // CUtlVector<CAnimUser>
    constexpr std::ptrdiff_t m_morphArray = 0x40; // CUtlVector<CBufferString>
    constexpr std::ptrdiff_t m_nChannelElements = 0x58; // int32_t
    constexpr std::ptrdiff_t m_dataChannelArray = 0x60; // CUtlVector<CAnimDataChannelDesc>
}

namespace CAnimLocalHierarchy {
    constexpr std::ptrdiff_t m_sBone = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_sNewParent = 0x10; // CBufferString
    constexpr std::ptrdiff_t m_nStartFrame = 0x20; // int32_t
    constexpr std::ptrdiff_t m_nPeakFrame = 0x24; // int32_t
    constexpr std::ptrdiff_t m_nTailFrame = 0x28; // int32_t
    constexpr std::ptrdiff_t m_nEndFrame = 0x2C; // int32_t
}

namespace CAnimMorphDifference {
    constexpr std::ptrdiff_t m_name = 0x0; // CBufferString
}

namespace CAnimMotorUpdaterBase {
    constexpr std::ptrdiff_t m_name = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_bDefault = 0x18; // bool
}

namespace CAnimMovement {
    constexpr std::ptrdiff_t endframe = 0x0; // int32_t
    constexpr std::ptrdiff_t motionflags = 0x4; // int32_t
    constexpr std::ptrdiff_t v0 = 0x8; // float
    constexpr std::ptrdiff_t v1 = 0xC; // float
    constexpr std::ptrdiff_t angle = 0x10; // float
    constexpr std::ptrdiff_t vector = 0x14; // Vector
    constexpr std::ptrdiff_t position = 0x20; // Vector
}

namespace CAnimNodePath {
    constexpr std::ptrdiff_t m_path = 0x0; // AnimNodeID[11]
    constexpr std::ptrdiff_t m_nCount = 0x2C; // int32_t
}

namespace CAnimParamHandle {
    constexpr std::ptrdiff_t m_type = 0x0; // AnimParamType_t
    constexpr std::ptrdiff_t m_index = 0x1; // uint8_t
}

namespace CAnimParamHandleMap {
    constexpr std::ptrdiff_t m_list = 0x0; // CUtlHashtable<uint16_t,int16_t>
}

namespace CAnimParameterBase {
    constexpr std::ptrdiff_t m_name = 0x18; // CGlobalSymbol
    constexpr std::ptrdiff_t m_group = 0x20; // CUtlString
    constexpr std::ptrdiff_t m_id = 0x28; // AnimParamID
    constexpr std::ptrdiff_t m_componentName = 0x40; // CUtlString
    constexpr std::ptrdiff_t m_bNetworkingRequested = 0x4C; // bool
    constexpr std::ptrdiff_t m_bIsReferenced = 0x4D; // bool
}

namespace CAnimParameterManagerUpdater {
    constexpr std::ptrdiff_t m_parameters = 0x18; // CUtlVector<CSmartPtr<CAnimParameterBase>>
    constexpr std::ptrdiff_t m_idToIndexMap = 0x30; // CUtlHashtable<AnimParamID,int32_t>
    constexpr std::ptrdiff_t m_nameToIndexMap = 0x50; // CUtlHashtable<CUtlString,int32_t>
    constexpr std::ptrdiff_t m_indexToHandle = 0x70; // CUtlVector<CAnimParamHandle>
    constexpr std::ptrdiff_t m_autoResetParams = 0x88; // CUtlVector<CUtlPair<CAnimParamHandle,CAnimVariant>>
    constexpr std::ptrdiff_t m_autoResetMap = 0xA0; // CUtlHashtable<CAnimParamHandle,int16_t>
}

namespace CAnimReplayFrame {
    constexpr std::ptrdiff_t m_inputDataBlocks = 0x10; // CUtlVector<CUtlBinaryBlock>
    constexpr std::ptrdiff_t m_instanceData = 0x28; // CUtlBinaryBlock
    constexpr std::ptrdiff_t m_startingLocalToWorldTransform = 0x40; // CTransform
    constexpr std::ptrdiff_t m_localToWorldTransform = 0x60; // CTransform
    constexpr std::ptrdiff_t m_timeStamp = 0x80; // float
}

namespace CAnimScriptComponentUpdater {
    constexpr std::ptrdiff_t m_hScript = 0x30; // AnimScriptHandle
}

namespace CAnimScriptManager {
    constexpr std::ptrdiff_t m_scriptInfo = 0x10; // CUtlVector<ScriptInfo_t>
}

namespace CAnimSequenceParams {
    constexpr std::ptrdiff_t m_flFadeInTime = 0x0; // float
    constexpr std::ptrdiff_t m_flFadeOutTime = 0x4; // float
}

namespace CAnimSkeleton {
    constexpr std::ptrdiff_t m_localSpaceTransforms = 0x10; // CUtlVector<CTransform>
    constexpr std::ptrdiff_t m_modelSpaceTransforms = 0x28; // CUtlVector<CTransform>
    constexpr std::ptrdiff_t m_boneNames = 0x40; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_children = 0x58; // CUtlVector<CUtlVector<int32_t>>
    constexpr std::ptrdiff_t m_parents = 0x70; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_feet = 0x88; // CUtlVector<CAnimFoot>
    constexpr std::ptrdiff_t m_morphNames = 0xA0; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_lodBoneCounts = 0xB8; // CUtlVector<int32_t>
}

namespace CAnimStateMachineUpdater {
    constexpr std::ptrdiff_t m_states = 0x8; // CUtlVector<CStateUpdateData>
    constexpr std::ptrdiff_t m_transitions = 0x20; // CUtlVector<CTransitionUpdateData>
    constexpr std::ptrdiff_t m_startStateIndex = 0x50; // int32_t
}

namespace CAnimTagBase {
    constexpr std::ptrdiff_t m_name = 0x18; // CGlobalSymbol
    constexpr std::ptrdiff_t m_group = 0x20; // CGlobalSymbol
    constexpr std::ptrdiff_t m_tagID = 0x28; // AnimTagID
    constexpr std::ptrdiff_t m_bIsReferenced = 0x2C; // bool
}

namespace CAnimTagManagerUpdater {
    constexpr std::ptrdiff_t m_tags = 0x18; // CUtlVector<CSmartPtr<CAnimTagBase>>
}

namespace CAnimUpdateNodeBase {
    constexpr std::ptrdiff_t m_nodePath = 0x18; // CAnimNodePath
    constexpr std::ptrdiff_t m_networkMode = 0x48; // AnimNodeNetworkMode
    constexpr std::ptrdiff_t m_name = 0x50; // CUtlString
}

namespace CAnimUpdateNodeRef {
    constexpr std::ptrdiff_t m_nodeIndex = 0x8; // int32_t
}

namespace CAnimUpdateSharedData {
    constexpr std::ptrdiff_t m_nodes = 0x10; // CUtlVector<CSmartPtr<CAnimUpdateNodeBase>>
    constexpr std::ptrdiff_t m_nodeIndexMap = 0x28; // CUtlHashtable<CAnimNodePath,int32_t>
    constexpr std::ptrdiff_t m_components = 0x48; // CUtlVector<CSmartPtr<CAnimComponentUpdater>>
    constexpr std::ptrdiff_t m_pParamListUpdater = 0x60; // CSmartPtr<CAnimParameterManagerUpdater>
    constexpr std::ptrdiff_t m_pTagManagerUpdater = 0x68; // CSmartPtr<CAnimTagManagerUpdater>
    constexpr std::ptrdiff_t m_scriptManager = 0x70; // CSmartPtr<CAnimScriptManager>
    constexpr std::ptrdiff_t m_settings = 0x78; // CAnimGraphSettingsManager
    constexpr std::ptrdiff_t m_pStaticPoseCache = 0xA8; // CSmartPtr<CStaticPoseCacheBuilder>
    constexpr std::ptrdiff_t m_pSkeleton = 0xB0; // CSmartPtr<CAnimSkeleton>
    constexpr std::ptrdiff_t m_rootNodePath = 0xB8; // CAnimNodePath
}

namespace CAnimUser {
    constexpr std::ptrdiff_t m_name = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_nType = 0x10; // int32_t
}

namespace CAnimUserDifference {
    constexpr std::ptrdiff_t m_name = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_nType = 0x10; // int32_t
}

namespace CAnimationGraphVisualizerAxis {
    constexpr std::ptrdiff_t m_xWsTransform = 0x40; // CTransform
    constexpr std::ptrdiff_t m_flAxisSize = 0x60; // float
}

namespace CAnimationGraphVisualizerLine {
    constexpr std::ptrdiff_t m_vWsPositionStart = 0x40; // VectorAligned
    constexpr std::ptrdiff_t m_vWsPositionEnd = 0x50; // VectorAligned
    constexpr std::ptrdiff_t m_Color = 0x60; // Color
}

namespace CAnimationGraphVisualizerPie {
    constexpr std::ptrdiff_t m_vWsCenter = 0x40; // VectorAligned
    constexpr std::ptrdiff_t m_vWsStart = 0x50; // VectorAligned
    constexpr std::ptrdiff_t m_vWsEnd = 0x60; // VectorAligned
    constexpr std::ptrdiff_t m_Color = 0x70; // Color
}

namespace CAnimationGraphVisualizerPrimitiveBase {
    constexpr std::ptrdiff_t m_Type = 0x8; // CAnimationGraphVisualizerPrimitiveType
    constexpr std::ptrdiff_t m_OwningAnimNodePaths = 0xC; // AnimNodeID[11]
    constexpr std::ptrdiff_t m_nOwningAnimNodePathCount = 0x38; // int32_t
}

namespace CAnimationGraphVisualizerSphere {
    constexpr std::ptrdiff_t m_vWsPosition = 0x40; // VectorAligned
    constexpr std::ptrdiff_t m_flRadius = 0x50; // float
    constexpr std::ptrdiff_t m_Color = 0x54; // Color
}

namespace CAnimationGraphVisualizerText {
    constexpr std::ptrdiff_t m_vWsPosition = 0x40; // VectorAligned
    constexpr std::ptrdiff_t m_Color = 0x50; // Color
    constexpr std::ptrdiff_t m_Text = 0x58; // CUtlString
}

namespace CAnimationGroup {
    constexpr std::ptrdiff_t m_nFlags = 0x10; // uint32_t
    constexpr std::ptrdiff_t m_name = 0x18; // CBufferString
    constexpr std::ptrdiff_t m_localHAnimArray_Handle = 0x60; // CUtlVector<CStrongHandle<InfoForResourceTypeCAnimData>>
    constexpr std::ptrdiff_t m_includedGroupArray_Handle = 0x78; // CUtlVector<CStrongHandle<InfoForResourceTypeCAnimationGroup>>
    constexpr std::ptrdiff_t m_directHSeqGroup_Handle = 0x90; // CStrongHandle<InfoForResourceTypeCSequenceGroupData>
    constexpr std::ptrdiff_t m_decodeKey = 0x98; // CAnimKeyData
    constexpr std::ptrdiff_t m_szScripts = 0x110; // CUtlVector<CBufferString>
}

namespace CAttachment {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_influenceNames = 0x8; // CUtlString[3]
    constexpr std::ptrdiff_t m_vInfluenceRotations = 0x20; // Quaternion[3]
    constexpr std::ptrdiff_t m_vInfluenceOffsets = 0x50; // Vector[3]
    constexpr std::ptrdiff_t m_influenceWeights = 0x74; // float[3]
    constexpr std::ptrdiff_t m_bInfluenceRootTransform = 0x80; // bool[3]
    constexpr std::ptrdiff_t m_nInfluences = 0x83; // uint8_t
    constexpr std::ptrdiff_t m_bIgnoreRotation = 0x84; // bool
}

namespace CAudioAnimTag {
    constexpr std::ptrdiff_t m_clipName = 0x38; // CUtlString
    constexpr std::ptrdiff_t m_attachmentName = 0x40; // CUtlString
    constexpr std::ptrdiff_t m_flVolume = 0x48; // float
    constexpr std::ptrdiff_t m_bStopWhenTagEnds = 0x4C; // bool
    constexpr std::ptrdiff_t m_bStopWhenGraphEnds = 0x4D; // bool
    constexpr std::ptrdiff_t m_bPlayOnServer = 0x4E; // bool
    constexpr std::ptrdiff_t m_bPlayOnClient = 0x4F; // bool
}

namespace CBaseConstraint {
    constexpr std::ptrdiff_t m_name = 0x28; // CUtlString
    constexpr std::ptrdiff_t m_vUpVector = 0x30; // Vector
    constexpr std::ptrdiff_t m_slaves = 0x40; // CUtlVector<CConstraintSlave>
    constexpr std::ptrdiff_t m_targets = 0x58; // CUtlVector<CConstraintTarget>
}

namespace CBinaryUpdateNode {
    constexpr std::ptrdiff_t m_pChild1 = 0x58; // CAnimUpdateNodeRef
    constexpr std::ptrdiff_t m_pChild2 = 0x68; // CAnimUpdateNodeRef
    constexpr std::ptrdiff_t m_timingBehavior = 0x78; // BinaryNodeTiming
    constexpr std::ptrdiff_t m_flTimingBlend = 0x7C; // float
    constexpr std::ptrdiff_t m_bResetChild1 = 0x80; // bool
    constexpr std::ptrdiff_t m_bResetChild2 = 0x81; // bool
}

namespace CBlend2DUpdateNode {
    constexpr std::ptrdiff_t m_items = 0x60; // CUtlVector<BlendItem_t>
    constexpr std::ptrdiff_t m_tags = 0x78; // CUtlVector<TagSpan_t>
    constexpr std::ptrdiff_t m_paramSpans = 0x90; // CParamSpanUpdater
    constexpr std::ptrdiff_t m_nodeItemIndices = 0xA8; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_damping = 0xC0; // CAnimInputDamping
    constexpr std::ptrdiff_t m_blendSourceX = 0xD0; // AnimValueSource
    constexpr std::ptrdiff_t m_paramX = 0xD4; // CAnimParamHandle
    constexpr std::ptrdiff_t m_blendSourceY = 0xD8; // AnimValueSource
    constexpr std::ptrdiff_t m_paramY = 0xDC; // CAnimParamHandle
    constexpr std::ptrdiff_t m_eBlendMode = 0xE0; // Blend2DMode
    constexpr std::ptrdiff_t m_playbackSpeed = 0xE4; // float
    constexpr std::ptrdiff_t m_bLoop = 0xE8; // bool
    constexpr std::ptrdiff_t m_bLockBlendOnReset = 0xE9; // bool
    constexpr std::ptrdiff_t m_bLockWhenWaning = 0xEA; // bool
    constexpr std::ptrdiff_t m_bAnimEventsAndTagsOnMostWeightedOnly = 0xEB; // bool
}

namespace CBlendCurve {
    constexpr std::ptrdiff_t m_flControlPoint1 = 0x0; // float
    constexpr std::ptrdiff_t m_flControlPoint2 = 0x4; // float
}

namespace CBlendUpdateNode {
    constexpr std::ptrdiff_t m_children = 0x60; // CUtlVector<CAnimUpdateNodeRef>
    constexpr std::ptrdiff_t m_sortedOrder = 0x78; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_targetValues = 0x90; // CUtlVector<float>
    constexpr std::ptrdiff_t m_blendValueSource = 0xAC; // AnimValueSource
    constexpr std::ptrdiff_t m_paramIndex = 0xB0; // CAnimParamHandle
    constexpr std::ptrdiff_t m_damping = 0xB8; // CAnimInputDamping
    constexpr std::ptrdiff_t m_blendKeyType = 0xC8; // BlendKeyType
    constexpr std::ptrdiff_t m_bLockBlendOnReset = 0xCC; // bool
    constexpr std::ptrdiff_t m_bSyncCycles = 0xCD; // bool
    constexpr std::ptrdiff_t m_bLoop = 0xCE; // bool
    constexpr std::ptrdiff_t m_bLockWhenWaning = 0xCF; // bool
}

namespace CBodyGroupAnimTag {
    constexpr std::ptrdiff_t m_nPriority = 0x38; // int32_t
    constexpr std::ptrdiff_t m_bodyGroupSettings = 0x40; // CUtlVector<CBodyGroupSetting>
}

namespace CBodyGroupSetting {
    constexpr std::ptrdiff_t m_BodyGroupName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nBodyGroupOption = 0x8; // int32_t
}

namespace CBoneConstraintDotToMorph {
    constexpr std::ptrdiff_t m_sBoneName = 0x28; // CUtlString
    constexpr std::ptrdiff_t m_sTargetBoneName = 0x30; // CUtlString
    constexpr std::ptrdiff_t m_sMorphChannelName = 0x38; // CUtlString
    constexpr std::ptrdiff_t m_flRemap = 0x40; // float[4]
}

namespace CBoneConstraintPoseSpaceBone {
    constexpr std::ptrdiff_t m_inputList = 0x70; // CUtlVector<CBoneConstraintPoseSpaceBone::Input_t>
}

namespace CBoneConstraintPoseSpaceBone_Input_t {
    constexpr std::ptrdiff_t m_inputValue = 0x0; // Vector
    constexpr std::ptrdiff_t m_outputTransformList = 0x10; // CUtlVector<CTransform>
}

namespace CBoneConstraintPoseSpaceMorph {
    constexpr std::ptrdiff_t m_sBoneName = 0x28; // CUtlString
    constexpr std::ptrdiff_t m_sAttachmentName = 0x30; // CUtlString
    constexpr std::ptrdiff_t m_outputMorph = 0x38; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_inputList = 0x50; // CUtlVector<CBoneConstraintPoseSpaceMorph::Input_t>
    constexpr std::ptrdiff_t m_bClamp = 0x68; // bool
}

namespace CBoneConstraintPoseSpaceMorph_Input_t {
    constexpr std::ptrdiff_t m_inputValue = 0x0; // Vector
    constexpr std::ptrdiff_t m_outputWeightList = 0x10; // CUtlVector<float>
}

namespace CBoneMaskUpdateNode {
    constexpr std::ptrdiff_t m_nWeightListIndex = 0x8C; // int32_t
    constexpr std::ptrdiff_t m_flRootMotionBlend = 0x90; // float
    constexpr std::ptrdiff_t m_blendSpace = 0x94; // BoneMaskBlendSpace
    constexpr std::ptrdiff_t m_footMotionTiming = 0x98; // BinaryNodeChildOption
    constexpr std::ptrdiff_t m_bUseBlendScale = 0x9C; // bool
    constexpr std::ptrdiff_t m_blendValueSource = 0xA0; // AnimValueSource
    constexpr std::ptrdiff_t m_hBlendParameter = 0xA4; // CAnimParamHandle
}

namespace CBonePositionMetricEvaluator {
    constexpr std::ptrdiff_t m_nBoneIndex = 0x50; // int32_t
}

namespace CBoneVelocityMetricEvaluator {
    constexpr std::ptrdiff_t m_nBoneIndex = 0x50; // int32_t
}

namespace CBoolAnimParameter {
    constexpr std::ptrdiff_t m_bDefaultValue = 0x60; // bool
}

namespace CCPPScriptComponentUpdater {
    constexpr std::ptrdiff_t m_scriptsToRun = 0x30; // CUtlVector<CGlobalSymbol>
}

namespace CCachedPose {
    constexpr std::ptrdiff_t m_transforms = 0x8; // CUtlVector<CTransform>
    constexpr std::ptrdiff_t m_morphWeights = 0x20; // CUtlVector<float>
    constexpr std::ptrdiff_t m_hSequence = 0x38; // HSequence
    constexpr std::ptrdiff_t m_flCycle = 0x3C; // float
}

namespace CChoiceUpdateNode {
    constexpr std::ptrdiff_t m_children = 0x58; // CUtlVector<CAnimUpdateNodeRef>
    constexpr std::ptrdiff_t m_weights = 0x70; // CUtlVector<float>
    constexpr std::ptrdiff_t m_blendTimes = 0x88; // CUtlVector<float>
    constexpr std::ptrdiff_t m_choiceMethod = 0xA0; // ChoiceMethod
    constexpr std::ptrdiff_t m_choiceChangeMethod = 0xA4; // ChoiceChangeMethod
    constexpr std::ptrdiff_t m_blendMethod = 0xA8; // ChoiceBlendMethod
    constexpr std::ptrdiff_t m_blendTime = 0xAC; // float
    constexpr std::ptrdiff_t m_bCrossFade = 0xB0; // bool
    constexpr std::ptrdiff_t m_bResetChosen = 0xB1; // bool
    constexpr std::ptrdiff_t m_bDontResetSameSelection = 0xB2; // bool
}

namespace CClothSettingsAnimTag {
    constexpr std::ptrdiff_t m_flStiffness = 0x38; // float
    constexpr std::ptrdiff_t m_flEaseIn = 0x3C; // float
    constexpr std::ptrdiff_t m_flEaseOut = 0x40; // float
    constexpr std::ptrdiff_t m_nVertexSet = 0x48; // CUtlString
}

namespace CCompressorGroup {
    constexpr std::ptrdiff_t m_nTotalElementCount = 0x0; // int32_t
    constexpr std::ptrdiff_t m_szChannelClass = 0x8; // CUtlVector<char*>
    constexpr std::ptrdiff_t m_szVariableName = 0x20; // CUtlVector<char*>
    constexpr std::ptrdiff_t m_nType = 0x38; // CUtlVector<fieldtype_t>
    constexpr std::ptrdiff_t m_nFlags = 0x50; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_szGrouping = 0x68; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_nCompressorIndex = 0x80; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_szElementNames = 0x98; // CUtlVector<CUtlVector<char*>>
    constexpr std::ptrdiff_t m_nElementUniqueID = 0xB0; // CUtlVector<CUtlVector<int32_t>>
    constexpr std::ptrdiff_t m_nElementMask = 0xC8; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_vectorCompressor = 0xF8; // CUtlVector<CCompressor<Vector>*>
    constexpr std::ptrdiff_t m_quaternionCompressor = 0x110; // CUtlVector<CCompressor<QuaternionStorage>*>
    constexpr std::ptrdiff_t m_intCompressor = 0x128; // CUtlVector<CCompressor<int32_t>*>
    constexpr std::ptrdiff_t m_boolCompressor = 0x140; // CUtlVector<CCompressor<bool>*>
    constexpr std::ptrdiff_t m_colorCompressor = 0x158; // CUtlVector<CCompressor<Color>*>
    constexpr std::ptrdiff_t m_vector2DCompressor = 0x170; // CUtlVector<CCompressor<Vector2D>*>
    constexpr std::ptrdiff_t m_vector4DCompressor = 0x188; // CUtlVector<CCompressor<Vector4D>*>
}

namespace CConcreteAnimParameter {
    constexpr std::ptrdiff_t m_previewButton = 0x50; // AnimParamButton_t
    constexpr std::ptrdiff_t m_eNetworkSetting = 0x54; // AnimParamNetworkSetting
    constexpr std::ptrdiff_t m_bUseMostRecentValue = 0x58; // bool
    constexpr std::ptrdiff_t m_bAutoReset = 0x59; // bool
    constexpr std::ptrdiff_t m_bGameWritable = 0x5A; // bool
    constexpr std::ptrdiff_t m_bGraphWritable = 0x5B; // bool
}

namespace CConstraintSlave {
    constexpr std::ptrdiff_t m_qBaseOrientation = 0x0; // Quaternion
    constexpr std::ptrdiff_t m_vBasePosition = 0x10; // Vector
    constexpr std::ptrdiff_t m_nBoneHash = 0x1C; // uint32_t
    constexpr std::ptrdiff_t m_flWeight = 0x20; // float
    constexpr std::ptrdiff_t m_sName = 0x28; // CUtlString
}

namespace CConstraintTarget {
    constexpr std::ptrdiff_t m_qOffset = 0x20; // Quaternion
    constexpr std::ptrdiff_t m_vOffset = 0x30; // Vector
    constexpr std::ptrdiff_t m_nBoneHash = 0x3C; // uint32_t
    constexpr std::ptrdiff_t m_sName = 0x40; // CUtlString
    constexpr std::ptrdiff_t m_flWeight = 0x48; // float
    constexpr std::ptrdiff_t m_bIsAttachment = 0x59; // bool
}

namespace CCycleBase {
    constexpr std::ptrdiff_t m_flCycle = 0x0; // float
}

namespace CCycleControlClipUpdateNode {
    constexpr std::ptrdiff_t m_tags = 0x60; // CUtlVector<TagSpan_t>
    constexpr std::ptrdiff_t m_hSequence = 0x7C; // HSequence
    constexpr std::ptrdiff_t m_duration = 0x80; // float
    constexpr std::ptrdiff_t m_valueSource = 0x84; // AnimValueSource
    constexpr std::ptrdiff_t m_paramIndex = 0x88; // CAnimParamHandle
}

namespace CCycleControlUpdateNode {
    constexpr std::ptrdiff_t m_valueSource = 0x68; // AnimValueSource
    constexpr std::ptrdiff_t m_paramIndex = 0x6C; // CAnimParamHandle
}

namespace CDampedPathAnimMotorUpdater {
    constexpr std::ptrdiff_t m_flAnticipationTime = 0x2C; // float
    constexpr std::ptrdiff_t m_flMinSpeedScale = 0x30; // float
    constexpr std::ptrdiff_t m_hAnticipationPosParam = 0x34; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hAnticipationHeadingParam = 0x36; // CAnimParamHandle
    constexpr std::ptrdiff_t m_flSpringConstant = 0x38; // float
    constexpr std::ptrdiff_t m_flMinSpringTension = 0x3C; // float
    constexpr std::ptrdiff_t m_flMaxSpringTension = 0x40; // float
}

namespace CDampedValueComponentUpdater {
    constexpr std::ptrdiff_t m_items = 0x30; // CUtlVector<CDampedValueUpdateItem>
}

namespace CDampedValueUpdateItem {
    constexpr std::ptrdiff_t m_damping = 0x0; // CAnimInputDamping
    constexpr std::ptrdiff_t m_hParamIn = 0x18; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hParamOut = 0x1A; // CAnimParamHandle
}

namespace CDemoSettingsComponentUpdater {
    constexpr std::ptrdiff_t m_settings = 0x30; // CAnimDemoCaptureSettings
}

namespace CDirectPlaybackTagData {
    constexpr std::ptrdiff_t m_sequenceName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_tags = 0x8; // CUtlVector<TagSpan_t>
}

namespace CDirectPlaybackUpdateNode {
    constexpr std::ptrdiff_t m_bFinishEarly = 0x6C; // bool
    constexpr std::ptrdiff_t m_bResetOnFinish = 0x6D; // bool
    constexpr std::ptrdiff_t m_allTags = 0x70; // CUtlVector<CDirectPlaybackTagData>
}

namespace CDirectionalBlendUpdateNode {
    constexpr std::ptrdiff_t m_hSequences = 0x5C; // HSequence[8]
    constexpr std::ptrdiff_t m_damping = 0x80; // CAnimInputDamping
    constexpr std::ptrdiff_t m_blendValueSource = 0x90; // AnimValueSource
    constexpr std::ptrdiff_t m_paramIndex = 0x94; // CAnimParamHandle
    constexpr std::ptrdiff_t m_playbackSpeed = 0x98; // float
    constexpr std::ptrdiff_t m_duration = 0x9C; // float
    constexpr std::ptrdiff_t m_bLoop = 0xA0; // bool
    constexpr std::ptrdiff_t m_bLockBlendOnReset = 0xA1; // bool
}

namespace CDistanceRemainingMetricEvaluator {
    constexpr std::ptrdiff_t m_flMaxDistance = 0x50; // float
    constexpr std::ptrdiff_t m_flMinDistance = 0x54; // float
    constexpr std::ptrdiff_t m_flStartGoalFilterDistance = 0x58; // float
    constexpr std::ptrdiff_t m_flMaxGoalOvershootScale = 0x5C; // float
    constexpr std::ptrdiff_t m_bFilterFixedMinDistance = 0x60; // bool
    constexpr std::ptrdiff_t m_bFilterGoalDistance = 0x61; // bool
    constexpr std::ptrdiff_t m_bFilterGoalOvershoot = 0x62; // bool
}

namespace CDrawCullingData {
    constexpr std::ptrdiff_t m_vConeApex = 0x0; // Vector
    constexpr std::ptrdiff_t m_ConeAxis = 0xC; // int8_t[3]
    constexpr std::ptrdiff_t m_ConeCutoff = 0xF; // int8_t
}

namespace CEmitTagActionUpdater {
    constexpr std::ptrdiff_t m_nTagIndex = 0x18; // int32_t
    constexpr std::ptrdiff_t m_bIsZeroDuration = 0x1C; // bool
}

namespace CEnumAnimParameter {
    constexpr std::ptrdiff_t m_defaultValue = 0x68; // uint8_t
    constexpr std::ptrdiff_t m_enumOptions = 0x70; // CUtlVector<CUtlString>
}

namespace CExpressionActionUpdater {
    constexpr std::ptrdiff_t m_hParam = 0x18; // CAnimParamHandle
    constexpr std::ptrdiff_t m_eParamType = 0x1A; // AnimParamType_t
    constexpr std::ptrdiff_t m_hScript = 0x1C; // AnimScriptHandle
}

namespace CFingerBone {
    constexpr std::ptrdiff_t m_boneName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_hingeAxis = 0x8; // Vector
    constexpr std::ptrdiff_t m_vCapsulePos1 = 0x14; // Vector
    constexpr std::ptrdiff_t m_vCapsulePos2 = 0x20; // Vector
    constexpr std::ptrdiff_t m_flMinAngle = 0x2C; // float
    constexpr std::ptrdiff_t m_flMaxAngle = 0x30; // float
    constexpr std::ptrdiff_t m_flRadius = 0x34; // float
}

namespace CFingerChain {
    constexpr std::ptrdiff_t m_targets = 0x0; // CUtlVector<CFingerSource>
    constexpr std::ptrdiff_t m_bones = 0x18; // CUtlVector<CFingerBone>
    constexpr std::ptrdiff_t m_name = 0x30; // CUtlString
    constexpr std::ptrdiff_t m_tipParentBoneName = 0x38; // CUtlString
    constexpr std::ptrdiff_t m_vTipOffset = 0x40; // Vector
    constexpr std::ptrdiff_t m_metacarpalBoneName = 0x50; // CUtlString
    constexpr std::ptrdiff_t m_vSplayHingeAxis = 0x58; // Vector
    constexpr std::ptrdiff_t m_flSplayMinAngle = 0x64; // float
    constexpr std::ptrdiff_t m_flSplayMaxAngle = 0x68; // float
    constexpr std::ptrdiff_t m_flFingerScaleRatio = 0x6C; // float
}

namespace CFingerSource {
    constexpr std::ptrdiff_t m_nFingerIndex = 0x0; // AnimVRFinger_t
    constexpr std::ptrdiff_t m_flFingerWeight = 0x4; // float
}

namespace CFlexController {
    constexpr std::ptrdiff_t m_szName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_szType = 0x8; // CUtlString
    constexpr std::ptrdiff_t min = 0x10; // float
    constexpr std::ptrdiff_t max = 0x14; // float
}

namespace CFlexDesc {
    constexpr std::ptrdiff_t m_szFacs = 0x0; // CUtlString
}

namespace CFlexOp {
    constexpr std::ptrdiff_t m_OpCode = 0x0; // FlexOpCode_t
    constexpr std::ptrdiff_t m_Data = 0x4; // int32_t
}

namespace CFlexRule {
    constexpr std::ptrdiff_t m_nFlex = 0x0; // int32_t
    constexpr std::ptrdiff_t m_FlexOps = 0x8; // CUtlVector<CFlexOp>
}

namespace CFloatAnimParameter {
    constexpr std::ptrdiff_t m_fDefaultValue = 0x60; // float
    constexpr std::ptrdiff_t m_fMinValue = 0x64; // float
    constexpr std::ptrdiff_t m_fMaxValue = 0x68; // float
    constexpr std::ptrdiff_t m_bInterpolate = 0x6C; // bool
}

namespace CFollowAttachmentUpdateNode {
    constexpr std::ptrdiff_t m_opFixedData = 0x70; // FollowAttachmentSettings_t
}

namespace CFollowPathUpdateNode {
    constexpr std::ptrdiff_t m_flBlendOutTime = 0x6C; // float
    constexpr std::ptrdiff_t m_bBlockNonPathMovement = 0x70; // bool
    constexpr std::ptrdiff_t m_bStopFeetAtGoal = 0x71; // bool
    constexpr std::ptrdiff_t m_bScaleSpeed = 0x72; // bool
    constexpr std::ptrdiff_t m_flScale = 0x74; // float
    constexpr std::ptrdiff_t m_flMinAngle = 0x78; // float
    constexpr std::ptrdiff_t m_flMaxAngle = 0x7C; // float
    constexpr std::ptrdiff_t m_flSpeedScaleBlending = 0x80; // float
    constexpr std::ptrdiff_t m_turnDamping = 0x88; // CAnimInputDamping
    constexpr std::ptrdiff_t m_facingTarget = 0x98; // AnimValueSource
    constexpr std::ptrdiff_t m_hParam = 0x9C; // CAnimParamHandle
    constexpr std::ptrdiff_t m_flTurnToFaceOffset = 0xA0; // float
    constexpr std::ptrdiff_t m_bTurnToFace = 0xA4; // bool
}

namespace CFootAdjustmentUpdateNode {
    constexpr std::ptrdiff_t m_clips = 0x70; // CUtlVector<HSequence>
    constexpr std::ptrdiff_t m_hBasePoseCacheHandle = 0x88; // CPoseHandle
    constexpr std::ptrdiff_t m_facingTarget = 0x8C; // CAnimParamHandle
    constexpr std::ptrdiff_t m_flTurnTimeMin = 0x90; // float
    constexpr std::ptrdiff_t m_flTurnTimeMax = 0x94; // float
    constexpr std::ptrdiff_t m_flStepHeightMax = 0x98; // float
    constexpr std::ptrdiff_t m_flStepHeightMaxAngle = 0x9C; // float
    constexpr std::ptrdiff_t m_bResetChild = 0xA0; // bool
    constexpr std::ptrdiff_t m_bAnimationDriven = 0xA1; // bool
}

namespace CFootCycleDefinition {
    constexpr std::ptrdiff_t m_vStancePositionMS = 0x0; // Vector
    constexpr std::ptrdiff_t m_vMidpointPositionMS = 0xC; // Vector
    constexpr std::ptrdiff_t m_flStanceDirectionMS = 0x18; // float
    constexpr std::ptrdiff_t m_vToStrideStartPos = 0x1C; // Vector
    constexpr std::ptrdiff_t m_stanceCycle = 0x28; // CAnimCycle
    constexpr std::ptrdiff_t m_footLiftCycle = 0x2C; // CFootCycle
    constexpr std::ptrdiff_t m_footOffCycle = 0x30; // CFootCycle
    constexpr std::ptrdiff_t m_footStrikeCycle = 0x34; // CFootCycle
    constexpr std::ptrdiff_t m_footLandCycle = 0x38; // CFootCycle
}

namespace CFootCycleMetricEvaluator {
    constexpr std::ptrdiff_t m_footIndices = 0x50; // CUtlVector<int32_t>
}

namespace CFootDefinition {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_ankleBoneName = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_toeBoneName = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_vBallOffset = 0x18; // Vector
    constexpr std::ptrdiff_t m_vHeelOffset = 0x24; // Vector
    constexpr std::ptrdiff_t m_flFootLength = 0x30; // float
    constexpr std::ptrdiff_t m_flBindPoseDirectionMS = 0x34; // float
    constexpr std::ptrdiff_t m_flTraceHeight = 0x38; // float
    constexpr std::ptrdiff_t m_flTraceRadius = 0x3C; // float
}

namespace CFootFallAnimTag {
    constexpr std::ptrdiff_t m_foot = 0x38; // FootFallTagFoot_t
}

namespace CFootLockUpdateNode {
    constexpr std::ptrdiff_t m_opFixedSettings = 0x68; // FootLockPoseOpFixedSettings
    constexpr std::ptrdiff_t m_footSettings = 0xD0; // CUtlVector<FootFixedSettings>
    constexpr std::ptrdiff_t m_hipShiftDamping = 0xE8; // CAnimInputDamping
    constexpr std::ptrdiff_t m_rootHeightDamping = 0xF8; // CAnimInputDamping
    constexpr std::ptrdiff_t m_flStrideCurveScale = 0x108; // float
    constexpr std::ptrdiff_t m_flStrideCurveLimitScale = 0x10C; // float
    constexpr std::ptrdiff_t m_flStepHeightIncreaseScale = 0x110; // float
    constexpr std::ptrdiff_t m_flStepHeightDecreaseScale = 0x114; // float
    constexpr std::ptrdiff_t m_flHipShiftScale = 0x118; // float
    constexpr std::ptrdiff_t m_flBlendTime = 0x11C; // float
    constexpr std::ptrdiff_t m_flMaxRootHeightOffset = 0x120; // float
    constexpr std::ptrdiff_t m_flMinRootHeightOffset = 0x124; // float
    constexpr std::ptrdiff_t m_flTiltPlanePitchSpringStrength = 0x128; // float
    constexpr std::ptrdiff_t m_flTiltPlaneRollSpringStrength = 0x12C; // float
    constexpr std::ptrdiff_t m_bApplyFootRotationLimits = 0x130; // bool
    constexpr std::ptrdiff_t m_bApplyHipShift = 0x131; // bool
    constexpr std::ptrdiff_t m_bModulateStepHeight = 0x132; // bool
    constexpr std::ptrdiff_t m_bResetChild = 0x133; // bool
    constexpr std::ptrdiff_t m_bEnableVerticalCurvedPaths = 0x134; // bool
    constexpr std::ptrdiff_t m_bEnableRootHeightDamping = 0x135; // bool
}

namespace CFootMotion {
    constexpr std::ptrdiff_t m_strides = 0x0; // CUtlVector<CFootStride>
    constexpr std::ptrdiff_t m_name = 0x18; // CUtlString
    constexpr std::ptrdiff_t m_bAdditive = 0x20; // bool
}

namespace CFootPinningUpdateNode {
    constexpr std::ptrdiff_t m_poseOpFixedData = 0x70; // FootPinningPoseOpFixedData_t
    constexpr std::ptrdiff_t m_eTimingSource = 0xA0; // FootPinningTimingSource
    constexpr std::ptrdiff_t m_params = 0xA8; // CUtlVector<CAnimParamHandle>
    constexpr std::ptrdiff_t m_bResetChild = 0xC0; // bool
}

namespace CFootPositionMetricEvaluator {
    constexpr std::ptrdiff_t m_footIndices = 0x50; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_bIgnoreSlope = 0x68; // bool
}

namespace CFootStepTriggerUpdateNode {
    constexpr std::ptrdiff_t m_triggers = 0x68; // CUtlVector<FootStepTrigger>
    constexpr std::ptrdiff_t m_flTolerance = 0x84; // float
}

namespace CFootStride {
    constexpr std::ptrdiff_t m_definition = 0x0; // CFootCycleDefinition
    constexpr std::ptrdiff_t m_trajectories = 0x40; // CFootTrajectories
}

namespace CFootTrajectories {
    constexpr std::ptrdiff_t m_trajectories = 0x0; // CUtlVector<CFootTrajectory>
}

namespace CFootTrajectory {
    constexpr std::ptrdiff_t m_vOffset = 0x0; // Vector
    constexpr std::ptrdiff_t m_flRotationOffset = 0xC; // float
    constexpr std::ptrdiff_t m_flProgression = 0x10; // float
}

namespace CFootstepLandedAnimTag {
    constexpr std::ptrdiff_t m_FootstepType = 0x38; // FootstepLandedFootSoundType_t
    constexpr std::ptrdiff_t m_OverrideSoundName = 0x40; // CUtlString
    constexpr std::ptrdiff_t m_DebugAnimSourceString = 0x48; // CUtlString
    constexpr std::ptrdiff_t m_BoneName = 0x50; // CUtlString
}

namespace CFutureFacingMetricEvaluator {
    constexpr std::ptrdiff_t m_flDistance = 0x50; // float
    constexpr std::ptrdiff_t m_flTime = 0x54; // float
}

namespace CFutureVelocityMetricEvaluator {
    constexpr std::ptrdiff_t m_flDistance = 0x50; // float
    constexpr std::ptrdiff_t m_flStoppingDistance = 0x54; // float
    constexpr std::ptrdiff_t m_flTargetSpeed = 0x58; // float
    constexpr std::ptrdiff_t m_eMode = 0x5C; // VelocityMetricMode
}

namespace CHitBox {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_sSurfaceProperty = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_sBoneName = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_vMinBounds = 0x18; // Vector
    constexpr std::ptrdiff_t m_vMaxBounds = 0x24; // Vector
    constexpr std::ptrdiff_t m_flShapeRadius = 0x30; // float
    constexpr std::ptrdiff_t m_nBoneNameHash = 0x34; // uint32_t
    constexpr std::ptrdiff_t m_nGroupId = 0x38; // int32_t
    constexpr std::ptrdiff_t m_nShapeType = 0x3C; // uint8_t
    constexpr std::ptrdiff_t m_bTranslationOnly = 0x3D; // bool
    constexpr std::ptrdiff_t m_CRC = 0x40; // uint32_t
    constexpr std::ptrdiff_t m_cRenderColor = 0x44; // Color
    constexpr std::ptrdiff_t m_nHitBoxIndex = 0x48; // uint16_t
}

namespace CHitBoxSet {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nNameHash = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_HitBoxes = 0x10; // CUtlVector<CHitBox>
    constexpr std::ptrdiff_t m_SourceFilename = 0x28; // CUtlString
}

namespace CHitBoxSetList {
    constexpr std::ptrdiff_t m_HitBoxSets = 0x0; // CUtlVector<CHitBoxSet>
}

namespace CHitReactUpdateNode {
    constexpr std::ptrdiff_t m_opFixedSettings = 0x68; // HitReactFixedSettings_t
    constexpr std::ptrdiff_t m_triggerParam = 0xB4; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hitBoneParam = 0xB6; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hitOffsetParam = 0xB8; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hitDirectionParam = 0xBA; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hitStrengthParam = 0xBC; // CAnimParamHandle
    constexpr std::ptrdiff_t m_flMinDelayBetweenHits = 0xC0; // float
    constexpr std::ptrdiff_t m_bResetChild = 0xC4; // bool
}

namespace CIntAnimParameter {
    constexpr std::ptrdiff_t m_defaultValue = 0x60; // int32_t
    constexpr std::ptrdiff_t m_minValue = 0x64; // int32_t
    constexpr std::ptrdiff_t m_maxValue = 0x68; // int32_t
}

namespace CJiggleBoneUpdateNode {
    constexpr std::ptrdiff_t m_opFixedData = 0x68; // JiggleBoneSettingsList_t
}

namespace CJumpHelperUpdateNode {
    constexpr std::ptrdiff_t m_hTargetParam = 0xA8; // CAnimParamHandle
    constexpr std::ptrdiff_t m_flOriginalJumpMovement = 0xAC; // Vector
    constexpr std::ptrdiff_t m_flOriginalJumpDuration = 0xB8; // float
    constexpr std::ptrdiff_t m_flJumpStartCycle = 0xBC; // float
    constexpr std::ptrdiff_t m_flJumpEndCycle = 0xC0; // float
    constexpr std::ptrdiff_t m_eCorrectionMethod = 0xC4; // JumpCorrectionMethod
    constexpr std::ptrdiff_t m_bTranslationAxis = 0xC8; // bool[3]
    constexpr std::ptrdiff_t m_bScaleSpeed = 0xCB; // bool
}

namespace CLODComponentUpdater {
    constexpr std::ptrdiff_t m_nServerLOD = 0x30; // int32_t
}

namespace CLeanMatrixUpdateNode {
    constexpr std::ptrdiff_t m_frameCorners = 0x5C; // int32_t[3][3]
    constexpr std::ptrdiff_t m_poses = 0x80; // CPoseHandle[9]
    constexpr std::ptrdiff_t m_damping = 0xA8; // CAnimInputDamping
    constexpr std::ptrdiff_t m_blendSource = 0xB8; // AnimVectorSource
    constexpr std::ptrdiff_t m_paramIndex = 0xBC; // CAnimParamHandle
    constexpr std::ptrdiff_t m_verticalAxis = 0xC0; // Vector
    constexpr std::ptrdiff_t m_horizontalAxis = 0xCC; // Vector
    constexpr std::ptrdiff_t m_hSequence = 0xD8; // HSequence
    constexpr std::ptrdiff_t m_flMaxValue = 0xDC; // float
    constexpr std::ptrdiff_t m_nSequenceMaxFrame = 0xE0; // int32_t
}

namespace CLookAtUpdateNode {
    constexpr std::ptrdiff_t m_opFixedSettings = 0x70; // LookAtOpFixedSettings_t
    constexpr std::ptrdiff_t m_target = 0x138; // AnimVectorSource
    constexpr std::ptrdiff_t m_paramIndex = 0x13C; // CAnimParamHandle
    constexpr std::ptrdiff_t m_weightParamIndex = 0x13E; // CAnimParamHandle
    constexpr std::ptrdiff_t m_bResetChild = 0x140; // bool
    constexpr std::ptrdiff_t m_bLockWhenWaning = 0x141; // bool
}

namespace CLookComponentUpdater {
    constexpr std::ptrdiff_t m_hLookHeading = 0x34; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hLookHeadingVelocity = 0x36; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hLookPitch = 0x38; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hLookDistance = 0x3A; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hLookDirection = 0x3C; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hLookTarget = 0x3E; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hLookTargetWorldSpace = 0x40; // CAnimParamHandle
    constexpr std::ptrdiff_t m_bNetworkLookTarget = 0x42; // bool
}

namespace CMaterialAttributeAnimTag {
    constexpr std::ptrdiff_t m_AttributeName = 0x38; // CUtlString
    constexpr std::ptrdiff_t m_AttributeType = 0x40; // MatterialAttributeTagType_t
    constexpr std::ptrdiff_t m_flValue = 0x44; // float
    constexpr std::ptrdiff_t m_Color = 0x48; // Color
}

namespace CMaterialDrawDescriptor {
    constexpr std::ptrdiff_t m_nPrimitiveType = 0x0; // RenderPrimitiveType_t
    constexpr std::ptrdiff_t m_nBaseVertex = 0x4; // int32_t
    constexpr std::ptrdiff_t m_nVertexCount = 0x8; // int32_t
    constexpr std::ptrdiff_t m_nStartIndex = 0xC; // int32_t
    constexpr std::ptrdiff_t m_nIndexCount = 0x10; // int32_t
    constexpr std::ptrdiff_t m_flUvDensity = 0x14; // float
    constexpr std::ptrdiff_t m_vTintColor = 0x18; // Vector
    constexpr std::ptrdiff_t m_flAlpha = 0x24; // float
    constexpr std::ptrdiff_t m_nFirstMeshlet = 0x2C; // uint32_t
    constexpr std::ptrdiff_t m_nNumMeshlets = 0x30; // uint16_t
    constexpr std::ptrdiff_t m_indexBuffer = 0xB8; // CRenderBufferBinding
    constexpr std::ptrdiff_t m_material = 0xE0; // CStrongHandle<InfoForResourceTypeIMaterial2>
}

namespace CMeshletDescriptor {
    constexpr std::ptrdiff_t m_PackedAABB = 0x0; // PackedAABB_t
    constexpr std::ptrdiff_t m_CullingData = 0x8; // CDrawCullingData
}

namespace CModelConfig {
    constexpr std::ptrdiff_t m_ConfigName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_Elements = 0x8; // CUtlVector<CModelConfigElement*>
    constexpr std::ptrdiff_t m_bTopLevel = 0x20; // bool
}

namespace CModelConfigElement {
    constexpr std::ptrdiff_t m_ElementName = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_NestedElements = 0x10; // CUtlVector<CModelConfigElement*>
}

namespace CModelConfigElement_AttachedModel {
    constexpr std::ptrdiff_t m_InstanceName = 0x48; // CUtlString
    constexpr std::ptrdiff_t m_EntityClass = 0x50; // CUtlString
    constexpr std::ptrdiff_t m_hModel = 0x58; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_vOffset = 0x60; // Vector
    constexpr std::ptrdiff_t m_aAngOffset = 0x6C; // QAngle
    constexpr std::ptrdiff_t m_AttachmentName = 0x78; // CUtlString
    constexpr std::ptrdiff_t m_LocalAttachmentOffsetName = 0x80; // CUtlString
    constexpr std::ptrdiff_t m_AttachmentType = 0x88; // ModelConfigAttachmentType_t
    constexpr std::ptrdiff_t m_bBoneMergeFlex = 0x8C; // bool
    constexpr std::ptrdiff_t m_bUserSpecifiedColor = 0x8D; // bool
    constexpr std::ptrdiff_t m_bUserSpecifiedMaterialGroup = 0x8E; // bool
    constexpr std::ptrdiff_t m_bAcceptParentMaterialDrivenDecals = 0x8F; // bool
    constexpr std::ptrdiff_t m_BodygroupOnOtherModels = 0x90; // CUtlString
    constexpr std::ptrdiff_t m_MaterialGroupOnOtherModels = 0x98; // CUtlString
}

namespace CModelConfigElement_Command {
    constexpr std::ptrdiff_t m_Command = 0x48; // CUtlString
    constexpr std::ptrdiff_t m_Args = 0x50; // KeyValues3
}

namespace CModelConfigElement_RandomColor {
    constexpr std::ptrdiff_t m_Gradient = 0x48; // CColorGradient
}

namespace CModelConfigElement_RandomPick {
    constexpr std::ptrdiff_t m_Choices = 0x48; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_ChoiceWeights = 0x60; // CUtlVector<float>
}

namespace CModelConfigElement_SetBodygroup {
    constexpr std::ptrdiff_t m_GroupName = 0x48; // CUtlString
    constexpr std::ptrdiff_t m_nChoice = 0x50; // int32_t
}

namespace CModelConfigElement_SetBodygroupOnAttachedModels {
    constexpr std::ptrdiff_t m_GroupName = 0x48; // CUtlString
    constexpr std::ptrdiff_t m_nChoice = 0x50; // int32_t
}

namespace CModelConfigElement_SetMaterialGroup {
    constexpr std::ptrdiff_t m_MaterialGroupName = 0x48; // CUtlString
}

namespace CModelConfigElement_SetMaterialGroupOnAttachedModels {
    constexpr std::ptrdiff_t m_MaterialGroupName = 0x48; // CUtlString
}

namespace CModelConfigElement_SetRenderColor {
    constexpr std::ptrdiff_t m_Color = 0x48; // Color
}

namespace CModelConfigElement_UserPick {
    constexpr std::ptrdiff_t m_Choices = 0x48; // CUtlVector<CUtlString>
}

namespace CModelConfigList {
    constexpr std::ptrdiff_t m_bHideMaterialGroupInTools = 0x0; // bool
    constexpr std::ptrdiff_t m_bHideRenderColorInTools = 0x1; // bool
    constexpr std::ptrdiff_t m_Configs = 0x8; // CUtlVector<CModelConfig*>
}

namespace CMoodVData {
    constexpr std::ptrdiff_t m_sModelName = 0x0; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_nMoodType = 0xE0; // MoodType_t
    constexpr std::ptrdiff_t m_animationLayers = 0xE8; // CUtlVector<MoodAnimationLayer_t>
}

namespace CMorphBundleData {
    constexpr std::ptrdiff_t m_flULeftSrc = 0x0; // float
    constexpr std::ptrdiff_t m_flVTopSrc = 0x4; // float
    constexpr std::ptrdiff_t m_offsets = 0x8; // CUtlVector<float>
    constexpr std::ptrdiff_t m_ranges = 0x20; // CUtlVector<float>
}

namespace CMorphConstraint {
    constexpr std::ptrdiff_t m_sTargetMorph = 0x70; // CUtlString
    constexpr std::ptrdiff_t m_nSlaveChannel = 0x78; // int32_t
    constexpr std::ptrdiff_t m_flMin = 0x7C; // float
    constexpr std::ptrdiff_t m_flMax = 0x80; // float
}

namespace CMorphData {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_morphRectDatas = 0x8; // CUtlVector<CMorphRectData>
}

namespace CMorphRectData {
    constexpr std::ptrdiff_t m_nXLeftDst = 0x0; // int16_t
    constexpr std::ptrdiff_t m_nYTopDst = 0x2; // int16_t
    constexpr std::ptrdiff_t m_flUWidthSrc = 0x4; // float
    constexpr std::ptrdiff_t m_flVHeightSrc = 0x8; // float
    constexpr std::ptrdiff_t m_bundleDatas = 0x10; // CUtlVector<CMorphBundleData>
}

namespace CMorphSetData {
    constexpr std::ptrdiff_t m_nWidth = 0x10; // int32_t
    constexpr std::ptrdiff_t m_nHeight = 0x14; // int32_t
    constexpr std::ptrdiff_t m_bundleTypes = 0x18; // CUtlVector<MorphBundleType_t>
    constexpr std::ptrdiff_t m_morphDatas = 0x30; // CUtlVector<CMorphData>
    constexpr std::ptrdiff_t m_pTextureAtlas = 0x48; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_FlexDesc = 0x50; // CUtlVector<CFlexDesc>
    constexpr std::ptrdiff_t m_FlexControllers = 0x68; // CUtlVector<CFlexController>
    constexpr std::ptrdiff_t m_FlexRules = 0x80; // CUtlVector<CFlexRule>
}

namespace CMotionDataSet {
    constexpr std::ptrdiff_t m_groups = 0x0; // CUtlVector<CMotionGraphGroup>
    constexpr std::ptrdiff_t m_nDimensionCount = 0x18; // int32_t
}

namespace CMotionGraph {
    constexpr std::ptrdiff_t m_paramSpans = 0x10; // CParamSpanUpdater
    constexpr std::ptrdiff_t m_tags = 0x28; // CUtlVector<TagSpan_t>
    constexpr std::ptrdiff_t m_pRootNode = 0x40; // CSmartPtr<CMotionNode>
    constexpr std::ptrdiff_t m_nParameterCount = 0x48; // int32_t
    constexpr std::ptrdiff_t m_nConfigStartIndex = 0x4C; // int32_t
    constexpr std::ptrdiff_t m_nConfigCount = 0x50; // int32_t
    constexpr std::ptrdiff_t m_bLoop = 0x54; // bool
}

namespace CMotionGraphConfig {
    constexpr std::ptrdiff_t m_paramValues = 0x0; // float[4]
    constexpr std::ptrdiff_t m_flDuration = 0x10; // float
    constexpr std::ptrdiff_t m_nMotionIndex = 0x14; // MotionIndex
    constexpr std::ptrdiff_t m_nSampleStart = 0x18; // int32_t
    constexpr std::ptrdiff_t m_nSampleCount = 0x1C; // int32_t
}

namespace CMotionGraphGroup {
    constexpr std::ptrdiff_t m_searchDB = 0x0; // CMotionSearchDB
    constexpr std::ptrdiff_t m_motionGraphs = 0xB8; // CUtlVector<CSmartPtr<CMotionGraph>>
    constexpr std::ptrdiff_t m_motionGraphConfigs = 0xD0; // CUtlVector<CMotionGraphConfig>
    constexpr std::ptrdiff_t m_sampleToConfig = 0xE8; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_hIsActiveScript = 0x100; // AnimScriptHandle
}

namespace CMotionGraphUpdateNode {
    constexpr std::ptrdiff_t m_pMotionGraph = 0x58; // CSmartPtr<CMotionGraph>
}

namespace CMotionMatchingUpdateNode {
    constexpr std::ptrdiff_t m_dataSet = 0x58; // CMotionDataSet
    constexpr std::ptrdiff_t m_metrics = 0x78; // CUtlVector<CSmartPtr<CMotionMetricEvaluator>>
    constexpr std::ptrdiff_t m_weights = 0x90; // CUtlVector<float>
    constexpr std::ptrdiff_t m_bSearchEveryTick = 0xE0; // bool
    constexpr std::ptrdiff_t m_flSearchInterval = 0xE4; // float
    constexpr std::ptrdiff_t m_bSearchWhenClipEnds = 0xE8; // bool
    constexpr std::ptrdiff_t m_bSearchWhenGoalChanges = 0xE9; // bool
    constexpr std::ptrdiff_t m_blendCurve = 0xEC; // CBlendCurve
    constexpr std::ptrdiff_t m_flSampleRate = 0xF4; // float
    constexpr std::ptrdiff_t m_flBlendTime = 0xF8; // float
    constexpr std::ptrdiff_t m_bLockClipWhenWaning = 0xFC; // bool
    constexpr std::ptrdiff_t m_flSelectionThreshold = 0x100; // float
    constexpr std::ptrdiff_t m_flReselectionTimeWindow = 0x104; // float
    constexpr std::ptrdiff_t m_bEnableRotationCorrection = 0x108; // bool
    constexpr std::ptrdiff_t m_bGoalAssist = 0x109; // bool
    constexpr std::ptrdiff_t m_flGoalAssistDistance = 0x10C; // float
    constexpr std::ptrdiff_t m_flGoalAssistTolerance = 0x110; // float
    constexpr std::ptrdiff_t m_distanceScale_Damping = 0x118; // CAnimInputDamping
    constexpr std::ptrdiff_t m_flDistanceScale_OuterRadius = 0x128; // float
    constexpr std::ptrdiff_t m_flDistanceScale_InnerRadius = 0x12C; // float
    constexpr std::ptrdiff_t m_flDistanceScale_MaxScale = 0x130; // float
    constexpr std::ptrdiff_t m_flDistanceScale_MinScale = 0x134; // float
    constexpr std::ptrdiff_t m_bEnableDistanceScaling = 0x138; // bool
}

namespace CMotionMetricEvaluator {
    constexpr std::ptrdiff_t m_means = 0x18; // CUtlVector<float>
    constexpr std::ptrdiff_t m_standardDeviations = 0x30; // CUtlVector<float>
    constexpr std::ptrdiff_t m_flWeight = 0x48; // float
    constexpr std::ptrdiff_t m_nDimensionStartIndex = 0x4C; // int32_t
}

namespace CMotionNode {
    constexpr std::ptrdiff_t m_name = 0x18; // CUtlString
    constexpr std::ptrdiff_t m_id = 0x20; // AnimNodeID
}

namespace CMotionNodeBlend1D {
    constexpr std::ptrdiff_t m_blendItems = 0x28; // CUtlVector<MotionBlendItem>
    constexpr std::ptrdiff_t m_nParamIndex = 0x40; // int32_t
}

namespace CMotionNodeSequence {
    constexpr std::ptrdiff_t m_tags = 0x28; // CUtlVector<TagSpan_t>
    constexpr std::ptrdiff_t m_hSequence = 0x40; // HSequence
    constexpr std::ptrdiff_t m_flPlaybackSpeed = 0x44; // float
}

namespace CMotionSearchDB {
    constexpr std::ptrdiff_t m_rootNode = 0x0; // CMotionSearchNode
    constexpr std::ptrdiff_t m_residualQuantizer = 0x80; // CProductQuantizer
    constexpr std::ptrdiff_t m_codeIndices = 0xA0; // CUtlVector<MotionDBIndex>
}

namespace CMotionSearchNode {
    constexpr std::ptrdiff_t m_children = 0x0; // CUtlVector<CMotionSearchNode*>
    constexpr std::ptrdiff_t m_quantizer = 0x18; // CVectorQuantizer
    constexpr std::ptrdiff_t m_sampleCodes = 0x38; // CUtlVector<CUtlVector<SampleCode>>
    constexpr std::ptrdiff_t m_sampleIndices = 0x50; // CUtlVector<CUtlVector<int32_t>>
    constexpr std::ptrdiff_t m_selectableSamples = 0x68; // CUtlVector<int32_t>
}

namespace CMovementComponentUpdater {
    constexpr std::ptrdiff_t m_movementModes = 0x30; // CUtlVector<CMovementMode>
    constexpr std::ptrdiff_t m_motors = 0x48; // CUtlVector<CSmartPtr<CAnimMotorUpdaterBase>>
    constexpr std::ptrdiff_t m_facingDamping = 0x60; // CAnimInputDamping
    constexpr std::ptrdiff_t m_eDefaultFacingMode = 0x70; // FacingMode
    constexpr std::ptrdiff_t m_nDefaultMotorIndex = 0x7C; // int32_t
    constexpr std::ptrdiff_t m_bMoveVarsDisabled = 0x80; // bool
    constexpr std::ptrdiff_t m_bNetworkPath = 0x81; // bool
    constexpr std::ptrdiff_t m_bNetworkFacing = 0x82; // bool
    constexpr std::ptrdiff_t m_paramHandles = 0x83; // CAnimParamHandle[30]
}

namespace CMovementMode {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_flSpeed = 0x8; // float
}

namespace CMoverUpdateNode {
    constexpr std::ptrdiff_t m_damping = 0x70; // CAnimInputDamping
    constexpr std::ptrdiff_t m_facingTarget = 0x80; // AnimValueSource
    constexpr std::ptrdiff_t m_hMoveVecParam = 0x84; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hMoveHeadingParam = 0x86; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hTurnToFaceParam = 0x88; // CAnimParamHandle
    constexpr std::ptrdiff_t m_flTurnToFaceOffset = 0x8C; // float
    constexpr std::ptrdiff_t m_flTurnToFaceLimit = 0x90; // float
    constexpr std::ptrdiff_t m_bAdditive = 0x94; // bool
    constexpr std::ptrdiff_t m_bApplyMovement = 0x95; // bool
    constexpr std::ptrdiff_t m_bOrientMovement = 0x96; // bool
    constexpr std::ptrdiff_t m_bApplyRotation = 0x97; // bool
    constexpr std::ptrdiff_t m_bLimitOnly = 0x98; // bool
}

namespace CParamSpanUpdater {
    constexpr std::ptrdiff_t m_spans = 0x0; // CUtlVector<ParamSpan_t>
}

namespace CParticleAnimTag {
    constexpr std::ptrdiff_t m_hParticleSystem = 0x38; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_particleSystemName = 0x40; // CUtlString
    constexpr std::ptrdiff_t m_configName = 0x48; // CUtlString
    constexpr std::ptrdiff_t m_bDetachFromOwner = 0x50; // bool
    constexpr std::ptrdiff_t m_bStopWhenTagEnds = 0x51; // bool
    constexpr std::ptrdiff_t m_bTagEndStopIsInstant = 0x52; // bool
    constexpr std::ptrdiff_t m_attachmentName = 0x58; // CUtlString
    constexpr std::ptrdiff_t m_attachmentType = 0x60; // ParticleAttachment_t
    constexpr std::ptrdiff_t m_attachmentCP1Name = 0x68; // CUtlString
    constexpr std::ptrdiff_t m_attachmentCP1Type = 0x70; // ParticleAttachment_t
}

namespace CPathAnimMotorUpdaterBase {
    constexpr std::ptrdiff_t m_bLockToPath = 0x20; // bool
}

namespace CPathHelperUpdateNode {
    constexpr std::ptrdiff_t m_flStoppingRadius = 0x68; // float
    constexpr std::ptrdiff_t m_flStoppingSpeedScale = 0x6C; // float
}

namespace CPathMetricEvaluator {
    constexpr std::ptrdiff_t m_pathTimeSamples = 0x50; // CUtlVector<float>
    constexpr std::ptrdiff_t m_flDistance = 0x68; // float
    constexpr std::ptrdiff_t m_bExtrapolateMovement = 0x6C; // bool
    constexpr std::ptrdiff_t m_flMinExtrapolationSpeed = 0x70; // float
}

namespace CPhysSurfaceProperties {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nameHash = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_baseNameHash = 0xC; // uint32_t
    constexpr std::ptrdiff_t m_bHidden = 0x18; // bool
    constexpr std::ptrdiff_t m_description = 0x20; // CUtlString
    constexpr std::ptrdiff_t m_physics = 0x28; // CPhysSurfacePropertiesPhysics
    constexpr std::ptrdiff_t m_audioSounds = 0x48; // CPhysSurfacePropertiesSoundNames
    constexpr std::ptrdiff_t m_audioParams = 0x88; // CPhysSurfacePropertiesAudio
}

namespace CPhysSurfacePropertiesAudio {
    constexpr std::ptrdiff_t m_reflectivity = 0x0; // float
    constexpr std::ptrdiff_t m_hardnessFactor = 0x4; // float
    constexpr std::ptrdiff_t m_roughnessFactor = 0x8; // float
    constexpr std::ptrdiff_t m_roughThreshold = 0xC; // float
    constexpr std::ptrdiff_t m_hardThreshold = 0x10; // float
    constexpr std::ptrdiff_t m_hardVelocityThreshold = 0x14; // float
    constexpr std::ptrdiff_t m_flStaticImpactVolume = 0x18; // float
    constexpr std::ptrdiff_t m_flOcclusionFactor = 0x1C; // float
}

namespace CPhysSurfacePropertiesPhysics {
    constexpr std::ptrdiff_t m_friction = 0x0; // float
    constexpr std::ptrdiff_t m_elasticity = 0x4; // float
    constexpr std::ptrdiff_t m_density = 0x8; // float
    constexpr std::ptrdiff_t m_thickness = 0xC; // float
    constexpr std::ptrdiff_t m_softContactFrequency = 0x10; // float
    constexpr std::ptrdiff_t m_softContactDampingRatio = 0x14; // float
    constexpr std::ptrdiff_t m_wheelDrag = 0x18; // float
}

namespace CPhysSurfacePropertiesSoundNames {
    constexpr std::ptrdiff_t m_impactSoft = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_impactHard = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_scrapeSmooth = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_scrapeRough = 0x18; // CUtlString
    constexpr std::ptrdiff_t m_bulletImpact = 0x20; // CUtlString
    constexpr std::ptrdiff_t m_rolling = 0x28; // CUtlString
    constexpr std::ptrdiff_t m_break = 0x30; // CUtlString
    constexpr std::ptrdiff_t m_strain = 0x38; // CUtlString
}

namespace CPlayerInputAnimMotorUpdater {
    constexpr std::ptrdiff_t m_sampleTimes = 0x20; // CUtlVector<float>
    constexpr std::ptrdiff_t m_flSpringConstant = 0x3C; // float
    constexpr std::ptrdiff_t m_flAnticipationDistance = 0x40; // float
    constexpr std::ptrdiff_t m_hAnticipationPosParam = 0x44; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hAnticipationHeadingParam = 0x46; // CAnimParamHandle
    constexpr std::ptrdiff_t m_bUseAcceleration = 0x48; // bool
}

namespace CPoseHandle {
    constexpr std::ptrdiff_t m_nIndex = 0x0; // uint16_t
    constexpr std::ptrdiff_t m_eType = 0x2; // PoseType_t
}

namespace CProductQuantizer {
    constexpr std::ptrdiff_t m_subQuantizers = 0x0; // CUtlVector<CVectorQuantizer>
    constexpr std::ptrdiff_t m_nDimensions = 0x18; // int32_t
}

namespace CQuaternionAnimParameter {
    constexpr std::ptrdiff_t m_defaultValue = 0x60; // Quaternion
    constexpr std::ptrdiff_t m_bInterpolate = 0x70; // bool
}

namespace CRagdollAnimTag {
    constexpr std::ptrdiff_t m_nPoseControl = 0x38; // AnimPoseControl
    constexpr std::ptrdiff_t m_flFrequency = 0x3C; // float
    constexpr std::ptrdiff_t m_flDampingRatio = 0x40; // float
    constexpr std::ptrdiff_t m_flDecayDuration = 0x44; // float
    constexpr std::ptrdiff_t m_flDecayBias = 0x48; // float
    constexpr std::ptrdiff_t m_bDestroy = 0x4C; // bool
}

namespace CRagdollComponentUpdater {
    constexpr std::ptrdiff_t m_ragdollNodePaths = 0x30; // CUtlVector<CAnimNodePath>
    constexpr std::ptrdiff_t m_boneIndices = 0x48; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_boneNames = 0x60; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_weightLists = 0x78; // CUtlVector<WeightList>
    constexpr std::ptrdiff_t m_flSpringFrequencyMin = 0x90; // float
    constexpr std::ptrdiff_t m_flSpringFrequencyMax = 0x94; // float
    constexpr std::ptrdiff_t m_flMaxStretch = 0x98; // float
}

namespace CRagdollUpdateNode {
    constexpr std::ptrdiff_t m_nWeightListIndex = 0x68; // int32_t
    constexpr std::ptrdiff_t m_poseControlMethod = 0x6C; // RagdollPoseControl
}

namespace CRenderBufferBinding {
    constexpr std::ptrdiff_t m_hBuffer = 0x0; // uint64_t
    constexpr std::ptrdiff_t m_nBindOffsetBytes = 0x10; // uint32_t
}

namespace CRenderMesh {
    constexpr std::ptrdiff_t m_sceneObjects = 0x10; // CUtlVectorFixedGrowable<CSceneObjectData>
    constexpr std::ptrdiff_t m_constraints = 0xA0; // CUtlVector<CBaseConstraint*>
    constexpr std::ptrdiff_t m_skeleton = 0xB8; // CRenderSkeleton
}

namespace CRenderSkeleton {
    constexpr std::ptrdiff_t m_bones = 0x0; // CUtlVector<RenderSkeletonBone_t>
    constexpr std::ptrdiff_t m_boneParents = 0x30; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_nBoneWeightCount = 0x48; // int32_t
}

namespace CSceneObjectData {
    constexpr std::ptrdiff_t m_vMinBounds = 0x0; // Vector
    constexpr std::ptrdiff_t m_vMaxBounds = 0xC; // Vector
    constexpr std::ptrdiff_t m_drawCalls = 0x18; // CUtlVector<CMaterialDrawDescriptor>
    constexpr std::ptrdiff_t m_drawBounds = 0x30; // CUtlVector<AABB_t>
    constexpr std::ptrdiff_t m_meshlets = 0x48; // CUtlVector<CMeshletDescriptor>
    constexpr std::ptrdiff_t m_vTintColor = 0x60; // Vector4D
}

namespace CSelectorUpdateNode {
    constexpr std::ptrdiff_t m_children = 0x58; // CUtlVector<CAnimUpdateNodeRef>
    constexpr std::ptrdiff_t m_tags = 0x70; // CUtlVector<int8_t>
    constexpr std::ptrdiff_t m_blendCurve = 0x8C; // CBlendCurve
    constexpr std::ptrdiff_t m_flBlendTime = 0x94; // CAnimValue<float>
    constexpr std::ptrdiff_t m_hParameter = 0x9C; // CAnimParamHandle
    constexpr std::ptrdiff_t m_eTagBehavior = 0xA0; // SelectorTagBehavior_t
    constexpr std::ptrdiff_t m_bResetOnChange = 0xA4; // bool
    constexpr std::ptrdiff_t m_bSyncCyclesOnChange = 0xA5; // bool
}

namespace CSeqAutoLayer {
    constexpr std::ptrdiff_t m_nLocalReference = 0x0; // int16_t
    constexpr std::ptrdiff_t m_nLocalPose = 0x2; // int16_t
    constexpr std::ptrdiff_t m_flags = 0x4; // CSeqAutoLayerFlag
    constexpr std::ptrdiff_t m_start = 0xC; // float
    constexpr std::ptrdiff_t m_peak = 0x10; // float
    constexpr std::ptrdiff_t m_tail = 0x14; // float
    constexpr std::ptrdiff_t m_end = 0x18; // float
}

namespace CSeqAutoLayerFlag {
    constexpr std::ptrdiff_t m_bPost = 0x0; // bool
    constexpr std::ptrdiff_t m_bSpline = 0x1; // bool
    constexpr std::ptrdiff_t m_bXFade = 0x2; // bool
    constexpr std::ptrdiff_t m_bNoBlend = 0x3; // bool
    constexpr std::ptrdiff_t m_bLocal = 0x4; // bool
    constexpr std::ptrdiff_t m_bPose = 0x5; // bool
    constexpr std::ptrdiff_t m_bFetchFrame = 0x6; // bool
    constexpr std::ptrdiff_t m_bSubtract = 0x7; // bool
}

namespace CSeqBoneMaskList {
    constexpr std::ptrdiff_t m_sName = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_nLocalBoneArray = 0x10; // CUtlVector<int16_t>
    constexpr std::ptrdiff_t m_flBoneWeightArray = 0x28; // CUtlVector<float>
    constexpr std::ptrdiff_t m_flDefaultMorphCtrlWeight = 0x40; // float
    constexpr std::ptrdiff_t m_morphCtrlWeightArray = 0x48; // CUtlVector<CUtlPair<CBufferString,float>>
}

namespace CSeqCmdLayer {
    constexpr std::ptrdiff_t m_cmd = 0x0; // int16_t
    constexpr std::ptrdiff_t m_nLocalReference = 0x2; // int16_t
    constexpr std::ptrdiff_t m_nLocalBonemask = 0x4; // int16_t
    constexpr std::ptrdiff_t m_nDstResult = 0x6; // int16_t
    constexpr std::ptrdiff_t m_nSrcResult = 0x8; // int16_t
    constexpr std::ptrdiff_t m_bSpline = 0xA; // bool
    constexpr std::ptrdiff_t m_flVar1 = 0xC; // float
    constexpr std::ptrdiff_t m_flVar2 = 0x10; // float
    constexpr std::ptrdiff_t m_nLineNumber = 0x14; // int16_t
}

namespace CSeqCmdSeqDesc {
    constexpr std::ptrdiff_t m_sName = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_flags = 0x10; // CSeqSeqDescFlag
    constexpr std::ptrdiff_t m_transition = 0x1C; // CSeqTransition
    constexpr std::ptrdiff_t m_nFrameRangeSequence = 0x24; // int16_t
    constexpr std::ptrdiff_t m_nFrameCount = 0x26; // int16_t
    constexpr std::ptrdiff_t m_flFPS = 0x28; // float
    constexpr std::ptrdiff_t m_nSubCycles = 0x2C; // int16_t
    constexpr std::ptrdiff_t m_numLocalResults = 0x2E; // int16_t
    constexpr std::ptrdiff_t m_cmdLayerArray = 0x30; // CUtlVector<CSeqCmdLayer>
    constexpr std::ptrdiff_t m_eventArray = 0x48; // CUtlVector<CAnimEventDefinition>
    constexpr std::ptrdiff_t m_activityArray = 0x60; // CUtlVector<CAnimActivity>
    constexpr std::ptrdiff_t m_poseSettingArray = 0x78; // CUtlVector<CSeqPoseSetting>
}

namespace CSeqIKLock {
    constexpr std::ptrdiff_t m_flPosWeight = 0x0; // float
    constexpr std::ptrdiff_t m_flAngleWeight = 0x4; // float
    constexpr std::ptrdiff_t m_nLocalBone = 0x8; // int16_t
    constexpr std::ptrdiff_t m_bBonesOrientedAlongPositiveX = 0xA; // bool
}

namespace CSeqMultiFetch {
    constexpr std::ptrdiff_t m_flags = 0x0; // CSeqMultiFetchFlag
    constexpr std::ptrdiff_t m_localReferenceArray = 0x8; // CUtlVector<int16_t>
    constexpr std::ptrdiff_t m_nGroupSize = 0x20; // int32_t[2]
    constexpr std::ptrdiff_t m_nLocalPose = 0x28; // int32_t[2]
    constexpr std::ptrdiff_t m_poseKeyArray0 = 0x30; // CUtlVector<float>
    constexpr std::ptrdiff_t m_poseKeyArray1 = 0x48; // CUtlVector<float>
    constexpr std::ptrdiff_t m_nLocalCyclePoseParameter = 0x60; // int32_t
    constexpr std::ptrdiff_t m_bCalculatePoseParameters = 0x64; // bool
}

namespace CSeqMultiFetchFlag {
    constexpr std::ptrdiff_t m_bRealtime = 0x0; // bool
    constexpr std::ptrdiff_t m_bCylepose = 0x1; // bool
    constexpr std::ptrdiff_t m_b0D = 0x2; // bool
    constexpr std::ptrdiff_t m_b1D = 0x3; // bool
    constexpr std::ptrdiff_t m_b2D = 0x4; // bool
    constexpr std::ptrdiff_t m_b2D_TRI = 0x5; // bool
}

namespace CSeqPoseParamDesc {
    constexpr std::ptrdiff_t m_sName = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_flStart = 0x10; // float
    constexpr std::ptrdiff_t m_flEnd = 0x14; // float
    constexpr std::ptrdiff_t m_flLoop = 0x18; // float
    constexpr std::ptrdiff_t m_bLooping = 0x1C; // bool
}

namespace CSeqPoseSetting {
    constexpr std::ptrdiff_t m_sPoseParameter = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_sAttachment = 0x10; // CBufferString
    constexpr std::ptrdiff_t m_sReferenceSequence = 0x20; // CBufferString
    constexpr std::ptrdiff_t m_flValue = 0x30; // float
    constexpr std::ptrdiff_t m_bX = 0x34; // bool
    constexpr std::ptrdiff_t m_bY = 0x35; // bool
    constexpr std::ptrdiff_t m_bZ = 0x36; // bool
    constexpr std::ptrdiff_t m_eType = 0x38; // int32_t
}

namespace CSeqS1SeqDesc {
    constexpr std::ptrdiff_t m_sName = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_flags = 0x10; // CSeqSeqDescFlag
    constexpr std::ptrdiff_t m_fetch = 0x20; // CSeqMultiFetch
    constexpr std::ptrdiff_t m_nLocalWeightlist = 0x88; // int32_t
    constexpr std::ptrdiff_t m_autoLayerArray = 0x90; // CUtlVector<CSeqAutoLayer>
    constexpr std::ptrdiff_t m_IKLockArray = 0xA8; // CUtlVector<CSeqIKLock>
    constexpr std::ptrdiff_t m_transition = 0xC0; // CSeqTransition
    constexpr std::ptrdiff_t m_SequenceKeys = 0xC8; // KeyValues3
    constexpr std::ptrdiff_t m_LegacyKeyValueText = 0xD8; // CBufferString
    constexpr std::ptrdiff_t m_activityArray = 0xE8; // CUtlVector<CAnimActivity>
    constexpr std::ptrdiff_t m_footMotion = 0x100; // CUtlVector<CFootMotion>
}

namespace CSeqScaleSet {
    constexpr std::ptrdiff_t m_sName = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_bRootOffset = 0x10; // bool
    constexpr std::ptrdiff_t m_vRootOffset = 0x14; // Vector
    constexpr std::ptrdiff_t m_nLocalBoneArray = 0x20; // CUtlVector<int16_t>
    constexpr std::ptrdiff_t m_flBoneScaleArray = 0x38; // CUtlVector<float>
}

namespace CSeqSeqDescFlag {
    constexpr std::ptrdiff_t m_bLooping = 0x0; // bool
    constexpr std::ptrdiff_t m_bSnap = 0x1; // bool
    constexpr std::ptrdiff_t m_bAutoplay = 0x2; // bool
    constexpr std::ptrdiff_t m_bPost = 0x3; // bool
    constexpr std::ptrdiff_t m_bHidden = 0x4; // bool
    constexpr std::ptrdiff_t m_bMulti = 0x5; // bool
    constexpr std::ptrdiff_t m_bLegacyDelta = 0x6; // bool
    constexpr std::ptrdiff_t m_bLegacyWorldspace = 0x7; // bool
    constexpr std::ptrdiff_t m_bLegacyCyclepose = 0x8; // bool
    constexpr std::ptrdiff_t m_bLegacyRealtime = 0x9; // bool
    constexpr std::ptrdiff_t m_bModelDoc = 0xA; // bool
}

namespace CSeqSynthAnimDesc {
    constexpr std::ptrdiff_t m_sName = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_flags = 0x10; // CSeqSeqDescFlag
    constexpr std::ptrdiff_t m_transition = 0x1C; // CSeqTransition
    constexpr std::ptrdiff_t m_nLocalBaseReference = 0x24; // int16_t
    constexpr std::ptrdiff_t m_nLocalBoneMask = 0x26; // int16_t
    constexpr std::ptrdiff_t m_activityArray = 0x28; // CUtlVector<CAnimActivity>
}

namespace CSeqTransition {
    constexpr std::ptrdiff_t m_flFadeInTime = 0x0; // float
    constexpr std::ptrdiff_t m_flFadeOutTime = 0x4; // float
}

namespace CSequenceFinishedAnimTag {
    constexpr std::ptrdiff_t m_sequenceName = 0x38; // CUtlString
}

namespace CSequenceGroupData {
    constexpr std::ptrdiff_t m_sName = 0x10; // CBufferString
    constexpr std::ptrdiff_t m_nFlags = 0x20; // uint32_t
    constexpr std::ptrdiff_t m_localSequenceNameArray = 0x28; // CUtlVector<CBufferString>
    constexpr std::ptrdiff_t m_localS1SeqDescArray = 0x40; // CUtlVector<CSeqS1SeqDesc>
    constexpr std::ptrdiff_t m_localMultiSeqDescArray = 0x58; // CUtlVector<CSeqS1SeqDesc>
    constexpr std::ptrdiff_t m_localSynthAnimDescArray = 0x70; // CUtlVector<CSeqSynthAnimDesc>
    constexpr std::ptrdiff_t m_localCmdSeqDescArray = 0x88; // CUtlVector<CSeqCmdSeqDesc>
    constexpr std::ptrdiff_t m_localBoneMaskArray = 0xA0; // CUtlVector<CSeqBoneMaskList>
    constexpr std::ptrdiff_t m_localScaleSetArray = 0xB8; // CUtlVector<CSeqScaleSet>
    constexpr std::ptrdiff_t m_localBoneNameArray = 0xD0; // CUtlVector<CBufferString>
    constexpr std::ptrdiff_t m_localNodeName = 0xE8; // CBufferString
    constexpr std::ptrdiff_t m_localPoseParamArray = 0xF8; // CUtlVector<CSeqPoseParamDesc>
    constexpr std::ptrdiff_t m_keyValues = 0x110; // KeyValues3
    constexpr std::ptrdiff_t m_localIKAutoplayLockArray = 0x120; // CUtlVector<CSeqIKLock>
}

namespace CSequenceUpdateNode {
    constexpr std::ptrdiff_t m_paramSpans = 0x60; // CParamSpanUpdater
    constexpr std::ptrdiff_t m_tags = 0x78; // CUtlVector<TagSpan_t>
    constexpr std::ptrdiff_t m_hSequence = 0x94; // HSequence
    constexpr std::ptrdiff_t m_playbackSpeed = 0x98; // float
    constexpr std::ptrdiff_t m_duration = 0x9C; // float
    constexpr std::ptrdiff_t m_bLoop = 0xA0; // bool
}

namespace CSetFacingUpdateNode {
    constexpr std::ptrdiff_t m_facingMode = 0x68; // FacingMode
    constexpr std::ptrdiff_t m_bResetChild = 0x6C; // bool
}

namespace CSetParameterActionUpdater {
    constexpr std::ptrdiff_t m_hParam = 0x18; // CAnimParamHandle
    constexpr std::ptrdiff_t m_value = 0x1A; // CAnimVariant
}

namespace CSingleFrameUpdateNode {
    constexpr std::ptrdiff_t m_actions = 0x58; // CUtlVector<CSmartPtr<CAnimActionUpdater>>
    constexpr std::ptrdiff_t m_hPoseCacheHandle = 0x70; // CPoseHandle
    constexpr std::ptrdiff_t m_hSequence = 0x74; // HSequence
    constexpr std::ptrdiff_t m_flCycle = 0x78; // float
}

namespace CSkeletalInputUpdateNode {
    constexpr std::ptrdiff_t m_fixedOpData = 0x58; // SkeletalInputOpFixedSettings_t
}

namespace CSlopeComponentUpdater {
    constexpr std::ptrdiff_t m_flTraceDistance = 0x34; // float
    constexpr std::ptrdiff_t m_hSlopeAngle = 0x38; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hSlopeAngleFront = 0x3A; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hSlopeAngleSide = 0x3C; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hSlopeHeading = 0x3E; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hSlopeNormal = 0x40; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hSlopeNormal_WorldSpace = 0x42; // CAnimParamHandle
}

namespace CSlowDownOnSlopesUpdateNode {
    constexpr std::ptrdiff_t m_flSlowDownStrength = 0x68; // float
}

namespace CSolveIKChainUpdateNode {
    constexpr std::ptrdiff_t m_targetHandles = 0x68; // CUtlVector<CSolveIKTargetHandle_t>
    constexpr std::ptrdiff_t m_opFixedData = 0x80; // SolveIKChainPoseOpFixedSettings_t
}

namespace CSolveIKTargetHandle_t {
    constexpr std::ptrdiff_t m_positionHandle = 0x0; // CAnimParamHandle
    constexpr std::ptrdiff_t m_orientationHandle = 0x2; // CAnimParamHandle
}

namespace CSpeedScaleUpdateNode {
    constexpr std::ptrdiff_t m_paramIndex = 0x68; // CAnimParamHandle
}

namespace CStanceOverrideUpdateNode {
    constexpr std::ptrdiff_t m_footStanceInfo = 0x68; // CUtlVector<StanceInfo_t>
    constexpr std::ptrdiff_t m_pStanceSourceNode = 0x80; // CAnimUpdateNodeRef
    constexpr std::ptrdiff_t m_hParameter = 0x90; // CAnimParamHandle
    constexpr std::ptrdiff_t m_eMode = 0x94; // StanceOverrideMode
}

namespace CStanceScaleUpdateNode {
    constexpr std::ptrdiff_t m_hParam = 0x68; // CAnimParamHandle
}

namespace CStateActionUpdater {
    constexpr std::ptrdiff_t m_pAction = 0x0; // CSmartPtr<CAnimActionUpdater>
    constexpr std::ptrdiff_t m_eBehavior = 0x8; // StateActionBehavior
}

namespace CStateMachineComponentUpdater {
    constexpr std::ptrdiff_t m_stateMachine = 0x30; // CAnimStateMachineUpdater
}

namespace CStateMachineUpdateNode {
    constexpr std::ptrdiff_t m_stateMachine = 0x68; // CAnimStateMachineUpdater
    constexpr std::ptrdiff_t m_stateData = 0xC0; // CUtlVector<CStateNodeStateData>
    constexpr std::ptrdiff_t m_transitionData = 0xD8; // CUtlVector<CStateNodeTransitionData>
    constexpr std::ptrdiff_t m_bBlockWaningTags = 0xF4; // bool
    constexpr std::ptrdiff_t m_bLockStateWhenWaning = 0xF5; // bool
}

namespace CStateNodeStateData {
    constexpr std::ptrdiff_t m_pChild = 0x0; // CAnimUpdateNodeRef
    constexpr std::ptrdiff_t m_bExclusiveRootMotion = 0x0; // bitfield:1
}

namespace CStateNodeTransitionData {
    constexpr std::ptrdiff_t m_curve = 0x0; // CBlendCurve
    constexpr std::ptrdiff_t m_blendDuration = 0x8; // CAnimValue<float>
    constexpr std::ptrdiff_t m_resetCycleValue = 0x10; // CAnimValue<float>
    constexpr std::ptrdiff_t m_bReset = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_resetCycleOption = 0x0; // bitfield:3
}

namespace CStateUpdateData {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_hScript = 0x8; // AnimScriptHandle
    constexpr std::ptrdiff_t m_transitionIndices = 0x10; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_actions = 0x28; // CUtlVector<CStateActionUpdater>
    constexpr std::ptrdiff_t m_stateID = 0x40; // AnimStateID
    constexpr std::ptrdiff_t m_bIsStartState = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bIsEndState = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bIsPassthrough = 0x0; // bitfield:1
}

namespace CStaticPoseCache {
    constexpr std::ptrdiff_t m_poses = 0x10; // CUtlVector<CCachedPose>
    constexpr std::ptrdiff_t m_nBoneCount = 0x28; // int32_t
    constexpr std::ptrdiff_t m_nMorphCount = 0x2C; // int32_t
}

namespace CStepsRemainingMetricEvaluator {
    constexpr std::ptrdiff_t m_footIndices = 0x50; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_flMinStepsRemaining = 0x68; // float
}

namespace CStopAtGoalUpdateNode {
    constexpr std::ptrdiff_t m_flOuterRadius = 0x6C; // float
    constexpr std::ptrdiff_t m_flInnerRadius = 0x70; // float
    constexpr std::ptrdiff_t m_flMaxScale = 0x74; // float
    constexpr std::ptrdiff_t m_flMinScale = 0x78; // float
    constexpr std::ptrdiff_t m_damping = 0x80; // CAnimInputDamping
}

namespace CSubtractUpdateNode {
    constexpr std::ptrdiff_t m_footMotionTiming = 0x8C; // BinaryNodeChildOption
    constexpr std::ptrdiff_t m_bApplyToFootMotion = 0x90; // bool
    constexpr std::ptrdiff_t m_bApplyChannelsSeparately = 0x91; // bool
    constexpr std::ptrdiff_t m_bUseModelSpace = 0x92; // bool
}

namespace CTiltTwistConstraint {
    constexpr std::ptrdiff_t m_nTargetAxis = 0x70; // int32_t
    constexpr std::ptrdiff_t m_nSlaveAxis = 0x74; // int32_t
}

namespace CTimeRemainingMetricEvaluator {
    constexpr std::ptrdiff_t m_bMatchByTimeRemaining = 0x50; // bool
    constexpr std::ptrdiff_t m_flMaxTimeRemaining = 0x54; // float
    constexpr std::ptrdiff_t m_bFilterByTimeRemaining = 0x58; // bool
    constexpr std::ptrdiff_t m_flMinTimeRemaining = 0x5C; // float
}

namespace CToggleComponentActionUpdater {
    constexpr std::ptrdiff_t m_componentID = 0x18; // AnimComponentID
    constexpr std::ptrdiff_t m_bSetEnabled = 0x1C; // bool
}

namespace CTransitionUpdateData {
    constexpr std::ptrdiff_t m_srcStateIndex = 0x0; // uint8_t
    constexpr std::ptrdiff_t m_destStateIndex = 0x1; // uint8_t
    constexpr std::ptrdiff_t m_bDisabled = 0x0; // bitfield:1
}

namespace CTurnHelperUpdateNode {
    constexpr std::ptrdiff_t m_facingTarget = 0x6C; // AnimValueSource
    constexpr std::ptrdiff_t m_turnStartTimeOffset = 0x70; // float
    constexpr std::ptrdiff_t m_turnDuration = 0x74; // float
    constexpr std::ptrdiff_t m_bMatchChildDuration = 0x78; // bool
    constexpr std::ptrdiff_t m_manualTurnOffset = 0x7C; // float
    constexpr std::ptrdiff_t m_bUseManualTurnOffset = 0x80; // bool
}

namespace CTwistConstraint {
    constexpr std::ptrdiff_t m_bInverse = 0x70; // bool
    constexpr std::ptrdiff_t m_qParentBindRotation = 0x80; // Quaternion
    constexpr std::ptrdiff_t m_qChildBindRotation = 0x90; // Quaternion
}

namespace CTwoBoneIKUpdateNode {
    constexpr std::ptrdiff_t m_opFixedData = 0x70; // TwoBoneIKSettings_t
}

namespace CUnaryUpdateNode {
    constexpr std::ptrdiff_t m_pChildNode = 0x58; // CAnimUpdateNodeRef
}

namespace CVPhysXSurfacePropertiesList {
    constexpr std::ptrdiff_t m_surfacePropertiesList = 0x0; // CUtlVector<CPhysSurfaceProperties*>
}

namespace CVRInputComponentUpdater {
    constexpr std::ptrdiff_t m_FingerCurl_Thumb = 0x34; // CAnimParamHandle
    constexpr std::ptrdiff_t m_FingerCurl_Index = 0x36; // CAnimParamHandle
    constexpr std::ptrdiff_t m_FingerCurl_Middle = 0x38; // CAnimParamHandle
    constexpr std::ptrdiff_t m_FingerCurl_Ring = 0x3A; // CAnimParamHandle
    constexpr std::ptrdiff_t m_FingerCurl_Pinky = 0x3C; // CAnimParamHandle
    constexpr std::ptrdiff_t m_FingerSplay_Thumb_Index = 0x3E; // CAnimParamHandle
    constexpr std::ptrdiff_t m_FingerSplay_Index_Middle = 0x40; // CAnimParamHandle
    constexpr std::ptrdiff_t m_FingerSplay_Middle_Ring = 0x42; // CAnimParamHandle
    constexpr std::ptrdiff_t m_FingerSplay_Ring_Pinky = 0x44; // CAnimParamHandle
}

namespace CVectorAnimParameter {
    constexpr std::ptrdiff_t m_defaultValue = 0x60; // Vector
    constexpr std::ptrdiff_t m_bInterpolate = 0x6C; // bool
}

namespace CVectorQuantizer {
    constexpr std::ptrdiff_t m_centroidVectors = 0x0; // CUtlVector<float>
    constexpr std::ptrdiff_t m_nCentroids = 0x18; // int32_t
    constexpr std::ptrdiff_t m_nDimensions = 0x1C; // int32_t
}

namespace CVirtualAnimParameter {
    constexpr std::ptrdiff_t m_expressionString = 0x50; // CUtlString
    constexpr std::ptrdiff_t m_eParamType = 0x58; // AnimParamType_t
}

namespace CVrSkeletalInputSettings {
    constexpr std::ptrdiff_t m_wristBones = 0x0; // CUtlVector<CWristBone>
    constexpr std::ptrdiff_t m_fingers = 0x18; // CUtlVector<CFingerChain>
    constexpr std::ptrdiff_t m_name = 0x30; // CUtlString
    constexpr std::ptrdiff_t m_outerKnuckle1 = 0x38; // CUtlString
    constexpr std::ptrdiff_t m_outerKnuckle2 = 0x40; // CUtlString
    constexpr std::ptrdiff_t m_eHand = 0x48; // AnimVRHand_t
}

namespace CWayPointHelperUpdateNode {
    constexpr std::ptrdiff_t m_flStartCycle = 0x6C; // float
    constexpr std::ptrdiff_t m_flEndCycle = 0x70; // float
    constexpr std::ptrdiff_t m_bOnlyGoals = 0x74; // bool
    constexpr std::ptrdiff_t m_bPreventOvershoot = 0x75; // bool
    constexpr std::ptrdiff_t m_bPreventUndershoot = 0x76; // bool
}

namespace CWristBone {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_vForwardLS = 0x8; // Vector
    constexpr std::ptrdiff_t m_vUpLS = 0x14; // Vector
    constexpr std::ptrdiff_t m_vOffset = 0x20; // Vector
}

namespace ChainToSolveData_t {
    constexpr std::ptrdiff_t m_nChainIndex = 0x0; // int32_t
    constexpr std::ptrdiff_t m_SolverSettings = 0x4; // IKSolverSettings_t
    constexpr std::ptrdiff_t m_TargetSettings = 0x10; // IKTargetSettings_t
    constexpr std::ptrdiff_t m_DebugSetting = 0x38; // SolveIKChainAnimNodeDebugSetting
    constexpr std::ptrdiff_t m_flDebugNormalizedValue = 0x3C; // float
    constexpr std::ptrdiff_t m_vDebugOffset = 0x40; // VectorAligned
}

namespace ConfigIndex {
    constexpr std::ptrdiff_t m_nGroup = 0x0; // uint16_t
    constexpr std::ptrdiff_t m_nConfig = 0x2; // uint16_t
}

namespace FingerBone_t {
    constexpr std::ptrdiff_t m_boneIndex = 0x0; // int32_t
    constexpr std::ptrdiff_t m_hingeAxis = 0x4; // Vector
    constexpr std::ptrdiff_t m_vCapsulePos1 = 0x10; // Vector
    constexpr std::ptrdiff_t m_vCapsulePos2 = 0x1C; // Vector
    constexpr std::ptrdiff_t m_flMinAngle = 0x28; // float
    constexpr std::ptrdiff_t m_flMaxAngle = 0x2C; // float
    constexpr std::ptrdiff_t m_flRadius = 0x30; // float
}

namespace FingerChain_t {
    constexpr std::ptrdiff_t m_targets = 0x0; // CUtlVector<FingerSource_t>
    constexpr std::ptrdiff_t m_bones = 0x18; // CUtlVector<FingerBone_t>
    constexpr std::ptrdiff_t m_vTipOffset = 0x30; // Vector
    constexpr std::ptrdiff_t m_vSplayHingeAxis = 0x3C; // Vector
    constexpr std::ptrdiff_t m_tipParentBoneIndex = 0x48; // int32_t
    constexpr std::ptrdiff_t m_metacarpalBoneIndex = 0x4C; // int32_t
    constexpr std::ptrdiff_t m_flSplayMinAngle = 0x50; // float
    constexpr std::ptrdiff_t m_flSplayMaxAngle = 0x54; // float
    constexpr std::ptrdiff_t m_flFingerScaleRatio = 0x58; // float
}

namespace FingerSource_t {
    constexpr std::ptrdiff_t m_nFingerIndex = 0x0; // AnimVRFinger_t
    constexpr std::ptrdiff_t m_flFingerWeight = 0x4; // float
}

namespace FollowAttachmentSettings_t {
    constexpr std::ptrdiff_t m_attachment = 0x0; // CAnimAttachment
    constexpr std::ptrdiff_t m_boneIndex = 0x80; // int32_t
    constexpr std::ptrdiff_t m_bMatchTranslation = 0x84; // bool
    constexpr std::ptrdiff_t m_bMatchRotation = 0x85; // bool
}

namespace FootFixedData_t {
    constexpr std::ptrdiff_t m_vToeOffset = 0x0; // VectorAligned
    constexpr std::ptrdiff_t m_vHeelOffset = 0x10; // VectorAligned
    constexpr std::ptrdiff_t m_nTargetBoneIndex = 0x20; // int32_t
    constexpr std::ptrdiff_t m_nAnkleBoneIndex = 0x24; // int32_t
    constexpr std::ptrdiff_t m_nIKAnchorBoneIndex = 0x28; // int32_t
    constexpr std::ptrdiff_t m_ikChainIndex = 0x2C; // int32_t
    constexpr std::ptrdiff_t m_flMaxIKLength = 0x30; // float
    constexpr std::ptrdiff_t m_nFootIndex = 0x34; // int32_t
    constexpr std::ptrdiff_t m_nTagIndex = 0x38; // int32_t
    constexpr std::ptrdiff_t m_flMaxRotationLeft = 0x3C; // float
    constexpr std::ptrdiff_t m_flMaxRotationRight = 0x40; // float
}

namespace FootFixedSettings {
    constexpr std::ptrdiff_t m_traceSettings = 0x0; // TraceSettings_t
    constexpr std::ptrdiff_t m_vFootBaseBindPosePositionMS = 0x10; // VectorAligned
    constexpr std::ptrdiff_t m_flFootBaseLength = 0x20; // float
    constexpr std::ptrdiff_t m_flMaxRotationLeft = 0x24; // float
    constexpr std::ptrdiff_t m_flMaxRotationRight = 0x28; // float
    constexpr std::ptrdiff_t m_footstepLandedTagIndex = 0x2C; // int32_t
    constexpr std::ptrdiff_t m_bEnableTracing = 0x30; // bool
    constexpr std::ptrdiff_t m_flTraceAngleBlend = 0x34; // float
    constexpr std::ptrdiff_t m_nDisableTagIndex = 0x38; // int32_t
    constexpr std::ptrdiff_t m_nFootIndex = 0x3C; // int32_t
}

namespace FootLockPoseOpFixedSettings {
    constexpr std::ptrdiff_t m_footInfo = 0x0; // CUtlVector<FootFixedData_t>
    constexpr std::ptrdiff_t m_hipDampingSettings = 0x18; // CAnimInputDamping
    constexpr std::ptrdiff_t m_nHipBoneIndex = 0x28; // int32_t
    constexpr std::ptrdiff_t m_ikSolverType = 0x2C; // IKSolverType
    constexpr std::ptrdiff_t m_bApplyTilt = 0x30; // bool
    constexpr std::ptrdiff_t m_bApplyHipDrop = 0x31; // bool
    constexpr std::ptrdiff_t m_bAlwaysUseFallbackHinge = 0x32; // bool
    constexpr std::ptrdiff_t m_bApplyFootRotationLimits = 0x33; // bool
    constexpr std::ptrdiff_t m_bApplyLegTwistLimits = 0x34; // bool
    constexpr std::ptrdiff_t m_flMaxFootHeight = 0x38; // float
    constexpr std::ptrdiff_t m_flExtensionScale = 0x3C; // float
    constexpr std::ptrdiff_t m_flMaxLegTwist = 0x40; // float
    constexpr std::ptrdiff_t m_bEnableLockBreaking = 0x44; // bool
    constexpr std::ptrdiff_t m_flLockBreakTolerance = 0x48; // float
    constexpr std::ptrdiff_t m_flLockBlendTime = 0x4C; // float
    constexpr std::ptrdiff_t m_bEnableStretching = 0x50; // bool
    constexpr std::ptrdiff_t m_flMaxStretchAmount = 0x54; // float
    constexpr std::ptrdiff_t m_flStretchExtensionScale = 0x58; // float
}

namespace FootPinningPoseOpFixedData_t {
    constexpr std::ptrdiff_t m_footInfo = 0x0; // CUtlVector<FootFixedData_t>
    constexpr std::ptrdiff_t m_flBlendTime = 0x18; // float
    constexpr std::ptrdiff_t m_flLockBreakDistance = 0x1C; // float
    constexpr std::ptrdiff_t m_flMaxLegTwist = 0x20; // float
    constexpr std::ptrdiff_t m_nHipBoneIndex = 0x24; // int32_t
    constexpr std::ptrdiff_t m_bApplyLegTwistLimits = 0x28; // bool
    constexpr std::ptrdiff_t m_bApplyFootRotationLimits = 0x29; // bool
}

namespace FootStepTrigger {
    constexpr std::ptrdiff_t m_tags = 0x0; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_nFootIndex = 0x18; // int32_t
    constexpr std::ptrdiff_t m_triggerPhase = 0x1C; // StepPhase
}

namespace HSequence {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace HitReactFixedSettings_t {
    constexpr std::ptrdiff_t m_nWeightListIndex = 0x0; // int32_t
    constexpr std::ptrdiff_t m_nEffectedBoneCount = 0x4; // int32_t
    constexpr std::ptrdiff_t m_flMaxImpactForce = 0x8; // float
    constexpr std::ptrdiff_t m_flMinImpactForce = 0xC; // float
    constexpr std::ptrdiff_t m_flWhipImpactScale = 0x10; // float
    constexpr std::ptrdiff_t m_flCounterRotationScale = 0x14; // float
    constexpr std::ptrdiff_t m_flDistanceFadeScale = 0x18; // float
    constexpr std::ptrdiff_t m_flPropagationScale = 0x1C; // float
    constexpr std::ptrdiff_t m_flWhipDelay = 0x20; // float
    constexpr std::ptrdiff_t m_flSpringStrength = 0x24; // float
    constexpr std::ptrdiff_t m_flWhipSpringStrength = 0x28; // float
    constexpr std::ptrdiff_t m_flMaxAngleRadians = 0x2C; // float
    constexpr std::ptrdiff_t m_nHipBoneIndex = 0x30; // int32_t
    constexpr std::ptrdiff_t m_flHipBoneTranslationScale = 0x34; // float
    constexpr std::ptrdiff_t m_flHipDipSpringStrength = 0x38; // float
    constexpr std::ptrdiff_t m_flHipDipImpactScale = 0x3C; // float
    constexpr std::ptrdiff_t m_flHipDipDelay = 0x40; // float
}

namespace IKBoneNameAndIndex_t {
    constexpr std::ptrdiff_t m_Name = 0x0; // CUtlString
}

namespace IKDemoCaptureSettings_t {
    constexpr std::ptrdiff_t m_parentBoneName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_eMode = 0x8; // IKChannelMode
    constexpr std::ptrdiff_t m_ikChainName = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_oneBoneStart = 0x18; // CUtlString
    constexpr std::ptrdiff_t m_oneBoneEnd = 0x20; // CUtlString
}

namespace IKSolverSettings_t {
    constexpr std::ptrdiff_t m_SolverType = 0x0; // IKSolverType
    constexpr std::ptrdiff_t m_nNumIterations = 0x4; // int32_t
}

namespace IKTargetSettings_t {
    constexpr std::ptrdiff_t m_TargetSource = 0x0; // IKTargetSource
    constexpr std::ptrdiff_t m_Bone = 0x8; // IKBoneNameAndIndex_t
    constexpr std::ptrdiff_t m_AnimgraphParameterNamePosition = 0x18; // AnimParamID
    constexpr std::ptrdiff_t m_AnimgraphParameterNameOrientation = 0x1C; // AnimParamID
    constexpr std::ptrdiff_t m_TargetCoordSystem = 0x20; // IKTargetCoordinateSystem
}

namespace JiggleBoneSettingsList_t {
    constexpr std::ptrdiff_t m_boneSettings = 0x0; // CUtlVector<JiggleBoneSettings_t>
}

namespace JiggleBoneSettings_t {
    constexpr std::ptrdiff_t m_nBoneIndex = 0x0; // int32_t
    constexpr std::ptrdiff_t m_flSpringStrength = 0x4; // float
    constexpr std::ptrdiff_t m_flMaxTimeStep = 0x8; // float
    constexpr std::ptrdiff_t m_flDamping = 0xC; // float
    constexpr std::ptrdiff_t m_vBoundsMaxLS = 0x10; // Vector
    constexpr std::ptrdiff_t m_vBoundsMinLS = 0x1C; // Vector
    constexpr std::ptrdiff_t m_eSimSpace = 0x28; // JiggleBoneSimSpace
}

namespace LookAtBone_t {
    constexpr std::ptrdiff_t m_index = 0x0; // int32_t
    constexpr std::ptrdiff_t m_weight = 0x4; // float
}

namespace LookAtOpFixedSettings_t {
    constexpr std::ptrdiff_t m_attachment = 0x0; // CAnimAttachment
    constexpr std::ptrdiff_t m_damping = 0x80; // CAnimInputDamping
    constexpr std::ptrdiff_t m_bones = 0x90; // CUtlVector<LookAtBone_t>
    constexpr std::ptrdiff_t m_flYawLimit = 0xA8; // float
    constexpr std::ptrdiff_t m_flPitchLimit = 0xAC; // float
    constexpr std::ptrdiff_t m_flHysteresisInnerAngle = 0xB0; // float
    constexpr std::ptrdiff_t m_flHysteresisOuterAngle = 0xB4; // float
    constexpr std::ptrdiff_t m_bRotateYawForward = 0xB8; // bool
    constexpr std::ptrdiff_t m_bMaintainUpDirection = 0xB9; // bool
    constexpr std::ptrdiff_t m_bTargetIsPosition = 0xBA; // bool
    constexpr std::ptrdiff_t m_bUseHysteresis = 0xBB; // bool
}

namespace MaterialGroup_t {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_materials = 0x8; // CUtlVector<CStrongHandle<InfoForResourceTypeIMaterial2>>
}

namespace ModelBoneFlexDriverControl_t {
    constexpr std::ptrdiff_t m_nBoneComponent = 0x0; // ModelBoneFlexComponent_t
    constexpr std::ptrdiff_t m_flexController = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_flexControllerToken = 0x10; // uint32_t
    constexpr std::ptrdiff_t m_flMin = 0x14; // float
    constexpr std::ptrdiff_t m_flMax = 0x18; // float
}

namespace ModelBoneFlexDriver_t {
    constexpr std::ptrdiff_t m_boneName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_boneNameToken = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_controls = 0x10; // CUtlVector<ModelBoneFlexDriverControl_t>
}

namespace ModelSkeletonData_t {
    constexpr std::ptrdiff_t m_boneName = 0x0; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_nParent = 0x18; // CUtlVector<int16_t>
    constexpr std::ptrdiff_t m_boneSphere = 0x30; // CUtlVector<float>
    constexpr std::ptrdiff_t m_nFlag = 0x48; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_bonePosParent = 0x60; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_boneRotParent = 0x78; // CUtlVector<QuaternionStorage>
    constexpr std::ptrdiff_t m_boneScaleParent = 0x90; // CUtlVector<float>
}

namespace MoodAnimationLayer_t {
    constexpr std::ptrdiff_t m_sName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_bActiveListening = 0x8; // bool
    constexpr std::ptrdiff_t m_bActiveTalking = 0x9; // bool
    constexpr std::ptrdiff_t m_layerAnimations = 0x10; // CUtlVector<MoodAnimation_t>
    constexpr std::ptrdiff_t m_flIntensity = 0x28; // CRangeFloat
    constexpr std::ptrdiff_t m_flDurationScale = 0x30; // CRangeFloat
    constexpr std::ptrdiff_t m_bScaleWithInts = 0x38; // bool
    constexpr std::ptrdiff_t m_flNextStart = 0x3C; // CRangeFloat
    constexpr std::ptrdiff_t m_flStartOffset = 0x44; // CRangeFloat
    constexpr std::ptrdiff_t m_flEndOffset = 0x4C; // CRangeFloat
    constexpr std::ptrdiff_t m_flFadeIn = 0x54; // float
    constexpr std::ptrdiff_t m_flFadeOut = 0x58; // float
}

namespace MoodAnimation_t {
    constexpr std::ptrdiff_t m_sName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_flWeight = 0x8; // float
}

namespace MotionBlendItem {
    constexpr std::ptrdiff_t m_pChild = 0x0; // CSmartPtr<CMotionNode>
    constexpr std::ptrdiff_t m_flKeyValue = 0x8; // float
}

namespace MotionDBIndex {
    constexpr std::ptrdiff_t m_nIndex = 0x0; // uint32_t
}

namespace MotionIndex {
    constexpr std::ptrdiff_t m_nGroup = 0x0; // uint16_t
    constexpr std::ptrdiff_t m_nMotion = 0x2; // uint16_t
}

namespace ParamSpanSample_t {
    constexpr std::ptrdiff_t m_value = 0x0; // CAnimVariant
    constexpr std::ptrdiff_t m_flCycle = 0x14; // float
}

namespace ParamSpan_t {
    constexpr std::ptrdiff_t m_samples = 0x0; // CUtlVector<ParamSpanSample_t>
    constexpr std::ptrdiff_t m_hParam = 0x18; // CAnimParamHandle
    constexpr std::ptrdiff_t m_eParamType = 0x1A; // AnimParamType_t
    constexpr std::ptrdiff_t m_flStartCycle = 0x1C; // float
    constexpr std::ptrdiff_t m_flEndCycle = 0x20; // float
}

namespace PermModelDataAnimatedMaterialAttribute_t {
    constexpr std::ptrdiff_t m_AttributeName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nNumChannels = 0x8; // int32_t
}

namespace PermModelData_t {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_modelInfo = 0x8; // PermModelInfo_t
    constexpr std::ptrdiff_t m_ExtParts = 0x60; // CUtlVector<PermModelExtPart_t>
    constexpr std::ptrdiff_t m_refMeshes = 0x78; // CUtlVector<CStrongHandle<InfoForResourceTypeCRenderMesh>>
    constexpr std::ptrdiff_t m_refMeshGroupMasks = 0x90; // CUtlVector<uint64_t>
    constexpr std::ptrdiff_t m_refPhysGroupMasks = 0xA8; // CUtlVector<uint64_t>
    constexpr std::ptrdiff_t m_refLODGroupMasks = 0xC0; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_lodGroupSwitchDistances = 0xD8; // CUtlVector<float>
    constexpr std::ptrdiff_t m_refPhysicsData = 0xF0; // CUtlVector<CStrongHandle<InfoForResourceTypeCPhysAggregateData>>
    constexpr std::ptrdiff_t m_refPhysicsHitboxData = 0x108; // CUtlVector<CStrongHandle<InfoForResourceTypeCPhysAggregateData>>
    constexpr std::ptrdiff_t m_refAnimGroups = 0x120; // CUtlVector<CStrongHandle<InfoForResourceTypeCAnimationGroup>>
    constexpr std::ptrdiff_t m_refSequenceGroups = 0x138; // CUtlVector<CStrongHandle<InfoForResourceTypeCSequenceGroupData>>
    constexpr std::ptrdiff_t m_meshGroups = 0x150; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_materialGroups = 0x168; // CUtlVector<MaterialGroup_t>
    constexpr std::ptrdiff_t m_nDefaultMeshGroupMask = 0x180; // uint64_t
    constexpr std::ptrdiff_t m_modelSkeleton = 0x188; // ModelSkeletonData_t
    constexpr std::ptrdiff_t m_remappingTable = 0x230; // CUtlVector<int16_t>
    constexpr std::ptrdiff_t m_remappingTableStarts = 0x248; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_boneFlexDrivers = 0x260; // CUtlVector<ModelBoneFlexDriver_t>
    constexpr std::ptrdiff_t m_pModelConfigList = 0x278; // CModelConfigList*
    constexpr std::ptrdiff_t m_BodyGroupsHiddenInTools = 0x280; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_refAnimIncludeModels = 0x298; // CUtlVector<CStrongHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_AnimatedMaterialAttributes = 0x2B0; // CUtlVector<PermModelDataAnimatedMaterialAttribute_t>
}

namespace PermModelExtPart_t {
    constexpr std::ptrdiff_t m_Transform = 0x0; // CTransform
    constexpr std::ptrdiff_t m_Name = 0x20; // CUtlString
    constexpr std::ptrdiff_t m_nParent = 0x28; // int32_t
    constexpr std::ptrdiff_t m_refModel = 0x30; // CStrongHandle<InfoForResourceTypeCModel>
}

namespace PermModelInfo_t {
    constexpr std::ptrdiff_t m_nFlags = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_vHullMin = 0x4; // Vector
    constexpr std::ptrdiff_t m_vHullMax = 0x10; // Vector
    constexpr std::ptrdiff_t m_vViewMin = 0x1C; // Vector
    constexpr std::ptrdiff_t m_vViewMax = 0x28; // Vector
    constexpr std::ptrdiff_t m_flMass = 0x34; // float
    constexpr std::ptrdiff_t m_vEyePosition = 0x38; // Vector
    constexpr std::ptrdiff_t m_flMaxEyeDeflection = 0x44; // float
    constexpr std::ptrdiff_t m_sSurfaceProperty = 0x48; // CUtlString
    constexpr std::ptrdiff_t m_keyValueText = 0x50; // CUtlString
}

namespace PhysSoftbodyDesc_t {
    constexpr std::ptrdiff_t m_ParticleBoneHash = 0x0; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_Particles = 0x18; // CUtlVector<RnSoftbodyParticle_t>
    constexpr std::ptrdiff_t m_Springs = 0x30; // CUtlVector<RnSoftbodySpring_t>
    constexpr std::ptrdiff_t m_Capsules = 0x48; // CUtlVector<RnSoftbodyCapsule_t>
    constexpr std::ptrdiff_t m_InitPose = 0x60; // CUtlVector<CTransform>
    constexpr std::ptrdiff_t m_ParticleBoneName = 0x78; // CUtlVector<CUtlString>
}

namespace RenderSkeletonBone_t {
    constexpr std::ptrdiff_t m_boneName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_parentName = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_invBindPose = 0x10; // matrix3x4_t
    constexpr std::ptrdiff_t m_bbox = 0x40; // SkeletonBoneBounds_t
    constexpr std::ptrdiff_t m_flSphereRadius = 0x58; // float
}

namespace SampleCode {
    constexpr std::ptrdiff_t m_subCode = 0x0; // uint8_t[8]
}

namespace ScriptInfo_t {
    constexpr std::ptrdiff_t m_code = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_paramsModified = 0x8; // CUtlVector<CAnimParamHandle>
    constexpr std::ptrdiff_t m_proxyReadParams = 0x20; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_proxyWriteParams = 0x38; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_eScriptType = 0x50; // AnimScriptType
}

namespace SkeletalInputOpFixedSettings_t {
    constexpr std::ptrdiff_t m_wristBones = 0x0; // CUtlVector<WristBone_t>
    constexpr std::ptrdiff_t m_fingers = 0x18; // CUtlVector<FingerChain_t>
    constexpr std::ptrdiff_t m_outerKnuckle1 = 0x30; // int32_t
    constexpr std::ptrdiff_t m_outerKnuckle2 = 0x34; // int32_t
    constexpr std::ptrdiff_t m_eHand = 0x38; // AnimVRHand_t
    constexpr std::ptrdiff_t m_eMotionRange = 0x3C; // AnimVRHandMotionRange_t
    constexpr std::ptrdiff_t m_eTransformSource = 0x40; // AnimVrBoneTransformSource_t
    constexpr std::ptrdiff_t m_bEnableIK = 0x44; // bool
    constexpr std::ptrdiff_t m_bEnableCollision = 0x45; // bool
}

namespace SkeletonBoneBounds_t {
    constexpr std::ptrdiff_t m_vecCenter = 0x0; // Vector
    constexpr std::ptrdiff_t m_vecSize = 0xC; // Vector
}

namespace SolveIKChainPoseOpFixedSettings_t {
    constexpr std::ptrdiff_t m_ChainsToSolveData = 0x0; // CUtlVector<ChainToSolveData_t>
    constexpr std::ptrdiff_t m_bMatchTargetOrientation = 0x18; // bool
}

namespace StanceInfo_t {
    constexpr std::ptrdiff_t m_vPosition = 0x0; // Vector
    constexpr std::ptrdiff_t m_flDirection = 0xC; // float
}

namespace TagSpan_t {
    constexpr std::ptrdiff_t m_tagIndex = 0x0; // int32_t
    constexpr std::ptrdiff_t m_startCycle = 0x4; // float
    constexpr std::ptrdiff_t m_endCycle = 0x8; // float
}

namespace TraceSettings_t {
    constexpr std::ptrdiff_t m_flTraceHeight = 0x0; // float
    constexpr std::ptrdiff_t m_flTraceRadius = 0x4; // float
}

namespace TwoBoneIKSettings_t {
    constexpr std::ptrdiff_t m_endEffectorType = 0x0; // IkEndEffectorType
    constexpr std::ptrdiff_t m_endEffectorAttachment = 0x10; // CAnimAttachment
    constexpr std::ptrdiff_t m_targetType = 0x90; // IkTargetType
    constexpr std::ptrdiff_t m_targetAttachment = 0xA0; // CAnimAttachment
    constexpr std::ptrdiff_t m_targetBoneIndex = 0x120; // int32_t
    constexpr std::ptrdiff_t m_hPositionParam = 0x124; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hRotationParam = 0x126; // CAnimParamHandle
    constexpr std::ptrdiff_t m_bAlwaysUseFallbackHinge = 0x128; // bool
    constexpr std::ptrdiff_t m_vLsFallbackHingeAxis = 0x130; // VectorAligned
    constexpr std::ptrdiff_t m_nFixedBoneIndex = 0x140; // int32_t
    constexpr std::ptrdiff_t m_nMiddleBoneIndex = 0x144; // int32_t
    constexpr std::ptrdiff_t m_nEndBoneIndex = 0x148; // int32_t
    constexpr std::ptrdiff_t m_bMatchTargetOrientation = 0x14C; // bool
    constexpr std::ptrdiff_t m_bConstrainTwist = 0x14D; // bool
    constexpr std::ptrdiff_t m_flMaxTwist = 0x150; // float
}

namespace VPhysXAggregateData_t {
    constexpr std::ptrdiff_t m_nFlags = 0x0; // uint16_t
    constexpr std::ptrdiff_t m_nRefCounter = 0x2; // uint16_t
    constexpr std::ptrdiff_t m_bonesHash = 0x8; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_boneNames = 0x20; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_indexNames = 0x38; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_indexHash = 0x50; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_bindPose = 0x68; // CUtlVector<matrix3x4a_t>
    constexpr std::ptrdiff_t m_parts = 0x80; // CUtlVector<VPhysXBodyPart_t>
    constexpr std::ptrdiff_t m_constraints2 = 0x98; // CUtlVector<VPhysXConstraint2_t>
    constexpr std::ptrdiff_t m_joints = 0xB0; // CUtlVector<VPhysXJoint_t>
    constexpr std::ptrdiff_t m_pFeModel = 0xC8; // PhysFeModelDesc_t*
    constexpr std::ptrdiff_t m_boneParents = 0xD0; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_surfacePropertyHashes = 0xE8; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_collisionAttributes = 0x100; // CUtlVector<VPhysXCollisionAttributes_t>
    constexpr std::ptrdiff_t m_debugPartNames = 0x118; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_embeddedKeyvalues = 0x130; // CUtlString
}

namespace VPhysXBodyPart_t {
    constexpr std::ptrdiff_t m_nFlags = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_flMass = 0x4; // float
    constexpr std::ptrdiff_t m_rnShape = 0x8; // VPhysics2ShapeDef_t
    constexpr std::ptrdiff_t m_nCollisionAttributeIndex = 0x80; // uint16_t
    constexpr std::ptrdiff_t m_nReserved = 0x82; // uint16_t
    constexpr std::ptrdiff_t m_flInertiaScale = 0x84; // float
    constexpr std::ptrdiff_t m_flLinearDamping = 0x88; // float
    constexpr std::ptrdiff_t m_flAngularDamping = 0x8C; // float
    constexpr std::ptrdiff_t m_bOverrideMassCenter = 0x90; // bool
    constexpr std::ptrdiff_t m_vMassCenterOverride = 0x94; // Vector
}

namespace VPhysXCollisionAttributes_t {
    constexpr std::ptrdiff_t m_CollisionGroup = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_InteractAs = 0x8; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_InteractWith = 0x20; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_InteractExclude = 0x38; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_CollisionGroupString = 0x50; // CUtlString
    constexpr std::ptrdiff_t m_InteractAsStrings = 0x58; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_InteractWithStrings = 0x70; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_InteractExcludeStrings = 0x88; // CUtlVector<CUtlString>
}

namespace VPhysXConstraint2_t {
    constexpr std::ptrdiff_t m_nFlags = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_nParent = 0x4; // uint16_t
    constexpr std::ptrdiff_t m_nChild = 0x6; // uint16_t
    constexpr std::ptrdiff_t m_params = 0x8; // VPhysXConstraintParams_t
}

namespace VPhysXConstraintParams_t {
    constexpr std::ptrdiff_t m_nType = 0x0; // int8_t
    constexpr std::ptrdiff_t m_nTranslateMotion = 0x1; // int8_t
    constexpr std::ptrdiff_t m_nRotateMotion = 0x2; // int8_t
    constexpr std::ptrdiff_t m_nFlags = 0x3; // int8_t
    constexpr std::ptrdiff_t m_anchor = 0x4; // Vector[2]
    constexpr std::ptrdiff_t m_axes = 0x1C; // QuaternionStorage[2]
    constexpr std::ptrdiff_t m_maxForce = 0x3C; // float
    constexpr std::ptrdiff_t m_maxTorque = 0x40; // float
    constexpr std::ptrdiff_t m_linearLimitValue = 0x44; // float
    constexpr std::ptrdiff_t m_linearLimitRestitution = 0x48; // float
    constexpr std::ptrdiff_t m_linearLimitSpring = 0x4C; // float
    constexpr std::ptrdiff_t m_linearLimitDamping = 0x50; // float
    constexpr std::ptrdiff_t m_twistLowLimitValue = 0x54; // float
    constexpr std::ptrdiff_t m_twistLowLimitRestitution = 0x58; // float
    constexpr std::ptrdiff_t m_twistLowLimitSpring = 0x5C; // float
    constexpr std::ptrdiff_t m_twistLowLimitDamping = 0x60; // float
    constexpr std::ptrdiff_t m_twistHighLimitValue = 0x64; // float
    constexpr std::ptrdiff_t m_twistHighLimitRestitution = 0x68; // float
    constexpr std::ptrdiff_t m_twistHighLimitSpring = 0x6C; // float
    constexpr std::ptrdiff_t m_twistHighLimitDamping = 0x70; // float
    constexpr std::ptrdiff_t m_swing1LimitValue = 0x74; // float
    constexpr std::ptrdiff_t m_swing1LimitRestitution = 0x78; // float
    constexpr std::ptrdiff_t m_swing1LimitSpring = 0x7C; // float
    constexpr std::ptrdiff_t m_swing1LimitDamping = 0x80; // float
    constexpr std::ptrdiff_t m_swing2LimitValue = 0x84; // float
    constexpr std::ptrdiff_t m_swing2LimitRestitution = 0x88; // float
    constexpr std::ptrdiff_t m_swing2LimitSpring = 0x8C; // float
    constexpr std::ptrdiff_t m_swing2LimitDamping = 0x90; // float
    constexpr std::ptrdiff_t m_goalPosition = 0x94; // Vector
    constexpr std::ptrdiff_t m_goalOrientation = 0xA0; // QuaternionStorage
    constexpr std::ptrdiff_t m_goalAngularVelocity = 0xB0; // Vector
    constexpr std::ptrdiff_t m_driveSpringX = 0xBC; // float
    constexpr std::ptrdiff_t m_driveSpringY = 0xC0; // float
    constexpr std::ptrdiff_t m_driveSpringZ = 0xC4; // float
    constexpr std::ptrdiff_t m_driveDampingX = 0xC8; // float
    constexpr std::ptrdiff_t m_driveDampingY = 0xCC; // float
    constexpr std::ptrdiff_t m_driveDampingZ = 0xD0; // float
    constexpr std::ptrdiff_t m_driveSpringTwist = 0xD4; // float
    constexpr std::ptrdiff_t m_driveSpringSwing = 0xD8; // float
    constexpr std::ptrdiff_t m_driveSpringSlerp = 0xDC; // float
    constexpr std::ptrdiff_t m_driveDampingTwist = 0xE0; // float
    constexpr std::ptrdiff_t m_driveDampingSwing = 0xE4; // float
    constexpr std::ptrdiff_t m_driveDampingSlerp = 0xE8; // float
    constexpr std::ptrdiff_t m_solverIterationCount = 0xEC; // int32_t
    constexpr std::ptrdiff_t m_projectionLinearTolerance = 0xF0; // float
    constexpr std::ptrdiff_t m_projectionAngularTolerance = 0xF4; // float
}

namespace VPhysXJoint_t {
    constexpr std::ptrdiff_t m_nType = 0x0; // uint16_t
    constexpr std::ptrdiff_t m_nBody1 = 0x2; // uint16_t
    constexpr std::ptrdiff_t m_nBody2 = 0x4; // uint16_t
    constexpr std::ptrdiff_t m_nFlags = 0x6; // uint16_t
    constexpr std::ptrdiff_t m_Frame1 = 0x10; // CTransform
    constexpr std::ptrdiff_t m_Frame2 = 0x30; // CTransform
    constexpr std::ptrdiff_t m_bEnableCollision = 0x50; // bool
    constexpr std::ptrdiff_t m_bEnableLinearLimit = 0x51; // bool
    constexpr std::ptrdiff_t m_LinearLimit = 0x54; // VPhysXRange_t
    constexpr std::ptrdiff_t m_bEnableLinearMotor = 0x5C; // bool
    constexpr std::ptrdiff_t m_vLinearTargetVelocity = 0x60; // Vector
    constexpr std::ptrdiff_t m_flMaxForce = 0x6C; // float
    constexpr std::ptrdiff_t m_bEnableSwingLimit = 0x70; // bool
    constexpr std::ptrdiff_t m_SwingLimit = 0x74; // VPhysXRange_t
    constexpr std::ptrdiff_t m_bEnableTwistLimit = 0x7C; // bool
    constexpr std::ptrdiff_t m_TwistLimit = 0x80; // VPhysXRange_t
    constexpr std::ptrdiff_t m_bEnableAngularMotor = 0x88; // bool
    constexpr std::ptrdiff_t m_vAngularTargetVelocity = 0x8C; // Vector
    constexpr std::ptrdiff_t m_flMaxTorque = 0x98; // float
    constexpr std::ptrdiff_t m_flLinearFrequency = 0x9C; // float
    constexpr std::ptrdiff_t m_flLinearDampingRatio = 0xA0; // float
    constexpr std::ptrdiff_t m_flAngularFrequency = 0xA4; // float
    constexpr std::ptrdiff_t m_flAngularDampingRatio = 0xA8; // float
    constexpr std::ptrdiff_t m_flFriction = 0xAC; // float
}

namespace VPhysXRange_t {
    constexpr std::ptrdiff_t m_flMin = 0x0; // float
    constexpr std::ptrdiff_t m_flMax = 0x4; // float
}

namespace VPhysics2ShapeDef_t {
    constexpr std::ptrdiff_t m_spheres = 0x0; // CUtlVector<RnSphereDesc_t>
    constexpr std::ptrdiff_t m_capsules = 0x18; // CUtlVector<RnCapsuleDesc_t>
    constexpr std::ptrdiff_t m_hulls = 0x30; // CUtlVector<RnHullDesc_t>
    constexpr std::ptrdiff_t m_meshes = 0x48; // CUtlVector<RnMeshDesc_t>
    constexpr std::ptrdiff_t m_CollisionAttributeIndices = 0x60; // CUtlVector<uint16_t>
}

namespace WeightList {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_weights = 0x8; // CUtlVector<float>
}

namespace WristBone_t {
    constexpr std::ptrdiff_t m_xOffsetTransformMS = 0x0; // CTransform
    constexpr std::ptrdiff_t m_boneIndex = 0x20; // int32_t
}
```

`SDK/animationsystem.dll.json`:

```json
{
  "AimMatrixOpFixedSettings_t": {
    "m_attachment": 0,
    "m_bTargetIsPosition": 200,
    "m_damping": 128,
    "m_eBlendMode": 184,
    "m_fAngleIncrement": 188,
    "m_nBoneMaskIndex": 196,
    "m_nSequenceMaxFrame": 192,
    "m_poseCacheHandles": 144
  },
  "AnimComponentID": {
    "m_id": 0
  },
  "AnimNodeID": {
    "m_id": 0
  },
  "AnimNodeOutputID": {
    "m_id": 0
  },
  "AnimParamID": {
    "m_id": 0
  },
  "AnimScriptHandle": {
    "m_id": 0
  },
  "AnimStateID": {
    "m_id": 0
  },
  "AnimTagID": {
    "m_id": 0
  },
  "AnimationDecodeDebugDumpElement_t": {
    "m_decodeOps": 40,
    "m_decodedAnims": 88,
    "m_internalOps": 64,
    "m_modelName": 8,
    "m_nEntityIndex": 0,
    "m_poseParams": 16
  },
  "AnimationDecodeDebugDump_t": {
    "m_elems": 8,
    "m_processingType": 0
  },
  "AnimationSnapshotBase_t": {
    "m_DecodeDump": 152,
    "m_SnapshotType": 144,
    "m_bBonesInWorldSpace": 64,
    "m_bHasDecodeDump": 148,
    "m_boneSetupMask": 72,
    "m_boneTransforms": 96,
    "m_flRealTime": 0,
    "m_flexControllers": 120,
    "m_rootToWorld": 16
  },
  "AnimationSnapshot_t": {
    "m_modelName": 280,
    "m_nEntIndex": 272
  },
  "AttachmentHandle_t": {
    "m_Value": 0
  },
  "BlendItem_t": {
    "m_bUseCustomDuration": 56,
    "m_flDuration": 52,
    "m_hSequence": 40,
    "m_pChild": 24,
    "m_tags": 0,
    "m_vPos": 44
  },
  "BoneDemoCaptureSettings_t": {
    "m_boneName": 0,
    "m_flChainLength": 8
  },
  "CActionComponentUpdater": {
    "m_actions": 48
  },
  "CAddUpdateNode": {
    "m_bApplyChannelsSeparately": 145,
    "m_bApplyToFootMotion": 144,
    "m_bUseModelSpace": 146,
    "m_footMotionTiming": 140
  },
  "CAimConstraint": {
    "m_nUpType": 128,
    "m_qAimOffset": 112
  },
  "CAimMatrixUpdateNode": {
    "m_bLockWhenWaning": 341,
    "m_bResetChild": 340,
    "m_hSequence": 336,
    "m_opFixedSettings": 112,
    "m_paramIndex": 332,
    "m_target": 328
  },
  "CAnimActivity": {
    "m_nActivity": 16,
    "m_nFlags": 20,
    "m_nWeight": 24,
    "m_name": 0
  },
  "CAnimAttachment": {
    "m_influenceIndices": 96,
    "m_influenceOffsets": 48,
    "m_influenceRotations": 0,
    "m_influenceWeights": 108,
    "m_numInfluences": 120
  },
  "CAnimBone": {
    "m_flags": 68,
    "m_name": 0,
    "m_parent": 16,
    "m_pos": 20,
    "m_qAlignment": 52,
    "m_quat": 32,
    "m_scale": 48
  },
  "CAnimBoneDifference": {
    "m_bHasMovement": 45,
    "m_bHasRotation": 44,
    "m_name": 0,
    "m_parent": 16,
    "m_posError": 32
  },
  "CAnimComponentUpdater": {
    "m_bStartEnabled": 40,
    "m_id": 32,
    "m_name": 24,
    "m_networkMode": 36
  },
  "CAnimData": {
    "m_animArray": 32,
    "m_decoderArray": 56,
    "m_nMaxUniqueFrameIndex": 80,
    "m_name": 16,
    "m_segmentArray": 88
  },
  "CAnimDataChannelDesc": {
    "m_nElementIndexArray": 96,
    "m_nElementMaskArray": 120,
    "m_nFlags": 32,
    "m_nType": 36,
    "m_szChannelClass": 0,
    "m_szDescription": 56,
    "m_szElementNameArray": 72,
    "m_szGrouping": 40,
    "m_szVariableName": 16
  },
  "CAnimDecoder": {
    "m_nType": 20,
    "m_nVersion": 16,
    "m_szName": 0
  },
  "CAnimDemoCaptureSettings": {
    "m_baseSequence": 56,
    "m_boneSelectionMode": 68,
    "m_bones": 72,
    "m_flIkRotation_MaxQuantizationError": 44,
    "m_flIkRotation_MaxSplineError": 24,
    "m_flIkTranslation_MaxQuantizationError": 48,
    "m_flIkTranslation_MaxSplineError": 28,
    "m_flMaxQuantizationErrorRotation": 32,
    "m_flMaxQuantizationErrorScale": 40,
    "m_flMaxQuantizationErrorTranslation": 36,
    "m_flMaxSplineErrorScale": 20,
    "m_flMaxSplineErrorTranslation": 16,
    "m_ikChains": 96,
    "m_nBaseSequenceFrame": 64,
    "m_rangeBoneChainLength": 0,
    "m_rangeMaxSplineErrorRotation": 8
  },
  "CAnimDesc": {
    "fps": 24,
    "framestalltime": 344,
    "m_Data": 32,
    "m_activityArray": 296,
    "m_eventArray": 272,
    "m_flags": 16,
    "m_hierarchyArray": 320,
    "m_movementArray": 248,
    "m_name": 0,
    "m_sequenceParams": 424,
    "m_vecBoneWorldMax": 400,
    "m_vecBoneWorldMin": 376,
    "m_vecRootMax": 360,
    "m_vecRootMin": 348
  },
  "CAnimDesc_Flag": {
    "m_bAllZeros": 1,
    "m_bAnimGraphAdditive": 7,
    "m_bDelta": 3,
    "m_bHidden": 2,
    "m_bImplicitSeqIgnoreDelta": 6,
    "m_bLegacyWorldspace": 4,
    "m_bLooping": 0,
    "m_bModelDoc": 5
  },
  "CAnimEncodeDifference": {
    "m_bHasMorphBitArray": 120,
    "m_bHasMovementBitArray": 96,
    "m_bHasRotationBitArray": 72,
    "m_bHasUserBitArray": 144,
    "m_boneArray": 0,
    "m_morphArray": 24,
    "m_userArray": 48
  },
  "CAnimEncodedFrames": {
    "m_fileName": 0,
    "m_frameblockArray": 24,
    "m_nFrames": 16,
    "m_nFramesPerBlock": 20,
    "m_usageDifferences": 48
  },
  "CAnimEnum": {
    "m_value": 0
  },
  "CAnimEventDefinition": {
    "m_EventData": 16,
    "m_flCycle": 12,
    "m_nFrame": 8,
    "m_sEventName": 48,
    "m_sLegacyOptions": 32
  },
  "CAnimFoot": {
    "m_ankleBoneIndex": 32,
    "m_name": 0,
    "m_toeBoneIndex": 36,
    "m_vBallOffset": 8,
    "m_vHeelOffset": 20
  },
  "CAnimFrameBlockAnim": {
    "m_nEndFrame": 4,
    "m_nStartFrame": 0,
    "m_segmentIndexArray": 8
  },
  "CAnimFrameSegment": {
    "m_container": 16,
    "m_nLocalChannel": 8,
    "m_nLocalElementMasks": 4,
    "m_nUniqueFrameIndex": 0
  },
  "CAnimGraphDebugReplay": {
    "m_animGraphFileName": 64,
    "m_frameCount": 104,
    "m_frameList": 72,
    "m_startIndex": 96,
    "m_writeIndex": 100
  },
  "CAnimGraphModelBinding": {
    "m_modelName": 8,
    "m_pSharedData": 16
  },
  "CAnimGraphNetworkSettings": {
    "m_bNetworkingEnabled": 32
  },
  "CAnimGraphSettingsManager": {
    "m_settingsGroups": 24
  },
  "CAnimInputDamping": {
    "m_fSpeedScale": 12,
    "m_speedFunction": 8
  },
  "CAnimKeyData": {
    "m_boneArray": 16,
    "m_dataChannelArray": 96,
    "m_morphArray": 64,
    "m_nChannelElements": 88,
    "m_name": 0,
    "m_userArray": 40
  },
  "CAnimLocalHierarchy": {
    "m_nEndFrame": 44,
    "m_nPeakFrame": 36,
    "m_nStartFrame": 32,
    "m_nTailFrame": 40,
    "m_sBone": 0,
    "m_sNewParent": 16
  },
  "CAnimMorphDifference": {
    "m_name": 0
  },
  "CAnimMotorUpdaterBase": {
    "m_bDefault": 24,
    "m_name": 16
  },
  "CAnimMovement": {
    "angle": 16,
    "endframe": 0,
    "motionflags": 4,
    "position": 32,
    "v0": 8,
    "v1": 12,
    "vector": 20
  },
  "CAnimNodePath": {
    "m_nCount": 44,
    "m_path": 0
  },
  "CAnimParamHandle": {
    "m_index": 1,
    "m_type": 0
  },
  "CAnimParamHandleMap": {
    "m_list": 0
  },
  "CAnimParameterBase": {
    "m_bIsReferenced": 77,
    "m_bNetworkingRequested": 76,
    "m_componentName": 64,
    "m_group": 32,
    "m_id": 40,
    "m_name": 24
  },
  "CAnimParameterManagerUpdater": {
    "m_autoResetMap": 160,
    "m_autoResetParams": 136,
    "m_idToIndexMap": 48,
    "m_indexToHandle": 112,
    "m_nameToIndexMap": 80,
    "m_parameters": 24
  },
  "CAnimReplayFrame": {
    "m_inputDataBlocks": 16,
    "m_instanceData": 40,
    "m_localToWorldTransform": 96,
    "m_startingLocalToWorldTransform": 64,
    "m_timeStamp": 128
  },
  "CAnimScriptComponentUpdater": {
    "m_hScript": 48
  },
  "CAnimScriptManager": {
    "m_scriptInfo": 16
  },
  "CAnimSequenceParams": {
    "m_flFadeInTime": 0,
    "m_flFadeOutTime": 4
  },
  "CAnimSkeleton": {
    "m_boneNames": 64,
    "m_children": 88,
    "m_feet": 136,
    "m_localSpaceTransforms": 16,
    "m_lodBoneCounts": 184,
    "m_modelSpaceTransforms": 40,
    "m_morphNames": 160,
    "m_parents": 112
  },
  "CAnimStateMachineUpdater": {
    "m_startStateIndex": 80,
    "m_states": 8,
    "m_transitions": 32
  },
  "CAnimTagBase": {
    "m_bIsReferenced": 44,
    "m_group": 32,
    "m_name": 24,
    "m_tagID": 40
  },
  "CAnimTagManagerUpdater": {
    "m_tags": 24
  },
  "CAnimUpdateNodeBase": {
    "m_name": 80,
    "m_networkMode": 72,
    "m_nodePath": 24
  },
  "CAnimUpdateNodeRef": {
    "m_nodeIndex": 8
  },
  "CAnimUpdateSharedData": {
    "m_components": 72,
    "m_nodeIndexMap": 40,
    "m_nodes": 16,
    "m_pParamListUpdater": 96,
    "m_pSkeleton": 176,
    "m_pStaticPoseCache": 168,
    "m_pTagManagerUpdater": 104,
    "m_rootNodePath": 184,
    "m_scriptManager": 112,
    "m_settings": 120
  },
  "CAnimUser": {
    "m_nType": 16,
    "m_name": 0
  },
  "CAnimUserDifference": {
    "m_nType": 16,
    "m_name": 0
  },
  "CAnimationGraphVisualizerAxis": {
    "m_flAxisSize": 96,
    "m_xWsTransform": 64
  },
  "CAnimationGraphVisualizerLine": {
    "m_Color": 96,
    "m_vWsPositionEnd": 80,
    "m_vWsPositionStart": 64
  },
  "CAnimationGraphVisualizerPie": {
    "m_Color": 112,
    "m_vWsCenter": 64,
    "m_vWsEnd": 96,
    "m_vWsStart": 80
  },
  "CAnimationGraphVisualizerPrimitiveBase": {
    "m_OwningAnimNodePaths": 12,
    "m_Type": 8,
    "m_nOwningAnimNodePathCount": 56
  },
  "CAnimationGraphVisualizerSphere": {
    "m_Color": 84,
    "m_flRadius": 80,
    "m_vWsPosition": 64
  },
  "CAnimationGraphVisualizerText": {
    "m_Color": 80,
    "m_Text": 88,
    "m_vWsPosition": 64
  },
  "CAnimationGroup": {
    "m_decodeKey": 152,
    "m_directHSeqGroup_Handle": 144,
    "m_includedGroupArray_Handle": 120,
    "m_localHAnimArray_Handle": 96,
    "m_nFlags": 16,
    "m_name": 24,
    "m_szScripts": 272
  },
  "CAttachment": {
    "m_bIgnoreRotation": 132,
    "m_bInfluenceRootTransform": 128,
    "m_influenceNames": 8,
    "m_influenceWeights": 116,
    "m_nInfluences": 131,
    "m_name": 0,
    "m_vInfluenceOffsets": 80,
    "m_vInfluenceRotations": 32
  },
  "CAudioAnimTag": {
    "m_attachmentName": 64,
    "m_bPlayOnClient": 79,
    "m_bPlayOnServer": 78,
    "m_bStopWhenGraphEnds": 77,
    "m_bStopWhenTagEnds": 76,
    "m_clipName": 56,
    "m_flVolume": 72
  },
  "CBaseConstraint": {
    "m_name": 40,
    "m_slaves": 64,
    "m_targets": 88,
    "m_vUpVector": 48
  },
  "CBinaryUpdateNode": {
    "m_bResetChild1": 128,
    "m_bResetChild2": 129,
    "m_flTimingBlend": 124,
    "m_pChild1": 88,
    "m_pChild2": 104,
    "m_timingBehavior": 120
  },
  "CBlend2DUpdateNode": {
    "m_bAnimEventsAndTagsOnMostWeightedOnly": 235,
    "m_bLockBlendOnReset": 233,
    "m_bLockWhenWaning": 234,
    "m_bLoop": 232,
    "m_blendSourceX": 208,
    "m_blendSourceY": 216,
    "m_damping": 192,
    "m_eBlendMode": 224,
    "m_items": 96,
    "m_nodeItemIndices": 168,
    "m_paramSpans": 144,
    "m_paramX": 212,
    "m_paramY": 220,
    "m_playbackSpeed": 228,
    "m_tags": 120
  },
  "CBlendCurve": {
    "m_flControlPoint1": 0,
    "m_flControlPoint2": 4
  },
  "CBlendUpdateNode": {
    "m_bLockBlendOnReset": 204,
    "m_bLockWhenWaning": 207,
    "m_bLoop": 206,
    "m_bSyncCycles": 205,
    "m_blendKeyType": 200,
    "m_blendValueSource": 172,
    "m_children": 96,
    "m_damping": 184,
    "m_paramIndex": 176,
    "m_sortedOrder": 120,
    "m_targetValues": 144
  },
  "CBodyGroupAnimTag": {
    "m_bodyGroupSettings": 64,
    "m_nPriority": 56
  },
  "CBodyGroupSetting": {
    "m_BodyGroupName": 0,
    "m_nBodyGroupOption": 8
  },
  "CBoneConstraintDotToMorph": {
    "m_flRemap": 64,
    "m_sBoneName": 40,
    "m_sMorphChannelName": 56,
    "m_sTargetBoneName": 48
  },
  "CBoneConstraintPoseSpaceBone": {
    "m_inputList": 112
  },
  "CBoneConstraintPoseSpaceBone_Input_t": {
    "m_inputValue": 0,
    "m_outputTransformList": 16
  },
  "CBoneConstraintPoseSpaceMorph": {
    "m_bClamp": 104,
    "m_inputList": 80,
    "m_outputMorph": 56,
    "m_sAttachmentName": 48,
    "m_sBoneName": 40
  },
  "CBoneConstraintPoseSpaceMorph_Input_t": {
    "m_inputValue": 0,
    "m_outputWeightList": 16
  },
  "CBoneMaskUpdateNode": {
    "m_bUseBlendScale": 156,
    "m_blendSpace": 148,
    "m_blendValueSource": 160,
    "m_flRootMotionBlend": 144,
    "m_footMotionTiming": 152,
    "m_hBlendParameter": 164,
    "m_nWeightListIndex": 140
  },
  "CBonePositionMetricEvaluator": {
    "m_nBoneIndex": 80
  },
  "CBoneVelocityMetricEvaluator": {
    "m_nBoneIndex": 80
  },
  "CBoolAnimParameter": {
    "m_bDefaultValue": 96
  },
  "CCPPScriptComponentUpdater": {
    "m_scriptsToRun": 48
  },
  "CCachedPose": {
    "m_flCycle": 60,
    "m_hSequence": 56,
    "m_morphWeights": 32,
    "m_transforms": 8
  },
  "CChoiceUpdateNode": {
    "m_bCrossFade": 176,
    "m_bDontResetSameSelection": 178,
    "m_bResetChosen": 177,
    "m_blendMethod": 168,
    "m_blendTime": 172,
    "m_blendTimes": 136,
    "m_children": 88,
    "m_choiceChangeMethod": 164,
    "m_choiceMethod": 160,
    "m_weights": 112
  },
  "CClothSettingsAnimTag": {
    "m_flEaseIn": 60,
    "m_flEaseOut": 64,
    "m_flStiffness": 56,
    "m_nVertexSet": 72
  },
  "CCompressorGroup": {
    "m_boolCompressor": 320,
    "m_colorCompressor": 344,
    "m_intCompressor": 296,
    "m_nCompressorIndex": 128,
    "m_nElementMask": 200,
    "m_nElementUniqueID": 176,
    "m_nFlags": 80,
    "m_nTotalElementCount": 0,
    "m_nType": 56,
    "m_quaternionCompressor": 272,
    "m_szChannelClass": 8,
    "m_szElementNames": 152,
    "m_szGrouping": 104,
    "m_szVariableName": 32,
    "m_vector2DCompressor": 368,
    "m_vector4DCompressor": 392,
    "m_vectorCompressor": 248
  },
  "CConcreteAnimParameter": {
    "m_bAutoReset": 89,
    "m_bGameWritable": 90,
    "m_bGraphWritable": 91,
    "m_bUseMostRecentValue": 88,
    "m_eNetworkSetting": 84,
    "m_previewButton": 80
  },
  "CConstraintSlave": {
    "m_flWeight": 32,
    "m_nBoneHash": 28,
    "m_qBaseOrientation": 0,
    "m_sName": 40,
    "m_vBasePosition": 16
  },
  "CConstraintTarget": {
    "m_bIsAttachment": 89,
    "m_flWeight": 72,
    "m_nBoneHash": 60,
    "m_qOffset": 32,
    "m_sName": 64,
    "m_vOffset": 48
  },
  "CCycleBase": {
    "m_flCycle": 0
  },
  "CCycleControlClipUpdateNode": {
    "m_duration": 128,
    "m_hSequence": 124,
    "m_paramIndex": 136,
    "m_tags": 96,
    "m_valueSource": 132
  },
  "CCycleControlUpdateNode": {
    "m_paramIndex": 108,
    "m_valueSource": 104
  },
  "CDampedPathAnimMotorUpdater": {
    "m_flAnticipationTime": 44,
    "m_flMaxSpringTension": 64,
    "m_flMinSpeedScale": 48,
    "m_flMinSpringTension": 60,
    "m_flSpringConstant": 56,
    "m_hAnticipationHeadingParam": 54,
    "m_hAnticipationPosParam": 52
  },
  "CDampedValueComponentUpdater": {
    "m_items": 48
  },
  "CDampedValueUpdateItem": {
    "m_damping": 0,
    "m_hParamIn": 24,
    "m_hParamOut": 26
  },
  "CDemoSettingsComponentUpdater": {
    "m_settings": 48
  },
  "CDirectPlaybackTagData": {
    "m_sequenceName": 0,
    "m_tags": 8
  },
  "CDirectPlaybackUpdateNode": {
    "m_allTags": 112,
    "m_bFinishEarly": 108,
    "m_bResetOnFinish": 109
  },
  "CDirectionalBlendUpdateNode": {
    "m_bLockBlendOnReset": 161,
    "m_bLoop": 160,
    "m_blendValueSource": 144,
    "m_damping": 128,
    "m_duration": 156,
    "m_hSequences": 92,
    "m_paramIndex": 148,
    "m_playbackSpeed": 152
  },
  "CDistanceRemainingMetricEvaluator": {
    "m_bFilterFixedMinDistance": 96,
    "m_bFilterGoalDistance": 97,
    "m_bFilterGoalOvershoot": 98,
    "m_flMaxDistance": 80,
    "m_flMaxGoalOvershootScale": 92,
    "m_flMinDistance": 84,
    "m_flStartGoalFilterDistance": 88
  },
  "CDrawCullingData": {
    "m_ConeAxis": 12,
    "m_ConeCutoff": 15,
    "m_vConeApex": 0
  },
  "CEmitTagActionUpdater": {
    "m_bIsZeroDuration": 28,
    "m_nTagIndex": 24
  },
  "CEnumAnimParameter": {
    "m_defaultValue": 104,
    "m_enumOptions": 112
  },
  "CExpressionActionUpdater": {
    "m_eParamType": 26,
    "m_hParam": 24,
    "m_hScript": 28
  },
  "CFingerBone": {
    "m_boneName": 0,
    "m_flMaxAngle": 48,
    "m_flMinAngle": 44,
    "m_flRadius": 52,
    "m_hingeAxis": 8,
    "m_vCapsulePos1": 20,
    "m_vCapsulePos2": 32
  },
  "CFingerChain": {
    "m_bones": 24,
    "m_flFingerScaleRatio": 108,
    "m_flSplayMaxAngle": 104,
    "m_flSplayMinAngle": 100,
    "m_metacarpalBoneName": 80,
    "m_name": 48,
    "m_targets": 0,
    "m_tipParentBoneName": 56,
    "m_vSplayHingeAxis": 88,
    "m_vTipOffset": 64
  },
  "CFingerSource": {
    "m_flFingerWeight": 4,
    "m_nFingerIndex": 0
  },
  "CFlexController": {
    "m_szName": 0,
    "m_szType": 8,
    "max": 20,
    "min": 16
  },
  "CFlexDesc": {
    "m_szFacs": 0
  },
  "CFlexOp": {
    "m_Data": 4,
    "m_OpCode": 0
  },
  "CFlexRule": {
    "m_FlexOps": 8,
    "m_nFlex": 0
  },
  "CFloatAnimParameter": {
    "m_bInterpolate": 108,
    "m_fDefaultValue": 96,
    "m_fMaxValue": 104,
    "m_fMinValue": 100
  },
  "CFollowAttachmentUpdateNode": {
    "m_opFixedData": 112
  },
  "CFollowPathUpdateNode": {
    "m_bBlockNonPathMovement": 112,
    "m_bScaleSpeed": 114,
    "m_bStopFeetAtGoal": 113,
    "m_bTurnToFace": 164,
    "m_facingTarget": 152,
    "m_flBlendOutTime": 108,
    "m_flMaxAngle": 124,
    "m_flMinAngle": 120,
    "m_flScale": 116,
    "m_flSpeedScaleBlending": 128,
    "m_flTurnToFaceOffset": 160,
    "m_hParam": 156,
    "m_turnDamping": 136
  },
  "CFootAdjustmentUpdateNode": {
    "m_bAnimationDriven": 161,
    "m_bResetChild": 160,
    "m_clips": 112,
    "m_facingTarget": 140,
    "m_flStepHeightMax": 152,
    "m_flStepHeightMaxAngle": 156,
    "m_flTurnTimeMax": 148,
    "m_flTurnTimeMin": 144,
    "m_hBasePoseCacheHandle": 136
  },
  "CFootCycleDefinition": {
    "m_flStanceDirectionMS": 24,
    "m_footLandCycle": 56,
    "m_footLiftCycle": 44,
    "m_footOffCycle": 48,
    "m_footStrikeCycle": 52,
    "m_stanceCycle": 40,
    "m_vMidpointPositionMS": 12,
    "m_vStancePositionMS": 0,
    "m_vToStrideStartPos": 28
  },
  "CFootCycleMetricEvaluator": {
    "m_footIndices": 80
  },
  "CFootDefinition": {
    "m_ankleBoneName": 8,
    "m_flBindPoseDirectionMS": 52,
    "m_flFootLength": 48,
    "m_flTraceHeight": 56,
    "m_flTraceRadius": 60,
    "m_name": 0,
    "m_toeBoneName": 16,
    "m_vBallOffset": 24,
    "m_vHeelOffset": 36
  },
  "CFootFallAnimTag": {
    "m_foot": 56
  },
  "CFootLockUpdateNode": {
    "m_bApplyFootRotationLimits": 304,
    "m_bApplyHipShift": 305,
    "m_bEnableRootHeightDamping": 309,
    "m_bEnableVerticalCurvedPaths": 308,
    "m_bModulateStepHeight": 306,
    "m_bResetChild": 307,
    "m_flBlendTime": 284,
    "m_flHipShiftScale": 280,
    "m_flMaxRootHeightOffset": 288,
    "m_flMinRootHeightOffset": 292,
    "m_flStepHeightDecreaseScale": 276,
    "m_flStepHeightIncreaseScale": 272,
    "m_flStrideCurveLimitScale": 268,
    "m_flStrideCurveScale": 264,
    "m_flTiltPlanePitchSpringStrength": 296,
    "m_flTiltPlaneRollSpringStrength": 300,
    "m_footSettings": 208,
    "m_hipShiftDamping": 232,
    "m_opFixedSettings": 104,
    "m_rootHeightDamping": 248
  },
  "CFootMotion": {
    "m_bAdditive": 32,
    "m_name": 24,
    "m_strides": 0
  },
  "CFootPinningUpdateNode": {
    "m_bResetChild": 192,
    "m_eTimingSource": 160,
    "m_params": 168,
    "m_poseOpFixedData": 112
  },
  "CFootPositionMetricEvaluator": {
    "m_bIgnoreSlope": 104,
    "m_footIndices": 80
  },
  "CFootStepTriggerUpdateNode": {
    "m_flTolerance": 132,
    "m_triggers": 104
  },
  "CFootStride": {
    "m_definition": 0,
    "m_trajectories": 64
  },
  "CFootTrajectories": {
    "m_trajectories": 0
  },
  "CFootTrajectory": {
    "m_flProgression": 16,
    "m_flRotationOffset": 12,
    "m_vOffset": 0
  },
  "CFootstepLandedAnimTag": {
    "m_BoneName": 80,
    "m_DebugAnimSourceString": 72,
    "m_FootstepType": 56,
    "m_OverrideSoundName": 64
  },
  "CFutureFacingMetricEvaluator": {
    "m_flDistance": 80,
    "m_flTime": 84
  },
  "CFutureVelocityMetricEvaluator": {
    "m_eMode": 92,
    "m_flDistance": 80,
    "m_flStoppingDistance": 84,
    "m_flTargetSpeed": 88
  },
  "CHitBox": {
    "m_CRC": 64,
    "m_bTranslationOnly": 61,
    "m_cRenderColor": 68,
    "m_flShapeRadius": 48,
    "m_nBoneNameHash": 52,
    "m_nGroupId": 56,
    "m_nHitBoxIndex": 72,
    "m_nShapeType": 60,
    "m_name": 0,
    "m_sBoneName": 16,
    "m_sSurfaceProperty": 8,
    "m_vMaxBounds": 36,
    "m_vMinBounds": 24
  },
  "CHitBoxSet": {
    "m_HitBoxes": 16,
    "m_SourceFilename": 40,
    "m_nNameHash": 8,
    "m_name": 0
  },
  "CHitBoxSetList": {
    "m_HitBoxSets": 0
  },
  "CHitReactUpdateNode": {
    "m_bResetChild": 196,
    "m_flMinDelayBetweenHits": 192,
    "m_hitBoneParam": 182,
    "m_hitDirectionParam": 186,
    "m_hitOffsetParam": 184,
    "m_hitStrengthParam": 188,
    "m_opFixedSettings": 104,
    "m_triggerParam": 180
  },
  "CIntAnimParameter": {
    "m_defaultValue": 96,
    "m_maxValue": 104,
    "m_minValue": 100
  },
  "CJiggleBoneUpdateNode": {
    "m_opFixedData": 104
  },
  "CJumpHelperUpdateNode": {
    "m_bScaleSpeed": 203,
    "m_bTranslationAxis": 200,
    "m_eCorrectionMethod": 196,
    "m_flJumpEndCycle": 192,
    "m_flJumpStartCycle": 188,
    "m_flOriginalJumpDuration": 184,
    "m_flOriginalJumpMovement": 172,
    "m_hTargetParam": 168
  },
  "CLODComponentUpdater": {
    "m_nServerLOD": 48
  },
  "CLeanMatrixUpdateNode": {
    "m_blendSource": 184,
    "m_damping": 168,
    "m_flMaxValue": 220,
    "m_frameCorners": 92,
    "m_hSequence": 216,
    "m_horizontalAxis": 204,
    "m_nSequenceMaxFrame": 224,
    "m_paramIndex": 188,
    "m_poses": 128,
    "m_verticalAxis": 192
  },
  "CLookAtUpdateNode": {
    "m_bLockWhenWaning": 321,
    "m_bResetChild": 320,
    "m_opFixedSettings": 112,
    "m_paramIndex": 316,
    "m_target": 312,
    "m_weightParamIndex": 318
  },
  "CLookComponentUpdater": {
    "m_bNetworkLookTarget": 66,
    "m_hLookDirection": 60,
    "m_hLookDistance": 58,
    "m_hLookHeading": 52,
    "m_hLookHeadingVelocity": 54,
    "m_hLookPitch": 56,
    "m_hLookTarget": 62,
    "m_hLookTargetWorldSpace": 64
  },
  "CMaterialAttributeAnimTag": {
    "m_AttributeName": 56,
    "m_AttributeType": 64,
    "m_Color": 72,
    "m_flValue": 68
  },
  "CMaterialDrawDescriptor": {
    "m_flAlpha": 36,
    "m_flUvDensity": 20,
    "m_indexBuffer": 184,
    "m_material": 224,
    "m_nBaseVertex": 4,
    "m_nFirstMeshlet": 44,
    "m_nIndexCount": 16,
    "m_nNumMeshlets": 48,
    "m_nPrimitiveType": 0,
    "m_nStartIndex": 12,
    "m_nVertexCount": 8,
    "m_vTintColor": 24
  },
  "CMeshletDescriptor": {
    "m_CullingData": 8,
    "m_PackedAABB": 0
  },
  "CModelConfig": {
    "m_ConfigName": 0,
    "m_Elements": 8,
    "m_bTopLevel": 32
  },
  "CModelConfigElement": {
    "m_ElementName": 8,
    "m_NestedElements": 16
  },
  "CModelConfigElement_AttachedModel": {
    "m_AttachmentName": 120,
    "m_AttachmentType": 136,
    "m_BodygroupOnOtherModels": 144,
    "m_EntityClass": 80,
    "m_InstanceName": 72,
    "m_LocalAttachmentOffsetName": 128,
    "m_MaterialGroupOnOtherModels": 152,
    "m_aAngOffset": 108,
    "m_bAcceptParentMaterialDrivenDecals": 143,
    "m_bBoneMergeFlex": 140,
    "m_bUserSpecifiedColor": 141,
    "m_bUserSpecifiedMaterialGroup": 142,
    "m_hModel": 88,
    "m_vOffset": 96
  },
  "CModelConfigElement_Command": {
    "m_Args": 80,
    "m_Command": 72
  },
  "CModelConfigElement_RandomColor": {
    "m_Gradient": 72
  },
  "CModelConfigElement_RandomPick": {
    "m_ChoiceWeights": 96,
    "m_Choices": 72
  },
  "CModelConfigElement_SetBodygroup": {
    "m_GroupName": 72,
    "m_nChoice": 80
  },
  "CModelConfigElement_SetBodygroupOnAttachedModels": {
    "m_GroupName": 72,
    "m_nChoice": 80
  },
  "CModelConfigElement_SetMaterialGroup": {
    "m_MaterialGroupName": 72
  },
  "CModelConfigElement_SetMaterialGroupOnAttachedModels": {
    "m_MaterialGroupName": 72
  },
  "CModelConfigElement_SetRenderColor": {
    "m_Color": 72
  },
  "CModelConfigElement_UserPick": {
    "m_Choices": 72
  },
  "CModelConfigList": {
    "m_Configs": 8,
    "m_bHideMaterialGroupInTools": 0,
    "m_bHideRenderColorInTools": 1
  },
  "CMoodVData": {
    "m_animationLayers": 232,
    "m_nMoodType": 224,
    "m_sModelName": 0
  },
  "CMorphBundleData": {
    "m_flULeftSrc": 0,
    "m_flVTopSrc": 4,
    "m_offsets": 8,
    "m_ranges": 32
  },
  "CMorphConstraint": {
    "m_flMax": 128,
    "m_flMin": 124,
    "m_nSlaveChannel": 120,
    "m_sTargetMorph": 112
  },
  "CMorphData": {
    "m_morphRectDatas": 8,
    "m_name": 0
  },
  "CMorphRectData": {
    "m_bundleDatas": 16,
    "m_flUWidthSrc": 4,
    "m_flVHeightSrc": 8,
    "m_nXLeftDst": 0,
    "m_nYTopDst": 2
  },
  "CMorphSetData": {
    "m_FlexControllers": 104,
    "m_FlexDesc": 80,
    "m_FlexRules": 128,
    "m_bundleTypes": 24,
    "m_morphDatas": 48,
    "m_nHeight": 20,
    "m_nWidth": 16,
    "m_pTextureAtlas": 72
  },
  "CMotionDataSet": {
    "m_groups": 0,
    "m_nDimensionCount": 24
  },
  "CMotionGraph": {
    "m_bLoop": 84,
    "m_nConfigCount": 80,
    "m_nConfigStartIndex": 76,
    "m_nParameterCount": 72,
    "m_pRootNode": 64,
    "m_paramSpans": 16,
    "m_tags": 40
  },
  "CMotionGraphConfig": {
    "m_flDuration": 16,
    "m_nMotionIndex": 20,
    "m_nSampleCount": 28,
    "m_nSampleStart": 24,
    "m_paramValues": 0
  },
  "CMotionGraphGroup": {
    "m_hIsActiveScript": 256,
    "m_motionGraphConfigs": 208,
    "m_motionGraphs": 184,
    "m_sampleToConfig": 232,
    "m_searchDB": 0
  },
  "CMotionGraphUpdateNode": {
    "m_pMotionGraph": 88
  },
  "CMotionMatchingUpdateNode": {
    "m_bEnableDistanceScaling": 312,
    "m_bEnableRotationCorrection": 264,
    "m_bGoalAssist": 265,
    "m_bLockClipWhenWaning": 252,
    "m_bSearchEveryTick": 224,
    "m_bSearchWhenClipEnds": 232,
    "m_bSearchWhenGoalChanges": 233,
    "m_blendCurve": 236,
    "m_dataSet": 88,
    "m_distanceScale_Damping": 280,
    "m_flBlendTime": 248,
    "m_flDistanceScale_InnerRadius": 300,
    "m_flDistanceScale_MaxScale": 304,
    "m_flDistanceScale_MinScale": 308,
    "m_flDistanceScale_OuterRadius": 296,
    "m_flGoalAssistDistance": 268,
    "m_flGoalAssistTolerance": 272,
    "m_flReselectionTimeWindow": 260,
    "m_flSampleRate": 244,
    "m_flSearchInterval": 228,
    "m_flSelectionThreshold": 256,
    "m_metrics": 120,
    "m_weights": 144
  },
  "CMotionMetricEvaluator": {
    "m_flWeight": 72,
    "m_means": 24,
    "m_nDimensionStartIndex": 76,
    "m_standardDeviations": 48
  },
  "CMotionNode": {
    "m_id": 32,
    "m_name": 24
  },
  "CMotionNodeBlend1D": {
    "m_blendItems": 40,
    "m_nParamIndex": 64
  },
  "CMotionNodeSequence": {
    "m_flPlaybackSpeed": 68,
    "m_hSequence": 64,
    "m_tags": 40
  },
  "CMotionSearchDB": {
    "m_codeIndices": 160,
    "m_residualQuantizer": 128,
    "m_rootNode": 0
  },
  "CMotionSearchNode": {
    "m_children": 0,
    "m_quantizer": 24,
    "m_sampleCodes": 56,
    "m_sampleIndices": 80,
    "m_selectableSamples": 104
  },
  "CMovementComponentUpdater": {
    "m_bMoveVarsDisabled": 128,
    "m_bNetworkFacing": 130,
    "m_bNetworkPath": 129,
    "m_eDefaultFacingMode": 112,
    "m_facingDamping": 96,
    "m_motors": 72,
    "m_movementModes": 48,
    "m_nDefaultMotorIndex": 124,
    "m_paramHandles": 131
  },
  "CMovementMode": {
    "m_flSpeed": 8,
    "m_name": 0
  },
  "CMoverUpdateNode": {
    "m_bAdditive": 148,
    "m_bApplyMovement": 149,
    "m_bApplyRotation": 151,
    "m_bLimitOnly": 152,
    "m_bOrientMovement": 150,
    "m_damping": 112,
    "m_facingTarget": 128,
    "m_flTurnToFaceLimit": 144,
    "m_flTurnToFaceOffset": 140,
    "m_hMoveHeadingParam": 134,
    "m_hMoveVecParam": 132,
    "m_hTurnToFaceParam": 136
  },
  "CParamSpanUpdater": {
    "m_spans": 0
  },
  "CParticleAnimTag": {
    "m_attachmentCP1Name": 104,
    "m_attachmentCP1Type": 112,
    "m_attachmentName": 88,
    "m_attachmentType": 96,
    "m_bDetachFromOwner": 80,
    "m_bStopWhenTagEnds": 81,
    "m_bTagEndStopIsInstant": 82,
    "m_configName": 72,
    "m_hParticleSystem": 56,
    "m_particleSystemName": 64
  },
  "CPathAnimMotorUpdaterBase": {
    "m_bLockToPath": 32
  },
  "CPathHelperUpdateNode": {
    "m_flStoppingRadius": 104,
    "m_flStoppingSpeedScale": 108
  },
  "CPathMetricEvaluator": {
    "m_bExtrapolateMovement": 108,
    "m_flDistance": 104,
    "m_flMinExtrapolationSpeed": 112,
    "m_pathTimeSamples": 80
  },
  "CPhysSurfaceProperties": {
    "m_audioParams": 136,
    "m_audioSounds": 72,
    "m_bHidden": 24,
    "m_baseNameHash": 12,
    "m_description": 32,
    "m_name": 0,
    "m_nameHash": 8,
    "m_physics": 40
  },
  "CPhysSurfacePropertiesAudio": {
    "m_flOcclusionFactor": 28,
    "m_flStaticImpactVolume": 24,
    "m_hardThreshold": 16,
    "m_hardVelocityThreshold": 20,
    "m_hardnessFactor": 4,
    "m_reflectivity": 0,
    "m_roughThreshold": 12,
    "m_roughnessFactor": 8
  },
  "CPhysSurfacePropertiesPhysics": {
    "m_density": 8,
    "m_elasticity": 4,
    "m_friction": 0,
    "m_softContactDampingRatio": 20,
    "m_softContactFrequency": 16,
    "m_thickness": 12,
    "m_wheelDrag": 24
  },
  "CPhysSurfacePropertiesSoundNames": {
    "m_break": 48,
    "m_bulletImpact": 32,
    "m_impactHard": 8,
    "m_impactSoft": 0,
    "m_rolling": 40,
    "m_scrapeRough": 24,
    "m_scrapeSmooth": 16,
    "m_strain": 56
  },
  "CPlayerInputAnimMotorUpdater": {
    "m_bUseAcceleration": 72,
    "m_flAnticipationDistance": 64,
    "m_flSpringConstant": 60,
    "m_hAnticipationHeadingParam": 70,
    "m_hAnticipationPosParam": 68,
    "m_sampleTimes": 32
  },
  "CPoseHandle": {
    "m_eType": 2,
    "m_nIndex": 0
  },
  "CProductQuantizer": {
    "m_nDimensions": 24,
    "m_subQuantizers": 0
  },
  "CQuaternionAnimParameter": {
    "m_bInterpolate": 112,
    "m_defaultValue": 96
  },
  "CRagdollAnimTag": {
    "m_bDestroy": 76,
    "m_flDampingRatio": 64,
    "m_flDecayBias": 72,
    "m_flDecayDuration": 68,
    "m_flFrequency": 60,
    "m_nPoseControl": 56
  },
  "CRagdollComponentUpdater": {
    "m_boneIndices": 72,
    "m_boneNames": 96,
    "m_flMaxStretch": 152,
    "m_flSpringFrequencyMax": 148,
    "m_flSpringFrequencyMin": 144,
    "m_ragdollNodePaths": 48,
    "m_weightLists": 120
  },
  "CRagdollUpdateNode": {
    "m_nWeightListIndex": 104,
    "m_poseControlMethod": 108
  },
  "CRenderBufferBinding": {
    "m_hBuffer": 0,
    "m_nBindOffsetBytes": 16
  },
  "CRenderMesh": {
    "m_constraints": 160,
    "m_sceneObjects": 16,
    "m_skeleton": 184
  },
  "CRenderSkeleton": {
    "m_boneParents": 48,
    "m_bones": 0,
    "m_nBoneWeightCount": 72
  },
  "CSceneObjectData": {
    "m_drawBounds": 48,
    "m_drawCalls": 24,
    "m_meshlets": 72,
    "m_vMaxBounds": 12,
    "m_vMinBounds": 0,
    "m_vTintColor": 96
  },
  "CSelectorUpdateNode": {
    "m_bResetOnChange": 164,
    "m_bSyncCyclesOnChange": 165,
    "m_blendCurve": 140,
    "m_children": 88,
    "m_eTagBehavior": 160,
    "m_flBlendTime": 148,
    "m_hParameter": 156,
    "m_tags": 112
  },
  "CSeqAutoLayer": {
    "m_end": 24,
    "m_flags": 4,
    "m_nLocalPose": 2,
    "m_nLocalReference": 0,
    "m_peak": 16,
    "m_start": 12,
    "m_tail": 20
  },
  "CSeqAutoLayerFlag": {
    "m_bFetchFrame": 6,
    "m_bLocal": 4,
    "m_bNoBlend": 3,
    "m_bPose": 5,
    "m_bPost": 0,
    "m_bSpline": 1,
    "m_bSubtract": 7,
    "m_bXFade": 2
  },
  "CSeqBoneMaskList": {
    "m_flBoneWeightArray": 40,
    "m_flDefaultMorphCtrlWeight": 64,
    "m_morphCtrlWeightArray": 72,
    "m_nLocalBoneArray": 16,
    "m_sName": 0
  },
  "CSeqCmdLayer": {
    "m_bSpline": 10,
    "m_cmd": 0,
    "m_flVar1": 12,
    "m_flVar2": 16,
    "m_nDstResult": 6,
    "m_nLineNumber": 20,
    "m_nLocalBonemask": 4,
    "m_nLocalReference": 2,
    "m_nSrcResult": 8
  },
  "CSeqCmdSeqDesc": {
    "m_activityArray": 96,
    "m_cmdLayerArray": 48,
    "m_eventArray": 72,
    "m_flFPS": 40,
    "m_flags": 16,
    "m_nFrameCount": 38,
    "m_nFrameRangeSequence": 36,
    "m_nSubCycles": 44,
    "m_numLocalResults": 46,
    "m_poseSettingArray": 120,
    "m_sName": 0,
    "m_transition": 28
  },
  "CSeqIKLock": {
    "m_bBonesOrientedAlongPositiveX": 10,
    "m_flAngleWeight": 4,
    "m_flPosWeight": 0,
    "m_nLocalBone": 8
  },
  "CSeqMultiFetch": {
    "m_bCalculatePoseParameters": 100,
    "m_flags": 0,
    "m_localReferenceArray": 8,
    "m_nGroupSize": 32,
    "m_nLocalCyclePoseParameter": 96,
    "m_nLocalPose": 40,
    "m_poseKeyArray0": 48,
    "m_poseKeyArray1": 72
  },
  "CSeqMultiFetchFlag": {
    "m_b0D": 2,
    "m_b1D": 3,
    "m_b2D": 4,
    "m_b2D_TRI": 5,
    "m_bCylepose": 1,
    "m_bRealtime": 0
  },
  "CSeqPoseParamDesc": {
    "m_bLooping": 28,
    "m_flEnd": 20,
    "m_flLoop": 24,
    "m_flStart": 16,
    "m_sName": 0
  },
  "CSeqPoseSetting": {
    "m_bX": 52,
    "m_bY": 53,
    "m_bZ": 54,
    "m_eType": 56,
    "m_flValue": 48,
    "m_sAttachment": 16,
    "m_sPoseParameter": 0,
    "m_sReferenceSequence": 32
  },
  "CSeqS1SeqDesc": {
    "m_IKLockArray": 168,
    "m_LegacyKeyValueText": 216,
    "m_SequenceKeys": 200,
    "m_activityArray": 232,
    "m_autoLayerArray": 144,
    "m_fetch": 32,
    "m_flags": 16,
    "m_footMotion": 256,
    "m_nLocalWeightlist": 136,
    "m_sName": 0,
    "m_transition": 192
  },
  "CSeqScaleSet": {
    "m_bRootOffset": 16,
    "m_flBoneScaleArray": 56,
    "m_nLocalBoneArray": 32,
    "m_sName": 0,
    "m_vRootOffset": 20
  },
  "CSeqSeqDescFlag": {
    "m_bAutoplay": 2,
    "m_bHidden": 4,
    "m_bLegacyCyclepose": 8,
    "m_bLegacyDelta": 6,
    "m_bLegacyRealtime": 9,
    "m_bLegacyWorldspace": 7,
    "m_bLooping": 0,
    "m_bModelDoc": 10,
    "m_bMulti": 5,
    "m_bPost": 3,
    "m_bSnap": 1
  },
  "CSeqSynthAnimDesc": {
    "m_activityArray": 40,
    "m_flags": 16,
    "m_nLocalBaseReference": 36,
    "m_nLocalBoneMask": 38,
    "m_sName": 0,
    "m_transition": 28
  },
  "CSeqTransition": {
    "m_flFadeInTime": 0,
    "m_flFadeOutTime": 4
  },
  "CSequenceFinishedAnimTag": {
    "m_sequenceName": 56
  },
  "CSequenceGroupData": {
    "m_keyValues": 272,
    "m_localBoneMaskArray": 160,
    "m_localBoneNameArray": 208,
    "m_localCmdSeqDescArray": 136,
    "m_localIKAutoplayLockArray": 288,
    "m_localMultiSeqDescArray": 88,
    "m_localNodeName": 232,
    "m_localPoseParamArray": 248,
    "m_localS1SeqDescArray": 64,
    "m_localScaleSetArray": 184,
    "m_localSequenceNameArray": 40,
    "m_localSynthAnimDescArray": 112,
    "m_nFlags": 32,
    "m_sName": 16
  },
  "CSequenceUpdateNode": {
    "m_bLoop": 160,
    "m_duration": 156,
    "m_hSequence": 148,
    "m_paramSpans": 96,
    "m_playbackSpeed": 152,
    "m_tags": 120
  },
  "CSetFacingUpdateNode": {
    "m_bResetChild": 108,
    "m_facingMode": 104
  },
  "CSetParameterActionUpdater": {
    "m_hParam": 24,
    "m_value": 26
  },
  "CSingleFrameUpdateNode": {
    "m_actions": 88,
    "m_flCycle": 120,
    "m_hPoseCacheHandle": 112,
    "m_hSequence": 116
  },
  "CSkeletalInputUpdateNode": {
    "m_fixedOpData": 88
  },
  "CSlopeComponentUpdater": {
    "m_flTraceDistance": 52,
    "m_hSlopeAngle": 56,
    "m_hSlopeAngleFront": 58,
    "m_hSlopeAngleSide": 60,
    "m_hSlopeHeading": 62,
    "m_hSlopeNormal": 64,
    "m_hSlopeNormal_WorldSpace": 66
  },
  "CSlowDownOnSlopesUpdateNode": {
    "m_flSlowDownStrength": 104
  },
  "CSolveIKChainUpdateNode": {
    "m_opFixedData": 128,
    "m_targetHandles": 104
  },
  "CSolveIKTargetHandle_t": {
    "m_orientationHandle": 2,
    "m_positionHandle": 0
  },
  "CSpeedScaleUpdateNode": {
    "m_paramIndex": 104
  },
  "CStanceOverrideUpdateNode": {
    "m_eMode": 148,
    "m_footStanceInfo": 104,
    "m_hParameter": 144,
    "m_pStanceSourceNode": 128
  },
  "CStanceScaleUpdateNode": {
    "m_hParam": 104
  },
  "CStateActionUpdater": {
    "m_eBehavior": 8,
    "m_pAction": 0
  },
  "CStateMachineComponentUpdater": {
    "m_stateMachine": 48
  },
  "CStateMachineUpdateNode": {
    "m_bBlockWaningTags": 244,
    "m_bLockStateWhenWaning": 245,
    "m_stateData": 192,
    "m_stateMachine": 104,
    "m_transitionData": 216
  },
  "CStateNodeStateData": {
    "m_bExclusiveRootMotion": 0,
    "m_pChild": 0
  },
  "CStateNodeTransitionData": {
    "m_bReset": 0,
    "m_blendDuration": 8,
    "m_curve": 0,
    "m_resetCycleOption": 0,
    "m_resetCycleValue": 16
  },
  "CStateUpdateData": {
    "m_actions": 40,
    "m_bIsEndState": 0,
    "m_bIsPassthrough": 0,
    "m_bIsStartState": 0,
    "m_hScript": 8,
    "m_name": 0,
    "m_stateID": 64,
    "m_transitionIndices": 16
  },
  "CStaticPoseCache": {
    "m_nBoneCount": 40,
    "m_nMorphCount": 44,
    "m_poses": 16
  },
  "CStepsRemainingMetricEvaluator": {
    "m_flMinStepsRemaining": 104,
    "m_footIndices": 80
  },
  "CStopAtGoalUpdateNode": {
    "m_damping": 128,
    "m_flInnerRadius": 112,
    "m_flMaxScale": 116,
    "m_flMinScale": 120,
    "m_flOuterRadius": 108
  },
  "CSubtractUpdateNode": {
    "m_bApplyChannelsSeparately": 145,
    "m_bApplyToFootMotion": 144,
    "m_bUseModelSpace": 146,
    "m_footMotionTiming": 140
  },
  "CTiltTwistConstraint": {
    "m_nSlaveAxis": 116,
    "m_nTargetAxis": 112
  },
  "CTimeRemainingMetricEvaluator": {
    "m_bFilterByTimeRemaining": 88,
    "m_bMatchByTimeRemaining": 80,
    "m_flMaxTimeRemaining": 84,
    "m_flMinTimeRemaining": 92
  },
  "CToggleComponentActionUpdater": {
    "m_bSetEnabled": 28,
    "m_componentID": 24
  },
  "CTransitionUpdateData": {
    "m_bDisabled": 0,
    "m_destStateIndex": 1,
    "m_srcStateIndex": 0
  },
  "CTurnHelperUpdateNode": {
    "m_bMatchChildDuration": 120,
    "m_bUseManualTurnOffset": 128,
    "m_facingTarget": 108,
    "m_manualTurnOffset": 124,
    "m_turnDuration": 116,
    "m_turnStartTimeOffset": 112
  },
  "CTwistConstraint": {
    "m_bInverse": 112,
    "m_qChildBindRotation": 144,
    "m_qParentBindRotation": 128
  },
  "CTwoBoneIKUpdateNode": {
    "m_opFixedData": 112
  },
  "CUnaryUpdateNode": {
    "m_pChildNode": 88
  },
  "CVPhysXSurfacePropertiesList": {
    "m_surfacePropertiesList": 0
  },
  "CVRInputComponentUpdater": {
    "m_FingerCurl_Index": 54,
    "m_FingerCurl_Middle": 56,
    "m_FingerCurl_Pinky": 60,
    "m_FingerCurl_Ring": 58,
    "m_FingerCurl_Thumb": 52,
    "m_FingerSplay_Index_Middle": 64,
    "m_FingerSplay_Middle_Ring": 66,
    "m_FingerSplay_Ring_Pinky": 68,
    "m_FingerSplay_Thumb_Index": 62
  },
  "CVectorAnimParameter": {
    "m_bInterpolate": 108,
    "m_defaultValue": 96
  },
  "CVectorQuantizer": {
    "m_centroidVectors": 0,
    "m_nCentroids": 24,
    "m_nDimensions": 28
  },
  "CVirtualAnimParameter": {
    "m_eParamType": 88,
    "m_expressionString": 80
  },
  "CVrSkeletalInputSettings": {
    "m_eHand": 72,
    "m_fingers": 24,
    "m_name": 48,
    "m_outerKnuckle1": 56,
    "m_outerKnuckle2": 64,
    "m_wristBones": 0
  },
  "CWayPointHelperUpdateNode": {
    "m_bOnlyGoals": 116,
    "m_bPreventOvershoot": 117,
    "m_bPreventUndershoot": 118,
    "m_flEndCycle": 112,
    "m_flStartCycle": 108
  },
  "CWristBone": {
    "m_name": 0,
    "m_vForwardLS": 8,
    "m_vOffset": 32,
    "m_vUpLS": 20
  },
  "ChainToSolveData_t": {
    "m_DebugSetting": 56,
    "m_SolverSettings": 4,
    "m_TargetSettings": 16,
    "m_flDebugNormalizedValue": 60,
    "m_nChainIndex": 0,
    "m_vDebugOffset": 64
  },
  "ConfigIndex": {
    "m_nConfig": 2,
    "m_nGroup": 0
  },
  "FingerBone_t": {
    "m_boneIndex": 0,
    "m_flMaxAngle": 44,
    "m_flMinAngle": 40,
    "m_flRadius": 48,
    "m_hingeAxis": 4,
    "m_vCapsulePos1": 16,
    "m_vCapsulePos2": 28
  },
  "FingerChain_t": {
    "m_bones": 24,
    "m_flFingerScaleRatio": 88,
    "m_flSplayMaxAngle": 84,
    "m_flSplayMinAngle": 80,
    "m_metacarpalBoneIndex": 76,
    "m_targets": 0,
    "m_tipParentBoneIndex": 72,
    "m_vSplayHingeAxis": 60,
    "m_vTipOffset": 48
  },
  "FingerSource_t": {
    "m_flFingerWeight": 4,
    "m_nFingerIndex": 0
  },
  "FollowAttachmentSettings_t": {
    "m_attachment": 0,
    "m_bMatchRotation": 133,
    "m_bMatchTranslation": 132,
    "m_boneIndex": 128
  },
  "FootFixedData_t": {
    "m_flMaxIKLength": 48,
    "m_flMaxRotationLeft": 60,
    "m_flMaxRotationRight": 64,
    "m_ikChainIndex": 44,
    "m_nAnkleBoneIndex": 36,
    "m_nFootIndex": 52,
    "m_nIKAnchorBoneIndex": 40,
    "m_nTagIndex": 56,
    "m_nTargetBoneIndex": 32,
    "m_vHeelOffset": 16,
    "m_vToeOffset": 0
  },
  "FootFixedSettings": {
    "m_bEnableTracing": 48,
    "m_flFootBaseLength": 32,
    "m_flMaxRotationLeft": 36,
    "m_flMaxRotationRight": 40,
    "m_flTraceAngleBlend": 52,
    "m_footstepLandedTagIndex": 44,
    "m_nDisableTagIndex": 56,
    "m_nFootIndex": 60,
    "m_traceSettings": 0,
    "m_vFootBaseBindPosePositionMS": 16
  },
  "FootLockPoseOpFixedSettings": {
    "m_bAlwaysUseFallbackHinge": 50,
    "m_bApplyFootRotationLimits": 51,
    "m_bApplyHipDrop": 49,
    "m_bApplyLegTwistLimits": 52,
    "m_bApplyTilt": 48,
    "m_bEnableLockBreaking": 68,
    "m_bEnableStretching": 80,
    "m_flExtensionScale": 60,
    "m_flLockBlendTime": 76,
    "m_flLockBreakTolerance": 72,
    "m_flMaxFootHeight": 56,
    "m_flMaxLegTwist": 64,
    "m_flMaxStretchAmount": 84,
    "m_flStretchExtensionScale": 88,
    "m_footInfo": 0,
    "m_hipDampingSettings": 24,
    "m_ikSolverType": 44,
    "m_nHipBoneIndex": 40
  },
  "FootPinningPoseOpFixedData_t": {
    "m_bApplyFootRotationLimits": 41,
    "m_bApplyLegTwistLimits": 40,
    "m_flBlendTime": 24,
    "m_flLockBreakDistance": 28,
    "m_flMaxLegTwist": 32,
    "m_footInfo": 0,
    "m_nHipBoneIndex": 36
  },
  "FootStepTrigger": {
    "m_nFootIndex": 24,
    "m_tags": 0,
    "m_triggerPhase": 28
  },
  "HSequence": {
    "m_Value": 0
  },
  "HitReactFixedSettings_t": {
    "m_flCounterRotationScale": 20,
    "m_flDistanceFadeScale": 24,
    "m_flHipBoneTranslationScale": 52,
    "m_flHipDipDelay": 64,
    "m_flHipDipImpactScale": 60,
    "m_flHipDipSpringStrength": 56,
    "m_flMaxAngleRadians": 44,
    "m_flMaxImpactForce": 8,
    "m_flMinImpactForce": 12,
    "m_flPropagationScale": 28,
    "m_flSpringStrength": 36,
    "m_flWhipDelay": 32,
    "m_flWhipImpactScale": 16,
    "m_flWhipSpringStrength": 40,
    "m_nEffectedBoneCount": 4,
    "m_nHipBoneIndex": 48,
    "m_nWeightListIndex": 0
  },
  "IKBoneNameAndIndex_t": {
    "m_Name": 0
  },
  "IKDemoCaptureSettings_t": {
    "m_eMode": 8,
    "m_ikChainName": 16,
    "m_oneBoneEnd": 32,
    "m_oneBoneStart": 24,
    "m_parentBoneName": 0
  },
  "IKSolverSettings_t": {
    "m_SolverType": 0,
    "m_nNumIterations": 4
  },
  "IKTargetSettings_t": {
    "m_AnimgraphParameterNameOrientation": 28,
    "m_AnimgraphParameterNamePosition": 24,
    "m_Bone": 8,
    "m_TargetCoordSystem": 32,
    "m_TargetSource": 0
  },
  "JiggleBoneSettingsList_t": {
    "m_boneSettings": 0
  },
  "JiggleBoneSettings_t": {
    "m_eSimSpace": 40,
    "m_flDamping": 12,
    "m_flMaxTimeStep": 8,
    "m_flSpringStrength": 4,
    "m_nBoneIndex": 0,
    "m_vBoundsMaxLS": 16,
    "m_vBoundsMinLS": 28
  },
  "LookAtBone_t": {
    "m_index": 0,
    "m_weight": 4
  },
  "LookAtOpFixedSettings_t": {
    "m_attachment": 0,
    "m_bMaintainUpDirection": 185,
    "m_bRotateYawForward": 184,
    "m_bTargetIsPosition": 186,
    "m_bUseHysteresis": 187,
    "m_bones": 144,
    "m_damping": 128,
    "m_flHysteresisInnerAngle": 176,
    "m_flHysteresisOuterAngle": 180,
    "m_flPitchLimit": 172,
    "m_flYawLimit": 168
  },
  "MaterialGroup_t": {
    "m_materials": 8,
    "m_name": 0
  },
  "ModelBoneFlexDriverControl_t": {
    "m_flMax": 24,
    "m_flMin": 20,
    "m_flexController": 8,
    "m_flexControllerToken": 16,
    "m_nBoneComponent": 0
  },
  "ModelBoneFlexDriver_t": {
    "m_boneName": 0,
    "m_boneNameToken": 8,
    "m_controls": 16
  },
  "ModelSkeletonData_t": {
    "m_boneName": 0,
    "m_bonePosParent": 96,
    "m_boneRotParent": 120,
    "m_boneScaleParent": 144,
    "m_boneSphere": 48,
    "m_nFlag": 72,
    "m_nParent": 24
  },
  "MoodAnimationLayer_t": {
    "m_bActiveListening": 8,
    "m_bActiveTalking": 9,
    "m_bScaleWithInts": 56,
    "m_flDurationScale": 48,
    "m_flEndOffset": 76,
    "m_flFadeIn": 84,
    "m_flFadeOut": 88,
    "m_flIntensity": 40,
    "m_flNextStart": 60,
    "m_flStartOffset": 68,
    "m_layerAnimations": 16,
    "m_sName": 0
  },
  "MoodAnimation_t": {
    "m_flWeight": 8,
    "m_sName": 0
  },
  "MotionBlendItem": {
    "m_flKeyValue": 8,
    "m_pChild": 0
  },
  "MotionDBIndex": {
    "m_nIndex": 0
  },
  "MotionIndex": {
    "m_nGroup": 0,
    "m_nMotion": 2
  },
  "ParamSpanSample_t": {
    "m_flCycle": 20,
    "m_value": 0
  },
  "ParamSpan_t": {
    "m_eParamType": 26,
    "m_flEndCycle": 32,
    "m_flStartCycle": 28,
    "m_hParam": 24,
    "m_samples": 0
  },
  "PermModelDataAnimatedMaterialAttribute_t": {
    "m_AttributeName": 0,
    "m_nNumChannels": 8
  },
  "PermModelData_t": {
    "m_AnimatedMaterialAttributes": 688,
    "m_BodyGroupsHiddenInTools": 640,
    "m_ExtParts": 96,
    "m_boneFlexDrivers": 608,
    "m_lodGroupSwitchDistances": 216,
    "m_materialGroups": 360,
    "m_meshGroups": 336,
    "m_modelInfo": 8,
    "m_modelSkeleton": 392,
    "m_nDefaultMeshGroupMask": 384,
    "m_name": 0,
    "m_pModelConfigList": 632,
    "m_refAnimGroups": 288,
    "m_refAnimIncludeModels": 664,
    "m_refLODGroupMasks": 192,
    "m_refMeshGroupMasks": 144,
    "m_refMeshes": 120,
    "m_refPhysGroupMasks": 168,
    "m_refPhysicsData": 240,
    "m_refPhysicsHitboxData": 264,
    "m_refSequenceGroups": 312,
    "m_remappingTable": 560,
    "m_remappingTableStarts": 584
  },
  "PermModelExtPart_t": {
    "m_Name": 32,
    "m_Transform": 0,
    "m_nParent": 40,
    "m_refModel": 48
  },
  "PermModelInfo_t": {
    "m_flMass": 52,
    "m_flMaxEyeDeflection": 68,
    "m_keyValueText": 80,
    "m_nFlags": 0,
    "m_sSurfaceProperty": 72,
    "m_vEyePosition": 56,
    "m_vHullMax": 16,
    "m_vHullMin": 4,
    "m_vViewMax": 40,
    "m_vViewMin": 28
  },
  "PhysSoftbodyDesc_t": {
    "m_Capsules": 72,
    "m_InitPose": 96,
    "m_ParticleBoneHash": 0,
    "m_ParticleBoneName": 120,
    "m_Particles": 24,
    "m_Springs": 48
  },
  "RenderSkeletonBone_t": {
    "m_bbox": 64,
    "m_boneName": 0,
    "m_flSphereRadius": 88,
    "m_invBindPose": 16,
    "m_parentName": 8
  },
  "SampleCode": {
    "m_subCode": 0
  },
  "ScriptInfo_t": {
    "m_code": 0,
    "m_eScriptType": 80,
    "m_paramsModified": 8,
    "m_proxyReadParams": 32,
    "m_proxyWriteParams": 56
  },
  "SkeletalInputOpFixedSettings_t": {
    "m_bEnableCollision": 69,
    "m_bEnableIK": 68,
    "m_eHand": 56,
    "m_eMotionRange": 60,
    "m_eTransformSource": 64,
    "m_fingers": 24,
    "m_outerKnuckle1": 48,
    "m_outerKnuckle2": 52,
    "m_wristBones": 0
  },
  "SkeletonBoneBounds_t": {
    "m_vecCenter": 0,
    "m_vecSize": 12
  },
  "SolveIKChainPoseOpFixedSettings_t": {
    "m_ChainsToSolveData": 0,
    "m_bMatchTargetOrientation": 24
  },
  "StanceInfo_t": {
    "m_flDirection": 12,
    "m_vPosition": 0
  },
  "TagSpan_t": {
    "m_endCycle": 8,
    "m_startCycle": 4,
    "m_tagIndex": 0
  },
  "TraceSettings_t": {
    "m_flTraceHeight": 0,
    "m_flTraceRadius": 4
  },
  "TwoBoneIKSettings_t": {
    "m_bAlwaysUseFallbackHinge": 296,
    "m_bConstrainTwist": 333,
    "m_bMatchTargetOrientation": 332,
    "m_endEffectorAttachment": 16,
    "m_endEffectorType": 0,
    "m_flMaxTwist": 336,
    "m_hPositionParam": 292,
    "m_hRotationParam": 294,
    "m_nEndBoneIndex": 328,
    "m_nFixedBoneIndex": 320,
    "m_nMiddleBoneIndex": 324,
    "m_targetAttachment": 160,
    "m_targetBoneIndex": 288,
    "m_targetType": 144,
    "m_vLsFallbackHingeAxis": 304
  },
  "VPhysXAggregateData_t": {
    "m_bindPose": 104,
    "m_boneNames": 32,
    "m_boneParents": 208,
    "m_bonesHash": 8,
    "m_collisionAttributes": 256,
    "m_constraints2": 152,
    "m_debugPartNames": 280,
    "m_embeddedKeyvalues": 304,
    "m_indexHash": 80,
    "m_indexNames": 56,
    "m_joints": 176,
    "m_nFlags": 0,
    "m_nRefCounter": 2,
    "m_pFeModel": 200,
    "m_parts": 128,
    "m_surfacePropertyHashes": 232
  },
  "VPhysXBodyPart_t": {
    "m_bOverrideMassCenter": 144,
    "m_flAngularDamping": 140,
    "m_flInertiaScale": 132,
    "m_flLinearDamping": 136,
    "m_flMass": 4,
    "m_nCollisionAttributeIndex": 128,
    "m_nFlags": 0,
    "m_nReserved": 130,
    "m_rnShape": 8,
    "m_vMassCenterOverride": 148
  },
  "VPhysXCollisionAttributes_t": {
    "m_CollisionGroup": 0,
    "m_CollisionGroupString": 80,
    "m_InteractAs": 8,
    "m_InteractAsStrings": 88,
    "m_InteractExclude": 56,
    "m_InteractExcludeStrings": 136,
    "m_InteractWith": 32,
    "m_InteractWithStrings": 112
  },
  "VPhysXConstraint2_t": {
    "m_nChild": 6,
    "m_nFlags": 0,
    "m_nParent": 4,
    "m_params": 8
  },
  "VPhysXConstraintParams_t": {
    "m_anchor": 4,
    "m_axes": 28,
    "m_driveDampingSlerp": 232,
    "m_driveDampingSwing": 228,
    "m_driveDampingTwist": 224,
    "m_driveDampingX": 200,
    "m_driveDampingY": 204,
    "m_driveDampingZ": 208,
    "m_driveSpringSlerp": 220,
    "m_driveSpringSwing": 216,
    "m_driveSpringTwist": 212,
    "m_driveSpringX": 188,
    "m_driveSpringY": 192,
    "m_driveSpringZ": 196,
    "m_goalAngularVelocity": 176,
    "m_goalOrientation": 160,
    "m_goalPosition": 148,
    "m_linearLimitDamping": 80,
    "m_linearLimitRestitution": 72,
    "m_linearLimitSpring": 76,
    "m_linearLimitValue": 68,
    "m_maxForce": 60,
    "m_maxTorque": 64,
    "m_nFlags": 3,
    "m_nRotateMotion": 2,
    "m_nTranslateMotion": 1,
    "m_nType": 0,
    "m_projectionAngularTolerance": 244,
    "m_projectionLinearTolerance": 240,
    "m_solverIterationCount": 236,
    "m_swing1LimitDamping": 128,
    "m_swing1LimitRestitution": 120,
    "m_swing1LimitSpring": 124,
    "m_swing1LimitValue": 116,
    "m_swing2LimitDamping": 144,
    "m_swing2LimitRestitution": 136,
    "m_swing2LimitSpring": 140,
    "m_swing2LimitValue": 132,
    "m_twistHighLimitDamping": 112,
    "m_twistHighLimitRestitution": 104,
    "m_twistHighLimitSpring": 108,
    "m_twistHighLimitValue": 100,
    "m_twistLowLimitDamping": 96,
    "m_twistLowLimitRestitution": 88,
    "m_twistLowLimitSpring": 92,
    "m_twistLowLimitValue": 84
  },
  "VPhysXJoint_t": {
    "m_Frame1": 16,
    "m_Frame2": 48,
    "m_LinearLimit": 84,
    "m_SwingLimit": 116,
    "m_TwistLimit": 128,
    "m_bEnableAngularMotor": 136,
    "m_bEnableCollision": 80,
    "m_bEnableLinearLimit": 81,
    "m_bEnableLinearMotor": 92,
    "m_bEnableSwingLimit": 112,
    "m_bEnableTwistLimit": 124,
    "m_flAngularDampingRatio": 168,
    "m_flAngularFrequency": 164,
    "m_flFriction": 172,
    "m_flLinearDampingRatio": 160,
    "m_flLinearFrequency": 156,
    "m_flMaxForce": 108,
    "m_flMaxTorque": 152,
    "m_nBody1": 2,
    "m_nBody2": 4,
    "m_nFlags": 6,
    "m_nType": 0,
    "m_vAngularTargetVelocity": 140,
    "m_vLinearTargetVelocity": 96
  },
  "VPhysXRange_t": {
    "m_flMax": 4,
    "m_flMin": 0
  },
  "VPhysics2ShapeDef_t": {
    "m_CollisionAttributeIndices": 96,
    "m_capsules": 24,
    "m_hulls": 48,
    "m_meshes": 72,
    "m_spheres": 0
  },
  "WeightList": {
    "m_name": 0,
    "m_weights": 8
  },
  "WristBone_t": {
    "m_boneIndex": 32,
    "m_xOffsetTransformMS": 0
  }
}
```

`SDK/animationsystem.dll.py`:

```py
'''
https://github.com/a2x/cs2-dumper
2023-11-23 10:28:25.369946400 UTC
'''

class AimMatrixOpFixedSettings_t:
    m_attachment = 0x0 # CAnimAttachment
    m_damping = 0x80 # CAnimInputDamping
    m_poseCacheHandles = 0x90 # CPoseHandle[10]
    m_eBlendMode = 0xB8 # AimMatrixBlendMode
    m_fAngleIncrement = 0xBC # float
    m_nSequenceMaxFrame = 0xC0 # int32_t
    m_nBoneMaskIndex = 0xC4 # int32_t
    m_bTargetIsPosition = 0xC8 # bool

class AnimComponentID:
    m_id = 0x0 # uint32_t

class AnimNodeID:
    m_id = 0x0 # uint32_t

class AnimNodeOutputID:
    m_id = 0x0 # uint32_t

class AnimParamID:
    m_id = 0x0 # uint32_t

class AnimScriptHandle:
    m_id = 0x0 # uint32_t

class AnimStateID:
    m_id = 0x0 # uint32_t

class AnimTagID:
    m_id = 0x0 # uint32_t

class AnimationDecodeDebugDumpElement_t:
    m_nEntityIndex = 0x0 # int32_t
    m_modelName = 0x8 # CUtlString
    m_poseParams = 0x10 # CUtlVector<CUtlString>
    m_decodeOps = 0x28 # CUtlVector<CUtlString>
    m_internalOps = 0x40 # CUtlVector<CUtlString>
    m_decodedAnims = 0x58 # CUtlVector<CUtlString>

class AnimationDecodeDebugDump_t:
    m_processingType = 0x0 # AnimationProcessingType_t
    m_elems = 0x8 # CUtlVector<AnimationDecodeDebugDumpElement_t>

class AnimationSnapshotBase_t:
    m_flRealTime = 0x0 # float
    m_rootToWorld = 0x10 # matrix3x4a_t
    m_bBonesInWorldSpace = 0x40 # bool
    m_boneSetupMask = 0x48 # CUtlVector<uint32_t>
    m_boneTransforms = 0x60 # CUtlVector<matrix3x4a_t>
    m_flexControllers = 0x78 # CUtlVector<float>
    m_SnapshotType = 0x90 # AnimationSnapshotType_t
    m_bHasDecodeDump = 0x94 # bool
    m_DecodeDump = 0x98 # AnimationDecodeDebugDumpElement_t

class AnimationSnapshot_t:
    m_nEntIndex = 0x110 # int32_t
    m_modelName = 0x118 # CUtlString

class AttachmentHandle_t:
    m_Value = 0x0 # uint8_t

class BlendItem_t:
    m_tags = 0x0 # CUtlVector<TagSpan_t>
    m_pChild = 0x18 # CAnimUpdateNodeRef
    m_hSequence = 0x28 # HSequence
    m_vPos = 0x2C # Vector2D
    m_flDuration = 0x34 # float
    m_bUseCustomDuration = 0x38 # bool

class BoneDemoCaptureSettings_t:
    m_boneName = 0x0 # CUtlString
    m_flChainLength = 0x8 # float

class CActionComponentUpdater:
    m_actions = 0x30 # CUtlVector<CSmartPtr<CAnimActionUpdater>>

class CAddUpdateNode:
    m_footMotionTiming = 0x8C # BinaryNodeChildOption
    m_bApplyToFootMotion = 0x90 # bool
    m_bApplyChannelsSeparately = 0x91 # bool
    m_bUseModelSpace = 0x92 # bool

class CAimConstraint:
    m_qAimOffset = 0x70 # Quaternion
    m_nUpType = 0x80 # uint32_t

class CAimMatrixUpdateNode:
    m_opFixedSettings = 0x70 # AimMatrixOpFixedSettings_t
    m_target = 0x148 # AnimVectorSource
    m_paramIndex = 0x14C # CAnimParamHandle
    m_hSequence = 0x150 # HSequence
    m_bResetChild = 0x154 # bool
    m_bLockWhenWaning = 0x155 # bool

class CAnimActivity:
    m_name = 0x0 # CBufferString
    m_nActivity = 0x10 # int32_t
    m_nFlags = 0x14 # int32_t
    m_nWeight = 0x18 # int32_t

class CAnimAttachment:
    m_influenceRotations = 0x0 # Quaternion[3]
    m_influenceOffsets = 0x30 # VectorAligned[3]
    m_influenceIndices = 0x60 # int32_t[3]
    m_influenceWeights = 0x6C # float[3]
    m_numInfluences = 0x78 # uint8_t

class CAnimBone:
    m_name = 0x0 # CBufferString
    m_parent = 0x10 # int32_t
    m_pos = 0x14 # Vector
    m_quat = 0x20 # QuaternionStorage
    m_scale = 0x30 # float
    m_qAlignment = 0x34 # QuaternionStorage
    m_flags = 0x44 # int32_t

class CAnimBoneDifference:
    m_name = 0x0 # CBufferString
    m_parent = 0x10 # CBufferString
    m_posError = 0x20 # Vector
    m_bHasRotation = 0x2C # bool
    m_bHasMovement = 0x2D # bool

class CAnimComponentUpdater:
    m_name = 0x18 # CUtlString
    m_id = 0x20 # AnimComponentID
    m_networkMode = 0x24 # AnimNodeNetworkMode
    m_bStartEnabled = 0x28 # bool

class CAnimData:
    m_name = 0x10 # CBufferString
    m_animArray = 0x20 # CUtlVector<CAnimDesc>
    m_decoderArray = 0x38 # CUtlVector<CAnimDecoder>
    m_nMaxUniqueFrameIndex = 0x50 # int32_t
    m_segmentArray = 0x58 # CUtlVector<CAnimFrameSegment>

class CAnimDataChannelDesc:
    m_szChannelClass = 0x0 # CBufferString
    m_szVariableName = 0x10 # CBufferString
    m_nFlags = 0x20 # int32_t
    m_nType = 0x24 # int32_t
    m_szGrouping = 0x28 # CBufferString
    m_szDescription = 0x38 # CBufferString
    m_szElementNameArray = 0x48 # CUtlVector<CBufferString>
    m_nElementIndexArray = 0x60 # CUtlVector<int32_t>
    m_nElementMaskArray = 0x78 # CUtlVector<uint32_t>

class CAnimDecoder:
    m_szName = 0x0 # CBufferString
    m_nVersion = 0x10 # int32_t
    m_nType = 0x14 # int32_t

class CAnimDemoCaptureSettings:
    m_rangeBoneChainLength = 0x0 # Vector2D
    m_rangeMaxSplineErrorRotation = 0x8 # Vector2D
    m_flMaxSplineErrorTranslation = 0x10 # float
    m_flMaxSplineErrorScale = 0x14 # float
    m_flIkRotation_MaxSplineError = 0x18 # float
    m_flIkTranslation_MaxSplineError = 0x1C # float
    m_flMaxQuantizationErrorRotation = 0x20 # float
    m_flMaxQuantizationErrorTranslation = 0x24 # float
    m_flMaxQuantizationErrorScale = 0x28 # float
    m_flIkRotation_MaxQuantizationError = 0x2C # float
    m_flIkTranslation_MaxQuantizationError = 0x30 # float
    m_baseSequence = 0x38 # CUtlString
    m_nBaseSequenceFrame = 0x40 # int32_t
    m_boneSelectionMode = 0x44 # EDemoBoneSelectionMode
    m_bones = 0x48 # CUtlVector<BoneDemoCaptureSettings_t>
    m_ikChains = 0x60 # CUtlVector<IKDemoCaptureSettings_t>

class CAnimDesc:
    m_name = 0x0 # CBufferString
    m_flags = 0x10 # CAnimDesc_Flag
    fps = 0x18 # float
    m_Data = 0x20 # CAnimEncodedFrames
    m_movementArray = 0xF8 # CUtlVector<CAnimMovement>
    m_eventArray = 0x110 # CUtlVector<CAnimEventDefinition>
    m_activityArray = 0x128 # CUtlVector<CAnimActivity>
    m_hierarchyArray = 0x140 # CUtlVector<CAnimLocalHierarchy>
    framestalltime = 0x158 # float
    m_vecRootMin = 0x15C # Vector
    m_vecRootMax = 0x168 # Vector
    m_vecBoneWorldMin = 0x178 # CUtlVector<Vector>
    m_vecBoneWorldMax = 0x190 # CUtlVector<Vector>
    m_sequenceParams = 0x1A8 # CAnimSequenceParams

class CAnimDesc_Flag:
    m_bLooping = 0x0 # bool
    m_bAllZeros = 0x1 # bool
    m_bHidden = 0x2 # bool
    m_bDelta = 0x3 # bool
    m_bLegacyWorldspace = 0x4 # bool
    m_bModelDoc = 0x5 # bool
    m_bImplicitSeqIgnoreDelta = 0x6 # bool
    m_bAnimGraphAdditive = 0x7 # bool

class CAnimEncodeDifference:
    m_boneArray = 0x0 # CUtlVector<CAnimBoneDifference>
    m_morphArray = 0x18 # CUtlVector<CAnimMorphDifference>
    m_userArray = 0x30 # CUtlVector<CAnimUserDifference>
    m_bHasRotationBitArray = 0x48 # CUtlVector<uint8_t>
    m_bHasMovementBitArray = 0x60 # CUtlVector<uint8_t>
    m_bHasMorphBitArray = 0x78 # CUtlVector<uint8_t>
    m_bHasUserBitArray = 0x90 # CUtlVector<uint8_t>

class CAnimEncodedFrames:
    m_fileName = 0x0 # CBufferString
    m_nFrames = 0x10 # int32_t
    m_nFramesPerBlock = 0x14 # int32_t
    m_frameblockArray = 0x18 # CUtlVector<CAnimFrameBlockAnim>
    m_usageDifferences = 0x30 # CAnimEncodeDifference

class CAnimEnum:
    m_value = 0x0 # uint8_t

class CAnimEventDefinition:
    m_nFrame = 0x8 # int32_t
    m_flCycle = 0xC # float
    m_EventData = 0x10 # KeyValues3
    m_sLegacyOptions = 0x20 # CBufferString
    m_sEventName = 0x30 # CGlobalSymbol

class CAnimFoot:
    m_name = 0x0 # CUtlString
    m_vBallOffset = 0x8 # Vector
    m_vHeelOffset = 0x14 # Vector
    m_ankleBoneIndex = 0x20 # int32_t
    m_toeBoneIndex = 0x24 # int32_t

class CAnimFrameBlockAnim:
    m_nStartFrame = 0x0 # int32_t
    m_nEndFrame = 0x4 # int32_t
    m_segmentIndexArray = 0x8 # CUtlVector<int32_t>

class CAnimFrameSegment:
    m_nUniqueFrameIndex = 0x0 # int32_t
    m_nLocalElementMasks = 0x4 # uint32_t
    m_nLocalChannel = 0x8 # int32_t
    m_container = 0x10 # CUtlBinaryBlock

class CAnimGraphDebugReplay:
    m_animGraphFileName = 0x40 # CUtlString
    m_frameList = 0x48 # CUtlVector<CSmartPtr<CAnimReplayFrame>>
    m_startIndex = 0x60 # int32_t
    m_writeIndex = 0x64 # int32_t
    m_frameCount = 0x68 # int32_t

class CAnimGraphModelBinding:
    m_modelName = 0x8 # CUtlString
    m_pSharedData = 0x10 # CSmartPtr<CAnimUpdateSharedData>

class CAnimGraphNetworkSettings:
    m_bNetworkingEnabled = 0x20 # bool

class CAnimGraphSettingsManager:
    m_settingsGroups = 0x18 # CUtlVector<CSmartPtr<CAnimGraphSettingsGroup>>

class CAnimInputDamping:
    m_speedFunction = 0x8 # DampingSpeedFunction
    m_fSpeedScale = 0xC # float

class CAnimKeyData:
    m_name = 0x0 # CBufferString
    m_boneArray = 0x10 # CUtlVector<CAnimBone>
    m_userArray = 0x28 # CUtlVector<CAnimUser>
    m_morphArray = 0x40 # CUtlVector<CBufferString>
    m_nChannelElements = 0x58 # int32_t
    m_dataChannelArray = 0x60 # CUtlVector<CAnimDataChannelDesc>

class CAnimLocalHierarchy:
    m_sBone = 0x0 # CBufferString
    m_sNewParent = 0x10 # CBufferString
    m_nStartFrame = 0x20 # int32_t
    m_nPeakFrame = 0x24 # int32_t
    m_nTailFrame = 0x28 # int32_t
    m_nEndFrame = 0x2C # int32_t

class CAnimMorphDifference:
    m_name = 0x0 # CBufferString

class CAnimMotorUpdaterBase:
    m_name = 0x10 # CUtlString
    m_bDefault = 0x18 # bool

class CAnimMovement:
    endframe = 0x0 # int32_t
    motionflags = 0x4 # int32_t
    v0 = 0x8 # float
    v1 = 0xC # float
    angle = 0x10 # float
    vector = 0x14 # Vector
    position = 0x20 # Vector

class CAnimNodePath:
    m_path = 0x0 # AnimNodeID[11]
    m_nCount = 0x2C # int32_t

class CAnimParamHandle:
    m_type = 0x0 # AnimParamType_t
    m_index = 0x1 # uint8_t

class CAnimParamHandleMap:
    m_list = 0x0 # CUtlHashtable<uint16_t,int16_t>

class CAnimParameterBase:
    m_name = 0x18 # CGlobalSymbol
    m_group = 0x20 # CUtlString
    m_id = 0x28 # AnimParamID
    m_componentName = 0x40 # CUtlString
    m_bNetworkingRequested = 0x4C # bool
    m_bIsReferenced = 0x4D # bool

class CAnimParameterManagerUpdater:
    m_parameters = 0x18 # CUtlVector<CSmartPtr<CAnimParameterBase>>
    m_idToIndexMap = 0x30 # CUtlHashtable<AnimParamID,int32_t>
    m_nameToIndexMap = 0x50 # CUtlHashtable<CUtlString,int32_t>
    m_indexToHandle = 0x70 # CUtlVector<CAnimParamHandle>
    m_autoResetParams = 0x88 # CUtlVector<CUtlPair<CAnimParamHandle,CAnimVariant>>
    m_autoResetMap = 0xA0 # CUtlHashtable<CAnimParamHandle,int16_t>

class CAnimReplayFrame:
    m_inputDataBlocks = 0x10 # CUtlVector<CUtlBinaryBlock>
    m_instanceData = 0x28 # CUtlBinaryBlock
    m_startingLocalToWorldTransform = 0x40 # CTransform
    m_localToWorldTransform = 0x60 # CTransform
    m_timeStamp = 0x80 # float

class CAnimScriptComponentUpdater:
    m_hScript = 0x30 # AnimScriptHandle

class CAnimScriptManager:
    m_scriptInfo = 0x10 # CUtlVector<ScriptInfo_t>

class CAnimSequenceParams:
    m_flFadeInTime = 0x0 # float
    m_flFadeOutTime = 0x4 # float

class CAnimSkeleton:
    m_localSpaceTransforms = 0x10 # CUtlVector<CTransform>
    m_modelSpaceTransforms = 0x28 # CUtlVector<CTransform>
    m_boneNames = 0x40 # CUtlVector<CUtlString>
    m_children = 0x58 # CUtlVector<CUtlVector<int32_t>>
    m_parents = 0x70 # CUtlVector<int32_t>
    m_feet = 0x88 # CUtlVector<CAnimFoot>
    m_morphNames = 0xA0 # CUtlVector<CUtlString>
    m_lodBoneCounts = 0xB8 # CUtlVector<int32_t>

class CAnimStateMachineUpdater:
    m_states = 0x8 # CUtlVector<CStateUpdateData>
    m_transitions = 0x20 # CUtlVector<CTransitionUpdateData>
    m_startStateIndex = 0x50 # int32_t

class CAnimTagBase:
    m_name = 0x18 # CGlobalSymbol
    m_group = 0x20 # CGlobalSymbol
    m_tagID = 0x28 # AnimTagID
    m_bIsReferenced = 0x2C # bool

class CAnimTagManagerUpdater:
    m_tags = 0x18 # CUtlVector<CSmartPtr<CAnimTagBase>>

class CAnimUpdateNodeBase:
    m_nodePath = 0x18 # CAnimNodePath
    m_networkMode = 0x48 # AnimNodeNetworkMode
    m_name = 0x50 # CUtlString

class CAnimUpdateNodeRef:
    m_nodeIndex = 0x8 # int32_t

class CAnimUpdateSharedData:
    m_nodes = 0x10 # CUtlVector<CSmartPtr<CAnimUpdateNodeBase>>
    m_nodeIndexMap = 0x28 # CUtlHashtable<CAnimNodePath,int32_t>
    m_components = 0x48 # CUtlVector<CSmartPtr<CAnimComponentUpdater>>
    m_pParamListUpdater = 0x60 # CSmartPtr<CAnimParameterManagerUpdater>
    m_pTagManagerUpdater = 0x68 # CSmartPtr<CAnimTagManagerUpdater>
    m_scriptManager = 0x70 # CSmartPtr<CAnimScriptManager>
    m_settings = 0x78 # CAnimGraphSettingsManager
    m_pStaticPoseCache = 0xA8 # CSmartPtr<CStaticPoseCacheBuilder>
    m_pSkeleton = 0xB0 # CSmartPtr<CAnimSkeleton>
    m_rootNodePath = 0xB8 # CAnimNodePath

class CAnimUser:
    m_name = 0x0 # CBufferString
    m_nType = 0x10 # int32_t

class CAnimUserDifference:
    m_name = 0x0 # CBufferString
    m_nType = 0x10 # int32_t

class CAnimationGraphVisualizerAxis:
    m_xWsTransform = 0x40 # CTransform
    m_flAxisSize = 0x60 # float

class CAnimationGraphVisualizerLine:
    m_vWsPositionStart = 0x40 # VectorAligned
    m_vWsPositionEnd = 0x50 # VectorAligned
    m_Color = 0x60 # Color

class CAnimationGraphVisualizerPie:
    m_vWsCenter = 0x40 # VectorAligned
    m_vWsStart = 0x50 # VectorAligned
    m_vWsEnd = 0x60 # VectorAligned
    m_Color = 0x70 # Color

class CAnimationGraphVisualizerPrimitiveBase:
    m_Type = 0x8 # CAnimationGraphVisualizerPrimitiveType
    m_OwningAnimNodePaths = 0xC # AnimNodeID[11]
    m_nOwningAnimNodePathCount = 0x38 # int32_t

class CAnimationGraphVisualizerSphere:
    m_vWsPosition = 0x40 # VectorAligned
    m_flRadius = 0x50 # float
    m_Color = 0x54 # Color

class CAnimationGraphVisualizerText:
    m_vWsPosition = 0x40 # VectorAligned
    m_Color = 0x50 # Color
    m_Text = 0x58 # CUtlString

class CAnimationGroup:
    m_nFlags = 0x10 # uint32_t
    m_name = 0x18 # CBufferString
    m_localHAnimArray_Handle = 0x60 # CUtlVector<CStrongHandle<InfoForResourceTypeCAnimData>>
    m_includedGroupArray_Handle = 0x78 # CUtlVector<CStrongHandle<InfoForResourceTypeCAnimationGroup>>
    m_directHSeqGroup_Handle = 0x90 # CStrongHandle<InfoForResourceTypeCSequenceGroupData>
    m_decodeKey = 0x98 # CAnimKeyData
    m_szScripts = 0x110 # CUtlVector<CBufferString>

class CAttachment:
    m_name = 0x0 # CUtlString
    m_influenceNames = 0x8 # CUtlString[3]
    m_vInfluenceRotations = 0x20 # Quaternion[3]
    m_vInfluenceOffsets = 0x50 # Vector[3]
    m_influenceWeights = 0x74 # float[3]
    m_bInfluenceRootTransform = 0x80 # bool[3]
    m_nInfluences = 0x83 # uint8_t
    m_bIgnoreRotation = 0x84 # bool

class CAudioAnimTag:
    m_clipName = 0x38 # CUtlString
    m_attachmentName = 0x40 # CUtlString
    m_flVolume = 0x48 # float
    m_bStopWhenTagEnds = 0x4C # bool
    m_bStopWhenGraphEnds = 0x4D # bool
    m_bPlayOnServer = 0x4E # bool
    m_bPlayOnClient = 0x4F # bool

class CBaseConstraint:
    m_name = 0x28 # CUtlString
    m_vUpVector = 0x30 # Vector
    m_slaves = 0x40 # CUtlVector<CConstraintSlave>
    m_targets = 0x58 # CUtlVector<CConstraintTarget>

class CBinaryUpdateNode:
    m_pChild1 = 0x58 # CAnimUpdateNodeRef
    m_pChild2 = 0x68 # CAnimUpdateNodeRef
    m_timingBehavior = 0x78 # BinaryNodeTiming
    m_flTimingBlend = 0x7C # float
    m_bResetChild1 = 0x80 # bool
    m_bResetChild2 = 0x81 # bool

class CBlend2DUpdateNode:
    m_items = 0x60 # CUtlVector<BlendItem_t>
    m_tags = 0x78 # CUtlVector<TagSpan_t>
    m_paramSpans = 0x90 # CParamSpanUpdater
    m_nodeItemIndices = 0xA8 # CUtlVector<int32_t>
    m_damping = 0xC0 # CAnimInputDamping
    m_blendSourceX = 0xD0 # AnimValueSource
    m_paramX = 0xD4 # CAnimParamHandle
    m_blendSourceY = 0xD8 # AnimValueSource
    m_paramY = 0xDC # CAnimParamHandle
    m_eBlendMode = 0xE0 # Blend2DMode
    m_playbackSpeed = 0xE4 # float
    m_bLoop = 0xE8 # bool
    m_bLockBlendOnReset = 0xE9 # bool
    m_bLockWhenWaning = 0xEA # bool
    m_bAnimEventsAndTagsOnMostWeightedOnly = 0xEB # bool

class CBlendCurve:
    m_flControlPoint1 = 0x0 # float
    m_flControlPoint2 = 0x4 # float

class CBlendUpdateNode:
    m_children = 0x60 # CUtlVector<CAnimUpdateNodeRef>
    m_sortedOrder = 0x78 # CUtlVector<uint8_t>
    m_targetValues = 0x90 # CUtlVector<float>
    m_blendValueSource = 0xAC # AnimValueSource
    m_paramIndex = 0xB0 # CAnimParamHandle
    m_damping = 0xB8 # CAnimInputDamping
    m_blendKeyType = 0xC8 # BlendKeyType
    m_bLockBlendOnReset = 0xCC # bool
    m_bSyncCycles = 0xCD # bool
    m_bLoop = 0xCE # bool
    m_bLockWhenWaning = 0xCF # bool

class CBodyGroupAnimTag:
    m_nPriority = 0x38 # int32_t
    m_bodyGroupSettings = 0x40 # CUtlVector<CBodyGroupSetting>

class CBodyGroupSetting:
    m_BodyGroupName = 0x0 # CUtlString
    m_nBodyGroupOption = 0x8 # int32_t

class CBoneConstraintDotToMorph:
    m_sBoneName = 0x28 # CUtlString
    m_sTargetBoneName = 0x30 # CUtlString
    m_sMorphChannelName = 0x38 # CUtlString
    m_flRemap = 0x40 # float[4]

class CBoneConstraintPoseSpaceBone:
    m_inputList = 0x70 # CUtlVector<CBoneConstraintPoseSpaceBone::Input_t>

class CBoneConstraintPoseSpaceBone_Input_t:
    m_inputValue = 0x0 # Vector
    m_outputTransformList = 0x10 # CUtlVector<CTransform>

class CBoneConstraintPoseSpaceMorph:
    m_sBoneName = 0x28 # CUtlString
    m_sAttachmentName = 0x30 # CUtlString
    m_outputMorph = 0x38 # CUtlVector<CUtlString>
    m_inputList = 0x50 # CUtlVector<CBoneConstraintPoseSpaceMorph::Input_t>
    m_bClamp = 0x68 # bool

class CBoneConstraintPoseSpaceMorph_Input_t:
    m_inputValue = 0x0 # Vector
    m_outputWeightList = 0x10 # CUtlVector<float>

class CBoneMaskUpdateNode:
    m_nWeightListIndex = 0x8C # int32_t
    m_flRootMotionBlend = 0x90 # float
    m_blendSpace = 0x94 # BoneMaskBlendSpace
    m_footMotionTiming = 0x98 # BinaryNodeChildOption
    m_bUseBlendScale = 0x9C # bool
    m_blendValueSource = 0xA0 # AnimValueSource
    m_hBlendParameter = 0xA4 # CAnimParamHandle

class CBonePositionMetricEvaluator:
    m_nBoneIndex = 0x50 # int32_t

class CBoneVelocityMetricEvaluator:
    m_nBoneIndex = 0x50 # int32_t

class CBoolAnimParameter:
    m_bDefaultValue = 0x60 # bool

class CCPPScriptComponentUpdater:
    m_scriptsToRun = 0x30 # CUtlVector<CGlobalSymbol>

class CCachedPose:
    m_transforms = 0x8 # CUtlVector<CTransform>
    m_morphWeights = 0x20 # CUtlVector<float>
    m_hSequence = 0x38 # HSequence
    m_flCycle = 0x3C # float

class CChoiceUpdateNode:
    m_children = 0x58 # CUtlVector<CAnimUpdateNodeRef>
    m_weights = 0x70 # CUtlVector<float>
    m_blendTimes = 0x88 # CUtlVector<float>
    m_choiceMethod = 0xA0 # ChoiceMethod
    m_choiceChangeMethod = 0xA4 # ChoiceChangeMethod
    m_blendMethod = 0xA8 # ChoiceBlendMethod
    m_blendTime = 0xAC # float
    m_bCrossFade = 0xB0 # bool
    m_bResetChosen = 0xB1 # bool
    m_bDontResetSameSelection = 0xB2 # bool

class CClothSettingsAnimTag:
    m_flStiffness = 0x38 # float
    m_flEaseIn = 0x3C # float
    m_flEaseOut = 0x40 # float
    m_nVertexSet = 0x48 # CUtlString

class CCompressorGroup:
    m_nTotalElementCount = 0x0 # int32_t
    m_szChannelClass = 0x8 # CUtlVector<char*>
    m_szVariableName = 0x20 # CUtlVector<char*>
    m_nType = 0x38 # CUtlVector<fieldtype_t>
    m_nFlags = 0x50 # CUtlVector<int32_t>
    m_szGrouping = 0x68 # CUtlVector<CUtlString>
    m_nCompressorIndex = 0x80 # CUtlVector<int32_t>
    m_szElementNames = 0x98 # CUtlVector<CUtlVector<char*>>
    m_nElementUniqueID = 0xB0 # CUtlVector<CUtlVector<int32_t>>
    m_nElementMask = 0xC8 # CUtlVector<uint32_t>
    m_vectorCompressor = 0xF8 # CUtlVector<CCompressor<Vector>*>
    m_quaternionCompressor = 0x110 # CUtlVector<CCompressor<QuaternionStorage>*>
    m_intCompressor = 0x128 # CUtlVector<CCompressor<int32_t>*>
    m_boolCompressor = 0x140 # CUtlVector<CCompressor<bool>*>
    m_colorCompressor = 0x158 # CUtlVector<CCompressor<Color>*>
    m_vector2DCompressor = 0x170 # CUtlVector<CCompressor<Vector2D>*>
    m_vector4DCompressor = 0x188 # CUtlVector<CCompressor<Vector4D>*>

class CConcreteAnimParameter:
    m_previewButton = 0x50 # AnimParamButton_t
    m_eNetworkSetting = 0x54 # AnimParamNetworkSetting
    m_bUseMostRecentValue = 0x58 # bool
    m_bAutoReset = 0x59 # bool
    m_bGameWritable = 0x5A # bool
    m_bGraphWritable = 0x5B # bool

class CConstraintSlave:
    m_qBaseOrientation = 0x0 # Quaternion
    m_vBasePosition = 0x10 # Vector
    m_nBoneHash = 0x1C # uint32_t
    m_flWeight = 0x20 # float
    m_sName = 0x28 # CUtlString

class CConstraintTarget:
    m_qOffset = 0x20 # Quaternion
    m_vOffset = 0x30 # Vector
    m_nBoneHash = 0x3C # uint32_t
    m_sName = 0x40 # CUtlString
    m_flWeight = 0x48 # float
    m_bIsAttachment = 0x59 # bool

class CCycleBase:
    m_flCycle = 0x0 # float

class CCycleControlClipUpdateNode:
    m_tags = 0x60 # CUtlVector<TagSpan_t>
    m_hSequence = 0x7C # HSequence
    m_duration = 0x80 # float
    m_valueSource = 0x84 # AnimValueSource
    m_paramIndex = 0x88 # CAnimParamHandle

class CCycleControlUpdateNode:
    m_valueSource = 0x68 # AnimValueSource
    m_paramIndex = 0x6C # CAnimParamHandle

class CDampedPathAnimMotorUpdater:
    m_flAnticipationTime = 0x2C # float
    m_flMinSpeedScale = 0x30 # float
    m_hAnticipationPosParam = 0x34 # CAnimParamHandle
    m_hAnticipationHeadingParam = 0x36 # CAnimParamHandle
    m_flSpringConstant = 0x38 # float
    m_flMinSpringTension = 0x3C # float
    m_flMaxSpringTension = 0x40 # float

class CDampedValueComponentUpdater:
    m_items = 0x30 # CUtlVector<CDampedValueUpdateItem>

class CDampedValueUpdateItem:
    m_damping = 0x0 # CAnimInputDamping
    m_hParamIn = 0x18 # CAnimParamHandle
    m_hParamOut = 0x1A # CAnimParamHandle

class CDemoSettingsComponentUpdater:
    m_settings = 0x30 # CAnimDemoCaptureSettings

class CDirectPlaybackTagData:
    m_sequenceName = 0x0 # CUtlString
    m_tags = 0x8 # CUtlVector<TagSpan_t>

class CDirectPlaybackUpdateNode:
    m_bFinishEarly = 0x6C # bool
    m_bResetOnFinish = 0x6D # bool
    m_allTags = 0x70 # CUtlVector<CDirectPlaybackTagData>

class CDirectionalBlendUpdateNode:
    m_hSequences = 0x5C # HSequence[8]
    m_damping = 0x80 # CAnimInputDamping
    m_blendValueSource = 0x90 # AnimValueSource
    m_paramIndex = 0x94 # CAnimParamHandle
    m_playbackSpeed = 0x98 # float
    m_duration = 0x9C # float
    m_bLoop = 0xA0 # bool
    m_bLockBlendOnReset = 0xA1 # bool

class CDistanceRemainingMetricEvaluator:
    m_flMaxDistance = 0x50 # float
    m_flMinDistance = 0x54 # float
    m_flStartGoalFilterDistance = 0x58 # float
    m_flMaxGoalOvershootScale = 0x5C # float
    m_bFilterFixedMinDistance = 0x60 # bool
    m_bFilterGoalDistance = 0x61 # bool
    m_bFilterGoalOvershoot = 0x62 # bool

class CDrawCullingData:
    m_vConeApex = 0x0 # Vector
    m_ConeAxis = 0xC # int8_t[3]
    m_ConeCutoff = 0xF # int8_t

class CEmitTagActionUpdater:
    m_nTagIndex = 0x18 # int32_t
    m_bIsZeroDuration = 0x1C # bool

class CEnumAnimParameter:
    m_defaultValue = 0x68 # uint8_t
    m_enumOptions = 0x70 # CUtlVector<CUtlString>

class CExpressionActionUpdater:
    m_hParam = 0x18 # CAnimParamHandle
    m_eParamType = 0x1A # AnimParamType_t
    m_hScript = 0x1C # AnimScriptHandle

class CFingerBone:
    m_boneName = 0x0 # CUtlString
    m_hingeAxis = 0x8 # Vector
    m_vCapsulePos1 = 0x14 # Vector
    m_vCapsulePos2 = 0x20 # Vector
    m_flMinAngle = 0x2C # float
    m_flMaxAngle = 0x30 # float
    m_flRadius = 0x34 # float

class CFingerChain:
    m_targets = 0x0 # CUtlVector<CFingerSource>
    m_bones = 0x18 # CUtlVector<CFingerBone>
    m_name = 0x30 # CUtlString
    m_tipParentBoneName = 0x38 # CUtlString
    m_vTipOffset = 0x40 # Vector
    m_metacarpalBoneName = 0x50 # CUtlString
    m_vSplayHingeAxis = 0x58 # Vector
    m_flSplayMinAngle = 0x64 # float
    m_flSplayMaxAngle = 0x68 # float
    m_flFingerScaleRatio = 0x6C # float

class CFingerSource:
    m_nFingerIndex = 0x0 # AnimVRFinger_t
    m_flFingerWeight = 0x4 # float

class CFlexController:
    m_szName = 0x0 # CUtlString
    m_szType = 0x8 # CUtlString
    min = 0x10 # float
    max = 0x14 # float

class CFlexDesc:
    m_szFacs = 0x0 # CUtlString

class CFlexOp:
    m_OpCode = 0x0 # FlexOpCode_t
    m_Data = 0x4 # int32_t

class CFlexRule:
    m_nFlex = 0x0 # int32_t
    m_FlexOps = 0x8 # CUtlVector<CFlexOp>

class CFloatAnimParameter:
    m_fDefaultValue = 0x60 # float
    m_fMinValue = 0x64 # float
    m_fMaxValue = 0x68 # float
    m_bInterpolate = 0x6C # bool

class CFollowAttachmentUpdateNode:
    m_opFixedData = 0x70 # FollowAttachmentSettings_t

class CFollowPathUpdateNode:
    m_flBlendOutTime = 0x6C # float
    m_bBlockNonPathMovement = 0x70 # bool
    m_bStopFeetAtGoal = 0x71 # bool
    m_bScaleSpeed = 0x72 # bool
    m_flScale = 0x74 # float
    m_flMinAngle = 0x78 # float
    m_flMaxAngle = 0x7C # float
    m_flSpeedScaleBlending = 0x80 # float
    m_turnDamping = 0x88 # CAnimInputDamping
    m_facingTarget = 0x98 # AnimValueSource
    m_hParam = 0x9C # CAnimParamHandle
    m_flTurnToFaceOffset = 0xA0 # float
    m_bTurnToFace = 0xA4 # bool

class CFootAdjustmentUpdateNode:
    m_clips = 0x70 # CUtlVector<HSequence>
    m_hBasePoseCacheHandle = 0x88 # CPoseHandle
    m_facingTarget = 0x8C # CAnimParamHandle
    m_flTurnTimeMin = 0x90 # float
    m_flTurnTimeMax = 0x94 # float
    m_flStepHeightMax = 0x98 # float
    m_flStepHeightMaxAngle = 0x9C # float
    m_bResetChild = 0xA0 # bool
    m_bAnimationDriven = 0xA1 # bool

class CFootCycleDefinition:
    m_vStancePositionMS = 0x0 # Vector
    m_vMidpointPositionMS = 0xC # Vector
    m_flStanceDirectionMS = 0x18 # float
    m_vToStrideStartPos = 0x1C # Vector
    m_stanceCycle = 0x28 # CAnimCycle
    m_footLiftCycle = 0x2C # CFootCycle
    m_footOffCycle = 0x30 # CFootCycle
    m_footStrikeCycle = 0x34 # CFootCycle
    m_footLandCycle = 0x38 # CFootCycle

class CFootCycleMetricEvaluator:
    m_footIndices = 0x50 # CUtlVector<int32_t>

class CFootDefinition:
    m_name = 0x0 # CUtlString
    m_ankleBoneName = 0x8 # CUtlString
    m_toeBoneName = 0x10 # CUtlString
    m_vBallOffset = 0x18 # Vector
    m_vHeelOffset = 0x24 # Vector
    m_flFootLength = 0x30 # float
    m_flBindPoseDirectionMS = 0x34 # float
    m_flTraceHeight = 0x38 # float
    m_flTraceRadius = 0x3C # float

class CFootFallAnimTag:
    m_foot = 0x38 # FootFallTagFoot_t

class CFootLockUpdateNode:
    m_opFixedSettings = 0x68 # FootLockPoseOpFixedSettings
    m_footSettings = 0xD0 # CUtlVector<FootFixedSettings>
    m_hipShiftDamping = 0xE8 # CAnimInputDamping
    m_rootHeightDamping = 0xF8 # CAnimInputDamping
    m_flStrideCurveScale = 0x108 # float
    m_flStrideCurveLimitScale = 0x10C # float
    m_flStepHeightIncreaseScale = 0x110 # float
    m_flStepHeightDecreaseScale = 0x114 # float
    m_flHipShiftScale = 0x118 # float
    m_flBlendTime = 0x11C # float
    m_flMaxRootHeightOffset = 0x120 # float
    m_flMinRootHeightOffset = 0x124 # float
    m_flTiltPlanePitchSpringStrength = 0x128 # float
    m_flTiltPlaneRollSpringStrength = 0x12C # float
    m_bApplyFootRotationLimits = 0x130 # bool
    m_bApplyHipShift = 0x131 # bool
    m_bModulateStepHeight = 0x132 # bool
    m_bResetChild = 0x133 # bool
    m_bEnableVerticalCurvedPaths = 0x134 # bool
    m_bEnableRootHeightDamping = 0x135 # bool

class CFootMotion:
    m_strides = 0x0 # CUtlVector<CFootStride>
    m_name = 0x18 # CUtlString
    m_bAdditive = 0x20 # bool

class CFootPinningUpdateNode:
    m_poseOpFixedData = 0x70 # FootPinningPoseOpFixedData_t
    m_eTimingSource = 0xA0 # FootPinningTimingSource
    m_params = 0xA8 # CUtlVector<CAnimParamHandle>
    m_bResetChild = 0xC0 # bool

class CFootPositionMetricEvaluator:
    m_footIndices = 0x50 # CUtlVector<int32_t>
    m_bIgnoreSlope = 0x68 # bool

class CFootStepTriggerUpdateNode:
    m_triggers = 0x68 # CUtlVector<FootStepTrigger>
    m_flTolerance = 0x84 # float

class CFootStride:
    m_definition = 0x0 # CFootCycleDefinition
    m_trajectories = 0x40 # CFootTrajectories

class CFootTrajectories:
    m_trajectories = 0x0 # CUtlVector<CFootTrajectory>

class CFootTrajectory:
    m_vOffset = 0x0 # Vector
    m_flRotationOffset = 0xC # float
    m_flProgression = 0x10 # float

class CFootstepLandedAnimTag:
    m_FootstepType = 0x38 # FootstepLandedFootSoundType_t
    m_OverrideSoundName = 0x40 # CUtlString
    m_DebugAnimSourceString = 0x48 # CUtlString
    m_BoneName = 0x50 # CUtlString

class CFutureFacingMetricEvaluator:
    m_flDistance = 0x50 # float
    m_flTime = 0x54 # float

class CFutureVelocityMetricEvaluator:
    m_flDistance = 0x50 # float
    m_flStoppingDistance = 0x54 # float
    m_flTargetSpeed = 0x58 # float
    m_eMode = 0x5C # VelocityMetricMode

class CHitBox:
    m_name = 0x0 # CUtlString
    m_sSurfaceProperty = 0x8 # CUtlString
    m_sBoneName = 0x10 # CUtlString
    m_vMinBounds = 0x18 # Vector
    m_vMaxBounds = 0x24 # Vector
    m_flShapeRadius = 0x30 # float
    m_nBoneNameHash = 0x34 # uint32_t
    m_nGroupId = 0x38 # int32_t
    m_nShapeType = 0x3C # uint8_t
    m_bTranslationOnly = 0x3D # bool
    m_CRC = 0x40 # uint32_t
    m_cRenderColor = 0x44 # Color
    m_nHitBoxIndex = 0x48 # uint16_t

class CHitBoxSet:
    m_name = 0x0 # CUtlString
    m_nNameHash = 0x8 # uint32_t
    m_HitBoxes = 0x10 # CUtlVector<CHitBox>
    m_SourceFilename = 0x28 # CUtlString

class CHitBoxSetList:
    m_HitBoxSets = 0x0 # CUtlVector<CHitBoxSet>

class CHitReactUpdateNode:
    m_opFixedSettings = 0x68 # HitReactFixedSettings_t
    m_triggerParam = 0xB4 # CAnimParamHandle
    m_hitBoneParam = 0xB6 # CAnimParamHandle
    m_hitOffsetParam = 0xB8 # CAnimParamHandle
    m_hitDirectionParam = 0xBA # CAnimParamHandle
    m_hitStrengthParam = 0xBC # CAnimParamHandle
    m_flMinDelayBetweenHits = 0xC0 # float
    m_bResetChild = 0xC4 # bool

class CIntAnimParameter:
    m_defaultValue = 0x60 # int32_t
    m_minValue = 0x64 # int32_t
    m_maxValue = 0x68 # int32_t

class CJiggleBoneUpdateNode:
    m_opFixedData = 0x68 # JiggleBoneSettingsList_t

class CJumpHelperUpdateNode:
    m_hTargetParam = 0xA8 # CAnimParamHandle
    m_flOriginalJumpMovement = 0xAC # Vector
    m_flOriginalJumpDuration = 0xB8 # float
    m_flJumpStartCycle = 0xBC # float
    m_flJumpEndCycle = 0xC0 # float
    m_eCorrectionMethod = 0xC4 # JumpCorrectionMethod
    m_bTranslationAxis = 0xC8 # bool[3]
    m_bScaleSpeed = 0xCB # bool

class CLODComponentUpdater:
    m_nServerLOD = 0x30 # int32_t

class CLeanMatrixUpdateNode:
    m_frameCorners = 0x5C # int32_t[3][3]
    m_poses = 0x80 # CPoseHandle[9]
    m_damping = 0xA8 # CAnimInputDamping
    m_blendSource = 0xB8 # AnimVectorSource
    m_paramIndex = 0xBC # CAnimParamHandle
    m_verticalAxis = 0xC0 # Vector
    m_horizontalAxis = 0xCC # Vector
    m_hSequence = 0xD8 # HSequence
    m_flMaxValue = 0xDC # float
    m_nSequenceMaxFrame = 0xE0 # int32_t

class CLookAtUpdateNode:
    m_opFixedSettings = 0x70 # LookAtOpFixedSettings_t
    m_target = 0x138 # AnimVectorSource
    m_paramIndex = 0x13C # CAnimParamHandle
    m_weightParamIndex = 0x13E # CAnimParamHandle
    m_bResetChild = 0x140 # bool
    m_bLockWhenWaning = 0x141 # bool

class CLookComponentUpdater:
    m_hLookHeading = 0x34 # CAnimParamHandle
    m_hLookHeadingVelocity = 0x36 # CAnimParamHandle
    m_hLookPitch = 0x38 # CAnimParamHandle
    m_hLookDistance = 0x3A # CAnimParamHandle
    m_hLookDirection = 0x3C # CAnimParamHandle
    m_hLookTarget = 0x3E # CAnimParamHandle
    m_hLookTargetWorldSpace = 0x40 # CAnimParamHandle
    m_bNetworkLookTarget = 0x42 # bool

class CMaterialAttributeAnimTag:
    m_AttributeName = 0x38 # CUtlString
    m_AttributeType = 0x40 # MatterialAttributeTagType_t
    m_flValue = 0x44 # float
    m_Color = 0x48 # Color

class CMaterialDrawDescriptor:
    m_nPrimitiveType = 0x0 # RenderPrimitiveType_t
    m_nBaseVertex = 0x4 # int32_t
    m_nVertexCount = 0x8 # int32_t
    m_nStartIndex = 0xC # int32_t
    m_nIndexCount = 0x10 # int32_t
    m_flUvDensity = 0x14 # float
    m_vTintColor = 0x18 # Vector
    m_flAlpha = 0x24 # float
    m_nFirstMeshlet = 0x2C # uint32_t
    m_nNumMeshlets = 0x30 # uint16_t
    m_indexBuffer = 0xB8 # CRenderBufferBinding
    m_material = 0xE0 # CStrongHandle<InfoForResourceTypeIMaterial2>

class CMeshletDescriptor:
    m_PackedAABB = 0x0 # PackedAABB_t
    m_CullingData = 0x8 # CDrawCullingData

class CModelConfig:
    m_ConfigName = 0x0 # CUtlString
    m_Elements = 0x8 # CUtlVector<CModelConfigElement*>
    m_bTopLevel = 0x20 # bool

class CModelConfigElement:
    m_ElementName = 0x8 # CUtlString
    m_NestedElements = 0x10 # CUtlVector<CModelConfigElement*>

class CModelConfigElement_AttachedModel:
    m_InstanceName = 0x48 # CUtlString
    m_EntityClass = 0x50 # CUtlString
    m_hModel = 0x58 # CStrongHandle<InfoForResourceTypeCModel>
    m_vOffset = 0x60 # Vector
    m_aAngOffset = 0x6C # QAngle
    m_AttachmentName = 0x78 # CUtlString
    m_LocalAttachmentOffsetName = 0x80 # CUtlString
    m_AttachmentType = 0x88 # ModelConfigAttachmentType_t
    m_bBoneMergeFlex = 0x8C # bool
    m_bUserSpecifiedColor = 0x8D # bool
    m_bUserSpecifiedMaterialGroup = 0x8E # bool
    m_bAcceptParentMaterialDrivenDecals = 0x8F # bool
    m_BodygroupOnOtherModels = 0x90 # CUtlString
    m_MaterialGroupOnOtherModels = 0x98 # CUtlString

class CModelConfigElement_Command:
    m_Command = 0x48 # CUtlString
    m_Args = 0x50 # KeyValues3

class CModelConfigElement_RandomColor:
    m_Gradient = 0x48 # CColorGradient

class CModelConfigElement_RandomPick:
    m_Choices = 0x48 # CUtlVector<CUtlString>
    m_ChoiceWeights = 0x60 # CUtlVector<float>

class CModelConfigElement_SetBodygroup:
    m_GroupName = 0x48 # CUtlString
    m_nChoice = 0x50 # int32_t

class CModelConfigElement_SetBodygroupOnAttachedModels:
    m_GroupName = 0x48 # CUtlString
    m_nChoice = 0x50 # int32_t

class CModelConfigElement_SetMaterialGroup:
    m_MaterialGroupName = 0x48 # CUtlString

class CModelConfigElement_SetMaterialGroupOnAttachedModels:
    m_MaterialGroupName = 0x48 # CUtlString

class CModelConfigElement_SetRenderColor:
    m_Color = 0x48 # Color

class CModelConfigElement_UserPick:
    m_Choices = 0x48 # CUtlVector<CUtlString>

class CModelConfigList:
    m_bHideMaterialGroupInTools = 0x0 # bool
    m_bHideRenderColorInTools = 0x1 # bool
    m_Configs = 0x8 # CUtlVector<CModelConfig*>

class CMoodVData:
    m_sModelName = 0x0 # CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    m_nMoodType = 0xE0 # MoodType_t
    m_animationLayers = 0xE8 # CUtlVector<MoodAnimationLayer_t>

class CMorphBundleData:
    m_flULeftSrc = 0x0 # float
    m_flVTopSrc = 0x4 # float
    m_offsets = 0x8 # CUtlVector<float>
    m_ranges = 0x20 # CUtlVector<float>

class CMorphConstraint:
    m_sTargetMorph = 0x70 # CUtlString
    m_nSlaveChannel = 0x78 # int32_t
    m_flMin = 0x7C # float
    m_flMax = 0x80 # float

class CMorphData:
    m_name = 0x0 # CUtlString
    m_morphRectDatas = 0x8 # CUtlVector<CMorphRectData>

class CMorphRectData:
    m_nXLeftDst = 0x0 # int16_t
    m_nYTopDst = 0x2 # int16_t
    m_flUWidthSrc = 0x4 # float
    m_flVHeightSrc = 0x8 # float
    m_bundleDatas = 0x10 # CUtlVector<CMorphBundleData>

class CMorphSetData:
    m_nWidth = 0x10 # int32_t
    m_nHeight = 0x14 # int32_t
    m_bundleTypes = 0x18 # CUtlVector<MorphBundleType_t>
    m_morphDatas = 0x30 # CUtlVector<CMorphData>
    m_pTextureAtlas = 0x48 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_FlexDesc = 0x50 # CUtlVector<CFlexDesc>
    m_FlexControllers = 0x68 # CUtlVector<CFlexController>
    m_FlexRules = 0x80 # CUtlVector<CFlexRule>

class CMotionDataSet:
    m_groups = 0x0 # CUtlVector<CMotionGraphGroup>
    m_nDimensionCount = 0x18 # int32_t

class CMotionGraph:
    m_paramSpans = 0x10 # CParamSpanUpdater
    m_tags = 0x28 # CUtlVector<TagSpan_t>
    m_pRootNode = 0x40 # CSmartPtr<CMotionNode>
    m_nParameterCount = 0x48 # int32_t
    m_nConfigStartIndex = 0x4C # int32_t
    m_nConfigCount = 0x50 # int32_t
    m_bLoop = 0x54 # bool

class CMotionGraphConfig:
    m_paramValues = 0x0 # float[4]
    m_flDuration = 0x10 # float
    m_nMotionIndex = 0x14 # MotionIndex
    m_nSampleStart = 0x18 # int32_t
    m_nSampleCount = 0x1C # int32_t

class CMotionGraphGroup:
    m_searchDB = 0x0 # CMotionSearchDB
    m_motionGraphs = 0xB8 # CUtlVector<CSmartPtr<CMotionGraph>>
    m_motionGraphConfigs = 0xD0 # CUtlVector<CMotionGraphConfig>
    m_sampleToConfig = 0xE8 # CUtlVector<int32_t>
    m_hIsActiveScript = 0x100 # AnimScriptHandle

class CMotionGraphUpdateNode:
    m_pMotionGraph = 0x58 # CSmartPtr<CMotionGraph>

class CMotionMatchingUpdateNode:
    m_dataSet = 0x58 # CMotionDataSet
    m_metrics = 0x78 # CUtlVector<CSmartPtr<CMotionMetricEvaluator>>
    m_weights = 0x90 # CUtlVector<float>
    m_bSearchEveryTick = 0xE0 # bool
    m_flSearchInterval = 0xE4 # float
    m_bSearchWhenClipEnds = 0xE8 # bool
    m_bSearchWhenGoalChanges = 0xE9 # bool
    m_blendCurve = 0xEC # CBlendCurve
    m_flSampleRate = 0xF4 # float
    m_flBlendTime = 0xF8 # float
    m_bLockClipWhenWaning = 0xFC # bool
    m_flSelectionThreshold = 0x100 # float
    m_flReselectionTimeWindow = 0x104 # float
    m_bEnableRotationCorrection = 0x108 # bool
    m_bGoalAssist = 0x109 # bool
    m_flGoalAssistDistance = 0x10C # float
    m_flGoalAssistTolerance = 0x110 # float
    m_distanceScale_Damping = 0x118 # CAnimInputDamping
    m_flDistanceScale_OuterRadius = 0x128 # float
    m_flDistanceScale_InnerRadius = 0x12C # float
    m_flDistanceScale_MaxScale = 0x130 # float
    m_flDistanceScale_MinScale = 0x134 # float
    m_bEnableDistanceScaling = 0x138 # bool

class CMotionMetricEvaluator:
    m_means = 0x18 # CUtlVector<float>
    m_standardDeviations = 0x30 # CUtlVector<float>
    m_flWeight = 0x48 # float
    m_nDimensionStartIndex = 0x4C # int32_t

class CMotionNode:
    m_name = 0x18 # CUtlString
    m_id = 0x20 # AnimNodeID

class CMotionNodeBlend1D:
    m_blendItems = 0x28 # CUtlVector<MotionBlendItem>
    m_nParamIndex = 0x40 # int32_t

class CMotionNodeSequence:
    m_tags = 0x28 # CUtlVector<TagSpan_t>
    m_hSequence = 0x40 # HSequence
    m_flPlaybackSpeed = 0x44 # float

class CMotionSearchDB:
    m_rootNode = 0x0 # CMotionSearchNode
    m_residualQuantizer = 0x80 # CProductQuantizer
    m_codeIndices = 0xA0 # CUtlVector<MotionDBIndex>

class CMotionSearchNode:
    m_children = 0x0 # CUtlVector<CMotionSearchNode*>
    m_quantizer = 0x18 # CVectorQuantizer
    m_sampleCodes = 0x38 # CUtlVector<CUtlVector<SampleCode>>
    m_sampleIndices = 0x50 # CUtlVector<CUtlVector<int32_t>>
    m_selectableSamples = 0x68 # CUtlVector<int32_t>

class CMovementComponentUpdater:
    m_movementModes = 0x30 # CUtlVector<CMovementMode>
    m_motors = 0x48 # CUtlVector<CSmartPtr<CAnimMotorUpdaterBase>>
    m_facingDamping = 0x60 # CAnimInputDamping
    m_eDefaultFacingMode = 0x70 # FacingMode
    m_nDefaultMotorIndex = 0x7C # int32_t
    m_bMoveVarsDisabled = 0x80 # bool
    m_bNetworkPath = 0x81 # bool
    m_bNetworkFacing = 0x82 # bool
    m_paramHandles = 0x83 # CAnimParamHandle[30]

class CMovementMode:
    m_name = 0x0 # CUtlString
    m_flSpeed = 0x8 # float

class CMoverUpdateNode:
    m_damping = 0x70 # CAnimInputDamping
    m_facingTarget = 0x80 # AnimValueSource
    m_hMoveVecParam = 0x84 # CAnimParamHandle
    m_hMoveHeadingParam = 0x86 # CAnimParamHandle
    m_hTurnToFaceParam = 0x88 # CAnimParamHandle
    m_flTurnToFaceOffset = 0x8C # float
    m_flTurnToFaceLimit = 0x90 # float
    m_bAdditive = 0x94 # bool
    m_bApplyMovement = 0x95 # bool
    m_bOrientMovement = 0x96 # bool
    m_bApplyRotation = 0x97 # bool
    m_bLimitOnly = 0x98 # bool

class CParamSpanUpdater:
    m_spans = 0x0 # CUtlVector<ParamSpan_t>

class CParticleAnimTag:
    m_hParticleSystem = 0x38 # CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    m_particleSystemName = 0x40 # CUtlString
    m_configName = 0x48 # CUtlString
    m_bDetachFromOwner = 0x50 # bool
    m_bStopWhenTagEnds = 0x51 # bool
    m_bTagEndStopIsInstant = 0x52 # bool
    m_attachmentName = 0x58 # CUtlString
    m_attachmentType = 0x60 # ParticleAttachment_t
    m_attachmentCP1Name = 0x68 # CUtlString
    m_attachmentCP1Type = 0x70 # ParticleAttachment_t

class CPathAnimMotorUpdaterBase:
    m_bLockToPath = 0x20 # bool

class CPathHelperUpdateNode:
    m_flStoppingRadius = 0x68 # float
    m_flStoppingSpeedScale = 0x6C # float

class CPathMetricEvaluator:
    m_pathTimeSamples = 0x50 # CUtlVector<float>
    m_flDistance = 0x68 # float
    m_bExtrapolateMovement = 0x6C # bool
    m_flMinExtrapolationSpeed = 0x70 # float

class CPhysSurfaceProperties:
    m_name = 0x0 # CUtlString
    m_nameHash = 0x8 # uint32_t
    m_baseNameHash = 0xC # uint32_t
    m_bHidden = 0x18 # bool
    m_description = 0x20 # CUtlString
    m_physics = 0x28 # CPhysSurfacePropertiesPhysics
    m_audioSounds = 0x48 # CPhysSurfacePropertiesSoundNames
    m_audioParams = 0x88 # CPhysSurfacePropertiesAudio

class CPhysSurfacePropertiesAudio:
    m_reflectivity = 0x0 # float
    m_hardnessFactor = 0x4 # float
    m_roughnessFactor = 0x8 # float
    m_roughThreshold = 0xC # float
    m_hardThreshold = 0x10 # float
    m_hardVelocityThreshold = 0x14 # float
    m_flStaticImpactVolume = 0x18 # float
    m_flOcclusionFactor = 0x1C # float

class CPhysSurfacePropertiesPhysics:
    m_friction = 0x0 # float
    m_elasticity = 0x4 # float
    m_density = 0x8 # float
    m_thickness = 0xC # float
    m_softContactFrequency = 0x10 # float
    m_softContactDampingRatio = 0x14 # float
    m_wheelDrag = 0x18 # float

class CPhysSurfacePropertiesSoundNames:
    m_impactSoft = 0x0 # CUtlString
    m_impactHard = 0x8 # CUtlString
    m_scrapeSmooth = 0x10 # CUtlString
    m_scrapeRough = 0x18 # CUtlString
    m_bulletImpact = 0x20 # CUtlString
    m_rolling = 0x28 # CUtlString
    m_break = 0x30 # CUtlString
    m_strain = 0x38 # CUtlString

class CPlayerInputAnimMotorUpdater:
    m_sampleTimes = 0x20 # CUtlVector<float>
    m_flSpringConstant = 0x3C # float
    m_flAnticipationDistance = 0x40 # float
    m_hAnticipationPosParam = 0x44 # CAnimParamHandle
    m_hAnticipationHeadingParam = 0x46 # CAnimParamHandle
    m_bUseAcceleration = 0x48 # bool

class CPoseHandle:
    m_nIndex = 0x0 # uint16_t
    m_eType = 0x2 # PoseType_t

class CProductQuantizer:
    m_subQuantizers = 0x0 # CUtlVector<CVectorQuantizer>
    m_nDimensions = 0x18 # int32_t

class CQuaternionAnimParameter:
    m_defaultValue = 0x60 # Quaternion
    m_bInterpolate = 0x70 # bool

class CRagdollAnimTag:
    m_nPoseControl = 0x38 # AnimPoseControl
    m_flFrequency = 0x3C # float
    m_flDampingRatio = 0x40 # float
    m_flDecayDuration = 0x44 # float
    m_flDecayBias = 0x48 # float
    m_bDestroy = 0x4C # bool

class CRagdollComponentUpdater:
    m_ragdollNodePaths = 0x30 # CUtlVector<CAnimNodePath>
    m_boneIndices = 0x48 # CUtlVector<int32_t>
    m_boneNames = 0x60 # CUtlVector<CUtlString>
    m_weightLists = 0x78 # CUtlVector<WeightList>
    m_flSpringFrequencyMin = 0x90 # float
    m_flSpringFrequencyMax = 0x94 # float
    m_flMaxStretch = 0x98 # float

class CRagdollUpdateNode:
    m_nWeightListIndex = 0x68 # int32_t
    m_poseControlMethod = 0x6C # RagdollPoseControl

class CRenderBufferBinding:
    m_hBuffer = 0x0 # uint64_t
    m_nBindOffsetBytes = 0x10 # uint32_t

class CRenderMesh:
    m_sceneObjects = 0x10 # CUtlVectorFixedGrowable<CSceneObjectData>
    m_constraints = 0xA0 # CUtlVector<CBaseConstraint*>
    m_skeleton = 0xB8 # CRenderSkeleton

class CRenderSkeleton:
    m_bones = 0x0 # CUtlVector<RenderSkeletonBone_t>
    m_boneParents = 0x30 # CUtlVector<int32_t>
    m_nBoneWeightCount = 0x48 # int32_t

class CSceneObjectData:
    m_vMinBounds = 0x0 # Vector
    m_vMaxBounds = 0xC # Vector
    m_drawCalls = 0x18 # CUtlVector<CMaterialDrawDescriptor>
    m_drawBounds = 0x30 # CUtlVector<AABB_t>
    m_meshlets = 0x48 # CUtlVector<CMeshletDescriptor>
    m_vTintColor = 0x60 # Vector4D

class CSelectorUpdateNode:
    m_children = 0x58 # CUtlVector<CAnimUpdateNodeRef>
    m_tags = 0x70 # CUtlVector<int8_t>
    m_blendCurve = 0x8C # CBlendCurve
    m_flBlendTime = 0x94 # CAnimValue<float>
    m_hParameter = 0x9C # CAnimParamHandle
    m_eTagBehavior = 0xA0 # SelectorTagBehavior_t
    m_bResetOnChange = 0xA4 # bool
    m_bSyncCyclesOnChange = 0xA5 # bool

class CSeqAutoLayer:
    m_nLocalReference = 0x0 # int16_t
    m_nLocalPose = 0x2 # int16_t
    m_flags = 0x4 # CSeqAutoLayerFlag
    m_start = 0xC # float
    m_peak = 0x10 # float
    m_tail = 0x14 # float
    m_end = 0x18 # float

class CSeqAutoLayerFlag:
    m_bPost = 0x0 # bool
    m_bSpline = 0x1 # bool
    m_bXFade = 0x2 # bool
    m_bNoBlend = 0x3 # bool
    m_bLocal = 0x4 # bool
    m_bPose = 0x5 # bool
    m_bFetchFrame = 0x6 # bool
    m_bSubtract = 0x7 # bool

class CSeqBoneMaskList:
    m_sName = 0x0 # CBufferString
    m_nLocalBoneArray = 0x10 # CUtlVector<int16_t>
    m_flBoneWeightArray = 0x28 # CUtlVector<float>
    m_flDefaultMorphCtrlWeight = 0x40 # float
    m_morphCtrlWeightArray = 0x48 # CUtlVector<CUtlPair<CBufferString,float>>

class CSeqCmdLayer:
    m_cmd = 0x0 # int16_t
    m_nLocalReference = 0x2 # int16_t
    m_nLocalBonemask = 0x4 # int16_t
    m_nDstResult = 0x6 # int16_t
    m_nSrcResult = 0x8 # int16_t
    m_bSpline = 0xA # bool
    m_flVar1 = 0xC # float
    m_flVar2 = 0x10 # float
    m_nLineNumber = 0x14 # int16_t

class CSeqCmdSeqDesc:
    m_sName = 0x0 # CBufferString
    m_flags = 0x10 # CSeqSeqDescFlag
    m_transition = 0x1C # CSeqTransition
    m_nFrameRangeSequence = 0x24 # int16_t
    m_nFrameCount = 0x26 # int16_t
    m_flFPS = 0x28 # float
    m_nSubCycles = 0x2C # int16_t
    m_numLocalResults = 0x2E # int16_t
    m_cmdLayerArray = 0x30 # CUtlVector<CSeqCmdLayer>
    m_eventArray = 0x48 # CUtlVector<CAnimEventDefinition>
    m_activityArray = 0x60 # CUtlVector<CAnimActivity>
    m_poseSettingArray = 0x78 # CUtlVector<CSeqPoseSetting>

class CSeqIKLock:
    m_flPosWeight = 0x0 # float
    m_flAngleWeight = 0x4 # float
    m_nLocalBone = 0x8 # int16_t
    m_bBonesOrientedAlongPositiveX = 0xA # bool

class CSeqMultiFetch:
    m_flags = 0x0 # CSeqMultiFetchFlag
    m_localReferenceArray = 0x8 # CUtlVector<int16_t>
    m_nGroupSize = 0x20 # int32_t[2]
    m_nLocalPose = 0x28 # int32_t[2]
    m_poseKeyArray0 = 0x30 # CUtlVector<float>
    m_poseKeyArray1 = 0x48 # CUtlVector<float>
    m_nLocalCyclePoseParameter = 0x60 # int32_t
    m_bCalculatePoseParameters = 0x64 # bool

class CSeqMultiFetchFlag:
    m_bRealtime = 0x0 # bool
    m_bCylepose = 0x1 # bool
    m_b0D = 0x2 # bool
    m_b1D = 0x3 # bool
    m_b2D = 0x4 # bool
    m_b2D_TRI = 0x5 # bool

class CSeqPoseParamDesc:
    m_sName = 0x0 # CBufferString
    m_flStart = 0x10 # float
    m_flEnd = 0x14 # float
    m_flLoop = 0x18 # float
    m_bLooping = 0x1C # bool

class CSeqPoseSetting:
    m_sPoseParameter = 0x0 # CBufferString
    m_sAttachment = 0x10 # CBufferString
    m_sReferenceSequence = 0x20 # CBufferString
    m_flValue = 0x30 # float
    m_bX = 0x34 # bool
    m_bY = 0x35 # bool
    m_bZ = 0x36 # bool
    m_eType = 0x38 # int32_t

class CSeqS1SeqDesc:
    m_sName = 0x0 # CBufferString
    m_flags = 0x10 # CSeqSeqDescFlag
    m_fetch = 0x20 # CSeqMultiFetch
    m_nLocalWeightlist = 0x88 # int32_t
    m_autoLayerArray = 0x90 # CUtlVector<CSeqAutoLayer>
    m_IKLockArray = 0xA8 # CUtlVector<CSeqIKLock>
    m_transition = 0xC0 # CSeqTransition
    m_SequenceKeys = 0xC8 # KeyValues3
    m_LegacyKeyValueText = 0xD8 # CBufferString
    m_activityArray = 0xE8 # CUtlVector<CAnimActivity>
    m_footMotion = 0x100 # CUtlVector<CFootMotion>

class CSeqScaleSet:
    m_sName = 0x0 # CBufferString
    m_bRootOffset = 0x10 # bool
    m_vRootOffset = 0x14 # Vector
    m_nLocalBoneArray = 0x20 # CUtlVector<int16_t>
    m_flBoneScaleArray = 0x38 # CUtlVector<float>

class CSeqSeqDescFlag:
    m_bLooping = 0x0 # bool
    m_bSnap = 0x1 # bool
    m_bAutoplay = 0x2 # bool
    m_bPost = 0x3 # bool
    m_bHidden = 0x4 # bool
    m_bMulti = 0x5 # bool
    m_bLegacyDelta = 0x6 # bool
    m_bLegacyWorldspace = 0x7 # bool
    m_bLegacyCyclepose = 0x8 # bool
    m_bLegacyRealtime = 0x9 # bool
    m_bModelDoc = 0xA # bool

class CSeqSynthAnimDesc:
    m_sName = 0x0 # CBufferString
    m_flags = 0x10 # CSeqSeqDescFlag
    m_transition = 0x1C # CSeqTransition
    m_nLocalBaseReference = 0x24 # int16_t
    m_nLocalBoneMask = 0x26 # int16_t
    m_activityArray = 0x28 # CUtlVector<CAnimActivity>

class CSeqTransition:
    m_flFadeInTime = 0x0 # float
    m_flFadeOutTime = 0x4 # float

class CSequenceFinishedAnimTag:
    m_sequenceName = 0x38 # CUtlString

class CSequenceGroupData:
    m_sName = 0x10 # CBufferString
    m_nFlags = 0x20 # uint32_t
    m_localSequenceNameArray = 0x28 # CUtlVector<CBufferString>
    m_localS1SeqDescArray = 0x40 # CUtlVector<CSeqS1SeqDesc>
    m_localMultiSeqDescArray = 0x58 # CUtlVector<CSeqS1SeqDesc>
    m_localSynthAnimDescArray = 0x70 # CUtlVector<CSeqSynthAnimDesc>
    m_localCmdSeqDescArray = 0x88 # CUtlVector<CSeqCmdSeqDesc>
    m_localBoneMaskArray = 0xA0 # CUtlVector<CSeqBoneMaskList>
    m_localScaleSetArray = 0xB8 # CUtlVector<CSeqScaleSet>
    m_localBoneNameArray = 0xD0 # CUtlVector<CBufferString>
    m_localNodeName = 0xE8 # CBufferString
    m_localPoseParamArray = 0xF8 # CUtlVector<CSeqPoseParamDesc>
    m_keyValues = 0x110 # KeyValues3
    m_localIKAutoplayLockArray = 0x120 # CUtlVector<CSeqIKLock>

class CSequenceUpdateNode:
    m_paramSpans = 0x60 # CParamSpanUpdater
    m_tags = 0x78 # CUtlVector<TagSpan_t>
    m_hSequence = 0x94 # HSequence
    m_playbackSpeed = 0x98 # float
    m_duration = 0x9C # float
    m_bLoop = 0xA0 # bool

class CSetFacingUpdateNode:
    m_facingMode = 0x68 # FacingMode
    m_bResetChild = 0x6C # bool

class CSetParameterActionUpdater:
    m_hParam = 0x18 # CAnimParamHandle
    m_value = 0x1A # CAnimVariant

class CSingleFrameUpdateNode:
    m_actions = 0x58 # CUtlVector<CSmartPtr<CAnimActionUpdater>>
    m_hPoseCacheHandle = 0x70 # CPoseHandle
    m_hSequence = 0x74 # HSequence
    m_flCycle = 0x78 # float

class CSkeletalInputUpdateNode:
    m_fixedOpData = 0x58 # SkeletalInputOpFixedSettings_t

class CSlopeComponentUpdater:
    m_flTraceDistance = 0x34 # float
    m_hSlopeAngle = 0x38 # CAnimParamHandle
    m_hSlopeAngleFront = 0x3A # CAnimParamHandle
    m_hSlopeAngleSide = 0x3C # CAnimParamHandle
    m_hSlopeHeading = 0x3E # CAnimParamHandle
    m_hSlopeNormal = 0x40 # CAnimParamHandle
    m_hSlopeNormal_WorldSpace = 0x42 # CAnimParamHandle

class CSlowDownOnSlopesUpdateNode:
    m_flSlowDownStrength = 0x68 # float

class CSolveIKChainUpdateNode:
    m_targetHandles = 0x68 # CUtlVector<CSolveIKTargetHandle_t>
    m_opFixedData = 0x80 # SolveIKChainPoseOpFixedSettings_t

class CSolveIKTargetHandle_t:
    m_positionHandle = 0x0 # CAnimParamHandle
    m_orientationHandle = 0x2 # CAnimParamHandle

class CSpeedScaleUpdateNode:
    m_paramIndex = 0x68 # CAnimParamHandle

class CStanceOverrideUpdateNode:
    m_footStanceInfo = 0x68 # CUtlVector<StanceInfo_t>
    m_pStanceSourceNode = 0x80 # CAnimUpdateNodeRef
    m_hParameter = 0x90 # CAnimParamHandle
    m_eMode = 0x94 # StanceOverrideMode

class CStanceScaleUpdateNode:
    m_hParam = 0x68 # CAnimParamHandle

class CStateActionUpdater:
    m_pAction = 0x0 # CSmartPtr<CAnimActionUpdater>
    m_eBehavior = 0x8 # StateActionBehavior

class CStateMachineComponentUpdater:
    m_stateMachine = 0x30 # CAnimStateMachineUpdater

class CStateMachineUpdateNode:
    m_stateMachine = 0x68 # CAnimStateMachineUpdater
    m_stateData = 0xC0 # CUtlVector<CStateNodeStateData>
    m_transitionData = 0xD8 # CUtlVector<CStateNodeTransitionData>
    m_bBlockWaningTags = 0xF4 # bool
    m_bLockStateWhenWaning = 0xF5 # bool

class CStateNodeStateData:
    m_pChild = 0x0 # CAnimUpdateNodeRef
    m_bExclusiveRootMotion = 0x0 # bitfield:1

class CStateNodeTransitionData:
    m_curve = 0x0 # CBlendCurve
    m_blendDuration = 0x8 # CAnimValue<float>
    m_resetCycleValue = 0x10 # CAnimValue<float>
    m_bReset = 0x0 # bitfield:1
    m_resetCycleOption = 0x0 # bitfield:3

class CStateUpdateData:
    m_name = 0x0 # CUtlString
    m_hScript = 0x8 # AnimScriptHandle
    m_transitionIndices = 0x10 # CUtlVector<int32_t>
    m_actions = 0x28 # CUtlVector<CStateActionUpdater>
    m_stateID = 0x40 # AnimStateID
    m_bIsStartState = 0x0 # bitfield:1
    m_bIsEndState = 0x0 # bitfield:1
    m_bIsPassthrough = 0x0 # bitfield:1

class CStaticPoseCache:
    m_poses = 0x10 # CUtlVector<CCachedPose>
    m_nBoneCount = 0x28 # int32_t
    m_nMorphCount = 0x2C # int32_t

class CStepsRemainingMetricEvaluator:
    m_footIndices = 0x50 # CUtlVector<int32_t>
    m_flMinStepsRemaining = 0x68 # float

class CStopAtGoalUpdateNode:
    m_flOuterRadius = 0x6C # float
    m_flInnerRadius = 0x70 # float
    m_flMaxScale = 0x74 # float
    m_flMinScale = 0x78 # float
    m_damping = 0x80 # CAnimInputDamping

class CSubtractUpdateNode:
    m_footMotionTiming = 0x8C # BinaryNodeChildOption
    m_bApplyToFootMotion = 0x90 # bool
    m_bApplyChannelsSeparately = 0x91 # bool
    m_bUseModelSpace = 0x92 # bool

class CTiltTwistConstraint:
    m_nTargetAxis = 0x70 # int32_t
    m_nSlaveAxis = 0x74 # int32_t

class CTimeRemainingMetricEvaluator:
    m_bMatchByTimeRemaining = 0x50 # bool
    m_flMaxTimeRemaining = 0x54 # float
    m_bFilterByTimeRemaining = 0x58 # bool
    m_flMinTimeRemaining = 0x5C # float

class CToggleComponentActionUpdater:
    m_componentID = 0x18 # AnimComponentID
    m_bSetEnabled = 0x1C # bool

class CTransitionUpdateData:
    m_srcStateIndex = 0x0 # uint8_t
    m_destStateIndex = 0x1 # uint8_t
    m_bDisabled = 0x0 # bitfield:1

class CTurnHelperUpdateNode:
    m_facingTarget = 0x6C # AnimValueSource
    m_turnStartTimeOffset = 0x70 # float
    m_turnDuration = 0x74 # float
    m_bMatchChildDuration = 0x78 # bool
    m_manualTurnOffset = 0x7C # float
    m_bUseManualTurnOffset = 0x80 # bool

class CTwistConstraint:
    m_bInverse = 0x70 # bool
    m_qParentBindRotation = 0x80 # Quaternion
    m_qChildBindRotation = 0x90 # Quaternion

class CTwoBoneIKUpdateNode:
    m_opFixedData = 0x70 # TwoBoneIKSettings_t

class CUnaryUpdateNode:
    m_pChildNode = 0x58 # CAnimUpdateNodeRef

class CVPhysXSurfacePropertiesList:
    m_surfacePropertiesList = 0x0 # CUtlVector<CPhysSurfaceProperties*>

class CVRInputComponentUpdater:
    m_FingerCurl_Thumb = 0x34 # CAnimParamHandle
    m_FingerCurl_Index = 0x36 # CAnimParamHandle
    m_FingerCurl_Middle = 0x38 # CAnimParamHandle
    m_FingerCurl_Ring = 0x3A # CAnimParamHandle
    m_FingerCurl_Pinky = 0x3C # CAnimParamHandle
    m_FingerSplay_Thumb_Index = 0x3E # CAnimParamHandle
    m_FingerSplay_Index_Middle = 0x40 # CAnimParamHandle
    m_FingerSplay_Middle_Ring = 0x42 # CAnimParamHandle
    m_FingerSplay_Ring_Pinky = 0x44 # CAnimParamHandle

class CVectorAnimParameter:
    m_defaultValue = 0x60 # Vector
    m_bInterpolate = 0x6C # bool

class CVectorQuantizer:
    m_centroidVectors = 0x0 # CUtlVector<float>
    m_nCentroids = 0x18 # int32_t
    m_nDimensions = 0x1C # int32_t

class CVirtualAnimParameter:
    m_expressionString = 0x50 # CUtlString
    m_eParamType = 0x58 # AnimParamType_t

class CVrSkeletalInputSettings:
    m_wristBones = 0x0 # CUtlVector<CWristBone>
    m_fingers = 0x18 # CUtlVector<CFingerChain>
    m_name = 0x30 # CUtlString
    m_outerKnuckle1 = 0x38 # CUtlString
    m_outerKnuckle2 = 0x40 # CUtlString
    m_eHand = 0x48 # AnimVRHand_t

class CWayPointHelperUpdateNode:
    m_flStartCycle = 0x6C # float
    m_flEndCycle = 0x70 # float
    m_bOnlyGoals = 0x74 # bool
    m_bPreventOvershoot = 0x75 # bool
    m_bPreventUndershoot = 0x76 # bool

class CWristBone:
    m_name = 0x0 # CUtlString
    m_vForwardLS = 0x8 # Vector
    m_vUpLS = 0x14 # Vector
    m_vOffset = 0x20 # Vector

class ChainToSolveData_t:
    m_nChainIndex = 0x0 # int32_t
    m_SolverSettings = 0x4 # IKSolverSettings_t
    m_TargetSettings = 0x10 # IKTargetSettings_t
    m_DebugSetting = 0x38 # SolveIKChainAnimNodeDebugSetting
    m_flDebugNormalizedValue = 0x3C # float
    m_vDebugOffset = 0x40 # VectorAligned

class ConfigIndex:
    m_nGroup = 0x0 # uint16_t
    m_nConfig = 0x2 # uint16_t

class FingerBone_t:
    m_boneIndex = 0x0 # int32_t
    m_hingeAxis = 0x4 # Vector
    m_vCapsulePos1 = 0x10 # Vector
    m_vCapsulePos2 = 0x1C # Vector
    m_flMinAngle = 0x28 # float
    m_flMaxAngle = 0x2C # float
    m_flRadius = 0x30 # float

class FingerChain_t:
    m_targets = 0x0 # CUtlVector<FingerSource_t>
    m_bones = 0x18 # CUtlVector<FingerBone_t>
    m_vTipOffset = 0x30 # Vector
    m_vSplayHingeAxis = 0x3C # Vector
    m_tipParentBoneIndex = 0x48 # int32_t
    m_metacarpalBoneIndex = 0x4C # int32_t
    m_flSplayMinAngle = 0x50 # float
    m_flSplayMaxAngle = 0x54 # float
    m_flFingerScaleRatio = 0x58 # float

class FingerSource_t:
    m_nFingerIndex = 0x0 # AnimVRFinger_t
    m_flFingerWeight = 0x4 # float

class FollowAttachmentSettings_t:
    m_attachment = 0x0 # CAnimAttachment
    m_boneIndex = 0x80 # int32_t
    m_bMatchTranslation = 0x84 # bool
    m_bMatchRotation = 0x85 # bool

class FootFixedData_t:
    m_vToeOffset = 0x0 # VectorAligned
    m_vHeelOffset = 0x10 # VectorAligned
    m_nTargetBoneIndex = 0x20 # int32_t
    m_nAnkleBoneIndex = 0x24 # int32_t
    m_nIKAnchorBoneIndex = 0x28 # int32_t
    m_ikChainIndex = 0x2C # int32_t
    m_flMaxIKLength = 0x30 # float
    m_nFootIndex = 0x34 # int32_t
    m_nTagIndex = 0x38 # int32_t
    m_flMaxRotationLeft = 0x3C # float
    m_flMaxRotationRight = 0x40 # float

class FootFixedSettings:
    m_traceSettings = 0x0 # TraceSettings_t
    m_vFootBaseBindPosePositionMS = 0x10 # VectorAligned
    m_flFootBaseLength = 0x20 # float
    m_flMaxRotationLeft = 0x24 # float
    m_flMaxRotationRight = 0x28 # float
    m_footstepLandedTagIndex = 0x2C # int32_t
    m_bEnableTracing = 0x30 # bool
    m_flTraceAngleBlend = 0x34 # float
    m_nDisableTagIndex = 0x38 # int32_t
    m_nFootIndex = 0x3C # int32_t

class FootLockPoseOpFixedSettings:
    m_footInfo = 0x0 # CUtlVector<FootFixedData_t>
    m_hipDampingSettings = 0x18 # CAnimInputDamping
    m_nHipBoneIndex = 0x28 # int32_t
    m_ikSolverType = 0x2C # IKSolverType
    m_bApplyTilt = 0x30 # bool
    m_bApplyHipDrop = 0x31 # bool
    m_bAlwaysUseFallbackHinge = 0x32 # bool
    m_bApplyFootRotationLimits = 0x33 # bool
    m_bApplyLegTwistLimits = 0x34 # bool
    m_flMaxFootHeight = 0x38 # float
    m_flExtensionScale = 0x3C # float
    m_flMaxLegTwist = 0x40 # float
    m_bEnableLockBreaking = 0x44 # bool
    m_flLockBreakTolerance = 0x48 # float
    m_flLockBlendTime = 0x4C # float
    m_bEnableStretching = 0x50 # bool
    m_flMaxStretchAmount = 0x54 # float
    m_flStretchExtensionScale = 0x58 # float

class FootPinningPoseOpFixedData_t:
    m_footInfo = 0x0 # CUtlVector<FootFixedData_t>
    m_flBlendTime = 0x18 # float
    m_flLockBreakDistance = 0x1C # float
    m_flMaxLegTwist = 0x20 # float
    m_nHipBoneIndex = 0x24 # int32_t
    m_bApplyLegTwistLimits = 0x28 # bool
    m_bApplyFootRotationLimits = 0x29 # bool

class FootStepTrigger:
    m_tags = 0x0 # CUtlVector<int32_t>
    m_nFootIndex = 0x18 # int32_t
    m_triggerPhase = 0x1C # StepPhase

class HSequence:
    m_Value = 0x0 # int32_t

class HitReactFixedSettings_t:
    m_nWeightListIndex = 0x0 # int32_t
    m_nEffectedBoneCount = 0x4 # int32_t
    m_flMaxImpactForce = 0x8 # float
    m_flMinImpactForce = 0xC # float
    m_flWhipImpactScale = 0x10 # float
    m_flCounterRotationScale = 0x14 # float
    m_flDistanceFadeScale = 0x18 # float
    m_flPropagationScale = 0x1C # float
    m_flWhipDelay = 0x20 # float
    m_flSpringStrength = 0x24 # float
    m_flWhipSpringStrength = 0x28 # float
    m_flMaxAngleRadians = 0x2C # float
    m_nHipBoneIndex = 0x30 # int32_t
    m_flHipBoneTranslationScale = 0x34 # float
    m_flHipDipSpringStrength = 0x38 # float
    m_flHipDipImpactScale = 0x3C # float
    m_flHipDipDelay = 0x40 # float

class IKBoneNameAndIndex_t:
    m_Name = 0x0 # CUtlString

class IKDemoCaptureSettings_t:
    m_parentBoneName = 0x0 # CUtlString
    m_eMode = 0x8 # IKChannelMode
    m_ikChainName = 0x10 # CUtlString
    m_oneBoneStart = 0x18 # CUtlString
    m_oneBoneEnd = 0x20 # CUtlString

class IKSolverSettings_t:
    m_SolverType = 0x0 # IKSolverType
    m_nNumIterations = 0x4 # int32_t

class IKTargetSettings_t:
    m_TargetSource = 0x0 # IKTargetSource
    m_Bone = 0x8 # IKBoneNameAndIndex_t
    m_AnimgraphParameterNamePosition = 0x18 # AnimParamID
    m_AnimgraphParameterNameOrientation = 0x1C # AnimParamID
    m_TargetCoordSystem = 0x20 # IKTargetCoordinateSystem

class JiggleBoneSettingsList_t:
    m_boneSettings = 0x0 # CUtlVector<JiggleBoneSettings_t>

class JiggleBoneSettings_t:
    m_nBoneIndex = 0x0 # int32_t
    m_flSpringStrength = 0x4 # float
    m_flMaxTimeStep = 0x8 # float
    m_flDamping = 0xC # float
    m_vBoundsMaxLS = 0x10 # Vector
    m_vBoundsMinLS = 0x1C # Vector
    m_eSimSpace = 0x28 # JiggleBoneSimSpace

class LookAtBone_t:
    m_index = 0x0 # int32_t
    m_weight = 0x4 # float

class LookAtOpFixedSettings_t:
    m_attachment = 0x0 # CAnimAttachment
    m_damping = 0x80 # CAnimInputDamping
    m_bones = 0x90 # CUtlVector<LookAtBone_t>
    m_flYawLimit = 0xA8 # float
    m_flPitchLimit = 0xAC # float
    m_flHysteresisInnerAngle = 0xB0 # float
    m_flHysteresisOuterAngle = 0xB4 # float
    m_bRotateYawForward = 0xB8 # bool
    m_bMaintainUpDirection = 0xB9 # bool
    m_bTargetIsPosition = 0xBA # bool
    m_bUseHysteresis = 0xBB # bool

class MaterialGroup_t:
    m_name = 0x0 # CUtlString
    m_materials = 0x8 # CUtlVector<CStrongHandle<InfoForResourceTypeIMaterial2>>

class ModelBoneFlexDriverControl_t:
    m_nBoneComponent = 0x0 # ModelBoneFlexComponent_t
    m_flexController = 0x8 # CUtlString
    m_flexControllerToken = 0x10 # uint32_t
    m_flMin = 0x14 # float
    m_flMax = 0x18 # float

class ModelBoneFlexDriver_t:
    m_boneName = 0x0 # CUtlString
    m_boneNameToken = 0x8 # uint32_t
    m_controls = 0x10 # CUtlVector<ModelBoneFlexDriverControl_t>

class ModelSkeletonData_t:
    m_boneName = 0x0 # CUtlVector<CUtlString>
    m_nParent = 0x18 # CUtlVector<int16_t>
    m_boneSphere = 0x30 # CUtlVector<float>
    m_nFlag = 0x48 # CUtlVector<uint32_t>
    m_bonePosParent = 0x60 # CUtlVector<Vector>
    m_boneRotParent = 0x78 # CUtlVector<QuaternionStorage>
    m_boneScaleParent = 0x90 # CUtlVector<float>

class MoodAnimationLayer_t:
    m_sName = 0x0 # CUtlString
    m_bActiveListening = 0x8 # bool
    m_bActiveTalking = 0x9 # bool
    m_layerAnimations = 0x10 # CUtlVector<MoodAnimation_t>
    m_flIntensity = 0x28 # CRangeFloat
    m_flDurationScale = 0x30 # CRangeFloat
    m_bScaleWithInts = 0x38 # bool
    m_flNextStart = 0x3C # CRangeFloat
    m_flStartOffset = 0x44 # CRangeFloat
    m_flEndOffset = 0x4C # CRangeFloat
    m_flFadeIn = 0x54 # float
    m_flFadeOut = 0x58 # float

class MoodAnimation_t:
    m_sName = 0x0 # CUtlString
    m_flWeight = 0x8 # float

class MotionBlendItem:
    m_pChild = 0x0 # CSmartPtr<CMotionNode>
    m_flKeyValue = 0x8 # float

class MotionDBIndex:
    m_nIndex = 0x0 # uint32_t

class MotionIndex:
    m_nGroup = 0x0 # uint16_t
    m_nMotion = 0x2 # uint16_t

class ParamSpanSample_t:
    m_value = 0x0 # CAnimVariant
    m_flCycle = 0x14 # float

class ParamSpan_t:
    m_samples = 0x0 # CUtlVector<ParamSpanSample_t>
    m_hParam = 0x18 # CAnimParamHandle
    m_eParamType = 0x1A # AnimParamType_t
    m_flStartCycle = 0x1C # float
    m_flEndCycle = 0x20 # float

class PermModelDataAnimatedMaterialAttribute_t:
    m_AttributeName = 0x0 # CUtlString
    m_nNumChannels = 0x8 # int32_t

class PermModelData_t:
    m_name = 0x0 # CUtlString
    m_modelInfo = 0x8 # PermModelInfo_t
    m_ExtParts = 0x60 # CUtlVector<PermModelExtPart_t>
    m_refMeshes = 0x78 # CUtlVector<CStrongHandle<InfoForResourceTypeCRenderMesh>>
    m_refMeshGroupMasks = 0x90 # CUtlVector<uint64_t>
    m_refPhysGroupMasks = 0xA8 # CUtlVector<uint64_t>
    m_refLODGroupMasks = 0xC0 # CUtlVector<uint8_t>
    m_lodGroupSwitchDistances = 0xD8 # CUtlVector<float>
    m_refPhysicsData = 0xF0 # CUtlVector<CStrongHandle<InfoForResourceTypeCPhysAggregateData>>
    m_refPhysicsHitboxData = 0x108 # CUtlVector<CStrongHandle<InfoForResourceTypeCPhysAggregateData>>
    m_refAnimGroups = 0x120 # CUtlVector<CStrongHandle<InfoForResourceTypeCAnimationGroup>>
    m_refSequenceGroups = 0x138 # CUtlVector<CStrongHandle<InfoForResourceTypeCSequenceGroupData>>
    m_meshGroups = 0x150 # CUtlVector<CUtlString>
    m_materialGroups = 0x168 # CUtlVector<MaterialGroup_t>
    m_nDefaultMeshGroupMask = 0x180 # uint64_t
    m_modelSkeleton = 0x188 # ModelSkeletonData_t
    m_remappingTable = 0x230 # CUtlVector<int16_t>
    m_remappingTableStarts = 0x248 # CUtlVector<uint16_t>
    m_boneFlexDrivers = 0x260 # CUtlVector<ModelBoneFlexDriver_t>
    m_pModelConfigList = 0x278 # CModelConfigList*
    m_BodyGroupsHiddenInTools = 0x280 # CUtlVector<CUtlString>
    m_refAnimIncludeModels = 0x298 # CUtlVector<CStrongHandle<InfoForResourceTypeCModel>>
    m_AnimatedMaterialAttributes = 0x2B0 # CUtlVector<PermModelDataAnimatedMaterialAttribute_t>

class PermModelExtPart_t:
    m_Transform = 0x0 # CTransform
    m_Name = 0x20 # CUtlString
    m_nParent = 0x28 # int32_t
    m_refModel = 0x30 # CStrongHandle<InfoForResourceTypeCModel>

class PermModelInfo_t:
    m_nFlags = 0x0 # uint32_t
    m_vHullMin = 0x4 # Vector
    m_vHullMax = 0x10 # Vector
    m_vViewMin = 0x1C # Vector
    m_vViewMax = 0x28 # Vector
    m_flMass = 0x34 # float
    m_vEyePosition = 0x38 # Vector
    m_flMaxEyeDeflection = 0x44 # float
    m_sSurfaceProperty = 0x48 # CUtlString
    m_keyValueText = 0x50 # CUtlString

class PhysSoftbodyDesc_t:
    m_ParticleBoneHash = 0x0 # CUtlVector<uint32_t>
    m_Particles = 0x18 # CUtlVector<RnSoftbodyParticle_t>
    m_Springs = 0x30 # CUtlVector<RnSoftbodySpring_t>
    m_Capsules = 0x48 # CUtlVector<RnSoftbodyCapsule_t>
    m_InitPose = 0x60 # CUtlVector<CTransform>
    m_ParticleBoneName = 0x78 # CUtlVector<CUtlString>

class RenderSkeletonBone_t:
    m_boneName = 0x0 # CUtlString
    m_parentName = 0x8 # CUtlString
    m_invBindPose = 0x10 # matrix3x4_t
    m_bbox = 0x40 # SkeletonBoneBounds_t
    m_flSphereRadius = 0x58 # float

class SampleCode:
    m_subCode = 0x0 # uint8_t[8]

class ScriptInfo_t:
    m_code = 0x0 # CUtlString
    m_paramsModified = 0x8 # CUtlVector<CAnimParamHandle>
    m_proxyReadParams = 0x20 # CUtlVector<int32_t>
    m_proxyWriteParams = 0x38 # CUtlVector<int32_t>
    m_eScriptType = 0x50 # AnimScriptType

class SkeletalInputOpFixedSettings_t:
    m_wristBones = 0x0 # CUtlVector<WristBone_t>
    m_fingers = 0x18 # CUtlVector<FingerChain_t>
    m_outerKnuckle1 = 0x30 # int32_t
    m_outerKnuckle2 = 0x34 # int32_t
    m_eHand = 0x38 # AnimVRHand_t
    m_eMotionRange = 0x3C # AnimVRHandMotionRange_t
    m_eTransformSource = 0x40 # AnimVrBoneTransformSource_t
    m_bEnableIK = 0x44 # bool
    m_bEnableCollision = 0x45 # bool

class SkeletonBoneBounds_t:
    m_vecCenter = 0x0 # Vector
    m_vecSize = 0xC # Vector

class SolveIKChainPoseOpFixedSettings_t:
    m_ChainsToSolveData = 0x0 # CUtlVector<ChainToSolveData_t>
    m_bMatchTargetOrientation = 0x18 # bool

class StanceInfo_t:
    m_vPosition = 0x0 # Vector
    m_flDirection = 0xC # float

class TagSpan_t:
    m_tagIndex = 0x0 # int32_t
    m_startCycle = 0x4 # float
    m_endCycle = 0x8 # float

class TraceSettings_t:
    m_flTraceHeight = 0x0 # float
    m_flTraceRadius = 0x4 # float

class TwoBoneIKSettings_t:
    m_endEffectorType = 0x0 # IkEndEffectorType
    m_endEffectorAttachment = 0x10 # CAnimAttachment
    m_targetType = 0x90 # IkTargetType
    m_targetAttachment = 0xA0 # CAnimAttachment
    m_targetBoneIndex = 0x120 # int32_t
    m_hPositionParam = 0x124 # CAnimParamHandle
    m_hRotationParam = 0x126 # CAnimParamHandle
    m_bAlwaysUseFallbackHinge = 0x128 # bool
    m_vLsFallbackHingeAxis = 0x130 # VectorAligned
    m_nFixedBoneIndex = 0x140 # int32_t
    m_nMiddleBoneIndex = 0x144 # int32_t
    m_nEndBoneIndex = 0x148 # int32_t
    m_bMatchTargetOrientation = 0x14C # bool
    m_bConstrainTwist = 0x14D # bool
    m_flMaxTwist = 0x150 # float

class VPhysXAggregateData_t:
    m_nFlags = 0x0 # uint16_t
    m_nRefCounter = 0x2 # uint16_t
    m_bonesHash = 0x8 # CUtlVector<uint32_t>
    m_boneNames = 0x20 # CUtlVector<CUtlString>
    m_indexNames = 0x38 # CUtlVector<uint16_t>
    m_indexHash = 0x50 # CUtlVector<uint16_t>
    m_bindPose = 0x68 # CUtlVector<matrix3x4a_t>
    m_parts = 0x80 # CUtlVector<VPhysXBodyPart_t>
    m_constraints2 = 0x98 # CUtlVector<VPhysXConstraint2_t>
    m_joints = 0xB0 # CUtlVector<VPhysXJoint_t>
    m_pFeModel = 0xC8 # PhysFeModelDesc_t*
    m_boneParents = 0xD0 # CUtlVector<uint16_t>
    m_surfacePropertyHashes = 0xE8 # CUtlVector<uint32_t>
    m_collisionAttributes = 0x100 # CUtlVector<VPhysXCollisionAttributes_t>
    m_debugPartNames = 0x118 # CUtlVector<CUtlString>
    m_embeddedKeyvalues = 0x130 # CUtlString

class VPhysXBodyPart_t:
    m_nFlags = 0x0 # uint32_t
    m_flMass = 0x4 # float
    m_rnShape = 0x8 # VPhysics2ShapeDef_t
    m_nCollisionAttributeIndex = 0x80 # uint16_t
    m_nReserved = 0x82 # uint16_t
    m_flInertiaScale = 0x84 # float
    m_flLinearDamping = 0x88 # float
    m_flAngularDamping = 0x8C # float
    m_bOverrideMassCenter = 0x90 # bool
    m_vMassCenterOverride = 0x94 # Vector

class VPhysXCollisionAttributes_t:
    m_CollisionGroup = 0x0 # uint32_t
    m_InteractAs = 0x8 # CUtlVector<uint32_t>
    m_InteractWith = 0x20 # CUtlVector<uint32_t>
    m_InteractExclude = 0x38 # CUtlVector<uint32_t>
    m_CollisionGroupString = 0x50 # CUtlString
    m_InteractAsStrings = 0x58 # CUtlVector<CUtlString>
    m_InteractWithStrings = 0x70 # CUtlVector<CUtlString>
    m_InteractExcludeStrings = 0x88 # CUtlVector<CUtlString>

class VPhysXConstraint2_t:
    m_nFlags = 0x0 # uint32_t
    m_nParent = 0x4 # uint16_t
    m_nChild = 0x6 # uint16_t
    m_params = 0x8 # VPhysXConstraintParams_t

class VPhysXConstraintParams_t:
    m_nType = 0x0 # int8_t
    m_nTranslateMotion = 0x1 # int8_t
    m_nRotateMotion = 0x2 # int8_t
    m_nFlags = 0x3 # int8_t
    m_anchor = 0x4 # Vector[2]
    m_axes = 0x1C # QuaternionStorage[2]
    m_maxForce = 0x3C # float
    m_maxTorque = 0x40 # float
    m_linearLimitValue = 0x44 # float
    m_linearLimitRestitution = 0x48 # float
    m_linearLimitSpring = 0x4C # float
    m_linearLimitDamping = 0x50 # float
    m_twistLowLimitValue = 0x54 # float
    m_twistLowLimitRestitution = 0x58 # float
    m_twistLowLimitSpring = 0x5C # float
    m_twistLowLimitDamping = 0x60 # float
    m_twistHighLimitValue = 0x64 # float
    m_twistHighLimitRestitution = 0x68 # float
    m_twistHighLimitSpring = 0x6C # float
    m_twistHighLimitDamping = 0x70 # float
    m_swing1LimitValue = 0x74 # float
    m_swing1LimitRestitution = 0x78 # float
    m_swing1LimitSpring = 0x7C # float
    m_swing1LimitDamping = 0x80 # float
    m_swing2LimitValue = 0x84 # float
    m_swing2LimitRestitution = 0x88 # float
    m_swing2LimitSpring = 0x8C # float
    m_swing2LimitDamping = 0x90 # float
    m_goalPosition = 0x94 # Vector
    m_goalOrientation = 0xA0 # QuaternionStorage
    m_goalAngularVelocity = 0xB0 # Vector
    m_driveSpringX = 0xBC # float
    m_driveSpringY = 0xC0 # float
    m_driveSpringZ = 0xC4 # float
    m_driveDampingX = 0xC8 # float
    m_driveDampingY = 0xCC # float
    m_driveDampingZ = 0xD0 # float
    m_driveSpringTwist = 0xD4 # float
    m_driveSpringSwing = 0xD8 # float
    m_driveSpringSlerp = 0xDC # float
    m_driveDampingTwist = 0xE0 # float
    m_driveDampingSwing = 0xE4 # float
    m_driveDampingSlerp = 0xE8 # float
    m_solverIterationCount = 0xEC # int32_t
    m_projectionLinearTolerance = 0xF0 # float
    m_projectionAngularTolerance = 0xF4 # float

class VPhysXJoint_t:
    m_nType = 0x0 # uint16_t
    m_nBody1 = 0x2 # uint16_t
    m_nBody2 = 0x4 # uint16_t
    m_nFlags = 0x6 # uint16_t
    m_Frame1 = 0x10 # CTransform
    m_Frame2 = 0x30 # CTransform
    m_bEnableCollision = 0x50 # bool
    m_bEnableLinearLimit = 0x51 # bool
    m_LinearLimit = 0x54 # VPhysXRange_t
    m_bEnableLinearMotor = 0x5C # bool
    m_vLinearTargetVelocity = 0x60 # Vector
    m_flMaxForce = 0x6C # float
    m_bEnableSwingLimit = 0x70 # bool
    m_SwingLimit = 0x74 # VPhysXRange_t
    m_bEnableTwistLimit = 0x7C # bool
    m_TwistLimit = 0x80 # VPhysXRange_t
    m_bEnableAngularMotor = 0x88 # bool
    m_vAngularTargetVelocity = 0x8C # Vector
    m_flMaxTorque = 0x98 # float
    m_flLinearFrequency = 0x9C # float
    m_flLinearDampingRatio = 0xA0 # float
    m_flAngularFrequency = 0xA4 # float
    m_flAngularDampingRatio = 0xA8 # float
    m_flFriction = 0xAC # float

class VPhysXRange_t:
    m_flMin = 0x0 # float
    m_flMax = 0x4 # float

class VPhysics2ShapeDef_t:
    m_spheres = 0x0 # CUtlVector<RnSphereDesc_t>
    m_capsules = 0x18 # CUtlVector<RnCapsuleDesc_t>
    m_hulls = 0x30 # CUtlVector<RnHullDesc_t>
    m_meshes = 0x48 # CUtlVector<RnMeshDesc_t>
    m_CollisionAttributeIndices = 0x60 # CUtlVector<uint16_t>

class WeightList:
    m_name = 0x0 # CUtlString
    m_weights = 0x8 # CUtlVector<float>

class WristBone_t:
    m_xOffsetTransformMS = 0x0 # CTransform
    m_boneIndex = 0x20 # int32_t

```

`SDK/animationsystem.dll.rs`:

```rs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.415809900 UTC
 */

#![allow(non_snake_case, non_upper_case_globals)]

pub mod AimMatrixOpFixedSettings_t {
    pub const m_attachment: usize = 0x0; // CAnimAttachment
    pub const m_damping: usize = 0x80; // CAnimInputDamping
    pub const m_poseCacheHandles: usize = 0x90; // CPoseHandle[10]
    pub const m_eBlendMode: usize = 0xB8; // AimMatrixBlendMode
    pub const m_fAngleIncrement: usize = 0xBC; // float
    pub const m_nSequenceMaxFrame: usize = 0xC0; // int32_t
    pub const m_nBoneMaskIndex: usize = 0xC4; // int32_t
    pub const m_bTargetIsPosition: usize = 0xC8; // bool
}

pub mod AnimComponentID {
    pub const m_id: usize = 0x0; // uint32_t
}

pub mod AnimNodeID {
    pub const m_id: usize = 0x0; // uint32_t
}

pub mod AnimNodeOutputID {
    pub const m_id: usize = 0x0; // uint32_t
}

pub mod AnimParamID {
    pub const m_id: usize = 0x0; // uint32_t
}

pub mod AnimScriptHandle {
    pub const m_id: usize = 0x0; // uint32_t
}

pub mod AnimStateID {
    pub const m_id: usize = 0x0; // uint32_t
}

pub mod AnimTagID {
    pub const m_id: usize = 0x0; // uint32_t
}

pub mod AnimationDecodeDebugDumpElement_t {
    pub const m_nEntityIndex: usize = 0x0; // int32_t
    pub const m_modelName: usize = 0x8; // CUtlString
    pub const m_poseParams: usize = 0x10; // CUtlVector<CUtlString>
    pub const m_decodeOps: usize = 0x28; // CUtlVector<CUtlString>
    pub const m_internalOps: usize = 0x40; // CUtlVector<CUtlString>
    pub const m_decodedAnims: usize = 0x58; // CUtlVector<CUtlString>
}

pub mod AnimationDecodeDebugDump_t {
    pub const m_processingType: usize = 0x0; // AnimationProcessingType_t
    pub const m_elems: usize = 0x8; // CUtlVector<AnimationDecodeDebugDumpElement_t>
}

pub mod AnimationSnapshotBase_t {
    pub const m_flRealTime: usize = 0x0; // float
    pub const m_rootToWorld: usize = 0x10; // matrix3x4a_t
    pub const m_bBonesInWorldSpace: usize = 0x40; // bool
    pub const m_boneSetupMask: usize = 0x48; // CUtlVector<uint32_t>
    pub const m_boneTransforms: usize = 0x60; // CUtlVector<matrix3x4a_t>
    pub const m_flexControllers: usize = 0x78; // CUtlVector<float>
    pub const m_SnapshotType: usize = 0x90; // AnimationSnapshotType_t
    pub const m_bHasDecodeDump: usize = 0x94; // bool
    pub const m_DecodeDump: usize = 0x98; // AnimationDecodeDebugDumpElement_t
}

pub mod AnimationSnapshot_t {
    pub const m_nEntIndex: usize = 0x110; // int32_t
    pub const m_modelName: usize = 0x118; // CUtlString
}

pub mod AttachmentHandle_t {
    pub const m_Value: usize = 0x0; // uint8_t
}

pub mod BlendItem_t {
    pub const m_tags: usize = 0x0; // CUtlVector<TagSpan_t>
    pub const m_pChild: usize = 0x18; // CAnimUpdateNodeRef
    pub const m_hSequence: usize = 0x28; // HSequence
    pub const m_vPos: usize = 0x2C; // Vector2D
    pub const m_flDuration: usize = 0x34; // float
    pub const m_bUseCustomDuration: usize = 0x38; // bool
}

pub mod BoneDemoCaptureSettings_t {
    pub const m_boneName: usize = 0x0; // CUtlString
    pub const m_flChainLength: usize = 0x8; // float
}

pub mod CActionComponentUpdater {
    pub const m_actions: usize = 0x30; // CUtlVector<CSmartPtr<CAnimActionUpdater>>
}

pub mod CAddUpdateNode {
    pub const m_footMotionTiming: usize = 0x8C; // BinaryNodeChildOption
    pub const m_bApplyToFootMotion: usize = 0x90; // bool
    pub const m_bApplyChannelsSeparately: usize = 0x91; // bool
    pub const m_bUseModelSpace: usize = 0x92; // bool
}

pub mod CAimConstraint {
    pub const m_qAimOffset: usize = 0x70; // Quaternion
    pub const m_nUpType: usize = 0x80; // uint32_t
}

pub mod CAimMatrixUpdateNode {
    pub const m_opFixedSettings: usize = 0x70; // AimMatrixOpFixedSettings_t
    pub const m_target: usize = 0x148; // AnimVectorSource
    pub const m_paramIndex: usize = 0x14C; // CAnimParamHandle
    pub const m_hSequence: usize = 0x150; // HSequence
    pub const m_bResetChild: usize = 0x154; // bool
    pub const m_bLockWhenWaning: usize = 0x155; // bool
}

pub mod CAnimActivity {
    pub const m_name: usize = 0x0; // CBufferString
    pub const m_nActivity: usize = 0x10; // int32_t
    pub const m_nFlags: usize = 0x14; // int32_t
    pub const m_nWeight: usize = 0x18; // int32_t
}

pub mod CAnimAttachment {
    pub const m_influenceRotations: usize = 0x0; // Quaternion[3]
    pub const m_influenceOffsets: usize = 0x30; // VectorAligned[3]
    pub const m_influenceIndices: usize = 0x60; // int32_t[3]
    pub const m_influenceWeights: usize = 0x6C; // float[3]
    pub const m_numInfluences: usize = 0x78; // uint8_t
}

pub mod CAnimBone {
    pub const m_name: usize = 0x0; // CBufferString
    pub const m_parent: usize = 0x10; // int32_t
    pub const m_pos: usize = 0x14; // Vector
    pub const m_quat: usize = 0x20; // QuaternionStorage
    pub const m_scale: usize = 0x30; // float
    pub const m_qAlignment: usize = 0x34; // QuaternionStorage
    pub const m_flags: usize = 0x44; // int32_t
}

pub mod CAnimBoneDifference {
    pub const m_name: usize = 0x0; // CBufferString
    pub const m_parent: usize = 0x10; // CBufferString
    pub const m_posError: usize = 0x20; // Vector
    pub const m_bHasRotation: usize = 0x2C; // bool
    pub const m_bHasMovement: usize = 0x2D; // bool
}

pub mod CAnimComponentUpdater {
    pub const m_name: usize = 0x18; // CUtlString
    pub const m_id: usize = 0x20; // AnimComponentID
    pub const m_networkMode: usize = 0x24; // AnimNodeNetworkMode
    pub const m_bStartEnabled: usize = 0x28; // bool
}

pub mod CAnimData {
    pub const m_name: usize = 0x10; // CBufferString
    pub const m_animArray: usize = 0x20; // CUtlVector<CAnimDesc>
    pub const m_decoderArray: usize = 0x38; // CUtlVector<CAnimDecoder>
    pub const m_nMaxUniqueFrameIndex: usize = 0x50; // int32_t
    pub const m_segmentArray: usize = 0x58; // CUtlVector<CAnimFrameSegment>
}

pub mod CAnimDataChannelDesc {
    pub const m_szChannelClass: usize = 0x0; // CBufferString
    pub const m_szVariableName: usize = 0x10; // CBufferString
    pub const m_nFlags: usize = 0x20; // int32_t
    pub const m_nType: usize = 0x24; // int32_t
    pub const m_szGrouping: usize = 0x28; // CBufferString
    pub const m_szDescription: usize = 0x38; // CBufferString
    pub const m_szElementNameArray: usize = 0x48; // CUtlVector<CBufferString>
    pub const m_nElementIndexArray: usize = 0x60; // CUtlVector<int32_t>
    pub const m_nElementMaskArray: usize = 0x78; // CUtlVector<uint32_t>
}

pub mod CAnimDecoder {
    pub const m_szName: usize = 0x0; // CBufferString
    pub const m_nVersion: usize = 0x10; // int32_t
    pub const m_nType: usize = 0x14; // int32_t
}

pub mod CAnimDemoCaptureSettings {
    pub const m_rangeBoneChainLength: usize = 0x0; // Vector2D
    pub const m_rangeMaxSplineErrorRotation: usize = 0x8; // Vector2D
    pub const m_flMaxSplineErrorTranslation: usize = 0x10; // float
    pub const m_flMaxSplineErrorScale: usize = 0x14; // float
    pub const m_flIkRotation_MaxSplineError: usize = 0x18; // float
    pub const m_flIkTranslation_MaxSplineError: usize = 0x1C; // float
    pub const m_flMaxQuantizationErrorRotation: usize = 0x20; // float
    pub const m_flMaxQuantizationErrorTranslation: usize = 0x24; // float
    pub const m_flMaxQuantizationErrorScale: usize = 0x28; // float
    pub const m_flIkRotation_MaxQuantizationError: usize = 0x2C; // float
    pub const m_flIkTranslation_MaxQuantizationError: usize = 0x30; // float
    pub const m_baseSequence: usize = 0x38; // CUtlString
    pub const m_nBaseSequenceFrame: usize = 0x40; // int32_t
    pub const m_boneSelectionMode: usize = 0x44; // EDemoBoneSelectionMode
    pub const m_bones: usize = 0x48; // CUtlVector<BoneDemoCaptureSettings_t>
    pub const m_ikChains: usize = 0x60; // CUtlVector<IKDemoCaptureSettings_t>
}

pub mod CAnimDesc {
    pub const m_name: usize = 0x0; // CBufferString
    pub const m_flags: usize = 0x10; // CAnimDesc_Flag
    pub const fps: usize = 0x18; // float
    pub const m_Data: usize = 0x20; // CAnimEncodedFrames
    pub const m_movementArray: usize = 0xF8; // CUtlVector<CAnimMovement>
    pub const m_eventArray: usize = 0x110; // CUtlVector<CAnimEventDefinition>
    pub const m_activityArray: usize = 0x128; // CUtlVector<CAnimActivity>
    pub const m_hierarchyArray: usize = 0x140; // CUtlVector<CAnimLocalHierarchy>
    pub const framestalltime: usize = 0x158; // float
    pub const m_vecRootMin: usize = 0x15C; // Vector
    pub const m_vecRootMax: usize = 0x168; // Vector
    pub const m_vecBoneWorldMin: usize = 0x178; // CUtlVector<Vector>
    pub const m_vecBoneWorldMax: usize = 0x190; // CUtlVector<Vector>
    pub const m_sequenceParams: usize = 0x1A8; // CAnimSequenceParams
}

pub mod CAnimDesc_Flag {
    pub const m_bLooping: usize = 0x0; // bool
    pub const m_bAllZeros: usize = 0x1; // bool
    pub const m_bHidden: usize = 0x2; // bool
    pub const m_bDelta: usize = 0x3; // bool
    pub const m_bLegacyWorldspace: usize = 0x4; // bool
    pub const m_bModelDoc: usize = 0x5; // bool
    pub const m_bImplicitSeqIgnoreDelta: usize = 0x6; // bool
    pub const m_bAnimGraphAdditive: usize = 0x7; // bool
}

pub mod CAnimEncodeDifference {
    pub const m_boneArray: usize = 0x0; // CUtlVector<CAnimBoneDifference>
    pub const m_morphArray: usize = 0x18; // CUtlVector<CAnimMorphDifference>
    pub const m_userArray: usize = 0x30; // CUtlVector<CAnimUserDifference>
    pub const m_bHasRotationBitArray: usize = 0x48; // CUtlVector<uint8_t>
    pub const m_bHasMovementBitArray: usize = 0x60; // CUtlVector<uint8_t>
    pub const m_bHasMorphBitArray: usize = 0x78; // CUtlVector<uint8_t>
    pub const m_bHasUserBitArray: usize = 0x90; // CUtlVector<uint8_t>
}

pub mod CAnimEncodedFrames {
    pub const m_fileName: usize = 0x0; // CBufferString
    pub const m_nFrames: usize = 0x10; // int32_t
    pub const m_nFramesPerBlock: usize = 0x14; // int32_t
    pub const m_frameblockArray: usize = 0x18; // CUtlVector<CAnimFrameBlockAnim>
    pub const m_usageDifferences: usize = 0x30; // CAnimEncodeDifference
}

pub mod CAnimEnum {
    pub const m_value: usize = 0x0; // uint8_t
}

pub mod CAnimEventDefinition {
    pub const m_nFrame: usize = 0x8; // int32_t
    pub const m_flCycle: usize = 0xC; // float
    pub const m_EventData: usize = 0x10; // KeyValues3
    pub const m_sLegacyOptions: usize = 0x20; // CBufferString
    pub const m_sEventName: usize = 0x30; // CGlobalSymbol
}

pub mod CAnimFoot {
    pub const m_name: usize = 0x0; // CUtlString
    pub const m_vBallOffset: usize = 0x8; // Vector
    pub const m_vHeelOffset: usize = 0x14; // Vector
    pub const m_ankleBoneIndex: usize = 0x20; // int32_t
    pub const m_toeBoneIndex: usize = 0x24; // int32_t
}

pub mod CAnimFrameBlockAnim {
    pub const m_nStartFrame: usize = 0x0; // int32_t
    pub const m_nEndFrame: usize = 0x4; // int32_t
    pub const m_segmentIndexArray: usize = 0x8; // CUtlVector<int32_t>
}

pub mod CAnimFrameSegment {
    pub const m_nUniqueFrameIndex: usize = 0x0; // int32_t
    pub const m_nLocalElementMasks: usize = 0x4; // uint32_t
    pub const m_nLocalChannel: usize = 0x8; // int32_t
    pub const m_container: usize = 0x10; // CUtlBinaryBlock
}

pub mod CAnimGraphDebugReplay {
    pub const m_animGraphFileName: usize = 0x40; // CUtlString
    pub const m_frameList: usize = 0x48; // CUtlVector<CSmartPtr<CAnimReplayFrame>>
    pub const m_startIndex: usize = 0x60; // int32_t
    pub const m_writeIndex: usize = 0x64; // int32_t
    pub const m_frameCount: usize = 0x68; // int32_t
}

pub mod CAnimGraphModelBinding {
    pub const m_modelName: usize = 0x8; // CUtlString
    pub const m_pSharedData: usize = 0x10; // CSmartPtr<CAnimUpdateSharedData>
}

pub mod CAnimGraphNetworkSettings {
    pub const m_bNetworkingEnabled: usize = 0x20; // bool
}

pub mod CAnimGraphSettingsManager {
    pub const m_settingsGroups: usize = 0x18; // CUtlVector<CSmartPtr<CAnimGraphSettingsGroup>>
}

pub mod CAnimInputDamping {
    pub const m_speedFunction: usize = 0x8; // DampingSpeedFunction
    pub const m_fSpeedScale: usize = 0xC; // float
}

pub mod CAnimKeyData {
    pub const m_name: usize = 0x0; // CBufferString
    pub const m_boneArray: usize = 0x10; // CUtlVector<CAnimBone>
    pub const m_userArray: usize = 0x28; // CUtlVector<CAnimUser>
    pub const m_morphArray: usize = 0x40; // CUtlVector<CBufferString>
    pub const m_nChannelElements: usize = 0x58; // int32_t
    pub const m_dataChannelArray: usize = 0x60; // CUtlVector<CAnimDataChannelDesc>
}

pub mod CAnimLocalHierarchy {
    pub const m_sBone: usize = 0x0; // CBufferString
    pub const m_sNewParent: usize = 0x10; // CBufferString
    pub const m_nStartFrame: usize = 0x20; // int32_t
    pub const m_nPeakFrame: usize = 0x24; // int32_t
    pub const m_nTailFrame: usize = 0x28; // int32_t
    pub const m_nEndFrame: usize = 0x2C; // int32_t
}

pub mod CAnimMorphDifference {
    pub const m_name: usize = 0x0; // CBufferString
}

pub mod CAnimMotorUpdaterBase {
    pub const m_name: usize = 0x10; // CUtlString
    pub const m_bDefault: usize = 0x18; // bool
}

pub mod CAnimMovement {
    pub const endframe: usize = 0x0; // int32_t
    pub const motionflags: usize = 0x4; // int32_t
    pub const v0: usize = 0x8; // float
    pub const v1: usize = 0xC; // float
    pub const angle: usize = 0x10; // float
    pub const vector: usize = 0x14; // Vector
    pub const position: usize = 0x20; // Vector
}

pub mod CAnimNodePath {
    pub const m_path: usize = 0x0; // AnimNodeID[11]
    pub const m_nCount: usize = 0x2C; // int32_t
}

pub mod CAnimParamHandle {
    pub const m_type: usize = 0x0; // AnimParamType_t
    pub const m_index: usize = 0x1; // uint8_t
}

pub mod CAnimParamHandleMap {
    pub const m_list: usize = 0x0; // CUtlHashtable<uint16_t,int16_t>
}

pub mod CAnimParameterBase {
    pub const m_name: usize = 0x18; // CGlobalSymbol
    pub const m_group: usize = 0x20; // CUtlString
    pub const m_id: usize = 0x28; // AnimParamID
    pub const m_componentName: usize = 0x40; // CUtlString
    pub const m_bNetworkingRequested: usize = 0x4C; // bool
    pub const m_bIsReferenced: usize = 0x4D; // bool
}

pub mod CAnimParameterManagerUpdater {
    pub const m_parameters: usize = 0x18; // CUtlVector<CSmartPtr<CAnimParameterBase>>
    pub const m_idToIndexMap: usize = 0x30; // CUtlHashtable<AnimParamID,int32_t>
    pub const m_nameToIndexMap: usize = 0x50; // CUtlHashtable<CUtlString,int32_t>
    pub const m_indexToHandle: usize = 0x70; // CUtlVector<CAnimParamHandle>
    pub const m_autoResetParams: usize = 0x88; // CUtlVector<CUtlPair<CAnimParamHandle,CAnimVariant>>
    pub const m_autoResetMap: usize = 0xA0; // CUtlHashtable<CAnimParamHandle,int16_t>
}

pub mod CAnimReplayFrame {
    pub const m_inputDataBlocks: usize = 0x10; // CUtlVector<CUtlBinaryBlock>
    pub const m_instanceData: usize = 0x28; // CUtlBinaryBlock
    pub const m_startingLocalToWorldTransform: usize = 0x40; // CTransform
    pub const m_localToWorldTransform: usize = 0x60; // CTransform
    pub const m_timeStamp: usize = 0x80; // float
}

pub mod CAnimScriptComponentUpdater {
    pub const m_hScript: usize = 0x30; // AnimScriptHandle
}

pub mod CAnimScriptManager {
    pub const m_scriptInfo: usize = 0x10; // CUtlVector<ScriptInfo_t>
}

pub mod CAnimSequenceParams {
    pub const m_flFadeInTime: usize = 0x0; // float
    pub const m_flFadeOutTime: usize = 0x4; // float
}

pub mod CAnimSkeleton {
    pub const m_localSpaceTransforms: usize = 0x10; // CUtlVector<CTransform>
    pub const m_modelSpaceTransforms: usize = 0x28; // CUtlVector<CTransform>
    pub const m_boneNames: usize = 0x40; // CUtlVector<CUtlString>
    pub const m_children: usize = 0x58; // CUtlVector<CUtlVector<int32_t>>
    pub const m_parents: usize = 0x70; // CUtlVector<int32_t>
    pub const m_feet: usize = 0x88; // CUtlVector<CAnimFoot>
    pub const m_morphNames: usize = 0xA0; // CUtlVector<CUtlString>
    pub const m_lodBoneCounts: usize = 0xB8; // CUtlVector<int32_t>
}

pub mod CAnimStateMachineUpdater {
    pub const m_states: usize = 0x8; // CUtlVector<CStateUpdateData>
    pub const m_transitions: usize = 0x20; // CUtlVector<CTransitionUpdateData>
    pub const m_startStateIndex: usize = 0x50; // int32_t
}

pub mod CAnimTagBase {
    pub const m_name: usize = 0x18; // CGlobalSymbol
    pub const m_group: usize = 0x20; // CGlobalSymbol
    pub const m_tagID: usize = 0x28; // AnimTagID
    pub const m_bIsReferenced: usize = 0x2C; // bool
}

pub mod CAnimTagManagerUpdater {
    pub const m_tags: usize = 0x18; // CUtlVector<CSmartPtr<CAnimTagBase>>
}

pub mod CAnimUpdateNodeBase {
    pub const m_nodePath: usize = 0x18; // CAnimNodePath
    pub const m_networkMode: usize = 0x48; // AnimNodeNetworkMode
    pub const m_name: usize = 0x50; // CUtlString
}

pub mod CAnimUpdateNodeRef {
    pub const m_nodeIndex: usize = 0x8; // int32_t
}

pub mod CAnimUpdateSharedData {
    pub const m_nodes: usize = 0x10; // CUtlVector<CSmartPtr<CAnimUpdateNodeBase>>
    pub const m_nodeIndexMap: usize = 0x28; // CUtlHashtable<CAnimNodePath,int32_t>
    pub const m_components: usize = 0x48; // CUtlVector<CSmartPtr<CAnimComponentUpdater>>
    pub const m_pParamListUpdater: usize = 0x60; // CSmartPtr<CAnimParameterManagerUpdater>
    pub const m_pTagManagerUpdater: usize = 0x68; // CSmartPtr<CAnimTagManagerUpdater>
    pub const m_scriptManager: usize = 0x70; // CSmartPtr<CAnimScriptManager>
    pub const m_settings: usize = 0x78; // CAnimGraphSettingsManager
    pub const m_pStaticPoseCache: usize = 0xA8; // CSmartPtr<CStaticPoseCacheBuilder>
    pub const m_pSkeleton: usize = 0xB0; // CSmartPtr<CAnimSkeleton>
    pub const m_rootNodePath: usize = 0xB8; // CAnimNodePath
}

pub mod CAnimUser {
    pub const m_name: usize = 0x0; // CBufferString
    pub const m_nType: usize = 0x10; // int32_t
}

pub mod CAnimUserDifference {
    pub const m_name: usize = 0x0; // CBufferString
    pub const m_nType: usize = 0x10; // int32_t
}

pub mod CAnimationGraphVisualizerAxis {
    pub const m_xWsTransform: usize = 0x40; // CTransform
    pub const m_flAxisSize: usize = 0x60; // float
}

pub mod CAnimationGraphVisualizerLine {
    pub const m_vWsPositionStart: usize = 0x40; // VectorAligned
    pub const m_vWsPositionEnd: usize = 0x50; // VectorAligned
    pub const m_Color: usize = 0x60; // Color
}

pub mod CAnimationGraphVisualizerPie {
    pub const m_vWsCenter: usize = 0x40; // VectorAligned
    pub const m_vWsStart: usize = 0x50; // VectorAligned
    pub const m_vWsEnd: usize = 0x60; // VectorAligned
    pub const m_Color: usize = 0x70; // Color
}

pub mod CAnimationGraphVisualizerPrimitiveBase {
    pub const m_Type: usize = 0x8; // CAnimationGraphVisualizerPrimitiveType
    pub const m_OwningAnimNodePaths: usize = 0xC; // AnimNodeID[11]
    pub const m_nOwningAnimNodePathCount: usize = 0x38; // int32_t
}

pub mod CAnimationGraphVisualizerSphere {
    pub const m_vWsPosition: usize = 0x40; // VectorAligned
    pub const m_flRadius: usize = 0x50; // float
    pub const m_Color: usize = 0x54; // Color
}

pub mod CAnimationGraphVisualizerText {
    pub const m_vWsPosition: usize = 0x40; // VectorAligned
    pub const m_Color: usize = 0x50; // Color
    pub const m_Text: usize = 0x58; // CUtlString
}

pub mod CAnimationGroup {
    pub const m_nFlags: usize = 0x10; // uint32_t
    pub const m_name: usize = 0x18; // CBufferString
    pub const m_localHAnimArray_Handle: usize = 0x60; // CUtlVector<CStrongHandle<InfoForResourceTypeCAnimData>>
    pub const m_includedGroupArray_Handle: usize = 0x78; // CUtlVector<CStrongHandle<InfoForResourceTypeCAnimationGroup>>
    pub const m_directHSeqGroup_Handle: usize = 0x90; // CStrongHandle<InfoForResourceTypeCSequenceGroupData>
    pub const m_decodeKey: usize = 0x98; // CAnimKeyData
    pub const m_szScripts: usize = 0x110; // CUtlVector<CBufferString>
}

pub mod CAttachment {
    pub const m_name: usize = 0x0; // CUtlString
    pub const m_influenceNames: usize = 0x8; // CUtlString[3]
    pub const m_vInfluenceRotations: usize = 0x20; // Quaternion[3]
    pub const m_vInfluenceOffsets: usize = 0x50; // Vector[3]
    pub const m_influenceWeights: usize = 0x74; // float[3]
    pub const m_bInfluenceRootTransform: usize = 0x80; // bool[3]
    pub const m_nInfluences: usize = 0x83; // uint8_t
    pub const m_bIgnoreRotation: usize = 0x84; // bool
}

pub mod CAudioAnimTag {
    pub const m_clipName: usize = 0x38; // CUtlString
    pub const m_attachmentName: usize = 0x40; // CUtlString
    pub const m_flVolume: usize = 0x48; // float
    pub const m_bStopWhenTagEnds: usize = 0x4C; // bool
    pub const m_bStopWhenGraphEnds: usize = 0x4D; // bool
    pub const m_bPlayOnServer: usize = 0x4E; // bool
    pub const m_bPlayOnClient: usize = 0x4F; // bool
}

pub mod CBaseConstraint {
    pub const m_name: usize = 0x28; // CUtlString
    pub const m_vUpVector: usize = 0x30; // Vector
    pub const m_slaves: usize = 0x40; // CUtlVector<CConstraintSlave>
    pub const m_targets: usize = 0x58; // CUtlVector<CConstraintTarget>
}

pub mod CBinaryUpdateNode {
    pub const m_pChild1: usize = 0x58; // CAnimUpdateNodeRef
    pub const m_pChild2: usize = 0x68; // CAnimUpdateNodeRef
    pub const m_timingBehavior: usize = 0x78; // BinaryNodeTiming
    pub const m_flTimingBlend: usize = 0x7C; // float
    pub const m_bResetChild1: usize = 0x80; // bool
    pub const m_bResetChild2: usize = 0x81; // bool
}

pub mod CBlend2DUpdateNode {
    pub const m_items: usize = 0x60; // CUtlVector<BlendItem_t>
    pub const m_tags: usize = 0x78; // CUtlVector<TagSpan_t>
    pub const m_paramSpans: usize = 0x90; // CParamSpanUpdater
    pub const m_nodeItemIndices: usize = 0xA8; // CUtlVector<int32_t>
    pub const m_damping: usize = 0xC0; // CAnimInputDamping
    pub const m_blendSourceX: usize = 0xD0; // AnimValueSource
    pub const m_paramX: usize = 0xD4; // CAnimParamHandle
    pub const m_blendSourceY: usize = 0xD8; // AnimValueSource
    pub const m_paramY: usize = 0xDC; // CAnimParamHandle
    pub const m_eBlendMode: usize = 0xE0; // Blend2DMode
    pub const m_playbackSpeed: usize = 0xE4; // float
    pub const m_bLoop: usize = 0xE8; // bool
    pub const m_bLockBlendOnReset: usize = 0xE9; // bool
    pub const m_bLockWhenWaning: usize = 0xEA; // bool
    pub const m_bAnimEventsAndTagsOnMostWeightedOnly: usize = 0xEB; // bool
}

pub mod CBlendCurve {
    pub const m_flControlPoint1: usize = 0x0; // float
    pub const m_flControlPoint2: usize = 0x4; // float
}

pub mod CBlendUpdateNode {
    pub const m_children: usize = 0x60; // CUtlVector<CAnimUpdateNodeRef>
    pub const m_sortedOrder: usize = 0x78; // CUtlVector<uint8_t>
    pub const m_targetValues: usize = 0x90; // CUtlVector<float>
    pub const m_blendValueSource: usize = 0xAC; // AnimValueSource
    pub const m_paramIndex: usize = 0xB0; // CAnimParamHandle
    pub const m_damping: usize = 0xB8; // CAnimInputDamping
    pub const m_blendKeyType: usize = 0xC8; // BlendKeyType
    pub const m_bLockBlendOnReset: usize = 0xCC; // bool
    pub const m_bSyncCycles: usize = 0xCD; // bool
    pub const m_bLoop: usize = 0xCE; // bool
    pub const m_bLockWhenWaning: usize = 0xCF; // bool
}

pub mod CBodyGroupAnimTag {
    pub const m_nPriority: usize = 0x38; // int32_t
    pub const m_bodyGroupSettings: usize = 0x40; // CUtlVector<CBodyGroupSetting>
}

pub mod CBodyGroupSetting {
    pub const m_BodyGroupName: usize = 0x0; // CUtlString
    pub const m_nBodyGroupOption: usize = 0x8; // int32_t
}

pub mod CBoneConstraintDotToMorph {
    pub const m_sBoneName: usize = 0x28; // CUtlString
    pub const m_sTargetBoneName: usize = 0x30; // CUtlString
    pub const m_sMorphChannelName: usize = 0x38; // CUtlString
    pub const m_flRemap: usize = 0x40; // float[4]
}

pub mod CBoneConstraintPoseSpaceBone {
    pub const m_inputList: usize = 0x70; // CUtlVector<CBoneConstraintPoseSpaceBone::Input_t>
}

pub mod CBoneConstraintPoseSpaceBone_Input_t {
    pub const m_inputValue: usize = 0x0; // Vector
    pub const m_outputTransformList: usize = 0x10; // CUtlVector<CTransform>
}

pub mod CBoneConstraintPoseSpaceMorph {
    pub const m_sBoneName: usize = 0x28; // CUtlString
    pub const m_sAttachmentName: usize = 0x30; // CUtlString
    pub const m_outputMorph: usize = 0x38; // CUtlVector<CUtlString>
    pub const m_inputList: usize = 0x50; // CUtlVector<CBoneConstraintPoseSpaceMorph::Input_t>
    pub const m_bClamp: usize = 0x68; // bool
}

pub mod CBoneConstraintPoseSpaceMorph_Input_t {
    pub const m_inputValue: usize = 0x0; // Vector
    pub const m_outputWeightList: usize = 0x10; // CUtlVector<float>
}

pub mod CBoneMaskUpdateNode {
    pub const m_nWeightListIndex: usize = 0x8C; // int32_t
    pub const m_flRootMotionBlend: usize = 0x90; // float
    pub const m_blendSpace: usize = 0x94; // BoneMaskBlendSpace
    pub const m_footMotionTiming: usize = 0x98; // BinaryNodeChildOption
    pub const m_bUseBlendScale: usize = 0x9C; // bool
    pub const m_blendValueSource: usize = 0xA0; // AnimValueSource
    pub const m_hBlendParameter: usize = 0xA4; // CAnimParamHandle
}

pub mod CBonePositionMetricEvaluator {
    pub const m_nBoneIndex: usize = 0x50; // int32_t
}

pub mod CBoneVelocityMetricEvaluator {
    pub const m_nBoneIndex: usize = 0x50; // int32_t
}

pub mod CBoolAnimParameter {
    pub const m_bDefaultValue: usize = 0x60; // bool
}

pub mod CCPPScriptComponentUpdater {
    pub const m_scriptsToRun: usize = 0x30; // CUtlVector<CGlobalSymbol>
}

pub mod CCachedPose {
    pub const m_transforms: usize = 0x8; // CUtlVector<CTransform>
    pub const m_morphWeights: usize = 0x20; // CUtlVector<float>
    pub const m_hSequence: usize = 0x38; // HSequence
    pub const m_flCycle: usize = 0x3C; // float
}

pub mod CChoiceUpdateNode {
    pub const m_children: usize = 0x58; // CUtlVector<CAnimUpdateNodeRef>
    pub const m_weights: usize = 0x70; // CUtlVector<float>
    pub const m_blendTimes: usize = 0x88; // CUtlVector<float>
    pub const m_choiceMethod: usize = 0xA0; // ChoiceMethod
    pub const m_choiceChangeMethod: usize = 0xA4; // ChoiceChangeMethod
    pub const m_blendMethod: usize = 0xA8; // ChoiceBlendMethod
    pub const m_blendTime: usize = 0xAC; // float
    pub const m_bCrossFade: usize = 0xB0; // bool
    pub const m_bResetChosen: usize = 0xB1; // bool
    pub const m_bDontResetSameSelection: usize = 0xB2; // bool
}

pub mod CClothSettingsAnimTag {
    pub const m_flStiffness: usize = 0x38; // float
    pub const m_flEaseIn: usize = 0x3C; // float
    pub const m_flEaseOut: usize = 0x40; // float
    pub const m_nVertexSet: usize = 0x48; // CUtlString
}

pub mod CCompressorGroup {
    pub const m_nTotalElementCount: usize = 0x0; // int32_t
    pub const m_szChannelClass: usize = 0x8; // CUtlVector<char*>
    pub const m_szVariableName: usize = 0x20; // CUtlVector<char*>
    pub const m_nType: usize = 0x38; // CUtlVector<fieldtype_t>
    pub const m_nFlags: usize = 0x50; // CUtlVector<int32_t>
    pub const m_szGrouping: usize = 0x68; // CUtlVector<CUtlString>
    pub const m_nCompressorIndex: usize = 0x80; // CUtlVector<int32_t>
    pub const m_szElementNames: usize = 0x98; // CUtlVector<CUtlVector<char*>>
    pub const m_nElementUniqueID: usize = 0xB0; // CUtlVector<CUtlVector<int32_t>>
    pub const m_nElementMask: usize = 0xC8; // CUtlVector<uint32_t>
    pub const m_vectorCompressor: usize = 0xF8; // CUtlVector<CCompressor<Vector>*>
    pub const m_quaternionCompressor: usize = 0x110; // CUtlVector<CCompressor<QuaternionStorage>*>
    pub const m_intCompressor: usize = 0x128; // CUtlVector<CCompressor<int32_t>*>
    pub const m_boolCompressor: usize = 0x140; // CUtlVector<CCompressor<bool>*>
    pub const m_colorCompressor: usize = 0x158; // CUtlVector<CCompressor<Color>*>
    pub const m_vector2DCompressor: usize = 0x170; // CUtlVector<CCompressor<Vector2D>*>
    pub const m_vector4DCompressor: usize = 0x188; // CUtlVector<CCompressor<Vector4D>*>
}

pub mod CConcreteAnimParameter {
    pub const m_previewButton: usize = 0x50; // AnimParamButton_t
    pub const m_eNetworkSetting: usize = 0x54; // AnimParamNetworkSetting
    pub const m_bUseMostRecentValue: usize = 0x58; // bool
    pub const m_bAutoReset: usize = 0x59; // bool
    pub const m_bGameWritable: usize = 0x5A; // bool
    pub const m_bGraphWritable: usize = 0x5B; // bool
}

pub mod CConstraintSlave {
    pub const m_qBaseOrientation: usize = 0x0; // Quaternion
    pub const m_vBasePosition: usize = 0x10; // Vector
    pub const m_nBoneHash: usize = 0x1C; // uint32_t
    pub const m_flWeight: usize = 0x20; // float
    pub const m_sName: usize = 0x28; // CUtlString
}

pub mod CConstraintTarget {
    pub const m_qOffset: usize = 0x20; // Quaternion
    pub const m_vOffset: usize = 0x30; // Vector
    pub const m_nBoneHash: usize = 0x3C; // uint32_t
    pub const m_sName: usize = 0x40; // CUtlString
    pub const m_flWeight: usize = 0x48; // float
    pub const m_bIsAttachment: usize = 0x59; // bool
}

pub mod CCycleBase {
    pub const m_flCycle: usize = 0x0; // float
}

pub mod CCycleControlClipUpdateNode {
    pub const m_tags: usize = 0x60; // CUtlVector<TagSpan_t>
    pub const m_hSequence: usize = 0x7C; // HSequence
    pub const m_duration: usize = 0x80; // float
    pub const m_valueSource: usize = 0x84; // AnimValueSource
    pub const m_paramIndex: usize = 0x88; // CAnimParamHandle
}

pub mod CCycleControlUpdateNode {
    pub const m_valueSource: usize = 0x68; // AnimValueSource
    pub const m_paramIndex: usize = 0x6C; // CAnimParamHandle
}

pub mod CDampedPathAnimMotorUpdater {
    pub const m_flAnticipationTime: usize = 0x2C; // float
    pub const m_flMinSpeedScale: usize = 0x30; // float
    pub const m_hAnticipationPosParam: usize = 0x34; // CAnimParamHandle
    pub const m_hAnticipationHeadingParam: usize = 0x36; // CAnimParamHandle
    pub const m_flSpringConstant: usize = 0x38; // float
    pub const m_flMinSpringTension: usize = 0x3C; // float
    pub const m_flMaxSpringTension: usize = 0x40; // float
}

pub mod CDampedValueComponentUpdater {
    pub const m_items: usize = 0x30; // CUtlVector<CDampedValueUpdateItem>
}

pub mod CDampedValueUpdateItem {
    pub const m_damping: usize = 0x0; // CAnimInputDamping
    pub const m_hParamIn: usize = 0x18; // CAnimParamHandle
    pub const m_hParamOut: usize = 0x1A; // CAnimParamHandle
}

pub mod CDemoSettingsComponentUpdater {
    pub const m_settings: usize = 0x30; // CAnimDemoCaptureSettings
}

pub mod CDirectPlaybackTagData {
    pub const m_sequenceName: usize = 0x0; // CUtlString
    pub const m_tags: usize = 0x8; // CUtlVector<TagSpan_t>
}

pub mod CDirectPlaybackUpdateNode {
    pub const m_bFinishEarly: usize = 0x6C; // bool
    pub const m_bResetOnFinish: usize = 0x6D; // bool
    pub const m_allTags: usize = 0x70; // CUtlVector<CDirectPlaybackTagData>
}

pub mod CDirectionalBlendUpdateNode {
    pub const m_hSequences: usize = 0x5C; // HSequence[8]
    pub const m_damping: usize = 0x80; // CAnimInputDamping
    pub const m_blendValueSource: usize = 0x90; // AnimValueSource
    pub const m_paramIndex: usize = 0x94; // CAnimParamHandle
    pub const m_playbackSpeed: usize = 0x98; // float
    pub const m_duration: usize = 0x9C; // float
    pub const m_bLoop: usize = 0xA0; // bool
    pub const m_bLockBlendOnReset: usize = 0xA1; // bool
}

pub mod CDistanceRemainingMetricEvaluator {
    pub const m_flMaxDistance: usize = 0x50; // float
    pub const m_flMinDistance: usize = 0x54; // float
    pub const m_flStartGoalFilterDistance: usize = 0x58; // float
    pub const m_flMaxGoalOvershootScale: usize = 0x5C; // float
    pub const m_bFilterFixedMinDistance: usize = 0x60; // bool
    pub const m_bFilterGoalDistance: usize = 0x61; // bool
    pub const m_bFilterGoalOvershoot: usize = 0x62; // bool
}

pub mod CDrawCullingData {
    pub const m_vConeApex: usize = 0x0; // Vector
    pub const m_ConeAxis: usize = 0xC; // int8_t[3]
    pub const m_ConeCutoff: usize = 0xF; // int8_t
}

pub mod CEmitTagActionUpdater {
    pub const m_nTagIndex: usize = 0x18; // int32_t
    pub const m_bIsZeroDuration: usize = 0x1C; // bool
}

pub mod CEnumAnimParameter {
    pub const m_defaultValue: usize = 0x68; // uint8_t
    pub const m_enumOptions: usize = 0x70; // CUtlVector<CUtlString>
}

pub mod CExpressionActionUpdater {
    pub const m_hParam: usize = 0x18; // CAnimParamHandle
    pub const m_eParamType: usize = 0x1A; // AnimParamType_t
    pub const m_hScript: usize = 0x1C; // AnimScriptHandle
}

pub mod CFingerBone {
    pub const m_boneName: usize = 0x0; // CUtlString
    pub const m_hingeAxis: usize = 0x8; // Vector
    pub const m_vCapsulePos1: usize = 0x14; // Vector
    pub const m_vCapsulePos2: usize = 0x20; // Vector
    pub const m_flMinAngle: usize = 0x2C; // float
    pub const m_flMaxAngle: usize = 0x30; // float
    pub const m_flRadius: usize = 0x34; // float
}

pub mod CFingerChain {
    pub const m_targets: usize = 0x0; // CUtlVector<CFingerSource>
    pub const m_bones: usize = 0x18; // CUtlVector<CFingerBone>
    pub const m_name: usize = 0x30; // CUtlString
    pub const m_tipParentBoneName: usize = 0x38; // CUtlString
    pub const m_vTipOffset: usize = 0x40; // Vector
    pub const m_metacarpalBoneName: usize = 0x50; // CUtlString
    pub const m_vSplayHingeAxis: usize = 0x58; // Vector
    pub const m_flSplayMinAngle: usize = 0x64; // float
    pub const m_flSplayMaxAngle: usize = 0x68; // float
    pub const m_flFingerScaleRatio: usize = 0x6C; // float
}

pub mod CFingerSource {
    pub const m_nFingerIndex: usize = 0x0; // AnimVRFinger_t
    pub const m_flFingerWeight: usize = 0x4; // float
}

pub mod CFlexController {
    pub const m_szName: usize = 0x0; // CUtlString
    pub const m_szType: usize = 0x8; // CUtlString
    pub const min: usize = 0x10; // float
    pub const max: usize = 0x14; // float
}

pub mod CFlexDesc {
    pub const m_szFacs: usize = 0x0; // CUtlString
}

pub mod CFlexOp {
    pub const m_OpCode: usize = 0x0; // FlexOpCode_t
    pub const m_Data: usize = 0x4; // int32_t
}

pub mod CFlexRule {
    pub const m_nFlex: usize = 0x0; // int32_t
    pub const m_FlexOps: usize = 0x8; // CUtlVector<CFlexOp>
}

pub mod CFloatAnimParameter {
    pub const m_fDefaultValue: usize = 0x60; // float
    pub const m_fMinValue: usize = 0x64; // float
    pub const m_fMaxValue: usize = 0x68; // float
    pub const m_bInterpolate: usize = 0x6C; // bool
}

pub mod CFollowAttachmentUpdateNode {
    pub const m_opFixedData: usize = 0x70; // FollowAttachmentSettings_t
}

pub mod CFollowPathUpdateNode {
    pub const m_flBlendOutTime: usize = 0x6C; // float
    pub const m_bBlockNonPathMovement: usize = 0x70; // bool
    pub const m_bStopFeetAtGoal: usize = 0x71; // bool
    pub const m_bScaleSpeed: usize = 0x72; // bool
    pub const m_flScale: usize = 0x74; // float
    pub const m_flMinAngle: usize = 0x78; // float
    pub const m_flMaxAngle: usize = 0x7C; // float
    pub const m_flSpeedScaleBlending: usize = 0x80; // float
    pub const m_turnDamping: usize = 0x88; // CAnimInputDamping
    pub const m_facingTarget: usize = 0x98; // AnimValueSource
    pub const m_hParam: usize = 0x9C; // CAnimParamHandle
    pub const m_flTurnToFaceOffset: usize = 0xA0; // float
    pub const m_bTurnToFace: usize = 0xA4; // bool
}

pub mod CFootAdjustmentUpdateNode {
    pub const m_clips: usize = 0x70; // CUtlVector<HSequence>
    pub const m_hBasePoseCacheHandle: usize = 0x88; // CPoseHandle
    pub const m_facingTarget: usize = 0x8C; // CAnimParamHandle
    pub const m_flTurnTimeMin: usize = 0x90; // float
    pub const m_flTurnTimeMax: usize = 0x94; // float
    pub const m_flStepHeightMax: usize = 0x98; // float
    pub const m_flStepHeightMaxAngle: usize = 0x9C; // float
    pub const m_bResetChild: usize = 0xA0; // bool
    pub const m_bAnimationDriven: usize = 0xA1; // bool
}

pub mod CFootCycleDefinition {
    pub const m_vStancePositionMS: usize = 0x0; // Vector
    pub const m_vMidpointPositionMS: usize = 0xC; // Vector
    pub const m_flStanceDirectionMS: usize = 0x18; // float
    pub const m_vToStrideStartPos: usize = 0x1C; // Vector
    pub const m_stanceCycle: usize = 0x28; // CAnimCycle
    pub const m_footLiftCycle: usize = 0x2C; // CFootCycle
    pub const m_footOffCycle: usize = 0x30; // CFootCycle
    pub const m_footStrikeCycle: usize = 0x34; // CFootCycle
    pub const m_footLandCycle: usize = 0x38; // CFootCycle
}

pub mod CFootCycleMetricEvaluator {
    pub const m_footIndices: usize = 0x50; // CUtlVector<int32_t>
}

pub mod CFootDefinition {
    pub const m_name: usize = 0x0; // CUtlString
    pub const m_ankleBoneName: usize = 0x8; // CUtlString
    pub const m_toeBoneName: usize = 0x10; // CUtlString
    pub const m_vBallOffset: usize = 0x18; // Vector
    pub const m_vHeelOffset: usize = 0x24; // Vector
    pub const m_flFootLength: usize = 0x30; // float
    pub const m_flBindPoseDirectionMS: usize = 0x34; // float
    pub const m_flTraceHeight: usize = 0x38; // float
    pub const m_flTraceRadius: usize = 0x3C; // float
}

pub mod CFootFallAnimTag {
    pub const m_foot: usize = 0x38; // FootFallTagFoot_t
}

pub mod CFootLockUpdateNode {
    pub const m_opFixedSettings: usize = 0x68; // FootLockPoseOpFixedSettings
    pub const m_footSettings: usize = 0xD0; // CUtlVector<FootFixedSettings>
    pub const m_hipShiftDamping: usize = 0xE8; // CAnimInputDamping
    pub const m_rootHeightDamping: usize = 0xF8; // CAnimInputDamping
    pub const m_flStrideCurveScale: usize = 0x108; // float
    pub const m_flStrideCurveLimitScale: usize = 0x10C; // float
    pub const m_flStepHeightIncreaseScale: usize = 0x110; // float
    pub const m_flStepHeightDecreaseScale: usize = 0x114; // float
    pub const m_flHipShiftScale: usize = 0x118; // float
    pub const m_flBlendTime: usize = 0x11C; // float
    pub const m_flMaxRootHeightOffset: usize = 0x120; // float
    pub const m_flMinRootHeightOffset: usize = 0x124; // float
    pub const m_flTiltPlanePitchSpringStrength: usize = 0x128; // float
    pub const m_flTiltPlaneRollSpringStrength: usize = 0x12C; // float
    pub const m_bApplyFootRotationLimits: usize = 0x130; // bool
    pub const m_bApplyHipShift: usize = 0x131; // bool
    pub const m_bModulateStepHeight: usize = 0x132; // bool
    pub const m_bResetChild: usize = 0x133; // bool
    pub const m_bEnableVerticalCurvedPaths: usize = 0x134; // bool
    pub const m_bEnableRootHeightDamping: usize = 0x135; // bool
}

pub mod CFootMotion {
    pub const m_strides: usize = 0x0; // CUtlVector<CFootStride>
    pub const m_name: usize = 0x18; // CUtlString
    pub const m_bAdditive: usize = 0x20; // bool
}

pub mod CFootPinningUpdateNode {
    pub const m_poseOpFixedData: usize = 0x70; // FootPinningPoseOpFixedData_t
    pub const m_eTimingSource: usize = 0xA0; // FootPinningTimingSource
    pub const m_params: usize = 0xA8; // CUtlVector<CAnimParamHandle>
    pub const m_bResetChild: usize = 0xC0; // bool
}

pub mod CFootPositionMetricEvaluator {
    pub const m_footIndices: usize = 0x50; // CUtlVector<int32_t>
    pub const m_bIgnoreSlope: usize = 0x68; // bool
}

pub mod CFootStepTriggerUpdateNode {
    pub const m_triggers: usize = 0x68; // CUtlVector<FootStepTrigger>
    pub const m_flTolerance: usize = 0x84; // float
}

pub mod CFootStride {
    pub const m_definition: usize = 0x0; // CFootCycleDefinition
    pub const m_trajectories: usize = 0x40; // CFootTrajectories
}

pub mod CFootTrajectories {
    pub const m_trajectories: usize = 0x0; // CUtlVector<CFootTrajectory>
}

pub mod CFootTrajectory {
    pub const m_vOffset: usize = 0x0; // Vector
    pub const m_flRotationOffset: usize = 0xC; // float
    pub const m_flProgression: usize = 0x10; // float
}

pub mod CFootstepLandedAnimTag {
    pub const m_FootstepType: usize = 0x38; // FootstepLandedFootSoundType_t
    pub const m_OverrideSoundName: usize = 0x40; // CUtlString
    pub const m_DebugAnimSourceString: usize = 0x48; // CUtlString
    pub const m_BoneName: usize = 0x50; // CUtlString
}

pub mod CFutureFacingMetricEvaluator {
    pub const m_flDistance: usize = 0x50; // float
    pub const m_flTime: usize = 0x54; // float
}

pub mod CFutureVelocityMetricEvaluator {
    pub const m_flDistance: usize = 0x50; // float
    pub const m_flStoppingDistance: usize = 0x54; // float
    pub const m_flTargetSpeed: usize = 0x58; // float
    pub const m_eMode: usize = 0x5C; // VelocityMetricMode
}

pub mod CHitBox {
    pub const m_name: usize = 0x0; // CUtlString
    pub const m_sSurfaceProperty: usize = 0x8; // CUtlString
    pub const m_sBoneName: usize = 0x10; // CUtlString
    pub const m_vMinBounds: usize = 0x18; // Vector
    pub const m_vMaxBounds: usize = 0x24; // Vector
    pub const m_flShapeRadius: usize = 0x30; // float
    pub const m_nBoneNameHash: usize = 0x34; // uint32_t
    pub const m_nGroupId: usize = 0x38; // int32_t
    pub const m_nShapeType: usize = 0x3C; // uint8_t
    pub const m_bTranslationOnly: usize = 0x3D; // bool
    pub const m_CRC: usize = 0x40; // uint32_t
    pub const m_cRenderColor: usize = 0x44; // Color
    pub const m_nHitBoxIndex: usize = 0x48; // uint16_t
}

pub mod CHitBoxSet {
    pub const m_name: usize = 0x0; // CUtlString
    pub const m_nNameHash: usize = 0x8; // uint32_t
    pub const m_HitBoxes: usize = 0x10; // CUtlVector<CHitBox>
    pub const m_SourceFilename: usize = 0x28; // CUtlString
}

pub mod CHitBoxSetList {
    pub const m_HitBoxSets: usize = 0x0; // CUtlVector<CHitBoxSet>
}

pub mod CHitReactUpdateNode {
    pub const m_opFixedSettings: usize = 0x68; // HitReactFixedSettings_t
    pub const m_triggerParam: usize = 0xB4; // CAnimParamHandle
    pub const m_hitBoneParam: usize = 0xB6; // CAnimParamHandle
    pub const m_hitOffsetParam: usize = 0xB8; // CAnimParamHandle
    pub const m_hitDirectionParam: usize = 0xBA; // CAnimParamHandle
    pub const m_hitStrengthParam: usize = 0xBC; // CAnimParamHandle
    pub const m_flMinDelayBetweenHits: usize = 0xC0; // float
    pub const m_bResetChild: usize = 0xC4; // bool
}

pub mod CIntAnimParameter {
    pub const m_defaultValue: usize = 0x60; // int32_t
    pub const m_minValue: usize = 0x64; // int32_t
    pub const m_maxValue: usize = 0x68; // int32_t
}

pub mod CJiggleBoneUpdateNode {
    pub const m_opFixedData: usize = 0x68; // JiggleBoneSettingsList_t
}

pub mod CJumpHelperUpdateNode {
    pub const m_hTargetParam: usize = 0xA8; // CAnimParamHandle
    pub const m_flOriginalJumpMovement: usize = 0xAC; // Vector
    pub const m_flOriginalJumpDuration: usize = 0xB8; // float
    pub const m_flJumpStartCycle: usize = 0xBC; // float
    pub const m_flJumpEndCycle: usize = 0xC0; // float
    pub const m_eCorrectionMethod: usize = 0xC4; // JumpCorrectionMethod
    pub const m_bTranslationAxis: usize = 0xC8; // bool[3]
    pub const m_bScaleSpeed: usize = 0xCB; // bool
}

pub mod CLODComponentUpdater {
    pub const m_nServerLOD: usize = 0x30; // int32_t
}

pub mod CLeanMatrixUpdateNode {
    pub const m_frameCorners: usize = 0x5C; // int32_t[3][3]
    pub const m_poses: usize = 0x80; // CPoseHandle[9]
    pub const m_damping: usize = 0xA8; // CAnimInputDamping
    pub const m_blendSource: usize = 0xB8; // AnimVectorSource
    pub const m_paramIndex: usize = 0xBC; // CAnimParamHandle
    pub const m_verticalAxis: usize = 0xC0; // Vector
    pub const m_horizontalAxis: usize = 0xCC; // Vector
    pub const m_hSequence: usize = 0xD8; // HSequence
    pub const m_flMaxValue: usize = 0xDC; // float
    pub const m_nSequenceMaxFrame: usize = 0xE0; // int32_t
}

pub mod CLookAtUpdateNode {
    pub const m_opFixedSettings: usize = 0x70; // LookAtOpFixedSettings_t
    pub const m_target: usize = 0x138; // AnimVectorSource
    pub const m_paramIndex: usize = 0x13C; // CAnimParamHandle
    pub const m_weightParamIndex: usize = 0x13E; // CAnimParamHandle
    pub const m_bResetChild: usize = 0x140; // bool
    pub const m_bLockWhenWaning: usize = 0x141; // bool
}

pub mod CLookComponentUpdater {
    pub const m_hLookHeading: usize = 0x34; // CAnimParamHandle
    pub const m_hLookHeadingVelocity: usize = 0x36; // CAnimParamHandle
    pub const m_hLookPitch: usize = 0x38; // CAnimParamHandle
    pub const m_hLookDistance: usize = 0x3A; // CAnimParamHandle
    pub const m_hLookDirection: usize = 0x3C; // CAnimParamHandle
    pub const m_hLookTarget: usize = 0x3E; // CAnimParamHandle
    pub const m_hLookTargetWorldSpace: usize = 0x40; // CAnimParamHandle
    pub const m_bNetworkLookTarget: usize = 0x42; // bool
}

pub mod CMaterialAttributeAnimTag {
    pub const m_AttributeName: usize = 0x38; // CUtlString
    pub const m_AttributeType: usize = 0x40; // MatterialAttributeTagType_t
    pub const m_flValue: usize = 0x44; // float
    pub const m_Color: usize = 0x48; // Color
}

pub mod CMaterialDrawDescriptor {
    pub const m_nPrimitiveType: usize = 0x0; // RenderPrimitiveType_t
    pub const m_nBaseVertex: usize = 0x4; // int32_t
    pub const m_nVertexCount: usize = 0x8; // int32_t
    pub const m_nStartIndex: usize = 0xC; // int32_t
    pub const m_nIndexCount: usize = 0x10; // int32_t
    pub const m_flUvDensity: usize = 0x14; // float
    pub const m_vTintColor: usize = 0x18; // Vector
    pub const m_flAlpha: usize = 0x24; // float
    pub const m_nFirstMeshlet: usize = 0x2C; // uint32_t
    pub const m_nNumMeshlets: usize = 0x30; // uint16_t
    pub const m_indexBuffer: usize = 0xB8; // CRenderBufferBinding
    pub const m_material: usize = 0xE0; // CStrongHandle<InfoForResourceTypeIMaterial2>
}

pub mod CMeshletDescriptor {
    pub const m_PackedAABB: usize = 0x0; // PackedAABB_t
    pub const m_CullingData: usize = 0x8; // CDrawCullingData
}

pub mod CModelConfig {
    pub const m_ConfigName: usize = 0x0; // CUtlString
    pub const m_Elements: usize = 0x8; // CUtlVector<CModelConfigElement*>
    pub const m_bTopLevel: usize = 0x20; // bool
}

pub mod CModelConfigElement {
    pub const m_ElementName: usize = 0x8; // CUtlString
    pub const m_NestedElements: usize = 0x10; // CUtlVector<CModelConfigElement*>
}

pub mod CModelConfigElement_AttachedModel {
    pub const m_InstanceName: usize = 0x48; // CUtlString
    pub const m_EntityClass: usize = 0x50; // CUtlString
    pub const m_hModel: usize = 0x58; // CStrongHandle<InfoForResourceTypeCModel>
    pub const m_vOffset: usize = 0x60; // Vector
    pub const m_aAngOffset: usize = 0x6C; // QAngle
    pub const m_AttachmentName: usize = 0x78; // CUtlString
    pub const m_LocalAttachmentOffsetName: usize = 0x80; // CUtlString
    pub const m_AttachmentType: usize = 0x88; // ModelConfigAttachmentType_t
    pub const m_bBoneMergeFlex: usize = 0x8C; // bool
    pub const m_bUserSpecifiedColor: usize = 0x8D; // bool
    pub const m_bUserSpecifiedMaterialGroup: usize = 0x8E; // bool
    pub const m_bAcceptParentMaterialDrivenDecals: usize = 0x8F; // bool
    pub const m_BodygroupOnOtherModels: usize = 0x90; // CUtlString
    pub const m_MaterialGroupOnOtherModels: usize = 0x98; // CUtlString
}

pub mod CModelConfigElement_Command {
    pub const m_Command: usize = 0x48; // CUtlString
    pub const m_Args: usize = 0x50; // KeyValues3
}

pub mod CModelConfigElement_RandomColor {
    pub const m_Gradient: usize = 0x48; // CColorGradient
}

pub mod CModelConfigElement_RandomPick {
    pub const m_Choices: usize = 0x48; // CUtlVector<CUtlString>
    pub const m_ChoiceWeights: usize = 0x60; // CUtlVector<float>
}

pub mod CModelConfigElement_SetBodygroup {
    pub const m_GroupName: usize = 0x48; // CUtlString
    pub const m_nChoice: usize = 0x50; // int32_t
}

pub mod CModelConfigElement_SetBodygroupOnAttachedModels {
    pub const m_GroupName: usize = 0x48; // CUtlString
    pub const m_nChoice: usize = 0x50; // int32_t
}

pub mod CModelConfigElement_SetMaterialGroup {
    pub const m_MaterialGroupName: usize = 0x48; // CUtlString
}

pub mod CModelConfigElement_SetMaterialGroupOnAttachedModels {
    pub const m_MaterialGroupName: usize = 0x48; // CUtlString
}

pub mod CModelConfigElement_SetRenderColor {
    pub const m_Color: usize = 0x48; // Color
}

pub mod CModelConfigElement_UserPick {
    pub const m_Choices: usize = 0x48; // CUtlVector<CUtlString>
}

pub mod CModelConfigList {
    pub const m_bHideMaterialGroupInTools: usize = 0x0; // bool
    pub const m_bHideRenderColorInTools: usize = 0x1; // bool
    pub const m_Configs: usize = 0x8; // CUtlVector<CModelConfig*>
}

pub mod CMoodVData {
    pub const m_sModelName: usize = 0x0; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    pub const m_nMoodType: usize = 0xE0; // MoodType_t
    pub const m_animationLayers: usize = 0xE8; // CUtlVector<MoodAnimationLayer_t>
}

pub mod CMorphBundleData {
    pub const m_flULeftSrc: usize = 0x0; // float
    pub const m_flVTopSrc: usize = 0x4; // float
    pub const m_offsets: usize = 0x8; // CUtlVector<float>
    pub const m_ranges: usize = 0x20; // CUtlVector<float>
}

pub mod CMorphConstraint {
    pub const m_sTargetMorph: usize = 0x70; // CUtlString
    pub const m_nSlaveChannel: usize = 0x78; // int32_t
    pub const m_flMin: usize = 0x7C; // float
    pub const m_flMax: usize = 0x80; // float
}

pub mod CMorphData {
    pub const m_name: usize = 0x0; // CUtlString
    pub const m_morphRectDatas: usize = 0x8; // CUtlVector<CMorphRectData>
}

pub mod CMorphRectData {
    pub const m_nXLeftDst: usize = 0x0; // int16_t
    pub const m_nYTopDst: usize = 0x2; // int16_t
    pub const m_flUWidthSrc: usize = 0x4; // float
    pub const m_flVHeightSrc: usize = 0x8; // float
    pub const m_bundleDatas: usize = 0x10; // CUtlVector<CMorphBundleData>
}

pub mod CMorphSetData {
    pub const m_nWidth: usize = 0x10; // int32_t
    pub const m_nHeight: usize = 0x14; // int32_t
    pub const m_bundleTypes: usize = 0x18; // CUtlVector<MorphBundleType_t>
    pub const m_morphDatas: usize = 0x30; // CUtlVector<CMorphData>
    pub const m_pTextureAtlas: usize = 0x48; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_FlexDesc: usize = 0x50; // CUtlVector<CFlexDesc>
    pub const m_FlexControllers: usize = 0x68; // CUtlVector<CFlexController>
    pub const m_FlexRules: usize = 0x80; // CUtlVector<CFlexRule>
}

pub mod CMotionDataSet {
    pub const m_groups: usize = 0x0; // CUtlVector<CMotionGraphGroup>
    pub const m_nDimensionCount: usize = 0x18; // int32_t
}

pub mod CMotionGraph {
    pub const m_paramSpans: usize = 0x10; // CParamSpanUpdater
    pub const m_tags: usize = 0x28; // CUtlVector<TagSpan_t>
    pub const m_pRootNode: usize = 0x40; // CSmartPtr<CMotionNode>
    pub const m_nParameterCount: usize = 0x48; // int32_t
    pub const m_nConfigStartIndex: usize = 0x4C; // int32_t
    pub const m_nConfigCount: usize = 0x50; // int32_t
    pub const m_bLoop: usize = 0x54; // bool
}

pub mod CMotionGraphConfig {
    pub const m_paramValues: usize = 0x0; // float[4]
    pub const m_flDuration: usize = 0x10; // float
    pub const m_nMotionIndex: usize = 0x14; // MotionIndex
    pub const m_nSampleStart: usize = 0x18; // int32_t
    pub const m_nSampleCount: usize = 0x1C; // int32_t
}

pub mod CMotionGraphGroup {
    pub const m_searchDB: usize = 0x0; // CMotionSearchDB
    pub const m_motionGraphs: usize = 0xB8; // CUtlVector<CSmartPtr<CMotionGraph>>
    pub const m_motionGraphConfigs: usize = 0xD0; // CUtlVector<CMotionGraphConfig>
    pub const m_sampleToConfig: usize = 0xE8; // CUtlVector<int32_t>
    pub const m_hIsActiveScript: usize = 0x100; // AnimScriptHandle
}

pub mod CMotionGraphUpdateNode {
    pub const m_pMotionGraph: usize = 0x58; // CSmartPtr<CMotionGraph>
}

pub mod CMotionMatchingUpdateNode {
    pub const m_dataSet: usize = 0x58; // CMotionDataSet
    pub const m_metrics: usize = 0x78; // CUtlVector<CSmartPtr<CMotionMetricEvaluator>>
    pub const m_weights: usize = 0x90; // CUtlVector<float>
    pub const m_bSearchEveryTick: usize = 0xE0; // bool
    pub const m_flSearchInterval: usize = 0xE4; // float
    pub const m_bSearchWhenClipEnds: usize = 0xE8; // bool
    pub const m_bSearchWhenGoalChanges: usize = 0xE9; // bool
    pub const m_blendCurve: usize = 0xEC; // CBlendCurve
    pub const m_flSampleRate: usize = 0xF4; // float
    pub const m_flBlendTime: usize = 0xF8; // float
    pub const m_bLockClipWhenWaning: usize = 0xFC; // bool
    pub const m_flSelectionThreshold: usize = 0x100; // float
    pub const m_flReselectionTimeWindow: usize = 0x104; // float
    pub const m_bEnableRotationCorrection: usize = 0x108; // bool
    pub const m_bGoalAssist: usize = 0x109; // bool
    pub const m_flGoalAssistDistance: usize = 0x10C; // float
    pub const m_flGoalAssistTolerance: usize = 0x110; // float
    pub const m_distanceScale_Damping: usize = 0x118; // CAnimInputDamping
    pub const m_flDistanceScale_OuterRadius: usize = 0x128; // float
    pub const m_flDistanceScale_InnerRadius: usize = 0x12C; // float
    pub const m_flDistanceScale_MaxScale: usize = 0x130; // float
    pub const m_flDistanceScale_MinScale: usize = 0x134; // float
    pub const m_bEnableDistanceScaling: usize = 0x138; // bool
}

pub mod CMotionMetricEvaluator {
    pub const m_means: usize = 0x18; // CUtlVector<float>
    pub const m_standardDeviations: usize = 0x30; // CUtlVector<float>
    pub const m_flWeight: usize = 0x48; // float
    pub const m_nDimensionStartIndex: usize = 0x4C; // int32_t
}

pub mod CMotionNode {
    pub const m_name: usize = 0x18; // CUtlString
    pub const m_id: usize = 0x20; // AnimNodeID
}

pub mod CMotionNodeBlend1D {
    pub const m_blendItems: usize = 0x28; // CUtlVector<MotionBlendItem>
    pub const m_nParamIndex: usize = 0x40; // int32_t
}

pub mod CMotionNodeSequence {
    pub const m_tags: usize = 0x28; // CUtlVector<TagSpan_t>
    pub const m_hSequence: usize = 0x40; // HSequence
    pub const m_flPlaybackSpeed: usize = 0x44; // float
}

pub mod CMotionSearchDB {
    pub const m_rootNode: usize = 0x0; // CMotionSearchNode
    pub const m_residualQuantizer: usize = 0x80; // CProductQuantizer
    pub const m_codeIndices: usize = 0xA0; // CUtlVector<MotionDBIndex>
}

pub mod CMotionSearchNode {
    pub const m_children: usize = 0x0; // CUtlVector<CMotionSearchNode*>
    pub const m_quantizer: usize = 0x18; // CVectorQuantizer
    pub const m_sampleCodes: usize = 0x38; // CUtlVector<CUtlVector<SampleCode>>
    pub const m_sampleIndices: usize = 0x50; // CUtlVector<CUtlVector<int32_t>>
    pub const m_selectableSamples: usize = 0x68; // CUtlVector<int32_t>
}

pub mod CMovementComponentUpdater {
    pub const m_movementModes: usize = 0x30; // CUtlVector<CMovementMode>
    pub const m_motors: usize = 0x48; // CUtlVector<CSmartPtr<CAnimMotorUpdaterBase>>
    pub const m_facingDamping: usize = 0x60; // CAnimInputDamping
    pub const m_eDefaultFacingMode: usize = 0x70; // FacingMode
    pub const m_nDefaultMotorIndex: usize = 0x7C; // int32_t
    pub const m_bMoveVarsDisabled: usize = 0x80; // bool
    pub const m_bNetworkPath: usize = 0x81; // bool
    pub const m_bNetworkFacing: usize = 0x82; // bool
    pub const m_paramHandles: usize = 0x83; // CAnimParamHandle[30]
}

pub mod CMovementMode {
    pub const m_name: usize = 0x0; // CUtlString
    pub const m_flSpeed: usize = 0x8; // float
}

pub mod CMoverUpdateNode {
    pub const m_damping: usize = 0x70; // CAnimInputDamping
    pub const m_facingTarget: usize = 0x80; // AnimValueSource
    pub const m_hMoveVecParam: usize = 0x84; // CAnimParamHandle
    pub const m_hMoveHeadingParam: usize = 0x86; // CAnimParamHandle
    pub const m_hTurnToFaceParam: usize = 0x88; // CAnimParamHandle
    pub const m_flTurnToFaceOffset: usize = 0x8C; // float
    pub const m_flTurnToFaceLimit: usize = 0x90; // float
    pub const m_bAdditive: usize = 0x94; // bool
    pub const m_bApplyMovement: usize = 0x95; // bool
    pub const m_bOrientMovement: usize = 0x96; // bool
    pub const m_bApplyRotation: usize = 0x97; // bool
    pub const m_bLimitOnly: usize = 0x98; // bool
}

pub mod CParamSpanUpdater {
    pub const m_spans: usize = 0x0; // CUtlVector<ParamSpan_t>
}

pub mod CParticleAnimTag {
    pub const m_hParticleSystem: usize = 0x38; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    pub const m_particleSystemName: usize = 0x40; // CUtlString
    pub const m_configName: usize = 0x48; // CUtlString
    pub const m_bDetachFromOwner: usize = 0x50; // bool
    pub const m_bStopWhenTagEnds: usize = 0x51; // bool
    pub const m_bTagEndStopIsInstant: usize = 0x52; // bool
    pub const m_attachmentName: usize = 0x58; // CUtlString
    pub const m_attachmentType: usize = 0x60; // ParticleAttachment_t
    pub const m_attachmentCP1Name: usize = 0x68; // CUtlString
    pub const m_attachmentCP1Type: usize = 0x70; // ParticleAttachment_t
}

pub mod CPathAnimMotorUpdaterBase {
    pub const m_bLockToPath: usize = 0x20; // bool
}

pub mod CPathHelperUpdateNode {
    pub const m_flStoppingRadius: usize = 0x68; // float
    pub const m_flStoppingSpeedScale: usize = 0x6C; // float
}

pub mod CPathMetricEvaluator {
    pub const m_pathTimeSamples: usize = 0x50; // CUtlVector<float>
    pub const m_flDistance: usize = 0x68; // float
    pub const m_bExtrapolateMovement: usize = 0x6C; // bool
    pub const m_flMinExtrapolationSpeed: usize = 0x70; // float
}

pub mod CPhysSurfaceProperties {
    pub const m_name: usize = 0x0; // CUtlString
    pub const m_nameHash: usize = 0x8; // uint32_t
    pub const m_baseNameHash: usize = 0xC; // uint32_t
    pub const m_bHidden: usize = 0x18; // bool
    pub const m_description: usize = 0x20; // CUtlString
    pub const m_physics: usize = 0x28; // CPhysSurfacePropertiesPhysics
    pub const m_audioSounds: usize = 0x48; // CPhysSurfacePropertiesSoundNames
    pub const m_audioParams: usize = 0x88; // CPhysSurfacePropertiesAudio
}

pub mod CPhysSurfacePropertiesAudio {
    pub const m_reflectivity: usize = 0x0; // float
    pub const m_hardnessFactor: usize = 0x4; // float
    pub const m_roughnessFactor: usize = 0x8; // float
    pub const m_roughThreshold: usize = 0xC; // float
    pub const m_hardThreshold: usize = 0x10; // float
    pub const m_hardVelocityThreshold: usize = 0x14; // float
    pub const m_flStaticImpactVolume: usize = 0x18; // float
    pub const m_flOcclusionFactor: usize = 0x1C; // float
}

pub mod CPhysSurfacePropertiesPhysics {
    pub const m_friction: usize = 0x0; // float
    pub const m_elasticity: usize = 0x4; // float
    pub const m_density: usize = 0x8; // float
    pub const m_thickness: usize = 0xC; // float
    pub const m_softContactFrequency: usize = 0x10; // float
    pub const m_softContactDampingRatio: usize = 0x14; // float
    pub const m_wheelDrag: usize = 0x18; // float
}

pub mod CPhysSurfacePropertiesSoundNames {
    pub const m_impactSoft: usize = 0x0; // CUtlString
    pub const m_impactHard: usize = 0x8; // CUtlString
    pub const m_scrapeSmooth: usize = 0x10; // CUtlString
    pub const m_scrapeRough: usize = 0x18; // CUtlString
    pub const m_bulletImpact: usize = 0x20; // CUtlString
    pub const m_rolling: usize = 0x28; // CUtlString
    pub const m_break: usize = 0x30; // CUtlString
    pub const m_strain: usize = 0x38; // CUtlString
}

pub mod CPlayerInputAnimMotorUpdater {
    pub const m_sampleTimes: usize = 0x20; // CUtlVector<float>
    pub const m_flSpringConstant: usize = 0x3C; // float
    pub const m_flAnticipationDistance: usize = 0x40; // float
    pub const m_hAnticipationPosParam: usize = 0x44; // CAnimParamHandle
    pub const m_hAnticipationHeadingParam: usize = 0x46; // CAnimParamHandle
    pub const m_bUseAcceleration: usize = 0x48; // bool
}

pub mod CPoseHandle {
    pub const m_nIndex: usize = 0x0; // uint16_t
    pub const m_eType: usize = 0x2; // PoseType_t
}

pub mod CProductQuantizer {
    pub const m_subQuantizers: usize = 0x0; // CUtlVector<CVectorQuantizer>
    pub const m_nDimensions: usize = 0x18; // int32_t
}

pub mod CQuaternionAnimParameter {
    pub const m_defaultValue: usize = 0x60; // Quaternion
    pub const m_bInterpolate: usize = 0x70; // bool
}

pub mod CRagdollAnimTag {
    pub const m_nPoseControl: usize = 0x38; // AnimPoseControl
    pub const m_flFrequency: usize = 0x3C; // float
    pub const m_flDampingRatio: usize = 0x40; // float
    pub const m_flDecayDuration: usize = 0x44; // float
    pub const m_flDecayBias: usize = 0x48; // float
    pub const m_bDestroy: usize = 0x4C; // bool
}

pub mod CRagdollComponentUpdater {
    pub const m_ragdollNodePaths: usize = 0x30; // CUtlVector<CAnimNodePath>
    pub const m_boneIndices: usize = 0x48; // CUtlVector<int32_t>
    pub const m_boneNames: usize = 0x60; // CUtlVector<CUtlString>
    pub const m_weightLists: usize = 0x78; // CUtlVector<WeightList>
    pub const m_flSpringFrequencyMin: usize = 0x90; // float
    pub const m_flSpringFrequencyMax: usize = 0x94; // float
    pub const m_flMaxStretch: usize = 0x98; // float
}

pub mod CRagdollUpdateNode {
    pub const m_nWeightListIndex: usize = 0x68; // int32_t
    pub const m_poseControlMethod: usize = 0x6C; // RagdollPoseControl
}

pub mod CRenderBufferBinding {
    pub const m_hBuffer: usize = 0x0; // uint64_t
    pub const m_nBindOffsetBytes: usize = 0x10; // uint32_t
}

pub mod CRenderMesh {
    pub const m_sceneObjects: usize = 0x10; // CUtlVectorFixedGrowable<CSceneObjectData>
    pub const m_constraints: usize = 0xA0; // CUtlVector<CBaseConstraint*>
    pub const m_skeleton: usize = 0xB8; // CRenderSkeleton
}

pub mod CRenderSkeleton {
    pub const m_bones: usize = 0x0; // CUtlVector<RenderSkeletonBone_t>
    pub const m_boneParents: usize = 0x30; // CUtlVector<int32_t>
    pub const m_nBoneWeightCount: usize = 0x48; // int32_t
}

pub mod CSceneObjectData {
    pub const m_vMinBounds: usize = 0x0; // Vector
    pub const m_vMaxBounds: usize = 0xC; // Vector
    pub const m_drawCalls: usize = 0x18; // CUtlVector<CMaterialDrawDescriptor>
    pub const m_drawBounds: usize = 0x30; // CUtlVector<AABB_t>
    pub const m_meshlets: usize = 0x48; // CUtlVector<CMeshletDescriptor>
    pub const m_vTintColor: usize = 0x60; // Vector4D
}

pub mod CSelectorUpdateNode {
    pub const m_children: usize = 0x58; // CUtlVector<CAnimUpdateNodeRef>
    pub const m_tags: usize = 0x70; // CUtlVector<int8_t>
    pub const m_blendCurve: usize = 0x8C; // CBlendCurve
    pub const m_flBlendTime: usize = 0x94; // CAnimValue<float>
    pub const m_hParameter: usize = 0x9C; // CAnimParamHandle
    pub const m_eTagBehavior: usize = 0xA0; // SelectorTagBehavior_t
    pub const m_bResetOnChange: usize = 0xA4; // bool
    pub const m_bSyncCyclesOnChange: usize = 0xA5; // bool
}

pub mod CSeqAutoLayer {
    pub const m_nLocalReference: usize = 0x0; // int16_t
    pub const m_nLocalPose: usize = 0x2; // int16_t
    pub const m_flags: usize = 0x4; // CSeqAutoLayerFlag
    pub const m_start: usize = 0xC; // float
    pub const m_peak: usize = 0x10; // float
    pub const m_tail: usize = 0x14; // float
    pub const m_end: usize = 0x18; // float
}

pub mod CSeqAutoLayerFlag {
    pub const m_bPost: usize = 0x0; // bool
    pub const m_bSpline: usize = 0x1; // bool
    pub const m_bXFade: usize = 0x2; // bool
    pub const m_bNoBlend: usize = 0x3; // bool
    pub const m_bLocal: usize = 0x4; // bool
    pub const m_bPose: usize = 0x5; // bool
    pub const m_bFetchFrame: usize = 0x6; // bool
    pub const m_bSubtract: usize = 0x7; // bool
}

pub mod CSeqBoneMaskList {
    pub const m_sName: usize = 0x0; // CBufferString
    pub const m_nLocalBoneArray: usize = 0x10; // CUtlVector<int16_t>
    pub const m_flBoneWeightArray: usize = 0x28; // CUtlVector<float>
    pub const m_flDefaultMorphCtrlWeight: usize = 0x40; // float
    pub const m_morphCtrlWeightArray: usize = 0x48; // CUtlVector<CUtlPair<CBufferString,float>>
}

pub mod CSeqCmdLayer {
    pub const m_cmd: usize = 0x0; // int16_t
    pub const m_nLocalReference: usize = 0x2; // int16_t
    pub const m_nLocalBonemask: usize = 0x4; // int16_t
    pub const m_nDstResult: usize = 0x6; // int16_t
    pub const m_nSrcResult: usize = 0x8; // int16_t
    pub const m_bSpline: usize = 0xA; // bool
    pub const m_flVar1: usize = 0xC; // float
    pub const m_flVar2: usize = 0x10; // float
    pub const m_nLineNumber: usize = 0x14; // int16_t
}

pub mod CSeqCmdSeqDesc {
    pub const m_sName: usize = 0x0; // CBufferString
    pub const m_flags: usize = 0x10; // CSeqSeqDescFlag
    pub const m_transition: usize = 0x1C; // CSeqTransition
    pub const m_nFrameRangeSequence: usize = 0x24; // int16_t
    pub const m_nFrameCount: usize = 0x26; // int16_t
    pub const m_flFPS: usize = 0x28; // float
    pub const m_nSubCycles: usize = 0x2C; // int16_t
    pub const m_numLocalResults: usize = 0x2E; // int16_t
    pub const m_cmdLayerArray: usize = 0x30; // CUtlVector<CSeqCmdLayer>
    pub const m_eventArray: usize = 0x48; // CUtlVector<CAnimEventDefinition>
    pub const m_activityArray: usize = 0x60; // CUtlVector<CAnimActivity>
    pub const m_poseSettingArray: usize = 0x78; // CUtlVector<CSeqPoseSetting>
}

pub mod CSeqIKLock {
    pub const m_flPosWeight: usize = 0x0; // float
    pub const m_flAngleWeight: usize = 0x4; // float
    pub const m_nLocalBone: usize = 0x8; // int16_t
    pub const m_bBonesOrientedAlongPositiveX: usize = 0xA; // bool
}

pub mod CSeqMultiFetch {
    pub const m_flags: usize = 0x0; // CSeqMultiFetchFlag
    pub const m_localReferenceArray: usize = 0x8; // CUtlVector<int16_t>
    pub const m_nGroupSize: usize = 0x20; // int32_t[2]
    pub const m_nLocalPose: usize = 0x28; // int32_t[2]
    pub const m_poseKeyArray0: usize = 0x30; // CUtlVector<float>
    pub const m_poseKeyArray1: usize = 0x48; // CUtlVector<float>
    pub const m_nLocalCyclePoseParameter: usize = 0x60; // int32_t
    pub const m_bCalculatePoseParameters: usize = 0x64; // bool
}

pub mod CSeqMultiFetchFlag {
    pub const m_bRealtime: usize = 0x0; // bool
    pub const m_bCylepose: usize = 0x1; // bool
    pub const m_b0D: usize = 0x2; // bool
    pub const m_b1D: usize = 0x3; // bool
    pub const m_b2D: usize = 0x4; // bool
    pub const m_b2D_TRI: usize = 0x5; // bool
}

pub mod CSeqPoseParamDesc {
    pub const m_sName: usize = 0x0; // CBufferString
    pub const m_flStart: usize = 0x10; // float
    pub const m_flEnd: usize = 0x14; // float
    pub const m_flLoop: usize = 0x18; // float
    pub const m_bLooping: usize = 0x1C; // bool
}

pub mod CSeqPoseSetting {
    pub const m_sPoseParameter: usize = 0x0; // CBufferString
    pub const m_sAttachment: usize = 0x10; // CBufferString
    pub const m_sReferenceSequence: usize = 0x20; // CBufferString
    pub const m_flValue: usize = 0x30; // float
    pub const m_bX: usize = 0x34; // bool
    pub const m_bY: usize = 0x35; // bool
    pub const m_bZ: usize = 0x36; // bool
    pub const m_eType: usize = 0x38; // int32_t
}

pub mod CSeqS1SeqDesc {
    pub const m_sName: usize = 0x0; // CBufferString
    pub const m_flags: usize = 0x10; // CSeqSeqDescFlag
    pub const m_fetch: usize = 0x20; // CSeqMultiFetch
    pub const m_nLocalWeightlist: usize = 0x88; // int32_t
    pub const m_autoLayerArray: usize = 0x90; // CUtlVector<CSeqAutoLayer>
    pub const m_IKLockArray: usize = 0xA8; // CUtlVector<CSeqIKLock>
    pub const m_transition: usize = 0xC0; // CSeqTransition
    pub const m_SequenceKeys: usize = 0xC8; // KeyValues3
    pub const m_LegacyKeyValueText: usize = 0xD8; // CBufferString
    pub const m_activityArray: usize = 0xE8; // CUtlVector<CAnimActivity>
    pub const m_footMotion: usize = 0x100; // CUtlVector<CFootMotion>
}

pub mod CSeqScaleSet {
    pub const m_sName: usize = 0x0; // CBufferString
    pub const m_bRootOffset: usize = 0x10; // bool
    pub const m_vRootOffset: usize = 0x14; // Vector
    pub const m_nLocalBoneArray: usize = 0x20; // CUtlVector<int16_t>
    pub const m_flBoneScaleArray: usize = 0x38; // CUtlVector<float>
}

pub mod CSeqSeqDescFlag {
    pub const m_bLooping: usize = 0x0; // bool
    pub const m_bSnap: usize = 0x1; // bool
    pub const m_bAutoplay: usize = 0x2; // bool
    pub const m_bPost: usize = 0x3; // bool
    pub const m_bHidden: usize = 0x4; // bool
    pub const m_bMulti: usize = 0x5; // bool
    pub const m_bLegacyDelta: usize = 0x6; // bool
    pub const m_bLegacyWorldspace: usize = 0x7; // bool
    pub const m_bLegacyCyclepose: usize = 0x8; // bool
    pub const m_bLegacyRealtime: usize = 0x9; // bool
    pub const m_bModelDoc: usize = 0xA; // bool
}

pub mod CSeqSynthAnimDesc {
    pub const m_sName: usize = 0x0; // CBufferString
    pub const m_flags: usize = 0x10; // CSeqSeqDescFlag
    pub const m_transition: usize = 0x1C; // CSeqTransition
    pub const m_nLocalBaseReference: usize = 0x24; // int16_t
    pub const m_nLocalBoneMask: usize = 0x26; // int16_t
    pub const m_activityArray: usize = 0x28; // CUtlVector<CAnimActivity>
}

pub mod CSeqTransition {
    pub const m_flFadeInTime: usize = 0x0; // float
    pub const m_flFadeOutTime: usize = 0x4; // float
}

pub mod CSequenceFinishedAnimTag {
    pub const m_sequenceName: usize = 0x38; // CUtlString
}

pub mod CSequenceGroupData {
    pub const m_sName: usize = 0x10; // CBufferString
    pub const m_nFlags: usize = 0x20; // uint32_t
    pub const m_localSequenceNameArray: usize = 0x28; // CUtlVector<CBufferString>
    pub const m_localS1SeqDescArray: usize = 0x40; // CUtlVector<CSeqS1SeqDesc>
    pub const m_localMultiSeqDescArray: usize = 0x58; // CUtlVector<CSeqS1SeqDesc>
    pub const m_localSynthAnimDescArray: usize = 0x70; // CUtlVector<CSeqSynthAnimDesc>
    pub const m_localCmdSeqDescArray: usize = 0x88; // CUtlVector<CSeqCmdSeqDesc>
    pub const m_localBoneMaskArray: usize = 0xA0; // CUtlVector<CSeqBoneMaskList>
    pub const m_localScaleSetArray: usize = 0xB8; // CUtlVector<CSeqScaleSet>
    pub const m_localBoneNameArray: usize = 0xD0; // CUtlVector<CBufferString>
    pub const m_localNodeName: usize = 0xE8; // CBufferString
    pub const m_localPoseParamArray: usize = 0xF8; // CUtlVector<CSeqPoseParamDesc>
    pub const m_keyValues: usize = 0x110; // KeyValues3
    pub const m_localIKAutoplayLockArray: usize = 0x120; // CUtlVector<CSeqIKLock>
}

pub mod CSequenceUpdateNode {
    pub const m_paramSpans: usize = 0x60; // CParamSpanUpdater
    pub const m_tags: usize = 0x78; // CUtlVector<TagSpan_t>
    pub const m_hSequence: usize = 0x94; // HSequence
    pub const m_playbackSpeed: usize = 0x98; // float
    pub const m_duration: usize = 0x9C; // float
    pub const m_bLoop: usize = 0xA0; // bool
}

pub mod CSetFacingUpdateNode {
    pub const m_facingMode: usize = 0x68; // FacingMode
    pub const m_bResetChild: usize = 0x6C; // bool
}

pub mod CSetParameterActionUpdater {
    pub const m_hParam: usize = 0x18; // CAnimParamHandle
    pub const m_value: usize = 0x1A; // CAnimVariant
}

pub mod CSingleFrameUpdateNode {
    pub const m_actions: usize = 0x58; // CUtlVector<CSmartPtr<CAnimActionUpdater>>
    pub const m_hPoseCacheHandle: usize = 0x70; // CPoseHandle
    pub const m_hSequence: usize = 0x74; // HSequence
    pub const m_flCycle: usize = 0x78; // float
}

pub mod CSkeletalInputUpdateNode {
    pub const m_fixedOpData: usize = 0x58; // SkeletalInputOpFixedSettings_t
}

pub mod CSlopeComponentUpdater {
    pub const m_flTraceDistance: usize = 0x34; // float
    pub const m_hSlopeAngle: usize = 0x38; // CAnimParamHandle
    pub const m_hSlopeAngleFront: usize = 0x3A; // CAnimParamHandle
    pub const m_hSlopeAngleSide: usize = 0x3C; // CAnimParamHandle
    pub const m_hSlopeHeading: usize = 0x3E; // CAnimParamHandle
    pub const m_hSlopeNormal: usize = 0x40; // CAnimParamHandle
    pub const m_hSlopeNormal_WorldSpace: usize = 0x42; // CAnimParamHandle
}

pub mod CSlowDownOnSlopesUpdateNode {
    pub const m_flSlowDownStrength: usize = 0x68; // float
}

pub mod CSolveIKChainUpdateNode {
    pub const m_targetHandles: usize = 0x68; // CUtlVector<CSolveIKTargetHandle_t>
    pub const m_opFixedData: usize = 0x80; // SolveIKChainPoseOpFixedSettings_t
}

pub mod CSolveIKTargetHandle_t {
    pub const m_positionHandle: usize = 0x0; // CAnimParamHandle
    pub const m_orientationHandle: usize = 0x2; // CAnimParamHandle
}

pub mod CSpeedScaleUpdateNode {
    pub const m_paramIndex: usize = 0x68; // CAnimParamHandle
}

pub mod CStanceOverrideUpdateNode {
    pub const m_footStanceInfo: usize = 0x68; // CUtlVector<StanceInfo_t>
    pub const m_pStanceSourceNode: usize = 0x80; // CAnimUpdateNodeRef
    pub const m_hParameter: usize = 0x90; // CAnimParamHandle
    pub const m_eMode: usize = 0x94; // StanceOverrideMode
}

pub mod CStanceScaleUpdateNode {
    pub const m_hParam: usize = 0x68; // CAnimParamHandle
}

pub mod CStateActionUpdater {
    pub const m_pAction: usize = 0x0; // CSmartPtr<CAnimActionUpdater>
    pub const m_eBehavior: usize = 0x8; // StateActionBehavior
}

pub mod CStateMachineComponentUpdater {
    pub const m_stateMachine: usize = 0x30; // CAnimStateMachineUpdater
}

pub mod CStateMachineUpdateNode {
    pub const m_stateMachine: usize = 0x68; // CAnimStateMachineUpdater
    pub const m_stateData: usize = 0xC0; // CUtlVector<CStateNodeStateData>
    pub const m_transitionData: usize = 0xD8; // CUtlVector<CStateNodeTransitionData>
    pub const m_bBlockWaningTags: usize = 0xF4; // bool
    pub const m_bLockStateWhenWaning: usize = 0xF5; // bool
}

pub mod CStateNodeStateData {
    pub const m_pChild: usize = 0x0; // CAnimUpdateNodeRef
    pub const m_bExclusiveRootMotion: usize = 0x0; // bitfield:1
}

pub mod CStateNodeTransitionData {
    pub const m_curve: usize = 0x0; // CBlendCurve
    pub const m_blendDuration: usize = 0x8; // CAnimValue<float>
    pub const m_resetCycleValue: usize = 0x10; // CAnimValue<float>
    pub const m_bReset: usize = 0x0; // bitfield:1
    pub const m_resetCycleOption: usize = 0x0; // bitfield:3
}

pub mod CStateUpdateData {
    pub const m_name: usize = 0x0; // CUtlString
    pub const m_hScript: usize = 0x8; // AnimScriptHandle
    pub const m_transitionIndices: usize = 0x10; // CUtlVector<int32_t>
    pub const m_actions: usize = 0x28; // CUtlVector<CStateActionUpdater>
    pub const m_stateID: usize = 0x40; // AnimStateID
    pub const m_bIsStartState: usize = 0x0; // bitfield:1
    pub const m_bIsEndState: usize = 0x0; // bitfield:1
    pub const m_bIsPassthrough: usize = 0x0; // bitfield:1
}

pub mod CStaticPoseCache {
    pub const m_poses: usize = 0x10; // CUtlVector<CCachedPose>
    pub const m_nBoneCount: usize = 0x28; // int32_t
    pub const m_nMorphCount: usize = 0x2C; // int32_t
}

pub mod CStepsRemainingMetricEvaluator {
    pub const m_footIndices: usize = 0x50; // CUtlVector<int32_t>
    pub const m_flMinStepsRemaining: usize = 0x68; // float
}

pub mod CStopAtGoalUpdateNode {
    pub const m_flOuterRadius: usize = 0x6C; // float
    pub const m_flInnerRadius: usize = 0x70; // float
    pub const m_flMaxScale: usize = 0x74; // float
    pub const m_flMinScale: usize = 0x78; // float
    pub const m_damping: usize = 0x80; // CAnimInputDamping
}

pub mod CSubtractUpdateNode {
    pub const m_footMotionTiming: usize = 0x8C; // BinaryNodeChildOption
    pub const m_bApplyToFootMotion: usize = 0x90; // bool
    pub const m_bApplyChannelsSeparately: usize = 0x91; // bool
    pub const m_bUseModelSpace: usize = 0x92; // bool
}

pub mod CTiltTwistConstraint {
    pub const m_nTargetAxis: usize = 0x70; // int32_t
    pub const m_nSlaveAxis: usize = 0x74; // int32_t
}

pub mod CTimeRemainingMetricEvaluator {
    pub const m_bMatchByTimeRemaining: usize = 0x50; // bool
    pub const m_flMaxTimeRemaining: usize = 0x54; // float
    pub const m_bFilterByTimeRemaining: usize = 0x58; // bool
    pub const m_flMinTimeRemaining: usize = 0x5C; // float
}

pub mod CToggleComponentActionUpdater {
    pub const m_componentID: usize = 0x18; // AnimComponentID
    pub const m_bSetEnabled: usize = 0x1C; // bool
}

pub mod CTransitionUpdateData {
    pub const m_srcStateIndex: usize = 0x0; // uint8_t
    pub const m_destStateIndex: usize = 0x1; // uint8_t
    pub const m_bDisabled: usize = 0x0; // bitfield:1
}

pub mod CTurnHelperUpdateNode {
    pub const m_facingTarget: usize = 0x6C; // AnimValueSource
    pub const m_turnStartTimeOffset: usize = 0x70; // float
    pub const m_turnDuration: usize = 0x74; // float
    pub const m_bMatchChildDuration: usize = 0x78; // bool
    pub const m_manualTurnOffset: usize = 0x7C; // float
    pub const m_bUseManualTurnOffset: usize = 0x80; // bool
}

pub mod CTwistConstraint {
    pub const m_bInverse: usize = 0x70; // bool
    pub const m_qParentBindRotation: usize = 0x80; // Quaternion
    pub const m_qChildBindRotation: usize = 0x90; // Quaternion
}

pub mod CTwoBoneIKUpdateNode {
    pub const m_opFixedData: usize = 0x70; // TwoBoneIKSettings_t
}

pub mod CUnaryUpdateNode {
    pub const m_pChildNode: usize = 0x58; // CAnimUpdateNodeRef
}

pub mod CVPhysXSurfacePropertiesList {
    pub const m_surfacePropertiesList: usize = 0x0; // CUtlVector<CPhysSurfaceProperties*>
}

pub mod CVRInputComponentUpdater {
    pub const m_FingerCurl_Thumb: usize = 0x34; // CAnimParamHandle
    pub const m_FingerCurl_Index: usize = 0x36; // CAnimParamHandle
    pub const m_FingerCurl_Middle: usize = 0x38; // CAnimParamHandle
    pub const m_FingerCurl_Ring: usize = 0x3A; // CAnimParamHandle
    pub const m_FingerCurl_Pinky: usize = 0x3C; // CAnimParamHandle
    pub const m_FingerSplay_Thumb_Index: usize = 0x3E; // CAnimParamHandle
    pub const m_FingerSplay_Index_Middle: usize = 0x40; // CAnimParamHandle
    pub const m_FingerSplay_Middle_Ring: usize = 0x42; // CAnimParamHandle
    pub const m_FingerSplay_Ring_Pinky: usize = 0x44; // CAnimParamHandle
}

pub mod CVectorAnimParameter {
    pub const m_defaultValue: usize = 0x60; // Vector
    pub const m_bInterpolate: usize = 0x6C; // bool
}

pub mod CVectorQuantizer {
    pub const m_centroidVectors: usize = 0x0; // CUtlVector<float>
    pub const m_nCentroids: usize = 0x18; // int32_t
    pub const m_nDimensions: usize = 0x1C; // int32_t
}

pub mod CVirtualAnimParameter {
    pub const m_expressionString: usize = 0x50; // CUtlString
    pub const m_eParamType: usize = 0x58; // AnimParamType_t
}

pub mod CVrSkeletalInputSettings {
    pub const m_wristBones: usize = 0x0; // CUtlVector<CWristBone>
    pub const m_fingers: usize = 0x18; // CUtlVector<CFingerChain>
    pub const m_name: usize = 0x30; // CUtlString
    pub const m_outerKnuckle1: usize = 0x38; // CUtlString
    pub const m_outerKnuckle2: usize = 0x40; // CUtlString
    pub const m_eHand: usize = 0x48; // AnimVRHand_t
}

pub mod CWayPointHelperUpdateNode {
    pub const m_flStartCycle: usize = 0x6C; // float
    pub const m_flEndCycle: usize = 0x70; // float
    pub const m_bOnlyGoals: usize = 0x74; // bool
    pub const m_bPreventOvershoot: usize = 0x75; // bool
    pub const m_bPreventUndershoot: usize = 0x76; // bool
}

pub mod CWristBone {
    pub const m_name: usize = 0x0; // CUtlString
    pub const m_vForwardLS: usize = 0x8; // Vector
    pub const m_vUpLS: usize = 0x14; // Vector
    pub const m_vOffset: usize = 0x20; // Vector
}

pub mod ChainToSolveData_t {
    pub const m_nChainIndex: usize = 0x0; // int32_t
    pub const m_SolverSettings: usize = 0x4; // IKSolverSettings_t
    pub const m_TargetSettings: usize = 0x10; // IKTargetSettings_t
    pub const m_DebugSetting: usize = 0x38; // SolveIKChainAnimNodeDebugSetting
    pub const m_flDebugNormalizedValue: usize = 0x3C; // float
    pub const m_vDebugOffset: usize = 0x40; // VectorAligned
}

pub mod ConfigIndex {
    pub const m_nGroup: usize = 0x0; // uint16_t
    pub const m_nConfig: usize = 0x2; // uint16_t
}

pub mod FingerBone_t {
    pub const m_boneIndex: usize = 0x0; // int32_t
    pub const m_hingeAxis: usize = 0x4; // Vector
    pub const m_vCapsulePos1: usize = 0x10; // Vector
    pub const m_vCapsulePos2: usize = 0x1C; // Vector
    pub const m_flMinAngle: usize = 0x28; // float
    pub const m_flMaxAngle: usize = 0x2C; // float
    pub const m_flRadius: usize = 0x30; // float
}

pub mod FingerChain_t {
    pub const m_targets: usize = 0x0; // CUtlVector<FingerSource_t>
    pub const m_bones: usize = 0x18; // CUtlVector<FingerBone_t>
    pub const m_vTipOffset: usize = 0x30; // Vector
    pub const m_vSplayHingeAxis: usize = 0x3C; // Vector
    pub const m_tipParentBoneIndex: usize = 0x48; // int32_t
    pub const m_metacarpalBoneIndex: usize = 0x4C; // int32_t
    pub const m_flSplayMinAngle: usize = 0x50; // float
    pub const m_flSplayMaxAngle: usize = 0x54; // float
    pub const m_flFingerScaleRatio: usize = 0x58; // float
}

pub mod FingerSource_t {
    pub const m_nFingerIndex: usize = 0x0; // AnimVRFinger_t
    pub const m_flFingerWeight: usize = 0x4; // float
}

pub mod FollowAttachmentSettings_t {
    pub const m_attachment: usize = 0x0; // CAnimAttachment
    pub const m_boneIndex: usize = 0x80; // int32_t
    pub const m_bMatchTranslation: usize = 0x84; // bool
    pub const m_bMatchRotation: usize = 0x85; // bool
}

pub mod FootFixedData_t {
    pub const m_vToeOffset: usize = 0x0; // VectorAligned
    pub const m_vHeelOffset: usize = 0x10; // VectorAligned
    pub const m_nTargetBoneIndex: usize = 0x20; // int32_t
    pub const m_nAnkleBoneIndex: usize = 0x24; // int32_t
    pub const m_nIKAnchorBoneIndex: usize = 0x28; // int32_t
    pub const m_ikChainIndex: usize = 0x2C; // int32_t
    pub const m_flMaxIKLength: usize = 0x30; // float
    pub const m_nFootIndex: usize = 0x34; // int32_t
    pub const m_nTagIndex: usize = 0x38; // int32_t
    pub const m_flMaxRotationLeft: usize = 0x3C; // float
    pub const m_flMaxRotationRight: usize = 0x40; // float
}

pub mod FootFixedSettings {
    pub const m_traceSettings: usize = 0x0; // TraceSettings_t
    pub const m_vFootBaseBindPosePositionMS: usize = 0x10; // VectorAligned
    pub const m_flFootBaseLength: usize = 0x20; // float
    pub const m_flMaxRotationLeft: usize = 0x24; // float
    pub const m_flMaxRotationRight: usize = 0x28; // float
    pub const m_footstepLandedTagIndex: usize = 0x2C; // int32_t
    pub const m_bEnableTracing: usize = 0x30; // bool
    pub const m_flTraceAngleBlend: usize = 0x34; // float
    pub const m_nDisableTagIndex: usize = 0x38; // int32_t
    pub const m_nFootIndex: usize = 0x3C; // int32_t
}

pub mod FootLockPoseOpFixedSettings {
    pub const m_footInfo: usize = 0x0; // CUtlVector<FootFixedData_t>
    pub const m_hipDampingSettings: usize = 0x18; // CAnimInputDamping
    pub const m_nHipBoneIndex: usize = 0x28; // int32_t
    pub const m_ikSolverType: usize = 0x2C; // IKSolverType
    pub const m_bApplyTilt: usize = 0x30; // bool
    pub const m_bApplyHipDrop: usize = 0x31; // bool
    pub const m_bAlwaysUseFallbackHinge: usize = 0x32; // bool
    pub const m_bApplyFootRotationLimits: usize = 0x33; // bool
    pub const m_bApplyLegTwistLimits: usize = 0x34; // bool
    pub const m_flMaxFootHeight: usize = 0x38; // float
    pub const m_flExtensionScale: usize = 0x3C; // float
    pub const m_flMaxLegTwist: usize = 0x40; // float
    pub const m_bEnableLockBreaking: usize = 0x44; // bool
    pub const m_flLockBreakTolerance: usize = 0x48; // float
    pub const m_flLockBlendTime: usize = 0x4C; // float
    pub const m_bEnableStretching: usize = 0x50; // bool
    pub const m_flMaxStretchAmount: usize = 0x54; // float
    pub const m_flStretchExtensionScale: usize = 0x58; // float
}

pub mod FootPinningPoseOpFixedData_t {
    pub const m_footInfo: usize = 0x0; // CUtlVector<FootFixedData_t>
    pub const m_flBlendTime: usize = 0x18; // float
    pub const m_flLockBreakDistance: usize = 0x1C; // float
    pub const m_flMaxLegTwist: usize = 0x20; // float
    pub const m_nHipBoneIndex: usize = 0x24; // int32_t
    pub const m_bApplyLegTwistLimits: usize = 0x28; // bool
    pub const m_bApplyFootRotationLimits: usize = 0x29; // bool
}

pub mod FootStepTrigger {
    pub const m_tags: usize = 0x0; // CUtlVector<int32_t>
    pub const m_nFootIndex: usize = 0x18; // int32_t
    pub const m_triggerPhase: usize = 0x1C; // StepPhase
}

pub mod HSequence {
    pub const m_Value: usize = 0x0; // int32_t
}

pub mod HitReactFixedSettings_t {
    pub const m_nWeightListIndex: usize = 0x0; // int32_t
    pub const m_nEffectedBoneCount: usize = 0x4; // int32_t
    pub const m_flMaxImpactForce: usize = 0x8; // float
    pub const m_flMinImpactForce: usize = 0xC; // float
    pub const m_flWhipImpactScale: usize = 0x10; // float
    pub const m_flCounterRotationScale: usize = 0x14; // float
    pub const m_flDistanceFadeScale: usize = 0x18; // float
    pub const m_flPropagationScale: usize = 0x1C; // float
    pub const m_flWhipDelay: usize = 0x20; // float
    pub const m_flSpringStrength: usize = 0x24; // float
    pub const m_flWhipSpringStrength: usize = 0x28; // float
    pub const m_flMaxAngleRadians: usize = 0x2C; // float
    pub const m_nHipBoneIndex: usize = 0x30; // int32_t
    pub const m_flHipBoneTranslationScale: usize = 0x34; // float
    pub const m_flHipDipSpringStrength: usize = 0x38; // float
    pub const m_flHipDipImpactScale: usize = 0x3C; // float
    pub const m_flHipDipDelay: usize = 0x40; // float
}

pub mod IKBoneNameAndIndex_t {
    pub const m_Name: usize = 0x0; // CUtlString
}

pub mod IKDemoCaptureSettings_t {
    pub const m_parentBoneName: usize = 0x0; // CUtlString
    pub const m_eMode: usize = 0x8; // IKChannelMode
    pub const m_ikChainName: usize = 0x10; // CUtlString
    pub const m_oneBoneStart: usize = 0x18; // CUtlString
    pub const m_oneBoneEnd: usize = 0x20; // CUtlString
}

pub mod IKSolverSettings_t {
    pub const m_SolverType: usize = 0x0; // IKSolverType
    pub const m_nNumIterations: usize = 0x4; // int32_t
}

pub mod IKTargetSettings_t {
    pub const m_TargetSource: usize = 0x0; // IKTargetSource
    pub const m_Bone: usize = 0x8; // IKBoneNameAndIndex_t
    pub const m_AnimgraphParameterNamePosition: usize = 0x18; // AnimParamID
    pub const m_AnimgraphParameterNameOrientation: usize = 0x1C; // AnimParamID
    pub const m_TargetCoordSystem: usize = 0x20; // IKTargetCoordinateSystem
}

pub mod JiggleBoneSettingsList_t {
    pub const m_boneSettings: usize = 0x0; // CUtlVector<JiggleBoneSettings_t>
}

pub mod JiggleBoneSettings_t {
    pub const m_nBoneIndex: usize = 0x0; // int32_t
    pub const m_flSpringStrength: usize = 0x4; // float
    pub const m_flMaxTimeStep: usize = 0x8; // float
    pub const m_flDamping: usize = 0xC; // float
    pub const m_vBoundsMaxLS: usize = 0x10; // Vector
    pub const m_vBoundsMinLS: usize = 0x1C; // Vector
    pub const m_eSimSpace: usize = 0x28; // JiggleBoneSimSpace
}

pub mod LookAtBone_t {
    pub const m_index: usize = 0x0; // int32_t
    pub const m_weight: usize = 0x4; // float
}

pub mod LookAtOpFixedSettings_t {
    pub const m_attachment: usize = 0x0; // CAnimAttachment
    pub const m_damping: usize = 0x80; // CAnimInputDamping
    pub const m_bones: usize = 0x90; // CUtlVector<LookAtBone_t>
    pub const m_flYawLimit: usize = 0xA8; // float
    pub const m_flPitchLimit: usize = 0xAC; // float
    pub const m_flHysteresisInnerAngle: usize = 0xB0; // float
    pub const m_flHysteresisOuterAngle: usize = 0xB4; // float
    pub const m_bRotateYawForward: usize = 0xB8; // bool
    pub const m_bMaintainUpDirection: usize = 0xB9; // bool
    pub const m_bTargetIsPosition: usize = 0xBA; // bool
    pub const m_bUseHysteresis: usize = 0xBB; // bool
}

pub mod MaterialGroup_t {
    pub const m_name: usize = 0x0; // CUtlString
    pub const m_materials: usize = 0x8; // CUtlVector<CStrongHandle<InfoForResourceTypeIMaterial2>>
}

pub mod ModelBoneFlexDriverControl_t {
    pub const m_nBoneComponent: usize = 0x0; // ModelBoneFlexComponent_t
    pub const m_flexController: usize = 0x8; // CUtlString
    pub const m_flexControllerToken: usize = 0x10; // uint32_t
    pub const m_flMin: usize = 0x14; // float
    pub const m_flMax: usize = 0x18; // float
}

pub mod ModelBoneFlexDriver_t {
    pub const m_boneName: usize = 0x0; // CUtlString
    pub const m_boneNameToken: usize = 0x8; // uint32_t
    pub const m_controls: usize = 0x10; // CUtlVector<ModelBoneFlexDriverControl_t>
}

pub mod ModelSkeletonData_t {
    pub const m_boneName: usize = 0x0; // CUtlVector<CUtlString>
    pub const m_nParent: usize = 0x18; // CUtlVector<int16_t>
    pub const m_boneSphere: usize = 0x30; // CUtlVector<float>
    pub const m_nFlag: usize = 0x48; // CUtlVector<uint32_t>
    pub const m_bonePosParent: usize = 0x60; // CUtlVector<Vector>
    pub const m_boneRotParent: usize = 0x78; // CUtlVector<QuaternionStorage>
    pub const m_boneScaleParent: usize = 0x90; // CUtlVector<float>
}

pub mod MoodAnimationLayer_t {
    pub const m_sName: usize = 0x0; // CUtlString
    pub const m_bActiveListening: usize = 0x8; // bool
    pub const m_bActiveTalking: usize = 0x9; // bool
    pub const m_layerAnimations: usize = 0x10; // CUtlVector<MoodAnimation_t>
    pub const m_flIntensity: usize = 0x28; // CRangeFloat
    pub const m_flDurationScale: usize = 0x30; // CRangeFloat
    pub const m_bScaleWithInts: usize = 0x38; // bool
    pub const m_flNextStart: usize = 0x3C; // CRangeFloat
    pub const m_flStartOffset: usize = 0x44; // CRangeFloat
    pub const m_flEndOffset: usize = 0x4C; // CRangeFloat
    pub const m_flFadeIn: usize = 0x54; // float
    pub const m_flFadeOut: usize = 0x58; // float
}

pub mod MoodAnimation_t {
    pub const m_sName: usize = 0x0; // CUtlString
    pub const m_flWeight: usize = 0x8; // float
}

pub mod MotionBlendItem {
    pub const m_pChild: usize = 0x0; // CSmartPtr<CMotionNode>
    pub const m_flKeyValue: usize = 0x8; // float
}

pub mod MotionDBIndex {
    pub const m_nIndex: usize = 0x0; // uint32_t
}

pub mod MotionIndex {
    pub const m_nGroup: usize = 0x0; // uint16_t
    pub const m_nMotion: usize = 0x2; // uint16_t
}

pub mod ParamSpanSample_t {
    pub const m_value: usize = 0x0; // CAnimVariant
    pub const m_flCycle: usize = 0x14; // float
}

pub mod ParamSpan_t {
    pub const m_samples: usize = 0x0; // CUtlVector<ParamSpanSample_t>
    pub const m_hParam: usize = 0x18; // CAnimParamHandle
    pub const m_eParamType: usize = 0x1A; // AnimParamType_t
    pub const m_flStartCycle: usize = 0x1C; // float
    pub const m_flEndCycle: usize = 0x20; // float
}

pub mod PermModelDataAnimatedMaterialAttribute_t {
    pub const m_AttributeName: usize = 0x0; // CUtlString
    pub const m_nNumChannels: usize = 0x8; // int32_t
}

pub mod PermModelData_t {
    pub const m_name: usize = 0x0; // CUtlString
    pub const m_modelInfo: usize = 0x8; // PermModelInfo_t
    pub const m_ExtParts: usize = 0x60; // CUtlVector<PermModelExtPart_t>
    pub const m_refMeshes: usize = 0x78; // CUtlVector<CStrongHandle<InfoForResourceTypeCRenderMesh>>
    pub const m_refMeshGroupMasks: usize = 0x90; // CUtlVector<uint64_t>
    pub const m_refPhysGroupMasks: usize = 0xA8; // CUtlVector<uint64_t>
    pub const m_refLODGroupMasks: usize = 0xC0; // CUtlVector<uint8_t>
    pub const m_lodGroupSwitchDistances: usize = 0xD8; // CUtlVector<float>
    pub const m_refPhysicsData: usize = 0xF0; // CUtlVector<CStrongHandle<InfoForResourceTypeCPhysAggregateData>>
    pub const m_refPhysicsHitboxData: usize = 0x108; // CUtlVector<CStrongHandle<InfoForResourceTypeCPhysAggregateData>>
    pub const m_refAnimGroups: usize = 0x120; // CUtlVector<CStrongHandle<InfoForResourceTypeCAnimationGroup>>
    pub const m_refSequenceGroups: usize = 0x138; // CUtlVector<CStrongHandle<InfoForResourceTypeCSequenceGroupData>>
    pub const m_meshGroups: usize = 0x150; // CUtlVector<CUtlString>
    pub const m_materialGroups: usize = 0x168; // CUtlVector<MaterialGroup_t>
    pub const m_nDefaultMeshGroupMask: usize = 0x180; // uint64_t
    pub const m_modelSkeleton: usize = 0x188; // ModelSkeletonData_t
    pub const m_remappingTable: usize = 0x230; // CUtlVector<int16_t>
    pub const m_remappingTableStarts: usize = 0x248; // CUtlVector<uint16_t>
    pub const m_boneFlexDrivers: usize = 0x260; // CUtlVector<ModelBoneFlexDriver_t>
    pub const m_pModelConfigList: usize = 0x278; // CModelConfigList*
    pub const m_BodyGroupsHiddenInTools: usize = 0x280; // CUtlVector<CUtlString>
    pub const m_refAnimIncludeModels: usize = 0x298; // CUtlVector<CStrongHandle<InfoForResourceTypeCModel>>
    pub const m_AnimatedMaterialAttributes: usize = 0x2B0; // CUtlVector<PermModelDataAnimatedMaterialAttribute_t>
}

pub mod PermModelExtPart_t {
    pub const m_Transform: usize = 0x0; // CTransform
    pub const m_Name: usize = 0x20; // CUtlString
    pub const m_nParent: usize = 0x28; // int32_t
    pub const m_refModel: usize = 0x30; // CStrongHandle<InfoForResourceTypeCModel>
}

pub mod PermModelInfo_t {
    pub const m_nFlags: usize = 0x0; // uint32_t
    pub const m_vHullMin: usize = 0x4; // Vector
    pub const m_vHullMax: usize = 0x10; // Vector
    pub const m_vViewMin: usize = 0x1C; // Vector
    pub const m_vViewMax: usize = 0x28; // Vector
    pub const m_flMass: usize = 0x34; // float
    pub const m_vEyePosition: usize = 0x38; // Vector
    pub const m_flMaxEyeDeflection: usize = 0x44; // float
    pub const m_sSurfaceProperty: usize = 0x48; // CUtlString
    pub const m_keyValueText: usize = 0x50; // CUtlString
}

pub mod PhysSoftbodyDesc_t {
    pub const m_ParticleBoneHash: usize = 0x0; // CUtlVector<uint32_t>
    pub const m_Particles: usize = 0x18; // CUtlVector<RnSoftbodyParticle_t>
    pub const m_Springs: usize = 0x30; // CUtlVector<RnSoftbodySpring_t>
    pub const m_Capsules: usize = 0x48; // CUtlVector<RnSoftbodyCapsule_t>
    pub const m_InitPose: usize = 0x60; // CUtlVector<CTransform>
    pub const m_ParticleBoneName: usize = 0x78; // CUtlVector<CUtlString>
}

pub mod RenderSkeletonBone_t {
    pub const m_boneName: usize = 0x0; // CUtlString
    pub const m_parentName: usize = 0x8; // CUtlString
    pub const m_invBindPose: usize = 0x10; // matrix3x4_t
    pub const m_bbox: usize = 0x40; // SkeletonBoneBounds_t
    pub const m_flSphereRadius: usize = 0x58; // float
}

pub mod SampleCode {
    pub const m_subCode: usize = 0x0; // uint8_t[8]
}

pub mod ScriptInfo_t {
    pub const m_code: usize = 0x0; // CUtlString
    pub const m_paramsModified: usize = 0x8; // CUtlVector<CAnimParamHandle>
    pub const m_proxyReadParams: usize = 0x20; // CUtlVector<int32_t>
    pub const m_proxyWriteParams: usize = 0x38; // CUtlVector<int32_t>
    pub const m_eScriptType: usize = 0x50; // AnimScriptType
}

pub mod SkeletalInputOpFixedSettings_t {
    pub const m_wristBones: usize = 0x0; // CUtlVector<WristBone_t>
    pub const m_fingers: usize = 0x18; // CUtlVector<FingerChain_t>
    pub const m_outerKnuckle1: usize = 0x30; // int32_t
    pub const m_outerKnuckle2: usize = 0x34; // int32_t
    pub const m_eHand: usize = 0x38; // AnimVRHand_t
    pub const m_eMotionRange: usize = 0x3C; // AnimVRHandMotionRange_t
    pub const m_eTransformSource: usize = 0x40; // AnimVrBoneTransformSource_t
    pub const m_bEnableIK: usize = 0x44; // bool
    pub const m_bEnableCollision: usize = 0x45; // bool
}

pub mod SkeletonBoneBounds_t {
    pub const m_vecCenter: usize = 0x0; // Vector
    pub const m_vecSize: usize = 0xC; // Vector
}

pub mod SolveIKChainPoseOpFixedSettings_t {
    pub const m_ChainsToSolveData: usize = 0x0; // CUtlVector<ChainToSolveData_t>
    pub const m_bMatchTargetOrientation: usize = 0x18; // bool
}

pub mod StanceInfo_t {
    pub const m_vPosition: usize = 0x0; // Vector
    pub const m_flDirection: usize = 0xC; // float
}

pub mod TagSpan_t {
    pub const m_tagIndex: usize = 0x0; // int32_t
    pub const m_startCycle: usize = 0x4; // float
    pub const m_endCycle: usize = 0x8; // float
}

pub mod TraceSettings_t {
    pub const m_flTraceHeight: usize = 0x0; // float
    pub const m_flTraceRadius: usize = 0x4; // float
}

pub mod TwoBoneIKSettings_t {
    pub const m_endEffectorType: usize = 0x0; // IkEndEffectorType
    pub const m_endEffectorAttachment: usize = 0x10; // CAnimAttachment
    pub const m_targetType: usize = 0x90; // IkTargetType
    pub const m_targetAttachment: usize = 0xA0; // CAnimAttachment
    pub const m_targetBoneIndex: usize = 0x120; // int32_t
    pub const m_hPositionParam: usize = 0x124; // CAnimParamHandle
    pub const m_hRotationParam: usize = 0x126; // CAnimParamHandle
    pub const m_bAlwaysUseFallbackHinge: usize = 0x128; // bool
    pub const m_vLsFallbackHingeAxis: usize = 0x130; // VectorAligned
    pub const m_nFixedBoneIndex: usize = 0x140; // int32_t
    pub const m_nMiddleBoneIndex: usize = 0x144; // int32_t
    pub const m_nEndBoneIndex: usize = 0x148; // int32_t
    pub const m_bMatchTargetOrientation: usize = 0x14C; // bool
    pub const m_bConstrainTwist: usize = 0x14D; // bool
    pub const m_flMaxTwist: usize = 0x150; // float
}

pub mod VPhysXAggregateData_t {
    pub const m_nFlags: usize = 0x0; // uint16_t
    pub const m_nRefCounter: usize = 0x2; // uint16_t
    pub const m_bonesHash: usize = 0x8; // CUtlVector<uint32_t>
    pub const m_boneNames: usize = 0x20; // CUtlVector<CUtlString>
    pub const m_indexNames: usize = 0x38; // CUtlVector<uint16_t>
    pub const m_indexHash: usize = 0x50; // CUtlVector<uint16_t>
    pub const m_bindPose: usize = 0x68; // CUtlVector<matrix3x4a_t>
    pub const m_parts: usize = 0x80; // CUtlVector<VPhysXBodyPart_t>
    pub const m_constraints2: usize = 0x98; // CUtlVector<VPhysXConstraint2_t>
    pub const m_joints: usize = 0xB0; // CUtlVector<VPhysXJoint_t>
    pub const m_pFeModel: usize = 0xC8; // PhysFeModelDesc_t*
    pub const m_boneParents: usize = 0xD0; // CUtlVector<uint16_t>
    pub const m_surfacePropertyHashes: usize = 0xE8; // CUtlVector<uint32_t>
    pub const m_collisionAttributes: usize = 0x100; // CUtlVector<VPhysXCollisionAttributes_t>
    pub const m_debugPartNames: usize = 0x118; // CUtlVector<CUtlString>
    pub const m_embeddedKeyvalues: usize = 0x130; // CUtlString
}

pub mod VPhysXBodyPart_t {
    pub const m_nFlags: usize = 0x0; // uint32_t
    pub const m_flMass: usize = 0x4; // float
    pub const m_rnShape: usize = 0x8; // VPhysics2ShapeDef_t
    pub const m_nCollisionAttributeIndex: usize = 0x80; // uint16_t
    pub const m_nReserved: usize = 0x82; // uint16_t
    pub const m_flInertiaScale: usize = 0x84; // float
    pub const m_flLinearDamping: usize = 0x88; // float
    pub const m_flAngularDamping: usize = 0x8C; // float
    pub const m_bOverrideMassCenter: usize = 0x90; // bool
    pub const m_vMassCenterOverride: usize = 0x94; // Vector
}

pub mod VPhysXCollisionAttributes_t {
    pub const m_CollisionGroup: usize = 0x0; // uint32_t
    pub const m_InteractAs: usize = 0x8; // CUtlVector<uint32_t>
    pub const m_InteractWith: usize = 0x20; // CUtlVector<uint32_t>
    pub const m_InteractExclude: usize = 0x38; // CUtlVector<uint32_t>
    pub const m_CollisionGroupString: usize = 0x50; // CUtlString
    pub const m_InteractAsStrings: usize = 0x58; // CUtlVector<CUtlString>
    pub const m_InteractWithStrings: usize = 0x70; // CUtlVector<CUtlString>
    pub const m_InteractExcludeStrings: usize = 0x88; // CUtlVector<CUtlString>
}

pub mod VPhysXConstraint2_t {
    pub const m_nFlags: usize = 0x0; // uint32_t
    pub const m_nParent: usize = 0x4; // uint16_t
    pub const m_nChild: usize = 0x6; // uint16_t
    pub const m_params: usize = 0x8; // VPhysXConstraintParams_t
}

pub mod VPhysXConstraintParams_t {
    pub const m_nType: usize = 0x0; // int8_t
    pub const m_nTranslateMotion: usize = 0x1; // int8_t
    pub const m_nRotateMotion: usize = 0x2; // int8_t
    pub const m_nFlags: usize = 0x3; // int8_t
    pub const m_anchor: usize = 0x4; // Vector[2]
    pub const m_axes: usize = 0x1C; // QuaternionStorage[2]
    pub const m_maxForce: usize = 0x3C; // float
    pub const m_maxTorque: usize = 0x40; // float
    pub const m_linearLimitValue: usize = 0x44; // float
    pub const m_linearLimitRestitution: usize = 0x48; // float
    pub const m_linearLimitSpring: usize = 0x4C; // float
    pub const m_linearLimitDamping: usize = 0x50; // float
    pub const m_twistLowLimitValue: usize = 0x54; // float
    pub const m_twistLowLimitRestitution: usize = 0x58; // float
    pub const m_twistLowLimitSpring: usize = 0x5C; // float
    pub const m_twistLowLimitDamping: usize = 0x60; // float
    pub const m_twistHighLimitValue: usize = 0x64; // float
    pub const m_twistHighLimitRestitution: usize = 0x68; // float
    pub const m_twistHighLimitSpring: usize = 0x6C; // float
    pub const m_twistHighLimitDamping: usize = 0x70; // float
    pub const m_swing1LimitValue: usize = 0x74; // float
    pub const m_swing1LimitRestitution: usize = 0x78; // float
    pub const m_swing1LimitSpring: usize = 0x7C; // float
    pub const m_swing1LimitDamping: usize = 0x80; // float
    pub const m_swing2LimitValue: usize = 0x84; // float
    pub const m_swing2LimitRestitution: usize = 0x88; // float
    pub const m_swing2LimitSpring: usize = 0x8C; // float
    pub const m_swing2LimitDamping: usize = 0x90; // float
    pub const m_goalPosition: usize = 0x94; // Vector
    pub const m_goalOrientation: usize = 0xA0; // QuaternionStorage
    pub const m_goalAngularVelocity: usize = 0xB0; // Vector
    pub const m_driveSpringX: usize = 0xBC; // float
    pub const m_driveSpringY: usize = 0xC0; // float
    pub const m_driveSpringZ: usize = 0xC4; // float
    pub const m_driveDampingX: usize = 0xC8; // float
    pub const m_driveDampingY: usize = 0xCC; // float
    pub const m_driveDampingZ: usize = 0xD0; // float
    pub const m_driveSpringTwist: usize = 0xD4; // float
    pub const m_driveSpringSwing: usize = 0xD8; // float
    pub const m_driveSpringSlerp: usize = 0xDC; // float
    pub const m_driveDampingTwist: usize = 0xE0; // float
    pub const m_driveDampingSwing: usize = 0xE4; // float
    pub const m_driveDampingSlerp: usize = 0xE8; // float
    pub const m_solverIterationCount: usize = 0xEC; // int32_t
    pub const m_projectionLinearTolerance: usize = 0xF0; // float
    pub const m_projectionAngularTolerance: usize = 0xF4; // float
}

pub mod VPhysXJoint_t {
    pub const m_nType: usize = 0x0; // uint16_t
    pub const m_nBody1: usize = 0x2; // uint16_t
    pub const m_nBody2: usize = 0x4; // uint16_t
    pub const m_nFlags: usize = 0x6; // uint16_t
    pub const m_Frame1: usize = 0x10; // CTransform
    pub const m_Frame2: usize = 0x30; // CTransform
    pub const m_bEnableCollision: usize = 0x50; // bool
    pub const m_bEnableLinearLimit: usize = 0x51; // bool
    pub const m_LinearLimit: usize = 0x54; // VPhysXRange_t
    pub const m_bEnableLinearMotor: usize = 0x5C; // bool
    pub const m_vLinearTargetVelocity: usize = 0x60; // Vector
    pub const m_flMaxForce: usize = 0x6C; // float
    pub const m_bEnableSwingLimit: usize = 0x70; // bool
    pub const m_SwingLimit: usize = 0x74; // VPhysXRange_t
    pub const m_bEnableTwistLimit: usize = 0x7C; // bool
    pub const m_TwistLimit: usize = 0x80; // VPhysXRange_t
    pub const m_bEnableAngularMotor: usize = 0x88; // bool
    pub const m_vAngularTargetVelocity: usize = 0x8C; // Vector
    pub const m_flMaxTorque: usize = 0x98; // float
    pub const m_flLinearFrequency: usize = 0x9C; // float
    pub const m_flLinearDampingRatio: usize = 0xA0; // float
    pub const m_flAngularFrequency: usize = 0xA4; // float
    pub const m_flAngularDampingRatio: usize = 0xA8; // float
    pub const m_flFriction: usize = 0xAC; // float
}

pub mod VPhysXRange_t {
    pub const m_flMin: usize = 0x0; // float
    pub const m_flMax: usize = 0x4; // float
}

pub mod VPhysics2ShapeDef_t {
    pub const m_spheres: usize = 0x0; // CUtlVector<RnSphereDesc_t>
    pub const m_capsules: usize = 0x18; // CUtlVector<RnCapsuleDesc_t>
    pub const m_hulls: usize = 0x30; // CUtlVector<RnHullDesc_t>
    pub const m_meshes: usize = 0x48; // CUtlVector<RnMeshDesc_t>
    pub const m_CollisionAttributeIndices: usize = 0x60; // CUtlVector<uint16_t>
}

pub mod WeightList {
    pub const m_name: usize = 0x0; // CUtlString
    pub const m_weights: usize = 0x8; // CUtlVector<float>
}

pub mod WristBone_t {
    pub const m_xOffsetTransformMS: usize = 0x0; // CTransform
    pub const m_boneIndex: usize = 0x20; // int32_t
}
```

`SDK/client.dll.cs`:

```cs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:27.137267200 UTC
 */

public static class ActiveModelConfig_t {
    public const nint m_Handle = 0x28; // ModelConfigHandle_t
    public const nint m_Name = 0x30; // CUtlSymbolLarge
    public const nint m_AssociatedEntities = 0x38; // C_NetworkUtlVectorBase<CHandle<C_BaseModelEntity>>
    public const nint m_AssociatedEntityNames = 0x50; // C_NetworkUtlVectorBase<CUtlSymbolLarge>
}

public static class CAnimGraphNetworkedVariables {
    public const nint m_PredNetBoolVariables = 0x8; // C_NetworkUtlVectorBase<uint32_t>
    public const nint m_PredNetByteVariables = 0x20; // C_NetworkUtlVectorBase<uint8_t>
    public const nint m_PredNetUInt16Variables = 0x38; // C_NetworkUtlVectorBase<uint16_t>
    public const nint m_PredNetIntVariables = 0x50; // C_NetworkUtlVectorBase<int32_t>
    public const nint m_PredNetUInt32Variables = 0x68; // C_NetworkUtlVectorBase<uint32_t>
    public const nint m_PredNetUInt64Variables = 0x80; // C_NetworkUtlVectorBase<uint64_t>
    public const nint m_PredNetFloatVariables = 0x98; // C_NetworkUtlVectorBase<float>
    public const nint m_PredNetVectorVariables = 0xB0; // C_NetworkUtlVectorBase<Vector>
    public const nint m_PredNetQuaternionVariables = 0xC8; // C_NetworkUtlVectorBase<Quaternion>
    public const nint m_OwnerOnlyPredNetBoolVariables = 0xE0; // C_NetworkUtlVectorBase<uint32_t>
    public const nint m_OwnerOnlyPredNetByteVariables = 0xF8; // C_NetworkUtlVectorBase<uint8_t>
    public const nint m_OwnerOnlyPredNetUInt16Variables = 0x110; // C_NetworkUtlVectorBase<uint16_t>
    public const nint m_OwnerOnlyPredNetIntVariables = 0x128; // C_NetworkUtlVectorBase<int32_t>
    public const nint m_OwnerOnlyPredNetUInt32Variables = 0x140; // C_NetworkUtlVectorBase<uint32_t>
    public const nint m_OwnerOnlyPredNetUInt64Variables = 0x158; // C_NetworkUtlVectorBase<uint64_t>
    public const nint m_OwnerOnlyPredNetFloatVariables = 0x170; // C_NetworkUtlVectorBase<float>
    public const nint m_OwnerOnlyPredNetVectorVariables = 0x188; // C_NetworkUtlVectorBase<Vector>
    public const nint m_OwnerOnlyPredNetQuaternionVariables = 0x1A0; // C_NetworkUtlVectorBase<Quaternion>
    public const nint m_nBoolVariablesCount = 0x1B8; // int32_t
    public const nint m_nOwnerOnlyBoolVariablesCount = 0x1BC; // int32_t
    public const nint m_nRandomSeedOffset = 0x1C0; // int32_t
    public const nint m_flLastTeleportTime = 0x1C4; // float
}

public static class CAttributeList {
    public const nint m_Attributes = 0x8; // C_UtlVectorEmbeddedNetworkVar<CEconItemAttribute>
    public const nint m_pManager = 0x58; // CAttributeManager*
}

public static class CAttributeManager {
    public const nint m_Providers = 0x8; // CUtlVector<CHandle<C_BaseEntity>>
    public const nint m_iReapplyProvisionParity = 0x20; // int32_t
    public const nint m_hOuter = 0x24; // CHandle<C_BaseEntity>
    public const nint m_bPreventLoopback = 0x28; // bool
    public const nint m_ProviderType = 0x2C; // attributeprovidertypes_t
    public const nint m_CachedResults = 0x30; // CUtlVector<CAttributeManager::cached_attribute_float_t>
}

public static class CAttributeManager_cached_attribute_float_t {
    public const nint flIn = 0x0; // float
    public const nint iAttribHook = 0x8; // CUtlSymbolLarge
    public const nint flOut = 0x10; // float
}

public static class CBaseAnimGraph {
    public const nint m_bInitiallyPopulateInterpHistory = 0xCC0; // bool
    public const nint m_bShouldAnimateDuringGameplayPause = 0xCC1; // bool
    public const nint m_bSuppressAnimEventSounds = 0xCC3; // bool
    public const nint m_bAnimGraphUpdateEnabled = 0xCD0; // bool
    public const nint m_flMaxSlopeDistance = 0xCD4; // float
    public const nint m_vLastSlopeCheckPos = 0xCD8; // Vector
    public const nint m_vecForce = 0xCE8; // Vector
    public const nint m_nForceBone = 0xCF4; // int32_t
    public const nint m_pClientsideRagdoll = 0xCF8; // CBaseAnimGraph*
    public const nint m_bBuiltRagdoll = 0xD00; // bool
    public const nint m_pRagdollPose = 0xD18; // PhysicsRagdollPose_t*
    public const nint m_bClientRagdoll = 0xD20; // bool
    public const nint m_bHasAnimatedMaterialAttributes = 0xD30; // bool
}

public static class CBaseAnimGraphController {
    public const nint m_baseLayer = 0x18; // CNetworkedSequenceOperation
    public const nint m_animGraphNetworkedVars = 0x40; // CAnimGraphNetworkedVariables
    public const nint m_bSequenceFinished = 0x1320; // bool
    public const nint m_flLastEventCycle = 0x1324; // float
    public const nint m_flLastEventAnimTime = 0x1328; // float
    public const nint m_flPlaybackRate = 0x132C; // CNetworkedQuantizedFloat
    public const nint m_flPrevAnimTime = 0x1334; // float
    public const nint m_bClientSideAnimation = 0x1338; // bool
    public const nint m_bNetworkedAnimationInputsChanged = 0x1339; // bool
    public const nint m_nPrevNewSequenceParity = 0x133A; // uint8_t
    public const nint m_nPrevResetEventsParity = 0x133B; // uint8_t
    public const nint m_nNewSequenceParity = 0x133C; // int32_t
    public const nint m_nResetEventsParity = 0x1340; // int32_t
    public const nint m_nAnimLoopMode = 0x1344; // AnimLoopMode_t
    public const nint m_hAnimationUpdate = 0x13E4; // AnimationUpdateListHandle_t
    public const nint m_hLastAnimEventSequence = 0x13E8; // HSequence
}

public static class CBasePlayerController {
    public const nint m_nFinalPredictedTick = 0x548; // int32_t
    public const nint m_CommandContext = 0x550; // C_CommandContext
    public const nint m_nInButtonsWhichAreToggles = 0x600; // uint64_t
    public const nint m_nTickBase = 0x608; // uint32_t
    public const nint m_hPawn = 0x60C; // CHandle<C_BasePlayerPawn>
    public const nint m_hPredictedPawn = 0x610; // CHandle<C_BasePlayerPawn>
    public const nint m_nSplitScreenSlot = 0x614; // CSplitScreenSlot
    public const nint m_hSplitOwner = 0x618; // CHandle<CBasePlayerController>
    public const nint m_hSplitScreenPlayers = 0x620; // CUtlVector<CHandle<CBasePlayerController>>
    public const nint m_bIsHLTV = 0x638; // bool
    public const nint m_iConnected = 0x63C; // PlayerConnectedState
    public const nint m_iszPlayerName = 0x640; // char[128]
    public const nint m_steamID = 0x6C8; // uint64_t
    public const nint m_bIsLocalPlayerController = 0x6D0; // bool
    public const nint m_iDesiredFOV = 0x6D4; // uint32_t
}

public static class CBasePlayerVData {
    public const nint m_sModelName = 0x28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    public const nint m_flHeadDamageMultiplier = 0x108; // CSkillFloat
    public const nint m_flChestDamageMultiplier = 0x118; // CSkillFloat
    public const nint m_flStomachDamageMultiplier = 0x128; // CSkillFloat
    public const nint m_flArmDamageMultiplier = 0x138; // CSkillFloat
    public const nint m_flLegDamageMultiplier = 0x148; // CSkillFloat
    public const nint m_flHoldBreathTime = 0x158; // float
    public const nint m_flDrowningDamageInterval = 0x15C; // float
    public const nint m_nDrowningDamageInitial = 0x160; // int32_t
    public const nint m_nDrowningDamageMax = 0x164; // int32_t
    public const nint m_nWaterSpeed = 0x168; // int32_t
    public const nint m_flUseRange = 0x16C; // float
    public const nint m_flUseAngleTolerance = 0x170; // float
    public const nint m_flCrouchTime = 0x174; // float
}

public static class CBasePlayerWeaponVData {
    public const nint m_szWorldModel = 0x28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    public const nint m_bBuiltRightHanded = 0x108; // bool
    public const nint m_bAllowFlipping = 0x109; // bool
    public const nint m_bIsFullAuto = 0x10A; // bool
    public const nint m_nNumBullets = 0x10C; // int32_t
    public const nint m_sMuzzleAttachment = 0x110; // CUtlString
    public const nint m_szMuzzleFlashParticle = 0x118; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    public const nint m_iFlags = 0x1F8; // ItemFlagTypes_t
    public const nint m_nPrimaryAmmoType = 0x1F9; // AmmoIndex_t
    public const nint m_nSecondaryAmmoType = 0x1FA; // AmmoIndex_t
    public const nint m_iMaxClip1 = 0x1FC; // int32_t
    public const nint m_iMaxClip2 = 0x200; // int32_t
    public const nint m_iDefaultClip1 = 0x204; // int32_t
    public const nint m_iDefaultClip2 = 0x208; // int32_t
    public const nint m_iWeight = 0x20C; // int32_t
    public const nint m_bAutoSwitchTo = 0x210; // bool
    public const nint m_bAutoSwitchFrom = 0x211; // bool
    public const nint m_iRumbleEffect = 0x214; // RumbleEffect_t
    public const nint m_aShootSounds = 0x218; // CUtlMap<WeaponSound_t,CSoundEventName>
    public const nint m_iSlot = 0x238; // int32_t
    public const nint m_iPosition = 0x23C; // int32_t
}

public static class CBaseProp {
    public const nint m_bModelOverrodeBlockLOS = 0xE80; // bool
    public const nint m_iShapeType = 0xE84; // int32_t
    public const nint m_bConformToCollisionBounds = 0xE88; // bool
    public const nint m_mPreferredCatchTransform = 0xE8C; // matrix3x4_t
}

public static class CBodyComponent {
    public const nint m_pSceneNode = 0x8; // CGameSceneNode*
    public const nint __m_pChainEntity = 0x20; // CNetworkVarChainer
}

public static class CBodyComponentBaseAnimGraph {
    public const nint m_animationController = 0x480; // CBaseAnimGraphController
    public const nint __m_pChainEntity = 0x18C0; // CNetworkVarChainer
}

public static class CBodyComponentBaseModelEntity {
    public const nint __m_pChainEntity = 0x480; // CNetworkVarChainer
}

public static class CBodyComponentPoint {
    public const nint m_sceneNode = 0x50; // CGameSceneNode
    public const nint __m_pChainEntity = 0x1A0; // CNetworkVarChainer
}

public static class CBodyComponentSkeletonInstance {
    public const nint m_skeletonInstance = 0x50; // CSkeletonInstance
    public const nint __m_pChainEntity = 0x450; // CNetworkVarChainer
}

public static class CBombTarget {
    public const nint m_bBombPlantedHere = 0xCC8; // bool
}

public static class CBuoyancyHelper {
    public const nint m_flFluidDensity = 0x18; // float
}

public static class CCSGameModeRules {
    public const nint __m_pChainEntity = 0x8; // CNetworkVarChainer
}

public static class CCSGameModeRules_Deathmatch {
    public const nint m_bFirstThink = 0x30; // bool
    public const nint m_bFirstThinkAfterConnected = 0x31; // bool
    public const nint m_flDMBonusStartTime = 0x34; // GameTime_t
    public const nint m_flDMBonusTimeLength = 0x38; // float
    public const nint m_nDMBonusWeaponLoadoutSlot = 0x3C; // int16_t
}

public static class CCSObserver_ObserverServices {
    public const nint m_hLastObserverTarget = 0x58; // CEntityHandle
    public const nint m_vecObserverInterpolateOffset = 0x5C; // Vector
    public const nint m_vecObserverInterpStartPos = 0x68; // Vector
    public const nint m_flObsInterp_PathLength = 0x74; // float
    public const nint m_qObsInterp_OrientationStart = 0x80; // Quaternion
    public const nint m_qObsInterp_OrientationTravelDir = 0x90; // Quaternion
    public const nint m_obsInterpState = 0xA0; // ObserverInterpState_t
    public const nint m_bObserverInterpolationNeedsDeferredSetup = 0xA4; // bool
}

public static class CCSPlayerBase_CameraServices {
    public const nint m_iFOV = 0x210; // uint32_t
    public const nint m_iFOVStart = 0x214; // uint32_t
    public const nint m_flFOVTime = 0x218; // GameTime_t
    public const nint m_flFOVRate = 0x21C; // float
    public const nint m_hZoomOwner = 0x220; // CHandle<C_BaseEntity>
    public const nint m_flLastShotFOV = 0x224; // float
}

public static class CCSPlayerController {
    public const nint m_pInGameMoneyServices = 0x700; // CCSPlayerController_InGameMoneyServices*
    public const nint m_pInventoryServices = 0x708; // CCSPlayerController_InventoryServices*
    public const nint m_pActionTrackingServices = 0x710; // CCSPlayerController_ActionTrackingServices*
    public const nint m_pDamageServices = 0x718; // CCSPlayerController_DamageServices*
    public const nint m_iPing = 0x720; // uint32_t
    public const nint m_bHasCommunicationAbuseMute = 0x724; // bool
    public const nint m_szCrosshairCodes = 0x728; // CUtlSymbolLarge
    public const nint m_iPendingTeamNum = 0x730; // uint8_t
    public const nint m_flForceTeamTime = 0x734; // GameTime_t
    public const nint m_iCompTeammateColor = 0x738; // int32_t
    public const nint m_bEverPlayedOnTeam = 0x73C; // bool
    public const nint m_flPreviousForceJoinTeamTime = 0x740; // GameTime_t
    public const nint m_szClan = 0x748; // CUtlSymbolLarge
    public const nint m_sSanitizedPlayerName = 0x750; // CUtlString
    public const nint m_iCoachingTeam = 0x758; // int32_t
    public const nint m_nPlayerDominated = 0x760; // uint64_t
    public const nint m_nPlayerDominatingMe = 0x768; // uint64_t
    public const nint m_iCompetitiveRanking = 0x770; // int32_t
    public const nint m_iCompetitiveWins = 0x774; // int32_t
    public const nint m_iCompetitiveRankType = 0x778; // int8_t
    public const nint m_iCompetitiveRankingPredicted_Win = 0x77C; // int32_t
    public const nint m_iCompetitiveRankingPredicted_Loss = 0x780; // int32_t
    public const nint m_iCompetitiveRankingPredicted_Tie = 0x784; // int32_t
    public const nint m_nEndMatchNextMapVote = 0x788; // int32_t
    public const nint m_unActiveQuestId = 0x78C; // uint16_t
    public const nint m_nQuestProgressReason = 0x790; // QuestProgress::Reason
    public const nint m_unPlayerTvControlFlags = 0x794; // uint32_t
    public const nint m_iDraftIndex = 0x7C0; // int32_t
    public const nint m_msQueuedModeDisconnectionTimestamp = 0x7C4; // uint32_t
    public const nint m_uiAbandonRecordedReason = 0x7C8; // uint32_t
    public const nint m_bCannotBeKicked = 0x7CC; // bool
    public const nint m_bEverFullyConnected = 0x7CD; // bool
    public const nint m_bAbandonAllowsSurrender = 0x7CE; // bool
    public const nint m_bAbandonOffersInstantSurrender = 0x7CF; // bool
    public const nint m_bDisconnection1MinWarningPrinted = 0x7D0; // bool
    public const nint m_bScoreReported = 0x7D1; // bool
    public const nint m_nDisconnectionTick = 0x7D4; // int32_t
    public const nint m_bControllingBot = 0x7E0; // bool
    public const nint m_bHasControlledBotThisRound = 0x7E1; // bool
    public const nint m_bHasBeenControlledByPlayerThisRound = 0x7E2; // bool
    public const nint m_nBotsControlledThisRound = 0x7E4; // int32_t
    public const nint m_bCanControlObservedBot = 0x7E8; // bool
    public const nint m_hPlayerPawn = 0x7EC; // CHandle<C_CSPlayerPawn>
    public const nint m_hObserverPawn = 0x7F0; // CHandle<C_CSObserverPawn>
    public const nint m_bPawnIsAlive = 0x7F4; // bool
    public const nint m_iPawnHealth = 0x7F8; // uint32_t
    public const nint m_iPawnArmor = 0x7FC; // int32_t
    public const nint m_bPawnHasDefuser = 0x800; // bool
    public const nint m_bPawnHasHelmet = 0x801; // bool
    public const nint m_nPawnCharacterDefIndex = 0x802; // uint16_t
    public const nint m_iPawnLifetimeStart = 0x804; // int32_t
    public const nint m_iPawnLifetimeEnd = 0x808; // int32_t
    public const nint m_iPawnBotDifficulty = 0x80C; // int32_t
    public const nint m_hOriginalControllerOfCurrentPawn = 0x810; // CHandle<CCSPlayerController>
    public const nint m_iScore = 0x814; // int32_t
    public const nint m_vecKills = 0x818; // C_NetworkUtlVectorBase<EKillTypes_t>
    public const nint m_iMVPs = 0x830; // int32_t
    public const nint m_bIsPlayerNameDirty = 0x834; // bool
}

public static class CCSPlayerController_ActionTrackingServices {
    public const nint m_perRoundStats = 0x40; // C_UtlVectorEmbeddedNetworkVar<CSPerRoundStats_t>
    public const nint m_matchStats = 0x90; // CSMatchStats_t
    public const nint m_iNumRoundKills = 0x108; // int32_t
    public const nint m_iNumRoundKillsHeadshots = 0x10C; // int32_t
    public const nint m_unTotalRoundDamageDealt = 0x110; // uint32_t
}

public static class CCSPlayerController_DamageServices {
    public const nint m_nSendUpdate = 0x40; // int32_t
    public const nint m_DamageList = 0x48; // C_UtlVectorEmbeddedNetworkVar<CDamageRecord>
}

public static class CCSPlayerController_InGameMoneyServices {
    public const nint m_iAccount = 0x40; // int32_t
    public const nint m_iStartAccount = 0x44; // int32_t
    public const nint m_iTotalCashSpent = 0x48; // int32_t
    public const nint m_iCashSpentThisRound = 0x4C; // int32_t
    public const nint m_nPreviousAccount = 0x50; // int32_t
}

public static class CCSPlayerController_InventoryServices {
    public const nint m_unMusicID = 0x40; // uint16_t
    public const nint m_rank = 0x44; // MedalRank_t[6]
    public const nint m_nPersonaDataPublicLevel = 0x5C; // int32_t
    public const nint m_nPersonaDataPublicCommendsLeader = 0x60; // int32_t
    public const nint m_nPersonaDataPublicCommendsTeacher = 0x64; // int32_t
    public const nint m_nPersonaDataPublicCommendsFriendly = 0x68; // int32_t
    public const nint m_vecServerAuthoritativeWeaponSlots = 0x70; // C_UtlVectorEmbeddedNetworkVar<ServerAuthoritativeWeaponSlot_t>
}

public static class CCSPlayer_ActionTrackingServices {
    public const nint m_hLastWeaponBeforeC4AutoSwitch = 0x40; // CHandle<C_BasePlayerWeapon>
    public const nint m_bIsRescuing = 0x44; // bool
    public const nint m_weaponPurchasesThisMatch = 0x48; // WeaponPurchaseTracker_t
    public const nint m_weaponPurchasesThisRound = 0xA0; // WeaponPurchaseTracker_t
}

public static class CCSPlayer_BulletServices {
    public const nint m_totalHitsOnServer = 0x40; // int32_t
}

public static class CCSPlayer_BuyServices {
    public const nint m_vecSellbackPurchaseEntries = 0x40; // C_UtlVectorEmbeddedNetworkVar<SellbackPurchaseEntry_t>
}

public static class CCSPlayer_CameraServices {
    public const nint m_flDeathCamTilt = 0x228; // float
}

public static class CCSPlayer_HostageServices {
    public const nint m_hCarriedHostage = 0x40; // CHandle<C_BaseEntity>
    public const nint m_hCarriedHostageProp = 0x44; // CHandle<C_BaseEntity>
}

public static class CCSPlayer_ItemServices {
    public const nint m_bHasDefuser = 0x40; // bool
    public const nint m_bHasHelmet = 0x41; // bool
    public const nint m_bHasHeavyArmor = 0x42; // bool
}

public static class CCSPlayer_MovementServices {
    public const nint m_flMaxFallVelocity = 0x210; // float
    public const nint m_vecLadderNormal = 0x214; // Vector
    public const nint m_nLadderSurfacePropIndex = 0x220; // int32_t
    public const nint m_flDuckAmount = 0x224; // float
    public const nint m_flDuckSpeed = 0x228; // float
    public const nint m_bDuckOverride = 0x22C; // bool
    public const nint m_bDesiresDuck = 0x22D; // bool
    public const nint m_flDuckOffset = 0x230; // float
    public const nint m_nDuckTimeMsecs = 0x234; // uint32_t
    public const nint m_nDuckJumpTimeMsecs = 0x238; // uint32_t
    public const nint m_nJumpTimeMsecs = 0x23C; // uint32_t
    public const nint m_flLastDuckTime = 0x240; // float
    public const nint m_vecLastPositionAtFullCrouchSpeed = 0x250; // Vector2D
    public const nint m_duckUntilOnGround = 0x258; // bool
    public const nint m_bHasWalkMovedSinceLastJump = 0x259; // bool
    public const nint m_bInStuckTest = 0x25A; // bool
    public const nint m_flStuckCheckTime = 0x268; // float[64][2]
    public const nint m_nTraceCount = 0x468; // int32_t
    public const nint m_StuckLast = 0x46C; // int32_t
    public const nint m_bSpeedCropped = 0x470; // bool
    public const nint m_nOldWaterLevel = 0x474; // int32_t
    public const nint m_flWaterEntryTime = 0x478; // float
    public const nint m_vecForward = 0x47C; // Vector
    public const nint m_vecLeft = 0x488; // Vector
    public const nint m_vecUp = 0x494; // Vector
    public const nint m_vecPreviouslyPredictedOrigin = 0x4A0; // Vector
    public const nint m_bOldJumpPressed = 0x4AC; // bool
    public const nint m_flJumpPressedTime = 0x4B0; // float
    public const nint m_flJumpUntil = 0x4B4; // float
    public const nint m_flJumpVel = 0x4B8; // float
    public const nint m_fStashGrenadeParameterWhen = 0x4BC; // GameTime_t
    public const nint m_nButtonDownMaskPrev = 0x4C0; // uint64_t
    public const nint m_flOffsetTickCompleteTime = 0x4C8; // float
    public const nint m_flOffsetTickStashedSpeed = 0x4CC; // float
    public const nint m_flStamina = 0x4D0; // float
    public const nint m_bUpdatePredictedOriginAfterDataUpdate = 0x4D4; // bool
    public const nint m_flHeightAtJumpStart = 0x4D8; // float
    public const nint m_flMaxJumpHeightThisJump = 0x4DC; // float
}

public static class CCSPlayer_PingServices {
    public const nint m_hPlayerPing = 0x40; // CHandle<C_BaseEntity>
}

public static class CCSPlayer_ViewModelServices {
    public const nint m_hViewModel = 0x40; // CHandle<C_BaseViewModel>[3]
}

public static class CCSPlayer_WaterServices {
    public const nint m_flWaterJumpTime = 0x40; // float
    public const nint m_vecWaterJumpVel = 0x44; // Vector
    public const nint m_flSwimSoundTime = 0x50; // float
}

public static class CCSPlayer_WeaponServices {
    public const nint m_flNextAttack = 0xC0; // GameTime_t
    public const nint m_bIsLookingAtWeapon = 0xC4; // bool
    public const nint m_bIsHoldingLookAtWeapon = 0xC5; // bool
}

public static class CCSWeaponBaseVData {
    public const nint m_WeaponType = 0x240; // CSWeaponType
    public const nint m_WeaponCategory = 0x244; // CSWeaponCategory
    public const nint m_szViewModel = 0x248; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    public const nint m_szPlayerModel = 0x328; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    public const nint m_szWorldDroppedModel = 0x408; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    public const nint m_szAimsightLensMaskModel = 0x4E8; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    public const nint m_szMagazineModel = 0x5C8; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    public const nint m_szHeatEffect = 0x6A8; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    public const nint m_szEjectBrassEffect = 0x788; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    public const nint m_szMuzzleFlashParticleAlt = 0x868; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    public const nint m_szMuzzleFlashThirdPersonParticle = 0x948; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    public const nint m_szMuzzleFlashThirdPersonParticleAlt = 0xA28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    public const nint m_szTracerParticle = 0xB08; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    public const nint m_GearSlot = 0xBE8; // gear_slot_t
    public const nint m_GearSlotPosition = 0xBEC; // int32_t
    public const nint m_DefaultLoadoutSlot = 0xBF0; // loadout_slot_t
    public const nint m_sWrongTeamMsg = 0xBF8; // CUtlString
    public const nint m_nPrice = 0xC00; // int32_t
    public const nint m_nKillAward = 0xC04; // int32_t
    public const nint m_nPrimaryReserveAmmoMax = 0xC08; // int32_t
    public const nint m_nSecondaryReserveAmmoMax = 0xC0C; // int32_t
    public const nint m_bMeleeWeapon = 0xC10; // bool
    public const nint m_bHasBurstMode = 0xC11; // bool
    public const nint m_bIsRevolver = 0xC12; // bool
    public const nint m_bCannotShootUnderwater = 0xC13; // bool
    public const nint m_szName = 0xC18; // CUtlString
    public const nint m_szAnimExtension = 0xC20; // CUtlString
    public const nint m_eSilencerType = 0xC28; // CSWeaponSilencerType
    public const nint m_nCrosshairMinDistance = 0xC2C; // int32_t
    public const nint m_nCrosshairDeltaDistance = 0xC30; // int32_t
    public const nint m_flCycleTime = 0xC34; // CFiringModeFloat
    public const nint m_flMaxSpeed = 0xC3C; // CFiringModeFloat
    public const nint m_flSpread = 0xC44; // CFiringModeFloat
    public const nint m_flInaccuracyCrouch = 0xC4C; // CFiringModeFloat
    public const nint m_flInaccuracyStand = 0xC54; // CFiringModeFloat
    public const nint m_flInaccuracyJump = 0xC5C; // CFiringModeFloat
    public const nint m_flInaccuracyLand = 0xC64; // CFiringModeFloat
    public const nint m_flInaccuracyLadder = 0xC6C; // CFiringModeFloat
    public const nint m_flInaccuracyFire = 0xC74; // CFiringModeFloat
    public const nint m_flInaccuracyMove = 0xC7C; // CFiringModeFloat
    public const nint m_flRecoilAngle = 0xC84; // CFiringModeFloat
    public const nint m_flRecoilAngleVariance = 0xC8C; // CFiringModeFloat
    public const nint m_flRecoilMagnitude = 0xC94; // CFiringModeFloat
    public const nint m_flRecoilMagnitudeVariance = 0xC9C; // CFiringModeFloat
    public const nint m_nTracerFrequency = 0xCA4; // CFiringModeInt
    public const nint m_flInaccuracyJumpInitial = 0xCAC; // float
    public const nint m_flInaccuracyJumpApex = 0xCB0; // float
    public const nint m_flInaccuracyReload = 0xCB4; // float
    public const nint m_nRecoilSeed = 0xCB8; // int32_t
    public const nint m_nSpreadSeed = 0xCBC; // int32_t
    public const nint m_flTimeToIdleAfterFire = 0xCC0; // float
    public const nint m_flIdleInterval = 0xCC4; // float
    public const nint m_flAttackMovespeedFactor = 0xCC8; // float
    public const nint m_flHeatPerShot = 0xCCC; // float
    public const nint m_flInaccuracyPitchShift = 0xCD0; // float
    public const nint m_flInaccuracyAltSoundThreshold = 0xCD4; // float
    public const nint m_flBotAudibleRange = 0xCD8; // float
    public const nint m_szUseRadioSubtitle = 0xCE0; // CUtlString
    public const nint m_bUnzoomsAfterShot = 0xCE8; // bool
    public const nint m_bHideViewModelWhenZoomed = 0xCE9; // bool
    public const nint m_nZoomLevels = 0xCEC; // int32_t
    public const nint m_nZoomFOV1 = 0xCF0; // int32_t
    public const nint m_nZoomFOV2 = 0xCF4; // int32_t
    public const nint m_flZoomTime0 = 0xCF8; // float
    public const nint m_flZoomTime1 = 0xCFC; // float
    public const nint m_flZoomTime2 = 0xD00; // float
    public const nint m_flIronSightPullUpSpeed = 0xD04; // float
    public const nint m_flIronSightPutDownSpeed = 0xD08; // float
    public const nint m_flIronSightFOV = 0xD0C; // float
    public const nint m_flIronSightPivotForward = 0xD10; // float
    public const nint m_flIronSightLooseness = 0xD14; // float
    public const nint m_angPivotAngle = 0xD18; // QAngle
    public const nint m_vecIronSightEyePos = 0xD24; // Vector
    public const nint m_nDamage = 0xD30; // int32_t
    public const nint m_flHeadshotMultiplier = 0xD34; // float
    public const nint m_flArmorRatio = 0xD38; // float
    public const nint m_flPenetration = 0xD3C; // float
    public const nint m_flRange = 0xD40; // float
    public const nint m_flRangeModifier = 0xD44; // float
    public const nint m_flFlinchVelocityModifierLarge = 0xD48; // float
    public const nint m_flFlinchVelocityModifierSmall = 0xD4C; // float
    public const nint m_flRecoveryTimeCrouch = 0xD50; // float
    public const nint m_flRecoveryTimeStand = 0xD54; // float
    public const nint m_flRecoveryTimeCrouchFinal = 0xD58; // float
    public const nint m_flRecoveryTimeStandFinal = 0xD5C; // float
    public const nint m_nRecoveryTransitionStartBullet = 0xD60; // int32_t
    public const nint m_nRecoveryTransitionEndBullet = 0xD64; // int32_t
    public const nint m_flThrowVelocity = 0xD68; // float
    public const nint m_vSmokeColor = 0xD6C; // Vector
    public const nint m_szAnimClass = 0xD78; // CUtlString
}

public static class CClientAlphaProperty {
    public const nint m_nRenderFX = 0x10; // uint8_t
    public const nint m_nRenderMode = 0x11; // uint8_t
    public const nint m_bAlphaOverride = 0x0; // bitfield:1
    public const nint m_bShadowAlphaOverride = 0x0; // bitfield:1
    public const nint m_nReserved = 0x0; // bitfield:6
    public const nint m_nAlpha = 0x13; // uint8_t
    public const nint m_nDesyncOffset = 0x14; // uint16_t
    public const nint m_nReserved2 = 0x16; // uint16_t
    public const nint m_nDistFadeStart = 0x18; // uint16_t
    public const nint m_nDistFadeEnd = 0x1A; // uint16_t
    public const nint m_flFadeScale = 0x1C; // float
    public const nint m_flRenderFxStartTime = 0x20; // GameTime_t
    public const nint m_flRenderFxDuration = 0x24; // float
}

public static class CCollisionProperty {
    public const nint m_collisionAttribute = 0x10; // VPhysicsCollisionAttribute_t
    public const nint m_vecMins = 0x40; // Vector
    public const nint m_vecMaxs = 0x4C; // Vector
    public const nint m_usSolidFlags = 0x5A; // uint8_t
    public const nint m_nSolidType = 0x5B; // SolidType_t
    public const nint m_triggerBloat = 0x5C; // uint8_t
    public const nint m_nSurroundType = 0x5D; // SurroundingBoundsType_t
    public const nint m_CollisionGroup = 0x5E; // uint8_t
    public const nint m_nEnablePhysics = 0x5F; // uint8_t
    public const nint m_flBoundingRadius = 0x60; // float
    public const nint m_vecSpecifiedSurroundingMins = 0x64; // Vector
    public const nint m_vecSpecifiedSurroundingMaxs = 0x70; // Vector
    public const nint m_vecSurroundingMaxs = 0x7C; // Vector
    public const nint m_vecSurroundingMins = 0x88; // Vector
    public const nint m_vCapsuleCenter1 = 0x94; // Vector
    public const nint m_vCapsuleCenter2 = 0xA0; // Vector
    public const nint m_flCapsuleRadius = 0xAC; // float
}

public static class CComicBook {
    public const nint m_CoverImage = 0x8; // CPanoramaImageName
    public const nint m_XmlFile = 0x18; // CUtlString
}

public static class CCompositeMaterialEditorDoc {
    public const nint m_nVersion = 0x8; // int32_t
    public const nint m_Points = 0x10; // CUtlVector<CompositeMaterialEditorPoint_t>
    public const nint m_KVthumbnail = 0x28; // KeyValues3
}

public static class CDamageRecord {
    public const nint m_PlayerDamager = 0x28; // CHandle<C_CSPlayerPawnBase>
    public const nint m_PlayerRecipient = 0x2C; // CHandle<C_CSPlayerPawnBase>
    public const nint m_hPlayerControllerDamager = 0x30; // CHandle<CCSPlayerController>
    public const nint m_hPlayerControllerRecipient = 0x34; // CHandle<CCSPlayerController>
    public const nint m_szPlayerDamagerName = 0x38; // CUtlString
    public const nint m_szPlayerRecipientName = 0x40; // CUtlString
    public const nint m_DamagerXuid = 0x48; // uint64_t
    public const nint m_RecipientXuid = 0x50; // uint64_t
    public const nint m_iDamage = 0x58; // int32_t
    public const nint m_iActualHealthRemoved = 0x5C; // int32_t
    public const nint m_iNumHits = 0x60; // int32_t
    public const nint m_iLastBulletUpdate = 0x64; // int32_t
    public const nint m_bIsOtherEnemy = 0x68; // bool
    public const nint m_killType = 0x69; // EKillTypes_t
}

public static class CDecalInfo {
    public const nint m_flAnimationScale = 0x0; // float
    public const nint m_flAnimationLifeSpan = 0x4; // float
    public const nint m_flPlaceTime = 0x8; // float
    public const nint m_flFadeStartTime = 0xC; // float
    public const nint m_flFadeDuration = 0x10; // float
    public const nint m_nVBSlot = 0x14; // int32_t
    public const nint m_nBoneIndex = 0x18; // int32_t
    public const nint m_vPosition = 0x28; // Vector
    public const nint m_flBoundingRadiusSqr = 0x34; // float
    public const nint m_pNext = 0x40; // CDecalInfo*
    public const nint m_pPrev = 0x48; // CDecalInfo*
    public const nint m_nDecalMaterialIndex = 0xA8; // int32_t
}

public static class CEconItemAttribute {
    public const nint m_iAttributeDefinitionIndex = 0x30; // uint16_t
    public const nint m_flValue = 0x34; // float
    public const nint m_flInitialValue = 0x38; // float
    public const nint m_nRefundableCurrency = 0x3C; // int32_t
    public const nint m_bSetBonus = 0x40; // bool
}

public static class CEffectData {
    public const nint m_vOrigin = 0x8; // Vector
    public const nint m_vStart = 0x14; // Vector
    public const nint m_vNormal = 0x20; // Vector
    public const nint m_vAngles = 0x2C; // QAngle
    public const nint m_hEntity = 0x38; // CEntityHandle
    public const nint m_hOtherEntity = 0x3C; // CEntityHandle
    public const nint m_flScale = 0x40; // float
    public const nint m_flMagnitude = 0x44; // float
    public const nint m_flRadius = 0x48; // float
    public const nint m_nSurfaceProp = 0x4C; // CUtlStringToken
    public const nint m_nEffectIndex = 0x50; // CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>
    public const nint m_nDamageType = 0x58; // uint32_t
    public const nint m_nPenetrate = 0x5C; // uint8_t
    public const nint m_nMaterial = 0x5E; // uint16_t
    public const nint m_nHitBox = 0x60; // uint16_t
    public const nint m_nColor = 0x62; // uint8_t
    public const nint m_fFlags = 0x63; // uint8_t
    public const nint m_nAttachmentIndex = 0x64; // AttachmentHandle_t
    public const nint m_nAttachmentName = 0x68; // CUtlStringToken
    public const nint m_iEffectName = 0x6C; // uint16_t
    public const nint m_nExplosionType = 0x6E; // uint8_t
}

public static class CEntityIdentity {
    public const nint m_nameStringableIndex = 0x14; // int32_t
    public const nint m_name = 0x18; // CUtlSymbolLarge
    public const nint m_designerName = 0x20; // CUtlSymbolLarge
    public const nint m_flags = 0x30; // uint32_t
    public const nint m_worldGroupId = 0x38; // WorldGroupId_t
    public const nint m_fDataObjectTypes = 0x3C; // uint32_t
    public const nint m_PathIndex = 0x40; // ChangeAccessorFieldPathIndex_t
    public const nint m_pPrev = 0x58; // CEntityIdentity*
    public const nint m_pNext = 0x60; // CEntityIdentity*
    public const nint m_pPrevByClass = 0x68; // CEntityIdentity*
    public const nint m_pNextByClass = 0x70; // CEntityIdentity*
}

public static class CEntityInstance {
    public const nint m_iszPrivateVScripts = 0x8; // CUtlSymbolLarge
    public const nint m_pEntity = 0x10; // CEntityIdentity*
    public const nint m_CScriptComponent = 0x28; // CScriptComponent*
}

public static class CFireOverlay {
    public const nint m_pOwner = 0xD0; // C_FireSmoke*
    public const nint m_vBaseColors = 0xD8; // Vector[4]
    public const nint m_flScale = 0x108; // float
    public const nint m_nGUID = 0x10C; // int32_t
}

public static class CFlashlightEffect {
    public const nint m_bIsOn = 0x10; // bool
    public const nint m_bMuzzleFlashEnabled = 0x20; // bool
    public const nint m_flMuzzleFlashBrightness = 0x24; // float
    public const nint m_quatMuzzleFlashOrientation = 0x30; // Quaternion
    public const nint m_vecMuzzleFlashOrigin = 0x40; // Vector
    public const nint m_flFov = 0x4C; // float
    public const nint m_flFarZ = 0x50; // float
    public const nint m_flLinearAtten = 0x54; // float
    public const nint m_bCastsShadows = 0x58; // bool
    public const nint m_flCurrentPullBackDist = 0x5C; // float
    public const nint m_FlashlightTexture = 0x60; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_MuzzleFlashTexture = 0x68; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_textureName = 0x70; // char[64]
}

public static class CFuncWater {
    public const nint m_BuoyancyHelper = 0xCC0; // CBuoyancyHelper
}

public static class CGameSceneNode {
    public const nint m_nodeToWorld = 0x10; // CTransform
    public const nint m_pOwner = 0x30; // CEntityInstance*
    public const nint m_pParent = 0x38; // CGameSceneNode*
    public const nint m_pChild = 0x40; // CGameSceneNode*
    public const nint m_pNextSibling = 0x48; // CGameSceneNode*
    public const nint m_hParent = 0x70; // CGameSceneNodeHandle
    public const nint m_vecOrigin = 0x80; // CNetworkOriginCellCoordQuantizedVector
    public const nint m_angRotation = 0xB8; // QAngle
    public const nint m_flScale = 0xC4; // float
    public const nint m_vecAbsOrigin = 0xC8; // Vector
    public const nint m_angAbsRotation = 0xD4; // QAngle
    public const nint m_flAbsScale = 0xE0; // float
    public const nint m_nParentAttachmentOrBone = 0xE4; // int16_t
    public const nint m_bDebugAbsOriginChanges = 0xE6; // bool
    public const nint m_bDormant = 0xE7; // bool
    public const nint m_bForceParentToBeNetworked = 0xE8; // bool
    public const nint m_bDirtyHierarchy = 0x0; // bitfield:1
    public const nint m_bDirtyBoneMergeInfo = 0x0; // bitfield:1
    public const nint m_bNetworkedPositionChanged = 0x0; // bitfield:1
    public const nint m_bNetworkedAnglesChanged = 0x0; // bitfield:1
    public const nint m_bNetworkedScaleChanged = 0x0; // bitfield:1
    public const nint m_bWillBeCallingPostDataUpdate = 0x0; // bitfield:1
    public const nint m_bNotifyBoneTransformsChanged = 0x0; // bitfield:1
    public const nint m_bBoneMergeFlex = 0x0; // bitfield:1
    public const nint m_nLatchAbsOrigin = 0x0; // bitfield:2
    public const nint m_bDirtyBoneMergeBoneToRoot = 0x0; // bitfield:1
    public const nint m_nHierarchicalDepth = 0xEB; // uint8_t
    public const nint m_nHierarchyType = 0xEC; // uint8_t
    public const nint m_nDoNotSetAnimTimeInInvalidatePhysicsCount = 0xED; // uint8_t
    public const nint m_name = 0xF0; // CUtlStringToken
    public const nint m_hierarchyAttachName = 0x130; // CUtlStringToken
    public const nint m_flZOffset = 0x134; // float
    public const nint m_vRenderOrigin = 0x138; // Vector
}

public static class CGameSceneNodeHandle {
    public const nint m_hOwner = 0x8; // CEntityHandle
    public const nint m_name = 0xC; // CUtlStringToken
}

public static class CGlobalLightBase {
    public const nint m_bSpotLight = 0x10; // bool
    public const nint m_SpotLightOrigin = 0x14; // Vector
    public const nint m_SpotLightAngles = 0x20; // QAngle
    public const nint m_ShadowDirection = 0x2C; // Vector
    public const nint m_AmbientDirection = 0x38; // Vector
    public const nint m_SpecularDirection = 0x44; // Vector
    public const nint m_InspectorSpecularDirection = 0x50; // Vector
    public const nint m_flSpecularPower = 0x5C; // float
    public const nint m_flSpecularIndependence = 0x60; // float
    public const nint m_SpecularColor = 0x64; // Color
    public const nint m_bStartDisabled = 0x68; // bool
    public const nint m_bEnabled = 0x69; // bool
    public const nint m_LightColor = 0x6A; // Color
    public const nint m_AmbientColor1 = 0x6E; // Color
    public const nint m_AmbientColor2 = 0x72; // Color
    public const nint m_AmbientColor3 = 0x76; // Color
    public const nint m_flSunDistance = 0x7C; // float
    public const nint m_flFOV = 0x80; // float
    public const nint m_flNearZ = 0x84; // float
    public const nint m_flFarZ = 0x88; // float
    public const nint m_bEnableShadows = 0x8C; // bool
    public const nint m_bOldEnableShadows = 0x8D; // bool
    public const nint m_bBackgroundClearNotRequired = 0x8E; // bool
    public const nint m_flCloudScale = 0x90; // float
    public const nint m_flCloud1Speed = 0x94; // float
    public const nint m_flCloud1Direction = 0x98; // float
    public const nint m_flCloud2Speed = 0x9C; // float
    public const nint m_flCloud2Direction = 0xA0; // float
    public const nint m_flAmbientScale1 = 0xB0; // float
    public const nint m_flAmbientScale2 = 0xB4; // float
    public const nint m_flGroundScale = 0xB8; // float
    public const nint m_flLightScale = 0xBC; // float
    public const nint m_flFoWDarkness = 0xC0; // float
    public const nint m_bEnableSeparateSkyboxFog = 0xC4; // bool
    public const nint m_vFowColor = 0xC8; // Vector
    public const nint m_ViewOrigin = 0xD4; // Vector
    public const nint m_ViewAngles = 0xE0; // QAngle
    public const nint m_flViewFoV = 0xEC; // float
    public const nint m_WorldPoints = 0xF0; // Vector[8]
    public const nint m_vFogOffsetLayer0 = 0x4A8; // Vector2D
    public const nint m_vFogOffsetLayer1 = 0x4B0; // Vector2D
    public const nint m_hEnvWind = 0x4B8; // CHandle<C_BaseEntity>
    public const nint m_hEnvSky = 0x4BC; // CHandle<C_BaseEntity>
}

public static class CGlowOverlay {
    public const nint m_vPos = 0x8; // Vector
    public const nint m_bDirectional = 0x14; // bool
    public const nint m_vDirection = 0x18; // Vector
    public const nint m_bInSky = 0x24; // bool
    public const nint m_skyObstructionScale = 0x28; // float
    public const nint m_Sprites = 0x30; // CGlowSprite[4]
    public const nint m_nSprites = 0xB0; // int32_t
    public const nint m_flProxyRadius = 0xB4; // float
    public const nint m_flHDRColorScale = 0xB8; // float
    public const nint m_flGlowObstructionScale = 0xBC; // float
    public const nint m_bCacheGlowObstruction = 0xC0; // bool
    public const nint m_bCacheSkyObstruction = 0xC1; // bool
    public const nint m_bActivated = 0xC2; // int16_t
    public const nint m_ListIndex = 0xC4; // uint16_t
    public const nint m_queryHandle = 0xC8; // int32_t
}

public static class CGlowProperty {
    public const nint m_fGlowColor = 0x8; // Vector
    public const nint m_iGlowType = 0x30; // int32_t
    public const nint m_iGlowTeam = 0x34; // int32_t
    public const nint m_nGlowRange = 0x38; // int32_t
    public const nint m_nGlowRangeMin = 0x3C; // int32_t
    public const nint m_glowColorOverride = 0x40; // Color
    public const nint m_bFlashing = 0x44; // bool
    public const nint m_flGlowTime = 0x48; // float
    public const nint m_flGlowStartTime = 0x4C; // float
    public const nint m_bEligibleForScreenHighlight = 0x50; // bool
    public const nint m_bGlowing = 0x51; // bool
}

public static class CGlowSprite {
    public const nint m_vColor = 0x0; // Vector
    public const nint m_flHorzSize = 0xC; // float
    public const nint m_flVertSize = 0x10; // float
    public const nint m_hMaterial = 0x18; // CStrongHandle<InfoForResourceTypeIMaterial2>
}

public static class CGrenadeTracer {
    public const nint m_flTracerDuration = 0xCE0; // float
    public const nint m_nType = 0xCE4; // GrenadeType_t
}

public static class CHitboxComponent {
    public const nint m_bvDisabledHitGroups = 0x24; // uint32_t[1]
}

public static class CInfoDynamicShadowHint {
    public const nint m_bDisabled = 0x540; // bool
    public const nint m_flRange = 0x544; // float
    public const nint m_nImportance = 0x548; // int32_t
    public const nint m_nLightChoice = 0x54C; // int32_t
    public const nint m_hLight = 0x550; // CHandle<C_BaseEntity>
}

public static class CInfoDynamicShadowHintBox {
    public const nint m_vBoxMins = 0x558; // Vector
    public const nint m_vBoxMaxs = 0x564; // Vector
}

public static class CInfoOffscreenPanoramaTexture {
    public const nint m_bDisabled = 0x540; // bool
    public const nint m_nResolutionX = 0x544; // int32_t
    public const nint m_nResolutionY = 0x548; // int32_t
    public const nint m_szLayoutFileName = 0x550; // CUtlSymbolLarge
    public const nint m_RenderAttrName = 0x558; // CUtlSymbolLarge
    public const nint m_TargetEntities = 0x560; // C_NetworkUtlVectorBase<CHandle<C_BaseModelEntity>>
    public const nint m_nTargetChangeCount = 0x578; // int32_t
    public const nint m_vecCSSClasses = 0x580; // C_NetworkUtlVectorBase<CUtlSymbolLarge>
    public const nint m_bCheckCSSClasses = 0x6F8; // bool
}

public static class CInfoWorldLayer {
    public const nint m_pOutputOnEntitiesSpawned = 0x540; // CEntityIOOutput
    public const nint m_worldName = 0x568; // CUtlSymbolLarge
    public const nint m_layerName = 0x570; // CUtlSymbolLarge
    public const nint m_bWorldLayerVisible = 0x578; // bool
    public const nint m_bEntitiesSpawned = 0x579; // bool
    public const nint m_bCreateAsChildSpawnGroup = 0x57A; // bool
    public const nint m_hLayerSpawnGroup = 0x57C; // uint32_t
    public const nint m_bWorldLayerActuallyVisible = 0x580; // bool
}

public static class CInterpolatedValue {
    public const nint m_flStartTime = 0x0; // float
    public const nint m_flEndTime = 0x4; // float
    public const nint m_flStartValue = 0x8; // float
    public const nint m_flEndValue = 0xC; // float
    public const nint m_nInterpType = 0x10; // int32_t
}

public static class CLightComponent {
    public const nint __m_pChainEntity = 0x48; // CNetworkVarChainer
    public const nint m_Color = 0x85; // Color
    public const nint m_SecondaryColor = 0x89; // Color
    public const nint m_flBrightness = 0x90; // float
    public const nint m_flBrightnessScale = 0x94; // float
    public const nint m_flBrightnessMult = 0x98; // float
    public const nint m_flRange = 0x9C; // float
    public const nint m_flFalloff = 0xA0; // float
    public const nint m_flAttenuation0 = 0xA4; // float
    public const nint m_flAttenuation1 = 0xA8; // float
    public const nint m_flAttenuation2 = 0xAC; // float
    public const nint m_flTheta = 0xB0; // float
    public const nint m_flPhi = 0xB4; // float
    public const nint m_hLightCookie = 0xB8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_nCascades = 0xC0; // int32_t
    public const nint m_nCastShadows = 0xC4; // int32_t
    public const nint m_nShadowWidth = 0xC8; // int32_t
    public const nint m_nShadowHeight = 0xCC; // int32_t
    public const nint m_bRenderDiffuse = 0xD0; // bool
    public const nint m_nRenderSpecular = 0xD4; // int32_t
    public const nint m_bRenderTransmissive = 0xD8; // bool
    public const nint m_flOrthoLightWidth = 0xDC; // float
    public const nint m_flOrthoLightHeight = 0xE0; // float
    public const nint m_nStyle = 0xE4; // int32_t
    public const nint m_Pattern = 0xE8; // CUtlString
    public const nint m_nCascadeRenderStaticObjects = 0xF0; // int32_t
    public const nint m_flShadowCascadeCrossFade = 0xF4; // float
    public const nint m_flShadowCascadeDistanceFade = 0xF8; // float
    public const nint m_flShadowCascadeDistance0 = 0xFC; // float
    public const nint m_flShadowCascadeDistance1 = 0x100; // float
    public const nint m_flShadowCascadeDistance2 = 0x104; // float
    public const nint m_flShadowCascadeDistance3 = 0x108; // float
    public const nint m_nShadowCascadeResolution0 = 0x10C; // int32_t
    public const nint m_nShadowCascadeResolution1 = 0x110; // int32_t
    public const nint m_nShadowCascadeResolution2 = 0x114; // int32_t
    public const nint m_nShadowCascadeResolution3 = 0x118; // int32_t
    public const nint m_bUsesBakedShadowing = 0x11C; // bool
    public const nint m_nShadowPriority = 0x120; // int32_t
    public const nint m_nBakedShadowIndex = 0x124; // int32_t
    public const nint m_bRenderToCubemaps = 0x128; // bool
    public const nint m_nDirectLight = 0x12C; // int32_t
    public const nint m_nIndirectLight = 0x130; // int32_t
    public const nint m_flFadeMinDist = 0x134; // float
    public const nint m_flFadeMaxDist = 0x138; // float
    public const nint m_flShadowFadeMinDist = 0x13C; // float
    public const nint m_flShadowFadeMaxDist = 0x140; // float
    public const nint m_bEnabled = 0x144; // bool
    public const nint m_bFlicker = 0x145; // bool
    public const nint m_bPrecomputedFieldsValid = 0x146; // bool
    public const nint m_vPrecomputedBoundsMins = 0x148; // Vector
    public const nint m_vPrecomputedBoundsMaxs = 0x154; // Vector
    public const nint m_vPrecomputedOBBOrigin = 0x160; // Vector
    public const nint m_vPrecomputedOBBAngles = 0x16C; // QAngle
    public const nint m_vPrecomputedOBBExtent = 0x178; // Vector
    public const nint m_flPrecomputedMaxRange = 0x184; // float
    public const nint m_nFogLightingMode = 0x188; // int32_t
    public const nint m_flFogContributionStength = 0x18C; // float
    public const nint m_flNearClipPlane = 0x190; // float
    public const nint m_SkyColor = 0x194; // Color
    public const nint m_flSkyIntensity = 0x198; // float
    public const nint m_SkyAmbientBounce = 0x19C; // Color
    public const nint m_bUseSecondaryColor = 0x1A0; // bool
    public const nint m_bMixedShadows = 0x1A1; // bool
    public const nint m_flLightStyleStartTime = 0x1A4; // GameTime_t
    public const nint m_flCapsuleLength = 0x1A8; // float
    public const nint m_flMinRoughness = 0x1AC; // float
}

public static class CLogicRelay {
    public const nint m_OnTrigger = 0x540; // CEntityIOOutput
    public const nint m_OnSpawn = 0x568; // CEntityIOOutput
    public const nint m_bDisabled = 0x590; // bool
    public const nint m_bWaitForRefire = 0x591; // bool
    public const nint m_bTriggerOnce = 0x592; // bool
    public const nint m_bFastRetrigger = 0x593; // bool
    public const nint m_bPassthoughCaller = 0x594; // bool
}

public static class CModelState {
    public const nint m_hModel = 0xA0; // CStrongHandle<InfoForResourceTypeCModel>
    public const nint m_ModelName = 0xA8; // CUtlSymbolLarge
    public const nint m_bClientClothCreationSuppressed = 0xE8; // bool
    public const nint m_MeshGroupMask = 0x180; // uint64_t
    public const nint m_nIdealMotionType = 0x222; // int8_t
    public const nint m_nForceLOD = 0x223; // int8_t
    public const nint m_nClothUpdateFlags = 0x224; // int8_t
}

public static class CNetworkedSequenceOperation {
    public const nint m_hSequence = 0x8; // HSequence
    public const nint m_flPrevCycle = 0xC; // float
    public const nint m_flCycle = 0x10; // float
    public const nint m_flWeight = 0x14; // CNetworkedQuantizedFloat
    public const nint m_bSequenceChangeNetworked = 0x1C; // bool
    public const nint m_bDiscontinuity = 0x1D; // bool
    public const nint m_flPrevCycleFromDiscontinuity = 0x20; // float
    public const nint m_flPrevCycleForAnimEventDetection = 0x24; // float
}

public static class CPlayer_CameraServices {
    public const nint m_vecCsViewPunchAngle = 0x40; // QAngle
    public const nint m_nCsViewPunchAngleTick = 0x4C; // GameTick_t
    public const nint m_flCsViewPunchAngleTickRatio = 0x50; // float
    public const nint m_PlayerFog = 0x58; // C_fogplayerparams_t
    public const nint m_hColorCorrectionCtrl = 0x98; // CHandle<C_ColorCorrection>
    public const nint m_hViewEntity = 0x9C; // CHandle<C_BaseEntity>
    public const nint m_hTonemapController = 0xA0; // CHandle<C_TonemapController2>
    public const nint m_audio = 0xA8; // audioparams_t
    public const nint m_PostProcessingVolumes = 0x120; // C_NetworkUtlVectorBase<CHandle<C_PostProcessingVolume>>
    public const nint m_flOldPlayerZ = 0x138; // float
    public const nint m_flOldPlayerViewOffsetZ = 0x13C; // float
    public const nint m_CurrentFog = 0x140; // fogparams_t
    public const nint m_hOldFogController = 0x1A8; // CHandle<C_FogController>
    public const nint m_bOverrideFogColor = 0x1AC; // bool[5]
    public const nint m_OverrideFogColor = 0x1B1; // Color[5]
    public const nint m_bOverrideFogStartEnd = 0x1C5; // bool[5]
    public const nint m_fOverrideFogStart = 0x1CC; // float[5]
    public const nint m_fOverrideFogEnd = 0x1E0; // float[5]
    public const nint m_hActivePostProcessingVolume = 0x1F4; // CHandle<C_PostProcessingVolume>
    public const nint m_angDemoViewAngles = 0x1F8; // QAngle
}

public static class CPlayer_MovementServices {
    public const nint m_nImpulse = 0x40; // int32_t
    public const nint m_nButtons = 0x48; // CInButtonState
    public const nint m_nQueuedButtonDownMask = 0x68; // uint64_t
    public const nint m_nQueuedButtonChangeMask = 0x70; // uint64_t
    public const nint m_nButtonDoublePressed = 0x78; // uint64_t
    public const nint m_pButtonPressedCmdNumber = 0x80; // uint32_t[64]
    public const nint m_nLastCommandNumberProcessed = 0x180; // uint32_t
    public const nint m_nToggleButtonDownMask = 0x188; // uint64_t
    public const nint m_flMaxspeed = 0x190; // float
    public const nint m_arrForceSubtickMoveWhen = 0x194; // float[4]
    public const nint m_flForwardMove = 0x1A4; // float
    public const nint m_flLeftMove = 0x1A8; // float
    public const nint m_flUpMove = 0x1AC; // float
    public const nint m_vecLastMovementImpulses = 0x1B0; // Vector
    public const nint m_vecOldViewAngles = 0x1BC; // QAngle
}

public static class CPlayer_MovementServices_Humanoid {
    public const nint m_flStepSoundTime = 0x1D0; // float
    public const nint m_flFallVelocity = 0x1D4; // float
    public const nint m_bInCrouch = 0x1D8; // bool
    public const nint m_nCrouchState = 0x1DC; // uint32_t
    public const nint m_flCrouchTransitionStartTime = 0x1E0; // GameTime_t
    public const nint m_bDucked = 0x1E4; // bool
    public const nint m_bDucking = 0x1E5; // bool
    public const nint m_bInDuckJump = 0x1E6; // bool
    public const nint m_groundNormal = 0x1E8; // Vector
    public const nint m_flSurfaceFriction = 0x1F4; // float
    public const nint m_surfaceProps = 0x1F8; // CUtlStringToken
    public const nint m_nStepside = 0x208; // int32_t
}

public static class CPlayer_ObserverServices {
    public const nint m_iObserverMode = 0x40; // uint8_t
    public const nint m_hObserverTarget = 0x44; // CHandle<C_BaseEntity>
    public const nint m_iObserverLastMode = 0x48; // ObserverMode_t
    public const nint m_bForcedObserverMode = 0x4C; // bool
    public const nint m_flObserverChaseDistance = 0x50; // float
    public const nint m_flObserverChaseDistanceCalcTime = 0x54; // GameTime_t
}

public static class CPlayer_WeaponServices {
    public const nint m_bAllowSwitchToNoWeapon = 0x40; // bool
    public const nint m_hMyWeapons = 0x48; // C_NetworkUtlVectorBase<CHandle<C_BasePlayerWeapon>>
    public const nint m_hActiveWeapon = 0x60; // CHandle<C_BasePlayerWeapon>
    public const nint m_hLastWeapon = 0x64; // CHandle<C_BasePlayerWeapon>
    public const nint m_iAmmo = 0x68; // uint16_t[32]
}

public static class CPointOffScreenIndicatorUi {
    public const nint m_bBeenEnabled = 0xF20; // bool
    public const nint m_bHide = 0xF21; // bool
    public const nint m_flSeenTargetTime = 0xF24; // float
    public const nint m_pTargetPanel = 0xF28; // C_PointClientUIWorldPanel*
}

public static class CPointTemplate {
    public const nint m_iszWorldName = 0x540; // CUtlSymbolLarge
    public const nint m_iszSource2EntityLumpName = 0x548; // CUtlSymbolLarge
    public const nint m_iszEntityFilterName = 0x550; // CUtlSymbolLarge
    public const nint m_flTimeoutInterval = 0x558; // float
    public const nint m_bAsynchronouslySpawnEntities = 0x55C; // bool
    public const nint m_pOutputOnSpawned = 0x560; // CEntityIOOutput
    public const nint m_clientOnlyEntityBehavior = 0x588; // PointTemplateClientOnlyEntityBehavior_t
    public const nint m_ownerSpawnGroupType = 0x58C; // PointTemplateOwnerSpawnGroupType_t
    public const nint m_createdSpawnGroupHandles = 0x590; // CUtlVector<uint32_t>
    public const nint m_SpawnedEntityHandles = 0x5A8; // CUtlVector<CEntityHandle>
    public const nint m_ScriptSpawnCallback = 0x5C0; // HSCRIPT
    public const nint m_ScriptCallbackScope = 0x5C8; // HSCRIPT
}

public static class CPrecipitationVData {
    public const nint m_szParticlePrecipitationEffect = 0x28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    public const nint m_flInnerDistance = 0x108; // float
    public const nint m_nAttachType = 0x10C; // ParticleAttachment_t
    public const nint m_bBatchSameVolumeType = 0x110; // bool
    public const nint m_nRTEnvCP = 0x114; // int32_t
    public const nint m_nRTEnvCPComponent = 0x118; // int32_t
    public const nint m_szModifier = 0x120; // CUtlString
}

public static class CProjectedTextureBase {
    public const nint m_hTargetEntity = 0xC; // CHandle<C_BaseEntity>
    public const nint m_bState = 0x10; // bool
    public const nint m_bAlwaysUpdate = 0x11; // bool
    public const nint m_flLightFOV = 0x14; // float
    public const nint m_bEnableShadows = 0x18; // bool
    public const nint m_bSimpleProjection = 0x19; // bool
    public const nint m_bLightOnlyTarget = 0x1A; // bool
    public const nint m_bLightWorld = 0x1B; // bool
    public const nint m_bCameraSpace = 0x1C; // bool
    public const nint m_flBrightnessScale = 0x20; // float
    public const nint m_LightColor = 0x24; // Color
    public const nint m_flIntensity = 0x28; // float
    public const nint m_flLinearAttenuation = 0x2C; // float
    public const nint m_flQuadraticAttenuation = 0x30; // float
    public const nint m_bVolumetric = 0x34; // bool
    public const nint m_flVolumetricIntensity = 0x38; // float
    public const nint m_flNoiseStrength = 0x3C; // float
    public const nint m_flFlashlightTime = 0x40; // float
    public const nint m_nNumPlanes = 0x44; // uint32_t
    public const nint m_flPlaneOffset = 0x48; // float
    public const nint m_flColorTransitionTime = 0x4C; // float
    public const nint m_flAmbient = 0x50; // float
    public const nint m_SpotlightTextureName = 0x54; // char[512]
    public const nint m_nSpotlightTextureFrame = 0x254; // int32_t
    public const nint m_nShadowQuality = 0x258; // uint32_t
    public const nint m_flNearZ = 0x25C; // float
    public const nint m_flFarZ = 0x260; // float
    public const nint m_flProjectionSize = 0x264; // float
    public const nint m_flRotation = 0x268; // float
    public const nint m_bFlipHorizontal = 0x26C; // bool
}

public static class CRenderComponent {
    public const nint __m_pChainEntity = 0x10; // CNetworkVarChainer
    public const nint m_bIsRenderingWithViewModels = 0x50; // bool
    public const nint m_nSplitscreenFlags = 0x54; // uint32_t
    public const nint m_bEnableRendering = 0x60; // bool
    public const nint m_bInterpolationReadyToDraw = 0xB0; // bool
}

public static class CSMatchStats_t {
    public const nint m_iEnemy5Ks = 0x68; // int32_t
    public const nint m_iEnemy4Ks = 0x6C; // int32_t
    public const nint m_iEnemy3Ks = 0x70; // int32_t
}

public static class CSPerRoundStats_t {
    public const nint m_iKills = 0x30; // int32_t
    public const nint m_iDeaths = 0x34; // int32_t
    public const nint m_iAssists = 0x38; // int32_t
    public const nint m_iDamage = 0x3C; // int32_t
    public const nint m_iEquipmentValue = 0x40; // int32_t
    public const nint m_iMoneySaved = 0x44; // int32_t
    public const nint m_iKillReward = 0x48; // int32_t
    public const nint m_iLiveTime = 0x4C; // int32_t
    public const nint m_iHeadShotKills = 0x50; // int32_t
    public const nint m_iObjective = 0x54; // int32_t
    public const nint m_iCashEarned = 0x58; // int32_t
    public const nint m_iUtilityDamage = 0x5C; // int32_t
    public const nint m_iEnemiesFlashed = 0x60; // int32_t
}

public static class CScriptComponent {
    public const nint m_scriptClassName = 0x30; // CUtlSymbolLarge
}

public static class CSkeletonInstance {
    public const nint m_modelState = 0x160; // CModelState
    public const nint m_bIsAnimationEnabled = 0x390; // bool
    public const nint m_bUseParentRenderBounds = 0x391; // bool
    public const nint m_bDisableSolidCollisionsForHierarchy = 0x392; // bool
    public const nint m_bDirtyMotionType = 0x0; // bitfield:1
    public const nint m_bIsGeneratingLatchedParentSpaceState = 0x0; // bitfield:1
    public const nint m_materialGroup = 0x394; // CUtlStringToken
    public const nint m_nHitboxSet = 0x398; // uint8_t
}

public static class CSkyboxReference {
    public const nint m_worldGroupId = 0x540; // WorldGroupId_t
    public const nint m_hSkyCamera = 0x544; // CHandle<C_SkyCamera>
}

public static class CTimeline {
    public const nint m_flValues = 0x10; // float[64]
    public const nint m_nValueCounts = 0x110; // int32_t[64]
    public const nint m_nBucketCount = 0x210; // int32_t
    public const nint m_flInterval = 0x214; // float
    public const nint m_flFinalValue = 0x218; // float
    public const nint m_nCompressionType = 0x21C; // TimelineCompression_t
    public const nint m_bStopped = 0x220; // bool
}

public static class C_AttributeContainer {
    public const nint m_Item = 0x50; // C_EconItemView
    public const nint m_iExternalItemProviderRegisteredToken = 0x498; // int32_t
    public const nint m_ullRegisteredAsItemID = 0x4A0; // uint64_t
}

public static class C_BarnLight {
    public const nint m_bEnabled = 0xCC0; // bool
    public const nint m_nColorMode = 0xCC4; // int32_t
    public const nint m_Color = 0xCC8; // Color
    public const nint m_flColorTemperature = 0xCCC; // float
    public const nint m_flBrightness = 0xCD0; // float
    public const nint m_flBrightnessScale = 0xCD4; // float
    public const nint m_nDirectLight = 0xCD8; // int32_t
    public const nint m_nBakedShadowIndex = 0xCDC; // int32_t
    public const nint m_nLuminaireShape = 0xCE0; // int32_t
    public const nint m_flLuminaireSize = 0xCE4; // float
    public const nint m_flLuminaireAnisotropy = 0xCE8; // float
    public const nint m_LightStyleString = 0xCF0; // CUtlString
    public const nint m_flLightStyleStartTime = 0xCF8; // GameTime_t
    public const nint m_QueuedLightStyleStrings = 0xD00; // C_NetworkUtlVectorBase<CUtlString>
    public const nint m_LightStyleEvents = 0xD18; // C_NetworkUtlVectorBase<CUtlString>
    public const nint m_LightStyleTargets = 0xD30; // C_NetworkUtlVectorBase<CHandle<C_BaseModelEntity>>
    public const nint m_StyleEvent = 0xD48; // CEntityIOOutput[4]
    public const nint m_hLightCookie = 0xDE8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_flShape = 0xDF0; // float
    public const nint m_flSoftX = 0xDF4; // float
    public const nint m_flSoftY = 0xDF8; // float
    public const nint m_flSkirt = 0xDFC; // float
    public const nint m_flSkirtNear = 0xE00; // float
    public const nint m_vSizeParams = 0xE04; // Vector
    public const nint m_flRange = 0xE10; // float
    public const nint m_vShear = 0xE14; // Vector
    public const nint m_nBakeSpecularToCubemaps = 0xE20; // int32_t
    public const nint m_vBakeSpecularToCubemapsSize = 0xE24; // Vector
    public const nint m_nCastShadows = 0xE30; // int32_t
    public const nint m_nShadowMapSize = 0xE34; // int32_t
    public const nint m_nShadowPriority = 0xE38; // int32_t
    public const nint m_bContactShadow = 0xE3C; // bool
    public const nint m_nBounceLight = 0xE40; // int32_t
    public const nint m_flBounceScale = 0xE44; // float
    public const nint m_flMinRoughness = 0xE48; // float
    public const nint m_vAlternateColor = 0xE4C; // Vector
    public const nint m_fAlternateColorBrightness = 0xE58; // float
    public const nint m_nFog = 0xE5C; // int32_t
    public const nint m_flFogStrength = 0xE60; // float
    public const nint m_nFogShadows = 0xE64; // int32_t
    public const nint m_flFogScale = 0xE68; // float
    public const nint m_flFadeSizeStart = 0xE6C; // float
    public const nint m_flFadeSizeEnd = 0xE70; // float
    public const nint m_flShadowFadeSizeStart = 0xE74; // float
    public const nint m_flShadowFadeSizeEnd = 0xE78; // float
    public const nint m_bPrecomputedFieldsValid = 0xE7C; // bool
    public const nint m_vPrecomputedBoundsMins = 0xE80; // Vector
    public const nint m_vPrecomputedBoundsMaxs = 0xE8C; // Vector
    public const nint m_vPrecomputedOBBOrigin = 0xE98; // Vector
    public const nint m_vPrecomputedOBBAngles = 0xEA4; // QAngle
    public const nint m_vPrecomputedOBBExtent = 0xEB0; // Vector
}

public static class C_BaseButton {
    public const nint m_glowEntity = 0xCC0; // CHandle<C_BaseModelEntity>
    public const nint m_usable = 0xCC4; // bool
    public const nint m_szDisplayText = 0xCC8; // CUtlSymbolLarge
}

public static class C_BaseCSGrenade {
    public const nint m_bClientPredictDelete = 0x19F0; // bool
    public const nint m_bRedraw = 0x19F1; // bool
    public const nint m_bIsHeldByPlayer = 0x19F2; // bool
    public const nint m_bPinPulled = 0x19F3; // bool
    public const nint m_bJumpThrow = 0x19F4; // bool
    public const nint m_eThrowStatus = 0x19F8; // EGrenadeThrowState
    public const nint m_fThrowTime = 0x19FC; // GameTime_t
    public const nint m_flThrowStrength = 0x1A00; // float
    public const nint m_flThrowStrengthApproach = 0x1A04; // float
    public const nint m_fDropTime = 0x1A08; // GameTime_t
}

public static class C_BaseCSGrenadeProjectile {
    public const nint m_vInitialPosition = 0x1068; // Vector
    public const nint m_vInitialVelocity = 0x1074; // Vector
    public const nint m_nBounces = 0x1080; // int32_t
    public const nint m_nExplodeEffectIndex = 0x1088; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    public const nint m_nExplodeEffectTickBegin = 0x1090; // int32_t
    public const nint m_vecExplodeEffectOrigin = 0x1094; // Vector
    public const nint m_flSpawnTime = 0x10A0; // GameTime_t
    public const nint vecLastTrailLinePos = 0x10A4; // Vector
    public const nint flNextTrailLineTime = 0x10B0; // GameTime_t
    public const nint m_bExplodeEffectBegan = 0x10B4; // bool
    public const nint m_bCanCreateGrenadeTrail = 0x10B5; // bool
    public const nint m_nSnapshotTrajectoryEffectIndex = 0x10B8; // ParticleIndex_t
    public const nint m_hSnapshotTrajectoryParticleSnapshot = 0x10C0; // CStrongHandle<InfoForResourceTypeIParticleSnapshot>
    public const nint m_arrTrajectoryTrailPoints = 0x10C8; // CUtlVector<Vector>
    public const nint m_arrTrajectoryTrailPointCreationTimes = 0x10E0; // CUtlVector<float>
    public const nint m_flTrajectoryTrailEffectCreationTime = 0x10F8; // float
}

public static class C_BaseClientUIEntity {
    public const nint m_bEnabled = 0xCC8; // bool
    public const nint m_DialogXMLName = 0xCD0; // CUtlSymbolLarge
    public const nint m_PanelClassName = 0xCD8; // CUtlSymbolLarge
    public const nint m_PanelID = 0xCE0; // CUtlSymbolLarge
}

public static class C_BaseCombatCharacter {
    public const nint m_hMyWearables = 0x1018; // C_NetworkUtlVectorBase<CHandle<C_EconWearable>>
    public const nint m_bloodColor = 0x1030; // int32_t
    public const nint m_leftFootAttachment = 0x1034; // AttachmentHandle_t
    public const nint m_rightFootAttachment = 0x1035; // AttachmentHandle_t
    public const nint m_nWaterWakeMode = 0x1038; // C_BaseCombatCharacter::WaterWakeMode_t
    public const nint m_flWaterWorldZ = 0x103C; // float
    public const nint m_flWaterNextTraceTime = 0x1040; // float
    public const nint m_flFieldOfView = 0x1044; // float
}

public static class C_BaseDoor {
    public const nint m_bIsUsable = 0xCC0; // bool
}

public static class C_BaseEntity {
    public const nint m_CBodyComponent = 0x30; // CBodyComponent*
    public const nint m_NetworkTransmitComponent = 0x38; // CNetworkTransmitComponent
    public const nint m_nLastThinkTick = 0x308; // GameTick_t
    public const nint m_pGameSceneNode = 0x310; // CGameSceneNode*
    public const nint m_pRenderComponent = 0x318; // CRenderComponent*
    public const nint m_pCollision = 0x320; // CCollisionProperty*
    public const nint m_iMaxHealth = 0x328; // int32_t
    public const nint m_iHealth = 0x32C; // int32_t
    public const nint m_lifeState = 0x330; // uint8_t
    public const nint m_bTakesDamage = 0x331; // bool
    public const nint m_nTakeDamageFlags = 0x334; // TakeDamageFlags_t
    public const nint m_ubInterpolationFrame = 0x338; // uint8_t
    public const nint m_hSceneObjectController = 0x33C; // CHandle<C_BaseEntity>
    public const nint m_nNoInterpolationTick = 0x340; // int32_t
    public const nint m_nVisibilityNoInterpolationTick = 0x344; // int32_t
    public const nint m_flProxyRandomValue = 0x348; // float
    public const nint m_iEFlags = 0x34C; // int32_t
    public const nint m_nWaterType = 0x350; // uint8_t
    public const nint m_bInterpolateEvenWithNoModel = 0x351; // bool
    public const nint m_bPredictionEligible = 0x352; // bool
    public const nint m_bApplyLayerMatchIDToModel = 0x353; // bool
    public const nint m_tokLayerMatchID = 0x354; // CUtlStringToken
    public const nint m_nSubclassID = 0x358; // CUtlStringToken
    public const nint m_nSimulationTick = 0x368; // int32_t
    public const nint m_iCurrentThinkContext = 0x36C; // int32_t
    public const nint m_aThinkFunctions = 0x370; // CUtlVector<thinkfunc_t>
    public const nint m_flAnimTime = 0x388; // float
    public const nint m_flSimulationTime = 0x38C; // float
    public const nint m_nSceneObjectOverrideFlags = 0x390; // uint8_t
    public const nint m_bHasSuccessfullyInterpolated = 0x391; // bool
    public const nint m_bHasAddedVarsToInterpolation = 0x392; // bool
    public const nint m_bRenderEvenWhenNotSuccessfullyInterpolated = 0x393; // bool
    public const nint m_nInterpolationLatchDirtyFlags = 0x394; // int32_t[2]
    public const nint m_ListEntry = 0x39C; // uint16_t[11]
    public const nint m_flCreateTime = 0x3B4; // GameTime_t
    public const nint m_flSpeed = 0x3B8; // float
    public const nint m_EntClientFlags = 0x3BC; // uint16_t
    public const nint m_bClientSideRagdoll = 0x3BE; // bool
    public const nint m_iTeamNum = 0x3BF; // uint8_t
    public const nint m_spawnflags = 0x3C0; // uint32_t
    public const nint m_nNextThinkTick = 0x3C4; // GameTick_t
    public const nint m_fFlags = 0x3C8; // uint32_t
    public const nint m_vecAbsVelocity = 0x3CC; // Vector
    public const nint m_vecVelocity = 0x3D8; // CNetworkVelocityVector
    public const nint m_vecBaseVelocity = 0x408; // Vector
    public const nint m_hEffectEntity = 0x414; // CHandle<C_BaseEntity>
    public const nint m_hOwnerEntity = 0x418; // CHandle<C_BaseEntity>
    public const nint m_MoveCollide = 0x41C; // MoveCollide_t
    public const nint m_MoveType = 0x41D; // MoveType_t
    public const nint m_flWaterLevel = 0x420; // float
    public const nint m_fEffects = 0x424; // uint32_t
    public const nint m_hGroundEntity = 0x428; // CHandle<C_BaseEntity>
    public const nint m_flFriction = 0x42C; // float
    public const nint m_flElasticity = 0x430; // float
    public const nint m_flGravityScale = 0x434; // float
    public const nint m_flTimeScale = 0x438; // float
    public const nint m_bSimulatedEveryTick = 0x43C; // bool
    public const nint m_bAnimatedEveryTick = 0x43D; // bool
    public const nint m_flNavIgnoreUntilTime = 0x440; // GameTime_t
    public const nint m_hThink = 0x444; // uint16_t
    public const nint m_fBBoxVisFlags = 0x450; // uint8_t
    public const nint m_bPredictable = 0x451; // bool
    public const nint m_bRenderWithViewModels = 0x452; // bool
    public const nint m_nSplitUserPlayerPredictionSlot = 0x454; // CSplitScreenSlot
    public const nint m_nFirstPredictableCommand = 0x458; // int32_t
    public const nint m_nLastPredictableCommand = 0x45C; // int32_t
    public const nint m_hOldMoveParent = 0x460; // CHandle<C_BaseEntity>
    public const nint m_Particles = 0x468; // CParticleProperty
    public const nint m_vecPredictedScriptFloats = 0x490; // CUtlVector<float>
    public const nint m_vecPredictedScriptFloatIDs = 0x4A8; // CUtlVector<int32_t>
    public const nint m_nNextScriptVarRecordID = 0x4D8; // int32_t
    public const nint m_vecAngVelocity = 0x4E8; // QAngle
    public const nint m_DataChangeEventRef = 0x4F4; // int32_t
    public const nint m_dependencies = 0x4F8; // CUtlVector<CEntityHandle>
    public const nint m_nCreationTick = 0x510; // int32_t
    public const nint m_bAnimTimeChanged = 0x529; // bool
    public const nint m_bSimulationTimeChanged = 0x52A; // bool
    public const nint m_sUniqueHammerID = 0x538; // CUtlString
}

public static class C_BaseFire {
    public const nint m_flScale = 0x540; // float
    public const nint m_flStartScale = 0x544; // float
    public const nint m_flScaleTime = 0x548; // float
    public const nint m_nFlags = 0x54C; // uint32_t
}

public static class C_BaseFlex {
    public const nint m_flexWeight = 0xE90; // C_NetworkUtlVectorBase<float>
    public const nint m_vLookTargetPosition = 0xEA8; // Vector
    public const nint m_blinktoggle = 0xEC0; // bool
    public const nint m_nLastFlexUpdateFrameCount = 0xF20; // int32_t
    public const nint m_CachedViewTarget = 0xF24; // Vector
    public const nint m_nNextSceneEventId = 0xF30; // uint32_t
    public const nint m_iBlink = 0xF34; // int32_t
    public const nint m_blinktime = 0xF38; // float
    public const nint m_prevblinktoggle = 0xF3C; // bool
    public const nint m_iJawOpen = 0xF40; // int32_t
    public const nint m_flJawOpenAmount = 0xF44; // float
    public const nint m_flBlinkAmount = 0xF48; // float
    public const nint m_iMouthAttachment = 0xF4C; // AttachmentHandle_t
    public const nint m_iEyeAttachment = 0xF4D; // AttachmentHandle_t
    public const nint m_bResetFlexWeightsOnModelChange = 0xF4E; // bool
    public const nint m_nEyeOcclusionRendererBone = 0xF68; // int32_t
    public const nint m_mEyeOcclusionRendererCameraToBoneTransform = 0xF6C; // matrix3x4_t
    public const nint m_vEyeOcclusionRendererHalfExtent = 0xF9C; // Vector
    public const nint m_PhonemeClasses = 0xFB8; // C_BaseFlex::Emphasized_Phoneme[3]
}

public static class C_BaseFlex_Emphasized_Phoneme {
    public const nint m_sClassName = 0x0; // CUtlString
    public const nint m_flAmount = 0x18; // float
    public const nint m_bRequired = 0x1C; // bool
    public const nint m_bBasechecked = 0x1D; // bool
    public const nint m_bValid = 0x1E; // bool
}

public static class C_BaseGrenade {
    public const nint m_bHasWarnedAI = 0x1018; // bool
    public const nint m_bIsSmokeGrenade = 0x1019; // bool
    public const nint m_bIsLive = 0x101A; // bool
    public const nint m_DmgRadius = 0x101C; // float
    public const nint m_flDetonateTime = 0x1020; // GameTime_t
    public const nint m_flWarnAITime = 0x1024; // float
    public const nint m_flDamage = 0x1028; // float
    public const nint m_iszBounceSound = 0x1030; // CUtlSymbolLarge
    public const nint m_ExplosionSound = 0x1038; // CUtlString
    public const nint m_hThrower = 0x1044; // CHandle<C_CSPlayerPawn>
    public const nint m_flNextAttack = 0x105C; // GameTime_t
    public const nint m_hOriginalThrower = 0x1060; // CHandle<C_CSPlayerPawn>
}

public static class C_BaseModelEntity {
    public const nint m_CRenderComponent = 0xA10; // CRenderComponent*
    public const nint m_CHitboxComponent = 0xA18; // CHitboxComponent
    public const nint m_bInitModelEffects = 0xA60; // bool
    public const nint m_bIsStaticProp = 0xA61; // bool
    public const nint m_nLastAddDecal = 0xA64; // int32_t
    public const nint m_nDecalsAdded = 0xA68; // int32_t
    public const nint m_iOldHealth = 0xA6C; // int32_t
    public const nint m_nRenderMode = 0xA70; // RenderMode_t
    public const nint m_nRenderFX = 0xA71; // RenderFx_t
    public const nint m_bAllowFadeInView = 0xA72; // bool
    public const nint m_clrRender = 0xA73; // Color
    public const nint m_vecRenderAttributes = 0xA78; // C_UtlVectorEmbeddedNetworkVar<EntityRenderAttribute_t>
    public const nint m_bRenderToCubemaps = 0xAE0; // bool
    public const nint m_Collision = 0xAE8; // CCollisionProperty
    public const nint m_Glow = 0xB98; // CGlowProperty
    public const nint m_flGlowBackfaceMult = 0xBF0; // float
    public const nint m_fadeMinDist = 0xBF4; // float
    public const nint m_fadeMaxDist = 0xBF8; // float
    public const nint m_flFadeScale = 0xBFC; // float
    public const nint m_flShadowStrength = 0xC00; // float
    public const nint m_nObjectCulling = 0xC04; // uint8_t
    public const nint m_nAddDecal = 0xC08; // int32_t
    public const nint m_vDecalPosition = 0xC0C; // Vector
    public const nint m_vDecalForwardAxis = 0xC18; // Vector
    public const nint m_flDecalHealBloodRate = 0xC24; // float
    public const nint m_flDecalHealHeightRate = 0xC28; // float
    public const nint m_ConfigEntitiesToPropagateMaterialDecalsTo = 0xC30; // C_NetworkUtlVectorBase<CHandle<C_BaseModelEntity>>
    public const nint m_vecViewOffset = 0xC48; // CNetworkViewOffsetVector
    public const nint m_pClientAlphaProperty = 0xC78; // CClientAlphaProperty*
    public const nint m_ClientOverrideTint = 0xC80; // Color
    public const nint m_bUseClientOverrideTint = 0xC84; // bool
}

public static class C_BasePlayerPawn {
    public const nint m_pWeaponServices = 0x10A8; // CPlayer_WeaponServices*
    public const nint m_pItemServices = 0x10B0; // CPlayer_ItemServices*
    public const nint m_pAutoaimServices = 0x10B8; // CPlayer_AutoaimServices*
    public const nint m_pObserverServices = 0x10C0; // CPlayer_ObserverServices*
    public const nint m_pWaterServices = 0x10C8; // CPlayer_WaterServices*
    public const nint m_pUseServices = 0x10D0; // CPlayer_UseServices*
    public const nint m_pFlashlightServices = 0x10D8; // CPlayer_FlashlightServices*
    public const nint m_pCameraServices = 0x10E0; // CPlayer_CameraServices*
    public const nint m_pMovementServices = 0x10E8; // CPlayer_MovementServices*
    public const nint m_ServerViewAngleChanges = 0x10F8; // C_UtlVectorEmbeddedNetworkVar<ViewAngleServerChange_t>
    public const nint m_nHighestConsumedServerViewAngleChangeIndex = 0x1148; // uint32_t
    public const nint v_angle = 0x114C; // QAngle
    public const nint v_anglePrevious = 0x1158; // QAngle
    public const nint m_iHideHUD = 0x1164; // uint32_t
    public const nint m_skybox3d = 0x1168; // sky3dparams_t
    public const nint m_flDeathTime = 0x11F8; // GameTime_t
    public const nint m_vecPredictionError = 0x11FC; // Vector
    public const nint m_flPredictionErrorTime = 0x1208; // GameTime_t
    public const nint m_vecLastCameraSetupLocalOrigin = 0x120C; // Vector
    public const nint m_flLastCameraSetupTime = 0x1218; // GameTime_t
    public const nint m_flFOVSensitivityAdjust = 0x121C; // float
    public const nint m_flMouseSensitivity = 0x1220; // float
    public const nint m_vOldOrigin = 0x1224; // Vector
    public const nint m_flOldSimulationTime = 0x1230; // float
    public const nint m_nLastExecutedCommandNumber = 0x1234; // int32_t
    public const nint m_nLastExecutedCommandTick = 0x1238; // int32_t
    public const nint m_hController = 0x123C; // CHandle<CBasePlayerController>
    public const nint m_bIsSwappingToPredictableController = 0x1240; // bool
}

public static class C_BasePlayerWeapon {
    public const nint m_nNextPrimaryAttackTick = 0x1560; // GameTick_t
    public const nint m_flNextPrimaryAttackTickRatio = 0x1564; // float
    public const nint m_nNextSecondaryAttackTick = 0x1568; // GameTick_t
    public const nint m_flNextSecondaryAttackTickRatio = 0x156C; // float
    public const nint m_iClip1 = 0x1570; // int32_t
    public const nint m_iClip2 = 0x1574; // int32_t
    public const nint m_pReserveAmmo = 0x1578; // int32_t[2]
}

public static class C_BasePropDoor {
    public const nint m_eDoorState = 0x10F8; // DoorState_t
    public const nint m_modelChanged = 0x10FC; // bool
    public const nint m_bLocked = 0x10FD; // bool
    public const nint m_closedPosition = 0x1100; // Vector
    public const nint m_closedAngles = 0x110C; // QAngle
    public const nint m_hMaster = 0x1118; // CHandle<C_BasePropDoor>
    public const nint m_vWhereToSetLightingOrigin = 0x111C; // Vector
}

public static class C_BaseTrigger {
    public const nint m_bDisabled = 0xCC0; // bool
    public const nint m_bClientSidePredicted = 0xCC1; // bool
}

public static class C_BaseViewModel {
    public const nint m_vecLastFacing = 0xE88; // Vector
    public const nint m_nViewModelIndex = 0xE94; // uint32_t
    public const nint m_nAnimationParity = 0xE98; // uint32_t
    public const nint m_flAnimationStartTime = 0xE9C; // float
    public const nint m_hWeapon = 0xEA0; // CHandle<C_BasePlayerWeapon>
    public const nint m_sVMName = 0xEA8; // CUtlSymbolLarge
    public const nint m_sAnimationPrefix = 0xEB0; // CUtlSymbolLarge
    public const nint m_hWeaponModel = 0xEB8; // CHandle<C_ViewmodelWeapon>
    public const nint m_iCameraAttachment = 0xEBC; // AttachmentHandle_t
    public const nint m_vecLastCameraAngles = 0xEC0; // QAngle
    public const nint m_previousElapsedDuration = 0xECC; // float
    public const nint m_previousCycle = 0xED0; // float
    public const nint m_nOldAnimationParity = 0xED4; // int32_t
    public const nint m_hOldLayerSequence = 0xED8; // HSequence
    public const nint m_oldLayer = 0xEDC; // int32_t
    public const nint m_oldLayerStartTime = 0xEE0; // float
    public const nint m_hControlPanel = 0xEE4; // CHandle<C_BaseEntity>
}

public static class C_Beam {
    public const nint m_flFrameRate = 0xCC0; // float
    public const nint m_flHDRColorScale = 0xCC4; // float
    public const nint m_flFireTime = 0xCC8; // GameTime_t
    public const nint m_flDamage = 0xCCC; // float
    public const nint m_nNumBeamEnts = 0xCD0; // uint8_t
    public const nint m_queryHandleHalo = 0xCD4; // int32_t
    public const nint m_hBaseMaterial = 0xCF8; // CStrongHandle<InfoForResourceTypeIMaterial2>
    public const nint m_nHaloIndex = 0xD00; // CStrongHandle<InfoForResourceTypeIMaterial2>
    public const nint m_nBeamType = 0xD08; // BeamType_t
    public const nint m_nBeamFlags = 0xD0C; // uint32_t
    public const nint m_hAttachEntity = 0xD10; // CHandle<C_BaseEntity>[10]
    public const nint m_nAttachIndex = 0xD38; // AttachmentHandle_t[10]
    public const nint m_fWidth = 0xD44; // float
    public const nint m_fEndWidth = 0xD48; // float
    public const nint m_fFadeLength = 0xD4C; // float
    public const nint m_fHaloScale = 0xD50; // float
    public const nint m_fAmplitude = 0xD54; // float
    public const nint m_fStartFrame = 0xD58; // float
    public const nint m_fSpeed = 0xD5C; // float
    public const nint m_flFrame = 0xD60; // float
    public const nint m_nClipStyle = 0xD64; // BeamClipStyle_t
    public const nint m_bTurnedOff = 0xD68; // bool
    public const nint m_vecEndPos = 0xD6C; // Vector
    public const nint m_hEndEntity = 0xD78; // CHandle<C_BaseEntity>
}

public static class C_BreakableProp {
    public const nint m_OnBreak = 0xEC8; // CEntityIOOutput
    public const nint m_OnHealthChanged = 0xEF0; // CEntityOutputTemplate<float>
    public const nint m_OnTakeDamage = 0xF18; // CEntityIOOutput
    public const nint m_impactEnergyScale = 0xF40; // float
    public const nint m_iMinHealthDmg = 0xF44; // int32_t
    public const nint m_flPressureDelay = 0xF48; // float
    public const nint m_hBreaker = 0xF4C; // CHandle<C_BaseEntity>
    public const nint m_PerformanceMode = 0xF50; // PerformanceMode_t
    public const nint m_flDmgModBullet = 0xF54; // float
    public const nint m_flDmgModClub = 0xF58; // float
    public const nint m_flDmgModExplosive = 0xF5C; // float
    public const nint m_flDmgModFire = 0xF60; // float
    public const nint m_iszPhysicsDamageTableName = 0xF68; // CUtlSymbolLarge
    public const nint m_iszBasePropData = 0xF70; // CUtlSymbolLarge
    public const nint m_iInteractions = 0xF78; // int32_t
    public const nint m_flPreventDamageBeforeTime = 0xF7C; // GameTime_t
    public const nint m_bHasBreakPiecesOrCommands = 0xF80; // bool
    public const nint m_explodeDamage = 0xF84; // float
    public const nint m_explodeRadius = 0xF88; // float
    public const nint m_explosionDelay = 0xF90; // float
    public const nint m_explosionBuildupSound = 0xF98; // CUtlSymbolLarge
    public const nint m_explosionCustomEffect = 0xFA0; // CUtlSymbolLarge
    public const nint m_explosionCustomSound = 0xFA8; // CUtlSymbolLarge
    public const nint m_explosionModifier = 0xFB0; // CUtlSymbolLarge
    public const nint m_hPhysicsAttacker = 0xFB8; // CHandle<C_BasePlayerPawn>
    public const nint m_flLastPhysicsInfluenceTime = 0xFBC; // GameTime_t
    public const nint m_flDefaultFadeScale = 0xFC0; // float
    public const nint m_hLastAttacker = 0xFC4; // CHandle<C_BaseEntity>
    public const nint m_hFlareEnt = 0xFC8; // CHandle<C_BaseEntity>
    public const nint m_noGhostCollision = 0xFCC; // bool
}

public static class C_BulletHitModel {
    public const nint m_matLocal = 0xE80; // matrix3x4_t
    public const nint m_iBoneIndex = 0xEB0; // int32_t
    public const nint m_hPlayerParent = 0xEB4; // CHandle<C_BaseEntity>
    public const nint m_bIsHit = 0xEB8; // bool
    public const nint m_flTimeCreated = 0xEBC; // float
    public const nint m_vecStartPos = 0xEC0; // Vector
}

public static class C_C4 {
    public const nint m_szScreenText = 0x19F0; // char[32]
    public const nint m_activeLightParticleIndex = 0x1A10; // ParticleIndex_t
    public const nint m_eActiveLightEffect = 0x1A14; // C4LightEffect_t
    public const nint m_bStartedArming = 0x1A18; // bool
    public const nint m_fArmedTime = 0x1A1C; // GameTime_t
    public const nint m_bBombPlacedAnimation = 0x1A20; // bool
    public const nint m_bIsPlantingViaUse = 0x1A21; // bool
    public const nint m_entitySpottedState = 0x1A28; // EntitySpottedState_t
    public const nint m_nSpotRules = 0x1A40; // int32_t
    public const nint m_bPlayedArmingBeeps = 0x1A44; // bool[7]
    public const nint m_bBombPlanted = 0x1A4B; // bool
    public const nint m_bDroppedFromDeath = 0x1A4C; // bool
}

public static class C_CSGOViewModel {
    public const nint m_bShouldIgnoreOffsetAndAccuracy = 0xF10; // bool
    public const nint m_nWeaponParity = 0xF14; // uint32_t
    public const nint m_nOldWeaponParity = 0xF18; // uint32_t
    public const nint m_nLastKnownAssociatedWeaponEntIndex = 0xF1C; // CEntityIndex
    public const nint m_bNeedToQueueHighResComposite = 0xF20; // bool
    public const nint m_vLoweredWeaponOffset = 0xF64; // QAngle
}

public static class C_CSGO_MapPreviewCameraPath {
    public const nint m_flZFar = 0x540; // float
    public const nint m_flZNear = 0x544; // float
    public const nint m_bLoop = 0x548; // bool
    public const nint m_bVerticalFOV = 0x549; // bool
    public const nint m_bConstantSpeed = 0x54A; // bool
    public const nint m_flDuration = 0x54C; // float
    public const nint m_flPathLength = 0x590; // float
    public const nint m_flPathDuration = 0x594; // float
}

public static class C_CSGO_MapPreviewCameraPathNode {
    public const nint m_szParentPathUniqueID = 0x540; // CUtlSymbolLarge
    public const nint m_nPathIndex = 0x548; // int32_t
    public const nint m_vInTangentLocal = 0x54C; // Vector
    public const nint m_vOutTangentLocal = 0x558; // Vector
    public const nint m_flFOV = 0x564; // float
    public const nint m_flSpeed = 0x568; // float
    public const nint m_flEaseIn = 0x56C; // float
    public const nint m_flEaseOut = 0x570; // float
    public const nint m_vInTangentWorld = 0x574; // Vector
    public const nint m_vOutTangentWorld = 0x580; // Vector
}

public static class C_CSGO_PreviewModel {
    public const nint m_animgraph = 0x1018; // CUtlString
    public const nint m_animgraphCharacterModeString = 0x1020; // CUtlString
    public const nint m_defaultAnim = 0x1028; // CUtlString
    public const nint m_nDefaultAnimLoopMode = 0x1030; // AnimLoopMode_t
    public const nint m_flInitialModelScale = 0x1034; // float
}

public static class C_CSGO_PreviewPlayer {
    public const nint m_animgraph = 0x22E8; // CUtlString
    public const nint m_animgraphCharacterModeString = 0x22F0; // CUtlString
    public const nint m_flInitialModelScale = 0x22F8; // float
}

public static class C_CSGO_TeamPreviewCamera {
    public const nint m_nVariant = 0x5A0; // int32_t
    public const nint m_bDofEnabled = 0x5A4; // bool
    public const nint m_flDofNearBlurry = 0x5A8; // float
    public const nint m_flDofNearCrisp = 0x5AC; // float
    public const nint m_flDofFarCrisp = 0x5B0; // float
    public const nint m_flDofFarBlurry = 0x5B4; // float
    public const nint m_flDofTiltToGround = 0x5B8; // float
}

public static class C_CSGO_TeamPreviewCharacterPosition {
    public const nint m_nVariant = 0x540; // int32_t
    public const nint m_nRandom = 0x544; // int32_t
    public const nint m_nOrdinal = 0x548; // int32_t
    public const nint m_sWeaponName = 0x550; // CUtlString
    public const nint m_xuid = 0x558; // uint64_t
    public const nint m_agentItem = 0x560; // C_EconItemView
    public const nint m_glovesItem = 0x9A8; // C_EconItemView
    public const nint m_weaponItem = 0xDF0; // C_EconItemView
}

public static class C_CSGameRules {
    public const nint __m_pChainEntity = 0x8; // CNetworkVarChainer
    public const nint m_bFreezePeriod = 0x30; // bool
    public const nint m_bWarmupPeriod = 0x31; // bool
    public const nint m_fWarmupPeriodEnd = 0x34; // GameTime_t
    public const nint m_fWarmupPeriodStart = 0x38; // GameTime_t
    public const nint m_nTotalPausedTicks = 0x3C; // int32_t
    public const nint m_nPauseStartTick = 0x40; // int32_t
    public const nint m_bServerPaused = 0x44; // bool
    public const nint m_bGamePaused = 0x45; // bool
    public const nint m_bTerroristTimeOutActive = 0x46; // bool
    public const nint m_bCTTimeOutActive = 0x47; // bool
    public const nint m_flTerroristTimeOutRemaining = 0x48; // float
    public const nint m_flCTTimeOutRemaining = 0x4C; // float
    public const nint m_nTerroristTimeOuts = 0x50; // int32_t
    public const nint m_nCTTimeOuts = 0x54; // int32_t
    public const nint m_bTechnicalTimeOut = 0x58; // bool
    public const nint m_bMatchWaitingForResume = 0x59; // bool
    public const nint m_iRoundTime = 0x5C; // int32_t
    public const nint m_fMatchStartTime = 0x60; // float
    public const nint m_fRoundStartTime = 0x64; // GameTime_t
    public const nint m_flRestartRoundTime = 0x68; // GameTime_t
    public const nint m_bGameRestart = 0x6C; // bool
    public const nint m_flGameStartTime = 0x70; // float
    public const nint m_timeUntilNextPhaseStarts = 0x74; // float
    public const nint m_gamePhase = 0x78; // int32_t
    public const nint m_totalRoundsPlayed = 0x7C; // int32_t
    public const nint m_nRoundsPlayedThisPhase = 0x80; // int32_t
    public const nint m_nOvertimePlaying = 0x84; // int32_t
    public const nint m_iHostagesRemaining = 0x88; // int32_t
    public const nint m_bAnyHostageReached = 0x8C; // bool
    public const nint m_bMapHasBombTarget = 0x8D; // bool
    public const nint m_bMapHasRescueZone = 0x8E; // bool
    public const nint m_bMapHasBuyZone = 0x8F; // bool
    public const nint m_bIsQueuedMatchmaking = 0x90; // bool
    public const nint m_nQueuedMatchmakingMode = 0x94; // int32_t
    public const nint m_bIsValveDS = 0x98; // bool
    public const nint m_bLogoMap = 0x99; // bool
    public const nint m_bPlayAllStepSoundsOnServer = 0x9A; // bool
    public const nint m_iSpectatorSlotCount = 0x9C; // int32_t
    public const nint m_MatchDevice = 0xA0; // int32_t
    public const nint m_bHasMatchStarted = 0xA4; // bool
    public const nint m_nNextMapInMapgroup = 0xA8; // int32_t
    public const nint m_szTournamentEventName = 0xAC; // char[512]
    public const nint m_szTournamentEventStage = 0x2AC; // char[512]
    public const nint m_szMatchStatTxt = 0x4AC; // char[512]
    public const nint m_szTournamentPredictionsTxt = 0x6AC; // char[512]
    public const nint m_nTournamentPredictionsPct = 0x8AC; // int32_t
    public const nint m_flCMMItemDropRevealStartTime = 0x8B0; // GameTime_t
    public const nint m_flCMMItemDropRevealEndTime = 0x8B4; // GameTime_t
    public const nint m_bIsDroppingItems = 0x8B8; // bool
    public const nint m_bIsQuestEligible = 0x8B9; // bool
    public const nint m_bIsHltvActive = 0x8BA; // bool
    public const nint m_nGuardianModeWaveNumber = 0x8BC; // int32_t
    public const nint m_nGuardianModeSpecialKillsRemaining = 0x8C0; // int32_t
    public const nint m_nGuardianModeSpecialWeaponNeeded = 0x8C4; // int32_t
    public const nint m_nGuardianGrenadesToGiveBots = 0x8C8; // int32_t
    public const nint m_nNumHeaviesToSpawn = 0x8CC; // int32_t
    public const nint m_numGlobalGiftsGiven = 0x8D0; // uint32_t
    public const nint m_numGlobalGifters = 0x8D4; // uint32_t
    public const nint m_numGlobalGiftsPeriodSeconds = 0x8D8; // uint32_t
    public const nint m_arrFeaturedGiftersAccounts = 0x8DC; // uint32_t[4]
    public const nint m_arrFeaturedGiftersGifts = 0x8EC; // uint32_t[4]
    public const nint m_arrProhibitedItemIndices = 0x8FC; // uint16_t[100]
    public const nint m_arrTournamentActiveCasterAccounts = 0x9C4; // uint32_t[4]
    public const nint m_numBestOfMaps = 0x9D4; // int32_t
    public const nint m_nHalloweenMaskListSeed = 0x9D8; // int32_t
    public const nint m_bBombDropped = 0x9DC; // bool
    public const nint m_bBombPlanted = 0x9DD; // bool
    public const nint m_iRoundWinStatus = 0x9E0; // int32_t
    public const nint m_eRoundWinReason = 0x9E4; // int32_t
    public const nint m_bTCantBuy = 0x9E8; // bool
    public const nint m_bCTCantBuy = 0x9E9; // bool
    public const nint m_flGuardianBuyUntilTime = 0x9EC; // GameTime_t
    public const nint m_iMatchStats_RoundResults = 0x9F0; // int32_t[30]
    public const nint m_iMatchStats_PlayersAlive_CT = 0xA68; // int32_t[30]
    public const nint m_iMatchStats_PlayersAlive_T = 0xAE0; // int32_t[30]
    public const nint m_TeamRespawnWaveTimes = 0xB58; // float[32]
    public const nint m_flNextRespawnWave = 0xBD8; // GameTime_t[32]
    public const nint m_nServerQuestID = 0xC58; // int32_t
    public const nint m_vMinimapMins = 0xC5C; // Vector
    public const nint m_vMinimapMaxs = 0xC68; // Vector
    public const nint m_MinimapVerticalSectionHeights = 0xC74; // float[8]
    public const nint m_bDontIncrementCoopWave = 0xC94; // bool
    public const nint m_bSpawnedTerrorHuntHeavy = 0xC95; // bool
    public const nint m_nEndMatchMapGroupVoteTypes = 0xC98; // int32_t[10]
    public const nint m_nEndMatchMapGroupVoteOptions = 0xCC0; // int32_t[10]
    public const nint m_nEndMatchMapVoteWinner = 0xCE8; // int32_t
    public const nint m_iNumConsecutiveCTLoses = 0xCEC; // int32_t
    public const nint m_iNumConsecutiveTerroristLoses = 0xCF0; // int32_t
    public const nint m_bMarkClientStopRecordAtRoundEnd = 0xD10; // bool
    public const nint m_nMatchAbortedEarlyReason = 0xD68; // int32_t
    public const nint m_bHasTriggeredRoundStartMusic = 0xD6C; // bool
    public const nint m_bHasTriggeredCoopSpawnReset = 0xD6D; // bool
    public const nint m_bSwitchingTeamsAtRoundReset = 0xD6E; // bool
    public const nint m_pGameModeRules = 0xD88; // CCSGameModeRules*
    public const nint m_RetakeRules = 0xD90; // C_RetakeGameRules
    public const nint m_nMatchEndCount = 0xEA8; // uint8_t
    public const nint m_nTTeamIntroVariant = 0xEAC; // int32_t
    public const nint m_nCTTeamIntroVariant = 0xEB0; // int32_t
    public const nint m_bTeamIntroPeriod = 0xEB4; // bool
    public const nint m_flLastPerfSampleTime = 0x4EC0; // double
}

public static class C_CSGameRulesProxy {
    public const nint m_pGameRules = 0x540; // C_CSGameRules*
}

public static class C_CSObserverPawn {
    public const nint m_hDetectParentChange = 0x16B0; // CEntityHandle
}

public static class C_CSPlayerPawn {
    public const nint m_pBulletServices = 0x16B0; // CCSPlayer_BulletServices*
    public const nint m_pHostageServices = 0x16B8; // CCSPlayer_HostageServices*
    public const nint m_pBuyServices = 0x16C0; // CCSPlayer_BuyServices*
    public const nint m_pGlowServices = 0x16C8; // CCSPlayer_GlowServices*
    public const nint m_pActionTrackingServices = 0x16D0; // CCSPlayer_ActionTrackingServices*
    public const nint m_flHealthShotBoostExpirationTime = 0x16D8; // GameTime_t
    public const nint m_flLastFiredWeaponTime = 0x16DC; // GameTime_t
    public const nint m_bHasFemaleVoice = 0x16E0; // bool
    public const nint m_flLandseconds = 0x16E4; // float
    public const nint m_flOldFallVelocity = 0x16E8; // float
    public const nint m_szLastPlaceName = 0x16EC; // char[18]
    public const nint m_bPrevDefuser = 0x16FE; // bool
    public const nint m_bPrevHelmet = 0x16FF; // bool
    public const nint m_nPrevArmorVal = 0x1700; // int32_t
    public const nint m_nPrevGrenadeAmmoCount = 0x1704; // int32_t
    public const nint m_unPreviousWeaponHash = 0x1708; // uint32_t
    public const nint m_unWeaponHash = 0x170C; // uint32_t
    public const nint m_bInBuyZone = 0x1710; // bool
    public const nint m_bPreviouslyInBuyZone = 0x1711; // bool
    public const nint m_aimPunchAngle = 0x1714; // QAngle
    public const nint m_aimPunchAngleVel = 0x1720; // QAngle
    public const nint m_aimPunchTickBase = 0x172C; // int32_t
    public const nint m_aimPunchTickFraction = 0x1730; // float
    public const nint m_aimPunchCache = 0x1738; // CUtlVector<QAngle>
    public const nint m_bInLanding = 0x1758; // bool
    public const nint m_flLandingTime = 0x175C; // float
    public const nint m_bInHostageRescueZone = 0x1760; // bool
    public const nint m_bInBombZone = 0x1761; // bool
    public const nint m_bIsBuyMenuOpen = 0x1762; // bool
    public const nint m_flTimeOfLastInjury = 0x1764; // GameTime_t
    public const nint m_flNextSprayDecalTime = 0x1768; // GameTime_t
    public const nint m_iRetakesOffering = 0x1880; // int32_t
    public const nint m_iRetakesOfferingCard = 0x1884; // int32_t
    public const nint m_bRetakesHasDefuseKit = 0x1888; // bool
    public const nint m_bRetakesMVPLastRound = 0x1889; // bool
    public const nint m_iRetakesMVPBoostItem = 0x188C; // int32_t
    public const nint m_RetakesMVPBoostExtraUtility = 0x1890; // loadout_slot_t
    public const nint m_bNeedToReApplyGloves = 0x18B0; // bool
    public const nint m_EconGloves = 0x18B8; // C_EconItemView
    public const nint m_bMustSyncRagdollState = 0x1D00; // bool
    public const nint m_nRagdollDamageBone = 0x1D04; // int32_t
    public const nint m_vRagdollDamageForce = 0x1D08; // Vector
    public const nint m_vRagdollDamagePosition = 0x1D14; // Vector
    public const nint m_szRagdollDamageWeaponName = 0x1D20; // char[64]
    public const nint m_bRagdollDamageHeadshot = 0x1D60; // bool
    public const nint m_vRagdollServerOrigin = 0x1D64; // Vector
    public const nint m_bLastHeadBoneTransformIsValid = 0x22B0; // bool
    public const nint m_lastLandTime = 0x22B4; // GameTime_t
    public const nint m_bOnGroundLastTick = 0x22B8; // bool
    public const nint m_qDeathEyeAngles = 0x22D4; // QAngle
    public const nint m_bSkipOneHeadConstraintUpdate = 0x22E0; // bool
}

public static class C_CSPlayerPawnBase {
    public const nint m_pPingServices = 0x1268; // CCSPlayer_PingServices*
    public const nint m_pViewModelServices = 0x1270; // CPlayer_ViewModelServices*
    public const nint m_fRenderingClipPlane = 0x1278; // float[4]
    public const nint m_nLastClipPlaneSetupFrame = 0x1288; // int32_t
    public const nint m_vecLastClipCameraPos = 0x128C; // Vector
    public const nint m_vecLastClipCameraForward = 0x1298; // Vector
    public const nint m_bClipHitStaticWorld = 0x12A4; // bool
    public const nint m_bCachedPlaneIsValid = 0x12A5; // bool
    public const nint m_pClippingWeapon = 0x12A8; // C_CSWeaponBase*
    public const nint m_previousPlayerState = 0x12B0; // CSPlayerState
    public const nint m_flLastCollisionCeiling = 0x12B4; // float
    public const nint m_flLastCollisionCeilingChangeTime = 0x12B8; // float
    public const nint m_grenadeParameterStashTime = 0x12D8; // GameTime_t
    public const nint m_bGrenadeParametersStashed = 0x12DC; // bool
    public const nint m_angStashedShootAngles = 0x12E0; // QAngle
    public const nint m_vecStashedGrenadeThrowPosition = 0x12EC; // Vector
    public const nint m_vecStashedVelocity = 0x12F8; // Vector
    public const nint m_angShootAngleHistory = 0x1304; // QAngle[2]
    public const nint m_vecThrowPositionHistory = 0x131C; // Vector[2]
    public const nint m_vecVelocityHistory = 0x1334; // Vector[2]
    public const nint m_thirdPersonHeading = 0x1350; // QAngle
    public const nint m_flSlopeDropOffset = 0x1368; // float
    public const nint m_flSlopeDropHeight = 0x1378; // float
    public const nint m_vHeadConstraintOffset = 0x1388; // Vector
    public const nint m_bIsScoped = 0x13A0; // bool
    public const nint m_bIsWalking = 0x13A1; // bool
    public const nint m_bResumeZoom = 0x13A2; // bool
    public const nint m_iPlayerState = 0x13A4; // CSPlayerState
    public const nint m_bIsDefusing = 0x13A8; // bool
    public const nint m_bIsGrabbingHostage = 0x13A9; // bool
    public const nint m_iBlockingUseActionInProgress = 0x13AC; // CSPlayerBlockingUseAction_t
    public const nint m_bIsRescuing = 0x13B0; // bool
    public const nint m_fImmuneToGunGameDamageTime = 0x13B4; // GameTime_t
    public const nint m_fImmuneToGunGameDamageTimeLast = 0x13B8; // GameTime_t
    public const nint m_bGunGameImmunity = 0x13BC; // bool
    public const nint m_bHasMovedSinceSpawn = 0x13BD; // bool
    public const nint m_fMolotovUseTime = 0x13C0; // float
    public const nint m_fMolotovDamageTime = 0x13C4; // float
    public const nint m_nWhichBombZone = 0x13C8; // int32_t
    public const nint m_bInNoDefuseArea = 0x13CC; // bool
    public const nint m_iThrowGrenadeCounter = 0x13D0; // int32_t
    public const nint m_bWaitForNoAttack = 0x13D4; // bool
    public const nint m_flGuardianTooFarDistFrac = 0x13D8; // float
    public const nint m_flDetectedByEnemySensorTime = 0x13DC; // GameTime_t
    public const nint m_flNextGuardianTooFarWarning = 0x13E0; // float
    public const nint m_bSuppressGuardianTooFarWarningAudio = 0x13E4; // bool
    public const nint m_bKilledByTaser = 0x13E5; // bool
    public const nint m_iMoveState = 0x13E8; // int32_t
    public const nint m_bCanMoveDuringFreezePeriod = 0x13EC; // bool
    public const nint m_flLowerBodyYawTarget = 0x13F0; // float
    public const nint m_bStrafing = 0x13F4; // bool
    public const nint m_flLastSpawnTimeIndex = 0x13F8; // GameTime_t
    public const nint m_flEmitSoundTime = 0x13FC; // GameTime_t
    public const nint m_iAddonBits = 0x1400; // int32_t
    public const nint m_iPrimaryAddon = 0x1404; // int32_t
    public const nint m_iSecondaryAddon = 0x1408; // int32_t
    public const nint m_iProgressBarDuration = 0x140C; // int32_t
    public const nint m_flProgressBarStartTime = 0x1410; // float
    public const nint m_iDirection = 0x1414; // int32_t
    public const nint m_iShotsFired = 0x1418; // int32_t
    public const nint m_bNightVisionOn = 0x141C; // bool
    public const nint m_bHasNightVision = 0x141D; // bool
    public const nint m_flVelocityModifier = 0x1420; // float
    public const nint m_flHitHeading = 0x1424; // float
    public const nint m_nHitBodyPart = 0x1428; // int32_t
    public const nint m_iStartAccount = 0x142C; // int32_t
    public const nint m_vecIntroStartEyePosition = 0x1430; // Vector
    public const nint m_vecIntroStartPlayerForward = 0x143C; // Vector
    public const nint m_flClientDeathTime = 0x1448; // GameTime_t
    public const nint m_flNightVisionAlpha = 0x144C; // float
    public const nint m_bScreenTearFrameCaptured = 0x1450; // bool
    public const nint m_flFlashBangTime = 0x1454; // float
    public const nint m_flFlashScreenshotAlpha = 0x1458; // float
    public const nint m_flFlashOverlayAlpha = 0x145C; // float
    public const nint m_bFlashBuildUp = 0x1460; // bool
    public const nint m_bFlashDspHasBeenCleared = 0x1461; // bool
    public const nint m_bFlashScreenshotHasBeenGrabbed = 0x1462; // bool
    public const nint m_flFlashMaxAlpha = 0x1464; // float
    public const nint m_flFlashDuration = 0x1468; // float
    public const nint m_lastStandingPos = 0x146C; // Vector
    public const nint m_vecLastMuzzleFlashPos = 0x1478; // Vector
    public const nint m_angLastMuzzleFlashAngle = 0x1484; // QAngle
    public const nint m_hMuzzleFlashShape = 0x1490; // CHandle<C_BaseEntity>
    public const nint m_iHealthBarRenderMaskIndex = 0x1494; // int32_t
    public const nint m_flHealthFadeValue = 0x1498; // float
    public const nint m_flHealthFadeAlpha = 0x149C; // float
    public const nint m_nMyCollisionGroup = 0x14A0; // int32_t
    public const nint m_ignoreLadderJumpTime = 0x14A4; // float
    public const nint m_ladderSurpressionTimer = 0x14A8; // CountdownTimer
    public const nint m_lastLadderNormal = 0x14C0; // Vector
    public const nint m_lastLadderPos = 0x14CC; // Vector
    public const nint m_flDeathCCWeight = 0x14E0; // float
    public const nint m_bOldIsScoped = 0x14E4; // bool
    public const nint m_flPrevRoundEndTime = 0x14E8; // float
    public const nint m_flPrevMatchEndTime = 0x14EC; // float
    public const nint m_unCurrentEquipmentValue = 0x14F0; // uint16_t
    public const nint m_unRoundStartEquipmentValue = 0x14F2; // uint16_t
    public const nint m_unFreezetimeEndEquipmentValue = 0x14F4; // uint16_t
    public const nint m_vecThirdPersonViewPositionOverride = 0x14F8; // Vector
    public const nint m_nHeavyAssaultSuitCooldownRemaining = 0x1504; // int32_t
    public const nint m_ArmorValue = 0x1508; // int32_t
    public const nint m_angEyeAngles = 0x1510; // QAngle
    public const nint m_fNextThinkPushAway = 0x1528; // float
    public const nint m_bShouldAutobuyDMWeapons = 0x152C; // bool
    public const nint m_bShouldAutobuyNow = 0x152D; // bool
    public const nint m_bHud_MiniScoreHidden = 0x152E; // bool
    public const nint m_bHud_RadarHidden = 0x152F; // bool
    public const nint m_nLastKillerIndex = 0x1530; // CEntityIndex
    public const nint m_nLastConcurrentKilled = 0x1534; // int32_t
    public const nint m_nDeathCamMusic = 0x1538; // int32_t
    public const nint m_iIDEntIndex = 0x153C; // CEntityIndex
    public const nint m_delayTargetIDTimer = 0x1540; // CountdownTimer
    public const nint m_iTargetedWeaponEntIndex = 0x1558; // CEntityIndex
    public const nint m_iOldIDEntIndex = 0x155C; // CEntityIndex
    public const nint m_holdTargetIDTimer = 0x1560; // CountdownTimer
    public const nint m_flCurrentMusicStartTime = 0x157C; // float
    public const nint m_flMusicRoundStartTime = 0x1580; // float
    public const nint m_bDeferStartMusicOnWarmup = 0x1584; // bool
    public const nint m_cycleLatch = 0x1588; // int32_t
    public const nint m_serverIntendedCycle = 0x158C; // float
    public const nint m_vecPlayerPatchEconIndices = 0x1590; // uint32_t[5]
    public const nint m_bHideTargetID = 0x15AC; // bool
    public const nint m_nextTaserShakeTime = 0x15B0; // float
    public const nint m_firstTaserShakeTime = 0x15B4; // float
    public const nint m_flLastSmokeOverlayAlpha = 0x15B8; // float
    public const nint m_vLastSmokeOverlayColor = 0x15BC; // Vector
    public const nint m_nPlayerSmokedFx = 0x15C8; // ParticleIndex_t
    public const nint m_flNextMagDropTime = 0x15CC; // float
    public const nint m_nLastMagDropAttachmentIndex = 0x15D0; // int32_t
    public const nint m_vecBulletHitModels = 0x15D8; // CUtlVector<C_BulletHitModel*>
    public const nint m_vecPickupModelSlerpers = 0x15F0; // CUtlVector<C_PickUpModelSlerper*>
    public const nint m_vecLastAliveLocalVelocity = 0x1608; // Vector
    public const nint m_entitySpottedState = 0x1630; // EntitySpottedState_t
    public const nint m_nSurvivalTeamNumber = 0x1648; // int32_t
    public const nint m_bGuardianShouldSprayCustomXMark = 0x164C; // bool
    public const nint m_bHasDeathInfo = 0x164D; // bool
    public const nint m_flDeathInfoTime = 0x1650; // float
    public const nint m_vecDeathInfoOrigin = 0x1654; // Vector
    public const nint m_bKilledByHeadshot = 0x1660; // bool
    public const nint m_hOriginalController = 0x1664; // CHandle<CCSPlayerController>
}

public static class C_CSPlayerResource {
    public const nint m_bHostageAlive = 0x540; // bool[12]
    public const nint m_isHostageFollowingSomeone = 0x54C; // bool[12]
    public const nint m_iHostageEntityIDs = 0x558; // CEntityIndex[12]
    public const nint m_bombsiteCenterA = 0x588; // Vector
    public const nint m_bombsiteCenterB = 0x594; // Vector
    public const nint m_hostageRescueX = 0x5A0; // int32_t[4]
    public const nint m_hostageRescueY = 0x5B0; // int32_t[4]
    public const nint m_hostageRescueZ = 0x5C0; // int32_t[4]
    public const nint m_bEndMatchNextMapAllVoted = 0x5D0; // bool
    public const nint m_foundGoalPositions = 0x5D1; // bool
}

public static class C_CSTeam {
    public const nint m_szTeamMatchStat = 0x5F8; // char[512]
    public const nint m_numMapVictories = 0x7F8; // int32_t
    public const nint m_bSurrendered = 0x7FC; // bool
    public const nint m_scoreFirstHalf = 0x800; // int32_t
    public const nint m_scoreSecondHalf = 0x804; // int32_t
    public const nint m_scoreOvertime = 0x808; // int32_t
    public const nint m_szClanTeamname = 0x80C; // char[129]
    public const nint m_iClanID = 0x890; // uint32_t
    public const nint m_szTeamFlagImage = 0x894; // char[8]
    public const nint m_szTeamLogoImage = 0x89C; // char[8]
}

public static class C_CSWeaponBase {
    public const nint m_flFireSequenceStartTime = 0x15D4; // float
    public const nint m_nFireSequenceStartTimeChange = 0x15D8; // int32_t
    public const nint m_nFireSequenceStartTimeAck = 0x15DC; // int32_t
    public const nint m_bPlayerFireEventIsPrimary = 0x15E0; // bool
    public const nint m_seqIdle = 0x15E4; // HSequence
    public const nint m_seqFirePrimary = 0x15E8; // HSequence
    public const nint m_seqFireSecondary = 0x15EC; // HSequence
    public const nint m_thirdPersonFireSequences = 0x15F0; // CUtlVector<HSequence>
    public const nint m_hCurrentThirdPersonSequence = 0x1608; // HSequence
    public const nint m_nSilencerBoneIndex = 0x160C; // int32_t
    public const nint m_thirdPersonSequences = 0x1610; // HSequence[6]
    public const nint m_ClientPreviousWeaponState = 0x1640; // CSWeaponState_t
    public const nint m_iState = 0x1644; // CSWeaponState_t
    public const nint m_flCrosshairDistance = 0x1648; // float
    public const nint m_iAmmoLastCheck = 0x164C; // int32_t
    public const nint m_iAlpha = 0x1650; // int32_t
    public const nint m_iScopeTextureID = 0x1654; // int32_t
    public const nint m_iCrosshairTextureID = 0x1658; // int32_t
    public const nint m_flGunAccuracyPosition = 0x165C; // float
    public const nint m_nViewModelIndex = 0x1660; // uint32_t
    public const nint m_bReloadsWithClips = 0x1664; // bool
    public const nint m_flTimeWeaponIdle = 0x1668; // GameTime_t
    public const nint m_bFireOnEmpty = 0x166C; // bool
    public const nint m_OnPlayerPickup = 0x1670; // CEntityIOOutput
    public const nint m_weaponMode = 0x1698; // CSWeaponMode
    public const nint m_flTurningInaccuracyDelta = 0x169C; // float
    public const nint m_vecTurningInaccuracyEyeDirLast = 0x16A0; // Vector
    public const nint m_flTurningInaccuracy = 0x16AC; // float
    public const nint m_fAccuracyPenalty = 0x16B0; // float
    public const nint m_flLastAccuracyUpdateTime = 0x16B4; // GameTime_t
    public const nint m_fAccuracySmoothedForZoom = 0x16B8; // float
    public const nint m_fScopeZoomEndTime = 0x16BC; // GameTime_t
    public const nint m_iRecoilIndex = 0x16C0; // int32_t
    public const nint m_flRecoilIndex = 0x16C4; // float
    public const nint m_bBurstMode = 0x16C8; // bool
    public const nint m_flPostponeFireReadyTime = 0x16CC; // GameTime_t
    public const nint m_bInReload = 0x16D0; // bool
    public const nint m_bReloadVisuallyComplete = 0x16D1; // bool
    public const nint m_flDroppedAtTime = 0x16D4; // GameTime_t
    public const nint m_bIsHauledBack = 0x16D8; // bool
    public const nint m_bSilencerOn = 0x16D9; // bool
    public const nint m_flTimeSilencerSwitchComplete = 0x16DC; // GameTime_t
    public const nint m_iOriginalTeamNumber = 0x16E0; // int32_t
    public const nint m_flNextAttackRenderTimeOffset = 0x16E4; // float
    public const nint m_bVisualsDataSet = 0x1768; // bool
    public const nint m_bOldFirstPersonSpectatedState = 0x1769; // bool
    public const nint m_hOurPing = 0x176C; // CHandle<C_BaseEntity>
    public const nint m_nOurPingIndex = 0x1770; // CEntityIndex
    public const nint m_vecOurPingPos = 0x1774; // Vector
    public const nint m_bGlowForPing = 0x1780; // bool
    public const nint m_bUIWeapon = 0x1781; // bool
    public const nint m_hPrevOwner = 0x1790; // CHandle<C_CSPlayerPawn>
    public const nint m_nDropTick = 0x1794; // GameTick_t
    public const nint m_donated = 0x17B4; // bool
    public const nint m_fLastShotTime = 0x17B8; // GameTime_t
    public const nint m_bWasOwnedByCT = 0x17BC; // bool
    public const nint m_bWasOwnedByTerrorist = 0x17BD; // bool
    public const nint m_gunHeat = 0x17C0; // float
    public const nint m_smokeAttachments = 0x17C4; // uint32_t
    public const nint m_lastSmokeTime = 0x17C8; // GameTime_t
    public const nint m_flNextClientFireBulletTime = 0x17CC; // float
    public const nint m_flNextClientFireBulletTime_Repredict = 0x17D0; // float
    public const nint m_IronSightController = 0x18B0; // C_IronSightController
    public const nint m_iIronSightMode = 0x1960; // int32_t
    public const nint m_flLastLOSTraceFailureTime = 0x1970; // GameTime_t
    public const nint m_iNumEmptyAttacks = 0x1974; // int32_t
}

public static class C_CSWeaponBaseGun {
    public const nint m_zoomLevel = 0x19F0; // int32_t
    public const nint m_iBurstShotsRemaining = 0x19F4; // int32_t
    public const nint m_iSilencerBodygroup = 0x19F8; // int32_t
    public const nint m_silencedModelIndex = 0x1A08; // int32_t
    public const nint m_inPrecache = 0x1A0C; // bool
    public const nint m_bNeedsBoltAction = 0x1A0D; // bool
}

public static class C_Chicken {
    public const nint m_hHolidayHatAddon = 0x10F0; // CHandle<CBaseAnimGraph>
    public const nint m_jumpedThisFrame = 0x10F4; // bool
    public const nint m_leader = 0x10F8; // CHandle<C_CSPlayerPawnBase>
    public const nint m_AttributeManager = 0x1100; // C_AttributeContainer
    public const nint m_OriginalOwnerXuidLow = 0x15A8; // uint32_t
    public const nint m_OriginalOwnerXuidHigh = 0x15AC; // uint32_t
    public const nint m_bAttributesInitialized = 0x15B0; // bool
    public const nint m_hWaterWakeParticles = 0x15B4; // ParticleIndex_t
}

public static class C_ClientRagdoll {
    public const nint m_bFadeOut = 0xE80; // bool
    public const nint m_bImportant = 0xE81; // bool
    public const nint m_flEffectTime = 0xE84; // GameTime_t
    public const nint m_gibDespawnTime = 0xE88; // GameTime_t
    public const nint m_iCurrentFriction = 0xE8C; // int32_t
    public const nint m_iMinFriction = 0xE90; // int32_t
    public const nint m_iMaxFriction = 0xE94; // int32_t
    public const nint m_iFrictionAnimState = 0xE98; // int32_t
    public const nint m_bReleaseRagdoll = 0xE9C; // bool
    public const nint m_iEyeAttachment = 0xE9D; // AttachmentHandle_t
    public const nint m_bFadingOut = 0xE9E; // bool
    public const nint m_flScaleEnd = 0xEA0; // float[10]
    public const nint m_flScaleTimeStart = 0xEC8; // GameTime_t[10]
    public const nint m_flScaleTimeEnd = 0xEF0; // GameTime_t[10]
}

public static class C_ColorCorrection {
    public const nint m_vecOrigin = 0x540; // Vector
    public const nint m_MinFalloff = 0x54C; // float
    public const nint m_MaxFalloff = 0x550; // float
    public const nint m_flFadeInDuration = 0x554; // float
    public const nint m_flFadeOutDuration = 0x558; // float
    public const nint m_flMaxWeight = 0x55C; // float
    public const nint m_flCurWeight = 0x560; // float
    public const nint m_netlookupFilename = 0x564; // char[512]
    public const nint m_bEnabled = 0x764; // bool
    public const nint m_bMaster = 0x765; // bool
    public const nint m_bClientSide = 0x766; // bool
    public const nint m_bExclusive = 0x767; // bool
    public const nint m_bEnabledOnClient = 0x768; // bool[1]
    public const nint m_flCurWeightOnClient = 0x76C; // float[1]
    public const nint m_bFadingIn = 0x770; // bool[1]
    public const nint m_flFadeStartWeight = 0x774; // float[1]
    public const nint m_flFadeStartTime = 0x778; // float[1]
    public const nint m_flFadeDuration = 0x77C; // float[1]
}

public static class C_ColorCorrectionVolume {
    public const nint m_LastEnterWeight = 0xCC8; // float
    public const nint m_LastEnterTime = 0xCCC; // float
    public const nint m_LastExitWeight = 0xCD0; // float
    public const nint m_LastExitTime = 0xCD4; // float
    public const nint m_bEnabled = 0xCD8; // bool
    public const nint m_MaxWeight = 0xCDC; // float
    public const nint m_FadeDuration = 0xCE0; // float
    public const nint m_Weight = 0xCE4; // float
    public const nint m_lookupFilename = 0xCE8; // char[512]
}

public static class C_CommandContext {
    public const nint needsprocessing = 0x0; // bool
    public const nint command_number = 0xA8; // int32_t
}

public static class C_CsmFovOverride {
    public const nint m_cameraName = 0x540; // CUtlString
    public const nint m_flCsmFovOverrideValue = 0x548; // float
}

public static class C_DecoyProjectile {
    public const nint m_nDecoyShotTick = 0x1100; // int32_t
    public const nint m_nClientLastKnownDecoyShotTick = 0x1104; // int32_t
    public const nint m_flTimeParticleEffectSpawn = 0x1128; // GameTime_t
}

public static class C_DynamicLight {
    public const nint m_Flags = 0xCC0; // uint8_t
    public const nint m_LightStyle = 0xCC1; // uint8_t
    public const nint m_Radius = 0xCC4; // float
    public const nint m_Exponent = 0xCC8; // int32_t
    public const nint m_InnerAngle = 0xCCC; // float
    public const nint m_OuterAngle = 0xCD0; // float
    public const nint m_SpotRadius = 0xCD4; // float
}

public static class C_DynamicProp {
    public const nint m_bUseHitboxesForRenderBox = 0xFD0; // bool
    public const nint m_bUseAnimGraph = 0xFD1; // bool
    public const nint m_pOutputAnimBegun = 0xFD8; // CEntityIOOutput
    public const nint m_pOutputAnimOver = 0x1000; // CEntityIOOutput
    public const nint m_pOutputAnimLoopCycleOver = 0x1028; // CEntityIOOutput
    public const nint m_OnAnimReachedStart = 0x1050; // CEntityIOOutput
    public const nint m_OnAnimReachedEnd = 0x1078; // CEntityIOOutput
    public const nint m_iszDefaultAnim = 0x10A0; // CUtlSymbolLarge
    public const nint m_nDefaultAnimLoopMode = 0x10A8; // AnimLoopMode_t
    public const nint m_bAnimateOnServer = 0x10AC; // bool
    public const nint m_bRandomizeCycle = 0x10AD; // bool
    public const nint m_bStartDisabled = 0x10AE; // bool
    public const nint m_bScriptedMovement = 0x10AF; // bool
    public const nint m_bFiredStartEndOutput = 0x10B0; // bool
    public const nint m_bForceNpcExclude = 0x10B1; // bool
    public const nint m_bCreateNonSolid = 0x10B2; // bool
    public const nint m_bIsOverrideProp = 0x10B3; // bool
    public const nint m_iInitialGlowState = 0x10B4; // int32_t
    public const nint m_nGlowRange = 0x10B8; // int32_t
    public const nint m_nGlowRangeMin = 0x10BC; // int32_t
    public const nint m_glowColor = 0x10C0; // Color
    public const nint m_nGlowTeam = 0x10C4; // int32_t
    public const nint m_iCachedFrameCount = 0x10C8; // int32_t
    public const nint m_vecCachedRenderMins = 0x10CC; // Vector
    public const nint m_vecCachedRenderMaxs = 0x10D8; // Vector
}

public static class C_EconEntity {
    public const nint m_flFlexDelayTime = 0x1028; // float
    public const nint m_flFlexDelayedWeight = 0x1030; // float*
    public const nint m_bAttributesInitialized = 0x1038; // bool
    public const nint m_AttributeManager = 0x1040; // C_AttributeContainer
    public const nint m_OriginalOwnerXuidLow = 0x14E8; // uint32_t
    public const nint m_OriginalOwnerXuidHigh = 0x14EC; // uint32_t
    public const nint m_nFallbackPaintKit = 0x14F0; // int32_t
    public const nint m_nFallbackSeed = 0x14F4; // int32_t
    public const nint m_flFallbackWear = 0x14F8; // float
    public const nint m_nFallbackStatTrak = 0x14FC; // int32_t
    public const nint m_bClientside = 0x1500; // bool
    public const nint m_bParticleSystemsCreated = 0x1501; // bool
    public const nint m_vecAttachedParticles = 0x1508; // CUtlVector<int32_t>
    public const nint m_hViewmodelAttachment = 0x1520; // CHandle<CBaseAnimGraph>
    public const nint m_iOldTeam = 0x1524; // int32_t
    public const nint m_bAttachmentDirty = 0x1528; // bool
    public const nint m_nUnloadedModelIndex = 0x152C; // int32_t
    public const nint m_iNumOwnerValidationRetries = 0x1530; // int32_t
    public const nint m_hOldProvidee = 0x1540; // CHandle<C_BaseEntity>
    public const nint m_vecAttachedModels = 0x1548; // CUtlVector<C_EconEntity::AttachedModelData_t>
}

public static class C_EconEntity_AttachedModelData_t {
    public const nint m_iModelDisplayFlags = 0x0; // int32_t
}

public static class C_EconItemView {
    public const nint m_bInventoryImageRgbaRequested = 0x60; // bool
    public const nint m_bInventoryImageTriedCache = 0x61; // bool
    public const nint m_nInventoryImageRgbaWidth = 0x80; // int32_t
    public const nint m_nInventoryImageRgbaHeight = 0x84; // int32_t
    public const nint m_szCurrentLoadCachedFileName = 0x88; // char[260]
    public const nint m_bRestoreCustomMaterialAfterPrecache = 0x1B8; // bool
    public const nint m_iItemDefinitionIndex = 0x1BA; // uint16_t
    public const nint m_iEntityQuality = 0x1BC; // int32_t
    public const nint m_iEntityLevel = 0x1C0; // uint32_t
    public const nint m_iItemID = 0x1C8; // uint64_t
    public const nint m_iItemIDHigh = 0x1D0; // uint32_t
    public const nint m_iItemIDLow = 0x1D4; // uint32_t
    public const nint m_iAccountID = 0x1D8; // uint32_t
    public const nint m_iInventoryPosition = 0x1DC; // uint32_t
    public const nint m_bInitialized = 0x1E8; // bool
    public const nint m_bIsStoreItem = 0x1E9; // bool
    public const nint m_bIsTradeItem = 0x1EA; // bool
    public const nint m_iEntityQuantity = 0x1EC; // int32_t
    public const nint m_iRarityOverride = 0x1F0; // int32_t
    public const nint m_iQualityOverride = 0x1F4; // int32_t
    public const nint m_unClientFlags = 0x1F8; // uint8_t
    public const nint m_unOverrideStyle = 0x1F9; // uint8_t
    public const nint m_AttributeList = 0x210; // CAttributeList
    public const nint m_NetworkedDynamicAttributes = 0x270; // CAttributeList
    public const nint m_szCustomName = 0x2D0; // char[161]
    public const nint m_szCustomNameOverride = 0x371; // char[161]
    public const nint m_bInitializedTags = 0x440; // bool
}

public static class C_EconWearable {
    public const nint m_nForceSkin = 0x1560; // int32_t
    public const nint m_bAlwaysAllow = 0x1564; // bool
}

public static class C_EntityDissolve {
    public const nint m_flStartTime = 0xCC8; // GameTime_t
    public const nint m_flFadeInStart = 0xCCC; // float
    public const nint m_flFadeInLength = 0xCD0; // float
    public const nint m_flFadeOutModelStart = 0xCD4; // float
    public const nint m_flFadeOutModelLength = 0xCD8; // float
    public const nint m_flFadeOutStart = 0xCDC; // float
    public const nint m_flFadeOutLength = 0xCE0; // float
    public const nint m_flNextSparkTime = 0xCE4; // GameTime_t
    public const nint m_nDissolveType = 0xCE8; // EntityDisolveType_t
    public const nint m_vDissolverOrigin = 0xCEC; // Vector
    public const nint m_nMagnitude = 0xCF8; // uint32_t
    public const nint m_bCoreExplode = 0xCFC; // bool
    public const nint m_bLinkedToServerEnt = 0xCFD; // bool
}

public static class C_EntityFlame {
    public const nint m_hEntAttached = 0x540; // CHandle<C_BaseEntity>
    public const nint m_hOldAttached = 0x568; // CHandle<C_BaseEntity>
    public const nint m_bCheapEffect = 0x56C; // bool
}

public static class C_EnvCombinedLightProbeVolume {
    public const nint m_Color = 0x1598; // Color
    public const nint m_flBrightness = 0x159C; // float
    public const nint m_hCubemapTexture = 0x15A0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_bCustomCubemapTexture = 0x15A8; // bool
    public const nint m_hLightProbeTexture = 0x15B0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_hLightProbeDirectLightIndicesTexture = 0x15B8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_hLightProbeDirectLightScalarsTexture = 0x15C0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_hLightProbeDirectLightShadowsTexture = 0x15C8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_vBoxMins = 0x15D0; // Vector
    public const nint m_vBoxMaxs = 0x15DC; // Vector
    public const nint m_bMoveable = 0x15E8; // bool
    public const nint m_nHandshake = 0x15EC; // int32_t
    public const nint m_nEnvCubeMapArrayIndex = 0x15F0; // int32_t
    public const nint m_nPriority = 0x15F4; // int32_t
    public const nint m_bStartDisabled = 0x15F8; // bool
    public const nint m_flEdgeFadeDist = 0x15FC; // float
    public const nint m_vEdgeFadeDists = 0x1600; // Vector
    public const nint m_nLightProbeSizeX = 0x160C; // int32_t
    public const nint m_nLightProbeSizeY = 0x1610; // int32_t
    public const nint m_nLightProbeSizeZ = 0x1614; // int32_t
    public const nint m_nLightProbeAtlasX = 0x1618; // int32_t
    public const nint m_nLightProbeAtlasY = 0x161C; // int32_t
    public const nint m_nLightProbeAtlasZ = 0x1620; // int32_t
    public const nint m_bEnabled = 0x1639; // bool
}

public static class C_EnvCubemap {
    public const nint m_hCubemapTexture = 0x5C0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_bCustomCubemapTexture = 0x5C8; // bool
    public const nint m_flInfluenceRadius = 0x5CC; // float
    public const nint m_vBoxProjectMins = 0x5D0; // Vector
    public const nint m_vBoxProjectMaxs = 0x5DC; // Vector
    public const nint m_bMoveable = 0x5E8; // bool
    public const nint m_nHandshake = 0x5EC; // int32_t
    public const nint m_nEnvCubeMapArrayIndex = 0x5F0; // int32_t
    public const nint m_nPriority = 0x5F4; // int32_t
    public const nint m_flEdgeFadeDist = 0x5F8; // float
    public const nint m_vEdgeFadeDists = 0x5FC; // Vector
    public const nint m_flDiffuseScale = 0x608; // float
    public const nint m_bStartDisabled = 0x60C; // bool
    public const nint m_bDefaultEnvMap = 0x60D; // bool
    public const nint m_bDefaultSpecEnvMap = 0x60E; // bool
    public const nint m_bIndoorCubeMap = 0x60F; // bool
    public const nint m_bCopyDiffuseFromDefaultCubemap = 0x610; // bool
    public const nint m_bEnabled = 0x620; // bool
}

public static class C_EnvCubemapFog {
    public const nint m_flEndDistance = 0x540; // float
    public const nint m_flStartDistance = 0x544; // float
    public const nint m_flFogFalloffExponent = 0x548; // float
    public const nint m_bHeightFogEnabled = 0x54C; // bool
    public const nint m_flFogHeightWidth = 0x550; // float
    public const nint m_flFogHeightEnd = 0x554; // float
    public const nint m_flFogHeightStart = 0x558; // float
    public const nint m_flFogHeightExponent = 0x55C; // float
    public const nint m_flLODBias = 0x560; // float
    public const nint m_bActive = 0x564; // bool
    public const nint m_bStartDisabled = 0x565; // bool
    public const nint m_flFogMaxOpacity = 0x568; // float
    public const nint m_nCubemapSourceType = 0x56C; // int32_t
    public const nint m_hSkyMaterial = 0x570; // CStrongHandle<InfoForResourceTypeIMaterial2>
    public const nint m_iszSkyEntity = 0x578; // CUtlSymbolLarge
    public const nint m_hFogCubemapTexture = 0x580; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_bHasHeightFogEnd = 0x588; // bool
    public const nint m_bFirstTime = 0x589; // bool
}

public static class C_EnvDecal {
    public const nint m_hDecalMaterial = 0xCC0; // CStrongHandle<InfoForResourceTypeIMaterial2>
    public const nint m_flWidth = 0xCC8; // float
    public const nint m_flHeight = 0xCCC; // float
    public const nint m_flDepth = 0xCD0; // float
    public const nint m_nRenderOrder = 0xCD4; // uint32_t
    public const nint m_bProjectOnWorld = 0xCD8; // bool
    public const nint m_bProjectOnCharacters = 0xCD9; // bool
    public const nint m_bProjectOnWater = 0xCDA; // bool
    public const nint m_flDepthSortBias = 0xCDC; // float
}

public static class C_EnvDetailController {
    public const nint m_flFadeStartDist = 0x540; // float
    public const nint m_flFadeEndDist = 0x544; // float
}

public static class C_EnvLightProbeVolume {
    public const nint m_hLightProbeTexture = 0x1518; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_hLightProbeDirectLightIndicesTexture = 0x1520; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_hLightProbeDirectLightScalarsTexture = 0x1528; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_hLightProbeDirectLightShadowsTexture = 0x1530; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_vBoxMins = 0x1538; // Vector
    public const nint m_vBoxMaxs = 0x1544; // Vector
    public const nint m_bMoveable = 0x1550; // bool
    public const nint m_nHandshake = 0x1554; // int32_t
    public const nint m_nPriority = 0x1558; // int32_t
    public const nint m_bStartDisabled = 0x155C; // bool
    public const nint m_nLightProbeSizeX = 0x1560; // int32_t
    public const nint m_nLightProbeSizeY = 0x1564; // int32_t
    public const nint m_nLightProbeSizeZ = 0x1568; // int32_t
    public const nint m_nLightProbeAtlasX = 0x156C; // int32_t
    public const nint m_nLightProbeAtlasY = 0x1570; // int32_t
    public const nint m_nLightProbeAtlasZ = 0x1574; // int32_t
    public const nint m_bEnabled = 0x1581; // bool
}

public static class C_EnvParticleGlow {
    public const nint m_flAlphaScale = 0x1270; // float
    public const nint m_flRadiusScale = 0x1274; // float
    public const nint m_flSelfIllumScale = 0x1278; // float
    public const nint m_ColorTint = 0x127C; // Color
    public const nint m_hTextureOverride = 0x1280; // CStrongHandle<InfoForResourceTypeCTextureBase>
}

public static class C_EnvScreenOverlay {
    public const nint m_iszOverlayNames = 0x540; // CUtlSymbolLarge[10]
    public const nint m_flOverlayTimes = 0x590; // float[10]
    public const nint m_flStartTime = 0x5B8; // GameTime_t
    public const nint m_iDesiredOverlay = 0x5BC; // int32_t
    public const nint m_bIsActive = 0x5C0; // bool
    public const nint m_bWasActive = 0x5C1; // bool
    public const nint m_iCachedDesiredOverlay = 0x5C4; // int32_t
    public const nint m_iCurrentOverlay = 0x5C8; // int32_t
    public const nint m_flCurrentOverlayTime = 0x5CC; // GameTime_t
}

public static class C_EnvSky {
    public const nint m_hSkyMaterial = 0xCC0; // CStrongHandle<InfoForResourceTypeIMaterial2>
    public const nint m_hSkyMaterialLightingOnly = 0xCC8; // CStrongHandle<InfoForResourceTypeIMaterial2>
    public const nint m_bStartDisabled = 0xCD0; // bool
    public const nint m_vTintColor = 0xCD1; // Color
    public const nint m_vTintColorLightingOnly = 0xCD5; // Color
    public const nint m_flBrightnessScale = 0xCDC; // float
    public const nint m_nFogType = 0xCE0; // int32_t
    public const nint m_flFogMinStart = 0xCE4; // float
    public const nint m_flFogMinEnd = 0xCE8; // float
    public const nint m_flFogMaxStart = 0xCEC; // float
    public const nint m_flFogMaxEnd = 0xCF0; // float
    public const nint m_bEnabled = 0xCF4; // bool
}

public static class C_EnvVolumetricFogController {
    public const nint m_flScattering = 0x540; // float
    public const nint m_flAnisotropy = 0x544; // float
    public const nint m_flFadeSpeed = 0x548; // float
    public const nint m_flDrawDistance = 0x54C; // float
    public const nint m_flFadeInStart = 0x550; // float
    public const nint m_flFadeInEnd = 0x554; // float
    public const nint m_flIndirectStrength = 0x558; // float
    public const nint m_nIndirectTextureDimX = 0x55C; // int32_t
    public const nint m_nIndirectTextureDimY = 0x560; // int32_t
    public const nint m_nIndirectTextureDimZ = 0x564; // int32_t
    public const nint m_vBoxMins = 0x568; // Vector
    public const nint m_vBoxMaxs = 0x574; // Vector
    public const nint m_bActive = 0x580; // bool
    public const nint m_flStartAnisoTime = 0x584; // GameTime_t
    public const nint m_flStartScatterTime = 0x588; // GameTime_t
    public const nint m_flStartDrawDistanceTime = 0x58C; // GameTime_t
    public const nint m_flStartAnisotropy = 0x590; // float
    public const nint m_flStartScattering = 0x594; // float
    public const nint m_flStartDrawDistance = 0x598; // float
    public const nint m_flDefaultAnisotropy = 0x59C; // float
    public const nint m_flDefaultScattering = 0x5A0; // float
    public const nint m_flDefaultDrawDistance = 0x5A4; // float
    public const nint m_bStartDisabled = 0x5A8; // bool
    public const nint m_bEnableIndirect = 0x5A9; // bool
    public const nint m_bIsMaster = 0x5AA; // bool
    public const nint m_hFogIndirectTexture = 0x5B0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_nForceRefreshCount = 0x5B8; // int32_t
    public const nint m_bFirstTime = 0x5BC; // bool
}

public static class C_EnvVolumetricFogVolume {
    public const nint m_bActive = 0x540; // bool
    public const nint m_vBoxMins = 0x544; // Vector
    public const nint m_vBoxMaxs = 0x550; // Vector
    public const nint m_bStartDisabled = 0x55C; // bool
    public const nint m_flStrength = 0x560; // float
    public const nint m_nFalloffShape = 0x564; // int32_t
    public const nint m_flFalloffExponent = 0x568; // float
}

public static class C_EnvWind {
    public const nint m_EnvWindShared = 0x540; // C_EnvWindShared
}

public static class C_EnvWindClientside {
    public const nint m_EnvWindShared = 0x540; // C_EnvWindShared
}

public static class C_EnvWindShared {
    public const nint m_flStartTime = 0x8; // GameTime_t
    public const nint m_iWindSeed = 0xC; // uint32_t
    public const nint m_iMinWind = 0x10; // uint16_t
    public const nint m_iMaxWind = 0x12; // uint16_t
    public const nint m_windRadius = 0x14; // int32_t
    public const nint m_iMinGust = 0x18; // uint16_t
    public const nint m_iMaxGust = 0x1A; // uint16_t
    public const nint m_flMinGustDelay = 0x1C; // float
    public const nint m_flMaxGustDelay = 0x20; // float
    public const nint m_flGustDuration = 0x24; // float
    public const nint m_iGustDirChange = 0x28; // uint16_t
    public const nint m_location = 0x2C; // Vector
    public const nint m_iszGustSound = 0x38; // int32_t
    public const nint m_iWindDir = 0x3C; // int32_t
    public const nint m_flWindSpeed = 0x40; // float
    public const nint m_currentWindVector = 0x44; // Vector
    public const nint m_CurrentSwayVector = 0x50; // Vector
    public const nint m_PrevSwayVector = 0x5C; // Vector
    public const nint m_iInitialWindDir = 0x68; // uint16_t
    public const nint m_flInitialWindSpeed = 0x6C; // float
    public const nint m_flVariationTime = 0x70; // GameTime_t
    public const nint m_flSwayTime = 0x74; // GameTime_t
    public const nint m_flSimTime = 0x78; // GameTime_t
    public const nint m_flSwitchTime = 0x7C; // GameTime_t
    public const nint m_flAveWindSpeed = 0x80; // float
    public const nint m_bGusting = 0x84; // bool
    public const nint m_flWindAngleVariation = 0x88; // float
    public const nint m_flWindSpeedVariation = 0x8C; // float
    public const nint m_iEntIndex = 0x90; // CEntityIndex
}

public static class C_EnvWindShared_WindAveEvent_t {
    public const nint m_flStartWindSpeed = 0x0; // float
    public const nint m_flAveWindSpeed = 0x4; // float
}

public static class C_EnvWindShared_WindVariationEvent_t {
    public const nint m_flWindAngleVariation = 0x0; // float
    public const nint m_flWindSpeedVariation = 0x4; // float
}

public static class C_FireSmoke {
    public const nint m_nFlameModelIndex = 0x550; // int32_t
    public const nint m_nFlameFromAboveModelIndex = 0x554; // int32_t
    public const nint m_flScaleRegister = 0x558; // float
    public const nint m_flScaleStart = 0x55C; // float
    public const nint m_flScaleEnd = 0x560; // float
    public const nint m_flScaleTimeStart = 0x564; // GameTime_t
    public const nint m_flScaleTimeEnd = 0x568; // GameTime_t
    public const nint m_flChildFlameSpread = 0x56C; // float
    public const nint m_flClipPerc = 0x580; // float
    public const nint m_bClipTested = 0x584; // bool
    public const nint m_bFadingOut = 0x585; // bool
    public const nint m_tParticleSpawn = 0x588; // TimedEvent
    public const nint m_pFireOverlay = 0x590; // CFireOverlay*
}

public static class C_FireSprite {
    public const nint m_vecMoveDir = 0xDF0; // Vector
    public const nint m_bFadeFromAbove = 0xDFC; // bool
}

public static class C_Fish {
    public const nint m_pos = 0xE80; // Vector
    public const nint m_vel = 0xE8C; // Vector
    public const nint m_angles = 0xE98; // QAngle
    public const nint m_localLifeState = 0xEA4; // int32_t
    public const nint m_deathDepth = 0xEA8; // float
    public const nint m_deathAngle = 0xEAC; // float
    public const nint m_buoyancy = 0xEB0; // float
    public const nint m_wiggleTimer = 0xEB8; // CountdownTimer
    public const nint m_wigglePhase = 0xED0; // float
    public const nint m_wiggleRate = 0xED4; // float
    public const nint m_actualPos = 0xED8; // Vector
    public const nint m_actualAngles = 0xEE4; // QAngle
    public const nint m_poolOrigin = 0xEF0; // Vector
    public const nint m_waterLevel = 0xEFC; // float
    public const nint m_gotUpdate = 0xF00; // bool
    public const nint m_x = 0xF04; // float
    public const nint m_y = 0xF08; // float
    public const nint m_z = 0xF0C; // float
    public const nint m_angle = 0xF10; // float
    public const nint m_errorHistory = 0xF14; // float[20]
    public const nint m_errorHistoryIndex = 0xF64; // int32_t
    public const nint m_errorHistoryCount = 0xF68; // int32_t
    public const nint m_averageError = 0xF6C; // float
}

public static class C_Fists {
    public const nint m_bPlayingUninterruptableAct = 0x19F0; // bool
    public const nint m_nUninterruptableActivity = 0x19F4; // PlayerAnimEvent_t
}

public static class C_FogController {
    public const nint m_fog = 0x540; // fogparams_t
    public const nint m_bUseAngles = 0x5A8; // bool
    public const nint m_iChangedVariables = 0x5AC; // int32_t
}

public static class C_FootstepControl {
    public const nint m_source = 0xCC8; // CUtlSymbolLarge
    public const nint m_destination = 0xCD0; // CUtlSymbolLarge
}

public static class C_FuncConveyor {
    public const nint m_vecMoveDirEntitySpace = 0xCC8; // Vector
    public const nint m_flTargetSpeed = 0xCD4; // float
    public const nint m_nTransitionStartTick = 0xCD8; // GameTick_t
    public const nint m_nTransitionDurationTicks = 0xCDC; // int32_t
    public const nint m_flTransitionStartSpeed = 0xCE0; // float
    public const nint m_hConveyorModels = 0xCE8; // C_NetworkUtlVectorBase<CHandle<C_BaseEntity>>
    public const nint m_flCurrentConveyorOffset = 0xD00; // float
    public const nint m_flCurrentConveyorSpeed = 0xD04; // float
}

public static class C_FuncElectrifiedVolume {
    public const nint m_nAmbientEffect = 0xCC0; // ParticleIndex_t
    public const nint m_EffectName = 0xCC8; // CUtlSymbolLarge
    public const nint m_bState = 0xCD0; // bool
}

public static class C_FuncLadder {
    public const nint m_vecLadderDir = 0xCC0; // Vector
    public const nint m_Dismounts = 0xCD0; // CUtlVector<CHandle<C_InfoLadderDismount>>
    public const nint m_vecLocalTop = 0xCE8; // Vector
    public const nint m_vecPlayerMountPositionTop = 0xCF4; // Vector
    public const nint m_vecPlayerMountPositionBottom = 0xD00; // Vector
    public const nint m_flAutoRideSpeed = 0xD0C; // float
    public const nint m_bDisabled = 0xD10; // bool
    public const nint m_bFakeLadder = 0xD11; // bool
    public const nint m_bHasSlack = 0xD12; // bool
}

public static class C_FuncMonitor {
    public const nint m_targetCamera = 0xCC0; // CUtlString
    public const nint m_nResolutionEnum = 0xCC8; // int32_t
    public const nint m_bRenderShadows = 0xCCC; // bool
    public const nint m_bUseUniqueColorTarget = 0xCCD; // bool
    public const nint m_brushModelName = 0xCD0; // CUtlString
    public const nint m_hTargetCamera = 0xCD8; // CHandle<C_BaseEntity>
    public const nint m_bEnabled = 0xCDC; // bool
    public const nint m_bDraw3DSkybox = 0xCDD; // bool
}

public static class C_FuncTrackTrain {
    public const nint m_nLongAxis = 0xCC0; // int32_t
    public const nint m_flRadius = 0xCC4; // float
    public const nint m_flLineLength = 0xCC8; // float
}

public static class C_GlobalLight {
    public const nint m_WindClothForceHandle = 0xA00; // uint16_t
}

public static class C_GradientFog {
    public const nint m_hGradientFogTexture = 0x540; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_flFogStartDistance = 0x548; // float
    public const nint m_flFogEndDistance = 0x54C; // float
    public const nint m_bHeightFogEnabled = 0x550; // bool
    public const nint m_flFogStartHeight = 0x554; // float
    public const nint m_flFogEndHeight = 0x558; // float
    public const nint m_flFarZ = 0x55C; // float
    public const nint m_flFogMaxOpacity = 0x560; // float
    public const nint m_flFogFalloffExponent = 0x564; // float
    public const nint m_flFogVerticalExponent = 0x568; // float
    public const nint m_fogColor = 0x56C; // Color
    public const nint m_flFogStrength = 0x570; // float
    public const nint m_flFadeTime = 0x574; // float
    public const nint m_bStartDisabled = 0x578; // bool
    public const nint m_bIsEnabled = 0x579; // bool
    public const nint m_bGradientFogNeedsTextures = 0x57A; // bool
}

public static class C_HandleTest {
    public const nint m_Handle = 0x540; // CHandle<C_BaseEntity>
    public const nint m_bSendHandle = 0x544; // bool
}

public static class C_Hostage {
    public const nint m_entitySpottedState = 0x10A8; // EntitySpottedState_t
    public const nint m_leader = 0x10C0; // CHandle<C_BaseEntity>
    public const nint m_reuseTimer = 0x10C8; // CountdownTimer
    public const nint m_vel = 0x10E0; // Vector
    public const nint m_isRescued = 0x10EC; // bool
    public const nint m_jumpedThisFrame = 0x10ED; // bool
    public const nint m_nHostageState = 0x10F0; // int32_t
    public const nint m_bHandsHaveBeenCut = 0x10F4; // bool
    public const nint m_hHostageGrabber = 0x10F8; // CHandle<C_CSPlayerPawn>
    public const nint m_fLastGrabTime = 0x10FC; // GameTime_t
    public const nint m_vecGrabbedPos = 0x1100; // Vector
    public const nint m_flRescueStartTime = 0x110C; // GameTime_t
    public const nint m_flGrabSuccessTime = 0x1110; // GameTime_t
    public const nint m_flDropStartTime = 0x1114; // GameTime_t
    public const nint m_flDeadOrRescuedTime = 0x1118; // GameTime_t
    public const nint m_blinkTimer = 0x1120; // CountdownTimer
    public const nint m_lookAt = 0x1138; // Vector
    public const nint m_lookAroundTimer = 0x1148; // CountdownTimer
    public const nint m_isInit = 0x1160; // bool
    public const nint m_eyeAttachment = 0x1161; // AttachmentHandle_t
    public const nint m_chestAttachment = 0x1162; // AttachmentHandle_t
    public const nint m_pPredictionOwner = 0x1168; // CBasePlayerController*
    public const nint m_fNewestAlphaThinkTime = 0x1170; // GameTime_t
}

public static class C_Inferno {
    public const nint m_nfxFireDamageEffect = 0xD00; // ParticleIndex_t
    public const nint m_firePositions = 0xD04; // Vector[64]
    public const nint m_fireParentPositions = 0x1004; // Vector[64]
    public const nint m_bFireIsBurning = 0x1304; // bool[64]
    public const nint m_BurnNormal = 0x1344; // Vector[64]
    public const nint m_fireCount = 0x1644; // int32_t
    public const nint m_nInfernoType = 0x1648; // int32_t
    public const nint m_nFireLifetime = 0x164C; // float
    public const nint m_bInPostEffectTime = 0x1650; // bool
    public const nint m_lastFireCount = 0x1654; // int32_t
    public const nint m_nFireEffectTickBegin = 0x1658; // int32_t
    public const nint m_drawableCount = 0x8260; // int32_t
    public const nint m_blosCheck = 0x8264; // bool
    public const nint m_nlosperiod = 0x8268; // int32_t
    public const nint m_maxFireHalfWidth = 0x826C; // float
    public const nint m_maxFireHeight = 0x8270; // float
    public const nint m_minBounds = 0x8274; // Vector
    public const nint m_maxBounds = 0x8280; // Vector
    public const nint m_flLastGrassBurnThink = 0x828C; // float
}

public static class C_InfoVisibilityBox {
    public const nint m_nMode = 0x544; // int32_t
    public const nint m_vBoxSize = 0x548; // Vector
    public const nint m_bEnabled = 0x554; // bool
}

public static class C_IronSightController {
    public const nint m_bIronSightAvailable = 0x10; // bool
    public const nint m_flIronSightAmount = 0x14; // float
    public const nint m_flIronSightAmountGained = 0x18; // float
    public const nint m_flIronSightAmountBiased = 0x1C; // float
    public const nint m_flIronSightAmount_Interpolated = 0x20; // float
    public const nint m_flIronSightAmountGained_Interpolated = 0x24; // float
    public const nint m_flIronSightAmountBiased_Interpolated = 0x28; // float
    public const nint m_flInterpolationLastUpdated = 0x2C; // float
    public const nint m_angDeltaAverage = 0x30; // QAngle[8]
    public const nint m_angViewLast = 0x90; // QAngle
    public const nint m_vecDotCoords = 0x9C; // Vector2D
    public const nint m_flDotBlur = 0xA4; // float
    public const nint m_flSpeedRatio = 0xA8; // float
}

public static class C_Item {
    public const nint m_bShouldGlow = 0x1560; // bool
    public const nint m_pReticleHintTextName = 0x1561; // char[256]
}

public static class C_ItemDogtags {
    public const nint m_OwningPlayer = 0x1668; // CHandle<C_CSPlayerPawn>
    public const nint m_KillingPlayer = 0x166C; // CHandle<C_CSPlayerPawn>
}

public static class C_LightEntity {
    public const nint m_CLightComponent = 0xCC0; // CLightComponent*
}

public static class C_LightGlow {
    public const nint m_nHorizontalSize = 0xCC0; // uint32_t
    public const nint m_nVerticalSize = 0xCC4; // uint32_t
    public const nint m_nMinDist = 0xCC8; // uint32_t
    public const nint m_nMaxDist = 0xCCC; // uint32_t
    public const nint m_nOuterMaxDist = 0xCD0; // uint32_t
    public const nint m_flGlowProxySize = 0xCD4; // float
    public const nint m_flHDRColorScale = 0xCD8; // float
    public const nint m_Glow = 0xCE0; // C_LightGlowOverlay
}

public static class C_LightGlowOverlay {
    public const nint m_vecOrigin = 0xD0; // Vector
    public const nint m_vecDirection = 0xDC; // Vector
    public const nint m_nMinDist = 0xE8; // int32_t
    public const nint m_nMaxDist = 0xEC; // int32_t
    public const nint m_nOuterMaxDist = 0xF0; // int32_t
    public const nint m_bOneSided = 0xF4; // bool
    public const nint m_bModulateByDot = 0xF5; // bool
}

public static class C_LocalTempEntity {
    public const nint flags = 0xE98; // int32_t
    public const nint die = 0xE9C; // GameTime_t
    public const nint m_flFrameMax = 0xEA0; // float
    public const nint x = 0xEA4; // float
    public const nint y = 0xEA8; // float
    public const nint fadeSpeed = 0xEAC; // float
    public const nint bounceFactor = 0xEB0; // float
    public const nint hitSound = 0xEB4; // int32_t
    public const nint priority = 0xEB8; // int32_t
    public const nint tentOffset = 0xEBC; // Vector
    public const nint m_vecTempEntAngVelocity = 0xEC8; // QAngle
    public const nint tempent_renderamt = 0xED4; // int32_t
    public const nint m_vecNormal = 0xED8; // Vector
    public const nint m_flSpriteScale = 0xEE4; // float
    public const nint m_nFlickerFrame = 0xEE8; // int32_t
    public const nint m_flFrameRate = 0xEEC; // float
    public const nint m_flFrame = 0xEF0; // float
    public const nint m_pszImpactEffect = 0xEF8; // char*
    public const nint m_pszParticleEffect = 0xF00; // char*
    public const nint m_bParticleCollision = 0xF08; // bool
    public const nint m_iLastCollisionFrame = 0xF0C; // int32_t
    public const nint m_vLastCollisionOrigin = 0xF10; // Vector
    public const nint m_vecTempEntVelocity = 0xF1C; // Vector
    public const nint m_vecPrevAbsOrigin = 0xF28; // Vector
    public const nint m_vecTempEntAcceleration = 0xF34; // Vector
}

public static class C_MapVetoPickController {
    public const nint m_nDraftType = 0x550; // int32_t
    public const nint m_nTeamWinningCoinToss = 0x554; // int32_t
    public const nint m_nTeamWithFirstChoice = 0x558; // int32_t[64]
    public const nint m_nVoteMapIdsList = 0x658; // int32_t[7]
    public const nint m_nAccountIDs = 0x674; // int32_t[64]
    public const nint m_nMapId0 = 0x774; // int32_t[64]
    public const nint m_nMapId1 = 0x874; // int32_t[64]
    public const nint m_nMapId2 = 0x974; // int32_t[64]
    public const nint m_nMapId3 = 0xA74; // int32_t[64]
    public const nint m_nMapId4 = 0xB74; // int32_t[64]
    public const nint m_nMapId5 = 0xC74; // int32_t[64]
    public const nint m_nStartingSide0 = 0xD74; // int32_t[64]
    public const nint m_nCurrentPhase = 0xE74; // int32_t
    public const nint m_nPhaseStartTick = 0xE78; // int32_t
    public const nint m_nPhaseDurationTicks = 0xE7C; // int32_t
    public const nint m_nPostDataUpdateTick = 0xE80; // int32_t
    public const nint m_bDisabledHud = 0xE84; // bool
}

public static class C_Melee {
    public const nint m_flThrowAt = 0x19F0; // GameTime_t
}

public static class C_MolotovProjectile {
    public const nint m_bIsIncGrenade = 0x1100; // bool
}

public static class C_Multimeter {
    public const nint m_hTargetC4 = 0xE88; // CHandle<C_PlantedC4>
}

public static class C_OmniLight {
    public const nint m_flInnerAngle = 0xF08; // float
    public const nint m_flOuterAngle = 0xF0C; // float
    public const nint m_bShowLight = 0xF10; // bool
}

public static class C_ParticleSystem {
    public const nint m_szSnapshotFileName = 0xCC0; // char[512]
    public const nint m_bActive = 0xEC0; // bool
    public const nint m_bFrozen = 0xEC1; // bool
    public const nint m_flFreezeTransitionDuration = 0xEC4; // float
    public const nint m_nStopType = 0xEC8; // int32_t
    public const nint m_bAnimateDuringGameplayPause = 0xECC; // bool
    public const nint m_iEffectIndex = 0xED0; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    public const nint m_flStartTime = 0xED8; // GameTime_t
    public const nint m_flPreSimTime = 0xEDC; // float
    public const nint m_vServerControlPoints = 0xEE0; // Vector[4]
    public const nint m_iServerControlPointAssignments = 0xF10; // uint8_t[4]
    public const nint m_hControlPointEnts = 0xF14; // CHandle<C_BaseEntity>[64]
    public const nint m_bNoSave = 0x1014; // bool
    public const nint m_bNoFreeze = 0x1015; // bool
    public const nint m_bNoRamp = 0x1016; // bool
    public const nint m_bStartActive = 0x1017; // bool
    public const nint m_iszEffectName = 0x1018; // CUtlSymbolLarge
    public const nint m_iszControlPointNames = 0x1020; // CUtlSymbolLarge[64]
    public const nint m_nDataCP = 0x1220; // int32_t
    public const nint m_vecDataCPValue = 0x1224; // Vector
    public const nint m_nTintCP = 0x1230; // int32_t
    public const nint m_clrTint = 0x1234; // Color
    public const nint m_bOldActive = 0x1258; // bool
    public const nint m_bOldFrozen = 0x1259; // bool
}

public static class C_PathParticleRope {
    public const nint m_bStartActive = 0x540; // bool
    public const nint m_flMaxSimulationTime = 0x544; // float
    public const nint m_iszEffectName = 0x548; // CUtlSymbolLarge
    public const nint m_PathNodes_Name = 0x550; // CUtlVector<CUtlSymbolLarge>
    public const nint m_flParticleSpacing = 0x568; // float
    public const nint m_flSlack = 0x56C; // float
    public const nint m_flRadius = 0x570; // float
    public const nint m_ColorTint = 0x574; // Color
    public const nint m_nEffectState = 0x578; // int32_t
    public const nint m_iEffectIndex = 0x580; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    public const nint m_PathNodes_Position = 0x588; // C_NetworkUtlVectorBase<Vector>
    public const nint m_PathNodes_TangentIn = 0x5A0; // C_NetworkUtlVectorBase<Vector>
    public const nint m_PathNodes_TangentOut = 0x5B8; // C_NetworkUtlVectorBase<Vector>
    public const nint m_PathNodes_Color = 0x5D0; // C_NetworkUtlVectorBase<Vector>
    public const nint m_PathNodes_PinEnabled = 0x5E8; // C_NetworkUtlVectorBase<bool>
    public const nint m_PathNodes_RadiusScale = 0x600; // C_NetworkUtlVectorBase<float>
}

public static class C_PhysMagnet {
    public const nint m_aAttachedObjectsFromServer = 0xE80; // CUtlVector<int32_t>
    public const nint m_aAttachedObjects = 0xE98; // CUtlVector<CHandle<C_BaseEntity>>
}

public static class C_PhysPropClientside {
    public const nint m_flTouchDelta = 0xFD0; // GameTime_t
    public const nint m_fDeathTime = 0xFD4; // GameTime_t
    public const nint m_impactEnergyScale = 0xFD8; // float
    public const nint m_inertiaScale = 0xFDC; // float
    public const nint m_flDmgModBullet = 0xFE0; // float
    public const nint m_flDmgModClub = 0xFE4; // float
    public const nint m_flDmgModExplosive = 0xFE8; // float
    public const nint m_flDmgModFire = 0xFEC; // float
    public const nint m_iszPhysicsDamageTableName = 0xFF0; // CUtlSymbolLarge
    public const nint m_iszBasePropData = 0xFF8; // CUtlSymbolLarge
    public const nint m_iInteractions = 0x1000; // int32_t
    public const nint m_bHasBreakPiecesOrCommands = 0x1004; // bool
    public const nint m_vecDamagePosition = 0x1008; // Vector
    public const nint m_vecDamageDirection = 0x1014; // Vector
    public const nint m_nDamageType = 0x1020; // int32_t
}

public static class C_PhysicsProp {
    public const nint m_bAwake = 0xFD0; // bool
}

public static class C_PickUpModelSlerper {
    public const nint m_hPlayerParent = 0xE80; // CHandle<C_BaseEntity>
    public const nint m_hItem = 0xE84; // CHandle<C_BaseEntity>
    public const nint m_flTimePickedUp = 0xE88; // float
    public const nint m_angOriginal = 0xE8C; // QAngle
    public const nint m_vecPosOriginal = 0xE98; // Vector
    public const nint m_angRandom = 0xEA8; // QAngle
}

public static class C_PlantedC4 {
    public const nint m_bBombTicking = 0xE80; // bool
    public const nint m_nBombSite = 0xE84; // int32_t
    public const nint m_nSourceSoundscapeHash = 0xE88; // int32_t
    public const nint m_entitySpottedState = 0xE90; // EntitySpottedState_t
    public const nint m_flNextGlow = 0xEA8; // GameTime_t
    public const nint m_flNextBeep = 0xEAC; // GameTime_t
    public const nint m_flC4Blow = 0xEB0; // GameTime_t
    public const nint m_bCannotBeDefused = 0xEB4; // bool
    public const nint m_bHasExploded = 0xEB5; // bool
    public const nint m_flTimerLength = 0xEB8; // float
    public const nint m_bBeingDefused = 0xEBC; // bool
    public const nint m_bTriggerWarning = 0xEC0; // float
    public const nint m_bExplodeWarning = 0xEC4; // float
    public const nint m_bC4Activated = 0xEC8; // bool
    public const nint m_bTenSecWarning = 0xEC9; // bool
    public const nint m_flDefuseLength = 0xECC; // float
    public const nint m_flDefuseCountDown = 0xED0; // GameTime_t
    public const nint m_bBombDefused = 0xED4; // bool
    public const nint m_hBombDefuser = 0xED8; // CHandle<C_CSPlayerPawn>
    public const nint m_hControlPanel = 0xEDC; // CHandle<C_BaseEntity>
    public const nint m_hDefuserMultimeter = 0xEE0; // CHandle<C_Multimeter>
    public const nint m_flNextRadarFlashTime = 0xEE4; // GameTime_t
    public const nint m_bRadarFlash = 0xEE8; // bool
    public const nint m_pBombDefuser = 0xEEC; // CHandle<C_CSPlayerPawn>
    public const nint m_fLastDefuseTime = 0xEF0; // GameTime_t
    public const nint m_pPredictionOwner = 0xEF8; // CBasePlayerController*
}

public static class C_PlayerPing {
    public const nint m_hPlayer = 0x570; // CHandle<C_CSPlayerPawn>
    public const nint m_hPingedEntity = 0x574; // CHandle<C_BaseEntity>
    public const nint m_iType = 0x578; // int32_t
    public const nint m_bUrgent = 0x57C; // bool
    public const nint m_szPlaceName = 0x57D; // char[18]
}

public static class C_PlayerSprayDecal {
    public const nint m_nUniqueID = 0xCC0; // int32_t
    public const nint m_unAccountID = 0xCC4; // uint32_t
    public const nint m_unTraceID = 0xCC8; // uint32_t
    public const nint m_rtGcTime = 0xCCC; // uint32_t
    public const nint m_vecEndPos = 0xCD0; // Vector
    public const nint m_vecStart = 0xCDC; // Vector
    public const nint m_vecLeft = 0xCE8; // Vector
    public const nint m_vecNormal = 0xCF4; // Vector
    public const nint m_nPlayer = 0xD00; // int32_t
    public const nint m_nEntity = 0xD04; // int32_t
    public const nint m_nHitbox = 0xD08; // int32_t
    public const nint m_flCreationTime = 0xD0C; // float
    public const nint m_nTintID = 0xD10; // int32_t
    public const nint m_nVersion = 0xD14; // uint8_t
    public const nint m_ubSignature = 0xD15; // uint8_t[128]
    public const nint m_SprayRenderHelper = 0xDA0; // CPlayerSprayDecalRenderHelper
}

public static class C_PlayerVisibility {
    public const nint m_flVisibilityStrength = 0x540; // float
    public const nint m_flFogDistanceMultiplier = 0x544; // float
    public const nint m_flFogMaxDensityMultiplier = 0x548; // float
    public const nint m_flFadeTime = 0x54C; // float
    public const nint m_bStartDisabled = 0x550; // bool
    public const nint m_bIsEnabled = 0x551; // bool
}

public static class C_PointCamera {
    public const nint m_FOV = 0x540; // float
    public const nint m_Resolution = 0x544; // float
    public const nint m_bFogEnable = 0x548; // bool
    public const nint m_FogColor = 0x549; // Color
    public const nint m_flFogStart = 0x550; // float
    public const nint m_flFogEnd = 0x554; // float
    public const nint m_flFogMaxDensity = 0x558; // float
    public const nint m_bActive = 0x55C; // bool
    public const nint m_bUseScreenAspectRatio = 0x55D; // bool
    public const nint m_flAspectRatio = 0x560; // float
    public const nint m_bNoSky = 0x564; // bool
    public const nint m_fBrightness = 0x568; // float
    public const nint m_flZFar = 0x56C; // float
    public const nint m_flZNear = 0x570; // float
    public const nint m_bCanHLTVUse = 0x574; // bool
    public const nint m_bDofEnabled = 0x575; // bool
    public const nint m_flDofNearBlurry = 0x578; // float
    public const nint m_flDofNearCrisp = 0x57C; // float
    public const nint m_flDofFarCrisp = 0x580; // float
    public const nint m_flDofFarBlurry = 0x584; // float
    public const nint m_flDofTiltToGround = 0x588; // float
    public const nint m_TargetFOV = 0x58C; // float
    public const nint m_DegreesPerSecond = 0x590; // float
    public const nint m_bIsOn = 0x594; // bool
    public const nint m_pNext = 0x598; // C_PointCamera*
}

public static class C_PointCameraVFOV {
    public const nint m_flVerticalFOV = 0x5A0; // float
}

public static class C_PointClientUIDialog {
    public const nint m_hActivator = 0xCF0; // CHandle<C_BaseEntity>
    public const nint m_bStartEnabled = 0xCF4; // bool
}

public static class C_PointClientUIHUD {
    public const nint m_bCheckCSSClasses = 0xCF8; // bool
    public const nint m_bIgnoreInput = 0xE80; // bool
    public const nint m_flWidth = 0xE84; // float
    public const nint m_flHeight = 0xE88; // float
    public const nint m_flDPI = 0xE8C; // float
    public const nint m_flInteractDistance = 0xE90; // float
    public const nint m_flDepthOffset = 0xE94; // float
    public const nint m_unOwnerContext = 0xE98; // uint32_t
    public const nint m_unHorizontalAlign = 0xE9C; // uint32_t
    public const nint m_unVerticalAlign = 0xEA0; // uint32_t
    public const nint m_unOrientation = 0xEA4; // uint32_t
    public const nint m_bAllowInteractionFromAllSceneWorlds = 0xEA8; // bool
    public const nint m_vecCSSClasses = 0xEB0; // C_NetworkUtlVectorBase<CUtlSymbolLarge>
}

public static class C_PointClientUIWorldPanel {
    public const nint m_bForceRecreateNextUpdate = 0xCF8; // bool
    public const nint m_bMoveViewToPlayerNextThink = 0xCF9; // bool
    public const nint m_bCheckCSSClasses = 0xCFA; // bool
    public const nint m_anchorDeltaTransform = 0xD00; // CTransform
    public const nint m_pOffScreenIndicator = 0xEA0; // CPointOffScreenIndicatorUi*
    public const nint m_bIgnoreInput = 0xEC8; // bool
    public const nint m_bLit = 0xEC9; // bool
    public const nint m_bFollowPlayerAcrossTeleport = 0xECA; // bool
    public const nint m_flWidth = 0xECC; // float
    public const nint m_flHeight = 0xED0; // float
    public const nint m_flDPI = 0xED4; // float
    public const nint m_flInteractDistance = 0xED8; // float
    public const nint m_flDepthOffset = 0xEDC; // float
    public const nint m_unOwnerContext = 0xEE0; // uint32_t
    public const nint m_unHorizontalAlign = 0xEE4; // uint32_t
    public const nint m_unVerticalAlign = 0xEE8; // uint32_t
    public const nint m_unOrientation = 0xEEC; // uint32_t
    public const nint m_bAllowInteractionFromAllSceneWorlds = 0xEF0; // bool
    public const nint m_vecCSSClasses = 0xEF8; // C_NetworkUtlVectorBase<CUtlSymbolLarge>
    public const nint m_bOpaque = 0xF10; // bool
    public const nint m_bNoDepth = 0xF11; // bool
    public const nint m_bRenderBackface = 0xF12; // bool
    public const nint m_bUseOffScreenIndicator = 0xF13; // bool
    public const nint m_bExcludeFromSaveGames = 0xF14; // bool
    public const nint m_bGrabbable = 0xF15; // bool
    public const nint m_bOnlyRenderToTexture = 0xF16; // bool
    public const nint m_bDisableMipGen = 0xF17; // bool
    public const nint m_nExplicitImageLayout = 0xF18; // int32_t
}

public static class C_PointClientUIWorldTextPanel {
    public const nint m_messageText = 0xF20; // char[512]
}

public static class C_PointCommentaryNode {
    public const nint m_bActive = 0xE88; // bool
    public const nint m_bWasActive = 0xE89; // bool
    public const nint m_flEndTime = 0xE8C; // GameTime_t
    public const nint m_flStartTime = 0xE90; // GameTime_t
    public const nint m_flStartTimeInCommentary = 0xE94; // float
    public const nint m_iszCommentaryFile = 0xE98; // CUtlSymbolLarge
    public const nint m_iszTitle = 0xEA0; // CUtlSymbolLarge
    public const nint m_iszSpeakers = 0xEA8; // CUtlSymbolLarge
    public const nint m_iNodeNumber = 0xEB0; // int32_t
    public const nint m_iNodeNumberMax = 0xEB4; // int32_t
    public const nint m_bListenedTo = 0xEB8; // bool
    public const nint m_hViewPosition = 0xEC8; // CHandle<C_BaseEntity>
    public const nint m_bRestartAfterRestore = 0xECC; // bool
}

public static class C_PointValueRemapper {
    public const nint m_bDisabled = 0x540; // bool
    public const nint m_bDisabledOld = 0x541; // bool
    public const nint m_bUpdateOnClient = 0x542; // bool
    public const nint m_nInputType = 0x544; // ValueRemapperInputType_t
    public const nint m_hRemapLineStart = 0x548; // CHandle<C_BaseEntity>
    public const nint m_hRemapLineEnd = 0x54C; // CHandle<C_BaseEntity>
    public const nint m_flMaximumChangePerSecond = 0x550; // float
    public const nint m_flDisengageDistance = 0x554; // float
    public const nint m_flEngageDistance = 0x558; // float
    public const nint m_bRequiresUseKey = 0x55C; // bool
    public const nint m_nOutputType = 0x560; // ValueRemapperOutputType_t
    public const nint m_hOutputEntities = 0x568; // C_NetworkUtlVectorBase<CHandle<C_BaseEntity>>
    public const nint m_nHapticsType = 0x580; // ValueRemapperHapticsType_t
    public const nint m_nMomentumType = 0x584; // ValueRemapperMomentumType_t
    public const nint m_flMomentumModifier = 0x588; // float
    public const nint m_flSnapValue = 0x58C; // float
    public const nint m_flCurrentMomentum = 0x590; // float
    public const nint m_nRatchetType = 0x594; // ValueRemapperRatchetType_t
    public const nint m_flRatchetOffset = 0x598; // float
    public const nint m_flInputOffset = 0x59C; // float
    public const nint m_bEngaged = 0x5A0; // bool
    public const nint m_bFirstUpdate = 0x5A1; // bool
    public const nint m_flPreviousValue = 0x5A4; // float
    public const nint m_flPreviousUpdateTickTime = 0x5A8; // GameTime_t
    public const nint m_vecPreviousTestPoint = 0x5AC; // Vector
}

public static class C_PointWorldText {
    public const nint m_bForceRecreateNextUpdate = 0xCC8; // bool
    public const nint m_messageText = 0xCD8; // char[512]
    public const nint m_FontName = 0xED8; // char[64]
    public const nint m_bEnabled = 0xF18; // bool
    public const nint m_bFullbright = 0xF19; // bool
    public const nint m_flWorldUnitsPerPx = 0xF1C; // float
    public const nint m_flFontSize = 0xF20; // float
    public const nint m_flDepthOffset = 0xF24; // float
    public const nint m_Color = 0xF28; // Color
    public const nint m_nJustifyHorizontal = 0xF2C; // PointWorldTextJustifyHorizontal_t
    public const nint m_nJustifyVertical = 0xF30; // PointWorldTextJustifyVertical_t
    public const nint m_nReorientMode = 0xF34; // PointWorldTextReorientMode_t
}

public static class C_PostProcessingVolume {
    public const nint m_hPostSettings = 0xCD8; // CStrongHandle<InfoForResourceTypeCPostProcessingResource>
    public const nint m_flFadeDuration = 0xCE0; // float
    public const nint m_flMinLogExposure = 0xCE4; // float
    public const nint m_flMaxLogExposure = 0xCE8; // float
    public const nint m_flMinExposure = 0xCEC; // float
    public const nint m_flMaxExposure = 0xCF0; // float
    public const nint m_flExposureCompensation = 0xCF4; // float
    public const nint m_flExposureFadeSpeedUp = 0xCF8; // float
    public const nint m_flExposureFadeSpeedDown = 0xCFC; // float
    public const nint m_flTonemapEVSmoothingRange = 0xD00; // float
    public const nint m_bMaster = 0xD04; // bool
    public const nint m_bExposureControl = 0xD05; // bool
    public const nint m_flRate = 0xD08; // float
    public const nint m_flTonemapPercentTarget = 0xD0C; // float
    public const nint m_flTonemapPercentBrightPixels = 0xD10; // float
    public const nint m_flTonemapMinAvgLum = 0xD14; // float
}

public static class C_Precipitation {
    public const nint m_flDensity = 0xCC8; // float
    public const nint m_flParticleInnerDist = 0xCD8; // float
    public const nint m_pParticleDef = 0xCE0; // char*
    public const nint m_tParticlePrecipTraceTimer = 0xD08; // TimedEvent[1]
    public const nint m_bActiveParticlePrecipEmitter = 0xD10; // bool[1]
    public const nint m_bParticlePrecipInitialized = 0xD11; // bool
    public const nint m_bHasSimulatedSinceLastSceneObjectUpdate = 0xD12; // bool
    public const nint m_nAvailableSheetSequencesMaxIndex = 0xD14; // int32_t
}

public static class C_PredictedViewModel {
    public const nint m_LagAnglesHistory = 0xEE8; // QAngle
    public const nint m_vPredictedOffset = 0xF00; // Vector
}

public static class C_RagdollManager {
    public const nint m_iCurrentMaxRagdollCount = 0x540; // int8_t
}

public static class C_RagdollProp {
    public const nint m_ragPos = 0xE88; // C_NetworkUtlVectorBase<Vector>
    public const nint m_ragAngles = 0xEA0; // C_NetworkUtlVectorBase<QAngle>
    public const nint m_flBlendWeight = 0xEB8; // float
    public const nint m_hRagdollSource = 0xEBC; // CHandle<C_BaseEntity>
    public const nint m_iEyeAttachment = 0xEC0; // AttachmentHandle_t
    public const nint m_flBlendWeightCurrent = 0xEC4; // float
    public const nint m_parentPhysicsBoneIndices = 0xEC8; // CUtlVector<int32_t>
    public const nint m_worldSpaceBoneComputationOrder = 0xEE0; // CUtlVector<int32_t>
}

public static class C_RagdollPropAttached {
    public const nint m_boneIndexAttached = 0xEF8; // uint32_t
    public const nint m_ragdollAttachedObjectIndex = 0xEFC; // uint32_t
    public const nint m_attachmentPointBoneSpace = 0xF00; // Vector
    public const nint m_attachmentPointRagdollSpace = 0xF0C; // Vector
    public const nint m_vecOffset = 0xF18; // Vector
    public const nint m_parentTime = 0xF24; // float
    public const nint m_bHasParent = 0xF28; // bool
}

public static class C_RectLight {
    public const nint m_bShowLight = 0xF08; // bool
}

public static class C_RetakeGameRules {
    public const nint m_nMatchSeed = 0xF8; // int32_t
    public const nint m_bBlockersPresent = 0xFC; // bool
    public const nint m_bRoundInProgress = 0xFD; // bool
    public const nint m_iFirstSecondHalfRound = 0x100; // int32_t
    public const nint m_iBombSite = 0x104; // int32_t
}

public static class C_RopeKeyframe {
    public const nint m_LinksTouchingSomething = 0xCC8; // CBitVec<10>
    public const nint m_nLinksTouchingSomething = 0xCCC; // int32_t
    public const nint m_bApplyWind = 0xCD0; // bool
    public const nint m_fPrevLockedPoints = 0xCD4; // int32_t
    public const nint m_iForcePointMoveCounter = 0xCD8; // int32_t
    public const nint m_bPrevEndPointPos = 0xCDC; // bool[2]
    public const nint m_vPrevEndPointPos = 0xCE0; // Vector[2]
    public const nint m_flCurScroll = 0xCF8; // float
    public const nint m_flScrollSpeed = 0xCFC; // float
    public const nint m_RopeFlags = 0xD00; // uint16_t
    public const nint m_iRopeMaterialModelIndex = 0xD08; // CStrongHandle<InfoForResourceTypeIMaterial2>
    public const nint m_LightValues = 0xF80; // Vector[10]
    public const nint m_nSegments = 0xFF8; // uint8_t
    public const nint m_hStartPoint = 0xFFC; // CHandle<C_BaseEntity>
    public const nint m_hEndPoint = 0x1000; // CHandle<C_BaseEntity>
    public const nint m_iStartAttachment = 0x1004; // AttachmentHandle_t
    public const nint m_iEndAttachment = 0x1005; // AttachmentHandle_t
    public const nint m_Subdiv = 0x1006; // uint8_t
    public const nint m_RopeLength = 0x1008; // int16_t
    public const nint m_Slack = 0x100A; // int16_t
    public const nint m_TextureScale = 0x100C; // float
    public const nint m_fLockedPoints = 0x1010; // uint8_t
    public const nint m_nChangeCount = 0x1011; // uint8_t
    public const nint m_Width = 0x1014; // float
    public const nint m_PhysicsDelegate = 0x1018; // C_RopeKeyframe::CPhysicsDelegate
    public const nint m_hMaterial = 0x1028; // CStrongHandle<InfoForResourceTypeIMaterial2>
    public const nint m_TextureHeight = 0x1030; // int32_t
    public const nint m_vecImpulse = 0x1034; // Vector
    public const nint m_vecPreviousImpulse = 0x1040; // Vector
    public const nint m_flCurrentGustTimer = 0x104C; // float
    public const nint m_flCurrentGustLifetime = 0x1050; // float
    public const nint m_flTimeToNextGust = 0x1054; // float
    public const nint m_vWindDir = 0x1058; // Vector
    public const nint m_vColorMod = 0x1064; // Vector
    public const nint m_vCachedEndPointAttachmentPos = 0x1070; // Vector[2]
    public const nint m_vCachedEndPointAttachmentAngle = 0x1088; // QAngle[2]
    public const nint m_bConstrainBetweenEndpoints = 0x10A0; // bool
    public const nint m_bEndPointAttachmentPositionsDirty = 0x0; // bitfield:1
    public const nint m_bEndPointAttachmentAnglesDirty = 0x0; // bitfield:1
    public const nint m_bNewDataThisFrame = 0x0; // bitfield:1
    public const nint m_bPhysicsInitted = 0x0; // bitfield:1
}

public static class C_RopeKeyframe_CPhysicsDelegate {
    public const nint m_pKeyframe = 0x8; // C_RopeKeyframe*
}

public static class C_SceneEntity {
    public const nint m_bIsPlayingBack = 0x548; // bool
    public const nint m_bPaused = 0x549; // bool
    public const nint m_bMultiplayer = 0x54A; // bool
    public const nint m_bAutogenerated = 0x54B; // bool
    public const nint m_flForceClientTime = 0x54C; // float
    public const nint m_nSceneStringIndex = 0x550; // uint16_t
    public const nint m_bClientOnly = 0x552; // bool
    public const nint m_hOwner = 0x554; // CHandle<C_BaseFlex>
    public const nint m_hActorList = 0x558; // C_NetworkUtlVectorBase<CHandle<C_BaseFlex>>
    public const nint m_bWasPlaying = 0x570; // bool
    public const nint m_QueuedEvents = 0x580; // CUtlVector<C_SceneEntity::QueuedEvents_t>
    public const nint m_flCurrentTime = 0x598; // float
}

public static class C_SceneEntity_QueuedEvents_t {
    public const nint starttime = 0x0; // float
}

public static class C_ShatterGlassShardPhysics {
    public const nint m_ShardDesc = 0xFE0; // shard_model_desc_t
}

public static class C_SkyCamera {
    public const nint m_skyboxData = 0x540; // sky3dparams_t
    public const nint m_skyboxSlotToken = 0x5D0; // CUtlStringToken
    public const nint m_bUseAngles = 0x5D4; // bool
    public const nint m_pNext = 0x5D8; // C_SkyCamera*
}

public static class C_SmokeGrenadeProjectile {
    public const nint m_nSmokeEffectTickBegin = 0x1108; // int32_t
    public const nint m_bDidSmokeEffect = 0x110C; // bool
    public const nint m_nRandomSeed = 0x1110; // int32_t
    public const nint m_vSmokeColor = 0x1114; // Vector
    public const nint m_vSmokeDetonationPos = 0x1120; // Vector
    public const nint m_VoxelFrameData = 0x1130; // CUtlVector<uint8_t>
    public const nint m_bSmokeVolumeDataReceived = 0x1148; // bool
    public const nint m_bSmokeEffectSpawned = 0x1149; // bool
}

public static class C_SoundAreaEntityBase {
    public const nint m_bDisabled = 0x540; // bool
    public const nint m_bWasEnabled = 0x548; // bool
    public const nint m_iszSoundAreaType = 0x550; // CUtlSymbolLarge
    public const nint m_vPos = 0x558; // Vector
}

public static class C_SoundAreaEntityOrientedBox {
    public const nint m_vMin = 0x568; // Vector
    public const nint m_vMax = 0x574; // Vector
}

public static class C_SoundAreaEntitySphere {
    public const nint m_flRadius = 0x568; // float
}

public static class C_SoundOpvarSetPointBase {
    public const nint m_iszStackName = 0x540; // CUtlSymbolLarge
    public const nint m_iszOperatorName = 0x548; // CUtlSymbolLarge
    public const nint m_iszOpvarName = 0x550; // CUtlSymbolLarge
    public const nint m_iOpvarIndex = 0x558; // int32_t
    public const nint m_bUseAutoCompare = 0x55C; // bool
}

public static class C_SpotlightEnd {
    public const nint m_flLightScale = 0xCC0; // float
    public const nint m_Radius = 0xCC4; // float
}

public static class C_Sprite {
    public const nint m_hSpriteMaterial = 0xCD8; // CStrongHandle<InfoForResourceTypeIMaterial2>
    public const nint m_hAttachedToEntity = 0xCE0; // CHandle<C_BaseEntity>
    public const nint m_nAttachment = 0xCE4; // AttachmentHandle_t
    public const nint m_flSpriteFramerate = 0xCE8; // float
    public const nint m_flFrame = 0xCEC; // float
    public const nint m_flDieTime = 0xCF0; // GameTime_t
    public const nint m_nBrightness = 0xD00; // uint32_t
    public const nint m_flBrightnessDuration = 0xD04; // float
    public const nint m_flSpriteScale = 0xD08; // float
    public const nint m_flScaleDuration = 0xD0C; // float
    public const nint m_bWorldSpaceScale = 0xD10; // bool
    public const nint m_flGlowProxySize = 0xD14; // float
    public const nint m_flHDRColorScale = 0xD18; // float
    public const nint m_flLastTime = 0xD1C; // GameTime_t
    public const nint m_flMaxFrame = 0xD20; // float
    public const nint m_flStartScale = 0xD24; // float
    public const nint m_flDestScale = 0xD28; // float
    public const nint m_flScaleTimeStart = 0xD2C; // GameTime_t
    public const nint m_nStartBrightness = 0xD30; // int32_t
    public const nint m_nDestBrightness = 0xD34; // int32_t
    public const nint m_flBrightnessTimeStart = 0xD38; // GameTime_t
    public const nint m_hOldSpriteMaterial = 0xD40; // CWeakHandle<InfoForResourceTypeIMaterial2>
    public const nint m_nSpriteWidth = 0xDE8; // int32_t
    public const nint m_nSpriteHeight = 0xDEC; // int32_t
}

public static class C_Sun {
    public const nint m_fxSSSunFlareEffectIndex = 0xCC0; // ParticleIndex_t
    public const nint m_fxSunFlareEffectIndex = 0xCC4; // ParticleIndex_t
    public const nint m_fdistNormalize = 0xCC8; // float
    public const nint m_vSunPos = 0xCCC; // Vector
    public const nint m_vDirection = 0xCD8; // Vector
    public const nint m_iszEffectName = 0xCE8; // CUtlSymbolLarge
    public const nint m_iszSSEffectName = 0xCF0; // CUtlSymbolLarge
    public const nint m_clrOverlay = 0xCF8; // Color
    public const nint m_bOn = 0xCFC; // bool
    public const nint m_bmaxColor = 0xCFD; // bool
    public const nint m_flSize = 0xD00; // float
    public const nint m_flHazeScale = 0xD04; // float
    public const nint m_flRotation = 0xD08; // float
    public const nint m_flHDRColorScale = 0xD0C; // float
    public const nint m_flAlphaHaze = 0xD10; // float
    public const nint m_flAlphaScale = 0xD14; // float
    public const nint m_flAlphaHdr = 0xD18; // float
    public const nint m_flFarZScale = 0xD1C; // float
}

public static class C_SunGlowOverlay {
    public const nint m_bModulateByDot = 0xD0; // bool
}

public static class C_Team {
    public const nint m_aPlayerControllers = 0x540; // C_NetworkUtlVectorBase<CHandle<CBasePlayerController>>
    public const nint m_aPlayers = 0x558; // C_NetworkUtlVectorBase<CHandle<C_BasePlayerPawn>>
    public const nint m_iScore = 0x570; // int32_t
    public const nint m_szTeamname = 0x574; // char[129]
}

public static class C_TeamRoundTimer {
    public const nint m_bTimerPaused = 0x540; // bool
    public const nint m_flTimeRemaining = 0x544; // float
    public const nint m_flTimerEndTime = 0x548; // GameTime_t
    public const nint m_bIsDisabled = 0x54C; // bool
    public const nint m_bShowInHUD = 0x54D; // bool
    public const nint m_nTimerLength = 0x550; // int32_t
    public const nint m_nTimerInitialLength = 0x554; // int32_t
    public const nint m_nTimerMaxLength = 0x558; // int32_t
    public const nint m_bAutoCountdown = 0x55C; // bool
    public const nint m_nSetupTimeLength = 0x560; // int32_t
    public const nint m_nState = 0x564; // int32_t
    public const nint m_bStartPaused = 0x568; // bool
    public const nint m_bInCaptureWatchState = 0x569; // bool
    public const nint m_flTotalTime = 0x56C; // float
    public const nint m_bStopWatchTimer = 0x570; // bool
    public const nint m_bFireFinished = 0x571; // bool
    public const nint m_bFire5MinRemain = 0x572; // bool
    public const nint m_bFire4MinRemain = 0x573; // bool
    public const nint m_bFire3MinRemain = 0x574; // bool
    public const nint m_bFire2MinRemain = 0x575; // bool
    public const nint m_bFire1MinRemain = 0x576; // bool
    public const nint m_bFire30SecRemain = 0x577; // bool
    public const nint m_bFire10SecRemain = 0x578; // bool
    public const nint m_bFire5SecRemain = 0x579; // bool
    public const nint m_bFire4SecRemain = 0x57A; // bool
    public const nint m_bFire3SecRemain = 0x57B; // bool
    public const nint m_bFire2SecRemain = 0x57C; // bool
    public const nint m_bFire1SecRemain = 0x57D; // bool
    public const nint m_nOldTimerLength = 0x580; // int32_t
    public const nint m_nOldTimerState = 0x584; // int32_t
}

public static class C_TextureBasedAnimatable {
    public const nint m_bLoop = 0xCC0; // bool
    public const nint m_flFPS = 0xCC4; // float
    public const nint m_hPositionKeys = 0xCC8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_hRotationKeys = 0xCD0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_vAnimationBoundsMin = 0xCD8; // Vector
    public const nint m_vAnimationBoundsMax = 0xCE4; // Vector
    public const nint m_flStartTime = 0xCF0; // float
    public const nint m_flStartFrame = 0xCF4; // float
}

public static class C_TonemapController2 {
    public const nint m_flAutoExposureMin = 0x540; // float
    public const nint m_flAutoExposureMax = 0x544; // float
    public const nint m_flTonemapPercentTarget = 0x548; // float
    public const nint m_flTonemapPercentBrightPixels = 0x54C; // float
    public const nint m_flTonemapMinAvgLum = 0x550; // float
    public const nint m_flExposureAdaptationSpeedUp = 0x554; // float
    public const nint m_flExposureAdaptationSpeedDown = 0x558; // float
    public const nint m_flTonemapEVSmoothingRange = 0x55C; // float
}

public static class C_TriggerBuoyancy {
    public const nint m_BuoyancyHelper = 0xCC8; // CBuoyancyHelper
    public const nint m_flFluidDensity = 0xCE8; // float
}

public static class C_ViewmodelWeapon {
    public const nint m_worldModel = 0xE80; // char*
}

public static class C_VoteController {
    public const nint m_iActiveIssueIndex = 0x550; // int32_t
    public const nint m_iOnlyTeamToVote = 0x554; // int32_t
    public const nint m_nVoteOptionCount = 0x558; // int32_t[5]
    public const nint m_nPotentialVotes = 0x56C; // int32_t
    public const nint m_bVotesDirty = 0x570; // bool
    public const nint m_bTypeDirty = 0x571; // bool
    public const nint m_bIsYesNoVote = 0x572; // bool
}

public static class C_WeaponBaseItem {
    public const nint m_SequenceCompleteTimer = 0x19F0; // CountdownTimer
    public const nint m_bRedraw = 0x1A08; // bool
}

public static class C_WeaponShield {
    public const nint m_flDisplayHealth = 0x1A10; // float
}

public static class C_WeaponTaser {
    public const nint m_fFireTime = 0x1A10; // GameTime_t
}

public static class C_fogplayerparams_t {
    public const nint m_hCtrl = 0x8; // CHandle<C_FogController>
    public const nint m_flTransitionTime = 0xC; // float
    public const nint m_OldColor = 0x10; // Color
    public const nint m_flOldStart = 0x14; // float
    public const nint m_flOldEnd = 0x18; // float
    public const nint m_flOldMaxDensity = 0x1C; // float
    public const nint m_flOldHDRColorScale = 0x20; // float
    public const nint m_flOldFarZ = 0x24; // float
    public const nint m_NewColor = 0x28; // Color
    public const nint m_flNewStart = 0x2C; // float
    public const nint m_flNewEnd = 0x30; // float
    public const nint m_flNewMaxDensity = 0x34; // float
    public const nint m_flNewHDRColorScale = 0x38; // float
    public const nint m_flNewFarZ = 0x3C; // float
}

public static class CompMatMutatorCondition_t {
    public const nint m_nMutatorCondition = 0x0; // CompMatPropertyMutatorConditionType_t
    public const nint m_strMutatorConditionContainerName = 0x8; // CUtlString
    public const nint m_strMutatorConditionContainerVarName = 0x10; // CUtlString
    public const nint m_strMutatorConditionContainerVarValue = 0x18; // CUtlString
    public const nint m_bPassWhenTrue = 0x20; // bool
}

public static class CompMatPropertyMutator_t {
    public const nint m_bEnabled = 0x0; // bool
    public const nint m_nMutatorCommandType = 0x4; // CompMatPropertyMutatorType_t
    public const nint m_strInitWith_Container = 0x8; // CUtlString
    public const nint m_strCopyProperty_InputContainerSrc = 0x10; // CUtlString
    public const nint m_strCopyProperty_InputContainerProperty = 0x18; // CUtlString
    public const nint m_strCopyProperty_TargetProperty = 0x20; // CUtlString
    public const nint m_strRandomRollInputVars_SeedInputVar = 0x28; // CUtlString
    public const nint m_vecRandomRollInputVars_InputVarsToRoll = 0x30; // CUtlVector<CUtlString>
    public const nint m_strCopyMatchingKeys_InputContainerSrc = 0x48; // CUtlString
    public const nint m_strCopyKeysWithSuffix_InputContainerSrc = 0x50; // CUtlString
    public const nint m_strCopyKeysWithSuffix_FindSuffix = 0x58; // CUtlString
    public const nint m_strCopyKeysWithSuffix_ReplaceSuffix = 0x60; // CUtlString
    public const nint m_nSetValue_Value = 0x68; // CompositeMaterialInputLooseVariable_t
    public const nint m_strGenerateTexture_TargetParam = 0x2D8; // CUtlString
    public const nint m_strGenerateTexture_InitialContainer = 0x2E0; // CUtlString
    public const nint m_nResolution = 0x2E8; // int32_t
    public const nint m_bIsScratchTarget = 0x2EC; // bool
    public const nint m_bSplatDebugInfo = 0x2ED; // bool
    public const nint m_bCaptureInRenderDoc = 0x2EE; // bool
    public const nint m_vecTexGenInstructions = 0x2F0; // CUtlVector<CompMatPropertyMutator_t>
    public const nint m_vecConditionalMutators = 0x308; // CUtlVector<CompMatPropertyMutator_t>
    public const nint m_strPopInputQueue_Container = 0x320; // CUtlString
    public const nint m_strDrawText_InputContainerSrc = 0x328; // CUtlString
    public const nint m_strDrawText_InputContainerProperty = 0x330; // CUtlString
    public const nint m_vecDrawText_Position = 0x338; // Vector2D
    public const nint m_colDrawText_Color = 0x340; // Color
    public const nint m_strDrawText_Font = 0x348; // CUtlString
    public const nint m_vecConditions = 0x350; // CUtlVector<CompMatMutatorCondition_t>
}

public static class CompositeMaterialAssemblyProcedure_t {
    public const nint m_vecCompMatIncludes = 0x0; // CUtlVector<CResourceName>
    public const nint m_vecMatchFilters = 0x18; // CUtlVector<CompositeMaterialMatchFilter_t>
    public const nint m_vecCompositeInputContainers = 0x30; // CUtlVector<CompositeMaterialInputContainer_t>
    public const nint m_vecPropertyMutators = 0x48; // CUtlVector<CompMatPropertyMutator_t>
}

public static class CompositeMaterialEditorPoint_t {
    public const nint m_ModelName = 0x0; // CResourceName
    public const nint m_nSequenceIndex = 0xE0; // int32_t
    public const nint m_flCycle = 0xE4; // float
    public const nint m_KVModelStateChoices = 0xE8; // KeyValues3
    public const nint m_bEnableChildModel = 0xF8; // bool
    public const nint m_ChildModelName = 0x100; // CResourceName
    public const nint m_vecCompositeMaterialAssemblyProcedures = 0x1E0; // CUtlVector<CompositeMaterialAssemblyProcedure_t>
    public const nint m_vecCompositeMaterials = 0x1F8; // CUtlVector<CompositeMaterial_t>
}

public static class CompositeMaterialInputContainer_t {
    public const nint m_bEnabled = 0x0; // bool
    public const nint m_nCompositeMaterialInputContainerSourceType = 0x4; // CompositeMaterialInputContainerSourceType_t
    public const nint m_strSpecificContainerMaterial = 0x8; // CResourceName
    public const nint m_strAttrName = 0xE8; // CUtlString
    public const nint m_strAlias = 0xF0; // CUtlString
    public const nint m_vecLooseVariables = 0xF8; // CUtlVector<CompositeMaterialInputLooseVariable_t>
    public const nint m_strAttrNameForVar = 0x110; // CUtlString
    public const nint m_bExposeExternally = 0x118; // bool
}

public static class CompositeMaterialInputLooseVariable_t {
    public const nint m_strName = 0x0; // CUtlString
    public const nint m_bExposeExternally = 0x8; // bool
    public const nint m_strExposedFriendlyName = 0x10; // CUtlString
    public const nint m_strExposedFriendlyGroupName = 0x18; // CUtlString
    public const nint m_bExposedVariableIsFixedRange = 0x20; // bool
    public const nint m_strExposedVisibleWhenTrue = 0x28; // CUtlString
    public const nint m_strExposedHiddenWhenTrue = 0x30; // CUtlString
    public const nint m_nVariableType = 0x38; // CompositeMaterialInputLooseVariableType_t
    public const nint m_bValueBoolean = 0x3C; // bool
    public const nint m_nValueIntX = 0x40; // int32_t
    public const nint m_nValueIntY = 0x44; // int32_t
    public const nint m_nValueIntZ = 0x48; // int32_t
    public const nint m_nValueIntW = 0x4C; // int32_t
    public const nint m_bHasFloatBounds = 0x50; // bool
    public const nint m_flValueFloatX = 0x54; // float
    public const nint m_flValueFloatX_Min = 0x58; // float
    public const nint m_flValueFloatX_Max = 0x5C; // float
    public const nint m_flValueFloatY = 0x60; // float
    public const nint m_flValueFloatY_Min = 0x64; // float
    public const nint m_flValueFloatY_Max = 0x68; // float
    public const nint m_flValueFloatZ = 0x6C; // float
    public const nint m_flValueFloatZ_Min = 0x70; // float
    public const nint m_flValueFloatZ_Max = 0x74; // float
    public const nint m_flValueFloatW = 0x78; // float
    public const nint m_flValueFloatW_Min = 0x7C; // float
    public const nint m_flValueFloatW_Max = 0x80; // float
    public const nint m_cValueColor4 = 0x84; // Color
    public const nint m_nValueSystemVar = 0x88; // CompositeMaterialVarSystemVar_t
    public const nint m_strResourceMaterial = 0x90; // CResourceName
    public const nint m_strTextureContentAssetPath = 0x170; // CUtlString
    public const nint m_strTextureRuntimeResourcePath = 0x178; // CResourceName
    public const nint m_strTextureCompilationVtexTemplate = 0x258; // CUtlString
    public const nint m_nTextureType = 0x260; // CompositeMaterialInputTextureType_t
    public const nint m_strString = 0x268; // CUtlString
}

public static class CompositeMaterialMatchFilter_t {
    public const nint m_nCompositeMaterialMatchFilterType = 0x0; // CompositeMaterialMatchFilterType_t
    public const nint m_strMatchFilter = 0x8; // CUtlString
    public const nint m_strMatchValue = 0x10; // CUtlString
    public const nint m_bPassWhenTrue = 0x18; // bool
}

public static class CompositeMaterial_t {
    public const nint m_TargetKVs = 0x8; // KeyValues3
    public const nint m_PreGenerationKVs = 0x18; // KeyValues3
    public const nint m_FinalKVs = 0x28; // KeyValues3
    public const nint m_vecGeneratedTextures = 0x40; // CUtlVector<GeneratedTextureHandle_t>
}

public static class CountdownTimer {
    public const nint m_duration = 0x8; // float
    public const nint m_timestamp = 0xC; // GameTime_t
    public const nint m_timescale = 0x10; // float
    public const nint m_nWorldGroupId = 0x14; // WorldGroupId_t
}

public static class EngineCountdownTimer {
    public const nint m_duration = 0x8; // float
    public const nint m_timestamp = 0xC; // float
    public const nint m_timescale = 0x10; // float
}

public static class EntityRenderAttribute_t {
    public const nint m_ID = 0x30; // CUtlStringToken
    public const nint m_Values = 0x34; // Vector4D
}

public static class EntitySpottedState_t {
    public const nint m_bSpotted = 0x8; // bool
    public const nint m_bSpottedByMask = 0xC; // uint32_t[2]
}

public static class GeneratedTextureHandle_t {
    public const nint m_strBitmapName = 0x0; // CUtlString
}

public static class IntervalTimer {
    public const nint m_timestamp = 0x8; // GameTime_t
    public const nint m_nWorldGroupId = 0xC; // WorldGroupId_t
}

public static class PhysicsRagdollPose_t {
    public const nint __m_pChainEntity = 0x8; // CNetworkVarChainer
    public const nint m_Transforms = 0x30; // C_NetworkUtlVectorBase<CTransform>
    public const nint m_hOwner = 0x48; // CHandle<C_BaseEntity>
    public const nint m_bDirty = 0x68; // bool
}

public static class SellbackPurchaseEntry_t {
    public const nint m_unDefIdx = 0x30; // uint16_t
    public const nint m_nCost = 0x34; // int32_t
    public const nint m_nPrevArmor = 0x38; // int32_t
    public const nint m_bPrevHelmet = 0x3C; // bool
    public const nint m_hItem = 0x40; // CEntityHandle
}

public static class ServerAuthoritativeWeaponSlot_t {
    public const nint unClass = 0x28; // uint16_t
    public const nint unSlot = 0x2A; // uint16_t
    public const nint unItemDefIdx = 0x2C; // uint16_t
}

public static class TimedEvent {
    public const nint m_TimeBetweenEvents = 0x0; // float
    public const nint m_fNextEvent = 0x4; // float
}

public static class VPhysicsCollisionAttribute_t {
    public const nint m_nInteractsAs = 0x8; // uint64_t
    public const nint m_nInteractsWith = 0x10; // uint64_t
    public const nint m_nInteractsExclude = 0x18; // uint64_t
    public const nint m_nEntityId = 0x20; // uint32_t
    public const nint m_nOwnerId = 0x24; // uint32_t
    public const nint m_nHierarchyId = 0x28; // uint16_t
    public const nint m_nCollisionGroup = 0x2A; // uint8_t
    public const nint m_nCollisionFunctionMask = 0x2B; // uint8_t
}

public static class ViewAngleServerChange_t {
    public const nint nType = 0x30; // FixAngleSet_t
    public const nint qAngle = 0x34; // QAngle
    public const nint nIndex = 0x40; // uint32_t
}

public static class WeaponPurchaseCount_t {
    public const nint m_nItemDefIndex = 0x30; // uint16_t
    public const nint m_nCount = 0x32; // uint16_t
}

public static class WeaponPurchaseTracker_t {
    public const nint m_weaponPurchases = 0x8; // C_UtlVectorEmbeddedNetworkVar<WeaponPurchaseCount_t>
}

public static class audioparams_t {
    public const nint localSound = 0x8; // Vector[8]
    public const nint soundscapeIndex = 0x68; // int32_t
    public const nint localBits = 0x6C; // uint8_t
    public const nint soundscapeEntityListIndex = 0x70; // int32_t
    public const nint soundEventHash = 0x74; // uint32_t
}

public static class fogparams_t {
    public const nint dirPrimary = 0x8; // Vector
    public const nint colorPrimary = 0x14; // Color
    public const nint colorSecondary = 0x18; // Color
    public const nint colorPrimaryLerpTo = 0x1C; // Color
    public const nint colorSecondaryLerpTo = 0x20; // Color
    public const nint start = 0x24; // float
    public const nint end = 0x28; // float
    public const nint farz = 0x2C; // float
    public const nint maxdensity = 0x30; // float
    public const nint exponent = 0x34; // float
    public const nint HDRColorScale = 0x38; // float
    public const nint skyboxFogFactor = 0x3C; // float
    public const nint skyboxFogFactorLerpTo = 0x40; // float
    public const nint startLerpTo = 0x44; // float
    public const nint endLerpTo = 0x48; // float
    public const nint maxdensityLerpTo = 0x4C; // float
    public const nint lerptime = 0x50; // GameTime_t
    public const nint duration = 0x54; // float
    public const nint blendtobackground = 0x58; // float
    public const nint scattering = 0x5C; // float
    public const nint locallightscale = 0x60; // float
    public const nint enable = 0x64; // bool
    public const nint blend = 0x65; // bool
    public const nint m_bNoReflectionFog = 0x66; // bool
    public const nint m_bPadding = 0x67; // bool
}

public static class shard_model_desc_t {
    public const nint m_nModelID = 0x8; // int32_t
    public const nint m_hMaterial = 0x10; // CStrongHandle<InfoForResourceTypeIMaterial2>
    public const nint m_solid = 0x18; // ShardSolid_t
    public const nint m_ShatterPanelMode = 0x19; // ShatterPanelMode
    public const nint m_vecPanelSize = 0x1C; // Vector2D
    public const nint m_vecStressPositionA = 0x24; // Vector2D
    public const nint m_vecStressPositionB = 0x2C; // Vector2D
    public const nint m_vecPanelVertices = 0x38; // C_NetworkUtlVectorBase<Vector2D>
    public const nint m_flGlassHalfThickness = 0x50; // float
    public const nint m_bHasParent = 0x54; // bool
    public const nint m_bParentFrozen = 0x55; // bool
    public const nint m_SurfacePropStringToken = 0x58; // CUtlStringToken
}

public static class sky3dparams_t {
    public const nint scale = 0x8; // int16_t
    public const nint origin = 0xC; // Vector
    public const nint bClip3DSkyBoxNearToWorldFar = 0x18; // bool
    public const nint flClip3DSkyBoxNearToWorldFarOffset = 0x1C; // float
    public const nint fog = 0x20; // fogparams_t
    public const nint m_nWorldGroupID = 0x88; // WorldGroupId_t
}
```

`SDK/client.dll.hpp`:

```hpp
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:27.047223400 UTC
 */

#pragma once

#include <cstddef>

namespace ActiveModelConfig_t {
    constexpr std::ptrdiff_t m_Handle = 0x28; // ModelConfigHandle_t
    constexpr std::ptrdiff_t m_Name = 0x30; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_AssociatedEntities = 0x38; // C_NetworkUtlVectorBase<CHandle<C_BaseModelEntity>>
    constexpr std::ptrdiff_t m_AssociatedEntityNames = 0x50; // C_NetworkUtlVectorBase<CUtlSymbolLarge>
}

namespace CAnimGraphNetworkedVariables {
    constexpr std::ptrdiff_t m_PredNetBoolVariables = 0x8; // C_NetworkUtlVectorBase<uint32_t>
    constexpr std::ptrdiff_t m_PredNetByteVariables = 0x20; // C_NetworkUtlVectorBase<uint8_t>
    constexpr std::ptrdiff_t m_PredNetUInt16Variables = 0x38; // C_NetworkUtlVectorBase<uint16_t>
    constexpr std::ptrdiff_t m_PredNetIntVariables = 0x50; // C_NetworkUtlVectorBase<int32_t>
    constexpr std::ptrdiff_t m_PredNetUInt32Variables = 0x68; // C_NetworkUtlVectorBase<uint32_t>
    constexpr std::ptrdiff_t m_PredNetUInt64Variables = 0x80; // C_NetworkUtlVectorBase<uint64_t>
    constexpr std::ptrdiff_t m_PredNetFloatVariables = 0x98; // C_NetworkUtlVectorBase<float>
    constexpr std::ptrdiff_t m_PredNetVectorVariables = 0xB0; // C_NetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_PredNetQuaternionVariables = 0xC8; // C_NetworkUtlVectorBase<Quaternion>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetBoolVariables = 0xE0; // C_NetworkUtlVectorBase<uint32_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetByteVariables = 0xF8; // C_NetworkUtlVectorBase<uint8_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetUInt16Variables = 0x110; // C_NetworkUtlVectorBase<uint16_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetIntVariables = 0x128; // C_NetworkUtlVectorBase<int32_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetUInt32Variables = 0x140; // C_NetworkUtlVectorBase<uint32_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetUInt64Variables = 0x158; // C_NetworkUtlVectorBase<uint64_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetFloatVariables = 0x170; // C_NetworkUtlVectorBase<float>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetVectorVariables = 0x188; // C_NetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetQuaternionVariables = 0x1A0; // C_NetworkUtlVectorBase<Quaternion>
    constexpr std::ptrdiff_t m_nBoolVariablesCount = 0x1B8; // int32_t
    constexpr std::ptrdiff_t m_nOwnerOnlyBoolVariablesCount = 0x1BC; // int32_t
    constexpr std::ptrdiff_t m_nRandomSeedOffset = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_flLastTeleportTime = 0x1C4; // float
}

namespace CAttributeList {
    constexpr std::ptrdiff_t m_Attributes = 0x8; // C_UtlVectorEmbeddedNetworkVar<CEconItemAttribute>
    constexpr std::ptrdiff_t m_pManager = 0x58; // CAttributeManager*
}

namespace CAttributeManager {
    constexpr std::ptrdiff_t m_Providers = 0x8; // CUtlVector<CHandle<C_BaseEntity>>
    constexpr std::ptrdiff_t m_iReapplyProvisionParity = 0x20; // int32_t
    constexpr std::ptrdiff_t m_hOuter = 0x24; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_bPreventLoopback = 0x28; // bool
    constexpr std::ptrdiff_t m_ProviderType = 0x2C; // attributeprovidertypes_t
    constexpr std::ptrdiff_t m_CachedResults = 0x30; // CUtlVector<CAttributeManager::cached_attribute_float_t>
}

namespace CAttributeManager_cached_attribute_float_t {
    constexpr std::ptrdiff_t flIn = 0x0; // float
    constexpr std::ptrdiff_t iAttribHook = 0x8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t flOut = 0x10; // float
}

namespace CBaseAnimGraph {
    constexpr std::ptrdiff_t m_bInitiallyPopulateInterpHistory = 0xCC0; // bool
    constexpr std::ptrdiff_t m_bShouldAnimateDuringGameplayPause = 0xCC1; // bool
    constexpr std::ptrdiff_t m_bSuppressAnimEventSounds = 0xCC3; // bool
    constexpr std::ptrdiff_t m_bAnimGraphUpdateEnabled = 0xCD0; // bool
    constexpr std::ptrdiff_t m_flMaxSlopeDistance = 0xCD4; // float
    constexpr std::ptrdiff_t m_vLastSlopeCheckPos = 0xCD8; // Vector
    constexpr std::ptrdiff_t m_vecForce = 0xCE8; // Vector
    constexpr std::ptrdiff_t m_nForceBone = 0xCF4; // int32_t
    constexpr std::ptrdiff_t m_pClientsideRagdoll = 0xCF8; // CBaseAnimGraph*
    constexpr std::ptrdiff_t m_bBuiltRagdoll = 0xD00; // bool
    constexpr std::ptrdiff_t m_pRagdollPose = 0xD18; // PhysicsRagdollPose_t*
    constexpr std::ptrdiff_t m_bClientRagdoll = 0xD20; // bool
    constexpr std::ptrdiff_t m_bHasAnimatedMaterialAttributes = 0xD30; // bool
}

namespace CBaseAnimGraphController {
    constexpr std::ptrdiff_t m_baseLayer = 0x18; // CNetworkedSequenceOperation
    constexpr std::ptrdiff_t m_animGraphNetworkedVars = 0x40; // CAnimGraphNetworkedVariables
    constexpr std::ptrdiff_t m_bSequenceFinished = 0x1320; // bool
    constexpr std::ptrdiff_t m_flLastEventCycle = 0x1324; // float
    constexpr std::ptrdiff_t m_flLastEventAnimTime = 0x1328; // float
    constexpr std::ptrdiff_t m_flPlaybackRate = 0x132C; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_flPrevAnimTime = 0x1334; // float
    constexpr std::ptrdiff_t m_bClientSideAnimation = 0x1338; // bool
    constexpr std::ptrdiff_t m_bNetworkedAnimationInputsChanged = 0x1339; // bool
    constexpr std::ptrdiff_t m_nPrevNewSequenceParity = 0x133A; // uint8_t
    constexpr std::ptrdiff_t m_nPrevResetEventsParity = 0x133B; // uint8_t
    constexpr std::ptrdiff_t m_nNewSequenceParity = 0x133C; // int32_t
    constexpr std::ptrdiff_t m_nResetEventsParity = 0x1340; // int32_t
    constexpr std::ptrdiff_t m_nAnimLoopMode = 0x1344; // AnimLoopMode_t
    constexpr std::ptrdiff_t m_hAnimationUpdate = 0x13E4; // AnimationUpdateListHandle_t
    constexpr std::ptrdiff_t m_hLastAnimEventSequence = 0x13E8; // HSequence
}

namespace CBasePlayerController {
    constexpr std::ptrdiff_t m_nFinalPredictedTick = 0x548; // int32_t
    constexpr std::ptrdiff_t m_CommandContext = 0x550; // C_CommandContext
    constexpr std::ptrdiff_t m_nInButtonsWhichAreToggles = 0x600; // uint64_t
    constexpr std::ptrdiff_t m_nTickBase = 0x608; // uint32_t
    constexpr std::ptrdiff_t m_hPawn = 0x60C; // CHandle<C_BasePlayerPawn>
    constexpr std::ptrdiff_t m_hPredictedPawn = 0x610; // CHandle<C_BasePlayerPawn>
    constexpr std::ptrdiff_t m_nSplitScreenSlot = 0x614; // CSplitScreenSlot
    constexpr std::ptrdiff_t m_hSplitOwner = 0x618; // CHandle<CBasePlayerController>
    constexpr std::ptrdiff_t m_hSplitScreenPlayers = 0x620; // CUtlVector<CHandle<CBasePlayerController>>
    constexpr std::ptrdiff_t m_bIsHLTV = 0x638; // bool
    constexpr std::ptrdiff_t m_iConnected = 0x63C; // PlayerConnectedState
    constexpr std::ptrdiff_t m_iszPlayerName = 0x640; // char[128]
    constexpr std::ptrdiff_t m_steamID = 0x6C8; // uint64_t
    constexpr std::ptrdiff_t m_bIsLocalPlayerController = 0x6D0; // bool
    constexpr std::ptrdiff_t m_iDesiredFOV = 0x6D4; // uint32_t
}

namespace CBasePlayerVData {
    constexpr std::ptrdiff_t m_sModelName = 0x28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_flHeadDamageMultiplier = 0x108; // CSkillFloat
    constexpr std::ptrdiff_t m_flChestDamageMultiplier = 0x118; // CSkillFloat
    constexpr std::ptrdiff_t m_flStomachDamageMultiplier = 0x128; // CSkillFloat
    constexpr std::ptrdiff_t m_flArmDamageMultiplier = 0x138; // CSkillFloat
    constexpr std::ptrdiff_t m_flLegDamageMultiplier = 0x148; // CSkillFloat
    constexpr std::ptrdiff_t m_flHoldBreathTime = 0x158; // float
    constexpr std::ptrdiff_t m_flDrowningDamageInterval = 0x15C; // float
    constexpr std::ptrdiff_t m_nDrowningDamageInitial = 0x160; // int32_t
    constexpr std::ptrdiff_t m_nDrowningDamageMax = 0x164; // int32_t
    constexpr std::ptrdiff_t m_nWaterSpeed = 0x168; // int32_t
    constexpr std::ptrdiff_t m_flUseRange = 0x16C; // float
    constexpr std::ptrdiff_t m_flUseAngleTolerance = 0x170; // float
    constexpr std::ptrdiff_t m_flCrouchTime = 0x174; // float
}

namespace CBasePlayerWeaponVData {
    constexpr std::ptrdiff_t m_szWorldModel = 0x28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_bBuiltRightHanded = 0x108; // bool
    constexpr std::ptrdiff_t m_bAllowFlipping = 0x109; // bool
    constexpr std::ptrdiff_t m_bIsFullAuto = 0x10A; // bool
    constexpr std::ptrdiff_t m_nNumBullets = 0x10C; // int32_t
    constexpr std::ptrdiff_t m_sMuzzleAttachment = 0x110; // CUtlString
    constexpr std::ptrdiff_t m_szMuzzleFlashParticle = 0x118; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_iFlags = 0x1F8; // ItemFlagTypes_t
    constexpr std::ptrdiff_t m_nPrimaryAmmoType = 0x1F9; // AmmoIndex_t
    constexpr std::ptrdiff_t m_nSecondaryAmmoType = 0x1FA; // AmmoIndex_t
    constexpr std::ptrdiff_t m_iMaxClip1 = 0x1FC; // int32_t
    constexpr std::ptrdiff_t m_iMaxClip2 = 0x200; // int32_t
    constexpr std::ptrdiff_t m_iDefaultClip1 = 0x204; // int32_t
    constexpr std::ptrdiff_t m_iDefaultClip2 = 0x208; // int32_t
    constexpr std::ptrdiff_t m_iWeight = 0x20C; // int32_t
    constexpr std::ptrdiff_t m_bAutoSwitchTo = 0x210; // bool
    constexpr std::ptrdiff_t m_bAutoSwitchFrom = 0x211; // bool
    constexpr std::ptrdiff_t m_iRumbleEffect = 0x214; // RumbleEffect_t
    constexpr std::ptrdiff_t m_aShootSounds = 0x218; // CUtlMap<WeaponSound_t,CSoundEventName>
    constexpr std::ptrdiff_t m_iSlot = 0x238; // int32_t
    constexpr std::ptrdiff_t m_iPosition = 0x23C; // int32_t
}

namespace CBaseProp {
    constexpr std::ptrdiff_t m_bModelOverrodeBlockLOS = 0xE80; // bool
    constexpr std::ptrdiff_t m_iShapeType = 0xE84; // int32_t
    constexpr std::ptrdiff_t m_bConformToCollisionBounds = 0xE88; // bool
    constexpr std::ptrdiff_t m_mPreferredCatchTransform = 0xE8C; // matrix3x4_t
}

namespace CBodyComponent {
    constexpr std::ptrdiff_t m_pSceneNode = 0x8; // CGameSceneNode*
    constexpr std::ptrdiff_t __m_pChainEntity = 0x20; // CNetworkVarChainer
}

namespace CBodyComponentBaseAnimGraph {
    constexpr std::ptrdiff_t m_animationController = 0x480; // CBaseAnimGraphController
    constexpr std::ptrdiff_t __m_pChainEntity = 0x18C0; // CNetworkVarChainer
}

namespace CBodyComponentBaseModelEntity {
    constexpr std::ptrdiff_t __m_pChainEntity = 0x480; // CNetworkVarChainer
}

namespace CBodyComponentPoint {
    constexpr std::ptrdiff_t m_sceneNode = 0x50; // CGameSceneNode
    constexpr std::ptrdiff_t __m_pChainEntity = 0x1A0; // CNetworkVarChainer
}

namespace CBodyComponentSkeletonInstance {
    constexpr std::ptrdiff_t m_skeletonInstance = 0x50; // CSkeletonInstance
    constexpr std::ptrdiff_t __m_pChainEntity = 0x450; // CNetworkVarChainer
}

namespace CBombTarget {
    constexpr std::ptrdiff_t m_bBombPlantedHere = 0xCC8; // bool
}

namespace CBuoyancyHelper {
    constexpr std::ptrdiff_t m_flFluidDensity = 0x18; // float
}

namespace CCSGameModeRules {
    constexpr std::ptrdiff_t __m_pChainEntity = 0x8; // CNetworkVarChainer
}

namespace CCSGameModeRules_Deathmatch {
    constexpr std::ptrdiff_t m_bFirstThink = 0x30; // bool
    constexpr std::ptrdiff_t m_bFirstThinkAfterConnected = 0x31; // bool
    constexpr std::ptrdiff_t m_flDMBonusStartTime = 0x34; // GameTime_t
    constexpr std::ptrdiff_t m_flDMBonusTimeLength = 0x38; // float
    constexpr std::ptrdiff_t m_nDMBonusWeaponLoadoutSlot = 0x3C; // int16_t
}

namespace CCSObserver_ObserverServices {
    constexpr std::ptrdiff_t m_hLastObserverTarget = 0x58; // CEntityHandle
    constexpr std::ptrdiff_t m_vecObserverInterpolateOffset = 0x5C; // Vector
    constexpr std::ptrdiff_t m_vecObserverInterpStartPos = 0x68; // Vector
    constexpr std::ptrdiff_t m_flObsInterp_PathLength = 0x74; // float
    constexpr std::ptrdiff_t m_qObsInterp_OrientationStart = 0x80; // Quaternion
    constexpr std::ptrdiff_t m_qObsInterp_OrientationTravelDir = 0x90; // Quaternion
    constexpr std::ptrdiff_t m_obsInterpState = 0xA0; // ObserverInterpState_t
    constexpr std::ptrdiff_t m_bObserverInterpolationNeedsDeferredSetup = 0xA4; // bool
}

namespace CCSPlayerBase_CameraServices {
    constexpr std::ptrdiff_t m_iFOV = 0x210; // uint32_t
    constexpr std::ptrdiff_t m_iFOVStart = 0x214; // uint32_t
    constexpr std::ptrdiff_t m_flFOVTime = 0x218; // GameTime_t
    constexpr std::ptrdiff_t m_flFOVRate = 0x21C; // float
    constexpr std::ptrdiff_t m_hZoomOwner = 0x220; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_flLastShotFOV = 0x224; // float
}

namespace CCSPlayerController {
    constexpr std::ptrdiff_t m_pInGameMoneyServices = 0x700; // CCSPlayerController_InGameMoneyServices*
    constexpr std::ptrdiff_t m_pInventoryServices = 0x708; // CCSPlayerController_InventoryServices*
    constexpr std::ptrdiff_t m_pActionTrackingServices = 0x710; // CCSPlayerController_ActionTrackingServices*
    constexpr std::ptrdiff_t m_pDamageServices = 0x718; // CCSPlayerController_DamageServices*
    constexpr std::ptrdiff_t m_iPing = 0x720; // uint32_t
    constexpr std::ptrdiff_t m_bHasCommunicationAbuseMute = 0x724; // bool
    constexpr std::ptrdiff_t m_szCrosshairCodes = 0x728; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iPendingTeamNum = 0x730; // uint8_t
    constexpr std::ptrdiff_t m_flForceTeamTime = 0x734; // GameTime_t
    constexpr std::ptrdiff_t m_iCompTeammateColor = 0x738; // int32_t
    constexpr std::ptrdiff_t m_bEverPlayedOnTeam = 0x73C; // bool
    constexpr std::ptrdiff_t m_flPreviousForceJoinTeamTime = 0x740; // GameTime_t
    constexpr std::ptrdiff_t m_szClan = 0x748; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_sSanitizedPlayerName = 0x750; // CUtlString
    constexpr std::ptrdiff_t m_iCoachingTeam = 0x758; // int32_t
    constexpr std::ptrdiff_t m_nPlayerDominated = 0x760; // uint64_t
    constexpr std::ptrdiff_t m_nPlayerDominatingMe = 0x768; // uint64_t
    constexpr std::ptrdiff_t m_iCompetitiveRanking = 0x770; // int32_t
    constexpr std::ptrdiff_t m_iCompetitiveWins = 0x774; // int32_t
    constexpr std::ptrdiff_t m_iCompetitiveRankType = 0x778; // int8_t
    constexpr std::ptrdiff_t m_iCompetitiveRankingPredicted_Win = 0x77C; // int32_t
    constexpr std::ptrdiff_t m_iCompetitiveRankingPredicted_Loss = 0x780; // int32_t
    constexpr std::ptrdiff_t m_iCompetitiveRankingPredicted_Tie = 0x784; // int32_t
    constexpr std::ptrdiff_t m_nEndMatchNextMapVote = 0x788; // int32_t
    constexpr std::ptrdiff_t m_unActiveQuestId = 0x78C; // uint16_t
    constexpr std::ptrdiff_t m_nQuestProgressReason = 0x790; // QuestProgress::Reason
    constexpr std::ptrdiff_t m_unPlayerTvControlFlags = 0x794; // uint32_t
    constexpr std::ptrdiff_t m_iDraftIndex = 0x7C0; // int32_t
    constexpr std::ptrdiff_t m_msQueuedModeDisconnectionTimestamp = 0x7C4; // uint32_t
    constexpr std::ptrdiff_t m_uiAbandonRecordedReason = 0x7C8; // uint32_t
    constexpr std::ptrdiff_t m_bCannotBeKicked = 0x7CC; // bool
    constexpr std::ptrdiff_t m_bEverFullyConnected = 0x7CD; // bool
    constexpr std::ptrdiff_t m_bAbandonAllowsSurrender = 0x7CE; // bool
    constexpr std::ptrdiff_t m_bAbandonOffersInstantSurrender = 0x7CF; // bool
    constexpr std::ptrdiff_t m_bDisconnection1MinWarningPrinted = 0x7D0; // bool
    constexpr std::ptrdiff_t m_bScoreReported = 0x7D1; // bool
    constexpr std::ptrdiff_t m_nDisconnectionTick = 0x7D4; // int32_t
    constexpr std::ptrdiff_t m_bControllingBot = 0x7E0; // bool
    constexpr std::ptrdiff_t m_bHasControlledBotThisRound = 0x7E1; // bool
    constexpr std::ptrdiff_t m_bHasBeenControlledByPlayerThisRound = 0x7E2; // bool
    constexpr std::ptrdiff_t m_nBotsControlledThisRound = 0x7E4; // int32_t
    constexpr std::ptrdiff_t m_bCanControlObservedBot = 0x7E8; // bool
    constexpr std::ptrdiff_t m_hPlayerPawn = 0x7EC; // CHandle<C_CSPlayerPawn>
    constexpr std::ptrdiff_t m_hObserverPawn = 0x7F0; // CHandle<C_CSObserverPawn>
    constexpr std::ptrdiff_t m_bPawnIsAlive = 0x7F4; // bool
    constexpr std::ptrdiff_t m_iPawnHealth = 0x7F8; // uint32_t
    constexpr std::ptrdiff_t m_iPawnArmor = 0x7FC; // int32_t
    constexpr std::ptrdiff_t m_bPawnHasDefuser = 0x800; // bool
    constexpr std::ptrdiff_t m_bPawnHasHelmet = 0x801; // bool
    constexpr std::ptrdiff_t m_nPawnCharacterDefIndex = 0x802; // uint16_t
    constexpr std::ptrdiff_t m_iPawnLifetimeStart = 0x804; // int32_t
    constexpr std::ptrdiff_t m_iPawnLifetimeEnd = 0x808; // int32_t
    constexpr std::ptrdiff_t m_iPawnBotDifficulty = 0x80C; // int32_t
    constexpr std::ptrdiff_t m_hOriginalControllerOfCurrentPawn = 0x810; // CHandle<CCSPlayerController>
    constexpr std::ptrdiff_t m_iScore = 0x814; // int32_t
    constexpr std::ptrdiff_t m_vecKills = 0x818; // C_NetworkUtlVectorBase<EKillTypes_t>
    constexpr std::ptrdiff_t m_iMVPs = 0x830; // int32_t
    constexpr std::ptrdiff_t m_bIsPlayerNameDirty = 0x834; // bool
}

namespace CCSPlayerController_ActionTrackingServices {
    constexpr std::ptrdiff_t m_perRoundStats = 0x40; // C_UtlVectorEmbeddedNetworkVar<CSPerRoundStats_t>
    constexpr std::ptrdiff_t m_matchStats = 0x90; // CSMatchStats_t
    constexpr std::ptrdiff_t m_iNumRoundKills = 0x108; // int32_t
    constexpr std::ptrdiff_t m_iNumRoundKillsHeadshots = 0x10C; // int32_t
    constexpr std::ptrdiff_t m_unTotalRoundDamageDealt = 0x110; // uint32_t
}

namespace CCSPlayerController_DamageServices {
    constexpr std::ptrdiff_t m_nSendUpdate = 0x40; // int32_t
    constexpr std::ptrdiff_t m_DamageList = 0x48; // C_UtlVectorEmbeddedNetworkVar<CDamageRecord>
}

namespace CCSPlayerController_InGameMoneyServices {
    constexpr std::ptrdiff_t m_iAccount = 0x40; // int32_t
    constexpr std::ptrdiff_t m_iStartAccount = 0x44; // int32_t
    constexpr std::ptrdiff_t m_iTotalCashSpent = 0x48; // int32_t
    constexpr std::ptrdiff_t m_iCashSpentThisRound = 0x4C; // int32_t
    constexpr std::ptrdiff_t m_nPreviousAccount = 0x50; // int32_t
}

namespace CCSPlayerController_InventoryServices {
    constexpr std::ptrdiff_t m_unMusicID = 0x40; // uint16_t
    constexpr std::ptrdiff_t m_rank = 0x44; // MedalRank_t[6]
    constexpr std::ptrdiff_t m_nPersonaDataPublicLevel = 0x5C; // int32_t
    constexpr std::ptrdiff_t m_nPersonaDataPublicCommendsLeader = 0x60; // int32_t
    constexpr std::ptrdiff_t m_nPersonaDataPublicCommendsTeacher = 0x64; // int32_t
    constexpr std::ptrdiff_t m_nPersonaDataPublicCommendsFriendly = 0x68; // int32_t
    constexpr std::ptrdiff_t m_vecServerAuthoritativeWeaponSlots = 0x70; // C_UtlVectorEmbeddedNetworkVar<ServerAuthoritativeWeaponSlot_t>
}

namespace CCSPlayer_ActionTrackingServices {
    constexpr std::ptrdiff_t m_hLastWeaponBeforeC4AutoSwitch = 0x40; // CHandle<C_BasePlayerWeapon>
    constexpr std::ptrdiff_t m_bIsRescuing = 0x44; // bool
    constexpr std::ptrdiff_t m_weaponPurchasesThisMatch = 0x48; // WeaponPurchaseTracker_t
    constexpr std::ptrdiff_t m_weaponPurchasesThisRound = 0xA0; // WeaponPurchaseTracker_t
}

namespace CCSPlayer_BulletServices {
    constexpr std::ptrdiff_t m_totalHitsOnServer = 0x40; // int32_t
}

namespace CCSPlayer_BuyServices {
    constexpr std::ptrdiff_t m_vecSellbackPurchaseEntries = 0x40; // C_UtlVectorEmbeddedNetworkVar<SellbackPurchaseEntry_t>
}

namespace CCSPlayer_CameraServices {
    constexpr std::ptrdiff_t m_flDeathCamTilt = 0x228; // float
}

namespace CCSPlayer_HostageServices {
    constexpr std::ptrdiff_t m_hCarriedHostage = 0x40; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_hCarriedHostageProp = 0x44; // CHandle<C_BaseEntity>
}

namespace CCSPlayer_ItemServices {
    constexpr std::ptrdiff_t m_bHasDefuser = 0x40; // bool
    constexpr std::ptrdiff_t m_bHasHelmet = 0x41; // bool
    constexpr std::ptrdiff_t m_bHasHeavyArmor = 0x42; // bool
}

namespace CCSPlayer_MovementServices {
    constexpr std::ptrdiff_t m_flMaxFallVelocity = 0x210; // float
    constexpr std::ptrdiff_t m_vecLadderNormal = 0x214; // Vector
    constexpr std::ptrdiff_t m_nLadderSurfacePropIndex = 0x220; // int32_t
    constexpr std::ptrdiff_t m_flDuckAmount = 0x224; // float
    constexpr std::ptrdiff_t m_flDuckSpeed = 0x228; // float
    constexpr std::ptrdiff_t m_bDuckOverride = 0x22C; // bool
    constexpr std::ptrdiff_t m_bDesiresDuck = 0x22D; // bool
    constexpr std::ptrdiff_t m_flDuckOffset = 0x230; // float
    constexpr std::ptrdiff_t m_nDuckTimeMsecs = 0x234; // uint32_t
    constexpr std::ptrdiff_t m_nDuckJumpTimeMsecs = 0x238; // uint32_t
    constexpr std::ptrdiff_t m_nJumpTimeMsecs = 0x23C; // uint32_t
    constexpr std::ptrdiff_t m_flLastDuckTime = 0x240; // float
    constexpr std::ptrdiff_t m_vecLastPositionAtFullCrouchSpeed = 0x250; // Vector2D
    constexpr std::ptrdiff_t m_duckUntilOnGround = 0x258; // bool
    constexpr std::ptrdiff_t m_bHasWalkMovedSinceLastJump = 0x259; // bool
    constexpr std::ptrdiff_t m_bInStuckTest = 0x25A; // bool
    constexpr std::ptrdiff_t m_flStuckCheckTime = 0x268; // float[64][2]
    constexpr std::ptrdiff_t m_nTraceCount = 0x468; // int32_t
    constexpr std::ptrdiff_t m_StuckLast = 0x46C; // int32_t
    constexpr std::ptrdiff_t m_bSpeedCropped = 0x470; // bool
    constexpr std::ptrdiff_t m_nOldWaterLevel = 0x474; // int32_t
    constexpr std::ptrdiff_t m_flWaterEntryTime = 0x478; // float
    constexpr std::ptrdiff_t m_vecForward = 0x47C; // Vector
    constexpr std::ptrdiff_t m_vecLeft = 0x488; // Vector
    constexpr std::ptrdiff_t m_vecUp = 0x494; // Vector
    constexpr std::ptrdiff_t m_vecPreviouslyPredictedOrigin = 0x4A0; // Vector
    constexpr std::ptrdiff_t m_bOldJumpPressed = 0x4AC; // bool
    constexpr std::ptrdiff_t m_flJumpPressedTime = 0x4B0; // float
    constexpr std::ptrdiff_t m_flJumpUntil = 0x4B4; // float
    constexpr std::ptrdiff_t m_flJumpVel = 0x4B8; // float
    constexpr std::ptrdiff_t m_fStashGrenadeParameterWhen = 0x4BC; // GameTime_t
    constexpr std::ptrdiff_t m_nButtonDownMaskPrev = 0x4C0; // uint64_t
    constexpr std::ptrdiff_t m_flOffsetTickCompleteTime = 0x4C8; // float
    constexpr std::ptrdiff_t m_flOffsetTickStashedSpeed = 0x4CC; // float
    constexpr std::ptrdiff_t m_flStamina = 0x4D0; // float
    constexpr std::ptrdiff_t m_bUpdatePredictedOriginAfterDataUpdate = 0x4D4; // bool
    constexpr std::ptrdiff_t m_flHeightAtJumpStart = 0x4D8; // float
    constexpr std::ptrdiff_t m_flMaxJumpHeightThisJump = 0x4DC; // float
}

namespace CCSPlayer_PingServices {
    constexpr std::ptrdiff_t m_hPlayerPing = 0x40; // CHandle<C_BaseEntity>
}

namespace CCSPlayer_ViewModelServices {
    constexpr std::ptrdiff_t m_hViewModel = 0x40; // CHandle<C_BaseViewModel>[3]
}

namespace CCSPlayer_WaterServices {
    constexpr std::ptrdiff_t m_flWaterJumpTime = 0x40; // float
    constexpr std::ptrdiff_t m_vecWaterJumpVel = 0x44; // Vector
    constexpr std::ptrdiff_t m_flSwimSoundTime = 0x50; // float
}

namespace CCSPlayer_WeaponServices {
    constexpr std::ptrdiff_t m_flNextAttack = 0xC0; // GameTime_t
    constexpr std::ptrdiff_t m_bIsLookingAtWeapon = 0xC4; // bool
    constexpr std::ptrdiff_t m_bIsHoldingLookAtWeapon = 0xC5; // bool
}

namespace CCSWeaponBaseVData {
    constexpr std::ptrdiff_t m_WeaponType = 0x240; // CSWeaponType
    constexpr std::ptrdiff_t m_WeaponCategory = 0x244; // CSWeaponCategory
    constexpr std::ptrdiff_t m_szViewModel = 0x248; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_szPlayerModel = 0x328; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_szWorldDroppedModel = 0x408; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_szAimsightLensMaskModel = 0x4E8; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_szMagazineModel = 0x5C8; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_szHeatEffect = 0x6A8; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_szEjectBrassEffect = 0x788; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_szMuzzleFlashParticleAlt = 0x868; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_szMuzzleFlashThirdPersonParticle = 0x948; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_szMuzzleFlashThirdPersonParticleAlt = 0xA28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_szTracerParticle = 0xB08; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_GearSlot = 0xBE8; // gear_slot_t
    constexpr std::ptrdiff_t m_GearSlotPosition = 0xBEC; // int32_t
    constexpr std::ptrdiff_t m_DefaultLoadoutSlot = 0xBF0; // loadout_slot_t
    constexpr std::ptrdiff_t m_sWrongTeamMsg = 0xBF8; // CUtlString
    constexpr std::ptrdiff_t m_nPrice = 0xC00; // int32_t
    constexpr std::ptrdiff_t m_nKillAward = 0xC04; // int32_t
    constexpr std::ptrdiff_t m_nPrimaryReserveAmmoMax = 0xC08; // int32_t
    constexpr std::ptrdiff_t m_nSecondaryReserveAmmoMax = 0xC0C; // int32_t
    constexpr std::ptrdiff_t m_bMeleeWeapon = 0xC10; // bool
    constexpr std::ptrdiff_t m_bHasBurstMode = 0xC11; // bool
    constexpr std::ptrdiff_t m_bIsRevolver = 0xC12; // bool
    constexpr std::ptrdiff_t m_bCannotShootUnderwater = 0xC13; // bool
    constexpr std::ptrdiff_t m_szName = 0xC18; // CUtlString
    constexpr std::ptrdiff_t m_szAnimExtension = 0xC20; // CUtlString
    constexpr std::ptrdiff_t m_eSilencerType = 0xC28; // CSWeaponSilencerType
    constexpr std::ptrdiff_t m_nCrosshairMinDistance = 0xC2C; // int32_t
    constexpr std::ptrdiff_t m_nCrosshairDeltaDistance = 0xC30; // int32_t
    constexpr std::ptrdiff_t m_flCycleTime = 0xC34; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flMaxSpeed = 0xC3C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flSpread = 0xC44; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyCrouch = 0xC4C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyStand = 0xC54; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyJump = 0xC5C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyLand = 0xC64; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyLadder = 0xC6C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyFire = 0xC74; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyMove = 0xC7C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flRecoilAngle = 0xC84; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flRecoilAngleVariance = 0xC8C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flRecoilMagnitude = 0xC94; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flRecoilMagnitudeVariance = 0xC9C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_nTracerFrequency = 0xCA4; // CFiringModeInt
    constexpr std::ptrdiff_t m_flInaccuracyJumpInitial = 0xCAC; // float
    constexpr std::ptrdiff_t m_flInaccuracyJumpApex = 0xCB0; // float
    constexpr std::ptrdiff_t m_flInaccuracyReload = 0xCB4; // float
    constexpr std::ptrdiff_t m_nRecoilSeed = 0xCB8; // int32_t
    constexpr std::ptrdiff_t m_nSpreadSeed = 0xCBC; // int32_t
    constexpr std::ptrdiff_t m_flTimeToIdleAfterFire = 0xCC0; // float
    constexpr std::ptrdiff_t m_flIdleInterval = 0xCC4; // float
    constexpr std::ptrdiff_t m_flAttackMovespeedFactor = 0xCC8; // float
    constexpr std::ptrdiff_t m_flHeatPerShot = 0xCCC; // float
    constexpr std::ptrdiff_t m_flInaccuracyPitchShift = 0xCD0; // float
    constexpr std::ptrdiff_t m_flInaccuracyAltSoundThreshold = 0xCD4; // float
    constexpr std::ptrdiff_t m_flBotAudibleRange = 0xCD8; // float
    constexpr std::ptrdiff_t m_szUseRadioSubtitle = 0xCE0; // CUtlString
    constexpr std::ptrdiff_t m_bUnzoomsAfterShot = 0xCE8; // bool
    constexpr std::ptrdiff_t m_bHideViewModelWhenZoomed = 0xCE9; // bool
    constexpr std::ptrdiff_t m_nZoomLevels = 0xCEC; // int32_t
    constexpr std::ptrdiff_t m_nZoomFOV1 = 0xCF0; // int32_t
    constexpr std::ptrdiff_t m_nZoomFOV2 = 0xCF4; // int32_t
    constexpr std::ptrdiff_t m_flZoomTime0 = 0xCF8; // float
    constexpr std::ptrdiff_t m_flZoomTime1 = 0xCFC; // float
    constexpr std::ptrdiff_t m_flZoomTime2 = 0xD00; // float
    constexpr std::ptrdiff_t m_flIronSightPullUpSpeed = 0xD04; // float
    constexpr std::ptrdiff_t m_flIronSightPutDownSpeed = 0xD08; // float
    constexpr std::ptrdiff_t m_flIronSightFOV = 0xD0C; // float
    constexpr std::ptrdiff_t m_flIronSightPivotForward = 0xD10; // float
    constexpr std::ptrdiff_t m_flIronSightLooseness = 0xD14; // float
    constexpr std::ptrdiff_t m_angPivotAngle = 0xD18; // QAngle
    constexpr std::ptrdiff_t m_vecIronSightEyePos = 0xD24; // Vector
    constexpr std::ptrdiff_t m_nDamage = 0xD30; // int32_t
    constexpr std::ptrdiff_t m_flHeadshotMultiplier = 0xD34; // float
    constexpr std::ptrdiff_t m_flArmorRatio = 0xD38; // float
    constexpr std::ptrdiff_t m_flPenetration = 0xD3C; // float
    constexpr std::ptrdiff_t m_flRange = 0xD40; // float
    constexpr std::ptrdiff_t m_flRangeModifier = 0xD44; // float
    constexpr std::ptrdiff_t m_flFlinchVelocityModifierLarge = 0xD48; // float
    constexpr std::ptrdiff_t m_flFlinchVelocityModifierSmall = 0xD4C; // float
    constexpr std::ptrdiff_t m_flRecoveryTimeCrouch = 0xD50; // float
    constexpr std::ptrdiff_t m_flRecoveryTimeStand = 0xD54; // float
    constexpr std::ptrdiff_t m_flRecoveryTimeCrouchFinal = 0xD58; // float
    constexpr std::ptrdiff_t m_flRecoveryTimeStandFinal = 0xD5C; // float
    constexpr std::ptrdiff_t m_nRecoveryTransitionStartBullet = 0xD60; // int32_t
    constexpr std::ptrdiff_t m_nRecoveryTransitionEndBullet = 0xD64; // int32_t
    constexpr std::ptrdiff_t m_flThrowVelocity = 0xD68; // float
    constexpr std::ptrdiff_t m_vSmokeColor = 0xD6C; // Vector
    constexpr std::ptrdiff_t m_szAnimClass = 0xD78; // CUtlString
}

namespace CClientAlphaProperty {
    constexpr std::ptrdiff_t m_nRenderFX = 0x10; // uint8_t
    constexpr std::ptrdiff_t m_nRenderMode = 0x11; // uint8_t
    constexpr std::ptrdiff_t m_bAlphaOverride = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bShadowAlphaOverride = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_nReserved = 0x0; // bitfield:6
    constexpr std::ptrdiff_t m_nAlpha = 0x13; // uint8_t
    constexpr std::ptrdiff_t m_nDesyncOffset = 0x14; // uint16_t
    constexpr std::ptrdiff_t m_nReserved2 = 0x16; // uint16_t
    constexpr std::ptrdiff_t m_nDistFadeStart = 0x18; // uint16_t
    constexpr std::ptrdiff_t m_nDistFadeEnd = 0x1A; // uint16_t
    constexpr std::ptrdiff_t m_flFadeScale = 0x1C; // float
    constexpr std::ptrdiff_t m_flRenderFxStartTime = 0x20; // GameTime_t
    constexpr std::ptrdiff_t m_flRenderFxDuration = 0x24; // float
}

namespace CCollisionProperty {
    constexpr std::ptrdiff_t m_collisionAttribute = 0x10; // VPhysicsCollisionAttribute_t
    constexpr std::ptrdiff_t m_vecMins = 0x40; // Vector
    constexpr std::ptrdiff_t m_vecMaxs = 0x4C; // Vector
    constexpr std::ptrdiff_t m_usSolidFlags = 0x5A; // uint8_t
    constexpr std::ptrdiff_t m_nSolidType = 0x5B; // SolidType_t
    constexpr std::ptrdiff_t m_triggerBloat = 0x5C; // uint8_t
    constexpr std::ptrdiff_t m_nSurroundType = 0x5D; // SurroundingBoundsType_t
    constexpr std::ptrdiff_t m_CollisionGroup = 0x5E; // uint8_t
    constexpr std::ptrdiff_t m_nEnablePhysics = 0x5F; // uint8_t
    constexpr std::ptrdiff_t m_flBoundingRadius = 0x60; // float
    constexpr std::ptrdiff_t m_vecSpecifiedSurroundingMins = 0x64; // Vector
    constexpr std::ptrdiff_t m_vecSpecifiedSurroundingMaxs = 0x70; // Vector
    constexpr std::ptrdiff_t m_vecSurroundingMaxs = 0x7C; // Vector
    constexpr std::ptrdiff_t m_vecSurroundingMins = 0x88; // Vector
    constexpr std::ptrdiff_t m_vCapsuleCenter1 = 0x94; // Vector
    constexpr std::ptrdiff_t m_vCapsuleCenter2 = 0xA0; // Vector
    constexpr std::ptrdiff_t m_flCapsuleRadius = 0xAC; // float
}

namespace CComicBook {
    constexpr std::ptrdiff_t m_CoverImage = 0x8; // CPanoramaImageName
    constexpr std::ptrdiff_t m_XmlFile = 0x18; // CUtlString
}

namespace CCompositeMaterialEditorDoc {
    constexpr std::ptrdiff_t m_nVersion = 0x8; // int32_t
    constexpr std::ptrdiff_t m_Points = 0x10; // CUtlVector<CompositeMaterialEditorPoint_t>
    constexpr std::ptrdiff_t m_KVthumbnail = 0x28; // KeyValues3
}

namespace CDamageRecord {
    constexpr std::ptrdiff_t m_PlayerDamager = 0x28; // CHandle<C_CSPlayerPawnBase>
    constexpr std::ptrdiff_t m_PlayerRecipient = 0x2C; // CHandle<C_CSPlayerPawnBase>
    constexpr std::ptrdiff_t m_hPlayerControllerDamager = 0x30; // CHandle<CCSPlayerController>
    constexpr std::ptrdiff_t m_hPlayerControllerRecipient = 0x34; // CHandle<CCSPlayerController>
    constexpr std::ptrdiff_t m_szPlayerDamagerName = 0x38; // CUtlString
    constexpr std::ptrdiff_t m_szPlayerRecipientName = 0x40; // CUtlString
    constexpr std::ptrdiff_t m_DamagerXuid = 0x48; // uint64_t
    constexpr std::ptrdiff_t m_RecipientXuid = 0x50; // uint64_t
    constexpr std::ptrdiff_t m_iDamage = 0x58; // int32_t
    constexpr std::ptrdiff_t m_iActualHealthRemoved = 0x5C; // int32_t
    constexpr std::ptrdiff_t m_iNumHits = 0x60; // int32_t
    constexpr std::ptrdiff_t m_iLastBulletUpdate = 0x64; // int32_t
    constexpr std::ptrdiff_t m_bIsOtherEnemy = 0x68; // bool
    constexpr std::ptrdiff_t m_killType = 0x69; // EKillTypes_t
}

namespace CDecalInfo {
    constexpr std::ptrdiff_t m_flAnimationScale = 0x0; // float
    constexpr std::ptrdiff_t m_flAnimationLifeSpan = 0x4; // float
    constexpr std::ptrdiff_t m_flPlaceTime = 0x8; // float
    constexpr std::ptrdiff_t m_flFadeStartTime = 0xC; // float
    constexpr std::ptrdiff_t m_flFadeDuration = 0x10; // float
    constexpr std::ptrdiff_t m_nVBSlot = 0x14; // int32_t
    constexpr std::ptrdiff_t m_nBoneIndex = 0x18; // int32_t
    constexpr std::ptrdiff_t m_vPosition = 0x28; // Vector
    constexpr std::ptrdiff_t m_flBoundingRadiusSqr = 0x34; // float
    constexpr std::ptrdiff_t m_pNext = 0x40; // CDecalInfo*
    constexpr std::ptrdiff_t m_pPrev = 0x48; // CDecalInfo*
    constexpr std::ptrdiff_t m_nDecalMaterialIndex = 0xA8; // int32_t
}

namespace CEconItemAttribute {
    constexpr std::ptrdiff_t m_iAttributeDefinitionIndex = 0x30; // uint16_t
    constexpr std::ptrdiff_t m_flValue = 0x34; // float
    constexpr std::ptrdiff_t m_flInitialValue = 0x38; // float
    constexpr std::ptrdiff_t m_nRefundableCurrency = 0x3C; // int32_t
    constexpr std::ptrdiff_t m_bSetBonus = 0x40; // bool
}

namespace CEffectData {
    constexpr std::ptrdiff_t m_vOrigin = 0x8; // Vector
    constexpr std::ptrdiff_t m_vStart = 0x14; // Vector
    constexpr std::ptrdiff_t m_vNormal = 0x20; // Vector
    constexpr std::ptrdiff_t m_vAngles = 0x2C; // QAngle
    constexpr std::ptrdiff_t m_hEntity = 0x38; // CEntityHandle
    constexpr std::ptrdiff_t m_hOtherEntity = 0x3C; // CEntityHandle
    constexpr std::ptrdiff_t m_flScale = 0x40; // float
    constexpr std::ptrdiff_t m_flMagnitude = 0x44; // float
    constexpr std::ptrdiff_t m_flRadius = 0x48; // float
    constexpr std::ptrdiff_t m_nSurfaceProp = 0x4C; // CUtlStringToken
    constexpr std::ptrdiff_t m_nEffectIndex = 0x50; // CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_nDamageType = 0x58; // uint32_t
    constexpr std::ptrdiff_t m_nPenetrate = 0x5C; // uint8_t
    constexpr std::ptrdiff_t m_nMaterial = 0x5E; // uint16_t
    constexpr std::ptrdiff_t m_nHitBox = 0x60; // uint16_t
    constexpr std::ptrdiff_t m_nColor = 0x62; // uint8_t
    constexpr std::ptrdiff_t m_fFlags = 0x63; // uint8_t
    constexpr std::ptrdiff_t m_nAttachmentIndex = 0x64; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_nAttachmentName = 0x68; // CUtlStringToken
    constexpr std::ptrdiff_t m_iEffectName = 0x6C; // uint16_t
    constexpr std::ptrdiff_t m_nExplosionType = 0x6E; // uint8_t
}

namespace CEntityIdentity {
    constexpr std::ptrdiff_t m_nameStringableIndex = 0x14; // int32_t
    constexpr std::ptrdiff_t m_name = 0x18; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_designerName = 0x20; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flags = 0x30; // uint32_t
    constexpr std::ptrdiff_t m_worldGroupId = 0x38; // WorldGroupId_t
    constexpr std::ptrdiff_t m_fDataObjectTypes = 0x3C; // uint32_t
    constexpr std::ptrdiff_t m_PathIndex = 0x40; // ChangeAccessorFieldPathIndex_t
    constexpr std::ptrdiff_t m_pPrev = 0x58; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pNext = 0x60; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pPrevByClass = 0x68; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pNextByClass = 0x70; // CEntityIdentity*
}

namespace CEntityInstance {
    constexpr std::ptrdiff_t m_iszPrivateVScripts = 0x8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_pEntity = 0x10; // CEntityIdentity*
    constexpr std::ptrdiff_t m_CScriptComponent = 0x28; // CScriptComponent*
}

namespace CFireOverlay {
    constexpr std::ptrdiff_t m_pOwner = 0xD0; // C_FireSmoke*
    constexpr std::ptrdiff_t m_vBaseColors = 0xD8; // Vector[4]
    constexpr std::ptrdiff_t m_flScale = 0x108; // float
    constexpr std::ptrdiff_t m_nGUID = 0x10C; // int32_t
}

namespace CFlashlightEffect {
    constexpr std::ptrdiff_t m_bIsOn = 0x10; // bool
    constexpr std::ptrdiff_t m_bMuzzleFlashEnabled = 0x20; // bool
    constexpr std::ptrdiff_t m_flMuzzleFlashBrightness = 0x24; // float
    constexpr std::ptrdiff_t m_quatMuzzleFlashOrientation = 0x30; // Quaternion
    constexpr std::ptrdiff_t m_vecMuzzleFlashOrigin = 0x40; // Vector
    constexpr std::ptrdiff_t m_flFov = 0x4C; // float
    constexpr std::ptrdiff_t m_flFarZ = 0x50; // float
    constexpr std::ptrdiff_t m_flLinearAtten = 0x54; // float
    constexpr std::ptrdiff_t m_bCastsShadows = 0x58; // bool
    constexpr std::ptrdiff_t m_flCurrentPullBackDist = 0x5C; // float
    constexpr std::ptrdiff_t m_FlashlightTexture = 0x60; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_MuzzleFlashTexture = 0x68; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_textureName = 0x70; // char[64]
}

namespace CFuncWater {
    constexpr std::ptrdiff_t m_BuoyancyHelper = 0xCC0; // CBuoyancyHelper
}

namespace CGameSceneNode {
    constexpr std::ptrdiff_t m_nodeToWorld = 0x10; // CTransform
    constexpr std::ptrdiff_t m_pOwner = 0x30; // CEntityInstance*
    constexpr std::ptrdiff_t m_pParent = 0x38; // CGameSceneNode*
    constexpr std::ptrdiff_t m_pChild = 0x40; // CGameSceneNode*
    constexpr std::ptrdiff_t m_pNextSibling = 0x48; // CGameSceneNode*
    constexpr std::ptrdiff_t m_hParent = 0x70; // CGameSceneNodeHandle
    constexpr std::ptrdiff_t m_vecOrigin = 0x80; // CNetworkOriginCellCoordQuantizedVector
    constexpr std::ptrdiff_t m_angRotation = 0xB8; // QAngle
    constexpr std::ptrdiff_t m_flScale = 0xC4; // float
    constexpr std::ptrdiff_t m_vecAbsOrigin = 0xC8; // Vector
    constexpr std::ptrdiff_t m_angAbsRotation = 0xD4; // QAngle
    constexpr std::ptrdiff_t m_flAbsScale = 0xE0; // float
    constexpr std::ptrdiff_t m_nParentAttachmentOrBone = 0xE4; // int16_t
    constexpr std::ptrdiff_t m_bDebugAbsOriginChanges = 0xE6; // bool
    constexpr std::ptrdiff_t m_bDormant = 0xE7; // bool
    constexpr std::ptrdiff_t m_bForceParentToBeNetworked = 0xE8; // bool
    constexpr std::ptrdiff_t m_bDirtyHierarchy = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bDirtyBoneMergeInfo = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bNetworkedPositionChanged = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bNetworkedAnglesChanged = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bNetworkedScaleChanged = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bWillBeCallingPostDataUpdate = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bNotifyBoneTransformsChanged = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bBoneMergeFlex = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_nLatchAbsOrigin = 0x0; // bitfield:2
    constexpr std::ptrdiff_t m_bDirtyBoneMergeBoneToRoot = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_nHierarchicalDepth = 0xEB; // uint8_t
    constexpr std::ptrdiff_t m_nHierarchyType = 0xEC; // uint8_t
    constexpr std::ptrdiff_t m_nDoNotSetAnimTimeInInvalidatePhysicsCount = 0xED; // uint8_t
    constexpr std::ptrdiff_t m_name = 0xF0; // CUtlStringToken
    constexpr std::ptrdiff_t m_hierarchyAttachName = 0x130; // CUtlStringToken
    constexpr std::ptrdiff_t m_flZOffset = 0x134; // float
    constexpr std::ptrdiff_t m_vRenderOrigin = 0x138; // Vector
}

namespace CGameSceneNodeHandle {
    constexpr std::ptrdiff_t m_hOwner = 0x8; // CEntityHandle
    constexpr std::ptrdiff_t m_name = 0xC; // CUtlStringToken
}

namespace CGlobalLightBase {
    constexpr std::ptrdiff_t m_bSpotLight = 0x10; // bool
    constexpr std::ptrdiff_t m_SpotLightOrigin = 0x14; // Vector
    constexpr std::ptrdiff_t m_SpotLightAngles = 0x20; // QAngle
    constexpr std::ptrdiff_t m_ShadowDirection = 0x2C; // Vector
    constexpr std::ptrdiff_t m_AmbientDirection = 0x38; // Vector
    constexpr std::ptrdiff_t m_SpecularDirection = 0x44; // Vector
    constexpr std::ptrdiff_t m_InspectorSpecularDirection = 0x50; // Vector
    constexpr std::ptrdiff_t m_flSpecularPower = 0x5C; // float
    constexpr std::ptrdiff_t m_flSpecularIndependence = 0x60; // float
    constexpr std::ptrdiff_t m_SpecularColor = 0x64; // Color
    constexpr std::ptrdiff_t m_bStartDisabled = 0x68; // bool
    constexpr std::ptrdiff_t m_bEnabled = 0x69; // bool
    constexpr std::ptrdiff_t m_LightColor = 0x6A; // Color
    constexpr std::ptrdiff_t m_AmbientColor1 = 0x6E; // Color
    constexpr std::ptrdiff_t m_AmbientColor2 = 0x72; // Color
    constexpr std::ptrdiff_t m_AmbientColor3 = 0x76; // Color
    constexpr std::ptrdiff_t m_flSunDistance = 0x7C; // float
    constexpr std::ptrdiff_t m_flFOV = 0x80; // float
    constexpr std::ptrdiff_t m_flNearZ = 0x84; // float
    constexpr std::ptrdiff_t m_flFarZ = 0x88; // float
    constexpr std::ptrdiff_t m_bEnableShadows = 0x8C; // bool
    constexpr std::ptrdiff_t m_bOldEnableShadows = 0x8D; // bool
    constexpr std::ptrdiff_t m_bBackgroundClearNotRequired = 0x8E; // bool
    constexpr std::ptrdiff_t m_flCloudScale = 0x90; // float
    constexpr std::ptrdiff_t m_flCloud1Speed = 0x94; // float
    constexpr std::ptrdiff_t m_flCloud1Direction = 0x98; // float
    constexpr std::ptrdiff_t m_flCloud2Speed = 0x9C; // float
    constexpr std::ptrdiff_t m_flCloud2Direction = 0xA0; // float
    constexpr std::ptrdiff_t m_flAmbientScale1 = 0xB0; // float
    constexpr std::ptrdiff_t m_flAmbientScale2 = 0xB4; // float
    constexpr std::ptrdiff_t m_flGroundScale = 0xB8; // float
    constexpr std::ptrdiff_t m_flLightScale = 0xBC; // float
    constexpr std::ptrdiff_t m_flFoWDarkness = 0xC0; // float
    constexpr std::ptrdiff_t m_bEnableSeparateSkyboxFog = 0xC4; // bool
    constexpr std::ptrdiff_t m_vFowColor = 0xC8; // Vector
    constexpr std::ptrdiff_t m_ViewOrigin = 0xD4; // Vector
    constexpr std::ptrdiff_t m_ViewAngles = 0xE0; // QAngle
    constexpr std::ptrdiff_t m_flViewFoV = 0xEC; // float
    constexpr std::ptrdiff_t m_WorldPoints = 0xF0; // Vector[8]
    constexpr std::ptrdiff_t m_vFogOffsetLayer0 = 0x4A8; // Vector2D
    constexpr std::ptrdiff_t m_vFogOffsetLayer1 = 0x4B0; // Vector2D
    constexpr std::ptrdiff_t m_hEnvWind = 0x4B8; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_hEnvSky = 0x4BC; // CHandle<C_BaseEntity>
}

namespace CGlowOverlay {
    constexpr std::ptrdiff_t m_vPos = 0x8; // Vector
    constexpr std::ptrdiff_t m_bDirectional = 0x14; // bool
    constexpr std::ptrdiff_t m_vDirection = 0x18; // Vector
    constexpr std::ptrdiff_t m_bInSky = 0x24; // bool
    constexpr std::ptrdiff_t m_skyObstructionScale = 0x28; // float
    constexpr std::ptrdiff_t m_Sprites = 0x30; // CGlowSprite[4]
    constexpr std::ptrdiff_t m_nSprites = 0xB0; // int32_t
    constexpr std::ptrdiff_t m_flProxyRadius = 0xB4; // float
    constexpr std::ptrdiff_t m_flHDRColorScale = 0xB8; // float
    constexpr std::ptrdiff_t m_flGlowObstructionScale = 0xBC; // float
    constexpr std::ptrdiff_t m_bCacheGlowObstruction = 0xC0; // bool
    constexpr std::ptrdiff_t m_bCacheSkyObstruction = 0xC1; // bool
    constexpr std::ptrdiff_t m_bActivated = 0xC2; // int16_t
    constexpr std::ptrdiff_t m_ListIndex = 0xC4; // uint16_t
    constexpr std::ptrdiff_t m_queryHandle = 0xC8; // int32_t
}

namespace CGlowProperty {
    constexpr std::ptrdiff_t m_fGlowColor = 0x8; // Vector
    constexpr std::ptrdiff_t m_iGlowType = 0x30; // int32_t
    constexpr std::ptrdiff_t m_iGlowTeam = 0x34; // int32_t
    constexpr std::ptrdiff_t m_nGlowRange = 0x38; // int32_t
    constexpr std::ptrdiff_t m_nGlowRangeMin = 0x3C; // int32_t
    constexpr std::ptrdiff_t m_glowColorOverride = 0x40; // Color
    constexpr std::ptrdiff_t m_bFlashing = 0x44; // bool
    constexpr std::ptrdiff_t m_flGlowTime = 0x48; // float
    constexpr std::ptrdiff_t m_flGlowStartTime = 0x4C; // float
    constexpr std::ptrdiff_t m_bEligibleForScreenHighlight = 0x50; // bool
    constexpr std::ptrdiff_t m_bGlowing = 0x51; // bool
}

namespace CGlowSprite {
    constexpr std::ptrdiff_t m_vColor = 0x0; // Vector
    constexpr std::ptrdiff_t m_flHorzSize = 0xC; // float
    constexpr std::ptrdiff_t m_flVertSize = 0x10; // float
    constexpr std::ptrdiff_t m_hMaterial = 0x18; // CStrongHandle<InfoForResourceTypeIMaterial2>
}

namespace CGrenadeTracer {
    constexpr std::ptrdiff_t m_flTracerDuration = 0xCE0; // float
    constexpr std::ptrdiff_t m_nType = 0xCE4; // GrenadeType_t
}

namespace CHitboxComponent {
    constexpr std::ptrdiff_t m_bvDisabledHitGroups = 0x24; // uint32_t[1]
}

namespace CInfoDynamicShadowHint {
    constexpr std::ptrdiff_t m_bDisabled = 0x540; // bool
    constexpr std::ptrdiff_t m_flRange = 0x544; // float
    constexpr std::ptrdiff_t m_nImportance = 0x548; // int32_t
    constexpr std::ptrdiff_t m_nLightChoice = 0x54C; // int32_t
    constexpr std::ptrdiff_t m_hLight = 0x550; // CHandle<C_BaseEntity>
}

namespace CInfoDynamicShadowHintBox {
    constexpr std::ptrdiff_t m_vBoxMins = 0x558; // Vector
    constexpr std::ptrdiff_t m_vBoxMaxs = 0x564; // Vector
}

namespace CInfoOffscreenPanoramaTexture {
    constexpr std::ptrdiff_t m_bDisabled = 0x540; // bool
    constexpr std::ptrdiff_t m_nResolutionX = 0x544; // int32_t
    constexpr std::ptrdiff_t m_nResolutionY = 0x548; // int32_t
    constexpr std::ptrdiff_t m_szLayoutFileName = 0x550; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_RenderAttrName = 0x558; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_TargetEntities = 0x560; // C_NetworkUtlVectorBase<CHandle<C_BaseModelEntity>>
    constexpr std::ptrdiff_t m_nTargetChangeCount = 0x578; // int32_t
    constexpr std::ptrdiff_t m_vecCSSClasses = 0x580; // C_NetworkUtlVectorBase<CUtlSymbolLarge>
    constexpr std::ptrdiff_t m_bCheckCSSClasses = 0x6F8; // bool
}

namespace CInfoWorldLayer {
    constexpr std::ptrdiff_t m_pOutputOnEntitiesSpawned = 0x540; // CEntityIOOutput
    constexpr std::ptrdiff_t m_worldName = 0x568; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_layerName = 0x570; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bWorldLayerVisible = 0x578; // bool
    constexpr std::ptrdiff_t m_bEntitiesSpawned = 0x579; // bool
    constexpr std::ptrdiff_t m_bCreateAsChildSpawnGroup = 0x57A; // bool
    constexpr std::ptrdiff_t m_hLayerSpawnGroup = 0x57C; // uint32_t
    constexpr std::ptrdiff_t m_bWorldLayerActuallyVisible = 0x580; // bool
}

namespace CInterpolatedValue {
    constexpr std::ptrdiff_t m_flStartTime = 0x0; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x4; // float
    constexpr std::ptrdiff_t m_flStartValue = 0x8; // float
    constexpr std::ptrdiff_t m_flEndValue = 0xC; // float
    constexpr std::ptrdiff_t m_nInterpType = 0x10; // int32_t
}

namespace CLightComponent {
    constexpr std::ptrdiff_t __m_pChainEntity = 0x48; // CNetworkVarChainer
    constexpr std::ptrdiff_t m_Color = 0x85; // Color
    constexpr std::ptrdiff_t m_SecondaryColor = 0x89; // Color
    constexpr std::ptrdiff_t m_flBrightness = 0x90; // float
    constexpr std::ptrdiff_t m_flBrightnessScale = 0x94; // float
    constexpr std::ptrdiff_t m_flBrightnessMult = 0x98; // float
    constexpr std::ptrdiff_t m_flRange = 0x9C; // float
    constexpr std::ptrdiff_t m_flFalloff = 0xA0; // float
    constexpr std::ptrdiff_t m_flAttenuation0 = 0xA4; // float
    constexpr std::ptrdiff_t m_flAttenuation1 = 0xA8; // float
    constexpr std::ptrdiff_t m_flAttenuation2 = 0xAC; // float
    constexpr std::ptrdiff_t m_flTheta = 0xB0; // float
    constexpr std::ptrdiff_t m_flPhi = 0xB4; // float
    constexpr std::ptrdiff_t m_hLightCookie = 0xB8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_nCascades = 0xC0; // int32_t
    constexpr std::ptrdiff_t m_nCastShadows = 0xC4; // int32_t
    constexpr std::ptrdiff_t m_nShadowWidth = 0xC8; // int32_t
    constexpr std::ptrdiff_t m_nShadowHeight = 0xCC; // int32_t
    constexpr std::ptrdiff_t m_bRenderDiffuse = 0xD0; // bool
    constexpr std::ptrdiff_t m_nRenderSpecular = 0xD4; // int32_t
    constexpr std::ptrdiff_t m_bRenderTransmissive = 0xD8; // bool
    constexpr std::ptrdiff_t m_flOrthoLightWidth = 0xDC; // float
    constexpr std::ptrdiff_t m_flOrthoLightHeight = 0xE0; // float
    constexpr std::ptrdiff_t m_nStyle = 0xE4; // int32_t
    constexpr std::ptrdiff_t m_Pattern = 0xE8; // CUtlString
    constexpr std::ptrdiff_t m_nCascadeRenderStaticObjects = 0xF0; // int32_t
    constexpr std::ptrdiff_t m_flShadowCascadeCrossFade = 0xF4; // float
    constexpr std::ptrdiff_t m_flShadowCascadeDistanceFade = 0xF8; // float
    constexpr std::ptrdiff_t m_flShadowCascadeDistance0 = 0xFC; // float
    constexpr std::ptrdiff_t m_flShadowCascadeDistance1 = 0x100; // float
    constexpr std::ptrdiff_t m_flShadowCascadeDistance2 = 0x104; // float
    constexpr std::ptrdiff_t m_flShadowCascadeDistance3 = 0x108; // float
    constexpr std::ptrdiff_t m_nShadowCascadeResolution0 = 0x10C; // int32_t
    constexpr std::ptrdiff_t m_nShadowCascadeResolution1 = 0x110; // int32_t
    constexpr std::ptrdiff_t m_nShadowCascadeResolution2 = 0x114; // int32_t
    constexpr std::ptrdiff_t m_nShadowCascadeResolution3 = 0x118; // int32_t
    constexpr std::ptrdiff_t m_bUsesBakedShadowing = 0x11C; // bool
    constexpr std::ptrdiff_t m_nShadowPriority = 0x120; // int32_t
    constexpr std::ptrdiff_t m_nBakedShadowIndex = 0x124; // int32_t
    constexpr std::ptrdiff_t m_bRenderToCubemaps = 0x128; // bool
    constexpr std::ptrdiff_t m_nDirectLight = 0x12C; // int32_t
    constexpr std::ptrdiff_t m_nIndirectLight = 0x130; // int32_t
    constexpr std::ptrdiff_t m_flFadeMinDist = 0x134; // float
    constexpr std::ptrdiff_t m_flFadeMaxDist = 0x138; // float
    constexpr std::ptrdiff_t m_flShadowFadeMinDist = 0x13C; // float
    constexpr std::ptrdiff_t m_flShadowFadeMaxDist = 0x140; // float
    constexpr std::ptrdiff_t m_bEnabled = 0x144; // bool
    constexpr std::ptrdiff_t m_bFlicker = 0x145; // bool
    constexpr std::ptrdiff_t m_bPrecomputedFieldsValid = 0x146; // bool
    constexpr std::ptrdiff_t m_vPrecomputedBoundsMins = 0x148; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedBoundsMaxs = 0x154; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedOBBOrigin = 0x160; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedOBBAngles = 0x16C; // QAngle
    constexpr std::ptrdiff_t m_vPrecomputedOBBExtent = 0x178; // Vector
    constexpr std::ptrdiff_t m_flPrecomputedMaxRange = 0x184; // float
    constexpr std::ptrdiff_t m_nFogLightingMode = 0x188; // int32_t
    constexpr std::ptrdiff_t m_flFogContributionStength = 0x18C; // float
    constexpr std::ptrdiff_t m_flNearClipPlane = 0x190; // float
    constexpr std::ptrdiff_t m_SkyColor = 0x194; // Color
    constexpr std::ptrdiff_t m_flSkyIntensity = 0x198; // float
    constexpr std::ptrdiff_t m_SkyAmbientBounce = 0x19C; // Color
    constexpr std::ptrdiff_t m_bUseSecondaryColor = 0x1A0; // bool
    constexpr std::ptrdiff_t m_bMixedShadows = 0x1A1; // bool
    constexpr std::ptrdiff_t m_flLightStyleStartTime = 0x1A4; // GameTime_t
    constexpr std::ptrdiff_t m_flCapsuleLength = 0x1A8; // float
    constexpr std::ptrdiff_t m_flMinRoughness = 0x1AC; // float
}

namespace CLogicRelay {
    constexpr std::ptrdiff_t m_OnTrigger = 0x540; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnSpawn = 0x568; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bDisabled = 0x590; // bool
    constexpr std::ptrdiff_t m_bWaitForRefire = 0x591; // bool
    constexpr std::ptrdiff_t m_bTriggerOnce = 0x592; // bool
    constexpr std::ptrdiff_t m_bFastRetrigger = 0x593; // bool
    constexpr std::ptrdiff_t m_bPassthoughCaller = 0x594; // bool
}

namespace CModelState {
    constexpr std::ptrdiff_t m_hModel = 0xA0; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_ModelName = 0xA8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bClientClothCreationSuppressed = 0xE8; // bool
    constexpr std::ptrdiff_t m_MeshGroupMask = 0x180; // uint64_t
    constexpr std::ptrdiff_t m_nIdealMotionType = 0x222; // int8_t
    constexpr std::ptrdiff_t m_nForceLOD = 0x223; // int8_t
    constexpr std::ptrdiff_t m_nClothUpdateFlags = 0x224; // int8_t
}

namespace CNetworkedSequenceOperation {
    constexpr std::ptrdiff_t m_hSequence = 0x8; // HSequence
    constexpr std::ptrdiff_t m_flPrevCycle = 0xC; // float
    constexpr std::ptrdiff_t m_flCycle = 0x10; // float
    constexpr std::ptrdiff_t m_flWeight = 0x14; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_bSequenceChangeNetworked = 0x1C; // bool
    constexpr std::ptrdiff_t m_bDiscontinuity = 0x1D; // bool
    constexpr std::ptrdiff_t m_flPrevCycleFromDiscontinuity = 0x20; // float
    constexpr std::ptrdiff_t m_flPrevCycleForAnimEventDetection = 0x24; // float
}

namespace CPlayer_CameraServices {
    constexpr std::ptrdiff_t m_vecCsViewPunchAngle = 0x40; // QAngle
    constexpr std::ptrdiff_t m_nCsViewPunchAngleTick = 0x4C; // GameTick_t
    constexpr std::ptrdiff_t m_flCsViewPunchAngleTickRatio = 0x50; // float
    constexpr std::ptrdiff_t m_PlayerFog = 0x58; // C_fogplayerparams_t
    constexpr std::ptrdiff_t m_hColorCorrectionCtrl = 0x98; // CHandle<C_ColorCorrection>
    constexpr std::ptrdiff_t m_hViewEntity = 0x9C; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_hTonemapController = 0xA0; // CHandle<C_TonemapController2>
    constexpr std::ptrdiff_t m_audio = 0xA8; // audioparams_t
    constexpr std::ptrdiff_t m_PostProcessingVolumes = 0x120; // C_NetworkUtlVectorBase<CHandle<C_PostProcessingVolume>>
    constexpr std::ptrdiff_t m_flOldPlayerZ = 0x138; // float
    constexpr std::ptrdiff_t m_flOldPlayerViewOffsetZ = 0x13C; // float
    constexpr std::ptrdiff_t m_CurrentFog = 0x140; // fogparams_t
    constexpr std::ptrdiff_t m_hOldFogController = 0x1A8; // CHandle<C_FogController>
    constexpr std::ptrdiff_t m_bOverrideFogColor = 0x1AC; // bool[5]
    constexpr std::ptrdiff_t m_OverrideFogColor = 0x1B1; // Color[5]
    constexpr std::ptrdiff_t m_bOverrideFogStartEnd = 0x1C5; // bool[5]
    constexpr std::ptrdiff_t m_fOverrideFogStart = 0x1CC; // float[5]
    constexpr std::ptrdiff_t m_fOverrideFogEnd = 0x1E0; // float[5]
    constexpr std::ptrdiff_t m_hActivePostProcessingVolume = 0x1F4; // CHandle<C_PostProcessingVolume>
    constexpr std::ptrdiff_t m_angDemoViewAngles = 0x1F8; // QAngle
}

namespace CPlayer_MovementServices {
    constexpr std::ptrdiff_t m_nImpulse = 0x40; // int32_t
    constexpr std::ptrdiff_t m_nButtons = 0x48; // CInButtonState
    constexpr std::ptrdiff_t m_nQueuedButtonDownMask = 0x68; // uint64_t
    constexpr std::ptrdiff_t m_nQueuedButtonChangeMask = 0x70; // uint64_t
    constexpr std::ptrdiff_t m_nButtonDoublePressed = 0x78; // uint64_t
    constexpr std::ptrdiff_t m_pButtonPressedCmdNumber = 0x80; // uint32_t[64]
    constexpr std::ptrdiff_t m_nLastCommandNumberProcessed = 0x180; // uint32_t
    constexpr std::ptrdiff_t m_nToggleButtonDownMask = 0x188; // uint64_t
    constexpr std::ptrdiff_t m_flMaxspeed = 0x190; // float
    constexpr std::ptrdiff_t m_arrForceSubtickMoveWhen = 0x194; // float[4]
    constexpr std::ptrdiff_t m_flForwardMove = 0x1A4; // float
    constexpr std::ptrdiff_t m_flLeftMove = 0x1A8; // float
    constexpr std::ptrdiff_t m_flUpMove = 0x1AC; // float
    constexpr std::ptrdiff_t m_vecLastMovementImpulses = 0x1B0; // Vector
    constexpr std::ptrdiff_t m_vecOldViewAngles = 0x1BC; // QAngle
}

namespace CPlayer_MovementServices_Humanoid {
    constexpr std::ptrdiff_t m_flStepSoundTime = 0x1D0; // float
    constexpr std::ptrdiff_t m_flFallVelocity = 0x1D4; // float
    constexpr std::ptrdiff_t m_bInCrouch = 0x1D8; // bool
    constexpr std::ptrdiff_t m_nCrouchState = 0x1DC; // uint32_t
    constexpr std::ptrdiff_t m_flCrouchTransitionStartTime = 0x1E0; // GameTime_t
    constexpr std::ptrdiff_t m_bDucked = 0x1E4; // bool
    constexpr std::ptrdiff_t m_bDucking = 0x1E5; // bool
    constexpr std::ptrdiff_t m_bInDuckJump = 0x1E6; // bool
    constexpr std::ptrdiff_t m_groundNormal = 0x1E8; // Vector
    constexpr std::ptrdiff_t m_flSurfaceFriction = 0x1F4; // float
    constexpr std::ptrdiff_t m_surfaceProps = 0x1F8; // CUtlStringToken
    constexpr std::ptrdiff_t m_nStepside = 0x208; // int32_t
}

namespace CPlayer_ObserverServices {
    constexpr std::ptrdiff_t m_iObserverMode = 0x40; // uint8_t
    constexpr std::ptrdiff_t m_hObserverTarget = 0x44; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_iObserverLastMode = 0x48; // ObserverMode_t
    constexpr std::ptrdiff_t m_bForcedObserverMode = 0x4C; // bool
    constexpr std::ptrdiff_t m_flObserverChaseDistance = 0x50; // float
    constexpr std::ptrdiff_t m_flObserverChaseDistanceCalcTime = 0x54; // GameTime_t
}

namespace CPlayer_WeaponServices {
    constexpr std::ptrdiff_t m_bAllowSwitchToNoWeapon = 0x40; // bool
    constexpr std::ptrdiff_t m_hMyWeapons = 0x48; // C_NetworkUtlVectorBase<CHandle<C_BasePlayerWeapon>>
    constexpr std::ptrdiff_t m_hActiveWeapon = 0x60; // CHandle<C_BasePlayerWeapon>
    constexpr std::ptrdiff_t m_hLastWeapon = 0x64; // CHandle<C_BasePlayerWeapon>
    constexpr std::ptrdiff_t m_iAmmo = 0x68; // uint16_t[32]
}

namespace CPointOffScreenIndicatorUi {
    constexpr std::ptrdiff_t m_bBeenEnabled = 0xF20; // bool
    constexpr std::ptrdiff_t m_bHide = 0xF21; // bool
    constexpr std::ptrdiff_t m_flSeenTargetTime = 0xF24; // float
    constexpr std::ptrdiff_t m_pTargetPanel = 0xF28; // C_PointClientUIWorldPanel*
}

namespace CPointTemplate {
    constexpr std::ptrdiff_t m_iszWorldName = 0x540; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSource2EntityLumpName = 0x548; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszEntityFilterName = 0x550; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flTimeoutInterval = 0x558; // float
    constexpr std::ptrdiff_t m_bAsynchronouslySpawnEntities = 0x55C; // bool
    constexpr std::ptrdiff_t m_pOutputOnSpawned = 0x560; // CEntityIOOutput
    constexpr std::ptrdiff_t m_clientOnlyEntityBehavior = 0x588; // PointTemplateClientOnlyEntityBehavior_t
    constexpr std::ptrdiff_t m_ownerSpawnGroupType = 0x58C; // PointTemplateOwnerSpawnGroupType_t
    constexpr std::ptrdiff_t m_createdSpawnGroupHandles = 0x590; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_SpawnedEntityHandles = 0x5A8; // CUtlVector<CEntityHandle>
    constexpr std::ptrdiff_t m_ScriptSpawnCallback = 0x5C0; // HSCRIPT
    constexpr std::ptrdiff_t m_ScriptCallbackScope = 0x5C8; // HSCRIPT
}

namespace CPrecipitationVData {
    constexpr std::ptrdiff_t m_szParticlePrecipitationEffect = 0x28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_flInnerDistance = 0x108; // float
    constexpr std::ptrdiff_t m_nAttachType = 0x10C; // ParticleAttachment_t
    constexpr std::ptrdiff_t m_bBatchSameVolumeType = 0x110; // bool
    constexpr std::ptrdiff_t m_nRTEnvCP = 0x114; // int32_t
    constexpr std::ptrdiff_t m_nRTEnvCPComponent = 0x118; // int32_t
    constexpr std::ptrdiff_t m_szModifier = 0x120; // CUtlString
}

namespace CProjectedTextureBase {
    constexpr std::ptrdiff_t m_hTargetEntity = 0xC; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_bState = 0x10; // bool
    constexpr std::ptrdiff_t m_bAlwaysUpdate = 0x11; // bool
    constexpr std::ptrdiff_t m_flLightFOV = 0x14; // float
    constexpr std::ptrdiff_t m_bEnableShadows = 0x18; // bool
    constexpr std::ptrdiff_t m_bSimpleProjection = 0x19; // bool
    constexpr std::ptrdiff_t m_bLightOnlyTarget = 0x1A; // bool
    constexpr std::ptrdiff_t m_bLightWorld = 0x1B; // bool
    constexpr std::ptrdiff_t m_bCameraSpace = 0x1C; // bool
    constexpr std::ptrdiff_t m_flBrightnessScale = 0x20; // float
    constexpr std::ptrdiff_t m_LightColor = 0x24; // Color
    constexpr std::ptrdiff_t m_flIntensity = 0x28; // float
    constexpr std::ptrdiff_t m_flLinearAttenuation = 0x2C; // float
    constexpr std::ptrdiff_t m_flQuadraticAttenuation = 0x30; // float
    constexpr std::ptrdiff_t m_bVolumetric = 0x34; // bool
    constexpr std::ptrdiff_t m_flVolumetricIntensity = 0x38; // float
    constexpr std::ptrdiff_t m_flNoiseStrength = 0x3C; // float
    constexpr std::ptrdiff_t m_flFlashlightTime = 0x40; // float
    constexpr std::ptrdiff_t m_nNumPlanes = 0x44; // uint32_t
    constexpr std::ptrdiff_t m_flPlaneOffset = 0x48; // float
    constexpr std::ptrdiff_t m_flColorTransitionTime = 0x4C; // float
    constexpr std::ptrdiff_t m_flAmbient = 0x50; // float
    constexpr std::ptrdiff_t m_SpotlightTextureName = 0x54; // char[512]
    constexpr std::ptrdiff_t m_nSpotlightTextureFrame = 0x254; // int32_t
    constexpr std::ptrdiff_t m_nShadowQuality = 0x258; // uint32_t
    constexpr std::ptrdiff_t m_flNearZ = 0x25C; // float
    constexpr std::ptrdiff_t m_flFarZ = 0x260; // float
    constexpr std::ptrdiff_t m_flProjectionSize = 0x264; // float
    constexpr std::ptrdiff_t m_flRotation = 0x268; // float
    constexpr std::ptrdiff_t m_bFlipHorizontal = 0x26C; // bool
}

namespace CRenderComponent {
    constexpr std::ptrdiff_t __m_pChainEntity = 0x10; // CNetworkVarChainer
    constexpr std::ptrdiff_t m_bIsRenderingWithViewModels = 0x50; // bool
    constexpr std::ptrdiff_t m_nSplitscreenFlags = 0x54; // uint32_t
    constexpr std::ptrdiff_t m_bEnableRendering = 0x60; // bool
    constexpr std::ptrdiff_t m_bInterpolationReadyToDraw = 0xB0; // bool
}

namespace CSMatchStats_t {
    constexpr std::ptrdiff_t m_iEnemy5Ks = 0x68; // int32_t
    constexpr std::ptrdiff_t m_iEnemy4Ks = 0x6C; // int32_t
    constexpr std::ptrdiff_t m_iEnemy3Ks = 0x70; // int32_t
}

namespace CSPerRoundStats_t {
    constexpr std::ptrdiff_t m_iKills = 0x30; // int32_t
    constexpr std::ptrdiff_t m_iDeaths = 0x34; // int32_t
    constexpr std::ptrdiff_t m_iAssists = 0x38; // int32_t
    constexpr std::ptrdiff_t m_iDamage = 0x3C; // int32_t
    constexpr std::ptrdiff_t m_iEquipmentValue = 0x40; // int32_t
    constexpr std::ptrdiff_t m_iMoneySaved = 0x44; // int32_t
    constexpr std::ptrdiff_t m_iKillReward = 0x48; // int32_t
    constexpr std::ptrdiff_t m_iLiveTime = 0x4C; // int32_t
    constexpr std::ptrdiff_t m_iHeadShotKills = 0x50; // int32_t
    constexpr std::ptrdiff_t m_iObjective = 0x54; // int32_t
    constexpr std::ptrdiff_t m_iCashEarned = 0x58; // int32_t
    constexpr std::ptrdiff_t m_iUtilityDamage = 0x5C; // int32_t
    constexpr std::ptrdiff_t m_iEnemiesFlashed = 0x60; // int32_t
}

namespace CScriptComponent {
    constexpr std::ptrdiff_t m_scriptClassName = 0x30; // CUtlSymbolLarge
}

namespace CSkeletonInstance {
    constexpr std::ptrdiff_t m_modelState = 0x160; // CModelState
    constexpr std::ptrdiff_t m_bIsAnimationEnabled = 0x390; // bool
    constexpr std::ptrdiff_t m_bUseParentRenderBounds = 0x391; // bool
    constexpr std::ptrdiff_t m_bDisableSolidCollisionsForHierarchy = 0x392; // bool
    constexpr std::ptrdiff_t m_bDirtyMotionType = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bIsGeneratingLatchedParentSpaceState = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_materialGroup = 0x394; // CUtlStringToken
    constexpr std::ptrdiff_t m_nHitboxSet = 0x398; // uint8_t
}

namespace CSkyboxReference {
    constexpr std::ptrdiff_t m_worldGroupId = 0x540; // WorldGroupId_t
    constexpr std::ptrdiff_t m_hSkyCamera = 0x544; // CHandle<C_SkyCamera>
}

namespace CTimeline {
    constexpr std::ptrdiff_t m_flValues = 0x10; // float[64]
    constexpr std::ptrdiff_t m_nValueCounts = 0x110; // int32_t[64]
    constexpr std::ptrdiff_t m_nBucketCount = 0x210; // int32_t
    constexpr std::ptrdiff_t m_flInterval = 0x214; // float
    constexpr std::ptrdiff_t m_flFinalValue = 0x218; // float
    constexpr std::ptrdiff_t m_nCompressionType = 0x21C; // TimelineCompression_t
    constexpr std::ptrdiff_t m_bStopped = 0x220; // bool
}

namespace C_AttributeContainer {
    constexpr std::ptrdiff_t m_Item = 0x50; // C_EconItemView
    constexpr std::ptrdiff_t m_iExternalItemProviderRegisteredToken = 0x498; // int32_t
    constexpr std::ptrdiff_t m_ullRegisteredAsItemID = 0x4A0; // uint64_t
}

namespace C_BarnLight {
    constexpr std::ptrdiff_t m_bEnabled = 0xCC0; // bool
    constexpr std::ptrdiff_t m_nColorMode = 0xCC4; // int32_t
    constexpr std::ptrdiff_t m_Color = 0xCC8; // Color
    constexpr std::ptrdiff_t m_flColorTemperature = 0xCCC; // float
    constexpr std::ptrdiff_t m_flBrightness = 0xCD0; // float
    constexpr std::ptrdiff_t m_flBrightnessScale = 0xCD4; // float
    constexpr std::ptrdiff_t m_nDirectLight = 0xCD8; // int32_t
    constexpr std::ptrdiff_t m_nBakedShadowIndex = 0xCDC; // int32_t
    constexpr std::ptrdiff_t m_nLuminaireShape = 0xCE0; // int32_t
    constexpr std::ptrdiff_t m_flLuminaireSize = 0xCE4; // float
    constexpr std::ptrdiff_t m_flLuminaireAnisotropy = 0xCE8; // float
    constexpr std::ptrdiff_t m_LightStyleString = 0xCF0; // CUtlString
    constexpr std::ptrdiff_t m_flLightStyleStartTime = 0xCF8; // GameTime_t
    constexpr std::ptrdiff_t m_QueuedLightStyleStrings = 0xD00; // C_NetworkUtlVectorBase<CUtlString>
    constexpr std::ptrdiff_t m_LightStyleEvents = 0xD18; // C_NetworkUtlVectorBase<CUtlString>
    constexpr std::ptrdiff_t m_LightStyleTargets = 0xD30; // C_NetworkUtlVectorBase<CHandle<C_BaseModelEntity>>
    constexpr std::ptrdiff_t m_StyleEvent = 0xD48; // CEntityIOOutput[4]
    constexpr std::ptrdiff_t m_hLightCookie = 0xDE8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_flShape = 0xDF0; // float
    constexpr std::ptrdiff_t m_flSoftX = 0xDF4; // float
    constexpr std::ptrdiff_t m_flSoftY = 0xDF8; // float
    constexpr std::ptrdiff_t m_flSkirt = 0xDFC; // float
    constexpr std::ptrdiff_t m_flSkirtNear = 0xE00; // float
    constexpr std::ptrdiff_t m_vSizeParams = 0xE04; // Vector
    constexpr std::ptrdiff_t m_flRange = 0xE10; // float
    constexpr std::ptrdiff_t m_vShear = 0xE14; // Vector
    constexpr std::ptrdiff_t m_nBakeSpecularToCubemaps = 0xE20; // int32_t
    constexpr std::ptrdiff_t m_vBakeSpecularToCubemapsSize = 0xE24; // Vector
    constexpr std::ptrdiff_t m_nCastShadows = 0xE30; // int32_t
    constexpr std::ptrdiff_t m_nShadowMapSize = 0xE34; // int32_t
    constexpr std::ptrdiff_t m_nShadowPriority = 0xE38; // int32_t
    constexpr std::ptrdiff_t m_bContactShadow = 0xE3C; // bool
    constexpr std::ptrdiff_t m_nBounceLight = 0xE40; // int32_t
    constexpr std::ptrdiff_t m_flBounceScale = 0xE44; // float
    constexpr std::ptrdiff_t m_flMinRoughness = 0xE48; // float
    constexpr std::ptrdiff_t m_vAlternateColor = 0xE4C; // Vector
    constexpr std::ptrdiff_t m_fAlternateColorBrightness = 0xE58; // float
    constexpr std::ptrdiff_t m_nFog = 0xE5C; // int32_t
    constexpr std::ptrdiff_t m_flFogStrength = 0xE60; // float
    constexpr std::ptrdiff_t m_nFogShadows = 0xE64; // int32_t
    constexpr std::ptrdiff_t m_flFogScale = 0xE68; // float
    constexpr std::ptrdiff_t m_flFadeSizeStart = 0xE6C; // float
    constexpr std::ptrdiff_t m_flFadeSizeEnd = 0xE70; // float
    constexpr std::ptrdiff_t m_flShadowFadeSizeStart = 0xE74; // float
    constexpr std::ptrdiff_t m_flShadowFadeSizeEnd = 0xE78; // float
    constexpr std::ptrdiff_t m_bPrecomputedFieldsValid = 0xE7C; // bool
    constexpr std::ptrdiff_t m_vPrecomputedBoundsMins = 0xE80; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedBoundsMaxs = 0xE8C; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedOBBOrigin = 0xE98; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedOBBAngles = 0xEA4; // QAngle
    constexpr std::ptrdiff_t m_vPrecomputedOBBExtent = 0xEB0; // Vector
}

namespace C_BaseButton {
    constexpr std::ptrdiff_t m_glowEntity = 0xCC0; // CHandle<C_BaseModelEntity>
    constexpr std::ptrdiff_t m_usable = 0xCC4; // bool
    constexpr std::ptrdiff_t m_szDisplayText = 0xCC8; // CUtlSymbolLarge
}

namespace C_BaseCSGrenade {
    constexpr std::ptrdiff_t m_bClientPredictDelete = 0x19F0; // bool
    constexpr std::ptrdiff_t m_bRedraw = 0x19F1; // bool
    constexpr std::ptrdiff_t m_bIsHeldByPlayer = 0x19F2; // bool
    constexpr std::ptrdiff_t m_bPinPulled = 0x19F3; // bool
    constexpr std::ptrdiff_t m_bJumpThrow = 0x19F4; // bool
    constexpr std::ptrdiff_t m_eThrowStatus = 0x19F8; // EGrenadeThrowState
    constexpr std::ptrdiff_t m_fThrowTime = 0x19FC; // GameTime_t
    constexpr std::ptrdiff_t m_flThrowStrength = 0x1A00; // float
    constexpr std::ptrdiff_t m_flThrowStrengthApproach = 0x1A04; // float
    constexpr std::ptrdiff_t m_fDropTime = 0x1A08; // GameTime_t
}

namespace C_BaseCSGrenadeProjectile {
    constexpr std::ptrdiff_t m_vInitialPosition = 0x1068; // Vector
    constexpr std::ptrdiff_t m_vInitialVelocity = 0x1074; // Vector
    constexpr std::ptrdiff_t m_nBounces = 0x1080; // int32_t
    constexpr std::ptrdiff_t m_nExplodeEffectIndex = 0x1088; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_nExplodeEffectTickBegin = 0x1090; // int32_t
    constexpr std::ptrdiff_t m_vecExplodeEffectOrigin = 0x1094; // Vector
    constexpr std::ptrdiff_t m_flSpawnTime = 0x10A0; // GameTime_t
    constexpr std::ptrdiff_t vecLastTrailLinePos = 0x10A4; // Vector
    constexpr std::ptrdiff_t flNextTrailLineTime = 0x10B0; // GameTime_t
    constexpr std::ptrdiff_t m_bExplodeEffectBegan = 0x10B4; // bool
    constexpr std::ptrdiff_t m_bCanCreateGrenadeTrail = 0x10B5; // bool
    constexpr std::ptrdiff_t m_nSnapshotTrajectoryEffectIndex = 0x10B8; // ParticleIndex_t
    constexpr std::ptrdiff_t m_hSnapshotTrajectoryParticleSnapshot = 0x10C0; // CStrongHandle<InfoForResourceTypeIParticleSnapshot>
    constexpr std::ptrdiff_t m_arrTrajectoryTrailPoints = 0x10C8; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_arrTrajectoryTrailPointCreationTimes = 0x10E0; // CUtlVector<float>
    constexpr std::ptrdiff_t m_flTrajectoryTrailEffectCreationTime = 0x10F8; // float
}

namespace C_BaseClientUIEntity {
    constexpr std::ptrdiff_t m_bEnabled = 0xCC8; // bool
    constexpr std::ptrdiff_t m_DialogXMLName = 0xCD0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_PanelClassName = 0xCD8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_PanelID = 0xCE0; // CUtlSymbolLarge
}

namespace C_BaseCombatCharacter {
    constexpr std::ptrdiff_t m_hMyWearables = 0x1018; // C_NetworkUtlVectorBase<CHandle<C_EconWearable>>
    constexpr std::ptrdiff_t m_bloodColor = 0x1030; // int32_t
    constexpr std::ptrdiff_t m_leftFootAttachment = 0x1034; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_rightFootAttachment = 0x1035; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_nWaterWakeMode = 0x1038; // C_BaseCombatCharacter::WaterWakeMode_t
    constexpr std::ptrdiff_t m_flWaterWorldZ = 0x103C; // float
    constexpr std::ptrdiff_t m_flWaterNextTraceTime = 0x1040; // float
    constexpr std::ptrdiff_t m_flFieldOfView = 0x1044; // float
}

namespace C_BaseDoor {
    constexpr std::ptrdiff_t m_bIsUsable = 0xCC0; // bool
}

namespace C_BaseEntity {
    constexpr std::ptrdiff_t m_CBodyComponent = 0x30; // CBodyComponent*
    constexpr std::ptrdiff_t m_NetworkTransmitComponent = 0x38; // CNetworkTransmitComponent
    constexpr std::ptrdiff_t m_nLastThinkTick = 0x308; // GameTick_t
    constexpr std::ptrdiff_t m_pGameSceneNode = 0x310; // CGameSceneNode*
    constexpr std::ptrdiff_t m_pRenderComponent = 0x318; // CRenderComponent*
    constexpr std::ptrdiff_t m_pCollision = 0x320; // CCollisionProperty*
    constexpr std::ptrdiff_t m_iMaxHealth = 0x328; // int32_t
    constexpr std::ptrdiff_t m_iHealth = 0x32C; // int32_t
    constexpr std::ptrdiff_t m_lifeState = 0x330; // uint8_t
    constexpr std::ptrdiff_t m_bTakesDamage = 0x331; // bool
    constexpr std::ptrdiff_t m_nTakeDamageFlags = 0x334; // TakeDamageFlags_t
    constexpr std::ptrdiff_t m_ubInterpolationFrame = 0x338; // uint8_t
    constexpr std::ptrdiff_t m_hSceneObjectController = 0x33C; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_nNoInterpolationTick = 0x340; // int32_t
    constexpr std::ptrdiff_t m_nVisibilityNoInterpolationTick = 0x344; // int32_t
    constexpr std::ptrdiff_t m_flProxyRandomValue = 0x348; // float
    constexpr std::ptrdiff_t m_iEFlags = 0x34C; // int32_t
    constexpr std::ptrdiff_t m_nWaterType = 0x350; // uint8_t
    constexpr std::ptrdiff_t m_bInterpolateEvenWithNoModel = 0x351; // bool
    constexpr std::ptrdiff_t m_bPredictionEligible = 0x352; // bool
    constexpr std::ptrdiff_t m_bApplyLayerMatchIDToModel = 0x353; // bool
    constexpr std::ptrdiff_t m_tokLayerMatchID = 0x354; // CUtlStringToken
    constexpr std::ptrdiff_t m_nSubclassID = 0x358; // CUtlStringToken
    constexpr std::ptrdiff_t m_nSimulationTick = 0x368; // int32_t
    constexpr std::ptrdiff_t m_iCurrentThinkContext = 0x36C; // int32_t
    constexpr std::ptrdiff_t m_aThinkFunctions = 0x370; // CUtlVector<thinkfunc_t>
    constexpr std::ptrdiff_t m_flAnimTime = 0x388; // float
    constexpr std::ptrdiff_t m_flSimulationTime = 0x38C; // float
    constexpr std::ptrdiff_t m_nSceneObjectOverrideFlags = 0x390; // uint8_t
    constexpr std::ptrdiff_t m_bHasSuccessfullyInterpolated = 0x391; // bool
    constexpr std::ptrdiff_t m_bHasAddedVarsToInterpolation = 0x392; // bool
    constexpr std::ptrdiff_t m_bRenderEvenWhenNotSuccessfullyInterpolated = 0x393; // bool
    constexpr std::ptrdiff_t m_nInterpolationLatchDirtyFlags = 0x394; // int32_t[2]
    constexpr std::ptrdiff_t m_ListEntry = 0x39C; // uint16_t[11]
    constexpr std::ptrdiff_t m_flCreateTime = 0x3B4; // GameTime_t
    constexpr std::ptrdiff_t m_flSpeed = 0x3B8; // float
    constexpr std::ptrdiff_t m_EntClientFlags = 0x3BC; // uint16_t
    constexpr std::ptrdiff_t m_bClientSideRagdoll = 0x3BE; // bool
    constexpr std::ptrdiff_t m_iTeamNum = 0x3BF; // uint8_t
    constexpr std::ptrdiff_t m_spawnflags = 0x3C0; // uint32_t
    constexpr std::ptrdiff_t m_nNextThinkTick = 0x3C4; // GameTick_t
    constexpr std::ptrdiff_t m_fFlags = 0x3C8; // uint32_t
    constexpr std::ptrdiff_t m_vecAbsVelocity = 0x3CC; // Vector
    constexpr std::ptrdiff_t m_vecVelocity = 0x3D8; // CNetworkVelocityVector
    constexpr std::ptrdiff_t m_vecBaseVelocity = 0x408; // Vector
    constexpr std::ptrdiff_t m_hEffectEntity = 0x414; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_hOwnerEntity = 0x418; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_MoveCollide = 0x41C; // MoveCollide_t
    constexpr std::ptrdiff_t m_MoveType = 0x41D; // MoveType_t
    constexpr std::ptrdiff_t m_flWaterLevel = 0x420; // float
    constexpr std::ptrdiff_t m_fEffects = 0x424; // uint32_t
    constexpr std::ptrdiff_t m_hGroundEntity = 0x428; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_flFriction = 0x42C; // float
    constexpr std::ptrdiff_t m_flElasticity = 0x430; // float
    constexpr std::ptrdiff_t m_flGravityScale = 0x434; // float
    constexpr std::ptrdiff_t m_flTimeScale = 0x438; // float
    constexpr std::ptrdiff_t m_bSimulatedEveryTick = 0x43C; // bool
    constexpr std::ptrdiff_t m_bAnimatedEveryTick = 0x43D; // bool
    constexpr std::ptrdiff_t m_flNavIgnoreUntilTime = 0x440; // GameTime_t
    constexpr std::ptrdiff_t m_hThink = 0x444; // uint16_t
    constexpr std::ptrdiff_t m_fBBoxVisFlags = 0x450; // uint8_t
    constexpr std::ptrdiff_t m_bPredictable = 0x451; // bool
    constexpr std::ptrdiff_t m_bRenderWithViewModels = 0x452; // bool
    constexpr std::ptrdiff_t m_nSplitUserPlayerPredictionSlot = 0x454; // CSplitScreenSlot
    constexpr std::ptrdiff_t m_nFirstPredictableCommand = 0x458; // int32_t
    constexpr std::ptrdiff_t m_nLastPredictableCommand = 0x45C; // int32_t
    constexpr std::ptrdiff_t m_hOldMoveParent = 0x460; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_Particles = 0x468; // CParticleProperty
    constexpr std::ptrdiff_t m_vecPredictedScriptFloats = 0x490; // CUtlVector<float>
    constexpr std::ptrdiff_t m_vecPredictedScriptFloatIDs = 0x4A8; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_nNextScriptVarRecordID = 0x4D8; // int32_t
    constexpr std::ptrdiff_t m_vecAngVelocity = 0x4E8; // QAngle
    constexpr std::ptrdiff_t m_DataChangeEventRef = 0x4F4; // int32_t
    constexpr std::ptrdiff_t m_dependencies = 0x4F8; // CUtlVector<CEntityHandle>
    constexpr std::ptrdiff_t m_nCreationTick = 0x510; // int32_t
    constexpr std::ptrdiff_t m_bAnimTimeChanged = 0x529; // bool
    constexpr std::ptrdiff_t m_bSimulationTimeChanged = 0x52A; // bool
    constexpr std::ptrdiff_t m_sUniqueHammerID = 0x538; // CUtlString
}

namespace C_BaseFire {
    constexpr std::ptrdiff_t m_flScale = 0x540; // float
    constexpr std::ptrdiff_t m_flStartScale = 0x544; // float
    constexpr std::ptrdiff_t m_flScaleTime = 0x548; // float
    constexpr std::ptrdiff_t m_nFlags = 0x54C; // uint32_t
}

namespace C_BaseFlex {
    constexpr std::ptrdiff_t m_flexWeight = 0xE90; // C_NetworkUtlVectorBase<float>
    constexpr std::ptrdiff_t m_vLookTargetPosition = 0xEA8; // Vector
    constexpr std::ptrdiff_t m_blinktoggle = 0xEC0; // bool
    constexpr std::ptrdiff_t m_nLastFlexUpdateFrameCount = 0xF20; // int32_t
    constexpr std::ptrdiff_t m_CachedViewTarget = 0xF24; // Vector
    constexpr std::ptrdiff_t m_nNextSceneEventId = 0xF30; // uint32_t
    constexpr std::ptrdiff_t m_iBlink = 0xF34; // int32_t
    constexpr std::ptrdiff_t m_blinktime = 0xF38; // float
    constexpr std::ptrdiff_t m_prevblinktoggle = 0xF3C; // bool
    constexpr std::ptrdiff_t m_iJawOpen = 0xF40; // int32_t
    constexpr std::ptrdiff_t m_flJawOpenAmount = 0xF44; // float
    constexpr std::ptrdiff_t m_flBlinkAmount = 0xF48; // float
    constexpr std::ptrdiff_t m_iMouthAttachment = 0xF4C; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_iEyeAttachment = 0xF4D; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_bResetFlexWeightsOnModelChange = 0xF4E; // bool
    constexpr std::ptrdiff_t m_nEyeOcclusionRendererBone = 0xF68; // int32_t
    constexpr std::ptrdiff_t m_mEyeOcclusionRendererCameraToBoneTransform = 0xF6C; // matrix3x4_t
    constexpr std::ptrdiff_t m_vEyeOcclusionRendererHalfExtent = 0xF9C; // Vector
    constexpr std::ptrdiff_t m_PhonemeClasses = 0xFB8; // C_BaseFlex::Emphasized_Phoneme[3]
}

namespace C_BaseFlex_Emphasized_Phoneme {
    constexpr std::ptrdiff_t m_sClassName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_flAmount = 0x18; // float
    constexpr std::ptrdiff_t m_bRequired = 0x1C; // bool
    constexpr std::ptrdiff_t m_bBasechecked = 0x1D; // bool
    constexpr std::ptrdiff_t m_bValid = 0x1E; // bool
}

namespace C_BaseGrenade {
    constexpr std::ptrdiff_t m_bHasWarnedAI = 0x1018; // bool
    constexpr std::ptrdiff_t m_bIsSmokeGrenade = 0x1019; // bool
    constexpr std::ptrdiff_t m_bIsLive = 0x101A; // bool
    constexpr std::ptrdiff_t m_DmgRadius = 0x101C; // float
    constexpr std::ptrdiff_t m_flDetonateTime = 0x1020; // GameTime_t
    constexpr std::ptrdiff_t m_flWarnAITime = 0x1024; // float
    constexpr std::ptrdiff_t m_flDamage = 0x1028; // float
    constexpr std::ptrdiff_t m_iszBounceSound = 0x1030; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_ExplosionSound = 0x1038; // CUtlString
    constexpr std::ptrdiff_t m_hThrower = 0x1044; // CHandle<C_CSPlayerPawn>
    constexpr std::ptrdiff_t m_flNextAttack = 0x105C; // GameTime_t
    constexpr std::ptrdiff_t m_hOriginalThrower = 0x1060; // CHandle<C_CSPlayerPawn>
}

namespace C_BaseModelEntity {
    constexpr std::ptrdiff_t m_CRenderComponent = 0xA10; // CRenderComponent*
    constexpr std::ptrdiff_t m_CHitboxComponent = 0xA18; // CHitboxComponent
    constexpr std::ptrdiff_t m_bInitModelEffects = 0xA60; // bool
    constexpr std::ptrdiff_t m_bIsStaticProp = 0xA61; // bool
    constexpr std::ptrdiff_t m_nLastAddDecal = 0xA64; // int32_t
    constexpr std::ptrdiff_t m_nDecalsAdded = 0xA68; // int32_t
    constexpr std::ptrdiff_t m_iOldHealth = 0xA6C; // int32_t
    constexpr std::ptrdiff_t m_nRenderMode = 0xA70; // RenderMode_t
    constexpr std::ptrdiff_t m_nRenderFX = 0xA71; // RenderFx_t
    constexpr std::ptrdiff_t m_bAllowFadeInView = 0xA72; // bool
    constexpr std::ptrdiff_t m_clrRender = 0xA73; // Color
    constexpr std::ptrdiff_t m_vecRenderAttributes = 0xA78; // C_UtlVectorEmbeddedNetworkVar<EntityRenderAttribute_t>
    constexpr std::ptrdiff_t m_bRenderToCubemaps = 0xAE0; // bool
    constexpr std::ptrdiff_t m_Collision = 0xAE8; // CCollisionProperty
    constexpr std::ptrdiff_t m_Glow = 0xB98; // CGlowProperty
    constexpr std::ptrdiff_t m_flGlowBackfaceMult = 0xBF0; // float
    constexpr std::ptrdiff_t m_fadeMinDist = 0xBF4; // float
    constexpr std::ptrdiff_t m_fadeMaxDist = 0xBF8; // float
    constexpr std::ptrdiff_t m_flFadeScale = 0xBFC; // float
    constexpr std::ptrdiff_t m_flShadowStrength = 0xC00; // float
    constexpr std::ptrdiff_t m_nObjectCulling = 0xC04; // uint8_t
    constexpr std::ptrdiff_t m_nAddDecal = 0xC08; // int32_t
    constexpr std::ptrdiff_t m_vDecalPosition = 0xC0C; // Vector
    constexpr std::ptrdiff_t m_vDecalForwardAxis = 0xC18; // Vector
    constexpr std::ptrdiff_t m_flDecalHealBloodRate = 0xC24; // float
    constexpr std::ptrdiff_t m_flDecalHealHeightRate = 0xC28; // float
    constexpr std::ptrdiff_t m_ConfigEntitiesToPropagateMaterialDecalsTo = 0xC30; // C_NetworkUtlVectorBase<CHandle<C_BaseModelEntity>>
    constexpr std::ptrdiff_t m_vecViewOffset = 0xC48; // CNetworkViewOffsetVector
    constexpr std::ptrdiff_t m_pClientAlphaProperty = 0xC78; // CClientAlphaProperty*
    constexpr std::ptrdiff_t m_ClientOverrideTint = 0xC80; // Color
    constexpr std::ptrdiff_t m_bUseClientOverrideTint = 0xC84; // bool
}

namespace C_BasePlayerPawn {
    constexpr std::ptrdiff_t m_pWeaponServices = 0x10A8; // CPlayer_WeaponServices*
    constexpr std::ptrdiff_t m_pItemServices = 0x10B0; // CPlayer_ItemServices*
    constexpr std::ptrdiff_t m_pAutoaimServices = 0x10B8; // CPlayer_AutoaimServices*
    constexpr std::ptrdiff_t m_pObserverServices = 0x10C0; // CPlayer_ObserverServices*
    constexpr std::ptrdiff_t m_pWaterServices = 0x10C8; // CPlayer_WaterServices*
    constexpr std::ptrdiff_t m_pUseServices = 0x10D0; // CPlayer_UseServices*
    constexpr std::ptrdiff_t m_pFlashlightServices = 0x10D8; // CPlayer_FlashlightServices*
    constexpr std::ptrdiff_t m_pCameraServices = 0x10E0; // CPlayer_CameraServices*
    constexpr std::ptrdiff_t m_pMovementServices = 0x10E8; // CPlayer_MovementServices*
    constexpr std::ptrdiff_t m_ServerViewAngleChanges = 0x10F8; // C_UtlVectorEmbeddedNetworkVar<ViewAngleServerChange_t>
    constexpr std::ptrdiff_t m_nHighestConsumedServerViewAngleChangeIndex = 0x1148; // uint32_t
    constexpr std::ptrdiff_t v_angle = 0x114C; // QAngle
    constexpr std::ptrdiff_t v_anglePrevious = 0x1158; // QAngle
    constexpr std::ptrdiff_t m_iHideHUD = 0x1164; // uint32_t
    constexpr std::ptrdiff_t m_skybox3d = 0x1168; // sky3dparams_t
    constexpr std::ptrdiff_t m_flDeathTime = 0x11F8; // GameTime_t
    constexpr std::ptrdiff_t m_vecPredictionError = 0x11FC; // Vector
    constexpr std::ptrdiff_t m_flPredictionErrorTime = 0x1208; // GameTime_t
    constexpr std::ptrdiff_t m_vecLastCameraSetupLocalOrigin = 0x120C; // Vector
    constexpr std::ptrdiff_t m_flLastCameraSetupTime = 0x1218; // GameTime_t
    constexpr std::ptrdiff_t m_flFOVSensitivityAdjust = 0x121C; // float
    constexpr std::ptrdiff_t m_flMouseSensitivity = 0x1220; // float
    constexpr std::ptrdiff_t m_vOldOrigin = 0x1224; // Vector
    constexpr std::ptrdiff_t m_flOldSimulationTime = 0x1230; // float
    constexpr std::ptrdiff_t m_nLastExecutedCommandNumber = 0x1234; // int32_t
    constexpr std::ptrdiff_t m_nLastExecutedCommandTick = 0x1238; // int32_t
    constexpr std::ptrdiff_t m_hController = 0x123C; // CHandle<CBasePlayerController>
    constexpr std::ptrdiff_t m_bIsSwappingToPredictableController = 0x1240; // bool
}

namespace C_BasePlayerWeapon {
    constexpr std::ptrdiff_t m_nNextPrimaryAttackTick = 0x1560; // GameTick_t
    constexpr std::ptrdiff_t m_flNextPrimaryAttackTickRatio = 0x1564; // float
    constexpr std::ptrdiff_t m_nNextSecondaryAttackTick = 0x1568; // GameTick_t
    constexpr std::ptrdiff_t m_flNextSecondaryAttackTickRatio = 0x156C; // float
    constexpr std::ptrdiff_t m_iClip1 = 0x1570; // int32_t
    constexpr std::ptrdiff_t m_iClip2 = 0x1574; // int32_t
    constexpr std::ptrdiff_t m_pReserveAmmo = 0x1578; // int32_t[2]
}

namespace C_BasePropDoor {
    constexpr std::ptrdiff_t m_eDoorState = 0x10F8; // DoorState_t
    constexpr std::ptrdiff_t m_modelChanged = 0x10FC; // bool
    constexpr std::ptrdiff_t m_bLocked = 0x10FD; // bool
    constexpr std::ptrdiff_t m_closedPosition = 0x1100; // Vector
    constexpr std::ptrdiff_t m_closedAngles = 0x110C; // QAngle
    constexpr std::ptrdiff_t m_hMaster = 0x1118; // CHandle<C_BasePropDoor>
    constexpr std::ptrdiff_t m_vWhereToSetLightingOrigin = 0x111C; // Vector
}

namespace C_BaseTrigger {
    constexpr std::ptrdiff_t m_bDisabled = 0xCC0; // bool
    constexpr std::ptrdiff_t m_bClientSidePredicted = 0xCC1; // bool
}

namespace C_BaseViewModel {
    constexpr std::ptrdiff_t m_vecLastFacing = 0xE88; // Vector
    constexpr std::ptrdiff_t m_nViewModelIndex = 0xE94; // uint32_t
    constexpr std::ptrdiff_t m_nAnimationParity = 0xE98; // uint32_t
    constexpr std::ptrdiff_t m_flAnimationStartTime = 0xE9C; // float
    constexpr std::ptrdiff_t m_hWeapon = 0xEA0; // CHandle<C_BasePlayerWeapon>
    constexpr std::ptrdiff_t m_sVMName = 0xEA8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_sAnimationPrefix = 0xEB0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hWeaponModel = 0xEB8; // CHandle<C_ViewmodelWeapon>
    constexpr std::ptrdiff_t m_iCameraAttachment = 0xEBC; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_vecLastCameraAngles = 0xEC0; // QAngle
    constexpr std::ptrdiff_t m_previousElapsedDuration = 0xECC; // float
    constexpr std::ptrdiff_t m_previousCycle = 0xED0; // float
    constexpr std::ptrdiff_t m_nOldAnimationParity = 0xED4; // int32_t
    constexpr std::ptrdiff_t m_hOldLayerSequence = 0xED8; // HSequence
    constexpr std::ptrdiff_t m_oldLayer = 0xEDC; // int32_t
    constexpr std::ptrdiff_t m_oldLayerStartTime = 0xEE0; // float
    constexpr std::ptrdiff_t m_hControlPanel = 0xEE4; // CHandle<C_BaseEntity>
}

namespace C_Beam {
    constexpr std::ptrdiff_t m_flFrameRate = 0xCC0; // float
    constexpr std::ptrdiff_t m_flHDRColorScale = 0xCC4; // float
    constexpr std::ptrdiff_t m_flFireTime = 0xCC8; // GameTime_t
    constexpr std::ptrdiff_t m_flDamage = 0xCCC; // float
    constexpr std::ptrdiff_t m_nNumBeamEnts = 0xCD0; // uint8_t
    constexpr std::ptrdiff_t m_queryHandleHalo = 0xCD4; // int32_t
    constexpr std::ptrdiff_t m_hBaseMaterial = 0xCF8; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_nHaloIndex = 0xD00; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_nBeamType = 0xD08; // BeamType_t
    constexpr std::ptrdiff_t m_nBeamFlags = 0xD0C; // uint32_t
    constexpr std::ptrdiff_t m_hAttachEntity = 0xD10; // CHandle<C_BaseEntity>[10]
    constexpr std::ptrdiff_t m_nAttachIndex = 0xD38; // AttachmentHandle_t[10]
    constexpr std::ptrdiff_t m_fWidth = 0xD44; // float
    constexpr std::ptrdiff_t m_fEndWidth = 0xD48; // float
    constexpr std::ptrdiff_t m_fFadeLength = 0xD4C; // float
    constexpr std::ptrdiff_t m_fHaloScale = 0xD50; // float
    constexpr std::ptrdiff_t m_fAmplitude = 0xD54; // float
    constexpr std::ptrdiff_t m_fStartFrame = 0xD58; // float
    constexpr std::ptrdiff_t m_fSpeed = 0xD5C; // float
    constexpr std::ptrdiff_t m_flFrame = 0xD60; // float
    constexpr std::ptrdiff_t m_nClipStyle = 0xD64; // BeamClipStyle_t
    constexpr std::ptrdiff_t m_bTurnedOff = 0xD68; // bool
    constexpr std::ptrdiff_t m_vecEndPos = 0xD6C; // Vector
    constexpr std::ptrdiff_t m_hEndEntity = 0xD78; // CHandle<C_BaseEntity>
}

namespace C_BreakableProp {
    constexpr std::ptrdiff_t m_OnBreak = 0xEC8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnHealthChanged = 0xEF0; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnTakeDamage = 0xF18; // CEntityIOOutput
    constexpr std::ptrdiff_t m_impactEnergyScale = 0xF40; // float
    constexpr std::ptrdiff_t m_iMinHealthDmg = 0xF44; // int32_t
    constexpr std::ptrdiff_t m_flPressureDelay = 0xF48; // float
    constexpr std::ptrdiff_t m_hBreaker = 0xF4C; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_PerformanceMode = 0xF50; // PerformanceMode_t
    constexpr std::ptrdiff_t m_flDmgModBullet = 0xF54; // float
    constexpr std::ptrdiff_t m_flDmgModClub = 0xF58; // float
    constexpr std::ptrdiff_t m_flDmgModExplosive = 0xF5C; // float
    constexpr std::ptrdiff_t m_flDmgModFire = 0xF60; // float
    constexpr std::ptrdiff_t m_iszPhysicsDamageTableName = 0xF68; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszBasePropData = 0xF70; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iInteractions = 0xF78; // int32_t
    constexpr std::ptrdiff_t m_flPreventDamageBeforeTime = 0xF7C; // GameTime_t
    constexpr std::ptrdiff_t m_bHasBreakPiecesOrCommands = 0xF80; // bool
    constexpr std::ptrdiff_t m_explodeDamage = 0xF84; // float
    constexpr std::ptrdiff_t m_explodeRadius = 0xF88; // float
    constexpr std::ptrdiff_t m_explosionDelay = 0xF90; // float
    constexpr std::ptrdiff_t m_explosionBuildupSound = 0xF98; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_explosionCustomEffect = 0xFA0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_explosionCustomSound = 0xFA8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_explosionModifier = 0xFB0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hPhysicsAttacker = 0xFB8; // CHandle<C_BasePlayerPawn>
    constexpr std::ptrdiff_t m_flLastPhysicsInfluenceTime = 0xFBC; // GameTime_t
    constexpr std::ptrdiff_t m_flDefaultFadeScale = 0xFC0; // float
    constexpr std::ptrdiff_t m_hLastAttacker = 0xFC4; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_hFlareEnt = 0xFC8; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_noGhostCollision = 0xFCC; // bool
}

namespace C_BulletHitModel {
    constexpr std::ptrdiff_t m_matLocal = 0xE80; // matrix3x4_t
    constexpr std::ptrdiff_t m_iBoneIndex = 0xEB0; // int32_t
    constexpr std::ptrdiff_t m_hPlayerParent = 0xEB4; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_bIsHit = 0xEB8; // bool
    constexpr std::ptrdiff_t m_flTimeCreated = 0xEBC; // float
    constexpr std::ptrdiff_t m_vecStartPos = 0xEC0; // Vector
}

namespace C_C4 {
    constexpr std::ptrdiff_t m_szScreenText = 0x19F0; // char[32]
    constexpr std::ptrdiff_t m_activeLightParticleIndex = 0x1A10; // ParticleIndex_t
    constexpr std::ptrdiff_t m_eActiveLightEffect = 0x1A14; // C4LightEffect_t
    constexpr std::ptrdiff_t m_bStartedArming = 0x1A18; // bool
    constexpr std::ptrdiff_t m_fArmedTime = 0x1A1C; // GameTime_t
    constexpr std::ptrdiff_t m_bBombPlacedAnimation = 0x1A20; // bool
    constexpr std::ptrdiff_t m_bIsPlantingViaUse = 0x1A21; // bool
    constexpr std::ptrdiff_t m_entitySpottedState = 0x1A28; // EntitySpottedState_t
    constexpr std::ptrdiff_t m_nSpotRules = 0x1A40; // int32_t
    constexpr std::ptrdiff_t m_bPlayedArmingBeeps = 0x1A44; // bool[7]
    constexpr std::ptrdiff_t m_bBombPlanted = 0x1A4B; // bool
    constexpr std::ptrdiff_t m_bDroppedFromDeath = 0x1A4C; // bool
}

namespace C_CSGOViewModel {
    constexpr std::ptrdiff_t m_bShouldIgnoreOffsetAndAccuracy = 0xF10; // bool
    constexpr std::ptrdiff_t m_nWeaponParity = 0xF14; // uint32_t
    constexpr std::ptrdiff_t m_nOldWeaponParity = 0xF18; // uint32_t
    constexpr std::ptrdiff_t m_nLastKnownAssociatedWeaponEntIndex = 0xF1C; // CEntityIndex
    constexpr std::ptrdiff_t m_bNeedToQueueHighResComposite = 0xF20; // bool
    constexpr std::ptrdiff_t m_vLoweredWeaponOffset = 0xF64; // QAngle
}

namespace C_CSGO_MapPreviewCameraPath {
    constexpr std::ptrdiff_t m_flZFar = 0x540; // float
    constexpr std::ptrdiff_t m_flZNear = 0x544; // float
    constexpr std::ptrdiff_t m_bLoop = 0x548; // bool
    constexpr std::ptrdiff_t m_bVerticalFOV = 0x549; // bool
    constexpr std::ptrdiff_t m_bConstantSpeed = 0x54A; // bool
    constexpr std::ptrdiff_t m_flDuration = 0x54C; // float
    constexpr std::ptrdiff_t m_flPathLength = 0x590; // float
    constexpr std::ptrdiff_t m_flPathDuration = 0x594; // float
}

namespace C_CSGO_MapPreviewCameraPathNode {
    constexpr std::ptrdiff_t m_szParentPathUniqueID = 0x540; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nPathIndex = 0x548; // int32_t
    constexpr std::ptrdiff_t m_vInTangentLocal = 0x54C; // Vector
    constexpr std::ptrdiff_t m_vOutTangentLocal = 0x558; // Vector
    constexpr std::ptrdiff_t m_flFOV = 0x564; // float
    constexpr std::ptrdiff_t m_flSpeed = 0x568; // float
    constexpr std::ptrdiff_t m_flEaseIn = 0x56C; // float
    constexpr std::ptrdiff_t m_flEaseOut = 0x570; // float
    constexpr std::ptrdiff_t m_vInTangentWorld = 0x574; // Vector
    constexpr std::ptrdiff_t m_vOutTangentWorld = 0x580; // Vector
}

namespace C_CSGO_PreviewModel {
    constexpr std::ptrdiff_t m_animgraph = 0x1018; // CUtlString
    constexpr std::ptrdiff_t m_animgraphCharacterModeString = 0x1020; // CUtlString
    constexpr std::ptrdiff_t m_defaultAnim = 0x1028; // CUtlString
    constexpr std::ptrdiff_t m_nDefaultAnimLoopMode = 0x1030; // AnimLoopMode_t
    constexpr std::ptrdiff_t m_flInitialModelScale = 0x1034; // float
}

namespace C_CSGO_PreviewPlayer {
    constexpr std::ptrdiff_t m_animgraph = 0x22E8; // CUtlString
    constexpr std::ptrdiff_t m_animgraphCharacterModeString = 0x22F0; // CUtlString
    constexpr std::ptrdiff_t m_flInitialModelScale = 0x22F8; // float
}

namespace C_CSGO_TeamPreviewCamera {
    constexpr std::ptrdiff_t m_nVariant = 0x5A0; // int32_t
    constexpr std::ptrdiff_t m_bDofEnabled = 0x5A4; // bool
    constexpr std::ptrdiff_t m_flDofNearBlurry = 0x5A8; // float
    constexpr std::ptrdiff_t m_flDofNearCrisp = 0x5AC; // float
    constexpr std::ptrdiff_t m_flDofFarCrisp = 0x5B0; // float
    constexpr std::ptrdiff_t m_flDofFarBlurry = 0x5B4; // float
    constexpr std::ptrdiff_t m_flDofTiltToGround = 0x5B8; // float
}

namespace C_CSGO_TeamPreviewCharacterPosition {
    constexpr std::ptrdiff_t m_nVariant = 0x540; // int32_t
    constexpr std::ptrdiff_t m_nRandom = 0x544; // int32_t
    constexpr std::ptrdiff_t m_nOrdinal = 0x548; // int32_t
    constexpr std::ptrdiff_t m_sWeaponName = 0x550; // CUtlString
    constexpr std::ptrdiff_t m_xuid = 0x558; // uint64_t
    constexpr std::ptrdiff_t m_agentItem = 0x560; // C_EconItemView
    constexpr std::ptrdiff_t m_glovesItem = 0x9A8; // C_EconItemView
    constexpr std::ptrdiff_t m_weaponItem = 0xDF0; // C_EconItemView
}

namespace C_CSGameRules {
    constexpr std::ptrdiff_t __m_pChainEntity = 0x8; // CNetworkVarChainer
    constexpr std::ptrdiff_t m_bFreezePeriod = 0x30; // bool
    constexpr std::ptrdiff_t m_bWarmupPeriod = 0x31; // bool
    constexpr std::ptrdiff_t m_fWarmupPeriodEnd = 0x34; // GameTime_t
    constexpr std::ptrdiff_t m_fWarmupPeriodStart = 0x38; // GameTime_t
    constexpr std::ptrdiff_t m_nTotalPausedTicks = 0x3C; // int32_t
    constexpr std::ptrdiff_t m_nPauseStartTick = 0x40; // int32_t
    constexpr std::ptrdiff_t m_bServerPaused = 0x44; // bool
    constexpr std::ptrdiff_t m_bGamePaused = 0x45; // bool
    constexpr std::ptrdiff_t m_bTerroristTimeOutActive = 0x46; // bool
    constexpr std::ptrdiff_t m_bCTTimeOutActive = 0x47; // bool
    constexpr std::ptrdiff_t m_flTerroristTimeOutRemaining = 0x48; // float
    constexpr std::ptrdiff_t m_flCTTimeOutRemaining = 0x4C; // float
    constexpr std::ptrdiff_t m_nTerroristTimeOuts = 0x50; // int32_t
    constexpr std::ptrdiff_t m_nCTTimeOuts = 0x54; // int32_t
    constexpr std::ptrdiff_t m_bTechnicalTimeOut = 0x58; // bool
    constexpr std::ptrdiff_t m_bMatchWaitingForResume = 0x59; // bool
    constexpr std::ptrdiff_t m_iRoundTime = 0x5C; // int32_t
    constexpr std::ptrdiff_t m_fMatchStartTime = 0x60; // float
    constexpr std::ptrdiff_t m_fRoundStartTime = 0x64; // GameTime_t
    constexpr std::ptrdiff_t m_flRestartRoundTime = 0x68; // GameTime_t
    constexpr std::ptrdiff_t m_bGameRestart = 0x6C; // bool
    constexpr std::ptrdiff_t m_flGameStartTime = 0x70; // float
    constexpr std::ptrdiff_t m_timeUntilNextPhaseStarts = 0x74; // float
    constexpr std::ptrdiff_t m_gamePhase = 0x78; // int32_t
    constexpr std::ptrdiff_t m_totalRoundsPlayed = 0x7C; // int32_t
    constexpr std::ptrdiff_t m_nRoundsPlayedThisPhase = 0x80; // int32_t
    constexpr std::ptrdiff_t m_nOvertimePlaying = 0x84; // int32_t
    constexpr std::ptrdiff_t m_iHostagesRemaining = 0x88; // int32_t
    constexpr std::ptrdiff_t m_bAnyHostageReached = 0x8C; // bool
    constexpr std::ptrdiff_t m_bMapHasBombTarget = 0x8D; // bool
    constexpr std::ptrdiff_t m_bMapHasRescueZone = 0x8E; // bool
    constexpr std::ptrdiff_t m_bMapHasBuyZone = 0x8F; // bool
    constexpr std::ptrdiff_t m_bIsQueuedMatchmaking = 0x90; // bool
    constexpr std::ptrdiff_t m_nQueuedMatchmakingMode = 0x94; // int32_t
    constexpr std::ptrdiff_t m_bIsValveDS = 0x98; // bool
    constexpr std::ptrdiff_t m_bLogoMap = 0x99; // bool
    constexpr std::ptrdiff_t m_bPlayAllStepSoundsOnServer = 0x9A; // bool
    constexpr std::ptrdiff_t m_iSpectatorSlotCount = 0x9C; // int32_t
    constexpr std::ptrdiff_t m_MatchDevice = 0xA0; // int32_t
    constexpr std::ptrdiff_t m_bHasMatchStarted = 0xA4; // bool
    constexpr std::ptrdiff_t m_nNextMapInMapgroup = 0xA8; // int32_t
    constexpr std::ptrdiff_t m_szTournamentEventName = 0xAC; // char[512]
    constexpr std::ptrdiff_t m_szTournamentEventStage = 0x2AC; // char[512]
    constexpr std::ptrdiff_t m_szMatchStatTxt = 0x4AC; // char[512]
    constexpr std::ptrdiff_t m_szTournamentPredictionsTxt = 0x6AC; // char[512]
    constexpr std::ptrdiff_t m_nTournamentPredictionsPct = 0x8AC; // int32_t
    constexpr std::ptrdiff_t m_flCMMItemDropRevealStartTime = 0x8B0; // GameTime_t
    constexpr std::ptrdiff_t m_flCMMItemDropRevealEndTime = 0x8B4; // GameTime_t
    constexpr std::ptrdiff_t m_bIsDroppingItems = 0x8B8; // bool
    constexpr std::ptrdiff_t m_bIsQuestEligible = 0x8B9; // bool
    constexpr std::ptrdiff_t m_bIsHltvActive = 0x8BA; // bool
    constexpr std::ptrdiff_t m_nGuardianModeWaveNumber = 0x8BC; // int32_t
    constexpr std::ptrdiff_t m_nGuardianModeSpecialKillsRemaining = 0x8C0; // int32_t
    constexpr std::ptrdiff_t m_nGuardianModeSpecialWeaponNeeded = 0x8C4; // int32_t
    constexpr std::ptrdiff_t m_nGuardianGrenadesToGiveBots = 0x8C8; // int32_t
    constexpr std::ptrdiff_t m_nNumHeaviesToSpawn = 0x8CC; // int32_t
    constexpr std::ptrdiff_t m_numGlobalGiftsGiven = 0x8D0; // uint32_t
    constexpr std::ptrdiff_t m_numGlobalGifters = 0x8D4; // uint32_t
    constexpr std::ptrdiff_t m_numGlobalGiftsPeriodSeconds = 0x8D8; // uint32_t
    constexpr std::ptrdiff_t m_arrFeaturedGiftersAccounts = 0x8DC; // uint32_t[4]
    constexpr std::ptrdiff_t m_arrFeaturedGiftersGifts = 0x8EC; // uint32_t[4]
    constexpr std::ptrdiff_t m_arrProhibitedItemIndices = 0x8FC; // uint16_t[100]
    constexpr std::ptrdiff_t m_arrTournamentActiveCasterAccounts = 0x9C4; // uint32_t[4]
    constexpr std::ptrdiff_t m_numBestOfMaps = 0x9D4; // int32_t
    constexpr std::ptrdiff_t m_nHalloweenMaskListSeed = 0x9D8; // int32_t
    constexpr std::ptrdiff_t m_bBombDropped = 0x9DC; // bool
    constexpr std::ptrdiff_t m_bBombPlanted = 0x9DD; // bool
    constexpr std::ptrdiff_t m_iRoundWinStatus = 0x9E0; // int32_t
    constexpr std::ptrdiff_t m_eRoundWinReason = 0x9E4; // int32_t
    constexpr std::ptrdiff_t m_bTCantBuy = 0x9E8; // bool
    constexpr std::ptrdiff_t m_bCTCantBuy = 0x9E9; // bool
    constexpr std::ptrdiff_t m_flGuardianBuyUntilTime = 0x9EC; // GameTime_t
    constexpr std::ptrdiff_t m_iMatchStats_RoundResults = 0x9F0; // int32_t[30]
    constexpr std::ptrdiff_t m_iMatchStats_PlayersAlive_CT = 0xA68; // int32_t[30]
    constexpr std::ptrdiff_t m_iMatchStats_PlayersAlive_T = 0xAE0; // int32_t[30]
    constexpr std::ptrdiff_t m_TeamRespawnWaveTimes = 0xB58; // float[32]
    constexpr std::ptrdiff_t m_flNextRespawnWave = 0xBD8; // GameTime_t[32]
    constexpr std::ptrdiff_t m_nServerQuestID = 0xC58; // int32_t
    constexpr std::ptrdiff_t m_vMinimapMins = 0xC5C; // Vector
    constexpr std::ptrdiff_t m_vMinimapMaxs = 0xC68; // Vector
    constexpr std::ptrdiff_t m_MinimapVerticalSectionHeights = 0xC74; // float[8]
    constexpr std::ptrdiff_t m_bDontIncrementCoopWave = 0xC94; // bool
    constexpr std::ptrdiff_t m_bSpawnedTerrorHuntHeavy = 0xC95; // bool
    constexpr std::ptrdiff_t m_nEndMatchMapGroupVoteTypes = 0xC98; // int32_t[10]
    constexpr std::ptrdiff_t m_nEndMatchMapGroupVoteOptions = 0xCC0; // int32_t[10]
    constexpr std::ptrdiff_t m_nEndMatchMapVoteWinner = 0xCE8; // int32_t
    constexpr std::ptrdiff_t m_iNumConsecutiveCTLoses = 0xCEC; // int32_t
    constexpr std::ptrdiff_t m_iNumConsecutiveTerroristLoses = 0xCF0; // int32_t
    constexpr std::ptrdiff_t m_bMarkClientStopRecordAtRoundEnd = 0xD10; // bool
    constexpr std::ptrdiff_t m_nMatchAbortedEarlyReason = 0xD68; // int32_t
    constexpr std::ptrdiff_t m_bHasTriggeredRoundStartMusic = 0xD6C; // bool
    constexpr std::ptrdiff_t m_bHasTriggeredCoopSpawnReset = 0xD6D; // bool
    constexpr std::ptrdiff_t m_bSwitchingTeamsAtRoundReset = 0xD6E; // bool
    constexpr std::ptrdiff_t m_pGameModeRules = 0xD88; // CCSGameModeRules*
    constexpr std::ptrdiff_t m_RetakeRules = 0xD90; // C_RetakeGameRules
    constexpr std::ptrdiff_t m_nMatchEndCount = 0xEA8; // uint8_t
    constexpr std::ptrdiff_t m_nTTeamIntroVariant = 0xEAC; // int32_t
    constexpr std::ptrdiff_t m_nCTTeamIntroVariant = 0xEB0; // int32_t
    constexpr std::ptrdiff_t m_bTeamIntroPeriod = 0xEB4; // bool
    constexpr std::ptrdiff_t m_flLastPerfSampleTime = 0x4EC0; // double
}

namespace C_CSGameRulesProxy {
    constexpr std::ptrdiff_t m_pGameRules = 0x540; // C_CSGameRules*
}

namespace C_CSObserverPawn {
    constexpr std::ptrdiff_t m_hDetectParentChange = 0x16B0; // CEntityHandle
}

namespace C_CSPlayerPawn {
    constexpr std::ptrdiff_t m_pBulletServices = 0x16B0; // CCSPlayer_BulletServices*
    constexpr std::ptrdiff_t m_pHostageServices = 0x16B8; // CCSPlayer_HostageServices*
    constexpr std::ptrdiff_t m_pBuyServices = 0x16C0; // CCSPlayer_BuyServices*
    constexpr std::ptrdiff_t m_pGlowServices = 0x16C8; // CCSPlayer_GlowServices*
    constexpr std::ptrdiff_t m_pActionTrackingServices = 0x16D0; // CCSPlayer_ActionTrackingServices*
    constexpr std::ptrdiff_t m_flHealthShotBoostExpirationTime = 0x16D8; // GameTime_t
    constexpr std::ptrdiff_t m_flLastFiredWeaponTime = 0x16DC; // GameTime_t
    constexpr std::ptrdiff_t m_bHasFemaleVoice = 0x16E0; // bool
    constexpr std::ptrdiff_t m_flLandseconds = 0x16E4; // float
    constexpr std::ptrdiff_t m_flOldFallVelocity = 0x16E8; // float
    constexpr std::ptrdiff_t m_szLastPlaceName = 0x16EC; // char[18]
    constexpr std::ptrdiff_t m_bPrevDefuser = 0x16FE; // bool
    constexpr std::ptrdiff_t m_bPrevHelmet = 0x16FF; // bool
    constexpr std::ptrdiff_t m_nPrevArmorVal = 0x1700; // int32_t
    constexpr std::ptrdiff_t m_nPrevGrenadeAmmoCount = 0x1704; // int32_t
    constexpr std::ptrdiff_t m_unPreviousWeaponHash = 0x1708; // uint32_t
    constexpr std::ptrdiff_t m_unWeaponHash = 0x170C; // uint32_t
    constexpr std::ptrdiff_t m_bInBuyZone = 0x1710; // bool
    constexpr std::ptrdiff_t m_bPreviouslyInBuyZone = 0x1711; // bool
    constexpr std::ptrdiff_t m_aimPunchAngle = 0x1714; // QAngle
    constexpr std::ptrdiff_t m_aimPunchAngleVel = 0x1720; // QAngle
    constexpr std::ptrdiff_t m_aimPunchTickBase = 0x172C; // int32_t
    constexpr std::ptrdiff_t m_aimPunchTickFraction = 0x1730; // float
    constexpr std::ptrdiff_t m_aimPunchCache = 0x1738; // CUtlVector<QAngle>
    constexpr std::ptrdiff_t m_bInLanding = 0x1758; // bool
    constexpr std::ptrdiff_t m_flLandingTime = 0x175C; // float
    constexpr std::ptrdiff_t m_bInHostageRescueZone = 0x1760; // bool
    constexpr std::ptrdiff_t m_bInBombZone = 0x1761; // bool
    constexpr std::ptrdiff_t m_bIsBuyMenuOpen = 0x1762; // bool
    constexpr std::ptrdiff_t m_flTimeOfLastInjury = 0x1764; // GameTime_t
    constexpr std::ptrdiff_t m_flNextSprayDecalTime = 0x1768; // GameTime_t
    constexpr std::ptrdiff_t m_iRetakesOffering = 0x1880; // int32_t
    constexpr std::ptrdiff_t m_iRetakesOfferingCard = 0x1884; // int32_t
    constexpr std::ptrdiff_t m_bRetakesHasDefuseKit = 0x1888; // bool
    constexpr std::ptrdiff_t m_bRetakesMVPLastRound = 0x1889; // bool
    constexpr std::ptrdiff_t m_iRetakesMVPBoostItem = 0x188C; // int32_t
    constexpr std::ptrdiff_t m_RetakesMVPBoostExtraUtility = 0x1890; // loadout_slot_t
    constexpr std::ptrdiff_t m_bNeedToReApplyGloves = 0x18B0; // bool
    constexpr std::ptrdiff_t m_EconGloves = 0x18B8; // C_EconItemView
    constexpr std::ptrdiff_t m_bMustSyncRagdollState = 0x1D00; // bool
    constexpr std::ptrdiff_t m_nRagdollDamageBone = 0x1D04; // int32_t
    constexpr std::ptrdiff_t m_vRagdollDamageForce = 0x1D08; // Vector
    constexpr std::ptrdiff_t m_vRagdollDamagePosition = 0x1D14; // Vector
    constexpr std::ptrdiff_t m_szRagdollDamageWeaponName = 0x1D20; // char[64]
    constexpr std::ptrdiff_t m_bRagdollDamageHeadshot = 0x1D60; // bool
    constexpr std::ptrdiff_t m_vRagdollServerOrigin = 0x1D64; // Vector
    constexpr std::ptrdiff_t m_bLastHeadBoneTransformIsValid = 0x22B0; // bool
    constexpr std::ptrdiff_t m_lastLandTime = 0x22B4; // GameTime_t
    constexpr std::ptrdiff_t m_bOnGroundLastTick = 0x22B8; // bool
    constexpr std::ptrdiff_t m_qDeathEyeAngles = 0x22D4; // QAngle
    constexpr std::ptrdiff_t m_bSkipOneHeadConstraintUpdate = 0x22E0; // bool
}

namespace C_CSPlayerPawnBase {
    constexpr std::ptrdiff_t m_pPingServices = 0x1268; // CCSPlayer_PingServices*
    constexpr std::ptrdiff_t m_pViewModelServices = 0x1270; // CPlayer_ViewModelServices*
    constexpr std::ptrdiff_t m_fRenderingClipPlane = 0x1278; // float[4]
    constexpr std::ptrdiff_t m_nLastClipPlaneSetupFrame = 0x1288; // int32_t
    constexpr std::ptrdiff_t m_vecLastClipCameraPos = 0x128C; // Vector
    constexpr std::ptrdiff_t m_vecLastClipCameraForward = 0x1298; // Vector
    constexpr std::ptrdiff_t m_bClipHitStaticWorld = 0x12A4; // bool
    constexpr std::ptrdiff_t m_bCachedPlaneIsValid = 0x12A5; // bool
    constexpr std::ptrdiff_t m_pClippingWeapon = 0x12A8; // C_CSWeaponBase*
    constexpr std::ptrdiff_t m_previousPlayerState = 0x12B0; // CSPlayerState
    constexpr std::ptrdiff_t m_flLastCollisionCeiling = 0x12B4; // float
    constexpr std::ptrdiff_t m_flLastCollisionCeilingChangeTime = 0x12B8; // float
    constexpr std::ptrdiff_t m_grenadeParameterStashTime = 0x12D8; // GameTime_t
    constexpr std::ptrdiff_t m_bGrenadeParametersStashed = 0x12DC; // bool
    constexpr std::ptrdiff_t m_angStashedShootAngles = 0x12E0; // QAngle
    constexpr std::ptrdiff_t m_vecStashedGrenadeThrowPosition = 0x12EC; // Vector
    constexpr std::ptrdiff_t m_vecStashedVelocity = 0x12F8; // Vector
    constexpr std::ptrdiff_t m_angShootAngleHistory = 0x1304; // QAngle[2]
    constexpr std::ptrdiff_t m_vecThrowPositionHistory = 0x131C; // Vector[2]
    constexpr std::ptrdiff_t m_vecVelocityHistory = 0x1334; // Vector[2]
    constexpr std::ptrdiff_t m_thirdPersonHeading = 0x1350; // QAngle
    constexpr std::ptrdiff_t m_flSlopeDropOffset = 0x1368; // float
    constexpr std::ptrdiff_t m_flSlopeDropHeight = 0x1378; // float
    constexpr std::ptrdiff_t m_vHeadConstraintOffset = 0x1388; // Vector
    constexpr std::ptrdiff_t m_bIsScoped = 0x13A0; // bool
    constexpr std::ptrdiff_t m_bIsWalking = 0x13A1; // bool
    constexpr std::ptrdiff_t m_bResumeZoom = 0x13A2; // bool
    constexpr std::ptrdiff_t m_iPlayerState = 0x13A4; // CSPlayerState
    constexpr std::ptrdiff_t m_bIsDefusing = 0x13A8; // bool
    constexpr std::ptrdiff_t m_bIsGrabbingHostage = 0x13A9; // bool
    constexpr std::ptrdiff_t m_iBlockingUseActionInProgress = 0x13AC; // CSPlayerBlockingUseAction_t
    constexpr std::ptrdiff_t m_bIsRescuing = 0x13B0; // bool
    constexpr std::ptrdiff_t m_fImmuneToGunGameDamageTime = 0x13B4; // GameTime_t
    constexpr std::ptrdiff_t m_fImmuneToGunGameDamageTimeLast = 0x13B8; // GameTime_t
    constexpr std::ptrdiff_t m_bGunGameImmunity = 0x13BC; // bool
    constexpr std::ptrdiff_t m_bHasMovedSinceSpawn = 0x13BD; // bool
    constexpr std::ptrdiff_t m_fMolotovUseTime = 0x13C0; // float
    constexpr std::ptrdiff_t m_fMolotovDamageTime = 0x13C4; // float
    constexpr std::ptrdiff_t m_nWhichBombZone = 0x13C8; // int32_t
    constexpr std::ptrdiff_t m_bInNoDefuseArea = 0x13CC; // bool
    constexpr std::ptrdiff_t m_iThrowGrenadeCounter = 0x13D0; // int32_t
    constexpr std::ptrdiff_t m_bWaitForNoAttack = 0x13D4; // bool
    constexpr std::ptrdiff_t m_flGuardianTooFarDistFrac = 0x13D8; // float
    constexpr std::ptrdiff_t m_flDetectedByEnemySensorTime = 0x13DC; // GameTime_t
    constexpr std::ptrdiff_t m_flNextGuardianTooFarWarning = 0x13E0; // float
    constexpr std::ptrdiff_t m_bSuppressGuardianTooFarWarningAudio = 0x13E4; // bool
    constexpr std::ptrdiff_t m_bKilledByTaser = 0x13E5; // bool
    constexpr std::ptrdiff_t m_iMoveState = 0x13E8; // int32_t
    constexpr std::ptrdiff_t m_bCanMoveDuringFreezePeriod = 0x13EC; // bool
    constexpr std::ptrdiff_t m_flLowerBodyYawTarget = 0x13F0; // float
    constexpr std::ptrdiff_t m_bStrafing = 0x13F4; // bool
    constexpr std::ptrdiff_t m_flLastSpawnTimeIndex = 0x13F8; // GameTime_t
    constexpr std::ptrdiff_t m_flEmitSoundTime = 0x13FC; // GameTime_t
    constexpr std::ptrdiff_t m_iAddonBits = 0x1400; // int32_t
    constexpr std::ptrdiff_t m_iPrimaryAddon = 0x1404; // int32_t
    constexpr std::ptrdiff_t m_iSecondaryAddon = 0x1408; // int32_t
    constexpr std::ptrdiff_t m_iProgressBarDuration = 0x140C; // int32_t
    constexpr std::ptrdiff_t m_flProgressBarStartTime = 0x1410; // float
    constexpr std::ptrdiff_t m_iDirection = 0x1414; // int32_t
    constexpr std::ptrdiff_t m_iShotsFired = 0x1418; // int32_t
    constexpr std::ptrdiff_t m_bNightVisionOn = 0x141C; // bool
    constexpr std::ptrdiff_t m_bHasNightVision = 0x141D; // bool
    constexpr std::ptrdiff_t m_flVelocityModifier = 0x1420; // float
    constexpr std::ptrdiff_t m_flHitHeading = 0x1424; // float
    constexpr std::ptrdiff_t m_nHitBodyPart = 0x1428; // int32_t
    constexpr std::ptrdiff_t m_iStartAccount = 0x142C; // int32_t
    constexpr std::ptrdiff_t m_vecIntroStartEyePosition = 0x1430; // Vector
    constexpr std::ptrdiff_t m_vecIntroStartPlayerForward = 0x143C; // Vector
    constexpr std::ptrdiff_t m_flClientDeathTime = 0x1448; // GameTime_t
    constexpr std::ptrdiff_t m_flNightVisionAlpha = 0x144C; // float
    constexpr std::ptrdiff_t m_bScreenTearFrameCaptured = 0x1450; // bool
    constexpr std::ptrdiff_t m_flFlashBangTime = 0x1454; // float
    constexpr std::ptrdiff_t m_flFlashScreenshotAlpha = 0x1458; // float
    constexpr std::ptrdiff_t m_flFlashOverlayAlpha = 0x145C; // float
    constexpr std::ptrdiff_t m_bFlashBuildUp = 0x1460; // bool
    constexpr std::ptrdiff_t m_bFlashDspHasBeenCleared = 0x1461; // bool
    constexpr std::ptrdiff_t m_bFlashScreenshotHasBeenGrabbed = 0x1462; // bool
    constexpr std::ptrdiff_t m_flFlashMaxAlpha = 0x1464; // float
    constexpr std::ptrdiff_t m_flFlashDuration = 0x1468; // float
    constexpr std::ptrdiff_t m_lastStandingPos = 0x146C; // Vector
    constexpr std::ptrdiff_t m_vecLastMuzzleFlashPos = 0x1478; // Vector
    constexpr std::ptrdiff_t m_angLastMuzzleFlashAngle = 0x1484; // QAngle
    constexpr std::ptrdiff_t m_hMuzzleFlashShape = 0x1490; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_iHealthBarRenderMaskIndex = 0x1494; // int32_t
    constexpr std::ptrdiff_t m_flHealthFadeValue = 0x1498; // float
    constexpr std::ptrdiff_t m_flHealthFadeAlpha = 0x149C; // float
    constexpr std::ptrdiff_t m_nMyCollisionGroup = 0x14A0; // int32_t
    constexpr std::ptrdiff_t m_ignoreLadderJumpTime = 0x14A4; // float
    constexpr std::ptrdiff_t m_ladderSurpressionTimer = 0x14A8; // CountdownTimer
    constexpr std::ptrdiff_t m_lastLadderNormal = 0x14C0; // Vector
    constexpr std::ptrdiff_t m_lastLadderPos = 0x14CC; // Vector
    constexpr std::ptrdiff_t m_flDeathCCWeight = 0x14E0; // float
    constexpr std::ptrdiff_t m_bOldIsScoped = 0x14E4; // bool
    constexpr std::ptrdiff_t m_flPrevRoundEndTime = 0x14E8; // float
    constexpr std::ptrdiff_t m_flPrevMatchEndTime = 0x14EC; // float
    constexpr std::ptrdiff_t m_unCurrentEquipmentValue = 0x14F0; // uint16_t
    constexpr std::ptrdiff_t m_unRoundStartEquipmentValue = 0x14F2; // uint16_t
    constexpr std::ptrdiff_t m_unFreezetimeEndEquipmentValue = 0x14F4; // uint16_t
    constexpr std::ptrdiff_t m_vecThirdPersonViewPositionOverride = 0x14F8; // Vector
    constexpr std::ptrdiff_t m_nHeavyAssaultSuitCooldownRemaining = 0x1504; // int32_t
    constexpr std::ptrdiff_t m_ArmorValue = 0x1508; // int32_t
    constexpr std::ptrdiff_t m_angEyeAngles = 0x1510; // QAngle
    constexpr std::ptrdiff_t m_fNextThinkPushAway = 0x1528; // float
    constexpr std::ptrdiff_t m_bShouldAutobuyDMWeapons = 0x152C; // bool
    constexpr std::ptrdiff_t m_bShouldAutobuyNow = 0x152D; // bool
    constexpr std::ptrdiff_t m_bHud_MiniScoreHidden = 0x152E; // bool
    constexpr std::ptrdiff_t m_bHud_RadarHidden = 0x152F; // bool
    constexpr std::ptrdiff_t m_nLastKillerIndex = 0x1530; // CEntityIndex
    constexpr std::ptrdiff_t m_nLastConcurrentKilled = 0x1534; // int32_t
    constexpr std::ptrdiff_t m_nDeathCamMusic = 0x1538; // int32_t
    constexpr std::ptrdiff_t m_iIDEntIndex = 0x153C; // CEntityIndex
    constexpr std::ptrdiff_t m_delayTargetIDTimer = 0x1540; // CountdownTimer
    constexpr std::ptrdiff_t m_iTargetedWeaponEntIndex = 0x1558; // CEntityIndex
    constexpr std::ptrdiff_t m_iOldIDEntIndex = 0x155C; // CEntityIndex
    constexpr std::ptrdiff_t m_holdTargetIDTimer = 0x1560; // CountdownTimer
    constexpr std::ptrdiff_t m_flCurrentMusicStartTime = 0x157C; // float
    constexpr std::ptrdiff_t m_flMusicRoundStartTime = 0x1580; // float
    constexpr std::ptrdiff_t m_bDeferStartMusicOnWarmup = 0x1584; // bool
    constexpr std::ptrdiff_t m_cycleLatch = 0x1588; // int32_t
    constexpr std::ptrdiff_t m_serverIntendedCycle = 0x158C; // float
    constexpr std::ptrdiff_t m_vecPlayerPatchEconIndices = 0x1590; // uint32_t[5]
    constexpr std::ptrdiff_t m_bHideTargetID = 0x15AC; // bool
    constexpr std::ptrdiff_t m_nextTaserShakeTime = 0x15B0; // float
    constexpr std::ptrdiff_t m_firstTaserShakeTime = 0x15B4; // float
    constexpr std::ptrdiff_t m_flLastSmokeOverlayAlpha = 0x15B8; // float
    constexpr std::ptrdiff_t m_vLastSmokeOverlayColor = 0x15BC; // Vector
    constexpr std::ptrdiff_t m_nPlayerSmokedFx = 0x15C8; // ParticleIndex_t
    constexpr std::ptrdiff_t m_flNextMagDropTime = 0x15CC; // float
    constexpr std::ptrdiff_t m_nLastMagDropAttachmentIndex = 0x15D0; // int32_t
    constexpr std::ptrdiff_t m_vecBulletHitModels = 0x15D8; // CUtlVector<C_BulletHitModel*>
    constexpr std::ptrdiff_t m_vecPickupModelSlerpers = 0x15F0; // CUtlVector<C_PickUpModelSlerper*>
    constexpr std::ptrdiff_t m_vecLastAliveLocalVelocity = 0x1608; // Vector
    constexpr std::ptrdiff_t m_entitySpottedState = 0x1630; // EntitySpottedState_t
    constexpr std::ptrdiff_t m_nSurvivalTeamNumber = 0x1648; // int32_t
    constexpr std::ptrdiff_t m_bGuardianShouldSprayCustomXMark = 0x164C; // bool
    constexpr std::ptrdiff_t m_bHasDeathInfo = 0x164D; // bool
    constexpr std::ptrdiff_t m_flDeathInfoTime = 0x1650; // float
    constexpr std::ptrdiff_t m_vecDeathInfoOrigin = 0x1654; // Vector
    constexpr std::ptrdiff_t m_bKilledByHeadshot = 0x1660; // bool
    constexpr std::ptrdiff_t m_hOriginalController = 0x1664; // CHandle<CCSPlayerController>
}

namespace C_CSPlayerResource {
    constexpr std::ptrdiff_t m_bHostageAlive = 0x540; // bool[12]
    constexpr std::ptrdiff_t m_isHostageFollowingSomeone = 0x54C; // bool[12]
    constexpr std::ptrdiff_t m_iHostageEntityIDs = 0x558; // CEntityIndex[12]
    constexpr std::ptrdiff_t m_bombsiteCenterA = 0x588; // Vector
    constexpr std::ptrdiff_t m_bombsiteCenterB = 0x594; // Vector
    constexpr std::ptrdiff_t m_hostageRescueX = 0x5A0; // int32_t[4]
    constexpr std::ptrdiff_t m_hostageRescueY = 0x5B0; // int32_t[4]
    constexpr std::ptrdiff_t m_hostageRescueZ = 0x5C0; // int32_t[4]
    constexpr std::ptrdiff_t m_bEndMatchNextMapAllVoted = 0x5D0; // bool
    constexpr std::ptrdiff_t m_foundGoalPositions = 0x5D1; // bool
}

namespace C_CSTeam {
    constexpr std::ptrdiff_t m_szTeamMatchStat = 0x5F8; // char[512]
    constexpr std::ptrdiff_t m_numMapVictories = 0x7F8; // int32_t
    constexpr std::ptrdiff_t m_bSurrendered = 0x7FC; // bool
    constexpr std::ptrdiff_t m_scoreFirstHalf = 0x800; // int32_t
    constexpr std::ptrdiff_t m_scoreSecondHalf = 0x804; // int32_t
    constexpr std::ptrdiff_t m_scoreOvertime = 0x808; // int32_t
    constexpr std::ptrdiff_t m_szClanTeamname = 0x80C; // char[129]
    constexpr std::ptrdiff_t m_iClanID = 0x890; // uint32_t
    constexpr std::ptrdiff_t m_szTeamFlagImage = 0x894; // char[8]
    constexpr std::ptrdiff_t m_szTeamLogoImage = 0x89C; // char[8]
}

namespace C_CSWeaponBase {
    constexpr std::ptrdiff_t m_flFireSequenceStartTime = 0x15D4; // float
    constexpr std::ptrdiff_t m_nFireSequenceStartTimeChange = 0x15D8; // int32_t
    constexpr std::ptrdiff_t m_nFireSequenceStartTimeAck = 0x15DC; // int32_t
    constexpr std::ptrdiff_t m_bPlayerFireEventIsPrimary = 0x15E0; // bool
    constexpr std::ptrdiff_t m_seqIdle = 0x15E4; // HSequence
    constexpr std::ptrdiff_t m_seqFirePrimary = 0x15E8; // HSequence
    constexpr std::ptrdiff_t m_seqFireSecondary = 0x15EC; // HSequence
    constexpr std::ptrdiff_t m_thirdPersonFireSequences = 0x15F0; // CUtlVector<HSequence>
    constexpr std::ptrdiff_t m_hCurrentThirdPersonSequence = 0x1608; // HSequence
    constexpr std::ptrdiff_t m_nSilencerBoneIndex = 0x160C; // int32_t
    constexpr std::ptrdiff_t m_thirdPersonSequences = 0x1610; // HSequence[6]
    constexpr std::ptrdiff_t m_ClientPreviousWeaponState = 0x1640; // CSWeaponState_t
    constexpr std::ptrdiff_t m_iState = 0x1644; // CSWeaponState_t
    constexpr std::ptrdiff_t m_flCrosshairDistance = 0x1648; // float
    constexpr std::ptrdiff_t m_iAmmoLastCheck = 0x164C; // int32_t
    constexpr std::ptrdiff_t m_iAlpha = 0x1650; // int32_t
    constexpr std::ptrdiff_t m_iScopeTextureID = 0x1654; // int32_t
    constexpr std::ptrdiff_t m_iCrosshairTextureID = 0x1658; // int32_t
    constexpr std::ptrdiff_t m_flGunAccuracyPosition = 0x165C; // float
    constexpr std::ptrdiff_t m_nViewModelIndex = 0x1660; // uint32_t
    constexpr std::ptrdiff_t m_bReloadsWithClips = 0x1664; // bool
    constexpr std::ptrdiff_t m_flTimeWeaponIdle = 0x1668; // GameTime_t
    constexpr std::ptrdiff_t m_bFireOnEmpty = 0x166C; // bool
    constexpr std::ptrdiff_t m_OnPlayerPickup = 0x1670; // CEntityIOOutput
    constexpr std::ptrdiff_t m_weaponMode = 0x1698; // CSWeaponMode
    constexpr std::ptrdiff_t m_flTurningInaccuracyDelta = 0x169C; // float
    constexpr std::ptrdiff_t m_vecTurningInaccuracyEyeDirLast = 0x16A0; // Vector
    constexpr std::ptrdiff_t m_flTurningInaccuracy = 0x16AC; // float
    constexpr std::ptrdiff_t m_fAccuracyPenalty = 0x16B0; // float
    constexpr std::ptrdiff_t m_flLastAccuracyUpdateTime = 0x16B4; // GameTime_t
    constexpr std::ptrdiff_t m_fAccuracySmoothedForZoom = 0x16B8; // float
    constexpr std::ptrdiff_t m_fScopeZoomEndTime = 0x16BC; // GameTime_t
    constexpr std::ptrdiff_t m_iRecoilIndex = 0x16C0; // int32_t
    constexpr std::ptrdiff_t m_flRecoilIndex = 0x16C4; // float
    constexpr std::ptrdiff_t m_bBurstMode = 0x16C8; // bool
    constexpr std::ptrdiff_t m_flPostponeFireReadyTime = 0x16CC; // GameTime_t
    constexpr std::ptrdiff_t m_bInReload = 0x16D0; // bool
    constexpr std::ptrdiff_t m_bReloadVisuallyComplete = 0x16D1; // bool
    constexpr std::ptrdiff_t m_flDroppedAtTime = 0x16D4; // GameTime_t
    constexpr std::ptrdiff_t m_bIsHauledBack = 0x16D8; // bool
    constexpr std::ptrdiff_t m_bSilencerOn = 0x16D9; // bool
    constexpr std::ptrdiff_t m_flTimeSilencerSwitchComplete = 0x16DC; // GameTime_t
    constexpr std::ptrdiff_t m_iOriginalTeamNumber = 0x16E0; // int32_t
    constexpr std::ptrdiff_t m_flNextAttackRenderTimeOffset = 0x16E4; // float
    constexpr std::ptrdiff_t m_bVisualsDataSet = 0x1768; // bool
    constexpr std::ptrdiff_t m_bOldFirstPersonSpectatedState = 0x1769; // bool
    constexpr std::ptrdiff_t m_hOurPing = 0x176C; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_nOurPingIndex = 0x1770; // CEntityIndex
    constexpr std::ptrdiff_t m_vecOurPingPos = 0x1774; // Vector
    constexpr std::ptrdiff_t m_bGlowForPing = 0x1780; // bool
    constexpr std::ptrdiff_t m_bUIWeapon = 0x1781; // bool
    constexpr std::ptrdiff_t m_hPrevOwner = 0x1790; // CHandle<C_CSPlayerPawn>
    constexpr std::ptrdiff_t m_nDropTick = 0x1794; // GameTick_t
    constexpr std::ptrdiff_t m_donated = 0x17B4; // bool
    constexpr std::ptrdiff_t m_fLastShotTime = 0x17B8; // GameTime_t
    constexpr std::ptrdiff_t m_bWasOwnedByCT = 0x17BC; // bool
    constexpr std::ptrdiff_t m_bWasOwnedByTerrorist = 0x17BD; // bool
    constexpr std::ptrdiff_t m_gunHeat = 0x17C0; // float
    constexpr std::ptrdiff_t m_smokeAttachments = 0x17C4; // uint32_t
    constexpr std::ptrdiff_t m_lastSmokeTime = 0x17C8; // GameTime_t
    constexpr std::ptrdiff_t m_flNextClientFireBulletTime = 0x17CC; // float
    constexpr std::ptrdiff_t m_flNextClientFireBulletTime_Repredict = 0x17D0; // float
    constexpr std::ptrdiff_t m_IronSightController = 0x18B0; // C_IronSightController
    constexpr std::ptrdiff_t m_iIronSightMode = 0x1960; // int32_t
    constexpr std::ptrdiff_t m_flLastLOSTraceFailureTime = 0x1970; // GameTime_t
    constexpr std::ptrdiff_t m_iNumEmptyAttacks = 0x1974; // int32_t
}

namespace C_CSWeaponBaseGun {
    constexpr std::ptrdiff_t m_zoomLevel = 0x19F0; // int32_t
    constexpr std::ptrdiff_t m_iBurstShotsRemaining = 0x19F4; // int32_t
    constexpr std::ptrdiff_t m_iSilencerBodygroup = 0x19F8; // int32_t
    constexpr std::ptrdiff_t m_silencedModelIndex = 0x1A08; // int32_t
    constexpr std::ptrdiff_t m_inPrecache = 0x1A0C; // bool
    constexpr std::ptrdiff_t m_bNeedsBoltAction = 0x1A0D; // bool
}

namespace C_Chicken {
    constexpr std::ptrdiff_t m_hHolidayHatAddon = 0x10F0; // CHandle<CBaseAnimGraph>
    constexpr std::ptrdiff_t m_jumpedThisFrame = 0x10F4; // bool
    constexpr std::ptrdiff_t m_leader = 0x10F8; // CHandle<C_CSPlayerPawnBase>
    constexpr std::ptrdiff_t m_AttributeManager = 0x1100; // C_AttributeContainer
    constexpr std::ptrdiff_t m_OriginalOwnerXuidLow = 0x15A8; // uint32_t
    constexpr std::ptrdiff_t m_OriginalOwnerXuidHigh = 0x15AC; // uint32_t
    constexpr std::ptrdiff_t m_bAttributesInitialized = 0x15B0; // bool
    constexpr std::ptrdiff_t m_hWaterWakeParticles = 0x15B4; // ParticleIndex_t
}

namespace C_ClientRagdoll {
    constexpr std::ptrdiff_t m_bFadeOut = 0xE80; // bool
    constexpr std::ptrdiff_t m_bImportant = 0xE81; // bool
    constexpr std::ptrdiff_t m_flEffectTime = 0xE84; // GameTime_t
    constexpr std::ptrdiff_t m_gibDespawnTime = 0xE88; // GameTime_t
    constexpr std::ptrdiff_t m_iCurrentFriction = 0xE8C; // int32_t
    constexpr std::ptrdiff_t m_iMinFriction = 0xE90; // int32_t
    constexpr std::ptrdiff_t m_iMaxFriction = 0xE94; // int32_t
    constexpr std::ptrdiff_t m_iFrictionAnimState = 0xE98; // int32_t
    constexpr std::ptrdiff_t m_bReleaseRagdoll = 0xE9C; // bool
    constexpr std::ptrdiff_t m_iEyeAttachment = 0xE9D; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_bFadingOut = 0xE9E; // bool
    constexpr std::ptrdiff_t m_flScaleEnd = 0xEA0; // float[10]
    constexpr std::ptrdiff_t m_flScaleTimeStart = 0xEC8; // GameTime_t[10]
    constexpr std::ptrdiff_t m_flScaleTimeEnd = 0xEF0; // GameTime_t[10]
}

namespace C_ColorCorrection {
    constexpr std::ptrdiff_t m_vecOrigin = 0x540; // Vector
    constexpr std::ptrdiff_t m_MinFalloff = 0x54C; // float
    constexpr std::ptrdiff_t m_MaxFalloff = 0x550; // float
    constexpr std::ptrdiff_t m_flFadeInDuration = 0x554; // float
    constexpr std::ptrdiff_t m_flFadeOutDuration = 0x558; // float
    constexpr std::ptrdiff_t m_flMaxWeight = 0x55C; // float
    constexpr std::ptrdiff_t m_flCurWeight = 0x560; // float
    constexpr std::ptrdiff_t m_netlookupFilename = 0x564; // char[512]
    constexpr std::ptrdiff_t m_bEnabled = 0x764; // bool
    constexpr std::ptrdiff_t m_bMaster = 0x765; // bool
    constexpr std::ptrdiff_t m_bClientSide = 0x766; // bool
    constexpr std::ptrdiff_t m_bExclusive = 0x767; // bool
    constexpr std::ptrdiff_t m_bEnabledOnClient = 0x768; // bool[1]
    constexpr std::ptrdiff_t m_flCurWeightOnClient = 0x76C; // float[1]
    constexpr std::ptrdiff_t m_bFadingIn = 0x770; // bool[1]
    constexpr std::ptrdiff_t m_flFadeStartWeight = 0x774; // float[1]
    constexpr std::ptrdiff_t m_flFadeStartTime = 0x778; // float[1]
    constexpr std::ptrdiff_t m_flFadeDuration = 0x77C; // float[1]
}

namespace C_ColorCorrectionVolume {
    constexpr std::ptrdiff_t m_LastEnterWeight = 0xCC8; // float
    constexpr std::ptrdiff_t m_LastEnterTime = 0xCCC; // float
    constexpr std::ptrdiff_t m_LastExitWeight = 0xCD0; // float
    constexpr std::ptrdiff_t m_LastExitTime = 0xCD4; // float
    constexpr std::ptrdiff_t m_bEnabled = 0xCD8; // bool
    constexpr std::ptrdiff_t m_MaxWeight = 0xCDC; // float
    constexpr std::ptrdiff_t m_FadeDuration = 0xCE0; // float
    constexpr std::ptrdiff_t m_Weight = 0xCE4; // float
    constexpr std::ptrdiff_t m_lookupFilename = 0xCE8; // char[512]
}

namespace C_CommandContext {
    constexpr std::ptrdiff_t needsprocessing = 0x0; // bool
    constexpr std::ptrdiff_t command_number = 0xA8; // int32_t
}

namespace C_CsmFovOverride {
    constexpr std::ptrdiff_t m_cameraName = 0x540; // CUtlString
    constexpr std::ptrdiff_t m_flCsmFovOverrideValue = 0x548; // float
}

namespace C_DecoyProjectile {
    constexpr std::ptrdiff_t m_nDecoyShotTick = 0x1100; // int32_t
    constexpr std::ptrdiff_t m_nClientLastKnownDecoyShotTick = 0x1104; // int32_t
    constexpr std::ptrdiff_t m_flTimeParticleEffectSpawn = 0x1128; // GameTime_t
}

namespace C_DynamicLight {
    constexpr std::ptrdiff_t m_Flags = 0xCC0; // uint8_t
    constexpr std::ptrdiff_t m_LightStyle = 0xCC1; // uint8_t
    constexpr std::ptrdiff_t m_Radius = 0xCC4; // float
    constexpr std::ptrdiff_t m_Exponent = 0xCC8; // int32_t
    constexpr std::ptrdiff_t m_InnerAngle = 0xCCC; // float
    constexpr std::ptrdiff_t m_OuterAngle = 0xCD0; // float
    constexpr std::ptrdiff_t m_SpotRadius = 0xCD4; // float
}

namespace C_DynamicProp {
    constexpr std::ptrdiff_t m_bUseHitboxesForRenderBox = 0xFD0; // bool
    constexpr std::ptrdiff_t m_bUseAnimGraph = 0xFD1; // bool
    constexpr std::ptrdiff_t m_pOutputAnimBegun = 0xFD8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_pOutputAnimOver = 0x1000; // CEntityIOOutput
    constexpr std::ptrdiff_t m_pOutputAnimLoopCycleOver = 0x1028; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnAnimReachedStart = 0x1050; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnAnimReachedEnd = 0x1078; // CEntityIOOutput
    constexpr std::ptrdiff_t m_iszDefaultAnim = 0x10A0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nDefaultAnimLoopMode = 0x10A8; // AnimLoopMode_t
    constexpr std::ptrdiff_t m_bAnimateOnServer = 0x10AC; // bool
    constexpr std::ptrdiff_t m_bRandomizeCycle = 0x10AD; // bool
    constexpr std::ptrdiff_t m_bStartDisabled = 0x10AE; // bool
    constexpr std::ptrdiff_t m_bScriptedMovement = 0x10AF; // bool
    constexpr std::ptrdiff_t m_bFiredStartEndOutput = 0x10B0; // bool
    constexpr std::ptrdiff_t m_bForceNpcExclude = 0x10B1; // bool
    constexpr std::ptrdiff_t m_bCreateNonSolid = 0x10B2; // bool
    constexpr std::ptrdiff_t m_bIsOverrideProp = 0x10B3; // bool
    constexpr std::ptrdiff_t m_iInitialGlowState = 0x10B4; // int32_t
    constexpr std::ptrdiff_t m_nGlowRange = 0x10B8; // int32_t
    constexpr std::ptrdiff_t m_nGlowRangeMin = 0x10BC; // int32_t
    constexpr std::ptrdiff_t m_glowColor = 0x10C0; // Color
    constexpr std::ptrdiff_t m_nGlowTeam = 0x10C4; // int32_t
    constexpr std::ptrdiff_t m_iCachedFrameCount = 0x10C8; // int32_t
    constexpr std::ptrdiff_t m_vecCachedRenderMins = 0x10CC; // Vector
    constexpr std::ptrdiff_t m_vecCachedRenderMaxs = 0x10D8; // Vector
}

namespace C_EconEntity {
    constexpr std::ptrdiff_t m_flFlexDelayTime = 0x1028; // float
    constexpr std::ptrdiff_t m_flFlexDelayedWeight = 0x1030; // float*
    constexpr std::ptrdiff_t m_bAttributesInitialized = 0x1038; // bool
    constexpr std::ptrdiff_t m_AttributeManager = 0x1040; // C_AttributeContainer
    constexpr std::ptrdiff_t m_OriginalOwnerXuidLow = 0x14E8; // uint32_t
    constexpr std::ptrdiff_t m_OriginalOwnerXuidHigh = 0x14EC; // uint32_t
    constexpr std::ptrdiff_t m_nFallbackPaintKit = 0x14F0; // int32_t
    constexpr std::ptrdiff_t m_nFallbackSeed = 0x14F4; // int32_t
    constexpr std::ptrdiff_t m_flFallbackWear = 0x14F8; // float
    constexpr std::ptrdiff_t m_nFallbackStatTrak = 0x14FC; // int32_t
    constexpr std::ptrdiff_t m_bClientside = 0x1500; // bool
    constexpr std::ptrdiff_t m_bParticleSystemsCreated = 0x1501; // bool
    constexpr std::ptrdiff_t m_vecAttachedParticles = 0x1508; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_hViewmodelAttachment = 0x1520; // CHandle<CBaseAnimGraph>
    constexpr std::ptrdiff_t m_iOldTeam = 0x1524; // int32_t
    constexpr std::ptrdiff_t m_bAttachmentDirty = 0x1528; // bool
    constexpr std::ptrdiff_t m_nUnloadedModelIndex = 0x152C; // int32_t
    constexpr std::ptrdiff_t m_iNumOwnerValidationRetries = 0x1530; // int32_t
    constexpr std::ptrdiff_t m_hOldProvidee = 0x1540; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_vecAttachedModels = 0x1548; // CUtlVector<C_EconEntity::AttachedModelData_t>
}

namespace C_EconEntity_AttachedModelData_t {
    constexpr std::ptrdiff_t m_iModelDisplayFlags = 0x0; // int32_t
}

namespace C_EconItemView {
    constexpr std::ptrdiff_t m_bInventoryImageRgbaRequested = 0x60; // bool
    constexpr std::ptrdiff_t m_bInventoryImageTriedCache = 0x61; // bool
    constexpr std::ptrdiff_t m_nInventoryImageRgbaWidth = 0x80; // int32_t
    constexpr std::ptrdiff_t m_nInventoryImageRgbaHeight = 0x84; // int32_t
    constexpr std::ptrdiff_t m_szCurrentLoadCachedFileName = 0x88; // char[260]
    constexpr std::ptrdiff_t m_bRestoreCustomMaterialAfterPrecache = 0x1B8; // bool
    constexpr std::ptrdiff_t m_iItemDefinitionIndex = 0x1BA; // uint16_t
    constexpr std::ptrdiff_t m_iEntityQuality = 0x1BC; // int32_t
    constexpr std::ptrdiff_t m_iEntityLevel = 0x1C0; // uint32_t
    constexpr std::ptrdiff_t m_iItemID = 0x1C8; // uint64_t
    constexpr std::ptrdiff_t m_iItemIDHigh = 0x1D0; // uint32_t
    constexpr std::ptrdiff_t m_iItemIDLow = 0x1D4; // uint32_t
    constexpr std::ptrdiff_t m_iAccountID = 0x1D8; // uint32_t
    constexpr std::ptrdiff_t m_iInventoryPosition = 0x1DC; // uint32_t
    constexpr std::ptrdiff_t m_bInitialized = 0x1E8; // bool
    constexpr std::ptrdiff_t m_bIsStoreItem = 0x1E9; // bool
    constexpr std::ptrdiff_t m_bIsTradeItem = 0x1EA; // bool
    constexpr std::ptrdiff_t m_iEntityQuantity = 0x1EC; // int32_t
    constexpr std::ptrdiff_t m_iRarityOverride = 0x1F0; // int32_t
    constexpr std::ptrdiff_t m_iQualityOverride = 0x1F4; // int32_t
    constexpr std::ptrdiff_t m_unClientFlags = 0x1F8; // uint8_t
    constexpr std::ptrdiff_t m_unOverrideStyle = 0x1F9; // uint8_t
    constexpr std::ptrdiff_t m_AttributeList = 0x210; // CAttributeList
    constexpr std::ptrdiff_t m_NetworkedDynamicAttributes = 0x270; // CAttributeList
    constexpr std::ptrdiff_t m_szCustomName = 0x2D0; // char[161]
    constexpr std::ptrdiff_t m_szCustomNameOverride = 0x371; // char[161]
    constexpr std::ptrdiff_t m_bInitializedTags = 0x440; // bool
}

namespace C_EconWearable {
    constexpr std::ptrdiff_t m_nForceSkin = 0x1560; // int32_t
    constexpr std::ptrdiff_t m_bAlwaysAllow = 0x1564; // bool
}

namespace C_EntityDissolve {
    constexpr std::ptrdiff_t m_flStartTime = 0xCC8; // GameTime_t
    constexpr std::ptrdiff_t m_flFadeInStart = 0xCCC; // float
    constexpr std::ptrdiff_t m_flFadeInLength = 0xCD0; // float
    constexpr std::ptrdiff_t m_flFadeOutModelStart = 0xCD4; // float
    constexpr std::ptrdiff_t m_flFadeOutModelLength = 0xCD8; // float
    constexpr std::ptrdiff_t m_flFadeOutStart = 0xCDC; // float
    constexpr std::ptrdiff_t m_flFadeOutLength = 0xCE0; // float
    constexpr std::ptrdiff_t m_flNextSparkTime = 0xCE4; // GameTime_t
    constexpr std::ptrdiff_t m_nDissolveType = 0xCE8; // EntityDisolveType_t
    constexpr std::ptrdiff_t m_vDissolverOrigin = 0xCEC; // Vector
    constexpr std::ptrdiff_t m_nMagnitude = 0xCF8; // uint32_t
    constexpr std::ptrdiff_t m_bCoreExplode = 0xCFC; // bool
    constexpr std::ptrdiff_t m_bLinkedToServerEnt = 0xCFD; // bool
}

namespace C_EntityFlame {
    constexpr std::ptrdiff_t m_hEntAttached = 0x540; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_hOldAttached = 0x568; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_bCheapEffect = 0x56C; // bool
}

namespace C_EnvCombinedLightProbeVolume {
    constexpr std::ptrdiff_t m_Color = 0x1598; // Color
    constexpr std::ptrdiff_t m_flBrightness = 0x159C; // float
    constexpr std::ptrdiff_t m_hCubemapTexture = 0x15A0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_bCustomCubemapTexture = 0x15A8; // bool
    constexpr std::ptrdiff_t m_hLightProbeTexture = 0x15B0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightIndicesTexture = 0x15B8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightScalarsTexture = 0x15C0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightShadowsTexture = 0x15C8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_vBoxMins = 0x15D0; // Vector
    constexpr std::ptrdiff_t m_vBoxMaxs = 0x15DC; // Vector
    constexpr std::ptrdiff_t m_bMoveable = 0x15E8; // bool
    constexpr std::ptrdiff_t m_nHandshake = 0x15EC; // int32_t
    constexpr std::ptrdiff_t m_nEnvCubeMapArrayIndex = 0x15F0; // int32_t
    constexpr std::ptrdiff_t m_nPriority = 0x15F4; // int32_t
    constexpr std::ptrdiff_t m_bStartDisabled = 0x15F8; // bool
    constexpr std::ptrdiff_t m_flEdgeFadeDist = 0x15FC; // float
    constexpr std::ptrdiff_t m_vEdgeFadeDists = 0x1600; // Vector
    constexpr std::ptrdiff_t m_nLightProbeSizeX = 0x160C; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeSizeY = 0x1610; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeSizeZ = 0x1614; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasX = 0x1618; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasY = 0x161C; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasZ = 0x1620; // int32_t
    constexpr std::ptrdiff_t m_bEnabled = 0x1639; // bool
}

namespace C_EnvCubemap {
    constexpr std::ptrdiff_t m_hCubemapTexture = 0x5C0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_bCustomCubemapTexture = 0x5C8; // bool
    constexpr std::ptrdiff_t m_flInfluenceRadius = 0x5CC; // float
    constexpr std::ptrdiff_t m_vBoxProjectMins = 0x5D0; // Vector
    constexpr std::ptrdiff_t m_vBoxProjectMaxs = 0x5DC; // Vector
    constexpr std::ptrdiff_t m_bMoveable = 0x5E8; // bool
    constexpr std::ptrdiff_t m_nHandshake = 0x5EC; // int32_t
    constexpr std::ptrdiff_t m_nEnvCubeMapArrayIndex = 0x5F0; // int32_t
    constexpr std::ptrdiff_t m_nPriority = 0x5F4; // int32_t
    constexpr std::ptrdiff_t m_flEdgeFadeDist = 0x5F8; // float
    constexpr std::ptrdiff_t m_vEdgeFadeDists = 0x5FC; // Vector
    constexpr std::ptrdiff_t m_flDiffuseScale = 0x608; // float
    constexpr std::ptrdiff_t m_bStartDisabled = 0x60C; // bool
    constexpr std::ptrdiff_t m_bDefaultEnvMap = 0x60D; // bool
    constexpr std::ptrdiff_t m_bDefaultSpecEnvMap = 0x60E; // bool
    constexpr std::ptrdiff_t m_bIndoorCubeMap = 0x60F; // bool
    constexpr std::ptrdiff_t m_bCopyDiffuseFromDefaultCubemap = 0x610; // bool
    constexpr std::ptrdiff_t m_bEnabled = 0x620; // bool
}

namespace C_EnvCubemapFog {
    constexpr std::ptrdiff_t m_flEndDistance = 0x540; // float
    constexpr std::ptrdiff_t m_flStartDistance = 0x544; // float
    constexpr std::ptrdiff_t m_flFogFalloffExponent = 0x548; // float
    constexpr std::ptrdiff_t m_bHeightFogEnabled = 0x54C; // bool
    constexpr std::ptrdiff_t m_flFogHeightWidth = 0x550; // float
    constexpr std::ptrdiff_t m_flFogHeightEnd = 0x554; // float
    constexpr std::ptrdiff_t m_flFogHeightStart = 0x558; // float
    constexpr std::ptrdiff_t m_flFogHeightExponent = 0x55C; // float
    constexpr std::ptrdiff_t m_flLODBias = 0x560; // float
    constexpr std::ptrdiff_t m_bActive = 0x564; // bool
    constexpr std::ptrdiff_t m_bStartDisabled = 0x565; // bool
    constexpr std::ptrdiff_t m_flFogMaxOpacity = 0x568; // float
    constexpr std::ptrdiff_t m_nCubemapSourceType = 0x56C; // int32_t
    constexpr std::ptrdiff_t m_hSkyMaterial = 0x570; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_iszSkyEntity = 0x578; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hFogCubemapTexture = 0x580; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_bHasHeightFogEnd = 0x588; // bool
    constexpr std::ptrdiff_t m_bFirstTime = 0x589; // bool
}

namespace C_EnvDecal {
    constexpr std::ptrdiff_t m_hDecalMaterial = 0xCC0; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_flWidth = 0xCC8; // float
    constexpr std::ptrdiff_t m_flHeight = 0xCCC; // float
    constexpr std::ptrdiff_t m_flDepth = 0xCD0; // float
    constexpr std::ptrdiff_t m_nRenderOrder = 0xCD4; // uint32_t
    constexpr std::ptrdiff_t m_bProjectOnWorld = 0xCD8; // bool
    constexpr std::ptrdiff_t m_bProjectOnCharacters = 0xCD9; // bool
    constexpr std::ptrdiff_t m_bProjectOnWater = 0xCDA; // bool
    constexpr std::ptrdiff_t m_flDepthSortBias = 0xCDC; // float
}

namespace C_EnvDetailController {
    constexpr std::ptrdiff_t m_flFadeStartDist = 0x540; // float
    constexpr std::ptrdiff_t m_flFadeEndDist = 0x544; // float
}

namespace C_EnvLightProbeVolume {
    constexpr std::ptrdiff_t m_hLightProbeTexture = 0x1518; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightIndicesTexture = 0x1520; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightScalarsTexture = 0x1528; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightShadowsTexture = 0x1530; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_vBoxMins = 0x1538; // Vector
    constexpr std::ptrdiff_t m_vBoxMaxs = 0x1544; // Vector
    constexpr std::ptrdiff_t m_bMoveable = 0x1550; // bool
    constexpr std::ptrdiff_t m_nHandshake = 0x1554; // int32_t
    constexpr std::ptrdiff_t m_nPriority = 0x1558; // int32_t
    constexpr std::ptrdiff_t m_bStartDisabled = 0x155C; // bool
    constexpr std::ptrdiff_t m_nLightProbeSizeX = 0x1560; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeSizeY = 0x1564; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeSizeZ = 0x1568; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasX = 0x156C; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasY = 0x1570; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasZ = 0x1574; // int32_t
    constexpr std::ptrdiff_t m_bEnabled = 0x1581; // bool
}

namespace C_EnvParticleGlow {
    constexpr std::ptrdiff_t m_flAlphaScale = 0x1270; // float
    constexpr std::ptrdiff_t m_flRadiusScale = 0x1274; // float
    constexpr std::ptrdiff_t m_flSelfIllumScale = 0x1278; // float
    constexpr std::ptrdiff_t m_ColorTint = 0x127C; // Color
    constexpr std::ptrdiff_t m_hTextureOverride = 0x1280; // CStrongHandle<InfoForResourceTypeCTextureBase>
}

namespace C_EnvScreenOverlay {
    constexpr std::ptrdiff_t m_iszOverlayNames = 0x540; // CUtlSymbolLarge[10]
    constexpr std::ptrdiff_t m_flOverlayTimes = 0x590; // float[10]
    constexpr std::ptrdiff_t m_flStartTime = 0x5B8; // GameTime_t
    constexpr std::ptrdiff_t m_iDesiredOverlay = 0x5BC; // int32_t
    constexpr std::ptrdiff_t m_bIsActive = 0x5C0; // bool
    constexpr std::ptrdiff_t m_bWasActive = 0x5C1; // bool
    constexpr std::ptrdiff_t m_iCachedDesiredOverlay = 0x5C4; // int32_t
    constexpr std::ptrdiff_t m_iCurrentOverlay = 0x5C8; // int32_t
    constexpr std::ptrdiff_t m_flCurrentOverlayTime = 0x5CC; // GameTime_t
}

namespace C_EnvSky {
    constexpr std::ptrdiff_t m_hSkyMaterial = 0xCC0; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_hSkyMaterialLightingOnly = 0xCC8; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_bStartDisabled = 0xCD0; // bool
    constexpr std::ptrdiff_t m_vTintColor = 0xCD1; // Color
    constexpr std::ptrdiff_t m_vTintColorLightingOnly = 0xCD5; // Color
    constexpr std::ptrdiff_t m_flBrightnessScale = 0xCDC; // float
    constexpr std::ptrdiff_t m_nFogType = 0xCE0; // int32_t
    constexpr std::ptrdiff_t m_flFogMinStart = 0xCE4; // float
    constexpr std::ptrdiff_t m_flFogMinEnd = 0xCE8; // float
    constexpr std::ptrdiff_t m_flFogMaxStart = 0xCEC; // float
    constexpr std::ptrdiff_t m_flFogMaxEnd = 0xCF0; // float
    constexpr std::ptrdiff_t m_bEnabled = 0xCF4; // bool
}

namespace C_EnvVolumetricFogController {
    constexpr std::ptrdiff_t m_flScattering = 0x540; // float
    constexpr std::ptrdiff_t m_flAnisotropy = 0x544; // float
    constexpr std::ptrdiff_t m_flFadeSpeed = 0x548; // float
    constexpr std::ptrdiff_t m_flDrawDistance = 0x54C; // float
    constexpr std::ptrdiff_t m_flFadeInStart = 0x550; // float
    constexpr std::ptrdiff_t m_flFadeInEnd = 0x554; // float
    constexpr std::ptrdiff_t m_flIndirectStrength = 0x558; // float
    constexpr std::ptrdiff_t m_nIndirectTextureDimX = 0x55C; // int32_t
    constexpr std::ptrdiff_t m_nIndirectTextureDimY = 0x560; // int32_t
    constexpr std::ptrdiff_t m_nIndirectTextureDimZ = 0x564; // int32_t
    constexpr std::ptrdiff_t m_vBoxMins = 0x568; // Vector
    constexpr std::ptrdiff_t m_vBoxMaxs = 0x574; // Vector
    constexpr std::ptrdiff_t m_bActive = 0x580; // bool
    constexpr std::ptrdiff_t m_flStartAnisoTime = 0x584; // GameTime_t
    constexpr std::ptrdiff_t m_flStartScatterTime = 0x588; // GameTime_t
    constexpr std::ptrdiff_t m_flStartDrawDistanceTime = 0x58C; // GameTime_t
    constexpr std::ptrdiff_t m_flStartAnisotropy = 0x590; // float
    constexpr std::ptrdiff_t m_flStartScattering = 0x594; // float
    constexpr std::ptrdiff_t m_flStartDrawDistance = 0x598; // float
    constexpr std::ptrdiff_t m_flDefaultAnisotropy = 0x59C; // float
    constexpr std::ptrdiff_t m_flDefaultScattering = 0x5A0; // float
    constexpr std::ptrdiff_t m_flDefaultDrawDistance = 0x5A4; // float
    constexpr std::ptrdiff_t m_bStartDisabled = 0x5A8; // bool
    constexpr std::ptrdiff_t m_bEnableIndirect = 0x5A9; // bool
    constexpr std::ptrdiff_t m_bIsMaster = 0x5AA; // bool
    constexpr std::ptrdiff_t m_hFogIndirectTexture = 0x5B0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_nForceRefreshCount = 0x5B8; // int32_t
    constexpr std::ptrdiff_t m_bFirstTime = 0x5BC; // bool
}

namespace C_EnvVolumetricFogVolume {
    constexpr std::ptrdiff_t m_bActive = 0x540; // bool
    constexpr std::ptrdiff_t m_vBoxMins = 0x544; // Vector
    constexpr std::ptrdiff_t m_vBoxMaxs = 0x550; // Vector
    constexpr std::ptrdiff_t m_bStartDisabled = 0x55C; // bool
    constexpr std::ptrdiff_t m_flStrength = 0x560; // float
    constexpr std::ptrdiff_t m_nFalloffShape = 0x564; // int32_t
    constexpr std::ptrdiff_t m_flFalloffExponent = 0x568; // float
}

namespace C_EnvWind {
    constexpr std::ptrdiff_t m_EnvWindShared = 0x540; // C_EnvWindShared
}

namespace C_EnvWindClientside {
    constexpr std::ptrdiff_t m_EnvWindShared = 0x540; // C_EnvWindShared
}

namespace C_EnvWindShared {
    constexpr std::ptrdiff_t m_flStartTime = 0x8; // GameTime_t
    constexpr std::ptrdiff_t m_iWindSeed = 0xC; // uint32_t
    constexpr std::ptrdiff_t m_iMinWind = 0x10; // uint16_t
    constexpr std::ptrdiff_t m_iMaxWind = 0x12; // uint16_t
    constexpr std::ptrdiff_t m_windRadius = 0x14; // int32_t
    constexpr std::ptrdiff_t m_iMinGust = 0x18; // uint16_t
    constexpr std::ptrdiff_t m_iMaxGust = 0x1A; // uint16_t
    constexpr std::ptrdiff_t m_flMinGustDelay = 0x1C; // float
    constexpr std::ptrdiff_t m_flMaxGustDelay = 0x20; // float
    constexpr std::ptrdiff_t m_flGustDuration = 0x24; // float
    constexpr std::ptrdiff_t m_iGustDirChange = 0x28; // uint16_t
    constexpr std::ptrdiff_t m_location = 0x2C; // Vector
    constexpr std::ptrdiff_t m_iszGustSound = 0x38; // int32_t
    constexpr std::ptrdiff_t m_iWindDir = 0x3C; // int32_t
    constexpr std::ptrdiff_t m_flWindSpeed = 0x40; // float
    constexpr std::ptrdiff_t m_currentWindVector = 0x44; // Vector
    constexpr std::ptrdiff_t m_CurrentSwayVector = 0x50; // Vector
    constexpr std::ptrdiff_t m_PrevSwayVector = 0x5C; // Vector
    constexpr std::ptrdiff_t m_iInitialWindDir = 0x68; // uint16_t
    constexpr std::ptrdiff_t m_flInitialWindSpeed = 0x6C; // float
    constexpr std::ptrdiff_t m_flVariationTime = 0x70; // GameTime_t
    constexpr std::ptrdiff_t m_flSwayTime = 0x74; // GameTime_t
    constexpr std::ptrdiff_t m_flSimTime = 0x78; // GameTime_t
    constexpr std::ptrdiff_t m_flSwitchTime = 0x7C; // GameTime_t
    constexpr std::ptrdiff_t m_flAveWindSpeed = 0x80; // float
    constexpr std::ptrdiff_t m_bGusting = 0x84; // bool
    constexpr std::ptrdiff_t m_flWindAngleVariation = 0x88; // float
    constexpr std::ptrdiff_t m_flWindSpeedVariation = 0x8C; // float
    constexpr std::ptrdiff_t m_iEntIndex = 0x90; // CEntityIndex
}

namespace C_EnvWindShared_WindAveEvent_t {
    constexpr std::ptrdiff_t m_flStartWindSpeed = 0x0; // float
    constexpr std::ptrdiff_t m_flAveWindSpeed = 0x4; // float
}

namespace C_EnvWindShared_WindVariationEvent_t {
    constexpr std::ptrdiff_t m_flWindAngleVariation = 0x0; // float
    constexpr std::ptrdiff_t m_flWindSpeedVariation = 0x4; // float
}

namespace C_FireSmoke {
    constexpr std::ptrdiff_t m_nFlameModelIndex = 0x550; // int32_t
    constexpr std::ptrdiff_t m_nFlameFromAboveModelIndex = 0x554; // int32_t
    constexpr std::ptrdiff_t m_flScaleRegister = 0x558; // float
    constexpr std::ptrdiff_t m_flScaleStart = 0x55C; // float
    constexpr std::ptrdiff_t m_flScaleEnd = 0x560; // float
    constexpr std::ptrdiff_t m_flScaleTimeStart = 0x564; // GameTime_t
    constexpr std::ptrdiff_t m_flScaleTimeEnd = 0x568; // GameTime_t
    constexpr std::ptrdiff_t m_flChildFlameSpread = 0x56C; // float
    constexpr std::ptrdiff_t m_flClipPerc = 0x580; // float
    constexpr std::ptrdiff_t m_bClipTested = 0x584; // bool
    constexpr std::ptrdiff_t m_bFadingOut = 0x585; // bool
    constexpr std::ptrdiff_t m_tParticleSpawn = 0x588; // TimedEvent
    constexpr std::ptrdiff_t m_pFireOverlay = 0x590; // CFireOverlay*
}

namespace C_FireSprite {
    constexpr std::ptrdiff_t m_vecMoveDir = 0xDF0; // Vector
    constexpr std::ptrdiff_t m_bFadeFromAbove = 0xDFC; // bool
}

namespace C_Fish {
    constexpr std::ptrdiff_t m_pos = 0xE80; // Vector
    constexpr std::ptrdiff_t m_vel = 0xE8C; // Vector
    constexpr std::ptrdiff_t m_angles = 0xE98; // QAngle
    constexpr std::ptrdiff_t m_localLifeState = 0xEA4; // int32_t
    constexpr std::ptrdiff_t m_deathDepth = 0xEA8; // float
    constexpr std::ptrdiff_t m_deathAngle = 0xEAC; // float
    constexpr std::ptrdiff_t m_buoyancy = 0xEB0; // float
    constexpr std::ptrdiff_t m_wiggleTimer = 0xEB8; // CountdownTimer
    constexpr std::ptrdiff_t m_wigglePhase = 0xED0; // float
    constexpr std::ptrdiff_t m_wiggleRate = 0xED4; // float
    constexpr std::ptrdiff_t m_actualPos = 0xED8; // Vector
    constexpr std::ptrdiff_t m_actualAngles = 0xEE4; // QAngle
    constexpr std::ptrdiff_t m_poolOrigin = 0xEF0; // Vector
    constexpr std::ptrdiff_t m_waterLevel = 0xEFC; // float
    constexpr std::ptrdiff_t m_gotUpdate = 0xF00; // bool
    constexpr std::ptrdiff_t m_x = 0xF04; // float
    constexpr std::ptrdiff_t m_y = 0xF08; // float
    constexpr std::ptrdiff_t m_z = 0xF0C; // float
    constexpr std::ptrdiff_t m_angle = 0xF10; // float
    constexpr std::ptrdiff_t m_errorHistory = 0xF14; // float[20]
    constexpr std::ptrdiff_t m_errorHistoryIndex = 0xF64; // int32_t
    constexpr std::ptrdiff_t m_errorHistoryCount = 0xF68; // int32_t
    constexpr std::ptrdiff_t m_averageError = 0xF6C; // float
}

namespace C_Fists {
    constexpr std::ptrdiff_t m_bPlayingUninterruptableAct = 0x19F0; // bool
    constexpr std::ptrdiff_t m_nUninterruptableActivity = 0x19F4; // PlayerAnimEvent_t
}

namespace C_FogController {
    constexpr std::ptrdiff_t m_fog = 0x540; // fogparams_t
    constexpr std::ptrdiff_t m_bUseAngles = 0x5A8; // bool
    constexpr std::ptrdiff_t m_iChangedVariables = 0x5AC; // int32_t
}

namespace C_FootstepControl {
    constexpr std::ptrdiff_t m_source = 0xCC8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_destination = 0xCD0; // CUtlSymbolLarge
}

namespace C_FuncConveyor {
    constexpr std::ptrdiff_t m_vecMoveDirEntitySpace = 0xCC8; // Vector
    constexpr std::ptrdiff_t m_flTargetSpeed = 0xCD4; // float
    constexpr std::ptrdiff_t m_nTransitionStartTick = 0xCD8; // GameTick_t
    constexpr std::ptrdiff_t m_nTransitionDurationTicks = 0xCDC; // int32_t
    constexpr std::ptrdiff_t m_flTransitionStartSpeed = 0xCE0; // float
    constexpr std::ptrdiff_t m_hConveyorModels = 0xCE8; // C_NetworkUtlVectorBase<CHandle<C_BaseEntity>>
    constexpr std::ptrdiff_t m_flCurrentConveyorOffset = 0xD00; // float
    constexpr std::ptrdiff_t m_flCurrentConveyorSpeed = 0xD04; // float
}

namespace C_FuncElectrifiedVolume {
    constexpr std::ptrdiff_t m_nAmbientEffect = 0xCC0; // ParticleIndex_t
    constexpr std::ptrdiff_t m_EffectName = 0xCC8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bState = 0xCD0; // bool
}

namespace C_FuncLadder {
    constexpr std::ptrdiff_t m_vecLadderDir = 0xCC0; // Vector
    constexpr std::ptrdiff_t m_Dismounts = 0xCD0; // CUtlVector<CHandle<C_InfoLadderDismount>>
    constexpr std::ptrdiff_t m_vecLocalTop = 0xCE8; // Vector
    constexpr std::ptrdiff_t m_vecPlayerMountPositionTop = 0xCF4; // Vector
    constexpr std::ptrdiff_t m_vecPlayerMountPositionBottom = 0xD00; // Vector
    constexpr std::ptrdiff_t m_flAutoRideSpeed = 0xD0C; // float
    constexpr std::ptrdiff_t m_bDisabled = 0xD10; // bool
    constexpr std::ptrdiff_t m_bFakeLadder = 0xD11; // bool
    constexpr std::ptrdiff_t m_bHasSlack = 0xD12; // bool
}

namespace C_FuncMonitor {
    constexpr std::ptrdiff_t m_targetCamera = 0xCC0; // CUtlString
    constexpr std::ptrdiff_t m_nResolutionEnum = 0xCC8; // int32_t
    constexpr std::ptrdiff_t m_bRenderShadows = 0xCCC; // bool
    constexpr std::ptrdiff_t m_bUseUniqueColorTarget = 0xCCD; // bool
    constexpr std::ptrdiff_t m_brushModelName = 0xCD0; // CUtlString
    constexpr std::ptrdiff_t m_hTargetCamera = 0xCD8; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_bEnabled = 0xCDC; // bool
    constexpr std::ptrdiff_t m_bDraw3DSkybox = 0xCDD; // bool
}

namespace C_FuncTrackTrain {
    constexpr std::ptrdiff_t m_nLongAxis = 0xCC0; // int32_t
    constexpr std::ptrdiff_t m_flRadius = 0xCC4; // float
    constexpr std::ptrdiff_t m_flLineLength = 0xCC8; // float
}

namespace C_GlobalLight {
    constexpr std::ptrdiff_t m_WindClothForceHandle = 0xA00; // uint16_t
}

namespace C_GradientFog {
    constexpr std::ptrdiff_t m_hGradientFogTexture = 0x540; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_flFogStartDistance = 0x548; // float
    constexpr std::ptrdiff_t m_flFogEndDistance = 0x54C; // float
    constexpr std::ptrdiff_t m_bHeightFogEnabled = 0x550; // bool
    constexpr std::ptrdiff_t m_flFogStartHeight = 0x554; // float
    constexpr std::ptrdiff_t m_flFogEndHeight = 0x558; // float
    constexpr std::ptrdiff_t m_flFarZ = 0x55C; // float
    constexpr std::ptrdiff_t m_flFogMaxOpacity = 0x560; // float
    constexpr std::ptrdiff_t m_flFogFalloffExponent = 0x564; // float
    constexpr std::ptrdiff_t m_flFogVerticalExponent = 0x568; // float
    constexpr std::ptrdiff_t m_fogColor = 0x56C; // Color
    constexpr std::ptrdiff_t m_flFogStrength = 0x570; // float
    constexpr std::ptrdiff_t m_flFadeTime = 0x574; // float
    constexpr std::ptrdiff_t m_bStartDisabled = 0x578; // bool
    constexpr std::ptrdiff_t m_bIsEnabled = 0x579; // bool
    constexpr std::ptrdiff_t m_bGradientFogNeedsTextures = 0x57A; // bool
}

namespace C_HandleTest {
    constexpr std::ptrdiff_t m_Handle = 0x540; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_bSendHandle = 0x544; // bool
}

namespace C_Hostage {
    constexpr std::ptrdiff_t m_entitySpottedState = 0x10A8; // EntitySpottedState_t
    constexpr std::ptrdiff_t m_leader = 0x10C0; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_reuseTimer = 0x10C8; // CountdownTimer
    constexpr std::ptrdiff_t m_vel = 0x10E0; // Vector
    constexpr std::ptrdiff_t m_isRescued = 0x10EC; // bool
    constexpr std::ptrdiff_t m_jumpedThisFrame = 0x10ED; // bool
    constexpr std::ptrdiff_t m_nHostageState = 0x10F0; // int32_t
    constexpr std::ptrdiff_t m_bHandsHaveBeenCut = 0x10F4; // bool
    constexpr std::ptrdiff_t m_hHostageGrabber = 0x10F8; // CHandle<C_CSPlayerPawn>
    constexpr std::ptrdiff_t m_fLastGrabTime = 0x10FC; // GameTime_t
    constexpr std::ptrdiff_t m_vecGrabbedPos = 0x1100; // Vector
    constexpr std::ptrdiff_t m_flRescueStartTime = 0x110C; // GameTime_t
    constexpr std::ptrdiff_t m_flGrabSuccessTime = 0x1110; // GameTime_t
    constexpr std::ptrdiff_t m_flDropStartTime = 0x1114; // GameTime_t
    constexpr std::ptrdiff_t m_flDeadOrRescuedTime = 0x1118; // GameTime_t
    constexpr std::ptrdiff_t m_blinkTimer = 0x1120; // CountdownTimer
    constexpr std::ptrdiff_t m_lookAt = 0x1138; // Vector
    constexpr std::ptrdiff_t m_lookAroundTimer = 0x1148; // CountdownTimer
    constexpr std::ptrdiff_t m_isInit = 0x1160; // bool
    constexpr std::ptrdiff_t m_eyeAttachment = 0x1161; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_chestAttachment = 0x1162; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_pPredictionOwner = 0x1168; // CBasePlayerController*
    constexpr std::ptrdiff_t m_fNewestAlphaThinkTime = 0x1170; // GameTime_t
}

namespace C_Inferno {
    constexpr std::ptrdiff_t m_nfxFireDamageEffect = 0xD00; // ParticleIndex_t
    constexpr std::ptrdiff_t m_firePositions = 0xD04; // Vector[64]
    constexpr std::ptrdiff_t m_fireParentPositions = 0x1004; // Vector[64]
    constexpr std::ptrdiff_t m_bFireIsBurning = 0x1304; // bool[64]
    constexpr std::ptrdiff_t m_BurnNormal = 0x1344; // Vector[64]
    constexpr std::ptrdiff_t m_fireCount = 0x1644; // int32_t
    constexpr std::ptrdiff_t m_nInfernoType = 0x1648; // int32_t
    constexpr std::ptrdiff_t m_nFireLifetime = 0x164C; // float
    constexpr std::ptrdiff_t m_bInPostEffectTime = 0x1650; // bool
    constexpr std::ptrdiff_t m_lastFireCount = 0x1654; // int32_t
    constexpr std::ptrdiff_t m_nFireEffectTickBegin = 0x1658; // int32_t
    constexpr std::ptrdiff_t m_drawableCount = 0x8260; // int32_t
    constexpr std::ptrdiff_t m_blosCheck = 0x8264; // bool
    constexpr std::ptrdiff_t m_nlosperiod = 0x8268; // int32_t
    constexpr std::ptrdiff_t m_maxFireHalfWidth = 0x826C; // float
    constexpr std::ptrdiff_t m_maxFireHeight = 0x8270; // float
    constexpr std::ptrdiff_t m_minBounds = 0x8274; // Vector
    constexpr std::ptrdiff_t m_maxBounds = 0x8280; // Vector
    constexpr std::ptrdiff_t m_flLastGrassBurnThink = 0x828C; // float
}

namespace C_InfoVisibilityBox {
    constexpr std::ptrdiff_t m_nMode = 0x544; // int32_t
    constexpr std::ptrdiff_t m_vBoxSize = 0x548; // Vector
    constexpr std::ptrdiff_t m_bEnabled = 0x554; // bool
}

namespace C_IronSightController {
    constexpr std::ptrdiff_t m_bIronSightAvailable = 0x10; // bool
    constexpr std::ptrdiff_t m_flIronSightAmount = 0x14; // float
    constexpr std::ptrdiff_t m_flIronSightAmountGained = 0x18; // float
    constexpr std::ptrdiff_t m_flIronSightAmountBiased = 0x1C; // float
    constexpr std::ptrdiff_t m_flIronSightAmount_Interpolated = 0x20; // float
    constexpr std::ptrdiff_t m_flIronSightAmountGained_Interpolated = 0x24; // float
    constexpr std::ptrdiff_t m_flIronSightAmountBiased_Interpolated = 0x28; // float
    constexpr std::ptrdiff_t m_flInterpolationLastUpdated = 0x2C; // float
    constexpr std::ptrdiff_t m_angDeltaAverage = 0x30; // QAngle[8]
    constexpr std::ptrdiff_t m_angViewLast = 0x90; // QAngle
    constexpr std::ptrdiff_t m_vecDotCoords = 0x9C; // Vector2D
    constexpr std::ptrdiff_t m_flDotBlur = 0xA4; // float
    constexpr std::ptrdiff_t m_flSpeedRatio = 0xA8; // float
}

namespace C_Item {
    constexpr std::ptrdiff_t m_bShouldGlow = 0x1560; // bool
    constexpr std::ptrdiff_t m_pReticleHintTextName = 0x1561; // char[256]
}

namespace C_ItemDogtags {
    constexpr std::ptrdiff_t m_OwningPlayer = 0x1668; // CHandle<C_CSPlayerPawn>
    constexpr std::ptrdiff_t m_KillingPlayer = 0x166C; // CHandle<C_CSPlayerPawn>
}

namespace C_LightEntity {
    constexpr std::ptrdiff_t m_CLightComponent = 0xCC0; // CLightComponent*
}

namespace C_LightGlow {
    constexpr std::ptrdiff_t m_nHorizontalSize = 0xCC0; // uint32_t
    constexpr std::ptrdiff_t m_nVerticalSize = 0xCC4; // uint32_t
    constexpr std::ptrdiff_t m_nMinDist = 0xCC8; // uint32_t
    constexpr std::ptrdiff_t m_nMaxDist = 0xCCC; // uint32_t
    constexpr std::ptrdiff_t m_nOuterMaxDist = 0xCD0; // uint32_t
    constexpr std::ptrdiff_t m_flGlowProxySize = 0xCD4; // float
    constexpr std::ptrdiff_t m_flHDRColorScale = 0xCD8; // float
    constexpr std::ptrdiff_t m_Glow = 0xCE0; // C_LightGlowOverlay
}

namespace C_LightGlowOverlay {
    constexpr std::ptrdiff_t m_vecOrigin = 0xD0; // Vector
    constexpr std::ptrdiff_t m_vecDirection = 0xDC; // Vector
    constexpr std::ptrdiff_t m_nMinDist = 0xE8; // int32_t
    constexpr std::ptrdiff_t m_nMaxDist = 0xEC; // int32_t
    constexpr std::ptrdiff_t m_nOuterMaxDist = 0xF0; // int32_t
    constexpr std::ptrdiff_t m_bOneSided = 0xF4; // bool
    constexpr std::ptrdiff_t m_bModulateByDot = 0xF5; // bool
}

namespace C_LocalTempEntity {
    constexpr std::ptrdiff_t flags = 0xE98; // int32_t
    constexpr std::ptrdiff_t die = 0xE9C; // GameTime_t
    constexpr std::ptrdiff_t m_flFrameMax = 0xEA0; // float
    constexpr std::ptrdiff_t x = 0xEA4; // float
    constexpr std::ptrdiff_t y = 0xEA8; // float
    constexpr std::ptrdiff_t fadeSpeed = 0xEAC; // float
    constexpr std::ptrdiff_t bounceFactor = 0xEB0; // float
    constexpr std::ptrdiff_t hitSound = 0xEB4; // int32_t
    constexpr std::ptrdiff_t priority = 0xEB8; // int32_t
    constexpr std::ptrdiff_t tentOffset = 0xEBC; // Vector
    constexpr std::ptrdiff_t m_vecTempEntAngVelocity = 0xEC8; // QAngle
    constexpr std::ptrdiff_t tempent_renderamt = 0xED4; // int32_t
    constexpr std::ptrdiff_t m_vecNormal = 0xED8; // Vector
    constexpr std::ptrdiff_t m_flSpriteScale = 0xEE4; // float
    constexpr std::ptrdiff_t m_nFlickerFrame = 0xEE8; // int32_t
    constexpr std::ptrdiff_t m_flFrameRate = 0xEEC; // float
    constexpr std::ptrdiff_t m_flFrame = 0xEF0; // float
    constexpr std::ptrdiff_t m_pszImpactEffect = 0xEF8; // char*
    constexpr std::ptrdiff_t m_pszParticleEffect = 0xF00; // char*
    constexpr std::ptrdiff_t m_bParticleCollision = 0xF08; // bool
    constexpr std::ptrdiff_t m_iLastCollisionFrame = 0xF0C; // int32_t
    constexpr std::ptrdiff_t m_vLastCollisionOrigin = 0xF10; // Vector
    constexpr std::ptrdiff_t m_vecTempEntVelocity = 0xF1C; // Vector
    constexpr std::ptrdiff_t m_vecPrevAbsOrigin = 0xF28; // Vector
    constexpr std::ptrdiff_t m_vecTempEntAcceleration = 0xF34; // Vector
}

namespace C_MapVetoPickController {
    constexpr std::ptrdiff_t m_nDraftType = 0x550; // int32_t
    constexpr std::ptrdiff_t m_nTeamWinningCoinToss = 0x554; // int32_t
    constexpr std::ptrdiff_t m_nTeamWithFirstChoice = 0x558; // int32_t[64]
    constexpr std::ptrdiff_t m_nVoteMapIdsList = 0x658; // int32_t[7]
    constexpr std::ptrdiff_t m_nAccountIDs = 0x674; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId0 = 0x774; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId1 = 0x874; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId2 = 0x974; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId3 = 0xA74; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId4 = 0xB74; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId5 = 0xC74; // int32_t[64]
    constexpr std::ptrdiff_t m_nStartingSide0 = 0xD74; // int32_t[64]
    constexpr std::ptrdiff_t m_nCurrentPhase = 0xE74; // int32_t
    constexpr std::ptrdiff_t m_nPhaseStartTick = 0xE78; // int32_t
    constexpr std::ptrdiff_t m_nPhaseDurationTicks = 0xE7C; // int32_t
    constexpr std::ptrdiff_t m_nPostDataUpdateTick = 0xE80; // int32_t
    constexpr std::ptrdiff_t m_bDisabledHud = 0xE84; // bool
}

namespace C_Melee {
    constexpr std::ptrdiff_t m_flThrowAt = 0x19F0; // GameTime_t
}

namespace C_MolotovProjectile {
    constexpr std::ptrdiff_t m_bIsIncGrenade = 0x1100; // bool
}

namespace C_Multimeter {
    constexpr std::ptrdiff_t m_hTargetC4 = 0xE88; // CHandle<C_PlantedC4>
}

namespace C_OmniLight {
    constexpr std::ptrdiff_t m_flInnerAngle = 0xF08; // float
    constexpr std::ptrdiff_t m_flOuterAngle = 0xF0C; // float
    constexpr std::ptrdiff_t m_bShowLight = 0xF10; // bool
}

namespace C_ParticleSystem {
    constexpr std::ptrdiff_t m_szSnapshotFileName = 0xCC0; // char[512]
    constexpr std::ptrdiff_t m_bActive = 0xEC0; // bool
    constexpr std::ptrdiff_t m_bFrozen = 0xEC1; // bool
    constexpr std::ptrdiff_t m_flFreezeTransitionDuration = 0xEC4; // float
    constexpr std::ptrdiff_t m_nStopType = 0xEC8; // int32_t
    constexpr std::ptrdiff_t m_bAnimateDuringGameplayPause = 0xECC; // bool
    constexpr std::ptrdiff_t m_iEffectIndex = 0xED0; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_flStartTime = 0xED8; // GameTime_t
    constexpr std::ptrdiff_t m_flPreSimTime = 0xEDC; // float
    constexpr std::ptrdiff_t m_vServerControlPoints = 0xEE0; // Vector[4]
    constexpr std::ptrdiff_t m_iServerControlPointAssignments = 0xF10; // uint8_t[4]
    constexpr std::ptrdiff_t m_hControlPointEnts = 0xF14; // CHandle<C_BaseEntity>[64]
    constexpr std::ptrdiff_t m_bNoSave = 0x1014; // bool
    constexpr std::ptrdiff_t m_bNoFreeze = 0x1015; // bool
    constexpr std::ptrdiff_t m_bNoRamp = 0x1016; // bool
    constexpr std::ptrdiff_t m_bStartActive = 0x1017; // bool
    constexpr std::ptrdiff_t m_iszEffectName = 0x1018; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszControlPointNames = 0x1020; // CUtlSymbolLarge[64]
    constexpr std::ptrdiff_t m_nDataCP = 0x1220; // int32_t
    constexpr std::ptrdiff_t m_vecDataCPValue = 0x1224; // Vector
    constexpr std::ptrdiff_t m_nTintCP = 0x1230; // int32_t
    constexpr std::ptrdiff_t m_clrTint = 0x1234; // Color
    constexpr std::ptrdiff_t m_bOldActive = 0x1258; // bool
    constexpr std::ptrdiff_t m_bOldFrozen = 0x1259; // bool
}

namespace C_PathParticleRope {
    constexpr std::ptrdiff_t m_bStartActive = 0x540; // bool
    constexpr std::ptrdiff_t m_flMaxSimulationTime = 0x544; // float
    constexpr std::ptrdiff_t m_iszEffectName = 0x548; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_PathNodes_Name = 0x550; // CUtlVector<CUtlSymbolLarge>
    constexpr std::ptrdiff_t m_flParticleSpacing = 0x568; // float
    constexpr std::ptrdiff_t m_flSlack = 0x56C; // float
    constexpr std::ptrdiff_t m_flRadius = 0x570; // float
    constexpr std::ptrdiff_t m_ColorTint = 0x574; // Color
    constexpr std::ptrdiff_t m_nEffectState = 0x578; // int32_t
    constexpr std::ptrdiff_t m_iEffectIndex = 0x580; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_PathNodes_Position = 0x588; // C_NetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_PathNodes_TangentIn = 0x5A0; // C_NetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_PathNodes_TangentOut = 0x5B8; // C_NetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_PathNodes_Color = 0x5D0; // C_NetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_PathNodes_PinEnabled = 0x5E8; // C_NetworkUtlVectorBase<bool>
    constexpr std::ptrdiff_t m_PathNodes_RadiusScale = 0x600; // C_NetworkUtlVectorBase<float>
}

namespace C_PhysMagnet {
    constexpr std::ptrdiff_t m_aAttachedObjectsFromServer = 0xE80; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_aAttachedObjects = 0xE98; // CUtlVector<CHandle<C_BaseEntity>>
}

namespace C_PhysPropClientside {
    constexpr std::ptrdiff_t m_flTouchDelta = 0xFD0; // GameTime_t
    constexpr std::ptrdiff_t m_fDeathTime = 0xFD4; // GameTime_t
    constexpr std::ptrdiff_t m_impactEnergyScale = 0xFD8; // float
    constexpr std::ptrdiff_t m_inertiaScale = 0xFDC; // float
    constexpr std::ptrdiff_t m_flDmgModBullet = 0xFE0; // float
    constexpr std::ptrdiff_t m_flDmgModClub = 0xFE4; // float
    constexpr std::ptrdiff_t m_flDmgModExplosive = 0xFE8; // float
    constexpr std::ptrdiff_t m_flDmgModFire = 0xFEC; // float
    constexpr std::ptrdiff_t m_iszPhysicsDamageTableName = 0xFF0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszBasePropData = 0xFF8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iInteractions = 0x1000; // int32_t
    constexpr std::ptrdiff_t m_bHasBreakPiecesOrCommands = 0x1004; // bool
    constexpr std::ptrdiff_t m_vecDamagePosition = 0x1008; // Vector
    constexpr std::ptrdiff_t m_vecDamageDirection = 0x1014; // Vector
    constexpr std::ptrdiff_t m_nDamageType = 0x1020; // int32_t
}

namespace C_PhysicsProp {
    constexpr std::ptrdiff_t m_bAwake = 0xFD0; // bool
}

namespace C_PickUpModelSlerper {
    constexpr std::ptrdiff_t m_hPlayerParent = 0xE80; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_hItem = 0xE84; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_flTimePickedUp = 0xE88; // float
    constexpr std::ptrdiff_t m_angOriginal = 0xE8C; // QAngle
    constexpr std::ptrdiff_t m_vecPosOriginal = 0xE98; // Vector
    constexpr std::ptrdiff_t m_angRandom = 0xEA8; // QAngle
}

namespace C_PlantedC4 {
    constexpr std::ptrdiff_t m_bBombTicking = 0xE80; // bool
    constexpr std::ptrdiff_t m_nBombSite = 0xE84; // int32_t
    constexpr std::ptrdiff_t m_nSourceSoundscapeHash = 0xE88; // int32_t
    constexpr std::ptrdiff_t m_entitySpottedState = 0xE90; // EntitySpottedState_t
    constexpr std::ptrdiff_t m_flNextGlow = 0xEA8; // GameTime_t
    constexpr std::ptrdiff_t m_flNextBeep = 0xEAC; // GameTime_t
    constexpr std::ptrdiff_t m_flC4Blow = 0xEB0; // GameTime_t
    constexpr std::ptrdiff_t m_bCannotBeDefused = 0xEB4; // bool
    constexpr std::ptrdiff_t m_bHasExploded = 0xEB5; // bool
    constexpr std::ptrdiff_t m_flTimerLength = 0xEB8; // float
    constexpr std::ptrdiff_t m_bBeingDefused = 0xEBC; // bool
    constexpr std::ptrdiff_t m_bTriggerWarning = 0xEC0; // float
    constexpr std::ptrdiff_t m_bExplodeWarning = 0xEC4; // float
    constexpr std::ptrdiff_t m_bC4Activated = 0xEC8; // bool
    constexpr std::ptrdiff_t m_bTenSecWarning = 0xEC9; // bool
    constexpr std::ptrdiff_t m_flDefuseLength = 0xECC; // float
    constexpr std::ptrdiff_t m_flDefuseCountDown = 0xED0; // GameTime_t
    constexpr std::ptrdiff_t m_bBombDefused = 0xED4; // bool
    constexpr std::ptrdiff_t m_hBombDefuser = 0xED8; // CHandle<C_CSPlayerPawn>
    constexpr std::ptrdiff_t m_hControlPanel = 0xEDC; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_hDefuserMultimeter = 0xEE0; // CHandle<C_Multimeter>
    constexpr std::ptrdiff_t m_flNextRadarFlashTime = 0xEE4; // GameTime_t
    constexpr std::ptrdiff_t m_bRadarFlash = 0xEE8; // bool
    constexpr std::ptrdiff_t m_pBombDefuser = 0xEEC; // CHandle<C_CSPlayerPawn>
    constexpr std::ptrdiff_t m_fLastDefuseTime = 0xEF0; // GameTime_t
    constexpr std::ptrdiff_t m_pPredictionOwner = 0xEF8; // CBasePlayerController*
}

namespace C_PlayerPing {
    constexpr std::ptrdiff_t m_hPlayer = 0x570; // CHandle<C_CSPlayerPawn>
    constexpr std::ptrdiff_t m_hPingedEntity = 0x574; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_iType = 0x578; // int32_t
    constexpr std::ptrdiff_t m_bUrgent = 0x57C; // bool
    constexpr std::ptrdiff_t m_szPlaceName = 0x57D; // char[18]
}

namespace C_PlayerSprayDecal {
    constexpr std::ptrdiff_t m_nUniqueID = 0xCC0; // int32_t
    constexpr std::ptrdiff_t m_unAccountID = 0xCC4; // uint32_t
    constexpr std::ptrdiff_t m_unTraceID = 0xCC8; // uint32_t
    constexpr std::ptrdiff_t m_rtGcTime = 0xCCC; // uint32_t
    constexpr std::ptrdiff_t m_vecEndPos = 0xCD0; // Vector
    constexpr std::ptrdiff_t m_vecStart = 0xCDC; // Vector
    constexpr std::ptrdiff_t m_vecLeft = 0xCE8; // Vector
    constexpr std::ptrdiff_t m_vecNormal = 0xCF4; // Vector
    constexpr std::ptrdiff_t m_nPlayer = 0xD00; // int32_t
    constexpr std::ptrdiff_t m_nEntity = 0xD04; // int32_t
    constexpr std::ptrdiff_t m_nHitbox = 0xD08; // int32_t
    constexpr std::ptrdiff_t m_flCreationTime = 0xD0C; // float
    constexpr std::ptrdiff_t m_nTintID = 0xD10; // int32_t
    constexpr std::ptrdiff_t m_nVersion = 0xD14; // uint8_t
    constexpr std::ptrdiff_t m_ubSignature = 0xD15; // uint8_t[128]
    constexpr std::ptrdiff_t m_SprayRenderHelper = 0xDA0; // CPlayerSprayDecalRenderHelper
}

namespace C_PlayerVisibility {
    constexpr std::ptrdiff_t m_flVisibilityStrength = 0x540; // float
    constexpr std::ptrdiff_t m_flFogDistanceMultiplier = 0x544; // float
    constexpr std::ptrdiff_t m_flFogMaxDensityMultiplier = 0x548; // float
    constexpr std::ptrdiff_t m_flFadeTime = 0x54C; // float
    constexpr std::ptrdiff_t m_bStartDisabled = 0x550; // bool
    constexpr std::ptrdiff_t m_bIsEnabled = 0x551; // bool
}

namespace C_PointCamera {
    constexpr std::ptrdiff_t m_FOV = 0x540; // float
    constexpr std::ptrdiff_t m_Resolution = 0x544; // float
    constexpr std::ptrdiff_t m_bFogEnable = 0x548; // bool
    constexpr std::ptrdiff_t m_FogColor = 0x549; // Color
    constexpr std::ptrdiff_t m_flFogStart = 0x550; // float
    constexpr std::ptrdiff_t m_flFogEnd = 0x554; // float
    constexpr std::ptrdiff_t m_flFogMaxDensity = 0x558; // float
    constexpr std::ptrdiff_t m_bActive = 0x55C; // bool
    constexpr std::ptrdiff_t m_bUseScreenAspectRatio = 0x55D; // bool
    constexpr std::ptrdiff_t m_flAspectRatio = 0x560; // float
    constexpr std::ptrdiff_t m_bNoSky = 0x564; // bool
    constexpr std::ptrdiff_t m_fBrightness = 0x568; // float
    constexpr std::ptrdiff_t m_flZFar = 0x56C; // float
    constexpr std::ptrdiff_t m_flZNear = 0x570; // float
    constexpr std::ptrdiff_t m_bCanHLTVUse = 0x574; // bool
    constexpr std::ptrdiff_t m_bDofEnabled = 0x575; // bool
    constexpr std::ptrdiff_t m_flDofNearBlurry = 0x578; // float
    constexpr std::ptrdiff_t m_flDofNearCrisp = 0x57C; // float
    constexpr std::ptrdiff_t m_flDofFarCrisp = 0x580; // float
    constexpr std::ptrdiff_t m_flDofFarBlurry = 0x584; // float
    constexpr std::ptrdiff_t m_flDofTiltToGround = 0x588; // float
    constexpr std::ptrdiff_t m_TargetFOV = 0x58C; // float
    constexpr std::ptrdiff_t m_DegreesPerSecond = 0x590; // float
    constexpr std::ptrdiff_t m_bIsOn = 0x594; // bool
    constexpr std::ptrdiff_t m_pNext = 0x598; // C_PointCamera*
}

namespace C_PointCameraVFOV {
    constexpr std::ptrdiff_t m_flVerticalFOV = 0x5A0; // float
}

namespace C_PointClientUIDialog {
    constexpr std::ptrdiff_t m_hActivator = 0xCF0; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_bStartEnabled = 0xCF4; // bool
}

namespace C_PointClientUIHUD {
    constexpr std::ptrdiff_t m_bCheckCSSClasses = 0xCF8; // bool
    constexpr std::ptrdiff_t m_bIgnoreInput = 0xE80; // bool
    constexpr std::ptrdiff_t m_flWidth = 0xE84; // float
    constexpr std::ptrdiff_t m_flHeight = 0xE88; // float
    constexpr std::ptrdiff_t m_flDPI = 0xE8C; // float
    constexpr std::ptrdiff_t m_flInteractDistance = 0xE90; // float
    constexpr std::ptrdiff_t m_flDepthOffset = 0xE94; // float
    constexpr std::ptrdiff_t m_unOwnerContext = 0xE98; // uint32_t
    constexpr std::ptrdiff_t m_unHorizontalAlign = 0xE9C; // uint32_t
    constexpr std::ptrdiff_t m_unVerticalAlign = 0xEA0; // uint32_t
    constexpr std::ptrdiff_t m_unOrientation = 0xEA4; // uint32_t
    constexpr std::ptrdiff_t m_bAllowInteractionFromAllSceneWorlds = 0xEA8; // bool
    constexpr std::ptrdiff_t m_vecCSSClasses = 0xEB0; // C_NetworkUtlVectorBase<CUtlSymbolLarge>
}

namespace C_PointClientUIWorldPanel {
    constexpr std::ptrdiff_t m_bForceRecreateNextUpdate = 0xCF8; // bool
    constexpr std::ptrdiff_t m_bMoveViewToPlayerNextThink = 0xCF9; // bool
    constexpr std::ptrdiff_t m_bCheckCSSClasses = 0xCFA; // bool
    constexpr std::ptrdiff_t m_anchorDeltaTransform = 0xD00; // CTransform
    constexpr std::ptrdiff_t m_pOffScreenIndicator = 0xEA0; // CPointOffScreenIndicatorUi*
    constexpr std::ptrdiff_t m_bIgnoreInput = 0xEC8; // bool
    constexpr std::ptrdiff_t m_bLit = 0xEC9; // bool
    constexpr std::ptrdiff_t m_bFollowPlayerAcrossTeleport = 0xECA; // bool
    constexpr std::ptrdiff_t m_flWidth = 0xECC; // float
    constexpr std::ptrdiff_t m_flHeight = 0xED0; // float
    constexpr std::ptrdiff_t m_flDPI = 0xED4; // float
    constexpr std::ptrdiff_t m_flInteractDistance = 0xED8; // float
    constexpr std::ptrdiff_t m_flDepthOffset = 0xEDC; // float
    constexpr std::ptrdiff_t m_unOwnerContext = 0xEE0; // uint32_t
    constexpr std::ptrdiff_t m_unHorizontalAlign = 0xEE4; // uint32_t
    constexpr std::ptrdiff_t m_unVerticalAlign = 0xEE8; // uint32_t
    constexpr std::ptrdiff_t m_unOrientation = 0xEEC; // uint32_t
    constexpr std::ptrdiff_t m_bAllowInteractionFromAllSceneWorlds = 0xEF0; // bool
    constexpr std::ptrdiff_t m_vecCSSClasses = 0xEF8; // C_NetworkUtlVectorBase<CUtlSymbolLarge>
    constexpr std::ptrdiff_t m_bOpaque = 0xF10; // bool
    constexpr std::ptrdiff_t m_bNoDepth = 0xF11; // bool
    constexpr std::ptrdiff_t m_bRenderBackface = 0xF12; // bool
    constexpr std::ptrdiff_t m_bUseOffScreenIndicator = 0xF13; // bool
    constexpr std::ptrdiff_t m_bExcludeFromSaveGames = 0xF14; // bool
    constexpr std::ptrdiff_t m_bGrabbable = 0xF15; // bool
    constexpr std::ptrdiff_t m_bOnlyRenderToTexture = 0xF16; // bool
    constexpr std::ptrdiff_t m_bDisableMipGen = 0xF17; // bool
    constexpr std::ptrdiff_t m_nExplicitImageLayout = 0xF18; // int32_t
}

namespace C_PointClientUIWorldTextPanel {
    constexpr std::ptrdiff_t m_messageText = 0xF20; // char[512]
}

namespace C_PointCommentaryNode {
    constexpr std::ptrdiff_t m_bActive = 0xE88; // bool
    constexpr std::ptrdiff_t m_bWasActive = 0xE89; // bool
    constexpr std::ptrdiff_t m_flEndTime = 0xE8C; // GameTime_t
    constexpr std::ptrdiff_t m_flStartTime = 0xE90; // GameTime_t
    constexpr std::ptrdiff_t m_flStartTimeInCommentary = 0xE94; // float
    constexpr std::ptrdiff_t m_iszCommentaryFile = 0xE98; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszTitle = 0xEA0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSpeakers = 0xEA8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iNodeNumber = 0xEB0; // int32_t
    constexpr std::ptrdiff_t m_iNodeNumberMax = 0xEB4; // int32_t
    constexpr std::ptrdiff_t m_bListenedTo = 0xEB8; // bool
    constexpr std::ptrdiff_t m_hViewPosition = 0xEC8; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_bRestartAfterRestore = 0xECC; // bool
}

namespace C_PointValueRemapper {
    constexpr std::ptrdiff_t m_bDisabled = 0x540; // bool
    constexpr std::ptrdiff_t m_bDisabledOld = 0x541; // bool
    constexpr std::ptrdiff_t m_bUpdateOnClient = 0x542; // bool
    constexpr std::ptrdiff_t m_nInputType = 0x544; // ValueRemapperInputType_t
    constexpr std::ptrdiff_t m_hRemapLineStart = 0x548; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_hRemapLineEnd = 0x54C; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_flMaximumChangePerSecond = 0x550; // float
    constexpr std::ptrdiff_t m_flDisengageDistance = 0x554; // float
    constexpr std::ptrdiff_t m_flEngageDistance = 0x558; // float
    constexpr std::ptrdiff_t m_bRequiresUseKey = 0x55C; // bool
    constexpr std::ptrdiff_t m_nOutputType = 0x560; // ValueRemapperOutputType_t
    constexpr std::ptrdiff_t m_hOutputEntities = 0x568; // C_NetworkUtlVectorBase<CHandle<C_BaseEntity>>
    constexpr std::ptrdiff_t m_nHapticsType = 0x580; // ValueRemapperHapticsType_t
    constexpr std::ptrdiff_t m_nMomentumType = 0x584; // ValueRemapperMomentumType_t
    constexpr std::ptrdiff_t m_flMomentumModifier = 0x588; // float
    constexpr std::ptrdiff_t m_flSnapValue = 0x58C; // float
    constexpr std::ptrdiff_t m_flCurrentMomentum = 0x590; // float
    constexpr std::ptrdiff_t m_nRatchetType = 0x594; // ValueRemapperRatchetType_t
    constexpr std::ptrdiff_t m_flRatchetOffset = 0x598; // float
    constexpr std::ptrdiff_t m_flInputOffset = 0x59C; // float
    constexpr std::ptrdiff_t m_bEngaged = 0x5A0; // bool
    constexpr std::ptrdiff_t m_bFirstUpdate = 0x5A1; // bool
    constexpr std::ptrdiff_t m_flPreviousValue = 0x5A4; // float
    constexpr std::ptrdiff_t m_flPreviousUpdateTickTime = 0x5A8; // GameTime_t
    constexpr std::ptrdiff_t m_vecPreviousTestPoint = 0x5AC; // Vector
}

namespace C_PointWorldText {
    constexpr std::ptrdiff_t m_bForceRecreateNextUpdate = 0xCC8; // bool
    constexpr std::ptrdiff_t m_messageText = 0xCD8; // char[512]
    constexpr std::ptrdiff_t m_FontName = 0xED8; // char[64]
    constexpr std::ptrdiff_t m_bEnabled = 0xF18; // bool
    constexpr std::ptrdiff_t m_bFullbright = 0xF19; // bool
    constexpr std::ptrdiff_t m_flWorldUnitsPerPx = 0xF1C; // float
    constexpr std::ptrdiff_t m_flFontSize = 0xF20; // float
    constexpr std::ptrdiff_t m_flDepthOffset = 0xF24; // float
    constexpr std::ptrdiff_t m_Color = 0xF28; // Color
    constexpr std::ptrdiff_t m_nJustifyHorizontal = 0xF2C; // PointWorldTextJustifyHorizontal_t
    constexpr std::ptrdiff_t m_nJustifyVertical = 0xF30; // PointWorldTextJustifyVertical_t
    constexpr std::ptrdiff_t m_nReorientMode = 0xF34; // PointWorldTextReorientMode_t
}

namespace C_PostProcessingVolume {
    constexpr std::ptrdiff_t m_hPostSettings = 0xCD8; // CStrongHandle<InfoForResourceTypeCPostProcessingResource>
    constexpr std::ptrdiff_t m_flFadeDuration = 0xCE0; // float
    constexpr std::ptrdiff_t m_flMinLogExposure = 0xCE4; // float
    constexpr std::ptrdiff_t m_flMaxLogExposure = 0xCE8; // float
    constexpr std::ptrdiff_t m_flMinExposure = 0xCEC; // float
    constexpr std::ptrdiff_t m_flMaxExposure = 0xCF0; // float
    constexpr std::ptrdiff_t m_flExposureCompensation = 0xCF4; // float
    constexpr std::ptrdiff_t m_flExposureFadeSpeedUp = 0xCF8; // float
    constexpr std::ptrdiff_t m_flExposureFadeSpeedDown = 0xCFC; // float
    constexpr std::ptrdiff_t m_flTonemapEVSmoothingRange = 0xD00; // float
    constexpr std::ptrdiff_t m_bMaster = 0xD04; // bool
    constexpr std::ptrdiff_t m_bExposureControl = 0xD05; // bool
    constexpr std::ptrdiff_t m_flRate = 0xD08; // float
    constexpr std::ptrdiff_t m_flTonemapPercentTarget = 0xD0C; // float
    constexpr std::ptrdiff_t m_flTonemapPercentBrightPixels = 0xD10; // float
    constexpr std::ptrdiff_t m_flTonemapMinAvgLum = 0xD14; // float
}

namespace C_Precipitation {
    constexpr std::ptrdiff_t m_flDensity = 0xCC8; // float
    constexpr std::ptrdiff_t m_flParticleInnerDist = 0xCD8; // float
    constexpr std::ptrdiff_t m_pParticleDef = 0xCE0; // char*
    constexpr std::ptrdiff_t m_tParticlePrecipTraceTimer = 0xD08; // TimedEvent[1]
    constexpr std::ptrdiff_t m_bActiveParticlePrecipEmitter = 0xD10; // bool[1]
    constexpr std::ptrdiff_t m_bParticlePrecipInitialized = 0xD11; // bool
    constexpr std::ptrdiff_t m_bHasSimulatedSinceLastSceneObjectUpdate = 0xD12; // bool
    constexpr std::ptrdiff_t m_nAvailableSheetSequencesMaxIndex = 0xD14; // int32_t
}

namespace C_PredictedViewModel {
    constexpr std::ptrdiff_t m_LagAnglesHistory = 0xEE8; // QAngle
    constexpr std::ptrdiff_t m_vPredictedOffset = 0xF00; // Vector
}

namespace C_RagdollManager {
    constexpr std::ptrdiff_t m_iCurrentMaxRagdollCount = 0x540; // int8_t
}

namespace C_RagdollProp {
    constexpr std::ptrdiff_t m_ragPos = 0xE88; // C_NetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_ragAngles = 0xEA0; // C_NetworkUtlVectorBase<QAngle>
    constexpr std::ptrdiff_t m_flBlendWeight = 0xEB8; // float
    constexpr std::ptrdiff_t m_hRagdollSource = 0xEBC; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_iEyeAttachment = 0xEC0; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_flBlendWeightCurrent = 0xEC4; // float
    constexpr std::ptrdiff_t m_parentPhysicsBoneIndices = 0xEC8; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_worldSpaceBoneComputationOrder = 0xEE0; // CUtlVector<int32_t>
}

namespace C_RagdollPropAttached {
    constexpr std::ptrdiff_t m_boneIndexAttached = 0xEF8; // uint32_t
    constexpr std::ptrdiff_t m_ragdollAttachedObjectIndex = 0xEFC; // uint32_t
    constexpr std::ptrdiff_t m_attachmentPointBoneSpace = 0xF00; // Vector
    constexpr std::ptrdiff_t m_attachmentPointRagdollSpace = 0xF0C; // Vector
    constexpr std::ptrdiff_t m_vecOffset = 0xF18; // Vector
    constexpr std::ptrdiff_t m_parentTime = 0xF24; // float
    constexpr std::ptrdiff_t m_bHasParent = 0xF28; // bool
}

namespace C_RectLight {
    constexpr std::ptrdiff_t m_bShowLight = 0xF08; // bool
}

namespace C_RetakeGameRules {
    constexpr std::ptrdiff_t m_nMatchSeed = 0xF8; // int32_t
    constexpr std::ptrdiff_t m_bBlockersPresent = 0xFC; // bool
    constexpr std::ptrdiff_t m_bRoundInProgress = 0xFD; // bool
    constexpr std::ptrdiff_t m_iFirstSecondHalfRound = 0x100; // int32_t
    constexpr std::ptrdiff_t m_iBombSite = 0x104; // int32_t
}

namespace C_RopeKeyframe {
    constexpr std::ptrdiff_t m_LinksTouchingSomething = 0xCC8; // CBitVec<10>
    constexpr std::ptrdiff_t m_nLinksTouchingSomething = 0xCCC; // int32_t
    constexpr std::ptrdiff_t m_bApplyWind = 0xCD0; // bool
    constexpr std::ptrdiff_t m_fPrevLockedPoints = 0xCD4; // int32_t
    constexpr std::ptrdiff_t m_iForcePointMoveCounter = 0xCD8; // int32_t
    constexpr std::ptrdiff_t m_bPrevEndPointPos = 0xCDC; // bool[2]
    constexpr std::ptrdiff_t m_vPrevEndPointPos = 0xCE0; // Vector[2]
    constexpr std::ptrdiff_t m_flCurScroll = 0xCF8; // float
    constexpr std::ptrdiff_t m_flScrollSpeed = 0xCFC; // float
    constexpr std::ptrdiff_t m_RopeFlags = 0xD00; // uint16_t
    constexpr std::ptrdiff_t m_iRopeMaterialModelIndex = 0xD08; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_LightValues = 0xF80; // Vector[10]
    constexpr std::ptrdiff_t m_nSegments = 0xFF8; // uint8_t
    constexpr std::ptrdiff_t m_hStartPoint = 0xFFC; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_hEndPoint = 0x1000; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_iStartAttachment = 0x1004; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_iEndAttachment = 0x1005; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_Subdiv = 0x1006; // uint8_t
    constexpr std::ptrdiff_t m_RopeLength = 0x1008; // int16_t
    constexpr std::ptrdiff_t m_Slack = 0x100A; // int16_t
    constexpr std::ptrdiff_t m_TextureScale = 0x100C; // float
    constexpr std::ptrdiff_t m_fLockedPoints = 0x1010; // uint8_t
    constexpr std::ptrdiff_t m_nChangeCount = 0x1011; // uint8_t
    constexpr std::ptrdiff_t m_Width = 0x1014; // float
    constexpr std::ptrdiff_t m_PhysicsDelegate = 0x1018; // C_RopeKeyframe::CPhysicsDelegate
    constexpr std::ptrdiff_t m_hMaterial = 0x1028; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_TextureHeight = 0x1030; // int32_t
    constexpr std::ptrdiff_t m_vecImpulse = 0x1034; // Vector
    constexpr std::ptrdiff_t m_vecPreviousImpulse = 0x1040; // Vector
    constexpr std::ptrdiff_t m_flCurrentGustTimer = 0x104C; // float
    constexpr std::ptrdiff_t m_flCurrentGustLifetime = 0x1050; // float
    constexpr std::ptrdiff_t m_flTimeToNextGust = 0x1054; // float
    constexpr std::ptrdiff_t m_vWindDir = 0x1058; // Vector
    constexpr std::ptrdiff_t m_vColorMod = 0x1064; // Vector
    constexpr std::ptrdiff_t m_vCachedEndPointAttachmentPos = 0x1070; // Vector[2]
    constexpr std::ptrdiff_t m_vCachedEndPointAttachmentAngle = 0x1088; // QAngle[2]
    constexpr std::ptrdiff_t m_bConstrainBetweenEndpoints = 0x10A0; // bool
    constexpr std::ptrdiff_t m_bEndPointAttachmentPositionsDirty = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bEndPointAttachmentAnglesDirty = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bNewDataThisFrame = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bPhysicsInitted = 0x0; // bitfield:1
}

namespace C_RopeKeyframe_CPhysicsDelegate {
    constexpr std::ptrdiff_t m_pKeyframe = 0x8; // C_RopeKeyframe*
}

namespace C_SceneEntity {
    constexpr std::ptrdiff_t m_bIsPlayingBack = 0x548; // bool
    constexpr std::ptrdiff_t m_bPaused = 0x549; // bool
    constexpr std::ptrdiff_t m_bMultiplayer = 0x54A; // bool
    constexpr std::ptrdiff_t m_bAutogenerated = 0x54B; // bool
    constexpr std::ptrdiff_t m_flForceClientTime = 0x54C; // float
    constexpr std::ptrdiff_t m_nSceneStringIndex = 0x550; // uint16_t
    constexpr std::ptrdiff_t m_bClientOnly = 0x552; // bool
    constexpr std::ptrdiff_t m_hOwner = 0x554; // CHandle<C_BaseFlex>
    constexpr std::ptrdiff_t m_hActorList = 0x558; // C_NetworkUtlVectorBase<CHandle<C_BaseFlex>>
    constexpr std::ptrdiff_t m_bWasPlaying = 0x570; // bool
    constexpr std::ptrdiff_t m_QueuedEvents = 0x580; // CUtlVector<C_SceneEntity::QueuedEvents_t>
    constexpr std::ptrdiff_t m_flCurrentTime = 0x598; // float
}

namespace C_SceneEntity_QueuedEvents_t {
    constexpr std::ptrdiff_t starttime = 0x0; // float
}

namespace C_ShatterGlassShardPhysics {
    constexpr std::ptrdiff_t m_ShardDesc = 0xFE0; // shard_model_desc_t
}

namespace C_SkyCamera {
    constexpr std::ptrdiff_t m_skyboxData = 0x540; // sky3dparams_t
    constexpr std::ptrdiff_t m_skyboxSlotToken = 0x5D0; // CUtlStringToken
    constexpr std::ptrdiff_t m_bUseAngles = 0x5D4; // bool
    constexpr std::ptrdiff_t m_pNext = 0x5D8; // C_SkyCamera*
}

namespace C_SmokeGrenadeProjectile {
    constexpr std::ptrdiff_t m_nSmokeEffectTickBegin = 0x1108; // int32_t
    constexpr std::ptrdiff_t m_bDidSmokeEffect = 0x110C; // bool
    constexpr std::ptrdiff_t m_nRandomSeed = 0x1110; // int32_t
    constexpr std::ptrdiff_t m_vSmokeColor = 0x1114; // Vector
    constexpr std::ptrdiff_t m_vSmokeDetonationPos = 0x1120; // Vector
    constexpr std::ptrdiff_t m_VoxelFrameData = 0x1130; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_bSmokeVolumeDataReceived = 0x1148; // bool
    constexpr std::ptrdiff_t m_bSmokeEffectSpawned = 0x1149; // bool
}

namespace C_SoundAreaEntityBase {
    constexpr std::ptrdiff_t m_bDisabled = 0x540; // bool
    constexpr std::ptrdiff_t m_bWasEnabled = 0x548; // bool
    constexpr std::ptrdiff_t m_iszSoundAreaType = 0x550; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_vPos = 0x558; // Vector
}

namespace C_SoundAreaEntityOrientedBox {
    constexpr std::ptrdiff_t m_vMin = 0x568; // Vector
    constexpr std::ptrdiff_t m_vMax = 0x574; // Vector
}

namespace C_SoundAreaEntitySphere {
    constexpr std::ptrdiff_t m_flRadius = 0x568; // float
}

namespace C_SoundOpvarSetPointBase {
    constexpr std::ptrdiff_t m_iszStackName = 0x540; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszOperatorName = 0x548; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszOpvarName = 0x550; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iOpvarIndex = 0x558; // int32_t
    constexpr std::ptrdiff_t m_bUseAutoCompare = 0x55C; // bool
}

namespace C_SpotlightEnd {
    constexpr std::ptrdiff_t m_flLightScale = 0xCC0; // float
    constexpr std::ptrdiff_t m_Radius = 0xCC4; // float
}

namespace C_Sprite {
    constexpr std::ptrdiff_t m_hSpriteMaterial = 0xCD8; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_hAttachedToEntity = 0xCE0; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_nAttachment = 0xCE4; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_flSpriteFramerate = 0xCE8; // float
    constexpr std::ptrdiff_t m_flFrame = 0xCEC; // float
    constexpr std::ptrdiff_t m_flDieTime = 0xCF0; // GameTime_t
    constexpr std::ptrdiff_t m_nBrightness = 0xD00; // uint32_t
    constexpr std::ptrdiff_t m_flBrightnessDuration = 0xD04; // float
    constexpr std::ptrdiff_t m_flSpriteScale = 0xD08; // float
    constexpr std::ptrdiff_t m_flScaleDuration = 0xD0C; // float
    constexpr std::ptrdiff_t m_bWorldSpaceScale = 0xD10; // bool
    constexpr std::ptrdiff_t m_flGlowProxySize = 0xD14; // float
    constexpr std::ptrdiff_t m_flHDRColorScale = 0xD18; // float
    constexpr std::ptrdiff_t m_flLastTime = 0xD1C; // GameTime_t
    constexpr std::ptrdiff_t m_flMaxFrame = 0xD20; // float
    constexpr std::ptrdiff_t m_flStartScale = 0xD24; // float
    constexpr std::ptrdiff_t m_flDestScale = 0xD28; // float
    constexpr std::ptrdiff_t m_flScaleTimeStart = 0xD2C; // GameTime_t
    constexpr std::ptrdiff_t m_nStartBrightness = 0xD30; // int32_t
    constexpr std::ptrdiff_t m_nDestBrightness = 0xD34; // int32_t
    constexpr std::ptrdiff_t m_flBrightnessTimeStart = 0xD38; // GameTime_t
    constexpr std::ptrdiff_t m_hOldSpriteMaterial = 0xD40; // CWeakHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_nSpriteWidth = 0xDE8; // int32_t
    constexpr std::ptrdiff_t m_nSpriteHeight = 0xDEC; // int32_t
}

namespace C_Sun {
    constexpr std::ptrdiff_t m_fxSSSunFlareEffectIndex = 0xCC0; // ParticleIndex_t
    constexpr std::ptrdiff_t m_fxSunFlareEffectIndex = 0xCC4; // ParticleIndex_t
    constexpr std::ptrdiff_t m_fdistNormalize = 0xCC8; // float
    constexpr std::ptrdiff_t m_vSunPos = 0xCCC; // Vector
    constexpr std::ptrdiff_t m_vDirection = 0xCD8; // Vector
    constexpr std::ptrdiff_t m_iszEffectName = 0xCE8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSSEffectName = 0xCF0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_clrOverlay = 0xCF8; // Color
    constexpr std::ptrdiff_t m_bOn = 0xCFC; // bool
    constexpr std::ptrdiff_t m_bmaxColor = 0xCFD; // bool
    constexpr std::ptrdiff_t m_flSize = 0xD00; // float
    constexpr std::ptrdiff_t m_flHazeScale = 0xD04; // float
    constexpr std::ptrdiff_t m_flRotation = 0xD08; // float
    constexpr std::ptrdiff_t m_flHDRColorScale = 0xD0C; // float
    constexpr std::ptrdiff_t m_flAlphaHaze = 0xD10; // float
    constexpr std::ptrdiff_t m_flAlphaScale = 0xD14; // float
    constexpr std::ptrdiff_t m_flAlphaHdr = 0xD18; // float
    constexpr std::ptrdiff_t m_flFarZScale = 0xD1C; // float
}

namespace C_SunGlowOverlay {
    constexpr std::ptrdiff_t m_bModulateByDot = 0xD0; // bool
}

namespace C_Team {
    constexpr std::ptrdiff_t m_aPlayerControllers = 0x540; // C_NetworkUtlVectorBase<CHandle<CBasePlayerController>>
    constexpr std::ptrdiff_t m_aPlayers = 0x558; // C_NetworkUtlVectorBase<CHandle<C_BasePlayerPawn>>
    constexpr std::ptrdiff_t m_iScore = 0x570; // int32_t
    constexpr std::ptrdiff_t m_szTeamname = 0x574; // char[129]
}

namespace C_TeamRoundTimer {
    constexpr std::ptrdiff_t m_bTimerPaused = 0x540; // bool
    constexpr std::ptrdiff_t m_flTimeRemaining = 0x544; // float
    constexpr std::ptrdiff_t m_flTimerEndTime = 0x548; // GameTime_t
    constexpr std::ptrdiff_t m_bIsDisabled = 0x54C; // bool
    constexpr std::ptrdiff_t m_bShowInHUD = 0x54D; // bool
    constexpr std::ptrdiff_t m_nTimerLength = 0x550; // int32_t
    constexpr std::ptrdiff_t m_nTimerInitialLength = 0x554; // int32_t
    constexpr std::ptrdiff_t m_nTimerMaxLength = 0x558; // int32_t
    constexpr std::ptrdiff_t m_bAutoCountdown = 0x55C; // bool
    constexpr std::ptrdiff_t m_nSetupTimeLength = 0x560; // int32_t
    constexpr std::ptrdiff_t m_nState = 0x564; // int32_t
    constexpr std::ptrdiff_t m_bStartPaused = 0x568; // bool
    constexpr std::ptrdiff_t m_bInCaptureWatchState = 0x569; // bool
    constexpr std::ptrdiff_t m_flTotalTime = 0x56C; // float
    constexpr std::ptrdiff_t m_bStopWatchTimer = 0x570; // bool
    constexpr std::ptrdiff_t m_bFireFinished = 0x571; // bool
    constexpr std::ptrdiff_t m_bFire5MinRemain = 0x572; // bool
    constexpr std::ptrdiff_t m_bFire4MinRemain = 0x573; // bool
    constexpr std::ptrdiff_t m_bFire3MinRemain = 0x574; // bool
    constexpr std::ptrdiff_t m_bFire2MinRemain = 0x575; // bool
    constexpr std::ptrdiff_t m_bFire1MinRemain = 0x576; // bool
    constexpr std::ptrdiff_t m_bFire30SecRemain = 0x577; // bool
    constexpr std::ptrdiff_t m_bFire10SecRemain = 0x578; // bool
    constexpr std::ptrdiff_t m_bFire5SecRemain = 0x579; // bool
    constexpr std::ptrdiff_t m_bFire4SecRemain = 0x57A; // bool
    constexpr std::ptrdiff_t m_bFire3SecRemain = 0x57B; // bool
    constexpr std::ptrdiff_t m_bFire2SecRemain = 0x57C; // bool
    constexpr std::ptrdiff_t m_bFire1SecRemain = 0x57D; // bool
    constexpr std::ptrdiff_t m_nOldTimerLength = 0x580; // int32_t
    constexpr std::ptrdiff_t m_nOldTimerState = 0x584; // int32_t
}

namespace C_TextureBasedAnimatable {
    constexpr std::ptrdiff_t m_bLoop = 0xCC0; // bool
    constexpr std::ptrdiff_t m_flFPS = 0xCC4; // float
    constexpr std::ptrdiff_t m_hPositionKeys = 0xCC8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hRotationKeys = 0xCD0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_vAnimationBoundsMin = 0xCD8; // Vector
    constexpr std::ptrdiff_t m_vAnimationBoundsMax = 0xCE4; // Vector
    constexpr std::ptrdiff_t m_flStartTime = 0xCF0; // float
    constexpr std::ptrdiff_t m_flStartFrame = 0xCF4; // float
}

namespace C_TonemapController2 {
    constexpr std::ptrdiff_t m_flAutoExposureMin = 0x540; // float
    constexpr std::ptrdiff_t m_flAutoExposureMax = 0x544; // float
    constexpr std::ptrdiff_t m_flTonemapPercentTarget = 0x548; // float
    constexpr std::ptrdiff_t m_flTonemapPercentBrightPixels = 0x54C; // float
    constexpr std::ptrdiff_t m_flTonemapMinAvgLum = 0x550; // float
    constexpr std::ptrdiff_t m_flExposureAdaptationSpeedUp = 0x554; // float
    constexpr std::ptrdiff_t m_flExposureAdaptationSpeedDown = 0x558; // float
    constexpr std::ptrdiff_t m_flTonemapEVSmoothingRange = 0x55C; // float
}

namespace C_TriggerBuoyancy {
    constexpr std::ptrdiff_t m_BuoyancyHelper = 0xCC8; // CBuoyancyHelper
    constexpr std::ptrdiff_t m_flFluidDensity = 0xCE8; // float
}

namespace C_ViewmodelWeapon {
    constexpr std::ptrdiff_t m_worldModel = 0xE80; // char*
}

namespace C_VoteController {
    constexpr std::ptrdiff_t m_iActiveIssueIndex = 0x550; // int32_t
    constexpr std::ptrdiff_t m_iOnlyTeamToVote = 0x554; // int32_t
    constexpr std::ptrdiff_t m_nVoteOptionCount = 0x558; // int32_t[5]
    constexpr std::ptrdiff_t m_nPotentialVotes = 0x56C; // int32_t
    constexpr std::ptrdiff_t m_bVotesDirty = 0x570; // bool
    constexpr std::ptrdiff_t m_bTypeDirty = 0x571; // bool
    constexpr std::ptrdiff_t m_bIsYesNoVote = 0x572; // bool
}

namespace C_WeaponBaseItem {
    constexpr std::ptrdiff_t m_SequenceCompleteTimer = 0x19F0; // CountdownTimer
    constexpr std::ptrdiff_t m_bRedraw = 0x1A08; // bool
}

namespace C_WeaponShield {
    constexpr std::ptrdiff_t m_flDisplayHealth = 0x1A10; // float
}

namespace C_WeaponTaser {
    constexpr std::ptrdiff_t m_fFireTime = 0x1A10; // GameTime_t
}

namespace C_fogplayerparams_t {
    constexpr std::ptrdiff_t m_hCtrl = 0x8; // CHandle<C_FogController>
    constexpr std::ptrdiff_t m_flTransitionTime = 0xC; // float
    constexpr std::ptrdiff_t m_OldColor = 0x10; // Color
    constexpr std::ptrdiff_t m_flOldStart = 0x14; // float
    constexpr std::ptrdiff_t m_flOldEnd = 0x18; // float
    constexpr std::ptrdiff_t m_flOldMaxDensity = 0x1C; // float
    constexpr std::ptrdiff_t m_flOldHDRColorScale = 0x20; // float
    constexpr std::ptrdiff_t m_flOldFarZ = 0x24; // float
    constexpr std::ptrdiff_t m_NewColor = 0x28; // Color
    constexpr std::ptrdiff_t m_flNewStart = 0x2C; // float
    constexpr std::ptrdiff_t m_flNewEnd = 0x30; // float
    constexpr std::ptrdiff_t m_flNewMaxDensity = 0x34; // float
    constexpr std::ptrdiff_t m_flNewHDRColorScale = 0x38; // float
    constexpr std::ptrdiff_t m_flNewFarZ = 0x3C; // float
}

namespace CompMatMutatorCondition_t {
    constexpr std::ptrdiff_t m_nMutatorCondition = 0x0; // CompMatPropertyMutatorConditionType_t
    constexpr std::ptrdiff_t m_strMutatorConditionContainerName = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_strMutatorConditionContainerVarName = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_strMutatorConditionContainerVarValue = 0x18; // CUtlString
    constexpr std::ptrdiff_t m_bPassWhenTrue = 0x20; // bool
}

namespace CompMatPropertyMutator_t {
    constexpr std::ptrdiff_t m_bEnabled = 0x0; // bool
    constexpr std::ptrdiff_t m_nMutatorCommandType = 0x4; // CompMatPropertyMutatorType_t
    constexpr std::ptrdiff_t m_strInitWith_Container = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_strCopyProperty_InputContainerSrc = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_strCopyProperty_InputContainerProperty = 0x18; // CUtlString
    constexpr std::ptrdiff_t m_strCopyProperty_TargetProperty = 0x20; // CUtlString
    constexpr std::ptrdiff_t m_strRandomRollInputVars_SeedInputVar = 0x28; // CUtlString
    constexpr std::ptrdiff_t m_vecRandomRollInputVars_InputVarsToRoll = 0x30; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_strCopyMatchingKeys_InputContainerSrc = 0x48; // CUtlString
    constexpr std::ptrdiff_t m_strCopyKeysWithSuffix_InputContainerSrc = 0x50; // CUtlString
    constexpr std::ptrdiff_t m_strCopyKeysWithSuffix_FindSuffix = 0x58; // CUtlString
    constexpr std::ptrdiff_t m_strCopyKeysWithSuffix_ReplaceSuffix = 0x60; // CUtlString
    constexpr std::ptrdiff_t m_nSetValue_Value = 0x68; // CompositeMaterialInputLooseVariable_t
    constexpr std::ptrdiff_t m_strGenerateTexture_TargetParam = 0x2D8; // CUtlString
    constexpr std::ptrdiff_t m_strGenerateTexture_InitialContainer = 0x2E0; // CUtlString
    constexpr std::ptrdiff_t m_nResolution = 0x2E8; // int32_t
    constexpr std::ptrdiff_t m_bIsScratchTarget = 0x2EC; // bool
    constexpr std::ptrdiff_t m_bSplatDebugInfo = 0x2ED; // bool
    constexpr std::ptrdiff_t m_bCaptureInRenderDoc = 0x2EE; // bool
    constexpr std::ptrdiff_t m_vecTexGenInstructions = 0x2F0; // CUtlVector<CompMatPropertyMutator_t>
    constexpr std::ptrdiff_t m_vecConditionalMutators = 0x308; // CUtlVector<CompMatPropertyMutator_t>
    constexpr std::ptrdiff_t m_strPopInputQueue_Container = 0x320; // CUtlString
    constexpr std::ptrdiff_t m_strDrawText_InputContainerSrc = 0x328; // CUtlString
    constexpr std::ptrdiff_t m_strDrawText_InputContainerProperty = 0x330; // CUtlString
    constexpr std::ptrdiff_t m_vecDrawText_Position = 0x338; // Vector2D
    constexpr std::ptrdiff_t m_colDrawText_Color = 0x340; // Color
    constexpr std::ptrdiff_t m_strDrawText_Font = 0x348; // CUtlString
    constexpr std::ptrdiff_t m_vecConditions = 0x350; // CUtlVector<CompMatMutatorCondition_t>
}

namespace CompositeMaterialAssemblyProcedure_t {
    constexpr std::ptrdiff_t m_vecCompMatIncludes = 0x0; // CUtlVector<CResourceName>
    constexpr std::ptrdiff_t m_vecMatchFilters = 0x18; // CUtlVector<CompositeMaterialMatchFilter_t>
    constexpr std::ptrdiff_t m_vecCompositeInputContainers = 0x30; // CUtlVector<CompositeMaterialInputContainer_t>
    constexpr std::ptrdiff_t m_vecPropertyMutators = 0x48; // CUtlVector<CompMatPropertyMutator_t>
}

namespace CompositeMaterialEditorPoint_t {
    constexpr std::ptrdiff_t m_ModelName = 0x0; // CResourceName
    constexpr std::ptrdiff_t m_nSequenceIndex = 0xE0; // int32_t
    constexpr std::ptrdiff_t m_flCycle = 0xE4; // float
    constexpr std::ptrdiff_t m_KVModelStateChoices = 0xE8; // KeyValues3
    constexpr std::ptrdiff_t m_bEnableChildModel = 0xF8; // bool
    constexpr std::ptrdiff_t m_ChildModelName = 0x100; // CResourceName
    constexpr std::ptrdiff_t m_vecCompositeMaterialAssemblyProcedures = 0x1E0; // CUtlVector<CompositeMaterialAssemblyProcedure_t>
    constexpr std::ptrdiff_t m_vecCompositeMaterials = 0x1F8; // CUtlVector<CompositeMaterial_t>
}

namespace CompositeMaterialInputContainer_t {
    constexpr std::ptrdiff_t m_bEnabled = 0x0; // bool
    constexpr std::ptrdiff_t m_nCompositeMaterialInputContainerSourceType = 0x4; // CompositeMaterialInputContainerSourceType_t
    constexpr std::ptrdiff_t m_strSpecificContainerMaterial = 0x8; // CResourceName
    constexpr std::ptrdiff_t m_strAttrName = 0xE8; // CUtlString
    constexpr std::ptrdiff_t m_strAlias = 0xF0; // CUtlString
    constexpr std::ptrdiff_t m_vecLooseVariables = 0xF8; // CUtlVector<CompositeMaterialInputLooseVariable_t>
    constexpr std::ptrdiff_t m_strAttrNameForVar = 0x110; // CUtlString
    constexpr std::ptrdiff_t m_bExposeExternally = 0x118; // bool
}

namespace CompositeMaterialInputLooseVariable_t {
    constexpr std::ptrdiff_t m_strName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_bExposeExternally = 0x8; // bool
    constexpr std::ptrdiff_t m_strExposedFriendlyName = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_strExposedFriendlyGroupName = 0x18; // CUtlString
    constexpr std::ptrdiff_t m_bExposedVariableIsFixedRange = 0x20; // bool
    constexpr std::ptrdiff_t m_strExposedVisibleWhenTrue = 0x28; // CUtlString
    constexpr std::ptrdiff_t m_strExposedHiddenWhenTrue = 0x30; // CUtlString
    constexpr std::ptrdiff_t m_nVariableType = 0x38; // CompositeMaterialInputLooseVariableType_t
    constexpr std::ptrdiff_t m_bValueBoolean = 0x3C; // bool
    constexpr std::ptrdiff_t m_nValueIntX = 0x40; // int32_t
    constexpr std::ptrdiff_t m_nValueIntY = 0x44; // int32_t
    constexpr std::ptrdiff_t m_nValueIntZ = 0x48; // int32_t
    constexpr std::ptrdiff_t m_nValueIntW = 0x4C; // int32_t
    constexpr std::ptrdiff_t m_bHasFloatBounds = 0x50; // bool
    constexpr std::ptrdiff_t m_flValueFloatX = 0x54; // float
    constexpr std::ptrdiff_t m_flValueFloatX_Min = 0x58; // float
    constexpr std::ptrdiff_t m_flValueFloatX_Max = 0x5C; // float
    constexpr std::ptrdiff_t m_flValueFloatY = 0x60; // float
    constexpr std::ptrdiff_t m_flValueFloatY_Min = 0x64; // float
    constexpr std::ptrdiff_t m_flValueFloatY_Max = 0x68; // float
    constexpr std::ptrdiff_t m_flValueFloatZ = 0x6C; // float
    constexpr std::ptrdiff_t m_flValueFloatZ_Min = 0x70; // float
    constexpr std::ptrdiff_t m_flValueFloatZ_Max = 0x74; // float
    constexpr std::ptrdiff_t m_flValueFloatW = 0x78; // float
    constexpr std::ptrdiff_t m_flValueFloatW_Min = 0x7C; // float
    constexpr std::ptrdiff_t m_flValueFloatW_Max = 0x80; // float
    constexpr std::ptrdiff_t m_cValueColor4 = 0x84; // Color
    constexpr std::ptrdiff_t m_nValueSystemVar = 0x88; // CompositeMaterialVarSystemVar_t
    constexpr std::ptrdiff_t m_strResourceMaterial = 0x90; // CResourceName
    constexpr std::ptrdiff_t m_strTextureContentAssetPath = 0x170; // CUtlString
    constexpr std::ptrdiff_t m_strTextureRuntimeResourcePath = 0x178; // CResourceName
    constexpr std::ptrdiff_t m_strTextureCompilationVtexTemplate = 0x258; // CUtlString
    constexpr std::ptrdiff_t m_nTextureType = 0x260; // CompositeMaterialInputTextureType_t
    constexpr std::ptrdiff_t m_strString = 0x268; // CUtlString
}

namespace CompositeMaterialMatchFilter_t {
    constexpr std::ptrdiff_t m_nCompositeMaterialMatchFilterType = 0x0; // CompositeMaterialMatchFilterType_t
    constexpr std::ptrdiff_t m_strMatchFilter = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_strMatchValue = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_bPassWhenTrue = 0x18; // bool
}

namespace CompositeMaterial_t {
    constexpr std::ptrdiff_t m_TargetKVs = 0x8; // KeyValues3
    constexpr std::ptrdiff_t m_PreGenerationKVs = 0x18; // KeyValues3
    constexpr std::ptrdiff_t m_FinalKVs = 0x28; // KeyValues3
    constexpr std::ptrdiff_t m_vecGeneratedTextures = 0x40; // CUtlVector<GeneratedTextureHandle_t>
}

namespace CountdownTimer {
    constexpr std::ptrdiff_t m_duration = 0x8; // float
    constexpr std::ptrdiff_t m_timestamp = 0xC; // GameTime_t
    constexpr std::ptrdiff_t m_timescale = 0x10; // float
    constexpr std::ptrdiff_t m_nWorldGroupId = 0x14; // WorldGroupId_t
}

namespace EngineCountdownTimer {
    constexpr std::ptrdiff_t m_duration = 0x8; // float
    constexpr std::ptrdiff_t m_timestamp = 0xC; // float
    constexpr std::ptrdiff_t m_timescale = 0x10; // float
}

namespace EntityRenderAttribute_t {
    constexpr std::ptrdiff_t m_ID = 0x30; // CUtlStringToken
    constexpr std::ptrdiff_t m_Values = 0x34; // Vector4D
}

namespace EntitySpottedState_t {
    constexpr std::ptrdiff_t m_bSpotted = 0x8; // bool
    constexpr std::ptrdiff_t m_bSpottedByMask = 0xC; // uint32_t[2]
}

namespace GeneratedTextureHandle_t {
    constexpr std::ptrdiff_t m_strBitmapName = 0x0; // CUtlString
}

namespace IntervalTimer {
    constexpr std::ptrdiff_t m_timestamp = 0x8; // GameTime_t
    constexpr std::ptrdiff_t m_nWorldGroupId = 0xC; // WorldGroupId_t
}

namespace PhysicsRagdollPose_t {
    constexpr std::ptrdiff_t __m_pChainEntity = 0x8; // CNetworkVarChainer
    constexpr std::ptrdiff_t m_Transforms = 0x30; // C_NetworkUtlVectorBase<CTransform>
    constexpr std::ptrdiff_t m_hOwner = 0x48; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_bDirty = 0x68; // bool
}

namespace SellbackPurchaseEntry_t {
    constexpr std::ptrdiff_t m_unDefIdx = 0x30; // uint16_t
    constexpr std::ptrdiff_t m_nCost = 0x34; // int32_t
    constexpr std::ptrdiff_t m_nPrevArmor = 0x38; // int32_t
    constexpr std::ptrdiff_t m_bPrevHelmet = 0x3C; // bool
    constexpr std::ptrdiff_t m_hItem = 0x40; // CEntityHandle
}

namespace ServerAuthoritativeWeaponSlot_t {
    constexpr std::ptrdiff_t unClass = 0x28; // uint16_t
    constexpr std::ptrdiff_t unSlot = 0x2A; // uint16_t
    constexpr std::ptrdiff_t unItemDefIdx = 0x2C; // uint16_t
}

namespace TimedEvent {
    constexpr std::ptrdiff_t m_TimeBetweenEvents = 0x0; // float
    constexpr std::ptrdiff_t m_fNextEvent = 0x4; // float
}

namespace VPhysicsCollisionAttribute_t {
    constexpr std::ptrdiff_t m_nInteractsAs = 0x8; // uint64_t
    constexpr std::ptrdiff_t m_nInteractsWith = 0x10; // uint64_t
    constexpr std::ptrdiff_t m_nInteractsExclude = 0x18; // uint64_t
    constexpr std::ptrdiff_t m_nEntityId = 0x20; // uint32_t
    constexpr std::ptrdiff_t m_nOwnerId = 0x24; // uint32_t
    constexpr std::ptrdiff_t m_nHierarchyId = 0x28; // uint16_t
    constexpr std::ptrdiff_t m_nCollisionGroup = 0x2A; // uint8_t
    constexpr std::ptrdiff_t m_nCollisionFunctionMask = 0x2B; // uint8_t
}

namespace ViewAngleServerChange_t {
    constexpr std::ptrdiff_t nType = 0x30; // FixAngleSet_t
    constexpr std::ptrdiff_t qAngle = 0x34; // QAngle
    constexpr std::ptrdiff_t nIndex = 0x40; // uint32_t
}

namespace WeaponPurchaseCount_t {
    constexpr std::ptrdiff_t m_nItemDefIndex = 0x30; // uint16_t
    constexpr std::ptrdiff_t m_nCount = 0x32; // uint16_t
}

namespace WeaponPurchaseTracker_t {
    constexpr std::ptrdiff_t m_weaponPurchases = 0x8; // C_UtlVectorEmbeddedNetworkVar<WeaponPurchaseCount_t>
}

namespace audioparams_t {
    constexpr std::ptrdiff_t localSound = 0x8; // Vector[8]
    constexpr std::ptrdiff_t soundscapeIndex = 0x68; // int32_t
    constexpr std::ptrdiff_t localBits = 0x6C; // uint8_t
    constexpr std::ptrdiff_t soundscapeEntityListIndex = 0x70; // int32_t
    constexpr std::ptrdiff_t soundEventHash = 0x74; // uint32_t
}

namespace fogparams_t {
    constexpr std::ptrdiff_t dirPrimary = 0x8; // Vector
    constexpr std::ptrdiff_t colorPrimary = 0x14; // Color
    constexpr std::ptrdiff_t colorSecondary = 0x18; // Color
    constexpr std::ptrdiff_t colorPrimaryLerpTo = 0x1C; // Color
    constexpr std::ptrdiff_t colorSecondaryLerpTo = 0x20; // Color
    constexpr std::ptrdiff_t start = 0x24; // float
    constexpr std::ptrdiff_t end = 0x28; // float
    constexpr std::ptrdiff_t farz = 0x2C; // float
    constexpr std::ptrdiff_t maxdensity = 0x30; // float
    constexpr std::ptrdiff_t exponent = 0x34; // float
    constexpr std::ptrdiff_t HDRColorScale = 0x38; // float
    constexpr std::ptrdiff_t skyboxFogFactor = 0x3C; // float
    constexpr std::ptrdiff_t skyboxFogFactorLerpTo = 0x40; // float
    constexpr std::ptrdiff_t startLerpTo = 0x44; // float
    constexpr std::ptrdiff_t endLerpTo = 0x48; // float
    constexpr std::ptrdiff_t maxdensityLerpTo = 0x4C; // float
    constexpr std::ptrdiff_t lerptime = 0x50; // GameTime_t
    constexpr std::ptrdiff_t duration = 0x54; // float
    constexpr std::ptrdiff_t blendtobackground = 0x58; // float
    constexpr std::ptrdiff_t scattering = 0x5C; // float
    constexpr std::ptrdiff_t locallightscale = 0x60; // float
    constexpr std::ptrdiff_t enable = 0x64; // bool
    constexpr std::ptrdiff_t blend = 0x65; // bool
    constexpr std::ptrdiff_t m_bNoReflectionFog = 0x66; // bool
    constexpr std::ptrdiff_t m_bPadding = 0x67; // bool
}

namespace shard_model_desc_t {
    constexpr std::ptrdiff_t m_nModelID = 0x8; // int32_t
    constexpr std::ptrdiff_t m_hMaterial = 0x10; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_solid = 0x18; // ShardSolid_t
    constexpr std::ptrdiff_t m_ShatterPanelMode = 0x19; // ShatterPanelMode
    constexpr std::ptrdiff_t m_vecPanelSize = 0x1C; // Vector2D
    constexpr std::ptrdiff_t m_vecStressPositionA = 0x24; // Vector2D
    constexpr std::ptrdiff_t m_vecStressPositionB = 0x2C; // Vector2D
    constexpr std::ptrdiff_t m_vecPanelVertices = 0x38; // C_NetworkUtlVectorBase<Vector2D>
    constexpr std::ptrdiff_t m_flGlassHalfThickness = 0x50; // float
    constexpr std::ptrdiff_t m_bHasParent = 0x54; // bool
    constexpr std::ptrdiff_t m_bParentFrozen = 0x55; // bool
    constexpr std::ptrdiff_t m_SurfacePropStringToken = 0x58; // CUtlStringToken
}

namespace sky3dparams_t {
    constexpr std::ptrdiff_t scale = 0x8; // int16_t
    constexpr std::ptrdiff_t origin = 0xC; // Vector
    constexpr std::ptrdiff_t bClip3DSkyBoxNearToWorldFar = 0x18; // bool
    constexpr std::ptrdiff_t flClip3DSkyBoxNearToWorldFarOffset = 0x1C; // float
    constexpr std::ptrdiff_t fog = 0x20; // fogparams_t
    constexpr std::ptrdiff_t m_nWorldGroupID = 0x88; // WorldGroupId_t
}
```

`SDK/client.dll.json`:

```json
{
  "ActiveModelConfig_t": {
    "m_AssociatedEntities": 56,
    "m_AssociatedEntityNames": 80,
    "m_Handle": 40,
    "m_Name": 48
  },
  "CAnimGraphNetworkedVariables": {
    "m_OwnerOnlyPredNetBoolVariables": 224,
    "m_OwnerOnlyPredNetByteVariables": 248,
    "m_OwnerOnlyPredNetFloatVariables": 368,
    "m_OwnerOnlyPredNetIntVariables": 296,
    "m_OwnerOnlyPredNetQuaternionVariables": 416,
    "m_OwnerOnlyPredNetUInt16Variables": 272,
    "m_OwnerOnlyPredNetUInt32Variables": 320,
    "m_OwnerOnlyPredNetUInt64Variables": 344,
    "m_OwnerOnlyPredNetVectorVariables": 392,
    "m_PredNetBoolVariables": 8,
    "m_PredNetByteVariables": 32,
    "m_PredNetFloatVariables": 152,
    "m_PredNetIntVariables": 80,
    "m_PredNetQuaternionVariables": 200,
    "m_PredNetUInt16Variables": 56,
    "m_PredNetUInt32Variables": 104,
    "m_PredNetUInt64Variables": 128,
    "m_PredNetVectorVariables": 176,
    "m_flLastTeleportTime": 452,
    "m_nBoolVariablesCount": 440,
    "m_nOwnerOnlyBoolVariablesCount": 444,
    "m_nRandomSeedOffset": 448
  },
  "CAttributeList": {
    "m_Attributes": 8,
    "m_pManager": 88
  },
  "CAttributeManager": {
    "m_CachedResults": 48,
    "m_ProviderType": 44,
    "m_Providers": 8,
    "m_bPreventLoopback": 40,
    "m_hOuter": 36,
    "m_iReapplyProvisionParity": 32
  },
  "CAttributeManager_cached_attribute_float_t": {
    "flIn": 0,
    "flOut": 16,
    "iAttribHook": 8
  },
  "CBaseAnimGraph": {
    "m_bAnimGraphUpdateEnabled": 3280,
    "m_bBuiltRagdoll": 3328,
    "m_bClientRagdoll": 3360,
    "m_bHasAnimatedMaterialAttributes": 3376,
    "m_bInitiallyPopulateInterpHistory": 3264,
    "m_bShouldAnimateDuringGameplayPause": 3265,
    "m_bSuppressAnimEventSounds": 3267,
    "m_flMaxSlopeDistance": 3284,
    "m_nForceBone": 3316,
    "m_pClientsideRagdoll": 3320,
    "m_pRagdollPose": 3352,
    "m_vLastSlopeCheckPos": 3288,
    "m_vecForce": 3304
  },
  "CBaseAnimGraphController": {
    "m_animGraphNetworkedVars": 64,
    "m_bClientSideAnimation": 4920,
    "m_bNetworkedAnimationInputsChanged": 4921,
    "m_bSequenceFinished": 4896,
    "m_baseLayer": 24,
    "m_flLastEventAnimTime": 4904,
    "m_flLastEventCycle": 4900,
    "m_flPlaybackRate": 4908,
    "m_flPrevAnimTime": 4916,
    "m_hAnimationUpdate": 5092,
    "m_hLastAnimEventSequence": 5096,
    "m_nAnimLoopMode": 4932,
    "m_nNewSequenceParity": 4924,
    "m_nPrevNewSequenceParity": 4922,
    "m_nPrevResetEventsParity": 4923,
    "m_nResetEventsParity": 4928
  },
  "CBasePlayerController": {
    "m_CommandContext": 1360,
    "m_bIsHLTV": 1592,
    "m_bIsLocalPlayerController": 1744,
    "m_hPawn": 1548,
    "m_hPredictedPawn": 1552,
    "m_hSplitOwner": 1560,
    "m_hSplitScreenPlayers": 1568,
    "m_iConnected": 1596,
    "m_iDesiredFOV": 1748,
    "m_iszPlayerName": 1600,
    "m_nFinalPredictedTick": 1352,
    "m_nInButtonsWhichAreToggles": 1536,
    "m_nSplitScreenSlot": 1556,
    "m_nTickBase": 1544,
    "m_steamID": 1736
  },
  "CBasePlayerVData": {
    "m_flArmDamageMultiplier": 312,
    "m_flChestDamageMultiplier": 280,
    "m_flCrouchTime": 372,
    "m_flDrowningDamageInterval": 348,
    "m_flHeadDamageMultiplier": 264,
    "m_flHoldBreathTime": 344,
    "m_flLegDamageMultiplier": 328,
    "m_flStomachDamageMultiplier": 296,
    "m_flUseAngleTolerance": 368,
    "m_flUseRange": 364,
    "m_nDrowningDamageInitial": 352,
    "m_nDrowningDamageMax": 356,
    "m_nWaterSpeed": 360,
    "m_sModelName": 40
  },
  "CBasePlayerWeaponVData": {
    "m_aShootSounds": 536,
    "m_bAllowFlipping": 265,
    "m_bAutoSwitchFrom": 529,
    "m_bAutoSwitchTo": 528,
    "m_bBuiltRightHanded": 264,
    "m_bIsFullAuto": 266,
    "m_iDefaultClip1": 516,
    "m_iDefaultClip2": 520,
    "m_iFlags": 504,
    "m_iMaxClip1": 508,
    "m_iMaxClip2": 512,
    "m_iPosition": 572,
    "m_iRumbleEffect": 532,
    "m_iSlot": 568,
    "m_iWeight": 524,
    "m_nNumBullets": 268,
    "m_nPrimaryAmmoType": 505,
    "m_nSecondaryAmmoType": 506,
    "m_sMuzzleAttachment": 272,
    "m_szMuzzleFlashParticle": 280,
    "m_szWorldModel": 40
  },
  "CBaseProp": {
    "m_bConformToCollisionBounds": 3720,
    "m_bModelOverrodeBlockLOS": 3712,
    "m_iShapeType": 3716,
    "m_mPreferredCatchTransform": 3724
  },
  "CBodyComponent": {
    "__m_pChainEntity": 32,
    "m_pSceneNode": 8
  },
  "CBodyComponentBaseAnimGraph": {
    "__m_pChainEntity": 6336,
    "m_animationController": 1152
  },
  "CBodyComponentBaseModelEntity": {
    "__m_pChainEntity": 1152
  },
  "CBodyComponentPoint": {
    "__m_pChainEntity": 416,
    "m_sceneNode": 80
  },
  "CBodyComponentSkeletonInstance": {
    "__m_pChainEntity": 1104,
    "m_skeletonInstance": 80
  },
  "CBombTarget": {
    "m_bBombPlantedHere": 3272
  },
  "CBuoyancyHelper": {
    "m_flFluidDensity": 24
  },
  "CCSGameModeRules": {
    "__m_pChainEntity": 8
  },
  "CCSGameModeRules_Deathmatch": {
    "m_bFirstThink": 48,
    "m_bFirstThinkAfterConnected": 49,
    "m_flDMBonusStartTime": 52,
    "m_flDMBonusTimeLength": 56,
    "m_nDMBonusWeaponLoadoutSlot": 60
  },
  "CCSObserver_ObserverServices": {
    "m_bObserverInterpolationNeedsDeferredSetup": 164,
    "m_flObsInterp_PathLength": 116,
    "m_hLastObserverTarget": 88,
    "m_obsInterpState": 160,
    "m_qObsInterp_OrientationStart": 128,
    "m_qObsInterp_OrientationTravelDir": 144,
    "m_vecObserverInterpStartPos": 104,
    "m_vecObserverInterpolateOffset": 92
  },
  "CCSPlayerBase_CameraServices": {
    "m_flFOVRate": 540,
    "m_flFOVTime": 536,
    "m_flLastShotFOV": 548,
    "m_hZoomOwner": 544,
    "m_iFOV": 528,
    "m_iFOVStart": 532
  },
  "CCSPlayerController": {
    "m_bAbandonAllowsSurrender": 1998,
    "m_bAbandonOffersInstantSurrender": 1999,
    "m_bCanControlObservedBot": 2024,
    "m_bCannotBeKicked": 1996,
    "m_bControllingBot": 2016,
    "m_bDisconnection1MinWarningPrinted": 2000,
    "m_bEverFullyConnected": 1997,
    "m_bEverPlayedOnTeam": 1852,
    "m_bHasBeenControlledByPlayerThisRound": 2018,
    "m_bHasCommunicationAbuseMute": 1828,
    "m_bHasControlledBotThisRound": 2017,
    "m_bIsPlayerNameDirty": 2100,
    "m_bPawnHasDefuser": 2048,
    "m_bPawnHasHelmet": 2049,
    "m_bPawnIsAlive": 2036,
    "m_bScoreReported": 2001,
    "m_flForceTeamTime": 1844,
    "m_flPreviousForceJoinTeamTime": 1856,
    "m_hObserverPawn": 2032,
    "m_hOriginalControllerOfCurrentPawn": 2064,
    "m_hPlayerPawn": 2028,
    "m_iCoachingTeam": 1880,
    "m_iCompTeammateColor": 1848,
    "m_iCompetitiveRankType": 1912,
    "m_iCompetitiveRanking": 1904,
    "m_iCompetitiveRankingPredicted_Loss": 1920,
    "m_iCompetitiveRankingPredicted_Tie": 1924,
    "m_iCompetitiveRankingPredicted_Win": 1916,
    "m_iCompetitiveWins": 1908,
    "m_iDraftIndex": 1984,
    "m_iMVPs": 2096,
    "m_iPawnArmor": 2044,
    "m_iPawnBotDifficulty": 2060,
    "m_iPawnHealth": 2040,
    "m_iPawnLifetimeEnd": 2056,
    "m_iPawnLifetimeStart": 2052,
    "m_iPendingTeamNum": 1840,
    "m_iPing": 1824,
    "m_iScore": 2068,
    "m_msQueuedModeDisconnectionTimestamp": 1988,
    "m_nBotsControlledThisRound": 2020,
    "m_nDisconnectionTick": 2004,
    "m_nEndMatchNextMapVote": 1928,
    "m_nPawnCharacterDefIndex": 2050,
    "m_nPlayerDominated": 1888,
    "m_nPlayerDominatingMe": 1896,
    "m_nQuestProgressReason": 1936,
    "m_pActionTrackingServices": 1808,
    "m_pDamageServices": 1816,
    "m_pInGameMoneyServices": 1792,
    "m_pInventoryServices": 1800,
    "m_sSanitizedPlayerName": 1872,
    "m_szClan": 1864,
    "m_szCrosshairCodes": 1832,
    "m_uiAbandonRecordedReason": 1992,
    "m_unActiveQuestId": 1932,
    "m_unPlayerTvControlFlags": 1940,
    "m_vecKills": 2072
  },
  "CCSPlayerController_ActionTrackingServices": {
    "m_iNumRoundKills": 264,
    "m_iNumRoundKillsHeadshots": 268,
    "m_matchStats": 144,
    "m_perRoundStats": 64,
    "m_unTotalRoundDamageDealt": 272
  },
  "CCSPlayerController_DamageServices": {
    "m_DamageList": 72,
    "m_nSendUpdate": 64
  },
  "CCSPlayerController_InGameMoneyServices": {
    "m_iAccount": 64,
    "m_iCashSpentThisRound": 76,
    "m_iStartAccount": 68,
    "m_iTotalCashSpent": 72,
    "m_nPreviousAccount": 80
  },
  "CCSPlayerController_InventoryServices": {
    "m_nPersonaDataPublicCommendsFriendly": 104,
    "m_nPersonaDataPublicCommendsLeader": 96,
    "m_nPersonaDataPublicCommendsTeacher": 100,
    "m_nPersonaDataPublicLevel": 92,
    "m_rank": 68,
    "m_unMusicID": 64,
    "m_vecServerAuthoritativeWeaponSlots": 112
  },
  "CCSPlayer_ActionTrackingServices": {
    "m_bIsRescuing": 68,
    "m_hLastWeaponBeforeC4AutoSwitch": 64,
    "m_weaponPurchasesThisMatch": 72,
    "m_weaponPurchasesThisRound": 160
  },
  "CCSPlayer_BulletServices": {
    "m_totalHitsOnServer": 64
  },
  "CCSPlayer_BuyServices": {
    "m_vecSellbackPurchaseEntries": 64
  },
  "CCSPlayer_CameraServices": {
    "m_flDeathCamTilt": 552
  },
  "CCSPlayer_HostageServices": {
    "m_hCarriedHostage": 64,
    "m_hCarriedHostageProp": 68
  },
  "CCSPlayer_ItemServices": {
    "m_bHasDefuser": 64,
    "m_bHasHeavyArmor": 66,
    "m_bHasHelmet": 65
  },
  "CCSPlayer_MovementServices": {
    "m_StuckLast": 1132,
    "m_bDesiresDuck": 557,
    "m_bDuckOverride": 556,
    "m_bHasWalkMovedSinceLastJump": 601,
    "m_bInStuckTest": 602,
    "m_bOldJumpPressed": 1196,
    "m_bSpeedCropped": 1136,
    "m_bUpdatePredictedOriginAfterDataUpdate": 1236,
    "m_duckUntilOnGround": 600,
    "m_fStashGrenadeParameterWhen": 1212,
    "m_flDuckAmount": 548,
    "m_flDuckOffset": 560,
    "m_flDuckSpeed": 552,
    "m_flHeightAtJumpStart": 1240,
    "m_flJumpPressedTime": 1200,
    "m_flJumpUntil": 1204,
    "m_flJumpVel": 1208,
    "m_flLastDuckTime": 576,
    "m_flMaxFallVelocity": 528,
    "m_flMaxJumpHeightThisJump": 1244,
    "m_flOffsetTickCompleteTime": 1224,
    "m_flOffsetTickStashedSpeed": 1228,
    "m_flStamina": 1232,
    "m_flStuckCheckTime": 616,
    "m_flWaterEntryTime": 1144,
    "m_nButtonDownMaskPrev": 1216,
    "m_nDuckJumpTimeMsecs": 568,
    "m_nDuckTimeMsecs": 564,
    "m_nJumpTimeMsecs": 572,
    "m_nLadderSurfacePropIndex": 544,
    "m_nOldWaterLevel": 1140,
    "m_nTraceCount": 1128,
    "m_vecForward": 1148,
    "m_vecLadderNormal": 532,
    "m_vecLastPositionAtFullCrouchSpeed": 592,
    "m_vecLeft": 1160,
    "m_vecPreviouslyPredictedOrigin": 1184,
    "m_vecUp": 1172
  },
  "CCSPlayer_PingServices": {
    "m_hPlayerPing": 64
  },
  "CCSPlayer_ViewModelServices": {
    "m_hViewModel": 64
  },
  "CCSPlayer_WaterServices": {
    "m_flSwimSoundTime": 80,
    "m_flWaterJumpTime": 64,
    "m_vecWaterJumpVel": 68
  },
  "CCSPlayer_WeaponServices": {
    "m_bIsHoldingLookAtWeapon": 197,
    "m_bIsLookingAtWeapon": 196,
    "m_flNextAttack": 192
  },
  "CCSWeaponBaseVData": {
    "m_DefaultLoadoutSlot": 3056,
    "m_GearSlot": 3048,
    "m_GearSlotPosition": 3052,
    "m_WeaponCategory": 580,
    "m_WeaponType": 576,
    "m_angPivotAngle": 3352,
    "m_bCannotShootUnderwater": 3091,
    "m_bHasBurstMode": 3089,
    "m_bHideViewModelWhenZoomed": 3305,
    "m_bIsRevolver": 3090,
    "m_bMeleeWeapon": 3088,
    "m_bUnzoomsAfterShot": 3304,
    "m_eSilencerType": 3112,
    "m_flArmorRatio": 3384,
    "m_flAttackMovespeedFactor": 3272,
    "m_flBotAudibleRange": 3288,
    "m_flCycleTime": 3124,
    "m_flFlinchVelocityModifierLarge": 3400,
    "m_flFlinchVelocityModifierSmall": 3404,
    "m_flHeadshotMultiplier": 3380,
    "m_flHeatPerShot": 3276,
    "m_flIdleInterval": 3268,
    "m_flInaccuracyAltSoundThreshold": 3284,
    "m_flInaccuracyCrouch": 3148,
    "m_flInaccuracyFire": 3188,
    "m_flInaccuracyJump": 3164,
    "m_flInaccuracyJumpApex": 3248,
    "m_flInaccuracyJumpInitial": 3244,
    "m_flInaccuracyLadder": 3180,
    "m_flInaccuracyLand": 3172,
    "m_flInaccuracyMove": 3196,
    "m_flInaccuracyPitchShift": 3280,
    "m_flInaccuracyReload": 3252,
    "m_flInaccuracyStand": 3156,
    "m_flIronSightFOV": 3340,
    "m_flIronSightLooseness": 3348,
    "m_flIronSightPivotForward": 3344,
    "m_flIronSightPullUpSpeed": 3332,
    "m_flIronSightPutDownSpeed": 3336,
    "m_flMaxSpeed": 3132,
    "m_flPenetration": 3388,
    "m_flRange": 3392,
    "m_flRangeModifier": 3396,
    "m_flRecoilAngle": 3204,
    "m_flRecoilAngleVariance": 3212,
    "m_flRecoilMagnitude": 3220,
    "m_flRecoilMagnitudeVariance": 3228,
    "m_flRecoveryTimeCrouch": 3408,
    "m_flRecoveryTimeCrouchFinal": 3416,
    "m_flRecoveryTimeStand": 3412,
    "m_flRecoveryTimeStandFinal": 3420,
    "m_flSpread": 3140,
    "m_flThrowVelocity": 3432,
    "m_flTimeToIdleAfterFire": 3264,
    "m_flZoomTime0": 3320,
    "m_flZoomTime1": 3324,
    "m_flZoomTime2": 3328,
    "m_nCrosshairDeltaDistance": 3120,
    "m_nCrosshairMinDistance": 3116,
    "m_nDamage": 3376,
    "m_nKillAward": 3076,
    "m_nPrice": 3072,
    "m_nPrimaryReserveAmmoMax": 3080,
    "m_nRecoilSeed": 3256,
    "m_nRecoveryTransitionEndBullet": 3428,
    "m_nRecoveryTransitionStartBullet": 3424,
    "m_nSecondaryReserveAmmoMax": 3084,
    "m_nSpreadSeed": 3260,
    "m_nTracerFrequency": 3236,
    "m_nZoomFOV1": 3312,
    "m_nZoomFOV2": 3316,
    "m_nZoomLevels": 3308,
    "m_sWrongTeamMsg": 3064,
    "m_szAimsightLensMaskModel": 1256,
    "m_szAnimClass": 3448,
    "m_szAnimExtension": 3104,
    "m_szEjectBrassEffect": 1928,
    "m_szHeatEffect": 1704,
    "m_szMagazineModel": 1480,
    "m_szMuzzleFlashParticleAlt": 2152,
    "m_szMuzzleFlashThirdPersonParticle": 2376,
    "m_szMuzzleFlashThirdPersonParticleAlt": 2600,
    "m_szName": 3096,
    "m_szPlayerModel": 808,
    "m_szTracerParticle": 2824,
    "m_szUseRadioSubtitle": 3296,
    "m_szViewModel": 584,
    "m_szWorldDroppedModel": 1032,
    "m_vSmokeColor": 3436,
    "m_vecIronSightEyePos": 3364
  },
  "CClientAlphaProperty": {
    "m_bAlphaOverride": 0,
    "m_bShadowAlphaOverride": 0,
    "m_flFadeScale": 28,
    "m_flRenderFxDuration": 36,
    "m_flRenderFxStartTime": 32,
    "m_nAlpha": 19,
    "m_nDesyncOffset": 20,
    "m_nDistFadeEnd": 26,
    "m_nDistFadeStart": 24,
    "m_nRenderFX": 16,
    "m_nRenderMode": 17,
    "m_nReserved": 0,
    "m_nReserved2": 22
  },
  "CCollisionProperty": {
    "m_CollisionGroup": 94,
    "m_collisionAttribute": 16,
    "m_flBoundingRadius": 96,
    "m_flCapsuleRadius": 172,
    "m_nEnablePhysics": 95,
    "m_nSolidType": 91,
    "m_nSurroundType": 93,
    "m_triggerBloat": 92,
    "m_usSolidFlags": 90,
    "m_vCapsuleCenter1": 148,
    "m_vCapsuleCenter2": 160,
    "m_vecMaxs": 76,
    "m_vecMins": 64,
    "m_vecSpecifiedSurroundingMaxs": 112,
    "m_vecSpecifiedSurroundingMins": 100,
    "m_vecSurroundingMaxs": 124,
    "m_vecSurroundingMins": 136
  },
  "CComicBook": {
    "m_CoverImage": 8,
    "m_XmlFile": 24
  },
  "CCompositeMaterialEditorDoc": {
    "m_KVthumbnail": 40,
    "m_Points": 16,
    "m_nVersion": 8
  },
  "CDamageRecord": {
    "m_DamagerXuid": 72,
    "m_PlayerDamager": 40,
    "m_PlayerRecipient": 44,
    "m_RecipientXuid": 80,
    "m_bIsOtherEnemy": 104,
    "m_hPlayerControllerDamager": 48,
    "m_hPlayerControllerRecipient": 52,
    "m_iActualHealthRemoved": 92,
    "m_iDamage": 88,
    "m_iLastBulletUpdate": 100,
    "m_iNumHits": 96,
    "m_killType": 105,
    "m_szPlayerDamagerName": 56,
    "m_szPlayerRecipientName": 64
  },
  "CDecalInfo": {
    "m_flAnimationLifeSpan": 4,
    "m_flAnimationScale": 0,
    "m_flBoundingRadiusSqr": 52,
    "m_flFadeDuration": 16,
    "m_flFadeStartTime": 12,
    "m_flPlaceTime": 8,
    "m_nBoneIndex": 24,
    "m_nDecalMaterialIndex": 168,
    "m_nVBSlot": 20,
    "m_pNext": 64,
    "m_pPrev": 72,
    "m_vPosition": 40
  },
  "CEconItemAttribute": {
    "m_bSetBonus": 64,
    "m_flInitialValue": 56,
    "m_flValue": 52,
    "m_iAttributeDefinitionIndex": 48,
    "m_nRefundableCurrency": 60
  },
  "CEffectData": {
    "m_fFlags": 99,
    "m_flMagnitude": 68,
    "m_flRadius": 72,
    "m_flScale": 64,
    "m_hEntity": 56,
    "m_hOtherEntity": 60,
    "m_iEffectName": 108,
    "m_nAttachmentIndex": 100,
    "m_nAttachmentName": 104,
    "m_nColor": 98,
    "m_nDamageType": 88,
    "m_nEffectIndex": 80,
    "m_nExplosionType": 110,
    "m_nHitBox": 96,
    "m_nMaterial": 94,
    "m_nPenetrate": 92,
    "m_nSurfaceProp": 76,
    "m_vAngles": 44,
    "m_vNormal": 32,
    "m_vOrigin": 8,
    "m_vStart": 20
  },
  "CEntityIdentity": {
    "m_PathIndex": 64,
    "m_designerName": 32,
    "m_fDataObjectTypes": 60,
    "m_flags": 48,
    "m_name": 24,
    "m_nameStringableIndex": 20,
    "m_pNext": 96,
    "m_pNextByClass": 112,
    "m_pPrev": 88,
    "m_pPrevByClass": 104,
    "m_worldGroupId": 56
  },
  "CEntityInstance": {
    "m_CScriptComponent": 40,
    "m_iszPrivateVScripts": 8,
    "m_pEntity": 16
  },
  "CFireOverlay": {
    "m_flScale": 264,
    "m_nGUID": 268,
    "m_pOwner": 208,
    "m_vBaseColors": 216
  },
  "CFlashlightEffect": {
    "m_FlashlightTexture": 96,
    "m_MuzzleFlashTexture": 104,
    "m_bCastsShadows": 88,
    "m_bIsOn": 16,
    "m_bMuzzleFlashEnabled": 32,
    "m_flCurrentPullBackDist": 92,
    "m_flFarZ": 80,
    "m_flFov": 76,
    "m_flLinearAtten": 84,
    "m_flMuzzleFlashBrightness": 36,
    "m_quatMuzzleFlashOrientation": 48,
    "m_textureName": 112,
    "m_vecMuzzleFlashOrigin": 64
  },
  "CFuncWater": {
    "m_BuoyancyHelper": 3264
  },
  "CGameSceneNode": {
    "m_angAbsRotation": 212,
    "m_angRotation": 184,
    "m_bBoneMergeFlex": 0,
    "m_bDebugAbsOriginChanges": 230,
    "m_bDirtyBoneMergeBoneToRoot": 0,
    "m_bDirtyBoneMergeInfo": 0,
    "m_bDirtyHierarchy": 0,
    "m_bDormant": 231,
    "m_bForceParentToBeNetworked": 232,
    "m_bNetworkedAnglesChanged": 0,
    "m_bNetworkedPositionChanged": 0,
    "m_bNetworkedScaleChanged": 0,
    "m_bNotifyBoneTransformsChanged": 0,
    "m_bWillBeCallingPostDataUpdate": 0,
    "m_flAbsScale": 224,
    "m_flScale": 196,
    "m_flZOffset": 308,
    "m_hParent": 112,
    "m_hierarchyAttachName": 304,
    "m_nDoNotSetAnimTimeInInvalidatePhysicsCount": 237,
    "m_nHierarchicalDepth": 235,
    "m_nHierarchyType": 236,
    "m_nLatchAbsOrigin": 0,
    "m_nParentAttachmentOrBone": 228,
    "m_name": 240,
    "m_nodeToWorld": 16,
    "m_pChild": 64,
    "m_pNextSibling": 72,
    "m_pOwner": 48,
    "m_pParent": 56,
    "m_vRenderOrigin": 312,
    "m_vecAbsOrigin": 200,
    "m_vecOrigin": 128
  },
  "CGameSceneNodeHandle": {
    "m_hOwner": 8,
    "m_name": 12
  },
  "CGlobalLightBase": {
    "m_AmbientColor1": 110,
    "m_AmbientColor2": 114,
    "m_AmbientColor3": 118,
    "m_AmbientDirection": 56,
    "m_InspectorSpecularDirection": 80,
    "m_LightColor": 106,
    "m_ShadowDirection": 44,
    "m_SpecularColor": 100,
    "m_SpecularDirection": 68,
    "m_SpotLightAngles": 32,
    "m_SpotLightOrigin": 20,
    "m_ViewAngles": 224,
    "m_ViewOrigin": 212,
    "m_WorldPoints": 240,
    "m_bBackgroundClearNotRequired": 142,
    "m_bEnableSeparateSkyboxFog": 196,
    "m_bEnableShadows": 140,
    "m_bEnabled": 105,
    "m_bOldEnableShadows": 141,
    "m_bSpotLight": 16,
    "m_bStartDisabled": 104,
    "m_flAmbientScale1": 176,
    "m_flAmbientScale2": 180,
    "m_flCloud1Direction": 152,
    "m_flCloud1Speed": 148,
    "m_flCloud2Direction": 160,
    "m_flCloud2Speed": 156,
    "m_flCloudScale": 144,
    "m_flFOV": 128,
    "m_flFarZ": 136,
    "m_flFoWDarkness": 192,
    "m_flGroundScale": 184,
    "m_flLightScale": 188,
    "m_flNearZ": 132,
    "m_flSpecularIndependence": 96,
    "m_flSpecularPower": 92,
    "m_flSunDistance": 124,
    "m_flViewFoV": 236,
    "m_hEnvSky": 1212,
    "m_hEnvWind": 1208,
    "m_vFogOffsetLayer0": 1192,
    "m_vFogOffsetLayer1": 1200,
    "m_vFowColor": 200
  },
  "CGlowOverlay": {
    "m_ListIndex": 196,
    "m_Sprites": 48,
    "m_bActivated": 194,
    "m_bCacheGlowObstruction": 192,
    "m_bCacheSkyObstruction": 193,
    "m_bDirectional": 20,
    "m_bInSky": 36,
    "m_flGlowObstructionScale": 188,
    "m_flHDRColorScale": 184,
    "m_flProxyRadius": 180,
    "m_nSprites": 176,
    "m_queryHandle": 200,
    "m_skyObstructionScale": 40,
    "m_vDirection": 24,
    "m_vPos": 8
  },
  "CGlowProperty": {
    "m_bEligibleForScreenHighlight": 80,
    "m_bFlashing": 68,
    "m_bGlowing": 81,
    "m_fGlowColor": 8,
    "m_flGlowStartTime": 76,
    "m_flGlowTime": 72,
    "m_glowColorOverride": 64,
    "m_iGlowTeam": 52,
    "m_iGlowType": 48,
    "m_nGlowRange": 56,
    "m_nGlowRangeMin": 60
  },
  "CGlowSprite": {
    "m_flHorzSize": 12,
    "m_flVertSize": 16,
    "m_hMaterial": 24,
    "m_vColor": 0
  },
  "CGrenadeTracer": {
    "m_flTracerDuration": 3296,
    "m_nType": 3300
  },
  "CHitboxComponent": {
    "m_bvDisabledHitGroups": 36
  },
  "CInfoDynamicShadowHint": {
    "m_bDisabled": 1344,
    "m_flRange": 1348,
    "m_hLight": 1360,
    "m_nImportance": 1352,
    "m_nLightChoice": 1356
  },
  "CInfoDynamicShadowHintBox": {
    "m_vBoxMaxs": 1380,
    "m_vBoxMins": 1368
  },
  "CInfoOffscreenPanoramaTexture": {
    "m_RenderAttrName": 1368,
    "m_TargetEntities": 1376,
    "m_bCheckCSSClasses": 1784,
    "m_bDisabled": 1344,
    "m_nResolutionX": 1348,
    "m_nResolutionY": 1352,
    "m_nTargetChangeCount": 1400,
    "m_szLayoutFileName": 1360,
    "m_vecCSSClasses": 1408
  },
  "CInfoWorldLayer": {
    "m_bCreateAsChildSpawnGroup": 1402,
    "m_bEntitiesSpawned": 1401,
    "m_bWorldLayerActuallyVisible": 1408,
    "m_bWorldLayerVisible": 1400,
    "m_hLayerSpawnGroup": 1404,
    "m_layerName": 1392,
    "m_pOutputOnEntitiesSpawned": 1344,
    "m_worldName": 1384
  },
  "CInterpolatedValue": {
    "m_flEndTime": 4,
    "m_flEndValue": 12,
    "m_flStartTime": 0,
    "m_flStartValue": 8,
    "m_nInterpType": 16
  },
  "CLightComponent": {
    "__m_pChainEntity": 72,
    "m_Color": 133,
    "m_Pattern": 232,
    "m_SecondaryColor": 137,
    "m_SkyAmbientBounce": 412,
    "m_SkyColor": 404,
    "m_bEnabled": 324,
    "m_bFlicker": 325,
    "m_bMixedShadows": 417,
    "m_bPrecomputedFieldsValid": 326,
    "m_bRenderDiffuse": 208,
    "m_bRenderToCubemaps": 296,
    "m_bRenderTransmissive": 216,
    "m_bUseSecondaryColor": 416,
    "m_bUsesBakedShadowing": 284,
    "m_flAttenuation0": 164,
    "m_flAttenuation1": 168,
    "m_flAttenuation2": 172,
    "m_flBrightness": 144,
    "m_flBrightnessMult": 152,
    "m_flBrightnessScale": 148,
    "m_flCapsuleLength": 424,
    "m_flFadeMaxDist": 312,
    "m_flFadeMinDist": 308,
    "m_flFalloff": 160,
    "m_flFogContributionStength": 396,
    "m_flLightStyleStartTime": 420,
    "m_flMinRoughness": 428,
    "m_flNearClipPlane": 400,
    "m_flOrthoLightHeight": 224,
    "m_flOrthoLightWidth": 220,
    "m_flPhi": 180,
    "m_flPrecomputedMaxRange": 388,
    "m_flRange": 156,
    "m_flShadowCascadeCrossFade": 244,
    "m_flShadowCascadeDistance0": 252,
    "m_flShadowCascadeDistance1": 256,
    "m_flShadowCascadeDistance2": 260,
    "m_flShadowCascadeDistance3": 264,
    "m_flShadowCascadeDistanceFade": 248,
    "m_flShadowFadeMaxDist": 320,
    "m_flShadowFadeMinDist": 316,
    "m_flSkyIntensity": 408,
    "m_flTheta": 176,
    "m_hLightCookie": 184,
    "m_nBakedShadowIndex": 292,
    "m_nCascadeRenderStaticObjects": 240,
    "m_nCascades": 192,
    "m_nCastShadows": 196,
    "m_nDirectLight": 300,
    "m_nFogLightingMode": 392,
    "m_nIndirectLight": 304,
    "m_nRenderSpecular": 212,
    "m_nShadowCascadeResolution0": 268,
    "m_nShadowCascadeResolution1": 272,
    "m_nShadowCascadeResolution2": 276,
    "m_nShadowCascadeResolution3": 280,
    "m_nShadowHeight": 204,
    "m_nShadowPriority": 288,
    "m_nShadowWidth": 200,
    "m_nStyle": 228,
    "m_vPrecomputedBoundsMaxs": 340,
    "m_vPrecomputedBoundsMins": 328,
    "m_vPrecomputedOBBAngles": 364,
    "m_vPrecomputedOBBExtent": 376,
    "m_vPrecomputedOBBOrigin": 352
  },
  "CLogicRelay": {
    "m_OnSpawn": 1384,
    "m_OnTrigger": 1344,
    "m_bDisabled": 1424,
    "m_bFastRetrigger": 1427,
    "m_bPassthoughCaller": 1428,
    "m_bTriggerOnce": 1426,
    "m_bWaitForRefire": 1425
  },
  "CModelState": {
    "m_MeshGroupMask": 384,
    "m_ModelName": 168,
    "m_bClientClothCreationSuppressed": 232,
    "m_hModel": 160,
    "m_nClothUpdateFlags": 548,
    "m_nForceLOD": 547,
    "m_nIdealMotionType": 546
  },
  "CNetworkedSequenceOperation": {
    "m_bDiscontinuity": 29,
    "m_bSequenceChangeNetworked": 28,
    "m_flCycle": 16,
    "m_flPrevCycle": 12,
    "m_flPrevCycleForAnimEventDetection": 36,
    "m_flPrevCycleFromDiscontinuity": 32,
    "m_flWeight": 20,
    "m_hSequence": 8
  },
  "CPlayer_CameraServices": {
    "m_CurrentFog": 320,
    "m_OverrideFogColor": 433,
    "m_PlayerFog": 88,
    "m_PostProcessingVolumes": 288,
    "m_angDemoViewAngles": 504,
    "m_audio": 168,
    "m_bOverrideFogColor": 428,
    "m_bOverrideFogStartEnd": 453,
    "m_fOverrideFogEnd": 480,
    "m_fOverrideFogStart": 460,
    "m_flCsViewPunchAngleTickRatio": 80,
    "m_flOldPlayerViewOffsetZ": 316,
    "m_flOldPlayerZ": 312,
    "m_hActivePostProcessingVolume": 500,
    "m_hColorCorrectionCtrl": 152,
    "m_hOldFogController": 424,
    "m_hTonemapController": 160,
    "m_hViewEntity": 156,
    "m_nCsViewPunchAngleTick": 76,
    "m_vecCsViewPunchAngle": 64
  },
  "CPlayer_MovementServices": {
    "m_arrForceSubtickMoveWhen": 404,
    "m_flForwardMove": 420,
    "m_flLeftMove": 424,
    "m_flMaxspeed": 400,
    "m_flUpMove": 428,
    "m_nButtonDoublePressed": 120,
    "m_nButtons": 72,
    "m_nImpulse": 64,
    "m_nLastCommandNumberProcessed": 384,
    "m_nQueuedButtonChangeMask": 112,
    "m_nQueuedButtonDownMask": 104,
    "m_nToggleButtonDownMask": 392,
    "m_pButtonPressedCmdNumber": 128,
    "m_vecLastMovementImpulses": 432,
    "m_vecOldViewAngles": 444
  },
  "CPlayer_MovementServices_Humanoid": {
    "m_bDucked": 484,
    "m_bDucking": 485,
    "m_bInCrouch": 472,
    "m_bInDuckJump": 486,
    "m_flCrouchTransitionStartTime": 480,
    "m_flFallVelocity": 468,
    "m_flStepSoundTime": 464,
    "m_flSurfaceFriction": 500,
    "m_groundNormal": 488,
    "m_nCrouchState": 476,
    "m_nStepside": 520,
    "m_surfaceProps": 504
  },
  "CPlayer_ObserverServices": {
    "m_bForcedObserverMode": 76,
    "m_flObserverChaseDistance": 80,
    "m_flObserverChaseDistanceCalcTime": 84,
    "m_hObserverTarget": 68,
    "m_iObserverLastMode": 72,
    "m_iObserverMode": 64
  },
  "CPlayer_WeaponServices": {
    "m_bAllowSwitchToNoWeapon": 64,
    "m_hActiveWeapon": 96,
    "m_hLastWeapon": 100,
    "m_hMyWeapons": 72,
    "m_iAmmo": 104
  },
  "CPointOffScreenIndicatorUi": {
    "m_bBeenEnabled": 3872,
    "m_bHide": 3873,
    "m_flSeenTargetTime": 3876,
    "m_pTargetPanel": 3880
  },
  "CPointTemplate": {
    "m_ScriptCallbackScope": 1480,
    "m_ScriptSpawnCallback": 1472,
    "m_SpawnedEntityHandles": 1448,
    "m_bAsynchronouslySpawnEntities": 1372,
    "m_clientOnlyEntityBehavior": 1416,
    "m_createdSpawnGroupHandles": 1424,
    "m_flTimeoutInterval": 1368,
    "m_iszEntityFilterName": 1360,
    "m_iszSource2EntityLumpName": 1352,
    "m_iszWorldName": 1344,
    "m_ownerSpawnGroupType": 1420,
    "m_pOutputOnSpawned": 1376
  },
  "CPrecipitationVData": {
    "m_bBatchSameVolumeType": 272,
    "m_flInnerDistance": 264,
    "m_nAttachType": 268,
    "m_nRTEnvCP": 276,
    "m_nRTEnvCPComponent": 280,
    "m_szModifier": 288,
    "m_szParticlePrecipitationEffect": 40
  },
  "CProjectedTextureBase": {
    "m_LightColor": 36,
    "m_SpotlightTextureName": 84,
    "m_bAlwaysUpdate": 17,
    "m_bCameraSpace": 28,
    "m_bEnableShadows": 24,
    "m_bFlipHorizontal": 620,
    "m_bLightOnlyTarget": 26,
    "m_bLightWorld": 27,
    "m_bSimpleProjection": 25,
    "m_bState": 16,
    "m_bVolumetric": 52,
    "m_flAmbient": 80,
    "m_flBrightnessScale": 32,
    "m_flColorTransitionTime": 76,
    "m_flFarZ": 608,
    "m_flFlashlightTime": 64,
    "m_flIntensity": 40,
    "m_flLightFOV": 20,
    "m_flLinearAttenuation": 44,
    "m_flNearZ": 604,
    "m_flNoiseStrength": 60,
    "m_flPlaneOffset": 72,
    "m_flProjectionSize": 612,
    "m_flQuadraticAttenuation": 48,
    "m_flRotation": 616,
    "m_flVolumetricIntensity": 56,
    "m_hTargetEntity": 12,
    "m_nNumPlanes": 68,
    "m_nShadowQuality": 600,
    "m_nSpotlightTextureFrame": 596
  },
  "CRenderComponent": {
    "__m_pChainEntity": 16,
    "m_bEnableRendering": 96,
    "m_bInterpolationReadyToDraw": 176,
    "m_bIsRenderingWithViewModels": 80,
    "m_nSplitscreenFlags": 84
  },
  "CSMatchStats_t": {
    "m_iEnemy3Ks": 112,
    "m_iEnemy4Ks": 108,
    "m_iEnemy5Ks": 104
  },
  "CSPerRoundStats_t": {
    "m_iAssists": 56,
    "m_iCashEarned": 88,
    "m_iDamage": 60,
    "m_iDeaths": 52,
    "m_iEnemiesFlashed": 96,
    "m_iEquipmentValue": 64,
    "m_iHeadShotKills": 80,
    "m_iKillReward": 72,
    "m_iKills": 48,
    "m_iLiveTime": 76,
    "m_iMoneySaved": 68,
    "m_iObjective": 84,
    "m_iUtilityDamage": 92
  },
  "CScriptComponent": {
    "m_scriptClassName": 48
  },
  "CSkeletonInstance": {
    "m_bDirtyMotionType": 0,
    "m_bDisableSolidCollisionsForHierarchy": 914,
    "m_bIsAnimationEnabled": 912,
    "m_bIsGeneratingLatchedParentSpaceState": 0,
    "m_bUseParentRenderBounds": 913,
    "m_materialGroup": 916,
    "m_modelState": 352,
    "m_nHitboxSet": 920
  },
  "CSkyboxReference": {
    "m_hSkyCamera": 1348,
    "m_worldGroupId": 1344
  },
  "CTimeline": {
    "m_bStopped": 544,
    "m_flFinalValue": 536,
    "m_flInterval": 532,
    "m_flValues": 16,
    "m_nBucketCount": 528,
    "m_nCompressionType": 540,
    "m_nValueCounts": 272
  },
  "C_AttributeContainer": {
    "m_Item": 80,
    "m_iExternalItemProviderRegisteredToken": 1176,
    "m_ullRegisteredAsItemID": 1184
  },
  "C_BarnLight": {
    "m_Color": 3272,
    "m_LightStyleEvents": 3352,
    "m_LightStyleString": 3312,
    "m_LightStyleTargets": 3376,
    "m_QueuedLightStyleStrings": 3328,
    "m_StyleEvent": 3400,
    "m_bContactShadow": 3644,
    "m_bEnabled": 3264,
    "m_bPrecomputedFieldsValid": 3708,
    "m_fAlternateColorBrightness": 3672,
    "m_flBounceScale": 3652,
    "m_flBrightness": 3280,
    "m_flBrightnessScale": 3284,
    "m_flColorTemperature": 3276,
    "m_flFadeSizeEnd": 3696,
    "m_flFadeSizeStart": 3692,
    "m_flFogScale": 3688,
    "m_flFogStrength": 3680,
    "m_flLightStyleStartTime": 3320,
    "m_flLuminaireAnisotropy": 3304,
    "m_flLuminaireSize": 3300,
    "m_flMinRoughness": 3656,
    "m_flRange": 3600,
    "m_flShadowFadeSizeEnd": 3704,
    "m_flShadowFadeSizeStart": 3700,
    "m_flShape": 3568,
    "m_flSkirt": 3580,
    "m_flSkirtNear": 3584,
    "m_flSoftX": 3572,
    "m_flSoftY": 3576,
    "m_hLightCookie": 3560,
    "m_nBakeSpecularToCubemaps": 3616,
    "m_nBakedShadowIndex": 3292,
    "m_nBounceLight": 3648,
    "m_nCastShadows": 3632,
    "m_nColorMode": 3268,
    "m_nDirectLight": 3288,
    "m_nFog": 3676,
    "m_nFogShadows": 3684,
    "m_nLuminaireShape": 3296,
    "m_nShadowMapSize": 3636,
    "m_nShadowPriority": 3640,
    "m_vAlternateColor": 3660,
    "m_vBakeSpecularToCubemapsSize": 3620,
    "m_vPrecomputedBoundsMaxs": 3724,
    "m_vPrecomputedBoundsMins": 3712,
    "m_vPrecomputedOBBAngles": 3748,
    "m_vPrecomputedOBBExtent": 3760,
    "m_vPrecomputedOBBOrigin": 3736,
    "m_vShear": 3604,
    "m_vSizeParams": 3588
  },
  "C_BaseButton": {
    "m_glowEntity": 3264,
    "m_szDisplayText": 3272,
    "m_usable": 3268
  },
  "C_BaseCSGrenade": {
    "m_bClientPredictDelete": 6640,
    "m_bIsHeldByPlayer": 6642,
    "m_bJumpThrow": 6644,
    "m_bPinPulled": 6643,
    "m_bRedraw": 6641,
    "m_eThrowStatus": 6648,
    "m_fDropTime": 6664,
    "m_fThrowTime": 6652,
    "m_flThrowStrength": 6656,
    "m_flThrowStrengthApproach": 6660
  },
  "C_BaseCSGrenadeProjectile": {
    "flNextTrailLineTime": 4272,
    "m_arrTrajectoryTrailPointCreationTimes": 4320,
    "m_arrTrajectoryTrailPoints": 4296,
    "m_bCanCreateGrenadeTrail": 4277,
    "m_bExplodeEffectBegan": 4276,
    "m_flSpawnTime": 4256,
    "m_flTrajectoryTrailEffectCreationTime": 4344,
    "m_hSnapshotTrajectoryParticleSnapshot": 4288,
    "m_nBounces": 4224,
    "m_nExplodeEffectIndex": 4232,
    "m_nExplodeEffectTickBegin": 4240,
    "m_nSnapshotTrajectoryEffectIndex": 4280,
    "m_vInitialPosition": 4200,
    "m_vInitialVelocity": 4212,
    "m_vecExplodeEffectOrigin": 4244,
    "vecLastTrailLinePos": 4260
  },
  "C_BaseClientUIEntity": {
    "m_DialogXMLName": 3280,
    "m_PanelClassName": 3288,
    "m_PanelID": 3296,
    "m_bEnabled": 3272
  },
  "C_BaseCombatCharacter": {
    "m_bloodColor": 4144,
    "m_flFieldOfView": 4164,
    "m_flWaterNextTraceTime": 4160,
    "m_flWaterWorldZ": 4156,
    "m_hMyWearables": 4120,
    "m_leftFootAttachment": 4148,
    "m_nWaterWakeMode": 4152,
    "m_rightFootAttachment": 4149
  },
  "C_BaseDoor": {
    "m_bIsUsable": 3264
  },
  "C_BaseEntity": {
    "m_CBodyComponent": 48,
    "m_DataChangeEventRef": 1268,
    "m_EntClientFlags": 956,
    "m_ListEntry": 924,
    "m_MoveCollide": 1052,
    "m_MoveType": 1053,
    "m_NetworkTransmitComponent": 56,
    "m_Particles": 1128,
    "m_aThinkFunctions": 880,
    "m_bAnimTimeChanged": 1321,
    "m_bAnimatedEveryTick": 1085,
    "m_bApplyLayerMatchIDToModel": 851,
    "m_bClientSideRagdoll": 958,
    "m_bHasAddedVarsToInterpolation": 914,
    "m_bHasSuccessfullyInterpolated": 913,
    "m_bInterpolateEvenWithNoModel": 849,
    "m_bPredictable": 1105,
    "m_bPredictionEligible": 850,
    "m_bRenderEvenWhenNotSuccessfullyInterpolated": 915,
    "m_bRenderWithViewModels": 1106,
    "m_bSimulatedEveryTick": 1084,
    "m_bSimulationTimeChanged": 1322,
    "m_bTakesDamage": 817,
    "m_dependencies": 1272,
    "m_fBBoxVisFlags": 1104,
    "m_fEffects": 1060,
    "m_fFlags": 968,
    "m_flAnimTime": 904,
    "m_flCreateTime": 948,
    "m_flElasticity": 1072,
    "m_flFriction": 1068,
    "m_flGravityScale": 1076,
    "m_flNavIgnoreUntilTime": 1088,
    "m_flProxyRandomValue": 840,
    "m_flSimulationTime": 908,
    "m_flSpeed": 952,
    "m_flTimeScale": 1080,
    "m_flWaterLevel": 1056,
    "m_hEffectEntity": 1044,
    "m_hGroundEntity": 1064,
    "m_hOldMoveParent": 1120,
    "m_hOwnerEntity": 1048,
    "m_hSceneObjectController": 828,
    "m_hThink": 1092,
    "m_iCurrentThinkContext": 876,
    "m_iEFlags": 844,
    "m_iHealth": 812,
    "m_iMaxHealth": 808,
    "m_iTeamNum": 959,
    "m_lifeState": 816,
    "m_nCreationTick": 1296,
    "m_nFirstPredictableCommand": 1112,
    "m_nInterpolationLatchDirtyFlags": 916,
    "m_nLastPredictableCommand": 1116,
    "m_nLastThinkTick": 776,
    "m_nNextScriptVarRecordID": 1240,
    "m_nNextThinkTick": 964,
    "m_nNoInterpolationTick": 832,
    "m_nSceneObjectOverrideFlags": 912,
    "m_nSimulationTick": 872,
    "m_nSplitUserPlayerPredictionSlot": 1108,
    "m_nSubclassID": 856,
    "m_nTakeDamageFlags": 820,
    "m_nVisibilityNoInterpolationTick": 836,
    "m_nWaterType": 848,
    "m_pCollision": 800,
    "m_pGameSceneNode": 784,
    "m_pRenderComponent": 792,
    "m_sUniqueHammerID": 1336,
    "m_spawnflags": 960,
    "m_tokLayerMatchID": 852,
    "m_ubInterpolationFrame": 824,
    "m_vecAbsVelocity": 972,
    "m_vecAngVelocity": 1256,
    "m_vecBaseVelocity": 1032,
    "m_vecPredictedScriptFloatIDs": 1192,
    "m_vecPredictedScriptFloats": 1168,
    "m_vecVelocity": 984
  },
  "C_BaseFire": {
    "m_flScale": 1344,
    "m_flScaleTime": 1352,
    "m_flStartScale": 1348,
    "m_nFlags": 1356
  },
  "C_BaseFlex": {
    "m_CachedViewTarget": 3876,
    "m_PhonemeClasses": 4024,
    "m_bResetFlexWeightsOnModelChange": 3918,
    "m_blinktime": 3896,
    "m_blinktoggle": 3776,
    "m_flBlinkAmount": 3912,
    "m_flJawOpenAmount": 3908,
    "m_flexWeight": 3728,
    "m_iBlink": 3892,
    "m_iEyeAttachment": 3917,
    "m_iJawOpen": 3904,
    "m_iMouthAttachment": 3916,
    "m_mEyeOcclusionRendererCameraToBoneTransform": 3948,
    "m_nEyeOcclusionRendererBone": 3944,
    "m_nLastFlexUpdateFrameCount": 3872,
    "m_nNextSceneEventId": 3888,
    "m_prevblinktoggle": 3900,
    "m_vEyeOcclusionRendererHalfExtent": 3996,
    "m_vLookTargetPosition": 3752
  },
  "C_BaseFlex_Emphasized_Phoneme": {
    "m_bBasechecked": 29,
    "m_bRequired": 28,
    "m_bValid": 30,
    "m_flAmount": 24,
    "m_sClassName": 0
  },
  "C_BaseGrenade": {
    "m_DmgRadius": 4124,
    "m_ExplosionSound": 4152,
    "m_bHasWarnedAI": 4120,
    "m_bIsLive": 4122,
    "m_bIsSmokeGrenade": 4121,
    "m_flDamage": 4136,
    "m_flDetonateTime": 4128,
    "m_flNextAttack": 4188,
    "m_flWarnAITime": 4132,
    "m_hOriginalThrower": 4192,
    "m_hThrower": 4164,
    "m_iszBounceSound": 4144
  },
  "C_BaseModelEntity": {
    "m_CHitboxComponent": 2584,
    "m_CRenderComponent": 2576,
    "m_ClientOverrideTint": 3200,
    "m_Collision": 2792,
    "m_ConfigEntitiesToPropagateMaterialDecalsTo": 3120,
    "m_Glow": 2968,
    "m_bAllowFadeInView": 2674,
    "m_bInitModelEffects": 2656,
    "m_bIsStaticProp": 2657,
    "m_bRenderToCubemaps": 2784,
    "m_bUseClientOverrideTint": 3204,
    "m_clrRender": 2675,
    "m_fadeMaxDist": 3064,
    "m_fadeMinDist": 3060,
    "m_flDecalHealBloodRate": 3108,
    "m_flDecalHealHeightRate": 3112,
    "m_flFadeScale": 3068,
    "m_flGlowBackfaceMult": 3056,
    "m_flShadowStrength": 3072,
    "m_iOldHealth": 2668,
    "m_nAddDecal": 3080,
    "m_nDecalsAdded": 2664,
    "m_nLastAddDecal": 2660,
    "m_nObjectCulling": 3076,
    "m_nRenderFX": 2673,
    "m_nRenderMode": 2672,
    "m_pClientAlphaProperty": 3192,
    "m_vDecalForwardAxis": 3096,
    "m_vDecalPosition": 3084,
    "m_vecRenderAttributes": 2680,
    "m_vecViewOffset": 3144
  },
  "C_BasePlayerPawn": {
    "m_ServerViewAngleChanges": 4344,
    "m_bIsSwappingToPredictableController": 4672,
    "m_flDeathTime": 4600,
    "m_flFOVSensitivityAdjust": 4636,
    "m_flLastCameraSetupTime": 4632,
    "m_flMouseSensitivity": 4640,
    "m_flOldSimulationTime": 4656,
    "m_flPredictionErrorTime": 4616,
    "m_hController": 4668,
    "m_iHideHUD": 4452,
    "m_nHighestConsumedServerViewAngleChangeIndex": 4424,
    "m_nLastExecutedCommandNumber": 4660,
    "m_nLastExecutedCommandTick": 4664,
    "m_pAutoaimServices": 4280,
    "m_pCameraServices": 4320,
    "m_pFlashlightServices": 4312,
    "m_pItemServices": 4272,
    "m_pMovementServices": 4328,
    "m_pObserverServices": 4288,
    "m_pUseServices": 4304,
    "m_pWaterServices": 4296,
    "m_pWeaponServices": 4264,
    "m_skybox3d": 4456,
    "m_vOldOrigin": 4644,
    "m_vecLastCameraSetupLocalOrigin": 4620,
    "m_vecPredictionError": 4604,
    "v_angle": 4428,
    "v_anglePrevious": 4440
  },
  "C_BasePlayerWeapon": {
    "m_flNextPrimaryAttackTickRatio": 5476,
    "m_flNextSecondaryAttackTickRatio": 5484,
    "m_iClip1": 5488,
    "m_iClip2": 5492,
    "m_nNextPrimaryAttackTick": 5472,
    "m_nNextSecondaryAttackTick": 5480,
    "m_pReserveAmmo": 5496
  },
  "C_BasePropDoor": {
    "m_bLocked": 4349,
    "m_closedAngles": 4364,
    "m_closedPosition": 4352,
    "m_eDoorState": 4344,
    "m_hMaster": 4376,
    "m_modelChanged": 4348,
    "m_vWhereToSetLightingOrigin": 4380
  },
  "C_BaseTrigger": {
    "m_bClientSidePredicted": 3265,
    "m_bDisabled": 3264
  },
  "C_BaseViewModel": {
    "m_flAnimationStartTime": 3740,
    "m_hControlPanel": 3812,
    "m_hOldLayerSequence": 3800,
    "m_hWeapon": 3744,
    "m_hWeaponModel": 3768,
    "m_iCameraAttachment": 3772,
    "m_nAnimationParity": 3736,
    "m_nOldAnimationParity": 3796,
    "m_nViewModelIndex": 3732,
    "m_oldLayer": 3804,
    "m_oldLayerStartTime": 3808,
    "m_previousCycle": 3792,
    "m_previousElapsedDuration": 3788,
    "m_sAnimationPrefix": 3760,
    "m_sVMName": 3752,
    "m_vecLastCameraAngles": 3776,
    "m_vecLastFacing": 3720
  },
  "C_Beam": {
    "m_bTurnedOff": 3432,
    "m_fAmplitude": 3412,
    "m_fEndWidth": 3400,
    "m_fFadeLength": 3404,
    "m_fHaloScale": 3408,
    "m_fSpeed": 3420,
    "m_fStartFrame": 3416,
    "m_fWidth": 3396,
    "m_flDamage": 3276,
    "m_flFireTime": 3272,
    "m_flFrame": 3424,
    "m_flFrameRate": 3264,
    "m_flHDRColorScale": 3268,
    "m_hAttachEntity": 3344,
    "m_hBaseMaterial": 3320,
    "m_hEndEntity": 3448,
    "m_nAttachIndex": 3384,
    "m_nBeamFlags": 3340,
    "m_nBeamType": 3336,
    "m_nClipStyle": 3428,
    "m_nHaloIndex": 3328,
    "m_nNumBeamEnts": 3280,
    "m_queryHandleHalo": 3284,
    "m_vecEndPos": 3436
  },
  "C_BreakableProp": {
    "m_OnBreak": 3784,
    "m_OnHealthChanged": 3824,
    "m_OnTakeDamage": 3864,
    "m_PerformanceMode": 3920,
    "m_bHasBreakPiecesOrCommands": 3968,
    "m_explodeDamage": 3972,
    "m_explodeRadius": 3976,
    "m_explosionBuildupSound": 3992,
    "m_explosionCustomEffect": 4000,
    "m_explosionCustomSound": 4008,
    "m_explosionDelay": 3984,
    "m_explosionModifier": 4016,
    "m_flDefaultFadeScale": 4032,
    "m_flDmgModBullet": 3924,
    "m_flDmgModClub": 3928,
    "m_flDmgModExplosive": 3932,
    "m_flDmgModFire": 3936,
    "m_flLastPhysicsInfluenceTime": 4028,
    "m_flPressureDelay": 3912,
    "m_flPreventDamageBeforeTime": 3964,
    "m_hBreaker": 3916,
    "m_hFlareEnt": 4040,
    "m_hLastAttacker": 4036,
    "m_hPhysicsAttacker": 4024,
    "m_iInteractions": 3960,
    "m_iMinHealthDmg": 3908,
    "m_impactEnergyScale": 3904,
    "m_iszBasePropData": 3952,
    "m_iszPhysicsDamageTableName": 3944,
    "m_noGhostCollision": 4044
  },
  "C_BulletHitModel": {
    "m_bIsHit": 3768,
    "m_flTimeCreated": 3772,
    "m_hPlayerParent": 3764,
    "m_iBoneIndex": 3760,
    "m_matLocal": 3712,
    "m_vecStartPos": 3776
  },
  "C_C4": {
    "m_activeLightParticleIndex": 6672,
    "m_bBombPlacedAnimation": 6688,
    "m_bBombPlanted": 6731,
    "m_bDroppedFromDeath": 6732,
    "m_bIsPlantingViaUse": 6689,
    "m_bPlayedArmingBeeps": 6724,
    "m_bStartedArming": 6680,
    "m_eActiveLightEffect": 6676,
    "m_entitySpottedState": 6696,
    "m_fArmedTime": 6684,
    "m_nSpotRules": 6720,
    "m_szScreenText": 6640
  },
  "C_CSGOViewModel": {
    "m_bNeedToQueueHighResComposite": 3872,
    "m_bShouldIgnoreOffsetAndAccuracy": 3856,
    "m_nLastKnownAssociatedWeaponEntIndex": 3868,
    "m_nOldWeaponParity": 3864,
    "m_nWeaponParity": 3860,
    "m_vLoweredWeaponOffset": 3940
  },
  "C_CSGO_MapPreviewCameraPath": {
    "m_bConstantSpeed": 1354,
    "m_bLoop": 1352,
    "m_bVerticalFOV": 1353,
    "m_flDuration": 1356,
    "m_flPathDuration": 1428,
    "m_flPathLength": 1424,
    "m_flZFar": 1344,
    "m_flZNear": 1348
  },
  "C_CSGO_MapPreviewCameraPathNode": {
    "m_flEaseIn": 1388,
    "m_flEaseOut": 1392,
    "m_flFOV": 1380,
    "m_flSpeed": 1384,
    "m_nPathIndex": 1352,
    "m_szParentPathUniqueID": 1344,
    "m_vInTangentLocal": 1356,
    "m_vInTangentWorld": 1396,
    "m_vOutTangentLocal": 1368,
    "m_vOutTangentWorld": 1408
  },
  "C_CSGO_PreviewModel": {
    "m_animgraph": 4120,
    "m_animgraphCharacterModeString": 4128,
    "m_defaultAnim": 4136,
    "m_flInitialModelScale": 4148,
    "m_nDefaultAnimLoopMode": 4144
  },
  "C_CSGO_PreviewPlayer": {
    "m_animgraph": 8936,
    "m_animgraphCharacterModeString": 8944,
    "m_flInitialModelScale": 8952
  },
  "C_CSGO_TeamPreviewCamera": {
    "m_bDofEnabled": 1444,
    "m_flDofFarBlurry": 1460,
    "m_flDofFarCrisp": 1456,
    "m_flDofNearBlurry": 1448,
    "m_flDofNearCrisp": 1452,
    "m_flDofTiltToGround": 1464,
    "m_nVariant": 1440
  },
  "C_CSGO_TeamPreviewCharacterPosition": {
    "m_agentItem": 1376,
    "m_glovesItem": 2472,
    "m_nOrdinal": 1352,
    "m_nRandom": 1348,
    "m_nVariant": 1344,
    "m_sWeaponName": 1360,
    "m_weaponItem": 3568,
    "m_xuid": 1368
  },
  "C_CSGameRules": {
    "__m_pChainEntity": 8,
    "m_MatchDevice": 160,
    "m_MinimapVerticalSectionHeights": 3188,
    "m_RetakeRules": 3472,
    "m_TeamRespawnWaveTimes": 2904,
    "m_arrFeaturedGiftersAccounts": 2268,
    "m_arrFeaturedGiftersGifts": 2284,
    "m_arrProhibitedItemIndices": 2300,
    "m_arrTournamentActiveCasterAccounts": 2500,
    "m_bAnyHostageReached": 140,
    "m_bBombDropped": 2524,
    "m_bBombPlanted": 2525,
    "m_bCTCantBuy": 2537,
    "m_bCTTimeOutActive": 71,
    "m_bDontIncrementCoopWave": 3220,
    "m_bFreezePeriod": 48,
    "m_bGamePaused": 69,
    "m_bGameRestart": 108,
    "m_bHasMatchStarted": 164,
    "m_bHasTriggeredCoopSpawnReset": 3437,
    "m_bHasTriggeredRoundStartMusic": 3436,
    "m_bIsDroppingItems": 2232,
    "m_bIsHltvActive": 2234,
    "m_bIsQuestEligible": 2233,
    "m_bIsQueuedMatchmaking": 144,
    "m_bIsValveDS": 152,
    "m_bLogoMap": 153,
    "m_bMapHasBombTarget": 141,
    "m_bMapHasBuyZone": 143,
    "m_bMapHasRescueZone": 142,
    "m_bMarkClientStopRecordAtRoundEnd": 3344,
    "m_bMatchWaitingForResume": 89,
    "m_bPlayAllStepSoundsOnServer": 154,
    "m_bServerPaused": 68,
    "m_bSpawnedTerrorHuntHeavy": 3221,
    "m_bSwitchingTeamsAtRoundReset": 3438,
    "m_bTCantBuy": 2536,
    "m_bTeamIntroPeriod": 3764,
    "m_bTechnicalTimeOut": 88,
    "m_bTerroristTimeOutActive": 70,
    "m_bWarmupPeriod": 49,
    "m_eRoundWinReason": 2532,
    "m_fMatchStartTime": 96,
    "m_fRoundStartTime": 100,
    "m_fWarmupPeriodEnd": 52,
    "m_fWarmupPeriodStart": 56,
    "m_flCMMItemDropRevealEndTime": 2228,
    "m_flCMMItemDropRevealStartTime": 2224,
    "m_flCTTimeOutRemaining": 76,
    "m_flGameStartTime": 112,
    "m_flGuardianBuyUntilTime": 2540,
    "m_flLastPerfSampleTime": 20160,
    "m_flNextRespawnWave": 3032,
    "m_flRestartRoundTime": 104,
    "m_flTerroristTimeOutRemaining": 72,
    "m_gamePhase": 120,
    "m_iHostagesRemaining": 136,
    "m_iMatchStats_PlayersAlive_CT": 2664,
    "m_iMatchStats_PlayersAlive_T": 2784,
    "m_iMatchStats_RoundResults": 2544,
    "m_iNumConsecutiveCTLoses": 3308,
    "m_iNumConsecutiveTerroristLoses": 3312,
    "m_iRoundTime": 92,
    "m_iRoundWinStatus": 2528,
    "m_iSpectatorSlotCount": 156,
    "m_nCTTeamIntroVariant": 3760,
    "m_nCTTimeOuts": 84,
    "m_nEndMatchMapGroupVoteOptions": 3264,
    "m_nEndMatchMapGroupVoteTypes": 3224,
    "m_nEndMatchMapVoteWinner": 3304,
    "m_nGuardianGrenadesToGiveBots": 2248,
    "m_nGuardianModeSpecialKillsRemaining": 2240,
    "m_nGuardianModeSpecialWeaponNeeded": 2244,
    "m_nGuardianModeWaveNumber": 2236,
    "m_nHalloweenMaskListSeed": 2520,
    "m_nMatchAbortedEarlyReason": 3432,
    "m_nMatchEndCount": 3752,
    "m_nNextMapInMapgroup": 168,
    "m_nNumHeaviesToSpawn": 2252,
    "m_nOvertimePlaying": 132,
    "m_nPauseStartTick": 64,
    "m_nQueuedMatchmakingMode": 148,
    "m_nRoundsPlayedThisPhase": 128,
    "m_nServerQuestID": 3160,
    "m_nTTeamIntroVariant": 3756,
    "m_nTerroristTimeOuts": 80,
    "m_nTotalPausedTicks": 60,
    "m_nTournamentPredictionsPct": 2220,
    "m_numBestOfMaps": 2516,
    "m_numGlobalGifters": 2260,
    "m_numGlobalGiftsGiven": 2256,
    "m_numGlobalGiftsPeriodSeconds": 2264,
    "m_pGameModeRules": 3464,
    "m_szMatchStatTxt": 1196,
    "m_szTournamentEventName": 172,
    "m_szTournamentEventStage": 684,
    "m_szTournamentPredictionsTxt": 1708,
    "m_timeUntilNextPhaseStarts": 116,
    "m_totalRoundsPlayed": 124,
    "m_vMinimapMaxs": 3176,
    "m_vMinimapMins": 3164
  },
  "C_CSGameRulesProxy": {
    "m_pGameRules": 1344
  },
  "C_CSObserverPawn": {
    "m_hDetectParentChange": 5808
  },
  "C_CSPlayerPawn": {
    "m_EconGloves": 6328,
    "m_RetakesMVPBoostExtraUtility": 6288,
    "m_aimPunchAngle": 5908,
    "m_aimPunchAngleVel": 5920,
    "m_aimPunchCache": 5944,
    "m_aimPunchTickBase": 5932,
    "m_aimPunchTickFraction": 5936,
    "m_bHasFemaleVoice": 5856,
    "m_bInBombZone": 5985,
    "m_bInBuyZone": 5904,
    "m_bInHostageRescueZone": 5984,
    "m_bInLanding": 5976,
    "m_bIsBuyMenuOpen": 5986,
    "m_bLastHeadBoneTransformIsValid": 8880,
    "m_bMustSyncRagdollState": 7424,
    "m_bNeedToReApplyGloves": 6320,
    "m_bOnGroundLastTick": 8888,
    "m_bPrevDefuser": 5886,
    "m_bPrevHelmet": 5887,
    "m_bPreviouslyInBuyZone": 5905,
    "m_bRagdollDamageHeadshot": 7520,
    "m_bRetakesHasDefuseKit": 6280,
    "m_bRetakesMVPLastRound": 6281,
    "m_bSkipOneHeadConstraintUpdate": 8928,
    "m_flHealthShotBoostExpirationTime": 5848,
    "m_flLandingTime": 5980,
    "m_flLandseconds": 5860,
    "m_flLastFiredWeaponTime": 5852,
    "m_flNextSprayDecalTime": 5992,
    "m_flOldFallVelocity": 5864,
    "m_flTimeOfLastInjury": 5988,
    "m_iRetakesMVPBoostItem": 6284,
    "m_iRetakesOffering": 6272,
    "m_iRetakesOfferingCard": 6276,
    "m_lastLandTime": 8884,
    "m_nPrevArmorVal": 5888,
    "m_nPrevGrenadeAmmoCount": 5892,
    "m_nRagdollDamageBone": 7428,
    "m_pActionTrackingServices": 5840,
    "m_pBulletServices": 5808,
    "m_pBuyServices": 5824,
    "m_pGlowServices": 5832,
    "m_pHostageServices": 5816,
    "m_qDeathEyeAngles": 8916,
    "m_szLastPlaceName": 5868,
    "m_szRagdollDamageWeaponName": 7456,
    "m_unPreviousWeaponHash": 5896,
    "m_unWeaponHash": 5900,
    "m_vRagdollDamageForce": 7432,
    "m_vRagdollDamagePosition": 7444,
    "m_vRagdollServerOrigin": 7524
  },
  "C_CSPlayerPawnBase": {
    "m_ArmorValue": 5384,
    "m_angEyeAngles": 5392,
    "m_angLastMuzzleFlashAngle": 5252,
    "m_angShootAngleHistory": 4868,
    "m_angStashedShootAngles": 4832,
    "m_bCachedPlaneIsValid": 4773,
    "m_bCanMoveDuringFreezePeriod": 5100,
    "m_bClipHitStaticWorld": 4772,
    "m_bDeferStartMusicOnWarmup": 5508,
    "m_bFlashBuildUp": 5216,
    "m_bFlashDspHasBeenCleared": 5217,
    "m_bFlashScreenshotHasBeenGrabbed": 5218,
    "m_bGrenadeParametersStashed": 4828,
    "m_bGuardianShouldSprayCustomXMark": 5708,
    "m_bGunGameImmunity": 5052,
    "m_bHasDeathInfo": 5709,
    "m_bHasMovedSinceSpawn": 5053,
    "m_bHasNightVision": 5149,
    "m_bHideTargetID": 5548,
    "m_bHud_MiniScoreHidden": 5422,
    "m_bHud_RadarHidden": 5423,
    "m_bInNoDefuseArea": 5068,
    "m_bIsDefusing": 5032,
    "m_bIsGrabbingHostage": 5033,
    "m_bIsRescuing": 5040,
    "m_bIsScoped": 5024,
    "m_bIsWalking": 5025,
    "m_bKilledByHeadshot": 5728,
    "m_bKilledByTaser": 5093,
    "m_bNightVisionOn": 5148,
    "m_bOldIsScoped": 5348,
    "m_bResumeZoom": 5026,
    "m_bScreenTearFrameCaptured": 5200,
    "m_bShouldAutobuyDMWeapons": 5420,
    "m_bShouldAutobuyNow": 5421,
    "m_bStrafing": 5108,
    "m_bSuppressGuardianTooFarWarningAudio": 5092,
    "m_bWaitForNoAttack": 5076,
    "m_cycleLatch": 5512,
    "m_delayTargetIDTimer": 5440,
    "m_entitySpottedState": 5680,
    "m_fImmuneToGunGameDamageTime": 5044,
    "m_fImmuneToGunGameDamageTimeLast": 5048,
    "m_fMolotovDamageTime": 5060,
    "m_fMolotovUseTime": 5056,
    "m_fNextThinkPushAway": 5416,
    "m_fRenderingClipPlane": 4728,
    "m_firstTaserShakeTime": 5556,
    "m_flClientDeathTime": 5192,
    "m_flCurrentMusicStartTime": 5500,
    "m_flDeathCCWeight": 5344,
    "m_flDeathInfoTime": 5712,
    "m_flDetectedByEnemySensorTime": 5084,
    "m_flEmitSoundTime": 5116,
    "m_flFlashBangTime": 5204,
    "m_flFlashDuration": 5224,
    "m_flFlashMaxAlpha": 5220,
    "m_flFlashOverlayAlpha": 5212,
    "m_flFlashScreenshotAlpha": 5208,
    "m_flGuardianTooFarDistFrac": 5080,
    "m_flHealthFadeAlpha": 5276,
    "m_flHealthFadeValue": 5272,
    "m_flHitHeading": 5156,
    "m_flLastCollisionCeiling": 4788,
    "m_flLastCollisionCeilingChangeTime": 4792,
    "m_flLastSmokeOverlayAlpha": 5560,
    "m_flLastSpawnTimeIndex": 5112,
    "m_flLowerBodyYawTarget": 5104,
    "m_flMusicRoundStartTime": 5504,
    "m_flNextGuardianTooFarWarning": 5088,
    "m_flNextMagDropTime": 5580,
    "m_flNightVisionAlpha": 5196,
    "m_flPrevMatchEndTime": 5356,
    "m_flPrevRoundEndTime": 5352,
    "m_flProgressBarStartTime": 5136,
    "m_flSlopeDropHeight": 4984,
    "m_flSlopeDropOffset": 4968,
    "m_flVelocityModifier": 5152,
    "m_grenadeParameterStashTime": 4824,
    "m_hMuzzleFlashShape": 5264,
    "m_hOriginalController": 5732,
    "m_holdTargetIDTimer": 5472,
    "m_iAddonBits": 5120,
    "m_iBlockingUseActionInProgress": 5036,
    "m_iDirection": 5140,
    "m_iHealthBarRenderMaskIndex": 5268,
    "m_iIDEntIndex": 5436,
    "m_iMoveState": 5096,
    "m_iOldIDEntIndex": 5468,
    "m_iPlayerState": 5028,
    "m_iPrimaryAddon": 5124,
    "m_iProgressBarDuration": 5132,
    "m_iSecondaryAddon": 5128,
    "m_iShotsFired": 5144,
    "m_iStartAccount": 5164,
    "m_iTargetedWeaponEntIndex": 5464,
    "m_iThrowGrenadeCounter": 5072,
    "m_ignoreLadderJumpTime": 5284,
    "m_ladderSurpressionTimer": 5288,
    "m_lastLadderNormal": 5312,
    "m_lastLadderPos": 5324,
    "m_lastStandingPos": 5228,
    "m_nDeathCamMusic": 5432,
    "m_nHeavyAssaultSuitCooldownRemaining": 5380,
    "m_nHitBodyPart": 5160,
    "m_nLastClipPlaneSetupFrame": 4744,
    "m_nLastConcurrentKilled": 5428,
    "m_nLastKillerIndex": 5424,
    "m_nLastMagDropAttachmentIndex": 5584,
    "m_nMyCollisionGroup": 5280,
    "m_nPlayerSmokedFx": 5576,
    "m_nSurvivalTeamNumber": 5704,
    "m_nWhichBombZone": 5064,
    "m_nextTaserShakeTime": 5552,
    "m_pClippingWeapon": 4776,
    "m_pPingServices": 4712,
    "m_pViewModelServices": 4720,
    "m_previousPlayerState": 4784,
    "m_serverIntendedCycle": 5516,
    "m_thirdPersonHeading": 4944,
    "m_unCurrentEquipmentValue": 5360,
    "m_unFreezetimeEndEquipmentValue": 5364,
    "m_unRoundStartEquipmentValue": 5362,
    "m_vHeadConstraintOffset": 5000,
    "m_vLastSmokeOverlayColor": 5564,
    "m_vecBulletHitModels": 5592,
    "m_vecDeathInfoOrigin": 5716,
    "m_vecIntroStartEyePosition": 5168,
    "m_vecIntroStartPlayerForward": 5180,
    "m_vecLastAliveLocalVelocity": 5640,
    "m_vecLastClipCameraForward": 4760,
    "m_vecLastClipCameraPos": 4748,
    "m_vecLastMuzzleFlashPos": 5240,
    "m_vecPickupModelSlerpers": 5616,
    "m_vecPlayerPatchEconIndices": 5520,
    "m_vecStashedGrenadeThrowPosition": 4844,
    "m_vecStashedVelocity": 4856,
    "m_vecThirdPersonViewPositionOverride": 5368,
    "m_vecThrowPositionHistory": 4892,
    "m_vecVelocityHistory": 4916
  },
  "C_CSPlayerResource": {
    "m_bEndMatchNextMapAllVoted": 1488,
    "m_bHostageAlive": 1344,
    "m_bombsiteCenterA": 1416,
    "m_bombsiteCenterB": 1428,
    "m_foundGoalPositions": 1489,
    "m_hostageRescueX": 1440,
    "m_hostageRescueY": 1456,
    "m_hostageRescueZ": 1472,
    "m_iHostageEntityIDs": 1368,
    "m_isHostageFollowingSomeone": 1356
  },
  "C_CSTeam": {
    "m_bSurrendered": 2044,
    "m_iClanID": 2192,
    "m_numMapVictories": 2040,
    "m_scoreFirstHalf": 2048,
    "m_scoreOvertime": 2056,
    "m_scoreSecondHalf": 2052,
    "m_szClanTeamname": 2060,
    "m_szTeamFlagImage": 2196,
    "m_szTeamLogoImage": 2204,
    "m_szTeamMatchStat": 1528
  },
  "C_CSWeaponBase": {
    "m_ClientPreviousWeaponState": 5696,
    "m_IronSightController": 6320,
    "m_OnPlayerPickup": 5744,
    "m_bBurstMode": 5832,
    "m_bFireOnEmpty": 5740,
    "m_bGlowForPing": 6016,
    "m_bInReload": 5840,
    "m_bIsHauledBack": 5848,
    "m_bOldFirstPersonSpectatedState": 5993,
    "m_bPlayerFireEventIsPrimary": 5600,
    "m_bReloadVisuallyComplete": 5841,
    "m_bReloadsWithClips": 5732,
    "m_bSilencerOn": 5849,
    "m_bUIWeapon": 6017,
    "m_bVisualsDataSet": 5992,
    "m_bWasOwnedByCT": 6076,
    "m_bWasOwnedByTerrorist": 6077,
    "m_donated": 6068,
    "m_fAccuracyPenalty": 5808,
    "m_fAccuracySmoothedForZoom": 5816,
    "m_fLastShotTime": 6072,
    "m_fScopeZoomEndTime": 5820,
    "m_flCrosshairDistance": 5704,
    "m_flDroppedAtTime": 5844,
    "m_flFireSequenceStartTime": 5588,
    "m_flGunAccuracyPosition": 5724,
    "m_flLastAccuracyUpdateTime": 5812,
    "m_flLastLOSTraceFailureTime": 6512,
    "m_flNextAttackRenderTimeOffset": 5860,
    "m_flNextClientFireBulletTime": 6092,
    "m_flNextClientFireBulletTime_Repredict": 6096,
    "m_flPostponeFireReadyTime": 5836,
    "m_flRecoilIndex": 5828,
    "m_flTimeSilencerSwitchComplete": 5852,
    "m_flTimeWeaponIdle": 5736,
    "m_flTurningInaccuracy": 5804,
    "m_flTurningInaccuracyDelta": 5788,
    "m_gunHeat": 6080,
    "m_hCurrentThirdPersonSequence": 5640,
    "m_hOurPing": 5996,
    "m_hPrevOwner": 6032,
    "m_iAlpha": 5712,
    "m_iAmmoLastCheck": 5708,
    "m_iCrosshairTextureID": 5720,
    "m_iIronSightMode": 6496,
    "m_iNumEmptyAttacks": 6516,
    "m_iOriginalTeamNumber": 5856,
    "m_iRecoilIndex": 5824,
    "m_iScopeTextureID": 5716,
    "m_iState": 5700,
    "m_lastSmokeTime": 6088,
    "m_nDropTick": 6036,
    "m_nFireSequenceStartTimeAck": 5596,
    "m_nFireSequenceStartTimeChange": 5592,
    "m_nOurPingIndex": 6000,
    "m_nSilencerBoneIndex": 5644,
    "m_nViewModelIndex": 5728,
    "m_seqFirePrimary": 5608,
    "m_seqFireSecondary": 5612,
    "m_seqIdle": 5604,
    "m_smokeAttachments": 6084,
    "m_thirdPersonFireSequences": 5616,
    "m_thirdPersonSequences": 5648,
    "m_vecOurPingPos": 6004,
    "m_vecTurningInaccuracyEyeDirLast": 5792,
    "m_weaponMode": 5784
  },
  "C_CSWeaponBaseGun": {
    "m_bNeedsBoltAction": 6669,
    "m_iBurstShotsRemaining": 6644,
    "m_iSilencerBodygroup": 6648,
    "m_inPrecache": 6668,
    "m_silencedModelIndex": 6664,
    "m_zoomLevel": 6640
  },
  "C_Chicken": {
    "m_AttributeManager": 4352,
    "m_OriginalOwnerXuidHigh": 5548,
    "m_OriginalOwnerXuidLow": 5544,
    "m_bAttributesInitialized": 5552,
    "m_hHolidayHatAddon": 4336,
    "m_hWaterWakeParticles": 5556,
    "m_jumpedThisFrame": 4340,
    "m_leader": 4344
  },
  "C_ClientRagdoll": {
    "m_bFadeOut": 3712,
    "m_bFadingOut": 3742,
    "m_bImportant": 3713,
    "m_bReleaseRagdoll": 3740,
    "m_flEffectTime": 3716,
    "m_flScaleEnd": 3744,
    "m_flScaleTimeEnd": 3824,
    "m_flScaleTimeStart": 3784,
    "m_gibDespawnTime": 3720,
    "m_iCurrentFriction": 3724,
    "m_iEyeAttachment": 3741,
    "m_iFrictionAnimState": 3736,
    "m_iMaxFriction": 3732,
    "m_iMinFriction": 3728
  },
  "C_ColorCorrection": {
    "m_MaxFalloff": 1360,
    "m_MinFalloff": 1356,
    "m_bClientSide": 1894,
    "m_bEnabled": 1892,
    "m_bEnabledOnClient": 1896,
    "m_bExclusive": 1895,
    "m_bFadingIn": 1904,
    "m_bMaster": 1893,
    "m_flCurWeight": 1376,
    "m_flCurWeightOnClient": 1900,
    "m_flFadeDuration": 1916,
    "m_flFadeInDuration": 1364,
    "m_flFadeOutDuration": 1368,
    "m_flFadeStartTime": 1912,
    "m_flFadeStartWeight": 1908,
    "m_flMaxWeight": 1372,
    "m_netlookupFilename": 1380,
    "m_vecOrigin": 1344
  },
  "C_ColorCorrectionVolume": {
    "m_FadeDuration": 3296,
    "m_LastEnterTime": 3276,
    "m_LastEnterWeight": 3272,
    "m_LastExitTime": 3284,
    "m_LastExitWeight": 3280,
    "m_MaxWeight": 3292,
    "m_Weight": 3300,
    "m_bEnabled": 3288,
    "m_lookupFilename": 3304
  },
  "C_CommandContext": {
    "command_number": 168,
    "needsprocessing": 0
  },
  "C_CsmFovOverride": {
    "m_cameraName": 1344,
    "m_flCsmFovOverrideValue": 1352
  },
  "C_DecoyProjectile": {
    "m_flTimeParticleEffectSpawn": 4392,
    "m_nClientLastKnownDecoyShotTick": 4356,
    "m_nDecoyShotTick": 4352
  },
  "C_DynamicLight": {
    "m_Exponent": 3272,
    "m_Flags": 3264,
    "m_InnerAngle": 3276,
    "m_LightStyle": 3265,
    "m_OuterAngle": 3280,
    "m_Radius": 3268,
    "m_SpotRadius": 3284
  },
  "C_DynamicProp": {
    "m_OnAnimReachedEnd": 4216,
    "m_OnAnimReachedStart": 4176,
    "m_bAnimateOnServer": 4268,
    "m_bCreateNonSolid": 4274,
    "m_bFiredStartEndOutput": 4272,
    "m_bForceNpcExclude": 4273,
    "m_bIsOverrideProp": 4275,
    "m_bRandomizeCycle": 4269,
    "m_bScriptedMovement": 4271,
    "m_bStartDisabled": 4270,
    "m_bUseAnimGraph": 4049,
    "m_bUseHitboxesForRenderBox": 4048,
    "m_glowColor": 4288,
    "m_iCachedFrameCount": 4296,
    "m_iInitialGlowState": 4276,
    "m_iszDefaultAnim": 4256,
    "m_nDefaultAnimLoopMode": 4264,
    "m_nGlowRange": 4280,
    "m_nGlowRangeMin": 4284,
    "m_nGlowTeam": 4292,
    "m_pOutputAnimBegun": 4056,
    "m_pOutputAnimLoopCycleOver": 4136,
    "m_pOutputAnimOver": 4096,
    "m_vecCachedRenderMaxs": 4312,
    "m_vecCachedRenderMins": 4300
  },
  "C_EconEntity": {
    "m_AttributeManager": 4160,
    "m_OriginalOwnerXuidHigh": 5356,
    "m_OriginalOwnerXuidLow": 5352,
    "m_bAttachmentDirty": 5416,
    "m_bAttributesInitialized": 4152,
    "m_bClientside": 5376,
    "m_bParticleSystemsCreated": 5377,
    "m_flFallbackWear": 5368,
    "m_flFlexDelayTime": 4136,
    "m_flFlexDelayedWeight": 4144,
    "m_hOldProvidee": 5440,
    "m_hViewmodelAttachment": 5408,
    "m_iNumOwnerValidationRetries": 5424,
    "m_iOldTeam": 5412,
    "m_nFallbackPaintKit": 5360,
    "m_nFallbackSeed": 5364,
    "m_nFallbackStatTrak": 5372,
    "m_nUnloadedModelIndex": 5420,
    "m_vecAttachedModels": 5448,
    "m_vecAttachedParticles": 5384
  },
  "C_EconEntity_AttachedModelData_t": {
    "m_iModelDisplayFlags": 0
  },
  "C_EconItemView": {
    "m_AttributeList": 528,
    "m_NetworkedDynamicAttributes": 624,
    "m_bInitialized": 488,
    "m_bInitializedTags": 1088,
    "m_bInventoryImageRgbaRequested": 96,
    "m_bInventoryImageTriedCache": 97,
    "m_bIsStoreItem": 489,
    "m_bIsTradeItem": 490,
    "m_bRestoreCustomMaterialAfterPrecache": 440,
    "m_iAccountID": 472,
    "m_iEntityLevel": 448,
    "m_iEntityQuality": 444,
    "m_iEntityQuantity": 492,
    "m_iInventoryPosition": 476,
    "m_iItemDefinitionIndex": 442,
    "m_iItemID": 456,
    "m_iItemIDHigh": 464,
    "m_iItemIDLow": 468,
    "m_iQualityOverride": 500,
    "m_iRarityOverride": 496,
    "m_nInventoryImageRgbaHeight": 132,
    "m_nInventoryImageRgbaWidth": 128,
    "m_szCurrentLoadCachedFileName": 136,
    "m_szCustomName": 720,
    "m_szCustomNameOverride": 881,
    "m_unClientFlags": 504,
    "m_unOverrideStyle": 505
  },
  "C_EconWearable": {
    "m_bAlwaysAllow": 5476,
    "m_nForceSkin": 5472
  },
  "C_EntityDissolve": {
    "m_bCoreExplode": 3324,
    "m_bLinkedToServerEnt": 3325,
    "m_flFadeInLength": 3280,
    "m_flFadeInStart": 3276,
    "m_flFadeOutLength": 3296,
    "m_flFadeOutModelLength": 3288,
    "m_flFadeOutModelStart": 3284,
    "m_flFadeOutStart": 3292,
    "m_flNextSparkTime": 3300,
    "m_flStartTime": 3272,
    "m_nDissolveType": 3304,
    "m_nMagnitude": 3320,
    "m_vDissolverOrigin": 3308
  },
  "C_EntityFlame": {
    "m_bCheapEffect": 1388,
    "m_hEntAttached": 1344,
    "m_hOldAttached": 1384
  },
  "C_EnvCombinedLightProbeVolume": {
    "m_Color": 5528,
    "m_bCustomCubemapTexture": 5544,
    "m_bEnabled": 5689,
    "m_bMoveable": 5608,
    "m_bStartDisabled": 5624,
    "m_flBrightness": 5532,
    "m_flEdgeFadeDist": 5628,
    "m_hCubemapTexture": 5536,
    "m_hLightProbeDirectLightIndicesTexture": 5560,
    "m_hLightProbeDirectLightScalarsTexture": 5568,
    "m_hLightProbeDirectLightShadowsTexture": 5576,
    "m_hLightProbeTexture": 5552,
    "m_nEnvCubeMapArrayIndex": 5616,
    "m_nHandshake": 5612,
    "m_nLightProbeAtlasX": 5656,
    "m_nLightProbeAtlasY": 5660,
    "m_nLightProbeAtlasZ": 5664,
    "m_nLightProbeSizeX": 5644,
    "m_nLightProbeSizeY": 5648,
    "m_nLightProbeSizeZ": 5652,
    "m_nPriority": 5620,
    "m_vBoxMaxs": 5596,
    "m_vBoxMins": 5584,
    "m_vEdgeFadeDists": 5632
  },
  "C_EnvCubemap": {
    "m_bCopyDiffuseFromDefaultCubemap": 1552,
    "m_bCustomCubemapTexture": 1480,
    "m_bDefaultEnvMap": 1549,
    "m_bDefaultSpecEnvMap": 1550,
    "m_bEnabled": 1568,
    "m_bIndoorCubeMap": 1551,
    "m_bMoveable": 1512,
    "m_bStartDisabled": 1548,
    "m_flDiffuseScale": 1544,
    "m_flEdgeFadeDist": 1528,
    "m_flInfluenceRadius": 1484,
    "m_hCubemapTexture": 1472,
    "m_nEnvCubeMapArrayIndex": 1520,
    "m_nHandshake": 1516,
    "m_nPriority": 1524,
    "m_vBoxProjectMaxs": 1500,
    "m_vBoxProjectMins": 1488,
    "m_vEdgeFadeDists": 1532
  },
  "C_EnvCubemapFog": {
    "m_bActive": 1380,
    "m_bFirstTime": 1417,
    "m_bHasHeightFogEnd": 1416,
    "m_bHeightFogEnabled": 1356,
    "m_bStartDisabled": 1381,
    "m_flEndDistance": 1344,
    "m_flFogFalloffExponent": 1352,
    "m_flFogHeightEnd": 1364,
    "m_flFogHeightExponent": 1372,
    "m_flFogHeightStart": 1368,
    "m_flFogHeightWidth": 1360,
    "m_flFogMaxOpacity": 1384,
    "m_flLODBias": 1376,
    "m_flStartDistance": 1348,
    "m_hFogCubemapTexture": 1408,
    "m_hSkyMaterial": 1392,
    "m_iszSkyEntity": 1400,
    "m_nCubemapSourceType": 1388
  },
  "C_EnvDecal": {
    "m_bProjectOnCharacters": 3289,
    "m_bProjectOnWater": 3290,
    "m_bProjectOnWorld": 3288,
    "m_flDepth": 3280,
    "m_flDepthSortBias": 3292,
    "m_flHeight": 3276,
    "m_flWidth": 3272,
    "m_hDecalMaterial": 3264,
    "m_nRenderOrder": 3284
  },
  "C_EnvDetailController": {
    "m_flFadeEndDist": 1348,
    "m_flFadeStartDist": 1344
  },
  "C_EnvLightProbeVolume": {
    "m_bEnabled": 5505,
    "m_bMoveable": 5456,
    "m_bStartDisabled": 5468,
    "m_hLightProbeDirectLightIndicesTexture": 5408,
    "m_hLightProbeDirectLightScalarsTexture": 5416,
    "m_hLightProbeDirectLightShadowsTexture": 5424,
    "m_hLightProbeTexture": 5400,
    "m_nHandshake": 5460,
    "m_nLightProbeAtlasX": 5484,
    "m_nLightProbeAtlasY": 5488,
    "m_nLightProbeAtlasZ": 5492,
    "m_nLightProbeSizeX": 5472,
    "m_nLightProbeSizeY": 5476,
    "m_nLightProbeSizeZ": 5480,
    "m_nPriority": 5464,
    "m_vBoxMaxs": 5444,
    "m_vBoxMins": 5432
  },
  "C_EnvParticleGlow": {
    "m_ColorTint": 4732,
    "m_flAlphaScale": 4720,
    "m_flRadiusScale": 4724,
    "m_flSelfIllumScale": 4728,
    "m_hTextureOverride": 4736
  },
  "C_EnvScreenOverlay": {
    "m_bIsActive": 1472,
    "m_bWasActive": 1473,
    "m_flCurrentOverlayTime": 1484,
    "m_flOverlayTimes": 1424,
    "m_flStartTime": 1464,
    "m_iCachedDesiredOverlay": 1476,
    "m_iCurrentOverlay": 1480,
    "m_iDesiredOverlay": 1468,
    "m_iszOverlayNames": 1344
  },
  "C_EnvSky": {
    "m_bEnabled": 3316,
    "m_bStartDisabled": 3280,
    "m_flBrightnessScale": 3292,
    "m_flFogMaxEnd": 3312,
    "m_flFogMaxStart": 3308,
    "m_flFogMinEnd": 3304,
    "m_flFogMinStart": 3300,
    "m_hSkyMaterial": 3264,
    "m_hSkyMaterialLightingOnly": 3272,
    "m_nFogType": 3296,
    "m_vTintColor": 3281,
    "m_vTintColorLightingOnly": 3285
  },
  "C_EnvVolumetricFogController": {
    "m_bActive": 1408,
    "m_bEnableIndirect": 1449,
    "m_bFirstTime": 1468,
    "m_bIsMaster": 1450,
    "m_bStartDisabled": 1448,
    "m_flAnisotropy": 1348,
    "m_flDefaultAnisotropy": 1436,
    "m_flDefaultDrawDistance": 1444,
    "m_flDefaultScattering": 1440,
    "m_flDrawDistance": 1356,
    "m_flFadeInEnd": 1364,
    "m_flFadeInStart": 1360,
    "m_flFadeSpeed": 1352,
    "m_flIndirectStrength": 1368,
    "m_flScattering": 1344,
    "m_flStartAnisoTime": 1412,
    "m_flStartAnisotropy": 1424,
    "m_flStartDrawDistance": 1432,
    "m_flStartDrawDistanceTime": 1420,
    "m_flStartScatterTime": 1416,
    "m_flStartScattering": 1428,
    "m_hFogIndirectTexture": 1456,
    "m_nForceRefreshCount": 1464,
    "m_nIndirectTextureDimX": 1372,
    "m_nIndirectTextureDimY": 1376,
    "m_nIndirectTextureDimZ": 1380,
    "m_vBoxMaxs": 1396,
    "m_vBoxMins": 1384
  },
  "C_EnvVolumetricFogVolume": {
    "m_bActive": 1344,
    "m_bStartDisabled": 1372,
    "m_flFalloffExponent": 1384,
    "m_flStrength": 1376,
    "m_nFalloffShape": 1380,
    "m_vBoxMaxs": 1360,
    "m_vBoxMins": 1348
  },
  "C_EnvWind": {
    "m_EnvWindShared": 1344
  },
  "C_EnvWindClientside": {
    "m_EnvWindShared": 1344
  },
  "C_EnvWindShared": {
    "m_CurrentSwayVector": 80,
    "m_PrevSwayVector": 92,
    "m_bGusting": 132,
    "m_currentWindVector": 68,
    "m_flAveWindSpeed": 128,
    "m_flGustDuration": 36,
    "m_flInitialWindSpeed": 108,
    "m_flMaxGustDelay": 32,
    "m_flMinGustDelay": 28,
    "m_flSimTime": 120,
    "m_flStartTime": 8,
    "m_flSwayTime": 116,
    "m_flSwitchTime": 124,
    "m_flVariationTime": 112,
    "m_flWindAngleVariation": 136,
    "m_flWindSpeed": 64,
    "m_flWindSpeedVariation": 140,
    "m_iEntIndex": 144,
    "m_iGustDirChange": 40,
    "m_iInitialWindDir": 104,
    "m_iMaxGust": 26,
    "m_iMaxWind": 18,
    "m_iMinGust": 24,
    "m_iMinWind": 16,
    "m_iWindDir": 60,
    "m_iWindSeed": 12,
    "m_iszGustSound": 56,
    "m_location": 44,
    "m_windRadius": 20
  },
  "C_EnvWindShared_WindAveEvent_t": {
    "m_flAveWindSpeed": 4,
    "m_flStartWindSpeed": 0
  },
  "C_EnvWindShared_WindVariationEvent_t": {
    "m_flWindAngleVariation": 0,
    "m_flWindSpeedVariation": 4
  },
  "C_FireSmoke": {
    "m_bClipTested": 1412,
    "m_bFadingOut": 1413,
    "m_flChildFlameSpread": 1388,
    "m_flClipPerc": 1408,
    "m_flScaleEnd": 1376,
    "m_flScaleRegister": 1368,
    "m_flScaleStart": 1372,
    "m_flScaleTimeEnd": 1384,
    "m_flScaleTimeStart": 1380,
    "m_nFlameFromAboveModelIndex": 1364,
    "m_nFlameModelIndex": 1360,
    "m_pFireOverlay": 1424,
    "m_tParticleSpawn": 1416
  },
  "C_FireSprite": {
    "m_bFadeFromAbove": 3580,
    "m_vecMoveDir": 3568
  },
  "C_Fish": {
    "m_actualAngles": 3812,
    "m_actualPos": 3800,
    "m_angle": 3856,
    "m_angles": 3736,
    "m_averageError": 3948,
    "m_buoyancy": 3760,
    "m_deathAngle": 3756,
    "m_deathDepth": 3752,
    "m_errorHistory": 3860,
    "m_errorHistoryCount": 3944,
    "m_errorHistoryIndex": 3940,
    "m_gotUpdate": 3840,
    "m_localLifeState": 3748,
    "m_poolOrigin": 3824,
    "m_pos": 3712,
    "m_vel": 3724,
    "m_waterLevel": 3836,
    "m_wigglePhase": 3792,
    "m_wiggleRate": 3796,
    "m_wiggleTimer": 3768,
    "m_x": 3844,
    "m_y": 3848,
    "m_z": 3852
  },
  "C_Fists": {
    "m_bPlayingUninterruptableAct": 6640,
    "m_nUninterruptableActivity": 6644
  },
  "C_FogController": {
    "m_bUseAngles": 1448,
    "m_fog": 1344,
    "m_iChangedVariables": 1452
  },
  "C_FootstepControl": {
    "m_destination": 3280,
    "m_source": 3272
  },
  "C_FuncConveyor": {
    "m_flCurrentConveyorOffset": 3328,
    "m_flCurrentConveyorSpeed": 3332,
    "m_flTargetSpeed": 3284,
    "m_flTransitionStartSpeed": 3296,
    "m_hConveyorModels": 3304,
    "m_nTransitionDurationTicks": 3292,
    "m_nTransitionStartTick": 3288,
    "m_vecMoveDirEntitySpace": 3272
  },
  "C_FuncElectrifiedVolume": {
    "m_EffectName": 3272,
    "m_bState": 3280,
    "m_nAmbientEffect": 3264
  },
  "C_FuncLadder": {
    "m_Dismounts": 3280,
    "m_bDisabled": 3344,
    "m_bFakeLadder": 3345,
    "m_bHasSlack": 3346,
    "m_flAutoRideSpeed": 3340,
    "m_vecLadderDir": 3264,
    "m_vecLocalTop": 3304,
    "m_vecPlayerMountPositionBottom": 3328,
    "m_vecPlayerMountPositionTop": 3316
  },
  "C_FuncMonitor": {
    "m_bDraw3DSkybox": 3293,
    "m_bEnabled": 3292,
    "m_bRenderShadows": 3276,
    "m_bUseUniqueColorTarget": 3277,
    "m_brushModelName": 3280,
    "m_hTargetCamera": 3288,
    "m_nResolutionEnum": 3272,
    "m_targetCamera": 3264
  },
  "C_FuncTrackTrain": {
    "m_flLineLength": 3272,
    "m_flRadius": 3268,
    "m_nLongAxis": 3264
  },
  "C_GlobalLight": {
    "m_WindClothForceHandle": 2560
  },
  "C_GradientFog": {
    "m_bGradientFogNeedsTextures": 1402,
    "m_bHeightFogEnabled": 1360,
    "m_bIsEnabled": 1401,
    "m_bStartDisabled": 1400,
    "m_flFadeTime": 1396,
    "m_flFarZ": 1372,
    "m_flFogEndDistance": 1356,
    "m_flFogEndHeight": 1368,
    "m_flFogFalloffExponent": 1380,
    "m_flFogMaxOpacity": 1376,
    "m_flFogStartDistance": 1352,
    "m_flFogStartHeight": 1364,
    "m_flFogStrength": 1392,
    "m_flFogVerticalExponent": 1384,
    "m_fogColor": 1388,
    "m_hGradientFogTexture": 1344
  },
  "C_HandleTest": {
    "m_Handle": 1344,
    "m_bSendHandle": 1348
  },
  "C_Hostage": {
    "m_bHandsHaveBeenCut": 4340,
    "m_blinkTimer": 4384,
    "m_chestAttachment": 4450,
    "m_entitySpottedState": 4264,
    "m_eyeAttachment": 4449,
    "m_fLastGrabTime": 4348,
    "m_fNewestAlphaThinkTime": 4464,
    "m_flDeadOrRescuedTime": 4376,
    "m_flDropStartTime": 4372,
    "m_flGrabSuccessTime": 4368,
    "m_flRescueStartTime": 4364,
    "m_hHostageGrabber": 4344,
    "m_isInit": 4448,
    "m_isRescued": 4332,
    "m_jumpedThisFrame": 4333,
    "m_leader": 4288,
    "m_lookAroundTimer": 4424,
    "m_lookAt": 4408,
    "m_nHostageState": 4336,
    "m_pPredictionOwner": 4456,
    "m_reuseTimer": 4296,
    "m_vecGrabbedPos": 4352,
    "m_vel": 4320
  },
  "C_Inferno": {
    "m_BurnNormal": 4932,
    "m_bFireIsBurning": 4868,
    "m_bInPostEffectTime": 5712,
    "m_blosCheck": 33380,
    "m_drawableCount": 33376,
    "m_fireCount": 5700,
    "m_fireParentPositions": 4100,
    "m_firePositions": 3332,
    "m_flLastGrassBurnThink": 33420,
    "m_lastFireCount": 5716,
    "m_maxBounds": 33408,
    "m_maxFireHalfWidth": 33388,
    "m_maxFireHeight": 33392,
    "m_minBounds": 33396,
    "m_nFireEffectTickBegin": 5720,
    "m_nFireLifetime": 5708,
    "m_nInfernoType": 5704,
    "m_nfxFireDamageEffect": 3328,
    "m_nlosperiod": 33384
  },
  "C_InfoVisibilityBox": {
    "m_bEnabled": 1364,
    "m_nMode": 1348,
    "m_vBoxSize": 1352
  },
  "C_IronSightController": {
    "m_angDeltaAverage": 48,
    "m_angViewLast": 144,
    "m_bIronSightAvailable": 16,
    "m_flDotBlur": 164,
    "m_flInterpolationLastUpdated": 44,
    "m_flIronSightAmount": 20,
    "m_flIronSightAmountBiased": 28,
    "m_flIronSightAmountBiased_Interpolated": 40,
    "m_flIronSightAmountGained": 24,
    "m_flIronSightAmountGained_Interpolated": 36,
    "m_flIronSightAmount_Interpolated": 32,
    "m_flSpeedRatio": 168,
    "m_vecDotCoords": 156
  },
  "C_Item": {
    "m_bShouldGlow": 5472,
    "m_pReticleHintTextName": 5473
  },
  "C_ItemDogtags": {
    "m_KillingPlayer": 5740,
    "m_OwningPlayer": 5736
  },
  "C_LightEntity": {
    "m_CLightComponent": 3264
  },
  "C_LightGlow": {
    "m_Glow": 3296,
    "m_flGlowProxySize": 3284,
    "m_flHDRColorScale": 3288,
    "m_nHorizontalSize": 3264,
    "m_nMaxDist": 3276,
    "m_nMinDist": 3272,
    "m_nOuterMaxDist": 3280,
    "m_nVerticalSize": 3268
  },
  "C_LightGlowOverlay": {
    "m_bModulateByDot": 245,
    "m_bOneSided": 244,
    "m_nMaxDist": 236,
    "m_nMinDist": 232,
    "m_nOuterMaxDist": 240,
    "m_vecDirection": 220,
    "m_vecOrigin": 208
  },
  "C_LocalTempEntity": {
    "bounceFactor": 3760,
    "die": 3740,
    "fadeSpeed": 3756,
    "flags": 3736,
    "hitSound": 3764,
    "m_bParticleCollision": 3848,
    "m_flFrame": 3824,
    "m_flFrameMax": 3744,
    "m_flFrameRate": 3820,
    "m_flSpriteScale": 3812,
    "m_iLastCollisionFrame": 3852,
    "m_nFlickerFrame": 3816,
    "m_pszImpactEffect": 3832,
    "m_pszParticleEffect": 3840,
    "m_vLastCollisionOrigin": 3856,
    "m_vecNormal": 3800,
    "m_vecPrevAbsOrigin": 3880,
    "m_vecTempEntAcceleration": 3892,
    "m_vecTempEntAngVelocity": 3784,
    "m_vecTempEntVelocity": 3868,
    "priority": 3768,
    "tempent_renderamt": 3796,
    "tentOffset": 3772,
    "x": 3748,
    "y": 3752
  },
  "C_MapVetoPickController": {
    "m_bDisabledHud": 3716,
    "m_nAccountIDs": 1652,
    "m_nCurrentPhase": 3700,
    "m_nDraftType": 1360,
    "m_nMapId0": 1908,
    "m_nMapId1": 2164,
    "m_nMapId2": 2420,
    "m_nMapId3": 2676,
    "m_nMapId4": 2932,
    "m_nMapId5": 3188,
    "m_nPhaseDurationTicks": 3708,
    "m_nPhaseStartTick": 3704,
    "m_nPostDataUpdateTick": 3712,
    "m_nStartingSide0": 3444,
    "m_nTeamWinningCoinToss": 1364,
    "m_nTeamWithFirstChoice": 1368,
    "m_nVoteMapIdsList": 1624
  },
  "C_Melee": {
    "m_flThrowAt": 6640
  },
  "C_MolotovProjectile": {
    "m_bIsIncGrenade": 4352
  },
  "C_Multimeter": {
    "m_hTargetC4": 3720
  },
  "C_OmniLight": {
    "m_bShowLight": 3856,
    "m_flInnerAngle": 3848,
    "m_flOuterAngle": 3852
  },
  "C_ParticleSystem": {
    "m_bActive": 3776,
    "m_bAnimateDuringGameplayPause": 3788,
    "m_bFrozen": 3777,
    "m_bNoFreeze": 4117,
    "m_bNoRamp": 4118,
    "m_bNoSave": 4116,
    "m_bOldActive": 4696,
    "m_bOldFrozen": 4697,
    "m_bStartActive": 4119,
    "m_clrTint": 4660,
    "m_flFreezeTransitionDuration": 3780,
    "m_flPreSimTime": 3804,
    "m_flStartTime": 3800,
    "m_hControlPointEnts": 3860,
    "m_iEffectIndex": 3792,
    "m_iServerControlPointAssignments": 3856,
    "m_iszControlPointNames": 4128,
    "m_iszEffectName": 4120,
    "m_nDataCP": 4640,
    "m_nStopType": 3784,
    "m_nTintCP": 4656,
    "m_szSnapshotFileName": 3264,
    "m_vServerControlPoints": 3808,
    "m_vecDataCPValue": 4644
  },
  "C_PathParticleRope": {
    "m_ColorTint": 1396,
    "m_PathNodes_Color": 1488,
    "m_PathNodes_Name": 1360,
    "m_PathNodes_PinEnabled": 1512,
    "m_PathNodes_Position": 1416,
    "m_PathNodes_RadiusScale": 1536,
    "m_PathNodes_TangentIn": 1440,
    "m_PathNodes_TangentOut": 1464,
    "m_bStartActive": 1344,
    "m_flMaxSimulationTime": 1348,
    "m_flParticleSpacing": 1384,
    "m_flRadius": 1392,
    "m_flSlack": 1388,
    "m_iEffectIndex": 1408,
    "m_iszEffectName": 1352,
    "m_nEffectState": 1400
  },
  "C_PhysMagnet": {
    "m_aAttachedObjects": 3736,
    "m_aAttachedObjectsFromServer": 3712
  },
  "C_PhysPropClientside": {
    "m_bHasBreakPiecesOrCommands": 4100,
    "m_fDeathTime": 4052,
    "m_flDmgModBullet": 4064,
    "m_flDmgModClub": 4068,
    "m_flDmgModExplosive": 4072,
    "m_flDmgModFire": 4076,
    "m_flTouchDelta": 4048,
    "m_iInteractions": 4096,
    "m_impactEnergyScale": 4056,
    "m_inertiaScale": 4060,
    "m_iszBasePropData": 4088,
    "m_iszPhysicsDamageTableName": 4080,
    "m_nDamageType": 4128,
    "m_vecDamageDirection": 4116,
    "m_vecDamagePosition": 4104
  },
  "C_PhysicsProp": {
    "m_bAwake": 4048
  },
  "C_PickUpModelSlerper": {
    "m_angOriginal": 3724,
    "m_angRandom": 3752,
    "m_flTimePickedUp": 3720,
    "m_hItem": 3716,
    "m_hPlayerParent": 3712,
    "m_vecPosOriginal": 3736
  },
  "C_PlantedC4": {
    "m_bBeingDefused": 3772,
    "m_bBombDefused": 3796,
    "m_bBombTicking": 3712,
    "m_bC4Activated": 3784,
    "m_bCannotBeDefused": 3764,
    "m_bExplodeWarning": 3780,
    "m_bHasExploded": 3765,
    "m_bRadarFlash": 3816,
    "m_bTenSecWarning": 3785,
    "m_bTriggerWarning": 3776,
    "m_entitySpottedState": 3728,
    "m_fLastDefuseTime": 3824,
    "m_flC4Blow": 3760,
    "m_flDefuseCountDown": 3792,
    "m_flDefuseLength": 3788,
    "m_flNextBeep": 3756,
    "m_flNextGlow": 3752,
    "m_flNextRadarFlashTime": 3812,
    "m_flTimerLength": 3768,
    "m_hBombDefuser": 3800,
    "m_hControlPanel": 3804,
    "m_hDefuserMultimeter": 3808,
    "m_nBombSite": 3716,
    "m_nSourceSoundscapeHash": 3720,
    "m_pBombDefuser": 3820,
    "m_pPredictionOwner": 3832
  },
  "C_PlayerPing": {
    "m_bUrgent": 1404,
    "m_hPingedEntity": 1396,
    "m_hPlayer": 1392,
    "m_iType": 1400,
    "m_szPlaceName": 1405
  },
  "C_PlayerSprayDecal": {
    "m_SprayRenderHelper": 3488,
    "m_flCreationTime": 3340,
    "m_nEntity": 3332,
    "m_nHitbox": 3336,
    "m_nPlayer": 3328,
    "m_nTintID": 3344,
    "m_nUniqueID": 3264,
    "m_nVersion": 3348,
    "m_rtGcTime": 3276,
    "m_ubSignature": 3349,
    "m_unAccountID": 3268,
    "m_unTraceID": 3272,
    "m_vecEndPos": 3280,
    "m_vecLeft": 3304,
    "m_vecNormal": 3316,
    "m_vecStart": 3292
  },
  "C_PlayerVisibility": {
    "m_bIsEnabled": 1361,
    "m_bStartDisabled": 1360,
    "m_flFadeTime": 1356,
    "m_flFogDistanceMultiplier": 1348,
    "m_flFogMaxDensityMultiplier": 1352,
    "m_flVisibilityStrength": 1344
  },
  "C_PointCamera": {
    "m_DegreesPerSecond": 1424,
    "m_FOV": 1344,
    "m_FogColor": 1353,
    "m_Resolution": 1348,
    "m_TargetFOV": 1420,
    "m_bActive": 1372,
    "m_bCanHLTVUse": 1396,
    "m_bDofEnabled": 1397,
    "m_bFogEnable": 1352,
    "m_bIsOn": 1428,
    "m_bNoSky": 1380,
    "m_bUseScreenAspectRatio": 1373,
    "m_fBrightness": 1384,
    "m_flAspectRatio": 1376,
    "m_flDofFarBlurry": 1412,
    "m_flDofFarCrisp": 1408,
    "m_flDofNearBlurry": 1400,
    "m_flDofNearCrisp": 1404,
    "m_flDofTiltToGround": 1416,
    "m_flFogEnd": 1364,
    "m_flFogMaxDensity": 1368,
    "m_flFogStart": 1360,
    "m_flZFar": 1388,
    "m_flZNear": 1392,
    "m_pNext": 1432
  },
  "C_PointCameraVFOV": {
    "m_flVerticalFOV": 1440
  },
  "C_PointClientUIDialog": {
    "m_bStartEnabled": 3316,
    "m_hActivator": 3312
  },
  "C_PointClientUIHUD": {
    "m_bAllowInteractionFromAllSceneWorlds": 3752,
    "m_bCheckCSSClasses": 3320,
    "m_bIgnoreInput": 3712,
    "m_flDPI": 3724,
    "m_flDepthOffset": 3732,
    "m_flHeight": 3720,
    "m_flInteractDistance": 3728,
    "m_flWidth": 3716,
    "m_unHorizontalAlign": 3740,
    "m_unOrientation": 3748,
    "m_unOwnerContext": 3736,
    "m_unVerticalAlign": 3744,
    "m_vecCSSClasses": 3760
  },
  "C_PointClientUIWorldPanel": {
    "m_anchorDeltaTransform": 3328,
    "m_bAllowInteractionFromAllSceneWorlds": 3824,
    "m_bCheckCSSClasses": 3322,
    "m_bDisableMipGen": 3863,
    "m_bExcludeFromSaveGames": 3860,
    "m_bFollowPlayerAcrossTeleport": 3786,
    "m_bForceRecreateNextUpdate": 3320,
    "m_bGrabbable": 3861,
    "m_bIgnoreInput": 3784,
    "m_bLit": 3785,
    "m_bMoveViewToPlayerNextThink": 3321,
    "m_bNoDepth": 3857,
    "m_bOnlyRenderToTexture": 3862,
    "m_bOpaque": 3856,
    "m_bRenderBackface": 3858,
    "m_bUseOffScreenIndicator": 3859,
    "m_flDPI": 3796,
    "m_flDepthOffset": 3804,
    "m_flHeight": 3792,
    "m_flInteractDistance": 3800,
    "m_flWidth": 3788,
    "m_nExplicitImageLayout": 3864,
    "m_pOffScreenIndicator": 3744,
    "m_unHorizontalAlign": 3812,
    "m_unOrientation": 3820,
    "m_unOwnerContext": 3808,
    "m_unVerticalAlign": 3816,
    "m_vecCSSClasses": 3832
  },
  "C_PointClientUIWorldTextPanel": {
    "m_messageText": 3872
  },
  "C_PointCommentaryNode": {
    "m_bActive": 3720,
    "m_bListenedTo": 3768,
    "m_bRestartAfterRestore": 3788,
    "m_bWasActive": 3721,
    "m_flEndTime": 3724,
    "m_flStartTime": 3728,
    "m_flStartTimeInCommentary": 3732,
    "m_hViewPosition": 3784,
    "m_iNodeNumber": 3760,
    "m_iNodeNumberMax": 3764,
    "m_iszCommentaryFile": 3736,
    "m_iszSpeakers": 3752,
    "m_iszTitle": 3744
  },
  "C_PointValueRemapper": {
    "m_bDisabled": 1344,
    "m_bDisabledOld": 1345,
    "m_bEngaged": 1440,
    "m_bFirstUpdate": 1441,
    "m_bRequiresUseKey": 1372,
    "m_bUpdateOnClient": 1346,
    "m_flCurrentMomentum": 1424,
    "m_flDisengageDistance": 1364,
    "m_flEngageDistance": 1368,
    "m_flInputOffset": 1436,
    "m_flMaximumChangePerSecond": 1360,
    "m_flMomentumModifier": 1416,
    "m_flPreviousUpdateTickTime": 1448,
    "m_flPreviousValue": 1444,
    "m_flRatchetOffset": 1432,
    "m_flSnapValue": 1420,
    "m_hOutputEntities": 1384,
    "m_hRemapLineEnd": 1356,
    "m_hRemapLineStart": 1352,
    "m_nHapticsType": 1408,
    "m_nInputType": 1348,
    "m_nMomentumType": 1412,
    "m_nOutputType": 1376,
    "m_nRatchetType": 1428,
    "m_vecPreviousTestPoint": 1452
  },
  "C_PointWorldText": {
    "m_Color": 3880,
    "m_FontName": 3800,
    "m_bEnabled": 3864,
    "m_bForceRecreateNextUpdate": 3272,
    "m_bFullbright": 3865,
    "m_flDepthOffset": 3876,
    "m_flFontSize": 3872,
    "m_flWorldUnitsPerPx": 3868,
    "m_messageText": 3288,
    "m_nJustifyHorizontal": 3884,
    "m_nJustifyVertical": 3888,
    "m_nReorientMode": 3892
  },
  "C_PostProcessingVolume": {
    "m_bExposureControl": 3333,
    "m_bMaster": 3332,
    "m_flExposureCompensation": 3316,
    "m_flExposureFadeSpeedDown": 3324,
    "m_flExposureFadeSpeedUp": 3320,
    "m_flFadeDuration": 3296,
    "m_flMaxExposure": 3312,
    "m_flMaxLogExposure": 3304,
    "m_flMinExposure": 3308,
    "m_flMinLogExposure": 3300,
    "m_flRate": 3336,
    "m_flTonemapEVSmoothingRange": 3328,
    "m_flTonemapMinAvgLum": 3348,
    "m_flTonemapPercentBrightPixels": 3344,
    "m_flTonemapPercentTarget": 3340,
    "m_hPostSettings": 3288
  },
  "C_Precipitation": {
    "m_bActiveParticlePrecipEmitter": 3344,
    "m_bHasSimulatedSinceLastSceneObjectUpdate": 3346,
    "m_bParticlePrecipInitialized": 3345,
    "m_flDensity": 3272,
    "m_flParticleInnerDist": 3288,
    "m_nAvailableSheetSequencesMaxIndex": 3348,
    "m_pParticleDef": 3296,
    "m_tParticlePrecipTraceTimer": 3336
  },
  "C_PredictedViewModel": {
    "m_LagAnglesHistory": 3816,
    "m_vPredictedOffset": 3840
  },
  "C_RagdollManager": {
    "m_iCurrentMaxRagdollCount": 1344
  },
  "C_RagdollProp": {
    "m_flBlendWeight": 3768,
    "m_flBlendWeightCurrent": 3780,
    "m_hRagdollSource": 3772,
    "m_iEyeAttachment": 3776,
    "m_parentPhysicsBoneIndices": 3784,
    "m_ragAngles": 3744,
    "m_ragPos": 3720,
    "m_worldSpaceBoneComputationOrder": 3808
  },
  "C_RagdollPropAttached": {
    "m_attachmentPointBoneSpace": 3840,
    "m_attachmentPointRagdollSpace": 3852,
    "m_bHasParent": 3880,
    "m_boneIndexAttached": 3832,
    "m_parentTime": 3876,
    "m_ragdollAttachedObjectIndex": 3836,
    "m_vecOffset": 3864
  },
  "C_RectLight": {
    "m_bShowLight": 3848
  },
  "C_RetakeGameRules": {
    "m_bBlockersPresent": 252,
    "m_bRoundInProgress": 253,
    "m_iBombSite": 260,
    "m_iFirstSecondHalfRound": 256,
    "m_nMatchSeed": 248
  },
  "C_RopeKeyframe": {
    "m_LightValues": 3968,
    "m_LinksTouchingSomething": 3272,
    "m_PhysicsDelegate": 4120,
    "m_RopeFlags": 3328,
    "m_RopeLength": 4104,
    "m_Slack": 4106,
    "m_Subdiv": 4102,
    "m_TextureHeight": 4144,
    "m_TextureScale": 4108,
    "m_Width": 4116,
    "m_bApplyWind": 3280,
    "m_bConstrainBetweenEndpoints": 4256,
    "m_bEndPointAttachmentAnglesDirty": 0,
    "m_bEndPointAttachmentPositionsDirty": 0,
    "m_bNewDataThisFrame": 0,
    "m_bPhysicsInitted": 0,
    "m_bPrevEndPointPos": 3292,
    "m_fLockedPoints": 4112,
    "m_fPrevLockedPoints": 3284,
    "m_flCurScroll": 3320,
    "m_flCurrentGustLifetime": 4176,
    "m_flCurrentGustTimer": 4172,
    "m_flScrollSpeed": 3324,
    "m_flTimeToNextGust": 4180,
    "m_hEndPoint": 4096,
    "m_hMaterial": 4136,
    "m_hStartPoint": 4092,
    "m_iEndAttachment": 4101,
    "m_iForcePointMoveCounter": 3288,
    "m_iRopeMaterialModelIndex": 3336,
    "m_iStartAttachment": 4100,
    "m_nChangeCount": 4113,
    "m_nLinksTouchingSomething": 3276,
    "m_nSegments": 4088,
    "m_vCachedEndPointAttachmentAngle": 4232,
    "m_vCachedEndPointAttachmentPos": 4208,
    "m_vColorMod": 4196,
    "m_vPrevEndPointPos": 3296,
    "m_vWindDir": 4184,
    "m_vecImpulse": 4148,
    "m_vecPreviousImpulse": 4160
  },
  "C_RopeKeyframe_CPhysicsDelegate": {
    "m_pKeyframe": 8
  },
  "C_SceneEntity": {
    "m_QueuedEvents": 1408,
    "m_bAutogenerated": 1355,
    "m_bClientOnly": 1362,
    "m_bIsPlayingBack": 1352,
    "m_bMultiplayer": 1354,
    "m_bPaused": 1353,
    "m_bWasPlaying": 1392,
    "m_flCurrentTime": 1432,
    "m_flForceClientTime": 1356,
    "m_hActorList": 1368,
    "m_hOwner": 1364,
    "m_nSceneStringIndex": 1360
  },
  "C_SceneEntity_QueuedEvents_t": {
    "starttime": 0
  },
  "C_ShatterGlassShardPhysics": {
    "m_ShardDesc": 4064
  },
  "C_SkyCamera": {
    "m_bUseAngles": 1492,
    "m_pNext": 1496,
    "m_skyboxData": 1344,
    "m_skyboxSlotToken": 1488
  },
  "C_SmokeGrenadeProjectile": {
    "m_VoxelFrameData": 4400,
    "m_bDidSmokeEffect": 4364,
    "m_bSmokeEffectSpawned": 4425,
    "m_bSmokeVolumeDataReceived": 4424,
    "m_nRandomSeed": 4368,
    "m_nSmokeEffectTickBegin": 4360,
    "m_vSmokeColor": 4372,
    "m_vSmokeDetonationPos": 4384
  },
  "C_SoundAreaEntityBase": {
    "m_bDisabled": 1344,
    "m_bWasEnabled": 1352,
    "m_iszSoundAreaType": 1360,
    "m_vPos": 1368
  },
  "C_SoundAreaEntityOrientedBox": {
    "m_vMax": 1396,
    "m_vMin": 1384
  },
  "C_SoundAreaEntitySphere": {
    "m_flRadius": 1384
  },
  "C_SoundOpvarSetPointBase": {
    "m_bUseAutoCompare": 1372,
    "m_iOpvarIndex": 1368,
    "m_iszOperatorName": 1352,
    "m_iszOpvarName": 1360,
    "m_iszStackName": 1344
  },
  "C_SpotlightEnd": {
    "m_Radius": 3268,
    "m_flLightScale": 3264
  },
  "C_Sprite": {
    "m_bWorldSpaceScale": 3344,
    "m_flBrightnessDuration": 3332,
    "m_flBrightnessTimeStart": 3384,
    "m_flDestScale": 3368,
    "m_flDieTime": 3312,
    "m_flFrame": 3308,
    "m_flGlowProxySize": 3348,
    "m_flHDRColorScale": 3352,
    "m_flLastTime": 3356,
    "m_flMaxFrame": 3360,
    "m_flScaleDuration": 3340,
    "m_flScaleTimeStart": 3372,
    "m_flSpriteFramerate": 3304,
    "m_flSpriteScale": 3336,
    "m_flStartScale": 3364,
    "m_hAttachedToEntity": 3296,
    "m_hOldSpriteMaterial": 3392,
    "m_hSpriteMaterial": 3288,
    "m_nAttachment": 3300,
    "m_nBrightness": 3328,
    "m_nDestBrightness": 3380,
    "m_nSpriteHeight": 3564,
    "m_nSpriteWidth": 3560,
    "m_nStartBrightness": 3376
  },
  "C_Sun": {
    "m_bOn": 3324,
    "m_bmaxColor": 3325,
    "m_clrOverlay": 3320,
    "m_fdistNormalize": 3272,
    "m_flAlphaHaze": 3344,
    "m_flAlphaHdr": 3352,
    "m_flAlphaScale": 3348,
    "m_flFarZScale": 3356,
    "m_flHDRColorScale": 3340,
    "m_flHazeScale": 3332,
    "m_flRotation": 3336,
    "m_flSize": 3328,
    "m_fxSSSunFlareEffectIndex": 3264,
    "m_fxSunFlareEffectIndex": 3268,
    "m_iszEffectName": 3304,
    "m_iszSSEffectName": 3312,
    "m_vDirection": 3288,
    "m_vSunPos": 3276
  },
  "C_SunGlowOverlay": {
    "m_bModulateByDot": 208
  },
  "C_Team": {
    "m_aPlayerControllers": 1344,
    "m_aPlayers": 1368,
    "m_iScore": 1392,
    "m_szTeamname": 1396
  },
  "C_TeamRoundTimer": {
    "m_bAutoCountdown": 1372,
    "m_bFire10SecRemain": 1400,
    "m_bFire1MinRemain": 1398,
    "m_bFire1SecRemain": 1405,
    "m_bFire2MinRemain": 1397,
    "m_bFire2SecRemain": 1404,
    "m_bFire30SecRemain": 1399,
    "m_bFire3MinRemain": 1396,
    "m_bFire3SecRemain": 1403,
    "m_bFire4MinRemain": 1395,
    "m_bFire4SecRemain": 1402,
    "m_bFire5MinRemain": 1394,
    "m_bFire5SecRemain": 1401,
    "m_bFireFinished": 1393,
    "m_bInCaptureWatchState": 1385,
    "m_bIsDisabled": 1356,
    "m_bShowInHUD": 1357,
    "m_bStartPaused": 1384,
    "m_bStopWatchTimer": 1392,
    "m_bTimerPaused": 1344,
    "m_flTimeRemaining": 1348,
    "m_flTimerEndTime": 1352,
    "m_flTotalTime": 1388,
    "m_nOldTimerLength": 1408,
    "m_nOldTimerState": 1412,
    "m_nSetupTimeLength": 1376,
    "m_nState": 1380,
    "m_nTimerInitialLength": 1364,
    "m_nTimerLength": 1360,
    "m_nTimerMaxLength": 1368
  },
  "C_TextureBasedAnimatable": {
    "m_bLoop": 3264,
    "m_flFPS": 3268,
    "m_flStartFrame": 3316,
    "m_flStartTime": 3312,
    "m_hPositionKeys": 3272,
    "m_hRotationKeys": 3280,
    "m_vAnimationBoundsMax": 3300,
    "m_vAnimationBoundsMin": 3288
  },
  "C_TonemapController2": {
    "m_flAutoExposureMax": 1348,
    "m_flAutoExposureMin": 1344,
    "m_flExposureAdaptationSpeedDown": 1368,
    "m_flExposureAdaptationSpeedUp": 1364,
    "m_flTonemapEVSmoothingRange": 1372,
    "m_flTonemapMinAvgLum": 1360,
    "m_flTonemapPercentBrightPixels": 1356,
    "m_flTonemapPercentTarget": 1352
  },
  "C_TriggerBuoyancy": {
    "m_BuoyancyHelper": 3272,
    "m_flFluidDensity": 3304
  },
  "C_ViewmodelWeapon": {
    "m_worldModel": 3712
  },
  "C_VoteController": {
    "m_bIsYesNoVote": 1394,
    "m_bTypeDirty": 1393,
    "m_bVotesDirty": 1392,
    "m_iActiveIssueIndex": 1360,
    "m_iOnlyTeamToVote": 1364,
    "m_nPotentialVotes": 1388,
    "m_nVoteOptionCount": 1368
  },
  "C_WeaponBaseItem": {
    "m_SequenceCompleteTimer": 6640,
    "m_bRedraw": 6664
  },
  "C_WeaponShield": {
    "m_flDisplayHealth": 6672
  },
  "C_WeaponTaser": {
    "m_fFireTime": 6672
  },
  "C_fogplayerparams_t": {
    "m_NewColor": 40,
    "m_OldColor": 16,
    "m_flNewEnd": 48,
    "m_flNewFarZ": 60,
    "m_flNewHDRColorScale": 56,
    "m_flNewMaxDensity": 52,
    "m_flNewStart": 44,
    "m_flOldEnd": 24,
    "m_flOldFarZ": 36,
    "m_flOldHDRColorScale": 32,
    "m_flOldMaxDensity": 28,
    "m_flOldStart": 20,
    "m_flTransitionTime": 12,
    "m_hCtrl": 8
  },
  "CompMatMutatorCondition_t": {
    "m_bPassWhenTrue": 32,
    "m_nMutatorCondition": 0,
    "m_strMutatorConditionContainerName": 8,
    "m_strMutatorConditionContainerVarName": 16,
    "m_strMutatorConditionContainerVarValue": 24
  },
  "CompMatPropertyMutator_t": {
    "m_bCaptureInRenderDoc": 750,
    "m_bEnabled": 0,
    "m_bIsScratchTarget": 748,
    "m_bSplatDebugInfo": 749,
    "m_colDrawText_Color": 832,
    "m_nMutatorCommandType": 4,
    "m_nResolution": 744,
    "m_nSetValue_Value": 104,
    "m_strCopyKeysWithSuffix_FindSuffix": 88,
    "m_strCopyKeysWithSuffix_InputContainerSrc": 80,
    "m_strCopyKeysWithSuffix_ReplaceSuffix": 96,
    "m_strCopyMatchingKeys_InputContainerSrc": 72,
    "m_strCopyProperty_InputContainerProperty": 24,
    "m_strCopyProperty_InputContainerSrc": 16,
    "m_strCopyProperty_TargetProperty": 32,
    "m_strDrawText_Font": 840,
    "m_strDrawText_InputContainerProperty": 816,
    "m_strDrawText_InputContainerSrc": 808,
    "m_strGenerateTexture_InitialContainer": 736,
    "m_strGenerateTexture_TargetParam": 728,
    "m_strInitWith_Container": 8,
    "m_strPopInputQueue_Container": 800,
    "m_strRandomRollInputVars_SeedInputVar": 40,
    "m_vecConditionalMutators": 776,
    "m_vecConditions": 848,
    "m_vecDrawText_Position": 824,
    "m_vecRandomRollInputVars_InputVarsToRoll": 48,
    "m_vecTexGenInstructions": 752
  },
  "CompositeMaterialAssemblyProcedure_t": {
    "m_vecCompMatIncludes": 0,
    "m_vecCompositeInputContainers": 48,
    "m_vecMatchFilters": 24,
    "m_vecPropertyMutators": 72
  },
  "CompositeMaterialEditorPoint_t": {
    "m_ChildModelName": 256,
    "m_KVModelStateChoices": 232,
    "m_ModelName": 0,
    "m_bEnableChildModel": 248,
    "m_flCycle": 228,
    "m_nSequenceIndex": 224,
    "m_vecCompositeMaterialAssemblyProcedures": 480,
    "m_vecCompositeMaterials": 504
  },
  "CompositeMaterialInputContainer_t": {
    "m_bEnabled": 0,
    "m_bExposeExternally": 280,
    "m_nCompositeMaterialInputContainerSourceType": 4,
    "m_strAlias": 240,
    "m_strAttrName": 232,
    "m_strAttrNameForVar": 272,
    "m_strSpecificContainerMaterial": 8,
    "m_vecLooseVariables": 248
  },
  "CompositeMaterialInputLooseVariable_t": {
    "m_bExposeExternally": 8,
    "m_bExposedVariableIsFixedRange": 32,
    "m_bHasFloatBounds": 80,
    "m_bValueBoolean": 60,
    "m_cValueColor4": 132,
    "m_flValueFloatW": 120,
    "m_flValueFloatW_Max": 128,
    "m_flValueFloatW_Min": 124,
    "m_flValueFloatX": 84,
    "m_flValueFloatX_Max": 92,
    "m_flValueFloatX_Min": 88,
    "m_flValueFloatY": 96,
    "m_flValueFloatY_Max": 104,
    "m_flValueFloatY_Min": 100,
    "m_flValueFloatZ": 108,
    "m_flValueFloatZ_Max": 116,
    "m_flValueFloatZ_Min": 112,
    "m_nTextureType": 608,
    "m_nValueIntW": 76,
    "m_nValueIntX": 64,
    "m_nValueIntY": 68,
    "m_nValueIntZ": 72,
    "m_nValueSystemVar": 136,
    "m_nVariableType": 56,
    "m_strExposedFriendlyGroupName": 24,
    "m_strExposedFriendlyName": 16,
    "m_strExposedHiddenWhenTrue": 48,
    "m_strExposedVisibleWhenTrue": 40,
    "m_strName": 0,
    "m_strResourceMaterial": 144,
    "m_strString": 616,
    "m_strTextureCompilationVtexTemplate": 600,
    "m_strTextureContentAssetPath": 368,
    "m_strTextureRuntimeResourcePath": 376
  },
  "CompositeMaterialMatchFilter_t": {
    "m_bPassWhenTrue": 24,
    "m_nCompositeMaterialMatchFilterType": 0,
    "m_strMatchFilter": 8,
    "m_strMatchValue": 16
  },
  "CompositeMaterial_t": {
    "m_FinalKVs": 40,
    "m_PreGenerationKVs": 24,
    "m_TargetKVs": 8,
    "m_vecGeneratedTextures": 64
  },
  "CountdownTimer": {
    "m_duration": 8,
    "m_nWorldGroupId": 20,
    "m_timescale": 16,
    "m_timestamp": 12
  },
  "EngineCountdownTimer": {
    "m_duration": 8,
    "m_timescale": 16,
    "m_timestamp": 12
  },
  "EntityRenderAttribute_t": {
    "m_ID": 48,
    "m_Values": 52
  },
  "EntitySpottedState_t": {
    "m_bSpotted": 8,
    "m_bSpottedByMask": 12
  },
  "GeneratedTextureHandle_t": {
    "m_strBitmapName": 0
  },
  "IntervalTimer": {
    "m_nWorldGroupId": 12,
    "m_timestamp": 8
  },
  "PhysicsRagdollPose_t": {
    "__m_pChainEntity": 8,
    "m_Transforms": 48,
    "m_bDirty": 104,
    "m_hOwner": 72
  },
  "SellbackPurchaseEntry_t": {
    "m_bPrevHelmet": 60,
    "m_hItem": 64,
    "m_nCost": 52,
    "m_nPrevArmor": 56,
    "m_unDefIdx": 48
  },
  "ServerAuthoritativeWeaponSlot_t": {
    "unClass": 40,
    "unItemDefIdx": 44,
    "unSlot": 42
  },
  "TimedEvent": {
    "m_TimeBetweenEvents": 0,
    "m_fNextEvent": 4
  },
  "VPhysicsCollisionAttribute_t": {
    "m_nCollisionFunctionMask": 43,
    "m_nCollisionGroup": 42,
    "m_nEntityId": 32,
    "m_nHierarchyId": 40,
    "m_nInteractsAs": 8,
    "m_nInteractsExclude": 24,
    "m_nInteractsWith": 16,
    "m_nOwnerId": 36
  },
  "ViewAngleServerChange_t": {
    "nIndex": 64,
    "nType": 48,
    "qAngle": 52
  },
  "WeaponPurchaseCount_t": {
    "m_nCount": 50,
    "m_nItemDefIndex": 48
  },
  "WeaponPurchaseTracker_t": {
    "m_weaponPurchases": 8
  },
  "audioparams_t": {
    "localBits": 108,
    "localSound": 8,
    "soundEventHash": 116,
    "soundscapeEntityListIndex": 112,
    "soundscapeIndex": 104
  },
  "fogparams_t": {
    "HDRColorScale": 56,
    "blend": 101,
    "blendtobackground": 88,
    "colorPrimary": 20,
    "colorPrimaryLerpTo": 28,
    "colorSecondary": 24,
    "colorSecondaryLerpTo": 32,
    "dirPrimary": 8,
    "duration": 84,
    "enable": 100,
    "end": 40,
    "endLerpTo": 72,
    "exponent": 52,
    "farz": 44,
    "lerptime": 80,
    "locallightscale": 96,
    "m_bNoReflectionFog": 102,
    "m_bPadding": 103,
    "maxdensity": 48,
    "maxdensityLerpTo": 76,
    "scattering": 92,
    "skyboxFogFactor": 60,
    "skyboxFogFactorLerpTo": 64,
    "start": 36,
    "startLerpTo": 68
  },
  "shard_model_desc_t": {
    "m_ShatterPanelMode": 25,
    "m_SurfacePropStringToken": 88,
    "m_bHasParent": 84,
    "m_bParentFrozen": 85,
    "m_flGlassHalfThickness": 80,
    "m_hMaterial": 16,
    "m_nModelID": 8,
    "m_solid": 24,
    "m_vecPanelSize": 28,
    "m_vecPanelVertices": 56,
    "m_vecStressPositionA": 36,
    "m_vecStressPositionB": 44
  },
  "sky3dparams_t": {
    "bClip3DSkyBoxNearToWorldFar": 24,
    "flClip3DSkyBoxNearToWorldFarOffset": 28,
    "fog": 32,
    "m_nWorldGroupID": 136,
    "origin": 12,
    "scale": 8
  }
}
```

`SDK/client.dll.py`:

```py
'''
https://github.com/a2x/cs2-dumper
2023-11-23 10:28:27.230821300 UTC
'''

class ActiveModelConfig_t:
    m_Handle = 0x28 # ModelConfigHandle_t
    m_Name = 0x30 # CUtlSymbolLarge
    m_AssociatedEntities = 0x38 # C_NetworkUtlVectorBase<CHandle<C_BaseModelEntity>>
    m_AssociatedEntityNames = 0x50 # C_NetworkUtlVectorBase<CUtlSymbolLarge>

class CAnimGraphNetworkedVariables:
    m_PredNetBoolVariables = 0x8 # C_NetworkUtlVectorBase<uint32_t>
    m_PredNetByteVariables = 0x20 # C_NetworkUtlVectorBase<uint8_t>
    m_PredNetUInt16Variables = 0x38 # C_NetworkUtlVectorBase<uint16_t>
    m_PredNetIntVariables = 0x50 # C_NetworkUtlVectorBase<int32_t>
    m_PredNetUInt32Variables = 0x68 # C_NetworkUtlVectorBase<uint32_t>
    m_PredNetUInt64Variables = 0x80 # C_NetworkUtlVectorBase<uint64_t>
    m_PredNetFloatVariables = 0x98 # C_NetworkUtlVectorBase<float>
    m_PredNetVectorVariables = 0xB0 # C_NetworkUtlVectorBase<Vector>
    m_PredNetQuaternionVariables = 0xC8 # C_NetworkUtlVectorBase<Quaternion>
    m_OwnerOnlyPredNetBoolVariables = 0xE0 # C_NetworkUtlVectorBase<uint32_t>
    m_OwnerOnlyPredNetByteVariables = 0xF8 # C_NetworkUtlVectorBase<uint8_t>
    m_OwnerOnlyPredNetUInt16Variables = 0x110 # C_NetworkUtlVectorBase<uint16_t>
    m_OwnerOnlyPredNetIntVariables = 0x128 # C_NetworkUtlVectorBase<int32_t>
    m_OwnerOnlyPredNetUInt32Variables = 0x140 # C_NetworkUtlVectorBase<uint32_t>
    m_OwnerOnlyPredNetUInt64Variables = 0x158 # C_NetworkUtlVectorBase<uint64_t>
    m_OwnerOnlyPredNetFloatVariables = 0x170 # C_NetworkUtlVectorBase<float>
    m_OwnerOnlyPredNetVectorVariables = 0x188 # C_NetworkUtlVectorBase<Vector>
    m_OwnerOnlyPredNetQuaternionVariables = 0x1A0 # C_NetworkUtlVectorBase<Quaternion>
    m_nBoolVariablesCount = 0x1B8 # int32_t
    m_nOwnerOnlyBoolVariablesCount = 0x1BC # int32_t
    m_nRandomSeedOffset = 0x1C0 # int32_t
    m_flLastTeleportTime = 0x1C4 # float

class CAttributeList:
    m_Attributes = 0x8 # C_UtlVectorEmbeddedNetworkVar<CEconItemAttribute>
    m_pManager = 0x58 # CAttributeManager*

class CAttributeManager:
    m_Providers = 0x8 # CUtlVector<CHandle<C_BaseEntity>>
    m_iReapplyProvisionParity = 0x20 # int32_t
    m_hOuter = 0x24 # CHandle<C_BaseEntity>
    m_bPreventLoopback = 0x28 # bool
    m_ProviderType = 0x2C # attributeprovidertypes_t
    m_CachedResults = 0x30 # CUtlVector<CAttributeManager::cached_attribute_float_t>

class CAttributeManager_cached_attribute_float_t:
    flIn = 0x0 # float
    iAttribHook = 0x8 # CUtlSymbolLarge
    flOut = 0x10 # float

class CBaseAnimGraph:
    m_bInitiallyPopulateInterpHistory = 0xCC0 # bool
    m_bShouldAnimateDuringGameplayPause = 0xCC1 # bool
    m_bSuppressAnimEventSounds = 0xCC3 # bool
    m_bAnimGraphUpdateEnabled = 0xCD0 # bool
    m_flMaxSlopeDistance = 0xCD4 # float
    m_vLastSlopeCheckPos = 0xCD8 # Vector
    m_vecForce = 0xCE8 # Vector
    m_nForceBone = 0xCF4 # int32_t
    m_pClientsideRagdoll = 0xCF8 # CBaseAnimGraph*
    m_bBuiltRagdoll = 0xD00 # bool
    m_pRagdollPose = 0xD18 # PhysicsRagdollPose_t*
    m_bClientRagdoll = 0xD20 # bool
    m_bHasAnimatedMaterialAttributes = 0xD30 # bool

class CBaseAnimGraphController:
    m_baseLayer = 0x18 # CNetworkedSequenceOperation
    m_animGraphNetworkedVars = 0x40 # CAnimGraphNetworkedVariables
    m_bSequenceFinished = 0x1320 # bool
    m_flLastEventCycle = 0x1324 # float
    m_flLastEventAnimTime = 0x1328 # float
    m_flPlaybackRate = 0x132C # CNetworkedQuantizedFloat
    m_flPrevAnimTime = 0x1334 # float
    m_bClientSideAnimation = 0x1338 # bool
    m_bNetworkedAnimationInputsChanged = 0x1339 # bool
    m_nPrevNewSequenceParity = 0x133A # uint8_t
    m_nPrevResetEventsParity = 0x133B # uint8_t
    m_nNewSequenceParity = 0x133C # int32_t
    m_nResetEventsParity = 0x1340 # int32_t
    m_nAnimLoopMode = 0x1344 # AnimLoopMode_t
    m_hAnimationUpdate = 0x13E4 # AnimationUpdateListHandle_t
    m_hLastAnimEventSequence = 0x13E8 # HSequence

class CBasePlayerController:
    m_nFinalPredictedTick = 0x548 # int32_t
    m_CommandContext = 0x550 # C_CommandContext
    m_nInButtonsWhichAreToggles = 0x600 # uint64_t
    m_nTickBase = 0x608 # uint32_t
    m_hPawn = 0x60C # CHandle<C_BasePlayerPawn>
    m_hPredictedPawn = 0x610 # CHandle<C_BasePlayerPawn>
    m_nSplitScreenSlot = 0x614 # CSplitScreenSlot
    m_hSplitOwner = 0x618 # CHandle<CBasePlayerController>
    m_hSplitScreenPlayers = 0x620 # CUtlVector<CHandle<CBasePlayerController>>
    m_bIsHLTV = 0x638 # bool
    m_iConnected = 0x63C # PlayerConnectedState
    m_iszPlayerName = 0x640 # char[128]
    m_steamID = 0x6C8 # uint64_t
    m_bIsLocalPlayerController = 0x6D0 # bool
    m_iDesiredFOV = 0x6D4 # uint32_t

class CBasePlayerVData:
    m_sModelName = 0x28 # CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    m_flHeadDamageMultiplier = 0x108 # CSkillFloat
    m_flChestDamageMultiplier = 0x118 # CSkillFloat
    m_flStomachDamageMultiplier = 0x128 # CSkillFloat
    m_flArmDamageMultiplier = 0x138 # CSkillFloat
    m_flLegDamageMultiplier = 0x148 # CSkillFloat
    m_flHoldBreathTime = 0x158 # float
    m_flDrowningDamageInterval = 0x15C # float
    m_nDrowningDamageInitial = 0x160 # int32_t
    m_nDrowningDamageMax = 0x164 # int32_t
    m_nWaterSpeed = 0x168 # int32_t
    m_flUseRange = 0x16C # float
    m_flUseAngleTolerance = 0x170 # float
    m_flCrouchTime = 0x174 # float

class CBasePlayerWeaponVData:
    m_szWorldModel = 0x28 # CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    m_bBuiltRightHanded = 0x108 # bool
    m_bAllowFlipping = 0x109 # bool
    m_bIsFullAuto = 0x10A # bool
    m_nNumBullets = 0x10C # int32_t
    m_sMuzzleAttachment = 0x110 # CUtlString
    m_szMuzzleFlashParticle = 0x118 # CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    m_iFlags = 0x1F8 # ItemFlagTypes_t
    m_nPrimaryAmmoType = 0x1F9 # AmmoIndex_t
    m_nSecondaryAmmoType = 0x1FA # AmmoIndex_t
    m_iMaxClip1 = 0x1FC # int32_t
    m_iMaxClip2 = 0x200 # int32_t
    m_iDefaultClip1 = 0x204 # int32_t
    m_iDefaultClip2 = 0x208 # int32_t
    m_iWeight = 0x20C # int32_t
    m_bAutoSwitchTo = 0x210 # bool
    m_bAutoSwitchFrom = 0x211 # bool
    m_iRumbleEffect = 0x214 # RumbleEffect_t
    m_aShootSounds = 0x218 # CUtlMap<WeaponSound_t,CSoundEventName>
    m_iSlot = 0x238 # int32_t
    m_iPosition = 0x23C # int32_t

class CBaseProp:
    m_bModelOverrodeBlockLOS = 0xE80 # bool
    m_iShapeType = 0xE84 # int32_t
    m_bConformToCollisionBounds = 0xE88 # bool
    m_mPreferredCatchTransform = 0xE8C # matrix3x4_t

class CBodyComponent:
    m_pSceneNode = 0x8 # CGameSceneNode*
    __m_pChainEntity = 0x20 # CNetworkVarChainer

class CBodyComponentBaseAnimGraph:
    m_animationController = 0x480 # CBaseAnimGraphController
    __m_pChainEntity = 0x18C0 # CNetworkVarChainer

class CBodyComponentBaseModelEntity:
    __m_pChainEntity = 0x480 # CNetworkVarChainer

class CBodyComponentPoint:
    m_sceneNode = 0x50 # CGameSceneNode
    __m_pChainEntity = 0x1A0 # CNetworkVarChainer

class CBodyComponentSkeletonInstance:
    m_skeletonInstance = 0x50 # CSkeletonInstance
    __m_pChainEntity = 0x450 # CNetworkVarChainer

class CBombTarget:
    m_bBombPlantedHere = 0xCC8 # bool

class CBuoyancyHelper:
    m_flFluidDensity = 0x18 # float

class CCSGameModeRules:
    __m_pChainEntity = 0x8 # CNetworkVarChainer

class CCSGameModeRules_Deathmatch:
    m_bFirstThink = 0x30 # bool
    m_bFirstThinkAfterConnected = 0x31 # bool
    m_flDMBonusStartTime = 0x34 # GameTime_t
    m_flDMBonusTimeLength = 0x38 # float
    m_nDMBonusWeaponLoadoutSlot = 0x3C # int16_t

class CCSObserver_ObserverServices:
    m_hLastObserverTarget = 0x58 # CEntityHandle
    m_vecObserverInterpolateOffset = 0x5C # Vector
    m_vecObserverInterpStartPos = 0x68 # Vector
    m_flObsInterp_PathLength = 0x74 # float
    m_qObsInterp_OrientationStart = 0x80 # Quaternion
    m_qObsInterp_OrientationTravelDir = 0x90 # Quaternion
    m_obsInterpState = 0xA0 # ObserverInterpState_t
    m_bObserverInterpolationNeedsDeferredSetup = 0xA4 # bool

class CCSPlayerBase_CameraServices:
    m_iFOV = 0x210 # uint32_t
    m_iFOVStart = 0x214 # uint32_t
    m_flFOVTime = 0x218 # GameTime_t
    m_flFOVRate = 0x21C # float
    m_hZoomOwner = 0x220 # CHandle<C_BaseEntity>
    m_flLastShotFOV = 0x224 # float

class CCSPlayerController:
    m_pInGameMoneyServices = 0x700 # CCSPlayerController_InGameMoneyServices*
    m_pInventoryServices = 0x708 # CCSPlayerController_InventoryServices*
    m_pActionTrackingServices = 0x710 # CCSPlayerController_ActionTrackingServices*
    m_pDamageServices = 0x718 # CCSPlayerController_DamageServices*
    m_iPing = 0x720 # uint32_t
    m_bHasCommunicationAbuseMute = 0x724 # bool
    m_szCrosshairCodes = 0x728 # CUtlSymbolLarge
    m_iPendingTeamNum = 0x730 # uint8_t
    m_flForceTeamTime = 0x734 # GameTime_t
    m_iCompTeammateColor = 0x738 # int32_t
    m_bEverPlayedOnTeam = 0x73C # bool
    m_flPreviousForceJoinTeamTime = 0x740 # GameTime_t
    m_szClan = 0x748 # CUtlSymbolLarge
    m_sSanitizedPlayerName = 0x750 # CUtlString
    m_iCoachingTeam = 0x758 # int32_t
    m_nPlayerDominated = 0x760 # uint64_t
    m_nPlayerDominatingMe = 0x768 # uint64_t
    m_iCompetitiveRanking = 0x770 # int32_t
    m_iCompetitiveWins = 0x774 # int32_t
    m_iCompetitiveRankType = 0x778 # int8_t
    m_iCompetitiveRankingPredicted_Win = 0x77C # int32_t
    m_iCompetitiveRankingPredicted_Loss = 0x780 # int32_t
    m_iCompetitiveRankingPredicted_Tie = 0x784 # int32_t
    m_nEndMatchNextMapVote = 0x788 # int32_t
    m_unActiveQuestId = 0x78C # uint16_t
    m_nQuestProgressReason = 0x790 # QuestProgress::Reason
    m_unPlayerTvControlFlags = 0x794 # uint32_t
    m_iDraftIndex = 0x7C0 # int32_t
    m_msQueuedModeDisconnectionTimestamp = 0x7C4 # uint32_t
    m_uiAbandonRecordedReason = 0x7C8 # uint32_t
    m_bCannotBeKicked = 0x7CC # bool
    m_bEverFullyConnected = 0x7CD # bool
    m_bAbandonAllowsSurrender = 0x7CE # bool
    m_bAbandonOffersInstantSurrender = 0x7CF # bool
    m_bDisconnection1MinWarningPrinted = 0x7D0 # bool
    m_bScoreReported = 0x7D1 # bool
    m_nDisconnectionTick = 0x7D4 # int32_t
    m_bControllingBot = 0x7E0 # bool
    m_bHasControlledBotThisRound = 0x7E1 # bool
    m_bHasBeenControlledByPlayerThisRound = 0x7E2 # bool
    m_nBotsControlledThisRound = 0x7E4 # int32_t
    m_bCanControlObservedBot = 0x7E8 # bool
    m_hPlayerPawn = 0x7EC # CHandle<C_CSPlayerPawn>
    m_hObserverPawn = 0x7F0 # CHandle<C_CSObserverPawn>
    m_bPawnIsAlive = 0x7F4 # bool
    m_iPawnHealth = 0x7F8 # uint32_t
    m_iPawnArmor = 0x7FC # int32_t
    m_bPawnHasDefuser = 0x800 # bool
    m_bPawnHasHelmet = 0x801 # bool
    m_nPawnCharacterDefIndex = 0x802 # uint16_t
    m_iPawnLifetimeStart = 0x804 # int32_t
    m_iPawnLifetimeEnd = 0x808 # int32_t
    m_iPawnBotDifficulty = 0x80C # int32_t
    m_hOriginalControllerOfCurrentPawn = 0x810 # CHandle<CCSPlayerController>
    m_iScore = 0x814 # int32_t
    m_vecKills = 0x818 # C_NetworkUtlVectorBase<EKillTypes_t>
    m_iMVPs = 0x830 # int32_t
    m_bIsPlayerNameDirty = 0x834 # bool

class CCSPlayerController_ActionTrackingServices:
    m_perRoundStats = 0x40 # C_UtlVectorEmbeddedNetworkVar<CSPerRoundStats_t>
    m_matchStats = 0x90 # CSMatchStats_t
    m_iNumRoundKills = 0x108 # int32_t
    m_iNumRoundKillsHeadshots = 0x10C # int32_t
    m_unTotalRoundDamageDealt = 0x110 # uint32_t

class CCSPlayerController_DamageServices:
    m_nSendUpdate = 0x40 # int32_t
    m_DamageList = 0x48 # C_UtlVectorEmbeddedNetworkVar<CDamageRecord>

class CCSPlayerController_InGameMoneyServices:
    m_iAccount = 0x40 # int32_t
    m_iStartAccount = 0x44 # int32_t
    m_iTotalCashSpent = 0x48 # int32_t
    m_iCashSpentThisRound = 0x4C # int32_t
    m_nPreviousAccount = 0x50 # int32_t

class CCSPlayerController_InventoryServices:
    m_unMusicID = 0x40 # uint16_t
    m_rank = 0x44 # MedalRank_t[6]
    m_nPersonaDataPublicLevel = 0x5C # int32_t
    m_nPersonaDataPublicCommendsLeader = 0x60 # int32_t
    m_nPersonaDataPublicCommendsTeacher = 0x64 # int32_t
    m_nPersonaDataPublicCommendsFriendly = 0x68 # int32_t
    m_vecServerAuthoritativeWeaponSlots = 0x70 # C_UtlVectorEmbeddedNetworkVar<ServerAuthoritativeWeaponSlot_t>

class CCSPlayer_ActionTrackingServices:
    m_hLastWeaponBeforeC4AutoSwitch = 0x40 # CHandle<C_BasePlayerWeapon>
    m_bIsRescuing = 0x44 # bool
    m_weaponPurchasesThisMatch = 0x48 # WeaponPurchaseTracker_t
    m_weaponPurchasesThisRound = 0xA0 # WeaponPurchaseTracker_t

class CCSPlayer_BulletServices:
    m_totalHitsOnServer = 0x40 # int32_t

class CCSPlayer_BuyServices:
    m_vecSellbackPurchaseEntries = 0x40 # C_UtlVectorEmbeddedNetworkVar<SellbackPurchaseEntry_t>

class CCSPlayer_CameraServices:
    m_flDeathCamTilt = 0x228 # float

class CCSPlayer_HostageServices:
    m_hCarriedHostage = 0x40 # CHandle<C_BaseEntity>
    m_hCarriedHostageProp = 0x44 # CHandle<C_BaseEntity>

class CCSPlayer_ItemServices:
    m_bHasDefuser = 0x40 # bool
    m_bHasHelmet = 0x41 # bool
    m_bHasHeavyArmor = 0x42 # bool

class CCSPlayer_MovementServices:
    m_flMaxFallVelocity = 0x210 # float
    m_vecLadderNormal = 0x214 # Vector
    m_nLadderSurfacePropIndex = 0x220 # int32_t
    m_flDuckAmount = 0x224 # float
    m_flDuckSpeed = 0x228 # float
    m_bDuckOverride = 0x22C # bool
    m_bDesiresDuck = 0x22D # bool
    m_flDuckOffset = 0x230 # float
    m_nDuckTimeMsecs = 0x234 # uint32_t
    m_nDuckJumpTimeMsecs = 0x238 # uint32_t
    m_nJumpTimeMsecs = 0x23C # uint32_t
    m_flLastDuckTime = 0x240 # float
    m_vecLastPositionAtFullCrouchSpeed = 0x250 # Vector2D
    m_duckUntilOnGround = 0x258 # bool
    m_bHasWalkMovedSinceLastJump = 0x259 # bool
    m_bInStuckTest = 0x25A # bool
    m_flStuckCheckTime = 0x268 # float[64][2]
    m_nTraceCount = 0x468 # int32_t
    m_StuckLast = 0x46C # int32_t
    m_bSpeedCropped = 0x470 # bool
    m_nOldWaterLevel = 0x474 # int32_t
    m_flWaterEntryTime = 0x478 # float
    m_vecForward = 0x47C # Vector
    m_vecLeft = 0x488 # Vector
    m_vecUp = 0x494 # Vector
    m_vecPreviouslyPredictedOrigin = 0x4A0 # Vector
    m_bOldJumpPressed = 0x4AC # bool
    m_flJumpPressedTime = 0x4B0 # float
    m_flJumpUntil = 0x4B4 # float
    m_flJumpVel = 0x4B8 # float
    m_fStashGrenadeParameterWhen = 0x4BC # GameTime_t
    m_nButtonDownMaskPrev = 0x4C0 # uint64_t
    m_flOffsetTickCompleteTime = 0x4C8 # float
    m_flOffsetTickStashedSpeed = 0x4CC # float
    m_flStamina = 0x4D0 # float
    m_bUpdatePredictedOriginAfterDataUpdate = 0x4D4 # bool
    m_flHeightAtJumpStart = 0x4D8 # float
    m_flMaxJumpHeightThisJump = 0x4DC # float

class CCSPlayer_PingServices:
    m_hPlayerPing = 0x40 # CHandle<C_BaseEntity>

class CCSPlayer_ViewModelServices:
    m_hViewModel = 0x40 # CHandle<C_BaseViewModel>[3]

class CCSPlayer_WaterServices:
    m_flWaterJumpTime = 0x40 # float
    m_vecWaterJumpVel = 0x44 # Vector
    m_flSwimSoundTime = 0x50 # float

class CCSPlayer_WeaponServices:
    m_flNextAttack = 0xC0 # GameTime_t
    m_bIsLookingAtWeapon = 0xC4 # bool
    m_bIsHoldingLookAtWeapon = 0xC5 # bool

class CCSWeaponBaseVData:
    m_WeaponType = 0x240 # CSWeaponType
    m_WeaponCategory = 0x244 # CSWeaponCategory
    m_szViewModel = 0x248 # CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    m_szPlayerModel = 0x328 # CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    m_szWorldDroppedModel = 0x408 # CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    m_szAimsightLensMaskModel = 0x4E8 # CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    m_szMagazineModel = 0x5C8 # CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    m_szHeatEffect = 0x6A8 # CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    m_szEjectBrassEffect = 0x788 # CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    m_szMuzzleFlashParticleAlt = 0x868 # CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    m_szMuzzleFlashThirdPersonParticle = 0x948 # CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    m_szMuzzleFlashThirdPersonParticleAlt = 0xA28 # CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    m_szTracerParticle = 0xB08 # CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    m_GearSlot = 0xBE8 # gear_slot_t
    m_GearSlotPosition = 0xBEC # int32_t
    m_DefaultLoadoutSlot = 0xBF0 # loadout_slot_t
    m_sWrongTeamMsg = 0xBF8 # CUtlString
    m_nPrice = 0xC00 # int32_t
    m_nKillAward = 0xC04 # int32_t
    m_nPrimaryReserveAmmoMax = 0xC08 # int32_t
    m_nSecondaryReserveAmmoMax = 0xC0C # int32_t
    m_bMeleeWeapon = 0xC10 # bool
    m_bHasBurstMode = 0xC11 # bool
    m_bIsRevolver = 0xC12 # bool
    m_bCannotShootUnderwater = 0xC13 # bool
    m_szName = 0xC18 # CUtlString
    m_szAnimExtension = 0xC20 # CUtlString
    m_eSilencerType = 0xC28 # CSWeaponSilencerType
    m_nCrosshairMinDistance = 0xC2C # int32_t
    m_nCrosshairDeltaDistance = 0xC30 # int32_t
    m_flCycleTime = 0xC34 # CFiringModeFloat
    m_flMaxSpeed = 0xC3C # CFiringModeFloat
    m_flSpread = 0xC44 # CFiringModeFloat
    m_flInaccuracyCrouch = 0xC4C # CFiringModeFloat
    m_flInaccuracyStand = 0xC54 # CFiringModeFloat
    m_flInaccuracyJump = 0xC5C # CFiringModeFloat
    m_flInaccuracyLand = 0xC64 # CFiringModeFloat
    m_flInaccuracyLadder = 0xC6C # CFiringModeFloat
    m_flInaccuracyFire = 0xC74 # CFiringModeFloat
    m_flInaccuracyMove = 0xC7C # CFiringModeFloat
    m_flRecoilAngle = 0xC84 # CFiringModeFloat
    m_flRecoilAngleVariance = 0xC8C # CFiringModeFloat
    m_flRecoilMagnitude = 0xC94 # CFiringModeFloat
    m_flRecoilMagnitudeVariance = 0xC9C # CFiringModeFloat
    m_nTracerFrequency = 0xCA4 # CFiringModeInt
    m_flInaccuracyJumpInitial = 0xCAC # float
    m_flInaccuracyJumpApex = 0xCB0 # float
    m_flInaccuracyReload = 0xCB4 # float
    m_nRecoilSeed = 0xCB8 # int32_t
    m_nSpreadSeed = 0xCBC # int32_t
    m_flTimeToIdleAfterFire = 0xCC0 # float
    m_flIdleInterval = 0xCC4 # float
    m_flAttackMovespeedFactor = 0xCC8 # float
    m_flHeatPerShot = 0xCCC # float
    m_flInaccuracyPitchShift = 0xCD0 # float
    m_flInaccuracyAltSoundThreshold = 0xCD4 # float
    m_flBotAudibleRange = 0xCD8 # float
    m_szUseRadioSubtitle = 0xCE0 # CUtlString
    m_bUnzoomsAfterShot = 0xCE8 # bool
    m_bHideViewModelWhenZoomed = 0xCE9 # bool
    m_nZoomLevels = 0xCEC # int32_t
    m_nZoomFOV1 = 0xCF0 # int32_t
    m_nZoomFOV2 = 0xCF4 # int32_t
    m_flZoomTime0 = 0xCF8 # float
    m_flZoomTime1 = 0xCFC # float
    m_flZoomTime2 = 0xD00 # float
    m_flIronSightPullUpSpeed = 0xD04 # float
    m_flIronSightPutDownSpeed = 0xD08 # float
    m_flIronSightFOV = 0xD0C # float
    m_flIronSightPivotForward = 0xD10 # float
    m_flIronSightLooseness = 0xD14 # float
    m_angPivotAngle = 0xD18 # QAngle
    m_vecIronSightEyePos = 0xD24 # Vector
    m_nDamage = 0xD30 # int32_t
    m_flHeadshotMultiplier = 0xD34 # float
    m_flArmorRatio = 0xD38 # float
    m_flPenetration = 0xD3C # float
    m_flRange = 0xD40 # float
    m_flRangeModifier = 0xD44 # float
    m_flFlinchVelocityModifierLarge = 0xD48 # float
    m_flFlinchVelocityModifierSmall = 0xD4C # float
    m_flRecoveryTimeCrouch = 0xD50 # float
    m_flRecoveryTimeStand = 0xD54 # float
    m_flRecoveryTimeCrouchFinal = 0xD58 # float
    m_flRecoveryTimeStandFinal = 0xD5C # float
    m_nRecoveryTransitionStartBullet = 0xD60 # int32_t
    m_nRecoveryTransitionEndBullet = 0xD64 # int32_t
    m_flThrowVelocity = 0xD68 # float
    m_vSmokeColor = 0xD6C # Vector
    m_szAnimClass = 0xD78 # CUtlString

class CClientAlphaProperty:
    m_nRenderFX = 0x10 # uint8_t
    m_nRenderMode = 0x11 # uint8_t
    m_bAlphaOverride = 0x0 # bitfield:1
    m_bShadowAlphaOverride = 0x0 # bitfield:1
    m_nReserved = 0x0 # bitfield:6
    m_nAlpha = 0x13 # uint8_t
    m_nDesyncOffset = 0x14 # uint16_t
    m_nReserved2 = 0x16 # uint16_t
    m_nDistFadeStart = 0x18 # uint16_t
    m_nDistFadeEnd = 0x1A # uint16_t
    m_flFadeScale = 0x1C # float
    m_flRenderFxStartTime = 0x20 # GameTime_t
    m_flRenderFxDuration = 0x24 # float

class CCollisionProperty:
    m_collisionAttribute = 0x10 # VPhysicsCollisionAttribute_t
    m_vecMins = 0x40 # Vector
    m_vecMaxs = 0x4C # Vector
    m_usSolidFlags = 0x5A # uint8_t
    m_nSolidType = 0x5B # SolidType_t
    m_triggerBloat = 0x5C # uint8_t
    m_nSurroundType = 0x5D # SurroundingBoundsType_t
    m_CollisionGroup = 0x5E # uint8_t
    m_nEnablePhysics = 0x5F # uint8_t
    m_flBoundingRadius = 0x60 # float
    m_vecSpecifiedSurroundingMins = 0x64 # Vector
    m_vecSpecifiedSurroundingMaxs = 0x70 # Vector
    m_vecSurroundingMaxs = 0x7C # Vector
    m_vecSurroundingMins = 0x88 # Vector
    m_vCapsuleCenter1 = 0x94 # Vector
    m_vCapsuleCenter2 = 0xA0 # Vector
    m_flCapsuleRadius = 0xAC # float

class CComicBook:
    m_CoverImage = 0x8 # CPanoramaImageName
    m_XmlFile = 0x18 # CUtlString

class CCompositeMaterialEditorDoc:
    m_nVersion = 0x8 # int32_t
    m_Points = 0x10 # CUtlVector<CompositeMaterialEditorPoint_t>
    m_KVthumbnail = 0x28 # KeyValues3

class CDamageRecord:
    m_PlayerDamager = 0x28 # CHandle<C_CSPlayerPawnBase>
    m_PlayerRecipient = 0x2C # CHandle<C_CSPlayerPawnBase>
    m_hPlayerControllerDamager = 0x30 # CHandle<CCSPlayerController>
    m_hPlayerControllerRecipient = 0x34 # CHandle<CCSPlayerController>
    m_szPlayerDamagerName = 0x38 # CUtlString
    m_szPlayerRecipientName = 0x40 # CUtlString
    m_DamagerXuid = 0x48 # uint64_t
    m_RecipientXuid = 0x50 # uint64_t
    m_iDamage = 0x58 # int32_t
    m_iActualHealthRemoved = 0x5C # int32_t
    m_iNumHits = 0x60 # int32_t
    m_iLastBulletUpdate = 0x64 # int32_t
    m_bIsOtherEnemy = 0x68 # bool
    m_killType = 0x69 # EKillTypes_t

class CDecalInfo:
    m_flAnimationScale = 0x0 # float
    m_flAnimationLifeSpan = 0x4 # float
    m_flPlaceTime = 0x8 # float
    m_flFadeStartTime = 0xC # float
    m_flFadeDuration = 0x10 # float
    m_nVBSlot = 0x14 # int32_t
    m_nBoneIndex = 0x18 # int32_t
    m_vPosition = 0x28 # Vector
    m_flBoundingRadiusSqr = 0x34 # float
    m_pNext = 0x40 # CDecalInfo*
    m_pPrev = 0x48 # CDecalInfo*
    m_nDecalMaterialIndex = 0xA8 # int32_t

class CEconItemAttribute:
    m_iAttributeDefinitionIndex = 0x30 # uint16_t
    m_flValue = 0x34 # float
    m_flInitialValue = 0x38 # float
    m_nRefundableCurrency = 0x3C # int32_t
    m_bSetBonus = 0x40 # bool

class CEffectData:
    m_vOrigin = 0x8 # Vector
    m_vStart = 0x14 # Vector
    m_vNormal = 0x20 # Vector
    m_vAngles = 0x2C # QAngle
    m_hEntity = 0x38 # CEntityHandle
    m_hOtherEntity = 0x3C # CEntityHandle
    m_flScale = 0x40 # float
    m_flMagnitude = 0x44 # float
    m_flRadius = 0x48 # float
    m_nSurfaceProp = 0x4C # CUtlStringToken
    m_nEffectIndex = 0x50 # CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>
    m_nDamageType = 0x58 # uint32_t
    m_nPenetrate = 0x5C # uint8_t
    m_nMaterial = 0x5E # uint16_t
    m_nHitBox = 0x60 # uint16_t
    m_nColor = 0x62 # uint8_t
    m_fFlags = 0x63 # uint8_t
    m_nAttachmentIndex = 0x64 # AttachmentHandle_t
    m_nAttachmentName = 0x68 # CUtlStringToken
    m_iEffectName = 0x6C # uint16_t
    m_nExplosionType = 0x6E # uint8_t

class CEntityIdentity:
    m_nameStringableIndex = 0x14 # int32_t
    m_name = 0x18 # CUtlSymbolLarge
    m_designerName = 0x20 # CUtlSymbolLarge
    m_flags = 0x30 # uint32_t
    m_worldGroupId = 0x38 # WorldGroupId_t
    m_fDataObjectTypes = 0x3C # uint32_t
    m_PathIndex = 0x40 # ChangeAccessorFieldPathIndex_t
    m_pPrev = 0x58 # CEntityIdentity*
    m_pNext = 0x60 # CEntityIdentity*
    m_pPrevByClass = 0x68 # CEntityIdentity*
    m_pNextByClass = 0x70 # CEntityIdentity*

class CEntityInstance:
    m_iszPrivateVScripts = 0x8 # CUtlSymbolLarge
    m_pEntity = 0x10 # CEntityIdentity*
    m_CScriptComponent = 0x28 # CScriptComponent*

class CFireOverlay:
    m_pOwner = 0xD0 # C_FireSmoke*
    m_vBaseColors = 0xD8 # Vector[4]
    m_flScale = 0x108 # float
    m_nGUID = 0x10C # int32_t

class CFlashlightEffect:
    m_bIsOn = 0x10 # bool
    m_bMuzzleFlashEnabled = 0x20 # bool
    m_flMuzzleFlashBrightness = 0x24 # float
    m_quatMuzzleFlashOrientation = 0x30 # Quaternion
    m_vecMuzzleFlashOrigin = 0x40 # Vector
    m_flFov = 0x4C # float
    m_flFarZ = 0x50 # float
    m_flLinearAtten = 0x54 # float
    m_bCastsShadows = 0x58 # bool
    m_flCurrentPullBackDist = 0x5C # float
    m_FlashlightTexture = 0x60 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_MuzzleFlashTexture = 0x68 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_textureName = 0x70 # char[64]

class CFuncWater:
    m_BuoyancyHelper = 0xCC0 # CBuoyancyHelper

class CGameSceneNode:
    m_nodeToWorld = 0x10 # CTransform
    m_pOwner = 0x30 # CEntityInstance*
    m_pParent = 0x38 # CGameSceneNode*
    m_pChild = 0x40 # CGameSceneNode*
    m_pNextSibling = 0x48 # CGameSceneNode*
    m_hParent = 0x70 # CGameSceneNodeHandle
    m_vecOrigin = 0x80 # CNetworkOriginCellCoordQuantizedVector
    m_angRotation = 0xB8 # QAngle
    m_flScale = 0xC4 # float
    m_vecAbsOrigin = 0xC8 # Vector
    m_angAbsRotation = 0xD4 # QAngle
    m_flAbsScale = 0xE0 # float
    m_nParentAttachmentOrBone = 0xE4 # int16_t
    m_bDebugAbsOriginChanges = 0xE6 # bool
    m_bDormant = 0xE7 # bool
    m_bForceParentToBeNetworked = 0xE8 # bool
    m_bDirtyHierarchy = 0x0 # bitfield:1
    m_bDirtyBoneMergeInfo = 0x0 # bitfield:1
    m_bNetworkedPositionChanged = 0x0 # bitfield:1
    m_bNetworkedAnglesChanged = 0x0 # bitfield:1
    m_bNetworkedScaleChanged = 0x0 # bitfield:1
    m_bWillBeCallingPostDataUpdate = 0x0 # bitfield:1
    m_bNotifyBoneTransformsChanged = 0x0 # bitfield:1
    m_bBoneMergeFlex = 0x0 # bitfield:1
    m_nLatchAbsOrigin = 0x0 # bitfield:2
    m_bDirtyBoneMergeBoneToRoot = 0x0 # bitfield:1
    m_nHierarchicalDepth = 0xEB # uint8_t
    m_nHierarchyType = 0xEC # uint8_t
    m_nDoNotSetAnimTimeInInvalidatePhysicsCount = 0xED # uint8_t
    m_name = 0xF0 # CUtlStringToken
    m_hierarchyAttachName = 0x130 # CUtlStringToken
    m_flZOffset = 0x134 # float
    m_vRenderOrigin = 0x138 # Vector

class CGameSceneNodeHandle:
    m_hOwner = 0x8 # CEntityHandle
    m_name = 0xC # CUtlStringToken

class CGlobalLightBase:
    m_bSpotLight = 0x10 # bool
    m_SpotLightOrigin = 0x14 # Vector
    m_SpotLightAngles = 0x20 # QAngle
    m_ShadowDirection = 0x2C # Vector
    m_AmbientDirection = 0x38 # Vector
    m_SpecularDirection = 0x44 # Vector
    m_InspectorSpecularDirection = 0x50 # Vector
    m_flSpecularPower = 0x5C # float
    m_flSpecularIndependence = 0x60 # float
    m_SpecularColor = 0x64 # Color
    m_bStartDisabled = 0x68 # bool
    m_bEnabled = 0x69 # bool
    m_LightColor = 0x6A # Color
    m_AmbientColor1 = 0x6E # Color
    m_AmbientColor2 = 0x72 # Color
    m_AmbientColor3 = 0x76 # Color
    m_flSunDistance = 0x7C # float
    m_flFOV = 0x80 # float
    m_flNearZ = 0x84 # float
    m_flFarZ = 0x88 # float
    m_bEnableShadows = 0x8C # bool
    m_bOldEnableShadows = 0x8D # bool
    m_bBackgroundClearNotRequired = 0x8E # bool
    m_flCloudScale = 0x90 # float
    m_flCloud1Speed = 0x94 # float
    m_flCloud1Direction = 0x98 # float
    m_flCloud2Speed = 0x9C # float
    m_flCloud2Direction = 0xA0 # float
    m_flAmbientScale1 = 0xB0 # float
    m_flAmbientScale2 = 0xB4 # float
    m_flGroundScale = 0xB8 # float
    m_flLightScale = 0xBC # float
    m_flFoWDarkness = 0xC0 # float
    m_bEnableSeparateSkyboxFog = 0xC4 # bool
    m_vFowColor = 0xC8 # Vector
    m_ViewOrigin = 0xD4 # Vector
    m_ViewAngles = 0xE0 # QAngle
    m_flViewFoV = 0xEC # float
    m_WorldPoints = 0xF0 # Vector[8]
    m_vFogOffsetLayer0 = 0x4A8 # Vector2D
    m_vFogOffsetLayer1 = 0x4B0 # Vector2D
    m_hEnvWind = 0x4B8 # CHandle<C_BaseEntity>
    m_hEnvSky = 0x4BC # CHandle<C_BaseEntity>

class CGlowOverlay:
    m_vPos = 0x8 # Vector
    m_bDirectional = 0x14 # bool
    m_vDirection = 0x18 # Vector
    m_bInSky = 0x24 # bool
    m_skyObstructionScale = 0x28 # float
    m_Sprites = 0x30 # CGlowSprite[4]
    m_nSprites = 0xB0 # int32_t
    m_flProxyRadius = 0xB4 # float
    m_flHDRColorScale = 0xB8 # float
    m_flGlowObstructionScale = 0xBC # float
    m_bCacheGlowObstruction = 0xC0 # bool
    m_bCacheSkyObstruction = 0xC1 # bool
    m_bActivated = 0xC2 # int16_t
    m_ListIndex = 0xC4 # uint16_t
    m_queryHandle = 0xC8 # int32_t

class CGlowProperty:
    m_fGlowColor = 0x8 # Vector
    m_iGlowType = 0x30 # int32_t
    m_iGlowTeam = 0x34 # int32_t
    m_nGlowRange = 0x38 # int32_t
    m_nGlowRangeMin = 0x3C # int32_t
    m_glowColorOverride = 0x40 # Color
    m_bFlashing = 0x44 # bool
    m_flGlowTime = 0x48 # float
    m_flGlowStartTime = 0x4C # float
    m_bEligibleForScreenHighlight = 0x50 # bool
    m_bGlowing = 0x51 # bool

class CGlowSprite:
    m_vColor = 0x0 # Vector
    m_flHorzSize = 0xC # float
    m_flVertSize = 0x10 # float
    m_hMaterial = 0x18 # CStrongHandle<InfoForResourceTypeIMaterial2>

class CGrenadeTracer:
    m_flTracerDuration = 0xCE0 # float
    m_nType = 0xCE4 # GrenadeType_t

class CHitboxComponent:
    m_bvDisabledHitGroups = 0x24 # uint32_t[1]

class CInfoDynamicShadowHint:
    m_bDisabled = 0x540 # bool
    m_flRange = 0x544 # float
    m_nImportance = 0x548 # int32_t
    m_nLightChoice = 0x54C # int32_t
    m_hLight = 0x550 # CHandle<C_BaseEntity>

class CInfoDynamicShadowHintBox:
    m_vBoxMins = 0x558 # Vector
    m_vBoxMaxs = 0x564 # Vector

class CInfoOffscreenPanoramaTexture:
    m_bDisabled = 0x540 # bool
    m_nResolutionX = 0x544 # int32_t
    m_nResolutionY = 0x548 # int32_t
    m_szLayoutFileName = 0x550 # CUtlSymbolLarge
    m_RenderAttrName = 0x558 # CUtlSymbolLarge
    m_TargetEntities = 0x560 # C_NetworkUtlVectorBase<CHandle<C_BaseModelEntity>>
    m_nTargetChangeCount = 0x578 # int32_t
    m_vecCSSClasses = 0x580 # C_NetworkUtlVectorBase<CUtlSymbolLarge>
    m_bCheckCSSClasses = 0x6F8 # bool

class CInfoWorldLayer:
    m_pOutputOnEntitiesSpawned = 0x540 # CEntityIOOutput
    m_worldName = 0x568 # CUtlSymbolLarge
    m_layerName = 0x570 # CUtlSymbolLarge
    m_bWorldLayerVisible = 0x578 # bool
    m_bEntitiesSpawned = 0x579 # bool
    m_bCreateAsChildSpawnGroup = 0x57A # bool
    m_hLayerSpawnGroup = 0x57C # uint32_t
    m_bWorldLayerActuallyVisible = 0x580 # bool

class CInterpolatedValue:
    m_flStartTime = 0x0 # float
    m_flEndTime = 0x4 # float
    m_flStartValue = 0x8 # float
    m_flEndValue = 0xC # float
    m_nInterpType = 0x10 # int32_t

class CLightComponent:
    __m_pChainEntity = 0x48 # CNetworkVarChainer
    m_Color = 0x85 # Color
    m_SecondaryColor = 0x89 # Color
    m_flBrightness = 0x90 # float
    m_flBrightnessScale = 0x94 # float
    m_flBrightnessMult = 0x98 # float
    m_flRange = 0x9C # float
    m_flFalloff = 0xA0 # float
    m_flAttenuation0 = 0xA4 # float
    m_flAttenuation1 = 0xA8 # float
    m_flAttenuation2 = 0xAC # float
    m_flTheta = 0xB0 # float
    m_flPhi = 0xB4 # float
    m_hLightCookie = 0xB8 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_nCascades = 0xC0 # int32_t
    m_nCastShadows = 0xC4 # int32_t
    m_nShadowWidth = 0xC8 # int32_t
    m_nShadowHeight = 0xCC # int32_t
    m_bRenderDiffuse = 0xD0 # bool
    m_nRenderSpecular = 0xD4 # int32_t
    m_bRenderTransmissive = 0xD8 # bool
    m_flOrthoLightWidth = 0xDC # float
    m_flOrthoLightHeight = 0xE0 # float
    m_nStyle = 0xE4 # int32_t
    m_Pattern = 0xE8 # CUtlString
    m_nCascadeRenderStaticObjects = 0xF0 # int32_t
    m_flShadowCascadeCrossFade = 0xF4 # float
    m_flShadowCascadeDistanceFade = 0xF8 # float
    m_flShadowCascadeDistance0 = 0xFC # float
    m_flShadowCascadeDistance1 = 0x100 # float
    m_flShadowCascadeDistance2 = 0x104 # float
    m_flShadowCascadeDistance3 = 0x108 # float
    m_nShadowCascadeResolution0 = 0x10C # int32_t
    m_nShadowCascadeResolution1 = 0x110 # int32_t
    m_nShadowCascadeResolution2 = 0x114 # int32_t
    m_nShadowCascadeResolution3 = 0x118 # int32_t
    m_bUsesBakedShadowing = 0x11C # bool
    m_nShadowPriority = 0x120 # int32_t
    m_nBakedShadowIndex = 0x124 # int32_t
    m_bRenderToCubemaps = 0x128 # bool
    m_nDirectLight = 0x12C # int32_t
    m_nIndirectLight = 0x130 # int32_t
    m_flFadeMinDist = 0x134 # float
    m_flFadeMaxDist = 0x138 # float
    m_flShadowFadeMinDist = 0x13C # float
    m_flShadowFadeMaxDist = 0x140 # float
    m_bEnabled = 0x144 # bool
    m_bFlicker = 0x145 # bool
    m_bPrecomputedFieldsValid = 0x146 # bool
    m_vPrecomputedBoundsMins = 0x148 # Vector
    m_vPrecomputedBoundsMaxs = 0x154 # Vector
    m_vPrecomputedOBBOrigin = 0x160 # Vector
    m_vPrecomputedOBBAngles = 0x16C # QAngle
    m_vPrecomputedOBBExtent = 0x178 # Vector
    m_flPrecomputedMaxRange = 0x184 # float
    m_nFogLightingMode = 0x188 # int32_t
    m_flFogContributionStength = 0x18C # float
    m_flNearClipPlane = 0x190 # float
    m_SkyColor = 0x194 # Color
    m_flSkyIntensity = 0x198 # float
    m_SkyAmbientBounce = 0x19C # Color
    m_bUseSecondaryColor = 0x1A0 # bool
    m_bMixedShadows = 0x1A1 # bool
    m_flLightStyleStartTime = 0x1A4 # GameTime_t
    m_flCapsuleLength = 0x1A8 # float
    m_flMinRoughness = 0x1AC # float

class CLogicRelay:
    m_OnTrigger = 0x540 # CEntityIOOutput
    m_OnSpawn = 0x568 # CEntityIOOutput
    m_bDisabled = 0x590 # bool
    m_bWaitForRefire = 0x591 # bool
    m_bTriggerOnce = 0x592 # bool
    m_bFastRetrigger = 0x593 # bool
    m_bPassthoughCaller = 0x594 # bool

class CModelState:
    m_hModel = 0xA0 # CStrongHandle<InfoForResourceTypeCModel>
    m_ModelName = 0xA8 # CUtlSymbolLarge
    m_bClientClothCreationSuppressed = 0xE8 # bool
    m_MeshGroupMask = 0x180 # uint64_t
    m_nIdealMotionType = 0x222 # int8_t
    m_nForceLOD = 0x223 # int8_t
    m_nClothUpdateFlags = 0x224 # int8_t

class CNetworkedSequenceOperation:
    m_hSequence = 0x8 # HSequence
    m_flPrevCycle = 0xC # float
    m_flCycle = 0x10 # float
    m_flWeight = 0x14 # CNetworkedQuantizedFloat
    m_bSequenceChangeNetworked = 0x1C # bool
    m_bDiscontinuity = 0x1D # bool
    m_flPrevCycleFromDiscontinuity = 0x20 # float
    m_flPrevCycleForAnimEventDetection = 0x24 # float

class CPlayer_CameraServices:
    m_vecCsViewPunchAngle = 0x40 # QAngle
    m_nCsViewPunchAngleTick = 0x4C # GameTick_t
    m_flCsViewPunchAngleTickRatio = 0x50 # float
    m_PlayerFog = 0x58 # C_fogplayerparams_t
    m_hColorCorrectionCtrl = 0x98 # CHandle<C_ColorCorrection>
    m_hViewEntity = 0x9C # CHandle<C_BaseEntity>
    m_hTonemapController = 0xA0 # CHandle<C_TonemapController2>
    m_audio = 0xA8 # audioparams_t
    m_PostProcessingVolumes = 0x120 # C_NetworkUtlVectorBase<CHandle<C_PostProcessingVolume>>
    m_flOldPlayerZ = 0x138 # float
    m_flOldPlayerViewOffsetZ = 0x13C # float
    m_CurrentFog = 0x140 # fogparams_t
    m_hOldFogController = 0x1A8 # CHandle<C_FogController>
    m_bOverrideFogColor = 0x1AC # bool[5]
    m_OverrideFogColor = 0x1B1 # Color[5]
    m_bOverrideFogStartEnd = 0x1C5 # bool[5]
    m_fOverrideFogStart = 0x1CC # float[5]
    m_fOverrideFogEnd = 0x1E0 # float[5]
    m_hActivePostProcessingVolume = 0x1F4 # CHandle<C_PostProcessingVolume>
    m_angDemoViewAngles = 0x1F8 # QAngle

class CPlayer_MovementServices:
    m_nImpulse = 0x40 # int32_t
    m_nButtons = 0x48 # CInButtonState
    m_nQueuedButtonDownMask = 0x68 # uint64_t
    m_nQueuedButtonChangeMask = 0x70 # uint64_t
    m_nButtonDoublePressed = 0x78 # uint64_t
    m_pButtonPressedCmdNumber = 0x80 # uint32_t[64]
    m_nLastCommandNumberProcessed = 0x180 # uint32_t
    m_nToggleButtonDownMask = 0x188 # uint64_t
    m_flMaxspeed = 0x190 # float
    m_arrForceSubtickMoveWhen = 0x194 # float[4]
    m_flForwardMove = 0x1A4 # float
    m_flLeftMove = 0x1A8 # float
    m_flUpMove = 0x1AC # float
    m_vecLastMovementImpulses = 0x1B0 # Vector
    m_vecOldViewAngles = 0x1BC # QAngle

class CPlayer_MovementServices_Humanoid:
    m_flStepSoundTime = 0x1D0 # float
    m_flFallVelocity = 0x1D4 # float
    m_bInCrouch = 0x1D8 # bool
    m_nCrouchState = 0x1DC # uint32_t
    m_flCrouchTransitionStartTime = 0x1E0 # GameTime_t
    m_bDucked = 0x1E4 # bool
    m_bDucking = 0x1E5 # bool
    m_bInDuckJump = 0x1E6 # bool
    m_groundNormal = 0x1E8 # Vector
    m_flSurfaceFriction = 0x1F4 # float
    m_surfaceProps = 0x1F8 # CUtlStringToken
    m_nStepside = 0x208 # int32_t

class CPlayer_ObserverServices:
    m_iObserverMode = 0x40 # uint8_t
    m_hObserverTarget = 0x44 # CHandle<C_BaseEntity>
    m_iObserverLastMode = 0x48 # ObserverMode_t
    m_bForcedObserverMode = 0x4C # bool
    m_flObserverChaseDistance = 0x50 # float
    m_flObserverChaseDistanceCalcTime = 0x54 # GameTime_t

class CPlayer_WeaponServices:
    m_bAllowSwitchToNoWeapon = 0x40 # bool
    m_hMyWeapons = 0x48 # C_NetworkUtlVectorBase<CHandle<C_BasePlayerWeapon>>
    m_hActiveWeapon = 0x60 # CHandle<C_BasePlayerWeapon>
    m_hLastWeapon = 0x64 # CHandle<C_BasePlayerWeapon>
    m_iAmmo = 0x68 # uint16_t[32]

class CPointOffScreenIndicatorUi:
    m_bBeenEnabled = 0xF20 # bool
    m_bHide = 0xF21 # bool
    m_flSeenTargetTime = 0xF24 # float
    m_pTargetPanel = 0xF28 # C_PointClientUIWorldPanel*

class CPointTemplate:
    m_iszWorldName = 0x540 # CUtlSymbolLarge
    m_iszSource2EntityLumpName = 0x548 # CUtlSymbolLarge
    m_iszEntityFilterName = 0x550 # CUtlSymbolLarge
    m_flTimeoutInterval = 0x558 # float
    m_bAsynchronouslySpawnEntities = 0x55C # bool
    m_pOutputOnSpawned = 0x560 # CEntityIOOutput
    m_clientOnlyEntityBehavior = 0x588 # PointTemplateClientOnlyEntityBehavior_t
    m_ownerSpawnGroupType = 0x58C # PointTemplateOwnerSpawnGroupType_t
    m_createdSpawnGroupHandles = 0x590 # CUtlVector<uint32_t>
    m_SpawnedEntityHandles = 0x5A8 # CUtlVector<CEntityHandle>
    m_ScriptSpawnCallback = 0x5C0 # HSCRIPT
    m_ScriptCallbackScope = 0x5C8 # HSCRIPT

class CPrecipitationVData:
    m_szParticlePrecipitationEffect = 0x28 # CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    m_flInnerDistance = 0x108 # float
    m_nAttachType = 0x10C # ParticleAttachment_t
    m_bBatchSameVolumeType = 0x110 # bool
    m_nRTEnvCP = 0x114 # int32_t
    m_nRTEnvCPComponent = 0x118 # int32_t
    m_szModifier = 0x120 # CUtlString

class CProjectedTextureBase:
    m_hTargetEntity = 0xC # CHandle<C_BaseEntity>
    m_bState = 0x10 # bool
    m_bAlwaysUpdate = 0x11 # bool
    m_flLightFOV = 0x14 # float
    m_bEnableShadows = 0x18 # bool
    m_bSimpleProjection = 0x19 # bool
    m_bLightOnlyTarget = 0x1A # bool
    m_bLightWorld = 0x1B # bool
    m_bCameraSpace = 0x1C # bool
    m_flBrightnessScale = 0x20 # float
    m_LightColor = 0x24 # Color
    m_flIntensity = 0x28 # float
    m_flLinearAttenuation = 0x2C # float
    m_flQuadraticAttenuation = 0x30 # float
    m_bVolumetric = 0x34 # bool
    m_flVolumetricIntensity = 0x38 # float
    m_flNoiseStrength = 0x3C # float
    m_flFlashlightTime = 0x40 # float
    m_nNumPlanes = 0x44 # uint32_t
    m_flPlaneOffset = 0x48 # float
    m_flColorTransitionTime = 0x4C # float
    m_flAmbient = 0x50 # float
    m_SpotlightTextureName = 0x54 # char[512]
    m_nSpotlightTextureFrame = 0x254 # int32_t
    m_nShadowQuality = 0x258 # uint32_t
    m_flNearZ = 0x25C # float
    m_flFarZ = 0x260 # float
    m_flProjectionSize = 0x264 # float
    m_flRotation = 0x268 # float
    m_bFlipHorizontal = 0x26C # bool

class CRenderComponent:
    __m_pChainEntity = 0x10 # CNetworkVarChainer
    m_bIsRenderingWithViewModels = 0x50 # bool
    m_nSplitscreenFlags = 0x54 # uint32_t
    m_bEnableRendering = 0x60 # bool
    m_bInterpolationReadyToDraw = 0xB0 # bool

class CSMatchStats_t:
    m_iEnemy5Ks = 0x68 # int32_t
    m_iEnemy4Ks = 0x6C # int32_t
    m_iEnemy3Ks = 0x70 # int32_t

class CSPerRoundStats_t:
    m_iKills = 0x30 # int32_t
    m_iDeaths = 0x34 # int32_t
    m_iAssists = 0x38 # int32_t
    m_iDamage = 0x3C # int32_t
    m_iEquipmentValue = 0x40 # int32_t
    m_iMoneySaved = 0x44 # int32_t
    m_iKillReward = 0x48 # int32_t
    m_iLiveTime = 0x4C # int32_t
    m_iHeadShotKills = 0x50 # int32_t
    m_iObjective = 0x54 # int32_t
    m_iCashEarned = 0x58 # int32_t
    m_iUtilityDamage = 0x5C # int32_t
    m_iEnemiesFlashed = 0x60 # int32_t

class CScriptComponent:
    m_scriptClassName = 0x30 # CUtlSymbolLarge

class CSkeletonInstance:
    m_modelState = 0x160 # CModelState
    m_bIsAnimationEnabled = 0x390 # bool
    m_bUseParentRenderBounds = 0x391 # bool
    m_bDisableSolidCollisionsForHierarchy = 0x392 # bool
    m_bDirtyMotionType = 0x0 # bitfield:1
    m_bIsGeneratingLatchedParentSpaceState = 0x0 # bitfield:1
    m_materialGroup = 0x394 # CUtlStringToken
    m_nHitboxSet = 0x398 # uint8_t

class CSkyboxReference:
    m_worldGroupId = 0x540 # WorldGroupId_t
    m_hSkyCamera = 0x544 # CHandle<C_SkyCamera>

class CTimeline:
    m_flValues = 0x10 # float[64]
    m_nValueCounts = 0x110 # int32_t[64]
    m_nBucketCount = 0x210 # int32_t
    m_flInterval = 0x214 # float
    m_flFinalValue = 0x218 # float
    m_nCompressionType = 0x21C # TimelineCompression_t
    m_bStopped = 0x220 # bool

class C_AttributeContainer:
    m_Item = 0x50 # C_EconItemView
    m_iExternalItemProviderRegisteredToken = 0x498 # int32_t
    m_ullRegisteredAsItemID = 0x4A0 # uint64_t

class C_BarnLight:
    m_bEnabled = 0xCC0 # bool
    m_nColorMode = 0xCC4 # int32_t
    m_Color = 0xCC8 # Color
    m_flColorTemperature = 0xCCC # float
    m_flBrightness = 0xCD0 # float
    m_flBrightnessScale = 0xCD4 # float
    m_nDirectLight = 0xCD8 # int32_t
    m_nBakedShadowIndex = 0xCDC # int32_t
    m_nLuminaireShape = 0xCE0 # int32_t
    m_flLuminaireSize = 0xCE4 # float
    m_flLuminaireAnisotropy = 0xCE8 # float
    m_LightStyleString = 0xCF0 # CUtlString
    m_flLightStyleStartTime = 0xCF8 # GameTime_t
    m_QueuedLightStyleStrings = 0xD00 # C_NetworkUtlVectorBase<CUtlString>
    m_LightStyleEvents = 0xD18 # C_NetworkUtlVectorBase<CUtlString>
    m_LightStyleTargets = 0xD30 # C_NetworkUtlVectorBase<CHandle<C_BaseModelEntity>>
    m_StyleEvent = 0xD48 # CEntityIOOutput[4]
    m_hLightCookie = 0xDE8 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_flShape = 0xDF0 # float
    m_flSoftX = 0xDF4 # float
    m_flSoftY = 0xDF8 # float
    m_flSkirt = 0xDFC # float
    m_flSkirtNear = 0xE00 # float
    m_vSizeParams = 0xE04 # Vector
    m_flRange = 0xE10 # float
    m_vShear = 0xE14 # Vector
    m_nBakeSpecularToCubemaps = 0xE20 # int32_t
    m_vBakeSpecularToCubemapsSize = 0xE24 # Vector
    m_nCastShadows = 0xE30 # int32_t
    m_nShadowMapSize = 0xE34 # int32_t
    m_nShadowPriority = 0xE38 # int32_t
    m_bContactShadow = 0xE3C # bool
    m_nBounceLight = 0xE40 # int32_t
    m_flBounceScale = 0xE44 # float
    m_flMinRoughness = 0xE48 # float
    m_vAlternateColor = 0xE4C # Vector
    m_fAlternateColorBrightness = 0xE58 # float
    m_nFog = 0xE5C # int32_t
    m_flFogStrength = 0xE60 # float
    m_nFogShadows = 0xE64 # int32_t
    m_flFogScale = 0xE68 # float
    m_flFadeSizeStart = 0xE6C # float
    m_flFadeSizeEnd = 0xE70 # float
    m_flShadowFadeSizeStart = 0xE74 # float
    m_flShadowFadeSizeEnd = 0xE78 # float
    m_bPrecomputedFieldsValid = 0xE7C # bool
    m_vPrecomputedBoundsMins = 0xE80 # Vector
    m_vPrecomputedBoundsMaxs = 0xE8C # Vector
    m_vPrecomputedOBBOrigin = 0xE98 # Vector
    m_vPrecomputedOBBAngles = 0xEA4 # QAngle
    m_vPrecomputedOBBExtent = 0xEB0 # Vector

class C_BaseButton:
    m_glowEntity = 0xCC0 # CHandle<C_BaseModelEntity>
    m_usable = 0xCC4 # bool
    m_szDisplayText = 0xCC8 # CUtlSymbolLarge

class C_BaseCSGrenade:
    m_bClientPredictDelete = 0x19F0 # bool
    m_bRedraw = 0x19F1 # bool
    m_bIsHeldByPlayer = 0x19F2 # bool
    m_bPinPulled = 0x19F3 # bool
    m_bJumpThrow = 0x19F4 # bool
    m_eThrowStatus = 0x19F8 # EGrenadeThrowState
    m_fThrowTime = 0x19FC # GameTime_t
    m_flThrowStrength = 0x1A00 # float
    m_flThrowStrengthApproach = 0x1A04 # float
    m_fDropTime = 0x1A08 # GameTime_t

class C_BaseCSGrenadeProjectile:
    m_vInitialPosition = 0x1068 # Vector
    m_vInitialVelocity = 0x1074 # Vector
    m_nBounces = 0x1080 # int32_t
    m_nExplodeEffectIndex = 0x1088 # CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    m_nExplodeEffectTickBegin = 0x1090 # int32_t
    m_vecExplodeEffectOrigin = 0x1094 # Vector
    m_flSpawnTime = 0x10A0 # GameTime_t
    vecLastTrailLinePos = 0x10A4 # Vector
    flNextTrailLineTime = 0x10B0 # GameTime_t
    m_bExplodeEffectBegan = 0x10B4 # bool
    m_bCanCreateGrenadeTrail = 0x10B5 # bool
    m_nSnapshotTrajectoryEffectIndex = 0x10B8 # ParticleIndex_t
    m_hSnapshotTrajectoryParticleSnapshot = 0x10C0 # CStrongHandle<InfoForResourceTypeIParticleSnapshot>
    m_arrTrajectoryTrailPoints = 0x10C8 # CUtlVector<Vector>
    m_arrTrajectoryTrailPointCreationTimes = 0x10E0 # CUtlVector<float>
    m_flTrajectoryTrailEffectCreationTime = 0x10F8 # float

class C_BaseClientUIEntity:
    m_bEnabled = 0xCC8 # bool
    m_DialogXMLName = 0xCD0 # CUtlSymbolLarge
    m_PanelClassName = 0xCD8 # CUtlSymbolLarge
    m_PanelID = 0xCE0 # CUtlSymbolLarge

class C_BaseCombatCharacter:
    m_hMyWearables = 0x1018 # C_NetworkUtlVectorBase<CHandle<C_EconWearable>>
    m_bloodColor = 0x1030 # int32_t
    m_leftFootAttachment = 0x1034 # AttachmentHandle_t
    m_rightFootAttachment = 0x1035 # AttachmentHandle_t
    m_nWaterWakeMode = 0x1038 # C_BaseCombatCharacter::WaterWakeMode_t
    m_flWaterWorldZ = 0x103C # float
    m_flWaterNextTraceTime = 0x1040 # float
    m_flFieldOfView = 0x1044 # float

class C_BaseDoor:
    m_bIsUsable = 0xCC0 # bool

class C_BaseEntity:
    m_CBodyComponent = 0x30 # CBodyComponent*
    m_NetworkTransmitComponent = 0x38 # CNetworkTransmitComponent
    m_nLastThinkTick = 0x308 # GameTick_t
    m_pGameSceneNode = 0x310 # CGameSceneNode*
    m_pRenderComponent = 0x318 # CRenderComponent*
    m_pCollision = 0x320 # CCollisionProperty*
    m_iMaxHealth = 0x328 # int32_t
    m_iHealth = 0x32C # int32_t
    m_lifeState = 0x330 # uint8_t
    m_bTakesDamage = 0x331 # bool
    m_nTakeDamageFlags = 0x334 # TakeDamageFlags_t
    m_ubInterpolationFrame = 0x338 # uint8_t
    m_hSceneObjectController = 0x33C # CHandle<C_BaseEntity>
    m_nNoInterpolationTick = 0x340 # int32_t
    m_nVisibilityNoInterpolationTick = 0x344 # int32_t
    m_flProxyRandomValue = 0x348 # float
    m_iEFlags = 0x34C # int32_t
    m_nWaterType = 0x350 # uint8_t
    m_bInterpolateEvenWithNoModel = 0x351 # bool
    m_bPredictionEligible = 0x352 # bool
    m_bApplyLayerMatchIDToModel = 0x353 # bool
    m_tokLayerMatchID = 0x354 # CUtlStringToken
    m_nSubclassID = 0x358 # CUtlStringToken
    m_nSimulationTick = 0x368 # int32_t
    m_iCurrentThinkContext = 0x36C # int32_t
    m_aThinkFunctions = 0x370 # CUtlVector<thinkfunc_t>
    m_flAnimTime = 0x388 # float
    m_flSimulationTime = 0x38C # float
    m_nSceneObjectOverrideFlags = 0x390 # uint8_t
    m_bHasSuccessfullyInterpolated = 0x391 # bool
    m_bHasAddedVarsToInterpolation = 0x392 # bool
    m_bRenderEvenWhenNotSuccessfullyInterpolated = 0x393 # bool
    m_nInterpolationLatchDirtyFlags = 0x394 # int32_t[2]
    m_ListEntry = 0x39C # uint16_t[11]
    m_flCreateTime = 0x3B4 # GameTime_t
    m_flSpeed = 0x3B8 # float
    m_EntClientFlags = 0x3BC # uint16_t
    m_bClientSideRagdoll = 0x3BE # bool
    m_iTeamNum = 0x3BF # uint8_t
    m_spawnflags = 0x3C0 # uint32_t
    m_nNextThinkTick = 0x3C4 # GameTick_t
    m_fFlags = 0x3C8 # uint32_t
    m_vecAbsVelocity = 0x3CC # Vector
    m_vecVelocity = 0x3D8 # CNetworkVelocityVector
    m_vecBaseVelocity = 0x408 # Vector
    m_hEffectEntity = 0x414 # CHandle<C_BaseEntity>
    m_hOwnerEntity = 0x418 # CHandle<C_BaseEntity>
    m_MoveCollide = 0x41C # MoveCollide_t
    m_MoveType = 0x41D # MoveType_t
    m_flWaterLevel = 0x420 # float
    m_fEffects = 0x424 # uint32_t
    m_hGroundEntity = 0x428 # CHandle<C_BaseEntity>
    m_flFriction = 0x42C # float
    m_flElasticity = 0x430 # float
    m_flGravityScale = 0x434 # float
    m_flTimeScale = 0x438 # float
    m_bSimulatedEveryTick = 0x43C # bool
    m_bAnimatedEveryTick = 0x43D # bool
    m_flNavIgnoreUntilTime = 0x440 # GameTime_t
    m_hThink = 0x444 # uint16_t
    m_fBBoxVisFlags = 0x450 # uint8_t
    m_bPredictable = 0x451 # bool
    m_bRenderWithViewModels = 0x452 # bool
    m_nSplitUserPlayerPredictionSlot = 0x454 # CSplitScreenSlot
    m_nFirstPredictableCommand = 0x458 # int32_t
    m_nLastPredictableCommand = 0x45C # int32_t
    m_hOldMoveParent = 0x460 # CHandle<C_BaseEntity>
    m_Particles = 0x468 # CParticleProperty
    m_vecPredictedScriptFloats = 0x490 # CUtlVector<float>
    m_vecPredictedScriptFloatIDs = 0x4A8 # CUtlVector<int32_t>
    m_nNextScriptVarRecordID = 0x4D8 # int32_t
    m_vecAngVelocity = 0x4E8 # QAngle
    m_DataChangeEventRef = 0x4F4 # int32_t
    m_dependencies = 0x4F8 # CUtlVector<CEntityHandle>
    m_nCreationTick = 0x510 # int32_t
    m_bAnimTimeChanged = 0x529 # bool
    m_bSimulationTimeChanged = 0x52A # bool
    m_sUniqueHammerID = 0x538 # CUtlString

class C_BaseFire:
    m_flScale = 0x540 # float
    m_flStartScale = 0x544 # float
    m_flScaleTime = 0x548 # float
    m_nFlags = 0x54C # uint32_t

class C_BaseFlex:
    m_flexWeight = 0xE90 # C_NetworkUtlVectorBase<float>
    m_vLookTargetPosition = 0xEA8 # Vector
    m_blinktoggle = 0xEC0 # bool
    m_nLastFlexUpdateFrameCount = 0xF20 # int32_t
    m_CachedViewTarget = 0xF24 # Vector
    m_nNextSceneEventId = 0xF30 # uint32_t
    m_iBlink = 0xF34 # int32_t
    m_blinktime = 0xF38 # float
    m_prevblinktoggle = 0xF3C # bool
    m_iJawOpen = 0xF40 # int32_t
    m_flJawOpenAmount = 0xF44 # float
    m_flBlinkAmount = 0xF48 # float
    m_iMouthAttachment = 0xF4C # AttachmentHandle_t
    m_iEyeAttachment = 0xF4D # AttachmentHandle_t
    m_bResetFlexWeightsOnModelChange = 0xF4E # bool
    m_nEyeOcclusionRendererBone = 0xF68 # int32_t
    m_mEyeOcclusionRendererCameraToBoneTransform = 0xF6C # matrix3x4_t
    m_vEyeOcclusionRendererHalfExtent = 0xF9C # Vector
    m_PhonemeClasses = 0xFB8 # C_BaseFlex::Emphasized_Phoneme[3]

class C_BaseFlex_Emphasized_Phoneme:
    m_sClassName = 0x0 # CUtlString
    m_flAmount = 0x18 # float
    m_bRequired = 0x1C # bool
    m_bBasechecked = 0x1D # bool
    m_bValid = 0x1E # bool

class C_BaseGrenade:
    m_bHasWarnedAI = 0x1018 # bool
    m_bIsSmokeGrenade = 0x1019 # bool
    m_bIsLive = 0x101A # bool
    m_DmgRadius = 0x101C # float
    m_flDetonateTime = 0x1020 # GameTime_t
    m_flWarnAITime = 0x1024 # float
    m_flDamage = 0x1028 # float
    m_iszBounceSound = 0x1030 # CUtlSymbolLarge
    m_ExplosionSound = 0x1038 # CUtlString
    m_hThrower = 0x1044 # CHandle<C_CSPlayerPawn>
    m_flNextAttack = 0x105C # GameTime_t
    m_hOriginalThrower = 0x1060 # CHandle<C_CSPlayerPawn>

class C_BaseModelEntity:
    m_CRenderComponent = 0xA10 # CRenderComponent*
    m_CHitboxComponent = 0xA18 # CHitboxComponent
    m_bInitModelEffects = 0xA60 # bool
    m_bIsStaticProp = 0xA61 # bool
    m_nLastAddDecal = 0xA64 # int32_t
    m_nDecalsAdded = 0xA68 # int32_t
    m_iOldHealth = 0xA6C # int32_t
    m_nRenderMode = 0xA70 # RenderMode_t
    m_nRenderFX = 0xA71 # RenderFx_t
    m_bAllowFadeInView = 0xA72 # bool
    m_clrRender = 0xA73 # Color
    m_vecRenderAttributes = 0xA78 # C_UtlVectorEmbeddedNetworkVar<EntityRenderAttribute_t>
    m_bRenderToCubemaps = 0xAE0 # bool
    m_Collision = 0xAE8 # CCollisionProperty
    m_Glow = 0xB98 # CGlowProperty
    m_flGlowBackfaceMult = 0xBF0 # float
    m_fadeMinDist = 0xBF4 # float
    m_fadeMaxDist = 0xBF8 # float
    m_flFadeScale = 0xBFC # float
    m_flShadowStrength = 0xC00 # float
    m_nObjectCulling = 0xC04 # uint8_t
    m_nAddDecal = 0xC08 # int32_t
    m_vDecalPosition = 0xC0C # Vector
    m_vDecalForwardAxis = 0xC18 # Vector
    m_flDecalHealBloodRate = 0xC24 # float
    m_flDecalHealHeightRate = 0xC28 # float
    m_ConfigEntitiesToPropagateMaterialDecalsTo = 0xC30 # C_NetworkUtlVectorBase<CHandle<C_BaseModelEntity>>
    m_vecViewOffset = 0xC48 # CNetworkViewOffsetVector
    m_pClientAlphaProperty = 0xC78 # CClientAlphaProperty*
    m_ClientOverrideTint = 0xC80 # Color
    m_bUseClientOverrideTint = 0xC84 # bool

class C_BasePlayerPawn:
    m_pWeaponServices = 0x10A8 # CPlayer_WeaponServices*
    m_pItemServices = 0x10B0 # CPlayer_ItemServices*
    m_pAutoaimServices = 0x10B8 # CPlayer_AutoaimServices*
    m_pObserverServices = 0x10C0 # CPlayer_ObserverServices*
    m_pWaterServices = 0x10C8 # CPlayer_WaterServices*
    m_pUseServices = 0x10D0 # CPlayer_UseServices*
    m_pFlashlightServices = 0x10D8 # CPlayer_FlashlightServices*
    m_pCameraServices = 0x10E0 # CPlayer_CameraServices*
    m_pMovementServices = 0x10E8 # CPlayer_MovementServices*
    m_ServerViewAngleChanges = 0x10F8 # C_UtlVectorEmbeddedNetworkVar<ViewAngleServerChange_t>
    m_nHighestConsumedServerViewAngleChangeIndex = 0x1148 # uint32_t
    v_angle = 0x114C # QAngle
    v_anglePrevious = 0x1158 # QAngle
    m_iHideHUD = 0x1164 # uint32_t
    m_skybox3d = 0x1168 # sky3dparams_t
    m_flDeathTime = 0x11F8 # GameTime_t
    m_vecPredictionError = 0x11FC # Vector
    m_flPredictionErrorTime = 0x1208 # GameTime_t
    m_vecLastCameraSetupLocalOrigin = 0x120C # Vector
    m_flLastCameraSetupTime = 0x1218 # GameTime_t
    m_flFOVSensitivityAdjust = 0x121C # float
    m_flMouseSensitivity = 0x1220 # float
    m_vOldOrigin = 0x1224 # Vector
    m_flOldSimulationTime = 0x1230 # float
    m_nLastExecutedCommandNumber = 0x1234 # int32_t
    m_nLastExecutedCommandTick = 0x1238 # int32_t
    m_hController = 0x123C # CHandle<CBasePlayerController>
    m_bIsSwappingToPredictableController = 0x1240 # bool

class C_BasePlayerWeapon:
    m_nNextPrimaryAttackTick = 0x1560 # GameTick_t
    m_flNextPrimaryAttackTickRatio = 0x1564 # float
    m_nNextSecondaryAttackTick = 0x1568 # GameTick_t
    m_flNextSecondaryAttackTickRatio = 0x156C # float
    m_iClip1 = 0x1570 # int32_t
    m_iClip2 = 0x1574 # int32_t
    m_pReserveAmmo = 0x1578 # int32_t[2]

class C_BasePropDoor:
    m_eDoorState = 0x10F8 # DoorState_t
    m_modelChanged = 0x10FC # bool
    m_bLocked = 0x10FD # bool
    m_closedPosition = 0x1100 # Vector
    m_closedAngles = 0x110C # QAngle
    m_hMaster = 0x1118 # CHandle<C_BasePropDoor>
    m_vWhereToSetLightingOrigin = 0x111C # Vector

class C_BaseTrigger:
    m_bDisabled = 0xCC0 # bool
    m_bClientSidePredicted = 0xCC1 # bool

class C_BaseViewModel:
    m_vecLastFacing = 0xE88 # Vector
    m_nViewModelIndex = 0xE94 # uint32_t
    m_nAnimationParity = 0xE98 # uint32_t
    m_flAnimationStartTime = 0xE9C # float
    m_hWeapon = 0xEA0 # CHandle<C_BasePlayerWeapon>
    m_sVMName = 0xEA8 # CUtlSymbolLarge
    m_sAnimationPrefix = 0xEB0 # CUtlSymbolLarge
    m_hWeaponModel = 0xEB8 # CHandle<C_ViewmodelWeapon>
    m_iCameraAttachment = 0xEBC # AttachmentHandle_t
    m_vecLastCameraAngles = 0xEC0 # QAngle
    m_previousElapsedDuration = 0xECC # float
    m_previousCycle = 0xED0 # float
    m_nOldAnimationParity = 0xED4 # int32_t
    m_hOldLayerSequence = 0xED8 # HSequence
    m_oldLayer = 0xEDC # int32_t
    m_oldLayerStartTime = 0xEE0 # float
    m_hControlPanel = 0xEE4 # CHandle<C_BaseEntity>

class C_Beam:
    m_flFrameRate = 0xCC0 # float
    m_flHDRColorScale = 0xCC4 # float
    m_flFireTime = 0xCC8 # GameTime_t
    m_flDamage = 0xCCC # float
    m_nNumBeamEnts = 0xCD0 # uint8_t
    m_queryHandleHalo = 0xCD4 # int32_t
    m_hBaseMaterial = 0xCF8 # CStrongHandle<InfoForResourceTypeIMaterial2>
    m_nHaloIndex = 0xD00 # CStrongHandle<InfoForResourceTypeIMaterial2>
    m_nBeamType = 0xD08 # BeamType_t
    m_nBeamFlags = 0xD0C # uint32_t
    m_hAttachEntity = 0xD10 # CHandle<C_BaseEntity>[10]
    m_nAttachIndex = 0xD38 # AttachmentHandle_t[10]
    m_fWidth = 0xD44 # float
    m_fEndWidth = 0xD48 # float
    m_fFadeLength = 0xD4C # float
    m_fHaloScale = 0xD50 # float
    m_fAmplitude = 0xD54 # float
    m_fStartFrame = 0xD58 # float
    m_fSpeed = 0xD5C # float
    m_flFrame = 0xD60 # float
    m_nClipStyle = 0xD64 # BeamClipStyle_t
    m_bTurnedOff = 0xD68 # bool
    m_vecEndPos = 0xD6C # Vector
    m_hEndEntity = 0xD78 # CHandle<C_BaseEntity>

class C_BreakableProp:
    m_OnBreak = 0xEC8 # CEntityIOOutput
    m_OnHealthChanged = 0xEF0 # CEntityOutputTemplate<float>
    m_OnTakeDamage = 0xF18 # CEntityIOOutput
    m_impactEnergyScale = 0xF40 # float
    m_iMinHealthDmg = 0xF44 # int32_t
    m_flPressureDelay = 0xF48 # float
    m_hBreaker = 0xF4C # CHandle<C_BaseEntity>
    m_PerformanceMode = 0xF50 # PerformanceMode_t
    m_flDmgModBullet = 0xF54 # float
    m_flDmgModClub = 0xF58 # float
    m_flDmgModExplosive = 0xF5C # float
    m_flDmgModFire = 0xF60 # float
    m_iszPhysicsDamageTableName = 0xF68 # CUtlSymbolLarge
    m_iszBasePropData = 0xF70 # CUtlSymbolLarge
    m_iInteractions = 0xF78 # int32_t
    m_flPreventDamageBeforeTime = 0xF7C # GameTime_t
    m_bHasBreakPiecesOrCommands = 0xF80 # bool
    m_explodeDamage = 0xF84 # float
    m_explodeRadius = 0xF88 # float
    m_explosionDelay = 0xF90 # float
    m_explosionBuildupSound = 0xF98 # CUtlSymbolLarge
    m_explosionCustomEffect = 0xFA0 # CUtlSymbolLarge
    m_explosionCustomSound = 0xFA8 # CUtlSymbolLarge
    m_explosionModifier = 0xFB0 # CUtlSymbolLarge
    m_hPhysicsAttacker = 0xFB8 # CHandle<C_BasePlayerPawn>
    m_flLastPhysicsInfluenceTime = 0xFBC # GameTime_t
    m_flDefaultFadeScale = 0xFC0 # float
    m_hLastAttacker = 0xFC4 # CHandle<C_BaseEntity>
    m_hFlareEnt = 0xFC8 # CHandle<C_BaseEntity>
    m_noGhostCollision = 0xFCC # bool

class C_BulletHitModel:
    m_matLocal = 0xE80 # matrix3x4_t
    m_iBoneIndex = 0xEB0 # int32_t
    m_hPlayerParent = 0xEB4 # CHandle<C_BaseEntity>
    m_bIsHit = 0xEB8 # bool
    m_flTimeCreated = 0xEBC # float
    m_vecStartPos = 0xEC0 # Vector

class C_C4:
    m_szScreenText = 0x19F0 # char[32]
    m_activeLightParticleIndex = 0x1A10 # ParticleIndex_t
    m_eActiveLightEffect = 0x1A14 # C4LightEffect_t
    m_bStartedArming = 0x1A18 # bool
    m_fArmedTime = 0x1A1C # GameTime_t
    m_bBombPlacedAnimation = 0x1A20 # bool
    m_bIsPlantingViaUse = 0x1A21 # bool
    m_entitySpottedState = 0x1A28 # EntitySpottedState_t
    m_nSpotRules = 0x1A40 # int32_t
    m_bPlayedArmingBeeps = 0x1A44 # bool[7]
    m_bBombPlanted = 0x1A4B # bool
    m_bDroppedFromDeath = 0x1A4C # bool

class C_CSGOViewModel:
    m_bShouldIgnoreOffsetAndAccuracy = 0xF10 # bool
    m_nWeaponParity = 0xF14 # uint32_t
    m_nOldWeaponParity = 0xF18 # uint32_t
    m_nLastKnownAssociatedWeaponEntIndex = 0xF1C # CEntityIndex
    m_bNeedToQueueHighResComposite = 0xF20 # bool
    m_vLoweredWeaponOffset = 0xF64 # QAngle

class C_CSGO_MapPreviewCameraPath:
    m_flZFar = 0x540 # float
    m_flZNear = 0x544 # float
    m_bLoop = 0x548 # bool
    m_bVerticalFOV = 0x549 # bool
    m_bConstantSpeed = 0x54A # bool
    m_flDuration = 0x54C # float
    m_flPathLength = 0x590 # float
    m_flPathDuration = 0x594 # float

class C_CSGO_MapPreviewCameraPathNode:
    m_szParentPathUniqueID = 0x540 # CUtlSymbolLarge
    m_nPathIndex = 0x548 # int32_t
    m_vInTangentLocal = 0x54C # Vector
    m_vOutTangentLocal = 0x558 # Vector
    m_flFOV = 0x564 # float
    m_flSpeed = 0x568 # float
    m_flEaseIn = 0x56C # float
    m_flEaseOut = 0x570 # float
    m_vInTangentWorld = 0x574 # Vector
    m_vOutTangentWorld = 0x580 # Vector

class C_CSGO_PreviewModel:
    m_animgraph = 0x1018 # CUtlString
    m_animgraphCharacterModeString = 0x1020 # CUtlString
    m_defaultAnim = 0x1028 # CUtlString
    m_nDefaultAnimLoopMode = 0x1030 # AnimLoopMode_t
    m_flInitialModelScale = 0x1034 # float

class C_CSGO_PreviewPlayer:
    m_animgraph = 0x22E8 # CUtlString
    m_animgraphCharacterModeString = 0x22F0 # CUtlString
    m_flInitialModelScale = 0x22F8 # float

class C_CSGO_TeamPreviewCamera:
    m_nVariant = 0x5A0 # int32_t
    m_bDofEnabled = 0x5A4 # bool
    m_flDofNearBlurry = 0x5A8 # float
    m_flDofNearCrisp = 0x5AC # float
    m_flDofFarCrisp = 0x5B0 # float
    m_flDofFarBlurry = 0x5B4 # float
    m_flDofTiltToGround = 0x5B8 # float

class C_CSGO_TeamPreviewCharacterPosition:
    m_nVariant = 0x540 # int32_t
    m_nRandom = 0x544 # int32_t
    m_nOrdinal = 0x548 # int32_t
    m_sWeaponName = 0x550 # CUtlString
    m_xuid = 0x558 # uint64_t
    m_agentItem = 0x560 # C_EconItemView
    m_glovesItem = 0x9A8 # C_EconItemView
    m_weaponItem = 0xDF0 # C_EconItemView

class C_CSGameRules:
    __m_pChainEntity = 0x8 # CNetworkVarChainer
    m_bFreezePeriod = 0x30 # bool
    m_bWarmupPeriod = 0x31 # bool
    m_fWarmupPeriodEnd = 0x34 # GameTime_t
    m_fWarmupPeriodStart = 0x38 # GameTime_t
    m_nTotalPausedTicks = 0x3C # int32_t
    m_nPauseStartTick = 0x40 # int32_t
    m_bServerPaused = 0x44 # bool
    m_bGamePaused = 0x45 # bool
    m_bTerroristTimeOutActive = 0x46 # bool
    m_bCTTimeOutActive = 0x47 # bool
    m_flTerroristTimeOutRemaining = 0x48 # float
    m_flCTTimeOutRemaining = 0x4C # float
    m_nTerroristTimeOuts = 0x50 # int32_t
    m_nCTTimeOuts = 0x54 # int32_t
    m_bTechnicalTimeOut = 0x58 # bool
    m_bMatchWaitingForResume = 0x59 # bool
    m_iRoundTime = 0x5C # int32_t
    m_fMatchStartTime = 0x60 # float
    m_fRoundStartTime = 0x64 # GameTime_t
    m_flRestartRoundTime = 0x68 # GameTime_t
    m_bGameRestart = 0x6C # bool
    m_flGameStartTime = 0x70 # float
    m_timeUntilNextPhaseStarts = 0x74 # float
    m_gamePhase = 0x78 # int32_t
    m_totalRoundsPlayed = 0x7C # int32_t
    m_nRoundsPlayedThisPhase = 0x80 # int32_t
    m_nOvertimePlaying = 0x84 # int32_t
    m_iHostagesRemaining = 0x88 # int32_t
    m_bAnyHostageReached = 0x8C # bool
    m_bMapHasBombTarget = 0x8D # bool
    m_bMapHasRescueZone = 0x8E # bool
    m_bMapHasBuyZone = 0x8F # bool
    m_bIsQueuedMatchmaking = 0x90 # bool
    m_nQueuedMatchmakingMode = 0x94 # int32_t
    m_bIsValveDS = 0x98 # bool
    m_bLogoMap = 0x99 # bool
    m_bPlayAllStepSoundsOnServer = 0x9A # bool
    m_iSpectatorSlotCount = 0x9C # int32_t
    m_MatchDevice = 0xA0 # int32_t
    m_bHasMatchStarted = 0xA4 # bool
    m_nNextMapInMapgroup = 0xA8 # int32_t
    m_szTournamentEventName = 0xAC # char[512]
    m_szTournamentEventStage = 0x2AC # char[512]
    m_szMatchStatTxt = 0x4AC # char[512]
    m_szTournamentPredictionsTxt = 0x6AC # char[512]
    m_nTournamentPredictionsPct = 0x8AC # int32_t
    m_flCMMItemDropRevealStartTime = 0x8B0 # GameTime_t
    m_flCMMItemDropRevealEndTime = 0x8B4 # GameTime_t
    m_bIsDroppingItems = 0x8B8 # bool
    m_bIsQuestEligible = 0x8B9 # bool
    m_bIsHltvActive = 0x8BA # bool
    m_nGuardianModeWaveNumber = 0x8BC # int32_t
    m_nGuardianModeSpecialKillsRemaining = 0x8C0 # int32_t
    m_nGuardianModeSpecialWeaponNeeded = 0x8C4 # int32_t
    m_nGuardianGrenadesToGiveBots = 0x8C8 # int32_t
    m_nNumHeaviesToSpawn = 0x8CC # int32_t
    m_numGlobalGiftsGiven = 0x8D0 # uint32_t
    m_numGlobalGifters = 0x8D4 # uint32_t
    m_numGlobalGiftsPeriodSeconds = 0x8D8 # uint32_t
    m_arrFeaturedGiftersAccounts = 0x8DC # uint32_t[4]
    m_arrFeaturedGiftersGifts = 0x8EC # uint32_t[4]
    m_arrProhibitedItemIndices = 0x8FC # uint16_t[100]
    m_arrTournamentActiveCasterAccounts = 0x9C4 # uint32_t[4]
    m_numBestOfMaps = 0x9D4 # int32_t
    m_nHalloweenMaskListSeed = 0x9D8 # int32_t
    m_bBombDropped = 0x9DC # bool
    m_bBombPlanted = 0x9DD # bool
    m_iRoundWinStatus = 0x9E0 # int32_t
    m_eRoundWinReason = 0x9E4 # int32_t
    m_bTCantBuy = 0x9E8 # bool
    m_bCTCantBuy = 0x9E9 # bool
    m_flGuardianBuyUntilTime = 0x9EC # GameTime_t
    m_iMatchStats_RoundResults = 0x9F0 # int32_t[30]
    m_iMatchStats_PlayersAlive_CT = 0xA68 # int32_t[30]
    m_iMatchStats_PlayersAlive_T = 0xAE0 # int32_t[30]
    m_TeamRespawnWaveTimes = 0xB58 # float[32]
    m_flNextRespawnWave = 0xBD8 # GameTime_t[32]
    m_nServerQuestID = 0xC58 # int32_t
    m_vMinimapMins = 0xC5C # Vector
    m_vMinimapMaxs = 0xC68 # Vector
    m_MinimapVerticalSectionHeights = 0xC74 # float[8]
    m_bDontIncrementCoopWave = 0xC94 # bool
    m_bSpawnedTerrorHuntHeavy = 0xC95 # bool
    m_nEndMatchMapGroupVoteTypes = 0xC98 # int32_t[10]
    m_nEndMatchMapGroupVoteOptions = 0xCC0 # int32_t[10]
    m_nEndMatchMapVoteWinner = 0xCE8 # int32_t
    m_iNumConsecutiveCTLoses = 0xCEC # int32_t
    m_iNumConsecutiveTerroristLoses = 0xCF0 # int32_t
    m_bMarkClientStopRecordAtRoundEnd = 0xD10 # bool
    m_nMatchAbortedEarlyReason = 0xD68 # int32_t
    m_bHasTriggeredRoundStartMusic = 0xD6C # bool
    m_bHasTriggeredCoopSpawnReset = 0xD6D # bool
    m_bSwitchingTeamsAtRoundReset = 0xD6E # bool
    m_pGameModeRules = 0xD88 # CCSGameModeRules*
    m_RetakeRules = 0xD90 # C_RetakeGameRules
    m_nMatchEndCount = 0xEA8 # uint8_t
    m_nTTeamIntroVariant = 0xEAC # int32_t
    m_nCTTeamIntroVariant = 0xEB0 # int32_t
    m_bTeamIntroPeriod = 0xEB4 # bool
    m_flLastPerfSampleTime = 0x4EC0 # double

class C_CSGameRulesProxy:
    m_pGameRules = 0x540 # C_CSGameRules*

class C_CSObserverPawn:
    m_hDetectParentChange = 0x16B0 # CEntityHandle

class C_CSPlayerPawn:
    m_pBulletServices = 0x16B0 # CCSPlayer_BulletServices*
    m_pHostageServices = 0x16B8 # CCSPlayer_HostageServices*
    m_pBuyServices = 0x16C0 # CCSPlayer_BuyServices*
    m_pGlowServices = 0x16C8 # CCSPlayer_GlowServices*
    m_pActionTrackingServices = 0x16D0 # CCSPlayer_ActionTrackingServices*
    m_flHealthShotBoostExpirationTime = 0x16D8 # GameTime_t
    m_flLastFiredWeaponTime = 0x16DC # GameTime_t
    m_bHasFemaleVoice = 0x16E0 # bool
    m_flLandseconds = 0x16E4 # float
    m_flOldFallVelocity = 0x16E8 # float
    m_szLastPlaceName = 0x16EC # char[18]
    m_bPrevDefuser = 0x16FE # bool
    m_bPrevHelmet = 0x16FF # bool
    m_nPrevArmorVal = 0x1700 # int32_t
    m_nPrevGrenadeAmmoCount = 0x1704 # int32_t
    m_unPreviousWeaponHash = 0x1708 # uint32_t
    m_unWeaponHash = 0x170C # uint32_t
    m_bInBuyZone = 0x1710 # bool
    m_bPreviouslyInBuyZone = 0x1711 # bool
    m_aimPunchAngle = 0x1714 # QAngle
    m_aimPunchAngleVel = 0x1720 # QAngle
    m_aimPunchTickBase = 0x172C # int32_t
    m_aimPunchTickFraction = 0x1730 # float
    m_aimPunchCache = 0x1738 # CUtlVector<QAngle>
    m_bInLanding = 0x1758 # bool
    m_flLandingTime = 0x175C # float
    m_bInHostageRescueZone = 0x1760 # bool
    m_bInBombZone = 0x1761 # bool
    m_bIsBuyMenuOpen = 0x1762 # bool
    m_flTimeOfLastInjury = 0x1764 # GameTime_t
    m_flNextSprayDecalTime = 0x1768 # GameTime_t
    m_iRetakesOffering = 0x1880 # int32_t
    m_iRetakesOfferingCard = 0x1884 # int32_t
    m_bRetakesHasDefuseKit = 0x1888 # bool
    m_bRetakesMVPLastRound = 0x1889 # bool
    m_iRetakesMVPBoostItem = 0x188C # int32_t
    m_RetakesMVPBoostExtraUtility = 0x1890 # loadout_slot_t
    m_bNeedToReApplyGloves = 0x18B0 # bool
    m_EconGloves = 0x18B8 # C_EconItemView
    m_bMustSyncRagdollState = 0x1D00 # bool
    m_nRagdollDamageBone = 0x1D04 # int32_t
    m_vRagdollDamageForce = 0x1D08 # Vector
    m_vRagdollDamagePosition = 0x1D14 # Vector
    m_szRagdollDamageWeaponName = 0x1D20 # char[64]
    m_bRagdollDamageHeadshot = 0x1D60 # bool
    m_vRagdollServerOrigin = 0x1D64 # Vector
    m_bLastHeadBoneTransformIsValid = 0x22B0 # bool
    m_lastLandTime = 0x22B4 # GameTime_t
    m_bOnGroundLastTick = 0x22B8 # bool
    m_qDeathEyeAngles = 0x22D4 # QAngle
    m_bSkipOneHeadConstraintUpdate = 0x22E0 # bool

class C_CSPlayerPawnBase:
    m_pPingServices = 0x1268 # CCSPlayer_PingServices*
    m_pViewModelServices = 0x1270 # CPlayer_ViewModelServices*
    m_fRenderingClipPlane = 0x1278 # float[4]
    m_nLastClipPlaneSetupFrame = 0x1288 # int32_t
    m_vecLastClipCameraPos = 0x128C # Vector
    m_vecLastClipCameraForward = 0x1298 # Vector
    m_bClipHitStaticWorld = 0x12A4 # bool
    m_bCachedPlaneIsValid = 0x12A5 # bool
    m_pClippingWeapon = 0x12A8 # C_CSWeaponBase*
    m_previousPlayerState = 0x12B0 # CSPlayerState
    m_flLastCollisionCeiling = 0x12B4 # float
    m_flLastCollisionCeilingChangeTime = 0x12B8 # float
    m_grenadeParameterStashTime = 0x12D8 # GameTime_t
    m_bGrenadeParametersStashed = 0x12DC # bool
    m_angStashedShootAngles = 0x12E0 # QAngle
    m_vecStashedGrenadeThrowPosition = 0x12EC # Vector
    m_vecStashedVelocity = 0x12F8 # Vector
    m_angShootAngleHistory = 0x1304 # QAngle[2]
    m_vecThrowPositionHistory = 0x131C # Vector[2]
    m_vecVelocityHistory = 0x1334 # Vector[2]
    m_thirdPersonHeading = 0x1350 # QAngle
    m_flSlopeDropOffset = 0x1368 # float
    m_flSlopeDropHeight = 0x1378 # float
    m_vHeadConstraintOffset = 0x1388 # Vector
    m_bIsScoped = 0x13A0 # bool
    m_bIsWalking = 0x13A1 # bool
    m_bResumeZoom = 0x13A2 # bool
    m_iPlayerState = 0x13A4 # CSPlayerState
    m_bIsDefusing = 0x13A8 # bool
    m_bIsGrabbingHostage = 0x13A9 # bool
    m_iBlockingUseActionInProgress = 0x13AC # CSPlayerBlockingUseAction_t
    m_bIsRescuing = 0x13B0 # bool
    m_fImmuneToGunGameDamageTime = 0x13B4 # GameTime_t
    m_fImmuneToGunGameDamageTimeLast = 0x13B8 # GameTime_t
    m_bGunGameImmunity = 0x13BC # bool
    m_bHasMovedSinceSpawn = 0x13BD # bool
    m_fMolotovUseTime = 0x13C0 # float
    m_fMolotovDamageTime = 0x13C4 # float
    m_nWhichBombZone = 0x13C8 # int32_t
    m_bInNoDefuseArea = 0x13CC # bool
    m_iThrowGrenadeCounter = 0x13D0 # int32_t
    m_bWaitForNoAttack = 0x13D4 # bool
    m_flGuardianTooFarDistFrac = 0x13D8 # float
    m_flDetectedByEnemySensorTime = 0x13DC # GameTime_t
    m_flNextGuardianTooFarWarning = 0x13E0 # float
    m_bSuppressGuardianTooFarWarningAudio = 0x13E4 # bool
    m_bKilledByTaser = 0x13E5 # bool
    m_iMoveState = 0x13E8 # int32_t
    m_bCanMoveDuringFreezePeriod = 0x13EC # bool
    m_flLowerBodyYawTarget = 0x13F0 # float
    m_bStrafing = 0x13F4 # bool
    m_flLastSpawnTimeIndex = 0x13F8 # GameTime_t
    m_flEmitSoundTime = 0x13FC # GameTime_t
    m_iAddonBits = 0x1400 # int32_t
    m_iPrimaryAddon = 0x1404 # int32_t
    m_iSecondaryAddon = 0x1408 # int32_t
    m_iProgressBarDuration = 0x140C # int32_t
    m_flProgressBarStartTime = 0x1410 # float
    m_iDirection = 0x1414 # int32_t
    m_iShotsFired = 0x1418 # int32_t
    m_bNightVisionOn = 0x141C # bool
    m_bHasNightVision = 0x141D # bool
    m_flVelocityModifier = 0x1420 # float
    m_flHitHeading = 0x1424 # float
    m_nHitBodyPart = 0x1428 # int32_t
    m_iStartAccount = 0x142C # int32_t
    m_vecIntroStartEyePosition = 0x1430 # Vector
    m_vecIntroStartPlayerForward = 0x143C # Vector
    m_flClientDeathTime = 0x1448 # GameTime_t
    m_flNightVisionAlpha = 0x144C # float
    m_bScreenTearFrameCaptured = 0x1450 # bool
    m_flFlashBangTime = 0x1454 # float
    m_flFlashScreenshotAlpha = 0x1458 # float
    m_flFlashOverlayAlpha = 0x145C # float
    m_bFlashBuildUp = 0x1460 # bool
    m_bFlashDspHasBeenCleared = 0x1461 # bool
    m_bFlashScreenshotHasBeenGrabbed = 0x1462 # bool
    m_flFlashMaxAlpha = 0x1464 # float
    m_flFlashDuration = 0x1468 # float
    m_lastStandingPos = 0x146C # Vector
    m_vecLastMuzzleFlashPos = 0x1478 # Vector
    m_angLastMuzzleFlashAngle = 0x1484 # QAngle
    m_hMuzzleFlashShape = 0x1490 # CHandle<C_BaseEntity>
    m_iHealthBarRenderMaskIndex = 0x1494 # int32_t
    m_flHealthFadeValue = 0x1498 # float
    m_flHealthFadeAlpha = 0x149C # float
    m_nMyCollisionGroup = 0x14A0 # int32_t
    m_ignoreLadderJumpTime = 0x14A4 # float
    m_ladderSurpressionTimer = 0x14A8 # CountdownTimer
    m_lastLadderNormal = 0x14C0 # Vector
    m_lastLadderPos = 0x14CC # Vector
    m_flDeathCCWeight = 0x14E0 # float
    m_bOldIsScoped = 0x14E4 # bool
    m_flPrevRoundEndTime = 0x14E8 # float
    m_flPrevMatchEndTime = 0x14EC # float
    m_unCurrentEquipmentValue = 0x14F0 # uint16_t
    m_unRoundStartEquipmentValue = 0x14F2 # uint16_t
    m_unFreezetimeEndEquipmentValue = 0x14F4 # uint16_t
    m_vecThirdPersonViewPositionOverride = 0x14F8 # Vector
    m_nHeavyAssaultSuitCooldownRemaining = 0x1504 # int32_t
    m_ArmorValue = 0x1508 # int32_t
    m_angEyeAngles = 0x1510 # QAngle
    m_fNextThinkPushAway = 0x1528 # float
    m_bShouldAutobuyDMWeapons = 0x152C # bool
    m_bShouldAutobuyNow = 0x152D # bool
    m_bHud_MiniScoreHidden = 0x152E # bool
    m_bHud_RadarHidden = 0x152F # bool
    m_nLastKillerIndex = 0x1530 # CEntityIndex
    m_nLastConcurrentKilled = 0x1534 # int32_t
    m_nDeathCamMusic = 0x1538 # int32_t
    m_iIDEntIndex = 0x153C # CEntityIndex
    m_delayTargetIDTimer = 0x1540 # CountdownTimer
    m_iTargetedWeaponEntIndex = 0x1558 # CEntityIndex
    m_iOldIDEntIndex = 0x155C # CEntityIndex
    m_holdTargetIDTimer = 0x1560 # CountdownTimer
    m_flCurrentMusicStartTime = 0x157C # float
    m_flMusicRoundStartTime = 0x1580 # float
    m_bDeferStartMusicOnWarmup = 0x1584 # bool
    m_cycleLatch = 0x1588 # int32_t
    m_serverIntendedCycle = 0x158C # float
    m_vecPlayerPatchEconIndices = 0x1590 # uint32_t[5]
    m_bHideTargetID = 0x15AC # bool
    m_nextTaserShakeTime = 0x15B0 # float
    m_firstTaserShakeTime = 0x15B4 # float
    m_flLastSmokeOverlayAlpha = 0x15B8 # float
    m_vLastSmokeOverlayColor = 0x15BC # Vector
    m_nPlayerSmokedFx = 0x15C8 # ParticleIndex_t
    m_flNextMagDropTime = 0x15CC # float
    m_nLastMagDropAttachmentIndex = 0x15D0 # int32_t
    m_vecBulletHitModels = 0x15D8 # CUtlVector<C_BulletHitModel*>
    m_vecPickupModelSlerpers = 0x15F0 # CUtlVector<C_PickUpModelSlerper*>
    m_vecLastAliveLocalVelocity = 0x1608 # Vector
    m_entitySpottedState = 0x1630 # EntitySpottedState_t
    m_nSurvivalTeamNumber = 0x1648 # int32_t
    m_bGuardianShouldSprayCustomXMark = 0x164C # bool
    m_bHasDeathInfo = 0x164D # bool
    m_flDeathInfoTime = 0x1650 # float
    m_vecDeathInfoOrigin = 0x1654 # Vector
    m_bKilledByHeadshot = 0x1660 # bool
    m_hOriginalController = 0x1664 # CHandle<CCSPlayerController>

class C_CSPlayerResource:
    m_bHostageAlive = 0x540 # bool[12]
    m_isHostageFollowingSomeone = 0x54C # bool[12]
    m_iHostageEntityIDs = 0x558 # CEntityIndex[12]
    m_bombsiteCenterA = 0x588 # Vector
    m_bombsiteCenterB = 0x594 # Vector
    m_hostageRescueX = 0x5A0 # int32_t[4]
    m_hostageRescueY = 0x5B0 # int32_t[4]
    m_hostageRescueZ = 0x5C0 # int32_t[4]
    m_bEndMatchNextMapAllVoted = 0x5D0 # bool
    m_foundGoalPositions = 0x5D1 # bool

class C_CSTeam:
    m_szTeamMatchStat = 0x5F8 # char[512]
    m_numMapVictories = 0x7F8 # int32_t
    m_bSurrendered = 0x7FC # bool
    m_scoreFirstHalf = 0x800 # int32_t
    m_scoreSecondHalf = 0x804 # int32_t
    m_scoreOvertime = 0x808 # int32_t
    m_szClanTeamname = 0x80C # char[129]
    m_iClanID = 0x890 # uint32_t
    m_szTeamFlagImage = 0x894 # char[8]
    m_szTeamLogoImage = 0x89C # char[8]

class C_CSWeaponBase:
    m_flFireSequenceStartTime = 0x15D4 # float
    m_nFireSequenceStartTimeChange = 0x15D8 # int32_t
    m_nFireSequenceStartTimeAck = 0x15DC # int32_t
    m_bPlayerFireEventIsPrimary = 0x15E0 # bool
    m_seqIdle = 0x15E4 # HSequence
    m_seqFirePrimary = 0x15E8 # HSequence
    m_seqFireSecondary = 0x15EC # HSequence
    m_thirdPersonFireSequences = 0x15F0 # CUtlVector<HSequence>
    m_hCurrentThirdPersonSequence = 0x1608 # HSequence
    m_nSilencerBoneIndex = 0x160C # int32_t
    m_thirdPersonSequences = 0x1610 # HSequence[6]
    m_ClientPreviousWeaponState = 0x1640 # CSWeaponState_t
    m_iState = 0x1644 # CSWeaponState_t
    m_flCrosshairDistance = 0x1648 # float
    m_iAmmoLastCheck = 0x164C # int32_t
    m_iAlpha = 0x1650 # int32_t
    m_iScopeTextureID = 0x1654 # int32_t
    m_iCrosshairTextureID = 0x1658 # int32_t
    m_flGunAccuracyPosition = 0x165C # float
    m_nViewModelIndex = 0x1660 # uint32_t
    m_bReloadsWithClips = 0x1664 # bool
    m_flTimeWeaponIdle = 0x1668 # GameTime_t
    m_bFireOnEmpty = 0x166C # bool
    m_OnPlayerPickup = 0x1670 # CEntityIOOutput
    m_weaponMode = 0x1698 # CSWeaponMode
    m_flTurningInaccuracyDelta = 0x169C # float
    m_vecTurningInaccuracyEyeDirLast = 0x16A0 # Vector
    m_flTurningInaccuracy = 0x16AC # float
    m_fAccuracyPenalty = 0x16B0 # float
    m_flLastAccuracyUpdateTime = 0x16B4 # GameTime_t
    m_fAccuracySmoothedForZoom = 0x16B8 # float
    m_fScopeZoomEndTime = 0x16BC # GameTime_t
    m_iRecoilIndex = 0x16C0 # int32_t
    m_flRecoilIndex = 0x16C4 # float
    m_bBurstMode = 0x16C8 # bool
    m_flPostponeFireReadyTime = 0x16CC # GameTime_t
    m_bInReload = 0x16D0 # bool
    m_bReloadVisuallyComplete = 0x16D1 # bool
    m_flDroppedAtTime = 0x16D4 # GameTime_t
    m_bIsHauledBack = 0x16D8 # bool
    m_bSilencerOn = 0x16D9 # bool
    m_flTimeSilencerSwitchComplete = 0x16DC # GameTime_t
    m_iOriginalTeamNumber = 0x16E0 # int32_t
    m_flNextAttackRenderTimeOffset = 0x16E4 # float
    m_bVisualsDataSet = 0x1768 # bool
    m_bOldFirstPersonSpectatedState = 0x1769 # bool
    m_hOurPing = 0x176C # CHandle<C_BaseEntity>
    m_nOurPingIndex = 0x1770 # CEntityIndex
    m_vecOurPingPos = 0x1774 # Vector
    m_bGlowForPing = 0x1780 # bool
    m_bUIWeapon = 0x1781 # bool
    m_hPrevOwner = 0x1790 # CHandle<C_CSPlayerPawn>
    m_nDropTick = 0x1794 # GameTick_t
    m_donated = 0x17B4 # bool
    m_fLastShotTime = 0x17B8 # GameTime_t
    m_bWasOwnedByCT = 0x17BC # bool
    m_bWasOwnedByTerrorist = 0x17BD # bool
    m_gunHeat = 0x17C0 # float
    m_smokeAttachments = 0x17C4 # uint32_t
    m_lastSmokeTime = 0x17C8 # GameTime_t
    m_flNextClientFireBulletTime = 0x17CC # float
    m_flNextClientFireBulletTime_Repredict = 0x17D0 # float
    m_IronSightController = 0x18B0 # C_IronSightController
    m_iIronSightMode = 0x1960 # int32_t
    m_flLastLOSTraceFailureTime = 0x1970 # GameTime_t
    m_iNumEmptyAttacks = 0x1974 # int32_t

class C_CSWeaponBaseGun:
    m_zoomLevel = 0x19F0 # int32_t
    m_iBurstShotsRemaining = 0x19F4 # int32_t
    m_iSilencerBodygroup = 0x19F8 # int32_t
    m_silencedModelIndex = 0x1A08 # int32_t
    m_inPrecache = 0x1A0C # bool
    m_bNeedsBoltAction = 0x1A0D # bool

class C_Chicken:
    m_hHolidayHatAddon = 0x10F0 # CHandle<CBaseAnimGraph>
    m_jumpedThisFrame = 0x10F4 # bool
    m_leader = 0x10F8 # CHandle<C_CSPlayerPawnBase>
    m_AttributeManager = 0x1100 # C_AttributeContainer
    m_OriginalOwnerXuidLow = 0x15A8 # uint32_t
    m_OriginalOwnerXuidHigh = 0x15AC # uint32_t
    m_bAttributesInitialized = 0x15B0 # bool
    m_hWaterWakeParticles = 0x15B4 # ParticleIndex_t

class C_ClientRagdoll:
    m_bFadeOut = 0xE80 # bool
    m_bImportant = 0xE81 # bool
    m_flEffectTime = 0xE84 # GameTime_t
    m_gibDespawnTime = 0xE88 # GameTime_t
    m_iCurrentFriction = 0xE8C # int32_t
    m_iMinFriction = 0xE90 # int32_t
    m_iMaxFriction = 0xE94 # int32_t
    m_iFrictionAnimState = 0xE98 # int32_t
    m_bReleaseRagdoll = 0xE9C # bool
    m_iEyeAttachment = 0xE9D # AttachmentHandle_t
    m_bFadingOut = 0xE9E # bool
    m_flScaleEnd = 0xEA0 # float[10]
    m_flScaleTimeStart = 0xEC8 # GameTime_t[10]
    m_flScaleTimeEnd = 0xEF0 # GameTime_t[10]

class C_ColorCorrection:
    m_vecOrigin = 0x540 # Vector
    m_MinFalloff = 0x54C # float
    m_MaxFalloff = 0x550 # float
    m_flFadeInDuration = 0x554 # float
    m_flFadeOutDuration = 0x558 # float
    m_flMaxWeight = 0x55C # float
    m_flCurWeight = 0x560 # float
    m_netlookupFilename = 0x564 # char[512]
    m_bEnabled = 0x764 # bool
    m_bMaster = 0x765 # bool
    m_bClientSide = 0x766 # bool
    m_bExclusive = 0x767 # bool
    m_bEnabledOnClient = 0x768 # bool[1]
    m_flCurWeightOnClient = 0x76C # float[1]
    m_bFadingIn = 0x770 # bool[1]
    m_flFadeStartWeight = 0x774 # float[1]
    m_flFadeStartTime = 0x778 # float[1]
    m_flFadeDuration = 0x77C # float[1]

class C_ColorCorrectionVolume:
    m_LastEnterWeight = 0xCC8 # float
    m_LastEnterTime = 0xCCC # float
    m_LastExitWeight = 0xCD0 # float
    m_LastExitTime = 0xCD4 # float
    m_bEnabled = 0xCD8 # bool
    m_MaxWeight = 0xCDC # float
    m_FadeDuration = 0xCE0 # float
    m_Weight = 0xCE4 # float
    m_lookupFilename = 0xCE8 # char[512]

class C_CommandContext:
    needsprocessing = 0x0 # bool
    command_number = 0xA8 # int32_t

class C_CsmFovOverride:
    m_cameraName = 0x540 # CUtlString
    m_flCsmFovOverrideValue = 0x548 # float

class C_DecoyProjectile:
    m_nDecoyShotTick = 0x1100 # int32_t
    m_nClientLastKnownDecoyShotTick = 0x1104 # int32_t
    m_flTimeParticleEffectSpawn = 0x1128 # GameTime_t

class C_DynamicLight:
    m_Flags = 0xCC0 # uint8_t
    m_LightStyle = 0xCC1 # uint8_t
    m_Radius = 0xCC4 # float
    m_Exponent = 0xCC8 # int32_t
    m_InnerAngle = 0xCCC # float
    m_OuterAngle = 0xCD0 # float
    m_SpotRadius = 0xCD4 # float

class C_DynamicProp:
    m_bUseHitboxesForRenderBox = 0xFD0 # bool
    m_bUseAnimGraph = 0xFD1 # bool
    m_pOutputAnimBegun = 0xFD8 # CEntityIOOutput
    m_pOutputAnimOver = 0x1000 # CEntityIOOutput
    m_pOutputAnimLoopCycleOver = 0x1028 # CEntityIOOutput
    m_OnAnimReachedStart = 0x1050 # CEntityIOOutput
    m_OnAnimReachedEnd = 0x1078 # CEntityIOOutput
    m_iszDefaultAnim = 0x10A0 # CUtlSymbolLarge
    m_nDefaultAnimLoopMode = 0x10A8 # AnimLoopMode_t
    m_bAnimateOnServer = 0x10AC # bool
    m_bRandomizeCycle = 0x10AD # bool
    m_bStartDisabled = 0x10AE # bool
    m_bScriptedMovement = 0x10AF # bool
    m_bFiredStartEndOutput = 0x10B0 # bool
    m_bForceNpcExclude = 0x10B1 # bool
    m_bCreateNonSolid = 0x10B2 # bool
    m_bIsOverrideProp = 0x10B3 # bool
    m_iInitialGlowState = 0x10B4 # int32_t
    m_nGlowRange = 0x10B8 # int32_t
    m_nGlowRangeMin = 0x10BC # int32_t
    m_glowColor = 0x10C0 # Color
    m_nGlowTeam = 0x10C4 # int32_t
    m_iCachedFrameCount = 0x10C8 # int32_t
    m_vecCachedRenderMins = 0x10CC # Vector
    m_vecCachedRenderMaxs = 0x10D8 # Vector

class C_EconEntity:
    m_flFlexDelayTime = 0x1028 # float
    m_flFlexDelayedWeight = 0x1030 # float*
    m_bAttributesInitialized = 0x1038 # bool
    m_AttributeManager = 0x1040 # C_AttributeContainer
    m_OriginalOwnerXuidLow = 0x14E8 # uint32_t
    m_OriginalOwnerXuidHigh = 0x14EC # uint32_t
    m_nFallbackPaintKit = 0x14F0 # int32_t
    m_nFallbackSeed = 0x14F4 # int32_t
    m_flFallbackWear = 0x14F8 # float
    m_nFallbackStatTrak = 0x14FC # int32_t
    m_bClientside = 0x1500 # bool
    m_bParticleSystemsCreated = 0x1501 # bool
    m_vecAttachedParticles = 0x1508 # CUtlVector<int32_t>
    m_hViewmodelAttachment = 0x1520 # CHandle<CBaseAnimGraph>
    m_iOldTeam = 0x1524 # int32_t
    m_bAttachmentDirty = 0x1528 # bool
    m_nUnloadedModelIndex = 0x152C # int32_t
    m_iNumOwnerValidationRetries = 0x1530 # int32_t
    m_hOldProvidee = 0x1540 # CHandle<C_BaseEntity>
    m_vecAttachedModels = 0x1548 # CUtlVector<C_EconEntity::AttachedModelData_t>

class C_EconEntity_AttachedModelData_t:
    m_iModelDisplayFlags = 0x0 # int32_t

class C_EconItemView:
    m_bInventoryImageRgbaRequested = 0x60 # bool
    m_bInventoryImageTriedCache = 0x61 # bool
    m_nInventoryImageRgbaWidth = 0x80 # int32_t
    m_nInventoryImageRgbaHeight = 0x84 # int32_t
    m_szCurrentLoadCachedFileName = 0x88 # char[260]
    m_bRestoreCustomMaterialAfterPrecache = 0x1B8 # bool
    m_iItemDefinitionIndex = 0x1BA # uint16_t
    m_iEntityQuality = 0x1BC # int32_t
    m_iEntityLevel = 0x1C0 # uint32_t
    m_iItemID = 0x1C8 # uint64_t
    m_iItemIDHigh = 0x1D0 # uint32_t
    m_iItemIDLow = 0x1D4 # uint32_t
    m_iAccountID = 0x1D8 # uint32_t
    m_iInventoryPosition = 0x1DC # uint32_t
    m_bInitialized = 0x1E8 # bool
    m_bIsStoreItem = 0x1E9 # bool
    m_bIsTradeItem = 0x1EA # bool
    m_iEntityQuantity = 0x1EC # int32_t
    m_iRarityOverride = 0x1F0 # int32_t
    m_iQualityOverride = 0x1F4 # int32_t
    m_unClientFlags = 0x1F8 # uint8_t
    m_unOverrideStyle = 0x1F9 # uint8_t
    m_AttributeList = 0x210 # CAttributeList
    m_NetworkedDynamicAttributes = 0x270 # CAttributeList
    m_szCustomName = 0x2D0 # char[161]
    m_szCustomNameOverride = 0x371 # char[161]
    m_bInitializedTags = 0x440 # bool

class C_EconWearable:
    m_nForceSkin = 0x1560 # int32_t
    m_bAlwaysAllow = 0x1564 # bool

class C_EntityDissolve:
    m_flStartTime = 0xCC8 # GameTime_t
    m_flFadeInStart = 0xCCC # float
    m_flFadeInLength = 0xCD0 # float
    m_flFadeOutModelStart = 0xCD4 # float
    m_flFadeOutModelLength = 0xCD8 # float
    m_flFadeOutStart = 0xCDC # float
    m_flFadeOutLength = 0xCE0 # float
    m_flNextSparkTime = 0xCE4 # GameTime_t
    m_nDissolveType = 0xCE8 # EntityDisolveType_t
    m_vDissolverOrigin = 0xCEC # Vector
    m_nMagnitude = 0xCF8 # uint32_t
    m_bCoreExplode = 0xCFC # bool
    m_bLinkedToServerEnt = 0xCFD # bool

class C_EntityFlame:
    m_hEntAttached = 0x540 # CHandle<C_BaseEntity>
    m_hOldAttached = 0x568 # CHandle<C_BaseEntity>
    m_bCheapEffect = 0x56C # bool

class C_EnvCombinedLightProbeVolume:
    m_Color = 0x1598 # Color
    m_flBrightness = 0x159C # float
    m_hCubemapTexture = 0x15A0 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_bCustomCubemapTexture = 0x15A8 # bool
    m_hLightProbeTexture = 0x15B0 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_hLightProbeDirectLightIndicesTexture = 0x15B8 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_hLightProbeDirectLightScalarsTexture = 0x15C0 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_hLightProbeDirectLightShadowsTexture = 0x15C8 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_vBoxMins = 0x15D0 # Vector
    m_vBoxMaxs = 0x15DC # Vector
    m_bMoveable = 0x15E8 # bool
    m_nHandshake = 0x15EC # int32_t
    m_nEnvCubeMapArrayIndex = 0x15F0 # int32_t
    m_nPriority = 0x15F4 # int32_t
    m_bStartDisabled = 0x15F8 # bool
    m_flEdgeFadeDist = 0x15FC # float
    m_vEdgeFadeDists = 0x1600 # Vector
    m_nLightProbeSizeX = 0x160C # int32_t
    m_nLightProbeSizeY = 0x1610 # int32_t
    m_nLightProbeSizeZ = 0x1614 # int32_t
    m_nLightProbeAtlasX = 0x1618 # int32_t
    m_nLightProbeAtlasY = 0x161C # int32_t
    m_nLightProbeAtlasZ = 0x1620 # int32_t
    m_bEnabled = 0x1639 # bool

class C_EnvCubemap:
    m_hCubemapTexture = 0x5C0 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_bCustomCubemapTexture = 0x5C8 # bool
    m_flInfluenceRadius = 0x5CC # float
    m_vBoxProjectMins = 0x5D0 # Vector
    m_vBoxProjectMaxs = 0x5DC # Vector
    m_bMoveable = 0x5E8 # bool
    m_nHandshake = 0x5EC # int32_t
    m_nEnvCubeMapArrayIndex = 0x5F0 # int32_t
    m_nPriority = 0x5F4 # int32_t
    m_flEdgeFadeDist = 0x5F8 # float
    m_vEdgeFadeDists = 0x5FC # Vector
    m_flDiffuseScale = 0x608 # float
    m_bStartDisabled = 0x60C # bool
    m_bDefaultEnvMap = 0x60D # bool
    m_bDefaultSpecEnvMap = 0x60E # bool
    m_bIndoorCubeMap = 0x60F # bool
    m_bCopyDiffuseFromDefaultCubemap = 0x610 # bool
    m_bEnabled = 0x620 # bool

class C_EnvCubemapFog:
    m_flEndDistance = 0x540 # float
    m_flStartDistance = 0x544 # float
    m_flFogFalloffExponent = 0x548 # float
    m_bHeightFogEnabled = 0x54C # bool
    m_flFogHeightWidth = 0x550 # float
    m_flFogHeightEnd = 0x554 # float
    m_flFogHeightStart = 0x558 # float
    m_flFogHeightExponent = 0x55C # float
    m_flLODBias = 0x560 # float
    m_bActive = 0x564 # bool
    m_bStartDisabled = 0x565 # bool
    m_flFogMaxOpacity = 0x568 # float
    m_nCubemapSourceType = 0x56C # int32_t
    m_hSkyMaterial = 0x570 # CStrongHandle<InfoForResourceTypeIMaterial2>
    m_iszSkyEntity = 0x578 # CUtlSymbolLarge
    m_hFogCubemapTexture = 0x580 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_bHasHeightFogEnd = 0x588 # bool
    m_bFirstTime = 0x589 # bool

class C_EnvDecal:
    m_hDecalMaterial = 0xCC0 # CStrongHandle<InfoForResourceTypeIMaterial2>
    m_flWidth = 0xCC8 # float
    m_flHeight = 0xCCC # float
    m_flDepth = 0xCD0 # float
    m_nRenderOrder = 0xCD4 # uint32_t
    m_bProjectOnWorld = 0xCD8 # bool
    m_bProjectOnCharacters = 0xCD9 # bool
    m_bProjectOnWater = 0xCDA # bool
    m_flDepthSortBias = 0xCDC # float

class C_EnvDetailController:
    m_flFadeStartDist = 0x540 # float
    m_flFadeEndDist = 0x544 # float

class C_EnvLightProbeVolume:
    m_hLightProbeTexture = 0x1518 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_hLightProbeDirectLightIndicesTexture = 0x1520 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_hLightProbeDirectLightScalarsTexture = 0x1528 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_hLightProbeDirectLightShadowsTexture = 0x1530 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_vBoxMins = 0x1538 # Vector
    m_vBoxMaxs = 0x1544 # Vector
    m_bMoveable = 0x1550 # bool
    m_nHandshake = 0x1554 # int32_t
    m_nPriority = 0x1558 # int32_t
    m_bStartDisabled = 0x155C # bool
    m_nLightProbeSizeX = 0x1560 # int32_t
    m_nLightProbeSizeY = 0x1564 # int32_t
    m_nLightProbeSizeZ = 0x1568 # int32_t
    m_nLightProbeAtlasX = 0x156C # int32_t
    m_nLightProbeAtlasY = 0x1570 # int32_t
    m_nLightProbeAtlasZ = 0x1574 # int32_t
    m_bEnabled = 0x1581 # bool

class C_EnvParticleGlow:
    m_flAlphaScale = 0x1270 # float
    m_flRadiusScale = 0x1274 # float
    m_flSelfIllumScale = 0x1278 # float
    m_ColorTint = 0x127C # Color
    m_hTextureOverride = 0x1280 # CStrongHandle<InfoForResourceTypeCTextureBase>

class C_EnvScreenOverlay:
    m_iszOverlayNames = 0x540 # CUtlSymbolLarge[10]
    m_flOverlayTimes = 0x590 # float[10]
    m_flStartTime = 0x5B8 # GameTime_t
    m_iDesiredOverlay = 0x5BC # int32_t
    m_bIsActive = 0x5C0 # bool
    m_bWasActive = 0x5C1 # bool
    m_iCachedDesiredOverlay = 0x5C4 # int32_t
    m_iCurrentOverlay = 0x5C8 # int32_t
    m_flCurrentOverlayTime = 0x5CC # GameTime_t

class C_EnvSky:
    m_hSkyMaterial = 0xCC0 # CStrongHandle<InfoForResourceTypeIMaterial2>
    m_hSkyMaterialLightingOnly = 0xCC8 # CStrongHandle<InfoForResourceTypeIMaterial2>
    m_bStartDisabled = 0xCD0 # bool
    m_vTintColor = 0xCD1 # Color
    m_vTintColorLightingOnly = 0xCD5 # Color
    m_flBrightnessScale = 0xCDC # float
    m_nFogType = 0xCE0 # int32_t
    m_flFogMinStart = 0xCE4 # float
    m_flFogMinEnd = 0xCE8 # float
    m_flFogMaxStart = 0xCEC # float
    m_flFogMaxEnd = 0xCF0 # float
    m_bEnabled = 0xCF4 # bool

class C_EnvVolumetricFogController:
    m_flScattering = 0x540 # float
    m_flAnisotropy = 0x544 # float
    m_flFadeSpeed = 0x548 # float
    m_flDrawDistance = 0x54C # float
    m_flFadeInStart = 0x550 # float
    m_flFadeInEnd = 0x554 # float
    m_flIndirectStrength = 0x558 # float
    m_nIndirectTextureDimX = 0x55C # int32_t
    m_nIndirectTextureDimY = 0x560 # int32_t
    m_nIndirectTextureDimZ = 0x564 # int32_t
    m_vBoxMins = 0x568 # Vector
    m_vBoxMaxs = 0x574 # Vector
    m_bActive = 0x580 # bool
    m_flStartAnisoTime = 0x584 # GameTime_t
    m_flStartScatterTime = 0x588 # GameTime_t
    m_flStartDrawDistanceTime = 0x58C # GameTime_t
    m_flStartAnisotropy = 0x590 # float
    m_flStartScattering = 0x594 # float
    m_flStartDrawDistance = 0x598 # float
    m_flDefaultAnisotropy = 0x59C # float
    m_flDefaultScattering = 0x5A0 # float
    m_flDefaultDrawDistance = 0x5A4 # float
    m_bStartDisabled = 0x5A8 # bool
    m_bEnableIndirect = 0x5A9 # bool
    m_bIsMaster = 0x5AA # bool
    m_hFogIndirectTexture = 0x5B0 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_nForceRefreshCount = 0x5B8 # int32_t
    m_bFirstTime = 0x5BC # bool

class C_EnvVolumetricFogVolume:
    m_bActive = 0x540 # bool
    m_vBoxMins = 0x544 # Vector
    m_vBoxMaxs = 0x550 # Vector
    m_bStartDisabled = 0x55C # bool
    m_flStrength = 0x560 # float
    m_nFalloffShape = 0x564 # int32_t
    m_flFalloffExponent = 0x568 # float

class C_EnvWind:
    m_EnvWindShared = 0x540 # C_EnvWindShared

class C_EnvWindClientside:
    m_EnvWindShared = 0x540 # C_EnvWindShared

class C_EnvWindShared:
    m_flStartTime = 0x8 # GameTime_t
    m_iWindSeed = 0xC # uint32_t
    m_iMinWind = 0x10 # uint16_t
    m_iMaxWind = 0x12 # uint16_t
    m_windRadius = 0x14 # int32_t
    m_iMinGust = 0x18 # uint16_t
    m_iMaxGust = 0x1A # uint16_t
    m_flMinGustDelay = 0x1C # float
    m_flMaxGustDelay = 0x20 # float
    m_flGustDuration = 0x24 # float
    m_iGustDirChange = 0x28 # uint16_t
    m_location = 0x2C # Vector
    m_iszGustSound = 0x38 # int32_t
    m_iWindDir = 0x3C # int32_t
    m_flWindSpeed = 0x40 # float
    m_currentWindVector = 0x44 # Vector
    m_CurrentSwayVector = 0x50 # Vector
    m_PrevSwayVector = 0x5C # Vector
    m_iInitialWindDir = 0x68 # uint16_t
    m_flInitialWindSpeed = 0x6C # float
    m_flVariationTime = 0x70 # GameTime_t
    m_flSwayTime = 0x74 # GameTime_t
    m_flSimTime = 0x78 # GameTime_t
    m_flSwitchTime = 0x7C # GameTime_t
    m_flAveWindSpeed = 0x80 # float
    m_bGusting = 0x84 # bool
    m_flWindAngleVariation = 0x88 # float
    m_flWindSpeedVariation = 0x8C # float
    m_iEntIndex = 0x90 # CEntityIndex

class C_EnvWindShared_WindAveEvent_t:
    m_flStartWindSpeed = 0x0 # float
    m_flAveWindSpeed = 0x4 # float

class C_EnvWindShared_WindVariationEvent_t:
    m_flWindAngleVariation = 0x0 # float
    m_flWindSpeedVariation = 0x4 # float

class C_FireSmoke:
    m_nFlameModelIndex = 0x550 # int32_t
    m_nFlameFromAboveModelIndex = 0x554 # int32_t
    m_flScaleRegister = 0x558 # float
    m_flScaleStart = 0x55C # float
    m_flScaleEnd = 0x560 # float
    m_flScaleTimeStart = 0x564 # GameTime_t
    m_flScaleTimeEnd = 0x568 # GameTime_t
    m_flChildFlameSpread = 0x56C # float
    m_flClipPerc = 0x580 # float
    m_bClipTested = 0x584 # bool
    m_bFadingOut = 0x585 # bool
    m_tParticleSpawn = 0x588 # TimedEvent
    m_pFireOverlay = 0x590 # CFireOverlay*

class C_FireSprite:
    m_vecMoveDir = 0xDF0 # Vector
    m_bFadeFromAbove = 0xDFC # bool

class C_Fish:
    m_pos = 0xE80 # Vector
    m_vel = 0xE8C # Vector
    m_angles = 0xE98 # QAngle
    m_localLifeState = 0xEA4 # int32_t
    m_deathDepth = 0xEA8 # float
    m_deathAngle = 0xEAC # float
    m_buoyancy = 0xEB0 # float
    m_wiggleTimer = 0xEB8 # CountdownTimer
    m_wigglePhase = 0xED0 # float
    m_wiggleRate = 0xED4 # float
    m_actualPos = 0xED8 # Vector
    m_actualAngles = 0xEE4 # QAngle
    m_poolOrigin = 0xEF0 # Vector
    m_waterLevel = 0xEFC # float
    m_gotUpdate = 0xF00 # bool
    m_x = 0xF04 # float
    m_y = 0xF08 # float
    m_z = 0xF0C # float
    m_angle = 0xF10 # float
    m_errorHistory = 0xF14 # float[20]
    m_errorHistoryIndex = 0xF64 # int32_t
    m_errorHistoryCount = 0xF68 # int32_t
    m_averageError = 0xF6C # float

class C_Fists:
    m_bPlayingUninterruptableAct = 0x19F0 # bool
    m_nUninterruptableActivity = 0x19F4 # PlayerAnimEvent_t

class C_FogController:
    m_fog = 0x540 # fogparams_t
    m_bUseAngles = 0x5A8 # bool
    m_iChangedVariables = 0x5AC # int32_t

class C_FootstepControl:
    m_source = 0xCC8 # CUtlSymbolLarge
    m_destination = 0xCD0 # CUtlSymbolLarge

class C_FuncConveyor:
    m_vecMoveDirEntitySpace = 0xCC8 # Vector
    m_flTargetSpeed = 0xCD4 # float
    m_nTransitionStartTick = 0xCD8 # GameTick_t
    m_nTransitionDurationTicks = 0xCDC # int32_t
    m_flTransitionStartSpeed = 0xCE0 # float
    m_hConveyorModels = 0xCE8 # C_NetworkUtlVectorBase<CHandle<C_BaseEntity>>
    m_flCurrentConveyorOffset = 0xD00 # float
    m_flCurrentConveyorSpeed = 0xD04 # float

class C_FuncElectrifiedVolume:
    m_nAmbientEffect = 0xCC0 # ParticleIndex_t
    m_EffectName = 0xCC8 # CUtlSymbolLarge
    m_bState = 0xCD0 # bool

class C_FuncLadder:
    m_vecLadderDir = 0xCC0 # Vector
    m_Dismounts = 0xCD0 # CUtlVector<CHandle<C_InfoLadderDismount>>
    m_vecLocalTop = 0xCE8 # Vector
    m_vecPlayerMountPositionTop = 0xCF4 # Vector
    m_vecPlayerMountPositionBottom = 0xD00 # Vector
    m_flAutoRideSpeed = 0xD0C # float
    m_bDisabled = 0xD10 # bool
    m_bFakeLadder = 0xD11 # bool
    m_bHasSlack = 0xD12 # bool

class C_FuncMonitor:
    m_targetCamera = 0xCC0 # CUtlString
    m_nResolutionEnum = 0xCC8 # int32_t
    m_bRenderShadows = 0xCCC # bool
    m_bUseUniqueColorTarget = 0xCCD # bool
    m_brushModelName = 0xCD0 # CUtlString
    m_hTargetCamera = 0xCD8 # CHandle<C_BaseEntity>
    m_bEnabled = 0xCDC # bool
    m_bDraw3DSkybox = 0xCDD # bool

class C_FuncTrackTrain:
    m_nLongAxis = 0xCC0 # int32_t
    m_flRadius = 0xCC4 # float
    m_flLineLength = 0xCC8 # float

class C_GlobalLight:
    m_WindClothForceHandle = 0xA00 # uint16_t

class C_GradientFog:
    m_hGradientFogTexture = 0x540 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_flFogStartDistance = 0x548 # float
    m_flFogEndDistance = 0x54C # float
    m_bHeightFogEnabled = 0x550 # bool
    m_flFogStartHeight = 0x554 # float
    m_flFogEndHeight = 0x558 # float
    m_flFarZ = 0x55C # float
    m_flFogMaxOpacity = 0x560 # float
    m_flFogFalloffExponent = 0x564 # float
    m_flFogVerticalExponent = 0x568 # float
    m_fogColor = 0x56C # Color
    m_flFogStrength = 0x570 # float
    m_flFadeTime = 0x574 # float
    m_bStartDisabled = 0x578 # bool
    m_bIsEnabled = 0x579 # bool
    m_bGradientFogNeedsTextures = 0x57A # bool

class C_HandleTest:
    m_Handle = 0x540 # CHandle<C_BaseEntity>
    m_bSendHandle = 0x544 # bool

class C_Hostage:
    m_entitySpottedState = 0x10A8 # EntitySpottedState_t
    m_leader = 0x10C0 # CHandle<C_BaseEntity>
    m_reuseTimer = 0x10C8 # CountdownTimer
    m_vel = 0x10E0 # Vector
    m_isRescued = 0x10EC # bool
    m_jumpedThisFrame = 0x10ED # bool
    m_nHostageState = 0x10F0 # int32_t
    m_bHandsHaveBeenCut = 0x10F4 # bool
    m_hHostageGrabber = 0x10F8 # CHandle<C_CSPlayerPawn>
    m_fLastGrabTime = 0x10FC # GameTime_t
    m_vecGrabbedPos = 0x1100 # Vector
    m_flRescueStartTime = 0x110C # GameTime_t
    m_flGrabSuccessTime = 0x1110 # GameTime_t
    m_flDropStartTime = 0x1114 # GameTime_t
    m_flDeadOrRescuedTime = 0x1118 # GameTime_t
    m_blinkTimer = 0x1120 # CountdownTimer
    m_lookAt = 0x1138 # Vector
    m_lookAroundTimer = 0x1148 # CountdownTimer
    m_isInit = 0x1160 # bool
    m_eyeAttachment = 0x1161 # AttachmentHandle_t
    m_chestAttachment = 0x1162 # AttachmentHandle_t
    m_pPredictionOwner = 0x1168 # CBasePlayerController*
    m_fNewestAlphaThinkTime = 0x1170 # GameTime_t

class C_Inferno:
    m_nfxFireDamageEffect = 0xD00 # ParticleIndex_t
    m_firePositions = 0xD04 # Vector[64]
    m_fireParentPositions = 0x1004 # Vector[64]
    m_bFireIsBurning = 0x1304 # bool[64]
    m_BurnNormal = 0x1344 # Vector[64]
    m_fireCount = 0x1644 # int32_t
    m_nInfernoType = 0x1648 # int32_t
    m_nFireLifetime = 0x164C # float
    m_bInPostEffectTime = 0x1650 # bool
    m_lastFireCount = 0x1654 # int32_t
    m_nFireEffectTickBegin = 0x1658 # int32_t
    m_drawableCount = 0x8260 # int32_t
    m_blosCheck = 0x8264 # bool
    m_nlosperiod = 0x8268 # int32_t
    m_maxFireHalfWidth = 0x826C # float
    m_maxFireHeight = 0x8270 # float
    m_minBounds = 0x8274 # Vector
    m_maxBounds = 0x8280 # Vector
    m_flLastGrassBurnThink = 0x828C # float

class C_InfoVisibilityBox:
    m_nMode = 0x544 # int32_t
    m_vBoxSize = 0x548 # Vector
    m_bEnabled = 0x554 # bool

class C_IronSightController:
    m_bIronSightAvailable = 0x10 # bool
    m_flIronSightAmount = 0x14 # float
    m_flIronSightAmountGained = 0x18 # float
    m_flIronSightAmountBiased = 0x1C # float
    m_flIronSightAmount_Interpolated = 0x20 # float
    m_flIronSightAmountGained_Interpolated = 0x24 # float
    m_flIronSightAmountBiased_Interpolated = 0x28 # float
    m_flInterpolationLastUpdated = 0x2C # float
    m_angDeltaAverage = 0x30 # QAngle[8]
    m_angViewLast = 0x90 # QAngle
    m_vecDotCoords = 0x9C # Vector2D
    m_flDotBlur = 0xA4 # float
    m_flSpeedRatio = 0xA8 # float

class C_Item:
    m_bShouldGlow = 0x1560 # bool
    m_pReticleHintTextName = 0x1561 # char[256]

class C_ItemDogtags:
    m_OwningPlayer = 0x1668 # CHandle<C_CSPlayerPawn>
    m_KillingPlayer = 0x166C # CHandle<C_CSPlayerPawn>

class C_LightEntity:
    m_CLightComponent = 0xCC0 # CLightComponent*

class C_LightGlow:
    m_nHorizontalSize = 0xCC0 # uint32_t
    m_nVerticalSize = 0xCC4 # uint32_t
    m_nMinDist = 0xCC8 # uint32_t
    m_nMaxDist = 0xCCC # uint32_t
    m_nOuterMaxDist = 0xCD0 # uint32_t
    m_flGlowProxySize = 0xCD4 # float
    m_flHDRColorScale = 0xCD8 # float
    m_Glow = 0xCE0 # C_LightGlowOverlay

class C_LightGlowOverlay:
    m_vecOrigin = 0xD0 # Vector
    m_vecDirection = 0xDC # Vector
    m_nMinDist = 0xE8 # int32_t
    m_nMaxDist = 0xEC # int32_t
    m_nOuterMaxDist = 0xF0 # int32_t
    m_bOneSided = 0xF4 # bool
    m_bModulateByDot = 0xF5 # bool

class C_LocalTempEntity:
    flags = 0xE98 # int32_t
    die = 0xE9C # GameTime_t
    m_flFrameMax = 0xEA0 # float
    x = 0xEA4 # float
    y = 0xEA8 # float
    fadeSpeed = 0xEAC # float
    bounceFactor = 0xEB0 # float
    hitSound = 0xEB4 # int32_t
    priority = 0xEB8 # int32_t
    tentOffset = 0xEBC # Vector
    m_vecTempEntAngVelocity = 0xEC8 # QAngle
    tempent_renderamt = 0xED4 # int32_t
    m_vecNormal = 0xED8 # Vector
    m_flSpriteScale = 0xEE4 # float
    m_nFlickerFrame = 0xEE8 # int32_t
    m_flFrameRate = 0xEEC # float
    m_flFrame = 0xEF0 # float
    m_pszImpactEffect = 0xEF8 # char*
    m_pszParticleEffect = 0xF00 # char*
    m_bParticleCollision = 0xF08 # bool
    m_iLastCollisionFrame = 0xF0C # int32_t
    m_vLastCollisionOrigin = 0xF10 # Vector
    m_vecTempEntVelocity = 0xF1C # Vector
    m_vecPrevAbsOrigin = 0xF28 # Vector
    m_vecTempEntAcceleration = 0xF34 # Vector

class C_MapVetoPickController:
    m_nDraftType = 0x550 # int32_t
    m_nTeamWinningCoinToss = 0x554 # int32_t
    m_nTeamWithFirstChoice = 0x558 # int32_t[64]
    m_nVoteMapIdsList = 0x658 # int32_t[7]
    m_nAccountIDs = 0x674 # int32_t[64]
    m_nMapId0 = 0x774 # int32_t[64]
    m_nMapId1 = 0x874 # int32_t[64]
    m_nMapId2 = 0x974 # int32_t[64]
    m_nMapId3 = 0xA74 # int32_t[64]
    m_nMapId4 = 0xB74 # int32_t[64]
    m_nMapId5 = 0xC74 # int32_t[64]
    m_nStartingSide0 = 0xD74 # int32_t[64]
    m_nCurrentPhase = 0xE74 # int32_t
    m_nPhaseStartTick = 0xE78 # int32_t
    m_nPhaseDurationTicks = 0xE7C # int32_t
    m_nPostDataUpdateTick = 0xE80 # int32_t
    m_bDisabledHud = 0xE84 # bool

class C_Melee:
    m_flThrowAt = 0x19F0 # GameTime_t

class C_MolotovProjectile:
    m_bIsIncGrenade = 0x1100 # bool

class C_Multimeter:
    m_hTargetC4 = 0xE88 # CHandle<C_PlantedC4>

class C_OmniLight:
    m_flInnerAngle = 0xF08 # float
    m_flOuterAngle = 0xF0C # float
    m_bShowLight = 0xF10 # bool

class C_ParticleSystem:
    m_szSnapshotFileName = 0xCC0 # char[512]
    m_bActive = 0xEC0 # bool
    m_bFrozen = 0xEC1 # bool
    m_flFreezeTransitionDuration = 0xEC4 # float
    m_nStopType = 0xEC8 # int32_t
    m_bAnimateDuringGameplayPause = 0xECC # bool
    m_iEffectIndex = 0xED0 # CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    m_flStartTime = 0xED8 # GameTime_t
    m_flPreSimTime = 0xEDC # float
    m_vServerControlPoints = 0xEE0 # Vector[4]
    m_iServerControlPointAssignments = 0xF10 # uint8_t[4]
    m_hControlPointEnts = 0xF14 # CHandle<C_BaseEntity>[64]
    m_bNoSave = 0x1014 # bool
    m_bNoFreeze = 0x1015 # bool
    m_bNoRamp = 0x1016 # bool
    m_bStartActive = 0x1017 # bool
    m_iszEffectName = 0x1018 # CUtlSymbolLarge
    m_iszControlPointNames = 0x1020 # CUtlSymbolLarge[64]
    m_nDataCP = 0x1220 # int32_t
    m_vecDataCPValue = 0x1224 # Vector
    m_nTintCP = 0x1230 # int32_t
    m_clrTint = 0x1234 # Color
    m_bOldActive = 0x1258 # bool
    m_bOldFrozen = 0x1259 # bool

class C_PathParticleRope:
    m_bStartActive = 0x540 # bool
    m_flMaxSimulationTime = 0x544 # float
    m_iszEffectName = 0x548 # CUtlSymbolLarge
    m_PathNodes_Name = 0x550 # CUtlVector<CUtlSymbolLarge>
    m_flParticleSpacing = 0x568 # float
    m_flSlack = 0x56C # float
    m_flRadius = 0x570 # float
    m_ColorTint = 0x574 # Color
    m_nEffectState = 0x578 # int32_t
    m_iEffectIndex = 0x580 # CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    m_PathNodes_Position = 0x588 # C_NetworkUtlVectorBase<Vector>
    m_PathNodes_TangentIn = 0x5A0 # C_NetworkUtlVectorBase<Vector>
    m_PathNodes_TangentOut = 0x5B8 # C_NetworkUtlVectorBase<Vector>
    m_PathNodes_Color = 0x5D0 # C_NetworkUtlVectorBase<Vector>
    m_PathNodes_PinEnabled = 0x5E8 # C_NetworkUtlVectorBase<bool>
    m_PathNodes_RadiusScale = 0x600 # C_NetworkUtlVectorBase<float>

class C_PhysMagnet:
    m_aAttachedObjectsFromServer = 0xE80 # CUtlVector<int32_t>
    m_aAttachedObjects = 0xE98 # CUtlVector<CHandle<C_BaseEntity>>

class C_PhysPropClientside:
    m_flTouchDelta = 0xFD0 # GameTime_t
    m_fDeathTime = 0xFD4 # GameTime_t
    m_impactEnergyScale = 0xFD8 # float
    m_inertiaScale = 0xFDC # float
    m_flDmgModBullet = 0xFE0 # float
    m_flDmgModClub = 0xFE4 # float
    m_flDmgModExplosive = 0xFE8 # float
    m_flDmgModFire = 0xFEC # float
    m_iszPhysicsDamageTableName = 0xFF0 # CUtlSymbolLarge
    m_iszBasePropData = 0xFF8 # CUtlSymbolLarge
    m_iInteractions = 0x1000 # int32_t
    m_bHasBreakPiecesOrCommands = 0x1004 # bool
    m_vecDamagePosition = 0x1008 # Vector
    m_vecDamageDirection = 0x1014 # Vector
    m_nDamageType = 0x1020 # int32_t

class C_PhysicsProp:
    m_bAwake = 0xFD0 # bool

class C_PickUpModelSlerper:
    m_hPlayerParent = 0xE80 # CHandle<C_BaseEntity>
    m_hItem = 0xE84 # CHandle<C_BaseEntity>
    m_flTimePickedUp = 0xE88 # float
    m_angOriginal = 0xE8C # QAngle
    m_vecPosOriginal = 0xE98 # Vector
    m_angRandom = 0xEA8 # QAngle

class C_PlantedC4:
    m_bBombTicking = 0xE80 # bool
    m_nBombSite = 0xE84 # int32_t
    m_nSourceSoundscapeHash = 0xE88 # int32_t
    m_entitySpottedState = 0xE90 # EntitySpottedState_t
    m_flNextGlow = 0xEA8 # GameTime_t
    m_flNextBeep = 0xEAC # GameTime_t
    m_flC4Blow = 0xEB0 # GameTime_t
    m_bCannotBeDefused = 0xEB4 # bool
    m_bHasExploded = 0xEB5 # bool
    m_flTimerLength = 0xEB8 # float
    m_bBeingDefused = 0xEBC # bool
    m_bTriggerWarning = 0xEC0 # float
    m_bExplodeWarning = 0xEC4 # float
    m_bC4Activated = 0xEC8 # bool
    m_bTenSecWarning = 0xEC9 # bool
    m_flDefuseLength = 0xECC # float
    m_flDefuseCountDown = 0xED0 # GameTime_t
    m_bBombDefused = 0xED4 # bool
    m_hBombDefuser = 0xED8 # CHandle<C_CSPlayerPawn>
    m_hControlPanel = 0xEDC # CHandle<C_BaseEntity>
    m_hDefuserMultimeter = 0xEE0 # CHandle<C_Multimeter>
    m_flNextRadarFlashTime = 0xEE4 # GameTime_t
    m_bRadarFlash = 0xEE8 # bool
    m_pBombDefuser = 0xEEC # CHandle<C_CSPlayerPawn>
    m_fLastDefuseTime = 0xEF0 # GameTime_t
    m_pPredictionOwner = 0xEF8 # CBasePlayerController*

class C_PlayerPing:
    m_hPlayer = 0x570 # CHandle<C_CSPlayerPawn>
    m_hPingedEntity = 0x574 # CHandle<C_BaseEntity>
    m_iType = 0x578 # int32_t
    m_bUrgent = 0x57C # bool
    m_szPlaceName = 0x57D # char[18]

class C_PlayerSprayDecal:
    m_nUniqueID = 0xCC0 # int32_t
    m_unAccountID = 0xCC4 # uint32_t
    m_unTraceID = 0xCC8 # uint32_t
    m_rtGcTime = 0xCCC # uint32_t
    m_vecEndPos = 0xCD0 # Vector
    m_vecStart = 0xCDC # Vector
    m_vecLeft = 0xCE8 # Vector
    m_vecNormal = 0xCF4 # Vector
    m_nPlayer = 0xD00 # int32_t
    m_nEntity = 0xD04 # int32_t
    m_nHitbox = 0xD08 # int32_t
    m_flCreationTime = 0xD0C # float
    m_nTintID = 0xD10 # int32_t
    m_nVersion = 0xD14 # uint8_t
    m_ubSignature = 0xD15 # uint8_t[128]
    m_SprayRenderHelper = 0xDA0 # CPlayerSprayDecalRenderHelper

class C_PlayerVisibility:
    m_flVisibilityStrength = 0x540 # float
    m_flFogDistanceMultiplier = 0x544 # float
    m_flFogMaxDensityMultiplier = 0x548 # float
    m_flFadeTime = 0x54C # float
    m_bStartDisabled = 0x550 # bool
    m_bIsEnabled = 0x551 # bool

class C_PointCamera:
    m_FOV = 0x540 # float
    m_Resolution = 0x544 # float
    m_bFogEnable = 0x548 # bool
    m_FogColor = 0x549 # Color
    m_flFogStart = 0x550 # float
    m_flFogEnd = 0x554 # float
    m_flFogMaxDensity = 0x558 # float
    m_bActive = 0x55C # bool
    m_bUseScreenAspectRatio = 0x55D # bool
    m_flAspectRatio = 0x560 # float
    m_bNoSky = 0x564 # bool
    m_fBrightness = 0x568 # float
    m_flZFar = 0x56C # float
    m_flZNear = 0x570 # float
    m_bCanHLTVUse = 0x574 # bool
    m_bDofEnabled = 0x575 # bool
    m_flDofNearBlurry = 0x578 # float
    m_flDofNearCrisp = 0x57C # float
    m_flDofFarCrisp = 0x580 # float
    m_flDofFarBlurry = 0x584 # float
    m_flDofTiltToGround = 0x588 # float
    m_TargetFOV = 0x58C # float
    m_DegreesPerSecond = 0x590 # float
    m_bIsOn = 0x594 # bool
    m_pNext = 0x598 # C_PointCamera*

class C_PointCameraVFOV:
    m_flVerticalFOV = 0x5A0 # float

class C_PointClientUIDialog:
    m_hActivator = 0xCF0 # CHandle<C_BaseEntity>
    m_bStartEnabled = 0xCF4 # bool

class C_PointClientUIHUD:
    m_bCheckCSSClasses = 0xCF8 # bool
    m_bIgnoreInput = 0xE80 # bool
    m_flWidth = 0xE84 # float
    m_flHeight = 0xE88 # float
    m_flDPI = 0xE8C # float
    m_flInteractDistance = 0xE90 # float
    m_flDepthOffset = 0xE94 # float
    m_unOwnerContext = 0xE98 # uint32_t
    m_unHorizontalAlign = 0xE9C # uint32_t
    m_unVerticalAlign = 0xEA0 # uint32_t
    m_unOrientation = 0xEA4 # uint32_t
    m_bAllowInteractionFromAllSceneWorlds = 0xEA8 # bool
    m_vecCSSClasses = 0xEB0 # C_NetworkUtlVectorBase<CUtlSymbolLarge>

class C_PointClientUIWorldPanel:
    m_bForceRecreateNextUpdate = 0xCF8 # bool
    m_bMoveViewToPlayerNextThink = 0xCF9 # bool
    m_bCheckCSSClasses = 0xCFA # bool
    m_anchorDeltaTransform = 0xD00 # CTransform
    m_pOffScreenIndicator = 0xEA0 # CPointOffScreenIndicatorUi*
    m_bIgnoreInput = 0xEC8 # bool
    m_bLit = 0xEC9 # bool
    m_bFollowPlayerAcrossTeleport = 0xECA # bool
    m_flWidth = 0xECC # float
    m_flHeight = 0xED0 # float
    m_flDPI = 0xED4 # float
    m_flInteractDistance = 0xED8 # float
    m_flDepthOffset = 0xEDC # float
    m_unOwnerContext = 0xEE0 # uint32_t
    m_unHorizontalAlign = 0xEE4 # uint32_t
    m_unVerticalAlign = 0xEE8 # uint32_t
    m_unOrientation = 0xEEC # uint32_t
    m_bAllowInteractionFromAllSceneWorlds = 0xEF0 # bool
    m_vecCSSClasses = 0xEF8 # C_NetworkUtlVectorBase<CUtlSymbolLarge>
    m_bOpaque = 0xF10 # bool
    m_bNoDepth = 0xF11 # bool
    m_bRenderBackface = 0xF12 # bool
    m_bUseOffScreenIndicator = 0xF13 # bool
    m_bExcludeFromSaveGames = 0xF14 # bool
    m_bGrabbable = 0xF15 # bool
    m_bOnlyRenderToTexture = 0xF16 # bool
    m_bDisableMipGen = 0xF17 # bool
    m_nExplicitImageLayout = 0xF18 # int32_t

class C_PointClientUIWorldTextPanel:
    m_messageText = 0xF20 # char[512]

class C_PointCommentaryNode:
    m_bActive = 0xE88 # bool
    m_bWasActive = 0xE89 # bool
    m_flEndTime = 0xE8C # GameTime_t
    m_flStartTime = 0xE90 # GameTime_t
    m_flStartTimeInCommentary = 0xE94 # float
    m_iszCommentaryFile = 0xE98 # CUtlSymbolLarge
    m_iszTitle = 0xEA0 # CUtlSymbolLarge
    m_iszSpeakers = 0xEA8 # CUtlSymbolLarge
    m_iNodeNumber = 0xEB0 # int32_t
    m_iNodeNumberMax = 0xEB4 # int32_t
    m_bListenedTo = 0xEB8 # bool
    m_hViewPosition = 0xEC8 # CHandle<C_BaseEntity>
    m_bRestartAfterRestore = 0xECC # bool

class C_PointValueRemapper:
    m_bDisabled = 0x540 # bool
    m_bDisabledOld = 0x541 # bool
    m_bUpdateOnClient = 0x542 # bool
    m_nInputType = 0x544 # ValueRemapperInputType_t
    m_hRemapLineStart = 0x548 # CHandle<C_BaseEntity>
    m_hRemapLineEnd = 0x54C # CHandle<C_BaseEntity>
    m_flMaximumChangePerSecond = 0x550 # float
    m_flDisengageDistance = 0x554 # float
    m_flEngageDistance = 0x558 # float
    m_bRequiresUseKey = 0x55C # bool
    m_nOutputType = 0x560 # ValueRemapperOutputType_t
    m_hOutputEntities = 0x568 # C_NetworkUtlVectorBase<CHandle<C_BaseEntity>>
    m_nHapticsType = 0x580 # ValueRemapperHapticsType_t
    m_nMomentumType = 0x584 # ValueRemapperMomentumType_t
    m_flMomentumModifier = 0x588 # float
    m_flSnapValue = 0x58C # float
    m_flCurrentMomentum = 0x590 # float
    m_nRatchetType = 0x594 # ValueRemapperRatchetType_t
    m_flRatchetOffset = 0x598 # float
    m_flInputOffset = 0x59C # float
    m_bEngaged = 0x5A0 # bool
    m_bFirstUpdate = 0x5A1 # bool
    m_flPreviousValue = 0x5A4 # float
    m_flPreviousUpdateTickTime = 0x5A8 # GameTime_t
    m_vecPreviousTestPoint = 0x5AC # Vector

class C_PointWorldText:
    m_bForceRecreateNextUpdate = 0xCC8 # bool
    m_messageText = 0xCD8 # char[512]
    m_FontName = 0xED8 # char[64]
    m_bEnabled = 0xF18 # bool
    m_bFullbright = 0xF19 # bool
    m_flWorldUnitsPerPx = 0xF1C # float
    m_flFontSize = 0xF20 # float
    m_flDepthOffset = 0xF24 # float
    m_Color = 0xF28 # Color
    m_nJustifyHorizontal = 0xF2C # PointWorldTextJustifyHorizontal_t
    m_nJustifyVertical = 0xF30 # PointWorldTextJustifyVertical_t
    m_nReorientMode = 0xF34 # PointWorldTextReorientMode_t

class C_PostProcessingVolume:
    m_hPostSettings = 0xCD8 # CStrongHandle<InfoForResourceTypeCPostProcessingResource>
    m_flFadeDuration = 0xCE0 # float
    m_flMinLogExposure = 0xCE4 # float
    m_flMaxLogExposure = 0xCE8 # float
    m_flMinExposure = 0xCEC # float
    m_flMaxExposure = 0xCF0 # float
    m_flExposureCompensation = 0xCF4 # float
    m_flExposureFadeSpeedUp = 0xCF8 # float
    m_flExposureFadeSpeedDown = 0xCFC # float
    m_flTonemapEVSmoothingRange = 0xD00 # float
    m_bMaster = 0xD04 # bool
    m_bExposureControl = 0xD05 # bool
    m_flRate = 0xD08 # float
    m_flTonemapPercentTarget = 0xD0C # float
    m_flTonemapPercentBrightPixels = 0xD10 # float
    m_flTonemapMinAvgLum = 0xD14 # float

class C_Precipitation:
    m_flDensity = 0xCC8 # float
    m_flParticleInnerDist = 0xCD8 # float
    m_pParticleDef = 0xCE0 # char*
    m_tParticlePrecipTraceTimer = 0xD08 # TimedEvent[1]
    m_bActiveParticlePrecipEmitter = 0xD10 # bool[1]
    m_bParticlePrecipInitialized = 0xD11 # bool
    m_bHasSimulatedSinceLastSceneObjectUpdate = 0xD12 # bool
    m_nAvailableSheetSequencesMaxIndex = 0xD14 # int32_t

class C_PredictedViewModel:
    m_LagAnglesHistory = 0xEE8 # QAngle
    m_vPredictedOffset = 0xF00 # Vector

class C_RagdollManager:
    m_iCurrentMaxRagdollCount = 0x540 # int8_t

class C_RagdollProp:
    m_ragPos = 0xE88 # C_NetworkUtlVectorBase<Vector>
    m_ragAngles = 0xEA0 # C_NetworkUtlVectorBase<QAngle>
    m_flBlendWeight = 0xEB8 # float
    m_hRagdollSource = 0xEBC # CHandle<C_BaseEntity>
    m_iEyeAttachment = 0xEC0 # AttachmentHandle_t
    m_flBlendWeightCurrent = 0xEC4 # float
    m_parentPhysicsBoneIndices = 0xEC8 # CUtlVector<int32_t>
    m_worldSpaceBoneComputationOrder = 0xEE0 # CUtlVector<int32_t>

class C_RagdollPropAttached:
    m_boneIndexAttached = 0xEF8 # uint32_t
    m_ragdollAttachedObjectIndex = 0xEFC # uint32_t
    m_attachmentPointBoneSpace = 0xF00 # Vector
    m_attachmentPointRagdollSpace = 0xF0C # Vector
    m_vecOffset = 0xF18 # Vector
    m_parentTime = 0xF24 # float
    m_bHasParent = 0xF28 # bool

class C_RectLight:
    m_bShowLight = 0xF08 # bool

class C_RetakeGameRules:
    m_nMatchSeed = 0xF8 # int32_t
    m_bBlockersPresent = 0xFC # bool
    m_bRoundInProgress = 0xFD # bool
    m_iFirstSecondHalfRound = 0x100 # int32_t
    m_iBombSite = 0x104 # int32_t

class C_RopeKeyframe:
    m_LinksTouchingSomething = 0xCC8 # CBitVec<10>
    m_nLinksTouchingSomething = 0xCCC # int32_t
    m_bApplyWind = 0xCD0 # bool
    m_fPrevLockedPoints = 0xCD4 # int32_t
    m_iForcePointMoveCounter = 0xCD8 # int32_t
    m_bPrevEndPointPos = 0xCDC # bool[2]
    m_vPrevEndPointPos = 0xCE0 # Vector[2]
    m_flCurScroll = 0xCF8 # float
    m_flScrollSpeed = 0xCFC # float
    m_RopeFlags = 0xD00 # uint16_t
    m_iRopeMaterialModelIndex = 0xD08 # CStrongHandle<InfoForResourceTypeIMaterial2>
    m_LightValues = 0xF80 # Vector[10]
    m_nSegments = 0xFF8 # uint8_t
    m_hStartPoint = 0xFFC # CHandle<C_BaseEntity>
    m_hEndPoint = 0x1000 # CHandle<C_BaseEntity>
    m_iStartAttachment = 0x1004 # AttachmentHandle_t
    m_iEndAttachment = 0x1005 # AttachmentHandle_t
    m_Subdiv = 0x1006 # uint8_t
    m_RopeLength = 0x1008 # int16_t
    m_Slack = 0x100A # int16_t
    m_TextureScale = 0x100C # float
    m_fLockedPoints = 0x1010 # uint8_t
    m_nChangeCount = 0x1011 # uint8_t
    m_Width = 0x1014 # float
    m_PhysicsDelegate = 0x1018 # C_RopeKeyframe::CPhysicsDelegate
    m_hMaterial = 0x1028 # CStrongHandle<InfoForResourceTypeIMaterial2>
    m_TextureHeight = 0x1030 # int32_t
    m_vecImpulse = 0x1034 # Vector
    m_vecPreviousImpulse = 0x1040 # Vector
    m_flCurrentGustTimer = 0x104C # float
    m_flCurrentGustLifetime = 0x1050 # float
    m_flTimeToNextGust = 0x1054 # float
    m_vWindDir = 0x1058 # Vector
    m_vColorMod = 0x1064 # Vector
    m_vCachedEndPointAttachmentPos = 0x1070 # Vector[2]
    m_vCachedEndPointAttachmentAngle = 0x1088 # QAngle[2]
    m_bConstrainBetweenEndpoints = 0x10A0 # bool
    m_bEndPointAttachmentPositionsDirty = 0x0 # bitfield:1
    m_bEndPointAttachmentAnglesDirty = 0x0 # bitfield:1
    m_bNewDataThisFrame = 0x0 # bitfield:1
    m_bPhysicsInitted = 0x0 # bitfield:1

class C_RopeKeyframe_CPhysicsDelegate:
    m_pKeyframe = 0x8 # C_RopeKeyframe*

class C_SceneEntity:
    m_bIsPlayingBack = 0x548 # bool
    m_bPaused = 0x549 # bool
    m_bMultiplayer = 0x54A # bool
    m_bAutogenerated = 0x54B # bool
    m_flForceClientTime = 0x54C # float
    m_nSceneStringIndex = 0x550 # uint16_t
    m_bClientOnly = 0x552 # bool
    m_hOwner = 0x554 # CHandle<C_BaseFlex>
    m_hActorList = 0x558 # C_NetworkUtlVectorBase<CHandle<C_BaseFlex>>
    m_bWasPlaying = 0x570 # bool
    m_QueuedEvents = 0x580 # CUtlVector<C_SceneEntity::QueuedEvents_t>
    m_flCurrentTime = 0x598 # float

class C_SceneEntity_QueuedEvents_t:
    starttime = 0x0 # float

class C_ShatterGlassShardPhysics:
    m_ShardDesc = 0xFE0 # shard_model_desc_t

class C_SkyCamera:
    m_skyboxData = 0x540 # sky3dparams_t
    m_skyboxSlotToken = 0x5D0 # CUtlStringToken
    m_bUseAngles = 0x5D4 # bool
    m_pNext = 0x5D8 # C_SkyCamera*

class C_SmokeGrenadeProjectile:
    m_nSmokeEffectTickBegin = 0x1108 # int32_t
    m_bDidSmokeEffect = 0x110C # bool
    m_nRandomSeed = 0x1110 # int32_t
    m_vSmokeColor = 0x1114 # Vector
    m_vSmokeDetonationPos = 0x1120 # Vector
    m_VoxelFrameData = 0x1130 # CUtlVector<uint8_t>
    m_bSmokeVolumeDataReceived = 0x1148 # bool
    m_bSmokeEffectSpawned = 0x1149 # bool

class C_SoundAreaEntityBase:
    m_bDisabled = 0x540 # bool
    m_bWasEnabled = 0x548 # bool
    m_iszSoundAreaType = 0x550 # CUtlSymbolLarge
    m_vPos = 0x558 # Vector

class C_SoundAreaEntityOrientedBox:
    m_vMin = 0x568 # Vector
    m_vMax = 0x574 # Vector

class C_SoundAreaEntitySphere:
    m_flRadius = 0x568 # float

class C_SoundOpvarSetPointBase:
    m_iszStackName = 0x540 # CUtlSymbolLarge
    m_iszOperatorName = 0x548 # CUtlSymbolLarge
    m_iszOpvarName = 0x550 # CUtlSymbolLarge
    m_iOpvarIndex = 0x558 # int32_t
    m_bUseAutoCompare = 0x55C # bool

class C_SpotlightEnd:
    m_flLightScale = 0xCC0 # float
    m_Radius = 0xCC4 # float

class C_Sprite:
    m_hSpriteMaterial = 0xCD8 # CStrongHandle<InfoForResourceTypeIMaterial2>
    m_hAttachedToEntity = 0xCE0 # CHandle<C_BaseEntity>
    m_nAttachment = 0xCE4 # AttachmentHandle_t
    m_flSpriteFramerate = 0xCE8 # float
    m_flFrame = 0xCEC # float
    m_flDieTime = 0xCF0 # GameTime_t
    m_nBrightness = 0xD00 # uint32_t
    m_flBrightnessDuration = 0xD04 # float
    m_flSpriteScale = 0xD08 # float
    m_flScaleDuration = 0xD0C # float
    m_bWorldSpaceScale = 0xD10 # bool
    m_flGlowProxySize = 0xD14 # float
    m_flHDRColorScale = 0xD18 # float
    m_flLastTime = 0xD1C # GameTime_t
    m_flMaxFrame = 0xD20 # float
    m_flStartScale = 0xD24 # float
    m_flDestScale = 0xD28 # float
    m_flScaleTimeStart = 0xD2C # GameTime_t
    m_nStartBrightness = 0xD30 # int32_t
    m_nDestBrightness = 0xD34 # int32_t
    m_flBrightnessTimeStart = 0xD38 # GameTime_t
    m_hOldSpriteMaterial = 0xD40 # CWeakHandle<InfoForResourceTypeIMaterial2>
    m_nSpriteWidth = 0xDE8 # int32_t
    m_nSpriteHeight = 0xDEC # int32_t

class C_Sun:
    m_fxSSSunFlareEffectIndex = 0xCC0 # ParticleIndex_t
    m_fxSunFlareEffectIndex = 0xCC4 # ParticleIndex_t
    m_fdistNormalize = 0xCC8 # float
    m_vSunPos = 0xCCC # Vector
    m_vDirection = 0xCD8 # Vector
    m_iszEffectName = 0xCE8 # CUtlSymbolLarge
    m_iszSSEffectName = 0xCF0 # CUtlSymbolLarge
    m_clrOverlay = 0xCF8 # Color
    m_bOn = 0xCFC # bool
    m_bmaxColor = 0xCFD # bool
    m_flSize = 0xD00 # float
    m_flHazeScale = 0xD04 # float
    m_flRotation = 0xD08 # float
    m_flHDRColorScale = 0xD0C # float
    m_flAlphaHaze = 0xD10 # float
    m_flAlphaScale = 0xD14 # float
    m_flAlphaHdr = 0xD18 # float
    m_flFarZScale = 0xD1C # float

class C_SunGlowOverlay:
    m_bModulateByDot = 0xD0 # bool

class C_Team:
    m_aPlayerControllers = 0x540 # C_NetworkUtlVectorBase<CHandle<CBasePlayerController>>
    m_aPlayers = 0x558 # C_NetworkUtlVectorBase<CHandle<C_BasePlayerPawn>>
    m_iScore = 0x570 # int32_t
    m_szTeamname = 0x574 # char[129]

class C_TeamRoundTimer:
    m_bTimerPaused = 0x540 # bool
    m_flTimeRemaining = 0x544 # float
    m_flTimerEndTime = 0x548 # GameTime_t
    m_bIsDisabled = 0x54C # bool
    m_bShowInHUD = 0x54D # bool
    m_nTimerLength = 0x550 # int32_t
    m_nTimerInitialLength = 0x554 # int32_t
    m_nTimerMaxLength = 0x558 # int32_t
    m_bAutoCountdown = 0x55C # bool
    m_nSetupTimeLength = 0x560 # int32_t
    m_nState = 0x564 # int32_t
    m_bStartPaused = 0x568 # bool
    m_bInCaptureWatchState = 0x569 # bool
    m_flTotalTime = 0x56C # float
    m_bStopWatchTimer = 0x570 # bool
    m_bFireFinished = 0x571 # bool
    m_bFire5MinRemain = 0x572 # bool
    m_bFire4MinRemain = 0x573 # bool
    m_bFire3MinRemain = 0x574 # bool
    m_bFire2MinRemain = 0x575 # bool
    m_bFire1MinRemain = 0x576 # bool
    m_bFire30SecRemain = 0x577 # bool
    m_bFire10SecRemain = 0x578 # bool
    m_bFire5SecRemain = 0x579 # bool
    m_bFire4SecRemain = 0x57A # bool
    m_bFire3SecRemain = 0x57B # bool
    m_bFire2SecRemain = 0x57C # bool
    m_bFire1SecRemain = 0x57D # bool
    m_nOldTimerLength = 0x580 # int32_t
    m_nOldTimerState = 0x584 # int32_t

class C_TextureBasedAnimatable:
    m_bLoop = 0xCC0 # bool
    m_flFPS = 0xCC4 # float
    m_hPositionKeys = 0xCC8 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_hRotationKeys = 0xCD0 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_vAnimationBoundsMin = 0xCD8 # Vector
    m_vAnimationBoundsMax = 0xCE4 # Vector
    m_flStartTime = 0xCF0 # float
    m_flStartFrame = 0xCF4 # float

class C_TonemapController2:
    m_flAutoExposureMin = 0x540 # float
    m_flAutoExposureMax = 0x544 # float
    m_flTonemapPercentTarget = 0x548 # float
    m_flTonemapPercentBrightPixels = 0x54C # float
    m_flTonemapMinAvgLum = 0x550 # float
    m_flExposureAdaptationSpeedUp = 0x554 # float
    m_flExposureAdaptationSpeedDown = 0x558 # float
    m_flTonemapEVSmoothingRange = 0x55C # float

class C_TriggerBuoyancy:
    m_BuoyancyHelper = 0xCC8 # CBuoyancyHelper
    m_flFluidDensity = 0xCE8 # float

class C_ViewmodelWeapon:
    m_worldModel = 0xE80 # char*

class C_VoteController:
    m_iActiveIssueIndex = 0x550 # int32_t
    m_iOnlyTeamToVote = 0x554 # int32_t
    m_nVoteOptionCount = 0x558 # int32_t[5]
    m_nPotentialVotes = 0x56C # int32_t
    m_bVotesDirty = 0x570 # bool
    m_bTypeDirty = 0x571 # bool
    m_bIsYesNoVote = 0x572 # bool

class C_WeaponBaseItem:
    m_SequenceCompleteTimer = 0x19F0 # CountdownTimer
    m_bRedraw = 0x1A08 # bool

class C_WeaponShield:
    m_flDisplayHealth = 0x1A10 # float

class C_WeaponTaser:
    m_fFireTime = 0x1A10 # GameTime_t

class C_fogplayerparams_t:
    m_hCtrl = 0x8 # CHandle<C_FogController>
    m_flTransitionTime = 0xC # float
    m_OldColor = 0x10 # Color
    m_flOldStart = 0x14 # float
    m_flOldEnd = 0x18 # float
    m_flOldMaxDensity = 0x1C # float
    m_flOldHDRColorScale = 0x20 # float
    m_flOldFarZ = 0x24 # float
    m_NewColor = 0x28 # Color
    m_flNewStart = 0x2C # float
    m_flNewEnd = 0x30 # float
    m_flNewMaxDensity = 0x34 # float
    m_flNewHDRColorScale = 0x38 # float
    m_flNewFarZ = 0x3C # float

class CompMatMutatorCondition_t:
    m_nMutatorCondition = 0x0 # CompMatPropertyMutatorConditionType_t
    m_strMutatorConditionContainerName = 0x8 # CUtlString
    m_strMutatorConditionContainerVarName = 0x10 # CUtlString
    m_strMutatorConditionContainerVarValue = 0x18 # CUtlString
    m_bPassWhenTrue = 0x20 # bool

class CompMatPropertyMutator_t:
    m_bEnabled = 0x0 # bool
    m_nMutatorCommandType = 0x4 # CompMatPropertyMutatorType_t
    m_strInitWith_Container = 0x8 # CUtlString
    m_strCopyProperty_InputContainerSrc = 0x10 # CUtlString
    m_strCopyProperty_InputContainerProperty = 0x18 # CUtlString
    m_strCopyProperty_TargetProperty = 0x20 # CUtlString
    m_strRandomRollInputVars_SeedInputVar = 0x28 # CUtlString
    m_vecRandomRollInputVars_InputVarsToRoll = 0x30 # CUtlVector<CUtlString>
    m_strCopyMatchingKeys_InputContainerSrc = 0x48 # CUtlString
    m_strCopyKeysWithSuffix_InputContainerSrc = 0x50 # CUtlString
    m_strCopyKeysWithSuffix_FindSuffix = 0x58 # CUtlString
    m_strCopyKeysWithSuffix_ReplaceSuffix = 0x60 # CUtlString
    m_nSetValue_Value = 0x68 # CompositeMaterialInputLooseVariable_t
    m_strGenerateTexture_TargetParam = 0x2D8 # CUtlString
    m_strGenerateTexture_InitialContainer = 0x2E0 # CUtlString
    m_nResolution = 0x2E8 # int32_t
    m_bIsScratchTarget = 0x2EC # bool
    m_bSplatDebugInfo = 0x2ED # bool
    m_bCaptureInRenderDoc = 0x2EE # bool
    m_vecTexGenInstructions = 0x2F0 # CUtlVector<CompMatPropertyMutator_t>
    m_vecConditionalMutators = 0x308 # CUtlVector<CompMatPropertyMutator_t>
    m_strPopInputQueue_Container = 0x320 # CUtlString
    m_strDrawText_InputContainerSrc = 0x328 # CUtlString
    m_strDrawText_InputContainerProperty = 0x330 # CUtlString
    m_vecDrawText_Position = 0x338 # Vector2D
    m_colDrawText_Color = 0x340 # Color
    m_strDrawText_Font = 0x348 # CUtlString
    m_vecConditions = 0x350 # CUtlVector<CompMatMutatorCondition_t>

class CompositeMaterialAssemblyProcedure_t:
    m_vecCompMatIncludes = 0x0 # CUtlVector<CResourceName>
    m_vecMatchFilters = 0x18 # CUtlVector<CompositeMaterialMatchFilter_t>
    m_vecCompositeInputContainers = 0x30 # CUtlVector<CompositeMaterialInputContainer_t>
    m_vecPropertyMutators = 0x48 # CUtlVector<CompMatPropertyMutator_t>

class CompositeMaterialEditorPoint_t:
    m_ModelName = 0x0 # CResourceName
    m_nSequenceIndex = 0xE0 # int32_t
    m_flCycle = 0xE4 # float
    m_KVModelStateChoices = 0xE8 # KeyValues3
    m_bEnableChildModel = 0xF8 # bool
    m_ChildModelName = 0x100 # CResourceName
    m_vecCompositeMaterialAssemblyProcedures = 0x1E0 # CUtlVector<CompositeMaterialAssemblyProcedure_t>
    m_vecCompositeMaterials = 0x1F8 # CUtlVector<CompositeMaterial_t>

class CompositeMaterialInputContainer_t:
    m_bEnabled = 0x0 # bool
    m_nCompositeMaterialInputContainerSourceType = 0x4 # CompositeMaterialInputContainerSourceType_t
    m_strSpecificContainerMaterial = 0x8 # CResourceName
    m_strAttrName = 0xE8 # CUtlString
    m_strAlias = 0xF0 # CUtlString
    m_vecLooseVariables = 0xF8 # CUtlVector<CompositeMaterialInputLooseVariable_t>
    m_strAttrNameForVar = 0x110 # CUtlString
    m_bExposeExternally = 0x118 # bool

class CompositeMaterialInputLooseVariable_t:
    m_strName = 0x0 # CUtlString
    m_bExposeExternally = 0x8 # bool
    m_strExposedFriendlyName = 0x10 # CUtlString
    m_strExposedFriendlyGroupName = 0x18 # CUtlString
    m_bExposedVariableIsFixedRange = 0x20 # bool
    m_strExposedVisibleWhenTrue = 0x28 # CUtlString
    m_strExposedHiddenWhenTrue = 0x30 # CUtlString
    m_nVariableType = 0x38 # CompositeMaterialInputLooseVariableType_t
    m_bValueBoolean = 0x3C # bool
    m_nValueIntX = 0x40 # int32_t
    m_nValueIntY = 0x44 # int32_t
    m_nValueIntZ = 0x48 # int32_t
    m_nValueIntW = 0x4C # int32_t
    m_bHasFloatBounds = 0x50 # bool
    m_flValueFloatX = 0x54 # float
    m_flValueFloatX_Min = 0x58 # float
    m_flValueFloatX_Max = 0x5C # float
    m_flValueFloatY = 0x60 # float
    m_flValueFloatY_Min = 0x64 # float
    m_flValueFloatY_Max = 0x68 # float
    m_flValueFloatZ = 0x6C # float
    m_flValueFloatZ_Min = 0x70 # float
    m_flValueFloatZ_Max = 0x74 # float
    m_flValueFloatW = 0x78 # float
    m_flValueFloatW_Min = 0x7C # float
    m_flValueFloatW_Max = 0x80 # float
    m_cValueColor4 = 0x84 # Color
    m_nValueSystemVar = 0x88 # CompositeMaterialVarSystemVar_t
    m_strResourceMaterial = 0x90 # CResourceName
    m_strTextureContentAssetPath = 0x170 # CUtlString
    m_strTextureRuntimeResourcePath = 0x178 # CResourceName
    m_strTextureCompilationVtexTemplate = 0x258 # CUtlString
    m_nTextureType = 0x260 # CompositeMaterialInputTextureType_t
    m_strString = 0x268 # CUtlString

class CompositeMaterialMatchFilter_t:
    m_nCompositeMaterialMatchFilterType = 0x0 # CompositeMaterialMatchFilterType_t
    m_strMatchFilter = 0x8 # CUtlString
    m_strMatchValue = 0x10 # CUtlString
    m_bPassWhenTrue = 0x18 # bool

class CompositeMaterial_t:
    m_TargetKVs = 0x8 # KeyValues3
    m_PreGenerationKVs = 0x18 # KeyValues3
    m_FinalKVs = 0x28 # KeyValues3
    m_vecGeneratedTextures = 0x40 # CUtlVector<GeneratedTextureHandle_t>

class CountdownTimer:
    m_duration = 0x8 # float
    m_timestamp = 0xC # GameTime_t
    m_timescale = 0x10 # float
    m_nWorldGroupId = 0x14 # WorldGroupId_t

class EngineCountdownTimer:
    m_duration = 0x8 # float
    m_timestamp = 0xC # float
    m_timescale = 0x10 # float

class EntityRenderAttribute_t:
    m_ID = 0x30 # CUtlStringToken
    m_Values = 0x34 # Vector4D

class EntitySpottedState_t:
    m_bSpotted = 0x8 # bool
    m_bSpottedByMask = 0xC # uint32_t[2]

class GeneratedTextureHandle_t:
    m_strBitmapName = 0x0 # CUtlString

class IntervalTimer:
    m_timestamp = 0x8 # GameTime_t
    m_nWorldGroupId = 0xC # WorldGroupId_t

class PhysicsRagdollPose_t:
    __m_pChainEntity = 0x8 # CNetworkVarChainer
    m_Transforms = 0x30 # C_NetworkUtlVectorBase<CTransform>
    m_hOwner = 0x48 # CHandle<C_BaseEntity>
    m_bDirty = 0x68 # bool

class SellbackPurchaseEntry_t:
    m_unDefIdx = 0x30 # uint16_t
    m_nCost = 0x34 # int32_t
    m_nPrevArmor = 0x38 # int32_t
    m_bPrevHelmet = 0x3C # bool
    m_hItem = 0x40 # CEntityHandle

class ServerAuthoritativeWeaponSlot_t:
    unClass = 0x28 # uint16_t
    unSlot = 0x2A # uint16_t
    unItemDefIdx = 0x2C # uint16_t

class TimedEvent:
    m_TimeBetweenEvents = 0x0 # float
    m_fNextEvent = 0x4 # float

class VPhysicsCollisionAttribute_t:
    m_nInteractsAs = 0x8 # uint64_t
    m_nInteractsWith = 0x10 # uint64_t
    m_nInteractsExclude = 0x18 # uint64_t
    m_nEntityId = 0x20 # uint32_t
    m_nOwnerId = 0x24 # uint32_t
    m_nHierarchyId = 0x28 # uint16_t
    m_nCollisionGroup = 0x2A # uint8_t
    m_nCollisionFunctionMask = 0x2B # uint8_t

class ViewAngleServerChange_t:
    nType = 0x30 # FixAngleSet_t
    qAngle = 0x34 # QAngle
    nIndex = 0x40 # uint32_t

class WeaponPurchaseCount_t:
    m_nItemDefIndex = 0x30 # uint16_t
    m_nCount = 0x32 # uint16_t

class WeaponPurchaseTracker_t:
    m_weaponPurchases = 0x8 # C_UtlVectorEmbeddedNetworkVar<WeaponPurchaseCount_t>

class audioparams_t:
    localSound = 0x8 # Vector[8]
    soundscapeIndex = 0x68 # int32_t
    localBits = 0x6C # uint8_t
    soundscapeEntityListIndex = 0x70 # int32_t
    soundEventHash = 0x74 # uint32_t

class fogparams_t:
    dirPrimary = 0x8 # Vector
    colorPrimary = 0x14 # Color
    colorSecondary = 0x18 # Color
    colorPrimaryLerpTo = 0x1C # Color
    colorSecondaryLerpTo = 0x20 # Color
    start = 0x24 # float
    end = 0x28 # float
    farz = 0x2C # float
    maxdensity = 0x30 # float
    exponent = 0x34 # float
    HDRColorScale = 0x38 # float
    skyboxFogFactor = 0x3C # float
    skyboxFogFactorLerpTo = 0x40 # float
    startLerpTo = 0x44 # float
    endLerpTo = 0x48 # float
    maxdensityLerpTo = 0x4C # float
    lerptime = 0x50 # GameTime_t
    duration = 0x54 # float
    blendtobackground = 0x58 # float
    scattering = 0x5C # float
    locallightscale = 0x60 # float
    enable = 0x64 # bool
    blend = 0x65 # bool
    m_bNoReflectionFog = 0x66 # bool
    m_bPadding = 0x67 # bool

class shard_model_desc_t:
    m_nModelID = 0x8 # int32_t
    m_hMaterial = 0x10 # CStrongHandle<InfoForResourceTypeIMaterial2>
    m_solid = 0x18 # ShardSolid_t
    m_ShatterPanelMode = 0x19 # ShatterPanelMode
    m_vecPanelSize = 0x1C # Vector2D
    m_vecStressPositionA = 0x24 # Vector2D
    m_vecStressPositionB = 0x2C # Vector2D
    m_vecPanelVertices = 0x38 # C_NetworkUtlVectorBase<Vector2D>
    m_flGlassHalfThickness = 0x50 # float
    m_bHasParent = 0x54 # bool
    m_bParentFrozen = 0x55 # bool
    m_SurfacePropStringToken = 0x58 # CUtlStringToken

class sky3dparams_t:
    scale = 0x8 # int16_t
    origin = 0xC # Vector
    bClip3DSkyBoxNearToWorldFar = 0x18 # bool
    flClip3DSkyBoxNearToWorldFarOffset = 0x1C # float
    fog = 0x20 # fogparams_t
    m_nWorldGroupID = 0x88 # WorldGroupId_t

```

`SDK/client.dll.rs`:

```rs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:27.308450600 UTC
 */

#![allow(non_snake_case, non_upper_case_globals)]

pub mod ActiveModelConfig_t {
    pub const m_Handle: usize = 0x28; // ModelConfigHandle_t
    pub const m_Name: usize = 0x30; // CUtlSymbolLarge
    pub const m_AssociatedEntities: usize = 0x38; // C_NetworkUtlVectorBase<CHandle<C_BaseModelEntity>>
    pub const m_AssociatedEntityNames: usize = 0x50; // C_NetworkUtlVectorBase<CUtlSymbolLarge>
}

pub mod CAnimGraphNetworkedVariables {
    pub const m_PredNetBoolVariables: usize = 0x8; // C_NetworkUtlVectorBase<uint32_t>
    pub const m_PredNetByteVariables: usize = 0x20; // C_NetworkUtlVectorBase<uint8_t>
    pub const m_PredNetUInt16Variables: usize = 0x38; // C_NetworkUtlVectorBase<uint16_t>
    pub const m_PredNetIntVariables: usize = 0x50; // C_NetworkUtlVectorBase<int32_t>
    pub const m_PredNetUInt32Variables: usize = 0x68; // C_NetworkUtlVectorBase<uint32_t>
    pub const m_PredNetUInt64Variables: usize = 0x80; // C_NetworkUtlVectorBase<uint64_t>
    pub const m_PredNetFloatVariables: usize = 0x98; // C_NetworkUtlVectorBase<float>
    pub const m_PredNetVectorVariables: usize = 0xB0; // C_NetworkUtlVectorBase<Vector>
    pub const m_PredNetQuaternionVariables: usize = 0xC8; // C_NetworkUtlVectorBase<Quaternion>
    pub const m_OwnerOnlyPredNetBoolVariables: usize = 0xE0; // C_NetworkUtlVectorBase<uint32_t>
    pub const m_OwnerOnlyPredNetByteVariables: usize = 0xF8; // C_NetworkUtlVectorBase<uint8_t>
    pub const m_OwnerOnlyPredNetUInt16Variables: usize = 0x110; // C_NetworkUtlVectorBase<uint16_t>
    pub const m_OwnerOnlyPredNetIntVariables: usize = 0x128; // C_NetworkUtlVectorBase<int32_t>
    pub const m_OwnerOnlyPredNetUInt32Variables: usize = 0x140; // C_NetworkUtlVectorBase<uint32_t>
    pub const m_OwnerOnlyPredNetUInt64Variables: usize = 0x158; // C_NetworkUtlVectorBase<uint64_t>
    pub const m_OwnerOnlyPredNetFloatVariables: usize = 0x170; // C_NetworkUtlVectorBase<float>
    pub const m_OwnerOnlyPredNetVectorVariables: usize = 0x188; // C_NetworkUtlVectorBase<Vector>
    pub const m_OwnerOnlyPredNetQuaternionVariables: usize = 0x1A0; // C_NetworkUtlVectorBase<Quaternion>
    pub const m_nBoolVariablesCount: usize = 0x1B8; // int32_t
    pub const m_nOwnerOnlyBoolVariablesCount: usize = 0x1BC; // int32_t
    pub const m_nRandomSeedOffset: usize = 0x1C0; // int32_t
    pub const m_flLastTeleportTime: usize = 0x1C4; // float
}

pub mod CAttributeList {
    pub const m_Attributes: usize = 0x8; // C_UtlVectorEmbeddedNetworkVar<CEconItemAttribute>
    pub const m_pManager: usize = 0x58; // CAttributeManager*
}

pub mod CAttributeManager {
    pub const m_Providers: usize = 0x8; // CUtlVector<CHandle<C_BaseEntity>>
    pub const m_iReapplyProvisionParity: usize = 0x20; // int32_t
    pub const m_hOuter: usize = 0x24; // CHandle<C_BaseEntity>
    pub const m_bPreventLoopback: usize = 0x28; // bool
    pub const m_ProviderType: usize = 0x2C; // attributeprovidertypes_t
    pub const m_CachedResults: usize = 0x30; // CUtlVector<CAttributeManager::cached_attribute_float_t>
}

pub mod CAttributeManager_cached_attribute_float_t {
    pub const flIn: usize = 0x0; // float
    pub const iAttribHook: usize = 0x8; // CUtlSymbolLarge
    pub const flOut: usize = 0x10; // float
}

pub mod CBaseAnimGraph {
    pub const m_bInitiallyPopulateInterpHistory: usize = 0xCC0; // bool
    pub const m_bShouldAnimateDuringGameplayPause: usize = 0xCC1; // bool
    pub const m_bSuppressAnimEventSounds: usize = 0xCC3; // bool
    pub const m_bAnimGraphUpdateEnabled: usize = 0xCD0; // bool
    pub const m_flMaxSlopeDistance: usize = 0xCD4; // float
    pub const m_vLastSlopeCheckPos: usize = 0xCD8; // Vector
    pub const m_vecForce: usize = 0xCE8; // Vector
    pub const m_nForceBone: usize = 0xCF4; // int32_t
    pub const m_pClientsideRagdoll: usize = 0xCF8; // CBaseAnimGraph*
    pub const m_bBuiltRagdoll: usize = 0xD00; // bool
    pub const m_pRagdollPose: usize = 0xD18; // PhysicsRagdollPose_t*
    pub const m_bClientRagdoll: usize = 0xD20; // bool
    pub const m_bHasAnimatedMaterialAttributes: usize = 0xD30; // bool
}

pub mod CBaseAnimGraphController {
    pub const m_baseLayer: usize = 0x18; // CNetworkedSequenceOperation
    pub const m_animGraphNetworkedVars: usize = 0x40; // CAnimGraphNetworkedVariables
    pub const m_bSequenceFinished: usize = 0x1320; // bool
    pub const m_flLastEventCycle: usize = 0x1324; // float
    pub const m_flLastEventAnimTime: usize = 0x1328; // float
    pub const m_flPlaybackRate: usize = 0x132C; // CNetworkedQuantizedFloat
    pub const m_flPrevAnimTime: usize = 0x1334; // float
    pub const m_bClientSideAnimation: usize = 0x1338; // bool
    pub const m_bNetworkedAnimationInputsChanged: usize = 0x1339; // bool
    pub const m_nPrevNewSequenceParity: usize = 0x133A; // uint8_t
    pub const m_nPrevResetEventsParity: usize = 0x133B; // uint8_t
    pub const m_nNewSequenceParity: usize = 0x133C; // int32_t
    pub const m_nResetEventsParity: usize = 0x1340; // int32_t
    pub const m_nAnimLoopMode: usize = 0x1344; // AnimLoopMode_t
    pub const m_hAnimationUpdate: usize = 0x13E4; // AnimationUpdateListHandle_t
    pub const m_hLastAnimEventSequence: usize = 0x13E8; // HSequence
}

pub mod CBasePlayerController {
    pub const m_nFinalPredictedTick: usize = 0x548; // int32_t
    pub const m_CommandContext: usize = 0x550; // C_CommandContext
    pub const m_nInButtonsWhichAreToggles: usize = 0x600; // uint64_t
    pub const m_nTickBase: usize = 0x608; // uint32_t
    pub const m_hPawn: usize = 0x60C; // CHandle<C_BasePlayerPawn>
    pub const m_hPredictedPawn: usize = 0x610; // CHandle<C_BasePlayerPawn>
    pub const m_nSplitScreenSlot: usize = 0x614; // CSplitScreenSlot
    pub const m_hSplitOwner: usize = 0x618; // CHandle<CBasePlayerController>
    pub const m_hSplitScreenPlayers: usize = 0x620; // CUtlVector<CHandle<CBasePlayerController>>
    pub const m_bIsHLTV: usize = 0x638; // bool
    pub const m_iConnected: usize = 0x63C; // PlayerConnectedState
    pub const m_iszPlayerName: usize = 0x640; // char[128]
    pub const m_steamID: usize = 0x6C8; // uint64_t
    pub const m_bIsLocalPlayerController: usize = 0x6D0; // bool
    pub const m_iDesiredFOV: usize = 0x6D4; // uint32_t
}

pub mod CBasePlayerVData {
    pub const m_sModelName: usize = 0x28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    pub const m_flHeadDamageMultiplier: usize = 0x108; // CSkillFloat
    pub const m_flChestDamageMultiplier: usize = 0x118; // CSkillFloat
    pub const m_flStomachDamageMultiplier: usize = 0x128; // CSkillFloat
    pub const m_flArmDamageMultiplier: usize = 0x138; // CSkillFloat
    pub const m_flLegDamageMultiplier: usize = 0x148; // CSkillFloat
    pub const m_flHoldBreathTime: usize = 0x158; // float
    pub const m_flDrowningDamageInterval: usize = 0x15C; // float
    pub const m_nDrowningDamageInitial: usize = 0x160; // int32_t
    pub const m_nDrowningDamageMax: usize = 0x164; // int32_t
    pub const m_nWaterSpeed: usize = 0x168; // int32_t
    pub const m_flUseRange: usize = 0x16C; // float
    pub const m_flUseAngleTolerance: usize = 0x170; // float
    pub const m_flCrouchTime: usize = 0x174; // float
}

pub mod CBasePlayerWeaponVData {
    pub const m_szWorldModel: usize = 0x28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    pub const m_bBuiltRightHanded: usize = 0x108; // bool
    pub const m_bAllowFlipping: usize = 0x109; // bool
    pub const m_bIsFullAuto: usize = 0x10A; // bool
    pub const m_nNumBullets: usize = 0x10C; // int32_t
    pub const m_sMuzzleAttachment: usize = 0x110; // CUtlString
    pub const m_szMuzzleFlashParticle: usize = 0x118; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    pub const m_iFlags: usize = 0x1F8; // ItemFlagTypes_t
    pub const m_nPrimaryAmmoType: usize = 0x1F9; // AmmoIndex_t
    pub const m_nSecondaryAmmoType: usize = 0x1FA; // AmmoIndex_t
    pub const m_iMaxClip1: usize = 0x1FC; // int32_t
    pub const m_iMaxClip2: usize = 0x200; // int32_t
    pub const m_iDefaultClip1: usize = 0x204; // int32_t
    pub const m_iDefaultClip2: usize = 0x208; // int32_t
    pub const m_iWeight: usize = 0x20C; // int32_t
    pub const m_bAutoSwitchTo: usize = 0x210; // bool
    pub const m_bAutoSwitchFrom: usize = 0x211; // bool
    pub const m_iRumbleEffect: usize = 0x214; // RumbleEffect_t
    pub const m_aShootSounds: usize = 0x218; // CUtlMap<WeaponSound_t,CSoundEventName>
    pub const m_iSlot: usize = 0x238; // int32_t
    pub const m_iPosition: usize = 0x23C; // int32_t
}

pub mod CBaseProp {
    pub const m_bModelOverrodeBlockLOS: usize = 0xE80; // bool
    pub const m_iShapeType: usize = 0xE84; // int32_t
    pub const m_bConformToCollisionBounds: usize = 0xE88; // bool
    pub const m_mPreferredCatchTransform: usize = 0xE8C; // matrix3x4_t
}

pub mod CBodyComponent {
    pub const m_pSceneNode: usize = 0x8; // CGameSceneNode*
    pub const __m_pChainEntity: usize = 0x20; // CNetworkVarChainer
}

pub mod CBodyComponentBaseAnimGraph {
    pub const m_animationController: usize = 0x480; // CBaseAnimGraphController
    pub const __m_pChainEntity: usize = 0x18C0; // CNetworkVarChainer
}

pub mod CBodyComponentBaseModelEntity {
    pub const __m_pChainEntity: usize = 0x480; // CNetworkVarChainer
}

pub mod CBodyComponentPoint {
    pub const m_sceneNode: usize = 0x50; // CGameSceneNode
    pub const __m_pChainEntity: usize = 0x1A0; // CNetworkVarChainer
}

pub mod CBodyComponentSkeletonInstance {
    pub const m_skeletonInstance: usize = 0x50; // CSkeletonInstance
    pub const __m_pChainEntity: usize = 0x450; // CNetworkVarChainer
}

pub mod CBombTarget {
    pub const m_bBombPlantedHere: usize = 0xCC8; // bool
}

pub mod CBuoyancyHelper {
    pub const m_flFluidDensity: usize = 0x18; // float
}

pub mod CCSGameModeRules {
    pub const __m_pChainEntity: usize = 0x8; // CNetworkVarChainer
}

pub mod CCSGameModeRules_Deathmatch {
    pub const m_bFirstThink: usize = 0x30; // bool
    pub const m_bFirstThinkAfterConnected: usize = 0x31; // bool
    pub const m_flDMBonusStartTime: usize = 0x34; // GameTime_t
    pub const m_flDMBonusTimeLength: usize = 0x38; // float
    pub const m_nDMBonusWeaponLoadoutSlot: usize = 0x3C; // int16_t
}

pub mod CCSObserver_ObserverServices {
    pub const m_hLastObserverTarget: usize = 0x58; // CEntityHandle
    pub const m_vecObserverInterpolateOffset: usize = 0x5C; // Vector
    pub const m_vecObserverInterpStartPos: usize = 0x68; // Vector
    pub const m_flObsInterp_PathLength: usize = 0x74; // float
    pub const m_qObsInterp_OrientationStart: usize = 0x80; // Quaternion
    pub const m_qObsInterp_OrientationTravelDir: usize = 0x90; // Quaternion
    pub const m_obsInterpState: usize = 0xA0; // ObserverInterpState_t
    pub const m_bObserverInterpolationNeedsDeferredSetup: usize = 0xA4; // bool
}

pub mod CCSPlayerBase_CameraServices {
    pub const m_iFOV: usize = 0x210; // uint32_t
    pub const m_iFOVStart: usize = 0x214; // uint32_t
    pub const m_flFOVTime: usize = 0x218; // GameTime_t
    pub const m_flFOVRate: usize = 0x21C; // float
    pub const m_hZoomOwner: usize = 0x220; // CHandle<C_BaseEntity>
    pub const m_flLastShotFOV: usize = 0x224; // float
}

pub mod CCSPlayerController {
    pub const m_pInGameMoneyServices: usize = 0x700; // CCSPlayerController_InGameMoneyServices*
    pub const m_pInventoryServices: usize = 0x708; // CCSPlayerController_InventoryServices*
    pub const m_pActionTrackingServices: usize = 0x710; // CCSPlayerController_ActionTrackingServices*
    pub const m_pDamageServices: usize = 0x718; // CCSPlayerController_DamageServices*
    pub const m_iPing: usize = 0x720; // uint32_t
    pub const m_bHasCommunicationAbuseMute: usize = 0x724; // bool
    pub const m_szCrosshairCodes: usize = 0x728; // CUtlSymbolLarge
    pub const m_iPendingTeamNum: usize = 0x730; // uint8_t
    pub const m_flForceTeamTime: usize = 0x734; // GameTime_t
    pub const m_iCompTeammateColor: usize = 0x738; // int32_t
    pub const m_bEverPlayedOnTeam: usize = 0x73C; // bool
    pub const m_flPreviousForceJoinTeamTime: usize = 0x740; // GameTime_t
    pub const m_szClan: usize = 0x748; // CUtlSymbolLarge
    pub const m_sSanitizedPlayerName: usize = 0x750; // CUtlString
    pub const m_iCoachingTeam: usize = 0x758; // int32_t
    pub const m_nPlayerDominated: usize = 0x760; // uint64_t
    pub const m_nPlayerDominatingMe: usize = 0x768; // uint64_t
    pub const m_iCompetitiveRanking: usize = 0x770; // int32_t
    pub const m_iCompetitiveWins: usize = 0x774; // int32_t
    pub const m_iCompetitiveRankType: usize = 0x778; // int8_t
    pub const m_iCompetitiveRankingPredicted_Win: usize = 0x77C; // int32_t
    pub const m_iCompetitiveRankingPredicted_Loss: usize = 0x780; // int32_t
    pub const m_iCompetitiveRankingPredicted_Tie: usize = 0x784; // int32_t
    pub const m_nEndMatchNextMapVote: usize = 0x788; // int32_t
    pub const m_unActiveQuestId: usize = 0x78C; // uint16_t
    pub const m_nQuestProgressReason: usize = 0x790; // QuestProgress::Reason
    pub const m_unPlayerTvControlFlags: usize = 0x794; // uint32_t
    pub const m_iDraftIndex: usize = 0x7C0; // int32_t
    pub const m_msQueuedModeDisconnectionTimestamp: usize = 0x7C4; // uint32_t
    pub const m_uiAbandonRecordedReason: usize = 0x7C8; // uint32_t
    pub const m_bCannotBeKicked: usize = 0x7CC; // bool
    pub const m_bEverFullyConnected: usize = 0x7CD; // bool
    pub const m_bAbandonAllowsSurrender: usize = 0x7CE; // bool
    pub const m_bAbandonOffersInstantSurrender: usize = 0x7CF; // bool
    pub const m_bDisconnection1MinWarningPrinted: usize = 0x7D0; // bool
    pub const m_bScoreReported: usize = 0x7D1; // bool
    pub const m_nDisconnectionTick: usize = 0x7D4; // int32_t
    pub const m_bControllingBot: usize = 0x7E0; // bool
    pub const m_bHasControlledBotThisRound: usize = 0x7E1; // bool
    pub const m_bHasBeenControlledByPlayerThisRound: usize = 0x7E2; // bool
    pub const m_nBotsControlledThisRound: usize = 0x7E4; // int32_t
    pub const m_bCanControlObservedBot: usize = 0x7E8; // bool
    pub const m_hPlayerPawn: usize = 0x7EC; // CHandle<C_CSPlayerPawn>
    pub const m_hObserverPawn: usize = 0x7F0; // CHandle<C_CSObserverPawn>
    pub const m_bPawnIsAlive: usize = 0x7F4; // bool
    pub const m_iPawnHealth: usize = 0x7F8; // uint32_t
    pub const m_iPawnArmor: usize = 0x7FC; // int32_t
    pub const m_bPawnHasDefuser: usize = 0x800; // bool
    pub const m_bPawnHasHelmet: usize = 0x801; // bool
    pub const m_nPawnCharacterDefIndex: usize = 0x802; // uint16_t
    pub const m_iPawnLifetimeStart: usize = 0x804; // int32_t
    pub const m_iPawnLifetimeEnd: usize = 0x808; // int32_t
    pub const m_iPawnBotDifficulty: usize = 0x80C; // int32_t
    pub const m_hOriginalControllerOfCurrentPawn: usize = 0x810; // CHandle<CCSPlayerController>
    pub const m_iScore: usize = 0x814; // int32_t
    pub const m_vecKills: usize = 0x818; // C_NetworkUtlVectorBase<EKillTypes_t>
    pub const m_iMVPs: usize = 0x830; // int32_t
    pub const m_bIsPlayerNameDirty: usize = 0x834; // bool
}

pub mod CCSPlayerController_ActionTrackingServices {
    pub const m_perRoundStats: usize = 0x40; // C_UtlVectorEmbeddedNetworkVar<CSPerRoundStats_t>
    pub const m_matchStats: usize = 0x90; // CSMatchStats_t
    pub const m_iNumRoundKills: usize = 0x108; // int32_t
    pub const m_iNumRoundKillsHeadshots: usize = 0x10C; // int32_t
    pub const m_unTotalRoundDamageDealt: usize = 0x110; // uint32_t
}

pub mod CCSPlayerController_DamageServices {
    pub const m_nSendUpdate: usize = 0x40; // int32_t
    pub const m_DamageList: usize = 0x48; // C_UtlVectorEmbeddedNetworkVar<CDamageRecord>
}

pub mod CCSPlayerController_InGameMoneyServices {
    pub const m_iAccount: usize = 0x40; // int32_t
    pub const m_iStartAccount: usize = 0x44; // int32_t
    pub const m_iTotalCashSpent: usize = 0x48; // int32_t
    pub const m_iCashSpentThisRound: usize = 0x4C; // int32_t
    pub const m_nPreviousAccount: usize = 0x50; // int32_t
}

pub mod CCSPlayerController_InventoryServices {
    pub const m_unMusicID: usize = 0x40; // uint16_t
    pub const m_rank: usize = 0x44; // MedalRank_t[6]
    pub const m_nPersonaDataPublicLevel: usize = 0x5C; // int32_t
    pub const m_nPersonaDataPublicCommendsLeader: usize = 0x60; // int32_t
    pub const m_nPersonaDataPublicCommendsTeacher: usize = 0x64; // int32_t
    pub const m_nPersonaDataPublicCommendsFriendly: usize = 0x68; // int32_t
    pub const m_vecServerAuthoritativeWeaponSlots: usize = 0x70; // C_UtlVectorEmbeddedNetworkVar<ServerAuthoritativeWeaponSlot_t>
}

pub mod CCSPlayer_ActionTrackingServices {
    pub const m_hLastWeaponBeforeC4AutoSwitch: usize = 0x40; // CHandle<C_BasePlayerWeapon>
    pub const m_bIsRescuing: usize = 0x44; // bool
    pub const m_weaponPurchasesThisMatch: usize = 0x48; // WeaponPurchaseTracker_t
    pub const m_weaponPurchasesThisRound: usize = 0xA0; // WeaponPurchaseTracker_t
}

pub mod CCSPlayer_BulletServices {
    pub const m_totalHitsOnServer: usize = 0x40; // int32_t
}

pub mod CCSPlayer_BuyServices {
    pub const m_vecSellbackPurchaseEntries: usize = 0x40; // C_UtlVectorEmbeddedNetworkVar<SellbackPurchaseEntry_t>
}

pub mod CCSPlayer_CameraServices {
    pub const m_flDeathCamTilt: usize = 0x228; // float
}

pub mod CCSPlayer_HostageServices {
    pub const m_hCarriedHostage: usize = 0x40; // CHandle<C_BaseEntity>
    pub const m_hCarriedHostageProp: usize = 0x44; // CHandle<C_BaseEntity>
}

pub mod CCSPlayer_ItemServices {
    pub const m_bHasDefuser: usize = 0x40; // bool
    pub const m_bHasHelmet: usize = 0x41; // bool
    pub const m_bHasHeavyArmor: usize = 0x42; // bool
}

pub mod CCSPlayer_MovementServices {
    pub const m_flMaxFallVelocity: usize = 0x210; // float
    pub const m_vecLadderNormal: usize = 0x214; // Vector
    pub const m_nLadderSurfacePropIndex: usize = 0x220; // int32_t
    pub const m_flDuckAmount: usize = 0x224; // float
    pub const m_flDuckSpeed: usize = 0x228; // float
    pub const m_bDuckOverride: usize = 0x22C; // bool
    pub const m_bDesiresDuck: usize = 0x22D; // bool
    pub const m_flDuckOffset: usize = 0x230; // float
    pub const m_nDuckTimeMsecs: usize = 0x234; // uint32_t
    pub const m_nDuckJumpTimeMsecs: usize = 0x238; // uint32_t
    pub const m_nJumpTimeMsecs: usize = 0x23C; // uint32_t
    pub const m_flLastDuckTime: usize = 0x240; // float
    pub const m_vecLastPositionAtFullCrouchSpeed: usize = 0x250; // Vector2D
    pub const m_duckUntilOnGround: usize = 0x258; // bool
    pub const m_bHasWalkMovedSinceLastJump: usize = 0x259; // bool
    pub const m_bInStuckTest: usize = 0x25A; // bool
    pub const m_flStuckCheckTime: usize = 0x268; // float[64][2]
    pub const m_nTraceCount: usize = 0x468; // int32_t
    pub const m_StuckLast: usize = 0x46C; // int32_t
    pub const m_bSpeedCropped: usize = 0x470; // bool
    pub const m_nOldWaterLevel: usize = 0x474; // int32_t
    pub const m_flWaterEntryTime: usize = 0x478; // float
    pub const m_vecForward: usize = 0x47C; // Vector
    pub const m_vecLeft: usize = 0x488; // Vector
    pub const m_vecUp: usize = 0x494; // Vector
    pub const m_vecPreviouslyPredictedOrigin: usize = 0x4A0; // Vector
    pub const m_bOldJumpPressed: usize = 0x4AC; // bool
    pub const m_flJumpPressedTime: usize = 0x4B0; // float
    pub const m_flJumpUntil: usize = 0x4B4; // float
    pub const m_flJumpVel: usize = 0x4B8; // float
    pub const m_fStashGrenadeParameterWhen: usize = 0x4BC; // GameTime_t
    pub const m_nButtonDownMaskPrev: usize = 0x4C0; // uint64_t
    pub const m_flOffsetTickCompleteTime: usize = 0x4C8; // float
    pub const m_flOffsetTickStashedSpeed: usize = 0x4CC; // float
    pub const m_flStamina: usize = 0x4D0; // float
    pub const m_bUpdatePredictedOriginAfterDataUpdate: usize = 0x4D4; // bool
    pub const m_flHeightAtJumpStart: usize = 0x4D8; // float
    pub const m_flMaxJumpHeightThisJump: usize = 0x4DC; // float
}

pub mod CCSPlayer_PingServices {
    pub const m_hPlayerPing: usize = 0x40; // CHandle<C_BaseEntity>
}

pub mod CCSPlayer_ViewModelServices {
    pub const m_hViewModel: usize = 0x40; // CHandle<C_BaseViewModel>[3]
}

pub mod CCSPlayer_WaterServices {
    pub const m_flWaterJumpTime: usize = 0x40; // float
    pub const m_vecWaterJumpVel: usize = 0x44; // Vector
    pub const m_flSwimSoundTime: usize = 0x50; // float
}

pub mod CCSPlayer_WeaponServices {
    pub const m_flNextAttack: usize = 0xC0; // GameTime_t
    pub const m_bIsLookingAtWeapon: usize = 0xC4; // bool
    pub const m_bIsHoldingLookAtWeapon: usize = 0xC5; // bool
}

pub mod CCSWeaponBaseVData {
    pub const m_WeaponType: usize = 0x240; // CSWeaponType
    pub const m_WeaponCategory: usize = 0x244; // CSWeaponCategory
    pub const m_szViewModel: usize = 0x248; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    pub const m_szPlayerModel: usize = 0x328; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    pub const m_szWorldDroppedModel: usize = 0x408; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    pub const m_szAimsightLensMaskModel: usize = 0x4E8; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    pub const m_szMagazineModel: usize = 0x5C8; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    pub const m_szHeatEffect: usize = 0x6A8; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    pub const m_szEjectBrassEffect: usize = 0x788; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    pub const m_szMuzzleFlashParticleAlt: usize = 0x868; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    pub const m_szMuzzleFlashThirdPersonParticle: usize = 0x948; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    pub const m_szMuzzleFlashThirdPersonParticleAlt: usize = 0xA28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    pub const m_szTracerParticle: usize = 0xB08; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    pub const m_GearSlot: usize = 0xBE8; // gear_slot_t
    pub const m_GearSlotPosition: usize = 0xBEC; // int32_t
    pub const m_DefaultLoadoutSlot: usize = 0xBF0; // loadout_slot_t
    pub const m_sWrongTeamMsg: usize = 0xBF8; // CUtlString
    pub const m_nPrice: usize = 0xC00; // int32_t
    pub const m_nKillAward: usize = 0xC04; // int32_t
    pub const m_nPrimaryReserveAmmoMax: usize = 0xC08; // int32_t
    pub const m_nSecondaryReserveAmmoMax: usize = 0xC0C; // int32_t
    pub const m_bMeleeWeapon: usize = 0xC10; // bool
    pub const m_bHasBurstMode: usize = 0xC11; // bool
    pub const m_bIsRevolver: usize = 0xC12; // bool
    pub const m_bCannotShootUnderwater: usize = 0xC13; // bool
    pub const m_szName: usize = 0xC18; // CUtlString
    pub const m_szAnimExtension: usize = 0xC20; // CUtlString
    pub const m_eSilencerType: usize = 0xC28; // CSWeaponSilencerType
    pub const m_nCrosshairMinDistance: usize = 0xC2C; // int32_t
    pub const m_nCrosshairDeltaDistance: usize = 0xC30; // int32_t
    pub const m_flCycleTime: usize = 0xC34; // CFiringModeFloat
    pub const m_flMaxSpeed: usize = 0xC3C; // CFiringModeFloat
    pub const m_flSpread: usize = 0xC44; // CFiringModeFloat
    pub const m_flInaccuracyCrouch: usize = 0xC4C; // CFiringModeFloat
    pub const m_flInaccuracyStand: usize = 0xC54; // CFiringModeFloat
    pub const m_flInaccuracyJump: usize = 0xC5C; // CFiringModeFloat
    pub const m_flInaccuracyLand: usize = 0xC64; // CFiringModeFloat
    pub const m_flInaccuracyLadder: usize = 0xC6C; // CFiringModeFloat
    pub const m_flInaccuracyFire: usize = 0xC74; // CFiringModeFloat
    pub const m_flInaccuracyMove: usize = 0xC7C; // CFiringModeFloat
    pub const m_flRecoilAngle: usize = 0xC84; // CFiringModeFloat
    pub const m_flRecoilAngleVariance: usize = 0xC8C; // CFiringModeFloat
    pub const m_flRecoilMagnitude: usize = 0xC94; // CFiringModeFloat
    pub const m_flRecoilMagnitudeVariance: usize = 0xC9C; // CFiringModeFloat
    pub const m_nTracerFrequency: usize = 0xCA4; // CFiringModeInt
    pub const m_flInaccuracyJumpInitial: usize = 0xCAC; // float
    pub const m_flInaccuracyJumpApex: usize = 0xCB0; // float
    pub const m_flInaccuracyReload: usize = 0xCB4; // float
    pub const m_nRecoilSeed: usize = 0xCB8; // int32_t
    pub const m_nSpreadSeed: usize = 0xCBC; // int32_t
    pub const m_flTimeToIdleAfterFire: usize = 0xCC0; // float
    pub const m_flIdleInterval: usize = 0xCC4; // float
    pub const m_flAttackMovespeedFactor: usize = 0xCC8; // float
    pub const m_flHeatPerShot: usize = 0xCCC; // float
    pub const m_flInaccuracyPitchShift: usize = 0xCD0; // float
    pub const m_flInaccuracyAltSoundThreshold: usize = 0xCD4; // float
    pub const m_flBotAudibleRange: usize = 0xCD8; // float
    pub const m_szUseRadioSubtitle: usize = 0xCE0; // CUtlString
    pub const m_bUnzoomsAfterShot: usize = 0xCE8; // bool
    pub const m_bHideViewModelWhenZoomed: usize = 0xCE9; // bool
    pub const m_nZoomLevels: usize = 0xCEC; // int32_t
    pub const m_nZoomFOV1: usize = 0xCF0; // int32_t
    pub const m_nZoomFOV2: usize = 0xCF4; // int32_t
    pub const m_flZoomTime0: usize = 0xCF8; // float
    pub const m_flZoomTime1: usize = 0xCFC; // float
    pub const m_flZoomTime2: usize = 0xD00; // float
    pub const m_flIronSightPullUpSpeed: usize = 0xD04; // float
    pub const m_flIronSightPutDownSpeed: usize = 0xD08; // float
    pub const m_flIronSightFOV: usize = 0xD0C; // float
    pub const m_flIronSightPivotForward: usize = 0xD10; // float
    pub const m_flIronSightLooseness: usize = 0xD14; // float
    pub const m_angPivotAngle: usize = 0xD18; // QAngle
    pub const m_vecIronSightEyePos: usize = 0xD24; // Vector
    pub const m_nDamage: usize = 0xD30; // int32_t
    pub const m_flHeadshotMultiplier: usize = 0xD34; // float
    pub const m_flArmorRatio: usize = 0xD38; // float
    pub const m_flPenetration: usize = 0xD3C; // float
    pub const m_flRange: usize = 0xD40; // float
    pub const m_flRangeModifier: usize = 0xD44; // float
    pub const m_flFlinchVelocityModifierLarge: usize = 0xD48; // float
    pub const m_flFlinchVelocityModifierSmall: usize = 0xD4C; // float
    pub const m_flRecoveryTimeCrouch: usize = 0xD50; // float
    pub const m_flRecoveryTimeStand: usize = 0xD54; // float
    pub const m_flRecoveryTimeCrouchFinal: usize = 0xD58; // float
    pub const m_flRecoveryTimeStandFinal: usize = 0xD5C; // float
    pub const m_nRecoveryTransitionStartBullet: usize = 0xD60; // int32_t
    pub const m_nRecoveryTransitionEndBullet: usize = 0xD64; // int32_t
    pub const m_flThrowVelocity: usize = 0xD68; // float
    pub const m_vSmokeColor: usize = 0xD6C; // Vector
    pub const m_szAnimClass: usize = 0xD78; // CUtlString
}

pub mod CClientAlphaProperty {
    pub const m_nRenderFX: usize = 0x10; // uint8_t
    pub const m_nRenderMode: usize = 0x11; // uint8_t
    pub const m_bAlphaOverride: usize = 0x0; // bitfield:1
    pub const m_bShadowAlphaOverride: usize = 0x0; // bitfield:1
    pub const m_nReserved: usize = 0x0; // bitfield:6
    pub const m_nAlpha: usize = 0x13; // uint8_t
    pub const m_nDesyncOffset: usize = 0x14; // uint16_t
    pub const m_nReserved2: usize = 0x16; // uint16_t
    pub const m_nDistFadeStart: usize = 0x18; // uint16_t
    pub const m_nDistFadeEnd: usize = 0x1A; // uint16_t
    pub const m_flFadeScale: usize = 0x1C; // float
    pub const m_flRenderFxStartTime: usize = 0x20; // GameTime_t
    pub const m_flRenderFxDuration: usize = 0x24; // float
}

pub mod CCollisionProperty {
    pub const m_collisionAttribute: usize = 0x10; // VPhysicsCollisionAttribute_t
    pub const m_vecMins: usize = 0x40; // Vector
    pub const m_vecMaxs: usize = 0x4C; // Vector
    pub const m_usSolidFlags: usize = 0x5A; // uint8_t
    pub const m_nSolidType: usize = 0x5B; // SolidType_t
    pub const m_triggerBloat: usize = 0x5C; // uint8_t
    pub const m_nSurroundType: usize = 0x5D; // SurroundingBoundsType_t
    pub const m_CollisionGroup: usize = 0x5E; // uint8_t
    pub const m_nEnablePhysics: usize = 0x5F; // uint8_t
    pub const m_flBoundingRadius: usize = 0x60; // float
    pub const m_vecSpecifiedSurroundingMins: usize = 0x64; // Vector
    pub const m_vecSpecifiedSurroundingMaxs: usize = 0x70; // Vector
    pub const m_vecSurroundingMaxs: usize = 0x7C; // Vector
    pub const m_vecSurroundingMins: usize = 0x88; // Vector
    pub const m_vCapsuleCenter1: usize = 0x94; // Vector
    pub const m_vCapsuleCenter2: usize = 0xA0; // Vector
    pub const m_flCapsuleRadius: usize = 0xAC; // float
}

pub mod CComicBook {
    pub const m_CoverImage: usize = 0x8; // CPanoramaImageName
    pub const m_XmlFile: usize = 0x18; // CUtlString
}

pub mod CCompositeMaterialEditorDoc {
    pub const m_nVersion: usize = 0x8; // int32_t
    pub const m_Points: usize = 0x10; // CUtlVector<CompositeMaterialEditorPoint_t>
    pub const m_KVthumbnail: usize = 0x28; // KeyValues3
}

pub mod CDamageRecord {
    pub const m_PlayerDamager: usize = 0x28; // CHandle<C_CSPlayerPawnBase>
    pub const m_PlayerRecipient: usize = 0x2C; // CHandle<C_CSPlayerPawnBase>
    pub const m_hPlayerControllerDamager: usize = 0x30; // CHandle<CCSPlayerController>
    pub const m_hPlayerControllerRecipient: usize = 0x34; // CHandle<CCSPlayerController>
    pub const m_szPlayerDamagerName: usize = 0x38; // CUtlString
    pub const m_szPlayerRecipientName: usize = 0x40; // CUtlString
    pub const m_DamagerXuid: usize = 0x48; // uint64_t
    pub const m_RecipientXuid: usize = 0x50; // uint64_t
    pub const m_iDamage: usize = 0x58; // int32_t
    pub const m_iActualHealthRemoved: usize = 0x5C; // int32_t
    pub const m_iNumHits: usize = 0x60; // int32_t
    pub const m_iLastBulletUpdate: usize = 0x64; // int32_t
    pub const m_bIsOtherEnemy: usize = 0x68; // bool
    pub const m_killType: usize = 0x69; // EKillTypes_t
}

pub mod CDecalInfo {
    pub const m_flAnimationScale: usize = 0x0; // float
    pub const m_flAnimationLifeSpan: usize = 0x4; // float
    pub const m_flPlaceTime: usize = 0x8; // float
    pub const m_flFadeStartTime: usize = 0xC; // float
    pub const m_flFadeDuration: usize = 0x10; // float
    pub const m_nVBSlot: usize = 0x14; // int32_t
    pub const m_nBoneIndex: usize = 0x18; // int32_t
    pub const m_vPosition: usize = 0x28; // Vector
    pub const m_flBoundingRadiusSqr: usize = 0x34; // float
    pub const m_pNext: usize = 0x40; // CDecalInfo*
    pub const m_pPrev: usize = 0x48; // CDecalInfo*
    pub const m_nDecalMaterialIndex: usize = 0xA8; // int32_t
}

pub mod CEconItemAttribute {
    pub const m_iAttributeDefinitionIndex: usize = 0x30; // uint16_t
    pub const m_flValue: usize = 0x34; // float
    pub const m_flInitialValue: usize = 0x38; // float
    pub const m_nRefundableCurrency: usize = 0x3C; // int32_t
    pub const m_bSetBonus: usize = 0x40; // bool
}

pub mod CEffectData {
    pub const m_vOrigin: usize = 0x8; // Vector
    pub const m_vStart: usize = 0x14; // Vector
    pub const m_vNormal: usize = 0x20; // Vector
    pub const m_vAngles: usize = 0x2C; // QAngle
    pub const m_hEntity: usize = 0x38; // CEntityHandle
    pub const m_hOtherEntity: usize = 0x3C; // CEntityHandle
    pub const m_flScale: usize = 0x40; // float
    pub const m_flMagnitude: usize = 0x44; // float
    pub const m_flRadius: usize = 0x48; // float
    pub const m_nSurfaceProp: usize = 0x4C; // CUtlStringToken
    pub const m_nEffectIndex: usize = 0x50; // CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>
    pub const m_nDamageType: usize = 0x58; // uint32_t
    pub const m_nPenetrate: usize = 0x5C; // uint8_t
    pub const m_nMaterial: usize = 0x5E; // uint16_t
    pub const m_nHitBox: usize = 0x60; // uint16_t
    pub const m_nColor: usize = 0x62; // uint8_t
    pub const m_fFlags: usize = 0x63; // uint8_t
    pub const m_nAttachmentIndex: usize = 0x64; // AttachmentHandle_t
    pub const m_nAttachmentName: usize = 0x68; // CUtlStringToken
    pub const m_iEffectName: usize = 0x6C; // uint16_t
    pub const m_nExplosionType: usize = 0x6E; // uint8_t
}

pub mod CEntityIdentity {
    pub const m_nameStringableIndex: usize = 0x14; // int32_t
    pub const m_name: usize = 0x18; // CUtlSymbolLarge
    pub const m_designerName: usize = 0x20; // CUtlSymbolLarge
    pub const m_flags: usize = 0x30; // uint32_t
    pub const m_worldGroupId: usize = 0x38; // WorldGroupId_t
    pub const m_fDataObjectTypes: usize = 0x3C; // uint32_t
    pub const m_PathIndex: usize = 0x40; // ChangeAccessorFieldPathIndex_t
    pub const m_pPrev: usize = 0x58; // CEntityIdentity*
    pub const m_pNext: usize = 0x60; // CEntityIdentity*
    pub const m_pPrevByClass: usize = 0x68; // CEntityIdentity*
    pub const m_pNextByClass: usize = 0x70; // CEntityIdentity*
}

pub mod CEntityInstance {
    pub const m_iszPrivateVScripts: usize = 0x8; // CUtlSymbolLarge
    pub const m_pEntity: usize = 0x10; // CEntityIdentity*
    pub const m_CScriptComponent: usize = 0x28; // CScriptComponent*
}

pub mod CFireOverlay {
    pub const m_pOwner: usize = 0xD0; // C_FireSmoke*
    pub const m_vBaseColors: usize = 0xD8; // Vector[4]
    pub const m_flScale: usize = 0x108; // float
    pub const m_nGUID: usize = 0x10C; // int32_t
}

pub mod CFlashlightEffect {
    pub const m_bIsOn: usize = 0x10; // bool
    pub const m_bMuzzleFlashEnabled: usize = 0x20; // bool
    pub const m_flMuzzleFlashBrightness: usize = 0x24; // float
    pub const m_quatMuzzleFlashOrientation: usize = 0x30; // Quaternion
    pub const m_vecMuzzleFlashOrigin: usize = 0x40; // Vector
    pub const m_flFov: usize = 0x4C; // float
    pub const m_flFarZ: usize = 0x50; // float
    pub const m_flLinearAtten: usize = 0x54; // float
    pub const m_bCastsShadows: usize = 0x58; // bool
    pub const m_flCurrentPullBackDist: usize = 0x5C; // float
    pub const m_FlashlightTexture: usize = 0x60; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_MuzzleFlashTexture: usize = 0x68; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_textureName: usize = 0x70; // char[64]
}

pub mod CFuncWater {
    pub const m_BuoyancyHelper: usize = 0xCC0; // CBuoyancyHelper
}

pub mod CGameSceneNode {
    pub const m_nodeToWorld: usize = 0x10; // CTransform
    pub const m_pOwner: usize = 0x30; // CEntityInstance*
    pub const m_pParent: usize = 0x38; // CGameSceneNode*
    pub const m_pChild: usize = 0x40; // CGameSceneNode*
    pub const m_pNextSibling: usize = 0x48; // CGameSceneNode*
    pub const m_hParent: usize = 0x70; // CGameSceneNodeHandle
    pub const m_vecOrigin: usize = 0x80; // CNetworkOriginCellCoordQuantizedVector
    pub const m_angRotation: usize = 0xB8; // QAngle
    pub const m_flScale: usize = 0xC4; // float
    pub const m_vecAbsOrigin: usize = 0xC8; // Vector
    pub const m_angAbsRotation: usize = 0xD4; // QAngle
    pub const m_flAbsScale: usize = 0xE0; // float
    pub const m_nParentAttachmentOrBone: usize = 0xE4; // int16_t
    pub const m_bDebugAbsOriginChanges: usize = 0xE6; // bool
    pub const m_bDormant: usize = 0xE7; // bool
    pub const m_bForceParentToBeNetworked: usize = 0xE8; // bool
    pub const m_bDirtyHierarchy: usize = 0x0; // bitfield:1
    pub const m_bDirtyBoneMergeInfo: usize = 0x0; // bitfield:1
    pub const m_bNetworkedPositionChanged: usize = 0x0; // bitfield:1
    pub const m_bNetworkedAnglesChanged: usize = 0x0; // bitfield:1
    pub const m_bNetworkedScaleChanged: usize = 0x0; // bitfield:1
    pub const m_bWillBeCallingPostDataUpdate: usize = 0x0; // bitfield:1
    pub const m_bNotifyBoneTransformsChanged: usize = 0x0; // bitfield:1
    pub const m_bBoneMergeFlex: usize = 0x0; // bitfield:1
    pub const m_nLatchAbsOrigin: usize = 0x0; // bitfield:2
    pub const m_bDirtyBoneMergeBoneToRoot: usize = 0x0; // bitfield:1
    pub const m_nHierarchicalDepth: usize = 0xEB; // uint8_t
    pub const m_nHierarchyType: usize = 0xEC; // uint8_t
    pub const m_nDoNotSetAnimTimeInInvalidatePhysicsCount: usize = 0xED; // uint8_t
    pub const m_name: usize = 0xF0; // CUtlStringToken
    pub const m_hierarchyAttachName: usize = 0x130; // CUtlStringToken
    pub const m_flZOffset: usize = 0x134; // float
    pub const m_vRenderOrigin: usize = 0x138; // Vector
}

pub mod CGameSceneNodeHandle {
    pub const m_hOwner: usize = 0x8; // CEntityHandle
    pub const m_name: usize = 0xC; // CUtlStringToken
}

pub mod CGlobalLightBase {
    pub const m_bSpotLight: usize = 0x10; // bool
    pub const m_SpotLightOrigin: usize = 0x14; // Vector
    pub const m_SpotLightAngles: usize = 0x20; // QAngle
    pub const m_ShadowDirection: usize = 0x2C; // Vector
    pub const m_AmbientDirection: usize = 0x38; // Vector
    pub const m_SpecularDirection: usize = 0x44; // Vector
    pub const m_InspectorSpecularDirection: usize = 0x50; // Vector
    pub const m_flSpecularPower: usize = 0x5C; // float
    pub const m_flSpecularIndependence: usize = 0x60; // float
    pub const m_SpecularColor: usize = 0x64; // Color
    pub const m_bStartDisabled: usize = 0x68; // bool
    pub const m_bEnabled: usize = 0x69; // bool
    pub const m_LightColor: usize = 0x6A; // Color
    pub const m_AmbientColor1: usize = 0x6E; // Color
    pub const m_AmbientColor2: usize = 0x72; // Color
    pub const m_AmbientColor3: usize = 0x76; // Color
    pub const m_flSunDistance: usize = 0x7C; // float
    pub const m_flFOV: usize = 0x80; // float
    pub const m_flNearZ: usize = 0x84; // float
    pub const m_flFarZ: usize = 0x88; // float
    pub const m_bEnableShadows: usize = 0x8C; // bool
    pub const m_bOldEnableShadows: usize = 0x8D; // bool
    pub const m_bBackgroundClearNotRequired: usize = 0x8E; // bool
    pub const m_flCloudScale: usize = 0x90; // float
    pub const m_flCloud1Speed: usize = 0x94; // float
    pub const m_flCloud1Direction: usize = 0x98; // float
    pub const m_flCloud2Speed: usize = 0x9C; // float
    pub const m_flCloud2Direction: usize = 0xA0; // float
    pub const m_flAmbientScale1: usize = 0xB0; // float
    pub const m_flAmbientScale2: usize = 0xB4; // float
    pub const m_flGroundScale: usize = 0xB8; // float
    pub const m_flLightScale: usize = 0xBC; // float
    pub const m_flFoWDarkness: usize = 0xC0; // float
    pub const m_bEnableSeparateSkyboxFog: usize = 0xC4; // bool
    pub const m_vFowColor: usize = 0xC8; // Vector
    pub const m_ViewOrigin: usize = 0xD4; // Vector
    pub const m_ViewAngles: usize = 0xE0; // QAngle
    pub const m_flViewFoV: usize = 0xEC; // float
    pub const m_WorldPoints: usize = 0xF0; // Vector[8]
    pub const m_vFogOffsetLayer0: usize = 0x4A8; // Vector2D
    pub const m_vFogOffsetLayer1: usize = 0x4B0; // Vector2D
    pub const m_hEnvWind: usize = 0x4B8; // CHandle<C_BaseEntity>
    pub const m_hEnvSky: usize = 0x4BC; // CHandle<C_BaseEntity>
}

pub mod CGlowOverlay {
    pub const m_vPos: usize = 0x8; // Vector
    pub const m_bDirectional: usize = 0x14; // bool
    pub const m_vDirection: usize = 0x18; // Vector
    pub const m_bInSky: usize = 0x24; // bool
    pub const m_skyObstructionScale: usize = 0x28; // float
    pub const m_Sprites: usize = 0x30; // CGlowSprite[4]
    pub const m_nSprites: usize = 0xB0; // int32_t
    pub const m_flProxyRadius: usize = 0xB4; // float
    pub const m_flHDRColorScale: usize = 0xB8; // float
    pub const m_flGlowObstructionScale: usize = 0xBC; // float
    pub const m_bCacheGlowObstruction: usize = 0xC0; // bool
    pub const m_bCacheSkyObstruction: usize = 0xC1; // bool
    pub const m_bActivated: usize = 0xC2; // int16_t
    pub const m_ListIndex: usize = 0xC4; // uint16_t
    pub const m_queryHandle: usize = 0xC8; // int32_t
}

pub mod CGlowProperty {
    pub const m_fGlowColor: usize = 0x8; // Vector
    pub const m_iGlowType: usize = 0x30; // int32_t
    pub const m_iGlowTeam: usize = 0x34; // int32_t
    pub const m_nGlowRange: usize = 0x38; // int32_t
    pub const m_nGlowRangeMin: usize = 0x3C; // int32_t
    pub const m_glowColorOverride: usize = 0x40; // Color
    pub const m_bFlashing: usize = 0x44; // bool
    pub const m_flGlowTime: usize = 0x48; // float
    pub const m_flGlowStartTime: usize = 0x4C; // float
    pub const m_bEligibleForScreenHighlight: usize = 0x50; // bool
    pub const m_bGlowing: usize = 0x51; // bool
}

pub mod CGlowSprite {
    pub const m_vColor: usize = 0x0; // Vector
    pub const m_flHorzSize: usize = 0xC; // float
    pub const m_flVertSize: usize = 0x10; // float
    pub const m_hMaterial: usize = 0x18; // CStrongHandle<InfoForResourceTypeIMaterial2>
}

pub mod CGrenadeTracer {
    pub const m_flTracerDuration: usize = 0xCE0; // float
    pub const m_nType: usize = 0xCE4; // GrenadeType_t
}

pub mod CHitboxComponent {
    pub const m_bvDisabledHitGroups: usize = 0x24; // uint32_t[1]
}

pub mod CInfoDynamicShadowHint {
    pub const m_bDisabled: usize = 0x540; // bool
    pub const m_flRange: usize = 0x544; // float
    pub const m_nImportance: usize = 0x548; // int32_t
    pub const m_nLightChoice: usize = 0x54C; // int32_t
    pub const m_hLight: usize = 0x550; // CHandle<C_BaseEntity>
}

pub mod CInfoDynamicShadowHintBox {
    pub const m_vBoxMins: usize = 0x558; // Vector
    pub const m_vBoxMaxs: usize = 0x564; // Vector
}

pub mod CInfoOffscreenPanoramaTexture {
    pub const m_bDisabled: usize = 0x540; // bool
    pub const m_nResolutionX: usize = 0x544; // int32_t
    pub const m_nResolutionY: usize = 0x548; // int32_t
    pub const m_szLayoutFileName: usize = 0x550; // CUtlSymbolLarge
    pub const m_RenderAttrName: usize = 0x558; // CUtlSymbolLarge
    pub const m_TargetEntities: usize = 0x560; // C_NetworkUtlVectorBase<CHandle<C_BaseModelEntity>>
    pub const m_nTargetChangeCount: usize = 0x578; // int32_t
    pub const m_vecCSSClasses: usize = 0x580; // C_NetworkUtlVectorBase<CUtlSymbolLarge>
    pub const m_bCheckCSSClasses: usize = 0x6F8; // bool
}

pub mod CInfoWorldLayer {
    pub const m_pOutputOnEntitiesSpawned: usize = 0x540; // CEntityIOOutput
    pub const m_worldName: usize = 0x568; // CUtlSymbolLarge
    pub const m_layerName: usize = 0x570; // CUtlSymbolLarge
    pub const m_bWorldLayerVisible: usize = 0x578; // bool
    pub const m_bEntitiesSpawned: usize = 0x579; // bool
    pub const m_bCreateAsChildSpawnGroup: usize = 0x57A; // bool
    pub const m_hLayerSpawnGroup: usize = 0x57C; // uint32_t
    pub const m_bWorldLayerActuallyVisible: usize = 0x580; // bool
}

pub mod CInterpolatedValue {
    pub const m_flStartTime: usize = 0x0; // float
    pub const m_flEndTime: usize = 0x4; // float
    pub const m_flStartValue: usize = 0x8; // float
    pub const m_flEndValue: usize = 0xC; // float
    pub const m_nInterpType: usize = 0x10; // int32_t
}

pub mod CLightComponent {
    pub const __m_pChainEntity: usize = 0x48; // CNetworkVarChainer
    pub const m_Color: usize = 0x85; // Color
    pub const m_SecondaryColor: usize = 0x89; // Color
    pub const m_flBrightness: usize = 0x90; // float
    pub const m_flBrightnessScale: usize = 0x94; // float
    pub const m_flBrightnessMult: usize = 0x98; // float
    pub const m_flRange: usize = 0x9C; // float
    pub const m_flFalloff: usize = 0xA0; // float
    pub const m_flAttenuation0: usize = 0xA4; // float
    pub const m_flAttenuation1: usize = 0xA8; // float
    pub const m_flAttenuation2: usize = 0xAC; // float
    pub const m_flTheta: usize = 0xB0; // float
    pub const m_flPhi: usize = 0xB4; // float
    pub const m_hLightCookie: usize = 0xB8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_nCascades: usize = 0xC0; // int32_t
    pub const m_nCastShadows: usize = 0xC4; // int32_t
    pub const m_nShadowWidth: usize = 0xC8; // int32_t
    pub const m_nShadowHeight: usize = 0xCC; // int32_t
    pub const m_bRenderDiffuse: usize = 0xD0; // bool
    pub const m_nRenderSpecular: usize = 0xD4; // int32_t
    pub const m_bRenderTransmissive: usize = 0xD8; // bool
    pub const m_flOrthoLightWidth: usize = 0xDC; // float
    pub const m_flOrthoLightHeight: usize = 0xE0; // float
    pub const m_nStyle: usize = 0xE4; // int32_t
    pub const m_Pattern: usize = 0xE8; // CUtlString
    pub const m_nCascadeRenderStaticObjects: usize = 0xF0; // int32_t
    pub const m_flShadowCascadeCrossFade: usize = 0xF4; // float
    pub const m_flShadowCascadeDistanceFade: usize = 0xF8; // float
    pub const m_flShadowCascadeDistance0: usize = 0xFC; // float
    pub const m_flShadowCascadeDistance1: usize = 0x100; // float
    pub const m_flShadowCascadeDistance2: usize = 0x104; // float
    pub const m_flShadowCascadeDistance3: usize = 0x108; // float
    pub const m_nShadowCascadeResolution0: usize = 0x10C; // int32_t
    pub const m_nShadowCascadeResolution1: usize = 0x110; // int32_t
    pub const m_nShadowCascadeResolution2: usize = 0x114; // int32_t
    pub const m_nShadowCascadeResolution3: usize = 0x118; // int32_t
    pub const m_bUsesBakedShadowing: usize = 0x11C; // bool
    pub const m_nShadowPriority: usize = 0x120; // int32_t
    pub const m_nBakedShadowIndex: usize = 0x124; // int32_t
    pub const m_bRenderToCubemaps: usize = 0x128; // bool
    pub const m_nDirectLight: usize = 0x12C; // int32_t
    pub const m_nIndirectLight: usize = 0x130; // int32_t
    pub const m_flFadeMinDist: usize = 0x134; // float
    pub const m_flFadeMaxDist: usize = 0x138; // float
    pub const m_flShadowFadeMinDist: usize = 0x13C; // float
    pub const m_flShadowFadeMaxDist: usize = 0x140; // float
    pub const m_bEnabled: usize = 0x144; // bool
    pub const m_bFlicker: usize = 0x145; // bool
    pub const m_bPrecomputedFieldsValid: usize = 0x146; // bool
    pub const m_vPrecomputedBoundsMins: usize = 0x148; // Vector
    pub const m_vPrecomputedBoundsMaxs: usize = 0x154; // Vector
    pub const m_vPrecomputedOBBOrigin: usize = 0x160; // Vector
    pub const m_vPrecomputedOBBAngles: usize = 0x16C; // QAngle
    pub const m_vPrecomputedOBBExtent: usize = 0x178; // Vector
    pub const m_flPrecomputedMaxRange: usize = 0x184; // float
    pub const m_nFogLightingMode: usize = 0x188; // int32_t
    pub const m_flFogContributionStength: usize = 0x18C; // float
    pub const m_flNearClipPlane: usize = 0x190; // float
    pub const m_SkyColor: usize = 0x194; // Color
    pub const m_flSkyIntensity: usize = 0x198; // float
    pub const m_SkyAmbientBounce: usize = 0x19C; // Color
    pub const m_bUseSecondaryColor: usize = 0x1A0; // bool
    pub const m_bMixedShadows: usize = 0x1A1; // bool
    pub const m_flLightStyleStartTime: usize = 0x1A4; // GameTime_t
    pub const m_flCapsuleLength: usize = 0x1A8; // float
    pub const m_flMinRoughness: usize = 0x1AC; // float
}

pub mod CLogicRelay {
    pub const m_OnTrigger: usize = 0x540; // CEntityIOOutput
    pub const m_OnSpawn: usize = 0x568; // CEntityIOOutput
    pub const m_bDisabled: usize = 0x590; // bool
    pub const m_bWaitForRefire: usize = 0x591; // bool
    pub const m_bTriggerOnce: usize = 0x592; // bool
    pub const m_bFastRetrigger: usize = 0x593; // bool
    pub const m_bPassthoughCaller: usize = 0x594; // bool
}

pub mod CModelState {
    pub const m_hModel: usize = 0xA0; // CStrongHandle<InfoForResourceTypeCModel>
    pub const m_ModelName: usize = 0xA8; // CUtlSymbolLarge
    pub const m_bClientClothCreationSuppressed: usize = 0xE8; // bool
    pub const m_MeshGroupMask: usize = 0x180; // uint64_t
    pub const m_nIdealMotionType: usize = 0x222; // int8_t
    pub const m_nForceLOD: usize = 0x223; // int8_t
    pub const m_nClothUpdateFlags: usize = 0x224; // int8_t
}

pub mod CNetworkedSequenceOperation {
    pub const m_hSequence: usize = 0x8; // HSequence
    pub const m_flPrevCycle: usize = 0xC; // float
    pub const m_flCycle: usize = 0x10; // float
    pub const m_flWeight: usize = 0x14; // CNetworkedQuantizedFloat
    pub const m_bSequenceChangeNetworked: usize = 0x1C; // bool
    pub const m_bDiscontinuity: usize = 0x1D; // bool
    pub const m_flPrevCycleFromDiscontinuity: usize = 0x20; // float
    pub const m_flPrevCycleForAnimEventDetection: usize = 0x24; // float
}

pub mod CPlayer_CameraServices {
    pub const m_vecCsViewPunchAngle: usize = 0x40; // QAngle
    pub const m_nCsViewPunchAngleTick: usize = 0x4C; // GameTick_t
    pub const m_flCsViewPunchAngleTickRatio: usize = 0x50; // float
    pub const m_PlayerFog: usize = 0x58; // C_fogplayerparams_t
    pub const m_hColorCorrectionCtrl: usize = 0x98; // CHandle<C_ColorCorrection>
    pub const m_hViewEntity: usize = 0x9C; // CHandle<C_BaseEntity>
    pub const m_hTonemapController: usize = 0xA0; // CHandle<C_TonemapController2>
    pub const m_audio: usize = 0xA8; // audioparams_t
    pub const m_PostProcessingVolumes: usize = 0x120; // C_NetworkUtlVectorBase<CHandle<C_PostProcessingVolume>>
    pub const m_flOldPlayerZ: usize = 0x138; // float
    pub const m_flOldPlayerViewOffsetZ: usize = 0x13C; // float
    pub const m_CurrentFog: usize = 0x140; // fogparams_t
    pub const m_hOldFogController: usize = 0x1A8; // CHandle<C_FogController>
    pub const m_bOverrideFogColor: usize = 0x1AC; // bool[5]
    pub const m_OverrideFogColor: usize = 0x1B1; // Color[5]
    pub const m_bOverrideFogStartEnd: usize = 0x1C5; // bool[5]
    pub const m_fOverrideFogStart: usize = 0x1CC; // float[5]
    pub const m_fOverrideFogEnd: usize = 0x1E0; // float[5]
    pub const m_hActivePostProcessingVolume: usize = 0x1F4; // CHandle<C_PostProcessingVolume>
    pub const m_angDemoViewAngles: usize = 0x1F8; // QAngle
}

pub mod CPlayer_MovementServices {
    pub const m_nImpulse: usize = 0x40; // int32_t
    pub const m_nButtons: usize = 0x48; // CInButtonState
    pub const m_nQueuedButtonDownMask: usize = 0x68; // uint64_t
    pub const m_nQueuedButtonChangeMask: usize = 0x70; // uint64_t
    pub const m_nButtonDoublePressed: usize = 0x78; // uint64_t
    pub const m_pButtonPressedCmdNumber: usize = 0x80; // uint32_t[64]
    pub const m_nLastCommandNumberProcessed: usize = 0x180; // uint32_t
    pub const m_nToggleButtonDownMask: usize = 0x188; // uint64_t
    pub const m_flMaxspeed: usize = 0x190; // float
    pub const m_arrForceSubtickMoveWhen: usize = 0x194; // float[4]
    pub const m_flForwardMove: usize = 0x1A4; // float
    pub const m_flLeftMove: usize = 0x1A8; // float
    pub const m_flUpMove: usize = 0x1AC; // float
    pub const m_vecLastMovementImpulses: usize = 0x1B0; // Vector
    pub const m_vecOldViewAngles: usize = 0x1BC; // QAngle
}

pub mod CPlayer_MovementServices_Humanoid {
    pub const m_flStepSoundTime: usize = 0x1D0; // float
    pub const m_flFallVelocity: usize = 0x1D4; // float
    pub const m_bInCrouch: usize = 0x1D8; // bool
    pub const m_nCrouchState: usize = 0x1DC; // uint32_t
    pub const m_flCrouchTransitionStartTime: usize = 0x1E0; // GameTime_t
    pub const m_bDucked: usize = 0x1E4; // bool
    pub const m_bDucking: usize = 0x1E5; // bool
    pub const m_bInDuckJump: usize = 0x1E6; // bool
    pub const m_groundNormal: usize = 0x1E8; // Vector
    pub const m_flSurfaceFriction: usize = 0x1F4; // float
    pub const m_surfaceProps: usize = 0x1F8; // CUtlStringToken
    pub const m_nStepside: usize = 0x208; // int32_t
}

pub mod CPlayer_ObserverServices {
    pub const m_iObserverMode: usize = 0x40; // uint8_t
    pub const m_hObserverTarget: usize = 0x44; // CHandle<C_BaseEntity>
    pub const m_iObserverLastMode: usize = 0x48; // ObserverMode_t
    pub const m_bForcedObserverMode: usize = 0x4C; // bool
    pub const m_flObserverChaseDistance: usize = 0x50; // float
    pub const m_flObserverChaseDistanceCalcTime: usize = 0x54; // GameTime_t
}

pub mod CPlayer_WeaponServices {
    pub const m_bAllowSwitchToNoWeapon: usize = 0x40; // bool
    pub const m_hMyWeapons: usize = 0x48; // C_NetworkUtlVectorBase<CHandle<C_BasePlayerWeapon>>
    pub const m_hActiveWeapon: usize = 0x60; // CHandle<C_BasePlayerWeapon>
    pub const m_hLastWeapon: usize = 0x64; // CHandle<C_BasePlayerWeapon>
    pub const m_iAmmo: usize = 0x68; // uint16_t[32]
}

pub mod CPointOffScreenIndicatorUi {
    pub const m_bBeenEnabled: usize = 0xF20; // bool
    pub const m_bHide: usize = 0xF21; // bool
    pub const m_flSeenTargetTime: usize = 0xF24; // float
    pub const m_pTargetPanel: usize = 0xF28; // C_PointClientUIWorldPanel*
}

pub mod CPointTemplate {
    pub const m_iszWorldName: usize = 0x540; // CUtlSymbolLarge
    pub const m_iszSource2EntityLumpName: usize = 0x548; // CUtlSymbolLarge
    pub const m_iszEntityFilterName: usize = 0x550; // CUtlSymbolLarge
    pub const m_flTimeoutInterval: usize = 0x558; // float
    pub const m_bAsynchronouslySpawnEntities: usize = 0x55C; // bool
    pub const m_pOutputOnSpawned: usize = 0x560; // CEntityIOOutput
    pub const m_clientOnlyEntityBehavior: usize = 0x588; // PointTemplateClientOnlyEntityBehavior_t
    pub const m_ownerSpawnGroupType: usize = 0x58C; // PointTemplateOwnerSpawnGroupType_t
    pub const m_createdSpawnGroupHandles: usize = 0x590; // CUtlVector<uint32_t>
    pub const m_SpawnedEntityHandles: usize = 0x5A8; // CUtlVector<CEntityHandle>
    pub const m_ScriptSpawnCallback: usize = 0x5C0; // HSCRIPT
    pub const m_ScriptCallbackScope: usize = 0x5C8; // HSCRIPT
}

pub mod CPrecipitationVData {
    pub const m_szParticlePrecipitationEffect: usize = 0x28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    pub const m_flInnerDistance: usize = 0x108; // float
    pub const m_nAttachType: usize = 0x10C; // ParticleAttachment_t
    pub const m_bBatchSameVolumeType: usize = 0x110; // bool
    pub const m_nRTEnvCP: usize = 0x114; // int32_t
    pub const m_nRTEnvCPComponent: usize = 0x118; // int32_t
    pub const m_szModifier: usize = 0x120; // CUtlString
}

pub mod CProjectedTextureBase {
    pub const m_hTargetEntity: usize = 0xC; // CHandle<C_BaseEntity>
    pub const m_bState: usize = 0x10; // bool
    pub const m_bAlwaysUpdate: usize = 0x11; // bool
    pub const m_flLightFOV: usize = 0x14; // float
    pub const m_bEnableShadows: usize = 0x18; // bool
    pub const m_bSimpleProjection: usize = 0x19; // bool
    pub const m_bLightOnlyTarget: usize = 0x1A; // bool
    pub const m_bLightWorld: usize = 0x1B; // bool
    pub const m_bCameraSpace: usize = 0x1C; // bool
    pub const m_flBrightnessScale: usize = 0x20; // float
    pub const m_LightColor: usize = 0x24; // Color
    pub const m_flIntensity: usize = 0x28; // float
    pub const m_flLinearAttenuation: usize = 0x2C; // float
    pub const m_flQuadraticAttenuation: usize = 0x30; // float
    pub const m_bVolumetric: usize = 0x34; // bool
    pub const m_flVolumetricIntensity: usize = 0x38; // float
    pub const m_flNoiseStrength: usize = 0x3C; // float
    pub const m_flFlashlightTime: usize = 0x40; // float
    pub const m_nNumPlanes: usize = 0x44; // uint32_t
    pub const m_flPlaneOffset: usize = 0x48; // float
    pub const m_flColorTransitionTime: usize = 0x4C; // float
    pub const m_flAmbient: usize = 0x50; // float
    pub const m_SpotlightTextureName: usize = 0x54; // char[512]
    pub const m_nSpotlightTextureFrame: usize = 0x254; // int32_t
    pub const m_nShadowQuality: usize = 0x258; // uint32_t
    pub const m_flNearZ: usize = 0x25C; // float
    pub const m_flFarZ: usize = 0x260; // float
    pub const m_flProjectionSize: usize = 0x264; // float
    pub const m_flRotation: usize = 0x268; // float
    pub const m_bFlipHorizontal: usize = 0x26C; // bool
}

pub mod CRenderComponent {
    pub const __m_pChainEntity: usize = 0x10; // CNetworkVarChainer
    pub const m_bIsRenderingWithViewModels: usize = 0x50; // bool
    pub const m_nSplitscreenFlags: usize = 0x54; // uint32_t
    pub const m_bEnableRendering: usize = 0x60; // bool
    pub const m_bInterpolationReadyToDraw: usize = 0xB0; // bool
}

pub mod CSMatchStats_t {
    pub const m_iEnemy5Ks: usize = 0x68; // int32_t
    pub const m_iEnemy4Ks: usize = 0x6C; // int32_t
    pub const m_iEnemy3Ks: usize = 0x70; // int32_t
}

pub mod CSPerRoundStats_t {
    pub const m_iKills: usize = 0x30; // int32_t
    pub const m_iDeaths: usize = 0x34; // int32_t
    pub const m_iAssists: usize = 0x38; // int32_t
    pub const m_iDamage: usize = 0x3C; // int32_t
    pub const m_iEquipmentValue: usize = 0x40; // int32_t
    pub const m_iMoneySaved: usize = 0x44; // int32_t
    pub const m_iKillReward: usize = 0x48; // int32_t
    pub const m_iLiveTime: usize = 0x4C; // int32_t
    pub const m_iHeadShotKills: usize = 0x50; // int32_t
    pub const m_iObjective: usize = 0x54; // int32_t
    pub const m_iCashEarned: usize = 0x58; // int32_t
    pub const m_iUtilityDamage: usize = 0x5C; // int32_t
    pub const m_iEnemiesFlashed: usize = 0x60; // int32_t
}

pub mod CScriptComponent {
    pub const m_scriptClassName: usize = 0x30; // CUtlSymbolLarge
}

pub mod CSkeletonInstance {
    pub const m_modelState: usize = 0x160; // CModelState
    pub const m_bIsAnimationEnabled: usize = 0x390; // bool
    pub const m_bUseParentRenderBounds: usize = 0x391; // bool
    pub const m_bDisableSolidCollisionsForHierarchy: usize = 0x392; // bool
    pub const m_bDirtyMotionType: usize = 0x0; // bitfield:1
    pub const m_bIsGeneratingLatchedParentSpaceState: usize = 0x0; // bitfield:1
    pub const m_materialGroup: usize = 0x394; // CUtlStringToken
    pub const m_nHitboxSet: usize = 0x398; // uint8_t
}

pub mod CSkyboxReference {
    pub const m_worldGroupId: usize = 0x540; // WorldGroupId_t
    pub const m_hSkyCamera: usize = 0x544; // CHandle<C_SkyCamera>
}

pub mod CTimeline {
    pub const m_flValues: usize = 0x10; // float[64]
    pub const m_nValueCounts: usize = 0x110; // int32_t[64]
    pub const m_nBucketCount: usize = 0x210; // int32_t
    pub const m_flInterval: usize = 0x214; // float
    pub const m_flFinalValue: usize = 0x218; // float
    pub const m_nCompressionType: usize = 0x21C; // TimelineCompression_t
    pub const m_bStopped: usize = 0x220; // bool
}

pub mod C_AttributeContainer {
    pub const m_Item: usize = 0x50; // C_EconItemView
    pub const m_iExternalItemProviderRegisteredToken: usize = 0x498; // int32_t
    pub const m_ullRegisteredAsItemID: usize = 0x4A0; // uint64_t
}

pub mod C_BarnLight {
    pub const m_bEnabled: usize = 0xCC0; // bool
    pub const m_nColorMode: usize = 0xCC4; // int32_t
    pub const m_Color: usize = 0xCC8; // Color
    pub const m_flColorTemperature: usize = 0xCCC; // float
    pub const m_flBrightness: usize = 0xCD0; // float
    pub const m_flBrightnessScale: usize = 0xCD4; // float
    pub const m_nDirectLight: usize = 0xCD8; // int32_t
    pub const m_nBakedShadowIndex: usize = 0xCDC; // int32_t
    pub const m_nLuminaireShape: usize = 0xCE0; // int32_t
    pub const m_flLuminaireSize: usize = 0xCE4; // float
    pub const m_flLuminaireAnisotropy: usize = 0xCE8; // float
    pub const m_LightStyleString: usize = 0xCF0; // CUtlString
    pub const m_flLightStyleStartTime: usize = 0xCF8; // GameTime_t
    pub const m_QueuedLightStyleStrings: usize = 0xD00; // C_NetworkUtlVectorBase<CUtlString>
    pub const m_LightStyleEvents: usize = 0xD18; // C_NetworkUtlVectorBase<CUtlString>
    pub const m_LightStyleTargets: usize = 0xD30; // C_NetworkUtlVectorBase<CHandle<C_BaseModelEntity>>
    pub const m_StyleEvent: usize = 0xD48; // CEntityIOOutput[4]
    pub const m_hLightCookie: usize = 0xDE8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_flShape: usize = 0xDF0; // float
    pub const m_flSoftX: usize = 0xDF4; // float
    pub const m_flSoftY: usize = 0xDF8; // float
    pub const m_flSkirt: usize = 0xDFC; // float
    pub const m_flSkirtNear: usize = 0xE00; // float
    pub const m_vSizeParams: usize = 0xE04; // Vector
    pub const m_flRange: usize = 0xE10; // float
    pub const m_vShear: usize = 0xE14; // Vector
    pub const m_nBakeSpecularToCubemaps: usize = 0xE20; // int32_t
    pub const m_vBakeSpecularToCubemapsSize: usize = 0xE24; // Vector
    pub const m_nCastShadows: usize = 0xE30; // int32_t
    pub const m_nShadowMapSize: usize = 0xE34; // int32_t
    pub const m_nShadowPriority: usize = 0xE38; // int32_t
    pub const m_bContactShadow: usize = 0xE3C; // bool
    pub const m_nBounceLight: usize = 0xE40; // int32_t
    pub const m_flBounceScale: usize = 0xE44; // float
    pub const m_flMinRoughness: usize = 0xE48; // float
    pub const m_vAlternateColor: usize = 0xE4C; // Vector
    pub const m_fAlternateColorBrightness: usize = 0xE58; // float
    pub const m_nFog: usize = 0xE5C; // int32_t
    pub const m_flFogStrength: usize = 0xE60; // float
    pub const m_nFogShadows: usize = 0xE64; // int32_t
    pub const m_flFogScale: usize = 0xE68; // float
    pub const m_flFadeSizeStart: usize = 0xE6C; // float
    pub const m_flFadeSizeEnd: usize = 0xE70; // float
    pub const m_flShadowFadeSizeStart: usize = 0xE74; // float
    pub const m_flShadowFadeSizeEnd: usize = 0xE78; // float
    pub const m_bPrecomputedFieldsValid: usize = 0xE7C; // bool
    pub const m_vPrecomputedBoundsMins: usize = 0xE80; // Vector
    pub const m_vPrecomputedBoundsMaxs: usize = 0xE8C; // Vector
    pub const m_vPrecomputedOBBOrigin: usize = 0xE98; // Vector
    pub const m_vPrecomputedOBBAngles: usize = 0xEA4; // QAngle
    pub const m_vPrecomputedOBBExtent: usize = 0xEB0; // Vector
}

pub mod C_BaseButton {
    pub const m_glowEntity: usize = 0xCC0; // CHandle<C_BaseModelEntity>
    pub const m_usable: usize = 0xCC4; // bool
    pub const m_szDisplayText: usize = 0xCC8; // CUtlSymbolLarge
}

pub mod C_BaseCSGrenade {
    pub const m_bClientPredictDelete: usize = 0x19F0; // bool
    pub const m_bRedraw: usize = 0x19F1; // bool
    pub const m_bIsHeldByPlayer: usize = 0x19F2; // bool
    pub const m_bPinPulled: usize = 0x19F3; // bool
    pub const m_bJumpThrow: usize = 0x19F4; // bool
    pub const m_eThrowStatus: usize = 0x19F8; // EGrenadeThrowState
    pub const m_fThrowTime: usize = 0x19FC; // GameTime_t
    pub const m_flThrowStrength: usize = 0x1A00; // float
    pub const m_flThrowStrengthApproach: usize = 0x1A04; // float
    pub const m_fDropTime: usize = 0x1A08; // GameTime_t
}

pub mod C_BaseCSGrenadeProjectile {
    pub const m_vInitialPosition: usize = 0x1068; // Vector
    pub const m_vInitialVelocity: usize = 0x1074; // Vector
    pub const m_nBounces: usize = 0x1080; // int32_t
    pub const m_nExplodeEffectIndex: usize = 0x1088; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    pub const m_nExplodeEffectTickBegin: usize = 0x1090; // int32_t
    pub const m_vecExplodeEffectOrigin: usize = 0x1094; // Vector
    pub const m_flSpawnTime: usize = 0x10A0; // GameTime_t
    pub const vecLastTrailLinePos: usize = 0x10A4; // Vector
    pub const flNextTrailLineTime: usize = 0x10B0; // GameTime_t
    pub const m_bExplodeEffectBegan: usize = 0x10B4; // bool
    pub const m_bCanCreateGrenadeTrail: usize = 0x10B5; // bool
    pub const m_nSnapshotTrajectoryEffectIndex: usize = 0x10B8; // ParticleIndex_t
    pub const m_hSnapshotTrajectoryParticleSnapshot: usize = 0x10C0; // CStrongHandle<InfoForResourceTypeIParticleSnapshot>
    pub const m_arrTrajectoryTrailPoints: usize = 0x10C8; // CUtlVector<Vector>
    pub const m_arrTrajectoryTrailPointCreationTimes: usize = 0x10E0; // CUtlVector<float>
    pub const m_flTrajectoryTrailEffectCreationTime: usize = 0x10F8; // float
}

pub mod C_BaseClientUIEntity {
    pub const m_bEnabled: usize = 0xCC8; // bool
    pub const m_DialogXMLName: usize = 0xCD0; // CUtlSymbolLarge
    pub const m_PanelClassName: usize = 0xCD8; // CUtlSymbolLarge
    pub const m_PanelID: usize = 0xCE0; // CUtlSymbolLarge
}

pub mod C_BaseCombatCharacter {
    pub const m_hMyWearables: usize = 0x1018; // C_NetworkUtlVectorBase<CHandle<C_EconWearable>>
    pub const m_bloodColor: usize = 0x1030; // int32_t
    pub const m_leftFootAttachment: usize = 0x1034; // AttachmentHandle_t
    pub const m_rightFootAttachment: usize = 0x1035; // AttachmentHandle_t
    pub const m_nWaterWakeMode: usize = 0x1038; // C_BaseCombatCharacter::WaterWakeMode_t
    pub const m_flWaterWorldZ: usize = 0x103C; // float
    pub const m_flWaterNextTraceTime: usize = 0x1040; // float
    pub const m_flFieldOfView: usize = 0x1044; // float
}

pub mod C_BaseDoor {
    pub const m_bIsUsable: usize = 0xCC0; // bool
}

pub mod C_BaseEntity {
    pub const m_CBodyComponent: usize = 0x30; // CBodyComponent*
    pub const m_NetworkTransmitComponent: usize = 0x38; // CNetworkTransmitComponent
    pub const m_nLastThinkTick: usize = 0x308; // GameTick_t
    pub const m_pGameSceneNode: usize = 0x310; // CGameSceneNode*
    pub const m_pRenderComponent: usize = 0x318; // CRenderComponent*
    pub const m_pCollision: usize = 0x320; // CCollisionProperty*
    pub const m_iMaxHealth: usize = 0x328; // int32_t
    pub const m_iHealth: usize = 0x32C; // int32_t
    pub const m_lifeState: usize = 0x330; // uint8_t
    pub const m_bTakesDamage: usize = 0x331; // bool
    pub const m_nTakeDamageFlags: usize = 0x334; // TakeDamageFlags_t
    pub const m_ubInterpolationFrame: usize = 0x338; // uint8_t
    pub const m_hSceneObjectController: usize = 0x33C; // CHandle<C_BaseEntity>
    pub const m_nNoInterpolationTick: usize = 0x340; // int32_t
    pub const m_nVisibilityNoInterpolationTick: usize = 0x344; // int32_t
    pub const m_flProxyRandomValue: usize = 0x348; // float
    pub const m_iEFlags: usize = 0x34C; // int32_t
    pub const m_nWaterType: usize = 0x350; // uint8_t
    pub const m_bInterpolateEvenWithNoModel: usize = 0x351; // bool
    pub const m_bPredictionEligible: usize = 0x352; // bool
    pub const m_bApplyLayerMatchIDToModel: usize = 0x353; // bool
    pub const m_tokLayerMatchID: usize = 0x354; // CUtlStringToken
    pub const m_nSubclassID: usize = 0x358; // CUtlStringToken
    pub const m_nSimulationTick: usize = 0x368; // int32_t
    pub const m_iCurrentThinkContext: usize = 0x36C; // int32_t
    pub const m_aThinkFunctions: usize = 0x370; // CUtlVector<thinkfunc_t>
    pub const m_flAnimTime: usize = 0x388; // float
    pub const m_flSimulationTime: usize = 0x38C; // float
    pub const m_nSceneObjectOverrideFlags: usize = 0x390; // uint8_t
    pub const m_bHasSuccessfullyInterpolated: usize = 0x391; // bool
    pub const m_bHasAddedVarsToInterpolation: usize = 0x392; // bool
    pub const m_bRenderEvenWhenNotSuccessfullyInterpolated: usize = 0x393; // bool
    pub const m_nInterpolationLatchDirtyFlags: usize = 0x394; // int32_t[2]
    pub const m_ListEntry: usize = 0x39C; // uint16_t[11]
    pub const m_flCreateTime: usize = 0x3B4; // GameTime_t
    pub const m_flSpeed: usize = 0x3B8; // float
    pub const m_EntClientFlags: usize = 0x3BC; // uint16_t
    pub const m_bClientSideRagdoll: usize = 0x3BE; // bool
    pub const m_iTeamNum: usize = 0x3BF; // uint8_t
    pub const m_spawnflags: usize = 0x3C0; // uint32_t
    pub const m_nNextThinkTick: usize = 0x3C4; // GameTick_t
    pub const m_fFlags: usize = 0x3C8; // uint32_t
    pub const m_vecAbsVelocity: usize = 0x3CC; // Vector
    pub const m_vecVelocity: usize = 0x3D8; // CNetworkVelocityVector
    pub const m_vecBaseVelocity: usize = 0x408; // Vector
    pub const m_hEffectEntity: usize = 0x414; // CHandle<C_BaseEntity>
    pub const m_hOwnerEntity: usize = 0x418; // CHandle<C_BaseEntity>
    pub const m_MoveCollide: usize = 0x41C; // MoveCollide_t
    pub const m_MoveType: usize = 0x41D; // MoveType_t
    pub const m_flWaterLevel: usize = 0x420; // float
    pub const m_fEffects: usize = 0x424; // uint32_t
    pub const m_hGroundEntity: usize = 0x428; // CHandle<C_BaseEntity>
    pub const m_flFriction: usize = 0x42C; // float
    pub const m_flElasticity: usize = 0x430; // float
    pub const m_flGravityScale: usize = 0x434; // float
    pub const m_flTimeScale: usize = 0x438; // float
    pub const m_bSimulatedEveryTick: usize = 0x43C; // bool
    pub const m_bAnimatedEveryTick: usize = 0x43D; // bool
    pub const m_flNavIgnoreUntilTime: usize = 0x440; // GameTime_t
    pub const m_hThink: usize = 0x444; // uint16_t
    pub const m_fBBoxVisFlags: usize = 0x450; // uint8_t
    pub const m_bPredictable: usize = 0x451; // bool
    pub const m_bRenderWithViewModels: usize = 0x452; // bool
    pub const m_nSplitUserPlayerPredictionSlot: usize = 0x454; // CSplitScreenSlot
    pub const m_nFirstPredictableCommand: usize = 0x458; // int32_t
    pub const m_nLastPredictableCommand: usize = 0x45C; // int32_t
    pub const m_hOldMoveParent: usize = 0x460; // CHandle<C_BaseEntity>
    pub const m_Particles: usize = 0x468; // CParticleProperty
    pub const m_vecPredictedScriptFloats: usize = 0x490; // CUtlVector<float>
    pub const m_vecPredictedScriptFloatIDs: usize = 0x4A8; // CUtlVector<int32_t>
    pub const m_nNextScriptVarRecordID: usize = 0x4D8; // int32_t
    pub const m_vecAngVelocity: usize = 0x4E8; // QAngle
    pub const m_DataChangeEventRef: usize = 0x4F4; // int32_t
    pub const m_dependencies: usize = 0x4F8; // CUtlVector<CEntityHandle>
    pub const m_nCreationTick: usize = 0x510; // int32_t
    pub const m_bAnimTimeChanged: usize = 0x529; // bool
    pub const m_bSimulationTimeChanged: usize = 0x52A; // bool
    pub const m_sUniqueHammerID: usize = 0x538; // CUtlString
}

pub mod C_BaseFire {
    pub const m_flScale: usize = 0x540; // float
    pub const m_flStartScale: usize = 0x544; // float
    pub const m_flScaleTime: usize = 0x548; // float
    pub const m_nFlags: usize = 0x54C; // uint32_t
}

pub mod C_BaseFlex {
    pub const m_flexWeight: usize = 0xE90; // C_NetworkUtlVectorBase<float>
    pub const m_vLookTargetPosition: usize = 0xEA8; // Vector
    pub const m_blinktoggle: usize = 0xEC0; // bool
    pub const m_nLastFlexUpdateFrameCount: usize = 0xF20; // int32_t
    pub const m_CachedViewTarget: usize = 0xF24; // Vector
    pub const m_nNextSceneEventId: usize = 0xF30; // uint32_t
    pub const m_iBlink: usize = 0xF34; // int32_t
    pub const m_blinktime: usize = 0xF38; // float
    pub const m_prevblinktoggle: usize = 0xF3C; // bool
    pub const m_iJawOpen: usize = 0xF40; // int32_t
    pub const m_flJawOpenAmount: usize = 0xF44; // float
    pub const m_flBlinkAmount: usize = 0xF48; // float
    pub const m_iMouthAttachment: usize = 0xF4C; // AttachmentHandle_t
    pub const m_iEyeAttachment: usize = 0xF4D; // AttachmentHandle_t
    pub const m_bResetFlexWeightsOnModelChange: usize = 0xF4E; // bool
    pub const m_nEyeOcclusionRendererBone: usize = 0xF68; // int32_t
    pub const m_mEyeOcclusionRendererCameraToBoneTransform: usize = 0xF6C; // matrix3x4_t
    pub const m_vEyeOcclusionRendererHalfExtent: usize = 0xF9C; // Vector
    pub const m_PhonemeClasses: usize = 0xFB8; // C_BaseFlex::Emphasized_Phoneme[3]
}

pub mod C_BaseFlex_Emphasized_Phoneme {
    pub const m_sClassName: usize = 0x0; // CUtlString
    pub const m_flAmount: usize = 0x18; // float
    pub const m_bRequired: usize = 0x1C; // bool
    pub const m_bBasechecked: usize = 0x1D; // bool
    pub const m_bValid: usize = 0x1E; // bool
}

pub mod C_BaseGrenade {
    pub const m_bHasWarnedAI: usize = 0x1018; // bool
    pub const m_bIsSmokeGrenade: usize = 0x1019; // bool
    pub const m_bIsLive: usize = 0x101A; // bool
    pub const m_DmgRadius: usize = 0x101C; // float
    pub const m_flDetonateTime: usize = 0x1020; // GameTime_t
    pub const m_flWarnAITime: usize = 0x1024; // float
    pub const m_flDamage: usize = 0x1028; // float
    pub const m_iszBounceSound: usize = 0x1030; // CUtlSymbolLarge
    pub const m_ExplosionSound: usize = 0x1038; // CUtlString
    pub const m_hThrower: usize = 0x1044; // CHandle<C_CSPlayerPawn>
    pub const m_flNextAttack: usize = 0x105C; // GameTime_t
    pub const m_hOriginalThrower: usize = 0x1060; // CHandle<C_CSPlayerPawn>
}

pub mod C_BaseModelEntity {
    pub const m_CRenderComponent: usize = 0xA10; // CRenderComponent*
    pub const m_CHitboxComponent: usize = 0xA18; // CHitboxComponent
    pub const m_bInitModelEffects: usize = 0xA60; // bool
    pub const m_bIsStaticProp: usize = 0xA61; // bool
    pub const m_nLastAddDecal: usize = 0xA64; // int32_t
    pub const m_nDecalsAdded: usize = 0xA68; // int32_t
    pub const m_iOldHealth: usize = 0xA6C; // int32_t
    pub const m_nRenderMode: usize = 0xA70; // RenderMode_t
    pub const m_nRenderFX: usize = 0xA71; // RenderFx_t
    pub const m_bAllowFadeInView: usize = 0xA72; // bool
    pub const m_clrRender: usize = 0xA73; // Color
    pub const m_vecRenderAttributes: usize = 0xA78; // C_UtlVectorEmbeddedNetworkVar<EntityRenderAttribute_t>
    pub const m_bRenderToCubemaps: usize = 0xAE0; // bool
    pub const m_Collision: usize = 0xAE8; // CCollisionProperty
    pub const m_Glow: usize = 0xB98; // CGlowProperty
    pub const m_flGlowBackfaceMult: usize = 0xBF0; // float
    pub const m_fadeMinDist: usize = 0xBF4; // float
    pub const m_fadeMaxDist: usize = 0xBF8; // float
    pub const m_flFadeScale: usize = 0xBFC; // float
    pub const m_flShadowStrength: usize = 0xC00; // float
    pub const m_nObjectCulling: usize = 0xC04; // uint8_t
    pub const m_nAddDecal: usize = 0xC08; // int32_t
    pub const m_vDecalPosition: usize = 0xC0C; // Vector
    pub const m_vDecalForwardAxis: usize = 0xC18; // Vector
    pub const m_flDecalHealBloodRate: usize = 0xC24; // float
    pub const m_flDecalHealHeightRate: usize = 0xC28; // float
    pub const m_ConfigEntitiesToPropagateMaterialDecalsTo: usize = 0xC30; // C_NetworkUtlVectorBase<CHandle<C_BaseModelEntity>>
    pub const m_vecViewOffset: usize = 0xC48; // CNetworkViewOffsetVector
    pub const m_pClientAlphaProperty: usize = 0xC78; // CClientAlphaProperty*
    pub const m_ClientOverrideTint: usize = 0xC80; // Color
    pub const m_bUseClientOverrideTint: usize = 0xC84; // bool
}

pub mod C_BasePlayerPawn {
    pub const m_pWeaponServices: usize = 0x10A8; // CPlayer_WeaponServices*
    pub const m_pItemServices: usize = 0x10B0; // CPlayer_ItemServices*
    pub const m_pAutoaimServices: usize = 0x10B8; // CPlayer_AutoaimServices*
    pub const m_pObserverServices: usize = 0x10C0; // CPlayer_ObserverServices*
    pub const m_pWaterServices: usize = 0x10C8; // CPlayer_WaterServices*
    pub const m_pUseServices: usize = 0x10D0; // CPlayer_UseServices*
    pub const m_pFlashlightServices: usize = 0x10D8; // CPlayer_FlashlightServices*
    pub const m_pCameraServices: usize = 0x10E0; // CPlayer_CameraServices*
    pub const m_pMovementServices: usize = 0x10E8; // CPlayer_MovementServices*
    pub const m_ServerViewAngleChanges: usize = 0x10F8; // C_UtlVectorEmbeddedNetworkVar<ViewAngleServerChange_t>
    pub const m_nHighestConsumedServerViewAngleChangeIndex: usize = 0x1148; // uint32_t
    pub const v_angle: usize = 0x114C; // QAngle
    pub const v_anglePrevious: usize = 0x1158; // QAngle
    pub const m_iHideHUD: usize = 0x1164; // uint32_t
    pub const m_skybox3d: usize = 0x1168; // sky3dparams_t
    pub const m_flDeathTime: usize = 0x11F8; // GameTime_t
    pub const m_vecPredictionError: usize = 0x11FC; // Vector
    pub const m_flPredictionErrorTime: usize = 0x1208; // GameTime_t
    pub const m_vecLastCameraSetupLocalOrigin: usize = 0x120C; // Vector
    pub const m_flLastCameraSetupTime: usize = 0x1218; // GameTime_t
    pub const m_flFOVSensitivityAdjust: usize = 0x121C; // float
    pub const m_flMouseSensitivity: usize = 0x1220; // float
    pub const m_vOldOrigin: usize = 0x1224; // Vector
    pub const m_flOldSimulationTime: usize = 0x1230; // float
    pub const m_nLastExecutedCommandNumber: usize = 0x1234; // int32_t
    pub const m_nLastExecutedCommandTick: usize = 0x1238; // int32_t
    pub const m_hController: usize = 0x123C; // CHandle<CBasePlayerController>
    pub const m_bIsSwappingToPredictableController: usize = 0x1240; // bool
}

pub mod C_BasePlayerWeapon {
    pub const m_nNextPrimaryAttackTick: usize = 0x1560; // GameTick_t
    pub const m_flNextPrimaryAttackTickRatio: usize = 0x1564; // float
    pub const m_nNextSecondaryAttackTick: usize = 0x1568; // GameTick_t
    pub const m_flNextSecondaryAttackTickRatio: usize = 0x156C; // float
    pub const m_iClip1: usize = 0x1570; // int32_t
    pub const m_iClip2: usize = 0x1574; // int32_t
    pub const m_pReserveAmmo: usize = 0x1578; // int32_t[2]
}

pub mod C_BasePropDoor {
    pub const m_eDoorState: usize = 0x10F8; // DoorState_t
    pub const m_modelChanged: usize = 0x10FC; // bool
    pub const m_bLocked: usize = 0x10FD; // bool
    pub const m_closedPosition: usize = 0x1100; // Vector
    pub const m_closedAngles: usize = 0x110C; // QAngle
    pub const m_hMaster: usize = 0x1118; // CHandle<C_BasePropDoor>
    pub const m_vWhereToSetLightingOrigin: usize = 0x111C; // Vector
}

pub mod C_BaseTrigger {
    pub const m_bDisabled: usize = 0xCC0; // bool
    pub const m_bClientSidePredicted: usize = 0xCC1; // bool
}

pub mod C_BaseViewModel {
    pub const m_vecLastFacing: usize = 0xE88; // Vector
    pub const m_nViewModelIndex: usize = 0xE94; // uint32_t
    pub const m_nAnimationParity: usize = 0xE98; // uint32_t
    pub const m_flAnimationStartTime: usize = 0xE9C; // float
    pub const m_hWeapon: usize = 0xEA0; // CHandle<C_BasePlayerWeapon>
    pub const m_sVMName: usize = 0xEA8; // CUtlSymbolLarge
    pub const m_sAnimationPrefix: usize = 0xEB0; // CUtlSymbolLarge
    pub const m_hWeaponModel: usize = 0xEB8; // CHandle<C_ViewmodelWeapon>
    pub const m_iCameraAttachment: usize = 0xEBC; // AttachmentHandle_t
    pub const m_vecLastCameraAngles: usize = 0xEC0; // QAngle
    pub const m_previousElapsedDuration: usize = 0xECC; // float
    pub const m_previousCycle: usize = 0xED0; // float
    pub const m_nOldAnimationParity: usize = 0xED4; // int32_t
    pub const m_hOldLayerSequence: usize = 0xED8; // HSequence
    pub const m_oldLayer: usize = 0xEDC; // int32_t
    pub const m_oldLayerStartTime: usize = 0xEE0; // float
    pub const m_hControlPanel: usize = 0xEE4; // CHandle<C_BaseEntity>
}

pub mod C_Beam {
    pub const m_flFrameRate: usize = 0xCC0; // float
    pub const m_flHDRColorScale: usize = 0xCC4; // float
    pub const m_flFireTime: usize = 0xCC8; // GameTime_t
    pub const m_flDamage: usize = 0xCCC; // float
    pub const m_nNumBeamEnts: usize = 0xCD0; // uint8_t
    pub const m_queryHandleHalo: usize = 0xCD4; // int32_t
    pub const m_hBaseMaterial: usize = 0xCF8; // CStrongHandle<InfoForResourceTypeIMaterial2>
    pub const m_nHaloIndex: usize = 0xD00; // CStrongHandle<InfoForResourceTypeIMaterial2>
    pub const m_nBeamType: usize = 0xD08; // BeamType_t
    pub const m_nBeamFlags: usize = 0xD0C; // uint32_t
    pub const m_hAttachEntity: usize = 0xD10; // CHandle<C_BaseEntity>[10]
    pub const m_nAttachIndex: usize = 0xD38; // AttachmentHandle_t[10]
    pub const m_fWidth: usize = 0xD44; // float
    pub const m_fEndWidth: usize = 0xD48; // float
    pub const m_fFadeLength: usize = 0xD4C; // float
    pub const m_fHaloScale: usize = 0xD50; // float
    pub const m_fAmplitude: usize = 0xD54; // float
    pub const m_fStartFrame: usize = 0xD58; // float
    pub const m_fSpeed: usize = 0xD5C; // float
    pub const m_flFrame: usize = 0xD60; // float
    pub const m_nClipStyle: usize = 0xD64; // BeamClipStyle_t
    pub const m_bTurnedOff: usize = 0xD68; // bool
    pub const m_vecEndPos: usize = 0xD6C; // Vector
    pub const m_hEndEntity: usize = 0xD78; // CHandle<C_BaseEntity>
}

pub mod C_BreakableProp {
    pub const m_OnBreak: usize = 0xEC8; // CEntityIOOutput
    pub const m_OnHealthChanged: usize = 0xEF0; // CEntityOutputTemplate<float>
    pub const m_OnTakeDamage: usize = 0xF18; // CEntityIOOutput
    pub const m_impactEnergyScale: usize = 0xF40; // float
    pub const m_iMinHealthDmg: usize = 0xF44; // int32_t
    pub const m_flPressureDelay: usize = 0xF48; // float
    pub const m_hBreaker: usize = 0xF4C; // CHandle<C_BaseEntity>
    pub const m_PerformanceMode: usize = 0xF50; // PerformanceMode_t
    pub const m_flDmgModBullet: usize = 0xF54; // float
    pub const m_flDmgModClub: usize = 0xF58; // float
    pub const m_flDmgModExplosive: usize = 0xF5C; // float
    pub const m_flDmgModFire: usize = 0xF60; // float
    pub const m_iszPhysicsDamageTableName: usize = 0xF68; // CUtlSymbolLarge
    pub const m_iszBasePropData: usize = 0xF70; // CUtlSymbolLarge
    pub const m_iInteractions: usize = 0xF78; // int32_t
    pub const m_flPreventDamageBeforeTime: usize = 0xF7C; // GameTime_t
    pub const m_bHasBreakPiecesOrCommands: usize = 0xF80; // bool
    pub const m_explodeDamage: usize = 0xF84; // float
    pub const m_explodeRadius: usize = 0xF88; // float
    pub const m_explosionDelay: usize = 0xF90; // float
    pub const m_explosionBuildupSound: usize = 0xF98; // CUtlSymbolLarge
    pub const m_explosionCustomEffect: usize = 0xFA0; // CUtlSymbolLarge
    pub const m_explosionCustomSound: usize = 0xFA8; // CUtlSymbolLarge
    pub const m_explosionModifier: usize = 0xFB0; // CUtlSymbolLarge
    pub const m_hPhysicsAttacker: usize = 0xFB8; // CHandle<C_BasePlayerPawn>
    pub const m_flLastPhysicsInfluenceTime: usize = 0xFBC; // GameTime_t
    pub const m_flDefaultFadeScale: usize = 0xFC0; // float
    pub const m_hLastAttacker: usize = 0xFC4; // CHandle<C_BaseEntity>
    pub const m_hFlareEnt: usize = 0xFC8; // CHandle<C_BaseEntity>
    pub const m_noGhostCollision: usize = 0xFCC; // bool
}

pub mod C_BulletHitModel {
    pub const m_matLocal: usize = 0xE80; // matrix3x4_t
    pub const m_iBoneIndex: usize = 0xEB0; // int32_t
    pub const m_hPlayerParent: usize = 0xEB4; // CHandle<C_BaseEntity>
    pub const m_bIsHit: usize = 0xEB8; // bool
    pub const m_flTimeCreated: usize = 0xEBC; // float
    pub const m_vecStartPos: usize = 0xEC0; // Vector
}

pub mod C_C4 {
    pub const m_szScreenText: usize = 0x19F0; // char[32]
    pub const m_activeLightParticleIndex: usize = 0x1A10; // ParticleIndex_t
    pub const m_eActiveLightEffect: usize = 0x1A14; // C4LightEffect_t
    pub const m_bStartedArming: usize = 0x1A18; // bool
    pub const m_fArmedTime: usize = 0x1A1C; // GameTime_t
    pub const m_bBombPlacedAnimation: usize = 0x1A20; // bool
    pub const m_bIsPlantingViaUse: usize = 0x1A21; // bool
    pub const m_entitySpottedState: usize = 0x1A28; // EntitySpottedState_t
    pub const m_nSpotRules: usize = 0x1A40; // int32_t
    pub const m_bPlayedArmingBeeps: usize = 0x1A44; // bool[7]
    pub const m_bBombPlanted: usize = 0x1A4B; // bool
    pub const m_bDroppedFromDeath: usize = 0x1A4C; // bool
}

pub mod C_CSGOViewModel {
    pub const m_bShouldIgnoreOffsetAndAccuracy: usize = 0xF10; // bool
    pub const m_nWeaponParity: usize = 0xF14; // uint32_t
    pub const m_nOldWeaponParity: usize = 0xF18; // uint32_t
    pub const m_nLastKnownAssociatedWeaponEntIndex: usize = 0xF1C; // CEntityIndex
    pub const m_bNeedToQueueHighResComposite: usize = 0xF20; // bool
    pub const m_vLoweredWeaponOffset: usize = 0xF64; // QAngle
}

pub mod C_CSGO_MapPreviewCameraPath {
    pub const m_flZFar: usize = 0x540; // float
    pub const m_flZNear: usize = 0x544; // float
    pub const m_bLoop: usize = 0x548; // bool
    pub const m_bVerticalFOV: usize = 0x549; // bool
    pub const m_bConstantSpeed: usize = 0x54A; // bool
    pub const m_flDuration: usize = 0x54C; // float
    pub const m_flPathLength: usize = 0x590; // float
    pub const m_flPathDuration: usize = 0x594; // float
}

pub mod C_CSGO_MapPreviewCameraPathNode {
    pub const m_szParentPathUniqueID: usize = 0x540; // CUtlSymbolLarge
    pub const m_nPathIndex: usize = 0x548; // int32_t
    pub const m_vInTangentLocal: usize = 0x54C; // Vector
    pub const m_vOutTangentLocal: usize = 0x558; // Vector
    pub const m_flFOV: usize = 0x564; // float
    pub const m_flSpeed: usize = 0x568; // float
    pub const m_flEaseIn: usize = 0x56C; // float
    pub const m_flEaseOut: usize = 0x570; // float
    pub const m_vInTangentWorld: usize = 0x574; // Vector
    pub const m_vOutTangentWorld: usize = 0x580; // Vector
}

pub mod C_CSGO_PreviewModel {
    pub const m_animgraph: usize = 0x1018; // CUtlString
    pub const m_animgraphCharacterModeString: usize = 0x1020; // CUtlString
    pub const m_defaultAnim: usize = 0x1028; // CUtlString
    pub const m_nDefaultAnimLoopMode: usize = 0x1030; // AnimLoopMode_t
    pub const m_flInitialModelScale: usize = 0x1034; // float
}

pub mod C_CSGO_PreviewPlayer {
    pub const m_animgraph: usize = 0x22E8; // CUtlString
    pub const m_animgraphCharacterModeString: usize = 0x22F0; // CUtlString
    pub const m_flInitialModelScale: usize = 0x22F8; // float
}

pub mod C_CSGO_TeamPreviewCamera {
    pub const m_nVariant: usize = 0x5A0; // int32_t
    pub const m_bDofEnabled: usize = 0x5A4; // bool
    pub const m_flDofNearBlurry: usize = 0x5A8; // float
    pub const m_flDofNearCrisp: usize = 0x5AC; // float
    pub const m_flDofFarCrisp: usize = 0x5B0; // float
    pub const m_flDofFarBlurry: usize = 0x5B4; // float
    pub const m_flDofTiltToGround: usize = 0x5B8; // float
}

pub mod C_CSGO_TeamPreviewCharacterPosition {
    pub const m_nVariant: usize = 0x540; // int32_t
    pub const m_nRandom: usize = 0x544; // int32_t
    pub const m_nOrdinal: usize = 0x548; // int32_t
    pub const m_sWeaponName: usize = 0x550; // CUtlString
    pub const m_xuid: usize = 0x558; // uint64_t
    pub const m_agentItem: usize = 0x560; // C_EconItemView
    pub const m_glovesItem: usize = 0x9A8; // C_EconItemView
    pub const m_weaponItem: usize = 0xDF0; // C_EconItemView
}

pub mod C_CSGameRules {
    pub const __m_pChainEntity: usize = 0x8; // CNetworkVarChainer
    pub const m_bFreezePeriod: usize = 0x30; // bool
    pub const m_bWarmupPeriod: usize = 0x31; // bool
    pub const m_fWarmupPeriodEnd: usize = 0x34; // GameTime_t
    pub const m_fWarmupPeriodStart: usize = 0x38; // GameTime_t
    pub const m_nTotalPausedTicks: usize = 0x3C; // int32_t
    pub const m_nPauseStartTick: usize = 0x40; // int32_t
    pub const m_bServerPaused: usize = 0x44; // bool
    pub const m_bGamePaused: usize = 0x45; // bool
    pub const m_bTerroristTimeOutActive: usize = 0x46; // bool
    pub const m_bCTTimeOutActive: usize = 0x47; // bool
    pub const m_flTerroristTimeOutRemaining: usize = 0x48; // float
    pub const m_flCTTimeOutRemaining: usize = 0x4C; // float
    pub const m_nTerroristTimeOuts: usize = 0x50; // int32_t
    pub const m_nCTTimeOuts: usize = 0x54; // int32_t
    pub const m_bTechnicalTimeOut: usize = 0x58; // bool
    pub const m_bMatchWaitingForResume: usize = 0x59; // bool
    pub const m_iRoundTime: usize = 0x5C; // int32_t
    pub const m_fMatchStartTime: usize = 0x60; // float
    pub const m_fRoundStartTime: usize = 0x64; // GameTime_t
    pub const m_flRestartRoundTime: usize = 0x68; // GameTime_t
    pub const m_bGameRestart: usize = 0x6C; // bool
    pub const m_flGameStartTime: usize = 0x70; // float
    pub const m_timeUntilNextPhaseStarts: usize = 0x74; // float
    pub const m_gamePhase: usize = 0x78; // int32_t
    pub const m_totalRoundsPlayed: usize = 0x7C; // int32_t
    pub const m_nRoundsPlayedThisPhase: usize = 0x80; // int32_t
    pub const m_nOvertimePlaying: usize = 0x84; // int32_t
    pub const m_iHostagesRemaining: usize = 0x88; // int32_t
    pub const m_bAnyHostageReached: usize = 0x8C; // bool
    pub const m_bMapHasBombTarget: usize = 0x8D; // bool
    pub const m_bMapHasRescueZone: usize = 0x8E; // bool
    pub const m_bMapHasBuyZone: usize = 0x8F; // bool
    pub const m_bIsQueuedMatchmaking: usize = 0x90; // bool
    pub const m_nQueuedMatchmakingMode: usize = 0x94; // int32_t
    pub const m_bIsValveDS: usize = 0x98; // bool
    pub const m_bLogoMap: usize = 0x99; // bool
    pub const m_bPlayAllStepSoundsOnServer: usize = 0x9A; // bool
    pub const m_iSpectatorSlotCount: usize = 0x9C; // int32_t
    pub const m_MatchDevice: usize = 0xA0; // int32_t
    pub const m_bHasMatchStarted: usize = 0xA4; // bool
    pub const m_nNextMapInMapgroup: usize = 0xA8; // int32_t
    pub const m_szTournamentEventName: usize = 0xAC; // char[512]
    pub const m_szTournamentEventStage: usize = 0x2AC; // char[512]
    pub const m_szMatchStatTxt: usize = 0x4AC; // char[512]
    pub const m_szTournamentPredictionsTxt: usize = 0x6AC; // char[512]
    pub const m_nTournamentPredictionsPct: usize = 0x8AC; // int32_t
    pub const m_flCMMItemDropRevealStartTime: usize = 0x8B0; // GameTime_t
    pub const m_flCMMItemDropRevealEndTime: usize = 0x8B4; // GameTime_t
    pub const m_bIsDroppingItems: usize = 0x8B8; // bool
    pub const m_bIsQuestEligible: usize = 0x8B9; // bool
    pub const m_bIsHltvActive: usize = 0x8BA; // bool
    pub const m_nGuardianModeWaveNumber: usize = 0x8BC; // int32_t
    pub const m_nGuardianModeSpecialKillsRemaining: usize = 0x8C0; // int32_t
    pub const m_nGuardianModeSpecialWeaponNeeded: usize = 0x8C4; // int32_t
    pub const m_nGuardianGrenadesToGiveBots: usize = 0x8C8; // int32_t
    pub const m_nNumHeaviesToSpawn: usize = 0x8CC; // int32_t
    pub const m_numGlobalGiftsGiven: usize = 0x8D0; // uint32_t
    pub const m_numGlobalGifters: usize = 0x8D4; // uint32_t
    pub const m_numGlobalGiftsPeriodSeconds: usize = 0x8D8; // uint32_t
    pub const m_arrFeaturedGiftersAccounts: usize = 0x8DC; // uint32_t[4]
    pub const m_arrFeaturedGiftersGifts: usize = 0x8EC; // uint32_t[4]
    pub const m_arrProhibitedItemIndices: usize = 0x8FC; // uint16_t[100]
    pub const m_arrTournamentActiveCasterAccounts: usize = 0x9C4; // uint32_t[4]
    pub const m_numBestOfMaps: usize = 0x9D4; // int32_t
    pub const m_nHalloweenMaskListSeed: usize = 0x9D8; // int32_t
    pub const m_bBombDropped: usize = 0x9DC; // bool
    pub const m_bBombPlanted: usize = 0x9DD; // bool
    pub const m_iRoundWinStatus: usize = 0x9E0; // int32_t
    pub const m_eRoundWinReason: usize = 0x9E4; // int32_t
    pub const m_bTCantBuy: usize = 0x9E8; // bool
    pub const m_bCTCantBuy: usize = 0x9E9; // bool
    pub const m_flGuardianBuyUntilTime: usize = 0x9EC; // GameTime_t
    pub const m_iMatchStats_RoundResults: usize = 0x9F0; // int32_t[30]
    pub const m_iMatchStats_PlayersAlive_CT: usize = 0xA68; // int32_t[30]
    pub const m_iMatchStats_PlayersAlive_T: usize = 0xAE0; // int32_t[30]
    pub const m_TeamRespawnWaveTimes: usize = 0xB58; // float[32]
    pub const m_flNextRespawnWave: usize = 0xBD8; // GameTime_t[32]
    pub const m_nServerQuestID: usize = 0xC58; // int32_t
    pub const m_vMinimapMins: usize = 0xC5C; // Vector
    pub const m_vMinimapMaxs: usize = 0xC68; // Vector
    pub const m_MinimapVerticalSectionHeights: usize = 0xC74; // float[8]
    pub const m_bDontIncrementCoopWave: usize = 0xC94; // bool
    pub const m_bSpawnedTerrorHuntHeavy: usize = 0xC95; // bool
    pub const m_nEndMatchMapGroupVoteTypes: usize = 0xC98; // int32_t[10]
    pub const m_nEndMatchMapGroupVoteOptions: usize = 0xCC0; // int32_t[10]
    pub const m_nEndMatchMapVoteWinner: usize = 0xCE8; // int32_t
    pub const m_iNumConsecutiveCTLoses: usize = 0xCEC; // int32_t
    pub const m_iNumConsecutiveTerroristLoses: usize = 0xCF0; // int32_t
    pub const m_bMarkClientStopRecordAtRoundEnd: usize = 0xD10; // bool
    pub const m_nMatchAbortedEarlyReason: usize = 0xD68; // int32_t
    pub const m_bHasTriggeredRoundStartMusic: usize = 0xD6C; // bool
    pub const m_bHasTriggeredCoopSpawnReset: usize = 0xD6D; // bool
    pub const m_bSwitchingTeamsAtRoundReset: usize = 0xD6E; // bool
    pub const m_pGameModeRules: usize = 0xD88; // CCSGameModeRules*
    pub const m_RetakeRules: usize = 0xD90; // C_RetakeGameRules
    pub const m_nMatchEndCount: usize = 0xEA8; // uint8_t
    pub const m_nTTeamIntroVariant: usize = 0xEAC; // int32_t
    pub const m_nCTTeamIntroVariant: usize = 0xEB0; // int32_t
    pub const m_bTeamIntroPeriod: usize = 0xEB4; // bool
    pub const m_flLastPerfSampleTime: usize = 0x4EC0; // double
}

pub mod C_CSGameRulesProxy {
    pub const m_pGameRules: usize = 0x540; // C_CSGameRules*
}

pub mod C_CSObserverPawn {
    pub const m_hDetectParentChange: usize = 0x16B0; // CEntityHandle
}

pub mod C_CSPlayerPawn {
    pub const m_pBulletServices: usize = 0x16B0; // CCSPlayer_BulletServices*
    pub const m_pHostageServices: usize = 0x16B8; // CCSPlayer_HostageServices*
    pub const m_pBuyServices: usize = 0x16C0; // CCSPlayer_BuyServices*
    pub const m_pGlowServices: usize = 0x16C8; // CCSPlayer_GlowServices*
    pub const m_pActionTrackingServices: usize = 0x16D0; // CCSPlayer_ActionTrackingServices*
    pub const m_flHealthShotBoostExpirationTime: usize = 0x16D8; // GameTime_t
    pub const m_flLastFiredWeaponTime: usize = 0x16DC; // GameTime_t
    pub const m_bHasFemaleVoice: usize = 0x16E0; // bool
    pub const m_flLandseconds: usize = 0x16E4; // float
    pub const m_flOldFallVelocity: usize = 0x16E8; // float
    pub const m_szLastPlaceName: usize = 0x16EC; // char[18]
    pub const m_bPrevDefuser: usize = 0x16FE; // bool
    pub const m_bPrevHelmet: usize = 0x16FF; // bool
    pub const m_nPrevArmorVal: usize = 0x1700; // int32_t
    pub const m_nPrevGrenadeAmmoCount: usize = 0x1704; // int32_t
    pub const m_unPreviousWeaponHash: usize = 0x1708; // uint32_t
    pub const m_unWeaponHash: usize = 0x170C; // uint32_t
    pub const m_bInBuyZone: usize = 0x1710; // bool
    pub const m_bPreviouslyInBuyZone: usize = 0x1711; // bool
    pub const m_aimPunchAngle: usize = 0x1714; // QAngle
    pub const m_aimPunchAngleVel: usize = 0x1720; // QAngle
    pub const m_aimPunchTickBase: usize = 0x172C; // int32_t
    pub const m_aimPunchTickFraction: usize = 0x1730; // float
    pub const m_aimPunchCache: usize = 0x1738; // CUtlVector<QAngle>
    pub const m_bInLanding: usize = 0x1758; // bool
    pub const m_flLandingTime: usize = 0x175C; // float
    pub const m_bInHostageRescueZone: usize = 0x1760; // bool
    pub const m_bInBombZone: usize = 0x1761; // bool
    pub const m_bIsBuyMenuOpen: usize = 0x1762; // bool
    pub const m_flTimeOfLastInjury: usize = 0x1764; // GameTime_t
    pub const m_flNextSprayDecalTime: usize = 0x1768; // GameTime_t
    pub const m_iRetakesOffering: usize = 0x1880; // int32_t
    pub const m_iRetakesOfferingCard: usize = 0x1884; // int32_t
    pub const m_bRetakesHasDefuseKit: usize = 0x1888; // bool
    pub const m_bRetakesMVPLastRound: usize = 0x1889; // bool
    pub const m_iRetakesMVPBoostItem: usize = 0x188C; // int32_t
    pub const m_RetakesMVPBoostExtraUtility: usize = 0x1890; // loadout_slot_t
    pub const m_bNeedToReApplyGloves: usize = 0x18B0; // bool
    pub const m_EconGloves: usize = 0x18B8; // C_EconItemView
    pub const m_bMustSyncRagdollState: usize = 0x1D00; // bool
    pub const m_nRagdollDamageBone: usize = 0x1D04; // int32_t
    pub const m_vRagdollDamageForce: usize = 0x1D08; // Vector
    pub const m_vRagdollDamagePosition: usize = 0x1D14; // Vector
    pub const m_szRagdollDamageWeaponName: usize = 0x1D20; // char[64]
    pub const m_bRagdollDamageHeadshot: usize = 0x1D60; // bool
    pub const m_vRagdollServerOrigin: usize = 0x1D64; // Vector
    pub const m_bLastHeadBoneTransformIsValid: usize = 0x22B0; // bool
    pub const m_lastLandTime: usize = 0x22B4; // GameTime_t
    pub const m_bOnGroundLastTick: usize = 0x22B8; // bool
    pub const m_qDeathEyeAngles: usize = 0x22D4; // QAngle
    pub const m_bSkipOneHeadConstraintUpdate: usize = 0x22E0; // bool
}

pub mod C_CSPlayerPawnBase {
    pub const m_pPingServices: usize = 0x1268; // CCSPlayer_PingServices*
    pub const m_pViewModelServices: usize = 0x1270; // CPlayer_ViewModelServices*
    pub const m_fRenderingClipPlane: usize = 0x1278; // float[4]
    pub const m_nLastClipPlaneSetupFrame: usize = 0x1288; // int32_t
    pub const m_vecLastClipCameraPos: usize = 0x128C; // Vector
    pub const m_vecLastClipCameraForward: usize = 0x1298; // Vector
    pub const m_bClipHitStaticWorld: usize = 0x12A4; // bool
    pub const m_bCachedPlaneIsValid: usize = 0x12A5; // bool
    pub const m_pClippingWeapon: usize = 0x12A8; // C_CSWeaponBase*
    pub const m_previousPlayerState: usize = 0x12B0; // CSPlayerState
    pub const m_flLastCollisionCeiling: usize = 0x12B4; // float
    pub const m_flLastCollisionCeilingChangeTime: usize = 0x12B8; // float
    pub const m_grenadeParameterStashTime: usize = 0x12D8; // GameTime_t
    pub const m_bGrenadeParametersStashed: usize = 0x12DC; // bool
    pub const m_angStashedShootAngles: usize = 0x12E0; // QAngle
    pub const m_vecStashedGrenadeThrowPosition: usize = 0x12EC; // Vector
    pub const m_vecStashedVelocity: usize = 0x12F8; // Vector
    pub const m_angShootAngleHistory: usize = 0x1304; // QAngle[2]
    pub const m_vecThrowPositionHistory: usize = 0x131C; // Vector[2]
    pub const m_vecVelocityHistory: usize = 0x1334; // Vector[2]
    pub const m_thirdPersonHeading: usize = 0x1350; // QAngle
    pub const m_flSlopeDropOffset: usize = 0x1368; // float
    pub const m_flSlopeDropHeight: usize = 0x1378; // float
    pub const m_vHeadConstraintOffset: usize = 0x1388; // Vector
    pub const m_bIsScoped: usize = 0x13A0; // bool
    pub const m_bIsWalking: usize = 0x13A1; // bool
    pub const m_bResumeZoom: usize = 0x13A2; // bool
    pub const m_iPlayerState: usize = 0x13A4; // CSPlayerState
    pub const m_bIsDefusing: usize = 0x13A8; // bool
    pub const m_bIsGrabbingHostage: usize = 0x13A9; // bool
    pub const m_iBlockingUseActionInProgress: usize = 0x13AC; // CSPlayerBlockingUseAction_t
    pub const m_bIsRescuing: usize = 0x13B0; // bool
    pub const m_fImmuneToGunGameDamageTime: usize = 0x13B4; // GameTime_t
    pub const m_fImmuneToGunGameDamageTimeLast: usize = 0x13B8; // GameTime_t
    pub const m_bGunGameImmunity: usize = 0x13BC; // bool
    pub const m_bHasMovedSinceSpawn: usize = 0x13BD; // bool
    pub const m_fMolotovUseTime: usize = 0x13C0; // float
    pub const m_fMolotovDamageTime: usize = 0x13C4; // float
    pub const m_nWhichBombZone: usize = 0x13C8; // int32_t
    pub const m_bInNoDefuseArea: usize = 0x13CC; // bool
    pub const m_iThrowGrenadeCounter: usize = 0x13D0; // int32_t
    pub const m_bWaitForNoAttack: usize = 0x13D4; // bool
    pub const m_flGuardianTooFarDistFrac: usize = 0x13D8; // float
    pub const m_flDetectedByEnemySensorTime: usize = 0x13DC; // GameTime_t
    pub const m_flNextGuardianTooFarWarning: usize = 0x13E0; // float
    pub const m_bSuppressGuardianTooFarWarningAudio: usize = 0x13E4; // bool
    pub const m_bKilledByTaser: usize = 0x13E5; // bool
    pub const m_iMoveState: usize = 0x13E8; // int32_t
    pub const m_bCanMoveDuringFreezePeriod: usize = 0x13EC; // bool
    pub const m_flLowerBodyYawTarget: usize = 0x13F0; // float
    pub const m_bStrafing: usize = 0x13F4; // bool
    pub const m_flLastSpawnTimeIndex: usize = 0x13F8; // GameTime_t
    pub const m_flEmitSoundTime: usize = 0x13FC; // GameTime_t
    pub const m_iAddonBits: usize = 0x1400; // int32_t
    pub const m_iPrimaryAddon: usize = 0x1404; // int32_t
    pub const m_iSecondaryAddon: usize = 0x1408; // int32_t
    pub const m_iProgressBarDuration: usize = 0x140C; // int32_t
    pub const m_flProgressBarStartTime: usize = 0x1410; // float
    pub const m_iDirection: usize = 0x1414; // int32_t
    pub const m_iShotsFired: usize = 0x1418; // int32_t
    pub const m_bNightVisionOn: usize = 0x141C; // bool
    pub const m_bHasNightVision: usize = 0x141D; // bool
    pub const m_flVelocityModifier: usize = 0x1420; // float
    pub const m_flHitHeading: usize = 0x1424; // float
    pub const m_nHitBodyPart: usize = 0x1428; // int32_t
    pub const m_iStartAccount: usize = 0x142C; // int32_t
    pub const m_vecIntroStartEyePosition: usize = 0x1430; // Vector
    pub const m_vecIntroStartPlayerForward: usize = 0x143C; // Vector
    pub const m_flClientDeathTime: usize = 0x1448; // GameTime_t
    pub const m_flNightVisionAlpha: usize = 0x144C; // float
    pub const m_bScreenTearFrameCaptured: usize = 0x1450; // bool
    pub const m_flFlashBangTime: usize = 0x1454; // float
    pub const m_flFlashScreenshotAlpha: usize = 0x1458; // float
    pub const m_flFlashOverlayAlpha: usize = 0x145C; // float
    pub const m_bFlashBuildUp: usize = 0x1460; // bool
    pub const m_bFlashDspHasBeenCleared: usize = 0x1461; // bool
    pub const m_bFlashScreenshotHasBeenGrabbed: usize = 0x1462; // bool
    pub const m_flFlashMaxAlpha: usize = 0x1464; // float
    pub const m_flFlashDuration: usize = 0x1468; // float
    pub const m_lastStandingPos: usize = 0x146C; // Vector
    pub const m_vecLastMuzzleFlashPos: usize = 0x1478; // Vector
    pub const m_angLastMuzzleFlashAngle: usize = 0x1484; // QAngle
    pub const m_hMuzzleFlashShape: usize = 0x1490; // CHandle<C_BaseEntity>
    pub const m_iHealthBarRenderMaskIndex: usize = 0x1494; // int32_t
    pub const m_flHealthFadeValue: usize = 0x1498; // float
    pub const m_flHealthFadeAlpha: usize = 0x149C; // float
    pub const m_nMyCollisionGroup: usize = 0x14A0; // int32_t
    pub const m_ignoreLadderJumpTime: usize = 0x14A4; // float
    pub const m_ladderSurpressionTimer: usize = 0x14A8; // CountdownTimer
    pub const m_lastLadderNormal: usize = 0x14C0; // Vector
    pub const m_lastLadderPos: usize = 0x14CC; // Vector
    pub const m_flDeathCCWeight: usize = 0x14E0; // float
    pub const m_bOldIsScoped: usize = 0x14E4; // bool
    pub const m_flPrevRoundEndTime: usize = 0x14E8; // float
    pub const m_flPrevMatchEndTime: usize = 0x14EC; // float
    pub const m_unCurrentEquipmentValue: usize = 0x14F0; // uint16_t
    pub const m_unRoundStartEquipmentValue: usize = 0x14F2; // uint16_t
    pub const m_unFreezetimeEndEquipmentValue: usize = 0x14F4; // uint16_t
    pub const m_vecThirdPersonViewPositionOverride: usize = 0x14F8; // Vector
    pub const m_nHeavyAssaultSuitCooldownRemaining: usize = 0x1504; // int32_t
    pub const m_ArmorValue: usize = 0x1508; // int32_t
    pub const m_angEyeAngles: usize = 0x1510; // QAngle
    pub const m_fNextThinkPushAway: usize = 0x1528; // float
    pub const m_bShouldAutobuyDMWeapons: usize = 0x152C; // bool
    pub const m_bShouldAutobuyNow: usize = 0x152D; // bool
    pub const m_bHud_MiniScoreHidden: usize = 0x152E; // bool
    pub const m_bHud_RadarHidden: usize = 0x152F; // bool
    pub const m_nLastKillerIndex: usize = 0x1530; // CEntityIndex
    pub const m_nLastConcurrentKilled: usize = 0x1534; // int32_t
    pub const m_nDeathCamMusic: usize = 0x1538; // int32_t
    pub const m_iIDEntIndex: usize = 0x153C; // CEntityIndex
    pub const m_delayTargetIDTimer: usize = 0x1540; // CountdownTimer
    pub const m_iTargetedWeaponEntIndex: usize = 0x1558; // CEntityIndex
    pub const m_iOldIDEntIndex: usize = 0x155C; // CEntityIndex
    pub const m_holdTargetIDTimer: usize = 0x1560; // CountdownTimer
    pub const m_flCurrentMusicStartTime: usize = 0x157C; // float
    pub const m_flMusicRoundStartTime: usize = 0x1580; // float
    pub const m_bDeferStartMusicOnWarmup: usize = 0x1584; // bool
    pub const m_cycleLatch: usize = 0x1588; // int32_t
    pub const m_serverIntendedCycle: usize = 0x158C; // float
    pub const m_vecPlayerPatchEconIndices: usize = 0x1590; // uint32_t[5]
    pub const m_bHideTargetID: usize = 0x15AC; // bool
    pub const m_nextTaserShakeTime: usize = 0x15B0; // float
    pub const m_firstTaserShakeTime: usize = 0x15B4; // float
    pub const m_flLastSmokeOverlayAlpha: usize = 0x15B8; // float
    pub const m_vLastSmokeOverlayColor: usize = 0x15BC; // Vector
    pub const m_nPlayerSmokedFx: usize = 0x15C8; // ParticleIndex_t
    pub const m_flNextMagDropTime: usize = 0x15CC; // float
    pub const m_nLastMagDropAttachmentIndex: usize = 0x15D0; // int32_t
    pub const m_vecBulletHitModels: usize = 0x15D8; // CUtlVector<C_BulletHitModel*>
    pub const m_vecPickupModelSlerpers: usize = 0x15F0; // CUtlVector<C_PickUpModelSlerper*>
    pub const m_vecLastAliveLocalVelocity: usize = 0x1608; // Vector
    pub const m_entitySpottedState: usize = 0x1630; // EntitySpottedState_t
    pub const m_nSurvivalTeamNumber: usize = 0x1648; // int32_t
    pub const m_bGuardianShouldSprayCustomXMark: usize = 0x164C; // bool
    pub const m_bHasDeathInfo: usize = 0x164D; // bool
    pub const m_flDeathInfoTime: usize = 0x1650; // float
    pub const m_vecDeathInfoOrigin: usize = 0x1654; // Vector
    pub const m_bKilledByHeadshot: usize = 0x1660; // bool
    pub const m_hOriginalController: usize = 0x1664; // CHandle<CCSPlayerController>
}

pub mod C_CSPlayerResource {
    pub const m_bHostageAlive: usize = 0x540; // bool[12]
    pub const m_isHostageFollowingSomeone: usize = 0x54C; // bool[12]
    pub const m_iHostageEntityIDs: usize = 0x558; // CEntityIndex[12]
    pub const m_bombsiteCenterA: usize = 0x588; // Vector
    pub const m_bombsiteCenterB: usize = 0x594; // Vector
    pub const m_hostageRescueX: usize = 0x5A0; // int32_t[4]
    pub const m_hostageRescueY: usize = 0x5B0; // int32_t[4]
    pub const m_hostageRescueZ: usize = 0x5C0; // int32_t[4]
    pub const m_bEndMatchNextMapAllVoted: usize = 0x5D0; // bool
    pub const m_foundGoalPositions: usize = 0x5D1; // bool
}

pub mod C_CSTeam {
    pub const m_szTeamMatchStat: usize = 0x5F8; // char[512]
    pub const m_numMapVictories: usize = 0x7F8; // int32_t
    pub const m_bSurrendered: usize = 0x7FC; // bool
    pub const m_scoreFirstHalf: usize = 0x800; // int32_t
    pub const m_scoreSecondHalf: usize = 0x804; // int32_t
    pub const m_scoreOvertime: usize = 0x808; // int32_t
    pub const m_szClanTeamname: usize = 0x80C; // char[129]
    pub const m_iClanID: usize = 0x890; // uint32_t
    pub const m_szTeamFlagImage: usize = 0x894; // char[8]
    pub const m_szTeamLogoImage: usize = 0x89C; // char[8]
}

pub mod C_CSWeaponBase {
    pub const m_flFireSequenceStartTime: usize = 0x15D4; // float
    pub const m_nFireSequenceStartTimeChange: usize = 0x15D8; // int32_t
    pub const m_nFireSequenceStartTimeAck: usize = 0x15DC; // int32_t
    pub const m_bPlayerFireEventIsPrimary: usize = 0x15E0; // bool
    pub const m_seqIdle: usize = 0x15E4; // HSequence
    pub const m_seqFirePrimary: usize = 0x15E8; // HSequence
    pub const m_seqFireSecondary: usize = 0x15EC; // HSequence
    pub const m_thirdPersonFireSequences: usize = 0x15F0; // CUtlVector<HSequence>
    pub const m_hCurrentThirdPersonSequence: usize = 0x1608; // HSequence
    pub const m_nSilencerBoneIndex: usize = 0x160C; // int32_t
    pub const m_thirdPersonSequences: usize = 0x1610; // HSequence[6]
    pub const m_ClientPreviousWeaponState: usize = 0x1640; // CSWeaponState_t
    pub const m_iState: usize = 0x1644; // CSWeaponState_t
    pub const m_flCrosshairDistance: usize = 0x1648; // float
    pub const m_iAmmoLastCheck: usize = 0x164C; // int32_t
    pub const m_iAlpha: usize = 0x1650; // int32_t
    pub const m_iScopeTextureID: usize = 0x1654; // int32_t
    pub const m_iCrosshairTextureID: usize = 0x1658; // int32_t
    pub const m_flGunAccuracyPosition: usize = 0x165C; // float
    pub const m_nViewModelIndex: usize = 0x1660; // uint32_t
    pub const m_bReloadsWithClips: usize = 0x1664; // bool
    pub const m_flTimeWeaponIdle: usize = 0x1668; // GameTime_t
    pub const m_bFireOnEmpty: usize = 0x166C; // bool
    pub const m_OnPlayerPickup: usize = 0x1670; // CEntityIOOutput
    pub const m_weaponMode: usize = 0x1698; // CSWeaponMode
    pub const m_flTurningInaccuracyDelta: usize = 0x169C; // float
    pub const m_vecTurningInaccuracyEyeDirLast: usize = 0x16A0; // Vector
    pub const m_flTurningInaccuracy: usize = 0x16AC; // float
    pub const m_fAccuracyPenalty: usize = 0x16B0; // float
    pub const m_flLastAccuracyUpdateTime: usize = 0x16B4; // GameTime_t
    pub const m_fAccuracySmoothedForZoom: usize = 0x16B8; // float
    pub const m_fScopeZoomEndTime: usize = 0x16BC; // GameTime_t
    pub const m_iRecoilIndex: usize = 0x16C0; // int32_t
    pub const m_flRecoilIndex: usize = 0x16C4; // float
    pub const m_bBurstMode: usize = 0x16C8; // bool
    pub const m_flPostponeFireReadyTime: usize = 0x16CC; // GameTime_t
    pub const m_bInReload: usize = 0x16D0; // bool
    pub const m_bReloadVisuallyComplete: usize = 0x16D1; // bool
    pub const m_flDroppedAtTime: usize = 0x16D4; // GameTime_t
    pub const m_bIsHauledBack: usize = 0x16D8; // bool
    pub const m_bSilencerOn: usize = 0x16D9; // bool
    pub const m_flTimeSilencerSwitchComplete: usize = 0x16DC; // GameTime_t
    pub const m_iOriginalTeamNumber: usize = 0x16E0; // int32_t
    pub const m_flNextAttackRenderTimeOffset: usize = 0x16E4; // float
    pub const m_bVisualsDataSet: usize = 0x1768; // bool
    pub const m_bOldFirstPersonSpectatedState: usize = 0x1769; // bool
    pub const m_hOurPing: usize = 0x176C; // CHandle<C_BaseEntity>
    pub const m_nOurPingIndex: usize = 0x1770; // CEntityIndex
    pub const m_vecOurPingPos: usize = 0x1774; // Vector
    pub const m_bGlowForPing: usize = 0x1780; // bool
    pub const m_bUIWeapon: usize = 0x1781; // bool
    pub const m_hPrevOwner: usize = 0x1790; // CHandle<C_CSPlayerPawn>
    pub const m_nDropTick: usize = 0x1794; // GameTick_t
    pub const m_donated: usize = 0x17B4; // bool
    pub const m_fLastShotTime: usize = 0x17B8; // GameTime_t
    pub const m_bWasOwnedByCT: usize = 0x17BC; // bool
    pub const m_bWasOwnedByTerrorist: usize = 0x17BD; // bool
    pub const m_gunHeat: usize = 0x17C0; // float
    pub const m_smokeAttachments: usize = 0x17C4; // uint32_t
    pub const m_lastSmokeTime: usize = 0x17C8; // GameTime_t
    pub const m_flNextClientFireBulletTime: usize = 0x17CC; // float
    pub const m_flNextClientFireBulletTime_Repredict: usize = 0x17D0; // float
    pub const m_IronSightController: usize = 0x18B0; // C_IronSightController
    pub const m_iIronSightMode: usize = 0x1960; // int32_t
    pub const m_flLastLOSTraceFailureTime: usize = 0x1970; // GameTime_t
    pub const m_iNumEmptyAttacks: usize = 0x1974; // int32_t
}

pub mod C_CSWeaponBaseGun {
    pub const m_zoomLevel: usize = 0x19F0; // int32_t
    pub const m_iBurstShotsRemaining: usize = 0x19F4; // int32_t
    pub const m_iSilencerBodygroup: usize = 0x19F8; // int32_t
    pub const m_silencedModelIndex: usize = 0x1A08; // int32_t
    pub const m_inPrecache: usize = 0x1A0C; // bool
    pub const m_bNeedsBoltAction: usize = 0x1A0D; // bool
}

pub mod C_Chicken {
    pub const m_hHolidayHatAddon: usize = 0x10F0; // CHandle<CBaseAnimGraph>
    pub const m_jumpedThisFrame: usize = 0x10F4; // bool
    pub const m_leader: usize = 0x10F8; // CHandle<C_CSPlayerPawnBase>
    pub const m_AttributeManager: usize = 0x1100; // C_AttributeContainer
    pub const m_OriginalOwnerXuidLow: usize = 0x15A8; // uint32_t
    pub const m_OriginalOwnerXuidHigh: usize = 0x15AC; // uint32_t
    pub const m_bAttributesInitialized: usize = 0x15B0; // bool
    pub const m_hWaterWakeParticles: usize = 0x15B4; // ParticleIndex_t
}

pub mod C_ClientRagdoll {
    pub const m_bFadeOut: usize = 0xE80; // bool
    pub const m_bImportant: usize = 0xE81; // bool
    pub const m_flEffectTime: usize = 0xE84; // GameTime_t
    pub const m_gibDespawnTime: usize = 0xE88; // GameTime_t
    pub const m_iCurrentFriction: usize = 0xE8C; // int32_t
    pub const m_iMinFriction: usize = 0xE90; // int32_t
    pub const m_iMaxFriction: usize = 0xE94; // int32_t
    pub const m_iFrictionAnimState: usize = 0xE98; // int32_t
    pub const m_bReleaseRagdoll: usize = 0xE9C; // bool
    pub const m_iEyeAttachment: usize = 0xE9D; // AttachmentHandle_t
    pub const m_bFadingOut: usize = 0xE9E; // bool
    pub const m_flScaleEnd: usize = 0xEA0; // float[10]
    pub const m_flScaleTimeStart: usize = 0xEC8; // GameTime_t[10]
    pub const m_flScaleTimeEnd: usize = 0xEF0; // GameTime_t[10]
}

pub mod C_ColorCorrection {
    pub const m_vecOrigin: usize = 0x540; // Vector
    pub const m_MinFalloff: usize = 0x54C; // float
    pub const m_MaxFalloff: usize = 0x550; // float
    pub const m_flFadeInDuration: usize = 0x554; // float
    pub const m_flFadeOutDuration: usize = 0x558; // float
    pub const m_flMaxWeight: usize = 0x55C; // float
    pub const m_flCurWeight: usize = 0x560; // float
    pub const m_netlookupFilename: usize = 0x564; // char[512]
    pub const m_bEnabled: usize = 0x764; // bool
    pub const m_bMaster: usize = 0x765; // bool
    pub const m_bClientSide: usize = 0x766; // bool
    pub const m_bExclusive: usize = 0x767; // bool
    pub const m_bEnabledOnClient: usize = 0x768; // bool[1]
    pub const m_flCurWeightOnClient: usize = 0x76C; // float[1]
    pub const m_bFadingIn: usize = 0x770; // bool[1]
    pub const m_flFadeStartWeight: usize = 0x774; // float[1]
    pub const m_flFadeStartTime: usize = 0x778; // float[1]
    pub const m_flFadeDuration: usize = 0x77C; // float[1]
}

pub mod C_ColorCorrectionVolume {
    pub const m_LastEnterWeight: usize = 0xCC8; // float
    pub const m_LastEnterTime: usize = 0xCCC; // float
    pub const m_LastExitWeight: usize = 0xCD0; // float
    pub const m_LastExitTime: usize = 0xCD4; // float
    pub const m_bEnabled: usize = 0xCD8; // bool
    pub const m_MaxWeight: usize = 0xCDC; // float
    pub const m_FadeDuration: usize = 0xCE0; // float
    pub const m_Weight: usize = 0xCE4; // float
    pub const m_lookupFilename: usize = 0xCE8; // char[512]
}

pub mod C_CommandContext {
    pub const needsprocessing: usize = 0x0; // bool
    pub const command_number: usize = 0xA8; // int32_t
}

pub mod C_CsmFovOverride {
    pub const m_cameraName: usize = 0x540; // CUtlString
    pub const m_flCsmFovOverrideValue: usize = 0x548; // float
}

pub mod C_DecoyProjectile {
    pub const m_nDecoyShotTick: usize = 0x1100; // int32_t
    pub const m_nClientLastKnownDecoyShotTick: usize = 0x1104; // int32_t
    pub const m_flTimeParticleEffectSpawn: usize = 0x1128; // GameTime_t
}

pub mod C_DynamicLight {
    pub const m_Flags: usize = 0xCC0; // uint8_t
    pub const m_LightStyle: usize = 0xCC1; // uint8_t
    pub const m_Radius: usize = 0xCC4; // float
    pub const m_Exponent: usize = 0xCC8; // int32_t
    pub const m_InnerAngle: usize = 0xCCC; // float
    pub const m_OuterAngle: usize = 0xCD0; // float
    pub const m_SpotRadius: usize = 0xCD4; // float
}

pub mod C_DynamicProp {
    pub const m_bUseHitboxesForRenderBox: usize = 0xFD0; // bool
    pub const m_bUseAnimGraph: usize = 0xFD1; // bool
    pub const m_pOutputAnimBegun: usize = 0xFD8; // CEntityIOOutput
    pub const m_pOutputAnimOver: usize = 0x1000; // CEntityIOOutput
    pub const m_pOutputAnimLoopCycleOver: usize = 0x1028; // CEntityIOOutput
    pub const m_OnAnimReachedStart: usize = 0x1050; // CEntityIOOutput
    pub const m_OnAnimReachedEnd: usize = 0x1078; // CEntityIOOutput
    pub const m_iszDefaultAnim: usize = 0x10A0; // CUtlSymbolLarge
    pub const m_nDefaultAnimLoopMode: usize = 0x10A8; // AnimLoopMode_t
    pub const m_bAnimateOnServer: usize = 0x10AC; // bool
    pub const m_bRandomizeCycle: usize = 0x10AD; // bool
    pub const m_bStartDisabled: usize = 0x10AE; // bool
    pub const m_bScriptedMovement: usize = 0x10AF; // bool
    pub const m_bFiredStartEndOutput: usize = 0x10B0; // bool
    pub const m_bForceNpcExclude: usize = 0x10B1; // bool
    pub const m_bCreateNonSolid: usize = 0x10B2; // bool
    pub const m_bIsOverrideProp: usize = 0x10B3; // bool
    pub const m_iInitialGlowState: usize = 0x10B4; // int32_t
    pub const m_nGlowRange: usize = 0x10B8; // int32_t
    pub const m_nGlowRangeMin: usize = 0x10BC; // int32_t
    pub const m_glowColor: usize = 0x10C0; // Color
    pub const m_nGlowTeam: usize = 0x10C4; // int32_t
    pub const m_iCachedFrameCount: usize = 0x10C8; // int32_t
    pub const m_vecCachedRenderMins: usize = 0x10CC; // Vector
    pub const m_vecCachedRenderMaxs: usize = 0x10D8; // Vector
}

pub mod C_EconEntity {
    pub const m_flFlexDelayTime: usize = 0x1028; // float
    pub const m_flFlexDelayedWeight: usize = 0x1030; // float*
    pub const m_bAttributesInitialized: usize = 0x1038; // bool
    pub const m_AttributeManager: usize = 0x1040; // C_AttributeContainer
    pub const m_OriginalOwnerXuidLow: usize = 0x14E8; // uint32_t
    pub const m_OriginalOwnerXuidHigh: usize = 0x14EC; // uint32_t
    pub const m_nFallbackPaintKit: usize = 0x14F0; // int32_t
    pub const m_nFallbackSeed: usize = 0x14F4; // int32_t
    pub const m_flFallbackWear: usize = 0x14F8; // float
    pub const m_nFallbackStatTrak: usize = 0x14FC; // int32_t
    pub const m_bClientside: usize = 0x1500; // bool
    pub const m_bParticleSystemsCreated: usize = 0x1501; // bool
    pub const m_vecAttachedParticles: usize = 0x1508; // CUtlVector<int32_t>
    pub const m_hViewmodelAttachment: usize = 0x1520; // CHandle<CBaseAnimGraph>
    pub const m_iOldTeam: usize = 0x1524; // int32_t
    pub const m_bAttachmentDirty: usize = 0x1528; // bool
    pub const m_nUnloadedModelIndex: usize = 0x152C; // int32_t
    pub const m_iNumOwnerValidationRetries: usize = 0x1530; // int32_t
    pub const m_hOldProvidee: usize = 0x1540; // CHandle<C_BaseEntity>
    pub const m_vecAttachedModels: usize = 0x1548; // CUtlVector<C_EconEntity::AttachedModelData_t>
}

pub mod C_EconEntity_AttachedModelData_t {
    pub const m_iModelDisplayFlags: usize = 0x0; // int32_t
}

pub mod C_EconItemView {
    pub const m_bInventoryImageRgbaRequested: usize = 0x60; // bool
    pub const m_bInventoryImageTriedCache: usize = 0x61; // bool
    pub const m_nInventoryImageRgbaWidth: usize = 0x80; // int32_t
    pub const m_nInventoryImageRgbaHeight: usize = 0x84; // int32_t
    pub const m_szCurrentLoadCachedFileName: usize = 0x88; // char[260]
    pub const m_bRestoreCustomMaterialAfterPrecache: usize = 0x1B8; // bool
    pub const m_iItemDefinitionIndex: usize = 0x1BA; // uint16_t
    pub const m_iEntityQuality: usize = 0x1BC; // int32_t
    pub const m_iEntityLevel: usize = 0x1C0; // uint32_t
    pub const m_iItemID: usize = 0x1C8; // uint64_t
    pub const m_iItemIDHigh: usize = 0x1D0; // uint32_t
    pub const m_iItemIDLow: usize = 0x1D4; // uint32_t
    pub const m_iAccountID: usize = 0x1D8; // uint32_t
    pub const m_iInventoryPosition: usize = 0x1DC; // uint32_t
    pub const m_bInitialized: usize = 0x1E8; // bool
    pub const m_bIsStoreItem: usize = 0x1E9; // bool
    pub const m_bIsTradeItem: usize = 0x1EA; // bool
    pub const m_iEntityQuantity: usize = 0x1EC; // int32_t
    pub const m_iRarityOverride: usize = 0x1F0; // int32_t
    pub const m_iQualityOverride: usize = 0x1F4; // int32_t
    pub const m_unClientFlags: usize = 0x1F8; // uint8_t
    pub const m_unOverrideStyle: usize = 0x1F9; // uint8_t
    pub const m_AttributeList: usize = 0x210; // CAttributeList
    pub const m_NetworkedDynamicAttributes: usize = 0x270; // CAttributeList
    pub const m_szCustomName: usize = 0x2D0; // char[161]
    pub const m_szCustomNameOverride: usize = 0x371; // char[161]
    pub const m_bInitializedTags: usize = 0x440; // bool
}

pub mod C_EconWearable {
    pub const m_nForceSkin: usize = 0x1560; // int32_t
    pub const m_bAlwaysAllow: usize = 0x1564; // bool
}

pub mod C_EntityDissolve {
    pub const m_flStartTime: usize = 0xCC8; // GameTime_t
    pub const m_flFadeInStart: usize = 0xCCC; // float
    pub const m_flFadeInLength: usize = 0xCD0; // float
    pub const m_flFadeOutModelStart: usize = 0xCD4; // float
    pub const m_flFadeOutModelLength: usize = 0xCD8; // float
    pub const m_flFadeOutStart: usize = 0xCDC; // float
    pub const m_flFadeOutLength: usize = 0xCE0; // float
    pub const m_flNextSparkTime: usize = 0xCE4; // GameTime_t
    pub const m_nDissolveType: usize = 0xCE8; // EntityDisolveType_t
    pub const m_vDissolverOrigin: usize = 0xCEC; // Vector
    pub const m_nMagnitude: usize = 0xCF8; // uint32_t
    pub const m_bCoreExplode: usize = 0xCFC; // bool
    pub const m_bLinkedToServerEnt: usize = 0xCFD; // bool
}

pub mod C_EntityFlame {
    pub const m_hEntAttached: usize = 0x540; // CHandle<C_BaseEntity>
    pub const m_hOldAttached: usize = 0x568; // CHandle<C_BaseEntity>
    pub const m_bCheapEffect: usize = 0x56C; // bool
}

pub mod C_EnvCombinedLightProbeVolume {
    pub const m_Color: usize = 0x1598; // Color
    pub const m_flBrightness: usize = 0x159C; // float
    pub const m_hCubemapTexture: usize = 0x15A0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_bCustomCubemapTexture: usize = 0x15A8; // bool
    pub const m_hLightProbeTexture: usize = 0x15B0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_hLightProbeDirectLightIndicesTexture: usize = 0x15B8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_hLightProbeDirectLightScalarsTexture: usize = 0x15C0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_hLightProbeDirectLightShadowsTexture: usize = 0x15C8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_vBoxMins: usize = 0x15D0; // Vector
    pub const m_vBoxMaxs: usize = 0x15DC; // Vector
    pub const m_bMoveable: usize = 0x15E8; // bool
    pub const m_nHandshake: usize = 0x15EC; // int32_t
    pub const m_nEnvCubeMapArrayIndex: usize = 0x15F0; // int32_t
    pub const m_nPriority: usize = 0x15F4; // int32_t
    pub const m_bStartDisabled: usize = 0x15F8; // bool
    pub const m_flEdgeFadeDist: usize = 0x15FC; // float
    pub const m_vEdgeFadeDists: usize = 0x1600; // Vector
    pub const m_nLightProbeSizeX: usize = 0x160C; // int32_t
    pub const m_nLightProbeSizeY: usize = 0x1610; // int32_t
    pub const m_nLightProbeSizeZ: usize = 0x1614; // int32_t
    pub const m_nLightProbeAtlasX: usize = 0x1618; // int32_t
    pub const m_nLightProbeAtlasY: usize = 0x161C; // int32_t
    pub const m_nLightProbeAtlasZ: usize = 0x1620; // int32_t
    pub const m_bEnabled: usize = 0x1639; // bool
}

pub mod C_EnvCubemap {
    pub const m_hCubemapTexture: usize = 0x5C0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_bCustomCubemapTexture: usize = 0x5C8; // bool
    pub const m_flInfluenceRadius: usize = 0x5CC; // float
    pub const m_vBoxProjectMins: usize = 0x5D0; // Vector
    pub const m_vBoxProjectMaxs: usize = 0x5DC; // Vector
    pub const m_bMoveable: usize = 0x5E8; // bool
    pub const m_nHandshake: usize = 0x5EC; // int32_t
    pub const m_nEnvCubeMapArrayIndex: usize = 0x5F0; // int32_t
    pub const m_nPriority: usize = 0x5F4; // int32_t
    pub const m_flEdgeFadeDist: usize = 0x5F8; // float
    pub const m_vEdgeFadeDists: usize = 0x5FC; // Vector
    pub const m_flDiffuseScale: usize = 0x608; // float
    pub const m_bStartDisabled: usize = 0x60C; // bool
    pub const m_bDefaultEnvMap: usize = 0x60D; // bool
    pub const m_bDefaultSpecEnvMap: usize = 0x60E; // bool
    pub const m_bIndoorCubeMap: usize = 0x60F; // bool
    pub const m_bCopyDiffuseFromDefaultCubemap: usize = 0x610; // bool
    pub const m_bEnabled: usize = 0x620; // bool
}

pub mod C_EnvCubemapFog {
    pub const m_flEndDistance: usize = 0x540; // float
    pub const m_flStartDistance: usize = 0x544; // float
    pub const m_flFogFalloffExponent: usize = 0x548; // float
    pub const m_bHeightFogEnabled: usize = 0x54C; // bool
    pub const m_flFogHeightWidth: usize = 0x550; // float
    pub const m_flFogHeightEnd: usize = 0x554; // float
    pub const m_flFogHeightStart: usize = 0x558; // float
    pub const m_flFogHeightExponent: usize = 0x55C; // float
    pub const m_flLODBias: usize = 0x560; // float
    pub const m_bActive: usize = 0x564; // bool
    pub const m_bStartDisabled: usize = 0x565; // bool
    pub const m_flFogMaxOpacity: usize = 0x568; // float
    pub const m_nCubemapSourceType: usize = 0x56C; // int32_t
    pub const m_hSkyMaterial: usize = 0x570; // CStrongHandle<InfoForResourceTypeIMaterial2>
    pub const m_iszSkyEntity: usize = 0x578; // CUtlSymbolLarge
    pub const m_hFogCubemapTexture: usize = 0x580; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_bHasHeightFogEnd: usize = 0x588; // bool
    pub const m_bFirstTime: usize = 0x589; // bool
}

pub mod C_EnvDecal {
    pub const m_hDecalMaterial: usize = 0xCC0; // CStrongHandle<InfoForResourceTypeIMaterial2>
    pub const m_flWidth: usize = 0xCC8; // float
    pub const m_flHeight: usize = 0xCCC; // float
    pub const m_flDepth: usize = 0xCD0; // float
    pub const m_nRenderOrder: usize = 0xCD4; // uint32_t
    pub const m_bProjectOnWorld: usize = 0xCD8; // bool
    pub const m_bProjectOnCharacters: usize = 0xCD9; // bool
    pub const m_bProjectOnWater: usize = 0xCDA; // bool
    pub const m_flDepthSortBias: usize = 0xCDC; // float
}

pub mod C_EnvDetailController {
    pub const m_flFadeStartDist: usize = 0x540; // float
    pub const m_flFadeEndDist: usize = 0x544; // float
}

pub mod C_EnvLightProbeVolume {
    pub const m_hLightProbeTexture: usize = 0x1518; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_hLightProbeDirectLightIndicesTexture: usize = 0x1520; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_hLightProbeDirectLightScalarsTexture: usize = 0x1528; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_hLightProbeDirectLightShadowsTexture: usize = 0x1530; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_vBoxMins: usize = 0x1538; // Vector
    pub const m_vBoxMaxs: usize = 0x1544; // Vector
    pub const m_bMoveable: usize = 0x1550; // bool
    pub const m_nHandshake: usize = 0x1554; // int32_t
    pub const m_nPriority: usize = 0x1558; // int32_t
    pub const m_bStartDisabled: usize = 0x155C; // bool
    pub const m_nLightProbeSizeX: usize = 0x1560; // int32_t
    pub const m_nLightProbeSizeY: usize = 0x1564; // int32_t
    pub const m_nLightProbeSizeZ: usize = 0x1568; // int32_t
    pub const m_nLightProbeAtlasX: usize = 0x156C; // int32_t
    pub const m_nLightProbeAtlasY: usize = 0x1570; // int32_t
    pub const m_nLightProbeAtlasZ: usize = 0x1574; // int32_t
    pub const m_bEnabled: usize = 0x1581; // bool
}

pub mod C_EnvParticleGlow {
    pub const m_flAlphaScale: usize = 0x1270; // float
    pub const m_flRadiusScale: usize = 0x1274; // float
    pub const m_flSelfIllumScale: usize = 0x1278; // float
    pub const m_ColorTint: usize = 0x127C; // Color
    pub const m_hTextureOverride: usize = 0x1280; // CStrongHandle<InfoForResourceTypeCTextureBase>
}

pub mod C_EnvScreenOverlay {
    pub const m_iszOverlayNames: usize = 0x540; // CUtlSymbolLarge[10]
    pub const m_flOverlayTimes: usize = 0x590; // float[10]
    pub const m_flStartTime: usize = 0x5B8; // GameTime_t
    pub const m_iDesiredOverlay: usize = 0x5BC; // int32_t
    pub const m_bIsActive: usize = 0x5C0; // bool
    pub const m_bWasActive: usize = 0x5C1; // bool
    pub const m_iCachedDesiredOverlay: usize = 0x5C4; // int32_t
    pub const m_iCurrentOverlay: usize = 0x5C8; // int32_t
    pub const m_flCurrentOverlayTime: usize = 0x5CC; // GameTime_t
}

pub mod C_EnvSky {
    pub const m_hSkyMaterial: usize = 0xCC0; // CStrongHandle<InfoForResourceTypeIMaterial2>
    pub const m_hSkyMaterialLightingOnly: usize = 0xCC8; // CStrongHandle<InfoForResourceTypeIMaterial2>
    pub const m_bStartDisabled: usize = 0xCD0; // bool
    pub const m_vTintColor: usize = 0xCD1; // Color
    pub const m_vTintColorLightingOnly: usize = 0xCD5; // Color
    pub const m_flBrightnessScale: usize = 0xCDC; // float
    pub const m_nFogType: usize = 0xCE0; // int32_t
    pub const m_flFogMinStart: usize = 0xCE4; // float
    pub const m_flFogMinEnd: usize = 0xCE8; // float
    pub const m_flFogMaxStart: usize = 0xCEC; // float
    pub const m_flFogMaxEnd: usize = 0xCF0; // float
    pub const m_bEnabled: usize = 0xCF4; // bool
}

pub mod C_EnvVolumetricFogController {
    pub const m_flScattering: usize = 0x540; // float
    pub const m_flAnisotropy: usize = 0x544; // float
    pub const m_flFadeSpeed: usize = 0x548; // float
    pub const m_flDrawDistance: usize = 0x54C; // float
    pub const m_flFadeInStart: usize = 0x550; // float
    pub const m_flFadeInEnd: usize = 0x554; // float
    pub const m_flIndirectStrength: usize = 0x558; // float
    pub const m_nIndirectTextureDimX: usize = 0x55C; // int32_t
    pub const m_nIndirectTextureDimY: usize = 0x560; // int32_t
    pub const m_nIndirectTextureDimZ: usize = 0x564; // int32_t
    pub const m_vBoxMins: usize = 0x568; // Vector
    pub const m_vBoxMaxs: usize = 0x574; // Vector
    pub const m_bActive: usize = 0x580; // bool
    pub const m_flStartAnisoTime: usize = 0x584; // GameTime_t
    pub const m_flStartScatterTime: usize = 0x588; // GameTime_t
    pub const m_flStartDrawDistanceTime: usize = 0x58C; // GameTime_t
    pub const m_flStartAnisotropy: usize = 0x590; // float
    pub const m_flStartScattering: usize = 0x594; // float
    pub const m_flStartDrawDistance: usize = 0x598; // float
    pub const m_flDefaultAnisotropy: usize = 0x59C; // float
    pub const m_flDefaultScattering: usize = 0x5A0; // float
    pub const m_flDefaultDrawDistance: usize = 0x5A4; // float
    pub const m_bStartDisabled: usize = 0x5A8; // bool
    pub const m_bEnableIndirect: usize = 0x5A9; // bool
    pub const m_bIsMaster: usize = 0x5AA; // bool
    pub const m_hFogIndirectTexture: usize = 0x5B0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_nForceRefreshCount: usize = 0x5B8; // int32_t
    pub const m_bFirstTime: usize = 0x5BC; // bool
}

pub mod C_EnvVolumetricFogVolume {
    pub const m_bActive: usize = 0x540; // bool
    pub const m_vBoxMins: usize = 0x544; // Vector
    pub const m_vBoxMaxs: usize = 0x550; // Vector
    pub const m_bStartDisabled: usize = 0x55C; // bool
    pub const m_flStrength: usize = 0x560; // float
    pub const m_nFalloffShape: usize = 0x564; // int32_t
    pub const m_flFalloffExponent: usize = 0x568; // float
}

pub mod C_EnvWind {
    pub const m_EnvWindShared: usize = 0x540; // C_EnvWindShared
}

pub mod C_EnvWindClientside {
    pub const m_EnvWindShared: usize = 0x540; // C_EnvWindShared
}

pub mod C_EnvWindShared {
    pub const m_flStartTime: usize = 0x8; // GameTime_t
    pub const m_iWindSeed: usize = 0xC; // uint32_t
    pub const m_iMinWind: usize = 0x10; // uint16_t
    pub const m_iMaxWind: usize = 0x12; // uint16_t
    pub const m_windRadius: usize = 0x14; // int32_t
    pub const m_iMinGust: usize = 0x18; // uint16_t
    pub const m_iMaxGust: usize = 0x1A; // uint16_t
    pub const m_flMinGustDelay: usize = 0x1C; // float
    pub const m_flMaxGustDelay: usize = 0x20; // float
    pub const m_flGustDuration: usize = 0x24; // float
    pub const m_iGustDirChange: usize = 0x28; // uint16_t
    pub const m_location: usize = 0x2C; // Vector
    pub const m_iszGustSound: usize = 0x38; // int32_t
    pub const m_iWindDir: usize = 0x3C; // int32_t
    pub const m_flWindSpeed: usize = 0x40; // float
    pub const m_currentWindVector: usize = 0x44; // Vector
    pub const m_CurrentSwayVector: usize = 0x50; // Vector
    pub const m_PrevSwayVector: usize = 0x5C; // Vector
    pub const m_iInitialWindDir: usize = 0x68; // uint16_t
    pub const m_flInitialWindSpeed: usize = 0x6C; // float
    pub const m_flVariationTime: usize = 0x70; // GameTime_t
    pub const m_flSwayTime: usize = 0x74; // GameTime_t
    pub const m_flSimTime: usize = 0x78; // GameTime_t
    pub const m_flSwitchTime: usize = 0x7C; // GameTime_t
    pub const m_flAveWindSpeed: usize = 0x80; // float
    pub const m_bGusting: usize = 0x84; // bool
    pub const m_flWindAngleVariation: usize = 0x88; // float
    pub const m_flWindSpeedVariation: usize = 0x8C; // float
    pub const m_iEntIndex: usize = 0x90; // CEntityIndex
}

pub mod C_EnvWindShared_WindAveEvent_t {
    pub const m_flStartWindSpeed: usize = 0x0; // float
    pub const m_flAveWindSpeed: usize = 0x4; // float
}

pub mod C_EnvWindShared_WindVariationEvent_t {
    pub const m_flWindAngleVariation: usize = 0x0; // float
    pub const m_flWindSpeedVariation: usize = 0x4; // float
}

pub mod C_FireSmoke {
    pub const m_nFlameModelIndex: usize = 0x550; // int32_t
    pub const m_nFlameFromAboveModelIndex: usize = 0x554; // int32_t
    pub const m_flScaleRegister: usize = 0x558; // float
    pub const m_flScaleStart: usize = 0x55C; // float
    pub const m_flScaleEnd: usize = 0x560; // float
    pub const m_flScaleTimeStart: usize = 0x564; // GameTime_t
    pub const m_flScaleTimeEnd: usize = 0x568; // GameTime_t
    pub const m_flChildFlameSpread: usize = 0x56C; // float
    pub const m_flClipPerc: usize = 0x580; // float
    pub const m_bClipTested: usize = 0x584; // bool
    pub const m_bFadingOut: usize = 0x585; // bool
    pub const m_tParticleSpawn: usize = 0x588; // TimedEvent
    pub const m_pFireOverlay: usize = 0x590; // CFireOverlay*
}

pub mod C_FireSprite {
    pub const m_vecMoveDir: usize = 0xDF0; // Vector
    pub const m_bFadeFromAbove: usize = 0xDFC; // bool
}

pub mod C_Fish {
    pub const m_pos: usize = 0xE80; // Vector
    pub const m_vel: usize = 0xE8C; // Vector
    pub const m_angles: usize = 0xE98; // QAngle
    pub const m_localLifeState: usize = 0xEA4; // int32_t
    pub const m_deathDepth: usize = 0xEA8; // float
    pub const m_deathAngle: usize = 0xEAC; // float
    pub const m_buoyancy: usize = 0xEB0; // float
    pub const m_wiggleTimer: usize = 0xEB8; // CountdownTimer
    pub const m_wigglePhase: usize = 0xED0; // float
    pub const m_wiggleRate: usize = 0xED4; // float
    pub const m_actualPos: usize = 0xED8; // Vector
    pub const m_actualAngles: usize = 0xEE4; // QAngle
    pub const m_poolOrigin: usize = 0xEF0; // Vector
    pub const m_waterLevel: usize = 0xEFC; // float
    pub const m_gotUpdate: usize = 0xF00; // bool
    pub const m_x: usize = 0xF04; // float
    pub const m_y: usize = 0xF08; // float
    pub const m_z: usize = 0xF0C; // float
    pub const m_angle: usize = 0xF10; // float
    pub const m_errorHistory: usize = 0xF14; // float[20]
    pub const m_errorHistoryIndex: usize = 0xF64; // int32_t
    pub const m_errorHistoryCount: usize = 0xF68; // int32_t
    pub const m_averageError: usize = 0xF6C; // float
}

pub mod C_Fists {
    pub const m_bPlayingUninterruptableAct: usize = 0x19F0; // bool
    pub const m_nUninterruptableActivity: usize = 0x19F4; // PlayerAnimEvent_t
}

pub mod C_FogController {
    pub const m_fog: usize = 0x540; // fogparams_t
    pub const m_bUseAngles: usize = 0x5A8; // bool
    pub const m_iChangedVariables: usize = 0x5AC; // int32_t
}

pub mod C_FootstepControl {
    pub const m_source: usize = 0xCC8; // CUtlSymbolLarge
    pub const m_destination: usize = 0xCD0; // CUtlSymbolLarge
}

pub mod C_FuncConveyor {
    pub const m_vecMoveDirEntitySpace: usize = 0xCC8; // Vector
    pub const m_flTargetSpeed: usize = 0xCD4; // float
    pub const m_nTransitionStartTick: usize = 0xCD8; // GameTick_t
    pub const m_nTransitionDurationTicks: usize = 0xCDC; // int32_t
    pub const m_flTransitionStartSpeed: usize = 0xCE0; // float
    pub const m_hConveyorModels: usize = 0xCE8; // C_NetworkUtlVectorBase<CHandle<C_BaseEntity>>
    pub const m_flCurrentConveyorOffset: usize = 0xD00; // float
    pub const m_flCurrentConveyorSpeed: usize = 0xD04; // float
}

pub mod C_FuncElectrifiedVolume {
    pub const m_nAmbientEffect: usize = 0xCC0; // ParticleIndex_t
    pub const m_EffectName: usize = 0xCC8; // CUtlSymbolLarge
    pub const m_bState: usize = 0xCD0; // bool
}

pub mod C_FuncLadder {
    pub const m_vecLadderDir: usize = 0xCC0; // Vector
    pub const m_Dismounts: usize = 0xCD0; // CUtlVector<CHandle<C_InfoLadderDismount>>
    pub const m_vecLocalTop: usize = 0xCE8; // Vector
    pub const m_vecPlayerMountPositionTop: usize = 0xCF4; // Vector
    pub const m_vecPlayerMountPositionBottom: usize = 0xD00; // Vector
    pub const m_flAutoRideSpeed: usize = 0xD0C; // float
    pub const m_bDisabled: usize = 0xD10; // bool
    pub const m_bFakeLadder: usize = 0xD11; // bool
    pub const m_bHasSlack: usize = 0xD12; // bool
}

pub mod C_FuncMonitor {
    pub const m_targetCamera: usize = 0xCC0; // CUtlString
    pub const m_nResolutionEnum: usize = 0xCC8; // int32_t
    pub const m_bRenderShadows: usize = 0xCCC; // bool
    pub const m_bUseUniqueColorTarget: usize = 0xCCD; // bool
    pub const m_brushModelName: usize = 0xCD0; // CUtlString
    pub const m_hTargetCamera: usize = 0xCD8; // CHandle<C_BaseEntity>
    pub const m_bEnabled: usize = 0xCDC; // bool
    pub const m_bDraw3DSkybox: usize = 0xCDD; // bool
}

pub mod C_FuncTrackTrain {
    pub const m_nLongAxis: usize = 0xCC0; // int32_t
    pub const m_flRadius: usize = 0xCC4; // float
    pub const m_flLineLength: usize = 0xCC8; // float
}

pub mod C_GlobalLight {
    pub const m_WindClothForceHandle: usize = 0xA00; // uint16_t
}

pub mod C_GradientFog {
    pub const m_hGradientFogTexture: usize = 0x540; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_flFogStartDistance: usize = 0x548; // float
    pub const m_flFogEndDistance: usize = 0x54C; // float
    pub const m_bHeightFogEnabled: usize = 0x550; // bool
    pub const m_flFogStartHeight: usize = 0x554; // float
    pub const m_flFogEndHeight: usize = 0x558; // float
    pub const m_flFarZ: usize = 0x55C; // float
    pub const m_flFogMaxOpacity: usize = 0x560; // float
    pub const m_flFogFalloffExponent: usize = 0x564; // float
    pub const m_flFogVerticalExponent: usize = 0x568; // float
    pub const m_fogColor: usize = 0x56C; // Color
    pub const m_flFogStrength: usize = 0x570; // float
    pub const m_flFadeTime: usize = 0x574; // float
    pub const m_bStartDisabled: usize = 0x578; // bool
    pub const m_bIsEnabled: usize = 0x579; // bool
    pub const m_bGradientFogNeedsTextures: usize = 0x57A; // bool
}

pub mod C_HandleTest {
    pub const m_Handle: usize = 0x540; // CHandle<C_BaseEntity>
    pub const m_bSendHandle: usize = 0x544; // bool
}

pub mod C_Hostage {
    pub const m_entitySpottedState: usize = 0x10A8; // EntitySpottedState_t
    pub const m_leader: usize = 0x10C0; // CHandle<C_BaseEntity>
    pub const m_reuseTimer: usize = 0x10C8; // CountdownTimer
    pub const m_vel: usize = 0x10E0; // Vector
    pub const m_isRescued: usize = 0x10EC; // bool
    pub const m_jumpedThisFrame: usize = 0x10ED; // bool
    pub const m_nHostageState: usize = 0x10F0; // int32_t
    pub const m_bHandsHaveBeenCut: usize = 0x10F4; // bool
    pub const m_hHostageGrabber: usize = 0x10F8; // CHandle<C_CSPlayerPawn>
    pub const m_fLastGrabTime: usize = 0x10FC; // GameTime_t
    pub const m_vecGrabbedPos: usize = 0x1100; // Vector
    pub const m_flRescueStartTime: usize = 0x110C; // GameTime_t
    pub const m_flGrabSuccessTime: usize = 0x1110; // GameTime_t
    pub const m_flDropStartTime: usize = 0x1114; // GameTime_t
    pub const m_flDeadOrRescuedTime: usize = 0x1118; // GameTime_t
    pub const m_blinkTimer: usize = 0x1120; // CountdownTimer
    pub const m_lookAt: usize = 0x1138; // Vector
    pub const m_lookAroundTimer: usize = 0x1148; // CountdownTimer
    pub const m_isInit: usize = 0x1160; // bool
    pub const m_eyeAttachment: usize = 0x1161; // AttachmentHandle_t
    pub const m_chestAttachment: usize = 0x1162; // AttachmentHandle_t
    pub const m_pPredictionOwner: usize = 0x1168; // CBasePlayerController*
    pub const m_fNewestAlphaThinkTime: usize = 0x1170; // GameTime_t
}

pub mod C_Inferno {
    pub const m_nfxFireDamageEffect: usize = 0xD00; // ParticleIndex_t
    pub const m_firePositions: usize = 0xD04; // Vector[64]
    pub const m_fireParentPositions: usize = 0x1004; // Vector[64]
    pub const m_bFireIsBurning: usize = 0x1304; // bool[64]
    pub const m_BurnNormal: usize = 0x1344; // Vector[64]
    pub const m_fireCount: usize = 0x1644; // int32_t
    pub const m_nInfernoType: usize = 0x1648; // int32_t
    pub const m_nFireLifetime: usize = 0x164C; // float
    pub const m_bInPostEffectTime: usize = 0x1650; // bool
    pub const m_lastFireCount: usize = 0x1654; // int32_t
    pub const m_nFireEffectTickBegin: usize = 0x1658; // int32_t
    pub const m_drawableCount: usize = 0x8260; // int32_t
    pub const m_blosCheck: usize = 0x8264; // bool
    pub const m_nlosperiod: usize = 0x8268; // int32_t
    pub const m_maxFireHalfWidth: usize = 0x826C; // float
    pub const m_maxFireHeight: usize = 0x8270; // float
    pub const m_minBounds: usize = 0x8274; // Vector
    pub const m_maxBounds: usize = 0x8280; // Vector
    pub const m_flLastGrassBurnThink: usize = 0x828C; // float
}

pub mod C_InfoVisibilityBox {
    pub const m_nMode: usize = 0x544; // int32_t
    pub const m_vBoxSize: usize = 0x548; // Vector
    pub const m_bEnabled: usize = 0x554; // bool
}

pub mod C_IronSightController {
    pub const m_bIronSightAvailable: usize = 0x10; // bool
    pub const m_flIronSightAmount: usize = 0x14; // float
    pub const m_flIronSightAmountGained: usize = 0x18; // float
    pub const m_flIronSightAmountBiased: usize = 0x1C; // float
    pub const m_flIronSightAmount_Interpolated: usize = 0x20; // float
    pub const m_flIronSightAmountGained_Interpolated: usize = 0x24; // float
    pub const m_flIronSightAmountBiased_Interpolated: usize = 0x28; // float
    pub const m_flInterpolationLastUpdated: usize = 0x2C; // float
    pub const m_angDeltaAverage: usize = 0x30; // QAngle[8]
    pub const m_angViewLast: usize = 0x90; // QAngle
    pub const m_vecDotCoords: usize = 0x9C; // Vector2D
    pub const m_flDotBlur: usize = 0xA4; // float
    pub const m_flSpeedRatio: usize = 0xA8; // float
}

pub mod C_Item {
    pub const m_bShouldGlow: usize = 0x1560; // bool
    pub const m_pReticleHintTextName: usize = 0x1561; // char[256]
}

pub mod C_ItemDogtags {
    pub const m_OwningPlayer: usize = 0x1668; // CHandle<C_CSPlayerPawn>
    pub const m_KillingPlayer: usize = 0x166C; // CHandle<C_CSPlayerPawn>
}

pub mod C_LightEntity {
    pub const m_CLightComponent: usize = 0xCC0; // CLightComponent*
}

pub mod C_LightGlow {
    pub const m_nHorizontalSize: usize = 0xCC0; // uint32_t
    pub const m_nVerticalSize: usize = 0xCC4; // uint32_t
    pub const m_nMinDist: usize = 0xCC8; // uint32_t
    pub const m_nMaxDist: usize = 0xCCC; // uint32_t
    pub const m_nOuterMaxDist: usize = 0xCD0; // uint32_t
    pub const m_flGlowProxySize: usize = 0xCD4; // float
    pub const m_flHDRColorScale: usize = 0xCD8; // float
    pub const m_Glow: usize = 0xCE0; // C_LightGlowOverlay
}

pub mod C_LightGlowOverlay {
    pub const m_vecOrigin: usize = 0xD0; // Vector
    pub const m_vecDirection: usize = 0xDC; // Vector
    pub const m_nMinDist: usize = 0xE8; // int32_t
    pub const m_nMaxDist: usize = 0xEC; // int32_t
    pub const m_nOuterMaxDist: usize = 0xF0; // int32_t
    pub const m_bOneSided: usize = 0xF4; // bool
    pub const m_bModulateByDot: usize = 0xF5; // bool
}

pub mod C_LocalTempEntity {
    pub const flags: usize = 0xE98; // int32_t
    pub const die: usize = 0xE9C; // GameTime_t
    pub const m_flFrameMax: usize = 0xEA0; // float
    pub const x: usize = 0xEA4; // float
    pub const y: usize = 0xEA8; // float
    pub const fadeSpeed: usize = 0xEAC; // float
    pub const bounceFactor: usize = 0xEB0; // float
    pub const hitSound: usize = 0xEB4; // int32_t
    pub const priority: usize = 0xEB8; // int32_t
    pub const tentOffset: usize = 0xEBC; // Vector
    pub const m_vecTempEntAngVelocity: usize = 0xEC8; // QAngle
    pub const tempent_renderamt: usize = 0xED4; // int32_t
    pub const m_vecNormal: usize = 0xED8; // Vector
    pub const m_flSpriteScale: usize = 0xEE4; // float
    pub const m_nFlickerFrame: usize = 0xEE8; // int32_t
    pub const m_flFrameRate: usize = 0xEEC; // float
    pub const m_flFrame: usize = 0xEF0; // float
    pub const m_pszImpactEffect: usize = 0xEF8; // char*
    pub const m_pszParticleEffect: usize = 0xF00; // char*
    pub const m_bParticleCollision: usize = 0xF08; // bool
    pub const m_iLastCollisionFrame: usize = 0xF0C; // int32_t
    pub const m_vLastCollisionOrigin: usize = 0xF10; // Vector
    pub const m_vecTempEntVelocity: usize = 0xF1C; // Vector
    pub const m_vecPrevAbsOrigin: usize = 0xF28; // Vector
    pub const m_vecTempEntAcceleration: usize = 0xF34; // Vector
}

pub mod C_MapVetoPickController {
    pub const m_nDraftType: usize = 0x550; // int32_t
    pub const m_nTeamWinningCoinToss: usize = 0x554; // int32_t
    pub const m_nTeamWithFirstChoice: usize = 0x558; // int32_t[64]
    pub const m_nVoteMapIdsList: usize = 0x658; // int32_t[7]
    pub const m_nAccountIDs: usize = 0x674; // int32_t[64]
    pub const m_nMapId0: usize = 0x774; // int32_t[64]
    pub const m_nMapId1: usize = 0x874; // int32_t[64]
    pub const m_nMapId2: usize = 0x974; // int32_t[64]
    pub const m_nMapId3: usize = 0xA74; // int32_t[64]
    pub const m_nMapId4: usize = 0xB74; // int32_t[64]
    pub const m_nMapId5: usize = 0xC74; // int32_t[64]
    pub const m_nStartingSide0: usize = 0xD74; // int32_t[64]
    pub const m_nCurrentPhase: usize = 0xE74; // int32_t
    pub const m_nPhaseStartTick: usize = 0xE78; // int32_t
    pub const m_nPhaseDurationTicks: usize = 0xE7C; // int32_t
    pub const m_nPostDataUpdateTick: usize = 0xE80; // int32_t
    pub const m_bDisabledHud: usize = 0xE84; // bool
}

pub mod C_Melee {
    pub const m_flThrowAt: usize = 0x19F0; // GameTime_t
}

pub mod C_MolotovProjectile {
    pub const m_bIsIncGrenade: usize = 0x1100; // bool
}

pub mod C_Multimeter {
    pub const m_hTargetC4: usize = 0xE88; // CHandle<C_PlantedC4>
}

pub mod C_OmniLight {
    pub const m_flInnerAngle: usize = 0xF08; // float
    pub const m_flOuterAngle: usize = 0xF0C; // float
    pub const m_bShowLight: usize = 0xF10; // bool
}

pub mod C_ParticleSystem {
    pub const m_szSnapshotFileName: usize = 0xCC0; // char[512]
    pub const m_bActive: usize = 0xEC0; // bool
    pub const m_bFrozen: usize = 0xEC1; // bool
    pub const m_flFreezeTransitionDuration: usize = 0xEC4; // float
    pub const m_nStopType: usize = 0xEC8; // int32_t
    pub const m_bAnimateDuringGameplayPause: usize = 0xECC; // bool
    pub const m_iEffectIndex: usize = 0xED0; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    pub const m_flStartTime: usize = 0xED8; // GameTime_t
    pub const m_flPreSimTime: usize = 0xEDC; // float
    pub const m_vServerControlPoints: usize = 0xEE0; // Vector[4]
    pub const m_iServerControlPointAssignments: usize = 0xF10; // uint8_t[4]
    pub const m_hControlPointEnts: usize = 0xF14; // CHandle<C_BaseEntity>[64]
    pub const m_bNoSave: usize = 0x1014; // bool
    pub const m_bNoFreeze: usize = 0x1015; // bool
    pub const m_bNoRamp: usize = 0x1016; // bool
    pub const m_bStartActive: usize = 0x1017; // bool
    pub const m_iszEffectName: usize = 0x1018; // CUtlSymbolLarge
    pub const m_iszControlPointNames: usize = 0x1020; // CUtlSymbolLarge[64]
    pub const m_nDataCP: usize = 0x1220; // int32_t
    pub const m_vecDataCPValue: usize = 0x1224; // Vector
    pub const m_nTintCP: usize = 0x1230; // int32_t
    pub const m_clrTint: usize = 0x1234; // Color
    pub const m_bOldActive: usize = 0x1258; // bool
    pub const m_bOldFrozen: usize = 0x1259; // bool
}

pub mod C_PathParticleRope {
    pub const m_bStartActive: usize = 0x540; // bool
    pub const m_flMaxSimulationTime: usize = 0x544; // float
    pub const m_iszEffectName: usize = 0x548; // CUtlSymbolLarge
    pub const m_PathNodes_Name: usize = 0x550; // CUtlVector<CUtlSymbolLarge>
    pub const m_flParticleSpacing: usize = 0x568; // float
    pub const m_flSlack: usize = 0x56C; // float
    pub const m_flRadius: usize = 0x570; // float
    pub const m_ColorTint: usize = 0x574; // Color
    pub const m_nEffectState: usize = 0x578; // int32_t
    pub const m_iEffectIndex: usize = 0x580; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    pub const m_PathNodes_Position: usize = 0x588; // C_NetworkUtlVectorBase<Vector>
    pub const m_PathNodes_TangentIn: usize = 0x5A0; // C_NetworkUtlVectorBase<Vector>
    pub const m_PathNodes_TangentOut: usize = 0x5B8; // C_NetworkUtlVectorBase<Vector>
    pub const m_PathNodes_Color: usize = 0x5D0; // C_NetworkUtlVectorBase<Vector>
    pub const m_PathNodes_PinEnabled: usize = 0x5E8; // C_NetworkUtlVectorBase<bool>
    pub const m_PathNodes_RadiusScale: usize = 0x600; // C_NetworkUtlVectorBase<float>
}

pub mod C_PhysMagnet {
    pub const m_aAttachedObjectsFromServer: usize = 0xE80; // CUtlVector<int32_t>
    pub const m_aAttachedObjects: usize = 0xE98; // CUtlVector<CHandle<C_BaseEntity>>
}

pub mod C_PhysPropClientside {
    pub const m_flTouchDelta: usize = 0xFD0; // GameTime_t
    pub const m_fDeathTime: usize = 0xFD4; // GameTime_t
    pub const m_impactEnergyScale: usize = 0xFD8; // float
    pub const m_inertiaScale: usize = 0xFDC; // float
    pub const m_flDmgModBullet: usize = 0xFE0; // float
    pub const m_flDmgModClub: usize = 0xFE4; // float
    pub const m_flDmgModExplosive: usize = 0xFE8; // float
    pub const m_flDmgModFire: usize = 0xFEC; // float
    pub const m_iszPhysicsDamageTableName: usize = 0xFF0; // CUtlSymbolLarge
    pub const m_iszBasePropData: usize = 0xFF8; // CUtlSymbolLarge
    pub const m_iInteractions: usize = 0x1000; // int32_t
    pub const m_bHasBreakPiecesOrCommands: usize = 0x1004; // bool
    pub const m_vecDamagePosition: usize = 0x1008; // Vector
    pub const m_vecDamageDirection: usize = 0x1014; // Vector
    pub const m_nDamageType: usize = 0x1020; // int32_t
}

pub mod C_PhysicsProp {
    pub const m_bAwake: usize = 0xFD0; // bool
}

pub mod C_PickUpModelSlerper {
    pub const m_hPlayerParent: usize = 0xE80; // CHandle<C_BaseEntity>
    pub const m_hItem: usize = 0xE84; // CHandle<C_BaseEntity>
    pub const m_flTimePickedUp: usize = 0xE88; // float
    pub const m_angOriginal: usize = 0xE8C; // QAngle
    pub const m_vecPosOriginal: usize = 0xE98; // Vector
    pub const m_angRandom: usize = 0xEA8; // QAngle
}

pub mod C_PlantedC4 {
    pub const m_bBombTicking: usize = 0xE80; // bool
    pub const m_nBombSite: usize = 0xE84; // int32_t
    pub const m_nSourceSoundscapeHash: usize = 0xE88; // int32_t
    pub const m_entitySpottedState: usize = 0xE90; // EntitySpottedState_t
    pub const m_flNextGlow: usize = 0xEA8; // GameTime_t
    pub const m_flNextBeep: usize = 0xEAC; // GameTime_t
    pub const m_flC4Blow: usize = 0xEB0; // GameTime_t
    pub const m_bCannotBeDefused: usize = 0xEB4; // bool
    pub const m_bHasExploded: usize = 0xEB5; // bool
    pub const m_flTimerLength: usize = 0xEB8; // float
    pub const m_bBeingDefused: usize = 0xEBC; // bool
    pub const m_bTriggerWarning: usize = 0xEC0; // float
    pub const m_bExplodeWarning: usize = 0xEC4; // float
    pub const m_bC4Activated: usize = 0xEC8; // bool
    pub const m_bTenSecWarning: usize = 0xEC9; // bool
    pub const m_flDefuseLength: usize = 0xECC; // float
    pub const m_flDefuseCountDown: usize = 0xED0; // GameTime_t
    pub const m_bBombDefused: usize = 0xED4; // bool
    pub const m_hBombDefuser: usize = 0xED8; // CHandle<C_CSPlayerPawn>
    pub const m_hControlPanel: usize = 0xEDC; // CHandle<C_BaseEntity>
    pub const m_hDefuserMultimeter: usize = 0xEE0; // CHandle<C_Multimeter>
    pub const m_flNextRadarFlashTime: usize = 0xEE4; // GameTime_t
    pub const m_bRadarFlash: usize = 0xEE8; // bool
    pub const m_pBombDefuser: usize = 0xEEC; // CHandle<C_CSPlayerPawn>
    pub const m_fLastDefuseTime: usize = 0xEF0; // GameTime_t
    pub const m_pPredictionOwner: usize = 0xEF8; // CBasePlayerController*
}

pub mod C_PlayerPing {
    pub const m_hPlayer: usize = 0x570; // CHandle<C_CSPlayerPawn>
    pub const m_hPingedEntity: usize = 0x574; // CHandle<C_BaseEntity>
    pub const m_iType: usize = 0x578; // int32_t
    pub const m_bUrgent: usize = 0x57C; // bool
    pub const m_szPlaceName: usize = 0x57D; // char[18]
}

pub mod C_PlayerSprayDecal {
    pub const m_nUniqueID: usize = 0xCC0; // int32_t
    pub const m_unAccountID: usize = 0xCC4; // uint32_t
    pub const m_unTraceID: usize = 0xCC8; // uint32_t
    pub const m_rtGcTime: usize = 0xCCC; // uint32_t
    pub const m_vecEndPos: usize = 0xCD0; // Vector
    pub const m_vecStart: usize = 0xCDC; // Vector
    pub const m_vecLeft: usize = 0xCE8; // Vector
    pub const m_vecNormal: usize = 0xCF4; // Vector
    pub const m_nPlayer: usize = 0xD00; // int32_t
    pub const m_nEntity: usize = 0xD04; // int32_t
    pub const m_nHitbox: usize = 0xD08; // int32_t
    pub const m_flCreationTime: usize = 0xD0C; // float
    pub const m_nTintID: usize = 0xD10; // int32_t
    pub const m_nVersion: usize = 0xD14; // uint8_t
    pub const m_ubSignature: usize = 0xD15; // uint8_t[128]
    pub const m_SprayRenderHelper: usize = 0xDA0; // CPlayerSprayDecalRenderHelper
}

pub mod C_PlayerVisibility {
    pub const m_flVisibilityStrength: usize = 0x540; // float
    pub const m_flFogDistanceMultiplier: usize = 0x544; // float
    pub const m_flFogMaxDensityMultiplier: usize = 0x548; // float
    pub const m_flFadeTime: usize = 0x54C; // float
    pub const m_bStartDisabled: usize = 0x550; // bool
    pub const m_bIsEnabled: usize = 0x551; // bool
}

pub mod C_PointCamera {
    pub const m_FOV: usize = 0x540; // float
    pub const m_Resolution: usize = 0x544; // float
    pub const m_bFogEnable: usize = 0x548; // bool
    pub const m_FogColor: usize = 0x549; // Color
    pub const m_flFogStart: usize = 0x550; // float
    pub const m_flFogEnd: usize = 0x554; // float
    pub const m_flFogMaxDensity: usize = 0x558; // float
    pub const m_bActive: usize = 0x55C; // bool
    pub const m_bUseScreenAspectRatio: usize = 0x55D; // bool
    pub const m_flAspectRatio: usize = 0x560; // float
    pub const m_bNoSky: usize = 0x564; // bool
    pub const m_fBrightness: usize = 0x568; // float
    pub const m_flZFar: usize = 0x56C; // float
    pub const m_flZNear: usize = 0x570; // float
    pub const m_bCanHLTVUse: usize = 0x574; // bool
    pub const m_bDofEnabled: usize = 0x575; // bool
    pub const m_flDofNearBlurry: usize = 0x578; // float
    pub const m_flDofNearCrisp: usize = 0x57C; // float
    pub const m_flDofFarCrisp: usize = 0x580; // float
    pub const m_flDofFarBlurry: usize = 0x584; // float
    pub const m_flDofTiltToGround: usize = 0x588; // float
    pub const m_TargetFOV: usize = 0x58C; // float
    pub const m_DegreesPerSecond: usize = 0x590; // float
    pub const m_bIsOn: usize = 0x594; // bool
    pub const m_pNext: usize = 0x598; // C_PointCamera*
}

pub mod C_PointCameraVFOV {
    pub const m_flVerticalFOV: usize = 0x5A0; // float
}

pub mod C_PointClientUIDialog {
    pub const m_hActivator: usize = 0xCF0; // CHandle<C_BaseEntity>
    pub const m_bStartEnabled: usize = 0xCF4; // bool
}

pub mod C_PointClientUIHUD {
    pub const m_bCheckCSSClasses: usize = 0xCF8; // bool
    pub const m_bIgnoreInput: usize = 0xE80; // bool
    pub const m_flWidth: usize = 0xE84; // float
    pub const m_flHeight: usize = 0xE88; // float
    pub const m_flDPI: usize = 0xE8C; // float
    pub const m_flInteractDistance: usize = 0xE90; // float
    pub const m_flDepthOffset: usize = 0xE94; // float
    pub const m_unOwnerContext: usize = 0xE98; // uint32_t
    pub const m_unHorizontalAlign: usize = 0xE9C; // uint32_t
    pub const m_unVerticalAlign: usize = 0xEA0; // uint32_t
    pub const m_unOrientation: usize = 0xEA4; // uint32_t
    pub const m_bAllowInteractionFromAllSceneWorlds: usize = 0xEA8; // bool
    pub const m_vecCSSClasses: usize = 0xEB0; // C_NetworkUtlVectorBase<CUtlSymbolLarge>
}

pub mod C_PointClientUIWorldPanel {
    pub const m_bForceRecreateNextUpdate: usize = 0xCF8; // bool
    pub const m_bMoveViewToPlayerNextThink: usize = 0xCF9; // bool
    pub const m_bCheckCSSClasses: usize = 0xCFA; // bool
    pub const m_anchorDeltaTransform: usize = 0xD00; // CTransform
    pub const m_pOffScreenIndicator: usize = 0xEA0; // CPointOffScreenIndicatorUi*
    pub const m_bIgnoreInput: usize = 0xEC8; // bool
    pub const m_bLit: usize = 0xEC9; // bool
    pub const m_bFollowPlayerAcrossTeleport: usize = 0xECA; // bool
    pub const m_flWidth: usize = 0xECC; // float
    pub const m_flHeight: usize = 0xED0; // float
    pub const m_flDPI: usize = 0xED4; // float
    pub const m_flInteractDistance: usize = 0xED8; // float
    pub const m_flDepthOffset: usize = 0xEDC; // float
    pub const m_unOwnerContext: usize = 0xEE0; // uint32_t
    pub const m_unHorizontalAlign: usize = 0xEE4; // uint32_t
    pub const m_unVerticalAlign: usize = 0xEE8; // uint32_t
    pub const m_unOrientation: usize = 0xEEC; // uint32_t
    pub const m_bAllowInteractionFromAllSceneWorlds: usize = 0xEF0; // bool
    pub const m_vecCSSClasses: usize = 0xEF8; // C_NetworkUtlVectorBase<CUtlSymbolLarge>
    pub const m_bOpaque: usize = 0xF10; // bool
    pub const m_bNoDepth: usize = 0xF11; // bool
    pub const m_bRenderBackface: usize = 0xF12; // bool
    pub const m_bUseOffScreenIndicator: usize = 0xF13; // bool
    pub const m_bExcludeFromSaveGames: usize = 0xF14; // bool
    pub const m_bGrabbable: usize = 0xF15; // bool
    pub const m_bOnlyRenderToTexture: usize = 0xF16; // bool
    pub const m_bDisableMipGen: usize = 0xF17; // bool
    pub const m_nExplicitImageLayout: usize = 0xF18; // int32_t
}

pub mod C_PointClientUIWorldTextPanel {
    pub const m_messageText: usize = 0xF20; // char[512]
}

pub mod C_PointCommentaryNode {
    pub const m_bActive: usize = 0xE88; // bool
    pub const m_bWasActive: usize = 0xE89; // bool
    pub const m_flEndTime: usize = 0xE8C; // GameTime_t
    pub const m_flStartTime: usize = 0xE90; // GameTime_t
    pub const m_flStartTimeInCommentary: usize = 0xE94; // float
    pub const m_iszCommentaryFile: usize = 0xE98; // CUtlSymbolLarge
    pub const m_iszTitle: usize = 0xEA0; // CUtlSymbolLarge
    pub const m_iszSpeakers: usize = 0xEA8; // CUtlSymbolLarge
    pub const m_iNodeNumber: usize = 0xEB0; // int32_t
    pub const m_iNodeNumberMax: usize = 0xEB4; // int32_t
    pub const m_bListenedTo: usize = 0xEB8; // bool
    pub const m_hViewPosition: usize = 0xEC8; // CHandle<C_BaseEntity>
    pub const m_bRestartAfterRestore: usize = 0xECC; // bool
}

pub mod C_PointValueRemapper {
    pub const m_bDisabled: usize = 0x540; // bool
    pub const m_bDisabledOld: usize = 0x541; // bool
    pub const m_bUpdateOnClient: usize = 0x542; // bool
    pub const m_nInputType: usize = 0x544; // ValueRemapperInputType_t
    pub const m_hRemapLineStart: usize = 0x548; // CHandle<C_BaseEntity>
    pub const m_hRemapLineEnd: usize = 0x54C; // CHandle<C_BaseEntity>
    pub const m_flMaximumChangePerSecond: usize = 0x550; // float
    pub const m_flDisengageDistance: usize = 0x554; // float
    pub const m_flEngageDistance: usize = 0x558; // float
    pub const m_bRequiresUseKey: usize = 0x55C; // bool
    pub const m_nOutputType: usize = 0x560; // ValueRemapperOutputType_t
    pub const m_hOutputEntities: usize = 0x568; // C_NetworkUtlVectorBase<CHandle<C_BaseEntity>>
    pub const m_nHapticsType: usize = 0x580; // ValueRemapperHapticsType_t
    pub const m_nMomentumType: usize = 0x584; // ValueRemapperMomentumType_t
    pub const m_flMomentumModifier: usize = 0x588; // float
    pub const m_flSnapValue: usize = 0x58C; // float
    pub const m_flCurrentMomentum: usize = 0x590; // float
    pub const m_nRatchetType: usize = 0x594; // ValueRemapperRatchetType_t
    pub const m_flRatchetOffset: usize = 0x598; // float
    pub const m_flInputOffset: usize = 0x59C; // float
    pub const m_bEngaged: usize = 0x5A0; // bool
    pub const m_bFirstUpdate: usize = 0x5A1; // bool
    pub const m_flPreviousValue: usize = 0x5A4; // float
    pub const m_flPreviousUpdateTickTime: usize = 0x5A8; // GameTime_t
    pub const m_vecPreviousTestPoint: usize = 0x5AC; // Vector
}

pub mod C_PointWorldText {
    pub const m_bForceRecreateNextUpdate: usize = 0xCC8; // bool
    pub const m_messageText: usize = 0xCD8; // char[512]
    pub const m_FontName: usize = 0xED8; // char[64]
    pub const m_bEnabled: usize = 0xF18; // bool
    pub const m_bFullbright: usize = 0xF19; // bool
    pub const m_flWorldUnitsPerPx: usize = 0xF1C; // float
    pub const m_flFontSize: usize = 0xF20; // float
    pub const m_flDepthOffset: usize = 0xF24; // float
    pub const m_Color: usize = 0xF28; // Color
    pub const m_nJustifyHorizontal: usize = 0xF2C; // PointWorldTextJustifyHorizontal_t
    pub const m_nJustifyVertical: usize = 0xF30; // PointWorldTextJustifyVertical_t
    pub const m_nReorientMode: usize = 0xF34; // PointWorldTextReorientMode_t
}

pub mod C_PostProcessingVolume {
    pub const m_hPostSettings: usize = 0xCD8; // CStrongHandle<InfoForResourceTypeCPostProcessingResource>
    pub const m_flFadeDuration: usize = 0xCE0; // float
    pub const m_flMinLogExposure: usize = 0xCE4; // float
    pub const m_flMaxLogExposure: usize = 0xCE8; // float
    pub const m_flMinExposure: usize = 0xCEC; // float
    pub const m_flMaxExposure: usize = 0xCF0; // float
    pub const m_flExposureCompensation: usize = 0xCF4; // float
    pub const m_flExposureFadeSpeedUp: usize = 0xCF8; // float
    pub const m_flExposureFadeSpeedDown: usize = 0xCFC; // float
    pub const m_flTonemapEVSmoothingRange: usize = 0xD00; // float
    pub const m_bMaster: usize = 0xD04; // bool
    pub const m_bExposureControl: usize = 0xD05; // bool
    pub const m_flRate: usize = 0xD08; // float
    pub const m_flTonemapPercentTarget: usize = 0xD0C; // float
    pub const m_flTonemapPercentBrightPixels: usize = 0xD10; // float
    pub const m_flTonemapMinAvgLum: usize = 0xD14; // float
}

pub mod C_Precipitation {
    pub const m_flDensity: usize = 0xCC8; // float
    pub const m_flParticleInnerDist: usize = 0xCD8; // float
    pub const m_pParticleDef: usize = 0xCE0; // char*
    pub const m_tParticlePrecipTraceTimer: usize = 0xD08; // TimedEvent[1]
    pub const m_bActiveParticlePrecipEmitter: usize = 0xD10; // bool[1]
    pub const m_bParticlePrecipInitialized: usize = 0xD11; // bool
    pub const m_bHasSimulatedSinceLastSceneObjectUpdate: usize = 0xD12; // bool
    pub const m_nAvailableSheetSequencesMaxIndex: usize = 0xD14; // int32_t
}

pub mod C_PredictedViewModel {
    pub const m_LagAnglesHistory: usize = 0xEE8; // QAngle
    pub const m_vPredictedOffset: usize = 0xF00; // Vector
}

pub mod C_RagdollManager {
    pub const m_iCurrentMaxRagdollCount: usize = 0x540; // int8_t
}

pub mod C_RagdollProp {
    pub const m_ragPos: usize = 0xE88; // C_NetworkUtlVectorBase<Vector>
    pub const m_ragAngles: usize = 0xEA0; // C_NetworkUtlVectorBase<QAngle>
    pub const m_flBlendWeight: usize = 0xEB8; // float
    pub const m_hRagdollSource: usize = 0xEBC; // CHandle<C_BaseEntity>
    pub const m_iEyeAttachment: usize = 0xEC0; // AttachmentHandle_t
    pub const m_flBlendWeightCurrent: usize = 0xEC4; // float
    pub const m_parentPhysicsBoneIndices: usize = 0xEC8; // CUtlVector<int32_t>
    pub const m_worldSpaceBoneComputationOrder: usize = 0xEE0; // CUtlVector<int32_t>
}

pub mod C_RagdollPropAttached {
    pub const m_boneIndexAttached: usize = 0xEF8; // uint32_t
    pub const m_ragdollAttachedObjectIndex: usize = 0xEFC; // uint32_t
    pub const m_attachmentPointBoneSpace: usize = 0xF00; // Vector
    pub const m_attachmentPointRagdollSpace: usize = 0xF0C; // Vector
    pub const m_vecOffset: usize = 0xF18; // Vector
    pub const m_parentTime: usize = 0xF24; // float
    pub const m_bHasParent: usize = 0xF28; // bool
}

pub mod C_RectLight {
    pub const m_bShowLight: usize = 0xF08; // bool
}

pub mod C_RetakeGameRules {
    pub const m_nMatchSeed: usize = 0xF8; // int32_t
    pub const m_bBlockersPresent: usize = 0xFC; // bool
    pub const m_bRoundInProgress: usize = 0xFD; // bool
    pub const m_iFirstSecondHalfRound: usize = 0x100; // int32_t
    pub const m_iBombSite: usize = 0x104; // int32_t
}

pub mod C_RopeKeyframe {
    pub const m_LinksTouchingSomething: usize = 0xCC8; // CBitVec<10>
    pub const m_nLinksTouchingSomething: usize = 0xCCC; // int32_t
    pub const m_bApplyWind: usize = 0xCD0; // bool
    pub const m_fPrevLockedPoints: usize = 0xCD4; // int32_t
    pub const m_iForcePointMoveCounter: usize = 0xCD8; // int32_t
    pub const m_bPrevEndPointPos: usize = 0xCDC; // bool[2]
    pub const m_vPrevEndPointPos: usize = 0xCE0; // Vector[2]
    pub const m_flCurScroll: usize = 0xCF8; // float
    pub const m_flScrollSpeed: usize = 0xCFC; // float
    pub const m_RopeFlags: usize = 0xD00; // uint16_t
    pub const m_iRopeMaterialModelIndex: usize = 0xD08; // CStrongHandle<InfoForResourceTypeIMaterial2>
    pub const m_LightValues: usize = 0xF80; // Vector[10]
    pub const m_nSegments: usize = 0xFF8; // uint8_t
    pub const m_hStartPoint: usize = 0xFFC; // CHandle<C_BaseEntity>
    pub const m_hEndPoint: usize = 0x1000; // CHandle<C_BaseEntity>
    pub const m_iStartAttachment: usize = 0x1004; // AttachmentHandle_t
    pub const m_iEndAttachment: usize = 0x1005; // AttachmentHandle_t
    pub const m_Subdiv: usize = 0x1006; // uint8_t
    pub const m_RopeLength: usize = 0x1008; // int16_t
    pub const m_Slack: usize = 0x100A; // int16_t
    pub const m_TextureScale: usize = 0x100C; // float
    pub const m_fLockedPoints: usize = 0x1010; // uint8_t
    pub const m_nChangeCount: usize = 0x1011; // uint8_t
    pub const m_Width: usize = 0x1014; // float
    pub const m_PhysicsDelegate: usize = 0x1018; // C_RopeKeyframe::CPhysicsDelegate
    pub const m_hMaterial: usize = 0x1028; // CStrongHandle<InfoForResourceTypeIMaterial2>
    pub const m_TextureHeight: usize = 0x1030; // int32_t
    pub const m_vecImpulse: usize = 0x1034; // Vector
    pub const m_vecPreviousImpulse: usize = 0x1040; // Vector
    pub const m_flCurrentGustTimer: usize = 0x104C; // float
    pub const m_flCurrentGustLifetime: usize = 0x1050; // float
    pub const m_flTimeToNextGust: usize = 0x1054; // float
    pub const m_vWindDir: usize = 0x1058; // Vector
    pub const m_vColorMod: usize = 0x1064; // Vector
    pub const m_vCachedEndPointAttachmentPos: usize = 0x1070; // Vector[2]
    pub const m_vCachedEndPointAttachmentAngle: usize = 0x1088; // QAngle[2]
    pub const m_bConstrainBetweenEndpoints: usize = 0x10A0; // bool
    pub const m_bEndPointAttachmentPositionsDirty: usize = 0x0; // bitfield:1
    pub const m_bEndPointAttachmentAnglesDirty: usize = 0x0; // bitfield:1
    pub const m_bNewDataThisFrame: usize = 0x0; // bitfield:1
    pub const m_bPhysicsInitted: usize = 0x0; // bitfield:1
}

pub mod C_RopeKeyframe_CPhysicsDelegate {
    pub const m_pKeyframe: usize = 0x8; // C_RopeKeyframe*
}

pub mod C_SceneEntity {
    pub const m_bIsPlayingBack: usize = 0x548; // bool
    pub const m_bPaused: usize = 0x549; // bool
    pub const m_bMultiplayer: usize = 0x54A; // bool
    pub const m_bAutogenerated: usize = 0x54B; // bool
    pub const m_flForceClientTime: usize = 0x54C; // float
    pub const m_nSceneStringIndex: usize = 0x550; // uint16_t
    pub const m_bClientOnly: usize = 0x552; // bool
    pub const m_hOwner: usize = 0x554; // CHandle<C_BaseFlex>
    pub const m_hActorList: usize = 0x558; // C_NetworkUtlVectorBase<CHandle<C_BaseFlex>>
    pub const m_bWasPlaying: usize = 0x570; // bool
    pub const m_QueuedEvents: usize = 0x580; // CUtlVector<C_SceneEntity::QueuedEvents_t>
    pub const m_flCurrentTime: usize = 0x598; // float
}

pub mod C_SceneEntity_QueuedEvents_t {
    pub const starttime: usize = 0x0; // float
}

pub mod C_ShatterGlassShardPhysics {
    pub const m_ShardDesc: usize = 0xFE0; // shard_model_desc_t
}

pub mod C_SkyCamera {
    pub const m_skyboxData: usize = 0x540; // sky3dparams_t
    pub const m_skyboxSlotToken: usize = 0x5D0; // CUtlStringToken
    pub const m_bUseAngles: usize = 0x5D4; // bool
    pub const m_pNext: usize = 0x5D8; // C_SkyCamera*
}

pub mod C_SmokeGrenadeProjectile {
    pub const m_nSmokeEffectTickBegin: usize = 0x1108; // int32_t
    pub const m_bDidSmokeEffect: usize = 0x110C; // bool
    pub const m_nRandomSeed: usize = 0x1110; // int32_t
    pub const m_vSmokeColor: usize = 0x1114; // Vector
    pub const m_vSmokeDetonationPos: usize = 0x1120; // Vector
    pub const m_VoxelFrameData: usize = 0x1130; // CUtlVector<uint8_t>
    pub const m_bSmokeVolumeDataReceived: usize = 0x1148; // bool
    pub const m_bSmokeEffectSpawned: usize = 0x1149; // bool
}

pub mod C_SoundAreaEntityBase {
    pub const m_bDisabled: usize = 0x540; // bool
    pub const m_bWasEnabled: usize = 0x548; // bool
    pub const m_iszSoundAreaType: usize = 0x550; // CUtlSymbolLarge
    pub const m_vPos: usize = 0x558; // Vector
}

pub mod C_SoundAreaEntityOrientedBox {
    pub const m_vMin: usize = 0x568; // Vector
    pub const m_vMax: usize = 0x574; // Vector
}

pub mod C_SoundAreaEntitySphere {
    pub const m_flRadius: usize = 0x568; // float
}

pub mod C_SoundOpvarSetPointBase {
    pub const m_iszStackName: usize = 0x540; // CUtlSymbolLarge
    pub const m_iszOperatorName: usize = 0x548; // CUtlSymbolLarge
    pub const m_iszOpvarName: usize = 0x550; // CUtlSymbolLarge
    pub const m_iOpvarIndex: usize = 0x558; // int32_t
    pub const m_bUseAutoCompare: usize = 0x55C; // bool
}

pub mod C_SpotlightEnd {
    pub const m_flLightScale: usize = 0xCC0; // float
    pub const m_Radius: usize = 0xCC4; // float
}

pub mod C_Sprite {
    pub const m_hSpriteMaterial: usize = 0xCD8; // CStrongHandle<InfoForResourceTypeIMaterial2>
    pub const m_hAttachedToEntity: usize = 0xCE0; // CHandle<C_BaseEntity>
    pub const m_nAttachment: usize = 0xCE4; // AttachmentHandle_t
    pub const m_flSpriteFramerate: usize = 0xCE8; // float
    pub const m_flFrame: usize = 0xCEC; // float
    pub const m_flDieTime: usize = 0xCF0; // GameTime_t
    pub const m_nBrightness: usize = 0xD00; // uint32_t
    pub const m_flBrightnessDuration: usize = 0xD04; // float
    pub const m_flSpriteScale: usize = 0xD08; // float
    pub const m_flScaleDuration: usize = 0xD0C; // float
    pub const m_bWorldSpaceScale: usize = 0xD10; // bool
    pub const m_flGlowProxySize: usize = 0xD14; // float
    pub const m_flHDRColorScale: usize = 0xD18; // float
    pub const m_flLastTime: usize = 0xD1C; // GameTime_t
    pub const m_flMaxFrame: usize = 0xD20; // float
    pub const m_flStartScale: usize = 0xD24; // float
    pub const m_flDestScale: usize = 0xD28; // float
    pub const m_flScaleTimeStart: usize = 0xD2C; // GameTime_t
    pub const m_nStartBrightness: usize = 0xD30; // int32_t
    pub const m_nDestBrightness: usize = 0xD34; // int32_t
    pub const m_flBrightnessTimeStart: usize = 0xD38; // GameTime_t
    pub const m_hOldSpriteMaterial: usize = 0xD40; // CWeakHandle<InfoForResourceTypeIMaterial2>
    pub const m_nSpriteWidth: usize = 0xDE8; // int32_t
    pub const m_nSpriteHeight: usize = 0xDEC; // int32_t
}

pub mod C_Sun {
    pub const m_fxSSSunFlareEffectIndex: usize = 0xCC0; // ParticleIndex_t
    pub const m_fxSunFlareEffectIndex: usize = 0xCC4; // ParticleIndex_t
    pub const m_fdistNormalize: usize = 0xCC8; // float
    pub const m_vSunPos: usize = 0xCCC; // Vector
    pub const m_vDirection: usize = 0xCD8; // Vector
    pub const m_iszEffectName: usize = 0xCE8; // CUtlSymbolLarge
    pub const m_iszSSEffectName: usize = 0xCF0; // CUtlSymbolLarge
    pub const m_clrOverlay: usize = 0xCF8; // Color
    pub const m_bOn: usize = 0xCFC; // bool
    pub const m_bmaxColor: usize = 0xCFD; // bool
    pub const m_flSize: usize = 0xD00; // float
    pub const m_flHazeScale: usize = 0xD04; // float
    pub const m_flRotation: usize = 0xD08; // float
    pub const m_flHDRColorScale: usize = 0xD0C; // float
    pub const m_flAlphaHaze: usize = 0xD10; // float
    pub const m_flAlphaScale: usize = 0xD14; // float
    pub const m_flAlphaHdr: usize = 0xD18; // float
    pub const m_flFarZScale: usize = 0xD1C; // float
}

pub mod C_SunGlowOverlay {
    pub const m_bModulateByDot: usize = 0xD0; // bool
}

pub mod C_Team {
    pub const m_aPlayerControllers: usize = 0x540; // C_NetworkUtlVectorBase<CHandle<CBasePlayerController>>
    pub const m_aPlayers: usize = 0x558; // C_NetworkUtlVectorBase<CHandle<C_BasePlayerPawn>>
    pub const m_iScore: usize = 0x570; // int32_t
    pub const m_szTeamname: usize = 0x574; // char[129]
}

pub mod C_TeamRoundTimer {
    pub const m_bTimerPaused: usize = 0x540; // bool
    pub const m_flTimeRemaining: usize = 0x544; // float
    pub const m_flTimerEndTime: usize = 0x548; // GameTime_t
    pub const m_bIsDisabled: usize = 0x54C; // bool
    pub const m_bShowInHUD: usize = 0x54D; // bool
    pub const m_nTimerLength: usize = 0x550; // int32_t
    pub const m_nTimerInitialLength: usize = 0x554; // int32_t
    pub const m_nTimerMaxLength: usize = 0x558; // int32_t
    pub const m_bAutoCountdown: usize = 0x55C; // bool
    pub const m_nSetupTimeLength: usize = 0x560; // int32_t
    pub const m_nState: usize = 0x564; // int32_t
    pub const m_bStartPaused: usize = 0x568; // bool
    pub const m_bInCaptureWatchState: usize = 0x569; // bool
    pub const m_flTotalTime: usize = 0x56C; // float
    pub const m_bStopWatchTimer: usize = 0x570; // bool
    pub const m_bFireFinished: usize = 0x571; // bool
    pub const m_bFire5MinRemain: usize = 0x572; // bool
    pub const m_bFire4MinRemain: usize = 0x573; // bool
    pub const m_bFire3MinRemain: usize = 0x574; // bool
    pub const m_bFire2MinRemain: usize = 0x575; // bool
    pub const m_bFire1MinRemain: usize = 0x576; // bool
    pub const m_bFire30SecRemain: usize = 0x577; // bool
    pub const m_bFire10SecRemain: usize = 0x578; // bool
    pub const m_bFire5SecRemain: usize = 0x579; // bool
    pub const m_bFire4SecRemain: usize = 0x57A; // bool
    pub const m_bFire3SecRemain: usize = 0x57B; // bool
    pub const m_bFire2SecRemain: usize = 0x57C; // bool
    pub const m_bFire1SecRemain: usize = 0x57D; // bool
    pub const m_nOldTimerLength: usize = 0x580; // int32_t
    pub const m_nOldTimerState: usize = 0x584; // int32_t
}

pub mod C_TextureBasedAnimatable {
    pub const m_bLoop: usize = 0xCC0; // bool
    pub const m_flFPS: usize = 0xCC4; // float
    pub const m_hPositionKeys: usize = 0xCC8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_hRotationKeys: usize = 0xCD0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_vAnimationBoundsMin: usize = 0xCD8; // Vector
    pub const m_vAnimationBoundsMax: usize = 0xCE4; // Vector
    pub const m_flStartTime: usize = 0xCF0; // float
    pub const m_flStartFrame: usize = 0xCF4; // float
}

pub mod C_TonemapController2 {
    pub const m_flAutoExposureMin: usize = 0x540; // float
    pub const m_flAutoExposureMax: usize = 0x544; // float
    pub const m_flTonemapPercentTarget: usize = 0x548; // float
    pub const m_flTonemapPercentBrightPixels: usize = 0x54C; // float
    pub const m_flTonemapMinAvgLum: usize = 0x550; // float
    pub const m_flExposureAdaptationSpeedUp: usize = 0x554; // float
    pub const m_flExposureAdaptationSpeedDown: usize = 0x558; // float
    pub const m_flTonemapEVSmoothingRange: usize = 0x55C; // float
}

pub mod C_TriggerBuoyancy {
    pub const m_BuoyancyHelper: usize = 0xCC8; // CBuoyancyHelper
    pub const m_flFluidDensity: usize = 0xCE8; // float
}

pub mod C_ViewmodelWeapon {
    pub const m_worldModel: usize = 0xE80; // char*
}

pub mod C_VoteController {
    pub const m_iActiveIssueIndex: usize = 0x550; // int32_t
    pub const m_iOnlyTeamToVote: usize = 0x554; // int32_t
    pub const m_nVoteOptionCount: usize = 0x558; // int32_t[5]
    pub const m_nPotentialVotes: usize = 0x56C; // int32_t
    pub const m_bVotesDirty: usize = 0x570; // bool
    pub const m_bTypeDirty: usize = 0x571; // bool
    pub const m_bIsYesNoVote: usize = 0x572; // bool
}

pub mod C_WeaponBaseItem {
    pub const m_SequenceCompleteTimer: usize = 0x19F0; // CountdownTimer
    pub const m_bRedraw: usize = 0x1A08; // bool
}

pub mod C_WeaponShield {
    pub const m_flDisplayHealth: usize = 0x1A10; // float
}

pub mod C_WeaponTaser {
    pub const m_fFireTime: usize = 0x1A10; // GameTime_t
}

pub mod C_fogplayerparams_t {
    pub const m_hCtrl: usize = 0x8; // CHandle<C_FogController>
    pub const m_flTransitionTime: usize = 0xC; // float
    pub const m_OldColor: usize = 0x10; // Color
    pub const m_flOldStart: usize = 0x14; // float
    pub const m_flOldEnd: usize = 0x18; // float
    pub const m_flOldMaxDensity: usize = 0x1C; // float
    pub const m_flOldHDRColorScale: usize = 0x20; // float
    pub const m_flOldFarZ: usize = 0x24; // float
    pub const m_NewColor: usize = 0x28; // Color
    pub const m_flNewStart: usize = 0x2C; // float
    pub const m_flNewEnd: usize = 0x30; // float
    pub const m_flNewMaxDensity: usize = 0x34; // float
    pub const m_flNewHDRColorScale: usize = 0x38; // float
    pub const m_flNewFarZ: usize = 0x3C; // float
}

pub mod CompMatMutatorCondition_t {
    pub const m_nMutatorCondition: usize = 0x0; // CompMatPropertyMutatorConditionType_t
    pub const m_strMutatorConditionContainerName: usize = 0x8; // CUtlString
    pub const m_strMutatorConditionContainerVarName: usize = 0x10; // CUtlString
    pub const m_strMutatorConditionContainerVarValue: usize = 0x18; // CUtlString
    pub const m_bPassWhenTrue: usize = 0x20; // bool
}

pub mod CompMatPropertyMutator_t {
    pub const m_bEnabled: usize = 0x0; // bool
    pub const m_nMutatorCommandType: usize = 0x4; // CompMatPropertyMutatorType_t
    pub const m_strInitWith_Container: usize = 0x8; // CUtlString
    pub const m_strCopyProperty_InputContainerSrc: usize = 0x10; // CUtlString
    pub const m_strCopyProperty_InputContainerProperty: usize = 0x18; // CUtlString
    pub const m_strCopyProperty_TargetProperty: usize = 0x20; // CUtlString
    pub const m_strRandomRollInputVars_SeedInputVar: usize = 0x28; // CUtlString
    pub const m_vecRandomRollInputVars_InputVarsToRoll: usize = 0x30; // CUtlVector<CUtlString>
    pub const m_strCopyMatchingKeys_InputContainerSrc: usize = 0x48; // CUtlString
    pub const m_strCopyKeysWithSuffix_InputContainerSrc: usize = 0x50; // CUtlString
    pub const m_strCopyKeysWithSuffix_FindSuffix: usize = 0x58; // CUtlString
    pub const m_strCopyKeysWithSuffix_ReplaceSuffix: usize = 0x60; // CUtlString
    pub const m_nSetValue_Value: usize = 0x68; // CompositeMaterialInputLooseVariable_t
    pub const m_strGenerateTexture_TargetParam: usize = 0x2D8; // CUtlString
    pub const m_strGenerateTexture_InitialContainer: usize = 0x2E0; // CUtlString
    pub const m_nResolution: usize = 0x2E8; // int32_t
    pub const m_bIsScratchTarget: usize = 0x2EC; // bool
    pub const m_bSplatDebugInfo: usize = 0x2ED; // bool
    pub const m_bCaptureInRenderDoc: usize = 0x2EE; // bool
    pub const m_vecTexGenInstructions: usize = 0x2F0; // CUtlVector<CompMatPropertyMutator_t>
    pub const m_vecConditionalMutators: usize = 0x308; // CUtlVector<CompMatPropertyMutator_t>
    pub const m_strPopInputQueue_Container: usize = 0x320; // CUtlString
    pub const m_strDrawText_InputContainerSrc: usize = 0x328; // CUtlString
    pub const m_strDrawText_InputContainerProperty: usize = 0x330; // CUtlString
    pub const m_vecDrawText_Position: usize = 0x338; // Vector2D
    pub const m_colDrawText_Color: usize = 0x340; // Color
    pub const m_strDrawText_Font: usize = 0x348; // CUtlString
    pub const m_vecConditions: usize = 0x350; // CUtlVector<CompMatMutatorCondition_t>
}

pub mod CompositeMaterialAssemblyProcedure_t {
    pub const m_vecCompMatIncludes: usize = 0x0; // CUtlVector<CResourceName>
    pub const m_vecMatchFilters: usize = 0x18; // CUtlVector<CompositeMaterialMatchFilter_t>
    pub const m_vecCompositeInputContainers: usize = 0x30; // CUtlVector<CompositeMaterialInputContainer_t>
    pub const m_vecPropertyMutators: usize = 0x48; // CUtlVector<CompMatPropertyMutator_t>
}

pub mod CompositeMaterialEditorPoint_t {
    pub const m_ModelName: usize = 0x0; // CResourceName
    pub const m_nSequenceIndex: usize = 0xE0; // int32_t
    pub const m_flCycle: usize = 0xE4; // float
    pub const m_KVModelStateChoices: usize = 0xE8; // KeyValues3
    pub const m_bEnableChildModel: usize = 0xF8; // bool
    pub const m_ChildModelName: usize = 0x100; // CResourceName
    pub const m_vecCompositeMaterialAssemblyProcedures: usize = 0x1E0; // CUtlVector<CompositeMaterialAssemblyProcedure_t>
    pub const m_vecCompositeMaterials: usize = 0x1F8; // CUtlVector<CompositeMaterial_t>
}

pub mod CompositeMaterialInputContainer_t {
    pub const m_bEnabled: usize = 0x0; // bool
    pub const m_nCompositeMaterialInputContainerSourceType: usize = 0x4; // CompositeMaterialInputContainerSourceType_t
    pub const m_strSpecificContainerMaterial: usize = 0x8; // CResourceName
    pub const m_strAttrName: usize = 0xE8; // CUtlString
    pub const m_strAlias: usize = 0xF0; // CUtlString
    pub const m_vecLooseVariables: usize = 0xF8; // CUtlVector<CompositeMaterialInputLooseVariable_t>
    pub const m_strAttrNameForVar: usize = 0x110; // CUtlString
    pub const m_bExposeExternally: usize = 0x118; // bool
}

pub mod CompositeMaterialInputLooseVariable_t {
    pub const m_strName: usize = 0x0; // CUtlString
    pub const m_bExposeExternally: usize = 0x8; // bool
    pub const m_strExposedFriendlyName: usize = 0x10; // CUtlString
    pub const m_strExposedFriendlyGroupName: usize = 0x18; // CUtlString
    pub const m_bExposedVariableIsFixedRange: usize = 0x20; // bool
    pub const m_strExposedVisibleWhenTrue: usize = 0x28; // CUtlString
    pub const m_strExposedHiddenWhenTrue: usize = 0x30; // CUtlString
    pub const m_nVariableType: usize = 0x38; // CompositeMaterialInputLooseVariableType_t
    pub const m_bValueBoolean: usize = 0x3C; // bool
    pub const m_nValueIntX: usize = 0x40; // int32_t
    pub const m_nValueIntY: usize = 0x44; // int32_t
    pub const m_nValueIntZ: usize = 0x48; // int32_t
    pub const m_nValueIntW: usize = 0x4C; // int32_t
    pub const m_bHasFloatBounds: usize = 0x50; // bool
    pub const m_flValueFloatX: usize = 0x54; // float
    pub const m_flValueFloatX_Min: usize = 0x58; // float
    pub const m_flValueFloatX_Max: usize = 0x5C; // float
    pub const m_flValueFloatY: usize = 0x60; // float
    pub const m_flValueFloatY_Min: usize = 0x64; // float
    pub const m_flValueFloatY_Max: usize = 0x68; // float
    pub const m_flValueFloatZ: usize = 0x6C; // float
    pub const m_flValueFloatZ_Min: usize = 0x70; // float
    pub const m_flValueFloatZ_Max: usize = 0x74; // float
    pub const m_flValueFloatW: usize = 0x78; // float
    pub const m_flValueFloatW_Min: usize = 0x7C; // float
    pub const m_flValueFloatW_Max: usize = 0x80; // float
    pub const m_cValueColor4: usize = 0x84; // Color
    pub const m_nValueSystemVar: usize = 0x88; // CompositeMaterialVarSystemVar_t
    pub const m_strResourceMaterial: usize = 0x90; // CResourceName
    pub const m_strTextureContentAssetPath: usize = 0x170; // CUtlString
    pub const m_strTextureRuntimeResourcePath: usize = 0x178; // CResourceName
    pub const m_strTextureCompilationVtexTemplate: usize = 0x258; // CUtlString
    pub const m_nTextureType: usize = 0x260; // CompositeMaterialInputTextureType_t
    pub const m_strString: usize = 0x268; // CUtlString
}

pub mod CompositeMaterialMatchFilter_t {
    pub const m_nCompositeMaterialMatchFilterType: usize = 0x0; // CompositeMaterialMatchFilterType_t
    pub const m_strMatchFilter: usize = 0x8; // CUtlString
    pub const m_strMatchValue: usize = 0x10; // CUtlString
    pub const m_bPassWhenTrue: usize = 0x18; // bool
}

pub mod CompositeMaterial_t {
    pub const m_TargetKVs: usize = 0x8; // KeyValues3
    pub const m_PreGenerationKVs: usize = 0x18; // KeyValues3
    pub const m_FinalKVs: usize = 0x28; // KeyValues3
    pub const m_vecGeneratedTextures: usize = 0x40; // CUtlVector<GeneratedTextureHandle_t>
}

pub mod CountdownTimer {
    pub const m_duration: usize = 0x8; // float
    pub const m_timestamp: usize = 0xC; // GameTime_t
    pub const m_timescale: usize = 0x10; // float
    pub const m_nWorldGroupId: usize = 0x14; // WorldGroupId_t
}

pub mod EngineCountdownTimer {
    pub const m_duration: usize = 0x8; // float
    pub const m_timestamp: usize = 0xC; // float
    pub const m_timescale: usize = 0x10; // float
}

pub mod EntityRenderAttribute_t {
    pub const m_ID: usize = 0x30; // CUtlStringToken
    pub const m_Values: usize = 0x34; // Vector4D
}

pub mod EntitySpottedState_t {
    pub const m_bSpotted: usize = 0x8; // bool
    pub const m_bSpottedByMask: usize = 0xC; // uint32_t[2]
}

pub mod GeneratedTextureHandle_t {
    pub const m_strBitmapName: usize = 0x0; // CUtlString
}

pub mod IntervalTimer {
    pub const m_timestamp: usize = 0x8; // GameTime_t
    pub const m_nWorldGroupId: usize = 0xC; // WorldGroupId_t
}

pub mod PhysicsRagdollPose_t {
    pub const __m_pChainEntity: usize = 0x8; // CNetworkVarChainer
    pub const m_Transforms: usize = 0x30; // C_NetworkUtlVectorBase<CTransform>
    pub const m_hOwner: usize = 0x48; // CHandle<C_BaseEntity>
    pub const m_bDirty: usize = 0x68; // bool
}

pub mod SellbackPurchaseEntry_t {
    pub const m_unDefIdx: usize = 0x30; // uint16_t
    pub const m_nCost: usize = 0x34; // int32_t
    pub const m_nPrevArmor: usize = 0x38; // int32_t
    pub const m_bPrevHelmet: usize = 0x3C; // bool
    pub const m_hItem: usize = 0x40; // CEntityHandle
}

pub mod ServerAuthoritativeWeaponSlot_t {
    pub const unClass: usize = 0x28; // uint16_t
    pub const unSlot: usize = 0x2A; // uint16_t
    pub const unItemDefIdx: usize = 0x2C; // uint16_t
}

pub mod TimedEvent {
    pub const m_TimeBetweenEvents: usize = 0x0; // float
    pub const m_fNextEvent: usize = 0x4; // float
}

pub mod VPhysicsCollisionAttribute_t {
    pub const m_nInteractsAs: usize = 0x8; // uint64_t
    pub const m_nInteractsWith: usize = 0x10; // uint64_t
    pub const m_nInteractsExclude: usize = 0x18; // uint64_t
    pub const m_nEntityId: usize = 0x20; // uint32_t
    pub const m_nOwnerId: usize = 0x24; // uint32_t
    pub const m_nHierarchyId: usize = 0x28; // uint16_t
    pub const m_nCollisionGroup: usize = 0x2A; // uint8_t
    pub const m_nCollisionFunctionMask: usize = 0x2B; // uint8_t
}

pub mod ViewAngleServerChange_t {
    pub const nType: usize = 0x30; // FixAngleSet_t
    pub const qAngle: usize = 0x34; // QAngle
    pub const nIndex: usize = 0x40; // uint32_t
}

pub mod WeaponPurchaseCount_t {
    pub const m_nItemDefIndex: usize = 0x30; // uint16_t
    pub const m_nCount: usize = 0x32; // uint16_t
}

pub mod WeaponPurchaseTracker_t {
    pub const m_weaponPurchases: usize = 0x8; // C_UtlVectorEmbeddedNetworkVar<WeaponPurchaseCount_t>
}

pub mod audioparams_t {
    pub const localSound: usize = 0x8; // Vector[8]
    pub const soundscapeIndex: usize = 0x68; // int32_t
    pub const localBits: usize = 0x6C; // uint8_t
    pub const soundscapeEntityListIndex: usize = 0x70; // int32_t
    pub const soundEventHash: usize = 0x74; // uint32_t
}

pub mod fogparams_t {
    pub const dirPrimary: usize = 0x8; // Vector
    pub const colorPrimary: usize = 0x14; // Color
    pub const colorSecondary: usize = 0x18; // Color
    pub const colorPrimaryLerpTo: usize = 0x1C; // Color
    pub const colorSecondaryLerpTo: usize = 0x20; // Color
    pub const start: usize = 0x24; // float
    pub const end: usize = 0x28; // float
    pub const farz: usize = 0x2C; // float
    pub const maxdensity: usize = 0x30; // float
    pub const exponent: usize = 0x34; // float
    pub const HDRColorScale: usize = 0x38; // float
    pub const skyboxFogFactor: usize = 0x3C; // float
    pub const skyboxFogFactorLerpTo: usize = 0x40; // float
    pub const startLerpTo: usize = 0x44; // float
    pub const endLerpTo: usize = 0x48; // float
    pub const maxdensityLerpTo: usize = 0x4C; // float
    pub const lerptime: usize = 0x50; // GameTime_t
    pub const duration: usize = 0x54; // float
    pub const blendtobackground: usize = 0x58; // float
    pub const scattering: usize = 0x5C; // float
    pub const locallightscale: usize = 0x60; // float
    pub const enable: usize = 0x64; // bool
    pub const blend: usize = 0x65; // bool
    pub const m_bNoReflectionFog: usize = 0x66; // bool
    pub const m_bPadding: usize = 0x67; // bool
}

pub mod shard_model_desc_t {
    pub const m_nModelID: usize = 0x8; // int32_t
    pub const m_hMaterial: usize = 0x10; // CStrongHandle<InfoForResourceTypeIMaterial2>
    pub const m_solid: usize = 0x18; // ShardSolid_t
    pub const m_ShatterPanelMode: usize = 0x19; // ShatterPanelMode
    pub const m_vecPanelSize: usize = 0x1C; // Vector2D
    pub const m_vecStressPositionA: usize = 0x24; // Vector2D
    pub const m_vecStressPositionB: usize = 0x2C; // Vector2D
    pub const m_vecPanelVertices: usize = 0x38; // C_NetworkUtlVectorBase<Vector2D>
    pub const m_flGlassHalfThickness: usize = 0x50; // float
    pub const m_bHasParent: usize = 0x54; // bool
    pub const m_bParentFrozen: usize = 0x55; // bool
    pub const m_SurfacePropStringToken: usize = 0x58; // CUtlStringToken
}

pub mod sky3dparams_t {
    pub const scale: usize = 0x8; // int16_t
    pub const origin: usize = 0xC; // Vector
    pub const bClip3DSkyBoxNearToWorldFar: usize = 0x18; // bool
    pub const flClip3DSkyBoxNearToWorldFarOffset: usize = 0x1C; // float
    pub const fog: usize = 0x20; // fogparams_t
    pub const m_nWorldGroupID: usize = 0x88; // WorldGroupId_t
}
```

`SDK/engine2.dll.cs`:

```cs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.163166 UTC
 */

public static class CEntityComponentHelper {
    public const nint m_flags = 0x8; // uint32_t
    public const nint m_pInfo = 0x10; // EntComponentInfo_t*
    public const nint m_nPriority = 0x18; // int32_t
    public const nint m_pNext = 0x20; // CEntityComponentHelper*
}

public static class CEntityIOOutput {
    public const nint m_Value = 0x18; // CVariantBase<CVariantDefaultAllocator>
}

public static class CEntityIdentity {
    public const nint m_nameStringableIndex = 0x14; // int32_t
    public const nint m_name = 0x18; // CUtlSymbolLarge
    public const nint m_designerName = 0x20; // CUtlSymbolLarge
    public const nint m_flags = 0x30; // uint32_t
    public const nint m_worldGroupId = 0x38; // WorldGroupId_t
    public const nint m_fDataObjectTypes = 0x3C; // uint32_t
    public const nint m_PathIndex = 0x40; // ChangeAccessorFieldPathIndex_t
    public const nint m_pPrev = 0x58; // CEntityIdentity*
    public const nint m_pNext = 0x60; // CEntityIdentity*
    public const nint m_pPrevByClass = 0x68; // CEntityIdentity*
    public const nint m_pNextByClass = 0x70; // CEntityIdentity*
}

public static class CEntityInstance {
    public const nint m_iszPrivateVScripts = 0x8; // CUtlSymbolLarge
    public const nint m_pEntity = 0x10; // CEntityIdentity*
    public const nint m_CScriptComponent = 0x28; // CScriptComponent*
}

public static class CNetworkVarChainer {
    public const nint m_PathIndex = 0x20; // ChangeAccessorFieldPathIndex_t
}

public static class CScriptComponent {
    public const nint m_scriptClassName = 0x30; // CUtlSymbolLarge
}

public static class EngineLoopState_t {
    public const nint m_nPlatWindowWidth = 0x18; // int32_t
    public const nint m_nPlatWindowHeight = 0x1C; // int32_t
    public const nint m_nRenderWidth = 0x20; // int32_t
    public const nint m_nRenderHeight = 0x24; // int32_t
}

public static class EntComponentInfo_t {
    public const nint m_pName = 0x0; // char*
    public const nint m_pCPPClassname = 0x8; // char*
    public const nint m_pNetworkDataReferencedDescription = 0x10; // char*
    public const nint m_pNetworkDataReferencedPtrPropDescription = 0x18; // char*
    public const nint m_nRuntimeIndex = 0x20; // int32_t
    public const nint m_nFlags = 0x24; // uint32_t
    public const nint m_pBaseClassComponentHelper = 0x60; // CEntityComponentHelper*
}

public static class EventAdvanceTick_t {
    public const nint m_nCurrentTick = 0x30; // int32_t
    public const nint m_nCurrentTickThisFrame = 0x34; // int32_t
    public const nint m_nTotalTicksThisFrame = 0x38; // int32_t
    public const nint m_nTotalTicks = 0x3C; // int32_t
}

public static class EventAppShutdown_t {
    public const nint m_nDummy0 = 0x0; // int32_t
}

public static class EventClientFrameSimulate_t {
    public const nint m_LoopState = 0x0; // EngineLoopState_t
    public const nint m_flRealTime = 0x28; // float
    public const nint m_flFrameTime = 0x2C; // float
}

public static class EventClientOutput_t {
    public const nint m_LoopState = 0x0; // EngineLoopState_t
    public const nint m_flRenderTime = 0x28; // float
    public const nint m_flRealTime = 0x2C; // float
    public const nint m_flRenderFrameTimeUnbounded = 0x30; // float
    public const nint m_bRenderOnly = 0x34; // bool
}

public static class EventClientPollInput_t {
    public const nint m_LoopState = 0x0; // EngineLoopState_t
    public const nint m_flRealTime = 0x28; // float
}

public static class EventClientPollNetworking_t {
    public const nint m_nTickCount = 0x0; // int32_t
}

public static class EventClientPostOutput_t {
    public const nint m_LoopState = 0x0; // EngineLoopState_t
    public const nint m_flRenderTime = 0x28; // double
    public const nint m_flRenderFrameTime = 0x30; // float
    public const nint m_flRenderFrameTimeUnbounded = 0x34; // float
    public const nint m_bRenderOnly = 0x38; // bool
}

public static class EventClientPreOutput_t {
    public const nint m_LoopState = 0x0; // EngineLoopState_t
    public const nint m_flRenderTime = 0x28; // double
    public const nint m_flRenderFrameTime = 0x30; // double
    public const nint m_flRenderFrameTimeUnbounded = 0x38; // double
    public const nint m_flRealTime = 0x40; // float
    public const nint m_bRenderOnly = 0x44; // bool
}

public static class EventClientProcessGameInput_t {
    public const nint m_LoopState = 0x0; // EngineLoopState_t
    public const nint m_flRealTime = 0x28; // float
    public const nint m_flFrameTime = 0x2C; // float
}

public static class EventClientProcessInput_t {
    public const nint m_LoopState = 0x0; // EngineLoopState_t
    public const nint m_flRealTime = 0x28; // float
}

public static class EventClientSceneSystemThreadStateChange_t {
    public const nint m_bThreadsActive = 0x0; // bool
}

public static class EventClientSendInput_t {
    public const nint m_bFinalClientCommandTick = 0x0; // bool
    public const nint m_nAdditionalClientCommandsToCreate = 0x4; // int32_t
}

public static class EventFrameBoundary_t {
    public const nint m_flFrameTime = 0x0; // float
}

public static class EventHostTimescaleChanged_t {
    public const nint m_flOldValue = 0x0; // float
    public const nint m_flNewValue = 0x4; // float
}

public static class EventPostAdvanceTick_t {
    public const nint m_nCurrentTick = 0x30; // int32_t
    public const nint m_nCurrentTickThisFrame = 0x34; // int32_t
    public const nint m_nTotalTicksThisFrame = 0x38; // int32_t
    public const nint m_nTotalTicks = 0x3C; // int32_t
}

public static class EventPostDataUpdate_t {
    public const nint m_nCount = 0x0; // int32_t
}

public static class EventPreDataUpdate_t {
    public const nint m_nCount = 0x0; // int32_t
}

public static class EventProfileStorageAvailable_t {
    public const nint m_nSplitScreenSlot = 0x0; // CSplitScreenSlot
}

public static class EventSetTime_t {
    public const nint m_LoopState = 0x0; // EngineLoopState_t
    public const nint m_nClientOutputFrames = 0x28; // int32_t
    public const nint m_flRealTime = 0x30; // double
    public const nint m_flRenderTime = 0x38; // double
    public const nint m_flRenderFrameTime = 0x40; // double
    public const nint m_flRenderFrameTimeUnbounded = 0x48; // double
    public const nint m_flRenderFrameTimeUnscaled = 0x50; // double
    public const nint m_flTickRemainder = 0x58; // double
}

public static class EventSimpleLoopFrameUpdate_t {
    public const nint m_LoopState = 0x0; // EngineLoopState_t
    public const nint m_flRealTime = 0x28; // float
    public const nint m_flFrameTime = 0x2C; // float
}

public static class EventSimulate_t {
    public const nint m_LoopState = 0x0; // EngineLoopState_t
    public const nint m_bFirstTick = 0x28; // bool
    public const nint m_bLastTick = 0x29; // bool
}
```

`SDK/engine2.dll.hpp`:

```hpp
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.158974700 UTC
 */

#pragma once

#include <cstddef>

namespace CEntityComponentHelper {
    constexpr std::ptrdiff_t m_flags = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_pInfo = 0x10; // EntComponentInfo_t*
    constexpr std::ptrdiff_t m_nPriority = 0x18; // int32_t
    constexpr std::ptrdiff_t m_pNext = 0x20; // CEntityComponentHelper*
}

namespace CEntityIOOutput {
    constexpr std::ptrdiff_t m_Value = 0x18; // CVariantBase<CVariantDefaultAllocator>
}

namespace CEntityIdentity {
    constexpr std::ptrdiff_t m_nameStringableIndex = 0x14; // int32_t
    constexpr std::ptrdiff_t m_name = 0x18; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_designerName = 0x20; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flags = 0x30; // uint32_t
    constexpr std::ptrdiff_t m_worldGroupId = 0x38; // WorldGroupId_t
    constexpr std::ptrdiff_t m_fDataObjectTypes = 0x3C; // uint32_t
    constexpr std::ptrdiff_t m_PathIndex = 0x40; // ChangeAccessorFieldPathIndex_t
    constexpr std::ptrdiff_t m_pPrev = 0x58; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pNext = 0x60; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pPrevByClass = 0x68; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pNextByClass = 0x70; // CEntityIdentity*
}

namespace CEntityInstance {
    constexpr std::ptrdiff_t m_iszPrivateVScripts = 0x8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_pEntity = 0x10; // CEntityIdentity*
    constexpr std::ptrdiff_t m_CScriptComponent = 0x28; // CScriptComponent*
}

namespace CNetworkVarChainer {
    constexpr std::ptrdiff_t m_PathIndex = 0x20; // ChangeAccessorFieldPathIndex_t
}

namespace CScriptComponent {
    constexpr std::ptrdiff_t m_scriptClassName = 0x30; // CUtlSymbolLarge
}

namespace EngineLoopState_t {
    constexpr std::ptrdiff_t m_nPlatWindowWidth = 0x18; // int32_t
    constexpr std::ptrdiff_t m_nPlatWindowHeight = 0x1C; // int32_t
    constexpr std::ptrdiff_t m_nRenderWidth = 0x20; // int32_t
    constexpr std::ptrdiff_t m_nRenderHeight = 0x24; // int32_t
}

namespace EntComponentInfo_t {
    constexpr std::ptrdiff_t m_pName = 0x0; // char*
    constexpr std::ptrdiff_t m_pCPPClassname = 0x8; // char*
    constexpr std::ptrdiff_t m_pNetworkDataReferencedDescription = 0x10; // char*
    constexpr std::ptrdiff_t m_pNetworkDataReferencedPtrPropDescription = 0x18; // char*
    constexpr std::ptrdiff_t m_nRuntimeIndex = 0x20; // int32_t
    constexpr std::ptrdiff_t m_nFlags = 0x24; // uint32_t
    constexpr std::ptrdiff_t m_pBaseClassComponentHelper = 0x60; // CEntityComponentHelper*
}

namespace EventAdvanceTick_t {
    constexpr std::ptrdiff_t m_nCurrentTick = 0x30; // int32_t
    constexpr std::ptrdiff_t m_nCurrentTickThisFrame = 0x34; // int32_t
    constexpr std::ptrdiff_t m_nTotalTicksThisFrame = 0x38; // int32_t
    constexpr std::ptrdiff_t m_nTotalTicks = 0x3C; // int32_t
}

namespace EventAppShutdown_t {
    constexpr std::ptrdiff_t m_nDummy0 = 0x0; // int32_t
}

namespace EventClientFrameSimulate_t {
    constexpr std::ptrdiff_t m_LoopState = 0x0; // EngineLoopState_t
    constexpr std::ptrdiff_t m_flRealTime = 0x28; // float
    constexpr std::ptrdiff_t m_flFrameTime = 0x2C; // float
}

namespace EventClientOutput_t {
    constexpr std::ptrdiff_t m_LoopState = 0x0; // EngineLoopState_t
    constexpr std::ptrdiff_t m_flRenderTime = 0x28; // float
    constexpr std::ptrdiff_t m_flRealTime = 0x2C; // float
    constexpr std::ptrdiff_t m_flRenderFrameTimeUnbounded = 0x30; // float
    constexpr std::ptrdiff_t m_bRenderOnly = 0x34; // bool
}

namespace EventClientPollInput_t {
    constexpr std::ptrdiff_t m_LoopState = 0x0; // EngineLoopState_t
    constexpr std::ptrdiff_t m_flRealTime = 0x28; // float
}

namespace EventClientPollNetworking_t {
    constexpr std::ptrdiff_t m_nTickCount = 0x0; // int32_t
}

namespace EventClientPostOutput_t {
    constexpr std::ptrdiff_t m_LoopState = 0x0; // EngineLoopState_t
    constexpr std::ptrdiff_t m_flRenderTime = 0x28; // double
    constexpr std::ptrdiff_t m_flRenderFrameTime = 0x30; // float
    constexpr std::ptrdiff_t m_flRenderFrameTimeUnbounded = 0x34; // float
    constexpr std::ptrdiff_t m_bRenderOnly = 0x38; // bool
}

namespace EventClientPreOutput_t {
    constexpr std::ptrdiff_t m_LoopState = 0x0; // EngineLoopState_t
    constexpr std::ptrdiff_t m_flRenderTime = 0x28; // double
    constexpr std::ptrdiff_t m_flRenderFrameTime = 0x30; // double
    constexpr std::ptrdiff_t m_flRenderFrameTimeUnbounded = 0x38; // double
    constexpr std::ptrdiff_t m_flRealTime = 0x40; // float
    constexpr std::ptrdiff_t m_bRenderOnly = 0x44; // bool
}

namespace EventClientProcessGameInput_t {
    constexpr std::ptrdiff_t m_LoopState = 0x0; // EngineLoopState_t
    constexpr std::ptrdiff_t m_flRealTime = 0x28; // float
    constexpr std::ptrdiff_t m_flFrameTime = 0x2C; // float
}

namespace EventClientProcessInput_t {
    constexpr std::ptrdiff_t m_LoopState = 0x0; // EngineLoopState_t
    constexpr std::ptrdiff_t m_flRealTime = 0x28; // float
}

namespace EventClientSceneSystemThreadStateChange_t {
    constexpr std::ptrdiff_t m_bThreadsActive = 0x0; // bool
}

namespace EventClientSendInput_t {
    constexpr std::ptrdiff_t m_bFinalClientCommandTick = 0x0; // bool
    constexpr std::ptrdiff_t m_nAdditionalClientCommandsToCreate = 0x4; // int32_t
}

namespace EventFrameBoundary_t {
    constexpr std::ptrdiff_t m_flFrameTime = 0x0; // float
}

namespace EventHostTimescaleChanged_t {
    constexpr std::ptrdiff_t m_flOldValue = 0x0; // float
    constexpr std::ptrdiff_t m_flNewValue = 0x4; // float
}

namespace EventPostAdvanceTick_t {
    constexpr std::ptrdiff_t m_nCurrentTick = 0x30; // int32_t
    constexpr std::ptrdiff_t m_nCurrentTickThisFrame = 0x34; // int32_t
    constexpr std::ptrdiff_t m_nTotalTicksThisFrame = 0x38; // int32_t
    constexpr std::ptrdiff_t m_nTotalTicks = 0x3C; // int32_t
}

namespace EventPostDataUpdate_t {
    constexpr std::ptrdiff_t m_nCount = 0x0; // int32_t
}

namespace EventPreDataUpdate_t {
    constexpr std::ptrdiff_t m_nCount = 0x0; // int32_t
}

namespace EventProfileStorageAvailable_t {
    constexpr std::ptrdiff_t m_nSplitScreenSlot = 0x0; // CSplitScreenSlot
}

namespace EventSetTime_t {
    constexpr std::ptrdiff_t m_LoopState = 0x0; // EngineLoopState_t
    constexpr std::ptrdiff_t m_nClientOutputFrames = 0x28; // int32_t
    constexpr std::ptrdiff_t m_flRealTime = 0x30; // double
    constexpr std::ptrdiff_t m_flRenderTime = 0x38; // double
    constexpr std::ptrdiff_t m_flRenderFrameTime = 0x40; // double
    constexpr std::ptrdiff_t m_flRenderFrameTimeUnbounded = 0x48; // double
    constexpr std::ptrdiff_t m_flRenderFrameTimeUnscaled = 0x50; // double
    constexpr std::ptrdiff_t m_flTickRemainder = 0x58; // double
}

namespace EventSimpleLoopFrameUpdate_t {
    constexpr std::ptrdiff_t m_LoopState = 0x0; // EngineLoopState_t
    constexpr std::ptrdiff_t m_flRealTime = 0x28; // float
    constexpr std::ptrdiff_t m_flFrameTime = 0x2C; // float
}

namespace EventSimulate_t {
    constexpr std::ptrdiff_t m_LoopState = 0x0; // EngineLoopState_t
    constexpr std::ptrdiff_t m_bFirstTick = 0x28; // bool
    constexpr std::ptrdiff_t m_bLastTick = 0x29; // bool
}
```

`SDK/engine2.dll.json`:

```json
{
  "CEntityComponentHelper": {
    "m_flags": 8,
    "m_nPriority": 24,
    "m_pInfo": 16,
    "m_pNext": 32
  },
  "CEntityIOOutput": {
    "m_Value": 24
  },
  "CEntityIdentity": {
    "m_PathIndex": 64,
    "m_designerName": 32,
    "m_fDataObjectTypes": 60,
    "m_flags": 48,
    "m_name": 24,
    "m_nameStringableIndex": 20,
    "m_pNext": 96,
    "m_pNextByClass": 112,
    "m_pPrev": 88,
    "m_pPrevByClass": 104,
    "m_worldGroupId": 56
  },
  "CEntityInstance": {
    "m_CScriptComponent": 40,
    "m_iszPrivateVScripts": 8,
    "m_pEntity": 16
  },
  "CNetworkVarChainer": {
    "m_PathIndex": 32
  },
  "CScriptComponent": {
    "m_scriptClassName": 48
  },
  "EngineLoopState_t": {
    "m_nPlatWindowHeight": 28,
    "m_nPlatWindowWidth": 24,
    "m_nRenderHeight": 36,
    "m_nRenderWidth": 32
  },
  "EntComponentInfo_t": {
    "m_nFlags": 36,
    "m_nRuntimeIndex": 32,
    "m_pBaseClassComponentHelper": 96,
    "m_pCPPClassname": 8,
    "m_pName": 0,
    "m_pNetworkDataReferencedDescription": 16,
    "m_pNetworkDataReferencedPtrPropDescription": 24
  },
  "EventAdvanceTick_t": {
    "m_nCurrentTick": 48,
    "m_nCurrentTickThisFrame": 52,
    "m_nTotalTicks": 60,
    "m_nTotalTicksThisFrame": 56
  },
  "EventAppShutdown_t": {
    "m_nDummy0": 0
  },
  "EventClientFrameSimulate_t": {
    "m_LoopState": 0,
    "m_flFrameTime": 44,
    "m_flRealTime": 40
  },
  "EventClientOutput_t": {
    "m_LoopState": 0,
    "m_bRenderOnly": 52,
    "m_flRealTime": 44,
    "m_flRenderFrameTimeUnbounded": 48,
    "m_flRenderTime": 40
  },
  "EventClientPollInput_t": {
    "m_LoopState": 0,
    "m_flRealTime": 40
  },
  "EventClientPollNetworking_t": {
    "m_nTickCount": 0
  },
  "EventClientPostOutput_t": {
    "m_LoopState": 0,
    "m_bRenderOnly": 56,
    "m_flRenderFrameTime": 48,
    "m_flRenderFrameTimeUnbounded": 52,
    "m_flRenderTime": 40
  },
  "EventClientPreOutput_t": {
    "m_LoopState": 0,
    "m_bRenderOnly": 68,
    "m_flRealTime": 64,
    "m_flRenderFrameTime": 48,
    "m_flRenderFrameTimeUnbounded": 56,
    "m_flRenderTime": 40
  },
  "EventClientProcessGameInput_t": {
    "m_LoopState": 0,
    "m_flFrameTime": 44,
    "m_flRealTime": 40
  },
  "EventClientProcessInput_t": {
    "m_LoopState": 0,
    "m_flRealTime": 40
  },
  "EventClientSceneSystemThreadStateChange_t": {
    "m_bThreadsActive": 0
  },
  "EventClientSendInput_t": {
    "m_bFinalClientCommandTick": 0,
    "m_nAdditionalClientCommandsToCreate": 4
  },
  "EventFrameBoundary_t": {
    "m_flFrameTime": 0
  },
  "EventHostTimescaleChanged_t": {
    "m_flNewValue": 4,
    "m_flOldValue": 0
  },
  "EventPostAdvanceTick_t": {
    "m_nCurrentTick": 48,
    "m_nCurrentTickThisFrame": 52,
    "m_nTotalTicks": 60,
    "m_nTotalTicksThisFrame": 56
  },
  "EventPostDataUpdate_t": {
    "m_nCount": 0
  },
  "EventPreDataUpdate_t": {
    "m_nCount": 0
  },
  "EventProfileStorageAvailable_t": {
    "m_nSplitScreenSlot": 0
  },
  "EventSetTime_t": {
    "m_LoopState": 0,
    "m_flRealTime": 48,
    "m_flRenderFrameTime": 64,
    "m_flRenderFrameTimeUnbounded": 72,
    "m_flRenderFrameTimeUnscaled": 80,
    "m_flRenderTime": 56,
    "m_flTickRemainder": 88,
    "m_nClientOutputFrames": 40
  },
  "EventSimpleLoopFrameUpdate_t": {
    "m_LoopState": 0,
    "m_flFrameTime": 44,
    "m_flRealTime": 40
  },
  "EventSimulate_t": {
    "m_LoopState": 0,
    "m_bFirstTick": 40,
    "m_bLastTick": 41
  }
}
```

`SDK/engine2.dll.py`:

```py
'''
https://github.com/a2x/cs2-dumper
2023-11-23 10:28:25.166990700 UTC
'''

class CEntityComponentHelper:
    m_flags = 0x8 # uint32_t
    m_pInfo = 0x10 # EntComponentInfo_t*
    m_nPriority = 0x18 # int32_t
    m_pNext = 0x20 # CEntityComponentHelper*

class CEntityIOOutput:
    m_Value = 0x18 # CVariantBase<CVariantDefaultAllocator>

class CEntityIdentity:
    m_nameStringableIndex = 0x14 # int32_t
    m_name = 0x18 # CUtlSymbolLarge
    m_designerName = 0x20 # CUtlSymbolLarge
    m_flags = 0x30 # uint32_t
    m_worldGroupId = 0x38 # WorldGroupId_t
    m_fDataObjectTypes = 0x3C # uint32_t
    m_PathIndex = 0x40 # ChangeAccessorFieldPathIndex_t
    m_pPrev = 0x58 # CEntityIdentity*
    m_pNext = 0x60 # CEntityIdentity*
    m_pPrevByClass = 0x68 # CEntityIdentity*
    m_pNextByClass = 0x70 # CEntityIdentity*

class CEntityInstance:
    m_iszPrivateVScripts = 0x8 # CUtlSymbolLarge
    m_pEntity = 0x10 # CEntityIdentity*
    m_CScriptComponent = 0x28 # CScriptComponent*

class CNetworkVarChainer:
    m_PathIndex = 0x20 # ChangeAccessorFieldPathIndex_t

class CScriptComponent:
    m_scriptClassName = 0x30 # CUtlSymbolLarge

class EngineLoopState_t:
    m_nPlatWindowWidth = 0x18 # int32_t
    m_nPlatWindowHeight = 0x1C # int32_t
    m_nRenderWidth = 0x20 # int32_t
    m_nRenderHeight = 0x24 # int32_t

class EntComponentInfo_t:
    m_pName = 0x0 # char*
    m_pCPPClassname = 0x8 # char*
    m_pNetworkDataReferencedDescription = 0x10 # char*
    m_pNetworkDataReferencedPtrPropDescription = 0x18 # char*
    m_nRuntimeIndex = 0x20 # int32_t
    m_nFlags = 0x24 # uint32_t
    m_pBaseClassComponentHelper = 0x60 # CEntityComponentHelper*

class EventAdvanceTick_t:
    m_nCurrentTick = 0x30 # int32_t
    m_nCurrentTickThisFrame = 0x34 # int32_t
    m_nTotalTicksThisFrame = 0x38 # int32_t
    m_nTotalTicks = 0x3C # int32_t

class EventAppShutdown_t:
    m_nDummy0 = 0x0 # int32_t

class EventClientFrameSimulate_t:
    m_LoopState = 0x0 # EngineLoopState_t
    m_flRealTime = 0x28 # float
    m_flFrameTime = 0x2C # float

class EventClientOutput_t:
    m_LoopState = 0x0 # EngineLoopState_t
    m_flRenderTime = 0x28 # float
    m_flRealTime = 0x2C # float
    m_flRenderFrameTimeUnbounded = 0x30 # float
    m_bRenderOnly = 0x34 # bool

class EventClientPollInput_t:
    m_LoopState = 0x0 # EngineLoopState_t
    m_flRealTime = 0x28 # float

class EventClientPollNetworking_t:
    m_nTickCount = 0x0 # int32_t

class EventClientPostOutput_t:
    m_LoopState = 0x0 # EngineLoopState_t
    m_flRenderTime = 0x28 # double
    m_flRenderFrameTime = 0x30 # float
    m_flRenderFrameTimeUnbounded = 0x34 # float
    m_bRenderOnly = 0x38 # bool

class EventClientPreOutput_t:
    m_LoopState = 0x0 # EngineLoopState_t
    m_flRenderTime = 0x28 # double
    m_flRenderFrameTime = 0x30 # double
    m_flRenderFrameTimeUnbounded = 0x38 # double
    m_flRealTime = 0x40 # float
    m_bRenderOnly = 0x44 # bool

class EventClientProcessGameInput_t:
    m_LoopState = 0x0 # EngineLoopState_t
    m_flRealTime = 0x28 # float
    m_flFrameTime = 0x2C # float

class EventClientProcessInput_t:
    m_LoopState = 0x0 # EngineLoopState_t
    m_flRealTime = 0x28 # float

class EventClientSceneSystemThreadStateChange_t:
    m_bThreadsActive = 0x0 # bool

class EventClientSendInput_t:
    m_bFinalClientCommandTick = 0x0 # bool
    m_nAdditionalClientCommandsToCreate = 0x4 # int32_t

class EventFrameBoundary_t:
    m_flFrameTime = 0x0 # float

class EventHostTimescaleChanged_t:
    m_flOldValue = 0x0 # float
    m_flNewValue = 0x4 # float

class EventPostAdvanceTick_t:
    m_nCurrentTick = 0x30 # int32_t
    m_nCurrentTickThisFrame = 0x34 # int32_t
    m_nTotalTicksThisFrame = 0x38 # int32_t
    m_nTotalTicks = 0x3C # int32_t

class EventPostDataUpdate_t:
    m_nCount = 0x0 # int32_t

class EventPreDataUpdate_t:
    m_nCount = 0x0 # int32_t

class EventProfileStorageAvailable_t:
    m_nSplitScreenSlot = 0x0 # CSplitScreenSlot

class EventSetTime_t:
    m_LoopState = 0x0 # EngineLoopState_t
    m_nClientOutputFrames = 0x28 # int32_t
    m_flRealTime = 0x30 # double
    m_flRenderTime = 0x38 # double
    m_flRenderFrameTime = 0x40 # double
    m_flRenderFrameTimeUnbounded = 0x48 # double
    m_flRenderFrameTimeUnscaled = 0x50 # double
    m_flTickRemainder = 0x58 # double

class EventSimpleLoopFrameUpdate_t:
    m_LoopState = 0x0 # EngineLoopState_t
    m_flRealTime = 0x28 # float
    m_flFrameTime = 0x2C # float

class EventSimulate_t:
    m_LoopState = 0x0 # EngineLoopState_t
    m_bFirstTick = 0x28 # bool
    m_bLastTick = 0x29 # bool

```

`SDK/engine2.dll.rs`:

```rs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.171412900 UTC
 */

#![allow(non_snake_case, non_upper_case_globals)]

pub mod CEntityComponentHelper {
    pub const m_flags: usize = 0x8; // uint32_t
    pub const m_pInfo: usize = 0x10; // EntComponentInfo_t*
    pub const m_nPriority: usize = 0x18; // int32_t
    pub const m_pNext: usize = 0x20; // CEntityComponentHelper*
}

pub mod CEntityIOOutput {
    pub const m_Value: usize = 0x18; // CVariantBase<CVariantDefaultAllocator>
}

pub mod CEntityIdentity {
    pub const m_nameStringableIndex: usize = 0x14; // int32_t
    pub const m_name: usize = 0x18; // CUtlSymbolLarge
    pub const m_designerName: usize = 0x20; // CUtlSymbolLarge
    pub const m_flags: usize = 0x30; // uint32_t
    pub const m_worldGroupId: usize = 0x38; // WorldGroupId_t
    pub const m_fDataObjectTypes: usize = 0x3C; // uint32_t
    pub const m_PathIndex: usize = 0x40; // ChangeAccessorFieldPathIndex_t
    pub const m_pPrev: usize = 0x58; // CEntityIdentity*
    pub const m_pNext: usize = 0x60; // CEntityIdentity*
    pub const m_pPrevByClass: usize = 0x68; // CEntityIdentity*
    pub const m_pNextByClass: usize = 0x70; // CEntityIdentity*
}

pub mod CEntityInstance {
    pub const m_iszPrivateVScripts: usize = 0x8; // CUtlSymbolLarge
    pub const m_pEntity: usize = 0x10; // CEntityIdentity*
    pub const m_CScriptComponent: usize = 0x28; // CScriptComponent*
}

pub mod CNetworkVarChainer {
    pub const m_PathIndex: usize = 0x20; // ChangeAccessorFieldPathIndex_t
}

pub mod CScriptComponent {
    pub const m_scriptClassName: usize = 0x30; // CUtlSymbolLarge
}

pub mod EngineLoopState_t {
    pub const m_nPlatWindowWidth: usize = 0x18; // int32_t
    pub const m_nPlatWindowHeight: usize = 0x1C; // int32_t
    pub const m_nRenderWidth: usize = 0x20; // int32_t
    pub const m_nRenderHeight: usize = 0x24; // int32_t
}

pub mod EntComponentInfo_t {
    pub const m_pName: usize = 0x0; // char*
    pub const m_pCPPClassname: usize = 0x8; // char*
    pub const m_pNetworkDataReferencedDescription: usize = 0x10; // char*
    pub const m_pNetworkDataReferencedPtrPropDescription: usize = 0x18; // char*
    pub const m_nRuntimeIndex: usize = 0x20; // int32_t
    pub const m_nFlags: usize = 0x24; // uint32_t
    pub const m_pBaseClassComponentHelper: usize = 0x60; // CEntityComponentHelper*
}

pub mod EventAdvanceTick_t {
    pub const m_nCurrentTick: usize = 0x30; // int32_t
    pub const m_nCurrentTickThisFrame: usize = 0x34; // int32_t
    pub const m_nTotalTicksThisFrame: usize = 0x38; // int32_t
    pub const m_nTotalTicks: usize = 0x3C; // int32_t
}

pub mod EventAppShutdown_t {
    pub const m_nDummy0: usize = 0x0; // int32_t
}

pub mod EventClientFrameSimulate_t {
    pub const m_LoopState: usize = 0x0; // EngineLoopState_t
    pub const m_flRealTime: usize = 0x28; // float
    pub const m_flFrameTime: usize = 0x2C; // float
}

pub mod EventClientOutput_t {
    pub const m_LoopState: usize = 0x0; // EngineLoopState_t
    pub const m_flRenderTime: usize = 0x28; // float
    pub const m_flRealTime: usize = 0x2C; // float
    pub const m_flRenderFrameTimeUnbounded: usize = 0x30; // float
    pub const m_bRenderOnly: usize = 0x34; // bool
}

pub mod EventClientPollInput_t {
    pub const m_LoopState: usize = 0x0; // EngineLoopState_t
    pub const m_flRealTime: usize = 0x28; // float
}

pub mod EventClientPollNetworking_t {
    pub const m_nTickCount: usize = 0x0; // int32_t
}

pub mod EventClientPostOutput_t {
    pub const m_LoopState: usize = 0x0; // EngineLoopState_t
    pub const m_flRenderTime: usize = 0x28; // double
    pub const m_flRenderFrameTime: usize = 0x30; // float
    pub const m_flRenderFrameTimeUnbounded: usize = 0x34; // float
    pub const m_bRenderOnly: usize = 0x38; // bool
}

pub mod EventClientPreOutput_t {
    pub const m_LoopState: usize = 0x0; // EngineLoopState_t
    pub const m_flRenderTime: usize = 0x28; // double
    pub const m_flRenderFrameTime: usize = 0x30; // double
    pub const m_flRenderFrameTimeUnbounded: usize = 0x38; // double
    pub const m_flRealTime: usize = 0x40; // float
    pub const m_bRenderOnly: usize = 0x44; // bool
}

pub mod EventClientProcessGameInput_t {
    pub const m_LoopState: usize = 0x0; // EngineLoopState_t
    pub const m_flRealTime: usize = 0x28; // float
    pub const m_flFrameTime: usize = 0x2C; // float
}

pub mod EventClientProcessInput_t {
    pub const m_LoopState: usize = 0x0; // EngineLoopState_t
    pub const m_flRealTime: usize = 0x28; // float
}

pub mod EventClientSceneSystemThreadStateChange_t {
    pub const m_bThreadsActive: usize = 0x0; // bool
}

pub mod EventClientSendInput_t {
    pub const m_bFinalClientCommandTick: usize = 0x0; // bool
    pub const m_nAdditionalClientCommandsToCreate: usize = 0x4; // int32_t
}

pub mod EventFrameBoundary_t {
    pub const m_flFrameTime: usize = 0x0; // float
}

pub mod EventHostTimescaleChanged_t {
    pub const m_flOldValue: usize = 0x0; // float
    pub const m_flNewValue: usize = 0x4; // float
}

pub mod EventPostAdvanceTick_t {
    pub const m_nCurrentTick: usize = 0x30; // int32_t
    pub const m_nCurrentTickThisFrame: usize = 0x34; // int32_t
    pub const m_nTotalTicksThisFrame: usize = 0x38; // int32_t
    pub const m_nTotalTicks: usize = 0x3C; // int32_t
}

pub mod EventPostDataUpdate_t {
    pub const m_nCount: usize = 0x0; // int32_t
}

pub mod EventPreDataUpdate_t {
    pub const m_nCount: usize = 0x0; // int32_t
}

pub mod EventProfileStorageAvailable_t {
    pub const m_nSplitScreenSlot: usize = 0x0; // CSplitScreenSlot
}

pub mod EventSetTime_t {
    pub const m_LoopState: usize = 0x0; // EngineLoopState_t
    pub const m_nClientOutputFrames: usize = 0x28; // int32_t
    pub const m_flRealTime: usize = 0x30; // double
    pub const m_flRenderTime: usize = 0x38; // double
    pub const m_flRenderFrameTime: usize = 0x40; // double
    pub const m_flRenderFrameTimeUnbounded: usize = 0x48; // double
    pub const m_flRenderFrameTimeUnscaled: usize = 0x50; // double
    pub const m_flTickRemainder: usize = 0x58; // double
}

pub mod EventSimpleLoopFrameUpdate_t {
    pub const m_LoopState: usize = 0x0; // EngineLoopState_t
    pub const m_flRealTime: usize = 0x28; // float
    pub const m_flFrameTime: usize = 0x2C; // float
}

pub mod EventSimulate_t {
    pub const m_LoopState: usize = 0x0; // EngineLoopState_t
    pub const m_bFirstTick: usize = 0x28; // bool
    pub const m_bLastTick: usize = 0x29; // bool
}
```

`SDK/host.dll.cs`:

```cs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:27.397761 UTC
 */

public static class CAnimScriptBase {
    public const nint m_bIsValid = 0x8; // bool
}

public static class EmptyTestScript {
    public const nint m_hTest = 0x10; // CAnimScriptParam<float>
}
```

`SDK/host.dll.hpp`:

```hpp
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:27.397047400 UTC
 */

#pragma once

#include <cstddef>

namespace CAnimScriptBase {
    constexpr std::ptrdiff_t m_bIsValid = 0x8; // bool
}

namespace EmptyTestScript {
    constexpr std::ptrdiff_t m_hTest = 0x10; // CAnimScriptParam<float>
}
```

`SDK/host.dll.json`:

```json
{
  "CAnimScriptBase": {
    "m_bIsValid": 8
  },
  "EmptyTestScript": {
    "m_hTest": 16
  }
}
```

`SDK/host.dll.py`:

```py
'''
https://github.com/a2x/cs2-dumper
2023-11-23 10:28:27.398723800 UTC
'''

class CAnimScriptBase:
    m_bIsValid = 0x8 # bool

class EmptyTestScript:
    m_hTest = 0x10 # CAnimScriptParam<float>

```

`SDK/host.dll.rs`:

```rs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:27.399399500 UTC
 */

#![allow(non_snake_case, non_upper_case_globals)]

pub mod CAnimScriptBase {
    pub const m_bIsValid: usize = 0x8; // bool
}

pub mod EmptyTestScript {
    pub const m_hTest: usize = 0x10; // CAnimScriptParam<float>
}
```

`SDK/interfaces.cs`:

```cs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:27.795896700 UTC
 */

public static class AnimationsystemDll {
    public const nint AnimationSystemUtils_001 = 0x64670;
    public const nint AnimationSystem_001 = 0x5F1D0;
}

public static class ClientDll {
    public const nint LegacyGameUI001 = 0x89C960;
    public const nint Source2ClientUI001 = 0x88B670;
    public const nint Source2ClientPrediction001 = 0x7A3990;
    public const nint ClientToolsInfo_001 = 0x72F780;
    public const nint Source2Client002 = 0x72F7A0;
    public const nint GameClientExports001 = 0x72F790;
    public const nint EmptyWorldService001_Client = 0x48FD90;
    public const nint Source2ClientConfig001 = 0x476CD0;
}

public static class Engine2Dll {
    public const nint SimpleEngineLoopService_001 = 0x1E4700;
    public const nint ClientServerEngineLoopService_001 = 0x1DA350;
    public const nint KeyValueCache001 = 0x1D6990;
    public const nint HostStateMgr001 = 0x1D4190;
    public const nint GameEventSystemServerV001 = 0x1CF830;
    public const nint GameEventSystemClientV001 = 0x1CF820;
    public const nint EngineServiceMgr001 = 0x1CB510;
    public const nint VProfService_001 = 0x1B8E80;
    public const nint ToolService_001 = 0x1B7BD0;
    public const nint StatsService_001 = 0x1B2E50;
    public const nint SplitScreenService_001 = 0x1B00C0;
    public const nint SoundService_001 = 0x1AAC00;
    public const nint ScreenshotService001 = 0x1A6AD0;
    public const nint RenderService_001 = 0x1A3E30;
    public const nint NetworkService_001 = 0x1A3940;
    public const nint NetworkServerService_001 = 0x19E7F0;
    public const nint NetworkP2PService_001 = 0x19A2E0;
    public const nint NetworkClientService_001 = 0x193F70;
    public const nint MapListService_001 = 0x18CF40;
    public const nint InputService_001 = 0x17ABB0;
    public const nint GameUIService_001 = 0x1753D0;
    public const nint GameResourceServiceServerV001 = 0x173130;
    public const nint GameResourceServiceClientV001 = 0x173120;
    public const nint BugService001 = 0x16C150;
    public const nint BenchmarkService001 = 0x16A920;
    public const nint VENGINE_GAMEUIFUNCS_VERSION005 = 0x118430;
    public const nint EngineGameUI001 = 0x1177C0;
    public const nint INETSUPPORT_001 = 0xE6E20;
    public const nint Source2EngineToServerStringTable001 = 0xA2410;
    public const nint Source2EngineToServer001 = 0x8B6F0;
    public const nint Source2EngineToClientStringTable001 = 0x841D0;
    public const nint Source2EngineToClient001 = 0x5A990;
}

public static class FilesystemStdioDll {
    public const nint VAsyncFileSystem2_001 = 0x66D30;
    public const nint VFileSystem017 = 0x66D20;
}

public static class HostDll {
    public const nint Source2Host001 = 0x18E10;
    public const nint SinglePlayerSharedMemory001 = 0x18A90;
    public const nint SaveRestoreDataVersion001 = 0x18A80;
    public const nint PredictionDiffManager001 = 0x16E20;
    public const nint HostUtils001 = 0x12550;
    public const nint GameSystem2HostHook = 0x11DA0;
    public const nint GameModelInfo001 = 0x11CC0;
    public const nint DebugDrawQueueManager001 = 0x11710;
}

public static class ImemanagerDll {
    public const nint IMEManager001 = 0xC470;
}

public static class InputsystemDll {
    public const nint InputSystemVersion001 = 0x28D0;
    public const nint InputStackSystemVersion001 = 0x16F0;
}

public static class LocalizeDll {
    public const nint Localize_001 = 0x3830;
}

public static class MatchmakingDll {
    public const nint GameTypes001 = 0x50270;
    public const nint MATCHFRAMEWORK_001 = 0x1012B0;
}

public static class Materialsystem2Dll {
    public const nint MaterialUtils_001 = 0x4DB90;
    public const nint TextLayout_001 = 0x4A2E0;
    public const nint PostProcessingSystem_001 = 0x42A60;
    public const nint FontManager_001 = 0x37900;
    public const nint VMaterialSystem2_001 = 0x25EC0;
}

public static class MeshsystemDll {
    public const nint MeshSystem001 = 0x7270;
}

public static class NavsystemDll {
    public const nint NavSystem001 = 0x76F0;
}

public static class NetworksystemDll {
    public const nint SerializedEntitiesVersion001 = 0xD1EB0;
    public const nint NetworkSystemVersion001 = 0xBC6E0;
    public const nint NetworkMessagesVersion001 = 0x9C6D0;
    public const nint FlattenedSerializersVersion001 = 0x7C440;
}

public static class PanoramaDll {
    public const nint PanoramaUIEngine001 = 0x57EE0;
}

public static class PanoramaTextPangoDll {
    public const nint PanoramaTextServices001 = 0x4CBD0;
}

public static class PanoramauiclientDll {
    public const nint PanoramaUIClient001 = 0x12780;
}

public static class ParticlesDll {
    public const nint ParticleSystemMgr003 = 0x52D20;
}

public static class PulseSystemDll {
    public const nint IPulseSystem_001 = 0x5B30;
}

public static class Rendersystemdx11Dll {
    public const nint RenderUtils_001 = 0x530F0;
    public const nint VRenderDeviceMgrBackdoor001 = 0x4A690;
    public const nint RenderDeviceMgr001 = 0x4A680;
}

public static class ResourcesystemDll {
    public const nint ResourceSystem013 = 0x10650;
}

public static class ScenefilecacheDll {
    public const nint SceneFileCache002 = 0x68E0;
    public const nint ResponseRulesCache001 = 0x3190;
}

public static class ScenesystemDll {
    public const nint SceneUtils_001 = 0x13C9E0;
    public const nint SceneSystem_002 = 0xCAA30;
    public const nint RenderingPipelines_001 = 0x8E8A0;
}

public static class SchemasystemDll {
    public const nint SchemaSystem_001 = 0xA930;
}

public static class ServerDll {
    public const nint NavGameTest001 = 0xA3A970;
    public const nint ServerToolsInfo_001 = 0x83D770;
    public const nint Source2GameClients001 = 0x83D780;
    public const nint Source2GameEntities001 = 0x83D790;
    public const nint Source2Server001 = 0x83D7A0;
    public const nint EmptyWorldService001_Server = 0x591C00;
    public const nint Source2ServerConfig001 = 0x571B30;
    public const nint EntitySubclassUtilsV001 = 0x2D08A0;
    public const nint customnavsystem001 = 0x24D620;
    public const nint Source2GameDirector001 = 0x1453E0;
}

public static class SoundsystemDll {
    public const nint SoundOpSystem001 = 0x1567E0;
    public const nint SoundOpSystemEdit001 = 0x8BBC0;
    public const nint VMixEditTool001 = 0x71740;
    public const nint SoundSystem001 = 0x46540;
}

public static class SteamaudioDll {
    public const nint SteamAudio001 = 0x12EE0;
}

public static class Steamclient64Dll {
    public const nint IVALIDATE001 = 0x84FD80;
    public const nint CLIENTENGINE_INTERFACE_VERSION005 = 0x84BC30;
    public const nint SteamClient021 = 0x6460C0;
    public const nint SteamClient020 = 0x6460B0;
    public const nint SteamClient019 = 0x6460A0;
    public const nint SteamClient018 = 0x646090;
    public const nint SteamClient017 = 0x646080;
    public const nint SteamClient016 = 0x646070;
    public const nint SteamClient015 = 0x646060;
    public const nint SteamClient014 = 0x646050;
    public const nint SteamClient013 = 0x646040;
    public const nint SteamClient012 = 0x646030;
    public const nint SteamClient011 = 0x646020;
    public const nint SteamClient010 = 0x646010;
    public const nint SteamClient009 = 0x646000;
    public const nint SteamClient008 = 0x645FF0;
    public const nint SteamClient007 = 0x645FE0;
    public const nint SteamClient006 = 0x645FD0;
    public const nint p2pvoice002 = 0xD97D0;
    public const nint p2pvoicesingleton002 = 0xD6200;
}

public static class Tier0Dll {
    public const nint VStringTokenSystem001 = 0x18C2B0;
    public const nint TestScriptMgr001 = 0x13F610;
    public const nint VProcessUtils002 = 0x12F790;
    public const nint VEngineCvar007 = 0x61920;
}

public static class V8SystemDll {
    public const nint Source2V8System001 = 0x1670;
}

public static class ValveAviDll {
    public const nint VAvi001 = 0x2F90;
}

public static class ValveWmfDll {
    public const nint VMediaFoundation001 = 0x12D0;
}

public static class Vphysics2Dll {
    public const nint VPhysics2_Handle_Interface_001 = 0x61120;
    public const nint VPhysics2_Interface_001 = 0x5C740;
}

public static class VscriptDll {
    public const nint VScriptManager010 = 0x31DA0;
}

public static class VstdlibS64Dll {
    public const nint IVALIDATE001 = 0x25000;
    public const nint VEngineCvar002 = 0x5760;
}

public static class WorldrendererDll {
    public const nint WorldRendererMgr001 = 0x21650;
}
```

`SDK/interfaces.hpp`:

```hpp
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:27.792287100 UTC
 */

#pragma once

#include <cstddef>

namespace AnimationsystemDll {
    constexpr std::ptrdiff_t AnimationSystemUtils_001 = 0x64670;
    constexpr std::ptrdiff_t AnimationSystem_001 = 0x5F1D0;
}

namespace ClientDll {
    constexpr std::ptrdiff_t LegacyGameUI001 = 0x89C960;
    constexpr std::ptrdiff_t Source2ClientUI001 = 0x88B670;
    constexpr std::ptrdiff_t Source2ClientPrediction001 = 0x7A3990;
    constexpr std::ptrdiff_t ClientToolsInfo_001 = 0x72F780;
    constexpr std::ptrdiff_t Source2Client002 = 0x72F7A0;
    constexpr std::ptrdiff_t GameClientExports001 = 0x72F790;
    constexpr std::ptrdiff_t EmptyWorldService001_Client = 0x48FD90;
    constexpr std::ptrdiff_t Source2ClientConfig001 = 0x476CD0;
}

namespace Engine2Dll {
    constexpr std::ptrdiff_t SimpleEngineLoopService_001 = 0x1E4700;
    constexpr std::ptrdiff_t ClientServerEngineLoopService_001 = 0x1DA350;
    constexpr std::ptrdiff_t KeyValueCache001 = 0x1D6990;
    constexpr std::ptrdiff_t HostStateMgr001 = 0x1D4190;
    constexpr std::ptrdiff_t GameEventSystemServerV001 = 0x1CF830;
    constexpr std::ptrdiff_t GameEventSystemClientV001 = 0x1CF820;
    constexpr std::ptrdiff_t EngineServiceMgr001 = 0x1CB510;
    constexpr std::ptrdiff_t VProfService_001 = 0x1B8E80;
    constexpr std::ptrdiff_t ToolService_001 = 0x1B7BD0;
    constexpr std::ptrdiff_t StatsService_001 = 0x1B2E50;
    constexpr std::ptrdiff_t SplitScreenService_001 = 0x1B00C0;
    constexpr std::ptrdiff_t SoundService_001 = 0x1AAC00;
    constexpr std::ptrdiff_t ScreenshotService001 = 0x1A6AD0;
    constexpr std::ptrdiff_t RenderService_001 = 0x1A3E30;
    constexpr std::ptrdiff_t NetworkService_001 = 0x1A3940;
    constexpr std::ptrdiff_t NetworkServerService_001 = 0x19E7F0;
    constexpr std::ptrdiff_t NetworkP2PService_001 = 0x19A2E0;
    constexpr std::ptrdiff_t NetworkClientService_001 = 0x193F70;
    constexpr std::ptrdiff_t MapListService_001 = 0x18CF40;
    constexpr std::ptrdiff_t InputService_001 = 0x17ABB0;
    constexpr std::ptrdiff_t GameUIService_001 = 0x1753D0;
    constexpr std::ptrdiff_t GameResourceServiceServerV001 = 0x173130;
    constexpr std::ptrdiff_t GameResourceServiceClientV001 = 0x173120;
    constexpr std::ptrdiff_t BugService001 = 0x16C150;
    constexpr std::ptrdiff_t BenchmarkService001 = 0x16A920;
    constexpr std::ptrdiff_t VENGINE_GAMEUIFUNCS_VERSION005 = 0x118430;
    constexpr std::ptrdiff_t EngineGameUI001 = 0x1177C0;
    constexpr std::ptrdiff_t INETSUPPORT_001 = 0xE6E20;
    constexpr std::ptrdiff_t Source2EngineToServerStringTable001 = 0xA2410;
    constexpr std::ptrdiff_t Source2EngineToServer001 = 0x8B6F0;
    constexpr std::ptrdiff_t Source2EngineToClientStringTable001 = 0x841D0;
    constexpr std::ptrdiff_t Source2EngineToClient001 = 0x5A990;
}

namespace FilesystemStdioDll {
    constexpr std::ptrdiff_t VAsyncFileSystem2_001 = 0x66D30;
    constexpr std::ptrdiff_t VFileSystem017 = 0x66D20;
}

namespace HostDll {
    constexpr std::ptrdiff_t Source2Host001 = 0x18E10;
    constexpr std::ptrdiff_t SinglePlayerSharedMemory001 = 0x18A90;
    constexpr std::ptrdiff_t SaveRestoreDataVersion001 = 0x18A80;
    constexpr std::ptrdiff_t PredictionDiffManager001 = 0x16E20;
    constexpr std::ptrdiff_t HostUtils001 = 0x12550;
    constexpr std::ptrdiff_t GameSystem2HostHook = 0x11DA0;
    constexpr std::ptrdiff_t GameModelInfo001 = 0x11CC0;
    constexpr std::ptrdiff_t DebugDrawQueueManager001 = 0x11710;
}

namespace ImemanagerDll {
    constexpr std::ptrdiff_t IMEManager001 = 0xC470;
}

namespace InputsystemDll {
    constexpr std::ptrdiff_t InputSystemVersion001 = 0x28D0;
    constexpr std::ptrdiff_t InputStackSystemVersion001 = 0x16F0;
}

namespace LocalizeDll {
    constexpr std::ptrdiff_t Localize_001 = 0x3830;
}

namespace MatchmakingDll {
    constexpr std::ptrdiff_t GameTypes001 = 0x50270;
    constexpr std::ptrdiff_t MATCHFRAMEWORK_001 = 0x1012B0;
}

namespace Materialsystem2Dll {
    constexpr std::ptrdiff_t MaterialUtils_001 = 0x4DB90;
    constexpr std::ptrdiff_t TextLayout_001 = 0x4A2E0;
    constexpr std::ptrdiff_t PostProcessingSystem_001 = 0x42A60;
    constexpr std::ptrdiff_t FontManager_001 = 0x37900;
    constexpr std::ptrdiff_t VMaterialSystem2_001 = 0x25EC0;
}

namespace MeshsystemDll {
    constexpr std::ptrdiff_t MeshSystem001 = 0x7270;
}

namespace NavsystemDll {
    constexpr std::ptrdiff_t NavSystem001 = 0x76F0;
}

namespace NetworksystemDll {
    constexpr std::ptrdiff_t SerializedEntitiesVersion001 = 0xD1EB0;
    constexpr std::ptrdiff_t NetworkSystemVersion001 = 0xBC6E0;
    constexpr std::ptrdiff_t NetworkMessagesVersion001 = 0x9C6D0;
    constexpr std::ptrdiff_t FlattenedSerializersVersion001 = 0x7C440;
}

namespace PanoramaDll {
    constexpr std::ptrdiff_t PanoramaUIEngine001 = 0x57EE0;
}

namespace PanoramaTextPangoDll {
    constexpr std::ptrdiff_t PanoramaTextServices001 = 0x4CBD0;
}

namespace PanoramauiclientDll {
    constexpr std::ptrdiff_t PanoramaUIClient001 = 0x12780;
}

namespace ParticlesDll {
    constexpr std::ptrdiff_t ParticleSystemMgr003 = 0x52D20;
}

namespace PulseSystemDll {
    constexpr std::ptrdiff_t IPulseSystem_001 = 0x5B30;
}

namespace Rendersystemdx11Dll {
    constexpr std::ptrdiff_t RenderUtils_001 = 0x530F0;
    constexpr std::ptrdiff_t VRenderDeviceMgrBackdoor001 = 0x4A690;
    constexpr std::ptrdiff_t RenderDeviceMgr001 = 0x4A680;
}

namespace ResourcesystemDll {
    constexpr std::ptrdiff_t ResourceSystem013 = 0x10650;
}

namespace ScenefilecacheDll {
    constexpr std::ptrdiff_t SceneFileCache002 = 0x68E0;
    constexpr std::ptrdiff_t ResponseRulesCache001 = 0x3190;
}

namespace ScenesystemDll {
    constexpr std::ptrdiff_t SceneUtils_001 = 0x13C9E0;
    constexpr std::ptrdiff_t SceneSystem_002 = 0xCAA30;
    constexpr std::ptrdiff_t RenderingPipelines_001 = 0x8E8A0;
}

namespace SchemasystemDll {
    constexpr std::ptrdiff_t SchemaSystem_001 = 0xA930;
}

namespace ServerDll {
    constexpr std::ptrdiff_t NavGameTest001 = 0xA3A970;
    constexpr std::ptrdiff_t ServerToolsInfo_001 = 0x83D770;
    constexpr std::ptrdiff_t Source2GameClients001 = 0x83D780;
    constexpr std::ptrdiff_t Source2GameEntities001 = 0x83D790;
    constexpr std::ptrdiff_t Source2Server001 = 0x83D7A0;
    constexpr std::ptrdiff_t EmptyWorldService001_Server = 0x591C00;
    constexpr std::ptrdiff_t Source2ServerConfig001 = 0x571B30;
    constexpr std::ptrdiff_t EntitySubclassUtilsV001 = 0x2D08A0;
    constexpr std::ptrdiff_t customnavsystem001 = 0x24D620;
    constexpr std::ptrdiff_t Source2GameDirector001 = 0x1453E0;
}

namespace SoundsystemDll {
    constexpr std::ptrdiff_t SoundOpSystem001 = 0x1567E0;
    constexpr std::ptrdiff_t SoundOpSystemEdit001 = 0x8BBC0;
    constexpr std::ptrdiff_t VMixEditTool001 = 0x71740;
    constexpr std::ptrdiff_t SoundSystem001 = 0x46540;
}

namespace SteamaudioDll {
    constexpr std::ptrdiff_t SteamAudio001 = 0x12EE0;
}

namespace Steamclient64Dll {
    constexpr std::ptrdiff_t IVALIDATE001 = 0x84FD80;
    constexpr std::ptrdiff_t CLIENTENGINE_INTERFACE_VERSION005 = 0x84BC30;
    constexpr std::ptrdiff_t SteamClient021 = 0x6460C0;
    constexpr std::ptrdiff_t SteamClient020 = 0x6460B0;
    constexpr std::ptrdiff_t SteamClient019 = 0x6460A0;
    constexpr std::ptrdiff_t SteamClient018 = 0x646090;
    constexpr std::ptrdiff_t SteamClient017 = 0x646080;
    constexpr std::ptrdiff_t SteamClient016 = 0x646070;
    constexpr std::ptrdiff_t SteamClient015 = 0x646060;
    constexpr std::ptrdiff_t SteamClient014 = 0x646050;
    constexpr std::ptrdiff_t SteamClient013 = 0x646040;
    constexpr std::ptrdiff_t SteamClient012 = 0x646030;
    constexpr std::ptrdiff_t SteamClient011 = 0x646020;
    constexpr std::ptrdiff_t SteamClient010 = 0x646010;
    constexpr std::ptrdiff_t SteamClient009 = 0x646000;
    constexpr std::ptrdiff_t SteamClient008 = 0x645FF0;
    constexpr std::ptrdiff_t SteamClient007 = 0x645FE0;
    constexpr std::ptrdiff_t SteamClient006 = 0x645FD0;
    constexpr std::ptrdiff_t p2pvoice002 = 0xD97D0;
    constexpr std::ptrdiff_t p2pvoicesingleton002 = 0xD6200;
}

namespace Tier0Dll {
    constexpr std::ptrdiff_t VStringTokenSystem001 = 0x18C2B0;
    constexpr std::ptrdiff_t TestScriptMgr001 = 0x13F610;
    constexpr std::ptrdiff_t VProcessUtils002 = 0x12F790;
    constexpr std::ptrdiff_t VEngineCvar007 = 0x61920;
}

namespace V8SystemDll {
    constexpr std::ptrdiff_t Source2V8System001 = 0x1670;
}

namespace ValveAviDll {
    constexpr std::ptrdiff_t VAvi001 = 0x2F90;
}

namespace ValveWmfDll {
    constexpr std::ptrdiff_t VMediaFoundation001 = 0x12D0;
}

namespace Vphysics2Dll {
    constexpr std::ptrdiff_t VPhysics2_Handle_Interface_001 = 0x61120;
    constexpr std::ptrdiff_t VPhysics2_Interface_001 = 0x5C740;
}

namespace VscriptDll {
    constexpr std::ptrdiff_t VScriptManager010 = 0x31DA0;
}

namespace VstdlibS64Dll {
    constexpr std::ptrdiff_t IVALIDATE001 = 0x25000;
    constexpr std::ptrdiff_t VEngineCvar002 = 0x5760;
}

namespace WorldrendererDll {
    constexpr std::ptrdiff_t WorldRendererMgr001 = 0x21650;
}
```

`SDK/interfaces.json`:

```json
{
  "AnimationsystemDll": {
    "AnimationSystemUtils_001": 411248,
    "AnimationSystem_001": 389584
  },
  "ClientDll": {
    "ClientToolsInfo_001": 7534464,
    "EmptyWorldService001_Client": 4783504,
    "GameClientExports001": 7534480,
    "LegacyGameUI001": 9029984,
    "Source2Client002": 7534496,
    "Source2ClientConfig001": 4680912,
    "Source2ClientPrediction001": 8010128,
    "Source2ClientUI001": 8959600
  },
  "Engine2Dll": {
    "BenchmarkService001": 1485088,
    "BugService001": 1491280,
    "ClientServerEngineLoopService_001": 1942352,
    "EngineGameUI001": 1144768,
    "EngineServiceMgr001": 1881360,
    "GameEventSystemClientV001": 1898528,
    "GameEventSystemServerV001": 1898544,
    "GameResourceServiceClientV001": 1519904,
    "GameResourceServiceServerV001": 1519920,
    "GameUIService_001": 1528784,
    "HostStateMgr001": 1917328,
    "INETSUPPORT_001": 945696,
    "InputService_001": 1551280,
    "KeyValueCache001": 1927568,
    "MapListService_001": 1625920,
    "NetworkClientService_001": 1654640,
    "NetworkP2PService_001": 1680096,
    "NetworkServerService_001": 1697776,
    "NetworkService_001": 1718592,
    "RenderService_001": 1719856,
    "ScreenshotService001": 1731280,
    "SimpleEngineLoopService_001": 1984256,
    "SoundService_001": 1747968,
    "Source2EngineToClient001": 371088,
    "Source2EngineToClientStringTable001": 541136,
    "Source2EngineToServer001": 571120,
    "Source2EngineToServerStringTable001": 664592,
    "SplitScreenService_001": 1769664,
    "StatsService_001": 1781328,
    "ToolService_001": 1801168,
    "VENGINE_GAMEUIFUNCS_VERSION005": 1147952,
    "VProfService_001": 1805952
  },
  "FilesystemStdioDll": {
    "VAsyncFileSystem2_001": 421168,
    "VFileSystem017": 421152
  },
  "HostDll": {
    "DebugDrawQueueManager001": 71440,
    "GameModelInfo001": 72896,
    "GameSystem2HostHook": 73120,
    "HostUtils001": 75088,
    "PredictionDiffManager001": 93728,
    "SaveRestoreDataVersion001": 100992,
    "SinglePlayerSharedMemory001": 101008,
    "Source2Host001": 101904
  },
  "ImemanagerDll": {
    "IMEManager001": 50288
  },
  "InputsystemDll": {
    "InputStackSystemVersion001": 5872,
    "InputSystemVersion001": 10448
  },
  "LocalizeDll": {
    "Localize_001": 14384
  },
  "MatchmakingDll": {
    "GameTypes001": 328304,
    "MATCHFRAMEWORK_001": 1053360
  },
  "Materialsystem2Dll": {
    "FontManager_001": 227584,
    "MaterialUtils_001": 318352,
    "PostProcessingSystem_001": 272992,
    "TextLayout_001": 303840,
    "VMaterialSystem2_001": 155328
  },
  "MeshsystemDll": {
    "MeshSystem001": 29296
  },
  "NavsystemDll": {
    "NavSystem001": 30448
  },
  "NetworksystemDll": {
    "FlattenedSerializersVersion001": 508992,
    "NetworkMessagesVersion001": 640720,
    "NetworkSystemVersion001": 771808,
    "SerializedEntitiesVersion001": 859824
  },
  "PanoramaDll": {
    "PanoramaUIEngine001": 360160
  },
  "PanoramaTextPangoDll": {
    "PanoramaTextServices001": 314320
  },
  "PanoramauiclientDll": {
    "PanoramaUIClient001": 75648
  },
  "ParticlesDll": {
    "ParticleSystemMgr003": 339232
  },
  "PulseSystemDll": {
    "IPulseSystem_001": 23344
  },
  "Rendersystemdx11Dll": {
    "RenderDeviceMgr001": 304768,
    "RenderUtils_001": 340208,
    "VRenderDeviceMgrBackdoor001": 304784
  },
  "ResourcesystemDll": {
    "ResourceSystem013": 67152
  },
  "ScenefilecacheDll": {
    "ResponseRulesCache001": 12688,
    "SceneFileCache002": 26848
  },
  "ScenesystemDll": {
    "RenderingPipelines_001": 583840,
    "SceneSystem_002": 830000,
    "SceneUtils_001": 1296864
  },
  "SchemasystemDll": {
    "SchemaSystem_001": 43312
  },
  "ServerDll": {
    "EmptyWorldService001_Server": 5839872,
    "EntitySubclassUtilsV001": 2951328,
    "NavGameTest001": 10725744,
    "ServerToolsInfo_001": 8640368,
    "Source2GameClients001": 8640384,
    "Source2GameDirector001": 1332192,
    "Source2GameEntities001": 8640400,
    "Source2Server001": 8640416,
    "Source2ServerConfig001": 5708592,
    "customnavsystem001": 2414112
  },
  "SoundsystemDll": {
    "SoundOpSystem001": 1402848,
    "SoundOpSystemEdit001": 572352,
    "SoundSystem001": 288064,
    "VMixEditTool001": 464704
  },
  "SteamaudioDll": {
    "SteamAudio001": 77536
  },
  "Steamclient64Dll": {
    "CLIENTENGINE_INTERFACE_VERSION005": 8698928,
    "IVALIDATE001": 8715648,
    "SteamClient006": 6578128,
    "SteamClient007": 6578144,
    "SteamClient008": 6578160,
    "SteamClient009": 6578176,
    "SteamClient010": 6578192,
    "SteamClient011": 6578208,
    "SteamClient012": 6578224,
    "SteamClient013": 6578240,
    "SteamClient014": 6578256,
    "SteamClient015": 6578272,
    "SteamClient016": 6578288,
    "SteamClient017": 6578304,
    "SteamClient018": 6578320,
    "SteamClient019": 6578336,
    "SteamClient020": 6578352,
    "SteamClient021": 6578368,
    "p2pvoice002": 890832,
    "p2pvoicesingleton002": 877056
  },
  "Tier0Dll": {
    "TestScriptMgr001": 1308176,
    "VEngineCvar007": 399648,
    "VProcessUtils002": 1243024,
    "VStringTokenSystem001": 1622704
  },
  "V8SystemDll": {
    "Source2V8System001": 5744
  },
  "ValveAviDll": {
    "VAvi001": 12176
  },
  "ValveWmfDll": {
    "VMediaFoundation001": 4816
  },
  "Vphysics2Dll": {
    "VPhysics2_Handle_Interface_001": 397600,
    "VPhysics2_Interface_001": 378688
  },
  "VscriptDll": {
    "VScriptManager010": 204192
  },
  "VstdlibS64Dll": {
    "IVALIDATE001": 151552,
    "VEngineCvar002": 22368
  },
  "WorldrendererDll": {
    "WorldRendererMgr001": 136784
  }
}
```

`SDK/interfaces.py`:

```py
'''
https://github.com/a2x/cs2-dumper
2023-11-23 10:28:27.799691100 UTC
'''

class AnimationsystemDll:
    AnimationSystemUtils_001 = 0x64670
    AnimationSystem_001 = 0x5F1D0

class ClientDll:
    LegacyGameUI001 = 0x89C960
    Source2ClientUI001 = 0x88B670
    Source2ClientPrediction001 = 0x7A3990
    ClientToolsInfo_001 = 0x72F780
    Source2Client002 = 0x72F7A0
    GameClientExports001 = 0x72F790
    EmptyWorldService001_Client = 0x48FD90
    Source2ClientConfig001 = 0x476CD0

class Engine2Dll:
    SimpleEngineLoopService_001 = 0x1E4700
    ClientServerEngineLoopService_001 = 0x1DA350
    KeyValueCache001 = 0x1D6990
    HostStateMgr001 = 0x1D4190
    GameEventSystemServerV001 = 0x1CF830
    GameEventSystemClientV001 = 0x1CF820
    EngineServiceMgr001 = 0x1CB510
    VProfService_001 = 0x1B8E80
    ToolService_001 = 0x1B7BD0
    StatsService_001 = 0x1B2E50
    SplitScreenService_001 = 0x1B00C0
    SoundService_001 = 0x1AAC00
    ScreenshotService001 = 0x1A6AD0
    RenderService_001 = 0x1A3E30
    NetworkService_001 = 0x1A3940
    NetworkServerService_001 = 0x19E7F0
    NetworkP2PService_001 = 0x19A2E0
    NetworkClientService_001 = 0x193F70
    MapListService_001 = 0x18CF40
    InputService_001 = 0x17ABB0
    GameUIService_001 = 0x1753D0
    GameResourceServiceServerV001 = 0x173130
    GameResourceServiceClientV001 = 0x173120
    BugService001 = 0x16C150
    BenchmarkService001 = 0x16A920
    VENGINE_GAMEUIFUNCS_VERSION005 = 0x118430
    EngineGameUI001 = 0x1177C0
    INETSUPPORT_001 = 0xE6E20
    Source2EngineToServerStringTable001 = 0xA2410
    Source2EngineToServer001 = 0x8B6F0
    Source2EngineToClientStringTable001 = 0x841D0
    Source2EngineToClient001 = 0x5A990

class FilesystemStdioDll:
    VAsyncFileSystem2_001 = 0x66D30
    VFileSystem017 = 0x66D20

class HostDll:
    Source2Host001 = 0x18E10
    SinglePlayerSharedMemory001 = 0x18A90
    SaveRestoreDataVersion001 = 0x18A80
    PredictionDiffManager001 = 0x16E20
    HostUtils001 = 0x12550
    GameSystem2HostHook = 0x11DA0
    GameModelInfo001 = 0x11CC0
    DebugDrawQueueManager001 = 0x11710

class ImemanagerDll:
    IMEManager001 = 0xC470

class InputsystemDll:
    InputSystemVersion001 = 0x28D0
    InputStackSystemVersion001 = 0x16F0

class LocalizeDll:
    Localize_001 = 0x3830

class MatchmakingDll:
    GameTypes001 = 0x50270
    MATCHFRAMEWORK_001 = 0x1012B0

class Materialsystem2Dll:
    MaterialUtils_001 = 0x4DB90
    TextLayout_001 = 0x4A2E0
    PostProcessingSystem_001 = 0x42A60
    FontManager_001 = 0x37900
    VMaterialSystem2_001 = 0x25EC0

class MeshsystemDll:
    MeshSystem001 = 0x7270

class NavsystemDll:
    NavSystem001 = 0x76F0

class NetworksystemDll:
    SerializedEntitiesVersion001 = 0xD1EB0
    NetworkSystemVersion001 = 0xBC6E0
    NetworkMessagesVersion001 = 0x9C6D0
    FlattenedSerializersVersion001 = 0x7C440

class PanoramaDll:
    PanoramaUIEngine001 = 0x57EE0

class PanoramaTextPangoDll:
    PanoramaTextServices001 = 0x4CBD0

class PanoramauiclientDll:
    PanoramaUIClient001 = 0x12780

class ParticlesDll:
    ParticleSystemMgr003 = 0x52D20

class PulseSystemDll:
    IPulseSystem_001 = 0x5B30

class Rendersystemdx11Dll:
    RenderUtils_001 = 0x530F0
    VRenderDeviceMgrBackdoor001 = 0x4A690
    RenderDeviceMgr001 = 0x4A680

class ResourcesystemDll:
    ResourceSystem013 = 0x10650

class ScenefilecacheDll:
    SceneFileCache002 = 0x68E0
    ResponseRulesCache001 = 0x3190

class ScenesystemDll:
    SceneUtils_001 = 0x13C9E0
    SceneSystem_002 = 0xCAA30
    RenderingPipelines_001 = 0x8E8A0

class SchemasystemDll:
    SchemaSystem_001 = 0xA930

class ServerDll:
    NavGameTest001 = 0xA3A970
    ServerToolsInfo_001 = 0x83D770
    Source2GameClients001 = 0x83D780
    Source2GameEntities001 = 0x83D790
    Source2Server001 = 0x83D7A0
    EmptyWorldService001_Server = 0x591C00
    Source2ServerConfig001 = 0x571B30
    EntitySubclassUtilsV001 = 0x2D08A0
    customnavsystem001 = 0x24D620
    Source2GameDirector001 = 0x1453E0

class SoundsystemDll:
    SoundOpSystem001 = 0x1567E0
    SoundOpSystemEdit001 = 0x8BBC0
    VMixEditTool001 = 0x71740
    SoundSystem001 = 0x46540

class SteamaudioDll:
    SteamAudio001 = 0x12EE0

class Steamclient64Dll:
    IVALIDATE001 = 0x84FD80
    CLIENTENGINE_INTERFACE_VERSION005 = 0x84BC30
    SteamClient021 = 0x6460C0
    SteamClient020 = 0x6460B0
    SteamClient019 = 0x6460A0
    SteamClient018 = 0x646090
    SteamClient017 = 0x646080
    SteamClient016 = 0x646070
    SteamClient015 = 0x646060
    SteamClient014 = 0x646050
    SteamClient013 = 0x646040
    SteamClient012 = 0x646030
    SteamClient011 = 0x646020
    SteamClient010 = 0x646010
    SteamClient009 = 0x646000
    SteamClient008 = 0x645FF0
    SteamClient007 = 0x645FE0
    SteamClient006 = 0x645FD0
    p2pvoice002 = 0xD97D0
    p2pvoicesingleton002 = 0xD6200

class Tier0Dll:
    VStringTokenSystem001 = 0x18C2B0
    TestScriptMgr001 = 0x13F610
    VProcessUtils002 = 0x12F790
    VEngineCvar007 = 0x61920

class V8SystemDll:
    Source2V8System001 = 0x1670

class ValveAviDll:
    VAvi001 = 0x2F90

class ValveWmfDll:
    VMediaFoundation001 = 0x12D0

class Vphysics2Dll:
    VPhysics2_Handle_Interface_001 = 0x61120
    VPhysics2_Interface_001 = 0x5C740

class VscriptDll:
    VScriptManager010 = 0x31DA0

class VstdlibS64Dll:
    IVALIDATE001 = 0x25000
    VEngineCvar002 = 0x5760

class WorldrendererDll:
    WorldRendererMgr001 = 0x21650

```

`SDK/interfaces.rs`:

```rs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:27.803796800 UTC
 */

#![allow(non_snake_case, non_upper_case_globals)]

pub mod AnimationsystemDll {
    pub const AnimationSystemUtils_001: usize = 0x64670;
    pub const AnimationSystem_001: usize = 0x5F1D0;
}

pub mod ClientDll {
    pub const LegacyGameUI001: usize = 0x89C960;
    pub const Source2ClientUI001: usize = 0x88B670;
    pub const Source2ClientPrediction001: usize = 0x7A3990;
    pub const ClientToolsInfo_001: usize = 0x72F780;
    pub const Source2Client002: usize = 0x72F7A0;
    pub const GameClientExports001: usize = 0x72F790;
    pub const EmptyWorldService001_Client: usize = 0x48FD90;
    pub const Source2ClientConfig001: usize = 0x476CD0;
}

pub mod Engine2Dll {
    pub const SimpleEngineLoopService_001: usize = 0x1E4700;
    pub const ClientServerEngineLoopService_001: usize = 0x1DA350;
    pub const KeyValueCache001: usize = 0x1D6990;
    pub const HostStateMgr001: usize = 0x1D4190;
    pub const GameEventSystemServerV001: usize = 0x1CF830;
    pub const GameEventSystemClientV001: usize = 0x1CF820;
    pub const EngineServiceMgr001: usize = 0x1CB510;
    pub const VProfService_001: usize = 0x1B8E80;
    pub const ToolService_001: usize = 0x1B7BD0;
    pub const StatsService_001: usize = 0x1B2E50;
    pub const SplitScreenService_001: usize = 0x1B00C0;
    pub const SoundService_001: usize = 0x1AAC00;
    pub const ScreenshotService001: usize = 0x1A6AD0;
    pub const RenderService_001: usize = 0x1A3E30;
    pub const NetworkService_001: usize = 0x1A3940;
    pub const NetworkServerService_001: usize = 0x19E7F0;
    pub const NetworkP2PService_001: usize = 0x19A2E0;
    pub const NetworkClientService_001: usize = 0x193F70;
    pub const MapListService_001: usize = 0x18CF40;
    pub const InputService_001: usize = 0x17ABB0;
    pub const GameUIService_001: usize = 0x1753D0;
    pub const GameResourceServiceServerV001: usize = 0x173130;
    pub const GameResourceServiceClientV001: usize = 0x173120;
    pub const BugService001: usize = 0x16C150;
    pub const BenchmarkService001: usize = 0x16A920;
    pub const VENGINE_GAMEUIFUNCS_VERSION005: usize = 0x118430;
    pub const EngineGameUI001: usize = 0x1177C0;
    pub const INETSUPPORT_001: usize = 0xE6E20;
    pub const Source2EngineToServerStringTable001: usize = 0xA2410;
    pub const Source2EngineToServer001: usize = 0x8B6F0;
    pub const Source2EngineToClientStringTable001: usize = 0x841D0;
    pub const Source2EngineToClient001: usize = 0x5A990;
}

pub mod FilesystemStdioDll {
    pub const VAsyncFileSystem2_001: usize = 0x66D30;
    pub const VFileSystem017: usize = 0x66D20;
}

pub mod HostDll {
    pub const Source2Host001: usize = 0x18E10;
    pub const SinglePlayerSharedMemory001: usize = 0x18A90;
    pub const SaveRestoreDataVersion001: usize = 0x18A80;
    pub const PredictionDiffManager001: usize = 0x16E20;
    pub const HostUtils001: usize = 0x12550;
    pub const GameSystem2HostHook: usize = 0x11DA0;
    pub const GameModelInfo001: usize = 0x11CC0;
    pub const DebugDrawQueueManager001: usize = 0x11710;
}

pub mod ImemanagerDll {
    pub const IMEManager001: usize = 0xC470;
}

pub mod InputsystemDll {
    pub const InputSystemVersion001: usize = 0x28D0;
    pub const InputStackSystemVersion001: usize = 0x16F0;
}

pub mod LocalizeDll {
    pub const Localize_001: usize = 0x3830;
}

pub mod MatchmakingDll {
    pub const GameTypes001: usize = 0x50270;
    pub const MATCHFRAMEWORK_001: usize = 0x1012B0;
}

pub mod Materialsystem2Dll {
    pub const MaterialUtils_001: usize = 0x4DB90;
    pub const TextLayout_001: usize = 0x4A2E0;
    pub const PostProcessingSystem_001: usize = 0x42A60;
    pub const FontManager_001: usize = 0x37900;
    pub const VMaterialSystem2_001: usize = 0x25EC0;
}

pub mod MeshsystemDll {
    pub const MeshSystem001: usize = 0x7270;
}

pub mod NavsystemDll {
    pub const NavSystem001: usize = 0x76F0;
}

pub mod NetworksystemDll {
    pub const SerializedEntitiesVersion001: usize = 0xD1EB0;
    pub const NetworkSystemVersion001: usize = 0xBC6E0;
    pub const NetworkMessagesVersion001: usize = 0x9C6D0;
    pub const FlattenedSerializersVersion001: usize = 0x7C440;
}

pub mod PanoramaDll {
    pub const PanoramaUIEngine001: usize = 0x57EE0;
}

pub mod PanoramaTextPangoDll {
    pub const PanoramaTextServices001: usize = 0x4CBD0;
}

pub mod PanoramauiclientDll {
    pub const PanoramaUIClient001: usize = 0x12780;
}

pub mod ParticlesDll {
    pub const ParticleSystemMgr003: usize = 0x52D20;
}

pub mod PulseSystemDll {
    pub const IPulseSystem_001: usize = 0x5B30;
}

pub mod Rendersystemdx11Dll {
    pub const RenderUtils_001: usize = 0x530F0;
    pub const VRenderDeviceMgrBackdoor001: usize = 0x4A690;
    pub const RenderDeviceMgr001: usize = 0x4A680;
}

pub mod ResourcesystemDll {
    pub const ResourceSystem013: usize = 0x10650;
}

pub mod ScenefilecacheDll {
    pub const SceneFileCache002: usize = 0x68E0;
    pub const ResponseRulesCache001: usize = 0x3190;
}

pub mod ScenesystemDll {
    pub const SceneUtils_001: usize = 0x13C9E0;
    pub const SceneSystem_002: usize = 0xCAA30;
    pub const RenderingPipelines_001: usize = 0x8E8A0;
}

pub mod SchemasystemDll {
    pub const SchemaSystem_001: usize = 0xA930;
}

pub mod ServerDll {
    pub const NavGameTest001: usize = 0xA3A970;
    pub const ServerToolsInfo_001: usize = 0x83D770;
    pub const Source2GameClients001: usize = 0x83D780;
    pub const Source2GameEntities001: usize = 0x83D790;
    pub const Source2Server001: usize = 0x83D7A0;
    pub const EmptyWorldService001_Server: usize = 0x591C00;
    pub const Source2ServerConfig001: usize = 0x571B30;
    pub const EntitySubclassUtilsV001: usize = 0x2D08A0;
    pub const customnavsystem001: usize = 0x24D620;
    pub const Source2GameDirector001: usize = 0x1453E0;
}

pub mod SoundsystemDll {
    pub const SoundOpSystem001: usize = 0x1567E0;
    pub const SoundOpSystemEdit001: usize = 0x8BBC0;
    pub const VMixEditTool001: usize = 0x71740;
    pub const SoundSystem001: usize = 0x46540;
}

pub mod SteamaudioDll {
    pub const SteamAudio001: usize = 0x12EE0;
}

pub mod Steamclient64Dll {
    pub const IVALIDATE001: usize = 0x84FD80;
    pub const CLIENTENGINE_INTERFACE_VERSION005: usize = 0x84BC30;
    pub const SteamClient021: usize = 0x6460C0;
    pub const SteamClient020: usize = 0x6460B0;
    pub const SteamClient019: usize = 0x6460A0;
    pub const SteamClient018: usize = 0x646090;
    pub const SteamClient017: usize = 0x646080;
    pub const SteamClient016: usize = 0x646070;
    pub const SteamClient015: usize = 0x646060;
    pub const SteamClient014: usize = 0x646050;
    pub const SteamClient013: usize = 0x646040;
    pub const SteamClient012: usize = 0x646030;
    pub const SteamClient011: usize = 0x646020;
    pub const SteamClient010: usize = 0x646010;
    pub const SteamClient009: usize = 0x646000;
    pub const SteamClient008: usize = 0x645FF0;
    pub const SteamClient007: usize = 0x645FE0;
    pub const SteamClient006: usize = 0x645FD0;
    pub const p2pvoice002: usize = 0xD97D0;
    pub const p2pvoicesingleton002: usize = 0xD6200;
}

pub mod Tier0Dll {
    pub const VStringTokenSystem001: usize = 0x18C2B0;
    pub const TestScriptMgr001: usize = 0x13F610;
    pub const VProcessUtils002: usize = 0x12F790;
    pub const VEngineCvar007: usize = 0x61920;
}

pub mod V8SystemDll {
    pub const Source2V8System001: usize = 0x1670;
}

pub mod ValveAviDll {
    pub const VAvi001: usize = 0x2F90;
}

pub mod ValveWmfDll {
    pub const VMediaFoundation001: usize = 0x12D0;
}

pub mod Vphysics2Dll {
    pub const VPhysics2_Handle_Interface_001: usize = 0x61120;
    pub const VPhysics2_Interface_001: usize = 0x5C740;
}

pub mod VscriptDll {
    pub const VScriptManager010: usize = 0x31DA0;
}

pub mod VstdlibS64Dll {
    pub const IVALIDATE001: usize = 0x25000;
    pub const VEngineCvar002: usize = 0x5760;
}

pub mod WorldrendererDll {
    pub const WorldRendererMgr001: usize = 0x21650;
}
```

`SDK/materialsystem2.dll.cs`:

```cs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.181453200 UTC
 */

public static class MaterialParamBuffer_t {
    public const nint m_value = 0x8; // CUtlBinaryBlock
}

public static class MaterialParamFloat_t {
    public const nint m_flValue = 0x8; // float
}

public static class MaterialParamInt_t {
    public const nint m_nValue = 0x8; // int32_t
}

public static class MaterialParamString_t {
    public const nint m_value = 0x8; // CUtlString
}

public static class MaterialParamTexture_t {
    public const nint m_pValue = 0x8; // CStrongHandle<InfoForResourceTypeCTextureBase>
}

public static class MaterialParamVector_t {
    public const nint m_value = 0x8; // Vector4D
}

public static class MaterialParam_t {
    public const nint m_name = 0x0; // CUtlString
}

public static class MaterialResourceData_t {
    public const nint m_materialName = 0x0; // CUtlString
    public const nint m_shaderName = 0x8; // CUtlString
    public const nint m_intParams = 0x10; // CUtlVector<MaterialParamInt_t>
    public const nint m_floatParams = 0x28; // CUtlVector<MaterialParamFloat_t>
    public const nint m_vectorParams = 0x40; // CUtlVector<MaterialParamVector_t>
    public const nint m_textureParams = 0x58; // CUtlVector<MaterialParamTexture_t>
    public const nint m_dynamicParams = 0x70; // CUtlVector<MaterialParamBuffer_t>
    public const nint m_dynamicTextureParams = 0x88; // CUtlVector<MaterialParamBuffer_t>
    public const nint m_intAttributes = 0xA0; // CUtlVector<MaterialParamInt_t>
    public const nint m_floatAttributes = 0xB8; // CUtlVector<MaterialParamFloat_t>
    public const nint m_vectorAttributes = 0xD0; // CUtlVector<MaterialParamVector_t>
    public const nint m_textureAttributes = 0xE8; // CUtlVector<MaterialParamTexture_t>
    public const nint m_stringAttributes = 0x100; // CUtlVector<MaterialParamString_t>
    public const nint m_renderAttributesUsed = 0x118; // CUtlVector<CUtlString>
}

public static class PostProcessingBloomParameters_t {
    public const nint m_blendMode = 0x0; // BloomBlendMode_t
    public const nint m_flBloomStrength = 0x4; // float
    public const nint m_flScreenBloomStrength = 0x8; // float
    public const nint m_flBlurBloomStrength = 0xC; // float
    public const nint m_flBloomThreshold = 0x10; // float
    public const nint m_flBloomThresholdWidth = 0x14; // float
    public const nint m_flSkyboxBloomStrength = 0x18; // float
    public const nint m_flBloomStartValue = 0x1C; // float
    public const nint m_flBlurWeight = 0x20; // float[5]
    public const nint m_vBlurTint = 0x34; // Vector[5]
}

public static class PostProcessingLocalContrastParameters_t {
    public const nint m_flLocalContrastStrength = 0x0; // float
    public const nint m_flLocalContrastEdgeStrength = 0x4; // float
    public const nint m_flLocalContrastVignetteStart = 0x8; // float
    public const nint m_flLocalContrastVignetteEnd = 0xC; // float
    public const nint m_flLocalContrastVignetteBlur = 0x10; // float
}

public static class PostProcessingResource_t {
    public const nint m_bHasTonemapParams = 0x0; // bool
    public const nint m_toneMapParams = 0x4; // PostProcessingTonemapParameters_t
    public const nint m_bHasBloomParams = 0x40; // bool
    public const nint m_bloomParams = 0x44; // PostProcessingBloomParameters_t
    public const nint m_bHasVignetteParams = 0xB4; // bool
    public const nint m_vignetteParams = 0xB8; // PostProcessingVignetteParameters_t
    public const nint m_bHasLocalContrastParams = 0xDC; // bool
    public const nint m_localConstrastParams = 0xE0; // PostProcessingLocalContrastParameters_t
    public const nint m_nColorCorrectionVolumeDim = 0xF4; // int32_t
    public const nint m_colorCorrectionVolumeData = 0xF8; // CUtlBinaryBlock
    public const nint m_bHasColorCorrection = 0x110; // bool
}

public static class PostProcessingTonemapParameters_t {
    public const nint m_flExposureBias = 0x0; // float
    public const nint m_flShoulderStrength = 0x4; // float
    public const nint m_flLinearStrength = 0x8; // float
    public const nint m_flLinearAngle = 0xC; // float
    public const nint m_flToeStrength = 0x10; // float
    public const nint m_flToeNum = 0x14; // float
    public const nint m_flToeDenom = 0x18; // float
    public const nint m_flWhitePoint = 0x1C; // float
    public const nint m_flLuminanceSource = 0x20; // float
    public const nint m_flExposureBiasShadows = 0x24; // float
    public const nint m_flExposureBiasHighlights = 0x28; // float
    public const nint m_flMinShadowLum = 0x2C; // float
    public const nint m_flMaxShadowLum = 0x30; // float
    public const nint m_flMinHighlightLum = 0x34; // float
    public const nint m_flMaxHighlightLum = 0x38; // float
}

public static class PostProcessingVignetteParameters_t {
    public const nint m_flVignetteStrength = 0x0; // float
    public const nint m_vCenter = 0x4; // Vector2D
    public const nint m_flRadius = 0xC; // float
    public const nint m_flRoundness = 0x10; // float
    public const nint m_flFeather = 0x14; // float
    public const nint m_vColorTint = 0x18; // Vector
}
```

`SDK/materialsystem2.dll.hpp`:

```hpp
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.178715400 UTC
 */

#pragma once

#include <cstddef>

namespace MaterialParamBuffer_t {
    constexpr std::ptrdiff_t m_value = 0x8; // CUtlBinaryBlock
}

namespace MaterialParamFloat_t {
    constexpr std::ptrdiff_t m_flValue = 0x8; // float
}

namespace MaterialParamInt_t {
    constexpr std::ptrdiff_t m_nValue = 0x8; // int32_t
}

namespace MaterialParamString_t {
    constexpr std::ptrdiff_t m_value = 0x8; // CUtlString
}

namespace MaterialParamTexture_t {
    constexpr std::ptrdiff_t m_pValue = 0x8; // CStrongHandle<InfoForResourceTypeCTextureBase>
}

namespace MaterialParamVector_t {
    constexpr std::ptrdiff_t m_value = 0x8; // Vector4D
}

namespace MaterialParam_t {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
}

namespace MaterialResourceData_t {
    constexpr std::ptrdiff_t m_materialName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_shaderName = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_intParams = 0x10; // CUtlVector<MaterialParamInt_t>
    constexpr std::ptrdiff_t m_floatParams = 0x28; // CUtlVector<MaterialParamFloat_t>
    constexpr std::ptrdiff_t m_vectorParams = 0x40; // CUtlVector<MaterialParamVector_t>
    constexpr std::ptrdiff_t m_textureParams = 0x58; // CUtlVector<MaterialParamTexture_t>
    constexpr std::ptrdiff_t m_dynamicParams = 0x70; // CUtlVector<MaterialParamBuffer_t>
    constexpr std::ptrdiff_t m_dynamicTextureParams = 0x88; // CUtlVector<MaterialParamBuffer_t>
    constexpr std::ptrdiff_t m_intAttributes = 0xA0; // CUtlVector<MaterialParamInt_t>
    constexpr std::ptrdiff_t m_floatAttributes = 0xB8; // CUtlVector<MaterialParamFloat_t>
    constexpr std::ptrdiff_t m_vectorAttributes = 0xD0; // CUtlVector<MaterialParamVector_t>
    constexpr std::ptrdiff_t m_textureAttributes = 0xE8; // CUtlVector<MaterialParamTexture_t>
    constexpr std::ptrdiff_t m_stringAttributes = 0x100; // CUtlVector<MaterialParamString_t>
    constexpr std::ptrdiff_t m_renderAttributesUsed = 0x118; // CUtlVector<CUtlString>
}

namespace PostProcessingBloomParameters_t {
    constexpr std::ptrdiff_t m_blendMode = 0x0; // BloomBlendMode_t
    constexpr std::ptrdiff_t m_flBloomStrength = 0x4; // float
    constexpr std::ptrdiff_t m_flScreenBloomStrength = 0x8; // float
    constexpr std::ptrdiff_t m_flBlurBloomStrength = 0xC; // float
    constexpr std::ptrdiff_t m_flBloomThreshold = 0x10; // float
    constexpr std::ptrdiff_t m_flBloomThresholdWidth = 0x14; // float
    constexpr std::ptrdiff_t m_flSkyboxBloomStrength = 0x18; // float
    constexpr std::ptrdiff_t m_flBloomStartValue = 0x1C; // float
    constexpr std::ptrdiff_t m_flBlurWeight = 0x20; // float[5]
    constexpr std::ptrdiff_t m_vBlurTint = 0x34; // Vector[5]
}

namespace PostProcessingLocalContrastParameters_t {
    constexpr std::ptrdiff_t m_flLocalContrastStrength = 0x0; // float
    constexpr std::ptrdiff_t m_flLocalContrastEdgeStrength = 0x4; // float
    constexpr std::ptrdiff_t m_flLocalContrastVignetteStart = 0x8; // float
    constexpr std::ptrdiff_t m_flLocalContrastVignetteEnd = 0xC; // float
    constexpr std::ptrdiff_t m_flLocalContrastVignetteBlur = 0x10; // float
}

namespace PostProcessingResource_t {
    constexpr std::ptrdiff_t m_bHasTonemapParams = 0x0; // bool
    constexpr std::ptrdiff_t m_toneMapParams = 0x4; // PostProcessingTonemapParameters_t
    constexpr std::ptrdiff_t m_bHasBloomParams = 0x40; // bool
    constexpr std::ptrdiff_t m_bloomParams = 0x44; // PostProcessingBloomParameters_t
    constexpr std::ptrdiff_t m_bHasVignetteParams = 0xB4; // bool
    constexpr std::ptrdiff_t m_vignetteParams = 0xB8; // PostProcessingVignetteParameters_t
    constexpr std::ptrdiff_t m_bHasLocalContrastParams = 0xDC; // bool
    constexpr std::ptrdiff_t m_localConstrastParams = 0xE0; // PostProcessingLocalContrastParameters_t
    constexpr std::ptrdiff_t m_nColorCorrectionVolumeDim = 0xF4; // int32_t
    constexpr std::ptrdiff_t m_colorCorrectionVolumeData = 0xF8; // CUtlBinaryBlock
    constexpr std::ptrdiff_t m_bHasColorCorrection = 0x110; // bool
}

namespace PostProcessingTonemapParameters_t {
    constexpr std::ptrdiff_t m_flExposureBias = 0x0; // float
    constexpr std::ptrdiff_t m_flShoulderStrength = 0x4; // float
    constexpr std::ptrdiff_t m_flLinearStrength = 0x8; // float
    constexpr std::ptrdiff_t m_flLinearAngle = 0xC; // float
    constexpr std::ptrdiff_t m_flToeStrength = 0x10; // float
    constexpr std::ptrdiff_t m_flToeNum = 0x14; // float
    constexpr std::ptrdiff_t m_flToeDenom = 0x18; // float
    constexpr std::ptrdiff_t m_flWhitePoint = 0x1C; // float
    constexpr std::ptrdiff_t m_flLuminanceSource = 0x20; // float
    constexpr std::ptrdiff_t m_flExposureBiasShadows = 0x24; // float
    constexpr std::ptrdiff_t m_flExposureBiasHighlights = 0x28; // float
    constexpr std::ptrdiff_t m_flMinShadowLum = 0x2C; // float
    constexpr std::ptrdiff_t m_flMaxShadowLum = 0x30; // float
    constexpr std::ptrdiff_t m_flMinHighlightLum = 0x34; // float
    constexpr std::ptrdiff_t m_flMaxHighlightLum = 0x38; // float
}

namespace PostProcessingVignetteParameters_t {
    constexpr std::ptrdiff_t m_flVignetteStrength = 0x0; // float
    constexpr std::ptrdiff_t m_vCenter = 0x4; // Vector2D
    constexpr std::ptrdiff_t m_flRadius = 0xC; // float
    constexpr std::ptrdiff_t m_flRoundness = 0x10; // float
    constexpr std::ptrdiff_t m_flFeather = 0x14; // float
    constexpr std::ptrdiff_t m_vColorTint = 0x18; // Vector
}
```

`SDK/materialsystem2.dll.json`:

```json
{
  "MaterialParamBuffer_t": {
    "m_value": 8
  },
  "MaterialParamFloat_t": {
    "m_flValue": 8
  },
  "MaterialParamInt_t": {
    "m_nValue": 8
  },
  "MaterialParamString_t": {
    "m_value": 8
  },
  "MaterialParamTexture_t": {
    "m_pValue": 8
  },
  "MaterialParamVector_t": {
    "m_value": 8
  },
  "MaterialParam_t": {
    "m_name": 0
  },
  "MaterialResourceData_t": {
    "m_dynamicParams": 112,
    "m_dynamicTextureParams": 136,
    "m_floatAttributes": 184,
    "m_floatParams": 40,
    "m_intAttributes": 160,
    "m_intParams": 16,
    "m_materialName": 0,
    "m_renderAttributesUsed": 280,
    "m_shaderName": 8,
    "m_stringAttributes": 256,
    "m_textureAttributes": 232,
    "m_textureParams": 88,
    "m_vectorAttributes": 208,
    "m_vectorParams": 64
  },
  "PostProcessingBloomParameters_t": {
    "m_blendMode": 0,
    "m_flBloomStartValue": 28,
    "m_flBloomStrength": 4,
    "m_flBloomThreshold": 16,
    "m_flBloomThresholdWidth": 20,
    "m_flBlurBloomStrength": 12,
    "m_flBlurWeight": 32,
    "m_flScreenBloomStrength": 8,
    "m_flSkyboxBloomStrength": 24,
    "m_vBlurTint": 52
  },
  "PostProcessingLocalContrastParameters_t": {
    "m_flLocalContrastEdgeStrength": 4,
    "m_flLocalContrastStrength": 0,
    "m_flLocalContrastVignetteBlur": 16,
    "m_flLocalContrastVignetteEnd": 12,
    "m_flLocalContrastVignetteStart": 8
  },
  "PostProcessingResource_t": {
    "m_bHasBloomParams": 64,
    "m_bHasColorCorrection": 272,
    "m_bHasLocalContrastParams": 220,
    "m_bHasTonemapParams": 0,
    "m_bHasVignetteParams": 180,
    "m_bloomParams": 68,
    "m_colorCorrectionVolumeData": 248,
    "m_localConstrastParams": 224,
    "m_nColorCorrectionVolumeDim": 244,
    "m_toneMapParams": 4,
    "m_vignetteParams": 184
  },
  "PostProcessingTonemapParameters_t": {
    "m_flExposureBias": 0,
    "m_flExposureBiasHighlights": 40,
    "m_flExposureBiasShadows": 36,
    "m_flLinearAngle": 12,
    "m_flLinearStrength": 8,
    "m_flLuminanceSource": 32,
    "m_flMaxHighlightLum": 56,
    "m_flMaxShadowLum": 48,
    "m_flMinHighlightLum": 52,
    "m_flMinShadowLum": 44,
    "m_flShoulderStrength": 4,
    "m_flToeDenom": 24,
    "m_flToeNum": 20,
    "m_flToeStrength": 16,
    "m_flWhitePoint": 28
  },
  "PostProcessingVignetteParameters_t": {
    "m_flFeather": 20,
    "m_flRadius": 12,
    "m_flRoundness": 16,
    "m_flVignetteStrength": 0,
    "m_vCenter": 4,
    "m_vColorTint": 24
  }
}
```

`SDK/materialsystem2.dll.py`:

```py
'''
https://github.com/a2x/cs2-dumper
2023-11-23 10:28:25.184007900 UTC
'''

class MaterialParamBuffer_t:
    m_value = 0x8 # CUtlBinaryBlock

class MaterialParamFloat_t:
    m_flValue = 0x8 # float

class MaterialParamInt_t:
    m_nValue = 0x8 # int32_t

class MaterialParamString_t:
    m_value = 0x8 # CUtlString

class MaterialParamTexture_t:
    m_pValue = 0x8 # CStrongHandle<InfoForResourceTypeCTextureBase>

class MaterialParamVector_t:
    m_value = 0x8 # Vector4D

class MaterialParam_t:
    m_name = 0x0 # CUtlString

class MaterialResourceData_t:
    m_materialName = 0x0 # CUtlString
    m_shaderName = 0x8 # CUtlString
    m_intParams = 0x10 # CUtlVector<MaterialParamInt_t>
    m_floatParams = 0x28 # CUtlVector<MaterialParamFloat_t>
    m_vectorParams = 0x40 # CUtlVector<MaterialParamVector_t>
    m_textureParams = 0x58 # CUtlVector<MaterialParamTexture_t>
    m_dynamicParams = 0x70 # CUtlVector<MaterialParamBuffer_t>
    m_dynamicTextureParams = 0x88 # CUtlVector<MaterialParamBuffer_t>
    m_intAttributes = 0xA0 # CUtlVector<MaterialParamInt_t>
    m_floatAttributes = 0xB8 # CUtlVector<MaterialParamFloat_t>
    m_vectorAttributes = 0xD0 # CUtlVector<MaterialParamVector_t>
    m_textureAttributes = 0xE8 # CUtlVector<MaterialParamTexture_t>
    m_stringAttributes = 0x100 # CUtlVector<MaterialParamString_t>
    m_renderAttributesUsed = 0x118 # CUtlVector<CUtlString>

class PostProcessingBloomParameters_t:
    m_blendMode = 0x0 # BloomBlendMode_t
    m_flBloomStrength = 0x4 # float
    m_flScreenBloomStrength = 0x8 # float
    m_flBlurBloomStrength = 0xC # float
    m_flBloomThreshold = 0x10 # float
    m_flBloomThresholdWidth = 0x14 # float
    m_flSkyboxBloomStrength = 0x18 # float
    m_flBloomStartValue = 0x1C # float
    m_flBlurWeight = 0x20 # float[5]
    m_vBlurTint = 0x34 # Vector[5]

class PostProcessingLocalContrastParameters_t:
    m_flLocalContrastStrength = 0x0 # float
    m_flLocalContrastEdgeStrength = 0x4 # float
    m_flLocalContrastVignetteStart = 0x8 # float
    m_flLocalContrastVignetteEnd = 0xC # float
    m_flLocalContrastVignetteBlur = 0x10 # float

class PostProcessingResource_t:
    m_bHasTonemapParams = 0x0 # bool
    m_toneMapParams = 0x4 # PostProcessingTonemapParameters_t
    m_bHasBloomParams = 0x40 # bool
    m_bloomParams = 0x44 # PostProcessingBloomParameters_t
    m_bHasVignetteParams = 0xB4 # bool
    m_vignetteParams = 0xB8 # PostProcessingVignetteParameters_t
    m_bHasLocalContrastParams = 0xDC # bool
    m_localConstrastParams = 0xE0 # PostProcessingLocalContrastParameters_t
    m_nColorCorrectionVolumeDim = 0xF4 # int32_t
    m_colorCorrectionVolumeData = 0xF8 # CUtlBinaryBlock
    m_bHasColorCorrection = 0x110 # bool

class PostProcessingTonemapParameters_t:
    m_flExposureBias = 0x0 # float
    m_flShoulderStrength = 0x4 # float
    m_flLinearStrength = 0x8 # float
    m_flLinearAngle = 0xC # float
    m_flToeStrength = 0x10 # float
    m_flToeNum = 0x14 # float
    m_flToeDenom = 0x18 # float
    m_flWhitePoint = 0x1C # float
    m_flLuminanceSource = 0x20 # float
    m_flExposureBiasShadows = 0x24 # float
    m_flExposureBiasHighlights = 0x28 # float
    m_flMinShadowLum = 0x2C # float
    m_flMaxShadowLum = 0x30 # float
    m_flMinHighlightLum = 0x34 # float
    m_flMaxHighlightLum = 0x38 # float

class PostProcessingVignetteParameters_t:
    m_flVignetteStrength = 0x0 # float
    m_vCenter = 0x4 # Vector2D
    m_flRadius = 0xC # float
    m_flRoundness = 0x10 # float
    m_flFeather = 0x14 # float
    m_vColorTint = 0x18 # Vector

```

`SDK/materialsystem2.dll.rs`:

```rs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.186853400 UTC
 */

#![allow(non_snake_case, non_upper_case_globals)]

pub mod MaterialParamBuffer_t {
    pub const m_value: usize = 0x8; // CUtlBinaryBlock
}

pub mod MaterialParamFloat_t {
    pub const m_flValue: usize = 0x8; // float
}

pub mod MaterialParamInt_t {
    pub const m_nValue: usize = 0x8; // int32_t
}

pub mod MaterialParamString_t {
    pub const m_value: usize = 0x8; // CUtlString
}

pub mod MaterialParamTexture_t {
    pub const m_pValue: usize = 0x8; // CStrongHandle<InfoForResourceTypeCTextureBase>
}

pub mod MaterialParamVector_t {
    pub const m_value: usize = 0x8; // Vector4D
}

pub mod MaterialParam_t {
    pub const m_name: usize = 0x0; // CUtlString
}

pub mod MaterialResourceData_t {
    pub const m_materialName: usize = 0x0; // CUtlString
    pub const m_shaderName: usize = 0x8; // CUtlString
    pub const m_intParams: usize = 0x10; // CUtlVector<MaterialParamInt_t>
    pub const m_floatParams: usize = 0x28; // CUtlVector<MaterialParamFloat_t>
    pub const m_vectorParams: usize = 0x40; // CUtlVector<MaterialParamVector_t>
    pub const m_textureParams: usize = 0x58; // CUtlVector<MaterialParamTexture_t>
    pub const m_dynamicParams: usize = 0x70; // CUtlVector<MaterialParamBuffer_t>
    pub const m_dynamicTextureParams: usize = 0x88; // CUtlVector<MaterialParamBuffer_t>
    pub const m_intAttributes: usize = 0xA0; // CUtlVector<MaterialParamInt_t>
    pub const m_floatAttributes: usize = 0xB8; // CUtlVector<MaterialParamFloat_t>
    pub const m_vectorAttributes: usize = 0xD0; // CUtlVector<MaterialParamVector_t>
    pub const m_textureAttributes: usize = 0xE8; // CUtlVector<MaterialParamTexture_t>
    pub const m_stringAttributes: usize = 0x100; // CUtlVector<MaterialParamString_t>
    pub const m_renderAttributesUsed: usize = 0x118; // CUtlVector<CUtlString>
}

pub mod PostProcessingBloomParameters_t {
    pub const m_blendMode: usize = 0x0; // BloomBlendMode_t
    pub const m_flBloomStrength: usize = 0x4; // float
    pub const m_flScreenBloomStrength: usize = 0x8; // float
    pub const m_flBlurBloomStrength: usize = 0xC; // float
    pub const m_flBloomThreshold: usize = 0x10; // float
    pub const m_flBloomThresholdWidth: usize = 0x14; // float
    pub const m_flSkyboxBloomStrength: usize = 0x18; // float
    pub const m_flBloomStartValue: usize = 0x1C; // float
    pub const m_flBlurWeight: usize = 0x20; // float[5]
    pub const m_vBlurTint: usize = 0x34; // Vector[5]
}

pub mod PostProcessingLocalContrastParameters_t {
    pub const m_flLocalContrastStrength: usize = 0x0; // float
    pub const m_flLocalContrastEdgeStrength: usize = 0x4; // float
    pub const m_flLocalContrastVignetteStart: usize = 0x8; // float
    pub const m_flLocalContrastVignetteEnd: usize = 0xC; // float
    pub const m_flLocalContrastVignetteBlur: usize = 0x10; // float
}

pub mod PostProcessingResource_t {
    pub const m_bHasTonemapParams: usize = 0x0; // bool
    pub const m_toneMapParams: usize = 0x4; // PostProcessingTonemapParameters_t
    pub const m_bHasBloomParams: usize = 0x40; // bool
    pub const m_bloomParams: usize = 0x44; // PostProcessingBloomParameters_t
    pub const m_bHasVignetteParams: usize = 0xB4; // bool
    pub const m_vignetteParams: usize = 0xB8; // PostProcessingVignetteParameters_t
    pub const m_bHasLocalContrastParams: usize = 0xDC; // bool
    pub const m_localConstrastParams: usize = 0xE0; // PostProcessingLocalContrastParameters_t
    pub const m_nColorCorrectionVolumeDim: usize = 0xF4; // int32_t
    pub const m_colorCorrectionVolumeData: usize = 0xF8; // CUtlBinaryBlock
    pub const m_bHasColorCorrection: usize = 0x110; // bool
}

pub mod PostProcessingTonemapParameters_t {
    pub const m_flExposureBias: usize = 0x0; // float
    pub const m_flShoulderStrength: usize = 0x4; // float
    pub const m_flLinearStrength: usize = 0x8; // float
    pub const m_flLinearAngle: usize = 0xC; // float
    pub const m_flToeStrength: usize = 0x10; // float
    pub const m_flToeNum: usize = 0x14; // float
    pub const m_flToeDenom: usize = 0x18; // float
    pub const m_flWhitePoint: usize = 0x1C; // float
    pub const m_flLuminanceSource: usize = 0x20; // float
    pub const m_flExposureBiasShadows: usize = 0x24; // float
    pub const m_flExposureBiasHighlights: usize = 0x28; // float
    pub const m_flMinShadowLum: usize = 0x2C; // float
    pub const m_flMaxShadowLum: usize = 0x30; // float
    pub const m_flMinHighlightLum: usize = 0x34; // float
    pub const m_flMaxHighlightLum: usize = 0x38; // float
}

pub mod PostProcessingVignetteParameters_t {
    pub const m_flVignetteStrength: usize = 0x0; // float
    pub const m_vCenter: usize = 0x4; // Vector2D
    pub const m_flRadius: usize = 0xC; // float
    pub const m_flRoundness: usize = 0x10; // float
    pub const m_flFeather: usize = 0x14; // float
    pub const m_vColorTint: usize = 0x18; // Vector
}
```

`SDK/networksystem.dll.cs`:

```cs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.189868900 UTC
 */

public static class ChangeAccessorFieldPathIndex_t {
    public const nint m_Value = 0x0; // int16_t
}
```

`SDK/networksystem.dll.hpp`:

```hpp
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.189419100 UTC
 */

#pragma once

#include <cstddef>

namespace ChangeAccessorFieldPathIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int16_t
}
```

`SDK/networksystem.dll.json`:

```json
{
  "ChangeAccessorFieldPathIndex_t": {
    "m_Value": 0
  }
}
```

`SDK/networksystem.dll.py`:

```py
'''
https://github.com/a2x/cs2-dumper
2023-11-23 10:28:25.190473900 UTC
'''

class ChangeAccessorFieldPathIndex_t:
    m_Value = 0x0 # int16_t

```

`SDK/networksystem.dll.rs`:

```rs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.190798 UTC
 */

#![allow(non_snake_case, non_upper_case_globals)]

pub mod ChangeAccessorFieldPathIndex_t {
    pub const m_Value: usize = 0x0; // int16_t
}
```

`SDK/offsets.cs`:

```cs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:28.615054800 UTC
 */

public static class ClientDll {
    public const nint dwBaseEntityModel_setModel = 0x584690;
    public const nint dwEntityList = 0x17B5200;
    public const nint dwForceBackward = 0x16B57E0;
    public const nint dwForceCrouch = 0x16B5AB0;
    public const nint dwForceForward = 0x16B5750;
    public const nint dwForceJump = 0x16B5A20;
    public const nint dwForceLeft = 0x16B5870;
    public const nint dwForceRight = 0x16B5900;
    public const nint dwGameEntitySystem_getBaseEntity = 0x607BE0;
    public const nint dwGameEntitySystem_getHighestEntityIndex = 0x5F9910;
    public const nint dwGameRules = 0x1810EB0;
    public const nint dwGlobalVars = 0x16B1670;
    public const nint dwGlowManager = 0x1810ED8;
    public const nint dwInterfaceLinkList = 0x190E578;
    public const nint dwLocalPlayerController = 0x1804518;
    public const nint dwLocalPlayerPawn = 0x16BC598;
    public const nint dwPlantedC4 = 0x1818478;
    public const nint dwViewAngles = 0x1872890;
    public const nint dwViewMatrix = 0x1813840;
    public const nint dwViewRender = 0x18140C0;
}

public static class Engine2Dll {
    public const nint dwBuildNumber = 0x48B514;
    public const nint dwNetworkGameClient = 0x48AAC0;
    public const nint dwNetworkGameClient_getLocalPlayer = 0xF0;
    public const nint dwNetworkGameClient_maxClients = 0x250;
    public const nint dwNetworkGameClient_signOnState = 0x240;
    public const nint dwWindowHeight = 0x541DBC;
    public const nint dwWindowWidth = 0x541DB8;
}
```

`SDK/offsets.hpp`:

```hpp
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:28.612975800 UTC
 */

#pragma once

#include <cstddef>

namespace ClientDll {
    constexpr std::ptrdiff_t dwBaseEntityModel_setModel = 0x584690;
    constexpr std::ptrdiff_t dwEntityList = 0x17B5200;
    constexpr std::ptrdiff_t dwForceBackward = 0x16B57E0;
    constexpr std::ptrdiff_t dwForceCrouch = 0x16B5AB0;
    constexpr std::ptrdiff_t dwForceForward = 0x16B5750;
    constexpr std::ptrdiff_t dwForceJump = 0x16B5A20;
    constexpr std::ptrdiff_t dwForceLeft = 0x16B5870;
    constexpr std::ptrdiff_t dwForceRight = 0x16B5900;
    constexpr std::ptrdiff_t dwGameEntitySystem_getBaseEntity = 0x607BE0;
    constexpr std::ptrdiff_t dwGameEntitySystem_getHighestEntityIndex = 0x5F9910;
    constexpr std::ptrdiff_t dwGameRules = 0x1810EB0;
    constexpr std::ptrdiff_t dwGlobalVars = 0x16B1670;
    constexpr std::ptrdiff_t dwGlowManager = 0x1810ED8;
    constexpr std::ptrdiff_t dwInterfaceLinkList = 0x190E578;
    constexpr std::ptrdiff_t dwLocalPlayerController = 0x1804518;
    constexpr std::ptrdiff_t dwLocalPlayerPawn = 0x16BC598;
    constexpr std::ptrdiff_t dwPlantedC4 = 0x1818478;
    constexpr std::ptrdiff_t dwViewAngles = 0x1872890;
    constexpr std::ptrdiff_t dwViewMatrix = 0x1813840;
    constexpr std::ptrdiff_t dwViewRender = 0x18140C0;
}

namespace Engine2Dll {
    constexpr std::ptrdiff_t dwBuildNumber = 0x48B514;
    constexpr std::ptrdiff_t dwNetworkGameClient = 0x48AAC0;
    constexpr std::ptrdiff_t dwNetworkGameClient_getLocalPlayer = 0xF0;
    constexpr std::ptrdiff_t dwNetworkGameClient_maxClients = 0x250;
    constexpr std::ptrdiff_t dwNetworkGameClient_signOnState = 0x240;
    constexpr std::ptrdiff_t dwWindowHeight = 0x541DBC;
    constexpr std::ptrdiff_t dwWindowWidth = 0x541DB8;
}
```

`SDK/offsets.json`:

```json
{
  "ClientDll": {
    "dwBaseEntityModel_setModel": 5785232,
    "dwEntityList": 24859136,
    "dwForceBackward": 23812064,
    "dwForceCrouch": 23812784,
    "dwForceForward": 23811920,
    "dwForceJump": 23812640,
    "dwForceLeft": 23812208,
    "dwForceRight": 23812352,
    "dwGameEntitySystem_getBaseEntity": 6323168,
    "dwGameEntitySystem_getHighestEntityIndex": 6265104,
    "dwGameRules": 25235120,
    "dwGlobalVars": 23795312,
    "dwGlowManager": 25235160,
    "dwInterfaceLinkList": 26273144,
    "dwLocalPlayerController": 25183512,
    "dwLocalPlayerPawn": 23840152,
    "dwPlantedC4": 25265272,
    "dwViewAngles": 25634960,
    "dwViewMatrix": 25245760,
    "dwViewRender": 25247936
  },
  "Engine2Dll": {
    "dwBuildNumber": 4764948,
    "dwNetworkGameClient": 4762304,
    "dwNetworkGameClient_getLocalPlayer": 240,
    "dwNetworkGameClient_maxClients": 592,
    "dwNetworkGameClient_signOnState": 576,
    "dwWindowHeight": 5512636,
    "dwWindowWidth": 5512632
  }
}
```

`SDK/offsets.py`:

```py
'''
https://github.com/a2x/cs2-dumper
2023-11-23 10:28:28.617331500 UTC
'''

class ClientDll:
    dwBaseEntityModel_setModel = 0x584690
    dwEntityList = 0x17B5200
    dwForceBackward = 0x16B57E0
    dwForceCrouch = 0x16B5AB0
    dwForceForward = 0x16B5750
    dwForceJump = 0x16B5A20
    dwForceLeft = 0x16B5870
    dwForceRight = 0x16B5900
    dwGameEntitySystem_getBaseEntity = 0x607BE0
    dwGameEntitySystem_getHighestEntityIndex = 0x5F9910
    dwGameRules = 0x1810EB0
    dwGlobalVars = 0x16B1670
    dwGlowManager = 0x1810ED8
    dwInterfaceLinkList = 0x190E578
    dwLocalPlayerController = 0x1804518
    dwLocalPlayerPawn = 0x16BC598
    dwPlantedC4 = 0x1818478
    dwViewAngles = 0x1872890
    dwViewMatrix = 0x1813840
    dwViewRender = 0x18140C0

class Engine2Dll:
    dwBuildNumber = 0x48B514
    dwNetworkGameClient = 0x48AAC0
    dwNetworkGameClient_getLocalPlayer = 0xF0
    dwNetworkGameClient_maxClients = 0x250
    dwNetworkGameClient_signOnState = 0x240
    dwWindowHeight = 0x541DBC
    dwWindowWidth = 0x541DB8

```

`SDK/offsets.rs`:

```rs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:28.619642500 UTC
 */

#![allow(non_snake_case, non_upper_case_globals)]

pub mod ClientDll {
    pub const dwBaseEntityModel_setModel: usize = 0x584690;
    pub const dwEntityList: usize = 0x17B5200;
    pub const dwForceBackward: usize = 0x16B57E0;
    pub const dwForceCrouch: usize = 0x16B5AB0;
    pub const dwForceForward: usize = 0x16B5750;
    pub const dwForceJump: usize = 0x16B5A20;
    pub const dwForceLeft: usize = 0x16B5870;
    pub const dwForceRight: usize = 0x16B5900;
    pub const dwGameEntitySystem_getBaseEntity: usize = 0x607BE0;
    pub const dwGameEntitySystem_getHighestEntityIndex: usize = 0x5F9910;
    pub const dwGameRules: usize = 0x1810EB0;
    pub const dwGlobalVars: usize = 0x16B1670;
    pub const dwGlowManager: usize = 0x1810ED8;
    pub const dwInterfaceLinkList: usize = 0x190E578;
    pub const dwLocalPlayerController: usize = 0x1804518;
    pub const dwLocalPlayerPawn: usize = 0x16BC598;
    pub const dwPlantedC4: usize = 0x1818478;
    pub const dwViewAngles: usize = 0x1872890;
    pub const dwViewMatrix: usize = 0x1813840;
    pub const dwViewRender: usize = 0x18140C0;
}

pub mod Engine2Dll {
    pub const dwBuildNumber: usize = 0x48B514;
    pub const dwNetworkGameClient: usize = 0x48AAC0;
    pub const dwNetworkGameClient_getLocalPlayer: usize = 0xF0;
    pub const dwNetworkGameClient_maxClients: usize = 0x250;
    pub const dwNetworkGameClient_signOnState: usize = 0x240;
    pub const dwWindowHeight: usize = 0x541DBC;
    pub const dwWindowWidth: usize = 0x541DB8;
}
```

`SDK/particles.dll.cs`:

```cs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.838895700 UTC
 */

public static class CBaseRendererSource2 {
    public const nint m_flRadiusScale = 0x200; // CParticleCollectionRendererFloatInput
    public const nint m_flAlphaScale = 0x358; // CParticleCollectionRendererFloatInput
    public const nint m_flRollScale = 0x4B0; // CParticleCollectionRendererFloatInput
    public const nint m_nAlpha2Field = 0x608; // ParticleAttributeIndex_t
    public const nint m_vecColorScale = 0x610; // CParticleCollectionRendererVecInput
    public const nint m_nColorBlendType = 0xC68; // ParticleColorBlendType_t
    public const nint m_nShaderType = 0xC6C; // SpriteCardShaderType_t
    public const nint m_strShaderOverride = 0xC70; // CUtlString
    public const nint m_flCenterXOffset = 0xC78; // CParticleCollectionRendererFloatInput
    public const nint m_flCenterYOffset = 0xDD0; // CParticleCollectionRendererFloatInput
    public const nint m_flBumpStrength = 0xF28; // float
    public const nint m_nCropTextureOverride = 0xF2C; // ParticleSequenceCropOverride_t
    public const nint m_vecTexturesInput = 0xF30; // CUtlVector<TextureGroup_t>
    public const nint m_flAnimationRate = 0xF48; // float
    public const nint m_nAnimationType = 0xF4C; // AnimationType_t
    public const nint m_bAnimateInFPS = 0xF50; // bool
    public const nint m_flSelfIllumAmount = 0xF58; // CParticleCollectionRendererFloatInput
    public const nint m_flDiffuseAmount = 0x10B0; // CParticleCollectionRendererFloatInput
    public const nint m_nLightingControlPoint = 0x1208; // int32_t
    public const nint m_nSelfIllumPerParticle = 0x120C; // ParticleAttributeIndex_t
    public const nint m_nOutputBlendMode = 0x1210; // ParticleOutputBlendMode_t
    public const nint m_bGammaCorrectVertexColors = 0x1214; // bool
    public const nint m_bSaturateColorPreAlphaBlend = 0x1215; // bool
    public const nint m_flAddSelfAmount = 0x1218; // CParticleCollectionRendererFloatInput
    public const nint m_flDesaturation = 0x1370; // CParticleCollectionRendererFloatInput
    public const nint m_flOverbrightFactor = 0x14C8; // CParticleCollectionRendererFloatInput
    public const nint m_nHSVShiftControlPoint = 0x1620; // int32_t
    public const nint m_nFogType = 0x1624; // ParticleFogType_t
    public const nint m_flFogAmount = 0x1628; // CParticleCollectionRendererFloatInput
    public const nint m_bTintByFOW = 0x1780; // bool
    public const nint m_bTintByGlobalLight = 0x1781; // bool
    public const nint m_nPerParticleAlphaReference = 0x1784; // SpriteCardPerParticleScale_t
    public const nint m_nPerParticleAlphaRefWindow = 0x1788; // SpriteCardPerParticleScale_t
    public const nint m_nAlphaReferenceType = 0x178C; // ParticleAlphaReferenceType_t
    public const nint m_flAlphaReferenceSoftness = 0x1790; // CParticleCollectionRendererFloatInput
    public const nint m_flSourceAlphaValueToMapToZero = 0x18E8; // CParticleCollectionRendererFloatInput
    public const nint m_flSourceAlphaValueToMapToOne = 0x1A40; // CParticleCollectionRendererFloatInput
    public const nint m_bRefract = 0x1B98; // bool
    public const nint m_bRefractSolid = 0x1B99; // bool
    public const nint m_flRefractAmount = 0x1BA0; // CParticleCollectionRendererFloatInput
    public const nint m_nRefractBlurRadius = 0x1CF8; // int32_t
    public const nint m_nRefractBlurType = 0x1CFC; // BlurFilterType_t
    public const nint m_bOnlyRenderInEffectsBloomPass = 0x1D00; // bool
    public const nint m_bOnlyRenderInEffectsWaterPass = 0x1D01; // bool
    public const nint m_bUseMixedResolutionRendering = 0x1D02; // bool
    public const nint m_bOnlyRenderInEffecsGameOverlay = 0x1D03; // bool
    public const nint m_stencilTestID = 0x1D04; // char[128]
    public const nint m_bStencilTestExclude = 0x1D84; // bool
    public const nint m_stencilWriteID = 0x1D85; // char[128]
    public const nint m_bWriteStencilOnDepthPass = 0x1E05; // bool
    public const nint m_bWriteStencilOnDepthFail = 0x1E06; // bool
    public const nint m_bReverseZBuffering = 0x1E07; // bool
    public const nint m_bDisableZBuffering = 0x1E08; // bool
    public const nint m_nFeatheringMode = 0x1E0C; // ParticleDepthFeatheringMode_t
    public const nint m_flFeatheringMinDist = 0x1E10; // CParticleCollectionRendererFloatInput
    public const nint m_flFeatheringMaxDist = 0x1F68; // CParticleCollectionRendererFloatInput
    public const nint m_flFeatheringFilter = 0x20C0; // CParticleCollectionRendererFloatInput
    public const nint m_flDepthBias = 0x2218; // float
    public const nint m_nSortMethod = 0x221C; // ParticleSortingChoiceList_t
    public const nint m_bBlendFramesSeq0 = 0x2220; // bool
    public const nint m_bMaxLuminanceBlendingSequence0 = 0x2221; // bool
}

public static class CBaseTrailRenderer {
    public const nint m_nOrientationType = 0x2470; // ParticleOrientationChoiceList_t
    public const nint m_nOrientationControlPoint = 0x2474; // int32_t
    public const nint m_flMinSize = 0x2478; // float
    public const nint m_flMaxSize = 0x247C; // float
    public const nint m_flStartFadeSize = 0x2480; // CParticleCollectionRendererFloatInput
    public const nint m_flEndFadeSize = 0x25D8; // CParticleCollectionRendererFloatInput
    public const nint m_bClampV = 0x2730; // bool
}

public static class CGeneralRandomRotation {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_flDegrees = 0x1C4; // float
    public const nint m_flDegreesMin = 0x1C8; // float
    public const nint m_flDegreesMax = 0x1CC; // float
    public const nint m_flRotationRandExponent = 0x1D0; // float
    public const nint m_bRandomlyFlipDirection = 0x1D4; // bool
}

public static class CGeneralSpin {
    public const nint m_nSpinRateDegrees = 0x1C0; // int32_t
    public const nint m_nSpinRateMinDegrees = 0x1C4; // int32_t
    public const nint m_fSpinRateStopTime = 0x1CC; // float
}

public static class CNewParticleEffect {
    public const nint m_pNext = 0x10; // CNewParticleEffect*
    public const nint m_pPrev = 0x18; // CNewParticleEffect*
    public const nint m_pParticles = 0x20; // IParticleCollection*
    public const nint m_pDebugName = 0x28; // char*
    public const nint m_bDontRemove = 0x0; // bitfield:1
    public const nint m_bRemove = 0x0; // bitfield:1
    public const nint m_bNeedsBBoxUpdate = 0x0; // bitfield:1
    public const nint m_bIsFirstFrame = 0x0; // bitfield:1
    public const nint m_bAutoUpdateBBox = 0x0; // bitfield:1
    public const nint m_bAllocated = 0x0; // bitfield:1
    public const nint m_bSimulate = 0x0; // bitfield:1
    public const nint m_bShouldPerformCullCheck = 0x0; // bitfield:1
    public const nint m_bForceNoDraw = 0x0; // bitfield:1
    public const nint m_bShouldSave = 0x0; // bitfield:1
    public const nint m_bDisableAggregation = 0x0; // bitfield:1
    public const nint m_bShouldSimulateDuringGamePaused = 0x0; // bitfield:1
    public const nint m_bShouldCheckFoW = 0x0; // bitfield:1
    public const nint m_vSortOrigin = 0x40; // Vector
    public const nint m_flScale = 0x4C; // float
    public const nint m_hOwner = 0x50; // PARTICLE_EHANDLE__*
    public const nint m_pOwningParticleProperty = 0x58; // CParticleProperty*
    public const nint m_flFreezeTransitionStart = 0x70; // float
    public const nint m_flFreezeTransitionDuration = 0x74; // float
    public const nint m_flFreezeTransitionOverride = 0x78; // float
    public const nint m_bFreezeTransitionActive = 0x7C; // bool
    public const nint m_bFreezeTargetState = 0x7D; // bool
    public const nint m_bCanFreeze = 0x7E; // bool
    public const nint m_LastMin = 0x80; // Vector
    public const nint m_LastMax = 0x8C; // Vector
    public const nint m_nSplitScreenUser = 0x98; // CSplitScreenSlot
    public const nint m_vecAggregationCenter = 0x9C; // Vector
    public const nint m_RefCount = 0xC0; // int32_t
}

public static class CParticleFloatInput {
    public const nint m_nType = 0x10; // ParticleFloatType_t
    public const nint m_nMapType = 0x14; // ParticleFloatMapType_t
    public const nint m_flLiteralValue = 0x18; // float
    public const nint m_NamedValue = 0x20; // CParticleNamedValueRef
    public const nint m_nControlPoint = 0x60; // int32_t
    public const nint m_nScalarAttribute = 0x64; // ParticleAttributeIndex_t
    public const nint m_nVectorAttribute = 0x68; // ParticleAttributeIndex_t
    public const nint m_nVectorComponent = 0x6C; // int32_t
    public const nint m_flRandomMin = 0x70; // float
    public const nint m_flRandomMax = 0x74; // float
    public const nint m_bHasRandomSignFlip = 0x78; // bool
    public const nint m_nRandomSeed = 0x7C; // int32_t
    public const nint m_nRandomMode = 0x80; // ParticleFloatRandomMode_t
    public const nint m_flLOD0 = 0x88; // float
    public const nint m_flLOD1 = 0x8C; // float
    public const nint m_flLOD2 = 0x90; // float
    public const nint m_flLOD3 = 0x94; // float
    public const nint m_nNoiseInputVectorAttribute = 0x98; // ParticleAttributeIndex_t
    public const nint m_flNoiseOutputMin = 0x9C; // float
    public const nint m_flNoiseOutputMax = 0xA0; // float
    public const nint m_flNoiseScale = 0xA4; // float
    public const nint m_vecNoiseOffsetRate = 0xA8; // Vector
    public const nint m_flNoiseOffset = 0xB4; // float
    public const nint m_nNoiseOctaves = 0xB8; // int32_t
    public const nint m_nNoiseTurbulence = 0xBC; // PFNoiseTurbulence_t
    public const nint m_nNoiseType = 0xC0; // PFNoiseType_t
    public const nint m_nNoiseModifier = 0xC4; // PFNoiseModifier_t
    public const nint m_flNoiseTurbulenceScale = 0xC8; // float
    public const nint m_flNoiseTurbulenceMix = 0xCC; // float
    public const nint m_flNoiseImgPreviewScale = 0xD0; // float
    public const nint m_bNoiseImgPreviewLive = 0xD4; // bool
    public const nint m_flNoCameraFallback = 0xE0; // float
    public const nint m_bUseBoundsCenter = 0xE4; // bool
    public const nint m_nInputMode = 0xE8; // ParticleFloatInputMode_t
    public const nint m_flMultFactor = 0xEC; // float
    public const nint m_flInput0 = 0xF0; // float
    public const nint m_flInput1 = 0xF4; // float
    public const nint m_flOutput0 = 0xF8; // float
    public const nint m_flOutput1 = 0xFC; // float
    public const nint m_flNotchedRangeMin = 0x100; // float
    public const nint m_flNotchedRangeMax = 0x104; // float
    public const nint m_flNotchedOutputOutside = 0x108; // float
    public const nint m_flNotchedOutputInside = 0x10C; // float
    public const nint m_nBiasType = 0x110; // ParticleFloatBiasType_t
    public const nint m_flBiasParameter = 0x114; // float
    public const nint m_Curve = 0x118; // CPiecewiseCurve
}

public static class CParticleFunction {
    public const nint m_flOpStrength = 0x8; // CParticleCollectionFloatInput
    public const nint m_nOpEndCapState = 0x160; // ParticleEndcapMode_t
    public const nint m_flOpStartFadeInTime = 0x164; // float
    public const nint m_flOpEndFadeInTime = 0x168; // float
    public const nint m_flOpStartFadeOutTime = 0x16C; // float
    public const nint m_flOpEndFadeOutTime = 0x170; // float
    public const nint m_flOpFadeOscillatePeriod = 0x174; // float
    public const nint m_bNormalizeToStopTime = 0x178; // bool
    public const nint m_flOpTimeOffsetMin = 0x17C; // float
    public const nint m_flOpTimeOffsetMax = 0x180; // float
    public const nint m_nOpTimeOffsetSeed = 0x184; // int32_t
    public const nint m_nOpTimeScaleSeed = 0x188; // int32_t
    public const nint m_flOpTimeScaleMin = 0x18C; // float
    public const nint m_flOpTimeScaleMax = 0x190; // float
    public const nint m_bDisableOperator = 0x196; // bool
    public const nint m_Notes = 0x198; // CUtlString
}

public static class CParticleFunctionEmitter {
    public const nint m_nEmitterIndex = 0x1B8; // int32_t
}

public static class CParticleFunctionInitializer {
    public const nint m_nAssociatedEmitterIndex = 0x1B8; // int32_t
}

public static class CParticleFunctionPreEmission {
    public const nint m_bRunOnce = 0x1C0; // bool
}

public static class CParticleFunctionRenderer {
    public const nint VisibilityInputs = 0x1B8; // CParticleVisibilityInputs
    public const nint m_bCannotBeRefracted = 0x1FC; // bool
    public const nint m_bSkipRenderingOnMobile = 0x1FD; // bool
}

public static class CParticleModelInput {
    public const nint m_nType = 0x10; // ParticleModelType_t
    public const nint m_NamedValue = 0x18; // CParticleNamedValueRef
    public const nint m_nControlPoint = 0x58; // int32_t
}

public static class CParticleSystemDefinition {
    public const nint m_nBehaviorVersion = 0x8; // int32_t
    public const nint m_PreEmissionOperators = 0x10; // CUtlVector<CParticleFunctionPreEmission*>
    public const nint m_Emitters = 0x28; // CUtlVector<CParticleFunctionEmitter*>
    public const nint m_Initializers = 0x40; // CUtlVector<CParticleFunctionInitializer*>
    public const nint m_Operators = 0x58; // CUtlVector<CParticleFunctionOperator*>
    public const nint m_ForceGenerators = 0x70; // CUtlVector<CParticleFunctionForce*>
    public const nint m_Constraints = 0x88; // CUtlVector<CParticleFunctionConstraint*>
    public const nint m_Renderers = 0xA0; // CUtlVector<CParticleFunctionRenderer*>
    public const nint m_Children = 0xB8; // CUtlVector<ParticleChildrenInfo_t>
    public const nint m_nFirstMultipleOverride_BackwardCompat = 0x178; // int32_t
    public const nint m_nInitialParticles = 0x210; // int32_t
    public const nint m_nMaxParticles = 0x214; // int32_t
    public const nint m_nGroupID = 0x218; // int32_t
    public const nint m_BoundingBoxMin = 0x21C; // Vector
    public const nint m_BoundingBoxMax = 0x228; // Vector
    public const nint m_flDepthSortBias = 0x234; // float
    public const nint m_nSortOverridePositionCP = 0x238; // int32_t
    public const nint m_bInfiniteBounds = 0x23C; // bool
    public const nint m_bEnableNamedValues = 0x23D; // bool
    public const nint m_NamedValueDomain = 0x240; // CUtlString
    public const nint m_NamedValueLocals = 0x248; // CUtlVector<ParticleNamedValueSource_t*>
    public const nint m_ConstantColor = 0x260; // Color
    public const nint m_ConstantNormal = 0x264; // Vector
    public const nint m_flConstantRadius = 0x270; // float
    public const nint m_flConstantRotation = 0x274; // float
    public const nint m_flConstantRotationSpeed = 0x278; // float
    public const nint m_flConstantLifespan = 0x27C; // float
    public const nint m_nConstantSequenceNumber = 0x280; // int32_t
    public const nint m_nConstantSequenceNumber1 = 0x284; // int32_t
    public const nint m_nSnapshotControlPoint = 0x288; // int32_t
    public const nint m_hSnapshot = 0x290; // CStrongHandle<InfoForResourceTypeIParticleSnapshot>
    public const nint m_pszCullReplacementName = 0x298; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    public const nint m_flCullRadius = 0x2A0; // float
    public const nint m_flCullFillCost = 0x2A4; // float
    public const nint m_nCullControlPoint = 0x2A8; // int32_t
    public const nint m_hFallback = 0x2B0; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    public const nint m_nFallbackMaxCount = 0x2B8; // int32_t
    public const nint m_hLowViolenceDef = 0x2C0; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    public const nint m_hReferenceReplacement = 0x2C8; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    public const nint m_flPreSimulationTime = 0x2D0; // float
    public const nint m_flStopSimulationAfterTime = 0x2D4; // float
    public const nint m_flMaximumTimeStep = 0x2D8; // float
    public const nint m_flMaximumSimTime = 0x2DC; // float
    public const nint m_flMinimumSimTime = 0x2E0; // float
    public const nint m_flMinimumTimeStep = 0x2E4; // float
    public const nint m_nMinimumFrames = 0x2E8; // int32_t
    public const nint m_nMinCPULevel = 0x2EC; // int32_t
    public const nint m_nMinGPULevel = 0x2F0; // int32_t
    public const nint m_flNoDrawTimeToGoToSleep = 0x2F4; // float
    public const nint m_flMaxDrawDistance = 0x2F8; // float
    public const nint m_flStartFadeDistance = 0x2FC; // float
    public const nint m_flMaxCreationDistance = 0x300; // float
    public const nint m_nAggregationMinAvailableParticles = 0x304; // int32_t
    public const nint m_flAggregateRadius = 0x308; // float
    public const nint m_bShouldBatch = 0x30C; // bool
    public const nint m_bShouldHitboxesFallbackToRenderBounds = 0x30D; // bool
    public const nint m_bShouldHitboxesFallbackToSnapshot = 0x30E; // bool
    public const nint m_nViewModelEffect = 0x310; // InheritableBoolType_t
    public const nint m_bScreenSpaceEffect = 0x314; // bool
    public const nint m_pszTargetLayerID = 0x318; // CUtlSymbolLarge
    public const nint m_nSkipRenderControlPoint = 0x320; // int32_t
    public const nint m_nAllowRenderControlPoint = 0x324; // int32_t
    public const nint m_bShouldSort = 0x328; // bool
    public const nint m_controlPointConfigurations = 0x370; // CUtlVector<ParticleControlPointConfiguration_t>
}

public static class CParticleTransformInput {
    public const nint m_nType = 0x10; // ParticleTransformType_t
    public const nint m_NamedValue = 0x18; // CParticleNamedValueRef
    public const nint m_bFollowNamedValue = 0x58; // bool
    public const nint m_bSupportsDisabled = 0x59; // bool
    public const nint m_bUseOrientation = 0x5A; // bool
    public const nint m_nControlPoint = 0x5C; // int32_t
    public const nint m_nControlPointRangeMax = 0x60; // int32_t
    public const nint m_flEndCPGrowthTime = 0x64; // float
}

public static class CParticleVariableRef {
    public const nint m_variableName = 0x0; // CKV3MemberNameWithStorage
    public const nint m_variableType = 0x38; // PulseValueType_t
}

public static class CParticleVecInput {
    public const nint m_nType = 0x10; // ParticleVecType_t
    public const nint m_vLiteralValue = 0x14; // Vector
    public const nint m_LiteralColor = 0x20; // Color
    public const nint m_NamedValue = 0x28; // CParticleNamedValueRef
    public const nint m_bFollowNamedValue = 0x68; // bool
    public const nint m_nVectorAttribute = 0x6C; // ParticleAttributeIndex_t
    public const nint m_vVectorAttributeScale = 0x70; // Vector
    public const nint m_nControlPoint = 0x7C; // int32_t
    public const nint m_nDeltaControlPoint = 0x80; // int32_t
    public const nint m_vCPValueScale = 0x84; // Vector
    public const nint m_vCPRelativePosition = 0x90; // Vector
    public const nint m_vCPRelativeDir = 0x9C; // Vector
    public const nint m_FloatComponentX = 0xA8; // CParticleFloatInput
    public const nint m_FloatComponentY = 0x200; // CParticleFloatInput
    public const nint m_FloatComponentZ = 0x358; // CParticleFloatInput
    public const nint m_FloatInterp = 0x4B0; // CParticleFloatInput
    public const nint m_flInterpInput0 = 0x608; // float
    public const nint m_flInterpInput1 = 0x60C; // float
    public const nint m_vInterpOutput0 = 0x610; // Vector
    public const nint m_vInterpOutput1 = 0x61C; // Vector
    public const nint m_Gradient = 0x628; // CColorGradient
    public const nint m_vRandomMin = 0x640; // Vector
    public const nint m_vRandomMax = 0x64C; // Vector
}

public static class CParticleVisibilityInputs {
    public const nint m_flCameraBias = 0x0; // float
    public const nint m_nCPin = 0x4; // int32_t
    public const nint m_flProxyRadius = 0x8; // float
    public const nint m_flInputMin = 0xC; // float
    public const nint m_flInputMax = 0x10; // float
    public const nint m_flNoPixelVisibilityFallback = 0x14; // float
    public const nint m_flDistanceInputMin = 0x18; // float
    public const nint m_flDistanceInputMax = 0x1C; // float
    public const nint m_flDotInputMin = 0x20; // float
    public const nint m_flDotInputMax = 0x24; // float
    public const nint m_bDotCPAngles = 0x28; // bool
    public const nint m_bDotCameraAngles = 0x29; // bool
    public const nint m_flAlphaScaleMin = 0x2C; // float
    public const nint m_flAlphaScaleMax = 0x30; // float
    public const nint m_flRadiusScaleMin = 0x34; // float
    public const nint m_flRadiusScaleMax = 0x38; // float
    public const nint m_flRadiusScaleFOVBase = 0x3C; // float
    public const nint m_bRightEye = 0x40; // bool
}

public static class CPathParameters {
    public const nint m_nStartControlPointNumber = 0x0; // int32_t
    public const nint m_nEndControlPointNumber = 0x4; // int32_t
    public const nint m_nBulgeControl = 0x8; // int32_t
    public const nint m_flBulge = 0xC; // float
    public const nint m_flMidPoint = 0x10; // float
    public const nint m_vStartPointOffset = 0x14; // Vector
    public const nint m_vMidPointOffset = 0x20; // Vector
    public const nint m_vEndOffset = 0x2C; // Vector
}

public static class CRandomNumberGeneratorParameters {
    public const nint m_bDistributeEvenly = 0x0; // bool
    public const nint m_nSeed = 0x4; // int32_t
}

public static class C_INIT_AddVectorToVector {
    public const nint m_vecScale = 0x1C0; // Vector
    public const nint m_nFieldOutput = 0x1CC; // ParticleAttributeIndex_t
    public const nint m_nFieldInput = 0x1D0; // ParticleAttributeIndex_t
    public const nint m_vOffsetMin = 0x1D4; // Vector
    public const nint m_vOffsetMax = 0x1E0; // Vector
    public const nint m_randomnessParameters = 0x1EC; // CRandomNumberGeneratorParameters
}

public static class C_INIT_AgeNoise {
    public const nint m_bAbsVal = 0x1C0; // bool
    public const nint m_bAbsValInv = 0x1C1; // bool
    public const nint m_flOffset = 0x1C4; // float
    public const nint m_flAgeMin = 0x1C8; // float
    public const nint m_flAgeMax = 0x1CC; // float
    public const nint m_flNoiseScale = 0x1D0; // float
    public const nint m_flNoiseScaleLoc = 0x1D4; // float
    public const nint m_vecOffsetLoc = 0x1D8; // Vector
}

public static class C_INIT_ChaoticAttractor {
    public const nint m_flAParm = 0x1C0; // float
    public const nint m_flBParm = 0x1C4; // float
    public const nint m_flCParm = 0x1C8; // float
    public const nint m_flDParm = 0x1CC; // float
    public const nint m_flScale = 0x1D0; // float
    public const nint m_flSpeedMin = 0x1D4; // float
    public const nint m_flSpeedMax = 0x1D8; // float
    public const nint m_nBaseCP = 0x1DC; // int32_t
    public const nint m_bUniformSpeed = 0x1E0; // bool
}

public static class C_INIT_ColorLitPerParticle {
    public const nint m_ColorMin = 0x1D8; // Color
    public const nint m_ColorMax = 0x1DC; // Color
    public const nint m_TintMin = 0x1E0; // Color
    public const nint m_TintMax = 0x1E4; // Color
    public const nint m_flTintPerc = 0x1E8; // float
    public const nint m_nTintBlendMode = 0x1EC; // ParticleColorBlendMode_t
    public const nint m_flLightAmplification = 0x1F0; // float
}

public static class C_INIT_CreateAlongPath {
    public const nint m_fMaxDistance = 0x1C0; // float
    public const nint m_PathParams = 0x1D0; // CPathParameters
    public const nint m_bUseRandomCPs = 0x210; // bool
    public const nint m_vEndOffset = 0x214; // Vector
    public const nint m_bSaveOffset = 0x220; // bool
}

public static class C_INIT_CreateFromCPs {
    public const nint m_nIncrement = 0x1C0; // int32_t
    public const nint m_nMinCP = 0x1C4; // int32_t
    public const nint m_nMaxCP = 0x1C8; // int32_t
    public const nint m_nDynamicCPCount = 0x1D0; // CParticleCollectionFloatInput
}

public static class C_INIT_CreateFromParentParticles {
    public const nint m_flVelocityScale = 0x1C0; // float
    public const nint m_flIncrement = 0x1C4; // float
    public const nint m_bRandomDistribution = 0x1C8; // bool
    public const nint m_nRandomSeed = 0x1CC; // int32_t
    public const nint m_bSubFrame = 0x1D0; // bool
}

public static class C_INIT_CreateFromPlaneCache {
    public const nint m_vecOffsetMin = 0x1C0; // Vector
    public const nint m_vecOffsetMax = 0x1CC; // Vector
    public const nint m_bUseNormal = 0x1D9; // bool
}

public static class C_INIT_CreateInEpitrochoid {
    public const nint m_nComponent1 = 0x1C0; // int32_t
    public const nint m_nComponent2 = 0x1C4; // int32_t
    public const nint m_TransformInput = 0x1C8; // CParticleTransformInput
    public const nint m_flParticleDensity = 0x230; // CPerParticleFloatInput
    public const nint m_flOffset = 0x388; // CPerParticleFloatInput
    public const nint m_flRadius1 = 0x4E0; // CPerParticleFloatInput
    public const nint m_flRadius2 = 0x638; // CPerParticleFloatInput
    public const nint m_bUseCount = 0x790; // bool
    public const nint m_bUseLocalCoords = 0x791; // bool
    public const nint m_bOffsetExistingPos = 0x792; // bool
}

public static class C_INIT_CreateOnGrid {
    public const nint m_nXCount = 0x1C0; // CParticleCollectionFloatInput
    public const nint m_nYCount = 0x318; // CParticleCollectionFloatInput
    public const nint m_nZCount = 0x470; // CParticleCollectionFloatInput
    public const nint m_nXSpacing = 0x5C8; // CParticleCollectionFloatInput
    public const nint m_nYSpacing = 0x720; // CParticleCollectionFloatInput
    public const nint m_nZSpacing = 0x878; // CParticleCollectionFloatInput
    public const nint m_nControlPointNumber = 0x9D0; // int32_t
    public const nint m_bLocalSpace = 0x9D4; // bool
    public const nint m_bCenter = 0x9D5; // bool
    public const nint m_bHollow = 0x9D6; // bool
}

public static class C_INIT_CreateOnModel {
    public const nint m_modelInput = 0x1C0; // CParticleModelInput
    public const nint m_transformInput = 0x220; // CParticleTransformInput
    public const nint m_nForceInModel = 0x288; // int32_t
    public const nint m_nDesiredHitbox = 0x28C; // int32_t
    public const nint m_nHitboxValueFromControlPointIndex = 0x290; // int32_t
    public const nint m_vecHitBoxScale = 0x298; // CParticleCollectionVecInput
    public const nint m_flBoneVelocity = 0x8F0; // float
    public const nint m_flMaxBoneVelocity = 0x8F4; // float
    public const nint m_vecDirectionBias = 0x8F8; // CParticleCollectionVecInput
    public const nint m_HitboxSetName = 0xF50; // char[128]
    public const nint m_bLocalCoords = 0xFD0; // bool
    public const nint m_bUseBones = 0xFD1; // bool
    public const nint m_flShellSize = 0xFD8; // CParticleCollectionFloatInput
}

public static class C_INIT_CreateOnModelAtHeight {
    public const nint m_bUseBones = 0x1C0; // bool
    public const nint m_bForceZ = 0x1C1; // bool
    public const nint m_nControlPointNumber = 0x1C4; // int32_t
    public const nint m_nHeightCP = 0x1C8; // int32_t
    public const nint m_bUseWaterHeight = 0x1CC; // bool
    public const nint m_flDesiredHeight = 0x1D0; // CParticleCollectionFloatInput
    public const nint m_vecHitBoxScale = 0x328; // CParticleCollectionVecInput
    public const nint m_vecDirectionBias = 0x980; // CParticleCollectionVecInput
    public const nint m_nBiasType = 0xFD8; // ParticleHitboxBiasType_t
    public const nint m_bLocalCoords = 0xFDC; // bool
    public const nint m_bPreferMovingBoxes = 0xFDD; // bool
    public const nint m_HitboxSetName = 0xFDE; // char[128]
    public const nint m_flHitboxVelocityScale = 0x1060; // CParticleCollectionFloatInput
    public const nint m_flMaxBoneVelocity = 0x11B8; // CParticleCollectionFloatInput
}

public static class C_INIT_CreateParticleImpulse {
    public const nint m_InputRadius = 0x1C0; // CPerParticleFloatInput
    public const nint m_InputMagnitude = 0x318; // CPerParticleFloatInput
    public const nint m_nFalloffFunction = 0x470; // ParticleFalloffFunction_t
    public const nint m_InputFalloffExp = 0x478; // CPerParticleFloatInput
    public const nint m_nImpulseType = 0x5D0; // ParticleImpulseType_t
}

public static class C_INIT_CreatePhyllotaxis {
    public const nint m_nControlPointNumber = 0x1C0; // int32_t
    public const nint m_nScaleCP = 0x1C4; // int32_t
    public const nint m_nComponent = 0x1C8; // int32_t
    public const nint m_fRadCentCore = 0x1CC; // float
    public const nint m_fRadPerPoint = 0x1D0; // float
    public const nint m_fRadPerPointTo = 0x1D4; // float
    public const nint m_fpointAngle = 0x1D8; // float
    public const nint m_fsizeOverall = 0x1DC; // float
    public const nint m_fRadBias = 0x1E0; // float
    public const nint m_fMinRad = 0x1E4; // float
    public const nint m_fDistBias = 0x1E8; // float
    public const nint m_bUseLocalCoords = 0x1EC; // bool
    public const nint m_bUseWithContEmit = 0x1ED; // bool
    public const nint m_bUseOrigRadius = 0x1EE; // bool
}

public static class C_INIT_CreateSequentialPath {
    public const nint m_fMaxDistance = 0x1C0; // float
    public const nint m_flNumToAssign = 0x1C4; // float
    public const nint m_bLoop = 0x1C8; // bool
    public const nint m_bCPPairs = 0x1C9; // bool
    public const nint m_bSaveOffset = 0x1CA; // bool
    public const nint m_PathParams = 0x1D0; // CPathParameters
}

public static class C_INIT_CreateSequentialPathV2 {
    public const nint m_fMaxDistance = 0x1C0; // CPerParticleFloatInput
    public const nint m_flNumToAssign = 0x318; // CParticleCollectionFloatInput
    public const nint m_bLoop = 0x470; // bool
    public const nint m_bCPPairs = 0x471; // bool
    public const nint m_bSaveOffset = 0x472; // bool
    public const nint m_PathParams = 0x480; // CPathParameters
}

public static class C_INIT_CreateSpiralSphere {
    public const nint m_nControlPointNumber = 0x1C0; // int32_t
    public const nint m_nOverrideCP = 0x1C4; // int32_t
    public const nint m_nDensity = 0x1C8; // int32_t
    public const nint m_flInitialRadius = 0x1CC; // float
    public const nint m_flInitialSpeedMin = 0x1D0; // float
    public const nint m_flInitialSpeedMax = 0x1D4; // float
    public const nint m_bUseParticleCount = 0x1D8; // bool
}

public static class C_INIT_CreateWithinBox {
    public const nint m_vecMin = 0x1C0; // CPerParticleVecInput
    public const nint m_vecMax = 0x818; // CPerParticleVecInput
    public const nint m_nControlPointNumber = 0xE70; // int32_t
    public const nint m_bLocalSpace = 0xE74; // bool
    public const nint m_randomnessParameters = 0xE78; // CRandomNumberGeneratorParameters
}

public static class C_INIT_CreateWithinSphereTransform {
    public const nint m_fRadiusMin = 0x1C0; // CPerParticleFloatInput
    public const nint m_fRadiusMax = 0x318; // CPerParticleFloatInput
    public const nint m_vecDistanceBias = 0x470; // CPerParticleVecInput
    public const nint m_vecDistanceBiasAbs = 0xAC8; // Vector
    public const nint m_TransformInput = 0xAD8; // CParticleTransformInput
    public const nint m_fSpeedMin = 0xB40; // CPerParticleFloatInput
    public const nint m_fSpeedMax = 0xC98; // CPerParticleFloatInput
    public const nint m_fSpeedRandExp = 0xDF0; // float
    public const nint m_bLocalCoords = 0xDF4; // bool
    public const nint m_flEndCPGrowthTime = 0xDF8; // float
    public const nint m_LocalCoordinateSystemSpeedMin = 0xE00; // CPerParticleVecInput
    public const nint m_LocalCoordinateSystemSpeedMax = 0x1458; // CPerParticleVecInput
    public const nint m_nFieldOutput = 0x1AB0; // ParticleAttributeIndex_t
    public const nint m_nFieldVelocity = 0x1AB4; // ParticleAttributeIndex_t
}

public static class C_INIT_CreationNoise {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_bAbsVal = 0x1C4; // bool
    public const nint m_bAbsValInv = 0x1C5; // bool
    public const nint m_flOffset = 0x1C8; // float
    public const nint m_flOutputMin = 0x1CC; // float
    public const nint m_flOutputMax = 0x1D0; // float
    public const nint m_flNoiseScale = 0x1D4; // float
    public const nint m_flNoiseScaleLoc = 0x1D8; // float
    public const nint m_vecOffsetLoc = 0x1DC; // Vector
    public const nint m_flWorldTimeScale = 0x1E8; // float
}

public static class C_INIT_DistanceCull {
    public const nint m_nControlPoint = 0x1C0; // int32_t
    public const nint m_flDistance = 0x1C8; // CParticleCollectionFloatInput
    public const nint m_bCullInside = 0x320; // bool
}

public static class C_INIT_DistanceToCPInit {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_flInputMin = 0x1C8; // CPerParticleFloatInput
    public const nint m_flInputMax = 0x320; // CPerParticleFloatInput
    public const nint m_flOutputMin = 0x478; // CPerParticleFloatInput
    public const nint m_flOutputMax = 0x5D0; // CPerParticleFloatInput
    public const nint m_nStartCP = 0x728; // int32_t
    public const nint m_bLOS = 0x72C; // bool
    public const nint m_CollisionGroupName = 0x72D; // char[128]
    public const nint m_nTraceSet = 0x7B0; // ParticleTraceSet_t
    public const nint m_flMaxTraceLength = 0x7B8; // CPerParticleFloatInput
    public const nint m_flLOSScale = 0x910; // float
    public const nint m_nSetMethod = 0x914; // ParticleSetMethod_t
    public const nint m_bActiveRange = 0x918; // bool
    public const nint m_vecDistanceScale = 0x91C; // Vector
    public const nint m_flRemapBias = 0x928; // float
}

public static class C_INIT_DistanceToNeighborCull {
    public const nint m_flDistance = 0x1C0; // CPerParticleFloatInput
}

public static class C_INIT_GlobalScale {
    public const nint m_flScale = 0x1C0; // float
    public const nint m_nScaleControlPointNumber = 0x1C4; // int32_t
    public const nint m_nControlPointNumber = 0x1C8; // int32_t
    public const nint m_bScaleRadius = 0x1CC; // bool
    public const nint m_bScalePosition = 0x1CD; // bool
    public const nint m_bScaleVelocity = 0x1CE; // bool
}

public static class C_INIT_InheritFromParentParticles {
    public const nint m_flScale = 0x1C0; // float
    public const nint m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    public const nint m_nIncrement = 0x1C8; // int32_t
    public const nint m_bRandomDistribution = 0x1CC; // bool
    public const nint m_nRandomSeed = 0x1D0; // int32_t
}

public static class C_INIT_InheritVelocity {
    public const nint m_nControlPointNumber = 0x1C0; // int32_t
    public const nint m_flVelocityScale = 0x1C4; // float
}

public static class C_INIT_InitFloat {
    public const nint m_InputValue = 0x1C0; // CPerParticleFloatInput
    public const nint m_nOutputField = 0x318; // ParticleAttributeIndex_t
    public const nint m_nSetMethod = 0x31C; // ParticleSetMethod_t
    public const nint m_InputStrength = 0x320; // CPerParticleFloatInput
}

public static class C_INIT_InitFloatCollection {
    public const nint m_InputValue = 0x1C0; // CParticleCollectionFloatInput
    public const nint m_nOutputField = 0x318; // ParticleAttributeIndex_t
}

public static class C_INIT_InitFromCPSnapshot {
    public const nint m_nControlPointNumber = 0x1C0; // int32_t
    public const nint m_nAttributeToRead = 0x1C4; // ParticleAttributeIndex_t
    public const nint m_nAttributeToWrite = 0x1C8; // ParticleAttributeIndex_t
    public const nint m_nLocalSpaceCP = 0x1CC; // int32_t
    public const nint m_bRandom = 0x1D0; // bool
    public const nint m_bReverse = 0x1D1; // bool
    public const nint m_nSnapShotIncrement = 0x1D8; // CParticleCollectionFloatInput
    public const nint m_nManualSnapshotIndex = 0x330; // CPerParticleFloatInput
    public const nint m_nRandomSeed = 0x488; // int32_t
    public const nint m_bLocalSpaceAngles = 0x48C; // bool
}

public static class C_INIT_InitFromParentKilled {
    public const nint m_nAttributeToCopy = 0x1C0; // ParticleAttributeIndex_t
}

public static class C_INIT_InitFromVectorFieldSnapshot {
    public const nint m_nControlPointNumber = 0x1C0; // int32_t
    public const nint m_nLocalSpaceCP = 0x1C4; // int32_t
    public const nint m_nWeightUpdateCP = 0x1C8; // int32_t
    public const nint m_bUseVerticalVelocity = 0x1CC; // bool
    public const nint m_vecScale = 0x1D0; // CPerParticleVecInput
}

public static class C_INIT_InitSkinnedPositionFromCPSnapshot {
    public const nint m_nSnapshotControlPointNumber = 0x1C0; // int32_t
    public const nint m_nControlPointNumber = 0x1C4; // int32_t
    public const nint m_bRandom = 0x1C8; // bool
    public const nint m_nRandomSeed = 0x1CC; // int32_t
    public const nint m_bRigid = 0x1D0; // bool
    public const nint m_bSetNormal = 0x1D1; // bool
    public const nint m_bIgnoreDt = 0x1D2; // bool
    public const nint m_flMinNormalVelocity = 0x1D4; // float
    public const nint m_flMaxNormalVelocity = 0x1D8; // float
    public const nint m_flIncrement = 0x1DC; // float
    public const nint m_nFullLoopIncrement = 0x1E0; // int32_t
    public const nint m_nSnapShotStartPoint = 0x1E4; // int32_t
    public const nint m_flBoneVelocity = 0x1E8; // float
    public const nint m_flBoneVelocityMax = 0x1EC; // float
    public const nint m_bCopyColor = 0x1F0; // bool
    public const nint m_bCopyAlpha = 0x1F1; // bool
    public const nint m_bSetRadius = 0x1F2; // bool
}

public static class C_INIT_InitVec {
    public const nint m_InputValue = 0x1C0; // CPerParticleVecInput
    public const nint m_nOutputField = 0x818; // ParticleAttributeIndex_t
    public const nint m_nSetMethod = 0x81C; // ParticleSetMethod_t
    public const nint m_bNormalizedOutput = 0x820; // bool
    public const nint m_bWritePreviousPosition = 0x821; // bool
}

public static class C_INIT_InitVecCollection {
    public const nint m_InputValue = 0x1C0; // CParticleCollectionVecInput
    public const nint m_nOutputField = 0x818; // ParticleAttributeIndex_t
}

public static class C_INIT_InitialRepulsionVelocity {
    public const nint m_CollisionGroupName = 0x1C0; // char[128]
    public const nint m_nTraceSet = 0x240; // ParticleTraceSet_t
    public const nint m_vecOutputMin = 0x244; // Vector
    public const nint m_vecOutputMax = 0x250; // Vector
    public const nint m_nControlPointNumber = 0x25C; // int32_t
    public const nint m_bPerParticle = 0x260; // bool
    public const nint m_bTranslate = 0x261; // bool
    public const nint m_bProportional = 0x262; // bool
    public const nint m_flTraceLength = 0x264; // float
    public const nint m_bPerParticleTR = 0x268; // bool
    public const nint m_bInherit = 0x269; // bool
    public const nint m_nChildCP = 0x26C; // int32_t
    public const nint m_nChildGroupID = 0x270; // int32_t
}

public static class C_INIT_InitialSequenceFromModel {
    public const nint m_nControlPointNumber = 0x1C0; // int32_t
    public const nint m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    public const nint m_nFieldOutputAnim = 0x1C8; // ParticleAttributeIndex_t
    public const nint m_flInputMin = 0x1CC; // float
    public const nint m_flInputMax = 0x1D0; // float
    public const nint m_flOutputMin = 0x1D4; // float
    public const nint m_flOutputMax = 0x1D8; // float
    public const nint m_nSetMethod = 0x1DC; // ParticleSetMethod_t
}

public static class C_INIT_InitialVelocityFromHitbox {
    public const nint m_flVelocityMin = 0x1C0; // float
    public const nint m_flVelocityMax = 0x1C4; // float
    public const nint m_nControlPointNumber = 0x1C8; // int32_t
    public const nint m_HitboxSetName = 0x1CC; // char[128]
    public const nint m_bUseBones = 0x24C; // bool
}

public static class C_INIT_InitialVelocityNoise {
    public const nint m_vecAbsVal = 0x1C0; // Vector
    public const nint m_vecAbsValInv = 0x1CC; // Vector
    public const nint m_vecOffsetLoc = 0x1D8; // CPerParticleVecInput
    public const nint m_flOffset = 0x830; // CPerParticleFloatInput
    public const nint m_vecOutputMin = 0x988; // CPerParticleVecInput
    public const nint m_vecOutputMax = 0xFE0; // CPerParticleVecInput
    public const nint m_flNoiseScale = 0x1638; // CPerParticleFloatInput
    public const nint m_flNoiseScaleLoc = 0x1790; // CPerParticleFloatInput
    public const nint m_TransformInput = 0x18E8; // CParticleTransformInput
    public const nint m_bIgnoreDt = 0x1950; // bool
}

public static class C_INIT_LifespanFromVelocity {
    public const nint m_vecComponentScale = 0x1C0; // Vector
    public const nint m_flTraceOffset = 0x1CC; // float
    public const nint m_flMaxTraceLength = 0x1D0; // float
    public const nint m_flTraceTolerance = 0x1D4; // float
    public const nint m_nMaxPlanes = 0x1D8; // int32_t
    public const nint m_CollisionGroupName = 0x1E0; // char[128]
    public const nint m_nTraceSet = 0x260; // ParticleTraceSet_t
    public const nint m_bIncludeWater = 0x270; // bool
}

public static class C_INIT_ModelCull {
    public const nint m_nControlPointNumber = 0x1C0; // int32_t
    public const nint m_bBoundBox = 0x1C4; // bool
    public const nint m_bCullOutside = 0x1C5; // bool
    public const nint m_bUseBones = 0x1C6; // bool
    public const nint m_HitboxSetName = 0x1C7; // char[128]
}

public static class C_INIT_MoveBetweenPoints {
    public const nint m_flSpeedMin = 0x1C0; // CPerParticleFloatInput
    public const nint m_flSpeedMax = 0x318; // CPerParticleFloatInput
    public const nint m_flEndSpread = 0x470; // CPerParticleFloatInput
    public const nint m_flStartOffset = 0x5C8; // CPerParticleFloatInput
    public const nint m_flEndOffset = 0x720; // CPerParticleFloatInput
    public const nint m_nEndControlPointNumber = 0x878; // int32_t
    public const nint m_bTrailBias = 0x87C; // bool
}

public static class C_INIT_NormalAlignToCP {
    public const nint m_transformInput = 0x1C0; // CParticleTransformInput
    public const nint m_nControlPointAxis = 0x228; // ParticleControlPointAxis_t
}

public static class C_INIT_NormalOffset {
    public const nint m_OffsetMin = 0x1C0; // Vector
    public const nint m_OffsetMax = 0x1CC; // Vector
    public const nint m_nControlPointNumber = 0x1D8; // int32_t
    public const nint m_bLocalCoords = 0x1DC; // bool
    public const nint m_bNormalize = 0x1DD; // bool
}

public static class C_INIT_OffsetVectorToVector {
    public const nint m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    public const nint m_vecOutputMin = 0x1C8; // Vector
    public const nint m_vecOutputMax = 0x1D4; // Vector
    public const nint m_randomnessParameters = 0x1E0; // CRandomNumberGeneratorParameters
}

public static class C_INIT_Orient2DRelToCP {
    public const nint m_nCP = 0x1C0; // int32_t
    public const nint m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    public const nint m_flRotOffset = 0x1C8; // float
}

public static class C_INIT_PlaneCull {
    public const nint m_nControlPoint = 0x1C0; // int32_t
    public const nint m_flDistance = 0x1C8; // CParticleCollectionFloatInput
    public const nint m_bCullInside = 0x320; // bool
}

public static class C_INIT_PointList {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_pointList = 0x1C8; // CUtlVector<PointDefinition_t>
    public const nint m_bPlaceAlongPath = 0x1E0; // bool
    public const nint m_bClosedLoop = 0x1E1; // bool
    public const nint m_nNumPointsAlongPath = 0x1E4; // int32_t
}

public static class C_INIT_PositionOffset {
    public const nint m_OffsetMin = 0x1C0; // CPerParticleVecInput
    public const nint m_OffsetMax = 0x818; // CPerParticleVecInput
    public const nint m_TransformInput = 0xE70; // CParticleTransformInput
    public const nint m_bLocalCoords = 0xED8; // bool
    public const nint m_bProportional = 0xED9; // bool
    public const nint m_randomnessParameters = 0xEDC; // CRandomNumberGeneratorParameters
}

public static class C_INIT_PositionOffsetToCP {
    public const nint m_nControlPointNumberStart = 0x1C0; // int32_t
    public const nint m_nControlPointNumberEnd = 0x1C4; // int32_t
    public const nint m_bLocalCoords = 0x1C8; // bool
}

public static class C_INIT_PositionPlaceOnGround {
    public const nint m_flOffset = 0x1C0; // CPerParticleFloatInput
    public const nint m_flMaxTraceLength = 0x318; // CPerParticleFloatInput
    public const nint m_CollisionGroupName = 0x470; // char[128]
    public const nint m_nTraceSet = 0x4F0; // ParticleTraceSet_t
    public const nint m_nTraceMissBehavior = 0x500; // ParticleTraceMissBehavior_t
    public const nint m_bIncludeWater = 0x504; // bool
    public const nint m_bSetNormal = 0x505; // bool
    public const nint m_bSetPXYZOnly = 0x506; // bool
    public const nint m_bTraceAlongNormal = 0x507; // bool
    public const nint m_bOffsetonColOnly = 0x508; // bool
    public const nint m_flOffsetByRadiusFactor = 0x50C; // float
    public const nint m_nPreserveOffsetCP = 0x510; // int32_t
    public const nint m_nIgnoreCP = 0x514; // int32_t
}

public static class C_INIT_PositionWarp {
    public const nint m_vecWarpMin = 0x1C0; // CParticleCollectionVecInput
    public const nint m_vecWarpMax = 0x818; // CParticleCollectionVecInput
    public const nint m_nScaleControlPointNumber = 0xE70; // int32_t
    public const nint m_nControlPointNumber = 0xE74; // int32_t
    public const nint m_nRadiusComponent = 0xE78; // int32_t
    public const nint m_flWarpTime = 0xE7C; // float
    public const nint m_flWarpStartTime = 0xE80; // float
    public const nint m_flPrevPosScale = 0xE84; // float
    public const nint m_bInvertWarp = 0xE88; // bool
    public const nint m_bUseCount = 0xE89; // bool
}

public static class C_INIT_PositionWarpScalar {
    public const nint m_vecWarpMin = 0x1C0; // Vector
    public const nint m_vecWarpMax = 0x1CC; // Vector
    public const nint m_InputValue = 0x1D8; // CPerParticleFloatInput
    public const nint m_flPrevPosScale = 0x330; // float
    public const nint m_nScaleControlPointNumber = 0x334; // int32_t
    public const nint m_nControlPointNumber = 0x338; // int32_t
}

public static class C_INIT_QuantizeFloat {
    public const nint m_InputValue = 0x1C0; // CPerParticleFloatInput
    public const nint m_nOutputField = 0x318; // ParticleAttributeIndex_t
}

public static class C_INIT_RadiusFromCPObject {
    public const nint m_nControlPoint = 0x1C0; // int32_t
}

public static class C_INIT_RandomAlpha {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_nAlphaMin = 0x1C4; // int32_t
    public const nint m_nAlphaMax = 0x1C8; // int32_t
    public const nint m_flAlphaRandExponent = 0x1D4; // float
}

public static class C_INIT_RandomAlphaWindowThreshold {
    public const nint m_flMin = 0x1C0; // float
    public const nint m_flMax = 0x1C4; // float
    public const nint m_flExponent = 0x1C8; // float
}

public static class C_INIT_RandomColor {
    public const nint m_ColorMin = 0x1DC; // Color
    public const nint m_ColorMax = 0x1E0; // Color
    public const nint m_TintMin = 0x1E4; // Color
    public const nint m_TintMax = 0x1E8; // Color
    public const nint m_flTintPerc = 0x1EC; // float
    public const nint m_flUpdateThreshold = 0x1F0; // float
    public const nint m_nTintCP = 0x1F4; // int32_t
    public const nint m_nFieldOutput = 0x1F8; // ParticleAttributeIndex_t
    public const nint m_nTintBlendMode = 0x1FC; // ParticleColorBlendMode_t
    public const nint m_flLightAmplification = 0x200; // float
}

public static class C_INIT_RandomLifeTime {
    public const nint m_fLifetimeMin = 0x1C0; // float
    public const nint m_fLifetimeMax = 0x1C4; // float
    public const nint m_fLifetimeRandExponent = 0x1C8; // float
}

public static class C_INIT_RandomModelSequence {
    public const nint m_ActivityName = 0x1C0; // char[256]
    public const nint m_SequenceName = 0x2C0; // char[256]
    public const nint m_hModel = 0x3C0; // CStrongHandle<InfoForResourceTypeCModel>
}

public static class C_INIT_RandomNamedModelElement {
    public const nint m_hModel = 0x1C0; // CStrongHandle<InfoForResourceTypeCModel>
    public const nint m_names = 0x1C8; // CUtlVector<CUtlString>
    public const nint m_bShuffle = 0x1E0; // bool
    public const nint m_bLinear = 0x1E1; // bool
    public const nint m_bModelFromRenderer = 0x1E2; // bool
    public const nint m_nFieldOutput = 0x1E4; // ParticleAttributeIndex_t
}

public static class C_INIT_RandomRadius {
    public const nint m_flRadiusMin = 0x1C0; // float
    public const nint m_flRadiusMax = 0x1C4; // float
    public const nint m_flRadiusRandExponent = 0x1C8; // float
}

public static class C_INIT_RandomScalar {
    public const nint m_flMin = 0x1C0; // float
    public const nint m_flMax = 0x1C4; // float
    public const nint m_flExponent = 0x1C8; // float
    public const nint m_nFieldOutput = 0x1CC; // ParticleAttributeIndex_t
}

public static class C_INIT_RandomSecondSequence {
    public const nint m_nSequenceMin = 0x1C0; // int32_t
    public const nint m_nSequenceMax = 0x1C4; // int32_t
}

public static class C_INIT_RandomSequence {
    public const nint m_nSequenceMin = 0x1C0; // int32_t
    public const nint m_nSequenceMax = 0x1C4; // int32_t
    public const nint m_bShuffle = 0x1C8; // bool
    public const nint m_bLinear = 0x1C9; // bool
    public const nint m_WeightedList = 0x1D0; // CUtlVector<SequenceWeightedList_t>
}

public static class C_INIT_RandomTrailLength {
    public const nint m_flMinLength = 0x1C0; // float
    public const nint m_flMaxLength = 0x1C4; // float
    public const nint m_flLengthRandExponent = 0x1C8; // float
}

public static class C_INIT_RandomVector {
    public const nint m_vecMin = 0x1C0; // Vector
    public const nint m_vecMax = 0x1CC; // Vector
    public const nint m_nFieldOutput = 0x1D8; // ParticleAttributeIndex_t
    public const nint m_randomnessParameters = 0x1DC; // CRandomNumberGeneratorParameters
}

public static class C_INIT_RandomVectorComponent {
    public const nint m_flMin = 0x1C0; // float
    public const nint m_flMax = 0x1C4; // float
    public const nint m_nFieldOutput = 0x1C8; // ParticleAttributeIndex_t
    public const nint m_nComponent = 0x1CC; // int32_t
}

public static class C_INIT_RandomYawFlip {
    public const nint m_flPercent = 0x1C0; // float
}

public static class C_INIT_RemapCPtoScalar {
    public const nint m_nCPInput = 0x1C0; // int32_t
    public const nint m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    public const nint m_nField = 0x1C8; // int32_t
    public const nint m_flInputMin = 0x1CC; // float
    public const nint m_flInputMax = 0x1D0; // float
    public const nint m_flOutputMin = 0x1D4; // float
    public const nint m_flOutputMax = 0x1D8; // float
    public const nint m_flStartTime = 0x1DC; // float
    public const nint m_flEndTime = 0x1E0; // float
    public const nint m_nSetMethod = 0x1E4; // ParticleSetMethod_t
    public const nint m_flRemapBias = 0x1E8; // float
}

public static class C_INIT_RemapInitialDirectionToTransformToVector {
    public const nint m_TransformInput = 0x1C0; // CParticleTransformInput
    public const nint m_nFieldOutput = 0x228; // ParticleAttributeIndex_t
    public const nint m_flScale = 0x22C; // float
    public const nint m_flOffsetRot = 0x230; // float
    public const nint m_vecOffsetAxis = 0x234; // Vector
    public const nint m_bNormalize = 0x240; // bool
}

public static class C_INIT_RemapInitialTransformDirectionToRotation {
    public const nint m_TransformInput = 0x1C0; // CParticleTransformInput
    public const nint m_nFieldOutput = 0x228; // ParticleAttributeIndex_t
    public const nint m_flOffsetRot = 0x22C; // float
    public const nint m_nComponent = 0x230; // int32_t
}

public static class C_INIT_RemapInitialVisibilityScalar {
    public const nint m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    public const nint m_flInputMin = 0x1C8; // float
    public const nint m_flInputMax = 0x1CC; // float
    public const nint m_flOutputMin = 0x1D0; // float
    public const nint m_flOutputMax = 0x1D4; // float
}

public static class C_INIT_RemapNamedModelElementToScalar {
    public const nint m_hModel = 0x1C0; // CStrongHandle<InfoForResourceTypeCModel>
    public const nint m_names = 0x1C8; // CUtlVector<CUtlString>
    public const nint m_values = 0x1E0; // CUtlVector<float>
    public const nint m_nFieldInput = 0x1F8; // ParticleAttributeIndex_t
    public const nint m_nFieldOutput = 0x1FC; // ParticleAttributeIndex_t
    public const nint m_nSetMethod = 0x200; // ParticleSetMethod_t
    public const nint m_bModelFromRenderer = 0x204; // bool
}

public static class C_INIT_RemapParticleCountToNamedModelElementScalar {
    public const nint m_hModel = 0x1F0; // CStrongHandle<InfoForResourceTypeCModel>
    public const nint m_outputMinName = 0x1F8; // CUtlString
    public const nint m_outputMaxName = 0x200; // CUtlString
    public const nint m_bModelFromRenderer = 0x208; // bool
}

public static class C_INIT_RemapParticleCountToScalar {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_nInputMin = 0x1C4; // int32_t
    public const nint m_nInputMax = 0x1C8; // int32_t
    public const nint m_nScaleControlPoint = 0x1CC; // int32_t
    public const nint m_nScaleControlPointField = 0x1D0; // int32_t
    public const nint m_flOutputMin = 0x1D4; // float
    public const nint m_flOutputMax = 0x1D8; // float
    public const nint m_nSetMethod = 0x1DC; // ParticleSetMethod_t
    public const nint m_bActiveRange = 0x1E0; // bool
    public const nint m_bInvert = 0x1E1; // bool
    public const nint m_bWrap = 0x1E2; // bool
    public const nint m_flRemapBias = 0x1E4; // float
}

public static class C_INIT_RemapQAnglesToRotation {
    public const nint m_TransformInput = 0x1C0; // CParticleTransformInput
}

public static class C_INIT_RemapScalar {
    public const nint m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    public const nint m_flInputMin = 0x1C8; // float
    public const nint m_flInputMax = 0x1CC; // float
    public const nint m_flOutputMin = 0x1D0; // float
    public const nint m_flOutputMax = 0x1D4; // float
    public const nint m_flStartTime = 0x1D8; // float
    public const nint m_flEndTime = 0x1DC; // float
    public const nint m_nSetMethod = 0x1E0; // ParticleSetMethod_t
    public const nint m_bActiveRange = 0x1E4; // bool
    public const nint m_flRemapBias = 0x1E8; // float
}

public static class C_INIT_RemapScalarToVector {
    public const nint m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    public const nint m_flInputMin = 0x1C8; // float
    public const nint m_flInputMax = 0x1CC; // float
    public const nint m_vecOutputMin = 0x1D0; // Vector
    public const nint m_vecOutputMax = 0x1DC; // Vector
    public const nint m_flStartTime = 0x1E8; // float
    public const nint m_flEndTime = 0x1EC; // float
    public const nint m_nSetMethod = 0x1F0; // ParticleSetMethod_t
    public const nint m_nControlPointNumber = 0x1F4; // int32_t
    public const nint m_bLocalCoords = 0x1F8; // bool
    public const nint m_flRemapBias = 0x1FC; // float
}

public static class C_INIT_RemapSpeedToScalar {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_nControlPointNumber = 0x1C4; // int32_t
    public const nint m_flStartTime = 0x1C8; // float
    public const nint m_flEndTime = 0x1CC; // float
    public const nint m_flInputMin = 0x1D0; // float
    public const nint m_flInputMax = 0x1D4; // float
    public const nint m_flOutputMin = 0x1D8; // float
    public const nint m_flOutputMax = 0x1DC; // float
    public const nint m_nSetMethod = 0x1E0; // ParticleSetMethod_t
    public const nint m_bPerParticle = 0x1E4; // bool
}

public static class C_INIT_RemapTransformOrientationToRotations {
    public const nint m_TransformInput = 0x1C0; // CParticleTransformInput
    public const nint m_vecRotation = 0x228; // Vector
    public const nint m_bUseQuat = 0x234; // bool
    public const nint m_bWriteNormal = 0x235; // bool
}

public static class C_INIT_RemapTransformToVector {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_vInputMin = 0x1C4; // Vector
    public const nint m_vInputMax = 0x1D0; // Vector
    public const nint m_vOutputMin = 0x1DC; // Vector
    public const nint m_vOutputMax = 0x1E8; // Vector
    public const nint m_TransformInput = 0x1F8; // CParticleTransformInput
    public const nint m_LocalSpaceTransform = 0x260; // CParticleTransformInput
    public const nint m_flStartTime = 0x2C8; // float
    public const nint m_flEndTime = 0x2CC; // float
    public const nint m_nSetMethod = 0x2D0; // ParticleSetMethod_t
    public const nint m_bOffset = 0x2D4; // bool
    public const nint m_bAccelerate = 0x2D5; // bool
    public const nint m_flRemapBias = 0x2D8; // float
}

public static class C_INIT_RingWave {
    public const nint m_TransformInput = 0x1C0; // CParticleTransformInput
    public const nint m_flParticlesPerOrbit = 0x228; // CParticleCollectionFloatInput
    public const nint m_flInitialRadius = 0x380; // CPerParticleFloatInput
    public const nint m_flThickness = 0x4D8; // CPerParticleFloatInput
    public const nint m_flInitialSpeedMin = 0x630; // CPerParticleFloatInput
    public const nint m_flInitialSpeedMax = 0x788; // CPerParticleFloatInput
    public const nint m_flRoll = 0x8E0; // CPerParticleFloatInput
    public const nint m_flPitch = 0xA38; // CPerParticleFloatInput
    public const nint m_flYaw = 0xB90; // CPerParticleFloatInput
    public const nint m_bEvenDistribution = 0xCE8; // bool
    public const nint m_bXYVelocityOnly = 0xCE9; // bool
}

public static class C_INIT_RtEnvCull {
    public const nint m_vecTestDir = 0x1C0; // Vector
    public const nint m_vecTestNormal = 0x1CC; // Vector
    public const nint m_bUseVelocity = 0x1D8; // bool
    public const nint m_bCullOnMiss = 0x1D9; // bool
    public const nint m_bLifeAdjust = 0x1DA; // bool
    public const nint m_RtEnvName = 0x1DB; // char[128]
    public const nint m_nRTEnvCP = 0x25C; // int32_t
    public const nint m_nComponent = 0x260; // int32_t
}

public static class C_INIT_ScaleVelocity {
    public const nint m_vecScale = 0x1C0; // CParticleCollectionVecInput
}

public static class C_INIT_SequenceFromCP {
    public const nint m_bKillUnused = 0x1C0; // bool
    public const nint m_bRadiusScale = 0x1C1; // bool
    public const nint m_nCP = 0x1C4; // int32_t
    public const nint m_vecOffset = 0x1C8; // Vector
}

public static class C_INIT_SequenceLifeTime {
    public const nint m_flFramerate = 0x1C0; // float
}

public static class C_INIT_SetHitboxToClosest {
    public const nint m_nControlPointNumber = 0x1C0; // int32_t
    public const nint m_nDesiredHitbox = 0x1C4; // int32_t
    public const nint m_vecHitBoxScale = 0x1C8; // CParticleCollectionVecInput
    public const nint m_HitboxSetName = 0x820; // char[128]
    public const nint m_bUseBones = 0x8A0; // bool
    public const nint m_bUseClosestPointOnHitbox = 0x8A1; // bool
    public const nint m_nTestType = 0x8A4; // ClosestPointTestType_t
    public const nint m_flHybridRatio = 0x8A8; // CParticleCollectionFloatInput
    public const nint m_bUpdatePosition = 0xA00; // bool
}

public static class C_INIT_SetHitboxToModel {
    public const nint m_nControlPointNumber = 0x1C0; // int32_t
    public const nint m_nForceInModel = 0x1C4; // int32_t
    public const nint m_nDesiredHitbox = 0x1C8; // int32_t
    public const nint m_vecHitBoxScale = 0x1D0; // CParticleCollectionVecInput
    public const nint m_vecDirectionBias = 0x828; // Vector
    public const nint m_bMaintainHitbox = 0x834; // bool
    public const nint m_bUseBones = 0x835; // bool
    public const nint m_HitboxSetName = 0x836; // char[128]
    public const nint m_flShellSize = 0x8B8; // CParticleCollectionFloatInput
}

public static class C_INIT_SetRigidAttachment {
    public const nint m_nControlPointNumber = 0x1C0; // int32_t
    public const nint m_nFieldInput = 0x1C4; // ParticleAttributeIndex_t
    public const nint m_nFieldOutput = 0x1C8; // ParticleAttributeIndex_t
    public const nint m_bLocalSpace = 0x1CC; // bool
}

public static class C_INIT_SetVectorAttributeToVectorExpression {
    public const nint m_nExpression = 0x1C0; // VectorExpressionType_t
    public const nint m_vInput1 = 0x1C8; // CPerParticleVecInput
    public const nint m_vInput2 = 0x820; // CPerParticleVecInput
    public const nint m_nOutputField = 0xE78; // ParticleAttributeIndex_t
    public const nint m_nSetMethod = 0xE7C; // ParticleSetMethod_t
    public const nint m_bNormalizedOutput = 0xE80; // bool
}

public static class C_INIT_StatusEffect {
    public const nint m_nDetail2Combo = 0x1C0; // Detail2Combo_t
    public const nint m_flDetail2Rotation = 0x1C4; // float
    public const nint m_flDetail2Scale = 0x1C8; // float
    public const nint m_flDetail2BlendFactor = 0x1CC; // float
    public const nint m_flColorWarpIntensity = 0x1D0; // float
    public const nint m_flDiffuseWarpBlendToFull = 0x1D4; // float
    public const nint m_flEnvMapIntensity = 0x1D8; // float
    public const nint m_flAmbientScale = 0x1DC; // float
    public const nint m_specularColor = 0x1E0; // Color
    public const nint m_flSpecularScale = 0x1E4; // float
    public const nint m_flSpecularExponent = 0x1E8; // float
    public const nint m_flSpecularExponentBlendToFull = 0x1EC; // float
    public const nint m_flSpecularBlendToFull = 0x1F0; // float
    public const nint m_rimLightColor = 0x1F4; // Color
    public const nint m_flRimLightScale = 0x1F8; // float
    public const nint m_flReflectionsTintByBaseBlendToNone = 0x1FC; // float
    public const nint m_flMetalnessBlendToFull = 0x200; // float
    public const nint m_flSelfIllumBlendToFull = 0x204; // float
}

public static class C_INIT_StatusEffectCitadel {
    public const nint m_flSFXColorWarpAmount = 0x1C0; // float
    public const nint m_flSFXNormalAmount = 0x1C4; // float
    public const nint m_flSFXMetalnessAmount = 0x1C8; // float
    public const nint m_flSFXRoughnessAmount = 0x1CC; // float
    public const nint m_flSFXSelfIllumAmount = 0x1D0; // float
    public const nint m_flSFXSScale = 0x1D4; // float
    public const nint m_flSFXSScrollX = 0x1D8; // float
    public const nint m_flSFXSScrollY = 0x1DC; // float
    public const nint m_flSFXSScrollZ = 0x1E0; // float
    public const nint m_flSFXSOffsetX = 0x1E4; // float
    public const nint m_flSFXSOffsetY = 0x1E8; // float
    public const nint m_flSFXSOffsetZ = 0x1EC; // float
    public const nint m_nDetailCombo = 0x1F0; // DetailCombo_t
    public const nint m_flSFXSDetailAmount = 0x1F4; // float
    public const nint m_flSFXSDetailScale = 0x1F8; // float
    public const nint m_flSFXSDetailScrollX = 0x1FC; // float
    public const nint m_flSFXSDetailScrollY = 0x200; // float
    public const nint m_flSFXSDetailScrollZ = 0x204; // float
    public const nint m_flSFXSUseModelUVs = 0x208; // float
}

public static class C_INIT_VelocityFromCP {
    public const nint m_velocityInput = 0x1C0; // CParticleCollectionVecInput
    public const nint m_transformInput = 0x818; // CParticleTransformInput
    public const nint m_flVelocityScale = 0x880; // float
    public const nint m_bDirectionOnly = 0x884; // bool
}

public static class C_INIT_VelocityFromNormal {
    public const nint m_fSpeedMin = 0x1C0; // float
    public const nint m_fSpeedMax = 0x1C4; // float
    public const nint m_bIgnoreDt = 0x1C8; // bool
}

public static class C_INIT_VelocityRadialRandom {
    public const nint m_nControlPointNumber = 0x1C0; // int32_t
    public const nint m_fSpeedMin = 0x1C4; // float
    public const nint m_fSpeedMax = 0x1C8; // float
    public const nint m_vecLocalCoordinateSystemSpeedScale = 0x1CC; // Vector
    public const nint m_bIgnoreDelta = 0x1D9; // bool
}

public static class C_INIT_VelocityRandom {
    public const nint m_nControlPointNumber = 0x1C0; // int32_t
    public const nint m_fSpeedMin = 0x1C8; // CPerParticleFloatInput
    public const nint m_fSpeedMax = 0x320; // CPerParticleFloatInput
    public const nint m_LocalCoordinateSystemSpeedMin = 0x478; // CPerParticleVecInput
    public const nint m_LocalCoordinateSystemSpeedMax = 0xAD0; // CPerParticleVecInput
    public const nint m_bIgnoreDT = 0x1128; // bool
    public const nint m_randomnessParameters = 0x112C; // CRandomNumberGeneratorParameters
}

public static class C_OP_AlphaDecay {
    public const nint m_flMinAlpha = 0x1C0; // float
}

public static class C_OP_AttractToControlPoint {
    public const nint m_vecComponentScale = 0x1D0; // Vector
    public const nint m_fForceAmount = 0x1E0; // CPerParticleFloatInput
    public const nint m_fFalloffPower = 0x338; // float
    public const nint m_TransformInput = 0x340; // CParticleTransformInput
    public const nint m_fForceAmountMin = 0x3A8; // CPerParticleFloatInput
    public const nint m_bApplyMinForce = 0x500; // bool
}

public static class C_OP_BasicMovement {
    public const nint m_Gravity = 0x1C0; // CParticleCollectionVecInput
    public const nint m_fDrag = 0x818; // CParticleCollectionFloatInput
    public const nint m_nMaxConstraintPasses = 0x970; // int32_t
}

public static class C_OP_BoxConstraint {
    public const nint m_vecMin = 0x1C0; // CParticleCollectionVecInput
    public const nint m_vecMax = 0x818; // CParticleCollectionVecInput
    public const nint m_nCP = 0xE70; // int32_t
    public const nint m_bLocalSpace = 0xE74; // bool
    public const nint m_bAccountForRadius = 0xE75; // bool
}

public static class C_OP_CPOffsetToPercentageBetweenCPs {
    public const nint m_flInputMin = 0x1C0; // float
    public const nint m_flInputMax = 0x1C4; // float
    public const nint m_flInputBias = 0x1C8; // float
    public const nint m_nStartCP = 0x1CC; // int32_t
    public const nint m_nEndCP = 0x1D0; // int32_t
    public const nint m_nOffsetCP = 0x1D4; // int32_t
    public const nint m_nOuputCP = 0x1D8; // int32_t
    public const nint m_nInputCP = 0x1DC; // int32_t
    public const nint m_bRadialCheck = 0x1E0; // bool
    public const nint m_bScaleOffset = 0x1E1; // bool
    public const nint m_vecOffset = 0x1E4; // Vector
}

public static class C_OP_CPVelocityForce {
    public const nint m_nControlPointNumber = 0x1D0; // int32_t
    public const nint m_flScale = 0x1D8; // CPerParticleFloatInput
}

public static class C_OP_CalculateVectorAttribute {
    public const nint m_vStartValue = 0x1C0; // Vector
    public const nint m_nFieldInput1 = 0x1CC; // ParticleAttributeIndex_t
    public const nint m_flInputScale1 = 0x1D0; // float
    public const nint m_nFieldInput2 = 0x1D4; // ParticleAttributeIndex_t
    public const nint m_flInputScale2 = 0x1D8; // float
    public const nint m_nControlPointInput1 = 0x1DC; // ControlPointReference_t
    public const nint m_flControlPointScale1 = 0x1F0; // float
    public const nint m_nControlPointInput2 = 0x1F4; // ControlPointReference_t
    public const nint m_flControlPointScale2 = 0x208; // float
    public const nint m_nFieldOutput = 0x20C; // ParticleAttributeIndex_t
    public const nint m_vFinalOutputScale = 0x210; // Vector
}

public static class C_OP_ChladniWave {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_flInputMin = 0x1C8; // CPerParticleFloatInput
    public const nint m_flInputMax = 0x320; // CPerParticleFloatInput
    public const nint m_flOutputMin = 0x478; // CPerParticleFloatInput
    public const nint m_flOutputMax = 0x5D0; // CPerParticleFloatInput
    public const nint m_vecWaveLength = 0x728; // CPerParticleVecInput
    public const nint m_vecHarmonics = 0xD80; // CPerParticleVecInput
    public const nint m_nSetMethod = 0x13D8; // ParticleSetMethod_t
    public const nint m_nLocalSpaceControlPoint = 0x13DC; // int32_t
    public const nint m_b3D = 0x13E0; // bool
}

public static class C_OP_ChooseRandomChildrenInGroup {
    public const nint m_nChildGroupID = 0x1D0; // int32_t
    public const nint m_flNumberOfChildren = 0x1D8; // CParticleCollectionFloatInput
}

public static class C_OP_ClampScalar {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_flOutputMin = 0x1C8; // CPerParticleFloatInput
    public const nint m_flOutputMax = 0x320; // CPerParticleFloatInput
}

public static class C_OP_ClampVector {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_vecOutputMin = 0x1C8; // CPerParticleVecInput
    public const nint m_vecOutputMax = 0x820; // CPerParticleVecInput
}

public static class C_OP_CollideWithParentParticles {
    public const nint m_flParentRadiusScale = 0x1C0; // CPerParticleFloatInput
    public const nint m_flRadiusScale = 0x318; // CPerParticleFloatInput
}

public static class C_OP_CollideWithSelf {
    public const nint m_flRadiusScale = 0x1C0; // CPerParticleFloatInput
    public const nint m_flMinimumSpeed = 0x318; // CPerParticleFloatInput
}

public static class C_OP_ColorAdjustHSL {
    public const nint m_flHueAdjust = 0x1C0; // CPerParticleFloatInput
    public const nint m_flSaturationAdjust = 0x318; // CPerParticleFloatInput
    public const nint m_flLightnessAdjust = 0x470; // CPerParticleFloatInput
}

public static class C_OP_ColorInterpolate {
    public const nint m_ColorFade = 0x1C0; // Color
    public const nint m_flFadeStartTime = 0x1D0; // float
    public const nint m_flFadeEndTime = 0x1D4; // float
    public const nint m_nFieldOutput = 0x1D8; // ParticleAttributeIndex_t
    public const nint m_bEaseInOut = 0x1DC; // bool
    public const nint m_bUseNewCode = 0x1DD; // bool
}

public static class C_OP_ColorInterpolateRandom {
    public const nint m_ColorFadeMin = 0x1C0; // Color
    public const nint m_ColorFadeMax = 0x1DC; // Color
    public const nint m_flFadeStartTime = 0x1EC; // float
    public const nint m_flFadeEndTime = 0x1F0; // float
    public const nint m_nFieldOutput = 0x1F4; // ParticleAttributeIndex_t
    public const nint m_bEaseInOut = 0x1F8; // bool
}

public static class C_OP_ConnectParentParticleToNearest {
    public const nint m_nFirstControlPoint = 0x1C0; // int32_t
    public const nint m_nSecondControlPoint = 0x1C4; // int32_t
}

public static class C_OP_ConstrainDistance {
    public const nint m_fMinDistance = 0x1C0; // CParticleCollectionFloatInput
    public const nint m_fMaxDistance = 0x318; // CParticleCollectionFloatInput
    public const nint m_nControlPointNumber = 0x470; // int32_t
    public const nint m_CenterOffset = 0x474; // Vector
    public const nint m_bGlobalCenter = 0x480; // bool
}

public static class C_OP_ConstrainDistanceToPath {
    public const nint m_fMinDistance = 0x1C0; // float
    public const nint m_flMaxDistance0 = 0x1C4; // float
    public const nint m_flMaxDistanceMid = 0x1C8; // float
    public const nint m_flMaxDistance1 = 0x1CC; // float
    public const nint m_PathParameters = 0x1D0; // CPathParameters
    public const nint m_flTravelTime = 0x210; // float
    public const nint m_nFieldScale = 0x214; // ParticleAttributeIndex_t
    public const nint m_nManualTField = 0x218; // ParticleAttributeIndex_t
}

public static class C_OP_ConstrainDistanceToUserSpecifiedPath {
    public const nint m_fMinDistance = 0x1C0; // float
    public const nint m_flMaxDistance = 0x1C4; // float
    public const nint m_flTimeScale = 0x1C8; // float
    public const nint m_bLoopedPath = 0x1CC; // bool
    public const nint m_pointList = 0x1D0; // CUtlVector<PointDefinitionWithTimeValues_t>
}

public static class C_OP_ConstrainLineLength {
    public const nint m_flMinDistance = 0x1C0; // float
    public const nint m_flMaxDistance = 0x1C4; // float
}

public static class C_OP_ContinuousEmitter {
    public const nint m_flEmissionDuration = 0x1C0; // CParticleCollectionFloatInput
    public const nint m_flStartTime = 0x318; // CParticleCollectionFloatInput
    public const nint m_flEmitRate = 0x470; // CParticleCollectionFloatInput
    public const nint m_flEmissionScale = 0x5C8; // float
    public const nint m_flScalePerParentParticle = 0x5CC; // float
    public const nint m_bInitFromKilledParentParticles = 0x5D0; // bool
    public const nint m_nSnapshotControlPoint = 0x5D4; // int32_t
    public const nint m_nLimitPerUpdate = 0x5D8; // int32_t
    public const nint m_bForceEmitOnFirstUpdate = 0x5DC; // bool
    public const nint m_bForceEmitOnLastUpdate = 0x5DD; // bool
}

public static class C_OP_ControlPointToRadialScreenSpace {
    public const nint m_nCPIn = 0x1D0; // int32_t
    public const nint m_vecCP1Pos = 0x1D4; // Vector
    public const nint m_nCPOut = 0x1E0; // int32_t
    public const nint m_nCPOutField = 0x1E4; // int32_t
    public const nint m_nCPSSPosOut = 0x1E8; // int32_t
}

public static class C_OP_ControlpointLight {
    public const nint m_flScale = 0x1C0; // float
    public const nint m_nControlPoint1 = 0x650; // int32_t
    public const nint m_nControlPoint2 = 0x654; // int32_t
    public const nint m_nControlPoint3 = 0x658; // int32_t
    public const nint m_nControlPoint4 = 0x65C; // int32_t
    public const nint m_vecCPOffset1 = 0x660; // Vector
    public const nint m_vecCPOffset2 = 0x66C; // Vector
    public const nint m_vecCPOffset3 = 0x678; // Vector
    public const nint m_vecCPOffset4 = 0x684; // Vector
    public const nint m_LightFiftyDist1 = 0x690; // float
    public const nint m_LightZeroDist1 = 0x694; // float
    public const nint m_LightFiftyDist2 = 0x698; // float
    public const nint m_LightZeroDist2 = 0x69C; // float
    public const nint m_LightFiftyDist3 = 0x6A0; // float
    public const nint m_LightZeroDist3 = 0x6A4; // float
    public const nint m_LightFiftyDist4 = 0x6A8; // float
    public const nint m_LightZeroDist4 = 0x6AC; // float
    public const nint m_LightColor1 = 0x6B0; // Color
    public const nint m_LightColor2 = 0x6B4; // Color
    public const nint m_LightColor3 = 0x6B8; // Color
    public const nint m_LightColor4 = 0x6BC; // Color
    public const nint m_bLightType1 = 0x6C0; // bool
    public const nint m_bLightType2 = 0x6C1; // bool
    public const nint m_bLightType3 = 0x6C2; // bool
    public const nint m_bLightType4 = 0x6C3; // bool
    public const nint m_bLightDynamic1 = 0x6C4; // bool
    public const nint m_bLightDynamic2 = 0x6C5; // bool
    public const nint m_bLightDynamic3 = 0x6C6; // bool
    public const nint m_bLightDynamic4 = 0x6C7; // bool
    public const nint m_bUseNormal = 0x6C8; // bool
    public const nint m_bUseHLambert = 0x6C9; // bool
    public const nint m_bClampLowerRange = 0x6CE; // bool
    public const nint m_bClampUpperRange = 0x6CF; // bool
}

public static class C_OP_Cull {
    public const nint m_flCullPerc = 0x1C0; // float
    public const nint m_flCullStart = 0x1C4; // float
    public const nint m_flCullEnd = 0x1C8; // float
    public const nint m_flCullExp = 0x1CC; // float
}

public static class C_OP_CurlNoiseForce {
    public const nint m_nNoiseType = 0x1D0; // ParticleDirectionNoiseType_t
    public const nint m_vecNoiseFreq = 0x1D8; // CPerParticleVecInput
    public const nint m_vecNoiseScale = 0x830; // CPerParticleVecInput
    public const nint m_vecOffset = 0xE88; // CPerParticleVecInput
    public const nint m_vecOffsetRate = 0x14E0; // CPerParticleVecInput
    public const nint m_flWorleySeed = 0x1B38; // CPerParticleFloatInput
    public const nint m_flWorleyJitter = 0x1C90; // CPerParticleFloatInput
}

public static class C_OP_CycleScalar {
    public const nint m_nDestField = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_flStartValue = 0x1C4; // float
    public const nint m_flEndValue = 0x1C8; // float
    public const nint m_flCycleTime = 0x1CC; // float
    public const nint m_bDoNotRepeatCycle = 0x1D0; // bool
    public const nint m_bSynchronizeParticles = 0x1D1; // bool
    public const nint m_nCPScale = 0x1D4; // int32_t
    public const nint m_nCPFieldMin = 0x1D8; // int32_t
    public const nint m_nCPFieldMax = 0x1DC; // int32_t
    public const nint m_nSetMethod = 0x1E0; // ParticleSetMethod_t
}

public static class C_OP_CylindricalDistanceToTransform {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_flInputMin = 0x1C8; // CPerParticleFloatInput
    public const nint m_flInputMax = 0x320; // CPerParticleFloatInput
    public const nint m_flOutputMin = 0x478; // CPerParticleFloatInput
    public const nint m_flOutputMax = 0x5D0; // CPerParticleFloatInput
    public const nint m_TransformStart = 0x728; // CParticleTransformInput
    public const nint m_TransformEnd = 0x790; // CParticleTransformInput
    public const nint m_nSetMethod = 0x7F8; // ParticleSetMethod_t
    public const nint m_bActiveRange = 0x7FC; // bool
    public const nint m_bAdditive = 0x7FD; // bool
    public const nint m_bCapsule = 0x7FE; // bool
}

public static class C_OP_DampenToCP {
    public const nint m_nControlPointNumber = 0x1C0; // int32_t
    public const nint m_flRange = 0x1C4; // float
    public const nint m_flScale = 0x1C8; // float
}

public static class C_OP_Decay {
    public const nint m_bRopeDecay = 0x1C0; // bool
    public const nint m_bForcePreserveParticleOrder = 0x1C1; // bool
}

public static class C_OP_DecayClampCount {
    public const nint m_nCount = 0x1C0; // CParticleCollectionFloatInput
}

public static class C_OP_DecayMaintainCount {
    public const nint m_nParticlesToMaintain = 0x1C0; // int32_t
    public const nint m_flDecayDelay = 0x1C4; // float
    public const nint m_nSnapshotControlPoint = 0x1C8; // int32_t
    public const nint m_bLifespanDecay = 0x1CC; // bool
    public const nint m_flScale = 0x1D0; // CParticleCollectionFloatInput
    public const nint m_bKillNewest = 0x328; // bool
}

public static class C_OP_DecayOffscreen {
    public const nint m_flOffscreenTime = 0x1C0; // CParticleCollectionFloatInput
}

public static class C_OP_DensityForce {
    public const nint m_flRadiusScale = 0x1D0; // float
    public const nint m_flForceScale = 0x1D4; // float
    public const nint m_flTargetDensity = 0x1D8; // float
}

public static class C_OP_DifferencePreviousParticle {
    public const nint m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    public const nint m_flInputMin = 0x1C8; // float
    public const nint m_flInputMax = 0x1CC; // float
    public const nint m_flOutputMin = 0x1D0; // float
    public const nint m_flOutputMax = 0x1D4; // float
    public const nint m_nSetMethod = 0x1D8; // ParticleSetMethod_t
    public const nint m_bActiveRange = 0x1DC; // bool
    public const nint m_bSetPreviousParticle = 0x1DD; // bool
}

public static class C_OP_Diffusion {
    public const nint m_flRadiusScale = 0x1C0; // float
    public const nint m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    public const nint m_nVoxelGridResolution = 0x1C8; // int32_t
}

public static class C_OP_DirectionBetweenVecsToVec {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_vecPoint1 = 0x1C8; // CPerParticleVecInput
    public const nint m_vecPoint2 = 0x820; // CPerParticleVecInput
}

public static class C_OP_DistanceBetweenCPsToCP {
    public const nint m_nStartCP = 0x1D0; // int32_t
    public const nint m_nEndCP = 0x1D4; // int32_t
    public const nint m_nOutputCP = 0x1D8; // int32_t
    public const nint m_nOutputCPField = 0x1DC; // int32_t
    public const nint m_bSetOnce = 0x1E0; // bool
    public const nint m_flInputMin = 0x1E4; // float
    public const nint m_flInputMax = 0x1E8; // float
    public const nint m_flOutputMin = 0x1EC; // float
    public const nint m_flOutputMax = 0x1F0; // float
    public const nint m_flMaxTraceLength = 0x1F4; // float
    public const nint m_flLOSScale = 0x1F8; // float
    public const nint m_bLOS = 0x1FC; // bool
    public const nint m_CollisionGroupName = 0x1FD; // char[128]
    public const nint m_nTraceSet = 0x280; // ParticleTraceSet_t
    public const nint m_nSetParent = 0x284; // ParticleParentSetMode_t
}

public static class C_OP_DistanceBetweenTransforms {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_TransformStart = 0x1C8; // CParticleTransformInput
    public const nint m_TransformEnd = 0x230; // CParticleTransformInput
    public const nint m_flInputMin = 0x298; // CPerParticleFloatInput
    public const nint m_flInputMax = 0x3F0; // CPerParticleFloatInput
    public const nint m_flOutputMin = 0x548; // CPerParticleFloatInput
    public const nint m_flOutputMax = 0x6A0; // CPerParticleFloatInput
    public const nint m_flMaxTraceLength = 0x7F8; // float
    public const nint m_flLOSScale = 0x7FC; // float
    public const nint m_CollisionGroupName = 0x800; // char[128]
    public const nint m_nTraceSet = 0x880; // ParticleTraceSet_t
    public const nint m_bLOS = 0x884; // bool
    public const nint m_nSetMethod = 0x888; // ParticleSetMethod_t
}

public static class C_OP_DistanceBetweenVecs {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_vecPoint1 = 0x1C8; // CPerParticleVecInput
    public const nint m_vecPoint2 = 0x820; // CPerParticleVecInput
    public const nint m_flInputMin = 0xE78; // CPerParticleFloatInput
    public const nint m_flInputMax = 0xFD0; // CPerParticleFloatInput
    public const nint m_flOutputMin = 0x1128; // CPerParticleFloatInput
    public const nint m_flOutputMax = 0x1280; // CPerParticleFloatInput
    public const nint m_nSetMethod = 0x13D8; // ParticleSetMethod_t
    public const nint m_bDeltaTime = 0x13DC; // bool
}

public static class C_OP_DistanceCull {
    public const nint m_nControlPoint = 0x1C0; // int32_t
    public const nint m_vecPointOffset = 0x1C4; // Vector
    public const nint m_flDistance = 0x1D0; // float
    public const nint m_bCullInside = 0x1D4; // bool
}

public static class C_OP_DistanceToTransform {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_flInputMin = 0x1C8; // CPerParticleFloatInput
    public const nint m_flInputMax = 0x320; // CPerParticleFloatInput
    public const nint m_flOutputMin = 0x478; // CPerParticleFloatInput
    public const nint m_flOutputMax = 0x5D0; // CPerParticleFloatInput
    public const nint m_TransformStart = 0x728; // CParticleTransformInput
    public const nint m_bLOS = 0x790; // bool
    public const nint m_CollisionGroupName = 0x791; // char[128]
    public const nint m_nTraceSet = 0x814; // ParticleTraceSet_t
    public const nint m_flMaxTraceLength = 0x818; // float
    public const nint m_flLOSScale = 0x81C; // float
    public const nint m_nSetMethod = 0x820; // ParticleSetMethod_t
    public const nint m_bActiveRange = 0x824; // bool
    public const nint m_bAdditive = 0x825; // bool
    public const nint m_vecComponentScale = 0x828; // CPerParticleVecInput
}

public static class C_OP_DragRelativeToPlane {
    public const nint m_flDragAtPlane = 0x1C0; // CParticleCollectionFloatInput
    public const nint m_flFalloff = 0x318; // CParticleCollectionFloatInput
    public const nint m_bDirectional = 0x470; // bool
    public const nint m_vecPlaneNormal = 0x478; // CParticleCollectionVecInput
    public const nint m_nControlPointNumber = 0xAD0; // int32_t
}

public static class C_OP_DriveCPFromGlobalSoundFloat {
    public const nint m_nOutputControlPoint = 0x1D0; // int32_t
    public const nint m_nOutputField = 0x1D4; // int32_t
    public const nint m_flInputMin = 0x1D8; // float
    public const nint m_flInputMax = 0x1DC; // float
    public const nint m_flOutputMin = 0x1E0; // float
    public const nint m_flOutputMax = 0x1E4; // float
    public const nint m_StackName = 0x1E8; // CUtlString
    public const nint m_OperatorName = 0x1F0; // CUtlString
    public const nint m_FieldName = 0x1F8; // CUtlString
}

public static class C_OP_EnableChildrenFromParentParticleCount {
    public const nint m_nChildGroupID = 0x1D0; // int32_t
    public const nint m_nFirstChild = 0x1D4; // int32_t
    public const nint m_nNumChildrenToEnable = 0x1D8; // CParticleCollectionFloatInput
    public const nint m_bDisableChildren = 0x330; // bool
    public const nint m_bPlayEndcapOnStop = 0x331; // bool
    public const nint m_bDestroyImmediately = 0x332; // bool
}

public static class C_OP_EndCapTimedDecay {
    public const nint m_flDecayTime = 0x1C0; // float
}

public static class C_OP_EndCapTimedFreeze {
    public const nint m_flFreezeTime = 0x1C0; // CParticleCollectionFloatInput
}

public static class C_OP_ExternalGameImpulseForce {
    public const nint m_flForceScale = 0x1D0; // CPerParticleFloatInput
    public const nint m_bRopes = 0x328; // bool
    public const nint m_bRopesZOnly = 0x329; // bool
    public const nint m_bExplosions = 0x32A; // bool
    public const nint m_bParticles = 0x32B; // bool
}

public static class C_OP_ExternalWindForce {
    public const nint m_vecSamplePosition = 0x1D0; // CPerParticleVecInput
    public const nint m_vecScale = 0x828; // CPerParticleVecInput
    public const nint m_bSampleWind = 0xE80; // bool
    public const nint m_bSampleWater = 0xE81; // bool
    public const nint m_bDampenNearWaterPlane = 0xE82; // bool
    public const nint m_bSampleGravity = 0xE83; // bool
    public const nint m_vecGravityForce = 0xE88; // CPerParticleVecInput
    public const nint m_bUseBasicMovementGravity = 0x14E0; // bool
    public const nint m_flLocalGravityScale = 0x14E8; // CPerParticleFloatInput
    public const nint m_flLocalBuoyancyScale = 0x1640; // CPerParticleFloatInput
    public const nint m_vecBuoyancyForce = 0x1798; // CPerParticleVecInput
}

public static class C_OP_FadeAndKill {
    public const nint m_flStartFadeInTime = 0x1C0; // float
    public const nint m_flEndFadeInTime = 0x1C4; // float
    public const nint m_flStartFadeOutTime = 0x1C8; // float
    public const nint m_flEndFadeOutTime = 0x1CC; // float
    public const nint m_flStartAlpha = 0x1D0; // float
    public const nint m_flEndAlpha = 0x1D4; // float
    public const nint m_bForcePreserveParticleOrder = 0x1D8; // bool
}

public static class C_OP_FadeAndKillForTracers {
    public const nint m_flStartFadeInTime = 0x1C0; // float
    public const nint m_flEndFadeInTime = 0x1C4; // float
    public const nint m_flStartFadeOutTime = 0x1C8; // float
    public const nint m_flEndFadeOutTime = 0x1CC; // float
    public const nint m_flStartAlpha = 0x1D0; // float
    public const nint m_flEndAlpha = 0x1D4; // float
}

public static class C_OP_FadeIn {
    public const nint m_flFadeInTimeMin = 0x1C0; // float
    public const nint m_flFadeInTimeMax = 0x1C4; // float
    public const nint m_flFadeInTimeExp = 0x1C8; // float
    public const nint m_bProportional = 0x1CC; // bool
}

public static class C_OP_FadeInSimple {
    public const nint m_flFadeInTime = 0x1C0; // float
    public const nint m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
}

public static class C_OP_FadeOut {
    public const nint m_flFadeOutTimeMin = 0x1C0; // float
    public const nint m_flFadeOutTimeMax = 0x1C4; // float
    public const nint m_flFadeOutTimeExp = 0x1C8; // float
    public const nint m_flFadeBias = 0x1CC; // float
    public const nint m_bProportional = 0x200; // bool
    public const nint m_bEaseInAndOut = 0x201; // bool
}

public static class C_OP_FadeOutSimple {
    public const nint m_flFadeOutTime = 0x1C0; // float
    public const nint m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
}

public static class C_OP_ForceBasedOnDistanceToPlane {
    public const nint m_flMinDist = 0x1D0; // float
    public const nint m_vecForceAtMinDist = 0x1D4; // Vector
    public const nint m_flMaxDist = 0x1E0; // float
    public const nint m_vecForceAtMaxDist = 0x1E4; // Vector
    public const nint m_vecPlaneNormal = 0x1F0; // Vector
    public const nint m_nControlPointNumber = 0x1FC; // int32_t
    public const nint m_flExponent = 0x200; // float
}

public static class C_OP_ForceControlPointStub {
    public const nint m_ControlPoint = 0x1D0; // int32_t
}

public static class C_OP_GlobalLight {
    public const nint m_flScale = 0x1C0; // float
    public const nint m_bClampLowerRange = 0x1C4; // bool
    public const nint m_bClampUpperRange = 0x1C5; // bool
}

public static class C_OP_HSVShiftToCP {
    public const nint m_nColorCP = 0x1D0; // int32_t
    public const nint m_nColorGemEnableCP = 0x1D4; // int32_t
    public const nint m_nOutputCP = 0x1D8; // int32_t
    public const nint m_DefaultHSVColor = 0x1DC; // Color
}

public static class C_OP_InheritFromParentParticles {
    public const nint m_flScale = 0x1C0; // float
    public const nint m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    public const nint m_nIncrement = 0x1C8; // int32_t
    public const nint m_bRandomDistribution = 0x1CC; // bool
}

public static class C_OP_InheritFromParentParticlesV2 {
    public const nint m_flScale = 0x1C0; // float
    public const nint m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    public const nint m_nIncrement = 0x1C8; // int32_t
    public const nint m_bRandomDistribution = 0x1CC; // bool
    public const nint m_nMissingParentBehavior = 0x1D0; // MissingParentInheritBehavior_t
}

public static class C_OP_InheritFromPeerSystem {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_nFieldInput = 0x1C4; // ParticleAttributeIndex_t
    public const nint m_nIncrement = 0x1C8; // int32_t
    public const nint m_nGroupID = 0x1CC; // int32_t
}

public static class C_OP_InstantaneousEmitter {
    public const nint m_nParticlesToEmit = 0x1C0; // CParticleCollectionFloatInput
    public const nint m_flStartTime = 0x318; // CParticleCollectionFloatInput
    public const nint m_flInitFromKilledParentParticles = 0x470; // float
    public const nint m_flParentParticleScale = 0x478; // CParticleCollectionFloatInput
    public const nint m_nMaxEmittedPerFrame = 0x5D0; // int32_t
    public const nint m_nSnapshotControlPoint = 0x5D4; // int32_t
}

public static class C_OP_InterpolateRadius {
    public const nint m_flStartTime = 0x1C0; // float
    public const nint m_flEndTime = 0x1C4; // float
    public const nint m_flStartScale = 0x1C8; // float
    public const nint m_flEndScale = 0x1CC; // float
    public const nint m_bEaseInAndOut = 0x1D0; // bool
    public const nint m_flBias = 0x1D4; // float
}

public static class C_OP_LagCompensation {
    public const nint m_nDesiredVelocityCP = 0x1C0; // int32_t
    public const nint m_nLatencyCP = 0x1C4; // int32_t
    public const nint m_nLatencyCPField = 0x1C8; // int32_t
    public const nint m_nDesiredVelocityCPField = 0x1CC; // int32_t
}

public static class C_OP_LerpEndCapScalar {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_flOutput = 0x1C4; // float
    public const nint m_flLerpTime = 0x1C8; // float
}

public static class C_OP_LerpEndCapVector {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_vecOutput = 0x1C4; // Vector
    public const nint m_flLerpTime = 0x1D0; // float
}

public static class C_OP_LerpScalar {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_flOutput = 0x1C8; // CPerParticleFloatInput
    public const nint m_flStartTime = 0x320; // float
    public const nint m_flEndTime = 0x324; // float
}

public static class C_OP_LerpToInitialPosition {
    public const nint m_nControlPointNumber = 0x1C0; // int32_t
    public const nint m_flInterpolation = 0x1C8; // CPerParticleFloatInput
    public const nint m_nCacheField = 0x320; // ParticleAttributeIndex_t
    public const nint m_flScale = 0x328; // CParticleCollectionFloatInput
    public const nint m_vecScale = 0x480; // CParticleCollectionVecInput
}

public static class C_OP_LerpToOtherAttribute {
    public const nint m_flInterpolation = 0x1C0; // CPerParticleFloatInput
    public const nint m_nFieldInputFrom = 0x318; // ParticleAttributeIndex_t
    public const nint m_nFieldInput = 0x31C; // ParticleAttributeIndex_t
    public const nint m_nFieldOutput = 0x320; // ParticleAttributeIndex_t
}

public static class C_OP_LerpVector {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_vecOutput = 0x1C4; // Vector
    public const nint m_flStartTime = 0x1D0; // float
    public const nint m_flEndTime = 0x1D4; // float
    public const nint m_nSetMethod = 0x1D8; // ParticleSetMethod_t
}

public static class C_OP_LightningSnapshotGenerator {
    public const nint m_nCPSnapshot = 0x1D0; // int32_t
    public const nint m_nCPStartPnt = 0x1D4; // int32_t
    public const nint m_nCPEndPnt = 0x1D8; // int32_t
    public const nint m_flSegments = 0x1E0; // CParticleCollectionFloatInput
    public const nint m_flOffset = 0x338; // CParticleCollectionFloatInput
    public const nint m_flOffsetDecay = 0x490; // CParticleCollectionFloatInput
    public const nint m_flRecalcRate = 0x5E8; // CParticleCollectionFloatInput
    public const nint m_flUVScale = 0x740; // CParticleCollectionFloatInput
    public const nint m_flUVOffset = 0x898; // CParticleCollectionFloatInput
    public const nint m_flSplitRate = 0x9F0; // CParticleCollectionFloatInput
    public const nint m_flBranchTwist = 0xB48; // CParticleCollectionFloatInput
    public const nint m_nBranchBehavior = 0xCA0; // ParticleLightnintBranchBehavior_t
    public const nint m_flRadiusStart = 0xCA8; // CParticleCollectionFloatInput
    public const nint m_flRadiusEnd = 0xE00; // CParticleCollectionFloatInput
    public const nint m_flDedicatedPool = 0xF58; // CParticleCollectionFloatInput
}

public static class C_OP_LocalAccelerationForce {
    public const nint m_nCP = 0x1D0; // int32_t
    public const nint m_nScaleCP = 0x1D4; // int32_t
    public const nint m_vecAccel = 0x1D8; // CParticleCollectionVecInput
}

public static class C_OP_LockPoints {
    public const nint m_nMinCol = 0x1C0; // int32_t
    public const nint m_nMaxCol = 0x1C4; // int32_t
    public const nint m_nMinRow = 0x1C8; // int32_t
    public const nint m_nMaxRow = 0x1CC; // int32_t
    public const nint m_nControlPoint = 0x1D0; // int32_t
    public const nint m_flBlendValue = 0x1D4; // float
}

public static class C_OP_LockToBone {
    public const nint m_modelInput = 0x1C0; // CParticleModelInput
    public const nint m_transformInput = 0x220; // CParticleTransformInput
    public const nint m_flLifeTimeFadeStart = 0x288; // float
    public const nint m_flLifeTimeFadeEnd = 0x28C; // float
    public const nint m_flJumpThreshold = 0x290; // float
    public const nint m_flPrevPosScale = 0x294; // float
    public const nint m_HitboxSetName = 0x298; // char[128]
    public const nint m_bRigid = 0x318; // bool
    public const nint m_bUseBones = 0x319; // bool
    public const nint m_nFieldOutput = 0x31C; // ParticleAttributeIndex_t
    public const nint m_nFieldOutputPrev = 0x320; // ParticleAttributeIndex_t
    public const nint m_nRotationSetType = 0x324; // ParticleRotationLockType_t
    public const nint m_bRigidRotationLock = 0x328; // bool
    public const nint m_vecRotation = 0x330; // CPerParticleVecInput
    public const nint m_flRotLerp = 0x988; // CPerParticleFloatInput
}

public static class C_OP_LockToPointList {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_pointList = 0x1C8; // CUtlVector<PointDefinition_t>
    public const nint m_bPlaceAlongPath = 0x1E0; // bool
    public const nint m_bClosedLoop = 0x1E1; // bool
    public const nint m_nNumPointsAlongPath = 0x1E4; // int32_t
}

public static class C_OP_LockToSavedSequentialPath {
    public const nint m_flFadeStart = 0x1C4; // float
    public const nint m_flFadeEnd = 0x1C8; // float
    public const nint m_bCPPairs = 0x1CC; // bool
    public const nint m_PathParams = 0x1D0; // CPathParameters
}

public static class C_OP_LockToSavedSequentialPathV2 {
    public const nint m_flFadeStart = 0x1C0; // float
    public const nint m_flFadeEnd = 0x1C4; // float
    public const nint m_bCPPairs = 0x1C8; // bool
    public const nint m_PathParams = 0x1D0; // CPathParameters
}

public static class C_OP_MaintainEmitter {
    public const nint m_nParticlesToMaintain = 0x1C0; // CParticleCollectionFloatInput
    public const nint m_flStartTime = 0x318; // float
    public const nint m_flEmissionDuration = 0x320; // CParticleCollectionFloatInput
    public const nint m_flEmissionRate = 0x478; // float
    public const nint m_nSnapshotControlPoint = 0x47C; // int32_t
    public const nint m_bEmitInstantaneously = 0x480; // bool
    public const nint m_bFinalEmitOnStop = 0x481; // bool
    public const nint m_flScale = 0x488; // CParticleCollectionFloatInput
}

public static class C_OP_MaintainSequentialPath {
    public const nint m_fMaxDistance = 0x1C0; // float
    public const nint m_flNumToAssign = 0x1C4; // float
    public const nint m_flCohesionStrength = 0x1C8; // float
    public const nint m_flTolerance = 0x1CC; // float
    public const nint m_bLoop = 0x1D0; // bool
    public const nint m_bUseParticleCount = 0x1D1; // bool
    public const nint m_PathParams = 0x1E0; // CPathParameters
}

public static class C_OP_MaxVelocity {
    public const nint m_flMaxVelocity = 0x1C0; // float
    public const nint m_flMinVelocity = 0x1C4; // float
    public const nint m_nOverrideCP = 0x1C8; // int32_t
    public const nint m_nOverrideCPField = 0x1CC; // int32_t
}

public static class C_OP_ModelCull {
    public const nint m_nControlPointNumber = 0x1C0; // int32_t
    public const nint m_bBoundBox = 0x1C4; // bool
    public const nint m_bCullOutside = 0x1C5; // bool
    public const nint m_bUseBones = 0x1C6; // bool
    public const nint m_HitboxSetName = 0x1C7; // char[128]
}

public static class C_OP_ModelDampenMovement {
    public const nint m_nControlPointNumber = 0x1C0; // int32_t
    public const nint m_bBoundBox = 0x1C4; // bool
    public const nint m_bOutside = 0x1C5; // bool
    public const nint m_bUseBones = 0x1C6; // bool
    public const nint m_HitboxSetName = 0x1C7; // char[128]
    public const nint m_vecPosOffset = 0x248; // CPerParticleVecInput
    public const nint m_fDrag = 0x8A0; // float
}

public static class C_OP_MoveToHitbox {
    public const nint m_modelInput = 0x1C0; // CParticleModelInput
    public const nint m_transformInput = 0x220; // CParticleTransformInput
    public const nint m_flLifeTimeLerpStart = 0x28C; // float
    public const nint m_flLifeTimeLerpEnd = 0x290; // float
    public const nint m_flPrevPosScale = 0x294; // float
    public const nint m_HitboxSetName = 0x298; // char[128]
    public const nint m_bUseBones = 0x318; // bool
    public const nint m_nLerpType = 0x31C; // HitboxLerpType_t
    public const nint m_flInterpolation = 0x320; // CPerParticleFloatInput
}

public static class C_OP_MovementLoopInsideSphere {
    public const nint m_nCP = 0x1C0; // int32_t
    public const nint m_flDistance = 0x1C8; // CParticleCollectionFloatInput
    public const nint m_vecScale = 0x320; // CParticleCollectionVecInput
    public const nint m_nDistSqrAttr = 0x978; // ParticleAttributeIndex_t
}

public static class C_OP_MovementMaintainOffset {
    public const nint m_vecOffset = 0x1C0; // Vector
    public const nint m_nCP = 0x1CC; // int32_t
    public const nint m_bRadiusScale = 0x1D0; // bool
}

public static class C_OP_MovementMoveAlongSkinnedCPSnapshot {
    public const nint m_nControlPointNumber = 0x1C0; // int32_t
    public const nint m_nSnapshotControlPointNumber = 0x1C4; // int32_t
    public const nint m_bSetNormal = 0x1C8; // bool
    public const nint m_bSetRadius = 0x1C9; // bool
    public const nint m_flInterpolation = 0x1D0; // CPerParticleFloatInput
    public const nint m_flTValue = 0x328; // CPerParticleFloatInput
}

public static class C_OP_MovementPlaceOnGround {
    public const nint m_flOffset = 0x1C0; // CPerParticleFloatInput
    public const nint m_flMaxTraceLength = 0x318; // float
    public const nint m_flTolerance = 0x31C; // float
    public const nint m_flTraceOffset = 0x320; // float
    public const nint m_flLerpRate = 0x324; // float
    public const nint m_CollisionGroupName = 0x328; // char[128]
    public const nint m_nTraceSet = 0x3A8; // ParticleTraceSet_t
    public const nint m_nRefCP1 = 0x3AC; // int32_t
    public const nint m_nRefCP2 = 0x3B0; // int32_t
    public const nint m_nLerpCP = 0x3B4; // int32_t
    public const nint m_nTraceMissBehavior = 0x3C0; // ParticleTraceMissBehavior_t
    public const nint m_bIncludeShotHull = 0x3C4; // bool
    public const nint m_bIncludeWater = 0x3C5; // bool
    public const nint m_bSetNormal = 0x3C8; // bool
    public const nint m_bScaleOffset = 0x3C9; // bool
    public const nint m_nPreserveOffsetCP = 0x3CC; // int32_t
    public const nint m_nIgnoreCP = 0x3D0; // int32_t
}

public static class C_OP_MovementRigidAttachToCP {
    public const nint m_nControlPointNumber = 0x1C0; // int32_t
    public const nint m_nScaleControlPoint = 0x1C4; // int32_t
    public const nint m_nScaleCPField = 0x1C8; // int32_t
    public const nint m_nFieldInput = 0x1CC; // ParticleAttributeIndex_t
    public const nint m_nFieldOutput = 0x1D0; // ParticleAttributeIndex_t
    public const nint m_bOffsetLocal = 0x1D4; // bool
}

public static class C_OP_MovementRotateParticleAroundAxis {
    public const nint m_vecRotAxis = 0x1C0; // CParticleCollectionVecInput
    public const nint m_flRotRate = 0x818; // CParticleCollectionFloatInput
    public const nint m_TransformInput = 0x970; // CParticleTransformInput
    public const nint m_bLocalSpace = 0x9D8; // bool
}

public static class C_OP_MovementSkinnedPositionFromCPSnapshot {
    public const nint m_nSnapshotControlPointNumber = 0x1C0; // int32_t
    public const nint m_nControlPointNumber = 0x1C4; // int32_t
    public const nint m_bRandom = 0x1C8; // bool
    public const nint m_nRandomSeed = 0x1CC; // int32_t
    public const nint m_bSetNormal = 0x1D0; // bool
    public const nint m_bSetRadius = 0x1D1; // bool
    public const nint m_flIncrement = 0x1D8; // CParticleCollectionFloatInput
    public const nint m_nFullLoopIncrement = 0x330; // CParticleCollectionFloatInput
    public const nint m_nSnapShotStartPoint = 0x488; // CParticleCollectionFloatInput
    public const nint m_flInterpolation = 0x5E0; // CPerParticleFloatInput
}

public static class C_OP_Noise {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_flOutputMin = 0x1C4; // float
    public const nint m_flOutputMax = 0x1C8; // float
    public const nint m_fl4NoiseScale = 0x1CC; // float
    public const nint m_bAdditive = 0x1D0; // bool
    public const nint m_flNoiseAnimationTimeScale = 0x1D4; // float
}

public static class C_OP_NoiseEmitter {
    public const nint m_flEmissionDuration = 0x1C0; // float
    public const nint m_flStartTime = 0x1C4; // float
    public const nint m_flEmissionScale = 0x1C8; // float
    public const nint m_nScaleControlPoint = 0x1CC; // int32_t
    public const nint m_nScaleControlPointField = 0x1D0; // int32_t
    public const nint m_nWorldNoisePoint = 0x1D4; // int32_t
    public const nint m_bAbsVal = 0x1D8; // bool
    public const nint m_bAbsValInv = 0x1D9; // bool
    public const nint m_flOffset = 0x1DC; // float
    public const nint m_flOutputMin = 0x1E0; // float
    public const nint m_flOutputMax = 0x1E4; // float
    public const nint m_flNoiseScale = 0x1E8; // float
    public const nint m_flWorldNoiseScale = 0x1EC; // float
    public const nint m_vecOffsetLoc = 0x1F0; // Vector
    public const nint m_flWorldTimeScale = 0x1FC; // float
}

public static class C_OP_NormalLock {
    public const nint m_nControlPointNumber = 0x1C0; // int32_t
}

public static class C_OP_NormalizeVector {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_flScale = 0x1C4; // float
}

public static class C_OP_Orient2DRelToCP {
    public const nint m_flRotOffset = 0x1C0; // float
    public const nint m_flSpinStrength = 0x1C4; // float
    public const nint m_nCP = 0x1C8; // int32_t
    public const nint m_nFieldOutput = 0x1CC; // ParticleAttributeIndex_t
}

public static class C_OP_OrientTo2dDirection {
    public const nint m_flRotOffset = 0x1C0; // float
    public const nint m_flSpinStrength = 0x1C4; // float
    public const nint m_nFieldOutput = 0x1C8; // ParticleAttributeIndex_t
}

public static class C_OP_OscillateScalar {
    public const nint m_RateMin = 0x1C0; // float
    public const nint m_RateMax = 0x1C4; // float
    public const nint m_FrequencyMin = 0x1C8; // float
    public const nint m_FrequencyMax = 0x1CC; // float
    public const nint m_nField = 0x1D0; // ParticleAttributeIndex_t
    public const nint m_bProportional = 0x1D4; // bool
    public const nint m_bProportionalOp = 0x1D5; // bool
    public const nint m_flStartTime_min = 0x1D8; // float
    public const nint m_flStartTime_max = 0x1DC; // float
    public const nint m_flEndTime_min = 0x1E0; // float
    public const nint m_flEndTime_max = 0x1E4; // float
    public const nint m_flOscMult = 0x1E8; // float
    public const nint m_flOscAdd = 0x1EC; // float
}

public static class C_OP_OscillateScalarSimple {
    public const nint m_Rate = 0x1C0; // float
    public const nint m_Frequency = 0x1C4; // float
    public const nint m_nField = 0x1C8; // ParticleAttributeIndex_t
    public const nint m_flOscMult = 0x1CC; // float
    public const nint m_flOscAdd = 0x1D0; // float
}

public static class C_OP_OscillateVector {
    public const nint m_RateMin = 0x1C0; // Vector
    public const nint m_RateMax = 0x1CC; // Vector
    public const nint m_FrequencyMin = 0x1D8; // Vector
    public const nint m_FrequencyMax = 0x1E4; // Vector
    public const nint m_nField = 0x1F0; // ParticleAttributeIndex_t
    public const nint m_bProportional = 0x1F4; // bool
    public const nint m_bProportionalOp = 0x1F5; // bool
    public const nint m_bOffset = 0x1F6; // bool
    public const nint m_flStartTime_min = 0x1F8; // float
    public const nint m_flStartTime_max = 0x1FC; // float
    public const nint m_flEndTime_min = 0x200; // float
    public const nint m_flEndTime_max = 0x204; // float
    public const nint m_flOscMult = 0x208; // CPerParticleFloatInput
    public const nint m_flOscAdd = 0x360; // CPerParticleFloatInput
    public const nint m_flRateScale = 0x4B8; // CPerParticleFloatInput
}

public static class C_OP_OscillateVectorSimple {
    public const nint m_Rate = 0x1C0; // Vector
    public const nint m_Frequency = 0x1CC; // Vector
    public const nint m_nField = 0x1D8; // ParticleAttributeIndex_t
    public const nint m_flOscMult = 0x1DC; // float
    public const nint m_flOscAdd = 0x1E0; // float
    public const nint m_bOffset = 0x1E4; // bool
}

public static class C_OP_ParentVortices {
    public const nint m_flForceScale = 0x1D0; // float
    public const nint m_vecTwistAxis = 0x1D4; // Vector
    public const nint m_bFlipBasedOnYaw = 0x1E0; // bool
}

public static class C_OP_ParticlePhysics {
    public const nint m_Gravity = 0x1C0; // CParticleCollectionVecInput
    public const nint m_fDrag = 0x818; // CParticleCollectionFloatInput
    public const nint m_nMaxConstraintPasses = 0x970; // int32_t
}

public static class C_OP_PerParticleForce {
    public const nint m_flForceScale = 0x1D0; // CPerParticleFloatInput
    public const nint m_vForce = 0x328; // CPerParticleVecInput
    public const nint m_nCP = 0x980; // int32_t
}

public static class C_OP_PercentageBetweenTransformLerpCPs {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_flInputMin = 0x1C4; // float
    public const nint m_flInputMax = 0x1C8; // float
    public const nint m_TransformStart = 0x1D0; // CParticleTransformInput
    public const nint m_TransformEnd = 0x238; // CParticleTransformInput
    public const nint m_nOutputStartCP = 0x2A0; // int32_t
    public const nint m_nOutputStartField = 0x2A4; // int32_t
    public const nint m_nOutputEndCP = 0x2A8; // int32_t
    public const nint m_nOutputEndField = 0x2AC; // int32_t
    public const nint m_nSetMethod = 0x2B0; // ParticleSetMethod_t
    public const nint m_bActiveRange = 0x2B4; // bool
    public const nint m_bRadialCheck = 0x2B5; // bool
}

public static class C_OP_PercentageBetweenTransforms {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_flInputMin = 0x1C4; // float
    public const nint m_flInputMax = 0x1C8; // float
    public const nint m_flOutputMin = 0x1CC; // float
    public const nint m_flOutputMax = 0x1D0; // float
    public const nint m_TransformStart = 0x1D8; // CParticleTransformInput
    public const nint m_TransformEnd = 0x240; // CParticleTransformInput
    public const nint m_nSetMethod = 0x2A8; // ParticleSetMethod_t
    public const nint m_bActiveRange = 0x2AC; // bool
    public const nint m_bRadialCheck = 0x2AD; // bool
}

public static class C_OP_PercentageBetweenTransformsVector {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_flInputMin = 0x1C4; // float
    public const nint m_flInputMax = 0x1C8; // float
    public const nint m_vecOutputMin = 0x1CC; // Vector
    public const nint m_vecOutputMax = 0x1D8; // Vector
    public const nint m_TransformStart = 0x1E8; // CParticleTransformInput
    public const nint m_TransformEnd = 0x250; // CParticleTransformInput
    public const nint m_nSetMethod = 0x2B8; // ParticleSetMethod_t
    public const nint m_bActiveRange = 0x2BC; // bool
    public const nint m_bRadialCheck = 0x2BD; // bool
}

public static class C_OP_PinParticleToCP {
    public const nint m_nControlPointNumber = 0x1C0; // int32_t
    public const nint m_vecOffset = 0x1C8; // CParticleCollectionVecInput
    public const nint m_bOffsetLocal = 0x820; // bool
    public const nint m_nParticleSelection = 0x824; // ParticleSelection_t
    public const nint m_nParticleNumber = 0x828; // CParticleCollectionFloatInput
    public const nint m_nPinBreakType = 0x980; // ParticlePinDistance_t
    public const nint m_flBreakDistance = 0x988; // CParticleCollectionFloatInput
    public const nint m_flBreakSpeed = 0xAE0; // CParticleCollectionFloatInput
    public const nint m_flAge = 0xC38; // CParticleCollectionFloatInput
    public const nint m_nBreakControlPointNumber = 0xD90; // int32_t
    public const nint m_nBreakControlPointNumber2 = 0xD94; // int32_t
    public const nint m_flBreakValue = 0xD98; // CParticleCollectionFloatInput
    public const nint m_flInterpolation = 0xEF0; // CPerParticleFloatInput
}

public static class C_OP_PlanarConstraint {
    public const nint m_PointOnPlane = 0x1C0; // Vector
    public const nint m_PlaneNormal = 0x1CC; // Vector
    public const nint m_nControlPointNumber = 0x1D8; // int32_t
    public const nint m_bGlobalOrigin = 0x1DC; // bool
    public const nint m_bGlobalNormal = 0x1DD; // bool
    public const nint m_flRadiusScale = 0x1E0; // CPerParticleFloatInput
    public const nint m_flMaximumDistanceToCP = 0x338; // CParticleCollectionFloatInput
}

public static class C_OP_PlaneCull {
    public const nint m_nPlaneControlPoint = 0x1C0; // int32_t
    public const nint m_vecPlaneDirection = 0x1C4; // Vector
    public const nint m_bLocalSpace = 0x1D0; // bool
    public const nint m_flPlaneOffset = 0x1D4; // float
}

public static class C_OP_PlayEndCapWhenFinished {
    public const nint m_bFireOnEmissionEnd = 0x1D0; // bool
    public const nint m_bIncludeChildren = 0x1D1; // bool
}

public static class C_OP_PointVectorAtNextParticle {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_flInterpolation = 0x1C8; // CPerParticleFloatInput
}

public static class C_OP_PositionLock {
    public const nint m_TransformInput = 0x1C0; // CParticleTransformInput
    public const nint m_flStartTime_min = 0x228; // float
    public const nint m_flStartTime_max = 0x22C; // float
    public const nint m_flStartTime_exp = 0x230; // float
    public const nint m_flEndTime_min = 0x234; // float
    public const nint m_flEndTime_max = 0x238; // float
    public const nint m_flEndTime_exp = 0x23C; // float
    public const nint m_flRange = 0x240; // float
    public const nint m_flRangeBias = 0x248; // CParticleCollectionFloatInput
    public const nint m_flJumpThreshold = 0x3A0; // float
    public const nint m_flPrevPosScale = 0x3A4; // float
    public const nint m_bLockRot = 0x3A8; // bool
    public const nint m_vecScale = 0x3B0; // CParticleCollectionVecInput
    public const nint m_nFieldOutput = 0xA08; // ParticleAttributeIndex_t
    public const nint m_nFieldOutputPrev = 0xA0C; // ParticleAttributeIndex_t
}

public static class C_OP_QuantizeCPComponent {
    public const nint m_flInputValue = 0x1D0; // CParticleCollectionFloatInput
    public const nint m_nCPOutput = 0x328; // int32_t
    public const nint m_nOutVectorField = 0x32C; // int32_t
    public const nint m_flQuantizeValue = 0x330; // CParticleCollectionFloatInput
}

public static class C_OP_QuantizeFloat {
    public const nint m_InputValue = 0x1C0; // CPerParticleFloatInput
    public const nint m_nOutputField = 0x318; // ParticleAttributeIndex_t
}

public static class C_OP_RadiusDecay {
    public const nint m_flMinRadius = 0x1C0; // float
}

public static class C_OP_RampCPLinearRandom {
    public const nint m_nOutControlPointNumber = 0x1D0; // int32_t
    public const nint m_vecRateMin = 0x1D4; // Vector
    public const nint m_vecRateMax = 0x1E0; // Vector
}

public static class C_OP_RampScalarLinear {
    public const nint m_RateMin = 0x1C0; // float
    public const nint m_RateMax = 0x1C4; // float
    public const nint m_flStartTime_min = 0x1C8; // float
    public const nint m_flStartTime_max = 0x1CC; // float
    public const nint m_flEndTime_min = 0x1D0; // float
    public const nint m_flEndTime_max = 0x1D4; // float
    public const nint m_nField = 0x200; // ParticleAttributeIndex_t
    public const nint m_bProportionalOp = 0x204; // bool
}

public static class C_OP_RampScalarLinearSimple {
    public const nint m_Rate = 0x1C0; // float
    public const nint m_flStartTime = 0x1C4; // float
    public const nint m_flEndTime = 0x1C8; // float
    public const nint m_nField = 0x1F0; // ParticleAttributeIndex_t
}

public static class C_OP_RampScalarSpline {
    public const nint m_RateMin = 0x1C0; // float
    public const nint m_RateMax = 0x1C4; // float
    public const nint m_flStartTime_min = 0x1C8; // float
    public const nint m_flStartTime_max = 0x1CC; // float
    public const nint m_flEndTime_min = 0x1D0; // float
    public const nint m_flEndTime_max = 0x1D4; // float
    public const nint m_flBias = 0x1D8; // float
    public const nint m_nField = 0x200; // ParticleAttributeIndex_t
    public const nint m_bProportionalOp = 0x204; // bool
    public const nint m_bEaseOut = 0x205; // bool
}

public static class C_OP_RampScalarSplineSimple {
    public const nint m_Rate = 0x1C0; // float
    public const nint m_flStartTime = 0x1C4; // float
    public const nint m_flEndTime = 0x1C8; // float
    public const nint m_nField = 0x1F0; // ParticleAttributeIndex_t
    public const nint m_bEaseOut = 0x1F4; // bool
}

public static class C_OP_RandomForce {
    public const nint m_MinForce = 0x1D0; // Vector
    public const nint m_MaxForce = 0x1DC; // Vector
}

public static class C_OP_ReadFromNeighboringParticle {
    public const nint m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    public const nint m_nIncrement = 0x1C8; // int32_t
    public const nint m_DistanceCheck = 0x1D0; // CPerParticleFloatInput
    public const nint m_flInterpolation = 0x328; // CPerParticleFloatInput
}

public static class C_OP_ReinitializeScalarEndCap {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_flOutputMin = 0x1C4; // float
    public const nint m_flOutputMax = 0x1C8; // float
}

public static class C_OP_RemapAverageHitboxSpeedtoCP {
    public const nint m_nInControlPointNumber = 0x1D0; // int32_t
    public const nint m_nOutControlPointNumber = 0x1D4; // int32_t
    public const nint m_nField = 0x1D8; // int32_t
    public const nint m_nHitboxDataType = 0x1DC; // ParticleHitboxDataSelection_t
    public const nint m_flInputMin = 0x1E0; // CParticleCollectionFloatInput
    public const nint m_flInputMax = 0x338; // CParticleCollectionFloatInput
    public const nint m_flOutputMin = 0x490; // CParticleCollectionFloatInput
    public const nint m_flOutputMax = 0x5E8; // CParticleCollectionFloatInput
    public const nint m_nHeightControlPointNumber = 0x740; // int32_t
    public const nint m_vecComparisonVelocity = 0x748; // CParticleCollectionVecInput
    public const nint m_HitboxSetName = 0xDA0; // char[128]
}

public static class C_OP_RemapAverageScalarValuetoCP {
    public const nint m_nOutControlPointNumber = 0x1D0; // int32_t
    public const nint m_nOutVectorField = 0x1D4; // int32_t
    public const nint m_nField = 0x1D8; // ParticleAttributeIndex_t
    public const nint m_flInputMin = 0x1DC; // float
    public const nint m_flInputMax = 0x1E0; // float
    public const nint m_flOutputMin = 0x1E4; // float
    public const nint m_flOutputMax = 0x1E8; // float
}

public static class C_OP_RemapBoundingVolumetoCP {
    public const nint m_nOutControlPointNumber = 0x1D0; // int32_t
    public const nint m_flInputMin = 0x1D4; // float
    public const nint m_flInputMax = 0x1D8; // float
    public const nint m_flOutputMin = 0x1DC; // float
    public const nint m_flOutputMax = 0x1E0; // float
}

public static class C_OP_RemapCPVelocityToVector {
    public const nint m_nControlPoint = 0x1C0; // int32_t
    public const nint m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    public const nint m_flScale = 0x1C8; // float
    public const nint m_bNormalize = 0x1CC; // bool
}

public static class C_OP_RemapCPtoCP {
    public const nint m_nInputControlPoint = 0x1D0; // int32_t
    public const nint m_nOutputControlPoint = 0x1D4; // int32_t
    public const nint m_nInputField = 0x1D8; // int32_t
    public const nint m_nOutputField = 0x1DC; // int32_t
    public const nint m_flInputMin = 0x1E0; // float
    public const nint m_flInputMax = 0x1E4; // float
    public const nint m_flOutputMin = 0x1E8; // float
    public const nint m_flOutputMax = 0x1EC; // float
    public const nint m_bDerivative = 0x1F0; // bool
    public const nint m_flInterpRate = 0x1F4; // float
}

public static class C_OP_RemapCPtoScalar {
    public const nint m_nCPInput = 0x1C0; // int32_t
    public const nint m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    public const nint m_nField = 0x1C8; // int32_t
    public const nint m_flInputMin = 0x1CC; // float
    public const nint m_flInputMax = 0x1D0; // float
    public const nint m_flOutputMin = 0x1D4; // float
    public const nint m_flOutputMax = 0x1D8; // float
    public const nint m_flStartTime = 0x1DC; // float
    public const nint m_flEndTime = 0x1E0; // float
    public const nint m_flInterpRate = 0x1E4; // float
    public const nint m_nSetMethod = 0x1E8; // ParticleSetMethod_t
}

public static class C_OP_RemapCPtoVector {
    public const nint m_nCPInput = 0x1C0; // int32_t
    public const nint m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    public const nint m_nLocalSpaceCP = 0x1C8; // int32_t
    public const nint m_vInputMin = 0x1CC; // Vector
    public const nint m_vInputMax = 0x1D8; // Vector
    public const nint m_vOutputMin = 0x1E4; // Vector
    public const nint m_vOutputMax = 0x1F0; // Vector
    public const nint m_flStartTime = 0x1FC; // float
    public const nint m_flEndTime = 0x200; // float
    public const nint m_flInterpRate = 0x204; // float
    public const nint m_nSetMethod = 0x208; // ParticleSetMethod_t
    public const nint m_bOffset = 0x20C; // bool
    public const nint m_bAccelerate = 0x20D; // bool
}

public static class C_OP_RemapControlPointDirectionToVector {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_flScale = 0x1C4; // float
    public const nint m_nControlPointNumber = 0x1C8; // int32_t
}

public static class C_OP_RemapControlPointOrientationToRotation {
    public const nint m_nCP = 0x1C0; // int32_t
    public const nint m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    public const nint m_flOffsetRot = 0x1C8; // float
    public const nint m_nComponent = 0x1CC; // int32_t
}

public static class C_OP_RemapCrossProductOfTwoVectorsToVector {
    public const nint m_InputVec1 = 0x1C0; // CPerParticleVecInput
    public const nint m_InputVec2 = 0x818; // CPerParticleVecInput
    public const nint m_nFieldOutput = 0xE70; // ParticleAttributeIndex_t
    public const nint m_bNormalize = 0xE74; // bool
}

public static class C_OP_RemapDensityGradientToVectorAttribute {
    public const nint m_flRadiusScale = 0x1C0; // float
    public const nint m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
}

public static class C_OP_RemapDensityToVector {
    public const nint m_flRadiusScale = 0x1C0; // float
    public const nint m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    public const nint m_flDensityMin = 0x1C8; // float
    public const nint m_flDensityMax = 0x1CC; // float
    public const nint m_vecOutputMin = 0x1D0; // Vector
    public const nint m_vecOutputMax = 0x1DC; // Vector
    public const nint m_bUseParentDensity = 0x1E8; // bool
    public const nint m_nVoxelGridResolution = 0x1EC; // int32_t
}

public static class C_OP_RemapDirectionToCPToVector {
    public const nint m_nCP = 0x1C0; // int32_t
    public const nint m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    public const nint m_flScale = 0x1C8; // float
    public const nint m_flOffsetRot = 0x1CC; // float
    public const nint m_vecOffsetAxis = 0x1D0; // Vector
    public const nint m_bNormalize = 0x1DC; // bool
    public const nint m_nFieldStrength = 0x1E0; // ParticleAttributeIndex_t
}

public static class C_OP_RemapDistanceToLineSegmentBase {
    public const nint m_nCP0 = 0x1C0; // int32_t
    public const nint m_nCP1 = 0x1C4; // int32_t
    public const nint m_flMinInputValue = 0x1C8; // float
    public const nint m_flMaxInputValue = 0x1CC; // float
    public const nint m_bInfiniteLine = 0x1D0; // bool
}

public static class C_OP_RemapDistanceToLineSegmentToScalar {
    public const nint m_nFieldOutput = 0x1E0; // ParticleAttributeIndex_t
    public const nint m_flMinOutputValue = 0x1E4; // float
    public const nint m_flMaxOutputValue = 0x1E8; // float
}

public static class C_OP_RemapDistanceToLineSegmentToVector {
    public const nint m_nFieldOutput = 0x1E0; // ParticleAttributeIndex_t
    public const nint m_vMinOutputValue = 0x1E4; // Vector
    public const nint m_vMaxOutputValue = 0x1F0; // Vector
}

public static class C_OP_RemapDotProductToCP {
    public const nint m_nInputCP1 = 0x1D0; // int32_t
    public const nint m_nInputCP2 = 0x1D4; // int32_t
    public const nint m_nOutputCP = 0x1D8; // int32_t
    public const nint m_nOutVectorField = 0x1DC; // int32_t
    public const nint m_flInputMin = 0x1E0; // CParticleCollectionFloatInput
    public const nint m_flInputMax = 0x338; // CParticleCollectionFloatInput
    public const nint m_flOutputMin = 0x490; // CParticleCollectionFloatInput
    public const nint m_flOutputMax = 0x5E8; // CParticleCollectionFloatInput
}

public static class C_OP_RemapDotProductToScalar {
    public const nint m_nInputCP1 = 0x1C0; // int32_t
    public const nint m_nInputCP2 = 0x1C4; // int32_t
    public const nint m_nFieldOutput = 0x1C8; // ParticleAttributeIndex_t
    public const nint m_flInputMin = 0x1CC; // float
    public const nint m_flInputMax = 0x1D0; // float
    public const nint m_flOutputMin = 0x1D4; // float
    public const nint m_flOutputMax = 0x1D8; // float
    public const nint m_bUseParticleVelocity = 0x1DC; // bool
    public const nint m_nSetMethod = 0x1E0; // ParticleSetMethod_t
    public const nint m_bActiveRange = 0x1E4; // bool
    public const nint m_bUseParticleNormal = 0x1E5; // bool
}

public static class C_OP_RemapExternalWindToCP {
    public const nint m_nCP = 0x1D0; // int32_t
    public const nint m_nCPOutput = 0x1D4; // int32_t
    public const nint m_vecScale = 0x1D8; // CParticleCollectionVecInput
    public const nint m_bSetMagnitude = 0x830; // bool
    public const nint m_nOutVectorField = 0x834; // int32_t
}

public static class C_OP_RemapModelVolumetoCP {
    public const nint m_nBBoxType = 0x1D0; // BBoxVolumeType_t
    public const nint m_nInControlPointNumber = 0x1D4; // int32_t
    public const nint m_nOutControlPointNumber = 0x1D8; // int32_t
    public const nint m_nOutControlPointMaxNumber = 0x1DC; // int32_t
    public const nint m_nField = 0x1E0; // int32_t
    public const nint m_flInputMin = 0x1E4; // float
    public const nint m_flInputMax = 0x1E8; // float
    public const nint m_flOutputMin = 0x1EC; // float
    public const nint m_flOutputMax = 0x1F0; // float
}

public static class C_OP_RemapNamedModelElementEndCap {
    public const nint m_hModel = 0x1C0; // CStrongHandle<InfoForResourceTypeCModel>
    public const nint m_inNames = 0x1C8; // CUtlVector<CUtlString>
    public const nint m_outNames = 0x1E0; // CUtlVector<CUtlString>
    public const nint m_fallbackNames = 0x1F8; // CUtlVector<CUtlString>
    public const nint m_bModelFromRenderer = 0x210; // bool
    public const nint m_nFieldInput = 0x214; // ParticleAttributeIndex_t
    public const nint m_nFieldOutput = 0x218; // ParticleAttributeIndex_t
}

public static class C_OP_RemapNamedModelElementOnceTimed {
    public const nint m_hModel = 0x1C0; // CStrongHandle<InfoForResourceTypeCModel>
    public const nint m_inNames = 0x1C8; // CUtlVector<CUtlString>
    public const nint m_outNames = 0x1E0; // CUtlVector<CUtlString>
    public const nint m_fallbackNames = 0x1F8; // CUtlVector<CUtlString>
    public const nint m_bModelFromRenderer = 0x210; // bool
    public const nint m_bProportional = 0x211; // bool
    public const nint m_nFieldInput = 0x214; // ParticleAttributeIndex_t
    public const nint m_nFieldOutput = 0x218; // ParticleAttributeIndex_t
    public const nint m_flRemapTime = 0x21C; // float
}

public static class C_OP_RemapParticleCountOnScalarEndCap {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_nInputMin = 0x1C4; // int32_t
    public const nint m_nInputMax = 0x1C8; // int32_t
    public const nint m_flOutputMin = 0x1CC; // float
    public const nint m_flOutputMax = 0x1D0; // float
    public const nint m_bBackwards = 0x1D4; // bool
    public const nint m_nSetMethod = 0x1D8; // ParticleSetMethod_t
}

public static class C_OP_RemapParticleCountToScalar {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_nInputMin = 0x1C8; // CParticleCollectionFloatInput
    public const nint m_nInputMax = 0x320; // CParticleCollectionFloatInput
    public const nint m_flOutputMin = 0x478; // CParticleCollectionFloatInput
    public const nint m_flOutputMax = 0x5D0; // CParticleCollectionFloatInput
    public const nint m_bActiveRange = 0x728; // bool
    public const nint m_nSetMethod = 0x72C; // ParticleSetMethod_t
}

public static class C_OP_RemapSDFDistanceToScalarAttribute {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_nVectorFieldInput = 0x1C4; // ParticleAttributeIndex_t
    public const nint m_flMinDistance = 0x1C8; // CParticleCollectionFloatInput
    public const nint m_flMaxDistance = 0x320; // CParticleCollectionFloatInput
    public const nint m_flValueBelowMin = 0x478; // CParticleCollectionFloatInput
    public const nint m_flValueAtMin = 0x5D0; // CParticleCollectionFloatInput
    public const nint m_flValueAtMax = 0x728; // CParticleCollectionFloatInput
    public const nint m_flValueAboveMax = 0x880; // CParticleCollectionFloatInput
}

public static class C_OP_RemapSDFDistanceToVectorAttribute {
    public const nint m_nVectorFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_nVectorFieldInput = 0x1C4; // ParticleAttributeIndex_t
    public const nint m_flMinDistance = 0x1C8; // CParticleCollectionFloatInput
    public const nint m_flMaxDistance = 0x320; // CParticleCollectionFloatInput
    public const nint m_vValueBelowMin = 0x478; // Vector
    public const nint m_vValueAtMin = 0x484; // Vector
    public const nint m_vValueAtMax = 0x490; // Vector
    public const nint m_vValueAboveMax = 0x49C; // Vector
}

public static class C_OP_RemapSDFGradientToVectorAttribute {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
}

public static class C_OP_RemapScalar {
    public const nint m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    public const nint m_flInputMin = 0x1C8; // float
    public const nint m_flInputMax = 0x1CC; // float
    public const nint m_flOutputMin = 0x1D0; // float
    public const nint m_flOutputMax = 0x1D4; // float
    public const nint m_bOldCode = 0x1D8; // bool
}

public static class C_OP_RemapScalarEndCap {
    public const nint m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    public const nint m_flInputMin = 0x1C8; // float
    public const nint m_flInputMax = 0x1CC; // float
    public const nint m_flOutputMin = 0x1D0; // float
    public const nint m_flOutputMax = 0x1D4; // float
}

public static class C_OP_RemapScalarOnceTimed {
    public const nint m_bProportional = 0x1C0; // bool
    public const nint m_nFieldInput = 0x1C4; // ParticleAttributeIndex_t
    public const nint m_nFieldOutput = 0x1C8; // ParticleAttributeIndex_t
    public const nint m_flInputMin = 0x1CC; // float
    public const nint m_flInputMax = 0x1D0; // float
    public const nint m_flOutputMin = 0x1D4; // float
    public const nint m_flOutputMax = 0x1D8; // float
    public const nint m_flRemapTime = 0x1DC; // float
}

public static class C_OP_RemapSpeed {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_flInputMin = 0x1C4; // float
    public const nint m_flInputMax = 0x1C8; // float
    public const nint m_flOutputMin = 0x1CC; // float
    public const nint m_flOutputMax = 0x1D0; // float
    public const nint m_nSetMethod = 0x1D4; // ParticleSetMethod_t
    public const nint m_bIgnoreDelta = 0x1D8; // bool
}

public static class C_OP_RemapSpeedtoCP {
    public const nint m_nInControlPointNumber = 0x1D0; // int32_t
    public const nint m_nOutControlPointNumber = 0x1D4; // int32_t
    public const nint m_nField = 0x1D8; // int32_t
    public const nint m_flInputMin = 0x1DC; // float
    public const nint m_flInputMax = 0x1E0; // float
    public const nint m_flOutputMin = 0x1E4; // float
    public const nint m_flOutputMax = 0x1E8; // float
    public const nint m_bUseDeltaV = 0x1EC; // bool
}

public static class C_OP_RemapTransformOrientationToRotations {
    public const nint m_TransformInput = 0x1C0; // CParticleTransformInput
    public const nint m_vecRotation = 0x228; // Vector
    public const nint m_bUseQuat = 0x234; // bool
    public const nint m_bWriteNormal = 0x235; // bool
}

public static class C_OP_RemapTransformOrientationToYaw {
    public const nint m_TransformInput = 0x1C0; // CParticleTransformInput
    public const nint m_nFieldOutput = 0x228; // ParticleAttributeIndex_t
    public const nint m_flRotOffset = 0x22C; // float
    public const nint m_flSpinStrength = 0x230; // float
}

public static class C_OP_RemapTransformToVelocity {
    public const nint m_TransformInput = 0x1C0; // CParticleTransformInput
}

public static class C_OP_RemapTransformVisibilityToScalar {
    public const nint m_nSetMethod = 0x1C0; // ParticleSetMethod_t
    public const nint m_TransformInput = 0x1C8; // CParticleTransformInput
    public const nint m_nFieldOutput = 0x230; // ParticleAttributeIndex_t
    public const nint m_flInputMin = 0x234; // float
    public const nint m_flInputMax = 0x238; // float
    public const nint m_flOutputMin = 0x23C; // float
    public const nint m_flOutputMax = 0x240; // float
    public const nint m_flRadius = 0x244; // float
}

public static class C_OP_RemapTransformVisibilityToVector {
    public const nint m_nSetMethod = 0x1C0; // ParticleSetMethod_t
    public const nint m_TransformInput = 0x1C8; // CParticleTransformInput
    public const nint m_nFieldOutput = 0x230; // ParticleAttributeIndex_t
    public const nint m_flInputMin = 0x234; // float
    public const nint m_flInputMax = 0x238; // float
    public const nint m_vecOutputMin = 0x23C; // Vector
    public const nint m_vecOutputMax = 0x248; // Vector
    public const nint m_flRadius = 0x254; // float
}

public static class C_OP_RemapVectorComponentToScalar {
    public const nint m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    public const nint m_nComponent = 0x1C8; // int32_t
}

public static class C_OP_RemapVectortoCP {
    public const nint m_nOutControlPointNumber = 0x1C0; // int32_t
    public const nint m_nFieldInput = 0x1C4; // ParticleAttributeIndex_t
    public const nint m_nParticleNumber = 0x1C8; // int32_t
}

public static class C_OP_RemapVelocityToVector {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_flScale = 0x1C4; // float
    public const nint m_bNormalize = 0x1C8; // bool
}

public static class C_OP_RemapVisibilityScalar {
    public const nint m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    public const nint m_flInputMin = 0x1C8; // float
    public const nint m_flInputMax = 0x1CC; // float
    public const nint m_flOutputMin = 0x1D0; // float
    public const nint m_flOutputMax = 0x1D4; // float
    public const nint m_flRadiusScale = 0x1D8; // float
}

public static class C_OP_RenderAsModels {
    public const nint m_ModelList = 0x200; // CUtlVector<ModelReference_t>
    public const nint m_flModelScale = 0x21C; // float
    public const nint m_bFitToModelSize = 0x220; // bool
    public const nint m_bNonUniformScaling = 0x221; // bool
    public const nint m_nXAxisScalingAttribute = 0x224; // ParticleAttributeIndex_t
    public const nint m_nYAxisScalingAttribute = 0x228; // ParticleAttributeIndex_t
    public const nint m_nZAxisScalingAttribute = 0x22C; // ParticleAttributeIndex_t
    public const nint m_nSizeCullBloat = 0x230; // int32_t
}

public static class C_OP_RenderBlobs {
    public const nint m_cubeWidth = 0x200; // CParticleCollectionRendererFloatInput
    public const nint m_cutoffRadius = 0x358; // CParticleCollectionRendererFloatInput
    public const nint m_renderRadius = 0x4B0; // CParticleCollectionRendererFloatInput
    public const nint m_nScaleCP = 0x608; // int32_t
    public const nint m_MaterialVars = 0x610; // CUtlVector<MaterialVariable_t>
    public const nint m_hMaterial = 0x640; // CStrongHandle<InfoForResourceTypeIMaterial2>
}

public static class C_OP_RenderCables {
    public const nint m_flRadiusScale = 0x200; // CParticleCollectionFloatInput
    public const nint m_flAlphaScale = 0x358; // CParticleCollectionFloatInput
    public const nint m_vecColorScale = 0x4B0; // CParticleCollectionVecInput
    public const nint m_nColorBlendType = 0xB08; // ParticleColorBlendType_t
    public const nint m_hMaterial = 0xB10; // CStrongHandle<InfoForResourceTypeIMaterial2>
    public const nint m_nTextureRepetitionMode = 0xB18; // TextureRepetitionMode_t
    public const nint m_flTextureRepeatsPerSegment = 0xB20; // CParticleCollectionFloatInput
    public const nint m_flTextureRepeatsCircumference = 0xC78; // CParticleCollectionFloatInput
    public const nint m_flColorMapOffsetV = 0xDD0; // CParticleCollectionFloatInput
    public const nint m_flColorMapOffsetU = 0xF28; // CParticleCollectionFloatInput
    public const nint m_flNormalMapOffsetV = 0x1080; // CParticleCollectionFloatInput
    public const nint m_flNormalMapOffsetU = 0x11D8; // CParticleCollectionFloatInput
    public const nint m_bDrawCableCaps = 0x1330; // bool
    public const nint m_flCapRoundness = 0x1334; // float
    public const nint m_flCapOffsetAmount = 0x1338; // float
    public const nint m_flTessScale = 0x133C; // float
    public const nint m_nMinTesselation = 0x1340; // int32_t
    public const nint m_nMaxTesselation = 0x1344; // int32_t
    public const nint m_nRoundness = 0x1348; // int32_t
    public const nint m_LightingTransform = 0x1350; // CParticleTransformInput
    public const nint m_MaterialFloatVars = 0x13B8; // CUtlVector<FloatInputMaterialVariable_t>
    public const nint m_MaterialVecVars = 0x13E8; // CUtlVector<VecInputMaterialVariable_t>
}

public static class C_OP_RenderDeferredLight {
    public const nint m_bUseAlphaTestWindow = 0x200; // bool
    public const nint m_bUseTexture = 0x201; // bool
    public const nint m_flRadiusScale = 0x204; // float
    public const nint m_flAlphaScale = 0x208; // float
    public const nint m_nAlpha2Field = 0x20C; // ParticleAttributeIndex_t
    public const nint m_vecColorScale = 0x210; // CParticleCollectionVecInput
    public const nint m_nColorBlendType = 0x868; // ParticleColorBlendType_t
    public const nint m_flLightDistance = 0x86C; // float
    public const nint m_flStartFalloff = 0x870; // float
    public const nint m_flDistanceFalloff = 0x874; // float
    public const nint m_flSpotFoV = 0x878; // float
    public const nint m_nAlphaTestPointField = 0x87C; // ParticleAttributeIndex_t
    public const nint m_nAlphaTestRangeField = 0x880; // ParticleAttributeIndex_t
    public const nint m_nAlphaTestSharpnessField = 0x884; // ParticleAttributeIndex_t
    public const nint m_hTexture = 0x888; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_nHSVShiftControlPoint = 0x890; // int32_t
}

public static class C_OP_RenderFlattenGrass {
    public const nint m_flFlattenStrength = 0x200; // float
    public const nint m_nStrengthFieldOverride = 0x204; // ParticleAttributeIndex_t
    public const nint m_flRadiusScale = 0x208; // float
}

public static class C_OP_RenderGpuImplicit {
    public const nint m_bUsePerParticleRadius = 0x200; // bool
    public const nint m_fGridSize = 0x208; // CParticleCollectionRendererFloatInput
    public const nint m_fRadiusScale = 0x360; // CParticleCollectionRendererFloatInput
    public const nint m_fIsosurfaceThreshold = 0x4B8; // CParticleCollectionRendererFloatInput
    public const nint m_nScaleCP = 0x610; // int32_t
    public const nint m_hMaterial = 0x618; // CStrongHandle<InfoForResourceTypeIMaterial2>
}

public static class C_OP_RenderLightBeam {
    public const nint m_vColorBlend = 0x200; // CParticleCollectionVecInput
    public const nint m_nColorBlendType = 0x858; // ParticleColorBlendType_t
    public const nint m_flBrightnessLumensPerMeter = 0x860; // CParticleCollectionFloatInput
    public const nint m_bCastShadows = 0x9B8; // bool
    public const nint m_flSkirt = 0x9C0; // CParticleCollectionFloatInput
    public const nint m_flRange = 0xB18; // CParticleCollectionFloatInput
    public const nint m_flThickness = 0xC70; // CParticleCollectionFloatInput
}

public static class C_OP_RenderLights {
    public const nint m_flAnimationRate = 0x210; // float
    public const nint m_nAnimationType = 0x214; // AnimationType_t
    public const nint m_bAnimateInFPS = 0x218; // bool
    public const nint m_flMinSize = 0x21C; // float
    public const nint m_flMaxSize = 0x220; // float
    public const nint m_flStartFadeSize = 0x224; // float
    public const nint m_flEndFadeSize = 0x228; // float
}

public static class C_OP_RenderMaterialProxy {
    public const nint m_nMaterialControlPoint = 0x200; // int32_t
    public const nint m_nProxyType = 0x204; // MaterialProxyType_t
    public const nint m_MaterialVars = 0x208; // CUtlVector<MaterialVariable_t>
    public const nint m_hOverrideMaterial = 0x220; // CStrongHandle<InfoForResourceTypeIMaterial2>
    public const nint m_flMaterialOverrideEnabled = 0x228; // CParticleCollectionFloatInput
    public const nint m_vecColorScale = 0x380; // CParticleCollectionVecInput
    public const nint m_flAlpha = 0x9D8; // CPerParticleFloatInput
    public const nint m_nColorBlendType = 0xB30; // ParticleColorBlendType_t
}

public static class C_OP_RenderModels {
    public const nint m_bOnlyRenderInEffectsBloomPass = 0x200; // bool
    public const nint m_bOnlyRenderInEffectsWaterPass = 0x201; // bool
    public const nint m_bUseMixedResolutionRendering = 0x202; // bool
    public const nint m_bOnlyRenderInEffecsGameOverlay = 0x203; // bool
    public const nint m_ModelList = 0x208; // CUtlVector<ModelReference_t>
    public const nint m_nBodyGroupField = 0x224; // ParticleAttributeIndex_t
    public const nint m_nSubModelField = 0x228; // ParticleAttributeIndex_t
    public const nint m_bIgnoreNormal = 0x22C; // bool
    public const nint m_bOrientZ = 0x22D; // bool
    public const nint m_bCenterOffset = 0x22E; // bool
    public const nint m_vecLocalOffset = 0x230; // CPerParticleVecInput
    public const nint m_vecLocalRotation = 0x888; // CPerParticleVecInput
    public const nint m_bIgnoreRadius = 0xEE0; // bool
    public const nint m_nModelScaleCP = 0xEE4; // int32_t
    public const nint m_vecComponentScale = 0xEE8; // CPerParticleVecInput
    public const nint m_bLocalScale = 0x1540; // bool
    public const nint m_nSizeCullBloat = 0x1544; // int32_t
    public const nint m_bAnimated = 0x1548; // bool
    public const nint m_flAnimationRate = 0x154C; // float
    public const nint m_bScaleAnimationRate = 0x1550; // bool
    public const nint m_bForceLoopingAnimation = 0x1551; // bool
    public const nint m_bResetAnimOnStop = 0x1552; // bool
    public const nint m_bManualAnimFrame = 0x1553; // bool
    public const nint m_nAnimationScaleField = 0x1554; // ParticleAttributeIndex_t
    public const nint m_nAnimationField = 0x1558; // ParticleAttributeIndex_t
    public const nint m_nManualFrameField = 0x155C; // ParticleAttributeIndex_t
    public const nint m_ActivityName = 0x1560; // char[256]
    public const nint m_SequenceName = 0x1660; // char[256]
    public const nint m_bEnableClothSimulation = 0x1760; // bool
    public const nint m_hOverrideMaterial = 0x1768; // CStrongHandle<InfoForResourceTypeIMaterial2>
    public const nint m_bOverrideTranslucentMaterials = 0x1770; // bool
    public const nint m_nSkin = 0x1778; // CPerParticleFloatInput
    public const nint m_MaterialVars = 0x18D0; // CUtlVector<MaterialVariable_t>
    public const nint m_modelInput = 0x18E8; // CParticleModelInput
    public const nint m_nLOD = 0x1948; // int32_t
    public const nint m_EconSlotName = 0x194C; // char[256]
    public const nint m_bOriginalModel = 0x1A4C; // bool
    public const nint m_bSuppressTint = 0x1A4D; // bool
    public const nint m_bUseRawMeshGroup = 0x1A4E; // bool
    public const nint m_bDisableShadows = 0x1A4F; // bool
    public const nint m_bAcceptsDecals = 0x1A50; // bool
    public const nint m_bForceDrawInterlevedWithSiblings = 0x1A51; // bool
    public const nint m_bDoNotDrawInParticlePass = 0x1A52; // bool
    public const nint m_szRenderAttribute = 0x1A53; // char[260]
    public const nint m_flRadiusScale = 0x1B58; // CParticleCollectionFloatInput
    public const nint m_flAlphaScale = 0x1CB0; // CParticleCollectionFloatInput
    public const nint m_flRollScale = 0x1E08; // CParticleCollectionFloatInput
    public const nint m_nAlpha2Field = 0x1F60; // ParticleAttributeIndex_t
    public const nint m_vecColorScale = 0x1F68; // CParticleCollectionVecInput
    public const nint m_nColorBlendType = 0x25C0; // ParticleColorBlendType_t
}

public static class C_OP_RenderOmni2Light {
    public const nint m_nLightType = 0x200; // ParticleOmni2LightTypeChoiceList_t
    public const nint m_vColorBlend = 0x208; // CParticleCollectionVecInput
    public const nint m_nColorBlendType = 0x860; // ParticleColorBlendType_t
    public const nint m_nBrightnessUnit = 0x864; // ParticleLightUnitChoiceList_t
    public const nint m_flBrightnessLumens = 0x868; // CPerParticleFloatInput
    public const nint m_flBrightnessCandelas = 0x9C0; // CPerParticleFloatInput
    public const nint m_bCastShadows = 0xB18; // bool
    public const nint m_flLuminaireRadius = 0xB20; // CPerParticleFloatInput
    public const nint m_flSkirt = 0xC78; // CPerParticleFloatInput
    public const nint m_flRange = 0xDD0; // CPerParticleFloatInput
    public const nint m_flInnerConeAngle = 0xF28; // CPerParticleFloatInput
    public const nint m_flOuterConeAngle = 0x1080; // CPerParticleFloatInput
    public const nint m_hLightCookie = 0x11D8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_bSphericalCookie = 0x11E0; // bool
}

public static class C_OP_RenderPoints {
    public const nint m_hMaterial = 0x200; // CStrongHandle<InfoForResourceTypeIMaterial2>
}

public static class C_OP_RenderPostProcessing {
    public const nint m_flPostProcessStrength = 0x200; // CPerParticleFloatInput
    public const nint m_hPostTexture = 0x358; // CStrongHandle<InfoForResourceTypeCPostProcessingResource>
    public const nint m_nPriority = 0x360; // ParticlePostProcessPriorityGroup_t
}

public static class C_OP_RenderProjected {
    public const nint m_bProjectCharacter = 0x200; // bool
    public const nint m_bProjectWorld = 0x201; // bool
    public const nint m_bProjectWater = 0x202; // bool
    public const nint m_bFlipHorizontal = 0x203; // bool
    public const nint m_bEnableProjectedDepthControls = 0x204; // bool
    public const nint m_flMinProjectionDepth = 0x208; // float
    public const nint m_flMaxProjectionDepth = 0x20C; // float
    public const nint m_hProjectedMaterial = 0x210; // CStrongHandle<InfoForResourceTypeIMaterial2>
    public const nint m_flAnimationTimeScale = 0x218; // float
    public const nint m_bOrientToNormal = 0x21C; // bool
    public const nint m_MaterialVars = 0x220; // CUtlVector<MaterialVariable_t>
}

public static class C_OP_RenderRopes {
    public const nint m_bEnableFadingAndClamping = 0x2470; // bool
    public const nint m_flMinSize = 0x2474; // float
    public const nint m_flMaxSize = 0x2478; // float
    public const nint m_flStartFadeSize = 0x247C; // float
    public const nint m_flEndFadeSize = 0x2480; // float
    public const nint m_flStartFadeDot = 0x2484; // float
    public const nint m_flEndFadeDot = 0x2488; // float
    public const nint m_flRadiusTaper = 0x248C; // float
    public const nint m_nMinTesselation = 0x2490; // int32_t
    public const nint m_nMaxTesselation = 0x2494; // int32_t
    public const nint m_flTessScale = 0x2498; // float
    public const nint m_flTextureVWorldSize = 0x24A0; // CParticleCollectionRendererFloatInput
    public const nint m_flTextureVScrollRate = 0x25F8; // CParticleCollectionRendererFloatInput
    public const nint m_flTextureVOffset = 0x2750; // CParticleCollectionRendererFloatInput
    public const nint m_nTextureVParamsCP = 0x28A8; // int32_t
    public const nint m_bClampV = 0x28AC; // bool
    public const nint m_nScaleCP1 = 0x28B0; // int32_t
    public const nint m_nScaleCP2 = 0x28B4; // int32_t
    public const nint m_flScaleVSizeByControlPointDistance = 0x28B8; // float
    public const nint m_flScaleVScrollByControlPointDistance = 0x28BC; // float
    public const nint m_flScaleVOffsetByControlPointDistance = 0x28C0; // float
    public const nint m_bUseScalarForTextureCoordinate = 0x28C5; // bool
    public const nint m_nScalarFieldForTextureCoordinate = 0x28C8; // ParticleAttributeIndex_t
    public const nint m_flScalarAttributeTextureCoordScale = 0x28CC; // float
    public const nint m_bReverseOrder = 0x28D0; // bool
    public const nint m_bClosedLoop = 0x28D1; // bool
    public const nint m_nOrientationType = 0x28D4; // ParticleOrientationChoiceList_t
    public const nint m_nVectorFieldForOrientation = 0x28D8; // ParticleAttributeIndex_t
    public const nint m_bDrawAsOpaque = 0x28DC; // bool
    public const nint m_bGenerateNormals = 0x28DD; // bool
}

public static class C_OP_RenderScreenShake {
    public const nint m_flDurationScale = 0x200; // float
    public const nint m_flRadiusScale = 0x204; // float
    public const nint m_flFrequencyScale = 0x208; // float
    public const nint m_flAmplitudeScale = 0x20C; // float
    public const nint m_nRadiusField = 0x210; // ParticleAttributeIndex_t
    public const nint m_nDurationField = 0x214; // ParticleAttributeIndex_t
    public const nint m_nFrequencyField = 0x218; // ParticleAttributeIndex_t
    public const nint m_nAmplitudeField = 0x21C; // ParticleAttributeIndex_t
    public const nint m_nFilterCP = 0x220; // int32_t
}

public static class C_OP_RenderScreenVelocityRotate {
    public const nint m_flRotateRateDegrees = 0x200; // float
    public const nint m_flForwardDegrees = 0x204; // float
}

public static class C_OP_RenderSound {
    public const nint m_flDurationScale = 0x200; // float
    public const nint m_flSndLvlScale = 0x204; // float
    public const nint m_flPitchScale = 0x208; // float
    public const nint m_flVolumeScale = 0x20C; // float
    public const nint m_nSndLvlField = 0x210; // ParticleAttributeIndex_t
    public const nint m_nDurationField = 0x214; // ParticleAttributeIndex_t
    public const nint m_nPitchField = 0x218; // ParticleAttributeIndex_t
    public const nint m_nVolumeField = 0x21C; // ParticleAttributeIndex_t
    public const nint m_nChannel = 0x220; // int32_t
    public const nint m_nCPReference = 0x224; // int32_t
    public const nint m_pszSoundName = 0x228; // char[256]
    public const nint m_bSuppressStopSoundEvent = 0x328; // bool
}

public static class C_OP_RenderSprites {
    public const nint m_nSequenceOverride = 0x2470; // CParticleCollectionRendererFloatInput
    public const nint m_nOrientationType = 0x25C8; // ParticleOrientationChoiceList_t
    public const nint m_nOrientationControlPoint = 0x25CC; // int32_t
    public const nint m_bUseYawWithNormalAligned = 0x25D0; // bool
    public const nint m_flMinSize = 0x25D4; // float
    public const nint m_flMaxSize = 0x25D8; // float
    public const nint m_flAlphaAdjustWithSizeAdjust = 0x25DC; // float
    public const nint m_flStartFadeSize = 0x25E0; // CParticleCollectionRendererFloatInput
    public const nint m_flEndFadeSize = 0x2738; // CParticleCollectionRendererFloatInput
    public const nint m_flStartFadeDot = 0x2890; // float
    public const nint m_flEndFadeDot = 0x2894; // float
    public const nint m_bDistanceAlpha = 0x2898; // bool
    public const nint m_bSoftEdges = 0x2899; // bool
    public const nint m_flEdgeSoftnessStart = 0x289C; // float
    public const nint m_flEdgeSoftnessEnd = 0x28A0; // float
    public const nint m_bOutline = 0x28A4; // bool
    public const nint m_OutlineColor = 0x28A5; // Color
    public const nint m_nOutlineAlpha = 0x28AC; // int32_t
    public const nint m_flOutlineStart0 = 0x28B0; // float
    public const nint m_flOutlineStart1 = 0x28B4; // float
    public const nint m_flOutlineEnd0 = 0x28B8; // float
    public const nint m_flOutlineEnd1 = 0x28BC; // float
    public const nint m_nLightingMode = 0x28C0; // ParticleLightingQuality_t
    public const nint m_flLightingTessellation = 0x28C8; // CParticleCollectionRendererFloatInput
    public const nint m_flLightingDirectionality = 0x2A20; // CParticleCollectionRendererFloatInput
    public const nint m_bParticleShadows = 0x2B78; // bool
    public const nint m_flShadowDensity = 0x2B7C; // float
}

public static class C_OP_RenderStandardLight {
    public const nint m_nLightType = 0x200; // ParticleLightTypeChoiceList_t
    public const nint m_vecColorScale = 0x208; // CParticleCollectionVecInput
    public const nint m_nColorBlendType = 0x860; // ParticleColorBlendType_t
    public const nint m_flIntensity = 0x868; // CParticleCollectionFloatInput
    public const nint m_bCastShadows = 0x9C0; // bool
    public const nint m_flTheta = 0x9C8; // CParticleCollectionFloatInput
    public const nint m_flPhi = 0xB20; // CParticleCollectionFloatInput
    public const nint m_flRadiusMultiplier = 0xC78; // CParticleCollectionFloatInput
    public const nint m_nAttenuationStyle = 0xDD0; // StandardLightingAttenuationStyle_t
    public const nint m_flFalloffLinearity = 0xDD8; // CParticleCollectionFloatInput
    public const nint m_flFiftyPercentFalloff = 0xF30; // CParticleCollectionFloatInput
    public const nint m_flZeroPercentFalloff = 0x1088; // CParticleCollectionFloatInput
    public const nint m_bRenderDiffuse = 0x11E0; // bool
    public const nint m_bRenderSpecular = 0x11E1; // bool
    public const nint m_lightCookie = 0x11E8; // CUtlString
    public const nint m_nPriority = 0x11F0; // int32_t
    public const nint m_nFogLightingMode = 0x11F4; // ParticleLightFogLightingMode_t
    public const nint m_flFogContribution = 0x11F8; // CParticleCollectionRendererFloatInput
    public const nint m_nCapsuleLightBehavior = 0x1350; // ParticleLightBehaviorChoiceList_t
    public const nint m_flCapsuleLength = 0x1354; // float
    public const nint m_bReverseOrder = 0x1358; // bool
    public const nint m_bClosedLoop = 0x1359; // bool
    public const nint m_nPrevPntSource = 0x135C; // ParticleAttributeIndex_t
    public const nint m_flMaxLength = 0x1360; // float
    public const nint m_flMinLength = 0x1364; // float
    public const nint m_bIgnoreDT = 0x1368; // bool
    public const nint m_flConstrainRadiusToLengthRatio = 0x136C; // float
    public const nint m_flLengthScale = 0x1370; // float
    public const nint m_flLengthFadeInTime = 0x1374; // float
}

public static class C_OP_RenderStatusEffect {
    public const nint m_pTextureColorWarp = 0x200; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_pTextureDetail2 = 0x208; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_pTextureDiffuseWarp = 0x210; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_pTextureFresnelColorWarp = 0x218; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_pTextureFresnelWarp = 0x220; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_pTextureSpecularWarp = 0x228; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_pTextureEnvMap = 0x230; // CStrongHandle<InfoForResourceTypeCTextureBase>
}

public static class C_OP_RenderStatusEffectCitadel {
    public const nint m_pTextureColorWarp = 0x200; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_pTextureNormal = 0x208; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_pTextureMetalness = 0x210; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_pTextureRoughness = 0x218; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_pTextureSelfIllum = 0x220; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_pTextureDetail = 0x228; // CStrongHandle<InfoForResourceTypeCTextureBase>
}

public static class C_OP_RenderText {
    public const nint m_OutlineColor = 0x200; // Color
    public const nint m_DefaultText = 0x208; // CUtlString
}

public static class C_OP_RenderTonemapController {
    public const nint m_flTonemapLevel = 0x200; // float
    public const nint m_flTonemapWeight = 0x204; // float
    public const nint m_nTonemapLevelField = 0x208; // ParticleAttributeIndex_t
    public const nint m_nTonemapWeightField = 0x20C; // ParticleAttributeIndex_t
}

public static class C_OP_RenderTrails {
    public const nint m_bEnableFadingAndClamping = 0x2740; // bool
    public const nint m_flStartFadeDot = 0x2744; // float
    public const nint m_flEndFadeDot = 0x2748; // float
    public const nint m_nPrevPntSource = 0x274C; // ParticleAttributeIndex_t
    public const nint m_flMaxLength = 0x2750; // float
    public const nint m_flMinLength = 0x2754; // float
    public const nint m_bIgnoreDT = 0x2758; // bool
    public const nint m_flConstrainRadiusToLengthRatio = 0x275C; // float
    public const nint m_flLengthScale = 0x2760; // float
    public const nint m_flLengthFadeInTime = 0x2764; // float
    public const nint m_flRadiusHeadTaper = 0x2768; // CPerParticleFloatInput
    public const nint m_vecHeadColorScale = 0x28C0; // CParticleCollectionVecInput
    public const nint m_flHeadAlphaScale = 0x2F18; // CPerParticleFloatInput
    public const nint m_flRadiusTaper = 0x3070; // CPerParticleFloatInput
    public const nint m_vecTailColorScale = 0x31C8; // CParticleCollectionVecInput
    public const nint m_flTailAlphaScale = 0x3820; // CPerParticleFloatInput
    public const nint m_nHorizCropField = 0x3978; // ParticleAttributeIndex_t
    public const nint m_nVertCropField = 0x397C; // ParticleAttributeIndex_t
    public const nint m_flForwardShift = 0x3980; // float
    public const nint m_bFlipUVBasedOnPitchYaw = 0x3984; // bool
}

public static class C_OP_RenderTreeShake {
    public const nint m_flPeakStrength = 0x200; // float
    public const nint m_nPeakStrengthFieldOverride = 0x204; // ParticleAttributeIndex_t
    public const nint m_flRadius = 0x208; // float
    public const nint m_nRadiusFieldOverride = 0x20C; // ParticleAttributeIndex_t
    public const nint m_flShakeDuration = 0x210; // float
    public const nint m_flTransitionTime = 0x214; // float
    public const nint m_flTwistAmount = 0x218; // float
    public const nint m_flRadialAmount = 0x21C; // float
    public const nint m_flControlPointOrientationAmount = 0x220; // float
    public const nint m_nControlPointForLinearDirection = 0x224; // int32_t
}

public static class C_OP_RenderVRHapticEvent {
    public const nint m_nHand = 0x200; // ParticleVRHandChoiceList_t
    public const nint m_nOutputHandCP = 0x204; // int32_t
    public const nint m_nOutputField = 0x208; // int32_t
    public const nint m_flAmplitude = 0x210; // CPerParticleFloatInput
}

public static class C_OP_RepeatedTriggerChildGroup {
    public const nint m_nChildGroupID = 0x1D0; // int32_t
    public const nint m_flClusterRefireTime = 0x1D8; // CParticleCollectionFloatInput
    public const nint m_flClusterSize = 0x330; // CParticleCollectionFloatInput
    public const nint m_flClusterCooldown = 0x488; // CParticleCollectionFloatInput
    public const nint m_bLimitChildCount = 0x5E0; // bool
}

public static class C_OP_RestartAfterDuration {
    public const nint m_flDurationMin = 0x1C0; // float
    public const nint m_flDurationMax = 0x1C4; // float
    public const nint m_nCP = 0x1C8; // int32_t
    public const nint m_nCPField = 0x1CC; // int32_t
    public const nint m_nChildGroupID = 0x1D0; // int32_t
    public const nint m_bOnlyChildren = 0x1D4; // bool
}

public static class C_OP_RopeSpringConstraint {
    public const nint m_flRestLength = 0x1C0; // CParticleCollectionFloatInput
    public const nint m_flMinDistance = 0x318; // CParticleCollectionFloatInput
    public const nint m_flMaxDistance = 0x470; // CParticleCollectionFloatInput
    public const nint m_flAdjustmentScale = 0x5C8; // float
    public const nint m_flInitialRestingLength = 0x5D0; // CParticleCollectionFloatInput
}

public static class C_OP_RotateVector {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_vecRotAxisMin = 0x1C4; // Vector
    public const nint m_vecRotAxisMax = 0x1D0; // Vector
    public const nint m_flRotRateMin = 0x1DC; // float
    public const nint m_flRotRateMax = 0x1E0; // float
    public const nint m_bNormalize = 0x1E4; // bool
    public const nint m_flScale = 0x1E8; // CPerParticleFloatInput
}

public static class C_OP_RtEnvCull {
    public const nint m_vecTestDir = 0x1C0; // Vector
    public const nint m_vecTestNormal = 0x1CC; // Vector
    public const nint m_bCullOnMiss = 0x1D8; // bool
    public const nint m_bStickInsteadOfCull = 0x1D9; // bool
    public const nint m_RtEnvName = 0x1DA; // char[128]
    public const nint m_nRTEnvCP = 0x25C; // int32_t
    public const nint m_nComponent = 0x260; // int32_t
}

public static class C_OP_SDFConstraint {
    public const nint m_flMinDist = 0x1C0; // CParticleCollectionFloatInput
    public const nint m_flMaxDist = 0x318; // CParticleCollectionFloatInput
    public const nint m_nMaxIterations = 0x470; // int32_t
}

public static class C_OP_SDFForce {
    public const nint m_flForceScale = 0x1D0; // float
}

public static class C_OP_SDFLighting {
    public const nint m_vLightingDir = 0x1C0; // Vector
    public const nint m_vTint_0 = 0x1CC; // Vector
    public const nint m_vTint_1 = 0x1D8; // Vector
}

public static class C_OP_SelectivelyEnableChildren {
    public const nint m_nChildGroupID = 0x1D0; // CParticleCollectionFloatInput
    public const nint m_nFirstChild = 0x328; // CParticleCollectionFloatInput
    public const nint m_nNumChildrenToEnable = 0x480; // CParticleCollectionFloatInput
    public const nint m_bPlayEndcapOnStop = 0x5D8; // bool
    public const nint m_bDestroyImmediately = 0x5D9; // bool
}

public static class C_OP_SequenceFromModel {
    public const nint m_nControlPointNumber = 0x1C0; // int32_t
    public const nint m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    public const nint m_nFieldOutputAnim = 0x1C8; // ParticleAttributeIndex_t
    public const nint m_flInputMin = 0x1CC; // float
    public const nint m_flInputMax = 0x1D0; // float
    public const nint m_flOutputMin = 0x1D4; // float
    public const nint m_flOutputMax = 0x1D8; // float
    public const nint m_nSetMethod = 0x1DC; // ParticleSetMethod_t
}

public static class C_OP_SetAttributeToScalarExpression {
    public const nint m_nExpression = 0x1C0; // ScalarExpressionType_t
    public const nint m_flInput1 = 0x1C8; // CPerParticleFloatInput
    public const nint m_flInput2 = 0x320; // CPerParticleFloatInput
    public const nint m_nOutputField = 0x478; // ParticleAttributeIndex_t
    public const nint m_nSetMethod = 0x47C; // ParticleSetMethod_t
}

public static class C_OP_SetCPOrientationToDirection {
    public const nint m_nInputControlPoint = 0x1C0; // int32_t
    public const nint m_nOutputControlPoint = 0x1C4; // int32_t
}

public static class C_OP_SetCPOrientationToGroundNormal {
    public const nint m_flInterpRate = 0x1C0; // float
    public const nint m_flMaxTraceLength = 0x1C4; // float
    public const nint m_flTolerance = 0x1C8; // float
    public const nint m_flTraceOffset = 0x1CC; // float
    public const nint m_CollisionGroupName = 0x1D0; // char[128]
    public const nint m_nTraceSet = 0x250; // ParticleTraceSet_t
    public const nint m_nInputCP = 0x254; // int32_t
    public const nint m_nOutputCP = 0x258; // int32_t
    public const nint m_bIncludeWater = 0x268; // bool
}

public static class C_OP_SetCPOrientationToPointAtCP {
    public const nint m_nInputCP = 0x1D0; // int32_t
    public const nint m_nOutputCP = 0x1D4; // int32_t
    public const nint m_flInterpolation = 0x1D8; // CParticleCollectionFloatInput
    public const nint m_b2DOrientation = 0x330; // bool
    public const nint m_bAvoidSingularity = 0x331; // bool
    public const nint m_bPointAway = 0x332; // bool
}

public static class C_OP_SetCPtoVector {
    public const nint m_nCPInput = 0x1C0; // int32_t
    public const nint m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
}

public static class C_OP_SetChildControlPoints {
    public const nint m_nChildGroupID = 0x1C0; // int32_t
    public const nint m_nFirstControlPoint = 0x1C4; // int32_t
    public const nint m_nNumControlPoints = 0x1C8; // int32_t
    public const nint m_nFirstSourcePoint = 0x1D0; // CParticleCollectionFloatInput
    public const nint m_bReverse = 0x328; // bool
    public const nint m_bSetOrientation = 0x329; // bool
}

public static class C_OP_SetControlPointFieldFromVectorExpression {
    public const nint m_nExpression = 0x1D0; // VectorFloatExpressionType_t
    public const nint m_vecInput1 = 0x1D8; // CParticleCollectionVecInput
    public const nint m_vecInput2 = 0x830; // CParticleCollectionVecInput
    public const nint m_flOutputRemap = 0xE88; // CParticleRemapFloatInput
    public const nint m_nOutputCP = 0xFE0; // int32_t
    public const nint m_nOutVectorField = 0xFE4; // int32_t
}

public static class C_OP_SetControlPointFieldToScalarExpression {
    public const nint m_nExpression = 0x1D0; // ScalarExpressionType_t
    public const nint m_flInput1 = 0x1D8; // CParticleCollectionFloatInput
    public const nint m_flInput2 = 0x330; // CParticleCollectionFloatInput
    public const nint m_flOutputRemap = 0x488; // CParticleRemapFloatInput
    public const nint m_nOutputCP = 0x5E0; // int32_t
    public const nint m_nOutVectorField = 0x5E4; // int32_t
}

public static class C_OP_SetControlPointFieldToWater {
    public const nint m_nSourceCP = 0x1D0; // int32_t
    public const nint m_nDestCP = 0x1D4; // int32_t
    public const nint m_nCPField = 0x1D8; // int32_t
}

public static class C_OP_SetControlPointFromObjectScale {
    public const nint m_nCPInput = 0x1D0; // int32_t
    public const nint m_nCPOutput = 0x1D4; // int32_t
}

public static class C_OP_SetControlPointOrientation {
    public const nint m_bUseWorldLocation = 0x1D0; // bool
    public const nint m_bRandomize = 0x1D2; // bool
    public const nint m_bSetOnce = 0x1D3; // bool
    public const nint m_nCP = 0x1D4; // int32_t
    public const nint m_nHeadLocation = 0x1D8; // int32_t
    public const nint m_vecRotation = 0x1DC; // QAngle
    public const nint m_vecRotationB = 0x1E8; // QAngle
    public const nint m_flInterpolation = 0x1F8; // CParticleCollectionFloatInput
}

public static class C_OP_SetControlPointOrientationToCPVelocity {
    public const nint m_nCPInput = 0x1D0; // int32_t
    public const nint m_nCPOutput = 0x1D4; // int32_t
}

public static class C_OP_SetControlPointPositionToRandomActiveCP {
    public const nint m_nCP1 = 0x1D0; // int32_t
    public const nint m_nHeadLocationMin = 0x1D4; // int32_t
    public const nint m_nHeadLocationMax = 0x1D8; // int32_t
    public const nint m_flResetRate = 0x1E0; // CParticleCollectionFloatInput
}

public static class C_OP_SetControlPointPositionToTimeOfDayValue {
    public const nint m_nControlPointNumber = 0x1D0; // int32_t
    public const nint m_pszTimeOfDayParameter = 0x1D4; // char[128]
    public const nint m_vecDefaultValue = 0x254; // Vector
}

public static class C_OP_SetControlPointPositions {
    public const nint m_bUseWorldLocation = 0x1D0; // bool
    public const nint m_bOrient = 0x1D1; // bool
    public const nint m_bSetOnce = 0x1D2; // bool
    public const nint m_nCP1 = 0x1D4; // int32_t
    public const nint m_nCP2 = 0x1D8; // int32_t
    public const nint m_nCP3 = 0x1DC; // int32_t
    public const nint m_nCP4 = 0x1E0; // int32_t
    public const nint m_vecCP1Pos = 0x1E4; // Vector
    public const nint m_vecCP2Pos = 0x1F0; // Vector
    public const nint m_vecCP3Pos = 0x1FC; // Vector
    public const nint m_vecCP4Pos = 0x208; // Vector
    public const nint m_nHeadLocation = 0x214; // int32_t
}

public static class C_OP_SetControlPointRotation {
    public const nint m_vecRotAxis = 0x1D0; // CParticleCollectionVecInput
    public const nint m_flRotRate = 0x828; // CParticleCollectionFloatInput
    public const nint m_nCP = 0x980; // int32_t
    public const nint m_nLocalCP = 0x984; // int32_t
}

public static class C_OP_SetControlPointToCPVelocity {
    public const nint m_nCPInput = 0x1D0; // int32_t
    public const nint m_nCPOutputVel = 0x1D4; // int32_t
    public const nint m_bNormalize = 0x1D8; // bool
    public const nint m_nCPOutputMag = 0x1DC; // int32_t
    public const nint m_nCPField = 0x1E0; // int32_t
    public const nint m_vecComparisonVelocity = 0x1E8; // CParticleCollectionVecInput
}

public static class C_OP_SetControlPointToCenter {
    public const nint m_nCP1 = 0x1D0; // int32_t
    public const nint m_vecCP1Pos = 0x1D4; // Vector
    public const nint m_nSetParent = 0x1E0; // ParticleParentSetMode_t
}

public static class C_OP_SetControlPointToHMD {
    public const nint m_nCP1 = 0x1D0; // int32_t
    public const nint m_vecCP1Pos = 0x1D4; // Vector
    public const nint m_bOrientToHMD = 0x1E0; // bool
}

public static class C_OP_SetControlPointToHand {
    public const nint m_nCP1 = 0x1D0; // int32_t
    public const nint m_nHand = 0x1D4; // int32_t
    public const nint m_vecCP1Pos = 0x1D8; // Vector
    public const nint m_bOrientToHand = 0x1E4; // bool
}

public static class C_OP_SetControlPointToImpactPoint {
    public const nint m_nCPOut = 0x1D0; // int32_t
    public const nint m_nCPIn = 0x1D4; // int32_t
    public const nint m_flUpdateRate = 0x1D8; // float
    public const nint m_flTraceLength = 0x1E0; // CParticleCollectionFloatInput
    public const nint m_flStartOffset = 0x338; // float
    public const nint m_flOffset = 0x33C; // float
    public const nint m_vecTraceDir = 0x340; // Vector
    public const nint m_CollisionGroupName = 0x34C; // char[128]
    public const nint m_nTraceSet = 0x3CC; // ParticleTraceSet_t
    public const nint m_bSetToEndpoint = 0x3D0; // bool
    public const nint m_bTraceToClosestSurface = 0x3D1; // bool
    public const nint m_bIncludeWater = 0x3D2; // bool
}

public static class C_OP_SetControlPointToPlayer {
    public const nint m_nCP1 = 0x1D0; // int32_t
    public const nint m_vecCP1Pos = 0x1D4; // Vector
    public const nint m_bOrientToEyes = 0x1E0; // bool
}

public static class C_OP_SetControlPointToVectorExpression {
    public const nint m_nExpression = 0x1D0; // VectorExpressionType_t
    public const nint m_nOutputCP = 0x1D4; // int32_t
    public const nint m_vInput1 = 0x1D8; // CParticleCollectionVecInput
    public const nint m_vInput2 = 0x830; // CParticleCollectionVecInput
    public const nint m_bNormalizedOutput = 0xE88; // bool
}

public static class C_OP_SetControlPointToWaterSurface {
    public const nint m_nSourceCP = 0x1D0; // int32_t
    public const nint m_nDestCP = 0x1D4; // int32_t
    public const nint m_nFlowCP = 0x1D8; // int32_t
    public const nint m_nActiveCP = 0x1DC; // int32_t
    public const nint m_nActiveCPField = 0x1E0; // int32_t
    public const nint m_flRetestRate = 0x1E8; // CParticleCollectionFloatInput
    public const nint m_bAdaptiveThreshold = 0x340; // bool
}

public static class C_OP_SetControlPointsToModelParticles {
    public const nint m_HitboxSetName = 0x1C0; // char[128]
    public const nint m_AttachmentName = 0x240; // char[128]
    public const nint m_nFirstControlPoint = 0x2C0; // int32_t
    public const nint m_nNumControlPoints = 0x2C4; // int32_t
    public const nint m_nFirstSourcePoint = 0x2C8; // int32_t
    public const nint m_bSkin = 0x2CC; // bool
    public const nint m_bAttachment = 0x2CD; // bool
}

public static class C_OP_SetControlPointsToParticle {
    public const nint m_nChildGroupID = 0x1C0; // int32_t
    public const nint m_nFirstControlPoint = 0x1C4; // int32_t
    public const nint m_nNumControlPoints = 0x1C8; // int32_t
    public const nint m_nFirstSourcePoint = 0x1CC; // int32_t
    public const nint m_bSetOrientation = 0x1D0; // bool
    public const nint m_nOrientationMode = 0x1D4; // ParticleOrientationSetMode_t
    public const nint m_nSetParent = 0x1D8; // ParticleParentSetMode_t
}

public static class C_OP_SetFloat {
    public const nint m_InputValue = 0x1C0; // CPerParticleFloatInput
    public const nint m_nOutputField = 0x318; // ParticleAttributeIndex_t
    public const nint m_nSetMethod = 0x31C; // ParticleSetMethod_t
    public const nint m_Lerp = 0x320; // CPerParticleFloatInput
    public const nint m_bUseNewCode = 0x478; // bool
}

public static class C_OP_SetFloatAttributeToVectorExpression {
    public const nint m_nExpression = 0x1C0; // VectorFloatExpressionType_t
    public const nint m_vInput1 = 0x1C8; // CPerParticleVecInput
    public const nint m_vInput2 = 0x820; // CPerParticleVecInput
    public const nint m_flOutputRemap = 0xE78; // CParticleRemapFloatInput
    public const nint m_nOutputField = 0xFD0; // ParticleAttributeIndex_t
    public const nint m_nSetMethod = 0xFD4; // ParticleSetMethod_t
}

public static class C_OP_SetFloatCollection {
    public const nint m_InputValue = 0x1C0; // CParticleCollectionFloatInput
    public const nint m_nOutputField = 0x318; // ParticleAttributeIndex_t
    public const nint m_nSetMethod = 0x31C; // ParticleSetMethod_t
    public const nint m_Lerp = 0x320; // CParticleCollectionFloatInput
}

public static class C_OP_SetFromCPSnapshot {
    public const nint m_nControlPointNumber = 0x1C0; // int32_t
    public const nint m_nAttributeToRead = 0x1C4; // ParticleAttributeIndex_t
    public const nint m_nAttributeToWrite = 0x1C8; // ParticleAttributeIndex_t
    public const nint m_nLocalSpaceCP = 0x1CC; // int32_t
    public const nint m_bRandom = 0x1D0; // bool
    public const nint m_bReverse = 0x1D1; // bool
    public const nint m_nRandomSeed = 0x1D4; // int32_t
    public const nint m_nSnapShotStartPoint = 0x1D8; // CParticleCollectionFloatInput
    public const nint m_nSnapShotIncrement = 0x330; // CParticleCollectionFloatInput
    public const nint m_flInterpolation = 0x488; // CPerParticleFloatInput
    public const nint m_bSubSample = 0x5E0; // bool
}

public static class C_OP_SetGravityToCP {
    public const nint m_nCPInput = 0x1D0; // int32_t
    public const nint m_nCPOutput = 0x1D4; // int32_t
    public const nint m_flScale = 0x1D8; // CParticleCollectionFloatInput
    public const nint m_bSetOrientation = 0x330; // bool
    public const nint m_bSetZDown = 0x331; // bool
}

public static class C_OP_SetParentControlPointsToChildCP {
    public const nint m_nChildGroupID = 0x1D0; // int32_t
    public const nint m_nChildControlPoint = 0x1D4; // int32_t
    public const nint m_nNumControlPoints = 0x1D8; // int32_t
    public const nint m_nFirstSourcePoint = 0x1DC; // int32_t
    public const nint m_bSetOrientation = 0x1E0; // bool
}

public static class C_OP_SetPerChildControlPoint {
    public const nint m_nChildGroupID = 0x1C0; // int32_t
    public const nint m_nFirstControlPoint = 0x1C4; // int32_t
    public const nint m_nNumControlPoints = 0x1C8; // int32_t
    public const nint m_nParticleIncrement = 0x1D0; // CParticleCollectionFloatInput
    public const nint m_nFirstSourcePoint = 0x328; // CParticleCollectionFloatInput
    public const nint m_bSetOrientation = 0x480; // bool
    public const nint m_nOrientationField = 0x484; // ParticleAttributeIndex_t
    public const nint m_bNumBasedOnParticleCount = 0x488; // bool
}

public static class C_OP_SetPerChildControlPointFromAttribute {
    public const nint m_nChildGroupID = 0x1C0; // int32_t
    public const nint m_nFirstControlPoint = 0x1C4; // int32_t
    public const nint m_nNumControlPoints = 0x1C8; // int32_t
    public const nint m_nParticleIncrement = 0x1CC; // int32_t
    public const nint m_nFirstSourcePoint = 0x1D0; // int32_t
    public const nint m_bNumBasedOnParticleCount = 0x1D4; // bool
    public const nint m_nAttributeToRead = 0x1D8; // ParticleAttributeIndex_t
    public const nint m_nCPField = 0x1DC; // int32_t
}

public static class C_OP_SetRandomControlPointPosition {
    public const nint m_bUseWorldLocation = 0x1D0; // bool
    public const nint m_bOrient = 0x1D1; // bool
    public const nint m_nCP1 = 0x1D4; // int32_t
    public const nint m_nHeadLocation = 0x1D8; // int32_t
    public const nint m_flReRandomRate = 0x1E0; // CParticleCollectionFloatInput
    public const nint m_vecCPMinPos = 0x338; // Vector
    public const nint m_vecCPMaxPos = 0x344; // Vector
    public const nint m_flInterpolation = 0x350; // CParticleCollectionFloatInput
}

public static class C_OP_SetSimulationRate {
    public const nint m_flSimulationScale = 0x1D0; // CParticleCollectionFloatInput
}

public static class C_OP_SetSingleControlPointPosition {
    public const nint m_bSetOnce = 0x1D0; // bool
    public const nint m_nCP1 = 0x1D4; // int32_t
    public const nint m_vecCP1Pos = 0x1D8; // CParticleCollectionVecInput
    public const nint m_transformInput = 0x830; // CParticleTransformInput
}

public static class C_OP_SetToCP {
    public const nint m_nControlPointNumber = 0x1C0; // int32_t
    public const nint m_vecOffset = 0x1C4; // Vector
    public const nint m_bOffsetLocal = 0x1D0; // bool
}

public static class C_OP_SetVariable {
    public const nint m_variableReference = 0x1D0; // CParticleVariableRef
    public const nint m_transformInput = 0x210; // CParticleTransformInput
    public const nint m_positionOffset = 0x278; // Vector
    public const nint m_rotationOffset = 0x284; // QAngle
    public const nint m_vecInput = 0x290; // CParticleCollectionVecInput
    public const nint m_floatInput = 0x8E8; // CParticleCollectionFloatInput
}

public static class C_OP_SetVec {
    public const nint m_InputValue = 0x1C0; // CPerParticleVecInput
    public const nint m_nOutputField = 0x818; // ParticleAttributeIndex_t
    public const nint m_nSetMethod = 0x81C; // ParticleSetMethod_t
    public const nint m_Lerp = 0x820; // CPerParticleFloatInput
    public const nint m_bNormalizedOutput = 0x978; // bool
}

public static class C_OP_SetVectorAttributeToVectorExpression {
    public const nint m_nExpression = 0x1C0; // VectorExpressionType_t
    public const nint m_vInput1 = 0x1C8; // CPerParticleVecInput
    public const nint m_vInput2 = 0x820; // CPerParticleVecInput
    public const nint m_nOutputField = 0xE78; // ParticleAttributeIndex_t
    public const nint m_nSetMethod = 0xE7C; // ParticleSetMethod_t
    public const nint m_bNormalizedOutput = 0xE80; // bool
}

public static class C_OP_ShapeMatchingConstraint {
    public const nint m_flShapeRestorationTime = 0x1C0; // float
}

public static class C_OP_SnapshotRigidSkinToBones {
    public const nint m_bTransformNormals = 0x1C0; // bool
    public const nint m_bTransformRadii = 0x1C1; // bool
    public const nint m_nControlPointNumber = 0x1C4; // int32_t
}

public static class C_OP_SnapshotSkinToBones {
    public const nint m_bTransformNormals = 0x1C0; // bool
    public const nint m_bTransformRadii = 0x1C1; // bool
    public const nint m_nControlPointNumber = 0x1C4; // int32_t
    public const nint m_flLifeTimeFadeStart = 0x1C8; // float
    public const nint m_flLifeTimeFadeEnd = 0x1CC; // float
    public const nint m_flJumpThreshold = 0x1D0; // float
    public const nint m_flPrevPosScale = 0x1D4; // float
}

public static class C_OP_SpringToVectorConstraint {
    public const nint m_flRestLength = 0x1C0; // CPerParticleFloatInput
    public const nint m_flMinDistance = 0x318; // CPerParticleFloatInput
    public const nint m_flMaxDistance = 0x470; // CPerParticleFloatInput
    public const nint m_flRestingLength = 0x5C8; // CPerParticleFloatInput
    public const nint m_vecAnchorVector = 0x720; // CPerParticleVecInput
}

public static class C_OP_StopAfterCPDuration {
    public const nint m_flDuration = 0x1D0; // CParticleCollectionFloatInput
    public const nint m_bDestroyImmediately = 0x328; // bool
    public const nint m_bPlayEndCap = 0x329; // bool
}

public static class C_OP_TeleportBeam {
    public const nint m_nCPPosition = 0x1C0; // int32_t
    public const nint m_nCPVelocity = 0x1C4; // int32_t
    public const nint m_nCPMisc = 0x1C8; // int32_t
    public const nint m_nCPColor = 0x1CC; // int32_t
    public const nint m_nCPInvalidColor = 0x1D0; // int32_t
    public const nint m_nCPExtraArcData = 0x1D4; // int32_t
    public const nint m_vGravity = 0x1D8; // Vector
    public const nint m_flArcMaxDuration = 0x1E4; // float
    public const nint m_flSegmentBreak = 0x1E8; // float
    public const nint m_flArcSpeed = 0x1EC; // float
    public const nint m_flAlpha = 0x1F0; // float
}

public static class C_OP_TimeVaryingForce {
    public const nint m_flStartLerpTime = 0x1D0; // float
    public const nint m_StartingForce = 0x1D4; // Vector
    public const nint m_flEndLerpTime = 0x1E0; // float
    public const nint m_EndingForce = 0x1E4; // Vector
}

public static class C_OP_TurbulenceForce {
    public const nint m_flNoiseCoordScale0 = 0x1D0; // float
    public const nint m_flNoiseCoordScale1 = 0x1D4; // float
    public const nint m_flNoiseCoordScale2 = 0x1D8; // float
    public const nint m_flNoiseCoordScale3 = 0x1DC; // float
    public const nint m_vecNoiseAmount0 = 0x1E0; // Vector
    public const nint m_vecNoiseAmount1 = 0x1EC; // Vector
    public const nint m_vecNoiseAmount2 = 0x1F8; // Vector
    public const nint m_vecNoiseAmount3 = 0x204; // Vector
}

public static class C_OP_TwistAroundAxis {
    public const nint m_fForceAmount = 0x1D0; // float
    public const nint m_TwistAxis = 0x1D4; // Vector
    public const nint m_bLocalSpace = 0x1E0; // bool
    public const nint m_nControlPointNumber = 0x1E4; // int32_t
}

public static class C_OP_UpdateLightSource {
    public const nint m_vColorTint = 0x1C0; // Color
    public const nint m_flBrightnessScale = 0x1C4; // float
    public const nint m_flRadiusScale = 0x1C8; // float
    public const nint m_flMinimumLightingRadius = 0x1CC; // float
    public const nint m_flMaximumLightingRadius = 0x1D0; // float
    public const nint m_flPositionDampingConstant = 0x1D4; // float
}

public static class C_OP_VectorFieldSnapshot {
    public const nint m_nControlPointNumber = 0x1C0; // int32_t
    public const nint m_nAttributeToWrite = 0x1C4; // ParticleAttributeIndex_t
    public const nint m_nLocalSpaceCP = 0x1C8; // int32_t
    public const nint m_flInterpolation = 0x1D0; // CPerParticleFloatInput
    public const nint m_vecScale = 0x328; // CPerParticleVecInput
    public const nint m_flBoundaryDampening = 0x980; // float
    public const nint m_bSetVelocity = 0x984; // bool
    public const nint m_bLockToSurface = 0x985; // bool
    public const nint m_flGridSpacing = 0x988; // float
}

public static class C_OP_VectorNoise {
    public const nint m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    public const nint m_vecOutputMin = 0x1C4; // Vector
    public const nint m_vecOutputMax = 0x1D0; // Vector
    public const nint m_fl4NoiseScale = 0x1DC; // float
    public const nint m_bAdditive = 0x1E0; // bool
    public const nint m_bOffset = 0x1E1; // bool
    public const nint m_flNoiseAnimationTimeScale = 0x1E4; // float
}

public static class C_OP_VelocityDecay {
    public const nint m_flMinVelocity = 0x1C0; // float
}

public static class C_OP_VelocityMatchingForce {
    public const nint m_flDirScale = 0x1C0; // float
    public const nint m_flSpdScale = 0x1C4; // float
    public const nint m_nCPBroadcast = 0x1C8; // int32_t
}

public static class C_OP_WindForce {
    public const nint m_vForce = 0x1D0; // Vector
}

public static class C_OP_WorldTraceConstraint {
    public const nint m_nCP = 0x1C0; // int32_t
    public const nint m_vecCpOffset = 0x1C4; // Vector
    public const nint m_nCollisionMode = 0x1D0; // ParticleCollisionMode_t
    public const nint m_nCollisionModeMin = 0x1D4; // ParticleCollisionMode_t
    public const nint m_nTraceSet = 0x1D8; // ParticleTraceSet_t
    public const nint m_CollisionGroupName = 0x1DC; // char[128]
    public const nint m_bWorldOnly = 0x25C; // bool
    public const nint m_bBrushOnly = 0x25D; // bool
    public const nint m_bIncludeWater = 0x25E; // bool
    public const nint m_nIgnoreCP = 0x260; // int32_t
    public const nint m_flCpMovementTolerance = 0x264; // float
    public const nint m_flRetestRate = 0x268; // float
    public const nint m_flTraceTolerance = 0x26C; // float
    public const nint m_flCollisionConfirmationSpeed = 0x270; // float
    public const nint m_nMaxTracesPerFrame = 0x274; // float
    public const nint m_flRadiusScale = 0x278; // CPerParticleFloatInput
    public const nint m_flBounceAmount = 0x3D0; // CPerParticleFloatInput
    public const nint m_flSlideAmount = 0x528; // CPerParticleFloatInput
    public const nint m_flRandomDirScale = 0x680; // CPerParticleFloatInput
    public const nint m_bDecayBounce = 0x7D8; // bool
    public const nint m_bKillonContact = 0x7D9; // bool
    public const nint m_flMinSpeed = 0x7DC; // float
    public const nint m_bSetNormal = 0x7E0; // bool
    public const nint m_nStickOnCollisionField = 0x7E4; // ParticleAttributeIndex_t
    public const nint m_flStopSpeed = 0x7E8; // CPerParticleFloatInput
    public const nint m_nEntityStickDataField = 0x940; // ParticleAttributeIndex_t
    public const nint m_nEntityStickNormalField = 0x944; // ParticleAttributeIndex_t
}

public static class CollisionGroupContext_t {
    public const nint m_nCollisionGroupNumber = 0x0; // int32_t
}

public static class ControlPointReference_t {
    public const nint m_controlPointNameString = 0x0; // int32_t
    public const nint m_vOffsetFromControlPoint = 0x4; // Vector
    public const nint m_bOffsetInLocalSpace = 0x10; // bool
}

public static class FloatInputMaterialVariable_t {
    public const nint m_strVariable = 0x0; // CUtlString
    public const nint m_flInput = 0x8; // CParticleCollectionFloatInput
}

public static class MaterialVariable_t {
    public const nint m_strVariable = 0x0; // CUtlString
    public const nint m_nVariableField = 0x8; // ParticleAttributeIndex_t
    public const nint m_flScale = 0xC; // float
}

public static class ModelReference_t {
    public const nint m_model = 0x0; // CStrongHandle<InfoForResourceTypeCModel>
    public const nint m_flRelativeProbabilityOfSpawn = 0x8; // float
}

public static class PARTICLE_EHANDLE__ {
    public const nint unused = 0x0; // int32_t
}

public static class PARTICLE_WORLD_HANDLE__ {
    public const nint unused = 0x0; // int32_t
}

public static class ParticleAttributeIndex_t {
    public const nint m_Value = 0x0; // int32_t
}

public static class ParticleChildrenInfo_t {
    public const nint m_ChildRef = 0x0; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    public const nint m_flDelay = 0x8; // float
    public const nint m_bEndCap = 0xC; // bool
    public const nint m_bDisableChild = 0xD; // bool
    public const nint m_nDetailLevel = 0x10; // ParticleDetailLevel_t
}

public static class ParticleControlPointConfiguration_t {
    public const nint m_name = 0x0; // CUtlString
    public const nint m_drivers = 0x8; // CUtlVector<ParticleControlPointDriver_t>
    public const nint m_previewState = 0x20; // ParticlePreviewState_t
}

public static class ParticleControlPointDriver_t {
    public const nint m_iControlPoint = 0x0; // int32_t
    public const nint m_iAttachType = 0x4; // ParticleAttachment_t
    public const nint m_attachmentName = 0x8; // CUtlString
    public const nint m_vecOffset = 0x10; // Vector
    public const nint m_angOffset = 0x1C; // QAngle
    public const nint m_entityName = 0x28; // CUtlString
}

public static class ParticleNamedValueConfiguration_t {
    public const nint m_ConfigName = 0x0; // CUtlString
    public const nint m_ConfigValue = 0x8; // KeyValues3
    public const nint m_iAttachType = 0x18; // ParticleAttachment_t
    public const nint m_BoundEntityPath = 0x20; // CUtlString
    public const nint m_strEntityScope = 0x28; // CUtlString
    public const nint m_strAttachmentName = 0x30; // CUtlString
}

public static class ParticleNamedValueSource_t {
    public const nint m_Name = 0x0; // CUtlString
    public const nint m_IsPublic = 0x8; // bool
    public const nint m_ValueType = 0xC; // PulseValueType_t
    public const nint m_DefaultConfig = 0x10; // ParticleNamedValueConfiguration_t
    public const nint m_NamedConfigs = 0x48; // CUtlVector<ParticleNamedValueConfiguration_t>
}

public static class ParticlePreviewBodyGroup_t {
    public const nint m_bodyGroupName = 0x0; // CUtlString
    public const nint m_nValue = 0x8; // int32_t
}

public static class ParticlePreviewState_t {
    public const nint m_previewModel = 0x0; // CUtlString
    public const nint m_nModSpecificData = 0x8; // uint32_t
    public const nint m_groundType = 0xC; // PetGroundType_t
    public const nint m_sequenceName = 0x10; // CUtlString
    public const nint m_nFireParticleOnSequenceFrame = 0x18; // int32_t
    public const nint m_hitboxSetName = 0x20; // CUtlString
    public const nint m_materialGroupName = 0x28; // CUtlString
    public const nint m_vecBodyGroups = 0x30; // CUtlVector<ParticlePreviewBodyGroup_t>
    public const nint m_flPlaybackSpeed = 0x48; // float
    public const nint m_flParticleSimulationRate = 0x4C; // float
    public const nint m_bShouldDrawHitboxes = 0x50; // bool
    public const nint m_bShouldDrawAttachments = 0x51; // bool
    public const nint m_bShouldDrawAttachmentNames = 0x52; // bool
    public const nint m_bShouldDrawControlPointAxes = 0x53; // bool
    public const nint m_bAnimationNonLooping = 0x54; // bool
    public const nint m_vecPreviewGravity = 0x58; // Vector
}

public static class PointDefinitionWithTimeValues_t {
    public const nint m_flTimeDuration = 0x14; // float
}

public static class PointDefinition_t {
    public const nint m_nControlPoint = 0x0; // int32_t
    public const nint m_bLocalCoords = 0x4; // bool
    public const nint m_vOffset = 0x8; // Vector
}

public static class SequenceWeightedList_t {
    public const nint m_nSequence = 0x0; // int32_t
    public const nint m_flRelativeWeight = 0x4; // float
}

public static class TextureControls_t {
    public const nint m_flFinalTextureScaleU = 0x0; // CParticleCollectionRendererFloatInput
    public const nint m_flFinalTextureScaleV = 0x158; // CParticleCollectionRendererFloatInput
    public const nint m_flFinalTextureOffsetU = 0x2B0; // CParticleCollectionRendererFloatInput
    public const nint m_flFinalTextureOffsetV = 0x408; // CParticleCollectionRendererFloatInput
    public const nint m_flFinalTextureUVRotation = 0x560; // CParticleCollectionRendererFloatInput
    public const nint m_flZoomScale = 0x6B8; // CParticleCollectionRendererFloatInput
    public const nint m_flDistortion = 0x810; // CParticleCollectionRendererFloatInput
    public const nint m_bRandomizeOffsets = 0x968; // bool
    public const nint m_bClampUVs = 0x969; // bool
    public const nint m_nPerParticleBlend = 0x96C; // SpriteCardPerParticleScale_t
    public const nint m_nPerParticleScale = 0x970; // SpriteCardPerParticleScale_t
    public const nint m_nPerParticleOffsetU = 0x974; // SpriteCardPerParticleScale_t
    public const nint m_nPerParticleOffsetV = 0x978; // SpriteCardPerParticleScale_t
    public const nint m_nPerParticleRotation = 0x97C; // SpriteCardPerParticleScale_t
    public const nint m_nPerParticleZoom = 0x980; // SpriteCardPerParticleScale_t
    public const nint m_nPerParticleDistortion = 0x984; // SpriteCardPerParticleScale_t
}

public static class TextureGroup_t {
    public const nint m_bEnabled = 0x0; // bool
    public const nint m_bReplaceTextureWithGradient = 0x1; // bool
    public const nint m_hTexture = 0x8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_Gradient = 0x10; // CColorGradient
    public const nint m_nTextureType = 0x28; // SpriteCardTextureType_t
    public const nint m_nTextureChannels = 0x2C; // SpriteCardTextureChannel_t
    public const nint m_nTextureBlendMode = 0x30; // ParticleTextureLayerBlendType_t
    public const nint m_flTextureBlend = 0x38; // CParticleCollectionRendererFloatInput
    public const nint m_TextureControls = 0x190; // TextureControls_t
}

public static class VecInputMaterialVariable_t {
    public const nint m_strVariable = 0x0; // CUtlString
    public const nint m_vecInput = 0x8; // CParticleCollectionVecInput
}
```

`SDK/particles.dll.hpp`:

```hpp
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.764240200 UTC
 */

#pragma once

#include <cstddef>

namespace CBaseRendererSource2 {
    constexpr std::ptrdiff_t m_flRadiusScale = 0x200; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flAlphaScale = 0x358; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flRollScale = 0x4B0; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_nAlpha2Field = 0x608; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vecColorScale = 0x610; // CParticleCollectionRendererVecInput
    constexpr std::ptrdiff_t m_nColorBlendType = 0xC68; // ParticleColorBlendType_t
    constexpr std::ptrdiff_t m_nShaderType = 0xC6C; // SpriteCardShaderType_t
    constexpr std::ptrdiff_t m_strShaderOverride = 0xC70; // CUtlString
    constexpr std::ptrdiff_t m_flCenterXOffset = 0xC78; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flCenterYOffset = 0xDD0; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flBumpStrength = 0xF28; // float
    constexpr std::ptrdiff_t m_nCropTextureOverride = 0xF2C; // ParticleSequenceCropOverride_t
    constexpr std::ptrdiff_t m_vecTexturesInput = 0xF30; // CUtlVector<TextureGroup_t>
    constexpr std::ptrdiff_t m_flAnimationRate = 0xF48; // float
    constexpr std::ptrdiff_t m_nAnimationType = 0xF4C; // AnimationType_t
    constexpr std::ptrdiff_t m_bAnimateInFPS = 0xF50; // bool
    constexpr std::ptrdiff_t m_flSelfIllumAmount = 0xF58; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flDiffuseAmount = 0x10B0; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_nLightingControlPoint = 0x1208; // int32_t
    constexpr std::ptrdiff_t m_nSelfIllumPerParticle = 0x120C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nOutputBlendMode = 0x1210; // ParticleOutputBlendMode_t
    constexpr std::ptrdiff_t m_bGammaCorrectVertexColors = 0x1214; // bool
    constexpr std::ptrdiff_t m_bSaturateColorPreAlphaBlend = 0x1215; // bool
    constexpr std::ptrdiff_t m_flAddSelfAmount = 0x1218; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flDesaturation = 0x1370; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flOverbrightFactor = 0x14C8; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_nHSVShiftControlPoint = 0x1620; // int32_t
    constexpr std::ptrdiff_t m_nFogType = 0x1624; // ParticleFogType_t
    constexpr std::ptrdiff_t m_flFogAmount = 0x1628; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_bTintByFOW = 0x1780; // bool
    constexpr std::ptrdiff_t m_bTintByGlobalLight = 0x1781; // bool
    constexpr std::ptrdiff_t m_nPerParticleAlphaReference = 0x1784; // SpriteCardPerParticleScale_t
    constexpr std::ptrdiff_t m_nPerParticleAlphaRefWindow = 0x1788; // SpriteCardPerParticleScale_t
    constexpr std::ptrdiff_t m_nAlphaReferenceType = 0x178C; // ParticleAlphaReferenceType_t
    constexpr std::ptrdiff_t m_flAlphaReferenceSoftness = 0x1790; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flSourceAlphaValueToMapToZero = 0x18E8; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flSourceAlphaValueToMapToOne = 0x1A40; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_bRefract = 0x1B98; // bool
    constexpr std::ptrdiff_t m_bRefractSolid = 0x1B99; // bool
    constexpr std::ptrdiff_t m_flRefractAmount = 0x1BA0; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_nRefractBlurRadius = 0x1CF8; // int32_t
    constexpr std::ptrdiff_t m_nRefractBlurType = 0x1CFC; // BlurFilterType_t
    constexpr std::ptrdiff_t m_bOnlyRenderInEffectsBloomPass = 0x1D00; // bool
    constexpr std::ptrdiff_t m_bOnlyRenderInEffectsWaterPass = 0x1D01; // bool
    constexpr std::ptrdiff_t m_bUseMixedResolutionRendering = 0x1D02; // bool
    constexpr std::ptrdiff_t m_bOnlyRenderInEffecsGameOverlay = 0x1D03; // bool
    constexpr std::ptrdiff_t m_stencilTestID = 0x1D04; // char[128]
    constexpr std::ptrdiff_t m_bStencilTestExclude = 0x1D84; // bool
    constexpr std::ptrdiff_t m_stencilWriteID = 0x1D85; // char[128]
    constexpr std::ptrdiff_t m_bWriteStencilOnDepthPass = 0x1E05; // bool
    constexpr std::ptrdiff_t m_bWriteStencilOnDepthFail = 0x1E06; // bool
    constexpr std::ptrdiff_t m_bReverseZBuffering = 0x1E07; // bool
    constexpr std::ptrdiff_t m_bDisableZBuffering = 0x1E08; // bool
    constexpr std::ptrdiff_t m_nFeatheringMode = 0x1E0C; // ParticleDepthFeatheringMode_t
    constexpr std::ptrdiff_t m_flFeatheringMinDist = 0x1E10; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flFeatheringMaxDist = 0x1F68; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flFeatheringFilter = 0x20C0; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flDepthBias = 0x2218; // float
    constexpr std::ptrdiff_t m_nSortMethod = 0x221C; // ParticleSortingChoiceList_t
    constexpr std::ptrdiff_t m_bBlendFramesSeq0 = 0x2220; // bool
    constexpr std::ptrdiff_t m_bMaxLuminanceBlendingSequence0 = 0x2221; // bool
}

namespace CBaseTrailRenderer {
    constexpr std::ptrdiff_t m_nOrientationType = 0x2470; // ParticleOrientationChoiceList_t
    constexpr std::ptrdiff_t m_nOrientationControlPoint = 0x2474; // int32_t
    constexpr std::ptrdiff_t m_flMinSize = 0x2478; // float
    constexpr std::ptrdiff_t m_flMaxSize = 0x247C; // float
    constexpr std::ptrdiff_t m_flStartFadeSize = 0x2480; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flEndFadeSize = 0x25D8; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_bClampV = 0x2730; // bool
}

namespace CGeneralRandomRotation {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flDegrees = 0x1C4; // float
    constexpr std::ptrdiff_t m_flDegreesMin = 0x1C8; // float
    constexpr std::ptrdiff_t m_flDegreesMax = 0x1CC; // float
    constexpr std::ptrdiff_t m_flRotationRandExponent = 0x1D0; // float
    constexpr std::ptrdiff_t m_bRandomlyFlipDirection = 0x1D4; // bool
}

namespace CGeneralSpin {
    constexpr std::ptrdiff_t m_nSpinRateDegrees = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nSpinRateMinDegrees = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_fSpinRateStopTime = 0x1CC; // float
}

namespace CNewParticleEffect {
    constexpr std::ptrdiff_t m_pNext = 0x10; // CNewParticleEffect*
    constexpr std::ptrdiff_t m_pPrev = 0x18; // CNewParticleEffect*
    constexpr std::ptrdiff_t m_pParticles = 0x20; // IParticleCollection*
    constexpr std::ptrdiff_t m_pDebugName = 0x28; // char*
    constexpr std::ptrdiff_t m_bDontRemove = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bRemove = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bNeedsBBoxUpdate = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bIsFirstFrame = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bAutoUpdateBBox = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bAllocated = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bSimulate = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bShouldPerformCullCheck = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bForceNoDraw = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bShouldSave = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bDisableAggregation = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bShouldSimulateDuringGamePaused = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bShouldCheckFoW = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_vSortOrigin = 0x40; // Vector
    constexpr std::ptrdiff_t m_flScale = 0x4C; // float
    constexpr std::ptrdiff_t m_hOwner = 0x50; // PARTICLE_EHANDLE__*
    constexpr std::ptrdiff_t m_pOwningParticleProperty = 0x58; // CParticleProperty*
    constexpr std::ptrdiff_t m_flFreezeTransitionStart = 0x70; // float
    constexpr std::ptrdiff_t m_flFreezeTransitionDuration = 0x74; // float
    constexpr std::ptrdiff_t m_flFreezeTransitionOverride = 0x78; // float
    constexpr std::ptrdiff_t m_bFreezeTransitionActive = 0x7C; // bool
    constexpr std::ptrdiff_t m_bFreezeTargetState = 0x7D; // bool
    constexpr std::ptrdiff_t m_bCanFreeze = 0x7E; // bool
    constexpr std::ptrdiff_t m_LastMin = 0x80; // Vector
    constexpr std::ptrdiff_t m_LastMax = 0x8C; // Vector
    constexpr std::ptrdiff_t m_nSplitScreenUser = 0x98; // CSplitScreenSlot
    constexpr std::ptrdiff_t m_vecAggregationCenter = 0x9C; // Vector
    constexpr std::ptrdiff_t m_RefCount = 0xC0; // int32_t
}

namespace CParticleFloatInput {
    constexpr std::ptrdiff_t m_nType = 0x10; // ParticleFloatType_t
    constexpr std::ptrdiff_t m_nMapType = 0x14; // ParticleFloatMapType_t
    constexpr std::ptrdiff_t m_flLiteralValue = 0x18; // float
    constexpr std::ptrdiff_t m_NamedValue = 0x20; // CParticleNamedValueRef
    constexpr std::ptrdiff_t m_nControlPoint = 0x60; // int32_t
    constexpr std::ptrdiff_t m_nScalarAttribute = 0x64; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nVectorAttribute = 0x68; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nVectorComponent = 0x6C; // int32_t
    constexpr std::ptrdiff_t m_flRandomMin = 0x70; // float
    constexpr std::ptrdiff_t m_flRandomMax = 0x74; // float
    constexpr std::ptrdiff_t m_bHasRandomSignFlip = 0x78; // bool
    constexpr std::ptrdiff_t m_nRandomSeed = 0x7C; // int32_t
    constexpr std::ptrdiff_t m_nRandomMode = 0x80; // ParticleFloatRandomMode_t
    constexpr std::ptrdiff_t m_flLOD0 = 0x88; // float
    constexpr std::ptrdiff_t m_flLOD1 = 0x8C; // float
    constexpr std::ptrdiff_t m_flLOD2 = 0x90; // float
    constexpr std::ptrdiff_t m_flLOD3 = 0x94; // float
    constexpr std::ptrdiff_t m_nNoiseInputVectorAttribute = 0x98; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flNoiseOutputMin = 0x9C; // float
    constexpr std::ptrdiff_t m_flNoiseOutputMax = 0xA0; // float
    constexpr std::ptrdiff_t m_flNoiseScale = 0xA4; // float
    constexpr std::ptrdiff_t m_vecNoiseOffsetRate = 0xA8; // Vector
    constexpr std::ptrdiff_t m_flNoiseOffset = 0xB4; // float
    constexpr std::ptrdiff_t m_nNoiseOctaves = 0xB8; // int32_t
    constexpr std::ptrdiff_t m_nNoiseTurbulence = 0xBC; // PFNoiseTurbulence_t
    constexpr std::ptrdiff_t m_nNoiseType = 0xC0; // PFNoiseType_t
    constexpr std::ptrdiff_t m_nNoiseModifier = 0xC4; // PFNoiseModifier_t
    constexpr std::ptrdiff_t m_flNoiseTurbulenceScale = 0xC8; // float
    constexpr std::ptrdiff_t m_flNoiseTurbulenceMix = 0xCC; // float
    constexpr std::ptrdiff_t m_flNoiseImgPreviewScale = 0xD0; // float
    constexpr std::ptrdiff_t m_bNoiseImgPreviewLive = 0xD4; // bool
    constexpr std::ptrdiff_t m_flNoCameraFallback = 0xE0; // float
    constexpr std::ptrdiff_t m_bUseBoundsCenter = 0xE4; // bool
    constexpr std::ptrdiff_t m_nInputMode = 0xE8; // ParticleFloatInputMode_t
    constexpr std::ptrdiff_t m_flMultFactor = 0xEC; // float
    constexpr std::ptrdiff_t m_flInput0 = 0xF0; // float
    constexpr std::ptrdiff_t m_flInput1 = 0xF4; // float
    constexpr std::ptrdiff_t m_flOutput0 = 0xF8; // float
    constexpr std::ptrdiff_t m_flOutput1 = 0xFC; // float
    constexpr std::ptrdiff_t m_flNotchedRangeMin = 0x100; // float
    constexpr std::ptrdiff_t m_flNotchedRangeMax = 0x104; // float
    constexpr std::ptrdiff_t m_flNotchedOutputOutside = 0x108; // float
    constexpr std::ptrdiff_t m_flNotchedOutputInside = 0x10C; // float
    constexpr std::ptrdiff_t m_nBiasType = 0x110; // ParticleFloatBiasType_t
    constexpr std::ptrdiff_t m_flBiasParameter = 0x114; // float
    constexpr std::ptrdiff_t m_Curve = 0x118; // CPiecewiseCurve
}

namespace CParticleFunction {
    constexpr std::ptrdiff_t m_flOpStrength = 0x8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nOpEndCapState = 0x160; // ParticleEndcapMode_t
    constexpr std::ptrdiff_t m_flOpStartFadeInTime = 0x164; // float
    constexpr std::ptrdiff_t m_flOpEndFadeInTime = 0x168; // float
    constexpr std::ptrdiff_t m_flOpStartFadeOutTime = 0x16C; // float
    constexpr std::ptrdiff_t m_flOpEndFadeOutTime = 0x170; // float
    constexpr std::ptrdiff_t m_flOpFadeOscillatePeriod = 0x174; // float
    constexpr std::ptrdiff_t m_bNormalizeToStopTime = 0x178; // bool
    constexpr std::ptrdiff_t m_flOpTimeOffsetMin = 0x17C; // float
    constexpr std::ptrdiff_t m_flOpTimeOffsetMax = 0x180; // float
    constexpr std::ptrdiff_t m_nOpTimeOffsetSeed = 0x184; // int32_t
    constexpr std::ptrdiff_t m_nOpTimeScaleSeed = 0x188; // int32_t
    constexpr std::ptrdiff_t m_flOpTimeScaleMin = 0x18C; // float
    constexpr std::ptrdiff_t m_flOpTimeScaleMax = 0x190; // float
    constexpr std::ptrdiff_t m_bDisableOperator = 0x196; // bool
    constexpr std::ptrdiff_t m_Notes = 0x198; // CUtlString
}

namespace CParticleFunctionEmitter {
    constexpr std::ptrdiff_t m_nEmitterIndex = 0x1B8; // int32_t
}

namespace CParticleFunctionInitializer {
    constexpr std::ptrdiff_t m_nAssociatedEmitterIndex = 0x1B8; // int32_t
}

namespace CParticleFunctionPreEmission {
    constexpr std::ptrdiff_t m_bRunOnce = 0x1C0; // bool
}

namespace CParticleFunctionRenderer {
    constexpr std::ptrdiff_t VisibilityInputs = 0x1B8; // CParticleVisibilityInputs
    constexpr std::ptrdiff_t m_bCannotBeRefracted = 0x1FC; // bool
    constexpr std::ptrdiff_t m_bSkipRenderingOnMobile = 0x1FD; // bool
}

namespace CParticleModelInput {
    constexpr std::ptrdiff_t m_nType = 0x10; // ParticleModelType_t
    constexpr std::ptrdiff_t m_NamedValue = 0x18; // CParticleNamedValueRef
    constexpr std::ptrdiff_t m_nControlPoint = 0x58; // int32_t
}

namespace CParticleSystemDefinition {
    constexpr std::ptrdiff_t m_nBehaviorVersion = 0x8; // int32_t
    constexpr std::ptrdiff_t m_PreEmissionOperators = 0x10; // CUtlVector<CParticleFunctionPreEmission*>
    constexpr std::ptrdiff_t m_Emitters = 0x28; // CUtlVector<CParticleFunctionEmitter*>
    constexpr std::ptrdiff_t m_Initializers = 0x40; // CUtlVector<CParticleFunctionInitializer*>
    constexpr std::ptrdiff_t m_Operators = 0x58; // CUtlVector<CParticleFunctionOperator*>
    constexpr std::ptrdiff_t m_ForceGenerators = 0x70; // CUtlVector<CParticleFunctionForce*>
    constexpr std::ptrdiff_t m_Constraints = 0x88; // CUtlVector<CParticleFunctionConstraint*>
    constexpr std::ptrdiff_t m_Renderers = 0xA0; // CUtlVector<CParticleFunctionRenderer*>
    constexpr std::ptrdiff_t m_Children = 0xB8; // CUtlVector<ParticleChildrenInfo_t>
    constexpr std::ptrdiff_t m_nFirstMultipleOverride_BackwardCompat = 0x178; // int32_t
    constexpr std::ptrdiff_t m_nInitialParticles = 0x210; // int32_t
    constexpr std::ptrdiff_t m_nMaxParticles = 0x214; // int32_t
    constexpr std::ptrdiff_t m_nGroupID = 0x218; // int32_t
    constexpr std::ptrdiff_t m_BoundingBoxMin = 0x21C; // Vector
    constexpr std::ptrdiff_t m_BoundingBoxMax = 0x228; // Vector
    constexpr std::ptrdiff_t m_flDepthSortBias = 0x234; // float
    constexpr std::ptrdiff_t m_nSortOverridePositionCP = 0x238; // int32_t
    constexpr std::ptrdiff_t m_bInfiniteBounds = 0x23C; // bool
    constexpr std::ptrdiff_t m_bEnableNamedValues = 0x23D; // bool
    constexpr std::ptrdiff_t m_NamedValueDomain = 0x240; // CUtlString
    constexpr std::ptrdiff_t m_NamedValueLocals = 0x248; // CUtlVector<ParticleNamedValueSource_t*>
    constexpr std::ptrdiff_t m_ConstantColor = 0x260; // Color
    constexpr std::ptrdiff_t m_ConstantNormal = 0x264; // Vector
    constexpr std::ptrdiff_t m_flConstantRadius = 0x270; // float
    constexpr std::ptrdiff_t m_flConstantRotation = 0x274; // float
    constexpr std::ptrdiff_t m_flConstantRotationSpeed = 0x278; // float
    constexpr std::ptrdiff_t m_flConstantLifespan = 0x27C; // float
    constexpr std::ptrdiff_t m_nConstantSequenceNumber = 0x280; // int32_t
    constexpr std::ptrdiff_t m_nConstantSequenceNumber1 = 0x284; // int32_t
    constexpr std::ptrdiff_t m_nSnapshotControlPoint = 0x288; // int32_t
    constexpr std::ptrdiff_t m_hSnapshot = 0x290; // CStrongHandle<InfoForResourceTypeIParticleSnapshot>
    constexpr std::ptrdiff_t m_pszCullReplacementName = 0x298; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_flCullRadius = 0x2A0; // float
    constexpr std::ptrdiff_t m_flCullFillCost = 0x2A4; // float
    constexpr std::ptrdiff_t m_nCullControlPoint = 0x2A8; // int32_t
    constexpr std::ptrdiff_t m_hFallback = 0x2B0; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_nFallbackMaxCount = 0x2B8; // int32_t
    constexpr std::ptrdiff_t m_hLowViolenceDef = 0x2C0; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_hReferenceReplacement = 0x2C8; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_flPreSimulationTime = 0x2D0; // float
    constexpr std::ptrdiff_t m_flStopSimulationAfterTime = 0x2D4; // float
    constexpr std::ptrdiff_t m_flMaximumTimeStep = 0x2D8; // float
    constexpr std::ptrdiff_t m_flMaximumSimTime = 0x2DC; // float
    constexpr std::ptrdiff_t m_flMinimumSimTime = 0x2E0; // float
    constexpr std::ptrdiff_t m_flMinimumTimeStep = 0x2E4; // float
    constexpr std::ptrdiff_t m_nMinimumFrames = 0x2E8; // int32_t
    constexpr std::ptrdiff_t m_nMinCPULevel = 0x2EC; // int32_t
    constexpr std::ptrdiff_t m_nMinGPULevel = 0x2F0; // int32_t
    constexpr std::ptrdiff_t m_flNoDrawTimeToGoToSleep = 0x2F4; // float
    constexpr std::ptrdiff_t m_flMaxDrawDistance = 0x2F8; // float
    constexpr std::ptrdiff_t m_flStartFadeDistance = 0x2FC; // float
    constexpr std::ptrdiff_t m_flMaxCreationDistance = 0x300; // float
    constexpr std::ptrdiff_t m_nAggregationMinAvailableParticles = 0x304; // int32_t
    constexpr std::ptrdiff_t m_flAggregateRadius = 0x308; // float
    constexpr std::ptrdiff_t m_bShouldBatch = 0x30C; // bool
    constexpr std::ptrdiff_t m_bShouldHitboxesFallbackToRenderBounds = 0x30D; // bool
    constexpr std::ptrdiff_t m_bShouldHitboxesFallbackToSnapshot = 0x30E; // bool
    constexpr std::ptrdiff_t m_nViewModelEffect = 0x310; // InheritableBoolType_t
    constexpr std::ptrdiff_t m_bScreenSpaceEffect = 0x314; // bool
    constexpr std::ptrdiff_t m_pszTargetLayerID = 0x318; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nSkipRenderControlPoint = 0x320; // int32_t
    constexpr std::ptrdiff_t m_nAllowRenderControlPoint = 0x324; // int32_t
    constexpr std::ptrdiff_t m_bShouldSort = 0x328; // bool
    constexpr std::ptrdiff_t m_controlPointConfigurations = 0x370; // CUtlVector<ParticleControlPointConfiguration_t>
}

namespace CParticleTransformInput {
    constexpr std::ptrdiff_t m_nType = 0x10; // ParticleTransformType_t
    constexpr std::ptrdiff_t m_NamedValue = 0x18; // CParticleNamedValueRef
    constexpr std::ptrdiff_t m_bFollowNamedValue = 0x58; // bool
    constexpr std::ptrdiff_t m_bSupportsDisabled = 0x59; // bool
    constexpr std::ptrdiff_t m_bUseOrientation = 0x5A; // bool
    constexpr std::ptrdiff_t m_nControlPoint = 0x5C; // int32_t
    constexpr std::ptrdiff_t m_nControlPointRangeMax = 0x60; // int32_t
    constexpr std::ptrdiff_t m_flEndCPGrowthTime = 0x64; // float
}

namespace CParticleVariableRef {
    constexpr std::ptrdiff_t m_variableName = 0x0; // CKV3MemberNameWithStorage
    constexpr std::ptrdiff_t m_variableType = 0x38; // PulseValueType_t
}

namespace CParticleVecInput {
    constexpr std::ptrdiff_t m_nType = 0x10; // ParticleVecType_t
    constexpr std::ptrdiff_t m_vLiteralValue = 0x14; // Vector
    constexpr std::ptrdiff_t m_LiteralColor = 0x20; // Color
    constexpr std::ptrdiff_t m_NamedValue = 0x28; // CParticleNamedValueRef
    constexpr std::ptrdiff_t m_bFollowNamedValue = 0x68; // bool
    constexpr std::ptrdiff_t m_nVectorAttribute = 0x6C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vVectorAttributeScale = 0x70; // Vector
    constexpr std::ptrdiff_t m_nControlPoint = 0x7C; // int32_t
    constexpr std::ptrdiff_t m_nDeltaControlPoint = 0x80; // int32_t
    constexpr std::ptrdiff_t m_vCPValueScale = 0x84; // Vector
    constexpr std::ptrdiff_t m_vCPRelativePosition = 0x90; // Vector
    constexpr std::ptrdiff_t m_vCPRelativeDir = 0x9C; // Vector
    constexpr std::ptrdiff_t m_FloatComponentX = 0xA8; // CParticleFloatInput
    constexpr std::ptrdiff_t m_FloatComponentY = 0x200; // CParticleFloatInput
    constexpr std::ptrdiff_t m_FloatComponentZ = 0x358; // CParticleFloatInput
    constexpr std::ptrdiff_t m_FloatInterp = 0x4B0; // CParticleFloatInput
    constexpr std::ptrdiff_t m_flInterpInput0 = 0x608; // float
    constexpr std::ptrdiff_t m_flInterpInput1 = 0x60C; // float
    constexpr std::ptrdiff_t m_vInterpOutput0 = 0x610; // Vector
    constexpr std::ptrdiff_t m_vInterpOutput1 = 0x61C; // Vector
    constexpr std::ptrdiff_t m_Gradient = 0x628; // CColorGradient
    constexpr std::ptrdiff_t m_vRandomMin = 0x640; // Vector
    constexpr std::ptrdiff_t m_vRandomMax = 0x64C; // Vector
}

namespace CParticleVisibilityInputs {
    constexpr std::ptrdiff_t m_flCameraBias = 0x0; // float
    constexpr std::ptrdiff_t m_nCPin = 0x4; // int32_t
    constexpr std::ptrdiff_t m_flProxyRadius = 0x8; // float
    constexpr std::ptrdiff_t m_flInputMin = 0xC; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x10; // float
    constexpr std::ptrdiff_t m_flNoPixelVisibilityFallback = 0x14; // float
    constexpr std::ptrdiff_t m_flDistanceInputMin = 0x18; // float
    constexpr std::ptrdiff_t m_flDistanceInputMax = 0x1C; // float
    constexpr std::ptrdiff_t m_flDotInputMin = 0x20; // float
    constexpr std::ptrdiff_t m_flDotInputMax = 0x24; // float
    constexpr std::ptrdiff_t m_bDotCPAngles = 0x28; // bool
    constexpr std::ptrdiff_t m_bDotCameraAngles = 0x29; // bool
    constexpr std::ptrdiff_t m_flAlphaScaleMin = 0x2C; // float
    constexpr std::ptrdiff_t m_flAlphaScaleMax = 0x30; // float
    constexpr std::ptrdiff_t m_flRadiusScaleMin = 0x34; // float
    constexpr std::ptrdiff_t m_flRadiusScaleMax = 0x38; // float
    constexpr std::ptrdiff_t m_flRadiusScaleFOVBase = 0x3C; // float
    constexpr std::ptrdiff_t m_bRightEye = 0x40; // bool
}

namespace CPathParameters {
    constexpr std::ptrdiff_t m_nStartControlPointNumber = 0x0; // int32_t
    constexpr std::ptrdiff_t m_nEndControlPointNumber = 0x4; // int32_t
    constexpr std::ptrdiff_t m_nBulgeControl = 0x8; // int32_t
    constexpr std::ptrdiff_t m_flBulge = 0xC; // float
    constexpr std::ptrdiff_t m_flMidPoint = 0x10; // float
    constexpr std::ptrdiff_t m_vStartPointOffset = 0x14; // Vector
    constexpr std::ptrdiff_t m_vMidPointOffset = 0x20; // Vector
    constexpr std::ptrdiff_t m_vEndOffset = 0x2C; // Vector
}

namespace CRandomNumberGeneratorParameters {
    constexpr std::ptrdiff_t m_bDistributeEvenly = 0x0; // bool
    constexpr std::ptrdiff_t m_nSeed = 0x4; // int32_t
}

namespace C_INIT_AddVectorToVector {
    constexpr std::ptrdiff_t m_vecScale = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1CC; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldInput = 0x1D0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vOffsetMin = 0x1D4; // Vector
    constexpr std::ptrdiff_t m_vOffsetMax = 0x1E0; // Vector
    constexpr std::ptrdiff_t m_randomnessParameters = 0x1EC; // CRandomNumberGeneratorParameters
}

namespace C_INIT_AgeNoise {
    constexpr std::ptrdiff_t m_bAbsVal = 0x1C0; // bool
    constexpr std::ptrdiff_t m_bAbsValInv = 0x1C1; // bool
    constexpr std::ptrdiff_t m_flOffset = 0x1C4; // float
    constexpr std::ptrdiff_t m_flAgeMin = 0x1C8; // float
    constexpr std::ptrdiff_t m_flAgeMax = 0x1CC; // float
    constexpr std::ptrdiff_t m_flNoiseScale = 0x1D0; // float
    constexpr std::ptrdiff_t m_flNoiseScaleLoc = 0x1D4; // float
    constexpr std::ptrdiff_t m_vecOffsetLoc = 0x1D8; // Vector
}

namespace C_INIT_ChaoticAttractor {
    constexpr std::ptrdiff_t m_flAParm = 0x1C0; // float
    constexpr std::ptrdiff_t m_flBParm = 0x1C4; // float
    constexpr std::ptrdiff_t m_flCParm = 0x1C8; // float
    constexpr std::ptrdiff_t m_flDParm = 0x1CC; // float
    constexpr std::ptrdiff_t m_flScale = 0x1D0; // float
    constexpr std::ptrdiff_t m_flSpeedMin = 0x1D4; // float
    constexpr std::ptrdiff_t m_flSpeedMax = 0x1D8; // float
    constexpr std::ptrdiff_t m_nBaseCP = 0x1DC; // int32_t
    constexpr std::ptrdiff_t m_bUniformSpeed = 0x1E0; // bool
}

namespace C_INIT_ColorLitPerParticle {
    constexpr std::ptrdiff_t m_ColorMin = 0x1D8; // Color
    constexpr std::ptrdiff_t m_ColorMax = 0x1DC; // Color
    constexpr std::ptrdiff_t m_TintMin = 0x1E0; // Color
    constexpr std::ptrdiff_t m_TintMax = 0x1E4; // Color
    constexpr std::ptrdiff_t m_flTintPerc = 0x1E8; // float
    constexpr std::ptrdiff_t m_nTintBlendMode = 0x1EC; // ParticleColorBlendMode_t
    constexpr std::ptrdiff_t m_flLightAmplification = 0x1F0; // float
}

namespace C_INIT_CreateAlongPath {
    constexpr std::ptrdiff_t m_fMaxDistance = 0x1C0; // float
    constexpr std::ptrdiff_t m_PathParams = 0x1D0; // CPathParameters
    constexpr std::ptrdiff_t m_bUseRandomCPs = 0x210; // bool
    constexpr std::ptrdiff_t m_vEndOffset = 0x214; // Vector
    constexpr std::ptrdiff_t m_bSaveOffset = 0x220; // bool
}

namespace C_INIT_CreateFromCPs {
    constexpr std::ptrdiff_t m_nIncrement = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nMinCP = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nMaxCP = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nDynamicCPCount = 0x1D0; // CParticleCollectionFloatInput
}

namespace C_INIT_CreateFromParentParticles {
    constexpr std::ptrdiff_t m_flVelocityScale = 0x1C0; // float
    constexpr std::ptrdiff_t m_flIncrement = 0x1C4; // float
    constexpr std::ptrdiff_t m_bRandomDistribution = 0x1C8; // bool
    constexpr std::ptrdiff_t m_nRandomSeed = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_bSubFrame = 0x1D0; // bool
}

namespace C_INIT_CreateFromPlaneCache {
    constexpr std::ptrdiff_t m_vecOffsetMin = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_vecOffsetMax = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_bUseNormal = 0x1D9; // bool
}

namespace C_INIT_CreateInEpitrochoid {
    constexpr std::ptrdiff_t m_nComponent1 = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nComponent2 = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_TransformInput = 0x1C8; // CParticleTransformInput
    constexpr std::ptrdiff_t m_flParticleDensity = 0x230; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOffset = 0x388; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flRadius1 = 0x4E0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flRadius2 = 0x638; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_bUseCount = 0x790; // bool
    constexpr std::ptrdiff_t m_bUseLocalCoords = 0x791; // bool
    constexpr std::ptrdiff_t m_bOffsetExistingPos = 0x792; // bool
}

namespace C_INIT_CreateOnGrid {
    constexpr std::ptrdiff_t m_nXCount = 0x1C0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nYCount = 0x318; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nZCount = 0x470; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nXSpacing = 0x5C8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nYSpacing = 0x720; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nZSpacing = 0x878; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x9D0; // int32_t
    constexpr std::ptrdiff_t m_bLocalSpace = 0x9D4; // bool
    constexpr std::ptrdiff_t m_bCenter = 0x9D5; // bool
    constexpr std::ptrdiff_t m_bHollow = 0x9D6; // bool
}

namespace C_INIT_CreateOnModel {
    constexpr std::ptrdiff_t m_modelInput = 0x1C0; // CParticleModelInput
    constexpr std::ptrdiff_t m_transformInput = 0x220; // CParticleTransformInput
    constexpr std::ptrdiff_t m_nForceInModel = 0x288; // int32_t
    constexpr std::ptrdiff_t m_nDesiredHitbox = 0x28C; // int32_t
    constexpr std::ptrdiff_t m_nHitboxValueFromControlPointIndex = 0x290; // int32_t
    constexpr std::ptrdiff_t m_vecHitBoxScale = 0x298; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_flBoneVelocity = 0x8F0; // float
    constexpr std::ptrdiff_t m_flMaxBoneVelocity = 0x8F4; // float
    constexpr std::ptrdiff_t m_vecDirectionBias = 0x8F8; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_HitboxSetName = 0xF50; // char[128]
    constexpr std::ptrdiff_t m_bLocalCoords = 0xFD0; // bool
    constexpr std::ptrdiff_t m_bUseBones = 0xFD1; // bool
    constexpr std::ptrdiff_t m_flShellSize = 0xFD8; // CParticleCollectionFloatInput
}

namespace C_INIT_CreateOnModelAtHeight {
    constexpr std::ptrdiff_t m_bUseBones = 0x1C0; // bool
    constexpr std::ptrdiff_t m_bForceZ = 0x1C1; // bool
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nHeightCP = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_bUseWaterHeight = 0x1CC; // bool
    constexpr std::ptrdiff_t m_flDesiredHeight = 0x1D0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_vecHitBoxScale = 0x328; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_vecDirectionBias = 0x980; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nBiasType = 0xFD8; // ParticleHitboxBiasType_t
    constexpr std::ptrdiff_t m_bLocalCoords = 0xFDC; // bool
    constexpr std::ptrdiff_t m_bPreferMovingBoxes = 0xFDD; // bool
    constexpr std::ptrdiff_t m_HitboxSetName = 0xFDE; // char[128]
    constexpr std::ptrdiff_t m_flHitboxVelocityScale = 0x1060; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flMaxBoneVelocity = 0x11B8; // CParticleCollectionFloatInput
}

namespace C_INIT_CreateParticleImpulse {
    constexpr std::ptrdiff_t m_InputRadius = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_InputMagnitude = 0x318; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nFalloffFunction = 0x470; // ParticleFalloffFunction_t
    constexpr std::ptrdiff_t m_InputFalloffExp = 0x478; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nImpulseType = 0x5D0; // ParticleImpulseType_t
}

namespace C_INIT_CreatePhyllotaxis {
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nScaleCP = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nComponent = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_fRadCentCore = 0x1CC; // float
    constexpr std::ptrdiff_t m_fRadPerPoint = 0x1D0; // float
    constexpr std::ptrdiff_t m_fRadPerPointTo = 0x1D4; // float
    constexpr std::ptrdiff_t m_fpointAngle = 0x1D8; // float
    constexpr std::ptrdiff_t m_fsizeOverall = 0x1DC; // float
    constexpr std::ptrdiff_t m_fRadBias = 0x1E0; // float
    constexpr std::ptrdiff_t m_fMinRad = 0x1E4; // float
    constexpr std::ptrdiff_t m_fDistBias = 0x1E8; // float
    constexpr std::ptrdiff_t m_bUseLocalCoords = 0x1EC; // bool
    constexpr std::ptrdiff_t m_bUseWithContEmit = 0x1ED; // bool
    constexpr std::ptrdiff_t m_bUseOrigRadius = 0x1EE; // bool
}

namespace C_INIT_CreateSequentialPath {
    constexpr std::ptrdiff_t m_fMaxDistance = 0x1C0; // float
    constexpr std::ptrdiff_t m_flNumToAssign = 0x1C4; // float
    constexpr std::ptrdiff_t m_bLoop = 0x1C8; // bool
    constexpr std::ptrdiff_t m_bCPPairs = 0x1C9; // bool
    constexpr std::ptrdiff_t m_bSaveOffset = 0x1CA; // bool
    constexpr std::ptrdiff_t m_PathParams = 0x1D0; // CPathParameters
}

namespace C_INIT_CreateSequentialPathV2 {
    constexpr std::ptrdiff_t m_fMaxDistance = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flNumToAssign = 0x318; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bLoop = 0x470; // bool
    constexpr std::ptrdiff_t m_bCPPairs = 0x471; // bool
    constexpr std::ptrdiff_t m_bSaveOffset = 0x472; // bool
    constexpr std::ptrdiff_t m_PathParams = 0x480; // CPathParameters
}

namespace C_INIT_CreateSpiralSphere {
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nOverrideCP = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nDensity = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_flInitialRadius = 0x1CC; // float
    constexpr std::ptrdiff_t m_flInitialSpeedMin = 0x1D0; // float
    constexpr std::ptrdiff_t m_flInitialSpeedMax = 0x1D4; // float
    constexpr std::ptrdiff_t m_bUseParticleCount = 0x1D8; // bool
}

namespace C_INIT_CreateWithinBox {
    constexpr std::ptrdiff_t m_vecMin = 0x1C0; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecMax = 0x818; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_nControlPointNumber = 0xE70; // int32_t
    constexpr std::ptrdiff_t m_bLocalSpace = 0xE74; // bool
    constexpr std::ptrdiff_t m_randomnessParameters = 0xE78; // CRandomNumberGeneratorParameters
}

namespace C_INIT_CreateWithinSphereTransform {
    constexpr std::ptrdiff_t m_fRadiusMin = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_fRadiusMax = 0x318; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_vecDistanceBias = 0x470; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecDistanceBiasAbs = 0xAC8; // Vector
    constexpr std::ptrdiff_t m_TransformInput = 0xAD8; // CParticleTransformInput
    constexpr std::ptrdiff_t m_fSpeedMin = 0xB40; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_fSpeedMax = 0xC98; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_fSpeedRandExp = 0xDF0; // float
    constexpr std::ptrdiff_t m_bLocalCoords = 0xDF4; // bool
    constexpr std::ptrdiff_t m_flEndCPGrowthTime = 0xDF8; // float
    constexpr std::ptrdiff_t m_LocalCoordinateSystemSpeedMin = 0xE00; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_LocalCoordinateSystemSpeedMax = 0x1458; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1AB0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldVelocity = 0x1AB4; // ParticleAttributeIndex_t
}

namespace C_INIT_CreationNoise {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bAbsVal = 0x1C4; // bool
    constexpr std::ptrdiff_t m_bAbsValInv = 0x1C5; // bool
    constexpr std::ptrdiff_t m_flOffset = 0x1C8; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1CC; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D0; // float
    constexpr std::ptrdiff_t m_flNoiseScale = 0x1D4; // float
    constexpr std::ptrdiff_t m_flNoiseScaleLoc = 0x1D8; // float
    constexpr std::ptrdiff_t m_vecOffsetLoc = 0x1DC; // Vector
    constexpr std::ptrdiff_t m_flWorldTimeScale = 0x1E8; // float
}

namespace C_INIT_DistanceCull {
    constexpr std::ptrdiff_t m_nControlPoint = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_flDistance = 0x1C8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bCullInside = 0x320; // bool
}

namespace C_INIT_DistanceToCPInit {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flInputMax = 0x320; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMin = 0x478; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMax = 0x5D0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nStartCP = 0x728; // int32_t
    constexpr std::ptrdiff_t m_bLOS = 0x72C; // bool
    constexpr std::ptrdiff_t m_CollisionGroupName = 0x72D; // char[128]
    constexpr std::ptrdiff_t m_nTraceSet = 0x7B0; // ParticleTraceSet_t
    constexpr std::ptrdiff_t m_flMaxTraceLength = 0x7B8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flLOSScale = 0x910; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x914; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bActiveRange = 0x918; // bool
    constexpr std::ptrdiff_t m_vecDistanceScale = 0x91C; // Vector
    constexpr std::ptrdiff_t m_flRemapBias = 0x928; // float
}

namespace C_INIT_DistanceToNeighborCull {
    constexpr std::ptrdiff_t m_flDistance = 0x1C0; // CPerParticleFloatInput
}

namespace C_INIT_GlobalScale {
    constexpr std::ptrdiff_t m_flScale = 0x1C0; // float
    constexpr std::ptrdiff_t m_nScaleControlPointNumber = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_bScaleRadius = 0x1CC; // bool
    constexpr std::ptrdiff_t m_bScalePosition = 0x1CD; // bool
    constexpr std::ptrdiff_t m_bScaleVelocity = 0x1CE; // bool
}

namespace C_INIT_InheritFromParentParticles {
    constexpr std::ptrdiff_t m_flScale = 0x1C0; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nIncrement = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_bRandomDistribution = 0x1CC; // bool
    constexpr std::ptrdiff_t m_nRandomSeed = 0x1D0; // int32_t
}

namespace C_INIT_InheritVelocity {
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_flVelocityScale = 0x1C4; // float
}

namespace C_INIT_InitFloat {
    constexpr std::ptrdiff_t m_InputValue = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nOutputField = 0x318; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSetMethod = 0x31C; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_InputStrength = 0x320; // CPerParticleFloatInput
}

namespace C_INIT_InitFloatCollection {
    constexpr std::ptrdiff_t m_InputValue = 0x1C0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nOutputField = 0x318; // ParticleAttributeIndex_t
}

namespace C_INIT_InitFromCPSnapshot {
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nAttributeToRead = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nAttributeToWrite = 0x1C8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nLocalSpaceCP = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_bRandom = 0x1D0; // bool
    constexpr std::ptrdiff_t m_bReverse = 0x1D1; // bool
    constexpr std::ptrdiff_t m_nSnapShotIncrement = 0x1D8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nManualSnapshotIndex = 0x330; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nRandomSeed = 0x488; // int32_t
    constexpr std::ptrdiff_t m_bLocalSpaceAngles = 0x48C; // bool
}

namespace C_INIT_InitFromParentKilled {
    constexpr std::ptrdiff_t m_nAttributeToCopy = 0x1C0; // ParticleAttributeIndex_t
}

namespace C_INIT_InitFromVectorFieldSnapshot {
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nLocalSpaceCP = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nWeightUpdateCP = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_bUseVerticalVelocity = 0x1CC; // bool
    constexpr std::ptrdiff_t m_vecScale = 0x1D0; // CPerParticleVecInput
}

namespace C_INIT_InitSkinnedPositionFromCPSnapshot {
    constexpr std::ptrdiff_t m_nSnapshotControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_bRandom = 0x1C8; // bool
    constexpr std::ptrdiff_t m_nRandomSeed = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_bRigid = 0x1D0; // bool
    constexpr std::ptrdiff_t m_bSetNormal = 0x1D1; // bool
    constexpr std::ptrdiff_t m_bIgnoreDt = 0x1D2; // bool
    constexpr std::ptrdiff_t m_flMinNormalVelocity = 0x1D4; // float
    constexpr std::ptrdiff_t m_flMaxNormalVelocity = 0x1D8; // float
    constexpr std::ptrdiff_t m_flIncrement = 0x1DC; // float
    constexpr std::ptrdiff_t m_nFullLoopIncrement = 0x1E0; // int32_t
    constexpr std::ptrdiff_t m_nSnapShotStartPoint = 0x1E4; // int32_t
    constexpr std::ptrdiff_t m_flBoneVelocity = 0x1E8; // float
    constexpr std::ptrdiff_t m_flBoneVelocityMax = 0x1EC; // float
    constexpr std::ptrdiff_t m_bCopyColor = 0x1F0; // bool
    constexpr std::ptrdiff_t m_bCopyAlpha = 0x1F1; // bool
    constexpr std::ptrdiff_t m_bSetRadius = 0x1F2; // bool
}

namespace C_INIT_InitVec {
    constexpr std::ptrdiff_t m_InputValue = 0x1C0; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_nOutputField = 0x818; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSetMethod = 0x81C; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bNormalizedOutput = 0x820; // bool
    constexpr std::ptrdiff_t m_bWritePreviousPosition = 0x821; // bool
}

namespace C_INIT_InitVecCollection {
    constexpr std::ptrdiff_t m_InputValue = 0x1C0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nOutputField = 0x818; // ParticleAttributeIndex_t
}

namespace C_INIT_InitialRepulsionVelocity {
    constexpr std::ptrdiff_t m_CollisionGroupName = 0x1C0; // char[128]
    constexpr std::ptrdiff_t m_nTraceSet = 0x240; // ParticleTraceSet_t
    constexpr std::ptrdiff_t m_vecOutputMin = 0x244; // Vector
    constexpr std::ptrdiff_t m_vecOutputMax = 0x250; // Vector
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x25C; // int32_t
    constexpr std::ptrdiff_t m_bPerParticle = 0x260; // bool
    constexpr std::ptrdiff_t m_bTranslate = 0x261; // bool
    constexpr std::ptrdiff_t m_bProportional = 0x262; // bool
    constexpr std::ptrdiff_t m_flTraceLength = 0x264; // float
    constexpr std::ptrdiff_t m_bPerParticleTR = 0x268; // bool
    constexpr std::ptrdiff_t m_bInherit = 0x269; // bool
    constexpr std::ptrdiff_t m_nChildCP = 0x26C; // int32_t
    constexpr std::ptrdiff_t m_nChildGroupID = 0x270; // int32_t
}

namespace C_INIT_InitialSequenceFromModel {
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutputAnim = 0x1C8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1CC; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D4; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D8; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x1DC; // ParticleSetMethod_t
}

namespace C_INIT_InitialVelocityFromHitbox {
    constexpr std::ptrdiff_t m_flVelocityMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_flVelocityMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_HitboxSetName = 0x1CC; // char[128]
    constexpr std::ptrdiff_t m_bUseBones = 0x24C; // bool
}

namespace C_INIT_InitialVelocityNoise {
    constexpr std::ptrdiff_t m_vecAbsVal = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_vecAbsValInv = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_vecOffsetLoc = 0x1D8; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_flOffset = 0x830; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_vecOutputMin = 0x988; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecOutputMax = 0xFE0; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_flNoiseScale = 0x1638; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flNoiseScaleLoc = 0x1790; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_TransformInput = 0x18E8; // CParticleTransformInput
    constexpr std::ptrdiff_t m_bIgnoreDt = 0x1950; // bool
}

namespace C_INIT_LifespanFromVelocity {
    constexpr std::ptrdiff_t m_vecComponentScale = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_flTraceOffset = 0x1CC; // float
    constexpr std::ptrdiff_t m_flMaxTraceLength = 0x1D0; // float
    constexpr std::ptrdiff_t m_flTraceTolerance = 0x1D4; // float
    constexpr std::ptrdiff_t m_nMaxPlanes = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_CollisionGroupName = 0x1E0; // char[128]
    constexpr std::ptrdiff_t m_nTraceSet = 0x260; // ParticleTraceSet_t
    constexpr std::ptrdiff_t m_bIncludeWater = 0x270; // bool
}

namespace C_INIT_ModelCull {
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_bBoundBox = 0x1C4; // bool
    constexpr std::ptrdiff_t m_bCullOutside = 0x1C5; // bool
    constexpr std::ptrdiff_t m_bUseBones = 0x1C6; // bool
    constexpr std::ptrdiff_t m_HitboxSetName = 0x1C7; // char[128]
}

namespace C_INIT_MoveBetweenPoints {
    constexpr std::ptrdiff_t m_flSpeedMin = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flSpeedMax = 0x318; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flEndSpread = 0x470; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flStartOffset = 0x5C8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flEndOffset = 0x720; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nEndControlPointNumber = 0x878; // int32_t
    constexpr std::ptrdiff_t m_bTrailBias = 0x87C; // bool
}

namespace C_INIT_NormalAlignToCP {
    constexpr std::ptrdiff_t m_transformInput = 0x1C0; // CParticleTransformInput
    constexpr std::ptrdiff_t m_nControlPointAxis = 0x228; // ParticleControlPointAxis_t
}

namespace C_INIT_NormalOffset {
    constexpr std::ptrdiff_t m_OffsetMin = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_OffsetMax = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_bLocalCoords = 0x1DC; // bool
    constexpr std::ptrdiff_t m_bNormalize = 0x1DD; // bool
}

namespace C_INIT_OffsetVectorToVector {
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vecOutputMin = 0x1C8; // Vector
    constexpr std::ptrdiff_t m_vecOutputMax = 0x1D4; // Vector
    constexpr std::ptrdiff_t m_randomnessParameters = 0x1E0; // CRandomNumberGeneratorParameters
}

namespace C_INIT_Orient2DRelToCP {
    constexpr std::ptrdiff_t m_nCP = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flRotOffset = 0x1C8; // float
}

namespace C_INIT_PlaneCull {
    constexpr std::ptrdiff_t m_nControlPoint = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_flDistance = 0x1C8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bCullInside = 0x320; // bool
}

namespace C_INIT_PointList {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_pointList = 0x1C8; // CUtlVector<PointDefinition_t>
    constexpr std::ptrdiff_t m_bPlaceAlongPath = 0x1E0; // bool
    constexpr std::ptrdiff_t m_bClosedLoop = 0x1E1; // bool
    constexpr std::ptrdiff_t m_nNumPointsAlongPath = 0x1E4; // int32_t
}

namespace C_INIT_PositionOffset {
    constexpr std::ptrdiff_t m_OffsetMin = 0x1C0; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_OffsetMax = 0x818; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_TransformInput = 0xE70; // CParticleTransformInput
    constexpr std::ptrdiff_t m_bLocalCoords = 0xED8; // bool
    constexpr std::ptrdiff_t m_bProportional = 0xED9; // bool
    constexpr std::ptrdiff_t m_randomnessParameters = 0xEDC; // CRandomNumberGeneratorParameters
}

namespace C_INIT_PositionOffsetToCP {
    constexpr std::ptrdiff_t m_nControlPointNumberStart = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nControlPointNumberEnd = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_bLocalCoords = 0x1C8; // bool
}

namespace C_INIT_PositionPlaceOnGround {
    constexpr std::ptrdiff_t m_flOffset = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flMaxTraceLength = 0x318; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_CollisionGroupName = 0x470; // char[128]
    constexpr std::ptrdiff_t m_nTraceSet = 0x4F0; // ParticleTraceSet_t
    constexpr std::ptrdiff_t m_nTraceMissBehavior = 0x500; // ParticleTraceMissBehavior_t
    constexpr std::ptrdiff_t m_bIncludeWater = 0x504; // bool
    constexpr std::ptrdiff_t m_bSetNormal = 0x505; // bool
    constexpr std::ptrdiff_t m_bSetPXYZOnly = 0x506; // bool
    constexpr std::ptrdiff_t m_bTraceAlongNormal = 0x507; // bool
    constexpr std::ptrdiff_t m_bOffsetonColOnly = 0x508; // bool
    constexpr std::ptrdiff_t m_flOffsetByRadiusFactor = 0x50C; // float
    constexpr std::ptrdiff_t m_nPreserveOffsetCP = 0x510; // int32_t
    constexpr std::ptrdiff_t m_nIgnoreCP = 0x514; // int32_t
}

namespace C_INIT_PositionWarp {
    constexpr std::ptrdiff_t m_vecWarpMin = 0x1C0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_vecWarpMax = 0x818; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nScaleControlPointNumber = 0xE70; // int32_t
    constexpr std::ptrdiff_t m_nControlPointNumber = 0xE74; // int32_t
    constexpr std::ptrdiff_t m_nRadiusComponent = 0xE78; // int32_t
    constexpr std::ptrdiff_t m_flWarpTime = 0xE7C; // float
    constexpr std::ptrdiff_t m_flWarpStartTime = 0xE80; // float
    constexpr std::ptrdiff_t m_flPrevPosScale = 0xE84; // float
    constexpr std::ptrdiff_t m_bInvertWarp = 0xE88; // bool
    constexpr std::ptrdiff_t m_bUseCount = 0xE89; // bool
}

namespace C_INIT_PositionWarpScalar {
    constexpr std::ptrdiff_t m_vecWarpMin = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_vecWarpMax = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_InputValue = 0x1D8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flPrevPosScale = 0x330; // float
    constexpr std::ptrdiff_t m_nScaleControlPointNumber = 0x334; // int32_t
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x338; // int32_t
}

namespace C_INIT_QuantizeFloat {
    constexpr std::ptrdiff_t m_InputValue = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nOutputField = 0x318; // ParticleAttributeIndex_t
}

namespace C_INIT_RadiusFromCPObject {
    constexpr std::ptrdiff_t m_nControlPoint = 0x1C0; // int32_t
}

namespace C_INIT_RandomAlpha {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nAlphaMin = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nAlphaMax = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_flAlphaRandExponent = 0x1D4; // float
}

namespace C_INIT_RandomAlphaWindowThreshold {
    constexpr std::ptrdiff_t m_flMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_flMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_flExponent = 0x1C8; // float
}

namespace C_INIT_RandomColor {
    constexpr std::ptrdiff_t m_ColorMin = 0x1DC; // Color
    constexpr std::ptrdiff_t m_ColorMax = 0x1E0; // Color
    constexpr std::ptrdiff_t m_TintMin = 0x1E4; // Color
    constexpr std::ptrdiff_t m_TintMax = 0x1E8; // Color
    constexpr std::ptrdiff_t m_flTintPerc = 0x1EC; // float
    constexpr std::ptrdiff_t m_flUpdateThreshold = 0x1F0; // float
    constexpr std::ptrdiff_t m_nTintCP = 0x1F4; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1F8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nTintBlendMode = 0x1FC; // ParticleColorBlendMode_t
    constexpr std::ptrdiff_t m_flLightAmplification = 0x200; // float
}

namespace C_INIT_RandomLifeTime {
    constexpr std::ptrdiff_t m_fLifetimeMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_fLifetimeMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_fLifetimeRandExponent = 0x1C8; // float
}

namespace C_INIT_RandomModelSequence {
    constexpr std::ptrdiff_t m_ActivityName = 0x1C0; // char[256]
    constexpr std::ptrdiff_t m_SequenceName = 0x2C0; // char[256]
    constexpr std::ptrdiff_t m_hModel = 0x3C0; // CStrongHandle<InfoForResourceTypeCModel>
}

namespace C_INIT_RandomNamedModelElement {
    constexpr std::ptrdiff_t m_hModel = 0x1C0; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_names = 0x1C8; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_bShuffle = 0x1E0; // bool
    constexpr std::ptrdiff_t m_bLinear = 0x1E1; // bool
    constexpr std::ptrdiff_t m_bModelFromRenderer = 0x1E2; // bool
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1E4; // ParticleAttributeIndex_t
}

namespace C_INIT_RandomRadius {
    constexpr std::ptrdiff_t m_flRadiusMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_flRadiusMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_flRadiusRandExponent = 0x1C8; // float
}

namespace C_INIT_RandomScalar {
    constexpr std::ptrdiff_t m_flMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_flMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_flExponent = 0x1C8; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1CC; // ParticleAttributeIndex_t
}

namespace C_INIT_RandomSecondSequence {
    constexpr std::ptrdiff_t m_nSequenceMin = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nSequenceMax = 0x1C4; // int32_t
}

namespace C_INIT_RandomSequence {
    constexpr std::ptrdiff_t m_nSequenceMin = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nSequenceMax = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_bShuffle = 0x1C8; // bool
    constexpr std::ptrdiff_t m_bLinear = 0x1C9; // bool
    constexpr std::ptrdiff_t m_WeightedList = 0x1D0; // CUtlVector<SequenceWeightedList_t>
}

namespace C_INIT_RandomTrailLength {
    constexpr std::ptrdiff_t m_flMinLength = 0x1C0; // float
    constexpr std::ptrdiff_t m_flMaxLength = 0x1C4; // float
    constexpr std::ptrdiff_t m_flLengthRandExponent = 0x1C8; // float
}

namespace C_INIT_RandomVector {
    constexpr std::ptrdiff_t m_vecMin = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_vecMax = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1D8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_randomnessParameters = 0x1DC; // CRandomNumberGeneratorParameters
}

namespace C_INIT_RandomVectorComponent {
    constexpr std::ptrdiff_t m_flMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_flMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nComponent = 0x1CC; // int32_t
}

namespace C_INIT_RandomYawFlip {
    constexpr std::ptrdiff_t m_flPercent = 0x1C0; // float
}

namespace C_INIT_RemapCPtoScalar {
    constexpr std::ptrdiff_t m_nCPInput = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nField = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1CC; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D4; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D8; // float
    constexpr std::ptrdiff_t m_flStartTime = 0x1DC; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x1E0; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x1E4; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_flRemapBias = 0x1E8; // float
}

namespace C_INIT_RemapInitialDirectionToTransformToVector {
    constexpr std::ptrdiff_t m_TransformInput = 0x1C0; // CParticleTransformInput
    constexpr std::ptrdiff_t m_nFieldOutput = 0x228; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flScale = 0x22C; // float
    constexpr std::ptrdiff_t m_flOffsetRot = 0x230; // float
    constexpr std::ptrdiff_t m_vecOffsetAxis = 0x234; // Vector
    constexpr std::ptrdiff_t m_bNormalize = 0x240; // bool
}

namespace C_INIT_RemapInitialTransformDirectionToRotation {
    constexpr std::ptrdiff_t m_TransformInput = 0x1C0; // CParticleTransformInput
    constexpr std::ptrdiff_t m_nFieldOutput = 0x228; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flOffsetRot = 0x22C; // float
    constexpr std::ptrdiff_t m_nComponent = 0x230; // int32_t
}

namespace C_INIT_RemapInitialVisibilityScalar {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C8; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1CC; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D4; // float
}

namespace C_INIT_RemapNamedModelElementToScalar {
    constexpr std::ptrdiff_t m_hModel = 0x1C0; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_names = 0x1C8; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_values = 0x1E0; // CUtlVector<float>
    constexpr std::ptrdiff_t m_nFieldInput = 0x1F8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1FC; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSetMethod = 0x200; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bModelFromRenderer = 0x204; // bool
}

namespace C_INIT_RemapParticleCountToNamedModelElementScalar {
    constexpr std::ptrdiff_t m_hModel = 0x1F0; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_outputMinName = 0x1F8; // CUtlString
    constexpr std::ptrdiff_t m_outputMaxName = 0x200; // CUtlString
    constexpr std::ptrdiff_t m_bModelFromRenderer = 0x208; // bool
}

namespace C_INIT_RemapParticleCountToScalar {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nInputMin = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nInputMax = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nScaleControlPoint = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_nScaleControlPointField = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D4; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D8; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x1DC; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bActiveRange = 0x1E0; // bool
    constexpr std::ptrdiff_t m_bInvert = 0x1E1; // bool
    constexpr std::ptrdiff_t m_bWrap = 0x1E2; // bool
    constexpr std::ptrdiff_t m_flRemapBias = 0x1E4; // float
}

namespace C_INIT_RemapQAnglesToRotation {
    constexpr std::ptrdiff_t m_TransformInput = 0x1C0; // CParticleTransformInput
}

namespace C_INIT_RemapScalar {
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C8; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1CC; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D4; // float
    constexpr std::ptrdiff_t m_flStartTime = 0x1D8; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x1DC; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x1E0; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bActiveRange = 0x1E4; // bool
    constexpr std::ptrdiff_t m_flRemapBias = 0x1E8; // float
}

namespace C_INIT_RemapScalarToVector {
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C8; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1CC; // float
    constexpr std::ptrdiff_t m_vecOutputMin = 0x1D0; // Vector
    constexpr std::ptrdiff_t m_vecOutputMax = 0x1DC; // Vector
    constexpr std::ptrdiff_t m_flStartTime = 0x1E8; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x1EC; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x1F0; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1F4; // int32_t
    constexpr std::ptrdiff_t m_bLocalCoords = 0x1F8; // bool
    constexpr std::ptrdiff_t m_flRemapBias = 0x1FC; // float
}

namespace C_INIT_RemapSpeedToScalar {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_flStartTime = 0x1C8; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x1CC; // float
    constexpr std::ptrdiff_t m_flInputMin = 0x1D0; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1D4; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D8; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1DC; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x1E0; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bPerParticle = 0x1E4; // bool
}

namespace C_INIT_RemapTransformOrientationToRotations {
    constexpr std::ptrdiff_t m_TransformInput = 0x1C0; // CParticleTransformInput
    constexpr std::ptrdiff_t m_vecRotation = 0x228; // Vector
    constexpr std::ptrdiff_t m_bUseQuat = 0x234; // bool
    constexpr std::ptrdiff_t m_bWriteNormal = 0x235; // bool
}

namespace C_INIT_RemapTransformToVector {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vInputMin = 0x1C4; // Vector
    constexpr std::ptrdiff_t m_vInputMax = 0x1D0; // Vector
    constexpr std::ptrdiff_t m_vOutputMin = 0x1DC; // Vector
    constexpr std::ptrdiff_t m_vOutputMax = 0x1E8; // Vector
    constexpr std::ptrdiff_t m_TransformInput = 0x1F8; // CParticleTransformInput
    constexpr std::ptrdiff_t m_LocalSpaceTransform = 0x260; // CParticleTransformInput
    constexpr std::ptrdiff_t m_flStartTime = 0x2C8; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x2CC; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x2D0; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bOffset = 0x2D4; // bool
    constexpr std::ptrdiff_t m_bAccelerate = 0x2D5; // bool
    constexpr std::ptrdiff_t m_flRemapBias = 0x2D8; // float
}

namespace C_INIT_RingWave {
    constexpr std::ptrdiff_t m_TransformInput = 0x1C0; // CParticleTransformInput
    constexpr std::ptrdiff_t m_flParticlesPerOrbit = 0x228; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flInitialRadius = 0x380; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flThickness = 0x4D8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flInitialSpeedMin = 0x630; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flInitialSpeedMax = 0x788; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flRoll = 0x8E0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flPitch = 0xA38; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flYaw = 0xB90; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_bEvenDistribution = 0xCE8; // bool
    constexpr std::ptrdiff_t m_bXYVelocityOnly = 0xCE9; // bool
}

namespace C_INIT_RtEnvCull {
    constexpr std::ptrdiff_t m_vecTestDir = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_vecTestNormal = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_bUseVelocity = 0x1D8; // bool
    constexpr std::ptrdiff_t m_bCullOnMiss = 0x1D9; // bool
    constexpr std::ptrdiff_t m_bLifeAdjust = 0x1DA; // bool
    constexpr std::ptrdiff_t m_RtEnvName = 0x1DB; // char[128]
    constexpr std::ptrdiff_t m_nRTEnvCP = 0x25C; // int32_t
    constexpr std::ptrdiff_t m_nComponent = 0x260; // int32_t
}

namespace C_INIT_ScaleVelocity {
    constexpr std::ptrdiff_t m_vecScale = 0x1C0; // CParticleCollectionVecInput
}

namespace C_INIT_SequenceFromCP {
    constexpr std::ptrdiff_t m_bKillUnused = 0x1C0; // bool
    constexpr std::ptrdiff_t m_bRadiusScale = 0x1C1; // bool
    constexpr std::ptrdiff_t m_nCP = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_vecOffset = 0x1C8; // Vector
}

namespace C_INIT_SequenceLifeTime {
    constexpr std::ptrdiff_t m_flFramerate = 0x1C0; // float
}

namespace C_INIT_SetHitboxToClosest {
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nDesiredHitbox = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_vecHitBoxScale = 0x1C8; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_HitboxSetName = 0x820; // char[128]
    constexpr std::ptrdiff_t m_bUseBones = 0x8A0; // bool
    constexpr std::ptrdiff_t m_bUseClosestPointOnHitbox = 0x8A1; // bool
    constexpr std::ptrdiff_t m_nTestType = 0x8A4; // ClosestPointTestType_t
    constexpr std::ptrdiff_t m_flHybridRatio = 0x8A8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bUpdatePosition = 0xA00; // bool
}

namespace C_INIT_SetHitboxToModel {
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nForceInModel = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nDesiredHitbox = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_vecHitBoxScale = 0x1D0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_vecDirectionBias = 0x828; // Vector
    constexpr std::ptrdiff_t m_bMaintainHitbox = 0x834; // bool
    constexpr std::ptrdiff_t m_bUseBones = 0x835; // bool
    constexpr std::ptrdiff_t m_HitboxSetName = 0x836; // char[128]
    constexpr std::ptrdiff_t m_flShellSize = 0x8B8; // CParticleCollectionFloatInput
}

namespace C_INIT_SetRigidAttachment {
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bLocalSpace = 0x1CC; // bool
}

namespace C_INIT_SetVectorAttributeToVectorExpression {
    constexpr std::ptrdiff_t m_nExpression = 0x1C0; // VectorExpressionType_t
    constexpr std::ptrdiff_t m_vInput1 = 0x1C8; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vInput2 = 0x820; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_nOutputField = 0xE78; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSetMethod = 0xE7C; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bNormalizedOutput = 0xE80; // bool
}

namespace C_INIT_StatusEffect {
    constexpr std::ptrdiff_t m_nDetail2Combo = 0x1C0; // Detail2Combo_t
    constexpr std::ptrdiff_t m_flDetail2Rotation = 0x1C4; // float
    constexpr std::ptrdiff_t m_flDetail2Scale = 0x1C8; // float
    constexpr std::ptrdiff_t m_flDetail2BlendFactor = 0x1CC; // float
    constexpr std::ptrdiff_t m_flColorWarpIntensity = 0x1D0; // float
    constexpr std::ptrdiff_t m_flDiffuseWarpBlendToFull = 0x1D4; // float
    constexpr std::ptrdiff_t m_flEnvMapIntensity = 0x1D8; // float
    constexpr std::ptrdiff_t m_flAmbientScale = 0x1DC; // float
    constexpr std::ptrdiff_t m_specularColor = 0x1E0; // Color
    constexpr std::ptrdiff_t m_flSpecularScale = 0x1E4; // float
    constexpr std::ptrdiff_t m_flSpecularExponent = 0x1E8; // float
    constexpr std::ptrdiff_t m_flSpecularExponentBlendToFull = 0x1EC; // float
    constexpr std::ptrdiff_t m_flSpecularBlendToFull = 0x1F0; // float
    constexpr std::ptrdiff_t m_rimLightColor = 0x1F4; // Color
    constexpr std::ptrdiff_t m_flRimLightScale = 0x1F8; // float
    constexpr std::ptrdiff_t m_flReflectionsTintByBaseBlendToNone = 0x1FC; // float
    constexpr std::ptrdiff_t m_flMetalnessBlendToFull = 0x200; // float
    constexpr std::ptrdiff_t m_flSelfIllumBlendToFull = 0x204; // float
}

namespace C_INIT_StatusEffectCitadel {
    constexpr std::ptrdiff_t m_flSFXColorWarpAmount = 0x1C0; // float
    constexpr std::ptrdiff_t m_flSFXNormalAmount = 0x1C4; // float
    constexpr std::ptrdiff_t m_flSFXMetalnessAmount = 0x1C8; // float
    constexpr std::ptrdiff_t m_flSFXRoughnessAmount = 0x1CC; // float
    constexpr std::ptrdiff_t m_flSFXSelfIllumAmount = 0x1D0; // float
    constexpr std::ptrdiff_t m_flSFXSScale = 0x1D4; // float
    constexpr std::ptrdiff_t m_flSFXSScrollX = 0x1D8; // float
    constexpr std::ptrdiff_t m_flSFXSScrollY = 0x1DC; // float
    constexpr std::ptrdiff_t m_flSFXSScrollZ = 0x1E0; // float
    constexpr std::ptrdiff_t m_flSFXSOffsetX = 0x1E4; // float
    constexpr std::ptrdiff_t m_flSFXSOffsetY = 0x1E8; // float
    constexpr std::ptrdiff_t m_flSFXSOffsetZ = 0x1EC; // float
    constexpr std::ptrdiff_t m_nDetailCombo = 0x1F0; // DetailCombo_t
    constexpr std::ptrdiff_t m_flSFXSDetailAmount = 0x1F4; // float
    constexpr std::ptrdiff_t m_flSFXSDetailScale = 0x1F8; // float
    constexpr std::ptrdiff_t m_flSFXSDetailScrollX = 0x1FC; // float
    constexpr std::ptrdiff_t m_flSFXSDetailScrollY = 0x200; // float
    constexpr std::ptrdiff_t m_flSFXSDetailScrollZ = 0x204; // float
    constexpr std::ptrdiff_t m_flSFXSUseModelUVs = 0x208; // float
}

namespace C_INIT_VelocityFromCP {
    constexpr std::ptrdiff_t m_velocityInput = 0x1C0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_transformInput = 0x818; // CParticleTransformInput
    constexpr std::ptrdiff_t m_flVelocityScale = 0x880; // float
    constexpr std::ptrdiff_t m_bDirectionOnly = 0x884; // bool
}

namespace C_INIT_VelocityFromNormal {
    constexpr std::ptrdiff_t m_fSpeedMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_fSpeedMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_bIgnoreDt = 0x1C8; // bool
}

namespace C_INIT_VelocityRadialRandom {
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_fSpeedMin = 0x1C4; // float
    constexpr std::ptrdiff_t m_fSpeedMax = 0x1C8; // float
    constexpr std::ptrdiff_t m_vecLocalCoordinateSystemSpeedScale = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_bIgnoreDelta = 0x1D9; // bool
}

namespace C_INIT_VelocityRandom {
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_fSpeedMin = 0x1C8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_fSpeedMax = 0x320; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_LocalCoordinateSystemSpeedMin = 0x478; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_LocalCoordinateSystemSpeedMax = 0xAD0; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_bIgnoreDT = 0x1128; // bool
    constexpr std::ptrdiff_t m_randomnessParameters = 0x112C; // CRandomNumberGeneratorParameters
}

namespace C_OP_AlphaDecay {
    constexpr std::ptrdiff_t m_flMinAlpha = 0x1C0; // float
}

namespace C_OP_AttractToControlPoint {
    constexpr std::ptrdiff_t m_vecComponentScale = 0x1D0; // Vector
    constexpr std::ptrdiff_t m_fForceAmount = 0x1E0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_fFalloffPower = 0x338; // float
    constexpr std::ptrdiff_t m_TransformInput = 0x340; // CParticleTransformInput
    constexpr std::ptrdiff_t m_fForceAmountMin = 0x3A8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_bApplyMinForce = 0x500; // bool
}

namespace C_OP_BasicMovement {
    constexpr std::ptrdiff_t m_Gravity = 0x1C0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_fDrag = 0x818; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nMaxConstraintPasses = 0x970; // int32_t
}

namespace C_OP_BoxConstraint {
    constexpr std::ptrdiff_t m_vecMin = 0x1C0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_vecMax = 0x818; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nCP = 0xE70; // int32_t
    constexpr std::ptrdiff_t m_bLocalSpace = 0xE74; // bool
    constexpr std::ptrdiff_t m_bAccountForRadius = 0xE75; // bool
}

namespace C_OP_CPOffsetToPercentageBetweenCPs {
    constexpr std::ptrdiff_t m_flInputMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_flInputBias = 0x1C8; // float
    constexpr std::ptrdiff_t m_nStartCP = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_nEndCP = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nOffsetCP = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nOuputCP = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_nInputCP = 0x1DC; // int32_t
    constexpr std::ptrdiff_t m_bRadialCheck = 0x1E0; // bool
    constexpr std::ptrdiff_t m_bScaleOffset = 0x1E1; // bool
    constexpr std::ptrdiff_t m_vecOffset = 0x1E4; // Vector
}

namespace C_OP_CPVelocityForce {
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_flScale = 0x1D8; // CPerParticleFloatInput
}

namespace C_OP_CalculateVectorAttribute {
    constexpr std::ptrdiff_t m_vStartValue = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_nFieldInput1 = 0x1CC; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputScale1 = 0x1D0; // float
    constexpr std::ptrdiff_t m_nFieldInput2 = 0x1D4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputScale2 = 0x1D8; // float
    constexpr std::ptrdiff_t m_nControlPointInput1 = 0x1DC; // ControlPointReference_t
    constexpr std::ptrdiff_t m_flControlPointScale1 = 0x1F0; // float
    constexpr std::ptrdiff_t m_nControlPointInput2 = 0x1F4; // ControlPointReference_t
    constexpr std::ptrdiff_t m_flControlPointScale2 = 0x208; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x20C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vFinalOutputScale = 0x210; // Vector
}

namespace C_OP_ChladniWave {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flInputMax = 0x320; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMin = 0x478; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMax = 0x5D0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_vecWaveLength = 0x728; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecHarmonics = 0xD80; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_nSetMethod = 0x13D8; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_nLocalSpaceControlPoint = 0x13DC; // int32_t
    constexpr std::ptrdiff_t m_b3D = 0x13E0; // bool
}

namespace C_OP_ChooseRandomChildrenInGroup {
    constexpr std::ptrdiff_t m_nChildGroupID = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_flNumberOfChildren = 0x1D8; // CParticleCollectionFloatInput
}

namespace C_OP_ClampScalar {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flOutputMin = 0x1C8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMax = 0x320; // CPerParticleFloatInput
}

namespace C_OP_ClampVector {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vecOutputMin = 0x1C8; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecOutputMax = 0x820; // CPerParticleVecInput
}

namespace C_OP_CollideWithParentParticles {
    constexpr std::ptrdiff_t m_flParentRadiusScale = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flRadiusScale = 0x318; // CPerParticleFloatInput
}

namespace C_OP_CollideWithSelf {
    constexpr std::ptrdiff_t m_flRadiusScale = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flMinimumSpeed = 0x318; // CPerParticleFloatInput
}

namespace C_OP_ColorAdjustHSL {
    constexpr std::ptrdiff_t m_flHueAdjust = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flSaturationAdjust = 0x318; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flLightnessAdjust = 0x470; // CPerParticleFloatInput
}

namespace C_OP_ColorInterpolate {
    constexpr std::ptrdiff_t m_ColorFade = 0x1C0; // Color
    constexpr std::ptrdiff_t m_flFadeStartTime = 0x1D0; // float
    constexpr std::ptrdiff_t m_flFadeEndTime = 0x1D4; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1D8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bEaseInOut = 0x1DC; // bool
    constexpr std::ptrdiff_t m_bUseNewCode = 0x1DD; // bool
}

namespace C_OP_ColorInterpolateRandom {
    constexpr std::ptrdiff_t m_ColorFadeMin = 0x1C0; // Color
    constexpr std::ptrdiff_t m_ColorFadeMax = 0x1DC; // Color
    constexpr std::ptrdiff_t m_flFadeStartTime = 0x1EC; // float
    constexpr std::ptrdiff_t m_flFadeEndTime = 0x1F0; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1F4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bEaseInOut = 0x1F8; // bool
}

namespace C_OP_ConnectParentParticleToNearest {
    constexpr std::ptrdiff_t m_nFirstControlPoint = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nSecondControlPoint = 0x1C4; // int32_t
}

namespace C_OP_ConstrainDistance {
    constexpr std::ptrdiff_t m_fMinDistance = 0x1C0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_fMaxDistance = 0x318; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x470; // int32_t
    constexpr std::ptrdiff_t m_CenterOffset = 0x474; // Vector
    constexpr std::ptrdiff_t m_bGlobalCenter = 0x480; // bool
}

namespace C_OP_ConstrainDistanceToPath {
    constexpr std::ptrdiff_t m_fMinDistance = 0x1C0; // float
    constexpr std::ptrdiff_t m_flMaxDistance0 = 0x1C4; // float
    constexpr std::ptrdiff_t m_flMaxDistanceMid = 0x1C8; // float
    constexpr std::ptrdiff_t m_flMaxDistance1 = 0x1CC; // float
    constexpr std::ptrdiff_t m_PathParameters = 0x1D0; // CPathParameters
    constexpr std::ptrdiff_t m_flTravelTime = 0x210; // float
    constexpr std::ptrdiff_t m_nFieldScale = 0x214; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nManualTField = 0x218; // ParticleAttributeIndex_t
}

namespace C_OP_ConstrainDistanceToUserSpecifiedPath {
    constexpr std::ptrdiff_t m_fMinDistance = 0x1C0; // float
    constexpr std::ptrdiff_t m_flMaxDistance = 0x1C4; // float
    constexpr std::ptrdiff_t m_flTimeScale = 0x1C8; // float
    constexpr std::ptrdiff_t m_bLoopedPath = 0x1CC; // bool
    constexpr std::ptrdiff_t m_pointList = 0x1D0; // CUtlVector<PointDefinitionWithTimeValues_t>
}

namespace C_OP_ConstrainLineLength {
    constexpr std::ptrdiff_t m_flMinDistance = 0x1C0; // float
    constexpr std::ptrdiff_t m_flMaxDistance = 0x1C4; // float
}

namespace C_OP_ContinuousEmitter {
    constexpr std::ptrdiff_t m_flEmissionDuration = 0x1C0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flStartTime = 0x318; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flEmitRate = 0x470; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flEmissionScale = 0x5C8; // float
    constexpr std::ptrdiff_t m_flScalePerParentParticle = 0x5CC; // float
    constexpr std::ptrdiff_t m_bInitFromKilledParentParticles = 0x5D0; // bool
    constexpr std::ptrdiff_t m_nSnapshotControlPoint = 0x5D4; // int32_t
    constexpr std::ptrdiff_t m_nLimitPerUpdate = 0x5D8; // int32_t
    constexpr std::ptrdiff_t m_bForceEmitOnFirstUpdate = 0x5DC; // bool
    constexpr std::ptrdiff_t m_bForceEmitOnLastUpdate = 0x5DD; // bool
}

namespace C_OP_ControlPointToRadialScreenSpace {
    constexpr std::ptrdiff_t m_nCPIn = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_vecCP1Pos = 0x1D4; // Vector
    constexpr std::ptrdiff_t m_nCPOut = 0x1E0; // int32_t
    constexpr std::ptrdiff_t m_nCPOutField = 0x1E4; // int32_t
    constexpr std::ptrdiff_t m_nCPSSPosOut = 0x1E8; // int32_t
}

namespace C_OP_ControlpointLight {
    constexpr std::ptrdiff_t m_flScale = 0x1C0; // float
    constexpr std::ptrdiff_t m_nControlPoint1 = 0x650; // int32_t
    constexpr std::ptrdiff_t m_nControlPoint2 = 0x654; // int32_t
    constexpr std::ptrdiff_t m_nControlPoint3 = 0x658; // int32_t
    constexpr std::ptrdiff_t m_nControlPoint4 = 0x65C; // int32_t
    constexpr std::ptrdiff_t m_vecCPOffset1 = 0x660; // Vector
    constexpr std::ptrdiff_t m_vecCPOffset2 = 0x66C; // Vector
    constexpr std::ptrdiff_t m_vecCPOffset3 = 0x678; // Vector
    constexpr std::ptrdiff_t m_vecCPOffset4 = 0x684; // Vector
    constexpr std::ptrdiff_t m_LightFiftyDist1 = 0x690; // float
    constexpr std::ptrdiff_t m_LightZeroDist1 = 0x694; // float
    constexpr std::ptrdiff_t m_LightFiftyDist2 = 0x698; // float
    constexpr std::ptrdiff_t m_LightZeroDist2 = 0x69C; // float
    constexpr std::ptrdiff_t m_LightFiftyDist3 = 0x6A0; // float
    constexpr std::ptrdiff_t m_LightZeroDist3 = 0x6A4; // float
    constexpr std::ptrdiff_t m_LightFiftyDist4 = 0x6A8; // float
    constexpr std::ptrdiff_t m_LightZeroDist4 = 0x6AC; // float
    constexpr std::ptrdiff_t m_LightColor1 = 0x6B0; // Color
    constexpr std::ptrdiff_t m_LightColor2 = 0x6B4; // Color
    constexpr std::ptrdiff_t m_LightColor3 = 0x6B8; // Color
    constexpr std::ptrdiff_t m_LightColor4 = 0x6BC; // Color
    constexpr std::ptrdiff_t m_bLightType1 = 0x6C0; // bool
    constexpr std::ptrdiff_t m_bLightType2 = 0x6C1; // bool
    constexpr std::ptrdiff_t m_bLightType3 = 0x6C2; // bool
    constexpr std::ptrdiff_t m_bLightType4 = 0x6C3; // bool
    constexpr std::ptrdiff_t m_bLightDynamic1 = 0x6C4; // bool
    constexpr std::ptrdiff_t m_bLightDynamic2 = 0x6C5; // bool
    constexpr std::ptrdiff_t m_bLightDynamic3 = 0x6C6; // bool
    constexpr std::ptrdiff_t m_bLightDynamic4 = 0x6C7; // bool
    constexpr std::ptrdiff_t m_bUseNormal = 0x6C8; // bool
    constexpr std::ptrdiff_t m_bUseHLambert = 0x6C9; // bool
    constexpr std::ptrdiff_t m_bClampLowerRange = 0x6CE; // bool
    constexpr std::ptrdiff_t m_bClampUpperRange = 0x6CF; // bool
}

namespace C_OP_Cull {
    constexpr std::ptrdiff_t m_flCullPerc = 0x1C0; // float
    constexpr std::ptrdiff_t m_flCullStart = 0x1C4; // float
    constexpr std::ptrdiff_t m_flCullEnd = 0x1C8; // float
    constexpr std::ptrdiff_t m_flCullExp = 0x1CC; // float
}

namespace C_OP_CurlNoiseForce {
    constexpr std::ptrdiff_t m_nNoiseType = 0x1D0; // ParticleDirectionNoiseType_t
    constexpr std::ptrdiff_t m_vecNoiseFreq = 0x1D8; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecNoiseScale = 0x830; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecOffset = 0xE88; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecOffsetRate = 0x14E0; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_flWorleySeed = 0x1B38; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flWorleyJitter = 0x1C90; // CPerParticleFloatInput
}

namespace C_OP_CycleScalar {
    constexpr std::ptrdiff_t m_nDestField = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flStartValue = 0x1C4; // float
    constexpr std::ptrdiff_t m_flEndValue = 0x1C8; // float
    constexpr std::ptrdiff_t m_flCycleTime = 0x1CC; // float
    constexpr std::ptrdiff_t m_bDoNotRepeatCycle = 0x1D0; // bool
    constexpr std::ptrdiff_t m_bSynchronizeParticles = 0x1D1; // bool
    constexpr std::ptrdiff_t m_nCPScale = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nCPFieldMin = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_nCPFieldMax = 0x1DC; // int32_t
    constexpr std::ptrdiff_t m_nSetMethod = 0x1E0; // ParticleSetMethod_t
}

namespace C_OP_CylindricalDistanceToTransform {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flInputMax = 0x320; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMin = 0x478; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMax = 0x5D0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_TransformStart = 0x728; // CParticleTransformInput
    constexpr std::ptrdiff_t m_TransformEnd = 0x790; // CParticleTransformInput
    constexpr std::ptrdiff_t m_nSetMethod = 0x7F8; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bActiveRange = 0x7FC; // bool
    constexpr std::ptrdiff_t m_bAdditive = 0x7FD; // bool
    constexpr std::ptrdiff_t m_bCapsule = 0x7FE; // bool
}

namespace C_OP_DampenToCP {
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_flRange = 0x1C4; // float
    constexpr std::ptrdiff_t m_flScale = 0x1C8; // float
}

namespace C_OP_Decay {
    constexpr std::ptrdiff_t m_bRopeDecay = 0x1C0; // bool
    constexpr std::ptrdiff_t m_bForcePreserveParticleOrder = 0x1C1; // bool
}

namespace C_OP_DecayClampCount {
    constexpr std::ptrdiff_t m_nCount = 0x1C0; // CParticleCollectionFloatInput
}

namespace C_OP_DecayMaintainCount {
    constexpr std::ptrdiff_t m_nParticlesToMaintain = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_flDecayDelay = 0x1C4; // float
    constexpr std::ptrdiff_t m_nSnapshotControlPoint = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_bLifespanDecay = 0x1CC; // bool
    constexpr std::ptrdiff_t m_flScale = 0x1D0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bKillNewest = 0x328; // bool
}

namespace C_OP_DecayOffscreen {
    constexpr std::ptrdiff_t m_flOffscreenTime = 0x1C0; // CParticleCollectionFloatInput
}

namespace C_OP_DensityForce {
    constexpr std::ptrdiff_t m_flRadiusScale = 0x1D0; // float
    constexpr std::ptrdiff_t m_flForceScale = 0x1D4; // float
    constexpr std::ptrdiff_t m_flTargetDensity = 0x1D8; // float
}

namespace C_OP_DifferencePreviousParticle {
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C8; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1CC; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D4; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x1D8; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bActiveRange = 0x1DC; // bool
    constexpr std::ptrdiff_t m_bSetPreviousParticle = 0x1DD; // bool
}

namespace C_OP_Diffusion {
    constexpr std::ptrdiff_t m_flRadiusScale = 0x1C0; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nVoxelGridResolution = 0x1C8; // int32_t
}

namespace C_OP_DirectionBetweenVecsToVec {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vecPoint1 = 0x1C8; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecPoint2 = 0x820; // CPerParticleVecInput
}

namespace C_OP_DistanceBetweenCPsToCP {
    constexpr std::ptrdiff_t m_nStartCP = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nEndCP = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nOutputCP = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_nOutputCPField = 0x1DC; // int32_t
    constexpr std::ptrdiff_t m_bSetOnce = 0x1E0; // bool
    constexpr std::ptrdiff_t m_flInputMin = 0x1E4; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1E8; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1EC; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1F0; // float
    constexpr std::ptrdiff_t m_flMaxTraceLength = 0x1F4; // float
    constexpr std::ptrdiff_t m_flLOSScale = 0x1F8; // float
    constexpr std::ptrdiff_t m_bLOS = 0x1FC; // bool
    constexpr std::ptrdiff_t m_CollisionGroupName = 0x1FD; // char[128]
    constexpr std::ptrdiff_t m_nTraceSet = 0x280; // ParticleTraceSet_t
    constexpr std::ptrdiff_t m_nSetParent = 0x284; // ParticleParentSetMode_t
}

namespace C_OP_DistanceBetweenTransforms {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_TransformStart = 0x1C8; // CParticleTransformInput
    constexpr std::ptrdiff_t m_TransformEnd = 0x230; // CParticleTransformInput
    constexpr std::ptrdiff_t m_flInputMin = 0x298; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flInputMax = 0x3F0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMin = 0x548; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMax = 0x6A0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flMaxTraceLength = 0x7F8; // float
    constexpr std::ptrdiff_t m_flLOSScale = 0x7FC; // float
    constexpr std::ptrdiff_t m_CollisionGroupName = 0x800; // char[128]
    constexpr std::ptrdiff_t m_nTraceSet = 0x880; // ParticleTraceSet_t
    constexpr std::ptrdiff_t m_bLOS = 0x884; // bool
    constexpr std::ptrdiff_t m_nSetMethod = 0x888; // ParticleSetMethod_t
}

namespace C_OP_DistanceBetweenVecs {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vecPoint1 = 0x1C8; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecPoint2 = 0x820; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_flInputMin = 0xE78; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flInputMax = 0xFD0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMin = 0x1128; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMax = 0x1280; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nSetMethod = 0x13D8; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bDeltaTime = 0x13DC; // bool
}

namespace C_OP_DistanceCull {
    constexpr std::ptrdiff_t m_nControlPoint = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_vecPointOffset = 0x1C4; // Vector
    constexpr std::ptrdiff_t m_flDistance = 0x1D0; // float
    constexpr std::ptrdiff_t m_bCullInside = 0x1D4; // bool
}

namespace C_OP_DistanceToTransform {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flInputMax = 0x320; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMin = 0x478; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMax = 0x5D0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_TransformStart = 0x728; // CParticleTransformInput
    constexpr std::ptrdiff_t m_bLOS = 0x790; // bool
    constexpr std::ptrdiff_t m_CollisionGroupName = 0x791; // char[128]
    constexpr std::ptrdiff_t m_nTraceSet = 0x814; // ParticleTraceSet_t
    constexpr std::ptrdiff_t m_flMaxTraceLength = 0x818; // float
    constexpr std::ptrdiff_t m_flLOSScale = 0x81C; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x820; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bActiveRange = 0x824; // bool
    constexpr std::ptrdiff_t m_bAdditive = 0x825; // bool
    constexpr std::ptrdiff_t m_vecComponentScale = 0x828; // CPerParticleVecInput
}

namespace C_OP_DragRelativeToPlane {
    constexpr std::ptrdiff_t m_flDragAtPlane = 0x1C0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flFalloff = 0x318; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bDirectional = 0x470; // bool
    constexpr std::ptrdiff_t m_vecPlaneNormal = 0x478; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nControlPointNumber = 0xAD0; // int32_t
}

namespace C_OP_DriveCPFromGlobalSoundFloat {
    constexpr std::ptrdiff_t m_nOutputControlPoint = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nOutputField = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1D8; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1DC; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1E0; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1E4; // float
    constexpr std::ptrdiff_t m_StackName = 0x1E8; // CUtlString
    constexpr std::ptrdiff_t m_OperatorName = 0x1F0; // CUtlString
    constexpr std::ptrdiff_t m_FieldName = 0x1F8; // CUtlString
}

namespace C_OP_EnableChildrenFromParentParticleCount {
    constexpr std::ptrdiff_t m_nChildGroupID = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nFirstChild = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nNumChildrenToEnable = 0x1D8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bDisableChildren = 0x330; // bool
    constexpr std::ptrdiff_t m_bPlayEndcapOnStop = 0x331; // bool
    constexpr std::ptrdiff_t m_bDestroyImmediately = 0x332; // bool
}

namespace C_OP_EndCapTimedDecay {
    constexpr std::ptrdiff_t m_flDecayTime = 0x1C0; // float
}

namespace C_OP_EndCapTimedFreeze {
    constexpr std::ptrdiff_t m_flFreezeTime = 0x1C0; // CParticleCollectionFloatInput
}

namespace C_OP_ExternalGameImpulseForce {
    constexpr std::ptrdiff_t m_flForceScale = 0x1D0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_bRopes = 0x328; // bool
    constexpr std::ptrdiff_t m_bRopesZOnly = 0x329; // bool
    constexpr std::ptrdiff_t m_bExplosions = 0x32A; // bool
    constexpr std::ptrdiff_t m_bParticles = 0x32B; // bool
}

namespace C_OP_ExternalWindForce {
    constexpr std::ptrdiff_t m_vecSamplePosition = 0x1D0; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecScale = 0x828; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_bSampleWind = 0xE80; // bool
    constexpr std::ptrdiff_t m_bSampleWater = 0xE81; // bool
    constexpr std::ptrdiff_t m_bDampenNearWaterPlane = 0xE82; // bool
    constexpr std::ptrdiff_t m_bSampleGravity = 0xE83; // bool
    constexpr std::ptrdiff_t m_vecGravityForce = 0xE88; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_bUseBasicMovementGravity = 0x14E0; // bool
    constexpr std::ptrdiff_t m_flLocalGravityScale = 0x14E8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flLocalBuoyancyScale = 0x1640; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_vecBuoyancyForce = 0x1798; // CPerParticleVecInput
}

namespace C_OP_FadeAndKill {
    constexpr std::ptrdiff_t m_flStartFadeInTime = 0x1C0; // float
    constexpr std::ptrdiff_t m_flEndFadeInTime = 0x1C4; // float
    constexpr std::ptrdiff_t m_flStartFadeOutTime = 0x1C8; // float
    constexpr std::ptrdiff_t m_flEndFadeOutTime = 0x1CC; // float
    constexpr std::ptrdiff_t m_flStartAlpha = 0x1D0; // float
    constexpr std::ptrdiff_t m_flEndAlpha = 0x1D4; // float
    constexpr std::ptrdiff_t m_bForcePreserveParticleOrder = 0x1D8; // bool
}

namespace C_OP_FadeAndKillForTracers {
    constexpr std::ptrdiff_t m_flStartFadeInTime = 0x1C0; // float
    constexpr std::ptrdiff_t m_flEndFadeInTime = 0x1C4; // float
    constexpr std::ptrdiff_t m_flStartFadeOutTime = 0x1C8; // float
    constexpr std::ptrdiff_t m_flEndFadeOutTime = 0x1CC; // float
    constexpr std::ptrdiff_t m_flStartAlpha = 0x1D0; // float
    constexpr std::ptrdiff_t m_flEndAlpha = 0x1D4; // float
}

namespace C_OP_FadeIn {
    constexpr std::ptrdiff_t m_flFadeInTimeMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_flFadeInTimeMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_flFadeInTimeExp = 0x1C8; // float
    constexpr std::ptrdiff_t m_bProportional = 0x1CC; // bool
}

namespace C_OP_FadeInSimple {
    constexpr std::ptrdiff_t m_flFadeInTime = 0x1C0; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
}

namespace C_OP_FadeOut {
    constexpr std::ptrdiff_t m_flFadeOutTimeMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_flFadeOutTimeMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_flFadeOutTimeExp = 0x1C8; // float
    constexpr std::ptrdiff_t m_flFadeBias = 0x1CC; // float
    constexpr std::ptrdiff_t m_bProportional = 0x200; // bool
    constexpr std::ptrdiff_t m_bEaseInAndOut = 0x201; // bool
}

namespace C_OP_FadeOutSimple {
    constexpr std::ptrdiff_t m_flFadeOutTime = 0x1C0; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
}

namespace C_OP_ForceBasedOnDistanceToPlane {
    constexpr std::ptrdiff_t m_flMinDist = 0x1D0; // float
    constexpr std::ptrdiff_t m_vecForceAtMinDist = 0x1D4; // Vector
    constexpr std::ptrdiff_t m_flMaxDist = 0x1E0; // float
    constexpr std::ptrdiff_t m_vecForceAtMaxDist = 0x1E4; // Vector
    constexpr std::ptrdiff_t m_vecPlaneNormal = 0x1F0; // Vector
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1FC; // int32_t
    constexpr std::ptrdiff_t m_flExponent = 0x200; // float
}

namespace C_OP_ForceControlPointStub {
    constexpr std::ptrdiff_t m_ControlPoint = 0x1D0; // int32_t
}

namespace C_OP_GlobalLight {
    constexpr std::ptrdiff_t m_flScale = 0x1C0; // float
    constexpr std::ptrdiff_t m_bClampLowerRange = 0x1C4; // bool
    constexpr std::ptrdiff_t m_bClampUpperRange = 0x1C5; // bool
}

namespace C_OP_HSVShiftToCP {
    constexpr std::ptrdiff_t m_nColorCP = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nColorGemEnableCP = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nOutputCP = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_DefaultHSVColor = 0x1DC; // Color
}

namespace C_OP_InheritFromParentParticles {
    constexpr std::ptrdiff_t m_flScale = 0x1C0; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nIncrement = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_bRandomDistribution = 0x1CC; // bool
}

namespace C_OP_InheritFromParentParticlesV2 {
    constexpr std::ptrdiff_t m_flScale = 0x1C0; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nIncrement = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_bRandomDistribution = 0x1CC; // bool
    constexpr std::ptrdiff_t m_nMissingParentBehavior = 0x1D0; // MissingParentInheritBehavior_t
}

namespace C_OP_InheritFromPeerSystem {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nIncrement = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nGroupID = 0x1CC; // int32_t
}

namespace C_OP_InstantaneousEmitter {
    constexpr std::ptrdiff_t m_nParticlesToEmit = 0x1C0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flStartTime = 0x318; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flInitFromKilledParentParticles = 0x470; // float
    constexpr std::ptrdiff_t m_flParentParticleScale = 0x478; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nMaxEmittedPerFrame = 0x5D0; // int32_t
    constexpr std::ptrdiff_t m_nSnapshotControlPoint = 0x5D4; // int32_t
}

namespace C_OP_InterpolateRadius {
    constexpr std::ptrdiff_t m_flStartTime = 0x1C0; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x1C4; // float
    constexpr std::ptrdiff_t m_flStartScale = 0x1C8; // float
    constexpr std::ptrdiff_t m_flEndScale = 0x1CC; // float
    constexpr std::ptrdiff_t m_bEaseInAndOut = 0x1D0; // bool
    constexpr std::ptrdiff_t m_flBias = 0x1D4; // float
}

namespace C_OP_LagCompensation {
    constexpr std::ptrdiff_t m_nDesiredVelocityCP = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nLatencyCP = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nLatencyCPField = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nDesiredVelocityCPField = 0x1CC; // int32_t
}

namespace C_OP_LerpEndCapScalar {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flOutput = 0x1C4; // float
    constexpr std::ptrdiff_t m_flLerpTime = 0x1C8; // float
}

namespace C_OP_LerpEndCapVector {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vecOutput = 0x1C4; // Vector
    constexpr std::ptrdiff_t m_flLerpTime = 0x1D0; // float
}

namespace C_OP_LerpScalar {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flOutput = 0x1C8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flStartTime = 0x320; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x324; // float
}

namespace C_OP_LerpToInitialPosition {
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_flInterpolation = 0x1C8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nCacheField = 0x320; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flScale = 0x328; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_vecScale = 0x480; // CParticleCollectionVecInput
}

namespace C_OP_LerpToOtherAttribute {
    constexpr std::ptrdiff_t m_flInterpolation = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nFieldInputFrom = 0x318; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldInput = 0x31C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x320; // ParticleAttributeIndex_t
}

namespace C_OP_LerpVector {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vecOutput = 0x1C4; // Vector
    constexpr std::ptrdiff_t m_flStartTime = 0x1D0; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x1D4; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x1D8; // ParticleSetMethod_t
}

namespace C_OP_LightningSnapshotGenerator {
    constexpr std::ptrdiff_t m_nCPSnapshot = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nCPStartPnt = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nCPEndPnt = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_flSegments = 0x1E0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flOffset = 0x338; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flOffsetDecay = 0x490; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flRecalcRate = 0x5E8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flUVScale = 0x740; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flUVOffset = 0x898; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flSplitRate = 0x9F0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flBranchTwist = 0xB48; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nBranchBehavior = 0xCA0; // ParticleLightnintBranchBehavior_t
    constexpr std::ptrdiff_t m_flRadiusStart = 0xCA8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flRadiusEnd = 0xE00; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flDedicatedPool = 0xF58; // CParticleCollectionFloatInput
}

namespace C_OP_LocalAccelerationForce {
    constexpr std::ptrdiff_t m_nCP = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nScaleCP = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_vecAccel = 0x1D8; // CParticleCollectionVecInput
}

namespace C_OP_LockPoints {
    constexpr std::ptrdiff_t m_nMinCol = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nMaxCol = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nMinRow = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nMaxRow = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_nControlPoint = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_flBlendValue = 0x1D4; // float
}

namespace C_OP_LockToBone {
    constexpr std::ptrdiff_t m_modelInput = 0x1C0; // CParticleModelInput
    constexpr std::ptrdiff_t m_transformInput = 0x220; // CParticleTransformInput
    constexpr std::ptrdiff_t m_flLifeTimeFadeStart = 0x288; // float
    constexpr std::ptrdiff_t m_flLifeTimeFadeEnd = 0x28C; // float
    constexpr std::ptrdiff_t m_flJumpThreshold = 0x290; // float
    constexpr std::ptrdiff_t m_flPrevPosScale = 0x294; // float
    constexpr std::ptrdiff_t m_HitboxSetName = 0x298; // char[128]
    constexpr std::ptrdiff_t m_bRigid = 0x318; // bool
    constexpr std::ptrdiff_t m_bUseBones = 0x319; // bool
    constexpr std::ptrdiff_t m_nFieldOutput = 0x31C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutputPrev = 0x320; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nRotationSetType = 0x324; // ParticleRotationLockType_t
    constexpr std::ptrdiff_t m_bRigidRotationLock = 0x328; // bool
    constexpr std::ptrdiff_t m_vecRotation = 0x330; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_flRotLerp = 0x988; // CPerParticleFloatInput
}

namespace C_OP_LockToPointList {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_pointList = 0x1C8; // CUtlVector<PointDefinition_t>
    constexpr std::ptrdiff_t m_bPlaceAlongPath = 0x1E0; // bool
    constexpr std::ptrdiff_t m_bClosedLoop = 0x1E1; // bool
    constexpr std::ptrdiff_t m_nNumPointsAlongPath = 0x1E4; // int32_t
}

namespace C_OP_LockToSavedSequentialPath {
    constexpr std::ptrdiff_t m_flFadeStart = 0x1C4; // float
    constexpr std::ptrdiff_t m_flFadeEnd = 0x1C8; // float
    constexpr std::ptrdiff_t m_bCPPairs = 0x1CC; // bool
    constexpr std::ptrdiff_t m_PathParams = 0x1D0; // CPathParameters
}

namespace C_OP_LockToSavedSequentialPathV2 {
    constexpr std::ptrdiff_t m_flFadeStart = 0x1C0; // float
    constexpr std::ptrdiff_t m_flFadeEnd = 0x1C4; // float
    constexpr std::ptrdiff_t m_bCPPairs = 0x1C8; // bool
    constexpr std::ptrdiff_t m_PathParams = 0x1D0; // CPathParameters
}

namespace C_OP_MaintainEmitter {
    constexpr std::ptrdiff_t m_nParticlesToMaintain = 0x1C0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flStartTime = 0x318; // float
    constexpr std::ptrdiff_t m_flEmissionDuration = 0x320; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flEmissionRate = 0x478; // float
    constexpr std::ptrdiff_t m_nSnapshotControlPoint = 0x47C; // int32_t
    constexpr std::ptrdiff_t m_bEmitInstantaneously = 0x480; // bool
    constexpr std::ptrdiff_t m_bFinalEmitOnStop = 0x481; // bool
    constexpr std::ptrdiff_t m_flScale = 0x488; // CParticleCollectionFloatInput
}

namespace C_OP_MaintainSequentialPath {
    constexpr std::ptrdiff_t m_fMaxDistance = 0x1C0; // float
    constexpr std::ptrdiff_t m_flNumToAssign = 0x1C4; // float
    constexpr std::ptrdiff_t m_flCohesionStrength = 0x1C8; // float
    constexpr std::ptrdiff_t m_flTolerance = 0x1CC; // float
    constexpr std::ptrdiff_t m_bLoop = 0x1D0; // bool
    constexpr std::ptrdiff_t m_bUseParticleCount = 0x1D1; // bool
    constexpr std::ptrdiff_t m_PathParams = 0x1E0; // CPathParameters
}

namespace C_OP_MaxVelocity {
    constexpr std::ptrdiff_t m_flMaxVelocity = 0x1C0; // float
    constexpr std::ptrdiff_t m_flMinVelocity = 0x1C4; // float
    constexpr std::ptrdiff_t m_nOverrideCP = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nOverrideCPField = 0x1CC; // int32_t
}

namespace C_OP_ModelCull {
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_bBoundBox = 0x1C4; // bool
    constexpr std::ptrdiff_t m_bCullOutside = 0x1C5; // bool
    constexpr std::ptrdiff_t m_bUseBones = 0x1C6; // bool
    constexpr std::ptrdiff_t m_HitboxSetName = 0x1C7; // char[128]
}

namespace C_OP_ModelDampenMovement {
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_bBoundBox = 0x1C4; // bool
    constexpr std::ptrdiff_t m_bOutside = 0x1C5; // bool
    constexpr std::ptrdiff_t m_bUseBones = 0x1C6; // bool
    constexpr std::ptrdiff_t m_HitboxSetName = 0x1C7; // char[128]
    constexpr std::ptrdiff_t m_vecPosOffset = 0x248; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_fDrag = 0x8A0; // float
}

namespace C_OP_MoveToHitbox {
    constexpr std::ptrdiff_t m_modelInput = 0x1C0; // CParticleModelInput
    constexpr std::ptrdiff_t m_transformInput = 0x220; // CParticleTransformInput
    constexpr std::ptrdiff_t m_flLifeTimeLerpStart = 0x28C; // float
    constexpr std::ptrdiff_t m_flLifeTimeLerpEnd = 0x290; // float
    constexpr std::ptrdiff_t m_flPrevPosScale = 0x294; // float
    constexpr std::ptrdiff_t m_HitboxSetName = 0x298; // char[128]
    constexpr std::ptrdiff_t m_bUseBones = 0x318; // bool
    constexpr std::ptrdiff_t m_nLerpType = 0x31C; // HitboxLerpType_t
    constexpr std::ptrdiff_t m_flInterpolation = 0x320; // CPerParticleFloatInput
}

namespace C_OP_MovementLoopInsideSphere {
    constexpr std::ptrdiff_t m_nCP = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_flDistance = 0x1C8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_vecScale = 0x320; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nDistSqrAttr = 0x978; // ParticleAttributeIndex_t
}

namespace C_OP_MovementMaintainOffset {
    constexpr std::ptrdiff_t m_vecOffset = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_nCP = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_bRadiusScale = 0x1D0; // bool
}

namespace C_OP_MovementMoveAlongSkinnedCPSnapshot {
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nSnapshotControlPointNumber = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_bSetNormal = 0x1C8; // bool
    constexpr std::ptrdiff_t m_bSetRadius = 0x1C9; // bool
    constexpr std::ptrdiff_t m_flInterpolation = 0x1D0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flTValue = 0x328; // CPerParticleFloatInput
}

namespace C_OP_MovementPlaceOnGround {
    constexpr std::ptrdiff_t m_flOffset = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flMaxTraceLength = 0x318; // float
    constexpr std::ptrdiff_t m_flTolerance = 0x31C; // float
    constexpr std::ptrdiff_t m_flTraceOffset = 0x320; // float
    constexpr std::ptrdiff_t m_flLerpRate = 0x324; // float
    constexpr std::ptrdiff_t m_CollisionGroupName = 0x328; // char[128]
    constexpr std::ptrdiff_t m_nTraceSet = 0x3A8; // ParticleTraceSet_t
    constexpr std::ptrdiff_t m_nRefCP1 = 0x3AC; // int32_t
    constexpr std::ptrdiff_t m_nRefCP2 = 0x3B0; // int32_t
    constexpr std::ptrdiff_t m_nLerpCP = 0x3B4; // int32_t
    constexpr std::ptrdiff_t m_nTraceMissBehavior = 0x3C0; // ParticleTraceMissBehavior_t
    constexpr std::ptrdiff_t m_bIncludeShotHull = 0x3C4; // bool
    constexpr std::ptrdiff_t m_bIncludeWater = 0x3C5; // bool
    constexpr std::ptrdiff_t m_bSetNormal = 0x3C8; // bool
    constexpr std::ptrdiff_t m_bScaleOffset = 0x3C9; // bool
    constexpr std::ptrdiff_t m_nPreserveOffsetCP = 0x3CC; // int32_t
    constexpr std::ptrdiff_t m_nIgnoreCP = 0x3D0; // int32_t
}

namespace C_OP_MovementRigidAttachToCP {
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nScaleControlPoint = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nScaleCPField = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nFieldInput = 0x1CC; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1D0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bOffsetLocal = 0x1D4; // bool
}

namespace C_OP_MovementRotateParticleAroundAxis {
    constexpr std::ptrdiff_t m_vecRotAxis = 0x1C0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_flRotRate = 0x818; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_TransformInput = 0x970; // CParticleTransformInput
    constexpr std::ptrdiff_t m_bLocalSpace = 0x9D8; // bool
}

namespace C_OP_MovementSkinnedPositionFromCPSnapshot {
    constexpr std::ptrdiff_t m_nSnapshotControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_bRandom = 0x1C8; // bool
    constexpr std::ptrdiff_t m_nRandomSeed = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_bSetNormal = 0x1D0; // bool
    constexpr std::ptrdiff_t m_bSetRadius = 0x1D1; // bool
    constexpr std::ptrdiff_t m_flIncrement = 0x1D8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nFullLoopIncrement = 0x330; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nSnapShotStartPoint = 0x488; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flInterpolation = 0x5E0; // CPerParticleFloatInput
}

namespace C_OP_Noise {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flOutputMin = 0x1C4; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1C8; // float
    constexpr std::ptrdiff_t m_fl4NoiseScale = 0x1CC; // float
    constexpr std::ptrdiff_t m_bAdditive = 0x1D0; // bool
    constexpr std::ptrdiff_t m_flNoiseAnimationTimeScale = 0x1D4; // float
}

namespace C_OP_NoiseEmitter {
    constexpr std::ptrdiff_t m_flEmissionDuration = 0x1C0; // float
    constexpr std::ptrdiff_t m_flStartTime = 0x1C4; // float
    constexpr std::ptrdiff_t m_flEmissionScale = 0x1C8; // float
    constexpr std::ptrdiff_t m_nScaleControlPoint = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_nScaleControlPointField = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nWorldNoisePoint = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_bAbsVal = 0x1D8; // bool
    constexpr std::ptrdiff_t m_bAbsValInv = 0x1D9; // bool
    constexpr std::ptrdiff_t m_flOffset = 0x1DC; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1E0; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1E4; // float
    constexpr std::ptrdiff_t m_flNoiseScale = 0x1E8; // float
    constexpr std::ptrdiff_t m_flWorldNoiseScale = 0x1EC; // float
    constexpr std::ptrdiff_t m_vecOffsetLoc = 0x1F0; // Vector
    constexpr std::ptrdiff_t m_flWorldTimeScale = 0x1FC; // float
}

namespace C_OP_NormalLock {
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
}

namespace C_OP_NormalizeVector {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flScale = 0x1C4; // float
}

namespace C_OP_Orient2DRelToCP {
    constexpr std::ptrdiff_t m_flRotOffset = 0x1C0; // float
    constexpr std::ptrdiff_t m_flSpinStrength = 0x1C4; // float
    constexpr std::ptrdiff_t m_nCP = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1CC; // ParticleAttributeIndex_t
}

namespace C_OP_OrientTo2dDirection {
    constexpr std::ptrdiff_t m_flRotOffset = 0x1C0; // float
    constexpr std::ptrdiff_t m_flSpinStrength = 0x1C4; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C8; // ParticleAttributeIndex_t
}

namespace C_OP_OscillateScalar {
    constexpr std::ptrdiff_t m_RateMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_RateMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_FrequencyMin = 0x1C8; // float
    constexpr std::ptrdiff_t m_FrequencyMax = 0x1CC; // float
    constexpr std::ptrdiff_t m_nField = 0x1D0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bProportional = 0x1D4; // bool
    constexpr std::ptrdiff_t m_bProportionalOp = 0x1D5; // bool
    constexpr std::ptrdiff_t m_flStartTime_min = 0x1D8; // float
    constexpr std::ptrdiff_t m_flStartTime_max = 0x1DC; // float
    constexpr std::ptrdiff_t m_flEndTime_min = 0x1E0; // float
    constexpr std::ptrdiff_t m_flEndTime_max = 0x1E4; // float
    constexpr std::ptrdiff_t m_flOscMult = 0x1E8; // float
    constexpr std::ptrdiff_t m_flOscAdd = 0x1EC; // float
}

namespace C_OP_OscillateScalarSimple {
    constexpr std::ptrdiff_t m_Rate = 0x1C0; // float
    constexpr std::ptrdiff_t m_Frequency = 0x1C4; // float
    constexpr std::ptrdiff_t m_nField = 0x1C8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flOscMult = 0x1CC; // float
    constexpr std::ptrdiff_t m_flOscAdd = 0x1D0; // float
}

namespace C_OP_OscillateVector {
    constexpr std::ptrdiff_t m_RateMin = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_RateMax = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_FrequencyMin = 0x1D8; // Vector
    constexpr std::ptrdiff_t m_FrequencyMax = 0x1E4; // Vector
    constexpr std::ptrdiff_t m_nField = 0x1F0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bProportional = 0x1F4; // bool
    constexpr std::ptrdiff_t m_bProportionalOp = 0x1F5; // bool
    constexpr std::ptrdiff_t m_bOffset = 0x1F6; // bool
    constexpr std::ptrdiff_t m_flStartTime_min = 0x1F8; // float
    constexpr std::ptrdiff_t m_flStartTime_max = 0x1FC; // float
    constexpr std::ptrdiff_t m_flEndTime_min = 0x200; // float
    constexpr std::ptrdiff_t m_flEndTime_max = 0x204; // float
    constexpr std::ptrdiff_t m_flOscMult = 0x208; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOscAdd = 0x360; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flRateScale = 0x4B8; // CPerParticleFloatInput
}

namespace C_OP_OscillateVectorSimple {
    constexpr std::ptrdiff_t m_Rate = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_Frequency = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_nField = 0x1D8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flOscMult = 0x1DC; // float
    constexpr std::ptrdiff_t m_flOscAdd = 0x1E0; // float
    constexpr std::ptrdiff_t m_bOffset = 0x1E4; // bool
}

namespace C_OP_ParentVortices {
    constexpr std::ptrdiff_t m_flForceScale = 0x1D0; // float
    constexpr std::ptrdiff_t m_vecTwistAxis = 0x1D4; // Vector
    constexpr std::ptrdiff_t m_bFlipBasedOnYaw = 0x1E0; // bool
}

namespace C_OP_ParticlePhysics {
    constexpr std::ptrdiff_t m_Gravity = 0x1C0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_fDrag = 0x818; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nMaxConstraintPasses = 0x970; // int32_t
}

namespace C_OP_PerParticleForce {
    constexpr std::ptrdiff_t m_flForceScale = 0x1D0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_vForce = 0x328; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_nCP = 0x980; // int32_t
}

namespace C_OP_PercentageBetweenTransformLerpCPs {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C4; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1C8; // float
    constexpr std::ptrdiff_t m_TransformStart = 0x1D0; // CParticleTransformInput
    constexpr std::ptrdiff_t m_TransformEnd = 0x238; // CParticleTransformInput
    constexpr std::ptrdiff_t m_nOutputStartCP = 0x2A0; // int32_t
    constexpr std::ptrdiff_t m_nOutputStartField = 0x2A4; // int32_t
    constexpr std::ptrdiff_t m_nOutputEndCP = 0x2A8; // int32_t
    constexpr std::ptrdiff_t m_nOutputEndField = 0x2AC; // int32_t
    constexpr std::ptrdiff_t m_nSetMethod = 0x2B0; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bActiveRange = 0x2B4; // bool
    constexpr std::ptrdiff_t m_bRadialCheck = 0x2B5; // bool
}

namespace C_OP_PercentageBetweenTransforms {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C4; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1C8; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1CC; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D0; // float
    constexpr std::ptrdiff_t m_TransformStart = 0x1D8; // CParticleTransformInput
    constexpr std::ptrdiff_t m_TransformEnd = 0x240; // CParticleTransformInput
    constexpr std::ptrdiff_t m_nSetMethod = 0x2A8; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bActiveRange = 0x2AC; // bool
    constexpr std::ptrdiff_t m_bRadialCheck = 0x2AD; // bool
}

namespace C_OP_PercentageBetweenTransformsVector {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C4; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1C8; // float
    constexpr std::ptrdiff_t m_vecOutputMin = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_vecOutputMax = 0x1D8; // Vector
    constexpr std::ptrdiff_t m_TransformStart = 0x1E8; // CParticleTransformInput
    constexpr std::ptrdiff_t m_TransformEnd = 0x250; // CParticleTransformInput
    constexpr std::ptrdiff_t m_nSetMethod = 0x2B8; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bActiveRange = 0x2BC; // bool
    constexpr std::ptrdiff_t m_bRadialCheck = 0x2BD; // bool
}

namespace C_OP_PinParticleToCP {
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_vecOffset = 0x1C8; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_bOffsetLocal = 0x820; // bool
    constexpr std::ptrdiff_t m_nParticleSelection = 0x824; // ParticleSelection_t
    constexpr std::ptrdiff_t m_nParticleNumber = 0x828; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nPinBreakType = 0x980; // ParticlePinDistance_t
    constexpr std::ptrdiff_t m_flBreakDistance = 0x988; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flBreakSpeed = 0xAE0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flAge = 0xC38; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nBreakControlPointNumber = 0xD90; // int32_t
    constexpr std::ptrdiff_t m_nBreakControlPointNumber2 = 0xD94; // int32_t
    constexpr std::ptrdiff_t m_flBreakValue = 0xD98; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flInterpolation = 0xEF0; // CPerParticleFloatInput
}

namespace C_OP_PlanarConstraint {
    constexpr std::ptrdiff_t m_PointOnPlane = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_PlaneNormal = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_bGlobalOrigin = 0x1DC; // bool
    constexpr std::ptrdiff_t m_bGlobalNormal = 0x1DD; // bool
    constexpr std::ptrdiff_t m_flRadiusScale = 0x1E0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flMaximumDistanceToCP = 0x338; // CParticleCollectionFloatInput
}

namespace C_OP_PlaneCull {
    constexpr std::ptrdiff_t m_nPlaneControlPoint = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_vecPlaneDirection = 0x1C4; // Vector
    constexpr std::ptrdiff_t m_bLocalSpace = 0x1D0; // bool
    constexpr std::ptrdiff_t m_flPlaneOffset = 0x1D4; // float
}

namespace C_OP_PlayEndCapWhenFinished {
    constexpr std::ptrdiff_t m_bFireOnEmissionEnd = 0x1D0; // bool
    constexpr std::ptrdiff_t m_bIncludeChildren = 0x1D1; // bool
}

namespace C_OP_PointVectorAtNextParticle {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInterpolation = 0x1C8; // CPerParticleFloatInput
}

namespace C_OP_PositionLock {
    constexpr std::ptrdiff_t m_TransformInput = 0x1C0; // CParticleTransformInput
    constexpr std::ptrdiff_t m_flStartTime_min = 0x228; // float
    constexpr std::ptrdiff_t m_flStartTime_max = 0x22C; // float
    constexpr std::ptrdiff_t m_flStartTime_exp = 0x230; // float
    constexpr std::ptrdiff_t m_flEndTime_min = 0x234; // float
    constexpr std::ptrdiff_t m_flEndTime_max = 0x238; // float
    constexpr std::ptrdiff_t m_flEndTime_exp = 0x23C; // float
    constexpr std::ptrdiff_t m_flRange = 0x240; // float
    constexpr std::ptrdiff_t m_flRangeBias = 0x248; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flJumpThreshold = 0x3A0; // float
    constexpr std::ptrdiff_t m_flPrevPosScale = 0x3A4; // float
    constexpr std::ptrdiff_t m_bLockRot = 0x3A8; // bool
    constexpr std::ptrdiff_t m_vecScale = 0x3B0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nFieldOutput = 0xA08; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutputPrev = 0xA0C; // ParticleAttributeIndex_t
}

namespace C_OP_QuantizeCPComponent {
    constexpr std::ptrdiff_t m_flInputValue = 0x1D0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nCPOutput = 0x328; // int32_t
    constexpr std::ptrdiff_t m_nOutVectorField = 0x32C; // int32_t
    constexpr std::ptrdiff_t m_flQuantizeValue = 0x330; // CParticleCollectionFloatInput
}

namespace C_OP_QuantizeFloat {
    constexpr std::ptrdiff_t m_InputValue = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nOutputField = 0x318; // ParticleAttributeIndex_t
}

namespace C_OP_RadiusDecay {
    constexpr std::ptrdiff_t m_flMinRadius = 0x1C0; // float
}

namespace C_OP_RampCPLinearRandom {
    constexpr std::ptrdiff_t m_nOutControlPointNumber = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_vecRateMin = 0x1D4; // Vector
    constexpr std::ptrdiff_t m_vecRateMax = 0x1E0; // Vector
}

namespace C_OP_RampScalarLinear {
    constexpr std::ptrdiff_t m_RateMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_RateMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_flStartTime_min = 0x1C8; // float
    constexpr std::ptrdiff_t m_flStartTime_max = 0x1CC; // float
    constexpr std::ptrdiff_t m_flEndTime_min = 0x1D0; // float
    constexpr std::ptrdiff_t m_flEndTime_max = 0x1D4; // float
    constexpr std::ptrdiff_t m_nField = 0x200; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bProportionalOp = 0x204; // bool
}

namespace C_OP_RampScalarLinearSimple {
    constexpr std::ptrdiff_t m_Rate = 0x1C0; // float
    constexpr std::ptrdiff_t m_flStartTime = 0x1C4; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x1C8; // float
    constexpr std::ptrdiff_t m_nField = 0x1F0; // ParticleAttributeIndex_t
}

namespace C_OP_RampScalarSpline {
    constexpr std::ptrdiff_t m_RateMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_RateMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_flStartTime_min = 0x1C8; // float
    constexpr std::ptrdiff_t m_flStartTime_max = 0x1CC; // float
    constexpr std::ptrdiff_t m_flEndTime_min = 0x1D0; // float
    constexpr std::ptrdiff_t m_flEndTime_max = 0x1D4; // float
    constexpr std::ptrdiff_t m_flBias = 0x1D8; // float
    constexpr std::ptrdiff_t m_nField = 0x200; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bProportionalOp = 0x204; // bool
    constexpr std::ptrdiff_t m_bEaseOut = 0x205; // bool
}

namespace C_OP_RampScalarSplineSimple {
    constexpr std::ptrdiff_t m_Rate = 0x1C0; // float
    constexpr std::ptrdiff_t m_flStartTime = 0x1C4; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x1C8; // float
    constexpr std::ptrdiff_t m_nField = 0x1F0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bEaseOut = 0x1F4; // bool
}

namespace C_OP_RandomForce {
    constexpr std::ptrdiff_t m_MinForce = 0x1D0; // Vector
    constexpr std::ptrdiff_t m_MaxForce = 0x1DC; // Vector
}

namespace C_OP_ReadFromNeighboringParticle {
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nIncrement = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_DistanceCheck = 0x1D0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flInterpolation = 0x328; // CPerParticleFloatInput
}

namespace C_OP_ReinitializeScalarEndCap {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flOutputMin = 0x1C4; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1C8; // float
}

namespace C_OP_RemapAverageHitboxSpeedtoCP {
    constexpr std::ptrdiff_t m_nInControlPointNumber = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nOutControlPointNumber = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nField = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_nHitboxDataType = 0x1DC; // ParticleHitboxDataSelection_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1E0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flInputMax = 0x338; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flOutputMin = 0x490; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flOutputMax = 0x5E8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nHeightControlPointNumber = 0x740; // int32_t
    constexpr std::ptrdiff_t m_vecComparisonVelocity = 0x748; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_HitboxSetName = 0xDA0; // char[128]
}

namespace C_OP_RemapAverageScalarValuetoCP {
    constexpr std::ptrdiff_t m_nOutControlPointNumber = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nOutVectorField = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nField = 0x1D8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1DC; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1E0; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1E4; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1E8; // float
}

namespace C_OP_RemapBoundingVolumetoCP {
    constexpr std::ptrdiff_t m_nOutControlPointNumber = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1D4; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1D8; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1DC; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1E0; // float
}

namespace C_OP_RemapCPVelocityToVector {
    constexpr std::ptrdiff_t m_nControlPoint = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flScale = 0x1C8; // float
    constexpr std::ptrdiff_t m_bNormalize = 0x1CC; // bool
}

namespace C_OP_RemapCPtoCP {
    constexpr std::ptrdiff_t m_nInputControlPoint = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nOutputControlPoint = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nInputField = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_nOutputField = 0x1DC; // int32_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1E0; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1E4; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1E8; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1EC; // float
    constexpr std::ptrdiff_t m_bDerivative = 0x1F0; // bool
    constexpr std::ptrdiff_t m_flInterpRate = 0x1F4; // float
}

namespace C_OP_RemapCPtoScalar {
    constexpr std::ptrdiff_t m_nCPInput = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nField = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1CC; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D4; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D8; // float
    constexpr std::ptrdiff_t m_flStartTime = 0x1DC; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x1E0; // float
    constexpr std::ptrdiff_t m_flInterpRate = 0x1E4; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x1E8; // ParticleSetMethod_t
}

namespace C_OP_RemapCPtoVector {
    constexpr std::ptrdiff_t m_nCPInput = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nLocalSpaceCP = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_vInputMin = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_vInputMax = 0x1D8; // Vector
    constexpr std::ptrdiff_t m_vOutputMin = 0x1E4; // Vector
    constexpr std::ptrdiff_t m_vOutputMax = 0x1F0; // Vector
    constexpr std::ptrdiff_t m_flStartTime = 0x1FC; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x200; // float
    constexpr std::ptrdiff_t m_flInterpRate = 0x204; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x208; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bOffset = 0x20C; // bool
    constexpr std::ptrdiff_t m_bAccelerate = 0x20D; // bool
}

namespace C_OP_RemapControlPointDirectionToVector {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flScale = 0x1C4; // float
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C8; // int32_t
}

namespace C_OP_RemapControlPointOrientationToRotation {
    constexpr std::ptrdiff_t m_nCP = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flOffsetRot = 0x1C8; // float
    constexpr std::ptrdiff_t m_nComponent = 0x1CC; // int32_t
}

namespace C_OP_RemapCrossProductOfTwoVectorsToVector {
    constexpr std::ptrdiff_t m_InputVec1 = 0x1C0; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_InputVec2 = 0x818; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_nFieldOutput = 0xE70; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bNormalize = 0xE74; // bool
}

namespace C_OP_RemapDensityGradientToVectorAttribute {
    constexpr std::ptrdiff_t m_flRadiusScale = 0x1C0; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
}

namespace C_OP_RemapDensityToVector {
    constexpr std::ptrdiff_t m_flRadiusScale = 0x1C0; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flDensityMin = 0x1C8; // float
    constexpr std::ptrdiff_t m_flDensityMax = 0x1CC; // float
    constexpr std::ptrdiff_t m_vecOutputMin = 0x1D0; // Vector
    constexpr std::ptrdiff_t m_vecOutputMax = 0x1DC; // Vector
    constexpr std::ptrdiff_t m_bUseParentDensity = 0x1E8; // bool
    constexpr std::ptrdiff_t m_nVoxelGridResolution = 0x1EC; // int32_t
}

namespace C_OP_RemapDirectionToCPToVector {
    constexpr std::ptrdiff_t m_nCP = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flScale = 0x1C8; // float
    constexpr std::ptrdiff_t m_flOffsetRot = 0x1CC; // float
    constexpr std::ptrdiff_t m_vecOffsetAxis = 0x1D0; // Vector
    constexpr std::ptrdiff_t m_bNormalize = 0x1DC; // bool
    constexpr std::ptrdiff_t m_nFieldStrength = 0x1E0; // ParticleAttributeIndex_t
}

namespace C_OP_RemapDistanceToLineSegmentBase {
    constexpr std::ptrdiff_t m_nCP0 = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nCP1 = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_flMinInputValue = 0x1C8; // float
    constexpr std::ptrdiff_t m_flMaxInputValue = 0x1CC; // float
    constexpr std::ptrdiff_t m_bInfiniteLine = 0x1D0; // bool
}

namespace C_OP_RemapDistanceToLineSegmentToScalar {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1E0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flMinOutputValue = 0x1E4; // float
    constexpr std::ptrdiff_t m_flMaxOutputValue = 0x1E8; // float
}

namespace C_OP_RemapDistanceToLineSegmentToVector {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1E0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vMinOutputValue = 0x1E4; // Vector
    constexpr std::ptrdiff_t m_vMaxOutputValue = 0x1F0; // Vector
}

namespace C_OP_RemapDotProductToCP {
    constexpr std::ptrdiff_t m_nInputCP1 = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nInputCP2 = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nOutputCP = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_nOutVectorField = 0x1DC; // int32_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1E0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flInputMax = 0x338; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flOutputMin = 0x490; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flOutputMax = 0x5E8; // CParticleCollectionFloatInput
}

namespace C_OP_RemapDotProductToScalar {
    constexpr std::ptrdiff_t m_nInputCP1 = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nInputCP2 = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1CC; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D4; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D8; // float
    constexpr std::ptrdiff_t m_bUseParticleVelocity = 0x1DC; // bool
    constexpr std::ptrdiff_t m_nSetMethod = 0x1E0; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bActiveRange = 0x1E4; // bool
    constexpr std::ptrdiff_t m_bUseParticleNormal = 0x1E5; // bool
}

namespace C_OP_RemapExternalWindToCP {
    constexpr std::ptrdiff_t m_nCP = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nCPOutput = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_vecScale = 0x1D8; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_bSetMagnitude = 0x830; // bool
    constexpr std::ptrdiff_t m_nOutVectorField = 0x834; // int32_t
}

namespace C_OP_RemapModelVolumetoCP {
    constexpr std::ptrdiff_t m_nBBoxType = 0x1D0; // BBoxVolumeType_t
    constexpr std::ptrdiff_t m_nInControlPointNumber = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nOutControlPointNumber = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_nOutControlPointMaxNumber = 0x1DC; // int32_t
    constexpr std::ptrdiff_t m_nField = 0x1E0; // int32_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1E4; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1E8; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1EC; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1F0; // float
}

namespace C_OP_RemapNamedModelElementEndCap {
    constexpr std::ptrdiff_t m_hModel = 0x1C0; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_inNames = 0x1C8; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_outNames = 0x1E0; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_fallbackNames = 0x1F8; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_bModelFromRenderer = 0x210; // bool
    constexpr std::ptrdiff_t m_nFieldInput = 0x214; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x218; // ParticleAttributeIndex_t
}

namespace C_OP_RemapNamedModelElementOnceTimed {
    constexpr std::ptrdiff_t m_hModel = 0x1C0; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_inNames = 0x1C8; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_outNames = 0x1E0; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_fallbackNames = 0x1F8; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_bModelFromRenderer = 0x210; // bool
    constexpr std::ptrdiff_t m_bProportional = 0x211; // bool
    constexpr std::ptrdiff_t m_nFieldInput = 0x214; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x218; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flRemapTime = 0x21C; // float
}

namespace C_OP_RemapParticleCountOnScalarEndCap {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nInputMin = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nInputMax = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_flOutputMin = 0x1CC; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D0; // float
    constexpr std::ptrdiff_t m_bBackwards = 0x1D4; // bool
    constexpr std::ptrdiff_t m_nSetMethod = 0x1D8; // ParticleSetMethod_t
}

namespace C_OP_RemapParticleCountToScalar {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nInputMin = 0x1C8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nInputMax = 0x320; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flOutputMin = 0x478; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flOutputMax = 0x5D0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bActiveRange = 0x728; // bool
    constexpr std::ptrdiff_t m_nSetMethod = 0x72C; // ParticleSetMethod_t
}

namespace C_OP_RemapSDFDistanceToScalarAttribute {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nVectorFieldInput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flMinDistance = 0x1C8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flMaxDistance = 0x320; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flValueBelowMin = 0x478; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flValueAtMin = 0x5D0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flValueAtMax = 0x728; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flValueAboveMax = 0x880; // CParticleCollectionFloatInput
}

namespace C_OP_RemapSDFDistanceToVectorAttribute {
    constexpr std::ptrdiff_t m_nVectorFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nVectorFieldInput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flMinDistance = 0x1C8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flMaxDistance = 0x320; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_vValueBelowMin = 0x478; // Vector
    constexpr std::ptrdiff_t m_vValueAtMin = 0x484; // Vector
    constexpr std::ptrdiff_t m_vValueAtMax = 0x490; // Vector
    constexpr std::ptrdiff_t m_vValueAboveMax = 0x49C; // Vector
}

namespace C_OP_RemapSDFGradientToVectorAttribute {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
}

namespace C_OP_RemapScalar {
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C8; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1CC; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D4; // float
    constexpr std::ptrdiff_t m_bOldCode = 0x1D8; // bool
}

namespace C_OP_RemapScalarEndCap {
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C8; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1CC; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D4; // float
}

namespace C_OP_RemapScalarOnceTimed {
    constexpr std::ptrdiff_t m_bProportional = 0x1C0; // bool
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1CC; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D4; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D8; // float
    constexpr std::ptrdiff_t m_flRemapTime = 0x1DC; // float
}

namespace C_OP_RemapSpeed {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C4; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1C8; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1CC; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D0; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x1D4; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bIgnoreDelta = 0x1D8; // bool
}

namespace C_OP_RemapSpeedtoCP {
    constexpr std::ptrdiff_t m_nInControlPointNumber = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nOutControlPointNumber = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nField = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1DC; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1E0; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1E4; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1E8; // float
    constexpr std::ptrdiff_t m_bUseDeltaV = 0x1EC; // bool
}

namespace C_OP_RemapTransformOrientationToRotations {
    constexpr std::ptrdiff_t m_TransformInput = 0x1C0; // CParticleTransformInput
    constexpr std::ptrdiff_t m_vecRotation = 0x228; // Vector
    constexpr std::ptrdiff_t m_bUseQuat = 0x234; // bool
    constexpr std::ptrdiff_t m_bWriteNormal = 0x235; // bool
}

namespace C_OP_RemapTransformOrientationToYaw {
    constexpr std::ptrdiff_t m_TransformInput = 0x1C0; // CParticleTransformInput
    constexpr std::ptrdiff_t m_nFieldOutput = 0x228; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flRotOffset = 0x22C; // float
    constexpr std::ptrdiff_t m_flSpinStrength = 0x230; // float
}

namespace C_OP_RemapTransformToVelocity {
    constexpr std::ptrdiff_t m_TransformInput = 0x1C0; // CParticleTransformInput
}

namespace C_OP_RemapTransformVisibilityToScalar {
    constexpr std::ptrdiff_t m_nSetMethod = 0x1C0; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_TransformInput = 0x1C8; // CParticleTransformInput
    constexpr std::ptrdiff_t m_nFieldOutput = 0x230; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x234; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x238; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x23C; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x240; // float
    constexpr std::ptrdiff_t m_flRadius = 0x244; // float
}

namespace C_OP_RemapTransformVisibilityToVector {
    constexpr std::ptrdiff_t m_nSetMethod = 0x1C0; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_TransformInput = 0x1C8; // CParticleTransformInput
    constexpr std::ptrdiff_t m_nFieldOutput = 0x230; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x234; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x238; // float
    constexpr std::ptrdiff_t m_vecOutputMin = 0x23C; // Vector
    constexpr std::ptrdiff_t m_vecOutputMax = 0x248; // Vector
    constexpr std::ptrdiff_t m_flRadius = 0x254; // float
}

namespace C_OP_RemapVectorComponentToScalar {
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nComponent = 0x1C8; // int32_t
}

namespace C_OP_RemapVectortoCP {
    constexpr std::ptrdiff_t m_nOutControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nParticleNumber = 0x1C8; // int32_t
}

namespace C_OP_RemapVelocityToVector {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flScale = 0x1C4; // float
    constexpr std::ptrdiff_t m_bNormalize = 0x1C8; // bool
}

namespace C_OP_RemapVisibilityScalar {
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C8; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1CC; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D4; // float
    constexpr std::ptrdiff_t m_flRadiusScale = 0x1D8; // float
}

namespace C_OP_RenderAsModels {
    constexpr std::ptrdiff_t m_ModelList = 0x200; // CUtlVector<ModelReference_t>
    constexpr std::ptrdiff_t m_flModelScale = 0x21C; // float
    constexpr std::ptrdiff_t m_bFitToModelSize = 0x220; // bool
    constexpr std::ptrdiff_t m_bNonUniformScaling = 0x221; // bool
    constexpr std::ptrdiff_t m_nXAxisScalingAttribute = 0x224; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nYAxisScalingAttribute = 0x228; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nZAxisScalingAttribute = 0x22C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSizeCullBloat = 0x230; // int32_t
}

namespace C_OP_RenderBlobs {
    constexpr std::ptrdiff_t m_cubeWidth = 0x200; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_cutoffRadius = 0x358; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_renderRadius = 0x4B0; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_nScaleCP = 0x608; // int32_t
    constexpr std::ptrdiff_t m_MaterialVars = 0x610; // CUtlVector<MaterialVariable_t>
    constexpr std::ptrdiff_t m_hMaterial = 0x640; // CStrongHandle<InfoForResourceTypeIMaterial2>
}

namespace C_OP_RenderCables {
    constexpr std::ptrdiff_t m_flRadiusScale = 0x200; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flAlphaScale = 0x358; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_vecColorScale = 0x4B0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nColorBlendType = 0xB08; // ParticleColorBlendType_t
    constexpr std::ptrdiff_t m_hMaterial = 0xB10; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_nTextureRepetitionMode = 0xB18; // TextureRepetitionMode_t
    constexpr std::ptrdiff_t m_flTextureRepeatsPerSegment = 0xB20; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flTextureRepeatsCircumference = 0xC78; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flColorMapOffsetV = 0xDD0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flColorMapOffsetU = 0xF28; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flNormalMapOffsetV = 0x1080; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flNormalMapOffsetU = 0x11D8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bDrawCableCaps = 0x1330; // bool
    constexpr std::ptrdiff_t m_flCapRoundness = 0x1334; // float
    constexpr std::ptrdiff_t m_flCapOffsetAmount = 0x1338; // float
    constexpr std::ptrdiff_t m_flTessScale = 0x133C; // float
    constexpr std::ptrdiff_t m_nMinTesselation = 0x1340; // int32_t
    constexpr std::ptrdiff_t m_nMaxTesselation = 0x1344; // int32_t
    constexpr std::ptrdiff_t m_nRoundness = 0x1348; // int32_t
    constexpr std::ptrdiff_t m_LightingTransform = 0x1350; // CParticleTransformInput
    constexpr std::ptrdiff_t m_MaterialFloatVars = 0x13B8; // CUtlVector<FloatInputMaterialVariable_t>
    constexpr std::ptrdiff_t m_MaterialVecVars = 0x13E8; // CUtlVector<VecInputMaterialVariable_t>
}

namespace C_OP_RenderDeferredLight {
    constexpr std::ptrdiff_t m_bUseAlphaTestWindow = 0x200; // bool
    constexpr std::ptrdiff_t m_bUseTexture = 0x201; // bool
    constexpr std::ptrdiff_t m_flRadiusScale = 0x204; // float
    constexpr std::ptrdiff_t m_flAlphaScale = 0x208; // float
    constexpr std::ptrdiff_t m_nAlpha2Field = 0x20C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vecColorScale = 0x210; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nColorBlendType = 0x868; // ParticleColorBlendType_t
    constexpr std::ptrdiff_t m_flLightDistance = 0x86C; // float
    constexpr std::ptrdiff_t m_flStartFalloff = 0x870; // float
    constexpr std::ptrdiff_t m_flDistanceFalloff = 0x874; // float
    constexpr std::ptrdiff_t m_flSpotFoV = 0x878; // float
    constexpr std::ptrdiff_t m_nAlphaTestPointField = 0x87C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nAlphaTestRangeField = 0x880; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nAlphaTestSharpnessField = 0x884; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_hTexture = 0x888; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_nHSVShiftControlPoint = 0x890; // int32_t
}

namespace C_OP_RenderFlattenGrass {
    constexpr std::ptrdiff_t m_flFlattenStrength = 0x200; // float
    constexpr std::ptrdiff_t m_nStrengthFieldOverride = 0x204; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flRadiusScale = 0x208; // float
}

namespace C_OP_RenderGpuImplicit {
    constexpr std::ptrdiff_t m_bUsePerParticleRadius = 0x200; // bool
    constexpr std::ptrdiff_t m_fGridSize = 0x208; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_fRadiusScale = 0x360; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_fIsosurfaceThreshold = 0x4B8; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_nScaleCP = 0x610; // int32_t
    constexpr std::ptrdiff_t m_hMaterial = 0x618; // CStrongHandle<InfoForResourceTypeIMaterial2>
}

namespace C_OP_RenderLightBeam {
    constexpr std::ptrdiff_t m_vColorBlend = 0x200; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nColorBlendType = 0x858; // ParticleColorBlendType_t
    constexpr std::ptrdiff_t m_flBrightnessLumensPerMeter = 0x860; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bCastShadows = 0x9B8; // bool
    constexpr std::ptrdiff_t m_flSkirt = 0x9C0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flRange = 0xB18; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flThickness = 0xC70; // CParticleCollectionFloatInput
}

namespace C_OP_RenderLights {
    constexpr std::ptrdiff_t m_flAnimationRate = 0x210; // float
    constexpr std::ptrdiff_t m_nAnimationType = 0x214; // AnimationType_t
    constexpr std::ptrdiff_t m_bAnimateInFPS = 0x218; // bool
    constexpr std::ptrdiff_t m_flMinSize = 0x21C; // float
    constexpr std::ptrdiff_t m_flMaxSize = 0x220; // float
    constexpr std::ptrdiff_t m_flStartFadeSize = 0x224; // float
    constexpr std::ptrdiff_t m_flEndFadeSize = 0x228; // float
}

namespace C_OP_RenderMaterialProxy {
    constexpr std::ptrdiff_t m_nMaterialControlPoint = 0x200; // int32_t
    constexpr std::ptrdiff_t m_nProxyType = 0x204; // MaterialProxyType_t
    constexpr std::ptrdiff_t m_MaterialVars = 0x208; // CUtlVector<MaterialVariable_t>
    constexpr std::ptrdiff_t m_hOverrideMaterial = 0x220; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_flMaterialOverrideEnabled = 0x228; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_vecColorScale = 0x380; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_flAlpha = 0x9D8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nColorBlendType = 0xB30; // ParticleColorBlendType_t
}

namespace C_OP_RenderModels {
    constexpr std::ptrdiff_t m_bOnlyRenderInEffectsBloomPass = 0x200; // bool
    constexpr std::ptrdiff_t m_bOnlyRenderInEffectsWaterPass = 0x201; // bool
    constexpr std::ptrdiff_t m_bUseMixedResolutionRendering = 0x202; // bool
    constexpr std::ptrdiff_t m_bOnlyRenderInEffecsGameOverlay = 0x203; // bool
    constexpr std::ptrdiff_t m_ModelList = 0x208; // CUtlVector<ModelReference_t>
    constexpr std::ptrdiff_t m_nBodyGroupField = 0x224; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSubModelField = 0x228; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bIgnoreNormal = 0x22C; // bool
    constexpr std::ptrdiff_t m_bOrientZ = 0x22D; // bool
    constexpr std::ptrdiff_t m_bCenterOffset = 0x22E; // bool
    constexpr std::ptrdiff_t m_vecLocalOffset = 0x230; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecLocalRotation = 0x888; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_bIgnoreRadius = 0xEE0; // bool
    constexpr std::ptrdiff_t m_nModelScaleCP = 0xEE4; // int32_t
    constexpr std::ptrdiff_t m_vecComponentScale = 0xEE8; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_bLocalScale = 0x1540; // bool
    constexpr std::ptrdiff_t m_nSizeCullBloat = 0x1544; // int32_t
    constexpr std::ptrdiff_t m_bAnimated = 0x1548; // bool
    constexpr std::ptrdiff_t m_flAnimationRate = 0x154C; // float
    constexpr std::ptrdiff_t m_bScaleAnimationRate = 0x1550; // bool
    constexpr std::ptrdiff_t m_bForceLoopingAnimation = 0x1551; // bool
    constexpr std::ptrdiff_t m_bResetAnimOnStop = 0x1552; // bool
    constexpr std::ptrdiff_t m_bManualAnimFrame = 0x1553; // bool
    constexpr std::ptrdiff_t m_nAnimationScaleField = 0x1554; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nAnimationField = 0x1558; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nManualFrameField = 0x155C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_ActivityName = 0x1560; // char[256]
    constexpr std::ptrdiff_t m_SequenceName = 0x1660; // char[256]
    constexpr std::ptrdiff_t m_bEnableClothSimulation = 0x1760; // bool
    constexpr std::ptrdiff_t m_hOverrideMaterial = 0x1768; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_bOverrideTranslucentMaterials = 0x1770; // bool
    constexpr std::ptrdiff_t m_nSkin = 0x1778; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_MaterialVars = 0x18D0; // CUtlVector<MaterialVariable_t>
    constexpr std::ptrdiff_t m_modelInput = 0x18E8; // CParticleModelInput
    constexpr std::ptrdiff_t m_nLOD = 0x1948; // int32_t
    constexpr std::ptrdiff_t m_EconSlotName = 0x194C; // char[256]
    constexpr std::ptrdiff_t m_bOriginalModel = 0x1A4C; // bool
    constexpr std::ptrdiff_t m_bSuppressTint = 0x1A4D; // bool
    constexpr std::ptrdiff_t m_bUseRawMeshGroup = 0x1A4E; // bool
    constexpr std::ptrdiff_t m_bDisableShadows = 0x1A4F; // bool
    constexpr std::ptrdiff_t m_bAcceptsDecals = 0x1A50; // bool
    constexpr std::ptrdiff_t m_bForceDrawInterlevedWithSiblings = 0x1A51; // bool
    constexpr std::ptrdiff_t m_bDoNotDrawInParticlePass = 0x1A52; // bool
    constexpr std::ptrdiff_t m_szRenderAttribute = 0x1A53; // char[260]
    constexpr std::ptrdiff_t m_flRadiusScale = 0x1B58; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flAlphaScale = 0x1CB0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flRollScale = 0x1E08; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nAlpha2Field = 0x1F60; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vecColorScale = 0x1F68; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nColorBlendType = 0x25C0; // ParticleColorBlendType_t
}

namespace C_OP_RenderOmni2Light {
    constexpr std::ptrdiff_t m_nLightType = 0x200; // ParticleOmni2LightTypeChoiceList_t
    constexpr std::ptrdiff_t m_vColorBlend = 0x208; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nColorBlendType = 0x860; // ParticleColorBlendType_t
    constexpr std::ptrdiff_t m_nBrightnessUnit = 0x864; // ParticleLightUnitChoiceList_t
    constexpr std::ptrdiff_t m_flBrightnessLumens = 0x868; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flBrightnessCandelas = 0x9C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_bCastShadows = 0xB18; // bool
    constexpr std::ptrdiff_t m_flLuminaireRadius = 0xB20; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flSkirt = 0xC78; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flRange = 0xDD0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flInnerConeAngle = 0xF28; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOuterConeAngle = 0x1080; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_hLightCookie = 0x11D8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_bSphericalCookie = 0x11E0; // bool
}

namespace C_OP_RenderPoints {
    constexpr std::ptrdiff_t m_hMaterial = 0x200; // CStrongHandle<InfoForResourceTypeIMaterial2>
}

namespace C_OP_RenderPostProcessing {
    constexpr std::ptrdiff_t m_flPostProcessStrength = 0x200; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_hPostTexture = 0x358; // CStrongHandle<InfoForResourceTypeCPostProcessingResource>
    constexpr std::ptrdiff_t m_nPriority = 0x360; // ParticlePostProcessPriorityGroup_t
}

namespace C_OP_RenderProjected {
    constexpr std::ptrdiff_t m_bProjectCharacter = 0x200; // bool
    constexpr std::ptrdiff_t m_bProjectWorld = 0x201; // bool
    constexpr std::ptrdiff_t m_bProjectWater = 0x202; // bool
    constexpr std::ptrdiff_t m_bFlipHorizontal = 0x203; // bool
    constexpr std::ptrdiff_t m_bEnableProjectedDepthControls = 0x204; // bool
    constexpr std::ptrdiff_t m_flMinProjectionDepth = 0x208; // float
    constexpr std::ptrdiff_t m_flMaxProjectionDepth = 0x20C; // float
    constexpr std::ptrdiff_t m_hProjectedMaterial = 0x210; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_flAnimationTimeScale = 0x218; // float
    constexpr std::ptrdiff_t m_bOrientToNormal = 0x21C; // bool
    constexpr std::ptrdiff_t m_MaterialVars = 0x220; // CUtlVector<MaterialVariable_t>
}

namespace C_OP_RenderRopes {
    constexpr std::ptrdiff_t m_bEnableFadingAndClamping = 0x2470; // bool
    constexpr std::ptrdiff_t m_flMinSize = 0x2474; // float
    constexpr std::ptrdiff_t m_flMaxSize = 0x2478; // float
    constexpr std::ptrdiff_t m_flStartFadeSize = 0x247C; // float
    constexpr std::ptrdiff_t m_flEndFadeSize = 0x2480; // float
    constexpr std::ptrdiff_t m_flStartFadeDot = 0x2484; // float
    constexpr std::ptrdiff_t m_flEndFadeDot = 0x2488; // float
    constexpr std::ptrdiff_t m_flRadiusTaper = 0x248C; // float
    constexpr std::ptrdiff_t m_nMinTesselation = 0x2490; // int32_t
    constexpr std::ptrdiff_t m_nMaxTesselation = 0x2494; // int32_t
    constexpr std::ptrdiff_t m_flTessScale = 0x2498; // float
    constexpr std::ptrdiff_t m_flTextureVWorldSize = 0x24A0; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flTextureVScrollRate = 0x25F8; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flTextureVOffset = 0x2750; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_nTextureVParamsCP = 0x28A8; // int32_t
    constexpr std::ptrdiff_t m_bClampV = 0x28AC; // bool
    constexpr std::ptrdiff_t m_nScaleCP1 = 0x28B0; // int32_t
    constexpr std::ptrdiff_t m_nScaleCP2 = 0x28B4; // int32_t
    constexpr std::ptrdiff_t m_flScaleVSizeByControlPointDistance = 0x28B8; // float
    constexpr std::ptrdiff_t m_flScaleVScrollByControlPointDistance = 0x28BC; // float
    constexpr std::ptrdiff_t m_flScaleVOffsetByControlPointDistance = 0x28C0; // float
    constexpr std::ptrdiff_t m_bUseScalarForTextureCoordinate = 0x28C5; // bool
    constexpr std::ptrdiff_t m_nScalarFieldForTextureCoordinate = 0x28C8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flScalarAttributeTextureCoordScale = 0x28CC; // float
    constexpr std::ptrdiff_t m_bReverseOrder = 0x28D0; // bool
    constexpr std::ptrdiff_t m_bClosedLoop = 0x28D1; // bool
    constexpr std::ptrdiff_t m_nOrientationType = 0x28D4; // ParticleOrientationChoiceList_t
    constexpr std::ptrdiff_t m_nVectorFieldForOrientation = 0x28D8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bDrawAsOpaque = 0x28DC; // bool
    constexpr std::ptrdiff_t m_bGenerateNormals = 0x28DD; // bool
}

namespace C_OP_RenderScreenShake {
    constexpr std::ptrdiff_t m_flDurationScale = 0x200; // float
    constexpr std::ptrdiff_t m_flRadiusScale = 0x204; // float
    constexpr std::ptrdiff_t m_flFrequencyScale = 0x208; // float
    constexpr std::ptrdiff_t m_flAmplitudeScale = 0x20C; // float
    constexpr std::ptrdiff_t m_nRadiusField = 0x210; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nDurationField = 0x214; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFrequencyField = 0x218; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nAmplitudeField = 0x21C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFilterCP = 0x220; // int32_t
}

namespace C_OP_RenderScreenVelocityRotate {
    constexpr std::ptrdiff_t m_flRotateRateDegrees = 0x200; // float
    constexpr std::ptrdiff_t m_flForwardDegrees = 0x204; // float
}

namespace C_OP_RenderSound {
    constexpr std::ptrdiff_t m_flDurationScale = 0x200; // float
    constexpr std::ptrdiff_t m_flSndLvlScale = 0x204; // float
    constexpr std::ptrdiff_t m_flPitchScale = 0x208; // float
    constexpr std::ptrdiff_t m_flVolumeScale = 0x20C; // float
    constexpr std::ptrdiff_t m_nSndLvlField = 0x210; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nDurationField = 0x214; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nPitchField = 0x218; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nVolumeField = 0x21C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nChannel = 0x220; // int32_t
    constexpr std::ptrdiff_t m_nCPReference = 0x224; // int32_t
    constexpr std::ptrdiff_t m_pszSoundName = 0x228; // char[256]
    constexpr std::ptrdiff_t m_bSuppressStopSoundEvent = 0x328; // bool
}

namespace C_OP_RenderSprites {
    constexpr std::ptrdiff_t m_nSequenceOverride = 0x2470; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_nOrientationType = 0x25C8; // ParticleOrientationChoiceList_t
    constexpr std::ptrdiff_t m_nOrientationControlPoint = 0x25CC; // int32_t
    constexpr std::ptrdiff_t m_bUseYawWithNormalAligned = 0x25D0; // bool
    constexpr std::ptrdiff_t m_flMinSize = 0x25D4; // float
    constexpr std::ptrdiff_t m_flMaxSize = 0x25D8; // float
    constexpr std::ptrdiff_t m_flAlphaAdjustWithSizeAdjust = 0x25DC; // float
    constexpr std::ptrdiff_t m_flStartFadeSize = 0x25E0; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flEndFadeSize = 0x2738; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flStartFadeDot = 0x2890; // float
    constexpr std::ptrdiff_t m_flEndFadeDot = 0x2894; // float
    constexpr std::ptrdiff_t m_bDistanceAlpha = 0x2898; // bool
    constexpr std::ptrdiff_t m_bSoftEdges = 0x2899; // bool
    constexpr std::ptrdiff_t m_flEdgeSoftnessStart = 0x289C; // float
    constexpr std::ptrdiff_t m_flEdgeSoftnessEnd = 0x28A0; // float
    constexpr std::ptrdiff_t m_bOutline = 0x28A4; // bool
    constexpr std::ptrdiff_t m_OutlineColor = 0x28A5; // Color
    constexpr std::ptrdiff_t m_nOutlineAlpha = 0x28AC; // int32_t
    constexpr std::ptrdiff_t m_flOutlineStart0 = 0x28B0; // float
    constexpr std::ptrdiff_t m_flOutlineStart1 = 0x28B4; // float
    constexpr std::ptrdiff_t m_flOutlineEnd0 = 0x28B8; // float
    constexpr std::ptrdiff_t m_flOutlineEnd1 = 0x28BC; // float
    constexpr std::ptrdiff_t m_nLightingMode = 0x28C0; // ParticleLightingQuality_t
    constexpr std::ptrdiff_t m_flLightingTessellation = 0x28C8; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flLightingDirectionality = 0x2A20; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_bParticleShadows = 0x2B78; // bool
    constexpr std::ptrdiff_t m_flShadowDensity = 0x2B7C; // float
}

namespace C_OP_RenderStandardLight {
    constexpr std::ptrdiff_t m_nLightType = 0x200; // ParticleLightTypeChoiceList_t
    constexpr std::ptrdiff_t m_vecColorScale = 0x208; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nColorBlendType = 0x860; // ParticleColorBlendType_t
    constexpr std::ptrdiff_t m_flIntensity = 0x868; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bCastShadows = 0x9C0; // bool
    constexpr std::ptrdiff_t m_flTheta = 0x9C8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flPhi = 0xB20; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flRadiusMultiplier = 0xC78; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nAttenuationStyle = 0xDD0; // StandardLightingAttenuationStyle_t
    constexpr std::ptrdiff_t m_flFalloffLinearity = 0xDD8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flFiftyPercentFalloff = 0xF30; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flZeroPercentFalloff = 0x1088; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bRenderDiffuse = 0x11E0; // bool
    constexpr std::ptrdiff_t m_bRenderSpecular = 0x11E1; // bool
    constexpr std::ptrdiff_t m_lightCookie = 0x11E8; // CUtlString
    constexpr std::ptrdiff_t m_nPriority = 0x11F0; // int32_t
    constexpr std::ptrdiff_t m_nFogLightingMode = 0x11F4; // ParticleLightFogLightingMode_t
    constexpr std::ptrdiff_t m_flFogContribution = 0x11F8; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_nCapsuleLightBehavior = 0x1350; // ParticleLightBehaviorChoiceList_t
    constexpr std::ptrdiff_t m_flCapsuleLength = 0x1354; // float
    constexpr std::ptrdiff_t m_bReverseOrder = 0x1358; // bool
    constexpr std::ptrdiff_t m_bClosedLoop = 0x1359; // bool
    constexpr std::ptrdiff_t m_nPrevPntSource = 0x135C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flMaxLength = 0x1360; // float
    constexpr std::ptrdiff_t m_flMinLength = 0x1364; // float
    constexpr std::ptrdiff_t m_bIgnoreDT = 0x1368; // bool
    constexpr std::ptrdiff_t m_flConstrainRadiusToLengthRatio = 0x136C; // float
    constexpr std::ptrdiff_t m_flLengthScale = 0x1370; // float
    constexpr std::ptrdiff_t m_flLengthFadeInTime = 0x1374; // float
}

namespace C_OP_RenderStatusEffect {
    constexpr std::ptrdiff_t m_pTextureColorWarp = 0x200; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_pTextureDetail2 = 0x208; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_pTextureDiffuseWarp = 0x210; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_pTextureFresnelColorWarp = 0x218; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_pTextureFresnelWarp = 0x220; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_pTextureSpecularWarp = 0x228; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_pTextureEnvMap = 0x230; // CStrongHandle<InfoForResourceTypeCTextureBase>
}

namespace C_OP_RenderStatusEffectCitadel {
    constexpr std::ptrdiff_t m_pTextureColorWarp = 0x200; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_pTextureNormal = 0x208; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_pTextureMetalness = 0x210; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_pTextureRoughness = 0x218; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_pTextureSelfIllum = 0x220; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_pTextureDetail = 0x228; // CStrongHandle<InfoForResourceTypeCTextureBase>
}

namespace C_OP_RenderText {
    constexpr std::ptrdiff_t m_OutlineColor = 0x200; // Color
    constexpr std::ptrdiff_t m_DefaultText = 0x208; // CUtlString
}

namespace C_OP_RenderTonemapController {
    constexpr std::ptrdiff_t m_flTonemapLevel = 0x200; // float
    constexpr std::ptrdiff_t m_flTonemapWeight = 0x204; // float
    constexpr std::ptrdiff_t m_nTonemapLevelField = 0x208; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nTonemapWeightField = 0x20C; // ParticleAttributeIndex_t
}

namespace C_OP_RenderTrails {
    constexpr std::ptrdiff_t m_bEnableFadingAndClamping = 0x2740; // bool
    constexpr std::ptrdiff_t m_flStartFadeDot = 0x2744; // float
    constexpr std::ptrdiff_t m_flEndFadeDot = 0x2748; // float
    constexpr std::ptrdiff_t m_nPrevPntSource = 0x274C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flMaxLength = 0x2750; // float
    constexpr std::ptrdiff_t m_flMinLength = 0x2754; // float
    constexpr std::ptrdiff_t m_bIgnoreDT = 0x2758; // bool
    constexpr std::ptrdiff_t m_flConstrainRadiusToLengthRatio = 0x275C; // float
    constexpr std::ptrdiff_t m_flLengthScale = 0x2760; // float
    constexpr std::ptrdiff_t m_flLengthFadeInTime = 0x2764; // float
    constexpr std::ptrdiff_t m_flRadiusHeadTaper = 0x2768; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_vecHeadColorScale = 0x28C0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_flHeadAlphaScale = 0x2F18; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flRadiusTaper = 0x3070; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_vecTailColorScale = 0x31C8; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_flTailAlphaScale = 0x3820; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nHorizCropField = 0x3978; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nVertCropField = 0x397C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flForwardShift = 0x3980; // float
    constexpr std::ptrdiff_t m_bFlipUVBasedOnPitchYaw = 0x3984; // bool
}

namespace C_OP_RenderTreeShake {
    constexpr std::ptrdiff_t m_flPeakStrength = 0x200; // float
    constexpr std::ptrdiff_t m_nPeakStrengthFieldOverride = 0x204; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flRadius = 0x208; // float
    constexpr std::ptrdiff_t m_nRadiusFieldOverride = 0x20C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flShakeDuration = 0x210; // float
    constexpr std::ptrdiff_t m_flTransitionTime = 0x214; // float
    constexpr std::ptrdiff_t m_flTwistAmount = 0x218; // float
    constexpr std::ptrdiff_t m_flRadialAmount = 0x21C; // float
    constexpr std::ptrdiff_t m_flControlPointOrientationAmount = 0x220; // float
    constexpr std::ptrdiff_t m_nControlPointForLinearDirection = 0x224; // int32_t
}

namespace C_OP_RenderVRHapticEvent {
    constexpr std::ptrdiff_t m_nHand = 0x200; // ParticleVRHandChoiceList_t
    constexpr std::ptrdiff_t m_nOutputHandCP = 0x204; // int32_t
    constexpr std::ptrdiff_t m_nOutputField = 0x208; // int32_t
    constexpr std::ptrdiff_t m_flAmplitude = 0x210; // CPerParticleFloatInput
}

namespace C_OP_RepeatedTriggerChildGroup {
    constexpr std::ptrdiff_t m_nChildGroupID = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_flClusterRefireTime = 0x1D8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flClusterSize = 0x330; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flClusterCooldown = 0x488; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bLimitChildCount = 0x5E0; // bool
}

namespace C_OP_RestartAfterDuration {
    constexpr std::ptrdiff_t m_flDurationMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_flDurationMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_nCP = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nCPField = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_nChildGroupID = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_bOnlyChildren = 0x1D4; // bool
}

namespace C_OP_RopeSpringConstraint {
    constexpr std::ptrdiff_t m_flRestLength = 0x1C0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flMinDistance = 0x318; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flMaxDistance = 0x470; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flAdjustmentScale = 0x5C8; // float
    constexpr std::ptrdiff_t m_flInitialRestingLength = 0x5D0; // CParticleCollectionFloatInput
}

namespace C_OP_RotateVector {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vecRotAxisMin = 0x1C4; // Vector
    constexpr std::ptrdiff_t m_vecRotAxisMax = 0x1D0; // Vector
    constexpr std::ptrdiff_t m_flRotRateMin = 0x1DC; // float
    constexpr std::ptrdiff_t m_flRotRateMax = 0x1E0; // float
    constexpr std::ptrdiff_t m_bNormalize = 0x1E4; // bool
    constexpr std::ptrdiff_t m_flScale = 0x1E8; // CPerParticleFloatInput
}

namespace C_OP_RtEnvCull {
    constexpr std::ptrdiff_t m_vecTestDir = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_vecTestNormal = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_bCullOnMiss = 0x1D8; // bool
    constexpr std::ptrdiff_t m_bStickInsteadOfCull = 0x1D9; // bool
    constexpr std::ptrdiff_t m_RtEnvName = 0x1DA; // char[128]
    constexpr std::ptrdiff_t m_nRTEnvCP = 0x25C; // int32_t
    constexpr std::ptrdiff_t m_nComponent = 0x260; // int32_t
}

namespace C_OP_SDFConstraint {
    constexpr std::ptrdiff_t m_flMinDist = 0x1C0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flMaxDist = 0x318; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nMaxIterations = 0x470; // int32_t
}

namespace C_OP_SDFForce {
    constexpr std::ptrdiff_t m_flForceScale = 0x1D0; // float
}

namespace C_OP_SDFLighting {
    constexpr std::ptrdiff_t m_vLightingDir = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_vTint_0 = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_vTint_1 = 0x1D8; // Vector
}

namespace C_OP_SelectivelyEnableChildren {
    constexpr std::ptrdiff_t m_nChildGroupID = 0x1D0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nFirstChild = 0x328; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nNumChildrenToEnable = 0x480; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bPlayEndcapOnStop = 0x5D8; // bool
    constexpr std::ptrdiff_t m_bDestroyImmediately = 0x5D9; // bool
}

namespace C_OP_SequenceFromModel {
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutputAnim = 0x1C8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1CC; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D4; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D8; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x1DC; // ParticleSetMethod_t
}

namespace C_OP_SetAttributeToScalarExpression {
    constexpr std::ptrdiff_t m_nExpression = 0x1C0; // ScalarExpressionType_t
    constexpr std::ptrdiff_t m_flInput1 = 0x1C8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flInput2 = 0x320; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nOutputField = 0x478; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSetMethod = 0x47C; // ParticleSetMethod_t
}

namespace C_OP_SetCPOrientationToDirection {
    constexpr std::ptrdiff_t m_nInputControlPoint = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nOutputControlPoint = 0x1C4; // int32_t
}

namespace C_OP_SetCPOrientationToGroundNormal {
    constexpr std::ptrdiff_t m_flInterpRate = 0x1C0; // float
    constexpr std::ptrdiff_t m_flMaxTraceLength = 0x1C4; // float
    constexpr std::ptrdiff_t m_flTolerance = 0x1C8; // float
    constexpr std::ptrdiff_t m_flTraceOffset = 0x1CC; // float
    constexpr std::ptrdiff_t m_CollisionGroupName = 0x1D0; // char[128]
    constexpr std::ptrdiff_t m_nTraceSet = 0x250; // ParticleTraceSet_t
    constexpr std::ptrdiff_t m_nInputCP = 0x254; // int32_t
    constexpr std::ptrdiff_t m_nOutputCP = 0x258; // int32_t
    constexpr std::ptrdiff_t m_bIncludeWater = 0x268; // bool
}

namespace C_OP_SetCPOrientationToPointAtCP {
    constexpr std::ptrdiff_t m_nInputCP = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nOutputCP = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_flInterpolation = 0x1D8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_b2DOrientation = 0x330; // bool
    constexpr std::ptrdiff_t m_bAvoidSingularity = 0x331; // bool
    constexpr std::ptrdiff_t m_bPointAway = 0x332; // bool
}

namespace C_OP_SetCPtoVector {
    constexpr std::ptrdiff_t m_nCPInput = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
}

namespace C_OP_SetChildControlPoints {
    constexpr std::ptrdiff_t m_nChildGroupID = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFirstControlPoint = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nNumControlPoints = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nFirstSourcePoint = 0x1D0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bReverse = 0x328; // bool
    constexpr std::ptrdiff_t m_bSetOrientation = 0x329; // bool
}

namespace C_OP_SetControlPointFieldFromVectorExpression {
    constexpr std::ptrdiff_t m_nExpression = 0x1D0; // VectorFloatExpressionType_t
    constexpr std::ptrdiff_t m_vecInput1 = 0x1D8; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_vecInput2 = 0x830; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_flOutputRemap = 0xE88; // CParticleRemapFloatInput
    constexpr std::ptrdiff_t m_nOutputCP = 0xFE0; // int32_t
    constexpr std::ptrdiff_t m_nOutVectorField = 0xFE4; // int32_t
}

namespace C_OP_SetControlPointFieldToScalarExpression {
    constexpr std::ptrdiff_t m_nExpression = 0x1D0; // ScalarExpressionType_t
    constexpr std::ptrdiff_t m_flInput1 = 0x1D8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flInput2 = 0x330; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flOutputRemap = 0x488; // CParticleRemapFloatInput
    constexpr std::ptrdiff_t m_nOutputCP = 0x5E0; // int32_t
    constexpr std::ptrdiff_t m_nOutVectorField = 0x5E4; // int32_t
}

namespace C_OP_SetControlPointFieldToWater {
    constexpr std::ptrdiff_t m_nSourceCP = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nDestCP = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nCPField = 0x1D8; // int32_t
}

namespace C_OP_SetControlPointFromObjectScale {
    constexpr std::ptrdiff_t m_nCPInput = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nCPOutput = 0x1D4; // int32_t
}

namespace C_OP_SetControlPointOrientation {
    constexpr std::ptrdiff_t m_bUseWorldLocation = 0x1D0; // bool
    constexpr std::ptrdiff_t m_bRandomize = 0x1D2; // bool
    constexpr std::ptrdiff_t m_bSetOnce = 0x1D3; // bool
    constexpr std::ptrdiff_t m_nCP = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nHeadLocation = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_vecRotation = 0x1DC; // QAngle
    constexpr std::ptrdiff_t m_vecRotationB = 0x1E8; // QAngle
    constexpr std::ptrdiff_t m_flInterpolation = 0x1F8; // CParticleCollectionFloatInput
}

namespace C_OP_SetControlPointOrientationToCPVelocity {
    constexpr std::ptrdiff_t m_nCPInput = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nCPOutput = 0x1D4; // int32_t
}

namespace C_OP_SetControlPointPositionToRandomActiveCP {
    constexpr std::ptrdiff_t m_nCP1 = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nHeadLocationMin = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nHeadLocationMax = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_flResetRate = 0x1E0; // CParticleCollectionFloatInput
}

namespace C_OP_SetControlPointPositionToTimeOfDayValue {
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_pszTimeOfDayParameter = 0x1D4; // char[128]
    constexpr std::ptrdiff_t m_vecDefaultValue = 0x254; // Vector
}

namespace C_OP_SetControlPointPositions {
    constexpr std::ptrdiff_t m_bUseWorldLocation = 0x1D0; // bool
    constexpr std::ptrdiff_t m_bOrient = 0x1D1; // bool
    constexpr std::ptrdiff_t m_bSetOnce = 0x1D2; // bool
    constexpr std::ptrdiff_t m_nCP1 = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nCP2 = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_nCP3 = 0x1DC; // int32_t
    constexpr std::ptrdiff_t m_nCP4 = 0x1E0; // int32_t
    constexpr std::ptrdiff_t m_vecCP1Pos = 0x1E4; // Vector
    constexpr std::ptrdiff_t m_vecCP2Pos = 0x1F0; // Vector
    constexpr std::ptrdiff_t m_vecCP3Pos = 0x1FC; // Vector
    constexpr std::ptrdiff_t m_vecCP4Pos = 0x208; // Vector
    constexpr std::ptrdiff_t m_nHeadLocation = 0x214; // int32_t
}

namespace C_OP_SetControlPointRotation {
    constexpr std::ptrdiff_t m_vecRotAxis = 0x1D0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_flRotRate = 0x828; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nCP = 0x980; // int32_t
    constexpr std::ptrdiff_t m_nLocalCP = 0x984; // int32_t
}

namespace C_OP_SetControlPointToCPVelocity {
    constexpr std::ptrdiff_t m_nCPInput = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nCPOutputVel = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_bNormalize = 0x1D8; // bool
    constexpr std::ptrdiff_t m_nCPOutputMag = 0x1DC; // int32_t
    constexpr std::ptrdiff_t m_nCPField = 0x1E0; // int32_t
    constexpr std::ptrdiff_t m_vecComparisonVelocity = 0x1E8; // CParticleCollectionVecInput
}

namespace C_OP_SetControlPointToCenter {
    constexpr std::ptrdiff_t m_nCP1 = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_vecCP1Pos = 0x1D4; // Vector
    constexpr std::ptrdiff_t m_nSetParent = 0x1E0; // ParticleParentSetMode_t
}

namespace C_OP_SetControlPointToHMD {
    constexpr std::ptrdiff_t m_nCP1 = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_vecCP1Pos = 0x1D4; // Vector
    constexpr std::ptrdiff_t m_bOrientToHMD = 0x1E0; // bool
}

namespace C_OP_SetControlPointToHand {
    constexpr std::ptrdiff_t m_nCP1 = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nHand = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_vecCP1Pos = 0x1D8; // Vector
    constexpr std::ptrdiff_t m_bOrientToHand = 0x1E4; // bool
}

namespace C_OP_SetControlPointToImpactPoint {
    constexpr std::ptrdiff_t m_nCPOut = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nCPIn = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_flUpdateRate = 0x1D8; // float
    constexpr std::ptrdiff_t m_flTraceLength = 0x1E0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flStartOffset = 0x338; // float
    constexpr std::ptrdiff_t m_flOffset = 0x33C; // float
    constexpr std::ptrdiff_t m_vecTraceDir = 0x340; // Vector
    constexpr std::ptrdiff_t m_CollisionGroupName = 0x34C; // char[128]
    constexpr std::ptrdiff_t m_nTraceSet = 0x3CC; // ParticleTraceSet_t
    constexpr std::ptrdiff_t m_bSetToEndpoint = 0x3D0; // bool
    constexpr std::ptrdiff_t m_bTraceToClosestSurface = 0x3D1; // bool
    constexpr std::ptrdiff_t m_bIncludeWater = 0x3D2; // bool
}

namespace C_OP_SetControlPointToPlayer {
    constexpr std::ptrdiff_t m_nCP1 = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_vecCP1Pos = 0x1D4; // Vector
    constexpr std::ptrdiff_t m_bOrientToEyes = 0x1E0; // bool
}

namespace C_OP_SetControlPointToVectorExpression {
    constexpr std::ptrdiff_t m_nExpression = 0x1D0; // VectorExpressionType_t
    constexpr std::ptrdiff_t m_nOutputCP = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_vInput1 = 0x1D8; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_vInput2 = 0x830; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_bNormalizedOutput = 0xE88; // bool
}

namespace C_OP_SetControlPointToWaterSurface {
    constexpr std::ptrdiff_t m_nSourceCP = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nDestCP = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nFlowCP = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_nActiveCP = 0x1DC; // int32_t
    constexpr std::ptrdiff_t m_nActiveCPField = 0x1E0; // int32_t
    constexpr std::ptrdiff_t m_flRetestRate = 0x1E8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bAdaptiveThreshold = 0x340; // bool
}

namespace C_OP_SetControlPointsToModelParticles {
    constexpr std::ptrdiff_t m_HitboxSetName = 0x1C0; // char[128]
    constexpr std::ptrdiff_t m_AttachmentName = 0x240; // char[128]
    constexpr std::ptrdiff_t m_nFirstControlPoint = 0x2C0; // int32_t
    constexpr std::ptrdiff_t m_nNumControlPoints = 0x2C4; // int32_t
    constexpr std::ptrdiff_t m_nFirstSourcePoint = 0x2C8; // int32_t
    constexpr std::ptrdiff_t m_bSkin = 0x2CC; // bool
    constexpr std::ptrdiff_t m_bAttachment = 0x2CD; // bool
}

namespace C_OP_SetControlPointsToParticle {
    constexpr std::ptrdiff_t m_nChildGroupID = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFirstControlPoint = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nNumControlPoints = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nFirstSourcePoint = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_bSetOrientation = 0x1D0; // bool
    constexpr std::ptrdiff_t m_nOrientationMode = 0x1D4; // ParticleOrientationSetMode_t
    constexpr std::ptrdiff_t m_nSetParent = 0x1D8; // ParticleParentSetMode_t
}

namespace C_OP_SetFloat {
    constexpr std::ptrdiff_t m_InputValue = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nOutputField = 0x318; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSetMethod = 0x31C; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_Lerp = 0x320; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_bUseNewCode = 0x478; // bool
}

namespace C_OP_SetFloatAttributeToVectorExpression {
    constexpr std::ptrdiff_t m_nExpression = 0x1C0; // VectorFloatExpressionType_t
    constexpr std::ptrdiff_t m_vInput1 = 0x1C8; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vInput2 = 0x820; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_flOutputRemap = 0xE78; // CParticleRemapFloatInput
    constexpr std::ptrdiff_t m_nOutputField = 0xFD0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSetMethod = 0xFD4; // ParticleSetMethod_t
}

namespace C_OP_SetFloatCollection {
    constexpr std::ptrdiff_t m_InputValue = 0x1C0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nOutputField = 0x318; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSetMethod = 0x31C; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_Lerp = 0x320; // CParticleCollectionFloatInput
}

namespace C_OP_SetFromCPSnapshot {
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nAttributeToRead = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nAttributeToWrite = 0x1C8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nLocalSpaceCP = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_bRandom = 0x1D0; // bool
    constexpr std::ptrdiff_t m_bReverse = 0x1D1; // bool
    constexpr std::ptrdiff_t m_nRandomSeed = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nSnapShotStartPoint = 0x1D8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nSnapShotIncrement = 0x330; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flInterpolation = 0x488; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_bSubSample = 0x5E0; // bool
}

namespace C_OP_SetGravityToCP {
    constexpr std::ptrdiff_t m_nCPInput = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nCPOutput = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_flScale = 0x1D8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bSetOrientation = 0x330; // bool
    constexpr std::ptrdiff_t m_bSetZDown = 0x331; // bool
}

namespace C_OP_SetParentControlPointsToChildCP {
    constexpr std::ptrdiff_t m_nChildGroupID = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nChildControlPoint = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nNumControlPoints = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_nFirstSourcePoint = 0x1DC; // int32_t
    constexpr std::ptrdiff_t m_bSetOrientation = 0x1E0; // bool
}

namespace C_OP_SetPerChildControlPoint {
    constexpr std::ptrdiff_t m_nChildGroupID = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFirstControlPoint = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nNumControlPoints = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nParticleIncrement = 0x1D0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nFirstSourcePoint = 0x328; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bSetOrientation = 0x480; // bool
    constexpr std::ptrdiff_t m_nOrientationField = 0x484; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bNumBasedOnParticleCount = 0x488; // bool
}

namespace C_OP_SetPerChildControlPointFromAttribute {
    constexpr std::ptrdiff_t m_nChildGroupID = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFirstControlPoint = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nNumControlPoints = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nParticleIncrement = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_nFirstSourcePoint = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_bNumBasedOnParticleCount = 0x1D4; // bool
    constexpr std::ptrdiff_t m_nAttributeToRead = 0x1D8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nCPField = 0x1DC; // int32_t
}

namespace C_OP_SetRandomControlPointPosition {
    constexpr std::ptrdiff_t m_bUseWorldLocation = 0x1D0; // bool
    constexpr std::ptrdiff_t m_bOrient = 0x1D1; // bool
    constexpr std::ptrdiff_t m_nCP1 = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nHeadLocation = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_flReRandomRate = 0x1E0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_vecCPMinPos = 0x338; // Vector
    constexpr std::ptrdiff_t m_vecCPMaxPos = 0x344; // Vector
    constexpr std::ptrdiff_t m_flInterpolation = 0x350; // CParticleCollectionFloatInput
}

namespace C_OP_SetSimulationRate {
    constexpr std::ptrdiff_t m_flSimulationScale = 0x1D0; // CParticleCollectionFloatInput
}

namespace C_OP_SetSingleControlPointPosition {
    constexpr std::ptrdiff_t m_bSetOnce = 0x1D0; // bool
    constexpr std::ptrdiff_t m_nCP1 = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_vecCP1Pos = 0x1D8; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_transformInput = 0x830; // CParticleTransformInput
}

namespace C_OP_SetToCP {
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_vecOffset = 0x1C4; // Vector
    constexpr std::ptrdiff_t m_bOffsetLocal = 0x1D0; // bool
}

namespace C_OP_SetVariable {
    constexpr std::ptrdiff_t m_variableReference = 0x1D0; // CParticleVariableRef
    constexpr std::ptrdiff_t m_transformInput = 0x210; // CParticleTransformInput
    constexpr std::ptrdiff_t m_positionOffset = 0x278; // Vector
    constexpr std::ptrdiff_t m_rotationOffset = 0x284; // QAngle
    constexpr std::ptrdiff_t m_vecInput = 0x290; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_floatInput = 0x8E8; // CParticleCollectionFloatInput
}

namespace C_OP_SetVec {
    constexpr std::ptrdiff_t m_InputValue = 0x1C0; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_nOutputField = 0x818; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSetMethod = 0x81C; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_Lerp = 0x820; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_bNormalizedOutput = 0x978; // bool
}

namespace C_OP_SetVectorAttributeToVectorExpression {
    constexpr std::ptrdiff_t m_nExpression = 0x1C0; // VectorExpressionType_t
    constexpr std::ptrdiff_t m_vInput1 = 0x1C8; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vInput2 = 0x820; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_nOutputField = 0xE78; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSetMethod = 0xE7C; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bNormalizedOutput = 0xE80; // bool
}

namespace C_OP_ShapeMatchingConstraint {
    constexpr std::ptrdiff_t m_flShapeRestorationTime = 0x1C0; // float
}

namespace C_OP_SnapshotRigidSkinToBones {
    constexpr std::ptrdiff_t m_bTransformNormals = 0x1C0; // bool
    constexpr std::ptrdiff_t m_bTransformRadii = 0x1C1; // bool
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C4; // int32_t
}

namespace C_OP_SnapshotSkinToBones {
    constexpr std::ptrdiff_t m_bTransformNormals = 0x1C0; // bool
    constexpr std::ptrdiff_t m_bTransformRadii = 0x1C1; // bool
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_flLifeTimeFadeStart = 0x1C8; // float
    constexpr std::ptrdiff_t m_flLifeTimeFadeEnd = 0x1CC; // float
    constexpr std::ptrdiff_t m_flJumpThreshold = 0x1D0; // float
    constexpr std::ptrdiff_t m_flPrevPosScale = 0x1D4; // float
}

namespace C_OP_SpringToVectorConstraint {
    constexpr std::ptrdiff_t m_flRestLength = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flMinDistance = 0x318; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flMaxDistance = 0x470; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flRestingLength = 0x5C8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_vecAnchorVector = 0x720; // CPerParticleVecInput
}

namespace C_OP_StopAfterCPDuration {
    constexpr std::ptrdiff_t m_flDuration = 0x1D0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bDestroyImmediately = 0x328; // bool
    constexpr std::ptrdiff_t m_bPlayEndCap = 0x329; // bool
}

namespace C_OP_TeleportBeam {
    constexpr std::ptrdiff_t m_nCPPosition = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nCPVelocity = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nCPMisc = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nCPColor = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_nCPInvalidColor = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nCPExtraArcData = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_vGravity = 0x1D8; // Vector
    constexpr std::ptrdiff_t m_flArcMaxDuration = 0x1E4; // float
    constexpr std::ptrdiff_t m_flSegmentBreak = 0x1E8; // float
    constexpr std::ptrdiff_t m_flArcSpeed = 0x1EC; // float
    constexpr std::ptrdiff_t m_flAlpha = 0x1F0; // float
}

namespace C_OP_TimeVaryingForce {
    constexpr std::ptrdiff_t m_flStartLerpTime = 0x1D0; // float
    constexpr std::ptrdiff_t m_StartingForce = 0x1D4; // Vector
    constexpr std::ptrdiff_t m_flEndLerpTime = 0x1E0; // float
    constexpr std::ptrdiff_t m_EndingForce = 0x1E4; // Vector
}

namespace C_OP_TurbulenceForce {
    constexpr std::ptrdiff_t m_flNoiseCoordScale0 = 0x1D0; // float
    constexpr std::ptrdiff_t m_flNoiseCoordScale1 = 0x1D4; // float
    constexpr std::ptrdiff_t m_flNoiseCoordScale2 = 0x1D8; // float
    constexpr std::ptrdiff_t m_flNoiseCoordScale3 = 0x1DC; // float
    constexpr std::ptrdiff_t m_vecNoiseAmount0 = 0x1E0; // Vector
    constexpr std::ptrdiff_t m_vecNoiseAmount1 = 0x1EC; // Vector
    constexpr std::ptrdiff_t m_vecNoiseAmount2 = 0x1F8; // Vector
    constexpr std::ptrdiff_t m_vecNoiseAmount3 = 0x204; // Vector
}

namespace C_OP_TwistAroundAxis {
    constexpr std::ptrdiff_t m_fForceAmount = 0x1D0; // float
    constexpr std::ptrdiff_t m_TwistAxis = 0x1D4; // Vector
    constexpr std::ptrdiff_t m_bLocalSpace = 0x1E0; // bool
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1E4; // int32_t
}

namespace C_OP_UpdateLightSource {
    constexpr std::ptrdiff_t m_vColorTint = 0x1C0; // Color
    constexpr std::ptrdiff_t m_flBrightnessScale = 0x1C4; // float
    constexpr std::ptrdiff_t m_flRadiusScale = 0x1C8; // float
    constexpr std::ptrdiff_t m_flMinimumLightingRadius = 0x1CC; // float
    constexpr std::ptrdiff_t m_flMaximumLightingRadius = 0x1D0; // float
    constexpr std::ptrdiff_t m_flPositionDampingConstant = 0x1D4; // float
}

namespace C_OP_VectorFieldSnapshot {
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nAttributeToWrite = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nLocalSpaceCP = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_flInterpolation = 0x1D0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_vecScale = 0x328; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_flBoundaryDampening = 0x980; // float
    constexpr std::ptrdiff_t m_bSetVelocity = 0x984; // bool
    constexpr std::ptrdiff_t m_bLockToSurface = 0x985; // bool
    constexpr std::ptrdiff_t m_flGridSpacing = 0x988; // float
}

namespace C_OP_VectorNoise {
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vecOutputMin = 0x1C4; // Vector
    constexpr std::ptrdiff_t m_vecOutputMax = 0x1D0; // Vector
    constexpr std::ptrdiff_t m_fl4NoiseScale = 0x1DC; // float
    constexpr std::ptrdiff_t m_bAdditive = 0x1E0; // bool
    constexpr std::ptrdiff_t m_bOffset = 0x1E1; // bool
    constexpr std::ptrdiff_t m_flNoiseAnimationTimeScale = 0x1E4; // float
}

namespace C_OP_VelocityDecay {
    constexpr std::ptrdiff_t m_flMinVelocity = 0x1C0; // float
}

namespace C_OP_VelocityMatchingForce {
    constexpr std::ptrdiff_t m_flDirScale = 0x1C0; // float
    constexpr std::ptrdiff_t m_flSpdScale = 0x1C4; // float
    constexpr std::ptrdiff_t m_nCPBroadcast = 0x1C8; // int32_t
}

namespace C_OP_WindForce {
    constexpr std::ptrdiff_t m_vForce = 0x1D0; // Vector
}

namespace C_OP_WorldTraceConstraint {
    constexpr std::ptrdiff_t m_nCP = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_vecCpOffset = 0x1C4; // Vector
    constexpr std::ptrdiff_t m_nCollisionMode = 0x1D0; // ParticleCollisionMode_t
    constexpr std::ptrdiff_t m_nCollisionModeMin = 0x1D4; // ParticleCollisionMode_t
    constexpr std::ptrdiff_t m_nTraceSet = 0x1D8; // ParticleTraceSet_t
    constexpr std::ptrdiff_t m_CollisionGroupName = 0x1DC; // char[128]
    constexpr std::ptrdiff_t m_bWorldOnly = 0x25C; // bool
    constexpr std::ptrdiff_t m_bBrushOnly = 0x25D; // bool
    constexpr std::ptrdiff_t m_bIncludeWater = 0x25E; // bool
    constexpr std::ptrdiff_t m_nIgnoreCP = 0x260; // int32_t
    constexpr std::ptrdiff_t m_flCpMovementTolerance = 0x264; // float
    constexpr std::ptrdiff_t m_flRetestRate = 0x268; // float
    constexpr std::ptrdiff_t m_flTraceTolerance = 0x26C; // float
    constexpr std::ptrdiff_t m_flCollisionConfirmationSpeed = 0x270; // float
    constexpr std::ptrdiff_t m_nMaxTracesPerFrame = 0x274; // float
    constexpr std::ptrdiff_t m_flRadiusScale = 0x278; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flBounceAmount = 0x3D0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flSlideAmount = 0x528; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flRandomDirScale = 0x680; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_bDecayBounce = 0x7D8; // bool
    constexpr std::ptrdiff_t m_bKillonContact = 0x7D9; // bool
    constexpr std::ptrdiff_t m_flMinSpeed = 0x7DC; // float
    constexpr std::ptrdiff_t m_bSetNormal = 0x7E0; // bool
    constexpr std::ptrdiff_t m_nStickOnCollisionField = 0x7E4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flStopSpeed = 0x7E8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nEntityStickDataField = 0x940; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nEntityStickNormalField = 0x944; // ParticleAttributeIndex_t
}

namespace CollisionGroupContext_t {
    constexpr std::ptrdiff_t m_nCollisionGroupNumber = 0x0; // int32_t
}

namespace ControlPointReference_t {
    constexpr std::ptrdiff_t m_controlPointNameString = 0x0; // int32_t
    constexpr std::ptrdiff_t m_vOffsetFromControlPoint = 0x4; // Vector
    constexpr std::ptrdiff_t m_bOffsetInLocalSpace = 0x10; // bool
}

namespace FloatInputMaterialVariable_t {
    constexpr std::ptrdiff_t m_strVariable = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_flInput = 0x8; // CParticleCollectionFloatInput
}

namespace MaterialVariable_t {
    constexpr std::ptrdiff_t m_strVariable = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nVariableField = 0x8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flScale = 0xC; // float
}

namespace ModelReference_t {
    constexpr std::ptrdiff_t m_model = 0x0; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_flRelativeProbabilityOfSpawn = 0x8; // float
}

namespace PARTICLE_EHANDLE__ {
    constexpr std::ptrdiff_t unused = 0x0; // int32_t
}

namespace PARTICLE_WORLD_HANDLE__ {
    constexpr std::ptrdiff_t unused = 0x0; // int32_t
}

namespace ParticleAttributeIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace ParticleChildrenInfo_t {
    constexpr std::ptrdiff_t m_ChildRef = 0x0; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_flDelay = 0x8; // float
    constexpr std::ptrdiff_t m_bEndCap = 0xC; // bool
    constexpr std::ptrdiff_t m_bDisableChild = 0xD; // bool
    constexpr std::ptrdiff_t m_nDetailLevel = 0x10; // ParticleDetailLevel_t
}

namespace ParticleControlPointConfiguration_t {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_drivers = 0x8; // CUtlVector<ParticleControlPointDriver_t>
    constexpr std::ptrdiff_t m_previewState = 0x20; // ParticlePreviewState_t
}

namespace ParticleControlPointDriver_t {
    constexpr std::ptrdiff_t m_iControlPoint = 0x0; // int32_t
    constexpr std::ptrdiff_t m_iAttachType = 0x4; // ParticleAttachment_t
    constexpr std::ptrdiff_t m_attachmentName = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_vecOffset = 0x10; // Vector
    constexpr std::ptrdiff_t m_angOffset = 0x1C; // QAngle
    constexpr std::ptrdiff_t m_entityName = 0x28; // CUtlString
}

namespace ParticleNamedValueConfiguration_t {
    constexpr std::ptrdiff_t m_ConfigName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_ConfigValue = 0x8; // KeyValues3
    constexpr std::ptrdiff_t m_iAttachType = 0x18; // ParticleAttachment_t
    constexpr std::ptrdiff_t m_BoundEntityPath = 0x20; // CUtlString
    constexpr std::ptrdiff_t m_strEntityScope = 0x28; // CUtlString
    constexpr std::ptrdiff_t m_strAttachmentName = 0x30; // CUtlString
}

namespace ParticleNamedValueSource_t {
    constexpr std::ptrdiff_t m_Name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_IsPublic = 0x8; // bool
    constexpr std::ptrdiff_t m_ValueType = 0xC; // PulseValueType_t
    constexpr std::ptrdiff_t m_DefaultConfig = 0x10; // ParticleNamedValueConfiguration_t
    constexpr std::ptrdiff_t m_NamedConfigs = 0x48; // CUtlVector<ParticleNamedValueConfiguration_t>
}

namespace ParticlePreviewBodyGroup_t {
    constexpr std::ptrdiff_t m_bodyGroupName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nValue = 0x8; // int32_t
}

namespace ParticlePreviewState_t {
    constexpr std::ptrdiff_t m_previewModel = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nModSpecificData = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_groundType = 0xC; // PetGroundType_t
    constexpr std::ptrdiff_t m_sequenceName = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_nFireParticleOnSequenceFrame = 0x18; // int32_t
    constexpr std::ptrdiff_t m_hitboxSetName = 0x20; // CUtlString
    constexpr std::ptrdiff_t m_materialGroupName = 0x28; // CUtlString
    constexpr std::ptrdiff_t m_vecBodyGroups = 0x30; // CUtlVector<ParticlePreviewBodyGroup_t>
    constexpr std::ptrdiff_t m_flPlaybackSpeed = 0x48; // float
    constexpr std::ptrdiff_t m_flParticleSimulationRate = 0x4C; // float
    constexpr std::ptrdiff_t m_bShouldDrawHitboxes = 0x50; // bool
    constexpr std::ptrdiff_t m_bShouldDrawAttachments = 0x51; // bool
    constexpr std::ptrdiff_t m_bShouldDrawAttachmentNames = 0x52; // bool
    constexpr std::ptrdiff_t m_bShouldDrawControlPointAxes = 0x53; // bool
    constexpr std::ptrdiff_t m_bAnimationNonLooping = 0x54; // bool
    constexpr std::ptrdiff_t m_vecPreviewGravity = 0x58; // Vector
}

namespace PointDefinitionWithTimeValues_t {
    constexpr std::ptrdiff_t m_flTimeDuration = 0x14; // float
}

namespace PointDefinition_t {
    constexpr std::ptrdiff_t m_nControlPoint = 0x0; // int32_t
    constexpr std::ptrdiff_t m_bLocalCoords = 0x4; // bool
    constexpr std::ptrdiff_t m_vOffset = 0x8; // Vector
}

namespace SequenceWeightedList_t {
    constexpr std::ptrdiff_t m_nSequence = 0x0; // int32_t
    constexpr std::ptrdiff_t m_flRelativeWeight = 0x4; // float
}

namespace TextureControls_t {
    constexpr std::ptrdiff_t m_flFinalTextureScaleU = 0x0; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flFinalTextureScaleV = 0x158; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flFinalTextureOffsetU = 0x2B0; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flFinalTextureOffsetV = 0x408; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flFinalTextureUVRotation = 0x560; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flZoomScale = 0x6B8; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flDistortion = 0x810; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_bRandomizeOffsets = 0x968; // bool
    constexpr std::ptrdiff_t m_bClampUVs = 0x969; // bool
    constexpr std::ptrdiff_t m_nPerParticleBlend = 0x96C; // SpriteCardPerParticleScale_t
    constexpr std::ptrdiff_t m_nPerParticleScale = 0x970; // SpriteCardPerParticleScale_t
    constexpr std::ptrdiff_t m_nPerParticleOffsetU = 0x974; // SpriteCardPerParticleScale_t
    constexpr std::ptrdiff_t m_nPerParticleOffsetV = 0x978; // SpriteCardPerParticleScale_t
    constexpr std::ptrdiff_t m_nPerParticleRotation = 0x97C; // SpriteCardPerParticleScale_t
    constexpr std::ptrdiff_t m_nPerParticleZoom = 0x980; // SpriteCardPerParticleScale_t
    constexpr std::ptrdiff_t m_nPerParticleDistortion = 0x984; // SpriteCardPerParticleScale_t
}

namespace TextureGroup_t {
    constexpr std::ptrdiff_t m_bEnabled = 0x0; // bool
    constexpr std::ptrdiff_t m_bReplaceTextureWithGradient = 0x1; // bool
    constexpr std::ptrdiff_t m_hTexture = 0x8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_Gradient = 0x10; // CColorGradient
    constexpr std::ptrdiff_t m_nTextureType = 0x28; // SpriteCardTextureType_t
    constexpr std::ptrdiff_t m_nTextureChannels = 0x2C; // SpriteCardTextureChannel_t
    constexpr std::ptrdiff_t m_nTextureBlendMode = 0x30; // ParticleTextureLayerBlendType_t
    constexpr std::ptrdiff_t m_flTextureBlend = 0x38; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_TextureControls = 0x190; // TextureControls_t
}

namespace VecInputMaterialVariable_t {
    constexpr std::ptrdiff_t m_strVariable = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_vecInput = 0x8; // CParticleCollectionVecInput
}
```

`SDK/particles.dll.json`:

```json
{
  "CBaseRendererSource2": {
    "m_bAnimateInFPS": 3920,
    "m_bBlendFramesSeq0": 8736,
    "m_bDisableZBuffering": 7688,
    "m_bGammaCorrectVertexColors": 4628,
    "m_bMaxLuminanceBlendingSequence0": 8737,
    "m_bOnlyRenderInEffecsGameOverlay": 7427,
    "m_bOnlyRenderInEffectsBloomPass": 7424,
    "m_bOnlyRenderInEffectsWaterPass": 7425,
    "m_bRefract": 7064,
    "m_bRefractSolid": 7065,
    "m_bReverseZBuffering": 7687,
    "m_bSaturateColorPreAlphaBlend": 4629,
    "m_bStencilTestExclude": 7556,
    "m_bTintByFOW": 6016,
    "m_bTintByGlobalLight": 6017,
    "m_bUseMixedResolutionRendering": 7426,
    "m_bWriteStencilOnDepthFail": 7686,
    "m_bWriteStencilOnDepthPass": 7685,
    "m_flAddSelfAmount": 4632,
    "m_flAlphaReferenceSoftness": 6032,
    "m_flAlphaScale": 856,
    "m_flAnimationRate": 3912,
    "m_flBumpStrength": 3880,
    "m_flCenterXOffset": 3192,
    "m_flCenterYOffset": 3536,
    "m_flDepthBias": 8728,
    "m_flDesaturation": 4976,
    "m_flDiffuseAmount": 4272,
    "m_flFeatheringFilter": 8384,
    "m_flFeatheringMaxDist": 8040,
    "m_flFeatheringMinDist": 7696,
    "m_flFogAmount": 5672,
    "m_flOverbrightFactor": 5320,
    "m_flRadiusScale": 512,
    "m_flRefractAmount": 7072,
    "m_flRollScale": 1200,
    "m_flSelfIllumAmount": 3928,
    "m_flSourceAlphaValueToMapToOne": 6720,
    "m_flSourceAlphaValueToMapToZero": 6376,
    "m_nAlpha2Field": 1544,
    "m_nAlphaReferenceType": 6028,
    "m_nAnimationType": 3916,
    "m_nColorBlendType": 3176,
    "m_nCropTextureOverride": 3884,
    "m_nFeatheringMode": 7692,
    "m_nFogType": 5668,
    "m_nHSVShiftControlPoint": 5664,
    "m_nLightingControlPoint": 4616,
    "m_nOutputBlendMode": 4624,
    "m_nPerParticleAlphaRefWindow": 6024,
    "m_nPerParticleAlphaReference": 6020,
    "m_nRefractBlurRadius": 7416,
    "m_nRefractBlurType": 7420,
    "m_nSelfIllumPerParticle": 4620,
    "m_nShaderType": 3180,
    "m_nSortMethod": 8732,
    "m_stencilTestID": 7428,
    "m_stencilWriteID": 7557,
    "m_strShaderOverride": 3184,
    "m_vecColorScale": 1552,
    "m_vecTexturesInput": 3888
  },
  "CBaseTrailRenderer": {
    "m_bClampV": 10032,
    "m_flEndFadeSize": 9688,
    "m_flMaxSize": 9340,
    "m_flMinSize": 9336,
    "m_flStartFadeSize": 9344,
    "m_nOrientationControlPoint": 9332,
    "m_nOrientationType": 9328
  },
  "CGeneralRandomRotation": {
    "m_bRandomlyFlipDirection": 468,
    "m_flDegrees": 452,
    "m_flDegreesMax": 460,
    "m_flDegreesMin": 456,
    "m_flRotationRandExponent": 464,
    "m_nFieldOutput": 448
  },
  "CGeneralSpin": {
    "m_fSpinRateStopTime": 460,
    "m_nSpinRateDegrees": 448,
    "m_nSpinRateMinDegrees": 452
  },
  "CNewParticleEffect": {
    "m_LastMax": 140,
    "m_LastMin": 128,
    "m_RefCount": 192,
    "m_bAllocated": 0,
    "m_bAutoUpdateBBox": 0,
    "m_bCanFreeze": 126,
    "m_bDisableAggregation": 0,
    "m_bDontRemove": 0,
    "m_bForceNoDraw": 0,
    "m_bFreezeTargetState": 125,
    "m_bFreezeTransitionActive": 124,
    "m_bIsFirstFrame": 0,
    "m_bNeedsBBoxUpdate": 0,
    "m_bRemove": 0,
    "m_bShouldCheckFoW": 0,
    "m_bShouldPerformCullCheck": 0,
    "m_bShouldSave": 0,
    "m_bShouldSimulateDuringGamePaused": 0,
    "m_bSimulate": 0,
    "m_flFreezeTransitionDuration": 116,
    "m_flFreezeTransitionOverride": 120,
    "m_flFreezeTransitionStart": 112,
    "m_flScale": 76,
    "m_hOwner": 80,
    "m_nSplitScreenUser": 152,
    "m_pDebugName": 40,
    "m_pNext": 16,
    "m_pOwningParticleProperty": 88,
    "m_pParticles": 32,
    "m_pPrev": 24,
    "m_vSortOrigin": 64,
    "m_vecAggregationCenter": 156
  },
  "CParticleFloatInput": {
    "m_Curve": 280,
    "m_NamedValue": 32,
    "m_bHasRandomSignFlip": 120,
    "m_bNoiseImgPreviewLive": 212,
    "m_bUseBoundsCenter": 228,
    "m_flBiasParameter": 276,
    "m_flInput0": 240,
    "m_flInput1": 244,
    "m_flLOD0": 136,
    "m_flLOD1": 140,
    "m_flLOD2": 144,
    "m_flLOD3": 148,
    "m_flLiteralValue": 24,
    "m_flMultFactor": 236,
    "m_flNoCameraFallback": 224,
    "m_flNoiseImgPreviewScale": 208,
    "m_flNoiseOffset": 180,
    "m_flNoiseOutputMax": 160,
    "m_flNoiseOutputMin": 156,
    "m_flNoiseScale": 164,
    "m_flNoiseTurbulenceMix": 204,
    "m_flNoiseTurbulenceScale": 200,
    "m_flNotchedOutputInside": 268,
    "m_flNotchedOutputOutside": 264,
    "m_flNotchedRangeMax": 260,
    "m_flNotchedRangeMin": 256,
    "m_flOutput0": 248,
    "m_flOutput1": 252,
    "m_flRandomMax": 116,
    "m_flRandomMin": 112,
    "m_nBiasType": 272,
    "m_nControlPoint": 96,
    "m_nInputMode": 232,
    "m_nMapType": 20,
    "m_nNoiseInputVectorAttribute": 152,
    "m_nNoiseModifier": 196,
    "m_nNoiseOctaves": 184,
    "m_nNoiseTurbulence": 188,
    "m_nNoiseType": 192,
    "m_nRandomMode": 128,
    "m_nRandomSeed": 124,
    "m_nScalarAttribute": 100,
    "m_nType": 16,
    "m_nVectorAttribute": 104,
    "m_nVectorComponent": 108,
    "m_vecNoiseOffsetRate": 168
  },
  "CParticleFunction": {
    "m_Notes": 408,
    "m_bDisableOperator": 406,
    "m_bNormalizeToStopTime": 376,
    "m_flOpEndFadeInTime": 360,
    "m_flOpEndFadeOutTime": 368,
    "m_flOpFadeOscillatePeriod": 372,
    "m_flOpStartFadeInTime": 356,
    "m_flOpStartFadeOutTime": 364,
    "m_flOpStrength": 8,
    "m_flOpTimeOffsetMax": 384,
    "m_flOpTimeOffsetMin": 380,
    "m_flOpTimeScaleMax": 400,
    "m_flOpTimeScaleMin": 396,
    "m_nOpEndCapState": 352,
    "m_nOpTimeOffsetSeed": 388,
    "m_nOpTimeScaleSeed": 392
  },
  "CParticleFunctionEmitter": {
    "m_nEmitterIndex": 440
  },
  "CParticleFunctionInitializer": {
    "m_nAssociatedEmitterIndex": 440
  },
  "CParticleFunctionPreEmission": {
    "m_bRunOnce": 448
  },
  "CParticleFunctionRenderer": {
    "VisibilityInputs": 440,
    "m_bCannotBeRefracted": 508,
    "m_bSkipRenderingOnMobile": 509
  },
  "CParticleModelInput": {
    "m_NamedValue": 24,
    "m_nControlPoint": 88,
    "m_nType": 16
  },
  "CParticleSystemDefinition": {
    "m_BoundingBoxMax": 552,
    "m_BoundingBoxMin": 540,
    "m_Children": 184,
    "m_ConstantColor": 608,
    "m_ConstantNormal": 612,
    "m_Constraints": 136,
    "m_Emitters": 40,
    "m_ForceGenerators": 112,
    "m_Initializers": 64,
    "m_NamedValueDomain": 576,
    "m_NamedValueLocals": 584,
    "m_Operators": 88,
    "m_PreEmissionOperators": 16,
    "m_Renderers": 160,
    "m_bEnableNamedValues": 573,
    "m_bInfiniteBounds": 572,
    "m_bScreenSpaceEffect": 788,
    "m_bShouldBatch": 780,
    "m_bShouldHitboxesFallbackToRenderBounds": 781,
    "m_bShouldHitboxesFallbackToSnapshot": 782,
    "m_bShouldSort": 808,
    "m_controlPointConfigurations": 880,
    "m_flAggregateRadius": 776,
    "m_flConstantLifespan": 636,
    "m_flConstantRadius": 624,
    "m_flConstantRotation": 628,
    "m_flConstantRotationSpeed": 632,
    "m_flCullFillCost": 676,
    "m_flCullRadius": 672,
    "m_flDepthSortBias": 564,
    "m_flMaxCreationDistance": 768,
    "m_flMaxDrawDistance": 760,
    "m_flMaximumSimTime": 732,
    "m_flMaximumTimeStep": 728,
    "m_flMinimumSimTime": 736,
    "m_flMinimumTimeStep": 740,
    "m_flNoDrawTimeToGoToSleep": 756,
    "m_flPreSimulationTime": 720,
    "m_flStartFadeDistance": 764,
    "m_flStopSimulationAfterTime": 724,
    "m_hFallback": 688,
    "m_hLowViolenceDef": 704,
    "m_hReferenceReplacement": 712,
    "m_hSnapshot": 656,
    "m_nAggregationMinAvailableParticles": 772,
    "m_nAllowRenderControlPoint": 804,
    "m_nBehaviorVersion": 8,
    "m_nConstantSequenceNumber": 640,
    "m_nConstantSequenceNumber1": 644,
    "m_nCullControlPoint": 680,
    "m_nFallbackMaxCount": 696,
    "m_nFirstMultipleOverride_BackwardCompat": 376,
    "m_nGroupID": 536,
    "m_nInitialParticles": 528,
    "m_nMaxParticles": 532,
    "m_nMinCPULevel": 748,
    "m_nMinGPULevel": 752,
    "m_nMinimumFrames": 744,
    "m_nSkipRenderControlPoint": 800,
    "m_nSnapshotControlPoint": 648,
    "m_nSortOverridePositionCP": 568,
    "m_nViewModelEffect": 784,
    "m_pszCullReplacementName": 664,
    "m_pszTargetLayerID": 792
  },
  "CParticleTransformInput": {
    "m_NamedValue": 24,
    "m_bFollowNamedValue": 88,
    "m_bSupportsDisabled": 89,
    "m_bUseOrientation": 90,
    "m_flEndCPGrowthTime": 100,
    "m_nControlPoint": 92,
    "m_nControlPointRangeMax": 96,
    "m_nType": 16
  },
  "CParticleVariableRef": {
    "m_variableName": 0,
    "m_variableType": 56
  },
  "CParticleVecInput": {
    "m_FloatComponentX": 168,
    "m_FloatComponentY": 512,
    "m_FloatComponentZ": 856,
    "m_FloatInterp": 1200,
    "m_Gradient": 1576,
    "m_LiteralColor": 32,
    "m_NamedValue": 40,
    "m_bFollowNamedValue": 104,
    "m_flInterpInput0": 1544,
    "m_flInterpInput1": 1548,
    "m_nControlPoint": 124,
    "m_nDeltaControlPoint": 128,
    "m_nType": 16,
    "m_nVectorAttribute": 108,
    "m_vCPRelativeDir": 156,
    "m_vCPRelativePosition": 144,
    "m_vCPValueScale": 132,
    "m_vInterpOutput0": 1552,
    "m_vInterpOutput1": 1564,
    "m_vLiteralValue": 20,
    "m_vRandomMax": 1612,
    "m_vRandomMin": 1600,
    "m_vVectorAttributeScale": 112
  },
  "CParticleVisibilityInputs": {
    "m_bDotCPAngles": 40,
    "m_bDotCameraAngles": 41,
    "m_bRightEye": 64,
    "m_flAlphaScaleMax": 48,
    "m_flAlphaScaleMin": 44,
    "m_flCameraBias": 0,
    "m_flDistanceInputMax": 28,
    "m_flDistanceInputMin": 24,
    "m_flDotInputMax": 36,
    "m_flDotInputMin": 32,
    "m_flInputMax": 16,
    "m_flInputMin": 12,
    "m_flNoPixelVisibilityFallback": 20,
    "m_flProxyRadius": 8,
    "m_flRadiusScaleFOVBase": 60,
    "m_flRadiusScaleMax": 56,
    "m_flRadiusScaleMin": 52,
    "m_nCPin": 4
  },
  "CPathParameters": {
    "m_flBulge": 12,
    "m_flMidPoint": 16,
    "m_nBulgeControl": 8,
    "m_nEndControlPointNumber": 4,
    "m_nStartControlPointNumber": 0,
    "m_vEndOffset": 44,
    "m_vMidPointOffset": 32,
    "m_vStartPointOffset": 20
  },
  "CRandomNumberGeneratorParameters": {
    "m_bDistributeEvenly": 0,
    "m_nSeed": 4
  },
  "C_INIT_AddVectorToVector": {
    "m_nFieldInput": 464,
    "m_nFieldOutput": 460,
    "m_randomnessParameters": 492,
    "m_vOffsetMax": 480,
    "m_vOffsetMin": 468,
    "m_vecScale": 448
  },
  "C_INIT_AgeNoise": {
    "m_bAbsVal": 448,
    "m_bAbsValInv": 449,
    "m_flAgeMax": 460,
    "m_flAgeMin": 456,
    "m_flNoiseScale": 464,
    "m_flNoiseScaleLoc": 468,
    "m_flOffset": 452,
    "m_vecOffsetLoc": 472
  },
  "C_INIT_ChaoticAttractor": {
    "m_bUniformSpeed": 480,
    "m_flAParm": 448,
    "m_flBParm": 452,
    "m_flCParm": 456,
    "m_flDParm": 460,
    "m_flScale": 464,
    "m_flSpeedMax": 472,
    "m_flSpeedMin": 468,
    "m_nBaseCP": 476
  },
  "C_INIT_ColorLitPerParticle": {
    "m_ColorMax": 476,
    "m_ColorMin": 472,
    "m_TintMax": 484,
    "m_TintMin": 480,
    "m_flLightAmplification": 496,
    "m_flTintPerc": 488,
    "m_nTintBlendMode": 492
  },
  "C_INIT_CreateAlongPath": {
    "m_PathParams": 464,
    "m_bSaveOffset": 544,
    "m_bUseRandomCPs": 528,
    "m_fMaxDistance": 448,
    "m_vEndOffset": 532
  },
  "C_INIT_CreateFromCPs": {
    "m_nDynamicCPCount": 464,
    "m_nIncrement": 448,
    "m_nMaxCP": 456,
    "m_nMinCP": 452
  },
  "C_INIT_CreateFromParentParticles": {
    "m_bRandomDistribution": 456,
    "m_bSubFrame": 464,
    "m_flIncrement": 452,
    "m_flVelocityScale": 448,
    "m_nRandomSeed": 460
  },
  "C_INIT_CreateFromPlaneCache": {
    "m_bUseNormal": 473,
    "m_vecOffsetMax": 460,
    "m_vecOffsetMin": 448
  },
  "C_INIT_CreateInEpitrochoid": {
    "m_TransformInput": 456,
    "m_bOffsetExistingPos": 1938,
    "m_bUseCount": 1936,
    "m_bUseLocalCoords": 1937,
    "m_flOffset": 904,
    "m_flParticleDensity": 560,
    "m_flRadius1": 1248,
    "m_flRadius2": 1592,
    "m_nComponent1": 448,
    "m_nComponent2": 452
  },
  "C_INIT_CreateOnGrid": {
    "m_bCenter": 2517,
    "m_bHollow": 2518,
    "m_bLocalSpace": 2516,
    "m_nControlPointNumber": 2512,
    "m_nXCount": 448,
    "m_nXSpacing": 1480,
    "m_nYCount": 792,
    "m_nYSpacing": 1824,
    "m_nZCount": 1136,
    "m_nZSpacing": 2168
  },
  "C_INIT_CreateOnModel": {
    "m_HitboxSetName": 3920,
    "m_bLocalCoords": 4048,
    "m_bUseBones": 4049,
    "m_flBoneVelocity": 2288,
    "m_flMaxBoneVelocity": 2292,
    "m_flShellSize": 4056,
    "m_modelInput": 448,
    "m_nDesiredHitbox": 652,
    "m_nForceInModel": 648,
    "m_nHitboxValueFromControlPointIndex": 656,
    "m_transformInput": 544,
    "m_vecDirectionBias": 2296,
    "m_vecHitBoxScale": 664
  },
  "C_INIT_CreateOnModelAtHeight": {
    "m_HitboxSetName": 4062,
    "m_bForceZ": 449,
    "m_bLocalCoords": 4060,
    "m_bPreferMovingBoxes": 4061,
    "m_bUseBones": 448,
    "m_bUseWaterHeight": 460,
    "m_flDesiredHeight": 464,
    "m_flHitboxVelocityScale": 4192,
    "m_flMaxBoneVelocity": 4536,
    "m_nBiasType": 4056,
    "m_nControlPointNumber": 452,
    "m_nHeightCP": 456,
    "m_vecDirectionBias": 2432,
    "m_vecHitBoxScale": 808
  },
  "C_INIT_CreateParticleImpulse": {
    "m_InputFalloffExp": 1144,
    "m_InputMagnitude": 792,
    "m_InputRadius": 448,
    "m_nFalloffFunction": 1136,
    "m_nImpulseType": 1488
  },
  "C_INIT_CreatePhyllotaxis": {
    "m_bUseLocalCoords": 492,
    "m_bUseOrigRadius": 494,
    "m_bUseWithContEmit": 493,
    "m_fDistBias": 488,
    "m_fMinRad": 484,
    "m_fRadBias": 480,
    "m_fRadCentCore": 460,
    "m_fRadPerPoint": 464,
    "m_fRadPerPointTo": 468,
    "m_fpointAngle": 472,
    "m_fsizeOverall": 476,
    "m_nComponent": 456,
    "m_nControlPointNumber": 448,
    "m_nScaleCP": 452
  },
  "C_INIT_CreateSequentialPath": {
    "m_PathParams": 464,
    "m_bCPPairs": 457,
    "m_bLoop": 456,
    "m_bSaveOffset": 458,
    "m_fMaxDistance": 448,
    "m_flNumToAssign": 452
  },
  "C_INIT_CreateSequentialPathV2": {
    "m_PathParams": 1152,
    "m_bCPPairs": 1137,
    "m_bLoop": 1136,
    "m_bSaveOffset": 1138,
    "m_fMaxDistance": 448,
    "m_flNumToAssign": 792
  },
  "C_INIT_CreateSpiralSphere": {
    "m_bUseParticleCount": 472,
    "m_flInitialRadius": 460,
    "m_flInitialSpeedMax": 468,
    "m_flInitialSpeedMin": 464,
    "m_nControlPointNumber": 448,
    "m_nDensity": 456,
    "m_nOverrideCP": 452
  },
  "C_INIT_CreateWithinBox": {
    "m_bLocalSpace": 3700,
    "m_nControlPointNumber": 3696,
    "m_randomnessParameters": 3704,
    "m_vecMax": 2072,
    "m_vecMin": 448
  },
  "C_INIT_CreateWithinSphereTransform": {
    "m_LocalCoordinateSystemSpeedMax": 5208,
    "m_LocalCoordinateSystemSpeedMin": 3584,
    "m_TransformInput": 2776,
    "m_bLocalCoords": 3572,
    "m_fRadiusMax": 792,
    "m_fRadiusMin": 448,
    "m_fSpeedMax": 3224,
    "m_fSpeedMin": 2880,
    "m_fSpeedRandExp": 3568,
    "m_flEndCPGrowthTime": 3576,
    "m_nFieldOutput": 6832,
    "m_nFieldVelocity": 6836,
    "m_vecDistanceBias": 1136,
    "m_vecDistanceBiasAbs": 2760
  },
  "C_INIT_CreationNoise": {
    "m_bAbsVal": 452,
    "m_bAbsValInv": 453,
    "m_flNoiseScale": 468,
    "m_flNoiseScaleLoc": 472,
    "m_flOffset": 456,
    "m_flOutputMax": 464,
    "m_flOutputMin": 460,
    "m_flWorldTimeScale": 488,
    "m_nFieldOutput": 448,
    "m_vecOffsetLoc": 476
  },
  "C_INIT_DistanceCull": {
    "m_bCullInside": 800,
    "m_flDistance": 456,
    "m_nControlPoint": 448
  },
  "C_INIT_DistanceToCPInit": {
    "m_CollisionGroupName": 1837,
    "m_bActiveRange": 2328,
    "m_bLOS": 1836,
    "m_flInputMax": 800,
    "m_flInputMin": 456,
    "m_flLOSScale": 2320,
    "m_flMaxTraceLength": 1976,
    "m_flOutputMax": 1488,
    "m_flOutputMin": 1144,
    "m_flRemapBias": 2344,
    "m_nFieldOutput": 448,
    "m_nSetMethod": 2324,
    "m_nStartCP": 1832,
    "m_nTraceSet": 1968,
    "m_vecDistanceScale": 2332
  },
  "C_INIT_DistanceToNeighborCull": {
    "m_flDistance": 448
  },
  "C_INIT_GlobalScale": {
    "m_bScalePosition": 461,
    "m_bScaleRadius": 460,
    "m_bScaleVelocity": 462,
    "m_flScale": 448,
    "m_nControlPointNumber": 456,
    "m_nScaleControlPointNumber": 452
  },
  "C_INIT_InheritFromParentParticles": {
    "m_bRandomDistribution": 460,
    "m_flScale": 448,
    "m_nFieldOutput": 452,
    "m_nIncrement": 456,
    "m_nRandomSeed": 464
  },
  "C_INIT_InheritVelocity": {
    "m_flVelocityScale": 452,
    "m_nControlPointNumber": 448
  },
  "C_INIT_InitFloat": {
    "m_InputStrength": 800,
    "m_InputValue": 448,
    "m_nOutputField": 792,
    "m_nSetMethod": 796
  },
  "C_INIT_InitFloatCollection": {
    "m_InputValue": 448,
    "m_nOutputField": 792
  },
  "C_INIT_InitFromCPSnapshot": {
    "m_bLocalSpaceAngles": 1164,
    "m_bRandom": 464,
    "m_bReverse": 465,
    "m_nAttributeToRead": 452,
    "m_nAttributeToWrite": 456,
    "m_nControlPointNumber": 448,
    "m_nLocalSpaceCP": 460,
    "m_nManualSnapshotIndex": 816,
    "m_nRandomSeed": 1160,
    "m_nSnapShotIncrement": 472
  },
  "C_INIT_InitFromParentKilled": {
    "m_nAttributeToCopy": 448
  },
  "C_INIT_InitFromVectorFieldSnapshot": {
    "m_bUseVerticalVelocity": 460,
    "m_nControlPointNumber": 448,
    "m_nLocalSpaceCP": 452,
    "m_nWeightUpdateCP": 456,
    "m_vecScale": 464
  },
  "C_INIT_InitSkinnedPositionFromCPSnapshot": {
    "m_bCopyAlpha": 497,
    "m_bCopyColor": 496,
    "m_bIgnoreDt": 466,
    "m_bRandom": 456,
    "m_bRigid": 464,
    "m_bSetNormal": 465,
    "m_bSetRadius": 498,
    "m_flBoneVelocity": 488,
    "m_flBoneVelocityMax": 492,
    "m_flIncrement": 476,
    "m_flMaxNormalVelocity": 472,
    "m_flMinNormalVelocity": 468,
    "m_nControlPointNumber": 452,
    "m_nFullLoopIncrement": 480,
    "m_nRandomSeed": 460,
    "m_nSnapShotStartPoint": 484,
    "m_nSnapshotControlPointNumber": 448
  },
  "C_INIT_InitVec": {
    "m_InputValue": 448,
    "m_bNormalizedOutput": 2080,
    "m_bWritePreviousPosition": 2081,
    "m_nOutputField": 2072,
    "m_nSetMethod": 2076
  },
  "C_INIT_InitVecCollection": {
    "m_InputValue": 448,
    "m_nOutputField": 2072
  },
  "C_INIT_InitialRepulsionVelocity": {
    "m_CollisionGroupName": 448,
    "m_bInherit": 617,
    "m_bPerParticle": 608,
    "m_bPerParticleTR": 616,
    "m_bProportional": 610,
    "m_bTranslate": 609,
    "m_flTraceLength": 612,
    "m_nChildCP": 620,
    "m_nChildGroupID": 624,
    "m_nControlPointNumber": 604,
    "m_nTraceSet": 576,
    "m_vecOutputMax": 592,
    "m_vecOutputMin": 580
  },
  "C_INIT_InitialSequenceFromModel": {
    "m_flInputMax": 464,
    "m_flInputMin": 460,
    "m_flOutputMax": 472,
    "m_flOutputMin": 468,
    "m_nControlPointNumber": 448,
    "m_nFieldOutput": 452,
    "m_nFieldOutputAnim": 456,
    "m_nSetMethod": 476
  },
  "C_INIT_InitialVelocityFromHitbox": {
    "m_HitboxSetName": 460,
    "m_bUseBones": 588,
    "m_flVelocityMax": 452,
    "m_flVelocityMin": 448,
    "m_nControlPointNumber": 456
  },
  "C_INIT_InitialVelocityNoise": {
    "m_TransformInput": 6376,
    "m_bIgnoreDt": 6480,
    "m_flNoiseScale": 5688,
    "m_flNoiseScaleLoc": 6032,
    "m_flOffset": 2096,
    "m_vecAbsVal": 448,
    "m_vecAbsValInv": 460,
    "m_vecOffsetLoc": 472,
    "m_vecOutputMax": 4064,
    "m_vecOutputMin": 2440
  },
  "C_INIT_LifespanFromVelocity": {
    "m_CollisionGroupName": 480,
    "m_bIncludeWater": 624,
    "m_flMaxTraceLength": 464,
    "m_flTraceOffset": 460,
    "m_flTraceTolerance": 468,
    "m_nMaxPlanes": 472,
    "m_nTraceSet": 608,
    "m_vecComponentScale": 448
  },
  "C_INIT_ModelCull": {
    "m_HitboxSetName": 455,
    "m_bBoundBox": 452,
    "m_bCullOutside": 453,
    "m_bUseBones": 454,
    "m_nControlPointNumber": 448
  },
  "C_INIT_MoveBetweenPoints": {
    "m_bTrailBias": 2172,
    "m_flEndOffset": 1824,
    "m_flEndSpread": 1136,
    "m_flSpeedMax": 792,
    "m_flSpeedMin": 448,
    "m_flStartOffset": 1480,
    "m_nEndControlPointNumber": 2168
  },
  "C_INIT_NormalAlignToCP": {
    "m_nControlPointAxis": 552,
    "m_transformInput": 448
  },
  "C_INIT_NormalOffset": {
    "m_OffsetMax": 460,
    "m_OffsetMin": 448,
    "m_bLocalCoords": 476,
    "m_bNormalize": 477,
    "m_nControlPointNumber": 472
  },
  "C_INIT_OffsetVectorToVector": {
    "m_nFieldInput": 448,
    "m_nFieldOutput": 452,
    "m_randomnessParameters": 480,
    "m_vecOutputMax": 468,
    "m_vecOutputMin": 456
  },
  "C_INIT_Orient2DRelToCP": {
    "m_flRotOffset": 456,
    "m_nCP": 448,
    "m_nFieldOutput": 452
  },
  "C_INIT_PlaneCull": {
    "m_bCullInside": 800,
    "m_flDistance": 456,
    "m_nControlPoint": 448
  },
  "C_INIT_PointList": {
    "m_bClosedLoop": 481,
    "m_bPlaceAlongPath": 480,
    "m_nFieldOutput": 448,
    "m_nNumPointsAlongPath": 484,
    "m_pointList": 456
  },
  "C_INIT_PositionOffset": {
    "m_OffsetMax": 2072,
    "m_OffsetMin": 448,
    "m_TransformInput": 3696,
    "m_bLocalCoords": 3800,
    "m_bProportional": 3801,
    "m_randomnessParameters": 3804
  },
  "C_INIT_PositionOffsetToCP": {
    "m_bLocalCoords": 456,
    "m_nControlPointNumberEnd": 452,
    "m_nControlPointNumberStart": 448
  },
  "C_INIT_PositionPlaceOnGround": {
    "m_CollisionGroupName": 1136,
    "m_bIncludeWater": 1284,
    "m_bOffsetonColOnly": 1288,
    "m_bSetNormal": 1285,
    "m_bSetPXYZOnly": 1286,
    "m_bTraceAlongNormal": 1287,
    "m_flMaxTraceLength": 792,
    "m_flOffset": 448,
    "m_flOffsetByRadiusFactor": 1292,
    "m_nIgnoreCP": 1300,
    "m_nPreserveOffsetCP": 1296,
    "m_nTraceMissBehavior": 1280,
    "m_nTraceSet": 1264
  },
  "C_INIT_PositionWarp": {
    "m_bInvertWarp": 3720,
    "m_bUseCount": 3721,
    "m_flPrevPosScale": 3716,
    "m_flWarpStartTime": 3712,
    "m_flWarpTime": 3708,
    "m_nControlPointNumber": 3700,
    "m_nRadiusComponent": 3704,
    "m_nScaleControlPointNumber": 3696,
    "m_vecWarpMax": 2072,
    "m_vecWarpMin": 448
  },
  "C_INIT_PositionWarpScalar": {
    "m_InputValue": 472,
    "m_flPrevPosScale": 816,
    "m_nControlPointNumber": 824,
    "m_nScaleControlPointNumber": 820,
    "m_vecWarpMax": 460,
    "m_vecWarpMin": 448
  },
  "C_INIT_QuantizeFloat": {
    "m_InputValue": 448,
    "m_nOutputField": 792
  },
  "C_INIT_RadiusFromCPObject": {
    "m_nControlPoint": 448
  },
  "C_INIT_RandomAlpha": {
    "m_flAlphaRandExponent": 468,
    "m_nAlphaMax": 456,
    "m_nAlphaMin": 452,
    "m_nFieldOutput": 448
  },
  "C_INIT_RandomAlphaWindowThreshold": {
    "m_flExponent": 456,
    "m_flMax": 452,
    "m_flMin": 448
  },
  "C_INIT_RandomColor": {
    "m_ColorMax": 480,
    "m_ColorMin": 476,
    "m_TintMax": 488,
    "m_TintMin": 484,
    "m_flLightAmplification": 512,
    "m_flTintPerc": 492,
    "m_flUpdateThreshold": 496,
    "m_nFieldOutput": 504,
    "m_nTintBlendMode": 508,
    "m_nTintCP": 500
  },
  "C_INIT_RandomLifeTime": {
    "m_fLifetimeMax": 452,
    "m_fLifetimeMin": 448,
    "m_fLifetimeRandExponent": 456
  },
  "C_INIT_RandomModelSequence": {
    "m_ActivityName": 448,
    "m_SequenceName": 704,
    "m_hModel": 960
  },
  "C_INIT_RandomNamedModelElement": {
    "m_bLinear": 481,
    "m_bModelFromRenderer": 482,
    "m_bShuffle": 480,
    "m_hModel": 448,
    "m_nFieldOutput": 484,
    "m_names": 456
  },
  "C_INIT_RandomRadius": {
    "m_flRadiusMax": 452,
    "m_flRadiusMin": 448,
    "m_flRadiusRandExponent": 456
  },
  "C_INIT_RandomScalar": {
    "m_flExponent": 456,
    "m_flMax": 452,
    "m_flMin": 448,
    "m_nFieldOutput": 460
  },
  "C_INIT_RandomSecondSequence": {
    "m_nSequenceMax": 452,
    "m_nSequenceMin": 448
  },
  "C_INIT_RandomSequence": {
    "m_WeightedList": 464,
    "m_bLinear": 457,
    "m_bShuffle": 456,
    "m_nSequenceMax": 452,
    "m_nSequenceMin": 448
  },
  "C_INIT_RandomTrailLength": {
    "m_flLengthRandExponent": 456,
    "m_flMaxLength": 452,
    "m_flMinLength": 448
  },
  "C_INIT_RandomVector": {
    "m_nFieldOutput": 472,
    "m_randomnessParameters": 476,
    "m_vecMax": 460,
    "m_vecMin": 448
  },
  "C_INIT_RandomVectorComponent": {
    "m_flMax": 452,
    "m_flMin": 448,
    "m_nComponent": 460,
    "m_nFieldOutput": 456
  },
  "C_INIT_RandomYawFlip": {
    "m_flPercent": 448
  },
  "C_INIT_RemapCPtoScalar": {
    "m_flEndTime": 480,
    "m_flInputMax": 464,
    "m_flInputMin": 460,
    "m_flOutputMax": 472,
    "m_flOutputMin": 468,
    "m_flRemapBias": 488,
    "m_flStartTime": 476,
    "m_nCPInput": 448,
    "m_nField": 456,
    "m_nFieldOutput": 452,
    "m_nSetMethod": 484
  },
  "C_INIT_RemapInitialDirectionToTransformToVector": {
    "m_TransformInput": 448,
    "m_bNormalize": 576,
    "m_flOffsetRot": 560,
    "m_flScale": 556,
    "m_nFieldOutput": 552,
    "m_vecOffsetAxis": 564
  },
  "C_INIT_RemapInitialTransformDirectionToRotation": {
    "m_TransformInput": 448,
    "m_flOffsetRot": 556,
    "m_nComponent": 560,
    "m_nFieldOutput": 552
  },
  "C_INIT_RemapInitialVisibilityScalar": {
    "m_flInputMax": 460,
    "m_flInputMin": 456,
    "m_flOutputMax": 468,
    "m_flOutputMin": 464,
    "m_nFieldOutput": 452
  },
  "C_INIT_RemapNamedModelElementToScalar": {
    "m_bModelFromRenderer": 516,
    "m_hModel": 448,
    "m_nFieldInput": 504,
    "m_nFieldOutput": 508,
    "m_nSetMethod": 512,
    "m_names": 456,
    "m_values": 480
  },
  "C_INIT_RemapParticleCountToNamedModelElementScalar": {
    "m_bModelFromRenderer": 520,
    "m_hModel": 496,
    "m_outputMaxName": 512,
    "m_outputMinName": 504
  },
  "C_INIT_RemapParticleCountToScalar": {
    "m_bActiveRange": 480,
    "m_bInvert": 481,
    "m_bWrap": 482,
    "m_flOutputMax": 472,
    "m_flOutputMin": 468,
    "m_flRemapBias": 484,
    "m_nFieldOutput": 448,
    "m_nInputMax": 456,
    "m_nInputMin": 452,
    "m_nScaleControlPoint": 460,
    "m_nScaleControlPointField": 464,
    "m_nSetMethod": 476
  },
  "C_INIT_RemapQAnglesToRotation": {
    "m_TransformInput": 448
  },
  "C_INIT_RemapScalar": {
    "m_bActiveRange": 484,
    "m_flEndTime": 476,
    "m_flInputMax": 460,
    "m_flInputMin": 456,
    "m_flOutputMax": 468,
    "m_flOutputMin": 464,
    "m_flRemapBias": 488,
    "m_flStartTime": 472,
    "m_nFieldInput": 448,
    "m_nFieldOutput": 452,
    "m_nSetMethod": 480
  },
  "C_INIT_RemapScalarToVector": {
    "m_bLocalCoords": 504,
    "m_flEndTime": 492,
    "m_flInputMax": 460,
    "m_flInputMin": 456,
    "m_flRemapBias": 508,
    "m_flStartTime": 488,
    "m_nControlPointNumber": 500,
    "m_nFieldInput": 448,
    "m_nFieldOutput": 452,
    "m_nSetMethod": 496,
    "m_vecOutputMax": 476,
    "m_vecOutputMin": 464
  },
  "C_INIT_RemapSpeedToScalar": {
    "m_bPerParticle": 484,
    "m_flEndTime": 460,
    "m_flInputMax": 468,
    "m_flInputMin": 464,
    "m_flOutputMax": 476,
    "m_flOutputMin": 472,
    "m_flStartTime": 456,
    "m_nControlPointNumber": 452,
    "m_nFieldOutput": 448,
    "m_nSetMethod": 480
  },
  "C_INIT_RemapTransformOrientationToRotations": {
    "m_TransformInput": 448,
    "m_bUseQuat": 564,
    "m_bWriteNormal": 565,
    "m_vecRotation": 552
  },
  "C_INIT_RemapTransformToVector": {
    "m_LocalSpaceTransform": 608,
    "m_TransformInput": 504,
    "m_bAccelerate": 725,
    "m_bOffset": 724,
    "m_flEndTime": 716,
    "m_flRemapBias": 728,
    "m_flStartTime": 712,
    "m_nFieldOutput": 448,
    "m_nSetMethod": 720,
    "m_vInputMax": 464,
    "m_vInputMin": 452,
    "m_vOutputMax": 488,
    "m_vOutputMin": 476
  },
  "C_INIT_RingWave": {
    "m_TransformInput": 448,
    "m_bEvenDistribution": 3304,
    "m_bXYVelocityOnly": 3305,
    "m_flInitialRadius": 896,
    "m_flInitialSpeedMax": 1928,
    "m_flInitialSpeedMin": 1584,
    "m_flParticlesPerOrbit": 552,
    "m_flPitch": 2616,
    "m_flRoll": 2272,
    "m_flThickness": 1240,
    "m_flYaw": 2960
  },
  "C_INIT_RtEnvCull": {
    "m_RtEnvName": 475,
    "m_bCullOnMiss": 473,
    "m_bLifeAdjust": 474,
    "m_bUseVelocity": 472,
    "m_nComponent": 608,
    "m_nRTEnvCP": 604,
    "m_vecTestDir": 448,
    "m_vecTestNormal": 460
  },
  "C_INIT_ScaleVelocity": {
    "m_vecScale": 448
  },
  "C_INIT_SequenceFromCP": {
    "m_bKillUnused": 448,
    "m_bRadiusScale": 449,
    "m_nCP": 452,
    "m_vecOffset": 456
  },
  "C_INIT_SequenceLifeTime": {
    "m_flFramerate": 448
  },
  "C_INIT_SetHitboxToClosest": {
    "m_HitboxSetName": 2080,
    "m_bUpdatePosition": 2560,
    "m_bUseBones": 2208,
    "m_bUseClosestPointOnHitbox": 2209,
    "m_flHybridRatio": 2216,
    "m_nControlPointNumber": 448,
    "m_nDesiredHitbox": 452,
    "m_nTestType": 2212,
    "m_vecHitBoxScale": 456
  },
  "C_INIT_SetHitboxToModel": {
    "m_HitboxSetName": 2102,
    "m_bMaintainHitbox": 2100,
    "m_bUseBones": 2101,
    "m_flShellSize": 2232,
    "m_nControlPointNumber": 448,
    "m_nDesiredHitbox": 456,
    "m_nForceInModel": 452,
    "m_vecDirectionBias": 2088,
    "m_vecHitBoxScale": 464
  },
  "C_INIT_SetRigidAttachment": {
    "m_bLocalSpace": 460,
    "m_nControlPointNumber": 448,
    "m_nFieldInput": 452,
    "m_nFieldOutput": 456
  },
  "C_INIT_SetVectorAttributeToVectorExpression": {
    "m_bNormalizedOutput": 3712,
    "m_nExpression": 448,
    "m_nOutputField": 3704,
    "m_nSetMethod": 3708,
    "m_vInput1": 456,
    "m_vInput2": 2080
  },
  "C_INIT_StatusEffect": {
    "m_flAmbientScale": 476,
    "m_flColorWarpIntensity": 464,
    "m_flDetail2BlendFactor": 460,
    "m_flDetail2Rotation": 452,
    "m_flDetail2Scale": 456,
    "m_flDiffuseWarpBlendToFull": 468,
    "m_flEnvMapIntensity": 472,
    "m_flMetalnessBlendToFull": 512,
    "m_flReflectionsTintByBaseBlendToNone": 508,
    "m_flRimLightScale": 504,
    "m_flSelfIllumBlendToFull": 516,
    "m_flSpecularBlendToFull": 496,
    "m_flSpecularExponent": 488,
    "m_flSpecularExponentBlendToFull": 492,
    "m_flSpecularScale": 484,
    "m_nDetail2Combo": 448,
    "m_rimLightColor": 500,
    "m_specularColor": 480
  },
  "C_INIT_StatusEffectCitadel": {
    "m_flSFXColorWarpAmount": 448,
    "m_flSFXMetalnessAmount": 456,
    "m_flSFXNormalAmount": 452,
    "m_flSFXRoughnessAmount": 460,
    "m_flSFXSDetailAmount": 500,
    "m_flSFXSDetailScale": 504,
    "m_flSFXSDetailScrollX": 508,
    "m_flSFXSDetailScrollY": 512,
    "m_flSFXSDetailScrollZ": 516,
    "m_flSFXSOffsetX": 484,
    "m_flSFXSOffsetY": 488,
    "m_flSFXSOffsetZ": 492,
    "m_flSFXSScale": 468,
    "m_flSFXSScrollX": 472,
    "m_flSFXSScrollY": 476,
    "m_flSFXSScrollZ": 480,
    "m_flSFXSUseModelUVs": 520,
    "m_flSFXSelfIllumAmount": 464,
    "m_nDetailCombo": 496
  },
  "C_INIT_VelocityFromCP": {
    "m_bDirectionOnly": 2180,
    "m_flVelocityScale": 2176,
    "m_transformInput": 2072,
    "m_velocityInput": 448
  },
  "C_INIT_VelocityFromNormal": {
    "m_bIgnoreDt": 456,
    "m_fSpeedMax": 452,
    "m_fSpeedMin": 448
  },
  "C_INIT_VelocityRadialRandom": {
    "m_bIgnoreDelta": 473,
    "m_fSpeedMax": 456,
    "m_fSpeedMin": 452,
    "m_nControlPointNumber": 448,
    "m_vecLocalCoordinateSystemSpeedScale": 460
  },
  "C_INIT_VelocityRandom": {
    "m_LocalCoordinateSystemSpeedMax": 2768,
    "m_LocalCoordinateSystemSpeedMin": 1144,
    "m_bIgnoreDT": 4392,
    "m_fSpeedMax": 800,
    "m_fSpeedMin": 456,
    "m_nControlPointNumber": 448,
    "m_randomnessParameters": 4396
  },
  "C_OP_AlphaDecay": {
    "m_flMinAlpha": 448
  },
  "C_OP_AttractToControlPoint": {
    "m_TransformInput": 832,
    "m_bApplyMinForce": 1280,
    "m_fFalloffPower": 824,
    "m_fForceAmount": 480,
    "m_fForceAmountMin": 936,
    "m_vecComponentScale": 464
  },
  "C_OP_BasicMovement": {
    "m_Gravity": 448,
    "m_fDrag": 2072,
    "m_nMaxConstraintPasses": 2416
  },
  "C_OP_BoxConstraint": {
    "m_bAccountForRadius": 3701,
    "m_bLocalSpace": 3700,
    "m_nCP": 3696,
    "m_vecMax": 2072,
    "m_vecMin": 448
  },
  "C_OP_CPOffsetToPercentageBetweenCPs": {
    "m_bRadialCheck": 480,
    "m_bScaleOffset": 481,
    "m_flInputBias": 456,
    "m_flInputMax": 452,
    "m_flInputMin": 448,
    "m_nEndCP": 464,
    "m_nInputCP": 476,
    "m_nOffsetCP": 468,
    "m_nOuputCP": 472,
    "m_nStartCP": 460,
    "m_vecOffset": 484
  },
  "C_OP_CPVelocityForce": {
    "m_flScale": 472,
    "m_nControlPointNumber": 464
  },
  "C_OP_CalculateVectorAttribute": {
    "m_flControlPointScale1": 496,
    "m_flControlPointScale2": 520,
    "m_flInputScale1": 464,
    "m_flInputScale2": 472,
    "m_nControlPointInput1": 476,
    "m_nControlPointInput2": 500,
    "m_nFieldInput1": 460,
    "m_nFieldInput2": 468,
    "m_nFieldOutput": 524,
    "m_vFinalOutputScale": 528,
    "m_vStartValue": 448
  },
  "C_OP_ChladniWave": {
    "m_b3D": 5088,
    "m_flInputMax": 800,
    "m_flInputMin": 456,
    "m_flOutputMax": 1488,
    "m_flOutputMin": 1144,
    "m_nFieldOutput": 448,
    "m_nLocalSpaceControlPoint": 5084,
    "m_nSetMethod": 5080,
    "m_vecHarmonics": 3456,
    "m_vecWaveLength": 1832
  },
  "C_OP_ChooseRandomChildrenInGroup": {
    "m_flNumberOfChildren": 472,
    "m_nChildGroupID": 464
  },
  "C_OP_ClampScalar": {
    "m_flOutputMax": 800,
    "m_flOutputMin": 456,
    "m_nFieldOutput": 448
  },
  "C_OP_ClampVector": {
    "m_nFieldOutput": 448,
    "m_vecOutputMax": 2080,
    "m_vecOutputMin": 456
  },
  "C_OP_CollideWithParentParticles": {
    "m_flParentRadiusScale": 448,
    "m_flRadiusScale": 792
  },
  "C_OP_CollideWithSelf": {
    "m_flMinimumSpeed": 792,
    "m_flRadiusScale": 448
  },
  "C_OP_ColorAdjustHSL": {
    "m_flHueAdjust": 448,
    "m_flLightnessAdjust": 1136,
    "m_flSaturationAdjust": 792
  },
  "C_OP_ColorInterpolate": {
    "m_ColorFade": 448,
    "m_bEaseInOut": 476,
    "m_bUseNewCode": 477,
    "m_flFadeEndTime": 468,
    "m_flFadeStartTime": 464,
    "m_nFieldOutput": 472
  },
  "C_OP_ColorInterpolateRandom": {
    "m_ColorFadeMax": 476,
    "m_ColorFadeMin": 448,
    "m_bEaseInOut": 504,
    "m_flFadeEndTime": 496,
    "m_flFadeStartTime": 492,
    "m_nFieldOutput": 500
  },
  "C_OP_ConnectParentParticleToNearest": {
    "m_nFirstControlPoint": 448,
    "m_nSecondControlPoint": 452
  },
  "C_OP_ConstrainDistance": {
    "m_CenterOffset": 1140,
    "m_bGlobalCenter": 1152,
    "m_fMaxDistance": 792,
    "m_fMinDistance": 448,
    "m_nControlPointNumber": 1136
  },
  "C_OP_ConstrainDistanceToPath": {
    "m_PathParameters": 464,
    "m_fMinDistance": 448,
    "m_flMaxDistance0": 452,
    "m_flMaxDistance1": 460,
    "m_flMaxDistanceMid": 456,
    "m_flTravelTime": 528,
    "m_nFieldScale": 532,
    "m_nManualTField": 536
  },
  "C_OP_ConstrainDistanceToUserSpecifiedPath": {
    "m_bLoopedPath": 460,
    "m_fMinDistance": 448,
    "m_flMaxDistance": 452,
    "m_flTimeScale": 456,
    "m_pointList": 464
  },
  "C_OP_ConstrainLineLength": {
    "m_flMaxDistance": 452,
    "m_flMinDistance": 448
  },
  "C_OP_ContinuousEmitter": {
    "m_bForceEmitOnFirstUpdate": 1500,
    "m_bForceEmitOnLastUpdate": 1501,
    "m_bInitFromKilledParentParticles": 1488,
    "m_flEmissionDuration": 448,
    "m_flEmissionScale": 1480,
    "m_flEmitRate": 1136,
    "m_flScalePerParentParticle": 1484,
    "m_flStartTime": 792,
    "m_nLimitPerUpdate": 1496,
    "m_nSnapshotControlPoint": 1492
  },
  "C_OP_ControlPointToRadialScreenSpace": {
    "m_nCPIn": 464,
    "m_nCPOut": 480,
    "m_nCPOutField": 484,
    "m_nCPSSPosOut": 488,
    "m_vecCP1Pos": 468
  },
  "C_OP_ControlpointLight": {
    "m_LightColor1": 1712,
    "m_LightColor2": 1716,
    "m_LightColor3": 1720,
    "m_LightColor4": 1724,
    "m_LightFiftyDist1": 1680,
    "m_LightFiftyDist2": 1688,
    "m_LightFiftyDist3": 1696,
    "m_LightFiftyDist4": 1704,
    "m_LightZeroDist1": 1684,
    "m_LightZeroDist2": 1692,
    "m_LightZeroDist3": 1700,
    "m_LightZeroDist4": 1708,
    "m_bClampLowerRange": 1742,
    "m_bClampUpperRange": 1743,
    "m_bLightDynamic1": 1732,
    "m_bLightDynamic2": 1733,
    "m_bLightDynamic3": 1734,
    "m_bLightDynamic4": 1735,
    "m_bLightType1": 1728,
    "m_bLightType2": 1729,
    "m_bLightType3": 1730,
    "m_bLightType4": 1731,
    "m_bUseHLambert": 1737,
    "m_bUseNormal": 1736,
    "m_flScale": 448,
    "m_nControlPoint1": 1616,
    "m_nControlPoint2": 1620,
    "m_nControlPoint3": 1624,
    "m_nControlPoint4": 1628,
    "m_vecCPOffset1": 1632,
    "m_vecCPOffset2": 1644,
    "m_vecCPOffset3": 1656,
    "m_vecCPOffset4": 1668
  },
  "C_OP_Cull": {
    "m_flCullEnd": 456,
    "m_flCullExp": 460,
    "m_flCullPerc": 448,
    "m_flCullStart": 452
  },
  "C_OP_CurlNoiseForce": {
    "m_flWorleyJitter": 7312,
    "m_flWorleySeed": 6968,
    "m_nNoiseType": 464,
    "m_vecNoiseFreq": 472,
    "m_vecNoiseScale": 2096,
    "m_vecOffset": 3720,
    "m_vecOffsetRate": 5344
  },
  "C_OP_CycleScalar": {
    "m_bDoNotRepeatCycle": 464,
    "m_bSynchronizeParticles": 465,
    "m_flCycleTime": 460,
    "m_flEndValue": 456,
    "m_flStartValue": 452,
    "m_nCPFieldMax": 476,
    "m_nCPFieldMin": 472,
    "m_nCPScale": 468,
    "m_nDestField": 448,
    "m_nSetMethod": 480
  },
  "C_OP_CylindricalDistanceToTransform": {
    "m_TransformEnd": 1936,
    "m_TransformStart": 1832,
    "m_bActiveRange": 2044,
    "m_bAdditive": 2045,
    "m_bCapsule": 2046,
    "m_flInputMax": 800,
    "m_flInputMin": 456,
    "m_flOutputMax": 1488,
    "m_flOutputMin": 1144,
    "m_nFieldOutput": 448,
    "m_nSetMethod": 2040
  },
  "C_OP_DampenToCP": {
    "m_flRange": 452,
    "m_flScale": 456,
    "m_nControlPointNumber": 448
  },
  "C_OP_Decay": {
    "m_bForcePreserveParticleOrder": 449,
    "m_bRopeDecay": 448
  },
  "C_OP_DecayClampCount": {
    "m_nCount": 448
  },
  "C_OP_DecayMaintainCount": {
    "m_bKillNewest": 808,
    "m_bLifespanDecay": 460,
    "m_flDecayDelay": 452,
    "m_flScale": 464,
    "m_nParticlesToMaintain": 448,
    "m_nSnapshotControlPoint": 456
  },
  "C_OP_DecayOffscreen": {
    "m_flOffscreenTime": 448
  },
  "C_OP_DensityForce": {
    "m_flForceScale": 468,
    "m_flRadiusScale": 464,
    "m_flTargetDensity": 472
  },
  "C_OP_DifferencePreviousParticle": {
    "m_bActiveRange": 476,
    "m_bSetPreviousParticle": 477,
    "m_flInputMax": 460,
    "m_flInputMin": 456,
    "m_flOutputMax": 468,
    "m_flOutputMin": 464,
    "m_nFieldInput": 448,
    "m_nFieldOutput": 452,
    "m_nSetMethod": 472
  },
  "C_OP_Diffusion": {
    "m_flRadiusScale": 448,
    "m_nFieldOutput": 452,
    "m_nVoxelGridResolution": 456
  },
  "C_OP_DirectionBetweenVecsToVec": {
    "m_nFieldOutput": 448,
    "m_vecPoint1": 456,
    "m_vecPoint2": 2080
  },
  "C_OP_DistanceBetweenCPsToCP": {
    "m_CollisionGroupName": 509,
    "m_bLOS": 508,
    "m_bSetOnce": 480,
    "m_flInputMax": 488,
    "m_flInputMin": 484,
    "m_flLOSScale": 504,
    "m_flMaxTraceLength": 500,
    "m_flOutputMax": 496,
    "m_flOutputMin": 492,
    "m_nEndCP": 468,
    "m_nOutputCP": 472,
    "m_nOutputCPField": 476,
    "m_nSetParent": 644,
    "m_nStartCP": 464,
    "m_nTraceSet": 640
  },
  "C_OP_DistanceBetweenTransforms": {
    "m_CollisionGroupName": 2048,
    "m_TransformEnd": 560,
    "m_TransformStart": 456,
    "m_bLOS": 2180,
    "m_flInputMax": 1008,
    "m_flInputMin": 664,
    "m_flLOSScale": 2044,
    "m_flMaxTraceLength": 2040,
    "m_flOutputMax": 1696,
    "m_flOutputMin": 1352,
    "m_nFieldOutput": 448,
    "m_nSetMethod": 2184,
    "m_nTraceSet": 2176
  },
  "C_OP_DistanceBetweenVecs": {
    "m_bDeltaTime": 5084,
    "m_flInputMax": 4048,
    "m_flInputMin": 3704,
    "m_flOutputMax": 4736,
    "m_flOutputMin": 4392,
    "m_nFieldOutput": 448,
    "m_nSetMethod": 5080,
    "m_vecPoint1": 456,
    "m_vecPoint2": 2080
  },
  "C_OP_DistanceCull": {
    "m_bCullInside": 468,
    "m_flDistance": 464,
    "m_nControlPoint": 448,
    "m_vecPointOffset": 452
  },
  "C_OP_DistanceToTransform": {
    "m_CollisionGroupName": 1937,
    "m_TransformStart": 1832,
    "m_bActiveRange": 2084,
    "m_bAdditive": 2085,
    "m_bLOS": 1936,
    "m_flInputMax": 800,
    "m_flInputMin": 456,
    "m_flLOSScale": 2076,
    "m_flMaxTraceLength": 2072,
    "m_flOutputMax": 1488,
    "m_flOutputMin": 1144,
    "m_nFieldOutput": 448,
    "m_nSetMethod": 2080,
    "m_nTraceSet": 2068,
    "m_vecComponentScale": 2088
  },
  "C_OP_DragRelativeToPlane": {
    "m_bDirectional": 1136,
    "m_flDragAtPlane": 448,
    "m_flFalloff": 792,
    "m_nControlPointNumber": 2768,
    "m_vecPlaneNormal": 1144
  },
  "C_OP_DriveCPFromGlobalSoundFloat": {
    "m_FieldName": 504,
    "m_OperatorName": 496,
    "m_StackName": 488,
    "m_flInputMax": 476,
    "m_flInputMin": 472,
    "m_flOutputMax": 484,
    "m_flOutputMin": 480,
    "m_nOutputControlPoint": 464,
    "m_nOutputField": 468
  },
  "C_OP_EnableChildrenFromParentParticleCount": {
    "m_bDestroyImmediately": 818,
    "m_bDisableChildren": 816,
    "m_bPlayEndcapOnStop": 817,
    "m_nChildGroupID": 464,
    "m_nFirstChild": 468,
    "m_nNumChildrenToEnable": 472
  },
  "C_OP_EndCapTimedDecay": {
    "m_flDecayTime": 448
  },
  "C_OP_EndCapTimedFreeze": {
    "m_flFreezeTime": 448
  },
  "C_OP_ExternalGameImpulseForce": {
    "m_bExplosions": 810,
    "m_bParticles": 811,
    "m_bRopes": 808,
    "m_bRopesZOnly": 809,
    "m_flForceScale": 464
  },
  "C_OP_ExternalWindForce": {
    "m_bDampenNearWaterPlane": 3714,
    "m_bSampleGravity": 3715,
    "m_bSampleWater": 3713,
    "m_bSampleWind": 3712,
    "m_bUseBasicMovementGravity": 5344,
    "m_flLocalBuoyancyScale": 5696,
    "m_flLocalGravityScale": 5352,
    "m_vecBuoyancyForce": 6040,
    "m_vecGravityForce": 3720,
    "m_vecSamplePosition": 464,
    "m_vecScale": 2088
  },
  "C_OP_FadeAndKill": {
    "m_bForcePreserveParticleOrder": 472,
    "m_flEndAlpha": 468,
    "m_flEndFadeInTime": 452,
    "m_flEndFadeOutTime": 460,
    "m_flStartAlpha": 464,
    "m_flStartFadeInTime": 448,
    "m_flStartFadeOutTime": 456
  },
  "C_OP_FadeAndKillForTracers": {
    "m_flEndAlpha": 468,
    "m_flEndFadeInTime": 452,
    "m_flEndFadeOutTime": 460,
    "m_flStartAlpha": 464,
    "m_flStartFadeInTime": 448,
    "m_flStartFadeOutTime": 456
  },
  "C_OP_FadeIn": {
    "m_bProportional": 460,
    "m_flFadeInTimeExp": 456,
    "m_flFadeInTimeMax": 452,
    "m_flFadeInTimeMin": 448
  },
  "C_OP_FadeInSimple": {
    "m_flFadeInTime": 448,
    "m_nFieldOutput": 452
  },
  "C_OP_FadeOut": {
    "m_bEaseInAndOut": 513,
    "m_bProportional": 512,
    "m_flFadeBias": 460,
    "m_flFadeOutTimeExp": 456,
    "m_flFadeOutTimeMax": 452,
    "m_flFadeOutTimeMin": 448
  },
  "C_OP_FadeOutSimple": {
    "m_flFadeOutTime": 448,
    "m_nFieldOutput": 452
  },
  "C_OP_ForceBasedOnDistanceToPlane": {
    "m_flExponent": 512,
    "m_flMaxDist": 480,
    "m_flMinDist": 464,
    "m_nControlPointNumber": 508,
    "m_vecForceAtMaxDist": 484,
    "m_vecForceAtMinDist": 468,
    "m_vecPlaneNormal": 496
  },
  "C_OP_ForceControlPointStub": {
    "m_ControlPoint": 464
  },
  "C_OP_GlobalLight": {
    "m_bClampLowerRange": 452,
    "m_bClampUpperRange": 453,
    "m_flScale": 448
  },
  "C_OP_HSVShiftToCP": {
    "m_DefaultHSVColor": 476,
    "m_nColorCP": 464,
    "m_nColorGemEnableCP": 468,
    "m_nOutputCP": 472
  },
  "C_OP_InheritFromParentParticles": {
    "m_bRandomDistribution": 460,
    "m_flScale": 448,
    "m_nFieldOutput": 452,
    "m_nIncrement": 456
  },
  "C_OP_InheritFromParentParticlesV2": {
    "m_bRandomDistribution": 460,
    "m_flScale": 448,
    "m_nFieldOutput": 452,
    "m_nIncrement": 456,
    "m_nMissingParentBehavior": 464
  },
  "C_OP_InheritFromPeerSystem": {
    "m_nFieldInput": 452,
    "m_nFieldOutput": 448,
    "m_nGroupID": 460,
    "m_nIncrement": 456
  },
  "C_OP_InstantaneousEmitter": {
    "m_flInitFromKilledParentParticles": 1136,
    "m_flParentParticleScale": 1144,
    "m_flStartTime": 792,
    "m_nMaxEmittedPerFrame": 1488,
    "m_nParticlesToEmit": 448,
    "m_nSnapshotControlPoint": 1492
  },
  "C_OP_InterpolateRadius": {
    "m_bEaseInAndOut": 464,
    "m_flBias": 468,
    "m_flEndScale": 460,
    "m_flEndTime": 452,
    "m_flStartScale": 456,
    "m_flStartTime": 448
  },
  "C_OP_LagCompensation": {
    "m_nDesiredVelocityCP": 448,
    "m_nDesiredVelocityCPField": 460,
    "m_nLatencyCP": 452,
    "m_nLatencyCPField": 456
  },
  "C_OP_LerpEndCapScalar": {
    "m_flLerpTime": 456,
    "m_flOutput": 452,
    "m_nFieldOutput": 448
  },
  "C_OP_LerpEndCapVector": {
    "m_flLerpTime": 464,
    "m_nFieldOutput": 448,
    "m_vecOutput": 452
  },
  "C_OP_LerpScalar": {
    "m_flEndTime": 804,
    "m_flOutput": 456,
    "m_flStartTime": 800,
    "m_nFieldOutput": 448
  },
  "C_OP_LerpToInitialPosition": {
    "m_flInterpolation": 456,
    "m_flScale": 808,
    "m_nCacheField": 800,
    "m_nControlPointNumber": 448,
    "m_vecScale": 1152
  },
  "C_OP_LerpToOtherAttribute": {
    "m_flInterpolation": 448,
    "m_nFieldInput": 796,
    "m_nFieldInputFrom": 792,
    "m_nFieldOutput": 800
  },
  "C_OP_LerpVector": {
    "m_flEndTime": 468,
    "m_flStartTime": 464,
    "m_nFieldOutput": 448,
    "m_nSetMethod": 472,
    "m_vecOutput": 452
  },
  "C_OP_LightningSnapshotGenerator": {
    "m_flBranchTwist": 2888,
    "m_flDedicatedPool": 3928,
    "m_flOffset": 824,
    "m_flOffsetDecay": 1168,
    "m_flRadiusEnd": 3584,
    "m_flRadiusStart": 3240,
    "m_flRecalcRate": 1512,
    "m_flSegments": 480,
    "m_flSplitRate": 2544,
    "m_flUVOffset": 2200,
    "m_flUVScale": 1856,
    "m_nBranchBehavior": 3232,
    "m_nCPEndPnt": 472,
    "m_nCPSnapshot": 464,
    "m_nCPStartPnt": 468
  },
  "C_OP_LocalAccelerationForce": {
    "m_nCP": 464,
    "m_nScaleCP": 468,
    "m_vecAccel": 472
  },
  "C_OP_LockPoints": {
    "m_flBlendValue": 468,
    "m_nControlPoint": 464,
    "m_nMaxCol": 452,
    "m_nMaxRow": 460,
    "m_nMinCol": 448,
    "m_nMinRow": 456
  },
  "C_OP_LockToBone": {
    "m_HitboxSetName": 664,
    "m_bRigid": 792,
    "m_bRigidRotationLock": 808,
    "m_bUseBones": 793,
    "m_flJumpThreshold": 656,
    "m_flLifeTimeFadeEnd": 652,
    "m_flLifeTimeFadeStart": 648,
    "m_flPrevPosScale": 660,
    "m_flRotLerp": 2440,
    "m_modelInput": 448,
    "m_nFieldOutput": 796,
    "m_nFieldOutputPrev": 800,
    "m_nRotationSetType": 804,
    "m_transformInput": 544,
    "m_vecRotation": 816
  },
  "C_OP_LockToPointList": {
    "m_bClosedLoop": 481,
    "m_bPlaceAlongPath": 480,
    "m_nFieldOutput": 448,
    "m_nNumPointsAlongPath": 484,
    "m_pointList": 456
  },
  "C_OP_LockToSavedSequentialPath": {
    "m_PathParams": 464,
    "m_bCPPairs": 460,
    "m_flFadeEnd": 456,
    "m_flFadeStart": 452
  },
  "C_OP_LockToSavedSequentialPathV2": {
    "m_PathParams": 464,
    "m_bCPPairs": 456,
    "m_flFadeEnd": 452,
    "m_flFadeStart": 448
  },
  "C_OP_MaintainEmitter": {
    "m_bEmitInstantaneously": 1152,
    "m_bFinalEmitOnStop": 1153,
    "m_flEmissionDuration": 800,
    "m_flEmissionRate": 1144,
    "m_flScale": 1160,
    "m_flStartTime": 792,
    "m_nParticlesToMaintain": 448,
    "m_nSnapshotControlPoint": 1148
  },
  "C_OP_MaintainSequentialPath": {
    "m_PathParams": 480,
    "m_bLoop": 464,
    "m_bUseParticleCount": 465,
    "m_fMaxDistance": 448,
    "m_flCohesionStrength": 456,
    "m_flNumToAssign": 452,
    "m_flTolerance": 460
  },
  "C_OP_MaxVelocity": {
    "m_flMaxVelocity": 448,
    "m_flMinVelocity": 452,
    "m_nOverrideCP": 456,
    "m_nOverrideCPField": 460
  },
  "C_OP_ModelCull": {
    "m_HitboxSetName": 455,
    "m_bBoundBox": 452,
    "m_bCullOutside": 453,
    "m_bUseBones": 454,
    "m_nControlPointNumber": 448
  },
  "C_OP_ModelDampenMovement": {
    "m_HitboxSetName": 455,
    "m_bBoundBox": 452,
    "m_bOutside": 453,
    "m_bUseBones": 454,
    "m_fDrag": 2208,
    "m_nControlPointNumber": 448,
    "m_vecPosOffset": 584
  },
  "C_OP_MoveToHitbox": {
    "m_HitboxSetName": 664,
    "m_bUseBones": 792,
    "m_flInterpolation": 800,
    "m_flLifeTimeLerpEnd": 656,
    "m_flLifeTimeLerpStart": 652,
    "m_flPrevPosScale": 660,
    "m_modelInput": 448,
    "m_nLerpType": 796,
    "m_transformInput": 544
  },
  "C_OP_MovementLoopInsideSphere": {
    "m_flDistance": 456,
    "m_nCP": 448,
    "m_nDistSqrAttr": 2424,
    "m_vecScale": 800
  },
  "C_OP_MovementMaintainOffset": {
    "m_bRadiusScale": 464,
    "m_nCP": 460,
    "m_vecOffset": 448
  },
  "C_OP_MovementMoveAlongSkinnedCPSnapshot": {
    "m_bSetNormal": 456,
    "m_bSetRadius": 457,
    "m_flInterpolation": 464,
    "m_flTValue": 808,
    "m_nControlPointNumber": 448,
    "m_nSnapshotControlPointNumber": 452
  },
  "C_OP_MovementPlaceOnGround": {
    "m_CollisionGroupName": 808,
    "m_bIncludeShotHull": 964,
    "m_bIncludeWater": 965,
    "m_bScaleOffset": 969,
    "m_bSetNormal": 968,
    "m_flLerpRate": 804,
    "m_flMaxTraceLength": 792,
    "m_flOffset": 448,
    "m_flTolerance": 796,
    "m_flTraceOffset": 800,
    "m_nIgnoreCP": 976,
    "m_nLerpCP": 948,
    "m_nPreserveOffsetCP": 972,
    "m_nRefCP1": 940,
    "m_nRefCP2": 944,
    "m_nTraceMissBehavior": 960,
    "m_nTraceSet": 936
  },
  "C_OP_MovementRigidAttachToCP": {
    "m_bOffsetLocal": 468,
    "m_nControlPointNumber": 448,
    "m_nFieldInput": 460,
    "m_nFieldOutput": 464,
    "m_nScaleCPField": 456,
    "m_nScaleControlPoint": 452
  },
  "C_OP_MovementRotateParticleAroundAxis": {
    "m_TransformInput": 2416,
    "m_bLocalSpace": 2520,
    "m_flRotRate": 2072,
    "m_vecRotAxis": 448
  },
  "C_OP_MovementSkinnedPositionFromCPSnapshot": {
    "m_bRandom": 456,
    "m_bSetNormal": 464,
    "m_bSetRadius": 465,
    "m_flIncrement": 472,
    "m_flInterpolation": 1504,
    "m_nControlPointNumber": 452,
    "m_nFullLoopIncrement": 816,
    "m_nRandomSeed": 460,
    "m_nSnapShotStartPoint": 1160,
    "m_nSnapshotControlPointNumber": 448
  },
  "C_OP_Noise": {
    "m_bAdditive": 464,
    "m_fl4NoiseScale": 460,
    "m_flNoiseAnimationTimeScale": 468,
    "m_flOutputMax": 456,
    "m_flOutputMin": 452,
    "m_nFieldOutput": 448
  },
  "C_OP_NoiseEmitter": {
    "m_bAbsVal": 472,
    "m_bAbsValInv": 473,
    "m_flEmissionDuration": 448,
    "m_flEmissionScale": 456,
    "m_flNoiseScale": 488,
    "m_flOffset": 476,
    "m_flOutputMax": 484,
    "m_flOutputMin": 480,
    "m_flStartTime": 452,
    "m_flWorldNoiseScale": 492,
    "m_flWorldTimeScale": 508,
    "m_nScaleControlPoint": 460,
    "m_nScaleControlPointField": 464,
    "m_nWorldNoisePoint": 468,
    "m_vecOffsetLoc": 496
  },
  "C_OP_NormalLock": {
    "m_nControlPointNumber": 448
  },
  "C_OP_NormalizeVector": {
    "m_flScale": 452,
    "m_nFieldOutput": 448
  },
  "C_OP_Orient2DRelToCP": {
    "m_flRotOffset": 448,
    "m_flSpinStrength": 452,
    "m_nCP": 456,
    "m_nFieldOutput": 460
  },
  "C_OP_OrientTo2dDirection": {
    "m_flRotOffset": 448,
    "m_flSpinStrength": 452,
    "m_nFieldOutput": 456
  },
  "C_OP_OscillateScalar": {
    "m_FrequencyMax": 460,
    "m_FrequencyMin": 456,
    "m_RateMax": 452,
    "m_RateMin": 448,
    "m_bProportional": 468,
    "m_bProportionalOp": 469,
    "m_flEndTime_max": 484,
    "m_flEndTime_min": 480,
    "m_flOscAdd": 492,
    "m_flOscMult": 488,
    "m_flStartTime_max": 476,
    "m_flStartTime_min": 472,
    "m_nField": 464
  },
  "C_OP_OscillateScalarSimple": {
    "m_Frequency": 452,
    "m_Rate": 448,
    "m_flOscAdd": 464,
    "m_flOscMult": 460,
    "m_nField": 456
  },
  "C_OP_OscillateVector": {
    "m_FrequencyMax": 484,
    "m_FrequencyMin": 472,
    "m_RateMax": 460,
    "m_RateMin": 448,
    "m_bOffset": 502,
    "m_bProportional": 500,
    "m_bProportionalOp": 501,
    "m_flEndTime_max": 516,
    "m_flEndTime_min": 512,
    "m_flOscAdd": 864,
    "m_flOscMult": 520,
    "m_flRateScale": 1208,
    "m_flStartTime_max": 508,
    "m_flStartTime_min": 504,
    "m_nField": 496
  },
  "C_OP_OscillateVectorSimple": {
    "m_Frequency": 460,
    "m_Rate": 448,
    "m_bOffset": 484,
    "m_flOscAdd": 480,
    "m_flOscMult": 476,
    "m_nField": 472
  },
  "C_OP_ParentVortices": {
    "m_bFlipBasedOnYaw": 480,
    "m_flForceScale": 464,
    "m_vecTwistAxis": 468
  },
  "C_OP_ParticlePhysics": {
    "m_Gravity": 448,
    "m_fDrag": 2072,
    "m_nMaxConstraintPasses": 2416
  },
  "C_OP_PerParticleForce": {
    "m_flForceScale": 464,
    "m_nCP": 2432,
    "m_vForce": 808
  },
  "C_OP_PercentageBetweenTransformLerpCPs": {
    "m_TransformEnd": 568,
    "m_TransformStart": 464,
    "m_bActiveRange": 692,
    "m_bRadialCheck": 693,
    "m_flInputMax": 456,
    "m_flInputMin": 452,
    "m_nFieldOutput": 448,
    "m_nOutputEndCP": 680,
    "m_nOutputEndField": 684,
    "m_nOutputStartCP": 672,
    "m_nOutputStartField": 676,
    "m_nSetMethod": 688
  },
  "C_OP_PercentageBetweenTransforms": {
    "m_TransformEnd": 576,
    "m_TransformStart": 472,
    "m_bActiveRange": 684,
    "m_bRadialCheck": 685,
    "m_flInputMax": 456,
    "m_flInputMin": 452,
    "m_flOutputMax": 464,
    "m_flOutputMin": 460,
    "m_nFieldOutput": 448,
    "m_nSetMethod": 680
  },
  "C_OP_PercentageBetweenTransformsVector": {
    "m_TransformEnd": 592,
    "m_TransformStart": 488,
    "m_bActiveRange": 700,
    "m_bRadialCheck": 701,
    "m_flInputMax": 456,
    "m_flInputMin": 452,
    "m_nFieldOutput": 448,
    "m_nSetMethod": 696,
    "m_vecOutputMax": 472,
    "m_vecOutputMin": 460
  },
  "C_OP_PinParticleToCP": {
    "m_bOffsetLocal": 2080,
    "m_flAge": 3128,
    "m_flBreakDistance": 2440,
    "m_flBreakSpeed": 2784,
    "m_flBreakValue": 3480,
    "m_flInterpolation": 3824,
    "m_nBreakControlPointNumber": 3472,
    "m_nBreakControlPointNumber2": 3476,
    "m_nControlPointNumber": 448,
    "m_nParticleNumber": 2088,
    "m_nParticleSelection": 2084,
    "m_nPinBreakType": 2432,
    "m_vecOffset": 456
  },
  "C_OP_PlanarConstraint": {
    "m_PlaneNormal": 460,
    "m_PointOnPlane": 448,
    "m_bGlobalNormal": 477,
    "m_bGlobalOrigin": 476,
    "m_flMaximumDistanceToCP": 824,
    "m_flRadiusScale": 480,
    "m_nControlPointNumber": 472
  },
  "C_OP_PlaneCull": {
    "m_bLocalSpace": 464,
    "m_flPlaneOffset": 468,
    "m_nPlaneControlPoint": 448,
    "m_vecPlaneDirection": 452
  },
  "C_OP_PlayEndCapWhenFinished": {
    "m_bFireOnEmissionEnd": 464,
    "m_bIncludeChildren": 465
  },
  "C_OP_PointVectorAtNextParticle": {
    "m_flInterpolation": 456,
    "m_nFieldOutput": 448
  },
  "C_OP_PositionLock": {
    "m_TransformInput": 448,
    "m_bLockRot": 936,
    "m_flEndTime_exp": 572,
    "m_flEndTime_max": 568,
    "m_flEndTime_min": 564,
    "m_flJumpThreshold": 928,
    "m_flPrevPosScale": 932,
    "m_flRange": 576,
    "m_flRangeBias": 584,
    "m_flStartTime_exp": 560,
    "m_flStartTime_max": 556,
    "m_flStartTime_min": 552,
    "m_nFieldOutput": 2568,
    "m_nFieldOutputPrev": 2572,
    "m_vecScale": 944
  },
  "C_OP_QuantizeCPComponent": {
    "m_flInputValue": 464,
    "m_flQuantizeValue": 816,
    "m_nCPOutput": 808,
    "m_nOutVectorField": 812
  },
  "C_OP_QuantizeFloat": {
    "m_InputValue": 448,
    "m_nOutputField": 792
  },
  "C_OP_RadiusDecay": {
    "m_flMinRadius": 448
  },
  "C_OP_RampCPLinearRandom": {
    "m_nOutControlPointNumber": 464,
    "m_vecRateMax": 480,
    "m_vecRateMin": 468
  },
  "C_OP_RampScalarLinear": {
    "m_RateMax": 452,
    "m_RateMin": 448,
    "m_bProportionalOp": 516,
    "m_flEndTime_max": 468,
    "m_flEndTime_min": 464,
    "m_flStartTime_max": 460,
    "m_flStartTime_min": 456,
    "m_nField": 512
  },
  "C_OP_RampScalarLinearSimple": {
    "m_Rate": 448,
    "m_flEndTime": 456,
    "m_flStartTime": 452,
    "m_nField": 496
  },
  "C_OP_RampScalarSpline": {
    "m_RateMax": 452,
    "m_RateMin": 448,
    "m_bEaseOut": 517,
    "m_bProportionalOp": 516,
    "m_flBias": 472,
    "m_flEndTime_max": 468,
    "m_flEndTime_min": 464,
    "m_flStartTime_max": 460,
    "m_flStartTime_min": 456,
    "m_nField": 512
  },
  "C_OP_RampScalarSplineSimple": {
    "m_Rate": 448,
    "m_bEaseOut": 500,
    "m_flEndTime": 456,
    "m_flStartTime": 452,
    "m_nField": 496
  },
  "C_OP_RandomForce": {
    "m_MaxForce": 476,
    "m_MinForce": 464
  },
  "C_OP_ReadFromNeighboringParticle": {
    "m_DistanceCheck": 464,
    "m_flInterpolation": 808,
    "m_nFieldInput": 448,
    "m_nFieldOutput": 452,
    "m_nIncrement": 456
  },
  "C_OP_ReinitializeScalarEndCap": {
    "m_flOutputMax": 456,
    "m_flOutputMin": 452,
    "m_nFieldOutput": 448
  },
  "C_OP_RemapAverageHitboxSpeedtoCP": {
    "m_HitboxSetName": 3488,
    "m_flInputMax": 824,
    "m_flInputMin": 480,
    "m_flOutputMax": 1512,
    "m_flOutputMin": 1168,
    "m_nField": 472,
    "m_nHeightControlPointNumber": 1856,
    "m_nHitboxDataType": 476,
    "m_nInControlPointNumber": 464,
    "m_nOutControlPointNumber": 468,
    "m_vecComparisonVelocity": 1864
  },
  "C_OP_RemapAverageScalarValuetoCP": {
    "m_flInputMax": 480,
    "m_flInputMin": 476,
    "m_flOutputMax": 488,
    "m_flOutputMin": 484,
    "m_nField": 472,
    "m_nOutControlPointNumber": 464,
    "m_nOutVectorField": 468
  },
  "C_OP_RemapBoundingVolumetoCP": {
    "m_flInputMax": 472,
    "m_flInputMin": 468,
    "m_flOutputMax": 480,
    "m_flOutputMin": 476,
    "m_nOutControlPointNumber": 464
  },
  "C_OP_RemapCPVelocityToVector": {
    "m_bNormalize": 460,
    "m_flScale": 456,
    "m_nControlPoint": 448,
    "m_nFieldOutput": 452
  },
  "C_OP_RemapCPtoCP": {
    "m_bDerivative": 496,
    "m_flInputMax": 484,
    "m_flInputMin": 480,
    "m_flInterpRate": 500,
    "m_flOutputMax": 492,
    "m_flOutputMin": 488,
    "m_nInputControlPoint": 464,
    "m_nInputField": 472,
    "m_nOutputControlPoint": 468,
    "m_nOutputField": 476
  },
  "C_OP_RemapCPtoScalar": {
    "m_flEndTime": 480,
    "m_flInputMax": 464,
    "m_flInputMin": 460,
    "m_flInterpRate": 484,
    "m_flOutputMax": 472,
    "m_flOutputMin": 468,
    "m_flStartTime": 476,
    "m_nCPInput": 448,
    "m_nField": 456,
    "m_nFieldOutput": 452,
    "m_nSetMethod": 488
  },
  "C_OP_RemapCPtoVector": {
    "m_bAccelerate": 525,
    "m_bOffset": 524,
    "m_flEndTime": 512,
    "m_flInterpRate": 516,
    "m_flStartTime": 508,
    "m_nCPInput": 448,
    "m_nFieldOutput": 452,
    "m_nLocalSpaceCP": 456,
    "m_nSetMethod": 520,
    "m_vInputMax": 472,
    "m_vInputMin": 460,
    "m_vOutputMax": 496,
    "m_vOutputMin": 484
  },
  "C_OP_RemapControlPointDirectionToVector": {
    "m_flScale": 452,
    "m_nControlPointNumber": 456,
    "m_nFieldOutput": 448
  },
  "C_OP_RemapControlPointOrientationToRotation": {
    "m_flOffsetRot": 456,
    "m_nCP": 448,
    "m_nComponent": 460,
    "m_nFieldOutput": 452
  },
  "C_OP_RemapCrossProductOfTwoVectorsToVector": {
    "m_InputVec1": 448,
    "m_InputVec2": 2072,
    "m_bNormalize": 3700,
    "m_nFieldOutput": 3696
  },
  "C_OP_RemapDensityGradientToVectorAttribute": {
    "m_flRadiusScale": 448,
    "m_nFieldOutput": 452
  },
  "C_OP_RemapDensityToVector": {
    "m_bUseParentDensity": 488,
    "m_flDensityMax": 460,
    "m_flDensityMin": 456,
    "m_flRadiusScale": 448,
    "m_nFieldOutput": 452,
    "m_nVoxelGridResolution": 492,
    "m_vecOutputMax": 476,
    "m_vecOutputMin": 464
  },
  "C_OP_RemapDirectionToCPToVector": {
    "m_bNormalize": 476,
    "m_flOffsetRot": 460,
    "m_flScale": 456,
    "m_nCP": 448,
    "m_nFieldOutput": 452,
    "m_nFieldStrength": 480,
    "m_vecOffsetAxis": 464
  },
  "C_OP_RemapDistanceToLineSegmentBase": {
    "m_bInfiniteLine": 464,
    "m_flMaxInputValue": 460,
    "m_flMinInputValue": 456,
    "m_nCP0": 448,
    "m_nCP1": 452
  },
  "C_OP_RemapDistanceToLineSegmentToScalar": {
    "m_flMaxOutputValue": 488,
    "m_flMinOutputValue": 484,
    "m_nFieldOutput": 480
  },
  "C_OP_RemapDistanceToLineSegmentToVector": {
    "m_nFieldOutput": 480,
    "m_vMaxOutputValue": 496,
    "m_vMinOutputValue": 484
  },
  "C_OP_RemapDotProductToCP": {
    "m_flInputMax": 824,
    "m_flInputMin": 480,
    "m_flOutputMax": 1512,
    "m_flOutputMin": 1168,
    "m_nInputCP1": 464,
    "m_nInputCP2": 468,
    "m_nOutVectorField": 476,
    "m_nOutputCP": 472
  },
  "C_OP_RemapDotProductToScalar": {
    "m_bActiveRange": 484,
    "m_bUseParticleNormal": 485,
    "m_bUseParticleVelocity": 476,
    "m_flInputMax": 464,
    "m_flInputMin": 460,
    "m_flOutputMax": 472,
    "m_flOutputMin": 468,
    "m_nFieldOutput": 456,
    "m_nInputCP1": 448,
    "m_nInputCP2": 452,
    "m_nSetMethod": 480
  },
  "C_OP_RemapExternalWindToCP": {
    "m_bSetMagnitude": 2096,
    "m_nCP": 464,
    "m_nCPOutput": 468,
    "m_nOutVectorField": 2100,
    "m_vecScale": 472
  },
  "C_OP_RemapModelVolumetoCP": {
    "m_flInputMax": 488,
    "m_flInputMin": 484,
    "m_flOutputMax": 496,
    "m_flOutputMin": 492,
    "m_nBBoxType": 464,
    "m_nField": 480,
    "m_nInControlPointNumber": 468,
    "m_nOutControlPointMaxNumber": 476,
    "m_nOutControlPointNumber": 472
  },
  "C_OP_RemapNamedModelElementEndCap": {
    "m_bModelFromRenderer": 528,
    "m_fallbackNames": 504,
    "m_hModel": 448,
    "m_inNames": 456,
    "m_nFieldInput": 532,
    "m_nFieldOutput": 536,
    "m_outNames": 480
  },
  "C_OP_RemapNamedModelElementOnceTimed": {
    "m_bModelFromRenderer": 528,
    "m_bProportional": 529,
    "m_fallbackNames": 504,
    "m_flRemapTime": 540,
    "m_hModel": 448,
    "m_inNames": 456,
    "m_nFieldInput": 532,
    "m_nFieldOutput": 536,
    "m_outNames": 480
  },
  "C_OP_RemapParticleCountOnScalarEndCap": {
    "m_bBackwards": 468,
    "m_flOutputMax": 464,
    "m_flOutputMin": 460,
    "m_nFieldOutput": 448,
    "m_nInputMax": 456,
    "m_nInputMin": 452,
    "m_nSetMethod": 472
  },
  "C_OP_RemapParticleCountToScalar": {
    "m_bActiveRange": 1832,
    "m_flOutputMax": 1488,
    "m_flOutputMin": 1144,
    "m_nFieldOutput": 448,
    "m_nInputMax": 800,
    "m_nInputMin": 456,
    "m_nSetMethod": 1836
  },
  "C_OP_RemapSDFDistanceToScalarAttribute": {
    "m_flMaxDistance": 800,
    "m_flMinDistance": 456,
    "m_flValueAboveMax": 2176,
    "m_flValueAtMax": 1832,
    "m_flValueAtMin": 1488,
    "m_flValueBelowMin": 1144,
    "m_nFieldOutput": 448,
    "m_nVectorFieldInput": 452
  },
  "C_OP_RemapSDFDistanceToVectorAttribute": {
    "m_flMaxDistance": 800,
    "m_flMinDistance": 456,
    "m_nVectorFieldInput": 452,
    "m_nVectorFieldOutput": 448,
    "m_vValueAboveMax": 1180,
    "m_vValueAtMax": 1168,
    "m_vValueAtMin": 1156,
    "m_vValueBelowMin": 1144
  },
  "C_OP_RemapSDFGradientToVectorAttribute": {
    "m_nFieldOutput": 448
  },
  "C_OP_RemapScalar": {
    "m_bOldCode": 472,
    "m_flInputMax": 460,
    "m_flInputMin": 456,
    "m_flOutputMax": 468,
    "m_flOutputMin": 464,
    "m_nFieldInput": 448,
    "m_nFieldOutput": 452
  },
  "C_OP_RemapScalarEndCap": {
    "m_flInputMax": 460,
    "m_flInputMin": 456,
    "m_flOutputMax": 468,
    "m_flOutputMin": 464,
    "m_nFieldInput": 448,
    "m_nFieldOutput": 452
  },
  "C_OP_RemapScalarOnceTimed": {
    "m_bProportional": 448,
    "m_flInputMax": 464,
    "m_flInputMin": 460,
    "m_flOutputMax": 472,
    "m_flOutputMin": 468,
    "m_flRemapTime": 476,
    "m_nFieldInput": 452,
    "m_nFieldOutput": 456
  },
  "C_OP_RemapSpeed": {
    "m_bIgnoreDelta": 472,
    "m_flInputMax": 456,
    "m_flInputMin": 452,
    "m_flOutputMax": 464,
    "m_flOutputMin": 460,
    "m_nFieldOutput": 448,
    "m_nSetMethod": 468
  },
  "C_OP_RemapSpeedtoCP": {
    "m_bUseDeltaV": 492,
    "m_flInputMax": 480,
    "m_flInputMin": 476,
    "m_flOutputMax": 488,
    "m_flOutputMin": 484,
    "m_nField": 472,
    "m_nInControlPointNumber": 464,
    "m_nOutControlPointNumber": 468
  },
  "C_OP_RemapTransformOrientationToRotations": {
    "m_TransformInput": 448,
    "m_bUseQuat": 564,
    "m_bWriteNormal": 565,
    "m_vecRotation": 552
  },
  "C_OP_RemapTransformOrientationToYaw": {
    "m_TransformInput": 448,
    "m_flRotOffset": 556,
    "m_flSpinStrength": 560,
    "m_nFieldOutput": 552
  },
  "C_OP_RemapTransformToVelocity": {
    "m_TransformInput": 448
  },
  "C_OP_RemapTransformVisibilityToScalar": {
    "m_TransformInput": 456,
    "m_flInputMax": 568,
    "m_flInputMin": 564,
    "m_flOutputMax": 576,
    "m_flOutputMin": 572,
    "m_flRadius": 580,
    "m_nFieldOutput": 560,
    "m_nSetMethod": 448
  },
  "C_OP_RemapTransformVisibilityToVector": {
    "m_TransformInput": 456,
    "m_flInputMax": 568,
    "m_flInputMin": 564,
    "m_flRadius": 596,
    "m_nFieldOutput": 560,
    "m_nSetMethod": 448,
    "m_vecOutputMax": 584,
    "m_vecOutputMin": 572
  },
  "C_OP_RemapVectorComponentToScalar": {
    "m_nComponent": 456,
    "m_nFieldInput": 448,
    "m_nFieldOutput": 452
  },
  "C_OP_RemapVectortoCP": {
    "m_nFieldInput": 452,
    "m_nOutControlPointNumber": 448,
    "m_nParticleNumber": 456
  },
  "C_OP_RemapVelocityToVector": {
    "m_bNormalize": 456,
    "m_flScale": 452,
    "m_nFieldOutput": 448
  },
  "C_OP_RemapVisibilityScalar": {
    "m_flInputMax": 460,
    "m_flInputMin": 456,
    "m_flOutputMax": 468,
    "m_flOutputMin": 464,
    "m_flRadiusScale": 472,
    "m_nFieldInput": 448,
    "m_nFieldOutput": 452
  },
  "C_OP_RenderAsModels": {
    "m_ModelList": 512,
    "m_bFitToModelSize": 544,
    "m_bNonUniformScaling": 545,
    "m_flModelScale": 540,
    "m_nSizeCullBloat": 560,
    "m_nXAxisScalingAttribute": 548,
    "m_nYAxisScalingAttribute": 552,
    "m_nZAxisScalingAttribute": 556
  },
  "C_OP_RenderBlobs": {
    "m_MaterialVars": 1552,
    "m_cubeWidth": 512,
    "m_cutoffRadius": 856,
    "m_hMaterial": 1600,
    "m_nScaleCP": 1544,
    "m_renderRadius": 1200
  },
  "C_OP_RenderCables": {
    "m_LightingTransform": 4944,
    "m_MaterialFloatVars": 5048,
    "m_MaterialVecVars": 5096,
    "m_bDrawCableCaps": 4912,
    "m_flAlphaScale": 856,
    "m_flCapOffsetAmount": 4920,
    "m_flCapRoundness": 4916,
    "m_flColorMapOffsetU": 3880,
    "m_flColorMapOffsetV": 3536,
    "m_flNormalMapOffsetU": 4568,
    "m_flNormalMapOffsetV": 4224,
    "m_flRadiusScale": 512,
    "m_flTessScale": 4924,
    "m_flTextureRepeatsCircumference": 3192,
    "m_flTextureRepeatsPerSegment": 2848,
    "m_hMaterial": 2832,
    "m_nColorBlendType": 2824,
    "m_nMaxTesselation": 4932,
    "m_nMinTesselation": 4928,
    "m_nRoundness": 4936,
    "m_nTextureRepetitionMode": 2840,
    "m_vecColorScale": 1200
  },
  "C_OP_RenderDeferredLight": {
    "m_bUseAlphaTestWindow": 512,
    "m_bUseTexture": 513,
    "m_flAlphaScale": 520,
    "m_flDistanceFalloff": 2164,
    "m_flLightDistance": 2156,
    "m_flRadiusScale": 516,
    "m_flSpotFoV": 2168,
    "m_flStartFalloff": 2160,
    "m_hTexture": 2184,
    "m_nAlpha2Field": 524,
    "m_nAlphaTestPointField": 2172,
    "m_nAlphaTestRangeField": 2176,
    "m_nAlphaTestSharpnessField": 2180,
    "m_nColorBlendType": 2152,
    "m_nHSVShiftControlPoint": 2192,
    "m_vecColorScale": 528
  },
  "C_OP_RenderFlattenGrass": {
    "m_flFlattenStrength": 512,
    "m_flRadiusScale": 520,
    "m_nStrengthFieldOverride": 516
  },
  "C_OP_RenderGpuImplicit": {
    "m_bUsePerParticleRadius": 512,
    "m_fGridSize": 520,
    "m_fIsosurfaceThreshold": 1208,
    "m_fRadiusScale": 864,
    "m_hMaterial": 1560,
    "m_nScaleCP": 1552
  },
  "C_OP_RenderLightBeam": {
    "m_bCastShadows": 2488,
    "m_flBrightnessLumensPerMeter": 2144,
    "m_flRange": 2840,
    "m_flSkirt": 2496,
    "m_flThickness": 3184,
    "m_nColorBlendType": 2136,
    "m_vColorBlend": 512
  },
  "C_OP_RenderLights": {
    "m_bAnimateInFPS": 536,
    "m_flAnimationRate": 528,
    "m_flEndFadeSize": 552,
    "m_flMaxSize": 544,
    "m_flMinSize": 540,
    "m_flStartFadeSize": 548,
    "m_nAnimationType": 532
  },
  "C_OP_RenderMaterialProxy": {
    "m_MaterialVars": 520,
    "m_flAlpha": 2520,
    "m_flMaterialOverrideEnabled": 552,
    "m_hOverrideMaterial": 544,
    "m_nColorBlendType": 2864,
    "m_nMaterialControlPoint": 512,
    "m_nProxyType": 516,
    "m_vecColorScale": 896
  },
  "C_OP_RenderModels": {
    "m_ActivityName": 5472,
    "m_EconSlotName": 6476,
    "m_MaterialVars": 6352,
    "m_ModelList": 520,
    "m_SequenceName": 5728,
    "m_bAcceptsDecals": 6736,
    "m_bAnimated": 5448,
    "m_bCenterOffset": 558,
    "m_bDisableShadows": 6735,
    "m_bDoNotDrawInParticlePass": 6738,
    "m_bEnableClothSimulation": 5984,
    "m_bForceDrawInterlevedWithSiblings": 6737,
    "m_bForceLoopingAnimation": 5457,
    "m_bIgnoreNormal": 556,
    "m_bIgnoreRadius": 3808,
    "m_bLocalScale": 5440,
    "m_bManualAnimFrame": 5459,
    "m_bOnlyRenderInEffecsGameOverlay": 515,
    "m_bOnlyRenderInEffectsBloomPass": 512,
    "m_bOnlyRenderInEffectsWaterPass": 513,
    "m_bOrientZ": 557,
    "m_bOriginalModel": 6732,
    "m_bOverrideTranslucentMaterials": 6000,
    "m_bResetAnimOnStop": 5458,
    "m_bScaleAnimationRate": 5456,
    "m_bSuppressTint": 6733,
    "m_bUseMixedResolutionRendering": 514,
    "m_bUseRawMeshGroup": 6734,
    "m_flAlphaScale": 7344,
    "m_flAnimationRate": 5452,
    "m_flRadiusScale": 7000,
    "m_flRollScale": 7688,
    "m_hOverrideMaterial": 5992,
    "m_modelInput": 6376,
    "m_nAlpha2Field": 8032,
    "m_nAnimationField": 5464,
    "m_nAnimationScaleField": 5460,
    "m_nBodyGroupField": 548,
    "m_nColorBlendType": 9664,
    "m_nLOD": 6472,
    "m_nManualFrameField": 5468,
    "m_nModelScaleCP": 3812,
    "m_nSizeCullBloat": 5444,
    "m_nSkin": 6008,
    "m_nSubModelField": 552,
    "m_szRenderAttribute": 6739,
    "m_vecColorScale": 8040,
    "m_vecComponentScale": 3816,
    "m_vecLocalOffset": 560,
    "m_vecLocalRotation": 2184
  },
  "C_OP_RenderOmni2Light": {
    "m_bCastShadows": 2840,
    "m_bSphericalCookie": 4576,
    "m_flBrightnessCandelas": 2496,
    "m_flBrightnessLumens": 2152,
    "m_flInnerConeAngle": 3880,
    "m_flLuminaireRadius": 2848,
    "m_flOuterConeAngle": 4224,
    "m_flRange": 3536,
    "m_flSkirt": 3192,
    "m_hLightCookie": 4568,
    "m_nBrightnessUnit": 2148,
    "m_nColorBlendType": 2144,
    "m_nLightType": 512,
    "m_vColorBlend": 520
  },
  "C_OP_RenderPoints": {
    "m_hMaterial": 512
  },
  "C_OP_RenderPostProcessing": {
    "m_flPostProcessStrength": 512,
    "m_hPostTexture": 856,
    "m_nPriority": 864
  },
  "C_OP_RenderProjected": {
    "m_MaterialVars": 544,
    "m_bEnableProjectedDepthControls": 516,
    "m_bFlipHorizontal": 515,
    "m_bOrientToNormal": 540,
    "m_bProjectCharacter": 512,
    "m_bProjectWater": 514,
    "m_bProjectWorld": 513,
    "m_flAnimationTimeScale": 536,
    "m_flMaxProjectionDepth": 524,
    "m_flMinProjectionDepth": 520,
    "m_hProjectedMaterial": 528
  },
  "C_OP_RenderRopes": {
    "m_bClampV": 10412,
    "m_bClosedLoop": 10449,
    "m_bDrawAsOpaque": 10460,
    "m_bEnableFadingAndClamping": 9328,
    "m_bGenerateNormals": 10461,
    "m_bReverseOrder": 10448,
    "m_bUseScalarForTextureCoordinate": 10437,
    "m_flEndFadeDot": 9352,
    "m_flEndFadeSize": 9344,
    "m_flMaxSize": 9336,
    "m_flMinSize": 9332,
    "m_flRadiusTaper": 9356,
    "m_flScalarAttributeTextureCoordScale": 10444,
    "m_flScaleVOffsetByControlPointDistance": 10432,
    "m_flScaleVScrollByControlPointDistance": 10428,
    "m_flScaleVSizeByControlPointDistance": 10424,
    "m_flStartFadeDot": 9348,
    "m_flStartFadeSize": 9340,
    "m_flTessScale": 9368,
    "m_flTextureVOffset": 10064,
    "m_flTextureVScrollRate": 9720,
    "m_flTextureVWorldSize": 9376,
    "m_nMaxTesselation": 9364,
    "m_nMinTesselation": 9360,
    "m_nOrientationType": 10452,
    "m_nScalarFieldForTextureCoordinate": 10440,
    "m_nScaleCP1": 10416,
    "m_nScaleCP2": 10420,
    "m_nTextureVParamsCP": 10408,
    "m_nVectorFieldForOrientation": 10456
  },
  "C_OP_RenderScreenShake": {
    "m_flAmplitudeScale": 524,
    "m_flDurationScale": 512,
    "m_flFrequencyScale": 520,
    "m_flRadiusScale": 516,
    "m_nAmplitudeField": 540,
    "m_nDurationField": 532,
    "m_nFilterCP": 544,
    "m_nFrequencyField": 536,
    "m_nRadiusField": 528
  },
  "C_OP_RenderScreenVelocityRotate": {
    "m_flForwardDegrees": 516,
    "m_flRotateRateDegrees": 512
  },
  "C_OP_RenderSound": {
    "m_bSuppressStopSoundEvent": 808,
    "m_flDurationScale": 512,
    "m_flPitchScale": 520,
    "m_flSndLvlScale": 516,
    "m_flVolumeScale": 524,
    "m_nCPReference": 548,
    "m_nChannel": 544,
    "m_nDurationField": 532,
    "m_nPitchField": 536,
    "m_nSndLvlField": 528,
    "m_nVolumeField": 540,
    "m_pszSoundName": 552
  },
  "C_OP_RenderSprites": {
    "m_OutlineColor": 10405,
    "m_bDistanceAlpha": 10392,
    "m_bOutline": 10404,
    "m_bParticleShadows": 11128,
    "m_bSoftEdges": 10393,
    "m_bUseYawWithNormalAligned": 9680,
    "m_flAlphaAdjustWithSizeAdjust": 9692,
    "m_flEdgeSoftnessEnd": 10400,
    "m_flEdgeSoftnessStart": 10396,
    "m_flEndFadeDot": 10388,
    "m_flEndFadeSize": 10040,
    "m_flLightingDirectionality": 10784,
    "m_flLightingTessellation": 10440,
    "m_flMaxSize": 9688,
    "m_flMinSize": 9684,
    "m_flOutlineEnd0": 10424,
    "m_flOutlineEnd1": 10428,
    "m_flOutlineStart0": 10416,
    "m_flOutlineStart1": 10420,
    "m_flShadowDensity": 11132,
    "m_flStartFadeDot": 10384,
    "m_flStartFadeSize": 9696,
    "m_nLightingMode": 10432,
    "m_nOrientationControlPoint": 9676,
    "m_nOrientationType": 9672,
    "m_nOutlineAlpha": 10412,
    "m_nSequenceOverride": 9328
  },
  "C_OP_RenderStandardLight": {
    "m_bCastShadows": 2496,
    "m_bClosedLoop": 4953,
    "m_bIgnoreDT": 4968,
    "m_bRenderDiffuse": 4576,
    "m_bRenderSpecular": 4577,
    "m_bReverseOrder": 4952,
    "m_flCapsuleLength": 4948,
    "m_flConstrainRadiusToLengthRatio": 4972,
    "m_flFalloffLinearity": 3544,
    "m_flFiftyPercentFalloff": 3888,
    "m_flFogContribution": 4600,
    "m_flIntensity": 2152,
    "m_flLengthFadeInTime": 4980,
    "m_flLengthScale": 4976,
    "m_flMaxLength": 4960,
    "m_flMinLength": 4964,
    "m_flPhi": 2848,
    "m_flRadiusMultiplier": 3192,
    "m_flTheta": 2504,
    "m_flZeroPercentFalloff": 4232,
    "m_lightCookie": 4584,
    "m_nAttenuationStyle": 3536,
    "m_nCapsuleLightBehavior": 4944,
    "m_nColorBlendType": 2144,
    "m_nFogLightingMode": 4596,
    "m_nLightType": 512,
    "m_nPrevPntSource": 4956,
    "m_nPriority": 4592,
    "m_vecColorScale": 520
  },
  "C_OP_RenderStatusEffect": {
    "m_pTextureColorWarp": 512,
    "m_pTextureDetail2": 520,
    "m_pTextureDiffuseWarp": 528,
    "m_pTextureEnvMap": 560,
    "m_pTextureFresnelColorWarp": 536,
    "m_pTextureFresnelWarp": 544,
    "m_pTextureSpecularWarp": 552
  },
  "C_OP_RenderStatusEffectCitadel": {
    "m_pTextureColorWarp": 512,
    "m_pTextureDetail": 552,
    "m_pTextureMetalness": 528,
    "m_pTextureNormal": 520,
    "m_pTextureRoughness": 536,
    "m_pTextureSelfIllum": 544
  },
  "C_OP_RenderText": {
    "m_DefaultText": 520,
    "m_OutlineColor": 512
  },
  "C_OP_RenderTonemapController": {
    "m_flTonemapLevel": 512,
    "m_flTonemapWeight": 516,
    "m_nTonemapLevelField": 520,
    "m_nTonemapWeightField": 524
  },
  "C_OP_RenderTrails": {
    "m_bEnableFadingAndClamping": 10048,
    "m_bFlipUVBasedOnPitchYaw": 14724,
    "m_bIgnoreDT": 10072,
    "m_flConstrainRadiusToLengthRatio": 10076,
    "m_flEndFadeDot": 10056,
    "m_flForwardShift": 14720,
    "m_flHeadAlphaScale": 12056,
    "m_flLengthFadeInTime": 10084,
    "m_flLengthScale": 10080,
    "m_flMaxLength": 10064,
    "m_flMinLength": 10068,
    "m_flRadiusHeadTaper": 10088,
    "m_flRadiusTaper": 12400,
    "m_flStartFadeDot": 10052,
    "m_flTailAlphaScale": 14368,
    "m_nHorizCropField": 14712,
    "m_nPrevPntSource": 10060,
    "m_nVertCropField": 14716,
    "m_vecHeadColorScale": 10432,
    "m_vecTailColorScale": 12744
  },
  "C_OP_RenderTreeShake": {
    "m_flControlPointOrientationAmount": 544,
    "m_flPeakStrength": 512,
    "m_flRadialAmount": 540,
    "m_flRadius": 520,
    "m_flShakeDuration": 528,
    "m_flTransitionTime": 532,
    "m_flTwistAmount": 536,
    "m_nControlPointForLinearDirection": 548,
    "m_nPeakStrengthFieldOverride": 516,
    "m_nRadiusFieldOverride": 524
  },
  "C_OP_RenderVRHapticEvent": {
    "m_flAmplitude": 528,
    "m_nHand": 512,
    "m_nOutputField": 520,
    "m_nOutputHandCP": 516
  },
  "C_OP_RepeatedTriggerChildGroup": {
    "m_bLimitChildCount": 1504,
    "m_flClusterCooldown": 1160,
    "m_flClusterRefireTime": 472,
    "m_flClusterSize": 816,
    "m_nChildGroupID": 464
  },
  "C_OP_RestartAfterDuration": {
    "m_bOnlyChildren": 468,
    "m_flDurationMax": 452,
    "m_flDurationMin": 448,
    "m_nCP": 456,
    "m_nCPField": 460,
    "m_nChildGroupID": 464
  },
  "C_OP_RopeSpringConstraint": {
    "m_flAdjustmentScale": 1480,
    "m_flInitialRestingLength": 1488,
    "m_flMaxDistance": 1136,
    "m_flMinDistance": 792,
    "m_flRestLength": 448
  },
  "C_OP_RotateVector": {
    "m_bNormalize": 484,
    "m_flRotRateMax": 480,
    "m_flRotRateMin": 476,
    "m_flScale": 488,
    "m_nFieldOutput": 448,
    "m_vecRotAxisMax": 464,
    "m_vecRotAxisMin": 452
  },
  "C_OP_RtEnvCull": {
    "m_RtEnvName": 474,
    "m_bCullOnMiss": 472,
    "m_bStickInsteadOfCull": 473,
    "m_nComponent": 608,
    "m_nRTEnvCP": 604,
    "m_vecTestDir": 448,
    "m_vecTestNormal": 460
  },
  "C_OP_SDFConstraint": {
    "m_flMaxDist": 792,
    "m_flMinDist": 448,
    "m_nMaxIterations": 1136
  },
  "C_OP_SDFForce": {
    "m_flForceScale": 464
  },
  "C_OP_SDFLighting": {
    "m_vLightingDir": 448,
    "m_vTint_0": 460,
    "m_vTint_1": 472
  },
  "C_OP_SelectivelyEnableChildren": {
    "m_bDestroyImmediately": 1497,
    "m_bPlayEndcapOnStop": 1496,
    "m_nChildGroupID": 464,
    "m_nFirstChild": 808,
    "m_nNumChildrenToEnable": 1152
  },
  "C_OP_SequenceFromModel": {
    "m_flInputMax": 464,
    "m_flInputMin": 460,
    "m_flOutputMax": 472,
    "m_flOutputMin": 468,
    "m_nControlPointNumber": 448,
    "m_nFieldOutput": 452,
    "m_nFieldOutputAnim": 456,
    "m_nSetMethod": 476
  },
  "C_OP_SetAttributeToScalarExpression": {
    "m_flInput1": 456,
    "m_flInput2": 800,
    "m_nExpression": 448,
    "m_nOutputField": 1144,
    "m_nSetMethod": 1148
  },
  "C_OP_SetCPOrientationToDirection": {
    "m_nInputControlPoint": 448,
    "m_nOutputControlPoint": 452
  },
  "C_OP_SetCPOrientationToGroundNormal": {
    "m_CollisionGroupName": 464,
    "m_bIncludeWater": 616,
    "m_flInterpRate": 448,
    "m_flMaxTraceLength": 452,
    "m_flTolerance": 456,
    "m_flTraceOffset": 460,
    "m_nInputCP": 596,
    "m_nOutputCP": 600,
    "m_nTraceSet": 592
  },
  "C_OP_SetCPOrientationToPointAtCP": {
    "m_b2DOrientation": 816,
    "m_bAvoidSingularity": 817,
    "m_bPointAway": 818,
    "m_flInterpolation": 472,
    "m_nInputCP": 464,
    "m_nOutputCP": 468
  },
  "C_OP_SetCPtoVector": {
    "m_nCPInput": 448,
    "m_nFieldOutput": 452
  },
  "C_OP_SetChildControlPoints": {
    "m_bReverse": 808,
    "m_bSetOrientation": 809,
    "m_nChildGroupID": 448,
    "m_nFirstControlPoint": 452,
    "m_nFirstSourcePoint": 464,
    "m_nNumControlPoints": 456
  },
  "C_OP_SetControlPointFieldFromVectorExpression": {
    "m_flOutputRemap": 3720,
    "m_nExpression": 464,
    "m_nOutVectorField": 4068,
    "m_nOutputCP": 4064,
    "m_vecInput1": 472,
    "m_vecInput2": 2096
  },
  "C_OP_SetControlPointFieldToScalarExpression": {
    "m_flInput1": 472,
    "m_flInput2": 816,
    "m_flOutputRemap": 1160,
    "m_nExpression": 464,
    "m_nOutVectorField": 1508,
    "m_nOutputCP": 1504
  },
  "C_OP_SetControlPointFieldToWater": {
    "m_nCPField": 472,
    "m_nDestCP": 468,
    "m_nSourceCP": 464
  },
  "C_OP_SetControlPointFromObjectScale": {
    "m_nCPInput": 464,
    "m_nCPOutput": 468
  },
  "C_OP_SetControlPointOrientation": {
    "m_bRandomize": 466,
    "m_bSetOnce": 467,
    "m_bUseWorldLocation": 464,
    "m_flInterpolation": 504,
    "m_nCP": 468,
    "m_nHeadLocation": 472,
    "m_vecRotation": 476,
    "m_vecRotationB": 488
  },
  "C_OP_SetControlPointOrientationToCPVelocity": {
    "m_nCPInput": 464,
    "m_nCPOutput": 468
  },
  "C_OP_SetControlPointPositionToRandomActiveCP": {
    "m_flResetRate": 480,
    "m_nCP1": 464,
    "m_nHeadLocationMax": 472,
    "m_nHeadLocationMin": 468
  },
  "C_OP_SetControlPointPositionToTimeOfDayValue": {
    "m_nControlPointNumber": 464,
    "m_pszTimeOfDayParameter": 468,
    "m_vecDefaultValue": 596
  },
  "C_OP_SetControlPointPositions": {
    "m_bOrient": 465,
    "m_bSetOnce": 466,
    "m_bUseWorldLocation": 464,
    "m_nCP1": 468,
    "m_nCP2": 472,
    "m_nCP3": 476,
    "m_nCP4": 480,
    "m_nHeadLocation": 532,
    "m_vecCP1Pos": 484,
    "m_vecCP2Pos": 496,
    "m_vecCP3Pos": 508,
    "m_vecCP4Pos": 520
  },
  "C_OP_SetControlPointRotation": {
    "m_flRotRate": 2088,
    "m_nCP": 2432,
    "m_nLocalCP": 2436,
    "m_vecRotAxis": 464
  },
  "C_OP_SetControlPointToCPVelocity": {
    "m_bNormalize": 472,
    "m_nCPField": 480,
    "m_nCPInput": 464,
    "m_nCPOutputMag": 476,
    "m_nCPOutputVel": 468,
    "m_vecComparisonVelocity": 488
  },
  "C_OP_SetControlPointToCenter": {
    "m_nCP1": 464,
    "m_nSetParent": 480,
    "m_vecCP1Pos": 468
  },
  "C_OP_SetControlPointToHMD": {
    "m_bOrientToHMD": 480,
    "m_nCP1": 464,
    "m_vecCP1Pos": 468
  },
  "C_OP_SetControlPointToHand": {
    "m_bOrientToHand": 484,
    "m_nCP1": 464,
    "m_nHand": 468,
    "m_vecCP1Pos": 472
  },
  "C_OP_SetControlPointToImpactPoint": {
    "m_CollisionGroupName": 844,
    "m_bIncludeWater": 978,
    "m_bSetToEndpoint": 976,
    "m_bTraceToClosestSurface": 977,
    "m_flOffset": 828,
    "m_flStartOffset": 824,
    "m_flTraceLength": 480,
    "m_flUpdateRate": 472,
    "m_nCPIn": 468,
    "m_nCPOut": 464,
    "m_nTraceSet": 972,
    "m_vecTraceDir": 832
  },
  "C_OP_SetControlPointToPlayer": {
    "m_bOrientToEyes": 480,
    "m_nCP1": 464,
    "m_vecCP1Pos": 468
  },
  "C_OP_SetControlPointToVectorExpression": {
    "m_bNormalizedOutput": 3720,
    "m_nExpression": 464,
    "m_nOutputCP": 468,
    "m_vInput1": 472,
    "m_vInput2": 2096
  },
  "C_OP_SetControlPointToWaterSurface": {
    "m_bAdaptiveThreshold": 832,
    "m_flRetestRate": 488,
    "m_nActiveCP": 476,
    "m_nActiveCPField": 480,
    "m_nDestCP": 468,
    "m_nFlowCP": 472,
    "m_nSourceCP": 464
  },
  "C_OP_SetControlPointsToModelParticles": {
    "m_AttachmentName": 576,
    "m_HitboxSetName": 448,
    "m_bAttachment": 717,
    "m_bSkin": 716,
    "m_nFirstControlPoint": 704,
    "m_nFirstSourcePoint": 712,
    "m_nNumControlPoints": 708
  },
  "C_OP_SetControlPointsToParticle": {
    "m_bSetOrientation": 464,
    "m_nChildGroupID": 448,
    "m_nFirstControlPoint": 452,
    "m_nFirstSourcePoint": 460,
    "m_nNumControlPoints": 456,
    "m_nOrientationMode": 468,
    "m_nSetParent": 472
  },
  "C_OP_SetFloat": {
    "m_InputValue": 448,
    "m_Lerp": 800,
    "m_bUseNewCode": 1144,
    "m_nOutputField": 792,
    "m_nSetMethod": 796
  },
  "C_OP_SetFloatAttributeToVectorExpression": {
    "m_flOutputRemap": 3704,
    "m_nExpression": 448,
    "m_nOutputField": 4048,
    "m_nSetMethod": 4052,
    "m_vInput1": 456,
    "m_vInput2": 2080
  },
  "C_OP_SetFloatCollection": {
    "m_InputValue": 448,
    "m_Lerp": 800,
    "m_nOutputField": 792,
    "m_nSetMethod": 796
  },
  "C_OP_SetFromCPSnapshot": {
    "m_bRandom": 464,
    "m_bReverse": 465,
    "m_bSubSample": 1504,
    "m_flInterpolation": 1160,
    "m_nAttributeToRead": 452,
    "m_nAttributeToWrite": 456,
    "m_nControlPointNumber": 448,
    "m_nLocalSpaceCP": 460,
    "m_nRandomSeed": 468,
    "m_nSnapShotIncrement": 816,
    "m_nSnapShotStartPoint": 472
  },
  "C_OP_SetGravityToCP": {
    "m_bSetOrientation": 816,
    "m_bSetZDown": 817,
    "m_flScale": 472,
    "m_nCPInput": 464,
    "m_nCPOutput": 468
  },
  "C_OP_SetParentControlPointsToChildCP": {
    "m_bSetOrientation": 480,
    "m_nChildControlPoint": 468,
    "m_nChildGroupID": 464,
    "m_nFirstSourcePoint": 476,
    "m_nNumControlPoints": 472
  },
  "C_OP_SetPerChildControlPoint": {
    "m_bNumBasedOnParticleCount": 1160,
    "m_bSetOrientation": 1152,
    "m_nChildGroupID": 448,
    "m_nFirstControlPoint": 452,
    "m_nFirstSourcePoint": 808,
    "m_nNumControlPoints": 456,
    "m_nOrientationField": 1156,
    "m_nParticleIncrement": 464
  },
  "C_OP_SetPerChildControlPointFromAttribute": {
    "m_bNumBasedOnParticleCount": 468,
    "m_nAttributeToRead": 472,
    "m_nCPField": 476,
    "m_nChildGroupID": 448,
    "m_nFirstControlPoint": 452,
    "m_nFirstSourcePoint": 464,
    "m_nNumControlPoints": 456,
    "m_nParticleIncrement": 460
  },
  "C_OP_SetRandomControlPointPosition": {
    "m_bOrient": 465,
    "m_bUseWorldLocation": 464,
    "m_flInterpolation": 848,
    "m_flReRandomRate": 480,
    "m_nCP1": 468,
    "m_nHeadLocation": 472,
    "m_vecCPMaxPos": 836,
    "m_vecCPMinPos": 824
  },
  "C_OP_SetSimulationRate": {
    "m_flSimulationScale": 464
  },
  "C_OP_SetSingleControlPointPosition": {
    "m_bSetOnce": 464,
    "m_nCP1": 468,
    "m_transformInput": 2096,
    "m_vecCP1Pos": 472
  },
  "C_OP_SetToCP": {
    "m_bOffsetLocal": 464,
    "m_nControlPointNumber": 448,
    "m_vecOffset": 452
  },
  "C_OP_SetVariable": {
    "m_floatInput": 2280,
    "m_positionOffset": 632,
    "m_rotationOffset": 644,
    "m_transformInput": 528,
    "m_variableReference": 464,
    "m_vecInput": 656
  },
  "C_OP_SetVec": {
    "m_InputValue": 448,
    "m_Lerp": 2080,
    "m_bNormalizedOutput": 2424,
    "m_nOutputField": 2072,
    "m_nSetMethod": 2076
  },
  "C_OP_SetVectorAttributeToVectorExpression": {
    "m_bNormalizedOutput": 3712,
    "m_nExpression": 448,
    "m_nOutputField": 3704,
    "m_nSetMethod": 3708,
    "m_vInput1": 456,
    "m_vInput2": 2080
  },
  "C_OP_ShapeMatchingConstraint": {
    "m_flShapeRestorationTime": 448
  },
  "C_OP_SnapshotRigidSkinToBones": {
    "m_bTransformNormals": 448,
    "m_bTransformRadii": 449,
    "m_nControlPointNumber": 452
  },
  "C_OP_SnapshotSkinToBones": {
    "m_bTransformNormals": 448,
    "m_bTransformRadii": 449,
    "m_flJumpThreshold": 464,
    "m_flLifeTimeFadeEnd": 460,
    "m_flLifeTimeFadeStart": 456,
    "m_flPrevPosScale": 468,
    "m_nControlPointNumber": 452
  },
  "C_OP_SpringToVectorConstraint": {
    "m_flMaxDistance": 1136,
    "m_flMinDistance": 792,
    "m_flRestLength": 448,
    "m_flRestingLength": 1480,
    "m_vecAnchorVector": 1824
  },
  "C_OP_StopAfterCPDuration": {
    "m_bDestroyImmediately": 808,
    "m_bPlayEndCap": 809,
    "m_flDuration": 464
  },
  "C_OP_TeleportBeam": {
    "m_flAlpha": 496,
    "m_flArcMaxDuration": 484,
    "m_flArcSpeed": 492,
    "m_flSegmentBreak": 488,
    "m_nCPColor": 460,
    "m_nCPExtraArcData": 468,
    "m_nCPInvalidColor": 464,
    "m_nCPMisc": 456,
    "m_nCPPosition": 448,
    "m_nCPVelocity": 452,
    "m_vGravity": 472
  },
  "C_OP_TimeVaryingForce": {
    "m_EndingForce": 484,
    "m_StartingForce": 468,
    "m_flEndLerpTime": 480,
    "m_flStartLerpTime": 464
  },
  "C_OP_TurbulenceForce": {
    "m_flNoiseCoordScale0": 464,
    "m_flNoiseCoordScale1": 468,
    "m_flNoiseCoordScale2": 472,
    "m_flNoiseCoordScale3": 476,
    "m_vecNoiseAmount0": 480,
    "m_vecNoiseAmount1": 492,
    "m_vecNoiseAmount2": 504,
    "m_vecNoiseAmount3": 516
  },
  "C_OP_TwistAroundAxis": {
    "m_TwistAxis": 468,
    "m_bLocalSpace": 480,
    "m_fForceAmount": 464,
    "m_nControlPointNumber": 484
  },
  "C_OP_UpdateLightSource": {
    "m_flBrightnessScale": 452,
    "m_flMaximumLightingRadius": 464,
    "m_flMinimumLightingRadius": 460,
    "m_flPositionDampingConstant": 468,
    "m_flRadiusScale": 456,
    "m_vColorTint": 448
  },
  "C_OP_VectorFieldSnapshot": {
    "m_bLockToSurface": 2437,
    "m_bSetVelocity": 2436,
    "m_flBoundaryDampening": 2432,
    "m_flGridSpacing": 2440,
    "m_flInterpolation": 464,
    "m_nAttributeToWrite": 452,
    "m_nControlPointNumber": 448,
    "m_nLocalSpaceCP": 456,
    "m_vecScale": 808
  },
  "C_OP_VectorNoise": {
    "m_bAdditive": 480,
    "m_bOffset": 481,
    "m_fl4NoiseScale": 476,
    "m_flNoiseAnimationTimeScale": 484,
    "m_nFieldOutput": 448,
    "m_vecOutputMax": 464,
    "m_vecOutputMin": 452
  },
  "C_OP_VelocityDecay": {
    "m_flMinVelocity": 448
  },
  "C_OP_VelocityMatchingForce": {
    "m_flDirScale": 448,
    "m_flSpdScale": 452,
    "m_nCPBroadcast": 456
  },
  "C_OP_WindForce": {
    "m_vForce": 464
  },
  "C_OP_WorldTraceConstraint": {
    "m_CollisionGroupName": 476,
    "m_bBrushOnly": 605,
    "m_bDecayBounce": 2008,
    "m_bIncludeWater": 606,
    "m_bKillonContact": 2009,
    "m_bSetNormal": 2016,
    "m_bWorldOnly": 604,
    "m_flBounceAmount": 976,
    "m_flCollisionConfirmationSpeed": 624,
    "m_flCpMovementTolerance": 612,
    "m_flMinSpeed": 2012,
    "m_flRadiusScale": 632,
    "m_flRandomDirScale": 1664,
    "m_flRetestRate": 616,
    "m_flSlideAmount": 1320,
    "m_flStopSpeed": 2024,
    "m_flTraceTolerance": 620,
    "m_nCP": 448,
    "m_nCollisionMode": 464,
    "m_nCollisionModeMin": 468,
    "m_nEntityStickDataField": 2368,
    "m_nEntityStickNormalField": 2372,
    "m_nIgnoreCP": 608,
    "m_nMaxTracesPerFrame": 628,
    "m_nStickOnCollisionField": 2020,
    "m_nTraceSet": 472,
    "m_vecCpOffset": 452
  },
  "CollisionGroupContext_t": {
    "m_nCollisionGroupNumber": 0
  },
  "ControlPointReference_t": {
    "m_bOffsetInLocalSpace": 16,
    "m_controlPointNameString": 0,
    "m_vOffsetFromControlPoint": 4
  },
  "FloatInputMaterialVariable_t": {
    "m_flInput": 8,
    "m_strVariable": 0
  },
  "MaterialVariable_t": {
    "m_flScale": 12,
    "m_nVariableField": 8,
    "m_strVariable": 0
  },
  "ModelReference_t": {
    "m_flRelativeProbabilityOfSpawn": 8,
    "m_model": 0
  },
  "PARTICLE_EHANDLE__": {
    "unused": 0
  },
  "PARTICLE_WORLD_HANDLE__": {
    "unused": 0
  },
  "ParticleAttributeIndex_t": {
    "m_Value": 0
  },
  "ParticleChildrenInfo_t": {
    "m_ChildRef": 0,
    "m_bDisableChild": 13,
    "m_bEndCap": 12,
    "m_flDelay": 8,
    "m_nDetailLevel": 16
  },
  "ParticleControlPointConfiguration_t": {
    "m_drivers": 8,
    "m_name": 0,
    "m_previewState": 32
  },
  "ParticleControlPointDriver_t": {
    "m_angOffset": 28,
    "m_attachmentName": 8,
    "m_entityName": 40,
    "m_iAttachType": 4,
    "m_iControlPoint": 0,
    "m_vecOffset": 16
  },
  "ParticleNamedValueConfiguration_t": {
    "m_BoundEntityPath": 32,
    "m_ConfigName": 0,
    "m_ConfigValue": 8,
    "m_iAttachType": 24,
    "m_strAttachmentName": 48,
    "m_strEntityScope": 40
  },
  "ParticleNamedValueSource_t": {
    "m_DefaultConfig": 16,
    "m_IsPublic": 8,
    "m_Name": 0,
    "m_NamedConfigs": 72,
    "m_ValueType": 12
  },
  "ParticlePreviewBodyGroup_t": {
    "m_bodyGroupName": 0,
    "m_nValue": 8
  },
  "ParticlePreviewState_t": {
    "m_bAnimationNonLooping": 84,
    "m_bShouldDrawAttachmentNames": 82,
    "m_bShouldDrawAttachments": 81,
    "m_bShouldDrawControlPointAxes": 83,
    "m_bShouldDrawHitboxes": 80,
    "m_flParticleSimulationRate": 76,
    "m_flPlaybackSpeed": 72,
    "m_groundType": 12,
    "m_hitboxSetName": 32,
    "m_materialGroupName": 40,
    "m_nFireParticleOnSequenceFrame": 24,
    "m_nModSpecificData": 8,
    "m_previewModel": 0,
    "m_sequenceName": 16,
    "m_vecBodyGroups": 48,
    "m_vecPreviewGravity": 88
  },
  "PointDefinitionWithTimeValues_t": {
    "m_flTimeDuration": 20
  },
  "PointDefinition_t": {
    "m_bLocalCoords": 4,
    "m_nControlPoint": 0,
    "m_vOffset": 8
  },
  "SequenceWeightedList_t": {
    "m_flRelativeWeight": 4,
    "m_nSequence": 0
  },
  "TextureControls_t": {
    "m_bClampUVs": 2409,
    "m_bRandomizeOffsets": 2408,
    "m_flDistortion": 2064,
    "m_flFinalTextureOffsetU": 688,
    "m_flFinalTextureOffsetV": 1032,
    "m_flFinalTextureScaleU": 0,
    "m_flFinalTextureScaleV": 344,
    "m_flFinalTextureUVRotation": 1376,
    "m_flZoomScale": 1720,
    "m_nPerParticleBlend": 2412,
    "m_nPerParticleDistortion": 2436,
    "m_nPerParticleOffsetU": 2420,
    "m_nPerParticleOffsetV": 2424,
    "m_nPerParticleRotation": 2428,
    "m_nPerParticleScale": 2416,
    "m_nPerParticleZoom": 2432
  },
  "TextureGroup_t": {
    "m_Gradient": 16,
    "m_TextureControls": 400,
    "m_bEnabled": 0,
    "m_bReplaceTextureWithGradient": 1,
    "m_flTextureBlend": 56,
    "m_hTexture": 8,
    "m_nTextureBlendMode": 48,
    "m_nTextureChannels": 44,
    "m_nTextureType": 40
  },
  "VecInputMaterialVariable_t": {
    "m_strVariable": 0,
    "m_vecInput": 8
  }
}
```

`SDK/particles.dll.py`:

```py
'''
https://github.com/a2x/cs2-dumper
2023-11-23 10:28:25.918885800 UTC
'''

class CBaseRendererSource2:
    m_flRadiusScale = 0x200 # CParticleCollectionRendererFloatInput
    m_flAlphaScale = 0x358 # CParticleCollectionRendererFloatInput
    m_flRollScale = 0x4B0 # CParticleCollectionRendererFloatInput
    m_nAlpha2Field = 0x608 # ParticleAttributeIndex_t
    m_vecColorScale = 0x610 # CParticleCollectionRendererVecInput
    m_nColorBlendType = 0xC68 # ParticleColorBlendType_t
    m_nShaderType = 0xC6C # SpriteCardShaderType_t
    m_strShaderOverride = 0xC70 # CUtlString
    m_flCenterXOffset = 0xC78 # CParticleCollectionRendererFloatInput
    m_flCenterYOffset = 0xDD0 # CParticleCollectionRendererFloatInput
    m_flBumpStrength = 0xF28 # float
    m_nCropTextureOverride = 0xF2C # ParticleSequenceCropOverride_t
    m_vecTexturesInput = 0xF30 # CUtlVector<TextureGroup_t>
    m_flAnimationRate = 0xF48 # float
    m_nAnimationType = 0xF4C # AnimationType_t
    m_bAnimateInFPS = 0xF50 # bool
    m_flSelfIllumAmount = 0xF58 # CParticleCollectionRendererFloatInput
    m_flDiffuseAmount = 0x10B0 # CParticleCollectionRendererFloatInput
    m_nLightingControlPoint = 0x1208 # int32_t
    m_nSelfIllumPerParticle = 0x120C # ParticleAttributeIndex_t
    m_nOutputBlendMode = 0x1210 # ParticleOutputBlendMode_t
    m_bGammaCorrectVertexColors = 0x1214 # bool
    m_bSaturateColorPreAlphaBlend = 0x1215 # bool
    m_flAddSelfAmount = 0x1218 # CParticleCollectionRendererFloatInput
    m_flDesaturation = 0x1370 # CParticleCollectionRendererFloatInput
    m_flOverbrightFactor = 0x14C8 # CParticleCollectionRendererFloatInput
    m_nHSVShiftControlPoint = 0x1620 # int32_t
    m_nFogType = 0x1624 # ParticleFogType_t
    m_flFogAmount = 0x1628 # CParticleCollectionRendererFloatInput
    m_bTintByFOW = 0x1780 # bool
    m_bTintByGlobalLight = 0x1781 # bool
    m_nPerParticleAlphaReference = 0x1784 # SpriteCardPerParticleScale_t
    m_nPerParticleAlphaRefWindow = 0x1788 # SpriteCardPerParticleScale_t
    m_nAlphaReferenceType = 0x178C # ParticleAlphaReferenceType_t
    m_flAlphaReferenceSoftness = 0x1790 # CParticleCollectionRendererFloatInput
    m_flSourceAlphaValueToMapToZero = 0x18E8 # CParticleCollectionRendererFloatInput
    m_flSourceAlphaValueToMapToOne = 0x1A40 # CParticleCollectionRendererFloatInput
    m_bRefract = 0x1B98 # bool
    m_bRefractSolid = 0x1B99 # bool
    m_flRefractAmount = 0x1BA0 # CParticleCollectionRendererFloatInput
    m_nRefractBlurRadius = 0x1CF8 # int32_t
    m_nRefractBlurType = 0x1CFC # BlurFilterType_t
    m_bOnlyRenderInEffectsBloomPass = 0x1D00 # bool
    m_bOnlyRenderInEffectsWaterPass = 0x1D01 # bool
    m_bUseMixedResolutionRendering = 0x1D02 # bool
    m_bOnlyRenderInEffecsGameOverlay = 0x1D03 # bool
    m_stencilTestID = 0x1D04 # char[128]
    m_bStencilTestExclude = 0x1D84 # bool
    m_stencilWriteID = 0x1D85 # char[128]
    m_bWriteStencilOnDepthPass = 0x1E05 # bool
    m_bWriteStencilOnDepthFail = 0x1E06 # bool
    m_bReverseZBuffering = 0x1E07 # bool
    m_bDisableZBuffering = 0x1E08 # bool
    m_nFeatheringMode = 0x1E0C # ParticleDepthFeatheringMode_t
    m_flFeatheringMinDist = 0x1E10 # CParticleCollectionRendererFloatInput
    m_flFeatheringMaxDist = 0x1F68 # CParticleCollectionRendererFloatInput
    m_flFeatheringFilter = 0x20C0 # CParticleCollectionRendererFloatInput
    m_flDepthBias = 0x2218 # float
    m_nSortMethod = 0x221C # ParticleSortingChoiceList_t
    m_bBlendFramesSeq0 = 0x2220 # bool
    m_bMaxLuminanceBlendingSequence0 = 0x2221 # bool

class CBaseTrailRenderer:
    m_nOrientationType = 0x2470 # ParticleOrientationChoiceList_t
    m_nOrientationControlPoint = 0x2474 # int32_t
    m_flMinSize = 0x2478 # float
    m_flMaxSize = 0x247C # float
    m_flStartFadeSize = 0x2480 # CParticleCollectionRendererFloatInput
    m_flEndFadeSize = 0x25D8 # CParticleCollectionRendererFloatInput
    m_bClampV = 0x2730 # bool

class CGeneralRandomRotation:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_flDegrees = 0x1C4 # float
    m_flDegreesMin = 0x1C8 # float
    m_flDegreesMax = 0x1CC # float
    m_flRotationRandExponent = 0x1D0 # float
    m_bRandomlyFlipDirection = 0x1D4 # bool

class CGeneralSpin:
    m_nSpinRateDegrees = 0x1C0 # int32_t
    m_nSpinRateMinDegrees = 0x1C4 # int32_t
    m_fSpinRateStopTime = 0x1CC # float

class CNewParticleEffect:
    m_pNext = 0x10 # CNewParticleEffect*
    m_pPrev = 0x18 # CNewParticleEffect*
    m_pParticles = 0x20 # IParticleCollection*
    m_pDebugName = 0x28 # char*
    m_bDontRemove = 0x0 # bitfield:1
    m_bRemove = 0x0 # bitfield:1
    m_bNeedsBBoxUpdate = 0x0 # bitfield:1
    m_bIsFirstFrame = 0x0 # bitfield:1
    m_bAutoUpdateBBox = 0x0 # bitfield:1
    m_bAllocated = 0x0 # bitfield:1
    m_bSimulate = 0x0 # bitfield:1
    m_bShouldPerformCullCheck = 0x0 # bitfield:1
    m_bForceNoDraw = 0x0 # bitfield:1
    m_bShouldSave = 0x0 # bitfield:1
    m_bDisableAggregation = 0x0 # bitfield:1
    m_bShouldSimulateDuringGamePaused = 0x0 # bitfield:1
    m_bShouldCheckFoW = 0x0 # bitfield:1
    m_vSortOrigin = 0x40 # Vector
    m_flScale = 0x4C # float
    m_hOwner = 0x50 # PARTICLE_EHANDLE__*
    m_pOwningParticleProperty = 0x58 # CParticleProperty*
    m_flFreezeTransitionStart = 0x70 # float
    m_flFreezeTransitionDuration = 0x74 # float
    m_flFreezeTransitionOverride = 0x78 # float
    m_bFreezeTransitionActive = 0x7C # bool
    m_bFreezeTargetState = 0x7D # bool
    m_bCanFreeze = 0x7E # bool
    m_LastMin = 0x80 # Vector
    m_LastMax = 0x8C # Vector
    m_nSplitScreenUser = 0x98 # CSplitScreenSlot
    m_vecAggregationCenter = 0x9C # Vector
    m_RefCount = 0xC0 # int32_t

class CParticleFloatInput:
    m_nType = 0x10 # ParticleFloatType_t
    m_nMapType = 0x14 # ParticleFloatMapType_t
    m_flLiteralValue = 0x18 # float
    m_NamedValue = 0x20 # CParticleNamedValueRef
    m_nControlPoint = 0x60 # int32_t
    m_nScalarAttribute = 0x64 # ParticleAttributeIndex_t
    m_nVectorAttribute = 0x68 # ParticleAttributeIndex_t
    m_nVectorComponent = 0x6C # int32_t
    m_flRandomMin = 0x70 # float
    m_flRandomMax = 0x74 # float
    m_bHasRandomSignFlip = 0x78 # bool
    m_nRandomSeed = 0x7C # int32_t
    m_nRandomMode = 0x80 # ParticleFloatRandomMode_t
    m_flLOD0 = 0x88 # float
    m_flLOD1 = 0x8C # float
    m_flLOD2 = 0x90 # float
    m_flLOD3 = 0x94 # float
    m_nNoiseInputVectorAttribute = 0x98 # ParticleAttributeIndex_t
    m_flNoiseOutputMin = 0x9C # float
    m_flNoiseOutputMax = 0xA0 # float
    m_flNoiseScale = 0xA4 # float
    m_vecNoiseOffsetRate = 0xA8 # Vector
    m_flNoiseOffset = 0xB4 # float
    m_nNoiseOctaves = 0xB8 # int32_t
    m_nNoiseTurbulence = 0xBC # PFNoiseTurbulence_t
    m_nNoiseType = 0xC0 # PFNoiseType_t
    m_nNoiseModifier = 0xC4 # PFNoiseModifier_t
    m_flNoiseTurbulenceScale = 0xC8 # float
    m_flNoiseTurbulenceMix = 0xCC # float
    m_flNoiseImgPreviewScale = 0xD0 # float
    m_bNoiseImgPreviewLive = 0xD4 # bool
    m_flNoCameraFallback = 0xE0 # float
    m_bUseBoundsCenter = 0xE4 # bool
    m_nInputMode = 0xE8 # ParticleFloatInputMode_t
    m_flMultFactor = 0xEC # float
    m_flInput0 = 0xF0 # float
    m_flInput1 = 0xF4 # float
    m_flOutput0 = 0xF8 # float
    m_flOutput1 = 0xFC # float
    m_flNotchedRangeMin = 0x100 # float
    m_flNotchedRangeMax = 0x104 # float
    m_flNotchedOutputOutside = 0x108 # float
    m_flNotchedOutputInside = 0x10C # float
    m_nBiasType = 0x110 # ParticleFloatBiasType_t
    m_flBiasParameter = 0x114 # float
    m_Curve = 0x118 # CPiecewiseCurve

class CParticleFunction:
    m_flOpStrength = 0x8 # CParticleCollectionFloatInput
    m_nOpEndCapState = 0x160 # ParticleEndcapMode_t
    m_flOpStartFadeInTime = 0x164 # float
    m_flOpEndFadeInTime = 0x168 # float
    m_flOpStartFadeOutTime = 0x16C # float
    m_flOpEndFadeOutTime = 0x170 # float
    m_flOpFadeOscillatePeriod = 0x174 # float
    m_bNormalizeToStopTime = 0x178 # bool
    m_flOpTimeOffsetMin = 0x17C # float
    m_flOpTimeOffsetMax = 0x180 # float
    m_nOpTimeOffsetSeed = 0x184 # int32_t
    m_nOpTimeScaleSeed = 0x188 # int32_t
    m_flOpTimeScaleMin = 0x18C # float
    m_flOpTimeScaleMax = 0x190 # float
    m_bDisableOperator = 0x196 # bool
    m_Notes = 0x198 # CUtlString

class CParticleFunctionEmitter:
    m_nEmitterIndex = 0x1B8 # int32_t

class CParticleFunctionInitializer:
    m_nAssociatedEmitterIndex = 0x1B8 # int32_t

class CParticleFunctionPreEmission:
    m_bRunOnce = 0x1C0 # bool

class CParticleFunctionRenderer:
    VisibilityInputs = 0x1B8 # CParticleVisibilityInputs
    m_bCannotBeRefracted = 0x1FC # bool
    m_bSkipRenderingOnMobile = 0x1FD # bool

class CParticleModelInput:
    m_nType = 0x10 # ParticleModelType_t
    m_NamedValue = 0x18 # CParticleNamedValueRef
    m_nControlPoint = 0x58 # int32_t

class CParticleSystemDefinition:
    m_nBehaviorVersion = 0x8 # int32_t
    m_PreEmissionOperators = 0x10 # CUtlVector<CParticleFunctionPreEmission*>
    m_Emitters = 0x28 # CUtlVector<CParticleFunctionEmitter*>
    m_Initializers = 0x40 # CUtlVector<CParticleFunctionInitializer*>
    m_Operators = 0x58 # CUtlVector<CParticleFunctionOperator*>
    m_ForceGenerators = 0x70 # CUtlVector<CParticleFunctionForce*>
    m_Constraints = 0x88 # CUtlVector<CParticleFunctionConstraint*>
    m_Renderers = 0xA0 # CUtlVector<CParticleFunctionRenderer*>
    m_Children = 0xB8 # CUtlVector<ParticleChildrenInfo_t>
    m_nFirstMultipleOverride_BackwardCompat = 0x178 # int32_t
    m_nInitialParticles = 0x210 # int32_t
    m_nMaxParticles = 0x214 # int32_t
    m_nGroupID = 0x218 # int32_t
    m_BoundingBoxMin = 0x21C # Vector
    m_BoundingBoxMax = 0x228 # Vector
    m_flDepthSortBias = 0x234 # float
    m_nSortOverridePositionCP = 0x238 # int32_t
    m_bInfiniteBounds = 0x23C # bool
    m_bEnableNamedValues = 0x23D # bool
    m_NamedValueDomain = 0x240 # CUtlString
    m_NamedValueLocals = 0x248 # CUtlVector<ParticleNamedValueSource_t*>
    m_ConstantColor = 0x260 # Color
    m_ConstantNormal = 0x264 # Vector
    m_flConstantRadius = 0x270 # float
    m_flConstantRotation = 0x274 # float
    m_flConstantRotationSpeed = 0x278 # float
    m_flConstantLifespan = 0x27C # float
    m_nConstantSequenceNumber = 0x280 # int32_t
    m_nConstantSequenceNumber1 = 0x284 # int32_t
    m_nSnapshotControlPoint = 0x288 # int32_t
    m_hSnapshot = 0x290 # CStrongHandle<InfoForResourceTypeIParticleSnapshot>
    m_pszCullReplacementName = 0x298 # CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    m_flCullRadius = 0x2A0 # float
    m_flCullFillCost = 0x2A4 # float
    m_nCullControlPoint = 0x2A8 # int32_t
    m_hFallback = 0x2B0 # CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    m_nFallbackMaxCount = 0x2B8 # int32_t
    m_hLowViolenceDef = 0x2C0 # CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    m_hReferenceReplacement = 0x2C8 # CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    m_flPreSimulationTime = 0x2D0 # float
    m_flStopSimulationAfterTime = 0x2D4 # float
    m_flMaximumTimeStep = 0x2D8 # float
    m_flMaximumSimTime = 0x2DC # float
    m_flMinimumSimTime = 0x2E0 # float
    m_flMinimumTimeStep = 0x2E4 # float
    m_nMinimumFrames = 0x2E8 # int32_t
    m_nMinCPULevel = 0x2EC # int32_t
    m_nMinGPULevel = 0x2F0 # int32_t
    m_flNoDrawTimeToGoToSleep = 0x2F4 # float
    m_flMaxDrawDistance = 0x2F8 # float
    m_flStartFadeDistance = 0x2FC # float
    m_flMaxCreationDistance = 0x300 # float
    m_nAggregationMinAvailableParticles = 0x304 # int32_t
    m_flAggregateRadius = 0x308 # float
    m_bShouldBatch = 0x30C # bool
    m_bShouldHitboxesFallbackToRenderBounds = 0x30D # bool
    m_bShouldHitboxesFallbackToSnapshot = 0x30E # bool
    m_nViewModelEffect = 0x310 # InheritableBoolType_t
    m_bScreenSpaceEffect = 0x314 # bool
    m_pszTargetLayerID = 0x318 # CUtlSymbolLarge
    m_nSkipRenderControlPoint = 0x320 # int32_t
    m_nAllowRenderControlPoint = 0x324 # int32_t
    m_bShouldSort = 0x328 # bool
    m_controlPointConfigurations = 0x370 # CUtlVector<ParticleControlPointConfiguration_t>

class CParticleTransformInput:
    m_nType = 0x10 # ParticleTransformType_t
    m_NamedValue = 0x18 # CParticleNamedValueRef
    m_bFollowNamedValue = 0x58 # bool
    m_bSupportsDisabled = 0x59 # bool
    m_bUseOrientation = 0x5A # bool
    m_nControlPoint = 0x5C # int32_t
    m_nControlPointRangeMax = 0x60 # int32_t
    m_flEndCPGrowthTime = 0x64 # float

class CParticleVariableRef:
    m_variableName = 0x0 # CKV3MemberNameWithStorage
    m_variableType = 0x38 # PulseValueType_t

class CParticleVecInput:
    m_nType = 0x10 # ParticleVecType_t
    m_vLiteralValue = 0x14 # Vector
    m_LiteralColor = 0x20 # Color
    m_NamedValue = 0x28 # CParticleNamedValueRef
    m_bFollowNamedValue = 0x68 # bool
    m_nVectorAttribute = 0x6C # ParticleAttributeIndex_t
    m_vVectorAttributeScale = 0x70 # Vector
    m_nControlPoint = 0x7C # int32_t
    m_nDeltaControlPoint = 0x80 # int32_t
    m_vCPValueScale = 0x84 # Vector
    m_vCPRelativePosition = 0x90 # Vector
    m_vCPRelativeDir = 0x9C # Vector
    m_FloatComponentX = 0xA8 # CParticleFloatInput
    m_FloatComponentY = 0x200 # CParticleFloatInput
    m_FloatComponentZ = 0x358 # CParticleFloatInput
    m_FloatInterp = 0x4B0 # CParticleFloatInput
    m_flInterpInput0 = 0x608 # float
    m_flInterpInput1 = 0x60C # float
    m_vInterpOutput0 = 0x610 # Vector
    m_vInterpOutput1 = 0x61C # Vector
    m_Gradient = 0x628 # CColorGradient
    m_vRandomMin = 0x640 # Vector
    m_vRandomMax = 0x64C # Vector

class CParticleVisibilityInputs:
    m_flCameraBias = 0x0 # float
    m_nCPin = 0x4 # int32_t
    m_flProxyRadius = 0x8 # float
    m_flInputMin = 0xC # float
    m_flInputMax = 0x10 # float
    m_flNoPixelVisibilityFallback = 0x14 # float
    m_flDistanceInputMin = 0x18 # float
    m_flDistanceInputMax = 0x1C # float
    m_flDotInputMin = 0x20 # float
    m_flDotInputMax = 0x24 # float
    m_bDotCPAngles = 0x28 # bool
    m_bDotCameraAngles = 0x29 # bool
    m_flAlphaScaleMin = 0x2C # float
    m_flAlphaScaleMax = 0x30 # float
    m_flRadiusScaleMin = 0x34 # float
    m_flRadiusScaleMax = 0x38 # float
    m_flRadiusScaleFOVBase = 0x3C # float
    m_bRightEye = 0x40 # bool

class CPathParameters:
    m_nStartControlPointNumber = 0x0 # int32_t
    m_nEndControlPointNumber = 0x4 # int32_t
    m_nBulgeControl = 0x8 # int32_t
    m_flBulge = 0xC # float
    m_flMidPoint = 0x10 # float
    m_vStartPointOffset = 0x14 # Vector
    m_vMidPointOffset = 0x20 # Vector
    m_vEndOffset = 0x2C # Vector

class CRandomNumberGeneratorParameters:
    m_bDistributeEvenly = 0x0 # bool
    m_nSeed = 0x4 # int32_t

class C_INIT_AddVectorToVector:
    m_vecScale = 0x1C0 # Vector
    m_nFieldOutput = 0x1CC # ParticleAttributeIndex_t
    m_nFieldInput = 0x1D0 # ParticleAttributeIndex_t
    m_vOffsetMin = 0x1D4 # Vector
    m_vOffsetMax = 0x1E0 # Vector
    m_randomnessParameters = 0x1EC # CRandomNumberGeneratorParameters

class C_INIT_AgeNoise:
    m_bAbsVal = 0x1C0 # bool
    m_bAbsValInv = 0x1C1 # bool
    m_flOffset = 0x1C4 # float
    m_flAgeMin = 0x1C8 # float
    m_flAgeMax = 0x1CC # float
    m_flNoiseScale = 0x1D0 # float
    m_flNoiseScaleLoc = 0x1D4 # float
    m_vecOffsetLoc = 0x1D8 # Vector

class C_INIT_ChaoticAttractor:
    m_flAParm = 0x1C0 # float
    m_flBParm = 0x1C4 # float
    m_flCParm = 0x1C8 # float
    m_flDParm = 0x1CC # float
    m_flScale = 0x1D0 # float
    m_flSpeedMin = 0x1D4 # float
    m_flSpeedMax = 0x1D8 # float
    m_nBaseCP = 0x1DC # int32_t
    m_bUniformSpeed = 0x1E0 # bool

class C_INIT_ColorLitPerParticle:
    m_ColorMin = 0x1D8 # Color
    m_ColorMax = 0x1DC # Color
    m_TintMin = 0x1E0 # Color
    m_TintMax = 0x1E4 # Color
    m_flTintPerc = 0x1E8 # float
    m_nTintBlendMode = 0x1EC # ParticleColorBlendMode_t
    m_flLightAmplification = 0x1F0 # float

class C_INIT_CreateAlongPath:
    m_fMaxDistance = 0x1C0 # float
    m_PathParams = 0x1D0 # CPathParameters
    m_bUseRandomCPs = 0x210 # bool
    m_vEndOffset = 0x214 # Vector
    m_bSaveOffset = 0x220 # bool

class C_INIT_CreateFromCPs:
    m_nIncrement = 0x1C0 # int32_t
    m_nMinCP = 0x1C4 # int32_t
    m_nMaxCP = 0x1C8 # int32_t
    m_nDynamicCPCount = 0x1D0 # CParticleCollectionFloatInput

class C_INIT_CreateFromParentParticles:
    m_flVelocityScale = 0x1C0 # float
    m_flIncrement = 0x1C4 # float
    m_bRandomDistribution = 0x1C8 # bool
    m_nRandomSeed = 0x1CC # int32_t
    m_bSubFrame = 0x1D0 # bool

class C_INIT_CreateFromPlaneCache:
    m_vecOffsetMin = 0x1C0 # Vector
    m_vecOffsetMax = 0x1CC # Vector
    m_bUseNormal = 0x1D9 # bool

class C_INIT_CreateInEpitrochoid:
    m_nComponent1 = 0x1C0 # int32_t
    m_nComponent2 = 0x1C4 # int32_t
    m_TransformInput = 0x1C8 # CParticleTransformInput
    m_flParticleDensity = 0x230 # CPerParticleFloatInput
    m_flOffset = 0x388 # CPerParticleFloatInput
    m_flRadius1 = 0x4E0 # CPerParticleFloatInput
    m_flRadius2 = 0x638 # CPerParticleFloatInput
    m_bUseCount = 0x790 # bool
    m_bUseLocalCoords = 0x791 # bool
    m_bOffsetExistingPos = 0x792 # bool

class C_INIT_CreateOnGrid:
    m_nXCount = 0x1C0 # CParticleCollectionFloatInput
    m_nYCount = 0x318 # CParticleCollectionFloatInput
    m_nZCount = 0x470 # CParticleCollectionFloatInput
    m_nXSpacing = 0x5C8 # CParticleCollectionFloatInput
    m_nYSpacing = 0x720 # CParticleCollectionFloatInput
    m_nZSpacing = 0x878 # CParticleCollectionFloatInput
    m_nControlPointNumber = 0x9D0 # int32_t
    m_bLocalSpace = 0x9D4 # bool
    m_bCenter = 0x9D5 # bool
    m_bHollow = 0x9D6 # bool

class C_INIT_CreateOnModel:
    m_modelInput = 0x1C0 # CParticleModelInput
    m_transformInput = 0x220 # CParticleTransformInput
    m_nForceInModel = 0x288 # int32_t
    m_nDesiredHitbox = 0x28C # int32_t
    m_nHitboxValueFromControlPointIndex = 0x290 # int32_t
    m_vecHitBoxScale = 0x298 # CParticleCollectionVecInput
    m_flBoneVelocity = 0x8F0 # float
    m_flMaxBoneVelocity = 0x8F4 # float
    m_vecDirectionBias = 0x8F8 # CParticleCollectionVecInput
    m_HitboxSetName = 0xF50 # char[128]
    m_bLocalCoords = 0xFD0 # bool
    m_bUseBones = 0xFD1 # bool
    m_flShellSize = 0xFD8 # CParticleCollectionFloatInput

class C_INIT_CreateOnModelAtHeight:
    m_bUseBones = 0x1C0 # bool
    m_bForceZ = 0x1C1 # bool
    m_nControlPointNumber = 0x1C4 # int32_t
    m_nHeightCP = 0x1C8 # int32_t
    m_bUseWaterHeight = 0x1CC # bool
    m_flDesiredHeight = 0x1D0 # CParticleCollectionFloatInput
    m_vecHitBoxScale = 0x328 # CParticleCollectionVecInput
    m_vecDirectionBias = 0x980 # CParticleCollectionVecInput
    m_nBiasType = 0xFD8 # ParticleHitboxBiasType_t
    m_bLocalCoords = 0xFDC # bool
    m_bPreferMovingBoxes = 0xFDD # bool
    m_HitboxSetName = 0xFDE # char[128]
    m_flHitboxVelocityScale = 0x1060 # CParticleCollectionFloatInput
    m_flMaxBoneVelocity = 0x11B8 # CParticleCollectionFloatInput

class C_INIT_CreateParticleImpulse:
    m_InputRadius = 0x1C0 # CPerParticleFloatInput
    m_InputMagnitude = 0x318 # CPerParticleFloatInput
    m_nFalloffFunction = 0x470 # ParticleFalloffFunction_t
    m_InputFalloffExp = 0x478 # CPerParticleFloatInput
    m_nImpulseType = 0x5D0 # ParticleImpulseType_t

class C_INIT_CreatePhyllotaxis:
    m_nControlPointNumber = 0x1C0 # int32_t
    m_nScaleCP = 0x1C4 # int32_t
    m_nComponent = 0x1C8 # int32_t
    m_fRadCentCore = 0x1CC # float
    m_fRadPerPoint = 0x1D0 # float
    m_fRadPerPointTo = 0x1D4 # float
    m_fpointAngle = 0x1D8 # float
    m_fsizeOverall = 0x1DC # float
    m_fRadBias = 0x1E0 # float
    m_fMinRad = 0x1E4 # float
    m_fDistBias = 0x1E8 # float
    m_bUseLocalCoords = 0x1EC # bool
    m_bUseWithContEmit = 0x1ED # bool
    m_bUseOrigRadius = 0x1EE # bool

class C_INIT_CreateSequentialPath:
    m_fMaxDistance = 0x1C0 # float
    m_flNumToAssign = 0x1C4 # float
    m_bLoop = 0x1C8 # bool
    m_bCPPairs = 0x1C9 # bool
    m_bSaveOffset = 0x1CA # bool
    m_PathParams = 0x1D0 # CPathParameters

class C_INIT_CreateSequentialPathV2:
    m_fMaxDistance = 0x1C0 # CPerParticleFloatInput
    m_flNumToAssign = 0x318 # CParticleCollectionFloatInput
    m_bLoop = 0x470 # bool
    m_bCPPairs = 0x471 # bool
    m_bSaveOffset = 0x472 # bool
    m_PathParams = 0x480 # CPathParameters

class C_INIT_CreateSpiralSphere:
    m_nControlPointNumber = 0x1C0 # int32_t
    m_nOverrideCP = 0x1C4 # int32_t
    m_nDensity = 0x1C8 # int32_t
    m_flInitialRadius = 0x1CC # float
    m_flInitialSpeedMin = 0x1D0 # float
    m_flInitialSpeedMax = 0x1D4 # float
    m_bUseParticleCount = 0x1D8 # bool

class C_INIT_CreateWithinBox:
    m_vecMin = 0x1C0 # CPerParticleVecInput
    m_vecMax = 0x818 # CPerParticleVecInput
    m_nControlPointNumber = 0xE70 # int32_t
    m_bLocalSpace = 0xE74 # bool
    m_randomnessParameters = 0xE78 # CRandomNumberGeneratorParameters

class C_INIT_CreateWithinSphereTransform:
    m_fRadiusMin = 0x1C0 # CPerParticleFloatInput
    m_fRadiusMax = 0x318 # CPerParticleFloatInput
    m_vecDistanceBias = 0x470 # CPerParticleVecInput
    m_vecDistanceBiasAbs = 0xAC8 # Vector
    m_TransformInput = 0xAD8 # CParticleTransformInput
    m_fSpeedMin = 0xB40 # CPerParticleFloatInput
    m_fSpeedMax = 0xC98 # CPerParticleFloatInput
    m_fSpeedRandExp = 0xDF0 # float
    m_bLocalCoords = 0xDF4 # bool
    m_flEndCPGrowthTime = 0xDF8 # float
    m_LocalCoordinateSystemSpeedMin = 0xE00 # CPerParticleVecInput
    m_LocalCoordinateSystemSpeedMax = 0x1458 # CPerParticleVecInput
    m_nFieldOutput = 0x1AB0 # ParticleAttributeIndex_t
    m_nFieldVelocity = 0x1AB4 # ParticleAttributeIndex_t

class C_INIT_CreationNoise:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_bAbsVal = 0x1C4 # bool
    m_bAbsValInv = 0x1C5 # bool
    m_flOffset = 0x1C8 # float
    m_flOutputMin = 0x1CC # float
    m_flOutputMax = 0x1D0 # float
    m_flNoiseScale = 0x1D4 # float
    m_flNoiseScaleLoc = 0x1D8 # float
    m_vecOffsetLoc = 0x1DC # Vector
    m_flWorldTimeScale = 0x1E8 # float

class C_INIT_DistanceCull:
    m_nControlPoint = 0x1C0 # int32_t
    m_flDistance = 0x1C8 # CParticleCollectionFloatInput
    m_bCullInside = 0x320 # bool

class C_INIT_DistanceToCPInit:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_flInputMin = 0x1C8 # CPerParticleFloatInput
    m_flInputMax = 0x320 # CPerParticleFloatInput
    m_flOutputMin = 0x478 # CPerParticleFloatInput
    m_flOutputMax = 0x5D0 # CPerParticleFloatInput
    m_nStartCP = 0x728 # int32_t
    m_bLOS = 0x72C # bool
    m_CollisionGroupName = 0x72D # char[128]
    m_nTraceSet = 0x7B0 # ParticleTraceSet_t
    m_flMaxTraceLength = 0x7B8 # CPerParticleFloatInput
    m_flLOSScale = 0x910 # float
    m_nSetMethod = 0x914 # ParticleSetMethod_t
    m_bActiveRange = 0x918 # bool
    m_vecDistanceScale = 0x91C # Vector
    m_flRemapBias = 0x928 # float

class C_INIT_DistanceToNeighborCull:
    m_flDistance = 0x1C0 # CPerParticleFloatInput

class C_INIT_GlobalScale:
    m_flScale = 0x1C0 # float
    m_nScaleControlPointNumber = 0x1C4 # int32_t
    m_nControlPointNumber = 0x1C8 # int32_t
    m_bScaleRadius = 0x1CC # bool
    m_bScalePosition = 0x1CD # bool
    m_bScaleVelocity = 0x1CE # bool

class C_INIT_InheritFromParentParticles:
    m_flScale = 0x1C0 # float
    m_nFieldOutput = 0x1C4 # ParticleAttributeIndex_t
    m_nIncrement = 0x1C8 # int32_t
    m_bRandomDistribution = 0x1CC # bool
    m_nRandomSeed = 0x1D0 # int32_t

class C_INIT_InheritVelocity:
    m_nControlPointNumber = 0x1C0 # int32_t
    m_flVelocityScale = 0x1C4 # float

class C_INIT_InitFloat:
    m_InputValue = 0x1C0 # CPerParticleFloatInput
    m_nOutputField = 0x318 # ParticleAttributeIndex_t
    m_nSetMethod = 0x31C # ParticleSetMethod_t
    m_InputStrength = 0x320 # CPerParticleFloatInput

class C_INIT_InitFloatCollection:
    m_InputValue = 0x1C0 # CParticleCollectionFloatInput
    m_nOutputField = 0x318 # ParticleAttributeIndex_t

class C_INIT_InitFromCPSnapshot:
    m_nControlPointNumber = 0x1C0 # int32_t
    m_nAttributeToRead = 0x1C4 # ParticleAttributeIndex_t
    m_nAttributeToWrite = 0x1C8 # ParticleAttributeIndex_t
    m_nLocalSpaceCP = 0x1CC # int32_t
    m_bRandom = 0x1D0 # bool
    m_bReverse = 0x1D1 # bool
    m_nSnapShotIncrement = 0x1D8 # CParticleCollectionFloatInput
    m_nManualSnapshotIndex = 0x330 # CPerParticleFloatInput
    m_nRandomSeed = 0x488 # int32_t
    m_bLocalSpaceAngles = 0x48C # bool

class C_INIT_InitFromParentKilled:
    m_nAttributeToCopy = 0x1C0 # ParticleAttributeIndex_t

class C_INIT_InitFromVectorFieldSnapshot:
    m_nControlPointNumber = 0x1C0 # int32_t
    m_nLocalSpaceCP = 0x1C4 # int32_t
    m_nWeightUpdateCP = 0x1C8 # int32_t
    m_bUseVerticalVelocity = 0x1CC # bool
    m_vecScale = 0x1D0 # CPerParticleVecInput

class C_INIT_InitSkinnedPositionFromCPSnapshot:
    m_nSnapshotControlPointNumber = 0x1C0 # int32_t
    m_nControlPointNumber = 0x1C4 # int32_t
    m_bRandom = 0x1C8 # bool
    m_nRandomSeed = 0x1CC # int32_t
    m_bRigid = 0x1D0 # bool
    m_bSetNormal = 0x1D1 # bool
    m_bIgnoreDt = 0x1D2 # bool
    m_flMinNormalVelocity = 0x1D4 # float
    m_flMaxNormalVelocity = 0x1D8 # float
    m_flIncrement = 0x1DC # float
    m_nFullLoopIncrement = 0x1E0 # int32_t
    m_nSnapShotStartPoint = 0x1E4 # int32_t
    m_flBoneVelocity = 0x1E8 # float
    m_flBoneVelocityMax = 0x1EC # float
    m_bCopyColor = 0x1F0 # bool
    m_bCopyAlpha = 0x1F1 # bool
    m_bSetRadius = 0x1F2 # bool

class C_INIT_InitVec:
    m_InputValue = 0x1C0 # CPerParticleVecInput
    m_nOutputField = 0x818 # ParticleAttributeIndex_t
    m_nSetMethod = 0x81C # ParticleSetMethod_t
    m_bNormalizedOutput = 0x820 # bool
    m_bWritePreviousPosition = 0x821 # bool

class C_INIT_InitVecCollection:
    m_InputValue = 0x1C0 # CParticleCollectionVecInput
    m_nOutputField = 0x818 # ParticleAttributeIndex_t

class C_INIT_InitialRepulsionVelocity:
    m_CollisionGroupName = 0x1C0 # char[128]
    m_nTraceSet = 0x240 # ParticleTraceSet_t
    m_vecOutputMin = 0x244 # Vector
    m_vecOutputMax = 0x250 # Vector
    m_nControlPointNumber = 0x25C # int32_t
    m_bPerParticle = 0x260 # bool
    m_bTranslate = 0x261 # bool
    m_bProportional = 0x262 # bool
    m_flTraceLength = 0x264 # float
    m_bPerParticleTR = 0x268 # bool
    m_bInherit = 0x269 # bool
    m_nChildCP = 0x26C # int32_t
    m_nChildGroupID = 0x270 # int32_t

class C_INIT_InitialSequenceFromModel:
    m_nControlPointNumber = 0x1C0 # int32_t
    m_nFieldOutput = 0x1C4 # ParticleAttributeIndex_t
    m_nFieldOutputAnim = 0x1C8 # ParticleAttributeIndex_t
    m_flInputMin = 0x1CC # float
    m_flInputMax = 0x1D0 # float
    m_flOutputMin = 0x1D4 # float
    m_flOutputMax = 0x1D8 # float
    m_nSetMethod = 0x1DC # ParticleSetMethod_t

class C_INIT_InitialVelocityFromHitbox:
    m_flVelocityMin = 0x1C0 # float
    m_flVelocityMax = 0x1C4 # float
    m_nControlPointNumber = 0x1C8 # int32_t
    m_HitboxSetName = 0x1CC # char[128]
    m_bUseBones = 0x24C # bool

class C_INIT_InitialVelocityNoise:
    m_vecAbsVal = 0x1C0 # Vector
    m_vecAbsValInv = 0x1CC # Vector
    m_vecOffsetLoc = 0x1D8 # CPerParticleVecInput
    m_flOffset = 0x830 # CPerParticleFloatInput
    m_vecOutputMin = 0x988 # CPerParticleVecInput
    m_vecOutputMax = 0xFE0 # CPerParticleVecInput
    m_flNoiseScale = 0x1638 # CPerParticleFloatInput
    m_flNoiseScaleLoc = 0x1790 # CPerParticleFloatInput
    m_TransformInput = 0x18E8 # CParticleTransformInput
    m_bIgnoreDt = 0x1950 # bool

class C_INIT_LifespanFromVelocity:
    m_vecComponentScale = 0x1C0 # Vector
    m_flTraceOffset = 0x1CC # float
    m_flMaxTraceLength = 0x1D0 # float
    m_flTraceTolerance = 0x1D4 # float
    m_nMaxPlanes = 0x1D8 # int32_t
    m_CollisionGroupName = 0x1E0 # char[128]
    m_nTraceSet = 0x260 # ParticleTraceSet_t
    m_bIncludeWater = 0x270 # bool

class C_INIT_ModelCull:
    m_nControlPointNumber = 0x1C0 # int32_t
    m_bBoundBox = 0x1C4 # bool
    m_bCullOutside = 0x1C5 # bool
    m_bUseBones = 0x1C6 # bool
    m_HitboxSetName = 0x1C7 # char[128]

class C_INIT_MoveBetweenPoints:
    m_flSpeedMin = 0x1C0 # CPerParticleFloatInput
    m_flSpeedMax = 0x318 # CPerParticleFloatInput
    m_flEndSpread = 0x470 # CPerParticleFloatInput
    m_flStartOffset = 0x5C8 # CPerParticleFloatInput
    m_flEndOffset = 0x720 # CPerParticleFloatInput
    m_nEndControlPointNumber = 0x878 # int32_t
    m_bTrailBias = 0x87C # bool

class C_INIT_NormalAlignToCP:
    m_transformInput = 0x1C0 # CParticleTransformInput
    m_nControlPointAxis = 0x228 # ParticleControlPointAxis_t

class C_INIT_NormalOffset:
    m_OffsetMin = 0x1C0 # Vector
    m_OffsetMax = 0x1CC # Vector
    m_nControlPointNumber = 0x1D8 # int32_t
    m_bLocalCoords = 0x1DC # bool
    m_bNormalize = 0x1DD # bool

class C_INIT_OffsetVectorToVector:
    m_nFieldInput = 0x1C0 # ParticleAttributeIndex_t
    m_nFieldOutput = 0x1C4 # ParticleAttributeIndex_t
    m_vecOutputMin = 0x1C8 # Vector
    m_vecOutputMax = 0x1D4 # Vector
    m_randomnessParameters = 0x1E0 # CRandomNumberGeneratorParameters

class C_INIT_Orient2DRelToCP:
    m_nCP = 0x1C0 # int32_t
    m_nFieldOutput = 0x1C4 # ParticleAttributeIndex_t
    m_flRotOffset = 0x1C8 # float

class C_INIT_PlaneCull:
    m_nControlPoint = 0x1C0 # int32_t
    m_flDistance = 0x1C8 # CParticleCollectionFloatInput
    m_bCullInside = 0x320 # bool

class C_INIT_PointList:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_pointList = 0x1C8 # CUtlVector<PointDefinition_t>
    m_bPlaceAlongPath = 0x1E0 # bool
    m_bClosedLoop = 0x1E1 # bool
    m_nNumPointsAlongPath = 0x1E4 # int32_t

class C_INIT_PositionOffset:
    m_OffsetMin = 0x1C0 # CPerParticleVecInput
    m_OffsetMax = 0x818 # CPerParticleVecInput
    m_TransformInput = 0xE70 # CParticleTransformInput
    m_bLocalCoords = 0xED8 # bool
    m_bProportional = 0xED9 # bool
    m_randomnessParameters = 0xEDC # CRandomNumberGeneratorParameters

class C_INIT_PositionOffsetToCP:
    m_nControlPointNumberStart = 0x1C0 # int32_t
    m_nControlPointNumberEnd = 0x1C4 # int32_t
    m_bLocalCoords = 0x1C8 # bool

class C_INIT_PositionPlaceOnGround:
    m_flOffset = 0x1C0 # CPerParticleFloatInput
    m_flMaxTraceLength = 0x318 # CPerParticleFloatInput
    m_CollisionGroupName = 0x470 # char[128]
    m_nTraceSet = 0x4F0 # ParticleTraceSet_t
    m_nTraceMissBehavior = 0x500 # ParticleTraceMissBehavior_t
    m_bIncludeWater = 0x504 # bool
    m_bSetNormal = 0x505 # bool
    m_bSetPXYZOnly = 0x506 # bool
    m_bTraceAlongNormal = 0x507 # bool
    m_bOffsetonColOnly = 0x508 # bool
    m_flOffsetByRadiusFactor = 0x50C # float
    m_nPreserveOffsetCP = 0x510 # int32_t
    m_nIgnoreCP = 0x514 # int32_t

class C_INIT_PositionWarp:
    m_vecWarpMin = 0x1C0 # CParticleCollectionVecInput
    m_vecWarpMax = 0x818 # CParticleCollectionVecInput
    m_nScaleControlPointNumber = 0xE70 # int32_t
    m_nControlPointNumber = 0xE74 # int32_t
    m_nRadiusComponent = 0xE78 # int32_t
    m_flWarpTime = 0xE7C # float
    m_flWarpStartTime = 0xE80 # float
    m_flPrevPosScale = 0xE84 # float
    m_bInvertWarp = 0xE88 # bool
    m_bUseCount = 0xE89 # bool

class C_INIT_PositionWarpScalar:
    m_vecWarpMin = 0x1C0 # Vector
    m_vecWarpMax = 0x1CC # Vector
    m_InputValue = 0x1D8 # CPerParticleFloatInput
    m_flPrevPosScale = 0x330 # float
    m_nScaleControlPointNumber = 0x334 # int32_t
    m_nControlPointNumber = 0x338 # int32_t

class C_INIT_QuantizeFloat:
    m_InputValue = 0x1C0 # CPerParticleFloatInput
    m_nOutputField = 0x318 # ParticleAttributeIndex_t

class C_INIT_RadiusFromCPObject:
    m_nControlPoint = 0x1C0 # int32_t

class C_INIT_RandomAlpha:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_nAlphaMin = 0x1C4 # int32_t
    m_nAlphaMax = 0x1C8 # int32_t
    m_flAlphaRandExponent = 0x1D4 # float

class C_INIT_RandomAlphaWindowThreshold:
    m_flMin = 0x1C0 # float
    m_flMax = 0x1C4 # float
    m_flExponent = 0x1C8 # float

class C_INIT_RandomColor:
    m_ColorMin = 0x1DC # Color
    m_ColorMax = 0x1E0 # Color
    m_TintMin = 0x1E4 # Color
    m_TintMax = 0x1E8 # Color
    m_flTintPerc = 0x1EC # float
    m_flUpdateThreshold = 0x1F0 # float
    m_nTintCP = 0x1F4 # int32_t
    m_nFieldOutput = 0x1F8 # ParticleAttributeIndex_t
    m_nTintBlendMode = 0x1FC # ParticleColorBlendMode_t
    m_flLightAmplification = 0x200 # float

class C_INIT_RandomLifeTime:
    m_fLifetimeMin = 0x1C0 # float
    m_fLifetimeMax = 0x1C4 # float
    m_fLifetimeRandExponent = 0x1C8 # float

class C_INIT_RandomModelSequence:
    m_ActivityName = 0x1C0 # char[256]
    m_SequenceName = 0x2C0 # char[256]
    m_hModel = 0x3C0 # CStrongHandle<InfoForResourceTypeCModel>

class C_INIT_RandomNamedModelElement:
    m_hModel = 0x1C0 # CStrongHandle<InfoForResourceTypeCModel>
    m_names = 0x1C8 # CUtlVector<CUtlString>
    m_bShuffle = 0x1E0 # bool
    m_bLinear = 0x1E1 # bool
    m_bModelFromRenderer = 0x1E2 # bool
    m_nFieldOutput = 0x1E4 # ParticleAttributeIndex_t

class C_INIT_RandomRadius:
    m_flRadiusMin = 0x1C0 # float
    m_flRadiusMax = 0x1C4 # float
    m_flRadiusRandExponent = 0x1C8 # float

class C_INIT_RandomScalar:
    m_flMin = 0x1C0 # float
    m_flMax = 0x1C4 # float
    m_flExponent = 0x1C8 # float
    m_nFieldOutput = 0x1CC # ParticleAttributeIndex_t

class C_INIT_RandomSecondSequence:
    m_nSequenceMin = 0x1C0 # int32_t
    m_nSequenceMax = 0x1C4 # int32_t

class C_INIT_RandomSequence:
    m_nSequenceMin = 0x1C0 # int32_t
    m_nSequenceMax = 0x1C4 # int32_t
    m_bShuffle = 0x1C8 # bool
    m_bLinear = 0x1C9 # bool
    m_WeightedList = 0x1D0 # CUtlVector<SequenceWeightedList_t>

class C_INIT_RandomTrailLength:
    m_flMinLength = 0x1C0 # float
    m_flMaxLength = 0x1C4 # float
    m_flLengthRandExponent = 0x1C8 # float

class C_INIT_RandomVector:
    m_vecMin = 0x1C0 # Vector
    m_vecMax = 0x1CC # Vector
    m_nFieldOutput = 0x1D8 # ParticleAttributeIndex_t
    m_randomnessParameters = 0x1DC # CRandomNumberGeneratorParameters

class C_INIT_RandomVectorComponent:
    m_flMin = 0x1C0 # float
    m_flMax = 0x1C4 # float
    m_nFieldOutput = 0x1C8 # ParticleAttributeIndex_t
    m_nComponent = 0x1CC # int32_t

class C_INIT_RandomYawFlip:
    m_flPercent = 0x1C0 # float

class C_INIT_RemapCPtoScalar:
    m_nCPInput = 0x1C0 # int32_t
    m_nFieldOutput = 0x1C4 # ParticleAttributeIndex_t
    m_nField = 0x1C8 # int32_t
    m_flInputMin = 0x1CC # float
    m_flInputMax = 0x1D0 # float
    m_flOutputMin = 0x1D4 # float
    m_flOutputMax = 0x1D8 # float
    m_flStartTime = 0x1DC # float
    m_flEndTime = 0x1E0 # float
    m_nSetMethod = 0x1E4 # ParticleSetMethod_t
    m_flRemapBias = 0x1E8 # float

class C_INIT_RemapInitialDirectionToTransformToVector:
    m_TransformInput = 0x1C0 # CParticleTransformInput
    m_nFieldOutput = 0x228 # ParticleAttributeIndex_t
    m_flScale = 0x22C # float
    m_flOffsetRot = 0x230 # float
    m_vecOffsetAxis = 0x234 # Vector
    m_bNormalize = 0x240 # bool

class C_INIT_RemapInitialTransformDirectionToRotation:
    m_TransformInput = 0x1C0 # CParticleTransformInput
    m_nFieldOutput = 0x228 # ParticleAttributeIndex_t
    m_flOffsetRot = 0x22C # float
    m_nComponent = 0x230 # int32_t

class C_INIT_RemapInitialVisibilityScalar:
    m_nFieldOutput = 0x1C4 # ParticleAttributeIndex_t
    m_flInputMin = 0x1C8 # float
    m_flInputMax = 0x1CC # float
    m_flOutputMin = 0x1D0 # float
    m_flOutputMax = 0x1D4 # float

class C_INIT_RemapNamedModelElementToScalar:
    m_hModel = 0x1C0 # CStrongHandle<InfoForResourceTypeCModel>
    m_names = 0x1C8 # CUtlVector<CUtlString>
    m_values = 0x1E0 # CUtlVector<float>
    m_nFieldInput = 0x1F8 # ParticleAttributeIndex_t
    m_nFieldOutput = 0x1FC # ParticleAttributeIndex_t
    m_nSetMethod = 0x200 # ParticleSetMethod_t
    m_bModelFromRenderer = 0x204 # bool

class C_INIT_RemapParticleCountToNamedModelElementScalar:
    m_hModel = 0x1F0 # CStrongHandle<InfoForResourceTypeCModel>
    m_outputMinName = 0x1F8 # CUtlString
    m_outputMaxName = 0x200 # CUtlString
    m_bModelFromRenderer = 0x208 # bool

class C_INIT_RemapParticleCountToScalar:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_nInputMin = 0x1C4 # int32_t
    m_nInputMax = 0x1C8 # int32_t
    m_nScaleControlPoint = 0x1CC # int32_t
    m_nScaleControlPointField = 0x1D0 # int32_t
    m_flOutputMin = 0x1D4 # float
    m_flOutputMax = 0x1D8 # float
    m_nSetMethod = 0x1DC # ParticleSetMethod_t
    m_bActiveRange = 0x1E0 # bool
    m_bInvert = 0x1E1 # bool
    m_bWrap = 0x1E2 # bool
    m_flRemapBias = 0x1E4 # float

class C_INIT_RemapQAnglesToRotation:
    m_TransformInput = 0x1C0 # CParticleTransformInput

class C_INIT_RemapScalar:
    m_nFieldInput = 0x1C0 # ParticleAttributeIndex_t
    m_nFieldOutput = 0x1C4 # ParticleAttributeIndex_t
    m_flInputMin = 0x1C8 # float
    m_flInputMax = 0x1CC # float
    m_flOutputMin = 0x1D0 # float
    m_flOutputMax = 0x1D4 # float
    m_flStartTime = 0x1D8 # float
    m_flEndTime = 0x1DC # float
    m_nSetMethod = 0x1E0 # ParticleSetMethod_t
    m_bActiveRange = 0x1E4 # bool
    m_flRemapBias = 0x1E8 # float

class C_INIT_RemapScalarToVector:
    m_nFieldInput = 0x1C0 # ParticleAttributeIndex_t
    m_nFieldOutput = 0x1C4 # ParticleAttributeIndex_t
    m_flInputMin = 0x1C8 # float
    m_flInputMax = 0x1CC # float
    m_vecOutputMin = 0x1D0 # Vector
    m_vecOutputMax = 0x1DC # Vector
    m_flStartTime = 0x1E8 # float
    m_flEndTime = 0x1EC # float
    m_nSetMethod = 0x1F0 # ParticleSetMethod_t
    m_nControlPointNumber = 0x1F4 # int32_t
    m_bLocalCoords = 0x1F8 # bool
    m_flRemapBias = 0x1FC # float

class C_INIT_RemapSpeedToScalar:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_nControlPointNumber = 0x1C4 # int32_t
    m_flStartTime = 0x1C8 # float
    m_flEndTime = 0x1CC # float
    m_flInputMin = 0x1D0 # float
    m_flInputMax = 0x1D4 # float
    m_flOutputMin = 0x1D8 # float
    m_flOutputMax = 0x1DC # float
    m_nSetMethod = 0x1E0 # ParticleSetMethod_t
    m_bPerParticle = 0x1E4 # bool

class C_INIT_RemapTransformOrientationToRotations:
    m_TransformInput = 0x1C0 # CParticleTransformInput
    m_vecRotation = 0x228 # Vector
    m_bUseQuat = 0x234 # bool
    m_bWriteNormal = 0x235 # bool

class C_INIT_RemapTransformToVector:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_vInputMin = 0x1C4 # Vector
    m_vInputMax = 0x1D0 # Vector
    m_vOutputMin = 0x1DC # Vector
    m_vOutputMax = 0x1E8 # Vector
    m_TransformInput = 0x1F8 # CParticleTransformInput
    m_LocalSpaceTransform = 0x260 # CParticleTransformInput
    m_flStartTime = 0x2C8 # float
    m_flEndTime = 0x2CC # float
    m_nSetMethod = 0x2D0 # ParticleSetMethod_t
    m_bOffset = 0x2D4 # bool
    m_bAccelerate = 0x2D5 # bool
    m_flRemapBias = 0x2D8 # float

class C_INIT_RingWave:
    m_TransformInput = 0x1C0 # CParticleTransformInput
    m_flParticlesPerOrbit = 0x228 # CParticleCollectionFloatInput
    m_flInitialRadius = 0x380 # CPerParticleFloatInput
    m_flThickness = 0x4D8 # CPerParticleFloatInput
    m_flInitialSpeedMin = 0x630 # CPerParticleFloatInput
    m_flInitialSpeedMax = 0x788 # CPerParticleFloatInput
    m_flRoll = 0x8E0 # CPerParticleFloatInput
    m_flPitch = 0xA38 # CPerParticleFloatInput
    m_flYaw = 0xB90 # CPerParticleFloatInput
    m_bEvenDistribution = 0xCE8 # bool
    m_bXYVelocityOnly = 0xCE9 # bool

class C_INIT_RtEnvCull:
    m_vecTestDir = 0x1C0 # Vector
    m_vecTestNormal = 0x1CC # Vector
    m_bUseVelocity = 0x1D8 # bool
    m_bCullOnMiss = 0x1D9 # bool
    m_bLifeAdjust = 0x1DA # bool
    m_RtEnvName = 0x1DB # char[128]
    m_nRTEnvCP = 0x25C # int32_t
    m_nComponent = 0x260 # int32_t

class C_INIT_ScaleVelocity:
    m_vecScale = 0x1C0 # CParticleCollectionVecInput

class C_INIT_SequenceFromCP:
    m_bKillUnused = 0x1C0 # bool
    m_bRadiusScale = 0x1C1 # bool
    m_nCP = 0x1C4 # int32_t
    m_vecOffset = 0x1C8 # Vector

class C_INIT_SequenceLifeTime:
    m_flFramerate = 0x1C0 # float

class C_INIT_SetHitboxToClosest:
    m_nControlPointNumber = 0x1C0 # int32_t
    m_nDesiredHitbox = 0x1C4 # int32_t
    m_vecHitBoxScale = 0x1C8 # CParticleCollectionVecInput
    m_HitboxSetName = 0x820 # char[128]
    m_bUseBones = 0x8A0 # bool
    m_bUseClosestPointOnHitbox = 0x8A1 # bool
    m_nTestType = 0x8A4 # ClosestPointTestType_t
    m_flHybridRatio = 0x8A8 # CParticleCollectionFloatInput
    m_bUpdatePosition = 0xA00 # bool

class C_INIT_SetHitboxToModel:
    m_nControlPointNumber = 0x1C0 # int32_t
    m_nForceInModel = 0x1C4 # int32_t
    m_nDesiredHitbox = 0x1C8 # int32_t
    m_vecHitBoxScale = 0x1D0 # CParticleCollectionVecInput
    m_vecDirectionBias = 0x828 # Vector
    m_bMaintainHitbox = 0x834 # bool
    m_bUseBones = 0x835 # bool
    m_HitboxSetName = 0x836 # char[128]
    m_flShellSize = 0x8B8 # CParticleCollectionFloatInput

class C_INIT_SetRigidAttachment:
    m_nControlPointNumber = 0x1C0 # int32_t
    m_nFieldInput = 0x1C4 # ParticleAttributeIndex_t
    m_nFieldOutput = 0x1C8 # ParticleAttributeIndex_t
    m_bLocalSpace = 0x1CC # bool

class C_INIT_SetVectorAttributeToVectorExpression:
    m_nExpression = 0x1C0 # VectorExpressionType_t
    m_vInput1 = 0x1C8 # CPerParticleVecInput
    m_vInput2 = 0x820 # CPerParticleVecInput
    m_nOutputField = 0xE78 # ParticleAttributeIndex_t
    m_nSetMethod = 0xE7C # ParticleSetMethod_t
    m_bNormalizedOutput = 0xE80 # bool

class C_INIT_StatusEffect:
    m_nDetail2Combo = 0x1C0 # Detail2Combo_t
    m_flDetail2Rotation = 0x1C4 # float
    m_flDetail2Scale = 0x1C8 # float
    m_flDetail2BlendFactor = 0x1CC # float
    m_flColorWarpIntensity = 0x1D0 # float
    m_flDiffuseWarpBlendToFull = 0x1D4 # float
    m_flEnvMapIntensity = 0x1D8 # float
    m_flAmbientScale = 0x1DC # float
    m_specularColor = 0x1E0 # Color
    m_flSpecularScale = 0x1E4 # float
    m_flSpecularExponent = 0x1E8 # float
    m_flSpecularExponentBlendToFull = 0x1EC # float
    m_flSpecularBlendToFull = 0x1F0 # float
    m_rimLightColor = 0x1F4 # Color
    m_flRimLightScale = 0x1F8 # float
    m_flReflectionsTintByBaseBlendToNone = 0x1FC # float
    m_flMetalnessBlendToFull = 0x200 # float
    m_flSelfIllumBlendToFull = 0x204 # float

class C_INIT_StatusEffectCitadel:
    m_flSFXColorWarpAmount = 0x1C0 # float
    m_flSFXNormalAmount = 0x1C4 # float
    m_flSFXMetalnessAmount = 0x1C8 # float
    m_flSFXRoughnessAmount = 0x1CC # float
    m_flSFXSelfIllumAmount = 0x1D0 # float
    m_flSFXSScale = 0x1D4 # float
    m_flSFXSScrollX = 0x1D8 # float
    m_flSFXSScrollY = 0x1DC # float
    m_flSFXSScrollZ = 0x1E0 # float
    m_flSFXSOffsetX = 0x1E4 # float
    m_flSFXSOffsetY = 0x1E8 # float
    m_flSFXSOffsetZ = 0x1EC # float
    m_nDetailCombo = 0x1F0 # DetailCombo_t
    m_flSFXSDetailAmount = 0x1F4 # float
    m_flSFXSDetailScale = 0x1F8 # float
    m_flSFXSDetailScrollX = 0x1FC # float
    m_flSFXSDetailScrollY = 0x200 # float
    m_flSFXSDetailScrollZ = 0x204 # float
    m_flSFXSUseModelUVs = 0x208 # float

class C_INIT_VelocityFromCP:
    m_velocityInput = 0x1C0 # CParticleCollectionVecInput
    m_transformInput = 0x818 # CParticleTransformInput
    m_flVelocityScale = 0x880 # float
    m_bDirectionOnly = 0x884 # bool

class C_INIT_VelocityFromNormal:
    m_fSpeedMin = 0x1C0 # float
    m_fSpeedMax = 0x1C4 # float
    m_bIgnoreDt = 0x1C8 # bool

class C_INIT_VelocityRadialRandom:
    m_nControlPointNumber = 0x1C0 # int32_t
    m_fSpeedMin = 0x1C4 # float
    m_fSpeedMax = 0x1C8 # float
    m_vecLocalCoordinateSystemSpeedScale = 0x1CC # Vector
    m_bIgnoreDelta = 0x1D9 # bool

class C_INIT_VelocityRandom:
    m_nControlPointNumber = 0x1C0 # int32_t
    m_fSpeedMin = 0x1C8 # CPerParticleFloatInput
    m_fSpeedMax = 0x320 # CPerParticleFloatInput
    m_LocalCoordinateSystemSpeedMin = 0x478 # CPerParticleVecInput
    m_LocalCoordinateSystemSpeedMax = 0xAD0 # CPerParticleVecInput
    m_bIgnoreDT = 0x1128 # bool
    m_randomnessParameters = 0x112C # CRandomNumberGeneratorParameters

class C_OP_AlphaDecay:
    m_flMinAlpha = 0x1C0 # float

class C_OP_AttractToControlPoint:
    m_vecComponentScale = 0x1D0 # Vector
    m_fForceAmount = 0x1E0 # CPerParticleFloatInput
    m_fFalloffPower = 0x338 # float
    m_TransformInput = 0x340 # CParticleTransformInput
    m_fForceAmountMin = 0x3A8 # CPerParticleFloatInput
    m_bApplyMinForce = 0x500 # bool

class C_OP_BasicMovement:
    m_Gravity = 0x1C0 # CParticleCollectionVecInput
    m_fDrag = 0x818 # CParticleCollectionFloatInput
    m_nMaxConstraintPasses = 0x970 # int32_t

class C_OP_BoxConstraint:
    m_vecMin = 0x1C0 # CParticleCollectionVecInput
    m_vecMax = 0x818 # CParticleCollectionVecInput
    m_nCP = 0xE70 # int32_t
    m_bLocalSpace = 0xE74 # bool
    m_bAccountForRadius = 0xE75 # bool

class C_OP_CPOffsetToPercentageBetweenCPs:
    m_flInputMin = 0x1C0 # float
    m_flInputMax = 0x1C4 # float
    m_flInputBias = 0x1C8 # float
    m_nStartCP = 0x1CC # int32_t
    m_nEndCP = 0x1D0 # int32_t
    m_nOffsetCP = 0x1D4 # int32_t
    m_nOuputCP = 0x1D8 # int32_t
    m_nInputCP = 0x1DC # int32_t
    m_bRadialCheck = 0x1E0 # bool
    m_bScaleOffset = 0x1E1 # bool
    m_vecOffset = 0x1E4 # Vector

class C_OP_CPVelocityForce:
    m_nControlPointNumber = 0x1D0 # int32_t
    m_flScale = 0x1D8 # CPerParticleFloatInput

class C_OP_CalculateVectorAttribute:
    m_vStartValue = 0x1C0 # Vector
    m_nFieldInput1 = 0x1CC # ParticleAttributeIndex_t
    m_flInputScale1 = 0x1D0 # float
    m_nFieldInput2 = 0x1D4 # ParticleAttributeIndex_t
    m_flInputScale2 = 0x1D8 # float
    m_nControlPointInput1 = 0x1DC # ControlPointReference_t
    m_flControlPointScale1 = 0x1F0 # float
    m_nControlPointInput2 = 0x1F4 # ControlPointReference_t
    m_flControlPointScale2 = 0x208 # float
    m_nFieldOutput = 0x20C # ParticleAttributeIndex_t
    m_vFinalOutputScale = 0x210 # Vector

class C_OP_ChladniWave:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_flInputMin = 0x1C8 # CPerParticleFloatInput
    m_flInputMax = 0x320 # CPerParticleFloatInput
    m_flOutputMin = 0x478 # CPerParticleFloatInput
    m_flOutputMax = 0x5D0 # CPerParticleFloatInput
    m_vecWaveLength = 0x728 # CPerParticleVecInput
    m_vecHarmonics = 0xD80 # CPerParticleVecInput
    m_nSetMethod = 0x13D8 # ParticleSetMethod_t
    m_nLocalSpaceControlPoint = 0x13DC # int32_t
    m_b3D = 0x13E0 # bool

class C_OP_ChooseRandomChildrenInGroup:
    m_nChildGroupID = 0x1D0 # int32_t
    m_flNumberOfChildren = 0x1D8 # CParticleCollectionFloatInput

class C_OP_ClampScalar:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_flOutputMin = 0x1C8 # CPerParticleFloatInput
    m_flOutputMax = 0x320 # CPerParticleFloatInput

class C_OP_ClampVector:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_vecOutputMin = 0x1C8 # CPerParticleVecInput
    m_vecOutputMax = 0x820 # CPerParticleVecInput

class C_OP_CollideWithParentParticles:
    m_flParentRadiusScale = 0x1C0 # CPerParticleFloatInput
    m_flRadiusScale = 0x318 # CPerParticleFloatInput

class C_OP_CollideWithSelf:
    m_flRadiusScale = 0x1C0 # CPerParticleFloatInput
    m_flMinimumSpeed = 0x318 # CPerParticleFloatInput

class C_OP_ColorAdjustHSL:
    m_flHueAdjust = 0x1C0 # CPerParticleFloatInput
    m_flSaturationAdjust = 0x318 # CPerParticleFloatInput
    m_flLightnessAdjust = 0x470 # CPerParticleFloatInput

class C_OP_ColorInterpolate:
    m_ColorFade = 0x1C0 # Color
    m_flFadeStartTime = 0x1D0 # float
    m_flFadeEndTime = 0x1D4 # float
    m_nFieldOutput = 0x1D8 # ParticleAttributeIndex_t
    m_bEaseInOut = 0x1DC # bool
    m_bUseNewCode = 0x1DD # bool

class C_OP_ColorInterpolateRandom:
    m_ColorFadeMin = 0x1C0 # Color
    m_ColorFadeMax = 0x1DC # Color
    m_flFadeStartTime = 0x1EC # float
    m_flFadeEndTime = 0x1F0 # float
    m_nFieldOutput = 0x1F4 # ParticleAttributeIndex_t
    m_bEaseInOut = 0x1F8 # bool

class C_OP_ConnectParentParticleToNearest:
    m_nFirstControlPoint = 0x1C0 # int32_t
    m_nSecondControlPoint = 0x1C4 # int32_t

class C_OP_ConstrainDistance:
    m_fMinDistance = 0x1C0 # CParticleCollectionFloatInput
    m_fMaxDistance = 0x318 # CParticleCollectionFloatInput
    m_nControlPointNumber = 0x470 # int32_t
    m_CenterOffset = 0x474 # Vector
    m_bGlobalCenter = 0x480 # bool

class C_OP_ConstrainDistanceToPath:
    m_fMinDistance = 0x1C0 # float
    m_flMaxDistance0 = 0x1C4 # float
    m_flMaxDistanceMid = 0x1C8 # float
    m_flMaxDistance1 = 0x1CC # float
    m_PathParameters = 0x1D0 # CPathParameters
    m_flTravelTime = 0x210 # float
    m_nFieldScale = 0x214 # ParticleAttributeIndex_t
    m_nManualTField = 0x218 # ParticleAttributeIndex_t

class C_OP_ConstrainDistanceToUserSpecifiedPath:
    m_fMinDistance = 0x1C0 # float
    m_flMaxDistance = 0x1C4 # float
    m_flTimeScale = 0x1C8 # float
    m_bLoopedPath = 0x1CC # bool
    m_pointList = 0x1D0 # CUtlVector<PointDefinitionWithTimeValues_t>

class C_OP_ConstrainLineLength:
    m_flMinDistance = 0x1C0 # float
    m_flMaxDistance = 0x1C4 # float

class C_OP_ContinuousEmitter:
    m_flEmissionDuration = 0x1C0 # CParticleCollectionFloatInput
    m_flStartTime = 0x318 # CParticleCollectionFloatInput
    m_flEmitRate = 0x470 # CParticleCollectionFloatInput
    m_flEmissionScale = 0x5C8 # float
    m_flScalePerParentParticle = 0x5CC # float
    m_bInitFromKilledParentParticles = 0x5D0 # bool
    m_nSnapshotControlPoint = 0x5D4 # int32_t
    m_nLimitPerUpdate = 0x5D8 # int32_t
    m_bForceEmitOnFirstUpdate = 0x5DC # bool
    m_bForceEmitOnLastUpdate = 0x5DD # bool

class C_OP_ControlPointToRadialScreenSpace:
    m_nCPIn = 0x1D0 # int32_t
    m_vecCP1Pos = 0x1D4 # Vector
    m_nCPOut = 0x1E0 # int32_t
    m_nCPOutField = 0x1E4 # int32_t
    m_nCPSSPosOut = 0x1E8 # int32_t

class C_OP_ControlpointLight:
    m_flScale = 0x1C0 # float
    m_nControlPoint1 = 0x650 # int32_t
    m_nControlPoint2 = 0x654 # int32_t
    m_nControlPoint3 = 0x658 # int32_t
    m_nControlPoint4 = 0x65C # int32_t
    m_vecCPOffset1 = 0x660 # Vector
    m_vecCPOffset2 = 0x66C # Vector
    m_vecCPOffset3 = 0x678 # Vector
    m_vecCPOffset4 = 0x684 # Vector
    m_LightFiftyDist1 = 0x690 # float
    m_LightZeroDist1 = 0x694 # float
    m_LightFiftyDist2 = 0x698 # float
    m_LightZeroDist2 = 0x69C # float
    m_LightFiftyDist3 = 0x6A0 # float
    m_LightZeroDist3 = 0x6A4 # float
    m_LightFiftyDist4 = 0x6A8 # float
    m_LightZeroDist4 = 0x6AC # float
    m_LightColor1 = 0x6B0 # Color
    m_LightColor2 = 0x6B4 # Color
    m_LightColor3 = 0x6B8 # Color
    m_LightColor4 = 0x6BC # Color
    m_bLightType1 = 0x6C0 # bool
    m_bLightType2 = 0x6C1 # bool
    m_bLightType3 = 0x6C2 # bool
    m_bLightType4 = 0x6C3 # bool
    m_bLightDynamic1 = 0x6C4 # bool
    m_bLightDynamic2 = 0x6C5 # bool
    m_bLightDynamic3 = 0x6C6 # bool
    m_bLightDynamic4 = 0x6C7 # bool
    m_bUseNormal = 0x6C8 # bool
    m_bUseHLambert = 0x6C9 # bool
    m_bClampLowerRange = 0x6CE # bool
    m_bClampUpperRange = 0x6CF # bool

class C_OP_Cull:
    m_flCullPerc = 0x1C0 # float
    m_flCullStart = 0x1C4 # float
    m_flCullEnd = 0x1C8 # float
    m_flCullExp = 0x1CC # float

class C_OP_CurlNoiseForce:
    m_nNoiseType = 0x1D0 # ParticleDirectionNoiseType_t
    m_vecNoiseFreq = 0x1D8 # CPerParticleVecInput
    m_vecNoiseScale = 0x830 # CPerParticleVecInput
    m_vecOffset = 0xE88 # CPerParticleVecInput
    m_vecOffsetRate = 0x14E0 # CPerParticleVecInput
    m_flWorleySeed = 0x1B38 # CPerParticleFloatInput
    m_flWorleyJitter = 0x1C90 # CPerParticleFloatInput

class C_OP_CycleScalar:
    m_nDestField = 0x1C0 # ParticleAttributeIndex_t
    m_flStartValue = 0x1C4 # float
    m_flEndValue = 0x1C8 # float
    m_flCycleTime = 0x1CC # float
    m_bDoNotRepeatCycle = 0x1D0 # bool
    m_bSynchronizeParticles = 0x1D1 # bool
    m_nCPScale = 0x1D4 # int32_t
    m_nCPFieldMin = 0x1D8 # int32_t
    m_nCPFieldMax = 0x1DC # int32_t
    m_nSetMethod = 0x1E0 # ParticleSetMethod_t

class C_OP_CylindricalDistanceToTransform:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_flInputMin = 0x1C8 # CPerParticleFloatInput
    m_flInputMax = 0x320 # CPerParticleFloatInput
    m_flOutputMin = 0x478 # CPerParticleFloatInput
    m_flOutputMax = 0x5D0 # CPerParticleFloatInput
    m_TransformStart = 0x728 # CParticleTransformInput
    m_TransformEnd = 0x790 # CParticleTransformInput
    m_nSetMethod = 0x7F8 # ParticleSetMethod_t
    m_bActiveRange = 0x7FC # bool
    m_bAdditive = 0x7FD # bool
    m_bCapsule = 0x7FE # bool

class C_OP_DampenToCP:
    m_nControlPointNumber = 0x1C0 # int32_t
    m_flRange = 0x1C4 # float
    m_flScale = 0x1C8 # float

class C_OP_Decay:
    m_bRopeDecay = 0x1C0 # bool
    m_bForcePreserveParticleOrder = 0x1C1 # bool

class C_OP_DecayClampCount:
    m_nCount = 0x1C0 # CParticleCollectionFloatInput

class C_OP_DecayMaintainCount:
    m_nParticlesToMaintain = 0x1C0 # int32_t
    m_flDecayDelay = 0x1C4 # float
    m_nSnapshotControlPoint = 0x1C8 # int32_t
    m_bLifespanDecay = 0x1CC # bool
    m_flScale = 0x1D0 # CParticleCollectionFloatInput
    m_bKillNewest = 0x328 # bool

class C_OP_DecayOffscreen:
    m_flOffscreenTime = 0x1C0 # CParticleCollectionFloatInput

class C_OP_DensityForce:
    m_flRadiusScale = 0x1D0 # float
    m_flForceScale = 0x1D4 # float
    m_flTargetDensity = 0x1D8 # float

class C_OP_DifferencePreviousParticle:
    m_nFieldInput = 0x1C0 # ParticleAttributeIndex_t
    m_nFieldOutput = 0x1C4 # ParticleAttributeIndex_t
    m_flInputMin = 0x1C8 # float
    m_flInputMax = 0x1CC # float
    m_flOutputMin = 0x1D0 # float
    m_flOutputMax = 0x1D4 # float
    m_nSetMethod = 0x1D8 # ParticleSetMethod_t
    m_bActiveRange = 0x1DC # bool
    m_bSetPreviousParticle = 0x1DD # bool

class C_OP_Diffusion:
    m_flRadiusScale = 0x1C0 # float
    m_nFieldOutput = 0x1C4 # ParticleAttributeIndex_t
    m_nVoxelGridResolution = 0x1C8 # int32_t

class C_OP_DirectionBetweenVecsToVec:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_vecPoint1 = 0x1C8 # CPerParticleVecInput
    m_vecPoint2 = 0x820 # CPerParticleVecInput

class C_OP_DistanceBetweenCPsToCP:
    m_nStartCP = 0x1D0 # int32_t
    m_nEndCP = 0x1D4 # int32_t
    m_nOutputCP = 0x1D8 # int32_t
    m_nOutputCPField = 0x1DC # int32_t
    m_bSetOnce = 0x1E0 # bool
    m_flInputMin = 0x1E4 # float
    m_flInputMax = 0x1E8 # float
    m_flOutputMin = 0x1EC # float
    m_flOutputMax = 0x1F0 # float
    m_flMaxTraceLength = 0x1F4 # float
    m_flLOSScale = 0x1F8 # float
    m_bLOS = 0x1FC # bool
    m_CollisionGroupName = 0x1FD # char[128]
    m_nTraceSet = 0x280 # ParticleTraceSet_t
    m_nSetParent = 0x284 # ParticleParentSetMode_t

class C_OP_DistanceBetweenTransforms:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_TransformStart = 0x1C8 # CParticleTransformInput
    m_TransformEnd = 0x230 # CParticleTransformInput
    m_flInputMin = 0x298 # CPerParticleFloatInput
    m_flInputMax = 0x3F0 # CPerParticleFloatInput
    m_flOutputMin = 0x548 # CPerParticleFloatInput
    m_flOutputMax = 0x6A0 # CPerParticleFloatInput
    m_flMaxTraceLength = 0x7F8 # float
    m_flLOSScale = 0x7FC # float
    m_CollisionGroupName = 0x800 # char[128]
    m_nTraceSet = 0x880 # ParticleTraceSet_t
    m_bLOS = 0x884 # bool
    m_nSetMethod = 0x888 # ParticleSetMethod_t

class C_OP_DistanceBetweenVecs:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_vecPoint1 = 0x1C8 # CPerParticleVecInput
    m_vecPoint2 = 0x820 # CPerParticleVecInput
    m_flInputMin = 0xE78 # CPerParticleFloatInput
    m_flInputMax = 0xFD0 # CPerParticleFloatInput
    m_flOutputMin = 0x1128 # CPerParticleFloatInput
    m_flOutputMax = 0x1280 # CPerParticleFloatInput
    m_nSetMethod = 0x13D8 # ParticleSetMethod_t
    m_bDeltaTime = 0x13DC # bool

class C_OP_DistanceCull:
    m_nControlPoint = 0x1C0 # int32_t
    m_vecPointOffset = 0x1C4 # Vector
    m_flDistance = 0x1D0 # float
    m_bCullInside = 0x1D4 # bool

class C_OP_DistanceToTransform:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_flInputMin = 0x1C8 # CPerParticleFloatInput
    m_flInputMax = 0x320 # CPerParticleFloatInput
    m_flOutputMin = 0x478 # CPerParticleFloatInput
    m_flOutputMax = 0x5D0 # CPerParticleFloatInput
    m_TransformStart = 0x728 # CParticleTransformInput
    m_bLOS = 0x790 # bool
    m_CollisionGroupName = 0x791 # char[128]
    m_nTraceSet = 0x814 # ParticleTraceSet_t
    m_flMaxTraceLength = 0x818 # float
    m_flLOSScale = 0x81C # float
    m_nSetMethod = 0x820 # ParticleSetMethod_t
    m_bActiveRange = 0x824 # bool
    m_bAdditive = 0x825 # bool
    m_vecComponentScale = 0x828 # CPerParticleVecInput

class C_OP_DragRelativeToPlane:
    m_flDragAtPlane = 0x1C0 # CParticleCollectionFloatInput
    m_flFalloff = 0x318 # CParticleCollectionFloatInput
    m_bDirectional = 0x470 # bool
    m_vecPlaneNormal = 0x478 # CParticleCollectionVecInput
    m_nControlPointNumber = 0xAD0 # int32_t

class C_OP_DriveCPFromGlobalSoundFloat:
    m_nOutputControlPoint = 0x1D0 # int32_t
    m_nOutputField = 0x1D4 # int32_t
    m_flInputMin = 0x1D8 # float
    m_flInputMax = 0x1DC # float
    m_flOutputMin = 0x1E0 # float
    m_flOutputMax = 0x1E4 # float
    m_StackName = 0x1E8 # CUtlString
    m_OperatorName = 0x1F0 # CUtlString
    m_FieldName = 0x1F8 # CUtlString

class C_OP_EnableChildrenFromParentParticleCount:
    m_nChildGroupID = 0x1D0 # int32_t
    m_nFirstChild = 0x1D4 # int32_t
    m_nNumChildrenToEnable = 0x1D8 # CParticleCollectionFloatInput
    m_bDisableChildren = 0x330 # bool
    m_bPlayEndcapOnStop = 0x331 # bool
    m_bDestroyImmediately = 0x332 # bool

class C_OP_EndCapTimedDecay:
    m_flDecayTime = 0x1C0 # float

class C_OP_EndCapTimedFreeze:
    m_flFreezeTime = 0x1C0 # CParticleCollectionFloatInput

class C_OP_ExternalGameImpulseForce:
    m_flForceScale = 0x1D0 # CPerParticleFloatInput
    m_bRopes = 0x328 # bool
    m_bRopesZOnly = 0x329 # bool
    m_bExplosions = 0x32A # bool
    m_bParticles = 0x32B # bool

class C_OP_ExternalWindForce:
    m_vecSamplePosition = 0x1D0 # CPerParticleVecInput
    m_vecScale = 0x828 # CPerParticleVecInput
    m_bSampleWind = 0xE80 # bool
    m_bSampleWater = 0xE81 # bool
    m_bDampenNearWaterPlane = 0xE82 # bool
    m_bSampleGravity = 0xE83 # bool
    m_vecGravityForce = 0xE88 # CPerParticleVecInput
    m_bUseBasicMovementGravity = 0x14E0 # bool
    m_flLocalGravityScale = 0x14E8 # CPerParticleFloatInput
    m_flLocalBuoyancyScale = 0x1640 # CPerParticleFloatInput
    m_vecBuoyancyForce = 0x1798 # CPerParticleVecInput

class C_OP_FadeAndKill:
    m_flStartFadeInTime = 0x1C0 # float
    m_flEndFadeInTime = 0x1C4 # float
    m_flStartFadeOutTime = 0x1C8 # float
    m_flEndFadeOutTime = 0x1CC # float
    m_flStartAlpha = 0x1D0 # float
    m_flEndAlpha = 0x1D4 # float
    m_bForcePreserveParticleOrder = 0x1D8 # bool

class C_OP_FadeAndKillForTracers:
    m_flStartFadeInTime = 0x1C0 # float
    m_flEndFadeInTime = 0x1C4 # float
    m_flStartFadeOutTime = 0x1C8 # float
    m_flEndFadeOutTime = 0x1CC # float
    m_flStartAlpha = 0x1D0 # float
    m_flEndAlpha = 0x1D4 # float

class C_OP_FadeIn:
    m_flFadeInTimeMin = 0x1C0 # float
    m_flFadeInTimeMax = 0x1C4 # float
    m_flFadeInTimeExp = 0x1C8 # float
    m_bProportional = 0x1CC # bool

class C_OP_FadeInSimple:
    m_flFadeInTime = 0x1C0 # float
    m_nFieldOutput = 0x1C4 # ParticleAttributeIndex_t

class C_OP_FadeOut:
    m_flFadeOutTimeMin = 0x1C0 # float
    m_flFadeOutTimeMax = 0x1C4 # float
    m_flFadeOutTimeExp = 0x1C8 # float
    m_flFadeBias = 0x1CC # float
    m_bProportional = 0x200 # bool
    m_bEaseInAndOut = 0x201 # bool

class C_OP_FadeOutSimple:
    m_flFadeOutTime = 0x1C0 # float
    m_nFieldOutput = 0x1C4 # ParticleAttributeIndex_t

class C_OP_ForceBasedOnDistanceToPlane:
    m_flMinDist = 0x1D0 # float
    m_vecForceAtMinDist = 0x1D4 # Vector
    m_flMaxDist = 0x1E0 # float
    m_vecForceAtMaxDist = 0x1E4 # Vector
    m_vecPlaneNormal = 0x1F0 # Vector
    m_nControlPointNumber = 0x1FC # int32_t
    m_flExponent = 0x200 # float

class C_OP_ForceControlPointStub:
    m_ControlPoint = 0x1D0 # int32_t

class C_OP_GlobalLight:
    m_flScale = 0x1C0 # float
    m_bClampLowerRange = 0x1C4 # bool
    m_bClampUpperRange = 0x1C5 # bool

class C_OP_HSVShiftToCP:
    m_nColorCP = 0x1D0 # int32_t
    m_nColorGemEnableCP = 0x1D4 # int32_t
    m_nOutputCP = 0x1D8 # int32_t
    m_DefaultHSVColor = 0x1DC # Color

class C_OP_InheritFromParentParticles:
    m_flScale = 0x1C0 # float
    m_nFieldOutput = 0x1C4 # ParticleAttributeIndex_t
    m_nIncrement = 0x1C8 # int32_t
    m_bRandomDistribution = 0x1CC # bool

class C_OP_InheritFromParentParticlesV2:
    m_flScale = 0x1C0 # float
    m_nFieldOutput = 0x1C4 # ParticleAttributeIndex_t
    m_nIncrement = 0x1C8 # int32_t
    m_bRandomDistribution = 0x1CC # bool
    m_nMissingParentBehavior = 0x1D0 # MissingParentInheritBehavior_t

class C_OP_InheritFromPeerSystem:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_nFieldInput = 0x1C4 # ParticleAttributeIndex_t
    m_nIncrement = 0x1C8 # int32_t
    m_nGroupID = 0x1CC # int32_t

class C_OP_InstantaneousEmitter:
    m_nParticlesToEmit = 0x1C0 # CParticleCollectionFloatInput
    m_flStartTime = 0x318 # CParticleCollectionFloatInput
    m_flInitFromKilledParentParticles = 0x470 # float
    m_flParentParticleScale = 0x478 # CParticleCollectionFloatInput
    m_nMaxEmittedPerFrame = 0x5D0 # int32_t
    m_nSnapshotControlPoint = 0x5D4 # int32_t

class C_OP_InterpolateRadius:
    m_flStartTime = 0x1C0 # float
    m_flEndTime = 0x1C4 # float
    m_flStartScale = 0x1C8 # float
    m_flEndScale = 0x1CC # float
    m_bEaseInAndOut = 0x1D0 # bool
    m_flBias = 0x1D4 # float

class C_OP_LagCompensation:
    m_nDesiredVelocityCP = 0x1C0 # int32_t
    m_nLatencyCP = 0x1C4 # int32_t
    m_nLatencyCPField = 0x1C8 # int32_t
    m_nDesiredVelocityCPField = 0x1CC # int32_t

class C_OP_LerpEndCapScalar:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_flOutput = 0x1C4 # float
    m_flLerpTime = 0x1C8 # float

class C_OP_LerpEndCapVector:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_vecOutput = 0x1C4 # Vector
    m_flLerpTime = 0x1D0 # float

class C_OP_LerpScalar:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_flOutput = 0x1C8 # CPerParticleFloatInput
    m_flStartTime = 0x320 # float
    m_flEndTime = 0x324 # float

class C_OP_LerpToInitialPosition:
    m_nControlPointNumber = 0x1C0 # int32_t
    m_flInterpolation = 0x1C8 # CPerParticleFloatInput
    m_nCacheField = 0x320 # ParticleAttributeIndex_t
    m_flScale = 0x328 # CParticleCollectionFloatInput
    m_vecScale = 0x480 # CParticleCollectionVecInput

class C_OP_LerpToOtherAttribute:
    m_flInterpolation = 0x1C0 # CPerParticleFloatInput
    m_nFieldInputFrom = 0x318 # ParticleAttributeIndex_t
    m_nFieldInput = 0x31C # ParticleAttributeIndex_t
    m_nFieldOutput = 0x320 # ParticleAttributeIndex_t

class C_OP_LerpVector:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_vecOutput = 0x1C4 # Vector
    m_flStartTime = 0x1D0 # float
    m_flEndTime = 0x1D4 # float
    m_nSetMethod = 0x1D8 # ParticleSetMethod_t

class C_OP_LightningSnapshotGenerator:
    m_nCPSnapshot = 0x1D0 # int32_t
    m_nCPStartPnt = 0x1D4 # int32_t
    m_nCPEndPnt = 0x1D8 # int32_t
    m_flSegments = 0x1E0 # CParticleCollectionFloatInput
    m_flOffset = 0x338 # CParticleCollectionFloatInput
    m_flOffsetDecay = 0x490 # CParticleCollectionFloatInput
    m_flRecalcRate = 0x5E8 # CParticleCollectionFloatInput
    m_flUVScale = 0x740 # CParticleCollectionFloatInput
    m_flUVOffset = 0x898 # CParticleCollectionFloatInput
    m_flSplitRate = 0x9F0 # CParticleCollectionFloatInput
    m_flBranchTwist = 0xB48 # CParticleCollectionFloatInput
    m_nBranchBehavior = 0xCA0 # ParticleLightnintBranchBehavior_t
    m_flRadiusStart = 0xCA8 # CParticleCollectionFloatInput
    m_flRadiusEnd = 0xE00 # CParticleCollectionFloatInput
    m_flDedicatedPool = 0xF58 # CParticleCollectionFloatInput

class C_OP_LocalAccelerationForce:
    m_nCP = 0x1D0 # int32_t
    m_nScaleCP = 0x1D4 # int32_t
    m_vecAccel = 0x1D8 # CParticleCollectionVecInput

class C_OP_LockPoints:
    m_nMinCol = 0x1C0 # int32_t
    m_nMaxCol = 0x1C4 # int32_t
    m_nMinRow = 0x1C8 # int32_t
    m_nMaxRow = 0x1CC # int32_t
    m_nControlPoint = 0x1D0 # int32_t
    m_flBlendValue = 0x1D4 # float

class C_OP_LockToBone:
    m_modelInput = 0x1C0 # CParticleModelInput
    m_transformInput = 0x220 # CParticleTransformInput
    m_flLifeTimeFadeStart = 0x288 # float
    m_flLifeTimeFadeEnd = 0x28C # float
    m_flJumpThreshold = 0x290 # float
    m_flPrevPosScale = 0x294 # float
    m_HitboxSetName = 0x298 # char[128]
    m_bRigid = 0x318 # bool
    m_bUseBones = 0x319 # bool
    m_nFieldOutput = 0x31C # ParticleAttributeIndex_t
    m_nFieldOutputPrev = 0x320 # ParticleAttributeIndex_t
    m_nRotationSetType = 0x324 # ParticleRotationLockType_t
    m_bRigidRotationLock = 0x328 # bool
    m_vecRotation = 0x330 # CPerParticleVecInput
    m_flRotLerp = 0x988 # CPerParticleFloatInput

class C_OP_LockToPointList:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_pointList = 0x1C8 # CUtlVector<PointDefinition_t>
    m_bPlaceAlongPath = 0x1E0 # bool
    m_bClosedLoop = 0x1E1 # bool
    m_nNumPointsAlongPath = 0x1E4 # int32_t

class C_OP_LockToSavedSequentialPath:
    m_flFadeStart = 0x1C4 # float
    m_flFadeEnd = 0x1C8 # float
    m_bCPPairs = 0x1CC # bool
    m_PathParams = 0x1D0 # CPathParameters

class C_OP_LockToSavedSequentialPathV2:
    m_flFadeStart = 0x1C0 # float
    m_flFadeEnd = 0x1C4 # float
    m_bCPPairs = 0x1C8 # bool
    m_PathParams = 0x1D0 # CPathParameters

class C_OP_MaintainEmitter:
    m_nParticlesToMaintain = 0x1C0 # CParticleCollectionFloatInput
    m_flStartTime = 0x318 # float
    m_flEmissionDuration = 0x320 # CParticleCollectionFloatInput
    m_flEmissionRate = 0x478 # float
    m_nSnapshotControlPoint = 0x47C # int32_t
    m_bEmitInstantaneously = 0x480 # bool
    m_bFinalEmitOnStop = 0x481 # bool
    m_flScale = 0x488 # CParticleCollectionFloatInput

class C_OP_MaintainSequentialPath:
    m_fMaxDistance = 0x1C0 # float
    m_flNumToAssign = 0x1C4 # float
    m_flCohesionStrength = 0x1C8 # float
    m_flTolerance = 0x1CC # float
    m_bLoop = 0x1D0 # bool
    m_bUseParticleCount = 0x1D1 # bool
    m_PathParams = 0x1E0 # CPathParameters

class C_OP_MaxVelocity:
    m_flMaxVelocity = 0x1C0 # float
    m_flMinVelocity = 0x1C4 # float
    m_nOverrideCP = 0x1C8 # int32_t
    m_nOverrideCPField = 0x1CC # int32_t

class C_OP_ModelCull:
    m_nControlPointNumber = 0x1C0 # int32_t
    m_bBoundBox = 0x1C4 # bool
    m_bCullOutside = 0x1C5 # bool
    m_bUseBones = 0x1C6 # bool
    m_HitboxSetName = 0x1C7 # char[128]

class C_OP_ModelDampenMovement:
    m_nControlPointNumber = 0x1C0 # int32_t
    m_bBoundBox = 0x1C4 # bool
    m_bOutside = 0x1C5 # bool
    m_bUseBones = 0x1C6 # bool
    m_HitboxSetName = 0x1C7 # char[128]
    m_vecPosOffset = 0x248 # CPerParticleVecInput
    m_fDrag = 0x8A0 # float

class C_OP_MoveToHitbox:
    m_modelInput = 0x1C0 # CParticleModelInput
    m_transformInput = 0x220 # CParticleTransformInput
    m_flLifeTimeLerpStart = 0x28C # float
    m_flLifeTimeLerpEnd = 0x290 # float
    m_flPrevPosScale = 0x294 # float
    m_HitboxSetName = 0x298 # char[128]
    m_bUseBones = 0x318 # bool
    m_nLerpType = 0x31C # HitboxLerpType_t
    m_flInterpolation = 0x320 # CPerParticleFloatInput

class C_OP_MovementLoopInsideSphere:
    m_nCP = 0x1C0 # int32_t
    m_flDistance = 0x1C8 # CParticleCollectionFloatInput
    m_vecScale = 0x320 # CParticleCollectionVecInput
    m_nDistSqrAttr = 0x978 # ParticleAttributeIndex_t

class C_OP_MovementMaintainOffset:
    m_vecOffset = 0x1C0 # Vector
    m_nCP = 0x1CC # int32_t
    m_bRadiusScale = 0x1D0 # bool

class C_OP_MovementMoveAlongSkinnedCPSnapshot:
    m_nControlPointNumber = 0x1C0 # int32_t
    m_nSnapshotControlPointNumber = 0x1C4 # int32_t
    m_bSetNormal = 0x1C8 # bool
    m_bSetRadius = 0x1C9 # bool
    m_flInterpolation = 0x1D0 # CPerParticleFloatInput
    m_flTValue = 0x328 # CPerParticleFloatInput

class C_OP_MovementPlaceOnGround:
    m_flOffset = 0x1C0 # CPerParticleFloatInput
    m_flMaxTraceLength = 0x318 # float
    m_flTolerance = 0x31C # float
    m_flTraceOffset = 0x320 # float
    m_flLerpRate = 0x324 # float
    m_CollisionGroupName = 0x328 # char[128]
    m_nTraceSet = 0x3A8 # ParticleTraceSet_t
    m_nRefCP1 = 0x3AC # int32_t
    m_nRefCP2 = 0x3B0 # int32_t
    m_nLerpCP = 0x3B4 # int32_t
    m_nTraceMissBehavior = 0x3C0 # ParticleTraceMissBehavior_t
    m_bIncludeShotHull = 0x3C4 # bool
    m_bIncludeWater = 0x3C5 # bool
    m_bSetNormal = 0x3C8 # bool
    m_bScaleOffset = 0x3C9 # bool
    m_nPreserveOffsetCP = 0x3CC # int32_t
    m_nIgnoreCP = 0x3D0 # int32_t

class C_OP_MovementRigidAttachToCP:
    m_nControlPointNumber = 0x1C0 # int32_t
    m_nScaleControlPoint = 0x1C4 # int32_t
    m_nScaleCPField = 0x1C8 # int32_t
    m_nFieldInput = 0x1CC # ParticleAttributeIndex_t
    m_nFieldOutput = 0x1D0 # ParticleAttributeIndex_t
    m_bOffsetLocal = 0x1D4 # bool

class C_OP_MovementRotateParticleAroundAxis:
    m_vecRotAxis = 0x1C0 # CParticleCollectionVecInput
    m_flRotRate = 0x818 # CParticleCollectionFloatInput
    m_TransformInput = 0x970 # CParticleTransformInput
    m_bLocalSpace = 0x9D8 # bool

class C_OP_MovementSkinnedPositionFromCPSnapshot:
    m_nSnapshotControlPointNumber = 0x1C0 # int32_t
    m_nControlPointNumber = 0x1C4 # int32_t
    m_bRandom = 0x1C8 # bool
    m_nRandomSeed = 0x1CC # int32_t
    m_bSetNormal = 0x1D0 # bool
    m_bSetRadius = 0x1D1 # bool
    m_flIncrement = 0x1D8 # CParticleCollectionFloatInput
    m_nFullLoopIncrement = 0x330 # CParticleCollectionFloatInput
    m_nSnapShotStartPoint = 0x488 # CParticleCollectionFloatInput
    m_flInterpolation = 0x5E0 # CPerParticleFloatInput

class C_OP_Noise:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_flOutputMin = 0x1C4 # float
    m_flOutputMax = 0x1C8 # float
    m_fl4NoiseScale = 0x1CC # float
    m_bAdditive = 0x1D0 # bool
    m_flNoiseAnimationTimeScale = 0x1D4 # float

class C_OP_NoiseEmitter:
    m_flEmissionDuration = 0x1C0 # float
    m_flStartTime = 0x1C4 # float
    m_flEmissionScale = 0x1C8 # float
    m_nScaleControlPoint = 0x1CC # int32_t
    m_nScaleControlPointField = 0x1D0 # int32_t
    m_nWorldNoisePoint = 0x1D4 # int32_t
    m_bAbsVal = 0x1D8 # bool
    m_bAbsValInv = 0x1D9 # bool
    m_flOffset = 0x1DC # float
    m_flOutputMin = 0x1E0 # float
    m_flOutputMax = 0x1E4 # float
    m_flNoiseScale = 0x1E8 # float
    m_flWorldNoiseScale = 0x1EC # float
    m_vecOffsetLoc = 0x1F0 # Vector
    m_flWorldTimeScale = 0x1FC # float

class C_OP_NormalLock:
    m_nControlPointNumber = 0x1C0 # int32_t

class C_OP_NormalizeVector:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_flScale = 0x1C4 # float

class C_OP_Orient2DRelToCP:
    m_flRotOffset = 0x1C0 # float
    m_flSpinStrength = 0x1C4 # float
    m_nCP = 0x1C8 # int32_t
    m_nFieldOutput = 0x1CC # ParticleAttributeIndex_t

class C_OP_OrientTo2dDirection:
    m_flRotOffset = 0x1C0 # float
    m_flSpinStrength = 0x1C4 # float
    m_nFieldOutput = 0x1C8 # ParticleAttributeIndex_t

class C_OP_OscillateScalar:
    m_RateMin = 0x1C0 # float
    m_RateMax = 0x1C4 # float
    m_FrequencyMin = 0x1C8 # float
    m_FrequencyMax = 0x1CC # float
    m_nField = 0x1D0 # ParticleAttributeIndex_t
    m_bProportional = 0x1D4 # bool
    m_bProportionalOp = 0x1D5 # bool
    m_flStartTime_min = 0x1D8 # float
    m_flStartTime_max = 0x1DC # float
    m_flEndTime_min = 0x1E0 # float
    m_flEndTime_max = 0x1E4 # float
    m_flOscMult = 0x1E8 # float
    m_flOscAdd = 0x1EC # float

class C_OP_OscillateScalarSimple:
    m_Rate = 0x1C0 # float
    m_Frequency = 0x1C4 # float
    m_nField = 0x1C8 # ParticleAttributeIndex_t
    m_flOscMult = 0x1CC # float
    m_flOscAdd = 0x1D0 # float

class C_OP_OscillateVector:
    m_RateMin = 0x1C0 # Vector
    m_RateMax = 0x1CC # Vector
    m_FrequencyMin = 0x1D8 # Vector
    m_FrequencyMax = 0x1E4 # Vector
    m_nField = 0x1F0 # ParticleAttributeIndex_t
    m_bProportional = 0x1F4 # bool
    m_bProportionalOp = 0x1F5 # bool
    m_bOffset = 0x1F6 # bool
    m_flStartTime_min = 0x1F8 # float
    m_flStartTime_max = 0x1FC # float
    m_flEndTime_min = 0x200 # float
    m_flEndTime_max = 0x204 # float
    m_flOscMult = 0x208 # CPerParticleFloatInput
    m_flOscAdd = 0x360 # CPerParticleFloatInput
    m_flRateScale = 0x4B8 # CPerParticleFloatInput

class C_OP_OscillateVectorSimple:
    m_Rate = 0x1C0 # Vector
    m_Frequency = 0x1CC # Vector
    m_nField = 0x1D8 # ParticleAttributeIndex_t
    m_flOscMult = 0x1DC # float
    m_flOscAdd = 0x1E0 # float
    m_bOffset = 0x1E4 # bool

class C_OP_ParentVortices:
    m_flForceScale = 0x1D0 # float
    m_vecTwistAxis = 0x1D4 # Vector
    m_bFlipBasedOnYaw = 0x1E0 # bool

class C_OP_ParticlePhysics:
    m_Gravity = 0x1C0 # CParticleCollectionVecInput
    m_fDrag = 0x818 # CParticleCollectionFloatInput
    m_nMaxConstraintPasses = 0x970 # int32_t

class C_OP_PerParticleForce:
    m_flForceScale = 0x1D0 # CPerParticleFloatInput
    m_vForce = 0x328 # CPerParticleVecInput
    m_nCP = 0x980 # int32_t

class C_OP_PercentageBetweenTransformLerpCPs:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_flInputMin = 0x1C4 # float
    m_flInputMax = 0x1C8 # float
    m_TransformStart = 0x1D0 # CParticleTransformInput
    m_TransformEnd = 0x238 # CParticleTransformInput
    m_nOutputStartCP = 0x2A0 # int32_t
    m_nOutputStartField = 0x2A4 # int32_t
    m_nOutputEndCP = 0x2A8 # int32_t
    m_nOutputEndField = 0x2AC # int32_t
    m_nSetMethod = 0x2B0 # ParticleSetMethod_t
    m_bActiveRange = 0x2B4 # bool
    m_bRadialCheck = 0x2B5 # bool

class C_OP_PercentageBetweenTransforms:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_flInputMin = 0x1C4 # float
    m_flInputMax = 0x1C8 # float
    m_flOutputMin = 0x1CC # float
    m_flOutputMax = 0x1D0 # float
    m_TransformStart = 0x1D8 # CParticleTransformInput
    m_TransformEnd = 0x240 # CParticleTransformInput
    m_nSetMethod = 0x2A8 # ParticleSetMethod_t
    m_bActiveRange = 0x2AC # bool
    m_bRadialCheck = 0x2AD # bool

class C_OP_PercentageBetweenTransformsVector:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_flInputMin = 0x1C4 # float
    m_flInputMax = 0x1C8 # float
    m_vecOutputMin = 0x1CC # Vector
    m_vecOutputMax = 0x1D8 # Vector
    m_TransformStart = 0x1E8 # CParticleTransformInput
    m_TransformEnd = 0x250 # CParticleTransformInput
    m_nSetMethod = 0x2B8 # ParticleSetMethod_t
    m_bActiveRange = 0x2BC # bool
    m_bRadialCheck = 0x2BD # bool

class C_OP_PinParticleToCP:
    m_nControlPointNumber = 0x1C0 # int32_t
    m_vecOffset = 0x1C8 # CParticleCollectionVecInput
    m_bOffsetLocal = 0x820 # bool
    m_nParticleSelection = 0x824 # ParticleSelection_t
    m_nParticleNumber = 0x828 # CParticleCollectionFloatInput
    m_nPinBreakType = 0x980 # ParticlePinDistance_t
    m_flBreakDistance = 0x988 # CParticleCollectionFloatInput
    m_flBreakSpeed = 0xAE0 # CParticleCollectionFloatInput
    m_flAge = 0xC38 # CParticleCollectionFloatInput
    m_nBreakControlPointNumber = 0xD90 # int32_t
    m_nBreakControlPointNumber2 = 0xD94 # int32_t
    m_flBreakValue = 0xD98 # CParticleCollectionFloatInput
    m_flInterpolation = 0xEF0 # CPerParticleFloatInput

class C_OP_PlanarConstraint:
    m_PointOnPlane = 0x1C0 # Vector
    m_PlaneNormal = 0x1CC # Vector
    m_nControlPointNumber = 0x1D8 # int32_t
    m_bGlobalOrigin = 0x1DC # bool
    m_bGlobalNormal = 0x1DD # bool
    m_flRadiusScale = 0x1E0 # CPerParticleFloatInput
    m_flMaximumDistanceToCP = 0x338 # CParticleCollectionFloatInput

class C_OP_PlaneCull:
    m_nPlaneControlPoint = 0x1C0 # int32_t
    m_vecPlaneDirection = 0x1C4 # Vector
    m_bLocalSpace = 0x1D0 # bool
    m_flPlaneOffset = 0x1D4 # float

class C_OP_PlayEndCapWhenFinished:
    m_bFireOnEmissionEnd = 0x1D0 # bool
    m_bIncludeChildren = 0x1D1 # bool

class C_OP_PointVectorAtNextParticle:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_flInterpolation = 0x1C8 # CPerParticleFloatInput

class C_OP_PositionLock:
    m_TransformInput = 0x1C0 # CParticleTransformInput
    m_flStartTime_min = 0x228 # float
    m_flStartTime_max = 0x22C # float
    m_flStartTime_exp = 0x230 # float
    m_flEndTime_min = 0x234 # float
    m_flEndTime_max = 0x238 # float
    m_flEndTime_exp = 0x23C # float
    m_flRange = 0x240 # float
    m_flRangeBias = 0x248 # CParticleCollectionFloatInput
    m_flJumpThreshold = 0x3A0 # float
    m_flPrevPosScale = 0x3A4 # float
    m_bLockRot = 0x3A8 # bool
    m_vecScale = 0x3B0 # CParticleCollectionVecInput
    m_nFieldOutput = 0xA08 # ParticleAttributeIndex_t
    m_nFieldOutputPrev = 0xA0C # ParticleAttributeIndex_t

class C_OP_QuantizeCPComponent:
    m_flInputValue = 0x1D0 # CParticleCollectionFloatInput
    m_nCPOutput = 0x328 # int32_t
    m_nOutVectorField = 0x32C # int32_t
    m_flQuantizeValue = 0x330 # CParticleCollectionFloatInput

class C_OP_QuantizeFloat:
    m_InputValue = 0x1C0 # CPerParticleFloatInput
    m_nOutputField = 0x318 # ParticleAttributeIndex_t

class C_OP_RadiusDecay:
    m_flMinRadius = 0x1C0 # float

class C_OP_RampCPLinearRandom:
    m_nOutControlPointNumber = 0x1D0 # int32_t
    m_vecRateMin = 0x1D4 # Vector
    m_vecRateMax = 0x1E0 # Vector

class C_OP_RampScalarLinear:
    m_RateMin = 0x1C0 # float
    m_RateMax = 0x1C4 # float
    m_flStartTime_min = 0x1C8 # float
    m_flStartTime_max = 0x1CC # float
    m_flEndTime_min = 0x1D0 # float
    m_flEndTime_max = 0x1D4 # float
    m_nField = 0x200 # ParticleAttributeIndex_t
    m_bProportionalOp = 0x204 # bool

class C_OP_RampScalarLinearSimple:
    m_Rate = 0x1C0 # float
    m_flStartTime = 0x1C4 # float
    m_flEndTime = 0x1C8 # float
    m_nField = 0x1F0 # ParticleAttributeIndex_t

class C_OP_RampScalarSpline:
    m_RateMin = 0x1C0 # float
    m_RateMax = 0x1C4 # float
    m_flStartTime_min = 0x1C8 # float
    m_flStartTime_max = 0x1CC # float
    m_flEndTime_min = 0x1D0 # float
    m_flEndTime_max = 0x1D4 # float
    m_flBias = 0x1D8 # float
    m_nField = 0x200 # ParticleAttributeIndex_t
    m_bProportionalOp = 0x204 # bool
    m_bEaseOut = 0x205 # bool

class C_OP_RampScalarSplineSimple:
    m_Rate = 0x1C0 # float
    m_flStartTime = 0x1C4 # float
    m_flEndTime = 0x1C8 # float
    m_nField = 0x1F0 # ParticleAttributeIndex_t
    m_bEaseOut = 0x1F4 # bool

class C_OP_RandomForce:
    m_MinForce = 0x1D0 # Vector
    m_MaxForce = 0x1DC # Vector

class C_OP_ReadFromNeighboringParticle:
    m_nFieldInput = 0x1C0 # ParticleAttributeIndex_t
    m_nFieldOutput = 0x1C4 # ParticleAttributeIndex_t
    m_nIncrement = 0x1C8 # int32_t
    m_DistanceCheck = 0x1D0 # CPerParticleFloatInput
    m_flInterpolation = 0x328 # CPerParticleFloatInput

class C_OP_ReinitializeScalarEndCap:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_flOutputMin = 0x1C4 # float
    m_flOutputMax = 0x1C8 # float

class C_OP_RemapAverageHitboxSpeedtoCP:
    m_nInControlPointNumber = 0x1D0 # int32_t
    m_nOutControlPointNumber = 0x1D4 # int32_t
    m_nField = 0x1D8 # int32_t
    m_nHitboxDataType = 0x1DC # ParticleHitboxDataSelection_t
    m_flInputMin = 0x1E0 # CParticleCollectionFloatInput
    m_flInputMax = 0x338 # CParticleCollectionFloatInput
    m_flOutputMin = 0x490 # CParticleCollectionFloatInput
    m_flOutputMax = 0x5E8 # CParticleCollectionFloatInput
    m_nHeightControlPointNumber = 0x740 # int32_t
    m_vecComparisonVelocity = 0x748 # CParticleCollectionVecInput
    m_HitboxSetName = 0xDA0 # char[128]

class C_OP_RemapAverageScalarValuetoCP:
    m_nOutControlPointNumber = 0x1D0 # int32_t
    m_nOutVectorField = 0x1D4 # int32_t
    m_nField = 0x1D8 # ParticleAttributeIndex_t
    m_flInputMin = 0x1DC # float
    m_flInputMax = 0x1E0 # float
    m_flOutputMin = 0x1E4 # float
    m_flOutputMax = 0x1E8 # float

class C_OP_RemapBoundingVolumetoCP:
    m_nOutControlPointNumber = 0x1D0 # int32_t
    m_flInputMin = 0x1D4 # float
    m_flInputMax = 0x1D8 # float
    m_flOutputMin = 0x1DC # float
    m_flOutputMax = 0x1E0 # float

class C_OP_RemapCPVelocityToVector:
    m_nControlPoint = 0x1C0 # int32_t
    m_nFieldOutput = 0x1C4 # ParticleAttributeIndex_t
    m_flScale = 0x1C8 # float
    m_bNormalize = 0x1CC # bool

class C_OP_RemapCPtoCP:
    m_nInputControlPoint = 0x1D0 # int32_t
    m_nOutputControlPoint = 0x1D4 # int32_t
    m_nInputField = 0x1D8 # int32_t
    m_nOutputField = 0x1DC # int32_t
    m_flInputMin = 0x1E0 # float
    m_flInputMax = 0x1E4 # float
    m_flOutputMin = 0x1E8 # float
    m_flOutputMax = 0x1EC # float
    m_bDerivative = 0x1F0 # bool
    m_flInterpRate = 0x1F4 # float

class C_OP_RemapCPtoScalar:
    m_nCPInput = 0x1C0 # int32_t
    m_nFieldOutput = 0x1C4 # ParticleAttributeIndex_t
    m_nField = 0x1C8 # int32_t
    m_flInputMin = 0x1CC # float
    m_flInputMax = 0x1D0 # float
    m_flOutputMin = 0x1D4 # float
    m_flOutputMax = 0x1D8 # float
    m_flStartTime = 0x1DC # float
    m_flEndTime = 0x1E0 # float
    m_flInterpRate = 0x1E4 # float
    m_nSetMethod = 0x1E8 # ParticleSetMethod_t

class C_OP_RemapCPtoVector:
    m_nCPInput = 0x1C0 # int32_t
    m_nFieldOutput = 0x1C4 # ParticleAttributeIndex_t
    m_nLocalSpaceCP = 0x1C8 # int32_t
    m_vInputMin = 0x1CC # Vector
    m_vInputMax = 0x1D8 # Vector
    m_vOutputMin = 0x1E4 # Vector
    m_vOutputMax = 0x1F0 # Vector
    m_flStartTime = 0x1FC # float
    m_flEndTime = 0x200 # float
    m_flInterpRate = 0x204 # float
    m_nSetMethod = 0x208 # ParticleSetMethod_t
    m_bOffset = 0x20C # bool
    m_bAccelerate = 0x20D # bool

class C_OP_RemapControlPointDirectionToVector:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_flScale = 0x1C4 # float
    m_nControlPointNumber = 0x1C8 # int32_t

class C_OP_RemapControlPointOrientationToRotation:
    m_nCP = 0x1C0 # int32_t
    m_nFieldOutput = 0x1C4 # ParticleAttributeIndex_t
    m_flOffsetRot = 0x1C8 # float
    m_nComponent = 0x1CC # int32_t

class C_OP_RemapCrossProductOfTwoVectorsToVector:
    m_InputVec1 = 0x1C0 # CPerParticleVecInput
    m_InputVec2 = 0x818 # CPerParticleVecInput
    m_nFieldOutput = 0xE70 # ParticleAttributeIndex_t
    m_bNormalize = 0xE74 # bool

class C_OP_RemapDensityGradientToVectorAttribute:
    m_flRadiusScale = 0x1C0 # float
    m_nFieldOutput = 0x1C4 # ParticleAttributeIndex_t

class C_OP_RemapDensityToVector:
    m_flRadiusScale = 0x1C0 # float
    m_nFieldOutput = 0x1C4 # ParticleAttributeIndex_t
    m_flDensityMin = 0x1C8 # float
    m_flDensityMax = 0x1CC # float
    m_vecOutputMin = 0x1D0 # Vector
    m_vecOutputMax = 0x1DC # Vector
    m_bUseParentDensity = 0x1E8 # bool
    m_nVoxelGridResolution = 0x1EC # int32_t

class C_OP_RemapDirectionToCPToVector:
    m_nCP = 0x1C0 # int32_t
    m_nFieldOutput = 0x1C4 # ParticleAttributeIndex_t
    m_flScale = 0x1C8 # float
    m_flOffsetRot = 0x1CC # float
    m_vecOffsetAxis = 0x1D0 # Vector
    m_bNormalize = 0x1DC # bool
    m_nFieldStrength = 0x1E0 # ParticleAttributeIndex_t

class C_OP_RemapDistanceToLineSegmentBase:
    m_nCP0 = 0x1C0 # int32_t
    m_nCP1 = 0x1C4 # int32_t
    m_flMinInputValue = 0x1C8 # float
    m_flMaxInputValue = 0x1CC # float
    m_bInfiniteLine = 0x1D0 # bool

class C_OP_RemapDistanceToLineSegmentToScalar:
    m_nFieldOutput = 0x1E0 # ParticleAttributeIndex_t
    m_flMinOutputValue = 0x1E4 # float
    m_flMaxOutputValue = 0x1E8 # float

class C_OP_RemapDistanceToLineSegmentToVector:
    m_nFieldOutput = 0x1E0 # ParticleAttributeIndex_t
    m_vMinOutputValue = 0x1E4 # Vector
    m_vMaxOutputValue = 0x1F0 # Vector

class C_OP_RemapDotProductToCP:
    m_nInputCP1 = 0x1D0 # int32_t
    m_nInputCP2 = 0x1D4 # int32_t
    m_nOutputCP = 0x1D8 # int32_t
    m_nOutVectorField = 0x1DC # int32_t
    m_flInputMin = 0x1E0 # CParticleCollectionFloatInput
    m_flInputMax = 0x338 # CParticleCollectionFloatInput
    m_flOutputMin = 0x490 # CParticleCollectionFloatInput
    m_flOutputMax = 0x5E8 # CParticleCollectionFloatInput

class C_OP_RemapDotProductToScalar:
    m_nInputCP1 = 0x1C0 # int32_t
    m_nInputCP2 = 0x1C4 # int32_t
    m_nFieldOutput = 0x1C8 # ParticleAttributeIndex_t
    m_flInputMin = 0x1CC # float
    m_flInputMax = 0x1D0 # float
    m_flOutputMin = 0x1D4 # float
    m_flOutputMax = 0x1D8 # float
    m_bUseParticleVelocity = 0x1DC # bool
    m_nSetMethod = 0x1E0 # ParticleSetMethod_t
    m_bActiveRange = 0x1E4 # bool
    m_bUseParticleNormal = 0x1E5 # bool

class C_OP_RemapExternalWindToCP:
    m_nCP = 0x1D0 # int32_t
    m_nCPOutput = 0x1D4 # int32_t
    m_vecScale = 0x1D8 # CParticleCollectionVecInput
    m_bSetMagnitude = 0x830 # bool
    m_nOutVectorField = 0x834 # int32_t

class C_OP_RemapModelVolumetoCP:
    m_nBBoxType = 0x1D0 # BBoxVolumeType_t
    m_nInControlPointNumber = 0x1D4 # int32_t
    m_nOutControlPointNumber = 0x1D8 # int32_t
    m_nOutControlPointMaxNumber = 0x1DC # int32_t
    m_nField = 0x1E0 # int32_t
    m_flInputMin = 0x1E4 # float
    m_flInputMax = 0x1E8 # float
    m_flOutputMin = 0x1EC # float
    m_flOutputMax = 0x1F0 # float

class C_OP_RemapNamedModelElementEndCap:
    m_hModel = 0x1C0 # CStrongHandle<InfoForResourceTypeCModel>
    m_inNames = 0x1C8 # CUtlVector<CUtlString>
    m_outNames = 0x1E0 # CUtlVector<CUtlString>
    m_fallbackNames = 0x1F8 # CUtlVector<CUtlString>
    m_bModelFromRenderer = 0x210 # bool
    m_nFieldInput = 0x214 # ParticleAttributeIndex_t
    m_nFieldOutput = 0x218 # ParticleAttributeIndex_t

class C_OP_RemapNamedModelElementOnceTimed:
    m_hModel = 0x1C0 # CStrongHandle<InfoForResourceTypeCModel>
    m_inNames = 0x1C8 # CUtlVector<CUtlString>
    m_outNames = 0x1E0 # CUtlVector<CUtlString>
    m_fallbackNames = 0x1F8 # CUtlVector<CUtlString>
    m_bModelFromRenderer = 0x210 # bool
    m_bProportional = 0x211 # bool
    m_nFieldInput = 0x214 # ParticleAttributeIndex_t
    m_nFieldOutput = 0x218 # ParticleAttributeIndex_t
    m_flRemapTime = 0x21C # float

class C_OP_RemapParticleCountOnScalarEndCap:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_nInputMin = 0x1C4 # int32_t
    m_nInputMax = 0x1C8 # int32_t
    m_flOutputMin = 0x1CC # float
    m_flOutputMax = 0x1D0 # float
    m_bBackwards = 0x1D4 # bool
    m_nSetMethod = 0x1D8 # ParticleSetMethod_t

class C_OP_RemapParticleCountToScalar:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_nInputMin = 0x1C8 # CParticleCollectionFloatInput
    m_nInputMax = 0x320 # CParticleCollectionFloatInput
    m_flOutputMin = 0x478 # CParticleCollectionFloatInput
    m_flOutputMax = 0x5D0 # CParticleCollectionFloatInput
    m_bActiveRange = 0x728 # bool
    m_nSetMethod = 0x72C # ParticleSetMethod_t

class C_OP_RemapSDFDistanceToScalarAttribute:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_nVectorFieldInput = 0x1C4 # ParticleAttributeIndex_t
    m_flMinDistance = 0x1C8 # CParticleCollectionFloatInput
    m_flMaxDistance = 0x320 # CParticleCollectionFloatInput
    m_flValueBelowMin = 0x478 # CParticleCollectionFloatInput
    m_flValueAtMin = 0x5D0 # CParticleCollectionFloatInput
    m_flValueAtMax = 0x728 # CParticleCollectionFloatInput
    m_flValueAboveMax = 0x880 # CParticleCollectionFloatInput

class C_OP_RemapSDFDistanceToVectorAttribute:
    m_nVectorFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_nVectorFieldInput = 0x1C4 # ParticleAttributeIndex_t
    m_flMinDistance = 0x1C8 # CParticleCollectionFloatInput
    m_flMaxDistance = 0x320 # CParticleCollectionFloatInput
    m_vValueBelowMin = 0x478 # Vector
    m_vValueAtMin = 0x484 # Vector
    m_vValueAtMax = 0x490 # Vector
    m_vValueAboveMax = 0x49C # Vector

class C_OP_RemapSDFGradientToVectorAttribute:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t

class C_OP_RemapScalar:
    m_nFieldInput = 0x1C0 # ParticleAttributeIndex_t
    m_nFieldOutput = 0x1C4 # ParticleAttributeIndex_t
    m_flInputMin = 0x1C8 # float
    m_flInputMax = 0x1CC # float
    m_flOutputMin = 0x1D0 # float
    m_flOutputMax = 0x1D4 # float
    m_bOldCode = 0x1D8 # bool

class C_OP_RemapScalarEndCap:
    m_nFieldInput = 0x1C0 # ParticleAttributeIndex_t
    m_nFieldOutput = 0x1C4 # ParticleAttributeIndex_t
    m_flInputMin = 0x1C8 # float
    m_flInputMax = 0x1CC # float
    m_flOutputMin = 0x1D0 # float
    m_flOutputMax = 0x1D4 # float

class C_OP_RemapScalarOnceTimed:
    m_bProportional = 0x1C0 # bool
    m_nFieldInput = 0x1C4 # ParticleAttributeIndex_t
    m_nFieldOutput = 0x1C8 # ParticleAttributeIndex_t
    m_flInputMin = 0x1CC # float
    m_flInputMax = 0x1D0 # float
    m_flOutputMin = 0x1D4 # float
    m_flOutputMax = 0x1D8 # float
    m_flRemapTime = 0x1DC # float

class C_OP_RemapSpeed:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_flInputMin = 0x1C4 # float
    m_flInputMax = 0x1C8 # float
    m_flOutputMin = 0x1CC # float
    m_flOutputMax = 0x1D0 # float
    m_nSetMethod = 0x1D4 # ParticleSetMethod_t
    m_bIgnoreDelta = 0x1D8 # bool

class C_OP_RemapSpeedtoCP:
    m_nInControlPointNumber = 0x1D0 # int32_t
    m_nOutControlPointNumber = 0x1D4 # int32_t
    m_nField = 0x1D8 # int32_t
    m_flInputMin = 0x1DC # float
    m_flInputMax = 0x1E0 # float
    m_flOutputMin = 0x1E4 # float
    m_flOutputMax = 0x1E8 # float
    m_bUseDeltaV = 0x1EC # bool

class C_OP_RemapTransformOrientationToRotations:
    m_TransformInput = 0x1C0 # CParticleTransformInput
    m_vecRotation = 0x228 # Vector
    m_bUseQuat = 0x234 # bool
    m_bWriteNormal = 0x235 # bool

class C_OP_RemapTransformOrientationToYaw:
    m_TransformInput = 0x1C0 # CParticleTransformInput
    m_nFieldOutput = 0x228 # ParticleAttributeIndex_t
    m_flRotOffset = 0x22C # float
    m_flSpinStrength = 0x230 # float

class C_OP_RemapTransformToVelocity:
    m_TransformInput = 0x1C0 # CParticleTransformInput

class C_OP_RemapTransformVisibilityToScalar:
    m_nSetMethod = 0x1C0 # ParticleSetMethod_t
    m_TransformInput = 0x1C8 # CParticleTransformInput
    m_nFieldOutput = 0x230 # ParticleAttributeIndex_t
    m_flInputMin = 0x234 # float
    m_flInputMax = 0x238 # float
    m_flOutputMin = 0x23C # float
    m_flOutputMax = 0x240 # float
    m_flRadius = 0x244 # float

class C_OP_RemapTransformVisibilityToVector:
    m_nSetMethod = 0x1C0 # ParticleSetMethod_t
    m_TransformInput = 0x1C8 # CParticleTransformInput
    m_nFieldOutput = 0x230 # ParticleAttributeIndex_t
    m_flInputMin = 0x234 # float
    m_flInputMax = 0x238 # float
    m_vecOutputMin = 0x23C # Vector
    m_vecOutputMax = 0x248 # Vector
    m_flRadius = 0x254 # float

class C_OP_RemapVectorComponentToScalar:
    m_nFieldInput = 0x1C0 # ParticleAttributeIndex_t
    m_nFieldOutput = 0x1C4 # ParticleAttributeIndex_t
    m_nComponent = 0x1C8 # int32_t

class C_OP_RemapVectortoCP:
    m_nOutControlPointNumber = 0x1C0 # int32_t
    m_nFieldInput = 0x1C4 # ParticleAttributeIndex_t
    m_nParticleNumber = 0x1C8 # int32_t

class C_OP_RemapVelocityToVector:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_flScale = 0x1C4 # float
    m_bNormalize = 0x1C8 # bool

class C_OP_RemapVisibilityScalar:
    m_nFieldInput = 0x1C0 # ParticleAttributeIndex_t
    m_nFieldOutput = 0x1C4 # ParticleAttributeIndex_t
    m_flInputMin = 0x1C8 # float
    m_flInputMax = 0x1CC # float
    m_flOutputMin = 0x1D0 # float
    m_flOutputMax = 0x1D4 # float
    m_flRadiusScale = 0x1D8 # float

class C_OP_RenderAsModels:
    m_ModelList = 0x200 # CUtlVector<ModelReference_t>
    m_flModelScale = 0x21C # float
    m_bFitToModelSize = 0x220 # bool
    m_bNonUniformScaling = 0x221 # bool
    m_nXAxisScalingAttribute = 0x224 # ParticleAttributeIndex_t
    m_nYAxisScalingAttribute = 0x228 # ParticleAttributeIndex_t
    m_nZAxisScalingAttribute = 0x22C # ParticleAttributeIndex_t
    m_nSizeCullBloat = 0x230 # int32_t

class C_OP_RenderBlobs:
    m_cubeWidth = 0x200 # CParticleCollectionRendererFloatInput
    m_cutoffRadius = 0x358 # CParticleCollectionRendererFloatInput
    m_renderRadius = 0x4B0 # CParticleCollectionRendererFloatInput
    m_nScaleCP = 0x608 # int32_t
    m_MaterialVars = 0x610 # CUtlVector<MaterialVariable_t>
    m_hMaterial = 0x640 # CStrongHandle<InfoForResourceTypeIMaterial2>

class C_OP_RenderCables:
    m_flRadiusScale = 0x200 # CParticleCollectionFloatInput
    m_flAlphaScale = 0x358 # CParticleCollectionFloatInput
    m_vecColorScale = 0x4B0 # CParticleCollectionVecInput
    m_nColorBlendType = 0xB08 # ParticleColorBlendType_t
    m_hMaterial = 0xB10 # CStrongHandle<InfoForResourceTypeIMaterial2>
    m_nTextureRepetitionMode = 0xB18 # TextureRepetitionMode_t
    m_flTextureRepeatsPerSegment = 0xB20 # CParticleCollectionFloatInput
    m_flTextureRepeatsCircumference = 0xC78 # CParticleCollectionFloatInput
    m_flColorMapOffsetV = 0xDD0 # CParticleCollectionFloatInput
    m_flColorMapOffsetU = 0xF28 # CParticleCollectionFloatInput
    m_flNormalMapOffsetV = 0x1080 # CParticleCollectionFloatInput
    m_flNormalMapOffsetU = 0x11D8 # CParticleCollectionFloatInput
    m_bDrawCableCaps = 0x1330 # bool
    m_flCapRoundness = 0x1334 # float
    m_flCapOffsetAmount = 0x1338 # float
    m_flTessScale = 0x133C # float
    m_nMinTesselation = 0x1340 # int32_t
    m_nMaxTesselation = 0x1344 # int32_t
    m_nRoundness = 0x1348 # int32_t
    m_LightingTransform = 0x1350 # CParticleTransformInput
    m_MaterialFloatVars = 0x13B8 # CUtlVector<FloatInputMaterialVariable_t>
    m_MaterialVecVars = 0x13E8 # CUtlVector<VecInputMaterialVariable_t>

class C_OP_RenderDeferredLight:
    m_bUseAlphaTestWindow = 0x200 # bool
    m_bUseTexture = 0x201 # bool
    m_flRadiusScale = 0x204 # float
    m_flAlphaScale = 0x208 # float
    m_nAlpha2Field = 0x20C # ParticleAttributeIndex_t
    m_vecColorScale = 0x210 # CParticleCollectionVecInput
    m_nColorBlendType = 0x868 # ParticleColorBlendType_t
    m_flLightDistance = 0x86C # float
    m_flStartFalloff = 0x870 # float
    m_flDistanceFalloff = 0x874 # float
    m_flSpotFoV = 0x878 # float
    m_nAlphaTestPointField = 0x87C # ParticleAttributeIndex_t
    m_nAlphaTestRangeField = 0x880 # ParticleAttributeIndex_t
    m_nAlphaTestSharpnessField = 0x884 # ParticleAttributeIndex_t
    m_hTexture = 0x888 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_nHSVShiftControlPoint = 0x890 # int32_t

class C_OP_RenderFlattenGrass:
    m_flFlattenStrength = 0x200 # float
    m_nStrengthFieldOverride = 0x204 # ParticleAttributeIndex_t
    m_flRadiusScale = 0x208 # float

class C_OP_RenderGpuImplicit:
    m_bUsePerParticleRadius = 0x200 # bool
    m_fGridSize = 0x208 # CParticleCollectionRendererFloatInput
    m_fRadiusScale = 0x360 # CParticleCollectionRendererFloatInput
    m_fIsosurfaceThreshold = 0x4B8 # CParticleCollectionRendererFloatInput
    m_nScaleCP = 0x610 # int32_t
    m_hMaterial = 0x618 # CStrongHandle<InfoForResourceTypeIMaterial2>

class C_OP_RenderLightBeam:
    m_vColorBlend = 0x200 # CParticleCollectionVecInput
    m_nColorBlendType = 0x858 # ParticleColorBlendType_t
    m_flBrightnessLumensPerMeter = 0x860 # CParticleCollectionFloatInput
    m_bCastShadows = 0x9B8 # bool
    m_flSkirt = 0x9C0 # CParticleCollectionFloatInput
    m_flRange = 0xB18 # CParticleCollectionFloatInput
    m_flThickness = 0xC70 # CParticleCollectionFloatInput

class C_OP_RenderLights:
    m_flAnimationRate = 0x210 # float
    m_nAnimationType = 0x214 # AnimationType_t
    m_bAnimateInFPS = 0x218 # bool
    m_flMinSize = 0x21C # float
    m_flMaxSize = 0x220 # float
    m_flStartFadeSize = 0x224 # float
    m_flEndFadeSize = 0x228 # float

class C_OP_RenderMaterialProxy:
    m_nMaterialControlPoint = 0x200 # int32_t
    m_nProxyType = 0x204 # MaterialProxyType_t
    m_MaterialVars = 0x208 # CUtlVector<MaterialVariable_t>
    m_hOverrideMaterial = 0x220 # CStrongHandle<InfoForResourceTypeIMaterial2>
    m_flMaterialOverrideEnabled = 0x228 # CParticleCollectionFloatInput
    m_vecColorScale = 0x380 # CParticleCollectionVecInput
    m_flAlpha = 0x9D8 # CPerParticleFloatInput
    m_nColorBlendType = 0xB30 # ParticleColorBlendType_t

class C_OP_RenderModels:
    m_bOnlyRenderInEffectsBloomPass = 0x200 # bool
    m_bOnlyRenderInEffectsWaterPass = 0x201 # bool
    m_bUseMixedResolutionRendering = 0x202 # bool
    m_bOnlyRenderInEffecsGameOverlay = 0x203 # bool
    m_ModelList = 0x208 # CUtlVector<ModelReference_t>
    m_nBodyGroupField = 0x224 # ParticleAttributeIndex_t
    m_nSubModelField = 0x228 # ParticleAttributeIndex_t
    m_bIgnoreNormal = 0x22C # bool
    m_bOrientZ = 0x22D # bool
    m_bCenterOffset = 0x22E # bool
    m_vecLocalOffset = 0x230 # CPerParticleVecInput
    m_vecLocalRotation = 0x888 # CPerParticleVecInput
    m_bIgnoreRadius = 0xEE0 # bool
    m_nModelScaleCP = 0xEE4 # int32_t
    m_vecComponentScale = 0xEE8 # CPerParticleVecInput
    m_bLocalScale = 0x1540 # bool
    m_nSizeCullBloat = 0x1544 # int32_t
    m_bAnimated = 0x1548 # bool
    m_flAnimationRate = 0x154C # float
    m_bScaleAnimationRate = 0x1550 # bool
    m_bForceLoopingAnimation = 0x1551 # bool
    m_bResetAnimOnStop = 0x1552 # bool
    m_bManualAnimFrame = 0x1553 # bool
    m_nAnimationScaleField = 0x1554 # ParticleAttributeIndex_t
    m_nAnimationField = 0x1558 # ParticleAttributeIndex_t
    m_nManualFrameField = 0x155C # ParticleAttributeIndex_t
    m_ActivityName = 0x1560 # char[256]
    m_SequenceName = 0x1660 # char[256]
    m_bEnableClothSimulation = 0x1760 # bool
    m_hOverrideMaterial = 0x1768 # CStrongHandle<InfoForResourceTypeIMaterial2>
    m_bOverrideTranslucentMaterials = 0x1770 # bool
    m_nSkin = 0x1778 # CPerParticleFloatInput
    m_MaterialVars = 0x18D0 # CUtlVector<MaterialVariable_t>
    m_modelInput = 0x18E8 # CParticleModelInput
    m_nLOD = 0x1948 # int32_t
    m_EconSlotName = 0x194C # char[256]
    m_bOriginalModel = 0x1A4C # bool
    m_bSuppressTint = 0x1A4D # bool
    m_bUseRawMeshGroup = 0x1A4E # bool
    m_bDisableShadows = 0x1A4F # bool
    m_bAcceptsDecals = 0x1A50 # bool
    m_bForceDrawInterlevedWithSiblings = 0x1A51 # bool
    m_bDoNotDrawInParticlePass = 0x1A52 # bool
    m_szRenderAttribute = 0x1A53 # char[260]
    m_flRadiusScale = 0x1B58 # CParticleCollectionFloatInput
    m_flAlphaScale = 0x1CB0 # CParticleCollectionFloatInput
    m_flRollScale = 0x1E08 # CParticleCollectionFloatInput
    m_nAlpha2Field = 0x1F60 # ParticleAttributeIndex_t
    m_vecColorScale = 0x1F68 # CParticleCollectionVecInput
    m_nColorBlendType = 0x25C0 # ParticleColorBlendType_t

class C_OP_RenderOmni2Light:
    m_nLightType = 0x200 # ParticleOmni2LightTypeChoiceList_t
    m_vColorBlend = 0x208 # CParticleCollectionVecInput
    m_nColorBlendType = 0x860 # ParticleColorBlendType_t
    m_nBrightnessUnit = 0x864 # ParticleLightUnitChoiceList_t
    m_flBrightnessLumens = 0x868 # CPerParticleFloatInput
    m_flBrightnessCandelas = 0x9C0 # CPerParticleFloatInput
    m_bCastShadows = 0xB18 # bool
    m_flLuminaireRadius = 0xB20 # CPerParticleFloatInput
    m_flSkirt = 0xC78 # CPerParticleFloatInput
    m_flRange = 0xDD0 # CPerParticleFloatInput
    m_flInnerConeAngle = 0xF28 # CPerParticleFloatInput
    m_flOuterConeAngle = 0x1080 # CPerParticleFloatInput
    m_hLightCookie = 0x11D8 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_bSphericalCookie = 0x11E0 # bool

class C_OP_RenderPoints:
    m_hMaterial = 0x200 # CStrongHandle<InfoForResourceTypeIMaterial2>

class C_OP_RenderPostProcessing:
    m_flPostProcessStrength = 0x200 # CPerParticleFloatInput
    m_hPostTexture = 0x358 # CStrongHandle<InfoForResourceTypeCPostProcessingResource>
    m_nPriority = 0x360 # ParticlePostProcessPriorityGroup_t

class C_OP_RenderProjected:
    m_bProjectCharacter = 0x200 # bool
    m_bProjectWorld = 0x201 # bool
    m_bProjectWater = 0x202 # bool
    m_bFlipHorizontal = 0x203 # bool
    m_bEnableProjectedDepthControls = 0x204 # bool
    m_flMinProjectionDepth = 0x208 # float
    m_flMaxProjectionDepth = 0x20C # float
    m_hProjectedMaterial = 0x210 # CStrongHandle<InfoForResourceTypeIMaterial2>
    m_flAnimationTimeScale = 0x218 # float
    m_bOrientToNormal = 0x21C # bool
    m_MaterialVars = 0x220 # CUtlVector<MaterialVariable_t>

class C_OP_RenderRopes:
    m_bEnableFadingAndClamping = 0x2470 # bool
    m_flMinSize = 0x2474 # float
    m_flMaxSize = 0x2478 # float
    m_flStartFadeSize = 0x247C # float
    m_flEndFadeSize = 0x2480 # float
    m_flStartFadeDot = 0x2484 # float
    m_flEndFadeDot = 0x2488 # float
    m_flRadiusTaper = 0x248C # float
    m_nMinTesselation = 0x2490 # int32_t
    m_nMaxTesselation = 0x2494 # int32_t
    m_flTessScale = 0x2498 # float
    m_flTextureVWorldSize = 0x24A0 # CParticleCollectionRendererFloatInput
    m_flTextureVScrollRate = 0x25F8 # CParticleCollectionRendererFloatInput
    m_flTextureVOffset = 0x2750 # CParticleCollectionRendererFloatInput
    m_nTextureVParamsCP = 0x28A8 # int32_t
    m_bClampV = 0x28AC # bool
    m_nScaleCP1 = 0x28B0 # int32_t
    m_nScaleCP2 = 0x28B4 # int32_t
    m_flScaleVSizeByControlPointDistance = 0x28B8 # float
    m_flScaleVScrollByControlPointDistance = 0x28BC # float
    m_flScaleVOffsetByControlPointDistance = 0x28C0 # float
    m_bUseScalarForTextureCoordinate = 0x28C5 # bool
    m_nScalarFieldForTextureCoordinate = 0x28C8 # ParticleAttributeIndex_t
    m_flScalarAttributeTextureCoordScale = 0x28CC # float
    m_bReverseOrder = 0x28D0 # bool
    m_bClosedLoop = 0x28D1 # bool
    m_nOrientationType = 0x28D4 # ParticleOrientationChoiceList_t
    m_nVectorFieldForOrientation = 0x28D8 # ParticleAttributeIndex_t
    m_bDrawAsOpaque = 0x28DC # bool
    m_bGenerateNormals = 0x28DD # bool

class C_OP_RenderScreenShake:
    m_flDurationScale = 0x200 # float
    m_flRadiusScale = 0x204 # float
    m_flFrequencyScale = 0x208 # float
    m_flAmplitudeScale = 0x20C # float
    m_nRadiusField = 0x210 # ParticleAttributeIndex_t
    m_nDurationField = 0x214 # ParticleAttributeIndex_t
    m_nFrequencyField = 0x218 # ParticleAttributeIndex_t
    m_nAmplitudeField = 0x21C # ParticleAttributeIndex_t
    m_nFilterCP = 0x220 # int32_t

class C_OP_RenderScreenVelocityRotate:
    m_flRotateRateDegrees = 0x200 # float
    m_flForwardDegrees = 0x204 # float

class C_OP_RenderSound:
    m_flDurationScale = 0x200 # float
    m_flSndLvlScale = 0x204 # float
    m_flPitchScale = 0x208 # float
    m_flVolumeScale = 0x20C # float
    m_nSndLvlField = 0x210 # ParticleAttributeIndex_t
    m_nDurationField = 0x214 # ParticleAttributeIndex_t
    m_nPitchField = 0x218 # ParticleAttributeIndex_t
    m_nVolumeField = 0x21C # ParticleAttributeIndex_t
    m_nChannel = 0x220 # int32_t
    m_nCPReference = 0x224 # int32_t
    m_pszSoundName = 0x228 # char[256]
    m_bSuppressStopSoundEvent = 0x328 # bool

class C_OP_RenderSprites:
    m_nSequenceOverride = 0x2470 # CParticleCollectionRendererFloatInput
    m_nOrientationType = 0x25C8 # ParticleOrientationChoiceList_t
    m_nOrientationControlPoint = 0x25CC # int32_t
    m_bUseYawWithNormalAligned = 0x25D0 # bool
    m_flMinSize = 0x25D4 # float
    m_flMaxSize = 0x25D8 # float
    m_flAlphaAdjustWithSizeAdjust = 0x25DC # float
    m_flStartFadeSize = 0x25E0 # CParticleCollectionRendererFloatInput
    m_flEndFadeSize = 0x2738 # CParticleCollectionRendererFloatInput
    m_flStartFadeDot = 0x2890 # float
    m_flEndFadeDot = 0x2894 # float
    m_bDistanceAlpha = 0x2898 # bool
    m_bSoftEdges = 0x2899 # bool
    m_flEdgeSoftnessStart = 0x289C # float
    m_flEdgeSoftnessEnd = 0x28A0 # float
    m_bOutline = 0x28A4 # bool
    m_OutlineColor = 0x28A5 # Color
    m_nOutlineAlpha = 0x28AC # int32_t
    m_flOutlineStart0 = 0x28B0 # float
    m_flOutlineStart1 = 0x28B4 # float
    m_flOutlineEnd0 = 0x28B8 # float
    m_flOutlineEnd1 = 0x28BC # float
    m_nLightingMode = 0x28C0 # ParticleLightingQuality_t
    m_flLightingTessellation = 0x28C8 # CParticleCollectionRendererFloatInput
    m_flLightingDirectionality = 0x2A20 # CParticleCollectionRendererFloatInput
    m_bParticleShadows = 0x2B78 # bool
    m_flShadowDensity = 0x2B7C # float

class C_OP_RenderStandardLight:
    m_nLightType = 0x200 # ParticleLightTypeChoiceList_t
    m_vecColorScale = 0x208 # CParticleCollectionVecInput
    m_nColorBlendType = 0x860 # ParticleColorBlendType_t
    m_flIntensity = 0x868 # CParticleCollectionFloatInput
    m_bCastShadows = 0x9C0 # bool
    m_flTheta = 0x9C8 # CParticleCollectionFloatInput
    m_flPhi = 0xB20 # CParticleCollectionFloatInput
    m_flRadiusMultiplier = 0xC78 # CParticleCollectionFloatInput
    m_nAttenuationStyle = 0xDD0 # StandardLightingAttenuationStyle_t
    m_flFalloffLinearity = 0xDD8 # CParticleCollectionFloatInput
    m_flFiftyPercentFalloff = 0xF30 # CParticleCollectionFloatInput
    m_flZeroPercentFalloff = 0x1088 # CParticleCollectionFloatInput
    m_bRenderDiffuse = 0x11E0 # bool
    m_bRenderSpecular = 0x11E1 # bool
    m_lightCookie = 0x11E8 # CUtlString
    m_nPriority = 0x11F0 # int32_t
    m_nFogLightingMode = 0x11F4 # ParticleLightFogLightingMode_t
    m_flFogContribution = 0x11F8 # CParticleCollectionRendererFloatInput
    m_nCapsuleLightBehavior = 0x1350 # ParticleLightBehaviorChoiceList_t
    m_flCapsuleLength = 0x1354 # float
    m_bReverseOrder = 0x1358 # bool
    m_bClosedLoop = 0x1359 # bool
    m_nPrevPntSource = 0x135C # ParticleAttributeIndex_t
    m_flMaxLength = 0x1360 # float
    m_flMinLength = 0x1364 # float
    m_bIgnoreDT = 0x1368 # bool
    m_flConstrainRadiusToLengthRatio = 0x136C # float
    m_flLengthScale = 0x1370 # float
    m_flLengthFadeInTime = 0x1374 # float

class C_OP_RenderStatusEffect:
    m_pTextureColorWarp = 0x200 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_pTextureDetail2 = 0x208 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_pTextureDiffuseWarp = 0x210 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_pTextureFresnelColorWarp = 0x218 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_pTextureFresnelWarp = 0x220 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_pTextureSpecularWarp = 0x228 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_pTextureEnvMap = 0x230 # CStrongHandle<InfoForResourceTypeCTextureBase>

class C_OP_RenderStatusEffectCitadel:
    m_pTextureColorWarp = 0x200 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_pTextureNormal = 0x208 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_pTextureMetalness = 0x210 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_pTextureRoughness = 0x218 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_pTextureSelfIllum = 0x220 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_pTextureDetail = 0x228 # CStrongHandle<InfoForResourceTypeCTextureBase>

class C_OP_RenderText:
    m_OutlineColor = 0x200 # Color
    m_DefaultText = 0x208 # CUtlString

class C_OP_RenderTonemapController:
    m_flTonemapLevel = 0x200 # float
    m_flTonemapWeight = 0x204 # float
    m_nTonemapLevelField = 0x208 # ParticleAttributeIndex_t
    m_nTonemapWeightField = 0x20C # ParticleAttributeIndex_t

class C_OP_RenderTrails:
    m_bEnableFadingAndClamping = 0x2740 # bool
    m_flStartFadeDot = 0x2744 # float
    m_flEndFadeDot = 0x2748 # float
    m_nPrevPntSource = 0x274C # ParticleAttributeIndex_t
    m_flMaxLength = 0x2750 # float
    m_flMinLength = 0x2754 # float
    m_bIgnoreDT = 0x2758 # bool
    m_flConstrainRadiusToLengthRatio = 0x275C # float
    m_flLengthScale = 0x2760 # float
    m_flLengthFadeInTime = 0x2764 # float
    m_flRadiusHeadTaper = 0x2768 # CPerParticleFloatInput
    m_vecHeadColorScale = 0x28C0 # CParticleCollectionVecInput
    m_flHeadAlphaScale = 0x2F18 # CPerParticleFloatInput
    m_flRadiusTaper = 0x3070 # CPerParticleFloatInput
    m_vecTailColorScale = 0x31C8 # CParticleCollectionVecInput
    m_flTailAlphaScale = 0x3820 # CPerParticleFloatInput
    m_nHorizCropField = 0x3978 # ParticleAttributeIndex_t
    m_nVertCropField = 0x397C # ParticleAttributeIndex_t
    m_flForwardShift = 0x3980 # float
    m_bFlipUVBasedOnPitchYaw = 0x3984 # bool

class C_OP_RenderTreeShake:
    m_flPeakStrength = 0x200 # float
    m_nPeakStrengthFieldOverride = 0x204 # ParticleAttributeIndex_t
    m_flRadius = 0x208 # float
    m_nRadiusFieldOverride = 0x20C # ParticleAttributeIndex_t
    m_flShakeDuration = 0x210 # float
    m_flTransitionTime = 0x214 # float
    m_flTwistAmount = 0x218 # float
    m_flRadialAmount = 0x21C # float
    m_flControlPointOrientationAmount = 0x220 # float
    m_nControlPointForLinearDirection = 0x224 # int32_t

class C_OP_RenderVRHapticEvent:
    m_nHand = 0x200 # ParticleVRHandChoiceList_t
    m_nOutputHandCP = 0x204 # int32_t
    m_nOutputField = 0x208 # int32_t
    m_flAmplitude = 0x210 # CPerParticleFloatInput

class C_OP_RepeatedTriggerChildGroup:
    m_nChildGroupID = 0x1D0 # int32_t
    m_flClusterRefireTime = 0x1D8 # CParticleCollectionFloatInput
    m_flClusterSize = 0x330 # CParticleCollectionFloatInput
    m_flClusterCooldown = 0x488 # CParticleCollectionFloatInput
    m_bLimitChildCount = 0x5E0 # bool

class C_OP_RestartAfterDuration:
    m_flDurationMin = 0x1C0 # float
    m_flDurationMax = 0x1C4 # float
    m_nCP = 0x1C8 # int32_t
    m_nCPField = 0x1CC # int32_t
    m_nChildGroupID = 0x1D0 # int32_t
    m_bOnlyChildren = 0x1D4 # bool

class C_OP_RopeSpringConstraint:
    m_flRestLength = 0x1C0 # CParticleCollectionFloatInput
    m_flMinDistance = 0x318 # CParticleCollectionFloatInput
    m_flMaxDistance = 0x470 # CParticleCollectionFloatInput
    m_flAdjustmentScale = 0x5C8 # float
    m_flInitialRestingLength = 0x5D0 # CParticleCollectionFloatInput

class C_OP_RotateVector:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_vecRotAxisMin = 0x1C4 # Vector
    m_vecRotAxisMax = 0x1D0 # Vector
    m_flRotRateMin = 0x1DC # float
    m_flRotRateMax = 0x1E0 # float
    m_bNormalize = 0x1E4 # bool
    m_flScale = 0x1E8 # CPerParticleFloatInput

class C_OP_RtEnvCull:
    m_vecTestDir = 0x1C0 # Vector
    m_vecTestNormal = 0x1CC # Vector
    m_bCullOnMiss = 0x1D8 # bool
    m_bStickInsteadOfCull = 0x1D9 # bool
    m_RtEnvName = 0x1DA # char[128]
    m_nRTEnvCP = 0x25C # int32_t
    m_nComponent = 0x260 # int32_t

class C_OP_SDFConstraint:
    m_flMinDist = 0x1C0 # CParticleCollectionFloatInput
    m_flMaxDist = 0x318 # CParticleCollectionFloatInput
    m_nMaxIterations = 0x470 # int32_t

class C_OP_SDFForce:
    m_flForceScale = 0x1D0 # float

class C_OP_SDFLighting:
    m_vLightingDir = 0x1C0 # Vector
    m_vTint_0 = 0x1CC # Vector
    m_vTint_1 = 0x1D8 # Vector

class C_OP_SelectivelyEnableChildren:
    m_nChildGroupID = 0x1D0 # CParticleCollectionFloatInput
    m_nFirstChild = 0x328 # CParticleCollectionFloatInput
    m_nNumChildrenToEnable = 0x480 # CParticleCollectionFloatInput
    m_bPlayEndcapOnStop = 0x5D8 # bool
    m_bDestroyImmediately = 0x5D9 # bool

class C_OP_SequenceFromModel:
    m_nControlPointNumber = 0x1C0 # int32_t
    m_nFieldOutput = 0x1C4 # ParticleAttributeIndex_t
    m_nFieldOutputAnim = 0x1C8 # ParticleAttributeIndex_t
    m_flInputMin = 0x1CC # float
    m_flInputMax = 0x1D0 # float
    m_flOutputMin = 0x1D4 # float
    m_flOutputMax = 0x1D8 # float
    m_nSetMethod = 0x1DC # ParticleSetMethod_t

class C_OP_SetAttributeToScalarExpression:
    m_nExpression = 0x1C0 # ScalarExpressionType_t
    m_flInput1 = 0x1C8 # CPerParticleFloatInput
    m_flInput2 = 0x320 # CPerParticleFloatInput
    m_nOutputField = 0x478 # ParticleAttributeIndex_t
    m_nSetMethod = 0x47C # ParticleSetMethod_t

class C_OP_SetCPOrientationToDirection:
    m_nInputControlPoint = 0x1C0 # int32_t
    m_nOutputControlPoint = 0x1C4 # int32_t

class C_OP_SetCPOrientationToGroundNormal:
    m_flInterpRate = 0x1C0 # float
    m_flMaxTraceLength = 0x1C4 # float
    m_flTolerance = 0x1C8 # float
    m_flTraceOffset = 0x1CC # float
    m_CollisionGroupName = 0x1D0 # char[128]
    m_nTraceSet = 0x250 # ParticleTraceSet_t
    m_nInputCP = 0x254 # int32_t
    m_nOutputCP = 0x258 # int32_t
    m_bIncludeWater = 0x268 # bool

class C_OP_SetCPOrientationToPointAtCP:
    m_nInputCP = 0x1D0 # int32_t
    m_nOutputCP = 0x1D4 # int32_t
    m_flInterpolation = 0x1D8 # CParticleCollectionFloatInput
    m_b2DOrientation = 0x330 # bool
    m_bAvoidSingularity = 0x331 # bool
    m_bPointAway = 0x332 # bool

class C_OP_SetCPtoVector:
    m_nCPInput = 0x1C0 # int32_t
    m_nFieldOutput = 0x1C4 # ParticleAttributeIndex_t

class C_OP_SetChildControlPoints:
    m_nChildGroupID = 0x1C0 # int32_t
    m_nFirstControlPoint = 0x1C4 # int32_t
    m_nNumControlPoints = 0x1C8 # int32_t
    m_nFirstSourcePoint = 0x1D0 # CParticleCollectionFloatInput
    m_bReverse = 0x328 # bool
    m_bSetOrientation = 0x329 # bool

class C_OP_SetControlPointFieldFromVectorExpression:
    m_nExpression = 0x1D0 # VectorFloatExpressionType_t
    m_vecInput1 = 0x1D8 # CParticleCollectionVecInput
    m_vecInput2 = 0x830 # CParticleCollectionVecInput
    m_flOutputRemap = 0xE88 # CParticleRemapFloatInput
    m_nOutputCP = 0xFE0 # int32_t
    m_nOutVectorField = 0xFE4 # int32_t

class C_OP_SetControlPointFieldToScalarExpression:
    m_nExpression = 0x1D0 # ScalarExpressionType_t
    m_flInput1 = 0x1D8 # CParticleCollectionFloatInput
    m_flInput2 = 0x330 # CParticleCollectionFloatInput
    m_flOutputRemap = 0x488 # CParticleRemapFloatInput
    m_nOutputCP = 0x5E0 # int32_t
    m_nOutVectorField = 0x5E4 # int32_t

class C_OP_SetControlPointFieldToWater:
    m_nSourceCP = 0x1D0 # int32_t
    m_nDestCP = 0x1D4 # int32_t
    m_nCPField = 0x1D8 # int32_t

class C_OP_SetControlPointFromObjectScale:
    m_nCPInput = 0x1D0 # int32_t
    m_nCPOutput = 0x1D4 # int32_t

class C_OP_SetControlPointOrientation:
    m_bUseWorldLocation = 0x1D0 # bool
    m_bRandomize = 0x1D2 # bool
    m_bSetOnce = 0x1D3 # bool
    m_nCP = 0x1D4 # int32_t
    m_nHeadLocation = 0x1D8 # int32_t
    m_vecRotation = 0x1DC # QAngle
    m_vecRotationB = 0x1E8 # QAngle
    m_flInterpolation = 0x1F8 # CParticleCollectionFloatInput

class C_OP_SetControlPointOrientationToCPVelocity:
    m_nCPInput = 0x1D0 # int32_t
    m_nCPOutput = 0x1D4 # int32_t

class C_OP_SetControlPointPositionToRandomActiveCP:
    m_nCP1 = 0x1D0 # int32_t
    m_nHeadLocationMin = 0x1D4 # int32_t
    m_nHeadLocationMax = 0x1D8 # int32_t
    m_flResetRate = 0x1E0 # CParticleCollectionFloatInput

class C_OP_SetControlPointPositionToTimeOfDayValue:
    m_nControlPointNumber = 0x1D0 # int32_t
    m_pszTimeOfDayParameter = 0x1D4 # char[128]
    m_vecDefaultValue = 0x254 # Vector

class C_OP_SetControlPointPositions:
    m_bUseWorldLocation = 0x1D0 # bool
    m_bOrient = 0x1D1 # bool
    m_bSetOnce = 0x1D2 # bool
    m_nCP1 = 0x1D4 # int32_t
    m_nCP2 = 0x1D8 # int32_t
    m_nCP3 = 0x1DC # int32_t
    m_nCP4 = 0x1E0 # int32_t
    m_vecCP1Pos = 0x1E4 # Vector
    m_vecCP2Pos = 0x1F0 # Vector
    m_vecCP3Pos = 0x1FC # Vector
    m_vecCP4Pos = 0x208 # Vector
    m_nHeadLocation = 0x214 # int32_t

class C_OP_SetControlPointRotation:
    m_vecRotAxis = 0x1D0 # CParticleCollectionVecInput
    m_flRotRate = 0x828 # CParticleCollectionFloatInput
    m_nCP = 0x980 # int32_t
    m_nLocalCP = 0x984 # int32_t

class C_OP_SetControlPointToCPVelocity:
    m_nCPInput = 0x1D0 # int32_t
    m_nCPOutputVel = 0x1D4 # int32_t
    m_bNormalize = 0x1D8 # bool
    m_nCPOutputMag = 0x1DC # int32_t
    m_nCPField = 0x1E0 # int32_t
    m_vecComparisonVelocity = 0x1E8 # CParticleCollectionVecInput

class C_OP_SetControlPointToCenter:
    m_nCP1 = 0x1D0 # int32_t
    m_vecCP1Pos = 0x1D4 # Vector
    m_nSetParent = 0x1E0 # ParticleParentSetMode_t

class C_OP_SetControlPointToHMD:
    m_nCP1 = 0x1D0 # int32_t
    m_vecCP1Pos = 0x1D4 # Vector
    m_bOrientToHMD = 0x1E0 # bool

class C_OP_SetControlPointToHand:
    m_nCP1 = 0x1D0 # int32_t
    m_nHand = 0x1D4 # int32_t
    m_vecCP1Pos = 0x1D8 # Vector
    m_bOrientToHand = 0x1E4 # bool

class C_OP_SetControlPointToImpactPoint:
    m_nCPOut = 0x1D0 # int32_t
    m_nCPIn = 0x1D4 # int32_t
    m_flUpdateRate = 0x1D8 # float
    m_flTraceLength = 0x1E0 # CParticleCollectionFloatInput
    m_flStartOffset = 0x338 # float
    m_flOffset = 0x33C # float
    m_vecTraceDir = 0x340 # Vector
    m_CollisionGroupName = 0x34C # char[128]
    m_nTraceSet = 0x3CC # ParticleTraceSet_t
    m_bSetToEndpoint = 0x3D0 # bool
    m_bTraceToClosestSurface = 0x3D1 # bool
    m_bIncludeWater = 0x3D2 # bool

class C_OP_SetControlPointToPlayer:
    m_nCP1 = 0x1D0 # int32_t
    m_vecCP1Pos = 0x1D4 # Vector
    m_bOrientToEyes = 0x1E0 # bool

class C_OP_SetControlPointToVectorExpression:
    m_nExpression = 0x1D0 # VectorExpressionType_t
    m_nOutputCP = 0x1D4 # int32_t
    m_vInput1 = 0x1D8 # CParticleCollectionVecInput
    m_vInput2 = 0x830 # CParticleCollectionVecInput
    m_bNormalizedOutput = 0xE88 # bool

class C_OP_SetControlPointToWaterSurface:
    m_nSourceCP = 0x1D0 # int32_t
    m_nDestCP = 0x1D4 # int32_t
    m_nFlowCP = 0x1D8 # int32_t
    m_nActiveCP = 0x1DC # int32_t
    m_nActiveCPField = 0x1E0 # int32_t
    m_flRetestRate = 0x1E8 # CParticleCollectionFloatInput
    m_bAdaptiveThreshold = 0x340 # bool

class C_OP_SetControlPointsToModelParticles:
    m_HitboxSetName = 0x1C0 # char[128]
    m_AttachmentName = 0x240 # char[128]
    m_nFirstControlPoint = 0x2C0 # int32_t
    m_nNumControlPoints = 0x2C4 # int32_t
    m_nFirstSourcePoint = 0x2C8 # int32_t
    m_bSkin = 0x2CC # bool
    m_bAttachment = 0x2CD # bool

class C_OP_SetControlPointsToParticle:
    m_nChildGroupID = 0x1C0 # int32_t
    m_nFirstControlPoint = 0x1C4 # int32_t
    m_nNumControlPoints = 0x1C8 # int32_t
    m_nFirstSourcePoint = 0x1CC # int32_t
    m_bSetOrientation = 0x1D0 # bool
    m_nOrientationMode = 0x1D4 # ParticleOrientationSetMode_t
    m_nSetParent = 0x1D8 # ParticleParentSetMode_t

class C_OP_SetFloat:
    m_InputValue = 0x1C0 # CPerParticleFloatInput
    m_nOutputField = 0x318 # ParticleAttributeIndex_t
    m_nSetMethod = 0x31C # ParticleSetMethod_t
    m_Lerp = 0x320 # CPerParticleFloatInput
    m_bUseNewCode = 0x478 # bool

class C_OP_SetFloatAttributeToVectorExpression:
    m_nExpression = 0x1C0 # VectorFloatExpressionType_t
    m_vInput1 = 0x1C8 # CPerParticleVecInput
    m_vInput2 = 0x820 # CPerParticleVecInput
    m_flOutputRemap = 0xE78 # CParticleRemapFloatInput
    m_nOutputField = 0xFD0 # ParticleAttributeIndex_t
    m_nSetMethod = 0xFD4 # ParticleSetMethod_t

class C_OP_SetFloatCollection:
    m_InputValue = 0x1C0 # CParticleCollectionFloatInput
    m_nOutputField = 0x318 # ParticleAttributeIndex_t
    m_nSetMethod = 0x31C # ParticleSetMethod_t
    m_Lerp = 0x320 # CParticleCollectionFloatInput

class C_OP_SetFromCPSnapshot:
    m_nControlPointNumber = 0x1C0 # int32_t
    m_nAttributeToRead = 0x1C4 # ParticleAttributeIndex_t
    m_nAttributeToWrite = 0x1C8 # ParticleAttributeIndex_t
    m_nLocalSpaceCP = 0x1CC # int32_t
    m_bRandom = 0x1D0 # bool
    m_bReverse = 0x1D1 # bool
    m_nRandomSeed = 0x1D4 # int32_t
    m_nSnapShotStartPoint = 0x1D8 # CParticleCollectionFloatInput
    m_nSnapShotIncrement = 0x330 # CParticleCollectionFloatInput
    m_flInterpolation = 0x488 # CPerParticleFloatInput
    m_bSubSample = 0x5E0 # bool

class C_OP_SetGravityToCP:
    m_nCPInput = 0x1D0 # int32_t
    m_nCPOutput = 0x1D4 # int32_t
    m_flScale = 0x1D8 # CParticleCollectionFloatInput
    m_bSetOrientation = 0x330 # bool
    m_bSetZDown = 0x331 # bool

class C_OP_SetParentControlPointsToChildCP:
    m_nChildGroupID = 0x1D0 # int32_t
    m_nChildControlPoint = 0x1D4 # int32_t
    m_nNumControlPoints = 0x1D8 # int32_t
    m_nFirstSourcePoint = 0x1DC # int32_t
    m_bSetOrientation = 0x1E0 # bool

class C_OP_SetPerChildControlPoint:
    m_nChildGroupID = 0x1C0 # int32_t
    m_nFirstControlPoint = 0x1C4 # int32_t
    m_nNumControlPoints = 0x1C8 # int32_t
    m_nParticleIncrement = 0x1D0 # CParticleCollectionFloatInput
    m_nFirstSourcePoint = 0x328 # CParticleCollectionFloatInput
    m_bSetOrientation = 0x480 # bool
    m_nOrientationField = 0x484 # ParticleAttributeIndex_t
    m_bNumBasedOnParticleCount = 0x488 # bool

class C_OP_SetPerChildControlPointFromAttribute:
    m_nChildGroupID = 0x1C0 # int32_t
    m_nFirstControlPoint = 0x1C4 # int32_t
    m_nNumControlPoints = 0x1C8 # int32_t
    m_nParticleIncrement = 0x1CC # int32_t
    m_nFirstSourcePoint = 0x1D0 # int32_t
    m_bNumBasedOnParticleCount = 0x1D4 # bool
    m_nAttributeToRead = 0x1D8 # ParticleAttributeIndex_t
    m_nCPField = 0x1DC # int32_t

class C_OP_SetRandomControlPointPosition:
    m_bUseWorldLocation = 0x1D0 # bool
    m_bOrient = 0x1D1 # bool
    m_nCP1 = 0x1D4 # int32_t
    m_nHeadLocation = 0x1D8 # int32_t
    m_flReRandomRate = 0x1E0 # CParticleCollectionFloatInput
    m_vecCPMinPos = 0x338 # Vector
    m_vecCPMaxPos = 0x344 # Vector
    m_flInterpolation = 0x350 # CParticleCollectionFloatInput

class C_OP_SetSimulationRate:
    m_flSimulationScale = 0x1D0 # CParticleCollectionFloatInput

class C_OP_SetSingleControlPointPosition:
    m_bSetOnce = 0x1D0 # bool
    m_nCP1 = 0x1D4 # int32_t
    m_vecCP1Pos = 0x1D8 # CParticleCollectionVecInput
    m_transformInput = 0x830 # CParticleTransformInput

class C_OP_SetToCP:
    m_nControlPointNumber = 0x1C0 # int32_t
    m_vecOffset = 0x1C4 # Vector
    m_bOffsetLocal = 0x1D0 # bool

class C_OP_SetVariable:
    m_variableReference = 0x1D0 # CParticleVariableRef
    m_transformInput = 0x210 # CParticleTransformInput
    m_positionOffset = 0x278 # Vector
    m_rotationOffset = 0x284 # QAngle
    m_vecInput = 0x290 # CParticleCollectionVecInput
    m_floatInput = 0x8E8 # CParticleCollectionFloatInput

class C_OP_SetVec:
    m_InputValue = 0x1C0 # CPerParticleVecInput
    m_nOutputField = 0x818 # ParticleAttributeIndex_t
    m_nSetMethod = 0x81C # ParticleSetMethod_t
    m_Lerp = 0x820 # CPerParticleFloatInput
    m_bNormalizedOutput = 0x978 # bool

class C_OP_SetVectorAttributeToVectorExpression:
    m_nExpression = 0x1C0 # VectorExpressionType_t
    m_vInput1 = 0x1C8 # CPerParticleVecInput
    m_vInput2 = 0x820 # CPerParticleVecInput
    m_nOutputField = 0xE78 # ParticleAttributeIndex_t
    m_nSetMethod = 0xE7C # ParticleSetMethod_t
    m_bNormalizedOutput = 0xE80 # bool

class C_OP_ShapeMatchingConstraint:
    m_flShapeRestorationTime = 0x1C0 # float

class C_OP_SnapshotRigidSkinToBones:
    m_bTransformNormals = 0x1C0 # bool
    m_bTransformRadii = 0x1C1 # bool
    m_nControlPointNumber = 0x1C4 # int32_t

class C_OP_SnapshotSkinToBones:
    m_bTransformNormals = 0x1C0 # bool
    m_bTransformRadii = 0x1C1 # bool
    m_nControlPointNumber = 0x1C4 # int32_t
    m_flLifeTimeFadeStart = 0x1C8 # float
    m_flLifeTimeFadeEnd = 0x1CC # float
    m_flJumpThreshold = 0x1D0 # float
    m_flPrevPosScale = 0x1D4 # float

class C_OP_SpringToVectorConstraint:
    m_flRestLength = 0x1C0 # CPerParticleFloatInput
    m_flMinDistance = 0x318 # CPerParticleFloatInput
    m_flMaxDistance = 0x470 # CPerParticleFloatInput
    m_flRestingLength = 0x5C8 # CPerParticleFloatInput
    m_vecAnchorVector = 0x720 # CPerParticleVecInput

class C_OP_StopAfterCPDuration:
    m_flDuration = 0x1D0 # CParticleCollectionFloatInput
    m_bDestroyImmediately = 0x328 # bool
    m_bPlayEndCap = 0x329 # bool

class C_OP_TeleportBeam:
    m_nCPPosition = 0x1C0 # int32_t
    m_nCPVelocity = 0x1C4 # int32_t
    m_nCPMisc = 0x1C8 # int32_t
    m_nCPColor = 0x1CC # int32_t
    m_nCPInvalidColor = 0x1D0 # int32_t
    m_nCPExtraArcData = 0x1D4 # int32_t
    m_vGravity = 0x1D8 # Vector
    m_flArcMaxDuration = 0x1E4 # float
    m_flSegmentBreak = 0x1E8 # float
    m_flArcSpeed = 0x1EC # float
    m_flAlpha = 0x1F0 # float

class C_OP_TimeVaryingForce:
    m_flStartLerpTime = 0x1D0 # float
    m_StartingForce = 0x1D4 # Vector
    m_flEndLerpTime = 0x1E0 # float
    m_EndingForce = 0x1E4 # Vector

class C_OP_TurbulenceForce:
    m_flNoiseCoordScale0 = 0x1D0 # float
    m_flNoiseCoordScale1 = 0x1D4 # float
    m_flNoiseCoordScale2 = 0x1D8 # float
    m_flNoiseCoordScale3 = 0x1DC # float
    m_vecNoiseAmount0 = 0x1E0 # Vector
    m_vecNoiseAmount1 = 0x1EC # Vector
    m_vecNoiseAmount2 = 0x1F8 # Vector
    m_vecNoiseAmount3 = 0x204 # Vector

class C_OP_TwistAroundAxis:
    m_fForceAmount = 0x1D0 # float
    m_TwistAxis = 0x1D4 # Vector
    m_bLocalSpace = 0x1E0 # bool
    m_nControlPointNumber = 0x1E4 # int32_t

class C_OP_UpdateLightSource:
    m_vColorTint = 0x1C0 # Color
    m_flBrightnessScale = 0x1C4 # float
    m_flRadiusScale = 0x1C8 # float
    m_flMinimumLightingRadius = 0x1CC # float
    m_flMaximumLightingRadius = 0x1D0 # float
    m_flPositionDampingConstant = 0x1D4 # float

class C_OP_VectorFieldSnapshot:
    m_nControlPointNumber = 0x1C0 # int32_t
    m_nAttributeToWrite = 0x1C4 # ParticleAttributeIndex_t
    m_nLocalSpaceCP = 0x1C8 # int32_t
    m_flInterpolation = 0x1D0 # CPerParticleFloatInput
    m_vecScale = 0x328 # CPerParticleVecInput
    m_flBoundaryDampening = 0x980 # float
    m_bSetVelocity = 0x984 # bool
    m_bLockToSurface = 0x985 # bool
    m_flGridSpacing = 0x988 # float

class C_OP_VectorNoise:
    m_nFieldOutput = 0x1C0 # ParticleAttributeIndex_t
    m_vecOutputMin = 0x1C4 # Vector
    m_vecOutputMax = 0x1D0 # Vector
    m_fl4NoiseScale = 0x1DC # float
    m_bAdditive = 0x1E0 # bool
    m_bOffset = 0x1E1 # bool
    m_flNoiseAnimationTimeScale = 0x1E4 # float

class C_OP_VelocityDecay:
    m_flMinVelocity = 0x1C0 # float

class C_OP_VelocityMatchingForce:
    m_flDirScale = 0x1C0 # float
    m_flSpdScale = 0x1C4 # float
    m_nCPBroadcast = 0x1C8 # int32_t

class C_OP_WindForce:
    m_vForce = 0x1D0 # Vector

class C_OP_WorldTraceConstraint:
    m_nCP = 0x1C0 # int32_t
    m_vecCpOffset = 0x1C4 # Vector
    m_nCollisionMode = 0x1D0 # ParticleCollisionMode_t
    m_nCollisionModeMin = 0x1D4 # ParticleCollisionMode_t
    m_nTraceSet = 0x1D8 # ParticleTraceSet_t
    m_CollisionGroupName = 0x1DC # char[128]
    m_bWorldOnly = 0x25C # bool
    m_bBrushOnly = 0x25D # bool
    m_bIncludeWater = 0x25E # bool
    m_nIgnoreCP = 0x260 # int32_t
    m_flCpMovementTolerance = 0x264 # float
    m_flRetestRate = 0x268 # float
    m_flTraceTolerance = 0x26C # float
    m_flCollisionConfirmationSpeed = 0x270 # float
    m_nMaxTracesPerFrame = 0x274 # float
    m_flRadiusScale = 0x278 # CPerParticleFloatInput
    m_flBounceAmount = 0x3D0 # CPerParticleFloatInput
    m_flSlideAmount = 0x528 # CPerParticleFloatInput
    m_flRandomDirScale = 0x680 # CPerParticleFloatInput
    m_bDecayBounce = 0x7D8 # bool
    m_bKillonContact = 0x7D9 # bool
    m_flMinSpeed = 0x7DC # float
    m_bSetNormal = 0x7E0 # bool
    m_nStickOnCollisionField = 0x7E4 # ParticleAttributeIndex_t
    m_flStopSpeed = 0x7E8 # CPerParticleFloatInput
    m_nEntityStickDataField = 0x940 # ParticleAttributeIndex_t
    m_nEntityStickNormalField = 0x944 # ParticleAttributeIndex_t

class CollisionGroupContext_t:
    m_nCollisionGroupNumber = 0x0 # int32_t

class ControlPointReference_t:
    m_controlPointNameString = 0x0 # int32_t
    m_vOffsetFromControlPoint = 0x4 # Vector
    m_bOffsetInLocalSpace = 0x10 # bool

class FloatInputMaterialVariable_t:
    m_strVariable = 0x0 # CUtlString
    m_flInput = 0x8 # CParticleCollectionFloatInput

class MaterialVariable_t:
    m_strVariable = 0x0 # CUtlString
    m_nVariableField = 0x8 # ParticleAttributeIndex_t
    m_flScale = 0xC # float

class ModelReference_t:
    m_model = 0x0 # CStrongHandle<InfoForResourceTypeCModel>
    m_flRelativeProbabilityOfSpawn = 0x8 # float

class PARTICLE_EHANDLE__:
    unused = 0x0 # int32_t

class PARTICLE_WORLD_HANDLE__:
    unused = 0x0 # int32_t

class ParticleAttributeIndex_t:
    m_Value = 0x0 # int32_t

class ParticleChildrenInfo_t:
    m_ChildRef = 0x0 # CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    m_flDelay = 0x8 # float
    m_bEndCap = 0xC # bool
    m_bDisableChild = 0xD # bool
    m_nDetailLevel = 0x10 # ParticleDetailLevel_t

class ParticleControlPointConfiguration_t:
    m_name = 0x0 # CUtlString
    m_drivers = 0x8 # CUtlVector<ParticleControlPointDriver_t>
    m_previewState = 0x20 # ParticlePreviewState_t

class ParticleControlPointDriver_t:
    m_iControlPoint = 0x0 # int32_t
    m_iAttachType = 0x4 # ParticleAttachment_t
    m_attachmentName = 0x8 # CUtlString
    m_vecOffset = 0x10 # Vector
    m_angOffset = 0x1C # QAngle
    m_entityName = 0x28 # CUtlString

class ParticleNamedValueConfiguration_t:
    m_ConfigName = 0x0 # CUtlString
    m_ConfigValue = 0x8 # KeyValues3
    m_iAttachType = 0x18 # ParticleAttachment_t
    m_BoundEntityPath = 0x20 # CUtlString
    m_strEntityScope = 0x28 # CUtlString
    m_strAttachmentName = 0x30 # CUtlString

class ParticleNamedValueSource_t:
    m_Name = 0x0 # CUtlString
    m_IsPublic = 0x8 # bool
    m_ValueType = 0xC # PulseValueType_t
    m_DefaultConfig = 0x10 # ParticleNamedValueConfiguration_t
    m_NamedConfigs = 0x48 # CUtlVector<ParticleNamedValueConfiguration_t>

class ParticlePreviewBodyGroup_t:
    m_bodyGroupName = 0x0 # CUtlString
    m_nValue = 0x8 # int32_t

class ParticlePreviewState_t:
    m_previewModel = 0x0 # CUtlString
    m_nModSpecificData = 0x8 # uint32_t
    m_groundType = 0xC # PetGroundType_t
    m_sequenceName = 0x10 # CUtlString
    m_nFireParticleOnSequenceFrame = 0x18 # int32_t
    m_hitboxSetName = 0x20 # CUtlString
    m_materialGroupName = 0x28 # CUtlString
    m_vecBodyGroups = 0x30 # CUtlVector<ParticlePreviewBodyGroup_t>
    m_flPlaybackSpeed = 0x48 # float
    m_flParticleSimulationRate = 0x4C # float
    m_bShouldDrawHitboxes = 0x50 # bool
    m_bShouldDrawAttachments = 0x51 # bool
    m_bShouldDrawAttachmentNames = 0x52 # bool
    m_bShouldDrawControlPointAxes = 0x53 # bool
    m_bAnimationNonLooping = 0x54 # bool
    m_vecPreviewGravity = 0x58 # Vector

class PointDefinitionWithTimeValues_t:
    m_flTimeDuration = 0x14 # float

class PointDefinition_t:
    m_nControlPoint = 0x0 # int32_t
    m_bLocalCoords = 0x4 # bool
    m_vOffset = 0x8 # Vector

class SequenceWeightedList_t:
    m_nSequence = 0x0 # int32_t
    m_flRelativeWeight = 0x4 # float

class TextureControls_t:
    m_flFinalTextureScaleU = 0x0 # CParticleCollectionRendererFloatInput
    m_flFinalTextureScaleV = 0x158 # CParticleCollectionRendererFloatInput
    m_flFinalTextureOffsetU = 0x2B0 # CParticleCollectionRendererFloatInput
    m_flFinalTextureOffsetV = 0x408 # CParticleCollectionRendererFloatInput
    m_flFinalTextureUVRotation = 0x560 # CParticleCollectionRendererFloatInput
    m_flZoomScale = 0x6B8 # CParticleCollectionRendererFloatInput
    m_flDistortion = 0x810 # CParticleCollectionRendererFloatInput
    m_bRandomizeOffsets = 0x968 # bool
    m_bClampUVs = 0x969 # bool
    m_nPerParticleBlend = 0x96C # SpriteCardPerParticleScale_t
    m_nPerParticleScale = 0x970 # SpriteCardPerParticleScale_t
    m_nPerParticleOffsetU = 0x974 # SpriteCardPerParticleScale_t
    m_nPerParticleOffsetV = 0x978 # SpriteCardPerParticleScale_t
    m_nPerParticleRotation = 0x97C # SpriteCardPerParticleScale_t
    m_nPerParticleZoom = 0x980 # SpriteCardPerParticleScale_t
    m_nPerParticleDistortion = 0x984 # SpriteCardPerParticleScale_t

class TextureGroup_t:
    m_bEnabled = 0x0 # bool
    m_bReplaceTextureWithGradient = 0x1 # bool
    m_hTexture = 0x8 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_Gradient = 0x10 # CColorGradient
    m_nTextureType = 0x28 # SpriteCardTextureType_t
    m_nTextureChannels = 0x2C # SpriteCardTextureChannel_t
    m_nTextureBlendMode = 0x30 # ParticleTextureLayerBlendType_t
    m_flTextureBlend = 0x38 # CParticleCollectionRendererFloatInput
    m_TextureControls = 0x190 # TextureControls_t

class VecInputMaterialVariable_t:
    m_strVariable = 0x0 # CUtlString
    m_vecInput = 0x8 # CParticleCollectionVecInput

```

`SDK/particles.dll.rs`:

```rs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.988320 UTC
 */

#![allow(non_snake_case, non_upper_case_globals)]

pub mod CBaseRendererSource2 {
    pub const m_flRadiusScale: usize = 0x200; // CParticleCollectionRendererFloatInput
    pub const m_flAlphaScale: usize = 0x358; // CParticleCollectionRendererFloatInput
    pub const m_flRollScale: usize = 0x4B0; // CParticleCollectionRendererFloatInput
    pub const m_nAlpha2Field: usize = 0x608; // ParticleAttributeIndex_t
    pub const m_vecColorScale: usize = 0x610; // CParticleCollectionRendererVecInput
    pub const m_nColorBlendType: usize = 0xC68; // ParticleColorBlendType_t
    pub const m_nShaderType: usize = 0xC6C; // SpriteCardShaderType_t
    pub const m_strShaderOverride: usize = 0xC70; // CUtlString
    pub const m_flCenterXOffset: usize = 0xC78; // CParticleCollectionRendererFloatInput
    pub const m_flCenterYOffset: usize = 0xDD0; // CParticleCollectionRendererFloatInput
    pub const m_flBumpStrength: usize = 0xF28; // float
    pub const m_nCropTextureOverride: usize = 0xF2C; // ParticleSequenceCropOverride_t
    pub const m_vecTexturesInput: usize = 0xF30; // CUtlVector<TextureGroup_t>
    pub const m_flAnimationRate: usize = 0xF48; // float
    pub const m_nAnimationType: usize = 0xF4C; // AnimationType_t
    pub const m_bAnimateInFPS: usize = 0xF50; // bool
    pub const m_flSelfIllumAmount: usize = 0xF58; // CParticleCollectionRendererFloatInput
    pub const m_flDiffuseAmount: usize = 0x10B0; // CParticleCollectionRendererFloatInput
    pub const m_nLightingControlPoint: usize = 0x1208; // int32_t
    pub const m_nSelfIllumPerParticle: usize = 0x120C; // ParticleAttributeIndex_t
    pub const m_nOutputBlendMode: usize = 0x1210; // ParticleOutputBlendMode_t
    pub const m_bGammaCorrectVertexColors: usize = 0x1214; // bool
    pub const m_bSaturateColorPreAlphaBlend: usize = 0x1215; // bool
    pub const m_flAddSelfAmount: usize = 0x1218; // CParticleCollectionRendererFloatInput
    pub const m_flDesaturation: usize = 0x1370; // CParticleCollectionRendererFloatInput
    pub const m_flOverbrightFactor: usize = 0x14C8; // CParticleCollectionRendererFloatInput
    pub const m_nHSVShiftControlPoint: usize = 0x1620; // int32_t
    pub const m_nFogType: usize = 0x1624; // ParticleFogType_t
    pub const m_flFogAmount: usize = 0x1628; // CParticleCollectionRendererFloatInput
    pub const m_bTintByFOW: usize = 0x1780; // bool
    pub const m_bTintByGlobalLight: usize = 0x1781; // bool
    pub const m_nPerParticleAlphaReference: usize = 0x1784; // SpriteCardPerParticleScale_t
    pub const m_nPerParticleAlphaRefWindow: usize = 0x1788; // SpriteCardPerParticleScale_t
    pub const m_nAlphaReferenceType: usize = 0x178C; // ParticleAlphaReferenceType_t
    pub const m_flAlphaReferenceSoftness: usize = 0x1790; // CParticleCollectionRendererFloatInput
    pub const m_flSourceAlphaValueToMapToZero: usize = 0x18E8; // CParticleCollectionRendererFloatInput
    pub const m_flSourceAlphaValueToMapToOne: usize = 0x1A40; // CParticleCollectionRendererFloatInput
    pub const m_bRefract: usize = 0x1B98; // bool
    pub const m_bRefractSolid: usize = 0x1B99; // bool
    pub const m_flRefractAmount: usize = 0x1BA0; // CParticleCollectionRendererFloatInput
    pub const m_nRefractBlurRadius: usize = 0x1CF8; // int32_t
    pub const m_nRefractBlurType: usize = 0x1CFC; // BlurFilterType_t
    pub const m_bOnlyRenderInEffectsBloomPass: usize = 0x1D00; // bool
    pub const m_bOnlyRenderInEffectsWaterPass: usize = 0x1D01; // bool
    pub const m_bUseMixedResolutionRendering: usize = 0x1D02; // bool
    pub const m_bOnlyRenderInEffecsGameOverlay: usize = 0x1D03; // bool
    pub const m_stencilTestID: usize = 0x1D04; // char[128]
    pub const m_bStencilTestExclude: usize = 0x1D84; // bool
    pub const m_stencilWriteID: usize = 0x1D85; // char[128]
    pub const m_bWriteStencilOnDepthPass: usize = 0x1E05; // bool
    pub const m_bWriteStencilOnDepthFail: usize = 0x1E06; // bool
    pub const m_bReverseZBuffering: usize = 0x1E07; // bool
    pub const m_bDisableZBuffering: usize = 0x1E08; // bool
    pub const m_nFeatheringMode: usize = 0x1E0C; // ParticleDepthFeatheringMode_t
    pub const m_flFeatheringMinDist: usize = 0x1E10; // CParticleCollectionRendererFloatInput
    pub const m_flFeatheringMaxDist: usize = 0x1F68; // CParticleCollectionRendererFloatInput
    pub const m_flFeatheringFilter: usize = 0x20C0; // CParticleCollectionRendererFloatInput
    pub const m_flDepthBias: usize = 0x2218; // float
    pub const m_nSortMethod: usize = 0x221C; // ParticleSortingChoiceList_t
    pub const m_bBlendFramesSeq0: usize = 0x2220; // bool
    pub const m_bMaxLuminanceBlendingSequence0: usize = 0x2221; // bool
}

pub mod CBaseTrailRenderer {
    pub const m_nOrientationType: usize = 0x2470; // ParticleOrientationChoiceList_t
    pub const m_nOrientationControlPoint: usize = 0x2474; // int32_t
    pub const m_flMinSize: usize = 0x2478; // float
    pub const m_flMaxSize: usize = 0x247C; // float
    pub const m_flStartFadeSize: usize = 0x2480; // CParticleCollectionRendererFloatInput
    pub const m_flEndFadeSize: usize = 0x25D8; // CParticleCollectionRendererFloatInput
    pub const m_bClampV: usize = 0x2730; // bool
}

pub mod CGeneralRandomRotation {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_flDegrees: usize = 0x1C4; // float
    pub const m_flDegreesMin: usize = 0x1C8; // float
    pub const m_flDegreesMax: usize = 0x1CC; // float
    pub const m_flRotationRandExponent: usize = 0x1D0; // float
    pub const m_bRandomlyFlipDirection: usize = 0x1D4; // bool
}

pub mod CGeneralSpin {
    pub const m_nSpinRateDegrees: usize = 0x1C0; // int32_t
    pub const m_nSpinRateMinDegrees: usize = 0x1C4; // int32_t
    pub const m_fSpinRateStopTime: usize = 0x1CC; // float
}

pub mod CNewParticleEffect {
    pub const m_pNext: usize = 0x10; // CNewParticleEffect*
    pub const m_pPrev: usize = 0x18; // CNewParticleEffect*
    pub const m_pParticles: usize = 0x20; // IParticleCollection*
    pub const m_pDebugName: usize = 0x28; // char*
    pub const m_bDontRemove: usize = 0x0; // bitfield:1
    pub const m_bRemove: usize = 0x0; // bitfield:1
    pub const m_bNeedsBBoxUpdate: usize = 0x0; // bitfield:1
    pub const m_bIsFirstFrame: usize = 0x0; // bitfield:1
    pub const m_bAutoUpdateBBox: usize = 0x0; // bitfield:1
    pub const m_bAllocated: usize = 0x0; // bitfield:1
    pub const m_bSimulate: usize = 0x0; // bitfield:1
    pub const m_bShouldPerformCullCheck: usize = 0x0; // bitfield:1
    pub const m_bForceNoDraw: usize = 0x0; // bitfield:1
    pub const m_bShouldSave: usize = 0x0; // bitfield:1
    pub const m_bDisableAggregation: usize = 0x0; // bitfield:1
    pub const m_bShouldSimulateDuringGamePaused: usize = 0x0; // bitfield:1
    pub const m_bShouldCheckFoW: usize = 0x0; // bitfield:1
    pub const m_vSortOrigin: usize = 0x40; // Vector
    pub const m_flScale: usize = 0x4C; // float
    pub const m_hOwner: usize = 0x50; // PARTICLE_EHANDLE__*
    pub const m_pOwningParticleProperty: usize = 0x58; // CParticleProperty*
    pub const m_flFreezeTransitionStart: usize = 0x70; // float
    pub const m_flFreezeTransitionDuration: usize = 0x74; // float
    pub const m_flFreezeTransitionOverride: usize = 0x78; // float
    pub const m_bFreezeTransitionActive: usize = 0x7C; // bool
    pub const m_bFreezeTargetState: usize = 0x7D; // bool
    pub const m_bCanFreeze: usize = 0x7E; // bool
    pub const m_LastMin: usize = 0x80; // Vector
    pub const m_LastMax: usize = 0x8C; // Vector
    pub const m_nSplitScreenUser: usize = 0x98; // CSplitScreenSlot
    pub const m_vecAggregationCenter: usize = 0x9C; // Vector
    pub const m_RefCount: usize = 0xC0; // int32_t
}

pub mod CParticleFloatInput {
    pub const m_nType: usize = 0x10; // ParticleFloatType_t
    pub const m_nMapType: usize = 0x14; // ParticleFloatMapType_t
    pub const m_flLiteralValue: usize = 0x18; // float
    pub const m_NamedValue: usize = 0x20; // CParticleNamedValueRef
    pub const m_nControlPoint: usize = 0x60; // int32_t
    pub const m_nScalarAttribute: usize = 0x64; // ParticleAttributeIndex_t
    pub const m_nVectorAttribute: usize = 0x68; // ParticleAttributeIndex_t
    pub const m_nVectorComponent: usize = 0x6C; // int32_t
    pub const m_flRandomMin: usize = 0x70; // float
    pub const m_flRandomMax: usize = 0x74; // float
    pub const m_bHasRandomSignFlip: usize = 0x78; // bool
    pub const m_nRandomSeed: usize = 0x7C; // int32_t
    pub const m_nRandomMode: usize = 0x80; // ParticleFloatRandomMode_t
    pub const m_flLOD0: usize = 0x88; // float
    pub const m_flLOD1: usize = 0x8C; // float
    pub const m_flLOD2: usize = 0x90; // float
    pub const m_flLOD3: usize = 0x94; // float
    pub const m_nNoiseInputVectorAttribute: usize = 0x98; // ParticleAttributeIndex_t
    pub const m_flNoiseOutputMin: usize = 0x9C; // float
    pub const m_flNoiseOutputMax: usize = 0xA0; // float
    pub const m_flNoiseScale: usize = 0xA4; // float
    pub const m_vecNoiseOffsetRate: usize = 0xA8; // Vector
    pub const m_flNoiseOffset: usize = 0xB4; // float
    pub const m_nNoiseOctaves: usize = 0xB8; // int32_t
    pub const m_nNoiseTurbulence: usize = 0xBC; // PFNoiseTurbulence_t
    pub const m_nNoiseType: usize = 0xC0; // PFNoiseType_t
    pub const m_nNoiseModifier: usize = 0xC4; // PFNoiseModifier_t
    pub const m_flNoiseTurbulenceScale: usize = 0xC8; // float
    pub const m_flNoiseTurbulenceMix: usize = 0xCC; // float
    pub const m_flNoiseImgPreviewScale: usize = 0xD0; // float
    pub const m_bNoiseImgPreviewLive: usize = 0xD4; // bool
    pub const m_flNoCameraFallback: usize = 0xE0; // float
    pub const m_bUseBoundsCenter: usize = 0xE4; // bool
    pub const m_nInputMode: usize = 0xE8; // ParticleFloatInputMode_t
    pub const m_flMultFactor: usize = 0xEC; // float
    pub const m_flInput0: usize = 0xF0; // float
    pub const m_flInput1: usize = 0xF4; // float
    pub const m_flOutput0: usize = 0xF8; // float
    pub const m_flOutput1: usize = 0xFC; // float
    pub const m_flNotchedRangeMin: usize = 0x100; // float
    pub const m_flNotchedRangeMax: usize = 0x104; // float
    pub const m_flNotchedOutputOutside: usize = 0x108; // float
    pub const m_flNotchedOutputInside: usize = 0x10C; // float
    pub const m_nBiasType: usize = 0x110; // ParticleFloatBiasType_t
    pub const m_flBiasParameter: usize = 0x114; // float
    pub const m_Curve: usize = 0x118; // CPiecewiseCurve
}

pub mod CParticleFunction {
    pub const m_flOpStrength: usize = 0x8; // CParticleCollectionFloatInput
    pub const m_nOpEndCapState: usize = 0x160; // ParticleEndcapMode_t
    pub const m_flOpStartFadeInTime: usize = 0x164; // float
    pub const m_flOpEndFadeInTime: usize = 0x168; // float
    pub const m_flOpStartFadeOutTime: usize = 0x16C; // float
    pub const m_flOpEndFadeOutTime: usize = 0x170; // float
    pub const m_flOpFadeOscillatePeriod: usize = 0x174; // float
    pub const m_bNormalizeToStopTime: usize = 0x178; // bool
    pub const m_flOpTimeOffsetMin: usize = 0x17C; // float
    pub const m_flOpTimeOffsetMax: usize = 0x180; // float
    pub const m_nOpTimeOffsetSeed: usize = 0x184; // int32_t
    pub const m_nOpTimeScaleSeed: usize = 0x188; // int32_t
    pub const m_flOpTimeScaleMin: usize = 0x18C; // float
    pub const m_flOpTimeScaleMax: usize = 0x190; // float
    pub const m_bDisableOperator: usize = 0x196; // bool
    pub const m_Notes: usize = 0x198; // CUtlString
}

pub mod CParticleFunctionEmitter {
    pub const m_nEmitterIndex: usize = 0x1B8; // int32_t
}

pub mod CParticleFunctionInitializer {
    pub const m_nAssociatedEmitterIndex: usize = 0x1B8; // int32_t
}

pub mod CParticleFunctionPreEmission {
    pub const m_bRunOnce: usize = 0x1C0; // bool
}

pub mod CParticleFunctionRenderer {
    pub const VisibilityInputs: usize = 0x1B8; // CParticleVisibilityInputs
    pub const m_bCannotBeRefracted: usize = 0x1FC; // bool
    pub const m_bSkipRenderingOnMobile: usize = 0x1FD; // bool
}

pub mod CParticleModelInput {
    pub const m_nType: usize = 0x10; // ParticleModelType_t
    pub const m_NamedValue: usize = 0x18; // CParticleNamedValueRef
    pub const m_nControlPoint: usize = 0x58; // int32_t
}

pub mod CParticleSystemDefinition {
    pub const m_nBehaviorVersion: usize = 0x8; // int32_t
    pub const m_PreEmissionOperators: usize = 0x10; // CUtlVector<CParticleFunctionPreEmission*>
    pub const m_Emitters: usize = 0x28; // CUtlVector<CParticleFunctionEmitter*>
    pub const m_Initializers: usize = 0x40; // CUtlVector<CParticleFunctionInitializer*>
    pub const m_Operators: usize = 0x58; // CUtlVector<CParticleFunctionOperator*>
    pub const m_ForceGenerators: usize = 0x70; // CUtlVector<CParticleFunctionForce*>
    pub const m_Constraints: usize = 0x88; // CUtlVector<CParticleFunctionConstraint*>
    pub const m_Renderers: usize = 0xA0; // CUtlVector<CParticleFunctionRenderer*>
    pub const m_Children: usize = 0xB8; // CUtlVector<ParticleChildrenInfo_t>
    pub const m_nFirstMultipleOverride_BackwardCompat: usize = 0x178; // int32_t
    pub const m_nInitialParticles: usize = 0x210; // int32_t
    pub const m_nMaxParticles: usize = 0x214; // int32_t
    pub const m_nGroupID: usize = 0x218; // int32_t
    pub const m_BoundingBoxMin: usize = 0x21C; // Vector
    pub const m_BoundingBoxMax: usize = 0x228; // Vector
    pub const m_flDepthSortBias: usize = 0x234; // float
    pub const m_nSortOverridePositionCP: usize = 0x238; // int32_t
    pub const m_bInfiniteBounds: usize = 0x23C; // bool
    pub const m_bEnableNamedValues: usize = 0x23D; // bool
    pub const m_NamedValueDomain: usize = 0x240; // CUtlString
    pub const m_NamedValueLocals: usize = 0x248; // CUtlVector<ParticleNamedValueSource_t*>
    pub const m_ConstantColor: usize = 0x260; // Color
    pub const m_ConstantNormal: usize = 0x264; // Vector
    pub const m_flConstantRadius: usize = 0x270; // float
    pub const m_flConstantRotation: usize = 0x274; // float
    pub const m_flConstantRotationSpeed: usize = 0x278; // float
    pub const m_flConstantLifespan: usize = 0x27C; // float
    pub const m_nConstantSequenceNumber: usize = 0x280; // int32_t
    pub const m_nConstantSequenceNumber1: usize = 0x284; // int32_t
    pub const m_nSnapshotControlPoint: usize = 0x288; // int32_t
    pub const m_hSnapshot: usize = 0x290; // CStrongHandle<InfoForResourceTypeIParticleSnapshot>
    pub const m_pszCullReplacementName: usize = 0x298; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    pub const m_flCullRadius: usize = 0x2A0; // float
    pub const m_flCullFillCost: usize = 0x2A4; // float
    pub const m_nCullControlPoint: usize = 0x2A8; // int32_t
    pub const m_hFallback: usize = 0x2B0; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    pub const m_nFallbackMaxCount: usize = 0x2B8; // int32_t
    pub const m_hLowViolenceDef: usize = 0x2C0; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    pub const m_hReferenceReplacement: usize = 0x2C8; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    pub const m_flPreSimulationTime: usize = 0x2D0; // float
    pub const m_flStopSimulationAfterTime: usize = 0x2D4; // float
    pub const m_flMaximumTimeStep: usize = 0x2D8; // float
    pub const m_flMaximumSimTime: usize = 0x2DC; // float
    pub const m_flMinimumSimTime: usize = 0x2E0; // float
    pub const m_flMinimumTimeStep: usize = 0x2E4; // float
    pub const m_nMinimumFrames: usize = 0x2E8; // int32_t
    pub const m_nMinCPULevel: usize = 0x2EC; // int32_t
    pub const m_nMinGPULevel: usize = 0x2F0; // int32_t
    pub const m_flNoDrawTimeToGoToSleep: usize = 0x2F4; // float
    pub const m_flMaxDrawDistance: usize = 0x2F8; // float
    pub const m_flStartFadeDistance: usize = 0x2FC; // float
    pub const m_flMaxCreationDistance: usize = 0x300; // float
    pub const m_nAggregationMinAvailableParticles: usize = 0x304; // int32_t
    pub const m_flAggregateRadius: usize = 0x308; // float
    pub const m_bShouldBatch: usize = 0x30C; // bool
    pub const m_bShouldHitboxesFallbackToRenderBounds: usize = 0x30D; // bool
    pub const m_bShouldHitboxesFallbackToSnapshot: usize = 0x30E; // bool
    pub const m_nViewModelEffect: usize = 0x310; // InheritableBoolType_t
    pub const m_bScreenSpaceEffect: usize = 0x314; // bool
    pub const m_pszTargetLayerID: usize = 0x318; // CUtlSymbolLarge
    pub const m_nSkipRenderControlPoint: usize = 0x320; // int32_t
    pub const m_nAllowRenderControlPoint: usize = 0x324; // int32_t
    pub const m_bShouldSort: usize = 0x328; // bool
    pub const m_controlPointConfigurations: usize = 0x370; // CUtlVector<ParticleControlPointConfiguration_t>
}

pub mod CParticleTransformInput {
    pub const m_nType: usize = 0x10; // ParticleTransformType_t
    pub const m_NamedValue: usize = 0x18; // CParticleNamedValueRef
    pub const m_bFollowNamedValue: usize = 0x58; // bool
    pub const m_bSupportsDisabled: usize = 0x59; // bool
    pub const m_bUseOrientation: usize = 0x5A; // bool
    pub const m_nControlPoint: usize = 0x5C; // int32_t
    pub const m_nControlPointRangeMax: usize = 0x60; // int32_t
    pub const m_flEndCPGrowthTime: usize = 0x64; // float
}

pub mod CParticleVariableRef {
    pub const m_variableName: usize = 0x0; // CKV3MemberNameWithStorage
    pub const m_variableType: usize = 0x38; // PulseValueType_t
}

pub mod CParticleVecInput {
    pub const m_nType: usize = 0x10; // ParticleVecType_t
    pub const m_vLiteralValue: usize = 0x14; // Vector
    pub const m_LiteralColor: usize = 0x20; // Color
    pub const m_NamedValue: usize = 0x28; // CParticleNamedValueRef
    pub const m_bFollowNamedValue: usize = 0x68; // bool
    pub const m_nVectorAttribute: usize = 0x6C; // ParticleAttributeIndex_t
    pub const m_vVectorAttributeScale: usize = 0x70; // Vector
    pub const m_nControlPoint: usize = 0x7C; // int32_t
    pub const m_nDeltaControlPoint: usize = 0x80; // int32_t
    pub const m_vCPValueScale: usize = 0x84; // Vector
    pub const m_vCPRelativePosition: usize = 0x90; // Vector
    pub const m_vCPRelativeDir: usize = 0x9C; // Vector
    pub const m_FloatComponentX: usize = 0xA8; // CParticleFloatInput
    pub const m_FloatComponentY: usize = 0x200; // CParticleFloatInput
    pub const m_FloatComponentZ: usize = 0x358; // CParticleFloatInput
    pub const m_FloatInterp: usize = 0x4B0; // CParticleFloatInput
    pub const m_flInterpInput0: usize = 0x608; // float
    pub const m_flInterpInput1: usize = 0x60C; // float
    pub const m_vInterpOutput0: usize = 0x610; // Vector
    pub const m_vInterpOutput1: usize = 0x61C; // Vector
    pub const m_Gradient: usize = 0x628; // CColorGradient
    pub const m_vRandomMin: usize = 0x640; // Vector
    pub const m_vRandomMax: usize = 0x64C; // Vector
}

pub mod CParticleVisibilityInputs {
    pub const m_flCameraBias: usize = 0x0; // float
    pub const m_nCPin: usize = 0x4; // int32_t
    pub const m_flProxyRadius: usize = 0x8; // float
    pub const m_flInputMin: usize = 0xC; // float
    pub const m_flInputMax: usize = 0x10; // float
    pub const m_flNoPixelVisibilityFallback: usize = 0x14; // float
    pub const m_flDistanceInputMin: usize = 0x18; // float
    pub const m_flDistanceInputMax: usize = 0x1C; // float
    pub const m_flDotInputMin: usize = 0x20; // float
    pub const m_flDotInputMax: usize = 0x24; // float
    pub const m_bDotCPAngles: usize = 0x28; // bool
    pub const m_bDotCameraAngles: usize = 0x29; // bool
    pub const m_flAlphaScaleMin: usize = 0x2C; // float
    pub const m_flAlphaScaleMax: usize = 0x30; // float
    pub const m_flRadiusScaleMin: usize = 0x34; // float
    pub const m_flRadiusScaleMax: usize = 0x38; // float
    pub const m_flRadiusScaleFOVBase: usize = 0x3C; // float
    pub const m_bRightEye: usize = 0x40; // bool
}

pub mod CPathParameters {
    pub const m_nStartControlPointNumber: usize = 0x0; // int32_t
    pub const m_nEndControlPointNumber: usize = 0x4; // int32_t
    pub const m_nBulgeControl: usize = 0x8; // int32_t
    pub const m_flBulge: usize = 0xC; // float
    pub const m_flMidPoint: usize = 0x10; // float
    pub const m_vStartPointOffset: usize = 0x14; // Vector
    pub const m_vMidPointOffset: usize = 0x20; // Vector
    pub const m_vEndOffset: usize = 0x2C; // Vector
}

pub mod CRandomNumberGeneratorParameters {
    pub const m_bDistributeEvenly: usize = 0x0; // bool
    pub const m_nSeed: usize = 0x4; // int32_t
}

pub mod C_INIT_AddVectorToVector {
    pub const m_vecScale: usize = 0x1C0; // Vector
    pub const m_nFieldOutput: usize = 0x1CC; // ParticleAttributeIndex_t
    pub const m_nFieldInput: usize = 0x1D0; // ParticleAttributeIndex_t
    pub const m_vOffsetMin: usize = 0x1D4; // Vector
    pub const m_vOffsetMax: usize = 0x1E0; // Vector
    pub const m_randomnessParameters: usize = 0x1EC; // CRandomNumberGeneratorParameters
}

pub mod C_INIT_AgeNoise {
    pub const m_bAbsVal: usize = 0x1C0; // bool
    pub const m_bAbsValInv: usize = 0x1C1; // bool
    pub const m_flOffset: usize = 0x1C4; // float
    pub const m_flAgeMin: usize = 0x1C8; // float
    pub const m_flAgeMax: usize = 0x1CC; // float
    pub const m_flNoiseScale: usize = 0x1D0; // float
    pub const m_flNoiseScaleLoc: usize = 0x1D4; // float
    pub const m_vecOffsetLoc: usize = 0x1D8; // Vector
}

pub mod C_INIT_ChaoticAttractor {
    pub const m_flAParm: usize = 0x1C0; // float
    pub const m_flBParm: usize = 0x1C4; // float
    pub const m_flCParm: usize = 0x1C8; // float
    pub const m_flDParm: usize = 0x1CC; // float
    pub const m_flScale: usize = 0x1D0; // float
    pub const m_flSpeedMin: usize = 0x1D4; // float
    pub const m_flSpeedMax: usize = 0x1D8; // float
    pub const m_nBaseCP: usize = 0x1DC; // int32_t
    pub const m_bUniformSpeed: usize = 0x1E0; // bool
}

pub mod C_INIT_ColorLitPerParticle {
    pub const m_ColorMin: usize = 0x1D8; // Color
    pub const m_ColorMax: usize = 0x1DC; // Color
    pub const m_TintMin: usize = 0x1E0; // Color
    pub const m_TintMax: usize = 0x1E4; // Color
    pub const m_flTintPerc: usize = 0x1E8; // float
    pub const m_nTintBlendMode: usize = 0x1EC; // ParticleColorBlendMode_t
    pub const m_flLightAmplification: usize = 0x1F0; // float
}

pub mod C_INIT_CreateAlongPath {
    pub const m_fMaxDistance: usize = 0x1C0; // float
    pub const m_PathParams: usize = 0x1D0; // CPathParameters
    pub const m_bUseRandomCPs: usize = 0x210; // bool
    pub const m_vEndOffset: usize = 0x214; // Vector
    pub const m_bSaveOffset: usize = 0x220; // bool
}

pub mod C_INIT_CreateFromCPs {
    pub const m_nIncrement: usize = 0x1C0; // int32_t
    pub const m_nMinCP: usize = 0x1C4; // int32_t
    pub const m_nMaxCP: usize = 0x1C8; // int32_t
    pub const m_nDynamicCPCount: usize = 0x1D0; // CParticleCollectionFloatInput
}

pub mod C_INIT_CreateFromParentParticles {
    pub const m_flVelocityScale: usize = 0x1C0; // float
    pub const m_flIncrement: usize = 0x1C4; // float
    pub const m_bRandomDistribution: usize = 0x1C8; // bool
    pub const m_nRandomSeed: usize = 0x1CC; // int32_t
    pub const m_bSubFrame: usize = 0x1D0; // bool
}

pub mod C_INIT_CreateFromPlaneCache {
    pub const m_vecOffsetMin: usize = 0x1C0; // Vector
    pub const m_vecOffsetMax: usize = 0x1CC; // Vector
    pub const m_bUseNormal: usize = 0x1D9; // bool
}

pub mod C_INIT_CreateInEpitrochoid {
    pub const m_nComponent1: usize = 0x1C0; // int32_t
    pub const m_nComponent2: usize = 0x1C4; // int32_t
    pub const m_TransformInput: usize = 0x1C8; // CParticleTransformInput
    pub const m_flParticleDensity: usize = 0x230; // CPerParticleFloatInput
    pub const m_flOffset: usize = 0x388; // CPerParticleFloatInput
    pub const m_flRadius1: usize = 0x4E0; // CPerParticleFloatInput
    pub const m_flRadius2: usize = 0x638; // CPerParticleFloatInput
    pub const m_bUseCount: usize = 0x790; // bool
    pub const m_bUseLocalCoords: usize = 0x791; // bool
    pub const m_bOffsetExistingPos: usize = 0x792; // bool
}

pub mod C_INIT_CreateOnGrid {
    pub const m_nXCount: usize = 0x1C0; // CParticleCollectionFloatInput
    pub const m_nYCount: usize = 0x318; // CParticleCollectionFloatInput
    pub const m_nZCount: usize = 0x470; // CParticleCollectionFloatInput
    pub const m_nXSpacing: usize = 0x5C8; // CParticleCollectionFloatInput
    pub const m_nYSpacing: usize = 0x720; // CParticleCollectionFloatInput
    pub const m_nZSpacing: usize = 0x878; // CParticleCollectionFloatInput
    pub const m_nControlPointNumber: usize = 0x9D0; // int32_t
    pub const m_bLocalSpace: usize = 0x9D4; // bool
    pub const m_bCenter: usize = 0x9D5; // bool
    pub const m_bHollow: usize = 0x9D6; // bool
}

pub mod C_INIT_CreateOnModel {
    pub const m_modelInput: usize = 0x1C0; // CParticleModelInput
    pub const m_transformInput: usize = 0x220; // CParticleTransformInput
    pub const m_nForceInModel: usize = 0x288; // int32_t
    pub const m_nDesiredHitbox: usize = 0x28C; // int32_t
    pub const m_nHitboxValueFromControlPointIndex: usize = 0x290; // int32_t
    pub const m_vecHitBoxScale: usize = 0x298; // CParticleCollectionVecInput
    pub const m_flBoneVelocity: usize = 0x8F0; // float
    pub const m_flMaxBoneVelocity: usize = 0x8F4; // float
    pub const m_vecDirectionBias: usize = 0x8F8; // CParticleCollectionVecInput
    pub const m_HitboxSetName: usize = 0xF50; // char[128]
    pub const m_bLocalCoords: usize = 0xFD0; // bool
    pub const m_bUseBones: usize = 0xFD1; // bool
    pub const m_flShellSize: usize = 0xFD8; // CParticleCollectionFloatInput
}

pub mod C_INIT_CreateOnModelAtHeight {
    pub const m_bUseBones: usize = 0x1C0; // bool
    pub const m_bForceZ: usize = 0x1C1; // bool
    pub const m_nControlPointNumber: usize = 0x1C4; // int32_t
    pub const m_nHeightCP: usize = 0x1C8; // int32_t
    pub const m_bUseWaterHeight: usize = 0x1CC; // bool
    pub const m_flDesiredHeight: usize = 0x1D0; // CParticleCollectionFloatInput
    pub const m_vecHitBoxScale: usize = 0x328; // CParticleCollectionVecInput
    pub const m_vecDirectionBias: usize = 0x980; // CParticleCollectionVecInput
    pub const m_nBiasType: usize = 0xFD8; // ParticleHitboxBiasType_t
    pub const m_bLocalCoords: usize = 0xFDC; // bool
    pub const m_bPreferMovingBoxes: usize = 0xFDD; // bool
    pub const m_HitboxSetName: usize = 0xFDE; // char[128]
    pub const m_flHitboxVelocityScale: usize = 0x1060; // CParticleCollectionFloatInput
    pub const m_flMaxBoneVelocity: usize = 0x11B8; // CParticleCollectionFloatInput
}

pub mod C_INIT_CreateParticleImpulse {
    pub const m_InputRadius: usize = 0x1C0; // CPerParticleFloatInput
    pub const m_InputMagnitude: usize = 0x318; // CPerParticleFloatInput
    pub const m_nFalloffFunction: usize = 0x470; // ParticleFalloffFunction_t
    pub const m_InputFalloffExp: usize = 0x478; // CPerParticleFloatInput
    pub const m_nImpulseType: usize = 0x5D0; // ParticleImpulseType_t
}

pub mod C_INIT_CreatePhyllotaxis {
    pub const m_nControlPointNumber: usize = 0x1C0; // int32_t
    pub const m_nScaleCP: usize = 0x1C4; // int32_t
    pub const m_nComponent: usize = 0x1C8; // int32_t
    pub const m_fRadCentCore: usize = 0x1CC; // float
    pub const m_fRadPerPoint: usize = 0x1D0; // float
    pub const m_fRadPerPointTo: usize = 0x1D4; // float
    pub const m_fpointAngle: usize = 0x1D8; // float
    pub const m_fsizeOverall: usize = 0x1DC; // float
    pub const m_fRadBias: usize = 0x1E0; // float
    pub const m_fMinRad: usize = 0x1E4; // float
    pub const m_fDistBias: usize = 0x1E8; // float
    pub const m_bUseLocalCoords: usize = 0x1EC; // bool
    pub const m_bUseWithContEmit: usize = 0x1ED; // bool
    pub const m_bUseOrigRadius: usize = 0x1EE; // bool
}

pub mod C_INIT_CreateSequentialPath {
    pub const m_fMaxDistance: usize = 0x1C0; // float
    pub const m_flNumToAssign: usize = 0x1C4; // float
    pub const m_bLoop: usize = 0x1C8; // bool
    pub const m_bCPPairs: usize = 0x1C9; // bool
    pub const m_bSaveOffset: usize = 0x1CA; // bool
    pub const m_PathParams: usize = 0x1D0; // CPathParameters
}

pub mod C_INIT_CreateSequentialPathV2 {
    pub const m_fMaxDistance: usize = 0x1C0; // CPerParticleFloatInput
    pub const m_flNumToAssign: usize = 0x318; // CParticleCollectionFloatInput
    pub const m_bLoop: usize = 0x470; // bool
    pub const m_bCPPairs: usize = 0x471; // bool
    pub const m_bSaveOffset: usize = 0x472; // bool
    pub const m_PathParams: usize = 0x480; // CPathParameters
}

pub mod C_INIT_CreateSpiralSphere {
    pub const m_nControlPointNumber: usize = 0x1C0; // int32_t
    pub const m_nOverrideCP: usize = 0x1C4; // int32_t
    pub const m_nDensity: usize = 0x1C8; // int32_t
    pub const m_flInitialRadius: usize = 0x1CC; // float
    pub const m_flInitialSpeedMin: usize = 0x1D0; // float
    pub const m_flInitialSpeedMax: usize = 0x1D4; // float
    pub const m_bUseParticleCount: usize = 0x1D8; // bool
}

pub mod C_INIT_CreateWithinBox {
    pub const m_vecMin: usize = 0x1C0; // CPerParticleVecInput
    pub const m_vecMax: usize = 0x818; // CPerParticleVecInput
    pub const m_nControlPointNumber: usize = 0xE70; // int32_t
    pub const m_bLocalSpace: usize = 0xE74; // bool
    pub const m_randomnessParameters: usize = 0xE78; // CRandomNumberGeneratorParameters
}

pub mod C_INIT_CreateWithinSphereTransform {
    pub const m_fRadiusMin: usize = 0x1C0; // CPerParticleFloatInput
    pub const m_fRadiusMax: usize = 0x318; // CPerParticleFloatInput
    pub const m_vecDistanceBias: usize = 0x470; // CPerParticleVecInput
    pub const m_vecDistanceBiasAbs: usize = 0xAC8; // Vector
    pub const m_TransformInput: usize = 0xAD8; // CParticleTransformInput
    pub const m_fSpeedMin: usize = 0xB40; // CPerParticleFloatInput
    pub const m_fSpeedMax: usize = 0xC98; // CPerParticleFloatInput
    pub const m_fSpeedRandExp: usize = 0xDF0; // float
    pub const m_bLocalCoords: usize = 0xDF4; // bool
    pub const m_flEndCPGrowthTime: usize = 0xDF8; // float
    pub const m_LocalCoordinateSystemSpeedMin: usize = 0xE00; // CPerParticleVecInput
    pub const m_LocalCoordinateSystemSpeedMax: usize = 0x1458; // CPerParticleVecInput
    pub const m_nFieldOutput: usize = 0x1AB0; // ParticleAttributeIndex_t
    pub const m_nFieldVelocity: usize = 0x1AB4; // ParticleAttributeIndex_t
}

pub mod C_INIT_CreationNoise {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_bAbsVal: usize = 0x1C4; // bool
    pub const m_bAbsValInv: usize = 0x1C5; // bool
    pub const m_flOffset: usize = 0x1C8; // float
    pub const m_flOutputMin: usize = 0x1CC; // float
    pub const m_flOutputMax: usize = 0x1D0; // float
    pub const m_flNoiseScale: usize = 0x1D4; // float
    pub const m_flNoiseScaleLoc: usize = 0x1D8; // float
    pub const m_vecOffsetLoc: usize = 0x1DC; // Vector
    pub const m_flWorldTimeScale: usize = 0x1E8; // float
}

pub mod C_INIT_DistanceCull {
    pub const m_nControlPoint: usize = 0x1C0; // int32_t
    pub const m_flDistance: usize = 0x1C8; // CParticleCollectionFloatInput
    pub const m_bCullInside: usize = 0x320; // bool
}

pub mod C_INIT_DistanceToCPInit {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_flInputMin: usize = 0x1C8; // CPerParticleFloatInput
    pub const m_flInputMax: usize = 0x320; // CPerParticleFloatInput
    pub const m_flOutputMin: usize = 0x478; // CPerParticleFloatInput
    pub const m_flOutputMax: usize = 0x5D0; // CPerParticleFloatInput
    pub const m_nStartCP: usize = 0x728; // int32_t
    pub const m_bLOS: usize = 0x72C; // bool
    pub const m_CollisionGroupName: usize = 0x72D; // char[128]
    pub const m_nTraceSet: usize = 0x7B0; // ParticleTraceSet_t
    pub const m_flMaxTraceLength: usize = 0x7B8; // CPerParticleFloatInput
    pub const m_flLOSScale: usize = 0x910; // float
    pub const m_nSetMethod: usize = 0x914; // ParticleSetMethod_t
    pub const m_bActiveRange: usize = 0x918; // bool
    pub const m_vecDistanceScale: usize = 0x91C; // Vector
    pub const m_flRemapBias: usize = 0x928; // float
}

pub mod C_INIT_DistanceToNeighborCull {
    pub const m_flDistance: usize = 0x1C0; // CPerParticleFloatInput
}

pub mod C_INIT_GlobalScale {
    pub const m_flScale: usize = 0x1C0; // float
    pub const m_nScaleControlPointNumber: usize = 0x1C4; // int32_t
    pub const m_nControlPointNumber: usize = 0x1C8; // int32_t
    pub const m_bScaleRadius: usize = 0x1CC; // bool
    pub const m_bScalePosition: usize = 0x1CD; // bool
    pub const m_bScaleVelocity: usize = 0x1CE; // bool
}

pub mod C_INIT_InheritFromParentParticles {
    pub const m_flScale: usize = 0x1C0; // float
    pub const m_nFieldOutput: usize = 0x1C4; // ParticleAttributeIndex_t
    pub const m_nIncrement: usize = 0x1C8; // int32_t
    pub const m_bRandomDistribution: usize = 0x1CC; // bool
    pub const m_nRandomSeed: usize = 0x1D0; // int32_t
}

pub mod C_INIT_InheritVelocity {
    pub const m_nControlPointNumber: usize = 0x1C0; // int32_t
    pub const m_flVelocityScale: usize = 0x1C4; // float
}

pub mod C_INIT_InitFloat {
    pub const m_InputValue: usize = 0x1C0; // CPerParticleFloatInput
    pub const m_nOutputField: usize = 0x318; // ParticleAttributeIndex_t
    pub const m_nSetMethod: usize = 0x31C; // ParticleSetMethod_t
    pub const m_InputStrength: usize = 0x320; // CPerParticleFloatInput
}

pub mod C_INIT_InitFloatCollection {
    pub const m_InputValue: usize = 0x1C0; // CParticleCollectionFloatInput
    pub const m_nOutputField: usize = 0x318; // ParticleAttributeIndex_t
}

pub mod C_INIT_InitFromCPSnapshot {
    pub const m_nControlPointNumber: usize = 0x1C0; // int32_t
    pub const m_nAttributeToRead: usize = 0x1C4; // ParticleAttributeIndex_t
    pub const m_nAttributeToWrite: usize = 0x1C8; // ParticleAttributeIndex_t
    pub const m_nLocalSpaceCP: usize = 0x1CC; // int32_t
    pub const m_bRandom: usize = 0x1D0; // bool
    pub const m_bReverse: usize = 0x1D1; // bool
    pub const m_nSnapShotIncrement: usize = 0x1D8; // CParticleCollectionFloatInput
    pub const m_nManualSnapshotIndex: usize = 0x330; // CPerParticleFloatInput
    pub const m_nRandomSeed: usize = 0x488; // int32_t
    pub const m_bLocalSpaceAngles: usize = 0x48C; // bool
}

pub mod C_INIT_InitFromParentKilled {
    pub const m_nAttributeToCopy: usize = 0x1C0; // ParticleAttributeIndex_t
}

pub mod C_INIT_InitFromVectorFieldSnapshot {
    pub const m_nControlPointNumber: usize = 0x1C0; // int32_t
    pub const m_nLocalSpaceCP: usize = 0x1C4; // int32_t
    pub const m_nWeightUpdateCP: usize = 0x1C8; // int32_t
    pub const m_bUseVerticalVelocity: usize = 0x1CC; // bool
    pub const m_vecScale: usize = 0x1D0; // CPerParticleVecInput
}

pub mod C_INIT_InitSkinnedPositionFromCPSnapshot {
    pub const m_nSnapshotControlPointNumber: usize = 0x1C0; // int32_t
    pub const m_nControlPointNumber: usize = 0x1C4; // int32_t
    pub const m_bRandom: usize = 0x1C8; // bool
    pub const m_nRandomSeed: usize = 0x1CC; // int32_t
    pub const m_bRigid: usize = 0x1D0; // bool
    pub const m_bSetNormal: usize = 0x1D1; // bool
    pub const m_bIgnoreDt: usize = 0x1D2; // bool
    pub const m_flMinNormalVelocity: usize = 0x1D4; // float
    pub const m_flMaxNormalVelocity: usize = 0x1D8; // float
    pub const m_flIncrement: usize = 0x1DC; // float
    pub const m_nFullLoopIncrement: usize = 0x1E0; // int32_t
    pub const m_nSnapShotStartPoint: usize = 0x1E4; // int32_t
    pub const m_flBoneVelocity: usize = 0x1E8; // float
    pub const m_flBoneVelocityMax: usize = 0x1EC; // float
    pub const m_bCopyColor: usize = 0x1F0; // bool
    pub const m_bCopyAlpha: usize = 0x1F1; // bool
    pub const m_bSetRadius: usize = 0x1F2; // bool
}

pub mod C_INIT_InitVec {
    pub const m_InputValue: usize = 0x1C0; // CPerParticleVecInput
    pub const m_nOutputField: usize = 0x818; // ParticleAttributeIndex_t
    pub const m_nSetMethod: usize = 0x81C; // ParticleSetMethod_t
    pub const m_bNormalizedOutput: usize = 0x820; // bool
    pub const m_bWritePreviousPosition: usize = 0x821; // bool
}

pub mod C_INIT_InitVecCollection {
    pub const m_InputValue: usize = 0x1C0; // CParticleCollectionVecInput
    pub const m_nOutputField: usize = 0x818; // ParticleAttributeIndex_t
}

pub mod C_INIT_InitialRepulsionVelocity {
    pub const m_CollisionGroupName: usize = 0x1C0; // char[128]
    pub const m_nTraceSet: usize = 0x240; // ParticleTraceSet_t
    pub const m_vecOutputMin: usize = 0x244; // Vector
    pub const m_vecOutputMax: usize = 0x250; // Vector
    pub const m_nControlPointNumber: usize = 0x25C; // int32_t
    pub const m_bPerParticle: usize = 0x260; // bool
    pub const m_bTranslate: usize = 0x261; // bool
    pub const m_bProportional: usize = 0x262; // bool
    pub const m_flTraceLength: usize = 0x264; // float
    pub const m_bPerParticleTR: usize = 0x268; // bool
    pub const m_bInherit: usize = 0x269; // bool
    pub const m_nChildCP: usize = 0x26C; // int32_t
    pub const m_nChildGroupID: usize = 0x270; // int32_t
}

pub mod C_INIT_InitialSequenceFromModel {
    pub const m_nControlPointNumber: usize = 0x1C0; // int32_t
    pub const m_nFieldOutput: usize = 0x1C4; // ParticleAttributeIndex_t
    pub const m_nFieldOutputAnim: usize = 0x1C8; // ParticleAttributeIndex_t
    pub const m_flInputMin: usize = 0x1CC; // float
    pub const m_flInputMax: usize = 0x1D0; // float
    pub const m_flOutputMin: usize = 0x1D4; // float
    pub const m_flOutputMax: usize = 0x1D8; // float
    pub const m_nSetMethod: usize = 0x1DC; // ParticleSetMethod_t
}

pub mod C_INIT_InitialVelocityFromHitbox {
    pub const m_flVelocityMin: usize = 0x1C0; // float
    pub const m_flVelocityMax: usize = 0x1C4; // float
    pub const m_nControlPointNumber: usize = 0x1C8; // int32_t
    pub const m_HitboxSetName: usize = 0x1CC; // char[128]
    pub const m_bUseBones: usize = 0x24C; // bool
}

pub mod C_INIT_InitialVelocityNoise {
    pub const m_vecAbsVal: usize = 0x1C0; // Vector
    pub const m_vecAbsValInv: usize = 0x1CC; // Vector
    pub const m_vecOffsetLoc: usize = 0x1D8; // CPerParticleVecInput
    pub const m_flOffset: usize = 0x830; // CPerParticleFloatInput
    pub const m_vecOutputMin: usize = 0x988; // CPerParticleVecInput
    pub const m_vecOutputMax: usize = 0xFE0; // CPerParticleVecInput
    pub const m_flNoiseScale: usize = 0x1638; // CPerParticleFloatInput
    pub const m_flNoiseScaleLoc: usize = 0x1790; // CPerParticleFloatInput
    pub const m_TransformInput: usize = 0x18E8; // CParticleTransformInput
    pub const m_bIgnoreDt: usize = 0x1950; // bool
}

pub mod C_INIT_LifespanFromVelocity {
    pub const m_vecComponentScale: usize = 0x1C0; // Vector
    pub const m_flTraceOffset: usize = 0x1CC; // float
    pub const m_flMaxTraceLength: usize = 0x1D0; // float
    pub const m_flTraceTolerance: usize = 0x1D4; // float
    pub const m_nMaxPlanes: usize = 0x1D8; // int32_t
    pub const m_CollisionGroupName: usize = 0x1E0; // char[128]
    pub const m_nTraceSet: usize = 0x260; // ParticleTraceSet_t
    pub const m_bIncludeWater: usize = 0x270; // bool
}

pub mod C_INIT_ModelCull {
    pub const m_nControlPointNumber: usize = 0x1C0; // int32_t
    pub const m_bBoundBox: usize = 0x1C4; // bool
    pub const m_bCullOutside: usize = 0x1C5; // bool
    pub const m_bUseBones: usize = 0x1C6; // bool
    pub const m_HitboxSetName: usize = 0x1C7; // char[128]
}

pub mod C_INIT_MoveBetweenPoints {
    pub const m_flSpeedMin: usize = 0x1C0; // CPerParticleFloatInput
    pub const m_flSpeedMax: usize = 0x318; // CPerParticleFloatInput
    pub const m_flEndSpread: usize = 0x470; // CPerParticleFloatInput
    pub const m_flStartOffset: usize = 0x5C8; // CPerParticleFloatInput
    pub const m_flEndOffset: usize = 0x720; // CPerParticleFloatInput
    pub const m_nEndControlPointNumber: usize = 0x878; // int32_t
    pub const m_bTrailBias: usize = 0x87C; // bool
}

pub mod C_INIT_NormalAlignToCP {
    pub const m_transformInput: usize = 0x1C0; // CParticleTransformInput
    pub const m_nControlPointAxis: usize = 0x228; // ParticleControlPointAxis_t
}

pub mod C_INIT_NormalOffset {
    pub const m_OffsetMin: usize = 0x1C0; // Vector
    pub const m_OffsetMax: usize = 0x1CC; // Vector
    pub const m_nControlPointNumber: usize = 0x1D8; // int32_t
    pub const m_bLocalCoords: usize = 0x1DC; // bool
    pub const m_bNormalize: usize = 0x1DD; // bool
}

pub mod C_INIT_OffsetVectorToVector {
    pub const m_nFieldInput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_nFieldOutput: usize = 0x1C4; // ParticleAttributeIndex_t
    pub const m_vecOutputMin: usize = 0x1C8; // Vector
    pub const m_vecOutputMax: usize = 0x1D4; // Vector
    pub const m_randomnessParameters: usize = 0x1E0; // CRandomNumberGeneratorParameters
}

pub mod C_INIT_Orient2DRelToCP {
    pub const m_nCP: usize = 0x1C0; // int32_t
    pub const m_nFieldOutput: usize = 0x1C4; // ParticleAttributeIndex_t
    pub const m_flRotOffset: usize = 0x1C8; // float
}

pub mod C_INIT_PlaneCull {
    pub const m_nControlPoint: usize = 0x1C0; // int32_t
    pub const m_flDistance: usize = 0x1C8; // CParticleCollectionFloatInput
    pub const m_bCullInside: usize = 0x320; // bool
}

pub mod C_INIT_PointList {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_pointList: usize = 0x1C8; // CUtlVector<PointDefinition_t>
    pub const m_bPlaceAlongPath: usize = 0x1E0; // bool
    pub const m_bClosedLoop: usize = 0x1E1; // bool
    pub const m_nNumPointsAlongPath: usize = 0x1E4; // int32_t
}

pub mod C_INIT_PositionOffset {
    pub const m_OffsetMin: usize = 0x1C0; // CPerParticleVecInput
    pub const m_OffsetMax: usize = 0x818; // CPerParticleVecInput
    pub const m_TransformInput: usize = 0xE70; // CParticleTransformInput
    pub const m_bLocalCoords: usize = 0xED8; // bool
    pub const m_bProportional: usize = 0xED9; // bool
    pub const m_randomnessParameters: usize = 0xEDC; // CRandomNumberGeneratorParameters
}

pub mod C_INIT_PositionOffsetToCP {
    pub const m_nControlPointNumberStart: usize = 0x1C0; // int32_t
    pub const m_nControlPointNumberEnd: usize = 0x1C4; // int32_t
    pub const m_bLocalCoords: usize = 0x1C8; // bool
}

pub mod C_INIT_PositionPlaceOnGround {
    pub const m_flOffset: usize = 0x1C0; // CPerParticleFloatInput
    pub const m_flMaxTraceLength: usize = 0x318; // CPerParticleFloatInput
    pub const m_CollisionGroupName: usize = 0x470; // char[128]
    pub const m_nTraceSet: usize = 0x4F0; // ParticleTraceSet_t
    pub const m_nTraceMissBehavior: usize = 0x500; // ParticleTraceMissBehavior_t
    pub const m_bIncludeWater: usize = 0x504; // bool
    pub const m_bSetNormal: usize = 0x505; // bool
    pub const m_bSetPXYZOnly: usize = 0x506; // bool
    pub const m_bTraceAlongNormal: usize = 0x507; // bool
    pub const m_bOffsetonColOnly: usize = 0x508; // bool
    pub const m_flOffsetByRadiusFactor: usize = 0x50C; // float
    pub const m_nPreserveOffsetCP: usize = 0x510; // int32_t
    pub const m_nIgnoreCP: usize = 0x514; // int32_t
}

pub mod C_INIT_PositionWarp {
    pub const m_vecWarpMin: usize = 0x1C0; // CParticleCollectionVecInput
    pub const m_vecWarpMax: usize = 0x818; // CParticleCollectionVecInput
    pub const m_nScaleControlPointNumber: usize = 0xE70; // int32_t
    pub const m_nControlPointNumber: usize = 0xE74; // int32_t
    pub const m_nRadiusComponent: usize = 0xE78; // int32_t
    pub const m_flWarpTime: usize = 0xE7C; // float
    pub const m_flWarpStartTime: usize = 0xE80; // float
    pub const m_flPrevPosScale: usize = 0xE84; // float
    pub const m_bInvertWarp: usize = 0xE88; // bool
    pub const m_bUseCount: usize = 0xE89; // bool
}

pub mod C_INIT_PositionWarpScalar {
    pub const m_vecWarpMin: usize = 0x1C0; // Vector
    pub const m_vecWarpMax: usize = 0x1CC; // Vector
    pub const m_InputValue: usize = 0x1D8; // CPerParticleFloatInput
    pub const m_flPrevPosScale: usize = 0x330; // float
    pub const m_nScaleControlPointNumber: usize = 0x334; // int32_t
    pub const m_nControlPointNumber: usize = 0x338; // int32_t
}

pub mod C_INIT_QuantizeFloat {
    pub const m_InputValue: usize = 0x1C0; // CPerParticleFloatInput
    pub const m_nOutputField: usize = 0x318; // ParticleAttributeIndex_t
}

pub mod C_INIT_RadiusFromCPObject {
    pub const m_nControlPoint: usize = 0x1C0; // int32_t
}

pub mod C_INIT_RandomAlpha {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_nAlphaMin: usize = 0x1C4; // int32_t
    pub const m_nAlphaMax: usize = 0x1C8; // int32_t
    pub const m_flAlphaRandExponent: usize = 0x1D4; // float
}

pub mod C_INIT_RandomAlphaWindowThreshold {
    pub const m_flMin: usize = 0x1C0; // float
    pub const m_flMax: usize = 0x1C4; // float
    pub const m_flExponent: usize = 0x1C8; // float
}

pub mod C_INIT_RandomColor {
    pub const m_ColorMin: usize = 0x1DC; // Color
    pub const m_ColorMax: usize = 0x1E0; // Color
    pub const m_TintMin: usize = 0x1E4; // Color
    pub const m_TintMax: usize = 0x1E8; // Color
    pub const m_flTintPerc: usize = 0x1EC; // float
    pub const m_flUpdateThreshold: usize = 0x1F0; // float
    pub const m_nTintCP: usize = 0x1F4; // int32_t
    pub const m_nFieldOutput: usize = 0x1F8; // ParticleAttributeIndex_t
    pub const m_nTintBlendMode: usize = 0x1FC; // ParticleColorBlendMode_t
    pub const m_flLightAmplification: usize = 0x200; // float
}

pub mod C_INIT_RandomLifeTime {
    pub const m_fLifetimeMin: usize = 0x1C0; // float
    pub const m_fLifetimeMax: usize = 0x1C4; // float
    pub const m_fLifetimeRandExponent: usize = 0x1C8; // float
}

pub mod C_INIT_RandomModelSequence {
    pub const m_ActivityName: usize = 0x1C0; // char[256]
    pub const m_SequenceName: usize = 0x2C0; // char[256]
    pub const m_hModel: usize = 0x3C0; // CStrongHandle<InfoForResourceTypeCModel>
}

pub mod C_INIT_RandomNamedModelElement {
    pub const m_hModel: usize = 0x1C0; // CStrongHandle<InfoForResourceTypeCModel>
    pub const m_names: usize = 0x1C8; // CUtlVector<CUtlString>
    pub const m_bShuffle: usize = 0x1E0; // bool
    pub const m_bLinear: usize = 0x1E1; // bool
    pub const m_bModelFromRenderer: usize = 0x1E2; // bool
    pub const m_nFieldOutput: usize = 0x1E4; // ParticleAttributeIndex_t
}

pub mod C_INIT_RandomRadius {
    pub const m_flRadiusMin: usize = 0x1C0; // float
    pub const m_flRadiusMax: usize = 0x1C4; // float
    pub const m_flRadiusRandExponent: usize = 0x1C8; // float
}

pub mod C_INIT_RandomScalar {
    pub const m_flMin: usize = 0x1C0; // float
    pub const m_flMax: usize = 0x1C4; // float
    pub const m_flExponent: usize = 0x1C8; // float
    pub const m_nFieldOutput: usize = 0x1CC; // ParticleAttributeIndex_t
}

pub mod C_INIT_RandomSecondSequence {
    pub const m_nSequenceMin: usize = 0x1C0; // int32_t
    pub const m_nSequenceMax: usize = 0x1C4; // int32_t
}

pub mod C_INIT_RandomSequence {
    pub const m_nSequenceMin: usize = 0x1C0; // int32_t
    pub const m_nSequenceMax: usize = 0x1C4; // int32_t
    pub const m_bShuffle: usize = 0x1C8; // bool
    pub const m_bLinear: usize = 0x1C9; // bool
    pub const m_WeightedList: usize = 0x1D0; // CUtlVector<SequenceWeightedList_t>
}

pub mod C_INIT_RandomTrailLength {
    pub const m_flMinLength: usize = 0x1C0; // float
    pub const m_flMaxLength: usize = 0x1C4; // float
    pub const m_flLengthRandExponent: usize = 0x1C8; // float
}

pub mod C_INIT_RandomVector {
    pub const m_vecMin: usize = 0x1C0; // Vector
    pub const m_vecMax: usize = 0x1CC; // Vector
    pub const m_nFieldOutput: usize = 0x1D8; // ParticleAttributeIndex_t
    pub const m_randomnessParameters: usize = 0x1DC; // CRandomNumberGeneratorParameters
}

pub mod C_INIT_RandomVectorComponent {
    pub const m_flMin: usize = 0x1C0; // float
    pub const m_flMax: usize = 0x1C4; // float
    pub const m_nFieldOutput: usize = 0x1C8; // ParticleAttributeIndex_t
    pub const m_nComponent: usize = 0x1CC; // int32_t
}

pub mod C_INIT_RandomYawFlip {
    pub const m_flPercent: usize = 0x1C0; // float
}

pub mod C_INIT_RemapCPtoScalar {
    pub const m_nCPInput: usize = 0x1C0; // int32_t
    pub const m_nFieldOutput: usize = 0x1C4; // ParticleAttributeIndex_t
    pub const m_nField: usize = 0x1C8; // int32_t
    pub const m_flInputMin: usize = 0x1CC; // float
    pub const m_flInputMax: usize = 0x1D0; // float
    pub const m_flOutputMin: usize = 0x1D4; // float
    pub const m_flOutputMax: usize = 0x1D8; // float
    pub const m_flStartTime: usize = 0x1DC; // float
    pub const m_flEndTime: usize = 0x1E0; // float
    pub const m_nSetMethod: usize = 0x1E4; // ParticleSetMethod_t
    pub const m_flRemapBias: usize = 0x1E8; // float
}

pub mod C_INIT_RemapInitialDirectionToTransformToVector {
    pub const m_TransformInput: usize = 0x1C0; // CParticleTransformInput
    pub const m_nFieldOutput: usize = 0x228; // ParticleAttributeIndex_t
    pub const m_flScale: usize = 0x22C; // float
    pub const m_flOffsetRot: usize = 0x230; // float
    pub const m_vecOffsetAxis: usize = 0x234; // Vector
    pub const m_bNormalize: usize = 0x240; // bool
}

pub mod C_INIT_RemapInitialTransformDirectionToRotation {
    pub const m_TransformInput: usize = 0x1C0; // CParticleTransformInput
    pub const m_nFieldOutput: usize = 0x228; // ParticleAttributeIndex_t
    pub const m_flOffsetRot: usize = 0x22C; // float
    pub const m_nComponent: usize = 0x230; // int32_t
}

pub mod C_INIT_RemapInitialVisibilityScalar {
    pub const m_nFieldOutput: usize = 0x1C4; // ParticleAttributeIndex_t
    pub const m_flInputMin: usize = 0x1C8; // float
    pub const m_flInputMax: usize = 0x1CC; // float
    pub const m_flOutputMin: usize = 0x1D0; // float
    pub const m_flOutputMax: usize = 0x1D4; // float
}

pub mod C_INIT_RemapNamedModelElementToScalar {
    pub const m_hModel: usize = 0x1C0; // CStrongHandle<InfoForResourceTypeCModel>
    pub const m_names: usize = 0x1C8; // CUtlVector<CUtlString>
    pub const m_values: usize = 0x1E0; // CUtlVector<float>
    pub const m_nFieldInput: usize = 0x1F8; // ParticleAttributeIndex_t
    pub const m_nFieldOutput: usize = 0x1FC; // ParticleAttributeIndex_t
    pub const m_nSetMethod: usize = 0x200; // ParticleSetMethod_t
    pub const m_bModelFromRenderer: usize = 0x204; // bool
}

pub mod C_INIT_RemapParticleCountToNamedModelElementScalar {
    pub const m_hModel: usize = 0x1F0; // CStrongHandle<InfoForResourceTypeCModel>
    pub const m_outputMinName: usize = 0x1F8; // CUtlString
    pub const m_outputMaxName: usize = 0x200; // CUtlString
    pub const m_bModelFromRenderer: usize = 0x208; // bool
}

pub mod C_INIT_RemapParticleCountToScalar {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_nInputMin: usize = 0x1C4; // int32_t
    pub const m_nInputMax: usize = 0x1C8; // int32_t
    pub const m_nScaleControlPoint: usize = 0x1CC; // int32_t
    pub const m_nScaleControlPointField: usize = 0x1D0; // int32_t
    pub const m_flOutputMin: usize = 0x1D4; // float
    pub const m_flOutputMax: usize = 0x1D8; // float
    pub const m_nSetMethod: usize = 0x1DC; // ParticleSetMethod_t
    pub const m_bActiveRange: usize = 0x1E0; // bool
    pub const m_bInvert: usize = 0x1E1; // bool
    pub const m_bWrap: usize = 0x1E2; // bool
    pub const m_flRemapBias: usize = 0x1E4; // float
}

pub mod C_INIT_RemapQAnglesToRotation {
    pub const m_TransformInput: usize = 0x1C0; // CParticleTransformInput
}

pub mod C_INIT_RemapScalar {
    pub const m_nFieldInput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_nFieldOutput: usize = 0x1C4; // ParticleAttributeIndex_t
    pub const m_flInputMin: usize = 0x1C8; // float
    pub const m_flInputMax: usize = 0x1CC; // float
    pub const m_flOutputMin: usize = 0x1D0; // float
    pub const m_flOutputMax: usize = 0x1D4; // float
    pub const m_flStartTime: usize = 0x1D8; // float
    pub const m_flEndTime: usize = 0x1DC; // float
    pub const m_nSetMethod: usize = 0x1E0; // ParticleSetMethod_t
    pub const m_bActiveRange: usize = 0x1E4; // bool
    pub const m_flRemapBias: usize = 0x1E8; // float
}

pub mod C_INIT_RemapScalarToVector {
    pub const m_nFieldInput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_nFieldOutput: usize = 0x1C4; // ParticleAttributeIndex_t
    pub const m_flInputMin: usize = 0x1C8; // float
    pub const m_flInputMax: usize = 0x1CC; // float
    pub const m_vecOutputMin: usize = 0x1D0; // Vector
    pub const m_vecOutputMax: usize = 0x1DC; // Vector
    pub const m_flStartTime: usize = 0x1E8; // float
    pub const m_flEndTime: usize = 0x1EC; // float
    pub const m_nSetMethod: usize = 0x1F0; // ParticleSetMethod_t
    pub const m_nControlPointNumber: usize = 0x1F4; // int32_t
    pub const m_bLocalCoords: usize = 0x1F8; // bool
    pub const m_flRemapBias: usize = 0x1FC; // float
}

pub mod C_INIT_RemapSpeedToScalar {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_nControlPointNumber: usize = 0x1C4; // int32_t
    pub const m_flStartTime: usize = 0x1C8; // float
    pub const m_flEndTime: usize = 0x1CC; // float
    pub const m_flInputMin: usize = 0x1D0; // float
    pub const m_flInputMax: usize = 0x1D4; // float
    pub const m_flOutputMin: usize = 0x1D8; // float
    pub const m_flOutputMax: usize = 0x1DC; // float
    pub const m_nSetMethod: usize = 0x1E0; // ParticleSetMethod_t
    pub const m_bPerParticle: usize = 0x1E4; // bool
}

pub mod C_INIT_RemapTransformOrientationToRotations {
    pub const m_TransformInput: usize = 0x1C0; // CParticleTransformInput
    pub const m_vecRotation: usize = 0x228; // Vector
    pub const m_bUseQuat: usize = 0x234; // bool
    pub const m_bWriteNormal: usize = 0x235; // bool
}

pub mod C_INIT_RemapTransformToVector {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_vInputMin: usize = 0x1C4; // Vector
    pub const m_vInputMax: usize = 0x1D0; // Vector
    pub const m_vOutputMin: usize = 0x1DC; // Vector
    pub const m_vOutputMax: usize = 0x1E8; // Vector
    pub const m_TransformInput: usize = 0x1F8; // CParticleTransformInput
    pub const m_LocalSpaceTransform: usize = 0x260; // CParticleTransformInput
    pub const m_flStartTime: usize = 0x2C8; // float
    pub const m_flEndTime: usize = 0x2CC; // float
    pub const m_nSetMethod: usize = 0x2D0; // ParticleSetMethod_t
    pub const m_bOffset: usize = 0x2D4; // bool
    pub const m_bAccelerate: usize = 0x2D5; // bool
    pub const m_flRemapBias: usize = 0x2D8; // float
}

pub mod C_INIT_RingWave {
    pub const m_TransformInput: usize = 0x1C0; // CParticleTransformInput
    pub const m_flParticlesPerOrbit: usize = 0x228; // CParticleCollectionFloatInput
    pub const m_flInitialRadius: usize = 0x380; // CPerParticleFloatInput
    pub const m_flThickness: usize = 0x4D8; // CPerParticleFloatInput
    pub const m_flInitialSpeedMin: usize = 0x630; // CPerParticleFloatInput
    pub const m_flInitialSpeedMax: usize = 0x788; // CPerParticleFloatInput
    pub const m_flRoll: usize = 0x8E0; // CPerParticleFloatInput
    pub const m_flPitch: usize = 0xA38; // CPerParticleFloatInput
    pub const m_flYaw: usize = 0xB90; // CPerParticleFloatInput
    pub const m_bEvenDistribution: usize = 0xCE8; // bool
    pub const m_bXYVelocityOnly: usize = 0xCE9; // bool
}

pub mod C_INIT_RtEnvCull {
    pub const m_vecTestDir: usize = 0x1C0; // Vector
    pub const m_vecTestNormal: usize = 0x1CC; // Vector
    pub const m_bUseVelocity: usize = 0x1D8; // bool
    pub const m_bCullOnMiss: usize = 0x1D9; // bool
    pub const m_bLifeAdjust: usize = 0x1DA; // bool
    pub const m_RtEnvName: usize = 0x1DB; // char[128]
    pub const m_nRTEnvCP: usize = 0x25C; // int32_t
    pub const m_nComponent: usize = 0x260; // int32_t
}

pub mod C_INIT_ScaleVelocity {
    pub const m_vecScale: usize = 0x1C0; // CParticleCollectionVecInput
}

pub mod C_INIT_SequenceFromCP {
    pub const m_bKillUnused: usize = 0x1C0; // bool
    pub const m_bRadiusScale: usize = 0x1C1; // bool
    pub const m_nCP: usize = 0x1C4; // int32_t
    pub const m_vecOffset: usize = 0x1C8; // Vector
}

pub mod C_INIT_SequenceLifeTime {
    pub const m_flFramerate: usize = 0x1C0; // float
}

pub mod C_INIT_SetHitboxToClosest {
    pub const m_nControlPointNumber: usize = 0x1C0; // int32_t
    pub const m_nDesiredHitbox: usize = 0x1C4; // int32_t
    pub const m_vecHitBoxScale: usize = 0x1C8; // CParticleCollectionVecInput
    pub const m_HitboxSetName: usize = 0x820; // char[128]
    pub const m_bUseBones: usize = 0x8A0; // bool
    pub const m_bUseClosestPointOnHitbox: usize = 0x8A1; // bool
    pub const m_nTestType: usize = 0x8A4; // ClosestPointTestType_t
    pub const m_flHybridRatio: usize = 0x8A8; // CParticleCollectionFloatInput
    pub const m_bUpdatePosition: usize = 0xA00; // bool
}

pub mod C_INIT_SetHitboxToModel {
    pub const m_nControlPointNumber: usize = 0x1C0; // int32_t
    pub const m_nForceInModel: usize = 0x1C4; // int32_t
    pub const m_nDesiredHitbox: usize = 0x1C8; // int32_t
    pub const m_vecHitBoxScale: usize = 0x1D0; // CParticleCollectionVecInput
    pub const m_vecDirectionBias: usize = 0x828; // Vector
    pub const m_bMaintainHitbox: usize = 0x834; // bool
    pub const m_bUseBones: usize = 0x835; // bool
    pub const m_HitboxSetName: usize = 0x836; // char[128]
    pub const m_flShellSize: usize = 0x8B8; // CParticleCollectionFloatInput
}

pub mod C_INIT_SetRigidAttachment {
    pub const m_nControlPointNumber: usize = 0x1C0; // int32_t
    pub const m_nFieldInput: usize = 0x1C4; // ParticleAttributeIndex_t
    pub const m_nFieldOutput: usize = 0x1C8; // ParticleAttributeIndex_t
    pub const m_bLocalSpace: usize = 0x1CC; // bool
}

pub mod C_INIT_SetVectorAttributeToVectorExpression {
    pub const m_nExpression: usize = 0x1C0; // VectorExpressionType_t
    pub const m_vInput1: usize = 0x1C8; // CPerParticleVecInput
    pub const m_vInput2: usize = 0x820; // CPerParticleVecInput
    pub const m_nOutputField: usize = 0xE78; // ParticleAttributeIndex_t
    pub const m_nSetMethod: usize = 0xE7C; // ParticleSetMethod_t
    pub const m_bNormalizedOutput: usize = 0xE80; // bool
}

pub mod C_INIT_StatusEffect {
    pub const m_nDetail2Combo: usize = 0x1C0; // Detail2Combo_t
    pub const m_flDetail2Rotation: usize = 0x1C4; // float
    pub const m_flDetail2Scale: usize = 0x1C8; // float
    pub const m_flDetail2BlendFactor: usize = 0x1CC; // float
    pub const m_flColorWarpIntensity: usize = 0x1D0; // float
    pub const m_flDiffuseWarpBlendToFull: usize = 0x1D4; // float
    pub const m_flEnvMapIntensity: usize = 0x1D8; // float
    pub const m_flAmbientScale: usize = 0x1DC; // float
    pub const m_specularColor: usize = 0x1E0; // Color
    pub const m_flSpecularScale: usize = 0x1E4; // float
    pub const m_flSpecularExponent: usize = 0x1E8; // float
    pub const m_flSpecularExponentBlendToFull: usize = 0x1EC; // float
    pub const m_flSpecularBlendToFull: usize = 0x1F0; // float
    pub const m_rimLightColor: usize = 0x1F4; // Color
    pub const m_flRimLightScale: usize = 0x1F8; // float
    pub const m_flReflectionsTintByBaseBlendToNone: usize = 0x1FC; // float
    pub const m_flMetalnessBlendToFull: usize = 0x200; // float
    pub const m_flSelfIllumBlendToFull: usize = 0x204; // float
}

pub mod C_INIT_StatusEffectCitadel {
    pub const m_flSFXColorWarpAmount: usize = 0x1C0; // float
    pub const m_flSFXNormalAmount: usize = 0x1C4; // float
    pub const m_flSFXMetalnessAmount: usize = 0x1C8; // float
    pub const m_flSFXRoughnessAmount: usize = 0x1CC; // float
    pub const m_flSFXSelfIllumAmount: usize = 0x1D0; // float
    pub const m_flSFXSScale: usize = 0x1D4; // float
    pub const m_flSFXSScrollX: usize = 0x1D8; // float
    pub const m_flSFXSScrollY: usize = 0x1DC; // float
    pub const m_flSFXSScrollZ: usize = 0x1E0; // float
    pub const m_flSFXSOffsetX: usize = 0x1E4; // float
    pub const m_flSFXSOffsetY: usize = 0x1E8; // float
    pub const m_flSFXSOffsetZ: usize = 0x1EC; // float
    pub const m_nDetailCombo: usize = 0x1F0; // DetailCombo_t
    pub const m_flSFXSDetailAmount: usize = 0x1F4; // float
    pub const m_flSFXSDetailScale: usize = 0x1F8; // float
    pub const m_flSFXSDetailScrollX: usize = 0x1FC; // float
    pub const m_flSFXSDetailScrollY: usize = 0x200; // float
    pub const m_flSFXSDetailScrollZ: usize = 0x204; // float
    pub const m_flSFXSUseModelUVs: usize = 0x208; // float
}

pub mod C_INIT_VelocityFromCP {
    pub const m_velocityInput: usize = 0x1C0; // CParticleCollectionVecInput
    pub const m_transformInput: usize = 0x818; // CParticleTransformInput
    pub const m_flVelocityScale: usize = 0x880; // float
    pub const m_bDirectionOnly: usize = 0x884; // bool
}

pub mod C_INIT_VelocityFromNormal {
    pub const m_fSpeedMin: usize = 0x1C0; // float
    pub const m_fSpeedMax: usize = 0x1C4; // float
    pub const m_bIgnoreDt: usize = 0x1C8; // bool
}

pub mod C_INIT_VelocityRadialRandom {
    pub const m_nControlPointNumber: usize = 0x1C0; // int32_t
    pub const m_fSpeedMin: usize = 0x1C4; // float
    pub const m_fSpeedMax: usize = 0x1C8; // float
    pub const m_vecLocalCoordinateSystemSpeedScale: usize = 0x1CC; // Vector
    pub const m_bIgnoreDelta: usize = 0x1D9; // bool
}

pub mod C_INIT_VelocityRandom {
    pub const m_nControlPointNumber: usize = 0x1C0; // int32_t
    pub const m_fSpeedMin: usize = 0x1C8; // CPerParticleFloatInput
    pub const m_fSpeedMax: usize = 0x320; // CPerParticleFloatInput
    pub const m_LocalCoordinateSystemSpeedMin: usize = 0x478; // CPerParticleVecInput
    pub const m_LocalCoordinateSystemSpeedMax: usize = 0xAD0; // CPerParticleVecInput
    pub const m_bIgnoreDT: usize = 0x1128; // bool
    pub const m_randomnessParameters: usize = 0x112C; // CRandomNumberGeneratorParameters
}

pub mod C_OP_AlphaDecay {
    pub const m_flMinAlpha: usize = 0x1C0; // float
}

pub mod C_OP_AttractToControlPoint {
    pub const m_vecComponentScale: usize = 0x1D0; // Vector
    pub const m_fForceAmount: usize = 0x1E0; // CPerParticleFloatInput
    pub const m_fFalloffPower: usize = 0x338; // float
    pub const m_TransformInput: usize = 0x340; // CParticleTransformInput
    pub const m_fForceAmountMin: usize = 0x3A8; // CPerParticleFloatInput
    pub const m_bApplyMinForce: usize = 0x500; // bool
}

pub mod C_OP_BasicMovement {
    pub const m_Gravity: usize = 0x1C0; // CParticleCollectionVecInput
    pub const m_fDrag: usize = 0x818; // CParticleCollectionFloatInput
    pub const m_nMaxConstraintPasses: usize = 0x970; // int32_t
}

pub mod C_OP_BoxConstraint {
    pub const m_vecMin: usize = 0x1C0; // CParticleCollectionVecInput
    pub const m_vecMax: usize = 0x818; // CParticleCollectionVecInput
    pub const m_nCP: usize = 0xE70; // int32_t
    pub const m_bLocalSpace: usize = 0xE74; // bool
    pub const m_bAccountForRadius: usize = 0xE75; // bool
}

pub mod C_OP_CPOffsetToPercentageBetweenCPs {
    pub const m_flInputMin: usize = 0x1C0; // float
    pub const m_flInputMax: usize = 0x1C4; // float
    pub const m_flInputBias: usize = 0x1C8; // float
    pub const m_nStartCP: usize = 0x1CC; // int32_t
    pub const m_nEndCP: usize = 0x1D0; // int32_t
    pub const m_nOffsetCP: usize = 0x1D4; // int32_t
    pub const m_nOuputCP: usize = 0x1D8; // int32_t
    pub const m_nInputCP: usize = 0x1DC; // int32_t
    pub const m_bRadialCheck: usize = 0x1E0; // bool
    pub const m_bScaleOffset: usize = 0x1E1; // bool
    pub const m_vecOffset: usize = 0x1E4; // Vector
}

pub mod C_OP_CPVelocityForce {
    pub const m_nControlPointNumber: usize = 0x1D0; // int32_t
    pub const m_flScale: usize = 0x1D8; // CPerParticleFloatInput
}

pub mod C_OP_CalculateVectorAttribute {
    pub const m_vStartValue: usize = 0x1C0; // Vector
    pub const m_nFieldInput1: usize = 0x1CC; // ParticleAttributeIndex_t
    pub const m_flInputScale1: usize = 0x1D0; // float
    pub const m_nFieldInput2: usize = 0x1D4; // ParticleAttributeIndex_t
    pub const m_flInputScale2: usize = 0x1D8; // float
    pub const m_nControlPointInput1: usize = 0x1DC; // ControlPointReference_t
    pub const m_flControlPointScale1: usize = 0x1F0; // float
    pub const m_nControlPointInput2: usize = 0x1F4; // ControlPointReference_t
    pub const m_flControlPointScale2: usize = 0x208; // float
    pub const m_nFieldOutput: usize = 0x20C; // ParticleAttributeIndex_t
    pub const m_vFinalOutputScale: usize = 0x210; // Vector
}

pub mod C_OP_ChladniWave {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_flInputMin: usize = 0x1C8; // CPerParticleFloatInput
    pub const m_flInputMax: usize = 0x320; // CPerParticleFloatInput
    pub const m_flOutputMin: usize = 0x478; // CPerParticleFloatInput
    pub const m_flOutputMax: usize = 0x5D0; // CPerParticleFloatInput
    pub const m_vecWaveLength: usize = 0x728; // CPerParticleVecInput
    pub const m_vecHarmonics: usize = 0xD80; // CPerParticleVecInput
    pub const m_nSetMethod: usize = 0x13D8; // ParticleSetMethod_t
    pub const m_nLocalSpaceControlPoint: usize = 0x13DC; // int32_t
    pub const m_b3D: usize = 0x13E0; // bool
}

pub mod C_OP_ChooseRandomChildrenInGroup {
    pub const m_nChildGroupID: usize = 0x1D0; // int32_t
    pub const m_flNumberOfChildren: usize = 0x1D8; // CParticleCollectionFloatInput
}

pub mod C_OP_ClampScalar {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_flOutputMin: usize = 0x1C8; // CPerParticleFloatInput
    pub const m_flOutputMax: usize = 0x320; // CPerParticleFloatInput
}

pub mod C_OP_ClampVector {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_vecOutputMin: usize = 0x1C8; // CPerParticleVecInput
    pub const m_vecOutputMax: usize = 0x820; // CPerParticleVecInput
}

pub mod C_OP_CollideWithParentParticles {
    pub const m_flParentRadiusScale: usize = 0x1C0; // CPerParticleFloatInput
    pub const m_flRadiusScale: usize = 0x318; // CPerParticleFloatInput
}

pub mod C_OP_CollideWithSelf {
    pub const m_flRadiusScale: usize = 0x1C0; // CPerParticleFloatInput
    pub const m_flMinimumSpeed: usize = 0x318; // CPerParticleFloatInput
}

pub mod C_OP_ColorAdjustHSL {
    pub const m_flHueAdjust: usize = 0x1C0; // CPerParticleFloatInput
    pub const m_flSaturationAdjust: usize = 0x318; // CPerParticleFloatInput
    pub const m_flLightnessAdjust: usize = 0x470; // CPerParticleFloatInput
}

pub mod C_OP_ColorInterpolate {
    pub const m_ColorFade: usize = 0x1C0; // Color
    pub const m_flFadeStartTime: usize = 0x1D0; // float
    pub const m_flFadeEndTime: usize = 0x1D4; // float
    pub const m_nFieldOutput: usize = 0x1D8; // ParticleAttributeIndex_t
    pub const m_bEaseInOut: usize = 0x1DC; // bool
    pub const m_bUseNewCode: usize = 0x1DD; // bool
}

pub mod C_OP_ColorInterpolateRandom {
    pub const m_ColorFadeMin: usize = 0x1C0; // Color
    pub const m_ColorFadeMax: usize = 0x1DC; // Color
    pub const m_flFadeStartTime: usize = 0x1EC; // float
    pub const m_flFadeEndTime: usize = 0x1F0; // float
    pub const m_nFieldOutput: usize = 0x1F4; // ParticleAttributeIndex_t
    pub const m_bEaseInOut: usize = 0x1F8; // bool
}

pub mod C_OP_ConnectParentParticleToNearest {
    pub const m_nFirstControlPoint: usize = 0x1C0; // int32_t
    pub const m_nSecondControlPoint: usize = 0x1C4; // int32_t
}

pub mod C_OP_ConstrainDistance {
    pub const m_fMinDistance: usize = 0x1C0; // CParticleCollectionFloatInput
    pub const m_fMaxDistance: usize = 0x318; // CParticleCollectionFloatInput
    pub const m_nControlPointNumber: usize = 0x470; // int32_t
    pub const m_CenterOffset: usize = 0x474; // Vector
    pub const m_bGlobalCenter: usize = 0x480; // bool
}

pub mod C_OP_ConstrainDistanceToPath {
    pub const m_fMinDistance: usize = 0x1C0; // float
    pub const m_flMaxDistance0: usize = 0x1C4; // float
    pub const m_flMaxDistanceMid: usize = 0x1C8; // float
    pub const m_flMaxDistance1: usize = 0x1CC; // float
    pub const m_PathParameters: usize = 0x1D0; // CPathParameters
    pub const m_flTravelTime: usize = 0x210; // float
    pub const m_nFieldScale: usize = 0x214; // ParticleAttributeIndex_t
    pub const m_nManualTField: usize = 0x218; // ParticleAttributeIndex_t
}

pub mod C_OP_ConstrainDistanceToUserSpecifiedPath {
    pub const m_fMinDistance: usize = 0x1C0; // float
    pub const m_flMaxDistance: usize = 0x1C4; // float
    pub const m_flTimeScale: usize = 0x1C8; // float
    pub const m_bLoopedPath: usize = 0x1CC; // bool
    pub const m_pointList: usize = 0x1D0; // CUtlVector<PointDefinitionWithTimeValues_t>
}

pub mod C_OP_ConstrainLineLength {
    pub const m_flMinDistance: usize = 0x1C0; // float
    pub const m_flMaxDistance: usize = 0x1C4; // float
}

pub mod C_OP_ContinuousEmitter {
    pub const m_flEmissionDuration: usize = 0x1C0; // CParticleCollectionFloatInput
    pub const m_flStartTime: usize = 0x318; // CParticleCollectionFloatInput
    pub const m_flEmitRate: usize = 0x470; // CParticleCollectionFloatInput
    pub const m_flEmissionScale: usize = 0x5C8; // float
    pub const m_flScalePerParentParticle: usize = 0x5CC; // float
    pub const m_bInitFromKilledParentParticles: usize = 0x5D0; // bool
    pub const m_nSnapshotControlPoint: usize = 0x5D4; // int32_t
    pub const m_nLimitPerUpdate: usize = 0x5D8; // int32_t
    pub const m_bForceEmitOnFirstUpdate: usize = 0x5DC; // bool
    pub const m_bForceEmitOnLastUpdate: usize = 0x5DD; // bool
}

pub mod C_OP_ControlPointToRadialScreenSpace {
    pub const m_nCPIn: usize = 0x1D0; // int32_t
    pub const m_vecCP1Pos: usize = 0x1D4; // Vector
    pub const m_nCPOut: usize = 0x1E0; // int32_t
    pub const m_nCPOutField: usize = 0x1E4; // int32_t
    pub const m_nCPSSPosOut: usize = 0x1E8; // int32_t
}

pub mod C_OP_ControlpointLight {
    pub const m_flScale: usize = 0x1C0; // float
    pub const m_nControlPoint1: usize = 0x650; // int32_t
    pub const m_nControlPoint2: usize = 0x654; // int32_t
    pub const m_nControlPoint3: usize = 0x658; // int32_t
    pub const m_nControlPoint4: usize = 0x65C; // int32_t
    pub const m_vecCPOffset1: usize = 0x660; // Vector
    pub const m_vecCPOffset2: usize = 0x66C; // Vector
    pub const m_vecCPOffset3: usize = 0x678; // Vector
    pub const m_vecCPOffset4: usize = 0x684; // Vector
    pub const m_LightFiftyDist1: usize = 0x690; // float
    pub const m_LightZeroDist1: usize = 0x694; // float
    pub const m_LightFiftyDist2: usize = 0x698; // float
    pub const m_LightZeroDist2: usize = 0x69C; // float
    pub const m_LightFiftyDist3: usize = 0x6A0; // float
    pub const m_LightZeroDist3: usize = 0x6A4; // float
    pub const m_LightFiftyDist4: usize = 0x6A8; // float
    pub const m_LightZeroDist4: usize = 0x6AC; // float
    pub const m_LightColor1: usize = 0x6B0; // Color
    pub const m_LightColor2: usize = 0x6B4; // Color
    pub const m_LightColor3: usize = 0x6B8; // Color
    pub const m_LightColor4: usize = 0x6BC; // Color
    pub const m_bLightType1: usize = 0x6C0; // bool
    pub const m_bLightType2: usize = 0x6C1; // bool
    pub const m_bLightType3: usize = 0x6C2; // bool
    pub const m_bLightType4: usize = 0x6C3; // bool
    pub const m_bLightDynamic1: usize = 0x6C4; // bool
    pub const m_bLightDynamic2: usize = 0x6C5; // bool
    pub const m_bLightDynamic3: usize = 0x6C6; // bool
    pub const m_bLightDynamic4: usize = 0x6C7; // bool
    pub const m_bUseNormal: usize = 0x6C8; // bool
    pub const m_bUseHLambert: usize = 0x6C9; // bool
    pub const m_bClampLowerRange: usize = 0x6CE; // bool
    pub const m_bClampUpperRange: usize = 0x6CF; // bool
}

pub mod C_OP_Cull {
    pub const m_flCullPerc: usize = 0x1C0; // float
    pub const m_flCullStart: usize = 0x1C4; // float
    pub const m_flCullEnd: usize = 0x1C8; // float
    pub const m_flCullExp: usize = 0x1CC; // float
}

pub mod C_OP_CurlNoiseForce {
    pub const m_nNoiseType: usize = 0x1D0; // ParticleDirectionNoiseType_t
    pub const m_vecNoiseFreq: usize = 0x1D8; // CPerParticleVecInput
    pub const m_vecNoiseScale: usize = 0x830; // CPerParticleVecInput
    pub const m_vecOffset: usize = 0xE88; // CPerParticleVecInput
    pub const m_vecOffsetRate: usize = 0x14E0; // CPerParticleVecInput
    pub const m_flWorleySeed: usize = 0x1B38; // CPerParticleFloatInput
    pub const m_flWorleyJitter: usize = 0x1C90; // CPerParticleFloatInput
}

pub mod C_OP_CycleScalar {
    pub const m_nDestField: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_flStartValue: usize = 0x1C4; // float
    pub const m_flEndValue: usize = 0x1C8; // float
    pub const m_flCycleTime: usize = 0x1CC; // float
    pub const m_bDoNotRepeatCycle: usize = 0x1D0; // bool
    pub const m_bSynchronizeParticles: usize = 0x1D1; // bool
    pub const m_nCPScale: usize = 0x1D4; // int32_t
    pub const m_nCPFieldMin: usize = 0x1D8; // int32_t
    pub const m_nCPFieldMax: usize = 0x1DC; // int32_t
    pub const m_nSetMethod: usize = 0x1E0; // ParticleSetMethod_t
}

pub mod C_OP_CylindricalDistanceToTransform {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_flInputMin: usize = 0x1C8; // CPerParticleFloatInput
    pub const m_flInputMax: usize = 0x320; // CPerParticleFloatInput
    pub const m_flOutputMin: usize = 0x478; // CPerParticleFloatInput
    pub const m_flOutputMax: usize = 0x5D0; // CPerParticleFloatInput
    pub const m_TransformStart: usize = 0x728; // CParticleTransformInput
    pub const m_TransformEnd: usize = 0x790; // CParticleTransformInput
    pub const m_nSetMethod: usize = 0x7F8; // ParticleSetMethod_t
    pub const m_bActiveRange: usize = 0x7FC; // bool
    pub const m_bAdditive: usize = 0x7FD; // bool
    pub const m_bCapsule: usize = 0x7FE; // bool
}

pub mod C_OP_DampenToCP {
    pub const m_nControlPointNumber: usize = 0x1C0; // int32_t
    pub const m_flRange: usize = 0x1C4; // float
    pub const m_flScale: usize = 0x1C8; // float
}

pub mod C_OP_Decay {
    pub const m_bRopeDecay: usize = 0x1C0; // bool
    pub const m_bForcePreserveParticleOrder: usize = 0x1C1; // bool
}

pub mod C_OP_DecayClampCount {
    pub const m_nCount: usize = 0x1C0; // CParticleCollectionFloatInput
}

pub mod C_OP_DecayMaintainCount {
    pub const m_nParticlesToMaintain: usize = 0x1C0; // int32_t
    pub const m_flDecayDelay: usize = 0x1C4; // float
    pub const m_nSnapshotControlPoint: usize = 0x1C8; // int32_t
    pub const m_bLifespanDecay: usize = 0x1CC; // bool
    pub const m_flScale: usize = 0x1D0; // CParticleCollectionFloatInput
    pub const m_bKillNewest: usize = 0x328; // bool
}

pub mod C_OP_DecayOffscreen {
    pub const m_flOffscreenTime: usize = 0x1C0; // CParticleCollectionFloatInput
}

pub mod C_OP_DensityForce {
    pub const m_flRadiusScale: usize = 0x1D0; // float
    pub const m_flForceScale: usize = 0x1D4; // float
    pub const m_flTargetDensity: usize = 0x1D8; // float
}

pub mod C_OP_DifferencePreviousParticle {
    pub const m_nFieldInput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_nFieldOutput: usize = 0x1C4; // ParticleAttributeIndex_t
    pub const m_flInputMin: usize = 0x1C8; // float
    pub const m_flInputMax: usize = 0x1CC; // float
    pub const m_flOutputMin: usize = 0x1D0; // float
    pub const m_flOutputMax: usize = 0x1D4; // float
    pub const m_nSetMethod: usize = 0x1D8; // ParticleSetMethod_t
    pub const m_bActiveRange: usize = 0x1DC; // bool
    pub const m_bSetPreviousParticle: usize = 0x1DD; // bool
}

pub mod C_OP_Diffusion {
    pub const m_flRadiusScale: usize = 0x1C0; // float
    pub const m_nFieldOutput: usize = 0x1C4; // ParticleAttributeIndex_t
    pub const m_nVoxelGridResolution: usize = 0x1C8; // int32_t
}

pub mod C_OP_DirectionBetweenVecsToVec {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_vecPoint1: usize = 0x1C8; // CPerParticleVecInput
    pub const m_vecPoint2: usize = 0x820; // CPerParticleVecInput
}

pub mod C_OP_DistanceBetweenCPsToCP {
    pub const m_nStartCP: usize = 0x1D0; // int32_t
    pub const m_nEndCP: usize = 0x1D4; // int32_t
    pub const m_nOutputCP: usize = 0x1D8; // int32_t
    pub const m_nOutputCPField: usize = 0x1DC; // int32_t
    pub const m_bSetOnce: usize = 0x1E0; // bool
    pub const m_flInputMin: usize = 0x1E4; // float
    pub const m_flInputMax: usize = 0x1E8; // float
    pub const m_flOutputMin: usize = 0x1EC; // float
    pub const m_flOutputMax: usize = 0x1F0; // float
    pub const m_flMaxTraceLength: usize = 0x1F4; // float
    pub const m_flLOSScale: usize = 0x1F8; // float
    pub const m_bLOS: usize = 0x1FC; // bool
    pub const m_CollisionGroupName: usize = 0x1FD; // char[128]
    pub const m_nTraceSet: usize = 0x280; // ParticleTraceSet_t
    pub const m_nSetParent: usize = 0x284; // ParticleParentSetMode_t
}

pub mod C_OP_DistanceBetweenTransforms {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_TransformStart: usize = 0x1C8; // CParticleTransformInput
    pub const m_TransformEnd: usize = 0x230; // CParticleTransformInput
    pub const m_flInputMin: usize = 0x298; // CPerParticleFloatInput
    pub const m_flInputMax: usize = 0x3F0; // CPerParticleFloatInput
    pub const m_flOutputMin: usize = 0x548; // CPerParticleFloatInput
    pub const m_flOutputMax: usize = 0x6A0; // CPerParticleFloatInput
    pub const m_flMaxTraceLength: usize = 0x7F8; // float
    pub const m_flLOSScale: usize = 0x7FC; // float
    pub const m_CollisionGroupName: usize = 0x800; // char[128]
    pub const m_nTraceSet: usize = 0x880; // ParticleTraceSet_t
    pub const m_bLOS: usize = 0x884; // bool
    pub const m_nSetMethod: usize = 0x888; // ParticleSetMethod_t
}

pub mod C_OP_DistanceBetweenVecs {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_vecPoint1: usize = 0x1C8; // CPerParticleVecInput
    pub const m_vecPoint2: usize = 0x820; // CPerParticleVecInput
    pub const m_flInputMin: usize = 0xE78; // CPerParticleFloatInput
    pub const m_flInputMax: usize = 0xFD0; // CPerParticleFloatInput
    pub const m_flOutputMin: usize = 0x1128; // CPerParticleFloatInput
    pub const m_flOutputMax: usize = 0x1280; // CPerParticleFloatInput
    pub const m_nSetMethod: usize = 0x13D8; // ParticleSetMethod_t
    pub const m_bDeltaTime: usize = 0x13DC; // bool
}

pub mod C_OP_DistanceCull {
    pub const m_nControlPoint: usize = 0x1C0; // int32_t
    pub const m_vecPointOffset: usize = 0x1C4; // Vector
    pub const m_flDistance: usize = 0x1D0; // float
    pub const m_bCullInside: usize = 0x1D4; // bool
}

pub mod C_OP_DistanceToTransform {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_flInputMin: usize = 0x1C8; // CPerParticleFloatInput
    pub const m_flInputMax: usize = 0x320; // CPerParticleFloatInput
    pub const m_flOutputMin: usize = 0x478; // CPerParticleFloatInput
    pub const m_flOutputMax: usize = 0x5D0; // CPerParticleFloatInput
    pub const m_TransformStart: usize = 0x728; // CParticleTransformInput
    pub const m_bLOS: usize = 0x790; // bool
    pub const m_CollisionGroupName: usize = 0x791; // char[128]
    pub const m_nTraceSet: usize = 0x814; // ParticleTraceSet_t
    pub const m_flMaxTraceLength: usize = 0x818; // float
    pub const m_flLOSScale: usize = 0x81C; // float
    pub const m_nSetMethod: usize = 0x820; // ParticleSetMethod_t
    pub const m_bActiveRange: usize = 0x824; // bool
    pub const m_bAdditive: usize = 0x825; // bool
    pub const m_vecComponentScale: usize = 0x828; // CPerParticleVecInput
}

pub mod C_OP_DragRelativeToPlane {
    pub const m_flDragAtPlane: usize = 0x1C0; // CParticleCollectionFloatInput
    pub const m_flFalloff: usize = 0x318; // CParticleCollectionFloatInput
    pub const m_bDirectional: usize = 0x470; // bool
    pub const m_vecPlaneNormal: usize = 0x478; // CParticleCollectionVecInput
    pub const m_nControlPointNumber: usize = 0xAD0; // int32_t
}

pub mod C_OP_DriveCPFromGlobalSoundFloat {
    pub const m_nOutputControlPoint: usize = 0x1D0; // int32_t
    pub const m_nOutputField: usize = 0x1D4; // int32_t
    pub const m_flInputMin: usize = 0x1D8; // float
    pub const m_flInputMax: usize = 0x1DC; // float
    pub const m_flOutputMin: usize = 0x1E0; // float
    pub const m_flOutputMax: usize = 0x1E4; // float
    pub const m_StackName: usize = 0x1E8; // CUtlString
    pub const m_OperatorName: usize = 0x1F0; // CUtlString
    pub const m_FieldName: usize = 0x1F8; // CUtlString
}

pub mod C_OP_EnableChildrenFromParentParticleCount {
    pub const m_nChildGroupID: usize = 0x1D0; // int32_t
    pub const m_nFirstChild: usize = 0x1D4; // int32_t
    pub const m_nNumChildrenToEnable: usize = 0x1D8; // CParticleCollectionFloatInput
    pub const m_bDisableChildren: usize = 0x330; // bool
    pub const m_bPlayEndcapOnStop: usize = 0x331; // bool
    pub const m_bDestroyImmediately: usize = 0x332; // bool
}

pub mod C_OP_EndCapTimedDecay {
    pub const m_flDecayTime: usize = 0x1C0; // float
}

pub mod C_OP_EndCapTimedFreeze {
    pub const m_flFreezeTime: usize = 0x1C0; // CParticleCollectionFloatInput
}

pub mod C_OP_ExternalGameImpulseForce {
    pub const m_flForceScale: usize = 0x1D0; // CPerParticleFloatInput
    pub const m_bRopes: usize = 0x328; // bool
    pub const m_bRopesZOnly: usize = 0x329; // bool
    pub const m_bExplosions: usize = 0x32A; // bool
    pub const m_bParticles: usize = 0x32B; // bool
}

pub mod C_OP_ExternalWindForce {
    pub const m_vecSamplePosition: usize = 0x1D0; // CPerParticleVecInput
    pub const m_vecScale: usize = 0x828; // CPerParticleVecInput
    pub const m_bSampleWind: usize = 0xE80; // bool
    pub const m_bSampleWater: usize = 0xE81; // bool
    pub const m_bDampenNearWaterPlane: usize = 0xE82; // bool
    pub const m_bSampleGravity: usize = 0xE83; // bool
    pub const m_vecGravityForce: usize = 0xE88; // CPerParticleVecInput
    pub const m_bUseBasicMovementGravity: usize = 0x14E0; // bool
    pub const m_flLocalGravityScale: usize = 0x14E8; // CPerParticleFloatInput
    pub const m_flLocalBuoyancyScale: usize = 0x1640; // CPerParticleFloatInput
    pub const m_vecBuoyancyForce: usize = 0x1798; // CPerParticleVecInput
}

pub mod C_OP_FadeAndKill {
    pub const m_flStartFadeInTime: usize = 0x1C0; // float
    pub const m_flEndFadeInTime: usize = 0x1C4; // float
    pub const m_flStartFadeOutTime: usize = 0x1C8; // float
    pub const m_flEndFadeOutTime: usize = 0x1CC; // float
    pub const m_flStartAlpha: usize = 0x1D0; // float
    pub const m_flEndAlpha: usize = 0x1D4; // float
    pub const m_bForcePreserveParticleOrder: usize = 0x1D8; // bool
}

pub mod C_OP_FadeAndKillForTracers {
    pub const m_flStartFadeInTime: usize = 0x1C0; // float
    pub const m_flEndFadeInTime: usize = 0x1C4; // float
    pub const m_flStartFadeOutTime: usize = 0x1C8; // float
    pub const m_flEndFadeOutTime: usize = 0x1CC; // float
    pub const m_flStartAlpha: usize = 0x1D0; // float
    pub const m_flEndAlpha: usize = 0x1D4; // float
}

pub mod C_OP_FadeIn {
    pub const m_flFadeInTimeMin: usize = 0x1C0; // float
    pub const m_flFadeInTimeMax: usize = 0x1C4; // float
    pub const m_flFadeInTimeExp: usize = 0x1C8; // float
    pub const m_bProportional: usize = 0x1CC; // bool
}

pub mod C_OP_FadeInSimple {
    pub const m_flFadeInTime: usize = 0x1C0; // float
    pub const m_nFieldOutput: usize = 0x1C4; // ParticleAttributeIndex_t
}

pub mod C_OP_FadeOut {
    pub const m_flFadeOutTimeMin: usize = 0x1C0; // float
    pub const m_flFadeOutTimeMax: usize = 0x1C4; // float
    pub const m_flFadeOutTimeExp: usize = 0x1C8; // float
    pub const m_flFadeBias: usize = 0x1CC; // float
    pub const m_bProportional: usize = 0x200; // bool
    pub const m_bEaseInAndOut: usize = 0x201; // bool
}

pub mod C_OP_FadeOutSimple {
    pub const m_flFadeOutTime: usize = 0x1C0; // float
    pub const m_nFieldOutput: usize = 0x1C4; // ParticleAttributeIndex_t
}

pub mod C_OP_ForceBasedOnDistanceToPlane {
    pub const m_flMinDist: usize = 0x1D0; // float
    pub const m_vecForceAtMinDist: usize = 0x1D4; // Vector
    pub const m_flMaxDist: usize = 0x1E0; // float
    pub const m_vecForceAtMaxDist: usize = 0x1E4; // Vector
    pub const m_vecPlaneNormal: usize = 0x1F0; // Vector
    pub const m_nControlPointNumber: usize = 0x1FC; // int32_t
    pub const m_flExponent: usize = 0x200; // float
}

pub mod C_OP_ForceControlPointStub {
    pub const m_ControlPoint: usize = 0x1D0; // int32_t
}

pub mod C_OP_GlobalLight {
    pub const m_flScale: usize = 0x1C0; // float
    pub const m_bClampLowerRange: usize = 0x1C4; // bool
    pub const m_bClampUpperRange: usize = 0x1C5; // bool
}

pub mod C_OP_HSVShiftToCP {
    pub const m_nColorCP: usize = 0x1D0; // int32_t
    pub const m_nColorGemEnableCP: usize = 0x1D4; // int32_t
    pub const m_nOutputCP: usize = 0x1D8; // int32_t
    pub const m_DefaultHSVColor: usize = 0x1DC; // Color
}

pub mod C_OP_InheritFromParentParticles {
    pub const m_flScale: usize = 0x1C0; // float
    pub const m_nFieldOutput: usize = 0x1C4; // ParticleAttributeIndex_t
    pub const m_nIncrement: usize = 0x1C8; // int32_t
    pub const m_bRandomDistribution: usize = 0x1CC; // bool
}

pub mod C_OP_InheritFromParentParticlesV2 {
    pub const m_flScale: usize = 0x1C0; // float
    pub const m_nFieldOutput: usize = 0x1C4; // ParticleAttributeIndex_t
    pub const m_nIncrement: usize = 0x1C8; // int32_t
    pub const m_bRandomDistribution: usize = 0x1CC; // bool
    pub const m_nMissingParentBehavior: usize = 0x1D0; // MissingParentInheritBehavior_t
}

pub mod C_OP_InheritFromPeerSystem {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_nFieldInput: usize = 0x1C4; // ParticleAttributeIndex_t
    pub const m_nIncrement: usize = 0x1C8; // int32_t
    pub const m_nGroupID: usize = 0x1CC; // int32_t
}

pub mod C_OP_InstantaneousEmitter {
    pub const m_nParticlesToEmit: usize = 0x1C0; // CParticleCollectionFloatInput
    pub const m_flStartTime: usize = 0x318; // CParticleCollectionFloatInput
    pub const m_flInitFromKilledParentParticles: usize = 0x470; // float
    pub const m_flParentParticleScale: usize = 0x478; // CParticleCollectionFloatInput
    pub const m_nMaxEmittedPerFrame: usize = 0x5D0; // int32_t
    pub const m_nSnapshotControlPoint: usize = 0x5D4; // int32_t
}

pub mod C_OP_InterpolateRadius {
    pub const m_flStartTime: usize = 0x1C0; // float
    pub const m_flEndTime: usize = 0x1C4; // float
    pub const m_flStartScale: usize = 0x1C8; // float
    pub const m_flEndScale: usize = 0x1CC; // float
    pub const m_bEaseInAndOut: usize = 0x1D0; // bool
    pub const m_flBias: usize = 0x1D4; // float
}

pub mod C_OP_LagCompensation {
    pub const m_nDesiredVelocityCP: usize = 0x1C0; // int32_t
    pub const m_nLatencyCP: usize = 0x1C4; // int32_t
    pub const m_nLatencyCPField: usize = 0x1C8; // int32_t
    pub const m_nDesiredVelocityCPField: usize = 0x1CC; // int32_t
}

pub mod C_OP_LerpEndCapScalar {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_flOutput: usize = 0x1C4; // float
    pub const m_flLerpTime: usize = 0x1C8; // float
}

pub mod C_OP_LerpEndCapVector {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_vecOutput: usize = 0x1C4; // Vector
    pub const m_flLerpTime: usize = 0x1D0; // float
}

pub mod C_OP_LerpScalar {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_flOutput: usize = 0x1C8; // CPerParticleFloatInput
    pub const m_flStartTime: usize = 0x320; // float
    pub const m_flEndTime: usize = 0x324; // float
}

pub mod C_OP_LerpToInitialPosition {
    pub const m_nControlPointNumber: usize = 0x1C0; // int32_t
    pub const m_flInterpolation: usize = 0x1C8; // CPerParticleFloatInput
    pub const m_nCacheField: usize = 0x320; // ParticleAttributeIndex_t
    pub const m_flScale: usize = 0x328; // CParticleCollectionFloatInput
    pub const m_vecScale: usize = 0x480; // CParticleCollectionVecInput
}

pub mod C_OP_LerpToOtherAttribute {
    pub const m_flInterpolation: usize = 0x1C0; // CPerParticleFloatInput
    pub const m_nFieldInputFrom: usize = 0x318; // ParticleAttributeIndex_t
    pub const m_nFieldInput: usize = 0x31C; // ParticleAttributeIndex_t
    pub const m_nFieldOutput: usize = 0x320; // ParticleAttributeIndex_t
}

pub mod C_OP_LerpVector {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_vecOutput: usize = 0x1C4; // Vector
    pub const m_flStartTime: usize = 0x1D0; // float
    pub const m_flEndTime: usize = 0x1D4; // float
    pub const m_nSetMethod: usize = 0x1D8; // ParticleSetMethod_t
}

pub mod C_OP_LightningSnapshotGenerator {
    pub const m_nCPSnapshot: usize = 0x1D0; // int32_t
    pub const m_nCPStartPnt: usize = 0x1D4; // int32_t
    pub const m_nCPEndPnt: usize = 0x1D8; // int32_t
    pub const m_flSegments: usize = 0x1E0; // CParticleCollectionFloatInput
    pub const m_flOffset: usize = 0x338; // CParticleCollectionFloatInput
    pub const m_flOffsetDecay: usize = 0x490; // CParticleCollectionFloatInput
    pub const m_flRecalcRate: usize = 0x5E8; // CParticleCollectionFloatInput
    pub const m_flUVScale: usize = 0x740; // CParticleCollectionFloatInput
    pub const m_flUVOffset: usize = 0x898; // CParticleCollectionFloatInput
    pub const m_flSplitRate: usize = 0x9F0; // CParticleCollectionFloatInput
    pub const m_flBranchTwist: usize = 0xB48; // CParticleCollectionFloatInput
    pub const m_nBranchBehavior: usize = 0xCA0; // ParticleLightnintBranchBehavior_t
    pub const m_flRadiusStart: usize = 0xCA8; // CParticleCollectionFloatInput
    pub const m_flRadiusEnd: usize = 0xE00; // CParticleCollectionFloatInput
    pub const m_flDedicatedPool: usize = 0xF58; // CParticleCollectionFloatInput
}

pub mod C_OP_LocalAccelerationForce {
    pub const m_nCP: usize = 0x1D0; // int32_t
    pub const m_nScaleCP: usize = 0x1D4; // int32_t
    pub const m_vecAccel: usize = 0x1D8; // CParticleCollectionVecInput
}

pub mod C_OP_LockPoints {
    pub const m_nMinCol: usize = 0x1C0; // int32_t
    pub const m_nMaxCol: usize = 0x1C4; // int32_t
    pub const m_nMinRow: usize = 0x1C8; // int32_t
    pub const m_nMaxRow: usize = 0x1CC; // int32_t
    pub const m_nControlPoint: usize = 0x1D0; // int32_t
    pub const m_flBlendValue: usize = 0x1D4; // float
}

pub mod C_OP_LockToBone {
    pub const m_modelInput: usize = 0x1C0; // CParticleModelInput
    pub const m_transformInput: usize = 0x220; // CParticleTransformInput
    pub const m_flLifeTimeFadeStart: usize = 0x288; // float
    pub const m_flLifeTimeFadeEnd: usize = 0x28C; // float
    pub const m_flJumpThreshold: usize = 0x290; // float
    pub const m_flPrevPosScale: usize = 0x294; // float
    pub const m_HitboxSetName: usize = 0x298; // char[128]
    pub const m_bRigid: usize = 0x318; // bool
    pub const m_bUseBones: usize = 0x319; // bool
    pub const m_nFieldOutput: usize = 0x31C; // ParticleAttributeIndex_t
    pub const m_nFieldOutputPrev: usize = 0x320; // ParticleAttributeIndex_t
    pub const m_nRotationSetType: usize = 0x324; // ParticleRotationLockType_t
    pub const m_bRigidRotationLock: usize = 0x328; // bool
    pub const m_vecRotation: usize = 0x330; // CPerParticleVecInput
    pub const m_flRotLerp: usize = 0x988; // CPerParticleFloatInput
}

pub mod C_OP_LockToPointList {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_pointList: usize = 0x1C8; // CUtlVector<PointDefinition_t>
    pub const m_bPlaceAlongPath: usize = 0x1E0; // bool
    pub const m_bClosedLoop: usize = 0x1E1; // bool
    pub const m_nNumPointsAlongPath: usize = 0x1E4; // int32_t
}

pub mod C_OP_LockToSavedSequentialPath {
    pub const m_flFadeStart: usize = 0x1C4; // float
    pub const m_flFadeEnd: usize = 0x1C8; // float
    pub const m_bCPPairs: usize = 0x1CC; // bool
    pub const m_PathParams: usize = 0x1D0; // CPathParameters
}

pub mod C_OP_LockToSavedSequentialPathV2 {
    pub const m_flFadeStart: usize = 0x1C0; // float
    pub const m_flFadeEnd: usize = 0x1C4; // float
    pub const m_bCPPairs: usize = 0x1C8; // bool
    pub const m_PathParams: usize = 0x1D0; // CPathParameters
}

pub mod C_OP_MaintainEmitter {
    pub const m_nParticlesToMaintain: usize = 0x1C0; // CParticleCollectionFloatInput
    pub const m_flStartTime: usize = 0x318; // float
    pub const m_flEmissionDuration: usize = 0x320; // CParticleCollectionFloatInput
    pub const m_flEmissionRate: usize = 0x478; // float
    pub const m_nSnapshotControlPoint: usize = 0x47C; // int32_t
    pub const m_bEmitInstantaneously: usize = 0x480; // bool
    pub const m_bFinalEmitOnStop: usize = 0x481; // bool
    pub const m_flScale: usize = 0x488; // CParticleCollectionFloatInput
}

pub mod C_OP_MaintainSequentialPath {
    pub const m_fMaxDistance: usize = 0x1C0; // float
    pub const m_flNumToAssign: usize = 0x1C4; // float
    pub const m_flCohesionStrength: usize = 0x1C8; // float
    pub const m_flTolerance: usize = 0x1CC; // float
    pub const m_bLoop: usize = 0x1D0; // bool
    pub const m_bUseParticleCount: usize = 0x1D1; // bool
    pub const m_PathParams: usize = 0x1E0; // CPathParameters
}

pub mod C_OP_MaxVelocity {
    pub const m_flMaxVelocity: usize = 0x1C0; // float
    pub const m_flMinVelocity: usize = 0x1C4; // float
    pub const m_nOverrideCP: usize = 0x1C8; // int32_t
    pub const m_nOverrideCPField: usize = 0x1CC; // int32_t
}

pub mod C_OP_ModelCull {
    pub const m_nControlPointNumber: usize = 0x1C0; // int32_t
    pub const m_bBoundBox: usize = 0x1C4; // bool
    pub const m_bCullOutside: usize = 0x1C5; // bool
    pub const m_bUseBones: usize = 0x1C6; // bool
    pub const m_HitboxSetName: usize = 0x1C7; // char[128]
}

pub mod C_OP_ModelDampenMovement {
    pub const m_nControlPointNumber: usize = 0x1C0; // int32_t
    pub const m_bBoundBox: usize = 0x1C4; // bool
    pub const m_bOutside: usize = 0x1C5; // bool
    pub const m_bUseBones: usize = 0x1C6; // bool
    pub const m_HitboxSetName: usize = 0x1C7; // char[128]
    pub const m_vecPosOffset: usize = 0x248; // CPerParticleVecInput
    pub const m_fDrag: usize = 0x8A0; // float
}

pub mod C_OP_MoveToHitbox {
    pub const m_modelInput: usize = 0x1C0; // CParticleModelInput
    pub const m_transformInput: usize = 0x220; // CParticleTransformInput
    pub const m_flLifeTimeLerpStart: usize = 0x28C; // float
    pub const m_flLifeTimeLerpEnd: usize = 0x290; // float
    pub const m_flPrevPosScale: usize = 0x294; // float
    pub const m_HitboxSetName: usize = 0x298; // char[128]
    pub const m_bUseBones: usize = 0x318; // bool
    pub const m_nLerpType: usize = 0x31C; // HitboxLerpType_t
    pub const m_flInterpolation: usize = 0x320; // CPerParticleFloatInput
}

pub mod C_OP_MovementLoopInsideSphere {
    pub const m_nCP: usize = 0x1C0; // int32_t
    pub const m_flDistance: usize = 0x1C8; // CParticleCollectionFloatInput
    pub const m_vecScale: usize = 0x320; // CParticleCollectionVecInput
    pub const m_nDistSqrAttr: usize = 0x978; // ParticleAttributeIndex_t
}

pub mod C_OP_MovementMaintainOffset {
    pub const m_vecOffset: usize = 0x1C0; // Vector
    pub const m_nCP: usize = 0x1CC; // int32_t
    pub const m_bRadiusScale: usize = 0x1D0; // bool
}

pub mod C_OP_MovementMoveAlongSkinnedCPSnapshot {
    pub const m_nControlPointNumber: usize = 0x1C0; // int32_t
    pub const m_nSnapshotControlPointNumber: usize = 0x1C4; // int32_t
    pub const m_bSetNormal: usize = 0x1C8; // bool
    pub const m_bSetRadius: usize = 0x1C9; // bool
    pub const m_flInterpolation: usize = 0x1D0; // CPerParticleFloatInput
    pub const m_flTValue: usize = 0x328; // CPerParticleFloatInput
}

pub mod C_OP_MovementPlaceOnGround {
    pub const m_flOffset: usize = 0x1C0; // CPerParticleFloatInput
    pub const m_flMaxTraceLength: usize = 0x318; // float
    pub const m_flTolerance: usize = 0x31C; // float
    pub const m_flTraceOffset: usize = 0x320; // float
    pub const m_flLerpRate: usize = 0x324; // float
    pub const m_CollisionGroupName: usize = 0x328; // char[128]
    pub const m_nTraceSet: usize = 0x3A8; // ParticleTraceSet_t
    pub const m_nRefCP1: usize = 0x3AC; // int32_t
    pub const m_nRefCP2: usize = 0x3B0; // int32_t
    pub const m_nLerpCP: usize = 0x3B4; // int32_t
    pub const m_nTraceMissBehavior: usize = 0x3C0; // ParticleTraceMissBehavior_t
    pub const m_bIncludeShotHull: usize = 0x3C4; // bool
    pub const m_bIncludeWater: usize = 0x3C5; // bool
    pub const m_bSetNormal: usize = 0x3C8; // bool
    pub const m_bScaleOffset: usize = 0x3C9; // bool
    pub const m_nPreserveOffsetCP: usize = 0x3CC; // int32_t
    pub const m_nIgnoreCP: usize = 0x3D0; // int32_t
}

pub mod C_OP_MovementRigidAttachToCP {
    pub const m_nControlPointNumber: usize = 0x1C0; // int32_t
    pub const m_nScaleControlPoint: usize = 0x1C4; // int32_t
    pub const m_nScaleCPField: usize = 0x1C8; // int32_t
    pub const m_nFieldInput: usize = 0x1CC; // ParticleAttributeIndex_t
    pub const m_nFieldOutput: usize = 0x1D0; // ParticleAttributeIndex_t
    pub const m_bOffsetLocal: usize = 0x1D4; // bool
}

pub mod C_OP_MovementRotateParticleAroundAxis {
    pub const m_vecRotAxis: usize = 0x1C0; // CParticleCollectionVecInput
    pub const m_flRotRate: usize = 0x818; // CParticleCollectionFloatInput
    pub const m_TransformInput: usize = 0x970; // CParticleTransformInput
    pub const m_bLocalSpace: usize = 0x9D8; // bool
}

pub mod C_OP_MovementSkinnedPositionFromCPSnapshot {
    pub const m_nSnapshotControlPointNumber: usize = 0x1C0; // int32_t
    pub const m_nControlPointNumber: usize = 0x1C4; // int32_t
    pub const m_bRandom: usize = 0x1C8; // bool
    pub const m_nRandomSeed: usize = 0x1CC; // int32_t
    pub const m_bSetNormal: usize = 0x1D0; // bool
    pub const m_bSetRadius: usize = 0x1D1; // bool
    pub const m_flIncrement: usize = 0x1D8; // CParticleCollectionFloatInput
    pub const m_nFullLoopIncrement: usize = 0x330; // CParticleCollectionFloatInput
    pub const m_nSnapShotStartPoint: usize = 0x488; // CParticleCollectionFloatInput
    pub const m_flInterpolation: usize = 0x5E0; // CPerParticleFloatInput
}

pub mod C_OP_Noise {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_flOutputMin: usize = 0x1C4; // float
    pub const m_flOutputMax: usize = 0x1C8; // float
    pub const m_fl4NoiseScale: usize = 0x1CC; // float
    pub const m_bAdditive: usize = 0x1D0; // bool
    pub const m_flNoiseAnimationTimeScale: usize = 0x1D4; // float
}

pub mod C_OP_NoiseEmitter {
    pub const m_flEmissionDuration: usize = 0x1C0; // float
    pub const m_flStartTime: usize = 0x1C4; // float
    pub const m_flEmissionScale: usize = 0x1C8; // float
    pub const m_nScaleControlPoint: usize = 0x1CC; // int32_t
    pub const m_nScaleControlPointField: usize = 0x1D0; // int32_t
    pub const m_nWorldNoisePoint: usize = 0x1D4; // int32_t
    pub const m_bAbsVal: usize = 0x1D8; // bool
    pub const m_bAbsValInv: usize = 0x1D9; // bool
    pub const m_flOffset: usize = 0x1DC; // float
    pub const m_flOutputMin: usize = 0x1E0; // float
    pub const m_flOutputMax: usize = 0x1E4; // float
    pub const m_flNoiseScale: usize = 0x1E8; // float
    pub const m_flWorldNoiseScale: usize = 0x1EC; // float
    pub const m_vecOffsetLoc: usize = 0x1F0; // Vector
    pub const m_flWorldTimeScale: usize = 0x1FC; // float
}

pub mod C_OP_NormalLock {
    pub const m_nControlPointNumber: usize = 0x1C0; // int32_t
}

pub mod C_OP_NormalizeVector {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_flScale: usize = 0x1C4; // float
}

pub mod C_OP_Orient2DRelToCP {
    pub const m_flRotOffset: usize = 0x1C0; // float
    pub const m_flSpinStrength: usize = 0x1C4; // float
    pub const m_nCP: usize = 0x1C8; // int32_t
    pub const m_nFieldOutput: usize = 0x1CC; // ParticleAttributeIndex_t
}

pub mod C_OP_OrientTo2dDirection {
    pub const m_flRotOffset: usize = 0x1C0; // float
    pub const m_flSpinStrength: usize = 0x1C4; // float
    pub const m_nFieldOutput: usize = 0x1C8; // ParticleAttributeIndex_t
}

pub mod C_OP_OscillateScalar {
    pub const m_RateMin: usize = 0x1C0; // float
    pub const m_RateMax: usize = 0x1C4; // float
    pub const m_FrequencyMin: usize = 0x1C8; // float
    pub const m_FrequencyMax: usize = 0x1CC; // float
    pub const m_nField: usize = 0x1D0; // ParticleAttributeIndex_t
    pub const m_bProportional: usize = 0x1D4; // bool
    pub const m_bProportionalOp: usize = 0x1D5; // bool
    pub const m_flStartTime_min: usize = 0x1D8; // float
    pub const m_flStartTime_max: usize = 0x1DC; // float
    pub const m_flEndTime_min: usize = 0x1E0; // float
    pub const m_flEndTime_max: usize = 0x1E4; // float
    pub const m_flOscMult: usize = 0x1E8; // float
    pub const m_flOscAdd: usize = 0x1EC; // float
}

pub mod C_OP_OscillateScalarSimple {
    pub const m_Rate: usize = 0x1C0; // float
    pub const m_Frequency: usize = 0x1C4; // float
    pub const m_nField: usize = 0x1C8; // ParticleAttributeIndex_t
    pub const m_flOscMult: usize = 0x1CC; // float
    pub const m_flOscAdd: usize = 0x1D0; // float
}

pub mod C_OP_OscillateVector {
    pub const m_RateMin: usize = 0x1C0; // Vector
    pub const m_RateMax: usize = 0x1CC; // Vector
    pub const m_FrequencyMin: usize = 0x1D8; // Vector
    pub const m_FrequencyMax: usize = 0x1E4; // Vector
    pub const m_nField: usize = 0x1F0; // ParticleAttributeIndex_t
    pub const m_bProportional: usize = 0x1F4; // bool
    pub const m_bProportionalOp: usize = 0x1F5; // bool
    pub const m_bOffset: usize = 0x1F6; // bool
    pub const m_flStartTime_min: usize = 0x1F8; // float
    pub const m_flStartTime_max: usize = 0x1FC; // float
    pub const m_flEndTime_min: usize = 0x200; // float
    pub const m_flEndTime_max: usize = 0x204; // float
    pub const m_flOscMult: usize = 0x208; // CPerParticleFloatInput
    pub const m_flOscAdd: usize = 0x360; // CPerParticleFloatInput
    pub const m_flRateScale: usize = 0x4B8; // CPerParticleFloatInput
}

pub mod C_OP_OscillateVectorSimple {
    pub const m_Rate: usize = 0x1C0; // Vector
    pub const m_Frequency: usize = 0x1CC; // Vector
    pub const m_nField: usize = 0x1D8; // ParticleAttributeIndex_t
    pub const m_flOscMult: usize = 0x1DC; // float
    pub const m_flOscAdd: usize = 0x1E0; // float
    pub const m_bOffset: usize = 0x1E4; // bool
}

pub mod C_OP_ParentVortices {
    pub const m_flForceScale: usize = 0x1D0; // float
    pub const m_vecTwistAxis: usize = 0x1D4; // Vector
    pub const m_bFlipBasedOnYaw: usize = 0x1E0; // bool
}

pub mod C_OP_ParticlePhysics {
    pub const m_Gravity: usize = 0x1C0; // CParticleCollectionVecInput
    pub const m_fDrag: usize = 0x818; // CParticleCollectionFloatInput
    pub const m_nMaxConstraintPasses: usize = 0x970; // int32_t
}

pub mod C_OP_PerParticleForce {
    pub const m_flForceScale: usize = 0x1D0; // CPerParticleFloatInput
    pub const m_vForce: usize = 0x328; // CPerParticleVecInput
    pub const m_nCP: usize = 0x980; // int32_t
}

pub mod C_OP_PercentageBetweenTransformLerpCPs {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_flInputMin: usize = 0x1C4; // float
    pub const m_flInputMax: usize = 0x1C8; // float
    pub const m_TransformStart: usize = 0x1D0; // CParticleTransformInput
    pub const m_TransformEnd: usize = 0x238; // CParticleTransformInput
    pub const m_nOutputStartCP: usize = 0x2A0; // int32_t
    pub const m_nOutputStartField: usize = 0x2A4; // int32_t
    pub const m_nOutputEndCP: usize = 0x2A8; // int32_t
    pub const m_nOutputEndField: usize = 0x2AC; // int32_t
    pub const m_nSetMethod: usize = 0x2B0; // ParticleSetMethod_t
    pub const m_bActiveRange: usize = 0x2B4; // bool
    pub const m_bRadialCheck: usize = 0x2B5; // bool
}

pub mod C_OP_PercentageBetweenTransforms {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_flInputMin: usize = 0x1C4; // float
    pub const m_flInputMax: usize = 0x1C8; // float
    pub const m_flOutputMin: usize = 0x1CC; // float
    pub const m_flOutputMax: usize = 0x1D0; // float
    pub const m_TransformStart: usize = 0x1D8; // CParticleTransformInput
    pub const m_TransformEnd: usize = 0x240; // CParticleTransformInput
    pub const m_nSetMethod: usize = 0x2A8; // ParticleSetMethod_t
    pub const m_bActiveRange: usize = 0x2AC; // bool
    pub const m_bRadialCheck: usize = 0x2AD; // bool
}

pub mod C_OP_PercentageBetweenTransformsVector {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_flInputMin: usize = 0x1C4; // float
    pub const m_flInputMax: usize = 0x1C8; // float
    pub const m_vecOutputMin: usize = 0x1CC; // Vector
    pub const m_vecOutputMax: usize = 0x1D8; // Vector
    pub const m_TransformStart: usize = 0x1E8; // CParticleTransformInput
    pub const m_TransformEnd: usize = 0x250; // CParticleTransformInput
    pub const m_nSetMethod: usize = 0x2B8; // ParticleSetMethod_t
    pub const m_bActiveRange: usize = 0x2BC; // bool
    pub const m_bRadialCheck: usize = 0x2BD; // bool
}

pub mod C_OP_PinParticleToCP {
    pub const m_nControlPointNumber: usize = 0x1C0; // int32_t
    pub const m_vecOffset: usize = 0x1C8; // CParticleCollectionVecInput
    pub const m_bOffsetLocal: usize = 0x820; // bool
    pub const m_nParticleSelection: usize = 0x824; // ParticleSelection_t
    pub const m_nParticleNumber: usize = 0x828; // CParticleCollectionFloatInput
    pub const m_nPinBreakType: usize = 0x980; // ParticlePinDistance_t
    pub const m_flBreakDistance: usize = 0x988; // CParticleCollectionFloatInput
    pub const m_flBreakSpeed: usize = 0xAE0; // CParticleCollectionFloatInput
    pub const m_flAge: usize = 0xC38; // CParticleCollectionFloatInput
    pub const m_nBreakControlPointNumber: usize = 0xD90; // int32_t
    pub const m_nBreakControlPointNumber2: usize = 0xD94; // int32_t
    pub const m_flBreakValue: usize = 0xD98; // CParticleCollectionFloatInput
    pub const m_flInterpolation: usize = 0xEF0; // CPerParticleFloatInput
}

pub mod C_OP_PlanarConstraint {
    pub const m_PointOnPlane: usize = 0x1C0; // Vector
    pub const m_PlaneNormal: usize = 0x1CC; // Vector
    pub const m_nControlPointNumber: usize = 0x1D8; // int32_t
    pub const m_bGlobalOrigin: usize = 0x1DC; // bool
    pub const m_bGlobalNormal: usize = 0x1DD; // bool
    pub const m_flRadiusScale: usize = 0x1E0; // CPerParticleFloatInput
    pub const m_flMaximumDistanceToCP: usize = 0x338; // CParticleCollectionFloatInput
}

pub mod C_OP_PlaneCull {
    pub const m_nPlaneControlPoint: usize = 0x1C0; // int32_t
    pub const m_vecPlaneDirection: usize = 0x1C4; // Vector
    pub const m_bLocalSpace: usize = 0x1D0; // bool
    pub const m_flPlaneOffset: usize = 0x1D4; // float
}

pub mod C_OP_PlayEndCapWhenFinished {
    pub const m_bFireOnEmissionEnd: usize = 0x1D0; // bool
    pub const m_bIncludeChildren: usize = 0x1D1; // bool
}

pub mod C_OP_PointVectorAtNextParticle {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_flInterpolation: usize = 0x1C8; // CPerParticleFloatInput
}

pub mod C_OP_PositionLock {
    pub const m_TransformInput: usize = 0x1C0; // CParticleTransformInput
    pub const m_flStartTime_min: usize = 0x228; // float
    pub const m_flStartTime_max: usize = 0x22C; // float
    pub const m_flStartTime_exp: usize = 0x230; // float
    pub const m_flEndTime_min: usize = 0x234; // float
    pub const m_flEndTime_max: usize = 0x238; // float
    pub const m_flEndTime_exp: usize = 0x23C; // float
    pub const m_flRange: usize = 0x240; // float
    pub const m_flRangeBias: usize = 0x248; // CParticleCollectionFloatInput
    pub const m_flJumpThreshold: usize = 0x3A0; // float
    pub const m_flPrevPosScale: usize = 0x3A4; // float
    pub const m_bLockRot: usize = 0x3A8; // bool
    pub const m_vecScale: usize = 0x3B0; // CParticleCollectionVecInput
    pub const m_nFieldOutput: usize = 0xA08; // ParticleAttributeIndex_t
    pub const m_nFieldOutputPrev: usize = 0xA0C; // ParticleAttributeIndex_t
}

pub mod C_OP_QuantizeCPComponent {
    pub const m_flInputValue: usize = 0x1D0; // CParticleCollectionFloatInput
    pub const m_nCPOutput: usize = 0x328; // int32_t
    pub const m_nOutVectorField: usize = 0x32C; // int32_t
    pub const m_flQuantizeValue: usize = 0x330; // CParticleCollectionFloatInput
}

pub mod C_OP_QuantizeFloat {
    pub const m_InputValue: usize = 0x1C0; // CPerParticleFloatInput
    pub const m_nOutputField: usize = 0x318; // ParticleAttributeIndex_t
}

pub mod C_OP_RadiusDecay {
    pub const m_flMinRadius: usize = 0x1C0; // float
}

pub mod C_OP_RampCPLinearRandom {
    pub const m_nOutControlPointNumber: usize = 0x1D0; // int32_t
    pub const m_vecRateMin: usize = 0x1D4; // Vector
    pub const m_vecRateMax: usize = 0x1E0; // Vector
}

pub mod C_OP_RampScalarLinear {
    pub const m_RateMin: usize = 0x1C0; // float
    pub const m_RateMax: usize = 0x1C4; // float
    pub const m_flStartTime_min: usize = 0x1C8; // float
    pub const m_flStartTime_max: usize = 0x1CC; // float
    pub const m_flEndTime_min: usize = 0x1D0; // float
    pub const m_flEndTime_max: usize = 0x1D4; // float
    pub const m_nField: usize = 0x200; // ParticleAttributeIndex_t
    pub const m_bProportionalOp: usize = 0x204; // bool
}

pub mod C_OP_RampScalarLinearSimple {
    pub const m_Rate: usize = 0x1C0; // float
    pub const m_flStartTime: usize = 0x1C4; // float
    pub const m_flEndTime: usize = 0x1C8; // float
    pub const m_nField: usize = 0x1F0; // ParticleAttributeIndex_t
}

pub mod C_OP_RampScalarSpline {
    pub const m_RateMin: usize = 0x1C0; // float
    pub const m_RateMax: usize = 0x1C4; // float
    pub const m_flStartTime_min: usize = 0x1C8; // float
    pub const m_flStartTime_max: usize = 0x1CC; // float
    pub const m_flEndTime_min: usize = 0x1D0; // float
    pub const m_flEndTime_max: usize = 0x1D4; // float
    pub const m_flBias: usize = 0x1D8; // float
    pub const m_nField: usize = 0x200; // ParticleAttributeIndex_t
    pub const m_bProportionalOp: usize = 0x204; // bool
    pub const m_bEaseOut: usize = 0x205; // bool
}

pub mod C_OP_RampScalarSplineSimple {
    pub const m_Rate: usize = 0x1C0; // float
    pub const m_flStartTime: usize = 0x1C4; // float
    pub const m_flEndTime: usize = 0x1C8; // float
    pub const m_nField: usize = 0x1F0; // ParticleAttributeIndex_t
    pub const m_bEaseOut: usize = 0x1F4; // bool
}

pub mod C_OP_RandomForce {
    pub const m_MinForce: usize = 0x1D0; // Vector
    pub const m_MaxForce: usize = 0x1DC; // Vector
}

pub mod C_OP_ReadFromNeighboringParticle {
    pub const m_nFieldInput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_nFieldOutput: usize = 0x1C4; // ParticleAttributeIndex_t
    pub const m_nIncrement: usize = 0x1C8; // int32_t
    pub const m_DistanceCheck: usize = 0x1D0; // CPerParticleFloatInput
    pub const m_flInterpolation: usize = 0x328; // CPerParticleFloatInput
}

pub mod C_OP_ReinitializeScalarEndCap {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_flOutputMin: usize = 0x1C4; // float
    pub const m_flOutputMax: usize = 0x1C8; // float
}

pub mod C_OP_RemapAverageHitboxSpeedtoCP {
    pub const m_nInControlPointNumber: usize = 0x1D0; // int32_t
    pub const m_nOutControlPointNumber: usize = 0x1D4; // int32_t
    pub const m_nField: usize = 0x1D8; // int32_t
    pub const m_nHitboxDataType: usize = 0x1DC; // ParticleHitboxDataSelection_t
    pub const m_flInputMin: usize = 0x1E0; // CParticleCollectionFloatInput
    pub const m_flInputMax: usize = 0x338; // CParticleCollectionFloatInput
    pub const m_flOutputMin: usize = 0x490; // CParticleCollectionFloatInput
    pub const m_flOutputMax: usize = 0x5E8; // CParticleCollectionFloatInput
    pub const m_nHeightControlPointNumber: usize = 0x740; // int32_t
    pub const m_vecComparisonVelocity: usize = 0x748; // CParticleCollectionVecInput
    pub const m_HitboxSetName: usize = 0xDA0; // char[128]
}

pub mod C_OP_RemapAverageScalarValuetoCP {
    pub const m_nOutControlPointNumber: usize = 0x1D0; // int32_t
    pub const m_nOutVectorField: usize = 0x1D4; // int32_t
    pub const m_nField: usize = 0x1D8; // ParticleAttributeIndex_t
    pub const m_flInputMin: usize = 0x1DC; // float
    pub const m_flInputMax: usize = 0x1E0; // float
    pub const m_flOutputMin: usize = 0x1E4; // float
    pub const m_flOutputMax: usize = 0x1E8; // float
}

pub mod C_OP_RemapBoundingVolumetoCP {
    pub const m_nOutControlPointNumber: usize = 0x1D0; // int32_t
    pub const m_flInputMin: usize = 0x1D4; // float
    pub const m_flInputMax: usize = 0x1D8; // float
    pub const m_flOutputMin: usize = 0x1DC; // float
    pub const m_flOutputMax: usize = 0x1E0; // float
}

pub mod C_OP_RemapCPVelocityToVector {
    pub const m_nControlPoint: usize = 0x1C0; // int32_t
    pub const m_nFieldOutput: usize = 0x1C4; // ParticleAttributeIndex_t
    pub const m_flScale: usize = 0x1C8; // float
    pub const m_bNormalize: usize = 0x1CC; // bool
}

pub mod C_OP_RemapCPtoCP {
    pub const m_nInputControlPoint: usize = 0x1D0; // int32_t
    pub const m_nOutputControlPoint: usize = 0x1D4; // int32_t
    pub const m_nInputField: usize = 0x1D8; // int32_t
    pub const m_nOutputField: usize = 0x1DC; // int32_t
    pub const m_flInputMin: usize = 0x1E0; // float
    pub const m_flInputMax: usize = 0x1E4; // float
    pub const m_flOutputMin: usize = 0x1E8; // float
    pub const m_flOutputMax: usize = 0x1EC; // float
    pub const m_bDerivative: usize = 0x1F0; // bool
    pub const m_flInterpRate: usize = 0x1F4; // float
}

pub mod C_OP_RemapCPtoScalar {
    pub const m_nCPInput: usize = 0x1C0; // int32_t
    pub const m_nFieldOutput: usize = 0x1C4; // ParticleAttributeIndex_t
    pub const m_nField: usize = 0x1C8; // int32_t
    pub const m_flInputMin: usize = 0x1CC; // float
    pub const m_flInputMax: usize = 0x1D0; // float
    pub const m_flOutputMin: usize = 0x1D4; // float
    pub const m_flOutputMax: usize = 0x1D8; // float
    pub const m_flStartTime: usize = 0x1DC; // float
    pub const m_flEndTime: usize = 0x1E0; // float
    pub const m_flInterpRate: usize = 0x1E4; // float
    pub const m_nSetMethod: usize = 0x1E8; // ParticleSetMethod_t
}

pub mod C_OP_RemapCPtoVector {
    pub const m_nCPInput: usize = 0x1C0; // int32_t
    pub const m_nFieldOutput: usize = 0x1C4; // ParticleAttributeIndex_t
    pub const m_nLocalSpaceCP: usize = 0x1C8; // int32_t
    pub const m_vInputMin: usize = 0x1CC; // Vector
    pub const m_vInputMax: usize = 0x1D8; // Vector
    pub const m_vOutputMin: usize = 0x1E4; // Vector
    pub const m_vOutputMax: usize = 0x1F0; // Vector
    pub const m_flStartTime: usize = 0x1FC; // float
    pub const m_flEndTime: usize = 0x200; // float
    pub const m_flInterpRate: usize = 0x204; // float
    pub const m_nSetMethod: usize = 0x208; // ParticleSetMethod_t
    pub const m_bOffset: usize = 0x20C; // bool
    pub const m_bAccelerate: usize = 0x20D; // bool
}

pub mod C_OP_RemapControlPointDirectionToVector {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_flScale: usize = 0x1C4; // float
    pub const m_nControlPointNumber: usize = 0x1C8; // int32_t
}

pub mod C_OP_RemapControlPointOrientationToRotation {
    pub const m_nCP: usize = 0x1C0; // int32_t
    pub const m_nFieldOutput: usize = 0x1C4; // ParticleAttributeIndex_t
    pub const m_flOffsetRot: usize = 0x1C8; // float
    pub const m_nComponent: usize = 0x1CC; // int32_t
}

pub mod C_OP_RemapCrossProductOfTwoVectorsToVector {
    pub const m_InputVec1: usize = 0x1C0; // CPerParticleVecInput
    pub const m_InputVec2: usize = 0x818; // CPerParticleVecInput
    pub const m_nFieldOutput: usize = 0xE70; // ParticleAttributeIndex_t
    pub const m_bNormalize: usize = 0xE74; // bool
}

pub mod C_OP_RemapDensityGradientToVectorAttribute {
    pub const m_flRadiusScale: usize = 0x1C0; // float
    pub const m_nFieldOutput: usize = 0x1C4; // ParticleAttributeIndex_t
}

pub mod C_OP_RemapDensityToVector {
    pub const m_flRadiusScale: usize = 0x1C0; // float
    pub const m_nFieldOutput: usize = 0x1C4; // ParticleAttributeIndex_t
    pub const m_flDensityMin: usize = 0x1C8; // float
    pub const m_flDensityMax: usize = 0x1CC; // float
    pub const m_vecOutputMin: usize = 0x1D0; // Vector
    pub const m_vecOutputMax: usize = 0x1DC; // Vector
    pub const m_bUseParentDensity: usize = 0x1E8; // bool
    pub const m_nVoxelGridResolution: usize = 0x1EC; // int32_t
}

pub mod C_OP_RemapDirectionToCPToVector {
    pub const m_nCP: usize = 0x1C0; // int32_t
    pub const m_nFieldOutput: usize = 0x1C4; // ParticleAttributeIndex_t
    pub const m_flScale: usize = 0x1C8; // float
    pub const m_flOffsetRot: usize = 0x1CC; // float
    pub const m_vecOffsetAxis: usize = 0x1D0; // Vector
    pub const m_bNormalize: usize = 0x1DC; // bool
    pub const m_nFieldStrength: usize = 0x1E0; // ParticleAttributeIndex_t
}

pub mod C_OP_RemapDistanceToLineSegmentBase {
    pub const m_nCP0: usize = 0x1C0; // int32_t
    pub const m_nCP1: usize = 0x1C4; // int32_t
    pub const m_flMinInputValue: usize = 0x1C8; // float
    pub const m_flMaxInputValue: usize = 0x1CC; // float
    pub const m_bInfiniteLine: usize = 0x1D0; // bool
}

pub mod C_OP_RemapDistanceToLineSegmentToScalar {
    pub const m_nFieldOutput: usize = 0x1E0; // ParticleAttributeIndex_t
    pub const m_flMinOutputValue: usize = 0x1E4; // float
    pub const m_flMaxOutputValue: usize = 0x1E8; // float
}

pub mod C_OP_RemapDistanceToLineSegmentToVector {
    pub const m_nFieldOutput: usize = 0x1E0; // ParticleAttributeIndex_t
    pub const m_vMinOutputValue: usize = 0x1E4; // Vector
    pub const m_vMaxOutputValue: usize = 0x1F0; // Vector
}

pub mod C_OP_RemapDotProductToCP {
    pub const m_nInputCP1: usize = 0x1D0; // int32_t
    pub const m_nInputCP2: usize = 0x1D4; // int32_t
    pub const m_nOutputCP: usize = 0x1D8; // int32_t
    pub const m_nOutVectorField: usize = 0x1DC; // int32_t
    pub const m_flInputMin: usize = 0x1E0; // CParticleCollectionFloatInput
    pub const m_flInputMax: usize = 0x338; // CParticleCollectionFloatInput
    pub const m_flOutputMin: usize = 0x490; // CParticleCollectionFloatInput
    pub const m_flOutputMax: usize = 0x5E8; // CParticleCollectionFloatInput
}

pub mod C_OP_RemapDotProductToScalar {
    pub const m_nInputCP1: usize = 0x1C0; // int32_t
    pub const m_nInputCP2: usize = 0x1C4; // int32_t
    pub const m_nFieldOutput: usize = 0x1C8; // ParticleAttributeIndex_t
    pub const m_flInputMin: usize = 0x1CC; // float
    pub const m_flInputMax: usize = 0x1D0; // float
    pub const m_flOutputMin: usize = 0x1D4; // float
    pub const m_flOutputMax: usize = 0x1D8; // float
    pub const m_bUseParticleVelocity: usize = 0x1DC; // bool
    pub const m_nSetMethod: usize = 0x1E0; // ParticleSetMethod_t
    pub const m_bActiveRange: usize = 0x1E4; // bool
    pub const m_bUseParticleNormal: usize = 0x1E5; // bool
}

pub mod C_OP_RemapExternalWindToCP {
    pub const m_nCP: usize = 0x1D0; // int32_t
    pub const m_nCPOutput: usize = 0x1D4; // int32_t
    pub const m_vecScale: usize = 0x1D8; // CParticleCollectionVecInput
    pub const m_bSetMagnitude: usize = 0x830; // bool
    pub const m_nOutVectorField: usize = 0x834; // int32_t
}

pub mod C_OP_RemapModelVolumetoCP {
    pub const m_nBBoxType: usize = 0x1D0; // BBoxVolumeType_t
    pub const m_nInControlPointNumber: usize = 0x1D4; // int32_t
    pub const m_nOutControlPointNumber: usize = 0x1D8; // int32_t
    pub const m_nOutControlPointMaxNumber: usize = 0x1DC; // int32_t
    pub const m_nField: usize = 0x1E0; // int32_t
    pub const m_flInputMin: usize = 0x1E4; // float
    pub const m_flInputMax: usize = 0x1E8; // float
    pub const m_flOutputMin: usize = 0x1EC; // float
    pub const m_flOutputMax: usize = 0x1F0; // float
}

pub mod C_OP_RemapNamedModelElementEndCap {
    pub const m_hModel: usize = 0x1C0; // CStrongHandle<InfoForResourceTypeCModel>
    pub const m_inNames: usize = 0x1C8; // CUtlVector<CUtlString>
    pub const m_outNames: usize = 0x1E0; // CUtlVector<CUtlString>
    pub const m_fallbackNames: usize = 0x1F8; // CUtlVector<CUtlString>
    pub const m_bModelFromRenderer: usize = 0x210; // bool
    pub const m_nFieldInput: usize = 0x214; // ParticleAttributeIndex_t
    pub const m_nFieldOutput: usize = 0x218; // ParticleAttributeIndex_t
}

pub mod C_OP_RemapNamedModelElementOnceTimed {
    pub const m_hModel: usize = 0x1C0; // CStrongHandle<InfoForResourceTypeCModel>
    pub const m_inNames: usize = 0x1C8; // CUtlVector<CUtlString>
    pub const m_outNames: usize = 0x1E0; // CUtlVector<CUtlString>
    pub const m_fallbackNames: usize = 0x1F8; // CUtlVector<CUtlString>
    pub const m_bModelFromRenderer: usize = 0x210; // bool
    pub const m_bProportional: usize = 0x211; // bool
    pub const m_nFieldInput: usize = 0x214; // ParticleAttributeIndex_t
    pub const m_nFieldOutput: usize = 0x218; // ParticleAttributeIndex_t
    pub const m_flRemapTime: usize = 0x21C; // float
}

pub mod C_OP_RemapParticleCountOnScalarEndCap {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_nInputMin: usize = 0x1C4; // int32_t
    pub const m_nInputMax: usize = 0x1C8; // int32_t
    pub const m_flOutputMin: usize = 0x1CC; // float
    pub const m_flOutputMax: usize = 0x1D0; // float
    pub const m_bBackwards: usize = 0x1D4; // bool
    pub const m_nSetMethod: usize = 0x1D8; // ParticleSetMethod_t
}

pub mod C_OP_RemapParticleCountToScalar {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_nInputMin: usize = 0x1C8; // CParticleCollectionFloatInput
    pub const m_nInputMax: usize = 0x320; // CParticleCollectionFloatInput
    pub const m_flOutputMin: usize = 0x478; // CParticleCollectionFloatInput
    pub const m_flOutputMax: usize = 0x5D0; // CParticleCollectionFloatInput
    pub const m_bActiveRange: usize = 0x728; // bool
    pub const m_nSetMethod: usize = 0x72C; // ParticleSetMethod_t
}

pub mod C_OP_RemapSDFDistanceToScalarAttribute {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_nVectorFieldInput: usize = 0x1C4; // ParticleAttributeIndex_t
    pub const m_flMinDistance: usize = 0x1C8; // CParticleCollectionFloatInput
    pub const m_flMaxDistance: usize = 0x320; // CParticleCollectionFloatInput
    pub const m_flValueBelowMin: usize = 0x478; // CParticleCollectionFloatInput
    pub const m_flValueAtMin: usize = 0x5D0; // CParticleCollectionFloatInput
    pub const m_flValueAtMax: usize = 0x728; // CParticleCollectionFloatInput
    pub const m_flValueAboveMax: usize = 0x880; // CParticleCollectionFloatInput
}

pub mod C_OP_RemapSDFDistanceToVectorAttribute {
    pub const m_nVectorFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_nVectorFieldInput: usize = 0x1C4; // ParticleAttributeIndex_t
    pub const m_flMinDistance: usize = 0x1C8; // CParticleCollectionFloatInput
    pub const m_flMaxDistance: usize = 0x320; // CParticleCollectionFloatInput
    pub const m_vValueBelowMin: usize = 0x478; // Vector
    pub const m_vValueAtMin: usize = 0x484; // Vector
    pub const m_vValueAtMax: usize = 0x490; // Vector
    pub const m_vValueAboveMax: usize = 0x49C; // Vector
}

pub mod C_OP_RemapSDFGradientToVectorAttribute {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
}

pub mod C_OP_RemapScalar {
    pub const m_nFieldInput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_nFieldOutput: usize = 0x1C4; // ParticleAttributeIndex_t
    pub const m_flInputMin: usize = 0x1C8; // float
    pub const m_flInputMax: usize = 0x1CC; // float
    pub const m_flOutputMin: usize = 0x1D0; // float
    pub const m_flOutputMax: usize = 0x1D4; // float
    pub const m_bOldCode: usize = 0x1D8; // bool
}

pub mod C_OP_RemapScalarEndCap {
    pub const m_nFieldInput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_nFieldOutput: usize = 0x1C4; // ParticleAttributeIndex_t
    pub const m_flInputMin: usize = 0x1C8; // float
    pub const m_flInputMax: usize = 0x1CC; // float
    pub const m_flOutputMin: usize = 0x1D0; // float
    pub const m_flOutputMax: usize = 0x1D4; // float
}

pub mod C_OP_RemapScalarOnceTimed {
    pub const m_bProportional: usize = 0x1C0; // bool
    pub const m_nFieldInput: usize = 0x1C4; // ParticleAttributeIndex_t
    pub const m_nFieldOutput: usize = 0x1C8; // ParticleAttributeIndex_t
    pub const m_flInputMin: usize = 0x1CC; // float
    pub const m_flInputMax: usize = 0x1D0; // float
    pub const m_flOutputMin: usize = 0x1D4; // float
    pub const m_flOutputMax: usize = 0x1D8; // float
    pub const m_flRemapTime: usize = 0x1DC; // float
}

pub mod C_OP_RemapSpeed {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_flInputMin: usize = 0x1C4; // float
    pub const m_flInputMax: usize = 0x1C8; // float
    pub const m_flOutputMin: usize = 0x1CC; // float
    pub const m_flOutputMax: usize = 0x1D0; // float
    pub const m_nSetMethod: usize = 0x1D4; // ParticleSetMethod_t
    pub const m_bIgnoreDelta: usize = 0x1D8; // bool
}

pub mod C_OP_RemapSpeedtoCP {
    pub const m_nInControlPointNumber: usize = 0x1D0; // int32_t
    pub const m_nOutControlPointNumber: usize = 0x1D4; // int32_t
    pub const m_nField: usize = 0x1D8; // int32_t
    pub const m_flInputMin: usize = 0x1DC; // float
    pub const m_flInputMax: usize = 0x1E0; // float
    pub const m_flOutputMin: usize = 0x1E4; // float
    pub const m_flOutputMax: usize = 0x1E8; // float
    pub const m_bUseDeltaV: usize = 0x1EC; // bool
}

pub mod C_OP_RemapTransformOrientationToRotations {
    pub const m_TransformInput: usize = 0x1C0; // CParticleTransformInput
    pub const m_vecRotation: usize = 0x228; // Vector
    pub const m_bUseQuat: usize = 0x234; // bool
    pub const m_bWriteNormal: usize = 0x235; // bool
}

pub mod C_OP_RemapTransformOrientationToYaw {
    pub const m_TransformInput: usize = 0x1C0; // CParticleTransformInput
    pub const m_nFieldOutput: usize = 0x228; // ParticleAttributeIndex_t
    pub const m_flRotOffset: usize = 0x22C; // float
    pub const m_flSpinStrength: usize = 0x230; // float
}

pub mod C_OP_RemapTransformToVelocity {
    pub const m_TransformInput: usize = 0x1C0; // CParticleTransformInput
}

pub mod C_OP_RemapTransformVisibilityToScalar {
    pub const m_nSetMethod: usize = 0x1C0; // ParticleSetMethod_t
    pub const m_TransformInput: usize = 0x1C8; // CParticleTransformInput
    pub const m_nFieldOutput: usize = 0x230; // ParticleAttributeIndex_t
    pub const m_flInputMin: usize = 0x234; // float
    pub const m_flInputMax: usize = 0x238; // float
    pub const m_flOutputMin: usize = 0x23C; // float
    pub const m_flOutputMax: usize = 0x240; // float
    pub const m_flRadius: usize = 0x244; // float
}

pub mod C_OP_RemapTransformVisibilityToVector {
    pub const m_nSetMethod: usize = 0x1C0; // ParticleSetMethod_t
    pub const m_TransformInput: usize = 0x1C8; // CParticleTransformInput
    pub const m_nFieldOutput: usize = 0x230; // ParticleAttributeIndex_t
    pub const m_flInputMin: usize = 0x234; // float
    pub const m_flInputMax: usize = 0x238; // float
    pub const m_vecOutputMin: usize = 0x23C; // Vector
    pub const m_vecOutputMax: usize = 0x248; // Vector
    pub const m_flRadius: usize = 0x254; // float
}

pub mod C_OP_RemapVectorComponentToScalar {
    pub const m_nFieldInput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_nFieldOutput: usize = 0x1C4; // ParticleAttributeIndex_t
    pub const m_nComponent: usize = 0x1C8; // int32_t
}

pub mod C_OP_RemapVectortoCP {
    pub const m_nOutControlPointNumber: usize = 0x1C0; // int32_t
    pub const m_nFieldInput: usize = 0x1C4; // ParticleAttributeIndex_t
    pub const m_nParticleNumber: usize = 0x1C8; // int32_t
}

pub mod C_OP_RemapVelocityToVector {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_flScale: usize = 0x1C4; // float
    pub const m_bNormalize: usize = 0x1C8; // bool
}

pub mod C_OP_RemapVisibilityScalar {
    pub const m_nFieldInput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_nFieldOutput: usize = 0x1C4; // ParticleAttributeIndex_t
    pub const m_flInputMin: usize = 0x1C8; // float
    pub const m_flInputMax: usize = 0x1CC; // float
    pub const m_flOutputMin: usize = 0x1D0; // float
    pub const m_flOutputMax: usize = 0x1D4; // float
    pub const m_flRadiusScale: usize = 0x1D8; // float
}

pub mod C_OP_RenderAsModels {
    pub const m_ModelList: usize = 0x200; // CUtlVector<ModelReference_t>
    pub const m_flModelScale: usize = 0x21C; // float
    pub const m_bFitToModelSize: usize = 0x220; // bool
    pub const m_bNonUniformScaling: usize = 0x221; // bool
    pub const m_nXAxisScalingAttribute: usize = 0x224; // ParticleAttributeIndex_t
    pub const m_nYAxisScalingAttribute: usize = 0x228; // ParticleAttributeIndex_t
    pub const m_nZAxisScalingAttribute: usize = 0x22C; // ParticleAttributeIndex_t
    pub const m_nSizeCullBloat: usize = 0x230; // int32_t
}

pub mod C_OP_RenderBlobs {
    pub const m_cubeWidth: usize = 0x200; // CParticleCollectionRendererFloatInput
    pub const m_cutoffRadius: usize = 0x358; // CParticleCollectionRendererFloatInput
    pub const m_renderRadius: usize = 0x4B0; // CParticleCollectionRendererFloatInput
    pub const m_nScaleCP: usize = 0x608; // int32_t
    pub const m_MaterialVars: usize = 0x610; // CUtlVector<MaterialVariable_t>
    pub const m_hMaterial: usize = 0x640; // CStrongHandle<InfoForResourceTypeIMaterial2>
}

pub mod C_OP_RenderCables {
    pub const m_flRadiusScale: usize = 0x200; // CParticleCollectionFloatInput
    pub const m_flAlphaScale: usize = 0x358; // CParticleCollectionFloatInput
    pub const m_vecColorScale: usize = 0x4B0; // CParticleCollectionVecInput
    pub const m_nColorBlendType: usize = 0xB08; // ParticleColorBlendType_t
    pub const m_hMaterial: usize = 0xB10; // CStrongHandle<InfoForResourceTypeIMaterial2>
    pub const m_nTextureRepetitionMode: usize = 0xB18; // TextureRepetitionMode_t
    pub const m_flTextureRepeatsPerSegment: usize = 0xB20; // CParticleCollectionFloatInput
    pub const m_flTextureRepeatsCircumference: usize = 0xC78; // CParticleCollectionFloatInput
    pub const m_flColorMapOffsetV: usize = 0xDD0; // CParticleCollectionFloatInput
    pub const m_flColorMapOffsetU: usize = 0xF28; // CParticleCollectionFloatInput
    pub const m_flNormalMapOffsetV: usize = 0x1080; // CParticleCollectionFloatInput
    pub const m_flNormalMapOffsetU: usize = 0x11D8; // CParticleCollectionFloatInput
    pub const m_bDrawCableCaps: usize = 0x1330; // bool
    pub const m_flCapRoundness: usize = 0x1334; // float
    pub const m_flCapOffsetAmount: usize = 0x1338; // float
    pub const m_flTessScale: usize = 0x133C; // float
    pub const m_nMinTesselation: usize = 0x1340; // int32_t
    pub const m_nMaxTesselation: usize = 0x1344; // int32_t
    pub const m_nRoundness: usize = 0x1348; // int32_t
    pub const m_LightingTransform: usize = 0x1350; // CParticleTransformInput
    pub const m_MaterialFloatVars: usize = 0x13B8; // CUtlVector<FloatInputMaterialVariable_t>
    pub const m_MaterialVecVars: usize = 0x13E8; // CUtlVector<VecInputMaterialVariable_t>
}

pub mod C_OP_RenderDeferredLight {
    pub const m_bUseAlphaTestWindow: usize = 0x200; // bool
    pub const m_bUseTexture: usize = 0x201; // bool
    pub const m_flRadiusScale: usize = 0x204; // float
    pub const m_flAlphaScale: usize = 0x208; // float
    pub const m_nAlpha2Field: usize = 0x20C; // ParticleAttributeIndex_t
    pub const m_vecColorScale: usize = 0x210; // CParticleCollectionVecInput
    pub const m_nColorBlendType: usize = 0x868; // ParticleColorBlendType_t
    pub const m_flLightDistance: usize = 0x86C; // float
    pub const m_flStartFalloff: usize = 0x870; // float
    pub const m_flDistanceFalloff: usize = 0x874; // float
    pub const m_flSpotFoV: usize = 0x878; // float
    pub const m_nAlphaTestPointField: usize = 0x87C; // ParticleAttributeIndex_t
    pub const m_nAlphaTestRangeField: usize = 0x880; // ParticleAttributeIndex_t
    pub const m_nAlphaTestSharpnessField: usize = 0x884; // ParticleAttributeIndex_t
    pub const m_hTexture: usize = 0x888; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_nHSVShiftControlPoint: usize = 0x890; // int32_t
}

pub mod C_OP_RenderFlattenGrass {
    pub const m_flFlattenStrength: usize = 0x200; // float
    pub const m_nStrengthFieldOverride: usize = 0x204; // ParticleAttributeIndex_t
    pub const m_flRadiusScale: usize = 0x208; // float
}

pub mod C_OP_RenderGpuImplicit {
    pub const m_bUsePerParticleRadius: usize = 0x200; // bool
    pub const m_fGridSize: usize = 0x208; // CParticleCollectionRendererFloatInput
    pub const m_fRadiusScale: usize = 0x360; // CParticleCollectionRendererFloatInput
    pub const m_fIsosurfaceThreshold: usize = 0x4B8; // CParticleCollectionRendererFloatInput
    pub const m_nScaleCP: usize = 0x610; // int32_t
    pub const m_hMaterial: usize = 0x618; // CStrongHandle<InfoForResourceTypeIMaterial2>
}

pub mod C_OP_RenderLightBeam {
    pub const m_vColorBlend: usize = 0x200; // CParticleCollectionVecInput
    pub const m_nColorBlendType: usize = 0x858; // ParticleColorBlendType_t
    pub const m_flBrightnessLumensPerMeter: usize = 0x860; // CParticleCollectionFloatInput
    pub const m_bCastShadows: usize = 0x9B8; // bool
    pub const m_flSkirt: usize = 0x9C0; // CParticleCollectionFloatInput
    pub const m_flRange: usize = 0xB18; // CParticleCollectionFloatInput
    pub const m_flThickness: usize = 0xC70; // CParticleCollectionFloatInput
}

pub mod C_OP_RenderLights {
    pub const m_flAnimationRate: usize = 0x210; // float
    pub const m_nAnimationType: usize = 0x214; // AnimationType_t
    pub const m_bAnimateInFPS: usize = 0x218; // bool
    pub const m_flMinSize: usize = 0x21C; // float
    pub const m_flMaxSize: usize = 0x220; // float
    pub const m_flStartFadeSize: usize = 0x224; // float
    pub const m_flEndFadeSize: usize = 0x228; // float
}

pub mod C_OP_RenderMaterialProxy {
    pub const m_nMaterialControlPoint: usize = 0x200; // int32_t
    pub const m_nProxyType: usize = 0x204; // MaterialProxyType_t
    pub const m_MaterialVars: usize = 0x208; // CUtlVector<MaterialVariable_t>
    pub const m_hOverrideMaterial: usize = 0x220; // CStrongHandle<InfoForResourceTypeIMaterial2>
    pub const m_flMaterialOverrideEnabled: usize = 0x228; // CParticleCollectionFloatInput
    pub const m_vecColorScale: usize = 0x380; // CParticleCollectionVecInput
    pub const m_flAlpha: usize = 0x9D8; // CPerParticleFloatInput
    pub const m_nColorBlendType: usize = 0xB30; // ParticleColorBlendType_t
}

pub mod C_OP_RenderModels {
    pub const m_bOnlyRenderInEffectsBloomPass: usize = 0x200; // bool
    pub const m_bOnlyRenderInEffectsWaterPass: usize = 0x201; // bool
    pub const m_bUseMixedResolutionRendering: usize = 0x202; // bool
    pub const m_bOnlyRenderInEffecsGameOverlay: usize = 0x203; // bool
    pub const m_ModelList: usize = 0x208; // CUtlVector<ModelReference_t>
    pub const m_nBodyGroupField: usize = 0x224; // ParticleAttributeIndex_t
    pub const m_nSubModelField: usize = 0x228; // ParticleAttributeIndex_t
    pub const m_bIgnoreNormal: usize = 0x22C; // bool
    pub const m_bOrientZ: usize = 0x22D; // bool
    pub const m_bCenterOffset: usize = 0x22E; // bool
    pub const m_vecLocalOffset: usize = 0x230; // CPerParticleVecInput
    pub const m_vecLocalRotation: usize = 0x888; // CPerParticleVecInput
    pub const m_bIgnoreRadius: usize = 0xEE0; // bool
    pub const m_nModelScaleCP: usize = 0xEE4; // int32_t
    pub const m_vecComponentScale: usize = 0xEE8; // CPerParticleVecInput
    pub const m_bLocalScale: usize = 0x1540; // bool
    pub const m_nSizeCullBloat: usize = 0x1544; // int32_t
    pub const m_bAnimated: usize = 0x1548; // bool
    pub const m_flAnimationRate: usize = 0x154C; // float
    pub const m_bScaleAnimationRate: usize = 0x1550; // bool
    pub const m_bForceLoopingAnimation: usize = 0x1551; // bool
    pub const m_bResetAnimOnStop: usize = 0x1552; // bool
    pub const m_bManualAnimFrame: usize = 0x1553; // bool
    pub const m_nAnimationScaleField: usize = 0x1554; // ParticleAttributeIndex_t
    pub const m_nAnimationField: usize = 0x1558; // ParticleAttributeIndex_t
    pub const m_nManualFrameField: usize = 0x155C; // ParticleAttributeIndex_t
    pub const m_ActivityName: usize = 0x1560; // char[256]
    pub const m_SequenceName: usize = 0x1660; // char[256]
    pub const m_bEnableClothSimulation: usize = 0x1760; // bool
    pub const m_hOverrideMaterial: usize = 0x1768; // CStrongHandle<InfoForResourceTypeIMaterial2>
    pub const m_bOverrideTranslucentMaterials: usize = 0x1770; // bool
    pub const m_nSkin: usize = 0x1778; // CPerParticleFloatInput
    pub const m_MaterialVars: usize = 0x18D0; // CUtlVector<MaterialVariable_t>
    pub const m_modelInput: usize = 0x18E8; // CParticleModelInput
    pub const m_nLOD: usize = 0x1948; // int32_t
    pub const m_EconSlotName: usize = 0x194C; // char[256]
    pub const m_bOriginalModel: usize = 0x1A4C; // bool
    pub const m_bSuppressTint: usize = 0x1A4D; // bool
    pub const m_bUseRawMeshGroup: usize = 0x1A4E; // bool
    pub const m_bDisableShadows: usize = 0x1A4F; // bool
    pub const m_bAcceptsDecals: usize = 0x1A50; // bool
    pub const m_bForceDrawInterlevedWithSiblings: usize = 0x1A51; // bool
    pub const m_bDoNotDrawInParticlePass: usize = 0x1A52; // bool
    pub const m_szRenderAttribute: usize = 0x1A53; // char[260]
    pub const m_flRadiusScale: usize = 0x1B58; // CParticleCollectionFloatInput
    pub const m_flAlphaScale: usize = 0x1CB0; // CParticleCollectionFloatInput
    pub const m_flRollScale: usize = 0x1E08; // CParticleCollectionFloatInput
    pub const m_nAlpha2Field: usize = 0x1F60; // ParticleAttributeIndex_t
    pub const m_vecColorScale: usize = 0x1F68; // CParticleCollectionVecInput
    pub const m_nColorBlendType: usize = 0x25C0; // ParticleColorBlendType_t
}

pub mod C_OP_RenderOmni2Light {
    pub const m_nLightType: usize = 0x200; // ParticleOmni2LightTypeChoiceList_t
    pub const m_vColorBlend: usize = 0x208; // CParticleCollectionVecInput
    pub const m_nColorBlendType: usize = 0x860; // ParticleColorBlendType_t
    pub const m_nBrightnessUnit: usize = 0x864; // ParticleLightUnitChoiceList_t
    pub const m_flBrightnessLumens: usize = 0x868; // CPerParticleFloatInput
    pub const m_flBrightnessCandelas: usize = 0x9C0; // CPerParticleFloatInput
    pub const m_bCastShadows: usize = 0xB18; // bool
    pub const m_flLuminaireRadius: usize = 0xB20; // CPerParticleFloatInput
    pub const m_flSkirt: usize = 0xC78; // CPerParticleFloatInput
    pub const m_flRange: usize = 0xDD0; // CPerParticleFloatInput
    pub const m_flInnerConeAngle: usize = 0xF28; // CPerParticleFloatInput
    pub const m_flOuterConeAngle: usize = 0x1080; // CPerParticleFloatInput
    pub const m_hLightCookie: usize = 0x11D8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_bSphericalCookie: usize = 0x11E0; // bool
}

pub mod C_OP_RenderPoints {
    pub const m_hMaterial: usize = 0x200; // CStrongHandle<InfoForResourceTypeIMaterial2>
}

pub mod C_OP_RenderPostProcessing {
    pub const m_flPostProcessStrength: usize = 0x200; // CPerParticleFloatInput
    pub const m_hPostTexture: usize = 0x358; // CStrongHandle<InfoForResourceTypeCPostProcessingResource>
    pub const m_nPriority: usize = 0x360; // ParticlePostProcessPriorityGroup_t
}

pub mod C_OP_RenderProjected {
    pub const m_bProjectCharacter: usize = 0x200; // bool
    pub const m_bProjectWorld: usize = 0x201; // bool
    pub const m_bProjectWater: usize = 0x202; // bool
    pub const m_bFlipHorizontal: usize = 0x203; // bool
    pub const m_bEnableProjectedDepthControls: usize = 0x204; // bool
    pub const m_flMinProjectionDepth: usize = 0x208; // float
    pub const m_flMaxProjectionDepth: usize = 0x20C; // float
    pub const m_hProjectedMaterial: usize = 0x210; // CStrongHandle<InfoForResourceTypeIMaterial2>
    pub const m_flAnimationTimeScale: usize = 0x218; // float
    pub const m_bOrientToNormal: usize = 0x21C; // bool
    pub const m_MaterialVars: usize = 0x220; // CUtlVector<MaterialVariable_t>
}

pub mod C_OP_RenderRopes {
    pub const m_bEnableFadingAndClamping: usize = 0x2470; // bool
    pub const m_flMinSize: usize = 0x2474; // float
    pub const m_flMaxSize: usize = 0x2478; // float
    pub const m_flStartFadeSize: usize = 0x247C; // float
    pub const m_flEndFadeSize: usize = 0x2480; // float
    pub const m_flStartFadeDot: usize = 0x2484; // float
    pub const m_flEndFadeDot: usize = 0x2488; // float
    pub const m_flRadiusTaper: usize = 0x248C; // float
    pub const m_nMinTesselation: usize = 0x2490; // int32_t
    pub const m_nMaxTesselation: usize = 0x2494; // int32_t
    pub const m_flTessScale: usize = 0x2498; // float
    pub const m_flTextureVWorldSize: usize = 0x24A0; // CParticleCollectionRendererFloatInput
    pub const m_flTextureVScrollRate: usize = 0x25F8; // CParticleCollectionRendererFloatInput
    pub const m_flTextureVOffset: usize = 0x2750; // CParticleCollectionRendererFloatInput
    pub const m_nTextureVParamsCP: usize = 0x28A8; // int32_t
    pub const m_bClampV: usize = 0x28AC; // bool
    pub const m_nScaleCP1: usize = 0x28B0; // int32_t
    pub const m_nScaleCP2: usize = 0x28B4; // int32_t
    pub const m_flScaleVSizeByControlPointDistance: usize = 0x28B8; // float
    pub const m_flScaleVScrollByControlPointDistance: usize = 0x28BC; // float
    pub const m_flScaleVOffsetByControlPointDistance: usize = 0x28C0; // float
    pub const m_bUseScalarForTextureCoordinate: usize = 0x28C5; // bool
    pub const m_nScalarFieldForTextureCoordinate: usize = 0x28C8; // ParticleAttributeIndex_t
    pub const m_flScalarAttributeTextureCoordScale: usize = 0x28CC; // float
    pub const m_bReverseOrder: usize = 0x28D0; // bool
    pub const m_bClosedLoop: usize = 0x28D1; // bool
    pub const m_nOrientationType: usize = 0x28D4; // ParticleOrientationChoiceList_t
    pub const m_nVectorFieldForOrientation: usize = 0x28D8; // ParticleAttributeIndex_t
    pub const m_bDrawAsOpaque: usize = 0x28DC; // bool
    pub const m_bGenerateNormals: usize = 0x28DD; // bool
}

pub mod C_OP_RenderScreenShake {
    pub const m_flDurationScale: usize = 0x200; // float
    pub const m_flRadiusScale: usize = 0x204; // float
    pub const m_flFrequencyScale: usize = 0x208; // float
    pub const m_flAmplitudeScale: usize = 0x20C; // float
    pub const m_nRadiusField: usize = 0x210; // ParticleAttributeIndex_t
    pub const m_nDurationField: usize = 0x214; // ParticleAttributeIndex_t
    pub const m_nFrequencyField: usize = 0x218; // ParticleAttributeIndex_t
    pub const m_nAmplitudeField: usize = 0x21C; // ParticleAttributeIndex_t
    pub const m_nFilterCP: usize = 0x220; // int32_t
}

pub mod C_OP_RenderScreenVelocityRotate {
    pub const m_flRotateRateDegrees: usize = 0x200; // float
    pub const m_flForwardDegrees: usize = 0x204; // float
}

pub mod C_OP_RenderSound {
    pub const m_flDurationScale: usize = 0x200; // float
    pub const m_flSndLvlScale: usize = 0x204; // float
    pub const m_flPitchScale: usize = 0x208; // float
    pub const m_flVolumeScale: usize = 0x20C; // float
    pub const m_nSndLvlField: usize = 0x210; // ParticleAttributeIndex_t
    pub const m_nDurationField: usize = 0x214; // ParticleAttributeIndex_t
    pub const m_nPitchField: usize = 0x218; // ParticleAttributeIndex_t
    pub const m_nVolumeField: usize = 0x21C; // ParticleAttributeIndex_t
    pub const m_nChannel: usize = 0x220; // int32_t
    pub const m_nCPReference: usize = 0x224; // int32_t
    pub const m_pszSoundName: usize = 0x228; // char[256]
    pub const m_bSuppressStopSoundEvent: usize = 0x328; // bool
}

pub mod C_OP_RenderSprites {
    pub const m_nSequenceOverride: usize = 0x2470; // CParticleCollectionRendererFloatInput
    pub const m_nOrientationType: usize = 0x25C8; // ParticleOrientationChoiceList_t
    pub const m_nOrientationControlPoint: usize = 0x25CC; // int32_t
    pub const m_bUseYawWithNormalAligned: usize = 0x25D0; // bool
    pub const m_flMinSize: usize = 0x25D4; // float
    pub const m_flMaxSize: usize = 0x25D8; // float
    pub const m_flAlphaAdjustWithSizeAdjust: usize = 0x25DC; // float
    pub const m_flStartFadeSize: usize = 0x25E0; // CParticleCollectionRendererFloatInput
    pub const m_flEndFadeSize: usize = 0x2738; // CParticleCollectionRendererFloatInput
    pub const m_flStartFadeDot: usize = 0x2890; // float
    pub const m_flEndFadeDot: usize = 0x2894; // float
    pub const m_bDistanceAlpha: usize = 0x2898; // bool
    pub const m_bSoftEdges: usize = 0x2899; // bool
    pub const m_flEdgeSoftnessStart: usize = 0x289C; // float
    pub const m_flEdgeSoftnessEnd: usize = 0x28A0; // float
    pub const m_bOutline: usize = 0x28A4; // bool
    pub const m_OutlineColor: usize = 0x28A5; // Color
    pub const m_nOutlineAlpha: usize = 0x28AC; // int32_t
    pub const m_flOutlineStart0: usize = 0x28B0; // float
    pub const m_flOutlineStart1: usize = 0x28B4; // float
    pub const m_flOutlineEnd0: usize = 0x28B8; // float
    pub const m_flOutlineEnd1: usize = 0x28BC; // float
    pub const m_nLightingMode: usize = 0x28C0; // ParticleLightingQuality_t
    pub const m_flLightingTessellation: usize = 0x28C8; // CParticleCollectionRendererFloatInput
    pub const m_flLightingDirectionality: usize = 0x2A20; // CParticleCollectionRendererFloatInput
    pub const m_bParticleShadows: usize = 0x2B78; // bool
    pub const m_flShadowDensity: usize = 0x2B7C; // float
}

pub mod C_OP_RenderStandardLight {
    pub const m_nLightType: usize = 0x200; // ParticleLightTypeChoiceList_t
    pub const m_vecColorScale: usize = 0x208; // CParticleCollectionVecInput
    pub const m_nColorBlendType: usize = 0x860; // ParticleColorBlendType_t
    pub const m_flIntensity: usize = 0x868; // CParticleCollectionFloatInput
    pub const m_bCastShadows: usize = 0x9C0; // bool
    pub const m_flTheta: usize = 0x9C8; // CParticleCollectionFloatInput
    pub const m_flPhi: usize = 0xB20; // CParticleCollectionFloatInput
    pub const m_flRadiusMultiplier: usize = 0xC78; // CParticleCollectionFloatInput
    pub const m_nAttenuationStyle: usize = 0xDD0; // StandardLightingAttenuationStyle_t
    pub const m_flFalloffLinearity: usize = 0xDD8; // CParticleCollectionFloatInput
    pub const m_flFiftyPercentFalloff: usize = 0xF30; // CParticleCollectionFloatInput
    pub const m_flZeroPercentFalloff: usize = 0x1088; // CParticleCollectionFloatInput
    pub const m_bRenderDiffuse: usize = 0x11E0; // bool
    pub const m_bRenderSpecular: usize = 0x11E1; // bool
    pub const m_lightCookie: usize = 0x11E8; // CUtlString
    pub const m_nPriority: usize = 0x11F0; // int32_t
    pub const m_nFogLightingMode: usize = 0x11F4; // ParticleLightFogLightingMode_t
    pub const m_flFogContribution: usize = 0x11F8; // CParticleCollectionRendererFloatInput
    pub const m_nCapsuleLightBehavior: usize = 0x1350; // ParticleLightBehaviorChoiceList_t
    pub const m_flCapsuleLength: usize = 0x1354; // float
    pub const m_bReverseOrder: usize = 0x1358; // bool
    pub const m_bClosedLoop: usize = 0x1359; // bool
    pub const m_nPrevPntSource: usize = 0x135C; // ParticleAttributeIndex_t
    pub const m_flMaxLength: usize = 0x1360; // float
    pub const m_flMinLength: usize = 0x1364; // float
    pub const m_bIgnoreDT: usize = 0x1368; // bool
    pub const m_flConstrainRadiusToLengthRatio: usize = 0x136C; // float
    pub const m_flLengthScale: usize = 0x1370; // float
    pub const m_flLengthFadeInTime: usize = 0x1374; // float
}

pub mod C_OP_RenderStatusEffect {
    pub const m_pTextureColorWarp: usize = 0x200; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_pTextureDetail2: usize = 0x208; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_pTextureDiffuseWarp: usize = 0x210; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_pTextureFresnelColorWarp: usize = 0x218; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_pTextureFresnelWarp: usize = 0x220; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_pTextureSpecularWarp: usize = 0x228; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_pTextureEnvMap: usize = 0x230; // CStrongHandle<InfoForResourceTypeCTextureBase>
}

pub mod C_OP_RenderStatusEffectCitadel {
    pub const m_pTextureColorWarp: usize = 0x200; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_pTextureNormal: usize = 0x208; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_pTextureMetalness: usize = 0x210; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_pTextureRoughness: usize = 0x218; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_pTextureSelfIllum: usize = 0x220; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_pTextureDetail: usize = 0x228; // CStrongHandle<InfoForResourceTypeCTextureBase>
}

pub mod C_OP_RenderText {
    pub const m_OutlineColor: usize = 0x200; // Color
    pub const m_DefaultText: usize = 0x208; // CUtlString
}

pub mod C_OP_RenderTonemapController {
    pub const m_flTonemapLevel: usize = 0x200; // float
    pub const m_flTonemapWeight: usize = 0x204; // float
    pub const m_nTonemapLevelField: usize = 0x208; // ParticleAttributeIndex_t
    pub const m_nTonemapWeightField: usize = 0x20C; // ParticleAttributeIndex_t
}

pub mod C_OP_RenderTrails {
    pub const m_bEnableFadingAndClamping: usize = 0x2740; // bool
    pub const m_flStartFadeDot: usize = 0x2744; // float
    pub const m_flEndFadeDot: usize = 0x2748; // float
    pub const m_nPrevPntSource: usize = 0x274C; // ParticleAttributeIndex_t
    pub const m_flMaxLength: usize = 0x2750; // float
    pub const m_flMinLength: usize = 0x2754; // float
    pub const m_bIgnoreDT: usize = 0x2758; // bool
    pub const m_flConstrainRadiusToLengthRatio: usize = 0x275C; // float
    pub const m_flLengthScale: usize = 0x2760; // float
    pub const m_flLengthFadeInTime: usize = 0x2764; // float
    pub const m_flRadiusHeadTaper: usize = 0x2768; // CPerParticleFloatInput
    pub const m_vecHeadColorScale: usize = 0x28C0; // CParticleCollectionVecInput
    pub const m_flHeadAlphaScale: usize = 0x2F18; // CPerParticleFloatInput
    pub const m_flRadiusTaper: usize = 0x3070; // CPerParticleFloatInput
    pub const m_vecTailColorScale: usize = 0x31C8; // CParticleCollectionVecInput
    pub const m_flTailAlphaScale: usize = 0x3820; // CPerParticleFloatInput
    pub const m_nHorizCropField: usize = 0x3978; // ParticleAttributeIndex_t
    pub const m_nVertCropField: usize = 0x397C; // ParticleAttributeIndex_t
    pub const m_flForwardShift: usize = 0x3980; // float
    pub const m_bFlipUVBasedOnPitchYaw: usize = 0x3984; // bool
}

pub mod C_OP_RenderTreeShake {
    pub const m_flPeakStrength: usize = 0x200; // float
    pub const m_nPeakStrengthFieldOverride: usize = 0x204; // ParticleAttributeIndex_t
    pub const m_flRadius: usize = 0x208; // float
    pub const m_nRadiusFieldOverride: usize = 0x20C; // ParticleAttributeIndex_t
    pub const m_flShakeDuration: usize = 0x210; // float
    pub const m_flTransitionTime: usize = 0x214; // float
    pub const m_flTwistAmount: usize = 0x218; // float
    pub const m_flRadialAmount: usize = 0x21C; // float
    pub const m_flControlPointOrientationAmount: usize = 0x220; // float
    pub const m_nControlPointForLinearDirection: usize = 0x224; // int32_t
}

pub mod C_OP_RenderVRHapticEvent {
    pub const m_nHand: usize = 0x200; // ParticleVRHandChoiceList_t
    pub const m_nOutputHandCP: usize = 0x204; // int32_t
    pub const m_nOutputField: usize = 0x208; // int32_t
    pub const m_flAmplitude: usize = 0x210; // CPerParticleFloatInput
}

pub mod C_OP_RepeatedTriggerChildGroup {
    pub const m_nChildGroupID: usize = 0x1D0; // int32_t
    pub const m_flClusterRefireTime: usize = 0x1D8; // CParticleCollectionFloatInput
    pub const m_flClusterSize: usize = 0x330; // CParticleCollectionFloatInput
    pub const m_flClusterCooldown: usize = 0x488; // CParticleCollectionFloatInput
    pub const m_bLimitChildCount: usize = 0x5E0; // bool
}

pub mod C_OP_RestartAfterDuration {
    pub const m_flDurationMin: usize = 0x1C0; // float
    pub const m_flDurationMax: usize = 0x1C4; // float
    pub const m_nCP: usize = 0x1C8; // int32_t
    pub const m_nCPField: usize = 0x1CC; // int32_t
    pub const m_nChildGroupID: usize = 0x1D0; // int32_t
    pub const m_bOnlyChildren: usize = 0x1D4; // bool
}

pub mod C_OP_RopeSpringConstraint {
    pub const m_flRestLength: usize = 0x1C0; // CParticleCollectionFloatInput
    pub const m_flMinDistance: usize = 0x318; // CParticleCollectionFloatInput
    pub const m_flMaxDistance: usize = 0x470; // CParticleCollectionFloatInput
    pub const m_flAdjustmentScale: usize = 0x5C8; // float
    pub const m_flInitialRestingLength: usize = 0x5D0; // CParticleCollectionFloatInput
}

pub mod C_OP_RotateVector {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_vecRotAxisMin: usize = 0x1C4; // Vector
    pub const m_vecRotAxisMax: usize = 0x1D0; // Vector
    pub const m_flRotRateMin: usize = 0x1DC; // float
    pub const m_flRotRateMax: usize = 0x1E0; // float
    pub const m_bNormalize: usize = 0x1E4; // bool
    pub const m_flScale: usize = 0x1E8; // CPerParticleFloatInput
}

pub mod C_OP_RtEnvCull {
    pub const m_vecTestDir: usize = 0x1C0; // Vector
    pub const m_vecTestNormal: usize = 0x1CC; // Vector
    pub const m_bCullOnMiss: usize = 0x1D8; // bool
    pub const m_bStickInsteadOfCull: usize = 0x1D9; // bool
    pub const m_RtEnvName: usize = 0x1DA; // char[128]
    pub const m_nRTEnvCP: usize = 0x25C; // int32_t
    pub const m_nComponent: usize = 0x260; // int32_t
}

pub mod C_OP_SDFConstraint {
    pub const m_flMinDist: usize = 0x1C0; // CParticleCollectionFloatInput
    pub const m_flMaxDist: usize = 0x318; // CParticleCollectionFloatInput
    pub const m_nMaxIterations: usize = 0x470; // int32_t
}

pub mod C_OP_SDFForce {
    pub const m_flForceScale: usize = 0x1D0; // float
}

pub mod C_OP_SDFLighting {
    pub const m_vLightingDir: usize = 0x1C0; // Vector
    pub const m_vTint_0: usize = 0x1CC; // Vector
    pub const m_vTint_1: usize = 0x1D8; // Vector
}

pub mod C_OP_SelectivelyEnableChildren {
    pub const m_nChildGroupID: usize = 0x1D0; // CParticleCollectionFloatInput
    pub const m_nFirstChild: usize = 0x328; // CParticleCollectionFloatInput
    pub const m_nNumChildrenToEnable: usize = 0x480; // CParticleCollectionFloatInput
    pub const m_bPlayEndcapOnStop: usize = 0x5D8; // bool
    pub const m_bDestroyImmediately: usize = 0x5D9; // bool
}

pub mod C_OP_SequenceFromModel {
    pub const m_nControlPointNumber: usize = 0x1C0; // int32_t
    pub const m_nFieldOutput: usize = 0x1C4; // ParticleAttributeIndex_t
    pub const m_nFieldOutputAnim: usize = 0x1C8; // ParticleAttributeIndex_t
    pub const m_flInputMin: usize = 0x1CC; // float
    pub const m_flInputMax: usize = 0x1D0; // float
    pub const m_flOutputMin: usize = 0x1D4; // float
    pub const m_flOutputMax: usize = 0x1D8; // float
    pub const m_nSetMethod: usize = 0x1DC; // ParticleSetMethod_t
}

pub mod C_OP_SetAttributeToScalarExpression {
    pub const m_nExpression: usize = 0x1C0; // ScalarExpressionType_t
    pub const m_flInput1: usize = 0x1C8; // CPerParticleFloatInput
    pub const m_flInput2: usize = 0x320; // CPerParticleFloatInput
    pub const m_nOutputField: usize = 0x478; // ParticleAttributeIndex_t
    pub const m_nSetMethod: usize = 0x47C; // ParticleSetMethod_t
}

pub mod C_OP_SetCPOrientationToDirection {
    pub const m_nInputControlPoint: usize = 0x1C0; // int32_t
    pub const m_nOutputControlPoint: usize = 0x1C4; // int32_t
}

pub mod C_OP_SetCPOrientationToGroundNormal {
    pub const m_flInterpRate: usize = 0x1C0; // float
    pub const m_flMaxTraceLength: usize = 0x1C4; // float
    pub const m_flTolerance: usize = 0x1C8; // float
    pub const m_flTraceOffset: usize = 0x1CC; // float
    pub const m_CollisionGroupName: usize = 0x1D0; // char[128]
    pub const m_nTraceSet: usize = 0x250; // ParticleTraceSet_t
    pub const m_nInputCP: usize = 0x254; // int32_t
    pub const m_nOutputCP: usize = 0x258; // int32_t
    pub const m_bIncludeWater: usize = 0x268; // bool
}

pub mod C_OP_SetCPOrientationToPointAtCP {
    pub const m_nInputCP: usize = 0x1D0; // int32_t
    pub const m_nOutputCP: usize = 0x1D4; // int32_t
    pub const m_flInterpolation: usize = 0x1D8; // CParticleCollectionFloatInput
    pub const m_b2DOrientation: usize = 0x330; // bool
    pub const m_bAvoidSingularity: usize = 0x331; // bool
    pub const m_bPointAway: usize = 0x332; // bool
}

pub mod C_OP_SetCPtoVector {
    pub const m_nCPInput: usize = 0x1C0; // int32_t
    pub const m_nFieldOutput: usize = 0x1C4; // ParticleAttributeIndex_t
}

pub mod C_OP_SetChildControlPoints {
    pub const m_nChildGroupID: usize = 0x1C0; // int32_t
    pub const m_nFirstControlPoint: usize = 0x1C4; // int32_t
    pub const m_nNumControlPoints: usize = 0x1C8; // int32_t
    pub const m_nFirstSourcePoint: usize = 0x1D0; // CParticleCollectionFloatInput
    pub const m_bReverse: usize = 0x328; // bool
    pub const m_bSetOrientation: usize = 0x329; // bool
}

pub mod C_OP_SetControlPointFieldFromVectorExpression {
    pub const m_nExpression: usize = 0x1D0; // VectorFloatExpressionType_t
    pub const m_vecInput1: usize = 0x1D8; // CParticleCollectionVecInput
    pub const m_vecInput2: usize = 0x830; // CParticleCollectionVecInput
    pub const m_flOutputRemap: usize = 0xE88; // CParticleRemapFloatInput
    pub const m_nOutputCP: usize = 0xFE0; // int32_t
    pub const m_nOutVectorField: usize = 0xFE4; // int32_t
}

pub mod C_OP_SetControlPointFieldToScalarExpression {
    pub const m_nExpression: usize = 0x1D0; // ScalarExpressionType_t
    pub const m_flInput1: usize = 0x1D8; // CParticleCollectionFloatInput
    pub const m_flInput2: usize = 0x330; // CParticleCollectionFloatInput
    pub const m_flOutputRemap: usize = 0x488; // CParticleRemapFloatInput
    pub const m_nOutputCP: usize = 0x5E0; // int32_t
    pub const m_nOutVectorField: usize = 0x5E4; // int32_t
}

pub mod C_OP_SetControlPointFieldToWater {
    pub const m_nSourceCP: usize = 0x1D0; // int32_t
    pub const m_nDestCP: usize = 0x1D4; // int32_t
    pub const m_nCPField: usize = 0x1D8; // int32_t
}

pub mod C_OP_SetControlPointFromObjectScale {
    pub const m_nCPInput: usize = 0x1D0; // int32_t
    pub const m_nCPOutput: usize = 0x1D4; // int32_t
}

pub mod C_OP_SetControlPointOrientation {
    pub const m_bUseWorldLocation: usize = 0x1D0; // bool
    pub const m_bRandomize: usize = 0x1D2; // bool
    pub const m_bSetOnce: usize = 0x1D3; // bool
    pub const m_nCP: usize = 0x1D4; // int32_t
    pub const m_nHeadLocation: usize = 0x1D8; // int32_t
    pub const m_vecRotation: usize = 0x1DC; // QAngle
    pub const m_vecRotationB: usize = 0x1E8; // QAngle
    pub const m_flInterpolation: usize = 0x1F8; // CParticleCollectionFloatInput
}

pub mod C_OP_SetControlPointOrientationToCPVelocity {
    pub const m_nCPInput: usize = 0x1D0; // int32_t
    pub const m_nCPOutput: usize = 0x1D4; // int32_t
}

pub mod C_OP_SetControlPointPositionToRandomActiveCP {
    pub const m_nCP1: usize = 0x1D0; // int32_t
    pub const m_nHeadLocationMin: usize = 0x1D4; // int32_t
    pub const m_nHeadLocationMax: usize = 0x1D8; // int32_t
    pub const m_flResetRate: usize = 0x1E0; // CParticleCollectionFloatInput
}

pub mod C_OP_SetControlPointPositionToTimeOfDayValue {
    pub const m_nControlPointNumber: usize = 0x1D0; // int32_t
    pub const m_pszTimeOfDayParameter: usize = 0x1D4; // char[128]
    pub const m_vecDefaultValue: usize = 0x254; // Vector
}

pub mod C_OP_SetControlPointPositions {
    pub const m_bUseWorldLocation: usize = 0x1D0; // bool
    pub const m_bOrient: usize = 0x1D1; // bool
    pub const m_bSetOnce: usize = 0x1D2; // bool
    pub const m_nCP1: usize = 0x1D4; // int32_t
    pub const m_nCP2: usize = 0x1D8; // int32_t
    pub const m_nCP3: usize = 0x1DC; // int32_t
    pub const m_nCP4: usize = 0x1E0; // int32_t
    pub const m_vecCP1Pos: usize = 0x1E4; // Vector
    pub const m_vecCP2Pos: usize = 0x1F0; // Vector
    pub const m_vecCP3Pos: usize = 0x1FC; // Vector
    pub const m_vecCP4Pos: usize = 0x208; // Vector
    pub const m_nHeadLocation: usize = 0x214; // int32_t
}

pub mod C_OP_SetControlPointRotation {
    pub const m_vecRotAxis: usize = 0x1D0; // CParticleCollectionVecInput
    pub const m_flRotRate: usize = 0x828; // CParticleCollectionFloatInput
    pub const m_nCP: usize = 0x980; // int32_t
    pub const m_nLocalCP: usize = 0x984; // int32_t
}

pub mod C_OP_SetControlPointToCPVelocity {
    pub const m_nCPInput: usize = 0x1D0; // int32_t
    pub const m_nCPOutputVel: usize = 0x1D4; // int32_t
    pub const m_bNormalize: usize = 0x1D8; // bool
    pub const m_nCPOutputMag: usize = 0x1DC; // int32_t
    pub const m_nCPField: usize = 0x1E0; // int32_t
    pub const m_vecComparisonVelocity: usize = 0x1E8; // CParticleCollectionVecInput
}

pub mod C_OP_SetControlPointToCenter {
    pub const m_nCP1: usize = 0x1D0; // int32_t
    pub const m_vecCP1Pos: usize = 0x1D4; // Vector
    pub const m_nSetParent: usize = 0x1E0; // ParticleParentSetMode_t
}

pub mod C_OP_SetControlPointToHMD {
    pub const m_nCP1: usize = 0x1D0; // int32_t
    pub const m_vecCP1Pos: usize = 0x1D4; // Vector
    pub const m_bOrientToHMD: usize = 0x1E0; // bool
}

pub mod C_OP_SetControlPointToHand {
    pub const m_nCP1: usize = 0x1D0; // int32_t
    pub const m_nHand: usize = 0x1D4; // int32_t
    pub const m_vecCP1Pos: usize = 0x1D8; // Vector
    pub const m_bOrientToHand: usize = 0x1E4; // bool
}

pub mod C_OP_SetControlPointToImpactPoint {
    pub const m_nCPOut: usize = 0x1D0; // int32_t
    pub const m_nCPIn: usize = 0x1D4; // int32_t
    pub const m_flUpdateRate: usize = 0x1D8; // float
    pub const m_flTraceLength: usize = 0x1E0; // CParticleCollectionFloatInput
    pub const m_flStartOffset: usize = 0x338; // float
    pub const m_flOffset: usize = 0x33C; // float
    pub const m_vecTraceDir: usize = 0x340; // Vector
    pub const m_CollisionGroupName: usize = 0x34C; // char[128]
    pub const m_nTraceSet: usize = 0x3CC; // ParticleTraceSet_t
    pub const m_bSetToEndpoint: usize = 0x3D0; // bool
    pub const m_bTraceToClosestSurface: usize = 0x3D1; // bool
    pub const m_bIncludeWater: usize = 0x3D2; // bool
}

pub mod C_OP_SetControlPointToPlayer {
    pub const m_nCP1: usize = 0x1D0; // int32_t
    pub const m_vecCP1Pos: usize = 0x1D4; // Vector
    pub const m_bOrientToEyes: usize = 0x1E0; // bool
}

pub mod C_OP_SetControlPointToVectorExpression {
    pub const m_nExpression: usize = 0x1D0; // VectorExpressionType_t
    pub const m_nOutputCP: usize = 0x1D4; // int32_t
    pub const m_vInput1: usize = 0x1D8; // CParticleCollectionVecInput
    pub const m_vInput2: usize = 0x830; // CParticleCollectionVecInput
    pub const m_bNormalizedOutput: usize = 0xE88; // bool
}

pub mod C_OP_SetControlPointToWaterSurface {
    pub const m_nSourceCP: usize = 0x1D0; // int32_t
    pub const m_nDestCP: usize = 0x1D4; // int32_t
    pub const m_nFlowCP: usize = 0x1D8; // int32_t
    pub const m_nActiveCP: usize = 0x1DC; // int32_t
    pub const m_nActiveCPField: usize = 0x1E0; // int32_t
    pub const m_flRetestRate: usize = 0x1E8; // CParticleCollectionFloatInput
    pub const m_bAdaptiveThreshold: usize = 0x340; // bool
}

pub mod C_OP_SetControlPointsToModelParticles {
    pub const m_HitboxSetName: usize = 0x1C0; // char[128]
    pub const m_AttachmentName: usize = 0x240; // char[128]
    pub const m_nFirstControlPoint: usize = 0x2C0; // int32_t
    pub const m_nNumControlPoints: usize = 0x2C4; // int32_t
    pub const m_nFirstSourcePoint: usize = 0x2C8; // int32_t
    pub const m_bSkin: usize = 0x2CC; // bool
    pub const m_bAttachment: usize = 0x2CD; // bool
}

pub mod C_OP_SetControlPointsToParticle {
    pub const m_nChildGroupID: usize = 0x1C0; // int32_t
    pub const m_nFirstControlPoint: usize = 0x1C4; // int32_t
    pub const m_nNumControlPoints: usize = 0x1C8; // int32_t
    pub const m_nFirstSourcePoint: usize = 0x1CC; // int32_t
    pub const m_bSetOrientation: usize = 0x1D0; // bool
    pub const m_nOrientationMode: usize = 0x1D4; // ParticleOrientationSetMode_t
    pub const m_nSetParent: usize = 0x1D8; // ParticleParentSetMode_t
}

pub mod C_OP_SetFloat {
    pub const m_InputValue: usize = 0x1C0; // CPerParticleFloatInput
    pub const m_nOutputField: usize = 0x318; // ParticleAttributeIndex_t
    pub const m_nSetMethod: usize = 0x31C; // ParticleSetMethod_t
    pub const m_Lerp: usize = 0x320; // CPerParticleFloatInput
    pub const m_bUseNewCode: usize = 0x478; // bool
}

pub mod C_OP_SetFloatAttributeToVectorExpression {
    pub const m_nExpression: usize = 0x1C0; // VectorFloatExpressionType_t
    pub const m_vInput1: usize = 0x1C8; // CPerParticleVecInput
    pub const m_vInput2: usize = 0x820; // CPerParticleVecInput
    pub const m_flOutputRemap: usize = 0xE78; // CParticleRemapFloatInput
    pub const m_nOutputField: usize = 0xFD0; // ParticleAttributeIndex_t
    pub const m_nSetMethod: usize = 0xFD4; // ParticleSetMethod_t
}

pub mod C_OP_SetFloatCollection {
    pub const m_InputValue: usize = 0x1C0; // CParticleCollectionFloatInput
    pub const m_nOutputField: usize = 0x318; // ParticleAttributeIndex_t
    pub const m_nSetMethod: usize = 0x31C; // ParticleSetMethod_t
    pub const m_Lerp: usize = 0x320; // CParticleCollectionFloatInput
}

pub mod C_OP_SetFromCPSnapshot {
    pub const m_nControlPointNumber: usize = 0x1C0; // int32_t
    pub const m_nAttributeToRead: usize = 0x1C4; // ParticleAttributeIndex_t
    pub const m_nAttributeToWrite: usize = 0x1C8; // ParticleAttributeIndex_t
    pub const m_nLocalSpaceCP: usize = 0x1CC; // int32_t
    pub const m_bRandom: usize = 0x1D0; // bool
    pub const m_bReverse: usize = 0x1D1; // bool
    pub const m_nRandomSeed: usize = 0x1D4; // int32_t
    pub const m_nSnapShotStartPoint: usize = 0x1D8; // CParticleCollectionFloatInput
    pub const m_nSnapShotIncrement: usize = 0x330; // CParticleCollectionFloatInput
    pub const m_flInterpolation: usize = 0x488; // CPerParticleFloatInput
    pub const m_bSubSample: usize = 0x5E0; // bool
}

pub mod C_OP_SetGravityToCP {
    pub const m_nCPInput: usize = 0x1D0; // int32_t
    pub const m_nCPOutput: usize = 0x1D4; // int32_t
    pub const m_flScale: usize = 0x1D8; // CParticleCollectionFloatInput
    pub const m_bSetOrientation: usize = 0x330; // bool
    pub const m_bSetZDown: usize = 0x331; // bool
}

pub mod C_OP_SetParentControlPointsToChildCP {
    pub const m_nChildGroupID: usize = 0x1D0; // int32_t
    pub const m_nChildControlPoint: usize = 0x1D4; // int32_t
    pub const m_nNumControlPoints: usize = 0x1D8; // int32_t
    pub const m_nFirstSourcePoint: usize = 0x1DC; // int32_t
    pub const m_bSetOrientation: usize = 0x1E0; // bool
}

pub mod C_OP_SetPerChildControlPoint {
    pub const m_nChildGroupID: usize = 0x1C0; // int32_t
    pub const m_nFirstControlPoint: usize = 0x1C4; // int32_t
    pub const m_nNumControlPoints: usize = 0x1C8; // int32_t
    pub const m_nParticleIncrement: usize = 0x1D0; // CParticleCollectionFloatInput
    pub const m_nFirstSourcePoint: usize = 0x328; // CParticleCollectionFloatInput
    pub const m_bSetOrientation: usize = 0x480; // bool
    pub const m_nOrientationField: usize = 0x484; // ParticleAttributeIndex_t
    pub const m_bNumBasedOnParticleCount: usize = 0x488; // bool
}

pub mod C_OP_SetPerChildControlPointFromAttribute {
    pub const m_nChildGroupID: usize = 0x1C0; // int32_t
    pub const m_nFirstControlPoint: usize = 0x1C4; // int32_t
    pub const m_nNumControlPoints: usize = 0x1C8; // int32_t
    pub const m_nParticleIncrement: usize = 0x1CC; // int32_t
    pub const m_nFirstSourcePoint: usize = 0x1D0; // int32_t
    pub const m_bNumBasedOnParticleCount: usize = 0x1D4; // bool
    pub const m_nAttributeToRead: usize = 0x1D8; // ParticleAttributeIndex_t
    pub const m_nCPField: usize = 0x1DC; // int32_t
}

pub mod C_OP_SetRandomControlPointPosition {
    pub const m_bUseWorldLocation: usize = 0x1D0; // bool
    pub const m_bOrient: usize = 0x1D1; // bool
    pub const m_nCP1: usize = 0x1D4; // int32_t
    pub const m_nHeadLocation: usize = 0x1D8; // int32_t
    pub const m_flReRandomRate: usize = 0x1E0; // CParticleCollectionFloatInput
    pub const m_vecCPMinPos: usize = 0x338; // Vector
    pub const m_vecCPMaxPos: usize = 0x344; // Vector
    pub const m_flInterpolation: usize = 0x350; // CParticleCollectionFloatInput
}

pub mod C_OP_SetSimulationRate {
    pub const m_flSimulationScale: usize = 0x1D0; // CParticleCollectionFloatInput
}

pub mod C_OP_SetSingleControlPointPosition {
    pub const m_bSetOnce: usize = 0x1D0; // bool
    pub const m_nCP1: usize = 0x1D4; // int32_t
    pub const m_vecCP1Pos: usize = 0x1D8; // CParticleCollectionVecInput
    pub const m_transformInput: usize = 0x830; // CParticleTransformInput
}

pub mod C_OP_SetToCP {
    pub const m_nControlPointNumber: usize = 0x1C0; // int32_t
    pub const m_vecOffset: usize = 0x1C4; // Vector
    pub const m_bOffsetLocal: usize = 0x1D0; // bool
}

pub mod C_OP_SetVariable {
    pub const m_variableReference: usize = 0x1D0; // CParticleVariableRef
    pub const m_transformInput: usize = 0x210; // CParticleTransformInput
    pub const m_positionOffset: usize = 0x278; // Vector
    pub const m_rotationOffset: usize = 0x284; // QAngle
    pub const m_vecInput: usize = 0x290; // CParticleCollectionVecInput
    pub const m_floatInput: usize = 0x8E8; // CParticleCollectionFloatInput
}

pub mod C_OP_SetVec {
    pub const m_InputValue: usize = 0x1C0; // CPerParticleVecInput
    pub const m_nOutputField: usize = 0x818; // ParticleAttributeIndex_t
    pub const m_nSetMethod: usize = 0x81C; // ParticleSetMethod_t
    pub const m_Lerp: usize = 0x820; // CPerParticleFloatInput
    pub const m_bNormalizedOutput: usize = 0x978; // bool
}

pub mod C_OP_SetVectorAttributeToVectorExpression {
    pub const m_nExpression: usize = 0x1C0; // VectorExpressionType_t
    pub const m_vInput1: usize = 0x1C8; // CPerParticleVecInput
    pub const m_vInput2: usize = 0x820; // CPerParticleVecInput
    pub const m_nOutputField: usize = 0xE78; // ParticleAttributeIndex_t
    pub const m_nSetMethod: usize = 0xE7C; // ParticleSetMethod_t
    pub const m_bNormalizedOutput: usize = 0xE80; // bool
}

pub mod C_OP_ShapeMatchingConstraint {
    pub const m_flShapeRestorationTime: usize = 0x1C0; // float
}

pub mod C_OP_SnapshotRigidSkinToBones {
    pub const m_bTransformNormals: usize = 0x1C0; // bool
    pub const m_bTransformRadii: usize = 0x1C1; // bool
    pub const m_nControlPointNumber: usize = 0x1C4; // int32_t
}

pub mod C_OP_SnapshotSkinToBones {
    pub const m_bTransformNormals: usize = 0x1C0; // bool
    pub const m_bTransformRadii: usize = 0x1C1; // bool
    pub const m_nControlPointNumber: usize = 0x1C4; // int32_t
    pub const m_flLifeTimeFadeStart: usize = 0x1C8; // float
    pub const m_flLifeTimeFadeEnd: usize = 0x1CC; // float
    pub const m_flJumpThreshold: usize = 0x1D0; // float
    pub const m_flPrevPosScale: usize = 0x1D4; // float
}

pub mod C_OP_SpringToVectorConstraint {
    pub const m_flRestLength: usize = 0x1C0; // CPerParticleFloatInput
    pub const m_flMinDistance: usize = 0x318; // CPerParticleFloatInput
    pub const m_flMaxDistance: usize = 0x470; // CPerParticleFloatInput
    pub const m_flRestingLength: usize = 0x5C8; // CPerParticleFloatInput
    pub const m_vecAnchorVector: usize = 0x720; // CPerParticleVecInput
}

pub mod C_OP_StopAfterCPDuration {
    pub const m_flDuration: usize = 0x1D0; // CParticleCollectionFloatInput
    pub const m_bDestroyImmediately: usize = 0x328; // bool
    pub const m_bPlayEndCap: usize = 0x329; // bool
}

pub mod C_OP_TeleportBeam {
    pub const m_nCPPosition: usize = 0x1C0; // int32_t
    pub const m_nCPVelocity: usize = 0x1C4; // int32_t
    pub const m_nCPMisc: usize = 0x1C8; // int32_t
    pub const m_nCPColor: usize = 0x1CC; // int32_t
    pub const m_nCPInvalidColor: usize = 0x1D0; // int32_t
    pub const m_nCPExtraArcData: usize = 0x1D4; // int32_t
    pub const m_vGravity: usize = 0x1D8; // Vector
    pub const m_flArcMaxDuration: usize = 0x1E4; // float
    pub const m_flSegmentBreak: usize = 0x1E8; // float
    pub const m_flArcSpeed: usize = 0x1EC; // float
    pub const m_flAlpha: usize = 0x1F0; // float
}

pub mod C_OP_TimeVaryingForce {
    pub const m_flStartLerpTime: usize = 0x1D0; // float
    pub const m_StartingForce: usize = 0x1D4; // Vector
    pub const m_flEndLerpTime: usize = 0x1E0; // float
    pub const m_EndingForce: usize = 0x1E4; // Vector
}

pub mod C_OP_TurbulenceForce {
    pub const m_flNoiseCoordScale0: usize = 0x1D0; // float
    pub const m_flNoiseCoordScale1: usize = 0x1D4; // float
    pub const m_flNoiseCoordScale2: usize = 0x1D8; // float
    pub const m_flNoiseCoordScale3: usize = 0x1DC; // float
    pub const m_vecNoiseAmount0: usize = 0x1E0; // Vector
    pub const m_vecNoiseAmount1: usize = 0x1EC; // Vector
    pub const m_vecNoiseAmount2: usize = 0x1F8; // Vector
    pub const m_vecNoiseAmount3: usize = 0x204; // Vector
}

pub mod C_OP_TwistAroundAxis {
    pub const m_fForceAmount: usize = 0x1D0; // float
    pub const m_TwistAxis: usize = 0x1D4; // Vector
    pub const m_bLocalSpace: usize = 0x1E0; // bool
    pub const m_nControlPointNumber: usize = 0x1E4; // int32_t
}

pub mod C_OP_UpdateLightSource {
    pub const m_vColorTint: usize = 0x1C0; // Color
    pub const m_flBrightnessScale: usize = 0x1C4; // float
    pub const m_flRadiusScale: usize = 0x1C8; // float
    pub const m_flMinimumLightingRadius: usize = 0x1CC; // float
    pub const m_flMaximumLightingRadius: usize = 0x1D0; // float
    pub const m_flPositionDampingConstant: usize = 0x1D4; // float
}

pub mod C_OP_VectorFieldSnapshot {
    pub const m_nControlPointNumber: usize = 0x1C0; // int32_t
    pub const m_nAttributeToWrite: usize = 0x1C4; // ParticleAttributeIndex_t
    pub const m_nLocalSpaceCP: usize = 0x1C8; // int32_t
    pub const m_flInterpolation: usize = 0x1D0; // CPerParticleFloatInput
    pub const m_vecScale: usize = 0x328; // CPerParticleVecInput
    pub const m_flBoundaryDampening: usize = 0x980; // float
    pub const m_bSetVelocity: usize = 0x984; // bool
    pub const m_bLockToSurface: usize = 0x985; // bool
    pub const m_flGridSpacing: usize = 0x988; // float
}

pub mod C_OP_VectorNoise {
    pub const m_nFieldOutput: usize = 0x1C0; // ParticleAttributeIndex_t
    pub const m_vecOutputMin: usize = 0x1C4; // Vector
    pub const m_vecOutputMax: usize = 0x1D0; // Vector
    pub const m_fl4NoiseScale: usize = 0x1DC; // float
    pub const m_bAdditive: usize = 0x1E0; // bool
    pub const m_bOffset: usize = 0x1E1; // bool
    pub const m_flNoiseAnimationTimeScale: usize = 0x1E4; // float
}

pub mod C_OP_VelocityDecay {
    pub const m_flMinVelocity: usize = 0x1C0; // float
}

pub mod C_OP_VelocityMatchingForce {
    pub const m_flDirScale: usize = 0x1C0; // float
    pub const m_flSpdScale: usize = 0x1C4; // float
    pub const m_nCPBroadcast: usize = 0x1C8; // int32_t
}

pub mod C_OP_WindForce {
    pub const m_vForce: usize = 0x1D0; // Vector
}

pub mod C_OP_WorldTraceConstraint {
    pub const m_nCP: usize = 0x1C0; // int32_t
    pub const m_vecCpOffset: usize = 0x1C4; // Vector
    pub const m_nCollisionMode: usize = 0x1D0; // ParticleCollisionMode_t
    pub const m_nCollisionModeMin: usize = 0x1D4; // ParticleCollisionMode_t
    pub const m_nTraceSet: usize = 0x1D8; // ParticleTraceSet_t
    pub const m_CollisionGroupName: usize = 0x1DC; // char[128]
    pub const m_bWorldOnly: usize = 0x25C; // bool
    pub const m_bBrushOnly: usize = 0x25D; // bool
    pub const m_bIncludeWater: usize = 0x25E; // bool
    pub const m_nIgnoreCP: usize = 0x260; // int32_t
    pub const m_flCpMovementTolerance: usize = 0x264; // float
    pub const m_flRetestRate: usize = 0x268; // float
    pub const m_flTraceTolerance: usize = 0x26C; // float
    pub const m_flCollisionConfirmationSpeed: usize = 0x270; // float
    pub const m_nMaxTracesPerFrame: usize = 0x274; // float
    pub const m_flRadiusScale: usize = 0x278; // CPerParticleFloatInput
    pub const m_flBounceAmount: usize = 0x3D0; // CPerParticleFloatInput
    pub const m_flSlideAmount: usize = 0x528; // CPerParticleFloatInput
    pub const m_flRandomDirScale: usize = 0x680; // CPerParticleFloatInput
    pub const m_bDecayBounce: usize = 0x7D8; // bool
    pub const m_bKillonContact: usize = 0x7D9; // bool
    pub const m_flMinSpeed: usize = 0x7DC; // float
    pub const m_bSetNormal: usize = 0x7E0; // bool
    pub const m_nStickOnCollisionField: usize = 0x7E4; // ParticleAttributeIndex_t
    pub const m_flStopSpeed: usize = 0x7E8; // CPerParticleFloatInput
    pub const m_nEntityStickDataField: usize = 0x940; // ParticleAttributeIndex_t
    pub const m_nEntityStickNormalField: usize = 0x944; // ParticleAttributeIndex_t
}

pub mod CollisionGroupContext_t {
    pub const m_nCollisionGroupNumber: usize = 0x0; // int32_t
}

pub mod ControlPointReference_t {
    pub const m_controlPointNameString: usize = 0x0; // int32_t
    pub const m_vOffsetFromControlPoint: usize = 0x4; // Vector
    pub const m_bOffsetInLocalSpace: usize = 0x10; // bool
}

pub mod FloatInputMaterialVariable_t {
    pub const m_strVariable: usize = 0x0; // CUtlString
    pub const m_flInput: usize = 0x8; // CParticleCollectionFloatInput
}

pub mod MaterialVariable_t {
    pub const m_strVariable: usize = 0x0; // CUtlString
    pub const m_nVariableField: usize = 0x8; // ParticleAttributeIndex_t
    pub const m_flScale: usize = 0xC; // float
}

pub mod ModelReference_t {
    pub const m_model: usize = 0x0; // CStrongHandle<InfoForResourceTypeCModel>
    pub const m_flRelativeProbabilityOfSpawn: usize = 0x8; // float
}

pub mod PARTICLE_EHANDLE__ {
    pub const unused: usize = 0x0; // int32_t
}

pub mod PARTICLE_WORLD_HANDLE__ {
    pub const unused: usize = 0x0; // int32_t
}

pub mod ParticleAttributeIndex_t {
    pub const m_Value: usize = 0x0; // int32_t
}

pub mod ParticleChildrenInfo_t {
    pub const m_ChildRef: usize = 0x0; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    pub const m_flDelay: usize = 0x8; // float
    pub const m_bEndCap: usize = 0xC; // bool
    pub const m_bDisableChild: usize = 0xD; // bool
    pub const m_nDetailLevel: usize = 0x10; // ParticleDetailLevel_t
}

pub mod ParticleControlPointConfiguration_t {
    pub const m_name: usize = 0x0; // CUtlString
    pub const m_drivers: usize = 0x8; // CUtlVector<ParticleControlPointDriver_t>
    pub const m_previewState: usize = 0x20; // ParticlePreviewState_t
}

pub mod ParticleControlPointDriver_t {
    pub const m_iControlPoint: usize = 0x0; // int32_t
    pub const m_iAttachType: usize = 0x4; // ParticleAttachment_t
    pub const m_attachmentName: usize = 0x8; // CUtlString
    pub const m_vecOffset: usize = 0x10; // Vector
    pub const m_angOffset: usize = 0x1C; // QAngle
    pub const m_entityName: usize = 0x28; // CUtlString
}

pub mod ParticleNamedValueConfiguration_t {
    pub const m_ConfigName: usize = 0x0; // CUtlString
    pub const m_ConfigValue: usize = 0x8; // KeyValues3
    pub const m_iAttachType: usize = 0x18; // ParticleAttachment_t
    pub const m_BoundEntityPath: usize = 0x20; // CUtlString
    pub const m_strEntityScope: usize = 0x28; // CUtlString
    pub const m_strAttachmentName: usize = 0x30; // CUtlString
}

pub mod ParticleNamedValueSource_t {
    pub const m_Name: usize = 0x0; // CUtlString
    pub const m_IsPublic: usize = 0x8; // bool
    pub const m_ValueType: usize = 0xC; // PulseValueType_t
    pub const m_DefaultConfig: usize = 0x10; // ParticleNamedValueConfiguration_t
    pub const m_NamedConfigs: usize = 0x48; // CUtlVector<ParticleNamedValueConfiguration_t>
}

pub mod ParticlePreviewBodyGroup_t {
    pub const m_bodyGroupName: usize = 0x0; // CUtlString
    pub const m_nValue: usize = 0x8; // int32_t
}

pub mod ParticlePreviewState_t {
    pub const m_previewModel: usize = 0x0; // CUtlString
    pub const m_nModSpecificData: usize = 0x8; // uint32_t
    pub const m_groundType: usize = 0xC; // PetGroundType_t
    pub const m_sequenceName: usize = 0x10; // CUtlString
    pub const m_nFireParticleOnSequenceFrame: usize = 0x18; // int32_t
    pub const m_hitboxSetName: usize = 0x20; // CUtlString
    pub const m_materialGroupName: usize = 0x28; // CUtlString
    pub const m_vecBodyGroups: usize = 0x30; // CUtlVector<ParticlePreviewBodyGroup_t>
    pub const m_flPlaybackSpeed: usize = 0x48; // float
    pub const m_flParticleSimulationRate: usize = 0x4C; // float
    pub const m_bShouldDrawHitboxes: usize = 0x50; // bool
    pub const m_bShouldDrawAttachments: usize = 0x51; // bool
    pub const m_bShouldDrawAttachmentNames: usize = 0x52; // bool
    pub const m_bShouldDrawControlPointAxes: usize = 0x53; // bool
    pub const m_bAnimationNonLooping: usize = 0x54; // bool
    pub const m_vecPreviewGravity: usize = 0x58; // Vector
}

pub mod PointDefinitionWithTimeValues_t {
    pub const m_flTimeDuration: usize = 0x14; // float
}

pub mod PointDefinition_t {
    pub const m_nControlPoint: usize = 0x0; // int32_t
    pub const m_bLocalCoords: usize = 0x4; // bool
    pub const m_vOffset: usize = 0x8; // Vector
}

pub mod SequenceWeightedList_t {
    pub const m_nSequence: usize = 0x0; // int32_t
    pub const m_flRelativeWeight: usize = 0x4; // float
}

pub mod TextureControls_t {
    pub const m_flFinalTextureScaleU: usize = 0x0; // CParticleCollectionRendererFloatInput
    pub const m_flFinalTextureScaleV: usize = 0x158; // CParticleCollectionRendererFloatInput
    pub const m_flFinalTextureOffsetU: usize = 0x2B0; // CParticleCollectionRendererFloatInput
    pub const m_flFinalTextureOffsetV: usize = 0x408; // CParticleCollectionRendererFloatInput
    pub const m_flFinalTextureUVRotation: usize = 0x560; // CParticleCollectionRendererFloatInput
    pub const m_flZoomScale: usize = 0x6B8; // CParticleCollectionRendererFloatInput
    pub const m_flDistortion: usize = 0x810; // CParticleCollectionRendererFloatInput
    pub const m_bRandomizeOffsets: usize = 0x968; // bool
    pub const m_bClampUVs: usize = 0x969; // bool
    pub const m_nPerParticleBlend: usize = 0x96C; // SpriteCardPerParticleScale_t
    pub const m_nPerParticleScale: usize = 0x970; // SpriteCardPerParticleScale_t
    pub const m_nPerParticleOffsetU: usize = 0x974; // SpriteCardPerParticleScale_t
    pub const m_nPerParticleOffsetV: usize = 0x978; // SpriteCardPerParticleScale_t
    pub const m_nPerParticleRotation: usize = 0x97C; // SpriteCardPerParticleScale_t
    pub const m_nPerParticleZoom: usize = 0x980; // SpriteCardPerParticleScale_t
    pub const m_nPerParticleDistortion: usize = 0x984; // SpriteCardPerParticleScale_t
}

pub mod TextureGroup_t {
    pub const m_bEnabled: usize = 0x0; // bool
    pub const m_bReplaceTextureWithGradient: usize = 0x1; // bool
    pub const m_hTexture: usize = 0x8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_Gradient: usize = 0x10; // CColorGradient
    pub const m_nTextureType: usize = 0x28; // SpriteCardTextureType_t
    pub const m_nTextureChannels: usize = 0x2C; // SpriteCardTextureChannel_t
    pub const m_nTextureBlendMode: usize = 0x30; // ParticleTextureLayerBlendType_t
    pub const m_flTextureBlend: usize = 0x38; // CParticleCollectionRendererFloatInput
    pub const m_TextureControls: usize = 0x190; // TextureControls_t
}

pub mod VecInputMaterialVariable_t {
    pub const m_strVariable: usize = 0x0; // CUtlString
    pub const m_vecInput: usize = 0x8; // CParticleCollectionVecInput
}
```

`SDK/pulse_system.dll.cs`:

```cs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.622659600 UTC
 */

public static class CPulseCell_Base {
    public const nint m_nEditorNodeID = 0x8; // PulseDocNodeID_t
}

public static class CPulseCell_Inflow_BaseEntrypoint {
    public const nint m_EntryChunk = 0x48; // PulseRuntimeChunkIndex_t
    public const nint m_RegisterMap = 0x50; // PulseRegisterMap_t
}

public static class CPulseCell_Inflow_EntOutputHandler {
    public const nint m_SourceEntity = 0x70; // CUtlSymbolLarge
    public const nint m_SourceOutput = 0x78; // CUtlSymbolLarge
    public const nint m_TargetInput = 0x80; // CUtlSymbolLarge
    public const nint m_ExpectedParamType = 0x88; // CPulseValueFullType
}

public static class CPulseCell_Inflow_EventHandler {
    public const nint m_EventName = 0x70; // CUtlSymbolLarge
}

public static class CPulseCell_Inflow_GraphHook {
    public const nint m_HookName = 0x70; // CUtlSymbolLarge
}

public static class CPulseCell_Inflow_Method {
    public const nint m_MethodName = 0x70; // CUtlSymbolLarge
    public const nint m_Description = 0x78; // CUtlString
    public const nint m_bIsPublic = 0x80; // bool
    public const nint m_ReturnType = 0x88; // CPulseValueFullType
    public const nint m_Args = 0x98; // CUtlVector<CPulseRuntimeMethodArg>
}

public static class CPulseCell_Inflow_Wait {
    public const nint m_WakeResume = 0x48; // CPulse_ResumePoint
}

public static class CPulseCell_Inflow_Yield {
    public const nint m_UnyieldResume = 0x48; // CPulse_ResumePoint
}

public static class CPulseCell_Outflow_CycleOrdered {
    public const nint m_Outputs = 0x48; // CUtlVector<CPulse_OutflowConnection>
}

public static class CPulseCell_Outflow_CycleOrdered_InstanceState_t {
    public const nint m_nNextIndex = 0x0; // int32_t
}

public static class CPulseCell_Outflow_CycleRandom {
    public const nint m_Outputs = 0x48; // CUtlVector<CPulse_OutflowConnection>
}

public static class CPulseCell_Outflow_CycleShuffled {
    public const nint m_Outputs = 0x48; // CUtlVector<CPulse_OutflowConnection>
}

public static class CPulseCell_Outflow_CycleShuffled_InstanceState_t {
    public const nint m_Shuffle = 0x0; // CUtlVectorFixedGrowable<uint8_t>
    public const nint m_nNextShuffle = 0x20; // int32_t
}

public static class CPulseCell_Outflow_IntSwitch {
    public const nint m_DefaultCaseOutflow = 0x48; // CPulse_OutflowConnection
    public const nint m_CaseOutflows = 0x58; // CUtlVector<CPulse_OutflowConnection>
}

public static class CPulseCell_Outflow_SimultaneousParallel {
    public const nint m_Outputs = 0x48; // CUtlVector<CPulse_OutflowConnection>
}

public static class CPulseCell_Outflow_StringSwitch {
    public const nint m_DefaultCaseOutflow = 0x48; // CPulse_OutflowConnection
    public const nint m_CaseOutflows = 0x58; // CUtlVector<CPulse_OutflowConnection>
}

public static class CPulseCell_Outflow_TestExplicitYesNo {
    public const nint m_Yes = 0x48; // CPulse_OutflowConnection
    public const nint m_No = 0x58; // CPulse_OutflowConnection
}

public static class CPulseCell_Outflow_TestRandomYesNo {
    public const nint m_Yes = 0x48; // CPulse_OutflowConnection
    public const nint m_No = 0x58; // CPulse_OutflowConnection
}

public static class CPulseCell_Step_CallExternalMethod {
    public const nint m_MethodName = 0x48; // CUtlSymbolLarge
    public const nint m_ExpectedArgs = 0x50; // CUtlVector<CPulseRuntimeMethodArg>
}

public static class CPulseCell_Step_PublicOutput {
    public const nint m_OutputIndex = 0x48; // PulseRuntimeOutputIndex_t
}

public static class CPulseCell_Step_TestDomainEntFire {
    public const nint m_Input = 0x48; // CUtlString
}

public static class CPulseGraphDef {
    public const nint m_DomainIdentifier = 0x8; // CUtlSymbolLarge
    public const nint m_ParentMapName = 0x10; // CUtlSymbolLarge
    public const nint m_Chunks = 0x18; // CUtlVector<CPulse_Chunk*>
    public const nint m_Cells = 0x30; // CUtlVector<CPulseCell_Base*>
    public const nint m_Vars = 0x48; // CUtlVector<CPulse_Variable>
    public const nint m_PublicOutputs = 0x60; // CUtlVector<CPulse_PublicOutput>
    public const nint m_InvokeBindings = 0x78; // CUtlVector<CPulse_InvokeBinding*>
    public const nint m_CallInfos = 0x90; // CUtlVector<CPulse_CallInfo*>
    public const nint m_OutputConnections = 0xA8; // CUtlVector<CPulse_OutputConnection*>
}

public static class CPulseGraphInstance_TestDomain {
    public const nint m_bIsRunningUnitTests = 0xD0; // bool
    public const nint m_bExplicitTimeStepping = 0xD1; // bool
    public const nint m_bExpectingToDestroyWithYieldedCursors = 0xD2; // bool
    public const nint m_nNextValidateIndex = 0xD4; // int32_t
    public const nint m_Tracepoints = 0xD8; // CUtlVector<CUtlString>
    public const nint m_bTestYesOrNoPath = 0xF0; // bool
}

public static class CPulseGraphInstance_TestDomain_Derived {
    public const nint m_nInstanceValueX = 0xF8; // int32_t
}

public static class CPulseRuntimeMethodArg {
    public const nint m_Name = 0x0; // CKV3MemberNameWithStorage
    public const nint m_Description = 0x38; // CUtlString
    public const nint m_Type = 0x40; // CPulseValueFullType
}

public static class CPulseTurtleGraphicsCursor {
    public const nint m_Color = 0x188; // Color
    public const nint m_vPos = 0x18C; // Vector2D
    public const nint m_flHeadingDeg = 0x194; // float
    public const nint m_bPenUp = 0x198; // bool
}

public static class CPulse_CallInfo {
    public const nint m_PortName = 0x0; // CUtlSymbolLarge
    public const nint m_nEditorNodeID = 0x8; // PulseDocNodeID_t
    public const nint m_RegisterMap = 0x10; // PulseRegisterMap_t
    public const nint m_CallMethodID = 0x30; // PulseDocNodeID_t
    public const nint m_nSrcChunk = 0x34; // PulseRuntimeChunkIndex_t
    public const nint m_nSrcInstruction = 0x38; // int32_t
}

public static class CPulse_Chunk {
    public const nint m_Instructions = 0x0; // CUtlLeanVector<PGDInstruction_t>
    public const nint m_Registers = 0x10; // CUtlLeanVector<CPulse_RegisterInfo>
    public const nint m_InstructionEditorIDs = 0x20; // CUtlLeanVector<PulseDocNodeID_t>
}

public static class CPulse_InvokeBinding {
    public const nint m_RegisterMap = 0x0; // PulseRegisterMap_t
    public const nint m_FuncName = 0x20; // CUtlSymbolLarge
    public const nint m_nCellIndex = 0x28; // PulseRuntimeCellIndex_t
    public const nint m_InstanceType = 0x30; // CPulseValueFullType
    public const nint m_nSrcChunk = 0x40; // PulseRuntimeChunkIndex_t
    public const nint m_nSrcInstruction = 0x44; // int32_t
}

public static class CPulse_OutflowConnection {
    public const nint m_SourceOutflowName = 0x0; // CUtlSymbolLarge
    public const nint m_nDestChunk = 0x8; // PulseRuntimeChunkIndex_t
    public const nint m_nInstruction = 0xC; // int32_t
}

public static class CPulse_OutputConnection {
    public const nint m_SourceOutput = 0x0; // CUtlSymbolLarge
    public const nint m_TargetEntity = 0x8; // CUtlSymbolLarge
    public const nint m_TargetInput = 0x10; // CUtlSymbolLarge
    public const nint m_Param = 0x18; // CUtlSymbolLarge
}

public static class CPulse_PublicOutput {
    public const nint m_Name = 0x0; // CUtlSymbolLarge
    public const nint m_Description = 0x8; // CUtlString
    public const nint m_ParamType = 0x10; // CPulseValueFullType
}

public static class CPulse_RegisterInfo {
    public const nint m_nReg = 0x0; // PulseRuntimeRegisterIndex_t
    public const nint m_Type = 0x8; // CPulseValueFullType
    public const nint m_OriginName = 0x18; // CKV3MemberNameWithStorage
    public const nint m_nWrittenByInstruction = 0x50; // int32_t
    public const nint m_nLastReadByInstruction = 0x54; // int32_t
}

public static class CPulse_Variable {
    public const nint m_Name = 0x0; // CUtlSymbolLarge
    public const nint m_Description = 0x8; // CUtlString
    public const nint m_Type = 0x10; // CPulseValueFullType
    public const nint m_DefaultValue = 0x20; // KeyValues3
    public const nint m_bIsPublic = 0x32; // bool
}

public static class CTestDomainDerived_Cursor {
    public const nint m_nCursorValueA = 0x188; // int32_t
    public const nint m_nCursorValueB = 0x18C; // int32_t
}

public static class FakeEntity_t {
    public const nint m_nHandle = 0x0; // PulseTestEHandle_t
    public const nint m_Name = 0x8; // CUtlString
    public const nint m_Class = 0x10; // CUtlString
    public const nint m_bDestroyed = 0x18; // bool
    public const nint m_pAssociatedGraphInstance = 0x20; // CPulseGraphInstance_TestDomain*
    public const nint m_bFuncWasCalled = 0x28; // bool
    public const nint m_fValue = 0x2C; // float
}

public static class PGDInstruction_t {
    public const nint m_nCode = 0x0; // PulseInstructionCode_t
    public const nint m_nVar = 0x4; // PulseRuntimeVarIndex_t
    public const nint m_nReg0 = 0x8; // PulseRuntimeRegisterIndex_t
    public const nint m_nReg1 = 0xA; // PulseRuntimeRegisterIndex_t
    public const nint m_nReg2 = 0xC; // PulseRuntimeRegisterIndex_t
    public const nint m_nInvokeBindingIndex = 0x10; // PulseRuntimeInvokeIndex_t
    public const nint m_nChunk = 0x14; // PulseRuntimeChunkIndex_t
    public const nint m_nDestInstruction = 0x18; // int32_t
    public const nint m_nCallInfoIndex = 0x1C; // PulseRuntimeCallInfoIndex_t
    public const nint m_Arg0Name = 0x20; // CUtlSymbolLarge
    public const nint m_Arg1Name = 0x28; // CUtlSymbolLarge
    public const nint m_bLiteralBool = 0x30; // bool
    public const nint m_nLiteralInt = 0x34; // int32_t
    public const nint m_flLiteralFloat = 0x38; // float
    public const nint m_LiteralString = 0x40; // CBufferString
    public const nint m_vLiteralVec3 = 0x50; // Vector
}

public static class PulseDocNodeID_t {
    public const nint m_Value = 0x0; // int32_t
}

public static class PulseRegisterMap_t {
    public const nint m_Inparams = 0x0; // KeyValues3
    public const nint m_Outparams = 0x10; // KeyValues3
}

public static class PulseRuntimeCallInfoIndex_t {
    public const nint m_Value = 0x0; // int32_t
}

public static class PulseRuntimeCellIndex_t {
    public const nint m_Value = 0x0; // int32_t
}

public static class PulseRuntimeChunkIndex_t {
    public const nint m_Value = 0x0; // int32_t
}

public static class PulseRuntimeEntrypointIndex_t {
    public const nint m_Value = 0x0; // int32_t
}

public static class PulseRuntimeInvokeIndex_t {
    public const nint m_Value = 0x0; // int32_t
}

public static class PulseRuntimeOutputIndex_t {
    public const nint m_Value = 0x0; // int32_t
}

public static class PulseRuntimeRegisterIndex_t {
    public const nint m_Value = 0x0; // int16_t
}

public static class PulseRuntimeStateOffset_t {
    public const nint m_Value = 0x0; // uint16_t
}

public static class PulseRuntimeVarIndex_t {
    public const nint m_Value = 0x0; // int32_t
}

public static class PulseTestEHandle_t {
    public const nint m_Value = 0x0; // int32_t
}
```

`SDK/pulse_system.dll.hpp`:

```hpp
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.618146700 UTC
 */

#pragma once

#include <cstddef>

namespace CPulseCell_Base {
    constexpr std::ptrdiff_t m_nEditorNodeID = 0x8; // PulseDocNodeID_t
}

namespace CPulseCell_Inflow_BaseEntrypoint {
    constexpr std::ptrdiff_t m_EntryChunk = 0x48; // PulseRuntimeChunkIndex_t
    constexpr std::ptrdiff_t m_RegisterMap = 0x50; // PulseRegisterMap_t
}

namespace CPulseCell_Inflow_EntOutputHandler {
    constexpr std::ptrdiff_t m_SourceEntity = 0x70; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_SourceOutput = 0x78; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_TargetInput = 0x80; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_ExpectedParamType = 0x88; // CPulseValueFullType
}

namespace CPulseCell_Inflow_EventHandler {
    constexpr std::ptrdiff_t m_EventName = 0x70; // CUtlSymbolLarge
}

namespace CPulseCell_Inflow_GraphHook {
    constexpr std::ptrdiff_t m_HookName = 0x70; // CUtlSymbolLarge
}

namespace CPulseCell_Inflow_Method {
    constexpr std::ptrdiff_t m_MethodName = 0x70; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_Description = 0x78; // CUtlString
    constexpr std::ptrdiff_t m_bIsPublic = 0x80; // bool
    constexpr std::ptrdiff_t m_ReturnType = 0x88; // CPulseValueFullType
    constexpr std::ptrdiff_t m_Args = 0x98; // CUtlVector<CPulseRuntimeMethodArg>
}

namespace CPulseCell_Inflow_Wait {
    constexpr std::ptrdiff_t m_WakeResume = 0x48; // CPulse_ResumePoint
}

namespace CPulseCell_Inflow_Yield {
    constexpr std::ptrdiff_t m_UnyieldResume = 0x48; // CPulse_ResumePoint
}

namespace CPulseCell_Outflow_CycleOrdered {
    constexpr std::ptrdiff_t m_Outputs = 0x48; // CUtlVector<CPulse_OutflowConnection>
}

namespace CPulseCell_Outflow_CycleOrdered_InstanceState_t {
    constexpr std::ptrdiff_t m_nNextIndex = 0x0; // int32_t
}

namespace CPulseCell_Outflow_CycleRandom {
    constexpr std::ptrdiff_t m_Outputs = 0x48; // CUtlVector<CPulse_OutflowConnection>
}

namespace CPulseCell_Outflow_CycleShuffled {
    constexpr std::ptrdiff_t m_Outputs = 0x48; // CUtlVector<CPulse_OutflowConnection>
}

namespace CPulseCell_Outflow_CycleShuffled_InstanceState_t {
    constexpr std::ptrdiff_t m_Shuffle = 0x0; // CUtlVectorFixedGrowable<uint8_t>
    constexpr std::ptrdiff_t m_nNextShuffle = 0x20; // int32_t
}

namespace CPulseCell_Outflow_IntSwitch {
    constexpr std::ptrdiff_t m_DefaultCaseOutflow = 0x48; // CPulse_OutflowConnection
    constexpr std::ptrdiff_t m_CaseOutflows = 0x58; // CUtlVector<CPulse_OutflowConnection>
}

namespace CPulseCell_Outflow_SimultaneousParallel {
    constexpr std::ptrdiff_t m_Outputs = 0x48; // CUtlVector<CPulse_OutflowConnection>
}

namespace CPulseCell_Outflow_StringSwitch {
    constexpr std::ptrdiff_t m_DefaultCaseOutflow = 0x48; // CPulse_OutflowConnection
    constexpr std::ptrdiff_t m_CaseOutflows = 0x58; // CUtlVector<CPulse_OutflowConnection>
}

namespace CPulseCell_Outflow_TestExplicitYesNo {
    constexpr std::ptrdiff_t m_Yes = 0x48; // CPulse_OutflowConnection
    constexpr std::ptrdiff_t m_No = 0x58; // CPulse_OutflowConnection
}

namespace CPulseCell_Outflow_TestRandomYesNo {
    constexpr std::ptrdiff_t m_Yes = 0x48; // CPulse_OutflowConnection
    constexpr std::ptrdiff_t m_No = 0x58; // CPulse_OutflowConnection
}

namespace CPulseCell_Step_CallExternalMethod {
    constexpr std::ptrdiff_t m_MethodName = 0x48; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_ExpectedArgs = 0x50; // CUtlVector<CPulseRuntimeMethodArg>
}

namespace CPulseCell_Step_PublicOutput {
    constexpr std::ptrdiff_t m_OutputIndex = 0x48; // PulseRuntimeOutputIndex_t
}

namespace CPulseCell_Step_TestDomainEntFire {
    constexpr std::ptrdiff_t m_Input = 0x48; // CUtlString
}

namespace CPulseGraphDef {
    constexpr std::ptrdiff_t m_DomainIdentifier = 0x8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_ParentMapName = 0x10; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_Chunks = 0x18; // CUtlVector<CPulse_Chunk*>
    constexpr std::ptrdiff_t m_Cells = 0x30; // CUtlVector<CPulseCell_Base*>
    constexpr std::ptrdiff_t m_Vars = 0x48; // CUtlVector<CPulse_Variable>
    constexpr std::ptrdiff_t m_PublicOutputs = 0x60; // CUtlVector<CPulse_PublicOutput>
    constexpr std::ptrdiff_t m_InvokeBindings = 0x78; // CUtlVector<CPulse_InvokeBinding*>
    constexpr std::ptrdiff_t m_CallInfos = 0x90; // CUtlVector<CPulse_CallInfo*>
    constexpr std::ptrdiff_t m_OutputConnections = 0xA8; // CUtlVector<CPulse_OutputConnection*>
}

namespace CPulseGraphInstance_TestDomain {
    constexpr std::ptrdiff_t m_bIsRunningUnitTests = 0xD0; // bool
    constexpr std::ptrdiff_t m_bExplicitTimeStepping = 0xD1; // bool
    constexpr std::ptrdiff_t m_bExpectingToDestroyWithYieldedCursors = 0xD2; // bool
    constexpr std::ptrdiff_t m_nNextValidateIndex = 0xD4; // int32_t
    constexpr std::ptrdiff_t m_Tracepoints = 0xD8; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_bTestYesOrNoPath = 0xF0; // bool
}

namespace CPulseGraphInstance_TestDomain_Derived {
    constexpr std::ptrdiff_t m_nInstanceValueX = 0xF8; // int32_t
}

namespace CPulseRuntimeMethodArg {
    constexpr std::ptrdiff_t m_Name = 0x0; // CKV3MemberNameWithStorage
    constexpr std::ptrdiff_t m_Description = 0x38; // CUtlString
    constexpr std::ptrdiff_t m_Type = 0x40; // CPulseValueFullType
}

namespace CPulseTurtleGraphicsCursor {
    constexpr std::ptrdiff_t m_Color = 0x188; // Color
    constexpr std::ptrdiff_t m_vPos = 0x18C; // Vector2D
    constexpr std::ptrdiff_t m_flHeadingDeg = 0x194; // float
    constexpr std::ptrdiff_t m_bPenUp = 0x198; // bool
}

namespace CPulse_CallInfo {
    constexpr std::ptrdiff_t m_PortName = 0x0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nEditorNodeID = 0x8; // PulseDocNodeID_t
    constexpr std::ptrdiff_t m_RegisterMap = 0x10; // PulseRegisterMap_t
    constexpr std::ptrdiff_t m_CallMethodID = 0x30; // PulseDocNodeID_t
    constexpr std::ptrdiff_t m_nSrcChunk = 0x34; // PulseRuntimeChunkIndex_t
    constexpr std::ptrdiff_t m_nSrcInstruction = 0x38; // int32_t
}

namespace CPulse_Chunk {
    constexpr std::ptrdiff_t m_Instructions = 0x0; // CUtlLeanVector<PGDInstruction_t>
    constexpr std::ptrdiff_t m_Registers = 0x10; // CUtlLeanVector<CPulse_RegisterInfo>
    constexpr std::ptrdiff_t m_InstructionEditorIDs = 0x20; // CUtlLeanVector<PulseDocNodeID_t>
}

namespace CPulse_InvokeBinding {
    constexpr std::ptrdiff_t m_RegisterMap = 0x0; // PulseRegisterMap_t
    constexpr std::ptrdiff_t m_FuncName = 0x20; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nCellIndex = 0x28; // PulseRuntimeCellIndex_t
    constexpr std::ptrdiff_t m_InstanceType = 0x30; // CPulseValueFullType
    constexpr std::ptrdiff_t m_nSrcChunk = 0x40; // PulseRuntimeChunkIndex_t
    constexpr std::ptrdiff_t m_nSrcInstruction = 0x44; // int32_t
}

namespace CPulse_OutflowConnection {
    constexpr std::ptrdiff_t m_SourceOutflowName = 0x0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nDestChunk = 0x8; // PulseRuntimeChunkIndex_t
    constexpr std::ptrdiff_t m_nInstruction = 0xC; // int32_t
}

namespace CPulse_OutputConnection {
    constexpr std::ptrdiff_t m_SourceOutput = 0x0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_TargetEntity = 0x8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_TargetInput = 0x10; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_Param = 0x18; // CUtlSymbolLarge
}

namespace CPulse_PublicOutput {
    constexpr std::ptrdiff_t m_Name = 0x0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_Description = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_ParamType = 0x10; // CPulseValueFullType
}

namespace CPulse_RegisterInfo {
    constexpr std::ptrdiff_t m_nReg = 0x0; // PulseRuntimeRegisterIndex_t
    constexpr std::ptrdiff_t m_Type = 0x8; // CPulseValueFullType
    constexpr std::ptrdiff_t m_OriginName = 0x18; // CKV3MemberNameWithStorage
    constexpr std::ptrdiff_t m_nWrittenByInstruction = 0x50; // int32_t
    constexpr std::ptrdiff_t m_nLastReadByInstruction = 0x54; // int32_t
}

namespace CPulse_Variable {
    constexpr std::ptrdiff_t m_Name = 0x0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_Description = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_Type = 0x10; // CPulseValueFullType
    constexpr std::ptrdiff_t m_DefaultValue = 0x20; // KeyValues3
    constexpr std::ptrdiff_t m_bIsPublic = 0x32; // bool
}

namespace CTestDomainDerived_Cursor {
    constexpr std::ptrdiff_t m_nCursorValueA = 0x188; // int32_t
    constexpr std::ptrdiff_t m_nCursorValueB = 0x18C; // int32_t
}

namespace FakeEntity_t {
    constexpr std::ptrdiff_t m_nHandle = 0x0; // PulseTestEHandle_t
    constexpr std::ptrdiff_t m_Name = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_Class = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_bDestroyed = 0x18; // bool
    constexpr std::ptrdiff_t m_pAssociatedGraphInstance = 0x20; // CPulseGraphInstance_TestDomain*
    constexpr std::ptrdiff_t m_bFuncWasCalled = 0x28; // bool
    constexpr std::ptrdiff_t m_fValue = 0x2C; // float
}

namespace PGDInstruction_t {
    constexpr std::ptrdiff_t m_nCode = 0x0; // PulseInstructionCode_t
    constexpr std::ptrdiff_t m_nVar = 0x4; // PulseRuntimeVarIndex_t
    constexpr std::ptrdiff_t m_nReg0 = 0x8; // PulseRuntimeRegisterIndex_t
    constexpr std::ptrdiff_t m_nReg1 = 0xA; // PulseRuntimeRegisterIndex_t
    constexpr std::ptrdiff_t m_nReg2 = 0xC; // PulseRuntimeRegisterIndex_t
    constexpr std::ptrdiff_t m_nInvokeBindingIndex = 0x10; // PulseRuntimeInvokeIndex_t
    constexpr std::ptrdiff_t m_nChunk = 0x14; // PulseRuntimeChunkIndex_t
    constexpr std::ptrdiff_t m_nDestInstruction = 0x18; // int32_t
    constexpr std::ptrdiff_t m_nCallInfoIndex = 0x1C; // PulseRuntimeCallInfoIndex_t
    constexpr std::ptrdiff_t m_Arg0Name = 0x20; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_Arg1Name = 0x28; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bLiteralBool = 0x30; // bool
    constexpr std::ptrdiff_t m_nLiteralInt = 0x34; // int32_t
    constexpr std::ptrdiff_t m_flLiteralFloat = 0x38; // float
    constexpr std::ptrdiff_t m_LiteralString = 0x40; // CBufferString
    constexpr std::ptrdiff_t m_vLiteralVec3 = 0x50; // Vector
}

namespace PulseDocNodeID_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace PulseRegisterMap_t {
    constexpr std::ptrdiff_t m_Inparams = 0x0; // KeyValues3
    constexpr std::ptrdiff_t m_Outparams = 0x10; // KeyValues3
}

namespace PulseRuntimeCallInfoIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace PulseRuntimeCellIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace PulseRuntimeChunkIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace PulseRuntimeEntrypointIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace PulseRuntimeInvokeIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace PulseRuntimeOutputIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace PulseRuntimeRegisterIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int16_t
}

namespace PulseRuntimeStateOffset_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // uint16_t
}

namespace PulseRuntimeVarIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace PulseTestEHandle_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}
```

`SDK/pulse_system.dll.json`:

```json
{
  "CPulseCell_Base": {
    "m_nEditorNodeID": 8
  },
  "CPulseCell_Inflow_BaseEntrypoint": {
    "m_EntryChunk": 72,
    "m_RegisterMap": 80
  },
  "CPulseCell_Inflow_EntOutputHandler": {
    "m_ExpectedParamType": 136,
    "m_SourceEntity": 112,
    "m_SourceOutput": 120,
    "m_TargetInput": 128
  },
  "CPulseCell_Inflow_EventHandler": {
    "m_EventName": 112
  },
  "CPulseCell_Inflow_GraphHook": {
    "m_HookName": 112
  },
  "CPulseCell_Inflow_Method": {
    "m_Args": 152,
    "m_Description": 120,
    "m_MethodName": 112,
    "m_ReturnType": 136,
    "m_bIsPublic": 128
  },
  "CPulseCell_Inflow_Wait": {
    "m_WakeResume": 72
  },
  "CPulseCell_Inflow_Yield": {
    "m_UnyieldResume": 72
  },
  "CPulseCell_Outflow_CycleOrdered": {
    "m_Outputs": 72
  },
  "CPulseCell_Outflow_CycleOrdered_InstanceState_t": {
    "m_nNextIndex": 0
  },
  "CPulseCell_Outflow_CycleRandom": {
    "m_Outputs": 72
  },
  "CPulseCell_Outflow_CycleShuffled": {
    "m_Outputs": 72
  },
  "CPulseCell_Outflow_CycleShuffled_InstanceState_t": {
    "m_Shuffle": 0,
    "m_nNextShuffle": 32
  },
  "CPulseCell_Outflow_IntSwitch": {
    "m_CaseOutflows": 88,
    "m_DefaultCaseOutflow": 72
  },
  "CPulseCell_Outflow_SimultaneousParallel": {
    "m_Outputs": 72
  },
  "CPulseCell_Outflow_StringSwitch": {
    "m_CaseOutflows": 88,
    "m_DefaultCaseOutflow": 72
  },
  "CPulseCell_Outflow_TestExplicitYesNo": {
    "m_No": 88,
    "m_Yes": 72
  },
  "CPulseCell_Outflow_TestRandomYesNo": {
    "m_No": 88,
    "m_Yes": 72
  },
  "CPulseCell_Step_CallExternalMethod": {
    "m_ExpectedArgs": 80,
    "m_MethodName": 72
  },
  "CPulseCell_Step_PublicOutput": {
    "m_OutputIndex": 72
  },
  "CPulseCell_Step_TestDomainEntFire": {
    "m_Input": 72
  },
  "CPulseGraphDef": {
    "m_CallInfos": 144,
    "m_Cells": 48,
    "m_Chunks": 24,
    "m_DomainIdentifier": 8,
    "m_InvokeBindings": 120,
    "m_OutputConnections": 168,
    "m_ParentMapName": 16,
    "m_PublicOutputs": 96,
    "m_Vars": 72
  },
  "CPulseGraphInstance_TestDomain": {
    "m_Tracepoints": 216,
    "m_bExpectingToDestroyWithYieldedCursors": 210,
    "m_bExplicitTimeStepping": 209,
    "m_bIsRunningUnitTests": 208,
    "m_bTestYesOrNoPath": 240,
    "m_nNextValidateIndex": 212
  },
  "CPulseGraphInstance_TestDomain_Derived": {
    "m_nInstanceValueX": 248
  },
  "CPulseRuntimeMethodArg": {
    "m_Description": 56,
    "m_Name": 0,
    "m_Type": 64
  },
  "CPulseTurtleGraphicsCursor": {
    "m_Color": 392,
    "m_bPenUp": 408,
    "m_flHeadingDeg": 404,
    "m_vPos": 396
  },
  "CPulse_CallInfo": {
    "m_CallMethodID": 48,
    "m_PortName": 0,
    "m_RegisterMap": 16,
    "m_nEditorNodeID": 8,
    "m_nSrcChunk": 52,
    "m_nSrcInstruction": 56
  },
  "CPulse_Chunk": {
    "m_InstructionEditorIDs": 32,
    "m_Instructions": 0,
    "m_Registers": 16
  },
  "CPulse_InvokeBinding": {
    "m_FuncName": 32,
    "m_InstanceType": 48,
    "m_RegisterMap": 0,
    "m_nCellIndex": 40,
    "m_nSrcChunk": 64,
    "m_nSrcInstruction": 68
  },
  "CPulse_OutflowConnection": {
    "m_SourceOutflowName": 0,
    "m_nDestChunk": 8,
    "m_nInstruction": 12
  },
  "CPulse_OutputConnection": {
    "m_Param": 24,
    "m_SourceOutput": 0,
    "m_TargetEntity": 8,
    "m_TargetInput": 16
  },
  "CPulse_PublicOutput": {
    "m_Description": 8,
    "m_Name": 0,
    "m_ParamType": 16
  },
  "CPulse_RegisterInfo": {
    "m_OriginName": 24,
    "m_Type": 8,
    "m_nLastReadByInstruction": 84,
    "m_nReg": 0,
    "m_nWrittenByInstruction": 80
  },
  "CPulse_Variable": {
    "m_DefaultValue": 32,
    "m_Description": 8,
    "m_Name": 0,
    "m_Type": 16,
    "m_bIsPublic": 50
  },
  "CTestDomainDerived_Cursor": {
    "m_nCursorValueA": 392,
    "m_nCursorValueB": 396
  },
  "FakeEntity_t": {
    "m_Class": 16,
    "m_Name": 8,
    "m_bDestroyed": 24,
    "m_bFuncWasCalled": 40,
    "m_fValue": 44,
    "m_nHandle": 0,
    "m_pAssociatedGraphInstance": 32
  },
  "PGDInstruction_t": {
    "m_Arg0Name": 32,
    "m_Arg1Name": 40,
    "m_LiteralString": 64,
    "m_bLiteralBool": 48,
    "m_flLiteralFloat": 56,
    "m_nCallInfoIndex": 28,
    "m_nChunk": 20,
    "m_nCode": 0,
    "m_nDestInstruction": 24,
    "m_nInvokeBindingIndex": 16,
    "m_nLiteralInt": 52,
    "m_nReg0": 8,
    "m_nReg1": 10,
    "m_nReg2": 12,
    "m_nVar": 4,
    "m_vLiteralVec3": 80
  },
  "PulseDocNodeID_t": {
    "m_Value": 0
  },
  "PulseRegisterMap_t": {
    "m_Inparams": 0,
    "m_Outparams": 16
  },
  "PulseRuntimeCallInfoIndex_t": {
    "m_Value": 0
  },
  "PulseRuntimeCellIndex_t": {
    "m_Value": 0
  },
  "PulseRuntimeChunkIndex_t": {
    "m_Value": 0
  },
  "PulseRuntimeEntrypointIndex_t": {
    "m_Value": 0
  },
  "PulseRuntimeInvokeIndex_t": {
    "m_Value": 0
  },
  "PulseRuntimeOutputIndex_t": {
    "m_Value": 0
  },
  "PulseRuntimeRegisterIndex_t": {
    "m_Value": 0
  },
  "PulseRuntimeStateOffset_t": {
    "m_Value": 0
  },
  "PulseRuntimeVarIndex_t": {
    "m_Value": 0
  },
  "PulseTestEHandle_t": {
    "m_Value": 0
  }
}
```

`SDK/pulse_system.dll.py`:

```py
'''
https://github.com/a2x/cs2-dumper
2023-11-23 10:28:25.627236900 UTC
'''

class CPulseCell_Base:
    m_nEditorNodeID = 0x8 # PulseDocNodeID_t

class CPulseCell_Inflow_BaseEntrypoint:
    m_EntryChunk = 0x48 # PulseRuntimeChunkIndex_t
    m_RegisterMap = 0x50 # PulseRegisterMap_t

class CPulseCell_Inflow_EntOutputHandler:
    m_SourceEntity = 0x70 # CUtlSymbolLarge
    m_SourceOutput = 0x78 # CUtlSymbolLarge
    m_TargetInput = 0x80 # CUtlSymbolLarge
    m_ExpectedParamType = 0x88 # CPulseValueFullType

class CPulseCell_Inflow_EventHandler:
    m_EventName = 0x70 # CUtlSymbolLarge

class CPulseCell_Inflow_GraphHook:
    m_HookName = 0x70 # CUtlSymbolLarge

class CPulseCell_Inflow_Method:
    m_MethodName = 0x70 # CUtlSymbolLarge
    m_Description = 0x78 # CUtlString
    m_bIsPublic = 0x80 # bool
    m_ReturnType = 0x88 # CPulseValueFullType
    m_Args = 0x98 # CUtlVector<CPulseRuntimeMethodArg>

class CPulseCell_Inflow_Wait:
    m_WakeResume = 0x48 # CPulse_ResumePoint

class CPulseCell_Inflow_Yield:
    m_UnyieldResume = 0x48 # CPulse_ResumePoint

class CPulseCell_Outflow_CycleOrdered:
    m_Outputs = 0x48 # CUtlVector<CPulse_OutflowConnection>

class CPulseCell_Outflow_CycleOrdered_InstanceState_t:
    m_nNextIndex = 0x0 # int32_t

class CPulseCell_Outflow_CycleRandom:
    m_Outputs = 0x48 # CUtlVector<CPulse_OutflowConnection>

class CPulseCell_Outflow_CycleShuffled:
    m_Outputs = 0x48 # CUtlVector<CPulse_OutflowConnection>

class CPulseCell_Outflow_CycleShuffled_InstanceState_t:
    m_Shuffle = 0x0 # CUtlVectorFixedGrowable<uint8_t>
    m_nNextShuffle = 0x20 # int32_t

class CPulseCell_Outflow_IntSwitch:
    m_DefaultCaseOutflow = 0x48 # CPulse_OutflowConnection
    m_CaseOutflows = 0x58 # CUtlVector<CPulse_OutflowConnection>

class CPulseCell_Outflow_SimultaneousParallel:
    m_Outputs = 0x48 # CUtlVector<CPulse_OutflowConnection>

class CPulseCell_Outflow_StringSwitch:
    m_DefaultCaseOutflow = 0x48 # CPulse_OutflowConnection
    m_CaseOutflows = 0x58 # CUtlVector<CPulse_OutflowConnection>

class CPulseCell_Outflow_TestExplicitYesNo:
    m_Yes = 0x48 # CPulse_OutflowConnection
    m_No = 0x58 # CPulse_OutflowConnection

class CPulseCell_Outflow_TestRandomYesNo:
    m_Yes = 0x48 # CPulse_OutflowConnection
    m_No = 0x58 # CPulse_OutflowConnection

class CPulseCell_Step_CallExternalMethod:
    m_MethodName = 0x48 # CUtlSymbolLarge
    m_ExpectedArgs = 0x50 # CUtlVector<CPulseRuntimeMethodArg>

class CPulseCell_Step_PublicOutput:
    m_OutputIndex = 0x48 # PulseRuntimeOutputIndex_t

class CPulseCell_Step_TestDomainEntFire:
    m_Input = 0x48 # CUtlString

class CPulseGraphDef:
    m_DomainIdentifier = 0x8 # CUtlSymbolLarge
    m_ParentMapName = 0x10 # CUtlSymbolLarge
    m_Chunks = 0x18 # CUtlVector<CPulse_Chunk*>
    m_Cells = 0x30 # CUtlVector<CPulseCell_Base*>
    m_Vars = 0x48 # CUtlVector<CPulse_Variable>
    m_PublicOutputs = 0x60 # CUtlVector<CPulse_PublicOutput>
    m_InvokeBindings = 0x78 # CUtlVector<CPulse_InvokeBinding*>
    m_CallInfos = 0x90 # CUtlVector<CPulse_CallInfo*>
    m_OutputConnections = 0xA8 # CUtlVector<CPulse_OutputConnection*>

class CPulseGraphInstance_TestDomain:
    m_bIsRunningUnitTests = 0xD0 # bool
    m_bExplicitTimeStepping = 0xD1 # bool
    m_bExpectingToDestroyWithYieldedCursors = 0xD2 # bool
    m_nNextValidateIndex = 0xD4 # int32_t
    m_Tracepoints = 0xD8 # CUtlVector<CUtlString>
    m_bTestYesOrNoPath = 0xF0 # bool

class CPulseGraphInstance_TestDomain_Derived:
    m_nInstanceValueX = 0xF8 # int32_t

class CPulseRuntimeMethodArg:
    m_Name = 0x0 # CKV3MemberNameWithStorage
    m_Description = 0x38 # CUtlString
    m_Type = 0x40 # CPulseValueFullType

class CPulseTurtleGraphicsCursor:
    m_Color = 0x188 # Color
    m_vPos = 0x18C # Vector2D
    m_flHeadingDeg = 0x194 # float
    m_bPenUp = 0x198 # bool

class CPulse_CallInfo:
    m_PortName = 0x0 # CUtlSymbolLarge
    m_nEditorNodeID = 0x8 # PulseDocNodeID_t
    m_RegisterMap = 0x10 # PulseRegisterMap_t
    m_CallMethodID = 0x30 # PulseDocNodeID_t
    m_nSrcChunk = 0x34 # PulseRuntimeChunkIndex_t
    m_nSrcInstruction = 0x38 # int32_t

class CPulse_Chunk:
    m_Instructions = 0x0 # CUtlLeanVector<PGDInstruction_t>
    m_Registers = 0x10 # CUtlLeanVector<CPulse_RegisterInfo>
    m_InstructionEditorIDs = 0x20 # CUtlLeanVector<PulseDocNodeID_t>

class CPulse_InvokeBinding:
    m_RegisterMap = 0x0 # PulseRegisterMap_t
    m_FuncName = 0x20 # CUtlSymbolLarge
    m_nCellIndex = 0x28 # PulseRuntimeCellIndex_t
    m_InstanceType = 0x30 # CPulseValueFullType
    m_nSrcChunk = 0x40 # PulseRuntimeChunkIndex_t
    m_nSrcInstruction = 0x44 # int32_t

class CPulse_OutflowConnection:
    m_SourceOutflowName = 0x0 # CUtlSymbolLarge
    m_nDestChunk = 0x8 # PulseRuntimeChunkIndex_t
    m_nInstruction = 0xC # int32_t

class CPulse_OutputConnection:
    m_SourceOutput = 0x0 # CUtlSymbolLarge
    m_TargetEntity = 0x8 # CUtlSymbolLarge
    m_TargetInput = 0x10 # CUtlSymbolLarge
    m_Param = 0x18 # CUtlSymbolLarge

class CPulse_PublicOutput:
    m_Name = 0x0 # CUtlSymbolLarge
    m_Description = 0x8 # CUtlString
    m_ParamType = 0x10 # CPulseValueFullType

class CPulse_RegisterInfo:
    m_nReg = 0x0 # PulseRuntimeRegisterIndex_t
    m_Type = 0x8 # CPulseValueFullType
    m_OriginName = 0x18 # CKV3MemberNameWithStorage
    m_nWrittenByInstruction = 0x50 # int32_t
    m_nLastReadByInstruction = 0x54 # int32_t

class CPulse_Variable:
    m_Name = 0x0 # CUtlSymbolLarge
    m_Description = 0x8 # CUtlString
    m_Type = 0x10 # CPulseValueFullType
    m_DefaultValue = 0x20 # KeyValues3
    m_bIsPublic = 0x32 # bool

class CTestDomainDerived_Cursor:
    m_nCursorValueA = 0x188 # int32_t
    m_nCursorValueB = 0x18C # int32_t

class FakeEntity_t:
    m_nHandle = 0x0 # PulseTestEHandle_t
    m_Name = 0x8 # CUtlString
    m_Class = 0x10 # CUtlString
    m_bDestroyed = 0x18 # bool
    m_pAssociatedGraphInstance = 0x20 # CPulseGraphInstance_TestDomain*
    m_bFuncWasCalled = 0x28 # bool
    m_fValue = 0x2C # float

class PGDInstruction_t:
    m_nCode = 0x0 # PulseInstructionCode_t
    m_nVar = 0x4 # PulseRuntimeVarIndex_t
    m_nReg0 = 0x8 # PulseRuntimeRegisterIndex_t
    m_nReg1 = 0xA # PulseRuntimeRegisterIndex_t
    m_nReg2 = 0xC # PulseRuntimeRegisterIndex_t
    m_nInvokeBindingIndex = 0x10 # PulseRuntimeInvokeIndex_t
    m_nChunk = 0x14 # PulseRuntimeChunkIndex_t
    m_nDestInstruction = 0x18 # int32_t
    m_nCallInfoIndex = 0x1C # PulseRuntimeCallInfoIndex_t
    m_Arg0Name = 0x20 # CUtlSymbolLarge
    m_Arg1Name = 0x28 # CUtlSymbolLarge
    m_bLiteralBool = 0x30 # bool
    m_nLiteralInt = 0x34 # int32_t
    m_flLiteralFloat = 0x38 # float
    m_LiteralString = 0x40 # CBufferString
    m_vLiteralVec3 = 0x50 # Vector

class PulseDocNodeID_t:
    m_Value = 0x0 # int32_t

class PulseRegisterMap_t:
    m_Inparams = 0x0 # KeyValues3
    m_Outparams = 0x10 # KeyValues3

class PulseRuntimeCallInfoIndex_t:
    m_Value = 0x0 # int32_t

class PulseRuntimeCellIndex_t:
    m_Value = 0x0 # int32_t

class PulseRuntimeChunkIndex_t:
    m_Value = 0x0 # int32_t

class PulseRuntimeEntrypointIndex_t:
    m_Value = 0x0 # int32_t

class PulseRuntimeInvokeIndex_t:
    m_Value = 0x0 # int32_t

class PulseRuntimeOutputIndex_t:
    m_Value = 0x0 # int32_t

class PulseRuntimeRegisterIndex_t:
    m_Value = 0x0 # int16_t

class PulseRuntimeStateOffset_t:
    m_Value = 0x0 # uint16_t

class PulseRuntimeVarIndex_t:
    m_Value = 0x0 # int32_t

class PulseTestEHandle_t:
    m_Value = 0x0 # int32_t

```

`SDK/pulse_system.dll.rs`:

```rs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.631616900 UTC
 */

#![allow(non_snake_case, non_upper_case_globals)]

pub mod CPulseCell_Base {
    pub const m_nEditorNodeID: usize = 0x8; // PulseDocNodeID_t
}

pub mod CPulseCell_Inflow_BaseEntrypoint {
    pub const m_EntryChunk: usize = 0x48; // PulseRuntimeChunkIndex_t
    pub const m_RegisterMap: usize = 0x50; // PulseRegisterMap_t
}

pub mod CPulseCell_Inflow_EntOutputHandler {
    pub const m_SourceEntity: usize = 0x70; // CUtlSymbolLarge
    pub const m_SourceOutput: usize = 0x78; // CUtlSymbolLarge
    pub const m_TargetInput: usize = 0x80; // CUtlSymbolLarge
    pub const m_ExpectedParamType: usize = 0x88; // CPulseValueFullType
}

pub mod CPulseCell_Inflow_EventHandler {
    pub const m_EventName: usize = 0x70; // CUtlSymbolLarge
}

pub mod CPulseCell_Inflow_GraphHook {
    pub const m_HookName: usize = 0x70; // CUtlSymbolLarge
}

pub mod CPulseCell_Inflow_Method {
    pub const m_MethodName: usize = 0x70; // CUtlSymbolLarge
    pub const m_Description: usize = 0x78; // CUtlString
    pub const m_bIsPublic: usize = 0x80; // bool
    pub const m_ReturnType: usize = 0x88; // CPulseValueFullType
    pub const m_Args: usize = 0x98; // CUtlVector<CPulseRuntimeMethodArg>
}

pub mod CPulseCell_Inflow_Wait {
    pub const m_WakeResume: usize = 0x48; // CPulse_ResumePoint
}

pub mod CPulseCell_Inflow_Yield {
    pub const m_UnyieldResume: usize = 0x48; // CPulse_ResumePoint
}

pub mod CPulseCell_Outflow_CycleOrdered {
    pub const m_Outputs: usize = 0x48; // CUtlVector<CPulse_OutflowConnection>
}

pub mod CPulseCell_Outflow_CycleOrdered_InstanceState_t {
    pub const m_nNextIndex: usize = 0x0; // int32_t
}

pub mod CPulseCell_Outflow_CycleRandom {
    pub const m_Outputs: usize = 0x48; // CUtlVector<CPulse_OutflowConnection>
}

pub mod CPulseCell_Outflow_CycleShuffled {
    pub const m_Outputs: usize = 0x48; // CUtlVector<CPulse_OutflowConnection>
}

pub mod CPulseCell_Outflow_CycleShuffled_InstanceState_t {
    pub const m_Shuffle: usize = 0x0; // CUtlVectorFixedGrowable<uint8_t>
    pub const m_nNextShuffle: usize = 0x20; // int32_t
}

pub mod CPulseCell_Outflow_IntSwitch {
    pub const m_DefaultCaseOutflow: usize = 0x48; // CPulse_OutflowConnection
    pub const m_CaseOutflows: usize = 0x58; // CUtlVector<CPulse_OutflowConnection>
}

pub mod CPulseCell_Outflow_SimultaneousParallel {
    pub const m_Outputs: usize = 0x48; // CUtlVector<CPulse_OutflowConnection>
}

pub mod CPulseCell_Outflow_StringSwitch {
    pub const m_DefaultCaseOutflow: usize = 0x48; // CPulse_OutflowConnection
    pub const m_CaseOutflows: usize = 0x58; // CUtlVector<CPulse_OutflowConnection>
}

pub mod CPulseCell_Outflow_TestExplicitYesNo {
    pub const m_Yes: usize = 0x48; // CPulse_OutflowConnection
    pub const m_No: usize = 0x58; // CPulse_OutflowConnection
}

pub mod CPulseCell_Outflow_TestRandomYesNo {
    pub const m_Yes: usize = 0x48; // CPulse_OutflowConnection
    pub const m_No: usize = 0x58; // CPulse_OutflowConnection
}

pub mod CPulseCell_Step_CallExternalMethod {
    pub const m_MethodName: usize = 0x48; // CUtlSymbolLarge
    pub const m_ExpectedArgs: usize = 0x50; // CUtlVector<CPulseRuntimeMethodArg>
}

pub mod CPulseCell_Step_PublicOutput {
    pub const m_OutputIndex: usize = 0x48; // PulseRuntimeOutputIndex_t
}

pub mod CPulseCell_Step_TestDomainEntFire {
    pub const m_Input: usize = 0x48; // CUtlString
}

pub mod CPulseGraphDef {
    pub const m_DomainIdentifier: usize = 0x8; // CUtlSymbolLarge
    pub const m_ParentMapName: usize = 0x10; // CUtlSymbolLarge
    pub const m_Chunks: usize = 0x18; // CUtlVector<CPulse_Chunk*>
    pub const m_Cells: usize = 0x30; // CUtlVector<CPulseCell_Base*>
    pub const m_Vars: usize = 0x48; // CUtlVector<CPulse_Variable>
    pub const m_PublicOutputs: usize = 0x60; // CUtlVector<CPulse_PublicOutput>
    pub const m_InvokeBindings: usize = 0x78; // CUtlVector<CPulse_InvokeBinding*>
    pub const m_CallInfos: usize = 0x90; // CUtlVector<CPulse_CallInfo*>
    pub const m_OutputConnections: usize = 0xA8; // CUtlVector<CPulse_OutputConnection*>
}

pub mod CPulseGraphInstance_TestDomain {
    pub const m_bIsRunningUnitTests: usize = 0xD0; // bool
    pub const m_bExplicitTimeStepping: usize = 0xD1; // bool
    pub const m_bExpectingToDestroyWithYieldedCursors: usize = 0xD2; // bool
    pub const m_nNextValidateIndex: usize = 0xD4; // int32_t
    pub const m_Tracepoints: usize = 0xD8; // CUtlVector<CUtlString>
    pub const m_bTestYesOrNoPath: usize = 0xF0; // bool
}

pub mod CPulseGraphInstance_TestDomain_Derived {
    pub const m_nInstanceValueX: usize = 0xF8; // int32_t
}

pub mod CPulseRuntimeMethodArg {
    pub const m_Name: usize = 0x0; // CKV3MemberNameWithStorage
    pub const m_Description: usize = 0x38; // CUtlString
    pub const m_Type: usize = 0x40; // CPulseValueFullType
}

pub mod CPulseTurtleGraphicsCursor {
    pub const m_Color: usize = 0x188; // Color
    pub const m_vPos: usize = 0x18C; // Vector2D
    pub const m_flHeadingDeg: usize = 0x194; // float
    pub const m_bPenUp: usize = 0x198; // bool
}

pub mod CPulse_CallInfo {
    pub const m_PortName: usize = 0x0; // CUtlSymbolLarge
    pub const m_nEditorNodeID: usize = 0x8; // PulseDocNodeID_t
    pub const m_RegisterMap: usize = 0x10; // PulseRegisterMap_t
    pub const m_CallMethodID: usize = 0x30; // PulseDocNodeID_t
    pub const m_nSrcChunk: usize = 0x34; // PulseRuntimeChunkIndex_t
    pub const m_nSrcInstruction: usize = 0x38; // int32_t
}

pub mod CPulse_Chunk {
    pub const m_Instructions: usize = 0x0; // CUtlLeanVector<PGDInstruction_t>
    pub const m_Registers: usize = 0x10; // CUtlLeanVector<CPulse_RegisterInfo>
    pub const m_InstructionEditorIDs: usize = 0x20; // CUtlLeanVector<PulseDocNodeID_t>
}

pub mod CPulse_InvokeBinding {
    pub const m_RegisterMap: usize = 0x0; // PulseRegisterMap_t
    pub const m_FuncName: usize = 0x20; // CUtlSymbolLarge
    pub const m_nCellIndex: usize = 0x28; // PulseRuntimeCellIndex_t
    pub const m_InstanceType: usize = 0x30; // CPulseValueFullType
    pub const m_nSrcChunk: usize = 0x40; // PulseRuntimeChunkIndex_t
    pub const m_nSrcInstruction: usize = 0x44; // int32_t
}

pub mod CPulse_OutflowConnection {
    pub const m_SourceOutflowName: usize = 0x0; // CUtlSymbolLarge
    pub const m_nDestChunk: usize = 0x8; // PulseRuntimeChunkIndex_t
    pub const m_nInstruction: usize = 0xC; // int32_t
}

pub mod CPulse_OutputConnection {
    pub const m_SourceOutput: usize = 0x0; // CUtlSymbolLarge
    pub const m_TargetEntity: usize = 0x8; // CUtlSymbolLarge
    pub const m_TargetInput: usize = 0x10; // CUtlSymbolLarge
    pub const m_Param: usize = 0x18; // CUtlSymbolLarge
}

pub mod CPulse_PublicOutput {
    pub const m_Name: usize = 0x0; // CUtlSymbolLarge
    pub const m_Description: usize = 0x8; // CUtlString
    pub const m_ParamType: usize = 0x10; // CPulseValueFullType
}

pub mod CPulse_RegisterInfo {
    pub const m_nReg: usize = 0x0; // PulseRuntimeRegisterIndex_t
    pub const m_Type: usize = 0x8; // CPulseValueFullType
    pub const m_OriginName: usize = 0x18; // CKV3MemberNameWithStorage
    pub const m_nWrittenByInstruction: usize = 0x50; // int32_t
    pub const m_nLastReadByInstruction: usize = 0x54; // int32_t
}

pub mod CPulse_Variable {
    pub const m_Name: usize = 0x0; // CUtlSymbolLarge
    pub const m_Description: usize = 0x8; // CUtlString
    pub const m_Type: usize = 0x10; // CPulseValueFullType
    pub const m_DefaultValue: usize = 0x20; // KeyValues3
    pub const m_bIsPublic: usize = 0x32; // bool
}

pub mod CTestDomainDerived_Cursor {
    pub const m_nCursorValueA: usize = 0x188; // int32_t
    pub const m_nCursorValueB: usize = 0x18C; // int32_t
}

pub mod FakeEntity_t {
    pub const m_nHandle: usize = 0x0; // PulseTestEHandle_t
    pub const m_Name: usize = 0x8; // CUtlString
    pub const m_Class: usize = 0x10; // CUtlString
    pub const m_bDestroyed: usize = 0x18; // bool
    pub const m_pAssociatedGraphInstance: usize = 0x20; // CPulseGraphInstance_TestDomain*
    pub const m_bFuncWasCalled: usize = 0x28; // bool
    pub const m_fValue: usize = 0x2C; // float
}

pub mod PGDInstruction_t {
    pub const m_nCode: usize = 0x0; // PulseInstructionCode_t
    pub const m_nVar: usize = 0x4; // PulseRuntimeVarIndex_t
    pub const m_nReg0: usize = 0x8; // PulseRuntimeRegisterIndex_t
    pub const m_nReg1: usize = 0xA; // PulseRuntimeRegisterIndex_t
    pub const m_nReg2: usize = 0xC; // PulseRuntimeRegisterIndex_t
    pub const m_nInvokeBindingIndex: usize = 0x10; // PulseRuntimeInvokeIndex_t
    pub const m_nChunk: usize = 0x14; // PulseRuntimeChunkIndex_t
    pub const m_nDestInstruction: usize = 0x18; // int32_t
    pub const m_nCallInfoIndex: usize = 0x1C; // PulseRuntimeCallInfoIndex_t
    pub const m_Arg0Name: usize = 0x20; // CUtlSymbolLarge
    pub const m_Arg1Name: usize = 0x28; // CUtlSymbolLarge
    pub const m_bLiteralBool: usize = 0x30; // bool
    pub const m_nLiteralInt: usize = 0x34; // int32_t
    pub const m_flLiteralFloat: usize = 0x38; // float
    pub const m_LiteralString: usize = 0x40; // CBufferString
    pub const m_vLiteralVec3: usize = 0x50; // Vector
}

pub mod PulseDocNodeID_t {
    pub const m_Value: usize = 0x0; // int32_t
}

pub mod PulseRegisterMap_t {
    pub const m_Inparams: usize = 0x0; // KeyValues3
    pub const m_Outparams: usize = 0x10; // KeyValues3
}

pub mod PulseRuntimeCallInfoIndex_t {
    pub const m_Value: usize = 0x0; // int32_t
}

pub mod PulseRuntimeCellIndex_t {
    pub const m_Value: usize = 0x0; // int32_t
}

pub mod PulseRuntimeChunkIndex_t {
    pub const m_Value: usize = 0x0; // int32_t
}

pub mod PulseRuntimeEntrypointIndex_t {
    pub const m_Value: usize = 0x0; // int32_t
}

pub mod PulseRuntimeInvokeIndex_t {
    pub const m_Value: usize = 0x0; // int32_t
}

pub mod PulseRuntimeOutputIndex_t {
    pub const m_Value: usize = 0x0; // int32_t
}

pub mod PulseRuntimeRegisterIndex_t {
    pub const m_Value: usize = 0x0; // int16_t
}

pub mod PulseRuntimeStateOffset_t {
    pub const m_Value: usize = 0x0; // uint16_t
}

pub mod PulseRuntimeVarIndex_t {
    pub const m_Value: usize = 0x0; // int32_t
}

pub mod PulseTestEHandle_t {
    pub const m_Value: usize = 0x0; // int32_t
}
```

`SDK/rendersystemdx11.dll.cs`:

```cs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.147932300 UTC
 */

public static class RenderInputLayoutField_t {
    public const nint m_pSemanticName = 0x0; // uint8_t[32]
    public const nint m_nSemanticIndex = 0x20; // int32_t
    public const nint m_Format = 0x24; // uint32_t
    public const nint m_nOffset = 0x28; // int32_t
    public const nint m_nSlot = 0x2C; // int32_t
    public const nint m_nSlotType = 0x30; // RenderSlotType_t
    public const nint m_nInstanceStepRate = 0x34; // int32_t
}

public static class VsInputSignatureElement_t {
    public const nint m_pName = 0x0; // char[64]
    public const nint m_pSemantic = 0x40; // char[64]
    public const nint m_pD3DSemanticName = 0x80; // char[64]
    public const nint m_nD3DSemanticIndex = 0xC0; // int32_t
}

public static class VsInputSignature_t {
    public const nint m_elems = 0x0; // CUtlVector<VsInputSignatureElement_t>
}
```

`SDK/rendersystemdx11.dll.hpp`:

```hpp
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.146651500 UTC
 */

#pragma once

#include <cstddef>

namespace RenderInputLayoutField_t {
    constexpr std::ptrdiff_t m_pSemanticName = 0x0; // uint8_t[32]
    constexpr std::ptrdiff_t m_nSemanticIndex = 0x20; // int32_t
    constexpr std::ptrdiff_t m_Format = 0x24; // uint32_t
    constexpr std::ptrdiff_t m_nOffset = 0x28; // int32_t
    constexpr std::ptrdiff_t m_nSlot = 0x2C; // int32_t
    constexpr std::ptrdiff_t m_nSlotType = 0x30; // RenderSlotType_t
    constexpr std::ptrdiff_t m_nInstanceStepRate = 0x34; // int32_t
}

namespace VsInputSignatureElement_t {
    constexpr std::ptrdiff_t m_pName = 0x0; // char[64]
    constexpr std::ptrdiff_t m_pSemantic = 0x40; // char[64]
    constexpr std::ptrdiff_t m_pD3DSemanticName = 0x80; // char[64]
    constexpr std::ptrdiff_t m_nD3DSemanticIndex = 0xC0; // int32_t
}

namespace VsInputSignature_t {
    constexpr std::ptrdiff_t m_elems = 0x0; // CUtlVector<VsInputSignatureElement_t>
}
```

`SDK/rendersystemdx11.dll.json`:

```json
{
  "RenderInputLayoutField_t": {
    "m_Format": 36,
    "m_nInstanceStepRate": 52,
    "m_nOffset": 40,
    "m_nSemanticIndex": 32,
    "m_nSlot": 44,
    "m_nSlotType": 48,
    "m_pSemanticName": 0
  },
  "VsInputSignatureElement_t": {
    "m_nD3DSemanticIndex": 192,
    "m_pD3DSemanticName": 128,
    "m_pName": 0,
    "m_pSemantic": 64
  },
  "VsInputSignature_t": {
    "m_elems": 0
  }
}
```

`SDK/rendersystemdx11.dll.py`:

```py
'''
https://github.com/a2x/cs2-dumper
2023-11-23 10:28:25.149873400 UTC
'''

class RenderInputLayoutField_t:
    m_pSemanticName = 0x0 # uint8_t[32]
    m_nSemanticIndex = 0x20 # int32_t
    m_Format = 0x24 # uint32_t
    m_nOffset = 0x28 # int32_t
    m_nSlot = 0x2C # int32_t
    m_nSlotType = 0x30 # RenderSlotType_t
    m_nInstanceStepRate = 0x34 # int32_t

class VsInputSignatureElement_t:
    m_pName = 0x0 # char[64]
    m_pSemantic = 0x40 # char[64]
    m_pD3DSemanticName = 0x80 # char[64]
    m_nD3DSemanticIndex = 0xC0 # int32_t

class VsInputSignature_t:
    m_elems = 0x0 # CUtlVector<VsInputSignatureElement_t>

```

`SDK/rendersystemdx11.dll.rs`:

```rs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.151807400 UTC
 */

#![allow(non_snake_case, non_upper_case_globals)]

pub mod RenderInputLayoutField_t {
    pub const m_pSemanticName: usize = 0x0; // uint8_t[32]
    pub const m_nSemanticIndex: usize = 0x20; // int32_t
    pub const m_Format: usize = 0x24; // uint32_t
    pub const m_nOffset: usize = 0x28; // int32_t
    pub const m_nSlot: usize = 0x2C; // int32_t
    pub const m_nSlotType: usize = 0x30; // RenderSlotType_t
    pub const m_nInstanceStepRate: usize = 0x34; // int32_t
}

pub mod VsInputSignatureElement_t {
    pub const m_pName: usize = 0x0; // char[64]
    pub const m_pSemantic: usize = 0x40; // char[64]
    pub const m_pD3DSemanticName: usize = 0x80; // char[64]
    pub const m_nD3DSemanticIndex: usize = 0xC0; // int32_t
}

pub mod VsInputSignature_t {
    pub const m_elems: usize = 0x0; // CUtlVector<VsInputSignatureElement_t>
}
```

`SDK/resourcesystem.dll.cs`:

```cs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.137831100 UTC
 */

public static class AABB_t {
    public const nint m_vMinBounds = 0x0; // Vector
    public const nint m_vMaxBounds = 0xC; // Vector
}

public static class CFuseProgram {
    public const nint m_programBuffer = 0x0; // CUtlVector<uint8_t>
    public const nint m_variablesRead = 0x18; // CUtlVector<FuseVariableIndex_t>
    public const nint m_variablesWritten = 0x30; // CUtlVector<FuseVariableIndex_t>
    public const nint m_nMaxTempVarsUsed = 0x48; // int32_t
}

public static class CFuseSymbolTable {
    public const nint m_constants = 0x0; // CUtlVector<ConstantInfo_t>
    public const nint m_variables = 0x18; // CUtlVector<VariableInfo_t>
    public const nint m_functions = 0x30; // CUtlVector<FunctionInfo_t>
    public const nint m_constantMap = 0x48; // CUtlHashtable<CUtlStringToken,int32_t>
    public const nint m_variableMap = 0x68; // CUtlHashtable<CUtlStringToken,int32_t>
    public const nint m_functionMap = 0x88; // CUtlHashtable<CUtlStringToken,int32_t>
}

public static class ConstantInfo_t {
    public const nint m_name = 0x0; // CUtlString
    public const nint m_nameToken = 0x8; // CUtlStringToken
    public const nint m_flValue = 0xC; // float
}

public static class FourQuaternions {
    public const nint x = 0x0; // fltx4
    public const nint y = 0x10; // fltx4
    public const nint z = 0x20; // fltx4
    public const nint w = 0x30; // fltx4
}

public static class FunctionInfo_t {
    public const nint m_name = 0x8; // CUtlString
    public const nint m_nameToken = 0x10; // CUtlStringToken
    public const nint m_nParamCount = 0x14; // int32_t
    public const nint m_nIndex = 0x18; // FuseFunctionIndex_t
    public const nint m_bIsPure = 0x1A; // bool
}

public static class FuseFunctionIndex_t {
    public const nint m_Value = 0x0; // uint16_t
}

public static class FuseVariableIndex_t {
    public const nint m_Value = 0x0; // uint16_t
}

public static class ManifestTestResource_t {
    public const nint m_name = 0x0; // CUtlString
    public const nint m_child = 0x8; // CStrongHandle<InfoForResourceTypeManifestTestResource_t>
}

public static class PackedAABB_t {
    public const nint m_nPackedMin = 0x0; // uint32_t
    public const nint m_nPackedMax = 0x4; // uint32_t
}

public static class TestResource_t {
    public const nint m_name = 0x0; // CUtlString
}

public static class VariableInfo_t {
    public const nint m_name = 0x0; // CUtlString
    public const nint m_nameToken = 0x8; // CUtlStringToken
    public const nint m_nIndex = 0xC; // FuseVariableIndex_t
    public const nint m_nNumComponents = 0xE; // uint8_t
    public const nint m_eVarType = 0xF; // FuseVariableType_t
    public const nint m_eAccess = 0x10; // FuseVariableAccess_t
}
```

`SDK/resourcesystem.dll.hpp`:

```hpp
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.135170700 UTC
 */

#pragma once

#include <cstddef>

namespace AABB_t {
    constexpr std::ptrdiff_t m_vMinBounds = 0x0; // Vector
    constexpr std::ptrdiff_t m_vMaxBounds = 0xC; // Vector
}

namespace CFuseProgram {
    constexpr std::ptrdiff_t m_programBuffer = 0x0; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_variablesRead = 0x18; // CUtlVector<FuseVariableIndex_t>
    constexpr std::ptrdiff_t m_variablesWritten = 0x30; // CUtlVector<FuseVariableIndex_t>
    constexpr std::ptrdiff_t m_nMaxTempVarsUsed = 0x48; // int32_t
}

namespace CFuseSymbolTable {
    constexpr std::ptrdiff_t m_constants = 0x0; // CUtlVector<ConstantInfo_t>
    constexpr std::ptrdiff_t m_variables = 0x18; // CUtlVector<VariableInfo_t>
    constexpr std::ptrdiff_t m_functions = 0x30; // CUtlVector<FunctionInfo_t>
    constexpr std::ptrdiff_t m_constantMap = 0x48; // CUtlHashtable<CUtlStringToken,int32_t>
    constexpr std::ptrdiff_t m_variableMap = 0x68; // CUtlHashtable<CUtlStringToken,int32_t>
    constexpr std::ptrdiff_t m_functionMap = 0x88; // CUtlHashtable<CUtlStringToken,int32_t>
}

namespace ConstantInfo_t {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nameToken = 0x8; // CUtlStringToken
    constexpr std::ptrdiff_t m_flValue = 0xC; // float
}

namespace FourQuaternions {
    constexpr std::ptrdiff_t x = 0x0; // fltx4
    constexpr std::ptrdiff_t y = 0x10; // fltx4
    constexpr std::ptrdiff_t z = 0x20; // fltx4
    constexpr std::ptrdiff_t w = 0x30; // fltx4
}

namespace FunctionInfo_t {
    constexpr std::ptrdiff_t m_name = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_nameToken = 0x10; // CUtlStringToken
    constexpr std::ptrdiff_t m_nParamCount = 0x14; // int32_t
    constexpr std::ptrdiff_t m_nIndex = 0x18; // FuseFunctionIndex_t
    constexpr std::ptrdiff_t m_bIsPure = 0x1A; // bool
}

namespace FuseFunctionIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // uint16_t
}

namespace FuseVariableIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // uint16_t
}

namespace ManifestTestResource_t {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_child = 0x8; // CStrongHandle<InfoForResourceTypeManifestTestResource_t>
}

namespace PackedAABB_t {
    constexpr std::ptrdiff_t m_nPackedMin = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_nPackedMax = 0x4; // uint32_t
}

namespace TestResource_t {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
}

namespace VariableInfo_t {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nameToken = 0x8; // CUtlStringToken
    constexpr std::ptrdiff_t m_nIndex = 0xC; // FuseVariableIndex_t
    constexpr std::ptrdiff_t m_nNumComponents = 0xE; // uint8_t
    constexpr std::ptrdiff_t m_eVarType = 0xF; // FuseVariableType_t
    constexpr std::ptrdiff_t m_eAccess = 0x10; // FuseVariableAccess_t
}
```

`SDK/resourcesystem.dll.json`:

```json
{
  "AABB_t": {
    "m_vMaxBounds": 12,
    "m_vMinBounds": 0
  },
  "CFuseProgram": {
    "m_nMaxTempVarsUsed": 72,
    "m_programBuffer": 0,
    "m_variablesRead": 24,
    "m_variablesWritten": 48
  },
  "CFuseSymbolTable": {
    "m_constantMap": 72,
    "m_constants": 0,
    "m_functionMap": 136,
    "m_functions": 48,
    "m_variableMap": 104,
    "m_variables": 24
  },
  "ConstantInfo_t": {
    "m_flValue": 12,
    "m_name": 0,
    "m_nameToken": 8
  },
  "FourQuaternions": {
    "w": 48,
    "x": 0,
    "y": 16,
    "z": 32
  },
  "FunctionInfo_t": {
    "m_bIsPure": 26,
    "m_nIndex": 24,
    "m_nParamCount": 20,
    "m_name": 8,
    "m_nameToken": 16
  },
  "FuseFunctionIndex_t": {
    "m_Value": 0
  },
  "FuseVariableIndex_t": {
    "m_Value": 0
  },
  "ManifestTestResource_t": {
    "m_child": 8,
    "m_name": 0
  },
  "PackedAABB_t": {
    "m_nPackedMax": 4,
    "m_nPackedMin": 0
  },
  "TestResource_t": {
    "m_name": 0
  },
  "VariableInfo_t": {
    "m_eAccess": 16,
    "m_eVarType": 15,
    "m_nIndex": 12,
    "m_nNumComponents": 14,
    "m_name": 0,
    "m_nameToken": 8
  }
}
```

`SDK/resourcesystem.dll.py`:

```py
'''
https://github.com/a2x/cs2-dumper
2023-11-23 10:28:25.140862200 UTC
'''

class AABB_t:
    m_vMinBounds = 0x0 # Vector
    m_vMaxBounds = 0xC # Vector

class CFuseProgram:
    m_programBuffer = 0x0 # CUtlVector<uint8_t>
    m_variablesRead = 0x18 # CUtlVector<FuseVariableIndex_t>
    m_variablesWritten = 0x30 # CUtlVector<FuseVariableIndex_t>
    m_nMaxTempVarsUsed = 0x48 # int32_t

class CFuseSymbolTable:
    m_constants = 0x0 # CUtlVector<ConstantInfo_t>
    m_variables = 0x18 # CUtlVector<VariableInfo_t>
    m_functions = 0x30 # CUtlVector<FunctionInfo_t>
    m_constantMap = 0x48 # CUtlHashtable<CUtlStringToken,int32_t>
    m_variableMap = 0x68 # CUtlHashtable<CUtlStringToken,int32_t>
    m_functionMap = 0x88 # CUtlHashtable<CUtlStringToken,int32_t>

class ConstantInfo_t:
    m_name = 0x0 # CUtlString
    m_nameToken = 0x8 # CUtlStringToken
    m_flValue = 0xC # float

class FourQuaternions:
    x = 0x0 # fltx4
    y = 0x10 # fltx4
    z = 0x20 # fltx4
    w = 0x30 # fltx4

class FunctionInfo_t:
    m_name = 0x8 # CUtlString
    m_nameToken = 0x10 # CUtlStringToken
    m_nParamCount = 0x14 # int32_t
    m_nIndex = 0x18 # FuseFunctionIndex_t
    m_bIsPure = 0x1A # bool

class FuseFunctionIndex_t:
    m_Value = 0x0 # uint16_t

class FuseVariableIndex_t:
    m_Value = 0x0 # uint16_t

class ManifestTestResource_t:
    m_name = 0x0 # CUtlString
    m_child = 0x8 # CStrongHandle<InfoForResourceTypeManifestTestResource_t>

class PackedAABB_t:
    m_nPackedMin = 0x0 # uint32_t
    m_nPackedMax = 0x4 # uint32_t

class TestResource_t:
    m_name = 0x0 # CUtlString

class VariableInfo_t:
    m_name = 0x0 # CUtlString
    m_nameToken = 0x8 # CUtlStringToken
    m_nIndex = 0xC # FuseVariableIndex_t
    m_nNumComponents = 0xE # uint8_t
    m_eVarType = 0xF # FuseVariableType_t
    m_eAccess = 0x10 # FuseVariableAccess_t

```

`SDK/resourcesystem.dll.rs`:

```rs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.143453 UTC
 */

#![allow(non_snake_case, non_upper_case_globals)]

pub mod AABB_t {
    pub const m_vMinBounds: usize = 0x0; // Vector
    pub const m_vMaxBounds: usize = 0xC; // Vector
}

pub mod CFuseProgram {
    pub const m_programBuffer: usize = 0x0; // CUtlVector<uint8_t>
    pub const m_variablesRead: usize = 0x18; // CUtlVector<FuseVariableIndex_t>
    pub const m_variablesWritten: usize = 0x30; // CUtlVector<FuseVariableIndex_t>
    pub const m_nMaxTempVarsUsed: usize = 0x48; // int32_t
}

pub mod CFuseSymbolTable {
    pub const m_constants: usize = 0x0; // CUtlVector<ConstantInfo_t>
    pub const m_variables: usize = 0x18; // CUtlVector<VariableInfo_t>
    pub const m_functions: usize = 0x30; // CUtlVector<FunctionInfo_t>
    pub const m_constantMap: usize = 0x48; // CUtlHashtable<CUtlStringToken,int32_t>
    pub const m_variableMap: usize = 0x68; // CUtlHashtable<CUtlStringToken,int32_t>
    pub const m_functionMap: usize = 0x88; // CUtlHashtable<CUtlStringToken,int32_t>
}

pub mod ConstantInfo_t {
    pub const m_name: usize = 0x0; // CUtlString
    pub const m_nameToken: usize = 0x8; // CUtlStringToken
    pub const m_flValue: usize = 0xC; // float
}

pub mod FourQuaternions {
    pub const x: usize = 0x0; // fltx4
    pub const y: usize = 0x10; // fltx4
    pub const z: usize = 0x20; // fltx4
    pub const w: usize = 0x30; // fltx4
}

pub mod FunctionInfo_t {
    pub const m_name: usize = 0x8; // CUtlString
    pub const m_nameToken: usize = 0x10; // CUtlStringToken
    pub const m_nParamCount: usize = 0x14; // int32_t
    pub const m_nIndex: usize = 0x18; // FuseFunctionIndex_t
    pub const m_bIsPure: usize = 0x1A; // bool
}

pub mod FuseFunctionIndex_t {
    pub const m_Value: usize = 0x0; // uint16_t
}

pub mod FuseVariableIndex_t {
    pub const m_Value: usize = 0x0; // uint16_t
}

pub mod ManifestTestResource_t {
    pub const m_name: usize = 0x0; // CUtlString
    pub const m_child: usize = 0x8; // CStrongHandle<InfoForResourceTypeManifestTestResource_t>
}

pub mod PackedAABB_t {
    pub const m_nPackedMin: usize = 0x0; // uint32_t
    pub const m_nPackedMax: usize = 0x4; // uint32_t
}

pub mod TestResource_t {
    pub const m_name: usize = 0x0; // CUtlString
}

pub mod VariableInfo_t {
    pub const m_name: usize = 0x0; // CUtlString
    pub const m_nameToken: usize = 0x8; // CUtlStringToken
    pub const m_nIndex: usize = 0xC; // FuseVariableIndex_t
    pub const m_nNumComponents: usize = 0xE; // uint8_t
    pub const m_eVarType: usize = 0xF; // FuseVariableType_t
    pub const m_eAccess: usize = 0x10; // FuseVariableAccess_t
}
```

`SDK/scenesystem.dll.cs`:

```cs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.578491300 UTC
 */

public static class CSSDSEndFrameViewInfo {
    public const nint m_nViewId = 0x0; // uint64_t
    public const nint m_ViewName = 0x8; // CUtlString
}

public static class CSSDSMsg_EndFrame {
    public const nint m_Views = 0x0; // CUtlVector<CSSDSEndFrameViewInfo>
}

public static class CSSDSMsg_LayerBase {
    public const nint m_viewId = 0x0; // SceneViewId_t
    public const nint m_ViewName = 0x10; // CUtlString
    public const nint m_nLayerIndex = 0x18; // int32_t
    public const nint m_nLayerId = 0x20; // uint64_t
    public const nint m_LayerName = 0x28; // CUtlString
    public const nint m_displayText = 0x30; // CUtlString
}

public static class CSSDSMsg_ViewRender {
    public const nint m_viewId = 0x0; // SceneViewId_t
    public const nint m_ViewName = 0x10; // CUtlString
}

public static class CSSDSMsg_ViewTarget {
    public const nint m_Name = 0x0; // CUtlString
    public const nint m_TextureId = 0x8; // uint64_t
    public const nint m_nWidth = 0x10; // int32_t
    public const nint m_nHeight = 0x14; // int32_t
    public const nint m_nRequestedWidth = 0x18; // int32_t
    public const nint m_nRequestedHeight = 0x1C; // int32_t
    public const nint m_nNumMipLevels = 0x20; // int32_t
    public const nint m_nDepth = 0x24; // int32_t
    public const nint m_nMultisampleNumSamples = 0x28; // int32_t
    public const nint m_nFormat = 0x2C; // int32_t
}

public static class CSSDSMsg_ViewTargetList {
    public const nint m_viewId = 0x0; // SceneViewId_t
    public const nint m_ViewName = 0x10; // CUtlString
    public const nint m_Targets = 0x18; // CUtlVector<CSSDSMsg_ViewTarget>
}

public static class SceneViewId_t {
    public const nint m_nViewId = 0x0; // uint64_t
    public const nint m_nFrameCount = 0x8; // uint64_t
}
```

`SDK/scenesystem.dll.hpp`:

```hpp
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.576844 UTC
 */

#pragma once

#include <cstddef>

namespace CSSDSEndFrameViewInfo {
    constexpr std::ptrdiff_t m_nViewId = 0x0; // uint64_t
    constexpr std::ptrdiff_t m_ViewName = 0x8; // CUtlString
}

namespace CSSDSMsg_EndFrame {
    constexpr std::ptrdiff_t m_Views = 0x0; // CUtlVector<CSSDSEndFrameViewInfo>
}

namespace CSSDSMsg_LayerBase {
    constexpr std::ptrdiff_t m_viewId = 0x0; // SceneViewId_t
    constexpr std::ptrdiff_t m_ViewName = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_nLayerIndex = 0x18; // int32_t
    constexpr std::ptrdiff_t m_nLayerId = 0x20; // uint64_t
    constexpr std::ptrdiff_t m_LayerName = 0x28; // CUtlString
    constexpr std::ptrdiff_t m_displayText = 0x30; // CUtlString
}

namespace CSSDSMsg_ViewRender {
    constexpr std::ptrdiff_t m_viewId = 0x0; // SceneViewId_t
    constexpr std::ptrdiff_t m_ViewName = 0x10; // CUtlString
}

namespace CSSDSMsg_ViewTarget {
    constexpr std::ptrdiff_t m_Name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_TextureId = 0x8; // uint64_t
    constexpr std::ptrdiff_t m_nWidth = 0x10; // int32_t
    constexpr std::ptrdiff_t m_nHeight = 0x14; // int32_t
    constexpr std::ptrdiff_t m_nRequestedWidth = 0x18; // int32_t
    constexpr std::ptrdiff_t m_nRequestedHeight = 0x1C; // int32_t
    constexpr std::ptrdiff_t m_nNumMipLevels = 0x20; // int32_t
    constexpr std::ptrdiff_t m_nDepth = 0x24; // int32_t
    constexpr std::ptrdiff_t m_nMultisampleNumSamples = 0x28; // int32_t
    constexpr std::ptrdiff_t m_nFormat = 0x2C; // int32_t
}

namespace CSSDSMsg_ViewTargetList {
    constexpr std::ptrdiff_t m_viewId = 0x0; // SceneViewId_t
    constexpr std::ptrdiff_t m_ViewName = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_Targets = 0x18; // CUtlVector<CSSDSMsg_ViewTarget>
}

namespace SceneViewId_t {
    constexpr std::ptrdiff_t m_nViewId = 0x0; // uint64_t
    constexpr std::ptrdiff_t m_nFrameCount = 0x8; // uint64_t
}
```

`SDK/scenesystem.dll.json`:

```json
{
  "CSSDSEndFrameViewInfo": {
    "m_ViewName": 8,
    "m_nViewId": 0
  },
  "CSSDSMsg_EndFrame": {
    "m_Views": 0
  },
  "CSSDSMsg_LayerBase": {
    "m_LayerName": 40,
    "m_ViewName": 16,
    "m_displayText": 48,
    "m_nLayerId": 32,
    "m_nLayerIndex": 24,
    "m_viewId": 0
  },
  "CSSDSMsg_ViewRender": {
    "m_ViewName": 16,
    "m_viewId": 0
  },
  "CSSDSMsg_ViewTarget": {
    "m_Name": 0,
    "m_TextureId": 8,
    "m_nDepth": 36,
    "m_nFormat": 44,
    "m_nHeight": 20,
    "m_nMultisampleNumSamples": 40,
    "m_nNumMipLevels": 32,
    "m_nRequestedHeight": 28,
    "m_nRequestedWidth": 24,
    "m_nWidth": 16
  },
  "CSSDSMsg_ViewTargetList": {
    "m_Targets": 24,
    "m_ViewName": 16,
    "m_viewId": 0
  },
  "SceneViewId_t": {
    "m_nFrameCount": 8,
    "m_nViewId": 0
  }
}
```

`SDK/scenesystem.dll.py`:

```py
'''
https://github.com/a2x/cs2-dumper
2023-11-23 10:28:25.580414100 UTC
'''

class CSSDSEndFrameViewInfo:
    m_nViewId = 0x0 # uint64_t
    m_ViewName = 0x8 # CUtlString

class CSSDSMsg_EndFrame:
    m_Views = 0x0 # CUtlVector<CSSDSEndFrameViewInfo>

class CSSDSMsg_LayerBase:
    m_viewId = 0x0 # SceneViewId_t
    m_ViewName = 0x10 # CUtlString
    m_nLayerIndex = 0x18 # int32_t
    m_nLayerId = 0x20 # uint64_t
    m_LayerName = 0x28 # CUtlString
    m_displayText = 0x30 # CUtlString

class CSSDSMsg_ViewRender:
    m_viewId = 0x0 # SceneViewId_t
    m_ViewName = 0x10 # CUtlString

class CSSDSMsg_ViewTarget:
    m_Name = 0x0 # CUtlString
    m_TextureId = 0x8 # uint64_t
    m_nWidth = 0x10 # int32_t
    m_nHeight = 0x14 # int32_t
    m_nRequestedWidth = 0x18 # int32_t
    m_nRequestedHeight = 0x1C # int32_t
    m_nNumMipLevels = 0x20 # int32_t
    m_nDepth = 0x24 # int32_t
    m_nMultisampleNumSamples = 0x28 # int32_t
    m_nFormat = 0x2C # int32_t

class CSSDSMsg_ViewTargetList:
    m_viewId = 0x0 # SceneViewId_t
    m_ViewName = 0x10 # CUtlString
    m_Targets = 0x18 # CUtlVector<CSSDSMsg_ViewTarget>

class SceneViewId_t:
    m_nViewId = 0x0 # uint64_t
    m_nFrameCount = 0x8 # uint64_t

```

`SDK/scenesystem.dll.rs`:

```rs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.582423200 UTC
 */

#![allow(non_snake_case, non_upper_case_globals)]

pub mod CSSDSEndFrameViewInfo {
    pub const m_nViewId: usize = 0x0; // uint64_t
    pub const m_ViewName: usize = 0x8; // CUtlString
}

pub mod CSSDSMsg_EndFrame {
    pub const m_Views: usize = 0x0; // CUtlVector<CSSDSEndFrameViewInfo>
}

pub mod CSSDSMsg_LayerBase {
    pub const m_viewId: usize = 0x0; // SceneViewId_t
    pub const m_ViewName: usize = 0x10; // CUtlString
    pub const m_nLayerIndex: usize = 0x18; // int32_t
    pub const m_nLayerId: usize = 0x20; // uint64_t
    pub const m_LayerName: usize = 0x28; // CUtlString
    pub const m_displayText: usize = 0x30; // CUtlString
}

pub mod CSSDSMsg_ViewRender {
    pub const m_viewId: usize = 0x0; // SceneViewId_t
    pub const m_ViewName: usize = 0x10; // CUtlString
}

pub mod CSSDSMsg_ViewTarget {
    pub const m_Name: usize = 0x0; // CUtlString
    pub const m_TextureId: usize = 0x8; // uint64_t
    pub const m_nWidth: usize = 0x10; // int32_t
    pub const m_nHeight: usize = 0x14; // int32_t
    pub const m_nRequestedWidth: usize = 0x18; // int32_t
    pub const m_nRequestedHeight: usize = 0x1C; // int32_t
    pub const m_nNumMipLevels: usize = 0x20; // int32_t
    pub const m_nDepth: usize = 0x24; // int32_t
    pub const m_nMultisampleNumSamples: usize = 0x28; // int32_t
    pub const m_nFormat: usize = 0x2C; // int32_t
}

pub mod CSSDSMsg_ViewTargetList {
    pub const m_viewId: usize = 0x0; // SceneViewId_t
    pub const m_ViewName: usize = 0x10; // CUtlString
    pub const m_Targets: usize = 0x18; // CUtlVector<CSSDSMsg_ViewTarget>
}

pub mod SceneViewId_t {
    pub const m_nViewId: usize = 0x0; // uint64_t
    pub const m_nFrameCount: usize = 0x8; // uint64_t
}
```

`SDK/schemasystem.dll.cs`:

```cs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.125726500 UTC
 */

public static class CExampleSchemaVData_Monomorphic {
    public const nint m_nExample1 = 0x0; // int32_t
    public const nint m_nExample2 = 0x4; // int32_t
}

public static class CExampleSchemaVData_PolymorphicBase {
    public const nint m_nBase = 0x8; // int32_t
}

public static class CExampleSchemaVData_PolymorphicDerivedA {
    public const nint m_nDerivedA = 0x10; // int32_t
}

public static class CExampleSchemaVData_PolymorphicDerivedB {
    public const nint m_nDerivedB = 0x10; // int32_t
}

public static class CSchemaSystemInternalRegistration {
    public const nint m_Vector2D = 0x0; // Vector2D
    public const nint m_Vector = 0x8; // Vector
    public const nint m_VectorAligned = 0x20; // VectorAligned
    public const nint m_Quaternion = 0x30; // Quaternion
    public const nint m_QAngle = 0x40; // QAngle
    public const nint m_RotationVector = 0x4C; // RotationVector
    public const nint m_RadianEuler = 0x58; // RadianEuler
    public const nint m_DegreeEuler = 0x64; // DegreeEuler
    public const nint m_QuaternionStorage = 0x70; // QuaternionStorage
    public const nint m_matrix3x4_t = 0x80; // matrix3x4_t
    public const nint m_matrix3x4a_t = 0xB0; // matrix3x4a_t
    public const nint m_Color = 0xE0; // Color
    public const nint m_Vector4D = 0xE4; // Vector4D
    public const nint m_CTransform = 0x100; // CTransform
    public const nint m_pKeyValues = 0x120; // KeyValues*
    public const nint m_CUtlBinaryBlock = 0x128; // CUtlBinaryBlock
    public const nint m_CUtlString = 0x140; // CUtlString
    public const nint m_CUtlSymbol = 0x148; // CUtlSymbol
    public const nint m_stringToken = 0x14C; // CUtlStringToken
    public const nint m_stringTokenWithStorage = 0x150; // CUtlStringTokenWithStorage
    public const nint m_ResourceTypes = 0x168; // CResourceArray<CResourcePointer<CResourceString>>
    public const nint m_KV3 = 0x170; // KeyValues3
}

public static class ResourceId_t {
    public const nint m_Value = 0x0; // uint64_t
}
```

`SDK/schemasystem.dll.hpp`:

```hpp
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.123909500 UTC
 */

#pragma once

#include <cstddef>

namespace CExampleSchemaVData_Monomorphic {
    constexpr std::ptrdiff_t m_nExample1 = 0x0; // int32_t
    constexpr std::ptrdiff_t m_nExample2 = 0x4; // int32_t
}

namespace CExampleSchemaVData_PolymorphicBase {
    constexpr std::ptrdiff_t m_nBase = 0x8; // int32_t
}

namespace CExampleSchemaVData_PolymorphicDerivedA {
    constexpr std::ptrdiff_t m_nDerivedA = 0x10; // int32_t
}

namespace CExampleSchemaVData_PolymorphicDerivedB {
    constexpr std::ptrdiff_t m_nDerivedB = 0x10; // int32_t
}

namespace CSchemaSystemInternalRegistration {
    constexpr std::ptrdiff_t m_Vector2D = 0x0; // Vector2D
    constexpr std::ptrdiff_t m_Vector = 0x8; // Vector
    constexpr std::ptrdiff_t m_VectorAligned = 0x20; // VectorAligned
    constexpr std::ptrdiff_t m_Quaternion = 0x30; // Quaternion
    constexpr std::ptrdiff_t m_QAngle = 0x40; // QAngle
    constexpr std::ptrdiff_t m_RotationVector = 0x4C; // RotationVector
    constexpr std::ptrdiff_t m_RadianEuler = 0x58; // RadianEuler
    constexpr std::ptrdiff_t m_DegreeEuler = 0x64; // DegreeEuler
    constexpr std::ptrdiff_t m_QuaternionStorage = 0x70; // QuaternionStorage
    constexpr std::ptrdiff_t m_matrix3x4_t = 0x80; // matrix3x4_t
    constexpr std::ptrdiff_t m_matrix3x4a_t = 0xB0; // matrix3x4a_t
    constexpr std::ptrdiff_t m_Color = 0xE0; // Color
    constexpr std::ptrdiff_t m_Vector4D = 0xE4; // Vector4D
    constexpr std::ptrdiff_t m_CTransform = 0x100; // CTransform
    constexpr std::ptrdiff_t m_pKeyValues = 0x120; // KeyValues*
    constexpr std::ptrdiff_t m_CUtlBinaryBlock = 0x128; // CUtlBinaryBlock
    constexpr std::ptrdiff_t m_CUtlString = 0x140; // CUtlString
    constexpr std::ptrdiff_t m_CUtlSymbol = 0x148; // CUtlSymbol
    constexpr std::ptrdiff_t m_stringToken = 0x14C; // CUtlStringToken
    constexpr std::ptrdiff_t m_stringTokenWithStorage = 0x150; // CUtlStringTokenWithStorage
    constexpr std::ptrdiff_t m_ResourceTypes = 0x168; // CResourceArray<CResourcePointer<CResourceString>>
    constexpr std::ptrdiff_t m_KV3 = 0x170; // KeyValues3
}

namespace ResourceId_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // uint64_t
}
```

`SDK/schemasystem.dll.json`:

```json
{
  "CExampleSchemaVData_Monomorphic": {
    "m_nExample1": 0,
    "m_nExample2": 4
  },
  "CExampleSchemaVData_PolymorphicBase": {
    "m_nBase": 8
  },
  "CExampleSchemaVData_PolymorphicDerivedA": {
    "m_nDerivedA": 16
  },
  "CExampleSchemaVData_PolymorphicDerivedB": {
    "m_nDerivedB": 16
  },
  "CSchemaSystemInternalRegistration": {
    "m_CTransform": 256,
    "m_CUtlBinaryBlock": 296,
    "m_CUtlString": 320,
    "m_CUtlSymbol": 328,
    "m_Color": 224,
    "m_DegreeEuler": 100,
    "m_KV3": 368,
    "m_QAngle": 64,
    "m_Quaternion": 48,
    "m_QuaternionStorage": 112,
    "m_RadianEuler": 88,
    "m_ResourceTypes": 360,
    "m_RotationVector": 76,
    "m_Vector": 8,
    "m_Vector2D": 0,
    "m_Vector4D": 228,
    "m_VectorAligned": 32,
    "m_matrix3x4_t": 128,
    "m_matrix3x4a_t": 176,
    "m_pKeyValues": 288,
    "m_stringToken": 332,
    "m_stringTokenWithStorage": 336
  },
  "ResourceId_t": {
    "m_Value": 0
  }
}
```

`SDK/schemasystem.dll.py`:

```py
'''
https://github.com/a2x/cs2-dumper
2023-11-23 10:28:25.127700600 UTC
'''

class CExampleSchemaVData_Monomorphic:
    m_nExample1 = 0x0 # int32_t
    m_nExample2 = 0x4 # int32_t

class CExampleSchemaVData_PolymorphicBase:
    m_nBase = 0x8 # int32_t

class CExampleSchemaVData_PolymorphicDerivedA:
    m_nDerivedA = 0x10 # int32_t

class CExampleSchemaVData_PolymorphicDerivedB:
    m_nDerivedB = 0x10 # int32_t

class CSchemaSystemInternalRegistration:
    m_Vector2D = 0x0 # Vector2D
    m_Vector = 0x8 # Vector
    m_VectorAligned = 0x20 # VectorAligned
    m_Quaternion = 0x30 # Quaternion
    m_QAngle = 0x40 # QAngle
    m_RotationVector = 0x4C # RotationVector
    m_RadianEuler = 0x58 # RadianEuler
    m_DegreeEuler = 0x64 # DegreeEuler
    m_QuaternionStorage = 0x70 # QuaternionStorage
    m_matrix3x4_t = 0x80 # matrix3x4_t
    m_matrix3x4a_t = 0xB0 # matrix3x4a_t
    m_Color = 0xE0 # Color
    m_Vector4D = 0xE4 # Vector4D
    m_CTransform = 0x100 # CTransform
    m_pKeyValues = 0x120 # KeyValues*
    m_CUtlBinaryBlock = 0x128 # CUtlBinaryBlock
    m_CUtlString = 0x140 # CUtlString
    m_CUtlSymbol = 0x148 # CUtlSymbol
    m_stringToken = 0x14C # CUtlStringToken
    m_stringTokenWithStorage = 0x150 # CUtlStringTokenWithStorage
    m_ResourceTypes = 0x168 # CResourceArray<CResourcePointer<CResourceString>>
    m_KV3 = 0x170 # KeyValues3

class ResourceId_t:
    m_Value = 0x0 # uint64_t

```

`SDK/schemasystem.dll.rs`:

```rs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.129472 UTC
 */

#![allow(non_snake_case, non_upper_case_globals)]

pub mod CExampleSchemaVData_Monomorphic {
    pub const m_nExample1: usize = 0x0; // int32_t
    pub const m_nExample2: usize = 0x4; // int32_t
}

pub mod CExampleSchemaVData_PolymorphicBase {
    pub const m_nBase: usize = 0x8; // int32_t
}

pub mod CExampleSchemaVData_PolymorphicDerivedA {
    pub const m_nDerivedA: usize = 0x10; // int32_t
}

pub mod CExampleSchemaVData_PolymorphicDerivedB {
    pub const m_nDerivedB: usize = 0x10; // int32_t
}

pub mod CSchemaSystemInternalRegistration {
    pub const m_Vector2D: usize = 0x0; // Vector2D
    pub const m_Vector: usize = 0x8; // Vector
    pub const m_VectorAligned: usize = 0x20; // VectorAligned
    pub const m_Quaternion: usize = 0x30; // Quaternion
    pub const m_QAngle: usize = 0x40; // QAngle
    pub const m_RotationVector: usize = 0x4C; // RotationVector
    pub const m_RadianEuler: usize = 0x58; // RadianEuler
    pub const m_DegreeEuler: usize = 0x64; // DegreeEuler
    pub const m_QuaternionStorage: usize = 0x70; // QuaternionStorage
    pub const m_matrix3x4_t: usize = 0x80; // matrix3x4_t
    pub const m_matrix3x4a_t: usize = 0xB0; // matrix3x4a_t
    pub const m_Color: usize = 0xE0; // Color
    pub const m_Vector4D: usize = 0xE4; // Vector4D
    pub const m_CTransform: usize = 0x100; // CTransform
    pub const m_pKeyValues: usize = 0x120; // KeyValues*
    pub const m_CUtlBinaryBlock: usize = 0x128; // CUtlBinaryBlock
    pub const m_CUtlString: usize = 0x140; // CUtlString
    pub const m_CUtlSymbol: usize = 0x148; // CUtlSymbol
    pub const m_stringToken: usize = 0x14C; // CUtlStringToken
    pub const m_stringTokenWithStorage: usize = 0x150; // CUtlStringTokenWithStorage
    pub const m_ResourceTypes: usize = 0x168; // CResourceArray<CResourcePointer<CResourceString>>
    pub const m_KV3: usize = 0x170; // KeyValues3
}

pub mod ResourceId_t {
    pub const m_Value: usize = 0x0; // uint64_t
}
```

`SDK/server.dll.cs`:

```cs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:26.428833100 UTC
 */

public static class ActiveModelConfig_t {
    public const nint m_Handle = 0x28; // ModelConfigHandle_t
    public const nint m_Name = 0x30; // CUtlSymbolLarge
    public const nint m_AssociatedEntities = 0x38; // CNetworkUtlVectorBase<CHandle<CBaseModelEntity>>
    public const nint m_AssociatedEntityNames = 0x50; // CNetworkUtlVectorBase<CUtlSymbolLarge>
}

public static class AmmoIndex_t {
    public const nint m_Value = 0x0; // int8_t
}

public static class AmmoTypeInfo_t {
    public const nint m_nMaxCarry = 0x10; // int32_t
    public const nint m_nSplashSize = 0x1C; // CRangeInt
    public const nint m_nFlags = 0x24; // AmmoFlags_t
    public const nint m_flMass = 0x28; // float
    public const nint m_flSpeed = 0x2C; // CRangeFloat
}

public static class AnimationUpdateListHandle_t {
    public const nint m_Value = 0x0; // uint32_t
}

public static class CAISound {
    public const nint m_iSoundType = 0x4B0; // int32_t
    public const nint m_iSoundContext = 0x4B4; // int32_t
    public const nint m_iVolume = 0x4B8; // int32_t
    public const nint m_iSoundIndex = 0x4BC; // int32_t
    public const nint m_flDuration = 0x4C0; // float
    public const nint m_iszProxyEntityName = 0x4C8; // CUtlSymbolLarge
}

public static class CAI_ChangeHintGroup {
    public const nint m_iSearchType = 0x4B0; // int32_t
    public const nint m_strSearchName = 0x4B8; // CUtlSymbolLarge
    public const nint m_strNewHintGroup = 0x4C0; // CUtlSymbolLarge
    public const nint m_flRadius = 0x4C8; // float
}

public static class CAI_ChangeTarget {
    public const nint m_iszNewTarget = 0x4B0; // CUtlSymbolLarge
}

public static class CAI_Expresser {
    public const nint m_flStopTalkTime = 0x38; // GameTime_t
    public const nint m_flStopTalkTimeWithoutDelay = 0x3C; // GameTime_t
    public const nint m_flBlockedTalkTime = 0x40; // GameTime_t
    public const nint m_voicePitch = 0x44; // int32_t
    public const nint m_flLastTimeAcceptedSpeak = 0x48; // GameTime_t
    public const nint m_bAllowSpeakingInterrupts = 0x4C; // bool
    public const nint m_bConsiderSceneInvolvementAsSpeech = 0x4D; // bool
    public const nint m_nLastSpokenPriority = 0x50; // int32_t
    public const nint m_pOuter = 0x58; // CBaseFlex*
}

public static class CAI_ExpresserWithFollowup {
    public const nint m_pPostponedFollowup = 0x60; // ResponseFollowup*
}

public static class CAmbientGeneric {
    public const nint m_radius = 0x4B0; // float
    public const nint m_flMaxRadius = 0x4B4; // float
    public const nint m_iSoundLevel = 0x4B8; // soundlevel_t
    public const nint m_dpv = 0x4BC; // dynpitchvol_t
    public const nint m_fActive = 0x520; // bool
    public const nint m_fLooping = 0x521; // bool
    public const nint m_iszSound = 0x528; // CUtlSymbolLarge
    public const nint m_sSourceEntName = 0x530; // CUtlSymbolLarge
    public const nint m_hSoundSource = 0x538; // CHandle<CBaseEntity>
    public const nint m_nSoundSourceEntIndex = 0x53C; // CEntityIndex
}

public static class CAnimGraphNetworkedVariables {
    public const nint m_PredNetBoolVariables = 0x8; // CNetworkUtlVectorBase<uint32_t>
    public const nint m_PredNetByteVariables = 0x20; // CNetworkUtlVectorBase<uint8_t>
    public const nint m_PredNetUInt16Variables = 0x38; // CNetworkUtlVectorBase<uint16_t>
    public const nint m_PredNetIntVariables = 0x50; // CNetworkUtlVectorBase<int32_t>
    public const nint m_PredNetUInt32Variables = 0x68; // CNetworkUtlVectorBase<uint32_t>
    public const nint m_PredNetUInt64Variables = 0x80; // CNetworkUtlVectorBase<uint64_t>
    public const nint m_PredNetFloatVariables = 0x98; // CNetworkUtlVectorBase<float>
    public const nint m_PredNetVectorVariables = 0xB0; // CNetworkUtlVectorBase<Vector>
    public const nint m_PredNetQuaternionVariables = 0xC8; // CNetworkUtlVectorBase<Quaternion>
    public const nint m_OwnerOnlyPredNetBoolVariables = 0xE0; // CNetworkUtlVectorBase<uint32_t>
    public const nint m_OwnerOnlyPredNetByteVariables = 0xF8; // CNetworkUtlVectorBase<uint8_t>
    public const nint m_OwnerOnlyPredNetUInt16Variables = 0x110; // CNetworkUtlVectorBase<uint16_t>
    public const nint m_OwnerOnlyPredNetIntVariables = 0x128; // CNetworkUtlVectorBase<int32_t>
    public const nint m_OwnerOnlyPredNetUInt32Variables = 0x140; // CNetworkUtlVectorBase<uint32_t>
    public const nint m_OwnerOnlyPredNetUInt64Variables = 0x158; // CNetworkUtlVectorBase<uint64_t>
    public const nint m_OwnerOnlyPredNetFloatVariables = 0x170; // CNetworkUtlVectorBase<float>
    public const nint m_OwnerOnlyPredNetVectorVariables = 0x188; // CNetworkUtlVectorBase<Vector>
    public const nint m_OwnerOnlyPredNetQuaternionVariables = 0x1A0; // CNetworkUtlVectorBase<Quaternion>
    public const nint m_nBoolVariablesCount = 0x1B8; // int32_t
    public const nint m_nOwnerOnlyBoolVariablesCount = 0x1BC; // int32_t
    public const nint m_nRandomSeedOffset = 0x1C0; // int32_t
    public const nint m_flLastTeleportTime = 0x1C4; // float
}

public static class CAnimGraphTagRef {
    public const nint m_nTagIndex = 0x0; // int32_t
    public const nint m_tagName = 0x10; // CGlobalSymbol
}

public static class CAttributeContainer {
    public const nint m_Item = 0x50; // CEconItemView
}

public static class CAttributeList {
    public const nint m_Attributes = 0x8; // CUtlVectorEmbeddedNetworkVar<CEconItemAttribute>
    public const nint m_pManager = 0x58; // CAttributeManager*
}

public static class CAttributeManager {
    public const nint m_Providers = 0x8; // CUtlVector<CHandle<CBaseEntity>>
    public const nint m_iReapplyProvisionParity = 0x20; // int32_t
    public const nint m_hOuter = 0x24; // CHandle<CBaseEntity>
    public const nint m_bPreventLoopback = 0x28; // bool
    public const nint m_ProviderType = 0x2C; // attributeprovidertypes_t
    public const nint m_CachedResults = 0x30; // CUtlVector<CAttributeManager::cached_attribute_float_t>
}

public static class CAttributeManager_cached_attribute_float_t {
    public const nint flIn = 0x0; // float
    public const nint iAttribHook = 0x8; // CUtlSymbolLarge
    public const nint flOut = 0x10; // float
}

public static class CBarnLight {
    public const nint m_bEnabled = 0x700; // bool
    public const nint m_nColorMode = 0x704; // int32_t
    public const nint m_Color = 0x708; // Color
    public const nint m_flColorTemperature = 0x70C; // float
    public const nint m_flBrightness = 0x710; // float
    public const nint m_flBrightnessScale = 0x714; // float
    public const nint m_nDirectLight = 0x718; // int32_t
    public const nint m_nBakedShadowIndex = 0x71C; // int32_t
    public const nint m_nLuminaireShape = 0x720; // int32_t
    public const nint m_flLuminaireSize = 0x724; // float
    public const nint m_flLuminaireAnisotropy = 0x728; // float
    public const nint m_LightStyleString = 0x730; // CUtlString
    public const nint m_flLightStyleStartTime = 0x738; // GameTime_t
    public const nint m_QueuedLightStyleStrings = 0x740; // CNetworkUtlVectorBase<CUtlString>
    public const nint m_LightStyleEvents = 0x758; // CNetworkUtlVectorBase<CUtlString>
    public const nint m_LightStyleTargets = 0x770; // CNetworkUtlVectorBase<CHandle<CBaseModelEntity>>
    public const nint m_StyleEvent = 0x788; // CEntityIOOutput[4]
    public const nint m_hLightCookie = 0x848; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_flShape = 0x850; // float
    public const nint m_flSoftX = 0x854; // float
    public const nint m_flSoftY = 0x858; // float
    public const nint m_flSkirt = 0x85C; // float
    public const nint m_flSkirtNear = 0x860; // float
    public const nint m_vSizeParams = 0x864; // Vector
    public const nint m_flRange = 0x870; // float
    public const nint m_vShear = 0x874; // Vector
    public const nint m_nBakeSpecularToCubemaps = 0x880; // int32_t
    public const nint m_vBakeSpecularToCubemapsSize = 0x884; // Vector
    public const nint m_nCastShadows = 0x890; // int32_t
    public const nint m_nShadowMapSize = 0x894; // int32_t
    public const nint m_nShadowPriority = 0x898; // int32_t
    public const nint m_bContactShadow = 0x89C; // bool
    public const nint m_nBounceLight = 0x8A0; // int32_t
    public const nint m_flBounceScale = 0x8A4; // float
    public const nint m_flMinRoughness = 0x8A8; // float
    public const nint m_vAlternateColor = 0x8AC; // Vector
    public const nint m_fAlternateColorBrightness = 0x8B8; // float
    public const nint m_nFog = 0x8BC; // int32_t
    public const nint m_flFogStrength = 0x8C0; // float
    public const nint m_nFogShadows = 0x8C4; // int32_t
    public const nint m_flFogScale = 0x8C8; // float
    public const nint m_flFadeSizeStart = 0x8CC; // float
    public const nint m_flFadeSizeEnd = 0x8D0; // float
    public const nint m_flShadowFadeSizeStart = 0x8D4; // float
    public const nint m_flShadowFadeSizeEnd = 0x8D8; // float
    public const nint m_bPrecomputedFieldsValid = 0x8DC; // bool
    public const nint m_vPrecomputedBoundsMins = 0x8E0; // Vector
    public const nint m_vPrecomputedBoundsMaxs = 0x8EC; // Vector
    public const nint m_vPrecomputedOBBOrigin = 0x8F8; // Vector
    public const nint m_vPrecomputedOBBAngles = 0x904; // QAngle
    public const nint m_vPrecomputedOBBExtent = 0x910; // Vector
    public const nint m_bPvsModifyEntity = 0x91C; // bool
}

public static class CBaseAnimGraph {
    public const nint m_bInitiallyPopulateInterpHistory = 0x700; // bool
    public const nint m_bShouldAnimateDuringGameplayPause = 0x701; // bool
    public const nint m_pChoreoServices = 0x708; // IChoreoServices*
    public const nint m_bAnimGraphUpdateEnabled = 0x710; // bool
    public const nint m_flMaxSlopeDistance = 0x714; // float
    public const nint m_vLastSlopeCheckPos = 0x718; // Vector
    public const nint m_bAnimGraphDirty = 0x724; // bool
    public const nint m_vecForce = 0x728; // Vector
    public const nint m_nForceBone = 0x734; // int32_t
    public const nint m_pRagdollPose = 0x748; // PhysicsRagdollPose_t*
    public const nint m_bClientRagdoll = 0x750; // bool
}

public static class CBaseAnimGraphController {
    public const nint m_baseLayer = 0x18; // CNetworkedSequenceOperation
    public const nint m_animGraphNetworkedVars = 0x40; // CAnimGraphNetworkedVariables
    public const nint m_bSequenceFinished = 0x218; // bool
    public const nint m_flLastEventCycle = 0x21C; // float
    public const nint m_flLastEventAnimTime = 0x220; // float
    public const nint m_flPlaybackRate = 0x224; // CNetworkedQuantizedFloat
    public const nint m_flPrevAnimTime = 0x22C; // float
    public const nint m_bClientSideAnimation = 0x230; // bool
    public const nint m_bNetworkedAnimationInputsChanged = 0x231; // bool
    public const nint m_nNewSequenceParity = 0x234; // int32_t
    public const nint m_nResetEventsParity = 0x238; // int32_t
    public const nint m_nAnimLoopMode = 0x23C; // AnimLoopMode_t
    public const nint m_hAnimationUpdate = 0x2DC; // AnimationUpdateListHandle_t
}

public static class CBaseButton {
    public const nint m_angMoveEntitySpace = 0x780; // QAngle
    public const nint m_fStayPushed = 0x78C; // bool
    public const nint m_fRotating = 0x78D; // bool
    public const nint m_ls = 0x790; // locksound_t
    public const nint m_sUseSound = 0x7B0; // CUtlSymbolLarge
    public const nint m_sLockedSound = 0x7B8; // CUtlSymbolLarge
    public const nint m_sUnlockedSound = 0x7C0; // CUtlSymbolLarge
    public const nint m_bLocked = 0x7C8; // bool
    public const nint m_bDisabled = 0x7C9; // bool
    public const nint m_flUseLockedTime = 0x7CC; // GameTime_t
    public const nint m_bSolidBsp = 0x7D0; // bool
    public const nint m_OnDamaged = 0x7D8; // CEntityIOOutput
    public const nint m_OnPressed = 0x800; // CEntityIOOutput
    public const nint m_OnUseLocked = 0x828; // CEntityIOOutput
    public const nint m_OnIn = 0x850; // CEntityIOOutput
    public const nint m_OnOut = 0x878; // CEntityIOOutput
    public const nint m_nState = 0x8A0; // int32_t
    public const nint m_hConstraint = 0x8A4; // CEntityHandle
    public const nint m_hConstraintParent = 0x8A8; // CEntityHandle
    public const nint m_bForceNpcExclude = 0x8AC; // bool
    public const nint m_sGlowEntity = 0x8B0; // CUtlSymbolLarge
    public const nint m_glowEntity = 0x8B8; // CHandle<CBaseModelEntity>
    public const nint m_usable = 0x8BC; // bool
    public const nint m_szDisplayText = 0x8C0; // CUtlSymbolLarge
}

public static class CBaseCSGrenade {
    public const nint m_bRedraw = 0xE20; // bool
    public const nint m_bIsHeldByPlayer = 0xE21; // bool
    public const nint m_bPinPulled = 0xE22; // bool
    public const nint m_bJumpThrow = 0xE23; // bool
    public const nint m_eThrowStatus = 0xE24; // EGrenadeThrowState
    public const nint m_fThrowTime = 0xE28; // GameTime_t
    public const nint m_flThrowStrength = 0xE2C; // float
    public const nint m_flThrowStrengthApproach = 0xE30; // float
    public const nint m_fDropTime = 0xE34; // GameTime_t
}

public static class CBaseCSGrenadeProjectile {
    public const nint m_vInitialPosition = 0x9C8; // Vector
    public const nint m_vInitialVelocity = 0x9D4; // Vector
    public const nint m_nBounces = 0x9E0; // int32_t
    public const nint m_nExplodeEffectIndex = 0x9E8; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    public const nint m_nExplodeEffectTickBegin = 0x9F0; // int32_t
    public const nint m_vecExplodeEffectOrigin = 0x9F4; // Vector
    public const nint m_flSpawnTime = 0xA00; // GameTime_t
    public const nint m_unOGSExtraFlags = 0xA04; // uint8_t
    public const nint m_bDetonationRecorded = 0xA05; // bool
    public const nint m_flDetonateTime = 0xA08; // GameTime_t
    public const nint m_nItemIndex = 0xA0C; // uint16_t
    public const nint m_vecOriginalSpawnLocation = 0xA10; // Vector
    public const nint m_flLastBounceSoundTime = 0xA1C; // GameTime_t
    public const nint m_vecGrenadeSpin = 0xA20; // RotationVector
    public const nint m_vecLastHitSurfaceNormal = 0xA2C; // Vector
    public const nint m_nTicksAtZeroVelocity = 0xA38; // int32_t
    public const nint m_bHasEverHitPlayer = 0xA3C; // bool
    public const nint m_bClearFromPlayers = 0xA3D; // bool
}

public static class CBaseClientUIEntity {
    public const nint m_bEnabled = 0x700; // bool
    public const nint m_DialogXMLName = 0x708; // CUtlSymbolLarge
    public const nint m_PanelClassName = 0x710; // CUtlSymbolLarge
    public const nint m_PanelID = 0x718; // CUtlSymbolLarge
    public const nint m_CustomOutput0 = 0x720; // CEntityIOOutput
    public const nint m_CustomOutput1 = 0x748; // CEntityIOOutput
    public const nint m_CustomOutput2 = 0x770; // CEntityIOOutput
    public const nint m_CustomOutput3 = 0x798; // CEntityIOOutput
    public const nint m_CustomOutput4 = 0x7C0; // CEntityIOOutput
    public const nint m_CustomOutput5 = 0x7E8; // CEntityIOOutput
    public const nint m_CustomOutput6 = 0x810; // CEntityIOOutput
    public const nint m_CustomOutput7 = 0x838; // CEntityIOOutput
    public const nint m_CustomOutput8 = 0x860; // CEntityIOOutput
    public const nint m_CustomOutput9 = 0x888; // CEntityIOOutput
}

public static class CBaseCombatCharacter {
    public const nint m_bForceServerRagdoll = 0x920; // bool
    public const nint m_hMyWearables = 0x928; // CNetworkUtlVectorBase<CHandle<CEconWearable>>
    public const nint m_flFieldOfView = 0x940; // float
    public const nint m_impactEnergyScale = 0x944; // float
    public const nint m_LastHitGroup = 0x948; // HitGroup_t
    public const nint m_bApplyStressDamage = 0x94C; // bool
    public const nint m_bloodColor = 0x950; // int32_t
    public const nint m_navMeshID = 0x9B0; // int32_t
    public const nint m_iDamageCount = 0x9B4; // int32_t
    public const nint m_pVecRelationships = 0x9B8; // CUtlVector<RelationshipOverride_t>*
    public const nint m_strRelationships = 0x9C0; // CUtlSymbolLarge
    public const nint m_eHull = 0x9C8; // Hull_t
    public const nint m_nNavHullIdx = 0x9CC; // uint32_t
}

public static class CBaseDMStart {
    public const nint m_Master = 0x4B0; // CUtlSymbolLarge
}

public static class CBaseDoor {
    public const nint m_angMoveEntitySpace = 0x790; // QAngle
    public const nint m_vecMoveDirParentSpace = 0x79C; // Vector
    public const nint m_ls = 0x7A8; // locksound_t
    public const nint m_bForceClosed = 0x7C8; // bool
    public const nint m_bDoorGroup = 0x7C9; // bool
    public const nint m_bLocked = 0x7CA; // bool
    public const nint m_bIgnoreDebris = 0x7CB; // bool
    public const nint m_eSpawnPosition = 0x7CC; // FuncDoorSpawnPos_t
    public const nint m_flBlockDamage = 0x7D0; // float
    public const nint m_NoiseMoving = 0x7D8; // CUtlSymbolLarge
    public const nint m_NoiseArrived = 0x7E0; // CUtlSymbolLarge
    public const nint m_NoiseMovingClosed = 0x7E8; // CUtlSymbolLarge
    public const nint m_NoiseArrivedClosed = 0x7F0; // CUtlSymbolLarge
    public const nint m_ChainTarget = 0x7F8; // CUtlSymbolLarge
    public const nint m_OnBlockedClosing = 0x800; // CEntityIOOutput
    public const nint m_OnBlockedOpening = 0x828; // CEntityIOOutput
    public const nint m_OnUnblockedClosing = 0x850; // CEntityIOOutput
    public const nint m_OnUnblockedOpening = 0x878; // CEntityIOOutput
    public const nint m_OnFullyClosed = 0x8A0; // CEntityIOOutput
    public const nint m_OnFullyOpen = 0x8C8; // CEntityIOOutput
    public const nint m_OnClose = 0x8F0; // CEntityIOOutput
    public const nint m_OnOpen = 0x918; // CEntityIOOutput
    public const nint m_OnLockedUse = 0x940; // CEntityIOOutput
    public const nint m_bLoopMoveSound = 0x968; // bool
    public const nint m_bCreateNavObstacle = 0x980; // bool
    public const nint m_isChaining = 0x981; // bool
    public const nint m_bIsUsable = 0x982; // bool
}

public static class CBaseEntity {
    public const nint m_CBodyComponent = 0x30; // CBodyComponent*
    public const nint m_NetworkTransmitComponent = 0x38; // CNetworkTransmitComponent
    public const nint m_aThinkFunctions = 0x228; // CUtlVector<thinkfunc_t>
    public const nint m_iCurrentThinkContext = 0x240; // int32_t
    public const nint m_nLastThinkTick = 0x244; // GameTick_t
    public const nint m_isSteadyState = 0x250; // CBitVec<64>
    public const nint m_lastNetworkChange = 0x258; // float
    public const nint m_ResponseContexts = 0x268; // CUtlVector<ResponseContext_t>
    public const nint m_iszResponseContext = 0x280; // CUtlSymbolLarge
    public const nint m_iHealth = 0x2A8; // int32_t
    public const nint m_iMaxHealth = 0x2AC; // int32_t
    public const nint m_lifeState = 0x2B0; // uint8_t
    public const nint m_flDamageAccumulator = 0x2B4; // float
    public const nint m_bTakesDamage = 0x2B8; // bool
    public const nint m_nTakeDamageFlags = 0x2BC; // TakeDamageFlags_t
    public const nint m_MoveCollide = 0x2C1; // MoveCollide_t
    public const nint m_MoveType = 0x2C2; // MoveType_t
    public const nint m_nWaterTouch = 0x2C3; // uint8_t
    public const nint m_nSlimeTouch = 0x2C4; // uint8_t
    public const nint m_bRestoreInHierarchy = 0x2C5; // bool
    public const nint m_target = 0x2C8; // CUtlSymbolLarge
    public const nint m_flMoveDoneTime = 0x2D0; // float
    public const nint m_hDamageFilter = 0x2D4; // CHandle<CBaseFilter>
    public const nint m_iszDamageFilterName = 0x2D8; // CUtlSymbolLarge
    public const nint m_nSubclassID = 0x2E0; // CUtlStringToken
    public const nint m_flAnimTime = 0x2F0; // float
    public const nint m_flSimulationTime = 0x2F4; // float
    public const nint m_flCreateTime = 0x2F8; // GameTime_t
    public const nint m_bClientSideRagdoll = 0x2FC; // bool
    public const nint m_ubInterpolationFrame = 0x2FD; // uint8_t
    public const nint m_vPrevVPhysicsUpdatePos = 0x300; // Vector
    public const nint m_iTeamNum = 0x30C; // uint8_t
    public const nint m_iGlobalname = 0x310; // CUtlSymbolLarge
    public const nint m_iSentToClients = 0x318; // int32_t
    public const nint m_flSpeed = 0x31C; // float
    public const nint m_sUniqueHammerID = 0x320; // CUtlString
    public const nint m_spawnflags = 0x328; // uint32_t
    public const nint m_nNextThinkTick = 0x32C; // GameTick_t
    public const nint m_nSimulationTick = 0x330; // int32_t
    public const nint m_OnKilled = 0x338; // CEntityIOOutput
    public const nint m_fFlags = 0x360; // uint32_t
    public const nint m_vecAbsVelocity = 0x364; // Vector
    public const nint m_vecVelocity = 0x370; // CNetworkVelocityVector
    public const nint m_vecBaseVelocity = 0x3A0; // Vector
    public const nint m_nPushEnumCount = 0x3AC; // int32_t
    public const nint m_pCollision = 0x3B0; // CCollisionProperty*
    public const nint m_hEffectEntity = 0x3B8; // CHandle<CBaseEntity>
    public const nint m_hOwnerEntity = 0x3BC; // CHandle<CBaseEntity>
    public const nint m_fEffects = 0x3C0; // uint32_t
    public const nint m_hGroundEntity = 0x3C4; // CHandle<CBaseEntity>
    public const nint m_flFriction = 0x3C8; // float
    public const nint m_flElasticity = 0x3CC; // float
    public const nint m_flGravityScale = 0x3D0; // float
    public const nint m_flTimeScale = 0x3D4; // float
    public const nint m_flWaterLevel = 0x3D8; // float
    public const nint m_bSimulatedEveryTick = 0x3DC; // bool
    public const nint m_bAnimatedEveryTick = 0x3DD; // bool
    public const nint m_bDisableLowViolence = 0x3DE; // bool
    public const nint m_nWaterType = 0x3DF; // uint8_t
    public const nint m_iEFlags = 0x3E0; // int32_t
    public const nint m_OnUser1 = 0x3E8; // CEntityIOOutput
    public const nint m_OnUser2 = 0x410; // CEntityIOOutput
    public const nint m_OnUser3 = 0x438; // CEntityIOOutput
    public const nint m_OnUser4 = 0x460; // CEntityIOOutput
    public const nint m_iInitialTeamNum = 0x488; // int32_t
    public const nint m_flNavIgnoreUntilTime = 0x48C; // GameTime_t
    public const nint m_vecAngVelocity = 0x490; // QAngle
    public const nint m_bNetworkQuantizeOriginAndAngles = 0x49C; // bool
    public const nint m_bLagCompensate = 0x49D; // bool
    public const nint m_flOverriddenFriction = 0x4A0; // float
    public const nint m_pBlocker = 0x4A4; // CHandle<CBaseEntity>
    public const nint m_flLocalTime = 0x4A8; // float
    public const nint m_flVPhysicsUpdateLocalTime = 0x4AC; // float
}

public static class CBaseFilter {
    public const nint m_bNegated = 0x4B0; // bool
    public const nint m_OnPass = 0x4B8; // CEntityIOOutput
    public const nint m_OnFail = 0x4E0; // CEntityIOOutput
}

public static class CBaseFire {
    public const nint m_flScale = 0x4B0; // float
    public const nint m_flStartScale = 0x4B4; // float
    public const nint m_flScaleTime = 0x4B8; // float
    public const nint m_nFlags = 0x4BC; // uint32_t
}

public static class CBaseFlex {
    public const nint m_flexWeight = 0x890; // CNetworkUtlVectorBase<float>
    public const nint m_vLookTargetPosition = 0x8A8; // Vector
    public const nint m_blinktoggle = 0x8B4; // bool
    public const nint m_flAllowResponsesEndTime = 0x908; // GameTime_t
    public const nint m_flLastFlexAnimationTime = 0x90C; // GameTime_t
    public const nint m_nNextSceneEventId = 0x910; // uint32_t
    public const nint m_bUpdateLayerPriorities = 0x914; // bool
}

public static class CBaseGrenade {
    public const nint m_OnPlayerPickup = 0x928; // CEntityIOOutput
    public const nint m_OnExplode = 0x950; // CEntityIOOutput
    public const nint m_bHasWarnedAI = 0x978; // bool
    public const nint m_bIsSmokeGrenade = 0x979; // bool
    public const nint m_bIsLive = 0x97A; // bool
    public const nint m_DmgRadius = 0x97C; // float
    public const nint m_flDetonateTime = 0x980; // GameTime_t
    public const nint m_flWarnAITime = 0x984; // float
    public const nint m_flDamage = 0x988; // float
    public const nint m_iszBounceSound = 0x990; // CUtlSymbolLarge
    public const nint m_ExplosionSound = 0x998; // CUtlString
    public const nint m_hThrower = 0x9A4; // CHandle<CCSPlayerPawn>
    public const nint m_flNextAttack = 0x9BC; // GameTime_t
    public const nint m_hOriginalThrower = 0x9C0; // CHandle<CCSPlayerPawn>
}

public static class CBaseIssue {
    public const nint m_szTypeString = 0x20; // char[64]
    public const nint m_szDetailsString = 0x60; // char[260]
    public const nint m_iNumYesVotes = 0x164; // int32_t
    public const nint m_iNumNoVotes = 0x168; // int32_t
    public const nint m_iNumPotentialVotes = 0x16C; // int32_t
    public const nint m_pVoteController = 0x170; // CVoteController*
}

public static class CBaseModelEntity {
    public const nint m_CRenderComponent = 0x4B0; // CRenderComponent*
    public const nint m_CHitboxComponent = 0x4B8; // CHitboxComponent
    public const nint m_flDissolveStartTime = 0x4E0; // GameTime_t
    public const nint m_OnIgnite = 0x4E8; // CEntityIOOutput
    public const nint m_nRenderMode = 0x510; // RenderMode_t
    public const nint m_nRenderFX = 0x511; // RenderFx_t
    public const nint m_bAllowFadeInView = 0x512; // bool
    public const nint m_clrRender = 0x513; // Color
    public const nint m_vecRenderAttributes = 0x518; // CUtlVectorEmbeddedNetworkVar<EntityRenderAttribute_t>
    public const nint m_bRenderToCubemaps = 0x568; // bool
    public const nint m_Collision = 0x570; // CCollisionProperty
    public const nint m_Glow = 0x620; // CGlowProperty
    public const nint m_flGlowBackfaceMult = 0x678; // float
    public const nint m_fadeMinDist = 0x67C; // float
    public const nint m_fadeMaxDist = 0x680; // float
    public const nint m_flFadeScale = 0x684; // float
    public const nint m_flShadowStrength = 0x688; // float
    public const nint m_nObjectCulling = 0x68C; // uint8_t
    public const nint m_nAddDecal = 0x690; // int32_t
    public const nint m_vDecalPosition = 0x694; // Vector
    public const nint m_vDecalForwardAxis = 0x6A0; // Vector
    public const nint m_flDecalHealBloodRate = 0x6AC; // float
    public const nint m_flDecalHealHeightRate = 0x6B0; // float
    public const nint m_ConfigEntitiesToPropagateMaterialDecalsTo = 0x6B8; // CNetworkUtlVectorBase<CHandle<CBaseModelEntity>>
    public const nint m_vecViewOffset = 0x6D0; // CNetworkViewOffsetVector
}

public static class CBaseMoveBehavior {
    public const nint m_iPositionInterpolator = 0x510; // int32_t
    public const nint m_iRotationInterpolator = 0x514; // int32_t
    public const nint m_flAnimStartTime = 0x518; // float
    public const nint m_flAnimEndTime = 0x51C; // float
    public const nint m_flAverageSpeedAcrossFrame = 0x520; // float
    public const nint m_pCurrentKeyFrame = 0x528; // CPathKeyFrame*
    public const nint m_pTargetKeyFrame = 0x530; // CPathKeyFrame*
    public const nint m_pPreKeyFrame = 0x538; // CPathKeyFrame*
    public const nint m_pPostKeyFrame = 0x540; // CPathKeyFrame*
    public const nint m_flTimeIntoFrame = 0x548; // float
    public const nint m_iDirection = 0x54C; // int32_t
}

public static class CBasePlatTrain {
    public const nint m_NoiseMoving = 0x780; // CUtlSymbolLarge
    public const nint m_NoiseArrived = 0x788; // CUtlSymbolLarge
    public const nint m_volume = 0x798; // float
    public const nint m_flTWidth = 0x79C; // float
    public const nint m_flTLength = 0x7A0; // float
}

public static class CBasePlayerController {
    public const nint m_nInButtonsWhichAreToggles = 0x4B8; // uint64_t
    public const nint m_nTickBase = 0x4C0; // uint32_t
    public const nint m_hPawn = 0x4F0; // CHandle<CBasePlayerPawn>
    public const nint m_nSplitScreenSlot = 0x4F4; // CSplitScreenSlot
    public const nint m_hSplitOwner = 0x4F8; // CHandle<CBasePlayerController>
    public const nint m_hSplitScreenPlayers = 0x500; // CUtlVector<CHandle<CBasePlayerController>>
    public const nint m_bIsHLTV = 0x518; // bool
    public const nint m_iConnected = 0x51C; // PlayerConnectedState
    public const nint m_iszPlayerName = 0x520; // char[128]
    public const nint m_szNetworkIDString = 0x5A0; // CUtlString
    public const nint m_fLerpTime = 0x5A8; // float
    public const nint m_bLagCompensation = 0x5AC; // bool
    public const nint m_bPredict = 0x5AD; // bool
    public const nint m_bAutoKickDisabled = 0x5AE; // bool
    public const nint m_bIsLowViolence = 0x5AF; // bool
    public const nint m_bGamePaused = 0x5B0; // bool
    public const nint m_nUsecTimestampLastUserCmdReceived = 0x648; // int64_t
    public const nint m_iIgnoreGlobalChat = 0x660; // ChatIgnoreType_t
    public const nint m_flLastPlayerTalkTime = 0x664; // float
    public const nint m_flLastEntitySteadyState = 0x668; // float
    public const nint m_nAvailableEntitySteadyState = 0x66C; // int32_t
    public const nint m_bHasAnySteadyStateEnts = 0x670; // bool
    public const nint m_steamID = 0x680; // uint64_t
    public const nint m_iDesiredFOV = 0x688; // uint32_t
}

public static class CBasePlayerPawn {
    public const nint m_pWeaponServices = 0x9D0; // CPlayer_WeaponServices*
    public const nint m_pItemServices = 0x9D8; // CPlayer_ItemServices*
    public const nint m_pAutoaimServices = 0x9E0; // CPlayer_AutoaimServices*
    public const nint m_pObserverServices = 0x9E8; // CPlayer_ObserverServices*
    public const nint m_pWaterServices = 0x9F0; // CPlayer_WaterServices*
    public const nint m_pUseServices = 0x9F8; // CPlayer_UseServices*
    public const nint m_pFlashlightServices = 0xA00; // CPlayer_FlashlightServices*
    public const nint m_pCameraServices = 0xA08; // CPlayer_CameraServices*
    public const nint m_pMovementServices = 0xA10; // CPlayer_MovementServices*
    public const nint m_ServerViewAngleChanges = 0xA20; // CUtlVectorEmbeddedNetworkVar<ViewAngleServerChange_t>
    public const nint m_nHighestGeneratedServerViewAngleChangeIndex = 0xA70; // uint32_t
    public const nint v_angle = 0xA74; // QAngle
    public const nint v_anglePrevious = 0xA80; // QAngle
    public const nint m_iHideHUD = 0xA8C; // uint32_t
    public const nint m_skybox3d = 0xA90; // sky3dparams_t
    public const nint m_fTimeLastHurt = 0xB20; // GameTime_t
    public const nint m_flDeathTime = 0xB24; // GameTime_t
    public const nint m_fNextSuicideTime = 0xB28; // GameTime_t
    public const nint m_fInitHUD = 0xB2C; // bool
    public const nint m_pExpresser = 0xB30; // CAI_Expresser*
    public const nint m_hController = 0xB38; // CHandle<CBasePlayerController>
    public const nint m_fHltvReplayDelay = 0xB40; // float
    public const nint m_fHltvReplayEnd = 0xB44; // float
    public const nint m_iHltvReplayEntity = 0xB48; // CEntityIndex
}

public static class CBasePlayerVData {
    public const nint m_sModelName = 0x28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    public const nint m_flHeadDamageMultiplier = 0x108; // CSkillFloat
    public const nint m_flChestDamageMultiplier = 0x118; // CSkillFloat
    public const nint m_flStomachDamageMultiplier = 0x128; // CSkillFloat
    public const nint m_flArmDamageMultiplier = 0x138; // CSkillFloat
    public const nint m_flLegDamageMultiplier = 0x148; // CSkillFloat
    public const nint m_flHoldBreathTime = 0x158; // float
    public const nint m_flDrowningDamageInterval = 0x15C; // float
    public const nint m_nDrowningDamageInitial = 0x160; // int32_t
    public const nint m_nDrowningDamageMax = 0x164; // int32_t
    public const nint m_nWaterSpeed = 0x168; // int32_t
    public const nint m_flUseRange = 0x16C; // float
    public const nint m_flUseAngleTolerance = 0x170; // float
    public const nint m_flCrouchTime = 0x174; // float
}

public static class CBasePlayerWeapon {
    public const nint m_nNextPrimaryAttackTick = 0xC18; // GameTick_t
    public const nint m_flNextPrimaryAttackTickRatio = 0xC1C; // float
    public const nint m_nNextSecondaryAttackTick = 0xC20; // GameTick_t
    public const nint m_flNextSecondaryAttackTickRatio = 0xC24; // float
    public const nint m_iClip1 = 0xC28; // int32_t
    public const nint m_iClip2 = 0xC2C; // int32_t
    public const nint m_pReserveAmmo = 0xC30; // int32_t[2]
    public const nint m_OnPlayerUse = 0xC38; // CEntityIOOutput
}

public static class CBasePlayerWeaponVData {
    public const nint m_szWorldModel = 0x28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    public const nint m_bBuiltRightHanded = 0x108; // bool
    public const nint m_bAllowFlipping = 0x109; // bool
    public const nint m_bIsFullAuto = 0x10A; // bool
    public const nint m_nNumBullets = 0x10C; // int32_t
    public const nint m_sMuzzleAttachment = 0x110; // CUtlString
    public const nint m_szMuzzleFlashParticle = 0x118; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    public const nint m_iFlags = 0x1F8; // ItemFlagTypes_t
    public const nint m_nPrimaryAmmoType = 0x1F9; // AmmoIndex_t
    public const nint m_nSecondaryAmmoType = 0x1FA; // AmmoIndex_t
    public const nint m_iMaxClip1 = 0x1FC; // int32_t
    public const nint m_iMaxClip2 = 0x200; // int32_t
    public const nint m_iDefaultClip1 = 0x204; // int32_t
    public const nint m_iDefaultClip2 = 0x208; // int32_t
    public const nint m_iWeight = 0x20C; // int32_t
    public const nint m_bAutoSwitchTo = 0x210; // bool
    public const nint m_bAutoSwitchFrom = 0x211; // bool
    public const nint m_iRumbleEffect = 0x214; // RumbleEffect_t
    public const nint m_aShootSounds = 0x218; // CUtlMap<WeaponSound_t,CSoundEventName>
    public const nint m_iSlot = 0x238; // int32_t
    public const nint m_iPosition = 0x23C; // int32_t
}

public static class CBaseProp {
    public const nint m_bModelOverrodeBlockLOS = 0x890; // bool
    public const nint m_iShapeType = 0x894; // int32_t
    public const nint m_bConformToCollisionBounds = 0x898; // bool
    public const nint m_mPreferredCatchTransform = 0x89C; // matrix3x4_t
}

public static class CBasePropDoor {
    public const nint m_flAutoReturnDelay = 0xB18; // float
    public const nint m_hDoorList = 0xB20; // CUtlVector<CHandle<CBasePropDoor>>
    public const nint m_nHardwareType = 0xB38; // int32_t
    public const nint m_bNeedsHardware = 0xB3C; // bool
    public const nint m_eDoorState = 0xB40; // DoorState_t
    public const nint m_bLocked = 0xB44; // bool
    public const nint m_closedPosition = 0xB48; // Vector
    public const nint m_closedAngles = 0xB54; // QAngle
    public const nint m_hBlocker = 0xB60; // CHandle<CBaseEntity>
    public const nint m_bFirstBlocked = 0xB64; // bool
    public const nint m_ls = 0xB68; // locksound_t
    public const nint m_bForceClosed = 0xB88; // bool
    public const nint m_vecLatchWorldPosition = 0xB8C; // Vector
    public const nint m_hActivator = 0xB98; // CHandle<CBaseEntity>
    public const nint m_SoundMoving = 0xBA8; // CUtlSymbolLarge
    public const nint m_SoundOpen = 0xBB0; // CUtlSymbolLarge
    public const nint m_SoundClose = 0xBB8; // CUtlSymbolLarge
    public const nint m_SoundLock = 0xBC0; // CUtlSymbolLarge
    public const nint m_SoundUnlock = 0xBC8; // CUtlSymbolLarge
    public const nint m_SoundLatch = 0xBD0; // CUtlSymbolLarge
    public const nint m_SoundPound = 0xBD8; // CUtlSymbolLarge
    public const nint m_SoundJiggle = 0xBE0; // CUtlSymbolLarge
    public const nint m_SoundLockedAnim = 0xBE8; // CUtlSymbolLarge
    public const nint m_numCloseAttempts = 0xBF0; // int32_t
    public const nint m_nPhysicsMaterial = 0xBF4; // CUtlStringToken
    public const nint m_SlaveName = 0xBF8; // CUtlSymbolLarge
    public const nint m_hMaster = 0xC00; // CHandle<CBasePropDoor>
    public const nint m_OnBlockedClosing = 0xC08; // CEntityIOOutput
    public const nint m_OnBlockedOpening = 0xC30; // CEntityIOOutput
    public const nint m_OnUnblockedClosing = 0xC58; // CEntityIOOutput
    public const nint m_OnUnblockedOpening = 0xC80; // CEntityIOOutput
    public const nint m_OnFullyClosed = 0xCA8; // CEntityIOOutput
    public const nint m_OnFullyOpen = 0xCD0; // CEntityIOOutput
    public const nint m_OnClose = 0xCF8; // CEntityIOOutput
    public const nint m_OnOpen = 0xD20; // CEntityIOOutput
    public const nint m_OnLockedUse = 0xD48; // CEntityIOOutput
    public const nint m_OnAjarOpen = 0xD70; // CEntityIOOutput
}

public static class CBaseToggle {
    public const nint m_toggle_state = 0x700; // TOGGLE_STATE
    public const nint m_flMoveDistance = 0x704; // float
    public const nint m_flWait = 0x708; // float
    public const nint m_flLip = 0x70C; // float
    public const nint m_bAlwaysFireBlockedOutputs = 0x710; // bool
    public const nint m_vecPosition1 = 0x714; // Vector
    public const nint m_vecPosition2 = 0x720; // Vector
    public const nint m_vecMoveAng = 0x72C; // QAngle
    public const nint m_vecAngle1 = 0x738; // QAngle
    public const nint m_vecAngle2 = 0x744; // QAngle
    public const nint m_flHeight = 0x750; // float
    public const nint m_hActivator = 0x754; // CHandle<CBaseEntity>
    public const nint m_vecFinalDest = 0x758; // Vector
    public const nint m_vecFinalAngle = 0x764; // QAngle
    public const nint m_movementType = 0x770; // int32_t
    public const nint m_sMaster = 0x778; // CUtlSymbolLarge
}

public static class CBaseTrigger {
    public const nint m_bDisabled = 0x780; // bool
    public const nint m_iFilterName = 0x788; // CUtlSymbolLarge
    public const nint m_hFilter = 0x790; // CHandle<CBaseFilter>
    public const nint m_OnStartTouch = 0x798; // CEntityIOOutput
    public const nint m_OnStartTouchAll = 0x7C0; // CEntityIOOutput
    public const nint m_OnEndTouch = 0x7E8; // CEntityIOOutput
    public const nint m_OnEndTouchAll = 0x810; // CEntityIOOutput
    public const nint m_OnTouching = 0x838; // CEntityIOOutput
    public const nint m_OnNotTouching = 0x860; // CEntityIOOutput
    public const nint m_hTouchingEntities = 0x888; // CUtlVector<CHandle<CBaseEntity>>
    public const nint m_bClientSidePredicted = 0x8A0; // bool
}

public static class CBaseViewModel {
    public const nint m_vecLastFacing = 0x898; // Vector
    public const nint m_nViewModelIndex = 0x8A4; // uint32_t
    public const nint m_nAnimationParity = 0x8A8; // uint32_t
    public const nint m_flAnimationStartTime = 0x8AC; // float
    public const nint m_hWeapon = 0x8B0; // CHandle<CBasePlayerWeapon>
    public const nint m_sVMName = 0x8B8; // CUtlSymbolLarge
    public const nint m_sAnimationPrefix = 0x8C0; // CUtlSymbolLarge
    public const nint m_hOldLayerSequence = 0x8C8; // HSequence
    public const nint m_oldLayer = 0x8CC; // int32_t
    public const nint m_oldLayerStartTime = 0x8D0; // float
    public const nint m_hControlPanel = 0x8D4; // CHandle<CBaseEntity>
}

public static class CBeam {
    public const nint m_flFrameRate = 0x700; // float
    public const nint m_flHDRColorScale = 0x704; // float
    public const nint m_flFireTime = 0x708; // GameTime_t
    public const nint m_flDamage = 0x70C; // float
    public const nint m_nNumBeamEnts = 0x710; // uint8_t
    public const nint m_hBaseMaterial = 0x718; // CStrongHandle<InfoForResourceTypeIMaterial2>
    public const nint m_nHaloIndex = 0x720; // CStrongHandle<InfoForResourceTypeIMaterial2>
    public const nint m_nBeamType = 0x728; // BeamType_t
    public const nint m_nBeamFlags = 0x72C; // uint32_t
    public const nint m_hAttachEntity = 0x730; // CHandle<CBaseEntity>[10]
    public const nint m_nAttachIndex = 0x758; // AttachmentHandle_t[10]
    public const nint m_fWidth = 0x764; // float
    public const nint m_fEndWidth = 0x768; // float
    public const nint m_fFadeLength = 0x76C; // float
    public const nint m_fHaloScale = 0x770; // float
    public const nint m_fAmplitude = 0x774; // float
    public const nint m_fStartFrame = 0x778; // float
    public const nint m_fSpeed = 0x77C; // float
    public const nint m_flFrame = 0x780; // float
    public const nint m_nClipStyle = 0x784; // BeamClipStyle_t
    public const nint m_bTurnedOff = 0x788; // bool
    public const nint m_vecEndPos = 0x78C; // Vector
    public const nint m_hEndEntity = 0x798; // CHandle<CBaseEntity>
    public const nint m_nDissolveType = 0x79C; // int32_t
}

public static class CBlood {
    public const nint m_vecSprayAngles = 0x4B0; // QAngle
    public const nint m_vecSprayDir = 0x4BC; // Vector
    public const nint m_flAmount = 0x4C8; // float
    public const nint m_Color = 0x4CC; // int32_t
}

public static class CBodyComponent {
    public const nint m_pSceneNode = 0x8; // CGameSceneNode*
    public const nint __m_pChainEntity = 0x20; // CNetworkVarChainer
}

public static class CBodyComponentBaseAnimGraph {
    public const nint m_animationController = 0x480; // CBaseAnimGraphController
    public const nint __m_pChainEntity = 0x760; // CNetworkVarChainer
}

public static class CBodyComponentBaseModelEntity {
    public const nint __m_pChainEntity = 0x480; // CNetworkVarChainer
}

public static class CBodyComponentPoint {
    public const nint m_sceneNode = 0x50; // CGameSceneNode
    public const nint __m_pChainEntity = 0x1A0; // CNetworkVarChainer
}

public static class CBodyComponentSkeletonInstance {
    public const nint m_skeletonInstance = 0x50; // CSkeletonInstance
    public const nint __m_pChainEntity = 0x450; // CNetworkVarChainer
}

public static class CBombTarget {
    public const nint m_OnBombExplode = 0x8A8; // CEntityIOOutput
    public const nint m_OnBombPlanted = 0x8D0; // CEntityIOOutput
    public const nint m_OnBombDefused = 0x8F8; // CEntityIOOutput
    public const nint m_bIsBombSiteB = 0x920; // bool
    public const nint m_bIsHeistBombTarget = 0x921; // bool
    public const nint m_bBombPlantedHere = 0x922; // bool
    public const nint m_szMountTarget = 0x928; // CUtlSymbolLarge
    public const nint m_hInstructorHint = 0x930; // CHandle<CBaseEntity>
    public const nint m_nBombSiteDesignation = 0x934; // int32_t
}

public static class CBot {
    public const nint m_pController = 0x10; // CCSPlayerController*
    public const nint m_pPlayer = 0x18; // CCSPlayerPawn*
    public const nint m_bHasSpawned = 0x20; // bool
    public const nint m_id = 0x24; // uint32_t
    public const nint m_isRunning = 0xB8; // bool
    public const nint m_isCrouching = 0xB9; // bool
    public const nint m_forwardSpeed = 0xBC; // float
    public const nint m_leftSpeed = 0xC0; // float
    public const nint m_verticalSpeed = 0xC4; // float
    public const nint m_buttonFlags = 0xC8; // uint64_t
    public const nint m_jumpTimestamp = 0xD0; // float
    public const nint m_viewForward = 0xD4; // Vector
    public const nint m_postureStackIndex = 0xF0; // int32_t
}

public static class CBreakable {
    public const nint m_Material = 0x710; // Materials
    public const nint m_hBreaker = 0x714; // CHandle<CBaseEntity>
    public const nint m_Explosion = 0x718; // Explosions
    public const nint m_iszSpawnObject = 0x720; // CUtlSymbolLarge
    public const nint m_flPressureDelay = 0x728; // float
    public const nint m_iMinHealthDmg = 0x72C; // int32_t
    public const nint m_iszPropData = 0x730; // CUtlSymbolLarge
    public const nint m_impactEnergyScale = 0x738; // float
    public const nint m_nOverrideBlockLOS = 0x73C; // EOverrideBlockLOS_t
    public const nint m_OnBreak = 0x740; // CEntityIOOutput
    public const nint m_OnHealthChanged = 0x768; // CEntityOutputTemplate<float>
    public const nint m_flDmgModBullet = 0x790; // float
    public const nint m_flDmgModClub = 0x794; // float
    public const nint m_flDmgModExplosive = 0x798; // float
    public const nint m_flDmgModFire = 0x79C; // float
    public const nint m_iszPhysicsDamageTableName = 0x7A0; // CUtlSymbolLarge
    public const nint m_iszBasePropData = 0x7A8; // CUtlSymbolLarge
    public const nint m_iInteractions = 0x7B0; // int32_t
    public const nint m_PerformanceMode = 0x7B4; // PerformanceMode_t
    public const nint m_hPhysicsAttacker = 0x7B8; // CHandle<CBasePlayerPawn>
    public const nint m_flLastPhysicsInfluenceTime = 0x7BC; // GameTime_t
}

public static class CBreakableProp {
    public const nint m_OnBreak = 0x8E0; // CEntityIOOutput
    public const nint m_OnHealthChanged = 0x908; // CEntityOutputTemplate<float>
    public const nint m_OnTakeDamage = 0x930; // CEntityIOOutput
    public const nint m_impactEnergyScale = 0x958; // float
    public const nint m_iMinHealthDmg = 0x95C; // int32_t
    public const nint m_preferredCarryAngles = 0x960; // QAngle
    public const nint m_flPressureDelay = 0x96C; // float
    public const nint m_hBreaker = 0x970; // CHandle<CBaseEntity>
    public const nint m_PerformanceMode = 0x974; // PerformanceMode_t
    public const nint m_flDmgModBullet = 0x978; // float
    public const nint m_flDmgModClub = 0x97C; // float
    public const nint m_flDmgModExplosive = 0x980; // float
    public const nint m_flDmgModFire = 0x984; // float
    public const nint m_iszPhysicsDamageTableName = 0x988; // CUtlSymbolLarge
    public const nint m_iszBasePropData = 0x990; // CUtlSymbolLarge
    public const nint m_iInteractions = 0x998; // int32_t
    public const nint m_flPreventDamageBeforeTime = 0x99C; // GameTime_t
    public const nint m_bHasBreakPiecesOrCommands = 0x9A0; // bool
    public const nint m_explodeDamage = 0x9A4; // float
    public const nint m_explodeRadius = 0x9A8; // float
    public const nint m_explosionDelay = 0x9B0; // float
    public const nint m_explosionBuildupSound = 0x9B8; // CUtlSymbolLarge
    public const nint m_explosionCustomEffect = 0x9C0; // CUtlSymbolLarge
    public const nint m_explosionCustomSound = 0x9C8; // CUtlSymbolLarge
    public const nint m_explosionModifier = 0x9D0; // CUtlSymbolLarge
    public const nint m_hPhysicsAttacker = 0x9D8; // CHandle<CBasePlayerPawn>
    public const nint m_flLastPhysicsInfluenceTime = 0x9DC; // GameTime_t
    public const nint m_bOriginalBlockLOS = 0x9E0; // bool
    public const nint m_flDefaultFadeScale = 0x9E4; // float
    public const nint m_hLastAttacker = 0x9E8; // CHandle<CBaseEntity>
    public const nint m_hFlareEnt = 0x9EC; // CHandle<CBaseEntity>
    public const nint m_bUsePuntSound = 0x9F0; // bool
    public const nint m_iszPuntSound = 0x9F8; // CUtlSymbolLarge
    public const nint m_noGhostCollision = 0xA00; // bool
}

public static class CBreakableStageHelper {
    public const nint m_nCurrentStage = 0x8; // int32_t
    public const nint m_nStageCount = 0xC; // int32_t
}

public static class CBtActionAim {
    public const nint m_szSensorInputKey = 0x68; // CUtlString
    public const nint m_szAimReadyKey = 0x80; // CUtlString
    public const nint m_flZoomCooldownTimestamp = 0x88; // float
    public const nint m_bDoneAiming = 0x8C; // bool
    public const nint m_flLerpStartTime = 0x90; // float
    public const nint m_flNextLookTargetLerpTime = 0x94; // float
    public const nint m_flPenaltyReductionRatio = 0x98; // float
    public const nint m_NextLookTarget = 0x9C; // QAngle
    public const nint m_AimTimer = 0xA8; // CountdownTimer
    public const nint m_SniperHoldTimer = 0xC0; // CountdownTimer
    public const nint m_FocusIntervalTimer = 0xD8; // CountdownTimer
    public const nint m_bAcquired = 0xF0; // bool
}

public static class CBtActionCombatPositioning {
    public const nint m_szSensorInputKey = 0x68; // CUtlString
    public const nint m_szIsAttackingKey = 0x80; // CUtlString
    public const nint m_ActionTimer = 0x88; // CountdownTimer
    public const nint m_bCrouching = 0xA0; // bool
}

public static class CBtActionMoveTo {
    public const nint m_szDestinationInputKey = 0x60; // CUtlString
    public const nint m_szHidingSpotInputKey = 0x68; // CUtlString
    public const nint m_szThreatInputKey = 0x70; // CUtlString
    public const nint m_vecDestination = 0x78; // Vector
    public const nint m_bAutoLookAdjust = 0x84; // bool
    public const nint m_bComputePath = 0x85; // bool
    public const nint m_flDamagingAreasPenaltyCost = 0x88; // float
    public const nint m_CheckApproximateCornersTimer = 0x90; // CountdownTimer
    public const nint m_CheckHighPriorityItem = 0xA8; // CountdownTimer
    public const nint m_RepathTimer = 0xC0; // CountdownTimer
    public const nint m_flArrivalEpsilon = 0xD8; // float
    public const nint m_flAdditionalArrivalEpsilon2D = 0xDC; // float
    public const nint m_flHidingSpotCheckDistanceThreshold = 0xE0; // float
    public const nint m_flNearestAreaDistanceThreshold = 0xE4; // float
}

public static class CBtActionParachutePositioning {
    public const nint m_ActionTimer = 0x58; // CountdownTimer
}

public static class CBtNodeCondition {
    public const nint m_bNegated = 0x58; // bool
}

public static class CBtNodeConditionInactive {
    public const nint m_flRoundStartThresholdSeconds = 0x78; // float
    public const nint m_flSensorInactivityThresholdSeconds = 0x7C; // float
    public const nint m_SensorInactivityTimer = 0x80; // CountdownTimer
}

public static class CBubbling {
    public const nint m_density = 0x700; // int32_t
    public const nint m_frequency = 0x704; // int32_t
    public const nint m_state = 0x708; // int32_t
}

public static class CBuoyancyHelper {
    public const nint m_flFluidDensity = 0x18; // float
}

public static class CBuyZone {
    public const nint m_LegacyTeamNum = 0x8A8; // int32_t
}

public static class CC4 {
    public const nint m_vecLastValidPlayerHeldPosition = 0xE20; // Vector
    public const nint m_vecLastValidDroppedPosition = 0xE2C; // Vector
    public const nint m_bDoValidDroppedPositionCheck = 0xE38; // bool
    public const nint m_bStartedArming = 0xE39; // bool
    public const nint m_fArmedTime = 0xE3C; // GameTime_t
    public const nint m_bBombPlacedAnimation = 0xE40; // bool
    public const nint m_bIsPlantingViaUse = 0xE41; // bool
    public const nint m_entitySpottedState = 0xE48; // EntitySpottedState_t
    public const nint m_nSpotRules = 0xE60; // int32_t
    public const nint m_bPlayedArmingBeeps = 0xE64; // bool[7]
    public const nint m_bBombPlanted = 0xE6B; // bool
    public const nint m_bDroppedFromDeath = 0xE6C; // bool
}

public static class CCSBot {
    public const nint m_lastCoopSpawnPoint = 0xF8; // CHandle<SpawnPointCoopEnemy>
    public const nint m_eyePosition = 0x108; // Vector
    public const nint m_name = 0x114; // char[64]
    public const nint m_combatRange = 0x154; // float
    public const nint m_isRogue = 0x158; // bool
    public const nint m_rogueTimer = 0x160; // CountdownTimer
    public const nint m_diedLastRound = 0x17C; // bool
    public const nint m_safeTime = 0x180; // float
    public const nint m_wasSafe = 0x184; // bool
    public const nint m_blindFire = 0x18C; // bool
    public const nint m_surpriseTimer = 0x190; // CountdownTimer
    public const nint m_bAllowActive = 0x1A8; // bool
    public const nint m_isFollowing = 0x1A9; // bool
    public const nint m_leader = 0x1AC; // CHandle<CCSPlayerPawn>
    public const nint m_followTimestamp = 0x1B0; // float
    public const nint m_allowAutoFollowTime = 0x1B4; // float
    public const nint m_hurryTimer = 0x1B8; // CountdownTimer
    public const nint m_alertTimer = 0x1D0; // CountdownTimer
    public const nint m_sneakTimer = 0x1E8; // CountdownTimer
    public const nint m_panicTimer = 0x200; // CountdownTimer
    public const nint m_stateTimestamp = 0x4D0; // float
    public const nint m_isAttacking = 0x4D4; // bool
    public const nint m_isOpeningDoor = 0x4D5; // bool
    public const nint m_taskEntity = 0x4DC; // CHandle<CBaseEntity>
    public const nint m_goalPosition = 0x4EC; // Vector
    public const nint m_goalEntity = 0x4F8; // CHandle<CBaseEntity>
    public const nint m_avoid = 0x4FC; // CHandle<CBaseEntity>
    public const nint m_avoidTimestamp = 0x500; // float
    public const nint m_isStopping = 0x504; // bool
    public const nint m_hasVisitedEnemySpawn = 0x505; // bool
    public const nint m_stillTimer = 0x508; // IntervalTimer
    public const nint m_bEyeAnglesUnderPathFinderControl = 0x518; // bool
    public const nint m_pathIndex = 0x6610; // int32_t
    public const nint m_areaEnteredTimestamp = 0x6614; // GameTime_t
    public const nint m_repathTimer = 0x6618; // CountdownTimer
    public const nint m_avoidFriendTimer = 0x6630; // CountdownTimer
    public const nint m_isFriendInTheWay = 0x6648; // bool
    public const nint m_politeTimer = 0x6650; // CountdownTimer
    public const nint m_isWaitingBehindFriend = 0x6668; // bool
    public const nint m_pathLadderEnd = 0x6694; // float
    public const nint m_mustRunTimer = 0x66E0; // CountdownTimer
    public const nint m_waitTimer = 0x66F8; // CountdownTimer
    public const nint m_updateTravelDistanceTimer = 0x6710; // CountdownTimer
    public const nint m_playerTravelDistance = 0x6728; // float[64]
    public const nint m_travelDistancePhase = 0x6828; // uint8_t
    public const nint m_hostageEscortCount = 0x69C0; // uint8_t
    public const nint m_hostageEscortCountTimestamp = 0x69C4; // float
    public const nint m_desiredTeam = 0x69C8; // int32_t
    public const nint m_hasJoined = 0x69CC; // bool
    public const nint m_isWaitingForHostage = 0x69CD; // bool
    public const nint m_inhibitWaitingForHostageTimer = 0x69D0; // CountdownTimer
    public const nint m_waitForHostageTimer = 0x69E8; // CountdownTimer
    public const nint m_noisePosition = 0x6A00; // Vector
    public const nint m_noiseTravelDistance = 0x6A0C; // float
    public const nint m_noiseTimestamp = 0x6A10; // float
    public const nint m_noiseSource = 0x6A18; // CCSPlayerPawn*
    public const nint m_noiseBendTimer = 0x6A30; // CountdownTimer
    public const nint m_bentNoisePosition = 0x6A48; // Vector
    public const nint m_bendNoisePositionValid = 0x6A54; // bool
    public const nint m_lookAroundStateTimestamp = 0x6A58; // float
    public const nint m_lookAheadAngle = 0x6A5C; // float
    public const nint m_forwardAngle = 0x6A60; // float
    public const nint m_inhibitLookAroundTimestamp = 0x6A64; // float
    public const nint m_lookAtSpot = 0x6A6C; // Vector
    public const nint m_lookAtSpotDuration = 0x6A7C; // float
    public const nint m_lookAtSpotTimestamp = 0x6A80; // float
    public const nint m_lookAtSpotAngleTolerance = 0x6A84; // float
    public const nint m_lookAtSpotClearIfClose = 0x6A88; // bool
    public const nint m_lookAtSpotAttack = 0x6A89; // bool
    public const nint m_lookAtDesc = 0x6A90; // char*
    public const nint m_peripheralTimestamp = 0x6A98; // float
    public const nint m_approachPointCount = 0x6C20; // uint8_t
    public const nint m_approachPointViewPosition = 0x6C24; // Vector
    public const nint m_viewSteadyTimer = 0x6C30; // IntervalTimer
    public const nint m_tossGrenadeTimer = 0x6C48; // CountdownTimer
    public const nint m_isAvoidingGrenade = 0x6C68; // CountdownTimer
    public const nint m_spotCheckTimestamp = 0x6C88; // float
    public const nint m_checkedHidingSpotCount = 0x7090; // int32_t
    public const nint m_lookPitch = 0x7094; // float
    public const nint m_lookPitchVel = 0x7098; // float
    public const nint m_lookYaw = 0x709C; // float
    public const nint m_lookYawVel = 0x70A0; // float
    public const nint m_targetSpot = 0x70A4; // Vector
    public const nint m_targetSpotVelocity = 0x70B0; // Vector
    public const nint m_targetSpotPredicted = 0x70BC; // Vector
    public const nint m_aimError = 0x70C8; // QAngle
    public const nint m_aimGoal = 0x70D4; // QAngle
    public const nint m_targetSpotTime = 0x70E0; // GameTime_t
    public const nint m_aimFocus = 0x70E4; // float
    public const nint m_aimFocusInterval = 0x70E8; // float
    public const nint m_aimFocusNextUpdate = 0x70EC; // GameTime_t
    public const nint m_ignoreEnemiesTimer = 0x70F8; // CountdownTimer
    public const nint m_enemy = 0x7110; // CHandle<CCSPlayerPawn>
    public const nint m_isEnemyVisible = 0x7114; // bool
    public const nint m_visibleEnemyParts = 0x7115; // uint8_t
    public const nint m_lastEnemyPosition = 0x7118; // Vector
    public const nint m_lastSawEnemyTimestamp = 0x7124; // float
    public const nint m_firstSawEnemyTimestamp = 0x7128; // float
    public const nint m_currentEnemyAcquireTimestamp = 0x712C; // float
    public const nint m_enemyDeathTimestamp = 0x7130; // float
    public const nint m_friendDeathTimestamp = 0x7134; // float
    public const nint m_isLastEnemyDead = 0x7138; // bool
    public const nint m_nearbyEnemyCount = 0x713C; // int32_t
    public const nint m_bomber = 0x7348; // CHandle<CCSPlayerPawn>
    public const nint m_nearbyFriendCount = 0x734C; // int32_t
    public const nint m_closestVisibleFriend = 0x7350; // CHandle<CCSPlayerPawn>
    public const nint m_closestVisibleHumanFriend = 0x7354; // CHandle<CCSPlayerPawn>
    public const nint m_attentionInterval = 0x7358; // IntervalTimer
    public const nint m_attacker = 0x7368; // CHandle<CCSPlayerPawn>
    public const nint m_attackedTimestamp = 0x736C; // float
    public const nint m_burnedByFlamesTimer = 0x7370; // IntervalTimer
    public const nint m_lastVictimID = 0x7380; // int32_t
    public const nint m_isAimingAtEnemy = 0x7384; // bool
    public const nint m_isRapidFiring = 0x7385; // bool
    public const nint m_equipTimer = 0x7388; // IntervalTimer
    public const nint m_zoomTimer = 0x7398; // CountdownTimer
    public const nint m_fireWeaponTimestamp = 0x73B0; // GameTime_t
    public const nint m_lookForWeaponsOnGroundTimer = 0x73B8; // CountdownTimer
    public const nint m_bIsSleeping = 0x73D0; // bool
    public const nint m_isEnemySniperVisible = 0x73D1; // bool
    public const nint m_sawEnemySniperTimer = 0x73D8; // CountdownTimer
    public const nint m_enemyQueueIndex = 0x7490; // uint8_t
    public const nint m_enemyQueueCount = 0x7491; // uint8_t
    public const nint m_enemyQueueAttendIndex = 0x7492; // uint8_t
    public const nint m_isStuck = 0x7493; // bool
    public const nint m_stuckTimestamp = 0x7494; // GameTime_t
    public const nint m_stuckSpot = 0x7498; // Vector
    public const nint m_wiggleTimer = 0x74A8; // CountdownTimer
    public const nint m_stuckJumpTimer = 0x74C0; // CountdownTimer
    public const nint m_nextCleanupCheckTimestamp = 0x74D8; // GameTime_t
    public const nint m_avgVel = 0x74DC; // float[10]
    public const nint m_avgVelIndex = 0x7504; // int32_t
    public const nint m_avgVelCount = 0x7508; // int32_t
    public const nint m_lastOrigin = 0x750C; // Vector
    public const nint m_lastRadioRecievedTimestamp = 0x751C; // float
    public const nint m_lastRadioSentTimestamp = 0x7520; // float
    public const nint m_radioSubject = 0x7524; // CHandle<CCSPlayerPawn>
    public const nint m_radioPosition = 0x7528; // Vector
    public const nint m_voiceEndTimestamp = 0x7534; // float
    public const nint m_lastValidReactionQueueFrame = 0x7540; // int32_t
}

public static class CCSGOViewModel {
    public const nint m_bShouldIgnoreOffsetAndAccuracy = 0x8D8; // bool
    public const nint m_nWeaponParity = 0x8DC; // uint32_t
    public const nint m_nOldWeaponParity = 0x8E0; // uint32_t
}

public static class CCSGO_TeamPreviewCharacterPosition {
    public const nint m_nVariant = 0x4B0; // int32_t
    public const nint m_nRandom = 0x4B4; // int32_t
    public const nint m_nOrdinal = 0x4B8; // int32_t
    public const nint m_sWeaponName = 0x4C0; // CUtlString
    public const nint m_xuid = 0x4C8; // uint64_t
    public const nint m_agentItem = 0x4D0; // CEconItemView
    public const nint m_glovesItem = 0x748; // CEconItemView
    public const nint m_weaponItem = 0x9C0; // CEconItemView
}

public static class CCSGameModeRules {
    public const nint __m_pChainEntity = 0x8; // CNetworkVarChainer
}

public static class CCSGameModeRules_Deathmatch {
    public const nint m_bFirstThink = 0x30; // bool
    public const nint m_bFirstThinkAfterConnected = 0x31; // bool
    public const nint m_flDMBonusStartTime = 0x34; // GameTime_t
    public const nint m_flDMBonusTimeLength = 0x38; // float
    public const nint m_nDMBonusWeaponLoadoutSlot = 0x3C; // int16_t
}

public static class CCSGameRules {
    public const nint __m_pChainEntity = 0x98; // CNetworkVarChainer
    public const nint m_coopMissionManager = 0xC0; // CHandle<CBaseEntity>
    public const nint m_bFreezePeriod = 0xC4; // bool
    public const nint m_bWarmupPeriod = 0xC5; // bool
    public const nint m_fWarmupPeriodEnd = 0xC8; // GameTime_t
    public const nint m_fWarmupPeriodStart = 0xCC; // GameTime_t
    public const nint m_nTotalPausedTicks = 0xD0; // int32_t
    public const nint m_nPauseStartTick = 0xD4; // int32_t
    public const nint m_bServerPaused = 0xD8; // bool
    public const nint m_bGamePaused = 0xD9; // bool
    public const nint m_bTerroristTimeOutActive = 0xDA; // bool
    public const nint m_bCTTimeOutActive = 0xDB; // bool
    public const nint m_flTerroristTimeOutRemaining = 0xDC; // float
    public const nint m_flCTTimeOutRemaining = 0xE0; // float
    public const nint m_nTerroristTimeOuts = 0xE4; // int32_t
    public const nint m_nCTTimeOuts = 0xE8; // int32_t
    public const nint m_bTechnicalTimeOut = 0xEC; // bool
    public const nint m_bMatchWaitingForResume = 0xED; // bool
    public const nint m_iRoundTime = 0xF0; // int32_t
    public const nint m_fMatchStartTime = 0xF4; // float
    public const nint m_fRoundStartTime = 0xF8; // GameTime_t
    public const nint m_flRestartRoundTime = 0xFC; // GameTime_t
    public const nint m_bGameRestart = 0x100; // bool
    public const nint m_flGameStartTime = 0x104; // float
    public const nint m_timeUntilNextPhaseStarts = 0x108; // float
    public const nint m_gamePhase = 0x10C; // int32_t
    public const nint m_totalRoundsPlayed = 0x110; // int32_t
    public const nint m_nRoundsPlayedThisPhase = 0x114; // int32_t
    public const nint m_nOvertimePlaying = 0x118; // int32_t
    public const nint m_iHostagesRemaining = 0x11C; // int32_t
    public const nint m_bAnyHostageReached = 0x120; // bool
    public const nint m_bMapHasBombTarget = 0x121; // bool
    public const nint m_bMapHasRescueZone = 0x122; // bool
    public const nint m_bMapHasBuyZone = 0x123; // bool
    public const nint m_bIsQueuedMatchmaking = 0x124; // bool
    public const nint m_nQueuedMatchmakingMode = 0x128; // int32_t
    public const nint m_bIsValveDS = 0x12C; // bool
    public const nint m_bLogoMap = 0x12D; // bool
    public const nint m_bPlayAllStepSoundsOnServer = 0x12E; // bool
    public const nint m_iSpectatorSlotCount = 0x130; // int32_t
    public const nint m_MatchDevice = 0x134; // int32_t
    public const nint m_bHasMatchStarted = 0x138; // bool
    public const nint m_nNextMapInMapgroup = 0x13C; // int32_t
    public const nint m_szTournamentEventName = 0x140; // char[512]
    public const nint m_szTournamentEventStage = 0x340; // char[512]
    public const nint m_szMatchStatTxt = 0x540; // char[512]
    public const nint m_szTournamentPredictionsTxt = 0x740; // char[512]
    public const nint m_nTournamentPredictionsPct = 0x940; // int32_t
    public const nint m_flCMMItemDropRevealStartTime = 0x944; // GameTime_t
    public const nint m_flCMMItemDropRevealEndTime = 0x948; // GameTime_t
    public const nint m_bIsDroppingItems = 0x94C; // bool
    public const nint m_bIsQuestEligible = 0x94D; // bool
    public const nint m_bIsHltvActive = 0x94E; // bool
    public const nint m_nGuardianModeWaveNumber = 0x950; // int32_t
    public const nint m_nGuardianModeSpecialKillsRemaining = 0x954; // int32_t
    public const nint m_nGuardianModeSpecialWeaponNeeded = 0x958; // int32_t
    public const nint m_nGuardianGrenadesToGiveBots = 0x95C; // int32_t
    public const nint m_nNumHeaviesToSpawn = 0x960; // int32_t
    public const nint m_numGlobalGiftsGiven = 0x964; // uint32_t
    public const nint m_numGlobalGifters = 0x968; // uint32_t
    public const nint m_numGlobalGiftsPeriodSeconds = 0x96C; // uint32_t
    public const nint m_arrFeaturedGiftersAccounts = 0x970; // uint32_t[4]
    public const nint m_arrFeaturedGiftersGifts = 0x980; // uint32_t[4]
    public const nint m_arrProhibitedItemIndices = 0x990; // uint16_t[100]
    public const nint m_arrTournamentActiveCasterAccounts = 0xA58; // uint32_t[4]
    public const nint m_numBestOfMaps = 0xA68; // int32_t
    public const nint m_nHalloweenMaskListSeed = 0xA6C; // int32_t
    public const nint m_bBombDropped = 0xA70; // bool
    public const nint m_bBombPlanted = 0xA71; // bool
    public const nint m_iRoundWinStatus = 0xA74; // int32_t
    public const nint m_eRoundWinReason = 0xA78; // int32_t
    public const nint m_bTCantBuy = 0xA7C; // bool
    public const nint m_bCTCantBuy = 0xA7D; // bool
    public const nint m_flGuardianBuyUntilTime = 0xA80; // GameTime_t
    public const nint m_iMatchStats_RoundResults = 0xA84; // int32_t[30]
    public const nint m_iMatchStats_PlayersAlive_CT = 0xAFC; // int32_t[30]
    public const nint m_iMatchStats_PlayersAlive_T = 0xB74; // int32_t[30]
    public const nint m_TeamRespawnWaveTimes = 0xBEC; // float[32]
    public const nint m_flNextRespawnWave = 0xC6C; // GameTime_t[32]
    public const nint m_nServerQuestID = 0xCEC; // int32_t
    public const nint m_vMinimapMins = 0xCF0; // Vector
    public const nint m_vMinimapMaxs = 0xCFC; // Vector
    public const nint m_MinimapVerticalSectionHeights = 0xD08; // float[8]
    public const nint m_bDontIncrementCoopWave = 0xD28; // bool
    public const nint m_bSpawnedTerrorHuntHeavy = 0xD29; // bool
    public const nint m_nEndMatchMapGroupVoteTypes = 0xD2C; // int32_t[10]
    public const nint m_nEndMatchMapGroupVoteOptions = 0xD54; // int32_t[10]
    public const nint m_nEndMatchMapVoteWinner = 0xD7C; // int32_t
    public const nint m_iNumConsecutiveCTLoses = 0xD80; // int32_t
    public const nint m_iNumConsecutiveTerroristLoses = 0xD84; // int32_t
    public const nint m_bHasHostageBeenTouched = 0xDA0; // bool
    public const nint m_flIntermissionStartTime = 0xDA4; // GameTime_t
    public const nint m_flIntermissionEndTime = 0xDA8; // GameTime_t
    public const nint m_bLevelInitialized = 0xDAC; // bool
    public const nint m_iTotalRoundsPlayed = 0xDB0; // int32_t
    public const nint m_iUnBalancedRounds = 0xDB4; // int32_t
    public const nint m_endMatchOnRoundReset = 0xDB8; // bool
    public const nint m_endMatchOnThink = 0xDB9; // bool
    public const nint m_iFreezeTime = 0xDBC; // int32_t
    public const nint m_iNumTerrorist = 0xDC0; // int32_t
    public const nint m_iNumCT = 0xDC4; // int32_t
    public const nint m_iNumSpawnableTerrorist = 0xDC8; // int32_t
    public const nint m_iNumSpawnableCT = 0xDCC; // int32_t
    public const nint m_arrSelectedHostageSpawnIndices = 0xDD0; // CUtlVector<int32_t>
    public const nint m_bFirstConnected = 0xDE8; // bool
    public const nint m_bCompleteReset = 0xDE9; // bool
    public const nint m_bPickNewTeamsOnReset = 0xDEA; // bool
    public const nint m_bScrambleTeamsOnRestart = 0xDEB; // bool
    public const nint m_bSwapTeamsOnRestart = 0xDEC; // bool
    public const nint m_nEndMatchTiedVotes = 0xDF8; // CUtlVector<int32_t>
    public const nint m_bNeedToAskPlayersForContinueVote = 0xE14; // bool
    public const nint m_numQueuedMatchmakingAccounts = 0xE18; // uint32_t
    public const nint m_pQueuedMatchmakingReservationString = 0xE20; // char*
    public const nint m_numTotalTournamentDrops = 0xE28; // uint32_t
    public const nint m_numSpectatorsCountMax = 0xE2C; // uint32_t
    public const nint m_numSpectatorsCountMaxTV = 0xE30; // uint32_t
    public const nint m_numSpectatorsCountMaxLnk = 0xE34; // uint32_t
    public const nint m_bForceTeamChangeSilent = 0xE40; // bool
    public const nint m_bLoadingRoundBackupData = 0xE41; // bool
    public const nint m_nMatchInfoShowType = 0xE78; // int32_t
    public const nint m_flMatchInfoDecidedTime = 0xE7C; // float
    public const nint m_flCoopRespawnAndHealTime = 0xE98; // float
    public const nint m_coopBonusCoinsFound = 0xE9C; // int32_t
    public const nint m_coopBonusPistolsOnly = 0xEA0; // bool
    public const nint m_coopPlayersInDeploymentZone = 0xEA1; // bool
    public const nint m_coopMissionDeadPlayerRespawnEnabled = 0xEA2; // bool
    public const nint mTeamDMLastWinningTeamNumber = 0xEA4; // int32_t
    public const nint mTeamDMLastThinkTime = 0xEA8; // float
    public const nint m_flTeamDMLastAnnouncementTime = 0xEAC; // float
    public const nint m_iAccountTerrorist = 0xEB0; // int32_t
    public const nint m_iAccountCT = 0xEB4; // int32_t
    public const nint m_iSpawnPointCount_Terrorist = 0xEB8; // int32_t
    public const nint m_iSpawnPointCount_CT = 0xEBC; // int32_t
    public const nint m_iMaxNumTerrorists = 0xEC0; // int32_t
    public const nint m_iMaxNumCTs = 0xEC4; // int32_t
    public const nint m_iLoserBonus = 0xEC8; // int32_t
    public const nint m_iLoserBonusMostRecentTeam = 0xECC; // int32_t
    public const nint m_tmNextPeriodicThink = 0xED0; // float
    public const nint m_bVoiceWonMatchBragFired = 0xED4; // bool
    public const nint m_fWarmupNextChatNoticeTime = 0xED8; // float
    public const nint m_iHostagesRescued = 0xEE0; // int32_t
    public const nint m_iHostagesTouched = 0xEE4; // int32_t
    public const nint m_flNextHostageAnnouncement = 0xEE8; // float
    public const nint m_bNoTerroristsKilled = 0xEEC; // bool
    public const nint m_bNoCTsKilled = 0xEED; // bool
    public const nint m_bNoEnemiesKilled = 0xEEE; // bool
    public const nint m_bCanDonateWeapons = 0xEEF; // bool
    public const nint m_firstKillTime = 0xEF4; // float
    public const nint m_firstBloodTime = 0xEFC; // float
    public const nint m_hostageWasInjured = 0xF18; // bool
    public const nint m_hostageWasKilled = 0xF19; // bool
    public const nint m_bVoteCalled = 0xF28; // bool
    public const nint m_bServerVoteOnReset = 0xF29; // bool
    public const nint m_flVoteCheckThrottle = 0xF2C; // float
    public const nint m_bBuyTimeEnded = 0xF30; // bool
    public const nint m_nLastFreezeEndBeep = 0xF34; // int32_t
    public const nint m_bTargetBombed = 0xF38; // bool
    public const nint m_bBombDefused = 0xF39; // bool
    public const nint m_bMapHasBombZone = 0xF3A; // bool
    public const nint m_vecMainCTSpawnPos = 0xF58; // Vector
    public const nint m_CTSpawnPointsMasterList = 0xF68; // CUtlVector<SpawnPoint*>
    public const nint m_TerroristSpawnPointsMasterList = 0xF80; // CUtlVector<SpawnPoint*>
    public const nint m_iNextCTSpawnPoint = 0xF98; // int32_t
    public const nint m_iNextTerroristSpawnPoint = 0xF9C; // int32_t
    public const nint m_CTSpawnPoints = 0xFA0; // CUtlVector<SpawnPoint*>
    public const nint m_TerroristSpawnPoints = 0xFB8; // CUtlVector<SpawnPoint*>
    public const nint m_bIsUnreservedGameServer = 0xFD0; // bool
    public const nint m_fAutobalanceDisplayTime = 0xFD4; // float
    public const nint m_bAllowWeaponSwitch = 0x1240; // bool
    public const nint m_bRoundTimeWarningTriggered = 0x1241; // bool
    public const nint m_phaseChangeAnnouncementTime = 0x1244; // GameTime_t
    public const nint m_fNextUpdateTeamClanNamesTime = 0x1248; // float
    public const nint m_flLastThinkTime = 0x124C; // GameTime_t
    public const nint m_fAccumulatedRoundOffDamage = 0x1250; // float
    public const nint m_nShorthandedBonusLastEvalRound = 0x1254; // int32_t
    public const nint m_nMatchAbortedEarlyReason = 0x14D0; // int32_t
    public const nint m_bHasTriggeredRoundStartMusic = 0x14D4; // bool
    public const nint m_bHasTriggeredCoopSpawnReset = 0x14D5; // bool
    public const nint m_bSwitchingTeamsAtRoundReset = 0x14D6; // bool
    public const nint m_pGameModeRules = 0x14F0; // CCSGameModeRules*
    public const nint m_BtGlobalBlackboard = 0x14F8; // KeyValues3
    public const nint m_hPlayerResource = 0x1560; // CHandle<CBaseEntity>
    public const nint m_RetakeRules = 0x1568; // CRetakeGameRules
    public const nint m_GuardianBotSkillLevelMax = 0x174C; // int32_t
    public const nint m_GuardianBotSkillLevelMin = 0x1750; // int32_t
    public const nint m_arrTeamUniqueKillWeaponsMatch = 0x1758; // CUtlVector<int32_t>[4]
    public const nint m_bTeamLastKillUsedUniqueWeaponMatch = 0x17B8; // bool[4]
    public const nint m_nMatchEndCount = 0x17E0; // uint8_t
    public const nint m_nTTeamIntroVariant = 0x17E4; // int32_t
    public const nint m_nCTTeamIntroVariant = 0x17E8; // int32_t
    public const nint m_bTeamIntroPeriod = 0x17EC; // bool
    public const nint m_fTeamIntroPeriodEnd = 0x17F0; // GameTime_t
    public const nint m_bPlayedTeamIntroVO = 0x17F4; // bool
    public const nint m_flLastPerfSampleTime = 0x5800; // double
    public const nint m_bSkipNextServerPerfSample = 0x5808; // bool
}

public static class CCSGameRulesProxy {
    public const nint m_pGameRules = 0x4B0; // CCSGameRules*
}

public static class CCSPlace {
    public const nint m_name = 0x708; // CUtlSymbolLarge
}

public static class CCSPlayerBase_CameraServices {
    public const nint m_iFOV = 0x170; // uint32_t
    public const nint m_iFOVStart = 0x174; // uint32_t
    public const nint m_flFOVTime = 0x178; // GameTime_t
    public const nint m_flFOVRate = 0x17C; // float
    public const nint m_hZoomOwner = 0x180; // CHandle<CBaseEntity>
    public const nint m_hTriggerFogList = 0x188; // CUtlVector<CHandle<CBaseEntity>>
    public const nint m_hLastFogTrigger = 0x1A0; // CHandle<CBaseEntity>
}

public static class CCSPlayerController {
    public const nint m_pInGameMoneyServices = 0x6B8; // CCSPlayerController_InGameMoneyServices*
    public const nint m_pInventoryServices = 0x6C0; // CCSPlayerController_InventoryServices*
    public const nint m_pActionTrackingServices = 0x6C8; // CCSPlayerController_ActionTrackingServices*
    public const nint m_pDamageServices = 0x6D0; // CCSPlayerController_DamageServices*
    public const nint m_iPing = 0x6D8; // uint32_t
    public const nint m_bHasCommunicationAbuseMute = 0x6DC; // bool
    public const nint m_szCrosshairCodes = 0x6E0; // CUtlSymbolLarge
    public const nint m_iPendingTeamNum = 0x6E8; // uint8_t
    public const nint m_flForceTeamTime = 0x6EC; // GameTime_t
    public const nint m_iCompTeammateColor = 0x6F0; // int32_t
    public const nint m_bEverPlayedOnTeam = 0x6F4; // bool
    public const nint m_bAttemptedToGetColor = 0x6F5; // bool
    public const nint m_iTeammatePreferredColor = 0x6F8; // int32_t
    public const nint m_bTeamChanged = 0x6FC; // bool
    public const nint m_bInSwitchTeam = 0x6FD; // bool
    public const nint m_bHasSeenJoinGame = 0x6FE; // bool
    public const nint m_bJustBecameSpectator = 0x6FF; // bool
    public const nint m_bSwitchTeamsOnNextRoundReset = 0x700; // bool
    public const nint m_bRemoveAllItemsOnNextRoundReset = 0x701; // bool
    public const nint m_szClan = 0x708; // CUtlSymbolLarge
    public const nint m_szClanName = 0x710; // char[32]
    public const nint m_iCoachingTeam = 0x730; // int32_t
    public const nint m_nPlayerDominated = 0x738; // uint64_t
    public const nint m_nPlayerDominatingMe = 0x740; // uint64_t
    public const nint m_iCompetitiveRanking = 0x748; // int32_t
    public const nint m_iCompetitiveWins = 0x74C; // int32_t
    public const nint m_iCompetitiveRankType = 0x750; // int8_t
    public const nint m_iCompetitiveRankingPredicted_Win = 0x754; // int32_t
    public const nint m_iCompetitiveRankingPredicted_Loss = 0x758; // int32_t
    public const nint m_iCompetitiveRankingPredicted_Tie = 0x75C; // int32_t
    public const nint m_nEndMatchNextMapVote = 0x760; // int32_t
    public const nint m_unActiveQuestId = 0x764; // uint16_t
    public const nint m_nQuestProgressReason = 0x768; // QuestProgress::Reason
    public const nint m_unPlayerTvControlFlags = 0x76C; // uint32_t
    public const nint m_iDraftIndex = 0x798; // int32_t
    public const nint m_msQueuedModeDisconnectionTimestamp = 0x79C; // uint32_t
    public const nint m_uiAbandonRecordedReason = 0x7A0; // uint32_t
    public const nint m_bCannotBeKicked = 0x7A4; // bool
    public const nint m_bEverFullyConnected = 0x7A5; // bool
    public const nint m_bAbandonAllowsSurrender = 0x7A6; // bool
    public const nint m_bAbandonOffersInstantSurrender = 0x7A7; // bool
    public const nint m_bDisconnection1MinWarningPrinted = 0x7A8; // bool
    public const nint m_bScoreReported = 0x7A9; // bool
    public const nint m_nDisconnectionTick = 0x7AC; // int32_t
    public const nint m_bControllingBot = 0x7B8; // bool
    public const nint m_bHasControlledBotThisRound = 0x7B9; // bool
    public const nint m_bHasBeenControlledByPlayerThisRound = 0x7BA; // bool
    public const nint m_nBotsControlledThisRound = 0x7BC; // int32_t
    public const nint m_bCanControlObservedBot = 0x7C0; // bool
    public const nint m_hPlayerPawn = 0x7C4; // CHandle<CCSPlayerPawn>
    public const nint m_hObserverPawn = 0x7C8; // CHandle<CCSObserverPawn>
    public const nint m_DesiredObserverMode = 0x7CC; // int32_t
    public const nint m_hDesiredObserverTarget = 0x7D0; // CEntityHandle
    public const nint m_bPawnIsAlive = 0x7D4; // bool
    public const nint m_iPawnHealth = 0x7D8; // uint32_t
    public const nint m_iPawnArmor = 0x7DC; // int32_t
    public const nint m_bPawnHasDefuser = 0x7E0; // bool
    public const nint m_bPawnHasHelmet = 0x7E1; // bool
    public const nint m_nPawnCharacterDefIndex = 0x7E2; // uint16_t
    public const nint m_iPawnLifetimeStart = 0x7E4; // int32_t
    public const nint m_iPawnLifetimeEnd = 0x7E8; // int32_t
    public const nint m_iPawnBotDifficulty = 0x7EC; // int32_t
    public const nint m_hOriginalControllerOfCurrentPawn = 0x7F0; // CHandle<CCSPlayerController>
    public const nint m_iScore = 0x7F4; // int32_t
    public const nint m_iRoundScore = 0x7F8; // int32_t
    public const nint m_iRoundsWon = 0x7FC; // int32_t
    public const nint m_vecKills = 0x800; // CNetworkUtlVectorBase<EKillTypes_t>
    public const nint m_iMVPs = 0x818; // int32_t
    public const nint m_nUpdateCounter = 0x81C; // int32_t
    public const nint m_flSmoothedPing = 0x820; // float
    public const nint m_lastHeldVoteTimer = 0xF8C8; // IntervalTimer
    public const nint m_bShowHints = 0xF8E0; // bool
    public const nint m_iNextTimeCheck = 0xF8E4; // int32_t
    public const nint m_bJustDidTeamKill = 0xF8E8; // bool
    public const nint m_bPunishForTeamKill = 0xF8E9; // bool
    public const nint m_bGaveTeamDamageWarning = 0xF8EA; // bool
    public const nint m_bGaveTeamDamageWarningThisRound = 0xF8EB; // bool
    public const nint m_dblLastReceivedPacketPlatFloatTime = 0xF8F0; // double
    public const nint m_LastTeamDamageWarningTime = 0xF8F8; // GameTime_t
    public const nint m_LastTimePlayerWasDisconnectedForPawnsRemove = 0xF8FC; // GameTime_t
}

public static class CCSPlayerController_ActionTrackingServices {
    public const nint m_perRoundStats = 0x40; // CUtlVectorEmbeddedNetworkVar<CSPerRoundStats_t>
    public const nint m_matchStats = 0x90; // CSMatchStats_t
    public const nint m_iNumRoundKills = 0x148; // int32_t
    public const nint m_iNumRoundKillsHeadshots = 0x14C; // int32_t
    public const nint m_unTotalRoundDamageDealt = 0x150; // uint32_t
}

public static class CCSPlayerController_DamageServices {
    public const nint m_nSendUpdate = 0x40; // int32_t
    public const nint m_DamageList = 0x48; // CUtlVectorEmbeddedNetworkVar<CDamageRecord>
}

public static class CCSPlayerController_InGameMoneyServices {
    public const nint m_bReceivesMoneyNextRound = 0x40; // bool
    public const nint m_iAccountMoneyEarnedForNextRound = 0x44; // int32_t
    public const nint m_iAccount = 0x48; // int32_t
    public const nint m_iStartAccount = 0x4C; // int32_t
    public const nint m_iTotalCashSpent = 0x50; // int32_t
    public const nint m_iCashSpentThisRound = 0x54; // int32_t
}

public static class CCSPlayerController_InventoryServices {
    public const nint m_unMusicID = 0x40; // uint16_t
    public const nint m_rank = 0x44; // MedalRank_t[6]
    public const nint m_nPersonaDataPublicLevel = 0x5C; // int32_t
    public const nint m_nPersonaDataPublicCommendsLeader = 0x60; // int32_t
    public const nint m_nPersonaDataPublicCommendsTeacher = 0x64; // int32_t
    public const nint m_nPersonaDataPublicCommendsFriendly = 0x68; // int32_t
    public const nint m_unEquippedPlayerSprayIDs = 0xF48; // uint32_t[1]
    public const nint m_vecServerAuthoritativeWeaponSlots = 0xF50; // CUtlVectorEmbeddedNetworkVar<ServerAuthoritativeWeaponSlot_t>
}

public static class CCSPlayerPawn {
    public const nint m_pBulletServices = 0x1550; // CCSPlayer_BulletServices*
    public const nint m_pHostageServices = 0x1558; // CCSPlayer_HostageServices*
    public const nint m_pBuyServices = 0x1560; // CCSPlayer_BuyServices*
    public const nint m_pActionTrackingServices = 0x1568; // CCSPlayer_ActionTrackingServices*
    public const nint m_pRadioServices = 0x1570; // CCSPlayer_RadioServices*
    public const nint m_pDamageReactServices = 0x1578; // CCSPlayer_DamageReactServices*
    public const nint m_nCharacterDefIndex = 0x1580; // uint16_t
    public const nint m_hPreviousModel = 0x1588; // CStrongHandle<InfoForResourceTypeCModel>
    public const nint m_bHasFemaleVoice = 0x1590; // bool
    public const nint m_strVOPrefix = 0x1598; // CUtlString
    public const nint m_szLastPlaceName = 0x15A0; // char[18]
    public const nint m_bInHostageResetZone = 0x1660; // bool
    public const nint m_bInBuyZone = 0x1661; // bool
    public const nint m_bWasInBuyZone = 0x1662; // bool
    public const nint m_bInHostageRescueZone = 0x1663; // bool
    public const nint m_bInBombZone = 0x1664; // bool
    public const nint m_bWasInHostageRescueZone = 0x1665; // bool
    public const nint m_iRetakesOffering = 0x1668; // int32_t
    public const nint m_iRetakesOfferingCard = 0x166C; // int32_t
    public const nint m_bRetakesHasDefuseKit = 0x1670; // bool
    public const nint m_bRetakesMVPLastRound = 0x1671; // bool
    public const nint m_iRetakesMVPBoostItem = 0x1674; // int32_t
    public const nint m_RetakesMVPBoostExtraUtility = 0x1678; // loadout_slot_t
    public const nint m_flHealthShotBoostExpirationTime = 0x167C; // GameTime_t
    public const nint m_flLandseconds = 0x1680; // float
    public const nint m_aimPunchAngle = 0x1684; // QAngle
    public const nint m_aimPunchAngleVel = 0x1690; // QAngle
    public const nint m_aimPunchTickBase = 0x169C; // int32_t
    public const nint m_aimPunchTickFraction = 0x16A0; // float
    public const nint m_aimPunchCache = 0x16A8; // CUtlVector<QAngle>
    public const nint m_bIsBuyMenuOpen = 0x16C0; // bool
    public const nint m_xLastHeadBoneTransform = 0x1C40; // CTransform
    public const nint m_bLastHeadBoneTransformIsValid = 0x1C60; // bool
    public const nint m_lastLandTime = 0x1C64; // GameTime_t
    public const nint m_bOnGroundLastTick = 0x1C68; // bool
    public const nint m_iPlayerLocked = 0x1C6C; // int32_t
    public const nint m_flTimeOfLastInjury = 0x1C74; // GameTime_t
    public const nint m_flNextSprayDecalTime = 0x1C78; // GameTime_t
    public const nint m_bNextSprayDecalTimeExpedited = 0x1C7C; // bool
    public const nint m_nRagdollDamageBone = 0x1C80; // int32_t
    public const nint m_vRagdollDamageForce = 0x1C84; // Vector
    public const nint m_vRagdollDamagePosition = 0x1C90; // Vector
    public const nint m_szRagdollDamageWeaponName = 0x1C9C; // char[64]
    public const nint m_bRagdollDamageHeadshot = 0x1CDC; // bool
    public const nint m_vRagdollServerOrigin = 0x1CE0; // Vector
    public const nint m_EconGloves = 0x1CF0; // CEconItemView
    public const nint m_qDeathEyeAngles = 0x1F68; // QAngle
    public const nint m_bSkipOneHeadConstraintUpdate = 0x1F74; // bool
}

public static class CCSPlayerPawnBase {
    public const nint m_CTouchExpansionComponent = 0xB68; // CTouchExpansionComponent
    public const nint m_pPingServices = 0xBB8; // CCSPlayer_PingServices*
    public const nint m_pViewModelServices = 0xBC0; // CPlayer_ViewModelServices*
    public const nint m_iDisplayHistoryBits = 0xBC8; // uint32_t
    public const nint m_flLastAttackedTeammate = 0xBCC; // float
    public const nint m_hOriginalController = 0xBD0; // CHandle<CCSPlayerController>
    public const nint m_blindUntilTime = 0xBD4; // GameTime_t
    public const nint m_blindStartTime = 0xBD8; // GameTime_t
    public const nint m_allowAutoFollowTime = 0xBDC; // GameTime_t
    public const nint m_entitySpottedState = 0xBE0; // EntitySpottedState_t
    public const nint m_nSpotRules = 0xBF8; // int32_t
    public const nint m_iPlayerState = 0xBFC; // CSPlayerState
    public const nint m_chickenIdleSoundTimer = 0xC08; // CountdownTimer
    public const nint m_chickenJumpSoundTimer = 0xC20; // CountdownTimer
    public const nint m_vecLastBookmarkedPosition = 0xCD8; // Vector
    public const nint m_flLastDistanceTraveledNotice = 0xCE4; // float
    public const nint m_flAccumulatedDistanceTraveled = 0xCE8; // float
    public const nint m_flLastFriendlyFireDamageReductionRatio = 0xCEC; // float
    public const nint m_bRespawning = 0xCF0; // bool
    public const nint m_nLastPickupPriority = 0xCF4; // int32_t
    public const nint m_flLastPickupPriorityTime = 0xCF8; // float
    public const nint m_bIsScoped = 0xCFC; // bool
    public const nint m_bIsWalking = 0xCFD; // bool
    public const nint m_bResumeZoom = 0xCFE; // bool
    public const nint m_bIsDefusing = 0xCFF; // bool
    public const nint m_bIsGrabbingHostage = 0xD00; // bool
    public const nint m_iBlockingUseActionInProgress = 0xD04; // CSPlayerBlockingUseAction_t
    public const nint m_fImmuneToGunGameDamageTime = 0xD08; // GameTime_t
    public const nint m_bGunGameImmunity = 0xD0C; // bool
    public const nint m_fMolotovDamageTime = 0xD10; // float
    public const nint m_bHasMovedSinceSpawn = 0xD14; // bool
    public const nint m_bCanMoveDuringFreezePeriod = 0xD15; // bool
    public const nint m_flGuardianTooFarDistFrac = 0xD18; // float
    public const nint m_flNextGuardianTooFarHurtTime = 0xD1C; // float
    public const nint m_flDetectedByEnemySensorTime = 0xD20; // GameTime_t
    public const nint m_flDealtDamageToEnemyMostRecentTimestamp = 0xD24; // float
    public const nint m_flLastEquippedHelmetTime = 0xD28; // GameTime_t
    public const nint m_flLastEquippedArmorTime = 0xD2C; // GameTime_t
    public const nint m_nHeavyAssaultSuitCooldownRemaining = 0xD30; // int32_t
    public const nint m_bResetArmorNextSpawn = 0xD34; // bool
    public const nint m_flLastBumpMineBumpTime = 0xD38; // GameTime_t
    public const nint m_flEmitSoundTime = 0xD3C; // GameTime_t
    public const nint m_iNumSpawns = 0xD40; // int32_t
    public const nint m_iShouldHaveCash = 0xD44; // int32_t
    public const nint m_bInvalidSteamLogonDelayed = 0xD48; // bool
    public const nint m_flLastAction = 0xD4C; // GameTime_t
    public const nint m_flNameChangeHistory = 0xD50; // float[5]
    public const nint m_fLastGivenDefuserTime = 0xD64; // float
    public const nint m_fLastGivenBombTime = 0xD68; // float
    public const nint m_bHasNightVision = 0xD6C; // bool
    public const nint m_bNightVisionOn = 0xD6D; // bool
    public const nint m_fNextRadarUpdateTime = 0xD70; // float
    public const nint m_flLastMoneyUpdateTime = 0xD74; // float
    public const nint m_MenuStringBuffer = 0xD78; // char[1024]
    public const nint m_fIntroCamTime = 0x1178; // float
    public const nint m_nMyCollisionGroup = 0x117C; // int32_t
    public const nint m_bInNoDefuseArea = 0x1180; // bool
    public const nint m_bKilledByTaser = 0x1181; // bool
    public const nint m_iMoveState = 0x1184; // int32_t
    public const nint m_grenadeParameterStashTime = 0x1188; // GameTime_t
    public const nint m_bGrenadeParametersStashed = 0x118C; // bool
    public const nint m_angStashedShootAngles = 0x1190; // QAngle
    public const nint m_vecStashedGrenadeThrowPosition = 0x119C; // Vector
    public const nint m_vecStashedVelocity = 0x11A8; // Vector
    public const nint m_angShootAngleHistory = 0x11B4; // QAngle[2]
    public const nint m_vecThrowPositionHistory = 0x11CC; // Vector[2]
    public const nint m_vecVelocityHistory = 0x11E4; // Vector[2]
    public const nint m_bDiedAirborne = 0x11FC; // bool
    public const nint m_iBombSiteIndex = 0x1200; // CEntityIndex
    public const nint m_nWhichBombZone = 0x1204; // int32_t
    public const nint m_bInBombZoneTrigger = 0x1208; // bool
    public const nint m_bWasInBombZoneTrigger = 0x1209; // bool
    public const nint m_iDirection = 0x120C; // int32_t
    public const nint m_iShotsFired = 0x1210; // int32_t
    public const nint m_ArmorValue = 0x1214; // int32_t
    public const nint m_flFlinchStack = 0x1218; // float
    public const nint m_flVelocityModifier = 0x121C; // float
    public const nint m_flHitHeading = 0x1220; // float
    public const nint m_nHitBodyPart = 0x1224; // int32_t
    public const nint m_iHostagesKilled = 0x1228; // int32_t
    public const nint m_vecTotalBulletForce = 0x122C; // Vector
    public const nint m_flFlashDuration = 0x1238; // float
    public const nint m_flFlashMaxAlpha = 0x123C; // float
    public const nint m_flProgressBarStartTime = 0x1240; // float
    public const nint m_iProgressBarDuration = 0x1244; // int32_t
    public const nint m_bWaitForNoAttack = 0x1248; // bool
    public const nint m_flLowerBodyYawTarget = 0x124C; // float
    public const nint m_bStrafing = 0x1250; // bool
    public const nint m_lastStandingPos = 0x1254; // Vector
    public const nint m_ignoreLadderJumpTime = 0x1260; // float
    public const nint m_ladderSurpressionTimer = 0x1268; // CountdownTimer
    public const nint m_lastLadderNormal = 0x1280; // Vector
    public const nint m_lastLadderPos = 0x128C; // Vector
    public const nint m_thirdPersonHeading = 0x1298; // QAngle
    public const nint m_flSlopeDropOffset = 0x12A4; // float
    public const nint m_flSlopeDropHeight = 0x12A8; // float
    public const nint m_vHeadConstraintOffset = 0x12AC; // Vector
    public const nint m_iLastWeaponFireUsercmd = 0x12C0; // int32_t
    public const nint m_angEyeAngles = 0x12C4; // QAngle
    public const nint m_bVCollisionInitted = 0x12D0; // bool
    public const nint m_storedSpawnPosition = 0x12D4; // Vector
    public const nint m_storedSpawnAngle = 0x12E0; // QAngle
    public const nint m_bIsSpawning = 0x12EC; // bool
    public const nint m_bHideTargetID = 0x12ED; // bool
    public const nint m_nNumDangerZoneDamageHits = 0x12F0; // int32_t
    public const nint m_bHud_MiniScoreHidden = 0x12F4; // bool
    public const nint m_bHud_RadarHidden = 0x12F5; // bool
    public const nint m_nLastKillerIndex = 0x12F8; // CEntityIndex
    public const nint m_nLastConcurrentKilled = 0x12FC; // int32_t
    public const nint m_nDeathCamMusic = 0x1300; // int32_t
    public const nint m_iAddonBits = 0x1304; // int32_t
    public const nint m_iPrimaryAddon = 0x1308; // int32_t
    public const nint m_iSecondaryAddon = 0x130C; // int32_t
    public const nint m_currentDeafnessFilter = 0x1310; // CUtlStringToken
    public const nint m_NumEnemiesKilledThisSpawn = 0x1314; // int32_t
    public const nint m_NumEnemiesKilledThisRound = 0x1318; // int32_t
    public const nint m_NumEnemiesAtRoundStart = 0x131C; // int32_t
    public const nint m_wasNotKilledNaturally = 0x1320; // bool
    public const nint m_vecPlayerPatchEconIndices = 0x1324; // uint32_t[5]
    public const nint m_iDeathFlags = 0x1338; // int32_t
    public const nint m_hPet = 0x133C; // CHandle<CChicken>
    public const nint m_unCurrentEquipmentValue = 0x1508; // uint16_t
    public const nint m_unRoundStartEquipmentValue = 0x150A; // uint16_t
    public const nint m_unFreezetimeEndEquipmentValue = 0x150C; // uint16_t
    public const nint m_nSurvivalTeamNumber = 0x1510; // int32_t
    public const nint m_bHasDeathInfo = 0x1514; // bool
    public const nint m_flDeathInfoTime = 0x1518; // float
    public const nint m_vecDeathInfoOrigin = 0x151C; // Vector
    public const nint m_bKilledByHeadshot = 0x1528; // bool
    public const nint m_LastHitBox = 0x152C; // int32_t
    public const nint m_LastHealth = 0x1530; // int32_t
    public const nint m_flLastCollisionCeiling = 0x1534; // float
    public const nint m_flLastCollisionCeilingChangeTime = 0x1538; // float
    public const nint m_pBot = 0x1540; // CCSBot*
    public const nint m_bBotAllowActive = 0x1548; // bool
    public const nint m_bCommittingSuicideOnTeamChange = 0x1549; // bool
}

public static class CCSPlayerResource {
    public const nint m_bHostageAlive = 0x4B0; // bool[12]
    public const nint m_isHostageFollowingSomeone = 0x4BC; // bool[12]
    public const nint m_iHostageEntityIDs = 0x4C8; // CEntityIndex[12]
    public const nint m_bombsiteCenterA = 0x4F8; // Vector
    public const nint m_bombsiteCenterB = 0x504; // Vector
    public const nint m_hostageRescueX = 0x510; // int32_t[4]
    public const nint m_hostageRescueY = 0x520; // int32_t[4]
    public const nint m_hostageRescueZ = 0x530; // int32_t[4]
    public const nint m_bEndMatchNextMapAllVoted = 0x540; // bool
    public const nint m_foundGoalPositions = 0x541; // bool
}

public static class CCSPlayer_ActionTrackingServices {
    public const nint m_hLastWeaponBeforeC4AutoSwitch = 0x208; // CHandle<CBasePlayerWeapon>
    public const nint m_bIsRescuing = 0x23C; // bool
    public const nint m_weaponPurchasesThisMatch = 0x240; // WeaponPurchaseTracker_t
    public const nint m_weaponPurchasesThisRound = 0x298; // WeaponPurchaseTracker_t
}

public static class CCSPlayer_BulletServices {
    public const nint m_totalHitsOnServer = 0x40; // int32_t
}

public static class CCSPlayer_BuyServices {
    public const nint m_vecSellbackPurchaseEntries = 0xC8; // CUtlVectorEmbeddedNetworkVar<SellbackPurchaseEntry_t>
}

public static class CCSPlayer_HostageServices {
    public const nint m_hCarriedHostage = 0x40; // CHandle<CBaseEntity>
    public const nint m_hCarriedHostageProp = 0x44; // CHandle<CBaseEntity>
}

public static class CCSPlayer_ItemServices {
    public const nint m_bHasDefuser = 0x40; // bool
    public const nint m_bHasHelmet = 0x41; // bool
    public const nint m_bHasHeavyArmor = 0x42; // bool
}

public static class CCSPlayer_MovementServices {
    public const nint m_flMaxFallVelocity = 0x220; // float
    public const nint m_vecLadderNormal = 0x224; // Vector
    public const nint m_nLadderSurfacePropIndex = 0x230; // int32_t
    public const nint m_flDuckAmount = 0x234; // float
    public const nint m_flDuckSpeed = 0x238; // float
    public const nint m_bDuckOverride = 0x23C; // bool
    public const nint m_bDesiresDuck = 0x23D; // bool
    public const nint m_flDuckOffset = 0x240; // float
    public const nint m_nDuckTimeMsecs = 0x244; // uint32_t
    public const nint m_nDuckJumpTimeMsecs = 0x248; // uint32_t
    public const nint m_nJumpTimeMsecs = 0x24C; // uint32_t
    public const nint m_flLastDuckTime = 0x250; // float
    public const nint m_vecLastPositionAtFullCrouchSpeed = 0x260; // Vector2D
    public const nint m_duckUntilOnGround = 0x268; // bool
    public const nint m_bHasWalkMovedSinceLastJump = 0x269; // bool
    public const nint m_bInStuckTest = 0x26A; // bool
    public const nint m_flStuckCheckTime = 0x278; // float[64][2]
    public const nint m_nTraceCount = 0x478; // int32_t
    public const nint m_StuckLast = 0x47C; // int32_t
    public const nint m_bSpeedCropped = 0x480; // bool
    public const nint m_nOldWaterLevel = 0x484; // int32_t
    public const nint m_flWaterEntryTime = 0x488; // float
    public const nint m_vecForward = 0x48C; // Vector
    public const nint m_vecLeft = 0x498; // Vector
    public const nint m_vecUp = 0x4A4; // Vector
    public const nint m_vecPreviouslyPredictedOrigin = 0x4B0; // Vector
    public const nint m_bMadeFootstepNoise = 0x4BC; // bool
    public const nint m_iFootsteps = 0x4C0; // int32_t
    public const nint m_bOldJumpPressed = 0x4C4; // bool
    public const nint m_flJumpPressedTime = 0x4C8; // float
    public const nint m_flJumpUntil = 0x4CC; // float
    public const nint m_flJumpVel = 0x4D0; // float
    public const nint m_fStashGrenadeParameterWhen = 0x4D4; // GameTime_t
    public const nint m_nButtonDownMaskPrev = 0x4D8; // uint64_t
    public const nint m_flOffsetTickCompleteTime = 0x4E0; // float
    public const nint m_flOffsetTickStashedSpeed = 0x4E4; // float
    public const nint m_flStamina = 0x4E8; // float
    public const nint m_flHeightAtJumpStart = 0x4EC; // float
    public const nint m_flMaxJumpHeightThisJump = 0x4F0; // float
}

public static class CCSPlayer_PingServices {
    public const nint m_flPlayerPingTokens = 0x40; // GameTime_t[5]
    public const nint m_hPlayerPing = 0x54; // CHandle<CBaseEntity>
}

public static class CCSPlayer_RadioServices {
    public const nint m_flGotHostageTalkTimer = 0x40; // GameTime_t
    public const nint m_flDefusingTalkTimer = 0x44; // GameTime_t
    public const nint m_flC4PlantTalkTimer = 0x48; // GameTime_t
    public const nint m_flRadioTokenSlots = 0x4C; // GameTime_t[3]
    public const nint m_bIgnoreRadio = 0x58; // bool
}

public static class CCSPlayer_UseServices {
    public const nint m_hLastKnownUseEntity = 0x40; // CHandle<CBaseEntity>
    public const nint m_flLastUseTimeStamp = 0x44; // GameTime_t
    public const nint m_flTimeStartedHoldingUse = 0x48; // GameTime_t
    public const nint m_flTimeLastUsedWindow = 0x4C; // GameTime_t
}

public static class CCSPlayer_ViewModelServices {
    public const nint m_hViewModel = 0x40; // CHandle<CBaseViewModel>[3]
}

public static class CCSPlayer_WaterServices {
    public const nint m_NextDrownDamageTime = 0x40; // float
    public const nint m_nDrownDmgRate = 0x44; // int32_t
    public const nint m_AirFinishedTime = 0x48; // GameTime_t
    public const nint m_flWaterJumpTime = 0x4C; // float
    public const nint m_vecWaterJumpVel = 0x50; // Vector
    public const nint m_flSwimSoundTime = 0x5C; // float
}

public static class CCSPlayer_WeaponServices {
    public const nint m_flNextAttack = 0xB0; // GameTime_t
    public const nint m_bIsLookingAtWeapon = 0xB4; // bool
    public const nint m_bIsHoldingLookAtWeapon = 0xB5; // bool
    public const nint m_hSavedWeapon = 0xB8; // CHandle<CBasePlayerWeapon>
    public const nint m_nTimeToMelee = 0xBC; // int32_t
    public const nint m_nTimeToSecondary = 0xC0; // int32_t
    public const nint m_nTimeToPrimary = 0xC4; // int32_t
    public const nint m_nTimeToSniperRifle = 0xC8; // int32_t
    public const nint m_bIsBeingGivenItem = 0xCC; // bool
    public const nint m_bIsPickingUpItemWithUse = 0xCD; // bool
    public const nint m_bPickedUpWeapon = 0xCE; // bool
}

public static class CCSTeam {
    public const nint m_nLastRecievedShorthandedRoundBonus = 0x568; // int32_t
    public const nint m_nShorthandedRoundBonusStartRound = 0x56C; // int32_t
    public const nint m_bSurrendered = 0x570; // bool
    public const nint m_szTeamMatchStat = 0x571; // char[512]
    public const nint m_numMapVictories = 0x774; // int32_t
    public const nint m_scoreFirstHalf = 0x778; // int32_t
    public const nint m_scoreSecondHalf = 0x77C; // int32_t
    public const nint m_scoreOvertime = 0x780; // int32_t
    public const nint m_szClanTeamname = 0x784; // char[129]
    public const nint m_iClanID = 0x808; // uint32_t
    public const nint m_szTeamFlagImage = 0x80C; // char[8]
    public const nint m_szTeamLogoImage = 0x814; // char[8]
    public const nint m_flNextResourceTime = 0x81C; // float
    public const nint m_iLastUpdateSentAt = 0x820; // int32_t
}

public static class CCSWeaponBase {
    public const nint m_bRemoveable = 0xC88; // bool
    public const nint m_flFireSequenceStartTime = 0xC90; // float
    public const nint m_nFireSequenceStartTimeChange = 0xC94; // int32_t
    public const nint m_nFireSequenceStartTimeAck = 0xC98; // int32_t
    public const nint m_bPlayerFireEventIsPrimary = 0xC9C; // bool
    public const nint m_seqIdle = 0xCA0; // HSequence
    public const nint m_seqFirePrimary = 0xCA4; // HSequence
    public const nint m_seqFireSecondary = 0xCA8; // HSequence
    public const nint m_thirdPersonFireSequences = 0xCB0; // CUtlVector<HSequence>
    public const nint m_hCurrentThirdPersonSequence = 0xCC8; // HSequence
    public const nint m_nSilencerBoneIndex = 0xCCC; // int32_t
    public const nint m_thirdPersonSequences = 0xCD0; // HSequence[6]
    public const nint m_bPlayerAmmoStockOnPickup = 0xCF0; // bool
    public const nint m_bRequireUseToTouch = 0xCF1; // bool
    public const nint m_iState = 0xCF4; // CSWeaponState_t
    public const nint m_flLastTimeInAir = 0xCF8; // GameTime_t
    public const nint m_flLastDeployTime = 0xCFC; // GameTime_t
    public const nint m_nViewModelIndex = 0xD00; // uint32_t
    public const nint m_bReloadsWithClips = 0xD04; // bool
    public const nint m_flTimeWeaponIdle = 0xD20; // GameTime_t
    public const nint m_bFireOnEmpty = 0xD24; // bool
    public const nint m_OnPlayerPickup = 0xD28; // CEntityIOOutput
    public const nint m_weaponMode = 0xD50; // CSWeaponMode
    public const nint m_flTurningInaccuracyDelta = 0xD54; // float
    public const nint m_vecTurningInaccuracyEyeDirLast = 0xD58; // Vector
    public const nint m_flTurningInaccuracy = 0xD64; // float
    public const nint m_fAccuracyPenalty = 0xD68; // float
    public const nint m_flLastAccuracyUpdateTime = 0xD6C; // GameTime_t
    public const nint m_fAccuracySmoothedForZoom = 0xD70; // float
    public const nint m_fScopeZoomEndTime = 0xD74; // GameTime_t
    public const nint m_iRecoilIndex = 0xD78; // int32_t
    public const nint m_flRecoilIndex = 0xD7C; // float
    public const nint m_bBurstMode = 0xD80; // bool
    public const nint m_flPostponeFireReadyTime = 0xD84; // GameTime_t
    public const nint m_bInReload = 0xD88; // bool
    public const nint m_bReloadVisuallyComplete = 0xD89; // bool
    public const nint m_flDroppedAtTime = 0xD8C; // GameTime_t
    public const nint m_bIsHauledBack = 0xD90; // bool
    public const nint m_bSilencerOn = 0xD91; // bool
    public const nint m_flTimeSilencerSwitchComplete = 0xD94; // GameTime_t
    public const nint m_iOriginalTeamNumber = 0xD98; // int32_t
    public const nint m_flNextAttackRenderTimeOffset = 0xD9C; // float
    public const nint m_bCanBePickedUp = 0xDB0; // bool
    public const nint m_bUseCanOverrideNextOwnerTouchTime = 0xDB1; // bool
    public const nint m_nextOwnerTouchTime = 0xDB4; // GameTime_t
    public const nint m_nextPrevOwnerTouchTime = 0xDB8; // GameTime_t
    public const nint m_hPrevOwner = 0xDBC; // CHandle<CCSPlayerPawn>
    public const nint m_nDropTick = 0xDC0; // GameTick_t
    public const nint m_donated = 0xDE4; // bool
    public const nint m_fLastShotTime = 0xDE8; // GameTime_t
    public const nint m_bWasOwnedByCT = 0xDEC; // bool
    public const nint m_bWasOwnedByTerrorist = 0xDED; // bool
    public const nint m_bFiredOutOfAmmoEvent = 0xDEE; // bool
    public const nint m_numRemoveUnownedWeaponThink = 0xDF0; // int32_t
    public const nint m_IronSightController = 0xDF8; // CIronSightController
    public const nint m_iIronSightMode = 0xE10; // int32_t
    public const nint m_flLastLOSTraceFailureTime = 0xE14; // GameTime_t
    public const nint m_iNumEmptyAttacks = 0xE18; // int32_t
}

public static class CCSWeaponBaseGun {
    public const nint m_zoomLevel = 0xE20; // int32_t
    public const nint m_iBurstShotsRemaining = 0xE24; // int32_t
    public const nint m_silencedModelIndex = 0xE30; // int32_t
    public const nint m_inPrecache = 0xE34; // bool
    public const nint m_bNeedsBoltAction = 0xE35; // bool
    public const nint m_bSkillReloadAvailable = 0xE36; // bool
    public const nint m_bSkillReloadLiftedReloadKey = 0xE37; // bool
    public const nint m_bSkillBoltInterruptAvailable = 0xE38; // bool
    public const nint m_bSkillBoltLiftedFireKey = 0xE39; // bool
}

public static class CCSWeaponBaseVData {
    public const nint m_WeaponType = 0x240; // CSWeaponType
    public const nint m_WeaponCategory = 0x244; // CSWeaponCategory
    public const nint m_szViewModel = 0x248; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    public const nint m_szPlayerModel = 0x328; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    public const nint m_szWorldDroppedModel = 0x408; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    public const nint m_szAimsightLensMaskModel = 0x4E8; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    public const nint m_szMagazineModel = 0x5C8; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    public const nint m_szHeatEffect = 0x6A8; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    public const nint m_szEjectBrassEffect = 0x788; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    public const nint m_szMuzzleFlashParticleAlt = 0x868; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    public const nint m_szMuzzleFlashThirdPersonParticle = 0x948; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    public const nint m_szMuzzleFlashThirdPersonParticleAlt = 0xA28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    public const nint m_szTracerParticle = 0xB08; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    public const nint m_GearSlot = 0xBE8; // gear_slot_t
    public const nint m_GearSlotPosition = 0xBEC; // int32_t
    public const nint m_DefaultLoadoutSlot = 0xBF0; // loadout_slot_t
    public const nint m_sWrongTeamMsg = 0xBF8; // CUtlString
    public const nint m_nPrice = 0xC00; // int32_t
    public const nint m_nKillAward = 0xC04; // int32_t
    public const nint m_nPrimaryReserveAmmoMax = 0xC08; // int32_t
    public const nint m_nSecondaryReserveAmmoMax = 0xC0C; // int32_t
    public const nint m_bMeleeWeapon = 0xC10; // bool
    public const nint m_bHasBurstMode = 0xC11; // bool
    public const nint m_bIsRevolver = 0xC12; // bool
    public const nint m_bCannotShootUnderwater = 0xC13; // bool
    public const nint m_szName = 0xC18; // CUtlString
    public const nint m_szAnimExtension = 0xC20; // CUtlString
    public const nint m_eSilencerType = 0xC28; // CSWeaponSilencerType
    public const nint m_nCrosshairMinDistance = 0xC2C; // int32_t
    public const nint m_nCrosshairDeltaDistance = 0xC30; // int32_t
    public const nint m_flCycleTime = 0xC34; // CFiringModeFloat
    public const nint m_flMaxSpeed = 0xC3C; // CFiringModeFloat
    public const nint m_flSpread = 0xC44; // CFiringModeFloat
    public const nint m_flInaccuracyCrouch = 0xC4C; // CFiringModeFloat
    public const nint m_flInaccuracyStand = 0xC54; // CFiringModeFloat
    public const nint m_flInaccuracyJump = 0xC5C; // CFiringModeFloat
    public const nint m_flInaccuracyLand = 0xC64; // CFiringModeFloat
    public const nint m_flInaccuracyLadder = 0xC6C; // CFiringModeFloat
    public const nint m_flInaccuracyFire = 0xC74; // CFiringModeFloat
    public const nint m_flInaccuracyMove = 0xC7C; // CFiringModeFloat
    public const nint m_flRecoilAngle = 0xC84; // CFiringModeFloat
    public const nint m_flRecoilAngleVariance = 0xC8C; // CFiringModeFloat
    public const nint m_flRecoilMagnitude = 0xC94; // CFiringModeFloat
    public const nint m_flRecoilMagnitudeVariance = 0xC9C; // CFiringModeFloat
    public const nint m_nTracerFrequency = 0xCA4; // CFiringModeInt
    public const nint m_flInaccuracyJumpInitial = 0xCAC; // float
    public const nint m_flInaccuracyJumpApex = 0xCB0; // float
    public const nint m_flInaccuracyReload = 0xCB4; // float
    public const nint m_nRecoilSeed = 0xCB8; // int32_t
    public const nint m_nSpreadSeed = 0xCBC; // int32_t
    public const nint m_flTimeToIdleAfterFire = 0xCC0; // float
    public const nint m_flIdleInterval = 0xCC4; // float
    public const nint m_flAttackMovespeedFactor = 0xCC8; // float
    public const nint m_flHeatPerShot = 0xCCC; // float
    public const nint m_flInaccuracyPitchShift = 0xCD0; // float
    public const nint m_flInaccuracyAltSoundThreshold = 0xCD4; // float
    public const nint m_flBotAudibleRange = 0xCD8; // float
    public const nint m_szUseRadioSubtitle = 0xCE0; // CUtlString
    public const nint m_bUnzoomsAfterShot = 0xCE8; // bool
    public const nint m_bHideViewModelWhenZoomed = 0xCE9; // bool
    public const nint m_nZoomLevels = 0xCEC; // int32_t
    public const nint m_nZoomFOV1 = 0xCF0; // int32_t
    public const nint m_nZoomFOV2 = 0xCF4; // int32_t
    public const nint m_flZoomTime0 = 0xCF8; // float
    public const nint m_flZoomTime1 = 0xCFC; // float
    public const nint m_flZoomTime2 = 0xD00; // float
    public const nint m_flIronSightPullUpSpeed = 0xD04; // float
    public const nint m_flIronSightPutDownSpeed = 0xD08; // float
    public const nint m_flIronSightFOV = 0xD0C; // float
    public const nint m_flIronSightPivotForward = 0xD10; // float
    public const nint m_flIronSightLooseness = 0xD14; // float
    public const nint m_angPivotAngle = 0xD18; // QAngle
    public const nint m_vecIronSightEyePos = 0xD24; // Vector
    public const nint m_nDamage = 0xD30; // int32_t
    public const nint m_flHeadshotMultiplier = 0xD34; // float
    public const nint m_flArmorRatio = 0xD38; // float
    public const nint m_flPenetration = 0xD3C; // float
    public const nint m_flRange = 0xD40; // float
    public const nint m_flRangeModifier = 0xD44; // float
    public const nint m_flFlinchVelocityModifierLarge = 0xD48; // float
    public const nint m_flFlinchVelocityModifierSmall = 0xD4C; // float
    public const nint m_flRecoveryTimeCrouch = 0xD50; // float
    public const nint m_flRecoveryTimeStand = 0xD54; // float
    public const nint m_flRecoveryTimeCrouchFinal = 0xD58; // float
    public const nint m_flRecoveryTimeStandFinal = 0xD5C; // float
    public const nint m_nRecoveryTransitionStartBullet = 0xD60; // int32_t
    public const nint m_nRecoveryTransitionEndBullet = 0xD64; // int32_t
    public const nint m_flThrowVelocity = 0xD68; // float
    public const nint m_vSmokeColor = 0xD6C; // Vector
    public const nint m_szAnimClass = 0xD78; // CUtlString
}

public static class CChangeLevel {
    public const nint m_sMapName = 0x8A8; // CUtlString
    public const nint m_sLandmarkName = 0x8B0; // CUtlString
    public const nint m_OnChangeLevel = 0x8B8; // CEntityIOOutput
    public const nint m_bTouched = 0x8E0; // bool
    public const nint m_bNoTouch = 0x8E1; // bool
    public const nint m_bNewChapter = 0x8E2; // bool
    public const nint m_bOnChangeLevelFired = 0x8E3; // bool
}

public static class CChicken {
    public const nint m_AttributeManager = 0xB28; // CAttributeContainer
    public const nint m_OriginalOwnerXuidLow = 0xDF0; // uint32_t
    public const nint m_OriginalOwnerXuidHigh = 0xDF4; // uint32_t
    public const nint m_updateTimer = 0xDF8; // CountdownTimer
    public const nint m_stuckAnchor = 0xE10; // Vector
    public const nint m_stuckTimer = 0xE20; // CountdownTimer
    public const nint m_collisionStuckTimer = 0xE38; // CountdownTimer
    public const nint m_isOnGround = 0xE50; // bool
    public const nint m_vFallVelocity = 0xE54; // Vector
    public const nint m_activity = 0xE60; // ChickenActivity
    public const nint m_activityTimer = 0xE68; // CountdownTimer
    public const nint m_turnRate = 0xE80; // float
    public const nint m_fleeFrom = 0xE84; // CHandle<CBaseEntity>
    public const nint m_moveRateThrottleTimer = 0xE88; // CountdownTimer
    public const nint m_startleTimer = 0xEA0; // CountdownTimer
    public const nint m_vocalizeTimer = 0xEB8; // CountdownTimer
    public const nint m_flWhenZombified = 0xED0; // GameTime_t
    public const nint m_jumpedThisFrame = 0xED4; // bool
    public const nint m_leader = 0xED8; // CHandle<CCSPlayerPawn>
    public const nint m_reuseTimer = 0xEE0; // CountdownTimer
    public const nint m_hasBeenUsed = 0xEF8; // bool
    public const nint m_jumpTimer = 0xF00; // CountdownTimer
    public const nint m_flLastJumpTime = 0xF18; // float
    public const nint m_bInJump = 0xF1C; // bool
    public const nint m_isWaitingForLeader = 0xF1D; // bool
    public const nint m_repathTimer = 0x2F28; // CountdownTimer
    public const nint m_inhibitDoorTimer = 0x2F40; // CountdownTimer
    public const nint m_inhibitObstacleAvoidanceTimer = 0x2FD0; // CountdownTimer
    public const nint m_vecPathGoal = 0x2FF0; // Vector
    public const nint m_flActiveFollowStartTime = 0x2FFC; // GameTime_t
    public const nint m_followMinuteTimer = 0x3000; // CountdownTimer
    public const nint m_vecLastEggPoopPosition = 0x3018; // Vector
    public const nint m_vecEggsPooped = 0x3028; // CUtlVector<CHandle<CBaseEntity>>
    public const nint m_BlockDirectionTimer = 0x3048; // CountdownTimer
}

public static class CCollisionProperty {
    public const nint m_collisionAttribute = 0x10; // VPhysicsCollisionAttribute_t
    public const nint m_vecMins = 0x40; // Vector
    public const nint m_vecMaxs = 0x4C; // Vector
    public const nint m_usSolidFlags = 0x5A; // uint8_t
    public const nint m_nSolidType = 0x5B; // SolidType_t
    public const nint m_triggerBloat = 0x5C; // uint8_t
    public const nint m_nSurroundType = 0x5D; // SurroundingBoundsType_t
    public const nint m_CollisionGroup = 0x5E; // uint8_t
    public const nint m_nEnablePhysics = 0x5F; // uint8_t
    public const nint m_flBoundingRadius = 0x60; // float
    public const nint m_vecSpecifiedSurroundingMins = 0x64; // Vector
    public const nint m_vecSpecifiedSurroundingMaxs = 0x70; // Vector
    public const nint m_vecSurroundingMaxs = 0x7C; // Vector
    public const nint m_vecSurroundingMins = 0x88; // Vector
    public const nint m_vCapsuleCenter1 = 0x94; // Vector
    public const nint m_vCapsuleCenter2 = 0xA0; // Vector
    public const nint m_flCapsuleRadius = 0xAC; // float
}

public static class CColorCorrection {
    public const nint m_flFadeInDuration = 0x4B0; // float
    public const nint m_flFadeOutDuration = 0x4B4; // float
    public const nint m_flStartFadeInWeight = 0x4B8; // float
    public const nint m_flStartFadeOutWeight = 0x4BC; // float
    public const nint m_flTimeStartFadeIn = 0x4C0; // GameTime_t
    public const nint m_flTimeStartFadeOut = 0x4C4; // GameTime_t
    public const nint m_flMaxWeight = 0x4C8; // float
    public const nint m_bStartDisabled = 0x4CC; // bool
    public const nint m_bEnabled = 0x4CD; // bool
    public const nint m_bMaster = 0x4CE; // bool
    public const nint m_bClientSide = 0x4CF; // bool
    public const nint m_bExclusive = 0x4D0; // bool
    public const nint m_MinFalloff = 0x4D4; // float
    public const nint m_MaxFalloff = 0x4D8; // float
    public const nint m_flCurWeight = 0x4DC; // float
    public const nint m_netlookupFilename = 0x4E0; // char[512]
    public const nint m_lookupFilename = 0x6E0; // CUtlSymbolLarge
}

public static class CColorCorrectionVolume {
    public const nint m_bEnabled = 0x8A8; // bool
    public const nint m_MaxWeight = 0x8AC; // float
    public const nint m_FadeDuration = 0x8B0; // float
    public const nint m_bStartDisabled = 0x8B4; // bool
    public const nint m_Weight = 0x8B8; // float
    public const nint m_lookupFilename = 0x8BC; // char[512]
    public const nint m_LastEnterWeight = 0xABC; // float
    public const nint m_LastEnterTime = 0xAC0; // GameTime_t
    public const nint m_LastExitWeight = 0xAC4; // float
    public const nint m_LastExitTime = 0xAC8; // GameTime_t
}

public static class CCommentaryAuto {
    public const nint m_OnCommentaryNewGame = 0x4B0; // CEntityIOOutput
    public const nint m_OnCommentaryMidGame = 0x4D8; // CEntityIOOutput
    public const nint m_OnCommentaryMultiplayerSpawn = 0x500; // CEntityIOOutput
}

public static class CCommentarySystem {
    public const nint m_bCommentaryConvarsChanging = 0x11; // bool
    public const nint m_bCommentaryEnabledMidGame = 0x12; // bool
    public const nint m_flNextTeleportTime = 0x14; // GameTime_t
    public const nint m_iTeleportStage = 0x18; // int32_t
    public const nint m_bCheatState = 0x1C; // bool
    public const nint m_bIsFirstSpawnGroupToLoad = 0x1D; // bool
    public const nint m_hCurrentNode = 0x38; // CHandle<CPointCommentaryNode>
    public const nint m_hActiveCommentaryNode = 0x3C; // CHandle<CPointCommentaryNode>
    public const nint m_hLastCommentaryNode = 0x40; // CHandle<CPointCommentaryNode>
    public const nint m_vecNodes = 0x48; // CUtlVector<CHandle<CPointCommentaryNode>>
}

public static class CConstantForceController {
    public const nint m_linear = 0xC; // Vector
    public const nint m_angular = 0x18; // RotationVector
    public const nint m_linearSave = 0x24; // Vector
    public const nint m_angularSave = 0x30; // RotationVector
}

public static class CConstraintAnchor {
    public const nint m_massScale = 0x890; // float
}

public static class CCopyRecipientFilter {
    public const nint m_Flags = 0x8; // int32_t
    public const nint m_Recipients = 0x10; // CUtlVector<CPlayerSlot>
}

public static class CCredits {
    public const nint m_OnCreditsDone = 0x4B0; // CEntityIOOutput
    public const nint m_bRolledOutroCredits = 0x4D8; // bool
    public const nint m_flLogoLength = 0x4DC; // float
}

public static class CDamageRecord {
    public const nint m_PlayerDamager = 0x28; // CHandle<CCSPlayerPawnBase>
    public const nint m_PlayerRecipient = 0x2C; // CHandle<CCSPlayerPawnBase>
    public const nint m_hPlayerControllerDamager = 0x30; // CHandle<CCSPlayerController>
    public const nint m_hPlayerControllerRecipient = 0x34; // CHandle<CCSPlayerController>
    public const nint m_szPlayerDamagerName = 0x38; // CUtlString
    public const nint m_szPlayerRecipientName = 0x40; // CUtlString
    public const nint m_DamagerXuid = 0x48; // uint64_t
    public const nint m_RecipientXuid = 0x50; // uint64_t
    public const nint m_iDamage = 0x58; // int32_t
    public const nint m_iActualHealthRemoved = 0x5C; // int32_t
    public const nint m_iNumHits = 0x60; // int32_t
    public const nint m_iLastBulletUpdate = 0x64; // int32_t
    public const nint m_bIsOtherEnemy = 0x68; // bool
    public const nint m_killType = 0x69; // EKillTypes_t
}

public static class CDebugHistory {
    public const nint m_nNpcEvents = 0x44F0; // int32_t
}

public static class CDecoyProjectile {
    public const nint m_nDecoyShotTick = 0xA48; // int32_t
    public const nint m_shotsRemaining = 0xA4C; // int32_t
    public const nint m_fExpireTime = 0xA50; // GameTime_t
    public const nint m_decoyWeaponDefIndex = 0xA60; // uint16_t
}

public static class CDynamicLight {
    public const nint m_ActualFlags = 0x700; // uint8_t
    public const nint m_Flags = 0x701; // uint8_t
    public const nint m_LightStyle = 0x702; // uint8_t
    public const nint m_On = 0x703; // bool
    public const nint m_Radius = 0x704; // float
    public const nint m_Exponent = 0x708; // int32_t
    public const nint m_InnerAngle = 0x70C; // float
    public const nint m_OuterAngle = 0x710; // float
    public const nint m_SpotRadius = 0x714; // float
}

public static class CDynamicProp {
    public const nint m_bCreateNavObstacle = 0xA10; // bool
    public const nint m_bUseHitboxesForRenderBox = 0xA11; // bool
    public const nint m_bUseAnimGraph = 0xA12; // bool
    public const nint m_pOutputAnimBegun = 0xA18; // CEntityIOOutput
    public const nint m_pOutputAnimOver = 0xA40; // CEntityIOOutput
    public const nint m_pOutputAnimLoopCycleOver = 0xA68; // CEntityIOOutput
    public const nint m_OnAnimReachedStart = 0xA90; // CEntityIOOutput
    public const nint m_OnAnimReachedEnd = 0xAB8; // CEntityIOOutput
    public const nint m_iszDefaultAnim = 0xAE0; // CUtlSymbolLarge
    public const nint m_nDefaultAnimLoopMode = 0xAE8; // AnimLoopMode_t
    public const nint m_bAnimateOnServer = 0xAEC; // bool
    public const nint m_bRandomizeCycle = 0xAED; // bool
    public const nint m_bStartDisabled = 0xAEE; // bool
    public const nint m_bScriptedMovement = 0xAEF; // bool
    public const nint m_bFiredStartEndOutput = 0xAF0; // bool
    public const nint m_bForceNpcExclude = 0xAF1; // bool
    public const nint m_bCreateNonSolid = 0xAF2; // bool
    public const nint m_bIsOverrideProp = 0xAF3; // bool
    public const nint m_iInitialGlowState = 0xAF4; // int32_t
    public const nint m_nGlowRange = 0xAF8; // int32_t
    public const nint m_nGlowRangeMin = 0xAFC; // int32_t
    public const nint m_glowColor = 0xB00; // Color
    public const nint m_nGlowTeam = 0xB04; // int32_t
}

public static class CEconEntity {
    public const nint m_AttributeManager = 0x930; // CAttributeContainer
    public const nint m_OriginalOwnerXuidLow = 0xBF8; // uint32_t
    public const nint m_OriginalOwnerXuidHigh = 0xBFC; // uint32_t
    public const nint m_nFallbackPaintKit = 0xC00; // int32_t
    public const nint m_nFallbackSeed = 0xC04; // int32_t
    public const nint m_flFallbackWear = 0xC08; // float
    public const nint m_nFallbackStatTrak = 0xC0C; // int32_t
    public const nint m_hOldProvidee = 0xC10; // CHandle<CBaseEntity>
    public const nint m_iOldOwnerClass = 0xC14; // int32_t
}

public static class CEconItemAttribute {
    public const nint m_iAttributeDefinitionIndex = 0x30; // uint16_t
    public const nint m_flValue = 0x34; // float
    public const nint m_flInitialValue = 0x38; // float
    public const nint m_nRefundableCurrency = 0x3C; // int32_t
    public const nint m_bSetBonus = 0x40; // bool
}

public static class CEconItemView {
    public const nint m_iItemDefinitionIndex = 0x38; // uint16_t
    public const nint m_iEntityQuality = 0x3C; // int32_t
    public const nint m_iEntityLevel = 0x40; // uint32_t
    public const nint m_iItemID = 0x48; // uint64_t
    public const nint m_iItemIDHigh = 0x50; // uint32_t
    public const nint m_iItemIDLow = 0x54; // uint32_t
    public const nint m_iAccountID = 0x58; // uint32_t
    public const nint m_iInventoryPosition = 0x5C; // uint32_t
    public const nint m_bInitialized = 0x68; // bool
    public const nint m_AttributeList = 0x70; // CAttributeList
    public const nint m_NetworkedDynamicAttributes = 0xD0; // CAttributeList
    public const nint m_szCustomName = 0x130; // char[161]
    public const nint m_szCustomNameOverride = 0x1D1; // char[161]
}

public static class CEconWearable {
    public const nint m_nForceSkin = 0xC18; // int32_t
    public const nint m_bAlwaysAllow = 0xC1C; // bool
}

public static class CEffectData {
    public const nint m_vOrigin = 0x8; // Vector
    public const nint m_vStart = 0x14; // Vector
    public const nint m_vNormal = 0x20; // Vector
    public const nint m_vAngles = 0x2C; // QAngle
    public const nint m_hEntity = 0x38; // CEntityHandle
    public const nint m_hOtherEntity = 0x3C; // CEntityHandle
    public const nint m_flScale = 0x40; // float
    public const nint m_flMagnitude = 0x44; // float
    public const nint m_flRadius = 0x48; // float
    public const nint m_nSurfaceProp = 0x4C; // CUtlStringToken
    public const nint m_nEffectIndex = 0x50; // CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>
    public const nint m_nDamageType = 0x58; // uint32_t
    public const nint m_nPenetrate = 0x5C; // uint8_t
    public const nint m_nMaterial = 0x5E; // uint16_t
    public const nint m_nHitBox = 0x60; // uint16_t
    public const nint m_nColor = 0x62; // uint8_t
    public const nint m_fFlags = 0x63; // uint8_t
    public const nint m_nAttachmentIndex = 0x64; // AttachmentHandle_t
    public const nint m_nAttachmentName = 0x68; // CUtlStringToken
    public const nint m_iEffectName = 0x6C; // uint16_t
    public const nint m_nExplosionType = 0x6E; // uint8_t
}

public static class CEntityDissolve {
    public const nint m_flFadeInStart = 0x700; // float
    public const nint m_flFadeInLength = 0x704; // float
    public const nint m_flFadeOutModelStart = 0x708; // float
    public const nint m_flFadeOutModelLength = 0x70C; // float
    public const nint m_flFadeOutStart = 0x710; // float
    public const nint m_flFadeOutLength = 0x714; // float
    public const nint m_flStartTime = 0x718; // GameTime_t
    public const nint m_nDissolveType = 0x71C; // EntityDisolveType_t
    public const nint m_vDissolverOrigin = 0x720; // Vector
    public const nint m_nMagnitude = 0x72C; // uint32_t
}

public static class CEntityFlame {
    public const nint m_hEntAttached = 0x4B0; // CHandle<CBaseEntity>
    public const nint m_bCheapEffect = 0x4B4; // bool
    public const nint m_flSize = 0x4B8; // float
    public const nint m_bUseHitboxes = 0x4BC; // bool
    public const nint m_iNumHitboxFires = 0x4C0; // int32_t
    public const nint m_flHitboxFireScale = 0x4C4; // float
    public const nint m_flLifetime = 0x4C8; // GameTime_t
    public const nint m_hAttacker = 0x4CC; // CHandle<CBaseEntity>
    public const nint m_iDangerSound = 0x4D0; // int32_t
    public const nint m_flDirectDamagePerSecond = 0x4D4; // float
    public const nint m_iCustomDamageType = 0x4D8; // int32_t
}

public static class CEntityIdentity {
    public const nint m_nameStringableIndex = 0x14; // int32_t
    public const nint m_name = 0x18; // CUtlSymbolLarge
    public const nint m_designerName = 0x20; // CUtlSymbolLarge
    public const nint m_flags = 0x30; // uint32_t
    public const nint m_worldGroupId = 0x38; // WorldGroupId_t
    public const nint m_fDataObjectTypes = 0x3C; // uint32_t
    public const nint m_PathIndex = 0x40; // ChangeAccessorFieldPathIndex_t
    public const nint m_pPrev = 0x58; // CEntityIdentity*
    public const nint m_pNext = 0x60; // CEntityIdentity*
    public const nint m_pPrevByClass = 0x68; // CEntityIdentity*
    public const nint m_pNextByClass = 0x70; // CEntityIdentity*
}

public static class CEntityInstance {
    public const nint m_iszPrivateVScripts = 0x8; // CUtlSymbolLarge
    public const nint m_pEntity = 0x10; // CEntityIdentity*
    public const nint m_CScriptComponent = 0x28; // CScriptComponent*
}

public static class CEnvBeam {
    public const nint m_active = 0x7A0; // int32_t
    public const nint m_spriteTexture = 0x7A8; // CStrongHandle<InfoForResourceTypeIMaterial2>
    public const nint m_iszStartEntity = 0x7B0; // CUtlSymbolLarge
    public const nint m_iszEndEntity = 0x7B8; // CUtlSymbolLarge
    public const nint m_life = 0x7C0; // float
    public const nint m_boltWidth = 0x7C4; // float
    public const nint m_noiseAmplitude = 0x7C8; // float
    public const nint m_speed = 0x7CC; // int32_t
    public const nint m_restrike = 0x7D0; // float
    public const nint m_iszSpriteName = 0x7D8; // CUtlSymbolLarge
    public const nint m_frameStart = 0x7E0; // int32_t
    public const nint m_vEndPointWorld = 0x7E4; // Vector
    public const nint m_vEndPointRelative = 0x7F0; // Vector
    public const nint m_radius = 0x7FC; // float
    public const nint m_TouchType = 0x800; // Touch_t
    public const nint m_iFilterName = 0x808; // CUtlSymbolLarge
    public const nint m_hFilter = 0x810; // CHandle<CBaseEntity>
    public const nint m_iszDecal = 0x818; // CUtlSymbolLarge
    public const nint m_OnTouchedByEntity = 0x820; // CEntityIOOutput
}

public static class CEnvBeverage {
    public const nint m_CanInDispenser = 0x4B0; // bool
    public const nint m_nBeverageType = 0x4B4; // int32_t
}

public static class CEnvCombinedLightProbeVolume {
    public const nint m_Color = 0x1508; // Color
    public const nint m_flBrightness = 0x150C; // float
    public const nint m_hCubemapTexture = 0x1510; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_bCustomCubemapTexture = 0x1518; // bool
    public const nint m_hLightProbeTexture = 0x1520; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_hLightProbeDirectLightIndicesTexture = 0x1528; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_hLightProbeDirectLightScalarsTexture = 0x1530; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_hLightProbeDirectLightShadowsTexture = 0x1538; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_vBoxMins = 0x1540; // Vector
    public const nint m_vBoxMaxs = 0x154C; // Vector
    public const nint m_bMoveable = 0x1558; // bool
    public const nint m_nHandshake = 0x155C; // int32_t
    public const nint m_nEnvCubeMapArrayIndex = 0x1560; // int32_t
    public const nint m_nPriority = 0x1564; // int32_t
    public const nint m_bStartDisabled = 0x1568; // bool
    public const nint m_flEdgeFadeDist = 0x156C; // float
    public const nint m_vEdgeFadeDists = 0x1570; // Vector
    public const nint m_nLightProbeSizeX = 0x157C; // int32_t
    public const nint m_nLightProbeSizeY = 0x1580; // int32_t
    public const nint m_nLightProbeSizeZ = 0x1584; // int32_t
    public const nint m_nLightProbeAtlasX = 0x1588; // int32_t
    public const nint m_nLightProbeAtlasY = 0x158C; // int32_t
    public const nint m_nLightProbeAtlasZ = 0x1590; // int32_t
    public const nint m_bEnabled = 0x15A9; // bool
}

public static class CEnvCubemap {
    public const nint m_hCubemapTexture = 0x530; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_bCustomCubemapTexture = 0x538; // bool
    public const nint m_flInfluenceRadius = 0x53C; // float
    public const nint m_vBoxProjectMins = 0x540; // Vector
    public const nint m_vBoxProjectMaxs = 0x54C; // Vector
    public const nint m_bMoveable = 0x558; // bool
    public const nint m_nHandshake = 0x55C; // int32_t
    public const nint m_nEnvCubeMapArrayIndex = 0x560; // int32_t
    public const nint m_nPriority = 0x564; // int32_t
    public const nint m_flEdgeFadeDist = 0x568; // float
    public const nint m_vEdgeFadeDists = 0x56C; // Vector
    public const nint m_flDiffuseScale = 0x578; // float
    public const nint m_bStartDisabled = 0x57C; // bool
    public const nint m_bDefaultEnvMap = 0x57D; // bool
    public const nint m_bDefaultSpecEnvMap = 0x57E; // bool
    public const nint m_bIndoorCubeMap = 0x57F; // bool
    public const nint m_bCopyDiffuseFromDefaultCubemap = 0x580; // bool
    public const nint m_bEnabled = 0x590; // bool
}

public static class CEnvCubemapFog {
    public const nint m_flEndDistance = 0x4B0; // float
    public const nint m_flStartDistance = 0x4B4; // float
    public const nint m_flFogFalloffExponent = 0x4B8; // float
    public const nint m_bHeightFogEnabled = 0x4BC; // bool
    public const nint m_flFogHeightWidth = 0x4C0; // float
    public const nint m_flFogHeightEnd = 0x4C4; // float
    public const nint m_flFogHeightStart = 0x4C8; // float
    public const nint m_flFogHeightExponent = 0x4CC; // float
    public const nint m_flLODBias = 0x4D0; // float
    public const nint m_bActive = 0x4D4; // bool
    public const nint m_bStartDisabled = 0x4D5; // bool
    public const nint m_flFogMaxOpacity = 0x4D8; // float
    public const nint m_nCubemapSourceType = 0x4DC; // int32_t
    public const nint m_hSkyMaterial = 0x4E0; // CStrongHandle<InfoForResourceTypeIMaterial2>
    public const nint m_iszSkyEntity = 0x4E8; // CUtlSymbolLarge
    public const nint m_hFogCubemapTexture = 0x4F0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_bHasHeightFogEnd = 0x4F8; // bool
    public const nint m_bFirstTime = 0x4F9; // bool
}

public static class CEnvDecal {
    public const nint m_hDecalMaterial = 0x700; // CStrongHandle<InfoForResourceTypeIMaterial2>
    public const nint m_flWidth = 0x708; // float
    public const nint m_flHeight = 0x70C; // float
    public const nint m_flDepth = 0x710; // float
    public const nint m_nRenderOrder = 0x714; // uint32_t
    public const nint m_bProjectOnWorld = 0x718; // bool
    public const nint m_bProjectOnCharacters = 0x719; // bool
    public const nint m_bProjectOnWater = 0x71A; // bool
    public const nint m_flDepthSortBias = 0x71C; // float
}

public static class CEnvDetailController {
    public const nint m_flFadeStartDist = 0x4B0; // float
    public const nint m_flFadeEndDist = 0x4B4; // float
}

public static class CEnvEntityIgniter {
    public const nint m_flLifetime = 0x4B0; // float
}

public static class CEnvEntityMaker {
    public const nint m_vecEntityMins = 0x4B0; // Vector
    public const nint m_vecEntityMaxs = 0x4BC; // Vector
    public const nint m_hCurrentInstance = 0x4C8; // CHandle<CBaseEntity>
    public const nint m_hCurrentBlocker = 0x4CC; // CHandle<CBaseEntity>
    public const nint m_vecBlockerOrigin = 0x4D0; // Vector
    public const nint m_angPostSpawnDirection = 0x4DC; // QAngle
    public const nint m_flPostSpawnDirectionVariance = 0x4E8; // float
    public const nint m_flPostSpawnSpeed = 0x4EC; // float
    public const nint m_bPostSpawnUseAngles = 0x4F0; // bool
    public const nint m_iszTemplate = 0x4F8; // CUtlSymbolLarge
    public const nint m_pOutputOnSpawned = 0x500; // CEntityIOOutput
    public const nint m_pOutputOnFailedSpawn = 0x528; // CEntityIOOutput
}

public static class CEnvExplosion {
    public const nint m_iMagnitude = 0x700; // int32_t
    public const nint m_flPlayerDamage = 0x704; // float
    public const nint m_iRadiusOverride = 0x708; // int32_t
    public const nint m_flInnerRadius = 0x70C; // float
    public const nint m_spriteScale = 0x710; // int32_t
    public const nint m_flDamageForce = 0x714; // float
    public const nint m_hInflictor = 0x718; // CHandle<CBaseEntity>
    public const nint m_iCustomDamageType = 0x71C; // int32_t
    public const nint m_iszExplosionType = 0x728; // CUtlSymbolLarge
    public const nint m_iszCustomEffectName = 0x730; // CUtlSymbolLarge
    public const nint m_iszCustomSoundName = 0x738; // CUtlSymbolLarge
    public const nint m_iClassIgnore = 0x740; // Class_T
    public const nint m_iClassIgnore2 = 0x744; // Class_T
    public const nint m_iszEntityIgnoreName = 0x748; // CUtlSymbolLarge
    public const nint m_hEntityIgnore = 0x750; // CHandle<CBaseEntity>
}

public static class CEnvFade {
    public const nint m_fadeColor = 0x4B0; // Color
    public const nint m_Duration = 0x4B4; // float
    public const nint m_HoldDuration = 0x4B8; // float
    public const nint m_OnBeginFade = 0x4C0; // CEntityIOOutput
}

public static class CEnvFireSensor {
    public const nint m_bEnabled = 0x4B0; // bool
    public const nint m_bHeatAtLevel = 0x4B1; // bool
    public const nint m_radius = 0x4B4; // float
    public const nint m_targetLevel = 0x4B8; // float
    public const nint m_targetTime = 0x4BC; // float
    public const nint m_levelTime = 0x4C0; // float
    public const nint m_OnHeatLevelStart = 0x4C8; // CEntityIOOutput
    public const nint m_OnHeatLevelEnd = 0x4F0; // CEntityIOOutput
}

public static class CEnvFireSource {
    public const nint m_bEnabled = 0x4B0; // bool
    public const nint m_radius = 0x4B4; // float
    public const nint m_damage = 0x4B8; // float
}

public static class CEnvGlobal {
    public const nint m_outCounter = 0x4B0; // CEntityOutputTemplate<int32_t>
    public const nint m_globalstate = 0x4D8; // CUtlSymbolLarge
    public const nint m_triggermode = 0x4E0; // int32_t
    public const nint m_initialstate = 0x4E4; // int32_t
    public const nint m_counter = 0x4E8; // int32_t
}

public static class CEnvHudHint {
    public const nint m_iszMessage = 0x4B0; // CUtlSymbolLarge
}

public static class CEnvInstructorHint {
    public const nint m_iszName = 0x4B0; // CUtlSymbolLarge
    public const nint m_iszReplace_Key = 0x4B8; // CUtlSymbolLarge
    public const nint m_iszHintTargetEntity = 0x4C0; // CUtlSymbolLarge
    public const nint m_iTimeout = 0x4C8; // int32_t
    public const nint m_iDisplayLimit = 0x4CC; // int32_t
    public const nint m_iszIcon_Onscreen = 0x4D0; // CUtlSymbolLarge
    public const nint m_iszIcon_Offscreen = 0x4D8; // CUtlSymbolLarge
    public const nint m_iszCaption = 0x4E0; // CUtlSymbolLarge
    public const nint m_iszActivatorCaption = 0x4E8; // CUtlSymbolLarge
    public const nint m_Color = 0x4F0; // Color
    public const nint m_fIconOffset = 0x4F4; // float
    public const nint m_fRange = 0x4F8; // float
    public const nint m_iPulseOption = 0x4FC; // uint8_t
    public const nint m_iAlphaOption = 0x4FD; // uint8_t
    public const nint m_iShakeOption = 0x4FE; // uint8_t
    public const nint m_bStatic = 0x4FF; // bool
    public const nint m_bNoOffscreen = 0x500; // bool
    public const nint m_bForceCaption = 0x501; // bool
    public const nint m_iInstanceType = 0x504; // int32_t
    public const nint m_bSuppressRest = 0x508; // bool
    public const nint m_iszBinding = 0x510; // CUtlSymbolLarge
    public const nint m_bAllowNoDrawTarget = 0x518; // bool
    public const nint m_bAutoStart = 0x519; // bool
    public const nint m_bLocalPlayerOnly = 0x51A; // bool
}

public static class CEnvInstructorVRHint {
    public const nint m_iszName = 0x4B0; // CUtlSymbolLarge
    public const nint m_iszHintTargetEntity = 0x4B8; // CUtlSymbolLarge
    public const nint m_iTimeout = 0x4C0; // int32_t
    public const nint m_iszCaption = 0x4C8; // CUtlSymbolLarge
    public const nint m_iszStartSound = 0x4D0; // CUtlSymbolLarge
    public const nint m_iLayoutFileType = 0x4D8; // int32_t
    public const nint m_iszCustomLayoutFile = 0x4E0; // CUtlSymbolLarge
    public const nint m_iAttachType = 0x4E8; // int32_t
    public const nint m_flHeightOffset = 0x4EC; // float
}

public static class CEnvLaser {
    public const nint m_iszLaserTarget = 0x7A0; // CUtlSymbolLarge
    public const nint m_pSprite = 0x7A8; // CSprite*
    public const nint m_iszSpriteName = 0x7B0; // CUtlSymbolLarge
    public const nint m_firePosition = 0x7B8; // Vector
    public const nint m_flStartFrame = 0x7C4; // float
}

public static class CEnvLightProbeVolume {
    public const nint m_hLightProbeTexture = 0x1488; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_hLightProbeDirectLightIndicesTexture = 0x1490; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_hLightProbeDirectLightScalarsTexture = 0x1498; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_hLightProbeDirectLightShadowsTexture = 0x14A0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_vBoxMins = 0x14A8; // Vector
    public const nint m_vBoxMaxs = 0x14B4; // Vector
    public const nint m_bMoveable = 0x14C0; // bool
    public const nint m_nHandshake = 0x14C4; // int32_t
    public const nint m_nPriority = 0x14C8; // int32_t
    public const nint m_bStartDisabled = 0x14CC; // bool
    public const nint m_nLightProbeSizeX = 0x14D0; // int32_t
    public const nint m_nLightProbeSizeY = 0x14D4; // int32_t
    public const nint m_nLightProbeSizeZ = 0x14D8; // int32_t
    public const nint m_nLightProbeAtlasX = 0x14DC; // int32_t
    public const nint m_nLightProbeAtlasY = 0x14E0; // int32_t
    public const nint m_nLightProbeAtlasZ = 0x14E4; // int32_t
    public const nint m_bEnabled = 0x14F1; // bool
}

public static class CEnvMicrophone {
    public const nint m_bDisabled = 0x4B0; // bool
    public const nint m_hMeasureTarget = 0x4B4; // CHandle<CBaseEntity>
    public const nint m_nSoundMask = 0x4B8; // int32_t
    public const nint m_flSensitivity = 0x4BC; // float
    public const nint m_flSmoothFactor = 0x4C0; // float
    public const nint m_flMaxRange = 0x4C4; // float
    public const nint m_iszSpeakerName = 0x4C8; // CUtlSymbolLarge
    public const nint m_hSpeaker = 0x4D0; // CHandle<CBaseEntity>
    public const nint m_bAvoidFeedback = 0x4D4; // bool
    public const nint m_iSpeakerDSPPreset = 0x4D8; // int32_t
    public const nint m_iszListenFilter = 0x4E0; // CUtlSymbolLarge
    public const nint m_hListenFilter = 0x4E8; // CHandle<CBaseFilter>
    public const nint m_SoundLevel = 0x4F0; // CEntityOutputTemplate<float>
    public const nint m_OnRoutedSound = 0x518; // CEntityIOOutput
    public const nint m_OnHeardSound = 0x540; // CEntityIOOutput
    public const nint m_szLastSound = 0x568; // char[256]
    public const nint m_iLastRoutedFrame = 0x668; // int32_t
}

public static class CEnvMuzzleFlash {
    public const nint m_flScale = 0x4B0; // float
    public const nint m_iszParentAttachment = 0x4B8; // CUtlSymbolLarge
}

public static class CEnvParticleGlow {
    public const nint m_flAlphaScale = 0xC78; // float
    public const nint m_flRadiusScale = 0xC7C; // float
    public const nint m_flSelfIllumScale = 0xC80; // float
    public const nint m_ColorTint = 0xC84; // Color
    public const nint m_hTextureOverride = 0xC88; // CStrongHandle<InfoForResourceTypeCTextureBase>
}

public static class CEnvProjectedTexture {
    public const nint m_hTargetEntity = 0x700; // CHandle<CBaseEntity>
    public const nint m_bState = 0x704; // bool
    public const nint m_bAlwaysUpdate = 0x705; // bool
    public const nint m_flLightFOV = 0x708; // float
    public const nint m_bEnableShadows = 0x70C; // bool
    public const nint m_bSimpleProjection = 0x70D; // bool
    public const nint m_bLightOnlyTarget = 0x70E; // bool
    public const nint m_bLightWorld = 0x70F; // bool
    public const nint m_bCameraSpace = 0x710; // bool
    public const nint m_flBrightnessScale = 0x714; // float
    public const nint m_LightColor = 0x718; // Color
    public const nint m_flIntensity = 0x71C; // float
    public const nint m_flLinearAttenuation = 0x720; // float
    public const nint m_flQuadraticAttenuation = 0x724; // float
    public const nint m_bVolumetric = 0x728; // bool
    public const nint m_flNoiseStrength = 0x72C; // float
    public const nint m_flFlashlightTime = 0x730; // float
    public const nint m_nNumPlanes = 0x734; // uint32_t
    public const nint m_flPlaneOffset = 0x738; // float
    public const nint m_flVolumetricIntensity = 0x73C; // float
    public const nint m_flColorTransitionTime = 0x740; // float
    public const nint m_flAmbient = 0x744; // float
    public const nint m_SpotlightTextureName = 0x748; // char[512]
    public const nint m_nSpotlightTextureFrame = 0x948; // int32_t
    public const nint m_nShadowQuality = 0x94C; // uint32_t
    public const nint m_flNearZ = 0x950; // float
    public const nint m_flFarZ = 0x954; // float
    public const nint m_flProjectionSize = 0x958; // float
    public const nint m_flRotation = 0x95C; // float
    public const nint m_bFlipHorizontal = 0x960; // bool
}

public static class CEnvScreenOverlay {
    public const nint m_iszOverlayNames = 0x4B0; // CUtlSymbolLarge[10]
    public const nint m_flOverlayTimes = 0x500; // float[10]
    public const nint m_flStartTime = 0x528; // GameTime_t
    public const nint m_iDesiredOverlay = 0x52C; // int32_t
    public const nint m_bIsActive = 0x530; // bool
}

public static class CEnvShake {
    public const nint m_limitToEntity = 0x4B0; // CUtlSymbolLarge
    public const nint m_Amplitude = 0x4B8; // float
    public const nint m_Frequency = 0x4BC; // float
    public const nint m_Duration = 0x4C0; // float
    public const nint m_Radius = 0x4C4; // float
    public const nint m_stopTime = 0x4C8; // GameTime_t
    public const nint m_nextShake = 0x4CC; // GameTime_t
    public const nint m_currentAmp = 0x4D0; // float
    public const nint m_maxForce = 0x4D4; // Vector
    public const nint m_shakeCallback = 0x4E8; // CPhysicsShake
}

public static class CEnvSky {
    public const nint m_hSkyMaterial = 0x700; // CStrongHandle<InfoForResourceTypeIMaterial2>
    public const nint m_hSkyMaterialLightingOnly = 0x708; // CStrongHandle<InfoForResourceTypeIMaterial2>
    public const nint m_bStartDisabled = 0x710; // bool
    public const nint m_vTintColor = 0x711; // Color
    public const nint m_vTintColorLightingOnly = 0x715; // Color
    public const nint m_flBrightnessScale = 0x71C; // float
    public const nint m_nFogType = 0x720; // int32_t
    public const nint m_flFogMinStart = 0x724; // float
    public const nint m_flFogMinEnd = 0x728; // float
    public const nint m_flFogMaxStart = 0x72C; // float
    public const nint m_flFogMaxEnd = 0x730; // float
    public const nint m_bEnabled = 0x734; // bool
}

public static class CEnvSoundscape {
    public const nint m_OnPlay = 0x4B0; // CEntityIOOutput
    public const nint m_flRadius = 0x4D8; // float
    public const nint m_soundscapeName = 0x4E0; // CUtlSymbolLarge
    public const nint m_soundEventName = 0x4E8; // CUtlSymbolLarge
    public const nint m_bOverrideWithEvent = 0x4F0; // bool
    public const nint m_soundscapeIndex = 0x4F4; // int32_t
    public const nint m_soundscapeEntityListId = 0x4F8; // int32_t
    public const nint m_soundEventHash = 0x4FC; // uint32_t
    public const nint m_positionNames = 0x500; // CUtlSymbolLarge[8]
    public const nint m_hProxySoundscape = 0x540; // CHandle<CEnvSoundscape>
    public const nint m_bDisabled = 0x544; // bool
}

public static class CEnvSoundscapeProxy {
    public const nint m_MainSoundscapeName = 0x548; // CUtlSymbolLarge
}

public static class CEnvSpark {
    public const nint m_flDelay = 0x4B0; // float
    public const nint m_nMagnitude = 0x4B4; // int32_t
    public const nint m_nTrailLength = 0x4B8; // int32_t
    public const nint m_nType = 0x4BC; // int32_t
    public const nint m_OnSpark = 0x4C0; // CEntityIOOutput
}

public static class CEnvSplash {
    public const nint m_flScale = 0x4B0; // float
}

public static class CEnvTilt {
    public const nint m_Duration = 0x4B0; // float
    public const nint m_Radius = 0x4B4; // float
    public const nint m_TiltTime = 0x4B8; // float
    public const nint m_stopTime = 0x4BC; // GameTime_t
}

public static class CEnvTracer {
    public const nint m_vecEnd = 0x4B0; // Vector
    public const nint m_flDelay = 0x4BC; // float
}

public static class CEnvViewPunch {
    public const nint m_flRadius = 0x4B0; // float
    public const nint m_angViewPunch = 0x4B4; // QAngle
}

public static class CEnvVolumetricFogController {
    public const nint m_flScattering = 0x4B0; // float
    public const nint m_flAnisotropy = 0x4B4; // float
    public const nint m_flFadeSpeed = 0x4B8; // float
    public const nint m_flDrawDistance = 0x4BC; // float
    public const nint m_flFadeInStart = 0x4C0; // float
    public const nint m_flFadeInEnd = 0x4C4; // float
    public const nint m_flIndirectStrength = 0x4C8; // float
    public const nint m_nIndirectTextureDimX = 0x4CC; // int32_t
    public const nint m_nIndirectTextureDimY = 0x4D0; // int32_t
    public const nint m_nIndirectTextureDimZ = 0x4D4; // int32_t
    public const nint m_vBoxMins = 0x4D8; // Vector
    public const nint m_vBoxMaxs = 0x4E4; // Vector
    public const nint m_bActive = 0x4F0; // bool
    public const nint m_flStartAnisoTime = 0x4F4; // GameTime_t
    public const nint m_flStartScatterTime = 0x4F8; // GameTime_t
    public const nint m_flStartDrawDistanceTime = 0x4FC; // GameTime_t
    public const nint m_flStartAnisotropy = 0x500; // float
    public const nint m_flStartScattering = 0x504; // float
    public const nint m_flStartDrawDistance = 0x508; // float
    public const nint m_flDefaultAnisotropy = 0x50C; // float
    public const nint m_flDefaultScattering = 0x510; // float
    public const nint m_flDefaultDrawDistance = 0x514; // float
    public const nint m_bStartDisabled = 0x518; // bool
    public const nint m_bEnableIndirect = 0x519; // bool
    public const nint m_bIsMaster = 0x51A; // bool
    public const nint m_hFogIndirectTexture = 0x520; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_nForceRefreshCount = 0x528; // int32_t
    public const nint m_bFirstTime = 0x52C; // bool
}

public static class CEnvVolumetricFogVolume {
    public const nint m_bActive = 0x4B0; // bool
    public const nint m_vBoxMins = 0x4B4; // Vector
    public const nint m_vBoxMaxs = 0x4C0; // Vector
    public const nint m_bStartDisabled = 0x4CC; // bool
    public const nint m_flStrength = 0x4D0; // float
    public const nint m_nFalloffShape = 0x4D4; // int32_t
    public const nint m_flFalloffExponent = 0x4D8; // float
}

public static class CEnvWind {
    public const nint m_EnvWindShared = 0x4B0; // CEnvWindShared
}

public static class CEnvWindShared {
    public const nint m_flStartTime = 0x8; // GameTime_t
    public const nint m_iWindSeed = 0xC; // uint32_t
    public const nint m_iMinWind = 0x10; // uint16_t
    public const nint m_iMaxWind = 0x12; // uint16_t
    public const nint m_windRadius = 0x14; // int32_t
    public const nint m_iMinGust = 0x18; // uint16_t
    public const nint m_iMaxGust = 0x1A; // uint16_t
    public const nint m_flMinGustDelay = 0x1C; // float
    public const nint m_flMaxGustDelay = 0x20; // float
    public const nint m_flGustDuration = 0x24; // float
    public const nint m_iGustDirChange = 0x28; // uint16_t
    public const nint m_location = 0x2C; // Vector
    public const nint m_iszGustSound = 0x38; // int32_t
    public const nint m_iWindDir = 0x3C; // int32_t
    public const nint m_flWindSpeed = 0x40; // float
    public const nint m_currentWindVector = 0x44; // Vector
    public const nint m_CurrentSwayVector = 0x50; // Vector
    public const nint m_PrevSwayVector = 0x5C; // Vector
    public const nint m_iInitialWindDir = 0x68; // uint16_t
    public const nint m_flInitialWindSpeed = 0x6C; // float
    public const nint m_OnGustStart = 0x70; // CEntityIOOutput
    public const nint m_OnGustEnd = 0x98; // CEntityIOOutput
    public const nint m_flVariationTime = 0xC0; // GameTime_t
    public const nint m_flSwayTime = 0xC4; // GameTime_t
    public const nint m_flSimTime = 0xC8; // GameTime_t
    public const nint m_flSwitchTime = 0xCC; // GameTime_t
    public const nint m_flAveWindSpeed = 0xD0; // float
    public const nint m_bGusting = 0xD4; // bool
    public const nint m_flWindAngleVariation = 0xD8; // float
    public const nint m_flWindSpeedVariation = 0xDC; // float
    public const nint m_iEntIndex = 0xE0; // CEntityIndex
}

public static class CEnvWindShared_WindAveEvent_t {
    public const nint m_flStartWindSpeed = 0x0; // float
    public const nint m_flAveWindSpeed = 0x4; // float
}

public static class CEnvWindShared_WindVariationEvent_t {
    public const nint m_flWindAngleVariation = 0x0; // float
    public const nint m_flWindSpeedVariation = 0x4; // float
}

public static class CFilterAttributeInt {
    public const nint m_sAttributeName = 0x508; // CUtlStringToken
}

public static class CFilterClass {
    public const nint m_iFilterClass = 0x508; // CUtlSymbolLarge
}

public static class CFilterContext {
    public const nint m_iFilterContext = 0x508; // CUtlSymbolLarge
}

public static class CFilterEnemy {
    public const nint m_iszEnemyName = 0x508; // CUtlSymbolLarge
    public const nint m_flRadius = 0x510; // float
    public const nint m_flOuterRadius = 0x514; // float
    public const nint m_nMaxSquadmatesPerEnemy = 0x518; // int32_t
    public const nint m_iszPlayerName = 0x520; // CUtlSymbolLarge
}

public static class CFilterMassGreater {
    public const nint m_fFilterMass = 0x508; // float
}

public static class CFilterModel {
    public const nint m_iFilterModel = 0x508; // CUtlSymbolLarge
}

public static class CFilterMultiple {
    public const nint m_nFilterType = 0x508; // filter_t
    public const nint m_iFilterName = 0x510; // CUtlSymbolLarge[10]
    public const nint m_hFilter = 0x560; // CHandle<CBaseEntity>[10]
    public const nint m_nFilterCount = 0x588; // int32_t
}

public static class CFilterName {
    public const nint m_iFilterName = 0x508; // CUtlSymbolLarge
}

public static class CFilterProximity {
    public const nint m_flRadius = 0x508; // float
}

public static class CFire {
    public const nint m_hEffect = 0x700; // CHandle<CBaseFire>
    public const nint m_hOwner = 0x704; // CHandle<CBaseEntity>
    public const nint m_nFireType = 0x708; // int32_t
    public const nint m_flFuel = 0x70C; // float
    public const nint m_flDamageTime = 0x710; // GameTime_t
    public const nint m_lastDamage = 0x714; // GameTime_t
    public const nint m_flFireSize = 0x718; // float
    public const nint m_flLastNavUpdateTime = 0x71C; // GameTime_t
    public const nint m_flHeatLevel = 0x720; // float
    public const nint m_flHeatAbsorb = 0x724; // float
    public const nint m_flDamageScale = 0x728; // float
    public const nint m_flMaxHeat = 0x72C; // float
    public const nint m_flLastHeatLevel = 0x730; // float
    public const nint m_flAttackTime = 0x734; // float
    public const nint m_bEnabled = 0x738; // bool
    public const nint m_bStartDisabled = 0x739; // bool
    public const nint m_bDidActivate = 0x73A; // bool
    public const nint m_OnIgnited = 0x740; // CEntityIOOutput
    public const nint m_OnExtinguished = 0x768; // CEntityIOOutput
}

public static class CFireSmoke {
    public const nint m_nFlameModelIndex = 0x4C0; // int32_t
    public const nint m_nFlameFromAboveModelIndex = 0x4C4; // int32_t
}

public static class CFiringModeFloat {
    public const nint m_flValues = 0x0; // float[2]
}

public static class CFiringModeInt {
    public const nint m_nValues = 0x0; // int32_t[2]
}

public static class CFish {
    public const nint m_pool = 0x890; // CHandle<CFishPool>
    public const nint m_id = 0x894; // uint32_t
    public const nint m_x = 0x898; // float
    public const nint m_y = 0x89C; // float
    public const nint m_z = 0x8A0; // float
    public const nint m_angle = 0x8A4; // float
    public const nint m_angleChange = 0x8A8; // float
    public const nint m_forward = 0x8AC; // Vector
    public const nint m_perp = 0x8B8; // Vector
    public const nint m_poolOrigin = 0x8C4; // Vector
    public const nint m_waterLevel = 0x8D0; // float
    public const nint m_speed = 0x8D4; // float
    public const nint m_desiredSpeed = 0x8D8; // float
    public const nint m_calmSpeed = 0x8DC; // float
    public const nint m_panicSpeed = 0x8E0; // float
    public const nint m_avoidRange = 0x8E4; // float
    public const nint m_turnTimer = 0x8E8; // CountdownTimer
    public const nint m_turnClockwise = 0x900; // bool
    public const nint m_goTimer = 0x908; // CountdownTimer
    public const nint m_moveTimer = 0x920; // CountdownTimer
    public const nint m_panicTimer = 0x938; // CountdownTimer
    public const nint m_disperseTimer = 0x950; // CountdownTimer
    public const nint m_proximityTimer = 0x968; // CountdownTimer
    public const nint m_visible = 0x980; // CUtlVector<CFish*>
}

public static class CFishPool {
    public const nint m_fishCount = 0x4C0; // int32_t
    public const nint m_maxRange = 0x4C4; // float
    public const nint m_swimDepth = 0x4C8; // float
    public const nint m_waterLevel = 0x4CC; // float
    public const nint m_isDormant = 0x4D0; // bool
    public const nint m_fishes = 0x4D8; // CUtlVector<CHandle<CFish>>
    public const nint m_visTimer = 0x4F0; // CountdownTimer
}

public static class CFists {
    public const nint m_bPlayingUninterruptableAct = 0xE20; // bool
    public const nint m_nUninterruptableActivity = 0xE24; // PlayerAnimEvent_t
    public const nint m_bRestorePrevWep = 0xE28; // bool
    public const nint m_hWeaponBeforePrevious = 0xE2C; // CHandle<CBasePlayerWeapon>
    public const nint m_hWeaponPrevious = 0xE30; // CHandle<CBasePlayerWeapon>
    public const nint m_bDelayedHardPunchIncoming = 0xE34; // bool
    public const nint m_bDestroyAfterTaunt = 0xE35; // bool
}

public static class CFlashbangProjectile {
    public const nint m_flTimeToDetonate = 0xA40; // float
    public const nint m_numOpponentsHit = 0xA44; // uint8_t
    public const nint m_numTeammatesHit = 0xA45; // uint8_t
}

public static class CFogController {
    public const nint m_fog = 0x4B0; // fogparams_t
    public const nint m_bUseAngles = 0x518; // bool
    public const nint m_iChangedVariables = 0x51C; // int32_t
}

public static class CFogTrigger {
    public const nint m_fog = 0x8A8; // fogparams_t
}

public static class CFogVolume {
    public const nint m_fogName = 0x700; // CUtlSymbolLarge
    public const nint m_postProcessName = 0x708; // CUtlSymbolLarge
    public const nint m_colorCorrectionName = 0x710; // CUtlSymbolLarge
    public const nint m_bDisabled = 0x720; // bool
    public const nint m_bInFogVolumesList = 0x721; // bool
}

public static class CFootstepControl {
    public const nint m_source = 0x8A8; // CUtlSymbolLarge
    public const nint m_destination = 0x8B0; // CUtlSymbolLarge
}

public static class CFuncBrush {
    public const nint m_iSolidity = 0x700; // BrushSolidities_e
    public const nint m_iDisabled = 0x704; // int32_t
    public const nint m_bSolidBsp = 0x708; // bool
    public const nint m_iszExcludedClass = 0x710; // CUtlSymbolLarge
    public const nint m_bInvertExclusion = 0x718; // bool
    public const nint m_bScriptedMovement = 0x719; // bool
}

public static class CFuncConveyor {
    public const nint m_szConveyorModels = 0x700; // CUtlSymbolLarge
    public const nint m_flTransitionDurationSeconds = 0x708; // float
    public const nint m_angMoveEntitySpace = 0x70C; // QAngle
    public const nint m_vecMoveDirEntitySpace = 0x718; // Vector
    public const nint m_flTargetSpeed = 0x724; // float
    public const nint m_nTransitionStartTick = 0x728; // GameTick_t
    public const nint m_nTransitionDurationTicks = 0x72C; // int32_t
    public const nint m_flTransitionStartSpeed = 0x730; // float
    public const nint m_hConveyorModels = 0x738; // CNetworkUtlVectorBase<CHandle<CBaseEntity>>
}

public static class CFuncElectrifiedVolume {
    public const nint m_EffectName = 0x720; // CUtlSymbolLarge
    public const nint m_EffectInterpenetrateName = 0x728; // CUtlSymbolLarge
    public const nint m_EffectZapName = 0x730; // CUtlSymbolLarge
    public const nint m_iszEffectSource = 0x738; // CUtlSymbolLarge
}

public static class CFuncInteractionLayerClip {
    public const nint m_bDisabled = 0x700; // bool
    public const nint m_iszInteractsAs = 0x708; // CUtlSymbolLarge
    public const nint m_iszInteractsWith = 0x710; // CUtlSymbolLarge
}

public static class CFuncLadder {
    public const nint m_vecLadderDir = 0x700; // Vector
    public const nint m_Dismounts = 0x710; // CUtlVector<CHandle<CInfoLadderDismount>>
    public const nint m_vecLocalTop = 0x728; // Vector
    public const nint m_vecPlayerMountPositionTop = 0x734; // Vector
    public const nint m_vecPlayerMountPositionBottom = 0x740; // Vector
    public const nint m_flAutoRideSpeed = 0x74C; // float
    public const nint m_bDisabled = 0x750; // bool
    public const nint m_bFakeLadder = 0x751; // bool
    public const nint m_bHasSlack = 0x752; // bool
    public const nint m_surfacePropName = 0x758; // CUtlSymbolLarge
    public const nint m_OnPlayerGotOnLadder = 0x760; // CEntityIOOutput
    public const nint m_OnPlayerGotOffLadder = 0x788; // CEntityIOOutput
}

public static class CFuncMonitor {
    public const nint m_targetCamera = 0x720; // CUtlString
    public const nint m_nResolutionEnum = 0x728; // int32_t
    public const nint m_bRenderShadows = 0x72C; // bool
    public const nint m_bUseUniqueColorTarget = 0x72D; // bool
    public const nint m_brushModelName = 0x730; // CUtlString
    public const nint m_hTargetCamera = 0x738; // CHandle<CBaseEntity>
    public const nint m_bEnabled = 0x73C; // bool
    public const nint m_bDraw3DSkybox = 0x73D; // bool
    public const nint m_bStartEnabled = 0x73E; // bool
}

public static class CFuncMoveLinear {
    public const nint m_authoredPosition = 0x780; // MoveLinearAuthoredPos_t
    public const nint m_angMoveEntitySpace = 0x784; // QAngle
    public const nint m_vecMoveDirParentSpace = 0x790; // Vector
    public const nint m_soundStart = 0x7A0; // CUtlSymbolLarge
    public const nint m_soundStop = 0x7A8; // CUtlSymbolLarge
    public const nint m_currentSound = 0x7B0; // CUtlSymbolLarge
    public const nint m_flBlockDamage = 0x7B8; // float
    public const nint m_flStartPosition = 0x7BC; // float
    public const nint m_flMoveDistance = 0x7C0; // float
    public const nint m_OnFullyOpen = 0x7D0; // CEntityIOOutput
    public const nint m_OnFullyClosed = 0x7F8; // CEntityIOOutput
    public const nint m_bCreateMovableNavMesh = 0x820; // bool
    public const nint m_bCreateNavObstacle = 0x821; // bool
}

public static class CFuncNavBlocker {
    public const nint m_bDisabled = 0x700; // bool
    public const nint m_nBlockedTeamNumber = 0x704; // int32_t
}

public static class CFuncNavObstruction {
    public const nint m_bDisabled = 0x708; // bool
}

public static class CFuncPlat {
    public const nint m_sNoise = 0x7A8; // CUtlSymbolLarge
}

public static class CFuncPlatRot {
    public const nint m_end = 0x7B0; // QAngle
    public const nint m_start = 0x7BC; // QAngle
}

public static class CFuncRotating {
    public const nint m_vecMoveAng = 0x700; // QAngle
    public const nint m_flFanFriction = 0x70C; // float
    public const nint m_flAttenuation = 0x710; // float
    public const nint m_flVolume = 0x714; // float
    public const nint m_flTargetSpeed = 0x718; // float
    public const nint m_flMaxSpeed = 0x71C; // float
    public const nint m_flBlockDamage = 0x720; // float
    public const nint m_flTimeScale = 0x724; // float
    public const nint m_NoiseRunning = 0x728; // CUtlSymbolLarge
    public const nint m_bReversed = 0x730; // bool
    public const nint m_angStart = 0x73C; // QAngle
    public const nint m_bStopAtStartPos = 0x748; // bool
    public const nint m_vecClientOrigin = 0x74C; // Vector
    public const nint m_vecClientAngles = 0x758; // QAngle
}

public static class CFuncShatterglass {
    public const nint m_hGlassMaterialDamaged = 0x700; // CStrongHandle<InfoForResourceTypeIMaterial2>
    public const nint m_hGlassMaterialUndamaged = 0x708; // CStrongHandle<InfoForResourceTypeIMaterial2>
    public const nint m_hConcreteMaterialEdgeFace = 0x710; // CStrongHandle<InfoForResourceTypeIMaterial2>
    public const nint m_hConcreteMaterialEdgeCaps = 0x718; // CStrongHandle<InfoForResourceTypeIMaterial2>
    public const nint m_hConcreteMaterialEdgeFins = 0x720; // CStrongHandle<InfoForResourceTypeIMaterial2>
    public const nint m_matPanelTransform = 0x728; // matrix3x4_t
    public const nint m_matPanelTransformWsTemp = 0x758; // matrix3x4_t
    public const nint m_vecShatterGlassShards = 0x788; // CUtlVector<uint32_t>
    public const nint m_PanelSize = 0x7A0; // Vector2D
    public const nint m_vecPanelNormalWs = 0x7A8; // Vector
    public const nint m_nNumShardsEverCreated = 0x7B4; // int32_t
    public const nint m_flLastShatterSoundEmitTime = 0x7B8; // GameTime_t
    public const nint m_flLastCleanupTime = 0x7BC; // GameTime_t
    public const nint m_flInitAtTime = 0x7C0; // GameTime_t
    public const nint m_flGlassThickness = 0x7C4; // float
    public const nint m_flSpawnInvulnerability = 0x7C8; // float
    public const nint m_bBreakSilent = 0x7CC; // bool
    public const nint m_bBreakShardless = 0x7CD; // bool
    public const nint m_bBroken = 0x7CE; // bool
    public const nint m_bHasRateLimitedShards = 0x7CF; // bool
    public const nint m_bGlassNavIgnore = 0x7D0; // bool
    public const nint m_bGlassInFrame = 0x7D1; // bool
    public const nint m_bStartBroken = 0x7D2; // bool
    public const nint m_iInitialDamageType = 0x7D3; // uint8_t
    public const nint m_szDamagePositioningEntityName01 = 0x7D8; // CUtlSymbolLarge
    public const nint m_szDamagePositioningEntityName02 = 0x7E0; // CUtlSymbolLarge
    public const nint m_szDamagePositioningEntityName03 = 0x7E8; // CUtlSymbolLarge
    public const nint m_szDamagePositioningEntityName04 = 0x7F0; // CUtlSymbolLarge
    public const nint m_vInitialDamagePositions = 0x7F8; // CUtlVector<Vector>
    public const nint m_vExtraDamagePositions = 0x810; // CUtlVector<Vector>
    public const nint m_OnBroken = 0x828; // CEntityIOOutput
    public const nint m_iSurfaceType = 0x851; // uint8_t
}

public static class CFuncTankTrain {
    public const nint m_OnDeath = 0x850; // CEntityIOOutput
}

public static class CFuncTimescale {
    public const nint m_flDesiredTimescale = 0x4B0; // float
    public const nint m_flAcceleration = 0x4B4; // float
    public const nint m_flMinBlendRate = 0x4B8; // float
    public const nint m_flBlendDeltaMultiplier = 0x4BC; // float
    public const nint m_isStarted = 0x4C0; // bool
}

public static class CFuncTrackChange {
    public const nint m_trackTop = 0x7C8; // CPathTrack*
    public const nint m_trackBottom = 0x7D0; // CPathTrack*
    public const nint m_train = 0x7D8; // CFuncTrackTrain*
    public const nint m_trackTopName = 0x7E0; // CUtlSymbolLarge
    public const nint m_trackBottomName = 0x7E8; // CUtlSymbolLarge
    public const nint m_trainName = 0x7F0; // CUtlSymbolLarge
    public const nint m_code = 0x7F8; // TRAIN_CODE
    public const nint m_targetState = 0x7FC; // int32_t
    public const nint m_use = 0x800; // int32_t
}

public static class CFuncTrackTrain {
    public const nint m_ppath = 0x700; // CHandle<CPathTrack>
    public const nint m_length = 0x704; // float
    public const nint m_vPosPrev = 0x708; // Vector
    public const nint m_angPrev = 0x714; // QAngle
    public const nint m_controlMins = 0x720; // Vector
    public const nint m_controlMaxs = 0x72C; // Vector
    public const nint m_lastBlockPos = 0x738; // Vector
    public const nint m_lastBlockTick = 0x744; // int32_t
    public const nint m_flVolume = 0x748; // float
    public const nint m_flBank = 0x74C; // float
    public const nint m_oldSpeed = 0x750; // float
    public const nint m_flBlockDamage = 0x754; // float
    public const nint m_height = 0x758; // float
    public const nint m_maxSpeed = 0x75C; // float
    public const nint m_dir = 0x760; // float
    public const nint m_iszSoundMove = 0x768; // CUtlSymbolLarge
    public const nint m_iszSoundMovePing = 0x770; // CUtlSymbolLarge
    public const nint m_iszSoundStart = 0x778; // CUtlSymbolLarge
    public const nint m_iszSoundStop = 0x780; // CUtlSymbolLarge
    public const nint m_strPathTarget = 0x788; // CUtlSymbolLarge
    public const nint m_flMoveSoundMinDuration = 0x790; // float
    public const nint m_flMoveSoundMaxDuration = 0x794; // float
    public const nint m_flNextMoveSoundTime = 0x798; // GameTime_t
    public const nint m_flMoveSoundMinPitch = 0x79C; // float
    public const nint m_flMoveSoundMaxPitch = 0x7A0; // float
    public const nint m_eOrientationType = 0x7A4; // TrainOrientationType_t
    public const nint m_eVelocityType = 0x7A8; // TrainVelocityType_t
    public const nint m_OnStart = 0x7B8; // CEntityIOOutput
    public const nint m_OnNext = 0x7E0; // CEntityIOOutput
    public const nint m_OnArrivedAtDestinationNode = 0x808; // CEntityIOOutput
    public const nint m_bManualSpeedChanges = 0x830; // bool
    public const nint m_flDesiredSpeed = 0x834; // float
    public const nint m_flSpeedChangeTime = 0x838; // GameTime_t
    public const nint m_flAccelSpeed = 0x83C; // float
    public const nint m_flDecelSpeed = 0x840; // float
    public const nint m_bAccelToSpeed = 0x844; // bool
    public const nint m_flTimeScale = 0x848; // float
    public const nint m_flNextMPSoundTime = 0x84C; // GameTime_t
}

public static class CFuncTrain {
    public const nint m_hCurrentTarget = 0x7A8; // CHandle<CBaseEntity>
    public const nint m_activated = 0x7AC; // bool
    public const nint m_hEnemy = 0x7B0; // CHandle<CBaseEntity>
    public const nint m_flBlockDamage = 0x7B4; // float
    public const nint m_flNextBlockTime = 0x7B8; // GameTime_t
    public const nint m_iszLastTarget = 0x7C0; // CUtlSymbolLarge
}

public static class CFuncVPhysicsClip {
    public const nint m_bDisabled = 0x700; // bool
}

public static class CFuncWall {
    public const nint m_nState = 0x700; // int32_t
}

public static class CFuncWater {
    public const nint m_BuoyancyHelper = 0x700; // CBuoyancyHelper
}

public static class CGameChoreoServices {
    public const nint m_hOwner = 0x8; // CHandle<CBaseAnimGraph>
    public const nint m_hScriptedSequence = 0xC; // CHandle<CScriptedSequence>
    public const nint m_scriptState = 0x10; // IChoreoServices::ScriptState_t
    public const nint m_choreoState = 0x14; // IChoreoServices::ChoreoState_t
    public const nint m_flTimeStartedState = 0x18; // GameTime_t
}

public static class CGameGibManager {
    public const nint m_bAllowNewGibs = 0x4D0; // bool
    public const nint m_iCurrentMaxPieces = 0x4D4; // int32_t
    public const nint m_iMaxPieces = 0x4D8; // int32_t
    public const nint m_iLastFrame = 0x4DC; // int32_t
}

public static class CGameMoney {
    public const nint m_OnMoneySpent = 0x710; // CEntityIOOutput
    public const nint m_OnMoneySpentFail = 0x738; // CEntityIOOutput
    public const nint m_nMoney = 0x760; // int32_t
    public const nint m_strAwardText = 0x768; // CUtlString
}

public static class CGamePlayerZone {
    public const nint m_OnPlayerInZone = 0x708; // CEntityIOOutput
    public const nint m_OnPlayerOutZone = 0x730; // CEntityIOOutput
    public const nint m_PlayersInCount = 0x758; // CEntityOutputTemplate<int32_t>
    public const nint m_PlayersOutCount = 0x780; // CEntityOutputTemplate<int32_t>
}

public static class CGameRules {
    public const nint m_szQuestName = 0x8; // char[128]
    public const nint m_nQuestPhase = 0x88; // int32_t
}

public static class CGameSceneNode {
    public const nint m_nodeToWorld = 0x10; // CTransform
    public const nint m_pOwner = 0x30; // CEntityInstance*
    public const nint m_pParent = 0x38; // CGameSceneNode*
    public const nint m_pChild = 0x40; // CGameSceneNode*
    public const nint m_pNextSibling = 0x48; // CGameSceneNode*
    public const nint m_hParent = 0x70; // CGameSceneNodeHandle
    public const nint m_vecOrigin = 0x80; // CNetworkOriginCellCoordQuantizedVector
    public const nint m_angRotation = 0xB8; // QAngle
    public const nint m_flScale = 0xC4; // float
    public const nint m_vecAbsOrigin = 0xC8; // Vector
    public const nint m_angAbsRotation = 0xD4; // QAngle
    public const nint m_flAbsScale = 0xE0; // float
    public const nint m_nParentAttachmentOrBone = 0xE4; // int16_t
    public const nint m_bDebugAbsOriginChanges = 0xE6; // bool
    public const nint m_bDormant = 0xE7; // bool
    public const nint m_bForceParentToBeNetworked = 0xE8; // bool
    public const nint m_bDirtyHierarchy = 0x0; // bitfield:1
    public const nint m_bDirtyBoneMergeInfo = 0x0; // bitfield:1
    public const nint m_bNetworkedPositionChanged = 0x0; // bitfield:1
    public const nint m_bNetworkedAnglesChanged = 0x0; // bitfield:1
    public const nint m_bNetworkedScaleChanged = 0x0; // bitfield:1
    public const nint m_bWillBeCallingPostDataUpdate = 0x0; // bitfield:1
    public const nint m_bNotifyBoneTransformsChanged = 0x0; // bitfield:1
    public const nint m_bBoneMergeFlex = 0x0; // bitfield:1
    public const nint m_nLatchAbsOrigin = 0x0; // bitfield:2
    public const nint m_bDirtyBoneMergeBoneToRoot = 0x0; // bitfield:1
    public const nint m_nHierarchicalDepth = 0xEB; // uint8_t
    public const nint m_nHierarchyType = 0xEC; // uint8_t
    public const nint m_nDoNotSetAnimTimeInInvalidatePhysicsCount = 0xED; // uint8_t
    public const nint m_name = 0xF0; // CUtlStringToken
    public const nint m_hierarchyAttachName = 0x130; // CUtlStringToken
    public const nint m_flZOffset = 0x134; // float
    public const nint m_vRenderOrigin = 0x138; // Vector
}

public static class CGameSceneNodeHandle {
    public const nint m_hOwner = 0x8; // CEntityHandle
    public const nint m_name = 0xC; // CUtlStringToken
}

public static class CGameScriptedMoveData {
    public const nint m_vDest = 0x0; // Vector
    public const nint m_vSrc = 0xC; // Vector
    public const nint m_angSrc = 0x18; // QAngle
    public const nint m_angDst = 0x24; // QAngle
    public const nint m_angCurrent = 0x30; // QAngle
    public const nint m_flAngRate = 0x3C; // float
    public const nint m_flDuration = 0x40; // float
    public const nint m_flStartTime = 0x44; // GameTime_t
    public const nint m_nPrevMoveType = 0x48; // MoveType_t
    public const nint m_bActive = 0x49; // bool
    public const nint m_bTeleportOnEnd = 0x4A; // bool
    public const nint m_bEndOnDestinationReached = 0x4B; // bool
    public const nint m_bIgnoreRotation = 0x4C; // bool
    public const nint m_nType = 0x50; // ScriptedMoveType_t
    public const nint m_bSuccess = 0x54; // bool
    public const nint m_nForcedCrouchState = 0x58; // ForcedCrouchState_t
    public const nint m_bIgnoreCollisions = 0x5C; // bool
}

public static class CGameText {
    public const nint m_iszMessage = 0x710; // CUtlSymbolLarge
    public const nint m_textParms = 0x718; // hudtextparms_t
}

public static class CGenericConstraint {
    public const nint m_nLinearMotionX = 0x510; // JointMotion_t
    public const nint m_nLinearMotionY = 0x514; // JointMotion_t
    public const nint m_nLinearMotionZ = 0x518; // JointMotion_t
    public const nint m_flLinearFrequencyX = 0x51C; // float
    public const nint m_flLinearFrequencyY = 0x520; // float
    public const nint m_flLinearFrequencyZ = 0x524; // float
    public const nint m_flLinearDampingRatioX = 0x528; // float
    public const nint m_flLinearDampingRatioY = 0x52C; // float
    public const nint m_flLinearDampingRatioZ = 0x530; // float
    public const nint m_flMaxLinearImpulseX = 0x534; // float
    public const nint m_flMaxLinearImpulseY = 0x538; // float
    public const nint m_flMaxLinearImpulseZ = 0x53C; // float
    public const nint m_flBreakAfterTimeX = 0x540; // float
    public const nint m_flBreakAfterTimeY = 0x544; // float
    public const nint m_flBreakAfterTimeZ = 0x548; // float
    public const nint m_flBreakAfterTimeStartTimeX = 0x54C; // GameTime_t
    public const nint m_flBreakAfterTimeStartTimeY = 0x550; // GameTime_t
    public const nint m_flBreakAfterTimeStartTimeZ = 0x554; // GameTime_t
    public const nint m_flBreakAfterTimeThresholdX = 0x558; // float
    public const nint m_flBreakAfterTimeThresholdY = 0x55C; // float
    public const nint m_flBreakAfterTimeThresholdZ = 0x560; // float
    public const nint m_flNotifyForceX = 0x564; // float
    public const nint m_flNotifyForceY = 0x568; // float
    public const nint m_flNotifyForceZ = 0x56C; // float
    public const nint m_flNotifyForceMinTimeX = 0x570; // float
    public const nint m_flNotifyForceMinTimeY = 0x574; // float
    public const nint m_flNotifyForceMinTimeZ = 0x578; // float
    public const nint m_flNotifyForceLastTimeX = 0x57C; // GameTime_t
    public const nint m_flNotifyForceLastTimeY = 0x580; // GameTime_t
    public const nint m_flNotifyForceLastTimeZ = 0x584; // GameTime_t
    public const nint m_bAxisNotifiedX = 0x588; // bool
    public const nint m_bAxisNotifiedY = 0x589; // bool
    public const nint m_bAxisNotifiedZ = 0x58A; // bool
    public const nint m_nAngularMotionX = 0x58C; // JointMotion_t
    public const nint m_nAngularMotionY = 0x590; // JointMotion_t
    public const nint m_nAngularMotionZ = 0x594; // JointMotion_t
    public const nint m_flAngularFrequencyX = 0x598; // float
    public const nint m_flAngularFrequencyY = 0x59C; // float
    public const nint m_flAngularFrequencyZ = 0x5A0; // float
    public const nint m_flAngularDampingRatioX = 0x5A4; // float
    public const nint m_flAngularDampingRatioY = 0x5A8; // float
    public const nint m_flAngularDampingRatioZ = 0x5AC; // float
    public const nint m_flMaxAngularImpulseX = 0x5B0; // float
    public const nint m_flMaxAngularImpulseY = 0x5B4; // float
    public const nint m_flMaxAngularImpulseZ = 0x5B8; // float
    public const nint m_NotifyForceReachedX = 0x5C0; // CEntityIOOutput
    public const nint m_NotifyForceReachedY = 0x5E8; // CEntityIOOutput
    public const nint m_NotifyForceReachedZ = 0x610; // CEntityIOOutput
}

public static class CGlowProperty {
    public const nint m_fGlowColor = 0x8; // Vector
    public const nint m_iGlowType = 0x30; // int32_t
    public const nint m_iGlowTeam = 0x34; // int32_t
    public const nint m_nGlowRange = 0x38; // int32_t
    public const nint m_nGlowRangeMin = 0x3C; // int32_t
    public const nint m_glowColorOverride = 0x40; // Color
    public const nint m_bFlashing = 0x44; // bool
    public const nint m_flGlowTime = 0x48; // float
    public const nint m_flGlowStartTime = 0x4C; // float
    public const nint m_bEligibleForScreenHighlight = 0x50; // bool
    public const nint m_bGlowing = 0x51; // bool
}

public static class CGradientFog {
    public const nint m_hGradientFogTexture = 0x4B0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_flFogStartDistance = 0x4B8; // float
    public const nint m_flFogEndDistance = 0x4BC; // float
    public const nint m_bHeightFogEnabled = 0x4C0; // bool
    public const nint m_flFogStartHeight = 0x4C4; // float
    public const nint m_flFogEndHeight = 0x4C8; // float
    public const nint m_flFarZ = 0x4CC; // float
    public const nint m_flFogMaxOpacity = 0x4D0; // float
    public const nint m_flFogFalloffExponent = 0x4D4; // float
    public const nint m_flFogVerticalExponent = 0x4D8; // float
    public const nint m_fogColor = 0x4DC; // Color
    public const nint m_flFogStrength = 0x4E0; // float
    public const nint m_flFadeTime = 0x4E4; // float
    public const nint m_bStartDisabled = 0x4E8; // bool
    public const nint m_bIsEnabled = 0x4E9; // bool
    public const nint m_bGradientFogNeedsTextures = 0x4EA; // bool
}

public static class CGunTarget {
    public const nint m_on = 0x780; // bool
    public const nint m_hTargetEnt = 0x784; // CHandle<CBaseEntity>
    public const nint m_OnDeath = 0x788; // CEntityIOOutput
}

public static class CHandleTest {
    public const nint m_Handle = 0x4B0; // CHandle<CBaseEntity>
    public const nint m_bSendHandle = 0x4B4; // bool
}

public static class CHintMessage {
    public const nint m_hintString = 0x8; // char*
    public const nint m_args = 0x10; // CUtlVector<char*>
    public const nint m_duration = 0x28; // float
}

public static class CHintMessageQueue {
    public const nint m_tmMessageEnd = 0x8; // float
    public const nint m_messages = 0x10; // CUtlVector<CHintMessage*>
    public const nint m_pPlayerController = 0x28; // CBasePlayerController*
}

public static class CHitboxComponent {
    public const nint m_bvDisabledHitGroups = 0x24; // uint32_t[1]
}

public static class CHostage {
    public const nint m_OnHostageBeginGrab = 0x9E8; // CEntityIOOutput
    public const nint m_OnFirstPickedUp = 0xA10; // CEntityIOOutput
    public const nint m_OnDroppedNotRescued = 0xA38; // CEntityIOOutput
    public const nint m_OnRescued = 0xA60; // CEntityIOOutput
    public const nint m_entitySpottedState = 0xA88; // EntitySpottedState_t
    public const nint m_nSpotRules = 0xAA0; // int32_t
    public const nint m_uiHostageSpawnExclusionGroupMask = 0xAA4; // uint32_t
    public const nint m_nHostageSpawnRandomFactor = 0xAA8; // uint32_t
    public const nint m_bRemove = 0xAAC; // bool
    public const nint m_vel = 0xAB0; // Vector
    public const nint m_isRescued = 0xABC; // bool
    public const nint m_jumpedThisFrame = 0xABD; // bool
    public const nint m_nHostageState = 0xAC0; // int32_t
    public const nint m_leader = 0xAC4; // CHandle<CBaseEntity>
    public const nint m_lastLeader = 0xAC8; // CHandle<CCSPlayerPawnBase>
    public const nint m_reuseTimer = 0xAD0; // CountdownTimer
    public const nint m_hasBeenUsed = 0xAE8; // bool
    public const nint m_accel = 0xAEC; // Vector
    public const nint m_isRunning = 0xAF8; // bool
    public const nint m_isCrouching = 0xAF9; // bool
    public const nint m_jumpTimer = 0xB00; // CountdownTimer
    public const nint m_isWaitingForLeader = 0xB18; // bool
    public const nint m_repathTimer = 0x2B28; // CountdownTimer
    public const nint m_inhibitDoorTimer = 0x2B40; // CountdownTimer
    public const nint m_inhibitObstacleAvoidanceTimer = 0x2BD0; // CountdownTimer
    public const nint m_wiggleTimer = 0x2BF0; // CountdownTimer
    public const nint m_isAdjusted = 0x2C0C; // bool
    public const nint m_bHandsHaveBeenCut = 0x2C0D; // bool
    public const nint m_hHostageGrabber = 0x2C10; // CHandle<CCSPlayerPawn>
    public const nint m_fLastGrabTime = 0x2C14; // GameTime_t
    public const nint m_vecPositionWhenStartedDroppingToGround = 0x2C18; // Vector
    public const nint m_vecGrabbedPos = 0x2C24; // Vector
    public const nint m_flRescueStartTime = 0x2C30; // GameTime_t
    public const nint m_flGrabSuccessTime = 0x2C34; // GameTime_t
    public const nint m_flDropStartTime = 0x2C38; // GameTime_t
    public const nint m_nApproachRewardPayouts = 0x2C3C; // int32_t
    public const nint m_nPickupEventCount = 0x2C40; // int32_t
    public const nint m_vecSpawnGroundPos = 0x2C44; // Vector
    public const nint m_vecHostageResetPosition = 0x2C64; // Vector
}

public static class CHostageExpresserShim {
    public const nint m_pExpresser = 0x9D0; // CAI_Expresser*
}

public static class CInButtonState {
    public const nint m_pButtonStates = 0x8; // uint64_t[3]
}

public static class CInferno {
    public const nint m_firePositions = 0x710; // Vector[64]
    public const nint m_fireParentPositions = 0xA10; // Vector[64]
    public const nint m_bFireIsBurning = 0xD10; // bool[64]
    public const nint m_BurnNormal = 0xD50; // Vector[64]
    public const nint m_fireCount = 0x1050; // int32_t
    public const nint m_nInfernoType = 0x1054; // int32_t
    public const nint m_nFireEffectTickBegin = 0x1058; // int32_t
    public const nint m_nFireLifetime = 0x105C; // float
    public const nint m_bInPostEffectTime = 0x1060; // bool
    public const nint m_nFiresExtinguishCount = 0x1064; // int32_t
    public const nint m_bWasCreatedInSmoke = 0x1068; // bool
    public const nint m_extent = 0x1270; // Extent
    public const nint m_damageTimer = 0x1288; // CountdownTimer
    public const nint m_damageRampTimer = 0x12A0; // CountdownTimer
    public const nint m_splashVelocity = 0x12B8; // Vector
    public const nint m_InitialSplashVelocity = 0x12C4; // Vector
    public const nint m_startPos = 0x12D0; // Vector
    public const nint m_vecOriginalSpawnLocation = 0x12DC; // Vector
    public const nint m_activeTimer = 0x12E8; // IntervalTimer
    public const nint m_fireSpawnOffset = 0x12F8; // int32_t
    public const nint m_nMaxFlames = 0x12FC; // int32_t
    public const nint m_BookkeepingTimer = 0x1300; // CountdownTimer
    public const nint m_NextSpreadTimer = 0x1318; // CountdownTimer
    public const nint m_nSourceItemDefIndex = 0x1330; // uint16_t
}

public static class CInfoDynamicShadowHint {
    public const nint m_bDisabled = 0x4B0; // bool
    public const nint m_flRange = 0x4B4; // float
    public const nint m_nImportance = 0x4B8; // int32_t
    public const nint m_nLightChoice = 0x4BC; // int32_t
    public const nint m_hLight = 0x4C0; // CHandle<CBaseEntity>
}

public static class CInfoDynamicShadowHintBox {
    public const nint m_vBoxMins = 0x4C8; // Vector
    public const nint m_vBoxMaxs = 0x4D4; // Vector
}

public static class CInfoGameEventProxy {
    public const nint m_iszEventName = 0x4B0; // CUtlSymbolLarge
    public const nint m_flRange = 0x4B8; // float
}

public static class CInfoOffscreenPanoramaTexture {
    public const nint m_bDisabled = 0x4B0; // bool
    public const nint m_nResolutionX = 0x4B4; // int32_t
    public const nint m_nResolutionY = 0x4B8; // int32_t
    public const nint m_szLayoutFileName = 0x4C0; // CUtlSymbolLarge
    public const nint m_RenderAttrName = 0x4C8; // CUtlSymbolLarge
    public const nint m_TargetEntities = 0x4D0; // CNetworkUtlVectorBase<CHandle<CBaseModelEntity>>
    public const nint m_nTargetChangeCount = 0x4E8; // int32_t
    public const nint m_vecCSSClasses = 0x4F0; // CNetworkUtlVectorBase<CUtlSymbolLarge>
    public const nint m_szTargetsName = 0x508; // CUtlSymbolLarge
    public const nint m_AdditionalTargetEntities = 0x510; // CUtlVector<CHandle<CBaseModelEntity>>
}

public static class CInfoPlayerStart {
    public const nint m_bDisabled = 0x4B0; // bool
}

public static class CInfoSpawnGroupLoadUnload {
    public const nint m_OnSpawnGroupLoadStarted = 0x4B0; // CEntityIOOutput
    public const nint m_OnSpawnGroupLoadFinished = 0x4D8; // CEntityIOOutput
    public const nint m_OnSpawnGroupUnloadStarted = 0x500; // CEntityIOOutput
    public const nint m_OnSpawnGroupUnloadFinished = 0x528; // CEntityIOOutput
    public const nint m_iszSpawnGroupName = 0x550; // CUtlSymbolLarge
    public const nint m_iszSpawnGroupFilterName = 0x558; // CUtlSymbolLarge
    public const nint m_iszLandmarkName = 0x560; // CUtlSymbolLarge
    public const nint m_sFixedSpawnGroupName = 0x568; // CUtlString
    public const nint m_flTimeoutInterval = 0x570; // float
    public const nint m_bStreamingStarted = 0x574; // bool
    public const nint m_bUnloadingStarted = 0x575; // bool
}

public static class CInfoVisibilityBox {
    public const nint m_nMode = 0x4B4; // int32_t
    public const nint m_vBoxSize = 0x4B8; // Vector
    public const nint m_bEnabled = 0x4C4; // bool
}

public static class CInfoWorldLayer {
    public const nint m_pOutputOnEntitiesSpawned = 0x4B0; // CEntityIOOutput
    public const nint m_worldName = 0x4D8; // CUtlSymbolLarge
    public const nint m_layerName = 0x4E0; // CUtlSymbolLarge
    public const nint m_bWorldLayerVisible = 0x4E8; // bool
    public const nint m_bEntitiesSpawned = 0x4E9; // bool
    public const nint m_bCreateAsChildSpawnGroup = 0x4EA; // bool
    public const nint m_hLayerSpawnGroup = 0x4EC; // uint32_t
}

public static class CInstancedSceneEntity {
    public const nint m_hOwner = 0xA08; // CHandle<CBaseEntity>
    public const nint m_bHadOwner = 0xA0C; // bool
    public const nint m_flPostSpeakDelay = 0xA10; // float
    public const nint m_flPreDelay = 0xA14; // float
    public const nint m_bIsBackground = 0xA18; // bool
}

public static class CInstructorEventEntity {
    public const nint m_iszName = 0x4B0; // CUtlSymbolLarge
    public const nint m_iszHintTargetEntity = 0x4B8; // CUtlSymbolLarge
    public const nint m_hTargetPlayer = 0x4C0; // CHandle<CBasePlayerPawn>
}

public static class CIronSightController {
    public const nint m_bIronSightAvailable = 0x8; // bool
    public const nint m_flIronSightAmount = 0xC; // float
    public const nint m_flIronSightAmountGained = 0x10; // float
    public const nint m_flIronSightAmountBiased = 0x14; // float
}

public static class CItem {
    public const nint m_OnPlayerTouch = 0x898; // CEntityIOOutput
    public const nint m_bActivateWhenAtRest = 0x8C0; // bool
    public const nint m_OnCacheInteraction = 0x8C8; // CEntityIOOutput
    public const nint m_OnPlayerPickup = 0x8F0; // CEntityIOOutput
    public const nint m_OnGlovePulled = 0x918; // CEntityIOOutput
    public const nint m_vOriginalSpawnOrigin = 0x940; // Vector
    public const nint m_vOriginalSpawnAngles = 0x94C; // QAngle
    public const nint m_bPhysStartAsleep = 0x958; // bool
}

public static class CItemDefuser {
    public const nint m_entitySpottedState = 0x968; // EntitySpottedState_t
    public const nint m_nSpotRules = 0x980; // int32_t
}

public static class CItemDogtags {
    public const nint m_OwningPlayer = 0x968; // CHandle<CCSPlayerPawn>
    public const nint m_KillingPlayer = 0x96C; // CHandle<CCSPlayerPawn>
}

public static class CItemGeneric {
    public const nint m_bHasTriggerRadius = 0x970; // bool
    public const nint m_bHasPickupRadius = 0x971; // bool
    public const nint m_flPickupRadiusSqr = 0x974; // float
    public const nint m_flTriggerRadiusSqr = 0x978; // float
    public const nint m_flLastPickupCheck = 0x97C; // GameTime_t
    public const nint m_bPlayerCounterListenerAdded = 0x980; // bool
    public const nint m_bPlayerInTriggerRadius = 0x981; // bool
    public const nint m_hSpawnParticleEffect = 0x988; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    public const nint m_pAmbientSoundEffect = 0x990; // CUtlSymbolLarge
    public const nint m_bAutoStartAmbientSound = 0x998; // bool
    public const nint m_pSpawnScriptFunction = 0x9A0; // CUtlSymbolLarge
    public const nint m_hPickupParticleEffect = 0x9A8; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    public const nint m_pPickupSoundEffect = 0x9B0; // CUtlSymbolLarge
    public const nint m_pPickupScriptFunction = 0x9B8; // CUtlSymbolLarge
    public const nint m_hTimeoutParticleEffect = 0x9C0; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    public const nint m_pTimeoutSoundEffect = 0x9C8; // CUtlSymbolLarge
    public const nint m_pTimeoutScriptFunction = 0x9D0; // CUtlSymbolLarge
    public const nint m_pPickupFilterName = 0x9D8; // CUtlSymbolLarge
    public const nint m_hPickupFilter = 0x9E0; // CHandle<CBaseFilter>
    public const nint m_OnPickup = 0x9E8; // CEntityIOOutput
    public const nint m_OnTimeout = 0xA10; // CEntityIOOutput
    public const nint m_OnTriggerStartTouch = 0xA38; // CEntityIOOutput
    public const nint m_OnTriggerTouch = 0xA60; // CEntityIOOutput
    public const nint m_OnTriggerEndTouch = 0xA88; // CEntityIOOutput
    public const nint m_pAllowPickupScriptFunction = 0xAB0; // CUtlSymbolLarge
    public const nint m_flPickupRadius = 0xAB8; // float
    public const nint m_flTriggerRadius = 0xABC; // float
    public const nint m_pTriggerSoundEffect = 0xAC0; // CUtlSymbolLarge
    public const nint m_bGlowWhenInTrigger = 0xAC8; // bool
    public const nint m_glowColor = 0xAC9; // Color
    public const nint m_bUseable = 0xACD; // bool
    public const nint m_hTriggerHelper = 0xAD0; // CHandle<CItemGenericTriggerHelper>
}

public static class CItemGenericTriggerHelper {
    public const nint m_hParentItem = 0x700; // CHandle<CItemGeneric>
}

public static class CKeepUpright {
    public const nint m_worldGoalAxis = 0x4B8; // Vector
    public const nint m_localTestAxis = 0x4C4; // Vector
    public const nint m_nameAttach = 0x4D8; // CUtlSymbolLarge
    public const nint m_attachedObject = 0x4E0; // CHandle<CBaseEntity>
    public const nint m_angularLimit = 0x4E4; // float
    public const nint m_bActive = 0x4E8; // bool
    public const nint m_bDampAllRotation = 0x4E9; // bool
}

public static class CKnife {
    public const nint m_bFirstAttack = 0xE20; // bool
}

public static class CLightComponent {
    public const nint __m_pChainEntity = 0x48; // CNetworkVarChainer
    public const nint m_Color = 0x85; // Color
    public const nint m_SecondaryColor = 0x89; // Color
    public const nint m_flBrightness = 0x90; // float
    public const nint m_flBrightnessScale = 0x94; // float
    public const nint m_flBrightnessMult = 0x98; // float
    public const nint m_flRange = 0x9C; // float
    public const nint m_flFalloff = 0xA0; // float
    public const nint m_flAttenuation0 = 0xA4; // float
    public const nint m_flAttenuation1 = 0xA8; // float
    public const nint m_flAttenuation2 = 0xAC; // float
    public const nint m_flTheta = 0xB0; // float
    public const nint m_flPhi = 0xB4; // float
    public const nint m_hLightCookie = 0xB8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_nCascades = 0xC0; // int32_t
    public const nint m_nCastShadows = 0xC4; // int32_t
    public const nint m_nShadowWidth = 0xC8; // int32_t
    public const nint m_nShadowHeight = 0xCC; // int32_t
    public const nint m_bRenderDiffuse = 0xD0; // bool
    public const nint m_nRenderSpecular = 0xD4; // int32_t
    public const nint m_bRenderTransmissive = 0xD8; // bool
    public const nint m_flOrthoLightWidth = 0xDC; // float
    public const nint m_flOrthoLightHeight = 0xE0; // float
    public const nint m_nStyle = 0xE4; // int32_t
    public const nint m_Pattern = 0xE8; // CUtlString
    public const nint m_nCascadeRenderStaticObjects = 0xF0; // int32_t
    public const nint m_flShadowCascadeCrossFade = 0xF4; // float
    public const nint m_flShadowCascadeDistanceFade = 0xF8; // float
    public const nint m_flShadowCascadeDistance0 = 0xFC; // float
    public const nint m_flShadowCascadeDistance1 = 0x100; // float
    public const nint m_flShadowCascadeDistance2 = 0x104; // float
    public const nint m_flShadowCascadeDistance3 = 0x108; // float
    public const nint m_nShadowCascadeResolution0 = 0x10C; // int32_t
    public const nint m_nShadowCascadeResolution1 = 0x110; // int32_t
    public const nint m_nShadowCascadeResolution2 = 0x114; // int32_t
    public const nint m_nShadowCascadeResolution3 = 0x118; // int32_t
    public const nint m_bUsesBakedShadowing = 0x11C; // bool
    public const nint m_nShadowPriority = 0x120; // int32_t
    public const nint m_nBakedShadowIndex = 0x124; // int32_t
    public const nint m_bRenderToCubemaps = 0x128; // bool
    public const nint m_nDirectLight = 0x12C; // int32_t
    public const nint m_nIndirectLight = 0x130; // int32_t
    public const nint m_flFadeMinDist = 0x134; // float
    public const nint m_flFadeMaxDist = 0x138; // float
    public const nint m_flShadowFadeMinDist = 0x13C; // float
    public const nint m_flShadowFadeMaxDist = 0x140; // float
    public const nint m_bEnabled = 0x144; // bool
    public const nint m_bFlicker = 0x145; // bool
    public const nint m_bPrecomputedFieldsValid = 0x146; // bool
    public const nint m_vPrecomputedBoundsMins = 0x148; // Vector
    public const nint m_vPrecomputedBoundsMaxs = 0x154; // Vector
    public const nint m_vPrecomputedOBBOrigin = 0x160; // Vector
    public const nint m_vPrecomputedOBBAngles = 0x16C; // QAngle
    public const nint m_vPrecomputedOBBExtent = 0x178; // Vector
    public const nint m_flPrecomputedMaxRange = 0x184; // float
    public const nint m_nFogLightingMode = 0x188; // int32_t
    public const nint m_flFogContributionStength = 0x18C; // float
    public const nint m_flNearClipPlane = 0x190; // float
    public const nint m_SkyColor = 0x194; // Color
    public const nint m_flSkyIntensity = 0x198; // float
    public const nint m_SkyAmbientBounce = 0x19C; // Color
    public const nint m_bUseSecondaryColor = 0x1A0; // bool
    public const nint m_bMixedShadows = 0x1A1; // bool
    public const nint m_flLightStyleStartTime = 0x1A4; // GameTime_t
    public const nint m_flCapsuleLength = 0x1A8; // float
    public const nint m_flMinRoughness = 0x1AC; // float
    public const nint m_bPvsModifyEntity = 0x1C0; // bool
}

public static class CLightEntity {
    public const nint m_CLightComponent = 0x700; // CLightComponent*
}

public static class CLightGlow {
    public const nint m_nHorizontalSize = 0x700; // uint32_t
    public const nint m_nVerticalSize = 0x704; // uint32_t
    public const nint m_nMinDist = 0x708; // uint32_t
    public const nint m_nMaxDist = 0x70C; // uint32_t
    public const nint m_nOuterMaxDist = 0x710; // uint32_t
    public const nint m_flGlowProxySize = 0x714; // float
    public const nint m_flHDRColorScale = 0x718; // float
}

public static class CLogicAchievement {
    public const nint m_bDisabled = 0x4B0; // bool
    public const nint m_iszAchievementEventID = 0x4B8; // CUtlSymbolLarge
    public const nint m_OnFired = 0x4C0; // CEntityIOOutput
}

public static class CLogicActiveAutosave {
    public const nint m_TriggerHitPoints = 0x4C0; // int32_t
    public const nint m_flTimeToTrigger = 0x4C4; // float
    public const nint m_flStartTime = 0x4C8; // GameTime_t
    public const nint m_flDangerousTime = 0x4CC; // float
}

public static class CLogicAuto {
    public const nint m_OnMapSpawn = 0x4B0; // CEntityIOOutput
    public const nint m_OnDemoMapSpawn = 0x4D8; // CEntityIOOutput
    public const nint m_OnNewGame = 0x500; // CEntityIOOutput
    public const nint m_OnLoadGame = 0x528; // CEntityIOOutput
    public const nint m_OnMapTransition = 0x550; // CEntityIOOutput
    public const nint m_OnBackgroundMap = 0x578; // CEntityIOOutput
    public const nint m_OnMultiNewMap = 0x5A0; // CEntityIOOutput
    public const nint m_OnMultiNewRound = 0x5C8; // CEntityIOOutput
    public const nint m_OnVREnabled = 0x5F0; // CEntityIOOutput
    public const nint m_OnVRNotEnabled = 0x618; // CEntityIOOutput
    public const nint m_globalstate = 0x640; // CUtlSymbolLarge
}

public static class CLogicAutosave {
    public const nint m_bForceNewLevelUnit = 0x4B0; // bool
    public const nint m_minHitPoints = 0x4B4; // int32_t
    public const nint m_minHitPointsToCommit = 0x4B8; // int32_t
}

public static class CLogicBranch {
    public const nint m_bInValue = 0x4B0; // bool
    public const nint m_Listeners = 0x4B8; // CUtlVector<CHandle<CBaseEntity>>
    public const nint m_OnTrue = 0x4D0; // CEntityIOOutput
    public const nint m_OnFalse = 0x4F8; // CEntityIOOutput
}

public static class CLogicBranchList {
    public const nint m_nLogicBranchNames = 0x4B0; // CUtlSymbolLarge[16]
    public const nint m_LogicBranchList = 0x530; // CUtlVector<CHandle<CBaseEntity>>
    public const nint m_eLastState = 0x548; // CLogicBranchList::LogicBranchListenerLastState_t
    public const nint m_OnAllTrue = 0x550; // CEntityIOOutput
    public const nint m_OnAllFalse = 0x578; // CEntityIOOutput
    public const nint m_OnMixed = 0x5A0; // CEntityIOOutput
}

public static class CLogicCase {
    public const nint m_nCase = 0x4B0; // CUtlSymbolLarge[32]
    public const nint m_nShuffleCases = 0x5B0; // int32_t
    public const nint m_nLastShuffleCase = 0x5B4; // int32_t
    public const nint m_uchShuffleCaseMap = 0x5B8; // uint8_t[32]
    public const nint m_OnCase = 0x5D8; // CEntityIOOutput[32]
    public const nint m_OnDefault = 0xAD8; // CEntityOutputTemplate<CVariantBase<CVariantDefaultAllocator>>
}

public static class CLogicCollisionPair {
    public const nint m_nameAttach1 = 0x4B0; // CUtlSymbolLarge
    public const nint m_nameAttach2 = 0x4B8; // CUtlSymbolLarge
    public const nint m_disabled = 0x4C0; // bool
    public const nint m_succeeded = 0x4C1; // bool
}

public static class CLogicCompare {
    public const nint m_flInValue = 0x4B0; // float
    public const nint m_flCompareValue = 0x4B4; // float
    public const nint m_OnLessThan = 0x4B8; // CEntityOutputTemplate<float>
    public const nint m_OnEqualTo = 0x4E0; // CEntityOutputTemplate<float>
    public const nint m_OnNotEqualTo = 0x508; // CEntityOutputTemplate<float>
    public const nint m_OnGreaterThan = 0x530; // CEntityOutputTemplate<float>
}

public static class CLogicDistanceAutosave {
    public const nint m_iszTargetEntity = 0x4B0; // CUtlSymbolLarge
    public const nint m_flDistanceToPlayer = 0x4B8; // float
    public const nint m_bForceNewLevelUnit = 0x4BC; // bool
    public const nint m_bCheckCough = 0x4BD; // bool
    public const nint m_bThinkDangerous = 0x4BE; // bool
    public const nint m_flDangerousTime = 0x4C0; // float
}

public static class CLogicDistanceCheck {
    public const nint m_iszEntityA = 0x4B0; // CUtlSymbolLarge
    public const nint m_iszEntityB = 0x4B8; // CUtlSymbolLarge
    public const nint m_flZone1Distance = 0x4C0; // float
    public const nint m_flZone2Distance = 0x4C4; // float
    public const nint m_InZone1 = 0x4C8; // CEntityIOOutput
    public const nint m_InZone2 = 0x4F0; // CEntityIOOutput
    public const nint m_InZone3 = 0x518; // CEntityIOOutput
}

public static class CLogicEventListener {
    public const nint m_strEventName = 0x4C0; // CUtlString
    public const nint m_bIsEnabled = 0x4C8; // bool
    public const nint m_nTeam = 0x4CC; // int32_t
    public const nint m_OnEventFired = 0x4D0; // CEntityIOOutput
}

public static class CLogicGameEvent {
    public const nint m_iszEventName = 0x4B0; // CUtlSymbolLarge
}

public static class CLogicGameEventListener {
    public const nint m_OnEventFired = 0x4C0; // CEntityIOOutput
    public const nint m_iszGameEventName = 0x4E8; // CUtlSymbolLarge
    public const nint m_iszGameEventItem = 0x4F0; // CUtlSymbolLarge
    public const nint m_bEnabled = 0x4F8; // bool
    public const nint m_bStartDisabled = 0x4F9; // bool
}

public static class CLogicLineToEntity {
    public const nint m_Line = 0x4B0; // CEntityOutputTemplate<Vector>
    public const nint m_SourceName = 0x4D8; // CUtlSymbolLarge
    public const nint m_StartEntity = 0x4E0; // CHandle<CBaseEntity>
    public const nint m_EndEntity = 0x4E4; // CHandle<CBaseEntity>
}

public static class CLogicMeasureMovement {
    public const nint m_strMeasureTarget = 0x4B0; // CUtlSymbolLarge
    public const nint m_strMeasureReference = 0x4B8; // CUtlSymbolLarge
    public const nint m_strTargetReference = 0x4C0; // CUtlSymbolLarge
    public const nint m_hMeasureTarget = 0x4C8; // CHandle<CBaseEntity>
    public const nint m_hMeasureReference = 0x4CC; // CHandle<CBaseEntity>
    public const nint m_hTarget = 0x4D0; // CHandle<CBaseEntity>
    public const nint m_hTargetReference = 0x4D4; // CHandle<CBaseEntity>
    public const nint m_flScale = 0x4D8; // float
    public const nint m_nMeasureType = 0x4DC; // int32_t
}

public static class CLogicNPCCounter {
    public const nint m_OnMinCountAll = 0x4B0; // CEntityIOOutput
    public const nint m_OnMaxCountAll = 0x4D8; // CEntityIOOutput
    public const nint m_OnFactorAll = 0x500; // CEntityOutputTemplate<float>
    public const nint m_OnMinPlayerDistAll = 0x528; // CEntityOutputTemplate<float>
    public const nint m_OnMinCount_1 = 0x550; // CEntityIOOutput
    public const nint m_OnMaxCount_1 = 0x578; // CEntityIOOutput
    public const nint m_OnFactor_1 = 0x5A0; // CEntityOutputTemplate<float>
    public const nint m_OnMinPlayerDist_1 = 0x5C8; // CEntityOutputTemplate<float>
    public const nint m_OnMinCount_2 = 0x5F0; // CEntityIOOutput
    public const nint m_OnMaxCount_2 = 0x618; // CEntityIOOutput
    public const nint m_OnFactor_2 = 0x640; // CEntityOutputTemplate<float>
    public const nint m_OnMinPlayerDist_2 = 0x668; // CEntityOutputTemplate<float>
    public const nint m_OnMinCount_3 = 0x690; // CEntityIOOutput
    public const nint m_OnMaxCount_3 = 0x6B8; // CEntityIOOutput
    public const nint m_OnFactor_3 = 0x6E0; // CEntityOutputTemplate<float>
    public const nint m_OnMinPlayerDist_3 = 0x708; // CEntityOutputTemplate<float>
    public const nint m_hSource = 0x730; // CEntityHandle
    public const nint m_iszSourceEntityName = 0x738; // CUtlSymbolLarge
    public const nint m_flDistanceMax = 0x740; // float
    public const nint m_bDisabled = 0x744; // bool
    public const nint m_nMinCountAll = 0x748; // int32_t
    public const nint m_nMaxCountAll = 0x74C; // int32_t
    public const nint m_nMinFactorAll = 0x750; // int32_t
    public const nint m_nMaxFactorAll = 0x754; // int32_t
    public const nint m_iszNPCClassname_1 = 0x760; // CUtlSymbolLarge
    public const nint m_nNPCState_1 = 0x768; // int32_t
    public const nint m_bInvertState_1 = 0x76C; // bool
    public const nint m_nMinCount_1 = 0x770; // int32_t
    public const nint m_nMaxCount_1 = 0x774; // int32_t
    public const nint m_nMinFactor_1 = 0x778; // int32_t
    public const nint m_nMaxFactor_1 = 0x77C; // int32_t
    public const nint m_flDefaultDist_1 = 0x784; // float
    public const nint m_iszNPCClassname_2 = 0x788; // CUtlSymbolLarge
    public const nint m_nNPCState_2 = 0x790; // int32_t
    public const nint m_bInvertState_2 = 0x794; // bool
    public const nint m_nMinCount_2 = 0x798; // int32_t
    public const nint m_nMaxCount_2 = 0x79C; // int32_t
    public const nint m_nMinFactor_2 = 0x7A0; // int32_t
    public const nint m_nMaxFactor_2 = 0x7A4; // int32_t
    public const nint m_flDefaultDist_2 = 0x7AC; // float
    public const nint m_iszNPCClassname_3 = 0x7B0; // CUtlSymbolLarge
    public const nint m_nNPCState_3 = 0x7B8; // int32_t
    public const nint m_bInvertState_3 = 0x7BC; // bool
    public const nint m_nMinCount_3 = 0x7C0; // int32_t
    public const nint m_nMaxCount_3 = 0x7C4; // int32_t
    public const nint m_nMinFactor_3 = 0x7C8; // int32_t
    public const nint m_nMaxFactor_3 = 0x7CC; // int32_t
    public const nint m_flDefaultDist_3 = 0x7D4; // float
}

public static class CLogicNPCCounterAABB {
    public const nint m_vDistanceOuterMins = 0x7F0; // Vector
    public const nint m_vDistanceOuterMaxs = 0x7FC; // Vector
    public const nint m_vOuterMins = 0x808; // Vector
    public const nint m_vOuterMaxs = 0x814; // Vector
}

public static class CLogicNavigation {
    public const nint m_isOn = 0x4B8; // bool
    public const nint m_navProperty = 0x4BC; // navproperties_t
}

public static class CLogicPlayerProxy {
    public const nint m_hPlayer = 0x4B0; // CHandle<CBaseEntity>
    public const nint m_PlayerHasAmmo = 0x4B8; // CEntityIOOutput
    public const nint m_PlayerHasNoAmmo = 0x4E0; // CEntityIOOutput
    public const nint m_PlayerDied = 0x508; // CEntityIOOutput
    public const nint m_RequestedPlayerHealth = 0x530; // CEntityOutputTemplate<int32_t>
}

public static class CLogicRelay {
    public const nint m_OnTrigger = 0x4B0; // CEntityIOOutput
    public const nint m_OnSpawn = 0x4D8; // CEntityIOOutput
    public const nint m_bDisabled = 0x500; // bool
    public const nint m_bWaitForRefire = 0x501; // bool
    public const nint m_bTriggerOnce = 0x502; // bool
    public const nint m_bFastRetrigger = 0x503; // bool
    public const nint m_bPassthoughCaller = 0x504; // bool
}

public static class CMapInfo {
    public const nint m_iBuyingStatus = 0x4B0; // int32_t
    public const nint m_flBombRadius = 0x4B4; // float
    public const nint m_iPetPopulation = 0x4B8; // int32_t
    public const nint m_bUseNormalSpawnsForDM = 0x4BC; // bool
    public const nint m_bDisableAutoGeneratedDMSpawns = 0x4BD; // bool
    public const nint m_flBotMaxVisionDistance = 0x4C0; // float
    public const nint m_iHostageCount = 0x4C4; // int32_t
    public const nint m_bFadePlayerVisibilityFarZ = 0x4C8; // bool
}

public static class CMapVetoPickController {
    public const nint m_bPlayedIntroVcd = 0x4B0; // bool
    public const nint m_bNeedToPlayFiveSecondsRemaining = 0x4B1; // bool
    public const nint m_dblPreMatchDraftSequenceTime = 0x4D0; // double
    public const nint m_bPreMatchDraftStateChanged = 0x4D8; // bool
    public const nint m_nDraftType = 0x4DC; // int32_t
    public const nint m_nTeamWinningCoinToss = 0x4E0; // int32_t
    public const nint m_nTeamWithFirstChoice = 0x4E4; // int32_t[64]
    public const nint m_nVoteMapIdsList = 0x5E4; // int32_t[7]
    public const nint m_nAccountIDs = 0x600; // int32_t[64]
    public const nint m_nMapId0 = 0x700; // int32_t[64]
    public const nint m_nMapId1 = 0x800; // int32_t[64]
    public const nint m_nMapId2 = 0x900; // int32_t[64]
    public const nint m_nMapId3 = 0xA00; // int32_t[64]
    public const nint m_nMapId4 = 0xB00; // int32_t[64]
    public const nint m_nMapId5 = 0xC00; // int32_t[64]
    public const nint m_nStartingSide0 = 0xD00; // int32_t[64]
    public const nint m_nCurrentPhase = 0xE00; // int32_t
    public const nint m_nPhaseStartTick = 0xE04; // int32_t
    public const nint m_nPhaseDurationTicks = 0xE08; // int32_t
    public const nint m_OnMapVetoed = 0xE10; // CEntityOutputTemplate<CUtlSymbolLarge>
    public const nint m_OnMapPicked = 0xE38; // CEntityOutputTemplate<CUtlSymbolLarge>
    public const nint m_OnSidesPicked = 0xE60; // CEntityOutputTemplate<int32_t>
    public const nint m_OnNewPhaseStarted = 0xE88; // CEntityOutputTemplate<int32_t>
    public const nint m_OnLevelTransition = 0xEB0; // CEntityOutputTemplate<int32_t>
}

public static class CMarkupVolume {
    public const nint m_bEnabled = 0x700; // bool
}

public static class CMarkupVolumeTagged {
    public const nint m_bIsGroup = 0x738; // bool
    public const nint m_bGroupByPrefab = 0x739; // bool
    public const nint m_bGroupByVolume = 0x73A; // bool
    public const nint m_bGroupOtherGroups = 0x73B; // bool
    public const nint m_bIsInGroup = 0x73C; // bool
}

public static class CMarkupVolumeTagged_NavGame {
    public const nint m_bFloodFillAttribute = 0x758; // bool
}

public static class CMarkupVolumeWithRef {
    public const nint m_bUseRef = 0x740; // bool
    public const nint m_vRefPos = 0x744; // Vector
    public const nint m_flRefDot = 0x750; // float
}

public static class CMathColorBlend {
    public const nint m_flInMin = 0x4B0; // float
    public const nint m_flInMax = 0x4B4; // float
    public const nint m_OutColor1 = 0x4B8; // Color
    public const nint m_OutColor2 = 0x4BC; // Color
    public const nint m_OutValue = 0x4C0; // CEntityOutputTemplate<Color>
}

public static class CMathCounter {
    public const nint m_flMin = 0x4B0; // float
    public const nint m_flMax = 0x4B4; // float
    public const nint m_bHitMin = 0x4B8; // bool
    public const nint m_bHitMax = 0x4B9; // bool
    public const nint m_bDisabled = 0x4BA; // bool
    public const nint m_OutValue = 0x4C0; // CEntityOutputTemplate<float>
    public const nint m_OnGetValue = 0x4E8; // CEntityOutputTemplate<float>
    public const nint m_OnHitMin = 0x510; // CEntityIOOutput
    public const nint m_OnHitMax = 0x538; // CEntityIOOutput
    public const nint m_OnChangedFromMin = 0x560; // CEntityIOOutput
    public const nint m_OnChangedFromMax = 0x588; // CEntityIOOutput
}

public static class CMathRemap {
    public const nint m_flInMin = 0x4B0; // float
    public const nint m_flInMax = 0x4B4; // float
    public const nint m_flOut1 = 0x4B8; // float
    public const nint m_flOut2 = 0x4BC; // float
    public const nint m_flOldInValue = 0x4C0; // float
    public const nint m_bEnabled = 0x4C4; // bool
    public const nint m_OutValue = 0x4C8; // CEntityOutputTemplate<float>
    public const nint m_OnRoseAboveMin = 0x4F0; // CEntityIOOutput
    public const nint m_OnRoseAboveMax = 0x518; // CEntityIOOutput
    public const nint m_OnFellBelowMin = 0x540; // CEntityIOOutput
    public const nint m_OnFellBelowMax = 0x568; // CEntityIOOutput
}

public static class CMelee {
    public const nint m_flThrowAt = 0xE20; // GameTime_t
    public const nint m_hThrower = 0xE24; // CHandle<CBaseEntity>
    public const nint m_bDidThrowDamage = 0xE28; // bool
}

public static class CMessage {
    public const nint m_iszMessage = 0x4B0; // CUtlSymbolLarge
    public const nint m_MessageVolume = 0x4B8; // float
    public const nint m_MessageAttenuation = 0x4BC; // int32_t
    public const nint m_Radius = 0x4C0; // float
    public const nint m_sNoise = 0x4C8; // CUtlSymbolLarge
    public const nint m_OnShowMessage = 0x4D0; // CEntityIOOutput
}

public static class CMessageEntity {
    public const nint m_radius = 0x4B0; // int32_t
    public const nint m_messageText = 0x4B8; // CUtlSymbolLarge
    public const nint m_drawText = 0x4C0; // bool
    public const nint m_bDeveloperOnly = 0x4C1; // bool
    public const nint m_bEnabled = 0x4C2; // bool
}

public static class CModelState {
    public const nint m_hModel = 0xA0; // CStrongHandle<InfoForResourceTypeCModel>
    public const nint m_ModelName = 0xA8; // CUtlSymbolLarge
    public const nint m_bClientClothCreationSuppressed = 0xE8; // bool
    public const nint m_MeshGroupMask = 0x180; // uint64_t
    public const nint m_nIdealMotionType = 0x222; // int8_t
    public const nint m_nForceLOD = 0x223; // int8_t
    public const nint m_nClothUpdateFlags = 0x224; // int8_t
}

public static class CMolotovProjectile {
    public const nint m_bIsIncGrenade = 0xA40; // bool
    public const nint m_bDetonated = 0xA4C; // bool
    public const nint m_stillTimer = 0xA50; // IntervalTimer
    public const nint m_bHasBouncedOffPlayer = 0xB30; // bool
}

public static class CMomentaryRotButton {
    public const nint m_Position = 0x8C8; // CEntityOutputTemplate<float>
    public const nint m_OnUnpressed = 0x8F0; // CEntityIOOutput
    public const nint m_OnFullyOpen = 0x918; // CEntityIOOutput
    public const nint m_OnFullyClosed = 0x940; // CEntityIOOutput
    public const nint m_OnReachedPosition = 0x968; // CEntityIOOutput
    public const nint m_lastUsed = 0x990; // int32_t
    public const nint m_start = 0x994; // QAngle
    public const nint m_end = 0x9A0; // QAngle
    public const nint m_IdealYaw = 0x9AC; // float
    public const nint m_sNoise = 0x9B0; // CUtlSymbolLarge
    public const nint m_bUpdateTarget = 0x9B8; // bool
    public const nint m_direction = 0x9BC; // int32_t
    public const nint m_returnSpeed = 0x9C0; // float
    public const nint m_flStartPosition = 0x9C4; // float
}

public static class CMotorController {
    public const nint m_speed = 0x8; // float
    public const nint m_maxTorque = 0xC; // float
    public const nint m_axis = 0x10; // Vector
    public const nint m_inertiaFactor = 0x1C; // float
}

public static class CMultiLightProxy {
    public const nint m_iszLightNameFilter = 0x4B0; // CUtlSymbolLarge
    public const nint m_iszLightClassFilter = 0x4B8; // CUtlSymbolLarge
    public const nint m_flLightRadiusFilter = 0x4C0; // float
    public const nint m_flBrightnessDelta = 0x4C4; // float
    public const nint m_bPerformScreenFade = 0x4C8; // bool
    public const nint m_flTargetBrightnessMultiplier = 0x4CC; // float
    public const nint m_flCurrentBrightnessMultiplier = 0x4D0; // float
    public const nint m_vecLights = 0x4D8; // CUtlVector<CHandle<CLightEntity>>
}

public static class CMultiSource {
    public const nint m_rgEntities = 0x4B0; // CHandle<CBaseEntity>[32]
    public const nint m_rgTriggered = 0x530; // int32_t[32]
    public const nint m_OnTrigger = 0x5B0; // CEntityIOOutput
    public const nint m_iTotal = 0x5D8; // int32_t
    public const nint m_globalstate = 0x5E0; // CUtlSymbolLarge
}

public static class CMultiplayer_Expresser {
    public const nint m_bAllowMultipleScenes = 0x70; // bool
}

public static class CNavHullPresetVData {
    public const nint m_vecNavHulls = 0x0; // CUtlVector<CUtlString>
}

public static class CNavHullVData {
    public const nint m_bAgentEnabled = 0x0; // bool
    public const nint m_agentRadius = 0x4; // float
    public const nint m_agentHeight = 0x8; // float
    public const nint m_agentShortHeightEnabled = 0xC; // bool
    public const nint m_agentShortHeight = 0x10; // float
    public const nint m_agentMaxClimb = 0x14; // float
    public const nint m_agentMaxSlope = 0x18; // int32_t
    public const nint m_agentMaxJumpDownDist = 0x1C; // float
    public const nint m_agentMaxJumpHorizDistBase = 0x20; // float
    public const nint m_agentMaxJumpUpDist = 0x24; // float
    public const nint m_agentBorderErosion = 0x28; // int32_t
}

public static class CNavLinkAnimgraphVar {
    public const nint m_strAnimgraphVar = 0x0; // CUtlString
    public const nint m_unAlignmentDegrees = 0x8; // uint32_t
}

public static class CNavLinkAreaEntity {
    public const nint m_flWidth = 0x4B0; // float
    public const nint m_vLocatorOffset = 0x4B4; // Vector
    public const nint m_qLocatorAnglesOffset = 0x4C0; // QAngle
    public const nint m_strMovementForward = 0x4D0; // CUtlSymbolLarge
    public const nint m_strMovementReverse = 0x4D8; // CUtlSymbolLarge
    public const nint m_nNavLinkIdForward = 0x4E0; // int32_t
    public const nint m_nNavLinkIdReverse = 0x4E4; // int32_t
    public const nint m_bEnabled = 0x4E8; // bool
    public const nint m_strFilterName = 0x4F0; // CUtlSymbolLarge
    public const nint m_hFilter = 0x4F8; // CHandle<CBaseFilter>
    public const nint m_OnNavLinkStart = 0x500; // CEntityIOOutput
    public const nint m_OnNavLinkFinish = 0x528; // CEntityIOOutput
    public const nint m_bIsTerminus = 0x550; // bool
}

public static class CNavLinkMovementVData {
    public const nint m_bIsInterpolated = 0x0; // bool
    public const nint m_unRecommendedDistance = 0x4; // uint32_t
    public const nint m_vecAnimgraphVars = 0x8; // CUtlVector<CNavLinkAnimgraphVar>
}

public static class CNavSpaceInfo {
    public const nint m_bCreateFlightSpace = 0x4B0; // bool
}

public static class CNavVolumeBreadthFirstSearch {
    public const nint m_vStartPos = 0xA0; // Vector
    public const nint m_flSearchDist = 0xAC; // float
}

public static class CNavVolumeSphere {
    public const nint m_vCenter = 0x70; // Vector
    public const nint m_flRadius = 0x7C; // float
}

public static class CNavVolumeSphericalShell {
    public const nint m_flRadiusInner = 0x80; // float
}

public static class CNavVolumeVector {
    public const nint m_bHasBeenPreFiltered = 0x78; // bool
}

public static class CNetworkOriginCellCoordQuantizedVector {
    public const nint m_cellX = 0x10; // uint16_t
    public const nint m_cellY = 0x12; // uint16_t
    public const nint m_cellZ = 0x14; // uint16_t
    public const nint m_nOutsideWorld = 0x16; // uint16_t
    public const nint m_vecX = 0x18; // CNetworkedQuantizedFloat
    public const nint m_vecY = 0x20; // CNetworkedQuantizedFloat
    public const nint m_vecZ = 0x28; // CNetworkedQuantizedFloat
}

public static class CNetworkOriginQuantizedVector {
    public const nint m_vecX = 0x10; // CNetworkedQuantizedFloat
    public const nint m_vecY = 0x18; // CNetworkedQuantizedFloat
    public const nint m_vecZ = 0x20; // CNetworkedQuantizedFloat
}

public static class CNetworkTransmitComponent {
    public const nint m_nTransmitStateOwnedCounter = 0x16C; // uint8_t
}

public static class CNetworkVelocityVector {
    public const nint m_vecX = 0x10; // CNetworkedQuantizedFloat
    public const nint m_vecY = 0x18; // CNetworkedQuantizedFloat
    public const nint m_vecZ = 0x20; // CNetworkedQuantizedFloat
}

public static class CNetworkViewOffsetVector {
    public const nint m_vecX = 0x10; // CNetworkedQuantizedFloat
    public const nint m_vecY = 0x18; // CNetworkedQuantizedFloat
    public const nint m_vecZ = 0x20; // CNetworkedQuantizedFloat
}

public static class CNetworkedSequenceOperation {
    public const nint m_hSequence = 0x8; // HSequence
    public const nint m_flPrevCycle = 0xC; // float
    public const nint m_flCycle = 0x10; // float
    public const nint m_flWeight = 0x14; // CNetworkedQuantizedFloat
    public const nint m_bSequenceChangeNetworked = 0x1C; // bool
    public const nint m_bDiscontinuity = 0x1D; // bool
    public const nint m_flPrevCycleFromDiscontinuity = 0x20; // float
    public const nint m_flPrevCycleForAnimEventDetection = 0x24; // float
}

public static class COmniLight {
    public const nint m_flInnerAngle = 0x928; // float
    public const nint m_flOuterAngle = 0x92C; // float
    public const nint m_bShowLight = 0x930; // bool
}

public static class COrnamentProp {
    public const nint m_initialOwner = 0xB08; // CUtlSymbolLarge
}

public static class CParticleSystem {
    public const nint m_szSnapshotFileName = 0x700; // char[512]
    public const nint m_bActive = 0x900; // bool
    public const nint m_bFrozen = 0x901; // bool
    public const nint m_flFreezeTransitionDuration = 0x904; // float
    public const nint m_nStopType = 0x908; // int32_t
    public const nint m_bAnimateDuringGameplayPause = 0x90C; // bool
    public const nint m_iEffectIndex = 0x910; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    public const nint m_flStartTime = 0x918; // GameTime_t
    public const nint m_flPreSimTime = 0x91C; // float
    public const nint m_vServerControlPoints = 0x920; // Vector[4]
    public const nint m_iServerControlPointAssignments = 0x950; // uint8_t[4]
    public const nint m_hControlPointEnts = 0x954; // CHandle<CBaseEntity>[64]
    public const nint m_bNoSave = 0xA54; // bool
    public const nint m_bNoFreeze = 0xA55; // bool
    public const nint m_bNoRamp = 0xA56; // bool
    public const nint m_bStartActive = 0xA57; // bool
    public const nint m_iszEffectName = 0xA58; // CUtlSymbolLarge
    public const nint m_iszControlPointNames = 0xA60; // CUtlSymbolLarge[64]
    public const nint m_nDataCP = 0xC60; // int32_t
    public const nint m_vecDataCPValue = 0xC64; // Vector
    public const nint m_nTintCP = 0xC70; // int32_t
    public const nint m_clrTint = 0xC74; // Color
}

public static class CPathCorner {
    public const nint m_flWait = 0x4B0; // float
    public const nint m_flRadius = 0x4B4; // float
    public const nint m_OnPass = 0x4B8; // CEntityIOOutput
}

public static class CPathKeyFrame {
    public const nint m_Origin = 0x4B0; // Vector
    public const nint m_Angles = 0x4BC; // QAngle
    public const nint m_qAngle = 0x4D0; // Quaternion
    public const nint m_iNextKey = 0x4E0; // CUtlSymbolLarge
    public const nint m_flNextTime = 0x4E8; // float
    public const nint m_pNextKey = 0x4F0; // CPathKeyFrame*
    public const nint m_pPrevKey = 0x4F8; // CPathKeyFrame*
    public const nint m_flSpeed = 0x500; // float
}

public static class CPathParticleRope {
    public const nint m_bStartActive = 0x4B0; // bool
    public const nint m_flMaxSimulationTime = 0x4B4; // float
    public const nint m_iszEffectName = 0x4B8; // CUtlSymbolLarge
    public const nint m_PathNodes_Name = 0x4C0; // CUtlVector<CUtlSymbolLarge>
    public const nint m_flParticleSpacing = 0x4D8; // float
    public const nint m_flSlack = 0x4DC; // float
    public const nint m_flRadius = 0x4E0; // float
    public const nint m_ColorTint = 0x4E4; // Color
    public const nint m_nEffectState = 0x4E8; // int32_t
    public const nint m_iEffectIndex = 0x4F0; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    public const nint m_PathNodes_Position = 0x4F8; // CNetworkUtlVectorBase<Vector>
    public const nint m_PathNodes_TangentIn = 0x510; // CNetworkUtlVectorBase<Vector>
    public const nint m_PathNodes_TangentOut = 0x528; // CNetworkUtlVectorBase<Vector>
    public const nint m_PathNodes_Color = 0x540; // CNetworkUtlVectorBase<Vector>
    public const nint m_PathNodes_PinEnabled = 0x558; // CNetworkUtlVectorBase<bool>
    public const nint m_PathNodes_RadiusScale = 0x570; // CNetworkUtlVectorBase<float>
}

public static class CPathTrack {
    public const nint m_pnext = 0x4B0; // CPathTrack*
    public const nint m_pprevious = 0x4B8; // CPathTrack*
    public const nint m_paltpath = 0x4C0; // CPathTrack*
    public const nint m_flRadius = 0x4C8; // float
    public const nint m_length = 0x4CC; // float
    public const nint m_altName = 0x4D0; // CUtlSymbolLarge
    public const nint m_nIterVal = 0x4D8; // int32_t
    public const nint m_eOrientationType = 0x4DC; // TrackOrientationType_t
    public const nint m_OnPass = 0x4E0; // CEntityIOOutput
}

public static class CPhysBallSocket {
    public const nint m_flFriction = 0x508; // float
    public const nint m_bEnableSwingLimit = 0x50C; // bool
    public const nint m_flSwingLimit = 0x510; // float
    public const nint m_bEnableTwistLimit = 0x514; // bool
    public const nint m_flMinTwistAngle = 0x518; // float
    public const nint m_flMaxTwistAngle = 0x51C; // float
}

public static class CPhysBox {
    public const nint m_damageType = 0x7C0; // int32_t
    public const nint m_massScale = 0x7C4; // float
    public const nint m_damageToEnableMotion = 0x7C8; // int32_t
    public const nint m_flForceToEnableMotion = 0x7CC; // float
    public const nint m_angPreferredCarryAngles = 0x7D0; // QAngle
    public const nint m_bNotSolidToWorld = 0x7DC; // bool
    public const nint m_bEnableUseOutput = 0x7DD; // bool
    public const nint m_iExploitableByPlayer = 0x7E0; // int32_t
    public const nint m_flTouchOutputPerEntityDelay = 0x7E4; // float
    public const nint m_OnDamaged = 0x7E8; // CEntityIOOutput
    public const nint m_OnAwakened = 0x810; // CEntityIOOutput
    public const nint m_OnMotionEnabled = 0x838; // CEntityIOOutput
    public const nint m_OnPlayerUse = 0x860; // CEntityIOOutput
    public const nint m_OnStartTouch = 0x888; // CEntityIOOutput
    public const nint m_hCarryingPlayer = 0x8B0; // CHandle<CBasePlayerPawn>
}

public static class CPhysConstraint {
    public const nint m_nameAttach1 = 0x4B8; // CUtlSymbolLarge
    public const nint m_nameAttach2 = 0x4C0; // CUtlSymbolLarge
    public const nint m_breakSound = 0x4C8; // CUtlSymbolLarge
    public const nint m_forceLimit = 0x4D0; // float
    public const nint m_torqueLimit = 0x4D4; // float
    public const nint m_teleportTick = 0x4D8; // uint32_t
    public const nint m_minTeleportDistance = 0x4DC; // float
    public const nint m_OnBreak = 0x4E0; // CEntityIOOutput
}

public static class CPhysExplosion {
    public const nint m_bExplodeOnSpawn = 0x4B0; // bool
    public const nint m_flMagnitude = 0x4B4; // float
    public const nint m_flDamage = 0x4B8; // float
    public const nint m_radius = 0x4BC; // float
    public const nint m_targetEntityName = 0x4C0; // CUtlSymbolLarge
    public const nint m_flInnerRadius = 0x4C8; // float
    public const nint m_flPushScale = 0x4CC; // float
    public const nint m_bConvertToDebrisWhenPossible = 0x4D0; // bool
    public const nint m_OnPushedPlayer = 0x4D8; // CEntityIOOutput
}

public static class CPhysFixed {
    public const nint m_flLinearFrequency = 0x508; // float
    public const nint m_flLinearDampingRatio = 0x50C; // float
    public const nint m_flAngularFrequency = 0x510; // float
    public const nint m_flAngularDampingRatio = 0x514; // float
    public const nint m_bEnableLinearConstraint = 0x518; // bool
    public const nint m_bEnableAngularConstraint = 0x519; // bool
}

public static class CPhysForce {
    public const nint m_nameAttach = 0x4B8; // CUtlSymbolLarge
    public const nint m_force = 0x4C0; // float
    public const nint m_forceTime = 0x4C4; // float
    public const nint m_attachedObject = 0x4C8; // CHandle<CBaseEntity>
    public const nint m_wasRestored = 0x4CC; // bool
    public const nint m_integrator = 0x4D0; // CConstantForceController
}

public static class CPhysHinge {
    public const nint m_soundInfo = 0x510; // ConstraintSoundInfo
    public const nint m_NotifyMinLimitReached = 0x598; // CEntityIOOutput
    public const nint m_NotifyMaxLimitReached = 0x5C0; // CEntityIOOutput
    public const nint m_bAtMinLimit = 0x5E8; // bool
    public const nint m_bAtMaxLimit = 0x5E9; // bool
    public const nint m_hinge = 0x5EC; // constraint_hingeparams_t
    public const nint m_hingeFriction = 0x62C; // float
    public const nint m_systemLoadScale = 0x630; // float
    public const nint m_bIsAxisLocal = 0x634; // bool
    public const nint m_flMinRotation = 0x638; // float
    public const nint m_flMaxRotation = 0x63C; // float
    public const nint m_flInitialRotation = 0x640; // float
    public const nint m_flMotorFrequency = 0x644; // float
    public const nint m_flMotorDampingRatio = 0x648; // float
    public const nint m_flAngleSpeed = 0x64C; // float
    public const nint m_flAngleSpeedThreshold = 0x650; // float
    public const nint m_OnStartMoving = 0x658; // CEntityIOOutput
    public const nint m_OnStopMoving = 0x680; // CEntityIOOutput
}

public static class CPhysImpact {
    public const nint m_damage = 0x4B0; // float
    public const nint m_distance = 0x4B4; // float
    public const nint m_directionEntityName = 0x4B8; // CUtlSymbolLarge
}

public static class CPhysLength {
    public const nint m_offset = 0x508; // Vector[2]
    public const nint m_vecAttach = 0x520; // Vector
    public const nint m_addLength = 0x52C; // float
    public const nint m_minLength = 0x530; // float
    public const nint m_totalLength = 0x534; // float
    public const nint m_bEnableCollision = 0x538; // bool
}

public static class CPhysMagnet {
    public const nint m_OnMagnetAttach = 0x890; // CEntityIOOutput
    public const nint m_OnMagnetDetach = 0x8B8; // CEntityIOOutput
    public const nint m_massScale = 0x8E0; // float
    public const nint m_forceLimit = 0x8E4; // float
    public const nint m_torqueLimit = 0x8E8; // float
    public const nint m_MagnettedEntities = 0x8F0; // CUtlVector<magnetted_objects_t>
    public const nint m_bActive = 0x908; // bool
    public const nint m_bHasHitSomething = 0x909; // bool
    public const nint m_flTotalMass = 0x90C; // float
    public const nint m_flRadius = 0x910; // float
    public const nint m_flNextSuckTime = 0x914; // GameTime_t
    public const nint m_iMaxObjectsAttached = 0x918; // int32_t
}

public static class CPhysMotor {
    public const nint m_nameAttach = 0x4B0; // CUtlSymbolLarge
    public const nint m_hAttachedObject = 0x4B8; // CHandle<CBaseEntity>
    public const nint m_spinUp = 0x4BC; // float
    public const nint m_additionalAcceleration = 0x4C0; // float
    public const nint m_angularAcceleration = 0x4C4; // float
    public const nint m_lastTime = 0x4C8; // GameTime_t
    public const nint m_motor = 0x4E0; // CMotorController
}

public static class CPhysPulley {
    public const nint m_position2 = 0x508; // Vector
    public const nint m_offset = 0x514; // Vector[2]
    public const nint m_addLength = 0x52C; // float
    public const nint m_gearRatio = 0x530; // float
}

public static class CPhysSlideConstraint {
    public const nint m_axisEnd = 0x510; // Vector
    public const nint m_slideFriction = 0x51C; // float
    public const nint m_systemLoadScale = 0x520; // float
    public const nint m_initialOffset = 0x524; // float
    public const nint m_bEnableLinearConstraint = 0x528; // bool
    public const nint m_bEnableAngularConstraint = 0x529; // bool
    public const nint m_flMotorFrequency = 0x52C; // float
    public const nint m_flMotorDampingRatio = 0x530; // float
    public const nint m_bUseEntityPivot = 0x534; // bool
    public const nint m_soundInfo = 0x538; // ConstraintSoundInfo
}

public static class CPhysThruster {
    public const nint m_localOrigin = 0x510; // Vector
}

public static class CPhysTorque {
    public const nint m_axis = 0x510; // Vector
}

public static class CPhysWheelConstraint {
    public const nint m_flSuspensionFrequency = 0x508; // float
    public const nint m_flSuspensionDampingRatio = 0x50C; // float
    public const nint m_flSuspensionHeightOffset = 0x510; // float
    public const nint m_bEnableSuspensionLimit = 0x514; // bool
    public const nint m_flMinSuspensionOffset = 0x518; // float
    public const nint m_flMaxSuspensionOffset = 0x51C; // float
    public const nint m_bEnableSteeringLimit = 0x520; // bool
    public const nint m_flMinSteeringAngle = 0x524; // float
    public const nint m_flMaxSteeringAngle = 0x528; // float
    public const nint m_flSteeringAxisFriction = 0x52C; // float
    public const nint m_flSpinAxisFriction = 0x530; // float
}

public static class CPhysicsEntitySolver {
    public const nint m_hMovingEntity = 0x4B8; // CHandle<CBaseEntity>
    public const nint m_hPhysicsBlocker = 0x4BC; // CHandle<CBaseEntity>
    public const nint m_separationDuration = 0x4C0; // float
    public const nint m_cancelTime = 0x4C4; // GameTime_t
}

public static class CPhysicsProp {
    public const nint m_MotionEnabled = 0xA10; // CEntityIOOutput
    public const nint m_OnAwakened = 0xA38; // CEntityIOOutput
    public const nint m_OnAwake = 0xA60; // CEntityIOOutput
    public const nint m_OnAsleep = 0xA88; // CEntityIOOutput
    public const nint m_OnPlayerUse = 0xAB0; // CEntityIOOutput
    public const nint m_OnPlayerPickup = 0xAD8; // CEntityIOOutput
    public const nint m_OnOutOfWorld = 0xB00; // CEntityIOOutput
    public const nint m_massScale = 0xB28; // float
    public const nint m_inertiaScale = 0xB2C; // float
    public const nint m_buoyancyScale = 0xB30; // float
    public const nint m_damageType = 0xB34; // int32_t
    public const nint m_damageToEnableMotion = 0xB38; // int32_t
    public const nint m_flForceToEnableMotion = 0xB3C; // float
    public const nint m_bThrownByPlayer = 0xB40; // bool
    public const nint m_bDroppedByPlayer = 0xB41; // bool
    public const nint m_bTouchedByPlayer = 0xB42; // bool
    public const nint m_bFirstCollisionAfterLaunch = 0xB43; // bool
    public const nint m_iExploitableByPlayer = 0xB44; // int32_t
    public const nint m_bHasBeenAwakened = 0xB48; // bool
    public const nint m_bIsOverrideProp = 0xB49; // bool
    public const nint m_fNextCheckDisableMotionContactsTime = 0xB4C; // GameTime_t
    public const nint m_iInitialGlowState = 0xB50; // int32_t
    public const nint m_nGlowRange = 0xB54; // int32_t
    public const nint m_nGlowRangeMin = 0xB58; // int32_t
    public const nint m_glowColor = 0xB5C; // Color
    public const nint m_bForceNavIgnore = 0xB60; // bool
    public const nint m_bNoNavmeshBlocker = 0xB61; // bool
    public const nint m_bForceNpcExclude = 0xB62; // bool
    public const nint m_bShouldAutoConvertBackFromDebris = 0xB63; // bool
    public const nint m_bMuteImpactEffects = 0xB64; // bool
    public const nint m_bAcceptDamageFromHeldObjects = 0xB6C; // bool
    public const nint m_bEnableUseOutput = 0xB6D; // bool
    public const nint m_bAwake = 0xB6E; // bool
    public const nint m_nCollisionGroupOverride = 0xB70; // int32_t
}

public static class CPhysicsPropRespawnable {
    public const nint m_vOriginalSpawnOrigin = 0xB78; // Vector
    public const nint m_vOriginalSpawnAngles = 0xB84; // QAngle
    public const nint m_vOriginalMins = 0xB90; // Vector
    public const nint m_vOriginalMaxs = 0xB9C; // Vector
    public const nint m_flRespawnDuration = 0xBA8; // float
}

public static class CPhysicsShake {
    public const nint m_force = 0x8; // Vector
}

public static class CPhysicsSpring {
    public const nint m_flFrequency = 0x4B8; // float
    public const nint m_flDampingRatio = 0x4BC; // float
    public const nint m_flRestLength = 0x4C0; // float
    public const nint m_nameAttachStart = 0x4C8; // CUtlSymbolLarge
    public const nint m_nameAttachEnd = 0x4D0; // CUtlSymbolLarge
    public const nint m_start = 0x4D8; // Vector
    public const nint m_end = 0x4E4; // Vector
    public const nint m_teleportTick = 0x4F0; // uint32_t
}

public static class CPhysicsWire {
    public const nint m_nDensity = 0x4B0; // int32_t
}

public static class CPlantedC4 {
    public const nint m_bBombTicking = 0x890; // bool
    public const nint m_flC4Blow = 0x894; // GameTime_t
    public const nint m_nBombSite = 0x898; // int32_t
    public const nint m_nSourceSoundscapeHash = 0x89C; // int32_t
    public const nint m_OnBombDefused = 0x8A0; // CEntityIOOutput
    public const nint m_OnBombBeginDefuse = 0x8C8; // CEntityIOOutput
    public const nint m_OnBombDefuseAborted = 0x8F0; // CEntityIOOutput
    public const nint m_bCannotBeDefused = 0x918; // bool
    public const nint m_entitySpottedState = 0x920; // EntitySpottedState_t
    public const nint m_nSpotRules = 0x938; // int32_t
    public const nint m_bTrainingPlacedByPlayer = 0x93C; // bool
    public const nint m_bHasExploded = 0x93D; // bool
    public const nint m_flTimerLength = 0x940; // float
    public const nint m_bBeingDefused = 0x944; // bool
    public const nint m_fLastDefuseTime = 0x94C; // GameTime_t
    public const nint m_flDefuseLength = 0x954; // float
    public const nint m_flDefuseCountDown = 0x958; // GameTime_t
    public const nint m_bBombDefused = 0x95C; // bool
    public const nint m_hBombDefuser = 0x960; // CHandle<CCSPlayerPawn>
    public const nint m_hControlPanel = 0x964; // CHandle<CBaseEntity>
    public const nint m_iProgressBarTime = 0x968; // int32_t
    public const nint m_bVoiceAlertFired = 0x96C; // bool
    public const nint m_bVoiceAlertPlayed = 0x96D; // bool[4]
    public const nint m_flNextBotBeepTime = 0x974; // GameTime_t
    public const nint m_bPlantedAfterPickup = 0x97C; // bool
    public const nint m_angCatchUpToPlayerEye = 0x980; // QAngle
    public const nint m_flLastSpinDetectionTime = 0x98C; // GameTime_t
}

public static class CPlatTrigger {
    public const nint m_pPlatform = 0x700; // CHandle<CFuncPlat>
}

public static class CPlayerControllerComponent {
    public const nint __m_pChainEntity = 0x8; // CNetworkVarChainer
}

public static class CPlayerPawnComponent {
    public const nint __m_pChainEntity = 0x8; // CNetworkVarChainer
}

public static class CPlayerPing {
    public const nint m_hPlayer = 0x4B8; // CHandle<CCSPlayerPawn>
    public const nint m_hPingedEntity = 0x4BC; // CHandle<CBaseEntity>
    public const nint m_iType = 0x4C0; // int32_t
    public const nint m_bUrgent = 0x4C4; // bool
    public const nint m_szPlaceName = 0x4C5; // char[18]
}

public static class CPlayerSprayDecal {
    public const nint m_nUniqueID = 0x700; // int32_t
    public const nint m_unAccountID = 0x704; // uint32_t
    public const nint m_unTraceID = 0x708; // uint32_t
    public const nint m_rtGcTime = 0x70C; // uint32_t
    public const nint m_vecEndPos = 0x710; // Vector
    public const nint m_vecStart = 0x71C; // Vector
    public const nint m_vecLeft = 0x728; // Vector
    public const nint m_vecNormal = 0x734; // Vector
    public const nint m_nPlayer = 0x740; // int32_t
    public const nint m_nEntity = 0x744; // int32_t
    public const nint m_nHitbox = 0x748; // int32_t
    public const nint m_flCreationTime = 0x74C; // float
    public const nint m_nTintID = 0x750; // int32_t
    public const nint m_nVersion = 0x754; // uint8_t
    public const nint m_ubSignature = 0x755; // uint8_t[128]
}

public static class CPlayerVisibility {
    public const nint m_flVisibilityStrength = 0x4B0; // float
    public const nint m_flFogDistanceMultiplier = 0x4B4; // float
    public const nint m_flFogMaxDensityMultiplier = 0x4B8; // float
    public const nint m_flFadeTime = 0x4BC; // float
    public const nint m_bStartDisabled = 0x4C0; // bool
    public const nint m_bIsEnabled = 0x4C1; // bool
}

public static class CPlayer_CameraServices {
    public const nint m_vecCsViewPunchAngle = 0x40; // QAngle
    public const nint m_nCsViewPunchAngleTick = 0x4C; // GameTick_t
    public const nint m_flCsViewPunchAngleTickRatio = 0x50; // float
    public const nint m_PlayerFog = 0x58; // fogplayerparams_t
    public const nint m_hColorCorrectionCtrl = 0x98; // CHandle<CColorCorrection>
    public const nint m_hViewEntity = 0x9C; // CHandle<CBaseEntity>
    public const nint m_hTonemapController = 0xA0; // CHandle<CTonemapController2>
    public const nint m_audio = 0xA8; // audioparams_t
    public const nint m_PostProcessingVolumes = 0x120; // CNetworkUtlVectorBase<CHandle<CPostProcessingVolume>>
    public const nint m_flOldPlayerZ = 0x138; // float
    public const nint m_flOldPlayerViewOffsetZ = 0x13C; // float
    public const nint m_hTriggerSoundscapeList = 0x158; // CUtlVector<CHandle<CEnvSoundscapeTriggerable>>
}

public static class CPlayer_MovementServices {
    public const nint m_nImpulse = 0x40; // int32_t
    public const nint m_nButtons = 0x48; // CInButtonState
    public const nint m_nQueuedButtonDownMask = 0x68; // uint64_t
    public const nint m_nQueuedButtonChangeMask = 0x70; // uint64_t
    public const nint m_nButtonDoublePressed = 0x78; // uint64_t
    public const nint m_pButtonPressedCmdNumber = 0x80; // uint32_t[64]
    public const nint m_nLastCommandNumberProcessed = 0x180; // uint32_t
    public const nint m_nToggleButtonDownMask = 0x188; // uint64_t
    public const nint m_flMaxspeed = 0x190; // float
    public const nint m_arrForceSubtickMoveWhen = 0x194; // float[4]
    public const nint m_flForwardMove = 0x1A4; // float
    public const nint m_flLeftMove = 0x1A8; // float
    public const nint m_flUpMove = 0x1AC; // float
    public const nint m_vecLastMovementImpulses = 0x1B0; // Vector
    public const nint m_vecOldViewAngles = 0x1BC; // QAngle
}

public static class CPlayer_MovementServices_Humanoid {
    public const nint m_flStepSoundTime = 0x1D0; // float
    public const nint m_flFallVelocity = 0x1D4; // float
    public const nint m_bInCrouch = 0x1D8; // bool
    public const nint m_nCrouchState = 0x1DC; // uint32_t
    public const nint m_flCrouchTransitionStartTime = 0x1E0; // GameTime_t
    public const nint m_bDucked = 0x1E4; // bool
    public const nint m_bDucking = 0x1E5; // bool
    public const nint m_bInDuckJump = 0x1E6; // bool
    public const nint m_groundNormal = 0x1E8; // Vector
    public const nint m_flSurfaceFriction = 0x1F4; // float
    public const nint m_surfaceProps = 0x1F8; // CUtlStringToken
    public const nint m_nStepside = 0x208; // int32_t
    public const nint m_iTargetVolume = 0x20C; // int32_t
    public const nint m_vecSmoothedVelocity = 0x210; // Vector
}

public static class CPlayer_ObserverServices {
    public const nint m_iObserverMode = 0x40; // uint8_t
    public const nint m_hObserverTarget = 0x44; // CHandle<CBaseEntity>
    public const nint m_iObserverLastMode = 0x48; // ObserverMode_t
    public const nint m_bForcedObserverMode = 0x4C; // bool
}

public static class CPlayer_WeaponServices {
    public const nint m_bAllowSwitchToNoWeapon = 0x40; // bool
    public const nint m_hMyWeapons = 0x48; // CNetworkUtlVectorBase<CHandle<CBasePlayerWeapon>>
    public const nint m_hActiveWeapon = 0x60; // CHandle<CBasePlayerWeapon>
    public const nint m_hLastWeapon = 0x64; // CHandle<CBasePlayerWeapon>
    public const nint m_iAmmo = 0x68; // uint16_t[32]
    public const nint m_bPreventWeaponPickup = 0xA8; // bool
}

public static class CPointAngleSensor {
    public const nint m_bDisabled = 0x4B0; // bool
    public const nint m_nLookAtName = 0x4B8; // CUtlSymbolLarge
    public const nint m_hTargetEntity = 0x4C0; // CHandle<CBaseEntity>
    public const nint m_hLookAtEntity = 0x4C4; // CHandle<CBaseEntity>
    public const nint m_flDuration = 0x4C8; // float
    public const nint m_flDotTolerance = 0x4CC; // float
    public const nint m_flFacingTime = 0x4D0; // GameTime_t
    public const nint m_bFired = 0x4D4; // bool
    public const nint m_OnFacingLookat = 0x4D8; // CEntityIOOutput
    public const nint m_OnNotFacingLookat = 0x500; // CEntityIOOutput
    public const nint m_TargetDir = 0x528; // CEntityOutputTemplate<Vector>
    public const nint m_FacingPercentage = 0x550; // CEntityOutputTemplate<float>
}

public static class CPointAngularVelocitySensor {
    public const nint m_hTargetEntity = 0x4B0; // CHandle<CBaseEntity>
    public const nint m_flThreshold = 0x4B4; // float
    public const nint m_nLastCompareResult = 0x4B8; // int32_t
    public const nint m_nLastFireResult = 0x4BC; // int32_t
    public const nint m_flFireTime = 0x4C0; // GameTime_t
    public const nint m_flFireInterval = 0x4C4; // float
    public const nint m_flLastAngVelocity = 0x4C8; // float
    public const nint m_lastOrientation = 0x4CC; // QAngle
    public const nint m_vecAxis = 0x4D8; // Vector
    public const nint m_bUseHelper = 0x4E4; // bool
    public const nint m_AngularVelocity = 0x4E8; // CEntityOutputTemplate<float>
    public const nint m_OnLessThan = 0x510; // CEntityIOOutput
    public const nint m_OnLessThanOrEqualTo = 0x538; // CEntityIOOutput
    public const nint m_OnGreaterThan = 0x560; // CEntityIOOutput
    public const nint m_OnGreaterThanOrEqualTo = 0x588; // CEntityIOOutput
    public const nint m_OnEqualTo = 0x5B0; // CEntityIOOutput
}

public static class CPointCamera {
    public const nint m_FOV = 0x4B0; // float
    public const nint m_Resolution = 0x4B4; // float
    public const nint m_bFogEnable = 0x4B8; // bool
    public const nint m_FogColor = 0x4B9; // Color
    public const nint m_flFogStart = 0x4C0; // float
    public const nint m_flFogEnd = 0x4C4; // float
    public const nint m_flFogMaxDensity = 0x4C8; // float
    public const nint m_bActive = 0x4CC; // bool
    public const nint m_bUseScreenAspectRatio = 0x4CD; // bool
    public const nint m_flAspectRatio = 0x4D0; // float
    public const nint m_bNoSky = 0x4D4; // bool
    public const nint m_fBrightness = 0x4D8; // float
    public const nint m_flZFar = 0x4DC; // float
    public const nint m_flZNear = 0x4E0; // float
    public const nint m_bCanHLTVUse = 0x4E4; // bool
    public const nint m_bDofEnabled = 0x4E5; // bool
    public const nint m_flDofNearBlurry = 0x4E8; // float
    public const nint m_flDofNearCrisp = 0x4EC; // float
    public const nint m_flDofFarCrisp = 0x4F0; // float
    public const nint m_flDofFarBlurry = 0x4F4; // float
    public const nint m_flDofTiltToGround = 0x4F8; // float
    public const nint m_TargetFOV = 0x4FC; // float
    public const nint m_DegreesPerSecond = 0x500; // float
    public const nint m_bIsOn = 0x504; // bool
    public const nint m_pNext = 0x508; // CPointCamera*
}

public static class CPointCameraVFOV {
    public const nint m_flVerticalFOV = 0x510; // float
}

public static class CPointClientUIDialog {
    public const nint m_hActivator = 0x8B0; // CHandle<CBaseEntity>
    public const nint m_bStartEnabled = 0x8B4; // bool
}

public static class CPointClientUIWorldPanel {
    public const nint m_bIgnoreInput = 0x8B0; // bool
    public const nint m_bLit = 0x8B1; // bool
    public const nint m_bFollowPlayerAcrossTeleport = 0x8B2; // bool
    public const nint m_flWidth = 0x8B4; // float
    public const nint m_flHeight = 0x8B8; // float
    public const nint m_flDPI = 0x8BC; // float
    public const nint m_flInteractDistance = 0x8C0; // float
    public const nint m_flDepthOffset = 0x8C4; // float
    public const nint m_unOwnerContext = 0x8C8; // uint32_t
    public const nint m_unHorizontalAlign = 0x8CC; // uint32_t
    public const nint m_unVerticalAlign = 0x8D0; // uint32_t
    public const nint m_unOrientation = 0x8D4; // uint32_t
    public const nint m_bAllowInteractionFromAllSceneWorlds = 0x8D8; // bool
    public const nint m_vecCSSClasses = 0x8E0; // CNetworkUtlVectorBase<CUtlSymbolLarge>
    public const nint m_bOpaque = 0x8F8; // bool
    public const nint m_bNoDepth = 0x8F9; // bool
    public const nint m_bRenderBackface = 0x8FA; // bool
    public const nint m_bUseOffScreenIndicator = 0x8FB; // bool
    public const nint m_bExcludeFromSaveGames = 0x8FC; // bool
    public const nint m_bGrabbable = 0x8FD; // bool
    public const nint m_bOnlyRenderToTexture = 0x8FE; // bool
    public const nint m_bDisableMipGen = 0x8FF; // bool
    public const nint m_nExplicitImageLayout = 0x900; // int32_t
}

public static class CPointClientUIWorldTextPanel {
    public const nint m_messageText = 0x908; // char[512]
}

public static class CPointCommentaryNode {
    public const nint m_iszPreCommands = 0x890; // CUtlSymbolLarge
    public const nint m_iszPostCommands = 0x898; // CUtlSymbolLarge
    public const nint m_iszCommentaryFile = 0x8A0; // CUtlSymbolLarge
    public const nint m_iszViewTarget = 0x8A8; // CUtlSymbolLarge
    public const nint m_hViewTarget = 0x8B0; // CHandle<CBaseEntity>
    public const nint m_hViewTargetAngles = 0x8B4; // CHandle<CBaseEntity>
    public const nint m_iszViewPosition = 0x8B8; // CUtlSymbolLarge
    public const nint m_hViewPosition = 0x8C0; // CHandle<CBaseEntity>
    public const nint m_hViewPositionMover = 0x8C4; // CHandle<CBaseEntity>
    public const nint m_bPreventMovement = 0x8C8; // bool
    public const nint m_bUnderCrosshair = 0x8C9; // bool
    public const nint m_bUnstoppable = 0x8CA; // bool
    public const nint m_flFinishedTime = 0x8CC; // GameTime_t
    public const nint m_vecFinishOrigin = 0x8D0; // Vector
    public const nint m_vecOriginalAngles = 0x8DC; // QAngle
    public const nint m_vecFinishAngles = 0x8E8; // QAngle
    public const nint m_bPreventChangesWhileMoving = 0x8F4; // bool
    public const nint m_bDisabled = 0x8F5; // bool
    public const nint m_vecTeleportOrigin = 0x8F8; // Vector
    public const nint m_flAbortedPlaybackAt = 0x904; // GameTime_t
    public const nint m_pOnCommentaryStarted = 0x908; // CEntityIOOutput
    public const nint m_pOnCommentaryStopped = 0x930; // CEntityIOOutput
    public const nint m_bActive = 0x958; // bool
    public const nint m_flStartTime = 0x95C; // GameTime_t
    public const nint m_flStartTimeInCommentary = 0x960; // float
    public const nint m_iszTitle = 0x968; // CUtlSymbolLarge
    public const nint m_iszSpeakers = 0x970; // CUtlSymbolLarge
    public const nint m_iNodeNumber = 0x978; // int32_t
    public const nint m_iNodeNumberMax = 0x97C; // int32_t
    public const nint m_bListenedTo = 0x980; // bool
}

public static class CPointEntityFinder {
    public const nint m_hEntity = 0x4B0; // CHandle<CBaseEntity>
    public const nint m_iFilterName = 0x4B8; // CUtlSymbolLarge
    public const nint m_hFilter = 0x4C0; // CHandle<CBaseFilter>
    public const nint m_iRefName = 0x4C8; // CUtlSymbolLarge
    public const nint m_hReference = 0x4D0; // CHandle<CBaseEntity>
    public const nint m_FindMethod = 0x4D4; // EntFinderMethod_t
    public const nint m_OnFoundEntity = 0x4D8; // CEntityIOOutput
}

public static class CPointGamestatsCounter {
    public const nint m_strStatisticName = 0x4B0; // CUtlSymbolLarge
    public const nint m_bDisabled = 0x4B8; // bool
}

public static class CPointGiveAmmo {
    public const nint m_pActivator = 0x4B0; // CHandle<CBaseEntity>
}

public static class CPointHurt {
    public const nint m_nDamage = 0x4B0; // int32_t
    public const nint m_bitsDamageType = 0x4B4; // int32_t
    public const nint m_flRadius = 0x4B8; // float
    public const nint m_flDelay = 0x4BC; // float
    public const nint m_strTarget = 0x4C0; // CUtlSymbolLarge
    public const nint m_pActivator = 0x4C8; // CHandle<CBaseEntity>
}

public static class CPointPrefab {
    public const nint m_targetMapName = 0x4B0; // CUtlSymbolLarge
    public const nint m_forceWorldGroupID = 0x4B8; // CUtlSymbolLarge
    public const nint m_associatedRelayTargetName = 0x4C0; // CUtlSymbolLarge
    public const nint m_fixupNames = 0x4C8; // bool
    public const nint m_bLoadDynamic = 0x4C9; // bool
    public const nint m_associatedRelayEntity = 0x4CC; // CHandle<CPointPrefab>
}

public static class CPointProximitySensor {
    public const nint m_bDisabled = 0x4B0; // bool
    public const nint m_hTargetEntity = 0x4B4; // CHandle<CBaseEntity>
    public const nint m_Distance = 0x4B8; // CEntityOutputTemplate<float>
}

public static class CPointPulse {
    public const nint m_sNameFixupStaticPrefix = 0x5C8; // CUtlSymbolLarge
    public const nint m_sNameFixupParent = 0x5D0; // CUtlSymbolLarge
    public const nint m_sNameFixupLocal = 0x5D8; // CUtlSymbolLarge
}

public static class CPointPush {
    public const nint m_bEnabled = 0x4B0; // bool
    public const nint m_flMagnitude = 0x4B4; // float
    public const nint m_flRadius = 0x4B8; // float
    public const nint m_flInnerRadius = 0x4BC; // float
    public const nint m_flConeOfInfluence = 0x4C0; // float
    public const nint m_iszFilterName = 0x4C8; // CUtlSymbolLarge
    public const nint m_hFilter = 0x4D0; // CHandle<CBaseFilter>
}

public static class CPointTeleport {
    public const nint m_vSaveOrigin = 0x4B0; // Vector
    public const nint m_vSaveAngles = 0x4BC; // QAngle
    public const nint m_bTeleportParentedEntities = 0x4C8; // bool
    public const nint m_bTeleportUseCurrentAngle = 0x4C9; // bool
}

public static class CPointTemplate {
    public const nint m_iszWorldName = 0x4B0; // CUtlSymbolLarge
    public const nint m_iszSource2EntityLumpName = 0x4B8; // CUtlSymbolLarge
    public const nint m_iszEntityFilterName = 0x4C0; // CUtlSymbolLarge
    public const nint m_flTimeoutInterval = 0x4C8; // float
    public const nint m_bAsynchronouslySpawnEntities = 0x4CC; // bool
    public const nint m_pOutputOnSpawned = 0x4D0; // CEntityIOOutput
    public const nint m_clientOnlyEntityBehavior = 0x4F8; // PointTemplateClientOnlyEntityBehavior_t
    public const nint m_ownerSpawnGroupType = 0x4FC; // PointTemplateOwnerSpawnGroupType_t
    public const nint m_createdSpawnGroupHandles = 0x500; // CUtlVector<uint32_t>
    public const nint m_SpawnedEntityHandles = 0x518; // CUtlVector<CEntityHandle>
    public const nint m_ScriptSpawnCallback = 0x530; // HSCRIPT
    public const nint m_ScriptCallbackScope = 0x538; // HSCRIPT
}

public static class CPointValueRemapper {
    public const nint m_bDisabled = 0x4B0; // bool
    public const nint m_bUpdateOnClient = 0x4B1; // bool
    public const nint m_nInputType = 0x4B4; // ValueRemapperInputType_t
    public const nint m_iszRemapLineStartName = 0x4B8; // CUtlSymbolLarge
    public const nint m_iszRemapLineEndName = 0x4C0; // CUtlSymbolLarge
    public const nint m_hRemapLineStart = 0x4C8; // CHandle<CBaseEntity>
    public const nint m_hRemapLineEnd = 0x4CC; // CHandle<CBaseEntity>
    public const nint m_flMaximumChangePerSecond = 0x4D0; // float
    public const nint m_flDisengageDistance = 0x4D4; // float
    public const nint m_flEngageDistance = 0x4D8; // float
    public const nint m_bRequiresUseKey = 0x4DC; // bool
    public const nint m_nOutputType = 0x4E0; // ValueRemapperOutputType_t
    public const nint m_iszOutputEntityName = 0x4E8; // CUtlSymbolLarge
    public const nint m_iszOutputEntity2Name = 0x4F0; // CUtlSymbolLarge
    public const nint m_iszOutputEntity3Name = 0x4F8; // CUtlSymbolLarge
    public const nint m_iszOutputEntity4Name = 0x500; // CUtlSymbolLarge
    public const nint m_hOutputEntities = 0x508; // CNetworkUtlVectorBase<CHandle<CBaseEntity>>
    public const nint m_nHapticsType = 0x520; // ValueRemapperHapticsType_t
    public const nint m_nMomentumType = 0x524; // ValueRemapperMomentumType_t
    public const nint m_flMomentumModifier = 0x528; // float
    public const nint m_flSnapValue = 0x52C; // float
    public const nint m_flCurrentMomentum = 0x530; // float
    public const nint m_nRatchetType = 0x534; // ValueRemapperRatchetType_t
    public const nint m_flRatchetOffset = 0x538; // float
    public const nint m_flInputOffset = 0x53C; // float
    public const nint m_bEngaged = 0x540; // bool
    public const nint m_bFirstUpdate = 0x541; // bool
    public const nint m_flPreviousValue = 0x544; // float
    public const nint m_flPreviousUpdateTickTime = 0x548; // GameTime_t
    public const nint m_vecPreviousTestPoint = 0x54C; // Vector
    public const nint m_hUsingPlayer = 0x558; // CHandle<CBasePlayerPawn>
    public const nint m_flCustomOutputValue = 0x55C; // float
    public const nint m_iszSoundEngage = 0x560; // CUtlSymbolLarge
    public const nint m_iszSoundDisengage = 0x568; // CUtlSymbolLarge
    public const nint m_iszSoundReachedValueZero = 0x570; // CUtlSymbolLarge
    public const nint m_iszSoundReachedValueOne = 0x578; // CUtlSymbolLarge
    public const nint m_iszSoundMovingLoop = 0x580; // CUtlSymbolLarge
    public const nint m_Position = 0x590; // CEntityOutputTemplate<float>
    public const nint m_PositionDelta = 0x5B8; // CEntityOutputTemplate<float>
    public const nint m_OnReachedValueZero = 0x5E0; // CEntityIOOutput
    public const nint m_OnReachedValueOne = 0x608; // CEntityIOOutput
    public const nint m_OnReachedValueCustom = 0x630; // CEntityIOOutput
    public const nint m_OnEngage = 0x658; // CEntityIOOutput
    public const nint m_OnDisengage = 0x680; // CEntityIOOutput
}

public static class CPointVelocitySensor {
    public const nint m_hTargetEntity = 0x4B0; // CHandle<CBaseEntity>
    public const nint m_vecAxis = 0x4B4; // Vector
    public const nint m_bEnabled = 0x4C0; // bool
    public const nint m_fPrevVelocity = 0x4C4; // float
    public const nint m_flAvgInterval = 0x4C8; // float
    public const nint m_Velocity = 0x4D0; // CEntityOutputTemplate<float>
}

public static class CPointWorldText {
    public const nint m_messageText = 0x700; // char[512]
    public const nint m_FontName = 0x900; // char[64]
    public const nint m_bEnabled = 0x940; // bool
    public const nint m_bFullbright = 0x941; // bool
    public const nint m_flWorldUnitsPerPx = 0x944; // float
    public const nint m_flFontSize = 0x948; // float
    public const nint m_flDepthOffset = 0x94C; // float
    public const nint m_Color = 0x950; // Color
    public const nint m_nJustifyHorizontal = 0x954; // PointWorldTextJustifyHorizontal_t
    public const nint m_nJustifyVertical = 0x958; // PointWorldTextJustifyVertical_t
    public const nint m_nReorientMode = 0x95C; // PointWorldTextReorientMode_t
}

public static class CPostProcessingVolume {
    public const nint m_hPostSettings = 0x8B8; // CStrongHandle<InfoForResourceTypeCPostProcessingResource>
    public const nint m_flFadeDuration = 0x8C0; // float
    public const nint m_flMinLogExposure = 0x8C4; // float
    public const nint m_flMaxLogExposure = 0x8C8; // float
    public const nint m_flMinExposure = 0x8CC; // float
    public const nint m_flMaxExposure = 0x8D0; // float
    public const nint m_flExposureCompensation = 0x8D4; // float
    public const nint m_flExposureFadeSpeedUp = 0x8D8; // float
    public const nint m_flExposureFadeSpeedDown = 0x8DC; // float
    public const nint m_flTonemapEVSmoothingRange = 0x8E0; // float
    public const nint m_bMaster = 0x8E4; // bool
    public const nint m_bExposureControl = 0x8E5; // bool
    public const nint m_flRate = 0x8E8; // float
    public const nint m_flTonemapPercentTarget = 0x8EC; // float
    public const nint m_flTonemapPercentBrightPixels = 0x8F0; // float
    public const nint m_flTonemapMinAvgLum = 0x8F4; // float
}

public static class CPrecipitationVData {
    public const nint m_szParticlePrecipitationEffect = 0x28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    public const nint m_flInnerDistance = 0x108; // float
    public const nint m_nAttachType = 0x10C; // ParticleAttachment_t
    public const nint m_bBatchSameVolumeType = 0x110; // bool
    public const nint m_nRTEnvCP = 0x114; // int32_t
    public const nint m_nRTEnvCPComponent = 0x118; // int32_t
    public const nint m_szModifier = 0x120; // CUtlString
}

public static class CProjectedDecal {
    public const nint m_nTexture = 0x4B0; // int32_t
    public const nint m_flDistance = 0x4B4; // float
}

public static class CPropDoorRotating {
    public const nint m_vecAxis = 0xD98; // Vector
    public const nint m_flDistance = 0xDA4; // float
    public const nint m_eSpawnPosition = 0xDA8; // PropDoorRotatingSpawnPos_t
    public const nint m_eOpenDirection = 0xDAC; // PropDoorRotatingOpenDirection_e
    public const nint m_eCurrentOpenDirection = 0xDB0; // PropDoorRotatingOpenDirection_e
    public const nint m_flAjarAngle = 0xDB4; // float
    public const nint m_angRotationAjarDeprecated = 0xDB8; // QAngle
    public const nint m_angRotationClosed = 0xDC4; // QAngle
    public const nint m_angRotationOpenForward = 0xDD0; // QAngle
    public const nint m_angRotationOpenBack = 0xDDC; // QAngle
    public const nint m_angGoal = 0xDE8; // QAngle
    public const nint m_vecForwardBoundsMin = 0xDF4; // Vector
    public const nint m_vecForwardBoundsMax = 0xE00; // Vector
    public const nint m_vecBackBoundsMin = 0xE0C; // Vector
    public const nint m_vecBackBoundsMax = 0xE18; // Vector
    public const nint m_bAjarDoorShouldntAlwaysOpen = 0xE24; // bool
    public const nint m_hEntityBlocker = 0xE28; // CHandle<CEntityBlocker>
}

public static class CPropDoorRotatingBreakable {
    public const nint m_bBreakable = 0xE30; // bool
    public const nint m_isAbleToCloseAreaPortals = 0xE31; // bool
    public const nint m_currentDamageState = 0xE34; // int32_t
    public const nint m_damageStates = 0xE38; // CUtlVector<CUtlSymbolLarge>
}

public static class CPulseCell_Inflow_GameEvent {
    public const nint m_EventName = 0x70; // CBufferString
}

public static class CPulseCell_Outflow_PlayVCD {
    public const nint m_vcdFilename = 0x48; // CUtlString
    public const nint m_OnFinished = 0x50; // CPulse_OutflowConnection
    public const nint m_Triggers = 0x60; // CUtlVector<CPulse_OutflowConnection>
}

public static class CPulseCell_SoundEventStart {
    public const nint m_Type = 0x48; // SoundEventStartType_t
}

public static class CPulseCell_Step_EntFire {
    public const nint m_Input = 0x48; // CUtlString
}

public static class CPulseCell_Step_SetAnimGraphParam {
    public const nint m_ParamName = 0x48; // CUtlString
}

public static class CPulseCell_Value_FindEntByName {
    public const nint m_EntityType = 0x48; // CUtlString
}

public static class CRR_Response {
    public const nint m_Type = 0x0; // uint8_t
    public const nint m_szResponseName = 0x1; // char[192]
    public const nint m_szMatchingRule = 0xC1; // char[128]
    public const nint m_Params = 0x148; // ResponseParams
    public const nint m_fMatchScore = 0x168; // float
    public const nint m_szSpeakerContext = 0x170; // char*
    public const nint m_szWorldContext = 0x178; // char*
    public const nint m_Followup = 0x180; // ResponseFollowup
    public const nint m_pchCriteriaNames = 0x1B8; // CUtlVector<CUtlSymbol>
    public const nint m_pchCriteriaValues = 0x1D0; // CUtlVector<char*>
}

public static class CRagdollConstraint {
    public const nint m_xmin = 0x508; // float
    public const nint m_xmax = 0x50C; // float
    public const nint m_ymin = 0x510; // float
    public const nint m_ymax = 0x514; // float
    public const nint m_zmin = 0x518; // float
    public const nint m_zmax = 0x51C; // float
    public const nint m_xfriction = 0x520; // float
    public const nint m_yfriction = 0x524; // float
    public const nint m_zfriction = 0x528; // float
}

public static class CRagdollMagnet {
    public const nint m_bDisabled = 0x4B0; // bool
    public const nint m_radius = 0x4B4; // float
    public const nint m_force = 0x4B8; // float
    public const nint m_axis = 0x4BC; // Vector
}

public static class CRagdollManager {
    public const nint m_iCurrentMaxRagdollCount = 0x4B0; // int8_t
    public const nint m_iMaxRagdollCount = 0x4B4; // int32_t
    public const nint m_bSaveImportant = 0x4B8; // bool
}

public static class CRagdollProp {
    public const nint m_ragdoll = 0x898; // ragdoll_t
    public const nint m_bStartDisabled = 0x8D0; // bool
    public const nint m_ragPos = 0x8D8; // CNetworkUtlVectorBase<Vector>
    public const nint m_ragAngles = 0x8F0; // CNetworkUtlVectorBase<QAngle>
    public const nint m_hRagdollSource = 0x908; // CHandle<CBaseEntity>
    public const nint m_lastUpdateTickCount = 0x90C; // uint32_t
    public const nint m_allAsleep = 0x910; // bool
    public const nint m_bFirstCollisionAfterLaunch = 0x911; // bool
    public const nint m_hDamageEntity = 0x914; // CHandle<CBaseEntity>
    public const nint m_hKiller = 0x918; // CHandle<CBaseEntity>
    public const nint m_hPhysicsAttacker = 0x91C; // CHandle<CBasePlayerPawn>
    public const nint m_flLastPhysicsInfluenceTime = 0x920; // GameTime_t
    public const nint m_flFadeOutStartTime = 0x924; // GameTime_t
    public const nint m_flFadeTime = 0x928; // float
    public const nint m_vecLastOrigin = 0x92C; // Vector
    public const nint m_flAwakeTime = 0x938; // GameTime_t
    public const nint m_flLastOriginChangeTime = 0x93C; // GameTime_t
    public const nint m_nBloodColor = 0x940; // int32_t
    public const nint m_strOriginClassName = 0x948; // CUtlSymbolLarge
    public const nint m_strSourceClassName = 0x950; // CUtlSymbolLarge
    public const nint m_bHasBeenPhysgunned = 0x958; // bool
    public const nint m_bShouldTeleportPhysics = 0x959; // bool
    public const nint m_flBlendWeight = 0x95C; // float
    public const nint m_flDefaultFadeScale = 0x960; // float
    public const nint m_ragdollMins = 0x968; // CUtlVector<Vector>
    public const nint m_ragdollMaxs = 0x980; // CUtlVector<Vector>
    public const nint m_bShouldDeleteActivationRecord = 0x998; // bool
    public const nint m_bValidatePoweredRagdollPose = 0x9F8; // bool
}

public static class CRagdollPropAttached {
    public const nint m_boneIndexAttached = 0xA38; // uint32_t
    public const nint m_ragdollAttachedObjectIndex = 0xA3C; // uint32_t
    public const nint m_attachmentPointBoneSpace = 0xA40; // Vector
    public const nint m_attachmentPointRagdollSpace = 0xA4C; // Vector
    public const nint m_bShouldDetach = 0xA58; // bool
    public const nint m_bShouldDeleteAttachedActivationRecord = 0xA68; // bool
}

public static class CRandSimTimer {
    public const nint m_minInterval = 0x8; // float
    public const nint m_maxInterval = 0xC; // float
}

public static class CRandStopwatch {
    public const nint m_minInterval = 0xC; // float
    public const nint m_maxInterval = 0x10; // float
}

public static class CRangeFloat {
    public const nint m_pValue = 0x0; // float[2]
}

public static class CRangeInt {
    public const nint m_pValue = 0x0; // int32_t[2]
}

public static class CRectLight {
    public const nint m_bShowLight = 0x928; // bool
}

public static class CRemapFloat {
    public const nint m_pValue = 0x0; // float[4]
}

public static class CRenderComponent {
    public const nint __m_pChainEntity = 0x10; // CNetworkVarChainer
    public const nint m_bIsRenderingWithViewModels = 0x50; // bool
    public const nint m_nSplitscreenFlags = 0x54; // uint32_t
    public const nint m_bEnableRendering = 0x60; // bool
    public const nint m_bInterpolationReadyToDraw = 0xB0; // bool
}

public static class CResponseCriteriaSet {
    public const nint m_nNumPrefixedContexts = 0x28; // int32_t
    public const nint m_bOverrideOnAppend = 0x2C; // bool
}

public static class CResponseQueue {
    public const nint m_ExpresserTargets = 0x50; // CUtlVector<CAI_Expresser*>
}

public static class CResponseQueue_CDeferredResponse {
    public const nint m_contexts = 0x10; // CResponseCriteriaSet
    public const nint m_fDispatchTime = 0x40; // float
    public const nint m_hIssuer = 0x44; // CHandle<CBaseEntity>
    public const nint m_response = 0x50; // CRR_Response
    public const nint m_bResponseValid = 0x238; // bool
}

public static class CRetakeGameRules {
    public const nint m_nMatchSeed = 0xF8; // int32_t
    public const nint m_bBlockersPresent = 0xFC; // bool
    public const nint m_bRoundInProgress = 0xFD; // bool
    public const nint m_iFirstSecondHalfRound = 0x100; // int32_t
    public const nint m_iBombSite = 0x104; // int32_t
}

public static class CRevertSaved {
    public const nint m_loadTime = 0x700; // float
    public const nint m_Duration = 0x704; // float
    public const nint m_HoldTime = 0x708; // float
}

public static class CRopeKeyframe {
    public const nint m_RopeFlags = 0x708; // uint16_t
    public const nint m_iNextLinkName = 0x710; // CUtlSymbolLarge
    public const nint m_Slack = 0x718; // int16_t
    public const nint m_Width = 0x71C; // float
    public const nint m_TextureScale = 0x720; // float
    public const nint m_nSegments = 0x724; // uint8_t
    public const nint m_bConstrainBetweenEndpoints = 0x725; // bool
    public const nint m_strRopeMaterialModel = 0x728; // CUtlSymbolLarge
    public const nint m_iRopeMaterialModelIndex = 0x730; // CStrongHandle<InfoForResourceTypeIMaterial2>
    public const nint m_Subdiv = 0x738; // uint8_t
    public const nint m_nChangeCount = 0x739; // uint8_t
    public const nint m_RopeLength = 0x73A; // int16_t
    public const nint m_fLockedPoints = 0x73C; // uint8_t
    public const nint m_bCreatedFromMapFile = 0x73D; // bool
    public const nint m_flScrollSpeed = 0x740; // float
    public const nint m_bStartPointValid = 0x744; // bool
    public const nint m_bEndPointValid = 0x745; // bool
    public const nint m_hStartPoint = 0x748; // CHandle<CBaseEntity>
    public const nint m_hEndPoint = 0x74C; // CHandle<CBaseEntity>
    public const nint m_iStartAttachment = 0x750; // AttachmentHandle_t
    public const nint m_iEndAttachment = 0x751; // AttachmentHandle_t
}

public static class CRotDoor {
    public const nint m_bSolidBsp = 0x988; // bool
}

public static class CRuleEntity {
    public const nint m_iszMaster = 0x700; // CUtlSymbolLarge
}

public static class CRulePointEntity {
    public const nint m_Score = 0x708; // int32_t
}

public static class CSAdditionalMatchStats_t {
    public const nint m_numRoundsSurvived = 0x14; // int32_t
    public const nint m_maxNumRoundsSurvived = 0x18; // int32_t
    public const nint m_numRoundsSurvivedTotal = 0x1C; // int32_t
    public const nint m_iRoundsWonWithoutPurchase = 0x20; // int32_t
    public const nint m_iRoundsWonWithoutPurchaseTotal = 0x24; // int32_t
    public const nint m_numFirstKills = 0x28; // int32_t
    public const nint m_numClutchKills = 0x2C; // int32_t
    public const nint m_numPistolKills = 0x30; // int32_t
    public const nint m_numSniperKills = 0x34; // int32_t
    public const nint m_iNumSuicides = 0x38; // int32_t
    public const nint m_iNumTeamKills = 0x3C; // int32_t
    public const nint m_iTeamDamage = 0x40; // int32_t
}

public static class CSAdditionalPerRoundStats_t {
    public const nint m_numChickensKilled = 0x0; // int32_t
    public const nint m_killsWhileBlind = 0x4; // int32_t
    public const nint m_bombCarrierkills = 0x8; // int32_t
    public const nint m_iBurnDamageInflicted = 0xC; // int32_t
    public const nint m_iDinks = 0x10; // int32_t
}

public static class CSMatchStats_t {
    public const nint m_iEnemy5Ks = 0x68; // int32_t
    public const nint m_iEnemy4Ks = 0x6C; // int32_t
    public const nint m_iEnemy3Ks = 0x70; // int32_t
    public const nint m_iEnemy2Ks = 0x74; // int32_t
    public const nint m_iUtility_Count = 0x78; // int32_t
    public const nint m_iUtility_Successes = 0x7C; // int32_t
    public const nint m_iUtility_Enemies = 0x80; // int32_t
    public const nint m_iFlash_Count = 0x84; // int32_t
    public const nint m_iFlash_Successes = 0x88; // int32_t
    public const nint m_nHealthPointsRemovedTotal = 0x8C; // int32_t
    public const nint m_nHealthPointsDealtTotal = 0x90; // int32_t
    public const nint m_nShotsFiredTotal = 0x94; // int32_t
    public const nint m_nShotsOnTargetTotal = 0x98; // int32_t
    public const nint m_i1v1Count = 0x9C; // int32_t
    public const nint m_i1v1Wins = 0xA0; // int32_t
    public const nint m_i1v2Count = 0xA4; // int32_t
    public const nint m_i1v2Wins = 0xA8; // int32_t
    public const nint m_iEntryCount = 0xAC; // int32_t
    public const nint m_iEntryWins = 0xB0; // int32_t
}

public static class CSPerRoundStats_t {
    public const nint m_iKills = 0x30; // int32_t
    public const nint m_iDeaths = 0x34; // int32_t
    public const nint m_iAssists = 0x38; // int32_t
    public const nint m_iDamage = 0x3C; // int32_t
    public const nint m_iEquipmentValue = 0x40; // int32_t
    public const nint m_iMoneySaved = 0x44; // int32_t
    public const nint m_iKillReward = 0x48; // int32_t
    public const nint m_iLiveTime = 0x4C; // int32_t
    public const nint m_iHeadShotKills = 0x50; // int32_t
    public const nint m_iObjective = 0x54; // int32_t
    public const nint m_iCashEarned = 0x58; // int32_t
    public const nint m_iUtilityDamage = 0x5C; // int32_t
    public const nint m_iEnemiesFlashed = 0x60; // int32_t
}

public static class CSceneEntity {
    public const nint m_iszSceneFile = 0x4B8; // CUtlSymbolLarge
    public const nint m_iszResumeSceneFile = 0x4C0; // CUtlSymbolLarge
    public const nint m_iszTarget1 = 0x4C8; // CUtlSymbolLarge
    public const nint m_iszTarget2 = 0x4D0; // CUtlSymbolLarge
    public const nint m_iszTarget3 = 0x4D8; // CUtlSymbolLarge
    public const nint m_iszTarget4 = 0x4E0; // CUtlSymbolLarge
    public const nint m_iszTarget5 = 0x4E8; // CUtlSymbolLarge
    public const nint m_iszTarget6 = 0x4F0; // CUtlSymbolLarge
    public const nint m_iszTarget7 = 0x4F8; // CUtlSymbolLarge
    public const nint m_iszTarget8 = 0x500; // CUtlSymbolLarge
    public const nint m_hTarget1 = 0x508; // CHandle<CBaseEntity>
    public const nint m_hTarget2 = 0x50C; // CHandle<CBaseEntity>
    public const nint m_hTarget3 = 0x510; // CHandle<CBaseEntity>
    public const nint m_hTarget4 = 0x514; // CHandle<CBaseEntity>
    public const nint m_hTarget5 = 0x518; // CHandle<CBaseEntity>
    public const nint m_hTarget6 = 0x51C; // CHandle<CBaseEntity>
    public const nint m_hTarget7 = 0x520; // CHandle<CBaseEntity>
    public const nint m_hTarget8 = 0x524; // CHandle<CBaseEntity>
    public const nint m_bIsPlayingBack = 0x528; // bool
    public const nint m_bPaused = 0x529; // bool
    public const nint m_bMultiplayer = 0x52A; // bool
    public const nint m_bAutogenerated = 0x52B; // bool
    public const nint m_flForceClientTime = 0x52C; // float
    public const nint m_flCurrentTime = 0x530; // float
    public const nint m_flFrameTime = 0x534; // float
    public const nint m_bCancelAtNextInterrupt = 0x538; // bool
    public const nint m_fPitch = 0x53C; // float
    public const nint m_bAutomated = 0x540; // bool
    public const nint m_nAutomatedAction = 0x544; // int32_t
    public const nint m_flAutomationDelay = 0x548; // float
    public const nint m_flAutomationTime = 0x54C; // float
    public const nint m_hWaitingForThisResumeScene = 0x550; // CHandle<CBaseEntity>
    public const nint m_bWaitingForResumeScene = 0x554; // bool
    public const nint m_bPausedViaInput = 0x555; // bool
    public const nint m_bPauseAtNextInterrupt = 0x556; // bool
    public const nint m_bWaitingForActor = 0x557; // bool
    public const nint m_bWaitingForInterrupt = 0x558; // bool
    public const nint m_bInterruptedActorsScenes = 0x559; // bool
    public const nint m_bBreakOnNonIdle = 0x55A; // bool
    public const nint m_hActorList = 0x560; // CNetworkUtlVectorBase<CHandle<CBaseFlex>>
    public const nint m_hRemoveActorList = 0x578; // CUtlVector<CHandle<CBaseEntity>>
    public const nint m_nSceneFlushCounter = 0x5A0; // int32_t
    public const nint m_nSceneStringIndex = 0x5A4; // uint16_t
    public const nint m_OnStart = 0x5A8; // CEntityIOOutput
    public const nint m_OnCompletion = 0x5D0; // CEntityIOOutput
    public const nint m_OnCanceled = 0x5F8; // CEntityIOOutput
    public const nint m_OnPaused = 0x620; // CEntityIOOutput
    public const nint m_OnResumed = 0x648; // CEntityIOOutput
    public const nint m_OnTrigger = 0x670; // CEntityIOOutput[16]
    public const nint m_hInterruptScene = 0x980; // CHandle<CSceneEntity>
    public const nint m_nInterruptCount = 0x984; // int32_t
    public const nint m_bSceneMissing = 0x988; // bool
    public const nint m_bInterrupted = 0x989; // bool
    public const nint m_bCompletedEarly = 0x98A; // bool
    public const nint m_bInterruptSceneFinished = 0x98B; // bool
    public const nint m_bRestoring = 0x98C; // bool
    public const nint m_hNotifySceneCompletion = 0x990; // CUtlVector<CHandle<CSceneEntity>>
    public const nint m_hListManagers = 0x9A8; // CUtlVector<CHandle<CSceneListManager>>
    public const nint m_iszSoundName = 0x9E8; // CUtlSymbolLarge
    public const nint m_hActor = 0x9F0; // CHandle<CBaseFlex>
    public const nint m_hActivator = 0x9F4; // CHandle<CBaseEntity>
    public const nint m_BusyActor = 0x9F8; // int32_t
    public const nint m_iPlayerDeathBehavior = 0x9FC; // SceneOnPlayerDeath_t
}

public static class CSceneEventInfo {
    public const nint m_iLayer = 0x0; // int32_t
    public const nint m_iPriority = 0x4; // int32_t
    public const nint m_hSequence = 0x8; // HSequence
    public const nint m_flWeight = 0xC; // float
    public const nint m_bIsMoving = 0x10; // bool
    public const nint m_bHasArrived = 0x11; // bool
    public const nint m_flInitialYaw = 0x14; // float
    public const nint m_flTargetYaw = 0x18; // float
    public const nint m_flFacingYaw = 0x1C; // float
    public const nint m_nType = 0x20; // int32_t
    public const nint m_flNext = 0x24; // GameTime_t
    public const nint m_bIsGesture = 0x28; // bool
    public const nint m_bShouldRemove = 0x29; // bool
    public const nint m_hTarget = 0x54; // CHandle<CBaseEntity>
    public const nint m_nSceneEventId = 0x58; // uint32_t
    public const nint m_bClientSide = 0x5C; // bool
    public const nint m_bStarted = 0x5D; // bool
}

public static class CSceneListManager {
    public const nint m_hListManagers = 0x4B0; // CUtlVector<CHandle<CSceneListManager>>
    public const nint m_iszScenes = 0x4C8; // CUtlSymbolLarge[16]
    public const nint m_hScenes = 0x548; // CHandle<CBaseEntity>[16]
}

public static class CScriptComponent {
    public const nint m_scriptClassName = 0x30; // CUtlSymbolLarge
}

public static class CScriptItem {
    public const nint m_OnPlayerPickup = 0x968; // CEntityIOOutput
    public const nint m_MoveTypeOverride = 0x990; // MoveType_t
}

public static class CScriptNavBlocker {
    public const nint m_vExtent = 0x710; // Vector
}

public static class CScriptTriggerHurt {
    public const nint m_vExtent = 0x948; // Vector
}

public static class CScriptTriggerMultiple {
    public const nint m_vExtent = 0x8D0; // Vector
}

public static class CScriptTriggerOnce {
    public const nint m_vExtent = 0x8D0; // Vector
}

public static class CScriptTriggerPush {
    public const nint m_vExtent = 0x8D0; // Vector
}

public static class CScriptUniformRandomStream {
    public const nint m_hScriptScope = 0x8; // HSCRIPT
    public const nint m_nInitialSeed = 0x9C; // int32_t
}

public static class CScriptedSequence {
    public const nint m_iszEntry = 0x4B0; // CUtlSymbolLarge
    public const nint m_iszPreIdle = 0x4B8; // CUtlSymbolLarge
    public const nint m_iszPlay = 0x4C0; // CUtlSymbolLarge
    public const nint m_iszPostIdle = 0x4C8; // CUtlSymbolLarge
    public const nint m_iszModifierToAddOnPlay = 0x4D0; // CUtlSymbolLarge
    public const nint m_iszNextScript = 0x4D8; // CUtlSymbolLarge
    public const nint m_iszEntity = 0x4E0; // CUtlSymbolLarge
    public const nint m_iszSyncGroup = 0x4E8; // CUtlSymbolLarge
    public const nint m_nMoveTo = 0x4F0; // ScriptedMoveTo_t
    public const nint m_bIsPlayingPreIdle = 0x4F4; // bool
    public const nint m_bIsPlayingEntry = 0x4F5; // bool
    public const nint m_bIsPlayingAction = 0x4F6; // bool
    public const nint m_bIsPlayingPostIdle = 0x4F7; // bool
    public const nint m_bLoopPreIdleSequence = 0x4F8; // bool
    public const nint m_bLoopActionSequence = 0x4F9; // bool
    public const nint m_bLoopPostIdleSequence = 0x4FA; // bool
    public const nint m_bSynchPostIdles = 0x4FB; // bool
    public const nint m_bIgnoreGravity = 0x4FC; // bool
    public const nint m_bDisableNPCCollisions = 0x4FD; // bool
    public const nint m_bKeepAnimgraphLockedPost = 0x4FE; // bool
    public const nint m_bDontAddModifiers = 0x4FF; // bool
    public const nint m_flRadius = 0x500; // float
    public const nint m_flRepeat = 0x504; // float
    public const nint m_flPlayAnimFadeInTime = 0x508; // float
    public const nint m_flMoveInterpTime = 0x50C; // float
    public const nint m_flAngRate = 0x510; // float
    public const nint m_iDelay = 0x514; // int32_t
    public const nint m_startTime = 0x518; // GameTime_t
    public const nint m_bWaitForBeginSequence = 0x51C; // bool
    public const nint m_saved_effects = 0x520; // int32_t
    public const nint m_savedFlags = 0x524; // int32_t
    public const nint m_savedCollisionGroup = 0x528; // int32_t
    public const nint m_interruptable = 0x52C; // bool
    public const nint m_sequenceStarted = 0x52D; // bool
    public const nint m_bPrevAnimatedEveryTick = 0x52E; // bool
    public const nint m_bForcedAnimatedEveryTick = 0x52F; // bool
    public const nint m_bPositionRelativeToOtherEntity = 0x530; // bool
    public const nint m_hTargetEnt = 0x534; // CHandle<CBaseEntity>
    public const nint m_hNextCine = 0x538; // CHandle<CScriptedSequence>
    public const nint m_bThinking = 0x53C; // bool
    public const nint m_bInitiatedSelfDelete = 0x53D; // bool
    public const nint m_bIsTeleportingDueToMoveTo = 0x53E; // bool
    public const nint m_bAllowCustomInterruptConditions = 0x53F; // bool
    public const nint m_hLastFoundEntity = 0x540; // CHandle<CBaseEntity>
    public const nint m_hForcedTarget = 0x544; // CHandle<CBaseAnimGraph>
    public const nint m_bDontCancelOtherSequences = 0x548; // bool
    public const nint m_bForceSynch = 0x549; // bool
    public const nint m_bTargetWasAsleep = 0x54A; // bool
    public const nint m_bPreventUpdateYawOnFinish = 0x54B; // bool
    public const nint m_bEnsureOnNavmeshOnFinish = 0x54C; // bool
    public const nint m_onDeathBehavior = 0x550; // ScriptedOnDeath_t
    public const nint m_ConflictResponse = 0x554; // ScriptedConflictResponse_t
    public const nint m_OnBeginSequence = 0x558; // CEntityIOOutput
    public const nint m_OnActionStartOrLoop = 0x580; // CEntityIOOutput
    public const nint m_OnEndSequence = 0x5A8; // CEntityIOOutput
    public const nint m_OnPostIdleEndSequence = 0x5D0; // CEntityIOOutput
    public const nint m_OnCancelSequence = 0x5F8; // CEntityIOOutput
    public const nint m_OnCancelFailedSequence = 0x620; // CEntityIOOutput
    public const nint m_OnScriptEvent = 0x648; // CEntityIOOutput[8]
    public const nint m_matOtherToMain = 0x790; // CTransform
    public const nint m_hInteractionMainEntity = 0x7B0; // CHandle<CBaseEntity>
    public const nint m_iPlayerDeathBehavior = 0x7B4; // int32_t
}

public static class CSensorGrenadeProjectile {
    public const nint m_fExpireTime = 0xA40; // GameTime_t
    public const nint m_fNextDetectPlayerSound = 0xA44; // GameTime_t
    public const nint m_hDisplayGrenade = 0xA48; // CHandle<CBaseEntity>
}

public static class CShatterGlassShard {
    public const nint m_hShardHandle = 0x8; // uint32_t
    public const nint m_vecPanelVertices = 0x10; // CUtlVector<Vector2D>
    public const nint m_vLocalPanelSpaceOrigin = 0x28; // Vector2D
    public const nint m_hModel = 0x30; // CStrongHandle<InfoForResourceTypeCModel>
    public const nint m_hPhysicsEntity = 0x38; // CHandle<CShatterGlassShardPhysics>
    public const nint m_hParentPanel = 0x3C; // CHandle<CFuncShatterglass>
    public const nint m_hParentShard = 0x40; // uint32_t
    public const nint m_ShatterStressType = 0x44; // ShatterGlassStressType
    public const nint m_vecStressVelocity = 0x48; // Vector
    public const nint m_bCreatedModel = 0x54; // bool
    public const nint m_flLongestEdge = 0x58; // float
    public const nint m_flShortestEdge = 0x5C; // float
    public const nint m_flLongestAcross = 0x60; // float
    public const nint m_flShortestAcross = 0x64; // float
    public const nint m_flSumOfAllEdges = 0x68; // float
    public const nint m_flArea = 0x6C; // float
    public const nint m_nOnFrameEdge = 0x70; // OnFrame
    public const nint m_nParentPanelsNthShard = 0x74; // int32_t
    public const nint m_nSubShardGeneration = 0x78; // int32_t
    public const nint m_vecAverageVertPosition = 0x7C; // Vector2D
    public const nint m_bAverageVertPositionIsValid = 0x84; // bool
    public const nint m_vecPanelSpaceStressPositionA = 0x88; // Vector2D
    public const nint m_vecPanelSpaceStressPositionB = 0x90; // Vector2D
    public const nint m_bStressPositionAIsValid = 0x98; // bool
    public const nint m_bStressPositionBIsValid = 0x99; // bool
    public const nint m_bFlaggedForRemoval = 0x9A; // bool
    public const nint m_flPhysicsEntitySpawnedAtTime = 0x9C; // GameTime_t
    public const nint m_bShatterRateLimited = 0xA0; // bool
    public const nint m_hEntityHittingMe = 0xA4; // CHandle<CBaseEntity>
    public const nint m_vecNeighbors = 0xA8; // CUtlVector<uint32_t>
}

public static class CShatterGlassShardPhysics {
    public const nint m_bDebris = 0xB78; // bool
    public const nint m_hParentShard = 0xB7C; // uint32_t
    public const nint m_ShardDesc = 0xB80; // shard_model_desc_t
}

public static class CSimTimer {
    public const nint m_interval = 0x8; // float
}

public static class CSimpleSimTimer {
    public const nint m_next = 0x0; // GameTime_t
    public const nint m_nWorldGroupId = 0x4; // WorldGroupId_t
}

public static class CSingleplayRules {
    public const nint m_bSinglePlayerGameEnding = 0x90; // bool
}

public static class CSkeletonAnimationController {
    public const nint m_pSkeletonInstance = 0x8; // CSkeletonInstance*
}

public static class CSkeletonInstance {
    public const nint m_modelState = 0x160; // CModelState
    public const nint m_bIsAnimationEnabled = 0x390; // bool
    public const nint m_bUseParentRenderBounds = 0x391; // bool
    public const nint m_bDisableSolidCollisionsForHierarchy = 0x392; // bool
    public const nint m_bDirtyMotionType = 0x0; // bitfield:1
    public const nint m_bIsGeneratingLatchedParentSpaceState = 0x0; // bitfield:1
    public const nint m_materialGroup = 0x394; // CUtlStringToken
    public const nint m_nHitboxSet = 0x398; // uint8_t
}

public static class CSkillDamage {
    public const nint m_flDamage = 0x0; // CSkillFloat
    public const nint m_flPhysicsForceDamage = 0x10; // float
}

public static class CSkillFloat {
    public const nint m_pValue = 0x0; // float[4]
}

public static class CSkillInt {
    public const nint m_pValue = 0x0; // int32_t[4]
}

public static class CSkyCamera {
    public const nint m_skyboxData = 0x4B0; // sky3dparams_t
    public const nint m_skyboxSlotToken = 0x540; // CUtlStringToken
    public const nint m_bUseAngles = 0x544; // bool
    public const nint m_pNext = 0x548; // CSkyCamera*
}

public static class CSkyboxReference {
    public const nint m_worldGroupId = 0x4B0; // WorldGroupId_t
    public const nint m_hSkyCamera = 0x4B4; // CHandle<CSkyCamera>
}

public static class CSmokeGrenadeProjectile {
    public const nint m_nSmokeEffectTickBegin = 0xA58; // int32_t
    public const nint m_bDidSmokeEffect = 0xA5C; // bool
    public const nint m_nRandomSeed = 0xA60; // int32_t
    public const nint m_vSmokeColor = 0xA64; // Vector
    public const nint m_vSmokeDetonationPos = 0xA70; // Vector
    public const nint m_VoxelFrameData = 0xA80; // CUtlVector<uint8_t>
    public const nint m_flLastBounce = 0xA98; // GameTime_t
    public const nint m_fllastSimulationTime = 0xA9C; // GameTime_t
}

public static class CSmoothFunc {
    public const nint m_flSmoothAmplitude = 0x8; // float
    public const nint m_flSmoothBias = 0xC; // float
    public const nint m_flSmoothDuration = 0x10; // float
    public const nint m_flSmoothRemainingTime = 0x14; // float
    public const nint m_nSmoothDir = 0x18; // int32_t
}

public static class CSound {
    public const nint m_hOwner = 0x0; // CHandle<CBaseEntity>
    public const nint m_hTarget = 0x4; // CHandle<CBaseEntity>
    public const nint m_iVolume = 0x8; // int32_t
    public const nint m_flOcclusionScale = 0xC; // float
    public const nint m_iType = 0x10; // int32_t
    public const nint m_iNextAudible = 0x14; // int32_t
    public const nint m_flExpireTime = 0x18; // GameTime_t
    public const nint m_iNext = 0x1C; // int16_t
    public const nint m_bNoExpirationTime = 0x1E; // bool
    public const nint m_ownerChannelIndex = 0x20; // int32_t
    public const nint m_vecOrigin = 0x24; // Vector
    public const nint m_bHasOwner = 0x30; // bool
}

public static class CSoundAreaEntityBase {
    public const nint m_bDisabled = 0x4B0; // bool
    public const nint m_iszSoundAreaType = 0x4B8; // CUtlSymbolLarge
    public const nint m_vPos = 0x4C0; // Vector
}

public static class CSoundAreaEntityOrientedBox {
    public const nint m_vMin = 0x4D0; // Vector
    public const nint m_vMax = 0x4DC; // Vector
}

public static class CSoundAreaEntitySphere {
    public const nint m_flRadius = 0x4D0; // float
}

public static class CSoundEnt {
    public const nint m_iFreeSound = 0x4B0; // int32_t
    public const nint m_iActiveSound = 0x4B4; // int32_t
    public const nint m_cLastActiveSounds = 0x4B8; // int32_t
    public const nint m_SoundPool = 0x4BC; // CSound[128]
}

public static class CSoundEnvelope {
    public const nint m_current = 0x0; // float
    public const nint m_target = 0x4; // float
    public const nint m_rate = 0x8; // float
    public const nint m_forceupdate = 0xC; // bool
}

public static class CSoundEventAABBEntity {
    public const nint m_vMins = 0x558; // Vector
    public const nint m_vMaxs = 0x564; // Vector
}

public static class CSoundEventEntity {
    public const nint m_bStartOnSpawn = 0x4B0; // bool
    public const nint m_bToLocalPlayer = 0x4B1; // bool
    public const nint m_bStopOnNew = 0x4B2; // bool
    public const nint m_bSaveRestore = 0x4B3; // bool
    public const nint m_bSavedIsPlaying = 0x4B4; // bool
    public const nint m_flSavedElapsedTime = 0x4B8; // float
    public const nint m_iszSourceEntityName = 0x4C0; // CUtlSymbolLarge
    public const nint m_iszAttachmentName = 0x4C8; // CUtlSymbolLarge
    public const nint m_onGUIDChanged = 0x4D0; // CEntityOutputTemplate<uint64_t>
    public const nint m_onSoundFinished = 0x4F8; // CEntityIOOutput
    public const nint m_iszSoundName = 0x540; // CUtlSymbolLarge
    public const nint m_hSource = 0x550; // CEntityHandle
}

public static class CSoundEventOBBEntity {
    public const nint m_vMins = 0x558; // Vector
    public const nint m_vMaxs = 0x564; // Vector
}

public static class CSoundEventParameter {
    public const nint m_iszParamName = 0x4B8; // CUtlSymbolLarge
    public const nint m_flFloatValue = 0x4C0; // float
}

public static class CSoundEventPathCornerEntity {
    public const nint m_iszPathCorner = 0x558; // CUtlSymbolLarge
    public const nint m_iCountMax = 0x560; // int32_t
    public const nint m_flDistanceMax = 0x564; // float
    public const nint m_flDistMaxSqr = 0x568; // float
    public const nint m_flDotProductMax = 0x56C; // float
    public const nint bPlaying = 0x570; // bool
}

public static class CSoundOpvarSetAABBEntity {
    public const nint m_vDistanceInnerMins = 0x648; // Vector
    public const nint m_vDistanceInnerMaxs = 0x654; // Vector
    public const nint m_vDistanceOuterMins = 0x660; // Vector
    public const nint m_vDistanceOuterMaxs = 0x66C; // Vector
    public const nint m_nAABBDirection = 0x678; // int32_t
    public const nint m_vInnerMins = 0x67C; // Vector
    public const nint m_vInnerMaxs = 0x688; // Vector
    public const nint m_vOuterMins = 0x694; // Vector
    public const nint m_vOuterMaxs = 0x6A0; // Vector
}

public static class CSoundOpvarSetEntity {
    public const nint m_iszStackName = 0x4B8; // CUtlSymbolLarge
    public const nint m_iszOperatorName = 0x4C0; // CUtlSymbolLarge
    public const nint m_iszOpvarName = 0x4C8; // CUtlSymbolLarge
    public const nint m_nOpvarType = 0x4D0; // int32_t
    public const nint m_nOpvarIndex = 0x4D4; // int32_t
    public const nint m_flOpvarValue = 0x4D8; // float
    public const nint m_OpvarValueString = 0x4E0; // CUtlSymbolLarge
    public const nint m_bSetOnSpawn = 0x4E8; // bool
}

public static class CSoundOpvarSetOBBWindEntity {
    public const nint m_vMins = 0x548; // Vector
    public const nint m_vMaxs = 0x554; // Vector
    public const nint m_vDistanceMins = 0x560; // Vector
    public const nint m_vDistanceMaxs = 0x56C; // Vector
    public const nint m_flWindMin = 0x578; // float
    public const nint m_flWindMax = 0x57C; // float
    public const nint m_flWindMapMin = 0x580; // float
    public const nint m_flWindMapMax = 0x584; // float
}

public static class CSoundOpvarSetPathCornerEntity {
    public const nint m_flDistMinSqr = 0x660; // float
    public const nint m_flDistMaxSqr = 0x664; // float
    public const nint m_iszPathCornerEntityName = 0x668; // CUtlSymbolLarge
}

public static class CSoundOpvarSetPointBase {
    public const nint m_bDisabled = 0x4B0; // bool
    public const nint m_hSource = 0x4B4; // CEntityHandle
    public const nint m_iszSourceEntityName = 0x4C0; // CUtlSymbolLarge
    public const nint m_vLastPosition = 0x518; // Vector
    public const nint m_iszStackName = 0x528; // CUtlSymbolLarge
    public const nint m_iszOperatorName = 0x530; // CUtlSymbolLarge
    public const nint m_iszOpvarName = 0x538; // CUtlSymbolLarge
    public const nint m_iOpvarIndex = 0x540; // int32_t
    public const nint m_bUseAutoCompare = 0x544; // bool
}

public static class CSoundOpvarSetPointEntity {
    public const nint m_OnEnter = 0x548; // CEntityIOOutput
    public const nint m_OnExit = 0x570; // CEntityIOOutput
    public const nint m_bAutoDisable = 0x598; // bool
    public const nint m_flDistanceMin = 0x5DC; // float
    public const nint m_flDistanceMax = 0x5E0; // float
    public const nint m_flDistanceMapMin = 0x5E4; // float
    public const nint m_flDistanceMapMax = 0x5E8; // float
    public const nint m_flOcclusionRadius = 0x5EC; // float
    public const nint m_flOcclusionMin = 0x5F0; // float
    public const nint m_flOcclusionMax = 0x5F4; // float
    public const nint m_flValSetOnDisable = 0x5F8; // float
    public const nint m_bSetValueOnDisable = 0x5FC; // bool
    public const nint m_nSimulationMode = 0x600; // int32_t
    public const nint m_nVisibilitySamples = 0x604; // int32_t
    public const nint m_vDynamicProxyPoint = 0x608; // Vector
    public const nint m_flDynamicMaximumOcclusion = 0x614; // float
    public const nint m_hDynamicEntity = 0x618; // CEntityHandle
    public const nint m_iszDynamicEntityName = 0x620; // CUtlSymbolLarge
    public const nint m_flPathingDistanceNormFactor = 0x628; // float
    public const nint m_vPathingSourcePos = 0x62C; // Vector
    public const nint m_vPathingListenerPos = 0x638; // Vector
    public const nint m_nPathingSourceIndex = 0x644; // int32_t
}

public static class CSoundPatch {
    public const nint m_pitch = 0x8; // CSoundEnvelope
    public const nint m_volume = 0x18; // CSoundEnvelope
    public const nint m_shutdownTime = 0x30; // float
    public const nint m_flLastTime = 0x34; // float
    public const nint m_iszSoundScriptName = 0x38; // CUtlSymbolLarge
    public const nint m_hEnt = 0x40; // CHandle<CBaseEntity>
    public const nint m_soundEntityIndex = 0x44; // CEntityIndex
    public const nint m_soundOrigin = 0x48; // Vector
    public const nint m_isPlaying = 0x54; // int32_t
    public const nint m_Filter = 0x58; // CCopyRecipientFilter
    public const nint m_flCloseCaptionDuration = 0x80; // float
    public const nint m_bUpdatedSoundOrigin = 0x84; // bool
    public const nint m_iszClassName = 0x88; // CUtlSymbolLarge
}

public static class CSoundStackSave {
    public const nint m_iszStackName = 0x4B0; // CUtlSymbolLarge
}

public static class CSpotlightEnd {
    public const nint m_flLightScale = 0x700; // float
    public const nint m_Radius = 0x704; // float
    public const nint m_vSpotlightDir = 0x708; // Vector
    public const nint m_vSpotlightOrg = 0x714; // Vector
}

public static class CSprite {
    public const nint m_hSpriteMaterial = 0x700; // CStrongHandle<InfoForResourceTypeIMaterial2>
    public const nint m_hAttachedToEntity = 0x708; // CHandle<CBaseEntity>
    public const nint m_nAttachment = 0x70C; // AttachmentHandle_t
    public const nint m_flSpriteFramerate = 0x710; // float
    public const nint m_flFrame = 0x714; // float
    public const nint m_flDieTime = 0x718; // GameTime_t
    public const nint m_nBrightness = 0x728; // uint32_t
    public const nint m_flBrightnessDuration = 0x72C; // float
    public const nint m_flSpriteScale = 0x730; // float
    public const nint m_flScaleDuration = 0x734; // float
    public const nint m_bWorldSpaceScale = 0x738; // bool
    public const nint m_flGlowProxySize = 0x73C; // float
    public const nint m_flHDRColorScale = 0x740; // float
    public const nint m_flLastTime = 0x744; // GameTime_t
    public const nint m_flMaxFrame = 0x748; // float
    public const nint m_flStartScale = 0x74C; // float
    public const nint m_flDestScale = 0x750; // float
    public const nint m_flScaleTimeStart = 0x754; // GameTime_t
    public const nint m_nStartBrightness = 0x758; // int32_t
    public const nint m_nDestBrightness = 0x75C; // int32_t
    public const nint m_flBrightnessTimeStart = 0x760; // GameTime_t
    public const nint m_nSpriteWidth = 0x764; // int32_t
    public const nint m_nSpriteHeight = 0x768; // int32_t
}

public static class CStopwatch {
    public const nint m_interval = 0xC; // float
}

public static class CStopwatchBase {
    public const nint m_fIsRunning = 0x8; // bool
}

public static class CSun {
    public const nint m_vDirection = 0x700; // Vector
    public const nint m_clrOverlay = 0x70C; // Color
    public const nint m_iszEffectName = 0x710; // CUtlSymbolLarge
    public const nint m_iszSSEffectName = 0x718; // CUtlSymbolLarge
    public const nint m_bOn = 0x720; // bool
    public const nint m_bmaxColor = 0x721; // bool
    public const nint m_flSize = 0x724; // float
    public const nint m_flRotation = 0x728; // float
    public const nint m_flHazeScale = 0x72C; // float
    public const nint m_flAlphaHaze = 0x730; // float
    public const nint m_flAlphaHdr = 0x734; // float
    public const nint m_flAlphaScale = 0x738; // float
    public const nint m_flHDRColorScale = 0x73C; // float
    public const nint m_flFarZScale = 0x740; // float
}

public static class CTakeDamageInfo {
    public const nint m_vecDamageForce = 0x8; // Vector
    public const nint m_vecDamagePosition = 0x14; // Vector
    public const nint m_vecReportedPosition = 0x20; // Vector
    public const nint m_vecDamageDirection = 0x2C; // Vector
    public const nint m_hInflictor = 0x38; // CHandle<CBaseEntity>
    public const nint m_hAttacker = 0x3C; // CHandle<CBaseEntity>
    public const nint m_hAbility = 0x40; // CHandle<CBaseEntity>
    public const nint m_flDamage = 0x44; // float
    public const nint m_bitsDamageType = 0x48; // int32_t
    public const nint m_iDamageCustom = 0x4C; // int32_t
    public const nint m_iAmmoType = 0x50; // AmmoIndex_t
    public const nint m_flOriginalDamage = 0x60; // float
    public const nint m_bShouldBleed = 0x64; // bool
    public const nint m_bShouldSpark = 0x65; // bool
    public const nint m_nDamageFlags = 0x70; // TakeDamageFlags_t
    public const nint m_nNumObjectsPenetrated = 0x74; // int32_t
    public const nint m_hScriptInstance = 0x78; // HSCRIPT
    public const nint m_bInTakeDamageFlow = 0x94; // bool
}

public static class CTakeDamageResult {
    public const nint m_nHealthLost = 0x0; // int32_t
    public const nint m_nDamageTaken = 0x4; // int32_t
}

public static class CTakeDamageSummaryScopeGuard {
    public const nint m_vecSummaries = 0x8; // CUtlVector<SummaryTakeDamageInfo_t*>
}

public static class CTankTargetChange {
    public const nint m_newTarget = 0x4B0; // CVariantBase<CVariantDefaultAllocator>
    public const nint m_newTargetName = 0x4C0; // CUtlSymbolLarge
}

public static class CTankTrainAI {
    public const nint m_hTrain = 0x4B0; // CHandle<CFuncTrackTrain>
    public const nint m_hTargetEntity = 0x4B4; // CHandle<CBaseEntity>
    public const nint m_soundPlaying = 0x4B8; // int32_t
    public const nint m_startSoundName = 0x4D0; // CUtlSymbolLarge
    public const nint m_engineSoundName = 0x4D8; // CUtlSymbolLarge
    public const nint m_movementSoundName = 0x4E0; // CUtlSymbolLarge
    public const nint m_targetEntityName = 0x4E8; // CUtlSymbolLarge
}

public static class CTeam {
    public const nint m_aPlayerControllers = 0x4B0; // CNetworkUtlVectorBase<CHandle<CBasePlayerController>>
    public const nint m_aPlayers = 0x4C8; // CNetworkUtlVectorBase<CHandle<CBasePlayerPawn>>
    public const nint m_iScore = 0x4E0; // int32_t
    public const nint m_szTeamname = 0x4E4; // char[129]
}

public static class CTestEffect {
    public const nint m_iLoop = 0x4B0; // int32_t
    public const nint m_iBeam = 0x4B4; // int32_t
    public const nint m_pBeam = 0x4B8; // CBeam*[24]
    public const nint m_flBeamTime = 0x578; // GameTime_t[24]
    public const nint m_flStartTime = 0x5D8; // GameTime_t
}

public static class CTextureBasedAnimatable {
    public const nint m_bLoop = 0x700; // bool
    public const nint m_flFPS = 0x704; // float
    public const nint m_hPositionKeys = 0x708; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_hRotationKeys = 0x710; // CStrongHandle<InfoForResourceTypeCTextureBase>
    public const nint m_vAnimationBoundsMin = 0x718; // Vector
    public const nint m_vAnimationBoundsMax = 0x724; // Vector
    public const nint m_flStartTime = 0x730; // float
    public const nint m_flStartFrame = 0x734; // float
}

public static class CTimeline {
    public const nint m_flValues = 0x10; // float[64]
    public const nint m_nValueCounts = 0x110; // int32_t[64]
    public const nint m_nBucketCount = 0x210; // int32_t
    public const nint m_flInterval = 0x214; // float
    public const nint m_flFinalValue = 0x218; // float
    public const nint m_nCompressionType = 0x21C; // TimelineCompression_t
    public const nint m_bStopped = 0x220; // bool
}

public static class CTimerEntity {
    public const nint m_OnTimer = 0x4B0; // CEntityIOOutput
    public const nint m_OnTimerHigh = 0x4D8; // CEntityIOOutput
    public const nint m_OnTimerLow = 0x500; // CEntityIOOutput
    public const nint m_iDisabled = 0x528; // int32_t
    public const nint m_flInitialDelay = 0x52C; // float
    public const nint m_flRefireTime = 0x530; // float
    public const nint m_bUpDownState = 0x534; // bool
    public const nint m_iUseRandomTime = 0x538; // int32_t
    public const nint m_bPauseAfterFiring = 0x53C; // bool
    public const nint m_flLowerRandomBound = 0x540; // float
    public const nint m_flUpperRandomBound = 0x544; // float
    public const nint m_flRemainingTime = 0x548; // float
    public const nint m_bPaused = 0x54C; // bool
}

public static class CTonemapController2 {
    public const nint m_flAutoExposureMin = 0x4B0; // float
    public const nint m_flAutoExposureMax = 0x4B4; // float
    public const nint m_flTonemapPercentTarget = 0x4B8; // float
    public const nint m_flTonemapPercentBrightPixels = 0x4BC; // float
    public const nint m_flTonemapMinAvgLum = 0x4C0; // float
    public const nint m_flExposureAdaptationSpeedUp = 0x4C4; // float
    public const nint m_flExposureAdaptationSpeedDown = 0x4C8; // float
    public const nint m_flTonemapEVSmoothingRange = 0x4CC; // float
}

public static class CTonemapTrigger {
    public const nint m_tonemapControllerName = 0x8A8; // CUtlSymbolLarge
    public const nint m_hTonemapController = 0x8B0; // CEntityHandle
}

public static class CTriggerActiveWeaponDetect {
    public const nint m_OnTouchedActiveWeapon = 0x8A8; // CEntityIOOutput
    public const nint m_iszWeaponClassName = 0x8D0; // CUtlSymbolLarge
}

public static class CTriggerBrush {
    public const nint m_OnStartTouch = 0x700; // CEntityIOOutput
    public const nint m_OnEndTouch = 0x728; // CEntityIOOutput
    public const nint m_OnUse = 0x750; // CEntityIOOutput
    public const nint m_iInputFilter = 0x778; // int32_t
    public const nint m_iDontMessageParent = 0x77C; // int32_t
}

public static class CTriggerBuoyancy {
    public const nint m_BuoyancyHelper = 0x8A8; // CBuoyancyHelper
    public const nint m_flFluidDensity = 0x8C8; // float
}

public static class CTriggerDetectBulletFire {
    public const nint m_bPlayerFireOnly = 0x8A8; // bool
    public const nint m_OnDetectedBulletFire = 0x8B0; // CEntityIOOutput
}

public static class CTriggerDetectExplosion {
    public const nint m_OnDetectedExplosion = 0x8E0; // CEntityIOOutput
}

public static class CTriggerFan {
    public const nint m_vFanOrigin = 0x8A8; // Vector
    public const nint m_vFanEnd = 0x8B4; // Vector
    public const nint m_vNoise = 0x8C0; // Vector
    public const nint m_flForce = 0x8CC; // float
    public const nint m_flPlayerForce = 0x8D0; // float
    public const nint m_flRampTime = 0x8D4; // float
    public const nint m_bFalloff = 0x8D8; // bool
    public const nint m_bPushPlayer = 0x8D9; // bool
    public const nint m_bRampDown = 0x8DA; // bool
    public const nint m_bAddNoise = 0x8DB; // bool
    public const nint m_RampTimer = 0x8E0; // CountdownTimer
}

public static class CTriggerGameEvent {
    public const nint m_strStartTouchEventName = 0x8A8; // CUtlString
    public const nint m_strEndTouchEventName = 0x8B0; // CUtlString
    public const nint m_strTriggerID = 0x8B8; // CUtlString
}

public static class CTriggerHurt {
    public const nint m_flOriginalDamage = 0x8A8; // float
    public const nint m_flDamage = 0x8AC; // float
    public const nint m_flDamageCap = 0x8B0; // float
    public const nint m_flLastDmgTime = 0x8B4; // GameTime_t
    public const nint m_flForgivenessDelay = 0x8B8; // float
    public const nint m_bitsDamageInflict = 0x8BC; // int32_t
    public const nint m_damageModel = 0x8C0; // int32_t
    public const nint m_bNoDmgForce = 0x8C4; // bool
    public const nint m_vDamageForce = 0x8C8; // Vector
    public const nint m_thinkAlways = 0x8D4; // bool
    public const nint m_hurtThinkPeriod = 0x8D8; // float
    public const nint m_OnHurt = 0x8E0; // CEntityIOOutput
    public const nint m_OnHurtPlayer = 0x908; // CEntityIOOutput
    public const nint m_hurtEntities = 0x930; // CUtlVector<CHandle<CBaseEntity>>
}

public static class CTriggerImpact {
    public const nint m_flMagnitude = 0x8D0; // float
    public const nint m_flNoise = 0x8D4; // float
    public const nint m_flViewkick = 0x8D8; // float
    public const nint m_pOutputForce = 0x8E0; // CEntityOutputTemplate<Vector>
}

public static class CTriggerLerpObject {
    public const nint m_iszLerpTarget = 0x8A8; // CUtlSymbolLarge
    public const nint m_hLerpTarget = 0x8B0; // CHandle<CBaseEntity>
    public const nint m_iszLerpTargetAttachment = 0x8B8; // CUtlSymbolLarge
    public const nint m_hLerpTargetAttachment = 0x8C0; // AttachmentHandle_t
    public const nint m_flLerpDuration = 0x8C4; // float
    public const nint m_bLerpRestoreMoveType = 0x8C8; // bool
    public const nint m_bSingleLerpObject = 0x8C9; // bool
    public const nint m_vecLerpingObjects = 0x8D0; // CUtlVector<lerpdata_t>
    public const nint m_iszLerpEffect = 0x8E8; // CUtlSymbolLarge
    public const nint m_iszLerpSound = 0x8F0; // CUtlSymbolLarge
    public const nint m_OnLerpStarted = 0x8F8; // CEntityIOOutput
    public const nint m_OnLerpFinished = 0x920; // CEntityIOOutput
}

public static class CTriggerLook {
    public const nint m_hLookTarget = 0x8D0; // CHandle<CBaseEntity>
    public const nint m_flFieldOfView = 0x8D4; // float
    public const nint m_flLookTime = 0x8D8; // float
    public const nint m_flLookTimeTotal = 0x8DC; // float
    public const nint m_flLookTimeLast = 0x8E0; // GameTime_t
    public const nint m_flTimeoutDuration = 0x8E4; // float
    public const nint m_bTimeoutFired = 0x8E8; // bool
    public const nint m_bIsLooking = 0x8E9; // bool
    public const nint m_b2DFOV = 0x8EA; // bool
    public const nint m_bUseVelocity = 0x8EB; // bool
    public const nint m_hActivator = 0x8EC; // CHandle<CBaseEntity>
    public const nint m_bTestOcclusion = 0x8F0; // bool
    public const nint m_OnTimeout = 0x8F8; // CEntityIOOutput
    public const nint m_OnStartLook = 0x920; // CEntityIOOutput
    public const nint m_OnEndLook = 0x948; // CEntityIOOutput
}

public static class CTriggerMultiple {
    public const nint m_OnTrigger = 0x8A8; // CEntityIOOutput
}

public static class CTriggerPhysics {
    public const nint m_gravityScale = 0x8B8; // float
    public const nint m_linearLimit = 0x8BC; // float
    public const nint m_linearDamping = 0x8C0; // float
    public const nint m_angularLimit = 0x8C4; // float
    public const nint m_angularDamping = 0x8C8; // float
    public const nint m_linearForce = 0x8CC; // float
    public const nint m_flFrequency = 0x8D0; // float
    public const nint m_flDampingRatio = 0x8D4; // float
    public const nint m_vecLinearForcePointAt = 0x8D8; // Vector
    public const nint m_bCollapseToForcePoint = 0x8E4; // bool
    public const nint m_vecLinearForcePointAtWorld = 0x8E8; // Vector
    public const nint m_vecLinearForceDirection = 0x8F4; // Vector
    public const nint m_bConvertToDebrisWhenPossible = 0x900; // bool
}

public static class CTriggerProximity {
    public const nint m_hMeasureTarget = 0x8A8; // CHandle<CBaseEntity>
    public const nint m_iszMeasureTarget = 0x8B0; // CUtlSymbolLarge
    public const nint m_fRadius = 0x8B8; // float
    public const nint m_nTouchers = 0x8BC; // int32_t
    public const nint m_NearestEntityDistance = 0x8C0; // CEntityOutputTemplate<float>
}

public static class CTriggerPush {
    public const nint m_angPushEntitySpace = 0x8A8; // QAngle
    public const nint m_vecPushDirEntitySpace = 0x8B4; // Vector
    public const nint m_bTriggerOnStartTouch = 0x8C0; // bool
    public const nint m_flAlternateTicksFix = 0x8C4; // float
    public const nint m_flPushSpeed = 0x8C8; // float
}

public static class CTriggerRemove {
    public const nint m_OnRemove = 0x8A8; // CEntityIOOutput
}

public static class CTriggerSave {
    public const nint m_bForceNewLevelUnit = 0x8A8; // bool
    public const nint m_fDangerousTimer = 0x8AC; // float
    public const nint m_minHitPoints = 0x8B0; // int32_t
}

public static class CTriggerSndSosOpvar {
    public const nint m_hTouchingPlayers = 0x8A8; // CUtlVector<CHandle<CBaseEntity>>
    public const nint m_flPosition = 0x8C0; // Vector
    public const nint m_flCenterSize = 0x8CC; // float
    public const nint m_flMinVal = 0x8D0; // float
    public const nint m_flMaxVal = 0x8D4; // float
    public const nint m_flWait = 0x8D8; // float
    public const nint m_opvarName = 0x8E0; // CUtlSymbolLarge
    public const nint m_stackName = 0x8E8; // CUtlSymbolLarge
    public const nint m_operatorName = 0x8F0; // CUtlSymbolLarge
    public const nint m_bVolIs2D = 0x8F8; // bool
    public const nint m_opvarNameChar = 0x8F9; // char[256]
    public const nint m_stackNameChar = 0x9F9; // char[256]
    public const nint m_operatorNameChar = 0xAF9; // char[256]
    public const nint m_VecNormPos = 0xBFC; // Vector
    public const nint m_flNormCenterSize = 0xC08; // float
}

public static class CTriggerSoundscape {
    public const nint m_hSoundscape = 0x8A8; // CHandle<CEnvSoundscapeTriggerable>
    public const nint m_SoundscapeName = 0x8B0; // CUtlSymbolLarge
    public const nint m_spectators = 0x8B8; // CUtlVector<CHandle<CBasePlayerPawn>>
}

public static class CTriggerTeleport {
    public const nint m_iLandmark = 0x8A8; // CUtlSymbolLarge
    public const nint m_bUseLandmarkAngles = 0x8B0; // bool
    public const nint m_bMirrorPlayer = 0x8B1; // bool
}

public static class CTriggerToggleSave {
    public const nint m_bDisabled = 0x8A8; // bool
}

public static class CTriggerVolume {
    public const nint m_iFilterName = 0x700; // CUtlSymbolLarge
    public const nint m_hFilter = 0x708; // CHandle<CBaseFilter>
}

public static class CVoteController {
    public const nint m_iActiveIssueIndex = 0x4B0; // int32_t
    public const nint m_iOnlyTeamToVote = 0x4B4; // int32_t
    public const nint m_nVoteOptionCount = 0x4B8; // int32_t[5]
    public const nint m_nPotentialVotes = 0x4CC; // int32_t
    public const nint m_bIsYesNoVote = 0x4D0; // bool
    public const nint m_acceptingVotesTimer = 0x4D8; // CountdownTimer
    public const nint m_executeCommandTimer = 0x4F0; // CountdownTimer
    public const nint m_resetVoteTimer = 0x508; // CountdownTimer
    public const nint m_nVotesCast = 0x520; // int32_t[64]
    public const nint m_playerHoldingVote = 0x620; // CPlayerSlot
    public const nint m_playerOverrideForVote = 0x624; // CPlayerSlot
    public const nint m_nHighestCountIndex = 0x628; // int32_t
    public const nint m_potentialIssues = 0x630; // CUtlVector<CBaseIssue*>
    public const nint m_VoteOptions = 0x648; // CUtlVector<char*>
}

public static class CWeaponBaseItem {
    public const nint m_SequenceCompleteTimer = 0xE20; // CountdownTimer
    public const nint m_bRedraw = 0xE38; // bool
}

public static class CWeaponShield {
    public const nint m_flBulletDamageAbsorbed = 0xE40; // float
    public const nint m_flLastBulletHitSoundTime = 0xE44; // GameTime_t
    public const nint m_flDisplayHealth = 0xE48; // float
}

public static class CWeaponTaser {
    public const nint m_fFireTime = 0xE40; // GameTime_t
}

public static class CommandToolCommand_t {
    public const nint m_bEnabled = 0x0; // bool
    public const nint m_bOpened = 0x1; // bool
    public const nint m_InternalId = 0x4; // uint32_t
    public const nint m_ShortName = 0x8; // CUtlString
    public const nint m_ExecMode = 0x10; // CommandExecMode_t
    public const nint m_SpawnGroup = 0x18; // CUtlString
    public const nint m_PeriodicExecDelay = 0x20; // float
    public const nint m_SpecType = 0x24; // CommandEntitySpecType_t
    public const nint m_EntitySpec = 0x28; // CUtlString
    public const nint m_Commands = 0x30; // CUtlString
    public const nint m_SetDebugBits = 0x38; // DebugOverlayBits_t
    public const nint m_ClearDebugBits = 0x40; // DebugOverlayBits_t
}

public static class ConceptHistory_t {
    public const nint timeSpoken = 0x0; // float
    public const nint m_response = 0x8; // CRR_Response
}

public static class ConstraintSoundInfo {
    public const nint m_vSampler = 0x8; // VelocitySampler
    public const nint m_soundProfile = 0x20; // SimpleConstraintSoundProfile
    public const nint m_forwardAxis = 0x40; // Vector
    public const nint m_iszTravelSoundFwd = 0x50; // CUtlSymbolLarge
    public const nint m_iszTravelSoundBack = 0x58; // CUtlSymbolLarge
    public const nint m_iszReversalSounds = 0x68; // CUtlSymbolLarge[3]
    public const nint m_bPlayTravelSound = 0x80; // bool
    public const nint m_bPlayReversalSound = 0x81; // bool
}

public static class CountdownTimer {
    public const nint m_duration = 0x8; // float
    public const nint m_timestamp = 0xC; // GameTime_t
    public const nint m_timescale = 0x10; // float
    public const nint m_nWorldGroupId = 0x14; // WorldGroupId_t
}

public static class EngineCountdownTimer {
    public const nint m_duration = 0x8; // float
    public const nint m_timestamp = 0xC; // float
    public const nint m_timescale = 0x10; // float
}

public static class EntityRenderAttribute_t {
    public const nint m_ID = 0x30; // CUtlStringToken
    public const nint m_Values = 0x34; // Vector4D
}

public static class EntitySpottedState_t {
    public const nint m_bSpotted = 0x8; // bool
    public const nint m_bSpottedByMask = 0xC; // uint32_t[2]
}

public static class Extent {
    public const nint lo = 0x0; // Vector
    public const nint hi = 0xC; // Vector
}

public static class FilterDamageType {
    public const nint m_iDamageType = 0x508; // int32_t
}

public static class FilterHealth {
    public const nint m_bAdrenalineActive = 0x508; // bool
    public const nint m_iHealthMin = 0x50C; // int32_t
    public const nint m_iHealthMax = 0x510; // int32_t
}

public static class FilterTeam {
    public const nint m_iFilterTeam = 0x508; // int32_t
}

public static class GameAmmoTypeInfo_t {
    public const nint m_nBuySize = 0x38; // int32_t
    public const nint m_nCost = 0x3C; // int32_t
}

public static class GameTick_t {
    public const nint m_Value = 0x0; // int32_t
}

public static class GameTime_t {
    public const nint m_Value = 0x0; // float
}

public static class HullFlags_t {
    public const nint m_bHull_Human = 0x0; // bool
    public const nint m_bHull_SmallCentered = 0x1; // bool
    public const nint m_bHull_WideHuman = 0x2; // bool
    public const nint m_bHull_Tiny = 0x3; // bool
    public const nint m_bHull_Medium = 0x4; // bool
    public const nint m_bHull_TinyCentered = 0x5; // bool
    public const nint m_bHull_Large = 0x6; // bool
    public const nint m_bHull_LargeCentered = 0x7; // bool
    public const nint m_bHull_MediumTall = 0x8; // bool
    public const nint m_bHull_Small = 0x9; // bool
}

public static class IntervalTimer {
    public const nint m_timestamp = 0x8; // GameTime_t
    public const nint m_nWorldGroupId = 0xC; // WorldGroupId_t
}

public static class ModelConfigHandle_t {
    public const nint m_Value = 0x0; // uint32_t
}

public static class ParticleIndex_t {
    public const nint m_Value = 0x0; // int32_t
}

public static class PhysicsRagdollPose_t {
    public const nint __m_pChainEntity = 0x8; // CNetworkVarChainer
    public const nint m_Transforms = 0x30; // CNetworkUtlVectorBase<CTransform>
    public const nint m_hOwner = 0x48; // CHandle<CBaseEntity>
}

public static class RagdollCreationParams_t {
    public const nint m_vForce = 0x0; // Vector
    public const nint m_nForceBone = 0xC; // int32_t
}

public static class RelationshipOverride_t {
    public const nint entity = 0x8; // CHandle<CBaseEntity>
    public const nint classType = 0xC; // Class_T
}

public static class Relationship_t {
    public const nint disposition = 0x0; // Disposition_t
    public const nint priority = 0x4; // int32_t
}

public static class ResponseContext_t {
    public const nint m_iszName = 0x0; // CUtlSymbolLarge
    public const nint m_iszValue = 0x8; // CUtlSymbolLarge
    public const nint m_fExpirationTime = 0x10; // GameTime_t
}

public static class ResponseFollowup {
    public const nint followup_concept = 0x0; // char*
    public const nint followup_contexts = 0x8; // char*
    public const nint followup_delay = 0x10; // float
    public const nint followup_target = 0x14; // char*
    public const nint followup_entityiotarget = 0x1C; // char*
    public const nint followup_entityioinput = 0x24; // char*
    public const nint followup_entityiodelay = 0x2C; // float
    public const nint bFired = 0x30; // bool
}

public static class ResponseParams {
    public const nint odds = 0x10; // int16_t
    public const nint flags = 0x12; // int16_t
    public const nint m_pFollowup = 0x18; // ResponseFollowup*
}

public static class SellbackPurchaseEntry_t {
    public const nint m_unDefIdx = 0x30; // uint16_t
    public const nint m_nCost = 0x34; // int32_t
    public const nint m_nPrevArmor = 0x38; // int32_t
    public const nint m_bPrevHelmet = 0x3C; // bool
    public const nint m_hItem = 0x40; // CEntityHandle
}

public static class ServerAuthoritativeWeaponSlot_t {
    public const nint unClass = 0x28; // uint16_t
    public const nint unSlot = 0x2A; // uint16_t
    public const nint unItemDefIdx = 0x2C; // uint16_t
}

public static class SimpleConstraintSoundProfile {
    public const nint eKeypoints = 0x8; // SimpleConstraintSoundProfile::SimpleConstraintsSoundProfileKeypoints_t
    public const nint m_keyPoints = 0xC; // float[2]
    public const nint m_reversalSoundThresholds = 0x14; // float[3]
}

public static class SpawnPoint {
    public const nint m_iPriority = 0x4B0; // int32_t
    public const nint m_bEnabled = 0x4B4; // bool
    public const nint m_nType = 0x4B8; // int32_t
}

public static class SpawnPointCoopEnemy {
    public const nint m_szWeaponsToGive = 0x4C0; // CUtlSymbolLarge
    public const nint m_szPlayerModelToUse = 0x4C8; // CUtlSymbolLarge
    public const nint m_nArmorToSpawnWith = 0x4D0; // int32_t
    public const nint m_nDefaultBehavior = 0x4D4; // SpawnPointCoopEnemy::BotDefaultBehavior_t
    public const nint m_nBotDifficulty = 0x4D8; // int32_t
    public const nint m_bIsAgressive = 0x4DC; // bool
    public const nint m_bStartAsleep = 0x4DD; // bool
    public const nint m_flHideRadius = 0x4E0; // float
    public const nint m_szBehaviorTreeFile = 0x4F0; // CUtlSymbolLarge
}

public static class SummaryTakeDamageInfo_t {
    public const nint nSummarisedCount = 0x0; // int32_t
    public const nint info = 0x8; // CTakeDamageInfo
    public const nint result = 0xA0; // CTakeDamageResult
    public const nint hTarget = 0xA8; // CHandle<CBaseEntity>
}

public static class VPhysicsCollisionAttribute_t {
    public const nint m_nInteractsAs = 0x8; // uint64_t
    public const nint m_nInteractsWith = 0x10; // uint64_t
    public const nint m_nInteractsExclude = 0x18; // uint64_t
    public const nint m_nEntityId = 0x20; // uint32_t
    public const nint m_nOwnerId = 0x24; // uint32_t
    public const nint m_nHierarchyId = 0x28; // uint16_t
    public const nint m_nCollisionGroup = 0x2A; // uint8_t
    public const nint m_nCollisionFunctionMask = 0x2B; // uint8_t
}

public static class VelocitySampler {
    public const nint m_prevSample = 0x0; // Vector
    public const nint m_fPrevSampleTime = 0xC; // GameTime_t
    public const nint m_fIdealSampleRate = 0x10; // float
}

public static class ViewAngleServerChange_t {
    public const nint nType = 0x30; // FixAngleSet_t
    public const nint qAngle = 0x34; // QAngle
    public const nint nIndex = 0x40; // uint32_t
}

public static class WeaponPurchaseCount_t {
    public const nint m_nItemDefIndex = 0x30; // uint16_t
    public const nint m_nCount = 0x32; // uint16_t
}

public static class WeaponPurchaseTracker_t {
    public const nint m_weaponPurchases = 0x8; // CUtlVectorEmbeddedNetworkVar<WeaponPurchaseCount_t>
}

public static class audioparams_t {
    public const nint localSound = 0x8; // Vector[8]
    public const nint soundscapeIndex = 0x68; // int32_t
    public const nint localBits = 0x6C; // uint8_t
    public const nint soundscapeEntityListIndex = 0x70; // int32_t
    public const nint soundEventHash = 0x74; // uint32_t
}

public static class dynpitchvol_base_t {
    public const nint preset = 0x0; // int32_t
    public const nint pitchrun = 0x4; // int32_t
    public const nint pitchstart = 0x8; // int32_t
    public const nint spinup = 0xC; // int32_t
    public const nint spindown = 0x10; // int32_t
    public const nint volrun = 0x14; // int32_t
    public const nint volstart = 0x18; // int32_t
    public const nint fadein = 0x1C; // int32_t
    public const nint fadeout = 0x20; // int32_t
    public const nint lfotype = 0x24; // int32_t
    public const nint lforate = 0x28; // int32_t
    public const nint lfomodpitch = 0x2C; // int32_t
    public const nint lfomodvol = 0x30; // int32_t
    public const nint cspinup = 0x34; // int32_t
    public const nint cspincount = 0x38; // int32_t
    public const nint pitch = 0x3C; // int32_t
    public const nint spinupsav = 0x40; // int32_t
    public const nint spindownsav = 0x44; // int32_t
    public const nint pitchfrac = 0x48; // int32_t
    public const nint vol = 0x4C; // int32_t
    public const nint fadeinsav = 0x50; // int32_t
    public const nint fadeoutsav = 0x54; // int32_t
    public const nint volfrac = 0x58; // int32_t
    public const nint lfofrac = 0x5C; // int32_t
    public const nint lfomult = 0x60; // int32_t
}

public static class fogparams_t {
    public const nint dirPrimary = 0x8; // Vector
    public const nint colorPrimary = 0x14; // Color
    public const nint colorSecondary = 0x18; // Color
    public const nint colorPrimaryLerpTo = 0x1C; // Color
    public const nint colorSecondaryLerpTo = 0x20; // Color
    public const nint start = 0x24; // float
    public const nint end = 0x28; // float
    public const nint farz = 0x2C; // float
    public const nint maxdensity = 0x30; // float
    public const nint exponent = 0x34; // float
    public const nint HDRColorScale = 0x38; // float
    public const nint skyboxFogFactor = 0x3C; // float
    public const nint skyboxFogFactorLerpTo = 0x40; // float
    public const nint startLerpTo = 0x44; // float
    public const nint endLerpTo = 0x48; // float
    public const nint maxdensityLerpTo = 0x4C; // float
    public const nint lerptime = 0x50; // GameTime_t
    public const nint duration = 0x54; // float
    public const nint blendtobackground = 0x58; // float
    public const nint scattering = 0x5C; // float
    public const nint locallightscale = 0x60; // float
    public const nint enable = 0x64; // bool
    public const nint blend = 0x65; // bool
    public const nint m_bNoReflectionFog = 0x66; // bool
    public const nint m_bPadding = 0x67; // bool
}

public static class fogplayerparams_t {
    public const nint m_hCtrl = 0x8; // CHandle<CFogController>
    public const nint m_flTransitionTime = 0xC; // float
    public const nint m_OldColor = 0x10; // Color
    public const nint m_flOldStart = 0x14; // float
    public const nint m_flOldEnd = 0x18; // float
    public const nint m_flOldMaxDensity = 0x1C; // float
    public const nint m_flOldHDRColorScale = 0x20; // float
    public const nint m_flOldFarZ = 0x24; // float
    public const nint m_NewColor = 0x28; // Color
    public const nint m_flNewStart = 0x2C; // float
    public const nint m_flNewEnd = 0x30; // float
    public const nint m_flNewMaxDensity = 0x34; // float
    public const nint m_flNewHDRColorScale = 0x38; // float
    public const nint m_flNewFarZ = 0x3C; // float
}

public static class hudtextparms_t {
    public const nint color1 = 0x0; // Color
    public const nint color2 = 0x4; // Color
    public const nint effect = 0x8; // uint8_t
    public const nint channel = 0x9; // uint8_t
    public const nint x = 0xC; // float
    public const nint y = 0x10; // float
}

public static class lerpdata_t {
    public const nint m_hEnt = 0x0; // CHandle<CBaseEntity>
    public const nint m_MoveType = 0x4; // MoveType_t
    public const nint m_flStartTime = 0x8; // GameTime_t
    public const nint m_vecStartOrigin = 0xC; // Vector
    public const nint m_qStartRot = 0x20; // Quaternion
    public const nint m_nFXIndex = 0x30; // ParticleIndex_t
}

public static class locksound_t {
    public const nint sLockedSound = 0x8; // CUtlSymbolLarge
    public const nint sUnlockedSound = 0x10; // CUtlSymbolLarge
    public const nint flwaitSound = 0x18; // GameTime_t
}

public static class magnetted_objects_t {
    public const nint hEntity = 0x8; // CHandle<CBaseEntity>
}

public static class ragdoll_t {
    public const nint list = 0x0; // CUtlVector<ragdollelement_t>
    public const nint boneIndex = 0x18; // CUtlVector<int32_t>
    public const nint allowStretch = 0x30; // bool
    public const nint unused = 0x31; // bool
}

public static class ragdollelement_t {
    public const nint originParentSpace = 0x0; // Vector
    public const nint parentIndex = 0x20; // int32_t
    public const nint m_flRadius = 0x24; // float
}

public static class shard_model_desc_t {
    public const nint m_nModelID = 0x8; // int32_t
    public const nint m_hMaterial = 0x10; // CStrongHandle<InfoForResourceTypeIMaterial2>
    public const nint m_solid = 0x18; // ShardSolid_t
    public const nint m_ShatterPanelMode = 0x19; // ShatterPanelMode
    public const nint m_vecPanelSize = 0x1C; // Vector2D
    public const nint m_vecStressPositionA = 0x24; // Vector2D
    public const nint m_vecStressPositionB = 0x2C; // Vector2D
    public const nint m_vecPanelVertices = 0x38; // CNetworkUtlVectorBase<Vector2D>
    public const nint m_flGlassHalfThickness = 0x50; // float
    public const nint m_bHasParent = 0x54; // bool
    public const nint m_bParentFrozen = 0x55; // bool
    public const nint m_SurfacePropStringToken = 0x58; // CUtlStringToken
}

public static class sky3dparams_t {
    public const nint scale = 0x8; // int16_t
    public const nint origin = 0xC; // Vector
    public const nint bClip3DSkyBoxNearToWorldFar = 0x18; // bool
    public const nint flClip3DSkyBoxNearToWorldFarOffset = 0x1C; // float
    public const nint fog = 0x20; // fogparams_t
    public const nint m_nWorldGroupID = 0x88; // WorldGroupId_t
}

public static class thinkfunc_t {
    public const nint m_hFn = 0x8; // HSCRIPT
    public const nint m_nContext = 0x10; // CUtlStringToken
    public const nint m_nNextThinkTick = 0x14; // GameTick_t
    public const nint m_nLastThinkTick = 0x18; // GameTick_t
}
```

`SDK/server.dll.hpp`:

```hpp
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:26.283184900 UTC
 */

#pragma once

#include <cstddef>

namespace ActiveModelConfig_t {
    constexpr std::ptrdiff_t m_Handle = 0x28; // ModelConfigHandle_t
    constexpr std::ptrdiff_t m_Name = 0x30; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_AssociatedEntities = 0x38; // CNetworkUtlVectorBase<CHandle<CBaseModelEntity>>
    constexpr std::ptrdiff_t m_AssociatedEntityNames = 0x50; // CNetworkUtlVectorBase<CUtlSymbolLarge>
}

namespace AmmoIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int8_t
}

namespace AmmoTypeInfo_t {
    constexpr std::ptrdiff_t m_nMaxCarry = 0x10; // int32_t
    constexpr std::ptrdiff_t m_nSplashSize = 0x1C; // CRangeInt
    constexpr std::ptrdiff_t m_nFlags = 0x24; // AmmoFlags_t
    constexpr std::ptrdiff_t m_flMass = 0x28; // float
    constexpr std::ptrdiff_t m_flSpeed = 0x2C; // CRangeFloat
}

namespace AnimationUpdateListHandle_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // uint32_t
}

namespace CAISound {
    constexpr std::ptrdiff_t m_iSoundType = 0x4B0; // int32_t
    constexpr std::ptrdiff_t m_iSoundContext = 0x4B4; // int32_t
    constexpr std::ptrdiff_t m_iVolume = 0x4B8; // int32_t
    constexpr std::ptrdiff_t m_iSoundIndex = 0x4BC; // int32_t
    constexpr std::ptrdiff_t m_flDuration = 0x4C0; // float
    constexpr std::ptrdiff_t m_iszProxyEntityName = 0x4C8; // CUtlSymbolLarge
}

namespace CAI_ChangeHintGroup {
    constexpr std::ptrdiff_t m_iSearchType = 0x4B0; // int32_t
    constexpr std::ptrdiff_t m_strSearchName = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_strNewHintGroup = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flRadius = 0x4C8; // float
}

namespace CAI_ChangeTarget {
    constexpr std::ptrdiff_t m_iszNewTarget = 0x4B0; // CUtlSymbolLarge
}

namespace CAI_Expresser {
    constexpr std::ptrdiff_t m_flStopTalkTime = 0x38; // GameTime_t
    constexpr std::ptrdiff_t m_flStopTalkTimeWithoutDelay = 0x3C; // GameTime_t
    constexpr std::ptrdiff_t m_flBlockedTalkTime = 0x40; // GameTime_t
    constexpr std::ptrdiff_t m_voicePitch = 0x44; // int32_t
    constexpr std::ptrdiff_t m_flLastTimeAcceptedSpeak = 0x48; // GameTime_t
    constexpr std::ptrdiff_t m_bAllowSpeakingInterrupts = 0x4C; // bool
    constexpr std::ptrdiff_t m_bConsiderSceneInvolvementAsSpeech = 0x4D; // bool
    constexpr std::ptrdiff_t m_nLastSpokenPriority = 0x50; // int32_t
    constexpr std::ptrdiff_t m_pOuter = 0x58; // CBaseFlex*
}

namespace CAI_ExpresserWithFollowup {
    constexpr std::ptrdiff_t m_pPostponedFollowup = 0x60; // ResponseFollowup*
}

namespace CAmbientGeneric {
    constexpr std::ptrdiff_t m_radius = 0x4B0; // float
    constexpr std::ptrdiff_t m_flMaxRadius = 0x4B4; // float
    constexpr std::ptrdiff_t m_iSoundLevel = 0x4B8; // soundlevel_t
    constexpr std::ptrdiff_t m_dpv = 0x4BC; // dynpitchvol_t
    constexpr std::ptrdiff_t m_fActive = 0x520; // bool
    constexpr std::ptrdiff_t m_fLooping = 0x521; // bool
    constexpr std::ptrdiff_t m_iszSound = 0x528; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_sSourceEntName = 0x530; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hSoundSource = 0x538; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_nSoundSourceEntIndex = 0x53C; // CEntityIndex
}

namespace CAnimGraphNetworkedVariables {
    constexpr std::ptrdiff_t m_PredNetBoolVariables = 0x8; // CNetworkUtlVectorBase<uint32_t>
    constexpr std::ptrdiff_t m_PredNetByteVariables = 0x20; // CNetworkUtlVectorBase<uint8_t>
    constexpr std::ptrdiff_t m_PredNetUInt16Variables = 0x38; // CNetworkUtlVectorBase<uint16_t>
    constexpr std::ptrdiff_t m_PredNetIntVariables = 0x50; // CNetworkUtlVectorBase<int32_t>
    constexpr std::ptrdiff_t m_PredNetUInt32Variables = 0x68; // CNetworkUtlVectorBase<uint32_t>
    constexpr std::ptrdiff_t m_PredNetUInt64Variables = 0x80; // CNetworkUtlVectorBase<uint64_t>
    constexpr std::ptrdiff_t m_PredNetFloatVariables = 0x98; // CNetworkUtlVectorBase<float>
    constexpr std::ptrdiff_t m_PredNetVectorVariables = 0xB0; // CNetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_PredNetQuaternionVariables = 0xC8; // CNetworkUtlVectorBase<Quaternion>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetBoolVariables = 0xE0; // CNetworkUtlVectorBase<uint32_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetByteVariables = 0xF8; // CNetworkUtlVectorBase<uint8_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetUInt16Variables = 0x110; // CNetworkUtlVectorBase<uint16_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetIntVariables = 0x128; // CNetworkUtlVectorBase<int32_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetUInt32Variables = 0x140; // CNetworkUtlVectorBase<uint32_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetUInt64Variables = 0x158; // CNetworkUtlVectorBase<uint64_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetFloatVariables = 0x170; // CNetworkUtlVectorBase<float>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetVectorVariables = 0x188; // CNetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetQuaternionVariables = 0x1A0; // CNetworkUtlVectorBase<Quaternion>
    constexpr std::ptrdiff_t m_nBoolVariablesCount = 0x1B8; // int32_t
    constexpr std::ptrdiff_t m_nOwnerOnlyBoolVariablesCount = 0x1BC; // int32_t
    constexpr std::ptrdiff_t m_nRandomSeedOffset = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_flLastTeleportTime = 0x1C4; // float
}

namespace CAnimGraphTagRef {
    constexpr std::ptrdiff_t m_nTagIndex = 0x0; // int32_t
    constexpr std::ptrdiff_t m_tagName = 0x10; // CGlobalSymbol
}

namespace CAttributeContainer {
    constexpr std::ptrdiff_t m_Item = 0x50; // CEconItemView
}

namespace CAttributeList {
    constexpr std::ptrdiff_t m_Attributes = 0x8; // CUtlVectorEmbeddedNetworkVar<CEconItemAttribute>
    constexpr std::ptrdiff_t m_pManager = 0x58; // CAttributeManager*
}

namespace CAttributeManager {
    constexpr std::ptrdiff_t m_Providers = 0x8; // CUtlVector<CHandle<CBaseEntity>>
    constexpr std::ptrdiff_t m_iReapplyProvisionParity = 0x20; // int32_t
    constexpr std::ptrdiff_t m_hOuter = 0x24; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bPreventLoopback = 0x28; // bool
    constexpr std::ptrdiff_t m_ProviderType = 0x2C; // attributeprovidertypes_t
    constexpr std::ptrdiff_t m_CachedResults = 0x30; // CUtlVector<CAttributeManager::cached_attribute_float_t>
}

namespace CAttributeManager_cached_attribute_float_t {
    constexpr std::ptrdiff_t flIn = 0x0; // float
    constexpr std::ptrdiff_t iAttribHook = 0x8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t flOut = 0x10; // float
}

namespace CBarnLight {
    constexpr std::ptrdiff_t m_bEnabled = 0x700; // bool
    constexpr std::ptrdiff_t m_nColorMode = 0x704; // int32_t
    constexpr std::ptrdiff_t m_Color = 0x708; // Color
    constexpr std::ptrdiff_t m_flColorTemperature = 0x70C; // float
    constexpr std::ptrdiff_t m_flBrightness = 0x710; // float
    constexpr std::ptrdiff_t m_flBrightnessScale = 0x714; // float
    constexpr std::ptrdiff_t m_nDirectLight = 0x718; // int32_t
    constexpr std::ptrdiff_t m_nBakedShadowIndex = 0x71C; // int32_t
    constexpr std::ptrdiff_t m_nLuminaireShape = 0x720; // int32_t
    constexpr std::ptrdiff_t m_flLuminaireSize = 0x724; // float
    constexpr std::ptrdiff_t m_flLuminaireAnisotropy = 0x728; // float
    constexpr std::ptrdiff_t m_LightStyleString = 0x730; // CUtlString
    constexpr std::ptrdiff_t m_flLightStyleStartTime = 0x738; // GameTime_t
    constexpr std::ptrdiff_t m_QueuedLightStyleStrings = 0x740; // CNetworkUtlVectorBase<CUtlString>
    constexpr std::ptrdiff_t m_LightStyleEvents = 0x758; // CNetworkUtlVectorBase<CUtlString>
    constexpr std::ptrdiff_t m_LightStyleTargets = 0x770; // CNetworkUtlVectorBase<CHandle<CBaseModelEntity>>
    constexpr std::ptrdiff_t m_StyleEvent = 0x788; // CEntityIOOutput[4]
    constexpr std::ptrdiff_t m_hLightCookie = 0x848; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_flShape = 0x850; // float
    constexpr std::ptrdiff_t m_flSoftX = 0x854; // float
    constexpr std::ptrdiff_t m_flSoftY = 0x858; // float
    constexpr std::ptrdiff_t m_flSkirt = 0x85C; // float
    constexpr std::ptrdiff_t m_flSkirtNear = 0x860; // float
    constexpr std::ptrdiff_t m_vSizeParams = 0x864; // Vector
    constexpr std::ptrdiff_t m_flRange = 0x870; // float
    constexpr std::ptrdiff_t m_vShear = 0x874; // Vector
    constexpr std::ptrdiff_t m_nBakeSpecularToCubemaps = 0x880; // int32_t
    constexpr std::ptrdiff_t m_vBakeSpecularToCubemapsSize = 0x884; // Vector
    constexpr std::ptrdiff_t m_nCastShadows = 0x890; // int32_t
    constexpr std::ptrdiff_t m_nShadowMapSize = 0x894; // int32_t
    constexpr std::ptrdiff_t m_nShadowPriority = 0x898; // int32_t
    constexpr std::ptrdiff_t m_bContactShadow = 0x89C; // bool
    constexpr std::ptrdiff_t m_nBounceLight = 0x8A0; // int32_t
    constexpr std::ptrdiff_t m_flBounceScale = 0x8A4; // float
    constexpr std::ptrdiff_t m_flMinRoughness = 0x8A8; // float
    constexpr std::ptrdiff_t m_vAlternateColor = 0x8AC; // Vector
    constexpr std::ptrdiff_t m_fAlternateColorBrightness = 0x8B8; // float
    constexpr std::ptrdiff_t m_nFog = 0x8BC; // int32_t
    constexpr std::ptrdiff_t m_flFogStrength = 0x8C0; // float
    constexpr std::ptrdiff_t m_nFogShadows = 0x8C4; // int32_t
    constexpr std::ptrdiff_t m_flFogScale = 0x8C8; // float
    constexpr std::ptrdiff_t m_flFadeSizeStart = 0x8CC; // float
    constexpr std::ptrdiff_t m_flFadeSizeEnd = 0x8D0; // float
    constexpr std::ptrdiff_t m_flShadowFadeSizeStart = 0x8D4; // float
    constexpr std::ptrdiff_t m_flShadowFadeSizeEnd = 0x8D8; // float
    constexpr std::ptrdiff_t m_bPrecomputedFieldsValid = 0x8DC; // bool
    constexpr std::ptrdiff_t m_vPrecomputedBoundsMins = 0x8E0; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedBoundsMaxs = 0x8EC; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedOBBOrigin = 0x8F8; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedOBBAngles = 0x904; // QAngle
    constexpr std::ptrdiff_t m_vPrecomputedOBBExtent = 0x910; // Vector
    constexpr std::ptrdiff_t m_bPvsModifyEntity = 0x91C; // bool
}

namespace CBaseAnimGraph {
    constexpr std::ptrdiff_t m_bInitiallyPopulateInterpHistory = 0x700; // bool
    constexpr std::ptrdiff_t m_bShouldAnimateDuringGameplayPause = 0x701; // bool
    constexpr std::ptrdiff_t m_pChoreoServices = 0x708; // IChoreoServices*
    constexpr std::ptrdiff_t m_bAnimGraphUpdateEnabled = 0x710; // bool
    constexpr std::ptrdiff_t m_flMaxSlopeDistance = 0x714; // float
    constexpr std::ptrdiff_t m_vLastSlopeCheckPos = 0x718; // Vector
    constexpr std::ptrdiff_t m_bAnimGraphDirty = 0x724; // bool
    constexpr std::ptrdiff_t m_vecForce = 0x728; // Vector
    constexpr std::ptrdiff_t m_nForceBone = 0x734; // int32_t
    constexpr std::ptrdiff_t m_pRagdollPose = 0x748; // PhysicsRagdollPose_t*
    constexpr std::ptrdiff_t m_bClientRagdoll = 0x750; // bool
}

namespace CBaseAnimGraphController {
    constexpr std::ptrdiff_t m_baseLayer = 0x18; // CNetworkedSequenceOperation
    constexpr std::ptrdiff_t m_animGraphNetworkedVars = 0x40; // CAnimGraphNetworkedVariables
    constexpr std::ptrdiff_t m_bSequenceFinished = 0x218; // bool
    constexpr std::ptrdiff_t m_flLastEventCycle = 0x21C; // float
    constexpr std::ptrdiff_t m_flLastEventAnimTime = 0x220; // float
    constexpr std::ptrdiff_t m_flPlaybackRate = 0x224; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_flPrevAnimTime = 0x22C; // float
    constexpr std::ptrdiff_t m_bClientSideAnimation = 0x230; // bool
    constexpr std::ptrdiff_t m_bNetworkedAnimationInputsChanged = 0x231; // bool
    constexpr std::ptrdiff_t m_nNewSequenceParity = 0x234; // int32_t
    constexpr std::ptrdiff_t m_nResetEventsParity = 0x238; // int32_t
    constexpr std::ptrdiff_t m_nAnimLoopMode = 0x23C; // AnimLoopMode_t
    constexpr std::ptrdiff_t m_hAnimationUpdate = 0x2DC; // AnimationUpdateListHandle_t
}

namespace CBaseButton {
    constexpr std::ptrdiff_t m_angMoveEntitySpace = 0x780; // QAngle
    constexpr std::ptrdiff_t m_fStayPushed = 0x78C; // bool
    constexpr std::ptrdiff_t m_fRotating = 0x78D; // bool
    constexpr std::ptrdiff_t m_ls = 0x790; // locksound_t
    constexpr std::ptrdiff_t m_sUseSound = 0x7B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_sLockedSound = 0x7B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_sUnlockedSound = 0x7C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bLocked = 0x7C8; // bool
    constexpr std::ptrdiff_t m_bDisabled = 0x7C9; // bool
    constexpr std::ptrdiff_t m_flUseLockedTime = 0x7CC; // GameTime_t
    constexpr std::ptrdiff_t m_bSolidBsp = 0x7D0; // bool
    constexpr std::ptrdiff_t m_OnDamaged = 0x7D8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnPressed = 0x800; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnUseLocked = 0x828; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnIn = 0x850; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnOut = 0x878; // CEntityIOOutput
    constexpr std::ptrdiff_t m_nState = 0x8A0; // int32_t
    constexpr std::ptrdiff_t m_hConstraint = 0x8A4; // CEntityHandle
    constexpr std::ptrdiff_t m_hConstraintParent = 0x8A8; // CEntityHandle
    constexpr std::ptrdiff_t m_bForceNpcExclude = 0x8AC; // bool
    constexpr std::ptrdiff_t m_sGlowEntity = 0x8B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_glowEntity = 0x8B8; // CHandle<CBaseModelEntity>
    constexpr std::ptrdiff_t m_usable = 0x8BC; // bool
    constexpr std::ptrdiff_t m_szDisplayText = 0x8C0; // CUtlSymbolLarge
}

namespace CBaseCSGrenade {
    constexpr std::ptrdiff_t m_bRedraw = 0xE20; // bool
    constexpr std::ptrdiff_t m_bIsHeldByPlayer = 0xE21; // bool
    constexpr std::ptrdiff_t m_bPinPulled = 0xE22; // bool
    constexpr std::ptrdiff_t m_bJumpThrow = 0xE23; // bool
    constexpr std::ptrdiff_t m_eThrowStatus = 0xE24; // EGrenadeThrowState
    constexpr std::ptrdiff_t m_fThrowTime = 0xE28; // GameTime_t
    constexpr std::ptrdiff_t m_flThrowStrength = 0xE2C; // float
    constexpr std::ptrdiff_t m_flThrowStrengthApproach = 0xE30; // float
    constexpr std::ptrdiff_t m_fDropTime = 0xE34; // GameTime_t
}

namespace CBaseCSGrenadeProjectile {
    constexpr std::ptrdiff_t m_vInitialPosition = 0x9C8; // Vector
    constexpr std::ptrdiff_t m_vInitialVelocity = 0x9D4; // Vector
    constexpr std::ptrdiff_t m_nBounces = 0x9E0; // int32_t
    constexpr std::ptrdiff_t m_nExplodeEffectIndex = 0x9E8; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_nExplodeEffectTickBegin = 0x9F0; // int32_t
    constexpr std::ptrdiff_t m_vecExplodeEffectOrigin = 0x9F4; // Vector
    constexpr std::ptrdiff_t m_flSpawnTime = 0xA00; // GameTime_t
    constexpr std::ptrdiff_t m_unOGSExtraFlags = 0xA04; // uint8_t
    constexpr std::ptrdiff_t m_bDetonationRecorded = 0xA05; // bool
    constexpr std::ptrdiff_t m_flDetonateTime = 0xA08; // GameTime_t
    constexpr std::ptrdiff_t m_nItemIndex = 0xA0C; // uint16_t
    constexpr std::ptrdiff_t m_vecOriginalSpawnLocation = 0xA10; // Vector
    constexpr std::ptrdiff_t m_flLastBounceSoundTime = 0xA1C; // GameTime_t
    constexpr std::ptrdiff_t m_vecGrenadeSpin = 0xA20; // RotationVector
    constexpr std::ptrdiff_t m_vecLastHitSurfaceNormal = 0xA2C; // Vector
    constexpr std::ptrdiff_t m_nTicksAtZeroVelocity = 0xA38; // int32_t
    constexpr std::ptrdiff_t m_bHasEverHitPlayer = 0xA3C; // bool
    constexpr std::ptrdiff_t m_bClearFromPlayers = 0xA3D; // bool
}

namespace CBaseClientUIEntity {
    constexpr std::ptrdiff_t m_bEnabled = 0x700; // bool
    constexpr std::ptrdiff_t m_DialogXMLName = 0x708; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_PanelClassName = 0x710; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_PanelID = 0x718; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_CustomOutput0 = 0x720; // CEntityIOOutput
    constexpr std::ptrdiff_t m_CustomOutput1 = 0x748; // CEntityIOOutput
    constexpr std::ptrdiff_t m_CustomOutput2 = 0x770; // CEntityIOOutput
    constexpr std::ptrdiff_t m_CustomOutput3 = 0x798; // CEntityIOOutput
    constexpr std::ptrdiff_t m_CustomOutput4 = 0x7C0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_CustomOutput5 = 0x7E8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_CustomOutput6 = 0x810; // CEntityIOOutput
    constexpr std::ptrdiff_t m_CustomOutput7 = 0x838; // CEntityIOOutput
    constexpr std::ptrdiff_t m_CustomOutput8 = 0x860; // CEntityIOOutput
    constexpr std::ptrdiff_t m_CustomOutput9 = 0x888; // CEntityIOOutput
}

namespace CBaseCombatCharacter {
    constexpr std::ptrdiff_t m_bForceServerRagdoll = 0x920; // bool
    constexpr std::ptrdiff_t m_hMyWearables = 0x928; // CNetworkUtlVectorBase<CHandle<CEconWearable>>
    constexpr std::ptrdiff_t m_flFieldOfView = 0x940; // float
    constexpr std::ptrdiff_t m_impactEnergyScale = 0x944; // float
    constexpr std::ptrdiff_t m_LastHitGroup = 0x948; // HitGroup_t
    constexpr std::ptrdiff_t m_bApplyStressDamage = 0x94C; // bool
    constexpr std::ptrdiff_t m_bloodColor = 0x950; // int32_t
    constexpr std::ptrdiff_t m_navMeshID = 0x9B0; // int32_t
    constexpr std::ptrdiff_t m_iDamageCount = 0x9B4; // int32_t
    constexpr std::ptrdiff_t m_pVecRelationships = 0x9B8; // CUtlVector<RelationshipOverride_t>*
    constexpr std::ptrdiff_t m_strRelationships = 0x9C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_eHull = 0x9C8; // Hull_t
    constexpr std::ptrdiff_t m_nNavHullIdx = 0x9CC; // uint32_t
}

namespace CBaseDMStart {
    constexpr std::ptrdiff_t m_Master = 0x4B0; // CUtlSymbolLarge
}

namespace CBaseDoor {
    constexpr std::ptrdiff_t m_angMoveEntitySpace = 0x790; // QAngle
    constexpr std::ptrdiff_t m_vecMoveDirParentSpace = 0x79C; // Vector
    constexpr std::ptrdiff_t m_ls = 0x7A8; // locksound_t
    constexpr std::ptrdiff_t m_bForceClosed = 0x7C8; // bool
    constexpr std::ptrdiff_t m_bDoorGroup = 0x7C9; // bool
    constexpr std::ptrdiff_t m_bLocked = 0x7CA; // bool
    constexpr std::ptrdiff_t m_bIgnoreDebris = 0x7CB; // bool
    constexpr std::ptrdiff_t m_eSpawnPosition = 0x7CC; // FuncDoorSpawnPos_t
    constexpr std::ptrdiff_t m_flBlockDamage = 0x7D0; // float
    constexpr std::ptrdiff_t m_NoiseMoving = 0x7D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_NoiseArrived = 0x7E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_NoiseMovingClosed = 0x7E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_NoiseArrivedClosed = 0x7F0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_ChainTarget = 0x7F8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_OnBlockedClosing = 0x800; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnBlockedOpening = 0x828; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnUnblockedClosing = 0x850; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnUnblockedOpening = 0x878; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFullyClosed = 0x8A0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFullyOpen = 0x8C8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnClose = 0x8F0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnOpen = 0x918; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnLockedUse = 0x940; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bLoopMoveSound = 0x968; // bool
    constexpr std::ptrdiff_t m_bCreateNavObstacle = 0x980; // bool
    constexpr std::ptrdiff_t m_isChaining = 0x981; // bool
    constexpr std::ptrdiff_t m_bIsUsable = 0x982; // bool
}

namespace CBaseEntity {
    constexpr std::ptrdiff_t m_CBodyComponent = 0x30; // CBodyComponent*
    constexpr std::ptrdiff_t m_NetworkTransmitComponent = 0x38; // CNetworkTransmitComponent
    constexpr std::ptrdiff_t m_aThinkFunctions = 0x228; // CUtlVector<thinkfunc_t>
    constexpr std::ptrdiff_t m_iCurrentThinkContext = 0x240; // int32_t
    constexpr std::ptrdiff_t m_nLastThinkTick = 0x244; // GameTick_t
    constexpr std::ptrdiff_t m_isSteadyState = 0x250; // CBitVec<64>
    constexpr std::ptrdiff_t m_lastNetworkChange = 0x258; // float
    constexpr std::ptrdiff_t m_ResponseContexts = 0x268; // CUtlVector<ResponseContext_t>
    constexpr std::ptrdiff_t m_iszResponseContext = 0x280; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iHealth = 0x2A8; // int32_t
    constexpr std::ptrdiff_t m_iMaxHealth = 0x2AC; // int32_t
    constexpr std::ptrdiff_t m_lifeState = 0x2B0; // uint8_t
    constexpr std::ptrdiff_t m_flDamageAccumulator = 0x2B4; // float
    constexpr std::ptrdiff_t m_bTakesDamage = 0x2B8; // bool
    constexpr std::ptrdiff_t m_nTakeDamageFlags = 0x2BC; // TakeDamageFlags_t
    constexpr std::ptrdiff_t m_MoveCollide = 0x2C1; // MoveCollide_t
    constexpr std::ptrdiff_t m_MoveType = 0x2C2; // MoveType_t
    constexpr std::ptrdiff_t m_nWaterTouch = 0x2C3; // uint8_t
    constexpr std::ptrdiff_t m_nSlimeTouch = 0x2C4; // uint8_t
    constexpr std::ptrdiff_t m_bRestoreInHierarchy = 0x2C5; // bool
    constexpr std::ptrdiff_t m_target = 0x2C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flMoveDoneTime = 0x2D0; // float
    constexpr std::ptrdiff_t m_hDamageFilter = 0x2D4; // CHandle<CBaseFilter>
    constexpr std::ptrdiff_t m_iszDamageFilterName = 0x2D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nSubclassID = 0x2E0; // CUtlStringToken
    constexpr std::ptrdiff_t m_flAnimTime = 0x2F0; // float
    constexpr std::ptrdiff_t m_flSimulationTime = 0x2F4; // float
    constexpr std::ptrdiff_t m_flCreateTime = 0x2F8; // GameTime_t
    constexpr std::ptrdiff_t m_bClientSideRagdoll = 0x2FC; // bool
    constexpr std::ptrdiff_t m_ubInterpolationFrame = 0x2FD; // uint8_t
    constexpr std::ptrdiff_t m_vPrevVPhysicsUpdatePos = 0x300; // Vector
    constexpr std::ptrdiff_t m_iTeamNum = 0x30C; // uint8_t
    constexpr std::ptrdiff_t m_iGlobalname = 0x310; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iSentToClients = 0x318; // int32_t
    constexpr std::ptrdiff_t m_flSpeed = 0x31C; // float
    constexpr std::ptrdiff_t m_sUniqueHammerID = 0x320; // CUtlString
    constexpr std::ptrdiff_t m_spawnflags = 0x328; // uint32_t
    constexpr std::ptrdiff_t m_nNextThinkTick = 0x32C; // GameTick_t
    constexpr std::ptrdiff_t m_nSimulationTick = 0x330; // int32_t
    constexpr std::ptrdiff_t m_OnKilled = 0x338; // CEntityIOOutput
    constexpr std::ptrdiff_t m_fFlags = 0x360; // uint32_t
    constexpr std::ptrdiff_t m_vecAbsVelocity = 0x364; // Vector
    constexpr std::ptrdiff_t m_vecVelocity = 0x370; // CNetworkVelocityVector
    constexpr std::ptrdiff_t m_vecBaseVelocity = 0x3A0; // Vector
    constexpr std::ptrdiff_t m_nPushEnumCount = 0x3AC; // int32_t
    constexpr std::ptrdiff_t m_pCollision = 0x3B0; // CCollisionProperty*
    constexpr std::ptrdiff_t m_hEffectEntity = 0x3B8; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hOwnerEntity = 0x3BC; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_fEffects = 0x3C0; // uint32_t
    constexpr std::ptrdiff_t m_hGroundEntity = 0x3C4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_flFriction = 0x3C8; // float
    constexpr std::ptrdiff_t m_flElasticity = 0x3CC; // float
    constexpr std::ptrdiff_t m_flGravityScale = 0x3D0; // float
    constexpr std::ptrdiff_t m_flTimeScale = 0x3D4; // float
    constexpr std::ptrdiff_t m_flWaterLevel = 0x3D8; // float
    constexpr std::ptrdiff_t m_bSimulatedEveryTick = 0x3DC; // bool
    constexpr std::ptrdiff_t m_bAnimatedEveryTick = 0x3DD; // bool
    constexpr std::ptrdiff_t m_bDisableLowViolence = 0x3DE; // bool
    constexpr std::ptrdiff_t m_nWaterType = 0x3DF; // uint8_t
    constexpr std::ptrdiff_t m_iEFlags = 0x3E0; // int32_t
    constexpr std::ptrdiff_t m_OnUser1 = 0x3E8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnUser2 = 0x410; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnUser3 = 0x438; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnUser4 = 0x460; // CEntityIOOutput
    constexpr std::ptrdiff_t m_iInitialTeamNum = 0x488; // int32_t
    constexpr std::ptrdiff_t m_flNavIgnoreUntilTime = 0x48C; // GameTime_t
    constexpr std::ptrdiff_t m_vecAngVelocity = 0x490; // QAngle
    constexpr std::ptrdiff_t m_bNetworkQuantizeOriginAndAngles = 0x49C; // bool
    constexpr std::ptrdiff_t m_bLagCompensate = 0x49D; // bool
    constexpr std::ptrdiff_t m_flOverriddenFriction = 0x4A0; // float
    constexpr std::ptrdiff_t m_pBlocker = 0x4A4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_flLocalTime = 0x4A8; // float
    constexpr std::ptrdiff_t m_flVPhysicsUpdateLocalTime = 0x4AC; // float
}

namespace CBaseFilter {
    constexpr std::ptrdiff_t m_bNegated = 0x4B0; // bool
    constexpr std::ptrdiff_t m_OnPass = 0x4B8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFail = 0x4E0; // CEntityIOOutput
}

namespace CBaseFire {
    constexpr std::ptrdiff_t m_flScale = 0x4B0; // float
    constexpr std::ptrdiff_t m_flStartScale = 0x4B4; // float
    constexpr std::ptrdiff_t m_flScaleTime = 0x4B8; // float
    constexpr std::ptrdiff_t m_nFlags = 0x4BC; // uint32_t
}

namespace CBaseFlex {
    constexpr std::ptrdiff_t m_flexWeight = 0x890; // CNetworkUtlVectorBase<float>
    constexpr std::ptrdiff_t m_vLookTargetPosition = 0x8A8; // Vector
    constexpr std::ptrdiff_t m_blinktoggle = 0x8B4; // bool
    constexpr std::ptrdiff_t m_flAllowResponsesEndTime = 0x908; // GameTime_t
    constexpr std::ptrdiff_t m_flLastFlexAnimationTime = 0x90C; // GameTime_t
    constexpr std::ptrdiff_t m_nNextSceneEventId = 0x910; // uint32_t
    constexpr std::ptrdiff_t m_bUpdateLayerPriorities = 0x914; // bool
}

namespace CBaseGrenade {
    constexpr std::ptrdiff_t m_OnPlayerPickup = 0x928; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnExplode = 0x950; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bHasWarnedAI = 0x978; // bool
    constexpr std::ptrdiff_t m_bIsSmokeGrenade = 0x979; // bool
    constexpr std::ptrdiff_t m_bIsLive = 0x97A; // bool
    constexpr std::ptrdiff_t m_DmgRadius = 0x97C; // float
    constexpr std::ptrdiff_t m_flDetonateTime = 0x980; // GameTime_t
    constexpr std::ptrdiff_t m_flWarnAITime = 0x984; // float
    constexpr std::ptrdiff_t m_flDamage = 0x988; // float
    constexpr std::ptrdiff_t m_iszBounceSound = 0x990; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_ExplosionSound = 0x998; // CUtlString
    constexpr std::ptrdiff_t m_hThrower = 0x9A4; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_flNextAttack = 0x9BC; // GameTime_t
    constexpr std::ptrdiff_t m_hOriginalThrower = 0x9C0; // CHandle<CCSPlayerPawn>
}

namespace CBaseIssue {
    constexpr std::ptrdiff_t m_szTypeString = 0x20; // char[64]
    constexpr std::ptrdiff_t m_szDetailsString = 0x60; // char[260]
    constexpr std::ptrdiff_t m_iNumYesVotes = 0x164; // int32_t
    constexpr std::ptrdiff_t m_iNumNoVotes = 0x168; // int32_t
    constexpr std::ptrdiff_t m_iNumPotentialVotes = 0x16C; // int32_t
    constexpr std::ptrdiff_t m_pVoteController = 0x170; // CVoteController*
}

namespace CBaseModelEntity {
    constexpr std::ptrdiff_t m_CRenderComponent = 0x4B0; // CRenderComponent*
    constexpr std::ptrdiff_t m_CHitboxComponent = 0x4B8; // CHitboxComponent
    constexpr std::ptrdiff_t m_flDissolveStartTime = 0x4E0; // GameTime_t
    constexpr std::ptrdiff_t m_OnIgnite = 0x4E8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_nRenderMode = 0x510; // RenderMode_t
    constexpr std::ptrdiff_t m_nRenderFX = 0x511; // RenderFx_t
    constexpr std::ptrdiff_t m_bAllowFadeInView = 0x512; // bool
    constexpr std::ptrdiff_t m_clrRender = 0x513; // Color
    constexpr std::ptrdiff_t m_vecRenderAttributes = 0x518; // CUtlVectorEmbeddedNetworkVar<EntityRenderAttribute_t>
    constexpr std::ptrdiff_t m_bRenderToCubemaps = 0x568; // bool
    constexpr std::ptrdiff_t m_Collision = 0x570; // CCollisionProperty
    constexpr std::ptrdiff_t m_Glow = 0x620; // CGlowProperty
    constexpr std::ptrdiff_t m_flGlowBackfaceMult = 0x678; // float
    constexpr std::ptrdiff_t m_fadeMinDist = 0x67C; // float
    constexpr std::ptrdiff_t m_fadeMaxDist = 0x680; // float
    constexpr std::ptrdiff_t m_flFadeScale = 0x684; // float
    constexpr std::ptrdiff_t m_flShadowStrength = 0x688; // float
    constexpr std::ptrdiff_t m_nObjectCulling = 0x68C; // uint8_t
    constexpr std::ptrdiff_t m_nAddDecal = 0x690; // int32_t
    constexpr std::ptrdiff_t m_vDecalPosition = 0x694; // Vector
    constexpr std::ptrdiff_t m_vDecalForwardAxis = 0x6A0; // Vector
    constexpr std::ptrdiff_t m_flDecalHealBloodRate = 0x6AC; // float
    constexpr std::ptrdiff_t m_flDecalHealHeightRate = 0x6B0; // float
    constexpr std::ptrdiff_t m_ConfigEntitiesToPropagateMaterialDecalsTo = 0x6B8; // CNetworkUtlVectorBase<CHandle<CBaseModelEntity>>
    constexpr std::ptrdiff_t m_vecViewOffset = 0x6D0; // CNetworkViewOffsetVector
}

namespace CBaseMoveBehavior {
    constexpr std::ptrdiff_t m_iPositionInterpolator = 0x510; // int32_t
    constexpr std::ptrdiff_t m_iRotationInterpolator = 0x514; // int32_t
    constexpr std::ptrdiff_t m_flAnimStartTime = 0x518; // float
    constexpr std::ptrdiff_t m_flAnimEndTime = 0x51C; // float
    constexpr std::ptrdiff_t m_flAverageSpeedAcrossFrame = 0x520; // float
    constexpr std::ptrdiff_t m_pCurrentKeyFrame = 0x528; // CPathKeyFrame*
    constexpr std::ptrdiff_t m_pTargetKeyFrame = 0x530; // CPathKeyFrame*
    constexpr std::ptrdiff_t m_pPreKeyFrame = 0x538; // CPathKeyFrame*
    constexpr std::ptrdiff_t m_pPostKeyFrame = 0x540; // CPathKeyFrame*
    constexpr std::ptrdiff_t m_flTimeIntoFrame = 0x548; // float
    constexpr std::ptrdiff_t m_iDirection = 0x54C; // int32_t
}

namespace CBasePlatTrain {
    constexpr std::ptrdiff_t m_NoiseMoving = 0x780; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_NoiseArrived = 0x788; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_volume = 0x798; // float
    constexpr std::ptrdiff_t m_flTWidth = 0x79C; // float
    constexpr std::ptrdiff_t m_flTLength = 0x7A0; // float
}

namespace CBasePlayerController {
    constexpr std::ptrdiff_t m_nInButtonsWhichAreToggles = 0x4B8; // uint64_t
    constexpr std::ptrdiff_t m_nTickBase = 0x4C0; // uint32_t
    constexpr std::ptrdiff_t m_hPawn = 0x4F0; // CHandle<CBasePlayerPawn>
    constexpr std::ptrdiff_t m_nSplitScreenSlot = 0x4F4; // CSplitScreenSlot
    constexpr std::ptrdiff_t m_hSplitOwner = 0x4F8; // CHandle<CBasePlayerController>
    constexpr std::ptrdiff_t m_hSplitScreenPlayers = 0x500; // CUtlVector<CHandle<CBasePlayerController>>
    constexpr std::ptrdiff_t m_bIsHLTV = 0x518; // bool
    constexpr std::ptrdiff_t m_iConnected = 0x51C; // PlayerConnectedState
    constexpr std::ptrdiff_t m_iszPlayerName = 0x520; // char[128]
    constexpr std::ptrdiff_t m_szNetworkIDString = 0x5A0; // CUtlString
    constexpr std::ptrdiff_t m_fLerpTime = 0x5A8; // float
    constexpr std::ptrdiff_t m_bLagCompensation = 0x5AC; // bool
    constexpr std::ptrdiff_t m_bPredict = 0x5AD; // bool
    constexpr std::ptrdiff_t m_bAutoKickDisabled = 0x5AE; // bool
    constexpr std::ptrdiff_t m_bIsLowViolence = 0x5AF; // bool
    constexpr std::ptrdiff_t m_bGamePaused = 0x5B0; // bool
    constexpr std::ptrdiff_t m_nUsecTimestampLastUserCmdReceived = 0x648; // int64_t
    constexpr std::ptrdiff_t m_iIgnoreGlobalChat = 0x660; // ChatIgnoreType_t
    constexpr std::ptrdiff_t m_flLastPlayerTalkTime = 0x664; // float
    constexpr std::ptrdiff_t m_flLastEntitySteadyState = 0x668; // float
    constexpr std::ptrdiff_t m_nAvailableEntitySteadyState = 0x66C; // int32_t
    constexpr std::ptrdiff_t m_bHasAnySteadyStateEnts = 0x670; // bool
    constexpr std::ptrdiff_t m_steamID = 0x680; // uint64_t
    constexpr std::ptrdiff_t m_iDesiredFOV = 0x688; // uint32_t
}

namespace CBasePlayerPawn {
    constexpr std::ptrdiff_t m_pWeaponServices = 0x9D0; // CPlayer_WeaponServices*
    constexpr std::ptrdiff_t m_pItemServices = 0x9D8; // CPlayer_ItemServices*
    constexpr std::ptrdiff_t m_pAutoaimServices = 0x9E0; // CPlayer_AutoaimServices*
    constexpr std::ptrdiff_t m_pObserverServices = 0x9E8; // CPlayer_ObserverServices*
    constexpr std::ptrdiff_t m_pWaterServices = 0x9F0; // CPlayer_WaterServices*
    constexpr std::ptrdiff_t m_pUseServices = 0x9F8; // CPlayer_UseServices*
    constexpr std::ptrdiff_t m_pFlashlightServices = 0xA00; // CPlayer_FlashlightServices*
    constexpr std::ptrdiff_t m_pCameraServices = 0xA08; // CPlayer_CameraServices*
    constexpr std::ptrdiff_t m_pMovementServices = 0xA10; // CPlayer_MovementServices*
    constexpr std::ptrdiff_t m_ServerViewAngleChanges = 0xA20; // CUtlVectorEmbeddedNetworkVar<ViewAngleServerChange_t>
    constexpr std::ptrdiff_t m_nHighestGeneratedServerViewAngleChangeIndex = 0xA70; // uint32_t
    constexpr std::ptrdiff_t v_angle = 0xA74; // QAngle
    constexpr std::ptrdiff_t v_anglePrevious = 0xA80; // QAngle
    constexpr std::ptrdiff_t m_iHideHUD = 0xA8C; // uint32_t
    constexpr std::ptrdiff_t m_skybox3d = 0xA90; // sky3dparams_t
    constexpr std::ptrdiff_t m_fTimeLastHurt = 0xB20; // GameTime_t
    constexpr std::ptrdiff_t m_flDeathTime = 0xB24; // GameTime_t
    constexpr std::ptrdiff_t m_fNextSuicideTime = 0xB28; // GameTime_t
    constexpr std::ptrdiff_t m_fInitHUD = 0xB2C; // bool
    constexpr std::ptrdiff_t m_pExpresser = 0xB30; // CAI_Expresser*
    constexpr std::ptrdiff_t m_hController = 0xB38; // CHandle<CBasePlayerController>
    constexpr std::ptrdiff_t m_fHltvReplayDelay = 0xB40; // float
    constexpr std::ptrdiff_t m_fHltvReplayEnd = 0xB44; // float
    constexpr std::ptrdiff_t m_iHltvReplayEntity = 0xB48; // CEntityIndex
}

namespace CBasePlayerVData {
    constexpr std::ptrdiff_t m_sModelName = 0x28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_flHeadDamageMultiplier = 0x108; // CSkillFloat
    constexpr std::ptrdiff_t m_flChestDamageMultiplier = 0x118; // CSkillFloat
    constexpr std::ptrdiff_t m_flStomachDamageMultiplier = 0x128; // CSkillFloat
    constexpr std::ptrdiff_t m_flArmDamageMultiplier = 0x138; // CSkillFloat
    constexpr std::ptrdiff_t m_flLegDamageMultiplier = 0x148; // CSkillFloat
    constexpr std::ptrdiff_t m_flHoldBreathTime = 0x158; // float
    constexpr std::ptrdiff_t m_flDrowningDamageInterval = 0x15C; // float
    constexpr std::ptrdiff_t m_nDrowningDamageInitial = 0x160; // int32_t
    constexpr std::ptrdiff_t m_nDrowningDamageMax = 0x164; // int32_t
    constexpr std::ptrdiff_t m_nWaterSpeed = 0x168; // int32_t
    constexpr std::ptrdiff_t m_flUseRange = 0x16C; // float
    constexpr std::ptrdiff_t m_flUseAngleTolerance = 0x170; // float
    constexpr std::ptrdiff_t m_flCrouchTime = 0x174; // float
}

namespace CBasePlayerWeapon {
    constexpr std::ptrdiff_t m_nNextPrimaryAttackTick = 0xC18; // GameTick_t
    constexpr std::ptrdiff_t m_flNextPrimaryAttackTickRatio = 0xC1C; // float
    constexpr std::ptrdiff_t m_nNextSecondaryAttackTick = 0xC20; // GameTick_t
    constexpr std::ptrdiff_t m_flNextSecondaryAttackTickRatio = 0xC24; // float
    constexpr std::ptrdiff_t m_iClip1 = 0xC28; // int32_t
    constexpr std::ptrdiff_t m_iClip2 = 0xC2C; // int32_t
    constexpr std::ptrdiff_t m_pReserveAmmo = 0xC30; // int32_t[2]
    constexpr std::ptrdiff_t m_OnPlayerUse = 0xC38; // CEntityIOOutput
}

namespace CBasePlayerWeaponVData {
    constexpr std::ptrdiff_t m_szWorldModel = 0x28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_bBuiltRightHanded = 0x108; // bool
    constexpr std::ptrdiff_t m_bAllowFlipping = 0x109; // bool
    constexpr std::ptrdiff_t m_bIsFullAuto = 0x10A; // bool
    constexpr std::ptrdiff_t m_nNumBullets = 0x10C; // int32_t
    constexpr std::ptrdiff_t m_sMuzzleAttachment = 0x110; // CUtlString
    constexpr std::ptrdiff_t m_szMuzzleFlashParticle = 0x118; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_iFlags = 0x1F8; // ItemFlagTypes_t
    constexpr std::ptrdiff_t m_nPrimaryAmmoType = 0x1F9; // AmmoIndex_t
    constexpr std::ptrdiff_t m_nSecondaryAmmoType = 0x1FA; // AmmoIndex_t
    constexpr std::ptrdiff_t m_iMaxClip1 = 0x1FC; // int32_t
    constexpr std::ptrdiff_t m_iMaxClip2 = 0x200; // int32_t
    constexpr std::ptrdiff_t m_iDefaultClip1 = 0x204; // int32_t
    constexpr std::ptrdiff_t m_iDefaultClip2 = 0x208; // int32_t
    constexpr std::ptrdiff_t m_iWeight = 0x20C; // int32_t
    constexpr std::ptrdiff_t m_bAutoSwitchTo = 0x210; // bool
    constexpr std::ptrdiff_t m_bAutoSwitchFrom = 0x211; // bool
    constexpr std::ptrdiff_t m_iRumbleEffect = 0x214; // RumbleEffect_t
    constexpr std::ptrdiff_t m_aShootSounds = 0x218; // CUtlMap<WeaponSound_t,CSoundEventName>
    constexpr std::ptrdiff_t m_iSlot = 0x238; // int32_t
    constexpr std::ptrdiff_t m_iPosition = 0x23C; // int32_t
}

namespace CBaseProp {
    constexpr std::ptrdiff_t m_bModelOverrodeBlockLOS = 0x890; // bool
    constexpr std::ptrdiff_t m_iShapeType = 0x894; // int32_t
    constexpr std::ptrdiff_t m_bConformToCollisionBounds = 0x898; // bool
    constexpr std::ptrdiff_t m_mPreferredCatchTransform = 0x89C; // matrix3x4_t
}

namespace CBasePropDoor {
    constexpr std::ptrdiff_t m_flAutoReturnDelay = 0xB18; // float
    constexpr std::ptrdiff_t m_hDoorList = 0xB20; // CUtlVector<CHandle<CBasePropDoor>>
    constexpr std::ptrdiff_t m_nHardwareType = 0xB38; // int32_t
    constexpr std::ptrdiff_t m_bNeedsHardware = 0xB3C; // bool
    constexpr std::ptrdiff_t m_eDoorState = 0xB40; // DoorState_t
    constexpr std::ptrdiff_t m_bLocked = 0xB44; // bool
    constexpr std::ptrdiff_t m_closedPosition = 0xB48; // Vector
    constexpr std::ptrdiff_t m_closedAngles = 0xB54; // QAngle
    constexpr std::ptrdiff_t m_hBlocker = 0xB60; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bFirstBlocked = 0xB64; // bool
    constexpr std::ptrdiff_t m_ls = 0xB68; // locksound_t
    constexpr std::ptrdiff_t m_bForceClosed = 0xB88; // bool
    constexpr std::ptrdiff_t m_vecLatchWorldPosition = 0xB8C; // Vector
    constexpr std::ptrdiff_t m_hActivator = 0xB98; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_SoundMoving = 0xBA8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_SoundOpen = 0xBB0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_SoundClose = 0xBB8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_SoundLock = 0xBC0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_SoundUnlock = 0xBC8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_SoundLatch = 0xBD0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_SoundPound = 0xBD8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_SoundJiggle = 0xBE0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_SoundLockedAnim = 0xBE8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_numCloseAttempts = 0xBF0; // int32_t
    constexpr std::ptrdiff_t m_nPhysicsMaterial = 0xBF4; // CUtlStringToken
    constexpr std::ptrdiff_t m_SlaveName = 0xBF8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hMaster = 0xC00; // CHandle<CBasePropDoor>
    constexpr std::ptrdiff_t m_OnBlockedClosing = 0xC08; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnBlockedOpening = 0xC30; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnUnblockedClosing = 0xC58; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnUnblockedOpening = 0xC80; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFullyClosed = 0xCA8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFullyOpen = 0xCD0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnClose = 0xCF8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnOpen = 0xD20; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnLockedUse = 0xD48; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnAjarOpen = 0xD70; // CEntityIOOutput
}

namespace CBaseToggle {
    constexpr std::ptrdiff_t m_toggle_state = 0x700; // TOGGLE_STATE
    constexpr std::ptrdiff_t m_flMoveDistance = 0x704; // float
    constexpr std::ptrdiff_t m_flWait = 0x708; // float
    constexpr std::ptrdiff_t m_flLip = 0x70C; // float
    constexpr std::ptrdiff_t m_bAlwaysFireBlockedOutputs = 0x710; // bool
    constexpr std::ptrdiff_t m_vecPosition1 = 0x714; // Vector
    constexpr std::ptrdiff_t m_vecPosition2 = 0x720; // Vector
    constexpr std::ptrdiff_t m_vecMoveAng = 0x72C; // QAngle
    constexpr std::ptrdiff_t m_vecAngle1 = 0x738; // QAngle
    constexpr std::ptrdiff_t m_vecAngle2 = 0x744; // QAngle
    constexpr std::ptrdiff_t m_flHeight = 0x750; // float
    constexpr std::ptrdiff_t m_hActivator = 0x754; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_vecFinalDest = 0x758; // Vector
    constexpr std::ptrdiff_t m_vecFinalAngle = 0x764; // QAngle
    constexpr std::ptrdiff_t m_movementType = 0x770; // int32_t
    constexpr std::ptrdiff_t m_sMaster = 0x778; // CUtlSymbolLarge
}

namespace CBaseTrigger {
    constexpr std::ptrdiff_t m_bDisabled = 0x780; // bool
    constexpr std::ptrdiff_t m_iFilterName = 0x788; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hFilter = 0x790; // CHandle<CBaseFilter>
    constexpr std::ptrdiff_t m_OnStartTouch = 0x798; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnStartTouchAll = 0x7C0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnEndTouch = 0x7E8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnEndTouchAll = 0x810; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnTouching = 0x838; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnNotTouching = 0x860; // CEntityIOOutput
    constexpr std::ptrdiff_t m_hTouchingEntities = 0x888; // CUtlVector<CHandle<CBaseEntity>>
    constexpr std::ptrdiff_t m_bClientSidePredicted = 0x8A0; // bool
}

namespace CBaseViewModel {
    constexpr std::ptrdiff_t m_vecLastFacing = 0x898; // Vector
    constexpr std::ptrdiff_t m_nViewModelIndex = 0x8A4; // uint32_t
    constexpr std::ptrdiff_t m_nAnimationParity = 0x8A8; // uint32_t
    constexpr std::ptrdiff_t m_flAnimationStartTime = 0x8AC; // float
    constexpr std::ptrdiff_t m_hWeapon = 0x8B0; // CHandle<CBasePlayerWeapon>
    constexpr std::ptrdiff_t m_sVMName = 0x8B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_sAnimationPrefix = 0x8C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hOldLayerSequence = 0x8C8; // HSequence
    constexpr std::ptrdiff_t m_oldLayer = 0x8CC; // int32_t
    constexpr std::ptrdiff_t m_oldLayerStartTime = 0x8D0; // float
    constexpr std::ptrdiff_t m_hControlPanel = 0x8D4; // CHandle<CBaseEntity>
}

namespace CBeam {
    constexpr std::ptrdiff_t m_flFrameRate = 0x700; // float
    constexpr std::ptrdiff_t m_flHDRColorScale = 0x704; // float
    constexpr std::ptrdiff_t m_flFireTime = 0x708; // GameTime_t
    constexpr std::ptrdiff_t m_flDamage = 0x70C; // float
    constexpr std::ptrdiff_t m_nNumBeamEnts = 0x710; // uint8_t
    constexpr std::ptrdiff_t m_hBaseMaterial = 0x718; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_nHaloIndex = 0x720; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_nBeamType = 0x728; // BeamType_t
    constexpr std::ptrdiff_t m_nBeamFlags = 0x72C; // uint32_t
    constexpr std::ptrdiff_t m_hAttachEntity = 0x730; // CHandle<CBaseEntity>[10]
    constexpr std::ptrdiff_t m_nAttachIndex = 0x758; // AttachmentHandle_t[10]
    constexpr std::ptrdiff_t m_fWidth = 0x764; // float
    constexpr std::ptrdiff_t m_fEndWidth = 0x768; // float
    constexpr std::ptrdiff_t m_fFadeLength = 0x76C; // float
    constexpr std::ptrdiff_t m_fHaloScale = 0x770; // float
    constexpr std::ptrdiff_t m_fAmplitude = 0x774; // float
    constexpr std::ptrdiff_t m_fStartFrame = 0x778; // float
    constexpr std::ptrdiff_t m_fSpeed = 0x77C; // float
    constexpr std::ptrdiff_t m_flFrame = 0x780; // float
    constexpr std::ptrdiff_t m_nClipStyle = 0x784; // BeamClipStyle_t
    constexpr std::ptrdiff_t m_bTurnedOff = 0x788; // bool
    constexpr std::ptrdiff_t m_vecEndPos = 0x78C; // Vector
    constexpr std::ptrdiff_t m_hEndEntity = 0x798; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_nDissolveType = 0x79C; // int32_t
}

namespace CBlood {
    constexpr std::ptrdiff_t m_vecSprayAngles = 0x4B0; // QAngle
    constexpr std::ptrdiff_t m_vecSprayDir = 0x4BC; // Vector
    constexpr std::ptrdiff_t m_flAmount = 0x4C8; // float
    constexpr std::ptrdiff_t m_Color = 0x4CC; // int32_t
}

namespace CBodyComponent {
    constexpr std::ptrdiff_t m_pSceneNode = 0x8; // CGameSceneNode*
    constexpr std::ptrdiff_t __m_pChainEntity = 0x20; // CNetworkVarChainer
}

namespace CBodyComponentBaseAnimGraph {
    constexpr std::ptrdiff_t m_animationController = 0x480; // CBaseAnimGraphController
    constexpr std::ptrdiff_t __m_pChainEntity = 0x760; // CNetworkVarChainer
}

namespace CBodyComponentBaseModelEntity {
    constexpr std::ptrdiff_t __m_pChainEntity = 0x480; // CNetworkVarChainer
}

namespace CBodyComponentPoint {
    constexpr std::ptrdiff_t m_sceneNode = 0x50; // CGameSceneNode
    constexpr std::ptrdiff_t __m_pChainEntity = 0x1A0; // CNetworkVarChainer
}

namespace CBodyComponentSkeletonInstance {
    constexpr std::ptrdiff_t m_skeletonInstance = 0x50; // CSkeletonInstance
    constexpr std::ptrdiff_t __m_pChainEntity = 0x450; // CNetworkVarChainer
}

namespace CBombTarget {
    constexpr std::ptrdiff_t m_OnBombExplode = 0x8A8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnBombPlanted = 0x8D0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnBombDefused = 0x8F8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bIsBombSiteB = 0x920; // bool
    constexpr std::ptrdiff_t m_bIsHeistBombTarget = 0x921; // bool
    constexpr std::ptrdiff_t m_bBombPlantedHere = 0x922; // bool
    constexpr std::ptrdiff_t m_szMountTarget = 0x928; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hInstructorHint = 0x930; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_nBombSiteDesignation = 0x934; // int32_t
}

namespace CBot {
    constexpr std::ptrdiff_t m_pController = 0x10; // CCSPlayerController*
    constexpr std::ptrdiff_t m_pPlayer = 0x18; // CCSPlayerPawn*
    constexpr std::ptrdiff_t m_bHasSpawned = 0x20; // bool
    constexpr std::ptrdiff_t m_id = 0x24; // uint32_t
    constexpr std::ptrdiff_t m_isRunning = 0xB8; // bool
    constexpr std::ptrdiff_t m_isCrouching = 0xB9; // bool
    constexpr std::ptrdiff_t m_forwardSpeed = 0xBC; // float
    constexpr std::ptrdiff_t m_leftSpeed = 0xC0; // float
    constexpr std::ptrdiff_t m_verticalSpeed = 0xC4; // float
    constexpr std::ptrdiff_t m_buttonFlags = 0xC8; // uint64_t
    constexpr std::ptrdiff_t m_jumpTimestamp = 0xD0; // float
    constexpr std::ptrdiff_t m_viewForward = 0xD4; // Vector
    constexpr std::ptrdiff_t m_postureStackIndex = 0xF0; // int32_t
}

namespace CBreakable {
    constexpr std::ptrdiff_t m_Material = 0x710; // Materials
    constexpr std::ptrdiff_t m_hBreaker = 0x714; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_Explosion = 0x718; // Explosions
    constexpr std::ptrdiff_t m_iszSpawnObject = 0x720; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flPressureDelay = 0x728; // float
    constexpr std::ptrdiff_t m_iMinHealthDmg = 0x72C; // int32_t
    constexpr std::ptrdiff_t m_iszPropData = 0x730; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_impactEnergyScale = 0x738; // float
    constexpr std::ptrdiff_t m_nOverrideBlockLOS = 0x73C; // EOverrideBlockLOS_t
    constexpr std::ptrdiff_t m_OnBreak = 0x740; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnHealthChanged = 0x768; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_flDmgModBullet = 0x790; // float
    constexpr std::ptrdiff_t m_flDmgModClub = 0x794; // float
    constexpr std::ptrdiff_t m_flDmgModExplosive = 0x798; // float
    constexpr std::ptrdiff_t m_flDmgModFire = 0x79C; // float
    constexpr std::ptrdiff_t m_iszPhysicsDamageTableName = 0x7A0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszBasePropData = 0x7A8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iInteractions = 0x7B0; // int32_t
    constexpr std::ptrdiff_t m_PerformanceMode = 0x7B4; // PerformanceMode_t
    constexpr std::ptrdiff_t m_hPhysicsAttacker = 0x7B8; // CHandle<CBasePlayerPawn>
    constexpr std::ptrdiff_t m_flLastPhysicsInfluenceTime = 0x7BC; // GameTime_t
}

namespace CBreakableProp {
    constexpr std::ptrdiff_t m_OnBreak = 0x8E0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnHealthChanged = 0x908; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnTakeDamage = 0x930; // CEntityIOOutput
    constexpr std::ptrdiff_t m_impactEnergyScale = 0x958; // float
    constexpr std::ptrdiff_t m_iMinHealthDmg = 0x95C; // int32_t
    constexpr std::ptrdiff_t m_preferredCarryAngles = 0x960; // QAngle
    constexpr std::ptrdiff_t m_flPressureDelay = 0x96C; // float
    constexpr std::ptrdiff_t m_hBreaker = 0x970; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_PerformanceMode = 0x974; // PerformanceMode_t
    constexpr std::ptrdiff_t m_flDmgModBullet = 0x978; // float
    constexpr std::ptrdiff_t m_flDmgModClub = 0x97C; // float
    constexpr std::ptrdiff_t m_flDmgModExplosive = 0x980; // float
    constexpr std::ptrdiff_t m_flDmgModFire = 0x984; // float
    constexpr std::ptrdiff_t m_iszPhysicsDamageTableName = 0x988; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszBasePropData = 0x990; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iInteractions = 0x998; // int32_t
    constexpr std::ptrdiff_t m_flPreventDamageBeforeTime = 0x99C; // GameTime_t
    constexpr std::ptrdiff_t m_bHasBreakPiecesOrCommands = 0x9A0; // bool
    constexpr std::ptrdiff_t m_explodeDamage = 0x9A4; // float
    constexpr std::ptrdiff_t m_explodeRadius = 0x9A8; // float
    constexpr std::ptrdiff_t m_explosionDelay = 0x9B0; // float
    constexpr std::ptrdiff_t m_explosionBuildupSound = 0x9B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_explosionCustomEffect = 0x9C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_explosionCustomSound = 0x9C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_explosionModifier = 0x9D0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hPhysicsAttacker = 0x9D8; // CHandle<CBasePlayerPawn>
    constexpr std::ptrdiff_t m_flLastPhysicsInfluenceTime = 0x9DC; // GameTime_t
    constexpr std::ptrdiff_t m_bOriginalBlockLOS = 0x9E0; // bool
    constexpr std::ptrdiff_t m_flDefaultFadeScale = 0x9E4; // float
    constexpr std::ptrdiff_t m_hLastAttacker = 0x9E8; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hFlareEnt = 0x9EC; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bUsePuntSound = 0x9F0; // bool
    constexpr std::ptrdiff_t m_iszPuntSound = 0x9F8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_noGhostCollision = 0xA00; // bool
}

namespace CBreakableStageHelper {
    constexpr std::ptrdiff_t m_nCurrentStage = 0x8; // int32_t
    constexpr std::ptrdiff_t m_nStageCount = 0xC; // int32_t
}

namespace CBtActionAim {
    constexpr std::ptrdiff_t m_szSensorInputKey = 0x68; // CUtlString
    constexpr std::ptrdiff_t m_szAimReadyKey = 0x80; // CUtlString
    constexpr std::ptrdiff_t m_flZoomCooldownTimestamp = 0x88; // float
    constexpr std::ptrdiff_t m_bDoneAiming = 0x8C; // bool
    constexpr std::ptrdiff_t m_flLerpStartTime = 0x90; // float
    constexpr std::ptrdiff_t m_flNextLookTargetLerpTime = 0x94; // float
    constexpr std::ptrdiff_t m_flPenaltyReductionRatio = 0x98; // float
    constexpr std::ptrdiff_t m_NextLookTarget = 0x9C; // QAngle
    constexpr std::ptrdiff_t m_AimTimer = 0xA8; // CountdownTimer
    constexpr std::ptrdiff_t m_SniperHoldTimer = 0xC0; // CountdownTimer
    constexpr std::ptrdiff_t m_FocusIntervalTimer = 0xD8; // CountdownTimer
    constexpr std::ptrdiff_t m_bAcquired = 0xF0; // bool
}

namespace CBtActionCombatPositioning {
    constexpr std::ptrdiff_t m_szSensorInputKey = 0x68; // CUtlString
    constexpr std::ptrdiff_t m_szIsAttackingKey = 0x80; // CUtlString
    constexpr std::ptrdiff_t m_ActionTimer = 0x88; // CountdownTimer
    constexpr std::ptrdiff_t m_bCrouching = 0xA0; // bool
}

namespace CBtActionMoveTo {
    constexpr std::ptrdiff_t m_szDestinationInputKey = 0x60; // CUtlString
    constexpr std::ptrdiff_t m_szHidingSpotInputKey = 0x68; // CUtlString
    constexpr std::ptrdiff_t m_szThreatInputKey = 0x70; // CUtlString
    constexpr std::ptrdiff_t m_vecDestination = 0x78; // Vector
    constexpr std::ptrdiff_t m_bAutoLookAdjust = 0x84; // bool
    constexpr std::ptrdiff_t m_bComputePath = 0x85; // bool
    constexpr std::ptrdiff_t m_flDamagingAreasPenaltyCost = 0x88; // float
    constexpr std::ptrdiff_t m_CheckApproximateCornersTimer = 0x90; // CountdownTimer
    constexpr std::ptrdiff_t m_CheckHighPriorityItem = 0xA8; // CountdownTimer
    constexpr std::ptrdiff_t m_RepathTimer = 0xC0; // CountdownTimer
    constexpr std::ptrdiff_t m_flArrivalEpsilon = 0xD8; // float
    constexpr std::ptrdiff_t m_flAdditionalArrivalEpsilon2D = 0xDC; // float
    constexpr std::ptrdiff_t m_flHidingSpotCheckDistanceThreshold = 0xE0; // float
    constexpr std::ptrdiff_t m_flNearestAreaDistanceThreshold = 0xE4; // float
}

namespace CBtActionParachutePositioning {
    constexpr std::ptrdiff_t m_ActionTimer = 0x58; // CountdownTimer
}

namespace CBtNodeCondition {
    constexpr std::ptrdiff_t m_bNegated = 0x58; // bool
}

namespace CBtNodeConditionInactive {
    constexpr std::ptrdiff_t m_flRoundStartThresholdSeconds = 0x78; // float
    constexpr std::ptrdiff_t m_flSensorInactivityThresholdSeconds = 0x7C; // float
    constexpr std::ptrdiff_t m_SensorInactivityTimer = 0x80; // CountdownTimer
}

namespace CBubbling {
    constexpr std::ptrdiff_t m_density = 0x700; // int32_t
    constexpr std::ptrdiff_t m_frequency = 0x704; // int32_t
    constexpr std::ptrdiff_t m_state = 0x708; // int32_t
}

namespace CBuoyancyHelper {
    constexpr std::ptrdiff_t m_flFluidDensity = 0x18; // float
}

namespace CBuyZone {
    constexpr std::ptrdiff_t m_LegacyTeamNum = 0x8A8; // int32_t
}

namespace CC4 {
    constexpr std::ptrdiff_t m_vecLastValidPlayerHeldPosition = 0xE20; // Vector
    constexpr std::ptrdiff_t m_vecLastValidDroppedPosition = 0xE2C; // Vector
    constexpr std::ptrdiff_t m_bDoValidDroppedPositionCheck = 0xE38; // bool
    constexpr std::ptrdiff_t m_bStartedArming = 0xE39; // bool
    constexpr std::ptrdiff_t m_fArmedTime = 0xE3C; // GameTime_t
    constexpr std::ptrdiff_t m_bBombPlacedAnimation = 0xE40; // bool
    constexpr std::ptrdiff_t m_bIsPlantingViaUse = 0xE41; // bool
    constexpr std::ptrdiff_t m_entitySpottedState = 0xE48; // EntitySpottedState_t
    constexpr std::ptrdiff_t m_nSpotRules = 0xE60; // int32_t
    constexpr std::ptrdiff_t m_bPlayedArmingBeeps = 0xE64; // bool[7]
    constexpr std::ptrdiff_t m_bBombPlanted = 0xE6B; // bool
    constexpr std::ptrdiff_t m_bDroppedFromDeath = 0xE6C; // bool
}

namespace CCSBot {
    constexpr std::ptrdiff_t m_lastCoopSpawnPoint = 0xF8; // CHandle<SpawnPointCoopEnemy>
    constexpr std::ptrdiff_t m_eyePosition = 0x108; // Vector
    constexpr std::ptrdiff_t m_name = 0x114; // char[64]
    constexpr std::ptrdiff_t m_combatRange = 0x154; // float
    constexpr std::ptrdiff_t m_isRogue = 0x158; // bool
    constexpr std::ptrdiff_t m_rogueTimer = 0x160; // CountdownTimer
    constexpr std::ptrdiff_t m_diedLastRound = 0x17C; // bool
    constexpr std::ptrdiff_t m_safeTime = 0x180; // float
    constexpr std::ptrdiff_t m_wasSafe = 0x184; // bool
    constexpr std::ptrdiff_t m_blindFire = 0x18C; // bool
    constexpr std::ptrdiff_t m_surpriseTimer = 0x190; // CountdownTimer
    constexpr std::ptrdiff_t m_bAllowActive = 0x1A8; // bool
    constexpr std::ptrdiff_t m_isFollowing = 0x1A9; // bool
    constexpr std::ptrdiff_t m_leader = 0x1AC; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_followTimestamp = 0x1B0; // float
    constexpr std::ptrdiff_t m_allowAutoFollowTime = 0x1B4; // float
    constexpr std::ptrdiff_t m_hurryTimer = 0x1B8; // CountdownTimer
    constexpr std::ptrdiff_t m_alertTimer = 0x1D0; // CountdownTimer
    constexpr std::ptrdiff_t m_sneakTimer = 0x1E8; // CountdownTimer
    constexpr std::ptrdiff_t m_panicTimer = 0x200; // CountdownTimer
    constexpr std::ptrdiff_t m_stateTimestamp = 0x4D0; // float
    constexpr std::ptrdiff_t m_isAttacking = 0x4D4; // bool
    constexpr std::ptrdiff_t m_isOpeningDoor = 0x4D5; // bool
    constexpr std::ptrdiff_t m_taskEntity = 0x4DC; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_goalPosition = 0x4EC; // Vector
    constexpr std::ptrdiff_t m_goalEntity = 0x4F8; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_avoid = 0x4FC; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_avoidTimestamp = 0x500; // float
    constexpr std::ptrdiff_t m_isStopping = 0x504; // bool
    constexpr std::ptrdiff_t m_hasVisitedEnemySpawn = 0x505; // bool
    constexpr std::ptrdiff_t m_stillTimer = 0x508; // IntervalTimer
    constexpr std::ptrdiff_t m_bEyeAnglesUnderPathFinderControl = 0x518; // bool
    constexpr std::ptrdiff_t m_pathIndex = 0x6610; // int32_t
    constexpr std::ptrdiff_t m_areaEnteredTimestamp = 0x6614; // GameTime_t
    constexpr std::ptrdiff_t m_repathTimer = 0x6618; // CountdownTimer
    constexpr std::ptrdiff_t m_avoidFriendTimer = 0x6630; // CountdownTimer
    constexpr std::ptrdiff_t m_isFriendInTheWay = 0x6648; // bool
    constexpr std::ptrdiff_t m_politeTimer = 0x6650; // CountdownTimer
    constexpr std::ptrdiff_t m_isWaitingBehindFriend = 0x6668; // bool
    constexpr std::ptrdiff_t m_pathLadderEnd = 0x6694; // float
    constexpr std::ptrdiff_t m_mustRunTimer = 0x66E0; // CountdownTimer
    constexpr std::ptrdiff_t m_waitTimer = 0x66F8; // CountdownTimer
    constexpr std::ptrdiff_t m_updateTravelDistanceTimer = 0x6710; // CountdownTimer
    constexpr std::ptrdiff_t m_playerTravelDistance = 0x6728; // float[64]
    constexpr std::ptrdiff_t m_travelDistancePhase = 0x6828; // uint8_t
    constexpr std::ptrdiff_t m_hostageEscortCount = 0x69C0; // uint8_t
    constexpr std::ptrdiff_t m_hostageEscortCountTimestamp = 0x69C4; // float
    constexpr std::ptrdiff_t m_desiredTeam = 0x69C8; // int32_t
    constexpr std::ptrdiff_t m_hasJoined = 0x69CC; // bool
    constexpr std::ptrdiff_t m_isWaitingForHostage = 0x69CD; // bool
    constexpr std::ptrdiff_t m_inhibitWaitingForHostageTimer = 0x69D0; // CountdownTimer
    constexpr std::ptrdiff_t m_waitForHostageTimer = 0x69E8; // CountdownTimer
    constexpr std::ptrdiff_t m_noisePosition = 0x6A00; // Vector
    constexpr std::ptrdiff_t m_noiseTravelDistance = 0x6A0C; // float
    constexpr std::ptrdiff_t m_noiseTimestamp = 0x6A10; // float
    constexpr std::ptrdiff_t m_noiseSource = 0x6A18; // CCSPlayerPawn*
    constexpr std::ptrdiff_t m_noiseBendTimer = 0x6A30; // CountdownTimer
    constexpr std::ptrdiff_t m_bentNoisePosition = 0x6A48; // Vector
    constexpr std::ptrdiff_t m_bendNoisePositionValid = 0x6A54; // bool
    constexpr std::ptrdiff_t m_lookAroundStateTimestamp = 0x6A58; // float
    constexpr std::ptrdiff_t m_lookAheadAngle = 0x6A5C; // float
    constexpr std::ptrdiff_t m_forwardAngle = 0x6A60; // float
    constexpr std::ptrdiff_t m_inhibitLookAroundTimestamp = 0x6A64; // float
    constexpr std::ptrdiff_t m_lookAtSpot = 0x6A6C; // Vector
    constexpr std::ptrdiff_t m_lookAtSpotDuration = 0x6A7C; // float
    constexpr std::ptrdiff_t m_lookAtSpotTimestamp = 0x6A80; // float
    constexpr std::ptrdiff_t m_lookAtSpotAngleTolerance = 0x6A84; // float
    constexpr std::ptrdiff_t m_lookAtSpotClearIfClose = 0x6A88; // bool
    constexpr std::ptrdiff_t m_lookAtSpotAttack = 0x6A89; // bool
    constexpr std::ptrdiff_t m_lookAtDesc = 0x6A90; // char*
    constexpr std::ptrdiff_t m_peripheralTimestamp = 0x6A98; // float
    constexpr std::ptrdiff_t m_approachPointCount = 0x6C20; // uint8_t
    constexpr std::ptrdiff_t m_approachPointViewPosition = 0x6C24; // Vector
    constexpr std::ptrdiff_t m_viewSteadyTimer = 0x6C30; // IntervalTimer
    constexpr std::ptrdiff_t m_tossGrenadeTimer = 0x6C48; // CountdownTimer
    constexpr std::ptrdiff_t m_isAvoidingGrenade = 0x6C68; // CountdownTimer
    constexpr std::ptrdiff_t m_spotCheckTimestamp = 0x6C88; // float
    constexpr std::ptrdiff_t m_checkedHidingSpotCount = 0x7090; // int32_t
    constexpr std::ptrdiff_t m_lookPitch = 0x7094; // float
    constexpr std::ptrdiff_t m_lookPitchVel = 0x7098; // float
    constexpr std::ptrdiff_t m_lookYaw = 0x709C; // float
    constexpr std::ptrdiff_t m_lookYawVel = 0x70A0; // float
    constexpr std::ptrdiff_t m_targetSpot = 0x70A4; // Vector
    constexpr std::ptrdiff_t m_targetSpotVelocity = 0x70B0; // Vector
    constexpr std::ptrdiff_t m_targetSpotPredicted = 0x70BC; // Vector
    constexpr std::ptrdiff_t m_aimError = 0x70C8; // QAngle
    constexpr std::ptrdiff_t m_aimGoal = 0x70D4; // QAngle
    constexpr std::ptrdiff_t m_targetSpotTime = 0x70E0; // GameTime_t
    constexpr std::ptrdiff_t m_aimFocus = 0x70E4; // float
    constexpr std::ptrdiff_t m_aimFocusInterval = 0x70E8; // float
    constexpr std::ptrdiff_t m_aimFocusNextUpdate = 0x70EC; // GameTime_t
    constexpr std::ptrdiff_t m_ignoreEnemiesTimer = 0x70F8; // CountdownTimer
    constexpr std::ptrdiff_t m_enemy = 0x7110; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_isEnemyVisible = 0x7114; // bool
    constexpr std::ptrdiff_t m_visibleEnemyParts = 0x7115; // uint8_t
    constexpr std::ptrdiff_t m_lastEnemyPosition = 0x7118; // Vector
    constexpr std::ptrdiff_t m_lastSawEnemyTimestamp = 0x7124; // float
    constexpr std::ptrdiff_t m_firstSawEnemyTimestamp = 0x7128; // float
    constexpr std::ptrdiff_t m_currentEnemyAcquireTimestamp = 0x712C; // float
    constexpr std::ptrdiff_t m_enemyDeathTimestamp = 0x7130; // float
    constexpr std::ptrdiff_t m_friendDeathTimestamp = 0x7134; // float
    constexpr std::ptrdiff_t m_isLastEnemyDead = 0x7138; // bool
    constexpr std::ptrdiff_t m_nearbyEnemyCount = 0x713C; // int32_t
    constexpr std::ptrdiff_t m_bomber = 0x7348; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_nearbyFriendCount = 0x734C; // int32_t
    constexpr std::ptrdiff_t m_closestVisibleFriend = 0x7350; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_closestVisibleHumanFriend = 0x7354; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_attentionInterval = 0x7358; // IntervalTimer
    constexpr std::ptrdiff_t m_attacker = 0x7368; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_attackedTimestamp = 0x736C; // float
    constexpr std::ptrdiff_t m_burnedByFlamesTimer = 0x7370; // IntervalTimer
    constexpr std::ptrdiff_t m_lastVictimID = 0x7380; // int32_t
    constexpr std::ptrdiff_t m_isAimingAtEnemy = 0x7384; // bool
    constexpr std::ptrdiff_t m_isRapidFiring = 0x7385; // bool
    constexpr std::ptrdiff_t m_equipTimer = 0x7388; // IntervalTimer
    constexpr std::ptrdiff_t m_zoomTimer = 0x7398; // CountdownTimer
    constexpr std::ptrdiff_t m_fireWeaponTimestamp = 0x73B0; // GameTime_t
    constexpr std::ptrdiff_t m_lookForWeaponsOnGroundTimer = 0x73B8; // CountdownTimer
    constexpr std::ptrdiff_t m_bIsSleeping = 0x73D0; // bool
    constexpr std::ptrdiff_t m_isEnemySniperVisible = 0x73D1; // bool
    constexpr std::ptrdiff_t m_sawEnemySniperTimer = 0x73D8; // CountdownTimer
    constexpr std::ptrdiff_t m_enemyQueueIndex = 0x7490; // uint8_t
    constexpr std::ptrdiff_t m_enemyQueueCount = 0x7491; // uint8_t
    constexpr std::ptrdiff_t m_enemyQueueAttendIndex = 0x7492; // uint8_t
    constexpr std::ptrdiff_t m_isStuck = 0x7493; // bool
    constexpr std::ptrdiff_t m_stuckTimestamp = 0x7494; // GameTime_t
    constexpr std::ptrdiff_t m_stuckSpot = 0x7498; // Vector
    constexpr std::ptrdiff_t m_wiggleTimer = 0x74A8; // CountdownTimer
    constexpr std::ptrdiff_t m_stuckJumpTimer = 0x74C0; // CountdownTimer
    constexpr std::ptrdiff_t m_nextCleanupCheckTimestamp = 0x74D8; // GameTime_t
    constexpr std::ptrdiff_t m_avgVel = 0x74DC; // float[10]
    constexpr std::ptrdiff_t m_avgVelIndex = 0x7504; // int32_t
    constexpr std::ptrdiff_t m_avgVelCount = 0x7508; // int32_t
    constexpr std::ptrdiff_t m_lastOrigin = 0x750C; // Vector
    constexpr std::ptrdiff_t m_lastRadioRecievedTimestamp = 0x751C; // float
    constexpr std::ptrdiff_t m_lastRadioSentTimestamp = 0x7520; // float
    constexpr std::ptrdiff_t m_radioSubject = 0x7524; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_radioPosition = 0x7528; // Vector
    constexpr std::ptrdiff_t m_voiceEndTimestamp = 0x7534; // float
    constexpr std::ptrdiff_t m_lastValidReactionQueueFrame = 0x7540; // int32_t
}

namespace CCSGOViewModel {
    constexpr std::ptrdiff_t m_bShouldIgnoreOffsetAndAccuracy = 0x8D8; // bool
    constexpr std::ptrdiff_t m_nWeaponParity = 0x8DC; // uint32_t
    constexpr std::ptrdiff_t m_nOldWeaponParity = 0x8E0; // uint32_t
}

namespace CCSGO_TeamPreviewCharacterPosition {
    constexpr std::ptrdiff_t m_nVariant = 0x4B0; // int32_t
    constexpr std::ptrdiff_t m_nRandom = 0x4B4; // int32_t
    constexpr std::ptrdiff_t m_nOrdinal = 0x4B8; // int32_t
    constexpr std::ptrdiff_t m_sWeaponName = 0x4C0; // CUtlString
    constexpr std::ptrdiff_t m_xuid = 0x4C8; // uint64_t
    constexpr std::ptrdiff_t m_agentItem = 0x4D0; // CEconItemView
    constexpr std::ptrdiff_t m_glovesItem = 0x748; // CEconItemView
    constexpr std::ptrdiff_t m_weaponItem = 0x9C0; // CEconItemView
}

namespace CCSGameModeRules {
    constexpr std::ptrdiff_t __m_pChainEntity = 0x8; // CNetworkVarChainer
}

namespace CCSGameModeRules_Deathmatch {
    constexpr std::ptrdiff_t m_bFirstThink = 0x30; // bool
    constexpr std::ptrdiff_t m_bFirstThinkAfterConnected = 0x31; // bool
    constexpr std::ptrdiff_t m_flDMBonusStartTime = 0x34; // GameTime_t
    constexpr std::ptrdiff_t m_flDMBonusTimeLength = 0x38; // float
    constexpr std::ptrdiff_t m_nDMBonusWeaponLoadoutSlot = 0x3C; // int16_t
}

namespace CCSGameRules {
    constexpr std::ptrdiff_t __m_pChainEntity = 0x98; // CNetworkVarChainer
    constexpr std::ptrdiff_t m_coopMissionManager = 0xC0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bFreezePeriod = 0xC4; // bool
    constexpr std::ptrdiff_t m_bWarmupPeriod = 0xC5; // bool
    constexpr std::ptrdiff_t m_fWarmupPeriodEnd = 0xC8; // GameTime_t
    constexpr std::ptrdiff_t m_fWarmupPeriodStart = 0xCC; // GameTime_t
    constexpr std::ptrdiff_t m_nTotalPausedTicks = 0xD0; // int32_t
    constexpr std::ptrdiff_t m_nPauseStartTick = 0xD4; // int32_t
    constexpr std::ptrdiff_t m_bServerPaused = 0xD8; // bool
    constexpr std::ptrdiff_t m_bGamePaused = 0xD9; // bool
    constexpr std::ptrdiff_t m_bTerroristTimeOutActive = 0xDA; // bool
    constexpr std::ptrdiff_t m_bCTTimeOutActive = 0xDB; // bool
    constexpr std::ptrdiff_t m_flTerroristTimeOutRemaining = 0xDC; // float
    constexpr std::ptrdiff_t m_flCTTimeOutRemaining = 0xE0; // float
    constexpr std::ptrdiff_t m_nTerroristTimeOuts = 0xE4; // int32_t
    constexpr std::ptrdiff_t m_nCTTimeOuts = 0xE8; // int32_t
    constexpr std::ptrdiff_t m_bTechnicalTimeOut = 0xEC; // bool
    constexpr std::ptrdiff_t m_bMatchWaitingForResume = 0xED; // bool
    constexpr std::ptrdiff_t m_iRoundTime = 0xF0; // int32_t
    constexpr std::ptrdiff_t m_fMatchStartTime = 0xF4; // float
    constexpr std::ptrdiff_t m_fRoundStartTime = 0xF8; // GameTime_t
    constexpr std::ptrdiff_t m_flRestartRoundTime = 0xFC; // GameTime_t
    constexpr std::ptrdiff_t m_bGameRestart = 0x100; // bool
    constexpr std::ptrdiff_t m_flGameStartTime = 0x104; // float
    constexpr std::ptrdiff_t m_timeUntilNextPhaseStarts = 0x108; // float
    constexpr std::ptrdiff_t m_gamePhase = 0x10C; // int32_t
    constexpr std::ptrdiff_t m_totalRoundsPlayed = 0x110; // int32_t
    constexpr std::ptrdiff_t m_nRoundsPlayedThisPhase = 0x114; // int32_t
    constexpr std::ptrdiff_t m_nOvertimePlaying = 0x118; // int32_t
    constexpr std::ptrdiff_t m_iHostagesRemaining = 0x11C; // int32_t
    constexpr std::ptrdiff_t m_bAnyHostageReached = 0x120; // bool
    constexpr std::ptrdiff_t m_bMapHasBombTarget = 0x121; // bool
    constexpr std::ptrdiff_t m_bMapHasRescueZone = 0x122; // bool
    constexpr std::ptrdiff_t m_bMapHasBuyZone = 0x123; // bool
    constexpr std::ptrdiff_t m_bIsQueuedMatchmaking = 0x124; // bool
    constexpr std::ptrdiff_t m_nQueuedMatchmakingMode = 0x128; // int32_t
    constexpr std::ptrdiff_t m_bIsValveDS = 0x12C; // bool
    constexpr std::ptrdiff_t m_bLogoMap = 0x12D; // bool
    constexpr std::ptrdiff_t m_bPlayAllStepSoundsOnServer = 0x12E; // bool
    constexpr std::ptrdiff_t m_iSpectatorSlotCount = 0x130; // int32_t
    constexpr std::ptrdiff_t m_MatchDevice = 0x134; // int32_t
    constexpr std::ptrdiff_t m_bHasMatchStarted = 0x138; // bool
    constexpr std::ptrdiff_t m_nNextMapInMapgroup = 0x13C; // int32_t
    constexpr std::ptrdiff_t m_szTournamentEventName = 0x140; // char[512]
    constexpr std::ptrdiff_t m_szTournamentEventStage = 0x340; // char[512]
    constexpr std::ptrdiff_t m_szMatchStatTxt = 0x540; // char[512]
    constexpr std::ptrdiff_t m_szTournamentPredictionsTxt = 0x740; // char[512]
    constexpr std::ptrdiff_t m_nTournamentPredictionsPct = 0x940; // int32_t
    constexpr std::ptrdiff_t m_flCMMItemDropRevealStartTime = 0x944; // GameTime_t
    constexpr std::ptrdiff_t m_flCMMItemDropRevealEndTime = 0x948; // GameTime_t
    constexpr std::ptrdiff_t m_bIsDroppingItems = 0x94C; // bool
    constexpr std::ptrdiff_t m_bIsQuestEligible = 0x94D; // bool
    constexpr std::ptrdiff_t m_bIsHltvActive = 0x94E; // bool
    constexpr std::ptrdiff_t m_nGuardianModeWaveNumber = 0x950; // int32_t
    constexpr std::ptrdiff_t m_nGuardianModeSpecialKillsRemaining = 0x954; // int32_t
    constexpr std::ptrdiff_t m_nGuardianModeSpecialWeaponNeeded = 0x958; // int32_t
    constexpr std::ptrdiff_t m_nGuardianGrenadesToGiveBots = 0x95C; // int32_t
    constexpr std::ptrdiff_t m_nNumHeaviesToSpawn = 0x960; // int32_t
    constexpr std::ptrdiff_t m_numGlobalGiftsGiven = 0x964; // uint32_t
    constexpr std::ptrdiff_t m_numGlobalGifters = 0x968; // uint32_t
    constexpr std::ptrdiff_t m_numGlobalGiftsPeriodSeconds = 0x96C; // uint32_t
    constexpr std::ptrdiff_t m_arrFeaturedGiftersAccounts = 0x970; // uint32_t[4]
    constexpr std::ptrdiff_t m_arrFeaturedGiftersGifts = 0x980; // uint32_t[4]
    constexpr std::ptrdiff_t m_arrProhibitedItemIndices = 0x990; // uint16_t[100]
    constexpr std::ptrdiff_t m_arrTournamentActiveCasterAccounts = 0xA58; // uint32_t[4]
    constexpr std::ptrdiff_t m_numBestOfMaps = 0xA68; // int32_t
    constexpr std::ptrdiff_t m_nHalloweenMaskListSeed = 0xA6C; // int32_t
    constexpr std::ptrdiff_t m_bBombDropped = 0xA70; // bool
    constexpr std::ptrdiff_t m_bBombPlanted = 0xA71; // bool
    constexpr std::ptrdiff_t m_iRoundWinStatus = 0xA74; // int32_t
    constexpr std::ptrdiff_t m_eRoundWinReason = 0xA78; // int32_t
    constexpr std::ptrdiff_t m_bTCantBuy = 0xA7C; // bool
    constexpr std::ptrdiff_t m_bCTCantBuy = 0xA7D; // bool
    constexpr std::ptrdiff_t m_flGuardianBuyUntilTime = 0xA80; // GameTime_t
    constexpr std::ptrdiff_t m_iMatchStats_RoundResults = 0xA84; // int32_t[30]
    constexpr std::ptrdiff_t m_iMatchStats_PlayersAlive_CT = 0xAFC; // int32_t[30]
    constexpr std::ptrdiff_t m_iMatchStats_PlayersAlive_T = 0xB74; // int32_t[30]
    constexpr std::ptrdiff_t m_TeamRespawnWaveTimes = 0xBEC; // float[32]
    constexpr std::ptrdiff_t m_flNextRespawnWave = 0xC6C; // GameTime_t[32]
    constexpr std::ptrdiff_t m_nServerQuestID = 0xCEC; // int32_t
    constexpr std::ptrdiff_t m_vMinimapMins = 0xCF0; // Vector
    constexpr std::ptrdiff_t m_vMinimapMaxs = 0xCFC; // Vector
    constexpr std::ptrdiff_t m_MinimapVerticalSectionHeights = 0xD08; // float[8]
    constexpr std::ptrdiff_t m_bDontIncrementCoopWave = 0xD28; // bool
    constexpr std::ptrdiff_t m_bSpawnedTerrorHuntHeavy = 0xD29; // bool
    constexpr std::ptrdiff_t m_nEndMatchMapGroupVoteTypes = 0xD2C; // int32_t[10]
    constexpr std::ptrdiff_t m_nEndMatchMapGroupVoteOptions = 0xD54; // int32_t[10]
    constexpr std::ptrdiff_t m_nEndMatchMapVoteWinner = 0xD7C; // int32_t
    constexpr std::ptrdiff_t m_iNumConsecutiveCTLoses = 0xD80; // int32_t
    constexpr std::ptrdiff_t m_iNumConsecutiveTerroristLoses = 0xD84; // int32_t
    constexpr std::ptrdiff_t m_bHasHostageBeenTouched = 0xDA0; // bool
    constexpr std::ptrdiff_t m_flIntermissionStartTime = 0xDA4; // GameTime_t
    constexpr std::ptrdiff_t m_flIntermissionEndTime = 0xDA8; // GameTime_t
    constexpr std::ptrdiff_t m_bLevelInitialized = 0xDAC; // bool
    constexpr std::ptrdiff_t m_iTotalRoundsPlayed = 0xDB0; // int32_t
    constexpr std::ptrdiff_t m_iUnBalancedRounds = 0xDB4; // int32_t
    constexpr std::ptrdiff_t m_endMatchOnRoundReset = 0xDB8; // bool
    constexpr std::ptrdiff_t m_endMatchOnThink = 0xDB9; // bool
    constexpr std::ptrdiff_t m_iFreezeTime = 0xDBC; // int32_t
    constexpr std::ptrdiff_t m_iNumTerrorist = 0xDC0; // int32_t
    constexpr std::ptrdiff_t m_iNumCT = 0xDC4; // int32_t
    constexpr std::ptrdiff_t m_iNumSpawnableTerrorist = 0xDC8; // int32_t
    constexpr std::ptrdiff_t m_iNumSpawnableCT = 0xDCC; // int32_t
    constexpr std::ptrdiff_t m_arrSelectedHostageSpawnIndices = 0xDD0; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_bFirstConnected = 0xDE8; // bool
    constexpr std::ptrdiff_t m_bCompleteReset = 0xDE9; // bool
    constexpr std::ptrdiff_t m_bPickNewTeamsOnReset = 0xDEA; // bool
    constexpr std::ptrdiff_t m_bScrambleTeamsOnRestart = 0xDEB; // bool
    constexpr std::ptrdiff_t m_bSwapTeamsOnRestart = 0xDEC; // bool
    constexpr std::ptrdiff_t m_nEndMatchTiedVotes = 0xDF8; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_bNeedToAskPlayersForContinueVote = 0xE14; // bool
    constexpr std::ptrdiff_t m_numQueuedMatchmakingAccounts = 0xE18; // uint32_t
    constexpr std::ptrdiff_t m_pQueuedMatchmakingReservationString = 0xE20; // char*
    constexpr std::ptrdiff_t m_numTotalTournamentDrops = 0xE28; // uint32_t
    constexpr std::ptrdiff_t m_numSpectatorsCountMax = 0xE2C; // uint32_t
    constexpr std::ptrdiff_t m_numSpectatorsCountMaxTV = 0xE30; // uint32_t
    constexpr std::ptrdiff_t m_numSpectatorsCountMaxLnk = 0xE34; // uint32_t
    constexpr std::ptrdiff_t m_bForceTeamChangeSilent = 0xE40; // bool
    constexpr std::ptrdiff_t m_bLoadingRoundBackupData = 0xE41; // bool
    constexpr std::ptrdiff_t m_nMatchInfoShowType = 0xE78; // int32_t
    constexpr std::ptrdiff_t m_flMatchInfoDecidedTime = 0xE7C; // float
    constexpr std::ptrdiff_t m_flCoopRespawnAndHealTime = 0xE98; // float
    constexpr std::ptrdiff_t m_coopBonusCoinsFound = 0xE9C; // int32_t
    constexpr std::ptrdiff_t m_coopBonusPistolsOnly = 0xEA0; // bool
    constexpr std::ptrdiff_t m_coopPlayersInDeploymentZone = 0xEA1; // bool
    constexpr std::ptrdiff_t m_coopMissionDeadPlayerRespawnEnabled = 0xEA2; // bool
    constexpr std::ptrdiff_t mTeamDMLastWinningTeamNumber = 0xEA4; // int32_t
    constexpr std::ptrdiff_t mTeamDMLastThinkTime = 0xEA8; // float
    constexpr std::ptrdiff_t m_flTeamDMLastAnnouncementTime = 0xEAC; // float
    constexpr std::ptrdiff_t m_iAccountTerrorist = 0xEB0; // int32_t
    constexpr std::ptrdiff_t m_iAccountCT = 0xEB4; // int32_t
    constexpr std::ptrdiff_t m_iSpawnPointCount_Terrorist = 0xEB8; // int32_t
    constexpr std::ptrdiff_t m_iSpawnPointCount_CT = 0xEBC; // int32_t
    constexpr std::ptrdiff_t m_iMaxNumTerrorists = 0xEC0; // int32_t
    constexpr std::ptrdiff_t m_iMaxNumCTs = 0xEC4; // int32_t
    constexpr std::ptrdiff_t m_iLoserBonus = 0xEC8; // int32_t
    constexpr std::ptrdiff_t m_iLoserBonusMostRecentTeam = 0xECC; // int32_t
    constexpr std::ptrdiff_t m_tmNextPeriodicThink = 0xED0; // float
    constexpr std::ptrdiff_t m_bVoiceWonMatchBragFired = 0xED4; // bool
    constexpr std::ptrdiff_t m_fWarmupNextChatNoticeTime = 0xED8; // float
    constexpr std::ptrdiff_t m_iHostagesRescued = 0xEE0; // int32_t
    constexpr std::ptrdiff_t m_iHostagesTouched = 0xEE4; // int32_t
    constexpr std::ptrdiff_t m_flNextHostageAnnouncement = 0xEE8; // float
    constexpr std::ptrdiff_t m_bNoTerroristsKilled = 0xEEC; // bool
    constexpr std::ptrdiff_t m_bNoCTsKilled = 0xEED; // bool
    constexpr std::ptrdiff_t m_bNoEnemiesKilled = 0xEEE; // bool
    constexpr std::ptrdiff_t m_bCanDonateWeapons = 0xEEF; // bool
    constexpr std::ptrdiff_t m_firstKillTime = 0xEF4; // float
    constexpr std::ptrdiff_t m_firstBloodTime = 0xEFC; // float
    constexpr std::ptrdiff_t m_hostageWasInjured = 0xF18; // bool
    constexpr std::ptrdiff_t m_hostageWasKilled = 0xF19; // bool
    constexpr std::ptrdiff_t m_bVoteCalled = 0xF28; // bool
    constexpr std::ptrdiff_t m_bServerVoteOnReset = 0xF29; // bool
    constexpr std::ptrdiff_t m_flVoteCheckThrottle = 0xF2C; // float
    constexpr std::ptrdiff_t m_bBuyTimeEnded = 0xF30; // bool
    constexpr std::ptrdiff_t m_nLastFreezeEndBeep = 0xF34; // int32_t
    constexpr std::ptrdiff_t m_bTargetBombed = 0xF38; // bool
    constexpr std::ptrdiff_t m_bBombDefused = 0xF39; // bool
    constexpr std::ptrdiff_t m_bMapHasBombZone = 0xF3A; // bool
    constexpr std::ptrdiff_t m_vecMainCTSpawnPos = 0xF58; // Vector
    constexpr std::ptrdiff_t m_CTSpawnPointsMasterList = 0xF68; // CUtlVector<SpawnPoint*>
    constexpr std::ptrdiff_t m_TerroristSpawnPointsMasterList = 0xF80; // CUtlVector<SpawnPoint*>
    constexpr std::ptrdiff_t m_iNextCTSpawnPoint = 0xF98; // int32_t
    constexpr std::ptrdiff_t m_iNextTerroristSpawnPoint = 0xF9C; // int32_t
    constexpr std::ptrdiff_t m_CTSpawnPoints = 0xFA0; // CUtlVector<SpawnPoint*>
    constexpr std::ptrdiff_t m_TerroristSpawnPoints = 0xFB8; // CUtlVector<SpawnPoint*>
    constexpr std::ptrdiff_t m_bIsUnreservedGameServer = 0xFD0; // bool
    constexpr std::ptrdiff_t m_fAutobalanceDisplayTime = 0xFD4; // float
    constexpr std::ptrdiff_t m_bAllowWeaponSwitch = 0x1240; // bool
    constexpr std::ptrdiff_t m_bRoundTimeWarningTriggered = 0x1241; // bool
    constexpr std::ptrdiff_t m_phaseChangeAnnouncementTime = 0x1244; // GameTime_t
    constexpr std::ptrdiff_t m_fNextUpdateTeamClanNamesTime = 0x1248; // float
    constexpr std::ptrdiff_t m_flLastThinkTime = 0x124C; // GameTime_t
    constexpr std::ptrdiff_t m_fAccumulatedRoundOffDamage = 0x1250; // float
    constexpr std::ptrdiff_t m_nShorthandedBonusLastEvalRound = 0x1254; // int32_t
    constexpr std::ptrdiff_t m_nMatchAbortedEarlyReason = 0x14D0; // int32_t
    constexpr std::ptrdiff_t m_bHasTriggeredRoundStartMusic = 0x14D4; // bool
    constexpr std::ptrdiff_t m_bHasTriggeredCoopSpawnReset = 0x14D5; // bool
    constexpr std::ptrdiff_t m_bSwitchingTeamsAtRoundReset = 0x14D6; // bool
    constexpr std::ptrdiff_t m_pGameModeRules = 0x14F0; // CCSGameModeRules*
    constexpr std::ptrdiff_t m_BtGlobalBlackboard = 0x14F8; // KeyValues3
    constexpr std::ptrdiff_t m_hPlayerResource = 0x1560; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_RetakeRules = 0x1568; // CRetakeGameRules
    constexpr std::ptrdiff_t m_GuardianBotSkillLevelMax = 0x174C; // int32_t
    constexpr std::ptrdiff_t m_GuardianBotSkillLevelMin = 0x1750; // int32_t
    constexpr std::ptrdiff_t m_arrTeamUniqueKillWeaponsMatch = 0x1758; // CUtlVector<int32_t>[4]
    constexpr std::ptrdiff_t m_bTeamLastKillUsedUniqueWeaponMatch = 0x17B8; // bool[4]
    constexpr std::ptrdiff_t m_nMatchEndCount = 0x17E0; // uint8_t
    constexpr std::ptrdiff_t m_nTTeamIntroVariant = 0x17E4; // int32_t
    constexpr std::ptrdiff_t m_nCTTeamIntroVariant = 0x17E8; // int32_t
    constexpr std::ptrdiff_t m_bTeamIntroPeriod = 0x17EC; // bool
    constexpr std::ptrdiff_t m_fTeamIntroPeriodEnd = 0x17F0; // GameTime_t
    constexpr std::ptrdiff_t m_bPlayedTeamIntroVO = 0x17F4; // bool
    constexpr std::ptrdiff_t m_flLastPerfSampleTime = 0x5800; // double
    constexpr std::ptrdiff_t m_bSkipNextServerPerfSample = 0x5808; // bool
}

namespace CCSGameRulesProxy {
    constexpr std::ptrdiff_t m_pGameRules = 0x4B0; // CCSGameRules*
}

namespace CCSPlace {
    constexpr std::ptrdiff_t m_name = 0x708; // CUtlSymbolLarge
}

namespace CCSPlayerBase_CameraServices {
    constexpr std::ptrdiff_t m_iFOV = 0x170; // uint32_t
    constexpr std::ptrdiff_t m_iFOVStart = 0x174; // uint32_t
    constexpr std::ptrdiff_t m_flFOVTime = 0x178; // GameTime_t
    constexpr std::ptrdiff_t m_flFOVRate = 0x17C; // float
    constexpr std::ptrdiff_t m_hZoomOwner = 0x180; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTriggerFogList = 0x188; // CUtlVector<CHandle<CBaseEntity>>
    constexpr std::ptrdiff_t m_hLastFogTrigger = 0x1A0; // CHandle<CBaseEntity>
}

namespace CCSPlayerController {
    constexpr std::ptrdiff_t m_pInGameMoneyServices = 0x6B8; // CCSPlayerController_InGameMoneyServices*
    constexpr std::ptrdiff_t m_pInventoryServices = 0x6C0; // CCSPlayerController_InventoryServices*
    constexpr std::ptrdiff_t m_pActionTrackingServices = 0x6C8; // CCSPlayerController_ActionTrackingServices*
    constexpr std::ptrdiff_t m_pDamageServices = 0x6D0; // CCSPlayerController_DamageServices*
    constexpr std::ptrdiff_t m_iPing = 0x6D8; // uint32_t
    constexpr std::ptrdiff_t m_bHasCommunicationAbuseMute = 0x6DC; // bool
    constexpr std::ptrdiff_t m_szCrosshairCodes = 0x6E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iPendingTeamNum = 0x6E8; // uint8_t
    constexpr std::ptrdiff_t m_flForceTeamTime = 0x6EC; // GameTime_t
    constexpr std::ptrdiff_t m_iCompTeammateColor = 0x6F0; // int32_t
    constexpr std::ptrdiff_t m_bEverPlayedOnTeam = 0x6F4; // bool
    constexpr std::ptrdiff_t m_bAttemptedToGetColor = 0x6F5; // bool
    constexpr std::ptrdiff_t m_iTeammatePreferredColor = 0x6F8; // int32_t
    constexpr std::ptrdiff_t m_bTeamChanged = 0x6FC; // bool
    constexpr std::ptrdiff_t m_bInSwitchTeam = 0x6FD; // bool
    constexpr std::ptrdiff_t m_bHasSeenJoinGame = 0x6FE; // bool
    constexpr std::ptrdiff_t m_bJustBecameSpectator = 0x6FF; // bool
    constexpr std::ptrdiff_t m_bSwitchTeamsOnNextRoundReset = 0x700; // bool
    constexpr std::ptrdiff_t m_bRemoveAllItemsOnNextRoundReset = 0x701; // bool
    constexpr std::ptrdiff_t m_szClan = 0x708; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_szClanName = 0x710; // char[32]
    constexpr std::ptrdiff_t m_iCoachingTeam = 0x730; // int32_t
    constexpr std::ptrdiff_t m_nPlayerDominated = 0x738; // uint64_t
    constexpr std::ptrdiff_t m_nPlayerDominatingMe = 0x740; // uint64_t
    constexpr std::ptrdiff_t m_iCompetitiveRanking = 0x748; // int32_t
    constexpr std::ptrdiff_t m_iCompetitiveWins = 0x74C; // int32_t
    constexpr std::ptrdiff_t m_iCompetitiveRankType = 0x750; // int8_t
    constexpr std::ptrdiff_t m_iCompetitiveRankingPredicted_Win = 0x754; // int32_t
    constexpr std::ptrdiff_t m_iCompetitiveRankingPredicted_Loss = 0x758; // int32_t
    constexpr std::ptrdiff_t m_iCompetitiveRankingPredicted_Tie = 0x75C; // int32_t
    constexpr std::ptrdiff_t m_nEndMatchNextMapVote = 0x760; // int32_t
    constexpr std::ptrdiff_t m_unActiveQuestId = 0x764; // uint16_t
    constexpr std::ptrdiff_t m_nQuestProgressReason = 0x768; // QuestProgress::Reason
    constexpr std::ptrdiff_t m_unPlayerTvControlFlags = 0x76C; // uint32_t
    constexpr std::ptrdiff_t m_iDraftIndex = 0x798; // int32_t
    constexpr std::ptrdiff_t m_msQueuedModeDisconnectionTimestamp = 0x79C; // uint32_t
    constexpr std::ptrdiff_t m_uiAbandonRecordedReason = 0x7A0; // uint32_t
    constexpr std::ptrdiff_t m_bCannotBeKicked = 0x7A4; // bool
    constexpr std::ptrdiff_t m_bEverFullyConnected = 0x7A5; // bool
    constexpr std::ptrdiff_t m_bAbandonAllowsSurrender = 0x7A6; // bool
    constexpr std::ptrdiff_t m_bAbandonOffersInstantSurrender = 0x7A7; // bool
    constexpr std::ptrdiff_t m_bDisconnection1MinWarningPrinted = 0x7A8; // bool
    constexpr std::ptrdiff_t m_bScoreReported = 0x7A9; // bool
    constexpr std::ptrdiff_t m_nDisconnectionTick = 0x7AC; // int32_t
    constexpr std::ptrdiff_t m_bControllingBot = 0x7B8; // bool
    constexpr std::ptrdiff_t m_bHasControlledBotThisRound = 0x7B9; // bool
    constexpr std::ptrdiff_t m_bHasBeenControlledByPlayerThisRound = 0x7BA; // bool
    constexpr std::ptrdiff_t m_nBotsControlledThisRound = 0x7BC; // int32_t
    constexpr std::ptrdiff_t m_bCanControlObservedBot = 0x7C0; // bool
    constexpr std::ptrdiff_t m_hPlayerPawn = 0x7C4; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_hObserverPawn = 0x7C8; // CHandle<CCSObserverPawn>
    constexpr std::ptrdiff_t m_DesiredObserverMode = 0x7CC; // int32_t
    constexpr std::ptrdiff_t m_hDesiredObserverTarget = 0x7D0; // CEntityHandle
    constexpr std::ptrdiff_t m_bPawnIsAlive = 0x7D4; // bool
    constexpr std::ptrdiff_t m_iPawnHealth = 0x7D8; // uint32_t
    constexpr std::ptrdiff_t m_iPawnArmor = 0x7DC; // int32_t
    constexpr std::ptrdiff_t m_bPawnHasDefuser = 0x7E0; // bool
    constexpr std::ptrdiff_t m_bPawnHasHelmet = 0x7E1; // bool
    constexpr std::ptrdiff_t m_nPawnCharacterDefIndex = 0x7E2; // uint16_t
    constexpr std::ptrdiff_t m_iPawnLifetimeStart = 0x7E4; // int32_t
    constexpr std::ptrdiff_t m_iPawnLifetimeEnd = 0x7E8; // int32_t
    constexpr std::ptrdiff_t m_iPawnBotDifficulty = 0x7EC; // int32_t
    constexpr std::ptrdiff_t m_hOriginalControllerOfCurrentPawn = 0x7F0; // CHandle<CCSPlayerController>
    constexpr std::ptrdiff_t m_iScore = 0x7F4; // int32_t
    constexpr std::ptrdiff_t m_iRoundScore = 0x7F8; // int32_t
    constexpr std::ptrdiff_t m_iRoundsWon = 0x7FC; // int32_t
    constexpr std::ptrdiff_t m_vecKills = 0x800; // CNetworkUtlVectorBase<EKillTypes_t>
    constexpr std::ptrdiff_t m_iMVPs = 0x818; // int32_t
    constexpr std::ptrdiff_t m_nUpdateCounter = 0x81C; // int32_t
    constexpr std::ptrdiff_t m_flSmoothedPing = 0x820; // float
    constexpr std::ptrdiff_t m_lastHeldVoteTimer = 0xF8C8; // IntervalTimer
    constexpr std::ptrdiff_t m_bShowHints = 0xF8E0; // bool
    constexpr std::ptrdiff_t m_iNextTimeCheck = 0xF8E4; // int32_t
    constexpr std::ptrdiff_t m_bJustDidTeamKill = 0xF8E8; // bool
    constexpr std::ptrdiff_t m_bPunishForTeamKill = 0xF8E9; // bool
    constexpr std::ptrdiff_t m_bGaveTeamDamageWarning = 0xF8EA; // bool
    constexpr std::ptrdiff_t m_bGaveTeamDamageWarningThisRound = 0xF8EB; // bool
    constexpr std::ptrdiff_t m_dblLastReceivedPacketPlatFloatTime = 0xF8F0; // double
    constexpr std::ptrdiff_t m_LastTeamDamageWarningTime = 0xF8F8; // GameTime_t
    constexpr std::ptrdiff_t m_LastTimePlayerWasDisconnectedForPawnsRemove = 0xF8FC; // GameTime_t
}

namespace CCSPlayerController_ActionTrackingServices {
    constexpr std::ptrdiff_t m_perRoundStats = 0x40; // CUtlVectorEmbeddedNetworkVar<CSPerRoundStats_t>
    constexpr std::ptrdiff_t m_matchStats = 0x90; // CSMatchStats_t
    constexpr std::ptrdiff_t m_iNumRoundKills = 0x148; // int32_t
    constexpr std::ptrdiff_t m_iNumRoundKillsHeadshots = 0x14C; // int32_t
    constexpr std::ptrdiff_t m_unTotalRoundDamageDealt = 0x150; // uint32_t
}

namespace CCSPlayerController_DamageServices {
    constexpr std::ptrdiff_t m_nSendUpdate = 0x40; // int32_t
    constexpr std::ptrdiff_t m_DamageList = 0x48; // CUtlVectorEmbeddedNetworkVar<CDamageRecord>
}

namespace CCSPlayerController_InGameMoneyServices {
    constexpr std::ptrdiff_t m_bReceivesMoneyNextRound = 0x40; // bool
    constexpr std::ptrdiff_t m_iAccountMoneyEarnedForNextRound = 0x44; // int32_t
    constexpr std::ptrdiff_t m_iAccount = 0x48; // int32_t
    constexpr std::ptrdiff_t m_iStartAccount = 0x4C; // int32_t
    constexpr std::ptrdiff_t m_iTotalCashSpent = 0x50; // int32_t
    constexpr std::ptrdiff_t m_iCashSpentThisRound = 0x54; // int32_t
}

namespace CCSPlayerController_InventoryServices {
    constexpr std::ptrdiff_t m_unMusicID = 0x40; // uint16_t
    constexpr std::ptrdiff_t m_rank = 0x44; // MedalRank_t[6]
    constexpr std::ptrdiff_t m_nPersonaDataPublicLevel = 0x5C; // int32_t
    constexpr std::ptrdiff_t m_nPersonaDataPublicCommendsLeader = 0x60; // int32_t
    constexpr std::ptrdiff_t m_nPersonaDataPublicCommendsTeacher = 0x64; // int32_t
    constexpr std::ptrdiff_t m_nPersonaDataPublicCommendsFriendly = 0x68; // int32_t
    constexpr std::ptrdiff_t m_unEquippedPlayerSprayIDs = 0xF48; // uint32_t[1]
    constexpr std::ptrdiff_t m_vecServerAuthoritativeWeaponSlots = 0xF50; // CUtlVectorEmbeddedNetworkVar<ServerAuthoritativeWeaponSlot_t>
}

namespace CCSPlayerPawn {
    constexpr std::ptrdiff_t m_pBulletServices = 0x1550; // CCSPlayer_BulletServices*
    constexpr std::ptrdiff_t m_pHostageServices = 0x1558; // CCSPlayer_HostageServices*
    constexpr std::ptrdiff_t m_pBuyServices = 0x1560; // CCSPlayer_BuyServices*
    constexpr std::ptrdiff_t m_pActionTrackingServices = 0x1568; // CCSPlayer_ActionTrackingServices*
    constexpr std::ptrdiff_t m_pRadioServices = 0x1570; // CCSPlayer_RadioServices*
    constexpr std::ptrdiff_t m_pDamageReactServices = 0x1578; // CCSPlayer_DamageReactServices*
    constexpr std::ptrdiff_t m_nCharacterDefIndex = 0x1580; // uint16_t
    constexpr std::ptrdiff_t m_hPreviousModel = 0x1588; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_bHasFemaleVoice = 0x1590; // bool
    constexpr std::ptrdiff_t m_strVOPrefix = 0x1598; // CUtlString
    constexpr std::ptrdiff_t m_szLastPlaceName = 0x15A0; // char[18]
    constexpr std::ptrdiff_t m_bInHostageResetZone = 0x1660; // bool
    constexpr std::ptrdiff_t m_bInBuyZone = 0x1661; // bool
    constexpr std::ptrdiff_t m_bWasInBuyZone = 0x1662; // bool
    constexpr std::ptrdiff_t m_bInHostageRescueZone = 0x1663; // bool
    constexpr std::ptrdiff_t m_bInBombZone = 0x1664; // bool
    constexpr std::ptrdiff_t m_bWasInHostageRescueZone = 0x1665; // bool
    constexpr std::ptrdiff_t m_iRetakesOffering = 0x1668; // int32_t
    constexpr std::ptrdiff_t m_iRetakesOfferingCard = 0x166C; // int32_t
    constexpr std::ptrdiff_t m_bRetakesHasDefuseKit = 0x1670; // bool
    constexpr std::ptrdiff_t m_bRetakesMVPLastRound = 0x1671; // bool
    constexpr std::ptrdiff_t m_iRetakesMVPBoostItem = 0x1674; // int32_t
    constexpr std::ptrdiff_t m_RetakesMVPBoostExtraUtility = 0x1678; // loadout_slot_t
    constexpr std::ptrdiff_t m_flHealthShotBoostExpirationTime = 0x167C; // GameTime_t
    constexpr std::ptrdiff_t m_flLandseconds = 0x1680; // float
    constexpr std::ptrdiff_t m_aimPunchAngle = 0x1684; // QAngle
    constexpr std::ptrdiff_t m_aimPunchAngleVel = 0x1690; // QAngle
    constexpr std::ptrdiff_t m_aimPunchTickBase = 0x169C; // int32_t
    constexpr std::ptrdiff_t m_aimPunchTickFraction = 0x16A0; // float
    constexpr std::ptrdiff_t m_aimPunchCache = 0x16A8; // CUtlVector<QAngle>
    constexpr std::ptrdiff_t m_bIsBuyMenuOpen = 0x16C0; // bool
    constexpr std::ptrdiff_t m_xLastHeadBoneTransform = 0x1C40; // CTransform
    constexpr std::ptrdiff_t m_bLastHeadBoneTransformIsValid = 0x1C60; // bool
    constexpr std::ptrdiff_t m_lastLandTime = 0x1C64; // GameTime_t
    constexpr std::ptrdiff_t m_bOnGroundLastTick = 0x1C68; // bool
    constexpr std::ptrdiff_t m_iPlayerLocked = 0x1C6C; // int32_t
    constexpr std::ptrdiff_t m_flTimeOfLastInjury = 0x1C74; // GameTime_t
    constexpr std::ptrdiff_t m_flNextSprayDecalTime = 0x1C78; // GameTime_t
    constexpr std::ptrdiff_t m_bNextSprayDecalTimeExpedited = 0x1C7C; // bool
    constexpr std::ptrdiff_t m_nRagdollDamageBone = 0x1C80; // int32_t
    constexpr std::ptrdiff_t m_vRagdollDamageForce = 0x1C84; // Vector
    constexpr std::ptrdiff_t m_vRagdollDamagePosition = 0x1C90; // Vector
    constexpr std::ptrdiff_t m_szRagdollDamageWeaponName = 0x1C9C; // char[64]
    constexpr std::ptrdiff_t m_bRagdollDamageHeadshot = 0x1CDC; // bool
    constexpr std::ptrdiff_t m_vRagdollServerOrigin = 0x1CE0; // Vector
    constexpr std::ptrdiff_t m_EconGloves = 0x1CF0; // CEconItemView
    constexpr std::ptrdiff_t m_qDeathEyeAngles = 0x1F68; // QAngle
    constexpr std::ptrdiff_t m_bSkipOneHeadConstraintUpdate = 0x1F74; // bool
}

namespace CCSPlayerPawnBase {
    constexpr std::ptrdiff_t m_CTouchExpansionComponent = 0xB68; // CTouchExpansionComponent
    constexpr std::ptrdiff_t m_pPingServices = 0xBB8; // CCSPlayer_PingServices*
    constexpr std::ptrdiff_t m_pViewModelServices = 0xBC0; // CPlayer_ViewModelServices*
    constexpr std::ptrdiff_t m_iDisplayHistoryBits = 0xBC8; // uint32_t
    constexpr std::ptrdiff_t m_flLastAttackedTeammate = 0xBCC; // float
    constexpr std::ptrdiff_t m_hOriginalController = 0xBD0; // CHandle<CCSPlayerController>
    constexpr std::ptrdiff_t m_blindUntilTime = 0xBD4; // GameTime_t
    constexpr std::ptrdiff_t m_blindStartTime = 0xBD8; // GameTime_t
    constexpr std::ptrdiff_t m_allowAutoFollowTime = 0xBDC; // GameTime_t
    constexpr std::ptrdiff_t m_entitySpottedState = 0xBE0; // EntitySpottedState_t
    constexpr std::ptrdiff_t m_nSpotRules = 0xBF8; // int32_t
    constexpr std::ptrdiff_t m_iPlayerState = 0xBFC; // CSPlayerState
    constexpr std::ptrdiff_t m_chickenIdleSoundTimer = 0xC08; // CountdownTimer
    constexpr std::ptrdiff_t m_chickenJumpSoundTimer = 0xC20; // CountdownTimer
    constexpr std::ptrdiff_t m_vecLastBookmarkedPosition = 0xCD8; // Vector
    constexpr std::ptrdiff_t m_flLastDistanceTraveledNotice = 0xCE4; // float
    constexpr std::ptrdiff_t m_flAccumulatedDistanceTraveled = 0xCE8; // float
    constexpr std::ptrdiff_t m_flLastFriendlyFireDamageReductionRatio = 0xCEC; // float
    constexpr std::ptrdiff_t m_bRespawning = 0xCF0; // bool
    constexpr std::ptrdiff_t m_nLastPickupPriority = 0xCF4; // int32_t
    constexpr std::ptrdiff_t m_flLastPickupPriorityTime = 0xCF8; // float
    constexpr std::ptrdiff_t m_bIsScoped = 0xCFC; // bool
    constexpr std::ptrdiff_t m_bIsWalking = 0xCFD; // bool
    constexpr std::ptrdiff_t m_bResumeZoom = 0xCFE; // bool
    constexpr std::ptrdiff_t m_bIsDefusing = 0xCFF; // bool
    constexpr std::ptrdiff_t m_bIsGrabbingHostage = 0xD00; // bool
    constexpr std::ptrdiff_t m_iBlockingUseActionInProgress = 0xD04; // CSPlayerBlockingUseAction_t
    constexpr std::ptrdiff_t m_fImmuneToGunGameDamageTime = 0xD08; // GameTime_t
    constexpr std::ptrdiff_t m_bGunGameImmunity = 0xD0C; // bool
    constexpr std::ptrdiff_t m_fMolotovDamageTime = 0xD10; // float
    constexpr std::ptrdiff_t m_bHasMovedSinceSpawn = 0xD14; // bool
    constexpr std::ptrdiff_t m_bCanMoveDuringFreezePeriod = 0xD15; // bool
    constexpr std::ptrdiff_t m_flGuardianTooFarDistFrac = 0xD18; // float
    constexpr std::ptrdiff_t m_flNextGuardianTooFarHurtTime = 0xD1C; // float
    constexpr std::ptrdiff_t m_flDetectedByEnemySensorTime = 0xD20; // GameTime_t
    constexpr std::ptrdiff_t m_flDealtDamageToEnemyMostRecentTimestamp = 0xD24; // float
    constexpr std::ptrdiff_t m_flLastEquippedHelmetTime = 0xD28; // GameTime_t
    constexpr std::ptrdiff_t m_flLastEquippedArmorTime = 0xD2C; // GameTime_t
    constexpr std::ptrdiff_t m_nHeavyAssaultSuitCooldownRemaining = 0xD30; // int32_t
    constexpr std::ptrdiff_t m_bResetArmorNextSpawn = 0xD34; // bool
    constexpr std::ptrdiff_t m_flLastBumpMineBumpTime = 0xD38; // GameTime_t
    constexpr std::ptrdiff_t m_flEmitSoundTime = 0xD3C; // GameTime_t
    constexpr std::ptrdiff_t m_iNumSpawns = 0xD40; // int32_t
    constexpr std::ptrdiff_t m_iShouldHaveCash = 0xD44; // int32_t
    constexpr std::ptrdiff_t m_bInvalidSteamLogonDelayed = 0xD48; // bool
    constexpr std::ptrdiff_t m_flLastAction = 0xD4C; // GameTime_t
    constexpr std::ptrdiff_t m_flNameChangeHistory = 0xD50; // float[5]
    constexpr std::ptrdiff_t m_fLastGivenDefuserTime = 0xD64; // float
    constexpr std::ptrdiff_t m_fLastGivenBombTime = 0xD68; // float
    constexpr std::ptrdiff_t m_bHasNightVision = 0xD6C; // bool
    constexpr std::ptrdiff_t m_bNightVisionOn = 0xD6D; // bool
    constexpr std::ptrdiff_t m_fNextRadarUpdateTime = 0xD70; // float
    constexpr std::ptrdiff_t m_flLastMoneyUpdateTime = 0xD74; // float
    constexpr std::ptrdiff_t m_MenuStringBuffer = 0xD78; // char[1024]
    constexpr std::ptrdiff_t m_fIntroCamTime = 0x1178; // float
    constexpr std::ptrdiff_t m_nMyCollisionGroup = 0x117C; // int32_t
    constexpr std::ptrdiff_t m_bInNoDefuseArea = 0x1180; // bool
    constexpr std::ptrdiff_t m_bKilledByTaser = 0x1181; // bool
    constexpr std::ptrdiff_t m_iMoveState = 0x1184; // int32_t
    constexpr std::ptrdiff_t m_grenadeParameterStashTime = 0x1188; // GameTime_t
    constexpr std::ptrdiff_t m_bGrenadeParametersStashed = 0x118C; // bool
    constexpr std::ptrdiff_t m_angStashedShootAngles = 0x1190; // QAngle
    constexpr std::ptrdiff_t m_vecStashedGrenadeThrowPosition = 0x119C; // Vector
    constexpr std::ptrdiff_t m_vecStashedVelocity = 0x11A8; // Vector
    constexpr std::ptrdiff_t m_angShootAngleHistory = 0x11B4; // QAngle[2]
    constexpr std::ptrdiff_t m_vecThrowPositionHistory = 0x11CC; // Vector[2]
    constexpr std::ptrdiff_t m_vecVelocityHistory = 0x11E4; // Vector[2]
    constexpr std::ptrdiff_t m_bDiedAirborne = 0x11FC; // bool
    constexpr std::ptrdiff_t m_iBombSiteIndex = 0x1200; // CEntityIndex
    constexpr std::ptrdiff_t m_nWhichBombZone = 0x1204; // int32_t
    constexpr std::ptrdiff_t m_bInBombZoneTrigger = 0x1208; // bool
    constexpr std::ptrdiff_t m_bWasInBombZoneTrigger = 0x1209; // bool
    constexpr std::ptrdiff_t m_iDirection = 0x120C; // int32_t
    constexpr std::ptrdiff_t m_iShotsFired = 0x1210; // int32_t
    constexpr std::ptrdiff_t m_ArmorValue = 0x1214; // int32_t
    constexpr std::ptrdiff_t m_flFlinchStack = 0x1218; // float
    constexpr std::ptrdiff_t m_flVelocityModifier = 0x121C; // float
    constexpr std::ptrdiff_t m_flHitHeading = 0x1220; // float
    constexpr std::ptrdiff_t m_nHitBodyPart = 0x1224; // int32_t
    constexpr std::ptrdiff_t m_iHostagesKilled = 0x1228; // int32_t
    constexpr std::ptrdiff_t m_vecTotalBulletForce = 0x122C; // Vector
    constexpr std::ptrdiff_t m_flFlashDuration = 0x1238; // float
    constexpr std::ptrdiff_t m_flFlashMaxAlpha = 0x123C; // float
    constexpr std::ptrdiff_t m_flProgressBarStartTime = 0x1240; // float
    constexpr std::ptrdiff_t m_iProgressBarDuration = 0x1244; // int32_t
    constexpr std::ptrdiff_t m_bWaitForNoAttack = 0x1248; // bool
    constexpr std::ptrdiff_t m_flLowerBodyYawTarget = 0x124C; // float
    constexpr std::ptrdiff_t m_bStrafing = 0x1250; // bool
    constexpr std::ptrdiff_t m_lastStandingPos = 0x1254; // Vector
    constexpr std::ptrdiff_t m_ignoreLadderJumpTime = 0x1260; // float
    constexpr std::ptrdiff_t m_ladderSurpressionTimer = 0x1268; // CountdownTimer
    constexpr std::ptrdiff_t m_lastLadderNormal = 0x1280; // Vector
    constexpr std::ptrdiff_t m_lastLadderPos = 0x128C; // Vector
    constexpr std::ptrdiff_t m_thirdPersonHeading = 0x1298; // QAngle
    constexpr std::ptrdiff_t m_flSlopeDropOffset = 0x12A4; // float
    constexpr std::ptrdiff_t m_flSlopeDropHeight = 0x12A8; // float
    constexpr std::ptrdiff_t m_vHeadConstraintOffset = 0x12AC; // Vector
    constexpr std::ptrdiff_t m_iLastWeaponFireUsercmd = 0x12C0; // int32_t
    constexpr std::ptrdiff_t m_angEyeAngles = 0x12C4; // QAngle
    constexpr std::ptrdiff_t m_bVCollisionInitted = 0x12D0; // bool
    constexpr std::ptrdiff_t m_storedSpawnPosition = 0x12D4; // Vector
    constexpr std::ptrdiff_t m_storedSpawnAngle = 0x12E0; // QAngle
    constexpr std::ptrdiff_t m_bIsSpawning = 0x12EC; // bool
    constexpr std::ptrdiff_t m_bHideTargetID = 0x12ED; // bool
    constexpr std::ptrdiff_t m_nNumDangerZoneDamageHits = 0x12F0; // int32_t
    constexpr std::ptrdiff_t m_bHud_MiniScoreHidden = 0x12F4; // bool
    constexpr std::ptrdiff_t m_bHud_RadarHidden = 0x12F5; // bool
    constexpr std::ptrdiff_t m_nLastKillerIndex = 0x12F8; // CEntityIndex
    constexpr std::ptrdiff_t m_nLastConcurrentKilled = 0x12FC; // int32_t
    constexpr std::ptrdiff_t m_nDeathCamMusic = 0x1300; // int32_t
    constexpr std::ptrdiff_t m_iAddonBits = 0x1304; // int32_t
    constexpr std::ptrdiff_t m_iPrimaryAddon = 0x1308; // int32_t
    constexpr std::ptrdiff_t m_iSecondaryAddon = 0x130C; // int32_t
    constexpr std::ptrdiff_t m_currentDeafnessFilter = 0x1310; // CUtlStringToken
    constexpr std::ptrdiff_t m_NumEnemiesKilledThisSpawn = 0x1314; // int32_t
    constexpr std::ptrdiff_t m_NumEnemiesKilledThisRound = 0x1318; // int32_t
    constexpr std::ptrdiff_t m_NumEnemiesAtRoundStart = 0x131C; // int32_t
    constexpr std::ptrdiff_t m_wasNotKilledNaturally = 0x1320; // bool
    constexpr std::ptrdiff_t m_vecPlayerPatchEconIndices = 0x1324; // uint32_t[5]
    constexpr std::ptrdiff_t m_iDeathFlags = 0x1338; // int32_t
    constexpr std::ptrdiff_t m_hPet = 0x133C; // CHandle<CChicken>
    constexpr std::ptrdiff_t m_unCurrentEquipmentValue = 0x1508; // uint16_t
    constexpr std::ptrdiff_t m_unRoundStartEquipmentValue = 0x150A; // uint16_t
    constexpr std::ptrdiff_t m_unFreezetimeEndEquipmentValue = 0x150C; // uint16_t
    constexpr std::ptrdiff_t m_nSurvivalTeamNumber = 0x1510; // int32_t
    constexpr std::ptrdiff_t m_bHasDeathInfo = 0x1514; // bool
    constexpr std::ptrdiff_t m_flDeathInfoTime = 0x1518; // float
    constexpr std::ptrdiff_t m_vecDeathInfoOrigin = 0x151C; // Vector
    constexpr std::ptrdiff_t m_bKilledByHeadshot = 0x1528; // bool
    constexpr std::ptrdiff_t m_LastHitBox = 0x152C; // int32_t
    constexpr std::ptrdiff_t m_LastHealth = 0x1530; // int32_t
    constexpr std::ptrdiff_t m_flLastCollisionCeiling = 0x1534; // float
    constexpr std::ptrdiff_t m_flLastCollisionCeilingChangeTime = 0x1538; // float
    constexpr std::ptrdiff_t m_pBot = 0x1540; // CCSBot*
    constexpr std::ptrdiff_t m_bBotAllowActive = 0x1548; // bool
    constexpr std::ptrdiff_t m_bCommittingSuicideOnTeamChange = 0x1549; // bool
}

namespace CCSPlayerResource {
    constexpr std::ptrdiff_t m_bHostageAlive = 0x4B0; // bool[12]
    constexpr std::ptrdiff_t m_isHostageFollowingSomeone = 0x4BC; // bool[12]
    constexpr std::ptrdiff_t m_iHostageEntityIDs = 0x4C8; // CEntityIndex[12]
    constexpr std::ptrdiff_t m_bombsiteCenterA = 0x4F8; // Vector
    constexpr std::ptrdiff_t m_bombsiteCenterB = 0x504; // Vector
    constexpr std::ptrdiff_t m_hostageRescueX = 0x510; // int32_t[4]
    constexpr std::ptrdiff_t m_hostageRescueY = 0x520; // int32_t[4]
    constexpr std::ptrdiff_t m_hostageRescueZ = 0x530; // int32_t[4]
    constexpr std::ptrdiff_t m_bEndMatchNextMapAllVoted = 0x540; // bool
    constexpr std::ptrdiff_t m_foundGoalPositions = 0x541; // bool
}

namespace CCSPlayer_ActionTrackingServices {
    constexpr std::ptrdiff_t m_hLastWeaponBeforeC4AutoSwitch = 0x208; // CHandle<CBasePlayerWeapon>
    constexpr std::ptrdiff_t m_bIsRescuing = 0x23C; // bool
    constexpr std::ptrdiff_t m_weaponPurchasesThisMatch = 0x240; // WeaponPurchaseTracker_t
    constexpr std::ptrdiff_t m_weaponPurchasesThisRound = 0x298; // WeaponPurchaseTracker_t
}

namespace CCSPlayer_BulletServices {
    constexpr std::ptrdiff_t m_totalHitsOnServer = 0x40; // int32_t
}

namespace CCSPlayer_BuyServices {
    constexpr std::ptrdiff_t m_vecSellbackPurchaseEntries = 0xC8; // CUtlVectorEmbeddedNetworkVar<SellbackPurchaseEntry_t>
}

namespace CCSPlayer_HostageServices {
    constexpr std::ptrdiff_t m_hCarriedHostage = 0x40; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hCarriedHostageProp = 0x44; // CHandle<CBaseEntity>
}

namespace CCSPlayer_ItemServices {
    constexpr std::ptrdiff_t m_bHasDefuser = 0x40; // bool
    constexpr std::ptrdiff_t m_bHasHelmet = 0x41; // bool
    constexpr std::ptrdiff_t m_bHasHeavyArmor = 0x42; // bool
}

namespace CCSPlayer_MovementServices {
    constexpr std::ptrdiff_t m_flMaxFallVelocity = 0x220; // float
    constexpr std::ptrdiff_t m_vecLadderNormal = 0x224; // Vector
    constexpr std::ptrdiff_t m_nLadderSurfacePropIndex = 0x230; // int32_t
    constexpr std::ptrdiff_t m_flDuckAmount = 0x234; // float
    constexpr std::ptrdiff_t m_flDuckSpeed = 0x238; // float
    constexpr std::ptrdiff_t m_bDuckOverride = 0x23C; // bool
    constexpr std::ptrdiff_t m_bDesiresDuck = 0x23D; // bool
    constexpr std::ptrdiff_t m_flDuckOffset = 0x240; // float
    constexpr std::ptrdiff_t m_nDuckTimeMsecs = 0x244; // uint32_t
    constexpr std::ptrdiff_t m_nDuckJumpTimeMsecs = 0x248; // uint32_t
    constexpr std::ptrdiff_t m_nJumpTimeMsecs = 0x24C; // uint32_t
    constexpr std::ptrdiff_t m_flLastDuckTime = 0x250; // float
    constexpr std::ptrdiff_t m_vecLastPositionAtFullCrouchSpeed = 0x260; // Vector2D
    constexpr std::ptrdiff_t m_duckUntilOnGround = 0x268; // bool
    constexpr std::ptrdiff_t m_bHasWalkMovedSinceLastJump = 0x269; // bool
    constexpr std::ptrdiff_t m_bInStuckTest = 0x26A; // bool
    constexpr std::ptrdiff_t m_flStuckCheckTime = 0x278; // float[64][2]
    constexpr std::ptrdiff_t m_nTraceCount = 0x478; // int32_t
    constexpr std::ptrdiff_t m_StuckLast = 0x47C; // int32_t
    constexpr std::ptrdiff_t m_bSpeedCropped = 0x480; // bool
    constexpr std::ptrdiff_t m_nOldWaterLevel = 0x484; // int32_t
    constexpr std::ptrdiff_t m_flWaterEntryTime = 0x488; // float
    constexpr std::ptrdiff_t m_vecForward = 0x48C; // Vector
    constexpr std::ptrdiff_t m_vecLeft = 0x498; // Vector
    constexpr std::ptrdiff_t m_vecUp = 0x4A4; // Vector
    constexpr std::ptrdiff_t m_vecPreviouslyPredictedOrigin = 0x4B0; // Vector
    constexpr std::ptrdiff_t m_bMadeFootstepNoise = 0x4BC; // bool
    constexpr std::ptrdiff_t m_iFootsteps = 0x4C0; // int32_t
    constexpr std::ptrdiff_t m_bOldJumpPressed = 0x4C4; // bool
    constexpr std::ptrdiff_t m_flJumpPressedTime = 0x4C8; // float
    constexpr std::ptrdiff_t m_flJumpUntil = 0x4CC; // float
    constexpr std::ptrdiff_t m_flJumpVel = 0x4D0; // float
    constexpr std::ptrdiff_t m_fStashGrenadeParameterWhen = 0x4D4; // GameTime_t
    constexpr std::ptrdiff_t m_nButtonDownMaskPrev = 0x4D8; // uint64_t
    constexpr std::ptrdiff_t m_flOffsetTickCompleteTime = 0x4E0; // float
    constexpr std::ptrdiff_t m_flOffsetTickStashedSpeed = 0x4E4; // float
    constexpr std::ptrdiff_t m_flStamina = 0x4E8; // float
    constexpr std::ptrdiff_t m_flHeightAtJumpStart = 0x4EC; // float
    constexpr std::ptrdiff_t m_flMaxJumpHeightThisJump = 0x4F0; // float
}

namespace CCSPlayer_PingServices {
    constexpr std::ptrdiff_t m_flPlayerPingTokens = 0x40; // GameTime_t[5]
    constexpr std::ptrdiff_t m_hPlayerPing = 0x54; // CHandle<CBaseEntity>
}

namespace CCSPlayer_RadioServices {
    constexpr std::ptrdiff_t m_flGotHostageTalkTimer = 0x40; // GameTime_t
    constexpr std::ptrdiff_t m_flDefusingTalkTimer = 0x44; // GameTime_t
    constexpr std::ptrdiff_t m_flC4PlantTalkTimer = 0x48; // GameTime_t
    constexpr std::ptrdiff_t m_flRadioTokenSlots = 0x4C; // GameTime_t[3]
    constexpr std::ptrdiff_t m_bIgnoreRadio = 0x58; // bool
}

namespace CCSPlayer_UseServices {
    constexpr std::ptrdiff_t m_hLastKnownUseEntity = 0x40; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_flLastUseTimeStamp = 0x44; // GameTime_t
    constexpr std::ptrdiff_t m_flTimeStartedHoldingUse = 0x48; // GameTime_t
    constexpr std::ptrdiff_t m_flTimeLastUsedWindow = 0x4C; // GameTime_t
}

namespace CCSPlayer_ViewModelServices {
    constexpr std::ptrdiff_t m_hViewModel = 0x40; // CHandle<CBaseViewModel>[3]
}

namespace CCSPlayer_WaterServices {
    constexpr std::ptrdiff_t m_NextDrownDamageTime = 0x40; // float
    constexpr std::ptrdiff_t m_nDrownDmgRate = 0x44; // int32_t
    constexpr std::ptrdiff_t m_AirFinishedTime = 0x48; // GameTime_t
    constexpr std::ptrdiff_t m_flWaterJumpTime = 0x4C; // float
    constexpr std::ptrdiff_t m_vecWaterJumpVel = 0x50; // Vector
    constexpr std::ptrdiff_t m_flSwimSoundTime = 0x5C; // float
}

namespace CCSPlayer_WeaponServices {
    constexpr std::ptrdiff_t m_flNextAttack = 0xB0; // GameTime_t
    constexpr std::ptrdiff_t m_bIsLookingAtWeapon = 0xB4; // bool
    constexpr std::ptrdiff_t m_bIsHoldingLookAtWeapon = 0xB5; // bool
    constexpr std::ptrdiff_t m_hSavedWeapon = 0xB8; // CHandle<CBasePlayerWeapon>
    constexpr std::ptrdiff_t m_nTimeToMelee = 0xBC; // int32_t
    constexpr std::ptrdiff_t m_nTimeToSecondary = 0xC0; // int32_t
    constexpr std::ptrdiff_t m_nTimeToPrimary = 0xC4; // int32_t
    constexpr std::ptrdiff_t m_nTimeToSniperRifle = 0xC8; // int32_t
    constexpr std::ptrdiff_t m_bIsBeingGivenItem = 0xCC; // bool
    constexpr std::ptrdiff_t m_bIsPickingUpItemWithUse = 0xCD; // bool
    constexpr std::ptrdiff_t m_bPickedUpWeapon = 0xCE; // bool
}

namespace CCSTeam {
    constexpr std::ptrdiff_t m_nLastRecievedShorthandedRoundBonus = 0x568; // int32_t
    constexpr std::ptrdiff_t m_nShorthandedRoundBonusStartRound = 0x56C; // int32_t
    constexpr std::ptrdiff_t m_bSurrendered = 0x570; // bool
    constexpr std::ptrdiff_t m_szTeamMatchStat = 0x571; // char[512]
    constexpr std::ptrdiff_t m_numMapVictories = 0x774; // int32_t
    constexpr std::ptrdiff_t m_scoreFirstHalf = 0x778; // int32_t
    constexpr std::ptrdiff_t m_scoreSecondHalf = 0x77C; // int32_t
    constexpr std::ptrdiff_t m_scoreOvertime = 0x780; // int32_t
    constexpr std::ptrdiff_t m_szClanTeamname = 0x784; // char[129]
    constexpr std::ptrdiff_t m_iClanID = 0x808; // uint32_t
    constexpr std::ptrdiff_t m_szTeamFlagImage = 0x80C; // char[8]
    constexpr std::ptrdiff_t m_szTeamLogoImage = 0x814; // char[8]
    constexpr std::ptrdiff_t m_flNextResourceTime = 0x81C; // float
    constexpr std::ptrdiff_t m_iLastUpdateSentAt = 0x820; // int32_t
}

namespace CCSWeaponBase {
    constexpr std::ptrdiff_t m_bRemoveable = 0xC88; // bool
    constexpr std::ptrdiff_t m_flFireSequenceStartTime = 0xC90; // float
    constexpr std::ptrdiff_t m_nFireSequenceStartTimeChange = 0xC94; // int32_t
    constexpr std::ptrdiff_t m_nFireSequenceStartTimeAck = 0xC98; // int32_t
    constexpr std::ptrdiff_t m_bPlayerFireEventIsPrimary = 0xC9C; // bool
    constexpr std::ptrdiff_t m_seqIdle = 0xCA0; // HSequence
    constexpr std::ptrdiff_t m_seqFirePrimary = 0xCA4; // HSequence
    constexpr std::ptrdiff_t m_seqFireSecondary = 0xCA8; // HSequence
    constexpr std::ptrdiff_t m_thirdPersonFireSequences = 0xCB0; // CUtlVector<HSequence>
    constexpr std::ptrdiff_t m_hCurrentThirdPersonSequence = 0xCC8; // HSequence
    constexpr std::ptrdiff_t m_nSilencerBoneIndex = 0xCCC; // int32_t
    constexpr std::ptrdiff_t m_thirdPersonSequences = 0xCD0; // HSequence[6]
    constexpr std::ptrdiff_t m_bPlayerAmmoStockOnPickup = 0xCF0; // bool
    constexpr std::ptrdiff_t m_bRequireUseToTouch = 0xCF1; // bool
    constexpr std::ptrdiff_t m_iState = 0xCF4; // CSWeaponState_t
    constexpr std::ptrdiff_t m_flLastTimeInAir = 0xCF8; // GameTime_t
    constexpr std::ptrdiff_t m_flLastDeployTime = 0xCFC; // GameTime_t
    constexpr std::ptrdiff_t m_nViewModelIndex = 0xD00; // uint32_t
    constexpr std::ptrdiff_t m_bReloadsWithClips = 0xD04; // bool
    constexpr std::ptrdiff_t m_flTimeWeaponIdle = 0xD20; // GameTime_t
    constexpr std::ptrdiff_t m_bFireOnEmpty = 0xD24; // bool
    constexpr std::ptrdiff_t m_OnPlayerPickup = 0xD28; // CEntityIOOutput
    constexpr std::ptrdiff_t m_weaponMode = 0xD50; // CSWeaponMode
    constexpr std::ptrdiff_t m_flTurningInaccuracyDelta = 0xD54; // float
    constexpr std::ptrdiff_t m_vecTurningInaccuracyEyeDirLast = 0xD58; // Vector
    constexpr std::ptrdiff_t m_flTurningInaccuracy = 0xD64; // float
    constexpr std::ptrdiff_t m_fAccuracyPenalty = 0xD68; // float
    constexpr std::ptrdiff_t m_flLastAccuracyUpdateTime = 0xD6C; // GameTime_t
    constexpr std::ptrdiff_t m_fAccuracySmoothedForZoom = 0xD70; // float
    constexpr std::ptrdiff_t m_fScopeZoomEndTime = 0xD74; // GameTime_t
    constexpr std::ptrdiff_t m_iRecoilIndex = 0xD78; // int32_t
    constexpr std::ptrdiff_t m_flRecoilIndex = 0xD7C; // float
    constexpr std::ptrdiff_t m_bBurstMode = 0xD80; // bool
    constexpr std::ptrdiff_t m_flPostponeFireReadyTime = 0xD84; // GameTime_t
    constexpr std::ptrdiff_t m_bInReload = 0xD88; // bool
    constexpr std::ptrdiff_t m_bReloadVisuallyComplete = 0xD89; // bool
    constexpr std::ptrdiff_t m_flDroppedAtTime = 0xD8C; // GameTime_t
    constexpr std::ptrdiff_t m_bIsHauledBack = 0xD90; // bool
    constexpr std::ptrdiff_t m_bSilencerOn = 0xD91; // bool
    constexpr std::ptrdiff_t m_flTimeSilencerSwitchComplete = 0xD94; // GameTime_t
    constexpr std::ptrdiff_t m_iOriginalTeamNumber = 0xD98; // int32_t
    constexpr std::ptrdiff_t m_flNextAttackRenderTimeOffset = 0xD9C; // float
    constexpr std::ptrdiff_t m_bCanBePickedUp = 0xDB0; // bool
    constexpr std::ptrdiff_t m_bUseCanOverrideNextOwnerTouchTime = 0xDB1; // bool
    constexpr std::ptrdiff_t m_nextOwnerTouchTime = 0xDB4; // GameTime_t
    constexpr std::ptrdiff_t m_nextPrevOwnerTouchTime = 0xDB8; // GameTime_t
    constexpr std::ptrdiff_t m_hPrevOwner = 0xDBC; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_nDropTick = 0xDC0; // GameTick_t
    constexpr std::ptrdiff_t m_donated = 0xDE4; // bool
    constexpr std::ptrdiff_t m_fLastShotTime = 0xDE8; // GameTime_t
    constexpr std::ptrdiff_t m_bWasOwnedByCT = 0xDEC; // bool
    constexpr std::ptrdiff_t m_bWasOwnedByTerrorist = 0xDED; // bool
    constexpr std::ptrdiff_t m_bFiredOutOfAmmoEvent = 0xDEE; // bool
    constexpr std::ptrdiff_t m_numRemoveUnownedWeaponThink = 0xDF0; // int32_t
    constexpr std::ptrdiff_t m_IronSightController = 0xDF8; // CIronSightController
    constexpr std::ptrdiff_t m_iIronSightMode = 0xE10; // int32_t
    constexpr std::ptrdiff_t m_flLastLOSTraceFailureTime = 0xE14; // GameTime_t
    constexpr std::ptrdiff_t m_iNumEmptyAttacks = 0xE18; // int32_t
}

namespace CCSWeaponBaseGun {
    constexpr std::ptrdiff_t m_zoomLevel = 0xE20; // int32_t
    constexpr std::ptrdiff_t m_iBurstShotsRemaining = 0xE24; // int32_t
    constexpr std::ptrdiff_t m_silencedModelIndex = 0xE30; // int32_t
    constexpr std::ptrdiff_t m_inPrecache = 0xE34; // bool
    constexpr std::ptrdiff_t m_bNeedsBoltAction = 0xE35; // bool
    constexpr std::ptrdiff_t m_bSkillReloadAvailable = 0xE36; // bool
    constexpr std::ptrdiff_t m_bSkillReloadLiftedReloadKey = 0xE37; // bool
    constexpr std::ptrdiff_t m_bSkillBoltInterruptAvailable = 0xE38; // bool
    constexpr std::ptrdiff_t m_bSkillBoltLiftedFireKey = 0xE39; // bool
}

namespace CCSWeaponBaseVData {
    constexpr std::ptrdiff_t m_WeaponType = 0x240; // CSWeaponType
    constexpr std::ptrdiff_t m_WeaponCategory = 0x244; // CSWeaponCategory
    constexpr std::ptrdiff_t m_szViewModel = 0x248; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_szPlayerModel = 0x328; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_szWorldDroppedModel = 0x408; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_szAimsightLensMaskModel = 0x4E8; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_szMagazineModel = 0x5C8; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_szHeatEffect = 0x6A8; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_szEjectBrassEffect = 0x788; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_szMuzzleFlashParticleAlt = 0x868; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_szMuzzleFlashThirdPersonParticle = 0x948; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_szMuzzleFlashThirdPersonParticleAlt = 0xA28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_szTracerParticle = 0xB08; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_GearSlot = 0xBE8; // gear_slot_t
    constexpr std::ptrdiff_t m_GearSlotPosition = 0xBEC; // int32_t
    constexpr std::ptrdiff_t m_DefaultLoadoutSlot = 0xBF0; // loadout_slot_t
    constexpr std::ptrdiff_t m_sWrongTeamMsg = 0xBF8; // CUtlString
    constexpr std::ptrdiff_t m_nPrice = 0xC00; // int32_t
    constexpr std::ptrdiff_t m_nKillAward = 0xC04; // int32_t
    constexpr std::ptrdiff_t m_nPrimaryReserveAmmoMax = 0xC08; // int32_t
    constexpr std::ptrdiff_t m_nSecondaryReserveAmmoMax = 0xC0C; // int32_t
    constexpr std::ptrdiff_t m_bMeleeWeapon = 0xC10; // bool
    constexpr std::ptrdiff_t m_bHasBurstMode = 0xC11; // bool
    constexpr std::ptrdiff_t m_bIsRevolver = 0xC12; // bool
    constexpr std::ptrdiff_t m_bCannotShootUnderwater = 0xC13; // bool
    constexpr std::ptrdiff_t m_szName = 0xC18; // CUtlString
    constexpr std::ptrdiff_t m_szAnimExtension = 0xC20; // CUtlString
    constexpr std::ptrdiff_t m_eSilencerType = 0xC28; // CSWeaponSilencerType
    constexpr std::ptrdiff_t m_nCrosshairMinDistance = 0xC2C; // int32_t
    constexpr std::ptrdiff_t m_nCrosshairDeltaDistance = 0xC30; // int32_t
    constexpr std::ptrdiff_t m_flCycleTime = 0xC34; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flMaxSpeed = 0xC3C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flSpread = 0xC44; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyCrouch = 0xC4C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyStand = 0xC54; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyJump = 0xC5C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyLand = 0xC64; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyLadder = 0xC6C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyFire = 0xC74; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyMove = 0xC7C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flRecoilAngle = 0xC84; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flRecoilAngleVariance = 0xC8C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flRecoilMagnitude = 0xC94; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flRecoilMagnitudeVariance = 0xC9C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_nTracerFrequency = 0xCA4; // CFiringModeInt
    constexpr std::ptrdiff_t m_flInaccuracyJumpInitial = 0xCAC; // float
    constexpr std::ptrdiff_t m_flInaccuracyJumpApex = 0xCB0; // float
    constexpr std::ptrdiff_t m_flInaccuracyReload = 0xCB4; // float
    constexpr std::ptrdiff_t m_nRecoilSeed = 0xCB8; // int32_t
    constexpr std::ptrdiff_t m_nSpreadSeed = 0xCBC; // int32_t
    constexpr std::ptrdiff_t m_flTimeToIdleAfterFire = 0xCC0; // float
    constexpr std::ptrdiff_t m_flIdleInterval = 0xCC4; // float
    constexpr std::ptrdiff_t m_flAttackMovespeedFactor = 0xCC8; // float
    constexpr std::ptrdiff_t m_flHeatPerShot = 0xCCC; // float
    constexpr std::ptrdiff_t m_flInaccuracyPitchShift = 0xCD0; // float
    constexpr std::ptrdiff_t m_flInaccuracyAltSoundThreshold = 0xCD4; // float
    constexpr std::ptrdiff_t m_flBotAudibleRange = 0xCD8; // float
    constexpr std::ptrdiff_t m_szUseRadioSubtitle = 0xCE0; // CUtlString
    constexpr std::ptrdiff_t m_bUnzoomsAfterShot = 0xCE8; // bool
    constexpr std::ptrdiff_t m_bHideViewModelWhenZoomed = 0xCE9; // bool
    constexpr std::ptrdiff_t m_nZoomLevels = 0xCEC; // int32_t
    constexpr std::ptrdiff_t m_nZoomFOV1 = 0xCF0; // int32_t
    constexpr std::ptrdiff_t m_nZoomFOV2 = 0xCF4; // int32_t
    constexpr std::ptrdiff_t m_flZoomTime0 = 0xCF8; // float
    constexpr std::ptrdiff_t m_flZoomTime1 = 0xCFC; // float
    constexpr std::ptrdiff_t m_flZoomTime2 = 0xD00; // float
    constexpr std::ptrdiff_t m_flIronSightPullUpSpeed = 0xD04; // float
    constexpr std::ptrdiff_t m_flIronSightPutDownSpeed = 0xD08; // float
    constexpr std::ptrdiff_t m_flIronSightFOV = 0xD0C; // float
    constexpr std::ptrdiff_t m_flIronSightPivotForward = 0xD10; // float
    constexpr std::ptrdiff_t m_flIronSightLooseness = 0xD14; // float
    constexpr std::ptrdiff_t m_angPivotAngle = 0xD18; // QAngle
    constexpr std::ptrdiff_t m_vecIronSightEyePos = 0xD24; // Vector
    constexpr std::ptrdiff_t m_nDamage = 0xD30; // int32_t
    constexpr std::ptrdiff_t m_flHeadshotMultiplier = 0xD34; // float
    constexpr std::ptrdiff_t m_flArmorRatio = 0xD38; // float
    constexpr std::ptrdiff_t m_flPenetration = 0xD3C; // float
    constexpr std::ptrdiff_t m_flRange = 0xD40; // float
    constexpr std::ptrdiff_t m_flRangeModifier = 0xD44; // float
    constexpr std::ptrdiff_t m_flFlinchVelocityModifierLarge = 0xD48; // float
    constexpr std::ptrdiff_t m_flFlinchVelocityModifierSmall = 0xD4C; // float
    constexpr std::ptrdiff_t m_flRecoveryTimeCrouch = 0xD50; // float
    constexpr std::ptrdiff_t m_flRecoveryTimeStand = 0xD54; // float
    constexpr std::ptrdiff_t m_flRecoveryTimeCrouchFinal = 0xD58; // float
    constexpr std::ptrdiff_t m_flRecoveryTimeStandFinal = 0xD5C; // float
    constexpr std::ptrdiff_t m_nRecoveryTransitionStartBullet = 0xD60; // int32_t
    constexpr std::ptrdiff_t m_nRecoveryTransitionEndBullet = 0xD64; // int32_t
    constexpr std::ptrdiff_t m_flThrowVelocity = 0xD68; // float
    constexpr std::ptrdiff_t m_vSmokeColor = 0xD6C; // Vector
    constexpr std::ptrdiff_t m_szAnimClass = 0xD78; // CUtlString
}

namespace CChangeLevel {
    constexpr std::ptrdiff_t m_sMapName = 0x8A8; // CUtlString
    constexpr std::ptrdiff_t m_sLandmarkName = 0x8B0; // CUtlString
    constexpr std::ptrdiff_t m_OnChangeLevel = 0x8B8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bTouched = 0x8E0; // bool
    constexpr std::ptrdiff_t m_bNoTouch = 0x8E1; // bool
    constexpr std::ptrdiff_t m_bNewChapter = 0x8E2; // bool
    constexpr std::ptrdiff_t m_bOnChangeLevelFired = 0x8E3; // bool
}

namespace CChicken {
    constexpr std::ptrdiff_t m_AttributeManager = 0xB28; // CAttributeContainer
    constexpr std::ptrdiff_t m_OriginalOwnerXuidLow = 0xDF0; // uint32_t
    constexpr std::ptrdiff_t m_OriginalOwnerXuidHigh = 0xDF4; // uint32_t
    constexpr std::ptrdiff_t m_updateTimer = 0xDF8; // CountdownTimer
    constexpr std::ptrdiff_t m_stuckAnchor = 0xE10; // Vector
    constexpr std::ptrdiff_t m_stuckTimer = 0xE20; // CountdownTimer
    constexpr std::ptrdiff_t m_collisionStuckTimer = 0xE38; // CountdownTimer
    constexpr std::ptrdiff_t m_isOnGround = 0xE50; // bool
    constexpr std::ptrdiff_t m_vFallVelocity = 0xE54; // Vector
    constexpr std::ptrdiff_t m_activity = 0xE60; // ChickenActivity
    constexpr std::ptrdiff_t m_activityTimer = 0xE68; // CountdownTimer
    constexpr std::ptrdiff_t m_turnRate = 0xE80; // float
    constexpr std::ptrdiff_t m_fleeFrom = 0xE84; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_moveRateThrottleTimer = 0xE88; // CountdownTimer
    constexpr std::ptrdiff_t m_startleTimer = 0xEA0; // CountdownTimer
    constexpr std::ptrdiff_t m_vocalizeTimer = 0xEB8; // CountdownTimer
    constexpr std::ptrdiff_t m_flWhenZombified = 0xED0; // GameTime_t
    constexpr std::ptrdiff_t m_jumpedThisFrame = 0xED4; // bool
    constexpr std::ptrdiff_t m_leader = 0xED8; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_reuseTimer = 0xEE0; // CountdownTimer
    constexpr std::ptrdiff_t m_hasBeenUsed = 0xEF8; // bool
    constexpr std::ptrdiff_t m_jumpTimer = 0xF00; // CountdownTimer
    constexpr std::ptrdiff_t m_flLastJumpTime = 0xF18; // float
    constexpr std::ptrdiff_t m_bInJump = 0xF1C; // bool
    constexpr std::ptrdiff_t m_isWaitingForLeader = 0xF1D; // bool
    constexpr std::ptrdiff_t m_repathTimer = 0x2F28; // CountdownTimer
    constexpr std::ptrdiff_t m_inhibitDoorTimer = 0x2F40; // CountdownTimer
    constexpr std::ptrdiff_t m_inhibitObstacleAvoidanceTimer = 0x2FD0; // CountdownTimer
    constexpr std::ptrdiff_t m_vecPathGoal = 0x2FF0; // Vector
    constexpr std::ptrdiff_t m_flActiveFollowStartTime = 0x2FFC; // GameTime_t
    constexpr std::ptrdiff_t m_followMinuteTimer = 0x3000; // CountdownTimer
    constexpr std::ptrdiff_t m_vecLastEggPoopPosition = 0x3018; // Vector
    constexpr std::ptrdiff_t m_vecEggsPooped = 0x3028; // CUtlVector<CHandle<CBaseEntity>>
    constexpr std::ptrdiff_t m_BlockDirectionTimer = 0x3048; // CountdownTimer
}

namespace CCollisionProperty {
    constexpr std::ptrdiff_t m_collisionAttribute = 0x10; // VPhysicsCollisionAttribute_t
    constexpr std::ptrdiff_t m_vecMins = 0x40; // Vector
    constexpr std::ptrdiff_t m_vecMaxs = 0x4C; // Vector
    constexpr std::ptrdiff_t m_usSolidFlags = 0x5A; // uint8_t
    constexpr std::ptrdiff_t m_nSolidType = 0x5B; // SolidType_t
    constexpr std::ptrdiff_t m_triggerBloat = 0x5C; // uint8_t
    constexpr std::ptrdiff_t m_nSurroundType = 0x5D; // SurroundingBoundsType_t
    constexpr std::ptrdiff_t m_CollisionGroup = 0x5E; // uint8_t
    constexpr std::ptrdiff_t m_nEnablePhysics = 0x5F; // uint8_t
    constexpr std::ptrdiff_t m_flBoundingRadius = 0x60; // float
    constexpr std::ptrdiff_t m_vecSpecifiedSurroundingMins = 0x64; // Vector
    constexpr std::ptrdiff_t m_vecSpecifiedSurroundingMaxs = 0x70; // Vector
    constexpr std::ptrdiff_t m_vecSurroundingMaxs = 0x7C; // Vector
    constexpr std::ptrdiff_t m_vecSurroundingMins = 0x88; // Vector
    constexpr std::ptrdiff_t m_vCapsuleCenter1 = 0x94; // Vector
    constexpr std::ptrdiff_t m_vCapsuleCenter2 = 0xA0; // Vector
    constexpr std::ptrdiff_t m_flCapsuleRadius = 0xAC; // float
}

namespace CColorCorrection {
    constexpr std::ptrdiff_t m_flFadeInDuration = 0x4B0; // float
    constexpr std::ptrdiff_t m_flFadeOutDuration = 0x4B4; // float
    constexpr std::ptrdiff_t m_flStartFadeInWeight = 0x4B8; // float
    constexpr std::ptrdiff_t m_flStartFadeOutWeight = 0x4BC; // float
    constexpr std::ptrdiff_t m_flTimeStartFadeIn = 0x4C0; // GameTime_t
    constexpr std::ptrdiff_t m_flTimeStartFadeOut = 0x4C4; // GameTime_t
    constexpr std::ptrdiff_t m_flMaxWeight = 0x4C8; // float
    constexpr std::ptrdiff_t m_bStartDisabled = 0x4CC; // bool
    constexpr std::ptrdiff_t m_bEnabled = 0x4CD; // bool
    constexpr std::ptrdiff_t m_bMaster = 0x4CE; // bool
    constexpr std::ptrdiff_t m_bClientSide = 0x4CF; // bool
    constexpr std::ptrdiff_t m_bExclusive = 0x4D0; // bool
    constexpr std::ptrdiff_t m_MinFalloff = 0x4D4; // float
    constexpr std::ptrdiff_t m_MaxFalloff = 0x4D8; // float
    constexpr std::ptrdiff_t m_flCurWeight = 0x4DC; // float
    constexpr std::ptrdiff_t m_netlookupFilename = 0x4E0; // char[512]
    constexpr std::ptrdiff_t m_lookupFilename = 0x6E0; // CUtlSymbolLarge
}

namespace CColorCorrectionVolume {
    constexpr std::ptrdiff_t m_bEnabled = 0x8A8; // bool
    constexpr std::ptrdiff_t m_MaxWeight = 0x8AC; // float
    constexpr std::ptrdiff_t m_FadeDuration = 0x8B0; // float
    constexpr std::ptrdiff_t m_bStartDisabled = 0x8B4; // bool
    constexpr std::ptrdiff_t m_Weight = 0x8B8; // float
    constexpr std::ptrdiff_t m_lookupFilename = 0x8BC; // char[512]
    constexpr std::ptrdiff_t m_LastEnterWeight = 0xABC; // float
    constexpr std::ptrdiff_t m_LastEnterTime = 0xAC0; // GameTime_t
    constexpr std::ptrdiff_t m_LastExitWeight = 0xAC4; // float
    constexpr std::ptrdiff_t m_LastExitTime = 0xAC8; // GameTime_t
}

namespace CCommentaryAuto {
    constexpr std::ptrdiff_t m_OnCommentaryNewGame = 0x4B0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnCommentaryMidGame = 0x4D8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnCommentaryMultiplayerSpawn = 0x500; // CEntityIOOutput
}

namespace CCommentarySystem {
    constexpr std::ptrdiff_t m_bCommentaryConvarsChanging = 0x11; // bool
    constexpr std::ptrdiff_t m_bCommentaryEnabledMidGame = 0x12; // bool
    constexpr std::ptrdiff_t m_flNextTeleportTime = 0x14; // GameTime_t
    constexpr std::ptrdiff_t m_iTeleportStage = 0x18; // int32_t
    constexpr std::ptrdiff_t m_bCheatState = 0x1C; // bool
    constexpr std::ptrdiff_t m_bIsFirstSpawnGroupToLoad = 0x1D; // bool
    constexpr std::ptrdiff_t m_hCurrentNode = 0x38; // CHandle<CPointCommentaryNode>
    constexpr std::ptrdiff_t m_hActiveCommentaryNode = 0x3C; // CHandle<CPointCommentaryNode>
    constexpr std::ptrdiff_t m_hLastCommentaryNode = 0x40; // CHandle<CPointCommentaryNode>
    constexpr std::ptrdiff_t m_vecNodes = 0x48; // CUtlVector<CHandle<CPointCommentaryNode>>
}

namespace CConstantForceController {
    constexpr std::ptrdiff_t m_linear = 0xC; // Vector
    constexpr std::ptrdiff_t m_angular = 0x18; // RotationVector
    constexpr std::ptrdiff_t m_linearSave = 0x24; // Vector
    constexpr std::ptrdiff_t m_angularSave = 0x30; // RotationVector
}

namespace CConstraintAnchor {
    constexpr std::ptrdiff_t m_massScale = 0x890; // float
}

namespace CCopyRecipientFilter {
    constexpr std::ptrdiff_t m_Flags = 0x8; // int32_t
    constexpr std::ptrdiff_t m_Recipients = 0x10; // CUtlVector<CPlayerSlot>
}

namespace CCredits {
    constexpr std::ptrdiff_t m_OnCreditsDone = 0x4B0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bRolledOutroCredits = 0x4D8; // bool
    constexpr std::ptrdiff_t m_flLogoLength = 0x4DC; // float
}

namespace CDamageRecord {
    constexpr std::ptrdiff_t m_PlayerDamager = 0x28; // CHandle<CCSPlayerPawnBase>
    constexpr std::ptrdiff_t m_PlayerRecipient = 0x2C; // CHandle<CCSPlayerPawnBase>
    constexpr std::ptrdiff_t m_hPlayerControllerDamager = 0x30; // CHandle<CCSPlayerController>
    constexpr std::ptrdiff_t m_hPlayerControllerRecipient = 0x34; // CHandle<CCSPlayerController>
    constexpr std::ptrdiff_t m_szPlayerDamagerName = 0x38; // CUtlString
    constexpr std::ptrdiff_t m_szPlayerRecipientName = 0x40; // CUtlString
    constexpr std::ptrdiff_t m_DamagerXuid = 0x48; // uint64_t
    constexpr std::ptrdiff_t m_RecipientXuid = 0x50; // uint64_t
    constexpr std::ptrdiff_t m_iDamage = 0x58; // int32_t
    constexpr std::ptrdiff_t m_iActualHealthRemoved = 0x5C; // int32_t
    constexpr std::ptrdiff_t m_iNumHits = 0x60; // int32_t
    constexpr std::ptrdiff_t m_iLastBulletUpdate = 0x64; // int32_t
    constexpr std::ptrdiff_t m_bIsOtherEnemy = 0x68; // bool
    constexpr std::ptrdiff_t m_killType = 0x69; // EKillTypes_t
}

namespace CDebugHistory {
    constexpr std::ptrdiff_t m_nNpcEvents = 0x44F0; // int32_t
}

namespace CDecoyProjectile {
    constexpr std::ptrdiff_t m_nDecoyShotTick = 0xA48; // int32_t
    constexpr std::ptrdiff_t m_shotsRemaining = 0xA4C; // int32_t
    constexpr std::ptrdiff_t m_fExpireTime = 0xA50; // GameTime_t
    constexpr std::ptrdiff_t m_decoyWeaponDefIndex = 0xA60; // uint16_t
}

namespace CDynamicLight {
    constexpr std::ptrdiff_t m_ActualFlags = 0x700; // uint8_t
    constexpr std::ptrdiff_t m_Flags = 0x701; // uint8_t
    constexpr std::ptrdiff_t m_LightStyle = 0x702; // uint8_t
    constexpr std::ptrdiff_t m_On = 0x703; // bool
    constexpr std::ptrdiff_t m_Radius = 0x704; // float
    constexpr std::ptrdiff_t m_Exponent = 0x708; // int32_t
    constexpr std::ptrdiff_t m_InnerAngle = 0x70C; // float
    constexpr std::ptrdiff_t m_OuterAngle = 0x710; // float
    constexpr std::ptrdiff_t m_SpotRadius = 0x714; // float
}

namespace CDynamicProp {
    constexpr std::ptrdiff_t m_bCreateNavObstacle = 0xA10; // bool
    constexpr std::ptrdiff_t m_bUseHitboxesForRenderBox = 0xA11; // bool
    constexpr std::ptrdiff_t m_bUseAnimGraph = 0xA12; // bool
    constexpr std::ptrdiff_t m_pOutputAnimBegun = 0xA18; // CEntityIOOutput
    constexpr std::ptrdiff_t m_pOutputAnimOver = 0xA40; // CEntityIOOutput
    constexpr std::ptrdiff_t m_pOutputAnimLoopCycleOver = 0xA68; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnAnimReachedStart = 0xA90; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnAnimReachedEnd = 0xAB8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_iszDefaultAnim = 0xAE0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nDefaultAnimLoopMode = 0xAE8; // AnimLoopMode_t
    constexpr std::ptrdiff_t m_bAnimateOnServer = 0xAEC; // bool
    constexpr std::ptrdiff_t m_bRandomizeCycle = 0xAED; // bool
    constexpr std::ptrdiff_t m_bStartDisabled = 0xAEE; // bool
    constexpr std::ptrdiff_t m_bScriptedMovement = 0xAEF; // bool
    constexpr std::ptrdiff_t m_bFiredStartEndOutput = 0xAF0; // bool
    constexpr std::ptrdiff_t m_bForceNpcExclude = 0xAF1; // bool
    constexpr std::ptrdiff_t m_bCreateNonSolid = 0xAF2; // bool
    constexpr std::ptrdiff_t m_bIsOverrideProp = 0xAF3; // bool
    constexpr std::ptrdiff_t m_iInitialGlowState = 0xAF4; // int32_t
    constexpr std::ptrdiff_t m_nGlowRange = 0xAF8; // int32_t
    constexpr std::ptrdiff_t m_nGlowRangeMin = 0xAFC; // int32_t
    constexpr std::ptrdiff_t m_glowColor = 0xB00; // Color
    constexpr std::ptrdiff_t m_nGlowTeam = 0xB04; // int32_t
}

namespace CEconEntity {
    constexpr std::ptrdiff_t m_AttributeManager = 0x930; // CAttributeContainer
    constexpr std::ptrdiff_t m_OriginalOwnerXuidLow = 0xBF8; // uint32_t
    constexpr std::ptrdiff_t m_OriginalOwnerXuidHigh = 0xBFC; // uint32_t
    constexpr std::ptrdiff_t m_nFallbackPaintKit = 0xC00; // int32_t
    constexpr std::ptrdiff_t m_nFallbackSeed = 0xC04; // int32_t
    constexpr std::ptrdiff_t m_flFallbackWear = 0xC08; // float
    constexpr std::ptrdiff_t m_nFallbackStatTrak = 0xC0C; // int32_t
    constexpr std::ptrdiff_t m_hOldProvidee = 0xC10; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iOldOwnerClass = 0xC14; // int32_t
}

namespace CEconItemAttribute {
    constexpr std::ptrdiff_t m_iAttributeDefinitionIndex = 0x30; // uint16_t
    constexpr std::ptrdiff_t m_flValue = 0x34; // float
    constexpr std::ptrdiff_t m_flInitialValue = 0x38; // float
    constexpr std::ptrdiff_t m_nRefundableCurrency = 0x3C; // int32_t
    constexpr std::ptrdiff_t m_bSetBonus = 0x40; // bool
}

namespace CEconItemView {
    constexpr std::ptrdiff_t m_iItemDefinitionIndex = 0x38; // uint16_t
    constexpr std::ptrdiff_t m_iEntityQuality = 0x3C; // int32_t
    constexpr std::ptrdiff_t m_iEntityLevel = 0x40; // uint32_t
    constexpr std::ptrdiff_t m_iItemID = 0x48; // uint64_t
    constexpr std::ptrdiff_t m_iItemIDHigh = 0x50; // uint32_t
    constexpr std::ptrdiff_t m_iItemIDLow = 0x54; // uint32_t
    constexpr std::ptrdiff_t m_iAccountID = 0x58; // uint32_t
    constexpr std::ptrdiff_t m_iInventoryPosition = 0x5C; // uint32_t
    constexpr std::ptrdiff_t m_bInitialized = 0x68; // bool
    constexpr std::ptrdiff_t m_AttributeList = 0x70; // CAttributeList
    constexpr std::ptrdiff_t m_NetworkedDynamicAttributes = 0xD0; // CAttributeList
    constexpr std::ptrdiff_t m_szCustomName = 0x130; // char[161]
    constexpr std::ptrdiff_t m_szCustomNameOverride = 0x1D1; // char[161]
}

namespace CEconWearable {
    constexpr std::ptrdiff_t m_nForceSkin = 0xC18; // int32_t
    constexpr std::ptrdiff_t m_bAlwaysAllow = 0xC1C; // bool
}

namespace CEffectData {
    constexpr std::ptrdiff_t m_vOrigin = 0x8; // Vector
    constexpr std::ptrdiff_t m_vStart = 0x14; // Vector
    constexpr std::ptrdiff_t m_vNormal = 0x20; // Vector
    constexpr std::ptrdiff_t m_vAngles = 0x2C; // QAngle
    constexpr std::ptrdiff_t m_hEntity = 0x38; // CEntityHandle
    constexpr std::ptrdiff_t m_hOtherEntity = 0x3C; // CEntityHandle
    constexpr std::ptrdiff_t m_flScale = 0x40; // float
    constexpr std::ptrdiff_t m_flMagnitude = 0x44; // float
    constexpr std::ptrdiff_t m_flRadius = 0x48; // float
    constexpr std::ptrdiff_t m_nSurfaceProp = 0x4C; // CUtlStringToken
    constexpr std::ptrdiff_t m_nEffectIndex = 0x50; // CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_nDamageType = 0x58; // uint32_t
    constexpr std::ptrdiff_t m_nPenetrate = 0x5C; // uint8_t
    constexpr std::ptrdiff_t m_nMaterial = 0x5E; // uint16_t
    constexpr std::ptrdiff_t m_nHitBox = 0x60; // uint16_t
    constexpr std::ptrdiff_t m_nColor = 0x62; // uint8_t
    constexpr std::ptrdiff_t m_fFlags = 0x63; // uint8_t
    constexpr std::ptrdiff_t m_nAttachmentIndex = 0x64; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_nAttachmentName = 0x68; // CUtlStringToken
    constexpr std::ptrdiff_t m_iEffectName = 0x6C; // uint16_t
    constexpr std::ptrdiff_t m_nExplosionType = 0x6E; // uint8_t
}

namespace CEntityDissolve {
    constexpr std::ptrdiff_t m_flFadeInStart = 0x700; // float
    constexpr std::ptrdiff_t m_flFadeInLength = 0x704; // float
    constexpr std::ptrdiff_t m_flFadeOutModelStart = 0x708; // float
    constexpr std::ptrdiff_t m_flFadeOutModelLength = 0x70C; // float
    constexpr std::ptrdiff_t m_flFadeOutStart = 0x710; // float
    constexpr std::ptrdiff_t m_flFadeOutLength = 0x714; // float
    constexpr std::ptrdiff_t m_flStartTime = 0x718; // GameTime_t
    constexpr std::ptrdiff_t m_nDissolveType = 0x71C; // EntityDisolveType_t
    constexpr std::ptrdiff_t m_vDissolverOrigin = 0x720; // Vector
    constexpr std::ptrdiff_t m_nMagnitude = 0x72C; // uint32_t
}

namespace CEntityFlame {
    constexpr std::ptrdiff_t m_hEntAttached = 0x4B0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bCheapEffect = 0x4B4; // bool
    constexpr std::ptrdiff_t m_flSize = 0x4B8; // float
    constexpr std::ptrdiff_t m_bUseHitboxes = 0x4BC; // bool
    constexpr std::ptrdiff_t m_iNumHitboxFires = 0x4C0; // int32_t
    constexpr std::ptrdiff_t m_flHitboxFireScale = 0x4C4; // float
    constexpr std::ptrdiff_t m_flLifetime = 0x4C8; // GameTime_t
    constexpr std::ptrdiff_t m_hAttacker = 0x4CC; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iDangerSound = 0x4D0; // int32_t
    constexpr std::ptrdiff_t m_flDirectDamagePerSecond = 0x4D4; // float
    constexpr std::ptrdiff_t m_iCustomDamageType = 0x4D8; // int32_t
}

namespace CEntityIdentity {
    constexpr std::ptrdiff_t m_nameStringableIndex = 0x14; // int32_t
    constexpr std::ptrdiff_t m_name = 0x18; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_designerName = 0x20; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flags = 0x30; // uint32_t
    constexpr std::ptrdiff_t m_worldGroupId = 0x38; // WorldGroupId_t
    constexpr std::ptrdiff_t m_fDataObjectTypes = 0x3C; // uint32_t
    constexpr std::ptrdiff_t m_PathIndex = 0x40; // ChangeAccessorFieldPathIndex_t
    constexpr std::ptrdiff_t m_pPrev = 0x58; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pNext = 0x60; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pPrevByClass = 0x68; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pNextByClass = 0x70; // CEntityIdentity*
}

namespace CEntityInstance {
    constexpr std::ptrdiff_t m_iszPrivateVScripts = 0x8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_pEntity = 0x10; // CEntityIdentity*
    constexpr std::ptrdiff_t m_CScriptComponent = 0x28; // CScriptComponent*
}

namespace CEnvBeam {
    constexpr std::ptrdiff_t m_active = 0x7A0; // int32_t
    constexpr std::ptrdiff_t m_spriteTexture = 0x7A8; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_iszStartEntity = 0x7B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszEndEntity = 0x7B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_life = 0x7C0; // float
    constexpr std::ptrdiff_t m_boltWidth = 0x7C4; // float
    constexpr std::ptrdiff_t m_noiseAmplitude = 0x7C8; // float
    constexpr std::ptrdiff_t m_speed = 0x7CC; // int32_t
    constexpr std::ptrdiff_t m_restrike = 0x7D0; // float
    constexpr std::ptrdiff_t m_iszSpriteName = 0x7D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_frameStart = 0x7E0; // int32_t
    constexpr std::ptrdiff_t m_vEndPointWorld = 0x7E4; // Vector
    constexpr std::ptrdiff_t m_vEndPointRelative = 0x7F0; // Vector
    constexpr std::ptrdiff_t m_radius = 0x7FC; // float
    constexpr std::ptrdiff_t m_TouchType = 0x800; // Touch_t
    constexpr std::ptrdiff_t m_iFilterName = 0x808; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hFilter = 0x810; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iszDecal = 0x818; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_OnTouchedByEntity = 0x820; // CEntityIOOutput
}

namespace CEnvBeverage {
    constexpr std::ptrdiff_t m_CanInDispenser = 0x4B0; // bool
    constexpr std::ptrdiff_t m_nBeverageType = 0x4B4; // int32_t
}

namespace CEnvCombinedLightProbeVolume {
    constexpr std::ptrdiff_t m_Color = 0x1508; // Color
    constexpr std::ptrdiff_t m_flBrightness = 0x150C; // float
    constexpr std::ptrdiff_t m_hCubemapTexture = 0x1510; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_bCustomCubemapTexture = 0x1518; // bool
    constexpr std::ptrdiff_t m_hLightProbeTexture = 0x1520; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightIndicesTexture = 0x1528; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightScalarsTexture = 0x1530; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightShadowsTexture = 0x1538; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_vBoxMins = 0x1540; // Vector
    constexpr std::ptrdiff_t m_vBoxMaxs = 0x154C; // Vector
    constexpr std::ptrdiff_t m_bMoveable = 0x1558; // bool
    constexpr std::ptrdiff_t m_nHandshake = 0x155C; // int32_t
    constexpr std::ptrdiff_t m_nEnvCubeMapArrayIndex = 0x1560; // int32_t
    constexpr std::ptrdiff_t m_nPriority = 0x1564; // int32_t
    constexpr std::ptrdiff_t m_bStartDisabled = 0x1568; // bool
    constexpr std::ptrdiff_t m_flEdgeFadeDist = 0x156C; // float
    constexpr std::ptrdiff_t m_vEdgeFadeDists = 0x1570; // Vector
    constexpr std::ptrdiff_t m_nLightProbeSizeX = 0x157C; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeSizeY = 0x1580; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeSizeZ = 0x1584; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasX = 0x1588; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasY = 0x158C; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasZ = 0x1590; // int32_t
    constexpr std::ptrdiff_t m_bEnabled = 0x15A9; // bool
}

namespace CEnvCubemap {
    constexpr std::ptrdiff_t m_hCubemapTexture = 0x530; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_bCustomCubemapTexture = 0x538; // bool
    constexpr std::ptrdiff_t m_flInfluenceRadius = 0x53C; // float
    constexpr std::ptrdiff_t m_vBoxProjectMins = 0x540; // Vector
    constexpr std::ptrdiff_t m_vBoxProjectMaxs = 0x54C; // Vector
    constexpr std::ptrdiff_t m_bMoveable = 0x558; // bool
    constexpr std::ptrdiff_t m_nHandshake = 0x55C; // int32_t
    constexpr std::ptrdiff_t m_nEnvCubeMapArrayIndex = 0x560; // int32_t
    constexpr std::ptrdiff_t m_nPriority = 0x564; // int32_t
    constexpr std::ptrdiff_t m_flEdgeFadeDist = 0x568; // float
    constexpr std::ptrdiff_t m_vEdgeFadeDists = 0x56C; // Vector
    constexpr std::ptrdiff_t m_flDiffuseScale = 0x578; // float
    constexpr std::ptrdiff_t m_bStartDisabled = 0x57C; // bool
    constexpr std::ptrdiff_t m_bDefaultEnvMap = 0x57D; // bool
    constexpr std::ptrdiff_t m_bDefaultSpecEnvMap = 0x57E; // bool
    constexpr std::ptrdiff_t m_bIndoorCubeMap = 0x57F; // bool
    constexpr std::ptrdiff_t m_bCopyDiffuseFromDefaultCubemap = 0x580; // bool
    constexpr std::ptrdiff_t m_bEnabled = 0x590; // bool
}

namespace CEnvCubemapFog {
    constexpr std::ptrdiff_t m_flEndDistance = 0x4B0; // float
    constexpr std::ptrdiff_t m_flStartDistance = 0x4B4; // float
    constexpr std::ptrdiff_t m_flFogFalloffExponent = 0x4B8; // float
    constexpr std::ptrdiff_t m_bHeightFogEnabled = 0x4BC; // bool
    constexpr std::ptrdiff_t m_flFogHeightWidth = 0x4C0; // float
    constexpr std::ptrdiff_t m_flFogHeightEnd = 0x4C4; // float
    constexpr std::ptrdiff_t m_flFogHeightStart = 0x4C8; // float
    constexpr std::ptrdiff_t m_flFogHeightExponent = 0x4CC; // float
    constexpr std::ptrdiff_t m_flLODBias = 0x4D0; // float
    constexpr std::ptrdiff_t m_bActive = 0x4D4; // bool
    constexpr std::ptrdiff_t m_bStartDisabled = 0x4D5; // bool
    constexpr std::ptrdiff_t m_flFogMaxOpacity = 0x4D8; // float
    constexpr std::ptrdiff_t m_nCubemapSourceType = 0x4DC; // int32_t
    constexpr std::ptrdiff_t m_hSkyMaterial = 0x4E0; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_iszSkyEntity = 0x4E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hFogCubemapTexture = 0x4F0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_bHasHeightFogEnd = 0x4F8; // bool
    constexpr std::ptrdiff_t m_bFirstTime = 0x4F9; // bool
}

namespace CEnvDecal {
    constexpr std::ptrdiff_t m_hDecalMaterial = 0x700; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_flWidth = 0x708; // float
    constexpr std::ptrdiff_t m_flHeight = 0x70C; // float
    constexpr std::ptrdiff_t m_flDepth = 0x710; // float
    constexpr std::ptrdiff_t m_nRenderOrder = 0x714; // uint32_t
    constexpr std::ptrdiff_t m_bProjectOnWorld = 0x718; // bool
    constexpr std::ptrdiff_t m_bProjectOnCharacters = 0x719; // bool
    constexpr std::ptrdiff_t m_bProjectOnWater = 0x71A; // bool
    constexpr std::ptrdiff_t m_flDepthSortBias = 0x71C; // float
}

namespace CEnvDetailController {
    constexpr std::ptrdiff_t m_flFadeStartDist = 0x4B0; // float
    constexpr std::ptrdiff_t m_flFadeEndDist = 0x4B4; // float
}

namespace CEnvEntityIgniter {
    constexpr std::ptrdiff_t m_flLifetime = 0x4B0; // float
}

namespace CEnvEntityMaker {
    constexpr std::ptrdiff_t m_vecEntityMins = 0x4B0; // Vector
    constexpr std::ptrdiff_t m_vecEntityMaxs = 0x4BC; // Vector
    constexpr std::ptrdiff_t m_hCurrentInstance = 0x4C8; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hCurrentBlocker = 0x4CC; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_vecBlockerOrigin = 0x4D0; // Vector
    constexpr std::ptrdiff_t m_angPostSpawnDirection = 0x4DC; // QAngle
    constexpr std::ptrdiff_t m_flPostSpawnDirectionVariance = 0x4E8; // float
    constexpr std::ptrdiff_t m_flPostSpawnSpeed = 0x4EC; // float
    constexpr std::ptrdiff_t m_bPostSpawnUseAngles = 0x4F0; // bool
    constexpr std::ptrdiff_t m_iszTemplate = 0x4F8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_pOutputOnSpawned = 0x500; // CEntityIOOutput
    constexpr std::ptrdiff_t m_pOutputOnFailedSpawn = 0x528; // CEntityIOOutput
}

namespace CEnvExplosion {
    constexpr std::ptrdiff_t m_iMagnitude = 0x700; // int32_t
    constexpr std::ptrdiff_t m_flPlayerDamage = 0x704; // float
    constexpr std::ptrdiff_t m_iRadiusOverride = 0x708; // int32_t
    constexpr std::ptrdiff_t m_flInnerRadius = 0x70C; // float
    constexpr std::ptrdiff_t m_spriteScale = 0x710; // int32_t
    constexpr std::ptrdiff_t m_flDamageForce = 0x714; // float
    constexpr std::ptrdiff_t m_hInflictor = 0x718; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iCustomDamageType = 0x71C; // int32_t
    constexpr std::ptrdiff_t m_iszExplosionType = 0x728; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszCustomEffectName = 0x730; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszCustomSoundName = 0x738; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iClassIgnore = 0x740; // Class_T
    constexpr std::ptrdiff_t m_iClassIgnore2 = 0x744; // Class_T
    constexpr std::ptrdiff_t m_iszEntityIgnoreName = 0x748; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hEntityIgnore = 0x750; // CHandle<CBaseEntity>
}

namespace CEnvFade {
    constexpr std::ptrdiff_t m_fadeColor = 0x4B0; // Color
    constexpr std::ptrdiff_t m_Duration = 0x4B4; // float
    constexpr std::ptrdiff_t m_HoldDuration = 0x4B8; // float
    constexpr std::ptrdiff_t m_OnBeginFade = 0x4C0; // CEntityIOOutput
}

namespace CEnvFireSensor {
    constexpr std::ptrdiff_t m_bEnabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_bHeatAtLevel = 0x4B1; // bool
    constexpr std::ptrdiff_t m_radius = 0x4B4; // float
    constexpr std::ptrdiff_t m_targetLevel = 0x4B8; // float
    constexpr std::ptrdiff_t m_targetTime = 0x4BC; // float
    constexpr std::ptrdiff_t m_levelTime = 0x4C0; // float
    constexpr std::ptrdiff_t m_OnHeatLevelStart = 0x4C8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnHeatLevelEnd = 0x4F0; // CEntityIOOutput
}

namespace CEnvFireSource {
    constexpr std::ptrdiff_t m_bEnabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_radius = 0x4B4; // float
    constexpr std::ptrdiff_t m_damage = 0x4B8; // float
}

namespace CEnvGlobal {
    constexpr std::ptrdiff_t m_outCounter = 0x4B0; // CEntityOutputTemplate<int32_t>
    constexpr std::ptrdiff_t m_globalstate = 0x4D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_triggermode = 0x4E0; // int32_t
    constexpr std::ptrdiff_t m_initialstate = 0x4E4; // int32_t
    constexpr std::ptrdiff_t m_counter = 0x4E8; // int32_t
}

namespace CEnvHudHint {
    constexpr std::ptrdiff_t m_iszMessage = 0x4B0; // CUtlSymbolLarge
}

namespace CEnvInstructorHint {
    constexpr std::ptrdiff_t m_iszName = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszReplace_Key = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszHintTargetEntity = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iTimeout = 0x4C8; // int32_t
    constexpr std::ptrdiff_t m_iDisplayLimit = 0x4CC; // int32_t
    constexpr std::ptrdiff_t m_iszIcon_Onscreen = 0x4D0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszIcon_Offscreen = 0x4D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszCaption = 0x4E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszActivatorCaption = 0x4E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_Color = 0x4F0; // Color
    constexpr std::ptrdiff_t m_fIconOffset = 0x4F4; // float
    constexpr std::ptrdiff_t m_fRange = 0x4F8; // float
    constexpr std::ptrdiff_t m_iPulseOption = 0x4FC; // uint8_t
    constexpr std::ptrdiff_t m_iAlphaOption = 0x4FD; // uint8_t
    constexpr std::ptrdiff_t m_iShakeOption = 0x4FE; // uint8_t
    constexpr std::ptrdiff_t m_bStatic = 0x4FF; // bool
    constexpr std::ptrdiff_t m_bNoOffscreen = 0x500; // bool
    constexpr std::ptrdiff_t m_bForceCaption = 0x501; // bool
    constexpr std::ptrdiff_t m_iInstanceType = 0x504; // int32_t
    constexpr std::ptrdiff_t m_bSuppressRest = 0x508; // bool
    constexpr std::ptrdiff_t m_iszBinding = 0x510; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bAllowNoDrawTarget = 0x518; // bool
    constexpr std::ptrdiff_t m_bAutoStart = 0x519; // bool
    constexpr std::ptrdiff_t m_bLocalPlayerOnly = 0x51A; // bool
}

namespace CEnvInstructorVRHint {
    constexpr std::ptrdiff_t m_iszName = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszHintTargetEntity = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iTimeout = 0x4C0; // int32_t
    constexpr std::ptrdiff_t m_iszCaption = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszStartSound = 0x4D0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iLayoutFileType = 0x4D8; // int32_t
    constexpr std::ptrdiff_t m_iszCustomLayoutFile = 0x4E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iAttachType = 0x4E8; // int32_t
    constexpr std::ptrdiff_t m_flHeightOffset = 0x4EC; // float
}

namespace CEnvLaser {
    constexpr std::ptrdiff_t m_iszLaserTarget = 0x7A0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_pSprite = 0x7A8; // CSprite*
    constexpr std::ptrdiff_t m_iszSpriteName = 0x7B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_firePosition = 0x7B8; // Vector
    constexpr std::ptrdiff_t m_flStartFrame = 0x7C4; // float
}

namespace CEnvLightProbeVolume {
    constexpr std::ptrdiff_t m_hLightProbeTexture = 0x1488; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightIndicesTexture = 0x1490; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightScalarsTexture = 0x1498; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightShadowsTexture = 0x14A0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_vBoxMins = 0x14A8; // Vector
    constexpr std::ptrdiff_t m_vBoxMaxs = 0x14B4; // Vector
    constexpr std::ptrdiff_t m_bMoveable = 0x14C0; // bool
    constexpr std::ptrdiff_t m_nHandshake = 0x14C4; // int32_t
    constexpr std::ptrdiff_t m_nPriority = 0x14C8; // int32_t
    constexpr std::ptrdiff_t m_bStartDisabled = 0x14CC; // bool
    constexpr std::ptrdiff_t m_nLightProbeSizeX = 0x14D0; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeSizeY = 0x14D4; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeSizeZ = 0x14D8; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasX = 0x14DC; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasY = 0x14E0; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasZ = 0x14E4; // int32_t
    constexpr std::ptrdiff_t m_bEnabled = 0x14F1; // bool
}

namespace CEnvMicrophone {
    constexpr std::ptrdiff_t m_bDisabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_hMeasureTarget = 0x4B4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_nSoundMask = 0x4B8; // int32_t
    constexpr std::ptrdiff_t m_flSensitivity = 0x4BC; // float
    constexpr std::ptrdiff_t m_flSmoothFactor = 0x4C0; // float
    constexpr std::ptrdiff_t m_flMaxRange = 0x4C4; // float
    constexpr std::ptrdiff_t m_iszSpeakerName = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hSpeaker = 0x4D0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bAvoidFeedback = 0x4D4; // bool
    constexpr std::ptrdiff_t m_iSpeakerDSPPreset = 0x4D8; // int32_t
    constexpr std::ptrdiff_t m_iszListenFilter = 0x4E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hListenFilter = 0x4E8; // CHandle<CBaseFilter>
    constexpr std::ptrdiff_t m_SoundLevel = 0x4F0; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnRoutedSound = 0x518; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnHeardSound = 0x540; // CEntityIOOutput
    constexpr std::ptrdiff_t m_szLastSound = 0x568; // char[256]
    constexpr std::ptrdiff_t m_iLastRoutedFrame = 0x668; // int32_t
}

namespace CEnvMuzzleFlash {
    constexpr std::ptrdiff_t m_flScale = 0x4B0; // float
    constexpr std::ptrdiff_t m_iszParentAttachment = 0x4B8; // CUtlSymbolLarge
}

namespace CEnvParticleGlow {
    constexpr std::ptrdiff_t m_flAlphaScale = 0xC78; // float
    constexpr std::ptrdiff_t m_flRadiusScale = 0xC7C; // float
    constexpr std::ptrdiff_t m_flSelfIllumScale = 0xC80; // float
    constexpr std::ptrdiff_t m_ColorTint = 0xC84; // Color
    constexpr std::ptrdiff_t m_hTextureOverride = 0xC88; // CStrongHandle<InfoForResourceTypeCTextureBase>
}

namespace CEnvProjectedTexture {
    constexpr std::ptrdiff_t m_hTargetEntity = 0x700; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bState = 0x704; // bool
    constexpr std::ptrdiff_t m_bAlwaysUpdate = 0x705; // bool
    constexpr std::ptrdiff_t m_flLightFOV = 0x708; // float
    constexpr std::ptrdiff_t m_bEnableShadows = 0x70C; // bool
    constexpr std::ptrdiff_t m_bSimpleProjection = 0x70D; // bool
    constexpr std::ptrdiff_t m_bLightOnlyTarget = 0x70E; // bool
    constexpr std::ptrdiff_t m_bLightWorld = 0x70F; // bool
    constexpr std::ptrdiff_t m_bCameraSpace = 0x710; // bool
    constexpr std::ptrdiff_t m_flBrightnessScale = 0x714; // float
    constexpr std::ptrdiff_t m_LightColor = 0x718; // Color
    constexpr std::ptrdiff_t m_flIntensity = 0x71C; // float
    constexpr std::ptrdiff_t m_flLinearAttenuation = 0x720; // float
    constexpr std::ptrdiff_t m_flQuadraticAttenuation = 0x724; // float
    constexpr std::ptrdiff_t m_bVolumetric = 0x728; // bool
    constexpr std::ptrdiff_t m_flNoiseStrength = 0x72C; // float
    constexpr std::ptrdiff_t m_flFlashlightTime = 0x730; // float
    constexpr std::ptrdiff_t m_nNumPlanes = 0x734; // uint32_t
    constexpr std::ptrdiff_t m_flPlaneOffset = 0x738; // float
    constexpr std::ptrdiff_t m_flVolumetricIntensity = 0x73C; // float
    constexpr std::ptrdiff_t m_flColorTransitionTime = 0x740; // float
    constexpr std::ptrdiff_t m_flAmbient = 0x744; // float
    constexpr std::ptrdiff_t m_SpotlightTextureName = 0x748; // char[512]
    constexpr std::ptrdiff_t m_nSpotlightTextureFrame = 0x948; // int32_t
    constexpr std::ptrdiff_t m_nShadowQuality = 0x94C; // uint32_t
    constexpr std::ptrdiff_t m_flNearZ = 0x950; // float
    constexpr std::ptrdiff_t m_flFarZ = 0x954; // float
    constexpr std::ptrdiff_t m_flProjectionSize = 0x958; // float
    constexpr std::ptrdiff_t m_flRotation = 0x95C; // float
    constexpr std::ptrdiff_t m_bFlipHorizontal = 0x960; // bool
}

namespace CEnvScreenOverlay {
    constexpr std::ptrdiff_t m_iszOverlayNames = 0x4B0; // CUtlSymbolLarge[10]
    constexpr std::ptrdiff_t m_flOverlayTimes = 0x500; // float[10]
    constexpr std::ptrdiff_t m_flStartTime = 0x528; // GameTime_t
    constexpr std::ptrdiff_t m_iDesiredOverlay = 0x52C; // int32_t
    constexpr std::ptrdiff_t m_bIsActive = 0x530; // bool
}

namespace CEnvShake {
    constexpr std::ptrdiff_t m_limitToEntity = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_Amplitude = 0x4B8; // float
    constexpr std::ptrdiff_t m_Frequency = 0x4BC; // float
    constexpr std::ptrdiff_t m_Duration = 0x4C0; // float
    constexpr std::ptrdiff_t m_Radius = 0x4C4; // float
    constexpr std::ptrdiff_t m_stopTime = 0x4C8; // GameTime_t
    constexpr std::ptrdiff_t m_nextShake = 0x4CC; // GameTime_t
    constexpr std::ptrdiff_t m_currentAmp = 0x4D0; // float
    constexpr std::ptrdiff_t m_maxForce = 0x4D4; // Vector
    constexpr std::ptrdiff_t m_shakeCallback = 0x4E8; // CPhysicsShake
}

namespace CEnvSky {
    constexpr std::ptrdiff_t m_hSkyMaterial = 0x700; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_hSkyMaterialLightingOnly = 0x708; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_bStartDisabled = 0x710; // bool
    constexpr std::ptrdiff_t m_vTintColor = 0x711; // Color
    constexpr std::ptrdiff_t m_vTintColorLightingOnly = 0x715; // Color
    constexpr std::ptrdiff_t m_flBrightnessScale = 0x71C; // float
    constexpr std::ptrdiff_t m_nFogType = 0x720; // int32_t
    constexpr std::ptrdiff_t m_flFogMinStart = 0x724; // float
    constexpr std::ptrdiff_t m_flFogMinEnd = 0x728; // float
    constexpr std::ptrdiff_t m_flFogMaxStart = 0x72C; // float
    constexpr std::ptrdiff_t m_flFogMaxEnd = 0x730; // float
    constexpr std::ptrdiff_t m_bEnabled = 0x734; // bool
}

namespace CEnvSoundscape {
    constexpr std::ptrdiff_t m_OnPlay = 0x4B0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_flRadius = 0x4D8; // float
    constexpr std::ptrdiff_t m_soundscapeName = 0x4E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_soundEventName = 0x4E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bOverrideWithEvent = 0x4F0; // bool
    constexpr std::ptrdiff_t m_soundscapeIndex = 0x4F4; // int32_t
    constexpr std::ptrdiff_t m_soundscapeEntityListId = 0x4F8; // int32_t
    constexpr std::ptrdiff_t m_soundEventHash = 0x4FC; // uint32_t
    constexpr std::ptrdiff_t m_positionNames = 0x500; // CUtlSymbolLarge[8]
    constexpr std::ptrdiff_t m_hProxySoundscape = 0x540; // CHandle<CEnvSoundscape>
    constexpr std::ptrdiff_t m_bDisabled = 0x544; // bool
}

namespace CEnvSoundscapeProxy {
    constexpr std::ptrdiff_t m_MainSoundscapeName = 0x548; // CUtlSymbolLarge
}

namespace CEnvSpark {
    constexpr std::ptrdiff_t m_flDelay = 0x4B0; // float
    constexpr std::ptrdiff_t m_nMagnitude = 0x4B4; // int32_t
    constexpr std::ptrdiff_t m_nTrailLength = 0x4B8; // int32_t
    constexpr std::ptrdiff_t m_nType = 0x4BC; // int32_t
    constexpr std::ptrdiff_t m_OnSpark = 0x4C0; // CEntityIOOutput
}

namespace CEnvSplash {
    constexpr std::ptrdiff_t m_flScale = 0x4B0; // float
}

namespace CEnvTilt {
    constexpr std::ptrdiff_t m_Duration = 0x4B0; // float
    constexpr std::ptrdiff_t m_Radius = 0x4B4; // float
    constexpr std::ptrdiff_t m_TiltTime = 0x4B8; // float
    constexpr std::ptrdiff_t m_stopTime = 0x4BC; // GameTime_t
}

namespace CEnvTracer {
    constexpr std::ptrdiff_t m_vecEnd = 0x4B0; // Vector
    constexpr std::ptrdiff_t m_flDelay = 0x4BC; // float
}

namespace CEnvViewPunch {
    constexpr std::ptrdiff_t m_flRadius = 0x4B0; // float
    constexpr std::ptrdiff_t m_angViewPunch = 0x4B4; // QAngle
}

namespace CEnvVolumetricFogController {
    constexpr std::ptrdiff_t m_flScattering = 0x4B0; // float
    constexpr std::ptrdiff_t m_flAnisotropy = 0x4B4; // float
    constexpr std::ptrdiff_t m_flFadeSpeed = 0x4B8; // float
    constexpr std::ptrdiff_t m_flDrawDistance = 0x4BC; // float
    constexpr std::ptrdiff_t m_flFadeInStart = 0x4C0; // float
    constexpr std::ptrdiff_t m_flFadeInEnd = 0x4C4; // float
    constexpr std::ptrdiff_t m_flIndirectStrength = 0x4C8; // float
    constexpr std::ptrdiff_t m_nIndirectTextureDimX = 0x4CC; // int32_t
    constexpr std::ptrdiff_t m_nIndirectTextureDimY = 0x4D0; // int32_t
    constexpr std::ptrdiff_t m_nIndirectTextureDimZ = 0x4D4; // int32_t
    constexpr std::ptrdiff_t m_vBoxMins = 0x4D8; // Vector
    constexpr std::ptrdiff_t m_vBoxMaxs = 0x4E4; // Vector
    constexpr std::ptrdiff_t m_bActive = 0x4F0; // bool
    constexpr std::ptrdiff_t m_flStartAnisoTime = 0x4F4; // GameTime_t
    constexpr std::ptrdiff_t m_flStartScatterTime = 0x4F8; // GameTime_t
    constexpr std::ptrdiff_t m_flStartDrawDistanceTime = 0x4FC; // GameTime_t
    constexpr std::ptrdiff_t m_flStartAnisotropy = 0x500; // float
    constexpr std::ptrdiff_t m_flStartScattering = 0x504; // float
    constexpr std::ptrdiff_t m_flStartDrawDistance = 0x508; // float
    constexpr std::ptrdiff_t m_flDefaultAnisotropy = 0x50C; // float
    constexpr std::ptrdiff_t m_flDefaultScattering = 0x510; // float
    constexpr std::ptrdiff_t m_flDefaultDrawDistance = 0x514; // float
    constexpr std::ptrdiff_t m_bStartDisabled = 0x518; // bool
    constexpr std::ptrdiff_t m_bEnableIndirect = 0x519; // bool
    constexpr std::ptrdiff_t m_bIsMaster = 0x51A; // bool
    constexpr std::ptrdiff_t m_hFogIndirectTexture = 0x520; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_nForceRefreshCount = 0x528; // int32_t
    constexpr std::ptrdiff_t m_bFirstTime = 0x52C; // bool
}

namespace CEnvVolumetricFogVolume {
    constexpr std::ptrdiff_t m_bActive = 0x4B0; // bool
    constexpr std::ptrdiff_t m_vBoxMins = 0x4B4; // Vector
    constexpr std::ptrdiff_t m_vBoxMaxs = 0x4C0; // Vector
    constexpr std::ptrdiff_t m_bStartDisabled = 0x4CC; // bool
    constexpr std::ptrdiff_t m_flStrength = 0x4D0; // float
    constexpr std::ptrdiff_t m_nFalloffShape = 0x4D4; // int32_t
    constexpr std::ptrdiff_t m_flFalloffExponent = 0x4D8; // float
}

namespace CEnvWind {
    constexpr std::ptrdiff_t m_EnvWindShared = 0x4B0; // CEnvWindShared
}

namespace CEnvWindShared {
    constexpr std::ptrdiff_t m_flStartTime = 0x8; // GameTime_t
    constexpr std::ptrdiff_t m_iWindSeed = 0xC; // uint32_t
    constexpr std::ptrdiff_t m_iMinWind = 0x10; // uint16_t
    constexpr std::ptrdiff_t m_iMaxWind = 0x12; // uint16_t
    constexpr std::ptrdiff_t m_windRadius = 0x14; // int32_t
    constexpr std::ptrdiff_t m_iMinGust = 0x18; // uint16_t
    constexpr std::ptrdiff_t m_iMaxGust = 0x1A; // uint16_t
    constexpr std::ptrdiff_t m_flMinGustDelay = 0x1C; // float
    constexpr std::ptrdiff_t m_flMaxGustDelay = 0x20; // float
    constexpr std::ptrdiff_t m_flGustDuration = 0x24; // float
    constexpr std::ptrdiff_t m_iGustDirChange = 0x28; // uint16_t
    constexpr std::ptrdiff_t m_location = 0x2C; // Vector
    constexpr std::ptrdiff_t m_iszGustSound = 0x38; // int32_t
    constexpr std::ptrdiff_t m_iWindDir = 0x3C; // int32_t
    constexpr std::ptrdiff_t m_flWindSpeed = 0x40; // float
    constexpr std::ptrdiff_t m_currentWindVector = 0x44; // Vector
    constexpr std::ptrdiff_t m_CurrentSwayVector = 0x50; // Vector
    constexpr std::ptrdiff_t m_PrevSwayVector = 0x5C; // Vector
    constexpr std::ptrdiff_t m_iInitialWindDir = 0x68; // uint16_t
    constexpr std::ptrdiff_t m_flInitialWindSpeed = 0x6C; // float
    constexpr std::ptrdiff_t m_OnGustStart = 0x70; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnGustEnd = 0x98; // CEntityIOOutput
    constexpr std::ptrdiff_t m_flVariationTime = 0xC0; // GameTime_t
    constexpr std::ptrdiff_t m_flSwayTime = 0xC4; // GameTime_t
    constexpr std::ptrdiff_t m_flSimTime = 0xC8; // GameTime_t
    constexpr std::ptrdiff_t m_flSwitchTime = 0xCC; // GameTime_t
    constexpr std::ptrdiff_t m_flAveWindSpeed = 0xD0; // float
    constexpr std::ptrdiff_t m_bGusting = 0xD4; // bool
    constexpr std::ptrdiff_t m_flWindAngleVariation = 0xD8; // float
    constexpr std::ptrdiff_t m_flWindSpeedVariation = 0xDC; // float
    constexpr std::ptrdiff_t m_iEntIndex = 0xE0; // CEntityIndex
}

namespace CEnvWindShared_WindAveEvent_t {
    constexpr std::ptrdiff_t m_flStartWindSpeed = 0x0; // float
    constexpr std::ptrdiff_t m_flAveWindSpeed = 0x4; // float
}

namespace CEnvWindShared_WindVariationEvent_t {
    constexpr std::ptrdiff_t m_flWindAngleVariation = 0x0; // float
    constexpr std::ptrdiff_t m_flWindSpeedVariation = 0x4; // float
}

namespace CFilterAttributeInt {
    constexpr std::ptrdiff_t m_sAttributeName = 0x508; // CUtlStringToken
}

namespace CFilterClass {
    constexpr std::ptrdiff_t m_iFilterClass = 0x508; // CUtlSymbolLarge
}

namespace CFilterContext {
    constexpr std::ptrdiff_t m_iFilterContext = 0x508; // CUtlSymbolLarge
}

namespace CFilterEnemy {
    constexpr std::ptrdiff_t m_iszEnemyName = 0x508; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flRadius = 0x510; // float
    constexpr std::ptrdiff_t m_flOuterRadius = 0x514; // float
    constexpr std::ptrdiff_t m_nMaxSquadmatesPerEnemy = 0x518; // int32_t
    constexpr std::ptrdiff_t m_iszPlayerName = 0x520; // CUtlSymbolLarge
}

namespace CFilterMassGreater {
    constexpr std::ptrdiff_t m_fFilterMass = 0x508; // float
}

namespace CFilterModel {
    constexpr std::ptrdiff_t m_iFilterModel = 0x508; // CUtlSymbolLarge
}

namespace CFilterMultiple {
    constexpr std::ptrdiff_t m_nFilterType = 0x508; // filter_t
    constexpr std::ptrdiff_t m_iFilterName = 0x510; // CUtlSymbolLarge[10]
    constexpr std::ptrdiff_t m_hFilter = 0x560; // CHandle<CBaseEntity>[10]
    constexpr std::ptrdiff_t m_nFilterCount = 0x588; // int32_t
}

namespace CFilterName {
    constexpr std::ptrdiff_t m_iFilterName = 0x508; // CUtlSymbolLarge
}

namespace CFilterProximity {
    constexpr std::ptrdiff_t m_flRadius = 0x508; // float
}

namespace CFire {
    constexpr std::ptrdiff_t m_hEffect = 0x700; // CHandle<CBaseFire>
    constexpr std::ptrdiff_t m_hOwner = 0x704; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_nFireType = 0x708; // int32_t
    constexpr std::ptrdiff_t m_flFuel = 0x70C; // float
    constexpr std::ptrdiff_t m_flDamageTime = 0x710; // GameTime_t
    constexpr std::ptrdiff_t m_lastDamage = 0x714; // GameTime_t
    constexpr std::ptrdiff_t m_flFireSize = 0x718; // float
    constexpr std::ptrdiff_t m_flLastNavUpdateTime = 0x71C; // GameTime_t
    constexpr std::ptrdiff_t m_flHeatLevel = 0x720; // float
    constexpr std::ptrdiff_t m_flHeatAbsorb = 0x724; // float
    constexpr std::ptrdiff_t m_flDamageScale = 0x728; // float
    constexpr std::ptrdiff_t m_flMaxHeat = 0x72C; // float
    constexpr std::ptrdiff_t m_flLastHeatLevel = 0x730; // float
    constexpr std::ptrdiff_t m_flAttackTime = 0x734; // float
    constexpr std::ptrdiff_t m_bEnabled = 0x738; // bool
    constexpr std::ptrdiff_t m_bStartDisabled = 0x739; // bool
    constexpr std::ptrdiff_t m_bDidActivate = 0x73A; // bool
    constexpr std::ptrdiff_t m_OnIgnited = 0x740; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnExtinguished = 0x768; // CEntityIOOutput
}

namespace CFireSmoke {
    constexpr std::ptrdiff_t m_nFlameModelIndex = 0x4C0; // int32_t
    constexpr std::ptrdiff_t m_nFlameFromAboveModelIndex = 0x4C4; // int32_t
}

namespace CFiringModeFloat {
    constexpr std::ptrdiff_t m_flValues = 0x0; // float[2]
}

namespace CFiringModeInt {
    constexpr std::ptrdiff_t m_nValues = 0x0; // int32_t[2]
}

namespace CFish {
    constexpr std::ptrdiff_t m_pool = 0x890; // CHandle<CFishPool>
    constexpr std::ptrdiff_t m_id = 0x894; // uint32_t
    constexpr std::ptrdiff_t m_x = 0x898; // float
    constexpr std::ptrdiff_t m_y = 0x89C; // float
    constexpr std::ptrdiff_t m_z = 0x8A0; // float
    constexpr std::ptrdiff_t m_angle = 0x8A4; // float
    constexpr std::ptrdiff_t m_angleChange = 0x8A8; // float
    constexpr std::ptrdiff_t m_forward = 0x8AC; // Vector
    constexpr std::ptrdiff_t m_perp = 0x8B8; // Vector
    constexpr std::ptrdiff_t m_poolOrigin = 0x8C4; // Vector
    constexpr std::ptrdiff_t m_waterLevel = 0x8D0; // float
    constexpr std::ptrdiff_t m_speed = 0x8D4; // float
    constexpr std::ptrdiff_t m_desiredSpeed = 0x8D8; // float
    constexpr std::ptrdiff_t m_calmSpeed = 0x8DC; // float
    constexpr std::ptrdiff_t m_panicSpeed = 0x8E0; // float
    constexpr std::ptrdiff_t m_avoidRange = 0x8E4; // float
    constexpr std::ptrdiff_t m_turnTimer = 0x8E8; // CountdownTimer
    constexpr std::ptrdiff_t m_turnClockwise = 0x900; // bool
    constexpr std::ptrdiff_t m_goTimer = 0x908; // CountdownTimer
    constexpr std::ptrdiff_t m_moveTimer = 0x920; // CountdownTimer
    constexpr std::ptrdiff_t m_panicTimer = 0x938; // CountdownTimer
    constexpr std::ptrdiff_t m_disperseTimer = 0x950; // CountdownTimer
    constexpr std::ptrdiff_t m_proximityTimer = 0x968; // CountdownTimer
    constexpr std::ptrdiff_t m_visible = 0x980; // CUtlVector<CFish*>
}

namespace CFishPool {
    constexpr std::ptrdiff_t m_fishCount = 0x4C0; // int32_t
    constexpr std::ptrdiff_t m_maxRange = 0x4C4; // float
    constexpr std::ptrdiff_t m_swimDepth = 0x4C8; // float
    constexpr std::ptrdiff_t m_waterLevel = 0x4CC; // float
    constexpr std::ptrdiff_t m_isDormant = 0x4D0; // bool
    constexpr std::ptrdiff_t m_fishes = 0x4D8; // CUtlVector<CHandle<CFish>>
    constexpr std::ptrdiff_t m_visTimer = 0x4F0; // CountdownTimer
}

namespace CFists {
    constexpr std::ptrdiff_t m_bPlayingUninterruptableAct = 0xE20; // bool
    constexpr std::ptrdiff_t m_nUninterruptableActivity = 0xE24; // PlayerAnimEvent_t
    constexpr std::ptrdiff_t m_bRestorePrevWep = 0xE28; // bool
    constexpr std::ptrdiff_t m_hWeaponBeforePrevious = 0xE2C; // CHandle<CBasePlayerWeapon>
    constexpr std::ptrdiff_t m_hWeaponPrevious = 0xE30; // CHandle<CBasePlayerWeapon>
    constexpr std::ptrdiff_t m_bDelayedHardPunchIncoming = 0xE34; // bool
    constexpr std::ptrdiff_t m_bDestroyAfterTaunt = 0xE35; // bool
}

namespace CFlashbangProjectile {
    constexpr std::ptrdiff_t m_flTimeToDetonate = 0xA40; // float
    constexpr std::ptrdiff_t m_numOpponentsHit = 0xA44; // uint8_t
    constexpr std::ptrdiff_t m_numTeammatesHit = 0xA45; // uint8_t
}

namespace CFogController {
    constexpr std::ptrdiff_t m_fog = 0x4B0; // fogparams_t
    constexpr std::ptrdiff_t m_bUseAngles = 0x518; // bool
    constexpr std::ptrdiff_t m_iChangedVariables = 0x51C; // int32_t
}

namespace CFogTrigger {
    constexpr std::ptrdiff_t m_fog = 0x8A8; // fogparams_t
}

namespace CFogVolume {
    constexpr std::ptrdiff_t m_fogName = 0x700; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_postProcessName = 0x708; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_colorCorrectionName = 0x710; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bDisabled = 0x720; // bool
    constexpr std::ptrdiff_t m_bInFogVolumesList = 0x721; // bool
}

namespace CFootstepControl {
    constexpr std::ptrdiff_t m_source = 0x8A8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_destination = 0x8B0; // CUtlSymbolLarge
}

namespace CFuncBrush {
    constexpr std::ptrdiff_t m_iSolidity = 0x700; // BrushSolidities_e
    constexpr std::ptrdiff_t m_iDisabled = 0x704; // int32_t
    constexpr std::ptrdiff_t m_bSolidBsp = 0x708; // bool
    constexpr std::ptrdiff_t m_iszExcludedClass = 0x710; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bInvertExclusion = 0x718; // bool
    constexpr std::ptrdiff_t m_bScriptedMovement = 0x719; // bool
}

namespace CFuncConveyor {
    constexpr std::ptrdiff_t m_szConveyorModels = 0x700; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flTransitionDurationSeconds = 0x708; // float
    constexpr std::ptrdiff_t m_angMoveEntitySpace = 0x70C; // QAngle
    constexpr std::ptrdiff_t m_vecMoveDirEntitySpace = 0x718; // Vector
    constexpr std::ptrdiff_t m_flTargetSpeed = 0x724; // float
    constexpr std::ptrdiff_t m_nTransitionStartTick = 0x728; // GameTick_t
    constexpr std::ptrdiff_t m_nTransitionDurationTicks = 0x72C; // int32_t
    constexpr std::ptrdiff_t m_flTransitionStartSpeed = 0x730; // float
    constexpr std::ptrdiff_t m_hConveyorModels = 0x738; // CNetworkUtlVectorBase<CHandle<CBaseEntity>>
}

namespace CFuncElectrifiedVolume {
    constexpr std::ptrdiff_t m_EffectName = 0x720; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_EffectInterpenetrateName = 0x728; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_EffectZapName = 0x730; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszEffectSource = 0x738; // CUtlSymbolLarge
}

namespace CFuncInteractionLayerClip {
    constexpr std::ptrdiff_t m_bDisabled = 0x700; // bool
    constexpr std::ptrdiff_t m_iszInteractsAs = 0x708; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszInteractsWith = 0x710; // CUtlSymbolLarge
}

namespace CFuncLadder {
    constexpr std::ptrdiff_t m_vecLadderDir = 0x700; // Vector
    constexpr std::ptrdiff_t m_Dismounts = 0x710; // CUtlVector<CHandle<CInfoLadderDismount>>
    constexpr std::ptrdiff_t m_vecLocalTop = 0x728; // Vector
    constexpr std::ptrdiff_t m_vecPlayerMountPositionTop = 0x734; // Vector
    constexpr std::ptrdiff_t m_vecPlayerMountPositionBottom = 0x740; // Vector
    constexpr std::ptrdiff_t m_flAutoRideSpeed = 0x74C; // float
    constexpr std::ptrdiff_t m_bDisabled = 0x750; // bool
    constexpr std::ptrdiff_t m_bFakeLadder = 0x751; // bool
    constexpr std::ptrdiff_t m_bHasSlack = 0x752; // bool
    constexpr std::ptrdiff_t m_surfacePropName = 0x758; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_OnPlayerGotOnLadder = 0x760; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnPlayerGotOffLadder = 0x788; // CEntityIOOutput
}

namespace CFuncMonitor {
    constexpr std::ptrdiff_t m_targetCamera = 0x720; // CUtlString
    constexpr std::ptrdiff_t m_nResolutionEnum = 0x728; // int32_t
    constexpr std::ptrdiff_t m_bRenderShadows = 0x72C; // bool
    constexpr std::ptrdiff_t m_bUseUniqueColorTarget = 0x72D; // bool
    constexpr std::ptrdiff_t m_brushModelName = 0x730; // CUtlString
    constexpr std::ptrdiff_t m_hTargetCamera = 0x738; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bEnabled = 0x73C; // bool
    constexpr std::ptrdiff_t m_bDraw3DSkybox = 0x73D; // bool
    constexpr std::ptrdiff_t m_bStartEnabled = 0x73E; // bool
}

namespace CFuncMoveLinear {
    constexpr std::ptrdiff_t m_authoredPosition = 0x780; // MoveLinearAuthoredPos_t
    constexpr std::ptrdiff_t m_angMoveEntitySpace = 0x784; // QAngle
    constexpr std::ptrdiff_t m_vecMoveDirParentSpace = 0x790; // Vector
    constexpr std::ptrdiff_t m_soundStart = 0x7A0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_soundStop = 0x7A8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_currentSound = 0x7B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flBlockDamage = 0x7B8; // float
    constexpr std::ptrdiff_t m_flStartPosition = 0x7BC; // float
    constexpr std::ptrdiff_t m_flMoveDistance = 0x7C0; // float
    constexpr std::ptrdiff_t m_OnFullyOpen = 0x7D0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFullyClosed = 0x7F8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bCreateMovableNavMesh = 0x820; // bool
    constexpr std::ptrdiff_t m_bCreateNavObstacle = 0x821; // bool
}

namespace CFuncNavBlocker {
    constexpr std::ptrdiff_t m_bDisabled = 0x700; // bool
    constexpr std::ptrdiff_t m_nBlockedTeamNumber = 0x704; // int32_t
}

namespace CFuncNavObstruction {
    constexpr std::ptrdiff_t m_bDisabled = 0x708; // bool
}

namespace CFuncPlat {
    constexpr std::ptrdiff_t m_sNoise = 0x7A8; // CUtlSymbolLarge
}

namespace CFuncPlatRot {
    constexpr std::ptrdiff_t m_end = 0x7B0; // QAngle
    constexpr std::ptrdiff_t m_start = 0x7BC; // QAngle
}

namespace CFuncRotating {
    constexpr std::ptrdiff_t m_vecMoveAng = 0x700; // QAngle
    constexpr std::ptrdiff_t m_flFanFriction = 0x70C; // float
    constexpr std::ptrdiff_t m_flAttenuation = 0x710; // float
    constexpr std::ptrdiff_t m_flVolume = 0x714; // float
    constexpr std::ptrdiff_t m_flTargetSpeed = 0x718; // float
    constexpr std::ptrdiff_t m_flMaxSpeed = 0x71C; // float
    constexpr std::ptrdiff_t m_flBlockDamage = 0x720; // float
    constexpr std::ptrdiff_t m_flTimeScale = 0x724; // float
    constexpr std::ptrdiff_t m_NoiseRunning = 0x728; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bReversed = 0x730; // bool
    constexpr std::ptrdiff_t m_angStart = 0x73C; // QAngle
    constexpr std::ptrdiff_t m_bStopAtStartPos = 0x748; // bool
    constexpr std::ptrdiff_t m_vecClientOrigin = 0x74C; // Vector
    constexpr std::ptrdiff_t m_vecClientAngles = 0x758; // QAngle
}

namespace CFuncShatterglass {
    constexpr std::ptrdiff_t m_hGlassMaterialDamaged = 0x700; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_hGlassMaterialUndamaged = 0x708; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_hConcreteMaterialEdgeFace = 0x710; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_hConcreteMaterialEdgeCaps = 0x718; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_hConcreteMaterialEdgeFins = 0x720; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_matPanelTransform = 0x728; // matrix3x4_t
    constexpr std::ptrdiff_t m_matPanelTransformWsTemp = 0x758; // matrix3x4_t
    constexpr std::ptrdiff_t m_vecShatterGlassShards = 0x788; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_PanelSize = 0x7A0; // Vector2D
    constexpr std::ptrdiff_t m_vecPanelNormalWs = 0x7A8; // Vector
    constexpr std::ptrdiff_t m_nNumShardsEverCreated = 0x7B4; // int32_t
    constexpr std::ptrdiff_t m_flLastShatterSoundEmitTime = 0x7B8; // GameTime_t
    constexpr std::ptrdiff_t m_flLastCleanupTime = 0x7BC; // GameTime_t
    constexpr std::ptrdiff_t m_flInitAtTime = 0x7C0; // GameTime_t
    constexpr std::ptrdiff_t m_flGlassThickness = 0x7C4; // float
    constexpr std::ptrdiff_t m_flSpawnInvulnerability = 0x7C8; // float
    constexpr std::ptrdiff_t m_bBreakSilent = 0x7CC; // bool
    constexpr std::ptrdiff_t m_bBreakShardless = 0x7CD; // bool
    constexpr std::ptrdiff_t m_bBroken = 0x7CE; // bool
    constexpr std::ptrdiff_t m_bHasRateLimitedShards = 0x7CF; // bool
    constexpr std::ptrdiff_t m_bGlassNavIgnore = 0x7D0; // bool
    constexpr std::ptrdiff_t m_bGlassInFrame = 0x7D1; // bool
    constexpr std::ptrdiff_t m_bStartBroken = 0x7D2; // bool
    constexpr std::ptrdiff_t m_iInitialDamageType = 0x7D3; // uint8_t
    constexpr std::ptrdiff_t m_szDamagePositioningEntityName01 = 0x7D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_szDamagePositioningEntityName02 = 0x7E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_szDamagePositioningEntityName03 = 0x7E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_szDamagePositioningEntityName04 = 0x7F0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_vInitialDamagePositions = 0x7F8; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_vExtraDamagePositions = 0x810; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_OnBroken = 0x828; // CEntityIOOutput
    constexpr std::ptrdiff_t m_iSurfaceType = 0x851; // uint8_t
}

namespace CFuncTankTrain {
    constexpr std::ptrdiff_t m_OnDeath = 0x850; // CEntityIOOutput
}

namespace CFuncTimescale {
    constexpr std::ptrdiff_t m_flDesiredTimescale = 0x4B0; // float
    constexpr std::ptrdiff_t m_flAcceleration = 0x4B4; // float
    constexpr std::ptrdiff_t m_flMinBlendRate = 0x4B8; // float
    constexpr std::ptrdiff_t m_flBlendDeltaMultiplier = 0x4BC; // float
    constexpr std::ptrdiff_t m_isStarted = 0x4C0; // bool
}

namespace CFuncTrackChange {
    constexpr std::ptrdiff_t m_trackTop = 0x7C8; // CPathTrack*
    constexpr std::ptrdiff_t m_trackBottom = 0x7D0; // CPathTrack*
    constexpr std::ptrdiff_t m_train = 0x7D8; // CFuncTrackTrain*
    constexpr std::ptrdiff_t m_trackTopName = 0x7E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_trackBottomName = 0x7E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_trainName = 0x7F0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_code = 0x7F8; // TRAIN_CODE
    constexpr std::ptrdiff_t m_targetState = 0x7FC; // int32_t
    constexpr std::ptrdiff_t m_use = 0x800; // int32_t
}

namespace CFuncTrackTrain {
    constexpr std::ptrdiff_t m_ppath = 0x700; // CHandle<CPathTrack>
    constexpr std::ptrdiff_t m_length = 0x704; // float
    constexpr std::ptrdiff_t m_vPosPrev = 0x708; // Vector
    constexpr std::ptrdiff_t m_angPrev = 0x714; // QAngle
    constexpr std::ptrdiff_t m_controlMins = 0x720; // Vector
    constexpr std::ptrdiff_t m_controlMaxs = 0x72C; // Vector
    constexpr std::ptrdiff_t m_lastBlockPos = 0x738; // Vector
    constexpr std::ptrdiff_t m_lastBlockTick = 0x744; // int32_t
    constexpr std::ptrdiff_t m_flVolume = 0x748; // float
    constexpr std::ptrdiff_t m_flBank = 0x74C; // float
    constexpr std::ptrdiff_t m_oldSpeed = 0x750; // float
    constexpr std::ptrdiff_t m_flBlockDamage = 0x754; // float
    constexpr std::ptrdiff_t m_height = 0x758; // float
    constexpr std::ptrdiff_t m_maxSpeed = 0x75C; // float
    constexpr std::ptrdiff_t m_dir = 0x760; // float
    constexpr std::ptrdiff_t m_iszSoundMove = 0x768; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSoundMovePing = 0x770; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSoundStart = 0x778; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSoundStop = 0x780; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_strPathTarget = 0x788; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flMoveSoundMinDuration = 0x790; // float
    constexpr std::ptrdiff_t m_flMoveSoundMaxDuration = 0x794; // float
    constexpr std::ptrdiff_t m_flNextMoveSoundTime = 0x798; // GameTime_t
    constexpr std::ptrdiff_t m_flMoveSoundMinPitch = 0x79C; // float
    constexpr std::ptrdiff_t m_flMoveSoundMaxPitch = 0x7A0; // float
    constexpr std::ptrdiff_t m_eOrientationType = 0x7A4; // TrainOrientationType_t
    constexpr std::ptrdiff_t m_eVelocityType = 0x7A8; // TrainVelocityType_t
    constexpr std::ptrdiff_t m_OnStart = 0x7B8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnNext = 0x7E0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnArrivedAtDestinationNode = 0x808; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bManualSpeedChanges = 0x830; // bool
    constexpr std::ptrdiff_t m_flDesiredSpeed = 0x834; // float
    constexpr std::ptrdiff_t m_flSpeedChangeTime = 0x838; // GameTime_t
    constexpr std::ptrdiff_t m_flAccelSpeed = 0x83C; // float
    constexpr std::ptrdiff_t m_flDecelSpeed = 0x840; // float
    constexpr std::ptrdiff_t m_bAccelToSpeed = 0x844; // bool
    constexpr std::ptrdiff_t m_flTimeScale = 0x848; // float
    constexpr std::ptrdiff_t m_flNextMPSoundTime = 0x84C; // GameTime_t
}

namespace CFuncTrain {
    constexpr std::ptrdiff_t m_hCurrentTarget = 0x7A8; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_activated = 0x7AC; // bool
    constexpr std::ptrdiff_t m_hEnemy = 0x7B0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_flBlockDamage = 0x7B4; // float
    constexpr std::ptrdiff_t m_flNextBlockTime = 0x7B8; // GameTime_t
    constexpr std::ptrdiff_t m_iszLastTarget = 0x7C0; // CUtlSymbolLarge
}

namespace CFuncVPhysicsClip {
    constexpr std::ptrdiff_t m_bDisabled = 0x700; // bool
}

namespace CFuncWall {
    constexpr std::ptrdiff_t m_nState = 0x700; // int32_t
}

namespace CFuncWater {
    constexpr std::ptrdiff_t m_BuoyancyHelper = 0x700; // CBuoyancyHelper
}

namespace CGameChoreoServices {
    constexpr std::ptrdiff_t m_hOwner = 0x8; // CHandle<CBaseAnimGraph>
    constexpr std::ptrdiff_t m_hScriptedSequence = 0xC; // CHandle<CScriptedSequence>
    constexpr std::ptrdiff_t m_scriptState = 0x10; // IChoreoServices::ScriptState_t
    constexpr std::ptrdiff_t m_choreoState = 0x14; // IChoreoServices::ChoreoState_t
    constexpr std::ptrdiff_t m_flTimeStartedState = 0x18; // GameTime_t
}

namespace CGameGibManager {
    constexpr std::ptrdiff_t m_bAllowNewGibs = 0x4D0; // bool
    constexpr std::ptrdiff_t m_iCurrentMaxPieces = 0x4D4; // int32_t
    constexpr std::ptrdiff_t m_iMaxPieces = 0x4D8; // int32_t
    constexpr std::ptrdiff_t m_iLastFrame = 0x4DC; // int32_t
}

namespace CGameMoney {
    constexpr std::ptrdiff_t m_OnMoneySpent = 0x710; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnMoneySpentFail = 0x738; // CEntityIOOutput
    constexpr std::ptrdiff_t m_nMoney = 0x760; // int32_t
    constexpr std::ptrdiff_t m_strAwardText = 0x768; // CUtlString
}

namespace CGamePlayerZone {
    constexpr std::ptrdiff_t m_OnPlayerInZone = 0x708; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnPlayerOutZone = 0x730; // CEntityIOOutput
    constexpr std::ptrdiff_t m_PlayersInCount = 0x758; // CEntityOutputTemplate<int32_t>
    constexpr std::ptrdiff_t m_PlayersOutCount = 0x780; // CEntityOutputTemplate<int32_t>
}

namespace CGameRules {
    constexpr std::ptrdiff_t m_szQuestName = 0x8; // char[128]
    constexpr std::ptrdiff_t m_nQuestPhase = 0x88; // int32_t
}

namespace CGameSceneNode {
    constexpr std::ptrdiff_t m_nodeToWorld = 0x10; // CTransform
    constexpr std::ptrdiff_t m_pOwner = 0x30; // CEntityInstance*
    constexpr std::ptrdiff_t m_pParent = 0x38; // CGameSceneNode*
    constexpr std::ptrdiff_t m_pChild = 0x40; // CGameSceneNode*
    constexpr std::ptrdiff_t m_pNextSibling = 0x48; // CGameSceneNode*
    constexpr std::ptrdiff_t m_hParent = 0x70; // CGameSceneNodeHandle
    constexpr std::ptrdiff_t m_vecOrigin = 0x80; // CNetworkOriginCellCoordQuantizedVector
    constexpr std::ptrdiff_t m_angRotation = 0xB8; // QAngle
    constexpr std::ptrdiff_t m_flScale = 0xC4; // float
    constexpr std::ptrdiff_t m_vecAbsOrigin = 0xC8; // Vector
    constexpr std::ptrdiff_t m_angAbsRotation = 0xD4; // QAngle
    constexpr std::ptrdiff_t m_flAbsScale = 0xE0; // float
    constexpr std::ptrdiff_t m_nParentAttachmentOrBone = 0xE4; // int16_t
    constexpr std::ptrdiff_t m_bDebugAbsOriginChanges = 0xE6; // bool
    constexpr std::ptrdiff_t m_bDormant = 0xE7; // bool
    constexpr std::ptrdiff_t m_bForceParentToBeNetworked = 0xE8; // bool
    constexpr std::ptrdiff_t m_bDirtyHierarchy = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bDirtyBoneMergeInfo = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bNetworkedPositionChanged = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bNetworkedAnglesChanged = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bNetworkedScaleChanged = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bWillBeCallingPostDataUpdate = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bNotifyBoneTransformsChanged = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bBoneMergeFlex = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_nLatchAbsOrigin = 0x0; // bitfield:2
    constexpr std::ptrdiff_t m_bDirtyBoneMergeBoneToRoot = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_nHierarchicalDepth = 0xEB; // uint8_t
    constexpr std::ptrdiff_t m_nHierarchyType = 0xEC; // uint8_t
    constexpr std::ptrdiff_t m_nDoNotSetAnimTimeInInvalidatePhysicsCount = 0xED; // uint8_t
    constexpr std::ptrdiff_t m_name = 0xF0; // CUtlStringToken
    constexpr std::ptrdiff_t m_hierarchyAttachName = 0x130; // CUtlStringToken
    constexpr std::ptrdiff_t m_flZOffset = 0x134; // float
    constexpr std::ptrdiff_t m_vRenderOrigin = 0x138; // Vector
}

namespace CGameSceneNodeHandle {
    constexpr std::ptrdiff_t m_hOwner = 0x8; // CEntityHandle
    constexpr std::ptrdiff_t m_name = 0xC; // CUtlStringToken
}

namespace CGameScriptedMoveData {
    constexpr std::ptrdiff_t m_vDest = 0x0; // Vector
    constexpr std::ptrdiff_t m_vSrc = 0xC; // Vector
    constexpr std::ptrdiff_t m_angSrc = 0x18; // QAngle
    constexpr std::ptrdiff_t m_angDst = 0x24; // QAngle
    constexpr std::ptrdiff_t m_angCurrent = 0x30; // QAngle
    constexpr std::ptrdiff_t m_flAngRate = 0x3C; // float
    constexpr std::ptrdiff_t m_flDuration = 0x40; // float
    constexpr std::ptrdiff_t m_flStartTime = 0x44; // GameTime_t
    constexpr std::ptrdiff_t m_nPrevMoveType = 0x48; // MoveType_t
    constexpr std::ptrdiff_t m_bActive = 0x49; // bool
    constexpr std::ptrdiff_t m_bTeleportOnEnd = 0x4A; // bool
    constexpr std::ptrdiff_t m_bEndOnDestinationReached = 0x4B; // bool
    constexpr std::ptrdiff_t m_bIgnoreRotation = 0x4C; // bool
    constexpr std::ptrdiff_t m_nType = 0x50; // ScriptedMoveType_t
    constexpr std::ptrdiff_t m_bSuccess = 0x54; // bool
    constexpr std::ptrdiff_t m_nForcedCrouchState = 0x58; // ForcedCrouchState_t
    constexpr std::ptrdiff_t m_bIgnoreCollisions = 0x5C; // bool
}

namespace CGameText {
    constexpr std::ptrdiff_t m_iszMessage = 0x710; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_textParms = 0x718; // hudtextparms_t
}

namespace CGenericConstraint {
    constexpr std::ptrdiff_t m_nLinearMotionX = 0x510; // JointMotion_t
    constexpr std::ptrdiff_t m_nLinearMotionY = 0x514; // JointMotion_t
    constexpr std::ptrdiff_t m_nLinearMotionZ = 0x518; // JointMotion_t
    constexpr std::ptrdiff_t m_flLinearFrequencyX = 0x51C; // float
    constexpr std::ptrdiff_t m_flLinearFrequencyY = 0x520; // float
    constexpr std::ptrdiff_t m_flLinearFrequencyZ = 0x524; // float
    constexpr std::ptrdiff_t m_flLinearDampingRatioX = 0x528; // float
    constexpr std::ptrdiff_t m_flLinearDampingRatioY = 0x52C; // float
    constexpr std::ptrdiff_t m_flLinearDampingRatioZ = 0x530; // float
    constexpr std::ptrdiff_t m_flMaxLinearImpulseX = 0x534; // float
    constexpr std::ptrdiff_t m_flMaxLinearImpulseY = 0x538; // float
    constexpr std::ptrdiff_t m_flMaxLinearImpulseZ = 0x53C; // float
    constexpr std::ptrdiff_t m_flBreakAfterTimeX = 0x540; // float
    constexpr std::ptrdiff_t m_flBreakAfterTimeY = 0x544; // float
    constexpr std::ptrdiff_t m_flBreakAfterTimeZ = 0x548; // float
    constexpr std::ptrdiff_t m_flBreakAfterTimeStartTimeX = 0x54C; // GameTime_t
    constexpr std::ptrdiff_t m_flBreakAfterTimeStartTimeY = 0x550; // GameTime_t
    constexpr std::ptrdiff_t m_flBreakAfterTimeStartTimeZ = 0x554; // GameTime_t
    constexpr std::ptrdiff_t m_flBreakAfterTimeThresholdX = 0x558; // float
    constexpr std::ptrdiff_t m_flBreakAfterTimeThresholdY = 0x55C; // float
    constexpr std::ptrdiff_t m_flBreakAfterTimeThresholdZ = 0x560; // float
    constexpr std::ptrdiff_t m_flNotifyForceX = 0x564; // float
    constexpr std::ptrdiff_t m_flNotifyForceY = 0x568; // float
    constexpr std::ptrdiff_t m_flNotifyForceZ = 0x56C; // float
    constexpr std::ptrdiff_t m_flNotifyForceMinTimeX = 0x570; // float
    constexpr std::ptrdiff_t m_flNotifyForceMinTimeY = 0x574; // float
    constexpr std::ptrdiff_t m_flNotifyForceMinTimeZ = 0x578; // float
    constexpr std::ptrdiff_t m_flNotifyForceLastTimeX = 0x57C; // GameTime_t
    constexpr std::ptrdiff_t m_flNotifyForceLastTimeY = 0x580; // GameTime_t
    constexpr std::ptrdiff_t m_flNotifyForceLastTimeZ = 0x584; // GameTime_t
    constexpr std::ptrdiff_t m_bAxisNotifiedX = 0x588; // bool
    constexpr std::ptrdiff_t m_bAxisNotifiedY = 0x589; // bool
    constexpr std::ptrdiff_t m_bAxisNotifiedZ = 0x58A; // bool
    constexpr std::ptrdiff_t m_nAngularMotionX = 0x58C; // JointMotion_t
    constexpr std::ptrdiff_t m_nAngularMotionY = 0x590; // JointMotion_t
    constexpr std::ptrdiff_t m_nAngularMotionZ = 0x594; // JointMotion_t
    constexpr std::ptrdiff_t m_flAngularFrequencyX = 0x598; // float
    constexpr std::ptrdiff_t m_flAngularFrequencyY = 0x59C; // float
    constexpr std::ptrdiff_t m_flAngularFrequencyZ = 0x5A0; // float
    constexpr std::ptrdiff_t m_flAngularDampingRatioX = 0x5A4; // float
    constexpr std::ptrdiff_t m_flAngularDampingRatioY = 0x5A8; // float
    constexpr std::ptrdiff_t m_flAngularDampingRatioZ = 0x5AC; // float
    constexpr std::ptrdiff_t m_flMaxAngularImpulseX = 0x5B0; // float
    constexpr std::ptrdiff_t m_flMaxAngularImpulseY = 0x5B4; // float
    constexpr std::ptrdiff_t m_flMaxAngularImpulseZ = 0x5B8; // float
    constexpr std::ptrdiff_t m_NotifyForceReachedX = 0x5C0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_NotifyForceReachedY = 0x5E8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_NotifyForceReachedZ = 0x610; // CEntityIOOutput
}

namespace CGlowProperty {
    constexpr std::ptrdiff_t m_fGlowColor = 0x8; // Vector
    constexpr std::ptrdiff_t m_iGlowType = 0x30; // int32_t
    constexpr std::ptrdiff_t m_iGlowTeam = 0x34; // int32_t
    constexpr std::ptrdiff_t m_nGlowRange = 0x38; // int32_t
    constexpr std::ptrdiff_t m_nGlowRangeMin = 0x3C; // int32_t
    constexpr std::ptrdiff_t m_glowColorOverride = 0x40; // Color
    constexpr std::ptrdiff_t m_bFlashing = 0x44; // bool
    constexpr std::ptrdiff_t m_flGlowTime = 0x48; // float
    constexpr std::ptrdiff_t m_flGlowStartTime = 0x4C; // float
    constexpr std::ptrdiff_t m_bEligibleForScreenHighlight = 0x50; // bool
    constexpr std::ptrdiff_t m_bGlowing = 0x51; // bool
}

namespace CGradientFog {
    constexpr std::ptrdiff_t m_hGradientFogTexture = 0x4B0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_flFogStartDistance = 0x4B8; // float
    constexpr std::ptrdiff_t m_flFogEndDistance = 0x4BC; // float
    constexpr std::ptrdiff_t m_bHeightFogEnabled = 0x4C0; // bool
    constexpr std::ptrdiff_t m_flFogStartHeight = 0x4C4; // float
    constexpr std::ptrdiff_t m_flFogEndHeight = 0x4C8; // float
    constexpr std::ptrdiff_t m_flFarZ = 0x4CC; // float
    constexpr std::ptrdiff_t m_flFogMaxOpacity = 0x4D0; // float
    constexpr std::ptrdiff_t m_flFogFalloffExponent = 0x4D4; // float
    constexpr std::ptrdiff_t m_flFogVerticalExponent = 0x4D8; // float
    constexpr std::ptrdiff_t m_fogColor = 0x4DC; // Color
    constexpr std::ptrdiff_t m_flFogStrength = 0x4E0; // float
    constexpr std::ptrdiff_t m_flFadeTime = 0x4E4; // float
    constexpr std::ptrdiff_t m_bStartDisabled = 0x4E8; // bool
    constexpr std::ptrdiff_t m_bIsEnabled = 0x4E9; // bool
    constexpr std::ptrdiff_t m_bGradientFogNeedsTextures = 0x4EA; // bool
}

namespace CGunTarget {
    constexpr std::ptrdiff_t m_on = 0x780; // bool
    constexpr std::ptrdiff_t m_hTargetEnt = 0x784; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_OnDeath = 0x788; // CEntityIOOutput
}

namespace CHandleTest {
    constexpr std::ptrdiff_t m_Handle = 0x4B0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bSendHandle = 0x4B4; // bool
}

namespace CHintMessage {
    constexpr std::ptrdiff_t m_hintString = 0x8; // char*
    constexpr std::ptrdiff_t m_args = 0x10; // CUtlVector<char*>
    constexpr std::ptrdiff_t m_duration = 0x28; // float
}

namespace CHintMessageQueue {
    constexpr std::ptrdiff_t m_tmMessageEnd = 0x8; // float
    constexpr std::ptrdiff_t m_messages = 0x10; // CUtlVector<CHintMessage*>
    constexpr std::ptrdiff_t m_pPlayerController = 0x28; // CBasePlayerController*
}

namespace CHitboxComponent {
    constexpr std::ptrdiff_t m_bvDisabledHitGroups = 0x24; // uint32_t[1]
}

namespace CHostage {
    constexpr std::ptrdiff_t m_OnHostageBeginGrab = 0x9E8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFirstPickedUp = 0xA10; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnDroppedNotRescued = 0xA38; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnRescued = 0xA60; // CEntityIOOutput
    constexpr std::ptrdiff_t m_entitySpottedState = 0xA88; // EntitySpottedState_t
    constexpr std::ptrdiff_t m_nSpotRules = 0xAA0; // int32_t
    constexpr std::ptrdiff_t m_uiHostageSpawnExclusionGroupMask = 0xAA4; // uint32_t
    constexpr std::ptrdiff_t m_nHostageSpawnRandomFactor = 0xAA8; // uint32_t
    constexpr std::ptrdiff_t m_bRemove = 0xAAC; // bool
    constexpr std::ptrdiff_t m_vel = 0xAB0; // Vector
    constexpr std::ptrdiff_t m_isRescued = 0xABC; // bool
    constexpr std::ptrdiff_t m_jumpedThisFrame = 0xABD; // bool
    constexpr std::ptrdiff_t m_nHostageState = 0xAC0; // int32_t
    constexpr std::ptrdiff_t m_leader = 0xAC4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_lastLeader = 0xAC8; // CHandle<CCSPlayerPawnBase>
    constexpr std::ptrdiff_t m_reuseTimer = 0xAD0; // CountdownTimer
    constexpr std::ptrdiff_t m_hasBeenUsed = 0xAE8; // bool
    constexpr std::ptrdiff_t m_accel = 0xAEC; // Vector
    constexpr std::ptrdiff_t m_isRunning = 0xAF8; // bool
    constexpr std::ptrdiff_t m_isCrouching = 0xAF9; // bool
    constexpr std::ptrdiff_t m_jumpTimer = 0xB00; // CountdownTimer
    constexpr std::ptrdiff_t m_isWaitingForLeader = 0xB18; // bool
    constexpr std::ptrdiff_t m_repathTimer = 0x2B28; // CountdownTimer
    constexpr std::ptrdiff_t m_inhibitDoorTimer = 0x2B40; // CountdownTimer
    constexpr std::ptrdiff_t m_inhibitObstacleAvoidanceTimer = 0x2BD0; // CountdownTimer
    constexpr std::ptrdiff_t m_wiggleTimer = 0x2BF0; // CountdownTimer
    constexpr std::ptrdiff_t m_isAdjusted = 0x2C0C; // bool
    constexpr std::ptrdiff_t m_bHandsHaveBeenCut = 0x2C0D; // bool
    constexpr std::ptrdiff_t m_hHostageGrabber = 0x2C10; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_fLastGrabTime = 0x2C14; // GameTime_t
    constexpr std::ptrdiff_t m_vecPositionWhenStartedDroppingToGround = 0x2C18; // Vector
    constexpr std::ptrdiff_t m_vecGrabbedPos = 0x2C24; // Vector
    constexpr std::ptrdiff_t m_flRescueStartTime = 0x2C30; // GameTime_t
    constexpr std::ptrdiff_t m_flGrabSuccessTime = 0x2C34; // GameTime_t
    constexpr std::ptrdiff_t m_flDropStartTime = 0x2C38; // GameTime_t
    constexpr std::ptrdiff_t m_nApproachRewardPayouts = 0x2C3C; // int32_t
    constexpr std::ptrdiff_t m_nPickupEventCount = 0x2C40; // int32_t
    constexpr std::ptrdiff_t m_vecSpawnGroundPos = 0x2C44; // Vector
    constexpr std::ptrdiff_t m_vecHostageResetPosition = 0x2C64; // Vector
}

namespace CHostageExpresserShim {
    constexpr std::ptrdiff_t m_pExpresser = 0x9D0; // CAI_Expresser*
}

namespace CInButtonState {
    constexpr std::ptrdiff_t m_pButtonStates = 0x8; // uint64_t[3]
}

namespace CInferno {
    constexpr std::ptrdiff_t m_firePositions = 0x710; // Vector[64]
    constexpr std::ptrdiff_t m_fireParentPositions = 0xA10; // Vector[64]
    constexpr std::ptrdiff_t m_bFireIsBurning = 0xD10; // bool[64]
    constexpr std::ptrdiff_t m_BurnNormal = 0xD50; // Vector[64]
    constexpr std::ptrdiff_t m_fireCount = 0x1050; // int32_t
    constexpr std::ptrdiff_t m_nInfernoType = 0x1054; // int32_t
    constexpr std::ptrdiff_t m_nFireEffectTickBegin = 0x1058; // int32_t
    constexpr std::ptrdiff_t m_nFireLifetime = 0x105C; // float
    constexpr std::ptrdiff_t m_bInPostEffectTime = 0x1060; // bool
    constexpr std::ptrdiff_t m_nFiresExtinguishCount = 0x1064; // int32_t
    constexpr std::ptrdiff_t m_bWasCreatedInSmoke = 0x1068; // bool
    constexpr std::ptrdiff_t m_extent = 0x1270; // Extent
    constexpr std::ptrdiff_t m_damageTimer = 0x1288; // CountdownTimer
    constexpr std::ptrdiff_t m_damageRampTimer = 0x12A0; // CountdownTimer
    constexpr std::ptrdiff_t m_splashVelocity = 0x12B8; // Vector
    constexpr std::ptrdiff_t m_InitialSplashVelocity = 0x12C4; // Vector
    constexpr std::ptrdiff_t m_startPos = 0x12D0; // Vector
    constexpr std::ptrdiff_t m_vecOriginalSpawnLocation = 0x12DC; // Vector
    constexpr std::ptrdiff_t m_activeTimer = 0x12E8; // IntervalTimer
    constexpr std::ptrdiff_t m_fireSpawnOffset = 0x12F8; // int32_t
    constexpr std::ptrdiff_t m_nMaxFlames = 0x12FC; // int32_t
    constexpr std::ptrdiff_t m_BookkeepingTimer = 0x1300; // CountdownTimer
    constexpr std::ptrdiff_t m_NextSpreadTimer = 0x1318; // CountdownTimer
    constexpr std::ptrdiff_t m_nSourceItemDefIndex = 0x1330; // uint16_t
}

namespace CInfoDynamicShadowHint {
    constexpr std::ptrdiff_t m_bDisabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_flRange = 0x4B4; // float
    constexpr std::ptrdiff_t m_nImportance = 0x4B8; // int32_t
    constexpr std::ptrdiff_t m_nLightChoice = 0x4BC; // int32_t
    constexpr std::ptrdiff_t m_hLight = 0x4C0; // CHandle<CBaseEntity>
}

namespace CInfoDynamicShadowHintBox {
    constexpr std::ptrdiff_t m_vBoxMins = 0x4C8; // Vector
    constexpr std::ptrdiff_t m_vBoxMaxs = 0x4D4; // Vector
}

namespace CInfoGameEventProxy {
    constexpr std::ptrdiff_t m_iszEventName = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flRange = 0x4B8; // float
}

namespace CInfoOffscreenPanoramaTexture {
    constexpr std::ptrdiff_t m_bDisabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_nResolutionX = 0x4B4; // int32_t
    constexpr std::ptrdiff_t m_nResolutionY = 0x4B8; // int32_t
    constexpr std::ptrdiff_t m_szLayoutFileName = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_RenderAttrName = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_TargetEntities = 0x4D0; // CNetworkUtlVectorBase<CHandle<CBaseModelEntity>>
    constexpr std::ptrdiff_t m_nTargetChangeCount = 0x4E8; // int32_t
    constexpr std::ptrdiff_t m_vecCSSClasses = 0x4F0; // CNetworkUtlVectorBase<CUtlSymbolLarge>
    constexpr std::ptrdiff_t m_szTargetsName = 0x508; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_AdditionalTargetEntities = 0x510; // CUtlVector<CHandle<CBaseModelEntity>>
}

namespace CInfoPlayerStart {
    constexpr std::ptrdiff_t m_bDisabled = 0x4B0; // bool
}

namespace CInfoSpawnGroupLoadUnload {
    constexpr std::ptrdiff_t m_OnSpawnGroupLoadStarted = 0x4B0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnSpawnGroupLoadFinished = 0x4D8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnSpawnGroupUnloadStarted = 0x500; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnSpawnGroupUnloadFinished = 0x528; // CEntityIOOutput
    constexpr std::ptrdiff_t m_iszSpawnGroupName = 0x550; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSpawnGroupFilterName = 0x558; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszLandmarkName = 0x560; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_sFixedSpawnGroupName = 0x568; // CUtlString
    constexpr std::ptrdiff_t m_flTimeoutInterval = 0x570; // float
    constexpr std::ptrdiff_t m_bStreamingStarted = 0x574; // bool
    constexpr std::ptrdiff_t m_bUnloadingStarted = 0x575; // bool
}

namespace CInfoVisibilityBox {
    constexpr std::ptrdiff_t m_nMode = 0x4B4; // int32_t
    constexpr std::ptrdiff_t m_vBoxSize = 0x4B8; // Vector
    constexpr std::ptrdiff_t m_bEnabled = 0x4C4; // bool
}

namespace CInfoWorldLayer {
    constexpr std::ptrdiff_t m_pOutputOnEntitiesSpawned = 0x4B0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_worldName = 0x4D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_layerName = 0x4E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bWorldLayerVisible = 0x4E8; // bool
    constexpr std::ptrdiff_t m_bEntitiesSpawned = 0x4E9; // bool
    constexpr std::ptrdiff_t m_bCreateAsChildSpawnGroup = 0x4EA; // bool
    constexpr std::ptrdiff_t m_hLayerSpawnGroup = 0x4EC; // uint32_t
}

namespace CInstancedSceneEntity {
    constexpr std::ptrdiff_t m_hOwner = 0xA08; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bHadOwner = 0xA0C; // bool
    constexpr std::ptrdiff_t m_flPostSpeakDelay = 0xA10; // float
    constexpr std::ptrdiff_t m_flPreDelay = 0xA14; // float
    constexpr std::ptrdiff_t m_bIsBackground = 0xA18; // bool
}

namespace CInstructorEventEntity {
    constexpr std::ptrdiff_t m_iszName = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszHintTargetEntity = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hTargetPlayer = 0x4C0; // CHandle<CBasePlayerPawn>
}

namespace CIronSightController {
    constexpr std::ptrdiff_t m_bIronSightAvailable = 0x8; // bool
    constexpr std::ptrdiff_t m_flIronSightAmount = 0xC; // float
    constexpr std::ptrdiff_t m_flIronSightAmountGained = 0x10; // float
    constexpr std::ptrdiff_t m_flIronSightAmountBiased = 0x14; // float
}

namespace CItem {
    constexpr std::ptrdiff_t m_OnPlayerTouch = 0x898; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bActivateWhenAtRest = 0x8C0; // bool
    constexpr std::ptrdiff_t m_OnCacheInteraction = 0x8C8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnPlayerPickup = 0x8F0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnGlovePulled = 0x918; // CEntityIOOutput
    constexpr std::ptrdiff_t m_vOriginalSpawnOrigin = 0x940; // Vector
    constexpr std::ptrdiff_t m_vOriginalSpawnAngles = 0x94C; // QAngle
    constexpr std::ptrdiff_t m_bPhysStartAsleep = 0x958; // bool
}

namespace CItemDefuser {
    constexpr std::ptrdiff_t m_entitySpottedState = 0x968; // EntitySpottedState_t
    constexpr std::ptrdiff_t m_nSpotRules = 0x980; // int32_t
}

namespace CItemDogtags {
    constexpr std::ptrdiff_t m_OwningPlayer = 0x968; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_KillingPlayer = 0x96C; // CHandle<CCSPlayerPawn>
}

namespace CItemGeneric {
    constexpr std::ptrdiff_t m_bHasTriggerRadius = 0x970; // bool
    constexpr std::ptrdiff_t m_bHasPickupRadius = 0x971; // bool
    constexpr std::ptrdiff_t m_flPickupRadiusSqr = 0x974; // float
    constexpr std::ptrdiff_t m_flTriggerRadiusSqr = 0x978; // float
    constexpr std::ptrdiff_t m_flLastPickupCheck = 0x97C; // GameTime_t
    constexpr std::ptrdiff_t m_bPlayerCounterListenerAdded = 0x980; // bool
    constexpr std::ptrdiff_t m_bPlayerInTriggerRadius = 0x981; // bool
    constexpr std::ptrdiff_t m_hSpawnParticleEffect = 0x988; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_pAmbientSoundEffect = 0x990; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bAutoStartAmbientSound = 0x998; // bool
    constexpr std::ptrdiff_t m_pSpawnScriptFunction = 0x9A0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hPickupParticleEffect = 0x9A8; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_pPickupSoundEffect = 0x9B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_pPickupScriptFunction = 0x9B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hTimeoutParticleEffect = 0x9C0; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_pTimeoutSoundEffect = 0x9C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_pTimeoutScriptFunction = 0x9D0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_pPickupFilterName = 0x9D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hPickupFilter = 0x9E0; // CHandle<CBaseFilter>
    constexpr std::ptrdiff_t m_OnPickup = 0x9E8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnTimeout = 0xA10; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnTriggerStartTouch = 0xA38; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnTriggerTouch = 0xA60; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnTriggerEndTouch = 0xA88; // CEntityIOOutput
    constexpr std::ptrdiff_t m_pAllowPickupScriptFunction = 0xAB0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flPickupRadius = 0xAB8; // float
    constexpr std::ptrdiff_t m_flTriggerRadius = 0xABC; // float
    constexpr std::ptrdiff_t m_pTriggerSoundEffect = 0xAC0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bGlowWhenInTrigger = 0xAC8; // bool
    constexpr std::ptrdiff_t m_glowColor = 0xAC9; // Color
    constexpr std::ptrdiff_t m_bUseable = 0xACD; // bool
    constexpr std::ptrdiff_t m_hTriggerHelper = 0xAD0; // CHandle<CItemGenericTriggerHelper>
}

namespace CItemGenericTriggerHelper {
    constexpr std::ptrdiff_t m_hParentItem = 0x700; // CHandle<CItemGeneric>
}

namespace CKeepUpright {
    constexpr std::ptrdiff_t m_worldGoalAxis = 0x4B8; // Vector
    constexpr std::ptrdiff_t m_localTestAxis = 0x4C4; // Vector
    constexpr std::ptrdiff_t m_nameAttach = 0x4D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_attachedObject = 0x4E0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_angularLimit = 0x4E4; // float
    constexpr std::ptrdiff_t m_bActive = 0x4E8; // bool
    constexpr std::ptrdiff_t m_bDampAllRotation = 0x4E9; // bool
}

namespace CKnife {
    constexpr std::ptrdiff_t m_bFirstAttack = 0xE20; // bool
}

namespace CLightComponent {
    constexpr std::ptrdiff_t __m_pChainEntity = 0x48; // CNetworkVarChainer
    constexpr std::ptrdiff_t m_Color = 0x85; // Color
    constexpr std::ptrdiff_t m_SecondaryColor = 0x89; // Color
    constexpr std::ptrdiff_t m_flBrightness = 0x90; // float
    constexpr std::ptrdiff_t m_flBrightnessScale = 0x94; // float
    constexpr std::ptrdiff_t m_flBrightnessMult = 0x98; // float
    constexpr std::ptrdiff_t m_flRange = 0x9C; // float
    constexpr std::ptrdiff_t m_flFalloff = 0xA0; // float
    constexpr std::ptrdiff_t m_flAttenuation0 = 0xA4; // float
    constexpr std::ptrdiff_t m_flAttenuation1 = 0xA8; // float
    constexpr std::ptrdiff_t m_flAttenuation2 = 0xAC; // float
    constexpr std::ptrdiff_t m_flTheta = 0xB0; // float
    constexpr std::ptrdiff_t m_flPhi = 0xB4; // float
    constexpr std::ptrdiff_t m_hLightCookie = 0xB8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_nCascades = 0xC0; // int32_t
    constexpr std::ptrdiff_t m_nCastShadows = 0xC4; // int32_t
    constexpr std::ptrdiff_t m_nShadowWidth = 0xC8; // int32_t
    constexpr std::ptrdiff_t m_nShadowHeight = 0xCC; // int32_t
    constexpr std::ptrdiff_t m_bRenderDiffuse = 0xD0; // bool
    constexpr std::ptrdiff_t m_nRenderSpecular = 0xD4; // int32_t
    constexpr std::ptrdiff_t m_bRenderTransmissive = 0xD8; // bool
    constexpr std::ptrdiff_t m_flOrthoLightWidth = 0xDC; // float
    constexpr std::ptrdiff_t m_flOrthoLightHeight = 0xE0; // float
    constexpr std::ptrdiff_t m_nStyle = 0xE4; // int32_t
    constexpr std::ptrdiff_t m_Pattern = 0xE8; // CUtlString
    constexpr std::ptrdiff_t m_nCascadeRenderStaticObjects = 0xF0; // int32_t
    constexpr std::ptrdiff_t m_flShadowCascadeCrossFade = 0xF4; // float
    constexpr std::ptrdiff_t m_flShadowCascadeDistanceFade = 0xF8; // float
    constexpr std::ptrdiff_t m_flShadowCascadeDistance0 = 0xFC; // float
    constexpr std::ptrdiff_t m_flShadowCascadeDistance1 = 0x100; // float
    constexpr std::ptrdiff_t m_flShadowCascadeDistance2 = 0x104; // float
    constexpr std::ptrdiff_t m_flShadowCascadeDistance3 = 0x108; // float
    constexpr std::ptrdiff_t m_nShadowCascadeResolution0 = 0x10C; // int32_t
    constexpr std::ptrdiff_t m_nShadowCascadeResolution1 = 0x110; // int32_t
    constexpr std::ptrdiff_t m_nShadowCascadeResolution2 = 0x114; // int32_t
    constexpr std::ptrdiff_t m_nShadowCascadeResolution3 = 0x118; // int32_t
    constexpr std::ptrdiff_t m_bUsesBakedShadowing = 0x11C; // bool
    constexpr std::ptrdiff_t m_nShadowPriority = 0x120; // int32_t
    constexpr std::ptrdiff_t m_nBakedShadowIndex = 0x124; // int32_t
    constexpr std::ptrdiff_t m_bRenderToCubemaps = 0x128; // bool
    constexpr std::ptrdiff_t m_nDirectLight = 0x12C; // int32_t
    constexpr std::ptrdiff_t m_nIndirectLight = 0x130; // int32_t
    constexpr std::ptrdiff_t m_flFadeMinDist = 0x134; // float
    constexpr std::ptrdiff_t m_flFadeMaxDist = 0x138; // float
    constexpr std::ptrdiff_t m_flShadowFadeMinDist = 0x13C; // float
    constexpr std::ptrdiff_t m_flShadowFadeMaxDist = 0x140; // float
    constexpr std::ptrdiff_t m_bEnabled = 0x144; // bool
    constexpr std::ptrdiff_t m_bFlicker = 0x145; // bool
    constexpr std::ptrdiff_t m_bPrecomputedFieldsValid = 0x146; // bool
    constexpr std::ptrdiff_t m_vPrecomputedBoundsMins = 0x148; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedBoundsMaxs = 0x154; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedOBBOrigin = 0x160; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedOBBAngles = 0x16C; // QAngle
    constexpr std::ptrdiff_t m_vPrecomputedOBBExtent = 0x178; // Vector
    constexpr std::ptrdiff_t m_flPrecomputedMaxRange = 0x184; // float
    constexpr std::ptrdiff_t m_nFogLightingMode = 0x188; // int32_t
    constexpr std::ptrdiff_t m_flFogContributionStength = 0x18C; // float
    constexpr std::ptrdiff_t m_flNearClipPlane = 0x190; // float
    constexpr std::ptrdiff_t m_SkyColor = 0x194; // Color
    constexpr std::ptrdiff_t m_flSkyIntensity = 0x198; // float
    constexpr std::ptrdiff_t m_SkyAmbientBounce = 0x19C; // Color
    constexpr std::ptrdiff_t m_bUseSecondaryColor = 0x1A0; // bool
    constexpr std::ptrdiff_t m_bMixedShadows = 0x1A1; // bool
    constexpr std::ptrdiff_t m_flLightStyleStartTime = 0x1A4; // GameTime_t
    constexpr std::ptrdiff_t m_flCapsuleLength = 0x1A8; // float
    constexpr std::ptrdiff_t m_flMinRoughness = 0x1AC; // float
    constexpr std::ptrdiff_t m_bPvsModifyEntity = 0x1C0; // bool
}

namespace CLightEntity {
    constexpr std::ptrdiff_t m_CLightComponent = 0x700; // CLightComponent*
}

namespace CLightGlow {
    constexpr std::ptrdiff_t m_nHorizontalSize = 0x700; // uint32_t
    constexpr std::ptrdiff_t m_nVerticalSize = 0x704; // uint32_t
    constexpr std::ptrdiff_t m_nMinDist = 0x708; // uint32_t
    constexpr std::ptrdiff_t m_nMaxDist = 0x70C; // uint32_t
    constexpr std::ptrdiff_t m_nOuterMaxDist = 0x710; // uint32_t
    constexpr std::ptrdiff_t m_flGlowProxySize = 0x714; // float
    constexpr std::ptrdiff_t m_flHDRColorScale = 0x718; // float
}

namespace CLogicAchievement {
    constexpr std::ptrdiff_t m_bDisabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_iszAchievementEventID = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_OnFired = 0x4C0; // CEntityIOOutput
}

namespace CLogicActiveAutosave {
    constexpr std::ptrdiff_t m_TriggerHitPoints = 0x4C0; // int32_t
    constexpr std::ptrdiff_t m_flTimeToTrigger = 0x4C4; // float
    constexpr std::ptrdiff_t m_flStartTime = 0x4C8; // GameTime_t
    constexpr std::ptrdiff_t m_flDangerousTime = 0x4CC; // float
}

namespace CLogicAuto {
    constexpr std::ptrdiff_t m_OnMapSpawn = 0x4B0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnDemoMapSpawn = 0x4D8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnNewGame = 0x500; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnLoadGame = 0x528; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnMapTransition = 0x550; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnBackgroundMap = 0x578; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnMultiNewMap = 0x5A0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnMultiNewRound = 0x5C8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnVREnabled = 0x5F0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnVRNotEnabled = 0x618; // CEntityIOOutput
    constexpr std::ptrdiff_t m_globalstate = 0x640; // CUtlSymbolLarge
}

namespace CLogicAutosave {
    constexpr std::ptrdiff_t m_bForceNewLevelUnit = 0x4B0; // bool
    constexpr std::ptrdiff_t m_minHitPoints = 0x4B4; // int32_t
    constexpr std::ptrdiff_t m_minHitPointsToCommit = 0x4B8; // int32_t
}

namespace CLogicBranch {
    constexpr std::ptrdiff_t m_bInValue = 0x4B0; // bool
    constexpr std::ptrdiff_t m_Listeners = 0x4B8; // CUtlVector<CHandle<CBaseEntity>>
    constexpr std::ptrdiff_t m_OnTrue = 0x4D0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFalse = 0x4F8; // CEntityIOOutput
}

namespace CLogicBranchList {
    constexpr std::ptrdiff_t m_nLogicBranchNames = 0x4B0; // CUtlSymbolLarge[16]
    constexpr std::ptrdiff_t m_LogicBranchList = 0x530; // CUtlVector<CHandle<CBaseEntity>>
    constexpr std::ptrdiff_t m_eLastState = 0x548; // CLogicBranchList::LogicBranchListenerLastState_t
    constexpr std::ptrdiff_t m_OnAllTrue = 0x550; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnAllFalse = 0x578; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnMixed = 0x5A0; // CEntityIOOutput
}

namespace CLogicCase {
    constexpr std::ptrdiff_t m_nCase = 0x4B0; // CUtlSymbolLarge[32]
    constexpr std::ptrdiff_t m_nShuffleCases = 0x5B0; // int32_t
    constexpr std::ptrdiff_t m_nLastShuffleCase = 0x5B4; // int32_t
    constexpr std::ptrdiff_t m_uchShuffleCaseMap = 0x5B8; // uint8_t[32]
    constexpr std::ptrdiff_t m_OnCase = 0x5D8; // CEntityIOOutput[32]
    constexpr std::ptrdiff_t m_OnDefault = 0xAD8; // CEntityOutputTemplate<CVariantBase<CVariantDefaultAllocator>>
}

namespace CLogicCollisionPair {
    constexpr std::ptrdiff_t m_nameAttach1 = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nameAttach2 = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_disabled = 0x4C0; // bool
    constexpr std::ptrdiff_t m_succeeded = 0x4C1; // bool
}

namespace CLogicCompare {
    constexpr std::ptrdiff_t m_flInValue = 0x4B0; // float
    constexpr std::ptrdiff_t m_flCompareValue = 0x4B4; // float
    constexpr std::ptrdiff_t m_OnLessThan = 0x4B8; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnEqualTo = 0x4E0; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnNotEqualTo = 0x508; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnGreaterThan = 0x530; // CEntityOutputTemplate<float>
}

namespace CLogicDistanceAutosave {
    constexpr std::ptrdiff_t m_iszTargetEntity = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flDistanceToPlayer = 0x4B8; // float
    constexpr std::ptrdiff_t m_bForceNewLevelUnit = 0x4BC; // bool
    constexpr std::ptrdiff_t m_bCheckCough = 0x4BD; // bool
    constexpr std::ptrdiff_t m_bThinkDangerous = 0x4BE; // bool
    constexpr std::ptrdiff_t m_flDangerousTime = 0x4C0; // float
}

namespace CLogicDistanceCheck {
    constexpr std::ptrdiff_t m_iszEntityA = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszEntityB = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flZone1Distance = 0x4C0; // float
    constexpr std::ptrdiff_t m_flZone2Distance = 0x4C4; // float
    constexpr std::ptrdiff_t m_InZone1 = 0x4C8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_InZone2 = 0x4F0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_InZone3 = 0x518; // CEntityIOOutput
}

namespace CLogicEventListener {
    constexpr std::ptrdiff_t m_strEventName = 0x4C0; // CUtlString
    constexpr std::ptrdiff_t m_bIsEnabled = 0x4C8; // bool
    constexpr std::ptrdiff_t m_nTeam = 0x4CC; // int32_t
    constexpr std::ptrdiff_t m_OnEventFired = 0x4D0; // CEntityIOOutput
}

namespace CLogicGameEvent {
    constexpr std::ptrdiff_t m_iszEventName = 0x4B0; // CUtlSymbolLarge
}

namespace CLogicGameEventListener {
    constexpr std::ptrdiff_t m_OnEventFired = 0x4C0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_iszGameEventName = 0x4E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszGameEventItem = 0x4F0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bEnabled = 0x4F8; // bool
    constexpr std::ptrdiff_t m_bStartDisabled = 0x4F9; // bool
}

namespace CLogicLineToEntity {
    constexpr std::ptrdiff_t m_Line = 0x4B0; // CEntityOutputTemplate<Vector>
    constexpr std::ptrdiff_t m_SourceName = 0x4D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_StartEntity = 0x4E0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_EndEntity = 0x4E4; // CHandle<CBaseEntity>
}

namespace CLogicMeasureMovement {
    constexpr std::ptrdiff_t m_strMeasureTarget = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_strMeasureReference = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_strTargetReference = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hMeasureTarget = 0x4C8; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hMeasureReference = 0x4CC; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTarget = 0x4D0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTargetReference = 0x4D4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_flScale = 0x4D8; // float
    constexpr std::ptrdiff_t m_nMeasureType = 0x4DC; // int32_t
}

namespace CLogicNPCCounter {
    constexpr std::ptrdiff_t m_OnMinCountAll = 0x4B0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnMaxCountAll = 0x4D8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFactorAll = 0x500; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnMinPlayerDistAll = 0x528; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnMinCount_1 = 0x550; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnMaxCount_1 = 0x578; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFactor_1 = 0x5A0; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnMinPlayerDist_1 = 0x5C8; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnMinCount_2 = 0x5F0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnMaxCount_2 = 0x618; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFactor_2 = 0x640; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnMinPlayerDist_2 = 0x668; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnMinCount_3 = 0x690; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnMaxCount_3 = 0x6B8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFactor_3 = 0x6E0; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnMinPlayerDist_3 = 0x708; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_hSource = 0x730; // CEntityHandle
    constexpr std::ptrdiff_t m_iszSourceEntityName = 0x738; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flDistanceMax = 0x740; // float
    constexpr std::ptrdiff_t m_bDisabled = 0x744; // bool
    constexpr std::ptrdiff_t m_nMinCountAll = 0x748; // int32_t
    constexpr std::ptrdiff_t m_nMaxCountAll = 0x74C; // int32_t
    constexpr std::ptrdiff_t m_nMinFactorAll = 0x750; // int32_t
    constexpr std::ptrdiff_t m_nMaxFactorAll = 0x754; // int32_t
    constexpr std::ptrdiff_t m_iszNPCClassname_1 = 0x760; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nNPCState_1 = 0x768; // int32_t
    constexpr std::ptrdiff_t m_bInvertState_1 = 0x76C; // bool
    constexpr std::ptrdiff_t m_nMinCount_1 = 0x770; // int32_t
    constexpr std::ptrdiff_t m_nMaxCount_1 = 0x774; // int32_t
    constexpr std::ptrdiff_t m_nMinFactor_1 = 0x778; // int32_t
    constexpr std::ptrdiff_t m_nMaxFactor_1 = 0x77C; // int32_t
    constexpr std::ptrdiff_t m_flDefaultDist_1 = 0x784; // float
    constexpr std::ptrdiff_t m_iszNPCClassname_2 = 0x788; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nNPCState_2 = 0x790; // int32_t
    constexpr std::ptrdiff_t m_bInvertState_2 = 0x794; // bool
    constexpr std::ptrdiff_t m_nMinCount_2 = 0x798; // int32_t
    constexpr std::ptrdiff_t m_nMaxCount_2 = 0x79C; // int32_t
    constexpr std::ptrdiff_t m_nMinFactor_2 = 0x7A0; // int32_t
    constexpr std::ptrdiff_t m_nMaxFactor_2 = 0x7A4; // int32_t
    constexpr std::ptrdiff_t m_flDefaultDist_2 = 0x7AC; // float
    constexpr std::ptrdiff_t m_iszNPCClassname_3 = 0x7B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nNPCState_3 = 0x7B8; // int32_t
    constexpr std::ptrdiff_t m_bInvertState_3 = 0x7BC; // bool
    constexpr std::ptrdiff_t m_nMinCount_3 = 0x7C0; // int32_t
    constexpr std::ptrdiff_t m_nMaxCount_3 = 0x7C4; // int32_t
    constexpr std::ptrdiff_t m_nMinFactor_3 = 0x7C8; // int32_t
    constexpr std::ptrdiff_t m_nMaxFactor_3 = 0x7CC; // int32_t
    constexpr std::ptrdiff_t m_flDefaultDist_3 = 0x7D4; // float
}

namespace CLogicNPCCounterAABB {
    constexpr std::ptrdiff_t m_vDistanceOuterMins = 0x7F0; // Vector
    constexpr std::ptrdiff_t m_vDistanceOuterMaxs = 0x7FC; // Vector
    constexpr std::ptrdiff_t m_vOuterMins = 0x808; // Vector
    constexpr std::ptrdiff_t m_vOuterMaxs = 0x814; // Vector
}

namespace CLogicNavigation {
    constexpr std::ptrdiff_t m_isOn = 0x4B8; // bool
    constexpr std::ptrdiff_t m_navProperty = 0x4BC; // navproperties_t
}

namespace CLogicPlayerProxy {
    constexpr std::ptrdiff_t m_hPlayer = 0x4B0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_PlayerHasAmmo = 0x4B8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_PlayerHasNoAmmo = 0x4E0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_PlayerDied = 0x508; // CEntityIOOutput
    constexpr std::ptrdiff_t m_RequestedPlayerHealth = 0x530; // CEntityOutputTemplate<int32_t>
}

namespace CLogicRelay {
    constexpr std::ptrdiff_t m_OnTrigger = 0x4B0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnSpawn = 0x4D8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bDisabled = 0x500; // bool
    constexpr std::ptrdiff_t m_bWaitForRefire = 0x501; // bool
    constexpr std::ptrdiff_t m_bTriggerOnce = 0x502; // bool
    constexpr std::ptrdiff_t m_bFastRetrigger = 0x503; // bool
    constexpr std::ptrdiff_t m_bPassthoughCaller = 0x504; // bool
}

namespace CMapInfo {
    constexpr std::ptrdiff_t m_iBuyingStatus = 0x4B0; // int32_t
    constexpr std::ptrdiff_t m_flBombRadius = 0x4B4; // float
    constexpr std::ptrdiff_t m_iPetPopulation = 0x4B8; // int32_t
    constexpr std::ptrdiff_t m_bUseNormalSpawnsForDM = 0x4BC; // bool
    constexpr std::ptrdiff_t m_bDisableAutoGeneratedDMSpawns = 0x4BD; // bool
    constexpr std::ptrdiff_t m_flBotMaxVisionDistance = 0x4C0; // float
    constexpr std::ptrdiff_t m_iHostageCount = 0x4C4; // int32_t
    constexpr std::ptrdiff_t m_bFadePlayerVisibilityFarZ = 0x4C8; // bool
}

namespace CMapVetoPickController {
    constexpr std::ptrdiff_t m_bPlayedIntroVcd = 0x4B0; // bool
    constexpr std::ptrdiff_t m_bNeedToPlayFiveSecondsRemaining = 0x4B1; // bool
    constexpr std::ptrdiff_t m_dblPreMatchDraftSequenceTime = 0x4D0; // double
    constexpr std::ptrdiff_t m_bPreMatchDraftStateChanged = 0x4D8; // bool
    constexpr std::ptrdiff_t m_nDraftType = 0x4DC; // int32_t
    constexpr std::ptrdiff_t m_nTeamWinningCoinToss = 0x4E0; // int32_t
    constexpr std::ptrdiff_t m_nTeamWithFirstChoice = 0x4E4; // int32_t[64]
    constexpr std::ptrdiff_t m_nVoteMapIdsList = 0x5E4; // int32_t[7]
    constexpr std::ptrdiff_t m_nAccountIDs = 0x600; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId0 = 0x700; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId1 = 0x800; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId2 = 0x900; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId3 = 0xA00; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId4 = 0xB00; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId5 = 0xC00; // int32_t[64]
    constexpr std::ptrdiff_t m_nStartingSide0 = 0xD00; // int32_t[64]
    constexpr std::ptrdiff_t m_nCurrentPhase = 0xE00; // int32_t
    constexpr std::ptrdiff_t m_nPhaseStartTick = 0xE04; // int32_t
    constexpr std::ptrdiff_t m_nPhaseDurationTicks = 0xE08; // int32_t
    constexpr std::ptrdiff_t m_OnMapVetoed = 0xE10; // CEntityOutputTemplate<CUtlSymbolLarge>
    constexpr std::ptrdiff_t m_OnMapPicked = 0xE38; // CEntityOutputTemplate<CUtlSymbolLarge>
    constexpr std::ptrdiff_t m_OnSidesPicked = 0xE60; // CEntityOutputTemplate<int32_t>
    constexpr std::ptrdiff_t m_OnNewPhaseStarted = 0xE88; // CEntityOutputTemplate<int32_t>
    constexpr std::ptrdiff_t m_OnLevelTransition = 0xEB0; // CEntityOutputTemplate<int32_t>
}

namespace CMarkupVolume {
    constexpr std::ptrdiff_t m_bEnabled = 0x700; // bool
}

namespace CMarkupVolumeTagged {
    constexpr std::ptrdiff_t m_bIsGroup = 0x738; // bool
    constexpr std::ptrdiff_t m_bGroupByPrefab = 0x739; // bool
    constexpr std::ptrdiff_t m_bGroupByVolume = 0x73A; // bool
    constexpr std::ptrdiff_t m_bGroupOtherGroups = 0x73B; // bool
    constexpr std::ptrdiff_t m_bIsInGroup = 0x73C; // bool
}

namespace CMarkupVolumeTagged_NavGame {
    constexpr std::ptrdiff_t m_bFloodFillAttribute = 0x758; // bool
}

namespace CMarkupVolumeWithRef {
    constexpr std::ptrdiff_t m_bUseRef = 0x740; // bool
    constexpr std::ptrdiff_t m_vRefPos = 0x744; // Vector
    constexpr std::ptrdiff_t m_flRefDot = 0x750; // float
}

namespace CMathColorBlend {
    constexpr std::ptrdiff_t m_flInMin = 0x4B0; // float
    constexpr std::ptrdiff_t m_flInMax = 0x4B4; // float
    constexpr std::ptrdiff_t m_OutColor1 = 0x4B8; // Color
    constexpr std::ptrdiff_t m_OutColor2 = 0x4BC; // Color
    constexpr std::ptrdiff_t m_OutValue = 0x4C0; // CEntityOutputTemplate<Color>
}

namespace CMathCounter {
    constexpr std::ptrdiff_t m_flMin = 0x4B0; // float
    constexpr std::ptrdiff_t m_flMax = 0x4B4; // float
    constexpr std::ptrdiff_t m_bHitMin = 0x4B8; // bool
    constexpr std::ptrdiff_t m_bHitMax = 0x4B9; // bool
    constexpr std::ptrdiff_t m_bDisabled = 0x4BA; // bool
    constexpr std::ptrdiff_t m_OutValue = 0x4C0; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnGetValue = 0x4E8; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnHitMin = 0x510; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnHitMax = 0x538; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnChangedFromMin = 0x560; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnChangedFromMax = 0x588; // CEntityIOOutput
}

namespace CMathRemap {
    constexpr std::ptrdiff_t m_flInMin = 0x4B0; // float
    constexpr std::ptrdiff_t m_flInMax = 0x4B4; // float
    constexpr std::ptrdiff_t m_flOut1 = 0x4B8; // float
    constexpr std::ptrdiff_t m_flOut2 = 0x4BC; // float
    constexpr std::ptrdiff_t m_flOldInValue = 0x4C0; // float
    constexpr std::ptrdiff_t m_bEnabled = 0x4C4; // bool
    constexpr std::ptrdiff_t m_OutValue = 0x4C8; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnRoseAboveMin = 0x4F0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnRoseAboveMax = 0x518; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFellBelowMin = 0x540; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFellBelowMax = 0x568; // CEntityIOOutput
}

namespace CMelee {
    constexpr std::ptrdiff_t m_flThrowAt = 0xE20; // GameTime_t
    constexpr std::ptrdiff_t m_hThrower = 0xE24; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bDidThrowDamage = 0xE28; // bool
}

namespace CMessage {
    constexpr std::ptrdiff_t m_iszMessage = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_MessageVolume = 0x4B8; // float
    constexpr std::ptrdiff_t m_MessageAttenuation = 0x4BC; // int32_t
    constexpr std::ptrdiff_t m_Radius = 0x4C0; // float
    constexpr std::ptrdiff_t m_sNoise = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_OnShowMessage = 0x4D0; // CEntityIOOutput
}

namespace CMessageEntity {
    constexpr std::ptrdiff_t m_radius = 0x4B0; // int32_t
    constexpr std::ptrdiff_t m_messageText = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_drawText = 0x4C0; // bool
    constexpr std::ptrdiff_t m_bDeveloperOnly = 0x4C1; // bool
    constexpr std::ptrdiff_t m_bEnabled = 0x4C2; // bool
}

namespace CModelState {
    constexpr std::ptrdiff_t m_hModel = 0xA0; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_ModelName = 0xA8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bClientClothCreationSuppressed = 0xE8; // bool
    constexpr std::ptrdiff_t m_MeshGroupMask = 0x180; // uint64_t
    constexpr std::ptrdiff_t m_nIdealMotionType = 0x222; // int8_t
    constexpr std::ptrdiff_t m_nForceLOD = 0x223; // int8_t
    constexpr std::ptrdiff_t m_nClothUpdateFlags = 0x224; // int8_t
}

namespace CMolotovProjectile {
    constexpr std::ptrdiff_t m_bIsIncGrenade = 0xA40; // bool
    constexpr std::ptrdiff_t m_bDetonated = 0xA4C; // bool
    constexpr std::ptrdiff_t m_stillTimer = 0xA50; // IntervalTimer
    constexpr std::ptrdiff_t m_bHasBouncedOffPlayer = 0xB30; // bool
}

namespace CMomentaryRotButton {
    constexpr std::ptrdiff_t m_Position = 0x8C8; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnUnpressed = 0x8F0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFullyOpen = 0x918; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFullyClosed = 0x940; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnReachedPosition = 0x968; // CEntityIOOutput
    constexpr std::ptrdiff_t m_lastUsed = 0x990; // int32_t
    constexpr std::ptrdiff_t m_start = 0x994; // QAngle
    constexpr std::ptrdiff_t m_end = 0x9A0; // QAngle
    constexpr std::ptrdiff_t m_IdealYaw = 0x9AC; // float
    constexpr std::ptrdiff_t m_sNoise = 0x9B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bUpdateTarget = 0x9B8; // bool
    constexpr std::ptrdiff_t m_direction = 0x9BC; // int32_t
    constexpr std::ptrdiff_t m_returnSpeed = 0x9C0; // float
    constexpr std::ptrdiff_t m_flStartPosition = 0x9C4; // float
}

namespace CMotorController {
    constexpr std::ptrdiff_t m_speed = 0x8; // float
    constexpr std::ptrdiff_t m_maxTorque = 0xC; // float
    constexpr std::ptrdiff_t m_axis = 0x10; // Vector
    constexpr std::ptrdiff_t m_inertiaFactor = 0x1C; // float
}

namespace CMultiLightProxy {
    constexpr std::ptrdiff_t m_iszLightNameFilter = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszLightClassFilter = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flLightRadiusFilter = 0x4C0; // float
    constexpr std::ptrdiff_t m_flBrightnessDelta = 0x4C4; // float
    constexpr std::ptrdiff_t m_bPerformScreenFade = 0x4C8; // bool
    constexpr std::ptrdiff_t m_flTargetBrightnessMultiplier = 0x4CC; // float
    constexpr std::ptrdiff_t m_flCurrentBrightnessMultiplier = 0x4D0; // float
    constexpr std::ptrdiff_t m_vecLights = 0x4D8; // CUtlVector<CHandle<CLightEntity>>
}

namespace CMultiSource {
    constexpr std::ptrdiff_t m_rgEntities = 0x4B0; // CHandle<CBaseEntity>[32]
    constexpr std::ptrdiff_t m_rgTriggered = 0x530; // int32_t[32]
    constexpr std::ptrdiff_t m_OnTrigger = 0x5B0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_iTotal = 0x5D8; // int32_t
    constexpr std::ptrdiff_t m_globalstate = 0x5E0; // CUtlSymbolLarge
}

namespace CMultiplayer_Expresser {
    constexpr std::ptrdiff_t m_bAllowMultipleScenes = 0x70; // bool
}

namespace CNavHullPresetVData {
    constexpr std::ptrdiff_t m_vecNavHulls = 0x0; // CUtlVector<CUtlString>
}

namespace CNavHullVData {
    constexpr std::ptrdiff_t m_bAgentEnabled = 0x0; // bool
    constexpr std::ptrdiff_t m_agentRadius = 0x4; // float
    constexpr std::ptrdiff_t m_agentHeight = 0x8; // float
    constexpr std::ptrdiff_t m_agentShortHeightEnabled = 0xC; // bool
    constexpr std::ptrdiff_t m_agentShortHeight = 0x10; // float
    constexpr std::ptrdiff_t m_agentMaxClimb = 0x14; // float
    constexpr std::ptrdiff_t m_agentMaxSlope = 0x18; // int32_t
    constexpr std::ptrdiff_t m_agentMaxJumpDownDist = 0x1C; // float
    constexpr std::ptrdiff_t m_agentMaxJumpHorizDistBase = 0x20; // float
    constexpr std::ptrdiff_t m_agentMaxJumpUpDist = 0x24; // float
    constexpr std::ptrdiff_t m_agentBorderErosion = 0x28; // int32_t
}

namespace CNavLinkAnimgraphVar {
    constexpr std::ptrdiff_t m_strAnimgraphVar = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_unAlignmentDegrees = 0x8; // uint32_t
}

namespace CNavLinkAreaEntity {
    constexpr std::ptrdiff_t m_flWidth = 0x4B0; // float
    constexpr std::ptrdiff_t m_vLocatorOffset = 0x4B4; // Vector
    constexpr std::ptrdiff_t m_qLocatorAnglesOffset = 0x4C0; // QAngle
    constexpr std::ptrdiff_t m_strMovementForward = 0x4D0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_strMovementReverse = 0x4D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nNavLinkIdForward = 0x4E0; // int32_t
    constexpr std::ptrdiff_t m_nNavLinkIdReverse = 0x4E4; // int32_t
    constexpr std::ptrdiff_t m_bEnabled = 0x4E8; // bool
    constexpr std::ptrdiff_t m_strFilterName = 0x4F0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hFilter = 0x4F8; // CHandle<CBaseFilter>
    constexpr std::ptrdiff_t m_OnNavLinkStart = 0x500; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnNavLinkFinish = 0x528; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bIsTerminus = 0x550; // bool
}

namespace CNavLinkMovementVData {
    constexpr std::ptrdiff_t m_bIsInterpolated = 0x0; // bool
    constexpr std::ptrdiff_t m_unRecommendedDistance = 0x4; // uint32_t
    constexpr std::ptrdiff_t m_vecAnimgraphVars = 0x8; // CUtlVector<CNavLinkAnimgraphVar>
}

namespace CNavSpaceInfo {
    constexpr std::ptrdiff_t m_bCreateFlightSpace = 0x4B0; // bool
}

namespace CNavVolumeBreadthFirstSearch {
    constexpr std::ptrdiff_t m_vStartPos = 0xA0; // Vector
    constexpr std::ptrdiff_t m_flSearchDist = 0xAC; // float
}

namespace CNavVolumeSphere {
    constexpr std::ptrdiff_t m_vCenter = 0x70; // Vector
    constexpr std::ptrdiff_t m_flRadius = 0x7C; // float
}

namespace CNavVolumeSphericalShell {
    constexpr std::ptrdiff_t m_flRadiusInner = 0x80; // float
}

namespace CNavVolumeVector {
    constexpr std::ptrdiff_t m_bHasBeenPreFiltered = 0x78; // bool
}

namespace CNetworkOriginCellCoordQuantizedVector {
    constexpr std::ptrdiff_t m_cellX = 0x10; // uint16_t
    constexpr std::ptrdiff_t m_cellY = 0x12; // uint16_t
    constexpr std::ptrdiff_t m_cellZ = 0x14; // uint16_t
    constexpr std::ptrdiff_t m_nOutsideWorld = 0x16; // uint16_t
    constexpr std::ptrdiff_t m_vecX = 0x18; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_vecY = 0x20; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_vecZ = 0x28; // CNetworkedQuantizedFloat
}

namespace CNetworkOriginQuantizedVector {
    constexpr std::ptrdiff_t m_vecX = 0x10; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_vecY = 0x18; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_vecZ = 0x20; // CNetworkedQuantizedFloat
}

namespace CNetworkTransmitComponent {
    constexpr std::ptrdiff_t m_nTransmitStateOwnedCounter = 0x16C; // uint8_t
}

namespace CNetworkVelocityVector {
    constexpr std::ptrdiff_t m_vecX = 0x10; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_vecY = 0x18; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_vecZ = 0x20; // CNetworkedQuantizedFloat
}

namespace CNetworkViewOffsetVector {
    constexpr std::ptrdiff_t m_vecX = 0x10; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_vecY = 0x18; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_vecZ = 0x20; // CNetworkedQuantizedFloat
}

namespace CNetworkedSequenceOperation {
    constexpr std::ptrdiff_t m_hSequence = 0x8; // HSequence
    constexpr std::ptrdiff_t m_flPrevCycle = 0xC; // float
    constexpr std::ptrdiff_t m_flCycle = 0x10; // float
    constexpr std::ptrdiff_t m_flWeight = 0x14; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_bSequenceChangeNetworked = 0x1C; // bool
    constexpr std::ptrdiff_t m_bDiscontinuity = 0x1D; // bool
    constexpr std::ptrdiff_t m_flPrevCycleFromDiscontinuity = 0x20; // float
    constexpr std::ptrdiff_t m_flPrevCycleForAnimEventDetection = 0x24; // float
}

namespace COmniLight {
    constexpr std::ptrdiff_t m_flInnerAngle = 0x928; // float
    constexpr std::ptrdiff_t m_flOuterAngle = 0x92C; // float
    constexpr std::ptrdiff_t m_bShowLight = 0x930; // bool
}

namespace COrnamentProp {
    constexpr std::ptrdiff_t m_initialOwner = 0xB08; // CUtlSymbolLarge
}

namespace CParticleSystem {
    constexpr std::ptrdiff_t m_szSnapshotFileName = 0x700; // char[512]
    constexpr std::ptrdiff_t m_bActive = 0x900; // bool
    constexpr std::ptrdiff_t m_bFrozen = 0x901; // bool
    constexpr std::ptrdiff_t m_flFreezeTransitionDuration = 0x904; // float
    constexpr std::ptrdiff_t m_nStopType = 0x908; // int32_t
    constexpr std::ptrdiff_t m_bAnimateDuringGameplayPause = 0x90C; // bool
    constexpr std::ptrdiff_t m_iEffectIndex = 0x910; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_flStartTime = 0x918; // GameTime_t
    constexpr std::ptrdiff_t m_flPreSimTime = 0x91C; // float
    constexpr std::ptrdiff_t m_vServerControlPoints = 0x920; // Vector[4]
    constexpr std::ptrdiff_t m_iServerControlPointAssignments = 0x950; // uint8_t[4]
    constexpr std::ptrdiff_t m_hControlPointEnts = 0x954; // CHandle<CBaseEntity>[64]
    constexpr std::ptrdiff_t m_bNoSave = 0xA54; // bool
    constexpr std::ptrdiff_t m_bNoFreeze = 0xA55; // bool
    constexpr std::ptrdiff_t m_bNoRamp = 0xA56; // bool
    constexpr std::ptrdiff_t m_bStartActive = 0xA57; // bool
    constexpr std::ptrdiff_t m_iszEffectName = 0xA58; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszControlPointNames = 0xA60; // CUtlSymbolLarge[64]
    constexpr std::ptrdiff_t m_nDataCP = 0xC60; // int32_t
    constexpr std::ptrdiff_t m_vecDataCPValue = 0xC64; // Vector
    constexpr std::ptrdiff_t m_nTintCP = 0xC70; // int32_t
    constexpr std::ptrdiff_t m_clrTint = 0xC74; // Color
}

namespace CPathCorner {
    constexpr std::ptrdiff_t m_flWait = 0x4B0; // float
    constexpr std::ptrdiff_t m_flRadius = 0x4B4; // float
    constexpr std::ptrdiff_t m_OnPass = 0x4B8; // CEntityIOOutput
}

namespace CPathKeyFrame {
    constexpr std::ptrdiff_t m_Origin = 0x4B0; // Vector
    constexpr std::ptrdiff_t m_Angles = 0x4BC; // QAngle
    constexpr std::ptrdiff_t m_qAngle = 0x4D0; // Quaternion
    constexpr std::ptrdiff_t m_iNextKey = 0x4E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flNextTime = 0x4E8; // float
    constexpr std::ptrdiff_t m_pNextKey = 0x4F0; // CPathKeyFrame*
    constexpr std::ptrdiff_t m_pPrevKey = 0x4F8; // CPathKeyFrame*
    constexpr std::ptrdiff_t m_flSpeed = 0x500; // float
}

namespace CPathParticleRope {
    constexpr std::ptrdiff_t m_bStartActive = 0x4B0; // bool
    constexpr std::ptrdiff_t m_flMaxSimulationTime = 0x4B4; // float
    constexpr std::ptrdiff_t m_iszEffectName = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_PathNodes_Name = 0x4C0; // CUtlVector<CUtlSymbolLarge>
    constexpr std::ptrdiff_t m_flParticleSpacing = 0x4D8; // float
    constexpr std::ptrdiff_t m_flSlack = 0x4DC; // float
    constexpr std::ptrdiff_t m_flRadius = 0x4E0; // float
    constexpr std::ptrdiff_t m_ColorTint = 0x4E4; // Color
    constexpr std::ptrdiff_t m_nEffectState = 0x4E8; // int32_t
    constexpr std::ptrdiff_t m_iEffectIndex = 0x4F0; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_PathNodes_Position = 0x4F8; // CNetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_PathNodes_TangentIn = 0x510; // CNetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_PathNodes_TangentOut = 0x528; // CNetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_PathNodes_Color = 0x540; // CNetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_PathNodes_PinEnabled = 0x558; // CNetworkUtlVectorBase<bool>
    constexpr std::ptrdiff_t m_PathNodes_RadiusScale = 0x570; // CNetworkUtlVectorBase<float>
}

namespace CPathTrack {
    constexpr std::ptrdiff_t m_pnext = 0x4B0; // CPathTrack*
    constexpr std::ptrdiff_t m_pprevious = 0x4B8; // CPathTrack*
    constexpr std::ptrdiff_t m_paltpath = 0x4C0; // CPathTrack*
    constexpr std::ptrdiff_t m_flRadius = 0x4C8; // float
    constexpr std::ptrdiff_t m_length = 0x4CC; // float
    constexpr std::ptrdiff_t m_altName = 0x4D0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nIterVal = 0x4D8; // int32_t
    constexpr std::ptrdiff_t m_eOrientationType = 0x4DC; // TrackOrientationType_t
    constexpr std::ptrdiff_t m_OnPass = 0x4E0; // CEntityIOOutput
}

namespace CPhysBallSocket {
    constexpr std::ptrdiff_t m_flFriction = 0x508; // float
    constexpr std::ptrdiff_t m_bEnableSwingLimit = 0x50C; // bool
    constexpr std::ptrdiff_t m_flSwingLimit = 0x510; // float
    constexpr std::ptrdiff_t m_bEnableTwistLimit = 0x514; // bool
    constexpr std::ptrdiff_t m_flMinTwistAngle = 0x518; // float
    constexpr std::ptrdiff_t m_flMaxTwistAngle = 0x51C; // float
}

namespace CPhysBox {
    constexpr std::ptrdiff_t m_damageType = 0x7C0; // int32_t
    constexpr std::ptrdiff_t m_massScale = 0x7C4; // float
    constexpr std::ptrdiff_t m_damageToEnableMotion = 0x7C8; // int32_t
    constexpr std::ptrdiff_t m_flForceToEnableMotion = 0x7CC; // float
    constexpr std::ptrdiff_t m_angPreferredCarryAngles = 0x7D0; // QAngle
    constexpr std::ptrdiff_t m_bNotSolidToWorld = 0x7DC; // bool
    constexpr std::ptrdiff_t m_bEnableUseOutput = 0x7DD; // bool
    constexpr std::ptrdiff_t m_iExploitableByPlayer = 0x7E0; // int32_t
    constexpr std::ptrdiff_t m_flTouchOutputPerEntityDelay = 0x7E4; // float
    constexpr std::ptrdiff_t m_OnDamaged = 0x7E8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnAwakened = 0x810; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnMotionEnabled = 0x838; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnPlayerUse = 0x860; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnStartTouch = 0x888; // CEntityIOOutput
    constexpr std::ptrdiff_t m_hCarryingPlayer = 0x8B0; // CHandle<CBasePlayerPawn>
}

namespace CPhysConstraint {
    constexpr std::ptrdiff_t m_nameAttach1 = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nameAttach2 = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_breakSound = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_forceLimit = 0x4D0; // float
    constexpr std::ptrdiff_t m_torqueLimit = 0x4D4; // float
    constexpr std::ptrdiff_t m_teleportTick = 0x4D8; // uint32_t
    constexpr std::ptrdiff_t m_minTeleportDistance = 0x4DC; // float
    constexpr std::ptrdiff_t m_OnBreak = 0x4E0; // CEntityIOOutput
}

namespace CPhysExplosion {
    constexpr std::ptrdiff_t m_bExplodeOnSpawn = 0x4B0; // bool
    constexpr std::ptrdiff_t m_flMagnitude = 0x4B4; // float
    constexpr std::ptrdiff_t m_flDamage = 0x4B8; // float
    constexpr std::ptrdiff_t m_radius = 0x4BC; // float
    constexpr std::ptrdiff_t m_targetEntityName = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flInnerRadius = 0x4C8; // float
    constexpr std::ptrdiff_t m_flPushScale = 0x4CC; // float
    constexpr std::ptrdiff_t m_bConvertToDebrisWhenPossible = 0x4D0; // bool
    constexpr std::ptrdiff_t m_OnPushedPlayer = 0x4D8; // CEntityIOOutput
}

namespace CPhysFixed {
    constexpr std::ptrdiff_t m_flLinearFrequency = 0x508; // float
    constexpr std::ptrdiff_t m_flLinearDampingRatio = 0x50C; // float
    constexpr std::ptrdiff_t m_flAngularFrequency = 0x510; // float
    constexpr std::ptrdiff_t m_flAngularDampingRatio = 0x514; // float
    constexpr std::ptrdiff_t m_bEnableLinearConstraint = 0x518; // bool
    constexpr std::ptrdiff_t m_bEnableAngularConstraint = 0x519; // bool
}

namespace CPhysForce {
    constexpr std::ptrdiff_t m_nameAttach = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_force = 0x4C0; // float
    constexpr std::ptrdiff_t m_forceTime = 0x4C4; // float
    constexpr std::ptrdiff_t m_attachedObject = 0x4C8; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_wasRestored = 0x4CC; // bool
    constexpr std::ptrdiff_t m_integrator = 0x4D0; // CConstantForceController
}

namespace CPhysHinge {
    constexpr std::ptrdiff_t m_soundInfo = 0x510; // ConstraintSoundInfo
    constexpr std::ptrdiff_t m_NotifyMinLimitReached = 0x598; // CEntityIOOutput
    constexpr std::ptrdiff_t m_NotifyMaxLimitReached = 0x5C0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bAtMinLimit = 0x5E8; // bool
    constexpr std::ptrdiff_t m_bAtMaxLimit = 0x5E9; // bool
    constexpr std::ptrdiff_t m_hinge = 0x5EC; // constraint_hingeparams_t
    constexpr std::ptrdiff_t m_hingeFriction = 0x62C; // float
    constexpr std::ptrdiff_t m_systemLoadScale = 0x630; // float
    constexpr std::ptrdiff_t m_bIsAxisLocal = 0x634; // bool
    constexpr std::ptrdiff_t m_flMinRotation = 0x638; // float
    constexpr std::ptrdiff_t m_flMaxRotation = 0x63C; // float
    constexpr std::ptrdiff_t m_flInitialRotation = 0x640; // float
    constexpr std::ptrdiff_t m_flMotorFrequency = 0x644; // float
    constexpr std::ptrdiff_t m_flMotorDampingRatio = 0x648; // float
    constexpr std::ptrdiff_t m_flAngleSpeed = 0x64C; // float
    constexpr std::ptrdiff_t m_flAngleSpeedThreshold = 0x650; // float
    constexpr std::ptrdiff_t m_OnStartMoving = 0x658; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnStopMoving = 0x680; // CEntityIOOutput
}

namespace CPhysImpact {
    constexpr std::ptrdiff_t m_damage = 0x4B0; // float
    constexpr std::ptrdiff_t m_distance = 0x4B4; // float
    constexpr std::ptrdiff_t m_directionEntityName = 0x4B8; // CUtlSymbolLarge
}

namespace CPhysLength {
    constexpr std::ptrdiff_t m_offset = 0x508; // Vector[2]
    constexpr std::ptrdiff_t m_vecAttach = 0x520; // Vector
    constexpr std::ptrdiff_t m_addLength = 0x52C; // float
    constexpr std::ptrdiff_t m_minLength = 0x530; // float
    constexpr std::ptrdiff_t m_totalLength = 0x534; // float
    constexpr std::ptrdiff_t m_bEnableCollision = 0x538; // bool
}

namespace CPhysMagnet {
    constexpr std::ptrdiff_t m_OnMagnetAttach = 0x890; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnMagnetDetach = 0x8B8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_massScale = 0x8E0; // float
    constexpr std::ptrdiff_t m_forceLimit = 0x8E4; // float
    constexpr std::ptrdiff_t m_torqueLimit = 0x8E8; // float
    constexpr std::ptrdiff_t m_MagnettedEntities = 0x8F0; // CUtlVector<magnetted_objects_t>
    constexpr std::ptrdiff_t m_bActive = 0x908; // bool
    constexpr std::ptrdiff_t m_bHasHitSomething = 0x909; // bool
    constexpr std::ptrdiff_t m_flTotalMass = 0x90C; // float
    constexpr std::ptrdiff_t m_flRadius = 0x910; // float
    constexpr std::ptrdiff_t m_flNextSuckTime = 0x914; // GameTime_t
    constexpr std::ptrdiff_t m_iMaxObjectsAttached = 0x918; // int32_t
}

namespace CPhysMotor {
    constexpr std::ptrdiff_t m_nameAttach = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hAttachedObject = 0x4B8; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_spinUp = 0x4BC; // float
    constexpr std::ptrdiff_t m_additionalAcceleration = 0x4C0; // float
    constexpr std::ptrdiff_t m_angularAcceleration = 0x4C4; // float
    constexpr std::ptrdiff_t m_lastTime = 0x4C8; // GameTime_t
    constexpr std::ptrdiff_t m_motor = 0x4E0; // CMotorController
}

namespace CPhysPulley {
    constexpr std::ptrdiff_t m_position2 = 0x508; // Vector
    constexpr std::ptrdiff_t m_offset = 0x514; // Vector[2]
    constexpr std::ptrdiff_t m_addLength = 0x52C; // float
    constexpr std::ptrdiff_t m_gearRatio = 0x530; // float
}

namespace CPhysSlideConstraint {
    constexpr std::ptrdiff_t m_axisEnd = 0x510; // Vector
    constexpr std::ptrdiff_t m_slideFriction = 0x51C; // float
    constexpr std::ptrdiff_t m_systemLoadScale = 0x520; // float
    constexpr std::ptrdiff_t m_initialOffset = 0x524; // float
    constexpr std::ptrdiff_t m_bEnableLinearConstraint = 0x528; // bool
    constexpr std::ptrdiff_t m_bEnableAngularConstraint = 0x529; // bool
    constexpr std::ptrdiff_t m_flMotorFrequency = 0x52C; // float
    constexpr std::ptrdiff_t m_flMotorDampingRatio = 0x530; // float
    constexpr std::ptrdiff_t m_bUseEntityPivot = 0x534; // bool
    constexpr std::ptrdiff_t m_soundInfo = 0x538; // ConstraintSoundInfo
}

namespace CPhysThruster {
    constexpr std::ptrdiff_t m_localOrigin = 0x510; // Vector
}

namespace CPhysTorque {
    constexpr std::ptrdiff_t m_axis = 0x510; // Vector
}

namespace CPhysWheelConstraint {
    constexpr std::ptrdiff_t m_flSuspensionFrequency = 0x508; // float
    constexpr std::ptrdiff_t m_flSuspensionDampingRatio = 0x50C; // float
    constexpr std::ptrdiff_t m_flSuspensionHeightOffset = 0x510; // float
    constexpr std::ptrdiff_t m_bEnableSuspensionLimit = 0x514; // bool
    constexpr std::ptrdiff_t m_flMinSuspensionOffset = 0x518; // float
    constexpr std::ptrdiff_t m_flMaxSuspensionOffset = 0x51C; // float
    constexpr std::ptrdiff_t m_bEnableSteeringLimit = 0x520; // bool
    constexpr std::ptrdiff_t m_flMinSteeringAngle = 0x524; // float
    constexpr std::ptrdiff_t m_flMaxSteeringAngle = 0x528; // float
    constexpr std::ptrdiff_t m_flSteeringAxisFriction = 0x52C; // float
    constexpr std::ptrdiff_t m_flSpinAxisFriction = 0x530; // float
}

namespace CPhysicsEntitySolver {
    constexpr std::ptrdiff_t m_hMovingEntity = 0x4B8; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hPhysicsBlocker = 0x4BC; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_separationDuration = 0x4C0; // float
    constexpr std::ptrdiff_t m_cancelTime = 0x4C4; // GameTime_t
}

namespace CPhysicsProp {
    constexpr std::ptrdiff_t m_MotionEnabled = 0xA10; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnAwakened = 0xA38; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnAwake = 0xA60; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnAsleep = 0xA88; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnPlayerUse = 0xAB0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnPlayerPickup = 0xAD8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnOutOfWorld = 0xB00; // CEntityIOOutput
    constexpr std::ptrdiff_t m_massScale = 0xB28; // float
    constexpr std::ptrdiff_t m_inertiaScale = 0xB2C; // float
    constexpr std::ptrdiff_t m_buoyancyScale = 0xB30; // float
    constexpr std::ptrdiff_t m_damageType = 0xB34; // int32_t
    constexpr std::ptrdiff_t m_damageToEnableMotion = 0xB38; // int32_t
    constexpr std::ptrdiff_t m_flForceToEnableMotion = 0xB3C; // float
    constexpr std::ptrdiff_t m_bThrownByPlayer = 0xB40; // bool
    constexpr std::ptrdiff_t m_bDroppedByPlayer = 0xB41; // bool
    constexpr std::ptrdiff_t m_bTouchedByPlayer = 0xB42; // bool
    constexpr std::ptrdiff_t m_bFirstCollisionAfterLaunch = 0xB43; // bool
    constexpr std::ptrdiff_t m_iExploitableByPlayer = 0xB44; // int32_t
    constexpr std::ptrdiff_t m_bHasBeenAwakened = 0xB48; // bool
    constexpr std::ptrdiff_t m_bIsOverrideProp = 0xB49; // bool
    constexpr std::ptrdiff_t m_fNextCheckDisableMotionContactsTime = 0xB4C; // GameTime_t
    constexpr std::ptrdiff_t m_iInitialGlowState = 0xB50; // int32_t
    constexpr std::ptrdiff_t m_nGlowRange = 0xB54; // int32_t
    constexpr std::ptrdiff_t m_nGlowRangeMin = 0xB58; // int32_t
    constexpr std::ptrdiff_t m_glowColor = 0xB5C; // Color
    constexpr std::ptrdiff_t m_bForceNavIgnore = 0xB60; // bool
    constexpr std::ptrdiff_t m_bNoNavmeshBlocker = 0xB61; // bool
    constexpr std::ptrdiff_t m_bForceNpcExclude = 0xB62; // bool
    constexpr std::ptrdiff_t m_bShouldAutoConvertBackFromDebris = 0xB63; // bool
    constexpr std::ptrdiff_t m_bMuteImpactEffects = 0xB64; // bool
    constexpr std::ptrdiff_t m_bAcceptDamageFromHeldObjects = 0xB6C; // bool
    constexpr std::ptrdiff_t m_bEnableUseOutput = 0xB6D; // bool
    constexpr std::ptrdiff_t m_bAwake = 0xB6E; // bool
    constexpr std::ptrdiff_t m_nCollisionGroupOverride = 0xB70; // int32_t
}

namespace CPhysicsPropRespawnable {
    constexpr std::ptrdiff_t m_vOriginalSpawnOrigin = 0xB78; // Vector
    constexpr std::ptrdiff_t m_vOriginalSpawnAngles = 0xB84; // QAngle
    constexpr std::ptrdiff_t m_vOriginalMins = 0xB90; // Vector
    constexpr std::ptrdiff_t m_vOriginalMaxs = 0xB9C; // Vector
    constexpr std::ptrdiff_t m_flRespawnDuration = 0xBA8; // float
}

namespace CPhysicsShake {
    constexpr std::ptrdiff_t m_force = 0x8; // Vector
}

namespace CPhysicsSpring {
    constexpr std::ptrdiff_t m_flFrequency = 0x4B8; // float
    constexpr std::ptrdiff_t m_flDampingRatio = 0x4BC; // float
    constexpr std::ptrdiff_t m_flRestLength = 0x4C0; // float
    constexpr std::ptrdiff_t m_nameAttachStart = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nameAttachEnd = 0x4D0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_start = 0x4D8; // Vector
    constexpr std::ptrdiff_t m_end = 0x4E4; // Vector
    constexpr std::ptrdiff_t m_teleportTick = 0x4F0; // uint32_t
}

namespace CPhysicsWire {
    constexpr std::ptrdiff_t m_nDensity = 0x4B0; // int32_t
}

namespace CPlantedC4 {
    constexpr std::ptrdiff_t m_bBombTicking = 0x890; // bool
    constexpr std::ptrdiff_t m_flC4Blow = 0x894; // GameTime_t
    constexpr std::ptrdiff_t m_nBombSite = 0x898; // int32_t
    constexpr std::ptrdiff_t m_nSourceSoundscapeHash = 0x89C; // int32_t
    constexpr std::ptrdiff_t m_OnBombDefused = 0x8A0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnBombBeginDefuse = 0x8C8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnBombDefuseAborted = 0x8F0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bCannotBeDefused = 0x918; // bool
    constexpr std::ptrdiff_t m_entitySpottedState = 0x920; // EntitySpottedState_t
    constexpr std::ptrdiff_t m_nSpotRules = 0x938; // int32_t
    constexpr std::ptrdiff_t m_bTrainingPlacedByPlayer = 0x93C; // bool
    constexpr std::ptrdiff_t m_bHasExploded = 0x93D; // bool
    constexpr std::ptrdiff_t m_flTimerLength = 0x940; // float
    constexpr std::ptrdiff_t m_bBeingDefused = 0x944; // bool
    constexpr std::ptrdiff_t m_fLastDefuseTime = 0x94C; // GameTime_t
    constexpr std::ptrdiff_t m_flDefuseLength = 0x954; // float
    constexpr std::ptrdiff_t m_flDefuseCountDown = 0x958; // GameTime_t
    constexpr std::ptrdiff_t m_bBombDefused = 0x95C; // bool
    constexpr std::ptrdiff_t m_hBombDefuser = 0x960; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_hControlPanel = 0x964; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iProgressBarTime = 0x968; // int32_t
    constexpr std::ptrdiff_t m_bVoiceAlertFired = 0x96C; // bool
    constexpr std::ptrdiff_t m_bVoiceAlertPlayed = 0x96D; // bool[4]
    constexpr std::ptrdiff_t m_flNextBotBeepTime = 0x974; // GameTime_t
    constexpr std::ptrdiff_t m_bPlantedAfterPickup = 0x97C; // bool
    constexpr std::ptrdiff_t m_angCatchUpToPlayerEye = 0x980; // QAngle
    constexpr std::ptrdiff_t m_flLastSpinDetectionTime = 0x98C; // GameTime_t
}

namespace CPlatTrigger {
    constexpr std::ptrdiff_t m_pPlatform = 0x700; // CHandle<CFuncPlat>
}

namespace CPlayerControllerComponent {
    constexpr std::ptrdiff_t __m_pChainEntity = 0x8; // CNetworkVarChainer
}

namespace CPlayerPawnComponent {
    constexpr std::ptrdiff_t __m_pChainEntity = 0x8; // CNetworkVarChainer
}

namespace CPlayerPing {
    constexpr std::ptrdiff_t m_hPlayer = 0x4B8; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_hPingedEntity = 0x4BC; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iType = 0x4C0; // int32_t
    constexpr std::ptrdiff_t m_bUrgent = 0x4C4; // bool
    constexpr std::ptrdiff_t m_szPlaceName = 0x4C5; // char[18]
}

namespace CPlayerSprayDecal {
    constexpr std::ptrdiff_t m_nUniqueID = 0x700; // int32_t
    constexpr std::ptrdiff_t m_unAccountID = 0x704; // uint32_t
    constexpr std::ptrdiff_t m_unTraceID = 0x708; // uint32_t
    constexpr std::ptrdiff_t m_rtGcTime = 0x70C; // uint32_t
    constexpr std::ptrdiff_t m_vecEndPos = 0x710; // Vector
    constexpr std::ptrdiff_t m_vecStart = 0x71C; // Vector
    constexpr std::ptrdiff_t m_vecLeft = 0x728; // Vector
    constexpr std::ptrdiff_t m_vecNormal = 0x734; // Vector
    constexpr std::ptrdiff_t m_nPlayer = 0x740; // int32_t
    constexpr std::ptrdiff_t m_nEntity = 0x744; // int32_t
    constexpr std::ptrdiff_t m_nHitbox = 0x748; // int32_t
    constexpr std::ptrdiff_t m_flCreationTime = 0x74C; // float
    constexpr std::ptrdiff_t m_nTintID = 0x750; // int32_t
    constexpr std::ptrdiff_t m_nVersion = 0x754; // uint8_t
    constexpr std::ptrdiff_t m_ubSignature = 0x755; // uint8_t[128]
}

namespace CPlayerVisibility {
    constexpr std::ptrdiff_t m_flVisibilityStrength = 0x4B0; // float
    constexpr std::ptrdiff_t m_flFogDistanceMultiplier = 0x4B4; // float
    constexpr std::ptrdiff_t m_flFogMaxDensityMultiplier = 0x4B8; // float
    constexpr std::ptrdiff_t m_flFadeTime = 0x4BC; // float
    constexpr std::ptrdiff_t m_bStartDisabled = 0x4C0; // bool
    constexpr std::ptrdiff_t m_bIsEnabled = 0x4C1; // bool
}

namespace CPlayer_CameraServices {
    constexpr std::ptrdiff_t m_vecCsViewPunchAngle = 0x40; // QAngle
    constexpr std::ptrdiff_t m_nCsViewPunchAngleTick = 0x4C; // GameTick_t
    constexpr std::ptrdiff_t m_flCsViewPunchAngleTickRatio = 0x50; // float
    constexpr std::ptrdiff_t m_PlayerFog = 0x58; // fogplayerparams_t
    constexpr std::ptrdiff_t m_hColorCorrectionCtrl = 0x98; // CHandle<CColorCorrection>
    constexpr std::ptrdiff_t m_hViewEntity = 0x9C; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTonemapController = 0xA0; // CHandle<CTonemapController2>
    constexpr std::ptrdiff_t m_audio = 0xA8; // audioparams_t
    constexpr std::ptrdiff_t m_PostProcessingVolumes = 0x120; // CNetworkUtlVectorBase<CHandle<CPostProcessingVolume>>
    constexpr std::ptrdiff_t m_flOldPlayerZ = 0x138; // float
    constexpr std::ptrdiff_t m_flOldPlayerViewOffsetZ = 0x13C; // float
    constexpr std::ptrdiff_t m_hTriggerSoundscapeList = 0x158; // CUtlVector<CHandle<CEnvSoundscapeTriggerable>>
}

namespace CPlayer_MovementServices {
    constexpr std::ptrdiff_t m_nImpulse = 0x40; // int32_t
    constexpr std::ptrdiff_t m_nButtons = 0x48; // CInButtonState
    constexpr std::ptrdiff_t m_nQueuedButtonDownMask = 0x68; // uint64_t
    constexpr std::ptrdiff_t m_nQueuedButtonChangeMask = 0x70; // uint64_t
    constexpr std::ptrdiff_t m_nButtonDoublePressed = 0x78; // uint64_t
    constexpr std::ptrdiff_t m_pButtonPressedCmdNumber = 0x80; // uint32_t[64]
    constexpr std::ptrdiff_t m_nLastCommandNumberProcessed = 0x180; // uint32_t
    constexpr std::ptrdiff_t m_nToggleButtonDownMask = 0x188; // uint64_t
    constexpr std::ptrdiff_t m_flMaxspeed = 0x190; // float
    constexpr std::ptrdiff_t m_arrForceSubtickMoveWhen = 0x194; // float[4]
    constexpr std::ptrdiff_t m_flForwardMove = 0x1A4; // float
    constexpr std::ptrdiff_t m_flLeftMove = 0x1A8; // float
    constexpr std::ptrdiff_t m_flUpMove = 0x1AC; // float
    constexpr std::ptrdiff_t m_vecLastMovementImpulses = 0x1B0; // Vector
    constexpr std::ptrdiff_t m_vecOldViewAngles = 0x1BC; // QAngle
}

namespace CPlayer_MovementServices_Humanoid {
    constexpr std::ptrdiff_t m_flStepSoundTime = 0x1D0; // float
    constexpr std::ptrdiff_t m_flFallVelocity = 0x1D4; // float
    constexpr std::ptrdiff_t m_bInCrouch = 0x1D8; // bool
    constexpr std::ptrdiff_t m_nCrouchState = 0x1DC; // uint32_t
    constexpr std::ptrdiff_t m_flCrouchTransitionStartTime = 0x1E0; // GameTime_t
    constexpr std::ptrdiff_t m_bDucked = 0x1E4; // bool
    constexpr std::ptrdiff_t m_bDucking = 0x1E5; // bool
    constexpr std::ptrdiff_t m_bInDuckJump = 0x1E6; // bool
    constexpr std::ptrdiff_t m_groundNormal = 0x1E8; // Vector
    constexpr std::ptrdiff_t m_flSurfaceFriction = 0x1F4; // float
    constexpr std::ptrdiff_t m_surfaceProps = 0x1F8; // CUtlStringToken
    constexpr std::ptrdiff_t m_nStepside = 0x208; // int32_t
    constexpr std::ptrdiff_t m_iTargetVolume = 0x20C; // int32_t
    constexpr std::ptrdiff_t m_vecSmoothedVelocity = 0x210; // Vector
}

namespace CPlayer_ObserverServices {
    constexpr std::ptrdiff_t m_iObserverMode = 0x40; // uint8_t
    constexpr std::ptrdiff_t m_hObserverTarget = 0x44; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iObserverLastMode = 0x48; // ObserverMode_t
    constexpr std::ptrdiff_t m_bForcedObserverMode = 0x4C; // bool
}

namespace CPlayer_WeaponServices {
    constexpr std::ptrdiff_t m_bAllowSwitchToNoWeapon = 0x40; // bool
    constexpr std::ptrdiff_t m_hMyWeapons = 0x48; // CNetworkUtlVectorBase<CHandle<CBasePlayerWeapon>>
    constexpr std::ptrdiff_t m_hActiveWeapon = 0x60; // CHandle<CBasePlayerWeapon>
    constexpr std::ptrdiff_t m_hLastWeapon = 0x64; // CHandle<CBasePlayerWeapon>
    constexpr std::ptrdiff_t m_iAmmo = 0x68; // uint16_t[32]
    constexpr std::ptrdiff_t m_bPreventWeaponPickup = 0xA8; // bool
}

namespace CPointAngleSensor {
    constexpr std::ptrdiff_t m_bDisabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_nLookAtName = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hTargetEntity = 0x4C0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hLookAtEntity = 0x4C4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_flDuration = 0x4C8; // float
    constexpr std::ptrdiff_t m_flDotTolerance = 0x4CC; // float
    constexpr std::ptrdiff_t m_flFacingTime = 0x4D0; // GameTime_t
    constexpr std::ptrdiff_t m_bFired = 0x4D4; // bool
    constexpr std::ptrdiff_t m_OnFacingLookat = 0x4D8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnNotFacingLookat = 0x500; // CEntityIOOutput
    constexpr std::ptrdiff_t m_TargetDir = 0x528; // CEntityOutputTemplate<Vector>
    constexpr std::ptrdiff_t m_FacingPercentage = 0x550; // CEntityOutputTemplate<float>
}

namespace CPointAngularVelocitySensor {
    constexpr std::ptrdiff_t m_hTargetEntity = 0x4B0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_flThreshold = 0x4B4; // float
    constexpr std::ptrdiff_t m_nLastCompareResult = 0x4B8; // int32_t
    constexpr std::ptrdiff_t m_nLastFireResult = 0x4BC; // int32_t
    constexpr std::ptrdiff_t m_flFireTime = 0x4C0; // GameTime_t
    constexpr std::ptrdiff_t m_flFireInterval = 0x4C4; // float
    constexpr std::ptrdiff_t m_flLastAngVelocity = 0x4C8; // float
    constexpr std::ptrdiff_t m_lastOrientation = 0x4CC; // QAngle
    constexpr std::ptrdiff_t m_vecAxis = 0x4D8; // Vector
    constexpr std::ptrdiff_t m_bUseHelper = 0x4E4; // bool
    constexpr std::ptrdiff_t m_AngularVelocity = 0x4E8; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnLessThan = 0x510; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnLessThanOrEqualTo = 0x538; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnGreaterThan = 0x560; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnGreaterThanOrEqualTo = 0x588; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnEqualTo = 0x5B0; // CEntityIOOutput
}

namespace CPointCamera {
    constexpr std::ptrdiff_t m_FOV = 0x4B0; // float
    constexpr std::ptrdiff_t m_Resolution = 0x4B4; // float
    constexpr std::ptrdiff_t m_bFogEnable = 0x4B8; // bool
    constexpr std::ptrdiff_t m_FogColor = 0x4B9; // Color
    constexpr std::ptrdiff_t m_flFogStart = 0x4C0; // float
    constexpr std::ptrdiff_t m_flFogEnd = 0x4C4; // float
    constexpr std::ptrdiff_t m_flFogMaxDensity = 0x4C8; // float
    constexpr std::ptrdiff_t m_bActive = 0x4CC; // bool
    constexpr std::ptrdiff_t m_bUseScreenAspectRatio = 0x4CD; // bool
    constexpr std::ptrdiff_t m_flAspectRatio = 0x4D0; // float
    constexpr std::ptrdiff_t m_bNoSky = 0x4D4; // bool
    constexpr std::ptrdiff_t m_fBrightness = 0x4D8; // float
    constexpr std::ptrdiff_t m_flZFar = 0x4DC; // float
    constexpr std::ptrdiff_t m_flZNear = 0x4E0; // float
    constexpr std::ptrdiff_t m_bCanHLTVUse = 0x4E4; // bool
    constexpr std::ptrdiff_t m_bDofEnabled = 0x4E5; // bool
    constexpr std::ptrdiff_t m_flDofNearBlurry = 0x4E8; // float
    constexpr std::ptrdiff_t m_flDofNearCrisp = 0x4EC; // float
    constexpr std::ptrdiff_t m_flDofFarCrisp = 0x4F0; // float
    constexpr std::ptrdiff_t m_flDofFarBlurry = 0x4F4; // float
    constexpr std::ptrdiff_t m_flDofTiltToGround = 0x4F8; // float
    constexpr std::ptrdiff_t m_TargetFOV = 0x4FC; // float
    constexpr std::ptrdiff_t m_DegreesPerSecond = 0x500; // float
    constexpr std::ptrdiff_t m_bIsOn = 0x504; // bool
    constexpr std::ptrdiff_t m_pNext = 0x508; // CPointCamera*
}

namespace CPointCameraVFOV {
    constexpr std::ptrdiff_t m_flVerticalFOV = 0x510; // float
}

namespace CPointClientUIDialog {
    constexpr std::ptrdiff_t m_hActivator = 0x8B0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bStartEnabled = 0x8B4; // bool
}

namespace CPointClientUIWorldPanel {
    constexpr std::ptrdiff_t m_bIgnoreInput = 0x8B0; // bool
    constexpr std::ptrdiff_t m_bLit = 0x8B1; // bool
    constexpr std::ptrdiff_t m_bFollowPlayerAcrossTeleport = 0x8B2; // bool
    constexpr std::ptrdiff_t m_flWidth = 0x8B4; // float
    constexpr std::ptrdiff_t m_flHeight = 0x8B8; // float
    constexpr std::ptrdiff_t m_flDPI = 0x8BC; // float
    constexpr std::ptrdiff_t m_flInteractDistance = 0x8C0; // float
    constexpr std::ptrdiff_t m_flDepthOffset = 0x8C4; // float
    constexpr std::ptrdiff_t m_unOwnerContext = 0x8C8; // uint32_t
    constexpr std::ptrdiff_t m_unHorizontalAlign = 0x8CC; // uint32_t
    constexpr std::ptrdiff_t m_unVerticalAlign = 0x8D0; // uint32_t
    constexpr std::ptrdiff_t m_unOrientation = 0x8D4; // uint32_t
    constexpr std::ptrdiff_t m_bAllowInteractionFromAllSceneWorlds = 0x8D8; // bool
    constexpr std::ptrdiff_t m_vecCSSClasses = 0x8E0; // CNetworkUtlVectorBase<CUtlSymbolLarge>
    constexpr std::ptrdiff_t m_bOpaque = 0x8F8; // bool
    constexpr std::ptrdiff_t m_bNoDepth = 0x8F9; // bool
    constexpr std::ptrdiff_t m_bRenderBackface = 0x8FA; // bool
    constexpr std::ptrdiff_t m_bUseOffScreenIndicator = 0x8FB; // bool
    constexpr std::ptrdiff_t m_bExcludeFromSaveGames = 0x8FC; // bool
    constexpr std::ptrdiff_t m_bGrabbable = 0x8FD; // bool
    constexpr std::ptrdiff_t m_bOnlyRenderToTexture = 0x8FE; // bool
    constexpr std::ptrdiff_t m_bDisableMipGen = 0x8FF; // bool
    constexpr std::ptrdiff_t m_nExplicitImageLayout = 0x900; // int32_t
}

namespace CPointClientUIWorldTextPanel {
    constexpr std::ptrdiff_t m_messageText = 0x908; // char[512]
}

namespace CPointCommentaryNode {
    constexpr std::ptrdiff_t m_iszPreCommands = 0x890; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszPostCommands = 0x898; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszCommentaryFile = 0x8A0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszViewTarget = 0x8A8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hViewTarget = 0x8B0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hViewTargetAngles = 0x8B4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iszViewPosition = 0x8B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hViewPosition = 0x8C0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hViewPositionMover = 0x8C4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bPreventMovement = 0x8C8; // bool
    constexpr std::ptrdiff_t m_bUnderCrosshair = 0x8C9; // bool
    constexpr std::ptrdiff_t m_bUnstoppable = 0x8CA; // bool
    constexpr std::ptrdiff_t m_flFinishedTime = 0x8CC; // GameTime_t
    constexpr std::ptrdiff_t m_vecFinishOrigin = 0x8D0; // Vector
    constexpr std::ptrdiff_t m_vecOriginalAngles = 0x8DC; // QAngle
    constexpr std::ptrdiff_t m_vecFinishAngles = 0x8E8; // QAngle
    constexpr std::ptrdiff_t m_bPreventChangesWhileMoving = 0x8F4; // bool
    constexpr std::ptrdiff_t m_bDisabled = 0x8F5; // bool
    constexpr std::ptrdiff_t m_vecTeleportOrigin = 0x8F8; // Vector
    constexpr std::ptrdiff_t m_flAbortedPlaybackAt = 0x904; // GameTime_t
    constexpr std::ptrdiff_t m_pOnCommentaryStarted = 0x908; // CEntityIOOutput
    constexpr std::ptrdiff_t m_pOnCommentaryStopped = 0x930; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bActive = 0x958; // bool
    constexpr std::ptrdiff_t m_flStartTime = 0x95C; // GameTime_t
    constexpr std::ptrdiff_t m_flStartTimeInCommentary = 0x960; // float
    constexpr std::ptrdiff_t m_iszTitle = 0x968; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSpeakers = 0x970; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iNodeNumber = 0x978; // int32_t
    constexpr std::ptrdiff_t m_iNodeNumberMax = 0x97C; // int32_t
    constexpr std::ptrdiff_t m_bListenedTo = 0x980; // bool
}

namespace CPointEntityFinder {
    constexpr std::ptrdiff_t m_hEntity = 0x4B0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iFilterName = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hFilter = 0x4C0; // CHandle<CBaseFilter>
    constexpr std::ptrdiff_t m_iRefName = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hReference = 0x4D0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_FindMethod = 0x4D4; // EntFinderMethod_t
    constexpr std::ptrdiff_t m_OnFoundEntity = 0x4D8; // CEntityIOOutput
}

namespace CPointGamestatsCounter {
    constexpr std::ptrdiff_t m_strStatisticName = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bDisabled = 0x4B8; // bool
}

namespace CPointGiveAmmo {
    constexpr std::ptrdiff_t m_pActivator = 0x4B0; // CHandle<CBaseEntity>
}

namespace CPointHurt {
    constexpr std::ptrdiff_t m_nDamage = 0x4B0; // int32_t
    constexpr std::ptrdiff_t m_bitsDamageType = 0x4B4; // int32_t
    constexpr std::ptrdiff_t m_flRadius = 0x4B8; // float
    constexpr std::ptrdiff_t m_flDelay = 0x4BC; // float
    constexpr std::ptrdiff_t m_strTarget = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_pActivator = 0x4C8; // CHandle<CBaseEntity>
}

namespace CPointPrefab {
    constexpr std::ptrdiff_t m_targetMapName = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_forceWorldGroupID = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_associatedRelayTargetName = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_fixupNames = 0x4C8; // bool
    constexpr std::ptrdiff_t m_bLoadDynamic = 0x4C9; // bool
    constexpr std::ptrdiff_t m_associatedRelayEntity = 0x4CC; // CHandle<CPointPrefab>
}

namespace CPointProximitySensor {
    constexpr std::ptrdiff_t m_bDisabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_hTargetEntity = 0x4B4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_Distance = 0x4B8; // CEntityOutputTemplate<float>
}

namespace CPointPulse {
    constexpr std::ptrdiff_t m_sNameFixupStaticPrefix = 0x5C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_sNameFixupParent = 0x5D0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_sNameFixupLocal = 0x5D8; // CUtlSymbolLarge
}

namespace CPointPush {
    constexpr std::ptrdiff_t m_bEnabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_flMagnitude = 0x4B4; // float
    constexpr std::ptrdiff_t m_flRadius = 0x4B8; // float
    constexpr std::ptrdiff_t m_flInnerRadius = 0x4BC; // float
    constexpr std::ptrdiff_t m_flConeOfInfluence = 0x4C0; // float
    constexpr std::ptrdiff_t m_iszFilterName = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hFilter = 0x4D0; // CHandle<CBaseFilter>
}

namespace CPointTeleport {
    constexpr std::ptrdiff_t m_vSaveOrigin = 0x4B0; // Vector
    constexpr std::ptrdiff_t m_vSaveAngles = 0x4BC; // QAngle
    constexpr std::ptrdiff_t m_bTeleportParentedEntities = 0x4C8; // bool
    constexpr std::ptrdiff_t m_bTeleportUseCurrentAngle = 0x4C9; // bool
}

namespace CPointTemplate {
    constexpr std::ptrdiff_t m_iszWorldName = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSource2EntityLumpName = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszEntityFilterName = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flTimeoutInterval = 0x4C8; // float
    constexpr std::ptrdiff_t m_bAsynchronouslySpawnEntities = 0x4CC; // bool
    constexpr std::ptrdiff_t m_pOutputOnSpawned = 0x4D0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_clientOnlyEntityBehavior = 0x4F8; // PointTemplateClientOnlyEntityBehavior_t
    constexpr std::ptrdiff_t m_ownerSpawnGroupType = 0x4FC; // PointTemplateOwnerSpawnGroupType_t
    constexpr std::ptrdiff_t m_createdSpawnGroupHandles = 0x500; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_SpawnedEntityHandles = 0x518; // CUtlVector<CEntityHandle>
    constexpr std::ptrdiff_t m_ScriptSpawnCallback = 0x530; // HSCRIPT
    constexpr std::ptrdiff_t m_ScriptCallbackScope = 0x538; // HSCRIPT
}

namespace CPointValueRemapper {
    constexpr std::ptrdiff_t m_bDisabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_bUpdateOnClient = 0x4B1; // bool
    constexpr std::ptrdiff_t m_nInputType = 0x4B4; // ValueRemapperInputType_t
    constexpr std::ptrdiff_t m_iszRemapLineStartName = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszRemapLineEndName = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hRemapLineStart = 0x4C8; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hRemapLineEnd = 0x4CC; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_flMaximumChangePerSecond = 0x4D0; // float
    constexpr std::ptrdiff_t m_flDisengageDistance = 0x4D4; // float
    constexpr std::ptrdiff_t m_flEngageDistance = 0x4D8; // float
    constexpr std::ptrdiff_t m_bRequiresUseKey = 0x4DC; // bool
    constexpr std::ptrdiff_t m_nOutputType = 0x4E0; // ValueRemapperOutputType_t
    constexpr std::ptrdiff_t m_iszOutputEntityName = 0x4E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszOutputEntity2Name = 0x4F0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszOutputEntity3Name = 0x4F8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszOutputEntity4Name = 0x500; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hOutputEntities = 0x508; // CNetworkUtlVectorBase<CHandle<CBaseEntity>>
    constexpr std::ptrdiff_t m_nHapticsType = 0x520; // ValueRemapperHapticsType_t
    constexpr std::ptrdiff_t m_nMomentumType = 0x524; // ValueRemapperMomentumType_t
    constexpr std::ptrdiff_t m_flMomentumModifier = 0x528; // float
    constexpr std::ptrdiff_t m_flSnapValue = 0x52C; // float
    constexpr std::ptrdiff_t m_flCurrentMomentum = 0x530; // float
    constexpr std::ptrdiff_t m_nRatchetType = 0x534; // ValueRemapperRatchetType_t
    constexpr std::ptrdiff_t m_flRatchetOffset = 0x538; // float
    constexpr std::ptrdiff_t m_flInputOffset = 0x53C; // float
    constexpr std::ptrdiff_t m_bEngaged = 0x540; // bool
    constexpr std::ptrdiff_t m_bFirstUpdate = 0x541; // bool
    constexpr std::ptrdiff_t m_flPreviousValue = 0x544; // float
    constexpr std::ptrdiff_t m_flPreviousUpdateTickTime = 0x548; // GameTime_t
    constexpr std::ptrdiff_t m_vecPreviousTestPoint = 0x54C; // Vector
    constexpr std::ptrdiff_t m_hUsingPlayer = 0x558; // CHandle<CBasePlayerPawn>
    constexpr std::ptrdiff_t m_flCustomOutputValue = 0x55C; // float
    constexpr std::ptrdiff_t m_iszSoundEngage = 0x560; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSoundDisengage = 0x568; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSoundReachedValueZero = 0x570; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSoundReachedValueOne = 0x578; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSoundMovingLoop = 0x580; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_Position = 0x590; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_PositionDelta = 0x5B8; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnReachedValueZero = 0x5E0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnReachedValueOne = 0x608; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnReachedValueCustom = 0x630; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnEngage = 0x658; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnDisengage = 0x680; // CEntityIOOutput
}

namespace CPointVelocitySensor {
    constexpr std::ptrdiff_t m_hTargetEntity = 0x4B0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_vecAxis = 0x4B4; // Vector
    constexpr std::ptrdiff_t m_bEnabled = 0x4C0; // bool
    constexpr std::ptrdiff_t m_fPrevVelocity = 0x4C4; // float
    constexpr std::ptrdiff_t m_flAvgInterval = 0x4C8; // float
    constexpr std::ptrdiff_t m_Velocity = 0x4D0; // CEntityOutputTemplate<float>
}

namespace CPointWorldText {
    constexpr std::ptrdiff_t m_messageText = 0x700; // char[512]
    constexpr std::ptrdiff_t m_FontName = 0x900; // char[64]
    constexpr std::ptrdiff_t m_bEnabled = 0x940; // bool
    constexpr std::ptrdiff_t m_bFullbright = 0x941; // bool
    constexpr std::ptrdiff_t m_flWorldUnitsPerPx = 0x944; // float
    constexpr std::ptrdiff_t m_flFontSize = 0x948; // float
    constexpr std::ptrdiff_t m_flDepthOffset = 0x94C; // float
    constexpr std::ptrdiff_t m_Color = 0x950; // Color
    constexpr std::ptrdiff_t m_nJustifyHorizontal = 0x954; // PointWorldTextJustifyHorizontal_t
    constexpr std::ptrdiff_t m_nJustifyVertical = 0x958; // PointWorldTextJustifyVertical_t
    constexpr std::ptrdiff_t m_nReorientMode = 0x95C; // PointWorldTextReorientMode_t
}

namespace CPostProcessingVolume {
    constexpr std::ptrdiff_t m_hPostSettings = 0x8B8; // CStrongHandle<InfoForResourceTypeCPostProcessingResource>
    constexpr std::ptrdiff_t m_flFadeDuration = 0x8C0; // float
    constexpr std::ptrdiff_t m_flMinLogExposure = 0x8C4; // float
    constexpr std::ptrdiff_t m_flMaxLogExposure = 0x8C8; // float
    constexpr std::ptrdiff_t m_flMinExposure = 0x8CC; // float
    constexpr std::ptrdiff_t m_flMaxExposure = 0x8D0; // float
    constexpr std::ptrdiff_t m_flExposureCompensation = 0x8D4; // float
    constexpr std::ptrdiff_t m_flExposureFadeSpeedUp = 0x8D8; // float
    constexpr std::ptrdiff_t m_flExposureFadeSpeedDown = 0x8DC; // float
    constexpr std::ptrdiff_t m_flTonemapEVSmoothingRange = 0x8E0; // float
    constexpr std::ptrdiff_t m_bMaster = 0x8E4; // bool
    constexpr std::ptrdiff_t m_bExposureControl = 0x8E5; // bool
    constexpr std::ptrdiff_t m_flRate = 0x8E8; // float
    constexpr std::ptrdiff_t m_flTonemapPercentTarget = 0x8EC; // float
    constexpr std::ptrdiff_t m_flTonemapPercentBrightPixels = 0x8F0; // float
    constexpr std::ptrdiff_t m_flTonemapMinAvgLum = 0x8F4; // float
}

namespace CPrecipitationVData {
    constexpr std::ptrdiff_t m_szParticlePrecipitationEffect = 0x28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_flInnerDistance = 0x108; // float
    constexpr std::ptrdiff_t m_nAttachType = 0x10C; // ParticleAttachment_t
    constexpr std::ptrdiff_t m_bBatchSameVolumeType = 0x110; // bool
    constexpr std::ptrdiff_t m_nRTEnvCP = 0x114; // int32_t
    constexpr std::ptrdiff_t m_nRTEnvCPComponent = 0x118; // int32_t
    constexpr std::ptrdiff_t m_szModifier = 0x120; // CUtlString
}

namespace CProjectedDecal {
    constexpr std::ptrdiff_t m_nTexture = 0x4B0; // int32_t
    constexpr std::ptrdiff_t m_flDistance = 0x4B4; // float
}

namespace CPropDoorRotating {
    constexpr std::ptrdiff_t m_vecAxis = 0xD98; // Vector
    constexpr std::ptrdiff_t m_flDistance = 0xDA4; // float
    constexpr std::ptrdiff_t m_eSpawnPosition = 0xDA8; // PropDoorRotatingSpawnPos_t
    constexpr std::ptrdiff_t m_eOpenDirection = 0xDAC; // PropDoorRotatingOpenDirection_e
    constexpr std::ptrdiff_t m_eCurrentOpenDirection = 0xDB0; // PropDoorRotatingOpenDirection_e
    constexpr std::ptrdiff_t m_flAjarAngle = 0xDB4; // float
    constexpr std::ptrdiff_t m_angRotationAjarDeprecated = 0xDB8; // QAngle
    constexpr std::ptrdiff_t m_angRotationClosed = 0xDC4; // QAngle
    constexpr std::ptrdiff_t m_angRotationOpenForward = 0xDD0; // QAngle
    constexpr std::ptrdiff_t m_angRotationOpenBack = 0xDDC; // QAngle
    constexpr std::ptrdiff_t m_angGoal = 0xDE8; // QAngle
    constexpr std::ptrdiff_t m_vecForwardBoundsMin = 0xDF4; // Vector
    constexpr std::ptrdiff_t m_vecForwardBoundsMax = 0xE00; // Vector
    constexpr std::ptrdiff_t m_vecBackBoundsMin = 0xE0C; // Vector
    constexpr std::ptrdiff_t m_vecBackBoundsMax = 0xE18; // Vector
    constexpr std::ptrdiff_t m_bAjarDoorShouldntAlwaysOpen = 0xE24; // bool
    constexpr std::ptrdiff_t m_hEntityBlocker = 0xE28; // CHandle<CEntityBlocker>
}

namespace CPropDoorRotatingBreakable {
    constexpr std::ptrdiff_t m_bBreakable = 0xE30; // bool
    constexpr std::ptrdiff_t m_isAbleToCloseAreaPortals = 0xE31; // bool
    constexpr std::ptrdiff_t m_currentDamageState = 0xE34; // int32_t
    constexpr std::ptrdiff_t m_damageStates = 0xE38; // CUtlVector<CUtlSymbolLarge>
}

namespace CPulseCell_Inflow_GameEvent {
    constexpr std::ptrdiff_t m_EventName = 0x70; // CBufferString
}

namespace CPulseCell_Outflow_PlayVCD {
    constexpr std::ptrdiff_t m_vcdFilename = 0x48; // CUtlString
    constexpr std::ptrdiff_t m_OnFinished = 0x50; // CPulse_OutflowConnection
    constexpr std::ptrdiff_t m_Triggers = 0x60; // CUtlVector<CPulse_OutflowConnection>
}

namespace CPulseCell_SoundEventStart {
    constexpr std::ptrdiff_t m_Type = 0x48; // SoundEventStartType_t
}

namespace CPulseCell_Step_EntFire {
    constexpr std::ptrdiff_t m_Input = 0x48; // CUtlString
}

namespace CPulseCell_Step_SetAnimGraphParam {
    constexpr std::ptrdiff_t m_ParamName = 0x48; // CUtlString
}

namespace CPulseCell_Value_FindEntByName {
    constexpr std::ptrdiff_t m_EntityType = 0x48; // CUtlString
}

namespace CRR_Response {
    constexpr std::ptrdiff_t m_Type = 0x0; // uint8_t
    constexpr std::ptrdiff_t m_szResponseName = 0x1; // char[192]
    constexpr std::ptrdiff_t m_szMatchingRule = 0xC1; // char[128]
    constexpr std::ptrdiff_t m_Params = 0x148; // ResponseParams
    constexpr std::ptrdiff_t m_fMatchScore = 0x168; // float
    constexpr std::ptrdiff_t m_szSpeakerContext = 0x170; // char*
    constexpr std::ptrdiff_t m_szWorldContext = 0x178; // char*
    constexpr std::ptrdiff_t m_Followup = 0x180; // ResponseFollowup
    constexpr std::ptrdiff_t m_pchCriteriaNames = 0x1B8; // CUtlVector<CUtlSymbol>
    constexpr std::ptrdiff_t m_pchCriteriaValues = 0x1D0; // CUtlVector<char*>
}

namespace CRagdollConstraint {
    constexpr std::ptrdiff_t m_xmin = 0x508; // float
    constexpr std::ptrdiff_t m_xmax = 0x50C; // float
    constexpr std::ptrdiff_t m_ymin = 0x510; // float
    constexpr std::ptrdiff_t m_ymax = 0x514; // float
    constexpr std::ptrdiff_t m_zmin = 0x518; // float
    constexpr std::ptrdiff_t m_zmax = 0x51C; // float
    constexpr std::ptrdiff_t m_xfriction = 0x520; // float
    constexpr std::ptrdiff_t m_yfriction = 0x524; // float
    constexpr std::ptrdiff_t m_zfriction = 0x528; // float
}

namespace CRagdollMagnet {
    constexpr std::ptrdiff_t m_bDisabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_radius = 0x4B4; // float
    constexpr std::ptrdiff_t m_force = 0x4B8; // float
    constexpr std::ptrdiff_t m_axis = 0x4BC; // Vector
}

namespace CRagdollManager {
    constexpr std::ptrdiff_t m_iCurrentMaxRagdollCount = 0x4B0; // int8_t
    constexpr std::ptrdiff_t m_iMaxRagdollCount = 0x4B4; // int32_t
    constexpr std::ptrdiff_t m_bSaveImportant = 0x4B8; // bool
}

namespace CRagdollProp {
    constexpr std::ptrdiff_t m_ragdoll = 0x898; // ragdoll_t
    constexpr std::ptrdiff_t m_bStartDisabled = 0x8D0; // bool
    constexpr std::ptrdiff_t m_ragPos = 0x8D8; // CNetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_ragAngles = 0x8F0; // CNetworkUtlVectorBase<QAngle>
    constexpr std::ptrdiff_t m_hRagdollSource = 0x908; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_lastUpdateTickCount = 0x90C; // uint32_t
    constexpr std::ptrdiff_t m_allAsleep = 0x910; // bool
    constexpr std::ptrdiff_t m_bFirstCollisionAfterLaunch = 0x911; // bool
    constexpr std::ptrdiff_t m_hDamageEntity = 0x914; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hKiller = 0x918; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hPhysicsAttacker = 0x91C; // CHandle<CBasePlayerPawn>
    constexpr std::ptrdiff_t m_flLastPhysicsInfluenceTime = 0x920; // GameTime_t
    constexpr std::ptrdiff_t m_flFadeOutStartTime = 0x924; // GameTime_t
    constexpr std::ptrdiff_t m_flFadeTime = 0x928; // float
    constexpr std::ptrdiff_t m_vecLastOrigin = 0x92C; // Vector
    constexpr std::ptrdiff_t m_flAwakeTime = 0x938; // GameTime_t
    constexpr std::ptrdiff_t m_flLastOriginChangeTime = 0x93C; // GameTime_t
    constexpr std::ptrdiff_t m_nBloodColor = 0x940; // int32_t
    constexpr std::ptrdiff_t m_strOriginClassName = 0x948; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_strSourceClassName = 0x950; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bHasBeenPhysgunned = 0x958; // bool
    constexpr std::ptrdiff_t m_bShouldTeleportPhysics = 0x959; // bool
    constexpr std::ptrdiff_t m_flBlendWeight = 0x95C; // float
    constexpr std::ptrdiff_t m_flDefaultFadeScale = 0x960; // float
    constexpr std::ptrdiff_t m_ragdollMins = 0x968; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_ragdollMaxs = 0x980; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_bShouldDeleteActivationRecord = 0x998; // bool
    constexpr std::ptrdiff_t m_bValidatePoweredRagdollPose = 0x9F8; // bool
}

namespace CRagdollPropAttached {
    constexpr std::ptrdiff_t m_boneIndexAttached = 0xA38; // uint32_t
    constexpr std::ptrdiff_t m_ragdollAttachedObjectIndex = 0xA3C; // uint32_t
    constexpr std::ptrdiff_t m_attachmentPointBoneSpace = 0xA40; // Vector
    constexpr std::ptrdiff_t m_attachmentPointRagdollSpace = 0xA4C; // Vector
    constexpr std::ptrdiff_t m_bShouldDetach = 0xA58; // bool
    constexpr std::ptrdiff_t m_bShouldDeleteAttachedActivationRecord = 0xA68; // bool
}

namespace CRandSimTimer {
    constexpr std::ptrdiff_t m_minInterval = 0x8; // float
    constexpr std::ptrdiff_t m_maxInterval = 0xC; // float
}

namespace CRandStopwatch {
    constexpr std::ptrdiff_t m_minInterval = 0xC; // float
    constexpr std::ptrdiff_t m_maxInterval = 0x10; // float
}

namespace CRangeFloat {
    constexpr std::ptrdiff_t m_pValue = 0x0; // float[2]
}

namespace CRangeInt {
    constexpr std::ptrdiff_t m_pValue = 0x0; // int32_t[2]
}

namespace CRectLight {
    constexpr std::ptrdiff_t m_bShowLight = 0x928; // bool
}

namespace CRemapFloat {
    constexpr std::ptrdiff_t m_pValue = 0x0; // float[4]
}

namespace CRenderComponent {
    constexpr std::ptrdiff_t __m_pChainEntity = 0x10; // CNetworkVarChainer
    constexpr std::ptrdiff_t m_bIsRenderingWithViewModels = 0x50; // bool
    constexpr std::ptrdiff_t m_nSplitscreenFlags = 0x54; // uint32_t
    constexpr std::ptrdiff_t m_bEnableRendering = 0x60; // bool
    constexpr std::ptrdiff_t m_bInterpolationReadyToDraw = 0xB0; // bool
}

namespace CResponseCriteriaSet {
    constexpr std::ptrdiff_t m_nNumPrefixedContexts = 0x28; // int32_t
    constexpr std::ptrdiff_t m_bOverrideOnAppend = 0x2C; // bool
}

namespace CResponseQueue {
    constexpr std::ptrdiff_t m_ExpresserTargets = 0x50; // CUtlVector<CAI_Expresser*>
}

namespace CResponseQueue_CDeferredResponse {
    constexpr std::ptrdiff_t m_contexts = 0x10; // CResponseCriteriaSet
    constexpr std::ptrdiff_t m_fDispatchTime = 0x40; // float
    constexpr std::ptrdiff_t m_hIssuer = 0x44; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_response = 0x50; // CRR_Response
    constexpr std::ptrdiff_t m_bResponseValid = 0x238; // bool
}

namespace CRetakeGameRules {
    constexpr std::ptrdiff_t m_nMatchSeed = 0xF8; // int32_t
    constexpr std::ptrdiff_t m_bBlockersPresent = 0xFC; // bool
    constexpr std::ptrdiff_t m_bRoundInProgress = 0xFD; // bool
    constexpr std::ptrdiff_t m_iFirstSecondHalfRound = 0x100; // int32_t
    constexpr std::ptrdiff_t m_iBombSite = 0x104; // int32_t
}

namespace CRevertSaved {
    constexpr std::ptrdiff_t m_loadTime = 0x700; // float
    constexpr std::ptrdiff_t m_Duration = 0x704; // float
    constexpr std::ptrdiff_t m_HoldTime = 0x708; // float
}

namespace CRopeKeyframe {
    constexpr std::ptrdiff_t m_RopeFlags = 0x708; // uint16_t
    constexpr std::ptrdiff_t m_iNextLinkName = 0x710; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_Slack = 0x718; // int16_t
    constexpr std::ptrdiff_t m_Width = 0x71C; // float
    constexpr std::ptrdiff_t m_TextureScale = 0x720; // float
    constexpr std::ptrdiff_t m_nSegments = 0x724; // uint8_t
    constexpr std::ptrdiff_t m_bConstrainBetweenEndpoints = 0x725; // bool
    constexpr std::ptrdiff_t m_strRopeMaterialModel = 0x728; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iRopeMaterialModelIndex = 0x730; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_Subdiv = 0x738; // uint8_t
    constexpr std::ptrdiff_t m_nChangeCount = 0x739; // uint8_t
    constexpr std::ptrdiff_t m_RopeLength = 0x73A; // int16_t
    constexpr std::ptrdiff_t m_fLockedPoints = 0x73C; // uint8_t
    constexpr std::ptrdiff_t m_bCreatedFromMapFile = 0x73D; // bool
    constexpr std::ptrdiff_t m_flScrollSpeed = 0x740; // float
    constexpr std::ptrdiff_t m_bStartPointValid = 0x744; // bool
    constexpr std::ptrdiff_t m_bEndPointValid = 0x745; // bool
    constexpr std::ptrdiff_t m_hStartPoint = 0x748; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hEndPoint = 0x74C; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iStartAttachment = 0x750; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_iEndAttachment = 0x751; // AttachmentHandle_t
}

namespace CRotDoor {
    constexpr std::ptrdiff_t m_bSolidBsp = 0x988; // bool
}

namespace CRuleEntity {
    constexpr std::ptrdiff_t m_iszMaster = 0x700; // CUtlSymbolLarge
}

namespace CRulePointEntity {
    constexpr std::ptrdiff_t m_Score = 0x708; // int32_t
}

namespace CSAdditionalMatchStats_t {
    constexpr std::ptrdiff_t m_numRoundsSurvived = 0x14; // int32_t
    constexpr std::ptrdiff_t m_maxNumRoundsSurvived = 0x18; // int32_t
    constexpr std::ptrdiff_t m_numRoundsSurvivedTotal = 0x1C; // int32_t
    constexpr std::ptrdiff_t m_iRoundsWonWithoutPurchase = 0x20; // int32_t
    constexpr std::ptrdiff_t m_iRoundsWonWithoutPurchaseTotal = 0x24; // int32_t
    constexpr std::ptrdiff_t m_numFirstKills = 0x28; // int32_t
    constexpr std::ptrdiff_t m_numClutchKills = 0x2C; // int32_t
    constexpr std::ptrdiff_t m_numPistolKills = 0x30; // int32_t
    constexpr std::ptrdiff_t m_numSniperKills = 0x34; // int32_t
    constexpr std::ptrdiff_t m_iNumSuicides = 0x38; // int32_t
    constexpr std::ptrdiff_t m_iNumTeamKills = 0x3C; // int32_t
    constexpr std::ptrdiff_t m_iTeamDamage = 0x40; // int32_t
}

namespace CSAdditionalPerRoundStats_t {
    constexpr std::ptrdiff_t m_numChickensKilled = 0x0; // int32_t
    constexpr std::ptrdiff_t m_killsWhileBlind = 0x4; // int32_t
    constexpr std::ptrdiff_t m_bombCarrierkills = 0x8; // int32_t
    constexpr std::ptrdiff_t m_iBurnDamageInflicted = 0xC; // int32_t
    constexpr std::ptrdiff_t m_iDinks = 0x10; // int32_t
}

namespace CSMatchStats_t {
    constexpr std::ptrdiff_t m_iEnemy5Ks = 0x68; // int32_t
    constexpr std::ptrdiff_t m_iEnemy4Ks = 0x6C; // int32_t
    constexpr std::ptrdiff_t m_iEnemy3Ks = 0x70; // int32_t
    constexpr std::ptrdiff_t m_iEnemy2Ks = 0x74; // int32_t
    constexpr std::ptrdiff_t m_iUtility_Count = 0x78; // int32_t
    constexpr std::ptrdiff_t m_iUtility_Successes = 0x7C; // int32_t
    constexpr std::ptrdiff_t m_iUtility_Enemies = 0x80; // int32_t
    constexpr std::ptrdiff_t m_iFlash_Count = 0x84; // int32_t
    constexpr std::ptrdiff_t m_iFlash_Successes = 0x88; // int32_t
    constexpr std::ptrdiff_t m_nHealthPointsRemovedTotal = 0x8C; // int32_t
    constexpr std::ptrdiff_t m_nHealthPointsDealtTotal = 0x90; // int32_t
    constexpr std::ptrdiff_t m_nShotsFiredTotal = 0x94; // int32_t
    constexpr std::ptrdiff_t m_nShotsOnTargetTotal = 0x98; // int32_t
    constexpr std::ptrdiff_t m_i1v1Count = 0x9C; // int32_t
    constexpr std::ptrdiff_t m_i1v1Wins = 0xA0; // int32_t
    constexpr std::ptrdiff_t m_i1v2Count = 0xA4; // int32_t
    constexpr std::ptrdiff_t m_i1v2Wins = 0xA8; // int32_t
    constexpr std::ptrdiff_t m_iEntryCount = 0xAC; // int32_t
    constexpr std::ptrdiff_t m_iEntryWins = 0xB0; // int32_t
}

namespace CSPerRoundStats_t {
    constexpr std::ptrdiff_t m_iKills = 0x30; // int32_t
    constexpr std::ptrdiff_t m_iDeaths = 0x34; // int32_t
    constexpr std::ptrdiff_t m_iAssists = 0x38; // int32_t
    constexpr std::ptrdiff_t m_iDamage = 0x3C; // int32_t
    constexpr std::ptrdiff_t m_iEquipmentValue = 0x40; // int32_t
    constexpr std::ptrdiff_t m_iMoneySaved = 0x44; // int32_t
    constexpr std::ptrdiff_t m_iKillReward = 0x48; // int32_t
    constexpr std::ptrdiff_t m_iLiveTime = 0x4C; // int32_t
    constexpr std::ptrdiff_t m_iHeadShotKills = 0x50; // int32_t
    constexpr std::ptrdiff_t m_iObjective = 0x54; // int32_t
    constexpr std::ptrdiff_t m_iCashEarned = 0x58; // int32_t
    constexpr std::ptrdiff_t m_iUtilityDamage = 0x5C; // int32_t
    constexpr std::ptrdiff_t m_iEnemiesFlashed = 0x60; // int32_t
}

namespace CSceneEntity {
    constexpr std::ptrdiff_t m_iszSceneFile = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszResumeSceneFile = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszTarget1 = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszTarget2 = 0x4D0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszTarget3 = 0x4D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszTarget4 = 0x4E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszTarget5 = 0x4E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszTarget6 = 0x4F0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszTarget7 = 0x4F8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszTarget8 = 0x500; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hTarget1 = 0x508; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTarget2 = 0x50C; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTarget3 = 0x510; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTarget4 = 0x514; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTarget5 = 0x518; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTarget6 = 0x51C; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTarget7 = 0x520; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTarget8 = 0x524; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bIsPlayingBack = 0x528; // bool
    constexpr std::ptrdiff_t m_bPaused = 0x529; // bool
    constexpr std::ptrdiff_t m_bMultiplayer = 0x52A; // bool
    constexpr std::ptrdiff_t m_bAutogenerated = 0x52B; // bool
    constexpr std::ptrdiff_t m_flForceClientTime = 0x52C; // float
    constexpr std::ptrdiff_t m_flCurrentTime = 0x530; // float
    constexpr std::ptrdiff_t m_flFrameTime = 0x534; // float
    constexpr std::ptrdiff_t m_bCancelAtNextInterrupt = 0x538; // bool
    constexpr std::ptrdiff_t m_fPitch = 0x53C; // float
    constexpr std::ptrdiff_t m_bAutomated = 0x540; // bool
    constexpr std::ptrdiff_t m_nAutomatedAction = 0x544; // int32_t
    constexpr std::ptrdiff_t m_flAutomationDelay = 0x548; // float
    constexpr std::ptrdiff_t m_flAutomationTime = 0x54C; // float
    constexpr std::ptrdiff_t m_hWaitingForThisResumeScene = 0x550; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bWaitingForResumeScene = 0x554; // bool
    constexpr std::ptrdiff_t m_bPausedViaInput = 0x555; // bool
    constexpr std::ptrdiff_t m_bPauseAtNextInterrupt = 0x556; // bool
    constexpr std::ptrdiff_t m_bWaitingForActor = 0x557; // bool
    constexpr std::ptrdiff_t m_bWaitingForInterrupt = 0x558; // bool
    constexpr std::ptrdiff_t m_bInterruptedActorsScenes = 0x559; // bool
    constexpr std::ptrdiff_t m_bBreakOnNonIdle = 0x55A; // bool
    constexpr std::ptrdiff_t m_hActorList = 0x560; // CNetworkUtlVectorBase<CHandle<CBaseFlex>>
    constexpr std::ptrdiff_t m_hRemoveActorList = 0x578; // CUtlVector<CHandle<CBaseEntity>>
    constexpr std::ptrdiff_t m_nSceneFlushCounter = 0x5A0; // int32_t
    constexpr std::ptrdiff_t m_nSceneStringIndex = 0x5A4; // uint16_t
    constexpr std::ptrdiff_t m_OnStart = 0x5A8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnCompletion = 0x5D0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnCanceled = 0x5F8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnPaused = 0x620; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnResumed = 0x648; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnTrigger = 0x670; // CEntityIOOutput[16]
    constexpr std::ptrdiff_t m_hInterruptScene = 0x980; // CHandle<CSceneEntity>
    constexpr std::ptrdiff_t m_nInterruptCount = 0x984; // int32_t
    constexpr std::ptrdiff_t m_bSceneMissing = 0x988; // bool
    constexpr std::ptrdiff_t m_bInterrupted = 0x989; // bool
    constexpr std::ptrdiff_t m_bCompletedEarly = 0x98A; // bool
    constexpr std::ptrdiff_t m_bInterruptSceneFinished = 0x98B; // bool
    constexpr std::ptrdiff_t m_bRestoring = 0x98C; // bool
    constexpr std::ptrdiff_t m_hNotifySceneCompletion = 0x990; // CUtlVector<CHandle<CSceneEntity>>
    constexpr std::ptrdiff_t m_hListManagers = 0x9A8; // CUtlVector<CHandle<CSceneListManager>>
    constexpr std::ptrdiff_t m_iszSoundName = 0x9E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hActor = 0x9F0; // CHandle<CBaseFlex>
    constexpr std::ptrdiff_t m_hActivator = 0x9F4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_BusyActor = 0x9F8; // int32_t
    constexpr std::ptrdiff_t m_iPlayerDeathBehavior = 0x9FC; // SceneOnPlayerDeath_t
}

namespace CSceneEventInfo {
    constexpr std::ptrdiff_t m_iLayer = 0x0; // int32_t
    constexpr std::ptrdiff_t m_iPriority = 0x4; // int32_t
    constexpr std::ptrdiff_t m_hSequence = 0x8; // HSequence
    constexpr std::ptrdiff_t m_flWeight = 0xC; // float
    constexpr std::ptrdiff_t m_bIsMoving = 0x10; // bool
    constexpr std::ptrdiff_t m_bHasArrived = 0x11; // bool
    constexpr std::ptrdiff_t m_flInitialYaw = 0x14; // float
    constexpr std::ptrdiff_t m_flTargetYaw = 0x18; // float
    constexpr std::ptrdiff_t m_flFacingYaw = 0x1C; // float
    constexpr std::ptrdiff_t m_nType = 0x20; // int32_t
    constexpr std::ptrdiff_t m_flNext = 0x24; // GameTime_t
    constexpr std::ptrdiff_t m_bIsGesture = 0x28; // bool
    constexpr std::ptrdiff_t m_bShouldRemove = 0x29; // bool
    constexpr std::ptrdiff_t m_hTarget = 0x54; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_nSceneEventId = 0x58; // uint32_t
    constexpr std::ptrdiff_t m_bClientSide = 0x5C; // bool
    constexpr std::ptrdiff_t m_bStarted = 0x5D; // bool
}

namespace CSceneListManager {
    constexpr std::ptrdiff_t m_hListManagers = 0x4B0; // CUtlVector<CHandle<CSceneListManager>>
    constexpr std::ptrdiff_t m_iszScenes = 0x4C8; // CUtlSymbolLarge[16]
    constexpr std::ptrdiff_t m_hScenes = 0x548; // CHandle<CBaseEntity>[16]
}

namespace CScriptComponent {
    constexpr std::ptrdiff_t m_scriptClassName = 0x30; // CUtlSymbolLarge
}

namespace CScriptItem {
    constexpr std::ptrdiff_t m_OnPlayerPickup = 0x968; // CEntityIOOutput
    constexpr std::ptrdiff_t m_MoveTypeOverride = 0x990; // MoveType_t
}

namespace CScriptNavBlocker {
    constexpr std::ptrdiff_t m_vExtent = 0x710; // Vector
}

namespace CScriptTriggerHurt {
    constexpr std::ptrdiff_t m_vExtent = 0x948; // Vector
}

namespace CScriptTriggerMultiple {
    constexpr std::ptrdiff_t m_vExtent = 0x8D0; // Vector
}

namespace CScriptTriggerOnce {
    constexpr std::ptrdiff_t m_vExtent = 0x8D0; // Vector
}

namespace CScriptTriggerPush {
    constexpr std::ptrdiff_t m_vExtent = 0x8D0; // Vector
}

namespace CScriptUniformRandomStream {
    constexpr std::ptrdiff_t m_hScriptScope = 0x8; // HSCRIPT
    constexpr std::ptrdiff_t m_nInitialSeed = 0x9C; // int32_t
}

namespace CScriptedSequence {
    constexpr std::ptrdiff_t m_iszEntry = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszPreIdle = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszPlay = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszPostIdle = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszModifierToAddOnPlay = 0x4D0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszNextScript = 0x4D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszEntity = 0x4E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSyncGroup = 0x4E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nMoveTo = 0x4F0; // ScriptedMoveTo_t
    constexpr std::ptrdiff_t m_bIsPlayingPreIdle = 0x4F4; // bool
    constexpr std::ptrdiff_t m_bIsPlayingEntry = 0x4F5; // bool
    constexpr std::ptrdiff_t m_bIsPlayingAction = 0x4F6; // bool
    constexpr std::ptrdiff_t m_bIsPlayingPostIdle = 0x4F7; // bool
    constexpr std::ptrdiff_t m_bLoopPreIdleSequence = 0x4F8; // bool
    constexpr std::ptrdiff_t m_bLoopActionSequence = 0x4F9; // bool
    constexpr std::ptrdiff_t m_bLoopPostIdleSequence = 0x4FA; // bool
    constexpr std::ptrdiff_t m_bSynchPostIdles = 0x4FB; // bool
    constexpr std::ptrdiff_t m_bIgnoreGravity = 0x4FC; // bool
    constexpr std::ptrdiff_t m_bDisableNPCCollisions = 0x4FD; // bool
    constexpr std::ptrdiff_t m_bKeepAnimgraphLockedPost = 0x4FE; // bool
    constexpr std::ptrdiff_t m_bDontAddModifiers = 0x4FF; // bool
    constexpr std::ptrdiff_t m_flRadius = 0x500; // float
    constexpr std::ptrdiff_t m_flRepeat = 0x504; // float
    constexpr std::ptrdiff_t m_flPlayAnimFadeInTime = 0x508; // float
    constexpr std::ptrdiff_t m_flMoveInterpTime = 0x50C; // float
    constexpr std::ptrdiff_t m_flAngRate = 0x510; // float
    constexpr std::ptrdiff_t m_iDelay = 0x514; // int32_t
    constexpr std::ptrdiff_t m_startTime = 0x518; // GameTime_t
    constexpr std::ptrdiff_t m_bWaitForBeginSequence = 0x51C; // bool
    constexpr std::ptrdiff_t m_saved_effects = 0x520; // int32_t
    constexpr std::ptrdiff_t m_savedFlags = 0x524; // int32_t
    constexpr std::ptrdiff_t m_savedCollisionGroup = 0x528; // int32_t
    constexpr std::ptrdiff_t m_interruptable = 0x52C; // bool
    constexpr std::ptrdiff_t m_sequenceStarted = 0x52D; // bool
    constexpr std::ptrdiff_t m_bPrevAnimatedEveryTick = 0x52E; // bool
    constexpr std::ptrdiff_t m_bForcedAnimatedEveryTick = 0x52F; // bool
    constexpr std::ptrdiff_t m_bPositionRelativeToOtherEntity = 0x530; // bool
    constexpr std::ptrdiff_t m_hTargetEnt = 0x534; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hNextCine = 0x538; // CHandle<CScriptedSequence>
    constexpr std::ptrdiff_t m_bThinking = 0x53C; // bool
    constexpr std::ptrdiff_t m_bInitiatedSelfDelete = 0x53D; // bool
    constexpr std::ptrdiff_t m_bIsTeleportingDueToMoveTo = 0x53E; // bool
    constexpr std::ptrdiff_t m_bAllowCustomInterruptConditions = 0x53F; // bool
    constexpr std::ptrdiff_t m_hLastFoundEntity = 0x540; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hForcedTarget = 0x544; // CHandle<CBaseAnimGraph>
    constexpr std::ptrdiff_t m_bDontCancelOtherSequences = 0x548; // bool
    constexpr std::ptrdiff_t m_bForceSynch = 0x549; // bool
    constexpr std::ptrdiff_t m_bTargetWasAsleep = 0x54A; // bool
    constexpr std::ptrdiff_t m_bPreventUpdateYawOnFinish = 0x54B; // bool
    constexpr std::ptrdiff_t m_bEnsureOnNavmeshOnFinish = 0x54C; // bool
    constexpr std::ptrdiff_t m_onDeathBehavior = 0x550; // ScriptedOnDeath_t
    constexpr std::ptrdiff_t m_ConflictResponse = 0x554; // ScriptedConflictResponse_t
    constexpr std::ptrdiff_t m_OnBeginSequence = 0x558; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnActionStartOrLoop = 0x580; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnEndSequence = 0x5A8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnPostIdleEndSequence = 0x5D0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnCancelSequence = 0x5F8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnCancelFailedSequence = 0x620; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnScriptEvent = 0x648; // CEntityIOOutput[8]
    constexpr std::ptrdiff_t m_matOtherToMain = 0x790; // CTransform
    constexpr std::ptrdiff_t m_hInteractionMainEntity = 0x7B0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iPlayerDeathBehavior = 0x7B4; // int32_t
}

namespace CSensorGrenadeProjectile {
    constexpr std::ptrdiff_t m_fExpireTime = 0xA40; // GameTime_t
    constexpr std::ptrdiff_t m_fNextDetectPlayerSound = 0xA44; // GameTime_t
    constexpr std::ptrdiff_t m_hDisplayGrenade = 0xA48; // CHandle<CBaseEntity>
}

namespace CShatterGlassShard {
    constexpr std::ptrdiff_t m_hShardHandle = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_vecPanelVertices = 0x10; // CUtlVector<Vector2D>
    constexpr std::ptrdiff_t m_vLocalPanelSpaceOrigin = 0x28; // Vector2D
    constexpr std::ptrdiff_t m_hModel = 0x30; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_hPhysicsEntity = 0x38; // CHandle<CShatterGlassShardPhysics>
    constexpr std::ptrdiff_t m_hParentPanel = 0x3C; // CHandle<CFuncShatterglass>
    constexpr std::ptrdiff_t m_hParentShard = 0x40; // uint32_t
    constexpr std::ptrdiff_t m_ShatterStressType = 0x44; // ShatterGlassStressType
    constexpr std::ptrdiff_t m_vecStressVelocity = 0x48; // Vector
    constexpr std::ptrdiff_t m_bCreatedModel = 0x54; // bool
    constexpr std::ptrdiff_t m_flLongestEdge = 0x58; // float
    constexpr std::ptrdiff_t m_flShortestEdge = 0x5C; // float
    constexpr std::ptrdiff_t m_flLongestAcross = 0x60; // float
    constexpr std::ptrdiff_t m_flShortestAcross = 0x64; // float
    constexpr std::ptrdiff_t m_flSumOfAllEdges = 0x68; // float
    constexpr std::ptrdiff_t m_flArea = 0x6C; // float
    constexpr std::ptrdiff_t m_nOnFrameEdge = 0x70; // OnFrame
    constexpr std::ptrdiff_t m_nParentPanelsNthShard = 0x74; // int32_t
    constexpr std::ptrdiff_t m_nSubShardGeneration = 0x78; // int32_t
    constexpr std::ptrdiff_t m_vecAverageVertPosition = 0x7C; // Vector2D
    constexpr std::ptrdiff_t m_bAverageVertPositionIsValid = 0x84; // bool
    constexpr std::ptrdiff_t m_vecPanelSpaceStressPositionA = 0x88; // Vector2D
    constexpr std::ptrdiff_t m_vecPanelSpaceStressPositionB = 0x90; // Vector2D
    constexpr std::ptrdiff_t m_bStressPositionAIsValid = 0x98; // bool
    constexpr std::ptrdiff_t m_bStressPositionBIsValid = 0x99; // bool
    constexpr std::ptrdiff_t m_bFlaggedForRemoval = 0x9A; // bool
    constexpr std::ptrdiff_t m_flPhysicsEntitySpawnedAtTime = 0x9C; // GameTime_t
    constexpr std::ptrdiff_t m_bShatterRateLimited = 0xA0; // bool
    constexpr std::ptrdiff_t m_hEntityHittingMe = 0xA4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_vecNeighbors = 0xA8; // CUtlVector<uint32_t>
}

namespace CShatterGlassShardPhysics {
    constexpr std::ptrdiff_t m_bDebris = 0xB78; // bool
    constexpr std::ptrdiff_t m_hParentShard = 0xB7C; // uint32_t
    constexpr std::ptrdiff_t m_ShardDesc = 0xB80; // shard_model_desc_t
}

namespace CSimTimer {
    constexpr std::ptrdiff_t m_interval = 0x8; // float
}

namespace CSimpleSimTimer {
    constexpr std::ptrdiff_t m_next = 0x0; // GameTime_t
    constexpr std::ptrdiff_t m_nWorldGroupId = 0x4; // WorldGroupId_t
}

namespace CSingleplayRules {
    constexpr std::ptrdiff_t m_bSinglePlayerGameEnding = 0x90; // bool
}

namespace CSkeletonAnimationController {
    constexpr std::ptrdiff_t m_pSkeletonInstance = 0x8; // CSkeletonInstance*
}

namespace CSkeletonInstance {
    constexpr std::ptrdiff_t m_modelState = 0x160; // CModelState
    constexpr std::ptrdiff_t m_bIsAnimationEnabled = 0x390; // bool
    constexpr std::ptrdiff_t m_bUseParentRenderBounds = 0x391; // bool
    constexpr std::ptrdiff_t m_bDisableSolidCollisionsForHierarchy = 0x392; // bool
    constexpr std::ptrdiff_t m_bDirtyMotionType = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bIsGeneratingLatchedParentSpaceState = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_materialGroup = 0x394; // CUtlStringToken
    constexpr std::ptrdiff_t m_nHitboxSet = 0x398; // uint8_t
}

namespace CSkillDamage {
    constexpr std::ptrdiff_t m_flDamage = 0x0; // CSkillFloat
    constexpr std::ptrdiff_t m_flPhysicsForceDamage = 0x10; // float
}

namespace CSkillFloat {
    constexpr std::ptrdiff_t m_pValue = 0x0; // float[4]
}

namespace CSkillInt {
    constexpr std::ptrdiff_t m_pValue = 0x0; // int32_t[4]
}

namespace CSkyCamera {
    constexpr std::ptrdiff_t m_skyboxData = 0x4B0; // sky3dparams_t
    constexpr std::ptrdiff_t m_skyboxSlotToken = 0x540; // CUtlStringToken
    constexpr std::ptrdiff_t m_bUseAngles = 0x544; // bool
    constexpr std::ptrdiff_t m_pNext = 0x548; // CSkyCamera*
}

namespace CSkyboxReference {
    constexpr std::ptrdiff_t m_worldGroupId = 0x4B0; // WorldGroupId_t
    constexpr std::ptrdiff_t m_hSkyCamera = 0x4B4; // CHandle<CSkyCamera>
}

namespace CSmokeGrenadeProjectile {
    constexpr std::ptrdiff_t m_nSmokeEffectTickBegin = 0xA58; // int32_t
    constexpr std::ptrdiff_t m_bDidSmokeEffect = 0xA5C; // bool
    constexpr std::ptrdiff_t m_nRandomSeed = 0xA60; // int32_t
    constexpr std::ptrdiff_t m_vSmokeColor = 0xA64; // Vector
    constexpr std::ptrdiff_t m_vSmokeDetonationPos = 0xA70; // Vector
    constexpr std::ptrdiff_t m_VoxelFrameData = 0xA80; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_flLastBounce = 0xA98; // GameTime_t
    constexpr std::ptrdiff_t m_fllastSimulationTime = 0xA9C; // GameTime_t
}

namespace CSmoothFunc {
    constexpr std::ptrdiff_t m_flSmoothAmplitude = 0x8; // float
    constexpr std::ptrdiff_t m_flSmoothBias = 0xC; // float
    constexpr std::ptrdiff_t m_flSmoothDuration = 0x10; // float
    constexpr std::ptrdiff_t m_flSmoothRemainingTime = 0x14; // float
    constexpr std::ptrdiff_t m_nSmoothDir = 0x18; // int32_t
}

namespace CSound {
    constexpr std::ptrdiff_t m_hOwner = 0x0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTarget = 0x4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iVolume = 0x8; // int32_t
    constexpr std::ptrdiff_t m_flOcclusionScale = 0xC; // float
    constexpr std::ptrdiff_t m_iType = 0x10; // int32_t
    constexpr std::ptrdiff_t m_iNextAudible = 0x14; // int32_t
    constexpr std::ptrdiff_t m_flExpireTime = 0x18; // GameTime_t
    constexpr std::ptrdiff_t m_iNext = 0x1C; // int16_t
    constexpr std::ptrdiff_t m_bNoExpirationTime = 0x1E; // bool
    constexpr std::ptrdiff_t m_ownerChannelIndex = 0x20; // int32_t
    constexpr std::ptrdiff_t m_vecOrigin = 0x24; // Vector
    constexpr std::ptrdiff_t m_bHasOwner = 0x30; // bool
}

namespace CSoundAreaEntityBase {
    constexpr std::ptrdiff_t m_bDisabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_iszSoundAreaType = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_vPos = 0x4C0; // Vector
}

namespace CSoundAreaEntityOrientedBox {
    constexpr std::ptrdiff_t m_vMin = 0x4D0; // Vector
    constexpr std::ptrdiff_t m_vMax = 0x4DC; // Vector
}

namespace CSoundAreaEntitySphere {
    constexpr std::ptrdiff_t m_flRadius = 0x4D0; // float
}

namespace CSoundEnt {
    constexpr std::ptrdiff_t m_iFreeSound = 0x4B0; // int32_t
    constexpr std::ptrdiff_t m_iActiveSound = 0x4B4; // int32_t
    constexpr std::ptrdiff_t m_cLastActiveSounds = 0x4B8; // int32_t
    constexpr std::ptrdiff_t m_SoundPool = 0x4BC; // CSound[128]
}

namespace CSoundEnvelope {
    constexpr std::ptrdiff_t m_current = 0x0; // float
    constexpr std::ptrdiff_t m_target = 0x4; // float
    constexpr std::ptrdiff_t m_rate = 0x8; // float
    constexpr std::ptrdiff_t m_forceupdate = 0xC; // bool
}

namespace CSoundEventAABBEntity {
    constexpr std::ptrdiff_t m_vMins = 0x558; // Vector
    constexpr std::ptrdiff_t m_vMaxs = 0x564; // Vector
}

namespace CSoundEventEntity {
    constexpr std::ptrdiff_t m_bStartOnSpawn = 0x4B0; // bool
    constexpr std::ptrdiff_t m_bToLocalPlayer = 0x4B1; // bool
    constexpr std::ptrdiff_t m_bStopOnNew = 0x4B2; // bool
    constexpr std::ptrdiff_t m_bSaveRestore = 0x4B3; // bool
    constexpr std::ptrdiff_t m_bSavedIsPlaying = 0x4B4; // bool
    constexpr std::ptrdiff_t m_flSavedElapsedTime = 0x4B8; // float
    constexpr std::ptrdiff_t m_iszSourceEntityName = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszAttachmentName = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_onGUIDChanged = 0x4D0; // CEntityOutputTemplate<uint64_t>
    constexpr std::ptrdiff_t m_onSoundFinished = 0x4F8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_iszSoundName = 0x540; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hSource = 0x550; // CEntityHandle
}

namespace CSoundEventOBBEntity {
    constexpr std::ptrdiff_t m_vMins = 0x558; // Vector
    constexpr std::ptrdiff_t m_vMaxs = 0x564; // Vector
}

namespace CSoundEventParameter {
    constexpr std::ptrdiff_t m_iszParamName = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flFloatValue = 0x4C0; // float
}

namespace CSoundEventPathCornerEntity {
    constexpr std::ptrdiff_t m_iszPathCorner = 0x558; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iCountMax = 0x560; // int32_t
    constexpr std::ptrdiff_t m_flDistanceMax = 0x564; // float
    constexpr std::ptrdiff_t m_flDistMaxSqr = 0x568; // float
    constexpr std::ptrdiff_t m_flDotProductMax = 0x56C; // float
    constexpr std::ptrdiff_t bPlaying = 0x570; // bool
}

namespace CSoundOpvarSetAABBEntity {
    constexpr std::ptrdiff_t m_vDistanceInnerMins = 0x648; // Vector
    constexpr std::ptrdiff_t m_vDistanceInnerMaxs = 0x654; // Vector
    constexpr std::ptrdiff_t m_vDistanceOuterMins = 0x660; // Vector
    constexpr std::ptrdiff_t m_vDistanceOuterMaxs = 0x66C; // Vector
    constexpr std::ptrdiff_t m_nAABBDirection = 0x678; // int32_t
    constexpr std::ptrdiff_t m_vInnerMins = 0x67C; // Vector
    constexpr std::ptrdiff_t m_vInnerMaxs = 0x688; // Vector
    constexpr std::ptrdiff_t m_vOuterMins = 0x694; // Vector
    constexpr std::ptrdiff_t m_vOuterMaxs = 0x6A0; // Vector
}

namespace CSoundOpvarSetEntity {
    constexpr std::ptrdiff_t m_iszStackName = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszOperatorName = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszOpvarName = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nOpvarType = 0x4D0; // int32_t
    constexpr std::ptrdiff_t m_nOpvarIndex = 0x4D4; // int32_t
    constexpr std::ptrdiff_t m_flOpvarValue = 0x4D8; // float
    constexpr std::ptrdiff_t m_OpvarValueString = 0x4E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bSetOnSpawn = 0x4E8; // bool
}

namespace CSoundOpvarSetOBBWindEntity {
    constexpr std::ptrdiff_t m_vMins = 0x548; // Vector
    constexpr std::ptrdiff_t m_vMaxs = 0x554; // Vector
    constexpr std::ptrdiff_t m_vDistanceMins = 0x560; // Vector
    constexpr std::ptrdiff_t m_vDistanceMaxs = 0x56C; // Vector
    constexpr std::ptrdiff_t m_flWindMin = 0x578; // float
    constexpr std::ptrdiff_t m_flWindMax = 0x57C; // float
    constexpr std::ptrdiff_t m_flWindMapMin = 0x580; // float
    constexpr std::ptrdiff_t m_flWindMapMax = 0x584; // float
}

namespace CSoundOpvarSetPathCornerEntity {
    constexpr std::ptrdiff_t m_flDistMinSqr = 0x660; // float
    constexpr std::ptrdiff_t m_flDistMaxSqr = 0x664; // float
    constexpr std::ptrdiff_t m_iszPathCornerEntityName = 0x668; // CUtlSymbolLarge
}

namespace CSoundOpvarSetPointBase {
    constexpr std::ptrdiff_t m_bDisabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_hSource = 0x4B4; // CEntityHandle
    constexpr std::ptrdiff_t m_iszSourceEntityName = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_vLastPosition = 0x518; // Vector
    constexpr std::ptrdiff_t m_iszStackName = 0x528; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszOperatorName = 0x530; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszOpvarName = 0x538; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iOpvarIndex = 0x540; // int32_t
    constexpr std::ptrdiff_t m_bUseAutoCompare = 0x544; // bool
}

namespace CSoundOpvarSetPointEntity {
    constexpr std::ptrdiff_t m_OnEnter = 0x548; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnExit = 0x570; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bAutoDisable = 0x598; // bool
    constexpr std::ptrdiff_t m_flDistanceMin = 0x5DC; // float
    constexpr std::ptrdiff_t m_flDistanceMax = 0x5E0; // float
    constexpr std::ptrdiff_t m_flDistanceMapMin = 0x5E4; // float
    constexpr std::ptrdiff_t m_flDistanceMapMax = 0x5E8; // float
    constexpr std::ptrdiff_t m_flOcclusionRadius = 0x5EC; // float
    constexpr std::ptrdiff_t m_flOcclusionMin = 0x5F0; // float
    constexpr std::ptrdiff_t m_flOcclusionMax = 0x5F4; // float
    constexpr std::ptrdiff_t m_flValSetOnDisable = 0x5F8; // float
    constexpr std::ptrdiff_t m_bSetValueOnDisable = 0x5FC; // bool
    constexpr std::ptrdiff_t m_nSimulationMode = 0x600; // int32_t
    constexpr std::ptrdiff_t m_nVisibilitySamples = 0x604; // int32_t
    constexpr std::ptrdiff_t m_vDynamicProxyPoint = 0x608; // Vector
    constexpr std::ptrdiff_t m_flDynamicMaximumOcclusion = 0x614; // float
    constexpr std::ptrdiff_t m_hDynamicEntity = 0x618; // CEntityHandle
    constexpr std::ptrdiff_t m_iszDynamicEntityName = 0x620; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flPathingDistanceNormFactor = 0x628; // float
    constexpr std::ptrdiff_t m_vPathingSourcePos = 0x62C; // Vector
    constexpr std::ptrdiff_t m_vPathingListenerPos = 0x638; // Vector
    constexpr std::ptrdiff_t m_nPathingSourceIndex = 0x644; // int32_t
}

namespace CSoundPatch {
    constexpr std::ptrdiff_t m_pitch = 0x8; // CSoundEnvelope
    constexpr std::ptrdiff_t m_volume = 0x18; // CSoundEnvelope
    constexpr std::ptrdiff_t m_shutdownTime = 0x30; // float
    constexpr std::ptrdiff_t m_flLastTime = 0x34; // float
    constexpr std::ptrdiff_t m_iszSoundScriptName = 0x38; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hEnt = 0x40; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_soundEntityIndex = 0x44; // CEntityIndex
    constexpr std::ptrdiff_t m_soundOrigin = 0x48; // Vector
    constexpr std::ptrdiff_t m_isPlaying = 0x54; // int32_t
    constexpr std::ptrdiff_t m_Filter = 0x58; // CCopyRecipientFilter
    constexpr std::ptrdiff_t m_flCloseCaptionDuration = 0x80; // float
    constexpr std::ptrdiff_t m_bUpdatedSoundOrigin = 0x84; // bool
    constexpr std::ptrdiff_t m_iszClassName = 0x88; // CUtlSymbolLarge
}

namespace CSoundStackSave {
    constexpr std::ptrdiff_t m_iszStackName = 0x4B0; // CUtlSymbolLarge
}

namespace CSpotlightEnd {
    constexpr std::ptrdiff_t m_flLightScale = 0x700; // float
    constexpr std::ptrdiff_t m_Radius = 0x704; // float
    constexpr std::ptrdiff_t m_vSpotlightDir = 0x708; // Vector
    constexpr std::ptrdiff_t m_vSpotlightOrg = 0x714; // Vector
}

namespace CSprite {
    constexpr std::ptrdiff_t m_hSpriteMaterial = 0x700; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_hAttachedToEntity = 0x708; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_nAttachment = 0x70C; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_flSpriteFramerate = 0x710; // float
    constexpr std::ptrdiff_t m_flFrame = 0x714; // float
    constexpr std::ptrdiff_t m_flDieTime = 0x718; // GameTime_t
    constexpr std::ptrdiff_t m_nBrightness = 0x728; // uint32_t
    constexpr std::ptrdiff_t m_flBrightnessDuration = 0x72C; // float
    constexpr std::ptrdiff_t m_flSpriteScale = 0x730; // float
    constexpr std::ptrdiff_t m_flScaleDuration = 0x734; // float
    constexpr std::ptrdiff_t m_bWorldSpaceScale = 0x738; // bool
    constexpr std::ptrdiff_t m_flGlowProxySize = 0x73C; // float
    constexpr std::ptrdiff_t m_flHDRColorScale = 0x740; // float
    constexpr std::ptrdiff_t m_flLastTime = 0x744; // GameTime_t
    constexpr std::ptrdiff_t m_flMaxFrame = 0x748; // float
    constexpr std::ptrdiff_t m_flStartScale = 0x74C; // float
    constexpr std::ptrdiff_t m_flDestScale = 0x750; // float
    constexpr std::ptrdiff_t m_flScaleTimeStart = 0x754; // GameTime_t
    constexpr std::ptrdiff_t m_nStartBrightness = 0x758; // int32_t
    constexpr std::ptrdiff_t m_nDestBrightness = 0x75C; // int32_t
    constexpr std::ptrdiff_t m_flBrightnessTimeStart = 0x760; // GameTime_t
    constexpr std::ptrdiff_t m_nSpriteWidth = 0x764; // int32_t
    constexpr std::ptrdiff_t m_nSpriteHeight = 0x768; // int32_t
}

namespace CStopwatch {
    constexpr std::ptrdiff_t m_interval = 0xC; // float
}

namespace CStopwatchBase {
    constexpr std::ptrdiff_t m_fIsRunning = 0x8; // bool
}

namespace CSun {
    constexpr std::ptrdiff_t m_vDirection = 0x700; // Vector
    constexpr std::ptrdiff_t m_clrOverlay = 0x70C; // Color
    constexpr std::ptrdiff_t m_iszEffectName = 0x710; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSSEffectName = 0x718; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bOn = 0x720; // bool
    constexpr std::ptrdiff_t m_bmaxColor = 0x721; // bool
    constexpr std::ptrdiff_t m_flSize = 0x724; // float
    constexpr std::ptrdiff_t m_flRotation = 0x728; // float
    constexpr std::ptrdiff_t m_flHazeScale = 0x72C; // float
    constexpr std::ptrdiff_t m_flAlphaHaze = 0x730; // float
    constexpr std::ptrdiff_t m_flAlphaHdr = 0x734; // float
    constexpr std::ptrdiff_t m_flAlphaScale = 0x738; // float
    constexpr std::ptrdiff_t m_flHDRColorScale = 0x73C; // float
    constexpr std::ptrdiff_t m_flFarZScale = 0x740; // float
}

namespace CTakeDamageInfo {
    constexpr std::ptrdiff_t m_vecDamageForce = 0x8; // Vector
    constexpr std::ptrdiff_t m_vecDamagePosition = 0x14; // Vector
    constexpr std::ptrdiff_t m_vecReportedPosition = 0x20; // Vector
    constexpr std::ptrdiff_t m_vecDamageDirection = 0x2C; // Vector
    constexpr std::ptrdiff_t m_hInflictor = 0x38; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hAttacker = 0x3C; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hAbility = 0x40; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_flDamage = 0x44; // float
    constexpr std::ptrdiff_t m_bitsDamageType = 0x48; // int32_t
    constexpr std::ptrdiff_t m_iDamageCustom = 0x4C; // int32_t
    constexpr std::ptrdiff_t m_iAmmoType = 0x50; // AmmoIndex_t
    constexpr std::ptrdiff_t m_flOriginalDamage = 0x60; // float
    constexpr std::ptrdiff_t m_bShouldBleed = 0x64; // bool
    constexpr std::ptrdiff_t m_bShouldSpark = 0x65; // bool
    constexpr std::ptrdiff_t m_nDamageFlags = 0x70; // TakeDamageFlags_t
    constexpr std::ptrdiff_t m_nNumObjectsPenetrated = 0x74; // int32_t
    constexpr std::ptrdiff_t m_hScriptInstance = 0x78; // HSCRIPT
    constexpr std::ptrdiff_t m_bInTakeDamageFlow = 0x94; // bool
}

namespace CTakeDamageResult {
    constexpr std::ptrdiff_t m_nHealthLost = 0x0; // int32_t
    constexpr std::ptrdiff_t m_nDamageTaken = 0x4; // int32_t
}

namespace CTakeDamageSummaryScopeGuard {
    constexpr std::ptrdiff_t m_vecSummaries = 0x8; // CUtlVector<SummaryTakeDamageInfo_t*>
}

namespace CTankTargetChange {
    constexpr std::ptrdiff_t m_newTarget = 0x4B0; // CVariantBase<CVariantDefaultAllocator>
    constexpr std::ptrdiff_t m_newTargetName = 0x4C0; // CUtlSymbolLarge
}

namespace CTankTrainAI {
    constexpr std::ptrdiff_t m_hTrain = 0x4B0; // CHandle<CFuncTrackTrain>
    constexpr std::ptrdiff_t m_hTargetEntity = 0x4B4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_soundPlaying = 0x4B8; // int32_t
    constexpr std::ptrdiff_t m_startSoundName = 0x4D0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_engineSoundName = 0x4D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_movementSoundName = 0x4E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_targetEntityName = 0x4E8; // CUtlSymbolLarge
}

namespace CTeam {
    constexpr std::ptrdiff_t m_aPlayerControllers = 0x4B0; // CNetworkUtlVectorBase<CHandle<CBasePlayerController>>
    constexpr std::ptrdiff_t m_aPlayers = 0x4C8; // CNetworkUtlVectorBase<CHandle<CBasePlayerPawn>>
    constexpr std::ptrdiff_t m_iScore = 0x4E0; // int32_t
    constexpr std::ptrdiff_t m_szTeamname = 0x4E4; // char[129]
}

namespace CTestEffect {
    constexpr std::ptrdiff_t m_iLoop = 0x4B0; // int32_t
    constexpr std::ptrdiff_t m_iBeam = 0x4B4; // int32_t
    constexpr std::ptrdiff_t m_pBeam = 0x4B8; // CBeam*[24]
    constexpr std::ptrdiff_t m_flBeamTime = 0x578; // GameTime_t[24]
    constexpr std::ptrdiff_t m_flStartTime = 0x5D8; // GameTime_t
}

namespace CTextureBasedAnimatable {
    constexpr std::ptrdiff_t m_bLoop = 0x700; // bool
    constexpr std::ptrdiff_t m_flFPS = 0x704; // float
    constexpr std::ptrdiff_t m_hPositionKeys = 0x708; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hRotationKeys = 0x710; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_vAnimationBoundsMin = 0x718; // Vector
    constexpr std::ptrdiff_t m_vAnimationBoundsMax = 0x724; // Vector
    constexpr std::ptrdiff_t m_flStartTime = 0x730; // float
    constexpr std::ptrdiff_t m_flStartFrame = 0x734; // float
}

namespace CTimeline {
    constexpr std::ptrdiff_t m_flValues = 0x10; // float[64]
    constexpr std::ptrdiff_t m_nValueCounts = 0x110; // int32_t[64]
    constexpr std::ptrdiff_t m_nBucketCount = 0x210; // int32_t
    constexpr std::ptrdiff_t m_flInterval = 0x214; // float
    constexpr std::ptrdiff_t m_flFinalValue = 0x218; // float
    constexpr std::ptrdiff_t m_nCompressionType = 0x21C; // TimelineCompression_t
    constexpr std::ptrdiff_t m_bStopped = 0x220; // bool
}

namespace CTimerEntity {
    constexpr std::ptrdiff_t m_OnTimer = 0x4B0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnTimerHigh = 0x4D8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnTimerLow = 0x500; // CEntityIOOutput
    constexpr std::ptrdiff_t m_iDisabled = 0x528; // int32_t
    constexpr std::ptrdiff_t m_flInitialDelay = 0x52C; // float
    constexpr std::ptrdiff_t m_flRefireTime = 0x530; // float
    constexpr std::ptrdiff_t m_bUpDownState = 0x534; // bool
    constexpr std::ptrdiff_t m_iUseRandomTime = 0x538; // int32_t
    constexpr std::ptrdiff_t m_bPauseAfterFiring = 0x53C; // bool
    constexpr std::ptrdiff_t m_flLowerRandomBound = 0x540; // float
    constexpr std::ptrdiff_t m_flUpperRandomBound = 0x544; // float
    constexpr std::ptrdiff_t m_flRemainingTime = 0x548; // float
    constexpr std::ptrdiff_t m_bPaused = 0x54C; // bool
}

namespace CTonemapController2 {
    constexpr std::ptrdiff_t m_flAutoExposureMin = 0x4B0; // float
    constexpr std::ptrdiff_t m_flAutoExposureMax = 0x4B4; // float
    constexpr std::ptrdiff_t m_flTonemapPercentTarget = 0x4B8; // float
    constexpr std::ptrdiff_t m_flTonemapPercentBrightPixels = 0x4BC; // float
    constexpr std::ptrdiff_t m_flTonemapMinAvgLum = 0x4C0; // float
    constexpr std::ptrdiff_t m_flExposureAdaptationSpeedUp = 0x4C4; // float
    constexpr std::ptrdiff_t m_flExposureAdaptationSpeedDown = 0x4C8; // float
    constexpr std::ptrdiff_t m_flTonemapEVSmoothingRange = 0x4CC; // float
}

namespace CTonemapTrigger {
    constexpr std::ptrdiff_t m_tonemapControllerName = 0x8A8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hTonemapController = 0x8B0; // CEntityHandle
}

namespace CTriggerActiveWeaponDetect {
    constexpr std::ptrdiff_t m_OnTouchedActiveWeapon = 0x8A8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_iszWeaponClassName = 0x8D0; // CUtlSymbolLarge
}

namespace CTriggerBrush {
    constexpr std::ptrdiff_t m_OnStartTouch = 0x700; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnEndTouch = 0x728; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnUse = 0x750; // CEntityIOOutput
    constexpr std::ptrdiff_t m_iInputFilter = 0x778; // int32_t
    constexpr std::ptrdiff_t m_iDontMessageParent = 0x77C; // int32_t
}

namespace CTriggerBuoyancy {
    constexpr std::ptrdiff_t m_BuoyancyHelper = 0x8A8; // CBuoyancyHelper
    constexpr std::ptrdiff_t m_flFluidDensity = 0x8C8; // float
}

namespace CTriggerDetectBulletFire {
    constexpr std::ptrdiff_t m_bPlayerFireOnly = 0x8A8; // bool
    constexpr std::ptrdiff_t m_OnDetectedBulletFire = 0x8B0; // CEntityIOOutput
}

namespace CTriggerDetectExplosion {
    constexpr std::ptrdiff_t m_OnDetectedExplosion = 0x8E0; // CEntityIOOutput
}

namespace CTriggerFan {
    constexpr std::ptrdiff_t m_vFanOrigin = 0x8A8; // Vector
    constexpr std::ptrdiff_t m_vFanEnd = 0x8B4; // Vector
    constexpr std::ptrdiff_t m_vNoise = 0x8C0; // Vector
    constexpr std::ptrdiff_t m_flForce = 0x8CC; // float
    constexpr std::ptrdiff_t m_flPlayerForce = 0x8D0; // float
    constexpr std::ptrdiff_t m_flRampTime = 0x8D4; // float
    constexpr std::ptrdiff_t m_bFalloff = 0x8D8; // bool
    constexpr std::ptrdiff_t m_bPushPlayer = 0x8D9; // bool
    constexpr std::ptrdiff_t m_bRampDown = 0x8DA; // bool
    constexpr std::ptrdiff_t m_bAddNoise = 0x8DB; // bool
    constexpr std::ptrdiff_t m_RampTimer = 0x8E0; // CountdownTimer
}

namespace CTriggerGameEvent {
    constexpr std::ptrdiff_t m_strStartTouchEventName = 0x8A8; // CUtlString
    constexpr std::ptrdiff_t m_strEndTouchEventName = 0x8B0; // CUtlString
    constexpr std::ptrdiff_t m_strTriggerID = 0x8B8; // CUtlString
}

namespace CTriggerHurt {
    constexpr std::ptrdiff_t m_flOriginalDamage = 0x8A8; // float
    constexpr std::ptrdiff_t m_flDamage = 0x8AC; // float
    constexpr std::ptrdiff_t m_flDamageCap = 0x8B0; // float
    constexpr std::ptrdiff_t m_flLastDmgTime = 0x8B4; // GameTime_t
    constexpr std::ptrdiff_t m_flForgivenessDelay = 0x8B8; // float
    constexpr std::ptrdiff_t m_bitsDamageInflict = 0x8BC; // int32_t
    constexpr std::ptrdiff_t m_damageModel = 0x8C0; // int32_t
    constexpr std::ptrdiff_t m_bNoDmgForce = 0x8C4; // bool
    constexpr std::ptrdiff_t m_vDamageForce = 0x8C8; // Vector
    constexpr std::ptrdiff_t m_thinkAlways = 0x8D4; // bool
    constexpr std::ptrdiff_t m_hurtThinkPeriod = 0x8D8; // float
    constexpr std::ptrdiff_t m_OnHurt = 0x8E0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnHurtPlayer = 0x908; // CEntityIOOutput
    constexpr std::ptrdiff_t m_hurtEntities = 0x930; // CUtlVector<CHandle<CBaseEntity>>
}

namespace CTriggerImpact {
    constexpr std::ptrdiff_t m_flMagnitude = 0x8D0; // float
    constexpr std::ptrdiff_t m_flNoise = 0x8D4; // float
    constexpr std::ptrdiff_t m_flViewkick = 0x8D8; // float
    constexpr std::ptrdiff_t m_pOutputForce = 0x8E0; // CEntityOutputTemplate<Vector>
}

namespace CTriggerLerpObject {
    constexpr std::ptrdiff_t m_iszLerpTarget = 0x8A8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hLerpTarget = 0x8B0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iszLerpTargetAttachment = 0x8B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hLerpTargetAttachment = 0x8C0; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_flLerpDuration = 0x8C4; // float
    constexpr std::ptrdiff_t m_bLerpRestoreMoveType = 0x8C8; // bool
    constexpr std::ptrdiff_t m_bSingleLerpObject = 0x8C9; // bool
    constexpr std::ptrdiff_t m_vecLerpingObjects = 0x8D0; // CUtlVector<lerpdata_t>
    constexpr std::ptrdiff_t m_iszLerpEffect = 0x8E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszLerpSound = 0x8F0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_OnLerpStarted = 0x8F8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnLerpFinished = 0x920; // CEntityIOOutput
}

namespace CTriggerLook {
    constexpr std::ptrdiff_t m_hLookTarget = 0x8D0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_flFieldOfView = 0x8D4; // float
    constexpr std::ptrdiff_t m_flLookTime = 0x8D8; // float
    constexpr std::ptrdiff_t m_flLookTimeTotal = 0x8DC; // float
    constexpr std::ptrdiff_t m_flLookTimeLast = 0x8E0; // GameTime_t
    constexpr std::ptrdiff_t m_flTimeoutDuration = 0x8E4; // float
    constexpr std::ptrdiff_t m_bTimeoutFired = 0x8E8; // bool
    constexpr std::ptrdiff_t m_bIsLooking = 0x8E9; // bool
    constexpr std::ptrdiff_t m_b2DFOV = 0x8EA; // bool
    constexpr std::ptrdiff_t m_bUseVelocity = 0x8EB; // bool
    constexpr std::ptrdiff_t m_hActivator = 0x8EC; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bTestOcclusion = 0x8F0; // bool
    constexpr std::ptrdiff_t m_OnTimeout = 0x8F8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnStartLook = 0x920; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnEndLook = 0x948; // CEntityIOOutput
}

namespace CTriggerMultiple {
    constexpr std::ptrdiff_t m_OnTrigger = 0x8A8; // CEntityIOOutput
}

namespace CTriggerPhysics {
    constexpr std::ptrdiff_t m_gravityScale = 0x8B8; // float
    constexpr std::ptrdiff_t m_linearLimit = 0x8BC; // float
    constexpr std::ptrdiff_t m_linearDamping = 0x8C0; // float
    constexpr std::ptrdiff_t m_angularLimit = 0x8C4; // float
    constexpr std::ptrdiff_t m_angularDamping = 0x8C8; // float
    constexpr std::ptrdiff_t m_linearForce = 0x8CC; // float
    constexpr std::ptrdiff_t m_flFrequency = 0x8D0; // float
    constexpr std::ptrdiff_t m_flDampingRatio = 0x8D4; // float
    constexpr std::ptrdiff_t m_vecLinearForcePointAt = 0x8D8; // Vector
    constexpr std::ptrdiff_t m_bCollapseToForcePoint = 0x8E4; // bool
    constexpr std::ptrdiff_t m_vecLinearForcePointAtWorld = 0x8E8; // Vector
    constexpr std::ptrdiff_t m_vecLinearForceDirection = 0x8F4; // Vector
    constexpr std::ptrdiff_t m_bConvertToDebrisWhenPossible = 0x900; // bool
}

namespace CTriggerProximity {
    constexpr std::ptrdiff_t m_hMeasureTarget = 0x8A8; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iszMeasureTarget = 0x8B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_fRadius = 0x8B8; // float
    constexpr std::ptrdiff_t m_nTouchers = 0x8BC; // int32_t
    constexpr std::ptrdiff_t m_NearestEntityDistance = 0x8C0; // CEntityOutputTemplate<float>
}

namespace CTriggerPush {
    constexpr std::ptrdiff_t m_angPushEntitySpace = 0x8A8; // QAngle
    constexpr std::ptrdiff_t m_vecPushDirEntitySpace = 0x8B4; // Vector
    constexpr std::ptrdiff_t m_bTriggerOnStartTouch = 0x8C0; // bool
    constexpr std::ptrdiff_t m_flAlternateTicksFix = 0x8C4; // float
    constexpr std::ptrdiff_t m_flPushSpeed = 0x8C8; // float
}

namespace CTriggerRemove {
    constexpr std::ptrdiff_t m_OnRemove = 0x8A8; // CEntityIOOutput
}

namespace CTriggerSave {
    constexpr std::ptrdiff_t m_bForceNewLevelUnit = 0x8A8; // bool
    constexpr std::ptrdiff_t m_fDangerousTimer = 0x8AC; // float
    constexpr std::ptrdiff_t m_minHitPoints = 0x8B0; // int32_t
}

namespace CTriggerSndSosOpvar {
    constexpr std::ptrdiff_t m_hTouchingPlayers = 0x8A8; // CUtlVector<CHandle<CBaseEntity>>
    constexpr std::ptrdiff_t m_flPosition = 0x8C0; // Vector
    constexpr std::ptrdiff_t m_flCenterSize = 0x8CC; // float
    constexpr std::ptrdiff_t m_flMinVal = 0x8D0; // float
    constexpr std::ptrdiff_t m_flMaxVal = 0x8D4; // float
    constexpr std::ptrdiff_t m_flWait = 0x8D8; // float
    constexpr std::ptrdiff_t m_opvarName = 0x8E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_stackName = 0x8E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_operatorName = 0x8F0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bVolIs2D = 0x8F8; // bool
    constexpr std::ptrdiff_t m_opvarNameChar = 0x8F9; // char[256]
    constexpr std::ptrdiff_t m_stackNameChar = 0x9F9; // char[256]
    constexpr std::ptrdiff_t m_operatorNameChar = 0xAF9; // char[256]
    constexpr std::ptrdiff_t m_VecNormPos = 0xBFC; // Vector
    constexpr std::ptrdiff_t m_flNormCenterSize = 0xC08; // float
}

namespace CTriggerSoundscape {
    constexpr std::ptrdiff_t m_hSoundscape = 0x8A8; // CHandle<CEnvSoundscapeTriggerable>
    constexpr std::ptrdiff_t m_SoundscapeName = 0x8B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_spectators = 0x8B8; // CUtlVector<CHandle<CBasePlayerPawn>>
}

namespace CTriggerTeleport {
    constexpr std::ptrdiff_t m_iLandmark = 0x8A8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bUseLandmarkAngles = 0x8B0; // bool
    constexpr std::ptrdiff_t m_bMirrorPlayer = 0x8B1; // bool
}

namespace CTriggerToggleSave {
    constexpr std::ptrdiff_t m_bDisabled = 0x8A8; // bool
}

namespace CTriggerVolume {
    constexpr std::ptrdiff_t m_iFilterName = 0x700; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hFilter = 0x708; // CHandle<CBaseFilter>
}

namespace CVoteController {
    constexpr std::ptrdiff_t m_iActiveIssueIndex = 0x4B0; // int32_t
    constexpr std::ptrdiff_t m_iOnlyTeamToVote = 0x4B4; // int32_t
    constexpr std::ptrdiff_t m_nVoteOptionCount = 0x4B8; // int32_t[5]
    constexpr std::ptrdiff_t m_nPotentialVotes = 0x4CC; // int32_t
    constexpr std::ptrdiff_t m_bIsYesNoVote = 0x4D0; // bool
    constexpr std::ptrdiff_t m_acceptingVotesTimer = 0x4D8; // CountdownTimer
    constexpr std::ptrdiff_t m_executeCommandTimer = 0x4F0; // CountdownTimer
    constexpr std::ptrdiff_t m_resetVoteTimer = 0x508; // CountdownTimer
    constexpr std::ptrdiff_t m_nVotesCast = 0x520; // int32_t[64]
    constexpr std::ptrdiff_t m_playerHoldingVote = 0x620; // CPlayerSlot
    constexpr std::ptrdiff_t m_playerOverrideForVote = 0x624; // CPlayerSlot
    constexpr std::ptrdiff_t m_nHighestCountIndex = 0x628; // int32_t
    constexpr std::ptrdiff_t m_potentialIssues = 0x630; // CUtlVector<CBaseIssue*>
    constexpr std::ptrdiff_t m_VoteOptions = 0x648; // CUtlVector<char*>
}

namespace CWeaponBaseItem {
    constexpr std::ptrdiff_t m_SequenceCompleteTimer = 0xE20; // CountdownTimer
    constexpr std::ptrdiff_t m_bRedraw = 0xE38; // bool
}

namespace CWeaponShield {
    constexpr std::ptrdiff_t m_flBulletDamageAbsorbed = 0xE40; // float
    constexpr std::ptrdiff_t m_flLastBulletHitSoundTime = 0xE44; // GameTime_t
    constexpr std::ptrdiff_t m_flDisplayHealth = 0xE48; // float
}

namespace CWeaponTaser {
    constexpr std::ptrdiff_t m_fFireTime = 0xE40; // GameTime_t
}

namespace CommandToolCommand_t {
    constexpr std::ptrdiff_t m_bEnabled = 0x0; // bool
    constexpr std::ptrdiff_t m_bOpened = 0x1; // bool
    constexpr std::ptrdiff_t m_InternalId = 0x4; // uint32_t
    constexpr std::ptrdiff_t m_ShortName = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_ExecMode = 0x10; // CommandExecMode_t
    constexpr std::ptrdiff_t m_SpawnGroup = 0x18; // CUtlString
    constexpr std::ptrdiff_t m_PeriodicExecDelay = 0x20; // float
    constexpr std::ptrdiff_t m_SpecType = 0x24; // CommandEntitySpecType_t
    constexpr std::ptrdiff_t m_EntitySpec = 0x28; // CUtlString
    constexpr std::ptrdiff_t m_Commands = 0x30; // CUtlString
    constexpr std::ptrdiff_t m_SetDebugBits = 0x38; // DebugOverlayBits_t
    constexpr std::ptrdiff_t m_ClearDebugBits = 0x40; // DebugOverlayBits_t
}

namespace ConceptHistory_t {
    constexpr std::ptrdiff_t timeSpoken = 0x0; // float
    constexpr std::ptrdiff_t m_response = 0x8; // CRR_Response
}

namespace ConstraintSoundInfo {
    constexpr std::ptrdiff_t m_vSampler = 0x8; // VelocitySampler
    constexpr std::ptrdiff_t m_soundProfile = 0x20; // SimpleConstraintSoundProfile
    constexpr std::ptrdiff_t m_forwardAxis = 0x40; // Vector
    constexpr std::ptrdiff_t m_iszTravelSoundFwd = 0x50; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszTravelSoundBack = 0x58; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszReversalSounds = 0x68; // CUtlSymbolLarge[3]
    constexpr std::ptrdiff_t m_bPlayTravelSound = 0x80; // bool
    constexpr std::ptrdiff_t m_bPlayReversalSound = 0x81; // bool
}

namespace CountdownTimer {
    constexpr std::ptrdiff_t m_duration = 0x8; // float
    constexpr std::ptrdiff_t m_timestamp = 0xC; // GameTime_t
    constexpr std::ptrdiff_t m_timescale = 0x10; // float
    constexpr std::ptrdiff_t m_nWorldGroupId = 0x14; // WorldGroupId_t
}

namespace EngineCountdownTimer {
    constexpr std::ptrdiff_t m_duration = 0x8; // float
    constexpr std::ptrdiff_t m_timestamp = 0xC; // float
    constexpr std::ptrdiff_t m_timescale = 0x10; // float
}

namespace EntityRenderAttribute_t {
    constexpr std::ptrdiff_t m_ID = 0x30; // CUtlStringToken
    constexpr std::ptrdiff_t m_Values = 0x34; // Vector4D
}

namespace EntitySpottedState_t {
    constexpr std::ptrdiff_t m_bSpotted = 0x8; // bool
    constexpr std::ptrdiff_t m_bSpottedByMask = 0xC; // uint32_t[2]
}

namespace Extent {
    constexpr std::ptrdiff_t lo = 0x0; // Vector
    constexpr std::ptrdiff_t hi = 0xC; // Vector
}

namespace FilterDamageType {
    constexpr std::ptrdiff_t m_iDamageType = 0x508; // int32_t
}

namespace FilterHealth {
    constexpr std::ptrdiff_t m_bAdrenalineActive = 0x508; // bool
    constexpr std::ptrdiff_t m_iHealthMin = 0x50C; // int32_t
    constexpr std::ptrdiff_t m_iHealthMax = 0x510; // int32_t
}

namespace FilterTeam {
    constexpr std::ptrdiff_t m_iFilterTeam = 0x508; // int32_t
}

namespace GameAmmoTypeInfo_t {
    constexpr std::ptrdiff_t m_nBuySize = 0x38; // int32_t
    constexpr std::ptrdiff_t m_nCost = 0x3C; // int32_t
}

namespace GameTick_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace GameTime_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // float
}

namespace HullFlags_t {
    constexpr std::ptrdiff_t m_bHull_Human = 0x0; // bool
    constexpr std::ptrdiff_t m_bHull_SmallCentered = 0x1; // bool
    constexpr std::ptrdiff_t m_bHull_WideHuman = 0x2; // bool
    constexpr std::ptrdiff_t m_bHull_Tiny = 0x3; // bool
    constexpr std::ptrdiff_t m_bHull_Medium = 0x4; // bool
    constexpr std::ptrdiff_t m_bHull_TinyCentered = 0x5; // bool
    constexpr std::ptrdiff_t m_bHull_Large = 0x6; // bool
    constexpr std::ptrdiff_t m_bHull_LargeCentered = 0x7; // bool
    constexpr std::ptrdiff_t m_bHull_MediumTall = 0x8; // bool
    constexpr std::ptrdiff_t m_bHull_Small = 0x9; // bool
}

namespace IntervalTimer {
    constexpr std::ptrdiff_t m_timestamp = 0x8; // GameTime_t
    constexpr std::ptrdiff_t m_nWorldGroupId = 0xC; // WorldGroupId_t
}

namespace ModelConfigHandle_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // uint32_t
}

namespace ParticleIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace PhysicsRagdollPose_t {
    constexpr std::ptrdiff_t __m_pChainEntity = 0x8; // CNetworkVarChainer
    constexpr std::ptrdiff_t m_Transforms = 0x30; // CNetworkUtlVectorBase<CTransform>
    constexpr std::ptrdiff_t m_hOwner = 0x48; // CHandle<CBaseEntity>
}

namespace RagdollCreationParams_t {
    constexpr std::ptrdiff_t m_vForce = 0x0; // Vector
    constexpr std::ptrdiff_t m_nForceBone = 0xC; // int32_t
}

namespace RelationshipOverride_t {
    constexpr std::ptrdiff_t entity = 0x8; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t classType = 0xC; // Class_T
}

namespace Relationship_t {
    constexpr std::ptrdiff_t disposition = 0x0; // Disposition_t
    constexpr std::ptrdiff_t priority = 0x4; // int32_t
}

namespace ResponseContext_t {
    constexpr std::ptrdiff_t m_iszName = 0x0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszValue = 0x8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_fExpirationTime = 0x10; // GameTime_t
}

namespace ResponseFollowup {
    constexpr std::ptrdiff_t followup_concept = 0x0; // char*
    constexpr std::ptrdiff_t followup_contexts = 0x8; // char*
    constexpr std::ptrdiff_t followup_delay = 0x10; // float
    constexpr std::ptrdiff_t followup_target = 0x14; // char*
    constexpr std::ptrdiff_t followup_entityiotarget = 0x1C; // char*
    constexpr std::ptrdiff_t followup_entityioinput = 0x24; // char*
    constexpr std::ptrdiff_t followup_entityiodelay = 0x2C; // float
    constexpr std::ptrdiff_t bFired = 0x30; // bool
}

namespace ResponseParams {
    constexpr std::ptrdiff_t odds = 0x10; // int16_t
    constexpr std::ptrdiff_t flags = 0x12; // int16_t
    constexpr std::ptrdiff_t m_pFollowup = 0x18; // ResponseFollowup*
}

namespace SellbackPurchaseEntry_t {
    constexpr std::ptrdiff_t m_unDefIdx = 0x30; // uint16_t
    constexpr std::ptrdiff_t m_nCost = 0x34; // int32_t
    constexpr std::ptrdiff_t m_nPrevArmor = 0x38; // int32_t
    constexpr std::ptrdiff_t m_bPrevHelmet = 0x3C; // bool
    constexpr std::ptrdiff_t m_hItem = 0x40; // CEntityHandle
}

namespace ServerAuthoritativeWeaponSlot_t {
    constexpr std::ptrdiff_t unClass = 0x28; // uint16_t
    constexpr std::ptrdiff_t unSlot = 0x2A; // uint16_t
    constexpr std::ptrdiff_t unItemDefIdx = 0x2C; // uint16_t
}

namespace SimpleConstraintSoundProfile {
    constexpr std::ptrdiff_t eKeypoints = 0x8; // SimpleConstraintSoundProfile::SimpleConstraintsSoundProfileKeypoints_t
    constexpr std::ptrdiff_t m_keyPoints = 0xC; // float[2]
    constexpr std::ptrdiff_t m_reversalSoundThresholds = 0x14; // float[3]
}

namespace SpawnPoint {
    constexpr std::ptrdiff_t m_iPriority = 0x4B0; // int32_t
    constexpr std::ptrdiff_t m_bEnabled = 0x4B4; // bool
    constexpr std::ptrdiff_t m_nType = 0x4B8; // int32_t
}

namespace SpawnPointCoopEnemy {
    constexpr std::ptrdiff_t m_szWeaponsToGive = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_szPlayerModelToUse = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nArmorToSpawnWith = 0x4D0; // int32_t
    constexpr std::ptrdiff_t m_nDefaultBehavior = 0x4D4; // SpawnPointCoopEnemy::BotDefaultBehavior_t
    constexpr std::ptrdiff_t m_nBotDifficulty = 0x4D8; // int32_t
    constexpr std::ptrdiff_t m_bIsAgressive = 0x4DC; // bool
    constexpr std::ptrdiff_t m_bStartAsleep = 0x4DD; // bool
    constexpr std::ptrdiff_t m_flHideRadius = 0x4E0; // float
    constexpr std::ptrdiff_t m_szBehaviorTreeFile = 0x4F0; // CUtlSymbolLarge
}

namespace SummaryTakeDamageInfo_t {
    constexpr std::ptrdiff_t nSummarisedCount = 0x0; // int32_t
    constexpr std::ptrdiff_t info = 0x8; // CTakeDamageInfo
    constexpr std::ptrdiff_t result = 0xA0; // CTakeDamageResult
    constexpr std::ptrdiff_t hTarget = 0xA8; // CHandle<CBaseEntity>
}

namespace VPhysicsCollisionAttribute_t {
    constexpr std::ptrdiff_t m_nInteractsAs = 0x8; // uint64_t
    constexpr std::ptrdiff_t m_nInteractsWith = 0x10; // uint64_t
    constexpr std::ptrdiff_t m_nInteractsExclude = 0x18; // uint64_t
    constexpr std::ptrdiff_t m_nEntityId = 0x20; // uint32_t
    constexpr std::ptrdiff_t m_nOwnerId = 0x24; // uint32_t
    constexpr std::ptrdiff_t m_nHierarchyId = 0x28; // uint16_t
    constexpr std::ptrdiff_t m_nCollisionGroup = 0x2A; // uint8_t
    constexpr std::ptrdiff_t m_nCollisionFunctionMask = 0x2B; // uint8_t
}

namespace VelocitySampler {
    constexpr std::ptrdiff_t m_prevSample = 0x0; // Vector
    constexpr std::ptrdiff_t m_fPrevSampleTime = 0xC; // GameTime_t
    constexpr std::ptrdiff_t m_fIdealSampleRate = 0x10; // float
}

namespace ViewAngleServerChange_t {
    constexpr std::ptrdiff_t nType = 0x30; // FixAngleSet_t
    constexpr std::ptrdiff_t qAngle = 0x34; // QAngle
    constexpr std::ptrdiff_t nIndex = 0x40; // uint32_t
}

namespace WeaponPurchaseCount_t {
    constexpr std::ptrdiff_t m_nItemDefIndex = 0x30; // uint16_t
    constexpr std::ptrdiff_t m_nCount = 0x32; // uint16_t
}

namespace WeaponPurchaseTracker_t {
    constexpr std::ptrdiff_t m_weaponPurchases = 0x8; // CUtlVectorEmbeddedNetworkVar<WeaponPurchaseCount_t>
}

namespace audioparams_t {
    constexpr std::ptrdiff_t localSound = 0x8; // Vector[8]
    constexpr std::ptrdiff_t soundscapeIndex = 0x68; // int32_t
    constexpr std::ptrdiff_t localBits = 0x6C; // uint8_t
    constexpr std::ptrdiff_t soundscapeEntityListIndex = 0x70; // int32_t
    constexpr std::ptrdiff_t soundEventHash = 0x74; // uint32_t
}

namespace dynpitchvol_base_t {
    constexpr std::ptrdiff_t preset = 0x0; // int32_t
    constexpr std::ptrdiff_t pitchrun = 0x4; // int32_t
    constexpr std::ptrdiff_t pitchstart = 0x8; // int32_t
    constexpr std::ptrdiff_t spinup = 0xC; // int32_t
    constexpr std::ptrdiff_t spindown = 0x10; // int32_t
    constexpr std::ptrdiff_t volrun = 0x14; // int32_t
    constexpr std::ptrdiff_t volstart = 0x18; // int32_t
    constexpr std::ptrdiff_t fadein = 0x1C; // int32_t
    constexpr std::ptrdiff_t fadeout = 0x20; // int32_t
    constexpr std::ptrdiff_t lfotype = 0x24; // int32_t
    constexpr std::ptrdiff_t lforate = 0x28; // int32_t
    constexpr std::ptrdiff_t lfomodpitch = 0x2C; // int32_t
    constexpr std::ptrdiff_t lfomodvol = 0x30; // int32_t
    constexpr std::ptrdiff_t cspinup = 0x34; // int32_t
    constexpr std::ptrdiff_t cspincount = 0x38; // int32_t
    constexpr std::ptrdiff_t pitch = 0x3C; // int32_t
    constexpr std::ptrdiff_t spinupsav = 0x40; // int32_t
    constexpr std::ptrdiff_t spindownsav = 0x44; // int32_t
    constexpr std::ptrdiff_t pitchfrac = 0x48; // int32_t
    constexpr std::ptrdiff_t vol = 0x4C; // int32_t
    constexpr std::ptrdiff_t fadeinsav = 0x50; // int32_t
    constexpr std::ptrdiff_t fadeoutsav = 0x54; // int32_t
    constexpr std::ptrdiff_t volfrac = 0x58; // int32_t
    constexpr std::ptrdiff_t lfofrac = 0x5C; // int32_t
    constexpr std::ptrdiff_t lfomult = 0x60; // int32_t
}

namespace fogparams_t {
    constexpr std::ptrdiff_t dirPrimary = 0x8; // Vector
    constexpr std::ptrdiff_t colorPrimary = 0x14; // Color
    constexpr std::ptrdiff_t colorSecondary = 0x18; // Color
    constexpr std::ptrdiff_t colorPrimaryLerpTo = 0x1C; // Color
    constexpr std::ptrdiff_t colorSecondaryLerpTo = 0x20; // Color
    constexpr std::ptrdiff_t start = 0x24; // float
    constexpr std::ptrdiff_t end = 0x28; // float
    constexpr std::ptrdiff_t farz = 0x2C; // float
    constexpr std::ptrdiff_t maxdensity = 0x30; // float
    constexpr std::ptrdiff_t exponent = 0x34; // float
    constexpr std::ptrdiff_t HDRColorScale = 0x38; // float
    constexpr std::ptrdiff_t skyboxFogFactor = 0x3C; // float
    constexpr std::ptrdiff_t skyboxFogFactorLerpTo = 0x40; // float
    constexpr std::ptrdiff_t startLerpTo = 0x44; // float
    constexpr std::ptrdiff_t endLerpTo = 0x48; // float
    constexpr std::ptrdiff_t maxdensityLerpTo = 0x4C; // float
    constexpr std::ptrdiff_t lerptime = 0x50; // GameTime_t
    constexpr std::ptrdiff_t duration = 0x54; // float
    constexpr std::ptrdiff_t blendtobackground = 0x58; // float
    constexpr std::ptrdiff_t scattering = 0x5C; // float
    constexpr std::ptrdiff_t locallightscale = 0x60; // float
    constexpr std::ptrdiff_t enable = 0x64; // bool
    constexpr std::ptrdiff_t blend = 0x65; // bool
    constexpr std::ptrdiff_t m_bNoReflectionFog = 0x66; // bool
    constexpr std::ptrdiff_t m_bPadding = 0x67; // bool
}

namespace fogplayerparams_t {
    constexpr std::ptrdiff_t m_hCtrl = 0x8; // CHandle<CFogController>
    constexpr std::ptrdiff_t m_flTransitionTime = 0xC; // float
    constexpr std::ptrdiff_t m_OldColor = 0x10; // Color
    constexpr std::ptrdiff_t m_flOldStart = 0x14; // float
    constexpr std::ptrdiff_t m_flOldEnd = 0x18; // float
    constexpr std::ptrdiff_t m_flOldMaxDensity = 0x1C; // float
    constexpr std::ptrdiff_t m_flOldHDRColorScale = 0x20; // float
    constexpr std::ptrdiff_t m_flOldFarZ = 0x24; // float
    constexpr std::ptrdiff_t m_NewColor = 0x28; // Color
    constexpr std::ptrdiff_t m_flNewStart = 0x2C; // float
    constexpr std::ptrdiff_t m_flNewEnd = 0x30; // float
    constexpr std::ptrdiff_t m_flNewMaxDensity = 0x34; // float
    constexpr std::ptrdiff_t m_flNewHDRColorScale = 0x38; // float
    constexpr std::ptrdiff_t m_flNewFarZ = 0x3C; // float
}

namespace hudtextparms_t {
    constexpr std::ptrdiff_t color1 = 0x0; // Color
    constexpr std::ptrdiff_t color2 = 0x4; // Color
    constexpr std::ptrdiff_t effect = 0x8; // uint8_t
    constexpr std::ptrdiff_t channel = 0x9; // uint8_t
    constexpr std::ptrdiff_t x = 0xC; // float
    constexpr std::ptrdiff_t y = 0x10; // float
}

namespace lerpdata_t {
    constexpr std::ptrdiff_t m_hEnt = 0x0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_MoveType = 0x4; // MoveType_t
    constexpr std::ptrdiff_t m_flStartTime = 0x8; // GameTime_t
    constexpr std::ptrdiff_t m_vecStartOrigin = 0xC; // Vector
    constexpr std::ptrdiff_t m_qStartRot = 0x20; // Quaternion
    constexpr std::ptrdiff_t m_nFXIndex = 0x30; // ParticleIndex_t
}

namespace locksound_t {
    constexpr std::ptrdiff_t sLockedSound = 0x8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t sUnlockedSound = 0x10; // CUtlSymbolLarge
    constexpr std::ptrdiff_t flwaitSound = 0x18; // GameTime_t
}

namespace magnetted_objects_t {
    constexpr std::ptrdiff_t hEntity = 0x8; // CHandle<CBaseEntity>
}

namespace ragdoll_t {
    constexpr std::ptrdiff_t list = 0x0; // CUtlVector<ragdollelement_t>
    constexpr std::ptrdiff_t boneIndex = 0x18; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t allowStretch = 0x30; // bool
    constexpr std::ptrdiff_t unused = 0x31; // bool
}

namespace ragdollelement_t {
    constexpr std::ptrdiff_t originParentSpace = 0x0; // Vector
    constexpr std::ptrdiff_t parentIndex = 0x20; // int32_t
    constexpr std::ptrdiff_t m_flRadius = 0x24; // float
}

namespace shard_model_desc_t {
    constexpr std::ptrdiff_t m_nModelID = 0x8; // int32_t
    constexpr std::ptrdiff_t m_hMaterial = 0x10; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_solid = 0x18; // ShardSolid_t
    constexpr std::ptrdiff_t m_ShatterPanelMode = 0x19; // ShatterPanelMode
    constexpr std::ptrdiff_t m_vecPanelSize = 0x1C; // Vector2D
    constexpr std::ptrdiff_t m_vecStressPositionA = 0x24; // Vector2D
    constexpr std::ptrdiff_t m_vecStressPositionB = 0x2C; // Vector2D
    constexpr std::ptrdiff_t m_vecPanelVertices = 0x38; // CNetworkUtlVectorBase<Vector2D>
    constexpr std::ptrdiff_t m_flGlassHalfThickness = 0x50; // float
    constexpr std::ptrdiff_t m_bHasParent = 0x54; // bool
    constexpr std::ptrdiff_t m_bParentFrozen = 0x55; // bool
    constexpr std::ptrdiff_t m_SurfacePropStringToken = 0x58; // CUtlStringToken
}

namespace sky3dparams_t {
    constexpr std::ptrdiff_t scale = 0x8; // int16_t
    constexpr std::ptrdiff_t origin = 0xC; // Vector
    constexpr std::ptrdiff_t bClip3DSkyBoxNearToWorldFar = 0x18; // bool
    constexpr std::ptrdiff_t flClip3DSkyBoxNearToWorldFarOffset = 0x1C; // float
    constexpr std::ptrdiff_t fog = 0x20; // fogparams_t
    constexpr std::ptrdiff_t m_nWorldGroupID = 0x88; // WorldGroupId_t
}

namespace thinkfunc_t {
    constexpr std::ptrdiff_t m_hFn = 0x8; // HSCRIPT
    constexpr std::ptrdiff_t m_nContext = 0x10; // CUtlStringToken
    constexpr std::ptrdiff_t m_nNextThinkTick = 0x14; // GameTick_t
    constexpr std::ptrdiff_t m_nLastThinkTick = 0x18; // GameTick_t
}
```

`SDK/server.dll.json`:

```json
{
  "ActiveModelConfig_t": {
    "m_AssociatedEntities": 56,
    "m_AssociatedEntityNames": 80,
    "m_Handle": 40,
    "m_Name": 48
  },
  "AmmoIndex_t": {
    "m_Value": 0
  },
  "AmmoTypeInfo_t": {
    "m_flMass": 40,
    "m_flSpeed": 44,
    "m_nFlags": 36,
    "m_nMaxCarry": 16,
    "m_nSplashSize": 28
  },
  "AnimationUpdateListHandle_t": {
    "m_Value": 0
  },
  "CAISound": {
    "m_flDuration": 1216,
    "m_iSoundContext": 1204,
    "m_iSoundIndex": 1212,
    "m_iSoundType": 1200,
    "m_iVolume": 1208,
    "m_iszProxyEntityName": 1224
  },
  "CAI_ChangeHintGroup": {
    "m_flRadius": 1224,
    "m_iSearchType": 1200,
    "m_strNewHintGroup": 1216,
    "m_strSearchName": 1208
  },
  "CAI_ChangeTarget": {
    "m_iszNewTarget": 1200
  },
  "CAI_Expresser": {
    "m_bAllowSpeakingInterrupts": 76,
    "m_bConsiderSceneInvolvementAsSpeech": 77,
    "m_flBlockedTalkTime": 64,
    "m_flLastTimeAcceptedSpeak": 72,
    "m_flStopTalkTime": 56,
    "m_flStopTalkTimeWithoutDelay": 60,
    "m_nLastSpokenPriority": 80,
    "m_pOuter": 88,
    "m_voicePitch": 68
  },
  "CAI_ExpresserWithFollowup": {
    "m_pPostponedFollowup": 96
  },
  "CAmbientGeneric": {
    "m_dpv": 1212,
    "m_fActive": 1312,
    "m_fLooping": 1313,
    "m_flMaxRadius": 1204,
    "m_hSoundSource": 1336,
    "m_iSoundLevel": 1208,
    "m_iszSound": 1320,
    "m_nSoundSourceEntIndex": 1340,
    "m_radius": 1200,
    "m_sSourceEntName": 1328
  },
  "CAnimGraphNetworkedVariables": {
    "m_OwnerOnlyPredNetBoolVariables": 224,
    "m_OwnerOnlyPredNetByteVariables": 248,
    "m_OwnerOnlyPredNetFloatVariables": 368,
    "m_OwnerOnlyPredNetIntVariables": 296,
    "m_OwnerOnlyPredNetQuaternionVariables": 416,
    "m_OwnerOnlyPredNetUInt16Variables": 272,
    "m_OwnerOnlyPredNetUInt32Variables": 320,
    "m_OwnerOnlyPredNetUInt64Variables": 344,
    "m_OwnerOnlyPredNetVectorVariables": 392,
    "m_PredNetBoolVariables": 8,
    "m_PredNetByteVariables": 32,
    "m_PredNetFloatVariables": 152,
    "m_PredNetIntVariables": 80,
    "m_PredNetQuaternionVariables": 200,
    "m_PredNetUInt16Variables": 56,
    "m_PredNetUInt32Variables": 104,
    "m_PredNetUInt64Variables": 128,
    "m_PredNetVectorVariables": 176,
    "m_flLastTeleportTime": 452,
    "m_nBoolVariablesCount": 440,
    "m_nOwnerOnlyBoolVariablesCount": 444,
    "m_nRandomSeedOffset": 448
  },
  "CAnimGraphTagRef": {
    "m_nTagIndex": 0,
    "m_tagName": 16
  },
  "CAttributeContainer": {
    "m_Item": 80
  },
  "CAttributeList": {
    "m_Attributes": 8,
    "m_pManager": 88
  },
  "CAttributeManager": {
    "m_CachedResults": 48,
    "m_ProviderType": 44,
    "m_Providers": 8,
    "m_bPreventLoopback": 40,
    "m_hOuter": 36,
    "m_iReapplyProvisionParity": 32
  },
  "CAttributeManager_cached_attribute_float_t": {
    "flIn": 0,
    "flOut": 16,
    "iAttribHook": 8
  },
  "CBarnLight": {
    "m_Color": 1800,
    "m_LightStyleEvents": 1880,
    "m_LightStyleString": 1840,
    "m_LightStyleTargets": 1904,
    "m_QueuedLightStyleStrings": 1856,
    "m_StyleEvent": 1928,
    "m_bContactShadow": 2204,
    "m_bEnabled": 1792,
    "m_bPrecomputedFieldsValid": 2268,
    "m_bPvsModifyEntity": 2332,
    "m_fAlternateColorBrightness": 2232,
    "m_flBounceScale": 2212,
    "m_flBrightness": 1808,
    "m_flBrightnessScale": 1812,
    "m_flColorTemperature": 1804,
    "m_flFadeSizeEnd": 2256,
    "m_flFadeSizeStart": 2252,
    "m_flFogScale": 2248,
    "m_flFogStrength": 2240,
    "m_flLightStyleStartTime": 1848,
    "m_flLuminaireAnisotropy": 1832,
    "m_flLuminaireSize": 1828,
    "m_flMinRoughness": 2216,
    "m_flRange": 2160,
    "m_flShadowFadeSizeEnd": 2264,
    "m_flShadowFadeSizeStart": 2260,
    "m_flShape": 2128,
    "m_flSkirt": 2140,
    "m_flSkirtNear": 2144,
    "m_flSoftX": 2132,
    "m_flSoftY": 2136,
    "m_hLightCookie": 2120,
    "m_nBakeSpecularToCubemaps": 2176,
    "m_nBakedShadowIndex": 1820,
    "m_nBounceLight": 2208,
    "m_nCastShadows": 2192,
    "m_nColorMode": 1796,
    "m_nDirectLight": 1816,
    "m_nFog": 2236,
    "m_nFogShadows": 2244,
    "m_nLuminaireShape": 1824,
    "m_nShadowMapSize": 2196,
    "m_nShadowPriority": 2200,
    "m_vAlternateColor": 2220,
    "m_vBakeSpecularToCubemapsSize": 2180,
    "m_vPrecomputedBoundsMaxs": 2284,
    "m_vPrecomputedBoundsMins": 2272,
    "m_vPrecomputedOBBAngles": 2308,
    "m_vPrecomputedOBBExtent": 2320,
    "m_vPrecomputedOBBOrigin": 2296,
    "m_vShear": 2164,
    "m_vSizeParams": 2148
  },
  "CBaseAnimGraph": {
    "m_bAnimGraphDirty": 1828,
    "m_bAnimGraphUpdateEnabled": 1808,
    "m_bClientRagdoll": 1872,
    "m_bInitiallyPopulateInterpHistory": 1792,
    "m_bShouldAnimateDuringGameplayPause": 1793,
    "m_flMaxSlopeDistance": 1812,
    "m_nForceBone": 1844,
    "m_pChoreoServices": 1800,
    "m_pRagdollPose": 1864,
    "m_vLastSlopeCheckPos": 1816,
    "m_vecForce": 1832
  },
  "CBaseAnimGraphController": {
    "m_animGraphNetworkedVars": 64,
    "m_bClientSideAnimation": 560,
    "m_bNetworkedAnimationInputsChanged": 561,
    "m_bSequenceFinished": 536,
    "m_baseLayer": 24,
    "m_flLastEventAnimTime": 544,
    "m_flLastEventCycle": 540,
    "m_flPlaybackRate": 548,
    "m_flPrevAnimTime": 556,
    "m_hAnimationUpdate": 732,
    "m_nAnimLoopMode": 572,
    "m_nNewSequenceParity": 564,
    "m_nResetEventsParity": 568
  },
  "CBaseButton": {
    "m_OnDamaged": 2008,
    "m_OnIn": 2128,
    "m_OnOut": 2168,
    "m_OnPressed": 2048,
    "m_OnUseLocked": 2088,
    "m_angMoveEntitySpace": 1920,
    "m_bDisabled": 1993,
    "m_bForceNpcExclude": 2220,
    "m_bLocked": 1992,
    "m_bSolidBsp": 2000,
    "m_fRotating": 1933,
    "m_fStayPushed": 1932,
    "m_flUseLockedTime": 1996,
    "m_glowEntity": 2232,
    "m_hConstraint": 2212,
    "m_hConstraintParent": 2216,
    "m_ls": 1936,
    "m_nState": 2208,
    "m_sGlowEntity": 2224,
    "m_sLockedSound": 1976,
    "m_sUnlockedSound": 1984,
    "m_sUseSound": 1968,
    "m_szDisplayText": 2240,
    "m_usable": 2236
  },
  "CBaseCSGrenade": {
    "m_bIsHeldByPlayer": 3617,
    "m_bJumpThrow": 3619,
    "m_bPinPulled": 3618,
    "m_bRedraw": 3616,
    "m_eThrowStatus": 3620,
    "m_fDropTime": 3636,
    "m_fThrowTime": 3624,
    "m_flThrowStrength": 3628,
    "m_flThrowStrengthApproach": 3632
  },
  "CBaseCSGrenadeProjectile": {
    "m_bClearFromPlayers": 2621,
    "m_bDetonationRecorded": 2565,
    "m_bHasEverHitPlayer": 2620,
    "m_flDetonateTime": 2568,
    "m_flLastBounceSoundTime": 2588,
    "m_flSpawnTime": 2560,
    "m_nBounces": 2528,
    "m_nExplodeEffectIndex": 2536,
    "m_nExplodeEffectTickBegin": 2544,
    "m_nItemIndex": 2572,
    "m_nTicksAtZeroVelocity": 2616,
    "m_unOGSExtraFlags": 2564,
    "m_vInitialPosition": 2504,
    "m_vInitialVelocity": 2516,
    "m_vecExplodeEffectOrigin": 2548,
    "m_vecGrenadeSpin": 2592,
    "m_vecLastHitSurfaceNormal": 2604,
    "m_vecOriginalSpawnLocation": 2576
  },
  "CBaseClientUIEntity": {
    "m_CustomOutput0": 1824,
    "m_CustomOutput1": 1864,
    "m_CustomOutput2": 1904,
    "m_CustomOutput3": 1944,
    "m_CustomOutput4": 1984,
    "m_CustomOutput5": 2024,
    "m_CustomOutput6": 2064,
    "m_CustomOutput7": 2104,
    "m_CustomOutput8": 2144,
    "m_CustomOutput9": 2184,
    "m_DialogXMLName": 1800,
    "m_PanelClassName": 1808,
    "m_PanelID": 1816,
    "m_bEnabled": 1792
  },
  "CBaseCombatCharacter": {
    "m_LastHitGroup": 2376,
    "m_bApplyStressDamage": 2380,
    "m_bForceServerRagdoll": 2336,
    "m_bloodColor": 2384,
    "m_eHull": 2504,
    "m_flFieldOfView": 2368,
    "m_hMyWearables": 2344,
    "m_iDamageCount": 2484,
    "m_impactEnergyScale": 2372,
    "m_nNavHullIdx": 2508,
    "m_navMeshID": 2480,
    "m_pVecRelationships": 2488,
    "m_strRelationships": 2496
  },
  "CBaseDMStart": {
    "m_Master": 1200
  },
  "CBaseDoor": {
    "m_ChainTarget": 2040,
    "m_NoiseArrived": 2016,
    "m_NoiseArrivedClosed": 2032,
    "m_NoiseMoving": 2008,
    "m_NoiseMovingClosed": 2024,
    "m_OnBlockedClosing": 2048,
    "m_OnBlockedOpening": 2088,
    "m_OnClose": 2288,
    "m_OnFullyClosed": 2208,
    "m_OnFullyOpen": 2248,
    "m_OnLockedUse": 2368,
    "m_OnOpen": 2328,
    "m_OnUnblockedClosing": 2128,
    "m_OnUnblockedOpening": 2168,
    "m_angMoveEntitySpace": 1936,
    "m_bCreateNavObstacle": 2432,
    "m_bDoorGroup": 1993,
    "m_bForceClosed": 1992,
    "m_bIgnoreDebris": 1995,
    "m_bIsUsable": 2434,
    "m_bLocked": 1994,
    "m_bLoopMoveSound": 2408,
    "m_eSpawnPosition": 1996,
    "m_flBlockDamage": 2000,
    "m_isChaining": 2433,
    "m_ls": 1960,
    "m_vecMoveDirParentSpace": 1948
  },
  "CBaseEntity": {
    "m_CBodyComponent": 48,
    "m_MoveCollide": 705,
    "m_MoveType": 706,
    "m_NetworkTransmitComponent": 56,
    "m_OnKilled": 824,
    "m_OnUser1": 1000,
    "m_OnUser2": 1040,
    "m_OnUser3": 1080,
    "m_OnUser4": 1120,
    "m_ResponseContexts": 616,
    "m_aThinkFunctions": 552,
    "m_bAnimatedEveryTick": 989,
    "m_bClientSideRagdoll": 764,
    "m_bDisableLowViolence": 990,
    "m_bLagCompensate": 1181,
    "m_bNetworkQuantizeOriginAndAngles": 1180,
    "m_bRestoreInHierarchy": 709,
    "m_bSimulatedEveryTick": 988,
    "m_bTakesDamage": 696,
    "m_fEffects": 960,
    "m_fFlags": 864,
    "m_flAnimTime": 752,
    "m_flCreateTime": 760,
    "m_flDamageAccumulator": 692,
    "m_flElasticity": 972,
    "m_flFriction": 968,
    "m_flGravityScale": 976,
    "m_flLocalTime": 1192,
    "m_flMoveDoneTime": 720,
    "m_flNavIgnoreUntilTime": 1164,
    "m_flOverriddenFriction": 1184,
    "m_flSimulationTime": 756,
    "m_flSpeed": 796,
    "m_flTimeScale": 980,
    "m_flVPhysicsUpdateLocalTime": 1196,
    "m_flWaterLevel": 984,
    "m_hDamageFilter": 724,
    "m_hEffectEntity": 952,
    "m_hGroundEntity": 964,
    "m_hOwnerEntity": 956,
    "m_iCurrentThinkContext": 576,
    "m_iEFlags": 992,
    "m_iGlobalname": 784,
    "m_iHealth": 680,
    "m_iInitialTeamNum": 1160,
    "m_iMaxHealth": 684,
    "m_iSentToClients": 792,
    "m_iTeamNum": 780,
    "m_isSteadyState": 592,
    "m_iszDamageFilterName": 728,
    "m_iszResponseContext": 640,
    "m_lastNetworkChange": 600,
    "m_lifeState": 688,
    "m_nLastThinkTick": 580,
    "m_nNextThinkTick": 812,
    "m_nPushEnumCount": 940,
    "m_nSimulationTick": 816,
    "m_nSlimeTouch": 708,
    "m_nSubclassID": 736,
    "m_nTakeDamageFlags": 700,
    "m_nWaterTouch": 707,
    "m_nWaterType": 991,
    "m_pBlocker": 1188,
    "m_pCollision": 944,
    "m_sUniqueHammerID": 800,
    "m_spawnflags": 808,
    "m_target": 712,
    "m_ubInterpolationFrame": 765,
    "m_vPrevVPhysicsUpdatePos": 768,
    "m_vecAbsVelocity": 868,
    "m_vecAngVelocity": 1168,
    "m_vecBaseVelocity": 928,
    "m_vecVelocity": 880
  },
  "CBaseFilter": {
    "m_OnFail": 1248,
    "m_OnPass": 1208,
    "m_bNegated": 1200
  },
  "CBaseFire": {
    "m_flScale": 1200,
    "m_flScaleTime": 1208,
    "m_flStartScale": 1204,
    "m_nFlags": 1212
  },
  "CBaseFlex": {
    "m_bUpdateLayerPriorities": 2324,
    "m_blinktoggle": 2228,
    "m_flAllowResponsesEndTime": 2312,
    "m_flLastFlexAnimationTime": 2316,
    "m_flexWeight": 2192,
    "m_nNextSceneEventId": 2320,
    "m_vLookTargetPosition": 2216
  },
  "CBaseGrenade": {
    "m_DmgRadius": 2428,
    "m_ExplosionSound": 2456,
    "m_OnExplode": 2384,
    "m_OnPlayerPickup": 2344,
    "m_bHasWarnedAI": 2424,
    "m_bIsLive": 2426,
    "m_bIsSmokeGrenade": 2425,
    "m_flDamage": 2440,
    "m_flDetonateTime": 2432,
    "m_flNextAttack": 2492,
    "m_flWarnAITime": 2436,
    "m_hOriginalThrower": 2496,
    "m_hThrower": 2468,
    "m_iszBounceSound": 2448
  },
  "CBaseIssue": {
    "m_iNumNoVotes": 360,
    "m_iNumPotentialVotes": 364,
    "m_iNumYesVotes": 356,
    "m_pVoteController": 368,
    "m_szDetailsString": 96,
    "m_szTypeString": 32
  },
  "CBaseModelEntity": {
    "m_CHitboxComponent": 1208,
    "m_CRenderComponent": 1200,
    "m_Collision": 1392,
    "m_ConfigEntitiesToPropagateMaterialDecalsTo": 1720,
    "m_Glow": 1568,
    "m_OnIgnite": 1256,
    "m_bAllowFadeInView": 1298,
    "m_bRenderToCubemaps": 1384,
    "m_clrRender": 1299,
    "m_fadeMaxDist": 1664,
    "m_fadeMinDist": 1660,
    "m_flDecalHealBloodRate": 1708,
    "m_flDecalHealHeightRate": 1712,
    "m_flDissolveStartTime": 1248,
    "m_flFadeScale": 1668,
    "m_flGlowBackfaceMult": 1656,
    "m_flShadowStrength": 1672,
    "m_nAddDecal": 1680,
    "m_nObjectCulling": 1676,
    "m_nRenderFX": 1297,
    "m_nRenderMode": 1296,
    "m_vDecalForwardAxis": 1696,
    "m_vDecalPosition": 1684,
    "m_vecRenderAttributes": 1304,
    "m_vecViewOffset": 1744
  },
  "CBaseMoveBehavior": {
    "m_flAnimEndTime": 1308,
    "m_flAnimStartTime": 1304,
    "m_flAverageSpeedAcrossFrame": 1312,
    "m_flTimeIntoFrame": 1352,
    "m_iDirection": 1356,
    "m_iPositionInterpolator": 1296,
    "m_iRotationInterpolator": 1300,
    "m_pCurrentKeyFrame": 1320,
    "m_pPostKeyFrame": 1344,
    "m_pPreKeyFrame": 1336,
    "m_pTargetKeyFrame": 1328
  },
  "CBasePlatTrain": {
    "m_NoiseArrived": 1928,
    "m_NoiseMoving": 1920,
    "m_flTLength": 1952,
    "m_flTWidth": 1948,
    "m_volume": 1944
  },
  "CBasePlayerController": {
    "m_bAutoKickDisabled": 1454,
    "m_bGamePaused": 1456,
    "m_bHasAnySteadyStateEnts": 1648,
    "m_bIsHLTV": 1304,
    "m_bIsLowViolence": 1455,
    "m_bLagCompensation": 1452,
    "m_bPredict": 1453,
    "m_fLerpTime": 1448,
    "m_flLastEntitySteadyState": 1640,
    "m_flLastPlayerTalkTime": 1636,
    "m_hPawn": 1264,
    "m_hSplitOwner": 1272,
    "m_hSplitScreenPlayers": 1280,
    "m_iConnected": 1308,
    "m_iDesiredFOV": 1672,
    "m_iIgnoreGlobalChat": 1632,
    "m_iszPlayerName": 1312,
    "m_nAvailableEntitySteadyState": 1644,
    "m_nInButtonsWhichAreToggles": 1208,
    "m_nSplitScreenSlot": 1268,
    "m_nTickBase": 1216,
    "m_nUsecTimestampLastUserCmdReceived": 1608,
    "m_steamID": 1664,
    "m_szNetworkIDString": 1440
  },
  "CBasePlayerPawn": {
    "m_ServerViewAngleChanges": 2592,
    "m_fHltvReplayDelay": 2880,
    "m_fHltvReplayEnd": 2884,
    "m_fInitHUD": 2860,
    "m_fNextSuicideTime": 2856,
    "m_fTimeLastHurt": 2848,
    "m_flDeathTime": 2852,
    "m_hController": 2872,
    "m_iHideHUD": 2700,
    "m_iHltvReplayEntity": 2888,
    "m_nHighestGeneratedServerViewAngleChangeIndex": 2672,
    "m_pAutoaimServices": 2528,
    "m_pCameraServices": 2568,
    "m_pExpresser": 2864,
    "m_pFlashlightServices": 2560,
    "m_pItemServices": 2520,
    "m_pMovementServices": 2576,
    "m_pObserverServices": 2536,
    "m_pUseServices": 2552,
    "m_pWaterServices": 2544,
    "m_pWeaponServices": 2512,
    "m_skybox3d": 2704,
    "v_angle": 2676,
    "v_anglePrevious": 2688
  },
  "CBasePlayerVData": {
    "m_flArmDamageMultiplier": 312,
    "m_flChestDamageMultiplier": 280,
    "m_flCrouchTime": 372,
    "m_flDrowningDamageInterval": 348,
    "m_flHeadDamageMultiplier": 264,
    "m_flHoldBreathTime": 344,
    "m_flLegDamageMultiplier": 328,
    "m_flStomachDamageMultiplier": 296,
    "m_flUseAngleTolerance": 368,
    "m_flUseRange": 364,
    "m_nDrowningDamageInitial": 352,
    "m_nDrowningDamageMax": 356,
    "m_nWaterSpeed": 360,
    "m_sModelName": 40
  },
  "CBasePlayerWeapon": {
    "m_OnPlayerUse": 3128,
    "m_flNextPrimaryAttackTickRatio": 3100,
    "m_flNextSecondaryAttackTickRatio": 3108,
    "m_iClip1": 3112,
    "m_iClip2": 3116,
    "m_nNextPrimaryAttackTick": 3096,
    "m_nNextSecondaryAttackTick": 3104,
    "m_pReserveAmmo": 3120
  },
  "CBasePlayerWeaponVData": {
    "m_aShootSounds": 536,
    "m_bAllowFlipping": 265,
    "m_bAutoSwitchFrom": 529,
    "m_bAutoSwitchTo": 528,
    "m_bBuiltRightHanded": 264,
    "m_bIsFullAuto": 266,
    "m_iDefaultClip1": 516,
    "m_iDefaultClip2": 520,
    "m_iFlags": 504,
    "m_iMaxClip1": 508,
    "m_iMaxClip2": 512,
    "m_iPosition": 572,
    "m_iRumbleEffect": 532,
    "m_iSlot": 568,
    "m_iWeight": 524,
    "m_nNumBullets": 268,
    "m_nPrimaryAmmoType": 505,
    "m_nSecondaryAmmoType": 506,
    "m_sMuzzleAttachment": 272,
    "m_szMuzzleFlashParticle": 280,
    "m_szWorldModel": 40
  },
  "CBaseProp": {
    "m_bConformToCollisionBounds": 2200,
    "m_bModelOverrodeBlockLOS": 2192,
    "m_iShapeType": 2196,
    "m_mPreferredCatchTransform": 2204
  },
  "CBasePropDoor": {
    "m_OnAjarOpen": 3440,
    "m_OnBlockedClosing": 3080,
    "m_OnBlockedOpening": 3120,
    "m_OnClose": 3320,
    "m_OnFullyClosed": 3240,
    "m_OnFullyOpen": 3280,
    "m_OnLockedUse": 3400,
    "m_OnOpen": 3360,
    "m_OnUnblockedClosing": 3160,
    "m_OnUnblockedOpening": 3200,
    "m_SlaveName": 3064,
    "m_SoundClose": 3000,
    "m_SoundJiggle": 3040,
    "m_SoundLatch": 3024,
    "m_SoundLock": 3008,
    "m_SoundLockedAnim": 3048,
    "m_SoundMoving": 2984,
    "m_SoundOpen": 2992,
    "m_SoundPound": 3032,
    "m_SoundUnlock": 3016,
    "m_bFirstBlocked": 2916,
    "m_bForceClosed": 2952,
    "m_bLocked": 2884,
    "m_bNeedsHardware": 2876,
    "m_closedAngles": 2900,
    "m_closedPosition": 2888,
    "m_eDoorState": 2880,
    "m_flAutoReturnDelay": 2840,
    "m_hActivator": 2968,
    "m_hBlocker": 2912,
    "m_hDoorList": 2848,
    "m_hMaster": 3072,
    "m_ls": 2920,
    "m_nHardwareType": 2872,
    "m_nPhysicsMaterial": 3060,
    "m_numCloseAttempts": 3056,
    "m_vecLatchWorldPosition": 2956
  },
  "CBaseToggle": {
    "m_bAlwaysFireBlockedOutputs": 1808,
    "m_flHeight": 1872,
    "m_flLip": 1804,
    "m_flMoveDistance": 1796,
    "m_flWait": 1800,
    "m_hActivator": 1876,
    "m_movementType": 1904,
    "m_sMaster": 1912,
    "m_toggle_state": 1792,
    "m_vecAngle1": 1848,
    "m_vecAngle2": 1860,
    "m_vecFinalAngle": 1892,
    "m_vecFinalDest": 1880,
    "m_vecMoveAng": 1836,
    "m_vecPosition1": 1812,
    "m_vecPosition2": 1824
  },
  "CBaseTrigger": {
    "m_OnEndTouch": 2024,
    "m_OnEndTouchAll": 2064,
    "m_OnNotTouching": 2144,
    "m_OnStartTouch": 1944,
    "m_OnStartTouchAll": 1984,
    "m_OnTouching": 2104,
    "m_bClientSidePredicted": 2208,
    "m_bDisabled": 1920,
    "m_hFilter": 1936,
    "m_hTouchingEntities": 2184,
    "m_iFilterName": 1928
  },
  "CBaseViewModel": {
    "m_flAnimationStartTime": 2220,
    "m_hControlPanel": 2260,
    "m_hOldLayerSequence": 2248,
    "m_hWeapon": 2224,
    "m_nAnimationParity": 2216,
    "m_nViewModelIndex": 2212,
    "m_oldLayer": 2252,
    "m_oldLayerStartTime": 2256,
    "m_sAnimationPrefix": 2240,
    "m_sVMName": 2232,
    "m_vecLastFacing": 2200
  },
  "CBeam": {
    "m_bTurnedOff": 1928,
    "m_fAmplitude": 1908,
    "m_fEndWidth": 1896,
    "m_fFadeLength": 1900,
    "m_fHaloScale": 1904,
    "m_fSpeed": 1916,
    "m_fStartFrame": 1912,
    "m_fWidth": 1892,
    "m_flDamage": 1804,
    "m_flFireTime": 1800,
    "m_flFrame": 1920,
    "m_flFrameRate": 1792,
    "m_flHDRColorScale": 1796,
    "m_hAttachEntity": 1840,
    "m_hBaseMaterial": 1816,
    "m_hEndEntity": 1944,
    "m_nAttachIndex": 1880,
    "m_nBeamFlags": 1836,
    "m_nBeamType": 1832,
    "m_nClipStyle": 1924,
    "m_nDissolveType": 1948,
    "m_nHaloIndex": 1824,
    "m_nNumBeamEnts": 1808,
    "m_vecEndPos": 1932
  },
  "CBlood": {
    "m_Color": 1228,
    "m_flAmount": 1224,
    "m_vecSprayAngles": 1200,
    "m_vecSprayDir": 1212
  },
  "CBodyComponent": {
    "__m_pChainEntity": 32,
    "m_pSceneNode": 8
  },
  "CBodyComponentBaseAnimGraph": {
    "__m_pChainEntity": 1888,
    "m_animationController": 1152
  },
  "CBodyComponentBaseModelEntity": {
    "__m_pChainEntity": 1152
  },
  "CBodyComponentPoint": {
    "__m_pChainEntity": 416,
    "m_sceneNode": 80
  },
  "CBodyComponentSkeletonInstance": {
    "__m_pChainEntity": 1104,
    "m_skeletonInstance": 80
  },
  "CBombTarget": {
    "m_OnBombDefused": 2296,
    "m_OnBombExplode": 2216,
    "m_OnBombPlanted": 2256,
    "m_bBombPlantedHere": 2338,
    "m_bIsBombSiteB": 2336,
    "m_bIsHeistBombTarget": 2337,
    "m_hInstructorHint": 2352,
    "m_nBombSiteDesignation": 2356,
    "m_szMountTarget": 2344
  },
  "CBot": {
    "m_bHasSpawned": 32,
    "m_buttonFlags": 200,
    "m_forwardSpeed": 188,
    "m_id": 36,
    "m_isCrouching": 185,
    "m_isRunning": 184,
    "m_jumpTimestamp": 208,
    "m_leftSpeed": 192,
    "m_pController": 16,
    "m_pPlayer": 24,
    "m_postureStackIndex": 240,
    "m_verticalSpeed": 196,
    "m_viewForward": 212
  },
  "CBreakable": {
    "m_Explosion": 1816,
    "m_Material": 1808,
    "m_OnBreak": 1856,
    "m_OnHealthChanged": 1896,
    "m_PerformanceMode": 1972,
    "m_flDmgModBullet": 1936,
    "m_flDmgModClub": 1940,
    "m_flDmgModExplosive": 1944,
    "m_flDmgModFire": 1948,
    "m_flLastPhysicsInfluenceTime": 1980,
    "m_flPressureDelay": 1832,
    "m_hBreaker": 1812,
    "m_hPhysicsAttacker": 1976,
    "m_iInteractions": 1968,
    "m_iMinHealthDmg": 1836,
    "m_impactEnergyScale": 1848,
    "m_iszBasePropData": 1960,
    "m_iszPhysicsDamageTableName": 1952,
    "m_iszPropData": 1840,
    "m_iszSpawnObject": 1824,
    "m_nOverrideBlockLOS": 1852
  },
  "CBreakableProp": {
    "m_OnBreak": 2272,
    "m_OnHealthChanged": 2312,
    "m_OnTakeDamage": 2352,
    "m_PerformanceMode": 2420,
    "m_bHasBreakPiecesOrCommands": 2464,
    "m_bOriginalBlockLOS": 2528,
    "m_bUsePuntSound": 2544,
    "m_explodeDamage": 2468,
    "m_explodeRadius": 2472,
    "m_explosionBuildupSound": 2488,
    "m_explosionCustomEffect": 2496,
    "m_explosionCustomSound": 2504,
    "m_explosionDelay": 2480,
    "m_explosionModifier": 2512,
    "m_flDefaultFadeScale": 2532,
    "m_flDmgModBullet": 2424,
    "m_flDmgModClub": 2428,
    "m_flDmgModExplosive": 2432,
    "m_flDmgModFire": 2436,
    "m_flLastPhysicsInfluenceTime": 2524,
    "m_flPressureDelay": 2412,
    "m_flPreventDamageBeforeTime": 2460,
    "m_hBreaker": 2416,
    "m_hFlareEnt": 2540,
    "m_hLastAttacker": 2536,
    "m_hPhysicsAttacker": 2520,
    "m_iInteractions": 2456,
    "m_iMinHealthDmg": 2396,
    "m_impactEnergyScale": 2392,
    "m_iszBasePropData": 2448,
    "m_iszPhysicsDamageTableName": 2440,
    "m_iszPuntSound": 2552,
    "m_noGhostCollision": 2560,
    "m_preferredCarryAngles": 2400
  },
  "CBreakableStageHelper": {
    "m_nCurrentStage": 8,
    "m_nStageCount": 12
  },
  "CBtActionAim": {
    "m_AimTimer": 168,
    "m_FocusIntervalTimer": 216,
    "m_NextLookTarget": 156,
    "m_SniperHoldTimer": 192,
    "m_bAcquired": 240,
    "m_bDoneAiming": 140,
    "m_flLerpStartTime": 144,
    "m_flNextLookTargetLerpTime": 148,
    "m_flPenaltyReductionRatio": 152,
    "m_flZoomCooldownTimestamp": 136,
    "m_szAimReadyKey": 128,
    "m_szSensorInputKey": 104
  },
  "CBtActionCombatPositioning": {
    "m_ActionTimer": 136,
    "m_bCrouching": 160,
    "m_szIsAttackingKey": 128,
    "m_szSensorInputKey": 104
  },
  "CBtActionMoveTo": {
    "m_CheckApproximateCornersTimer": 144,
    "m_CheckHighPriorityItem": 168,
    "m_RepathTimer": 192,
    "m_bAutoLookAdjust": 132,
    "m_bComputePath": 133,
    "m_flAdditionalArrivalEpsilon2D": 220,
    "m_flArrivalEpsilon": 216,
    "m_flDamagingAreasPenaltyCost": 136,
    "m_flHidingSpotCheckDistanceThreshold": 224,
    "m_flNearestAreaDistanceThreshold": 228,
    "m_szDestinationInputKey": 96,
    "m_szHidingSpotInputKey": 104,
    "m_szThreatInputKey": 112,
    "m_vecDestination": 120
  },
  "CBtActionParachutePositioning": {
    "m_ActionTimer": 88
  },
  "CBtNodeCondition": {
    "m_bNegated": 88
  },
  "CBtNodeConditionInactive": {
    "m_SensorInactivityTimer": 128,
    "m_flRoundStartThresholdSeconds": 120,
    "m_flSensorInactivityThresholdSeconds": 124
  },
  "CBubbling": {
    "m_density": 1792,
    "m_frequency": 1796,
    "m_state": 1800
  },
  "CBuoyancyHelper": {
    "m_flFluidDensity": 24
  },
  "CBuyZone": {
    "m_LegacyTeamNum": 2216
  },
  "CC4": {
    "m_bBombPlacedAnimation": 3648,
    "m_bBombPlanted": 3691,
    "m_bDoValidDroppedPositionCheck": 3640,
    "m_bDroppedFromDeath": 3692,
    "m_bIsPlantingViaUse": 3649,
    "m_bPlayedArmingBeeps": 3684,
    "m_bStartedArming": 3641,
    "m_entitySpottedState": 3656,
    "m_fArmedTime": 3644,
    "m_nSpotRules": 3680,
    "m_vecLastValidDroppedPosition": 3628,
    "m_vecLastValidPlayerHeldPosition": 3616
  },
  "CCSBot": {
    "m_aimError": 28872,
    "m_aimFocus": 28900,
    "m_aimFocusInterval": 28904,
    "m_aimFocusNextUpdate": 28908,
    "m_aimGoal": 28884,
    "m_alertTimer": 464,
    "m_allowAutoFollowTime": 436,
    "m_approachPointCount": 27680,
    "m_approachPointViewPosition": 27684,
    "m_areaEnteredTimestamp": 26132,
    "m_attackedTimestamp": 29548,
    "m_attacker": 29544,
    "m_attentionInterval": 29528,
    "m_avgVel": 29916,
    "m_avgVelCount": 29960,
    "m_avgVelIndex": 29956,
    "m_avoid": 1276,
    "m_avoidFriendTimer": 26160,
    "m_avoidTimestamp": 1280,
    "m_bAllowActive": 424,
    "m_bEyeAnglesUnderPathFinderControl": 1304,
    "m_bIsSleeping": 29648,
    "m_bendNoisePositionValid": 27220,
    "m_bentNoisePosition": 27208,
    "m_blindFire": 396,
    "m_bomber": 29512,
    "m_burnedByFlamesTimer": 29552,
    "m_checkedHidingSpotCount": 28816,
    "m_closestVisibleFriend": 29520,
    "m_closestVisibleHumanFriend": 29524,
    "m_combatRange": 340,
    "m_currentEnemyAcquireTimestamp": 28972,
    "m_desiredTeam": 27080,
    "m_diedLastRound": 380,
    "m_enemy": 28944,
    "m_enemyDeathTimestamp": 28976,
    "m_enemyQueueAttendIndex": 29842,
    "m_enemyQueueCount": 29841,
    "m_enemyQueueIndex": 29840,
    "m_equipTimer": 29576,
    "m_eyePosition": 264,
    "m_fireWeaponTimestamp": 29616,
    "m_firstSawEnemyTimestamp": 28968,
    "m_followTimestamp": 432,
    "m_forwardAngle": 27232,
    "m_friendDeathTimestamp": 28980,
    "m_goalEntity": 1272,
    "m_goalPosition": 1260,
    "m_hasJoined": 27084,
    "m_hasVisitedEnemySpawn": 1285,
    "m_hostageEscortCount": 27072,
    "m_hostageEscortCountTimestamp": 27076,
    "m_hurryTimer": 440,
    "m_ignoreEnemiesTimer": 28920,
    "m_inhibitLookAroundTimestamp": 27236,
    "m_inhibitWaitingForHostageTimer": 27088,
    "m_isAimingAtEnemy": 29572,
    "m_isAttacking": 1236,
    "m_isAvoidingGrenade": 27752,
    "m_isEnemySniperVisible": 29649,
    "m_isEnemyVisible": 28948,
    "m_isFollowing": 425,
    "m_isFriendInTheWay": 26184,
    "m_isLastEnemyDead": 28984,
    "m_isOpeningDoor": 1237,
    "m_isRapidFiring": 29573,
    "m_isRogue": 344,
    "m_isStopping": 1284,
    "m_isStuck": 29843,
    "m_isWaitingBehindFriend": 26216,
    "m_isWaitingForHostage": 27085,
    "m_lastCoopSpawnPoint": 248,
    "m_lastEnemyPosition": 28952,
    "m_lastOrigin": 29964,
    "m_lastRadioRecievedTimestamp": 29980,
    "m_lastRadioSentTimestamp": 29984,
    "m_lastSawEnemyTimestamp": 28964,
    "m_lastValidReactionQueueFrame": 30016,
    "m_lastVictimID": 29568,
    "m_leader": 428,
    "m_lookAheadAngle": 27228,
    "m_lookAroundStateTimestamp": 27224,
    "m_lookAtDesc": 27280,
    "m_lookAtSpot": 27244,
    "m_lookAtSpotAngleTolerance": 27268,
    "m_lookAtSpotAttack": 27273,
    "m_lookAtSpotClearIfClose": 27272,
    "m_lookAtSpotDuration": 27260,
    "m_lookAtSpotTimestamp": 27264,
    "m_lookForWeaponsOnGroundTimer": 29624,
    "m_lookPitch": 28820,
    "m_lookPitchVel": 28824,
    "m_lookYaw": 28828,
    "m_lookYawVel": 28832,
    "m_mustRunTimer": 26336,
    "m_name": 276,
    "m_nearbyEnemyCount": 28988,
    "m_nearbyFriendCount": 29516,
    "m_nextCleanupCheckTimestamp": 29912,
    "m_noiseBendTimer": 27184,
    "m_noisePosition": 27136,
    "m_noiseSource": 27160,
    "m_noiseTimestamp": 27152,
    "m_noiseTravelDistance": 27148,
    "m_panicTimer": 512,
    "m_pathIndex": 26128,
    "m_pathLadderEnd": 26260,
    "m_peripheralTimestamp": 27288,
    "m_playerTravelDistance": 26408,
    "m_politeTimer": 26192,
    "m_radioPosition": 29992,
    "m_radioSubject": 29988,
    "m_repathTimer": 26136,
    "m_rogueTimer": 352,
    "m_safeTime": 384,
    "m_sawEnemySniperTimer": 29656,
    "m_sneakTimer": 488,
    "m_spotCheckTimestamp": 27784,
    "m_stateTimestamp": 1232,
    "m_stillTimer": 1288,
    "m_stuckJumpTimer": 29888,
    "m_stuckSpot": 29848,
    "m_stuckTimestamp": 29844,
    "m_surpriseTimer": 400,
    "m_targetSpot": 28836,
    "m_targetSpotPredicted": 28860,
    "m_targetSpotTime": 28896,
    "m_targetSpotVelocity": 28848,
    "m_taskEntity": 1244,
    "m_tossGrenadeTimer": 27720,
    "m_travelDistancePhase": 26664,
    "m_updateTravelDistanceTimer": 26384,
    "m_viewSteadyTimer": 27696,
    "m_visibleEnemyParts": 28949,
    "m_voiceEndTimestamp": 30004,
    "m_waitForHostageTimer": 27112,
    "m_waitTimer": 26360,
    "m_wasSafe": 388,
    "m_wiggleTimer": 29864,
    "m_zoomTimer": 29592
  },
  "CCSGOViewModel": {
    "m_bShouldIgnoreOffsetAndAccuracy": 2264,
    "m_nOldWeaponParity": 2272,
    "m_nWeaponParity": 2268
  },
  "CCSGO_TeamPreviewCharacterPosition": {
    "m_agentItem": 1232,
    "m_glovesItem": 1864,
    "m_nOrdinal": 1208,
    "m_nRandom": 1204,
    "m_nVariant": 1200,
    "m_sWeaponName": 1216,
    "m_weaponItem": 2496,
    "m_xuid": 1224
  },
  "CCSGameModeRules": {
    "__m_pChainEntity": 8
  },
  "CCSGameModeRules_Deathmatch": {
    "m_bFirstThink": 48,
    "m_bFirstThinkAfterConnected": 49,
    "m_flDMBonusStartTime": 52,
    "m_flDMBonusTimeLength": 56,
    "m_nDMBonusWeaponLoadoutSlot": 60
  },
  "CCSGameRules": {
    "__m_pChainEntity": 152,
    "mTeamDMLastThinkTime": 3752,
    "mTeamDMLastWinningTeamNumber": 3748,
    "m_BtGlobalBlackboard": 5368,
    "m_CTSpawnPoints": 4000,
    "m_CTSpawnPointsMasterList": 3944,
    "m_GuardianBotSkillLevelMax": 5964,
    "m_GuardianBotSkillLevelMin": 5968,
    "m_MatchDevice": 308,
    "m_MinimapVerticalSectionHeights": 3336,
    "m_RetakeRules": 5480,
    "m_TeamRespawnWaveTimes": 3052,
    "m_TerroristSpawnPoints": 4024,
    "m_TerroristSpawnPointsMasterList": 3968,
    "m_arrFeaturedGiftersAccounts": 2416,
    "m_arrFeaturedGiftersGifts": 2432,
    "m_arrProhibitedItemIndices": 2448,
    "m_arrSelectedHostageSpawnIndices": 3536,
    "m_arrTeamUniqueKillWeaponsMatch": 5976,
    "m_arrTournamentActiveCasterAccounts": 2648,
    "m_bAllowWeaponSwitch": 4672,
    "m_bAnyHostageReached": 288,
    "m_bBombDefused": 3897,
    "m_bBombDropped": 2672,
    "m_bBombPlanted": 2673,
    "m_bBuyTimeEnded": 3888,
    "m_bCTCantBuy": 2685,
    "m_bCTTimeOutActive": 219,
    "m_bCanDonateWeapons": 3823,
    "m_bCompleteReset": 3561,
    "m_bDontIncrementCoopWave": 3368,
    "m_bFirstConnected": 3560,
    "m_bForceTeamChangeSilent": 3648,
    "m_bFreezePeriod": 196,
    "m_bGamePaused": 217,
    "m_bGameRestart": 256,
    "m_bHasHostageBeenTouched": 3488,
    "m_bHasMatchStarted": 312,
    "m_bHasTriggeredCoopSpawnReset": 5333,
    "m_bHasTriggeredRoundStartMusic": 5332,
    "m_bIsDroppingItems": 2380,
    "m_bIsHltvActive": 2382,
    "m_bIsQuestEligible": 2381,
    "m_bIsQueuedMatchmaking": 292,
    "m_bIsUnreservedGameServer": 4048,
    "m_bIsValveDS": 300,
    "m_bLevelInitialized": 3500,
    "m_bLoadingRoundBackupData": 3649,
    "m_bLogoMap": 301,
    "m_bMapHasBombTarget": 289,
    "m_bMapHasBombZone": 3898,
    "m_bMapHasBuyZone": 291,
    "m_bMapHasRescueZone": 290,
    "m_bMatchWaitingForResume": 237,
    "m_bNeedToAskPlayersForContinueVote": 3604,
    "m_bNoCTsKilled": 3821,
    "m_bNoEnemiesKilled": 3822,
    "m_bNoTerroristsKilled": 3820,
    "m_bPickNewTeamsOnReset": 3562,
    "m_bPlayAllStepSoundsOnServer": 302,
    "m_bPlayedTeamIntroVO": 6132,
    "m_bRoundTimeWarningTriggered": 4673,
    "m_bScrambleTeamsOnRestart": 3563,
    "m_bServerPaused": 216,
    "m_bServerVoteOnReset": 3881,
    "m_bSkipNextServerPerfSample": 22536,
    "m_bSpawnedTerrorHuntHeavy": 3369,
    "m_bSwapTeamsOnRestart": 3564,
    "m_bSwitchingTeamsAtRoundReset": 5334,
    "m_bTCantBuy": 2684,
    "m_bTargetBombed": 3896,
    "m_bTeamIntroPeriod": 6124,
    "m_bTeamLastKillUsedUniqueWeaponMatch": 6072,
    "m_bTechnicalTimeOut": 236,
    "m_bTerroristTimeOutActive": 218,
    "m_bVoiceWonMatchBragFired": 3796,
    "m_bVoteCalled": 3880,
    "m_bWarmupPeriod": 197,
    "m_coopBonusCoinsFound": 3740,
    "m_coopBonusPistolsOnly": 3744,
    "m_coopMissionDeadPlayerRespawnEnabled": 3746,
    "m_coopMissionManager": 192,
    "m_coopPlayersInDeploymentZone": 3745,
    "m_eRoundWinReason": 2680,
    "m_endMatchOnRoundReset": 3512,
    "m_endMatchOnThink": 3513,
    "m_fAccumulatedRoundOffDamage": 4688,
    "m_fAutobalanceDisplayTime": 4052,
    "m_fMatchStartTime": 244,
    "m_fNextUpdateTeamClanNamesTime": 4680,
    "m_fRoundStartTime": 248,
    "m_fTeamIntroPeriodEnd": 6128,
    "m_fWarmupNextChatNoticeTime": 3800,
    "m_fWarmupPeriodEnd": 200,
    "m_fWarmupPeriodStart": 204,
    "m_firstBloodTime": 3836,
    "m_firstKillTime": 3828,
    "m_flCMMItemDropRevealEndTime": 2376,
    "m_flCMMItemDropRevealStartTime": 2372,
    "m_flCTTimeOutRemaining": 224,
    "m_flCoopRespawnAndHealTime": 3736,
    "m_flGameStartTime": 260,
    "m_flGuardianBuyUntilTime": 2688,
    "m_flIntermissionEndTime": 3496,
    "m_flIntermissionStartTime": 3492,
    "m_flLastPerfSampleTime": 22528,
    "m_flLastThinkTime": 4684,
    "m_flMatchInfoDecidedTime": 3708,
    "m_flNextHostageAnnouncement": 3816,
    "m_flNextRespawnWave": 3180,
    "m_flRestartRoundTime": 252,
    "m_flTeamDMLastAnnouncementTime": 3756,
    "m_flTerroristTimeOutRemaining": 220,
    "m_flVoteCheckThrottle": 3884,
    "m_gamePhase": 268,
    "m_hPlayerResource": 5472,
    "m_hostageWasInjured": 3864,
    "m_hostageWasKilled": 3865,
    "m_iAccountCT": 3764,
    "m_iAccountTerrorist": 3760,
    "m_iFreezeTime": 3516,
    "m_iHostagesRemaining": 284,
    "m_iHostagesRescued": 3808,
    "m_iHostagesTouched": 3812,
    "m_iLoserBonus": 3784,
    "m_iLoserBonusMostRecentTeam": 3788,
    "m_iMatchStats_PlayersAlive_CT": 2812,
    "m_iMatchStats_PlayersAlive_T": 2932,
    "m_iMatchStats_RoundResults": 2692,
    "m_iMaxNumCTs": 3780,
    "m_iMaxNumTerrorists": 3776,
    "m_iNextCTSpawnPoint": 3992,
    "m_iNextTerroristSpawnPoint": 3996,
    "m_iNumCT": 3524,
    "m_iNumConsecutiveCTLoses": 3456,
    "m_iNumConsecutiveTerroristLoses": 3460,
    "m_iNumSpawnableCT": 3532,
    "m_iNumSpawnableTerrorist": 3528,
    "m_iNumTerrorist": 3520,
    "m_iRoundTime": 240,
    "m_iRoundWinStatus": 2676,
    "m_iSpawnPointCount_CT": 3772,
    "m_iSpawnPointCount_Terrorist": 3768,
    "m_iSpectatorSlotCount": 304,
    "m_iTotalRoundsPlayed": 3504,
    "m_iUnBalancedRounds": 3508,
    "m_nCTTeamIntroVariant": 6120,
    "m_nCTTimeOuts": 232,
    "m_nEndMatchMapGroupVoteOptions": 3412,
    "m_nEndMatchMapGroupVoteTypes": 3372,
    "m_nEndMatchMapVoteWinner": 3452,
    "m_nEndMatchTiedVotes": 3576,
    "m_nGuardianGrenadesToGiveBots": 2396,
    "m_nGuardianModeSpecialKillsRemaining": 2388,
    "m_nGuardianModeSpecialWeaponNeeded": 2392,
    "m_nGuardianModeWaveNumber": 2384,
    "m_nHalloweenMaskListSeed": 2668,
    "m_nLastFreezeEndBeep": 3892,
    "m_nMatchAbortedEarlyReason": 5328,
    "m_nMatchEndCount": 6112,
    "m_nMatchInfoShowType": 3704,
    "m_nNextMapInMapgroup": 316,
    "m_nNumHeaviesToSpawn": 2400,
    "m_nOvertimePlaying": 280,
    "m_nPauseStartTick": 212,
    "m_nQueuedMatchmakingMode": 296,
    "m_nRoundsPlayedThisPhase": 276,
    "m_nServerQuestID": 3308,
    "m_nShorthandedBonusLastEvalRound": 4692,
    "m_nTTeamIntroVariant": 6116,
    "m_nTerroristTimeOuts": 228,
    "m_nTotalPausedTicks": 208,
    "m_nTournamentPredictionsPct": 2368,
    "m_numBestOfMaps": 2664,
    "m_numGlobalGifters": 2408,
    "m_numGlobalGiftsGiven": 2404,
    "m_numGlobalGiftsPeriodSeconds": 2412,
    "m_numQueuedMatchmakingAccounts": 3608,
    "m_numSpectatorsCountMax": 3628,
    "m_numSpectatorsCountMaxLnk": 3636,
    "m_numSpectatorsCountMaxTV": 3632,
    "m_numTotalTournamentDrops": 3624,
    "m_pGameModeRules": 5360,
    "m_pQueuedMatchmakingReservationString": 3616,
    "m_phaseChangeAnnouncementTime": 4676,
    "m_szMatchStatTxt": 1344,
    "m_szTournamentEventName": 320,
    "m_szTournamentEventStage": 832,
    "m_szTournamentPredictionsTxt": 1856,
    "m_timeUntilNextPhaseStarts": 264,
    "m_tmNextPeriodicThink": 3792,
    "m_totalRoundsPlayed": 272,
    "m_vMinimapMaxs": 3324,
    "m_vMinimapMins": 3312,
    "m_vecMainCTSpawnPos": 3928
  },
  "CCSGameRulesProxy": {
    "m_pGameRules": 1200
  },
  "CCSPlace": {
    "m_name": 1800
  },
  "CCSPlayerBase_CameraServices": {
    "m_flFOVRate": 380,
    "m_flFOVTime": 376,
    "m_hLastFogTrigger": 416,
    "m_hTriggerFogList": 392,
    "m_hZoomOwner": 384,
    "m_iFOV": 368,
    "m_iFOVStart": 372
  },
  "CCSPlayerController": {
    "m_DesiredObserverMode": 1996,
    "m_LastTeamDamageWarningTime": 63736,
    "m_LastTimePlayerWasDisconnectedForPawnsRemove": 63740,
    "m_bAbandonAllowsSurrender": 1958,
    "m_bAbandonOffersInstantSurrender": 1959,
    "m_bAttemptedToGetColor": 1781,
    "m_bCanControlObservedBot": 1984,
    "m_bCannotBeKicked": 1956,
    "m_bControllingBot": 1976,
    "m_bDisconnection1MinWarningPrinted": 1960,
    "m_bEverFullyConnected": 1957,
    "m_bEverPlayedOnTeam": 1780,
    "m_bGaveTeamDamageWarning": 63722,
    "m_bGaveTeamDamageWarningThisRound": 63723,
    "m_bHasBeenControlledByPlayerThisRound": 1978,
    "m_bHasCommunicationAbuseMute": 1756,
    "m_bHasControlledBotThisRound": 1977,
    "m_bHasSeenJoinGame": 1790,
    "m_bInSwitchTeam": 1789,
    "m_bJustBecameSpectator": 1791,
    "m_bJustDidTeamKill": 63720,
    "m_bPawnHasDefuser": 2016,
    "m_bPawnHasHelmet": 2017,
    "m_bPawnIsAlive": 2004,
    "m_bPunishForTeamKill": 63721,
    "m_bRemoveAllItemsOnNextRoundReset": 1793,
    "m_bScoreReported": 1961,
    "m_bShowHints": 63712,
    "m_bSwitchTeamsOnNextRoundReset": 1792,
    "m_bTeamChanged": 1788,
    "m_dblLastReceivedPacketPlatFloatTime": 63728,
    "m_flForceTeamTime": 1772,
    "m_flSmoothedPing": 2080,
    "m_hDesiredObserverTarget": 2000,
    "m_hObserverPawn": 1992,
    "m_hOriginalControllerOfCurrentPawn": 2032,
    "m_hPlayerPawn": 1988,
    "m_iCoachingTeam": 1840,
    "m_iCompTeammateColor": 1776,
    "m_iCompetitiveRankType": 1872,
    "m_iCompetitiveRanking": 1864,
    "m_iCompetitiveRankingPredicted_Loss": 1880,
    "m_iCompetitiveRankingPredicted_Tie": 1884,
    "m_iCompetitiveRankingPredicted_Win": 1876,
    "m_iCompetitiveWins": 1868,
    "m_iDraftIndex": 1944,
    "m_iMVPs": 2072,
    "m_iNextTimeCheck": 63716,
    "m_iPawnArmor": 2012,
    "m_iPawnBotDifficulty": 2028,
    "m_iPawnHealth": 2008,
    "m_iPawnLifetimeEnd": 2024,
    "m_iPawnLifetimeStart": 2020,
    "m_iPendingTeamNum": 1768,
    "m_iPing": 1752,
    "m_iRoundScore": 2040,
    "m_iRoundsWon": 2044,
    "m_iScore": 2036,
    "m_iTeammatePreferredColor": 1784,
    "m_lastHeldVoteTimer": 63688,
    "m_msQueuedModeDisconnectionTimestamp": 1948,
    "m_nBotsControlledThisRound": 1980,
    "m_nDisconnectionTick": 1964,
    "m_nEndMatchNextMapVote": 1888,
    "m_nPawnCharacterDefIndex": 2018,
    "m_nPlayerDominated": 1848,
    "m_nPlayerDominatingMe": 1856,
    "m_nQuestProgressReason": 1896,
    "m_nUpdateCounter": 2076,
    "m_pActionTrackingServices": 1736,
    "m_pDamageServices": 1744,
    "m_pInGameMoneyServices": 1720,
    "m_pInventoryServices": 1728,
    "m_szClan": 1800,
    "m_szClanName": 1808,
    "m_szCrosshairCodes": 1760,
    "m_uiAbandonRecordedReason": 1952,
    "m_unActiveQuestId": 1892,
    "m_unPlayerTvControlFlags": 1900,
    "m_vecKills": 2048
  },
  "CCSPlayerController_ActionTrackingServices": {
    "m_iNumRoundKills": 328,
    "m_iNumRoundKillsHeadshots": 332,
    "m_matchStats": 144,
    "m_perRoundStats": 64,
    "m_unTotalRoundDamageDealt": 336
  },
  "CCSPlayerController_DamageServices": {
    "m_DamageList": 72,
    "m_nSendUpdate": 64
  },
  "CCSPlayerController_InGameMoneyServices": {
    "m_bReceivesMoneyNextRound": 64,
    "m_iAccount": 72,
    "m_iAccountMoneyEarnedForNextRound": 68,
    "m_iCashSpentThisRound": 84,
    "m_iStartAccount": 76,
    "m_iTotalCashSpent": 80
  },
  "CCSPlayerController_InventoryServices": {
    "m_nPersonaDataPublicCommendsFriendly": 104,
    "m_nPersonaDataPublicCommendsLeader": 96,
    "m_nPersonaDataPublicCommendsTeacher": 100,
    "m_nPersonaDataPublicLevel": 92,
    "m_rank": 68,
    "m_unEquippedPlayerSprayIDs": 3912,
    "m_unMusicID": 64,
    "m_vecServerAuthoritativeWeaponSlots": 3920
  },
  "CCSPlayerPawn": {
    "m_EconGloves": 7408,
    "m_RetakesMVPBoostExtraUtility": 5752,
    "m_aimPunchAngle": 5764,
    "m_aimPunchAngleVel": 5776,
    "m_aimPunchCache": 5800,
    "m_aimPunchTickBase": 5788,
    "m_aimPunchTickFraction": 5792,
    "m_bHasFemaleVoice": 5520,
    "m_bInBombZone": 5732,
    "m_bInBuyZone": 5729,
    "m_bInHostageRescueZone": 5731,
    "m_bInHostageResetZone": 5728,
    "m_bIsBuyMenuOpen": 5824,
    "m_bLastHeadBoneTransformIsValid": 7264,
    "m_bNextSprayDecalTimeExpedited": 7292,
    "m_bOnGroundLastTick": 7272,
    "m_bRagdollDamageHeadshot": 7388,
    "m_bRetakesHasDefuseKit": 5744,
    "m_bRetakesMVPLastRound": 5745,
    "m_bSkipOneHeadConstraintUpdate": 8052,
    "m_bWasInBuyZone": 5730,
    "m_bWasInHostageRescueZone": 5733,
    "m_flHealthShotBoostExpirationTime": 5756,
    "m_flLandseconds": 5760,
    "m_flNextSprayDecalTime": 7288,
    "m_flTimeOfLastInjury": 7284,
    "m_hPreviousModel": 5512,
    "m_iPlayerLocked": 7276,
    "m_iRetakesMVPBoostItem": 5748,
    "m_iRetakesOffering": 5736,
    "m_iRetakesOfferingCard": 5740,
    "m_lastLandTime": 7268,
    "m_nCharacterDefIndex": 5504,
    "m_nRagdollDamageBone": 7296,
    "m_pActionTrackingServices": 5480,
    "m_pBulletServices": 5456,
    "m_pBuyServices": 5472,
    "m_pDamageReactServices": 5496,
    "m_pHostageServices": 5464,
    "m_pRadioServices": 5488,
    "m_qDeathEyeAngles": 8040,
    "m_strVOPrefix": 5528,
    "m_szLastPlaceName": 5536,
    "m_szRagdollDamageWeaponName": 7324,
    "m_vRagdollDamageForce": 7300,
    "m_vRagdollDamagePosition": 7312,
    "m_vRagdollServerOrigin": 7392,
    "m_xLastHeadBoneTransform": 7232
  },
  "CCSPlayerPawnBase": {
    "m_ArmorValue": 4628,
    "m_CTouchExpansionComponent": 2920,
    "m_LastHealth": 5424,
    "m_LastHitBox": 5420,
    "m_MenuStringBuffer": 3448,
    "m_NumEnemiesAtRoundStart": 4892,
    "m_NumEnemiesKilledThisRound": 4888,
    "m_NumEnemiesKilledThisSpawn": 4884,
    "m_allowAutoFollowTime": 3036,
    "m_angEyeAngles": 4804,
    "m_angShootAngleHistory": 4532,
    "m_angStashedShootAngles": 4496,
    "m_bBotAllowActive": 5448,
    "m_bCanMoveDuringFreezePeriod": 3349,
    "m_bCommittingSuicideOnTeamChange": 5449,
    "m_bDiedAirborne": 4604,
    "m_bGrenadeParametersStashed": 4492,
    "m_bGunGameImmunity": 3340,
    "m_bHasDeathInfo": 5396,
    "m_bHasMovedSinceSpawn": 3348,
    "m_bHasNightVision": 3436,
    "m_bHideTargetID": 4845,
    "m_bHud_MiniScoreHidden": 4852,
    "m_bHud_RadarHidden": 4853,
    "m_bInBombZoneTrigger": 4616,
    "m_bInNoDefuseArea": 4480,
    "m_bInvalidSteamLogonDelayed": 3400,
    "m_bIsDefusing": 3327,
    "m_bIsGrabbingHostage": 3328,
    "m_bIsScoped": 3324,
    "m_bIsSpawning": 4844,
    "m_bIsWalking": 3325,
    "m_bKilledByHeadshot": 5416,
    "m_bKilledByTaser": 4481,
    "m_bNightVisionOn": 3437,
    "m_bResetArmorNextSpawn": 3380,
    "m_bRespawning": 3312,
    "m_bResumeZoom": 3326,
    "m_bStrafing": 4688,
    "m_bVCollisionInitted": 4816,
    "m_bWaitForNoAttack": 4680,
    "m_bWasInBombZoneTrigger": 4617,
    "m_blindStartTime": 3032,
    "m_blindUntilTime": 3028,
    "m_chickenIdleSoundTimer": 3080,
    "m_chickenJumpSoundTimer": 3104,
    "m_currentDeafnessFilter": 4880,
    "m_entitySpottedState": 3040,
    "m_fImmuneToGunGameDamageTime": 3336,
    "m_fIntroCamTime": 4472,
    "m_fLastGivenBombTime": 3432,
    "m_fLastGivenDefuserTime": 3428,
    "m_fMolotovDamageTime": 3344,
    "m_fNextRadarUpdateTime": 3440,
    "m_flAccumulatedDistanceTraveled": 3304,
    "m_flDealtDamageToEnemyMostRecentTimestamp": 3364,
    "m_flDeathInfoTime": 5400,
    "m_flDetectedByEnemySensorTime": 3360,
    "m_flEmitSoundTime": 3388,
    "m_flFlashDuration": 4664,
    "m_flFlashMaxAlpha": 4668,
    "m_flFlinchStack": 4632,
    "m_flGuardianTooFarDistFrac": 3352,
    "m_flHitHeading": 4640,
    "m_flLastAction": 3404,
    "m_flLastAttackedTeammate": 3020,
    "m_flLastBumpMineBumpTime": 3384,
    "m_flLastCollisionCeiling": 5428,
    "m_flLastCollisionCeilingChangeTime": 5432,
    "m_flLastDistanceTraveledNotice": 3300,
    "m_flLastEquippedArmorTime": 3372,
    "m_flLastEquippedHelmetTime": 3368,
    "m_flLastFriendlyFireDamageReductionRatio": 3308,
    "m_flLastMoneyUpdateTime": 3444,
    "m_flLastPickupPriorityTime": 3320,
    "m_flLowerBodyYawTarget": 4684,
    "m_flNameChangeHistory": 3408,
    "m_flNextGuardianTooFarHurtTime": 3356,
    "m_flProgressBarStartTime": 4672,
    "m_flSlopeDropHeight": 4776,
    "m_flSlopeDropOffset": 4772,
    "m_flVelocityModifier": 4636,
    "m_grenadeParameterStashTime": 4488,
    "m_hOriginalController": 3024,
    "m_hPet": 4924,
    "m_iAddonBits": 4868,
    "m_iBlockingUseActionInProgress": 3332,
    "m_iBombSiteIndex": 4608,
    "m_iDeathFlags": 4920,
    "m_iDirection": 4620,
    "m_iDisplayHistoryBits": 3016,
    "m_iHostagesKilled": 4648,
    "m_iLastWeaponFireUsercmd": 4800,
    "m_iMoveState": 4484,
    "m_iNumSpawns": 3392,
    "m_iPlayerState": 3068,
    "m_iPrimaryAddon": 4872,
    "m_iProgressBarDuration": 4676,
    "m_iSecondaryAddon": 4876,
    "m_iShotsFired": 4624,
    "m_iShouldHaveCash": 3396,
    "m_ignoreLadderJumpTime": 4704,
    "m_ladderSurpressionTimer": 4712,
    "m_lastLadderNormal": 4736,
    "m_lastLadderPos": 4748,
    "m_lastStandingPos": 4692,
    "m_nDeathCamMusic": 4864,
    "m_nHeavyAssaultSuitCooldownRemaining": 3376,
    "m_nHitBodyPart": 4644,
    "m_nLastConcurrentKilled": 4860,
    "m_nLastKillerIndex": 4856,
    "m_nLastPickupPriority": 3316,
    "m_nMyCollisionGroup": 4476,
    "m_nNumDangerZoneDamageHits": 4848,
    "m_nSpotRules": 3064,
    "m_nSurvivalTeamNumber": 5392,
    "m_nWhichBombZone": 4612,
    "m_pBot": 5440,
    "m_pPingServices": 3000,
    "m_pViewModelServices": 3008,
    "m_storedSpawnAngle": 4832,
    "m_storedSpawnPosition": 4820,
    "m_thirdPersonHeading": 4760,
    "m_unCurrentEquipmentValue": 5384,
    "m_unFreezetimeEndEquipmentValue": 5388,
    "m_unRoundStartEquipmentValue": 5386,
    "m_vHeadConstraintOffset": 4780,
    "m_vecDeathInfoOrigin": 5404,
    "m_vecLastBookmarkedPosition": 3288,
    "m_vecPlayerPatchEconIndices": 4900,
    "m_vecStashedGrenadeThrowPosition": 4508,
    "m_vecStashedVelocity": 4520,
    "m_vecThrowPositionHistory": 4556,
    "m_vecTotalBulletForce": 4652,
    "m_vecVelocityHistory": 4580,
    "m_wasNotKilledNaturally": 4896
  },
  "CCSPlayerResource": {
    "m_bEndMatchNextMapAllVoted": 1344,
    "m_bHostageAlive": 1200,
    "m_bombsiteCenterA": 1272,
    "m_bombsiteCenterB": 1284,
    "m_foundGoalPositions": 1345,
    "m_hostageRescueX": 1296,
    "m_hostageRescueY": 1312,
    "m_hostageRescueZ": 1328,
    "m_iHostageEntityIDs": 1224,
    "m_isHostageFollowingSomeone": 1212
  },
  "CCSPlayer_ActionTrackingServices": {
    "m_bIsRescuing": 572,
    "m_hLastWeaponBeforeC4AutoSwitch": 520,
    "m_weaponPurchasesThisMatch": 576,
    "m_weaponPurchasesThisRound": 664
  },
  "CCSPlayer_BulletServices": {
    "m_totalHitsOnServer": 64
  },
  "CCSPlayer_BuyServices": {
    "m_vecSellbackPurchaseEntries": 200
  },
  "CCSPlayer_HostageServices": {
    "m_hCarriedHostage": 64,
    "m_hCarriedHostageProp": 68
  },
  "CCSPlayer_ItemServices": {
    "m_bHasDefuser": 64,
    "m_bHasHeavyArmor": 66,
    "m_bHasHelmet": 65
  },
  "CCSPlayer_MovementServices": {
    "m_StuckLast": 1148,
    "m_bDesiresDuck": 573,
    "m_bDuckOverride": 572,
    "m_bHasWalkMovedSinceLastJump": 617,
    "m_bInStuckTest": 618,
    "m_bMadeFootstepNoise": 1212,
    "m_bOldJumpPressed": 1220,
    "m_bSpeedCropped": 1152,
    "m_duckUntilOnGround": 616,
    "m_fStashGrenadeParameterWhen": 1236,
    "m_flDuckAmount": 564,
    "m_flDuckOffset": 576,
    "m_flDuckSpeed": 568,
    "m_flHeightAtJumpStart": 1260,
    "m_flJumpPressedTime": 1224,
    "m_flJumpUntil": 1228,
    "m_flJumpVel": 1232,
    "m_flLastDuckTime": 592,
    "m_flMaxFallVelocity": 544,
    "m_flMaxJumpHeightThisJump": 1264,
    "m_flOffsetTickCompleteTime": 1248,
    "m_flOffsetTickStashedSpeed": 1252,
    "m_flStamina": 1256,
    "m_flStuckCheckTime": 632,
    "m_flWaterEntryTime": 1160,
    "m_iFootsteps": 1216,
    "m_nButtonDownMaskPrev": 1240,
    "m_nDuckJumpTimeMsecs": 584,
    "m_nDuckTimeMsecs": 580,
    "m_nJumpTimeMsecs": 588,
    "m_nLadderSurfacePropIndex": 560,
    "m_nOldWaterLevel": 1156,
    "m_nTraceCount": 1144,
    "m_vecForward": 1164,
    "m_vecLadderNormal": 548,
    "m_vecLastPositionAtFullCrouchSpeed": 608,
    "m_vecLeft": 1176,
    "m_vecPreviouslyPredictedOrigin": 1200,
    "m_vecUp": 1188
  },
  "CCSPlayer_PingServices": {
    "m_flPlayerPingTokens": 64,
    "m_hPlayerPing": 84
  },
  "CCSPlayer_RadioServices": {
    "m_bIgnoreRadio": 88,
    "m_flC4PlantTalkTimer": 72,
    "m_flDefusingTalkTimer": 68,
    "m_flGotHostageTalkTimer": 64,
    "m_flRadioTokenSlots": 76
  },
  "CCSPlayer_UseServices": {
    "m_flLastUseTimeStamp": 68,
    "m_flTimeLastUsedWindow": 76,
    "m_flTimeStartedHoldingUse": 72,
    "m_hLastKnownUseEntity": 64
  },
  "CCSPlayer_ViewModelServices": {
    "m_hViewModel": 64
  },
  "CCSPlayer_WaterServices": {
    "m_AirFinishedTime": 72,
    "m_NextDrownDamageTime": 64,
    "m_flSwimSoundTime": 92,
    "m_flWaterJumpTime": 76,
    "m_nDrownDmgRate": 68,
    "m_vecWaterJumpVel": 80
  },
  "CCSPlayer_WeaponServices": {
    "m_bIsBeingGivenItem": 204,
    "m_bIsHoldingLookAtWeapon": 181,
    "m_bIsLookingAtWeapon": 180,
    "m_bIsPickingUpItemWithUse": 205,
    "m_bPickedUpWeapon": 206,
    "m_flNextAttack": 176,
    "m_hSavedWeapon": 184,
    "m_nTimeToMelee": 188,
    "m_nTimeToPrimary": 196,
    "m_nTimeToSecondary": 192,
    "m_nTimeToSniperRifle": 200
  },
  "CCSTeam": {
    "m_bSurrendered": 1392,
    "m_flNextResourceTime": 2076,
    "m_iClanID": 2056,
    "m_iLastUpdateSentAt": 2080,
    "m_nLastRecievedShorthandedRoundBonus": 1384,
    "m_nShorthandedRoundBonusStartRound": 1388,
    "m_numMapVictories": 1908,
    "m_scoreFirstHalf": 1912,
    "m_scoreOvertime": 1920,
    "m_scoreSecondHalf": 1916,
    "m_szClanTeamname": 1924,
    "m_szTeamFlagImage": 2060,
    "m_szTeamLogoImage": 2068,
    "m_szTeamMatchStat": 1393
  },
  "CCSWeaponBase": {
    "m_IronSightController": 3576,
    "m_OnPlayerPickup": 3368,
    "m_bBurstMode": 3456,
    "m_bCanBePickedUp": 3504,
    "m_bFireOnEmpty": 3364,
    "m_bFiredOutOfAmmoEvent": 3566,
    "m_bInReload": 3464,
    "m_bIsHauledBack": 3472,
    "m_bPlayerAmmoStockOnPickup": 3312,
    "m_bPlayerFireEventIsPrimary": 3228,
    "m_bReloadVisuallyComplete": 3465,
    "m_bReloadsWithClips": 3332,
    "m_bRemoveable": 3208,
    "m_bRequireUseToTouch": 3313,
    "m_bSilencerOn": 3473,
    "m_bUseCanOverrideNextOwnerTouchTime": 3505,
    "m_bWasOwnedByCT": 3564,
    "m_bWasOwnedByTerrorist": 3565,
    "m_donated": 3556,
    "m_fAccuracyPenalty": 3432,
    "m_fAccuracySmoothedForZoom": 3440,
    "m_fLastShotTime": 3560,
    "m_fScopeZoomEndTime": 3444,
    "m_flDroppedAtTime": 3468,
    "m_flFireSequenceStartTime": 3216,
    "m_flLastAccuracyUpdateTime": 3436,
    "m_flLastDeployTime": 3324,
    "m_flLastLOSTraceFailureTime": 3604,
    "m_flLastTimeInAir": 3320,
    "m_flNextAttackRenderTimeOffset": 3484,
    "m_flPostponeFireReadyTime": 3460,
    "m_flRecoilIndex": 3452,
    "m_flTimeSilencerSwitchComplete": 3476,
    "m_flTimeWeaponIdle": 3360,
    "m_flTurningInaccuracy": 3428,
    "m_flTurningInaccuracyDelta": 3412,
    "m_hCurrentThirdPersonSequence": 3272,
    "m_hPrevOwner": 3516,
    "m_iIronSightMode": 3600,
    "m_iNumEmptyAttacks": 3608,
    "m_iOriginalTeamNumber": 3480,
    "m_iRecoilIndex": 3448,
    "m_iState": 3316,
    "m_nDropTick": 3520,
    "m_nFireSequenceStartTimeAck": 3224,
    "m_nFireSequenceStartTimeChange": 3220,
    "m_nSilencerBoneIndex": 3276,
    "m_nViewModelIndex": 3328,
    "m_nextOwnerTouchTime": 3508,
    "m_nextPrevOwnerTouchTime": 3512,
    "m_numRemoveUnownedWeaponThink": 3568,
    "m_seqFirePrimary": 3236,
    "m_seqFireSecondary": 3240,
    "m_seqIdle": 3232,
    "m_thirdPersonFireSequences": 3248,
    "m_thirdPersonSequences": 3280,
    "m_vecTurningInaccuracyEyeDirLast": 3416,
    "m_weaponMode": 3408
  },
  "CCSWeaponBaseGun": {
    "m_bNeedsBoltAction": 3637,
    "m_bSkillBoltInterruptAvailable": 3640,
    "m_bSkillBoltLiftedFireKey": 3641,
    "m_bSkillReloadAvailable": 3638,
    "m_bSkillReloadLiftedReloadKey": 3639,
    "m_iBurstShotsRemaining": 3620,
    "m_inPrecache": 3636,
    "m_silencedModelIndex": 3632,
    "m_zoomLevel": 3616
  },
  "CCSWeaponBaseVData": {
    "m_DefaultLoadoutSlot": 3056,
    "m_GearSlot": 3048,
    "m_GearSlotPosition": 3052,
    "m_WeaponCategory": 580,
    "m_WeaponType": 576,
    "m_angPivotAngle": 3352,
    "m_bCannotShootUnderwater": 3091,
    "m_bHasBurstMode": 3089,
    "m_bHideViewModelWhenZoomed": 3305,
    "m_bIsRevolver": 3090,
    "m_bMeleeWeapon": 3088,
    "m_bUnzoomsAfterShot": 3304,
    "m_eSilencerType": 3112,
    "m_flArmorRatio": 3384,
    "m_flAttackMovespeedFactor": 3272,
    "m_flBotAudibleRange": 3288,
    "m_flCycleTime": 3124,
    "m_flFlinchVelocityModifierLarge": 3400,
    "m_flFlinchVelocityModifierSmall": 3404,
    "m_flHeadshotMultiplier": 3380,
    "m_flHeatPerShot": 3276,
    "m_flIdleInterval": 3268,
    "m_flInaccuracyAltSoundThreshold": 3284,
    "m_flInaccuracyCrouch": 3148,
    "m_flInaccuracyFire": 3188,
    "m_flInaccuracyJump": 3164,
    "m_flInaccuracyJumpApex": 3248,
    "m_flInaccuracyJumpInitial": 3244,
    "m_flInaccuracyLadder": 3180,
    "m_flInaccuracyLand": 3172,
    "m_flInaccuracyMove": 3196,
    "m_flInaccuracyPitchShift": 3280,
    "m_flInaccuracyReload": 3252,
    "m_flInaccuracyStand": 3156,
    "m_flIronSightFOV": 3340,
    "m_flIronSightLooseness": 3348,
    "m_flIronSightPivotForward": 3344,
    "m_flIronSightPullUpSpeed": 3332,
    "m_flIronSightPutDownSpeed": 3336,
    "m_flMaxSpeed": 3132,
    "m_flPenetration": 3388,
    "m_flRange": 3392,
    "m_flRangeModifier": 3396,
    "m_flRecoilAngle": 3204,
    "m_flRecoilAngleVariance": 3212,
    "m_flRecoilMagnitude": 3220,
    "m_flRecoilMagnitudeVariance": 3228,
    "m_flRecoveryTimeCrouch": 3408,
    "m_flRecoveryTimeCrouchFinal": 3416,
    "m_flRecoveryTimeStand": 3412,
    "m_flRecoveryTimeStandFinal": 3420,
    "m_flSpread": 3140,
    "m_flThrowVelocity": 3432,
    "m_flTimeToIdleAfterFire": 3264,
    "m_flZoomTime0": 3320,
    "m_flZoomTime1": 3324,
    "m_flZoomTime2": 3328,
    "m_nCrosshairDeltaDistance": 3120,
    "m_nCrosshairMinDistance": 3116,
    "m_nDamage": 3376,
    "m_nKillAward": 3076,
    "m_nPrice": 3072,
    "m_nPrimaryReserveAmmoMax": 3080,
    "m_nRecoilSeed": 3256,
    "m_nRecoveryTransitionEndBullet": 3428,
    "m_nRecoveryTransitionStartBullet": 3424,
    "m_nSecondaryReserveAmmoMax": 3084,
    "m_nSpreadSeed": 3260,
    "m_nTracerFrequency": 3236,
    "m_nZoomFOV1": 3312,
    "m_nZoomFOV2": 3316,
    "m_nZoomLevels": 3308,
    "m_sWrongTeamMsg": 3064,
    "m_szAimsightLensMaskModel": 1256,
    "m_szAnimClass": 3448,
    "m_szAnimExtension": 3104,
    "m_szEjectBrassEffect": 1928,
    "m_szHeatEffect": 1704,
    "m_szMagazineModel": 1480,
    "m_szMuzzleFlashParticleAlt": 2152,
    "m_szMuzzleFlashThirdPersonParticle": 2376,
    "m_szMuzzleFlashThirdPersonParticleAlt": 2600,
    "m_szName": 3096,
    "m_szPlayerModel": 808,
    "m_szTracerParticle": 2824,
    "m_szUseRadioSubtitle": 3296,
    "m_szViewModel": 584,
    "m_szWorldDroppedModel": 1032,
    "m_vSmokeColor": 3436,
    "m_vecIronSightEyePos": 3364
  },
  "CChangeLevel": {
    "m_OnChangeLevel": 2232,
    "m_bNewChapter": 2274,
    "m_bNoTouch": 2273,
    "m_bOnChangeLevelFired": 2275,
    "m_bTouched": 2272,
    "m_sLandmarkName": 2224,
    "m_sMapName": 2216
  },
  "CChicken": {
    "m_AttributeManager": 2856,
    "m_BlockDirectionTimer": 12360,
    "m_OriginalOwnerXuidHigh": 3572,
    "m_OriginalOwnerXuidLow": 3568,
    "m_activity": 3680,
    "m_activityTimer": 3688,
    "m_bInJump": 3868,
    "m_collisionStuckTimer": 3640,
    "m_flActiveFollowStartTime": 12284,
    "m_flLastJumpTime": 3864,
    "m_flWhenZombified": 3792,
    "m_fleeFrom": 3716,
    "m_followMinuteTimer": 12288,
    "m_hasBeenUsed": 3832,
    "m_inhibitDoorTimer": 12096,
    "m_inhibitObstacleAvoidanceTimer": 12240,
    "m_isOnGround": 3664,
    "m_isWaitingForLeader": 3869,
    "m_jumpTimer": 3840,
    "m_jumpedThisFrame": 3796,
    "m_leader": 3800,
    "m_moveRateThrottleTimer": 3720,
    "m_repathTimer": 12072,
    "m_reuseTimer": 3808,
    "m_startleTimer": 3744,
    "m_stuckAnchor": 3600,
    "m_stuckTimer": 3616,
    "m_turnRate": 3712,
    "m_updateTimer": 3576,
    "m_vFallVelocity": 3668,
    "m_vecEggsPooped": 12328,
    "m_vecLastEggPoopPosition": 12312,
    "m_vecPathGoal": 12272,
    "m_vocalizeTimer": 3768
  },
  "CCollisionProperty": {
    "m_CollisionGroup": 94,
    "m_collisionAttribute": 16,
    "m_flBoundingRadius": 96,
    "m_flCapsuleRadius": 172,
    "m_nEnablePhysics": 95,
    "m_nSolidType": 91,
    "m_nSurroundType": 93,
    "m_triggerBloat": 92,
    "m_usSolidFlags": 90,
    "m_vCapsuleCenter1": 148,
    "m_vCapsuleCenter2": 160,
    "m_vecMaxs": 76,
    "m_vecMins": 64,
    "m_vecSpecifiedSurroundingMaxs": 112,
    "m_vecSpecifiedSurroundingMins": 100,
    "m_vecSurroundingMaxs": 124,
    "m_vecSurroundingMins": 136
  },
  "CColorCorrection": {
    "m_MaxFalloff": 1240,
    "m_MinFalloff": 1236,
    "m_bClientSide": 1231,
    "m_bEnabled": 1229,
    "m_bExclusive": 1232,
    "m_bMaster": 1230,
    "m_bStartDisabled": 1228,
    "m_flCurWeight": 1244,
    "m_flFadeInDuration": 1200,
    "m_flFadeOutDuration": 1204,
    "m_flMaxWeight": 1224,
    "m_flStartFadeInWeight": 1208,
    "m_flStartFadeOutWeight": 1212,
    "m_flTimeStartFadeIn": 1216,
    "m_flTimeStartFadeOut": 1220,
    "m_lookupFilename": 1760,
    "m_netlookupFilename": 1248
  },
  "CColorCorrectionVolume": {
    "m_FadeDuration": 2224,
    "m_LastEnterTime": 2752,
    "m_LastEnterWeight": 2748,
    "m_LastExitTime": 2760,
    "m_LastExitWeight": 2756,
    "m_MaxWeight": 2220,
    "m_Weight": 2232,
    "m_bEnabled": 2216,
    "m_bStartDisabled": 2228,
    "m_lookupFilename": 2236
  },
  "CCommentaryAuto": {
    "m_OnCommentaryMidGame": 1240,
    "m_OnCommentaryMultiplayerSpawn": 1280,
    "m_OnCommentaryNewGame": 1200
  },
  "CCommentarySystem": {
    "m_bCheatState": 28,
    "m_bCommentaryConvarsChanging": 17,
    "m_bCommentaryEnabledMidGame": 18,
    "m_bIsFirstSpawnGroupToLoad": 29,
    "m_flNextTeleportTime": 20,
    "m_hActiveCommentaryNode": 60,
    "m_hCurrentNode": 56,
    "m_hLastCommentaryNode": 64,
    "m_iTeleportStage": 24,
    "m_vecNodes": 72
  },
  "CConstantForceController": {
    "m_angular": 24,
    "m_angularSave": 48,
    "m_linear": 12,
    "m_linearSave": 36
  },
  "CConstraintAnchor": {
    "m_massScale": 2192
  },
  "CCopyRecipientFilter": {
    "m_Flags": 8,
    "m_Recipients": 16
  },
  "CCredits": {
    "m_OnCreditsDone": 1200,
    "m_bRolledOutroCredits": 1240,
    "m_flLogoLength": 1244
  },
  "CDamageRecord": {
    "m_DamagerXuid": 72,
    "m_PlayerDamager": 40,
    "m_PlayerRecipient": 44,
    "m_RecipientXuid": 80,
    "m_bIsOtherEnemy": 104,
    "m_hPlayerControllerDamager": 48,
    "m_hPlayerControllerRecipient": 52,
    "m_iActualHealthRemoved": 92,
    "m_iDamage": 88,
    "m_iLastBulletUpdate": 100,
    "m_iNumHits": 96,
    "m_killType": 105,
    "m_szPlayerDamagerName": 56,
    "m_szPlayerRecipientName": 64
  },
  "CDebugHistory": {
    "m_nNpcEvents": 17648
  },
  "CDecoyProjectile": {
    "m_decoyWeaponDefIndex": 2656,
    "m_fExpireTime": 2640,
    "m_nDecoyShotTick": 2632,
    "m_shotsRemaining": 2636
  },
  "CDynamicLight": {
    "m_ActualFlags": 1792,
    "m_Exponent": 1800,
    "m_Flags": 1793,
    "m_InnerAngle": 1804,
    "m_LightStyle": 1794,
    "m_On": 1795,
    "m_OuterAngle": 1808,
    "m_Radius": 1796,
    "m_SpotRadius": 1812
  },
  "CDynamicProp": {
    "m_OnAnimReachedEnd": 2744,
    "m_OnAnimReachedStart": 2704,
    "m_bAnimateOnServer": 2796,
    "m_bCreateNavObstacle": 2576,
    "m_bCreateNonSolid": 2802,
    "m_bFiredStartEndOutput": 2800,
    "m_bForceNpcExclude": 2801,
    "m_bIsOverrideProp": 2803,
    "m_bRandomizeCycle": 2797,
    "m_bScriptedMovement": 2799,
    "m_bStartDisabled": 2798,
    "m_bUseAnimGraph": 2578,
    "m_bUseHitboxesForRenderBox": 2577,
    "m_glowColor": 2816,
    "m_iInitialGlowState": 2804,
    "m_iszDefaultAnim": 2784,
    "m_nDefaultAnimLoopMode": 2792,
    "m_nGlowRange": 2808,
    "m_nGlowRangeMin": 2812,
    "m_nGlowTeam": 2820,
    "m_pOutputAnimBegun": 2584,
    "m_pOutputAnimLoopCycleOver": 2664,
    "m_pOutputAnimOver": 2624
  },
  "CEconEntity": {
    "m_AttributeManager": 2352,
    "m_OriginalOwnerXuidHigh": 3068,
    "m_OriginalOwnerXuidLow": 3064,
    "m_flFallbackWear": 3080,
    "m_hOldProvidee": 3088,
    "m_iOldOwnerClass": 3092,
    "m_nFallbackPaintKit": 3072,
    "m_nFallbackSeed": 3076,
    "m_nFallbackStatTrak": 3084
  },
  "CEconItemAttribute": {
    "m_bSetBonus": 64,
    "m_flInitialValue": 56,
    "m_flValue": 52,
    "m_iAttributeDefinitionIndex": 48,
    "m_nRefundableCurrency": 60
  },
  "CEconItemView": {
    "m_AttributeList": 112,
    "m_NetworkedDynamicAttributes": 208,
    "m_bInitialized": 104,
    "m_iAccountID": 88,
    "m_iEntityLevel": 64,
    "m_iEntityQuality": 60,
    "m_iInventoryPosition": 92,
    "m_iItemDefinitionIndex": 56,
    "m_iItemID": 72,
    "m_iItemIDHigh": 80,
    "m_iItemIDLow": 84,
    "m_szCustomName": 304,
    "m_szCustomNameOverride": 465
  },
  "CEconWearable": {
    "m_bAlwaysAllow": 3100,
    "m_nForceSkin": 3096
  },
  "CEffectData": {
    "m_fFlags": 99,
    "m_flMagnitude": 68,
    "m_flRadius": 72,
    "m_flScale": 64,
    "m_hEntity": 56,
    "m_hOtherEntity": 60,
    "m_iEffectName": 108,
    "m_nAttachmentIndex": 100,
    "m_nAttachmentName": 104,
    "m_nColor": 98,
    "m_nDamageType": 88,
    "m_nEffectIndex": 80,
    "m_nExplosionType": 110,
    "m_nHitBox": 96,
    "m_nMaterial": 94,
    "m_nPenetrate": 92,
    "m_nSurfaceProp": 76,
    "m_vAngles": 44,
    "m_vNormal": 32,
    "m_vOrigin": 8,
    "m_vStart": 20
  },
  "CEntityDissolve": {
    "m_flFadeInLength": 1796,
    "m_flFadeInStart": 1792,
    "m_flFadeOutLength": 1812,
    "m_flFadeOutModelLength": 1804,
    "m_flFadeOutModelStart": 1800,
    "m_flFadeOutStart": 1808,
    "m_flStartTime": 1816,
    "m_nDissolveType": 1820,
    "m_nMagnitude": 1836,
    "m_vDissolverOrigin": 1824
  },
  "CEntityFlame": {
    "m_bCheapEffect": 1204,
    "m_bUseHitboxes": 1212,
    "m_flDirectDamagePerSecond": 1236,
    "m_flHitboxFireScale": 1220,
    "m_flLifetime": 1224,
    "m_flSize": 1208,
    "m_hAttacker": 1228,
    "m_hEntAttached": 1200,
    "m_iCustomDamageType": 1240,
    "m_iDangerSound": 1232,
    "m_iNumHitboxFires": 1216
  },
  "CEntityIdentity": {
    "m_PathIndex": 64,
    "m_designerName": 32,
    "m_fDataObjectTypes": 60,
    "m_flags": 48,
    "m_name": 24,
    "m_nameStringableIndex": 20,
    "m_pNext": 96,
    "m_pNextByClass": 112,
    "m_pPrev": 88,
    "m_pPrevByClass": 104,
    "m_worldGroupId": 56
  },
  "CEntityInstance": {
    "m_CScriptComponent": 40,
    "m_iszPrivateVScripts": 8,
    "m_pEntity": 16
  },
  "CEnvBeam": {
    "m_OnTouchedByEntity": 2080,
    "m_TouchType": 2048,
    "m_active": 1952,
    "m_boltWidth": 1988,
    "m_frameStart": 2016,
    "m_hFilter": 2064,
    "m_iFilterName": 2056,
    "m_iszDecal": 2072,
    "m_iszEndEntity": 1976,
    "m_iszSpriteName": 2008,
    "m_iszStartEntity": 1968,
    "m_life": 1984,
    "m_noiseAmplitude": 1992,
    "m_radius": 2044,
    "m_restrike": 2000,
    "m_speed": 1996,
    "m_spriteTexture": 1960,
    "m_vEndPointRelative": 2032,
    "m_vEndPointWorld": 2020
  },
  "CEnvBeverage": {
    "m_CanInDispenser": 1200,
    "m_nBeverageType": 1204
  },
  "CEnvCombinedLightProbeVolume": {
    "m_Color": 5384,
    "m_bCustomCubemapTexture": 5400,
    "m_bEnabled": 5545,
    "m_bMoveable": 5464,
    "m_bStartDisabled": 5480,
    "m_flBrightness": 5388,
    "m_flEdgeFadeDist": 5484,
    "m_hCubemapTexture": 5392,
    "m_hLightProbeDirectLightIndicesTexture": 5416,
    "m_hLightProbeDirectLightScalarsTexture": 5424,
    "m_hLightProbeDirectLightShadowsTexture": 5432,
    "m_hLightProbeTexture": 5408,
    "m_nEnvCubeMapArrayIndex": 5472,
    "m_nHandshake": 5468,
    "m_nLightProbeAtlasX": 5512,
    "m_nLightProbeAtlasY": 5516,
    "m_nLightProbeAtlasZ": 5520,
    "m_nLightProbeSizeX": 5500,
    "m_nLightProbeSizeY": 5504,
    "m_nLightProbeSizeZ": 5508,
    "m_nPriority": 5476,
    "m_vBoxMaxs": 5452,
    "m_vBoxMins": 5440,
    "m_vEdgeFadeDists": 5488
  },
  "CEnvCubemap": {
    "m_bCopyDiffuseFromDefaultCubemap": 1408,
    "m_bCustomCubemapTexture": 1336,
    "m_bDefaultEnvMap": 1405,
    "m_bDefaultSpecEnvMap": 1406,
    "m_bEnabled": 1424,
    "m_bIndoorCubeMap": 1407,
    "m_bMoveable": 1368,
    "m_bStartDisabled": 1404,
    "m_flDiffuseScale": 1400,
    "m_flEdgeFadeDist": 1384,
    "m_flInfluenceRadius": 1340,
    "m_hCubemapTexture": 1328,
    "m_nEnvCubeMapArrayIndex": 1376,
    "m_nHandshake": 1372,
    "m_nPriority": 1380,
    "m_vBoxProjectMaxs": 1356,
    "m_vBoxProjectMins": 1344,
    "m_vEdgeFadeDists": 1388
  },
  "CEnvCubemapFog": {
    "m_bActive": 1236,
    "m_bFirstTime": 1273,
    "m_bHasHeightFogEnd": 1272,
    "m_bHeightFogEnabled": 1212,
    "m_bStartDisabled": 1237,
    "m_flEndDistance": 1200,
    "m_flFogFalloffExponent": 1208,
    "m_flFogHeightEnd": 1220,
    "m_flFogHeightExponent": 1228,
    "m_flFogHeightStart": 1224,
    "m_flFogHeightWidth": 1216,
    "m_flFogMaxOpacity": 1240,
    "m_flLODBias": 1232,
    "m_flStartDistance": 1204,
    "m_hFogCubemapTexture": 1264,
    "m_hSkyMaterial": 1248,
    "m_iszSkyEntity": 1256,
    "m_nCubemapSourceType": 1244
  },
  "CEnvDecal": {
    "m_bProjectOnCharacters": 1817,
    "m_bProjectOnWater": 1818,
    "m_bProjectOnWorld": 1816,
    "m_flDepth": 1808,
    "m_flDepthSortBias": 1820,
    "m_flHeight": 1804,
    "m_flWidth": 1800,
    "m_hDecalMaterial": 1792,
    "m_nRenderOrder": 1812
  },
  "CEnvDetailController": {
    "m_flFadeEndDist": 1204,
    "m_flFadeStartDist": 1200
  },
  "CEnvEntityIgniter": {
    "m_flLifetime": 1200
  },
  "CEnvEntityMaker": {
    "m_angPostSpawnDirection": 1244,
    "m_bPostSpawnUseAngles": 1264,
    "m_flPostSpawnDirectionVariance": 1256,
    "m_flPostSpawnSpeed": 1260,
    "m_hCurrentBlocker": 1228,
    "m_hCurrentInstance": 1224,
    "m_iszTemplate": 1272,
    "m_pOutputOnFailedSpawn": 1320,
    "m_pOutputOnSpawned": 1280,
    "m_vecBlockerOrigin": 1232,
    "m_vecEntityMaxs": 1212,
    "m_vecEntityMins": 1200
  },
  "CEnvExplosion": {
    "m_flDamageForce": 1812,
    "m_flInnerRadius": 1804,
    "m_flPlayerDamage": 1796,
    "m_hEntityIgnore": 1872,
    "m_hInflictor": 1816,
    "m_iClassIgnore": 1856,
    "m_iClassIgnore2": 1860,
    "m_iCustomDamageType": 1820,
    "m_iMagnitude": 1792,
    "m_iRadiusOverride": 1800,
    "m_iszCustomEffectName": 1840,
    "m_iszCustomSoundName": 1848,
    "m_iszEntityIgnoreName": 1864,
    "m_iszExplosionType": 1832,
    "m_spriteScale": 1808
  },
  "CEnvFade": {
    "m_Duration": 1204,
    "m_HoldDuration": 1208,
    "m_OnBeginFade": 1216,
    "m_fadeColor": 1200
  },
  "CEnvFireSensor": {
    "m_OnHeatLevelEnd": 1264,
    "m_OnHeatLevelStart": 1224,
    "m_bEnabled": 1200,
    "m_bHeatAtLevel": 1201,
    "m_levelTime": 1216,
    "m_radius": 1204,
    "m_targetLevel": 1208,
    "m_targetTime": 1212
  },
  "CEnvFireSource": {
    "m_bEnabled": 1200,
    "m_damage": 1208,
    "m_radius": 1204
  },
  "CEnvGlobal": {
    "m_counter": 1256,
    "m_globalstate": 1240,
    "m_initialstate": 1252,
    "m_outCounter": 1200,
    "m_triggermode": 1248
  },
  "CEnvHudHint": {
    "m_iszMessage": 1200
  },
  "CEnvInstructorHint": {
    "m_Color": 1264,
    "m_bAllowNoDrawTarget": 1304,
    "m_bAutoStart": 1305,
    "m_bForceCaption": 1281,
    "m_bLocalPlayerOnly": 1306,
    "m_bNoOffscreen": 1280,
    "m_bStatic": 1279,
    "m_bSuppressRest": 1288,
    "m_fIconOffset": 1268,
    "m_fRange": 1272,
    "m_iAlphaOption": 1277,
    "m_iDisplayLimit": 1228,
    "m_iInstanceType": 1284,
    "m_iPulseOption": 1276,
    "m_iShakeOption": 1278,
    "m_iTimeout": 1224,
    "m_iszActivatorCaption": 1256,
    "m_iszBinding": 1296,
    "m_iszCaption": 1248,
    "m_iszHintTargetEntity": 1216,
    "m_iszIcon_Offscreen": 1240,
    "m_iszIcon_Onscreen": 1232,
    "m_iszName": 1200,
    "m_iszReplace_Key": 1208
  },
  "CEnvInstructorVRHint": {
    "m_flHeightOffset": 1260,
    "m_iAttachType": 1256,
    "m_iLayoutFileType": 1240,
    "m_iTimeout": 1216,
    "m_iszCaption": 1224,
    "m_iszCustomLayoutFile": 1248,
    "m_iszHintTargetEntity": 1208,
    "m_iszName": 1200,
    "m_iszStartSound": 1232
  },
  "CEnvLaser": {
    "m_firePosition": 1976,
    "m_flStartFrame": 1988,
    "m_iszLaserTarget": 1952,
    "m_iszSpriteName": 1968,
    "m_pSprite": 1960
  },
  "CEnvLightProbeVolume": {
    "m_bEnabled": 5361,
    "m_bMoveable": 5312,
    "m_bStartDisabled": 5324,
    "m_hLightProbeDirectLightIndicesTexture": 5264,
    "m_hLightProbeDirectLightScalarsTexture": 5272,
    "m_hLightProbeDirectLightShadowsTexture": 5280,
    "m_hLightProbeTexture": 5256,
    "m_nHandshake": 5316,
    "m_nLightProbeAtlasX": 5340,
    "m_nLightProbeAtlasY": 5344,
    "m_nLightProbeAtlasZ": 5348,
    "m_nLightProbeSizeX": 5328,
    "m_nLightProbeSizeY": 5332,
    "m_nLightProbeSizeZ": 5336,
    "m_nPriority": 5320,
    "m_vBoxMaxs": 5300,
    "m_vBoxMins": 5288
  },
  "CEnvMicrophone": {
    "m_OnHeardSound": 1344,
    "m_OnRoutedSound": 1304,
    "m_SoundLevel": 1264,
    "m_bAvoidFeedback": 1236,
    "m_bDisabled": 1200,
    "m_flMaxRange": 1220,
    "m_flSensitivity": 1212,
    "m_flSmoothFactor": 1216,
    "m_hListenFilter": 1256,
    "m_hMeasureTarget": 1204,
    "m_hSpeaker": 1232,
    "m_iLastRoutedFrame": 1640,
    "m_iSpeakerDSPPreset": 1240,
    "m_iszListenFilter": 1248,
    "m_iszSpeakerName": 1224,
    "m_nSoundMask": 1208,
    "m_szLastSound": 1384
  },
  "CEnvMuzzleFlash": {
    "m_flScale": 1200,
    "m_iszParentAttachment": 1208
  },
  "CEnvParticleGlow": {
    "m_ColorTint": 3204,
    "m_flAlphaScale": 3192,
    "m_flRadiusScale": 3196,
    "m_flSelfIllumScale": 3200,
    "m_hTextureOverride": 3208
  },
  "CEnvProjectedTexture": {
    "m_LightColor": 1816,
    "m_SpotlightTextureName": 1864,
    "m_bAlwaysUpdate": 1797,
    "m_bCameraSpace": 1808,
    "m_bEnableShadows": 1804,
    "m_bFlipHorizontal": 2400,
    "m_bLightOnlyTarget": 1806,
    "m_bLightWorld": 1807,
    "m_bSimpleProjection": 1805,
    "m_bState": 1796,
    "m_bVolumetric": 1832,
    "m_flAmbient": 1860,
    "m_flBrightnessScale": 1812,
    "m_flColorTransitionTime": 1856,
    "m_flFarZ": 2388,
    "m_flFlashlightTime": 1840,
    "m_flIntensity": 1820,
    "m_flLightFOV": 1800,
    "m_flLinearAttenuation": 1824,
    "m_flNearZ": 2384,
    "m_flNoiseStrength": 1836,
    "m_flPlaneOffset": 1848,
    "m_flProjectionSize": 2392,
    "m_flQuadraticAttenuation": 1828,
    "m_flRotation": 2396,
    "m_flVolumetricIntensity": 1852,
    "m_hTargetEntity": 1792,
    "m_nNumPlanes": 1844,
    "m_nShadowQuality": 2380,
    "m_nSpotlightTextureFrame": 2376
  },
  "CEnvScreenOverlay": {
    "m_bIsActive": 1328,
    "m_flOverlayTimes": 1280,
    "m_flStartTime": 1320,
    "m_iDesiredOverlay": 1324,
    "m_iszOverlayNames": 1200
  },
  "CEnvShake": {
    "m_Amplitude": 1208,
    "m_Duration": 1216,
    "m_Frequency": 1212,
    "m_Radius": 1220,
    "m_currentAmp": 1232,
    "m_limitToEntity": 1200,
    "m_maxForce": 1236,
    "m_nextShake": 1228,
    "m_shakeCallback": 1256,
    "m_stopTime": 1224
  },
  "CEnvSky": {
    "m_bEnabled": 1844,
    "m_bStartDisabled": 1808,
    "m_flBrightnessScale": 1820,
    "m_flFogMaxEnd": 1840,
    "m_flFogMaxStart": 1836,
    "m_flFogMinEnd": 1832,
    "m_flFogMinStart": 1828,
    "m_hSkyMaterial": 1792,
    "m_hSkyMaterialLightingOnly": 1800,
    "m_nFogType": 1824,
    "m_vTintColor": 1809,
    "m_vTintColorLightingOnly": 1813
  },
  "CEnvSoundscape": {
    "m_OnPlay": 1200,
    "m_bDisabled": 1348,
    "m_bOverrideWithEvent": 1264,
    "m_flRadius": 1240,
    "m_hProxySoundscape": 1344,
    "m_positionNames": 1280,
    "m_soundEventHash": 1276,
    "m_soundEventName": 1256,
    "m_soundscapeEntityListId": 1272,
    "m_soundscapeIndex": 1268,
    "m_soundscapeName": 1248
  },
  "CEnvSoundscapeProxy": {
    "m_MainSoundscapeName": 1352
  },
  "CEnvSpark": {
    "m_OnSpark": 1216,
    "m_flDelay": 1200,
    "m_nMagnitude": 1204,
    "m_nTrailLength": 1208,
    "m_nType": 1212
  },
  "CEnvSplash": {
    "m_flScale": 1200
  },
  "CEnvTilt": {
    "m_Duration": 1200,
    "m_Radius": 1204,
    "m_TiltTime": 1208,
    "m_stopTime": 1212
  },
  "CEnvTracer": {
    "m_flDelay": 1212,
    "m_vecEnd": 1200
  },
  "CEnvViewPunch": {
    "m_angViewPunch": 1204,
    "m_flRadius": 1200
  },
  "CEnvVolumetricFogController": {
    "m_bActive": 1264,
    "m_bEnableIndirect": 1305,
    "m_bFirstTime": 1324,
    "m_bIsMaster": 1306,
    "m_bStartDisabled": 1304,
    "m_flAnisotropy": 1204,
    "m_flDefaultAnisotropy": 1292,
    "m_flDefaultDrawDistance": 1300,
    "m_flDefaultScattering": 1296,
    "m_flDrawDistance": 1212,
    "m_flFadeInEnd": 1220,
    "m_flFadeInStart": 1216,
    "m_flFadeSpeed": 1208,
    "m_flIndirectStrength": 1224,
    "m_flScattering": 1200,
    "m_flStartAnisoTime": 1268,
    "m_flStartAnisotropy": 1280,
    "m_flStartDrawDistance": 1288,
    "m_flStartDrawDistanceTime": 1276,
    "m_flStartScatterTime": 1272,
    "m_flStartScattering": 1284,
    "m_hFogIndirectTexture": 1312,
    "m_nForceRefreshCount": 1320,
    "m_nIndirectTextureDimX": 1228,
    "m_nIndirectTextureDimY": 1232,
    "m_nIndirectTextureDimZ": 1236,
    "m_vBoxMaxs": 1252,
    "m_vBoxMins": 1240
  },
  "CEnvVolumetricFogVolume": {
    "m_bActive": 1200,
    "m_bStartDisabled": 1228,
    "m_flFalloffExponent": 1240,
    "m_flStrength": 1232,
    "m_nFalloffShape": 1236,
    "m_vBoxMaxs": 1216,
    "m_vBoxMins": 1204
  },
  "CEnvWind": {
    "m_EnvWindShared": 1200
  },
  "CEnvWindShared": {
    "m_CurrentSwayVector": 80,
    "m_OnGustEnd": 152,
    "m_OnGustStart": 112,
    "m_PrevSwayVector": 92,
    "m_bGusting": 212,
    "m_currentWindVector": 68,
    "m_flAveWindSpeed": 208,
    "m_flGustDuration": 36,
    "m_flInitialWindSpeed": 108,
    "m_flMaxGustDelay": 32,
    "m_flMinGustDelay": 28,
    "m_flSimTime": 200,
    "m_flStartTime": 8,
    "m_flSwayTime": 196,
    "m_flSwitchTime": 204,
    "m_flVariationTime": 192,
    "m_flWindAngleVariation": 216,
    "m_flWindSpeed": 64,
    "m_flWindSpeedVariation": 220,
    "m_iEntIndex": 224,
    "m_iGustDirChange": 40,
    "m_iInitialWindDir": 104,
    "m_iMaxGust": 26,
    "m_iMaxWind": 18,
    "m_iMinGust": 24,
    "m_iMinWind": 16,
    "m_iWindDir": 60,
    "m_iWindSeed": 12,
    "m_iszGustSound": 56,
    "m_location": 44,
    "m_windRadius": 20
  },
  "CEnvWindShared_WindAveEvent_t": {
    "m_flAveWindSpeed": 4,
    "m_flStartWindSpeed": 0
  },
  "CEnvWindShared_WindVariationEvent_t": {
    "m_flWindAngleVariation": 0,
    "m_flWindSpeedVariation": 4
  },
  "CFilterAttributeInt": {
    "m_sAttributeName": 1288
  },
  "CFilterClass": {
    "m_iFilterClass": 1288
  },
  "CFilterContext": {
    "m_iFilterContext": 1288
  },
  "CFilterEnemy": {
    "m_flOuterRadius": 1300,
    "m_flRadius": 1296,
    "m_iszEnemyName": 1288,
    "m_iszPlayerName": 1312,
    "m_nMaxSquadmatesPerEnemy": 1304
  },
  "CFilterMassGreater": {
    "m_fFilterMass": 1288
  },
  "CFilterModel": {
    "m_iFilterModel": 1288
  },
  "CFilterMultiple": {
    "m_hFilter": 1376,
    "m_iFilterName": 1296,
    "m_nFilterCount": 1416,
    "m_nFilterType": 1288
  },
  "CFilterName": {
    "m_iFilterName": 1288
  },
  "CFilterProximity": {
    "m_flRadius": 1288
  },
  "CFire": {
    "m_OnExtinguished": 1896,
    "m_OnIgnited": 1856,
    "m_bDidActivate": 1850,
    "m_bEnabled": 1848,
    "m_bStartDisabled": 1849,
    "m_flAttackTime": 1844,
    "m_flDamageScale": 1832,
    "m_flDamageTime": 1808,
    "m_flFireSize": 1816,
    "m_flFuel": 1804,
    "m_flHeatAbsorb": 1828,
    "m_flHeatLevel": 1824,
    "m_flLastHeatLevel": 1840,
    "m_flLastNavUpdateTime": 1820,
    "m_flMaxHeat": 1836,
    "m_hEffect": 1792,
    "m_hOwner": 1796,
    "m_lastDamage": 1812,
    "m_nFireType": 1800
  },
  "CFireSmoke": {
    "m_nFlameFromAboveModelIndex": 1220,
    "m_nFlameModelIndex": 1216
  },
  "CFiringModeFloat": {
    "m_flValues": 0
  },
  "CFiringModeInt": {
    "m_nValues": 0
  },
  "CFish": {
    "m_angle": 2212,
    "m_angleChange": 2216,
    "m_avoidRange": 2276,
    "m_calmSpeed": 2268,
    "m_desiredSpeed": 2264,
    "m_disperseTimer": 2384,
    "m_forward": 2220,
    "m_goTimer": 2312,
    "m_id": 2196,
    "m_moveTimer": 2336,
    "m_panicSpeed": 2272,
    "m_panicTimer": 2360,
    "m_perp": 2232,
    "m_pool": 2192,
    "m_poolOrigin": 2244,
    "m_proximityTimer": 2408,
    "m_speed": 2260,
    "m_turnClockwise": 2304,
    "m_turnTimer": 2280,
    "m_visible": 2432,
    "m_waterLevel": 2256,
    "m_x": 2200,
    "m_y": 2204,
    "m_z": 2208
  },
  "CFishPool": {
    "m_fishCount": 1216,
    "m_fishes": 1240,
    "m_isDormant": 1232,
    "m_maxRange": 1220,
    "m_swimDepth": 1224,
    "m_visTimer": 1264,
    "m_waterLevel": 1228
  },
  "CFists": {
    "m_bDelayedHardPunchIncoming": 3636,
    "m_bDestroyAfterTaunt": 3637,
    "m_bPlayingUninterruptableAct": 3616,
    "m_bRestorePrevWep": 3624,
    "m_hWeaponBeforePrevious": 3628,
    "m_hWeaponPrevious": 3632,
    "m_nUninterruptableActivity": 3620
  },
  "CFlashbangProjectile": {
    "m_flTimeToDetonate": 2624,
    "m_numOpponentsHit": 2628,
    "m_numTeammatesHit": 2629
  },
  "CFogController": {
    "m_bUseAngles": 1304,
    "m_fog": 1200,
    "m_iChangedVariables": 1308
  },
  "CFogTrigger": {
    "m_fog": 2216
  },
  "CFogVolume": {
    "m_bDisabled": 1824,
    "m_bInFogVolumesList": 1825,
    "m_colorCorrectionName": 1808,
    "m_fogName": 1792,
    "m_postProcessName": 1800
  },
  "CFootstepControl": {
    "m_destination": 2224,
    "m_source": 2216
  },
  "CFuncBrush": {
    "m_bInvertExclusion": 1816,
    "m_bScriptedMovement": 1817,
    "m_bSolidBsp": 1800,
    "m_iDisabled": 1796,
    "m_iSolidity": 1792,
    "m_iszExcludedClass": 1808
  },
  "CFuncConveyor": {
    "m_angMoveEntitySpace": 1804,
    "m_flTargetSpeed": 1828,
    "m_flTransitionDurationSeconds": 1800,
    "m_flTransitionStartSpeed": 1840,
    "m_hConveyorModels": 1848,
    "m_nTransitionDurationTicks": 1836,
    "m_nTransitionStartTick": 1832,
    "m_szConveyorModels": 1792,
    "m_vecMoveDirEntitySpace": 1816
  },
  "CFuncElectrifiedVolume": {
    "m_EffectInterpenetrateName": 1832,
    "m_EffectName": 1824,
    "m_EffectZapName": 1840,
    "m_iszEffectSource": 1848
  },
  "CFuncInteractionLayerClip": {
    "m_bDisabled": 1792,
    "m_iszInteractsAs": 1800,
    "m_iszInteractsWith": 1808
  },
  "CFuncLadder": {
    "m_Dismounts": 1808,
    "m_OnPlayerGotOffLadder": 1928,
    "m_OnPlayerGotOnLadder": 1888,
    "m_bDisabled": 1872,
    "m_bFakeLadder": 1873,
    "m_bHasSlack": 1874,
    "m_flAutoRideSpeed": 1868,
    "m_surfacePropName": 1880,
    "m_vecLadderDir": 1792,
    "m_vecLocalTop": 1832,
    "m_vecPlayerMountPositionBottom": 1856,
    "m_vecPlayerMountPositionTop": 1844
  },
  "CFuncMonitor": {
    "m_bDraw3DSkybox": 1853,
    "m_bEnabled": 1852,
    "m_bRenderShadows": 1836,
    "m_bStartEnabled": 1854,
    "m_bUseUniqueColorTarget": 1837,
    "m_brushModelName": 1840,
    "m_hTargetCamera": 1848,
    "m_nResolutionEnum": 1832,
    "m_targetCamera": 1824
  },
  "CFuncMoveLinear": {
    "m_OnFullyClosed": 2040,
    "m_OnFullyOpen": 2000,
    "m_angMoveEntitySpace": 1924,
    "m_authoredPosition": 1920,
    "m_bCreateMovableNavMesh": 2080,
    "m_bCreateNavObstacle": 2081,
    "m_currentSound": 1968,
    "m_flBlockDamage": 1976,
    "m_flMoveDistance": 1984,
    "m_flStartPosition": 1980,
    "m_soundStart": 1952,
    "m_soundStop": 1960,
    "m_vecMoveDirParentSpace": 1936
  },
  "CFuncNavBlocker": {
    "m_bDisabled": 1792,
    "m_nBlockedTeamNumber": 1796
  },
  "CFuncNavObstruction": {
    "m_bDisabled": 1800
  },
  "CFuncPlat": {
    "m_sNoise": 1960
  },
  "CFuncPlatRot": {
    "m_end": 1968,
    "m_start": 1980
  },
  "CFuncRotating": {
    "m_NoiseRunning": 1832,
    "m_angStart": 1852,
    "m_bReversed": 1840,
    "m_bStopAtStartPos": 1864,
    "m_flAttenuation": 1808,
    "m_flBlockDamage": 1824,
    "m_flFanFriction": 1804,
    "m_flMaxSpeed": 1820,
    "m_flTargetSpeed": 1816,
    "m_flTimeScale": 1828,
    "m_flVolume": 1812,
    "m_vecClientAngles": 1880,
    "m_vecClientOrigin": 1868,
    "m_vecMoveAng": 1792
  },
  "CFuncShatterglass": {
    "m_OnBroken": 2088,
    "m_PanelSize": 1952,
    "m_bBreakShardless": 1997,
    "m_bBreakSilent": 1996,
    "m_bBroken": 1998,
    "m_bGlassInFrame": 2001,
    "m_bGlassNavIgnore": 2000,
    "m_bHasRateLimitedShards": 1999,
    "m_bStartBroken": 2002,
    "m_flGlassThickness": 1988,
    "m_flInitAtTime": 1984,
    "m_flLastCleanupTime": 1980,
    "m_flLastShatterSoundEmitTime": 1976,
    "m_flSpawnInvulnerability": 1992,
    "m_hConcreteMaterialEdgeCaps": 1816,
    "m_hConcreteMaterialEdgeFace": 1808,
    "m_hConcreteMaterialEdgeFins": 1824,
    "m_hGlassMaterialDamaged": 1792,
    "m_hGlassMaterialUndamaged": 1800,
    "m_iInitialDamageType": 2003,
    "m_iSurfaceType": 2129,
    "m_matPanelTransform": 1832,
    "m_matPanelTransformWsTemp": 1880,
    "m_nNumShardsEverCreated": 1972,
    "m_szDamagePositioningEntityName01": 2008,
    "m_szDamagePositioningEntityName02": 2016,
    "m_szDamagePositioningEntityName03": 2024,
    "m_szDamagePositioningEntityName04": 2032,
    "m_vExtraDamagePositions": 2064,
    "m_vInitialDamagePositions": 2040,
    "m_vecPanelNormalWs": 1960,
    "m_vecShatterGlassShards": 1928
  },
  "CFuncTankTrain": {
    "m_OnDeath": 2128
  },
  "CFuncTimescale": {
    "m_flAcceleration": 1204,
    "m_flBlendDeltaMultiplier": 1212,
    "m_flDesiredTimescale": 1200,
    "m_flMinBlendRate": 1208,
    "m_isStarted": 1216
  },
  "CFuncTrackChange": {
    "m_code": 2040,
    "m_targetState": 2044,
    "m_trackBottom": 2000,
    "m_trackBottomName": 2024,
    "m_trackTop": 1992,
    "m_trackTopName": 2016,
    "m_train": 2008,
    "m_trainName": 2032,
    "m_use": 2048
  },
  "CFuncTrackTrain": {
    "m_OnArrivedAtDestinationNode": 2056,
    "m_OnNext": 2016,
    "m_OnStart": 1976,
    "m_angPrev": 1812,
    "m_bAccelToSpeed": 2116,
    "m_bManualSpeedChanges": 2096,
    "m_controlMaxs": 1836,
    "m_controlMins": 1824,
    "m_dir": 1888,
    "m_eOrientationType": 1956,
    "m_eVelocityType": 1960,
    "m_flAccelSpeed": 2108,
    "m_flBank": 1868,
    "m_flBlockDamage": 1876,
    "m_flDecelSpeed": 2112,
    "m_flDesiredSpeed": 2100,
    "m_flMoveSoundMaxDuration": 1940,
    "m_flMoveSoundMaxPitch": 1952,
    "m_flMoveSoundMinDuration": 1936,
    "m_flMoveSoundMinPitch": 1948,
    "m_flNextMPSoundTime": 2124,
    "m_flNextMoveSoundTime": 1944,
    "m_flSpeedChangeTime": 2104,
    "m_flTimeScale": 2120,
    "m_flVolume": 1864,
    "m_height": 1880,
    "m_iszSoundMove": 1896,
    "m_iszSoundMovePing": 1904,
    "m_iszSoundStart": 1912,
    "m_iszSoundStop": 1920,
    "m_lastBlockPos": 1848,
    "m_lastBlockTick": 1860,
    "m_length": 1796,
    "m_maxSpeed": 1884,
    "m_oldSpeed": 1872,
    "m_ppath": 1792,
    "m_strPathTarget": 1928,
    "m_vPosPrev": 1800
  },
  "CFuncTrain": {
    "m_activated": 1964,
    "m_flBlockDamage": 1972,
    "m_flNextBlockTime": 1976,
    "m_hCurrentTarget": 1960,
    "m_hEnemy": 1968,
    "m_iszLastTarget": 1984
  },
  "CFuncVPhysicsClip": {
    "m_bDisabled": 1792
  },
  "CFuncWall": {
    "m_nState": 1792
  },
  "CFuncWater": {
    "m_BuoyancyHelper": 1792
  },
  "CGameChoreoServices": {
    "m_choreoState": 20,
    "m_flTimeStartedState": 24,
    "m_hOwner": 8,
    "m_hScriptedSequence": 12,
    "m_scriptState": 16
  },
  "CGameGibManager": {
    "m_bAllowNewGibs": 1232,
    "m_iCurrentMaxPieces": 1236,
    "m_iLastFrame": 1244,
    "m_iMaxPieces": 1240
  },
  "CGameMoney": {
    "m_OnMoneySpent": 1808,
    "m_OnMoneySpentFail": 1848,
    "m_nMoney": 1888,
    "m_strAwardText": 1896
  },
  "CGamePlayerZone": {
    "m_OnPlayerInZone": 1800,
    "m_OnPlayerOutZone": 1840,
    "m_PlayersInCount": 1880,
    "m_PlayersOutCount": 1920
  },
  "CGameRules": {
    "m_nQuestPhase": 136,
    "m_szQuestName": 8
  },
  "CGameSceneNode": {
    "m_angAbsRotation": 212,
    "m_angRotation": 184,
    "m_bBoneMergeFlex": 0,
    "m_bDebugAbsOriginChanges": 230,
    "m_bDirtyBoneMergeBoneToRoot": 0,
    "m_bDirtyBoneMergeInfo": 0,
    "m_bDirtyHierarchy": 0,
    "m_bDormant": 231,
    "m_bForceParentToBeNetworked": 232,
    "m_bNetworkedAnglesChanged": 0,
    "m_bNetworkedPositionChanged": 0,
    "m_bNetworkedScaleChanged": 0,
    "m_bNotifyBoneTransformsChanged": 0,
    "m_bWillBeCallingPostDataUpdate": 0,
    "m_flAbsScale": 224,
    "m_flScale": 196,
    "m_flZOffset": 308,
    "m_hParent": 112,
    "m_hierarchyAttachName": 304,
    "m_nDoNotSetAnimTimeInInvalidatePhysicsCount": 237,
    "m_nHierarchicalDepth": 235,
    "m_nHierarchyType": 236,
    "m_nLatchAbsOrigin": 0,
    "m_nParentAttachmentOrBone": 228,
    "m_name": 240,
    "m_nodeToWorld": 16,
    "m_pChild": 64,
    "m_pNextSibling": 72,
    "m_pOwner": 48,
    "m_pParent": 56,
    "m_vRenderOrigin": 312,
    "m_vecAbsOrigin": 200,
    "m_vecOrigin": 128
  },
  "CGameSceneNodeHandle": {
    "m_hOwner": 8,
    "m_name": 12
  },
  "CGameScriptedMoveData": {
    "m_angCurrent": 48,
    "m_angDst": 36,
    "m_angSrc": 24,
    "m_bActive": 73,
    "m_bEndOnDestinationReached": 75,
    "m_bIgnoreCollisions": 92,
    "m_bIgnoreRotation": 76,
    "m_bSuccess": 84,
    "m_bTeleportOnEnd": 74,
    "m_flAngRate": 60,
    "m_flDuration": 64,
    "m_flStartTime": 68,
    "m_nForcedCrouchState": 88,
    "m_nPrevMoveType": 72,
    "m_nType": 80,
    "m_vDest": 0,
    "m_vSrc": 12
  },
  "CGameText": {
    "m_iszMessage": 1808,
    "m_textParms": 1816
  },
  "CGenericConstraint": {
    "m_NotifyForceReachedX": 1472,
    "m_NotifyForceReachedY": 1512,
    "m_NotifyForceReachedZ": 1552,
    "m_bAxisNotifiedX": 1416,
    "m_bAxisNotifiedY": 1417,
    "m_bAxisNotifiedZ": 1418,
    "m_flAngularDampingRatioX": 1444,
    "m_flAngularDampingRatioY": 1448,
    "m_flAngularDampingRatioZ": 1452,
    "m_flAngularFrequencyX": 1432,
    "m_flAngularFrequencyY": 1436,
    "m_flAngularFrequencyZ": 1440,
    "m_flBreakAfterTimeStartTimeX": 1356,
    "m_flBreakAfterTimeStartTimeY": 1360,
    "m_flBreakAfterTimeStartTimeZ": 1364,
    "m_flBreakAfterTimeThresholdX": 1368,
    "m_flBreakAfterTimeThresholdY": 1372,
    "m_flBreakAfterTimeThresholdZ": 1376,
    "m_flBreakAfterTimeX": 1344,
    "m_flBreakAfterTimeY": 1348,
    "m_flBreakAfterTimeZ": 1352,
    "m_flLinearDampingRatioX": 1320,
    "m_flLinearDampingRatioY": 1324,
    "m_flLinearDampingRatioZ": 1328,
    "m_flLinearFrequencyX": 1308,
    "m_flLinearFrequencyY": 1312,
    "m_flLinearFrequencyZ": 1316,
    "m_flMaxAngularImpulseX": 1456,
    "m_flMaxAngularImpulseY": 1460,
    "m_flMaxAngularImpulseZ": 1464,
    "m_flMaxLinearImpulseX": 1332,
    "m_flMaxLinearImpulseY": 1336,
    "m_flMaxLinearImpulseZ": 1340,
    "m_flNotifyForceLastTimeX": 1404,
    "m_flNotifyForceLastTimeY": 1408,
    "m_flNotifyForceLastTimeZ": 1412,
    "m_flNotifyForceMinTimeX": 1392,
    "m_flNotifyForceMinTimeY": 1396,
    "m_flNotifyForceMinTimeZ": 1400,
    "m_flNotifyForceX": 1380,
    "m_flNotifyForceY": 1384,
    "m_flNotifyForceZ": 1388,
    "m_nAngularMotionX": 1420,
    "m_nAngularMotionY": 1424,
    "m_nAngularMotionZ": 1428,
    "m_nLinearMotionX": 1296,
    "m_nLinearMotionY": 1300,
    "m_nLinearMotionZ": 1304
  },
  "CGlowProperty": {
    "m_bEligibleForScreenHighlight": 80,
    "m_bFlashing": 68,
    "m_bGlowing": 81,
    "m_fGlowColor": 8,
    "m_flGlowStartTime": 76,
    "m_flGlowTime": 72,
    "m_glowColorOverride": 64,
    "m_iGlowTeam": 52,
    "m_iGlowType": 48,
    "m_nGlowRange": 56,
    "m_nGlowRangeMin": 60
  },
  "CGradientFog": {
    "m_bGradientFogNeedsTextures": 1258,
    "m_bHeightFogEnabled": 1216,
    "m_bIsEnabled": 1257,
    "m_bStartDisabled": 1256,
    "m_flFadeTime": 1252,
    "m_flFarZ": 1228,
    "m_flFogEndDistance": 1212,
    "m_flFogEndHeight": 1224,
    "m_flFogFalloffExponent": 1236,
    "m_flFogMaxOpacity": 1232,
    "m_flFogStartDistance": 1208,
    "m_flFogStartHeight": 1220,
    "m_flFogStrength": 1248,
    "m_flFogVerticalExponent": 1240,
    "m_fogColor": 1244,
    "m_hGradientFogTexture": 1200
  },
  "CGunTarget": {
    "m_OnDeath": 1928,
    "m_hTargetEnt": 1924,
    "m_on": 1920
  },
  "CHandleTest": {
    "m_Handle": 1200,
    "m_bSendHandle": 1204
  },
  "CHintMessage": {
    "m_args": 16,
    "m_duration": 40,
    "m_hintString": 8
  },
  "CHintMessageQueue": {
    "m_messages": 16,
    "m_pPlayerController": 40,
    "m_tmMessageEnd": 8
  },
  "CHitboxComponent": {
    "m_bvDisabledHitGroups": 36
  },
  "CHostage": {
    "m_OnDroppedNotRescued": 2616,
    "m_OnFirstPickedUp": 2576,
    "m_OnHostageBeginGrab": 2536,
    "m_OnRescued": 2656,
    "m_accel": 2796,
    "m_bHandsHaveBeenCut": 11277,
    "m_bRemove": 2732,
    "m_entitySpottedState": 2696,
    "m_fLastGrabTime": 11284,
    "m_flDropStartTime": 11320,
    "m_flGrabSuccessTime": 11316,
    "m_flRescueStartTime": 11312,
    "m_hHostageGrabber": 11280,
    "m_hasBeenUsed": 2792,
    "m_inhibitDoorTimer": 11072,
    "m_inhibitObstacleAvoidanceTimer": 11216,
    "m_isAdjusted": 11276,
    "m_isCrouching": 2809,
    "m_isRescued": 2748,
    "m_isRunning": 2808,
    "m_isWaitingForLeader": 2840,
    "m_jumpTimer": 2816,
    "m_jumpedThisFrame": 2749,
    "m_lastLeader": 2760,
    "m_leader": 2756,
    "m_nApproachRewardPayouts": 11324,
    "m_nHostageSpawnRandomFactor": 2728,
    "m_nHostageState": 2752,
    "m_nPickupEventCount": 11328,
    "m_nSpotRules": 2720,
    "m_repathTimer": 11048,
    "m_reuseTimer": 2768,
    "m_uiHostageSpawnExclusionGroupMask": 2724,
    "m_vecGrabbedPos": 11300,
    "m_vecHostageResetPosition": 11364,
    "m_vecPositionWhenStartedDroppingToGround": 11288,
    "m_vecSpawnGroundPos": 11332,
    "m_vel": 2736,
    "m_wiggleTimer": 11248
  },
  "CHostageExpresserShim": {
    "m_pExpresser": 2512
  },
  "CInButtonState": {
    "m_pButtonStates": 8
  },
  "CInferno": {
    "m_BookkeepingTimer": 4864,
    "m_BurnNormal": 3408,
    "m_InitialSplashVelocity": 4804,
    "m_NextSpreadTimer": 4888,
    "m_activeTimer": 4840,
    "m_bFireIsBurning": 3344,
    "m_bInPostEffectTime": 4192,
    "m_bWasCreatedInSmoke": 4200,
    "m_damageRampTimer": 4768,
    "m_damageTimer": 4744,
    "m_extent": 4720,
    "m_fireCount": 4176,
    "m_fireParentPositions": 2576,
    "m_firePositions": 1808,
    "m_fireSpawnOffset": 4856,
    "m_nFireEffectTickBegin": 4184,
    "m_nFireLifetime": 4188,
    "m_nFiresExtinguishCount": 4196,
    "m_nInfernoType": 4180,
    "m_nMaxFlames": 4860,
    "m_nSourceItemDefIndex": 4912,
    "m_splashVelocity": 4792,
    "m_startPos": 4816,
    "m_vecOriginalSpawnLocation": 4828
  },
  "CInfoDynamicShadowHint": {
    "m_bDisabled": 1200,
    "m_flRange": 1204,
    "m_hLight": 1216,
    "m_nImportance": 1208,
    "m_nLightChoice": 1212
  },
  "CInfoDynamicShadowHintBox": {
    "m_vBoxMaxs": 1236,
    "m_vBoxMins": 1224
  },
  "CInfoGameEventProxy": {
    "m_flRange": 1208,
    "m_iszEventName": 1200
  },
  "CInfoOffscreenPanoramaTexture": {
    "m_AdditionalTargetEntities": 1296,
    "m_RenderAttrName": 1224,
    "m_TargetEntities": 1232,
    "m_bDisabled": 1200,
    "m_nResolutionX": 1204,
    "m_nResolutionY": 1208,
    "m_nTargetChangeCount": 1256,
    "m_szLayoutFileName": 1216,
    "m_szTargetsName": 1288,
    "m_vecCSSClasses": 1264
  },
  "CInfoPlayerStart": {
    "m_bDisabled": 1200
  },
  "CInfoSpawnGroupLoadUnload": {
    "m_OnSpawnGroupLoadFinished": 1240,
    "m_OnSpawnGroupLoadStarted": 1200,
    "m_OnSpawnGroupUnloadFinished": 1320,
    "m_OnSpawnGroupUnloadStarted": 1280,
    "m_bStreamingStarted": 1396,
    "m_bUnloadingStarted": 1397,
    "m_flTimeoutInterval": 1392,
    "m_iszLandmarkName": 1376,
    "m_iszSpawnGroupFilterName": 1368,
    "m_iszSpawnGroupName": 1360,
    "m_sFixedSpawnGroupName": 1384
  },
  "CInfoVisibilityBox": {
    "m_bEnabled": 1220,
    "m_nMode": 1204,
    "m_vBoxSize": 1208
  },
  "CInfoWorldLayer": {
    "m_bCreateAsChildSpawnGroup": 1258,
    "m_bEntitiesSpawned": 1257,
    "m_bWorldLayerVisible": 1256,
    "m_hLayerSpawnGroup": 1260,
    "m_layerName": 1248,
    "m_pOutputOnEntitiesSpawned": 1200,
    "m_worldName": 1240
  },
  "CInstancedSceneEntity": {
    "m_bHadOwner": 2572,
    "m_bIsBackground": 2584,
    "m_flPostSpeakDelay": 2576,
    "m_flPreDelay": 2580,
    "m_hOwner": 2568
  },
  "CInstructorEventEntity": {
    "m_hTargetPlayer": 1216,
    "m_iszHintTargetEntity": 1208,
    "m_iszName": 1200
  },
  "CIronSightController": {
    "m_bIronSightAvailable": 8,
    "m_flIronSightAmount": 12,
    "m_flIronSightAmountBiased": 20,
    "m_flIronSightAmountGained": 16
  },
  "CItem": {
    "m_OnCacheInteraction": 2248,
    "m_OnGlovePulled": 2328,
    "m_OnPlayerPickup": 2288,
    "m_OnPlayerTouch": 2200,
    "m_bActivateWhenAtRest": 2240,
    "m_bPhysStartAsleep": 2392,
    "m_vOriginalSpawnAngles": 2380,
    "m_vOriginalSpawnOrigin": 2368
  },
  "CItemDefuser": {
    "m_entitySpottedState": 2408,
    "m_nSpotRules": 2432
  },
  "CItemDogtags": {
    "m_KillingPlayer": 2412,
    "m_OwningPlayer": 2408
  },
  "CItemGeneric": {
    "m_OnPickup": 2536,
    "m_OnTimeout": 2576,
    "m_OnTriggerEndTouch": 2696,
    "m_OnTriggerStartTouch": 2616,
    "m_OnTriggerTouch": 2656,
    "m_bAutoStartAmbientSound": 2456,
    "m_bGlowWhenInTrigger": 2760,
    "m_bHasPickupRadius": 2417,
    "m_bHasTriggerRadius": 2416,
    "m_bPlayerCounterListenerAdded": 2432,
    "m_bPlayerInTriggerRadius": 2433,
    "m_bUseable": 2765,
    "m_flLastPickupCheck": 2428,
    "m_flPickupRadius": 2744,
    "m_flPickupRadiusSqr": 2420,
    "m_flTriggerRadius": 2748,
    "m_flTriggerRadiusSqr": 2424,
    "m_glowColor": 2761,
    "m_hPickupFilter": 2528,
    "m_hPickupParticleEffect": 2472,
    "m_hSpawnParticleEffect": 2440,
    "m_hTimeoutParticleEffect": 2496,
    "m_hTriggerHelper": 2768,
    "m_pAllowPickupScriptFunction": 2736,
    "m_pAmbientSoundEffect": 2448,
    "m_pPickupFilterName": 2520,
    "m_pPickupScriptFunction": 2488,
    "m_pPickupSoundEffect": 2480,
    "m_pSpawnScriptFunction": 2464,
    "m_pTimeoutScriptFunction": 2512,
    "m_pTimeoutSoundEffect": 2504,
    "m_pTriggerSoundEffect": 2752
  },
  "CItemGenericTriggerHelper": {
    "m_hParentItem": 1792
  },
  "CKeepUpright": {
    "m_angularLimit": 1252,
    "m_attachedObject": 1248,
    "m_bActive": 1256,
    "m_bDampAllRotation": 1257,
    "m_localTestAxis": 1220,
    "m_nameAttach": 1240,
    "m_worldGoalAxis": 1208
  },
  "CKnife": {
    "m_bFirstAttack": 3616
  },
  "CLightComponent": {
    "__m_pChainEntity": 72,
    "m_Color": 133,
    "m_Pattern": 232,
    "m_SecondaryColor": 137,
    "m_SkyAmbientBounce": 412,
    "m_SkyColor": 404,
    "m_bEnabled": 324,
    "m_bFlicker": 325,
    "m_bMixedShadows": 417,
    "m_bPrecomputedFieldsValid": 326,
    "m_bPvsModifyEntity": 448,
    "m_bRenderDiffuse": 208,
    "m_bRenderToCubemaps": 296,
    "m_bRenderTransmissive": 216,
    "m_bUseSecondaryColor": 416,
    "m_bUsesBakedShadowing": 284,
    "m_flAttenuation0": 164,
    "m_flAttenuation1": 168,
    "m_flAttenuation2": 172,
    "m_flBrightness": 144,
    "m_flBrightnessMult": 152,
    "m_flBrightnessScale": 148,
    "m_flCapsuleLength": 424,
    "m_flFadeMaxDist": 312,
    "m_flFadeMinDist": 308,
    "m_flFalloff": 160,
    "m_flFogContributionStength": 396,
    "m_flLightStyleStartTime": 420,
    "m_flMinRoughness": 428,
    "m_flNearClipPlane": 400,
    "m_flOrthoLightHeight": 224,
    "m_flOrthoLightWidth": 220,
    "m_flPhi": 180,
    "m_flPrecomputedMaxRange": 388,
    "m_flRange": 156,
    "m_flShadowCascadeCrossFade": 244,
    "m_flShadowCascadeDistance0": 252,
    "m_flShadowCascadeDistance1": 256,
    "m_flShadowCascadeDistance2": 260,
    "m_flShadowCascadeDistance3": 264,
    "m_flShadowCascadeDistanceFade": 248,
    "m_flShadowFadeMaxDist": 320,
    "m_flShadowFadeMinDist": 316,
    "m_flSkyIntensity": 408,
    "m_flTheta": 176,
    "m_hLightCookie": 184,
    "m_nBakedShadowIndex": 292,
    "m_nCascadeRenderStaticObjects": 240,
    "m_nCascades": 192,
    "m_nCastShadows": 196,
    "m_nDirectLight": 300,
    "m_nFogLightingMode": 392,
    "m_nIndirectLight": 304,
    "m_nRenderSpecular": 212,
    "m_nShadowCascadeResolution0": 268,
    "m_nShadowCascadeResolution1": 272,
    "m_nShadowCascadeResolution2": 276,
    "m_nShadowCascadeResolution3": 280,
    "m_nShadowHeight": 204,
    "m_nShadowPriority": 288,
    "m_nShadowWidth": 200,
    "m_nStyle": 228,
    "m_vPrecomputedBoundsMaxs": 340,
    "m_vPrecomputedBoundsMins": 328,
    "m_vPrecomputedOBBAngles": 364,
    "m_vPrecomputedOBBExtent": 376,
    "m_vPrecomputedOBBOrigin": 352
  },
  "CLightEntity": {
    "m_CLightComponent": 1792
  },
  "CLightGlow": {
    "m_flGlowProxySize": 1812,
    "m_flHDRColorScale": 1816,
    "m_nHorizontalSize": 1792,
    "m_nMaxDist": 1804,
    "m_nMinDist": 1800,
    "m_nOuterMaxDist": 1808,
    "m_nVerticalSize": 1796
  },
  "CLogicAchievement": {
    "m_OnFired": 1216,
    "m_bDisabled": 1200,
    "m_iszAchievementEventID": 1208
  },
  "CLogicActiveAutosave": {
    "m_TriggerHitPoints": 1216,
    "m_flDangerousTime": 1228,
    "m_flStartTime": 1224,
    "m_flTimeToTrigger": 1220
  },
  "CLogicAuto": {
    "m_OnBackgroundMap": 1400,
    "m_OnDemoMapSpawn": 1240,
    "m_OnLoadGame": 1320,
    "m_OnMapSpawn": 1200,
    "m_OnMapTransition": 1360,
    "m_OnMultiNewMap": 1440,
    "m_OnMultiNewRound": 1480,
    "m_OnNewGame": 1280,
    "m_OnVREnabled": 1520,
    "m_OnVRNotEnabled": 1560,
    "m_globalstate": 1600
  },
  "CLogicAutosave": {
    "m_bForceNewLevelUnit": 1200,
    "m_minHitPoints": 1204,
    "m_minHitPointsToCommit": 1208
  },
  "CLogicBranch": {
    "m_Listeners": 1208,
    "m_OnFalse": 1272,
    "m_OnTrue": 1232,
    "m_bInValue": 1200
  },
  "CLogicBranchList": {
    "m_LogicBranchList": 1328,
    "m_OnAllFalse": 1400,
    "m_OnAllTrue": 1360,
    "m_OnMixed": 1440,
    "m_eLastState": 1352,
    "m_nLogicBranchNames": 1200
  },
  "CLogicCase": {
    "m_OnCase": 1496,
    "m_OnDefault": 2776,
    "m_nCase": 1200,
    "m_nLastShuffleCase": 1460,
    "m_nShuffleCases": 1456,
    "m_uchShuffleCaseMap": 1464
  },
  "CLogicCollisionPair": {
    "m_disabled": 1216,
    "m_nameAttach1": 1200,
    "m_nameAttach2": 1208,
    "m_succeeded": 1217
  },
  "CLogicCompare": {
    "m_OnEqualTo": 1248,
    "m_OnGreaterThan": 1328,
    "m_OnLessThan": 1208,
    "m_OnNotEqualTo": 1288,
    "m_flCompareValue": 1204,
    "m_flInValue": 1200
  },
  "CLogicDistanceAutosave": {
    "m_bCheckCough": 1213,
    "m_bForceNewLevelUnit": 1212,
    "m_bThinkDangerous": 1214,
    "m_flDangerousTime": 1216,
    "m_flDistanceToPlayer": 1208,
    "m_iszTargetEntity": 1200
  },
  "CLogicDistanceCheck": {
    "m_InZone1": 1224,
    "m_InZone2": 1264,
    "m_InZone3": 1304,
    "m_flZone1Distance": 1216,
    "m_flZone2Distance": 1220,
    "m_iszEntityA": 1200,
    "m_iszEntityB": 1208
  },
  "CLogicEventListener": {
    "m_OnEventFired": 1232,
    "m_bIsEnabled": 1224,
    "m_nTeam": 1228,
    "m_strEventName": 1216
  },
  "CLogicGameEvent": {
    "m_iszEventName": 1200
  },
  "CLogicGameEventListener": {
    "m_OnEventFired": 1216,
    "m_bEnabled": 1272,
    "m_bStartDisabled": 1273,
    "m_iszGameEventItem": 1264,
    "m_iszGameEventName": 1256
  },
  "CLogicLineToEntity": {
    "m_EndEntity": 1252,
    "m_Line": 1200,
    "m_SourceName": 1240,
    "m_StartEntity": 1248
  },
  "CLogicMeasureMovement": {
    "m_flScale": 1240,
    "m_hMeasureReference": 1228,
    "m_hMeasureTarget": 1224,
    "m_hTarget": 1232,
    "m_hTargetReference": 1236,
    "m_nMeasureType": 1244,
    "m_strMeasureReference": 1208,
    "m_strMeasureTarget": 1200,
    "m_strTargetReference": 1216
  },
  "CLogicNPCCounter": {
    "m_OnFactorAll": 1280,
    "m_OnFactor_1": 1440,
    "m_OnFactor_2": 1600,
    "m_OnFactor_3": 1760,
    "m_OnMaxCountAll": 1240,
    "m_OnMaxCount_1": 1400,
    "m_OnMaxCount_2": 1560,
    "m_OnMaxCount_3": 1720,
    "m_OnMinCountAll": 1200,
    "m_OnMinCount_1": 1360,
    "m_OnMinCount_2": 1520,
    "m_OnMinCount_3": 1680,
    "m_OnMinPlayerDistAll": 1320,
    "m_OnMinPlayerDist_1": 1480,
    "m_OnMinPlayerDist_2": 1640,
    "m_OnMinPlayerDist_3": 1800,
    "m_bDisabled": 1860,
    "m_bInvertState_1": 1900,
    "m_bInvertState_2": 1940,
    "m_bInvertState_3": 1980,
    "m_flDefaultDist_1": 1924,
    "m_flDefaultDist_2": 1964,
    "m_flDefaultDist_3": 2004,
    "m_flDistanceMax": 1856,
    "m_hSource": 1840,
    "m_iszNPCClassname_1": 1888,
    "m_iszNPCClassname_2": 1928,
    "m_iszNPCClassname_3": 1968,
    "m_iszSourceEntityName": 1848,
    "m_nMaxCountAll": 1868,
    "m_nMaxCount_1": 1908,
    "m_nMaxCount_2": 1948,
    "m_nMaxCount_3": 1988,
    "m_nMaxFactorAll": 1876,
    "m_nMaxFactor_1": 1916,
    "m_nMaxFactor_2": 1956,
    "m_nMaxFactor_3": 1996,
    "m_nMinCountAll": 1864,
    "m_nMinCount_1": 1904,
    "m_nMinCount_2": 1944,
    "m_nMinCount_3": 1984,
    "m_nMinFactorAll": 1872,
    "m_nMinFactor_1": 1912,
    "m_nMinFactor_2": 1952,
    "m_nMinFactor_3": 1992,
    "m_nNPCState_1": 1896,
    "m_nNPCState_2": 1936,
    "m_nNPCState_3": 1976
  },
  "CLogicNPCCounterAABB": {
    "m_vDistanceOuterMaxs": 2044,
    "m_vDistanceOuterMins": 2032,
    "m_vOuterMaxs": 2068,
    "m_vOuterMins": 2056
  },
  "CLogicNavigation": {
    "m_isOn": 1208,
    "m_navProperty": 1212
  },
  "CLogicPlayerProxy": {
    "m_PlayerDied": 1288,
    "m_PlayerHasAmmo": 1208,
    "m_PlayerHasNoAmmo": 1248,
    "m_RequestedPlayerHealth": 1328,
    "m_hPlayer": 1200
  },
  "CLogicRelay": {
    "m_OnSpawn": 1240,
    "m_OnTrigger": 1200,
    "m_bDisabled": 1280,
    "m_bFastRetrigger": 1283,
    "m_bPassthoughCaller": 1284,
    "m_bTriggerOnce": 1282,
    "m_bWaitForRefire": 1281
  },
  "CMapInfo": {
    "m_bDisableAutoGeneratedDMSpawns": 1213,
    "m_bFadePlayerVisibilityFarZ": 1224,
    "m_bUseNormalSpawnsForDM": 1212,
    "m_flBombRadius": 1204,
    "m_flBotMaxVisionDistance": 1216,
    "m_iBuyingStatus": 1200,
    "m_iHostageCount": 1220,
    "m_iPetPopulation": 1208
  },
  "CMapVetoPickController": {
    "m_OnLevelTransition": 3760,
    "m_OnMapPicked": 3640,
    "m_OnMapVetoed": 3600,
    "m_OnNewPhaseStarted": 3720,
    "m_OnSidesPicked": 3680,
    "m_bNeedToPlayFiveSecondsRemaining": 1201,
    "m_bPlayedIntroVcd": 1200,
    "m_bPreMatchDraftStateChanged": 1240,
    "m_dblPreMatchDraftSequenceTime": 1232,
    "m_nAccountIDs": 1536,
    "m_nCurrentPhase": 3584,
    "m_nDraftType": 1244,
    "m_nMapId0": 1792,
    "m_nMapId1": 2048,
    "m_nMapId2": 2304,
    "m_nMapId3": 2560,
    "m_nMapId4": 2816,
    "m_nMapId5": 3072,
    "m_nPhaseDurationTicks": 3592,
    "m_nPhaseStartTick": 3588,
    "m_nStartingSide0": 3328,
    "m_nTeamWinningCoinToss": 1248,
    "m_nTeamWithFirstChoice": 1252,
    "m_nVoteMapIdsList": 1508
  },
  "CMarkupVolume": {
    "m_bEnabled": 1792
  },
  "CMarkupVolumeTagged": {
    "m_bGroupByPrefab": 1849,
    "m_bGroupByVolume": 1850,
    "m_bGroupOtherGroups": 1851,
    "m_bIsGroup": 1848,
    "m_bIsInGroup": 1852
  },
  "CMarkupVolumeTagged_NavGame": {
    "m_bFloodFillAttribute": 1880
  },
  "CMarkupVolumeWithRef": {
    "m_bUseRef": 1856,
    "m_flRefDot": 1872,
    "m_vRefPos": 1860
  },
  "CMathColorBlend": {
    "m_OutColor1": 1208,
    "m_OutColor2": 1212,
    "m_OutValue": 1216,
    "m_flInMax": 1204,
    "m_flInMin": 1200
  },
  "CMathCounter": {
    "m_OnChangedFromMax": 1416,
    "m_OnChangedFromMin": 1376,
    "m_OnGetValue": 1256,
    "m_OnHitMax": 1336,
    "m_OnHitMin": 1296,
    "m_OutValue": 1216,
    "m_bDisabled": 1210,
    "m_bHitMax": 1209,
    "m_bHitMin": 1208,
    "m_flMax": 1204,
    "m_flMin": 1200
  },
  "CMathRemap": {
    "m_OnFellBelowMax": 1384,
    "m_OnFellBelowMin": 1344,
    "m_OnRoseAboveMax": 1304,
    "m_OnRoseAboveMin": 1264,
    "m_OutValue": 1224,
    "m_bEnabled": 1220,
    "m_flInMax": 1204,
    "m_flInMin": 1200,
    "m_flOldInValue": 1216,
    "m_flOut1": 1208,
    "m_flOut2": 1212
  },
  "CMelee": {
    "m_bDidThrowDamage": 3624,
    "m_flThrowAt": 3616,
    "m_hThrower": 3620
  },
  "CMessage": {
    "m_MessageAttenuation": 1212,
    "m_MessageVolume": 1208,
    "m_OnShowMessage": 1232,
    "m_Radius": 1216,
    "m_iszMessage": 1200,
    "m_sNoise": 1224
  },
  "CMessageEntity": {
    "m_bDeveloperOnly": 1217,
    "m_bEnabled": 1218,
    "m_drawText": 1216,
    "m_messageText": 1208,
    "m_radius": 1200
  },
  "CModelState": {
    "m_MeshGroupMask": 384,
    "m_ModelName": 168,
    "m_bClientClothCreationSuppressed": 232,
    "m_hModel": 160,
    "m_nClothUpdateFlags": 548,
    "m_nForceLOD": 547,
    "m_nIdealMotionType": 546
  },
  "CMolotovProjectile": {
    "m_bDetonated": 2636,
    "m_bHasBouncedOffPlayer": 2864,
    "m_bIsIncGrenade": 2624,
    "m_stillTimer": 2640
  },
  "CMomentaryRotButton": {
    "m_IdealYaw": 2476,
    "m_OnFullyClosed": 2368,
    "m_OnFullyOpen": 2328,
    "m_OnReachedPosition": 2408,
    "m_OnUnpressed": 2288,
    "m_Position": 2248,
    "m_bUpdateTarget": 2488,
    "m_direction": 2492,
    "m_end": 2464,
    "m_flStartPosition": 2500,
    "m_lastUsed": 2448,
    "m_returnSpeed": 2496,
    "m_sNoise": 2480,
    "m_start": 2452
  },
  "CMotorController": {
    "m_axis": 16,
    "m_inertiaFactor": 28,
    "m_maxTorque": 12,
    "m_speed": 8
  },
  "CMultiLightProxy": {
    "m_bPerformScreenFade": 1224,
    "m_flBrightnessDelta": 1220,
    "m_flCurrentBrightnessMultiplier": 1232,
    "m_flLightRadiusFilter": 1216,
    "m_flTargetBrightnessMultiplier": 1228,
    "m_iszLightClassFilter": 1208,
    "m_iszLightNameFilter": 1200,
    "m_vecLights": 1240
  },
  "CMultiSource": {
    "m_OnTrigger": 1456,
    "m_globalstate": 1504,
    "m_iTotal": 1496,
    "m_rgEntities": 1200,
    "m_rgTriggered": 1328
  },
  "CMultiplayer_Expresser": {
    "m_bAllowMultipleScenes": 112
  },
  "CNavHullPresetVData": {
    "m_vecNavHulls": 0
  },
  "CNavHullVData": {
    "m_agentBorderErosion": 40,
    "m_agentHeight": 8,
    "m_agentMaxClimb": 20,
    "m_agentMaxJumpDownDist": 28,
    "m_agentMaxJumpHorizDistBase": 32,
    "m_agentMaxJumpUpDist": 36,
    "m_agentMaxSlope": 24,
    "m_agentRadius": 4,
    "m_agentShortHeight": 16,
    "m_agentShortHeightEnabled": 12,
    "m_bAgentEnabled": 0
  },
  "CNavLinkAnimgraphVar": {
    "m_strAnimgraphVar": 0,
    "m_unAlignmentDegrees": 8
  },
  "CNavLinkAreaEntity": {
    "m_OnNavLinkFinish": 1320,
    "m_OnNavLinkStart": 1280,
    "m_bEnabled": 1256,
    "m_bIsTerminus": 1360,
    "m_flWidth": 1200,
    "m_hFilter": 1272,
    "m_nNavLinkIdForward": 1248,
    "m_nNavLinkIdReverse": 1252,
    "m_qLocatorAnglesOffset": 1216,
    "m_strFilterName": 1264,
    "m_strMovementForward": 1232,
    "m_strMovementReverse": 1240,
    "m_vLocatorOffset": 1204
  },
  "CNavLinkMovementVData": {
    "m_bIsInterpolated": 0,
    "m_unRecommendedDistance": 4,
    "m_vecAnimgraphVars": 8
  },
  "CNavSpaceInfo": {
    "m_bCreateFlightSpace": 1200
  },
  "CNavVolumeBreadthFirstSearch": {
    "m_flSearchDist": 172,
    "m_vStartPos": 160
  },
  "CNavVolumeSphere": {
    "m_flRadius": 124,
    "m_vCenter": 112
  },
  "CNavVolumeSphericalShell": {
    "m_flRadiusInner": 128
  },
  "CNavVolumeVector": {
    "m_bHasBeenPreFiltered": 120
  },
  "CNetworkOriginCellCoordQuantizedVector": {
    "m_cellX": 16,
    "m_cellY": 18,
    "m_cellZ": 20,
    "m_nOutsideWorld": 22,
    "m_vecX": 24,
    "m_vecY": 32,
    "m_vecZ": 40
  },
  "CNetworkOriginQuantizedVector": {
    "m_vecX": 16,
    "m_vecY": 24,
    "m_vecZ": 32
  },
  "CNetworkTransmitComponent": {
    "m_nTransmitStateOwnedCounter": 364
  },
  "CNetworkVelocityVector": {
    "m_vecX": 16,
    "m_vecY": 24,
    "m_vecZ": 32
  },
  "CNetworkViewOffsetVector": {
    "m_vecX": 16,
    "m_vecY": 24,
    "m_vecZ": 32
  },
  "CNetworkedSequenceOperation": {
    "m_bDiscontinuity": 29,
    "m_bSequenceChangeNetworked": 28,
    "m_flCycle": 16,
    "m_flPrevCycle": 12,
    "m_flPrevCycleForAnimEventDetection": 36,
    "m_flPrevCycleFromDiscontinuity": 32,
    "m_flWeight": 20,
    "m_hSequence": 8
  },
  "COmniLight": {
    "m_bShowLight": 2352,
    "m_flInnerAngle": 2344,
    "m_flOuterAngle": 2348
  },
  "COrnamentProp": {
    "m_initialOwner": 2824
  },
  "CParticleSystem": {
    "m_bActive": 2304,
    "m_bAnimateDuringGameplayPause": 2316,
    "m_bFrozen": 2305,
    "m_bNoFreeze": 2645,
    "m_bNoRamp": 2646,
    "m_bNoSave": 2644,
    "m_bStartActive": 2647,
    "m_clrTint": 3188,
    "m_flFreezeTransitionDuration": 2308,
    "m_flPreSimTime": 2332,
    "m_flStartTime": 2328,
    "m_hControlPointEnts": 2388,
    "m_iEffectIndex": 2320,
    "m_iServerControlPointAssignments": 2384,
    "m_iszControlPointNames": 2656,
    "m_iszEffectName": 2648,
    "m_nDataCP": 3168,
    "m_nStopType": 2312,
    "m_nTintCP": 3184,
    "m_szSnapshotFileName": 1792,
    "m_vServerControlPoints": 2336,
    "m_vecDataCPValue": 3172
  },
  "CPathCorner": {
    "m_OnPass": 1208,
    "m_flRadius": 1204,
    "m_flWait": 1200
  },
  "CPathKeyFrame": {
    "m_Angles": 1212,
    "m_Origin": 1200,
    "m_flNextTime": 1256,
    "m_flSpeed": 1280,
    "m_iNextKey": 1248,
    "m_pNextKey": 1264,
    "m_pPrevKey": 1272,
    "m_qAngle": 1232
  },
  "CPathParticleRope": {
    "m_ColorTint": 1252,
    "m_PathNodes_Color": 1344,
    "m_PathNodes_Name": 1216,
    "m_PathNodes_PinEnabled": 1368,
    "m_PathNodes_Position": 1272,
    "m_PathNodes_RadiusScale": 1392,
    "m_PathNodes_TangentIn": 1296,
    "m_PathNodes_TangentOut": 1320,
    "m_bStartActive": 1200,
    "m_flMaxSimulationTime": 1204,
    "m_flParticleSpacing": 1240,
    "m_flRadius": 1248,
    "m_flSlack": 1244,
    "m_iEffectIndex": 1264,
    "m_iszEffectName": 1208,
    "m_nEffectState": 1256
  },
  "CPathTrack": {
    "m_OnPass": 1248,
    "m_altName": 1232,
    "m_eOrientationType": 1244,
    "m_flRadius": 1224,
    "m_length": 1228,
    "m_nIterVal": 1240,
    "m_paltpath": 1216,
    "m_pnext": 1200,
    "m_pprevious": 1208
  },
  "CPhysBallSocket": {
    "m_bEnableSwingLimit": 1292,
    "m_bEnableTwistLimit": 1300,
    "m_flFriction": 1288,
    "m_flMaxTwistAngle": 1308,
    "m_flMinTwistAngle": 1304,
    "m_flSwingLimit": 1296
  },
  "CPhysBox": {
    "m_OnAwakened": 2064,
    "m_OnDamaged": 2024,
    "m_OnMotionEnabled": 2104,
    "m_OnPlayerUse": 2144,
    "m_OnStartTouch": 2184,
    "m_angPreferredCarryAngles": 2000,
    "m_bEnableUseOutput": 2013,
    "m_bNotSolidToWorld": 2012,
    "m_damageToEnableMotion": 1992,
    "m_damageType": 1984,
    "m_flForceToEnableMotion": 1996,
    "m_flTouchOutputPerEntityDelay": 2020,
    "m_hCarryingPlayer": 2224,
    "m_iExploitableByPlayer": 2016,
    "m_massScale": 1988
  },
  "CPhysConstraint": {
    "m_OnBreak": 1248,
    "m_breakSound": 1224,
    "m_forceLimit": 1232,
    "m_minTeleportDistance": 1244,
    "m_nameAttach1": 1208,
    "m_nameAttach2": 1216,
    "m_teleportTick": 1240,
    "m_torqueLimit": 1236
  },
  "CPhysExplosion": {
    "m_OnPushedPlayer": 1240,
    "m_bConvertToDebrisWhenPossible": 1232,
    "m_bExplodeOnSpawn": 1200,
    "m_flDamage": 1208,
    "m_flInnerRadius": 1224,
    "m_flMagnitude": 1204,
    "m_flPushScale": 1228,
    "m_radius": 1212,
    "m_targetEntityName": 1216
  },
  "CPhysFixed": {
    "m_bEnableAngularConstraint": 1305,
    "m_bEnableLinearConstraint": 1304,
    "m_flAngularDampingRatio": 1300,
    "m_flAngularFrequency": 1296,
    "m_flLinearDampingRatio": 1292,
    "m_flLinearFrequency": 1288
  },
  "CPhysForce": {
    "m_attachedObject": 1224,
    "m_force": 1216,
    "m_forceTime": 1220,
    "m_integrator": 1232,
    "m_nameAttach": 1208,
    "m_wasRestored": 1228
  },
  "CPhysHinge": {
    "m_NotifyMaxLimitReached": 1472,
    "m_NotifyMinLimitReached": 1432,
    "m_OnStartMoving": 1624,
    "m_OnStopMoving": 1664,
    "m_bAtMaxLimit": 1513,
    "m_bAtMinLimit": 1512,
    "m_bIsAxisLocal": 1588,
    "m_flAngleSpeed": 1612,
    "m_flAngleSpeedThreshold": 1616,
    "m_flInitialRotation": 1600,
    "m_flMaxRotation": 1596,
    "m_flMinRotation": 1592,
    "m_flMotorDampingRatio": 1608,
    "m_flMotorFrequency": 1604,
    "m_hinge": 1516,
    "m_hingeFriction": 1580,
    "m_soundInfo": 1296,
    "m_systemLoadScale": 1584
  },
  "CPhysImpact": {
    "m_damage": 1200,
    "m_directionEntityName": 1208,
    "m_distance": 1204
  },
  "CPhysLength": {
    "m_addLength": 1324,
    "m_bEnableCollision": 1336,
    "m_minLength": 1328,
    "m_offset": 1288,
    "m_totalLength": 1332,
    "m_vecAttach": 1312
  },
  "CPhysMagnet": {
    "m_MagnettedEntities": 2288,
    "m_OnMagnetAttach": 2192,
    "m_OnMagnetDetach": 2232,
    "m_bActive": 2312,
    "m_bHasHitSomething": 2313,
    "m_flNextSuckTime": 2324,
    "m_flRadius": 2320,
    "m_flTotalMass": 2316,
    "m_forceLimit": 2276,
    "m_iMaxObjectsAttached": 2328,
    "m_massScale": 2272,
    "m_torqueLimit": 2280
  },
  "CPhysMotor": {
    "m_additionalAcceleration": 1216,
    "m_angularAcceleration": 1220,
    "m_hAttachedObject": 1208,
    "m_lastTime": 1224,
    "m_motor": 1248,
    "m_nameAttach": 1200,
    "m_spinUp": 1212
  },
  "CPhysPulley": {
    "m_addLength": 1324,
    "m_gearRatio": 1328,
    "m_offset": 1300,
    "m_position2": 1288
  },
  "CPhysSlideConstraint": {
    "m_axisEnd": 1296,
    "m_bEnableAngularConstraint": 1321,
    "m_bEnableLinearConstraint": 1320,
    "m_bUseEntityPivot": 1332,
    "m_flMotorDampingRatio": 1328,
    "m_flMotorFrequency": 1324,
    "m_initialOffset": 1316,
    "m_slideFriction": 1308,
    "m_soundInfo": 1336,
    "m_systemLoadScale": 1312
  },
  "CPhysThruster": {
    "m_localOrigin": 1296
  },
  "CPhysTorque": {
    "m_axis": 1296
  },
  "CPhysWheelConstraint": {
    "m_bEnableSteeringLimit": 1312,
    "m_bEnableSuspensionLimit": 1300,
    "m_flMaxSteeringAngle": 1320,
    "m_flMaxSuspensionOffset": 1308,
    "m_flMinSteeringAngle": 1316,
    "m_flMinSuspensionOffset": 1304,
    "m_flSpinAxisFriction": 1328,
    "m_flSteeringAxisFriction": 1324,
    "m_flSuspensionDampingRatio": 1292,
    "m_flSuspensionFrequency": 1288,
    "m_flSuspensionHeightOffset": 1296
  },
  "CPhysicsEntitySolver": {
    "m_cancelTime": 1220,
    "m_hMovingEntity": 1208,
    "m_hPhysicsBlocker": 1212,
    "m_separationDuration": 1216
  },
  "CPhysicsProp": {
    "m_MotionEnabled": 2576,
    "m_OnAsleep": 2696,
    "m_OnAwake": 2656,
    "m_OnAwakened": 2616,
    "m_OnOutOfWorld": 2816,
    "m_OnPlayerPickup": 2776,
    "m_OnPlayerUse": 2736,
    "m_bAcceptDamageFromHeldObjects": 2924,
    "m_bAwake": 2926,
    "m_bDroppedByPlayer": 2881,
    "m_bEnableUseOutput": 2925,
    "m_bFirstCollisionAfterLaunch": 2883,
    "m_bForceNavIgnore": 2912,
    "m_bForceNpcExclude": 2914,
    "m_bHasBeenAwakened": 2888,
    "m_bIsOverrideProp": 2889,
    "m_bMuteImpactEffects": 2916,
    "m_bNoNavmeshBlocker": 2913,
    "m_bShouldAutoConvertBackFromDebris": 2915,
    "m_bThrownByPlayer": 2880,
    "m_bTouchedByPlayer": 2882,
    "m_buoyancyScale": 2864,
    "m_damageToEnableMotion": 2872,
    "m_damageType": 2868,
    "m_fNextCheckDisableMotionContactsTime": 2892,
    "m_flForceToEnableMotion": 2876,
    "m_glowColor": 2908,
    "m_iExploitableByPlayer": 2884,
    "m_iInitialGlowState": 2896,
    "m_inertiaScale": 2860,
    "m_massScale": 2856,
    "m_nCollisionGroupOverride": 2928,
    "m_nGlowRange": 2900,
    "m_nGlowRangeMin": 2904
  },
  "CPhysicsPropRespawnable": {
    "m_flRespawnDuration": 2984,
    "m_vOriginalMaxs": 2972,
    "m_vOriginalMins": 2960,
    "m_vOriginalSpawnAngles": 2948,
    "m_vOriginalSpawnOrigin": 2936
  },
  "CPhysicsShake": {
    "m_force": 8
  },
  "CPhysicsSpring": {
    "m_end": 1252,
    "m_flDampingRatio": 1212,
    "m_flFrequency": 1208,
    "m_flRestLength": 1216,
    "m_nameAttachEnd": 1232,
    "m_nameAttachStart": 1224,
    "m_start": 1240,
    "m_teleportTick": 1264
  },
  "CPhysicsWire": {
    "m_nDensity": 1200
  },
  "CPlantedC4": {
    "m_OnBombBeginDefuse": 2248,
    "m_OnBombDefuseAborted": 2288,
    "m_OnBombDefused": 2208,
    "m_angCatchUpToPlayerEye": 2432,
    "m_bBeingDefused": 2372,
    "m_bBombDefused": 2396,
    "m_bBombTicking": 2192,
    "m_bCannotBeDefused": 2328,
    "m_bHasExploded": 2365,
    "m_bPlantedAfterPickup": 2428,
    "m_bTrainingPlacedByPlayer": 2364,
    "m_bVoiceAlertFired": 2412,
    "m_bVoiceAlertPlayed": 2413,
    "m_entitySpottedState": 2336,
    "m_fLastDefuseTime": 2380,
    "m_flC4Blow": 2196,
    "m_flDefuseCountDown": 2392,
    "m_flDefuseLength": 2388,
    "m_flLastSpinDetectionTime": 2444,
    "m_flNextBotBeepTime": 2420,
    "m_flTimerLength": 2368,
    "m_hBombDefuser": 2400,
    "m_hControlPanel": 2404,
    "m_iProgressBarTime": 2408,
    "m_nBombSite": 2200,
    "m_nSourceSoundscapeHash": 2204,
    "m_nSpotRules": 2360
  },
  "CPlatTrigger": {
    "m_pPlatform": 1792
  },
  "CPlayerControllerComponent": {
    "__m_pChainEntity": 8
  },
  "CPlayerPawnComponent": {
    "__m_pChainEntity": 8
  },
  "CPlayerPing": {
    "m_bUrgent": 1220,
    "m_hPingedEntity": 1212,
    "m_hPlayer": 1208,
    "m_iType": 1216,
    "m_szPlaceName": 1221
  },
  "CPlayerSprayDecal": {
    "m_flCreationTime": 1868,
    "m_nEntity": 1860,
    "m_nHitbox": 1864,
    "m_nPlayer": 1856,
    "m_nTintID": 1872,
    "m_nUniqueID": 1792,
    "m_nVersion": 1876,
    "m_rtGcTime": 1804,
    "m_ubSignature": 1877,
    "m_unAccountID": 1796,
    "m_unTraceID": 1800,
    "m_vecEndPos": 1808,
    "m_vecLeft": 1832,
    "m_vecNormal": 1844,
    "m_vecStart": 1820
  },
  "CPlayerVisibility": {
    "m_bIsEnabled": 1217,
    "m_bStartDisabled": 1216,
    "m_flFadeTime": 1212,
    "m_flFogDistanceMultiplier": 1204,
    "m_flFogMaxDensityMultiplier": 1208,
    "m_flVisibilityStrength": 1200
  },
  "CPlayer_CameraServices": {
    "m_PlayerFog": 88,
    "m_PostProcessingVolumes": 288,
    "m_audio": 168,
    "m_flCsViewPunchAngleTickRatio": 80,
    "m_flOldPlayerViewOffsetZ": 316,
    "m_flOldPlayerZ": 312,
    "m_hColorCorrectionCtrl": 152,
    "m_hTonemapController": 160,
    "m_hTriggerSoundscapeList": 344,
    "m_hViewEntity": 156,
    "m_nCsViewPunchAngleTick": 76,
    "m_vecCsViewPunchAngle": 64
  },
  "CPlayer_MovementServices": {
    "m_arrForceSubtickMoveWhen": 404,
    "m_flForwardMove": 420,
    "m_flLeftMove": 424,
    "m_flMaxspeed": 400,
    "m_flUpMove": 428,
    "m_nButtonDoublePressed": 120,
    "m_nButtons": 72,
    "m_nImpulse": 64,
    "m_nLastCommandNumberProcessed": 384,
    "m_nQueuedButtonChangeMask": 112,
    "m_nQueuedButtonDownMask": 104,
    "m_nToggleButtonDownMask": 392,
    "m_pButtonPressedCmdNumber": 128,
    "m_vecLastMovementImpulses": 432,
    "m_vecOldViewAngles": 444
  },
  "CPlayer_MovementServices_Humanoid": {
    "m_bDucked": 484,
    "m_bDucking": 485,
    "m_bInCrouch": 472,
    "m_bInDuckJump": 486,
    "m_flCrouchTransitionStartTime": 480,
    "m_flFallVelocity": 468,
    "m_flStepSoundTime": 464,
    "m_flSurfaceFriction": 500,
    "m_groundNormal": 488,
    "m_iTargetVolume": 524,
    "m_nCrouchState": 476,
    "m_nStepside": 520,
    "m_surfaceProps": 504,
    "m_vecSmoothedVelocity": 528
  },
  "CPlayer_ObserverServices": {
    "m_bForcedObserverMode": 76,
    "m_hObserverTarget": 68,
    "m_iObserverLastMode": 72,
    "m_iObserverMode": 64
  },
  "CPlayer_WeaponServices": {
    "m_bAllowSwitchToNoWeapon": 64,
    "m_bPreventWeaponPickup": 168,
    "m_hActiveWeapon": 96,
    "m_hLastWeapon": 100,
    "m_hMyWeapons": 72,
    "m_iAmmo": 104
  },
  "CPointAngleSensor": {
    "m_FacingPercentage": 1360,
    "m_OnFacingLookat": 1240,
    "m_OnNotFacingLookat": 1280,
    "m_TargetDir": 1320,
    "m_bDisabled": 1200,
    "m_bFired": 1236,
    "m_flDotTolerance": 1228,
    "m_flDuration": 1224,
    "m_flFacingTime": 1232,
    "m_hLookAtEntity": 1220,
    "m_hTargetEntity": 1216,
    "m_nLookAtName": 1208
  },
  "CPointAngularVelocitySensor": {
    "m_AngularVelocity": 1256,
    "m_OnEqualTo": 1456,
    "m_OnGreaterThan": 1376,
    "m_OnGreaterThanOrEqualTo": 1416,
    "m_OnLessThan": 1296,
    "m_OnLessThanOrEqualTo": 1336,
    "m_bUseHelper": 1252,
    "m_flFireInterval": 1220,
    "m_flFireTime": 1216,
    "m_flLastAngVelocity": 1224,
    "m_flThreshold": 1204,
    "m_hTargetEntity": 1200,
    "m_lastOrientation": 1228,
    "m_nLastCompareResult": 1208,
    "m_nLastFireResult": 1212,
    "m_vecAxis": 1240
  },
  "CPointCamera": {
    "m_DegreesPerSecond": 1280,
    "m_FOV": 1200,
    "m_FogColor": 1209,
    "m_Resolution": 1204,
    "m_TargetFOV": 1276,
    "m_bActive": 1228,
    "m_bCanHLTVUse": 1252,
    "m_bDofEnabled": 1253,
    "m_bFogEnable": 1208,
    "m_bIsOn": 1284,
    "m_bNoSky": 1236,
    "m_bUseScreenAspectRatio": 1229,
    "m_fBrightness": 1240,
    "m_flAspectRatio": 1232,
    "m_flDofFarBlurry": 1268,
    "m_flDofFarCrisp": 1264,
    "m_flDofNearBlurry": 1256,
    "m_flDofNearCrisp": 1260,
    "m_flDofTiltToGround": 1272,
    "m_flFogEnd": 1220,
    "m_flFogMaxDensity": 1224,
    "m_flFogStart": 1216,
    "m_flZFar": 1244,
    "m_flZNear": 1248,
    "m_pNext": 1288
  },
  "CPointCameraVFOV": {
    "m_flVerticalFOV": 1296
  },
  "CPointClientUIDialog": {
    "m_bStartEnabled": 2228,
    "m_hActivator": 2224
  },
  "CPointClientUIWorldPanel": {
    "m_bAllowInteractionFromAllSceneWorlds": 2264,
    "m_bDisableMipGen": 2303,
    "m_bExcludeFromSaveGames": 2300,
    "m_bFollowPlayerAcrossTeleport": 2226,
    "m_bGrabbable": 2301,
    "m_bIgnoreInput": 2224,
    "m_bLit": 2225,
    "m_bNoDepth": 2297,
    "m_bOnlyRenderToTexture": 2302,
    "m_bOpaque": 2296,
    "m_bRenderBackface": 2298,
    "m_bUseOffScreenIndicator": 2299,
    "m_flDPI": 2236,
    "m_flDepthOffset": 2244,
    "m_flHeight": 2232,
    "m_flInteractDistance": 2240,
    "m_flWidth": 2228,
    "m_nExplicitImageLayout": 2304,
    "m_unHorizontalAlign": 2252,
    "m_unOrientation": 2260,
    "m_unOwnerContext": 2248,
    "m_unVerticalAlign": 2256,
    "m_vecCSSClasses": 2272
  },
  "CPointClientUIWorldTextPanel": {
    "m_messageText": 2312
  },
  "CPointCommentaryNode": {
    "m_bActive": 2392,
    "m_bDisabled": 2293,
    "m_bListenedTo": 2432,
    "m_bPreventChangesWhileMoving": 2292,
    "m_bPreventMovement": 2248,
    "m_bUnderCrosshair": 2249,
    "m_bUnstoppable": 2250,
    "m_flAbortedPlaybackAt": 2308,
    "m_flFinishedTime": 2252,
    "m_flStartTime": 2396,
    "m_flStartTimeInCommentary": 2400,
    "m_hViewPosition": 2240,
    "m_hViewPositionMover": 2244,
    "m_hViewTarget": 2224,
    "m_hViewTargetAngles": 2228,
    "m_iNodeNumber": 2424,
    "m_iNodeNumberMax": 2428,
    "m_iszCommentaryFile": 2208,
    "m_iszPostCommands": 2200,
    "m_iszPreCommands": 2192,
    "m_iszSpeakers": 2416,
    "m_iszTitle": 2408,
    "m_iszViewPosition": 2232,
    "m_iszViewTarget": 2216,
    "m_pOnCommentaryStarted": 2312,
    "m_pOnCommentaryStopped": 2352,
    "m_vecFinishAngles": 2280,
    "m_vecFinishOrigin": 2256,
    "m_vecOriginalAngles": 2268,
    "m_vecTeleportOrigin": 2296
  },
  "CPointEntityFinder": {
    "m_FindMethod": 1236,
    "m_OnFoundEntity": 1240,
    "m_hEntity": 1200,
    "m_hFilter": 1216,
    "m_hReference": 1232,
    "m_iFilterName": 1208,
    "m_iRefName": 1224
  },
  "CPointGamestatsCounter": {
    "m_bDisabled": 1208,
    "m_strStatisticName": 1200
  },
  "CPointGiveAmmo": {
    "m_pActivator": 1200
  },
  "CPointHurt": {
    "m_bitsDamageType": 1204,
    "m_flDelay": 1212,
    "m_flRadius": 1208,
    "m_nDamage": 1200,
    "m_pActivator": 1224,
    "m_strTarget": 1216
  },
  "CPointPrefab": {
    "m_associatedRelayEntity": 1228,
    "m_associatedRelayTargetName": 1216,
    "m_bLoadDynamic": 1225,
    "m_fixupNames": 1224,
    "m_forceWorldGroupID": 1208,
    "m_targetMapName": 1200
  },
  "CPointProximitySensor": {
    "m_Distance": 1208,
    "m_bDisabled": 1200,
    "m_hTargetEntity": 1204
  },
  "CPointPulse": {
    "m_sNameFixupLocal": 1496,
    "m_sNameFixupParent": 1488,
    "m_sNameFixupStaticPrefix": 1480
  },
  "CPointPush": {
    "m_bEnabled": 1200,
    "m_flConeOfInfluence": 1216,
    "m_flInnerRadius": 1212,
    "m_flMagnitude": 1204,
    "m_flRadius": 1208,
    "m_hFilter": 1232,
    "m_iszFilterName": 1224
  },
  "CPointTeleport": {
    "m_bTeleportParentedEntities": 1224,
    "m_bTeleportUseCurrentAngle": 1225,
    "m_vSaveAngles": 1212,
    "m_vSaveOrigin": 1200
  },
  "CPointTemplate": {
    "m_ScriptCallbackScope": 1336,
    "m_ScriptSpawnCallback": 1328,
    "m_SpawnedEntityHandles": 1304,
    "m_bAsynchronouslySpawnEntities": 1228,
    "m_clientOnlyEntityBehavior": 1272,
    "m_createdSpawnGroupHandles": 1280,
    "m_flTimeoutInterval": 1224,
    "m_iszEntityFilterName": 1216,
    "m_iszSource2EntityLumpName": 1208,
    "m_iszWorldName": 1200,
    "m_ownerSpawnGroupType": 1276,
    "m_pOutputOnSpawned": 1232
  },
  "CPointValueRemapper": {
    "m_OnDisengage": 1664,
    "m_OnEngage": 1624,
    "m_OnReachedValueCustom": 1584,
    "m_OnReachedValueOne": 1544,
    "m_OnReachedValueZero": 1504,
    "m_Position": 1424,
    "m_PositionDelta": 1464,
    "m_bDisabled": 1200,
    "m_bEngaged": 1344,
    "m_bFirstUpdate": 1345,
    "m_bRequiresUseKey": 1244,
    "m_bUpdateOnClient": 1201,
    "m_flCurrentMomentum": 1328,
    "m_flCustomOutputValue": 1372,
    "m_flDisengageDistance": 1236,
    "m_flEngageDistance": 1240,
    "m_flInputOffset": 1340,
    "m_flMaximumChangePerSecond": 1232,
    "m_flMomentumModifier": 1320,
    "m_flPreviousUpdateTickTime": 1352,
    "m_flPreviousValue": 1348,
    "m_flRatchetOffset": 1336,
    "m_flSnapValue": 1324,
    "m_hOutputEntities": 1288,
    "m_hRemapLineEnd": 1228,
    "m_hRemapLineStart": 1224,
    "m_hUsingPlayer": 1368,
    "m_iszOutputEntity2Name": 1264,
    "m_iszOutputEntity3Name": 1272,
    "m_iszOutputEntity4Name": 1280,
    "m_iszOutputEntityName": 1256,
    "m_iszRemapLineEndName": 1216,
    "m_iszRemapLineStartName": 1208,
    "m_iszSoundDisengage": 1384,
    "m_iszSoundEngage": 1376,
    "m_iszSoundMovingLoop": 1408,
    "m_iszSoundReachedValueOne": 1400,
    "m_iszSoundReachedValueZero": 1392,
    "m_nHapticsType": 1312,
    "m_nInputType": 1204,
    "m_nMomentumType": 1316,
    "m_nOutputType": 1248,
    "m_nRatchetType": 1332,
    "m_vecPreviousTestPoint": 1356
  },
  "CPointVelocitySensor": {
    "m_Velocity": 1232,
    "m_bEnabled": 1216,
    "m_fPrevVelocity": 1220,
    "m_flAvgInterval": 1224,
    "m_hTargetEntity": 1200,
    "m_vecAxis": 1204
  },
  "CPointWorldText": {
    "m_Color": 2384,
    "m_FontName": 2304,
    "m_bEnabled": 2368,
    "m_bFullbright": 2369,
    "m_flDepthOffset": 2380,
    "m_flFontSize": 2376,
    "m_flWorldUnitsPerPx": 2372,
    "m_messageText": 1792,
    "m_nJustifyHorizontal": 2388,
    "m_nJustifyVertical": 2392,
    "m_nReorientMode": 2396
  },
  "CPostProcessingVolume": {
    "m_bExposureControl": 2277,
    "m_bMaster": 2276,
    "m_flExposureCompensation": 2260,
    "m_flExposureFadeSpeedDown": 2268,
    "m_flExposureFadeSpeedUp": 2264,
    "m_flFadeDuration": 2240,
    "m_flMaxExposure": 2256,
    "m_flMaxLogExposure": 2248,
    "m_flMinExposure": 2252,
    "m_flMinLogExposure": 2244,
    "m_flRate": 2280,
    "m_flTonemapEVSmoothingRange": 2272,
    "m_flTonemapMinAvgLum": 2292,
    "m_flTonemapPercentBrightPixels": 2288,
    "m_flTonemapPercentTarget": 2284,
    "m_hPostSettings": 2232
  },
  "CPrecipitationVData": {
    "m_bBatchSameVolumeType": 272,
    "m_flInnerDistance": 264,
    "m_nAttachType": 268,
    "m_nRTEnvCP": 276,
    "m_nRTEnvCPComponent": 280,
    "m_szModifier": 288,
    "m_szParticlePrecipitationEffect": 40
  },
  "CProjectedDecal": {
    "m_flDistance": 1204,
    "m_nTexture": 1200
  },
  "CPropDoorRotating": {
    "m_angGoal": 3560,
    "m_angRotationAjarDeprecated": 3512,
    "m_angRotationClosed": 3524,
    "m_angRotationOpenBack": 3548,
    "m_angRotationOpenForward": 3536,
    "m_bAjarDoorShouldntAlwaysOpen": 3620,
    "m_eCurrentOpenDirection": 3504,
    "m_eOpenDirection": 3500,
    "m_eSpawnPosition": 3496,
    "m_flAjarAngle": 3508,
    "m_flDistance": 3492,
    "m_hEntityBlocker": 3624,
    "m_vecAxis": 3480,
    "m_vecBackBoundsMax": 3608,
    "m_vecBackBoundsMin": 3596,
    "m_vecForwardBoundsMax": 3584,
    "m_vecForwardBoundsMin": 3572
  },
  "CPropDoorRotatingBreakable": {
    "m_bBreakable": 3632,
    "m_currentDamageState": 3636,
    "m_damageStates": 3640,
    "m_isAbleToCloseAreaPortals": 3633
  },
  "CPulseCell_Inflow_GameEvent": {
    "m_EventName": 112
  },
  "CPulseCell_Outflow_PlayVCD": {
    "m_OnFinished": 80,
    "m_Triggers": 96,
    "m_vcdFilename": 72
  },
  "CPulseCell_SoundEventStart": {
    "m_Type": 72
  },
  "CPulseCell_Step_EntFire": {
    "m_Input": 72
  },
  "CPulseCell_Step_SetAnimGraphParam": {
    "m_ParamName": 72
  },
  "CPulseCell_Value_FindEntByName": {
    "m_EntityType": 72
  },
  "CRR_Response": {
    "m_Followup": 384,
    "m_Params": 328,
    "m_Type": 0,
    "m_fMatchScore": 360,
    "m_pchCriteriaNames": 440,
    "m_pchCriteriaValues": 464,
    "m_szMatchingRule": 193,
    "m_szResponseName": 1,
    "m_szSpeakerContext": 368,
    "m_szWorldContext": 376
  },
  "CRagdollConstraint": {
    "m_xfriction": 1312,
    "m_xmax": 1292,
    "m_xmin": 1288,
    "m_yfriction": 1316,
    "m_ymax": 1300,
    "m_ymin": 1296,
    "m_zfriction": 1320,
    "m_zmax": 1308,
    "m_zmin": 1304
  },
  "CRagdollMagnet": {
    "m_axis": 1212,
    "m_bDisabled": 1200,
    "m_force": 1208,
    "m_radius": 1204
  },
  "CRagdollManager": {
    "m_bSaveImportant": 1208,
    "m_iCurrentMaxRagdollCount": 1200,
    "m_iMaxRagdollCount": 1204
  },
  "CRagdollProp": {
    "m_allAsleep": 2320,
    "m_bFirstCollisionAfterLaunch": 2321,
    "m_bHasBeenPhysgunned": 2392,
    "m_bShouldDeleteActivationRecord": 2456,
    "m_bShouldTeleportPhysics": 2393,
    "m_bStartDisabled": 2256,
    "m_bValidatePoweredRagdollPose": 2552,
    "m_flAwakeTime": 2360,
    "m_flBlendWeight": 2396,
    "m_flDefaultFadeScale": 2400,
    "m_flFadeOutStartTime": 2340,
    "m_flFadeTime": 2344,
    "m_flLastOriginChangeTime": 2364,
    "m_flLastPhysicsInfluenceTime": 2336,
    "m_hDamageEntity": 2324,
    "m_hKiller": 2328,
    "m_hPhysicsAttacker": 2332,
    "m_hRagdollSource": 2312,
    "m_lastUpdateTickCount": 2316,
    "m_nBloodColor": 2368,
    "m_ragAngles": 2288,
    "m_ragPos": 2264,
    "m_ragdoll": 2200,
    "m_ragdollMaxs": 2432,
    "m_ragdollMins": 2408,
    "m_strOriginClassName": 2376,
    "m_strSourceClassName": 2384,
    "m_vecLastOrigin": 2348
  },
  "CRagdollPropAttached": {
    "m_attachmentPointBoneSpace": 2624,
    "m_attachmentPointRagdollSpace": 2636,
    "m_bShouldDeleteAttachedActivationRecord": 2664,
    "m_bShouldDetach": 2648,
    "m_boneIndexAttached": 2616,
    "m_ragdollAttachedObjectIndex": 2620
  },
  "CRandSimTimer": {
    "m_maxInterval": 12,
    "m_minInterval": 8
  },
  "CRandStopwatch": {
    "m_maxInterval": 16,
    "m_minInterval": 12
  },
  "CRangeFloat": {
    "m_pValue": 0
  },
  "CRangeInt": {
    "m_pValue": 0
  },
  "CRectLight": {
    "m_bShowLight": 2344
  },
  "CRemapFloat": {
    "m_pValue": 0
  },
  "CRenderComponent": {
    "__m_pChainEntity": 16,
    "m_bEnableRendering": 96,
    "m_bInterpolationReadyToDraw": 176,
    "m_bIsRenderingWithViewModels": 80,
    "m_nSplitscreenFlags": 84
  },
  "CResponseCriteriaSet": {
    "m_bOverrideOnAppend": 44,
    "m_nNumPrefixedContexts": 40
  },
  "CResponseQueue": {
    "m_ExpresserTargets": 80
  },
  "CResponseQueue_CDeferredResponse": {
    "m_bResponseValid": 568,
    "m_contexts": 16,
    "m_fDispatchTime": 64,
    "m_hIssuer": 68,
    "m_response": 80
  },
  "CRetakeGameRules": {
    "m_bBlockersPresent": 252,
    "m_bRoundInProgress": 253,
    "m_iBombSite": 260,
    "m_iFirstSecondHalfRound": 256,
    "m_nMatchSeed": 248
  },
  "CRevertSaved": {
    "m_Duration": 1796,
    "m_HoldTime": 1800,
    "m_loadTime": 1792
  },
  "CRopeKeyframe": {
    "m_RopeFlags": 1800,
    "m_RopeLength": 1850,
    "m_Slack": 1816,
    "m_Subdiv": 1848,
    "m_TextureScale": 1824,
    "m_Width": 1820,
    "m_bConstrainBetweenEndpoints": 1829,
    "m_bCreatedFromMapFile": 1853,
    "m_bEndPointValid": 1861,
    "m_bStartPointValid": 1860,
    "m_fLockedPoints": 1852,
    "m_flScrollSpeed": 1856,
    "m_hEndPoint": 1868,
    "m_hStartPoint": 1864,
    "m_iEndAttachment": 1873,
    "m_iNextLinkName": 1808,
    "m_iRopeMaterialModelIndex": 1840,
    "m_iStartAttachment": 1872,
    "m_nChangeCount": 1849,
    "m_nSegments": 1828,
    "m_strRopeMaterialModel": 1832
  },
  "CRotDoor": {
    "m_bSolidBsp": 2440
  },
  "CRuleEntity": {
    "m_iszMaster": 1792
  },
  "CRulePointEntity": {
    "m_Score": 1800
  },
  "CSAdditionalMatchStats_t": {
    "m_iNumSuicides": 56,
    "m_iNumTeamKills": 60,
    "m_iRoundsWonWithoutPurchase": 32,
    "m_iRoundsWonWithoutPurchaseTotal": 36,
    "m_iTeamDamage": 64,
    "m_maxNumRoundsSurvived": 24,
    "m_numClutchKills": 44,
    "m_numFirstKills": 40,
    "m_numPistolKills": 48,
    "m_numRoundsSurvived": 20,
    "m_numRoundsSurvivedTotal": 28,
    "m_numSniperKills": 52
  },
  "CSAdditionalPerRoundStats_t": {
    "m_bombCarrierkills": 8,
    "m_iBurnDamageInflicted": 12,
    "m_iDinks": 16,
    "m_killsWhileBlind": 4,
    "m_numChickensKilled": 0
  },
  "CSMatchStats_t": {
    "m_i1v1Count": 156,
    "m_i1v1Wins": 160,
    "m_i1v2Count": 164,
    "m_i1v2Wins": 168,
    "m_iEnemy2Ks": 116,
    "m_iEnemy3Ks": 112,
    "m_iEnemy4Ks": 108,
    "m_iEnemy5Ks": 104,
    "m_iEntryCount": 172,
    "m_iEntryWins": 176,
    "m_iFlash_Count": 132,
    "m_iFlash_Successes": 136,
    "m_iUtility_Count": 120,
    "m_iUtility_Enemies": 128,
    "m_iUtility_Successes": 124,
    "m_nHealthPointsDealtTotal": 144,
    "m_nHealthPointsRemovedTotal": 140,
    "m_nShotsFiredTotal": 148,
    "m_nShotsOnTargetTotal": 152
  },
  "CSPerRoundStats_t": {
    "m_iAssists": 56,
    "m_iCashEarned": 88,
    "m_iDamage": 60,
    "m_iDeaths": 52,
    "m_iEnemiesFlashed": 96,
    "m_iEquipmentValue": 64,
    "m_iHeadShotKills": 80,
    "m_iKillReward": 72,
    "m_iKills": 48,
    "m_iLiveTime": 76,
    "m_iMoneySaved": 68,
    "m_iObjective": 84,
    "m_iUtilityDamage": 92
  },
  "CSceneEntity": {
    "m_BusyActor": 2552,
    "m_OnCanceled": 1528,
    "m_OnCompletion": 1488,
    "m_OnPaused": 1568,
    "m_OnResumed": 1608,
    "m_OnStart": 1448,
    "m_OnTrigger": 1648,
    "m_bAutogenerated": 1323,
    "m_bAutomated": 1344,
    "m_bBreakOnNonIdle": 1370,
    "m_bCancelAtNextInterrupt": 1336,
    "m_bCompletedEarly": 2442,
    "m_bInterruptSceneFinished": 2443,
    "m_bInterrupted": 2441,
    "m_bInterruptedActorsScenes": 1369,
    "m_bIsPlayingBack": 1320,
    "m_bMultiplayer": 1322,
    "m_bPauseAtNextInterrupt": 1366,
    "m_bPaused": 1321,
    "m_bPausedViaInput": 1365,
    "m_bRestoring": 2444,
    "m_bSceneMissing": 2440,
    "m_bWaitingForActor": 1367,
    "m_bWaitingForInterrupt": 1368,
    "m_bWaitingForResumeScene": 1364,
    "m_fPitch": 1340,
    "m_flAutomationDelay": 1352,
    "m_flAutomationTime": 1356,
    "m_flCurrentTime": 1328,
    "m_flForceClientTime": 1324,
    "m_flFrameTime": 1332,
    "m_hActivator": 2548,
    "m_hActor": 2544,
    "m_hActorList": 1376,
    "m_hInterruptScene": 2432,
    "m_hListManagers": 2472,
    "m_hNotifySceneCompletion": 2448,
    "m_hRemoveActorList": 1400,
    "m_hTarget1": 1288,
    "m_hTarget2": 1292,
    "m_hTarget3": 1296,
    "m_hTarget4": 1300,
    "m_hTarget5": 1304,
    "m_hTarget6": 1308,
    "m_hTarget7": 1312,
    "m_hTarget8": 1316,
    "m_hWaitingForThisResumeScene": 1360,
    "m_iPlayerDeathBehavior": 2556,
    "m_iszResumeSceneFile": 1216,
    "m_iszSceneFile": 1208,
    "m_iszSoundName": 2536,
    "m_iszTarget1": 1224,
    "m_iszTarget2": 1232,
    "m_iszTarget3": 1240,
    "m_iszTarget4": 1248,
    "m_iszTarget5": 1256,
    "m_iszTarget6": 1264,
    "m_iszTarget7": 1272,
    "m_iszTarget8": 1280,
    "m_nAutomatedAction": 1348,
    "m_nInterruptCount": 2436,
    "m_nSceneFlushCounter": 1440,
    "m_nSceneStringIndex": 1444
  },
  "CSceneEventInfo": {
    "m_bClientSide": 92,
    "m_bHasArrived": 17,
    "m_bIsGesture": 40,
    "m_bIsMoving": 16,
    "m_bShouldRemove": 41,
    "m_bStarted": 93,
    "m_flFacingYaw": 28,
    "m_flInitialYaw": 20,
    "m_flNext": 36,
    "m_flTargetYaw": 24,
    "m_flWeight": 12,
    "m_hSequence": 8,
    "m_hTarget": 84,
    "m_iLayer": 0,
    "m_iPriority": 4,
    "m_nSceneEventId": 88,
    "m_nType": 32
  },
  "CSceneListManager": {
    "m_hListManagers": 1200,
    "m_hScenes": 1352,
    "m_iszScenes": 1224
  },
  "CScriptComponent": {
    "m_scriptClassName": 48
  },
  "CScriptItem": {
    "m_MoveTypeOverride": 2448,
    "m_OnPlayerPickup": 2408
  },
  "CScriptNavBlocker": {
    "m_vExtent": 1808
  },
  "CScriptTriggerHurt": {
    "m_vExtent": 2376
  },
  "CScriptTriggerMultiple": {
    "m_vExtent": 2256
  },
  "CScriptTriggerOnce": {
    "m_vExtent": 2256
  },
  "CScriptTriggerPush": {
    "m_vExtent": 2256
  },
  "CScriptUniformRandomStream": {
    "m_hScriptScope": 8,
    "m_nInitialSeed": 156
  },
  "CScriptedSequence": {
    "m_ConflictResponse": 1364,
    "m_OnActionStartOrLoop": 1408,
    "m_OnBeginSequence": 1368,
    "m_OnCancelFailedSequence": 1568,
    "m_OnCancelSequence": 1528,
    "m_OnEndSequence": 1448,
    "m_OnPostIdleEndSequence": 1488,
    "m_OnScriptEvent": 1608,
    "m_bAllowCustomInterruptConditions": 1343,
    "m_bDisableNPCCollisions": 1277,
    "m_bDontAddModifiers": 1279,
    "m_bDontCancelOtherSequences": 1352,
    "m_bEnsureOnNavmeshOnFinish": 1356,
    "m_bForceSynch": 1353,
    "m_bForcedAnimatedEveryTick": 1327,
    "m_bIgnoreGravity": 1276,
    "m_bInitiatedSelfDelete": 1341,
    "m_bIsPlayingAction": 1270,
    "m_bIsPlayingEntry": 1269,
    "m_bIsPlayingPostIdle": 1271,
    "m_bIsPlayingPreIdle": 1268,
    "m_bIsTeleportingDueToMoveTo": 1342,
    "m_bKeepAnimgraphLockedPost": 1278,
    "m_bLoopActionSequence": 1273,
    "m_bLoopPostIdleSequence": 1274,
    "m_bLoopPreIdleSequence": 1272,
    "m_bPositionRelativeToOtherEntity": 1328,
    "m_bPrevAnimatedEveryTick": 1326,
    "m_bPreventUpdateYawOnFinish": 1355,
    "m_bSynchPostIdles": 1275,
    "m_bTargetWasAsleep": 1354,
    "m_bThinking": 1340,
    "m_bWaitForBeginSequence": 1308,
    "m_flAngRate": 1296,
    "m_flMoveInterpTime": 1292,
    "m_flPlayAnimFadeInTime": 1288,
    "m_flRadius": 1280,
    "m_flRepeat": 1284,
    "m_hForcedTarget": 1348,
    "m_hInteractionMainEntity": 1968,
    "m_hLastFoundEntity": 1344,
    "m_hNextCine": 1336,
    "m_hTargetEnt": 1332,
    "m_iDelay": 1300,
    "m_iPlayerDeathBehavior": 1972,
    "m_interruptable": 1324,
    "m_iszEntity": 1248,
    "m_iszEntry": 1200,
    "m_iszModifierToAddOnPlay": 1232,
    "m_iszNextScript": 1240,
    "m_iszPlay": 1216,
    "m_iszPostIdle": 1224,
    "m_iszPreIdle": 1208,
    "m_iszSyncGroup": 1256,
    "m_matOtherToMain": 1936,
    "m_nMoveTo": 1264,
    "m_onDeathBehavior": 1360,
    "m_savedCollisionGroup": 1320,
    "m_savedFlags": 1316,
    "m_saved_effects": 1312,
    "m_sequenceStarted": 1325,
    "m_startTime": 1304
  },
  "CSensorGrenadeProjectile": {
    "m_fExpireTime": 2624,
    "m_fNextDetectPlayerSound": 2628,
    "m_hDisplayGrenade": 2632
  },
  "CShatterGlassShard": {
    "m_ShatterStressType": 68,
    "m_bAverageVertPositionIsValid": 132,
    "m_bCreatedModel": 84,
    "m_bFlaggedForRemoval": 154,
    "m_bShatterRateLimited": 160,
    "m_bStressPositionAIsValid": 152,
    "m_bStressPositionBIsValid": 153,
    "m_flArea": 108,
    "m_flLongestAcross": 96,
    "m_flLongestEdge": 88,
    "m_flPhysicsEntitySpawnedAtTime": 156,
    "m_flShortestAcross": 100,
    "m_flShortestEdge": 92,
    "m_flSumOfAllEdges": 104,
    "m_hEntityHittingMe": 164,
    "m_hModel": 48,
    "m_hParentPanel": 60,
    "m_hParentShard": 64,
    "m_hPhysicsEntity": 56,
    "m_hShardHandle": 8,
    "m_nOnFrameEdge": 112,
    "m_nParentPanelsNthShard": 116,
    "m_nSubShardGeneration": 120,
    "m_vLocalPanelSpaceOrigin": 40,
    "m_vecAverageVertPosition": 124,
    "m_vecNeighbors": 168,
    "m_vecPanelSpaceStressPositionA": 136,
    "m_vecPanelSpaceStressPositionB": 144,
    "m_vecPanelVertices": 16,
    "m_vecStressVelocity": 72
  },
  "CShatterGlassShardPhysics": {
    "m_ShardDesc": 2944,
    "m_bDebris": 2936,
    "m_hParentShard": 2940
  },
  "CSimTimer": {
    "m_interval": 8
  },
  "CSimpleSimTimer": {
    "m_nWorldGroupId": 4,
    "m_next": 0
  },
  "CSingleplayRules": {
    "m_bSinglePlayerGameEnding": 144
  },
  "CSkeletonAnimationController": {
    "m_pSkeletonInstance": 8
  },
  "CSkeletonInstance": {
    "m_bDirtyMotionType": 0,
    "m_bDisableSolidCollisionsForHierarchy": 914,
    "m_bIsAnimationEnabled": 912,
    "m_bIsGeneratingLatchedParentSpaceState": 0,
    "m_bUseParentRenderBounds": 913,
    "m_materialGroup": 916,
    "m_modelState": 352,
    "m_nHitboxSet": 920
  },
  "CSkillDamage": {
    "m_flDamage": 0,
    "m_flPhysicsForceDamage": 16
  },
  "CSkillFloat": {
    "m_pValue": 0
  },
  "CSkillInt": {
    "m_pValue": 0
  },
  "CSkyCamera": {
    "m_bUseAngles": 1348,
    "m_pNext": 1352,
    "m_skyboxData": 1200,
    "m_skyboxSlotToken": 1344
  },
  "CSkyboxReference": {
    "m_hSkyCamera": 1204,
    "m_worldGroupId": 1200
  },
  "CSmokeGrenadeProjectile": {
    "m_VoxelFrameData": 2688,
    "m_bDidSmokeEffect": 2652,
    "m_flLastBounce": 2712,
    "m_fllastSimulationTime": 2716,
    "m_nRandomSeed": 2656,
    "m_nSmokeEffectTickBegin": 2648,
    "m_vSmokeColor": 2660,
    "m_vSmokeDetonationPos": 2672
  },
  "CSmoothFunc": {
    "m_flSmoothAmplitude": 8,
    "m_flSmoothBias": 12,
    "m_flSmoothDuration": 16,
    "m_flSmoothRemainingTime": 20,
    "m_nSmoothDir": 24
  },
  "CSound": {
    "m_bHasOwner": 48,
    "m_bNoExpirationTime": 30,
    "m_flExpireTime": 24,
    "m_flOcclusionScale": 12,
    "m_hOwner": 0,
    "m_hTarget": 4,
    "m_iNext": 28,
    "m_iNextAudible": 20,
    "m_iType": 16,
    "m_iVolume": 8,
    "m_ownerChannelIndex": 32,
    "m_vecOrigin": 36
  },
  "CSoundAreaEntityBase": {
    "m_bDisabled": 1200,
    "m_iszSoundAreaType": 1208,
    "m_vPos": 1216
  },
  "CSoundAreaEntityOrientedBox": {
    "m_vMax": 1244,
    "m_vMin": 1232
  },
  "CSoundAreaEntitySphere": {
    "m_flRadius": 1232
  },
  "CSoundEnt": {
    "m_SoundPool": 1212,
    "m_cLastActiveSounds": 1208,
    "m_iActiveSound": 1204,
    "m_iFreeSound": 1200
  },
  "CSoundEnvelope": {
    "m_current": 0,
    "m_forceupdate": 12,
    "m_rate": 8,
    "m_target": 4
  },
  "CSoundEventAABBEntity": {
    "m_vMaxs": 1380,
    "m_vMins": 1368
  },
  "CSoundEventEntity": {
    "m_bSaveRestore": 1203,
    "m_bSavedIsPlaying": 1204,
    "m_bStartOnSpawn": 1200,
    "m_bStopOnNew": 1202,
    "m_bToLocalPlayer": 1201,
    "m_flSavedElapsedTime": 1208,
    "m_hSource": 1360,
    "m_iszAttachmentName": 1224,
    "m_iszSoundName": 1344,
    "m_iszSourceEntityName": 1216,
    "m_onGUIDChanged": 1232,
    "m_onSoundFinished": 1272
  },
  "CSoundEventOBBEntity": {
    "m_vMaxs": 1380,
    "m_vMins": 1368
  },
  "CSoundEventParameter": {
    "m_flFloatValue": 1216,
    "m_iszParamName": 1208
  },
  "CSoundEventPathCornerEntity": {
    "bPlaying": 1392,
    "m_flDistMaxSqr": 1384,
    "m_flDistanceMax": 1380,
    "m_flDotProductMax": 1388,
    "m_iCountMax": 1376,
    "m_iszPathCorner": 1368
  },
  "CSoundOpvarSetAABBEntity": {
    "m_nAABBDirection": 1656,
    "m_vDistanceInnerMaxs": 1620,
    "m_vDistanceInnerMins": 1608,
    "m_vDistanceOuterMaxs": 1644,
    "m_vDistanceOuterMins": 1632,
    "m_vInnerMaxs": 1672,
    "m_vInnerMins": 1660,
    "m_vOuterMaxs": 1696,
    "m_vOuterMins": 1684
  },
  "CSoundOpvarSetEntity": {
    "m_OpvarValueString": 1248,
    "m_bSetOnSpawn": 1256,
    "m_flOpvarValue": 1240,
    "m_iszOperatorName": 1216,
    "m_iszOpvarName": 1224,
    "m_iszStackName": 1208,
    "m_nOpvarIndex": 1236,
    "m_nOpvarType": 1232
  },
  "CSoundOpvarSetOBBWindEntity": {
    "m_flWindMapMax": 1412,
    "m_flWindMapMin": 1408,
    "m_flWindMax": 1404,
    "m_flWindMin": 1400,
    "m_vDistanceMaxs": 1388,
    "m_vDistanceMins": 1376,
    "m_vMaxs": 1364,
    "m_vMins": 1352
  },
  "CSoundOpvarSetPathCornerEntity": {
    "m_flDistMaxSqr": 1636,
    "m_flDistMinSqr": 1632,
    "m_iszPathCornerEntityName": 1640
  },
  "CSoundOpvarSetPointBase": {
    "m_bDisabled": 1200,
    "m_bUseAutoCompare": 1348,
    "m_hSource": 1204,
    "m_iOpvarIndex": 1344,
    "m_iszOperatorName": 1328,
    "m_iszOpvarName": 1336,
    "m_iszSourceEntityName": 1216,
    "m_iszStackName": 1320,
    "m_vLastPosition": 1304
  },
  "CSoundOpvarSetPointEntity": {
    "m_OnEnter": 1352,
    "m_OnExit": 1392,
    "m_bAutoDisable": 1432,
    "m_bSetValueOnDisable": 1532,
    "m_flDistanceMapMax": 1512,
    "m_flDistanceMapMin": 1508,
    "m_flDistanceMax": 1504,
    "m_flDistanceMin": 1500,
    "m_flDynamicMaximumOcclusion": 1556,
    "m_flOcclusionMax": 1524,
    "m_flOcclusionMin": 1520,
    "m_flOcclusionRadius": 1516,
    "m_flPathingDistanceNormFactor": 1576,
    "m_flValSetOnDisable": 1528,
    "m_hDynamicEntity": 1560,
    "m_iszDynamicEntityName": 1568,
    "m_nPathingSourceIndex": 1604,
    "m_nSimulationMode": 1536,
    "m_nVisibilitySamples": 1540,
    "m_vDynamicProxyPoint": 1544,
    "m_vPathingListenerPos": 1592,
    "m_vPathingSourcePos": 1580
  },
  "CSoundPatch": {
    "m_Filter": 88,
    "m_bUpdatedSoundOrigin": 132,
    "m_flCloseCaptionDuration": 128,
    "m_flLastTime": 52,
    "m_hEnt": 64,
    "m_isPlaying": 84,
    "m_iszClassName": 136,
    "m_iszSoundScriptName": 56,
    "m_pitch": 8,
    "m_shutdownTime": 48,
    "m_soundEntityIndex": 68,
    "m_soundOrigin": 72,
    "m_volume": 24
  },
  "CSoundStackSave": {
    "m_iszStackName": 1200
  },
  "CSpotlightEnd": {
    "m_Radius": 1796,
    "m_flLightScale": 1792,
    "m_vSpotlightDir": 1800,
    "m_vSpotlightOrg": 1812
  },
  "CSprite": {
    "m_bWorldSpaceScale": 1848,
    "m_flBrightnessDuration": 1836,
    "m_flBrightnessTimeStart": 1888,
    "m_flDestScale": 1872,
    "m_flDieTime": 1816,
    "m_flFrame": 1812,
    "m_flGlowProxySize": 1852,
    "m_flHDRColorScale": 1856,
    "m_flLastTime": 1860,
    "m_flMaxFrame": 1864,
    "m_flScaleDuration": 1844,
    "m_flScaleTimeStart": 1876,
    "m_flSpriteFramerate": 1808,
    "m_flSpriteScale": 1840,
    "m_flStartScale": 1868,
    "m_hAttachedToEntity": 1800,
    "m_hSpriteMaterial": 1792,
    "m_nAttachment": 1804,
    "m_nBrightness": 1832,
    "m_nDestBrightness": 1884,
    "m_nSpriteHeight": 1896,
    "m_nSpriteWidth": 1892,
    "m_nStartBrightness": 1880
  },
  "CStopwatch": {
    "m_interval": 12
  },
  "CStopwatchBase": {
    "m_fIsRunning": 8
  },
  "CSun": {
    "m_bOn": 1824,
    "m_bmaxColor": 1825,
    "m_clrOverlay": 1804,
    "m_flAlphaHaze": 1840,
    "m_flAlphaHdr": 1844,
    "m_flAlphaScale": 1848,
    "m_flFarZScale": 1856,
    "m_flHDRColorScale": 1852,
    "m_flHazeScale": 1836,
    "m_flRotation": 1832,
    "m_flSize": 1828,
    "m_iszEffectName": 1808,
    "m_iszSSEffectName": 1816,
    "m_vDirection": 1792
  },
  "CTakeDamageInfo": {
    "m_bInTakeDamageFlow": 148,
    "m_bShouldBleed": 100,
    "m_bShouldSpark": 101,
    "m_bitsDamageType": 72,
    "m_flDamage": 68,
    "m_flOriginalDamage": 96,
    "m_hAbility": 64,
    "m_hAttacker": 60,
    "m_hInflictor": 56,
    "m_hScriptInstance": 120,
    "m_iAmmoType": 80,
    "m_iDamageCustom": 76,
    "m_nDamageFlags": 112,
    "m_nNumObjectsPenetrated": 116,
    "m_vecDamageDirection": 44,
    "m_vecDamageForce": 8,
    "m_vecDamagePosition": 20,
    "m_vecReportedPosition": 32
  },
  "CTakeDamageResult": {
    "m_nDamageTaken": 4,
    "m_nHealthLost": 0
  },
  "CTakeDamageSummaryScopeGuard": {
    "m_vecSummaries": 8
  },
  "CTankTargetChange": {
    "m_newTarget": 1200,
    "m_newTargetName": 1216
  },
  "CTankTrainAI": {
    "m_engineSoundName": 1240,
    "m_hTargetEntity": 1204,
    "m_hTrain": 1200,
    "m_movementSoundName": 1248,
    "m_soundPlaying": 1208,
    "m_startSoundName": 1232,
    "m_targetEntityName": 1256
  },
  "CTeam": {
    "m_aPlayerControllers": 1200,
    "m_aPlayers": 1224,
    "m_iScore": 1248,
    "m_szTeamname": 1252
  },
  "CTestEffect": {
    "m_flBeamTime": 1400,
    "m_flStartTime": 1496,
    "m_iBeam": 1204,
    "m_iLoop": 1200,
    "m_pBeam": 1208
  },
  "CTextureBasedAnimatable": {
    "m_bLoop": 1792,
    "m_flFPS": 1796,
    "m_flStartFrame": 1844,
    "m_flStartTime": 1840,
    "m_hPositionKeys": 1800,
    "m_hRotationKeys": 1808,
    "m_vAnimationBoundsMax": 1828,
    "m_vAnimationBoundsMin": 1816
  },
  "CTimeline": {
    "m_bStopped": 544,
    "m_flFinalValue": 536,
    "m_flInterval": 532,
    "m_flValues": 16,
    "m_nBucketCount": 528,
    "m_nCompressionType": 540,
    "m_nValueCounts": 272
  },
  "CTimerEntity": {
    "m_OnTimer": 1200,
    "m_OnTimerHigh": 1240,
    "m_OnTimerLow": 1280,
    "m_bPauseAfterFiring": 1340,
    "m_bPaused": 1356,
    "m_bUpDownState": 1332,
    "m_flInitialDelay": 1324,
    "m_flLowerRandomBound": 1344,
    "m_flRefireTime": 1328,
    "m_flRemainingTime": 1352,
    "m_flUpperRandomBound": 1348,
    "m_iDisabled": 1320,
    "m_iUseRandomTime": 1336
  },
  "CTonemapController2": {
    "m_flAutoExposureMax": 1204,
    "m_flAutoExposureMin": 1200,
    "m_flExposureAdaptationSpeedDown": 1224,
    "m_flExposureAdaptationSpeedUp": 1220,
    "m_flTonemapEVSmoothingRange": 1228,
    "m_flTonemapMinAvgLum": 1216,
    "m_flTonemapPercentBrightPixels": 1212,
    "m_flTonemapPercentTarget": 1208
  },
  "CTonemapTrigger": {
    "m_hTonemapController": 2224,
    "m_tonemapControllerName": 2216
  },
  "CTriggerActiveWeaponDetect": {
    "m_OnTouchedActiveWeapon": 2216,
    "m_iszWeaponClassName": 2256
  },
  "CTriggerBrush": {
    "m_OnEndTouch": 1832,
    "m_OnStartTouch": 1792,
    "m_OnUse": 1872,
    "m_iDontMessageParent": 1916,
    "m_iInputFilter": 1912
  },
  "CTriggerBuoyancy": {
    "m_BuoyancyHelper": 2216,
    "m_flFluidDensity": 2248
  },
  "CTriggerDetectBulletFire": {
    "m_OnDetectedBulletFire": 2224,
    "m_bPlayerFireOnly": 2216
  },
  "CTriggerDetectExplosion": {
    "m_OnDetectedExplosion": 2272
  },
  "CTriggerFan": {
    "m_RampTimer": 2272,
    "m_bAddNoise": 2267,
    "m_bFalloff": 2264,
    "m_bPushPlayer": 2265,
    "m_bRampDown": 2266,
    "m_flForce": 2252,
    "m_flPlayerForce": 2256,
    "m_flRampTime": 2260,
    "m_vFanEnd": 2228,
    "m_vFanOrigin": 2216,
    "m_vNoise": 2240
  },
  "CTriggerGameEvent": {
    "m_strEndTouchEventName": 2224,
    "m_strStartTouchEventName": 2216,
    "m_strTriggerID": 2232
  },
  "CTriggerHurt": {
    "m_OnHurt": 2272,
    "m_OnHurtPlayer": 2312,
    "m_bNoDmgForce": 2244,
    "m_bitsDamageInflict": 2236,
    "m_damageModel": 2240,
    "m_flDamage": 2220,
    "m_flDamageCap": 2224,
    "m_flForgivenessDelay": 2232,
    "m_flLastDmgTime": 2228,
    "m_flOriginalDamage": 2216,
    "m_hurtEntities": 2352,
    "m_hurtThinkPeriod": 2264,
    "m_thinkAlways": 2260,
    "m_vDamageForce": 2248
  },
  "CTriggerImpact": {
    "m_flMagnitude": 2256,
    "m_flNoise": 2260,
    "m_flViewkick": 2264,
    "m_pOutputForce": 2272
  },
  "CTriggerLerpObject": {
    "m_OnLerpFinished": 2336,
    "m_OnLerpStarted": 2296,
    "m_bLerpRestoreMoveType": 2248,
    "m_bSingleLerpObject": 2249,
    "m_flLerpDuration": 2244,
    "m_hLerpTarget": 2224,
    "m_hLerpTargetAttachment": 2240,
    "m_iszLerpEffect": 2280,
    "m_iszLerpSound": 2288,
    "m_iszLerpTarget": 2216,
    "m_iszLerpTargetAttachment": 2232,
    "m_vecLerpingObjects": 2256
  },
  "CTriggerLook": {
    "m_OnEndLook": 2376,
    "m_OnStartLook": 2336,
    "m_OnTimeout": 2296,
    "m_b2DFOV": 2282,
    "m_bIsLooking": 2281,
    "m_bTestOcclusion": 2288,
    "m_bTimeoutFired": 2280,
    "m_bUseVelocity": 2283,
    "m_flFieldOfView": 2260,
    "m_flLookTime": 2264,
    "m_flLookTimeLast": 2272,
    "m_flLookTimeTotal": 2268,
    "m_flTimeoutDuration": 2276,
    "m_hActivator": 2284,
    "m_hLookTarget": 2256
  },
  "CTriggerMultiple": {
    "m_OnTrigger": 2216
  },
  "CTriggerPhysics": {
    "m_angularDamping": 2248,
    "m_angularLimit": 2244,
    "m_bCollapseToForcePoint": 2276,
    "m_bConvertToDebrisWhenPossible": 2304,
    "m_flDampingRatio": 2260,
    "m_flFrequency": 2256,
    "m_gravityScale": 2232,
    "m_linearDamping": 2240,
    "m_linearForce": 2252,
    "m_linearLimit": 2236,
    "m_vecLinearForceDirection": 2292,
    "m_vecLinearForcePointAt": 2264,
    "m_vecLinearForcePointAtWorld": 2280
  },
  "CTriggerProximity": {
    "m_NearestEntityDistance": 2240,
    "m_fRadius": 2232,
    "m_hMeasureTarget": 2216,
    "m_iszMeasureTarget": 2224,
    "m_nTouchers": 2236
  },
  "CTriggerPush": {
    "m_angPushEntitySpace": 2216,
    "m_bTriggerOnStartTouch": 2240,
    "m_flAlternateTicksFix": 2244,
    "m_flPushSpeed": 2248,
    "m_vecPushDirEntitySpace": 2228
  },
  "CTriggerRemove": {
    "m_OnRemove": 2216
  },
  "CTriggerSave": {
    "m_bForceNewLevelUnit": 2216,
    "m_fDangerousTimer": 2220,
    "m_minHitPoints": 2224
  },
  "CTriggerSndSosOpvar": {
    "m_VecNormPos": 3068,
    "m_bVolIs2D": 2296,
    "m_flCenterSize": 2252,
    "m_flMaxVal": 2260,
    "m_flMinVal": 2256,
    "m_flNormCenterSize": 3080,
    "m_flPosition": 2240,
    "m_flWait": 2264,
    "m_hTouchingPlayers": 2216,
    "m_operatorName": 2288,
    "m_operatorNameChar": 2809,
    "m_opvarName": 2272,
    "m_opvarNameChar": 2297,
    "m_stackName": 2280,
    "m_stackNameChar": 2553
  },
  "CTriggerSoundscape": {
    "m_SoundscapeName": 2224,
    "m_hSoundscape": 2216,
    "m_spectators": 2232
  },
  "CTriggerTeleport": {
    "m_bMirrorPlayer": 2225,
    "m_bUseLandmarkAngles": 2224,
    "m_iLandmark": 2216
  },
  "CTriggerToggleSave": {
    "m_bDisabled": 2216
  },
  "CTriggerVolume": {
    "m_hFilter": 1800,
    "m_iFilterName": 1792
  },
  "CVoteController": {
    "m_VoteOptions": 1608,
    "m_acceptingVotesTimer": 1240,
    "m_bIsYesNoVote": 1232,
    "m_executeCommandTimer": 1264,
    "m_iActiveIssueIndex": 1200,
    "m_iOnlyTeamToVote": 1204,
    "m_nHighestCountIndex": 1576,
    "m_nPotentialVotes": 1228,
    "m_nVoteOptionCount": 1208,
    "m_nVotesCast": 1312,
    "m_playerHoldingVote": 1568,
    "m_playerOverrideForVote": 1572,
    "m_potentialIssues": 1584,
    "m_resetVoteTimer": 1288
  },
  "CWeaponBaseItem": {
    "m_SequenceCompleteTimer": 3616,
    "m_bRedraw": 3640
  },
  "CWeaponShield": {
    "m_flBulletDamageAbsorbed": 3648,
    "m_flDisplayHealth": 3656,
    "m_flLastBulletHitSoundTime": 3652
  },
  "CWeaponTaser": {
    "m_fFireTime": 3648
  },
  "CommandToolCommand_t": {
    "m_ClearDebugBits": 64,
    "m_Commands": 48,
    "m_EntitySpec": 40,
    "m_ExecMode": 16,
    "m_InternalId": 4,
    "m_PeriodicExecDelay": 32,
    "m_SetDebugBits": 56,
    "m_ShortName": 8,
    "m_SpawnGroup": 24,
    "m_SpecType": 36,
    "m_bEnabled": 0,
    "m_bOpened": 1
  },
  "ConceptHistory_t": {
    "m_response": 8,
    "timeSpoken": 0
  },
  "ConstraintSoundInfo": {
    "m_bPlayReversalSound": 129,
    "m_bPlayTravelSound": 128,
    "m_forwardAxis": 64,
    "m_iszReversalSounds": 104,
    "m_iszTravelSoundBack": 88,
    "m_iszTravelSoundFwd": 80,
    "m_soundProfile": 32,
    "m_vSampler": 8
  },
  "CountdownTimer": {
    "m_duration": 8,
    "m_nWorldGroupId": 20,
    "m_timescale": 16,
    "m_timestamp": 12
  },
  "EngineCountdownTimer": {
    "m_duration": 8,
    "m_timescale": 16,
    "m_timestamp": 12
  },
  "EntityRenderAttribute_t": {
    "m_ID": 48,
    "m_Values": 52
  },
  "EntitySpottedState_t": {
    "m_bSpotted": 8,
    "m_bSpottedByMask": 12
  },
  "Extent": {
    "hi": 12,
    "lo": 0
  },
  "FilterDamageType": {
    "m_iDamageType": 1288
  },
  "FilterHealth": {
    "m_bAdrenalineActive": 1288,
    "m_iHealthMax": 1296,
    "m_iHealthMin": 1292
  },
  "FilterTeam": {
    "m_iFilterTeam": 1288
  },
  "GameAmmoTypeInfo_t": {
    "m_nBuySize": 56,
    "m_nCost": 60
  },
  "GameTick_t": {
    "m_Value": 0
  },
  "GameTime_t": {
    "m_Value": 0
  },
  "HullFlags_t": {
    "m_bHull_Human": 0,
    "m_bHull_Large": 6,
    "m_bHull_LargeCentered": 7,
    "m_bHull_Medium": 4,
    "m_bHull_MediumTall": 8,
    "m_bHull_Small": 9,
    "m_bHull_SmallCentered": 1,
    "m_bHull_Tiny": 3,
    "m_bHull_TinyCentered": 5,
    "m_bHull_WideHuman": 2
  },
  "IntervalTimer": {
    "m_nWorldGroupId": 12,
    "m_timestamp": 8
  },
  "ModelConfigHandle_t": {
    "m_Value": 0
  },
  "ParticleIndex_t": {
    "m_Value": 0
  },
  "PhysicsRagdollPose_t": {
    "__m_pChainEntity": 8,
    "m_Transforms": 48,
    "m_hOwner": 72
  },
  "RagdollCreationParams_t": {
    "m_nForceBone": 12,
    "m_vForce": 0
  },
  "RelationshipOverride_t": {
    "classType": 12,
    "entity": 8
  },
  "Relationship_t": {
    "disposition": 0,
    "priority": 4
  },
  "ResponseContext_t": {
    "m_fExpirationTime": 16,
    "m_iszName": 0,
    "m_iszValue": 8
  },
  "ResponseFollowup": {
    "bFired": 48,
    "followup_concept": 0,
    "followup_contexts": 8,
    "followup_delay": 16,
    "followup_entityiodelay": 44,
    "followup_entityioinput": 36,
    "followup_entityiotarget": 28,
    "followup_target": 20
  },
  "ResponseParams": {
    "flags": 18,
    "m_pFollowup": 24,
    "odds": 16
  },
  "SellbackPurchaseEntry_t": {
    "m_bPrevHelmet": 60,
    "m_hItem": 64,
    "m_nCost": 52,
    "m_nPrevArmor": 56,
    "m_unDefIdx": 48
  },
  "ServerAuthoritativeWeaponSlot_t": {
    "unClass": 40,
    "unItemDefIdx": 44,
    "unSlot": 42
  },
  "SimpleConstraintSoundProfile": {
    "eKeypoints": 8,
    "m_keyPoints": 12,
    "m_reversalSoundThresholds": 20
  },
  "SpawnPoint": {
    "m_bEnabled": 1204,
    "m_iPriority": 1200,
    "m_nType": 1208
  },
  "SpawnPointCoopEnemy": {
    "m_bIsAgressive": 1244,
    "m_bStartAsleep": 1245,
    "m_flHideRadius": 1248,
    "m_nArmorToSpawnWith": 1232,
    "m_nBotDifficulty": 1240,
    "m_nDefaultBehavior": 1236,
    "m_szBehaviorTreeFile": 1264,
    "m_szPlayerModelToUse": 1224,
    "m_szWeaponsToGive": 1216
  },
  "SummaryTakeDamageInfo_t": {
    "hTarget": 168,
    "info": 8,
    "nSummarisedCount": 0,
    "result": 160
  },
  "VPhysicsCollisionAttribute_t": {
    "m_nCollisionFunctionMask": 43,
    "m_nCollisionGroup": 42,
    "m_nEntityId": 32,
    "m_nHierarchyId": 40,
    "m_nInteractsAs": 8,
    "m_nInteractsExclude": 24,
    "m_nInteractsWith": 16,
    "m_nOwnerId": 36
  },
  "VelocitySampler": {
    "m_fIdealSampleRate": 16,
    "m_fPrevSampleTime": 12,
    "m_prevSample": 0
  },
  "ViewAngleServerChange_t": {
    "nIndex": 64,
    "nType": 48,
    "qAngle": 52
  },
  "WeaponPurchaseCount_t": {
    "m_nCount": 50,
    "m_nItemDefIndex": 48
  },
  "WeaponPurchaseTracker_t": {
    "m_weaponPurchases": 8
  },
  "audioparams_t": {
    "localBits": 108,
    "localSound": 8,
    "soundEventHash": 116,
    "soundscapeEntityListIndex": 112,
    "soundscapeIndex": 104
  },
  "dynpitchvol_base_t": {
    "cspincount": 56,
    "cspinup": 52,
    "fadein": 28,
    "fadeinsav": 80,
    "fadeout": 32,
    "fadeoutsav": 84,
    "lfofrac": 92,
    "lfomodpitch": 44,
    "lfomodvol": 48,
    "lfomult": 96,
    "lforate": 40,
    "lfotype": 36,
    "pitch": 60,
    "pitchfrac": 72,
    "pitchrun": 4,
    "pitchstart": 8,
    "preset": 0,
    "spindown": 16,
    "spindownsav": 68,
    "spinup": 12,
    "spinupsav": 64,
    "vol": 76,
    "volfrac": 88,
    "volrun": 20,
    "volstart": 24
  },
  "fogparams_t": {
    "HDRColorScale": 56,
    "blend": 101,
    "blendtobackground": 88,
    "colorPrimary": 20,
    "colorPrimaryLerpTo": 28,
    "colorSecondary": 24,
    "colorSecondaryLerpTo": 32,
    "dirPrimary": 8,
    "duration": 84,
    "enable": 100,
    "end": 40,
    "endLerpTo": 72,
    "exponent": 52,
    "farz": 44,
    "lerptime": 80,
    "locallightscale": 96,
    "m_bNoReflectionFog": 102,
    "m_bPadding": 103,
    "maxdensity": 48,
    "maxdensityLerpTo": 76,
    "scattering": 92,
    "skyboxFogFactor": 60,
    "skyboxFogFactorLerpTo": 64,
    "start": 36,
    "startLerpTo": 68
  },
  "fogplayerparams_t": {
    "m_NewColor": 40,
    "m_OldColor": 16,
    "m_flNewEnd": 48,
    "m_flNewFarZ": 60,
    "m_flNewHDRColorScale": 56,
    "m_flNewMaxDensity": 52,
    "m_flNewStart": 44,
    "m_flOldEnd": 24,
    "m_flOldFarZ": 36,
    "m_flOldHDRColorScale": 32,
    "m_flOldMaxDensity": 28,
    "m_flOldStart": 20,
    "m_flTransitionTime": 12,
    "m_hCtrl": 8
  },
  "hudtextparms_t": {
    "channel": 9,
    "color1": 0,
    "color2": 4,
    "effect": 8,
    "x": 12,
    "y": 16
  },
  "lerpdata_t": {
    "m_MoveType": 4,
    "m_flStartTime": 8,
    "m_hEnt": 0,
    "m_nFXIndex": 48,
    "m_qStartRot": 32,
    "m_vecStartOrigin": 12
  },
  "locksound_t": {
    "flwaitSound": 24,
    "sLockedSound": 8,
    "sUnlockedSound": 16
  },
  "magnetted_objects_t": {
    "hEntity": 8
  },
  "ragdoll_t": {
    "allowStretch": 48,
    "boneIndex": 24,
    "list": 0,
    "unused": 49
  },
  "ragdollelement_t": {
    "m_flRadius": 36,
    "originParentSpace": 0,
    "parentIndex": 32
  },
  "shard_model_desc_t": {
    "m_ShatterPanelMode": 25,
    "m_SurfacePropStringToken": 88,
    "m_bHasParent": 84,
    "m_bParentFrozen": 85,
    "m_flGlassHalfThickness": 80,
    "m_hMaterial": 16,
    "m_nModelID": 8,
    "m_solid": 24,
    "m_vecPanelSize": 28,
    "m_vecPanelVertices": 56,
    "m_vecStressPositionA": 36,
    "m_vecStressPositionB": 44
  },
  "sky3dparams_t": {
    "bClip3DSkyBoxNearToWorldFar": 24,
    "flClip3DSkyBoxNearToWorldFarOffset": 28,
    "fog": 32,
    "m_nWorldGroupID": 136,
    "origin": 12,
    "scale": 8
  },
  "thinkfunc_t": {
    "m_hFn": 8,
    "m_nContext": 16,
    "m_nLastThinkTick": 24,
    "m_nNextThinkTick": 20
  }
}
```

`SDK/server.dll.py`:

```py
'''
https://github.com/a2x/cs2-dumper
2023-11-23 10:28:26.579080 UTC
'''

class ActiveModelConfig_t:
    m_Handle = 0x28 # ModelConfigHandle_t
    m_Name = 0x30 # CUtlSymbolLarge
    m_AssociatedEntities = 0x38 # CNetworkUtlVectorBase<CHandle<CBaseModelEntity>>
    m_AssociatedEntityNames = 0x50 # CNetworkUtlVectorBase<CUtlSymbolLarge>

class AmmoIndex_t:
    m_Value = 0x0 # int8_t

class AmmoTypeInfo_t:
    m_nMaxCarry = 0x10 # int32_t
    m_nSplashSize = 0x1C # CRangeInt
    m_nFlags = 0x24 # AmmoFlags_t
    m_flMass = 0x28 # float
    m_flSpeed = 0x2C # CRangeFloat

class AnimationUpdateListHandle_t:
    m_Value = 0x0 # uint32_t

class CAISound:
    m_iSoundType = 0x4B0 # int32_t
    m_iSoundContext = 0x4B4 # int32_t
    m_iVolume = 0x4B8 # int32_t
    m_iSoundIndex = 0x4BC # int32_t
    m_flDuration = 0x4C0 # float
    m_iszProxyEntityName = 0x4C8 # CUtlSymbolLarge

class CAI_ChangeHintGroup:
    m_iSearchType = 0x4B0 # int32_t
    m_strSearchName = 0x4B8 # CUtlSymbolLarge
    m_strNewHintGroup = 0x4C0 # CUtlSymbolLarge
    m_flRadius = 0x4C8 # float

class CAI_ChangeTarget:
    m_iszNewTarget = 0x4B0 # CUtlSymbolLarge

class CAI_Expresser:
    m_flStopTalkTime = 0x38 # GameTime_t
    m_flStopTalkTimeWithoutDelay = 0x3C # GameTime_t
    m_flBlockedTalkTime = 0x40 # GameTime_t
    m_voicePitch = 0x44 # int32_t
    m_flLastTimeAcceptedSpeak = 0x48 # GameTime_t
    m_bAllowSpeakingInterrupts = 0x4C # bool
    m_bConsiderSceneInvolvementAsSpeech = 0x4D # bool
    m_nLastSpokenPriority = 0x50 # int32_t
    m_pOuter = 0x58 # CBaseFlex*

class CAI_ExpresserWithFollowup:
    m_pPostponedFollowup = 0x60 # ResponseFollowup*

class CAmbientGeneric:
    m_radius = 0x4B0 # float
    m_flMaxRadius = 0x4B4 # float
    m_iSoundLevel = 0x4B8 # soundlevel_t
    m_dpv = 0x4BC # dynpitchvol_t
    m_fActive = 0x520 # bool
    m_fLooping = 0x521 # bool
    m_iszSound = 0x528 # CUtlSymbolLarge
    m_sSourceEntName = 0x530 # CUtlSymbolLarge
    m_hSoundSource = 0x538 # CHandle<CBaseEntity>
    m_nSoundSourceEntIndex = 0x53C # CEntityIndex

class CAnimGraphNetworkedVariables:
    m_PredNetBoolVariables = 0x8 # CNetworkUtlVectorBase<uint32_t>
    m_PredNetByteVariables = 0x20 # CNetworkUtlVectorBase<uint8_t>
    m_PredNetUInt16Variables = 0x38 # CNetworkUtlVectorBase<uint16_t>
    m_PredNetIntVariables = 0x50 # CNetworkUtlVectorBase<int32_t>
    m_PredNetUInt32Variables = 0x68 # CNetworkUtlVectorBase<uint32_t>
    m_PredNetUInt64Variables = 0x80 # CNetworkUtlVectorBase<uint64_t>
    m_PredNetFloatVariables = 0x98 # CNetworkUtlVectorBase<float>
    m_PredNetVectorVariables = 0xB0 # CNetworkUtlVectorBase<Vector>
    m_PredNetQuaternionVariables = 0xC8 # CNetworkUtlVectorBase<Quaternion>
    m_OwnerOnlyPredNetBoolVariables = 0xE0 # CNetworkUtlVectorBase<uint32_t>
    m_OwnerOnlyPredNetByteVariables = 0xF8 # CNetworkUtlVectorBase<uint8_t>
    m_OwnerOnlyPredNetUInt16Variables = 0x110 # CNetworkUtlVectorBase<uint16_t>
    m_OwnerOnlyPredNetIntVariables = 0x128 # CNetworkUtlVectorBase<int32_t>
    m_OwnerOnlyPredNetUInt32Variables = 0x140 # CNetworkUtlVectorBase<uint32_t>
    m_OwnerOnlyPredNetUInt64Variables = 0x158 # CNetworkUtlVectorBase<uint64_t>
    m_OwnerOnlyPredNetFloatVariables = 0x170 # CNetworkUtlVectorBase<float>
    m_OwnerOnlyPredNetVectorVariables = 0x188 # CNetworkUtlVectorBase<Vector>
    m_OwnerOnlyPredNetQuaternionVariables = 0x1A0 # CNetworkUtlVectorBase<Quaternion>
    m_nBoolVariablesCount = 0x1B8 # int32_t
    m_nOwnerOnlyBoolVariablesCount = 0x1BC # int32_t
    m_nRandomSeedOffset = 0x1C0 # int32_t
    m_flLastTeleportTime = 0x1C4 # float

class CAnimGraphTagRef:
    m_nTagIndex = 0x0 # int32_t
    m_tagName = 0x10 # CGlobalSymbol

class CAttributeContainer:
    m_Item = 0x50 # CEconItemView

class CAttributeList:
    m_Attributes = 0x8 # CUtlVectorEmbeddedNetworkVar<CEconItemAttribute>
    m_pManager = 0x58 # CAttributeManager*

class CAttributeManager:
    m_Providers = 0x8 # CUtlVector<CHandle<CBaseEntity>>
    m_iReapplyProvisionParity = 0x20 # int32_t
    m_hOuter = 0x24 # CHandle<CBaseEntity>
    m_bPreventLoopback = 0x28 # bool
    m_ProviderType = 0x2C # attributeprovidertypes_t
    m_CachedResults = 0x30 # CUtlVector<CAttributeManager::cached_attribute_float_t>

class CAttributeManager_cached_attribute_float_t:
    flIn = 0x0 # float
    iAttribHook = 0x8 # CUtlSymbolLarge
    flOut = 0x10 # float

class CBarnLight:
    m_bEnabled = 0x700 # bool
    m_nColorMode = 0x704 # int32_t
    m_Color = 0x708 # Color
    m_flColorTemperature = 0x70C # float
    m_flBrightness = 0x710 # float
    m_flBrightnessScale = 0x714 # float
    m_nDirectLight = 0x718 # int32_t
    m_nBakedShadowIndex = 0x71C # int32_t
    m_nLuminaireShape = 0x720 # int32_t
    m_flLuminaireSize = 0x724 # float
    m_flLuminaireAnisotropy = 0x728 # float
    m_LightStyleString = 0x730 # CUtlString
    m_flLightStyleStartTime = 0x738 # GameTime_t
    m_QueuedLightStyleStrings = 0x740 # CNetworkUtlVectorBase<CUtlString>
    m_LightStyleEvents = 0x758 # CNetworkUtlVectorBase<CUtlString>
    m_LightStyleTargets = 0x770 # CNetworkUtlVectorBase<CHandle<CBaseModelEntity>>
    m_StyleEvent = 0x788 # CEntityIOOutput[4]
    m_hLightCookie = 0x848 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_flShape = 0x850 # float
    m_flSoftX = 0x854 # float
    m_flSoftY = 0x858 # float
    m_flSkirt = 0x85C # float
    m_flSkirtNear = 0x860 # float
    m_vSizeParams = 0x864 # Vector
    m_flRange = 0x870 # float
    m_vShear = 0x874 # Vector
    m_nBakeSpecularToCubemaps = 0x880 # int32_t
    m_vBakeSpecularToCubemapsSize = 0x884 # Vector
    m_nCastShadows = 0x890 # int32_t
    m_nShadowMapSize = 0x894 # int32_t
    m_nShadowPriority = 0x898 # int32_t
    m_bContactShadow = 0x89C # bool
    m_nBounceLight = 0x8A0 # int32_t
    m_flBounceScale = 0x8A4 # float
    m_flMinRoughness = 0x8A8 # float
    m_vAlternateColor = 0x8AC # Vector
    m_fAlternateColorBrightness = 0x8B8 # float
    m_nFog = 0x8BC # int32_t
    m_flFogStrength = 0x8C0 # float
    m_nFogShadows = 0x8C4 # int32_t
    m_flFogScale = 0x8C8 # float
    m_flFadeSizeStart = 0x8CC # float
    m_flFadeSizeEnd = 0x8D0 # float
    m_flShadowFadeSizeStart = 0x8D4 # float
    m_flShadowFadeSizeEnd = 0x8D8 # float
    m_bPrecomputedFieldsValid = 0x8DC # bool
    m_vPrecomputedBoundsMins = 0x8E0 # Vector
    m_vPrecomputedBoundsMaxs = 0x8EC # Vector
    m_vPrecomputedOBBOrigin = 0x8F8 # Vector
    m_vPrecomputedOBBAngles = 0x904 # QAngle
    m_vPrecomputedOBBExtent = 0x910 # Vector
    m_bPvsModifyEntity = 0x91C # bool

class CBaseAnimGraph:
    m_bInitiallyPopulateInterpHistory = 0x700 # bool
    m_bShouldAnimateDuringGameplayPause = 0x701 # bool
    m_pChoreoServices = 0x708 # IChoreoServices*
    m_bAnimGraphUpdateEnabled = 0x710 # bool
    m_flMaxSlopeDistance = 0x714 # float
    m_vLastSlopeCheckPos = 0x718 # Vector
    m_bAnimGraphDirty = 0x724 # bool
    m_vecForce = 0x728 # Vector
    m_nForceBone = 0x734 # int32_t
    m_pRagdollPose = 0x748 # PhysicsRagdollPose_t*
    m_bClientRagdoll = 0x750 # bool

class CBaseAnimGraphController:
    m_baseLayer = 0x18 # CNetworkedSequenceOperation
    m_animGraphNetworkedVars = 0x40 # CAnimGraphNetworkedVariables
    m_bSequenceFinished = 0x218 # bool
    m_flLastEventCycle = 0x21C # float
    m_flLastEventAnimTime = 0x220 # float
    m_flPlaybackRate = 0x224 # CNetworkedQuantizedFloat
    m_flPrevAnimTime = 0x22C # float
    m_bClientSideAnimation = 0x230 # bool
    m_bNetworkedAnimationInputsChanged = 0x231 # bool
    m_nNewSequenceParity = 0x234 # int32_t
    m_nResetEventsParity = 0x238 # int32_t
    m_nAnimLoopMode = 0x23C # AnimLoopMode_t
    m_hAnimationUpdate = 0x2DC # AnimationUpdateListHandle_t

class CBaseButton:
    m_angMoveEntitySpace = 0x780 # QAngle
    m_fStayPushed = 0x78C # bool
    m_fRotating = 0x78D # bool
    m_ls = 0x790 # locksound_t
    m_sUseSound = 0x7B0 # CUtlSymbolLarge
    m_sLockedSound = 0x7B8 # CUtlSymbolLarge
    m_sUnlockedSound = 0x7C0 # CUtlSymbolLarge
    m_bLocked = 0x7C8 # bool
    m_bDisabled = 0x7C9 # bool
    m_flUseLockedTime = 0x7CC # GameTime_t
    m_bSolidBsp = 0x7D0 # bool
    m_OnDamaged = 0x7D8 # CEntityIOOutput
    m_OnPressed = 0x800 # CEntityIOOutput
    m_OnUseLocked = 0x828 # CEntityIOOutput
    m_OnIn = 0x850 # CEntityIOOutput
    m_OnOut = 0x878 # CEntityIOOutput
    m_nState = 0x8A0 # int32_t
    m_hConstraint = 0x8A4 # CEntityHandle
    m_hConstraintParent = 0x8A8 # CEntityHandle
    m_bForceNpcExclude = 0x8AC # bool
    m_sGlowEntity = 0x8B0 # CUtlSymbolLarge
    m_glowEntity = 0x8B8 # CHandle<CBaseModelEntity>
    m_usable = 0x8BC # bool
    m_szDisplayText = 0x8C0 # CUtlSymbolLarge

class CBaseCSGrenade:
    m_bRedraw = 0xE20 # bool
    m_bIsHeldByPlayer = 0xE21 # bool
    m_bPinPulled = 0xE22 # bool
    m_bJumpThrow = 0xE23 # bool
    m_eThrowStatus = 0xE24 # EGrenadeThrowState
    m_fThrowTime = 0xE28 # GameTime_t
    m_flThrowStrength = 0xE2C # float
    m_flThrowStrengthApproach = 0xE30 # float
    m_fDropTime = 0xE34 # GameTime_t

class CBaseCSGrenadeProjectile:
    m_vInitialPosition = 0x9C8 # Vector
    m_vInitialVelocity = 0x9D4 # Vector
    m_nBounces = 0x9E0 # int32_t
    m_nExplodeEffectIndex = 0x9E8 # CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    m_nExplodeEffectTickBegin = 0x9F0 # int32_t
    m_vecExplodeEffectOrigin = 0x9F4 # Vector
    m_flSpawnTime = 0xA00 # GameTime_t
    m_unOGSExtraFlags = 0xA04 # uint8_t
    m_bDetonationRecorded = 0xA05 # bool
    m_flDetonateTime = 0xA08 # GameTime_t
    m_nItemIndex = 0xA0C # uint16_t
    m_vecOriginalSpawnLocation = 0xA10 # Vector
    m_flLastBounceSoundTime = 0xA1C # GameTime_t
    m_vecGrenadeSpin = 0xA20 # RotationVector
    m_vecLastHitSurfaceNormal = 0xA2C # Vector
    m_nTicksAtZeroVelocity = 0xA38 # int32_t
    m_bHasEverHitPlayer = 0xA3C # bool
    m_bClearFromPlayers = 0xA3D # bool

class CBaseClientUIEntity:
    m_bEnabled = 0x700 # bool
    m_DialogXMLName = 0x708 # CUtlSymbolLarge
    m_PanelClassName = 0x710 # CUtlSymbolLarge
    m_PanelID = 0x718 # CUtlSymbolLarge
    m_CustomOutput0 = 0x720 # CEntityIOOutput
    m_CustomOutput1 = 0x748 # CEntityIOOutput
    m_CustomOutput2 = 0x770 # CEntityIOOutput
    m_CustomOutput3 = 0x798 # CEntityIOOutput
    m_CustomOutput4 = 0x7C0 # CEntityIOOutput
    m_CustomOutput5 = 0x7E8 # CEntityIOOutput
    m_CustomOutput6 = 0x810 # CEntityIOOutput
    m_CustomOutput7 = 0x838 # CEntityIOOutput
    m_CustomOutput8 = 0x860 # CEntityIOOutput
    m_CustomOutput9 = 0x888 # CEntityIOOutput

class CBaseCombatCharacter:
    m_bForceServerRagdoll = 0x920 # bool
    m_hMyWearables = 0x928 # CNetworkUtlVectorBase<CHandle<CEconWearable>>
    m_flFieldOfView = 0x940 # float
    m_impactEnergyScale = 0x944 # float
    m_LastHitGroup = 0x948 # HitGroup_t
    m_bApplyStressDamage = 0x94C # bool
    m_bloodColor = 0x950 # int32_t
    m_navMeshID = 0x9B0 # int32_t
    m_iDamageCount = 0x9B4 # int32_t
    m_pVecRelationships = 0x9B8 # CUtlVector<RelationshipOverride_t>*
    m_strRelationships = 0x9C0 # CUtlSymbolLarge
    m_eHull = 0x9C8 # Hull_t
    m_nNavHullIdx = 0x9CC # uint32_t

class CBaseDMStart:
    m_Master = 0x4B0 # CUtlSymbolLarge

class CBaseDoor:
    m_angMoveEntitySpace = 0x790 # QAngle
    m_vecMoveDirParentSpace = 0x79C # Vector
    m_ls = 0x7A8 # locksound_t
    m_bForceClosed = 0x7C8 # bool
    m_bDoorGroup = 0x7C9 # bool
    m_bLocked = 0x7CA # bool
    m_bIgnoreDebris = 0x7CB # bool
    m_eSpawnPosition = 0x7CC # FuncDoorSpawnPos_t
    m_flBlockDamage = 0x7D0 # float
    m_NoiseMoving = 0x7D8 # CUtlSymbolLarge
    m_NoiseArrived = 0x7E0 # CUtlSymbolLarge
    m_NoiseMovingClosed = 0x7E8 # CUtlSymbolLarge
    m_NoiseArrivedClosed = 0x7F0 # CUtlSymbolLarge
    m_ChainTarget = 0x7F8 # CUtlSymbolLarge
    m_OnBlockedClosing = 0x800 # CEntityIOOutput
    m_OnBlockedOpening = 0x828 # CEntityIOOutput
    m_OnUnblockedClosing = 0x850 # CEntityIOOutput
    m_OnUnblockedOpening = 0x878 # CEntityIOOutput
    m_OnFullyClosed = 0x8A0 # CEntityIOOutput
    m_OnFullyOpen = 0x8C8 # CEntityIOOutput
    m_OnClose = 0x8F0 # CEntityIOOutput
    m_OnOpen = 0x918 # CEntityIOOutput
    m_OnLockedUse = 0x940 # CEntityIOOutput
    m_bLoopMoveSound = 0x968 # bool
    m_bCreateNavObstacle = 0x980 # bool
    m_isChaining = 0x981 # bool
    m_bIsUsable = 0x982 # bool

class CBaseEntity:
    m_CBodyComponent = 0x30 # CBodyComponent*
    m_NetworkTransmitComponent = 0x38 # CNetworkTransmitComponent
    m_aThinkFunctions = 0x228 # CUtlVector<thinkfunc_t>
    m_iCurrentThinkContext = 0x240 # int32_t
    m_nLastThinkTick = 0x244 # GameTick_t
    m_isSteadyState = 0x250 # CBitVec<64>
    m_lastNetworkChange = 0x258 # float
    m_ResponseContexts = 0x268 # CUtlVector<ResponseContext_t>
    m_iszResponseContext = 0x280 # CUtlSymbolLarge
    m_iHealth = 0x2A8 # int32_t
    m_iMaxHealth = 0x2AC # int32_t
    m_lifeState = 0x2B0 # uint8_t
    m_flDamageAccumulator = 0x2B4 # float
    m_bTakesDamage = 0x2B8 # bool
    m_nTakeDamageFlags = 0x2BC # TakeDamageFlags_t
    m_MoveCollide = 0x2C1 # MoveCollide_t
    m_MoveType = 0x2C2 # MoveType_t
    m_nWaterTouch = 0x2C3 # uint8_t
    m_nSlimeTouch = 0x2C4 # uint8_t
    m_bRestoreInHierarchy = 0x2C5 # bool
    m_target = 0x2C8 # CUtlSymbolLarge
    m_flMoveDoneTime = 0x2D0 # float
    m_hDamageFilter = 0x2D4 # CHandle<CBaseFilter>
    m_iszDamageFilterName = 0x2D8 # CUtlSymbolLarge
    m_nSubclassID = 0x2E0 # CUtlStringToken
    m_flAnimTime = 0x2F0 # float
    m_flSimulationTime = 0x2F4 # float
    m_flCreateTime = 0x2F8 # GameTime_t
    m_bClientSideRagdoll = 0x2FC # bool
    m_ubInterpolationFrame = 0x2FD # uint8_t
    m_vPrevVPhysicsUpdatePos = 0x300 # Vector
    m_iTeamNum = 0x30C # uint8_t
    m_iGlobalname = 0x310 # CUtlSymbolLarge
    m_iSentToClients = 0x318 # int32_t
    m_flSpeed = 0x31C # float
    m_sUniqueHammerID = 0x320 # CUtlString
    m_spawnflags = 0x328 # uint32_t
    m_nNextThinkTick = 0x32C # GameTick_t
    m_nSimulationTick = 0x330 # int32_t
    m_OnKilled = 0x338 # CEntityIOOutput
    m_fFlags = 0x360 # uint32_t
    m_vecAbsVelocity = 0x364 # Vector
    m_vecVelocity = 0x370 # CNetworkVelocityVector
    m_vecBaseVelocity = 0x3A0 # Vector
    m_nPushEnumCount = 0x3AC # int32_t
    m_pCollision = 0x3B0 # CCollisionProperty*
    m_hEffectEntity = 0x3B8 # CHandle<CBaseEntity>
    m_hOwnerEntity = 0x3BC # CHandle<CBaseEntity>
    m_fEffects = 0x3C0 # uint32_t
    m_hGroundEntity = 0x3C4 # CHandle<CBaseEntity>
    m_flFriction = 0x3C8 # float
    m_flElasticity = 0x3CC # float
    m_flGravityScale = 0x3D0 # float
    m_flTimeScale = 0x3D4 # float
    m_flWaterLevel = 0x3D8 # float
    m_bSimulatedEveryTick = 0x3DC # bool
    m_bAnimatedEveryTick = 0x3DD # bool
    m_bDisableLowViolence = 0x3DE # bool
    m_nWaterType = 0x3DF # uint8_t
    m_iEFlags = 0x3E0 # int32_t
    m_OnUser1 = 0x3E8 # CEntityIOOutput
    m_OnUser2 = 0x410 # CEntityIOOutput
    m_OnUser3 = 0x438 # CEntityIOOutput
    m_OnUser4 = 0x460 # CEntityIOOutput
    m_iInitialTeamNum = 0x488 # int32_t
    m_flNavIgnoreUntilTime = 0x48C # GameTime_t
    m_vecAngVelocity = 0x490 # QAngle
    m_bNetworkQuantizeOriginAndAngles = 0x49C # bool
    m_bLagCompensate = 0x49D # bool
    m_flOverriddenFriction = 0x4A0 # float
    m_pBlocker = 0x4A4 # CHandle<CBaseEntity>
    m_flLocalTime = 0x4A8 # float
    m_flVPhysicsUpdateLocalTime = 0x4AC # float

class CBaseFilter:
    m_bNegated = 0x4B0 # bool
    m_OnPass = 0x4B8 # CEntityIOOutput
    m_OnFail = 0x4E0 # CEntityIOOutput

class CBaseFire:
    m_flScale = 0x4B0 # float
    m_flStartScale = 0x4B4 # float
    m_flScaleTime = 0x4B8 # float
    m_nFlags = 0x4BC # uint32_t

class CBaseFlex:
    m_flexWeight = 0x890 # CNetworkUtlVectorBase<float>
    m_vLookTargetPosition = 0x8A8 # Vector
    m_blinktoggle = 0x8B4 # bool
    m_flAllowResponsesEndTime = 0x908 # GameTime_t
    m_flLastFlexAnimationTime = 0x90C # GameTime_t
    m_nNextSceneEventId = 0x910 # uint32_t
    m_bUpdateLayerPriorities = 0x914 # bool

class CBaseGrenade:
    m_OnPlayerPickup = 0x928 # CEntityIOOutput
    m_OnExplode = 0x950 # CEntityIOOutput
    m_bHasWarnedAI = 0x978 # bool
    m_bIsSmokeGrenade = 0x979 # bool
    m_bIsLive = 0x97A # bool
    m_DmgRadius = 0x97C # float
    m_flDetonateTime = 0x980 # GameTime_t
    m_flWarnAITime = 0x984 # float
    m_flDamage = 0x988 # float
    m_iszBounceSound = 0x990 # CUtlSymbolLarge
    m_ExplosionSound = 0x998 # CUtlString
    m_hThrower = 0x9A4 # CHandle<CCSPlayerPawn>
    m_flNextAttack = 0x9BC # GameTime_t
    m_hOriginalThrower = 0x9C0 # CHandle<CCSPlayerPawn>

class CBaseIssue:
    m_szTypeString = 0x20 # char[64]
    m_szDetailsString = 0x60 # char[260]
    m_iNumYesVotes = 0x164 # int32_t
    m_iNumNoVotes = 0x168 # int32_t
    m_iNumPotentialVotes = 0x16C # int32_t
    m_pVoteController = 0x170 # CVoteController*

class CBaseModelEntity:
    m_CRenderComponent = 0x4B0 # CRenderComponent*
    m_CHitboxComponent = 0x4B8 # CHitboxComponent
    m_flDissolveStartTime = 0x4E0 # GameTime_t
    m_OnIgnite = 0x4E8 # CEntityIOOutput
    m_nRenderMode = 0x510 # RenderMode_t
    m_nRenderFX = 0x511 # RenderFx_t
    m_bAllowFadeInView = 0x512 # bool
    m_clrRender = 0x513 # Color
    m_vecRenderAttributes = 0x518 # CUtlVectorEmbeddedNetworkVar<EntityRenderAttribute_t>
    m_bRenderToCubemaps = 0x568 # bool
    m_Collision = 0x570 # CCollisionProperty
    m_Glow = 0x620 # CGlowProperty
    m_flGlowBackfaceMult = 0x678 # float
    m_fadeMinDist = 0x67C # float
    m_fadeMaxDist = 0x680 # float
    m_flFadeScale = 0x684 # float
    m_flShadowStrength = 0x688 # float
    m_nObjectCulling = 0x68C # uint8_t
    m_nAddDecal = 0x690 # int32_t
    m_vDecalPosition = 0x694 # Vector
    m_vDecalForwardAxis = 0x6A0 # Vector
    m_flDecalHealBloodRate = 0x6AC # float
    m_flDecalHealHeightRate = 0x6B0 # float
    m_ConfigEntitiesToPropagateMaterialDecalsTo = 0x6B8 # CNetworkUtlVectorBase<CHandle<CBaseModelEntity>>
    m_vecViewOffset = 0x6D0 # CNetworkViewOffsetVector

class CBaseMoveBehavior:
    m_iPositionInterpolator = 0x510 # int32_t
    m_iRotationInterpolator = 0x514 # int32_t
    m_flAnimStartTime = 0x518 # float
    m_flAnimEndTime = 0x51C # float
    m_flAverageSpeedAcrossFrame = 0x520 # float
    m_pCurrentKeyFrame = 0x528 # CPathKeyFrame*
    m_pTargetKeyFrame = 0x530 # CPathKeyFrame*
    m_pPreKeyFrame = 0x538 # CPathKeyFrame*
    m_pPostKeyFrame = 0x540 # CPathKeyFrame*
    m_flTimeIntoFrame = 0x548 # float
    m_iDirection = 0x54C # int32_t

class CBasePlatTrain:
    m_NoiseMoving = 0x780 # CUtlSymbolLarge
    m_NoiseArrived = 0x788 # CUtlSymbolLarge
    m_volume = 0x798 # float
    m_flTWidth = 0x79C # float
    m_flTLength = 0x7A0 # float

class CBasePlayerController:
    m_nInButtonsWhichAreToggles = 0x4B8 # uint64_t
    m_nTickBase = 0x4C0 # uint32_t
    m_hPawn = 0x4F0 # CHandle<CBasePlayerPawn>
    m_nSplitScreenSlot = 0x4F4 # CSplitScreenSlot
    m_hSplitOwner = 0x4F8 # CHandle<CBasePlayerController>
    m_hSplitScreenPlayers = 0x500 # CUtlVector<CHandle<CBasePlayerController>>
    m_bIsHLTV = 0x518 # bool
    m_iConnected = 0x51C # PlayerConnectedState
    m_iszPlayerName = 0x520 # char[128]
    m_szNetworkIDString = 0x5A0 # CUtlString
    m_fLerpTime = 0x5A8 # float
    m_bLagCompensation = 0x5AC # bool
    m_bPredict = 0x5AD # bool
    m_bAutoKickDisabled = 0x5AE # bool
    m_bIsLowViolence = 0x5AF # bool
    m_bGamePaused = 0x5B0 # bool
    m_nUsecTimestampLastUserCmdReceived = 0x648 # int64_t
    m_iIgnoreGlobalChat = 0x660 # ChatIgnoreType_t
    m_flLastPlayerTalkTime = 0x664 # float
    m_flLastEntitySteadyState = 0x668 # float
    m_nAvailableEntitySteadyState = 0x66C # int32_t
    m_bHasAnySteadyStateEnts = 0x670 # bool
    m_steamID = 0x680 # uint64_t
    m_iDesiredFOV = 0x688 # uint32_t

class CBasePlayerPawn:
    m_pWeaponServices = 0x9D0 # CPlayer_WeaponServices*
    m_pItemServices = 0x9D8 # CPlayer_ItemServices*
    m_pAutoaimServices = 0x9E0 # CPlayer_AutoaimServices*
    m_pObserverServices = 0x9E8 # CPlayer_ObserverServices*
    m_pWaterServices = 0x9F0 # CPlayer_WaterServices*
    m_pUseServices = 0x9F8 # CPlayer_UseServices*
    m_pFlashlightServices = 0xA00 # CPlayer_FlashlightServices*
    m_pCameraServices = 0xA08 # CPlayer_CameraServices*
    m_pMovementServices = 0xA10 # CPlayer_MovementServices*
    m_ServerViewAngleChanges = 0xA20 # CUtlVectorEmbeddedNetworkVar<ViewAngleServerChange_t>
    m_nHighestGeneratedServerViewAngleChangeIndex = 0xA70 # uint32_t
    v_angle = 0xA74 # QAngle
    v_anglePrevious = 0xA80 # QAngle
    m_iHideHUD = 0xA8C # uint32_t
    m_skybox3d = 0xA90 # sky3dparams_t
    m_fTimeLastHurt = 0xB20 # GameTime_t
    m_flDeathTime = 0xB24 # GameTime_t
    m_fNextSuicideTime = 0xB28 # GameTime_t
    m_fInitHUD = 0xB2C # bool
    m_pExpresser = 0xB30 # CAI_Expresser*
    m_hController = 0xB38 # CHandle<CBasePlayerController>
    m_fHltvReplayDelay = 0xB40 # float
    m_fHltvReplayEnd = 0xB44 # float
    m_iHltvReplayEntity = 0xB48 # CEntityIndex

class CBasePlayerVData:
    m_sModelName = 0x28 # CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    m_flHeadDamageMultiplier = 0x108 # CSkillFloat
    m_flChestDamageMultiplier = 0x118 # CSkillFloat
    m_flStomachDamageMultiplier = 0x128 # CSkillFloat
    m_flArmDamageMultiplier = 0x138 # CSkillFloat
    m_flLegDamageMultiplier = 0x148 # CSkillFloat
    m_flHoldBreathTime = 0x158 # float
    m_flDrowningDamageInterval = 0x15C # float
    m_nDrowningDamageInitial = 0x160 # int32_t
    m_nDrowningDamageMax = 0x164 # int32_t
    m_nWaterSpeed = 0x168 # int32_t
    m_flUseRange = 0x16C # float
    m_flUseAngleTolerance = 0x170 # float
    m_flCrouchTime = 0x174 # float

class CBasePlayerWeapon:
    m_nNextPrimaryAttackTick = 0xC18 # GameTick_t
    m_flNextPrimaryAttackTickRatio = 0xC1C # float
    m_nNextSecondaryAttackTick = 0xC20 # GameTick_t
    m_flNextSecondaryAttackTickRatio = 0xC24 # float
    m_iClip1 = 0xC28 # int32_t
    m_iClip2 = 0xC2C # int32_t
    m_pReserveAmmo = 0xC30 # int32_t[2]
    m_OnPlayerUse = 0xC38 # CEntityIOOutput

class CBasePlayerWeaponVData:
    m_szWorldModel = 0x28 # CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    m_bBuiltRightHanded = 0x108 # bool
    m_bAllowFlipping = 0x109 # bool
    m_bIsFullAuto = 0x10A # bool
    m_nNumBullets = 0x10C # int32_t
    m_sMuzzleAttachment = 0x110 # CUtlString
    m_szMuzzleFlashParticle = 0x118 # CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    m_iFlags = 0x1F8 # ItemFlagTypes_t
    m_nPrimaryAmmoType = 0x1F9 # AmmoIndex_t
    m_nSecondaryAmmoType = 0x1FA # AmmoIndex_t
    m_iMaxClip1 = 0x1FC # int32_t
    m_iMaxClip2 = 0x200 # int32_t
    m_iDefaultClip1 = 0x204 # int32_t
    m_iDefaultClip2 = 0x208 # int32_t
    m_iWeight = 0x20C # int32_t
    m_bAutoSwitchTo = 0x210 # bool
    m_bAutoSwitchFrom = 0x211 # bool
    m_iRumbleEffect = 0x214 # RumbleEffect_t
    m_aShootSounds = 0x218 # CUtlMap<WeaponSound_t,CSoundEventName>
    m_iSlot = 0x238 # int32_t
    m_iPosition = 0x23C # int32_t

class CBaseProp:
    m_bModelOverrodeBlockLOS = 0x890 # bool
    m_iShapeType = 0x894 # int32_t
    m_bConformToCollisionBounds = 0x898 # bool
    m_mPreferredCatchTransform = 0x89C # matrix3x4_t

class CBasePropDoor:
    m_flAutoReturnDelay = 0xB18 # float
    m_hDoorList = 0xB20 # CUtlVector<CHandle<CBasePropDoor>>
    m_nHardwareType = 0xB38 # int32_t
    m_bNeedsHardware = 0xB3C # bool
    m_eDoorState = 0xB40 # DoorState_t
    m_bLocked = 0xB44 # bool
    m_closedPosition = 0xB48 # Vector
    m_closedAngles = 0xB54 # QAngle
    m_hBlocker = 0xB60 # CHandle<CBaseEntity>
    m_bFirstBlocked = 0xB64 # bool
    m_ls = 0xB68 # locksound_t
    m_bForceClosed = 0xB88 # bool
    m_vecLatchWorldPosition = 0xB8C # Vector
    m_hActivator = 0xB98 # CHandle<CBaseEntity>
    m_SoundMoving = 0xBA8 # CUtlSymbolLarge
    m_SoundOpen = 0xBB0 # CUtlSymbolLarge
    m_SoundClose = 0xBB8 # CUtlSymbolLarge
    m_SoundLock = 0xBC0 # CUtlSymbolLarge
    m_SoundUnlock = 0xBC8 # CUtlSymbolLarge
    m_SoundLatch = 0xBD0 # CUtlSymbolLarge
    m_SoundPound = 0xBD8 # CUtlSymbolLarge
    m_SoundJiggle = 0xBE0 # CUtlSymbolLarge
    m_SoundLockedAnim = 0xBE8 # CUtlSymbolLarge
    m_numCloseAttempts = 0xBF0 # int32_t
    m_nPhysicsMaterial = 0xBF4 # CUtlStringToken
    m_SlaveName = 0xBF8 # CUtlSymbolLarge
    m_hMaster = 0xC00 # CHandle<CBasePropDoor>
    m_OnBlockedClosing = 0xC08 # CEntityIOOutput
    m_OnBlockedOpening = 0xC30 # CEntityIOOutput
    m_OnUnblockedClosing = 0xC58 # CEntityIOOutput
    m_OnUnblockedOpening = 0xC80 # CEntityIOOutput
    m_OnFullyClosed = 0xCA8 # CEntityIOOutput
    m_OnFullyOpen = 0xCD0 # CEntityIOOutput
    m_OnClose = 0xCF8 # CEntityIOOutput
    m_OnOpen = 0xD20 # CEntityIOOutput
    m_OnLockedUse = 0xD48 # CEntityIOOutput
    m_OnAjarOpen = 0xD70 # CEntityIOOutput

class CBaseToggle:
    m_toggle_state = 0x700 # TOGGLE_STATE
    m_flMoveDistance = 0x704 # float
    m_flWait = 0x708 # float
    m_flLip = 0x70C # float
    m_bAlwaysFireBlockedOutputs = 0x710 # bool
    m_vecPosition1 = 0x714 # Vector
    m_vecPosition2 = 0x720 # Vector
    m_vecMoveAng = 0x72C # QAngle
    m_vecAngle1 = 0x738 # QAngle
    m_vecAngle2 = 0x744 # QAngle
    m_flHeight = 0x750 # float
    m_hActivator = 0x754 # CHandle<CBaseEntity>
    m_vecFinalDest = 0x758 # Vector
    m_vecFinalAngle = 0x764 # QAngle
    m_movementType = 0x770 # int32_t
    m_sMaster = 0x778 # CUtlSymbolLarge

class CBaseTrigger:
    m_bDisabled = 0x780 # bool
    m_iFilterName = 0x788 # CUtlSymbolLarge
    m_hFilter = 0x790 # CHandle<CBaseFilter>
    m_OnStartTouch = 0x798 # CEntityIOOutput
    m_OnStartTouchAll = 0x7C0 # CEntityIOOutput
    m_OnEndTouch = 0x7E8 # CEntityIOOutput
    m_OnEndTouchAll = 0x810 # CEntityIOOutput
    m_OnTouching = 0x838 # CEntityIOOutput
    m_OnNotTouching = 0x860 # CEntityIOOutput
    m_hTouchingEntities = 0x888 # CUtlVector<CHandle<CBaseEntity>>
    m_bClientSidePredicted = 0x8A0 # bool

class CBaseViewModel:
    m_vecLastFacing = 0x898 # Vector
    m_nViewModelIndex = 0x8A4 # uint32_t
    m_nAnimationParity = 0x8A8 # uint32_t
    m_flAnimationStartTime = 0x8AC # float
    m_hWeapon = 0x8B0 # CHandle<CBasePlayerWeapon>
    m_sVMName = 0x8B8 # CUtlSymbolLarge
    m_sAnimationPrefix = 0x8C0 # CUtlSymbolLarge
    m_hOldLayerSequence = 0x8C8 # HSequence
    m_oldLayer = 0x8CC # int32_t
    m_oldLayerStartTime = 0x8D0 # float
    m_hControlPanel = 0x8D4 # CHandle<CBaseEntity>

class CBeam:
    m_flFrameRate = 0x700 # float
    m_flHDRColorScale = 0x704 # float
    m_flFireTime = 0x708 # GameTime_t
    m_flDamage = 0x70C # float
    m_nNumBeamEnts = 0x710 # uint8_t
    m_hBaseMaterial = 0x718 # CStrongHandle<InfoForResourceTypeIMaterial2>
    m_nHaloIndex = 0x720 # CStrongHandle<InfoForResourceTypeIMaterial2>
    m_nBeamType = 0x728 # BeamType_t
    m_nBeamFlags = 0x72C # uint32_t
    m_hAttachEntity = 0x730 # CHandle<CBaseEntity>[10]
    m_nAttachIndex = 0x758 # AttachmentHandle_t[10]
    m_fWidth = 0x764 # float
    m_fEndWidth = 0x768 # float
    m_fFadeLength = 0x76C # float
    m_fHaloScale = 0x770 # float
    m_fAmplitude = 0x774 # float
    m_fStartFrame = 0x778 # float
    m_fSpeed = 0x77C # float
    m_flFrame = 0x780 # float
    m_nClipStyle = 0x784 # BeamClipStyle_t
    m_bTurnedOff = 0x788 # bool
    m_vecEndPos = 0x78C # Vector
    m_hEndEntity = 0x798 # CHandle<CBaseEntity>
    m_nDissolveType = 0x79C # int32_t

class CBlood:
    m_vecSprayAngles = 0x4B0 # QAngle
    m_vecSprayDir = 0x4BC # Vector
    m_flAmount = 0x4C8 # float
    m_Color = 0x4CC # int32_t

class CBodyComponent:
    m_pSceneNode = 0x8 # CGameSceneNode*
    __m_pChainEntity = 0x20 # CNetworkVarChainer

class CBodyComponentBaseAnimGraph:
    m_animationController = 0x480 # CBaseAnimGraphController
    __m_pChainEntity = 0x760 # CNetworkVarChainer

class CBodyComponentBaseModelEntity:
    __m_pChainEntity = 0x480 # CNetworkVarChainer

class CBodyComponentPoint:
    m_sceneNode = 0x50 # CGameSceneNode
    __m_pChainEntity = 0x1A0 # CNetworkVarChainer

class CBodyComponentSkeletonInstance:
    m_skeletonInstance = 0x50 # CSkeletonInstance
    __m_pChainEntity = 0x450 # CNetworkVarChainer

class CBombTarget:
    m_OnBombExplode = 0x8A8 # CEntityIOOutput
    m_OnBombPlanted = 0x8D0 # CEntityIOOutput
    m_OnBombDefused = 0x8F8 # CEntityIOOutput
    m_bIsBombSiteB = 0x920 # bool
    m_bIsHeistBombTarget = 0x921 # bool
    m_bBombPlantedHere = 0x922 # bool
    m_szMountTarget = 0x928 # CUtlSymbolLarge
    m_hInstructorHint = 0x930 # CHandle<CBaseEntity>
    m_nBombSiteDesignation = 0x934 # int32_t

class CBot:
    m_pController = 0x10 # CCSPlayerController*
    m_pPlayer = 0x18 # CCSPlayerPawn*
    m_bHasSpawned = 0x20 # bool
    m_id = 0x24 # uint32_t
    m_isRunning = 0xB8 # bool
    m_isCrouching = 0xB9 # bool
    m_forwardSpeed = 0xBC # float
    m_leftSpeed = 0xC0 # float
    m_verticalSpeed = 0xC4 # float
    m_buttonFlags = 0xC8 # uint64_t
    m_jumpTimestamp = 0xD0 # float
    m_viewForward = 0xD4 # Vector
    m_postureStackIndex = 0xF0 # int32_t

class CBreakable:
    m_Material = 0x710 # Materials
    m_hBreaker = 0x714 # CHandle<CBaseEntity>
    m_Explosion = 0x718 # Explosions
    m_iszSpawnObject = 0x720 # CUtlSymbolLarge
    m_flPressureDelay = 0x728 # float
    m_iMinHealthDmg = 0x72C # int32_t
    m_iszPropData = 0x730 # CUtlSymbolLarge
    m_impactEnergyScale = 0x738 # float
    m_nOverrideBlockLOS = 0x73C # EOverrideBlockLOS_t
    m_OnBreak = 0x740 # CEntityIOOutput
    m_OnHealthChanged = 0x768 # CEntityOutputTemplate<float>
    m_flDmgModBullet = 0x790 # float
    m_flDmgModClub = 0x794 # float
    m_flDmgModExplosive = 0x798 # float
    m_flDmgModFire = 0x79C # float
    m_iszPhysicsDamageTableName = 0x7A0 # CUtlSymbolLarge
    m_iszBasePropData = 0x7A8 # CUtlSymbolLarge
    m_iInteractions = 0x7B0 # int32_t
    m_PerformanceMode = 0x7B4 # PerformanceMode_t
    m_hPhysicsAttacker = 0x7B8 # CHandle<CBasePlayerPawn>
    m_flLastPhysicsInfluenceTime = 0x7BC # GameTime_t

class CBreakableProp:
    m_OnBreak = 0x8E0 # CEntityIOOutput
    m_OnHealthChanged = 0x908 # CEntityOutputTemplate<float>
    m_OnTakeDamage = 0x930 # CEntityIOOutput
    m_impactEnergyScale = 0x958 # float
    m_iMinHealthDmg = 0x95C # int32_t
    m_preferredCarryAngles = 0x960 # QAngle
    m_flPressureDelay = 0x96C # float
    m_hBreaker = 0x970 # CHandle<CBaseEntity>
    m_PerformanceMode = 0x974 # PerformanceMode_t
    m_flDmgModBullet = 0x978 # float
    m_flDmgModClub = 0x97C # float
    m_flDmgModExplosive = 0x980 # float
    m_flDmgModFire = 0x984 # float
    m_iszPhysicsDamageTableName = 0x988 # CUtlSymbolLarge
    m_iszBasePropData = 0x990 # CUtlSymbolLarge
    m_iInteractions = 0x998 # int32_t
    m_flPreventDamageBeforeTime = 0x99C # GameTime_t
    m_bHasBreakPiecesOrCommands = 0x9A0 # bool
    m_explodeDamage = 0x9A4 # float
    m_explodeRadius = 0x9A8 # float
    m_explosionDelay = 0x9B0 # float
    m_explosionBuildupSound = 0x9B8 # CUtlSymbolLarge
    m_explosionCustomEffect = 0x9C0 # CUtlSymbolLarge
    m_explosionCustomSound = 0x9C8 # CUtlSymbolLarge
    m_explosionModifier = 0x9D0 # CUtlSymbolLarge
    m_hPhysicsAttacker = 0x9D8 # CHandle<CBasePlayerPawn>
    m_flLastPhysicsInfluenceTime = 0x9DC # GameTime_t
    m_bOriginalBlockLOS = 0x9E0 # bool
    m_flDefaultFadeScale = 0x9E4 # float
    m_hLastAttacker = 0x9E8 # CHandle<CBaseEntity>
    m_hFlareEnt = 0x9EC # CHandle<CBaseEntity>
    m_bUsePuntSound = 0x9F0 # bool
    m_iszPuntSound = 0x9F8 # CUtlSymbolLarge
    m_noGhostCollision = 0xA00 # bool

class CBreakableStageHelper:
    m_nCurrentStage = 0x8 # int32_t
    m_nStageCount = 0xC # int32_t

class CBtActionAim:
    m_szSensorInputKey = 0x68 # CUtlString
    m_szAimReadyKey = 0x80 # CUtlString
    m_flZoomCooldownTimestamp = 0x88 # float
    m_bDoneAiming = 0x8C # bool
    m_flLerpStartTime = 0x90 # float
    m_flNextLookTargetLerpTime = 0x94 # float
    m_flPenaltyReductionRatio = 0x98 # float
    m_NextLookTarget = 0x9C # QAngle
    m_AimTimer = 0xA8 # CountdownTimer
    m_SniperHoldTimer = 0xC0 # CountdownTimer
    m_FocusIntervalTimer = 0xD8 # CountdownTimer
    m_bAcquired = 0xF0 # bool

class CBtActionCombatPositioning:
    m_szSensorInputKey = 0x68 # CUtlString
    m_szIsAttackingKey = 0x80 # CUtlString
    m_ActionTimer = 0x88 # CountdownTimer
    m_bCrouching = 0xA0 # bool

class CBtActionMoveTo:
    m_szDestinationInputKey = 0x60 # CUtlString
    m_szHidingSpotInputKey = 0x68 # CUtlString
    m_szThreatInputKey = 0x70 # CUtlString
    m_vecDestination = 0x78 # Vector
    m_bAutoLookAdjust = 0x84 # bool
    m_bComputePath = 0x85 # bool
    m_flDamagingAreasPenaltyCost = 0x88 # float
    m_CheckApproximateCornersTimer = 0x90 # CountdownTimer
    m_CheckHighPriorityItem = 0xA8 # CountdownTimer
    m_RepathTimer = 0xC0 # CountdownTimer
    m_flArrivalEpsilon = 0xD8 # float
    m_flAdditionalArrivalEpsilon2D = 0xDC # float
    m_flHidingSpotCheckDistanceThreshold = 0xE0 # float
    m_flNearestAreaDistanceThreshold = 0xE4 # float

class CBtActionParachutePositioning:
    m_ActionTimer = 0x58 # CountdownTimer

class CBtNodeCondition:
    m_bNegated = 0x58 # bool

class CBtNodeConditionInactive:
    m_flRoundStartThresholdSeconds = 0x78 # float
    m_flSensorInactivityThresholdSeconds = 0x7C # float
    m_SensorInactivityTimer = 0x80 # CountdownTimer

class CBubbling:
    m_density = 0x700 # int32_t
    m_frequency = 0x704 # int32_t
    m_state = 0x708 # int32_t

class CBuoyancyHelper:
    m_flFluidDensity = 0x18 # float

class CBuyZone:
    m_LegacyTeamNum = 0x8A8 # int32_t

class CC4:
    m_vecLastValidPlayerHeldPosition = 0xE20 # Vector
    m_vecLastValidDroppedPosition = 0xE2C # Vector
    m_bDoValidDroppedPositionCheck = 0xE38 # bool
    m_bStartedArming = 0xE39 # bool
    m_fArmedTime = 0xE3C # GameTime_t
    m_bBombPlacedAnimation = 0xE40 # bool
    m_bIsPlantingViaUse = 0xE41 # bool
    m_entitySpottedState = 0xE48 # EntitySpottedState_t
    m_nSpotRules = 0xE60 # int32_t
    m_bPlayedArmingBeeps = 0xE64 # bool[7]
    m_bBombPlanted = 0xE6B # bool
    m_bDroppedFromDeath = 0xE6C # bool

class CCSBot:
    m_lastCoopSpawnPoint = 0xF8 # CHandle<SpawnPointCoopEnemy>
    m_eyePosition = 0x108 # Vector
    m_name = 0x114 # char[64]
    m_combatRange = 0x154 # float
    m_isRogue = 0x158 # bool
    m_rogueTimer = 0x160 # CountdownTimer
    m_diedLastRound = 0x17C # bool
    m_safeTime = 0x180 # float
    m_wasSafe = 0x184 # bool
    m_blindFire = 0x18C # bool
    m_surpriseTimer = 0x190 # CountdownTimer
    m_bAllowActive = 0x1A8 # bool
    m_isFollowing = 0x1A9 # bool
    m_leader = 0x1AC # CHandle<CCSPlayerPawn>
    m_followTimestamp = 0x1B0 # float
    m_allowAutoFollowTime = 0x1B4 # float
    m_hurryTimer = 0x1B8 # CountdownTimer
    m_alertTimer = 0x1D0 # CountdownTimer
    m_sneakTimer = 0x1E8 # CountdownTimer
    m_panicTimer = 0x200 # CountdownTimer
    m_stateTimestamp = 0x4D0 # float
    m_isAttacking = 0x4D4 # bool
    m_isOpeningDoor = 0x4D5 # bool
    m_taskEntity = 0x4DC # CHandle<CBaseEntity>
    m_goalPosition = 0x4EC # Vector
    m_goalEntity = 0x4F8 # CHandle<CBaseEntity>
    m_avoid = 0x4FC # CHandle<CBaseEntity>
    m_avoidTimestamp = 0x500 # float
    m_isStopping = 0x504 # bool
    m_hasVisitedEnemySpawn = 0x505 # bool
    m_stillTimer = 0x508 # IntervalTimer
    m_bEyeAnglesUnderPathFinderControl = 0x518 # bool
    m_pathIndex = 0x6610 # int32_t
    m_areaEnteredTimestamp = 0x6614 # GameTime_t
    m_repathTimer = 0x6618 # CountdownTimer
    m_avoidFriendTimer = 0x6630 # CountdownTimer
    m_isFriendInTheWay = 0x6648 # bool
    m_politeTimer = 0x6650 # CountdownTimer
    m_isWaitingBehindFriend = 0x6668 # bool
    m_pathLadderEnd = 0x6694 # float
    m_mustRunTimer = 0x66E0 # CountdownTimer
    m_waitTimer = 0x66F8 # CountdownTimer
    m_updateTravelDistanceTimer = 0x6710 # CountdownTimer
    m_playerTravelDistance = 0x6728 # float[64]
    m_travelDistancePhase = 0x6828 # uint8_t
    m_hostageEscortCount = 0x69C0 # uint8_t
    m_hostageEscortCountTimestamp = 0x69C4 # float
    m_desiredTeam = 0x69C8 # int32_t
    m_hasJoined = 0x69CC # bool
    m_isWaitingForHostage = 0x69CD # bool
    m_inhibitWaitingForHostageTimer = 0x69D0 # CountdownTimer
    m_waitForHostageTimer = 0x69E8 # CountdownTimer
    m_noisePosition = 0x6A00 # Vector
    m_noiseTravelDistance = 0x6A0C # float
    m_noiseTimestamp = 0x6A10 # float
    m_noiseSource = 0x6A18 # CCSPlayerPawn*
    m_noiseBendTimer = 0x6A30 # CountdownTimer
    m_bentNoisePosition = 0x6A48 # Vector
    m_bendNoisePositionValid = 0x6A54 # bool
    m_lookAroundStateTimestamp = 0x6A58 # float
    m_lookAheadAngle = 0x6A5C # float
    m_forwardAngle = 0x6A60 # float
    m_inhibitLookAroundTimestamp = 0x6A64 # float
    m_lookAtSpot = 0x6A6C # Vector
    m_lookAtSpotDuration = 0x6A7C # float
    m_lookAtSpotTimestamp = 0x6A80 # float
    m_lookAtSpotAngleTolerance = 0x6A84 # float
    m_lookAtSpotClearIfClose = 0x6A88 # bool
    m_lookAtSpotAttack = 0x6A89 # bool
    m_lookAtDesc = 0x6A90 # char*
    m_peripheralTimestamp = 0x6A98 # float
    m_approachPointCount = 0x6C20 # uint8_t
    m_approachPointViewPosition = 0x6C24 # Vector
    m_viewSteadyTimer = 0x6C30 # IntervalTimer
    m_tossGrenadeTimer = 0x6C48 # CountdownTimer
    m_isAvoidingGrenade = 0x6C68 # CountdownTimer
    m_spotCheckTimestamp = 0x6C88 # float
    m_checkedHidingSpotCount = 0x7090 # int32_t
    m_lookPitch = 0x7094 # float
    m_lookPitchVel = 0x7098 # float
    m_lookYaw = 0x709C # float
    m_lookYawVel = 0x70A0 # float
    m_targetSpot = 0x70A4 # Vector
    m_targetSpotVelocity = 0x70B0 # Vector
    m_targetSpotPredicted = 0x70BC # Vector
    m_aimError = 0x70C8 # QAngle
    m_aimGoal = 0x70D4 # QAngle
    m_targetSpotTime = 0x70E0 # GameTime_t
    m_aimFocus = 0x70E4 # float
    m_aimFocusInterval = 0x70E8 # float
    m_aimFocusNextUpdate = 0x70EC # GameTime_t
    m_ignoreEnemiesTimer = 0x70F8 # CountdownTimer
    m_enemy = 0x7110 # CHandle<CCSPlayerPawn>
    m_isEnemyVisible = 0x7114 # bool
    m_visibleEnemyParts = 0x7115 # uint8_t
    m_lastEnemyPosition = 0x7118 # Vector
    m_lastSawEnemyTimestamp = 0x7124 # float
    m_firstSawEnemyTimestamp = 0x7128 # float
    m_currentEnemyAcquireTimestamp = 0x712C # float
    m_enemyDeathTimestamp = 0x7130 # float
    m_friendDeathTimestamp = 0x7134 # float
    m_isLastEnemyDead = 0x7138 # bool
    m_nearbyEnemyCount = 0x713C # int32_t
    m_bomber = 0x7348 # CHandle<CCSPlayerPawn>
    m_nearbyFriendCount = 0x734C # int32_t
    m_closestVisibleFriend = 0x7350 # CHandle<CCSPlayerPawn>
    m_closestVisibleHumanFriend = 0x7354 # CHandle<CCSPlayerPawn>
    m_attentionInterval = 0x7358 # IntervalTimer
    m_attacker = 0x7368 # CHandle<CCSPlayerPawn>
    m_attackedTimestamp = 0x736C # float
    m_burnedByFlamesTimer = 0x7370 # IntervalTimer
    m_lastVictimID = 0x7380 # int32_t
    m_isAimingAtEnemy = 0x7384 # bool
    m_isRapidFiring = 0x7385 # bool
    m_equipTimer = 0x7388 # IntervalTimer
    m_zoomTimer = 0x7398 # CountdownTimer
    m_fireWeaponTimestamp = 0x73B0 # GameTime_t
    m_lookForWeaponsOnGroundTimer = 0x73B8 # CountdownTimer
    m_bIsSleeping = 0x73D0 # bool
    m_isEnemySniperVisible = 0x73D1 # bool
    m_sawEnemySniperTimer = 0x73D8 # CountdownTimer
    m_enemyQueueIndex = 0x7490 # uint8_t
    m_enemyQueueCount = 0x7491 # uint8_t
    m_enemyQueueAttendIndex = 0x7492 # uint8_t
    m_isStuck = 0x7493 # bool
    m_stuckTimestamp = 0x7494 # GameTime_t
    m_stuckSpot = 0x7498 # Vector
    m_wiggleTimer = 0x74A8 # CountdownTimer
    m_stuckJumpTimer = 0x74C0 # CountdownTimer
    m_nextCleanupCheckTimestamp = 0x74D8 # GameTime_t
    m_avgVel = 0x74DC # float[10]
    m_avgVelIndex = 0x7504 # int32_t
    m_avgVelCount = 0x7508 # int32_t
    m_lastOrigin = 0x750C # Vector
    m_lastRadioRecievedTimestamp = 0x751C # float
    m_lastRadioSentTimestamp = 0x7520 # float
    m_radioSubject = 0x7524 # CHandle<CCSPlayerPawn>
    m_radioPosition = 0x7528 # Vector
    m_voiceEndTimestamp = 0x7534 # float
    m_lastValidReactionQueueFrame = 0x7540 # int32_t

class CCSGOViewModel:
    m_bShouldIgnoreOffsetAndAccuracy = 0x8D8 # bool
    m_nWeaponParity = 0x8DC # uint32_t
    m_nOldWeaponParity = 0x8E0 # uint32_t

class CCSGO_TeamPreviewCharacterPosition:
    m_nVariant = 0x4B0 # int32_t
    m_nRandom = 0x4B4 # int32_t
    m_nOrdinal = 0x4B8 # int32_t
    m_sWeaponName = 0x4C0 # CUtlString
    m_xuid = 0x4C8 # uint64_t
    m_agentItem = 0x4D0 # CEconItemView
    m_glovesItem = 0x748 # CEconItemView
    m_weaponItem = 0x9C0 # CEconItemView

class CCSGameModeRules:
    __m_pChainEntity = 0x8 # CNetworkVarChainer

class CCSGameModeRules_Deathmatch:
    m_bFirstThink = 0x30 # bool
    m_bFirstThinkAfterConnected = 0x31 # bool
    m_flDMBonusStartTime = 0x34 # GameTime_t
    m_flDMBonusTimeLength = 0x38 # float
    m_nDMBonusWeaponLoadoutSlot = 0x3C # int16_t

class CCSGameRules:
    __m_pChainEntity = 0x98 # CNetworkVarChainer
    m_coopMissionManager = 0xC0 # CHandle<CBaseEntity>
    m_bFreezePeriod = 0xC4 # bool
    m_bWarmupPeriod = 0xC5 # bool
    m_fWarmupPeriodEnd = 0xC8 # GameTime_t
    m_fWarmupPeriodStart = 0xCC # GameTime_t
    m_nTotalPausedTicks = 0xD0 # int32_t
    m_nPauseStartTick = 0xD4 # int32_t
    m_bServerPaused = 0xD8 # bool
    m_bGamePaused = 0xD9 # bool
    m_bTerroristTimeOutActive = 0xDA # bool
    m_bCTTimeOutActive = 0xDB # bool
    m_flTerroristTimeOutRemaining = 0xDC # float
    m_flCTTimeOutRemaining = 0xE0 # float
    m_nTerroristTimeOuts = 0xE4 # int32_t
    m_nCTTimeOuts = 0xE8 # int32_t
    m_bTechnicalTimeOut = 0xEC # bool
    m_bMatchWaitingForResume = 0xED # bool
    m_iRoundTime = 0xF0 # int32_t
    m_fMatchStartTime = 0xF4 # float
    m_fRoundStartTime = 0xF8 # GameTime_t
    m_flRestartRoundTime = 0xFC # GameTime_t
    m_bGameRestart = 0x100 # bool
    m_flGameStartTime = 0x104 # float
    m_timeUntilNextPhaseStarts = 0x108 # float
    m_gamePhase = 0x10C # int32_t
    m_totalRoundsPlayed = 0x110 # int32_t
    m_nRoundsPlayedThisPhase = 0x114 # int32_t
    m_nOvertimePlaying = 0x118 # int32_t
    m_iHostagesRemaining = 0x11C # int32_t
    m_bAnyHostageReached = 0x120 # bool
    m_bMapHasBombTarget = 0x121 # bool
    m_bMapHasRescueZone = 0x122 # bool
    m_bMapHasBuyZone = 0x123 # bool
    m_bIsQueuedMatchmaking = 0x124 # bool
    m_nQueuedMatchmakingMode = 0x128 # int32_t
    m_bIsValveDS = 0x12C # bool
    m_bLogoMap = 0x12D # bool
    m_bPlayAllStepSoundsOnServer = 0x12E # bool
    m_iSpectatorSlotCount = 0x130 # int32_t
    m_MatchDevice = 0x134 # int32_t
    m_bHasMatchStarted = 0x138 # bool
    m_nNextMapInMapgroup = 0x13C # int32_t
    m_szTournamentEventName = 0x140 # char[512]
    m_szTournamentEventStage = 0x340 # char[512]
    m_szMatchStatTxt = 0x540 # char[512]
    m_szTournamentPredictionsTxt = 0x740 # char[512]
    m_nTournamentPredictionsPct = 0x940 # int32_t
    m_flCMMItemDropRevealStartTime = 0x944 # GameTime_t
    m_flCMMItemDropRevealEndTime = 0x948 # GameTime_t
    m_bIsDroppingItems = 0x94C # bool
    m_bIsQuestEligible = 0x94D # bool
    m_bIsHltvActive = 0x94E # bool
    m_nGuardianModeWaveNumber = 0x950 # int32_t
    m_nGuardianModeSpecialKillsRemaining = 0x954 # int32_t
    m_nGuardianModeSpecialWeaponNeeded = 0x958 # int32_t
    m_nGuardianGrenadesToGiveBots = 0x95C # int32_t
    m_nNumHeaviesToSpawn = 0x960 # int32_t
    m_numGlobalGiftsGiven = 0x964 # uint32_t
    m_numGlobalGifters = 0x968 # uint32_t
    m_numGlobalGiftsPeriodSeconds = 0x96C # uint32_t
    m_arrFeaturedGiftersAccounts = 0x970 # uint32_t[4]
    m_arrFeaturedGiftersGifts = 0x980 # uint32_t[4]
    m_arrProhibitedItemIndices = 0x990 # uint16_t[100]
    m_arrTournamentActiveCasterAccounts = 0xA58 # uint32_t[4]
    m_numBestOfMaps = 0xA68 # int32_t
    m_nHalloweenMaskListSeed = 0xA6C # int32_t
    m_bBombDropped = 0xA70 # bool
    m_bBombPlanted = 0xA71 # bool
    m_iRoundWinStatus = 0xA74 # int32_t
    m_eRoundWinReason = 0xA78 # int32_t
    m_bTCantBuy = 0xA7C # bool
    m_bCTCantBuy = 0xA7D # bool
    m_flGuardianBuyUntilTime = 0xA80 # GameTime_t
    m_iMatchStats_RoundResults = 0xA84 # int32_t[30]
    m_iMatchStats_PlayersAlive_CT = 0xAFC # int32_t[30]
    m_iMatchStats_PlayersAlive_T = 0xB74 # int32_t[30]
    m_TeamRespawnWaveTimes = 0xBEC # float[32]
    m_flNextRespawnWave = 0xC6C # GameTime_t[32]
    m_nServerQuestID = 0xCEC # int32_t
    m_vMinimapMins = 0xCF0 # Vector
    m_vMinimapMaxs = 0xCFC # Vector
    m_MinimapVerticalSectionHeights = 0xD08 # float[8]
    m_bDontIncrementCoopWave = 0xD28 # bool
    m_bSpawnedTerrorHuntHeavy = 0xD29 # bool
    m_nEndMatchMapGroupVoteTypes = 0xD2C # int32_t[10]
    m_nEndMatchMapGroupVoteOptions = 0xD54 # int32_t[10]
    m_nEndMatchMapVoteWinner = 0xD7C # int32_t
    m_iNumConsecutiveCTLoses = 0xD80 # int32_t
    m_iNumConsecutiveTerroristLoses = 0xD84 # int32_t
    m_bHasHostageBeenTouched = 0xDA0 # bool
    m_flIntermissionStartTime = 0xDA4 # GameTime_t
    m_flIntermissionEndTime = 0xDA8 # GameTime_t
    m_bLevelInitialized = 0xDAC # bool
    m_iTotalRoundsPlayed = 0xDB0 # int32_t
    m_iUnBalancedRounds = 0xDB4 # int32_t
    m_endMatchOnRoundReset = 0xDB8 # bool
    m_endMatchOnThink = 0xDB9 # bool
    m_iFreezeTime = 0xDBC # int32_t
    m_iNumTerrorist = 0xDC0 # int32_t
    m_iNumCT = 0xDC4 # int32_t
    m_iNumSpawnableTerrorist = 0xDC8 # int32_t
    m_iNumSpawnableCT = 0xDCC # int32_t
    m_arrSelectedHostageSpawnIndices = 0xDD0 # CUtlVector<int32_t>
    m_bFirstConnected = 0xDE8 # bool
    m_bCompleteReset = 0xDE9 # bool
    m_bPickNewTeamsOnReset = 0xDEA # bool
    m_bScrambleTeamsOnRestart = 0xDEB # bool
    m_bSwapTeamsOnRestart = 0xDEC # bool
    m_nEndMatchTiedVotes = 0xDF8 # CUtlVector<int32_t>
    m_bNeedToAskPlayersForContinueVote = 0xE14 # bool
    m_numQueuedMatchmakingAccounts = 0xE18 # uint32_t
    m_pQueuedMatchmakingReservationString = 0xE20 # char*
    m_numTotalTournamentDrops = 0xE28 # uint32_t
    m_numSpectatorsCountMax = 0xE2C # uint32_t
    m_numSpectatorsCountMaxTV = 0xE30 # uint32_t
    m_numSpectatorsCountMaxLnk = 0xE34 # uint32_t
    m_bForceTeamChangeSilent = 0xE40 # bool
    m_bLoadingRoundBackupData = 0xE41 # bool
    m_nMatchInfoShowType = 0xE78 # int32_t
    m_flMatchInfoDecidedTime = 0xE7C # float
    m_flCoopRespawnAndHealTime = 0xE98 # float
    m_coopBonusCoinsFound = 0xE9C # int32_t
    m_coopBonusPistolsOnly = 0xEA0 # bool
    m_coopPlayersInDeploymentZone = 0xEA1 # bool
    m_coopMissionDeadPlayerRespawnEnabled = 0xEA2 # bool
    mTeamDMLastWinningTeamNumber = 0xEA4 # int32_t
    mTeamDMLastThinkTime = 0xEA8 # float
    m_flTeamDMLastAnnouncementTime = 0xEAC # float
    m_iAccountTerrorist = 0xEB0 # int32_t
    m_iAccountCT = 0xEB4 # int32_t
    m_iSpawnPointCount_Terrorist = 0xEB8 # int32_t
    m_iSpawnPointCount_CT = 0xEBC # int32_t
    m_iMaxNumTerrorists = 0xEC0 # int32_t
    m_iMaxNumCTs = 0xEC4 # int32_t
    m_iLoserBonus = 0xEC8 # int32_t
    m_iLoserBonusMostRecentTeam = 0xECC # int32_t
    m_tmNextPeriodicThink = 0xED0 # float
    m_bVoiceWonMatchBragFired = 0xED4 # bool
    m_fWarmupNextChatNoticeTime = 0xED8 # float
    m_iHostagesRescued = 0xEE0 # int32_t
    m_iHostagesTouched = 0xEE4 # int32_t
    m_flNextHostageAnnouncement = 0xEE8 # float
    m_bNoTerroristsKilled = 0xEEC # bool
    m_bNoCTsKilled = 0xEED # bool
    m_bNoEnemiesKilled = 0xEEE # bool
    m_bCanDonateWeapons = 0xEEF # bool
    m_firstKillTime = 0xEF4 # float
    m_firstBloodTime = 0xEFC # float
    m_hostageWasInjured = 0xF18 # bool
    m_hostageWasKilled = 0xF19 # bool
    m_bVoteCalled = 0xF28 # bool
    m_bServerVoteOnReset = 0xF29 # bool
    m_flVoteCheckThrottle = 0xF2C # float
    m_bBuyTimeEnded = 0xF30 # bool
    m_nLastFreezeEndBeep = 0xF34 # int32_t
    m_bTargetBombed = 0xF38 # bool
    m_bBombDefused = 0xF39 # bool
    m_bMapHasBombZone = 0xF3A # bool
    m_vecMainCTSpawnPos = 0xF58 # Vector
    m_CTSpawnPointsMasterList = 0xF68 # CUtlVector<SpawnPoint*>
    m_TerroristSpawnPointsMasterList = 0xF80 # CUtlVector<SpawnPoint*>
    m_iNextCTSpawnPoint = 0xF98 # int32_t
    m_iNextTerroristSpawnPoint = 0xF9C # int32_t
    m_CTSpawnPoints = 0xFA0 # CUtlVector<SpawnPoint*>
    m_TerroristSpawnPoints = 0xFB8 # CUtlVector<SpawnPoint*>
    m_bIsUnreservedGameServer = 0xFD0 # bool
    m_fAutobalanceDisplayTime = 0xFD4 # float
    m_bAllowWeaponSwitch = 0x1240 # bool
    m_bRoundTimeWarningTriggered = 0x1241 # bool
    m_phaseChangeAnnouncementTime = 0x1244 # GameTime_t
    m_fNextUpdateTeamClanNamesTime = 0x1248 # float
    m_flLastThinkTime = 0x124C # GameTime_t
    m_fAccumulatedRoundOffDamage = 0x1250 # float
    m_nShorthandedBonusLastEvalRound = 0x1254 # int32_t
    m_nMatchAbortedEarlyReason = 0x14D0 # int32_t
    m_bHasTriggeredRoundStartMusic = 0x14D4 # bool
    m_bHasTriggeredCoopSpawnReset = 0x14D5 # bool
    m_bSwitchingTeamsAtRoundReset = 0x14D6 # bool
    m_pGameModeRules = 0x14F0 # CCSGameModeRules*
    m_BtGlobalBlackboard = 0x14F8 # KeyValues3
    m_hPlayerResource = 0x1560 # CHandle<CBaseEntity>
    m_RetakeRules = 0x1568 # CRetakeGameRules
    m_GuardianBotSkillLevelMax = 0x174C # int32_t
    m_GuardianBotSkillLevelMin = 0x1750 # int32_t
    m_arrTeamUniqueKillWeaponsMatch = 0x1758 # CUtlVector<int32_t>[4]
    m_bTeamLastKillUsedUniqueWeaponMatch = 0x17B8 # bool[4]
    m_nMatchEndCount = 0x17E0 # uint8_t
    m_nTTeamIntroVariant = 0x17E4 # int32_t
    m_nCTTeamIntroVariant = 0x17E8 # int32_t
    m_bTeamIntroPeriod = 0x17EC # bool
    m_fTeamIntroPeriodEnd = 0x17F0 # GameTime_t
    m_bPlayedTeamIntroVO = 0x17F4 # bool
    m_flLastPerfSampleTime = 0x5800 # double
    m_bSkipNextServerPerfSample = 0x5808 # bool

class CCSGameRulesProxy:
    m_pGameRules = 0x4B0 # CCSGameRules*

class CCSPlace:
    m_name = 0x708 # CUtlSymbolLarge

class CCSPlayerBase_CameraServices:
    m_iFOV = 0x170 # uint32_t
    m_iFOVStart = 0x174 # uint32_t
    m_flFOVTime = 0x178 # GameTime_t
    m_flFOVRate = 0x17C # float
    m_hZoomOwner = 0x180 # CHandle<CBaseEntity>
    m_hTriggerFogList = 0x188 # CUtlVector<CHandle<CBaseEntity>>
    m_hLastFogTrigger = 0x1A0 # CHandle<CBaseEntity>

class CCSPlayerController:
    m_pInGameMoneyServices = 0x6B8 # CCSPlayerController_InGameMoneyServices*
    m_pInventoryServices = 0x6C0 # CCSPlayerController_InventoryServices*
    m_pActionTrackingServices = 0x6C8 # CCSPlayerController_ActionTrackingServices*
    m_pDamageServices = 0x6D0 # CCSPlayerController_DamageServices*
    m_iPing = 0x6D8 # uint32_t
    m_bHasCommunicationAbuseMute = 0x6DC # bool
    m_szCrosshairCodes = 0x6E0 # CUtlSymbolLarge
    m_iPendingTeamNum = 0x6E8 # uint8_t
    m_flForceTeamTime = 0x6EC # GameTime_t
    m_iCompTeammateColor = 0x6F0 # int32_t
    m_bEverPlayedOnTeam = 0x6F4 # bool
    m_bAttemptedToGetColor = 0x6F5 # bool
    m_iTeammatePreferredColor = 0x6F8 # int32_t
    m_bTeamChanged = 0x6FC # bool
    m_bInSwitchTeam = 0x6FD # bool
    m_bHasSeenJoinGame = 0x6FE # bool
    m_bJustBecameSpectator = 0x6FF # bool
    m_bSwitchTeamsOnNextRoundReset = 0x700 # bool
    m_bRemoveAllItemsOnNextRoundReset = 0x701 # bool
    m_szClan = 0x708 # CUtlSymbolLarge
    m_szClanName = 0x710 # char[32]
    m_iCoachingTeam = 0x730 # int32_t
    m_nPlayerDominated = 0x738 # uint64_t
    m_nPlayerDominatingMe = 0x740 # uint64_t
    m_iCompetitiveRanking = 0x748 # int32_t
    m_iCompetitiveWins = 0x74C # int32_t
    m_iCompetitiveRankType = 0x750 # int8_t
    m_iCompetitiveRankingPredicted_Win = 0x754 # int32_t
    m_iCompetitiveRankingPredicted_Loss = 0x758 # int32_t
    m_iCompetitiveRankingPredicted_Tie = 0x75C # int32_t
    m_nEndMatchNextMapVote = 0x760 # int32_t
    m_unActiveQuestId = 0x764 # uint16_t
    m_nQuestProgressReason = 0x768 # QuestProgress::Reason
    m_unPlayerTvControlFlags = 0x76C # uint32_t
    m_iDraftIndex = 0x798 # int32_t
    m_msQueuedModeDisconnectionTimestamp = 0x79C # uint32_t
    m_uiAbandonRecordedReason = 0x7A0 # uint32_t
    m_bCannotBeKicked = 0x7A4 # bool
    m_bEverFullyConnected = 0x7A5 # bool
    m_bAbandonAllowsSurrender = 0x7A6 # bool
    m_bAbandonOffersInstantSurrender = 0x7A7 # bool
    m_bDisconnection1MinWarningPrinted = 0x7A8 # bool
    m_bScoreReported = 0x7A9 # bool
    m_nDisconnectionTick = 0x7AC # int32_t
    m_bControllingBot = 0x7B8 # bool
    m_bHasControlledBotThisRound = 0x7B9 # bool
    m_bHasBeenControlledByPlayerThisRound = 0x7BA # bool
    m_nBotsControlledThisRound = 0x7BC # int32_t
    m_bCanControlObservedBot = 0x7C0 # bool
    m_hPlayerPawn = 0x7C4 # CHandle<CCSPlayerPawn>
    m_hObserverPawn = 0x7C8 # CHandle<CCSObserverPawn>
    m_DesiredObserverMode = 0x7CC # int32_t
    m_hDesiredObserverTarget = 0x7D0 # CEntityHandle
    m_bPawnIsAlive = 0x7D4 # bool
    m_iPawnHealth = 0x7D8 # uint32_t
    m_iPawnArmor = 0x7DC # int32_t
    m_bPawnHasDefuser = 0x7E0 # bool
    m_bPawnHasHelmet = 0x7E1 # bool
    m_nPawnCharacterDefIndex = 0x7E2 # uint16_t
    m_iPawnLifetimeStart = 0x7E4 # int32_t
    m_iPawnLifetimeEnd = 0x7E8 # int32_t
    m_iPawnBotDifficulty = 0x7EC # int32_t
    m_hOriginalControllerOfCurrentPawn = 0x7F0 # CHandle<CCSPlayerController>
    m_iScore = 0x7F4 # int32_t
    m_iRoundScore = 0x7F8 # int32_t
    m_iRoundsWon = 0x7FC # int32_t
    m_vecKills = 0x800 # CNetworkUtlVectorBase<EKillTypes_t>
    m_iMVPs = 0x818 # int32_t
    m_nUpdateCounter = 0x81C # int32_t
    m_flSmoothedPing = 0x820 # float
    m_lastHeldVoteTimer = 0xF8C8 # IntervalTimer
    m_bShowHints = 0xF8E0 # bool
    m_iNextTimeCheck = 0xF8E4 # int32_t
    m_bJustDidTeamKill = 0xF8E8 # bool
    m_bPunishForTeamKill = 0xF8E9 # bool
    m_bGaveTeamDamageWarning = 0xF8EA # bool
    m_bGaveTeamDamageWarningThisRound = 0xF8EB # bool
    m_dblLastReceivedPacketPlatFloatTime = 0xF8F0 # double
    m_LastTeamDamageWarningTime = 0xF8F8 # GameTime_t
    m_LastTimePlayerWasDisconnectedForPawnsRemove = 0xF8FC # GameTime_t

class CCSPlayerController_ActionTrackingServices:
    m_perRoundStats = 0x40 # CUtlVectorEmbeddedNetworkVar<CSPerRoundStats_t>
    m_matchStats = 0x90 # CSMatchStats_t
    m_iNumRoundKills = 0x148 # int32_t
    m_iNumRoundKillsHeadshots = 0x14C # int32_t
    m_unTotalRoundDamageDealt = 0x150 # uint32_t

class CCSPlayerController_DamageServices:
    m_nSendUpdate = 0x40 # int32_t
    m_DamageList = 0x48 # CUtlVectorEmbeddedNetworkVar<CDamageRecord>

class CCSPlayerController_InGameMoneyServices:
    m_bReceivesMoneyNextRound = 0x40 # bool
    m_iAccountMoneyEarnedForNextRound = 0x44 # int32_t
    m_iAccount = 0x48 # int32_t
    m_iStartAccount = 0x4C # int32_t
    m_iTotalCashSpent = 0x50 # int32_t
    m_iCashSpentThisRound = 0x54 # int32_t

class CCSPlayerController_InventoryServices:
    m_unMusicID = 0x40 # uint16_t
    m_rank = 0x44 # MedalRank_t[6]
    m_nPersonaDataPublicLevel = 0x5C # int32_t
    m_nPersonaDataPublicCommendsLeader = 0x60 # int32_t
    m_nPersonaDataPublicCommendsTeacher = 0x64 # int32_t
    m_nPersonaDataPublicCommendsFriendly = 0x68 # int32_t
    m_unEquippedPlayerSprayIDs = 0xF48 # uint32_t[1]
    m_vecServerAuthoritativeWeaponSlots = 0xF50 # CUtlVectorEmbeddedNetworkVar<ServerAuthoritativeWeaponSlot_t>

class CCSPlayerPawn:
    m_pBulletServices = 0x1550 # CCSPlayer_BulletServices*
    m_pHostageServices = 0x1558 # CCSPlayer_HostageServices*
    m_pBuyServices = 0x1560 # CCSPlayer_BuyServices*
    m_pActionTrackingServices = 0x1568 # CCSPlayer_ActionTrackingServices*
    m_pRadioServices = 0x1570 # CCSPlayer_RadioServices*
    m_pDamageReactServices = 0x1578 # CCSPlayer_DamageReactServices*
    m_nCharacterDefIndex = 0x1580 # uint16_t
    m_hPreviousModel = 0x1588 # CStrongHandle<InfoForResourceTypeCModel>
    m_bHasFemaleVoice = 0x1590 # bool
    m_strVOPrefix = 0x1598 # CUtlString
    m_szLastPlaceName = 0x15A0 # char[18]
    m_bInHostageResetZone = 0x1660 # bool
    m_bInBuyZone = 0x1661 # bool
    m_bWasInBuyZone = 0x1662 # bool
    m_bInHostageRescueZone = 0x1663 # bool
    m_bInBombZone = 0x1664 # bool
    m_bWasInHostageRescueZone = 0x1665 # bool
    m_iRetakesOffering = 0x1668 # int32_t
    m_iRetakesOfferingCard = 0x166C # int32_t
    m_bRetakesHasDefuseKit = 0x1670 # bool
    m_bRetakesMVPLastRound = 0x1671 # bool
    m_iRetakesMVPBoostItem = 0x1674 # int32_t
    m_RetakesMVPBoostExtraUtility = 0x1678 # loadout_slot_t
    m_flHealthShotBoostExpirationTime = 0x167C # GameTime_t
    m_flLandseconds = 0x1680 # float
    m_aimPunchAngle = 0x1684 # QAngle
    m_aimPunchAngleVel = 0x1690 # QAngle
    m_aimPunchTickBase = 0x169C # int32_t
    m_aimPunchTickFraction = 0x16A0 # float
    m_aimPunchCache = 0x16A8 # CUtlVector<QAngle>
    m_bIsBuyMenuOpen = 0x16C0 # bool
    m_xLastHeadBoneTransform = 0x1C40 # CTransform
    m_bLastHeadBoneTransformIsValid = 0x1C60 # bool
    m_lastLandTime = 0x1C64 # GameTime_t
    m_bOnGroundLastTick = 0x1C68 # bool
    m_iPlayerLocked = 0x1C6C # int32_t
    m_flTimeOfLastInjury = 0x1C74 # GameTime_t
    m_flNextSprayDecalTime = 0x1C78 # GameTime_t
    m_bNextSprayDecalTimeExpedited = 0x1C7C # bool
    m_nRagdollDamageBone = 0x1C80 # int32_t
    m_vRagdollDamageForce = 0x1C84 # Vector
    m_vRagdollDamagePosition = 0x1C90 # Vector
    m_szRagdollDamageWeaponName = 0x1C9C # char[64]
    m_bRagdollDamageHeadshot = 0x1CDC # bool
    m_vRagdollServerOrigin = 0x1CE0 # Vector
    m_EconGloves = 0x1CF0 # CEconItemView
    m_qDeathEyeAngles = 0x1F68 # QAngle
    m_bSkipOneHeadConstraintUpdate = 0x1F74 # bool

class CCSPlayerPawnBase:
    m_CTouchExpansionComponent = 0xB68 # CTouchExpansionComponent
    m_pPingServices = 0xBB8 # CCSPlayer_PingServices*
    m_pViewModelServices = 0xBC0 # CPlayer_ViewModelServices*
    m_iDisplayHistoryBits = 0xBC8 # uint32_t
    m_flLastAttackedTeammate = 0xBCC # float
    m_hOriginalController = 0xBD0 # CHandle<CCSPlayerController>
    m_blindUntilTime = 0xBD4 # GameTime_t
    m_blindStartTime = 0xBD8 # GameTime_t
    m_allowAutoFollowTime = 0xBDC # GameTime_t
    m_entitySpottedState = 0xBE0 # EntitySpottedState_t
    m_nSpotRules = 0xBF8 # int32_t
    m_iPlayerState = 0xBFC # CSPlayerState
    m_chickenIdleSoundTimer = 0xC08 # CountdownTimer
    m_chickenJumpSoundTimer = 0xC20 # CountdownTimer
    m_vecLastBookmarkedPosition = 0xCD8 # Vector
    m_flLastDistanceTraveledNotice = 0xCE4 # float
    m_flAccumulatedDistanceTraveled = 0xCE8 # float
    m_flLastFriendlyFireDamageReductionRatio = 0xCEC # float
    m_bRespawning = 0xCF0 # bool
    m_nLastPickupPriority = 0xCF4 # int32_t
    m_flLastPickupPriorityTime = 0xCF8 # float
    m_bIsScoped = 0xCFC # bool
    m_bIsWalking = 0xCFD # bool
    m_bResumeZoom = 0xCFE # bool
    m_bIsDefusing = 0xCFF # bool
    m_bIsGrabbingHostage = 0xD00 # bool
    m_iBlockingUseActionInProgress = 0xD04 # CSPlayerBlockingUseAction_t
    m_fImmuneToGunGameDamageTime = 0xD08 # GameTime_t
    m_bGunGameImmunity = 0xD0C # bool
    m_fMolotovDamageTime = 0xD10 # float
    m_bHasMovedSinceSpawn = 0xD14 # bool
    m_bCanMoveDuringFreezePeriod = 0xD15 # bool
    m_flGuardianTooFarDistFrac = 0xD18 # float
    m_flNextGuardianTooFarHurtTime = 0xD1C # float
    m_flDetectedByEnemySensorTime = 0xD20 # GameTime_t
    m_flDealtDamageToEnemyMostRecentTimestamp = 0xD24 # float
    m_flLastEquippedHelmetTime = 0xD28 # GameTime_t
    m_flLastEquippedArmorTime = 0xD2C # GameTime_t
    m_nHeavyAssaultSuitCooldownRemaining = 0xD30 # int32_t
    m_bResetArmorNextSpawn = 0xD34 # bool
    m_flLastBumpMineBumpTime = 0xD38 # GameTime_t
    m_flEmitSoundTime = 0xD3C # GameTime_t
    m_iNumSpawns = 0xD40 # int32_t
    m_iShouldHaveCash = 0xD44 # int32_t
    m_bInvalidSteamLogonDelayed = 0xD48 # bool
    m_flLastAction = 0xD4C # GameTime_t
    m_flNameChangeHistory = 0xD50 # float[5]
    m_fLastGivenDefuserTime = 0xD64 # float
    m_fLastGivenBombTime = 0xD68 # float
    m_bHasNightVision = 0xD6C # bool
    m_bNightVisionOn = 0xD6D # bool
    m_fNextRadarUpdateTime = 0xD70 # float
    m_flLastMoneyUpdateTime = 0xD74 # float
    m_MenuStringBuffer = 0xD78 # char[1024]
    m_fIntroCamTime = 0x1178 # float
    m_nMyCollisionGroup = 0x117C # int32_t
    m_bInNoDefuseArea = 0x1180 # bool
    m_bKilledByTaser = 0x1181 # bool
    m_iMoveState = 0x1184 # int32_t
    m_grenadeParameterStashTime = 0x1188 # GameTime_t
    m_bGrenadeParametersStashed = 0x118C # bool
    m_angStashedShootAngles = 0x1190 # QAngle
    m_vecStashedGrenadeThrowPosition = 0x119C # Vector
    m_vecStashedVelocity = 0x11A8 # Vector
    m_angShootAngleHistory = 0x11B4 # QAngle[2]
    m_vecThrowPositionHistory = 0x11CC # Vector[2]
    m_vecVelocityHistory = 0x11E4 # Vector[2]
    m_bDiedAirborne = 0x11FC # bool
    m_iBombSiteIndex = 0x1200 # CEntityIndex
    m_nWhichBombZone = 0x1204 # int32_t
    m_bInBombZoneTrigger = 0x1208 # bool
    m_bWasInBombZoneTrigger = 0x1209 # bool
    m_iDirection = 0x120C # int32_t
    m_iShotsFired = 0x1210 # int32_t
    m_ArmorValue = 0x1214 # int32_t
    m_flFlinchStack = 0x1218 # float
    m_flVelocityModifier = 0x121C # float
    m_flHitHeading = 0x1220 # float
    m_nHitBodyPart = 0x1224 # int32_t
    m_iHostagesKilled = 0x1228 # int32_t
    m_vecTotalBulletForce = 0x122C # Vector
    m_flFlashDuration = 0x1238 # float
    m_flFlashMaxAlpha = 0x123C # float
    m_flProgressBarStartTime = 0x1240 # float
    m_iProgressBarDuration = 0x1244 # int32_t
    m_bWaitForNoAttack = 0x1248 # bool
    m_flLowerBodyYawTarget = 0x124C # float
    m_bStrafing = 0x1250 # bool
    m_lastStandingPos = 0x1254 # Vector
    m_ignoreLadderJumpTime = 0x1260 # float
    m_ladderSurpressionTimer = 0x1268 # CountdownTimer
    m_lastLadderNormal = 0x1280 # Vector
    m_lastLadderPos = 0x128C # Vector
    m_thirdPersonHeading = 0x1298 # QAngle
    m_flSlopeDropOffset = 0x12A4 # float
    m_flSlopeDropHeight = 0x12A8 # float
    m_vHeadConstraintOffset = 0x12AC # Vector
    m_iLastWeaponFireUsercmd = 0x12C0 # int32_t
    m_angEyeAngles = 0x12C4 # QAngle
    m_bVCollisionInitted = 0x12D0 # bool
    m_storedSpawnPosition = 0x12D4 # Vector
    m_storedSpawnAngle = 0x12E0 # QAngle
    m_bIsSpawning = 0x12EC # bool
    m_bHideTargetID = 0x12ED # bool
    m_nNumDangerZoneDamageHits = 0x12F0 # int32_t
    m_bHud_MiniScoreHidden = 0x12F4 # bool
    m_bHud_RadarHidden = 0x12F5 # bool
    m_nLastKillerIndex = 0x12F8 # CEntityIndex
    m_nLastConcurrentKilled = 0x12FC # int32_t
    m_nDeathCamMusic = 0x1300 # int32_t
    m_iAddonBits = 0x1304 # int32_t
    m_iPrimaryAddon = 0x1308 # int32_t
    m_iSecondaryAddon = 0x130C # int32_t
    m_currentDeafnessFilter = 0x1310 # CUtlStringToken
    m_NumEnemiesKilledThisSpawn = 0x1314 # int32_t
    m_NumEnemiesKilledThisRound = 0x1318 # int32_t
    m_NumEnemiesAtRoundStart = 0x131C # int32_t
    m_wasNotKilledNaturally = 0x1320 # bool
    m_vecPlayerPatchEconIndices = 0x1324 # uint32_t[5]
    m_iDeathFlags = 0x1338 # int32_t
    m_hPet = 0x133C # CHandle<CChicken>
    m_unCurrentEquipmentValue = 0x1508 # uint16_t
    m_unRoundStartEquipmentValue = 0x150A # uint16_t
    m_unFreezetimeEndEquipmentValue = 0x150C # uint16_t
    m_nSurvivalTeamNumber = 0x1510 # int32_t
    m_bHasDeathInfo = 0x1514 # bool
    m_flDeathInfoTime = 0x1518 # float
    m_vecDeathInfoOrigin = 0x151C # Vector
    m_bKilledByHeadshot = 0x1528 # bool
    m_LastHitBox = 0x152C # int32_t
    m_LastHealth = 0x1530 # int32_t
    m_flLastCollisionCeiling = 0x1534 # float
    m_flLastCollisionCeilingChangeTime = 0x1538 # float
    m_pBot = 0x1540 # CCSBot*
    m_bBotAllowActive = 0x1548 # bool
    m_bCommittingSuicideOnTeamChange = 0x1549 # bool

class CCSPlayerResource:
    m_bHostageAlive = 0x4B0 # bool[12]
    m_isHostageFollowingSomeone = 0x4BC # bool[12]
    m_iHostageEntityIDs = 0x4C8 # CEntityIndex[12]
    m_bombsiteCenterA = 0x4F8 # Vector
    m_bombsiteCenterB = 0x504 # Vector
    m_hostageRescueX = 0x510 # int32_t[4]
    m_hostageRescueY = 0x520 # int32_t[4]
    m_hostageRescueZ = 0x530 # int32_t[4]
    m_bEndMatchNextMapAllVoted = 0x540 # bool
    m_foundGoalPositions = 0x541 # bool

class CCSPlayer_ActionTrackingServices:
    m_hLastWeaponBeforeC4AutoSwitch = 0x208 # CHandle<CBasePlayerWeapon>
    m_bIsRescuing = 0x23C # bool
    m_weaponPurchasesThisMatch = 0x240 # WeaponPurchaseTracker_t
    m_weaponPurchasesThisRound = 0x298 # WeaponPurchaseTracker_t

class CCSPlayer_BulletServices:
    m_totalHitsOnServer = 0x40 # int32_t

class CCSPlayer_BuyServices:
    m_vecSellbackPurchaseEntries = 0xC8 # CUtlVectorEmbeddedNetworkVar<SellbackPurchaseEntry_t>

class CCSPlayer_HostageServices:
    m_hCarriedHostage = 0x40 # CHandle<CBaseEntity>
    m_hCarriedHostageProp = 0x44 # CHandle<CBaseEntity>

class CCSPlayer_ItemServices:
    m_bHasDefuser = 0x40 # bool
    m_bHasHelmet = 0x41 # bool
    m_bHasHeavyArmor = 0x42 # bool

class CCSPlayer_MovementServices:
    m_flMaxFallVelocity = 0x220 # float
    m_vecLadderNormal = 0x224 # Vector
    m_nLadderSurfacePropIndex = 0x230 # int32_t
    m_flDuckAmount = 0x234 # float
    m_flDuckSpeed = 0x238 # float
    m_bDuckOverride = 0x23C # bool
    m_bDesiresDuck = 0x23D # bool
    m_flDuckOffset = 0x240 # float
    m_nDuckTimeMsecs = 0x244 # uint32_t
    m_nDuckJumpTimeMsecs = 0x248 # uint32_t
    m_nJumpTimeMsecs = 0x24C # uint32_t
    m_flLastDuckTime = 0x250 # float
    m_vecLastPositionAtFullCrouchSpeed = 0x260 # Vector2D
    m_duckUntilOnGround = 0x268 # bool
    m_bHasWalkMovedSinceLastJump = 0x269 # bool
    m_bInStuckTest = 0x26A # bool
    m_flStuckCheckTime = 0x278 # float[64][2]
    m_nTraceCount = 0x478 # int32_t
    m_StuckLast = 0x47C # int32_t
    m_bSpeedCropped = 0x480 # bool
    m_nOldWaterLevel = 0x484 # int32_t
    m_flWaterEntryTime = 0x488 # float
    m_vecForward = 0x48C # Vector
    m_vecLeft = 0x498 # Vector
    m_vecUp = 0x4A4 # Vector
    m_vecPreviouslyPredictedOrigin = 0x4B0 # Vector
    m_bMadeFootstepNoise = 0x4BC # bool
    m_iFootsteps = 0x4C0 # int32_t
    m_bOldJumpPressed = 0x4C4 # bool
    m_flJumpPressedTime = 0x4C8 # float
    m_flJumpUntil = 0x4CC # float
    m_flJumpVel = 0x4D0 # float
    m_fStashGrenadeParameterWhen = 0x4D4 # GameTime_t
    m_nButtonDownMaskPrev = 0x4D8 # uint64_t
    m_flOffsetTickCompleteTime = 0x4E0 # float
    m_flOffsetTickStashedSpeed = 0x4E4 # float
    m_flStamina = 0x4E8 # float
    m_flHeightAtJumpStart = 0x4EC # float
    m_flMaxJumpHeightThisJump = 0x4F0 # float

class CCSPlayer_PingServices:
    m_flPlayerPingTokens = 0x40 # GameTime_t[5]
    m_hPlayerPing = 0x54 # CHandle<CBaseEntity>

class CCSPlayer_RadioServices:
    m_flGotHostageTalkTimer = 0x40 # GameTime_t
    m_flDefusingTalkTimer = 0x44 # GameTime_t
    m_flC4PlantTalkTimer = 0x48 # GameTime_t
    m_flRadioTokenSlots = 0x4C # GameTime_t[3]
    m_bIgnoreRadio = 0x58 # bool

class CCSPlayer_UseServices:
    m_hLastKnownUseEntity = 0x40 # CHandle<CBaseEntity>
    m_flLastUseTimeStamp = 0x44 # GameTime_t
    m_flTimeStartedHoldingUse = 0x48 # GameTime_t
    m_flTimeLastUsedWindow = 0x4C # GameTime_t

class CCSPlayer_ViewModelServices:
    m_hViewModel = 0x40 # CHandle<CBaseViewModel>[3]

class CCSPlayer_WaterServices:
    m_NextDrownDamageTime = 0x40 # float
    m_nDrownDmgRate = 0x44 # int32_t
    m_AirFinishedTime = 0x48 # GameTime_t
    m_flWaterJumpTime = 0x4C # float
    m_vecWaterJumpVel = 0x50 # Vector
    m_flSwimSoundTime = 0x5C # float

class CCSPlayer_WeaponServices:
    m_flNextAttack = 0xB0 # GameTime_t
    m_bIsLookingAtWeapon = 0xB4 # bool
    m_bIsHoldingLookAtWeapon = 0xB5 # bool
    m_hSavedWeapon = 0xB8 # CHandle<CBasePlayerWeapon>
    m_nTimeToMelee = 0xBC # int32_t
    m_nTimeToSecondary = 0xC0 # int32_t
    m_nTimeToPrimary = 0xC4 # int32_t
    m_nTimeToSniperRifle = 0xC8 # int32_t
    m_bIsBeingGivenItem = 0xCC # bool
    m_bIsPickingUpItemWithUse = 0xCD # bool
    m_bPickedUpWeapon = 0xCE # bool

class CCSTeam:
    m_nLastRecievedShorthandedRoundBonus = 0x568 # int32_t
    m_nShorthandedRoundBonusStartRound = 0x56C # int32_t
    m_bSurrendered = 0x570 # bool
    m_szTeamMatchStat = 0x571 # char[512]
    m_numMapVictories = 0x774 # int32_t
    m_scoreFirstHalf = 0x778 # int32_t
    m_scoreSecondHalf = 0x77C # int32_t
    m_scoreOvertime = 0x780 # int32_t
    m_szClanTeamname = 0x784 # char[129]
    m_iClanID = 0x808 # uint32_t
    m_szTeamFlagImage = 0x80C # char[8]
    m_szTeamLogoImage = 0x814 # char[8]
    m_flNextResourceTime = 0x81C # float
    m_iLastUpdateSentAt = 0x820 # int32_t

class CCSWeaponBase:
    m_bRemoveable = 0xC88 # bool
    m_flFireSequenceStartTime = 0xC90 # float
    m_nFireSequenceStartTimeChange = 0xC94 # int32_t
    m_nFireSequenceStartTimeAck = 0xC98 # int32_t
    m_bPlayerFireEventIsPrimary = 0xC9C # bool
    m_seqIdle = 0xCA0 # HSequence
    m_seqFirePrimary = 0xCA4 # HSequence
    m_seqFireSecondary = 0xCA8 # HSequence
    m_thirdPersonFireSequences = 0xCB0 # CUtlVector<HSequence>
    m_hCurrentThirdPersonSequence = 0xCC8 # HSequence
    m_nSilencerBoneIndex = 0xCCC # int32_t
    m_thirdPersonSequences = 0xCD0 # HSequence[6]
    m_bPlayerAmmoStockOnPickup = 0xCF0 # bool
    m_bRequireUseToTouch = 0xCF1 # bool
    m_iState = 0xCF4 # CSWeaponState_t
    m_flLastTimeInAir = 0xCF8 # GameTime_t
    m_flLastDeployTime = 0xCFC # GameTime_t
    m_nViewModelIndex = 0xD00 # uint32_t
    m_bReloadsWithClips = 0xD04 # bool
    m_flTimeWeaponIdle = 0xD20 # GameTime_t
    m_bFireOnEmpty = 0xD24 # bool
    m_OnPlayerPickup = 0xD28 # CEntityIOOutput
    m_weaponMode = 0xD50 # CSWeaponMode
    m_flTurningInaccuracyDelta = 0xD54 # float
    m_vecTurningInaccuracyEyeDirLast = 0xD58 # Vector
    m_flTurningInaccuracy = 0xD64 # float
    m_fAccuracyPenalty = 0xD68 # float
    m_flLastAccuracyUpdateTime = 0xD6C # GameTime_t
    m_fAccuracySmoothedForZoom = 0xD70 # float
    m_fScopeZoomEndTime = 0xD74 # GameTime_t
    m_iRecoilIndex = 0xD78 # int32_t
    m_flRecoilIndex = 0xD7C # float
    m_bBurstMode = 0xD80 # bool
    m_flPostponeFireReadyTime = 0xD84 # GameTime_t
    m_bInReload = 0xD88 # bool
    m_bReloadVisuallyComplete = 0xD89 # bool
    m_flDroppedAtTime = 0xD8C # GameTime_t
    m_bIsHauledBack = 0xD90 # bool
    m_bSilencerOn = 0xD91 # bool
    m_flTimeSilencerSwitchComplete = 0xD94 # GameTime_t
    m_iOriginalTeamNumber = 0xD98 # int32_t
    m_flNextAttackRenderTimeOffset = 0xD9C # float
    m_bCanBePickedUp = 0xDB0 # bool
    m_bUseCanOverrideNextOwnerTouchTime = 0xDB1 # bool
    m_nextOwnerTouchTime = 0xDB4 # GameTime_t
    m_nextPrevOwnerTouchTime = 0xDB8 # GameTime_t
    m_hPrevOwner = 0xDBC # CHandle<CCSPlayerPawn>
    m_nDropTick = 0xDC0 # GameTick_t
    m_donated = 0xDE4 # bool
    m_fLastShotTime = 0xDE8 # GameTime_t
    m_bWasOwnedByCT = 0xDEC # bool
    m_bWasOwnedByTerrorist = 0xDED # bool
    m_bFiredOutOfAmmoEvent = 0xDEE # bool
    m_numRemoveUnownedWeaponThink = 0xDF0 # int32_t
    m_IronSightController = 0xDF8 # CIronSightController
    m_iIronSightMode = 0xE10 # int32_t
    m_flLastLOSTraceFailureTime = 0xE14 # GameTime_t
    m_iNumEmptyAttacks = 0xE18 # int32_t

class CCSWeaponBaseGun:
    m_zoomLevel = 0xE20 # int32_t
    m_iBurstShotsRemaining = 0xE24 # int32_t
    m_silencedModelIndex = 0xE30 # int32_t
    m_inPrecache = 0xE34 # bool
    m_bNeedsBoltAction = 0xE35 # bool
    m_bSkillReloadAvailable = 0xE36 # bool
    m_bSkillReloadLiftedReloadKey = 0xE37 # bool
    m_bSkillBoltInterruptAvailable = 0xE38 # bool
    m_bSkillBoltLiftedFireKey = 0xE39 # bool

class CCSWeaponBaseVData:
    m_WeaponType = 0x240 # CSWeaponType
    m_WeaponCategory = 0x244 # CSWeaponCategory
    m_szViewModel = 0x248 # CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    m_szPlayerModel = 0x328 # CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    m_szWorldDroppedModel = 0x408 # CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    m_szAimsightLensMaskModel = 0x4E8 # CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    m_szMagazineModel = 0x5C8 # CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    m_szHeatEffect = 0x6A8 # CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    m_szEjectBrassEffect = 0x788 # CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    m_szMuzzleFlashParticleAlt = 0x868 # CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    m_szMuzzleFlashThirdPersonParticle = 0x948 # CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    m_szMuzzleFlashThirdPersonParticleAlt = 0xA28 # CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    m_szTracerParticle = 0xB08 # CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    m_GearSlot = 0xBE8 # gear_slot_t
    m_GearSlotPosition = 0xBEC # int32_t
    m_DefaultLoadoutSlot = 0xBF0 # loadout_slot_t
    m_sWrongTeamMsg = 0xBF8 # CUtlString
    m_nPrice = 0xC00 # int32_t
    m_nKillAward = 0xC04 # int32_t
    m_nPrimaryReserveAmmoMax = 0xC08 # int32_t
    m_nSecondaryReserveAmmoMax = 0xC0C # int32_t
    m_bMeleeWeapon = 0xC10 # bool
    m_bHasBurstMode = 0xC11 # bool
    m_bIsRevolver = 0xC12 # bool
    m_bCannotShootUnderwater = 0xC13 # bool
    m_szName = 0xC18 # CUtlString
    m_szAnimExtension = 0xC20 # CUtlString
    m_eSilencerType = 0xC28 # CSWeaponSilencerType
    m_nCrosshairMinDistance = 0xC2C # int32_t
    m_nCrosshairDeltaDistance = 0xC30 # int32_t
    m_flCycleTime = 0xC34 # CFiringModeFloat
    m_flMaxSpeed = 0xC3C # CFiringModeFloat
    m_flSpread = 0xC44 # CFiringModeFloat
    m_flInaccuracyCrouch = 0xC4C # CFiringModeFloat
    m_flInaccuracyStand = 0xC54 # CFiringModeFloat
    m_flInaccuracyJump = 0xC5C # CFiringModeFloat
    m_flInaccuracyLand = 0xC64 # CFiringModeFloat
    m_flInaccuracyLadder = 0xC6C # CFiringModeFloat
    m_flInaccuracyFire = 0xC74 # CFiringModeFloat
    m_flInaccuracyMove = 0xC7C # CFiringModeFloat
    m_flRecoilAngle = 0xC84 # CFiringModeFloat
    m_flRecoilAngleVariance = 0xC8C # CFiringModeFloat
    m_flRecoilMagnitude = 0xC94 # CFiringModeFloat
    m_flRecoilMagnitudeVariance = 0xC9C # CFiringModeFloat
    m_nTracerFrequency = 0xCA4 # CFiringModeInt
    m_flInaccuracyJumpInitial = 0xCAC # float
    m_flInaccuracyJumpApex = 0xCB0 # float
    m_flInaccuracyReload = 0xCB4 # float
    m_nRecoilSeed = 0xCB8 # int32_t
    m_nSpreadSeed = 0xCBC # int32_t
    m_flTimeToIdleAfterFire = 0xCC0 # float
    m_flIdleInterval = 0xCC4 # float
    m_flAttackMovespeedFactor = 0xCC8 # float
    m_flHeatPerShot = 0xCCC # float
    m_flInaccuracyPitchShift = 0xCD0 # float
    m_flInaccuracyAltSoundThreshold = 0xCD4 # float
    m_flBotAudibleRange = 0xCD8 # float
    m_szUseRadioSubtitle = 0xCE0 # CUtlString
    m_bUnzoomsAfterShot = 0xCE8 # bool
    m_bHideViewModelWhenZoomed = 0xCE9 # bool
    m_nZoomLevels = 0xCEC # int32_t
    m_nZoomFOV1 = 0xCF0 # int32_t
    m_nZoomFOV2 = 0xCF4 # int32_t
    m_flZoomTime0 = 0xCF8 # float
    m_flZoomTime1 = 0xCFC # float
    m_flZoomTime2 = 0xD00 # float
    m_flIronSightPullUpSpeed = 0xD04 # float
    m_flIronSightPutDownSpeed = 0xD08 # float
    m_flIronSightFOV = 0xD0C # float
    m_flIronSightPivotForward = 0xD10 # float
    m_flIronSightLooseness = 0xD14 # float
    m_angPivotAngle = 0xD18 # QAngle
    m_vecIronSightEyePos = 0xD24 # Vector
    m_nDamage = 0xD30 # int32_t
    m_flHeadshotMultiplier = 0xD34 # float
    m_flArmorRatio = 0xD38 # float
    m_flPenetration = 0xD3C # float
    m_flRange = 0xD40 # float
    m_flRangeModifier = 0xD44 # float
    m_flFlinchVelocityModifierLarge = 0xD48 # float
    m_flFlinchVelocityModifierSmall = 0xD4C # float
    m_flRecoveryTimeCrouch = 0xD50 # float
    m_flRecoveryTimeStand = 0xD54 # float
    m_flRecoveryTimeCrouchFinal = 0xD58 # float
    m_flRecoveryTimeStandFinal = 0xD5C # float
    m_nRecoveryTransitionStartBullet = 0xD60 # int32_t
    m_nRecoveryTransitionEndBullet = 0xD64 # int32_t
    m_flThrowVelocity = 0xD68 # float
    m_vSmokeColor = 0xD6C # Vector
    m_szAnimClass = 0xD78 # CUtlString

class CChangeLevel:
    m_sMapName = 0x8A8 # CUtlString
    m_sLandmarkName = 0x8B0 # CUtlString
    m_OnChangeLevel = 0x8B8 # CEntityIOOutput
    m_bTouched = 0x8E0 # bool
    m_bNoTouch = 0x8E1 # bool
    m_bNewChapter = 0x8E2 # bool
    m_bOnChangeLevelFired = 0x8E3 # bool

class CChicken:
    m_AttributeManager = 0xB28 # CAttributeContainer
    m_OriginalOwnerXuidLow = 0xDF0 # uint32_t
    m_OriginalOwnerXuidHigh = 0xDF4 # uint32_t
    m_updateTimer = 0xDF8 # CountdownTimer
    m_stuckAnchor = 0xE10 # Vector
    m_stuckTimer = 0xE20 # CountdownTimer
    m_collisionStuckTimer = 0xE38 # CountdownTimer
    m_isOnGround = 0xE50 # bool
    m_vFallVelocity = 0xE54 # Vector
    m_activity = 0xE60 # ChickenActivity
    m_activityTimer = 0xE68 # CountdownTimer
    m_turnRate = 0xE80 # float
    m_fleeFrom = 0xE84 # CHandle<CBaseEntity>
    m_moveRateThrottleTimer = 0xE88 # CountdownTimer
    m_startleTimer = 0xEA0 # CountdownTimer
    m_vocalizeTimer = 0xEB8 # CountdownTimer
    m_flWhenZombified = 0xED0 # GameTime_t
    m_jumpedThisFrame = 0xED4 # bool
    m_leader = 0xED8 # CHandle<CCSPlayerPawn>
    m_reuseTimer = 0xEE0 # CountdownTimer
    m_hasBeenUsed = 0xEF8 # bool
    m_jumpTimer = 0xF00 # CountdownTimer
    m_flLastJumpTime = 0xF18 # float
    m_bInJump = 0xF1C # bool
    m_isWaitingForLeader = 0xF1D # bool
    m_repathTimer = 0x2F28 # CountdownTimer
    m_inhibitDoorTimer = 0x2F40 # CountdownTimer
    m_inhibitObstacleAvoidanceTimer = 0x2FD0 # CountdownTimer
    m_vecPathGoal = 0x2FF0 # Vector
    m_flActiveFollowStartTime = 0x2FFC # GameTime_t
    m_followMinuteTimer = 0x3000 # CountdownTimer
    m_vecLastEggPoopPosition = 0x3018 # Vector
    m_vecEggsPooped = 0x3028 # CUtlVector<CHandle<CBaseEntity>>
    m_BlockDirectionTimer = 0x3048 # CountdownTimer

class CCollisionProperty:
    m_collisionAttribute = 0x10 # VPhysicsCollisionAttribute_t
    m_vecMins = 0x40 # Vector
    m_vecMaxs = 0x4C # Vector
    m_usSolidFlags = 0x5A # uint8_t
    m_nSolidType = 0x5B # SolidType_t
    m_triggerBloat = 0x5C # uint8_t
    m_nSurroundType = 0x5D # SurroundingBoundsType_t
    m_CollisionGroup = 0x5E # uint8_t
    m_nEnablePhysics = 0x5F # uint8_t
    m_flBoundingRadius = 0x60 # float
    m_vecSpecifiedSurroundingMins = 0x64 # Vector
    m_vecSpecifiedSurroundingMaxs = 0x70 # Vector
    m_vecSurroundingMaxs = 0x7C # Vector
    m_vecSurroundingMins = 0x88 # Vector
    m_vCapsuleCenter1 = 0x94 # Vector
    m_vCapsuleCenter2 = 0xA0 # Vector
    m_flCapsuleRadius = 0xAC # float

class CColorCorrection:
    m_flFadeInDuration = 0x4B0 # float
    m_flFadeOutDuration = 0x4B4 # float
    m_flStartFadeInWeight = 0x4B8 # float
    m_flStartFadeOutWeight = 0x4BC # float
    m_flTimeStartFadeIn = 0x4C0 # GameTime_t
    m_flTimeStartFadeOut = 0x4C4 # GameTime_t
    m_flMaxWeight = 0x4C8 # float
    m_bStartDisabled = 0x4CC # bool
    m_bEnabled = 0x4CD # bool
    m_bMaster = 0x4CE # bool
    m_bClientSide = 0x4CF # bool
    m_bExclusive = 0x4D0 # bool
    m_MinFalloff = 0x4D4 # float
    m_MaxFalloff = 0x4D8 # float
    m_flCurWeight = 0x4DC # float
    m_netlookupFilename = 0x4E0 # char[512]
    m_lookupFilename = 0x6E0 # CUtlSymbolLarge

class CColorCorrectionVolume:
    m_bEnabled = 0x8A8 # bool
    m_MaxWeight = 0x8AC # float
    m_FadeDuration = 0x8B0 # float
    m_bStartDisabled = 0x8B4 # bool
    m_Weight = 0x8B8 # float
    m_lookupFilename = 0x8BC # char[512]
    m_LastEnterWeight = 0xABC # float
    m_LastEnterTime = 0xAC0 # GameTime_t
    m_LastExitWeight = 0xAC4 # float
    m_LastExitTime = 0xAC8 # GameTime_t

class CCommentaryAuto:
    m_OnCommentaryNewGame = 0x4B0 # CEntityIOOutput
    m_OnCommentaryMidGame = 0x4D8 # CEntityIOOutput
    m_OnCommentaryMultiplayerSpawn = 0x500 # CEntityIOOutput

class CCommentarySystem:
    m_bCommentaryConvarsChanging = 0x11 # bool
    m_bCommentaryEnabledMidGame = 0x12 # bool
    m_flNextTeleportTime = 0x14 # GameTime_t
    m_iTeleportStage = 0x18 # int32_t
    m_bCheatState = 0x1C # bool
    m_bIsFirstSpawnGroupToLoad = 0x1D # bool
    m_hCurrentNode = 0x38 # CHandle<CPointCommentaryNode>
    m_hActiveCommentaryNode = 0x3C # CHandle<CPointCommentaryNode>
    m_hLastCommentaryNode = 0x40 # CHandle<CPointCommentaryNode>
    m_vecNodes = 0x48 # CUtlVector<CHandle<CPointCommentaryNode>>

class CConstantForceController:
    m_linear = 0xC # Vector
    m_angular = 0x18 # RotationVector
    m_linearSave = 0x24 # Vector
    m_angularSave = 0x30 # RotationVector

class CConstraintAnchor:
    m_massScale = 0x890 # float

class CCopyRecipientFilter:
    m_Flags = 0x8 # int32_t
    m_Recipients = 0x10 # CUtlVector<CPlayerSlot>

class CCredits:
    m_OnCreditsDone = 0x4B0 # CEntityIOOutput
    m_bRolledOutroCredits = 0x4D8 # bool
    m_flLogoLength = 0x4DC # float

class CDamageRecord:
    m_PlayerDamager = 0x28 # CHandle<CCSPlayerPawnBase>
    m_PlayerRecipient = 0x2C # CHandle<CCSPlayerPawnBase>
    m_hPlayerControllerDamager = 0x30 # CHandle<CCSPlayerController>
    m_hPlayerControllerRecipient = 0x34 # CHandle<CCSPlayerController>
    m_szPlayerDamagerName = 0x38 # CUtlString
    m_szPlayerRecipientName = 0x40 # CUtlString
    m_DamagerXuid = 0x48 # uint64_t
    m_RecipientXuid = 0x50 # uint64_t
    m_iDamage = 0x58 # int32_t
    m_iActualHealthRemoved = 0x5C # int32_t
    m_iNumHits = 0x60 # int32_t
    m_iLastBulletUpdate = 0x64 # int32_t
    m_bIsOtherEnemy = 0x68 # bool
    m_killType = 0x69 # EKillTypes_t

class CDebugHistory:
    m_nNpcEvents = 0x44F0 # int32_t

class CDecoyProjectile:
    m_nDecoyShotTick = 0xA48 # int32_t
    m_shotsRemaining = 0xA4C # int32_t
    m_fExpireTime = 0xA50 # GameTime_t
    m_decoyWeaponDefIndex = 0xA60 # uint16_t

class CDynamicLight:
    m_ActualFlags = 0x700 # uint8_t
    m_Flags = 0x701 # uint8_t
    m_LightStyle = 0x702 # uint8_t
    m_On = 0x703 # bool
    m_Radius = 0x704 # float
    m_Exponent = 0x708 # int32_t
    m_InnerAngle = 0x70C # float
    m_OuterAngle = 0x710 # float
    m_SpotRadius = 0x714 # float

class CDynamicProp:
    m_bCreateNavObstacle = 0xA10 # bool
    m_bUseHitboxesForRenderBox = 0xA11 # bool
    m_bUseAnimGraph = 0xA12 # bool
    m_pOutputAnimBegun = 0xA18 # CEntityIOOutput
    m_pOutputAnimOver = 0xA40 # CEntityIOOutput
    m_pOutputAnimLoopCycleOver = 0xA68 # CEntityIOOutput
    m_OnAnimReachedStart = 0xA90 # CEntityIOOutput
    m_OnAnimReachedEnd = 0xAB8 # CEntityIOOutput
    m_iszDefaultAnim = 0xAE0 # CUtlSymbolLarge
    m_nDefaultAnimLoopMode = 0xAE8 # AnimLoopMode_t
    m_bAnimateOnServer = 0xAEC # bool
    m_bRandomizeCycle = 0xAED # bool
    m_bStartDisabled = 0xAEE # bool
    m_bScriptedMovement = 0xAEF # bool
    m_bFiredStartEndOutput = 0xAF0 # bool
    m_bForceNpcExclude = 0xAF1 # bool
    m_bCreateNonSolid = 0xAF2 # bool
    m_bIsOverrideProp = 0xAF3 # bool
    m_iInitialGlowState = 0xAF4 # int32_t
    m_nGlowRange = 0xAF8 # int32_t
    m_nGlowRangeMin = 0xAFC # int32_t
    m_glowColor = 0xB00 # Color
    m_nGlowTeam = 0xB04 # int32_t

class CEconEntity:
    m_AttributeManager = 0x930 # CAttributeContainer
    m_OriginalOwnerXuidLow = 0xBF8 # uint32_t
    m_OriginalOwnerXuidHigh = 0xBFC # uint32_t
    m_nFallbackPaintKit = 0xC00 # int32_t
    m_nFallbackSeed = 0xC04 # int32_t
    m_flFallbackWear = 0xC08 # float
    m_nFallbackStatTrak = 0xC0C # int32_t
    m_hOldProvidee = 0xC10 # CHandle<CBaseEntity>
    m_iOldOwnerClass = 0xC14 # int32_t

class CEconItemAttribute:
    m_iAttributeDefinitionIndex = 0x30 # uint16_t
    m_flValue = 0x34 # float
    m_flInitialValue = 0x38 # float
    m_nRefundableCurrency = 0x3C # int32_t
    m_bSetBonus = 0x40 # bool

class CEconItemView:
    m_iItemDefinitionIndex = 0x38 # uint16_t
    m_iEntityQuality = 0x3C # int32_t
    m_iEntityLevel = 0x40 # uint32_t
    m_iItemID = 0x48 # uint64_t
    m_iItemIDHigh = 0x50 # uint32_t
    m_iItemIDLow = 0x54 # uint32_t
    m_iAccountID = 0x58 # uint32_t
    m_iInventoryPosition = 0x5C # uint32_t
    m_bInitialized = 0x68 # bool
    m_AttributeList = 0x70 # CAttributeList
    m_NetworkedDynamicAttributes = 0xD0 # CAttributeList
    m_szCustomName = 0x130 # char[161]
    m_szCustomNameOverride = 0x1D1 # char[161]

class CEconWearable:
    m_nForceSkin = 0xC18 # int32_t
    m_bAlwaysAllow = 0xC1C # bool

class CEffectData:
    m_vOrigin = 0x8 # Vector
    m_vStart = 0x14 # Vector
    m_vNormal = 0x20 # Vector
    m_vAngles = 0x2C # QAngle
    m_hEntity = 0x38 # CEntityHandle
    m_hOtherEntity = 0x3C # CEntityHandle
    m_flScale = 0x40 # float
    m_flMagnitude = 0x44 # float
    m_flRadius = 0x48 # float
    m_nSurfaceProp = 0x4C # CUtlStringToken
    m_nEffectIndex = 0x50 # CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>
    m_nDamageType = 0x58 # uint32_t
    m_nPenetrate = 0x5C # uint8_t
    m_nMaterial = 0x5E # uint16_t
    m_nHitBox = 0x60 # uint16_t
    m_nColor = 0x62 # uint8_t
    m_fFlags = 0x63 # uint8_t
    m_nAttachmentIndex = 0x64 # AttachmentHandle_t
    m_nAttachmentName = 0x68 # CUtlStringToken
    m_iEffectName = 0x6C # uint16_t
    m_nExplosionType = 0x6E # uint8_t

class CEntityDissolve:
    m_flFadeInStart = 0x700 # float
    m_flFadeInLength = 0x704 # float
    m_flFadeOutModelStart = 0x708 # float
    m_flFadeOutModelLength = 0x70C # float
    m_flFadeOutStart = 0x710 # float
    m_flFadeOutLength = 0x714 # float
    m_flStartTime = 0x718 # GameTime_t
    m_nDissolveType = 0x71C # EntityDisolveType_t
    m_vDissolverOrigin = 0x720 # Vector
    m_nMagnitude = 0x72C # uint32_t

class CEntityFlame:
    m_hEntAttached = 0x4B0 # CHandle<CBaseEntity>
    m_bCheapEffect = 0x4B4 # bool
    m_flSize = 0x4B8 # float
    m_bUseHitboxes = 0x4BC # bool
    m_iNumHitboxFires = 0x4C0 # int32_t
    m_flHitboxFireScale = 0x4C4 # float
    m_flLifetime = 0x4C8 # GameTime_t
    m_hAttacker = 0x4CC # CHandle<CBaseEntity>
    m_iDangerSound = 0x4D0 # int32_t
    m_flDirectDamagePerSecond = 0x4D4 # float
    m_iCustomDamageType = 0x4D8 # int32_t

class CEntityIdentity:
    m_nameStringableIndex = 0x14 # int32_t
    m_name = 0x18 # CUtlSymbolLarge
    m_designerName = 0x20 # CUtlSymbolLarge
    m_flags = 0x30 # uint32_t
    m_worldGroupId = 0x38 # WorldGroupId_t
    m_fDataObjectTypes = 0x3C # uint32_t
    m_PathIndex = 0x40 # ChangeAccessorFieldPathIndex_t
    m_pPrev = 0x58 # CEntityIdentity*
    m_pNext = 0x60 # CEntityIdentity*
    m_pPrevByClass = 0x68 # CEntityIdentity*
    m_pNextByClass = 0x70 # CEntityIdentity*

class CEntityInstance:
    m_iszPrivateVScripts = 0x8 # CUtlSymbolLarge
    m_pEntity = 0x10 # CEntityIdentity*
    m_CScriptComponent = 0x28 # CScriptComponent*

class CEnvBeam:
    m_active = 0x7A0 # int32_t
    m_spriteTexture = 0x7A8 # CStrongHandle<InfoForResourceTypeIMaterial2>
    m_iszStartEntity = 0x7B0 # CUtlSymbolLarge
    m_iszEndEntity = 0x7B8 # CUtlSymbolLarge
    m_life = 0x7C0 # float
    m_boltWidth = 0x7C4 # float
    m_noiseAmplitude = 0x7C8 # float
    m_speed = 0x7CC # int32_t
    m_restrike = 0x7D0 # float
    m_iszSpriteName = 0x7D8 # CUtlSymbolLarge
    m_frameStart = 0x7E0 # int32_t
    m_vEndPointWorld = 0x7E4 # Vector
    m_vEndPointRelative = 0x7F0 # Vector
    m_radius = 0x7FC # float
    m_TouchType = 0x800 # Touch_t
    m_iFilterName = 0x808 # CUtlSymbolLarge
    m_hFilter = 0x810 # CHandle<CBaseEntity>
    m_iszDecal = 0x818 # CUtlSymbolLarge
    m_OnTouchedByEntity = 0x820 # CEntityIOOutput

class CEnvBeverage:
    m_CanInDispenser = 0x4B0 # bool
    m_nBeverageType = 0x4B4 # int32_t

class CEnvCombinedLightProbeVolume:
    m_Color = 0x1508 # Color
    m_flBrightness = 0x150C # float
    m_hCubemapTexture = 0x1510 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_bCustomCubemapTexture = 0x1518 # bool
    m_hLightProbeTexture = 0x1520 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_hLightProbeDirectLightIndicesTexture = 0x1528 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_hLightProbeDirectLightScalarsTexture = 0x1530 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_hLightProbeDirectLightShadowsTexture = 0x1538 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_vBoxMins = 0x1540 # Vector
    m_vBoxMaxs = 0x154C # Vector
    m_bMoveable = 0x1558 # bool
    m_nHandshake = 0x155C # int32_t
    m_nEnvCubeMapArrayIndex = 0x1560 # int32_t
    m_nPriority = 0x1564 # int32_t
    m_bStartDisabled = 0x1568 # bool
    m_flEdgeFadeDist = 0x156C # float
    m_vEdgeFadeDists = 0x1570 # Vector
    m_nLightProbeSizeX = 0x157C # int32_t
    m_nLightProbeSizeY = 0x1580 # int32_t
    m_nLightProbeSizeZ = 0x1584 # int32_t
    m_nLightProbeAtlasX = 0x1588 # int32_t
    m_nLightProbeAtlasY = 0x158C # int32_t
    m_nLightProbeAtlasZ = 0x1590 # int32_t
    m_bEnabled = 0x15A9 # bool

class CEnvCubemap:
    m_hCubemapTexture = 0x530 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_bCustomCubemapTexture = 0x538 # bool
    m_flInfluenceRadius = 0x53C # float
    m_vBoxProjectMins = 0x540 # Vector
    m_vBoxProjectMaxs = 0x54C # Vector
    m_bMoveable = 0x558 # bool
    m_nHandshake = 0x55C # int32_t
    m_nEnvCubeMapArrayIndex = 0x560 # int32_t
    m_nPriority = 0x564 # int32_t
    m_flEdgeFadeDist = 0x568 # float
    m_vEdgeFadeDists = 0x56C # Vector
    m_flDiffuseScale = 0x578 # float
    m_bStartDisabled = 0x57C # bool
    m_bDefaultEnvMap = 0x57D # bool
    m_bDefaultSpecEnvMap = 0x57E # bool
    m_bIndoorCubeMap = 0x57F # bool
    m_bCopyDiffuseFromDefaultCubemap = 0x580 # bool
    m_bEnabled = 0x590 # bool

class CEnvCubemapFog:
    m_flEndDistance = 0x4B0 # float
    m_flStartDistance = 0x4B4 # float
    m_flFogFalloffExponent = 0x4B8 # float
    m_bHeightFogEnabled = 0x4BC # bool
    m_flFogHeightWidth = 0x4C0 # float
    m_flFogHeightEnd = 0x4C4 # float
    m_flFogHeightStart = 0x4C8 # float
    m_flFogHeightExponent = 0x4CC # float
    m_flLODBias = 0x4D0 # float
    m_bActive = 0x4D4 # bool
    m_bStartDisabled = 0x4D5 # bool
    m_flFogMaxOpacity = 0x4D8 # float
    m_nCubemapSourceType = 0x4DC # int32_t
    m_hSkyMaterial = 0x4E0 # CStrongHandle<InfoForResourceTypeIMaterial2>
    m_iszSkyEntity = 0x4E8 # CUtlSymbolLarge
    m_hFogCubemapTexture = 0x4F0 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_bHasHeightFogEnd = 0x4F8 # bool
    m_bFirstTime = 0x4F9 # bool

class CEnvDecal:
    m_hDecalMaterial = 0x700 # CStrongHandle<InfoForResourceTypeIMaterial2>
    m_flWidth = 0x708 # float
    m_flHeight = 0x70C # float
    m_flDepth = 0x710 # float
    m_nRenderOrder = 0x714 # uint32_t
    m_bProjectOnWorld = 0x718 # bool
    m_bProjectOnCharacters = 0x719 # bool
    m_bProjectOnWater = 0x71A # bool
    m_flDepthSortBias = 0x71C # float

class CEnvDetailController:
    m_flFadeStartDist = 0x4B0 # float
    m_flFadeEndDist = 0x4B4 # float

class CEnvEntityIgniter:
    m_flLifetime = 0x4B0 # float

class CEnvEntityMaker:
    m_vecEntityMins = 0x4B0 # Vector
    m_vecEntityMaxs = 0x4BC # Vector
    m_hCurrentInstance = 0x4C8 # CHandle<CBaseEntity>
    m_hCurrentBlocker = 0x4CC # CHandle<CBaseEntity>
    m_vecBlockerOrigin = 0x4D0 # Vector
    m_angPostSpawnDirection = 0x4DC # QAngle
    m_flPostSpawnDirectionVariance = 0x4E8 # float
    m_flPostSpawnSpeed = 0x4EC # float
    m_bPostSpawnUseAngles = 0x4F0 # bool
    m_iszTemplate = 0x4F8 # CUtlSymbolLarge
    m_pOutputOnSpawned = 0x500 # CEntityIOOutput
    m_pOutputOnFailedSpawn = 0x528 # CEntityIOOutput

class CEnvExplosion:
    m_iMagnitude = 0x700 # int32_t
    m_flPlayerDamage = 0x704 # float
    m_iRadiusOverride = 0x708 # int32_t
    m_flInnerRadius = 0x70C # float
    m_spriteScale = 0x710 # int32_t
    m_flDamageForce = 0x714 # float
    m_hInflictor = 0x718 # CHandle<CBaseEntity>
    m_iCustomDamageType = 0x71C # int32_t
    m_iszExplosionType = 0x728 # CUtlSymbolLarge
    m_iszCustomEffectName = 0x730 # CUtlSymbolLarge
    m_iszCustomSoundName = 0x738 # CUtlSymbolLarge
    m_iClassIgnore = 0x740 # Class_T
    m_iClassIgnore2 = 0x744 # Class_T
    m_iszEntityIgnoreName = 0x748 # CUtlSymbolLarge
    m_hEntityIgnore = 0x750 # CHandle<CBaseEntity>

class CEnvFade:
    m_fadeColor = 0x4B0 # Color
    m_Duration = 0x4B4 # float
    m_HoldDuration = 0x4B8 # float
    m_OnBeginFade = 0x4C0 # CEntityIOOutput

class CEnvFireSensor:
    m_bEnabled = 0x4B0 # bool
    m_bHeatAtLevel = 0x4B1 # bool
    m_radius = 0x4B4 # float
    m_targetLevel = 0x4B8 # float
    m_targetTime = 0x4BC # float
    m_levelTime = 0x4C0 # float
    m_OnHeatLevelStart = 0x4C8 # CEntityIOOutput
    m_OnHeatLevelEnd = 0x4F0 # CEntityIOOutput

class CEnvFireSource:
    m_bEnabled = 0x4B0 # bool
    m_radius = 0x4B4 # float
    m_damage = 0x4B8 # float

class CEnvGlobal:
    m_outCounter = 0x4B0 # CEntityOutputTemplate<int32_t>
    m_globalstate = 0x4D8 # CUtlSymbolLarge
    m_triggermode = 0x4E0 # int32_t
    m_initialstate = 0x4E4 # int32_t
    m_counter = 0x4E8 # int32_t

class CEnvHudHint:
    m_iszMessage = 0x4B0 # CUtlSymbolLarge

class CEnvInstructorHint:
    m_iszName = 0x4B0 # CUtlSymbolLarge
    m_iszReplace_Key = 0x4B8 # CUtlSymbolLarge
    m_iszHintTargetEntity = 0x4C0 # CUtlSymbolLarge
    m_iTimeout = 0x4C8 # int32_t
    m_iDisplayLimit = 0x4CC # int32_t
    m_iszIcon_Onscreen = 0x4D0 # CUtlSymbolLarge
    m_iszIcon_Offscreen = 0x4D8 # CUtlSymbolLarge
    m_iszCaption = 0x4E0 # CUtlSymbolLarge
    m_iszActivatorCaption = 0x4E8 # CUtlSymbolLarge
    m_Color = 0x4F0 # Color
    m_fIconOffset = 0x4F4 # float
    m_fRange = 0x4F8 # float
    m_iPulseOption = 0x4FC # uint8_t
    m_iAlphaOption = 0x4FD # uint8_t
    m_iShakeOption = 0x4FE # uint8_t
    m_bStatic = 0x4FF # bool
    m_bNoOffscreen = 0x500 # bool
    m_bForceCaption = 0x501 # bool
    m_iInstanceType = 0x504 # int32_t
    m_bSuppressRest = 0x508 # bool
    m_iszBinding = 0x510 # CUtlSymbolLarge
    m_bAllowNoDrawTarget = 0x518 # bool
    m_bAutoStart = 0x519 # bool
    m_bLocalPlayerOnly = 0x51A # bool

class CEnvInstructorVRHint:
    m_iszName = 0x4B0 # CUtlSymbolLarge
    m_iszHintTargetEntity = 0x4B8 # CUtlSymbolLarge
    m_iTimeout = 0x4C0 # int32_t
    m_iszCaption = 0x4C8 # CUtlSymbolLarge
    m_iszStartSound = 0x4D0 # CUtlSymbolLarge
    m_iLayoutFileType = 0x4D8 # int32_t
    m_iszCustomLayoutFile = 0x4E0 # CUtlSymbolLarge
    m_iAttachType = 0x4E8 # int32_t
    m_flHeightOffset = 0x4EC # float

class CEnvLaser:
    m_iszLaserTarget = 0x7A0 # CUtlSymbolLarge
    m_pSprite = 0x7A8 # CSprite*
    m_iszSpriteName = 0x7B0 # CUtlSymbolLarge
    m_firePosition = 0x7B8 # Vector
    m_flStartFrame = 0x7C4 # float

class CEnvLightProbeVolume:
    m_hLightProbeTexture = 0x1488 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_hLightProbeDirectLightIndicesTexture = 0x1490 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_hLightProbeDirectLightScalarsTexture = 0x1498 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_hLightProbeDirectLightShadowsTexture = 0x14A0 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_vBoxMins = 0x14A8 # Vector
    m_vBoxMaxs = 0x14B4 # Vector
    m_bMoveable = 0x14C0 # bool
    m_nHandshake = 0x14C4 # int32_t
    m_nPriority = 0x14C8 # int32_t
    m_bStartDisabled = 0x14CC # bool
    m_nLightProbeSizeX = 0x14D0 # int32_t
    m_nLightProbeSizeY = 0x14D4 # int32_t
    m_nLightProbeSizeZ = 0x14D8 # int32_t
    m_nLightProbeAtlasX = 0x14DC # int32_t
    m_nLightProbeAtlasY = 0x14E0 # int32_t
    m_nLightProbeAtlasZ = 0x14E4 # int32_t
    m_bEnabled = 0x14F1 # bool

class CEnvMicrophone:
    m_bDisabled = 0x4B0 # bool
    m_hMeasureTarget = 0x4B4 # CHandle<CBaseEntity>
    m_nSoundMask = 0x4B8 # int32_t
    m_flSensitivity = 0x4BC # float
    m_flSmoothFactor = 0x4C0 # float
    m_flMaxRange = 0x4C4 # float
    m_iszSpeakerName = 0x4C8 # CUtlSymbolLarge
    m_hSpeaker = 0x4D0 # CHandle<CBaseEntity>
    m_bAvoidFeedback = 0x4D4 # bool
    m_iSpeakerDSPPreset = 0x4D8 # int32_t
    m_iszListenFilter = 0x4E0 # CUtlSymbolLarge
    m_hListenFilter = 0x4E8 # CHandle<CBaseFilter>
    m_SoundLevel = 0x4F0 # CEntityOutputTemplate<float>
    m_OnRoutedSound = 0x518 # CEntityIOOutput
    m_OnHeardSound = 0x540 # CEntityIOOutput
    m_szLastSound = 0x568 # char[256]
    m_iLastRoutedFrame = 0x668 # int32_t

class CEnvMuzzleFlash:
    m_flScale = 0x4B0 # float
    m_iszParentAttachment = 0x4B8 # CUtlSymbolLarge

class CEnvParticleGlow:
    m_flAlphaScale = 0xC78 # float
    m_flRadiusScale = 0xC7C # float
    m_flSelfIllumScale = 0xC80 # float
    m_ColorTint = 0xC84 # Color
    m_hTextureOverride = 0xC88 # CStrongHandle<InfoForResourceTypeCTextureBase>

class CEnvProjectedTexture:
    m_hTargetEntity = 0x700 # CHandle<CBaseEntity>
    m_bState = 0x704 # bool
    m_bAlwaysUpdate = 0x705 # bool
    m_flLightFOV = 0x708 # float
    m_bEnableShadows = 0x70C # bool
    m_bSimpleProjection = 0x70D # bool
    m_bLightOnlyTarget = 0x70E # bool
    m_bLightWorld = 0x70F # bool
    m_bCameraSpace = 0x710 # bool
    m_flBrightnessScale = 0x714 # float
    m_LightColor = 0x718 # Color
    m_flIntensity = 0x71C # float
    m_flLinearAttenuation = 0x720 # float
    m_flQuadraticAttenuation = 0x724 # float
    m_bVolumetric = 0x728 # bool
    m_flNoiseStrength = 0x72C # float
    m_flFlashlightTime = 0x730 # float
    m_nNumPlanes = 0x734 # uint32_t
    m_flPlaneOffset = 0x738 # float
    m_flVolumetricIntensity = 0x73C # float
    m_flColorTransitionTime = 0x740 # float
    m_flAmbient = 0x744 # float
    m_SpotlightTextureName = 0x748 # char[512]
    m_nSpotlightTextureFrame = 0x948 # int32_t
    m_nShadowQuality = 0x94C # uint32_t
    m_flNearZ = 0x950 # float
    m_flFarZ = 0x954 # float
    m_flProjectionSize = 0x958 # float
    m_flRotation = 0x95C # float
    m_bFlipHorizontal = 0x960 # bool

class CEnvScreenOverlay:
    m_iszOverlayNames = 0x4B0 # CUtlSymbolLarge[10]
    m_flOverlayTimes = 0x500 # float[10]
    m_flStartTime = 0x528 # GameTime_t
    m_iDesiredOverlay = 0x52C # int32_t
    m_bIsActive = 0x530 # bool

class CEnvShake:
    m_limitToEntity = 0x4B0 # CUtlSymbolLarge
    m_Amplitude = 0x4B8 # float
    m_Frequency = 0x4BC # float
    m_Duration = 0x4C0 # float
    m_Radius = 0x4C4 # float
    m_stopTime = 0x4C8 # GameTime_t
    m_nextShake = 0x4CC # GameTime_t
    m_currentAmp = 0x4D0 # float
    m_maxForce = 0x4D4 # Vector
    m_shakeCallback = 0x4E8 # CPhysicsShake

class CEnvSky:
    m_hSkyMaterial = 0x700 # CStrongHandle<InfoForResourceTypeIMaterial2>
    m_hSkyMaterialLightingOnly = 0x708 # CStrongHandle<InfoForResourceTypeIMaterial2>
    m_bStartDisabled = 0x710 # bool
    m_vTintColor = 0x711 # Color
    m_vTintColorLightingOnly = 0x715 # Color
    m_flBrightnessScale = 0x71C # float
    m_nFogType = 0x720 # int32_t
    m_flFogMinStart = 0x724 # float
    m_flFogMinEnd = 0x728 # float
    m_flFogMaxStart = 0x72C # float
    m_flFogMaxEnd = 0x730 # float
    m_bEnabled = 0x734 # bool

class CEnvSoundscape:
    m_OnPlay = 0x4B0 # CEntityIOOutput
    m_flRadius = 0x4D8 # float
    m_soundscapeName = 0x4E0 # CUtlSymbolLarge
    m_soundEventName = 0x4E8 # CUtlSymbolLarge
    m_bOverrideWithEvent = 0x4F0 # bool
    m_soundscapeIndex = 0x4F4 # int32_t
    m_soundscapeEntityListId = 0x4F8 # int32_t
    m_soundEventHash = 0x4FC # uint32_t
    m_positionNames = 0x500 # CUtlSymbolLarge[8]
    m_hProxySoundscape = 0x540 # CHandle<CEnvSoundscape>
    m_bDisabled = 0x544 # bool

class CEnvSoundscapeProxy:
    m_MainSoundscapeName = 0x548 # CUtlSymbolLarge

class CEnvSpark:
    m_flDelay = 0x4B0 # float
    m_nMagnitude = 0x4B4 # int32_t
    m_nTrailLength = 0x4B8 # int32_t
    m_nType = 0x4BC # int32_t
    m_OnSpark = 0x4C0 # CEntityIOOutput

class CEnvSplash:
    m_flScale = 0x4B0 # float

class CEnvTilt:
    m_Duration = 0x4B0 # float
    m_Radius = 0x4B4 # float
    m_TiltTime = 0x4B8 # float
    m_stopTime = 0x4BC # GameTime_t

class CEnvTracer:
    m_vecEnd = 0x4B0 # Vector
    m_flDelay = 0x4BC # float

class CEnvViewPunch:
    m_flRadius = 0x4B0 # float
    m_angViewPunch = 0x4B4 # QAngle

class CEnvVolumetricFogController:
    m_flScattering = 0x4B0 # float
    m_flAnisotropy = 0x4B4 # float
    m_flFadeSpeed = 0x4B8 # float
    m_flDrawDistance = 0x4BC # float
    m_flFadeInStart = 0x4C0 # float
    m_flFadeInEnd = 0x4C4 # float
    m_flIndirectStrength = 0x4C8 # float
    m_nIndirectTextureDimX = 0x4CC # int32_t
    m_nIndirectTextureDimY = 0x4D0 # int32_t
    m_nIndirectTextureDimZ = 0x4D4 # int32_t
    m_vBoxMins = 0x4D8 # Vector
    m_vBoxMaxs = 0x4E4 # Vector
    m_bActive = 0x4F0 # bool
    m_flStartAnisoTime = 0x4F4 # GameTime_t
    m_flStartScatterTime = 0x4F8 # GameTime_t
    m_flStartDrawDistanceTime = 0x4FC # GameTime_t
    m_flStartAnisotropy = 0x500 # float
    m_flStartScattering = 0x504 # float
    m_flStartDrawDistance = 0x508 # float
    m_flDefaultAnisotropy = 0x50C # float
    m_flDefaultScattering = 0x510 # float
    m_flDefaultDrawDistance = 0x514 # float
    m_bStartDisabled = 0x518 # bool
    m_bEnableIndirect = 0x519 # bool
    m_bIsMaster = 0x51A # bool
    m_hFogIndirectTexture = 0x520 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_nForceRefreshCount = 0x528 # int32_t
    m_bFirstTime = 0x52C # bool

class CEnvVolumetricFogVolume:
    m_bActive = 0x4B0 # bool
    m_vBoxMins = 0x4B4 # Vector
    m_vBoxMaxs = 0x4C0 # Vector
    m_bStartDisabled = 0x4CC # bool
    m_flStrength = 0x4D0 # float
    m_nFalloffShape = 0x4D4 # int32_t
    m_flFalloffExponent = 0x4D8 # float

class CEnvWind:
    m_EnvWindShared = 0x4B0 # CEnvWindShared

class CEnvWindShared:
    m_flStartTime = 0x8 # GameTime_t
    m_iWindSeed = 0xC # uint32_t
    m_iMinWind = 0x10 # uint16_t
    m_iMaxWind = 0x12 # uint16_t
    m_windRadius = 0x14 # int32_t
    m_iMinGust = 0x18 # uint16_t
    m_iMaxGust = 0x1A # uint16_t
    m_flMinGustDelay = 0x1C # float
    m_flMaxGustDelay = 0x20 # float
    m_flGustDuration = 0x24 # float
    m_iGustDirChange = 0x28 # uint16_t
    m_location = 0x2C # Vector
    m_iszGustSound = 0x38 # int32_t
    m_iWindDir = 0x3C # int32_t
    m_flWindSpeed = 0x40 # float
    m_currentWindVector = 0x44 # Vector
    m_CurrentSwayVector = 0x50 # Vector
    m_PrevSwayVector = 0x5C # Vector
    m_iInitialWindDir = 0x68 # uint16_t
    m_flInitialWindSpeed = 0x6C # float
    m_OnGustStart = 0x70 # CEntityIOOutput
    m_OnGustEnd = 0x98 # CEntityIOOutput
    m_flVariationTime = 0xC0 # GameTime_t
    m_flSwayTime = 0xC4 # GameTime_t
    m_flSimTime = 0xC8 # GameTime_t
    m_flSwitchTime = 0xCC # GameTime_t
    m_flAveWindSpeed = 0xD0 # float
    m_bGusting = 0xD4 # bool
    m_flWindAngleVariation = 0xD8 # float
    m_flWindSpeedVariation = 0xDC # float
    m_iEntIndex = 0xE0 # CEntityIndex

class CEnvWindShared_WindAveEvent_t:
    m_flStartWindSpeed = 0x0 # float
    m_flAveWindSpeed = 0x4 # float

class CEnvWindShared_WindVariationEvent_t:
    m_flWindAngleVariation = 0x0 # float
    m_flWindSpeedVariation = 0x4 # float

class CFilterAttributeInt:
    m_sAttributeName = 0x508 # CUtlStringToken

class CFilterClass:
    m_iFilterClass = 0x508 # CUtlSymbolLarge

class CFilterContext:
    m_iFilterContext = 0x508 # CUtlSymbolLarge

class CFilterEnemy:
    m_iszEnemyName = 0x508 # CUtlSymbolLarge
    m_flRadius = 0x510 # float
    m_flOuterRadius = 0x514 # float
    m_nMaxSquadmatesPerEnemy = 0x518 # int32_t
    m_iszPlayerName = 0x520 # CUtlSymbolLarge

class CFilterMassGreater:
    m_fFilterMass = 0x508 # float

class CFilterModel:
    m_iFilterModel = 0x508 # CUtlSymbolLarge

class CFilterMultiple:
    m_nFilterType = 0x508 # filter_t
    m_iFilterName = 0x510 # CUtlSymbolLarge[10]
    m_hFilter = 0x560 # CHandle<CBaseEntity>[10]
    m_nFilterCount = 0x588 # int32_t

class CFilterName:
    m_iFilterName = 0x508 # CUtlSymbolLarge

class CFilterProximity:
    m_flRadius = 0x508 # float

class CFire:
    m_hEffect = 0x700 # CHandle<CBaseFire>
    m_hOwner = 0x704 # CHandle<CBaseEntity>
    m_nFireType = 0x708 # int32_t
    m_flFuel = 0x70C # float
    m_flDamageTime = 0x710 # GameTime_t
    m_lastDamage = 0x714 # GameTime_t
    m_flFireSize = 0x718 # float
    m_flLastNavUpdateTime = 0x71C # GameTime_t
    m_flHeatLevel = 0x720 # float
    m_flHeatAbsorb = 0x724 # float
    m_flDamageScale = 0x728 # float
    m_flMaxHeat = 0x72C # float
    m_flLastHeatLevel = 0x730 # float
    m_flAttackTime = 0x734 # float
    m_bEnabled = 0x738 # bool
    m_bStartDisabled = 0x739 # bool
    m_bDidActivate = 0x73A # bool
    m_OnIgnited = 0x740 # CEntityIOOutput
    m_OnExtinguished = 0x768 # CEntityIOOutput

class CFireSmoke:
    m_nFlameModelIndex = 0x4C0 # int32_t
    m_nFlameFromAboveModelIndex = 0x4C4 # int32_t

class CFiringModeFloat:
    m_flValues = 0x0 # float[2]

class CFiringModeInt:
    m_nValues = 0x0 # int32_t[2]

class CFish:
    m_pool = 0x890 # CHandle<CFishPool>
    m_id = 0x894 # uint32_t
    m_x = 0x898 # float
    m_y = 0x89C # float
    m_z = 0x8A0 # float
    m_angle = 0x8A4 # float
    m_angleChange = 0x8A8 # float
    m_forward = 0x8AC # Vector
    m_perp = 0x8B8 # Vector
    m_poolOrigin = 0x8C4 # Vector
    m_waterLevel = 0x8D0 # float
    m_speed = 0x8D4 # float
    m_desiredSpeed = 0x8D8 # float
    m_calmSpeed = 0x8DC # float
    m_panicSpeed = 0x8E0 # float
    m_avoidRange = 0x8E4 # float
    m_turnTimer = 0x8E8 # CountdownTimer
    m_turnClockwise = 0x900 # bool
    m_goTimer = 0x908 # CountdownTimer
    m_moveTimer = 0x920 # CountdownTimer
    m_panicTimer = 0x938 # CountdownTimer
    m_disperseTimer = 0x950 # CountdownTimer
    m_proximityTimer = 0x968 # CountdownTimer
    m_visible = 0x980 # CUtlVector<CFish*>

class CFishPool:
    m_fishCount = 0x4C0 # int32_t
    m_maxRange = 0x4C4 # float
    m_swimDepth = 0x4C8 # float
    m_waterLevel = 0x4CC # float
    m_isDormant = 0x4D0 # bool
    m_fishes = 0x4D8 # CUtlVector<CHandle<CFish>>
    m_visTimer = 0x4F0 # CountdownTimer

class CFists:
    m_bPlayingUninterruptableAct = 0xE20 # bool
    m_nUninterruptableActivity = 0xE24 # PlayerAnimEvent_t
    m_bRestorePrevWep = 0xE28 # bool
    m_hWeaponBeforePrevious = 0xE2C # CHandle<CBasePlayerWeapon>
    m_hWeaponPrevious = 0xE30 # CHandle<CBasePlayerWeapon>
    m_bDelayedHardPunchIncoming = 0xE34 # bool
    m_bDestroyAfterTaunt = 0xE35 # bool

class CFlashbangProjectile:
    m_flTimeToDetonate = 0xA40 # float
    m_numOpponentsHit = 0xA44 # uint8_t
    m_numTeammatesHit = 0xA45 # uint8_t

class CFogController:
    m_fog = 0x4B0 # fogparams_t
    m_bUseAngles = 0x518 # bool
    m_iChangedVariables = 0x51C # int32_t

class CFogTrigger:
    m_fog = 0x8A8 # fogparams_t

class CFogVolume:
    m_fogName = 0x700 # CUtlSymbolLarge
    m_postProcessName = 0x708 # CUtlSymbolLarge
    m_colorCorrectionName = 0x710 # CUtlSymbolLarge
    m_bDisabled = 0x720 # bool
    m_bInFogVolumesList = 0x721 # bool

class CFootstepControl:
    m_source = 0x8A8 # CUtlSymbolLarge
    m_destination = 0x8B0 # CUtlSymbolLarge

class CFuncBrush:
    m_iSolidity = 0x700 # BrushSolidities_e
    m_iDisabled = 0x704 # int32_t
    m_bSolidBsp = 0x708 # bool
    m_iszExcludedClass = 0x710 # CUtlSymbolLarge
    m_bInvertExclusion = 0x718 # bool
    m_bScriptedMovement = 0x719 # bool

class CFuncConveyor:
    m_szConveyorModels = 0x700 # CUtlSymbolLarge
    m_flTransitionDurationSeconds = 0x708 # float
    m_angMoveEntitySpace = 0x70C # QAngle
    m_vecMoveDirEntitySpace = 0x718 # Vector
    m_flTargetSpeed = 0x724 # float
    m_nTransitionStartTick = 0x728 # GameTick_t
    m_nTransitionDurationTicks = 0x72C # int32_t
    m_flTransitionStartSpeed = 0x730 # float
    m_hConveyorModels = 0x738 # CNetworkUtlVectorBase<CHandle<CBaseEntity>>

class CFuncElectrifiedVolume:
    m_EffectName = 0x720 # CUtlSymbolLarge
    m_EffectInterpenetrateName = 0x728 # CUtlSymbolLarge
    m_EffectZapName = 0x730 # CUtlSymbolLarge
    m_iszEffectSource = 0x738 # CUtlSymbolLarge

class CFuncInteractionLayerClip:
    m_bDisabled = 0x700 # bool
    m_iszInteractsAs = 0x708 # CUtlSymbolLarge
    m_iszInteractsWith = 0x710 # CUtlSymbolLarge

class CFuncLadder:
    m_vecLadderDir = 0x700 # Vector
    m_Dismounts = 0x710 # CUtlVector<CHandle<CInfoLadderDismount>>
    m_vecLocalTop = 0x728 # Vector
    m_vecPlayerMountPositionTop = 0x734 # Vector
    m_vecPlayerMountPositionBottom = 0x740 # Vector
    m_flAutoRideSpeed = 0x74C # float
    m_bDisabled = 0x750 # bool
    m_bFakeLadder = 0x751 # bool
    m_bHasSlack = 0x752 # bool
    m_surfacePropName = 0x758 # CUtlSymbolLarge
    m_OnPlayerGotOnLadder = 0x760 # CEntityIOOutput
    m_OnPlayerGotOffLadder = 0x788 # CEntityIOOutput

class CFuncMonitor:
    m_targetCamera = 0x720 # CUtlString
    m_nResolutionEnum = 0x728 # int32_t
    m_bRenderShadows = 0x72C # bool
    m_bUseUniqueColorTarget = 0x72D # bool
    m_brushModelName = 0x730 # CUtlString
    m_hTargetCamera = 0x738 # CHandle<CBaseEntity>
    m_bEnabled = 0x73C # bool
    m_bDraw3DSkybox = 0x73D # bool
    m_bStartEnabled = 0x73E # bool

class CFuncMoveLinear:
    m_authoredPosition = 0x780 # MoveLinearAuthoredPos_t
    m_angMoveEntitySpace = 0x784 # QAngle
    m_vecMoveDirParentSpace = 0x790 # Vector
    m_soundStart = 0x7A0 # CUtlSymbolLarge
    m_soundStop = 0x7A8 # CUtlSymbolLarge
    m_currentSound = 0x7B0 # CUtlSymbolLarge
    m_flBlockDamage = 0x7B8 # float
    m_flStartPosition = 0x7BC # float
    m_flMoveDistance = 0x7C0 # float
    m_OnFullyOpen = 0x7D0 # CEntityIOOutput
    m_OnFullyClosed = 0x7F8 # CEntityIOOutput
    m_bCreateMovableNavMesh = 0x820 # bool
    m_bCreateNavObstacle = 0x821 # bool

class CFuncNavBlocker:
    m_bDisabled = 0x700 # bool
    m_nBlockedTeamNumber = 0x704 # int32_t

class CFuncNavObstruction:
    m_bDisabled = 0x708 # bool

class CFuncPlat:
    m_sNoise = 0x7A8 # CUtlSymbolLarge

class CFuncPlatRot:
    m_end = 0x7B0 # QAngle
    m_start = 0x7BC # QAngle

class CFuncRotating:
    m_vecMoveAng = 0x700 # QAngle
    m_flFanFriction = 0x70C # float
    m_flAttenuation = 0x710 # float
    m_flVolume = 0x714 # float
    m_flTargetSpeed = 0x718 # float
    m_flMaxSpeed = 0x71C # float
    m_flBlockDamage = 0x720 # float
    m_flTimeScale = 0x724 # float
    m_NoiseRunning = 0x728 # CUtlSymbolLarge
    m_bReversed = 0x730 # bool
    m_angStart = 0x73C # QAngle
    m_bStopAtStartPos = 0x748 # bool
    m_vecClientOrigin = 0x74C # Vector
    m_vecClientAngles = 0x758 # QAngle

class CFuncShatterglass:
    m_hGlassMaterialDamaged = 0x700 # CStrongHandle<InfoForResourceTypeIMaterial2>
    m_hGlassMaterialUndamaged = 0x708 # CStrongHandle<InfoForResourceTypeIMaterial2>
    m_hConcreteMaterialEdgeFace = 0x710 # CStrongHandle<InfoForResourceTypeIMaterial2>
    m_hConcreteMaterialEdgeCaps = 0x718 # CStrongHandle<InfoForResourceTypeIMaterial2>
    m_hConcreteMaterialEdgeFins = 0x720 # CStrongHandle<InfoForResourceTypeIMaterial2>
    m_matPanelTransform = 0x728 # matrix3x4_t
    m_matPanelTransformWsTemp = 0x758 # matrix3x4_t
    m_vecShatterGlassShards = 0x788 # CUtlVector<uint32_t>
    m_PanelSize = 0x7A0 # Vector2D
    m_vecPanelNormalWs = 0x7A8 # Vector
    m_nNumShardsEverCreated = 0x7B4 # int32_t
    m_flLastShatterSoundEmitTime = 0x7B8 # GameTime_t
    m_flLastCleanupTime = 0x7BC # GameTime_t
    m_flInitAtTime = 0x7C0 # GameTime_t
    m_flGlassThickness = 0x7C4 # float
    m_flSpawnInvulnerability = 0x7C8 # float
    m_bBreakSilent = 0x7CC # bool
    m_bBreakShardless = 0x7CD # bool
    m_bBroken = 0x7CE # bool
    m_bHasRateLimitedShards = 0x7CF # bool
    m_bGlassNavIgnore = 0x7D0 # bool
    m_bGlassInFrame = 0x7D1 # bool
    m_bStartBroken = 0x7D2 # bool
    m_iInitialDamageType = 0x7D3 # uint8_t
    m_szDamagePositioningEntityName01 = 0x7D8 # CUtlSymbolLarge
    m_szDamagePositioningEntityName02 = 0x7E0 # CUtlSymbolLarge
    m_szDamagePositioningEntityName03 = 0x7E8 # CUtlSymbolLarge
    m_szDamagePositioningEntityName04 = 0x7F0 # CUtlSymbolLarge
    m_vInitialDamagePositions = 0x7F8 # CUtlVector<Vector>
    m_vExtraDamagePositions = 0x810 # CUtlVector<Vector>
    m_OnBroken = 0x828 # CEntityIOOutput
    m_iSurfaceType = 0x851 # uint8_t

class CFuncTankTrain:
    m_OnDeath = 0x850 # CEntityIOOutput

class CFuncTimescale:
    m_flDesiredTimescale = 0x4B0 # float
    m_flAcceleration = 0x4B4 # float
    m_flMinBlendRate = 0x4B8 # float
    m_flBlendDeltaMultiplier = 0x4BC # float
    m_isStarted = 0x4C0 # bool

class CFuncTrackChange:
    m_trackTop = 0x7C8 # CPathTrack*
    m_trackBottom = 0x7D0 # CPathTrack*
    m_train = 0x7D8 # CFuncTrackTrain*
    m_trackTopName = 0x7E0 # CUtlSymbolLarge
    m_trackBottomName = 0x7E8 # CUtlSymbolLarge
    m_trainName = 0x7F0 # CUtlSymbolLarge
    m_code = 0x7F8 # TRAIN_CODE
    m_targetState = 0x7FC # int32_t
    m_use = 0x800 # int32_t

class CFuncTrackTrain:
    m_ppath = 0x700 # CHandle<CPathTrack>
    m_length = 0x704 # float
    m_vPosPrev = 0x708 # Vector
    m_angPrev = 0x714 # QAngle
    m_controlMins = 0x720 # Vector
    m_controlMaxs = 0x72C # Vector
    m_lastBlockPos = 0x738 # Vector
    m_lastBlockTick = 0x744 # int32_t
    m_flVolume = 0x748 # float
    m_flBank = 0x74C # float
    m_oldSpeed = 0x750 # float
    m_flBlockDamage = 0x754 # float
    m_height = 0x758 # float
    m_maxSpeed = 0x75C # float
    m_dir = 0x760 # float
    m_iszSoundMove = 0x768 # CUtlSymbolLarge
    m_iszSoundMovePing = 0x770 # CUtlSymbolLarge
    m_iszSoundStart = 0x778 # CUtlSymbolLarge
    m_iszSoundStop = 0x780 # CUtlSymbolLarge
    m_strPathTarget = 0x788 # CUtlSymbolLarge
    m_flMoveSoundMinDuration = 0x790 # float
    m_flMoveSoundMaxDuration = 0x794 # float
    m_flNextMoveSoundTime = 0x798 # GameTime_t
    m_flMoveSoundMinPitch = 0x79C # float
    m_flMoveSoundMaxPitch = 0x7A0 # float
    m_eOrientationType = 0x7A4 # TrainOrientationType_t
    m_eVelocityType = 0x7A8 # TrainVelocityType_t
    m_OnStart = 0x7B8 # CEntityIOOutput
    m_OnNext = 0x7E0 # CEntityIOOutput
    m_OnArrivedAtDestinationNode = 0x808 # CEntityIOOutput
    m_bManualSpeedChanges = 0x830 # bool
    m_flDesiredSpeed = 0x834 # float
    m_flSpeedChangeTime = 0x838 # GameTime_t
    m_flAccelSpeed = 0x83C # float
    m_flDecelSpeed = 0x840 # float
    m_bAccelToSpeed = 0x844 # bool
    m_flTimeScale = 0x848 # float
    m_flNextMPSoundTime = 0x84C # GameTime_t

class CFuncTrain:
    m_hCurrentTarget = 0x7A8 # CHandle<CBaseEntity>
    m_activated = 0x7AC # bool
    m_hEnemy = 0x7B0 # CHandle<CBaseEntity>
    m_flBlockDamage = 0x7B4 # float
    m_flNextBlockTime = 0x7B8 # GameTime_t
    m_iszLastTarget = 0x7C0 # CUtlSymbolLarge

class CFuncVPhysicsClip:
    m_bDisabled = 0x700 # bool

class CFuncWall:
    m_nState = 0x700 # int32_t

class CFuncWater:
    m_BuoyancyHelper = 0x700 # CBuoyancyHelper

class CGameChoreoServices:
    m_hOwner = 0x8 # CHandle<CBaseAnimGraph>
    m_hScriptedSequence = 0xC # CHandle<CScriptedSequence>
    m_scriptState = 0x10 # IChoreoServices::ScriptState_t
    m_choreoState = 0x14 # IChoreoServices::ChoreoState_t
    m_flTimeStartedState = 0x18 # GameTime_t

class CGameGibManager:
    m_bAllowNewGibs = 0x4D0 # bool
    m_iCurrentMaxPieces = 0x4D4 # int32_t
    m_iMaxPieces = 0x4D8 # int32_t
    m_iLastFrame = 0x4DC # int32_t

class CGameMoney:
    m_OnMoneySpent = 0x710 # CEntityIOOutput
    m_OnMoneySpentFail = 0x738 # CEntityIOOutput
    m_nMoney = 0x760 # int32_t
    m_strAwardText = 0x768 # CUtlString

class CGamePlayerZone:
    m_OnPlayerInZone = 0x708 # CEntityIOOutput
    m_OnPlayerOutZone = 0x730 # CEntityIOOutput
    m_PlayersInCount = 0x758 # CEntityOutputTemplate<int32_t>
    m_PlayersOutCount = 0x780 # CEntityOutputTemplate<int32_t>

class CGameRules:
    m_szQuestName = 0x8 # char[128]
    m_nQuestPhase = 0x88 # int32_t

class CGameSceneNode:
    m_nodeToWorld = 0x10 # CTransform
    m_pOwner = 0x30 # CEntityInstance*
    m_pParent = 0x38 # CGameSceneNode*
    m_pChild = 0x40 # CGameSceneNode*
    m_pNextSibling = 0x48 # CGameSceneNode*
    m_hParent = 0x70 # CGameSceneNodeHandle
    m_vecOrigin = 0x80 # CNetworkOriginCellCoordQuantizedVector
    m_angRotation = 0xB8 # QAngle
    m_flScale = 0xC4 # float
    m_vecAbsOrigin = 0xC8 # Vector
    m_angAbsRotation = 0xD4 # QAngle
    m_flAbsScale = 0xE0 # float
    m_nParentAttachmentOrBone = 0xE4 # int16_t
    m_bDebugAbsOriginChanges = 0xE6 # bool
    m_bDormant = 0xE7 # bool
    m_bForceParentToBeNetworked = 0xE8 # bool
    m_bDirtyHierarchy = 0x0 # bitfield:1
    m_bDirtyBoneMergeInfo = 0x0 # bitfield:1
    m_bNetworkedPositionChanged = 0x0 # bitfield:1
    m_bNetworkedAnglesChanged = 0x0 # bitfield:1
    m_bNetworkedScaleChanged = 0x0 # bitfield:1
    m_bWillBeCallingPostDataUpdate = 0x0 # bitfield:1
    m_bNotifyBoneTransformsChanged = 0x0 # bitfield:1
    m_bBoneMergeFlex = 0x0 # bitfield:1
    m_nLatchAbsOrigin = 0x0 # bitfield:2
    m_bDirtyBoneMergeBoneToRoot = 0x0 # bitfield:1
    m_nHierarchicalDepth = 0xEB # uint8_t
    m_nHierarchyType = 0xEC # uint8_t
    m_nDoNotSetAnimTimeInInvalidatePhysicsCount = 0xED # uint8_t
    m_name = 0xF0 # CUtlStringToken
    m_hierarchyAttachName = 0x130 # CUtlStringToken
    m_flZOffset = 0x134 # float
    m_vRenderOrigin = 0x138 # Vector

class CGameSceneNodeHandle:
    m_hOwner = 0x8 # CEntityHandle
    m_name = 0xC # CUtlStringToken

class CGameScriptedMoveData:
    m_vDest = 0x0 # Vector
    m_vSrc = 0xC # Vector
    m_angSrc = 0x18 # QAngle
    m_angDst = 0x24 # QAngle
    m_angCurrent = 0x30 # QAngle
    m_flAngRate = 0x3C # float
    m_flDuration = 0x40 # float
    m_flStartTime = 0x44 # GameTime_t
    m_nPrevMoveType = 0x48 # MoveType_t
    m_bActive = 0x49 # bool
    m_bTeleportOnEnd = 0x4A # bool
    m_bEndOnDestinationReached = 0x4B # bool
    m_bIgnoreRotation = 0x4C # bool
    m_nType = 0x50 # ScriptedMoveType_t
    m_bSuccess = 0x54 # bool
    m_nForcedCrouchState = 0x58 # ForcedCrouchState_t
    m_bIgnoreCollisions = 0x5C # bool

class CGameText:
    m_iszMessage = 0x710 # CUtlSymbolLarge
    m_textParms = 0x718 # hudtextparms_t

class CGenericConstraint:
    m_nLinearMotionX = 0x510 # JointMotion_t
    m_nLinearMotionY = 0x514 # JointMotion_t
    m_nLinearMotionZ = 0x518 # JointMotion_t
    m_flLinearFrequencyX = 0x51C # float
    m_flLinearFrequencyY = 0x520 # float
    m_flLinearFrequencyZ = 0x524 # float
    m_flLinearDampingRatioX = 0x528 # float
    m_flLinearDampingRatioY = 0x52C # float
    m_flLinearDampingRatioZ = 0x530 # float
    m_flMaxLinearImpulseX = 0x534 # float
    m_flMaxLinearImpulseY = 0x538 # float
    m_flMaxLinearImpulseZ = 0x53C # float
    m_flBreakAfterTimeX = 0x540 # float
    m_flBreakAfterTimeY = 0x544 # float
    m_flBreakAfterTimeZ = 0x548 # float
    m_flBreakAfterTimeStartTimeX = 0x54C # GameTime_t
    m_flBreakAfterTimeStartTimeY = 0x550 # GameTime_t
    m_flBreakAfterTimeStartTimeZ = 0x554 # GameTime_t
    m_flBreakAfterTimeThresholdX = 0x558 # float
    m_flBreakAfterTimeThresholdY = 0x55C # float
    m_flBreakAfterTimeThresholdZ = 0x560 # float
    m_flNotifyForceX = 0x564 # float
    m_flNotifyForceY = 0x568 # float
    m_flNotifyForceZ = 0x56C # float
    m_flNotifyForceMinTimeX = 0x570 # float
    m_flNotifyForceMinTimeY = 0x574 # float
    m_flNotifyForceMinTimeZ = 0x578 # float
    m_flNotifyForceLastTimeX = 0x57C # GameTime_t
    m_flNotifyForceLastTimeY = 0x580 # GameTime_t
    m_flNotifyForceLastTimeZ = 0x584 # GameTime_t
    m_bAxisNotifiedX = 0x588 # bool
    m_bAxisNotifiedY = 0x589 # bool
    m_bAxisNotifiedZ = 0x58A # bool
    m_nAngularMotionX = 0x58C # JointMotion_t
    m_nAngularMotionY = 0x590 # JointMotion_t
    m_nAngularMotionZ = 0x594 # JointMotion_t
    m_flAngularFrequencyX = 0x598 # float
    m_flAngularFrequencyY = 0x59C # float
    m_flAngularFrequencyZ = 0x5A0 # float
    m_flAngularDampingRatioX = 0x5A4 # float
    m_flAngularDampingRatioY = 0x5A8 # float
    m_flAngularDampingRatioZ = 0x5AC # float
    m_flMaxAngularImpulseX = 0x5B0 # float
    m_flMaxAngularImpulseY = 0x5B4 # float
    m_flMaxAngularImpulseZ = 0x5B8 # float
    m_NotifyForceReachedX = 0x5C0 # CEntityIOOutput
    m_NotifyForceReachedY = 0x5E8 # CEntityIOOutput
    m_NotifyForceReachedZ = 0x610 # CEntityIOOutput

class CGlowProperty:
    m_fGlowColor = 0x8 # Vector
    m_iGlowType = 0x30 # int32_t
    m_iGlowTeam = 0x34 # int32_t
    m_nGlowRange = 0x38 # int32_t
    m_nGlowRangeMin = 0x3C # int32_t
    m_glowColorOverride = 0x40 # Color
    m_bFlashing = 0x44 # bool
    m_flGlowTime = 0x48 # float
    m_flGlowStartTime = 0x4C # float
    m_bEligibleForScreenHighlight = 0x50 # bool
    m_bGlowing = 0x51 # bool

class CGradientFog:
    m_hGradientFogTexture = 0x4B0 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_flFogStartDistance = 0x4B8 # float
    m_flFogEndDistance = 0x4BC # float
    m_bHeightFogEnabled = 0x4C0 # bool
    m_flFogStartHeight = 0x4C4 # float
    m_flFogEndHeight = 0x4C8 # float
    m_flFarZ = 0x4CC # float
    m_flFogMaxOpacity = 0x4D0 # float
    m_flFogFalloffExponent = 0x4D4 # float
    m_flFogVerticalExponent = 0x4D8 # float
    m_fogColor = 0x4DC # Color
    m_flFogStrength = 0x4E0 # float
    m_flFadeTime = 0x4E4 # float
    m_bStartDisabled = 0x4E8 # bool
    m_bIsEnabled = 0x4E9 # bool
    m_bGradientFogNeedsTextures = 0x4EA # bool

class CGunTarget:
    m_on = 0x780 # bool
    m_hTargetEnt = 0x784 # CHandle<CBaseEntity>
    m_OnDeath = 0x788 # CEntityIOOutput

class CHandleTest:
    m_Handle = 0x4B0 # CHandle<CBaseEntity>
    m_bSendHandle = 0x4B4 # bool

class CHintMessage:
    m_hintString = 0x8 # char*
    m_args = 0x10 # CUtlVector<char*>
    m_duration = 0x28 # float

class CHintMessageQueue:
    m_tmMessageEnd = 0x8 # float
    m_messages = 0x10 # CUtlVector<CHintMessage*>
    m_pPlayerController = 0x28 # CBasePlayerController*

class CHitboxComponent:
    m_bvDisabledHitGroups = 0x24 # uint32_t[1]

class CHostage:
    m_OnHostageBeginGrab = 0x9E8 # CEntityIOOutput
    m_OnFirstPickedUp = 0xA10 # CEntityIOOutput
    m_OnDroppedNotRescued = 0xA38 # CEntityIOOutput
    m_OnRescued = 0xA60 # CEntityIOOutput
    m_entitySpottedState = 0xA88 # EntitySpottedState_t
    m_nSpotRules = 0xAA0 # int32_t
    m_uiHostageSpawnExclusionGroupMask = 0xAA4 # uint32_t
    m_nHostageSpawnRandomFactor = 0xAA8 # uint32_t
    m_bRemove = 0xAAC # bool
    m_vel = 0xAB0 # Vector
    m_isRescued = 0xABC # bool
    m_jumpedThisFrame = 0xABD # bool
    m_nHostageState = 0xAC0 # int32_t
    m_leader = 0xAC4 # CHandle<CBaseEntity>
    m_lastLeader = 0xAC8 # CHandle<CCSPlayerPawnBase>
    m_reuseTimer = 0xAD0 # CountdownTimer
    m_hasBeenUsed = 0xAE8 # bool
    m_accel = 0xAEC # Vector
    m_isRunning = 0xAF8 # bool
    m_isCrouching = 0xAF9 # bool
    m_jumpTimer = 0xB00 # CountdownTimer
    m_isWaitingForLeader = 0xB18 # bool
    m_repathTimer = 0x2B28 # CountdownTimer
    m_inhibitDoorTimer = 0x2B40 # CountdownTimer
    m_inhibitObstacleAvoidanceTimer = 0x2BD0 # CountdownTimer
    m_wiggleTimer = 0x2BF0 # CountdownTimer
    m_isAdjusted = 0x2C0C # bool
    m_bHandsHaveBeenCut = 0x2C0D # bool
    m_hHostageGrabber = 0x2C10 # CHandle<CCSPlayerPawn>
    m_fLastGrabTime = 0x2C14 # GameTime_t
    m_vecPositionWhenStartedDroppingToGround = 0x2C18 # Vector
    m_vecGrabbedPos = 0x2C24 # Vector
    m_flRescueStartTime = 0x2C30 # GameTime_t
    m_flGrabSuccessTime = 0x2C34 # GameTime_t
    m_flDropStartTime = 0x2C38 # GameTime_t
    m_nApproachRewardPayouts = 0x2C3C # int32_t
    m_nPickupEventCount = 0x2C40 # int32_t
    m_vecSpawnGroundPos = 0x2C44 # Vector
    m_vecHostageResetPosition = 0x2C64 # Vector

class CHostageExpresserShim:
    m_pExpresser = 0x9D0 # CAI_Expresser*

class CInButtonState:
    m_pButtonStates = 0x8 # uint64_t[3]

class CInferno:
    m_firePositions = 0x710 # Vector[64]
    m_fireParentPositions = 0xA10 # Vector[64]
    m_bFireIsBurning = 0xD10 # bool[64]
    m_BurnNormal = 0xD50 # Vector[64]
    m_fireCount = 0x1050 # int32_t
    m_nInfernoType = 0x1054 # int32_t
    m_nFireEffectTickBegin = 0x1058 # int32_t
    m_nFireLifetime = 0x105C # float
    m_bInPostEffectTime = 0x1060 # bool
    m_nFiresExtinguishCount = 0x1064 # int32_t
    m_bWasCreatedInSmoke = 0x1068 # bool
    m_extent = 0x1270 # Extent
    m_damageTimer = 0x1288 # CountdownTimer
    m_damageRampTimer = 0x12A0 # CountdownTimer
    m_splashVelocity = 0x12B8 # Vector
    m_InitialSplashVelocity = 0x12C4 # Vector
    m_startPos = 0x12D0 # Vector
    m_vecOriginalSpawnLocation = 0x12DC # Vector
    m_activeTimer = 0x12E8 # IntervalTimer
    m_fireSpawnOffset = 0x12F8 # int32_t
    m_nMaxFlames = 0x12FC # int32_t
    m_BookkeepingTimer = 0x1300 # CountdownTimer
    m_NextSpreadTimer = 0x1318 # CountdownTimer
    m_nSourceItemDefIndex = 0x1330 # uint16_t

class CInfoDynamicShadowHint:
    m_bDisabled = 0x4B0 # bool
    m_flRange = 0x4B4 # float
    m_nImportance = 0x4B8 # int32_t
    m_nLightChoice = 0x4BC # int32_t
    m_hLight = 0x4C0 # CHandle<CBaseEntity>

class CInfoDynamicShadowHintBox:
    m_vBoxMins = 0x4C8 # Vector
    m_vBoxMaxs = 0x4D4 # Vector

class CInfoGameEventProxy:
    m_iszEventName = 0x4B0 # CUtlSymbolLarge
    m_flRange = 0x4B8 # float

class CInfoOffscreenPanoramaTexture:
    m_bDisabled = 0x4B0 # bool
    m_nResolutionX = 0x4B4 # int32_t
    m_nResolutionY = 0x4B8 # int32_t
    m_szLayoutFileName = 0x4C0 # CUtlSymbolLarge
    m_RenderAttrName = 0x4C8 # CUtlSymbolLarge
    m_TargetEntities = 0x4D0 # CNetworkUtlVectorBase<CHandle<CBaseModelEntity>>
    m_nTargetChangeCount = 0x4E8 # int32_t
    m_vecCSSClasses = 0x4F0 # CNetworkUtlVectorBase<CUtlSymbolLarge>
    m_szTargetsName = 0x508 # CUtlSymbolLarge
    m_AdditionalTargetEntities = 0x510 # CUtlVector<CHandle<CBaseModelEntity>>

class CInfoPlayerStart:
    m_bDisabled = 0x4B0 # bool

class CInfoSpawnGroupLoadUnload:
    m_OnSpawnGroupLoadStarted = 0x4B0 # CEntityIOOutput
    m_OnSpawnGroupLoadFinished = 0x4D8 # CEntityIOOutput
    m_OnSpawnGroupUnloadStarted = 0x500 # CEntityIOOutput
    m_OnSpawnGroupUnloadFinished = 0x528 # CEntityIOOutput
    m_iszSpawnGroupName = 0x550 # CUtlSymbolLarge
    m_iszSpawnGroupFilterName = 0x558 # CUtlSymbolLarge
    m_iszLandmarkName = 0x560 # CUtlSymbolLarge
    m_sFixedSpawnGroupName = 0x568 # CUtlString
    m_flTimeoutInterval = 0x570 # float
    m_bStreamingStarted = 0x574 # bool
    m_bUnloadingStarted = 0x575 # bool

class CInfoVisibilityBox:
    m_nMode = 0x4B4 # int32_t
    m_vBoxSize = 0x4B8 # Vector
    m_bEnabled = 0x4C4 # bool

class CInfoWorldLayer:
    m_pOutputOnEntitiesSpawned = 0x4B0 # CEntityIOOutput
    m_worldName = 0x4D8 # CUtlSymbolLarge
    m_layerName = 0x4E0 # CUtlSymbolLarge
    m_bWorldLayerVisible = 0x4E8 # bool
    m_bEntitiesSpawned = 0x4E9 # bool
    m_bCreateAsChildSpawnGroup = 0x4EA # bool
    m_hLayerSpawnGroup = 0x4EC # uint32_t

class CInstancedSceneEntity:
    m_hOwner = 0xA08 # CHandle<CBaseEntity>
    m_bHadOwner = 0xA0C # bool
    m_flPostSpeakDelay = 0xA10 # float
    m_flPreDelay = 0xA14 # float
    m_bIsBackground = 0xA18 # bool

class CInstructorEventEntity:
    m_iszName = 0x4B0 # CUtlSymbolLarge
    m_iszHintTargetEntity = 0x4B8 # CUtlSymbolLarge
    m_hTargetPlayer = 0x4C0 # CHandle<CBasePlayerPawn>

class CIronSightController:
    m_bIronSightAvailable = 0x8 # bool
    m_flIronSightAmount = 0xC # float
    m_flIronSightAmountGained = 0x10 # float
    m_flIronSightAmountBiased = 0x14 # float

class CItem:
    m_OnPlayerTouch = 0x898 # CEntityIOOutput
    m_bActivateWhenAtRest = 0x8C0 # bool
    m_OnCacheInteraction = 0x8C8 # CEntityIOOutput
    m_OnPlayerPickup = 0x8F0 # CEntityIOOutput
    m_OnGlovePulled = 0x918 # CEntityIOOutput
    m_vOriginalSpawnOrigin = 0x940 # Vector
    m_vOriginalSpawnAngles = 0x94C # QAngle
    m_bPhysStartAsleep = 0x958 # bool

class CItemDefuser:
    m_entitySpottedState = 0x968 # EntitySpottedState_t
    m_nSpotRules = 0x980 # int32_t

class CItemDogtags:
    m_OwningPlayer = 0x968 # CHandle<CCSPlayerPawn>
    m_KillingPlayer = 0x96C # CHandle<CCSPlayerPawn>

class CItemGeneric:
    m_bHasTriggerRadius = 0x970 # bool
    m_bHasPickupRadius = 0x971 # bool
    m_flPickupRadiusSqr = 0x974 # float
    m_flTriggerRadiusSqr = 0x978 # float
    m_flLastPickupCheck = 0x97C # GameTime_t
    m_bPlayerCounterListenerAdded = 0x980 # bool
    m_bPlayerInTriggerRadius = 0x981 # bool
    m_hSpawnParticleEffect = 0x988 # CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    m_pAmbientSoundEffect = 0x990 # CUtlSymbolLarge
    m_bAutoStartAmbientSound = 0x998 # bool
    m_pSpawnScriptFunction = 0x9A0 # CUtlSymbolLarge
    m_hPickupParticleEffect = 0x9A8 # CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    m_pPickupSoundEffect = 0x9B0 # CUtlSymbolLarge
    m_pPickupScriptFunction = 0x9B8 # CUtlSymbolLarge
    m_hTimeoutParticleEffect = 0x9C0 # CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    m_pTimeoutSoundEffect = 0x9C8 # CUtlSymbolLarge
    m_pTimeoutScriptFunction = 0x9D0 # CUtlSymbolLarge
    m_pPickupFilterName = 0x9D8 # CUtlSymbolLarge
    m_hPickupFilter = 0x9E0 # CHandle<CBaseFilter>
    m_OnPickup = 0x9E8 # CEntityIOOutput
    m_OnTimeout = 0xA10 # CEntityIOOutput
    m_OnTriggerStartTouch = 0xA38 # CEntityIOOutput
    m_OnTriggerTouch = 0xA60 # CEntityIOOutput
    m_OnTriggerEndTouch = 0xA88 # CEntityIOOutput
    m_pAllowPickupScriptFunction = 0xAB0 # CUtlSymbolLarge
    m_flPickupRadius = 0xAB8 # float
    m_flTriggerRadius = 0xABC # float
    m_pTriggerSoundEffect = 0xAC0 # CUtlSymbolLarge
    m_bGlowWhenInTrigger = 0xAC8 # bool
    m_glowColor = 0xAC9 # Color
    m_bUseable = 0xACD # bool
    m_hTriggerHelper = 0xAD0 # CHandle<CItemGenericTriggerHelper>

class CItemGenericTriggerHelper:
    m_hParentItem = 0x700 # CHandle<CItemGeneric>

class CKeepUpright:
    m_worldGoalAxis = 0x4B8 # Vector
    m_localTestAxis = 0x4C4 # Vector
    m_nameAttach = 0x4D8 # CUtlSymbolLarge
    m_attachedObject = 0x4E0 # CHandle<CBaseEntity>
    m_angularLimit = 0x4E4 # float
    m_bActive = 0x4E8 # bool
    m_bDampAllRotation = 0x4E9 # bool

class CKnife:
    m_bFirstAttack = 0xE20 # bool

class CLightComponent:
    __m_pChainEntity = 0x48 # CNetworkVarChainer
    m_Color = 0x85 # Color
    m_SecondaryColor = 0x89 # Color
    m_flBrightness = 0x90 # float
    m_flBrightnessScale = 0x94 # float
    m_flBrightnessMult = 0x98 # float
    m_flRange = 0x9C # float
    m_flFalloff = 0xA0 # float
    m_flAttenuation0 = 0xA4 # float
    m_flAttenuation1 = 0xA8 # float
    m_flAttenuation2 = 0xAC # float
    m_flTheta = 0xB0 # float
    m_flPhi = 0xB4 # float
    m_hLightCookie = 0xB8 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_nCascades = 0xC0 # int32_t
    m_nCastShadows = 0xC4 # int32_t
    m_nShadowWidth = 0xC8 # int32_t
    m_nShadowHeight = 0xCC # int32_t
    m_bRenderDiffuse = 0xD0 # bool
    m_nRenderSpecular = 0xD4 # int32_t
    m_bRenderTransmissive = 0xD8 # bool
    m_flOrthoLightWidth = 0xDC # float
    m_flOrthoLightHeight = 0xE0 # float
    m_nStyle = 0xE4 # int32_t
    m_Pattern = 0xE8 # CUtlString
    m_nCascadeRenderStaticObjects = 0xF0 # int32_t
    m_flShadowCascadeCrossFade = 0xF4 # float
    m_flShadowCascadeDistanceFade = 0xF8 # float
    m_flShadowCascadeDistance0 = 0xFC # float
    m_flShadowCascadeDistance1 = 0x100 # float
    m_flShadowCascadeDistance2 = 0x104 # float
    m_flShadowCascadeDistance3 = 0x108 # float
    m_nShadowCascadeResolution0 = 0x10C # int32_t
    m_nShadowCascadeResolution1 = 0x110 # int32_t
    m_nShadowCascadeResolution2 = 0x114 # int32_t
    m_nShadowCascadeResolution3 = 0x118 # int32_t
    m_bUsesBakedShadowing = 0x11C # bool
    m_nShadowPriority = 0x120 # int32_t
    m_nBakedShadowIndex = 0x124 # int32_t
    m_bRenderToCubemaps = 0x128 # bool
    m_nDirectLight = 0x12C # int32_t
    m_nIndirectLight = 0x130 # int32_t
    m_flFadeMinDist = 0x134 # float
    m_flFadeMaxDist = 0x138 # float
    m_flShadowFadeMinDist = 0x13C # float
    m_flShadowFadeMaxDist = 0x140 # float
    m_bEnabled = 0x144 # bool
    m_bFlicker = 0x145 # bool
    m_bPrecomputedFieldsValid = 0x146 # bool
    m_vPrecomputedBoundsMins = 0x148 # Vector
    m_vPrecomputedBoundsMaxs = 0x154 # Vector
    m_vPrecomputedOBBOrigin = 0x160 # Vector
    m_vPrecomputedOBBAngles = 0x16C # QAngle
    m_vPrecomputedOBBExtent = 0x178 # Vector
    m_flPrecomputedMaxRange = 0x184 # float
    m_nFogLightingMode = 0x188 # int32_t
    m_flFogContributionStength = 0x18C # float
    m_flNearClipPlane = 0x190 # float
    m_SkyColor = 0x194 # Color
    m_flSkyIntensity = 0x198 # float
    m_SkyAmbientBounce = 0x19C # Color
    m_bUseSecondaryColor = 0x1A0 # bool
    m_bMixedShadows = 0x1A1 # bool
    m_flLightStyleStartTime = 0x1A4 # GameTime_t
    m_flCapsuleLength = 0x1A8 # float
    m_flMinRoughness = 0x1AC # float
    m_bPvsModifyEntity = 0x1C0 # bool

class CLightEntity:
    m_CLightComponent = 0x700 # CLightComponent*

class CLightGlow:
    m_nHorizontalSize = 0x700 # uint32_t
    m_nVerticalSize = 0x704 # uint32_t
    m_nMinDist = 0x708 # uint32_t
    m_nMaxDist = 0x70C # uint32_t
    m_nOuterMaxDist = 0x710 # uint32_t
    m_flGlowProxySize = 0x714 # float
    m_flHDRColorScale = 0x718 # float

class CLogicAchievement:
    m_bDisabled = 0x4B0 # bool
    m_iszAchievementEventID = 0x4B8 # CUtlSymbolLarge
    m_OnFired = 0x4C0 # CEntityIOOutput

class CLogicActiveAutosave:
    m_TriggerHitPoints = 0x4C0 # int32_t
    m_flTimeToTrigger = 0x4C4 # float
    m_flStartTime = 0x4C8 # GameTime_t
    m_flDangerousTime = 0x4CC # float

class CLogicAuto:
    m_OnMapSpawn = 0x4B0 # CEntityIOOutput
    m_OnDemoMapSpawn = 0x4D8 # CEntityIOOutput
    m_OnNewGame = 0x500 # CEntityIOOutput
    m_OnLoadGame = 0x528 # CEntityIOOutput
    m_OnMapTransition = 0x550 # CEntityIOOutput
    m_OnBackgroundMap = 0x578 # CEntityIOOutput
    m_OnMultiNewMap = 0x5A0 # CEntityIOOutput
    m_OnMultiNewRound = 0x5C8 # CEntityIOOutput
    m_OnVREnabled = 0x5F0 # CEntityIOOutput
    m_OnVRNotEnabled = 0x618 # CEntityIOOutput
    m_globalstate = 0x640 # CUtlSymbolLarge

class CLogicAutosave:
    m_bForceNewLevelUnit = 0x4B0 # bool
    m_minHitPoints = 0x4B4 # int32_t
    m_minHitPointsToCommit = 0x4B8 # int32_t

class CLogicBranch:
    m_bInValue = 0x4B0 # bool
    m_Listeners = 0x4B8 # CUtlVector<CHandle<CBaseEntity>>
    m_OnTrue = 0x4D0 # CEntityIOOutput
    m_OnFalse = 0x4F8 # CEntityIOOutput

class CLogicBranchList:
    m_nLogicBranchNames = 0x4B0 # CUtlSymbolLarge[16]
    m_LogicBranchList = 0x530 # CUtlVector<CHandle<CBaseEntity>>
    m_eLastState = 0x548 # CLogicBranchList::LogicBranchListenerLastState_t
    m_OnAllTrue = 0x550 # CEntityIOOutput
    m_OnAllFalse = 0x578 # CEntityIOOutput
    m_OnMixed = 0x5A0 # CEntityIOOutput

class CLogicCase:
    m_nCase = 0x4B0 # CUtlSymbolLarge[32]
    m_nShuffleCases = 0x5B0 # int32_t
    m_nLastShuffleCase = 0x5B4 # int32_t
    m_uchShuffleCaseMap = 0x5B8 # uint8_t[32]
    m_OnCase = 0x5D8 # CEntityIOOutput[32]
    m_OnDefault = 0xAD8 # CEntityOutputTemplate<CVariantBase<CVariantDefaultAllocator>>

class CLogicCollisionPair:
    m_nameAttach1 = 0x4B0 # CUtlSymbolLarge
    m_nameAttach2 = 0x4B8 # CUtlSymbolLarge
    m_disabled = 0x4C0 # bool
    m_succeeded = 0x4C1 # bool

class CLogicCompare:
    m_flInValue = 0x4B0 # float
    m_flCompareValue = 0x4B4 # float
    m_OnLessThan = 0x4B8 # CEntityOutputTemplate<float>
    m_OnEqualTo = 0x4E0 # CEntityOutputTemplate<float>
    m_OnNotEqualTo = 0x508 # CEntityOutputTemplate<float>
    m_OnGreaterThan = 0x530 # CEntityOutputTemplate<float>

class CLogicDistanceAutosave:
    m_iszTargetEntity = 0x4B0 # CUtlSymbolLarge
    m_flDistanceToPlayer = 0x4B8 # float
    m_bForceNewLevelUnit = 0x4BC # bool
    m_bCheckCough = 0x4BD # bool
    m_bThinkDangerous = 0x4BE # bool
    m_flDangerousTime = 0x4C0 # float

class CLogicDistanceCheck:
    m_iszEntityA = 0x4B0 # CUtlSymbolLarge
    m_iszEntityB = 0x4B8 # CUtlSymbolLarge
    m_flZone1Distance = 0x4C0 # float
    m_flZone2Distance = 0x4C4 # float
    m_InZone1 = 0x4C8 # CEntityIOOutput
    m_InZone2 = 0x4F0 # CEntityIOOutput
    m_InZone3 = 0x518 # CEntityIOOutput

class CLogicEventListener:
    m_strEventName = 0x4C0 # CUtlString
    m_bIsEnabled = 0x4C8 # bool
    m_nTeam = 0x4CC # int32_t
    m_OnEventFired = 0x4D0 # CEntityIOOutput

class CLogicGameEvent:
    m_iszEventName = 0x4B0 # CUtlSymbolLarge

class CLogicGameEventListener:
    m_OnEventFired = 0x4C0 # CEntityIOOutput
    m_iszGameEventName = 0x4E8 # CUtlSymbolLarge
    m_iszGameEventItem = 0x4F0 # CUtlSymbolLarge
    m_bEnabled = 0x4F8 # bool
    m_bStartDisabled = 0x4F9 # bool

class CLogicLineToEntity:
    m_Line = 0x4B0 # CEntityOutputTemplate<Vector>
    m_SourceName = 0x4D8 # CUtlSymbolLarge
    m_StartEntity = 0x4E0 # CHandle<CBaseEntity>
    m_EndEntity = 0x4E4 # CHandle<CBaseEntity>

class CLogicMeasureMovement:
    m_strMeasureTarget = 0x4B0 # CUtlSymbolLarge
    m_strMeasureReference = 0x4B8 # CUtlSymbolLarge
    m_strTargetReference = 0x4C0 # CUtlSymbolLarge
    m_hMeasureTarget = 0x4C8 # CHandle<CBaseEntity>
    m_hMeasureReference = 0x4CC # CHandle<CBaseEntity>
    m_hTarget = 0x4D0 # CHandle<CBaseEntity>
    m_hTargetReference = 0x4D4 # CHandle<CBaseEntity>
    m_flScale = 0x4D8 # float
    m_nMeasureType = 0x4DC # int32_t

class CLogicNPCCounter:
    m_OnMinCountAll = 0x4B0 # CEntityIOOutput
    m_OnMaxCountAll = 0x4D8 # CEntityIOOutput
    m_OnFactorAll = 0x500 # CEntityOutputTemplate<float>
    m_OnMinPlayerDistAll = 0x528 # CEntityOutputTemplate<float>
    m_OnMinCount_1 = 0x550 # CEntityIOOutput
    m_OnMaxCount_1 = 0x578 # CEntityIOOutput
    m_OnFactor_1 = 0x5A0 # CEntityOutputTemplate<float>
    m_OnMinPlayerDist_1 = 0x5C8 # CEntityOutputTemplate<float>
    m_OnMinCount_2 = 0x5F0 # CEntityIOOutput
    m_OnMaxCount_2 = 0x618 # CEntityIOOutput
    m_OnFactor_2 = 0x640 # CEntityOutputTemplate<float>
    m_OnMinPlayerDist_2 = 0x668 # CEntityOutputTemplate<float>
    m_OnMinCount_3 = 0x690 # CEntityIOOutput
    m_OnMaxCount_3 = 0x6B8 # CEntityIOOutput
    m_OnFactor_3 = 0x6E0 # CEntityOutputTemplate<float>
    m_OnMinPlayerDist_3 = 0x708 # CEntityOutputTemplate<float>
    m_hSource = 0x730 # CEntityHandle
    m_iszSourceEntityName = 0x738 # CUtlSymbolLarge
    m_flDistanceMax = 0x740 # float
    m_bDisabled = 0x744 # bool
    m_nMinCountAll = 0x748 # int32_t
    m_nMaxCountAll = 0x74C # int32_t
    m_nMinFactorAll = 0x750 # int32_t
    m_nMaxFactorAll = 0x754 # int32_t
    m_iszNPCClassname_1 = 0x760 # CUtlSymbolLarge
    m_nNPCState_1 = 0x768 # int32_t
    m_bInvertState_1 = 0x76C # bool
    m_nMinCount_1 = 0x770 # int32_t
    m_nMaxCount_1 = 0x774 # int32_t
    m_nMinFactor_1 = 0x778 # int32_t
    m_nMaxFactor_1 = 0x77C # int32_t
    m_flDefaultDist_1 = 0x784 # float
    m_iszNPCClassname_2 = 0x788 # CUtlSymbolLarge
    m_nNPCState_2 = 0x790 # int32_t
    m_bInvertState_2 = 0x794 # bool
    m_nMinCount_2 = 0x798 # int32_t
    m_nMaxCount_2 = 0x79C # int32_t
    m_nMinFactor_2 = 0x7A0 # int32_t
    m_nMaxFactor_2 = 0x7A4 # int32_t
    m_flDefaultDist_2 = 0x7AC # float
    m_iszNPCClassname_3 = 0x7B0 # CUtlSymbolLarge
    m_nNPCState_3 = 0x7B8 # int32_t
    m_bInvertState_3 = 0x7BC # bool
    m_nMinCount_3 = 0x7C0 # int32_t
    m_nMaxCount_3 = 0x7C4 # int32_t
    m_nMinFactor_3 = 0x7C8 # int32_t
    m_nMaxFactor_3 = 0x7CC # int32_t
    m_flDefaultDist_3 = 0x7D4 # float

class CLogicNPCCounterAABB:
    m_vDistanceOuterMins = 0x7F0 # Vector
    m_vDistanceOuterMaxs = 0x7FC # Vector
    m_vOuterMins = 0x808 # Vector
    m_vOuterMaxs = 0x814 # Vector

class CLogicNavigation:
    m_isOn = 0x4B8 # bool
    m_navProperty = 0x4BC # navproperties_t

class CLogicPlayerProxy:
    m_hPlayer = 0x4B0 # CHandle<CBaseEntity>
    m_PlayerHasAmmo = 0x4B8 # CEntityIOOutput
    m_PlayerHasNoAmmo = 0x4E0 # CEntityIOOutput
    m_PlayerDied = 0x508 # CEntityIOOutput
    m_RequestedPlayerHealth = 0x530 # CEntityOutputTemplate<int32_t>

class CLogicRelay:
    m_OnTrigger = 0x4B0 # CEntityIOOutput
    m_OnSpawn = 0x4D8 # CEntityIOOutput
    m_bDisabled = 0x500 # bool
    m_bWaitForRefire = 0x501 # bool
    m_bTriggerOnce = 0x502 # bool
    m_bFastRetrigger = 0x503 # bool
    m_bPassthoughCaller = 0x504 # bool

class CMapInfo:
    m_iBuyingStatus = 0x4B0 # int32_t
    m_flBombRadius = 0x4B4 # float
    m_iPetPopulation = 0x4B8 # int32_t
    m_bUseNormalSpawnsForDM = 0x4BC # bool
    m_bDisableAutoGeneratedDMSpawns = 0x4BD # bool
    m_flBotMaxVisionDistance = 0x4C0 # float
    m_iHostageCount = 0x4C4 # int32_t
    m_bFadePlayerVisibilityFarZ = 0x4C8 # bool

class CMapVetoPickController:
    m_bPlayedIntroVcd = 0x4B0 # bool
    m_bNeedToPlayFiveSecondsRemaining = 0x4B1 # bool
    m_dblPreMatchDraftSequenceTime = 0x4D0 # double
    m_bPreMatchDraftStateChanged = 0x4D8 # bool
    m_nDraftType = 0x4DC # int32_t
    m_nTeamWinningCoinToss = 0x4E0 # int32_t
    m_nTeamWithFirstChoice = 0x4E4 # int32_t[64]
    m_nVoteMapIdsList = 0x5E4 # int32_t[7]
    m_nAccountIDs = 0x600 # int32_t[64]
    m_nMapId0 = 0x700 # int32_t[64]
    m_nMapId1 = 0x800 # int32_t[64]
    m_nMapId2 = 0x900 # int32_t[64]
    m_nMapId3 = 0xA00 # int32_t[64]
    m_nMapId4 = 0xB00 # int32_t[64]
    m_nMapId5 = 0xC00 # int32_t[64]
    m_nStartingSide0 = 0xD00 # int32_t[64]
    m_nCurrentPhase = 0xE00 # int32_t
    m_nPhaseStartTick = 0xE04 # int32_t
    m_nPhaseDurationTicks = 0xE08 # int32_t
    m_OnMapVetoed = 0xE10 # CEntityOutputTemplate<CUtlSymbolLarge>
    m_OnMapPicked = 0xE38 # CEntityOutputTemplate<CUtlSymbolLarge>
    m_OnSidesPicked = 0xE60 # CEntityOutputTemplate<int32_t>
    m_OnNewPhaseStarted = 0xE88 # CEntityOutputTemplate<int32_t>
    m_OnLevelTransition = 0xEB0 # CEntityOutputTemplate<int32_t>

class CMarkupVolume:
    m_bEnabled = 0x700 # bool

class CMarkupVolumeTagged:
    m_bIsGroup = 0x738 # bool
    m_bGroupByPrefab = 0x739 # bool
    m_bGroupByVolume = 0x73A # bool
    m_bGroupOtherGroups = 0x73B # bool
    m_bIsInGroup = 0x73C # bool

class CMarkupVolumeTagged_NavGame:
    m_bFloodFillAttribute = 0x758 # bool

class CMarkupVolumeWithRef:
    m_bUseRef = 0x740 # bool
    m_vRefPos = 0x744 # Vector
    m_flRefDot = 0x750 # float

class CMathColorBlend:
    m_flInMin = 0x4B0 # float
    m_flInMax = 0x4B4 # float
    m_OutColor1 = 0x4B8 # Color
    m_OutColor2 = 0x4BC # Color
    m_OutValue = 0x4C0 # CEntityOutputTemplate<Color>

class CMathCounter:
    m_flMin = 0x4B0 # float
    m_flMax = 0x4B4 # float
    m_bHitMin = 0x4B8 # bool
    m_bHitMax = 0x4B9 # bool
    m_bDisabled = 0x4BA # bool
    m_OutValue = 0x4C0 # CEntityOutputTemplate<float>
    m_OnGetValue = 0x4E8 # CEntityOutputTemplate<float>
    m_OnHitMin = 0x510 # CEntityIOOutput
    m_OnHitMax = 0x538 # CEntityIOOutput
    m_OnChangedFromMin = 0x560 # CEntityIOOutput
    m_OnChangedFromMax = 0x588 # CEntityIOOutput

class CMathRemap:
    m_flInMin = 0x4B0 # float
    m_flInMax = 0x4B4 # float
    m_flOut1 = 0x4B8 # float
    m_flOut2 = 0x4BC # float
    m_flOldInValue = 0x4C0 # float
    m_bEnabled = 0x4C4 # bool
    m_OutValue = 0x4C8 # CEntityOutputTemplate<float>
    m_OnRoseAboveMin = 0x4F0 # CEntityIOOutput
    m_OnRoseAboveMax = 0x518 # CEntityIOOutput
    m_OnFellBelowMin = 0x540 # CEntityIOOutput
    m_OnFellBelowMax = 0x568 # CEntityIOOutput

class CMelee:
    m_flThrowAt = 0xE20 # GameTime_t
    m_hThrower = 0xE24 # CHandle<CBaseEntity>
    m_bDidThrowDamage = 0xE28 # bool

class CMessage:
    m_iszMessage = 0x4B0 # CUtlSymbolLarge
    m_MessageVolume = 0x4B8 # float
    m_MessageAttenuation = 0x4BC # int32_t
    m_Radius = 0x4C0 # float
    m_sNoise = 0x4C8 # CUtlSymbolLarge
    m_OnShowMessage = 0x4D0 # CEntityIOOutput

class CMessageEntity:
    m_radius = 0x4B0 # int32_t
    m_messageText = 0x4B8 # CUtlSymbolLarge
    m_drawText = 0x4C0 # bool
    m_bDeveloperOnly = 0x4C1 # bool
    m_bEnabled = 0x4C2 # bool

class CModelState:
    m_hModel = 0xA0 # CStrongHandle<InfoForResourceTypeCModel>
    m_ModelName = 0xA8 # CUtlSymbolLarge
    m_bClientClothCreationSuppressed = 0xE8 # bool
    m_MeshGroupMask = 0x180 # uint64_t
    m_nIdealMotionType = 0x222 # int8_t
    m_nForceLOD = 0x223 # int8_t
    m_nClothUpdateFlags = 0x224 # int8_t

class CMolotovProjectile:
    m_bIsIncGrenade = 0xA40 # bool
    m_bDetonated = 0xA4C # bool
    m_stillTimer = 0xA50 # IntervalTimer
    m_bHasBouncedOffPlayer = 0xB30 # bool

class CMomentaryRotButton:
    m_Position = 0x8C8 # CEntityOutputTemplate<float>
    m_OnUnpressed = 0x8F0 # CEntityIOOutput
    m_OnFullyOpen = 0x918 # CEntityIOOutput
    m_OnFullyClosed = 0x940 # CEntityIOOutput
    m_OnReachedPosition = 0x968 # CEntityIOOutput
    m_lastUsed = 0x990 # int32_t
    m_start = 0x994 # QAngle
    m_end = 0x9A0 # QAngle
    m_IdealYaw = 0x9AC # float
    m_sNoise = 0x9B0 # CUtlSymbolLarge
    m_bUpdateTarget = 0x9B8 # bool
    m_direction = 0x9BC # int32_t
    m_returnSpeed = 0x9C0 # float
    m_flStartPosition = 0x9C4 # float

class CMotorController:
    m_speed = 0x8 # float
    m_maxTorque = 0xC # float
    m_axis = 0x10 # Vector
    m_inertiaFactor = 0x1C # float

class CMultiLightProxy:
    m_iszLightNameFilter = 0x4B0 # CUtlSymbolLarge
    m_iszLightClassFilter = 0x4B8 # CUtlSymbolLarge
    m_flLightRadiusFilter = 0x4C0 # float
    m_flBrightnessDelta = 0x4C4 # float
    m_bPerformScreenFade = 0x4C8 # bool
    m_flTargetBrightnessMultiplier = 0x4CC # float
    m_flCurrentBrightnessMultiplier = 0x4D0 # float
    m_vecLights = 0x4D8 # CUtlVector<CHandle<CLightEntity>>

class CMultiSource:
    m_rgEntities = 0x4B0 # CHandle<CBaseEntity>[32]
    m_rgTriggered = 0x530 # int32_t[32]
    m_OnTrigger = 0x5B0 # CEntityIOOutput
    m_iTotal = 0x5D8 # int32_t
    m_globalstate = 0x5E0 # CUtlSymbolLarge

class CMultiplayer_Expresser:
    m_bAllowMultipleScenes = 0x70 # bool

class CNavHullPresetVData:
    m_vecNavHulls = 0x0 # CUtlVector<CUtlString>

class CNavHullVData:
    m_bAgentEnabled = 0x0 # bool
    m_agentRadius = 0x4 # float
    m_agentHeight = 0x8 # float
    m_agentShortHeightEnabled = 0xC # bool
    m_agentShortHeight = 0x10 # float
    m_agentMaxClimb = 0x14 # float
    m_agentMaxSlope = 0x18 # int32_t
    m_agentMaxJumpDownDist = 0x1C # float
    m_agentMaxJumpHorizDistBase = 0x20 # float
    m_agentMaxJumpUpDist = 0x24 # float
    m_agentBorderErosion = 0x28 # int32_t

class CNavLinkAnimgraphVar:
    m_strAnimgraphVar = 0x0 # CUtlString
    m_unAlignmentDegrees = 0x8 # uint32_t

class CNavLinkAreaEntity:
    m_flWidth = 0x4B0 # float
    m_vLocatorOffset = 0x4B4 # Vector
    m_qLocatorAnglesOffset = 0x4C0 # QAngle
    m_strMovementForward = 0x4D0 # CUtlSymbolLarge
    m_strMovementReverse = 0x4D8 # CUtlSymbolLarge
    m_nNavLinkIdForward = 0x4E0 # int32_t
    m_nNavLinkIdReverse = 0x4E4 # int32_t
    m_bEnabled = 0x4E8 # bool
    m_strFilterName = 0x4F0 # CUtlSymbolLarge
    m_hFilter = 0x4F8 # CHandle<CBaseFilter>
    m_OnNavLinkStart = 0x500 # CEntityIOOutput
    m_OnNavLinkFinish = 0x528 # CEntityIOOutput
    m_bIsTerminus = 0x550 # bool

class CNavLinkMovementVData:
    m_bIsInterpolated = 0x0 # bool
    m_unRecommendedDistance = 0x4 # uint32_t
    m_vecAnimgraphVars = 0x8 # CUtlVector<CNavLinkAnimgraphVar>

class CNavSpaceInfo:
    m_bCreateFlightSpace = 0x4B0 # bool

class CNavVolumeBreadthFirstSearch:
    m_vStartPos = 0xA0 # Vector
    m_flSearchDist = 0xAC # float

class CNavVolumeSphere:
    m_vCenter = 0x70 # Vector
    m_flRadius = 0x7C # float

class CNavVolumeSphericalShell:
    m_flRadiusInner = 0x80 # float

class CNavVolumeVector:
    m_bHasBeenPreFiltered = 0x78 # bool

class CNetworkOriginCellCoordQuantizedVector:
    m_cellX = 0x10 # uint16_t
    m_cellY = 0x12 # uint16_t
    m_cellZ = 0x14 # uint16_t
    m_nOutsideWorld = 0x16 # uint16_t
    m_vecX = 0x18 # CNetworkedQuantizedFloat
    m_vecY = 0x20 # CNetworkedQuantizedFloat
    m_vecZ = 0x28 # CNetworkedQuantizedFloat

class CNetworkOriginQuantizedVector:
    m_vecX = 0x10 # CNetworkedQuantizedFloat
    m_vecY = 0x18 # CNetworkedQuantizedFloat
    m_vecZ = 0x20 # CNetworkedQuantizedFloat

class CNetworkTransmitComponent:
    m_nTransmitStateOwnedCounter = 0x16C # uint8_t

class CNetworkVelocityVector:
    m_vecX = 0x10 # CNetworkedQuantizedFloat
    m_vecY = 0x18 # CNetworkedQuantizedFloat
    m_vecZ = 0x20 # CNetworkedQuantizedFloat

class CNetworkViewOffsetVector:
    m_vecX = 0x10 # CNetworkedQuantizedFloat
    m_vecY = 0x18 # CNetworkedQuantizedFloat
    m_vecZ = 0x20 # CNetworkedQuantizedFloat

class CNetworkedSequenceOperation:
    m_hSequence = 0x8 # HSequence
    m_flPrevCycle = 0xC # float
    m_flCycle = 0x10 # float
    m_flWeight = 0x14 # CNetworkedQuantizedFloat
    m_bSequenceChangeNetworked = 0x1C # bool
    m_bDiscontinuity = 0x1D # bool
    m_flPrevCycleFromDiscontinuity = 0x20 # float
    m_flPrevCycleForAnimEventDetection = 0x24 # float

class COmniLight:
    m_flInnerAngle = 0x928 # float
    m_flOuterAngle = 0x92C # float
    m_bShowLight = 0x930 # bool

class COrnamentProp:
    m_initialOwner = 0xB08 # CUtlSymbolLarge

class CParticleSystem:
    m_szSnapshotFileName = 0x700 # char[512]
    m_bActive = 0x900 # bool
    m_bFrozen = 0x901 # bool
    m_flFreezeTransitionDuration = 0x904 # float
    m_nStopType = 0x908 # int32_t
    m_bAnimateDuringGameplayPause = 0x90C # bool
    m_iEffectIndex = 0x910 # CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    m_flStartTime = 0x918 # GameTime_t
    m_flPreSimTime = 0x91C # float
    m_vServerControlPoints = 0x920 # Vector[4]
    m_iServerControlPointAssignments = 0x950 # uint8_t[4]
    m_hControlPointEnts = 0x954 # CHandle<CBaseEntity>[64]
    m_bNoSave = 0xA54 # bool
    m_bNoFreeze = 0xA55 # bool
    m_bNoRamp = 0xA56 # bool
    m_bStartActive = 0xA57 # bool
    m_iszEffectName = 0xA58 # CUtlSymbolLarge
    m_iszControlPointNames = 0xA60 # CUtlSymbolLarge[64]
    m_nDataCP = 0xC60 # int32_t
    m_vecDataCPValue = 0xC64 # Vector
    m_nTintCP = 0xC70 # int32_t
    m_clrTint = 0xC74 # Color

class CPathCorner:
    m_flWait = 0x4B0 # float
    m_flRadius = 0x4B4 # float
    m_OnPass = 0x4B8 # CEntityIOOutput

class CPathKeyFrame:
    m_Origin = 0x4B0 # Vector
    m_Angles = 0x4BC # QAngle
    m_qAngle = 0x4D0 # Quaternion
    m_iNextKey = 0x4E0 # CUtlSymbolLarge
    m_flNextTime = 0x4E8 # float
    m_pNextKey = 0x4F0 # CPathKeyFrame*
    m_pPrevKey = 0x4F8 # CPathKeyFrame*
    m_flSpeed = 0x500 # float

class CPathParticleRope:
    m_bStartActive = 0x4B0 # bool
    m_flMaxSimulationTime = 0x4B4 # float
    m_iszEffectName = 0x4B8 # CUtlSymbolLarge
    m_PathNodes_Name = 0x4C0 # CUtlVector<CUtlSymbolLarge>
    m_flParticleSpacing = 0x4D8 # float
    m_flSlack = 0x4DC # float
    m_flRadius = 0x4E0 # float
    m_ColorTint = 0x4E4 # Color
    m_nEffectState = 0x4E8 # int32_t
    m_iEffectIndex = 0x4F0 # CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    m_PathNodes_Position = 0x4F8 # CNetworkUtlVectorBase<Vector>
    m_PathNodes_TangentIn = 0x510 # CNetworkUtlVectorBase<Vector>
    m_PathNodes_TangentOut = 0x528 # CNetworkUtlVectorBase<Vector>
    m_PathNodes_Color = 0x540 # CNetworkUtlVectorBase<Vector>
    m_PathNodes_PinEnabled = 0x558 # CNetworkUtlVectorBase<bool>
    m_PathNodes_RadiusScale = 0x570 # CNetworkUtlVectorBase<float>

class CPathTrack:
    m_pnext = 0x4B0 # CPathTrack*
    m_pprevious = 0x4B8 # CPathTrack*
    m_paltpath = 0x4C0 # CPathTrack*
    m_flRadius = 0x4C8 # float
    m_length = 0x4CC # float
    m_altName = 0x4D0 # CUtlSymbolLarge
    m_nIterVal = 0x4D8 # int32_t
    m_eOrientationType = 0x4DC # TrackOrientationType_t
    m_OnPass = 0x4E0 # CEntityIOOutput

class CPhysBallSocket:
    m_flFriction = 0x508 # float
    m_bEnableSwingLimit = 0x50C # bool
    m_flSwingLimit = 0x510 # float
    m_bEnableTwistLimit = 0x514 # bool
    m_flMinTwistAngle = 0x518 # float
    m_flMaxTwistAngle = 0x51C # float

class CPhysBox:
    m_damageType = 0x7C0 # int32_t
    m_massScale = 0x7C4 # float
    m_damageToEnableMotion = 0x7C8 # int32_t
    m_flForceToEnableMotion = 0x7CC # float
    m_angPreferredCarryAngles = 0x7D0 # QAngle
    m_bNotSolidToWorld = 0x7DC # bool
    m_bEnableUseOutput = 0x7DD # bool
    m_iExploitableByPlayer = 0x7E0 # int32_t
    m_flTouchOutputPerEntityDelay = 0x7E4 # float
    m_OnDamaged = 0x7E8 # CEntityIOOutput
    m_OnAwakened = 0x810 # CEntityIOOutput
    m_OnMotionEnabled = 0x838 # CEntityIOOutput
    m_OnPlayerUse = 0x860 # CEntityIOOutput
    m_OnStartTouch = 0x888 # CEntityIOOutput
    m_hCarryingPlayer = 0x8B0 # CHandle<CBasePlayerPawn>

class CPhysConstraint:
    m_nameAttach1 = 0x4B8 # CUtlSymbolLarge
    m_nameAttach2 = 0x4C0 # CUtlSymbolLarge
    m_breakSound = 0x4C8 # CUtlSymbolLarge
    m_forceLimit = 0x4D0 # float
    m_torqueLimit = 0x4D4 # float
    m_teleportTick = 0x4D8 # uint32_t
    m_minTeleportDistance = 0x4DC # float
    m_OnBreak = 0x4E0 # CEntityIOOutput

class CPhysExplosion:
    m_bExplodeOnSpawn = 0x4B0 # bool
    m_flMagnitude = 0x4B4 # float
    m_flDamage = 0x4B8 # float
    m_radius = 0x4BC # float
    m_targetEntityName = 0x4C0 # CUtlSymbolLarge
    m_flInnerRadius = 0x4C8 # float
    m_flPushScale = 0x4CC # float
    m_bConvertToDebrisWhenPossible = 0x4D0 # bool
    m_OnPushedPlayer = 0x4D8 # CEntityIOOutput

class CPhysFixed:
    m_flLinearFrequency = 0x508 # float
    m_flLinearDampingRatio = 0x50C # float
    m_flAngularFrequency = 0x510 # float
    m_flAngularDampingRatio = 0x514 # float
    m_bEnableLinearConstraint = 0x518 # bool
    m_bEnableAngularConstraint = 0x519 # bool

class CPhysForce:
    m_nameAttach = 0x4B8 # CUtlSymbolLarge
    m_force = 0x4C0 # float
    m_forceTime = 0x4C4 # float
    m_attachedObject = 0x4C8 # CHandle<CBaseEntity>
    m_wasRestored = 0x4CC # bool
    m_integrator = 0x4D0 # CConstantForceController

class CPhysHinge:
    m_soundInfo = 0x510 # ConstraintSoundInfo
    m_NotifyMinLimitReached = 0x598 # CEntityIOOutput
    m_NotifyMaxLimitReached = 0x5C0 # CEntityIOOutput
    m_bAtMinLimit = 0x5E8 # bool
    m_bAtMaxLimit = 0x5E9 # bool
    m_hinge = 0x5EC # constraint_hingeparams_t
    m_hingeFriction = 0x62C # float
    m_systemLoadScale = 0x630 # float
    m_bIsAxisLocal = 0x634 # bool
    m_flMinRotation = 0x638 # float
    m_flMaxRotation = 0x63C # float
    m_flInitialRotation = 0x640 # float
    m_flMotorFrequency = 0x644 # float
    m_flMotorDampingRatio = 0x648 # float
    m_flAngleSpeed = 0x64C # float
    m_flAngleSpeedThreshold = 0x650 # float
    m_OnStartMoving = 0x658 # CEntityIOOutput
    m_OnStopMoving = 0x680 # CEntityIOOutput

class CPhysImpact:
    m_damage = 0x4B0 # float
    m_distance = 0x4B4 # float
    m_directionEntityName = 0x4B8 # CUtlSymbolLarge

class CPhysLength:
    m_offset = 0x508 # Vector[2]
    m_vecAttach = 0x520 # Vector
    m_addLength = 0x52C # float
    m_minLength = 0x530 # float
    m_totalLength = 0x534 # float
    m_bEnableCollision = 0x538 # bool

class CPhysMagnet:
    m_OnMagnetAttach = 0x890 # CEntityIOOutput
    m_OnMagnetDetach = 0x8B8 # CEntityIOOutput
    m_massScale = 0x8E0 # float
    m_forceLimit = 0x8E4 # float
    m_torqueLimit = 0x8E8 # float
    m_MagnettedEntities = 0x8F0 # CUtlVector<magnetted_objects_t>
    m_bActive = 0x908 # bool
    m_bHasHitSomething = 0x909 # bool
    m_flTotalMass = 0x90C # float
    m_flRadius = 0x910 # float
    m_flNextSuckTime = 0x914 # GameTime_t
    m_iMaxObjectsAttached = 0x918 # int32_t

class CPhysMotor:
    m_nameAttach = 0x4B0 # CUtlSymbolLarge
    m_hAttachedObject = 0x4B8 # CHandle<CBaseEntity>
    m_spinUp = 0x4BC # float
    m_additionalAcceleration = 0x4C0 # float
    m_angularAcceleration = 0x4C4 # float
    m_lastTime = 0x4C8 # GameTime_t
    m_motor = 0x4E0 # CMotorController

class CPhysPulley:
    m_position2 = 0x508 # Vector
    m_offset = 0x514 # Vector[2]
    m_addLength = 0x52C # float
    m_gearRatio = 0x530 # float

class CPhysSlideConstraint:
    m_axisEnd = 0x510 # Vector
    m_slideFriction = 0x51C # float
    m_systemLoadScale = 0x520 # float
    m_initialOffset = 0x524 # float
    m_bEnableLinearConstraint = 0x528 # bool
    m_bEnableAngularConstraint = 0x529 # bool
    m_flMotorFrequency = 0x52C # float
    m_flMotorDampingRatio = 0x530 # float
    m_bUseEntityPivot = 0x534 # bool
    m_soundInfo = 0x538 # ConstraintSoundInfo

class CPhysThruster:
    m_localOrigin = 0x510 # Vector

class CPhysTorque:
    m_axis = 0x510 # Vector

class CPhysWheelConstraint:
    m_flSuspensionFrequency = 0x508 # float
    m_flSuspensionDampingRatio = 0x50C # float
    m_flSuspensionHeightOffset = 0x510 # float
    m_bEnableSuspensionLimit = 0x514 # bool
    m_flMinSuspensionOffset = 0x518 # float
    m_flMaxSuspensionOffset = 0x51C # float
    m_bEnableSteeringLimit = 0x520 # bool
    m_flMinSteeringAngle = 0x524 # float
    m_flMaxSteeringAngle = 0x528 # float
    m_flSteeringAxisFriction = 0x52C # float
    m_flSpinAxisFriction = 0x530 # float

class CPhysicsEntitySolver:
    m_hMovingEntity = 0x4B8 # CHandle<CBaseEntity>
    m_hPhysicsBlocker = 0x4BC # CHandle<CBaseEntity>
    m_separationDuration = 0x4C0 # float
    m_cancelTime = 0x4C4 # GameTime_t

class CPhysicsProp:
    m_MotionEnabled = 0xA10 # CEntityIOOutput
    m_OnAwakened = 0xA38 # CEntityIOOutput
    m_OnAwake = 0xA60 # CEntityIOOutput
    m_OnAsleep = 0xA88 # CEntityIOOutput
    m_OnPlayerUse = 0xAB0 # CEntityIOOutput
    m_OnPlayerPickup = 0xAD8 # CEntityIOOutput
    m_OnOutOfWorld = 0xB00 # CEntityIOOutput
    m_massScale = 0xB28 # float
    m_inertiaScale = 0xB2C # float
    m_buoyancyScale = 0xB30 # float
    m_damageType = 0xB34 # int32_t
    m_damageToEnableMotion = 0xB38 # int32_t
    m_flForceToEnableMotion = 0xB3C # float
    m_bThrownByPlayer = 0xB40 # bool
    m_bDroppedByPlayer = 0xB41 # bool
    m_bTouchedByPlayer = 0xB42 # bool
    m_bFirstCollisionAfterLaunch = 0xB43 # bool
    m_iExploitableByPlayer = 0xB44 # int32_t
    m_bHasBeenAwakened = 0xB48 # bool
    m_bIsOverrideProp = 0xB49 # bool
    m_fNextCheckDisableMotionContactsTime = 0xB4C # GameTime_t
    m_iInitialGlowState = 0xB50 # int32_t
    m_nGlowRange = 0xB54 # int32_t
    m_nGlowRangeMin = 0xB58 # int32_t
    m_glowColor = 0xB5C # Color
    m_bForceNavIgnore = 0xB60 # bool
    m_bNoNavmeshBlocker = 0xB61 # bool
    m_bForceNpcExclude = 0xB62 # bool
    m_bShouldAutoConvertBackFromDebris = 0xB63 # bool
    m_bMuteImpactEffects = 0xB64 # bool
    m_bAcceptDamageFromHeldObjects = 0xB6C # bool
    m_bEnableUseOutput = 0xB6D # bool
    m_bAwake = 0xB6E # bool
    m_nCollisionGroupOverride = 0xB70 # int32_t

class CPhysicsPropRespawnable:
    m_vOriginalSpawnOrigin = 0xB78 # Vector
    m_vOriginalSpawnAngles = 0xB84 # QAngle
    m_vOriginalMins = 0xB90 # Vector
    m_vOriginalMaxs = 0xB9C # Vector
    m_flRespawnDuration = 0xBA8 # float

class CPhysicsShake:
    m_force = 0x8 # Vector

class CPhysicsSpring:
    m_flFrequency = 0x4B8 # float
    m_flDampingRatio = 0x4BC # float
    m_flRestLength = 0x4C0 # float
    m_nameAttachStart = 0x4C8 # CUtlSymbolLarge
    m_nameAttachEnd = 0x4D0 # CUtlSymbolLarge
    m_start = 0x4D8 # Vector
    m_end = 0x4E4 # Vector
    m_teleportTick = 0x4F0 # uint32_t

class CPhysicsWire:
    m_nDensity = 0x4B0 # int32_t

class CPlantedC4:
    m_bBombTicking = 0x890 # bool
    m_flC4Blow = 0x894 # GameTime_t
    m_nBombSite = 0x898 # int32_t
    m_nSourceSoundscapeHash = 0x89C # int32_t
    m_OnBombDefused = 0x8A0 # CEntityIOOutput
    m_OnBombBeginDefuse = 0x8C8 # CEntityIOOutput
    m_OnBombDefuseAborted = 0x8F0 # CEntityIOOutput
    m_bCannotBeDefused = 0x918 # bool
    m_entitySpottedState = 0x920 # EntitySpottedState_t
    m_nSpotRules = 0x938 # int32_t
    m_bTrainingPlacedByPlayer = 0x93C # bool
    m_bHasExploded = 0x93D # bool
    m_flTimerLength = 0x940 # float
    m_bBeingDefused = 0x944 # bool
    m_fLastDefuseTime = 0x94C # GameTime_t
    m_flDefuseLength = 0x954 # float
    m_flDefuseCountDown = 0x958 # GameTime_t
    m_bBombDefused = 0x95C # bool
    m_hBombDefuser = 0x960 # CHandle<CCSPlayerPawn>
    m_hControlPanel = 0x964 # CHandle<CBaseEntity>
    m_iProgressBarTime = 0x968 # int32_t
    m_bVoiceAlertFired = 0x96C # bool
    m_bVoiceAlertPlayed = 0x96D # bool[4]
    m_flNextBotBeepTime = 0x974 # GameTime_t
    m_bPlantedAfterPickup = 0x97C # bool
    m_angCatchUpToPlayerEye = 0x980 # QAngle
    m_flLastSpinDetectionTime = 0x98C # GameTime_t

class CPlatTrigger:
    m_pPlatform = 0x700 # CHandle<CFuncPlat>

class CPlayerControllerComponent:
    __m_pChainEntity = 0x8 # CNetworkVarChainer

class CPlayerPawnComponent:
    __m_pChainEntity = 0x8 # CNetworkVarChainer

class CPlayerPing:
    m_hPlayer = 0x4B8 # CHandle<CCSPlayerPawn>
    m_hPingedEntity = 0x4BC # CHandle<CBaseEntity>
    m_iType = 0x4C0 # int32_t
    m_bUrgent = 0x4C4 # bool
    m_szPlaceName = 0x4C5 # char[18]

class CPlayerSprayDecal:
    m_nUniqueID = 0x700 # int32_t
    m_unAccountID = 0x704 # uint32_t
    m_unTraceID = 0x708 # uint32_t
    m_rtGcTime = 0x70C # uint32_t
    m_vecEndPos = 0x710 # Vector
    m_vecStart = 0x71C # Vector
    m_vecLeft = 0x728 # Vector
    m_vecNormal = 0x734 # Vector
    m_nPlayer = 0x740 # int32_t
    m_nEntity = 0x744 # int32_t
    m_nHitbox = 0x748 # int32_t
    m_flCreationTime = 0x74C # float
    m_nTintID = 0x750 # int32_t
    m_nVersion = 0x754 # uint8_t
    m_ubSignature = 0x755 # uint8_t[128]

class CPlayerVisibility:
    m_flVisibilityStrength = 0x4B0 # float
    m_flFogDistanceMultiplier = 0x4B4 # float
    m_flFogMaxDensityMultiplier = 0x4B8 # float
    m_flFadeTime = 0x4BC # float
    m_bStartDisabled = 0x4C0 # bool
    m_bIsEnabled = 0x4C1 # bool

class CPlayer_CameraServices:
    m_vecCsViewPunchAngle = 0x40 # QAngle
    m_nCsViewPunchAngleTick = 0x4C # GameTick_t
    m_flCsViewPunchAngleTickRatio = 0x50 # float
    m_PlayerFog = 0x58 # fogplayerparams_t
    m_hColorCorrectionCtrl = 0x98 # CHandle<CColorCorrection>
    m_hViewEntity = 0x9C # CHandle<CBaseEntity>
    m_hTonemapController = 0xA0 # CHandle<CTonemapController2>
    m_audio = 0xA8 # audioparams_t
    m_PostProcessingVolumes = 0x120 # CNetworkUtlVectorBase<CHandle<CPostProcessingVolume>>
    m_flOldPlayerZ = 0x138 # float
    m_flOldPlayerViewOffsetZ = 0x13C # float
    m_hTriggerSoundscapeList = 0x158 # CUtlVector<CHandle<CEnvSoundscapeTriggerable>>

class CPlayer_MovementServices:
    m_nImpulse = 0x40 # int32_t
    m_nButtons = 0x48 # CInButtonState
    m_nQueuedButtonDownMask = 0x68 # uint64_t
    m_nQueuedButtonChangeMask = 0x70 # uint64_t
    m_nButtonDoublePressed = 0x78 # uint64_t
    m_pButtonPressedCmdNumber = 0x80 # uint32_t[64]
    m_nLastCommandNumberProcessed = 0x180 # uint32_t
    m_nToggleButtonDownMask = 0x188 # uint64_t
    m_flMaxspeed = 0x190 # float
    m_arrForceSubtickMoveWhen = 0x194 # float[4]
    m_flForwardMove = 0x1A4 # float
    m_flLeftMove = 0x1A8 # float
    m_flUpMove = 0x1AC # float
    m_vecLastMovementImpulses = 0x1B0 # Vector
    m_vecOldViewAngles = 0x1BC # QAngle

class CPlayer_MovementServices_Humanoid:
    m_flStepSoundTime = 0x1D0 # float
    m_flFallVelocity = 0x1D4 # float
    m_bInCrouch = 0x1D8 # bool
    m_nCrouchState = 0x1DC # uint32_t
    m_flCrouchTransitionStartTime = 0x1E0 # GameTime_t
    m_bDucked = 0x1E4 # bool
    m_bDucking = 0x1E5 # bool
    m_bInDuckJump = 0x1E6 # bool
    m_groundNormal = 0x1E8 # Vector
    m_flSurfaceFriction = 0x1F4 # float
    m_surfaceProps = 0x1F8 # CUtlStringToken
    m_nStepside = 0x208 # int32_t
    m_iTargetVolume = 0x20C # int32_t
    m_vecSmoothedVelocity = 0x210 # Vector

class CPlayer_ObserverServices:
    m_iObserverMode = 0x40 # uint8_t
    m_hObserverTarget = 0x44 # CHandle<CBaseEntity>
    m_iObserverLastMode = 0x48 # ObserverMode_t
    m_bForcedObserverMode = 0x4C # bool

class CPlayer_WeaponServices:
    m_bAllowSwitchToNoWeapon = 0x40 # bool
    m_hMyWeapons = 0x48 # CNetworkUtlVectorBase<CHandle<CBasePlayerWeapon>>
    m_hActiveWeapon = 0x60 # CHandle<CBasePlayerWeapon>
    m_hLastWeapon = 0x64 # CHandle<CBasePlayerWeapon>
    m_iAmmo = 0x68 # uint16_t[32]
    m_bPreventWeaponPickup = 0xA8 # bool

class CPointAngleSensor:
    m_bDisabled = 0x4B0 # bool
    m_nLookAtName = 0x4B8 # CUtlSymbolLarge
    m_hTargetEntity = 0x4C0 # CHandle<CBaseEntity>
    m_hLookAtEntity = 0x4C4 # CHandle<CBaseEntity>
    m_flDuration = 0x4C8 # float
    m_flDotTolerance = 0x4CC # float
    m_flFacingTime = 0x4D0 # GameTime_t
    m_bFired = 0x4D4 # bool
    m_OnFacingLookat = 0x4D8 # CEntityIOOutput
    m_OnNotFacingLookat = 0x500 # CEntityIOOutput
    m_TargetDir = 0x528 # CEntityOutputTemplate<Vector>
    m_FacingPercentage = 0x550 # CEntityOutputTemplate<float>

class CPointAngularVelocitySensor:
    m_hTargetEntity = 0x4B0 # CHandle<CBaseEntity>
    m_flThreshold = 0x4B4 # float
    m_nLastCompareResult = 0x4B8 # int32_t
    m_nLastFireResult = 0x4BC # int32_t
    m_flFireTime = 0x4C0 # GameTime_t
    m_flFireInterval = 0x4C4 # float
    m_flLastAngVelocity = 0x4C8 # float
    m_lastOrientation = 0x4CC # QAngle
    m_vecAxis = 0x4D8 # Vector
    m_bUseHelper = 0x4E4 # bool
    m_AngularVelocity = 0x4E8 # CEntityOutputTemplate<float>
    m_OnLessThan = 0x510 # CEntityIOOutput
    m_OnLessThanOrEqualTo = 0x538 # CEntityIOOutput
    m_OnGreaterThan = 0x560 # CEntityIOOutput
    m_OnGreaterThanOrEqualTo = 0x588 # CEntityIOOutput
    m_OnEqualTo = 0x5B0 # CEntityIOOutput

class CPointCamera:
    m_FOV = 0x4B0 # float
    m_Resolution = 0x4B4 # float
    m_bFogEnable = 0x4B8 # bool
    m_FogColor = 0x4B9 # Color
    m_flFogStart = 0x4C0 # float
    m_flFogEnd = 0x4C4 # float
    m_flFogMaxDensity = 0x4C8 # float
    m_bActive = 0x4CC # bool
    m_bUseScreenAspectRatio = 0x4CD # bool
    m_flAspectRatio = 0x4D0 # float
    m_bNoSky = 0x4D4 # bool
    m_fBrightness = 0x4D8 # float
    m_flZFar = 0x4DC # float
    m_flZNear = 0x4E0 # float
    m_bCanHLTVUse = 0x4E4 # bool
    m_bDofEnabled = 0x4E5 # bool
    m_flDofNearBlurry = 0x4E8 # float
    m_flDofNearCrisp = 0x4EC # float
    m_flDofFarCrisp = 0x4F0 # float
    m_flDofFarBlurry = 0x4F4 # float
    m_flDofTiltToGround = 0x4F8 # float
    m_TargetFOV = 0x4FC # float
    m_DegreesPerSecond = 0x500 # float
    m_bIsOn = 0x504 # bool
    m_pNext = 0x508 # CPointCamera*

class CPointCameraVFOV:
    m_flVerticalFOV = 0x510 # float

class CPointClientUIDialog:
    m_hActivator = 0x8B0 # CHandle<CBaseEntity>
    m_bStartEnabled = 0x8B4 # bool

class CPointClientUIWorldPanel:
    m_bIgnoreInput = 0x8B0 # bool
    m_bLit = 0x8B1 # bool
    m_bFollowPlayerAcrossTeleport = 0x8B2 # bool
    m_flWidth = 0x8B4 # float
    m_flHeight = 0x8B8 # float
    m_flDPI = 0x8BC # float
    m_flInteractDistance = 0x8C0 # float
    m_flDepthOffset = 0x8C4 # float
    m_unOwnerContext = 0x8C8 # uint32_t
    m_unHorizontalAlign = 0x8CC # uint32_t
    m_unVerticalAlign = 0x8D0 # uint32_t
    m_unOrientation = 0x8D4 # uint32_t
    m_bAllowInteractionFromAllSceneWorlds = 0x8D8 # bool
    m_vecCSSClasses = 0x8E0 # CNetworkUtlVectorBase<CUtlSymbolLarge>
    m_bOpaque = 0x8F8 # bool
    m_bNoDepth = 0x8F9 # bool
    m_bRenderBackface = 0x8FA # bool
    m_bUseOffScreenIndicator = 0x8FB # bool
    m_bExcludeFromSaveGames = 0x8FC # bool
    m_bGrabbable = 0x8FD # bool
    m_bOnlyRenderToTexture = 0x8FE # bool
    m_bDisableMipGen = 0x8FF # bool
    m_nExplicitImageLayout = 0x900 # int32_t

class CPointClientUIWorldTextPanel:
    m_messageText = 0x908 # char[512]

class CPointCommentaryNode:
    m_iszPreCommands = 0x890 # CUtlSymbolLarge
    m_iszPostCommands = 0x898 # CUtlSymbolLarge
    m_iszCommentaryFile = 0x8A0 # CUtlSymbolLarge
    m_iszViewTarget = 0x8A8 # CUtlSymbolLarge
    m_hViewTarget = 0x8B0 # CHandle<CBaseEntity>
    m_hViewTargetAngles = 0x8B4 # CHandle<CBaseEntity>
    m_iszViewPosition = 0x8B8 # CUtlSymbolLarge
    m_hViewPosition = 0x8C0 # CHandle<CBaseEntity>
    m_hViewPositionMover = 0x8C4 # CHandle<CBaseEntity>
    m_bPreventMovement = 0x8C8 # bool
    m_bUnderCrosshair = 0x8C9 # bool
    m_bUnstoppable = 0x8CA # bool
    m_flFinishedTime = 0x8CC # GameTime_t
    m_vecFinishOrigin = 0x8D0 # Vector
    m_vecOriginalAngles = 0x8DC # QAngle
    m_vecFinishAngles = 0x8E8 # QAngle
    m_bPreventChangesWhileMoving = 0x8F4 # bool
    m_bDisabled = 0x8F5 # bool
    m_vecTeleportOrigin = 0x8F8 # Vector
    m_flAbortedPlaybackAt = 0x904 # GameTime_t
    m_pOnCommentaryStarted = 0x908 # CEntityIOOutput
    m_pOnCommentaryStopped = 0x930 # CEntityIOOutput
    m_bActive = 0x958 # bool
    m_flStartTime = 0x95C # GameTime_t
    m_flStartTimeInCommentary = 0x960 # float
    m_iszTitle = 0x968 # CUtlSymbolLarge
    m_iszSpeakers = 0x970 # CUtlSymbolLarge
    m_iNodeNumber = 0x978 # int32_t
    m_iNodeNumberMax = 0x97C # int32_t
    m_bListenedTo = 0x980 # bool

class CPointEntityFinder:
    m_hEntity = 0x4B0 # CHandle<CBaseEntity>
    m_iFilterName = 0x4B8 # CUtlSymbolLarge
    m_hFilter = 0x4C0 # CHandle<CBaseFilter>
    m_iRefName = 0x4C8 # CUtlSymbolLarge
    m_hReference = 0x4D0 # CHandle<CBaseEntity>
    m_FindMethod = 0x4D4 # EntFinderMethod_t
    m_OnFoundEntity = 0x4D8 # CEntityIOOutput

class CPointGamestatsCounter:
    m_strStatisticName = 0x4B0 # CUtlSymbolLarge
    m_bDisabled = 0x4B8 # bool

class CPointGiveAmmo:
    m_pActivator = 0x4B0 # CHandle<CBaseEntity>

class CPointHurt:
    m_nDamage = 0x4B0 # int32_t
    m_bitsDamageType = 0x4B4 # int32_t
    m_flRadius = 0x4B8 # float
    m_flDelay = 0x4BC # float
    m_strTarget = 0x4C0 # CUtlSymbolLarge
    m_pActivator = 0x4C8 # CHandle<CBaseEntity>

class CPointPrefab:
    m_targetMapName = 0x4B0 # CUtlSymbolLarge
    m_forceWorldGroupID = 0x4B8 # CUtlSymbolLarge
    m_associatedRelayTargetName = 0x4C0 # CUtlSymbolLarge
    m_fixupNames = 0x4C8 # bool
    m_bLoadDynamic = 0x4C9 # bool
    m_associatedRelayEntity = 0x4CC # CHandle<CPointPrefab>

class CPointProximitySensor:
    m_bDisabled = 0x4B0 # bool
    m_hTargetEntity = 0x4B4 # CHandle<CBaseEntity>
    m_Distance = 0x4B8 # CEntityOutputTemplate<float>

class CPointPulse:
    m_sNameFixupStaticPrefix = 0x5C8 # CUtlSymbolLarge
    m_sNameFixupParent = 0x5D0 # CUtlSymbolLarge
    m_sNameFixupLocal = 0x5D8 # CUtlSymbolLarge

class CPointPush:
    m_bEnabled = 0x4B0 # bool
    m_flMagnitude = 0x4B4 # float
    m_flRadius = 0x4B8 # float
    m_flInnerRadius = 0x4BC # float
    m_flConeOfInfluence = 0x4C0 # float
    m_iszFilterName = 0x4C8 # CUtlSymbolLarge
    m_hFilter = 0x4D0 # CHandle<CBaseFilter>

class CPointTeleport:
    m_vSaveOrigin = 0x4B0 # Vector
    m_vSaveAngles = 0x4BC # QAngle
    m_bTeleportParentedEntities = 0x4C8 # bool
    m_bTeleportUseCurrentAngle = 0x4C9 # bool

class CPointTemplate:
    m_iszWorldName = 0x4B0 # CUtlSymbolLarge
    m_iszSource2EntityLumpName = 0x4B8 # CUtlSymbolLarge
    m_iszEntityFilterName = 0x4C0 # CUtlSymbolLarge
    m_flTimeoutInterval = 0x4C8 # float
    m_bAsynchronouslySpawnEntities = 0x4CC # bool
    m_pOutputOnSpawned = 0x4D0 # CEntityIOOutput
    m_clientOnlyEntityBehavior = 0x4F8 # PointTemplateClientOnlyEntityBehavior_t
    m_ownerSpawnGroupType = 0x4FC # PointTemplateOwnerSpawnGroupType_t
    m_createdSpawnGroupHandles = 0x500 # CUtlVector<uint32_t>
    m_SpawnedEntityHandles = 0x518 # CUtlVector<CEntityHandle>
    m_ScriptSpawnCallback = 0x530 # HSCRIPT
    m_ScriptCallbackScope = 0x538 # HSCRIPT

class CPointValueRemapper:
    m_bDisabled = 0x4B0 # bool
    m_bUpdateOnClient = 0x4B1 # bool
    m_nInputType = 0x4B4 # ValueRemapperInputType_t
    m_iszRemapLineStartName = 0x4B8 # CUtlSymbolLarge
    m_iszRemapLineEndName = 0x4C0 # CUtlSymbolLarge
    m_hRemapLineStart = 0x4C8 # CHandle<CBaseEntity>
    m_hRemapLineEnd = 0x4CC # CHandle<CBaseEntity>
    m_flMaximumChangePerSecond = 0x4D0 # float
    m_flDisengageDistance = 0x4D4 # float
    m_flEngageDistance = 0x4D8 # float
    m_bRequiresUseKey = 0x4DC # bool
    m_nOutputType = 0x4E0 # ValueRemapperOutputType_t
    m_iszOutputEntityName = 0x4E8 # CUtlSymbolLarge
    m_iszOutputEntity2Name = 0x4F0 # CUtlSymbolLarge
    m_iszOutputEntity3Name = 0x4F8 # CUtlSymbolLarge
    m_iszOutputEntity4Name = 0x500 # CUtlSymbolLarge
    m_hOutputEntities = 0x508 # CNetworkUtlVectorBase<CHandle<CBaseEntity>>
    m_nHapticsType = 0x520 # ValueRemapperHapticsType_t
    m_nMomentumType = 0x524 # ValueRemapperMomentumType_t
    m_flMomentumModifier = 0x528 # float
    m_flSnapValue = 0x52C # float
    m_flCurrentMomentum = 0x530 # float
    m_nRatchetType = 0x534 # ValueRemapperRatchetType_t
    m_flRatchetOffset = 0x538 # float
    m_flInputOffset = 0x53C # float
    m_bEngaged = 0x540 # bool
    m_bFirstUpdate = 0x541 # bool
    m_flPreviousValue = 0x544 # float
    m_flPreviousUpdateTickTime = 0x548 # GameTime_t
    m_vecPreviousTestPoint = 0x54C # Vector
    m_hUsingPlayer = 0x558 # CHandle<CBasePlayerPawn>
    m_flCustomOutputValue = 0x55C # float
    m_iszSoundEngage = 0x560 # CUtlSymbolLarge
    m_iszSoundDisengage = 0x568 # CUtlSymbolLarge
    m_iszSoundReachedValueZero = 0x570 # CUtlSymbolLarge
    m_iszSoundReachedValueOne = 0x578 # CUtlSymbolLarge
    m_iszSoundMovingLoop = 0x580 # CUtlSymbolLarge
    m_Position = 0x590 # CEntityOutputTemplate<float>
    m_PositionDelta = 0x5B8 # CEntityOutputTemplate<float>
    m_OnReachedValueZero = 0x5E0 # CEntityIOOutput
    m_OnReachedValueOne = 0x608 # CEntityIOOutput
    m_OnReachedValueCustom = 0x630 # CEntityIOOutput
    m_OnEngage = 0x658 # CEntityIOOutput
    m_OnDisengage = 0x680 # CEntityIOOutput

class CPointVelocitySensor:
    m_hTargetEntity = 0x4B0 # CHandle<CBaseEntity>
    m_vecAxis = 0x4B4 # Vector
    m_bEnabled = 0x4C0 # bool
    m_fPrevVelocity = 0x4C4 # float
    m_flAvgInterval = 0x4C8 # float
    m_Velocity = 0x4D0 # CEntityOutputTemplate<float>

class CPointWorldText:
    m_messageText = 0x700 # char[512]
    m_FontName = 0x900 # char[64]
    m_bEnabled = 0x940 # bool
    m_bFullbright = 0x941 # bool
    m_flWorldUnitsPerPx = 0x944 # float
    m_flFontSize = 0x948 # float
    m_flDepthOffset = 0x94C # float
    m_Color = 0x950 # Color
    m_nJustifyHorizontal = 0x954 # PointWorldTextJustifyHorizontal_t
    m_nJustifyVertical = 0x958 # PointWorldTextJustifyVertical_t
    m_nReorientMode = 0x95C # PointWorldTextReorientMode_t

class CPostProcessingVolume:
    m_hPostSettings = 0x8B8 # CStrongHandle<InfoForResourceTypeCPostProcessingResource>
    m_flFadeDuration = 0x8C0 # float
    m_flMinLogExposure = 0x8C4 # float
    m_flMaxLogExposure = 0x8C8 # float
    m_flMinExposure = 0x8CC # float
    m_flMaxExposure = 0x8D0 # float
    m_flExposureCompensation = 0x8D4 # float
    m_flExposureFadeSpeedUp = 0x8D8 # float
    m_flExposureFadeSpeedDown = 0x8DC # float
    m_flTonemapEVSmoothingRange = 0x8E0 # float
    m_bMaster = 0x8E4 # bool
    m_bExposureControl = 0x8E5 # bool
    m_flRate = 0x8E8 # float
    m_flTonemapPercentTarget = 0x8EC # float
    m_flTonemapPercentBrightPixels = 0x8F0 # float
    m_flTonemapMinAvgLum = 0x8F4 # float

class CPrecipitationVData:
    m_szParticlePrecipitationEffect = 0x28 # CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    m_flInnerDistance = 0x108 # float
    m_nAttachType = 0x10C # ParticleAttachment_t
    m_bBatchSameVolumeType = 0x110 # bool
    m_nRTEnvCP = 0x114 # int32_t
    m_nRTEnvCPComponent = 0x118 # int32_t
    m_szModifier = 0x120 # CUtlString

class CProjectedDecal:
    m_nTexture = 0x4B0 # int32_t
    m_flDistance = 0x4B4 # float

class CPropDoorRotating:
    m_vecAxis = 0xD98 # Vector
    m_flDistance = 0xDA4 # float
    m_eSpawnPosition = 0xDA8 # PropDoorRotatingSpawnPos_t
    m_eOpenDirection = 0xDAC # PropDoorRotatingOpenDirection_e
    m_eCurrentOpenDirection = 0xDB0 # PropDoorRotatingOpenDirection_e
    m_flAjarAngle = 0xDB4 # float
    m_angRotationAjarDeprecated = 0xDB8 # QAngle
    m_angRotationClosed = 0xDC4 # QAngle
    m_angRotationOpenForward = 0xDD0 # QAngle
    m_angRotationOpenBack = 0xDDC # QAngle
    m_angGoal = 0xDE8 # QAngle
    m_vecForwardBoundsMin = 0xDF4 # Vector
    m_vecForwardBoundsMax = 0xE00 # Vector
    m_vecBackBoundsMin = 0xE0C # Vector
    m_vecBackBoundsMax = 0xE18 # Vector
    m_bAjarDoorShouldntAlwaysOpen = 0xE24 # bool
    m_hEntityBlocker = 0xE28 # CHandle<CEntityBlocker>

class CPropDoorRotatingBreakable:
    m_bBreakable = 0xE30 # bool
    m_isAbleToCloseAreaPortals = 0xE31 # bool
    m_currentDamageState = 0xE34 # int32_t
    m_damageStates = 0xE38 # CUtlVector<CUtlSymbolLarge>

class CPulseCell_Inflow_GameEvent:
    m_EventName = 0x70 # CBufferString

class CPulseCell_Outflow_PlayVCD:
    m_vcdFilename = 0x48 # CUtlString
    m_OnFinished = 0x50 # CPulse_OutflowConnection
    m_Triggers = 0x60 # CUtlVector<CPulse_OutflowConnection>

class CPulseCell_SoundEventStart:
    m_Type = 0x48 # SoundEventStartType_t

class CPulseCell_Step_EntFire:
    m_Input = 0x48 # CUtlString

class CPulseCell_Step_SetAnimGraphParam:
    m_ParamName = 0x48 # CUtlString

class CPulseCell_Value_FindEntByName:
    m_EntityType = 0x48 # CUtlString

class CRR_Response:
    m_Type = 0x0 # uint8_t
    m_szResponseName = 0x1 # char[192]
    m_szMatchingRule = 0xC1 # char[128]
    m_Params = 0x148 # ResponseParams
    m_fMatchScore = 0x168 # float
    m_szSpeakerContext = 0x170 # char*
    m_szWorldContext = 0x178 # char*
    m_Followup = 0x180 # ResponseFollowup
    m_pchCriteriaNames = 0x1B8 # CUtlVector<CUtlSymbol>
    m_pchCriteriaValues = 0x1D0 # CUtlVector<char*>

class CRagdollConstraint:
    m_xmin = 0x508 # float
    m_xmax = 0x50C # float
    m_ymin = 0x510 # float
    m_ymax = 0x514 # float
    m_zmin = 0x518 # float
    m_zmax = 0x51C # float
    m_xfriction = 0x520 # float
    m_yfriction = 0x524 # float
    m_zfriction = 0x528 # float

class CRagdollMagnet:
    m_bDisabled = 0x4B0 # bool
    m_radius = 0x4B4 # float
    m_force = 0x4B8 # float
    m_axis = 0x4BC # Vector

class CRagdollManager:
    m_iCurrentMaxRagdollCount = 0x4B0 # int8_t
    m_iMaxRagdollCount = 0x4B4 # int32_t
    m_bSaveImportant = 0x4B8 # bool

class CRagdollProp:
    m_ragdoll = 0x898 # ragdoll_t
    m_bStartDisabled = 0x8D0 # bool
    m_ragPos = 0x8D8 # CNetworkUtlVectorBase<Vector>
    m_ragAngles = 0x8F0 # CNetworkUtlVectorBase<QAngle>
    m_hRagdollSource = 0x908 # CHandle<CBaseEntity>
    m_lastUpdateTickCount = 0x90C # uint32_t
    m_allAsleep = 0x910 # bool
    m_bFirstCollisionAfterLaunch = 0x911 # bool
    m_hDamageEntity = 0x914 # CHandle<CBaseEntity>
    m_hKiller = 0x918 # CHandle<CBaseEntity>
    m_hPhysicsAttacker = 0x91C # CHandle<CBasePlayerPawn>
    m_flLastPhysicsInfluenceTime = 0x920 # GameTime_t
    m_flFadeOutStartTime = 0x924 # GameTime_t
    m_flFadeTime = 0x928 # float
    m_vecLastOrigin = 0x92C # Vector
    m_flAwakeTime = 0x938 # GameTime_t
    m_flLastOriginChangeTime = 0x93C # GameTime_t
    m_nBloodColor = 0x940 # int32_t
    m_strOriginClassName = 0x948 # CUtlSymbolLarge
    m_strSourceClassName = 0x950 # CUtlSymbolLarge
    m_bHasBeenPhysgunned = 0x958 # bool
    m_bShouldTeleportPhysics = 0x959 # bool
    m_flBlendWeight = 0x95C # float
    m_flDefaultFadeScale = 0x960 # float
    m_ragdollMins = 0x968 # CUtlVector<Vector>
    m_ragdollMaxs = 0x980 # CUtlVector<Vector>
    m_bShouldDeleteActivationRecord = 0x998 # bool
    m_bValidatePoweredRagdollPose = 0x9F8 # bool

class CRagdollPropAttached:
    m_boneIndexAttached = 0xA38 # uint32_t
    m_ragdollAttachedObjectIndex = 0xA3C # uint32_t
    m_attachmentPointBoneSpace = 0xA40 # Vector
    m_attachmentPointRagdollSpace = 0xA4C # Vector
    m_bShouldDetach = 0xA58 # bool
    m_bShouldDeleteAttachedActivationRecord = 0xA68 # bool

class CRandSimTimer:
    m_minInterval = 0x8 # float
    m_maxInterval = 0xC # float

class CRandStopwatch:
    m_minInterval = 0xC # float
    m_maxInterval = 0x10 # float

class CRangeFloat:
    m_pValue = 0x0 # float[2]

class CRangeInt:
    m_pValue = 0x0 # int32_t[2]

class CRectLight:
    m_bShowLight = 0x928 # bool

class CRemapFloat:
    m_pValue = 0x0 # float[4]

class CRenderComponent:
    __m_pChainEntity = 0x10 # CNetworkVarChainer
    m_bIsRenderingWithViewModels = 0x50 # bool
    m_nSplitscreenFlags = 0x54 # uint32_t
    m_bEnableRendering = 0x60 # bool
    m_bInterpolationReadyToDraw = 0xB0 # bool

class CResponseCriteriaSet:
    m_nNumPrefixedContexts = 0x28 # int32_t
    m_bOverrideOnAppend = 0x2C # bool

class CResponseQueue:
    m_ExpresserTargets = 0x50 # CUtlVector<CAI_Expresser*>

class CResponseQueue_CDeferredResponse:
    m_contexts = 0x10 # CResponseCriteriaSet
    m_fDispatchTime = 0x40 # float
    m_hIssuer = 0x44 # CHandle<CBaseEntity>
    m_response = 0x50 # CRR_Response
    m_bResponseValid = 0x238 # bool

class CRetakeGameRules:
    m_nMatchSeed = 0xF8 # int32_t
    m_bBlockersPresent = 0xFC # bool
    m_bRoundInProgress = 0xFD # bool
    m_iFirstSecondHalfRound = 0x100 # int32_t
    m_iBombSite = 0x104 # int32_t

class CRevertSaved:
    m_loadTime = 0x700 # float
    m_Duration = 0x704 # float
    m_HoldTime = 0x708 # float

class CRopeKeyframe:
    m_RopeFlags = 0x708 # uint16_t
    m_iNextLinkName = 0x710 # CUtlSymbolLarge
    m_Slack = 0x718 # int16_t
    m_Width = 0x71C # float
    m_TextureScale = 0x720 # float
    m_nSegments = 0x724 # uint8_t
    m_bConstrainBetweenEndpoints = 0x725 # bool
    m_strRopeMaterialModel = 0x728 # CUtlSymbolLarge
    m_iRopeMaterialModelIndex = 0x730 # CStrongHandle<InfoForResourceTypeIMaterial2>
    m_Subdiv = 0x738 # uint8_t
    m_nChangeCount = 0x739 # uint8_t
    m_RopeLength = 0x73A # int16_t
    m_fLockedPoints = 0x73C # uint8_t
    m_bCreatedFromMapFile = 0x73D # bool
    m_flScrollSpeed = 0x740 # float
    m_bStartPointValid = 0x744 # bool
    m_bEndPointValid = 0x745 # bool
    m_hStartPoint = 0x748 # CHandle<CBaseEntity>
    m_hEndPoint = 0x74C # CHandle<CBaseEntity>
    m_iStartAttachment = 0x750 # AttachmentHandle_t
    m_iEndAttachment = 0x751 # AttachmentHandle_t

class CRotDoor:
    m_bSolidBsp = 0x988 # bool

class CRuleEntity:
    m_iszMaster = 0x700 # CUtlSymbolLarge

class CRulePointEntity:
    m_Score = 0x708 # int32_t

class CSAdditionalMatchStats_t:
    m_numRoundsSurvived = 0x14 # int32_t
    m_maxNumRoundsSurvived = 0x18 # int32_t
    m_numRoundsSurvivedTotal = 0x1C # int32_t
    m_iRoundsWonWithoutPurchase = 0x20 # int32_t
    m_iRoundsWonWithoutPurchaseTotal = 0x24 # int32_t
    m_numFirstKills = 0x28 # int32_t
    m_numClutchKills = 0x2C # int32_t
    m_numPistolKills = 0x30 # int32_t
    m_numSniperKills = 0x34 # int32_t
    m_iNumSuicides = 0x38 # int32_t
    m_iNumTeamKills = 0x3C # int32_t
    m_iTeamDamage = 0x40 # int32_t

class CSAdditionalPerRoundStats_t:
    m_numChickensKilled = 0x0 # int32_t
    m_killsWhileBlind = 0x4 # int32_t
    m_bombCarrierkills = 0x8 # int32_t
    m_iBurnDamageInflicted = 0xC # int32_t
    m_iDinks = 0x10 # int32_t

class CSMatchStats_t:
    m_iEnemy5Ks = 0x68 # int32_t
    m_iEnemy4Ks = 0x6C # int32_t
    m_iEnemy3Ks = 0x70 # int32_t
    m_iEnemy2Ks = 0x74 # int32_t
    m_iUtility_Count = 0x78 # int32_t
    m_iUtility_Successes = 0x7C # int32_t
    m_iUtility_Enemies = 0x80 # int32_t
    m_iFlash_Count = 0x84 # int32_t
    m_iFlash_Successes = 0x88 # int32_t
    m_nHealthPointsRemovedTotal = 0x8C # int32_t
    m_nHealthPointsDealtTotal = 0x90 # int32_t
    m_nShotsFiredTotal = 0x94 # int32_t
    m_nShotsOnTargetTotal = 0x98 # int32_t
    m_i1v1Count = 0x9C # int32_t
    m_i1v1Wins = 0xA0 # int32_t
    m_i1v2Count = 0xA4 # int32_t
    m_i1v2Wins = 0xA8 # int32_t
    m_iEntryCount = 0xAC # int32_t
    m_iEntryWins = 0xB0 # int32_t

class CSPerRoundStats_t:
    m_iKills = 0x30 # int32_t
    m_iDeaths = 0x34 # int32_t
    m_iAssists = 0x38 # int32_t
    m_iDamage = 0x3C # int32_t
    m_iEquipmentValue = 0x40 # int32_t
    m_iMoneySaved = 0x44 # int32_t
    m_iKillReward = 0x48 # int32_t
    m_iLiveTime = 0x4C # int32_t
    m_iHeadShotKills = 0x50 # int32_t
    m_iObjective = 0x54 # int32_t
    m_iCashEarned = 0x58 # int32_t
    m_iUtilityDamage = 0x5C # int32_t
    m_iEnemiesFlashed = 0x60 # int32_t

class CSceneEntity:
    m_iszSceneFile = 0x4B8 # CUtlSymbolLarge
    m_iszResumeSceneFile = 0x4C0 # CUtlSymbolLarge
    m_iszTarget1 = 0x4C8 # CUtlSymbolLarge
    m_iszTarget2 = 0x4D0 # CUtlSymbolLarge
    m_iszTarget3 = 0x4D8 # CUtlSymbolLarge
    m_iszTarget4 = 0x4E0 # CUtlSymbolLarge
    m_iszTarget5 = 0x4E8 # CUtlSymbolLarge
    m_iszTarget6 = 0x4F0 # CUtlSymbolLarge
    m_iszTarget7 = 0x4F8 # CUtlSymbolLarge
    m_iszTarget8 = 0x500 # CUtlSymbolLarge
    m_hTarget1 = 0x508 # CHandle<CBaseEntity>
    m_hTarget2 = 0x50C # CHandle<CBaseEntity>
    m_hTarget3 = 0x510 # CHandle<CBaseEntity>
    m_hTarget4 = 0x514 # CHandle<CBaseEntity>
    m_hTarget5 = 0x518 # CHandle<CBaseEntity>
    m_hTarget6 = 0x51C # CHandle<CBaseEntity>
    m_hTarget7 = 0x520 # CHandle<CBaseEntity>
    m_hTarget8 = 0x524 # CHandle<CBaseEntity>
    m_bIsPlayingBack = 0x528 # bool
    m_bPaused = 0x529 # bool
    m_bMultiplayer = 0x52A # bool
    m_bAutogenerated = 0x52B # bool
    m_flForceClientTime = 0x52C # float
    m_flCurrentTime = 0x530 # float
    m_flFrameTime = 0x534 # float
    m_bCancelAtNextInterrupt = 0x538 # bool
    m_fPitch = 0x53C # float
    m_bAutomated = 0x540 # bool
    m_nAutomatedAction = 0x544 # int32_t
    m_flAutomationDelay = 0x548 # float
    m_flAutomationTime = 0x54C # float
    m_hWaitingForThisResumeScene = 0x550 # CHandle<CBaseEntity>
    m_bWaitingForResumeScene = 0x554 # bool
    m_bPausedViaInput = 0x555 # bool
    m_bPauseAtNextInterrupt = 0x556 # bool
    m_bWaitingForActor = 0x557 # bool
    m_bWaitingForInterrupt = 0x558 # bool
    m_bInterruptedActorsScenes = 0x559 # bool
    m_bBreakOnNonIdle = 0x55A # bool
    m_hActorList = 0x560 # CNetworkUtlVectorBase<CHandle<CBaseFlex>>
    m_hRemoveActorList = 0x578 # CUtlVector<CHandle<CBaseEntity>>
    m_nSceneFlushCounter = 0x5A0 # int32_t
    m_nSceneStringIndex = 0x5A4 # uint16_t
    m_OnStart = 0x5A8 # CEntityIOOutput
    m_OnCompletion = 0x5D0 # CEntityIOOutput
    m_OnCanceled = 0x5F8 # CEntityIOOutput
    m_OnPaused = 0x620 # CEntityIOOutput
    m_OnResumed = 0x648 # CEntityIOOutput
    m_OnTrigger = 0x670 # CEntityIOOutput[16]
    m_hInterruptScene = 0x980 # CHandle<CSceneEntity>
    m_nInterruptCount = 0x984 # int32_t
    m_bSceneMissing = 0x988 # bool
    m_bInterrupted = 0x989 # bool
    m_bCompletedEarly = 0x98A # bool
    m_bInterruptSceneFinished = 0x98B # bool
    m_bRestoring = 0x98C # bool
    m_hNotifySceneCompletion = 0x990 # CUtlVector<CHandle<CSceneEntity>>
    m_hListManagers = 0x9A8 # CUtlVector<CHandle<CSceneListManager>>
    m_iszSoundName = 0x9E8 # CUtlSymbolLarge
    m_hActor = 0x9F0 # CHandle<CBaseFlex>
    m_hActivator = 0x9F4 # CHandle<CBaseEntity>
    m_BusyActor = 0x9F8 # int32_t
    m_iPlayerDeathBehavior = 0x9FC # SceneOnPlayerDeath_t

class CSceneEventInfo:
    m_iLayer = 0x0 # int32_t
    m_iPriority = 0x4 # int32_t
    m_hSequence = 0x8 # HSequence
    m_flWeight = 0xC # float
    m_bIsMoving = 0x10 # bool
    m_bHasArrived = 0x11 # bool
    m_flInitialYaw = 0x14 # float
    m_flTargetYaw = 0x18 # float
    m_flFacingYaw = 0x1C # float
    m_nType = 0x20 # int32_t
    m_flNext = 0x24 # GameTime_t
    m_bIsGesture = 0x28 # bool
    m_bShouldRemove = 0x29 # bool
    m_hTarget = 0x54 # CHandle<CBaseEntity>
    m_nSceneEventId = 0x58 # uint32_t
    m_bClientSide = 0x5C # bool
    m_bStarted = 0x5D # bool

class CSceneListManager:
    m_hListManagers = 0x4B0 # CUtlVector<CHandle<CSceneListManager>>
    m_iszScenes = 0x4C8 # CUtlSymbolLarge[16]
    m_hScenes = 0x548 # CHandle<CBaseEntity>[16]

class CScriptComponent:
    m_scriptClassName = 0x30 # CUtlSymbolLarge

class CScriptItem:
    m_OnPlayerPickup = 0x968 # CEntityIOOutput
    m_MoveTypeOverride = 0x990 # MoveType_t

class CScriptNavBlocker:
    m_vExtent = 0x710 # Vector

class CScriptTriggerHurt:
    m_vExtent = 0x948 # Vector

class CScriptTriggerMultiple:
    m_vExtent = 0x8D0 # Vector

class CScriptTriggerOnce:
    m_vExtent = 0x8D0 # Vector

class CScriptTriggerPush:
    m_vExtent = 0x8D0 # Vector

class CScriptUniformRandomStream:
    m_hScriptScope = 0x8 # HSCRIPT
    m_nInitialSeed = 0x9C # int32_t

class CScriptedSequence:
    m_iszEntry = 0x4B0 # CUtlSymbolLarge
    m_iszPreIdle = 0x4B8 # CUtlSymbolLarge
    m_iszPlay = 0x4C0 # CUtlSymbolLarge
    m_iszPostIdle = 0x4C8 # CUtlSymbolLarge
    m_iszModifierToAddOnPlay = 0x4D0 # CUtlSymbolLarge
    m_iszNextScript = 0x4D8 # CUtlSymbolLarge
    m_iszEntity = 0x4E0 # CUtlSymbolLarge
    m_iszSyncGroup = 0x4E8 # CUtlSymbolLarge
    m_nMoveTo = 0x4F0 # ScriptedMoveTo_t
    m_bIsPlayingPreIdle = 0x4F4 # bool
    m_bIsPlayingEntry = 0x4F5 # bool
    m_bIsPlayingAction = 0x4F6 # bool
    m_bIsPlayingPostIdle = 0x4F7 # bool
    m_bLoopPreIdleSequence = 0x4F8 # bool
    m_bLoopActionSequence = 0x4F9 # bool
    m_bLoopPostIdleSequence = 0x4FA # bool
    m_bSynchPostIdles = 0x4FB # bool
    m_bIgnoreGravity = 0x4FC # bool
    m_bDisableNPCCollisions = 0x4FD # bool
    m_bKeepAnimgraphLockedPost = 0x4FE # bool
    m_bDontAddModifiers = 0x4FF # bool
    m_flRadius = 0x500 # float
    m_flRepeat = 0x504 # float
    m_flPlayAnimFadeInTime = 0x508 # float
    m_flMoveInterpTime = 0x50C # float
    m_flAngRate = 0x510 # float
    m_iDelay = 0x514 # int32_t
    m_startTime = 0x518 # GameTime_t
    m_bWaitForBeginSequence = 0x51C # bool
    m_saved_effects = 0x520 # int32_t
    m_savedFlags = 0x524 # int32_t
    m_savedCollisionGroup = 0x528 # int32_t
    m_interruptable = 0x52C # bool
    m_sequenceStarted = 0x52D # bool
    m_bPrevAnimatedEveryTick = 0x52E # bool
    m_bForcedAnimatedEveryTick = 0x52F # bool
    m_bPositionRelativeToOtherEntity = 0x530 # bool
    m_hTargetEnt = 0x534 # CHandle<CBaseEntity>
    m_hNextCine = 0x538 # CHandle<CScriptedSequence>
    m_bThinking = 0x53C # bool
    m_bInitiatedSelfDelete = 0x53D # bool
    m_bIsTeleportingDueToMoveTo = 0x53E # bool
    m_bAllowCustomInterruptConditions = 0x53F # bool
    m_hLastFoundEntity = 0x540 # CHandle<CBaseEntity>
    m_hForcedTarget = 0x544 # CHandle<CBaseAnimGraph>
    m_bDontCancelOtherSequences = 0x548 # bool
    m_bForceSynch = 0x549 # bool
    m_bTargetWasAsleep = 0x54A # bool
    m_bPreventUpdateYawOnFinish = 0x54B # bool
    m_bEnsureOnNavmeshOnFinish = 0x54C # bool
    m_onDeathBehavior = 0x550 # ScriptedOnDeath_t
    m_ConflictResponse = 0x554 # ScriptedConflictResponse_t
    m_OnBeginSequence = 0x558 # CEntityIOOutput
    m_OnActionStartOrLoop = 0x580 # CEntityIOOutput
    m_OnEndSequence = 0x5A8 # CEntityIOOutput
    m_OnPostIdleEndSequence = 0x5D0 # CEntityIOOutput
    m_OnCancelSequence = 0x5F8 # CEntityIOOutput
    m_OnCancelFailedSequence = 0x620 # CEntityIOOutput
    m_OnScriptEvent = 0x648 # CEntityIOOutput[8]
    m_matOtherToMain = 0x790 # CTransform
    m_hInteractionMainEntity = 0x7B0 # CHandle<CBaseEntity>
    m_iPlayerDeathBehavior = 0x7B4 # int32_t

class CSensorGrenadeProjectile:
    m_fExpireTime = 0xA40 # GameTime_t
    m_fNextDetectPlayerSound = 0xA44 # GameTime_t
    m_hDisplayGrenade = 0xA48 # CHandle<CBaseEntity>

class CShatterGlassShard:
    m_hShardHandle = 0x8 # uint32_t
    m_vecPanelVertices = 0x10 # CUtlVector<Vector2D>
    m_vLocalPanelSpaceOrigin = 0x28 # Vector2D
    m_hModel = 0x30 # CStrongHandle<InfoForResourceTypeCModel>
    m_hPhysicsEntity = 0x38 # CHandle<CShatterGlassShardPhysics>
    m_hParentPanel = 0x3C # CHandle<CFuncShatterglass>
    m_hParentShard = 0x40 # uint32_t
    m_ShatterStressType = 0x44 # ShatterGlassStressType
    m_vecStressVelocity = 0x48 # Vector
    m_bCreatedModel = 0x54 # bool
    m_flLongestEdge = 0x58 # float
    m_flShortestEdge = 0x5C # float
    m_flLongestAcross = 0x60 # float
    m_flShortestAcross = 0x64 # float
    m_flSumOfAllEdges = 0x68 # float
    m_flArea = 0x6C # float
    m_nOnFrameEdge = 0x70 # OnFrame
    m_nParentPanelsNthShard = 0x74 # int32_t
    m_nSubShardGeneration = 0x78 # int32_t
    m_vecAverageVertPosition = 0x7C # Vector2D
    m_bAverageVertPositionIsValid = 0x84 # bool
    m_vecPanelSpaceStressPositionA = 0x88 # Vector2D
    m_vecPanelSpaceStressPositionB = 0x90 # Vector2D
    m_bStressPositionAIsValid = 0x98 # bool
    m_bStressPositionBIsValid = 0x99 # bool
    m_bFlaggedForRemoval = 0x9A # bool
    m_flPhysicsEntitySpawnedAtTime = 0x9C # GameTime_t
    m_bShatterRateLimited = 0xA0 # bool
    m_hEntityHittingMe = 0xA4 # CHandle<CBaseEntity>
    m_vecNeighbors = 0xA8 # CUtlVector<uint32_t>

class CShatterGlassShardPhysics:
    m_bDebris = 0xB78 # bool
    m_hParentShard = 0xB7C # uint32_t
    m_ShardDesc = 0xB80 # shard_model_desc_t

class CSimTimer:
    m_interval = 0x8 # float

class CSimpleSimTimer:
    m_next = 0x0 # GameTime_t
    m_nWorldGroupId = 0x4 # WorldGroupId_t

class CSingleplayRules:
    m_bSinglePlayerGameEnding = 0x90 # bool

class CSkeletonAnimationController:
    m_pSkeletonInstance = 0x8 # CSkeletonInstance*

class CSkeletonInstance:
    m_modelState = 0x160 # CModelState
    m_bIsAnimationEnabled = 0x390 # bool
    m_bUseParentRenderBounds = 0x391 # bool
    m_bDisableSolidCollisionsForHierarchy = 0x392 # bool
    m_bDirtyMotionType = 0x0 # bitfield:1
    m_bIsGeneratingLatchedParentSpaceState = 0x0 # bitfield:1
    m_materialGroup = 0x394 # CUtlStringToken
    m_nHitboxSet = 0x398 # uint8_t

class CSkillDamage:
    m_flDamage = 0x0 # CSkillFloat
    m_flPhysicsForceDamage = 0x10 # float

class CSkillFloat:
    m_pValue = 0x0 # float[4]

class CSkillInt:
    m_pValue = 0x0 # int32_t[4]

class CSkyCamera:
    m_skyboxData = 0x4B0 # sky3dparams_t
    m_skyboxSlotToken = 0x540 # CUtlStringToken
    m_bUseAngles = 0x544 # bool
    m_pNext = 0x548 # CSkyCamera*

class CSkyboxReference:
    m_worldGroupId = 0x4B0 # WorldGroupId_t
    m_hSkyCamera = 0x4B4 # CHandle<CSkyCamera>

class CSmokeGrenadeProjectile:
    m_nSmokeEffectTickBegin = 0xA58 # int32_t
    m_bDidSmokeEffect = 0xA5C # bool
    m_nRandomSeed = 0xA60 # int32_t
    m_vSmokeColor = 0xA64 # Vector
    m_vSmokeDetonationPos = 0xA70 # Vector
    m_VoxelFrameData = 0xA80 # CUtlVector<uint8_t>
    m_flLastBounce = 0xA98 # GameTime_t
    m_fllastSimulationTime = 0xA9C # GameTime_t

class CSmoothFunc:
    m_flSmoothAmplitude = 0x8 # float
    m_flSmoothBias = 0xC # float
    m_flSmoothDuration = 0x10 # float
    m_flSmoothRemainingTime = 0x14 # float
    m_nSmoothDir = 0x18 # int32_t

class CSound:
    m_hOwner = 0x0 # CHandle<CBaseEntity>
    m_hTarget = 0x4 # CHandle<CBaseEntity>
    m_iVolume = 0x8 # int32_t
    m_flOcclusionScale = 0xC # float
    m_iType = 0x10 # int32_t
    m_iNextAudible = 0x14 # int32_t
    m_flExpireTime = 0x18 # GameTime_t
    m_iNext = 0x1C # int16_t
    m_bNoExpirationTime = 0x1E # bool
    m_ownerChannelIndex = 0x20 # int32_t
    m_vecOrigin = 0x24 # Vector
    m_bHasOwner = 0x30 # bool

class CSoundAreaEntityBase:
    m_bDisabled = 0x4B0 # bool
    m_iszSoundAreaType = 0x4B8 # CUtlSymbolLarge
    m_vPos = 0x4C0 # Vector

class CSoundAreaEntityOrientedBox:
    m_vMin = 0x4D0 # Vector
    m_vMax = 0x4DC # Vector

class CSoundAreaEntitySphere:
    m_flRadius = 0x4D0 # float

class CSoundEnt:
    m_iFreeSound = 0x4B0 # int32_t
    m_iActiveSound = 0x4B4 # int32_t
    m_cLastActiveSounds = 0x4B8 # int32_t
    m_SoundPool = 0x4BC # CSound[128]

class CSoundEnvelope:
    m_current = 0x0 # float
    m_target = 0x4 # float
    m_rate = 0x8 # float
    m_forceupdate = 0xC # bool

class CSoundEventAABBEntity:
    m_vMins = 0x558 # Vector
    m_vMaxs = 0x564 # Vector

class CSoundEventEntity:
    m_bStartOnSpawn = 0x4B0 # bool
    m_bToLocalPlayer = 0x4B1 # bool
    m_bStopOnNew = 0x4B2 # bool
    m_bSaveRestore = 0x4B3 # bool
    m_bSavedIsPlaying = 0x4B4 # bool
    m_flSavedElapsedTime = 0x4B8 # float
    m_iszSourceEntityName = 0x4C0 # CUtlSymbolLarge
    m_iszAttachmentName = 0x4C8 # CUtlSymbolLarge
    m_onGUIDChanged = 0x4D0 # CEntityOutputTemplate<uint64_t>
    m_onSoundFinished = 0x4F8 # CEntityIOOutput
    m_iszSoundName = 0x540 # CUtlSymbolLarge
    m_hSource = 0x550 # CEntityHandle

class CSoundEventOBBEntity:
    m_vMins = 0x558 # Vector
    m_vMaxs = 0x564 # Vector

class CSoundEventParameter:
    m_iszParamName = 0x4B8 # CUtlSymbolLarge
    m_flFloatValue = 0x4C0 # float

class CSoundEventPathCornerEntity:
    m_iszPathCorner = 0x558 # CUtlSymbolLarge
    m_iCountMax = 0x560 # int32_t
    m_flDistanceMax = 0x564 # float
    m_flDistMaxSqr = 0x568 # float
    m_flDotProductMax = 0x56C # float
    bPlaying = 0x570 # bool

class CSoundOpvarSetAABBEntity:
    m_vDistanceInnerMins = 0x648 # Vector
    m_vDistanceInnerMaxs = 0x654 # Vector
    m_vDistanceOuterMins = 0x660 # Vector
    m_vDistanceOuterMaxs = 0x66C # Vector
    m_nAABBDirection = 0x678 # int32_t
    m_vInnerMins = 0x67C # Vector
    m_vInnerMaxs = 0x688 # Vector
    m_vOuterMins = 0x694 # Vector
    m_vOuterMaxs = 0x6A0 # Vector

class CSoundOpvarSetEntity:
    m_iszStackName = 0x4B8 # CUtlSymbolLarge
    m_iszOperatorName = 0x4C0 # CUtlSymbolLarge
    m_iszOpvarName = 0x4C8 # CUtlSymbolLarge
    m_nOpvarType = 0x4D0 # int32_t
    m_nOpvarIndex = 0x4D4 # int32_t
    m_flOpvarValue = 0x4D8 # float
    m_OpvarValueString = 0x4E0 # CUtlSymbolLarge
    m_bSetOnSpawn = 0x4E8 # bool

class CSoundOpvarSetOBBWindEntity:
    m_vMins = 0x548 # Vector
    m_vMaxs = 0x554 # Vector
    m_vDistanceMins = 0x560 # Vector
    m_vDistanceMaxs = 0x56C # Vector
    m_flWindMin = 0x578 # float
    m_flWindMax = 0x57C # float
    m_flWindMapMin = 0x580 # float
    m_flWindMapMax = 0x584 # float

class CSoundOpvarSetPathCornerEntity:
    m_flDistMinSqr = 0x660 # float
    m_flDistMaxSqr = 0x664 # float
    m_iszPathCornerEntityName = 0x668 # CUtlSymbolLarge

class CSoundOpvarSetPointBase:
    m_bDisabled = 0x4B0 # bool
    m_hSource = 0x4B4 # CEntityHandle
    m_iszSourceEntityName = 0x4C0 # CUtlSymbolLarge
    m_vLastPosition = 0x518 # Vector
    m_iszStackName = 0x528 # CUtlSymbolLarge
    m_iszOperatorName = 0x530 # CUtlSymbolLarge
    m_iszOpvarName = 0x538 # CUtlSymbolLarge
    m_iOpvarIndex = 0x540 # int32_t
    m_bUseAutoCompare = 0x544 # bool

class CSoundOpvarSetPointEntity:
    m_OnEnter = 0x548 # CEntityIOOutput
    m_OnExit = 0x570 # CEntityIOOutput
    m_bAutoDisable = 0x598 # bool
    m_flDistanceMin = 0x5DC # float
    m_flDistanceMax = 0x5E0 # float
    m_flDistanceMapMin = 0x5E4 # float
    m_flDistanceMapMax = 0x5E8 # float
    m_flOcclusionRadius = 0x5EC # float
    m_flOcclusionMin = 0x5F0 # float
    m_flOcclusionMax = 0x5F4 # float
    m_flValSetOnDisable = 0x5F8 # float
    m_bSetValueOnDisable = 0x5FC # bool
    m_nSimulationMode = 0x600 # int32_t
    m_nVisibilitySamples = 0x604 # int32_t
    m_vDynamicProxyPoint = 0x608 # Vector
    m_flDynamicMaximumOcclusion = 0x614 # float
    m_hDynamicEntity = 0x618 # CEntityHandle
    m_iszDynamicEntityName = 0x620 # CUtlSymbolLarge
    m_flPathingDistanceNormFactor = 0x628 # float
    m_vPathingSourcePos = 0x62C # Vector
    m_vPathingListenerPos = 0x638 # Vector
    m_nPathingSourceIndex = 0x644 # int32_t

class CSoundPatch:
    m_pitch = 0x8 # CSoundEnvelope
    m_volume = 0x18 # CSoundEnvelope
    m_shutdownTime = 0x30 # float
    m_flLastTime = 0x34 # float
    m_iszSoundScriptName = 0x38 # CUtlSymbolLarge
    m_hEnt = 0x40 # CHandle<CBaseEntity>
    m_soundEntityIndex = 0x44 # CEntityIndex
    m_soundOrigin = 0x48 # Vector
    m_isPlaying = 0x54 # int32_t
    m_Filter = 0x58 # CCopyRecipientFilter
    m_flCloseCaptionDuration = 0x80 # float
    m_bUpdatedSoundOrigin = 0x84 # bool
    m_iszClassName = 0x88 # CUtlSymbolLarge

class CSoundStackSave:
    m_iszStackName = 0x4B0 # CUtlSymbolLarge

class CSpotlightEnd:
    m_flLightScale = 0x700 # float
    m_Radius = 0x704 # float
    m_vSpotlightDir = 0x708 # Vector
    m_vSpotlightOrg = 0x714 # Vector

class CSprite:
    m_hSpriteMaterial = 0x700 # CStrongHandle<InfoForResourceTypeIMaterial2>
    m_hAttachedToEntity = 0x708 # CHandle<CBaseEntity>
    m_nAttachment = 0x70C # AttachmentHandle_t
    m_flSpriteFramerate = 0x710 # float
    m_flFrame = 0x714 # float
    m_flDieTime = 0x718 # GameTime_t
    m_nBrightness = 0x728 # uint32_t
    m_flBrightnessDuration = 0x72C # float
    m_flSpriteScale = 0x730 # float
    m_flScaleDuration = 0x734 # float
    m_bWorldSpaceScale = 0x738 # bool
    m_flGlowProxySize = 0x73C # float
    m_flHDRColorScale = 0x740 # float
    m_flLastTime = 0x744 # GameTime_t
    m_flMaxFrame = 0x748 # float
    m_flStartScale = 0x74C # float
    m_flDestScale = 0x750 # float
    m_flScaleTimeStart = 0x754 # GameTime_t
    m_nStartBrightness = 0x758 # int32_t
    m_nDestBrightness = 0x75C # int32_t
    m_flBrightnessTimeStart = 0x760 # GameTime_t
    m_nSpriteWidth = 0x764 # int32_t
    m_nSpriteHeight = 0x768 # int32_t

class CStopwatch:
    m_interval = 0xC # float

class CStopwatchBase:
    m_fIsRunning = 0x8 # bool

class CSun:
    m_vDirection = 0x700 # Vector
    m_clrOverlay = 0x70C # Color
    m_iszEffectName = 0x710 # CUtlSymbolLarge
    m_iszSSEffectName = 0x718 # CUtlSymbolLarge
    m_bOn = 0x720 # bool
    m_bmaxColor = 0x721 # bool
    m_flSize = 0x724 # float
    m_flRotation = 0x728 # float
    m_flHazeScale = 0x72C # float
    m_flAlphaHaze = 0x730 # float
    m_flAlphaHdr = 0x734 # float
    m_flAlphaScale = 0x738 # float
    m_flHDRColorScale = 0x73C # float
    m_flFarZScale = 0x740 # float

class CTakeDamageInfo:
    m_vecDamageForce = 0x8 # Vector
    m_vecDamagePosition = 0x14 # Vector
    m_vecReportedPosition = 0x20 # Vector
    m_vecDamageDirection = 0x2C # Vector
    m_hInflictor = 0x38 # CHandle<CBaseEntity>
    m_hAttacker = 0x3C # CHandle<CBaseEntity>
    m_hAbility = 0x40 # CHandle<CBaseEntity>
    m_flDamage = 0x44 # float
    m_bitsDamageType = 0x48 # int32_t
    m_iDamageCustom = 0x4C # int32_t
    m_iAmmoType = 0x50 # AmmoIndex_t
    m_flOriginalDamage = 0x60 # float
    m_bShouldBleed = 0x64 # bool
    m_bShouldSpark = 0x65 # bool
    m_nDamageFlags = 0x70 # TakeDamageFlags_t
    m_nNumObjectsPenetrated = 0x74 # int32_t
    m_hScriptInstance = 0x78 # HSCRIPT
    m_bInTakeDamageFlow = 0x94 # bool

class CTakeDamageResult:
    m_nHealthLost = 0x0 # int32_t
    m_nDamageTaken = 0x4 # int32_t

class CTakeDamageSummaryScopeGuard:
    m_vecSummaries = 0x8 # CUtlVector<SummaryTakeDamageInfo_t*>

class CTankTargetChange:
    m_newTarget = 0x4B0 # CVariantBase<CVariantDefaultAllocator>
    m_newTargetName = 0x4C0 # CUtlSymbolLarge

class CTankTrainAI:
    m_hTrain = 0x4B0 # CHandle<CFuncTrackTrain>
    m_hTargetEntity = 0x4B4 # CHandle<CBaseEntity>
    m_soundPlaying = 0x4B8 # int32_t
    m_startSoundName = 0x4D0 # CUtlSymbolLarge
    m_engineSoundName = 0x4D8 # CUtlSymbolLarge
    m_movementSoundName = 0x4E0 # CUtlSymbolLarge
    m_targetEntityName = 0x4E8 # CUtlSymbolLarge

class CTeam:
    m_aPlayerControllers = 0x4B0 # CNetworkUtlVectorBase<CHandle<CBasePlayerController>>
    m_aPlayers = 0x4C8 # CNetworkUtlVectorBase<CHandle<CBasePlayerPawn>>
    m_iScore = 0x4E0 # int32_t
    m_szTeamname = 0x4E4 # char[129]

class CTestEffect:
    m_iLoop = 0x4B0 # int32_t
    m_iBeam = 0x4B4 # int32_t
    m_pBeam = 0x4B8 # CBeam*[24]
    m_flBeamTime = 0x578 # GameTime_t[24]
    m_flStartTime = 0x5D8 # GameTime_t

class CTextureBasedAnimatable:
    m_bLoop = 0x700 # bool
    m_flFPS = 0x704 # float
    m_hPositionKeys = 0x708 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_hRotationKeys = 0x710 # CStrongHandle<InfoForResourceTypeCTextureBase>
    m_vAnimationBoundsMin = 0x718 # Vector
    m_vAnimationBoundsMax = 0x724 # Vector
    m_flStartTime = 0x730 # float
    m_flStartFrame = 0x734 # float

class CTimeline:
    m_flValues = 0x10 # float[64]
    m_nValueCounts = 0x110 # int32_t[64]
    m_nBucketCount = 0x210 # int32_t
    m_flInterval = 0x214 # float
    m_flFinalValue = 0x218 # float
    m_nCompressionType = 0x21C # TimelineCompression_t
    m_bStopped = 0x220 # bool

class CTimerEntity:
    m_OnTimer = 0x4B0 # CEntityIOOutput
    m_OnTimerHigh = 0x4D8 # CEntityIOOutput
    m_OnTimerLow = 0x500 # CEntityIOOutput
    m_iDisabled = 0x528 # int32_t
    m_flInitialDelay = 0x52C # float
    m_flRefireTime = 0x530 # float
    m_bUpDownState = 0x534 # bool
    m_iUseRandomTime = 0x538 # int32_t
    m_bPauseAfterFiring = 0x53C # bool
    m_flLowerRandomBound = 0x540 # float
    m_flUpperRandomBound = 0x544 # float
    m_flRemainingTime = 0x548 # float
    m_bPaused = 0x54C # bool

class CTonemapController2:
    m_flAutoExposureMin = 0x4B0 # float
    m_flAutoExposureMax = 0x4B4 # float
    m_flTonemapPercentTarget = 0x4B8 # float
    m_flTonemapPercentBrightPixels = 0x4BC # float
    m_flTonemapMinAvgLum = 0x4C0 # float
    m_flExposureAdaptationSpeedUp = 0x4C4 # float
    m_flExposureAdaptationSpeedDown = 0x4C8 # float
    m_flTonemapEVSmoothingRange = 0x4CC # float

class CTonemapTrigger:
    m_tonemapControllerName = 0x8A8 # CUtlSymbolLarge
    m_hTonemapController = 0x8B0 # CEntityHandle

class CTriggerActiveWeaponDetect:
    m_OnTouchedActiveWeapon = 0x8A8 # CEntityIOOutput
    m_iszWeaponClassName = 0x8D0 # CUtlSymbolLarge

class CTriggerBrush:
    m_OnStartTouch = 0x700 # CEntityIOOutput
    m_OnEndTouch = 0x728 # CEntityIOOutput
    m_OnUse = 0x750 # CEntityIOOutput
    m_iInputFilter = 0x778 # int32_t
    m_iDontMessageParent = 0x77C # int32_t

class CTriggerBuoyancy:
    m_BuoyancyHelper = 0x8A8 # CBuoyancyHelper
    m_flFluidDensity = 0x8C8 # float

class CTriggerDetectBulletFire:
    m_bPlayerFireOnly = 0x8A8 # bool
    m_OnDetectedBulletFire = 0x8B0 # CEntityIOOutput

class CTriggerDetectExplosion:
    m_OnDetectedExplosion = 0x8E0 # CEntityIOOutput

class CTriggerFan:
    m_vFanOrigin = 0x8A8 # Vector
    m_vFanEnd = 0x8B4 # Vector
    m_vNoise = 0x8C0 # Vector
    m_flForce = 0x8CC # float
    m_flPlayerForce = 0x8D0 # float
    m_flRampTime = 0x8D4 # float
    m_bFalloff = 0x8D8 # bool
    m_bPushPlayer = 0x8D9 # bool
    m_bRampDown = 0x8DA # bool
    m_bAddNoise = 0x8DB # bool
    m_RampTimer = 0x8E0 # CountdownTimer

class CTriggerGameEvent:
    m_strStartTouchEventName = 0x8A8 # CUtlString
    m_strEndTouchEventName = 0x8B0 # CUtlString
    m_strTriggerID = 0x8B8 # CUtlString

class CTriggerHurt:
    m_flOriginalDamage = 0x8A8 # float
    m_flDamage = 0x8AC # float
    m_flDamageCap = 0x8B0 # float
    m_flLastDmgTime = 0x8B4 # GameTime_t
    m_flForgivenessDelay = 0x8B8 # float
    m_bitsDamageInflict = 0x8BC # int32_t
    m_damageModel = 0x8C0 # int32_t
    m_bNoDmgForce = 0x8C4 # bool
    m_vDamageForce = 0x8C8 # Vector
    m_thinkAlways = 0x8D4 # bool
    m_hurtThinkPeriod = 0x8D8 # float
    m_OnHurt = 0x8E0 # CEntityIOOutput
    m_OnHurtPlayer = 0x908 # CEntityIOOutput
    m_hurtEntities = 0x930 # CUtlVector<CHandle<CBaseEntity>>

class CTriggerImpact:
    m_flMagnitude = 0x8D0 # float
    m_flNoise = 0x8D4 # float
    m_flViewkick = 0x8D8 # float
    m_pOutputForce = 0x8E0 # CEntityOutputTemplate<Vector>

class CTriggerLerpObject:
    m_iszLerpTarget = 0x8A8 # CUtlSymbolLarge
    m_hLerpTarget = 0x8B0 # CHandle<CBaseEntity>
    m_iszLerpTargetAttachment = 0x8B8 # CUtlSymbolLarge
    m_hLerpTargetAttachment = 0x8C0 # AttachmentHandle_t
    m_flLerpDuration = 0x8C4 # float
    m_bLerpRestoreMoveType = 0x8C8 # bool
    m_bSingleLerpObject = 0x8C9 # bool
    m_vecLerpingObjects = 0x8D0 # CUtlVector<lerpdata_t>
    m_iszLerpEffect = 0x8E8 # CUtlSymbolLarge
    m_iszLerpSound = 0x8F0 # CUtlSymbolLarge
    m_OnLerpStarted = 0x8F8 # CEntityIOOutput
    m_OnLerpFinished = 0x920 # CEntityIOOutput

class CTriggerLook:
    m_hLookTarget = 0x8D0 # CHandle<CBaseEntity>
    m_flFieldOfView = 0x8D4 # float
    m_flLookTime = 0x8D8 # float
    m_flLookTimeTotal = 0x8DC # float
    m_flLookTimeLast = 0x8E0 # GameTime_t
    m_flTimeoutDuration = 0x8E4 # float
    m_bTimeoutFired = 0x8E8 # bool
    m_bIsLooking = 0x8E9 # bool
    m_b2DFOV = 0x8EA # bool
    m_bUseVelocity = 0x8EB # bool
    m_hActivator = 0x8EC # CHandle<CBaseEntity>
    m_bTestOcclusion = 0x8F0 # bool
    m_OnTimeout = 0x8F8 # CEntityIOOutput
    m_OnStartLook = 0x920 # CEntityIOOutput
    m_OnEndLook = 0x948 # CEntityIOOutput

class CTriggerMultiple:
    m_OnTrigger = 0x8A8 # CEntityIOOutput

class CTriggerPhysics:
    m_gravityScale = 0x8B8 # float
    m_linearLimit = 0x8BC # float
    m_linearDamping = 0x8C0 # float
    m_angularLimit = 0x8C4 # float
    m_angularDamping = 0x8C8 # float
    m_linearForce = 0x8CC # float
    m_flFrequency = 0x8D0 # float
    m_flDampingRatio = 0x8D4 # float
    m_vecLinearForcePointAt = 0x8D8 # Vector
    m_bCollapseToForcePoint = 0x8E4 # bool
    m_vecLinearForcePointAtWorld = 0x8E8 # Vector
    m_vecLinearForceDirection = 0x8F4 # Vector
    m_bConvertToDebrisWhenPossible = 0x900 # bool

class CTriggerProximity:
    m_hMeasureTarget = 0x8A8 # CHandle<CBaseEntity>
    m_iszMeasureTarget = 0x8B0 # CUtlSymbolLarge
    m_fRadius = 0x8B8 # float
    m_nTouchers = 0x8BC # int32_t
    m_NearestEntityDistance = 0x8C0 # CEntityOutputTemplate<float>

class CTriggerPush:
    m_angPushEntitySpace = 0x8A8 # QAngle
    m_vecPushDirEntitySpace = 0x8B4 # Vector
    m_bTriggerOnStartTouch = 0x8C0 # bool
    m_flAlternateTicksFix = 0x8C4 # float
    m_flPushSpeed = 0x8C8 # float

class CTriggerRemove:
    m_OnRemove = 0x8A8 # CEntityIOOutput

class CTriggerSave:
    m_bForceNewLevelUnit = 0x8A8 # bool
    m_fDangerousTimer = 0x8AC # float
    m_minHitPoints = 0x8B0 # int32_t

class CTriggerSndSosOpvar:
    m_hTouchingPlayers = 0x8A8 # CUtlVector<CHandle<CBaseEntity>>
    m_flPosition = 0x8C0 # Vector
    m_flCenterSize = 0x8CC # float
    m_flMinVal = 0x8D0 # float
    m_flMaxVal = 0x8D4 # float
    m_flWait = 0x8D8 # float
    m_opvarName = 0x8E0 # CUtlSymbolLarge
    m_stackName = 0x8E8 # CUtlSymbolLarge
    m_operatorName = 0x8F0 # CUtlSymbolLarge
    m_bVolIs2D = 0x8F8 # bool
    m_opvarNameChar = 0x8F9 # char[256]
    m_stackNameChar = 0x9F9 # char[256]
    m_operatorNameChar = 0xAF9 # char[256]
    m_VecNormPos = 0xBFC # Vector
    m_flNormCenterSize = 0xC08 # float

class CTriggerSoundscape:
    m_hSoundscape = 0x8A8 # CHandle<CEnvSoundscapeTriggerable>
    m_SoundscapeName = 0x8B0 # CUtlSymbolLarge
    m_spectators = 0x8B8 # CUtlVector<CHandle<CBasePlayerPawn>>

class CTriggerTeleport:
    m_iLandmark = 0x8A8 # CUtlSymbolLarge
    m_bUseLandmarkAngles = 0x8B0 # bool
    m_bMirrorPlayer = 0x8B1 # bool

class CTriggerToggleSave:
    m_bDisabled = 0x8A8 # bool

class CTriggerVolume:
    m_iFilterName = 0x700 # CUtlSymbolLarge
    m_hFilter = 0x708 # CHandle<CBaseFilter>

class CVoteController:
    m_iActiveIssueIndex = 0x4B0 # int32_t
    m_iOnlyTeamToVote = 0x4B4 # int32_t
    m_nVoteOptionCount = 0x4B8 # int32_t[5]
    m_nPotentialVotes = 0x4CC # int32_t
    m_bIsYesNoVote = 0x4D0 # bool
    m_acceptingVotesTimer = 0x4D8 # CountdownTimer
    m_executeCommandTimer = 0x4F0 # CountdownTimer
    m_resetVoteTimer = 0x508 # CountdownTimer
    m_nVotesCast = 0x520 # int32_t[64]
    m_playerHoldingVote = 0x620 # CPlayerSlot
    m_playerOverrideForVote = 0x624 # CPlayerSlot
    m_nHighestCountIndex = 0x628 # int32_t
    m_potentialIssues = 0x630 # CUtlVector<CBaseIssue*>
    m_VoteOptions = 0x648 # CUtlVector<char*>

class CWeaponBaseItem:
    m_SequenceCompleteTimer = 0xE20 # CountdownTimer
    m_bRedraw = 0xE38 # bool

class CWeaponShield:
    m_flBulletDamageAbsorbed = 0xE40 # float
    m_flLastBulletHitSoundTime = 0xE44 # GameTime_t
    m_flDisplayHealth = 0xE48 # float

class CWeaponTaser:
    m_fFireTime = 0xE40 # GameTime_t

class CommandToolCommand_t:
    m_bEnabled = 0x0 # bool
    m_bOpened = 0x1 # bool
    m_InternalId = 0x4 # uint32_t
    m_ShortName = 0x8 # CUtlString
    m_ExecMode = 0x10 # CommandExecMode_t
    m_SpawnGroup = 0x18 # CUtlString
    m_PeriodicExecDelay = 0x20 # float
    m_SpecType = 0x24 # CommandEntitySpecType_t
    m_EntitySpec = 0x28 # CUtlString
    m_Commands = 0x30 # CUtlString
    m_SetDebugBits = 0x38 # DebugOverlayBits_t
    m_ClearDebugBits = 0x40 # DebugOverlayBits_t

class ConceptHistory_t:
    timeSpoken = 0x0 # float
    m_response = 0x8 # CRR_Response

class ConstraintSoundInfo:
    m_vSampler = 0x8 # VelocitySampler
    m_soundProfile = 0x20 # SimpleConstraintSoundProfile
    m_forwardAxis = 0x40 # Vector
    m_iszTravelSoundFwd = 0x50 # CUtlSymbolLarge
    m_iszTravelSoundBack = 0x58 # CUtlSymbolLarge
    m_iszReversalSounds = 0x68 # CUtlSymbolLarge[3]
    m_bPlayTravelSound = 0x80 # bool
    m_bPlayReversalSound = 0x81 # bool

class CountdownTimer:
    m_duration = 0x8 # float
    m_timestamp = 0xC # GameTime_t
    m_timescale = 0x10 # float
    m_nWorldGroupId = 0x14 # WorldGroupId_t

class EngineCountdownTimer:
    m_duration = 0x8 # float
    m_timestamp = 0xC # float
    m_timescale = 0x10 # float

class EntityRenderAttribute_t:
    m_ID = 0x30 # CUtlStringToken
    m_Values = 0x34 # Vector4D

class EntitySpottedState_t:
    m_bSpotted = 0x8 # bool
    m_bSpottedByMask = 0xC # uint32_t[2]

class Extent:
    lo = 0x0 # Vector
    hi = 0xC # Vector

class FilterDamageType:
    m_iDamageType = 0x508 # int32_t

class FilterHealth:
    m_bAdrenalineActive = 0x508 # bool
    m_iHealthMin = 0x50C # int32_t
    m_iHealthMax = 0x510 # int32_t

class FilterTeam:
    m_iFilterTeam = 0x508 # int32_t

class GameAmmoTypeInfo_t:
    m_nBuySize = 0x38 # int32_t
    m_nCost = 0x3C # int32_t

class GameTick_t:
    m_Value = 0x0 # int32_t

class GameTime_t:
    m_Value = 0x0 # float

class HullFlags_t:
    m_bHull_Human = 0x0 # bool
    m_bHull_SmallCentered = 0x1 # bool
    m_bHull_WideHuman = 0x2 # bool
    m_bHull_Tiny = 0x3 # bool
    m_bHull_Medium = 0x4 # bool
    m_bHull_TinyCentered = 0x5 # bool
    m_bHull_Large = 0x6 # bool
    m_bHull_LargeCentered = 0x7 # bool
    m_bHull_MediumTall = 0x8 # bool
    m_bHull_Small = 0x9 # bool

class IntervalTimer:
    m_timestamp = 0x8 # GameTime_t
    m_nWorldGroupId = 0xC # WorldGroupId_t

class ModelConfigHandle_t:
    m_Value = 0x0 # uint32_t

class ParticleIndex_t:
    m_Value = 0x0 # int32_t

class PhysicsRagdollPose_t:
    __m_pChainEntity = 0x8 # CNetworkVarChainer
    m_Transforms = 0x30 # CNetworkUtlVectorBase<CTransform>
    m_hOwner = 0x48 # CHandle<CBaseEntity>

class RagdollCreationParams_t:
    m_vForce = 0x0 # Vector
    m_nForceBone = 0xC # int32_t

class RelationshipOverride_t:
    entity = 0x8 # CHandle<CBaseEntity>
    classType = 0xC # Class_T

class Relationship_t:
    disposition = 0x0 # Disposition_t
    priority = 0x4 # int32_t

class ResponseContext_t:
    m_iszName = 0x0 # CUtlSymbolLarge
    m_iszValue = 0x8 # CUtlSymbolLarge
    m_fExpirationTime = 0x10 # GameTime_t

class ResponseFollowup:
    followup_concept = 0x0 # char*
    followup_contexts = 0x8 # char*
    followup_delay = 0x10 # float
    followup_target = 0x14 # char*
    followup_entityiotarget = 0x1C # char*
    followup_entityioinput = 0x24 # char*
    followup_entityiodelay = 0x2C # float
    bFired = 0x30 # bool

class ResponseParams:
    odds = 0x10 # int16_t
    flags = 0x12 # int16_t
    m_pFollowup = 0x18 # ResponseFollowup*

class SellbackPurchaseEntry_t:
    m_unDefIdx = 0x30 # uint16_t
    m_nCost = 0x34 # int32_t
    m_nPrevArmor = 0x38 # int32_t
    m_bPrevHelmet = 0x3C # bool
    m_hItem = 0x40 # CEntityHandle

class ServerAuthoritativeWeaponSlot_t:
    unClass = 0x28 # uint16_t
    unSlot = 0x2A # uint16_t
    unItemDefIdx = 0x2C # uint16_t

class SimpleConstraintSoundProfile:
    eKeypoints = 0x8 # SimpleConstraintSoundProfile::SimpleConstraintsSoundProfileKeypoints_t
    m_keyPoints = 0xC # float[2]
    m_reversalSoundThresholds = 0x14 # float[3]

class SpawnPoint:
    m_iPriority = 0x4B0 # int32_t
    m_bEnabled = 0x4B4 # bool
    m_nType = 0x4B8 # int32_t

class SpawnPointCoopEnemy:
    m_szWeaponsToGive = 0x4C0 # CUtlSymbolLarge
    m_szPlayerModelToUse = 0x4C8 # CUtlSymbolLarge
    m_nArmorToSpawnWith = 0x4D0 # int32_t
    m_nDefaultBehavior = 0x4D4 # SpawnPointCoopEnemy::BotDefaultBehavior_t
    m_nBotDifficulty = 0x4D8 # int32_t
    m_bIsAgressive = 0x4DC # bool
    m_bStartAsleep = 0x4DD # bool
    m_flHideRadius = 0x4E0 # float
    m_szBehaviorTreeFile = 0x4F0 # CUtlSymbolLarge

class SummaryTakeDamageInfo_t:
    nSummarisedCount = 0x0 # int32_t
    info = 0x8 # CTakeDamageInfo
    result = 0xA0 # CTakeDamageResult
    hTarget = 0xA8 # CHandle<CBaseEntity>

class VPhysicsCollisionAttribute_t:
    m_nInteractsAs = 0x8 # uint64_t
    m_nInteractsWith = 0x10 # uint64_t
    m_nInteractsExclude = 0x18 # uint64_t
    m_nEntityId = 0x20 # uint32_t
    m_nOwnerId = 0x24 # uint32_t
    m_nHierarchyId = 0x28 # uint16_t
    m_nCollisionGroup = 0x2A # uint8_t
    m_nCollisionFunctionMask = 0x2B # uint8_t

class VelocitySampler:
    m_prevSample = 0x0 # Vector
    m_fPrevSampleTime = 0xC # GameTime_t
    m_fIdealSampleRate = 0x10 # float

class ViewAngleServerChange_t:
    nType = 0x30 # FixAngleSet_t
    qAngle = 0x34 # QAngle
    nIndex = 0x40 # uint32_t

class WeaponPurchaseCount_t:
    m_nItemDefIndex = 0x30 # uint16_t
    m_nCount = 0x32 # uint16_t

class WeaponPurchaseTracker_t:
    m_weaponPurchases = 0x8 # CUtlVectorEmbeddedNetworkVar<WeaponPurchaseCount_t>

class audioparams_t:
    localSound = 0x8 # Vector[8]
    soundscapeIndex = 0x68 # int32_t
    localBits = 0x6C # uint8_t
    soundscapeEntityListIndex = 0x70 # int32_t
    soundEventHash = 0x74 # uint32_t

class dynpitchvol_base_t:
    preset = 0x0 # int32_t
    pitchrun = 0x4 # int32_t
    pitchstart = 0x8 # int32_t
    spinup = 0xC # int32_t
    spindown = 0x10 # int32_t
    volrun = 0x14 # int32_t
    volstart = 0x18 # int32_t
    fadein = 0x1C # int32_t
    fadeout = 0x20 # int32_t
    lfotype = 0x24 # int32_t
    lforate = 0x28 # int32_t
    lfomodpitch = 0x2C # int32_t
    lfomodvol = 0x30 # int32_t
    cspinup = 0x34 # int32_t
    cspincount = 0x38 # int32_t
    pitch = 0x3C # int32_t
    spinupsav = 0x40 # int32_t
    spindownsav = 0x44 # int32_t
    pitchfrac = 0x48 # int32_t
    vol = 0x4C # int32_t
    fadeinsav = 0x50 # int32_t
    fadeoutsav = 0x54 # int32_t
    volfrac = 0x58 # int32_t
    lfofrac = 0x5C # int32_t
    lfomult = 0x60 # int32_t

class fogparams_t:
    dirPrimary = 0x8 # Vector
    colorPrimary = 0x14 # Color
    colorSecondary = 0x18 # Color
    colorPrimaryLerpTo = 0x1C # Color
    colorSecondaryLerpTo = 0x20 # Color
    start = 0x24 # float
    end = 0x28 # float
    farz = 0x2C # float
    maxdensity = 0x30 # float
    exponent = 0x34 # float
    HDRColorScale = 0x38 # float
    skyboxFogFactor = 0x3C # float
    skyboxFogFactorLerpTo = 0x40 # float
    startLerpTo = 0x44 # float
    endLerpTo = 0x48 # float
    maxdensityLerpTo = 0x4C # float
    lerptime = 0x50 # GameTime_t
    duration = 0x54 # float
    blendtobackground = 0x58 # float
    scattering = 0x5C # float
    locallightscale = 0x60 # float
    enable = 0x64 # bool
    blend = 0x65 # bool
    m_bNoReflectionFog = 0x66 # bool
    m_bPadding = 0x67 # bool

class fogplayerparams_t:
    m_hCtrl = 0x8 # CHandle<CFogController>
    m_flTransitionTime = 0xC # float
    m_OldColor = 0x10 # Color
    m_flOldStart = 0x14 # float
    m_flOldEnd = 0x18 # float
    m_flOldMaxDensity = 0x1C # float
    m_flOldHDRColorScale = 0x20 # float
    m_flOldFarZ = 0x24 # float
    m_NewColor = 0x28 # Color
    m_flNewStart = 0x2C # float
    m_flNewEnd = 0x30 # float
    m_flNewMaxDensity = 0x34 # float
    m_flNewHDRColorScale = 0x38 # float
    m_flNewFarZ = 0x3C # float

class hudtextparms_t:
    color1 = 0x0 # Color
    color2 = 0x4 # Color
    effect = 0x8 # uint8_t
    channel = 0x9 # uint8_t
    x = 0xC # float
    y = 0x10 # float

class lerpdata_t:
    m_hEnt = 0x0 # CHandle<CBaseEntity>
    m_MoveType = 0x4 # MoveType_t
    m_flStartTime = 0x8 # GameTime_t
    m_vecStartOrigin = 0xC # Vector
    m_qStartRot = 0x20 # Quaternion
    m_nFXIndex = 0x30 # ParticleIndex_t

class locksound_t:
    sLockedSound = 0x8 # CUtlSymbolLarge
    sUnlockedSound = 0x10 # CUtlSymbolLarge
    flwaitSound = 0x18 # GameTime_t

class magnetted_objects_t:
    hEntity = 0x8 # CHandle<CBaseEntity>

class ragdoll_t:
    list = 0x0 # CUtlVector<ragdollelement_t>
    boneIndex = 0x18 # CUtlVector<int32_t>
    allowStretch = 0x30 # bool
    unused = 0x31 # bool

class ragdollelement_t:
    originParentSpace = 0x0 # Vector
    parentIndex = 0x20 # int32_t
    m_flRadius = 0x24 # float

class shard_model_desc_t:
    m_nModelID = 0x8 # int32_t
    m_hMaterial = 0x10 # CStrongHandle<InfoForResourceTypeIMaterial2>
    m_solid = 0x18 # ShardSolid_t
    m_ShatterPanelMode = 0x19 # ShatterPanelMode
    m_vecPanelSize = 0x1C # Vector2D
    m_vecStressPositionA = 0x24 # Vector2D
    m_vecStressPositionB = 0x2C # Vector2D
    m_vecPanelVertices = 0x38 # CNetworkUtlVectorBase<Vector2D>
    m_flGlassHalfThickness = 0x50 # float
    m_bHasParent = 0x54 # bool
    m_bParentFrozen = 0x55 # bool
    m_SurfacePropStringToken = 0x58 # CUtlStringToken

class sky3dparams_t:
    scale = 0x8 # int16_t
    origin = 0xC # Vector
    bClip3DSkyBoxNearToWorldFar = 0x18 # bool
    flClip3DSkyBoxNearToWorldFarOffset = 0x1C # float
    fog = 0x20 # fogparams_t
    m_nWorldGroupID = 0x88 # WorldGroupId_t

class thinkfunc_t:
    m_hFn = 0x8 # HSCRIPT
    m_nContext = 0x10 # CUtlStringToken
    m_nNextThinkTick = 0x14 # GameTick_t
    m_nLastThinkTick = 0x18 # GameTick_t

```

`SDK/server.dll.rs`:

```rs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:26.750976700 UTC
 */

#![allow(non_snake_case, non_upper_case_globals)]

pub mod ActiveModelConfig_t {
    pub const m_Handle: usize = 0x28; // ModelConfigHandle_t
    pub const m_Name: usize = 0x30; // CUtlSymbolLarge
    pub const m_AssociatedEntities: usize = 0x38; // CNetworkUtlVectorBase<CHandle<CBaseModelEntity>>
    pub const m_AssociatedEntityNames: usize = 0x50; // CNetworkUtlVectorBase<CUtlSymbolLarge>
}

pub mod AmmoIndex_t {
    pub const m_Value: usize = 0x0; // int8_t
}

pub mod AmmoTypeInfo_t {
    pub const m_nMaxCarry: usize = 0x10; // int32_t
    pub const m_nSplashSize: usize = 0x1C; // CRangeInt
    pub const m_nFlags: usize = 0x24; // AmmoFlags_t
    pub const m_flMass: usize = 0x28; // float
    pub const m_flSpeed: usize = 0x2C; // CRangeFloat
}

pub mod AnimationUpdateListHandle_t {
    pub const m_Value: usize = 0x0; // uint32_t
}

pub mod CAISound {
    pub const m_iSoundType: usize = 0x4B0; // int32_t
    pub const m_iSoundContext: usize = 0x4B4; // int32_t
    pub const m_iVolume: usize = 0x4B8; // int32_t
    pub const m_iSoundIndex: usize = 0x4BC; // int32_t
    pub const m_flDuration: usize = 0x4C0; // float
    pub const m_iszProxyEntityName: usize = 0x4C8; // CUtlSymbolLarge
}

pub mod CAI_ChangeHintGroup {
    pub const m_iSearchType: usize = 0x4B0; // int32_t
    pub const m_strSearchName: usize = 0x4B8; // CUtlSymbolLarge
    pub const m_strNewHintGroup: usize = 0x4C0; // CUtlSymbolLarge
    pub const m_flRadius: usize = 0x4C8; // float
}

pub mod CAI_ChangeTarget {
    pub const m_iszNewTarget: usize = 0x4B0; // CUtlSymbolLarge
}

pub mod CAI_Expresser {
    pub const m_flStopTalkTime: usize = 0x38; // GameTime_t
    pub const m_flStopTalkTimeWithoutDelay: usize = 0x3C; // GameTime_t
    pub const m_flBlockedTalkTime: usize = 0x40; // GameTime_t
    pub const m_voicePitch: usize = 0x44; // int32_t
    pub const m_flLastTimeAcceptedSpeak: usize = 0x48; // GameTime_t
    pub const m_bAllowSpeakingInterrupts: usize = 0x4C; // bool
    pub const m_bConsiderSceneInvolvementAsSpeech: usize = 0x4D; // bool
    pub const m_nLastSpokenPriority: usize = 0x50; // int32_t
    pub const m_pOuter: usize = 0x58; // CBaseFlex*
}

pub mod CAI_ExpresserWithFollowup {
    pub const m_pPostponedFollowup: usize = 0x60; // ResponseFollowup*
}

pub mod CAmbientGeneric {
    pub const m_radius: usize = 0x4B0; // float
    pub const m_flMaxRadius: usize = 0x4B4; // float
    pub const m_iSoundLevel: usize = 0x4B8; // soundlevel_t
    pub const m_dpv: usize = 0x4BC; // dynpitchvol_t
    pub const m_fActive: usize = 0x520; // bool
    pub const m_fLooping: usize = 0x521; // bool
    pub const m_iszSound: usize = 0x528; // CUtlSymbolLarge
    pub const m_sSourceEntName: usize = 0x530; // CUtlSymbolLarge
    pub const m_hSoundSource: usize = 0x538; // CHandle<CBaseEntity>
    pub const m_nSoundSourceEntIndex: usize = 0x53C; // CEntityIndex
}

pub mod CAnimGraphNetworkedVariables {
    pub const m_PredNetBoolVariables: usize = 0x8; // CNetworkUtlVectorBase<uint32_t>
    pub const m_PredNetByteVariables: usize = 0x20; // CNetworkUtlVectorBase<uint8_t>
    pub const m_PredNetUInt16Variables: usize = 0x38; // CNetworkUtlVectorBase<uint16_t>
    pub const m_PredNetIntVariables: usize = 0x50; // CNetworkUtlVectorBase<int32_t>
    pub const m_PredNetUInt32Variables: usize = 0x68; // CNetworkUtlVectorBase<uint32_t>
    pub const m_PredNetUInt64Variables: usize = 0x80; // CNetworkUtlVectorBase<uint64_t>
    pub const m_PredNetFloatVariables: usize = 0x98; // CNetworkUtlVectorBase<float>
    pub const m_PredNetVectorVariables: usize = 0xB0; // CNetworkUtlVectorBase<Vector>
    pub const m_PredNetQuaternionVariables: usize = 0xC8; // CNetworkUtlVectorBase<Quaternion>
    pub const m_OwnerOnlyPredNetBoolVariables: usize = 0xE0; // CNetworkUtlVectorBase<uint32_t>
    pub const m_OwnerOnlyPredNetByteVariables: usize = 0xF8; // CNetworkUtlVectorBase<uint8_t>
    pub const m_OwnerOnlyPredNetUInt16Variables: usize = 0x110; // CNetworkUtlVectorBase<uint16_t>
    pub const m_OwnerOnlyPredNetIntVariables: usize = 0x128; // CNetworkUtlVectorBase<int32_t>
    pub const m_OwnerOnlyPredNetUInt32Variables: usize = 0x140; // CNetworkUtlVectorBase<uint32_t>
    pub const m_OwnerOnlyPredNetUInt64Variables: usize = 0x158; // CNetworkUtlVectorBase<uint64_t>
    pub const m_OwnerOnlyPredNetFloatVariables: usize = 0x170; // CNetworkUtlVectorBase<float>
    pub const m_OwnerOnlyPredNetVectorVariables: usize = 0x188; // CNetworkUtlVectorBase<Vector>
    pub const m_OwnerOnlyPredNetQuaternionVariables: usize = 0x1A0; // CNetworkUtlVectorBase<Quaternion>
    pub const m_nBoolVariablesCount: usize = 0x1B8; // int32_t
    pub const m_nOwnerOnlyBoolVariablesCount: usize = 0x1BC; // int32_t
    pub const m_nRandomSeedOffset: usize = 0x1C0; // int32_t
    pub const m_flLastTeleportTime: usize = 0x1C4; // float
}

pub mod CAnimGraphTagRef {
    pub const m_nTagIndex: usize = 0x0; // int32_t
    pub const m_tagName: usize = 0x10; // CGlobalSymbol
}

pub mod CAttributeContainer {
    pub const m_Item: usize = 0x50; // CEconItemView
}

pub mod CAttributeList {
    pub const m_Attributes: usize = 0x8; // CUtlVectorEmbeddedNetworkVar<CEconItemAttribute>
    pub const m_pManager: usize = 0x58; // CAttributeManager*
}

pub mod CAttributeManager {
    pub const m_Providers: usize = 0x8; // CUtlVector<CHandle<CBaseEntity>>
    pub const m_iReapplyProvisionParity: usize = 0x20; // int32_t
    pub const m_hOuter: usize = 0x24; // CHandle<CBaseEntity>
    pub const m_bPreventLoopback: usize = 0x28; // bool
    pub const m_ProviderType: usize = 0x2C; // attributeprovidertypes_t
    pub const m_CachedResults: usize = 0x30; // CUtlVector<CAttributeManager::cached_attribute_float_t>
}

pub mod CAttributeManager_cached_attribute_float_t {
    pub const flIn: usize = 0x0; // float
    pub const iAttribHook: usize = 0x8; // CUtlSymbolLarge
    pub const flOut: usize = 0x10; // float
}

pub mod CBarnLight {
    pub const m_bEnabled: usize = 0x700; // bool
    pub const m_nColorMode: usize = 0x704; // int32_t
    pub const m_Color: usize = 0x708; // Color
    pub const m_flColorTemperature: usize = 0x70C; // float
    pub const m_flBrightness: usize = 0x710; // float
    pub const m_flBrightnessScale: usize = 0x714; // float
    pub const m_nDirectLight: usize = 0x718; // int32_t
    pub const m_nBakedShadowIndex: usize = 0x71C; // int32_t
    pub const m_nLuminaireShape: usize = 0x720; // int32_t
    pub const m_flLuminaireSize: usize = 0x724; // float
    pub const m_flLuminaireAnisotropy: usize = 0x728; // float
    pub const m_LightStyleString: usize = 0x730; // CUtlString
    pub const m_flLightStyleStartTime: usize = 0x738; // GameTime_t
    pub const m_QueuedLightStyleStrings: usize = 0x740; // CNetworkUtlVectorBase<CUtlString>
    pub const m_LightStyleEvents: usize = 0x758; // CNetworkUtlVectorBase<CUtlString>
    pub const m_LightStyleTargets: usize = 0x770; // CNetworkUtlVectorBase<CHandle<CBaseModelEntity>>
    pub const m_StyleEvent: usize = 0x788; // CEntityIOOutput[4]
    pub const m_hLightCookie: usize = 0x848; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_flShape: usize = 0x850; // float
    pub const m_flSoftX: usize = 0x854; // float
    pub const m_flSoftY: usize = 0x858; // float
    pub const m_flSkirt: usize = 0x85C; // float
    pub const m_flSkirtNear: usize = 0x860; // float
    pub const m_vSizeParams: usize = 0x864; // Vector
    pub const m_flRange: usize = 0x870; // float
    pub const m_vShear: usize = 0x874; // Vector
    pub const m_nBakeSpecularToCubemaps: usize = 0x880; // int32_t
    pub const m_vBakeSpecularToCubemapsSize: usize = 0x884; // Vector
    pub const m_nCastShadows: usize = 0x890; // int32_t
    pub const m_nShadowMapSize: usize = 0x894; // int32_t
    pub const m_nShadowPriority: usize = 0x898; // int32_t
    pub const m_bContactShadow: usize = 0x89C; // bool
    pub const m_nBounceLight: usize = 0x8A0; // int32_t
    pub const m_flBounceScale: usize = 0x8A4; // float
    pub const m_flMinRoughness: usize = 0x8A8; // float
    pub const m_vAlternateColor: usize = 0x8AC; // Vector
    pub const m_fAlternateColorBrightness: usize = 0x8B8; // float
    pub const m_nFog: usize = 0x8BC; // int32_t
    pub const m_flFogStrength: usize = 0x8C0; // float
    pub const m_nFogShadows: usize = 0x8C4; // int32_t
    pub const m_flFogScale: usize = 0x8C8; // float
    pub const m_flFadeSizeStart: usize = 0x8CC; // float
    pub const m_flFadeSizeEnd: usize = 0x8D0; // float
    pub const m_flShadowFadeSizeStart: usize = 0x8D4; // float
    pub const m_flShadowFadeSizeEnd: usize = 0x8D8; // float
    pub const m_bPrecomputedFieldsValid: usize = 0x8DC; // bool
    pub const m_vPrecomputedBoundsMins: usize = 0x8E0; // Vector
    pub const m_vPrecomputedBoundsMaxs: usize = 0x8EC; // Vector
    pub const m_vPrecomputedOBBOrigin: usize = 0x8F8; // Vector
    pub const m_vPrecomputedOBBAngles: usize = 0x904; // QAngle
    pub const m_vPrecomputedOBBExtent: usize = 0x910; // Vector
    pub const m_bPvsModifyEntity: usize = 0x91C; // bool
}

pub mod CBaseAnimGraph {
    pub const m_bInitiallyPopulateInterpHistory: usize = 0x700; // bool
    pub const m_bShouldAnimateDuringGameplayPause: usize = 0x701; // bool
    pub const m_pChoreoServices: usize = 0x708; // IChoreoServices*
    pub const m_bAnimGraphUpdateEnabled: usize = 0x710; // bool
    pub const m_flMaxSlopeDistance: usize = 0x714; // float
    pub const m_vLastSlopeCheckPos: usize = 0x718; // Vector
    pub const m_bAnimGraphDirty: usize = 0x724; // bool
    pub const m_vecForce: usize = 0x728; // Vector
    pub const m_nForceBone: usize = 0x734; // int32_t
    pub const m_pRagdollPose: usize = 0x748; // PhysicsRagdollPose_t*
    pub const m_bClientRagdoll: usize = 0x750; // bool
}

pub mod CBaseAnimGraphController {
    pub const m_baseLayer: usize = 0x18; // CNetworkedSequenceOperation
    pub const m_animGraphNetworkedVars: usize = 0x40; // CAnimGraphNetworkedVariables
    pub const m_bSequenceFinished: usize = 0x218; // bool
    pub const m_flLastEventCycle: usize = 0x21C; // float
    pub const m_flLastEventAnimTime: usize = 0x220; // float
    pub const m_flPlaybackRate: usize = 0x224; // CNetworkedQuantizedFloat
    pub const m_flPrevAnimTime: usize = 0x22C; // float
    pub const m_bClientSideAnimation: usize = 0x230; // bool
    pub const m_bNetworkedAnimationInputsChanged: usize = 0x231; // bool
    pub const m_nNewSequenceParity: usize = 0x234; // int32_t
    pub const m_nResetEventsParity: usize = 0x238; // int32_t
    pub const m_nAnimLoopMode: usize = 0x23C; // AnimLoopMode_t
    pub const m_hAnimationUpdate: usize = 0x2DC; // AnimationUpdateListHandle_t
}

pub mod CBaseButton {
    pub const m_angMoveEntitySpace: usize = 0x780; // QAngle
    pub const m_fStayPushed: usize = 0x78C; // bool
    pub const m_fRotating: usize = 0x78D; // bool
    pub const m_ls: usize = 0x790; // locksound_t
    pub const m_sUseSound: usize = 0x7B0; // CUtlSymbolLarge
    pub const m_sLockedSound: usize = 0x7B8; // CUtlSymbolLarge
    pub const m_sUnlockedSound: usize = 0x7C0; // CUtlSymbolLarge
    pub const m_bLocked: usize = 0x7C8; // bool
    pub const m_bDisabled: usize = 0x7C9; // bool
    pub const m_flUseLockedTime: usize = 0x7CC; // GameTime_t
    pub const m_bSolidBsp: usize = 0x7D0; // bool
    pub const m_OnDamaged: usize = 0x7D8; // CEntityIOOutput
    pub const m_OnPressed: usize = 0x800; // CEntityIOOutput
    pub const m_OnUseLocked: usize = 0x828; // CEntityIOOutput
    pub const m_OnIn: usize = 0x850; // CEntityIOOutput
    pub const m_OnOut: usize = 0x878; // CEntityIOOutput
    pub const m_nState: usize = 0x8A0; // int32_t
    pub const m_hConstraint: usize = 0x8A4; // CEntityHandle
    pub const m_hConstraintParent: usize = 0x8A8; // CEntityHandle
    pub const m_bForceNpcExclude: usize = 0x8AC; // bool
    pub const m_sGlowEntity: usize = 0x8B0; // CUtlSymbolLarge
    pub const m_glowEntity: usize = 0x8B8; // CHandle<CBaseModelEntity>
    pub const m_usable: usize = 0x8BC; // bool
    pub const m_szDisplayText: usize = 0x8C0; // CUtlSymbolLarge
}

pub mod CBaseCSGrenade {
    pub const m_bRedraw: usize = 0xE20; // bool
    pub const m_bIsHeldByPlayer: usize = 0xE21; // bool
    pub const m_bPinPulled: usize = 0xE22; // bool
    pub const m_bJumpThrow: usize = 0xE23; // bool
    pub const m_eThrowStatus: usize = 0xE24; // EGrenadeThrowState
    pub const m_fThrowTime: usize = 0xE28; // GameTime_t
    pub const m_flThrowStrength: usize = 0xE2C; // float
    pub const m_flThrowStrengthApproach: usize = 0xE30; // float
    pub const m_fDropTime: usize = 0xE34; // GameTime_t
}

pub mod CBaseCSGrenadeProjectile {
    pub const m_vInitialPosition: usize = 0x9C8; // Vector
    pub const m_vInitialVelocity: usize = 0x9D4; // Vector
    pub const m_nBounces: usize = 0x9E0; // int32_t
    pub const m_nExplodeEffectIndex: usize = 0x9E8; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    pub const m_nExplodeEffectTickBegin: usize = 0x9F0; // int32_t
    pub const m_vecExplodeEffectOrigin: usize = 0x9F4; // Vector
    pub const m_flSpawnTime: usize = 0xA00; // GameTime_t
    pub const m_unOGSExtraFlags: usize = 0xA04; // uint8_t
    pub const m_bDetonationRecorded: usize = 0xA05; // bool
    pub const m_flDetonateTime: usize = 0xA08; // GameTime_t
    pub const m_nItemIndex: usize = 0xA0C; // uint16_t
    pub const m_vecOriginalSpawnLocation: usize = 0xA10; // Vector
    pub const m_flLastBounceSoundTime: usize = 0xA1C; // GameTime_t
    pub const m_vecGrenadeSpin: usize = 0xA20; // RotationVector
    pub const m_vecLastHitSurfaceNormal: usize = 0xA2C; // Vector
    pub const m_nTicksAtZeroVelocity: usize = 0xA38; // int32_t
    pub const m_bHasEverHitPlayer: usize = 0xA3C; // bool
    pub const m_bClearFromPlayers: usize = 0xA3D; // bool
}

pub mod CBaseClientUIEntity {
    pub const m_bEnabled: usize = 0x700; // bool
    pub const m_DialogXMLName: usize = 0x708; // CUtlSymbolLarge
    pub const m_PanelClassName: usize = 0x710; // CUtlSymbolLarge
    pub const m_PanelID: usize = 0x718; // CUtlSymbolLarge
    pub const m_CustomOutput0: usize = 0x720; // CEntityIOOutput
    pub const m_CustomOutput1: usize = 0x748; // CEntityIOOutput
    pub const m_CustomOutput2: usize = 0x770; // CEntityIOOutput
    pub const m_CustomOutput3: usize = 0x798; // CEntityIOOutput
    pub const m_CustomOutput4: usize = 0x7C0; // CEntityIOOutput
    pub const m_CustomOutput5: usize = 0x7E8; // CEntityIOOutput
    pub const m_CustomOutput6: usize = 0x810; // CEntityIOOutput
    pub const m_CustomOutput7: usize = 0x838; // CEntityIOOutput
    pub const m_CustomOutput8: usize = 0x860; // CEntityIOOutput
    pub const m_CustomOutput9: usize = 0x888; // CEntityIOOutput
}

pub mod CBaseCombatCharacter {
    pub const m_bForceServerRagdoll: usize = 0x920; // bool
    pub const m_hMyWearables: usize = 0x928; // CNetworkUtlVectorBase<CHandle<CEconWearable>>
    pub const m_flFieldOfView: usize = 0x940; // float
    pub const m_impactEnergyScale: usize = 0x944; // float
    pub const m_LastHitGroup: usize = 0x948; // HitGroup_t
    pub const m_bApplyStressDamage: usize = 0x94C; // bool
    pub const m_bloodColor: usize = 0x950; // int32_t
    pub const m_navMeshID: usize = 0x9B0; // int32_t
    pub const m_iDamageCount: usize = 0x9B4; // int32_t
    pub const m_pVecRelationships: usize = 0x9B8; // CUtlVector<RelationshipOverride_t>*
    pub const m_strRelationships: usize = 0x9C0; // CUtlSymbolLarge
    pub const m_eHull: usize = 0x9C8; // Hull_t
    pub const m_nNavHullIdx: usize = 0x9CC; // uint32_t
}

pub mod CBaseDMStart {
    pub const m_Master: usize = 0x4B0; // CUtlSymbolLarge
}

pub mod CBaseDoor {
    pub const m_angMoveEntitySpace: usize = 0x790; // QAngle
    pub const m_vecMoveDirParentSpace: usize = 0x79C; // Vector
    pub const m_ls: usize = 0x7A8; // locksound_t
    pub const m_bForceClosed: usize = 0x7C8; // bool
    pub const m_bDoorGroup: usize = 0x7C9; // bool
    pub const m_bLocked: usize = 0x7CA; // bool
    pub const m_bIgnoreDebris: usize = 0x7CB; // bool
    pub const m_eSpawnPosition: usize = 0x7CC; // FuncDoorSpawnPos_t
    pub const m_flBlockDamage: usize = 0x7D0; // float
    pub const m_NoiseMoving: usize = 0x7D8; // CUtlSymbolLarge
    pub const m_NoiseArrived: usize = 0x7E0; // CUtlSymbolLarge
    pub const m_NoiseMovingClosed: usize = 0x7E8; // CUtlSymbolLarge
    pub const m_NoiseArrivedClosed: usize = 0x7F0; // CUtlSymbolLarge
    pub const m_ChainTarget: usize = 0x7F8; // CUtlSymbolLarge
    pub const m_OnBlockedClosing: usize = 0x800; // CEntityIOOutput
    pub const m_OnBlockedOpening: usize = 0x828; // CEntityIOOutput
    pub const m_OnUnblockedClosing: usize = 0x850; // CEntityIOOutput
    pub const m_OnUnblockedOpening: usize = 0x878; // CEntityIOOutput
    pub const m_OnFullyClosed: usize = 0x8A0; // CEntityIOOutput
    pub const m_OnFullyOpen: usize = 0x8C8; // CEntityIOOutput
    pub const m_OnClose: usize = 0x8F0; // CEntityIOOutput
    pub const m_OnOpen: usize = 0x918; // CEntityIOOutput
    pub const m_OnLockedUse: usize = 0x940; // CEntityIOOutput
    pub const m_bLoopMoveSound: usize = 0x968; // bool
    pub const m_bCreateNavObstacle: usize = 0x980; // bool
    pub const m_isChaining: usize = 0x981; // bool
    pub const m_bIsUsable: usize = 0x982; // bool
}

pub mod CBaseEntity {
    pub const m_CBodyComponent: usize = 0x30; // CBodyComponent*
    pub const m_NetworkTransmitComponent: usize = 0x38; // CNetworkTransmitComponent
    pub const m_aThinkFunctions: usize = 0x228; // CUtlVector<thinkfunc_t>
    pub const m_iCurrentThinkContext: usize = 0x240; // int32_t
    pub const m_nLastThinkTick: usize = 0x244; // GameTick_t
    pub const m_isSteadyState: usize = 0x250; // CBitVec<64>
    pub const m_lastNetworkChange: usize = 0x258; // float
    pub const m_ResponseContexts: usize = 0x268; // CUtlVector<ResponseContext_t>
    pub const m_iszResponseContext: usize = 0x280; // CUtlSymbolLarge
    pub const m_iHealth: usize = 0x2A8; // int32_t
    pub const m_iMaxHealth: usize = 0x2AC; // int32_t
    pub const m_lifeState: usize = 0x2B0; // uint8_t
    pub const m_flDamageAccumulator: usize = 0x2B4; // float
    pub const m_bTakesDamage: usize = 0x2B8; // bool
    pub const m_nTakeDamageFlags: usize = 0x2BC; // TakeDamageFlags_t
    pub const m_MoveCollide: usize = 0x2C1; // MoveCollide_t
    pub const m_MoveType: usize = 0x2C2; // MoveType_t
    pub const m_nWaterTouch: usize = 0x2C3; // uint8_t
    pub const m_nSlimeTouch: usize = 0x2C4; // uint8_t
    pub const m_bRestoreInHierarchy: usize = 0x2C5; // bool
    pub const m_target: usize = 0x2C8; // CUtlSymbolLarge
    pub const m_flMoveDoneTime: usize = 0x2D0; // float
    pub const m_hDamageFilter: usize = 0x2D4; // CHandle<CBaseFilter>
    pub const m_iszDamageFilterName: usize = 0x2D8; // CUtlSymbolLarge
    pub const m_nSubclassID: usize = 0x2E0; // CUtlStringToken
    pub const m_flAnimTime: usize = 0x2F0; // float
    pub const m_flSimulationTime: usize = 0x2F4; // float
    pub const m_flCreateTime: usize = 0x2F8; // GameTime_t
    pub const m_bClientSideRagdoll: usize = 0x2FC; // bool
    pub const m_ubInterpolationFrame: usize = 0x2FD; // uint8_t
    pub const m_vPrevVPhysicsUpdatePos: usize = 0x300; // Vector
    pub const m_iTeamNum: usize = 0x30C; // uint8_t
    pub const m_iGlobalname: usize = 0x310; // CUtlSymbolLarge
    pub const m_iSentToClients: usize = 0x318; // int32_t
    pub const m_flSpeed: usize = 0x31C; // float
    pub const m_sUniqueHammerID: usize = 0x320; // CUtlString
    pub const m_spawnflags: usize = 0x328; // uint32_t
    pub const m_nNextThinkTick: usize = 0x32C; // GameTick_t
    pub const m_nSimulationTick: usize = 0x330; // int32_t
    pub const m_OnKilled: usize = 0x338; // CEntityIOOutput
    pub const m_fFlags: usize = 0x360; // uint32_t
    pub const m_vecAbsVelocity: usize = 0x364; // Vector
    pub const m_vecVelocity: usize = 0x370; // CNetworkVelocityVector
    pub const m_vecBaseVelocity: usize = 0x3A0; // Vector
    pub const m_nPushEnumCount: usize = 0x3AC; // int32_t
    pub const m_pCollision: usize = 0x3B0; // CCollisionProperty*
    pub const m_hEffectEntity: usize = 0x3B8; // CHandle<CBaseEntity>
    pub const m_hOwnerEntity: usize = 0x3BC; // CHandle<CBaseEntity>
    pub const m_fEffects: usize = 0x3C0; // uint32_t
    pub const m_hGroundEntity: usize = 0x3C4; // CHandle<CBaseEntity>
    pub const m_flFriction: usize = 0x3C8; // float
    pub const m_flElasticity: usize = 0x3CC; // float
    pub const m_flGravityScale: usize = 0x3D0; // float
    pub const m_flTimeScale: usize = 0x3D4; // float
    pub const m_flWaterLevel: usize = 0x3D8; // float
    pub const m_bSimulatedEveryTick: usize = 0x3DC; // bool
    pub const m_bAnimatedEveryTick: usize = 0x3DD; // bool
    pub const m_bDisableLowViolence: usize = 0x3DE; // bool
    pub const m_nWaterType: usize = 0x3DF; // uint8_t
    pub const m_iEFlags: usize = 0x3E0; // int32_t
    pub const m_OnUser1: usize = 0x3E8; // CEntityIOOutput
    pub const m_OnUser2: usize = 0x410; // CEntityIOOutput
    pub const m_OnUser3: usize = 0x438; // CEntityIOOutput
    pub const m_OnUser4: usize = 0x460; // CEntityIOOutput
    pub const m_iInitialTeamNum: usize = 0x488; // int32_t
    pub const m_flNavIgnoreUntilTime: usize = 0x48C; // GameTime_t
    pub const m_vecAngVelocity: usize = 0x490; // QAngle
    pub const m_bNetworkQuantizeOriginAndAngles: usize = 0x49C; // bool
    pub const m_bLagCompensate: usize = 0x49D; // bool
    pub const m_flOverriddenFriction: usize = 0x4A0; // float
    pub const m_pBlocker: usize = 0x4A4; // CHandle<CBaseEntity>
    pub const m_flLocalTime: usize = 0x4A8; // float
    pub const m_flVPhysicsUpdateLocalTime: usize = 0x4AC; // float
}

pub mod CBaseFilter {
    pub const m_bNegated: usize = 0x4B0; // bool
    pub const m_OnPass: usize = 0x4B8; // CEntityIOOutput
    pub const m_OnFail: usize = 0x4E0; // CEntityIOOutput
}

pub mod CBaseFire {
    pub const m_flScale: usize = 0x4B0; // float
    pub const m_flStartScale: usize = 0x4B4; // float
    pub const m_flScaleTime: usize = 0x4B8; // float
    pub const m_nFlags: usize = 0x4BC; // uint32_t
}

pub mod CBaseFlex {
    pub const m_flexWeight: usize = 0x890; // CNetworkUtlVectorBase<float>
    pub const m_vLookTargetPosition: usize = 0x8A8; // Vector
    pub const m_blinktoggle: usize = 0x8B4; // bool
    pub const m_flAllowResponsesEndTime: usize = 0x908; // GameTime_t
    pub const m_flLastFlexAnimationTime: usize = 0x90C; // GameTime_t
    pub const m_nNextSceneEventId: usize = 0x910; // uint32_t
    pub const m_bUpdateLayerPriorities: usize = 0x914; // bool
}

pub mod CBaseGrenade {
    pub const m_OnPlayerPickup: usize = 0x928; // CEntityIOOutput
    pub const m_OnExplode: usize = 0x950; // CEntityIOOutput
    pub const m_bHasWarnedAI: usize = 0x978; // bool
    pub const m_bIsSmokeGrenade: usize = 0x979; // bool
    pub const m_bIsLive: usize = 0x97A; // bool
    pub const m_DmgRadius: usize = 0x97C; // float
    pub const m_flDetonateTime: usize = 0x980; // GameTime_t
    pub const m_flWarnAITime: usize = 0x984; // float
    pub const m_flDamage: usize = 0x988; // float
    pub const m_iszBounceSound: usize = 0x990; // CUtlSymbolLarge
    pub const m_ExplosionSound: usize = 0x998; // CUtlString
    pub const m_hThrower: usize = 0x9A4; // CHandle<CCSPlayerPawn>
    pub const m_flNextAttack: usize = 0x9BC; // GameTime_t
    pub const m_hOriginalThrower: usize = 0x9C0; // CHandle<CCSPlayerPawn>
}

pub mod CBaseIssue {
    pub const m_szTypeString: usize = 0x20; // char[64]
    pub const m_szDetailsString: usize = 0x60; // char[260]
    pub const m_iNumYesVotes: usize = 0x164; // int32_t
    pub const m_iNumNoVotes: usize = 0x168; // int32_t
    pub const m_iNumPotentialVotes: usize = 0x16C; // int32_t
    pub const m_pVoteController: usize = 0x170; // CVoteController*
}

pub mod CBaseModelEntity {
    pub const m_CRenderComponent: usize = 0x4B0; // CRenderComponent*
    pub const m_CHitboxComponent: usize = 0x4B8; // CHitboxComponent
    pub const m_flDissolveStartTime: usize = 0x4E0; // GameTime_t
    pub const m_OnIgnite: usize = 0x4E8; // CEntityIOOutput
    pub const m_nRenderMode: usize = 0x510; // RenderMode_t
    pub const m_nRenderFX: usize = 0x511; // RenderFx_t
    pub const m_bAllowFadeInView: usize = 0x512; // bool
    pub const m_clrRender: usize = 0x513; // Color
    pub const m_vecRenderAttributes: usize = 0x518; // CUtlVectorEmbeddedNetworkVar<EntityRenderAttribute_t>
    pub const m_bRenderToCubemaps: usize = 0x568; // bool
    pub const m_Collision: usize = 0x570; // CCollisionProperty
    pub const m_Glow: usize = 0x620; // CGlowProperty
    pub const m_flGlowBackfaceMult: usize = 0x678; // float
    pub const m_fadeMinDist: usize = 0x67C; // float
    pub const m_fadeMaxDist: usize = 0x680; // float
    pub const m_flFadeScale: usize = 0x684; // float
    pub const m_flShadowStrength: usize = 0x688; // float
    pub const m_nObjectCulling: usize = 0x68C; // uint8_t
    pub const m_nAddDecal: usize = 0x690; // int32_t
    pub const m_vDecalPosition: usize = 0x694; // Vector
    pub const m_vDecalForwardAxis: usize = 0x6A0; // Vector
    pub const m_flDecalHealBloodRate: usize = 0x6AC; // float
    pub const m_flDecalHealHeightRate: usize = 0x6B0; // float
    pub const m_ConfigEntitiesToPropagateMaterialDecalsTo: usize = 0x6B8; // CNetworkUtlVectorBase<CHandle<CBaseModelEntity>>
    pub const m_vecViewOffset: usize = 0x6D0; // CNetworkViewOffsetVector
}

pub mod CBaseMoveBehavior {
    pub const m_iPositionInterpolator: usize = 0x510; // int32_t
    pub const m_iRotationInterpolator: usize = 0x514; // int32_t
    pub const m_flAnimStartTime: usize = 0x518; // float
    pub const m_flAnimEndTime: usize = 0x51C; // float
    pub const m_flAverageSpeedAcrossFrame: usize = 0x520; // float
    pub const m_pCurrentKeyFrame: usize = 0x528; // CPathKeyFrame*
    pub const m_pTargetKeyFrame: usize = 0x530; // CPathKeyFrame*
    pub const m_pPreKeyFrame: usize = 0x538; // CPathKeyFrame*
    pub const m_pPostKeyFrame: usize = 0x540; // CPathKeyFrame*
    pub const m_flTimeIntoFrame: usize = 0x548; // float
    pub const m_iDirection: usize = 0x54C; // int32_t
}

pub mod CBasePlatTrain {
    pub const m_NoiseMoving: usize = 0x780; // CUtlSymbolLarge
    pub const m_NoiseArrived: usize = 0x788; // CUtlSymbolLarge
    pub const m_volume: usize = 0x798; // float
    pub const m_flTWidth: usize = 0x79C; // float
    pub const m_flTLength: usize = 0x7A0; // float
}

pub mod CBasePlayerController {
    pub const m_nInButtonsWhichAreToggles: usize = 0x4B8; // uint64_t
    pub const m_nTickBase: usize = 0x4C0; // uint32_t
    pub const m_hPawn: usize = 0x4F0; // CHandle<CBasePlayerPawn>
    pub const m_nSplitScreenSlot: usize = 0x4F4; // CSplitScreenSlot
    pub const m_hSplitOwner: usize = 0x4F8; // CHandle<CBasePlayerController>
    pub const m_hSplitScreenPlayers: usize = 0x500; // CUtlVector<CHandle<CBasePlayerController>>
    pub const m_bIsHLTV: usize = 0x518; // bool
    pub const m_iConnected: usize = 0x51C; // PlayerConnectedState
    pub const m_iszPlayerName: usize = 0x520; // char[128]
    pub const m_szNetworkIDString: usize = 0x5A0; // CUtlString
    pub const m_fLerpTime: usize = 0x5A8; // float
    pub const m_bLagCompensation: usize = 0x5AC; // bool
    pub const m_bPredict: usize = 0x5AD; // bool
    pub const m_bAutoKickDisabled: usize = 0x5AE; // bool
    pub const m_bIsLowViolence: usize = 0x5AF; // bool
    pub const m_bGamePaused: usize = 0x5B0; // bool
    pub const m_nUsecTimestampLastUserCmdReceived: usize = 0x648; // int64_t
    pub const m_iIgnoreGlobalChat: usize = 0x660; // ChatIgnoreType_t
    pub const m_flLastPlayerTalkTime: usize = 0x664; // float
    pub const m_flLastEntitySteadyState: usize = 0x668; // float
    pub const m_nAvailableEntitySteadyState: usize = 0x66C; // int32_t
    pub const m_bHasAnySteadyStateEnts: usize = 0x670; // bool
    pub const m_steamID: usize = 0x680; // uint64_t
    pub const m_iDesiredFOV: usize = 0x688; // uint32_t
}

pub mod CBasePlayerPawn {
    pub const m_pWeaponServices: usize = 0x9D0; // CPlayer_WeaponServices*
    pub const m_pItemServices: usize = 0x9D8; // CPlayer_ItemServices*
    pub const m_pAutoaimServices: usize = 0x9E0; // CPlayer_AutoaimServices*
    pub const m_pObserverServices: usize = 0x9E8; // CPlayer_ObserverServices*
    pub const m_pWaterServices: usize = 0x9F0; // CPlayer_WaterServices*
    pub const m_pUseServices: usize = 0x9F8; // CPlayer_UseServices*
    pub const m_pFlashlightServices: usize = 0xA00; // CPlayer_FlashlightServices*
    pub const m_pCameraServices: usize = 0xA08; // CPlayer_CameraServices*
    pub const m_pMovementServices: usize = 0xA10; // CPlayer_MovementServices*
    pub const m_ServerViewAngleChanges: usize = 0xA20; // CUtlVectorEmbeddedNetworkVar<ViewAngleServerChange_t>
    pub const m_nHighestGeneratedServerViewAngleChangeIndex: usize = 0xA70; // uint32_t
    pub const v_angle: usize = 0xA74; // QAngle
    pub const v_anglePrevious: usize = 0xA80; // QAngle
    pub const m_iHideHUD: usize = 0xA8C; // uint32_t
    pub const m_skybox3d: usize = 0xA90; // sky3dparams_t
    pub const m_fTimeLastHurt: usize = 0xB20; // GameTime_t
    pub const m_flDeathTime: usize = 0xB24; // GameTime_t
    pub const m_fNextSuicideTime: usize = 0xB28; // GameTime_t
    pub const m_fInitHUD: usize = 0xB2C; // bool
    pub const m_pExpresser: usize = 0xB30; // CAI_Expresser*
    pub const m_hController: usize = 0xB38; // CHandle<CBasePlayerController>
    pub const m_fHltvReplayDelay: usize = 0xB40; // float
    pub const m_fHltvReplayEnd: usize = 0xB44; // float
    pub const m_iHltvReplayEntity: usize = 0xB48; // CEntityIndex
}

pub mod CBasePlayerVData {
    pub const m_sModelName: usize = 0x28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    pub const m_flHeadDamageMultiplier: usize = 0x108; // CSkillFloat
    pub const m_flChestDamageMultiplier: usize = 0x118; // CSkillFloat
    pub const m_flStomachDamageMultiplier: usize = 0x128; // CSkillFloat
    pub const m_flArmDamageMultiplier: usize = 0x138; // CSkillFloat
    pub const m_flLegDamageMultiplier: usize = 0x148; // CSkillFloat
    pub const m_flHoldBreathTime: usize = 0x158; // float
    pub const m_flDrowningDamageInterval: usize = 0x15C; // float
    pub const m_nDrowningDamageInitial: usize = 0x160; // int32_t
    pub const m_nDrowningDamageMax: usize = 0x164; // int32_t
    pub const m_nWaterSpeed: usize = 0x168; // int32_t
    pub const m_flUseRange: usize = 0x16C; // float
    pub const m_flUseAngleTolerance: usize = 0x170; // float
    pub const m_flCrouchTime: usize = 0x174; // float
}

pub mod CBasePlayerWeapon {
    pub const m_nNextPrimaryAttackTick: usize = 0xC18; // GameTick_t
    pub const m_flNextPrimaryAttackTickRatio: usize = 0xC1C; // float
    pub const m_nNextSecondaryAttackTick: usize = 0xC20; // GameTick_t
    pub const m_flNextSecondaryAttackTickRatio: usize = 0xC24; // float
    pub const m_iClip1: usize = 0xC28; // int32_t
    pub const m_iClip2: usize = 0xC2C; // int32_t
    pub const m_pReserveAmmo: usize = 0xC30; // int32_t[2]
    pub const m_OnPlayerUse: usize = 0xC38; // CEntityIOOutput
}

pub mod CBasePlayerWeaponVData {
    pub const m_szWorldModel: usize = 0x28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    pub const m_bBuiltRightHanded: usize = 0x108; // bool
    pub const m_bAllowFlipping: usize = 0x109; // bool
    pub const m_bIsFullAuto: usize = 0x10A; // bool
    pub const m_nNumBullets: usize = 0x10C; // int32_t
    pub const m_sMuzzleAttachment: usize = 0x110; // CUtlString
    pub const m_szMuzzleFlashParticle: usize = 0x118; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    pub const m_iFlags: usize = 0x1F8; // ItemFlagTypes_t
    pub const m_nPrimaryAmmoType: usize = 0x1F9; // AmmoIndex_t
    pub const m_nSecondaryAmmoType: usize = 0x1FA; // AmmoIndex_t
    pub const m_iMaxClip1: usize = 0x1FC; // int32_t
    pub const m_iMaxClip2: usize = 0x200; // int32_t
    pub const m_iDefaultClip1: usize = 0x204; // int32_t
    pub const m_iDefaultClip2: usize = 0x208; // int32_t
    pub const m_iWeight: usize = 0x20C; // int32_t
    pub const m_bAutoSwitchTo: usize = 0x210; // bool
    pub const m_bAutoSwitchFrom: usize = 0x211; // bool
    pub const m_iRumbleEffect: usize = 0x214; // RumbleEffect_t
    pub const m_aShootSounds: usize = 0x218; // CUtlMap<WeaponSound_t,CSoundEventName>
    pub const m_iSlot: usize = 0x238; // int32_t
    pub const m_iPosition: usize = 0x23C; // int32_t
}

pub mod CBaseProp {
    pub const m_bModelOverrodeBlockLOS: usize = 0x890; // bool
    pub const m_iShapeType: usize = 0x894; // int32_t
    pub const m_bConformToCollisionBounds: usize = 0x898; // bool
    pub const m_mPreferredCatchTransform: usize = 0x89C; // matrix3x4_t
}

pub mod CBasePropDoor {
    pub const m_flAutoReturnDelay: usize = 0xB18; // float
    pub const m_hDoorList: usize = 0xB20; // CUtlVector<CHandle<CBasePropDoor>>
    pub const m_nHardwareType: usize = 0xB38; // int32_t
    pub const m_bNeedsHardware: usize = 0xB3C; // bool
    pub const m_eDoorState: usize = 0xB40; // DoorState_t
    pub const m_bLocked: usize = 0xB44; // bool
    pub const m_closedPosition: usize = 0xB48; // Vector
    pub const m_closedAngles: usize = 0xB54; // QAngle
    pub const m_hBlocker: usize = 0xB60; // CHandle<CBaseEntity>
    pub const m_bFirstBlocked: usize = 0xB64; // bool
    pub const m_ls: usize = 0xB68; // locksound_t
    pub const m_bForceClosed: usize = 0xB88; // bool
    pub const m_vecLatchWorldPosition: usize = 0xB8C; // Vector
    pub const m_hActivator: usize = 0xB98; // CHandle<CBaseEntity>
    pub const m_SoundMoving: usize = 0xBA8; // CUtlSymbolLarge
    pub const m_SoundOpen: usize = 0xBB0; // CUtlSymbolLarge
    pub const m_SoundClose: usize = 0xBB8; // CUtlSymbolLarge
    pub const m_SoundLock: usize = 0xBC0; // CUtlSymbolLarge
    pub const m_SoundUnlock: usize = 0xBC8; // CUtlSymbolLarge
    pub const m_SoundLatch: usize = 0xBD0; // CUtlSymbolLarge
    pub const m_SoundPound: usize = 0xBD8; // CUtlSymbolLarge
    pub const m_SoundJiggle: usize = 0xBE0; // CUtlSymbolLarge
    pub const m_SoundLockedAnim: usize = 0xBE8; // CUtlSymbolLarge
    pub const m_numCloseAttempts: usize = 0xBF0; // int32_t
    pub const m_nPhysicsMaterial: usize = 0xBF4; // CUtlStringToken
    pub const m_SlaveName: usize = 0xBF8; // CUtlSymbolLarge
    pub const m_hMaster: usize = 0xC00; // CHandle<CBasePropDoor>
    pub const m_OnBlockedClosing: usize = 0xC08; // CEntityIOOutput
    pub const m_OnBlockedOpening: usize = 0xC30; // CEntityIOOutput
    pub const m_OnUnblockedClosing: usize = 0xC58; // CEntityIOOutput
    pub const m_OnUnblockedOpening: usize = 0xC80; // CEntityIOOutput
    pub const m_OnFullyClosed: usize = 0xCA8; // CEntityIOOutput
    pub const m_OnFullyOpen: usize = 0xCD0; // CEntityIOOutput
    pub const m_OnClose: usize = 0xCF8; // CEntityIOOutput
    pub const m_OnOpen: usize = 0xD20; // CEntityIOOutput
    pub const m_OnLockedUse: usize = 0xD48; // CEntityIOOutput
    pub const m_OnAjarOpen: usize = 0xD70; // CEntityIOOutput
}

pub mod CBaseToggle {
    pub const m_toggle_state: usize = 0x700; // TOGGLE_STATE
    pub const m_flMoveDistance: usize = 0x704; // float
    pub const m_flWait: usize = 0x708; // float
    pub const m_flLip: usize = 0x70C; // float
    pub const m_bAlwaysFireBlockedOutputs: usize = 0x710; // bool
    pub const m_vecPosition1: usize = 0x714; // Vector
    pub const m_vecPosition2: usize = 0x720; // Vector
    pub const m_vecMoveAng: usize = 0x72C; // QAngle
    pub const m_vecAngle1: usize = 0x738; // QAngle
    pub const m_vecAngle2: usize = 0x744; // QAngle
    pub const m_flHeight: usize = 0x750; // float
    pub const m_hActivator: usize = 0x754; // CHandle<CBaseEntity>
    pub const m_vecFinalDest: usize = 0x758; // Vector
    pub const m_vecFinalAngle: usize = 0x764; // QAngle
    pub const m_movementType: usize = 0x770; // int32_t
    pub const m_sMaster: usize = 0x778; // CUtlSymbolLarge
}

pub mod CBaseTrigger {
    pub const m_bDisabled: usize = 0x780; // bool
    pub const m_iFilterName: usize = 0x788; // CUtlSymbolLarge
    pub const m_hFilter: usize = 0x790; // CHandle<CBaseFilter>
    pub const m_OnStartTouch: usize = 0x798; // CEntityIOOutput
    pub const m_OnStartTouchAll: usize = 0x7C0; // CEntityIOOutput
    pub const m_OnEndTouch: usize = 0x7E8; // CEntityIOOutput
    pub const m_OnEndTouchAll: usize = 0x810; // CEntityIOOutput
    pub const m_OnTouching: usize = 0x838; // CEntityIOOutput
    pub const m_OnNotTouching: usize = 0x860; // CEntityIOOutput
    pub const m_hTouchingEntities: usize = 0x888; // CUtlVector<CHandle<CBaseEntity>>
    pub const m_bClientSidePredicted: usize = 0x8A0; // bool
}

pub mod CBaseViewModel {
    pub const m_vecLastFacing: usize = 0x898; // Vector
    pub const m_nViewModelIndex: usize = 0x8A4; // uint32_t
    pub const m_nAnimationParity: usize = 0x8A8; // uint32_t
    pub const m_flAnimationStartTime: usize = 0x8AC; // float
    pub const m_hWeapon: usize = 0x8B0; // CHandle<CBasePlayerWeapon>
    pub const m_sVMName: usize = 0x8B8; // CUtlSymbolLarge
    pub const m_sAnimationPrefix: usize = 0x8C0; // CUtlSymbolLarge
    pub const m_hOldLayerSequence: usize = 0x8C8; // HSequence
    pub const m_oldLayer: usize = 0x8CC; // int32_t
    pub const m_oldLayerStartTime: usize = 0x8D0; // float
    pub const m_hControlPanel: usize = 0x8D4; // CHandle<CBaseEntity>
}

pub mod CBeam {
    pub const m_flFrameRate: usize = 0x700; // float
    pub const m_flHDRColorScale: usize = 0x704; // float
    pub const m_flFireTime: usize = 0x708; // GameTime_t
    pub const m_flDamage: usize = 0x70C; // float
    pub const m_nNumBeamEnts: usize = 0x710; // uint8_t
    pub const m_hBaseMaterial: usize = 0x718; // CStrongHandle<InfoForResourceTypeIMaterial2>
    pub const m_nHaloIndex: usize = 0x720; // CStrongHandle<InfoForResourceTypeIMaterial2>
    pub const m_nBeamType: usize = 0x728; // BeamType_t
    pub const m_nBeamFlags: usize = 0x72C; // uint32_t
    pub const m_hAttachEntity: usize = 0x730; // CHandle<CBaseEntity>[10]
    pub const m_nAttachIndex: usize = 0x758; // AttachmentHandle_t[10]
    pub const m_fWidth: usize = 0x764; // float
    pub const m_fEndWidth: usize = 0x768; // float
    pub const m_fFadeLength: usize = 0x76C; // float
    pub const m_fHaloScale: usize = 0x770; // float
    pub const m_fAmplitude: usize = 0x774; // float
    pub const m_fStartFrame: usize = 0x778; // float
    pub const m_fSpeed: usize = 0x77C; // float
    pub const m_flFrame: usize = 0x780; // float
    pub const m_nClipStyle: usize = 0x784; // BeamClipStyle_t
    pub const m_bTurnedOff: usize = 0x788; // bool
    pub const m_vecEndPos: usize = 0x78C; // Vector
    pub const m_hEndEntity: usize = 0x798; // CHandle<CBaseEntity>
    pub const m_nDissolveType: usize = 0x79C; // int32_t
}

pub mod CBlood {
    pub const m_vecSprayAngles: usize = 0x4B0; // QAngle
    pub const m_vecSprayDir: usize = 0x4BC; // Vector
    pub const m_flAmount: usize = 0x4C8; // float
    pub const m_Color: usize = 0x4CC; // int32_t
}

pub mod CBodyComponent {
    pub const m_pSceneNode: usize = 0x8; // CGameSceneNode*
    pub const __m_pChainEntity: usize = 0x20; // CNetworkVarChainer
}

pub mod CBodyComponentBaseAnimGraph {
    pub const m_animationController: usize = 0x480; // CBaseAnimGraphController
    pub const __m_pChainEntity: usize = 0x760; // CNetworkVarChainer
}

pub mod CBodyComponentBaseModelEntity {
    pub const __m_pChainEntity: usize = 0x480; // CNetworkVarChainer
}

pub mod CBodyComponentPoint {
    pub const m_sceneNode: usize = 0x50; // CGameSceneNode
    pub const __m_pChainEntity: usize = 0x1A0; // CNetworkVarChainer
}

pub mod CBodyComponentSkeletonInstance {
    pub const m_skeletonInstance: usize = 0x50; // CSkeletonInstance
    pub const __m_pChainEntity: usize = 0x450; // CNetworkVarChainer
}

pub mod CBombTarget {
    pub const m_OnBombExplode: usize = 0x8A8; // CEntityIOOutput
    pub const m_OnBombPlanted: usize = 0x8D0; // CEntityIOOutput
    pub const m_OnBombDefused: usize = 0x8F8; // CEntityIOOutput
    pub const m_bIsBombSiteB: usize = 0x920; // bool
    pub const m_bIsHeistBombTarget: usize = 0x921; // bool
    pub const m_bBombPlantedHere: usize = 0x922; // bool
    pub const m_szMountTarget: usize = 0x928; // CUtlSymbolLarge
    pub const m_hInstructorHint: usize = 0x930; // CHandle<CBaseEntity>
    pub const m_nBombSiteDesignation: usize = 0x934; // int32_t
}

pub mod CBot {
    pub const m_pController: usize = 0x10; // CCSPlayerController*
    pub const m_pPlayer: usize = 0x18; // CCSPlayerPawn*
    pub const m_bHasSpawned: usize = 0x20; // bool
    pub const m_id: usize = 0x24; // uint32_t
    pub const m_isRunning: usize = 0xB8; // bool
    pub const m_isCrouching: usize = 0xB9; // bool
    pub const m_forwardSpeed: usize = 0xBC; // float
    pub const m_leftSpeed: usize = 0xC0; // float
    pub const m_verticalSpeed: usize = 0xC4; // float
    pub const m_buttonFlags: usize = 0xC8; // uint64_t
    pub const m_jumpTimestamp: usize = 0xD0; // float
    pub const m_viewForward: usize = 0xD4; // Vector
    pub const m_postureStackIndex: usize = 0xF0; // int32_t
}

pub mod CBreakable {
    pub const m_Material: usize = 0x710; // Materials
    pub const m_hBreaker: usize = 0x714; // CHandle<CBaseEntity>
    pub const m_Explosion: usize = 0x718; // Explosions
    pub const m_iszSpawnObject: usize = 0x720; // CUtlSymbolLarge
    pub const m_flPressureDelay: usize = 0x728; // float
    pub const m_iMinHealthDmg: usize = 0x72C; // int32_t
    pub const m_iszPropData: usize = 0x730; // CUtlSymbolLarge
    pub const m_impactEnergyScale: usize = 0x738; // float
    pub const m_nOverrideBlockLOS: usize = 0x73C; // EOverrideBlockLOS_t
    pub const m_OnBreak: usize = 0x740; // CEntityIOOutput
    pub const m_OnHealthChanged: usize = 0x768; // CEntityOutputTemplate<float>
    pub const m_flDmgModBullet: usize = 0x790; // float
    pub const m_flDmgModClub: usize = 0x794; // float
    pub const m_flDmgModExplosive: usize = 0x798; // float
    pub const m_flDmgModFire: usize = 0x79C; // float
    pub const m_iszPhysicsDamageTableName: usize = 0x7A0; // CUtlSymbolLarge
    pub const m_iszBasePropData: usize = 0x7A8; // CUtlSymbolLarge
    pub const m_iInteractions: usize = 0x7B0; // int32_t
    pub const m_PerformanceMode: usize = 0x7B4; // PerformanceMode_t
    pub const m_hPhysicsAttacker: usize = 0x7B8; // CHandle<CBasePlayerPawn>
    pub const m_flLastPhysicsInfluenceTime: usize = 0x7BC; // GameTime_t
}

pub mod CBreakableProp {
    pub const m_OnBreak: usize = 0x8E0; // CEntityIOOutput
    pub const m_OnHealthChanged: usize = 0x908; // CEntityOutputTemplate<float>
    pub const m_OnTakeDamage: usize = 0x930; // CEntityIOOutput
    pub const m_impactEnergyScale: usize = 0x958; // float
    pub const m_iMinHealthDmg: usize = 0x95C; // int32_t
    pub const m_preferredCarryAngles: usize = 0x960; // QAngle
    pub const m_flPressureDelay: usize = 0x96C; // float
    pub const m_hBreaker: usize = 0x970; // CHandle<CBaseEntity>
    pub const m_PerformanceMode: usize = 0x974; // PerformanceMode_t
    pub const m_flDmgModBullet: usize = 0x978; // float
    pub const m_flDmgModClub: usize = 0x97C; // float
    pub const m_flDmgModExplosive: usize = 0x980; // float
    pub const m_flDmgModFire: usize = 0x984; // float
    pub const m_iszPhysicsDamageTableName: usize = 0x988; // CUtlSymbolLarge
    pub const m_iszBasePropData: usize = 0x990; // CUtlSymbolLarge
    pub const m_iInteractions: usize = 0x998; // int32_t
    pub const m_flPreventDamageBeforeTime: usize = 0x99C; // GameTime_t
    pub const m_bHasBreakPiecesOrCommands: usize = 0x9A0; // bool
    pub const m_explodeDamage: usize = 0x9A4; // float
    pub const m_explodeRadius: usize = 0x9A8; // float
    pub const m_explosionDelay: usize = 0x9B0; // float
    pub const m_explosionBuildupSound: usize = 0x9B8; // CUtlSymbolLarge
    pub const m_explosionCustomEffect: usize = 0x9C0; // CUtlSymbolLarge
    pub const m_explosionCustomSound: usize = 0x9C8; // CUtlSymbolLarge
    pub const m_explosionModifier: usize = 0x9D0; // CUtlSymbolLarge
    pub const m_hPhysicsAttacker: usize = 0x9D8; // CHandle<CBasePlayerPawn>
    pub const m_flLastPhysicsInfluenceTime: usize = 0x9DC; // GameTime_t
    pub const m_bOriginalBlockLOS: usize = 0x9E0; // bool
    pub const m_flDefaultFadeScale: usize = 0x9E4; // float
    pub const m_hLastAttacker: usize = 0x9E8; // CHandle<CBaseEntity>
    pub const m_hFlareEnt: usize = 0x9EC; // CHandle<CBaseEntity>
    pub const m_bUsePuntSound: usize = 0x9F0; // bool
    pub const m_iszPuntSound: usize = 0x9F8; // CUtlSymbolLarge
    pub const m_noGhostCollision: usize = 0xA00; // bool
}

pub mod CBreakableStageHelper {
    pub const m_nCurrentStage: usize = 0x8; // int32_t
    pub const m_nStageCount: usize = 0xC; // int32_t
}

pub mod CBtActionAim {
    pub const m_szSensorInputKey: usize = 0x68; // CUtlString
    pub const m_szAimReadyKey: usize = 0x80; // CUtlString
    pub const m_flZoomCooldownTimestamp: usize = 0x88; // float
    pub const m_bDoneAiming: usize = 0x8C; // bool
    pub const m_flLerpStartTime: usize = 0x90; // float
    pub const m_flNextLookTargetLerpTime: usize = 0x94; // float
    pub const m_flPenaltyReductionRatio: usize = 0x98; // float
    pub const m_NextLookTarget: usize = 0x9C; // QAngle
    pub const m_AimTimer: usize = 0xA8; // CountdownTimer
    pub const m_SniperHoldTimer: usize = 0xC0; // CountdownTimer
    pub const m_FocusIntervalTimer: usize = 0xD8; // CountdownTimer
    pub const m_bAcquired: usize = 0xF0; // bool
}

pub mod CBtActionCombatPositioning {
    pub const m_szSensorInputKey: usize = 0x68; // CUtlString
    pub const m_szIsAttackingKey: usize = 0x80; // CUtlString
    pub const m_ActionTimer: usize = 0x88; // CountdownTimer
    pub const m_bCrouching: usize = 0xA0; // bool
}

pub mod CBtActionMoveTo {
    pub const m_szDestinationInputKey: usize = 0x60; // CUtlString
    pub const m_szHidingSpotInputKey: usize = 0x68; // CUtlString
    pub const m_szThreatInputKey: usize = 0x70; // CUtlString
    pub const m_vecDestination: usize = 0x78; // Vector
    pub const m_bAutoLookAdjust: usize = 0x84; // bool
    pub const m_bComputePath: usize = 0x85; // bool
    pub const m_flDamagingAreasPenaltyCost: usize = 0x88; // float
    pub const m_CheckApproximateCornersTimer: usize = 0x90; // CountdownTimer
    pub const m_CheckHighPriorityItem: usize = 0xA8; // CountdownTimer
    pub const m_RepathTimer: usize = 0xC0; // CountdownTimer
    pub const m_flArrivalEpsilon: usize = 0xD8; // float
    pub const m_flAdditionalArrivalEpsilon2D: usize = 0xDC; // float
    pub const m_flHidingSpotCheckDistanceThreshold: usize = 0xE0; // float
    pub const m_flNearestAreaDistanceThreshold: usize = 0xE4; // float
}

pub mod CBtActionParachutePositioning {
    pub const m_ActionTimer: usize = 0x58; // CountdownTimer
}

pub mod CBtNodeCondition {
    pub const m_bNegated: usize = 0x58; // bool
}

pub mod CBtNodeConditionInactive {
    pub const m_flRoundStartThresholdSeconds: usize = 0x78; // float
    pub const m_flSensorInactivityThresholdSeconds: usize = 0x7C; // float
    pub const m_SensorInactivityTimer: usize = 0x80; // CountdownTimer
}

pub mod CBubbling {
    pub const m_density: usize = 0x700; // int32_t
    pub const m_frequency: usize = 0x704; // int32_t
    pub const m_state: usize = 0x708; // int32_t
}

pub mod CBuoyancyHelper {
    pub const m_flFluidDensity: usize = 0x18; // float
}

pub mod CBuyZone {
    pub const m_LegacyTeamNum: usize = 0x8A8; // int32_t
}

pub mod CC4 {
    pub const m_vecLastValidPlayerHeldPosition: usize = 0xE20; // Vector
    pub const m_vecLastValidDroppedPosition: usize = 0xE2C; // Vector
    pub const m_bDoValidDroppedPositionCheck: usize = 0xE38; // bool
    pub const m_bStartedArming: usize = 0xE39; // bool
    pub const m_fArmedTime: usize = 0xE3C; // GameTime_t
    pub const m_bBombPlacedAnimation: usize = 0xE40; // bool
    pub const m_bIsPlantingViaUse: usize = 0xE41; // bool
    pub const m_entitySpottedState: usize = 0xE48; // EntitySpottedState_t
    pub const m_nSpotRules: usize = 0xE60; // int32_t
    pub const m_bPlayedArmingBeeps: usize = 0xE64; // bool[7]
    pub const m_bBombPlanted: usize = 0xE6B; // bool
    pub const m_bDroppedFromDeath: usize = 0xE6C; // bool
}

pub mod CCSBot {
    pub const m_lastCoopSpawnPoint: usize = 0xF8; // CHandle<SpawnPointCoopEnemy>
    pub const m_eyePosition: usize = 0x108; // Vector
    pub const m_name: usize = 0x114; // char[64]
    pub const m_combatRange: usize = 0x154; // float
    pub const m_isRogue: usize = 0x158; // bool
    pub const m_rogueTimer: usize = 0x160; // CountdownTimer
    pub const m_diedLastRound: usize = 0x17C; // bool
    pub const m_safeTime: usize = 0x180; // float
    pub const m_wasSafe: usize = 0x184; // bool
    pub const m_blindFire: usize = 0x18C; // bool
    pub const m_surpriseTimer: usize = 0x190; // CountdownTimer
    pub const m_bAllowActive: usize = 0x1A8; // bool
    pub const m_isFollowing: usize = 0x1A9; // bool
    pub const m_leader: usize = 0x1AC; // CHandle<CCSPlayerPawn>
    pub const m_followTimestamp: usize = 0x1B0; // float
    pub const m_allowAutoFollowTime: usize = 0x1B4; // float
    pub const m_hurryTimer: usize = 0x1B8; // CountdownTimer
    pub const m_alertTimer: usize = 0x1D0; // CountdownTimer
    pub const m_sneakTimer: usize = 0x1E8; // CountdownTimer
    pub const m_panicTimer: usize = 0x200; // CountdownTimer
    pub const m_stateTimestamp: usize = 0x4D0; // float
    pub const m_isAttacking: usize = 0x4D4; // bool
    pub const m_isOpeningDoor: usize = 0x4D5; // bool
    pub const m_taskEntity: usize = 0x4DC; // CHandle<CBaseEntity>
    pub const m_goalPosition: usize = 0x4EC; // Vector
    pub const m_goalEntity: usize = 0x4F8; // CHandle<CBaseEntity>
    pub const m_avoid: usize = 0x4FC; // CHandle<CBaseEntity>
    pub const m_avoidTimestamp: usize = 0x500; // float
    pub const m_isStopping: usize = 0x504; // bool
    pub const m_hasVisitedEnemySpawn: usize = 0x505; // bool
    pub const m_stillTimer: usize = 0x508; // IntervalTimer
    pub const m_bEyeAnglesUnderPathFinderControl: usize = 0x518; // bool
    pub const m_pathIndex: usize = 0x6610; // int32_t
    pub const m_areaEnteredTimestamp: usize = 0x6614; // GameTime_t
    pub const m_repathTimer: usize = 0x6618; // CountdownTimer
    pub const m_avoidFriendTimer: usize = 0x6630; // CountdownTimer
    pub const m_isFriendInTheWay: usize = 0x6648; // bool
    pub const m_politeTimer: usize = 0x6650; // CountdownTimer
    pub const m_isWaitingBehindFriend: usize = 0x6668; // bool
    pub const m_pathLadderEnd: usize = 0x6694; // float
    pub const m_mustRunTimer: usize = 0x66E0; // CountdownTimer
    pub const m_waitTimer: usize = 0x66F8; // CountdownTimer
    pub const m_updateTravelDistanceTimer: usize = 0x6710; // CountdownTimer
    pub const m_playerTravelDistance: usize = 0x6728; // float[64]
    pub const m_travelDistancePhase: usize = 0x6828; // uint8_t
    pub const m_hostageEscortCount: usize = 0x69C0; // uint8_t
    pub const m_hostageEscortCountTimestamp: usize = 0x69C4; // float
    pub const m_desiredTeam: usize = 0x69C8; // int32_t
    pub const m_hasJoined: usize = 0x69CC; // bool
    pub const m_isWaitingForHostage: usize = 0x69CD; // bool
    pub const m_inhibitWaitingForHostageTimer: usize = 0x69D0; // CountdownTimer
    pub const m_waitForHostageTimer: usize = 0x69E8; // CountdownTimer
    pub const m_noisePosition: usize = 0x6A00; // Vector
    pub const m_noiseTravelDistance: usize = 0x6A0C; // float
    pub const m_noiseTimestamp: usize = 0x6A10; // float
    pub const m_noiseSource: usize = 0x6A18; // CCSPlayerPawn*
    pub const m_noiseBendTimer: usize = 0x6A30; // CountdownTimer
    pub const m_bentNoisePosition: usize = 0x6A48; // Vector
    pub const m_bendNoisePositionValid: usize = 0x6A54; // bool
    pub const m_lookAroundStateTimestamp: usize = 0x6A58; // float
    pub const m_lookAheadAngle: usize = 0x6A5C; // float
    pub const m_forwardAngle: usize = 0x6A60; // float
    pub const m_inhibitLookAroundTimestamp: usize = 0x6A64; // float
    pub const m_lookAtSpot: usize = 0x6A6C; // Vector
    pub const m_lookAtSpotDuration: usize = 0x6A7C; // float
    pub const m_lookAtSpotTimestamp: usize = 0x6A80; // float
    pub const m_lookAtSpotAngleTolerance: usize = 0x6A84; // float
    pub const m_lookAtSpotClearIfClose: usize = 0x6A88; // bool
    pub const m_lookAtSpotAttack: usize = 0x6A89; // bool
    pub const m_lookAtDesc: usize = 0x6A90; // char*
    pub const m_peripheralTimestamp: usize = 0x6A98; // float
    pub const m_approachPointCount: usize = 0x6C20; // uint8_t
    pub const m_approachPointViewPosition: usize = 0x6C24; // Vector
    pub const m_viewSteadyTimer: usize = 0x6C30; // IntervalTimer
    pub const m_tossGrenadeTimer: usize = 0x6C48; // CountdownTimer
    pub const m_isAvoidingGrenade: usize = 0x6C68; // CountdownTimer
    pub const m_spotCheckTimestamp: usize = 0x6C88; // float
    pub const m_checkedHidingSpotCount: usize = 0x7090; // int32_t
    pub const m_lookPitch: usize = 0x7094; // float
    pub const m_lookPitchVel: usize = 0x7098; // float
    pub const m_lookYaw: usize = 0x709C; // float
    pub const m_lookYawVel: usize = 0x70A0; // float
    pub const m_targetSpot: usize = 0x70A4; // Vector
    pub const m_targetSpotVelocity: usize = 0x70B0; // Vector
    pub const m_targetSpotPredicted: usize = 0x70BC; // Vector
    pub const m_aimError: usize = 0x70C8; // QAngle
    pub const m_aimGoal: usize = 0x70D4; // QAngle
    pub const m_targetSpotTime: usize = 0x70E0; // GameTime_t
    pub const m_aimFocus: usize = 0x70E4; // float
    pub const m_aimFocusInterval: usize = 0x70E8; // float
    pub const m_aimFocusNextUpdate: usize = 0x70EC; // GameTime_t
    pub const m_ignoreEnemiesTimer: usize = 0x70F8; // CountdownTimer
    pub const m_enemy: usize = 0x7110; // CHandle<CCSPlayerPawn>
    pub const m_isEnemyVisible: usize = 0x7114; // bool
    pub const m_visibleEnemyParts: usize = 0x7115; // uint8_t
    pub const m_lastEnemyPosition: usize = 0x7118; // Vector
    pub const m_lastSawEnemyTimestamp: usize = 0x7124; // float
    pub const m_firstSawEnemyTimestamp: usize = 0x7128; // float
    pub const m_currentEnemyAcquireTimestamp: usize = 0x712C; // float
    pub const m_enemyDeathTimestamp: usize = 0x7130; // float
    pub const m_friendDeathTimestamp: usize = 0x7134; // float
    pub const m_isLastEnemyDead: usize = 0x7138; // bool
    pub const m_nearbyEnemyCount: usize = 0x713C; // int32_t
    pub const m_bomber: usize = 0x7348; // CHandle<CCSPlayerPawn>
    pub const m_nearbyFriendCount: usize = 0x734C; // int32_t
    pub const m_closestVisibleFriend: usize = 0x7350; // CHandle<CCSPlayerPawn>
    pub const m_closestVisibleHumanFriend: usize = 0x7354; // CHandle<CCSPlayerPawn>
    pub const m_attentionInterval: usize = 0x7358; // IntervalTimer
    pub const m_attacker: usize = 0x7368; // CHandle<CCSPlayerPawn>
    pub const m_attackedTimestamp: usize = 0x736C; // float
    pub const m_burnedByFlamesTimer: usize = 0x7370; // IntervalTimer
    pub const m_lastVictimID: usize = 0x7380; // int32_t
    pub const m_isAimingAtEnemy: usize = 0x7384; // bool
    pub const m_isRapidFiring: usize = 0x7385; // bool
    pub const m_equipTimer: usize = 0x7388; // IntervalTimer
    pub const m_zoomTimer: usize = 0x7398; // CountdownTimer
    pub const m_fireWeaponTimestamp: usize = 0x73B0; // GameTime_t
    pub const m_lookForWeaponsOnGroundTimer: usize = 0x73B8; // CountdownTimer
    pub const m_bIsSleeping: usize = 0x73D0; // bool
    pub const m_isEnemySniperVisible: usize = 0x73D1; // bool
    pub const m_sawEnemySniperTimer: usize = 0x73D8; // CountdownTimer
    pub const m_enemyQueueIndex: usize = 0x7490; // uint8_t
    pub const m_enemyQueueCount: usize = 0x7491; // uint8_t
    pub const m_enemyQueueAttendIndex: usize = 0x7492; // uint8_t
    pub const m_isStuck: usize = 0x7493; // bool
    pub const m_stuckTimestamp: usize = 0x7494; // GameTime_t
    pub const m_stuckSpot: usize = 0x7498; // Vector
    pub const m_wiggleTimer: usize = 0x74A8; // CountdownTimer
    pub const m_stuckJumpTimer: usize = 0x74C0; // CountdownTimer
    pub const m_nextCleanupCheckTimestamp: usize = 0x74D8; // GameTime_t
    pub const m_avgVel: usize = 0x74DC; // float[10]
    pub const m_avgVelIndex: usize = 0x7504; // int32_t
    pub const m_avgVelCount: usize = 0x7508; // int32_t
    pub const m_lastOrigin: usize = 0x750C; // Vector
    pub const m_lastRadioRecievedTimestamp: usize = 0x751C; // float
    pub const m_lastRadioSentTimestamp: usize = 0x7520; // float
    pub const m_radioSubject: usize = 0x7524; // CHandle<CCSPlayerPawn>
    pub const m_radioPosition: usize = 0x7528; // Vector
    pub const m_voiceEndTimestamp: usize = 0x7534; // float
    pub const m_lastValidReactionQueueFrame: usize = 0x7540; // int32_t
}

pub mod CCSGOViewModel {
    pub const m_bShouldIgnoreOffsetAndAccuracy: usize = 0x8D8; // bool
    pub const m_nWeaponParity: usize = 0x8DC; // uint32_t
    pub const m_nOldWeaponParity: usize = 0x8E0; // uint32_t
}

pub mod CCSGO_TeamPreviewCharacterPosition {
    pub const m_nVariant: usize = 0x4B0; // int32_t
    pub const m_nRandom: usize = 0x4B4; // int32_t
    pub const m_nOrdinal: usize = 0x4B8; // int32_t
    pub const m_sWeaponName: usize = 0x4C0; // CUtlString
    pub const m_xuid: usize = 0x4C8; // uint64_t
    pub const m_agentItem: usize = 0x4D0; // CEconItemView
    pub const m_glovesItem: usize = 0x748; // CEconItemView
    pub const m_weaponItem: usize = 0x9C0; // CEconItemView
}

pub mod CCSGameModeRules {
    pub const __m_pChainEntity: usize = 0x8; // CNetworkVarChainer
}

pub mod CCSGameModeRules_Deathmatch {
    pub const m_bFirstThink: usize = 0x30; // bool
    pub const m_bFirstThinkAfterConnected: usize = 0x31; // bool
    pub const m_flDMBonusStartTime: usize = 0x34; // GameTime_t
    pub const m_flDMBonusTimeLength: usize = 0x38; // float
    pub const m_nDMBonusWeaponLoadoutSlot: usize = 0x3C; // int16_t
}

pub mod CCSGameRules {
    pub const __m_pChainEntity: usize = 0x98; // CNetworkVarChainer
    pub const m_coopMissionManager: usize = 0xC0; // CHandle<CBaseEntity>
    pub const m_bFreezePeriod: usize = 0xC4; // bool
    pub const m_bWarmupPeriod: usize = 0xC5; // bool
    pub const m_fWarmupPeriodEnd: usize = 0xC8; // GameTime_t
    pub const m_fWarmupPeriodStart: usize = 0xCC; // GameTime_t
    pub const m_nTotalPausedTicks: usize = 0xD0; // int32_t
    pub const m_nPauseStartTick: usize = 0xD4; // int32_t
    pub const m_bServerPaused: usize = 0xD8; // bool
    pub const m_bGamePaused: usize = 0xD9; // bool
    pub const m_bTerroristTimeOutActive: usize = 0xDA; // bool
    pub const m_bCTTimeOutActive: usize = 0xDB; // bool
    pub const m_flTerroristTimeOutRemaining: usize = 0xDC; // float
    pub const m_flCTTimeOutRemaining: usize = 0xE0; // float
    pub const m_nTerroristTimeOuts: usize = 0xE4; // int32_t
    pub const m_nCTTimeOuts: usize = 0xE8; // int32_t
    pub const m_bTechnicalTimeOut: usize = 0xEC; // bool
    pub const m_bMatchWaitingForResume: usize = 0xED; // bool
    pub const m_iRoundTime: usize = 0xF0; // int32_t
    pub const m_fMatchStartTime: usize = 0xF4; // float
    pub const m_fRoundStartTime: usize = 0xF8; // GameTime_t
    pub const m_flRestartRoundTime: usize = 0xFC; // GameTime_t
    pub const m_bGameRestart: usize = 0x100; // bool
    pub const m_flGameStartTime: usize = 0x104; // float
    pub const m_timeUntilNextPhaseStarts: usize = 0x108; // float
    pub const m_gamePhase: usize = 0x10C; // int32_t
    pub const m_totalRoundsPlayed: usize = 0x110; // int32_t
    pub const m_nRoundsPlayedThisPhase: usize = 0x114; // int32_t
    pub const m_nOvertimePlaying: usize = 0x118; // int32_t
    pub const m_iHostagesRemaining: usize = 0x11C; // int32_t
    pub const m_bAnyHostageReached: usize = 0x120; // bool
    pub const m_bMapHasBombTarget: usize = 0x121; // bool
    pub const m_bMapHasRescueZone: usize = 0x122; // bool
    pub const m_bMapHasBuyZone: usize = 0x123; // bool
    pub const m_bIsQueuedMatchmaking: usize = 0x124; // bool
    pub const m_nQueuedMatchmakingMode: usize = 0x128; // int32_t
    pub const m_bIsValveDS: usize = 0x12C; // bool
    pub const m_bLogoMap: usize = 0x12D; // bool
    pub const m_bPlayAllStepSoundsOnServer: usize = 0x12E; // bool
    pub const m_iSpectatorSlotCount: usize = 0x130; // int32_t
    pub const m_MatchDevice: usize = 0x134; // int32_t
    pub const m_bHasMatchStarted: usize = 0x138; // bool
    pub const m_nNextMapInMapgroup: usize = 0x13C; // int32_t
    pub const m_szTournamentEventName: usize = 0x140; // char[512]
    pub const m_szTournamentEventStage: usize = 0x340; // char[512]
    pub const m_szMatchStatTxt: usize = 0x540; // char[512]
    pub const m_szTournamentPredictionsTxt: usize = 0x740; // char[512]
    pub const m_nTournamentPredictionsPct: usize = 0x940; // int32_t
    pub const m_flCMMItemDropRevealStartTime: usize = 0x944; // GameTime_t
    pub const m_flCMMItemDropRevealEndTime: usize = 0x948; // GameTime_t
    pub const m_bIsDroppingItems: usize = 0x94C; // bool
    pub const m_bIsQuestEligible: usize = 0x94D; // bool
    pub const m_bIsHltvActive: usize = 0x94E; // bool
    pub const m_nGuardianModeWaveNumber: usize = 0x950; // int32_t
    pub const m_nGuardianModeSpecialKillsRemaining: usize = 0x954; // int32_t
    pub const m_nGuardianModeSpecialWeaponNeeded: usize = 0x958; // int32_t
    pub const m_nGuardianGrenadesToGiveBots: usize = 0x95C; // int32_t
    pub const m_nNumHeaviesToSpawn: usize = 0x960; // int32_t
    pub const m_numGlobalGiftsGiven: usize = 0x964; // uint32_t
    pub const m_numGlobalGifters: usize = 0x968; // uint32_t
    pub const m_numGlobalGiftsPeriodSeconds: usize = 0x96C; // uint32_t
    pub const m_arrFeaturedGiftersAccounts: usize = 0x970; // uint32_t[4]
    pub const m_arrFeaturedGiftersGifts: usize = 0x980; // uint32_t[4]
    pub const m_arrProhibitedItemIndices: usize = 0x990; // uint16_t[100]
    pub const m_arrTournamentActiveCasterAccounts: usize = 0xA58; // uint32_t[4]
    pub const m_numBestOfMaps: usize = 0xA68; // int32_t
    pub const m_nHalloweenMaskListSeed: usize = 0xA6C; // int32_t
    pub const m_bBombDropped: usize = 0xA70; // bool
    pub const m_bBombPlanted: usize = 0xA71; // bool
    pub const m_iRoundWinStatus: usize = 0xA74; // int32_t
    pub const m_eRoundWinReason: usize = 0xA78; // int32_t
    pub const m_bTCantBuy: usize = 0xA7C; // bool
    pub const m_bCTCantBuy: usize = 0xA7D; // bool
    pub const m_flGuardianBuyUntilTime: usize = 0xA80; // GameTime_t
    pub const m_iMatchStats_RoundResults: usize = 0xA84; // int32_t[30]
    pub const m_iMatchStats_PlayersAlive_CT: usize = 0xAFC; // int32_t[30]
    pub const m_iMatchStats_PlayersAlive_T: usize = 0xB74; // int32_t[30]
    pub const m_TeamRespawnWaveTimes: usize = 0xBEC; // float[32]
    pub const m_flNextRespawnWave: usize = 0xC6C; // GameTime_t[32]
    pub const m_nServerQuestID: usize = 0xCEC; // int32_t
    pub const m_vMinimapMins: usize = 0xCF0; // Vector
    pub const m_vMinimapMaxs: usize = 0xCFC; // Vector
    pub const m_MinimapVerticalSectionHeights: usize = 0xD08; // float[8]
    pub const m_bDontIncrementCoopWave: usize = 0xD28; // bool
    pub const m_bSpawnedTerrorHuntHeavy: usize = 0xD29; // bool
    pub const m_nEndMatchMapGroupVoteTypes: usize = 0xD2C; // int32_t[10]
    pub const m_nEndMatchMapGroupVoteOptions: usize = 0xD54; // int32_t[10]
    pub const m_nEndMatchMapVoteWinner: usize = 0xD7C; // int32_t
    pub const m_iNumConsecutiveCTLoses: usize = 0xD80; // int32_t
    pub const m_iNumConsecutiveTerroristLoses: usize = 0xD84; // int32_t
    pub const m_bHasHostageBeenTouched: usize = 0xDA0; // bool
    pub const m_flIntermissionStartTime: usize = 0xDA4; // GameTime_t
    pub const m_flIntermissionEndTime: usize = 0xDA8; // GameTime_t
    pub const m_bLevelInitialized: usize = 0xDAC; // bool
    pub const m_iTotalRoundsPlayed: usize = 0xDB0; // int32_t
    pub const m_iUnBalancedRounds: usize = 0xDB4; // int32_t
    pub const m_endMatchOnRoundReset: usize = 0xDB8; // bool
    pub const m_endMatchOnThink: usize = 0xDB9; // bool
    pub const m_iFreezeTime: usize = 0xDBC; // int32_t
    pub const m_iNumTerrorist: usize = 0xDC0; // int32_t
    pub const m_iNumCT: usize = 0xDC4; // int32_t
    pub const m_iNumSpawnableTerrorist: usize = 0xDC8; // int32_t
    pub const m_iNumSpawnableCT: usize = 0xDCC; // int32_t
    pub const m_arrSelectedHostageSpawnIndices: usize = 0xDD0; // CUtlVector<int32_t>
    pub const m_bFirstConnected: usize = 0xDE8; // bool
    pub const m_bCompleteReset: usize = 0xDE9; // bool
    pub const m_bPickNewTeamsOnReset: usize = 0xDEA; // bool
    pub const m_bScrambleTeamsOnRestart: usize = 0xDEB; // bool
    pub const m_bSwapTeamsOnRestart: usize = 0xDEC; // bool
    pub const m_nEndMatchTiedVotes: usize = 0xDF8; // CUtlVector<int32_t>
    pub const m_bNeedToAskPlayersForContinueVote: usize = 0xE14; // bool
    pub const m_numQueuedMatchmakingAccounts: usize = 0xE18; // uint32_t
    pub const m_pQueuedMatchmakingReservationString: usize = 0xE20; // char*
    pub const m_numTotalTournamentDrops: usize = 0xE28; // uint32_t
    pub const m_numSpectatorsCountMax: usize = 0xE2C; // uint32_t
    pub const m_numSpectatorsCountMaxTV: usize = 0xE30; // uint32_t
    pub const m_numSpectatorsCountMaxLnk: usize = 0xE34; // uint32_t
    pub const m_bForceTeamChangeSilent: usize = 0xE40; // bool
    pub const m_bLoadingRoundBackupData: usize = 0xE41; // bool
    pub const m_nMatchInfoShowType: usize = 0xE78; // int32_t
    pub const m_flMatchInfoDecidedTime: usize = 0xE7C; // float
    pub const m_flCoopRespawnAndHealTime: usize = 0xE98; // float
    pub const m_coopBonusCoinsFound: usize = 0xE9C; // int32_t
    pub const m_coopBonusPistolsOnly: usize = 0xEA0; // bool
    pub const m_coopPlayersInDeploymentZone: usize = 0xEA1; // bool
    pub const m_coopMissionDeadPlayerRespawnEnabled: usize = 0xEA2; // bool
    pub const mTeamDMLastWinningTeamNumber: usize = 0xEA4; // int32_t
    pub const mTeamDMLastThinkTime: usize = 0xEA8; // float
    pub const m_flTeamDMLastAnnouncementTime: usize = 0xEAC; // float
    pub const m_iAccountTerrorist: usize = 0xEB0; // int32_t
    pub const m_iAccountCT: usize = 0xEB4; // int32_t
    pub const m_iSpawnPointCount_Terrorist: usize = 0xEB8; // int32_t
    pub const m_iSpawnPointCount_CT: usize = 0xEBC; // int32_t
    pub const m_iMaxNumTerrorists: usize = 0xEC0; // int32_t
    pub const m_iMaxNumCTs: usize = 0xEC4; // int32_t
    pub const m_iLoserBonus: usize = 0xEC8; // int32_t
    pub const m_iLoserBonusMostRecentTeam: usize = 0xECC; // int32_t
    pub const m_tmNextPeriodicThink: usize = 0xED0; // float
    pub const m_bVoiceWonMatchBragFired: usize = 0xED4; // bool
    pub const m_fWarmupNextChatNoticeTime: usize = 0xED8; // float
    pub const m_iHostagesRescued: usize = 0xEE0; // int32_t
    pub const m_iHostagesTouched: usize = 0xEE4; // int32_t
    pub const m_flNextHostageAnnouncement: usize = 0xEE8; // float
    pub const m_bNoTerroristsKilled: usize = 0xEEC; // bool
    pub const m_bNoCTsKilled: usize = 0xEED; // bool
    pub const m_bNoEnemiesKilled: usize = 0xEEE; // bool
    pub const m_bCanDonateWeapons: usize = 0xEEF; // bool
    pub const m_firstKillTime: usize = 0xEF4; // float
    pub const m_firstBloodTime: usize = 0xEFC; // float
    pub const m_hostageWasInjured: usize = 0xF18; // bool
    pub const m_hostageWasKilled: usize = 0xF19; // bool
    pub const m_bVoteCalled: usize = 0xF28; // bool
    pub const m_bServerVoteOnReset: usize = 0xF29; // bool
    pub const m_flVoteCheckThrottle: usize = 0xF2C; // float
    pub const m_bBuyTimeEnded: usize = 0xF30; // bool
    pub const m_nLastFreezeEndBeep: usize = 0xF34; // int32_t
    pub const m_bTargetBombed: usize = 0xF38; // bool
    pub const m_bBombDefused: usize = 0xF39; // bool
    pub const m_bMapHasBombZone: usize = 0xF3A; // bool
    pub const m_vecMainCTSpawnPos: usize = 0xF58; // Vector
    pub const m_CTSpawnPointsMasterList: usize = 0xF68; // CUtlVector<SpawnPoint*>
    pub const m_TerroristSpawnPointsMasterList: usize = 0xF80; // CUtlVector<SpawnPoint*>
    pub const m_iNextCTSpawnPoint: usize = 0xF98; // int32_t
    pub const m_iNextTerroristSpawnPoint: usize = 0xF9C; // int32_t
    pub const m_CTSpawnPoints: usize = 0xFA0; // CUtlVector<SpawnPoint*>
    pub const m_TerroristSpawnPoints: usize = 0xFB8; // CUtlVector<SpawnPoint*>
    pub const m_bIsUnreservedGameServer: usize = 0xFD0; // bool
    pub const m_fAutobalanceDisplayTime: usize = 0xFD4; // float
    pub const m_bAllowWeaponSwitch: usize = 0x1240; // bool
    pub const m_bRoundTimeWarningTriggered: usize = 0x1241; // bool
    pub const m_phaseChangeAnnouncementTime: usize = 0x1244; // GameTime_t
    pub const m_fNextUpdateTeamClanNamesTime: usize = 0x1248; // float
    pub const m_flLastThinkTime: usize = 0x124C; // GameTime_t
    pub const m_fAccumulatedRoundOffDamage: usize = 0x1250; // float
    pub const m_nShorthandedBonusLastEvalRound: usize = 0x1254; // int32_t
    pub const m_nMatchAbortedEarlyReason: usize = 0x14D0; // int32_t
    pub const m_bHasTriggeredRoundStartMusic: usize = 0x14D4; // bool
    pub const m_bHasTriggeredCoopSpawnReset: usize = 0x14D5; // bool
    pub const m_bSwitchingTeamsAtRoundReset: usize = 0x14D6; // bool
    pub const m_pGameModeRules: usize = 0x14F0; // CCSGameModeRules*
    pub const m_BtGlobalBlackboard: usize = 0x14F8; // KeyValues3
    pub const m_hPlayerResource: usize = 0x1560; // CHandle<CBaseEntity>
    pub const m_RetakeRules: usize = 0x1568; // CRetakeGameRules
    pub const m_GuardianBotSkillLevelMax: usize = 0x174C; // int32_t
    pub const m_GuardianBotSkillLevelMin: usize = 0x1750; // int32_t
    pub const m_arrTeamUniqueKillWeaponsMatch: usize = 0x1758; // CUtlVector<int32_t>[4]
    pub const m_bTeamLastKillUsedUniqueWeaponMatch: usize = 0x17B8; // bool[4]
    pub const m_nMatchEndCount: usize = 0x17E0; // uint8_t
    pub const m_nTTeamIntroVariant: usize = 0x17E4; // int32_t
    pub const m_nCTTeamIntroVariant: usize = 0x17E8; // int32_t
    pub const m_bTeamIntroPeriod: usize = 0x17EC; // bool
    pub const m_fTeamIntroPeriodEnd: usize = 0x17F0; // GameTime_t
    pub const m_bPlayedTeamIntroVO: usize = 0x17F4; // bool
    pub const m_flLastPerfSampleTime: usize = 0x5800; // double
    pub const m_bSkipNextServerPerfSample: usize = 0x5808; // bool
}

pub mod CCSGameRulesProxy {
    pub const m_pGameRules: usize = 0x4B0; // CCSGameRules*
}

pub mod CCSPlace {
    pub const m_name: usize = 0x708; // CUtlSymbolLarge
}

pub mod CCSPlayerBase_CameraServices {
    pub const m_iFOV: usize = 0x170; // uint32_t
    pub const m_iFOVStart: usize = 0x174; // uint32_t
    pub const m_flFOVTime: usize = 0x178; // GameTime_t
    pub const m_flFOVRate: usize = 0x17C; // float
    pub const m_hZoomOwner: usize = 0x180; // CHandle<CBaseEntity>
    pub const m_hTriggerFogList: usize = 0x188; // CUtlVector<CHandle<CBaseEntity>>
    pub const m_hLastFogTrigger: usize = 0x1A0; // CHandle<CBaseEntity>
}

pub mod CCSPlayerController {
    pub const m_pInGameMoneyServices: usize = 0x6B8; // CCSPlayerController_InGameMoneyServices*
    pub const m_pInventoryServices: usize = 0x6C0; // CCSPlayerController_InventoryServices*
    pub const m_pActionTrackingServices: usize = 0x6C8; // CCSPlayerController_ActionTrackingServices*
    pub const m_pDamageServices: usize = 0x6D0; // CCSPlayerController_DamageServices*
    pub const m_iPing: usize = 0x6D8; // uint32_t
    pub const m_bHasCommunicationAbuseMute: usize = 0x6DC; // bool
    pub const m_szCrosshairCodes: usize = 0x6E0; // CUtlSymbolLarge
    pub const m_iPendingTeamNum: usize = 0x6E8; // uint8_t
    pub const m_flForceTeamTime: usize = 0x6EC; // GameTime_t
    pub const m_iCompTeammateColor: usize = 0x6F0; // int32_t
    pub const m_bEverPlayedOnTeam: usize = 0x6F4; // bool
    pub const m_bAttemptedToGetColor: usize = 0x6F5; // bool
    pub const m_iTeammatePreferredColor: usize = 0x6F8; // int32_t
    pub const m_bTeamChanged: usize = 0x6FC; // bool
    pub const m_bInSwitchTeam: usize = 0x6FD; // bool
    pub const m_bHasSeenJoinGame: usize = 0x6FE; // bool
    pub const m_bJustBecameSpectator: usize = 0x6FF; // bool
    pub const m_bSwitchTeamsOnNextRoundReset: usize = 0x700; // bool
    pub const m_bRemoveAllItemsOnNextRoundReset: usize = 0x701; // bool
    pub const m_szClan: usize = 0x708; // CUtlSymbolLarge
    pub const m_szClanName: usize = 0x710; // char[32]
    pub const m_iCoachingTeam: usize = 0x730; // int32_t
    pub const m_nPlayerDominated: usize = 0x738; // uint64_t
    pub const m_nPlayerDominatingMe: usize = 0x740; // uint64_t
    pub const m_iCompetitiveRanking: usize = 0x748; // int32_t
    pub const m_iCompetitiveWins: usize = 0x74C; // int32_t
    pub const m_iCompetitiveRankType: usize = 0x750; // int8_t
    pub const m_iCompetitiveRankingPredicted_Win: usize = 0x754; // int32_t
    pub const m_iCompetitiveRankingPredicted_Loss: usize = 0x758; // int32_t
    pub const m_iCompetitiveRankingPredicted_Tie: usize = 0x75C; // int32_t
    pub const m_nEndMatchNextMapVote: usize = 0x760; // int32_t
    pub const m_unActiveQuestId: usize = 0x764; // uint16_t
    pub const m_nQuestProgressReason: usize = 0x768; // QuestProgress::Reason
    pub const m_unPlayerTvControlFlags: usize = 0x76C; // uint32_t
    pub const m_iDraftIndex: usize = 0x798; // int32_t
    pub const m_msQueuedModeDisconnectionTimestamp: usize = 0x79C; // uint32_t
    pub const m_uiAbandonRecordedReason: usize = 0x7A0; // uint32_t
    pub const m_bCannotBeKicked: usize = 0x7A4; // bool
    pub const m_bEverFullyConnected: usize = 0x7A5; // bool
    pub const m_bAbandonAllowsSurrender: usize = 0x7A6; // bool
    pub const m_bAbandonOffersInstantSurrender: usize = 0x7A7; // bool
    pub const m_bDisconnection1MinWarningPrinted: usize = 0x7A8; // bool
    pub const m_bScoreReported: usize = 0x7A9; // bool
    pub const m_nDisconnectionTick: usize = 0x7AC; // int32_t
    pub const m_bControllingBot: usize = 0x7B8; // bool
    pub const m_bHasControlledBotThisRound: usize = 0x7B9; // bool
    pub const m_bHasBeenControlledByPlayerThisRound: usize = 0x7BA; // bool
    pub const m_nBotsControlledThisRound: usize = 0x7BC; // int32_t
    pub const m_bCanControlObservedBot: usize = 0x7C0; // bool
    pub const m_hPlayerPawn: usize = 0x7C4; // CHandle<CCSPlayerPawn>
    pub const m_hObserverPawn: usize = 0x7C8; // CHandle<CCSObserverPawn>
    pub const m_DesiredObserverMode: usize = 0x7CC; // int32_t
    pub const m_hDesiredObserverTarget: usize = 0x7D0; // CEntityHandle
    pub const m_bPawnIsAlive: usize = 0x7D4; // bool
    pub const m_iPawnHealth: usize = 0x7D8; // uint32_t
    pub const m_iPawnArmor: usize = 0x7DC; // int32_t
    pub const m_bPawnHasDefuser: usize = 0x7E0; // bool
    pub const m_bPawnHasHelmet: usize = 0x7E1; // bool
    pub const m_nPawnCharacterDefIndex: usize = 0x7E2; // uint16_t
    pub const m_iPawnLifetimeStart: usize = 0x7E4; // int32_t
    pub const m_iPawnLifetimeEnd: usize = 0x7E8; // int32_t
    pub const m_iPawnBotDifficulty: usize = 0x7EC; // int32_t
    pub const m_hOriginalControllerOfCurrentPawn: usize = 0x7F0; // CHandle<CCSPlayerController>
    pub const m_iScore: usize = 0x7F4; // int32_t
    pub const m_iRoundScore: usize = 0x7F8; // int32_t
    pub const m_iRoundsWon: usize = 0x7FC; // int32_t
    pub const m_vecKills: usize = 0x800; // CNetworkUtlVectorBase<EKillTypes_t>
    pub const m_iMVPs: usize = 0x818; // int32_t
    pub const m_nUpdateCounter: usize = 0x81C; // int32_t
    pub const m_flSmoothedPing: usize = 0x820; // float
    pub const m_lastHeldVoteTimer: usize = 0xF8C8; // IntervalTimer
    pub const m_bShowHints: usize = 0xF8E0; // bool
    pub const m_iNextTimeCheck: usize = 0xF8E4; // int32_t
    pub const m_bJustDidTeamKill: usize = 0xF8E8; // bool
    pub const m_bPunishForTeamKill: usize = 0xF8E9; // bool
    pub const m_bGaveTeamDamageWarning: usize = 0xF8EA; // bool
    pub const m_bGaveTeamDamageWarningThisRound: usize = 0xF8EB; // bool
    pub const m_dblLastReceivedPacketPlatFloatTime: usize = 0xF8F0; // double
    pub const m_LastTeamDamageWarningTime: usize = 0xF8F8; // GameTime_t
    pub const m_LastTimePlayerWasDisconnectedForPawnsRemove: usize = 0xF8FC; // GameTime_t
}

pub mod CCSPlayerController_ActionTrackingServices {
    pub const m_perRoundStats: usize = 0x40; // CUtlVectorEmbeddedNetworkVar<CSPerRoundStats_t>
    pub const m_matchStats: usize = 0x90; // CSMatchStats_t
    pub const m_iNumRoundKills: usize = 0x148; // int32_t
    pub const m_iNumRoundKillsHeadshots: usize = 0x14C; // int32_t
    pub const m_unTotalRoundDamageDealt: usize = 0x150; // uint32_t
}

pub mod CCSPlayerController_DamageServices {
    pub const m_nSendUpdate: usize = 0x40; // int32_t
    pub const m_DamageList: usize = 0x48; // CUtlVectorEmbeddedNetworkVar<CDamageRecord>
}

pub mod CCSPlayerController_InGameMoneyServices {
    pub const m_bReceivesMoneyNextRound: usize = 0x40; // bool
    pub const m_iAccountMoneyEarnedForNextRound: usize = 0x44; // int32_t
    pub const m_iAccount: usize = 0x48; // int32_t
    pub const m_iStartAccount: usize = 0x4C; // int32_t
    pub const m_iTotalCashSpent: usize = 0x50; // int32_t
    pub const m_iCashSpentThisRound: usize = 0x54; // int32_t
}

pub mod CCSPlayerController_InventoryServices {
    pub const m_unMusicID: usize = 0x40; // uint16_t
    pub const m_rank: usize = 0x44; // MedalRank_t[6]
    pub const m_nPersonaDataPublicLevel: usize = 0x5C; // int32_t
    pub const m_nPersonaDataPublicCommendsLeader: usize = 0x60; // int32_t
    pub const m_nPersonaDataPublicCommendsTeacher: usize = 0x64; // int32_t
    pub const m_nPersonaDataPublicCommendsFriendly: usize = 0x68; // int32_t
    pub const m_unEquippedPlayerSprayIDs: usize = 0xF48; // uint32_t[1]
    pub const m_vecServerAuthoritativeWeaponSlots: usize = 0xF50; // CUtlVectorEmbeddedNetworkVar<ServerAuthoritativeWeaponSlot_t>
}

pub mod CCSPlayerPawn {
    pub const m_pBulletServices: usize = 0x1550; // CCSPlayer_BulletServices*
    pub const m_pHostageServices: usize = 0x1558; // CCSPlayer_HostageServices*
    pub const m_pBuyServices: usize = 0x1560; // CCSPlayer_BuyServices*
    pub const m_pActionTrackingServices: usize = 0x1568; // CCSPlayer_ActionTrackingServices*
    pub const m_pRadioServices: usize = 0x1570; // CCSPlayer_RadioServices*
    pub const m_pDamageReactServices: usize = 0x1578; // CCSPlayer_DamageReactServices*
    pub const m_nCharacterDefIndex: usize = 0x1580; // uint16_t
    pub const m_hPreviousModel: usize = 0x1588; // CStrongHandle<InfoForResourceTypeCModel>
    pub const m_bHasFemaleVoice: usize = 0x1590; // bool
    pub const m_strVOPrefix: usize = 0x1598; // CUtlString
    pub const m_szLastPlaceName: usize = 0x15A0; // char[18]
    pub const m_bInHostageResetZone: usize = 0x1660; // bool
    pub const m_bInBuyZone: usize = 0x1661; // bool
    pub const m_bWasInBuyZone: usize = 0x1662; // bool
    pub const m_bInHostageRescueZone: usize = 0x1663; // bool
    pub const m_bInBombZone: usize = 0x1664; // bool
    pub const m_bWasInHostageRescueZone: usize = 0x1665; // bool
    pub const m_iRetakesOffering: usize = 0x1668; // int32_t
    pub const m_iRetakesOfferingCard: usize = 0x166C; // int32_t
    pub const m_bRetakesHasDefuseKit: usize = 0x1670; // bool
    pub const m_bRetakesMVPLastRound: usize = 0x1671; // bool
    pub const m_iRetakesMVPBoostItem: usize = 0x1674; // int32_t
    pub const m_RetakesMVPBoostExtraUtility: usize = 0x1678; // loadout_slot_t
    pub const m_flHealthShotBoostExpirationTime: usize = 0x167C; // GameTime_t
    pub const m_flLandseconds: usize = 0x1680; // float
    pub const m_aimPunchAngle: usize = 0x1684; // QAngle
    pub const m_aimPunchAngleVel: usize = 0x1690; // QAngle
    pub const m_aimPunchTickBase: usize = 0x169C; // int32_t
    pub const m_aimPunchTickFraction: usize = 0x16A0; // float
    pub const m_aimPunchCache: usize = 0x16A8; // CUtlVector<QAngle>
    pub const m_bIsBuyMenuOpen: usize = 0x16C0; // bool
    pub const m_xLastHeadBoneTransform: usize = 0x1C40; // CTransform
    pub const m_bLastHeadBoneTransformIsValid: usize = 0x1C60; // bool
    pub const m_lastLandTime: usize = 0x1C64; // GameTime_t
    pub const m_bOnGroundLastTick: usize = 0x1C68; // bool
    pub const m_iPlayerLocked: usize = 0x1C6C; // int32_t
    pub const m_flTimeOfLastInjury: usize = 0x1C74; // GameTime_t
    pub const m_flNextSprayDecalTime: usize = 0x1C78; // GameTime_t
    pub const m_bNextSprayDecalTimeExpedited: usize = 0x1C7C; // bool
    pub const m_nRagdollDamageBone: usize = 0x1C80; // int32_t
    pub const m_vRagdollDamageForce: usize = 0x1C84; // Vector
    pub const m_vRagdollDamagePosition: usize = 0x1C90; // Vector
    pub const m_szRagdollDamageWeaponName: usize = 0x1C9C; // char[64]
    pub const m_bRagdollDamageHeadshot: usize = 0x1CDC; // bool
    pub const m_vRagdollServerOrigin: usize = 0x1CE0; // Vector
    pub const m_EconGloves: usize = 0x1CF0; // CEconItemView
    pub const m_qDeathEyeAngles: usize = 0x1F68; // QAngle
    pub const m_bSkipOneHeadConstraintUpdate: usize = 0x1F74; // bool
}

pub mod CCSPlayerPawnBase {
    pub const m_CTouchExpansionComponent: usize = 0xB68; // CTouchExpansionComponent
    pub const m_pPingServices: usize = 0xBB8; // CCSPlayer_PingServices*
    pub const m_pViewModelServices: usize = 0xBC0; // CPlayer_ViewModelServices*
    pub const m_iDisplayHistoryBits: usize = 0xBC8; // uint32_t
    pub const m_flLastAttackedTeammate: usize = 0xBCC; // float
    pub const m_hOriginalController: usize = 0xBD0; // CHandle<CCSPlayerController>
    pub const m_blindUntilTime: usize = 0xBD4; // GameTime_t
    pub const m_blindStartTime: usize = 0xBD8; // GameTime_t
    pub const m_allowAutoFollowTime: usize = 0xBDC; // GameTime_t
    pub const m_entitySpottedState: usize = 0xBE0; // EntitySpottedState_t
    pub const m_nSpotRules: usize = 0xBF8; // int32_t
    pub const m_iPlayerState: usize = 0xBFC; // CSPlayerState
    pub const m_chickenIdleSoundTimer: usize = 0xC08; // CountdownTimer
    pub const m_chickenJumpSoundTimer: usize = 0xC20; // CountdownTimer
    pub const m_vecLastBookmarkedPosition: usize = 0xCD8; // Vector
    pub const m_flLastDistanceTraveledNotice: usize = 0xCE4; // float
    pub const m_flAccumulatedDistanceTraveled: usize = 0xCE8; // float
    pub const m_flLastFriendlyFireDamageReductionRatio: usize = 0xCEC; // float
    pub const m_bRespawning: usize = 0xCF0; // bool
    pub const m_nLastPickupPriority: usize = 0xCF4; // int32_t
    pub const m_flLastPickupPriorityTime: usize = 0xCF8; // float
    pub const m_bIsScoped: usize = 0xCFC; // bool
    pub const m_bIsWalking: usize = 0xCFD; // bool
    pub const m_bResumeZoom: usize = 0xCFE; // bool
    pub const m_bIsDefusing: usize = 0xCFF; // bool
    pub const m_bIsGrabbingHostage: usize = 0xD00; // bool
    pub const m_iBlockingUseActionInProgress: usize = 0xD04; // CSPlayerBlockingUseAction_t
    pub const m_fImmuneToGunGameDamageTime: usize = 0xD08; // GameTime_t
    pub const m_bGunGameImmunity: usize = 0xD0C; // bool
    pub const m_fMolotovDamageTime: usize = 0xD10; // float
    pub const m_bHasMovedSinceSpawn: usize = 0xD14; // bool
    pub const m_bCanMoveDuringFreezePeriod: usize = 0xD15; // bool
    pub const m_flGuardianTooFarDistFrac: usize = 0xD18; // float
    pub const m_flNextGuardianTooFarHurtTime: usize = 0xD1C; // float
    pub const m_flDetectedByEnemySensorTime: usize = 0xD20; // GameTime_t
    pub const m_flDealtDamageToEnemyMostRecentTimestamp: usize = 0xD24; // float
    pub const m_flLastEquippedHelmetTime: usize = 0xD28; // GameTime_t
    pub const m_flLastEquippedArmorTime: usize = 0xD2C; // GameTime_t
    pub const m_nHeavyAssaultSuitCooldownRemaining: usize = 0xD30; // int32_t
    pub const m_bResetArmorNextSpawn: usize = 0xD34; // bool
    pub const m_flLastBumpMineBumpTime: usize = 0xD38; // GameTime_t
    pub const m_flEmitSoundTime: usize = 0xD3C; // GameTime_t
    pub const m_iNumSpawns: usize = 0xD40; // int32_t
    pub const m_iShouldHaveCash: usize = 0xD44; // int32_t
    pub const m_bInvalidSteamLogonDelayed: usize = 0xD48; // bool
    pub const m_flLastAction: usize = 0xD4C; // GameTime_t
    pub const m_flNameChangeHistory: usize = 0xD50; // float[5]
    pub const m_fLastGivenDefuserTime: usize = 0xD64; // float
    pub const m_fLastGivenBombTime: usize = 0xD68; // float
    pub const m_bHasNightVision: usize = 0xD6C; // bool
    pub const m_bNightVisionOn: usize = 0xD6D; // bool
    pub const m_fNextRadarUpdateTime: usize = 0xD70; // float
    pub const m_flLastMoneyUpdateTime: usize = 0xD74; // float
    pub const m_MenuStringBuffer: usize = 0xD78; // char[1024]
    pub const m_fIntroCamTime: usize = 0x1178; // float
    pub const m_nMyCollisionGroup: usize = 0x117C; // int32_t
    pub const m_bInNoDefuseArea: usize = 0x1180; // bool
    pub const m_bKilledByTaser: usize = 0x1181; // bool
    pub const m_iMoveState: usize = 0x1184; // int32_t
    pub const m_grenadeParameterStashTime: usize = 0x1188; // GameTime_t
    pub const m_bGrenadeParametersStashed: usize = 0x118C; // bool
    pub const m_angStashedShootAngles: usize = 0x1190; // QAngle
    pub const m_vecStashedGrenadeThrowPosition: usize = 0x119C; // Vector
    pub const m_vecStashedVelocity: usize = 0x11A8; // Vector
    pub const m_angShootAngleHistory: usize = 0x11B4; // QAngle[2]
    pub const m_vecThrowPositionHistory: usize = 0x11CC; // Vector[2]
    pub const m_vecVelocityHistory: usize = 0x11E4; // Vector[2]
    pub const m_bDiedAirborne: usize = 0x11FC; // bool
    pub const m_iBombSiteIndex: usize = 0x1200; // CEntityIndex
    pub const m_nWhichBombZone: usize = 0x1204; // int32_t
    pub const m_bInBombZoneTrigger: usize = 0x1208; // bool
    pub const m_bWasInBombZoneTrigger: usize = 0x1209; // bool
    pub const m_iDirection: usize = 0x120C; // int32_t
    pub const m_iShotsFired: usize = 0x1210; // int32_t
    pub const m_ArmorValue: usize = 0x1214; // int32_t
    pub const m_flFlinchStack: usize = 0x1218; // float
    pub const m_flVelocityModifier: usize = 0x121C; // float
    pub const m_flHitHeading: usize = 0x1220; // float
    pub const m_nHitBodyPart: usize = 0x1224; // int32_t
    pub const m_iHostagesKilled: usize = 0x1228; // int32_t
    pub const m_vecTotalBulletForce: usize = 0x122C; // Vector
    pub const m_flFlashDuration: usize = 0x1238; // float
    pub const m_flFlashMaxAlpha: usize = 0x123C; // float
    pub const m_flProgressBarStartTime: usize = 0x1240; // float
    pub const m_iProgressBarDuration: usize = 0x1244; // int32_t
    pub const m_bWaitForNoAttack: usize = 0x1248; // bool
    pub const m_flLowerBodyYawTarget: usize = 0x124C; // float
    pub const m_bStrafing: usize = 0x1250; // bool
    pub const m_lastStandingPos: usize = 0x1254; // Vector
    pub const m_ignoreLadderJumpTime: usize = 0x1260; // float
    pub const m_ladderSurpressionTimer: usize = 0x1268; // CountdownTimer
    pub const m_lastLadderNormal: usize = 0x1280; // Vector
    pub const m_lastLadderPos: usize = 0x128C; // Vector
    pub const m_thirdPersonHeading: usize = 0x1298; // QAngle
    pub const m_flSlopeDropOffset: usize = 0x12A4; // float
    pub const m_flSlopeDropHeight: usize = 0x12A8; // float
    pub const m_vHeadConstraintOffset: usize = 0x12AC; // Vector
    pub const m_iLastWeaponFireUsercmd: usize = 0x12C0; // int32_t
    pub const m_angEyeAngles: usize = 0x12C4; // QAngle
    pub const m_bVCollisionInitted: usize = 0x12D0; // bool
    pub const m_storedSpawnPosition: usize = 0x12D4; // Vector
    pub const m_storedSpawnAngle: usize = 0x12E0; // QAngle
    pub const m_bIsSpawning: usize = 0x12EC; // bool
    pub const m_bHideTargetID: usize = 0x12ED; // bool
    pub const m_nNumDangerZoneDamageHits: usize = 0x12F0; // int32_t
    pub const m_bHud_MiniScoreHidden: usize = 0x12F4; // bool
    pub const m_bHud_RadarHidden: usize = 0x12F5; // bool
    pub const m_nLastKillerIndex: usize = 0x12F8; // CEntityIndex
    pub const m_nLastConcurrentKilled: usize = 0x12FC; // int32_t
    pub const m_nDeathCamMusic: usize = 0x1300; // int32_t
    pub const m_iAddonBits: usize = 0x1304; // int32_t
    pub const m_iPrimaryAddon: usize = 0x1308; // int32_t
    pub const m_iSecondaryAddon: usize = 0x130C; // int32_t
    pub const m_currentDeafnessFilter: usize = 0x1310; // CUtlStringToken
    pub const m_NumEnemiesKilledThisSpawn: usize = 0x1314; // int32_t
    pub const m_NumEnemiesKilledThisRound: usize = 0x1318; // int32_t
    pub const m_NumEnemiesAtRoundStart: usize = 0x131C; // int32_t
    pub const m_wasNotKilledNaturally: usize = 0x1320; // bool
    pub const m_vecPlayerPatchEconIndices: usize = 0x1324; // uint32_t[5]
    pub const m_iDeathFlags: usize = 0x1338; // int32_t
    pub const m_hPet: usize = 0x133C; // CHandle<CChicken>
    pub const m_unCurrentEquipmentValue: usize = 0x1508; // uint16_t
    pub const m_unRoundStartEquipmentValue: usize = 0x150A; // uint16_t
    pub const m_unFreezetimeEndEquipmentValue: usize = 0x150C; // uint16_t
    pub const m_nSurvivalTeamNumber: usize = 0x1510; // int32_t
    pub const m_bHasDeathInfo: usize = 0x1514; // bool
    pub const m_flDeathInfoTime: usize = 0x1518; // float
    pub const m_vecDeathInfoOrigin: usize = 0x151C; // Vector
    pub const m_bKilledByHeadshot: usize = 0x1528; // bool
    pub const m_LastHitBox: usize = 0x152C; // int32_t
    pub const m_LastHealth: usize = 0x1530; // int32_t
    pub const m_flLastCollisionCeiling: usize = 0x1534; // float
    pub const m_flLastCollisionCeilingChangeTime: usize = 0x1538; // float
    pub const m_pBot: usize = 0x1540; // CCSBot*
    pub const m_bBotAllowActive: usize = 0x1548; // bool
    pub const m_bCommittingSuicideOnTeamChange: usize = 0x1549; // bool
}

pub mod CCSPlayerResource {
    pub const m_bHostageAlive: usize = 0x4B0; // bool[12]
    pub const m_isHostageFollowingSomeone: usize = 0x4BC; // bool[12]
    pub const m_iHostageEntityIDs: usize = 0x4C8; // CEntityIndex[12]
    pub const m_bombsiteCenterA: usize = 0x4F8; // Vector
    pub const m_bombsiteCenterB: usize = 0x504; // Vector
    pub const m_hostageRescueX: usize = 0x510; // int32_t[4]
    pub const m_hostageRescueY: usize = 0x520; // int32_t[4]
    pub const m_hostageRescueZ: usize = 0x530; // int32_t[4]
    pub const m_bEndMatchNextMapAllVoted: usize = 0x540; // bool
    pub const m_foundGoalPositions: usize = 0x541; // bool
}

pub mod CCSPlayer_ActionTrackingServices {
    pub const m_hLastWeaponBeforeC4AutoSwitch: usize = 0x208; // CHandle<CBasePlayerWeapon>
    pub const m_bIsRescuing: usize = 0x23C; // bool
    pub const m_weaponPurchasesThisMatch: usize = 0x240; // WeaponPurchaseTracker_t
    pub const m_weaponPurchasesThisRound: usize = 0x298; // WeaponPurchaseTracker_t
}

pub mod CCSPlayer_BulletServices {
    pub const m_totalHitsOnServer: usize = 0x40; // int32_t
}

pub mod CCSPlayer_BuyServices {
    pub const m_vecSellbackPurchaseEntries: usize = 0xC8; // CUtlVectorEmbeddedNetworkVar<SellbackPurchaseEntry_t>
}

pub mod CCSPlayer_HostageServices {
    pub const m_hCarriedHostage: usize = 0x40; // CHandle<CBaseEntity>
    pub const m_hCarriedHostageProp: usize = 0x44; // CHandle<CBaseEntity>
}

pub mod CCSPlayer_ItemServices {
    pub const m_bHasDefuser: usize = 0x40; // bool
    pub const m_bHasHelmet: usize = 0x41; // bool
    pub const m_bHasHeavyArmor: usize = 0x42; // bool
}

pub mod CCSPlayer_MovementServices {
    pub const m_flMaxFallVelocity: usize = 0x220; // float
    pub const m_vecLadderNormal: usize = 0x224; // Vector
    pub const m_nLadderSurfacePropIndex: usize = 0x230; // int32_t
    pub const m_flDuckAmount: usize = 0x234; // float
    pub const m_flDuckSpeed: usize = 0x238; // float
    pub const m_bDuckOverride: usize = 0x23C; // bool
    pub const m_bDesiresDuck: usize = 0x23D; // bool
    pub const m_flDuckOffset: usize = 0x240; // float
    pub const m_nDuckTimeMsecs: usize = 0x244; // uint32_t
    pub const m_nDuckJumpTimeMsecs: usize = 0x248; // uint32_t
    pub const m_nJumpTimeMsecs: usize = 0x24C; // uint32_t
    pub const m_flLastDuckTime: usize = 0x250; // float
    pub const m_vecLastPositionAtFullCrouchSpeed: usize = 0x260; // Vector2D
    pub const m_duckUntilOnGround: usize = 0x268; // bool
    pub const m_bHasWalkMovedSinceLastJump: usize = 0x269; // bool
    pub const m_bInStuckTest: usize = 0x26A; // bool
    pub const m_flStuckCheckTime: usize = 0x278; // float[64][2]
    pub const m_nTraceCount: usize = 0x478; // int32_t
    pub const m_StuckLast: usize = 0x47C; // int32_t
    pub const m_bSpeedCropped: usize = 0x480; // bool
    pub const m_nOldWaterLevel: usize = 0x484; // int32_t
    pub const m_flWaterEntryTime: usize = 0x488; // float
    pub const m_vecForward: usize = 0x48C; // Vector
    pub const m_vecLeft: usize = 0x498; // Vector
    pub const m_vecUp: usize = 0x4A4; // Vector
    pub const m_vecPreviouslyPredictedOrigin: usize = 0x4B0; // Vector
    pub const m_bMadeFootstepNoise: usize = 0x4BC; // bool
    pub const m_iFootsteps: usize = 0x4C0; // int32_t
    pub const m_bOldJumpPressed: usize = 0x4C4; // bool
    pub const m_flJumpPressedTime: usize = 0x4C8; // float
    pub const m_flJumpUntil: usize = 0x4CC; // float
    pub const m_flJumpVel: usize = 0x4D0; // float
    pub const m_fStashGrenadeParameterWhen: usize = 0x4D4; // GameTime_t
    pub const m_nButtonDownMaskPrev: usize = 0x4D8; // uint64_t
    pub const m_flOffsetTickCompleteTime: usize = 0x4E0; // float
    pub const m_flOffsetTickStashedSpeed: usize = 0x4E4; // float
    pub const m_flStamina: usize = 0x4E8; // float
    pub const m_flHeightAtJumpStart: usize = 0x4EC; // float
    pub const m_flMaxJumpHeightThisJump: usize = 0x4F0; // float
}

pub mod CCSPlayer_PingServices {
    pub const m_flPlayerPingTokens: usize = 0x40; // GameTime_t[5]
    pub const m_hPlayerPing: usize = 0x54; // CHandle<CBaseEntity>
}

pub mod CCSPlayer_RadioServices {
    pub const m_flGotHostageTalkTimer: usize = 0x40; // GameTime_t
    pub const m_flDefusingTalkTimer: usize = 0x44; // GameTime_t
    pub const m_flC4PlantTalkTimer: usize = 0x48; // GameTime_t
    pub const m_flRadioTokenSlots: usize = 0x4C; // GameTime_t[3]
    pub const m_bIgnoreRadio: usize = 0x58; // bool
}

pub mod CCSPlayer_UseServices {
    pub const m_hLastKnownUseEntity: usize = 0x40; // CHandle<CBaseEntity>
    pub const m_flLastUseTimeStamp: usize = 0x44; // GameTime_t
    pub const m_flTimeStartedHoldingUse: usize = 0x48; // GameTime_t
    pub const m_flTimeLastUsedWindow: usize = 0x4C; // GameTime_t
}

pub mod CCSPlayer_ViewModelServices {
    pub const m_hViewModel: usize = 0x40; // CHandle<CBaseViewModel>[3]
}

pub mod CCSPlayer_WaterServices {
    pub const m_NextDrownDamageTime: usize = 0x40; // float
    pub const m_nDrownDmgRate: usize = 0x44; // int32_t
    pub const m_AirFinishedTime: usize = 0x48; // GameTime_t
    pub const m_flWaterJumpTime: usize = 0x4C; // float
    pub const m_vecWaterJumpVel: usize = 0x50; // Vector
    pub const m_flSwimSoundTime: usize = 0x5C; // float
}

pub mod CCSPlayer_WeaponServices {
    pub const m_flNextAttack: usize = 0xB0; // GameTime_t
    pub const m_bIsLookingAtWeapon: usize = 0xB4; // bool
    pub const m_bIsHoldingLookAtWeapon: usize = 0xB5; // bool
    pub const m_hSavedWeapon: usize = 0xB8; // CHandle<CBasePlayerWeapon>
    pub const m_nTimeToMelee: usize = 0xBC; // int32_t
    pub const m_nTimeToSecondary: usize = 0xC0; // int32_t
    pub const m_nTimeToPrimary: usize = 0xC4; // int32_t
    pub const m_nTimeToSniperRifle: usize = 0xC8; // int32_t
    pub const m_bIsBeingGivenItem: usize = 0xCC; // bool
    pub const m_bIsPickingUpItemWithUse: usize = 0xCD; // bool
    pub const m_bPickedUpWeapon: usize = 0xCE; // bool
}

pub mod CCSTeam {
    pub const m_nLastRecievedShorthandedRoundBonus: usize = 0x568; // int32_t
    pub const m_nShorthandedRoundBonusStartRound: usize = 0x56C; // int32_t
    pub const m_bSurrendered: usize = 0x570; // bool
    pub const m_szTeamMatchStat: usize = 0x571; // char[512]
    pub const m_numMapVictories: usize = 0x774; // int32_t
    pub const m_scoreFirstHalf: usize = 0x778; // int32_t
    pub const m_scoreSecondHalf: usize = 0x77C; // int32_t
    pub const m_scoreOvertime: usize = 0x780; // int32_t
    pub const m_szClanTeamname: usize = 0x784; // char[129]
    pub const m_iClanID: usize = 0x808; // uint32_t
    pub const m_szTeamFlagImage: usize = 0x80C; // char[8]
    pub const m_szTeamLogoImage: usize = 0x814; // char[8]
    pub const m_flNextResourceTime: usize = 0x81C; // float
    pub const m_iLastUpdateSentAt: usize = 0x820; // int32_t
}

pub mod CCSWeaponBase {
    pub const m_bRemoveable: usize = 0xC88; // bool
    pub const m_flFireSequenceStartTime: usize = 0xC90; // float
    pub const m_nFireSequenceStartTimeChange: usize = 0xC94; // int32_t
    pub const m_nFireSequenceStartTimeAck: usize = 0xC98; // int32_t
    pub const m_bPlayerFireEventIsPrimary: usize = 0xC9C; // bool
    pub const m_seqIdle: usize = 0xCA0; // HSequence
    pub const m_seqFirePrimary: usize = 0xCA4; // HSequence
    pub const m_seqFireSecondary: usize = 0xCA8; // HSequence
    pub const m_thirdPersonFireSequences: usize = 0xCB0; // CUtlVector<HSequence>
    pub const m_hCurrentThirdPersonSequence: usize = 0xCC8; // HSequence
    pub const m_nSilencerBoneIndex: usize = 0xCCC; // int32_t
    pub const m_thirdPersonSequences: usize = 0xCD0; // HSequence[6]
    pub const m_bPlayerAmmoStockOnPickup: usize = 0xCF0; // bool
    pub const m_bRequireUseToTouch: usize = 0xCF1; // bool
    pub const m_iState: usize = 0xCF4; // CSWeaponState_t
    pub const m_flLastTimeInAir: usize = 0xCF8; // GameTime_t
    pub const m_flLastDeployTime: usize = 0xCFC; // GameTime_t
    pub const m_nViewModelIndex: usize = 0xD00; // uint32_t
    pub const m_bReloadsWithClips: usize = 0xD04; // bool
    pub const m_flTimeWeaponIdle: usize = 0xD20; // GameTime_t
    pub const m_bFireOnEmpty: usize = 0xD24; // bool
    pub const m_OnPlayerPickup: usize = 0xD28; // CEntityIOOutput
    pub const m_weaponMode: usize = 0xD50; // CSWeaponMode
    pub const m_flTurningInaccuracyDelta: usize = 0xD54; // float
    pub const m_vecTurningInaccuracyEyeDirLast: usize = 0xD58; // Vector
    pub const m_flTurningInaccuracy: usize = 0xD64; // float
    pub const m_fAccuracyPenalty: usize = 0xD68; // float
    pub const m_flLastAccuracyUpdateTime: usize = 0xD6C; // GameTime_t
    pub const m_fAccuracySmoothedForZoom: usize = 0xD70; // float
    pub const m_fScopeZoomEndTime: usize = 0xD74; // GameTime_t
    pub const m_iRecoilIndex: usize = 0xD78; // int32_t
    pub const m_flRecoilIndex: usize = 0xD7C; // float
    pub const m_bBurstMode: usize = 0xD80; // bool
    pub const m_flPostponeFireReadyTime: usize = 0xD84; // GameTime_t
    pub const m_bInReload: usize = 0xD88; // bool
    pub const m_bReloadVisuallyComplete: usize = 0xD89; // bool
    pub const m_flDroppedAtTime: usize = 0xD8C; // GameTime_t
    pub const m_bIsHauledBack: usize = 0xD90; // bool
    pub const m_bSilencerOn: usize = 0xD91; // bool
    pub const m_flTimeSilencerSwitchComplete: usize = 0xD94; // GameTime_t
    pub const m_iOriginalTeamNumber: usize = 0xD98; // int32_t
    pub const m_flNextAttackRenderTimeOffset: usize = 0xD9C; // float
    pub const m_bCanBePickedUp: usize = 0xDB0; // bool
    pub const m_bUseCanOverrideNextOwnerTouchTime: usize = 0xDB1; // bool
    pub const m_nextOwnerTouchTime: usize = 0xDB4; // GameTime_t
    pub const m_nextPrevOwnerTouchTime: usize = 0xDB8; // GameTime_t
    pub const m_hPrevOwner: usize = 0xDBC; // CHandle<CCSPlayerPawn>
    pub const m_nDropTick: usize = 0xDC0; // GameTick_t
    pub const m_donated: usize = 0xDE4; // bool
    pub const m_fLastShotTime: usize = 0xDE8; // GameTime_t
    pub const m_bWasOwnedByCT: usize = 0xDEC; // bool
    pub const m_bWasOwnedByTerrorist: usize = 0xDED; // bool
    pub const m_bFiredOutOfAmmoEvent: usize = 0xDEE; // bool
    pub const m_numRemoveUnownedWeaponThink: usize = 0xDF0; // int32_t
    pub const m_IronSightController: usize = 0xDF8; // CIronSightController
    pub const m_iIronSightMode: usize = 0xE10; // int32_t
    pub const m_flLastLOSTraceFailureTime: usize = 0xE14; // GameTime_t
    pub const m_iNumEmptyAttacks: usize = 0xE18; // int32_t
}

pub mod CCSWeaponBaseGun {
    pub const m_zoomLevel: usize = 0xE20; // int32_t
    pub const m_iBurstShotsRemaining: usize = 0xE24; // int32_t
    pub const m_silencedModelIndex: usize = 0xE30; // int32_t
    pub const m_inPrecache: usize = 0xE34; // bool
    pub const m_bNeedsBoltAction: usize = 0xE35; // bool
    pub const m_bSkillReloadAvailable: usize = 0xE36; // bool
    pub const m_bSkillReloadLiftedReloadKey: usize = 0xE37; // bool
    pub const m_bSkillBoltInterruptAvailable: usize = 0xE38; // bool
    pub const m_bSkillBoltLiftedFireKey: usize = 0xE39; // bool
}

pub mod CCSWeaponBaseVData {
    pub const m_WeaponType: usize = 0x240; // CSWeaponType
    pub const m_WeaponCategory: usize = 0x244; // CSWeaponCategory
    pub const m_szViewModel: usize = 0x248; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    pub const m_szPlayerModel: usize = 0x328; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    pub const m_szWorldDroppedModel: usize = 0x408; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    pub const m_szAimsightLensMaskModel: usize = 0x4E8; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    pub const m_szMagazineModel: usize = 0x5C8; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    pub const m_szHeatEffect: usize = 0x6A8; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    pub const m_szEjectBrassEffect: usize = 0x788; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    pub const m_szMuzzleFlashParticleAlt: usize = 0x868; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    pub const m_szMuzzleFlashThirdPersonParticle: usize = 0x948; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    pub const m_szMuzzleFlashThirdPersonParticleAlt: usize = 0xA28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    pub const m_szTracerParticle: usize = 0xB08; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    pub const m_GearSlot: usize = 0xBE8; // gear_slot_t
    pub const m_GearSlotPosition: usize = 0xBEC; // int32_t
    pub const m_DefaultLoadoutSlot: usize = 0xBF0; // loadout_slot_t
    pub const m_sWrongTeamMsg: usize = 0xBF8; // CUtlString
    pub const m_nPrice: usize = 0xC00; // int32_t
    pub const m_nKillAward: usize = 0xC04; // int32_t
    pub const m_nPrimaryReserveAmmoMax: usize = 0xC08; // int32_t
    pub const m_nSecondaryReserveAmmoMax: usize = 0xC0C; // int32_t
    pub const m_bMeleeWeapon: usize = 0xC10; // bool
    pub const m_bHasBurstMode: usize = 0xC11; // bool
    pub const m_bIsRevolver: usize = 0xC12; // bool
    pub const m_bCannotShootUnderwater: usize = 0xC13; // bool
    pub const m_szName: usize = 0xC18; // CUtlString
    pub const m_szAnimExtension: usize = 0xC20; // CUtlString
    pub const m_eSilencerType: usize = 0xC28; // CSWeaponSilencerType
    pub const m_nCrosshairMinDistance: usize = 0xC2C; // int32_t
    pub const m_nCrosshairDeltaDistance: usize = 0xC30; // int32_t
    pub const m_flCycleTime: usize = 0xC34; // CFiringModeFloat
    pub const m_flMaxSpeed: usize = 0xC3C; // CFiringModeFloat
    pub const m_flSpread: usize = 0xC44; // CFiringModeFloat
    pub const m_flInaccuracyCrouch: usize = 0xC4C; // CFiringModeFloat
    pub const m_flInaccuracyStand: usize = 0xC54; // CFiringModeFloat
    pub const m_flInaccuracyJump: usize = 0xC5C; // CFiringModeFloat
    pub const m_flInaccuracyLand: usize = 0xC64; // CFiringModeFloat
    pub const m_flInaccuracyLadder: usize = 0xC6C; // CFiringModeFloat
    pub const m_flInaccuracyFire: usize = 0xC74; // CFiringModeFloat
    pub const m_flInaccuracyMove: usize = 0xC7C; // CFiringModeFloat
    pub const m_flRecoilAngle: usize = 0xC84; // CFiringModeFloat
    pub const m_flRecoilAngleVariance: usize = 0xC8C; // CFiringModeFloat
    pub const m_flRecoilMagnitude: usize = 0xC94; // CFiringModeFloat
    pub const m_flRecoilMagnitudeVariance: usize = 0xC9C; // CFiringModeFloat
    pub const m_nTracerFrequency: usize = 0xCA4; // CFiringModeInt
    pub const m_flInaccuracyJumpInitial: usize = 0xCAC; // float
    pub const m_flInaccuracyJumpApex: usize = 0xCB0; // float
    pub const m_flInaccuracyReload: usize = 0xCB4; // float
    pub const m_nRecoilSeed: usize = 0xCB8; // int32_t
    pub const m_nSpreadSeed: usize = 0xCBC; // int32_t
    pub const m_flTimeToIdleAfterFire: usize = 0xCC0; // float
    pub const m_flIdleInterval: usize = 0xCC4; // float
    pub const m_flAttackMovespeedFactor: usize = 0xCC8; // float
    pub const m_flHeatPerShot: usize = 0xCCC; // float
    pub const m_flInaccuracyPitchShift: usize = 0xCD0; // float
    pub const m_flInaccuracyAltSoundThreshold: usize = 0xCD4; // float
    pub const m_flBotAudibleRange: usize = 0xCD8; // float
    pub const m_szUseRadioSubtitle: usize = 0xCE0; // CUtlString
    pub const m_bUnzoomsAfterShot: usize = 0xCE8; // bool
    pub const m_bHideViewModelWhenZoomed: usize = 0xCE9; // bool
    pub const m_nZoomLevels: usize = 0xCEC; // int32_t
    pub const m_nZoomFOV1: usize = 0xCF0; // int32_t
    pub const m_nZoomFOV2: usize = 0xCF4; // int32_t
    pub const m_flZoomTime0: usize = 0xCF8; // float
    pub const m_flZoomTime1: usize = 0xCFC; // float
    pub const m_flZoomTime2: usize = 0xD00; // float
    pub const m_flIronSightPullUpSpeed: usize = 0xD04; // float
    pub const m_flIronSightPutDownSpeed: usize = 0xD08; // float
    pub const m_flIronSightFOV: usize = 0xD0C; // float
    pub const m_flIronSightPivotForward: usize = 0xD10; // float
    pub const m_flIronSightLooseness: usize = 0xD14; // float
    pub const m_angPivotAngle: usize = 0xD18; // QAngle
    pub const m_vecIronSightEyePos: usize = 0xD24; // Vector
    pub const m_nDamage: usize = 0xD30; // int32_t
    pub const m_flHeadshotMultiplier: usize = 0xD34; // float
    pub const m_flArmorRatio: usize = 0xD38; // float
    pub const m_flPenetration: usize = 0xD3C; // float
    pub const m_flRange: usize = 0xD40; // float
    pub const m_flRangeModifier: usize = 0xD44; // float
    pub const m_flFlinchVelocityModifierLarge: usize = 0xD48; // float
    pub const m_flFlinchVelocityModifierSmall: usize = 0xD4C; // float
    pub const m_flRecoveryTimeCrouch: usize = 0xD50; // float
    pub const m_flRecoveryTimeStand: usize = 0xD54; // float
    pub const m_flRecoveryTimeCrouchFinal: usize = 0xD58; // float
    pub const m_flRecoveryTimeStandFinal: usize = 0xD5C; // float
    pub const m_nRecoveryTransitionStartBullet: usize = 0xD60; // int32_t
    pub const m_nRecoveryTransitionEndBullet: usize = 0xD64; // int32_t
    pub const m_flThrowVelocity: usize = 0xD68; // float
    pub const m_vSmokeColor: usize = 0xD6C; // Vector
    pub const m_szAnimClass: usize = 0xD78; // CUtlString
}

pub mod CChangeLevel {
    pub const m_sMapName: usize = 0x8A8; // CUtlString
    pub const m_sLandmarkName: usize = 0x8B0; // CUtlString
    pub const m_OnChangeLevel: usize = 0x8B8; // CEntityIOOutput
    pub const m_bTouched: usize = 0x8E0; // bool
    pub const m_bNoTouch: usize = 0x8E1; // bool
    pub const m_bNewChapter: usize = 0x8E2; // bool
    pub const m_bOnChangeLevelFired: usize = 0x8E3; // bool
}

pub mod CChicken {
    pub const m_AttributeManager: usize = 0xB28; // CAttributeContainer
    pub const m_OriginalOwnerXuidLow: usize = 0xDF0; // uint32_t
    pub const m_OriginalOwnerXuidHigh: usize = 0xDF4; // uint32_t
    pub const m_updateTimer: usize = 0xDF8; // CountdownTimer
    pub const m_stuckAnchor: usize = 0xE10; // Vector
    pub const m_stuckTimer: usize = 0xE20; // CountdownTimer
    pub const m_collisionStuckTimer: usize = 0xE38; // CountdownTimer
    pub const m_isOnGround: usize = 0xE50; // bool
    pub const m_vFallVelocity: usize = 0xE54; // Vector
    pub const m_activity: usize = 0xE60; // ChickenActivity
    pub const m_activityTimer: usize = 0xE68; // CountdownTimer
    pub const m_turnRate: usize = 0xE80; // float
    pub const m_fleeFrom: usize = 0xE84; // CHandle<CBaseEntity>
    pub const m_moveRateThrottleTimer: usize = 0xE88; // CountdownTimer
    pub const m_startleTimer: usize = 0xEA0; // CountdownTimer
    pub const m_vocalizeTimer: usize = 0xEB8; // CountdownTimer
    pub const m_flWhenZombified: usize = 0xED0; // GameTime_t
    pub const m_jumpedThisFrame: usize = 0xED4; // bool
    pub const m_leader: usize = 0xED8; // CHandle<CCSPlayerPawn>
    pub const m_reuseTimer: usize = 0xEE0; // CountdownTimer
    pub const m_hasBeenUsed: usize = 0xEF8; // bool
    pub const m_jumpTimer: usize = 0xF00; // CountdownTimer
    pub const m_flLastJumpTime: usize = 0xF18; // float
    pub const m_bInJump: usize = 0xF1C; // bool
    pub const m_isWaitingForLeader: usize = 0xF1D; // bool
    pub const m_repathTimer: usize = 0x2F28; // CountdownTimer
    pub const m_inhibitDoorTimer: usize = 0x2F40; // CountdownTimer
    pub const m_inhibitObstacleAvoidanceTimer: usize = 0x2FD0; // CountdownTimer
    pub const m_vecPathGoal: usize = 0x2FF0; // Vector
    pub const m_flActiveFollowStartTime: usize = 0x2FFC; // GameTime_t
    pub const m_followMinuteTimer: usize = 0x3000; // CountdownTimer
    pub const m_vecLastEggPoopPosition: usize = 0x3018; // Vector
    pub const m_vecEggsPooped: usize = 0x3028; // CUtlVector<CHandle<CBaseEntity>>
    pub const m_BlockDirectionTimer: usize = 0x3048; // CountdownTimer
}

pub mod CCollisionProperty {
    pub const m_collisionAttribute: usize = 0x10; // VPhysicsCollisionAttribute_t
    pub const m_vecMins: usize = 0x40; // Vector
    pub const m_vecMaxs: usize = 0x4C; // Vector
    pub const m_usSolidFlags: usize = 0x5A; // uint8_t
    pub const m_nSolidType: usize = 0x5B; // SolidType_t
    pub const m_triggerBloat: usize = 0x5C; // uint8_t
    pub const m_nSurroundType: usize = 0x5D; // SurroundingBoundsType_t
    pub const m_CollisionGroup: usize = 0x5E; // uint8_t
    pub const m_nEnablePhysics: usize = 0x5F; // uint8_t
    pub const m_flBoundingRadius: usize = 0x60; // float
    pub const m_vecSpecifiedSurroundingMins: usize = 0x64; // Vector
    pub const m_vecSpecifiedSurroundingMaxs: usize = 0x70; // Vector
    pub const m_vecSurroundingMaxs: usize = 0x7C; // Vector
    pub const m_vecSurroundingMins: usize = 0x88; // Vector
    pub const m_vCapsuleCenter1: usize = 0x94; // Vector
    pub const m_vCapsuleCenter2: usize = 0xA0; // Vector
    pub const m_flCapsuleRadius: usize = 0xAC; // float
}

pub mod CColorCorrection {
    pub const m_flFadeInDuration: usize = 0x4B0; // float
    pub const m_flFadeOutDuration: usize = 0x4B4; // float
    pub const m_flStartFadeInWeight: usize = 0x4B8; // float
    pub const m_flStartFadeOutWeight: usize = 0x4BC; // float
    pub const m_flTimeStartFadeIn: usize = 0x4C0; // GameTime_t
    pub const m_flTimeStartFadeOut: usize = 0x4C4; // GameTime_t
    pub const m_flMaxWeight: usize = 0x4C8; // float
    pub const m_bStartDisabled: usize = 0x4CC; // bool
    pub const m_bEnabled: usize = 0x4CD; // bool
    pub const m_bMaster: usize = 0x4CE; // bool
    pub const m_bClientSide: usize = 0x4CF; // bool
    pub const m_bExclusive: usize = 0x4D0; // bool
    pub const m_MinFalloff: usize = 0x4D4; // float
    pub const m_MaxFalloff: usize = 0x4D8; // float
    pub const m_flCurWeight: usize = 0x4DC; // float
    pub const m_netlookupFilename: usize = 0x4E0; // char[512]
    pub const m_lookupFilename: usize = 0x6E0; // CUtlSymbolLarge
}

pub mod CColorCorrectionVolume {
    pub const m_bEnabled: usize = 0x8A8; // bool
    pub const m_MaxWeight: usize = 0x8AC; // float
    pub const m_FadeDuration: usize = 0x8B0; // float
    pub const m_bStartDisabled: usize = 0x8B4; // bool
    pub const m_Weight: usize = 0x8B8; // float
    pub const m_lookupFilename: usize = 0x8BC; // char[512]
    pub const m_LastEnterWeight: usize = 0xABC; // float
    pub const m_LastEnterTime: usize = 0xAC0; // GameTime_t
    pub const m_LastExitWeight: usize = 0xAC4; // float
    pub const m_LastExitTime: usize = 0xAC8; // GameTime_t
}

pub mod CCommentaryAuto {
    pub const m_OnCommentaryNewGame: usize = 0x4B0; // CEntityIOOutput
    pub const m_OnCommentaryMidGame: usize = 0x4D8; // CEntityIOOutput
    pub const m_OnCommentaryMultiplayerSpawn: usize = 0x500; // CEntityIOOutput
}

pub mod CCommentarySystem {
    pub const m_bCommentaryConvarsChanging: usize = 0x11; // bool
    pub const m_bCommentaryEnabledMidGame: usize = 0x12; // bool
    pub const m_flNextTeleportTime: usize = 0x14; // GameTime_t
    pub const m_iTeleportStage: usize = 0x18; // int32_t
    pub const m_bCheatState: usize = 0x1C; // bool
    pub const m_bIsFirstSpawnGroupToLoad: usize = 0x1D; // bool
    pub const m_hCurrentNode: usize = 0x38; // CHandle<CPointCommentaryNode>
    pub const m_hActiveCommentaryNode: usize = 0x3C; // CHandle<CPointCommentaryNode>
    pub const m_hLastCommentaryNode: usize = 0x40; // CHandle<CPointCommentaryNode>
    pub const m_vecNodes: usize = 0x48; // CUtlVector<CHandle<CPointCommentaryNode>>
}

pub mod CConstantForceController {
    pub const m_linear: usize = 0xC; // Vector
    pub const m_angular: usize = 0x18; // RotationVector
    pub const m_linearSave: usize = 0x24; // Vector
    pub const m_angularSave: usize = 0x30; // RotationVector
}

pub mod CConstraintAnchor {
    pub const m_massScale: usize = 0x890; // float
}

pub mod CCopyRecipientFilter {
    pub const m_Flags: usize = 0x8; // int32_t
    pub const m_Recipients: usize = 0x10; // CUtlVector<CPlayerSlot>
}

pub mod CCredits {
    pub const m_OnCreditsDone: usize = 0x4B0; // CEntityIOOutput
    pub const m_bRolledOutroCredits: usize = 0x4D8; // bool
    pub const m_flLogoLength: usize = 0x4DC; // float
}

pub mod CDamageRecord {
    pub const m_PlayerDamager: usize = 0x28; // CHandle<CCSPlayerPawnBase>
    pub const m_PlayerRecipient: usize = 0x2C; // CHandle<CCSPlayerPawnBase>
    pub const m_hPlayerControllerDamager: usize = 0x30; // CHandle<CCSPlayerController>
    pub const m_hPlayerControllerRecipient: usize = 0x34; // CHandle<CCSPlayerController>
    pub const m_szPlayerDamagerName: usize = 0x38; // CUtlString
    pub const m_szPlayerRecipientName: usize = 0x40; // CUtlString
    pub const m_DamagerXuid: usize = 0x48; // uint64_t
    pub const m_RecipientXuid: usize = 0x50; // uint64_t
    pub const m_iDamage: usize = 0x58; // int32_t
    pub const m_iActualHealthRemoved: usize = 0x5C; // int32_t
    pub const m_iNumHits: usize = 0x60; // int32_t
    pub const m_iLastBulletUpdate: usize = 0x64; // int32_t
    pub const m_bIsOtherEnemy: usize = 0x68; // bool
    pub const m_killType: usize = 0x69; // EKillTypes_t
}

pub mod CDebugHistory {
    pub const m_nNpcEvents: usize = 0x44F0; // int32_t
}

pub mod CDecoyProjectile {
    pub const m_nDecoyShotTick: usize = 0xA48; // int32_t
    pub const m_shotsRemaining: usize = 0xA4C; // int32_t
    pub const m_fExpireTime: usize = 0xA50; // GameTime_t
    pub const m_decoyWeaponDefIndex: usize = 0xA60; // uint16_t
}

pub mod CDynamicLight {
    pub const m_ActualFlags: usize = 0x700; // uint8_t
    pub const m_Flags: usize = 0x701; // uint8_t
    pub const m_LightStyle: usize = 0x702; // uint8_t
    pub const m_On: usize = 0x703; // bool
    pub const m_Radius: usize = 0x704; // float
    pub const m_Exponent: usize = 0x708; // int32_t
    pub const m_InnerAngle: usize = 0x70C; // float
    pub const m_OuterAngle: usize = 0x710; // float
    pub const m_SpotRadius: usize = 0x714; // float
}

pub mod CDynamicProp {
    pub const m_bCreateNavObstacle: usize = 0xA10; // bool
    pub const m_bUseHitboxesForRenderBox: usize = 0xA11; // bool
    pub const m_bUseAnimGraph: usize = 0xA12; // bool
    pub const m_pOutputAnimBegun: usize = 0xA18; // CEntityIOOutput
    pub const m_pOutputAnimOver: usize = 0xA40; // CEntityIOOutput
    pub const m_pOutputAnimLoopCycleOver: usize = 0xA68; // CEntityIOOutput
    pub const m_OnAnimReachedStart: usize = 0xA90; // CEntityIOOutput
    pub const m_OnAnimReachedEnd: usize = 0xAB8; // CEntityIOOutput
    pub const m_iszDefaultAnim: usize = 0xAE0; // CUtlSymbolLarge
    pub const m_nDefaultAnimLoopMode: usize = 0xAE8; // AnimLoopMode_t
    pub const m_bAnimateOnServer: usize = 0xAEC; // bool
    pub const m_bRandomizeCycle: usize = 0xAED; // bool
    pub const m_bStartDisabled: usize = 0xAEE; // bool
    pub const m_bScriptedMovement: usize = 0xAEF; // bool
    pub const m_bFiredStartEndOutput: usize = 0xAF0; // bool
    pub const m_bForceNpcExclude: usize = 0xAF1; // bool
    pub const m_bCreateNonSolid: usize = 0xAF2; // bool
    pub const m_bIsOverrideProp: usize = 0xAF3; // bool
    pub const m_iInitialGlowState: usize = 0xAF4; // int32_t
    pub const m_nGlowRange: usize = 0xAF8; // int32_t
    pub const m_nGlowRangeMin: usize = 0xAFC; // int32_t
    pub const m_glowColor: usize = 0xB00; // Color
    pub const m_nGlowTeam: usize = 0xB04; // int32_t
}

pub mod CEconEntity {
    pub const m_AttributeManager: usize = 0x930; // CAttributeContainer
    pub const m_OriginalOwnerXuidLow: usize = 0xBF8; // uint32_t
    pub const m_OriginalOwnerXuidHigh: usize = 0xBFC; // uint32_t
    pub const m_nFallbackPaintKit: usize = 0xC00; // int32_t
    pub const m_nFallbackSeed: usize = 0xC04; // int32_t
    pub const m_flFallbackWear: usize = 0xC08; // float
    pub const m_nFallbackStatTrak: usize = 0xC0C; // int32_t
    pub const m_hOldProvidee: usize = 0xC10; // CHandle<CBaseEntity>
    pub const m_iOldOwnerClass: usize = 0xC14; // int32_t
}

pub mod CEconItemAttribute {
    pub const m_iAttributeDefinitionIndex: usize = 0x30; // uint16_t
    pub const m_flValue: usize = 0x34; // float
    pub const m_flInitialValue: usize = 0x38; // float
    pub const m_nRefundableCurrency: usize = 0x3C; // int32_t
    pub const m_bSetBonus: usize = 0x40; // bool
}

pub mod CEconItemView {
    pub const m_iItemDefinitionIndex: usize = 0x38; // uint16_t
    pub const m_iEntityQuality: usize = 0x3C; // int32_t
    pub const m_iEntityLevel: usize = 0x40; // uint32_t
    pub const m_iItemID: usize = 0x48; // uint64_t
    pub const m_iItemIDHigh: usize = 0x50; // uint32_t
    pub const m_iItemIDLow: usize = 0x54; // uint32_t
    pub const m_iAccountID: usize = 0x58; // uint32_t
    pub const m_iInventoryPosition: usize = 0x5C; // uint32_t
    pub const m_bInitialized: usize = 0x68; // bool
    pub const m_AttributeList: usize = 0x70; // CAttributeList
    pub const m_NetworkedDynamicAttributes: usize = 0xD0; // CAttributeList
    pub const m_szCustomName: usize = 0x130; // char[161]
    pub const m_szCustomNameOverride: usize = 0x1D1; // char[161]
}

pub mod CEconWearable {
    pub const m_nForceSkin: usize = 0xC18; // int32_t
    pub const m_bAlwaysAllow: usize = 0xC1C; // bool
}

pub mod CEffectData {
    pub const m_vOrigin: usize = 0x8; // Vector
    pub const m_vStart: usize = 0x14; // Vector
    pub const m_vNormal: usize = 0x20; // Vector
    pub const m_vAngles: usize = 0x2C; // QAngle
    pub const m_hEntity: usize = 0x38; // CEntityHandle
    pub const m_hOtherEntity: usize = 0x3C; // CEntityHandle
    pub const m_flScale: usize = 0x40; // float
    pub const m_flMagnitude: usize = 0x44; // float
    pub const m_flRadius: usize = 0x48; // float
    pub const m_nSurfaceProp: usize = 0x4C; // CUtlStringToken
    pub const m_nEffectIndex: usize = 0x50; // CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>
    pub const m_nDamageType: usize = 0x58; // uint32_t
    pub const m_nPenetrate: usize = 0x5C; // uint8_t
    pub const m_nMaterial: usize = 0x5E; // uint16_t
    pub const m_nHitBox: usize = 0x60; // uint16_t
    pub const m_nColor: usize = 0x62; // uint8_t
    pub const m_fFlags: usize = 0x63; // uint8_t
    pub const m_nAttachmentIndex: usize = 0x64; // AttachmentHandle_t
    pub const m_nAttachmentName: usize = 0x68; // CUtlStringToken
    pub const m_iEffectName: usize = 0x6C; // uint16_t
    pub const m_nExplosionType: usize = 0x6E; // uint8_t
}

pub mod CEntityDissolve {
    pub const m_flFadeInStart: usize = 0x700; // float
    pub const m_flFadeInLength: usize = 0x704; // float
    pub const m_flFadeOutModelStart: usize = 0x708; // float
    pub const m_flFadeOutModelLength: usize = 0x70C; // float
    pub const m_flFadeOutStart: usize = 0x710; // float
    pub const m_flFadeOutLength: usize = 0x714; // float
    pub const m_flStartTime: usize = 0x718; // GameTime_t
    pub const m_nDissolveType: usize = 0x71C; // EntityDisolveType_t
    pub const m_vDissolverOrigin: usize = 0x720; // Vector
    pub const m_nMagnitude: usize = 0x72C; // uint32_t
}

pub mod CEntityFlame {
    pub const m_hEntAttached: usize = 0x4B0; // CHandle<CBaseEntity>
    pub const m_bCheapEffect: usize = 0x4B4; // bool
    pub const m_flSize: usize = 0x4B8; // float
    pub const m_bUseHitboxes: usize = 0x4BC; // bool
    pub const m_iNumHitboxFires: usize = 0x4C0; // int32_t
    pub const m_flHitboxFireScale: usize = 0x4C4; // float
    pub const m_flLifetime: usize = 0x4C8; // GameTime_t
    pub const m_hAttacker: usize = 0x4CC; // CHandle<CBaseEntity>
    pub const m_iDangerSound: usize = 0x4D0; // int32_t
    pub const m_flDirectDamagePerSecond: usize = 0x4D4; // float
    pub const m_iCustomDamageType: usize = 0x4D8; // int32_t
}

pub mod CEntityIdentity {
    pub const m_nameStringableIndex: usize = 0x14; // int32_t
    pub const m_name: usize = 0x18; // CUtlSymbolLarge
    pub const m_designerName: usize = 0x20; // CUtlSymbolLarge
    pub const m_flags: usize = 0x30; // uint32_t
    pub const m_worldGroupId: usize = 0x38; // WorldGroupId_t
    pub const m_fDataObjectTypes: usize = 0x3C; // uint32_t
    pub const m_PathIndex: usize = 0x40; // ChangeAccessorFieldPathIndex_t
    pub const m_pPrev: usize = 0x58; // CEntityIdentity*
    pub const m_pNext: usize = 0x60; // CEntityIdentity*
    pub const m_pPrevByClass: usize = 0x68; // CEntityIdentity*
    pub const m_pNextByClass: usize = 0x70; // CEntityIdentity*
}

pub mod CEntityInstance {
    pub const m_iszPrivateVScripts: usize = 0x8; // CUtlSymbolLarge
    pub const m_pEntity: usize = 0x10; // CEntityIdentity*
    pub const m_CScriptComponent: usize = 0x28; // CScriptComponent*
}

pub mod CEnvBeam {
    pub const m_active: usize = 0x7A0; // int32_t
    pub const m_spriteTexture: usize = 0x7A8; // CStrongHandle<InfoForResourceTypeIMaterial2>
    pub const m_iszStartEntity: usize = 0x7B0; // CUtlSymbolLarge
    pub const m_iszEndEntity: usize = 0x7B8; // CUtlSymbolLarge
    pub const m_life: usize = 0x7C0; // float
    pub const m_boltWidth: usize = 0x7C4; // float
    pub const m_noiseAmplitude: usize = 0x7C8; // float
    pub const m_speed: usize = 0x7CC; // int32_t
    pub const m_restrike: usize = 0x7D0; // float
    pub const m_iszSpriteName: usize = 0x7D8; // CUtlSymbolLarge
    pub const m_frameStart: usize = 0x7E0; // int32_t
    pub const m_vEndPointWorld: usize = 0x7E4; // Vector
    pub const m_vEndPointRelative: usize = 0x7F0; // Vector
    pub const m_radius: usize = 0x7FC; // float
    pub const m_TouchType: usize = 0x800; // Touch_t
    pub const m_iFilterName: usize = 0x808; // CUtlSymbolLarge
    pub const m_hFilter: usize = 0x810; // CHandle<CBaseEntity>
    pub const m_iszDecal: usize = 0x818; // CUtlSymbolLarge
    pub const m_OnTouchedByEntity: usize = 0x820; // CEntityIOOutput
}

pub mod CEnvBeverage {
    pub const m_CanInDispenser: usize = 0x4B0; // bool
    pub const m_nBeverageType: usize = 0x4B4; // int32_t
}

pub mod CEnvCombinedLightProbeVolume {
    pub const m_Color: usize = 0x1508; // Color
    pub const m_flBrightness: usize = 0x150C; // float
    pub const m_hCubemapTexture: usize = 0x1510; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_bCustomCubemapTexture: usize = 0x1518; // bool
    pub const m_hLightProbeTexture: usize = 0x1520; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_hLightProbeDirectLightIndicesTexture: usize = 0x1528; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_hLightProbeDirectLightScalarsTexture: usize = 0x1530; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_hLightProbeDirectLightShadowsTexture: usize = 0x1538; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_vBoxMins: usize = 0x1540; // Vector
    pub const m_vBoxMaxs: usize = 0x154C; // Vector
    pub const m_bMoveable: usize = 0x1558; // bool
    pub const m_nHandshake: usize = 0x155C; // int32_t
    pub const m_nEnvCubeMapArrayIndex: usize = 0x1560; // int32_t
    pub const m_nPriority: usize = 0x1564; // int32_t
    pub const m_bStartDisabled: usize = 0x1568; // bool
    pub const m_flEdgeFadeDist: usize = 0x156C; // float
    pub const m_vEdgeFadeDists: usize = 0x1570; // Vector
    pub const m_nLightProbeSizeX: usize = 0x157C; // int32_t
    pub const m_nLightProbeSizeY: usize = 0x1580; // int32_t
    pub const m_nLightProbeSizeZ: usize = 0x1584; // int32_t
    pub const m_nLightProbeAtlasX: usize = 0x1588; // int32_t
    pub const m_nLightProbeAtlasY: usize = 0x158C; // int32_t
    pub const m_nLightProbeAtlasZ: usize = 0x1590; // int32_t
    pub const m_bEnabled: usize = 0x15A9; // bool
}

pub mod CEnvCubemap {
    pub const m_hCubemapTexture: usize = 0x530; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_bCustomCubemapTexture: usize = 0x538; // bool
    pub const m_flInfluenceRadius: usize = 0x53C; // float
    pub const m_vBoxProjectMins: usize = 0x540; // Vector
    pub const m_vBoxProjectMaxs: usize = 0x54C; // Vector
    pub const m_bMoveable: usize = 0x558; // bool
    pub const m_nHandshake: usize = 0x55C; // int32_t
    pub const m_nEnvCubeMapArrayIndex: usize = 0x560; // int32_t
    pub const m_nPriority: usize = 0x564; // int32_t
    pub const m_flEdgeFadeDist: usize = 0x568; // float
    pub const m_vEdgeFadeDists: usize = 0x56C; // Vector
    pub const m_flDiffuseScale: usize = 0x578; // float
    pub const m_bStartDisabled: usize = 0x57C; // bool
    pub const m_bDefaultEnvMap: usize = 0x57D; // bool
    pub const m_bDefaultSpecEnvMap: usize = 0x57E; // bool
    pub const m_bIndoorCubeMap: usize = 0x57F; // bool
    pub const m_bCopyDiffuseFromDefaultCubemap: usize = 0x580; // bool
    pub const m_bEnabled: usize = 0x590; // bool
}

pub mod CEnvCubemapFog {
    pub const m_flEndDistance: usize = 0x4B0; // float
    pub const m_flStartDistance: usize = 0x4B4; // float
    pub const m_flFogFalloffExponent: usize = 0x4B8; // float
    pub const m_bHeightFogEnabled: usize = 0x4BC; // bool
    pub const m_flFogHeightWidth: usize = 0x4C0; // float
    pub const m_flFogHeightEnd: usize = 0x4C4; // float
    pub const m_flFogHeightStart: usize = 0x4C8; // float
    pub const m_flFogHeightExponent: usize = 0x4CC; // float
    pub const m_flLODBias: usize = 0x4D0; // float
    pub const m_bActive: usize = 0x4D4; // bool
    pub const m_bStartDisabled: usize = 0x4D5; // bool
    pub const m_flFogMaxOpacity: usize = 0x4D8; // float
    pub const m_nCubemapSourceType: usize = 0x4DC; // int32_t
    pub const m_hSkyMaterial: usize = 0x4E0; // CStrongHandle<InfoForResourceTypeIMaterial2>
    pub const m_iszSkyEntity: usize = 0x4E8; // CUtlSymbolLarge
    pub const m_hFogCubemapTexture: usize = 0x4F0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_bHasHeightFogEnd: usize = 0x4F8; // bool
    pub const m_bFirstTime: usize = 0x4F9; // bool
}

pub mod CEnvDecal {
    pub const m_hDecalMaterial: usize = 0x700; // CStrongHandle<InfoForResourceTypeIMaterial2>
    pub const m_flWidth: usize = 0x708; // float
    pub const m_flHeight: usize = 0x70C; // float
    pub const m_flDepth: usize = 0x710; // float
    pub const m_nRenderOrder: usize = 0x714; // uint32_t
    pub const m_bProjectOnWorld: usize = 0x718; // bool
    pub const m_bProjectOnCharacters: usize = 0x719; // bool
    pub const m_bProjectOnWater: usize = 0x71A; // bool
    pub const m_flDepthSortBias: usize = 0x71C; // float
}

pub mod CEnvDetailController {
    pub const m_flFadeStartDist: usize = 0x4B0; // float
    pub const m_flFadeEndDist: usize = 0x4B4; // float
}

pub mod CEnvEntityIgniter {
    pub const m_flLifetime: usize = 0x4B0; // float
}

pub mod CEnvEntityMaker {
    pub const m_vecEntityMins: usize = 0x4B0; // Vector
    pub const m_vecEntityMaxs: usize = 0x4BC; // Vector
    pub const m_hCurrentInstance: usize = 0x4C8; // CHandle<CBaseEntity>
    pub const m_hCurrentBlocker: usize = 0x4CC; // CHandle<CBaseEntity>
    pub const m_vecBlockerOrigin: usize = 0x4D0; // Vector
    pub const m_angPostSpawnDirection: usize = 0x4DC; // QAngle
    pub const m_flPostSpawnDirectionVariance: usize = 0x4E8; // float
    pub const m_flPostSpawnSpeed: usize = 0x4EC; // float
    pub const m_bPostSpawnUseAngles: usize = 0x4F0; // bool
    pub const m_iszTemplate: usize = 0x4F8; // CUtlSymbolLarge
    pub const m_pOutputOnSpawned: usize = 0x500; // CEntityIOOutput
    pub const m_pOutputOnFailedSpawn: usize = 0x528; // CEntityIOOutput
}

pub mod CEnvExplosion {
    pub const m_iMagnitude: usize = 0x700; // int32_t
    pub const m_flPlayerDamage: usize = 0x704; // float
    pub const m_iRadiusOverride: usize = 0x708; // int32_t
    pub const m_flInnerRadius: usize = 0x70C; // float
    pub const m_spriteScale: usize = 0x710; // int32_t
    pub const m_flDamageForce: usize = 0x714; // float
    pub const m_hInflictor: usize = 0x718; // CHandle<CBaseEntity>
    pub const m_iCustomDamageType: usize = 0x71C; // int32_t
    pub const m_iszExplosionType: usize = 0x728; // CUtlSymbolLarge
    pub const m_iszCustomEffectName: usize = 0x730; // CUtlSymbolLarge
    pub const m_iszCustomSoundName: usize = 0x738; // CUtlSymbolLarge
    pub const m_iClassIgnore: usize = 0x740; // Class_T
    pub const m_iClassIgnore2: usize = 0x744; // Class_T
    pub const m_iszEntityIgnoreName: usize = 0x748; // CUtlSymbolLarge
    pub const m_hEntityIgnore: usize = 0x750; // CHandle<CBaseEntity>
}

pub mod CEnvFade {
    pub const m_fadeColor: usize = 0x4B0; // Color
    pub const m_Duration: usize = 0x4B4; // float
    pub const m_HoldDuration: usize = 0x4B8; // float
    pub const m_OnBeginFade: usize = 0x4C0; // CEntityIOOutput
}

pub mod CEnvFireSensor {
    pub const m_bEnabled: usize = 0x4B0; // bool
    pub const m_bHeatAtLevel: usize = 0x4B1; // bool
    pub const m_radius: usize = 0x4B4; // float
    pub const m_targetLevel: usize = 0x4B8; // float
    pub const m_targetTime: usize = 0x4BC; // float
    pub const m_levelTime: usize = 0x4C0; // float
    pub const m_OnHeatLevelStart: usize = 0x4C8; // CEntityIOOutput
    pub const m_OnHeatLevelEnd: usize = 0x4F0; // CEntityIOOutput
}

pub mod CEnvFireSource {
    pub const m_bEnabled: usize = 0x4B0; // bool
    pub const m_radius: usize = 0x4B4; // float
    pub const m_damage: usize = 0x4B8; // float
}

pub mod CEnvGlobal {
    pub const m_outCounter: usize = 0x4B0; // CEntityOutputTemplate<int32_t>
    pub const m_globalstate: usize = 0x4D8; // CUtlSymbolLarge
    pub const m_triggermode: usize = 0x4E0; // int32_t
    pub const m_initialstate: usize = 0x4E4; // int32_t
    pub const m_counter: usize = 0x4E8; // int32_t
}

pub mod CEnvHudHint {
    pub const m_iszMessage: usize = 0x4B0; // CUtlSymbolLarge
}

pub mod CEnvInstructorHint {
    pub const m_iszName: usize = 0x4B0; // CUtlSymbolLarge
    pub const m_iszReplace_Key: usize = 0x4B8; // CUtlSymbolLarge
    pub const m_iszHintTargetEntity: usize = 0x4C0; // CUtlSymbolLarge
    pub const m_iTimeout: usize = 0x4C8; // int32_t
    pub const m_iDisplayLimit: usize = 0x4CC; // int32_t
    pub const m_iszIcon_Onscreen: usize = 0x4D0; // CUtlSymbolLarge
    pub const m_iszIcon_Offscreen: usize = 0x4D8; // CUtlSymbolLarge
    pub const m_iszCaption: usize = 0x4E0; // CUtlSymbolLarge
    pub const m_iszActivatorCaption: usize = 0x4E8; // CUtlSymbolLarge
    pub const m_Color: usize = 0x4F0; // Color
    pub const m_fIconOffset: usize = 0x4F4; // float
    pub const m_fRange: usize = 0x4F8; // float
    pub const m_iPulseOption: usize = 0x4FC; // uint8_t
    pub const m_iAlphaOption: usize = 0x4FD; // uint8_t
    pub const m_iShakeOption: usize = 0x4FE; // uint8_t
    pub const m_bStatic: usize = 0x4FF; // bool
    pub const m_bNoOffscreen: usize = 0x500; // bool
    pub const m_bForceCaption: usize = 0x501; // bool
    pub const m_iInstanceType: usize = 0x504; // int32_t
    pub const m_bSuppressRest: usize = 0x508; // bool
    pub const m_iszBinding: usize = 0x510; // CUtlSymbolLarge
    pub const m_bAllowNoDrawTarget: usize = 0x518; // bool
    pub const m_bAutoStart: usize = 0x519; // bool
    pub const m_bLocalPlayerOnly: usize = 0x51A; // bool
}

pub mod CEnvInstructorVRHint {
    pub const m_iszName: usize = 0x4B0; // CUtlSymbolLarge
    pub const m_iszHintTargetEntity: usize = 0x4B8; // CUtlSymbolLarge
    pub const m_iTimeout: usize = 0x4C0; // int32_t
    pub const m_iszCaption: usize = 0x4C8; // CUtlSymbolLarge
    pub const m_iszStartSound: usize = 0x4D0; // CUtlSymbolLarge
    pub const m_iLayoutFileType: usize = 0x4D8; // int32_t
    pub const m_iszCustomLayoutFile: usize = 0x4E0; // CUtlSymbolLarge
    pub const m_iAttachType: usize = 0x4E8; // int32_t
    pub const m_flHeightOffset: usize = 0x4EC; // float
}

pub mod CEnvLaser {
    pub const m_iszLaserTarget: usize = 0x7A0; // CUtlSymbolLarge
    pub const m_pSprite: usize = 0x7A8; // CSprite*
    pub const m_iszSpriteName: usize = 0x7B0; // CUtlSymbolLarge
    pub const m_firePosition: usize = 0x7B8; // Vector
    pub const m_flStartFrame: usize = 0x7C4; // float
}

pub mod CEnvLightProbeVolume {
    pub const m_hLightProbeTexture: usize = 0x1488; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_hLightProbeDirectLightIndicesTexture: usize = 0x1490; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_hLightProbeDirectLightScalarsTexture: usize = 0x1498; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_hLightProbeDirectLightShadowsTexture: usize = 0x14A0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_vBoxMins: usize = 0x14A8; // Vector
    pub const m_vBoxMaxs: usize = 0x14B4; // Vector
    pub const m_bMoveable: usize = 0x14C0; // bool
    pub const m_nHandshake: usize = 0x14C4; // int32_t
    pub const m_nPriority: usize = 0x14C8; // int32_t
    pub const m_bStartDisabled: usize = 0x14CC; // bool
    pub const m_nLightProbeSizeX: usize = 0x14D0; // int32_t
    pub const m_nLightProbeSizeY: usize = 0x14D4; // int32_t
    pub const m_nLightProbeSizeZ: usize = 0x14D8; // int32_t
    pub const m_nLightProbeAtlasX: usize = 0x14DC; // int32_t
    pub const m_nLightProbeAtlasY: usize = 0x14E0; // int32_t
    pub const m_nLightProbeAtlasZ: usize = 0x14E4; // int32_t
    pub const m_bEnabled: usize = 0x14F1; // bool
}

pub mod CEnvMicrophone {
    pub const m_bDisabled: usize = 0x4B0; // bool
    pub const m_hMeasureTarget: usize = 0x4B4; // CHandle<CBaseEntity>
    pub const m_nSoundMask: usize = 0x4B8; // int32_t
    pub const m_flSensitivity: usize = 0x4BC; // float
    pub const m_flSmoothFactor: usize = 0x4C0; // float
    pub const m_flMaxRange: usize = 0x4C4; // float
    pub const m_iszSpeakerName: usize = 0x4C8; // CUtlSymbolLarge
    pub const m_hSpeaker: usize = 0x4D0; // CHandle<CBaseEntity>
    pub const m_bAvoidFeedback: usize = 0x4D4; // bool
    pub const m_iSpeakerDSPPreset: usize = 0x4D8; // int32_t
    pub const m_iszListenFilter: usize = 0x4E0; // CUtlSymbolLarge
    pub const m_hListenFilter: usize = 0x4E8; // CHandle<CBaseFilter>
    pub const m_SoundLevel: usize = 0x4F0; // CEntityOutputTemplate<float>
    pub const m_OnRoutedSound: usize = 0x518; // CEntityIOOutput
    pub const m_OnHeardSound: usize = 0x540; // CEntityIOOutput
    pub const m_szLastSound: usize = 0x568; // char[256]
    pub const m_iLastRoutedFrame: usize = 0x668; // int32_t
}

pub mod CEnvMuzzleFlash {
    pub const m_flScale: usize = 0x4B0; // float
    pub const m_iszParentAttachment: usize = 0x4B8; // CUtlSymbolLarge
}

pub mod CEnvParticleGlow {
    pub const m_flAlphaScale: usize = 0xC78; // float
    pub const m_flRadiusScale: usize = 0xC7C; // float
    pub const m_flSelfIllumScale: usize = 0xC80; // float
    pub const m_ColorTint: usize = 0xC84; // Color
    pub const m_hTextureOverride: usize = 0xC88; // CStrongHandle<InfoForResourceTypeCTextureBase>
}

pub mod CEnvProjectedTexture {
    pub const m_hTargetEntity: usize = 0x700; // CHandle<CBaseEntity>
    pub const m_bState: usize = 0x704; // bool
    pub const m_bAlwaysUpdate: usize = 0x705; // bool
    pub const m_flLightFOV: usize = 0x708; // float
    pub const m_bEnableShadows: usize = 0x70C; // bool
    pub const m_bSimpleProjection: usize = 0x70D; // bool
    pub const m_bLightOnlyTarget: usize = 0x70E; // bool
    pub const m_bLightWorld: usize = 0x70F; // bool
    pub const m_bCameraSpace: usize = 0x710; // bool
    pub const m_flBrightnessScale: usize = 0x714; // float
    pub const m_LightColor: usize = 0x718; // Color
    pub const m_flIntensity: usize = 0x71C; // float
    pub const m_flLinearAttenuation: usize = 0x720; // float
    pub const m_flQuadraticAttenuation: usize = 0x724; // float
    pub const m_bVolumetric: usize = 0x728; // bool
    pub const m_flNoiseStrength: usize = 0x72C; // float
    pub const m_flFlashlightTime: usize = 0x730; // float
    pub const m_nNumPlanes: usize = 0x734; // uint32_t
    pub const m_flPlaneOffset: usize = 0x738; // float
    pub const m_flVolumetricIntensity: usize = 0x73C; // float
    pub const m_flColorTransitionTime: usize = 0x740; // float
    pub const m_flAmbient: usize = 0x744; // float
    pub const m_SpotlightTextureName: usize = 0x748; // char[512]
    pub const m_nSpotlightTextureFrame: usize = 0x948; // int32_t
    pub const m_nShadowQuality: usize = 0x94C; // uint32_t
    pub const m_flNearZ: usize = 0x950; // float
    pub const m_flFarZ: usize = 0x954; // float
    pub const m_flProjectionSize: usize = 0x958; // float
    pub const m_flRotation: usize = 0x95C; // float
    pub const m_bFlipHorizontal: usize = 0x960; // bool
}

pub mod CEnvScreenOverlay {
    pub const m_iszOverlayNames: usize = 0x4B0; // CUtlSymbolLarge[10]
    pub const m_flOverlayTimes: usize = 0x500; // float[10]
    pub const m_flStartTime: usize = 0x528; // GameTime_t
    pub const m_iDesiredOverlay: usize = 0x52C; // int32_t
    pub const m_bIsActive: usize = 0x530; // bool
}

pub mod CEnvShake {
    pub const m_limitToEntity: usize = 0x4B0; // CUtlSymbolLarge
    pub const m_Amplitude: usize = 0x4B8; // float
    pub const m_Frequency: usize = 0x4BC; // float
    pub const m_Duration: usize = 0x4C0; // float
    pub const m_Radius: usize = 0x4C4; // float
    pub const m_stopTime: usize = 0x4C8; // GameTime_t
    pub const m_nextShake: usize = 0x4CC; // GameTime_t
    pub const m_currentAmp: usize = 0x4D0; // float
    pub const m_maxForce: usize = 0x4D4; // Vector
    pub const m_shakeCallback: usize = 0x4E8; // CPhysicsShake
}

pub mod CEnvSky {
    pub const m_hSkyMaterial: usize = 0x700; // CStrongHandle<InfoForResourceTypeIMaterial2>
    pub const m_hSkyMaterialLightingOnly: usize = 0x708; // CStrongHandle<InfoForResourceTypeIMaterial2>
    pub const m_bStartDisabled: usize = 0x710; // bool
    pub const m_vTintColor: usize = 0x711; // Color
    pub const m_vTintColorLightingOnly: usize = 0x715; // Color
    pub const m_flBrightnessScale: usize = 0x71C; // float
    pub const m_nFogType: usize = 0x720; // int32_t
    pub const m_flFogMinStart: usize = 0x724; // float
    pub const m_flFogMinEnd: usize = 0x728; // float
    pub const m_flFogMaxStart: usize = 0x72C; // float
    pub const m_flFogMaxEnd: usize = 0x730; // float
    pub const m_bEnabled: usize = 0x734; // bool
}

pub mod CEnvSoundscape {
    pub const m_OnPlay: usize = 0x4B0; // CEntityIOOutput
    pub const m_flRadius: usize = 0x4D8; // float
    pub const m_soundscapeName: usize = 0x4E0; // CUtlSymbolLarge
    pub const m_soundEventName: usize = 0x4E8; // CUtlSymbolLarge
    pub const m_bOverrideWithEvent: usize = 0x4F0; // bool
    pub const m_soundscapeIndex: usize = 0x4F4; // int32_t
    pub const m_soundscapeEntityListId: usize = 0x4F8; // int32_t
    pub const m_soundEventHash: usize = 0x4FC; // uint32_t
    pub const m_positionNames: usize = 0x500; // CUtlSymbolLarge[8]
    pub const m_hProxySoundscape: usize = 0x540; // CHandle<CEnvSoundscape>
    pub const m_bDisabled: usize = 0x544; // bool
}

pub mod CEnvSoundscapeProxy {
    pub const m_MainSoundscapeName: usize = 0x548; // CUtlSymbolLarge
}

pub mod CEnvSpark {
    pub const m_flDelay: usize = 0x4B0; // float
    pub const m_nMagnitude: usize = 0x4B4; // int32_t
    pub const m_nTrailLength: usize = 0x4B8; // int32_t
    pub const m_nType: usize = 0x4BC; // int32_t
    pub const m_OnSpark: usize = 0x4C0; // CEntityIOOutput
}

pub mod CEnvSplash {
    pub const m_flScale: usize = 0x4B0; // float
}

pub mod CEnvTilt {
    pub const m_Duration: usize = 0x4B0; // float
    pub const m_Radius: usize = 0x4B4; // float
    pub const m_TiltTime: usize = 0x4B8; // float
    pub const m_stopTime: usize = 0x4BC; // GameTime_t
}

pub mod CEnvTracer {
    pub const m_vecEnd: usize = 0x4B0; // Vector
    pub const m_flDelay: usize = 0x4BC; // float
}

pub mod CEnvViewPunch {
    pub const m_flRadius: usize = 0x4B0; // float
    pub const m_angViewPunch: usize = 0x4B4; // QAngle
}

pub mod CEnvVolumetricFogController {
    pub const m_flScattering: usize = 0x4B0; // float
    pub const m_flAnisotropy: usize = 0x4B4; // float
    pub const m_flFadeSpeed: usize = 0x4B8; // float
    pub const m_flDrawDistance: usize = 0x4BC; // float
    pub const m_flFadeInStart: usize = 0x4C0; // float
    pub const m_flFadeInEnd: usize = 0x4C4; // float
    pub const m_flIndirectStrength: usize = 0x4C8; // float
    pub const m_nIndirectTextureDimX: usize = 0x4CC; // int32_t
    pub const m_nIndirectTextureDimY: usize = 0x4D0; // int32_t
    pub const m_nIndirectTextureDimZ: usize = 0x4D4; // int32_t
    pub const m_vBoxMins: usize = 0x4D8; // Vector
    pub const m_vBoxMaxs: usize = 0x4E4; // Vector
    pub const m_bActive: usize = 0x4F0; // bool
    pub const m_flStartAnisoTime: usize = 0x4F4; // GameTime_t
    pub const m_flStartScatterTime: usize = 0x4F8; // GameTime_t
    pub const m_flStartDrawDistanceTime: usize = 0x4FC; // GameTime_t
    pub const m_flStartAnisotropy: usize = 0x500; // float
    pub const m_flStartScattering: usize = 0x504; // float
    pub const m_flStartDrawDistance: usize = 0x508; // float
    pub const m_flDefaultAnisotropy: usize = 0x50C; // float
    pub const m_flDefaultScattering: usize = 0x510; // float
    pub const m_flDefaultDrawDistance: usize = 0x514; // float
    pub const m_bStartDisabled: usize = 0x518; // bool
    pub const m_bEnableIndirect: usize = 0x519; // bool
    pub const m_bIsMaster: usize = 0x51A; // bool
    pub const m_hFogIndirectTexture: usize = 0x520; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_nForceRefreshCount: usize = 0x528; // int32_t
    pub const m_bFirstTime: usize = 0x52C; // bool
}

pub mod CEnvVolumetricFogVolume {
    pub const m_bActive: usize = 0x4B0; // bool
    pub const m_vBoxMins: usize = 0x4B4; // Vector
    pub const m_vBoxMaxs: usize = 0x4C0; // Vector
    pub const m_bStartDisabled: usize = 0x4CC; // bool
    pub const m_flStrength: usize = 0x4D0; // float
    pub const m_nFalloffShape: usize = 0x4D4; // int32_t
    pub const m_flFalloffExponent: usize = 0x4D8; // float
}

pub mod CEnvWind {
    pub const m_EnvWindShared: usize = 0x4B0; // CEnvWindShared
}

pub mod CEnvWindShared {
    pub const m_flStartTime: usize = 0x8; // GameTime_t
    pub const m_iWindSeed: usize = 0xC; // uint32_t
    pub const m_iMinWind: usize = 0x10; // uint16_t
    pub const m_iMaxWind: usize = 0x12; // uint16_t
    pub const m_windRadius: usize = 0x14; // int32_t
    pub const m_iMinGust: usize = 0x18; // uint16_t
    pub const m_iMaxGust: usize = 0x1A; // uint16_t
    pub const m_flMinGustDelay: usize = 0x1C; // float
    pub const m_flMaxGustDelay: usize = 0x20; // float
    pub const m_flGustDuration: usize = 0x24; // float
    pub const m_iGustDirChange: usize = 0x28; // uint16_t
    pub const m_location: usize = 0x2C; // Vector
    pub const m_iszGustSound: usize = 0x38; // int32_t
    pub const m_iWindDir: usize = 0x3C; // int32_t
    pub const m_flWindSpeed: usize = 0x40; // float
    pub const m_currentWindVector: usize = 0x44; // Vector
    pub const m_CurrentSwayVector: usize = 0x50; // Vector
    pub const m_PrevSwayVector: usize = 0x5C; // Vector
    pub const m_iInitialWindDir: usize = 0x68; // uint16_t
    pub const m_flInitialWindSpeed: usize = 0x6C; // float
    pub const m_OnGustStart: usize = 0x70; // CEntityIOOutput
    pub const m_OnGustEnd: usize = 0x98; // CEntityIOOutput
    pub const m_flVariationTime: usize = 0xC0; // GameTime_t
    pub const m_flSwayTime: usize = 0xC4; // GameTime_t
    pub const m_flSimTime: usize = 0xC8; // GameTime_t
    pub const m_flSwitchTime: usize = 0xCC; // GameTime_t
    pub const m_flAveWindSpeed: usize = 0xD0; // float
    pub const m_bGusting: usize = 0xD4; // bool
    pub const m_flWindAngleVariation: usize = 0xD8; // float
    pub const m_flWindSpeedVariation: usize = 0xDC; // float
    pub const m_iEntIndex: usize = 0xE0; // CEntityIndex
}

pub mod CEnvWindShared_WindAveEvent_t {
    pub const m_flStartWindSpeed: usize = 0x0; // float
    pub const m_flAveWindSpeed: usize = 0x4; // float
}

pub mod CEnvWindShared_WindVariationEvent_t {
    pub const m_flWindAngleVariation: usize = 0x0; // float
    pub const m_flWindSpeedVariation: usize = 0x4; // float
}

pub mod CFilterAttributeInt {
    pub const m_sAttributeName: usize = 0x508; // CUtlStringToken
}

pub mod CFilterClass {
    pub const m_iFilterClass: usize = 0x508; // CUtlSymbolLarge
}

pub mod CFilterContext {
    pub const m_iFilterContext: usize = 0x508; // CUtlSymbolLarge
}

pub mod CFilterEnemy {
    pub const m_iszEnemyName: usize = 0x508; // CUtlSymbolLarge
    pub const m_flRadius: usize = 0x510; // float
    pub const m_flOuterRadius: usize = 0x514; // float
    pub const m_nMaxSquadmatesPerEnemy: usize = 0x518; // int32_t
    pub const m_iszPlayerName: usize = 0x520; // CUtlSymbolLarge
}

pub mod CFilterMassGreater {
    pub const m_fFilterMass: usize = 0x508; // float
}

pub mod CFilterModel {
    pub const m_iFilterModel: usize = 0x508; // CUtlSymbolLarge
}

pub mod CFilterMultiple {
    pub const m_nFilterType: usize = 0x508; // filter_t
    pub const m_iFilterName: usize = 0x510; // CUtlSymbolLarge[10]
    pub const m_hFilter: usize = 0x560; // CHandle<CBaseEntity>[10]
    pub const m_nFilterCount: usize = 0x588; // int32_t
}

pub mod CFilterName {
    pub const m_iFilterName: usize = 0x508; // CUtlSymbolLarge
}

pub mod CFilterProximity {
    pub const m_flRadius: usize = 0x508; // float
}

pub mod CFire {
    pub const m_hEffect: usize = 0x700; // CHandle<CBaseFire>
    pub const m_hOwner: usize = 0x704; // CHandle<CBaseEntity>
    pub const m_nFireType: usize = 0x708; // int32_t
    pub const m_flFuel: usize = 0x70C; // float
    pub const m_flDamageTime: usize = 0x710; // GameTime_t
    pub const m_lastDamage: usize = 0x714; // GameTime_t
    pub const m_flFireSize: usize = 0x718; // float
    pub const m_flLastNavUpdateTime: usize = 0x71C; // GameTime_t
    pub const m_flHeatLevel: usize = 0x720; // float
    pub const m_flHeatAbsorb: usize = 0x724; // float
    pub const m_flDamageScale: usize = 0x728; // float
    pub const m_flMaxHeat: usize = 0x72C; // float
    pub const m_flLastHeatLevel: usize = 0x730; // float
    pub const m_flAttackTime: usize = 0x734; // float
    pub const m_bEnabled: usize = 0x738; // bool
    pub const m_bStartDisabled: usize = 0x739; // bool
    pub const m_bDidActivate: usize = 0x73A; // bool
    pub const m_OnIgnited: usize = 0x740; // CEntityIOOutput
    pub const m_OnExtinguished: usize = 0x768; // CEntityIOOutput
}

pub mod CFireSmoke {
    pub const m_nFlameModelIndex: usize = 0x4C0; // int32_t
    pub const m_nFlameFromAboveModelIndex: usize = 0x4C4; // int32_t
}

pub mod CFiringModeFloat {
    pub const m_flValues: usize = 0x0; // float[2]
}

pub mod CFiringModeInt {
    pub const m_nValues: usize = 0x0; // int32_t[2]
}

pub mod CFish {
    pub const m_pool: usize = 0x890; // CHandle<CFishPool>
    pub const m_id: usize = 0x894; // uint32_t
    pub const m_x: usize = 0x898; // float
    pub const m_y: usize = 0x89C; // float
    pub const m_z: usize = 0x8A0; // float
    pub const m_angle: usize = 0x8A4; // float
    pub const m_angleChange: usize = 0x8A8; // float
    pub const m_forward: usize = 0x8AC; // Vector
    pub const m_perp: usize = 0x8B8; // Vector
    pub const m_poolOrigin: usize = 0x8C4; // Vector
    pub const m_waterLevel: usize = 0x8D0; // float
    pub const m_speed: usize = 0x8D4; // float
    pub const m_desiredSpeed: usize = 0x8D8; // float
    pub const m_calmSpeed: usize = 0x8DC; // float
    pub const m_panicSpeed: usize = 0x8E0; // float
    pub const m_avoidRange: usize = 0x8E4; // float
    pub const m_turnTimer: usize = 0x8E8; // CountdownTimer
    pub const m_turnClockwise: usize = 0x900; // bool
    pub const m_goTimer: usize = 0x908; // CountdownTimer
    pub const m_moveTimer: usize = 0x920; // CountdownTimer
    pub const m_panicTimer: usize = 0x938; // CountdownTimer
    pub const m_disperseTimer: usize = 0x950; // CountdownTimer
    pub const m_proximityTimer: usize = 0x968; // CountdownTimer
    pub const m_visible: usize = 0x980; // CUtlVector<CFish*>
}

pub mod CFishPool {
    pub const m_fishCount: usize = 0x4C0; // int32_t
    pub const m_maxRange: usize = 0x4C4; // float
    pub const m_swimDepth: usize = 0x4C8; // float
    pub const m_waterLevel: usize = 0x4CC; // float
    pub const m_isDormant: usize = 0x4D0; // bool
    pub const m_fishes: usize = 0x4D8; // CUtlVector<CHandle<CFish>>
    pub const m_visTimer: usize = 0x4F0; // CountdownTimer
}

pub mod CFists {
    pub const m_bPlayingUninterruptableAct: usize = 0xE20; // bool
    pub const m_nUninterruptableActivity: usize = 0xE24; // PlayerAnimEvent_t
    pub const m_bRestorePrevWep: usize = 0xE28; // bool
    pub const m_hWeaponBeforePrevious: usize = 0xE2C; // CHandle<CBasePlayerWeapon>
    pub const m_hWeaponPrevious: usize = 0xE30; // CHandle<CBasePlayerWeapon>
    pub const m_bDelayedHardPunchIncoming: usize = 0xE34; // bool
    pub const m_bDestroyAfterTaunt: usize = 0xE35; // bool
}

pub mod CFlashbangProjectile {
    pub const m_flTimeToDetonate: usize = 0xA40; // float
    pub const m_numOpponentsHit: usize = 0xA44; // uint8_t
    pub const m_numTeammatesHit: usize = 0xA45; // uint8_t
}

pub mod CFogController {
    pub const m_fog: usize = 0x4B0; // fogparams_t
    pub const m_bUseAngles: usize = 0x518; // bool
    pub const m_iChangedVariables: usize = 0x51C; // int32_t
}

pub mod CFogTrigger {
    pub const m_fog: usize = 0x8A8; // fogparams_t
}

pub mod CFogVolume {
    pub const m_fogName: usize = 0x700; // CUtlSymbolLarge
    pub const m_postProcessName: usize = 0x708; // CUtlSymbolLarge
    pub const m_colorCorrectionName: usize = 0x710; // CUtlSymbolLarge
    pub const m_bDisabled: usize = 0x720; // bool
    pub const m_bInFogVolumesList: usize = 0x721; // bool
}

pub mod CFootstepControl {
    pub const m_source: usize = 0x8A8; // CUtlSymbolLarge
    pub const m_destination: usize = 0x8B0; // CUtlSymbolLarge
}

pub mod CFuncBrush {
    pub const m_iSolidity: usize = 0x700; // BrushSolidities_e
    pub const m_iDisabled: usize = 0x704; // int32_t
    pub const m_bSolidBsp: usize = 0x708; // bool
    pub const m_iszExcludedClass: usize = 0x710; // CUtlSymbolLarge
    pub const m_bInvertExclusion: usize = 0x718; // bool
    pub const m_bScriptedMovement: usize = 0x719; // bool
}

pub mod CFuncConveyor {
    pub const m_szConveyorModels: usize = 0x700; // CUtlSymbolLarge
    pub const m_flTransitionDurationSeconds: usize = 0x708; // float
    pub const m_angMoveEntitySpace: usize = 0x70C; // QAngle
    pub const m_vecMoveDirEntitySpace: usize = 0x718; // Vector
    pub const m_flTargetSpeed: usize = 0x724; // float
    pub const m_nTransitionStartTick: usize = 0x728; // GameTick_t
    pub const m_nTransitionDurationTicks: usize = 0x72C; // int32_t
    pub const m_flTransitionStartSpeed: usize = 0x730; // float
    pub const m_hConveyorModels: usize = 0x738; // CNetworkUtlVectorBase<CHandle<CBaseEntity>>
}

pub mod CFuncElectrifiedVolume {
    pub const m_EffectName: usize = 0x720; // CUtlSymbolLarge
    pub const m_EffectInterpenetrateName: usize = 0x728; // CUtlSymbolLarge
    pub const m_EffectZapName: usize = 0x730; // CUtlSymbolLarge
    pub const m_iszEffectSource: usize = 0x738; // CUtlSymbolLarge
}

pub mod CFuncInteractionLayerClip {
    pub const m_bDisabled: usize = 0x700; // bool
    pub const m_iszInteractsAs: usize = 0x708; // CUtlSymbolLarge
    pub const m_iszInteractsWith: usize = 0x710; // CUtlSymbolLarge
}

pub mod CFuncLadder {
    pub const m_vecLadderDir: usize = 0x700; // Vector
    pub const m_Dismounts: usize = 0x710; // CUtlVector<CHandle<CInfoLadderDismount>>
    pub const m_vecLocalTop: usize = 0x728; // Vector
    pub const m_vecPlayerMountPositionTop: usize = 0x734; // Vector
    pub const m_vecPlayerMountPositionBottom: usize = 0x740; // Vector
    pub const m_flAutoRideSpeed: usize = 0x74C; // float
    pub const m_bDisabled: usize = 0x750; // bool
    pub const m_bFakeLadder: usize = 0x751; // bool
    pub const m_bHasSlack: usize = 0x752; // bool
    pub const m_surfacePropName: usize = 0x758; // CUtlSymbolLarge
    pub const m_OnPlayerGotOnLadder: usize = 0x760; // CEntityIOOutput
    pub const m_OnPlayerGotOffLadder: usize = 0x788; // CEntityIOOutput
}

pub mod CFuncMonitor {
    pub const m_targetCamera: usize = 0x720; // CUtlString
    pub const m_nResolutionEnum: usize = 0x728; // int32_t
    pub const m_bRenderShadows: usize = 0x72C; // bool
    pub const m_bUseUniqueColorTarget: usize = 0x72D; // bool
    pub const m_brushModelName: usize = 0x730; // CUtlString
    pub const m_hTargetCamera: usize = 0x738; // CHandle<CBaseEntity>
    pub const m_bEnabled: usize = 0x73C; // bool
    pub const m_bDraw3DSkybox: usize = 0x73D; // bool
    pub const m_bStartEnabled: usize = 0x73E; // bool
}

pub mod CFuncMoveLinear {
    pub const m_authoredPosition: usize = 0x780; // MoveLinearAuthoredPos_t
    pub const m_angMoveEntitySpace: usize = 0x784; // QAngle
    pub const m_vecMoveDirParentSpace: usize = 0x790; // Vector
    pub const m_soundStart: usize = 0x7A0; // CUtlSymbolLarge
    pub const m_soundStop: usize = 0x7A8; // CUtlSymbolLarge
    pub const m_currentSound: usize = 0x7B0; // CUtlSymbolLarge
    pub const m_flBlockDamage: usize = 0x7B8; // float
    pub const m_flStartPosition: usize = 0x7BC; // float
    pub const m_flMoveDistance: usize = 0x7C0; // float
    pub const m_OnFullyOpen: usize = 0x7D0; // CEntityIOOutput
    pub const m_OnFullyClosed: usize = 0x7F8; // CEntityIOOutput
    pub const m_bCreateMovableNavMesh: usize = 0x820; // bool
    pub const m_bCreateNavObstacle: usize = 0x821; // bool
}

pub mod CFuncNavBlocker {
    pub const m_bDisabled: usize = 0x700; // bool
    pub const m_nBlockedTeamNumber: usize = 0x704; // int32_t
}

pub mod CFuncNavObstruction {
    pub const m_bDisabled: usize = 0x708; // bool
}

pub mod CFuncPlat {
    pub const m_sNoise: usize = 0x7A8; // CUtlSymbolLarge
}

pub mod CFuncPlatRot {
    pub const m_end: usize = 0x7B0; // QAngle
    pub const m_start: usize = 0x7BC; // QAngle
}

pub mod CFuncRotating {
    pub const m_vecMoveAng: usize = 0x700; // QAngle
    pub const m_flFanFriction: usize = 0x70C; // float
    pub const m_flAttenuation: usize = 0x710; // float
    pub const m_flVolume: usize = 0x714; // float
    pub const m_flTargetSpeed: usize = 0x718; // float
    pub const m_flMaxSpeed: usize = 0x71C; // float
    pub const m_flBlockDamage: usize = 0x720; // float
    pub const m_flTimeScale: usize = 0x724; // float
    pub const m_NoiseRunning: usize = 0x728; // CUtlSymbolLarge
    pub const m_bReversed: usize = 0x730; // bool
    pub const m_angStart: usize = 0x73C; // QAngle
    pub const m_bStopAtStartPos: usize = 0x748; // bool
    pub const m_vecClientOrigin: usize = 0x74C; // Vector
    pub const m_vecClientAngles: usize = 0x758; // QAngle
}

pub mod CFuncShatterglass {
    pub const m_hGlassMaterialDamaged: usize = 0x700; // CStrongHandle<InfoForResourceTypeIMaterial2>
    pub const m_hGlassMaterialUndamaged: usize = 0x708; // CStrongHandle<InfoForResourceTypeIMaterial2>
    pub const m_hConcreteMaterialEdgeFace: usize = 0x710; // CStrongHandle<InfoForResourceTypeIMaterial2>
    pub const m_hConcreteMaterialEdgeCaps: usize = 0x718; // CStrongHandle<InfoForResourceTypeIMaterial2>
    pub const m_hConcreteMaterialEdgeFins: usize = 0x720; // CStrongHandle<InfoForResourceTypeIMaterial2>
    pub const m_matPanelTransform: usize = 0x728; // matrix3x4_t
    pub const m_matPanelTransformWsTemp: usize = 0x758; // matrix3x4_t
    pub const m_vecShatterGlassShards: usize = 0x788; // CUtlVector<uint32_t>
    pub const m_PanelSize: usize = 0x7A0; // Vector2D
    pub const m_vecPanelNormalWs: usize = 0x7A8; // Vector
    pub const m_nNumShardsEverCreated: usize = 0x7B4; // int32_t
    pub const m_flLastShatterSoundEmitTime: usize = 0x7B8; // GameTime_t
    pub const m_flLastCleanupTime: usize = 0x7BC; // GameTime_t
    pub const m_flInitAtTime: usize = 0x7C0; // GameTime_t
    pub const m_flGlassThickness: usize = 0x7C4; // float
    pub const m_flSpawnInvulnerability: usize = 0x7C8; // float
    pub const m_bBreakSilent: usize = 0x7CC; // bool
    pub const m_bBreakShardless: usize = 0x7CD; // bool
    pub const m_bBroken: usize = 0x7CE; // bool
    pub const m_bHasRateLimitedShards: usize = 0x7CF; // bool
    pub const m_bGlassNavIgnore: usize = 0x7D0; // bool
    pub const m_bGlassInFrame: usize = 0x7D1; // bool
    pub const m_bStartBroken: usize = 0x7D2; // bool
    pub const m_iInitialDamageType: usize = 0x7D3; // uint8_t
    pub const m_szDamagePositioningEntityName01: usize = 0x7D8; // CUtlSymbolLarge
    pub const m_szDamagePositioningEntityName02: usize = 0x7E0; // CUtlSymbolLarge
    pub const m_szDamagePositioningEntityName03: usize = 0x7E8; // CUtlSymbolLarge
    pub const m_szDamagePositioningEntityName04: usize = 0x7F0; // CUtlSymbolLarge
    pub const m_vInitialDamagePositions: usize = 0x7F8; // CUtlVector<Vector>
    pub const m_vExtraDamagePositions: usize = 0x810; // CUtlVector<Vector>
    pub const m_OnBroken: usize = 0x828; // CEntityIOOutput
    pub const m_iSurfaceType: usize = 0x851; // uint8_t
}

pub mod CFuncTankTrain {
    pub const m_OnDeath: usize = 0x850; // CEntityIOOutput
}

pub mod CFuncTimescale {
    pub const m_flDesiredTimescale: usize = 0x4B0; // float
    pub const m_flAcceleration: usize = 0x4B4; // float
    pub const m_flMinBlendRate: usize = 0x4B8; // float
    pub const m_flBlendDeltaMultiplier: usize = 0x4BC; // float
    pub const m_isStarted: usize = 0x4C0; // bool
}

pub mod CFuncTrackChange {
    pub const m_trackTop: usize = 0x7C8; // CPathTrack*
    pub const m_trackBottom: usize = 0x7D0; // CPathTrack*
    pub const m_train: usize = 0x7D8; // CFuncTrackTrain*
    pub const m_trackTopName: usize = 0x7E0; // CUtlSymbolLarge
    pub const m_trackBottomName: usize = 0x7E8; // CUtlSymbolLarge
    pub const m_trainName: usize = 0x7F0; // CUtlSymbolLarge
    pub const m_code: usize = 0x7F8; // TRAIN_CODE
    pub const m_targetState: usize = 0x7FC; // int32_t
    pub const m_use: usize = 0x800; // int32_t
}

pub mod CFuncTrackTrain {
    pub const m_ppath: usize = 0x700; // CHandle<CPathTrack>
    pub const m_length: usize = 0x704; // float
    pub const m_vPosPrev: usize = 0x708; // Vector
    pub const m_angPrev: usize = 0x714; // QAngle
    pub const m_controlMins: usize = 0x720; // Vector
    pub const m_controlMaxs: usize = 0x72C; // Vector
    pub const m_lastBlockPos: usize = 0x738; // Vector
    pub const m_lastBlockTick: usize = 0x744; // int32_t
    pub const m_flVolume: usize = 0x748; // float
    pub const m_flBank: usize = 0x74C; // float
    pub const m_oldSpeed: usize = 0x750; // float
    pub const m_flBlockDamage: usize = 0x754; // float
    pub const m_height: usize = 0x758; // float
    pub const m_maxSpeed: usize = 0x75C; // float
    pub const m_dir: usize = 0x760; // float
    pub const m_iszSoundMove: usize = 0x768; // CUtlSymbolLarge
    pub const m_iszSoundMovePing: usize = 0x770; // CUtlSymbolLarge
    pub const m_iszSoundStart: usize = 0x778; // CUtlSymbolLarge
    pub const m_iszSoundStop: usize = 0x780; // CUtlSymbolLarge
    pub const m_strPathTarget: usize = 0x788; // CUtlSymbolLarge
    pub const m_flMoveSoundMinDuration: usize = 0x790; // float
    pub const m_flMoveSoundMaxDuration: usize = 0x794; // float
    pub const m_flNextMoveSoundTime: usize = 0x798; // GameTime_t
    pub const m_flMoveSoundMinPitch: usize = 0x79C; // float
    pub const m_flMoveSoundMaxPitch: usize = 0x7A0; // float
    pub const m_eOrientationType: usize = 0x7A4; // TrainOrientationType_t
    pub const m_eVelocityType: usize = 0x7A8; // TrainVelocityType_t
    pub const m_OnStart: usize = 0x7B8; // CEntityIOOutput
    pub const m_OnNext: usize = 0x7E0; // CEntityIOOutput
    pub const m_OnArrivedAtDestinationNode: usize = 0x808; // CEntityIOOutput
    pub const m_bManualSpeedChanges: usize = 0x830; // bool
    pub const m_flDesiredSpeed: usize = 0x834; // float
    pub const m_flSpeedChangeTime: usize = 0x838; // GameTime_t
    pub const m_flAccelSpeed: usize = 0x83C; // float
    pub const m_flDecelSpeed: usize = 0x840; // float
    pub const m_bAccelToSpeed: usize = 0x844; // bool
    pub const m_flTimeScale: usize = 0x848; // float
    pub const m_flNextMPSoundTime: usize = 0x84C; // GameTime_t
}

pub mod CFuncTrain {
    pub const m_hCurrentTarget: usize = 0x7A8; // CHandle<CBaseEntity>
    pub const m_activated: usize = 0x7AC; // bool
    pub const m_hEnemy: usize = 0x7B0; // CHandle<CBaseEntity>
    pub const m_flBlockDamage: usize = 0x7B4; // float
    pub const m_flNextBlockTime: usize = 0x7B8; // GameTime_t
    pub const m_iszLastTarget: usize = 0x7C0; // CUtlSymbolLarge
}

pub mod CFuncVPhysicsClip {
    pub const m_bDisabled: usize = 0x700; // bool
}

pub mod CFuncWall {
    pub const m_nState: usize = 0x700; // int32_t
}

pub mod CFuncWater {
    pub const m_BuoyancyHelper: usize = 0x700; // CBuoyancyHelper
}

pub mod CGameChoreoServices {
    pub const m_hOwner: usize = 0x8; // CHandle<CBaseAnimGraph>
    pub const m_hScriptedSequence: usize = 0xC; // CHandle<CScriptedSequence>
    pub const m_scriptState: usize = 0x10; // IChoreoServices::ScriptState_t
    pub const m_choreoState: usize = 0x14; // IChoreoServices::ChoreoState_t
    pub const m_flTimeStartedState: usize = 0x18; // GameTime_t
}

pub mod CGameGibManager {
    pub const m_bAllowNewGibs: usize = 0x4D0; // bool
    pub const m_iCurrentMaxPieces: usize = 0x4D4; // int32_t
    pub const m_iMaxPieces: usize = 0x4D8; // int32_t
    pub const m_iLastFrame: usize = 0x4DC; // int32_t
}

pub mod CGameMoney {
    pub const m_OnMoneySpent: usize = 0x710; // CEntityIOOutput
    pub const m_OnMoneySpentFail: usize = 0x738; // CEntityIOOutput
    pub const m_nMoney: usize = 0x760; // int32_t
    pub const m_strAwardText: usize = 0x768; // CUtlString
}

pub mod CGamePlayerZone {
    pub const m_OnPlayerInZone: usize = 0x708; // CEntityIOOutput
    pub const m_OnPlayerOutZone: usize = 0x730; // CEntityIOOutput
    pub const m_PlayersInCount: usize = 0x758; // CEntityOutputTemplate<int32_t>
    pub const m_PlayersOutCount: usize = 0x780; // CEntityOutputTemplate<int32_t>
}

pub mod CGameRules {
    pub const m_szQuestName: usize = 0x8; // char[128]
    pub const m_nQuestPhase: usize = 0x88; // int32_t
}

pub mod CGameSceneNode {
    pub const m_nodeToWorld: usize = 0x10; // CTransform
    pub const m_pOwner: usize = 0x30; // CEntityInstance*
    pub const m_pParent: usize = 0x38; // CGameSceneNode*
    pub const m_pChild: usize = 0x40; // CGameSceneNode*
    pub const m_pNextSibling: usize = 0x48; // CGameSceneNode*
    pub const m_hParent: usize = 0x70; // CGameSceneNodeHandle
    pub const m_vecOrigin: usize = 0x80; // CNetworkOriginCellCoordQuantizedVector
    pub const m_angRotation: usize = 0xB8; // QAngle
    pub const m_flScale: usize = 0xC4; // float
    pub const m_vecAbsOrigin: usize = 0xC8; // Vector
    pub const m_angAbsRotation: usize = 0xD4; // QAngle
    pub const m_flAbsScale: usize = 0xE0; // float
    pub const m_nParentAttachmentOrBone: usize = 0xE4; // int16_t
    pub const m_bDebugAbsOriginChanges: usize = 0xE6; // bool
    pub const m_bDormant: usize = 0xE7; // bool
    pub const m_bForceParentToBeNetworked: usize = 0xE8; // bool
    pub const m_bDirtyHierarchy: usize = 0x0; // bitfield:1
    pub const m_bDirtyBoneMergeInfo: usize = 0x0; // bitfield:1
    pub const m_bNetworkedPositionChanged: usize = 0x0; // bitfield:1
    pub const m_bNetworkedAnglesChanged: usize = 0x0; // bitfield:1
    pub const m_bNetworkedScaleChanged: usize = 0x0; // bitfield:1
    pub const m_bWillBeCallingPostDataUpdate: usize = 0x0; // bitfield:1
    pub const m_bNotifyBoneTransformsChanged: usize = 0x0; // bitfield:1
    pub const m_bBoneMergeFlex: usize = 0x0; // bitfield:1
    pub const m_nLatchAbsOrigin: usize = 0x0; // bitfield:2
    pub const m_bDirtyBoneMergeBoneToRoot: usize = 0x0; // bitfield:1
    pub const m_nHierarchicalDepth: usize = 0xEB; // uint8_t
    pub const m_nHierarchyType: usize = 0xEC; // uint8_t
    pub const m_nDoNotSetAnimTimeInInvalidatePhysicsCount: usize = 0xED; // uint8_t
    pub const m_name: usize = 0xF0; // CUtlStringToken
    pub const m_hierarchyAttachName: usize = 0x130; // CUtlStringToken
    pub const m_flZOffset: usize = 0x134; // float
    pub const m_vRenderOrigin: usize = 0x138; // Vector
}

pub mod CGameSceneNodeHandle {
    pub const m_hOwner: usize = 0x8; // CEntityHandle
    pub const m_name: usize = 0xC; // CUtlStringToken
}

pub mod CGameScriptedMoveData {
    pub const m_vDest: usize = 0x0; // Vector
    pub const m_vSrc: usize = 0xC; // Vector
    pub const m_angSrc: usize = 0x18; // QAngle
    pub const m_angDst: usize = 0x24; // QAngle
    pub const m_angCurrent: usize = 0x30; // QAngle
    pub const m_flAngRate: usize = 0x3C; // float
    pub const m_flDuration: usize = 0x40; // float
    pub const m_flStartTime: usize = 0x44; // GameTime_t
    pub const m_nPrevMoveType: usize = 0x48; // MoveType_t
    pub const m_bActive: usize = 0x49; // bool
    pub const m_bTeleportOnEnd: usize = 0x4A; // bool
    pub const m_bEndOnDestinationReached: usize = 0x4B; // bool
    pub const m_bIgnoreRotation: usize = 0x4C; // bool
    pub const m_nType: usize = 0x50; // ScriptedMoveType_t
    pub const m_bSuccess: usize = 0x54; // bool
    pub const m_nForcedCrouchState: usize = 0x58; // ForcedCrouchState_t
    pub const m_bIgnoreCollisions: usize = 0x5C; // bool
}

pub mod CGameText {
    pub const m_iszMessage: usize = 0x710; // CUtlSymbolLarge
    pub const m_textParms: usize = 0x718; // hudtextparms_t
}

pub mod CGenericConstraint {
    pub const m_nLinearMotionX: usize = 0x510; // JointMotion_t
    pub const m_nLinearMotionY: usize = 0x514; // JointMotion_t
    pub const m_nLinearMotionZ: usize = 0x518; // JointMotion_t
    pub const m_flLinearFrequencyX: usize = 0x51C; // float
    pub const m_flLinearFrequencyY: usize = 0x520; // float
    pub const m_flLinearFrequencyZ: usize = 0x524; // float
    pub const m_flLinearDampingRatioX: usize = 0x528; // float
    pub const m_flLinearDampingRatioY: usize = 0x52C; // float
    pub const m_flLinearDampingRatioZ: usize = 0x530; // float
    pub const m_flMaxLinearImpulseX: usize = 0x534; // float
    pub const m_flMaxLinearImpulseY: usize = 0x538; // float
    pub const m_flMaxLinearImpulseZ: usize = 0x53C; // float
    pub const m_flBreakAfterTimeX: usize = 0x540; // float
    pub const m_flBreakAfterTimeY: usize = 0x544; // float
    pub const m_flBreakAfterTimeZ: usize = 0x548; // float
    pub const m_flBreakAfterTimeStartTimeX: usize = 0x54C; // GameTime_t
    pub const m_flBreakAfterTimeStartTimeY: usize = 0x550; // GameTime_t
    pub const m_flBreakAfterTimeStartTimeZ: usize = 0x554; // GameTime_t
    pub const m_flBreakAfterTimeThresholdX: usize = 0x558; // float
    pub const m_flBreakAfterTimeThresholdY: usize = 0x55C; // float
    pub const m_flBreakAfterTimeThresholdZ: usize = 0x560; // float
    pub const m_flNotifyForceX: usize = 0x564; // float
    pub const m_flNotifyForceY: usize = 0x568; // float
    pub const m_flNotifyForceZ: usize = 0x56C; // float
    pub const m_flNotifyForceMinTimeX: usize = 0x570; // float
    pub const m_flNotifyForceMinTimeY: usize = 0x574; // float
    pub const m_flNotifyForceMinTimeZ: usize = 0x578; // float
    pub const m_flNotifyForceLastTimeX: usize = 0x57C; // GameTime_t
    pub const m_flNotifyForceLastTimeY: usize = 0x580; // GameTime_t
    pub const m_flNotifyForceLastTimeZ: usize = 0x584; // GameTime_t
    pub const m_bAxisNotifiedX: usize = 0x588; // bool
    pub const m_bAxisNotifiedY: usize = 0x589; // bool
    pub const m_bAxisNotifiedZ: usize = 0x58A; // bool
    pub const m_nAngularMotionX: usize = 0x58C; // JointMotion_t
    pub const m_nAngularMotionY: usize = 0x590; // JointMotion_t
    pub const m_nAngularMotionZ: usize = 0x594; // JointMotion_t
    pub const m_flAngularFrequencyX: usize = 0x598; // float
    pub const m_flAngularFrequencyY: usize = 0x59C; // float
    pub const m_flAngularFrequencyZ: usize = 0x5A0; // float
    pub const m_flAngularDampingRatioX: usize = 0x5A4; // float
    pub const m_flAngularDampingRatioY: usize = 0x5A8; // float
    pub const m_flAngularDampingRatioZ: usize = 0x5AC; // float
    pub const m_flMaxAngularImpulseX: usize = 0x5B0; // float
    pub const m_flMaxAngularImpulseY: usize = 0x5B4; // float
    pub const m_flMaxAngularImpulseZ: usize = 0x5B8; // float
    pub const m_NotifyForceReachedX: usize = 0x5C0; // CEntityIOOutput
    pub const m_NotifyForceReachedY: usize = 0x5E8; // CEntityIOOutput
    pub const m_NotifyForceReachedZ: usize = 0x610; // CEntityIOOutput
}

pub mod CGlowProperty {
    pub const m_fGlowColor: usize = 0x8; // Vector
    pub const m_iGlowType: usize = 0x30; // int32_t
    pub const m_iGlowTeam: usize = 0x34; // int32_t
    pub const m_nGlowRange: usize = 0x38; // int32_t
    pub const m_nGlowRangeMin: usize = 0x3C; // int32_t
    pub const m_glowColorOverride: usize = 0x40; // Color
    pub const m_bFlashing: usize = 0x44; // bool
    pub const m_flGlowTime: usize = 0x48; // float
    pub const m_flGlowStartTime: usize = 0x4C; // float
    pub const m_bEligibleForScreenHighlight: usize = 0x50; // bool
    pub const m_bGlowing: usize = 0x51; // bool
}

pub mod CGradientFog {
    pub const m_hGradientFogTexture: usize = 0x4B0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_flFogStartDistance: usize = 0x4B8; // float
    pub const m_flFogEndDistance: usize = 0x4BC; // float
    pub const m_bHeightFogEnabled: usize = 0x4C0; // bool
    pub const m_flFogStartHeight: usize = 0x4C4; // float
    pub const m_flFogEndHeight: usize = 0x4C8; // float
    pub const m_flFarZ: usize = 0x4CC; // float
    pub const m_flFogMaxOpacity: usize = 0x4D0; // float
    pub const m_flFogFalloffExponent: usize = 0x4D4; // float
    pub const m_flFogVerticalExponent: usize = 0x4D8; // float
    pub const m_fogColor: usize = 0x4DC; // Color
    pub const m_flFogStrength: usize = 0x4E0; // float
    pub const m_flFadeTime: usize = 0x4E4; // float
    pub const m_bStartDisabled: usize = 0x4E8; // bool
    pub const m_bIsEnabled: usize = 0x4E9; // bool
    pub const m_bGradientFogNeedsTextures: usize = 0x4EA; // bool
}

pub mod CGunTarget {
    pub const m_on: usize = 0x780; // bool
    pub const m_hTargetEnt: usize = 0x784; // CHandle<CBaseEntity>
    pub const m_OnDeath: usize = 0x788; // CEntityIOOutput
}

pub mod CHandleTest {
    pub const m_Handle: usize = 0x4B0; // CHandle<CBaseEntity>
    pub const m_bSendHandle: usize = 0x4B4; // bool
}

pub mod CHintMessage {
    pub const m_hintString: usize = 0x8; // char*
    pub const m_args: usize = 0x10; // CUtlVector<char*>
    pub const m_duration: usize = 0x28; // float
}

pub mod CHintMessageQueue {
    pub const m_tmMessageEnd: usize = 0x8; // float
    pub const m_messages: usize = 0x10; // CUtlVector<CHintMessage*>
    pub const m_pPlayerController: usize = 0x28; // CBasePlayerController*
}

pub mod CHitboxComponent {
    pub const m_bvDisabledHitGroups: usize = 0x24; // uint32_t[1]
}

pub mod CHostage {
    pub const m_OnHostageBeginGrab: usize = 0x9E8; // CEntityIOOutput
    pub const m_OnFirstPickedUp: usize = 0xA10; // CEntityIOOutput
    pub const m_OnDroppedNotRescued: usize = 0xA38; // CEntityIOOutput
    pub const m_OnRescued: usize = 0xA60; // CEntityIOOutput
    pub const m_entitySpottedState: usize = 0xA88; // EntitySpottedState_t
    pub const m_nSpotRules: usize = 0xAA0; // int32_t
    pub const m_uiHostageSpawnExclusionGroupMask: usize = 0xAA4; // uint32_t
    pub const m_nHostageSpawnRandomFactor: usize = 0xAA8; // uint32_t
    pub const m_bRemove: usize = 0xAAC; // bool
    pub const m_vel: usize = 0xAB0; // Vector
    pub const m_isRescued: usize = 0xABC; // bool
    pub const m_jumpedThisFrame: usize = 0xABD; // bool
    pub const m_nHostageState: usize = 0xAC0; // int32_t
    pub const m_leader: usize = 0xAC4; // CHandle<CBaseEntity>
    pub const m_lastLeader: usize = 0xAC8; // CHandle<CCSPlayerPawnBase>
    pub const m_reuseTimer: usize = 0xAD0; // CountdownTimer
    pub const m_hasBeenUsed: usize = 0xAE8; // bool
    pub const m_accel: usize = 0xAEC; // Vector
    pub const m_isRunning: usize = 0xAF8; // bool
    pub const m_isCrouching: usize = 0xAF9; // bool
    pub const m_jumpTimer: usize = 0xB00; // CountdownTimer
    pub const m_isWaitingForLeader: usize = 0xB18; // bool
    pub const m_repathTimer: usize = 0x2B28; // CountdownTimer
    pub const m_inhibitDoorTimer: usize = 0x2B40; // CountdownTimer
    pub const m_inhibitObstacleAvoidanceTimer: usize = 0x2BD0; // CountdownTimer
    pub const m_wiggleTimer: usize = 0x2BF0; // CountdownTimer
    pub const m_isAdjusted: usize = 0x2C0C; // bool
    pub const m_bHandsHaveBeenCut: usize = 0x2C0D; // bool
    pub const m_hHostageGrabber: usize = 0x2C10; // CHandle<CCSPlayerPawn>
    pub const m_fLastGrabTime: usize = 0x2C14; // GameTime_t
    pub const m_vecPositionWhenStartedDroppingToGround: usize = 0x2C18; // Vector
    pub const m_vecGrabbedPos: usize = 0x2C24; // Vector
    pub const m_flRescueStartTime: usize = 0x2C30; // GameTime_t
    pub const m_flGrabSuccessTime: usize = 0x2C34; // GameTime_t
    pub const m_flDropStartTime: usize = 0x2C38; // GameTime_t
    pub const m_nApproachRewardPayouts: usize = 0x2C3C; // int32_t
    pub const m_nPickupEventCount: usize = 0x2C40; // int32_t
    pub const m_vecSpawnGroundPos: usize = 0x2C44; // Vector
    pub const m_vecHostageResetPosition: usize = 0x2C64; // Vector
}

pub mod CHostageExpresserShim {
    pub const m_pExpresser: usize = 0x9D0; // CAI_Expresser*
}

pub mod CInButtonState {
    pub const m_pButtonStates: usize = 0x8; // uint64_t[3]
}

pub mod CInferno {
    pub const m_firePositions: usize = 0x710; // Vector[64]
    pub const m_fireParentPositions: usize = 0xA10; // Vector[64]
    pub const m_bFireIsBurning: usize = 0xD10; // bool[64]
    pub const m_BurnNormal: usize = 0xD50; // Vector[64]
    pub const m_fireCount: usize = 0x1050; // int32_t
    pub const m_nInfernoType: usize = 0x1054; // int32_t
    pub const m_nFireEffectTickBegin: usize = 0x1058; // int32_t
    pub const m_nFireLifetime: usize = 0x105C; // float
    pub const m_bInPostEffectTime: usize = 0x1060; // bool
    pub const m_nFiresExtinguishCount: usize = 0x1064; // int32_t
    pub const m_bWasCreatedInSmoke: usize = 0x1068; // bool
    pub const m_extent: usize = 0x1270; // Extent
    pub const m_damageTimer: usize = 0x1288; // CountdownTimer
    pub const m_damageRampTimer: usize = 0x12A0; // CountdownTimer
    pub const m_splashVelocity: usize = 0x12B8; // Vector
    pub const m_InitialSplashVelocity: usize = 0x12C4; // Vector
    pub const m_startPos: usize = 0x12D0; // Vector
    pub const m_vecOriginalSpawnLocation: usize = 0x12DC; // Vector
    pub const m_activeTimer: usize = 0x12E8; // IntervalTimer
    pub const m_fireSpawnOffset: usize = 0x12F8; // int32_t
    pub const m_nMaxFlames: usize = 0x12FC; // int32_t
    pub const m_BookkeepingTimer: usize = 0x1300; // CountdownTimer
    pub const m_NextSpreadTimer: usize = 0x1318; // CountdownTimer
    pub const m_nSourceItemDefIndex: usize = 0x1330; // uint16_t
}

pub mod CInfoDynamicShadowHint {
    pub const m_bDisabled: usize = 0x4B0; // bool
    pub const m_flRange: usize = 0x4B4; // float
    pub const m_nImportance: usize = 0x4B8; // int32_t
    pub const m_nLightChoice: usize = 0x4BC; // int32_t
    pub const m_hLight: usize = 0x4C0; // CHandle<CBaseEntity>
}

pub mod CInfoDynamicShadowHintBox {
    pub const m_vBoxMins: usize = 0x4C8; // Vector
    pub const m_vBoxMaxs: usize = 0x4D4; // Vector
}

pub mod CInfoGameEventProxy {
    pub const m_iszEventName: usize = 0x4B0; // CUtlSymbolLarge
    pub const m_flRange: usize = 0x4B8; // float
}

pub mod CInfoOffscreenPanoramaTexture {
    pub const m_bDisabled: usize = 0x4B0; // bool
    pub const m_nResolutionX: usize = 0x4B4; // int32_t
    pub const m_nResolutionY: usize = 0x4B8; // int32_t
    pub const m_szLayoutFileName: usize = 0x4C0; // CUtlSymbolLarge
    pub const m_RenderAttrName: usize = 0x4C8; // CUtlSymbolLarge
    pub const m_TargetEntities: usize = 0x4D0; // CNetworkUtlVectorBase<CHandle<CBaseModelEntity>>
    pub const m_nTargetChangeCount: usize = 0x4E8; // int32_t
    pub const m_vecCSSClasses: usize = 0x4F0; // CNetworkUtlVectorBase<CUtlSymbolLarge>
    pub const m_szTargetsName: usize = 0x508; // CUtlSymbolLarge
    pub const m_AdditionalTargetEntities: usize = 0x510; // CUtlVector<CHandle<CBaseModelEntity>>
}

pub mod CInfoPlayerStart {
    pub const m_bDisabled: usize = 0x4B0; // bool
}

pub mod CInfoSpawnGroupLoadUnload {
    pub const m_OnSpawnGroupLoadStarted: usize = 0x4B0; // CEntityIOOutput
    pub const m_OnSpawnGroupLoadFinished: usize = 0x4D8; // CEntityIOOutput
    pub const m_OnSpawnGroupUnloadStarted: usize = 0x500; // CEntityIOOutput
    pub const m_OnSpawnGroupUnloadFinished: usize = 0x528; // CEntityIOOutput
    pub const m_iszSpawnGroupName: usize = 0x550; // CUtlSymbolLarge
    pub const m_iszSpawnGroupFilterName: usize = 0x558; // CUtlSymbolLarge
    pub const m_iszLandmarkName: usize = 0x560; // CUtlSymbolLarge
    pub const m_sFixedSpawnGroupName: usize = 0x568; // CUtlString
    pub const m_flTimeoutInterval: usize = 0x570; // float
    pub const m_bStreamingStarted: usize = 0x574; // bool
    pub const m_bUnloadingStarted: usize = 0x575; // bool
}

pub mod CInfoVisibilityBox {
    pub const m_nMode: usize = 0x4B4; // int32_t
    pub const m_vBoxSize: usize = 0x4B8; // Vector
    pub const m_bEnabled: usize = 0x4C4; // bool
}

pub mod CInfoWorldLayer {
    pub const m_pOutputOnEntitiesSpawned: usize = 0x4B0; // CEntityIOOutput
    pub const m_worldName: usize = 0x4D8; // CUtlSymbolLarge
    pub const m_layerName: usize = 0x4E0; // CUtlSymbolLarge
    pub const m_bWorldLayerVisible: usize = 0x4E8; // bool
    pub const m_bEntitiesSpawned: usize = 0x4E9; // bool
    pub const m_bCreateAsChildSpawnGroup: usize = 0x4EA; // bool
    pub const m_hLayerSpawnGroup: usize = 0x4EC; // uint32_t
}

pub mod CInstancedSceneEntity {
    pub const m_hOwner: usize = 0xA08; // CHandle<CBaseEntity>
    pub const m_bHadOwner: usize = 0xA0C; // bool
    pub const m_flPostSpeakDelay: usize = 0xA10; // float
    pub const m_flPreDelay: usize = 0xA14; // float
    pub const m_bIsBackground: usize = 0xA18; // bool
}

pub mod CInstructorEventEntity {
    pub const m_iszName: usize = 0x4B0; // CUtlSymbolLarge
    pub const m_iszHintTargetEntity: usize = 0x4B8; // CUtlSymbolLarge
    pub const m_hTargetPlayer: usize = 0x4C0; // CHandle<CBasePlayerPawn>
}

pub mod CIronSightController {
    pub const m_bIronSightAvailable: usize = 0x8; // bool
    pub const m_flIronSightAmount: usize = 0xC; // float
    pub const m_flIronSightAmountGained: usize = 0x10; // float
    pub const m_flIronSightAmountBiased: usize = 0x14; // float
}

pub mod CItem {
    pub const m_OnPlayerTouch: usize = 0x898; // CEntityIOOutput
    pub const m_bActivateWhenAtRest: usize = 0x8C0; // bool
    pub const m_OnCacheInteraction: usize = 0x8C8; // CEntityIOOutput
    pub const m_OnPlayerPickup: usize = 0x8F0; // CEntityIOOutput
    pub const m_OnGlovePulled: usize = 0x918; // CEntityIOOutput
    pub const m_vOriginalSpawnOrigin: usize = 0x940; // Vector
    pub const m_vOriginalSpawnAngles: usize = 0x94C; // QAngle
    pub const m_bPhysStartAsleep: usize = 0x958; // bool
}

pub mod CItemDefuser {
    pub const m_entitySpottedState: usize = 0x968; // EntitySpottedState_t
    pub const m_nSpotRules: usize = 0x980; // int32_t
}

pub mod CItemDogtags {
    pub const m_OwningPlayer: usize = 0x968; // CHandle<CCSPlayerPawn>
    pub const m_KillingPlayer: usize = 0x96C; // CHandle<CCSPlayerPawn>
}

pub mod CItemGeneric {
    pub const m_bHasTriggerRadius: usize = 0x970; // bool
    pub const m_bHasPickupRadius: usize = 0x971; // bool
    pub const m_flPickupRadiusSqr: usize = 0x974; // float
    pub const m_flTriggerRadiusSqr: usize = 0x978; // float
    pub const m_flLastPickupCheck: usize = 0x97C; // GameTime_t
    pub const m_bPlayerCounterListenerAdded: usize = 0x980; // bool
    pub const m_bPlayerInTriggerRadius: usize = 0x981; // bool
    pub const m_hSpawnParticleEffect: usize = 0x988; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    pub const m_pAmbientSoundEffect: usize = 0x990; // CUtlSymbolLarge
    pub const m_bAutoStartAmbientSound: usize = 0x998; // bool
    pub const m_pSpawnScriptFunction: usize = 0x9A0; // CUtlSymbolLarge
    pub const m_hPickupParticleEffect: usize = 0x9A8; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    pub const m_pPickupSoundEffect: usize = 0x9B0; // CUtlSymbolLarge
    pub const m_pPickupScriptFunction: usize = 0x9B8; // CUtlSymbolLarge
    pub const m_hTimeoutParticleEffect: usize = 0x9C0; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    pub const m_pTimeoutSoundEffect: usize = 0x9C8; // CUtlSymbolLarge
    pub const m_pTimeoutScriptFunction: usize = 0x9D0; // CUtlSymbolLarge
    pub const m_pPickupFilterName: usize = 0x9D8; // CUtlSymbolLarge
    pub const m_hPickupFilter: usize = 0x9E0; // CHandle<CBaseFilter>
    pub const m_OnPickup: usize = 0x9E8; // CEntityIOOutput
    pub const m_OnTimeout: usize = 0xA10; // CEntityIOOutput
    pub const m_OnTriggerStartTouch: usize = 0xA38; // CEntityIOOutput
    pub const m_OnTriggerTouch: usize = 0xA60; // CEntityIOOutput
    pub const m_OnTriggerEndTouch: usize = 0xA88; // CEntityIOOutput
    pub const m_pAllowPickupScriptFunction: usize = 0xAB0; // CUtlSymbolLarge
    pub const m_flPickupRadius: usize = 0xAB8; // float
    pub const m_flTriggerRadius: usize = 0xABC; // float
    pub const m_pTriggerSoundEffect: usize = 0xAC0; // CUtlSymbolLarge
    pub const m_bGlowWhenInTrigger: usize = 0xAC8; // bool
    pub const m_glowColor: usize = 0xAC9; // Color
    pub const m_bUseable: usize = 0xACD; // bool
    pub const m_hTriggerHelper: usize = 0xAD0; // CHandle<CItemGenericTriggerHelper>
}

pub mod CItemGenericTriggerHelper {
    pub const m_hParentItem: usize = 0x700; // CHandle<CItemGeneric>
}

pub mod CKeepUpright {
    pub const m_worldGoalAxis: usize = 0x4B8; // Vector
    pub const m_localTestAxis: usize = 0x4C4; // Vector
    pub const m_nameAttach: usize = 0x4D8; // CUtlSymbolLarge
    pub const m_attachedObject: usize = 0x4E0; // CHandle<CBaseEntity>
    pub const m_angularLimit: usize = 0x4E4; // float
    pub const m_bActive: usize = 0x4E8; // bool
    pub const m_bDampAllRotation: usize = 0x4E9; // bool
}

pub mod CKnife {
    pub const m_bFirstAttack: usize = 0xE20; // bool
}

pub mod CLightComponent {
    pub const __m_pChainEntity: usize = 0x48; // CNetworkVarChainer
    pub const m_Color: usize = 0x85; // Color
    pub const m_SecondaryColor: usize = 0x89; // Color
    pub const m_flBrightness: usize = 0x90; // float
    pub const m_flBrightnessScale: usize = 0x94; // float
    pub const m_flBrightnessMult: usize = 0x98; // float
    pub const m_flRange: usize = 0x9C; // float
    pub const m_flFalloff: usize = 0xA0; // float
    pub const m_flAttenuation0: usize = 0xA4; // float
    pub const m_flAttenuation1: usize = 0xA8; // float
    pub const m_flAttenuation2: usize = 0xAC; // float
    pub const m_flTheta: usize = 0xB0; // float
    pub const m_flPhi: usize = 0xB4; // float
    pub const m_hLightCookie: usize = 0xB8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_nCascades: usize = 0xC0; // int32_t
    pub const m_nCastShadows: usize = 0xC4; // int32_t
    pub const m_nShadowWidth: usize = 0xC8; // int32_t
    pub const m_nShadowHeight: usize = 0xCC; // int32_t
    pub const m_bRenderDiffuse: usize = 0xD0; // bool
    pub const m_nRenderSpecular: usize = 0xD4; // int32_t
    pub const m_bRenderTransmissive: usize = 0xD8; // bool
    pub const m_flOrthoLightWidth: usize = 0xDC; // float
    pub const m_flOrthoLightHeight: usize = 0xE0; // float
    pub const m_nStyle: usize = 0xE4; // int32_t
    pub const m_Pattern: usize = 0xE8; // CUtlString
    pub const m_nCascadeRenderStaticObjects: usize = 0xF0; // int32_t
    pub const m_flShadowCascadeCrossFade: usize = 0xF4; // float
    pub const m_flShadowCascadeDistanceFade: usize = 0xF8; // float
    pub const m_flShadowCascadeDistance0: usize = 0xFC; // float
    pub const m_flShadowCascadeDistance1: usize = 0x100; // float
    pub const m_flShadowCascadeDistance2: usize = 0x104; // float
    pub const m_flShadowCascadeDistance3: usize = 0x108; // float
    pub const m_nShadowCascadeResolution0: usize = 0x10C; // int32_t
    pub const m_nShadowCascadeResolution1: usize = 0x110; // int32_t
    pub const m_nShadowCascadeResolution2: usize = 0x114; // int32_t
    pub const m_nShadowCascadeResolution3: usize = 0x118; // int32_t
    pub const m_bUsesBakedShadowing: usize = 0x11C; // bool
    pub const m_nShadowPriority: usize = 0x120; // int32_t
    pub const m_nBakedShadowIndex: usize = 0x124; // int32_t
    pub const m_bRenderToCubemaps: usize = 0x128; // bool
    pub const m_nDirectLight: usize = 0x12C; // int32_t
    pub const m_nIndirectLight: usize = 0x130; // int32_t
    pub const m_flFadeMinDist: usize = 0x134; // float
    pub const m_flFadeMaxDist: usize = 0x138; // float
    pub const m_flShadowFadeMinDist: usize = 0x13C; // float
    pub const m_flShadowFadeMaxDist: usize = 0x140; // float
    pub const m_bEnabled: usize = 0x144; // bool
    pub const m_bFlicker: usize = 0x145; // bool
    pub const m_bPrecomputedFieldsValid: usize = 0x146; // bool
    pub const m_vPrecomputedBoundsMins: usize = 0x148; // Vector
    pub const m_vPrecomputedBoundsMaxs: usize = 0x154; // Vector
    pub const m_vPrecomputedOBBOrigin: usize = 0x160; // Vector
    pub const m_vPrecomputedOBBAngles: usize = 0x16C; // QAngle
    pub const m_vPrecomputedOBBExtent: usize = 0x178; // Vector
    pub const m_flPrecomputedMaxRange: usize = 0x184; // float
    pub const m_nFogLightingMode: usize = 0x188; // int32_t
    pub const m_flFogContributionStength: usize = 0x18C; // float
    pub const m_flNearClipPlane: usize = 0x190; // float
    pub const m_SkyColor: usize = 0x194; // Color
    pub const m_flSkyIntensity: usize = 0x198; // float
    pub const m_SkyAmbientBounce: usize = 0x19C; // Color
    pub const m_bUseSecondaryColor: usize = 0x1A0; // bool
    pub const m_bMixedShadows: usize = 0x1A1; // bool
    pub const m_flLightStyleStartTime: usize = 0x1A4; // GameTime_t
    pub const m_flCapsuleLength: usize = 0x1A8; // float
    pub const m_flMinRoughness: usize = 0x1AC; // float
    pub const m_bPvsModifyEntity: usize = 0x1C0; // bool
}

pub mod CLightEntity {
    pub const m_CLightComponent: usize = 0x700; // CLightComponent*
}

pub mod CLightGlow {
    pub const m_nHorizontalSize: usize = 0x700; // uint32_t
    pub const m_nVerticalSize: usize = 0x704; // uint32_t
    pub const m_nMinDist: usize = 0x708; // uint32_t
    pub const m_nMaxDist: usize = 0x70C; // uint32_t
    pub const m_nOuterMaxDist: usize = 0x710; // uint32_t
    pub const m_flGlowProxySize: usize = 0x714; // float
    pub const m_flHDRColorScale: usize = 0x718; // float
}

pub mod CLogicAchievement {
    pub const m_bDisabled: usize = 0x4B0; // bool
    pub const m_iszAchievementEventID: usize = 0x4B8; // CUtlSymbolLarge
    pub const m_OnFired: usize = 0x4C0; // CEntityIOOutput
}

pub mod CLogicActiveAutosave {
    pub const m_TriggerHitPoints: usize = 0x4C0; // int32_t
    pub const m_flTimeToTrigger: usize = 0x4C4; // float
    pub const m_flStartTime: usize = 0x4C8; // GameTime_t
    pub const m_flDangerousTime: usize = 0x4CC; // float
}

pub mod CLogicAuto {
    pub const m_OnMapSpawn: usize = 0x4B0; // CEntityIOOutput
    pub const m_OnDemoMapSpawn: usize = 0x4D8; // CEntityIOOutput
    pub const m_OnNewGame: usize = 0x500; // CEntityIOOutput
    pub const m_OnLoadGame: usize = 0x528; // CEntityIOOutput
    pub const m_OnMapTransition: usize = 0x550; // CEntityIOOutput
    pub const m_OnBackgroundMap: usize = 0x578; // CEntityIOOutput
    pub const m_OnMultiNewMap: usize = 0x5A0; // CEntityIOOutput
    pub const m_OnMultiNewRound: usize = 0x5C8; // CEntityIOOutput
    pub const m_OnVREnabled: usize = 0x5F0; // CEntityIOOutput
    pub const m_OnVRNotEnabled: usize = 0x618; // CEntityIOOutput
    pub const m_globalstate: usize = 0x640; // CUtlSymbolLarge
}

pub mod CLogicAutosave {
    pub const m_bForceNewLevelUnit: usize = 0x4B0; // bool
    pub const m_minHitPoints: usize = 0x4B4; // int32_t
    pub const m_minHitPointsToCommit: usize = 0x4B8; // int32_t
}

pub mod CLogicBranch {
    pub const m_bInValue: usize = 0x4B0; // bool
    pub const m_Listeners: usize = 0x4B8; // CUtlVector<CHandle<CBaseEntity>>
    pub const m_OnTrue: usize = 0x4D0; // CEntityIOOutput
    pub const m_OnFalse: usize = 0x4F8; // CEntityIOOutput
}

pub mod CLogicBranchList {
    pub const m_nLogicBranchNames: usize = 0x4B0; // CUtlSymbolLarge[16]
    pub const m_LogicBranchList: usize = 0x530; // CUtlVector<CHandle<CBaseEntity>>
    pub const m_eLastState: usize = 0x548; // CLogicBranchList::LogicBranchListenerLastState_t
    pub const m_OnAllTrue: usize = 0x550; // CEntityIOOutput
    pub const m_OnAllFalse: usize = 0x578; // CEntityIOOutput
    pub const m_OnMixed: usize = 0x5A0; // CEntityIOOutput
}

pub mod CLogicCase {
    pub const m_nCase: usize = 0x4B0; // CUtlSymbolLarge[32]
    pub const m_nShuffleCases: usize = 0x5B0; // int32_t
    pub const m_nLastShuffleCase: usize = 0x5B4; // int32_t
    pub const m_uchShuffleCaseMap: usize = 0x5B8; // uint8_t[32]
    pub const m_OnCase: usize = 0x5D8; // CEntityIOOutput[32]
    pub const m_OnDefault: usize = 0xAD8; // CEntityOutputTemplate<CVariantBase<CVariantDefaultAllocator>>
}

pub mod CLogicCollisionPair {
    pub const m_nameAttach1: usize = 0x4B0; // CUtlSymbolLarge
    pub const m_nameAttach2: usize = 0x4B8; // CUtlSymbolLarge
    pub const m_disabled: usize = 0x4C0; // bool
    pub const m_succeeded: usize = 0x4C1; // bool
}

pub mod CLogicCompare {
    pub const m_flInValue: usize = 0x4B0; // float
    pub const m_flCompareValue: usize = 0x4B4; // float
    pub const m_OnLessThan: usize = 0x4B8; // CEntityOutputTemplate<float>
    pub const m_OnEqualTo: usize = 0x4E0; // CEntityOutputTemplate<float>
    pub const m_OnNotEqualTo: usize = 0x508; // CEntityOutputTemplate<float>
    pub const m_OnGreaterThan: usize = 0x530; // CEntityOutputTemplate<float>
}

pub mod CLogicDistanceAutosave {
    pub const m_iszTargetEntity: usize = 0x4B0; // CUtlSymbolLarge
    pub const m_flDistanceToPlayer: usize = 0x4B8; // float
    pub const m_bForceNewLevelUnit: usize = 0x4BC; // bool
    pub const m_bCheckCough: usize = 0x4BD; // bool
    pub const m_bThinkDangerous: usize = 0x4BE; // bool
    pub const m_flDangerousTime: usize = 0x4C0; // float
}

pub mod CLogicDistanceCheck {
    pub const m_iszEntityA: usize = 0x4B0; // CUtlSymbolLarge
    pub const m_iszEntityB: usize = 0x4B8; // CUtlSymbolLarge
    pub const m_flZone1Distance: usize = 0x4C0; // float
    pub const m_flZone2Distance: usize = 0x4C4; // float
    pub const m_InZone1: usize = 0x4C8; // CEntityIOOutput
    pub const m_InZone2: usize = 0x4F0; // CEntityIOOutput
    pub const m_InZone3: usize = 0x518; // CEntityIOOutput
}

pub mod CLogicEventListener {
    pub const m_strEventName: usize = 0x4C0; // CUtlString
    pub const m_bIsEnabled: usize = 0x4C8; // bool
    pub const m_nTeam: usize = 0x4CC; // int32_t
    pub const m_OnEventFired: usize = 0x4D0; // CEntityIOOutput
}

pub mod CLogicGameEvent {
    pub const m_iszEventName: usize = 0x4B0; // CUtlSymbolLarge
}

pub mod CLogicGameEventListener {
    pub const m_OnEventFired: usize = 0x4C0; // CEntityIOOutput
    pub const m_iszGameEventName: usize = 0x4E8; // CUtlSymbolLarge
    pub const m_iszGameEventItem: usize = 0x4F0; // CUtlSymbolLarge
    pub const m_bEnabled: usize = 0x4F8; // bool
    pub const m_bStartDisabled: usize = 0x4F9; // bool
}

pub mod CLogicLineToEntity {
    pub const m_Line: usize = 0x4B0; // CEntityOutputTemplate<Vector>
    pub const m_SourceName: usize = 0x4D8; // CUtlSymbolLarge
    pub const m_StartEntity: usize = 0x4E0; // CHandle<CBaseEntity>
    pub const m_EndEntity: usize = 0x4E4; // CHandle<CBaseEntity>
}

pub mod CLogicMeasureMovement {
    pub const m_strMeasureTarget: usize = 0x4B0; // CUtlSymbolLarge
    pub const m_strMeasureReference: usize = 0x4B8; // CUtlSymbolLarge
    pub const m_strTargetReference: usize = 0x4C0; // CUtlSymbolLarge
    pub const m_hMeasureTarget: usize = 0x4C8; // CHandle<CBaseEntity>
    pub const m_hMeasureReference: usize = 0x4CC; // CHandle<CBaseEntity>
    pub const m_hTarget: usize = 0x4D0; // CHandle<CBaseEntity>
    pub const m_hTargetReference: usize = 0x4D4; // CHandle<CBaseEntity>
    pub const m_flScale: usize = 0x4D8; // float
    pub const m_nMeasureType: usize = 0x4DC; // int32_t
}

pub mod CLogicNPCCounter {
    pub const m_OnMinCountAll: usize = 0x4B0; // CEntityIOOutput
    pub const m_OnMaxCountAll: usize = 0x4D8; // CEntityIOOutput
    pub const m_OnFactorAll: usize = 0x500; // CEntityOutputTemplate<float>
    pub const m_OnMinPlayerDistAll: usize = 0x528; // CEntityOutputTemplate<float>
    pub const m_OnMinCount_1: usize = 0x550; // CEntityIOOutput
    pub const m_OnMaxCount_1: usize = 0x578; // CEntityIOOutput
    pub const m_OnFactor_1: usize = 0x5A0; // CEntityOutputTemplate<float>
    pub const m_OnMinPlayerDist_1: usize = 0x5C8; // CEntityOutputTemplate<float>
    pub const m_OnMinCount_2: usize = 0x5F0; // CEntityIOOutput
    pub const m_OnMaxCount_2: usize = 0x618; // CEntityIOOutput
    pub const m_OnFactor_2: usize = 0x640; // CEntityOutputTemplate<float>
    pub const m_OnMinPlayerDist_2: usize = 0x668; // CEntityOutputTemplate<float>
    pub const m_OnMinCount_3: usize = 0x690; // CEntityIOOutput
    pub const m_OnMaxCount_3: usize = 0x6B8; // CEntityIOOutput
    pub const m_OnFactor_3: usize = 0x6E0; // CEntityOutputTemplate<float>
    pub const m_OnMinPlayerDist_3: usize = 0x708; // CEntityOutputTemplate<float>
    pub const m_hSource: usize = 0x730; // CEntityHandle
    pub const m_iszSourceEntityName: usize = 0x738; // CUtlSymbolLarge
    pub const m_flDistanceMax: usize = 0x740; // float
    pub const m_bDisabled: usize = 0x744; // bool
    pub const m_nMinCountAll: usize = 0x748; // int32_t
    pub const m_nMaxCountAll: usize = 0x74C; // int32_t
    pub const m_nMinFactorAll: usize = 0x750; // int32_t
    pub const m_nMaxFactorAll: usize = 0x754; // int32_t
    pub const m_iszNPCClassname_1: usize = 0x760; // CUtlSymbolLarge
    pub const m_nNPCState_1: usize = 0x768; // int32_t
    pub const m_bInvertState_1: usize = 0x76C; // bool
    pub const m_nMinCount_1: usize = 0x770; // int32_t
    pub const m_nMaxCount_1: usize = 0x774; // int32_t
    pub const m_nMinFactor_1: usize = 0x778; // int32_t
    pub const m_nMaxFactor_1: usize = 0x77C; // int32_t
    pub const m_flDefaultDist_1: usize = 0x784; // float
    pub const m_iszNPCClassname_2: usize = 0x788; // CUtlSymbolLarge
    pub const m_nNPCState_2: usize = 0x790; // int32_t
    pub const m_bInvertState_2: usize = 0x794; // bool
    pub const m_nMinCount_2: usize = 0x798; // int32_t
    pub const m_nMaxCount_2: usize = 0x79C; // int32_t
    pub const m_nMinFactor_2: usize = 0x7A0; // int32_t
    pub const m_nMaxFactor_2: usize = 0x7A4; // int32_t
    pub const m_flDefaultDist_2: usize = 0x7AC; // float
    pub const m_iszNPCClassname_3: usize = 0x7B0; // CUtlSymbolLarge
    pub const m_nNPCState_3: usize = 0x7B8; // int32_t
    pub const m_bInvertState_3: usize = 0x7BC; // bool
    pub const m_nMinCount_3: usize = 0x7C0; // int32_t
    pub const m_nMaxCount_3: usize = 0x7C4; // int32_t
    pub const m_nMinFactor_3: usize = 0x7C8; // int32_t
    pub const m_nMaxFactor_3: usize = 0x7CC; // int32_t
    pub const m_flDefaultDist_3: usize = 0x7D4; // float
}

pub mod CLogicNPCCounterAABB {
    pub const m_vDistanceOuterMins: usize = 0x7F0; // Vector
    pub const m_vDistanceOuterMaxs: usize = 0x7FC; // Vector
    pub const m_vOuterMins: usize = 0x808; // Vector
    pub const m_vOuterMaxs: usize = 0x814; // Vector
}

pub mod CLogicNavigation {
    pub const m_isOn: usize = 0x4B8; // bool
    pub const m_navProperty: usize = 0x4BC; // navproperties_t
}

pub mod CLogicPlayerProxy {
    pub const m_hPlayer: usize = 0x4B0; // CHandle<CBaseEntity>
    pub const m_PlayerHasAmmo: usize = 0x4B8; // CEntityIOOutput
    pub const m_PlayerHasNoAmmo: usize = 0x4E0; // CEntityIOOutput
    pub const m_PlayerDied: usize = 0x508; // CEntityIOOutput
    pub const m_RequestedPlayerHealth: usize = 0x530; // CEntityOutputTemplate<int32_t>
}

pub mod CLogicRelay {
    pub const m_OnTrigger: usize = 0x4B0; // CEntityIOOutput
    pub const m_OnSpawn: usize = 0x4D8; // CEntityIOOutput
    pub const m_bDisabled: usize = 0x500; // bool
    pub const m_bWaitForRefire: usize = 0x501; // bool
    pub const m_bTriggerOnce: usize = 0x502; // bool
    pub const m_bFastRetrigger: usize = 0x503; // bool
    pub const m_bPassthoughCaller: usize = 0x504; // bool
}

pub mod CMapInfo {
    pub const m_iBuyingStatus: usize = 0x4B0; // int32_t
    pub const m_flBombRadius: usize = 0x4B4; // float
    pub const m_iPetPopulation: usize = 0x4B8; // int32_t
    pub const m_bUseNormalSpawnsForDM: usize = 0x4BC; // bool
    pub const m_bDisableAutoGeneratedDMSpawns: usize = 0x4BD; // bool
    pub const m_flBotMaxVisionDistance: usize = 0x4C0; // float
    pub const m_iHostageCount: usize = 0x4C4; // int32_t
    pub const m_bFadePlayerVisibilityFarZ: usize = 0x4C8; // bool
}

pub mod CMapVetoPickController {
    pub const m_bPlayedIntroVcd: usize = 0x4B0; // bool
    pub const m_bNeedToPlayFiveSecondsRemaining: usize = 0x4B1; // bool
    pub const m_dblPreMatchDraftSequenceTime: usize = 0x4D0; // double
    pub const m_bPreMatchDraftStateChanged: usize = 0x4D8; // bool
    pub const m_nDraftType: usize = 0x4DC; // int32_t
    pub const m_nTeamWinningCoinToss: usize = 0x4E0; // int32_t
    pub const m_nTeamWithFirstChoice: usize = 0x4E4; // int32_t[64]
    pub const m_nVoteMapIdsList: usize = 0x5E4; // int32_t[7]
    pub const m_nAccountIDs: usize = 0x600; // int32_t[64]
    pub const m_nMapId0: usize = 0x700; // int32_t[64]
    pub const m_nMapId1: usize = 0x800; // int32_t[64]
    pub const m_nMapId2: usize = 0x900; // int32_t[64]
    pub const m_nMapId3: usize = 0xA00; // int32_t[64]
    pub const m_nMapId4: usize = 0xB00; // int32_t[64]
    pub const m_nMapId5: usize = 0xC00; // int32_t[64]
    pub const m_nStartingSide0: usize = 0xD00; // int32_t[64]
    pub const m_nCurrentPhase: usize = 0xE00; // int32_t
    pub const m_nPhaseStartTick: usize = 0xE04; // int32_t
    pub const m_nPhaseDurationTicks: usize = 0xE08; // int32_t
    pub const m_OnMapVetoed: usize = 0xE10; // CEntityOutputTemplate<CUtlSymbolLarge>
    pub const m_OnMapPicked: usize = 0xE38; // CEntityOutputTemplate<CUtlSymbolLarge>
    pub const m_OnSidesPicked: usize = 0xE60; // CEntityOutputTemplate<int32_t>
    pub const m_OnNewPhaseStarted: usize = 0xE88; // CEntityOutputTemplate<int32_t>
    pub const m_OnLevelTransition: usize = 0xEB0; // CEntityOutputTemplate<int32_t>
}

pub mod CMarkupVolume {
    pub const m_bEnabled: usize = 0x700; // bool
}

pub mod CMarkupVolumeTagged {
    pub const m_bIsGroup: usize = 0x738; // bool
    pub const m_bGroupByPrefab: usize = 0x739; // bool
    pub const m_bGroupByVolume: usize = 0x73A; // bool
    pub const m_bGroupOtherGroups: usize = 0x73B; // bool
    pub const m_bIsInGroup: usize = 0x73C; // bool
}

pub mod CMarkupVolumeTagged_NavGame {
    pub const m_bFloodFillAttribute: usize = 0x758; // bool
}

pub mod CMarkupVolumeWithRef {
    pub const m_bUseRef: usize = 0x740; // bool
    pub const m_vRefPos: usize = 0x744; // Vector
    pub const m_flRefDot: usize = 0x750; // float
}

pub mod CMathColorBlend {
    pub const m_flInMin: usize = 0x4B0; // float
    pub const m_flInMax: usize = 0x4B4; // float
    pub const m_OutColor1: usize = 0x4B8; // Color
    pub const m_OutColor2: usize = 0x4BC; // Color
    pub const m_OutValue: usize = 0x4C0; // CEntityOutputTemplate<Color>
}

pub mod CMathCounter {
    pub const m_flMin: usize = 0x4B0; // float
    pub const m_flMax: usize = 0x4B4; // float
    pub const m_bHitMin: usize = 0x4B8; // bool
    pub const m_bHitMax: usize = 0x4B9; // bool
    pub const m_bDisabled: usize = 0x4BA; // bool
    pub const m_OutValue: usize = 0x4C0; // CEntityOutputTemplate<float>
    pub const m_OnGetValue: usize = 0x4E8; // CEntityOutputTemplate<float>
    pub const m_OnHitMin: usize = 0x510; // CEntityIOOutput
    pub const m_OnHitMax: usize = 0x538; // CEntityIOOutput
    pub const m_OnChangedFromMin: usize = 0x560; // CEntityIOOutput
    pub const m_OnChangedFromMax: usize = 0x588; // CEntityIOOutput
}

pub mod CMathRemap {
    pub const m_flInMin: usize = 0x4B0; // float
    pub const m_flInMax: usize = 0x4B4; // float
    pub const m_flOut1: usize = 0x4B8; // float
    pub const m_flOut2: usize = 0x4BC; // float
    pub const m_flOldInValue: usize = 0x4C0; // float
    pub const m_bEnabled: usize = 0x4C4; // bool
    pub const m_OutValue: usize = 0x4C8; // CEntityOutputTemplate<float>
    pub const m_OnRoseAboveMin: usize = 0x4F0; // CEntityIOOutput
    pub const m_OnRoseAboveMax: usize = 0x518; // CEntityIOOutput
    pub const m_OnFellBelowMin: usize = 0x540; // CEntityIOOutput
    pub const m_OnFellBelowMax: usize = 0x568; // CEntityIOOutput
}

pub mod CMelee {
    pub const m_flThrowAt: usize = 0xE20; // GameTime_t
    pub const m_hThrower: usize = 0xE24; // CHandle<CBaseEntity>
    pub const m_bDidThrowDamage: usize = 0xE28; // bool
}

pub mod CMessage {
    pub const m_iszMessage: usize = 0x4B0; // CUtlSymbolLarge
    pub const m_MessageVolume: usize = 0x4B8; // float
    pub const m_MessageAttenuation: usize = 0x4BC; // int32_t
    pub const m_Radius: usize = 0x4C0; // float
    pub const m_sNoise: usize = 0x4C8; // CUtlSymbolLarge
    pub const m_OnShowMessage: usize = 0x4D0; // CEntityIOOutput
}

pub mod CMessageEntity {
    pub const m_radius: usize = 0x4B0; // int32_t
    pub const m_messageText: usize = 0x4B8; // CUtlSymbolLarge
    pub const m_drawText: usize = 0x4C0; // bool
    pub const m_bDeveloperOnly: usize = 0x4C1; // bool
    pub const m_bEnabled: usize = 0x4C2; // bool
}

pub mod CModelState {
    pub const m_hModel: usize = 0xA0; // CStrongHandle<InfoForResourceTypeCModel>
    pub const m_ModelName: usize = 0xA8; // CUtlSymbolLarge
    pub const m_bClientClothCreationSuppressed: usize = 0xE8; // bool
    pub const m_MeshGroupMask: usize = 0x180; // uint64_t
    pub const m_nIdealMotionType: usize = 0x222; // int8_t
    pub const m_nForceLOD: usize = 0x223; // int8_t
    pub const m_nClothUpdateFlags: usize = 0x224; // int8_t
}

pub mod CMolotovProjectile {
    pub const m_bIsIncGrenade: usize = 0xA40; // bool
    pub const m_bDetonated: usize = 0xA4C; // bool
    pub const m_stillTimer: usize = 0xA50; // IntervalTimer
    pub const m_bHasBouncedOffPlayer: usize = 0xB30; // bool
}

pub mod CMomentaryRotButton {
    pub const m_Position: usize = 0x8C8; // CEntityOutputTemplate<float>
    pub const m_OnUnpressed: usize = 0x8F0; // CEntityIOOutput
    pub const m_OnFullyOpen: usize = 0x918; // CEntityIOOutput
    pub const m_OnFullyClosed: usize = 0x940; // CEntityIOOutput
    pub const m_OnReachedPosition: usize = 0x968; // CEntityIOOutput
    pub const m_lastUsed: usize = 0x990; // int32_t
    pub const m_start: usize = 0x994; // QAngle
    pub const m_end: usize = 0x9A0; // QAngle
    pub const m_IdealYaw: usize = 0x9AC; // float
    pub const m_sNoise: usize = 0x9B0; // CUtlSymbolLarge
    pub const m_bUpdateTarget: usize = 0x9B8; // bool
    pub const m_direction: usize = 0x9BC; // int32_t
    pub const m_returnSpeed: usize = 0x9C0; // float
    pub const m_flStartPosition: usize = 0x9C4; // float
}

pub mod CMotorController {
    pub const m_speed: usize = 0x8; // float
    pub const m_maxTorque: usize = 0xC; // float
    pub const m_axis: usize = 0x10; // Vector
    pub const m_inertiaFactor: usize = 0x1C; // float
}

pub mod CMultiLightProxy {
    pub const m_iszLightNameFilter: usize = 0x4B0; // CUtlSymbolLarge
    pub const m_iszLightClassFilter: usize = 0x4B8; // CUtlSymbolLarge
    pub const m_flLightRadiusFilter: usize = 0x4C0; // float
    pub const m_flBrightnessDelta: usize = 0x4C4; // float
    pub const m_bPerformScreenFade: usize = 0x4C8; // bool
    pub const m_flTargetBrightnessMultiplier: usize = 0x4CC; // float
    pub const m_flCurrentBrightnessMultiplier: usize = 0x4D0; // float
    pub const m_vecLights: usize = 0x4D8; // CUtlVector<CHandle<CLightEntity>>
}

pub mod CMultiSource {
    pub const m_rgEntities: usize = 0x4B0; // CHandle<CBaseEntity>[32]
    pub const m_rgTriggered: usize = 0x530; // int32_t[32]
    pub const m_OnTrigger: usize = 0x5B0; // CEntityIOOutput
    pub const m_iTotal: usize = 0x5D8; // int32_t
    pub const m_globalstate: usize = 0x5E0; // CUtlSymbolLarge
}

pub mod CMultiplayer_Expresser {
    pub const m_bAllowMultipleScenes: usize = 0x70; // bool
}

pub mod CNavHullPresetVData {
    pub const m_vecNavHulls: usize = 0x0; // CUtlVector<CUtlString>
}

pub mod CNavHullVData {
    pub const m_bAgentEnabled: usize = 0x0; // bool
    pub const m_agentRadius: usize = 0x4; // float
    pub const m_agentHeight: usize = 0x8; // float
    pub const m_agentShortHeightEnabled: usize = 0xC; // bool
    pub const m_agentShortHeight: usize = 0x10; // float
    pub const m_agentMaxClimb: usize = 0x14; // float
    pub const m_agentMaxSlope: usize = 0x18; // int32_t
    pub const m_agentMaxJumpDownDist: usize = 0x1C; // float
    pub const m_agentMaxJumpHorizDistBase: usize = 0x20; // float
    pub const m_agentMaxJumpUpDist: usize = 0x24; // float
    pub const m_agentBorderErosion: usize = 0x28; // int32_t
}

pub mod CNavLinkAnimgraphVar {
    pub const m_strAnimgraphVar: usize = 0x0; // CUtlString
    pub const m_unAlignmentDegrees: usize = 0x8; // uint32_t
}

pub mod CNavLinkAreaEntity {
    pub const m_flWidth: usize = 0x4B0; // float
    pub const m_vLocatorOffset: usize = 0x4B4; // Vector
    pub const m_qLocatorAnglesOffset: usize = 0x4C0; // QAngle
    pub const m_strMovementForward: usize = 0x4D0; // CUtlSymbolLarge
    pub const m_strMovementReverse: usize = 0x4D8; // CUtlSymbolLarge
    pub const m_nNavLinkIdForward: usize = 0x4E0; // int32_t
    pub const m_nNavLinkIdReverse: usize = 0x4E4; // int32_t
    pub const m_bEnabled: usize = 0x4E8; // bool
    pub const m_strFilterName: usize = 0x4F0; // CUtlSymbolLarge
    pub const m_hFilter: usize = 0x4F8; // CHandle<CBaseFilter>
    pub const m_OnNavLinkStart: usize = 0x500; // CEntityIOOutput
    pub const m_OnNavLinkFinish: usize = 0x528; // CEntityIOOutput
    pub const m_bIsTerminus: usize = 0x550; // bool
}

pub mod CNavLinkMovementVData {
    pub const m_bIsInterpolated: usize = 0x0; // bool
    pub const m_unRecommendedDistance: usize = 0x4; // uint32_t
    pub const m_vecAnimgraphVars: usize = 0x8; // CUtlVector<CNavLinkAnimgraphVar>
}

pub mod CNavSpaceInfo {
    pub const m_bCreateFlightSpace: usize = 0x4B0; // bool
}

pub mod CNavVolumeBreadthFirstSearch {
    pub const m_vStartPos: usize = 0xA0; // Vector
    pub const m_flSearchDist: usize = 0xAC; // float
}

pub mod CNavVolumeSphere {
    pub const m_vCenter: usize = 0x70; // Vector
    pub const m_flRadius: usize = 0x7C; // float
}

pub mod CNavVolumeSphericalShell {
    pub const m_flRadiusInner: usize = 0x80; // float
}

pub mod CNavVolumeVector {
    pub const m_bHasBeenPreFiltered: usize = 0x78; // bool
}

pub mod CNetworkOriginCellCoordQuantizedVector {
    pub const m_cellX: usize = 0x10; // uint16_t
    pub const m_cellY: usize = 0x12; // uint16_t
    pub const m_cellZ: usize = 0x14; // uint16_t
    pub const m_nOutsideWorld: usize = 0x16; // uint16_t
    pub const m_vecX: usize = 0x18; // CNetworkedQuantizedFloat
    pub const m_vecY: usize = 0x20; // CNetworkedQuantizedFloat
    pub const m_vecZ: usize = 0x28; // CNetworkedQuantizedFloat
}

pub mod CNetworkOriginQuantizedVector {
    pub const m_vecX: usize = 0x10; // CNetworkedQuantizedFloat
    pub const m_vecY: usize = 0x18; // CNetworkedQuantizedFloat
    pub const m_vecZ: usize = 0x20; // CNetworkedQuantizedFloat
}

pub mod CNetworkTransmitComponent {
    pub const m_nTransmitStateOwnedCounter: usize = 0x16C; // uint8_t
}

pub mod CNetworkVelocityVector {
    pub const m_vecX: usize = 0x10; // CNetworkedQuantizedFloat
    pub const m_vecY: usize = 0x18; // CNetworkedQuantizedFloat
    pub const m_vecZ: usize = 0x20; // CNetworkedQuantizedFloat
}

pub mod CNetworkViewOffsetVector {
    pub const m_vecX: usize = 0x10; // CNetworkedQuantizedFloat
    pub const m_vecY: usize = 0x18; // CNetworkedQuantizedFloat
    pub const m_vecZ: usize = 0x20; // CNetworkedQuantizedFloat
}

pub mod CNetworkedSequenceOperation {
    pub const m_hSequence: usize = 0x8; // HSequence
    pub const m_flPrevCycle: usize = 0xC; // float
    pub const m_flCycle: usize = 0x10; // float
    pub const m_flWeight: usize = 0x14; // CNetworkedQuantizedFloat
    pub const m_bSequenceChangeNetworked: usize = 0x1C; // bool
    pub const m_bDiscontinuity: usize = 0x1D; // bool
    pub const m_flPrevCycleFromDiscontinuity: usize = 0x20; // float
    pub const m_flPrevCycleForAnimEventDetection: usize = 0x24; // float
}

pub mod COmniLight {
    pub const m_flInnerAngle: usize = 0x928; // float
    pub const m_flOuterAngle: usize = 0x92C; // float
    pub const m_bShowLight: usize = 0x930; // bool
}

pub mod COrnamentProp {
    pub const m_initialOwner: usize = 0xB08; // CUtlSymbolLarge
}

pub mod CParticleSystem {
    pub const m_szSnapshotFileName: usize = 0x700; // char[512]
    pub const m_bActive: usize = 0x900; // bool
    pub const m_bFrozen: usize = 0x901; // bool
    pub const m_flFreezeTransitionDuration: usize = 0x904; // float
    pub const m_nStopType: usize = 0x908; // int32_t
    pub const m_bAnimateDuringGameplayPause: usize = 0x90C; // bool
    pub const m_iEffectIndex: usize = 0x910; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    pub const m_flStartTime: usize = 0x918; // GameTime_t
    pub const m_flPreSimTime: usize = 0x91C; // float
    pub const m_vServerControlPoints: usize = 0x920; // Vector[4]
    pub const m_iServerControlPointAssignments: usize = 0x950; // uint8_t[4]
    pub const m_hControlPointEnts: usize = 0x954; // CHandle<CBaseEntity>[64]
    pub const m_bNoSave: usize = 0xA54; // bool
    pub const m_bNoFreeze: usize = 0xA55; // bool
    pub const m_bNoRamp: usize = 0xA56; // bool
    pub const m_bStartActive: usize = 0xA57; // bool
    pub const m_iszEffectName: usize = 0xA58; // CUtlSymbolLarge
    pub const m_iszControlPointNames: usize = 0xA60; // CUtlSymbolLarge[64]
    pub const m_nDataCP: usize = 0xC60; // int32_t
    pub const m_vecDataCPValue: usize = 0xC64; // Vector
    pub const m_nTintCP: usize = 0xC70; // int32_t
    pub const m_clrTint: usize = 0xC74; // Color
}

pub mod CPathCorner {
    pub const m_flWait: usize = 0x4B0; // float
    pub const m_flRadius: usize = 0x4B4; // float
    pub const m_OnPass: usize = 0x4B8; // CEntityIOOutput
}

pub mod CPathKeyFrame {
    pub const m_Origin: usize = 0x4B0; // Vector
    pub const m_Angles: usize = 0x4BC; // QAngle
    pub const m_qAngle: usize = 0x4D0; // Quaternion
    pub const m_iNextKey: usize = 0x4E0; // CUtlSymbolLarge
    pub const m_flNextTime: usize = 0x4E8; // float
    pub const m_pNextKey: usize = 0x4F0; // CPathKeyFrame*
    pub const m_pPrevKey: usize = 0x4F8; // CPathKeyFrame*
    pub const m_flSpeed: usize = 0x500; // float
}

pub mod CPathParticleRope {
    pub const m_bStartActive: usize = 0x4B0; // bool
    pub const m_flMaxSimulationTime: usize = 0x4B4; // float
    pub const m_iszEffectName: usize = 0x4B8; // CUtlSymbolLarge
    pub const m_PathNodes_Name: usize = 0x4C0; // CUtlVector<CUtlSymbolLarge>
    pub const m_flParticleSpacing: usize = 0x4D8; // float
    pub const m_flSlack: usize = 0x4DC; // float
    pub const m_flRadius: usize = 0x4E0; // float
    pub const m_ColorTint: usize = 0x4E4; // Color
    pub const m_nEffectState: usize = 0x4E8; // int32_t
    pub const m_iEffectIndex: usize = 0x4F0; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    pub const m_PathNodes_Position: usize = 0x4F8; // CNetworkUtlVectorBase<Vector>
    pub const m_PathNodes_TangentIn: usize = 0x510; // CNetworkUtlVectorBase<Vector>
    pub const m_PathNodes_TangentOut: usize = 0x528; // CNetworkUtlVectorBase<Vector>
    pub const m_PathNodes_Color: usize = 0x540; // CNetworkUtlVectorBase<Vector>
    pub const m_PathNodes_PinEnabled: usize = 0x558; // CNetworkUtlVectorBase<bool>
    pub const m_PathNodes_RadiusScale: usize = 0x570; // CNetworkUtlVectorBase<float>
}

pub mod CPathTrack {
    pub const m_pnext: usize = 0x4B0; // CPathTrack*
    pub const m_pprevious: usize = 0x4B8; // CPathTrack*
    pub const m_paltpath: usize = 0x4C0; // CPathTrack*
    pub const m_flRadius: usize = 0x4C8; // float
    pub const m_length: usize = 0x4CC; // float
    pub const m_altName: usize = 0x4D0; // CUtlSymbolLarge
    pub const m_nIterVal: usize = 0x4D8; // int32_t
    pub const m_eOrientationType: usize = 0x4DC; // TrackOrientationType_t
    pub const m_OnPass: usize = 0x4E0; // CEntityIOOutput
}

pub mod CPhysBallSocket {
    pub const m_flFriction: usize = 0x508; // float
    pub const m_bEnableSwingLimit: usize = 0x50C; // bool
    pub const m_flSwingLimit: usize = 0x510; // float
    pub const m_bEnableTwistLimit: usize = 0x514; // bool
    pub const m_flMinTwistAngle: usize = 0x518; // float
    pub const m_flMaxTwistAngle: usize = 0x51C; // float
}

pub mod CPhysBox {
    pub const m_damageType: usize = 0x7C0; // int32_t
    pub const m_massScale: usize = 0x7C4; // float
    pub const m_damageToEnableMotion: usize = 0x7C8; // int32_t
    pub const m_flForceToEnableMotion: usize = 0x7CC; // float
    pub const m_angPreferredCarryAngles: usize = 0x7D0; // QAngle
    pub const m_bNotSolidToWorld: usize = 0x7DC; // bool
    pub const m_bEnableUseOutput: usize = 0x7DD; // bool
    pub const m_iExploitableByPlayer: usize = 0x7E0; // int32_t
    pub const m_flTouchOutputPerEntityDelay: usize = 0x7E4; // float
    pub const m_OnDamaged: usize = 0x7E8; // CEntityIOOutput
    pub const m_OnAwakened: usize = 0x810; // CEntityIOOutput
    pub const m_OnMotionEnabled: usize = 0x838; // CEntityIOOutput
    pub const m_OnPlayerUse: usize = 0x860; // CEntityIOOutput
    pub const m_OnStartTouch: usize = 0x888; // CEntityIOOutput
    pub const m_hCarryingPlayer: usize = 0x8B0; // CHandle<CBasePlayerPawn>
}

pub mod CPhysConstraint {
    pub const m_nameAttach1: usize = 0x4B8; // CUtlSymbolLarge
    pub const m_nameAttach2: usize = 0x4C0; // CUtlSymbolLarge
    pub const m_breakSound: usize = 0x4C8; // CUtlSymbolLarge
    pub const m_forceLimit: usize = 0x4D0; // float
    pub const m_torqueLimit: usize = 0x4D4; // float
    pub const m_teleportTick: usize = 0x4D8; // uint32_t
    pub const m_minTeleportDistance: usize = 0x4DC; // float
    pub const m_OnBreak: usize = 0x4E0; // CEntityIOOutput
}

pub mod CPhysExplosion {
    pub const m_bExplodeOnSpawn: usize = 0x4B0; // bool
    pub const m_flMagnitude: usize = 0x4B4; // float
    pub const m_flDamage: usize = 0x4B8; // float
    pub const m_radius: usize = 0x4BC; // float
    pub const m_targetEntityName: usize = 0x4C0; // CUtlSymbolLarge
    pub const m_flInnerRadius: usize = 0x4C8; // float
    pub const m_flPushScale: usize = 0x4CC; // float
    pub const m_bConvertToDebrisWhenPossible: usize = 0x4D0; // bool
    pub const m_OnPushedPlayer: usize = 0x4D8; // CEntityIOOutput
}

pub mod CPhysFixed {
    pub const m_flLinearFrequency: usize = 0x508; // float
    pub const m_flLinearDampingRatio: usize = 0x50C; // float
    pub const m_flAngularFrequency: usize = 0x510; // float
    pub const m_flAngularDampingRatio: usize = 0x514; // float
    pub const m_bEnableLinearConstraint: usize = 0x518; // bool
    pub const m_bEnableAngularConstraint: usize = 0x519; // bool
}

pub mod CPhysForce {
    pub const m_nameAttach: usize = 0x4B8; // CUtlSymbolLarge
    pub const m_force: usize = 0x4C0; // float
    pub const m_forceTime: usize = 0x4C4; // float
    pub const m_attachedObject: usize = 0x4C8; // CHandle<CBaseEntity>
    pub const m_wasRestored: usize = 0x4CC; // bool
    pub const m_integrator: usize = 0x4D0; // CConstantForceController
}

pub mod CPhysHinge {
    pub const m_soundInfo: usize = 0x510; // ConstraintSoundInfo
    pub const m_NotifyMinLimitReached: usize = 0x598; // CEntityIOOutput
    pub const m_NotifyMaxLimitReached: usize = 0x5C0; // CEntityIOOutput
    pub const m_bAtMinLimit: usize = 0x5E8; // bool
    pub const m_bAtMaxLimit: usize = 0x5E9; // bool
    pub const m_hinge: usize = 0x5EC; // constraint_hingeparams_t
    pub const m_hingeFriction: usize = 0x62C; // float
    pub const m_systemLoadScale: usize = 0x630; // float
    pub const m_bIsAxisLocal: usize = 0x634; // bool
    pub const m_flMinRotation: usize = 0x638; // float
    pub const m_flMaxRotation: usize = 0x63C; // float
    pub const m_flInitialRotation: usize = 0x640; // float
    pub const m_flMotorFrequency: usize = 0x644; // float
    pub const m_flMotorDampingRatio: usize = 0x648; // float
    pub const m_flAngleSpeed: usize = 0x64C; // float
    pub const m_flAngleSpeedThreshold: usize = 0x650; // float
    pub const m_OnStartMoving: usize = 0x658; // CEntityIOOutput
    pub const m_OnStopMoving: usize = 0x680; // CEntityIOOutput
}

pub mod CPhysImpact {
    pub const m_damage: usize = 0x4B0; // float
    pub const m_distance: usize = 0x4B4; // float
    pub const m_directionEntityName: usize = 0x4B8; // CUtlSymbolLarge
}

pub mod CPhysLength {
    pub const m_offset: usize = 0x508; // Vector[2]
    pub const m_vecAttach: usize = 0x520; // Vector
    pub const m_addLength: usize = 0x52C; // float
    pub const m_minLength: usize = 0x530; // float
    pub const m_totalLength: usize = 0x534; // float
    pub const m_bEnableCollision: usize = 0x538; // bool
}

pub mod CPhysMagnet {
    pub const m_OnMagnetAttach: usize = 0x890; // CEntityIOOutput
    pub const m_OnMagnetDetach: usize = 0x8B8; // CEntityIOOutput
    pub const m_massScale: usize = 0x8E0; // float
    pub const m_forceLimit: usize = 0x8E4; // float
    pub const m_torqueLimit: usize = 0x8E8; // float
    pub const m_MagnettedEntities: usize = 0x8F0; // CUtlVector<magnetted_objects_t>
    pub const m_bActive: usize = 0x908; // bool
    pub const m_bHasHitSomething: usize = 0x909; // bool
    pub const m_flTotalMass: usize = 0x90C; // float
    pub const m_flRadius: usize = 0x910; // float
    pub const m_flNextSuckTime: usize = 0x914; // GameTime_t
    pub const m_iMaxObjectsAttached: usize = 0x918; // int32_t
}

pub mod CPhysMotor {
    pub const m_nameAttach: usize = 0x4B0; // CUtlSymbolLarge
    pub const m_hAttachedObject: usize = 0x4B8; // CHandle<CBaseEntity>
    pub const m_spinUp: usize = 0x4BC; // float
    pub const m_additionalAcceleration: usize = 0x4C0; // float
    pub const m_angularAcceleration: usize = 0x4C4; // float
    pub const m_lastTime: usize = 0x4C8; // GameTime_t
    pub const m_motor: usize = 0x4E0; // CMotorController
}

pub mod CPhysPulley {
    pub const m_position2: usize = 0x508; // Vector
    pub const m_offset: usize = 0x514; // Vector[2]
    pub const m_addLength: usize = 0x52C; // float
    pub const m_gearRatio: usize = 0x530; // float
}

pub mod CPhysSlideConstraint {
    pub const m_axisEnd: usize = 0x510; // Vector
    pub const m_slideFriction: usize = 0x51C; // float
    pub const m_systemLoadScale: usize = 0x520; // float
    pub const m_initialOffset: usize = 0x524; // float
    pub const m_bEnableLinearConstraint: usize = 0x528; // bool
    pub const m_bEnableAngularConstraint: usize = 0x529; // bool
    pub const m_flMotorFrequency: usize = 0x52C; // float
    pub const m_flMotorDampingRatio: usize = 0x530; // float
    pub const m_bUseEntityPivot: usize = 0x534; // bool
    pub const m_soundInfo: usize = 0x538; // ConstraintSoundInfo
}

pub mod CPhysThruster {
    pub const m_localOrigin: usize = 0x510; // Vector
}

pub mod CPhysTorque {
    pub const m_axis: usize = 0x510; // Vector
}

pub mod CPhysWheelConstraint {
    pub const m_flSuspensionFrequency: usize = 0x508; // float
    pub const m_flSuspensionDampingRatio: usize = 0x50C; // float
    pub const m_flSuspensionHeightOffset: usize = 0x510; // float
    pub const m_bEnableSuspensionLimit: usize = 0x514; // bool
    pub const m_flMinSuspensionOffset: usize = 0x518; // float
    pub const m_flMaxSuspensionOffset: usize = 0x51C; // float
    pub const m_bEnableSteeringLimit: usize = 0x520; // bool
    pub const m_flMinSteeringAngle: usize = 0x524; // float
    pub const m_flMaxSteeringAngle: usize = 0x528; // float
    pub const m_flSteeringAxisFriction: usize = 0x52C; // float
    pub const m_flSpinAxisFriction: usize = 0x530; // float
}

pub mod CPhysicsEntitySolver {
    pub const m_hMovingEntity: usize = 0x4B8; // CHandle<CBaseEntity>
    pub const m_hPhysicsBlocker: usize = 0x4BC; // CHandle<CBaseEntity>
    pub const m_separationDuration: usize = 0x4C0; // float
    pub const m_cancelTime: usize = 0x4C4; // GameTime_t
}

pub mod CPhysicsProp {
    pub const m_MotionEnabled: usize = 0xA10; // CEntityIOOutput
    pub const m_OnAwakened: usize = 0xA38; // CEntityIOOutput
    pub const m_OnAwake: usize = 0xA60; // CEntityIOOutput
    pub const m_OnAsleep: usize = 0xA88; // CEntityIOOutput
    pub const m_OnPlayerUse: usize = 0xAB0; // CEntityIOOutput
    pub const m_OnPlayerPickup: usize = 0xAD8; // CEntityIOOutput
    pub const m_OnOutOfWorld: usize = 0xB00; // CEntityIOOutput
    pub const m_massScale: usize = 0xB28; // float
    pub const m_inertiaScale: usize = 0xB2C; // float
    pub const m_buoyancyScale: usize = 0xB30; // float
    pub const m_damageType: usize = 0xB34; // int32_t
    pub const m_damageToEnableMotion: usize = 0xB38; // int32_t
    pub const m_flForceToEnableMotion: usize = 0xB3C; // float
    pub const m_bThrownByPlayer: usize = 0xB40; // bool
    pub const m_bDroppedByPlayer: usize = 0xB41; // bool
    pub const m_bTouchedByPlayer: usize = 0xB42; // bool
    pub const m_bFirstCollisionAfterLaunch: usize = 0xB43; // bool
    pub const m_iExploitableByPlayer: usize = 0xB44; // int32_t
    pub const m_bHasBeenAwakened: usize = 0xB48; // bool
    pub const m_bIsOverrideProp: usize = 0xB49; // bool
    pub const m_fNextCheckDisableMotionContactsTime: usize = 0xB4C; // GameTime_t
    pub const m_iInitialGlowState: usize = 0xB50; // int32_t
    pub const m_nGlowRange: usize = 0xB54; // int32_t
    pub const m_nGlowRangeMin: usize = 0xB58; // int32_t
    pub const m_glowColor: usize = 0xB5C; // Color
    pub const m_bForceNavIgnore: usize = 0xB60; // bool
    pub const m_bNoNavmeshBlocker: usize = 0xB61; // bool
    pub const m_bForceNpcExclude: usize = 0xB62; // bool
    pub const m_bShouldAutoConvertBackFromDebris: usize = 0xB63; // bool
    pub const m_bMuteImpactEffects: usize = 0xB64; // bool
    pub const m_bAcceptDamageFromHeldObjects: usize = 0xB6C; // bool
    pub const m_bEnableUseOutput: usize = 0xB6D; // bool
    pub const m_bAwake: usize = 0xB6E; // bool
    pub const m_nCollisionGroupOverride: usize = 0xB70; // int32_t
}

pub mod CPhysicsPropRespawnable {
    pub const m_vOriginalSpawnOrigin: usize = 0xB78; // Vector
    pub const m_vOriginalSpawnAngles: usize = 0xB84; // QAngle
    pub const m_vOriginalMins: usize = 0xB90; // Vector
    pub const m_vOriginalMaxs: usize = 0xB9C; // Vector
    pub const m_flRespawnDuration: usize = 0xBA8; // float
}

pub mod CPhysicsShake {
    pub const m_force: usize = 0x8; // Vector
}

pub mod CPhysicsSpring {
    pub const m_flFrequency: usize = 0x4B8; // float
    pub const m_flDampingRatio: usize = 0x4BC; // float
    pub const m_flRestLength: usize = 0x4C0; // float
    pub const m_nameAttachStart: usize = 0x4C8; // CUtlSymbolLarge
    pub const m_nameAttachEnd: usize = 0x4D0; // CUtlSymbolLarge
    pub const m_start: usize = 0x4D8; // Vector
    pub const m_end: usize = 0x4E4; // Vector
    pub const m_teleportTick: usize = 0x4F0; // uint32_t
}

pub mod CPhysicsWire {
    pub const m_nDensity: usize = 0x4B0; // int32_t
}

pub mod CPlantedC4 {
    pub const m_bBombTicking: usize = 0x890; // bool
    pub const m_flC4Blow: usize = 0x894; // GameTime_t
    pub const m_nBombSite: usize = 0x898; // int32_t
    pub const m_nSourceSoundscapeHash: usize = 0x89C; // int32_t
    pub const m_OnBombDefused: usize = 0x8A0; // CEntityIOOutput
    pub const m_OnBombBeginDefuse: usize = 0x8C8; // CEntityIOOutput
    pub const m_OnBombDefuseAborted: usize = 0x8F0; // CEntityIOOutput
    pub const m_bCannotBeDefused: usize = 0x918; // bool
    pub const m_entitySpottedState: usize = 0x920; // EntitySpottedState_t
    pub const m_nSpotRules: usize = 0x938; // int32_t
    pub const m_bTrainingPlacedByPlayer: usize = 0x93C; // bool
    pub const m_bHasExploded: usize = 0x93D; // bool
    pub const m_flTimerLength: usize = 0x940; // float
    pub const m_bBeingDefused: usize = 0x944; // bool
    pub const m_fLastDefuseTime: usize = 0x94C; // GameTime_t
    pub const m_flDefuseLength: usize = 0x954; // float
    pub const m_flDefuseCountDown: usize = 0x958; // GameTime_t
    pub const m_bBombDefused: usize = 0x95C; // bool
    pub const m_hBombDefuser: usize = 0x960; // CHandle<CCSPlayerPawn>
    pub const m_hControlPanel: usize = 0x964; // CHandle<CBaseEntity>
    pub const m_iProgressBarTime: usize = 0x968; // int32_t
    pub const m_bVoiceAlertFired: usize = 0x96C; // bool
    pub const m_bVoiceAlertPlayed: usize = 0x96D; // bool[4]
    pub const m_flNextBotBeepTime: usize = 0x974; // GameTime_t
    pub const m_bPlantedAfterPickup: usize = 0x97C; // bool
    pub const m_angCatchUpToPlayerEye: usize = 0x980; // QAngle
    pub const m_flLastSpinDetectionTime: usize = 0x98C; // GameTime_t
}

pub mod CPlatTrigger {
    pub const m_pPlatform: usize = 0x700; // CHandle<CFuncPlat>
}

pub mod CPlayerControllerComponent {
    pub const __m_pChainEntity: usize = 0x8; // CNetworkVarChainer
}

pub mod CPlayerPawnComponent {
    pub const __m_pChainEntity: usize = 0x8; // CNetworkVarChainer
}

pub mod CPlayerPing {
    pub const m_hPlayer: usize = 0x4B8; // CHandle<CCSPlayerPawn>
    pub const m_hPingedEntity: usize = 0x4BC; // CHandle<CBaseEntity>
    pub const m_iType: usize = 0x4C0; // int32_t
    pub const m_bUrgent: usize = 0x4C4; // bool
    pub const m_szPlaceName: usize = 0x4C5; // char[18]
}

pub mod CPlayerSprayDecal {
    pub const m_nUniqueID: usize = 0x700; // int32_t
    pub const m_unAccountID: usize = 0x704; // uint32_t
    pub const m_unTraceID: usize = 0x708; // uint32_t
    pub const m_rtGcTime: usize = 0x70C; // uint32_t
    pub const m_vecEndPos: usize = 0x710; // Vector
    pub const m_vecStart: usize = 0x71C; // Vector
    pub const m_vecLeft: usize = 0x728; // Vector
    pub const m_vecNormal: usize = 0x734; // Vector
    pub const m_nPlayer: usize = 0x740; // int32_t
    pub const m_nEntity: usize = 0x744; // int32_t
    pub const m_nHitbox: usize = 0x748; // int32_t
    pub const m_flCreationTime: usize = 0x74C; // float
    pub const m_nTintID: usize = 0x750; // int32_t
    pub const m_nVersion: usize = 0x754; // uint8_t
    pub const m_ubSignature: usize = 0x755; // uint8_t[128]
}

pub mod CPlayerVisibility {
    pub const m_flVisibilityStrength: usize = 0x4B0; // float
    pub const m_flFogDistanceMultiplier: usize = 0x4B4; // float
    pub const m_flFogMaxDensityMultiplier: usize = 0x4B8; // float
    pub const m_flFadeTime: usize = 0x4BC; // float
    pub const m_bStartDisabled: usize = 0x4C0; // bool
    pub const m_bIsEnabled: usize = 0x4C1; // bool
}

pub mod CPlayer_CameraServices {
    pub const m_vecCsViewPunchAngle: usize = 0x40; // QAngle
    pub const m_nCsViewPunchAngleTick: usize = 0x4C; // GameTick_t
    pub const m_flCsViewPunchAngleTickRatio: usize = 0x50; // float
    pub const m_PlayerFog: usize = 0x58; // fogplayerparams_t
    pub const m_hColorCorrectionCtrl: usize = 0x98; // CHandle<CColorCorrection>
    pub const m_hViewEntity: usize = 0x9C; // CHandle<CBaseEntity>
    pub const m_hTonemapController: usize = 0xA0; // CHandle<CTonemapController2>
    pub const m_audio: usize = 0xA8; // audioparams_t
    pub const m_PostProcessingVolumes: usize = 0x120; // CNetworkUtlVectorBase<CHandle<CPostProcessingVolume>>
    pub const m_flOldPlayerZ: usize = 0x138; // float
    pub const m_flOldPlayerViewOffsetZ: usize = 0x13C; // float
    pub const m_hTriggerSoundscapeList: usize = 0x158; // CUtlVector<CHandle<CEnvSoundscapeTriggerable>>
}

pub mod CPlayer_MovementServices {
    pub const m_nImpulse: usize = 0x40; // int32_t
    pub const m_nButtons: usize = 0x48; // CInButtonState
    pub const m_nQueuedButtonDownMask: usize = 0x68; // uint64_t
    pub const m_nQueuedButtonChangeMask: usize = 0x70; // uint64_t
    pub const m_nButtonDoublePressed: usize = 0x78; // uint64_t
    pub const m_pButtonPressedCmdNumber: usize = 0x80; // uint32_t[64]
    pub const m_nLastCommandNumberProcessed: usize = 0x180; // uint32_t
    pub const m_nToggleButtonDownMask: usize = 0x188; // uint64_t
    pub const m_flMaxspeed: usize = 0x190; // float
    pub const m_arrForceSubtickMoveWhen: usize = 0x194; // float[4]
    pub const m_flForwardMove: usize = 0x1A4; // float
    pub const m_flLeftMove: usize = 0x1A8; // float
    pub const m_flUpMove: usize = 0x1AC; // float
    pub const m_vecLastMovementImpulses: usize = 0x1B0; // Vector
    pub const m_vecOldViewAngles: usize = 0x1BC; // QAngle
}

pub mod CPlayer_MovementServices_Humanoid {
    pub const m_flStepSoundTime: usize = 0x1D0; // float
    pub const m_flFallVelocity: usize = 0x1D4; // float
    pub const m_bInCrouch: usize = 0x1D8; // bool
    pub const m_nCrouchState: usize = 0x1DC; // uint32_t
    pub const m_flCrouchTransitionStartTime: usize = 0x1E0; // GameTime_t
    pub const m_bDucked: usize = 0x1E4; // bool
    pub const m_bDucking: usize = 0x1E5; // bool
    pub const m_bInDuckJump: usize = 0x1E6; // bool
    pub const m_groundNormal: usize = 0x1E8; // Vector
    pub const m_flSurfaceFriction: usize = 0x1F4; // float
    pub const m_surfaceProps: usize = 0x1F8; // CUtlStringToken
    pub const m_nStepside: usize = 0x208; // int32_t
    pub const m_iTargetVolume: usize = 0x20C; // int32_t
    pub const m_vecSmoothedVelocity: usize = 0x210; // Vector
}

pub mod CPlayer_ObserverServices {
    pub const m_iObserverMode: usize = 0x40; // uint8_t
    pub const m_hObserverTarget: usize = 0x44; // CHandle<CBaseEntity>
    pub const m_iObserverLastMode: usize = 0x48; // ObserverMode_t
    pub const m_bForcedObserverMode: usize = 0x4C; // bool
}

pub mod CPlayer_WeaponServices {
    pub const m_bAllowSwitchToNoWeapon: usize = 0x40; // bool
    pub const m_hMyWeapons: usize = 0x48; // CNetworkUtlVectorBase<CHandle<CBasePlayerWeapon>>
    pub const m_hActiveWeapon: usize = 0x60; // CHandle<CBasePlayerWeapon>
    pub const m_hLastWeapon: usize = 0x64; // CHandle<CBasePlayerWeapon>
    pub const m_iAmmo: usize = 0x68; // uint16_t[32]
    pub const m_bPreventWeaponPickup: usize = 0xA8; // bool
}

pub mod CPointAngleSensor {
    pub const m_bDisabled: usize = 0x4B0; // bool
    pub const m_nLookAtName: usize = 0x4B8; // CUtlSymbolLarge
    pub const m_hTargetEntity: usize = 0x4C0; // CHandle<CBaseEntity>
    pub const m_hLookAtEntity: usize = 0x4C4; // CHandle<CBaseEntity>
    pub const m_flDuration: usize = 0x4C8; // float
    pub const m_flDotTolerance: usize = 0x4CC; // float
    pub const m_flFacingTime: usize = 0x4D0; // GameTime_t
    pub const m_bFired: usize = 0x4D4; // bool
    pub const m_OnFacingLookat: usize = 0x4D8; // CEntityIOOutput
    pub const m_OnNotFacingLookat: usize = 0x500; // CEntityIOOutput
    pub const m_TargetDir: usize = 0x528; // CEntityOutputTemplate<Vector>
    pub const m_FacingPercentage: usize = 0x550; // CEntityOutputTemplate<float>
}

pub mod CPointAngularVelocitySensor {
    pub const m_hTargetEntity: usize = 0x4B0; // CHandle<CBaseEntity>
    pub const m_flThreshold: usize = 0x4B4; // float
    pub const m_nLastCompareResult: usize = 0x4B8; // int32_t
    pub const m_nLastFireResult: usize = 0x4BC; // int32_t
    pub const m_flFireTime: usize = 0x4C0; // GameTime_t
    pub const m_flFireInterval: usize = 0x4C4; // float
    pub const m_flLastAngVelocity: usize = 0x4C8; // float
    pub const m_lastOrientation: usize = 0x4CC; // QAngle
    pub const m_vecAxis: usize = 0x4D8; // Vector
    pub const m_bUseHelper: usize = 0x4E4; // bool
    pub const m_AngularVelocity: usize = 0x4E8; // CEntityOutputTemplate<float>
    pub const m_OnLessThan: usize = 0x510; // CEntityIOOutput
    pub const m_OnLessThanOrEqualTo: usize = 0x538; // CEntityIOOutput
    pub const m_OnGreaterThan: usize = 0x560; // CEntityIOOutput
    pub const m_OnGreaterThanOrEqualTo: usize = 0x588; // CEntityIOOutput
    pub const m_OnEqualTo: usize = 0x5B0; // CEntityIOOutput
}

pub mod CPointCamera {
    pub const m_FOV: usize = 0x4B0; // float
    pub const m_Resolution: usize = 0x4B4; // float
    pub const m_bFogEnable: usize = 0x4B8; // bool
    pub const m_FogColor: usize = 0x4B9; // Color
    pub const m_flFogStart: usize = 0x4C0; // float
    pub const m_flFogEnd: usize = 0x4C4; // float
    pub const m_flFogMaxDensity: usize = 0x4C8; // float
    pub const m_bActive: usize = 0x4CC; // bool
    pub const m_bUseScreenAspectRatio: usize = 0x4CD; // bool
    pub const m_flAspectRatio: usize = 0x4D0; // float
    pub const m_bNoSky: usize = 0x4D4; // bool
    pub const m_fBrightness: usize = 0x4D8; // float
    pub const m_flZFar: usize = 0x4DC; // float
    pub const m_flZNear: usize = 0x4E0; // float
    pub const m_bCanHLTVUse: usize = 0x4E4; // bool
    pub const m_bDofEnabled: usize = 0x4E5; // bool
    pub const m_flDofNearBlurry: usize = 0x4E8; // float
    pub const m_flDofNearCrisp: usize = 0x4EC; // float
    pub const m_flDofFarCrisp: usize = 0x4F0; // float
    pub const m_flDofFarBlurry: usize = 0x4F4; // float
    pub const m_flDofTiltToGround: usize = 0x4F8; // float
    pub const m_TargetFOV: usize = 0x4FC; // float
    pub const m_DegreesPerSecond: usize = 0x500; // float
    pub const m_bIsOn: usize = 0x504; // bool
    pub const m_pNext: usize = 0x508; // CPointCamera*
}

pub mod CPointCameraVFOV {
    pub const m_flVerticalFOV: usize = 0x510; // float
}

pub mod CPointClientUIDialog {
    pub const m_hActivator: usize = 0x8B0; // CHandle<CBaseEntity>
    pub const m_bStartEnabled: usize = 0x8B4; // bool
}

pub mod CPointClientUIWorldPanel {
    pub const m_bIgnoreInput: usize = 0x8B0; // bool
    pub const m_bLit: usize = 0x8B1; // bool
    pub const m_bFollowPlayerAcrossTeleport: usize = 0x8B2; // bool
    pub const m_flWidth: usize = 0x8B4; // float
    pub const m_flHeight: usize = 0x8B8; // float
    pub const m_flDPI: usize = 0x8BC; // float
    pub const m_flInteractDistance: usize = 0x8C0; // float
    pub const m_flDepthOffset: usize = 0x8C4; // float
    pub const m_unOwnerContext: usize = 0x8C8; // uint32_t
    pub const m_unHorizontalAlign: usize = 0x8CC; // uint32_t
    pub const m_unVerticalAlign: usize = 0x8D0; // uint32_t
    pub const m_unOrientation: usize = 0x8D4; // uint32_t
    pub const m_bAllowInteractionFromAllSceneWorlds: usize = 0x8D8; // bool
    pub const m_vecCSSClasses: usize = 0x8E0; // CNetworkUtlVectorBase<CUtlSymbolLarge>
    pub const m_bOpaque: usize = 0x8F8; // bool
    pub const m_bNoDepth: usize = 0x8F9; // bool
    pub const m_bRenderBackface: usize = 0x8FA; // bool
    pub const m_bUseOffScreenIndicator: usize = 0x8FB; // bool
    pub const m_bExcludeFromSaveGames: usize = 0x8FC; // bool
    pub const m_bGrabbable: usize = 0x8FD; // bool
    pub const m_bOnlyRenderToTexture: usize = 0x8FE; // bool
    pub const m_bDisableMipGen: usize = 0x8FF; // bool
    pub const m_nExplicitImageLayout: usize = 0x900; // int32_t
}

pub mod CPointClientUIWorldTextPanel {
    pub const m_messageText: usize = 0x908; // char[512]
}

pub mod CPointCommentaryNode {
    pub const m_iszPreCommands: usize = 0x890; // CUtlSymbolLarge
    pub const m_iszPostCommands: usize = 0x898; // CUtlSymbolLarge
    pub const m_iszCommentaryFile: usize = 0x8A0; // CUtlSymbolLarge
    pub const m_iszViewTarget: usize = 0x8A8; // CUtlSymbolLarge
    pub const m_hViewTarget: usize = 0x8B0; // CHandle<CBaseEntity>
    pub const m_hViewTargetAngles: usize = 0x8B4; // CHandle<CBaseEntity>
    pub const m_iszViewPosition: usize = 0x8B8; // CUtlSymbolLarge
    pub const m_hViewPosition: usize = 0x8C0; // CHandle<CBaseEntity>
    pub const m_hViewPositionMover: usize = 0x8C4; // CHandle<CBaseEntity>
    pub const m_bPreventMovement: usize = 0x8C8; // bool
    pub const m_bUnderCrosshair: usize = 0x8C9; // bool
    pub const m_bUnstoppable: usize = 0x8CA; // bool
    pub const m_flFinishedTime: usize = 0x8CC; // GameTime_t
    pub const m_vecFinishOrigin: usize = 0x8D0; // Vector
    pub const m_vecOriginalAngles: usize = 0x8DC; // QAngle
    pub const m_vecFinishAngles: usize = 0x8E8; // QAngle
    pub const m_bPreventChangesWhileMoving: usize = 0x8F4; // bool
    pub const m_bDisabled: usize = 0x8F5; // bool
    pub const m_vecTeleportOrigin: usize = 0x8F8; // Vector
    pub const m_flAbortedPlaybackAt: usize = 0x904; // GameTime_t
    pub const m_pOnCommentaryStarted: usize = 0x908; // CEntityIOOutput
    pub const m_pOnCommentaryStopped: usize = 0x930; // CEntityIOOutput
    pub const m_bActive: usize = 0x958; // bool
    pub const m_flStartTime: usize = 0x95C; // GameTime_t
    pub const m_flStartTimeInCommentary: usize = 0x960; // float
    pub const m_iszTitle: usize = 0x968; // CUtlSymbolLarge
    pub const m_iszSpeakers: usize = 0x970; // CUtlSymbolLarge
    pub const m_iNodeNumber: usize = 0x978; // int32_t
    pub const m_iNodeNumberMax: usize = 0x97C; // int32_t
    pub const m_bListenedTo: usize = 0x980; // bool
}

pub mod CPointEntityFinder {
    pub const m_hEntity: usize = 0x4B0; // CHandle<CBaseEntity>
    pub const m_iFilterName: usize = 0x4B8; // CUtlSymbolLarge
    pub const m_hFilter: usize = 0x4C0; // CHandle<CBaseFilter>
    pub const m_iRefName: usize = 0x4C8; // CUtlSymbolLarge
    pub const m_hReference: usize = 0x4D0; // CHandle<CBaseEntity>
    pub const m_FindMethod: usize = 0x4D4; // EntFinderMethod_t
    pub const m_OnFoundEntity: usize = 0x4D8; // CEntityIOOutput
}

pub mod CPointGamestatsCounter {
    pub const m_strStatisticName: usize = 0x4B0; // CUtlSymbolLarge
    pub const m_bDisabled: usize = 0x4B8; // bool
}

pub mod CPointGiveAmmo {
    pub const m_pActivator: usize = 0x4B0; // CHandle<CBaseEntity>
}

pub mod CPointHurt {
    pub const m_nDamage: usize = 0x4B0; // int32_t
    pub const m_bitsDamageType: usize = 0x4B4; // int32_t
    pub const m_flRadius: usize = 0x4B8; // float
    pub const m_flDelay: usize = 0x4BC; // float
    pub const m_strTarget: usize = 0x4C0; // CUtlSymbolLarge
    pub const m_pActivator: usize = 0x4C8; // CHandle<CBaseEntity>
}

pub mod CPointPrefab {
    pub const m_targetMapName: usize = 0x4B0; // CUtlSymbolLarge
    pub const m_forceWorldGroupID: usize = 0x4B8; // CUtlSymbolLarge
    pub const m_associatedRelayTargetName: usize = 0x4C0; // CUtlSymbolLarge
    pub const m_fixupNames: usize = 0x4C8; // bool
    pub const m_bLoadDynamic: usize = 0x4C9; // bool
    pub const m_associatedRelayEntity: usize = 0x4CC; // CHandle<CPointPrefab>
}

pub mod CPointProximitySensor {
    pub const m_bDisabled: usize = 0x4B0; // bool
    pub const m_hTargetEntity: usize = 0x4B4; // CHandle<CBaseEntity>
    pub const m_Distance: usize = 0x4B8; // CEntityOutputTemplate<float>
}

pub mod CPointPulse {
    pub const m_sNameFixupStaticPrefix: usize = 0x5C8; // CUtlSymbolLarge
    pub const m_sNameFixupParent: usize = 0x5D0; // CUtlSymbolLarge
    pub const m_sNameFixupLocal: usize = 0x5D8; // CUtlSymbolLarge
}

pub mod CPointPush {
    pub const m_bEnabled: usize = 0x4B0; // bool
    pub const m_flMagnitude: usize = 0x4B4; // float
    pub const m_flRadius: usize = 0x4B8; // float
    pub const m_flInnerRadius: usize = 0x4BC; // float
    pub const m_flConeOfInfluence: usize = 0x4C0; // float
    pub const m_iszFilterName: usize = 0x4C8; // CUtlSymbolLarge
    pub const m_hFilter: usize = 0x4D0; // CHandle<CBaseFilter>
}

pub mod CPointTeleport {
    pub const m_vSaveOrigin: usize = 0x4B0; // Vector
    pub const m_vSaveAngles: usize = 0x4BC; // QAngle
    pub const m_bTeleportParentedEntities: usize = 0x4C8; // bool
    pub const m_bTeleportUseCurrentAngle: usize = 0x4C9; // bool
}

pub mod CPointTemplate {
    pub const m_iszWorldName: usize = 0x4B0; // CUtlSymbolLarge
    pub const m_iszSource2EntityLumpName: usize = 0x4B8; // CUtlSymbolLarge
    pub const m_iszEntityFilterName: usize = 0x4C0; // CUtlSymbolLarge
    pub const m_flTimeoutInterval: usize = 0x4C8; // float
    pub const m_bAsynchronouslySpawnEntities: usize = 0x4CC; // bool
    pub const m_pOutputOnSpawned: usize = 0x4D0; // CEntityIOOutput
    pub const m_clientOnlyEntityBehavior: usize = 0x4F8; // PointTemplateClientOnlyEntityBehavior_t
    pub const m_ownerSpawnGroupType: usize = 0x4FC; // PointTemplateOwnerSpawnGroupType_t
    pub const m_createdSpawnGroupHandles: usize = 0x500; // CUtlVector<uint32_t>
    pub const m_SpawnedEntityHandles: usize = 0x518; // CUtlVector<CEntityHandle>
    pub const m_ScriptSpawnCallback: usize = 0x530; // HSCRIPT
    pub const m_ScriptCallbackScope: usize = 0x538; // HSCRIPT
}

pub mod CPointValueRemapper {
    pub const m_bDisabled: usize = 0x4B0; // bool
    pub const m_bUpdateOnClient: usize = 0x4B1; // bool
    pub const m_nInputType: usize = 0x4B4; // ValueRemapperInputType_t
    pub const m_iszRemapLineStartName: usize = 0x4B8; // CUtlSymbolLarge
    pub const m_iszRemapLineEndName: usize = 0x4C0; // CUtlSymbolLarge
    pub const m_hRemapLineStart: usize = 0x4C8; // CHandle<CBaseEntity>
    pub const m_hRemapLineEnd: usize = 0x4CC; // CHandle<CBaseEntity>
    pub const m_flMaximumChangePerSecond: usize = 0x4D0; // float
    pub const m_flDisengageDistance: usize = 0x4D4; // float
    pub const m_flEngageDistance: usize = 0x4D8; // float
    pub const m_bRequiresUseKey: usize = 0x4DC; // bool
    pub const m_nOutputType: usize = 0x4E0; // ValueRemapperOutputType_t
    pub const m_iszOutputEntityName: usize = 0x4E8; // CUtlSymbolLarge
    pub const m_iszOutputEntity2Name: usize = 0x4F0; // CUtlSymbolLarge
    pub const m_iszOutputEntity3Name: usize = 0x4F8; // CUtlSymbolLarge
    pub const m_iszOutputEntity4Name: usize = 0x500; // CUtlSymbolLarge
    pub const m_hOutputEntities: usize = 0x508; // CNetworkUtlVectorBase<CHandle<CBaseEntity>>
    pub const m_nHapticsType: usize = 0x520; // ValueRemapperHapticsType_t
    pub const m_nMomentumType: usize = 0x524; // ValueRemapperMomentumType_t
    pub const m_flMomentumModifier: usize = 0x528; // float
    pub const m_flSnapValue: usize = 0x52C; // float
    pub const m_flCurrentMomentum: usize = 0x530; // float
    pub const m_nRatchetType: usize = 0x534; // ValueRemapperRatchetType_t
    pub const m_flRatchetOffset: usize = 0x538; // float
    pub const m_flInputOffset: usize = 0x53C; // float
    pub const m_bEngaged: usize = 0x540; // bool
    pub const m_bFirstUpdate: usize = 0x541; // bool
    pub const m_flPreviousValue: usize = 0x544; // float
    pub const m_flPreviousUpdateTickTime: usize = 0x548; // GameTime_t
    pub const m_vecPreviousTestPoint: usize = 0x54C; // Vector
    pub const m_hUsingPlayer: usize = 0x558; // CHandle<CBasePlayerPawn>
    pub const m_flCustomOutputValue: usize = 0x55C; // float
    pub const m_iszSoundEngage: usize = 0x560; // CUtlSymbolLarge
    pub const m_iszSoundDisengage: usize = 0x568; // CUtlSymbolLarge
    pub const m_iszSoundReachedValueZero: usize = 0x570; // CUtlSymbolLarge
    pub const m_iszSoundReachedValueOne: usize = 0x578; // CUtlSymbolLarge
    pub const m_iszSoundMovingLoop: usize = 0x580; // CUtlSymbolLarge
    pub const m_Position: usize = 0x590; // CEntityOutputTemplate<float>
    pub const m_PositionDelta: usize = 0x5B8; // CEntityOutputTemplate<float>
    pub const m_OnReachedValueZero: usize = 0x5E0; // CEntityIOOutput
    pub const m_OnReachedValueOne: usize = 0x608; // CEntityIOOutput
    pub const m_OnReachedValueCustom: usize = 0x630; // CEntityIOOutput
    pub const m_OnEngage: usize = 0x658; // CEntityIOOutput
    pub const m_OnDisengage: usize = 0x680; // CEntityIOOutput
}

pub mod CPointVelocitySensor {
    pub const m_hTargetEntity: usize = 0x4B0; // CHandle<CBaseEntity>
    pub const m_vecAxis: usize = 0x4B4; // Vector
    pub const m_bEnabled: usize = 0x4C0; // bool
    pub const m_fPrevVelocity: usize = 0x4C4; // float
    pub const m_flAvgInterval: usize = 0x4C8; // float
    pub const m_Velocity: usize = 0x4D0; // CEntityOutputTemplate<float>
}

pub mod CPointWorldText {
    pub const m_messageText: usize = 0x700; // char[512]
    pub const m_FontName: usize = 0x900; // char[64]
    pub const m_bEnabled: usize = 0x940; // bool
    pub const m_bFullbright: usize = 0x941; // bool
    pub const m_flWorldUnitsPerPx: usize = 0x944; // float
    pub const m_flFontSize: usize = 0x948; // float
    pub const m_flDepthOffset: usize = 0x94C; // float
    pub const m_Color: usize = 0x950; // Color
    pub const m_nJustifyHorizontal: usize = 0x954; // PointWorldTextJustifyHorizontal_t
    pub const m_nJustifyVertical: usize = 0x958; // PointWorldTextJustifyVertical_t
    pub const m_nReorientMode: usize = 0x95C; // PointWorldTextReorientMode_t
}

pub mod CPostProcessingVolume {
    pub const m_hPostSettings: usize = 0x8B8; // CStrongHandle<InfoForResourceTypeCPostProcessingResource>
    pub const m_flFadeDuration: usize = 0x8C0; // float
    pub const m_flMinLogExposure: usize = 0x8C4; // float
    pub const m_flMaxLogExposure: usize = 0x8C8; // float
    pub const m_flMinExposure: usize = 0x8CC; // float
    pub const m_flMaxExposure: usize = 0x8D0; // float
    pub const m_flExposureCompensation: usize = 0x8D4; // float
    pub const m_flExposureFadeSpeedUp: usize = 0x8D8; // float
    pub const m_flExposureFadeSpeedDown: usize = 0x8DC; // float
    pub const m_flTonemapEVSmoothingRange: usize = 0x8E0; // float
    pub const m_bMaster: usize = 0x8E4; // bool
    pub const m_bExposureControl: usize = 0x8E5; // bool
    pub const m_flRate: usize = 0x8E8; // float
    pub const m_flTonemapPercentTarget: usize = 0x8EC; // float
    pub const m_flTonemapPercentBrightPixels: usize = 0x8F0; // float
    pub const m_flTonemapMinAvgLum: usize = 0x8F4; // float
}

pub mod CPrecipitationVData {
    pub const m_szParticlePrecipitationEffect: usize = 0x28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    pub const m_flInnerDistance: usize = 0x108; // float
    pub const m_nAttachType: usize = 0x10C; // ParticleAttachment_t
    pub const m_bBatchSameVolumeType: usize = 0x110; // bool
    pub const m_nRTEnvCP: usize = 0x114; // int32_t
    pub const m_nRTEnvCPComponent: usize = 0x118; // int32_t
    pub const m_szModifier: usize = 0x120; // CUtlString
}

pub mod CProjectedDecal {
    pub const m_nTexture: usize = 0x4B0; // int32_t
    pub const m_flDistance: usize = 0x4B4; // float
}

pub mod CPropDoorRotating {
    pub const m_vecAxis: usize = 0xD98; // Vector
    pub const m_flDistance: usize = 0xDA4; // float
    pub const m_eSpawnPosition: usize = 0xDA8; // PropDoorRotatingSpawnPos_t
    pub const m_eOpenDirection: usize = 0xDAC; // PropDoorRotatingOpenDirection_e
    pub const m_eCurrentOpenDirection: usize = 0xDB0; // PropDoorRotatingOpenDirection_e
    pub const m_flAjarAngle: usize = 0xDB4; // float
    pub const m_angRotationAjarDeprecated: usize = 0xDB8; // QAngle
    pub const m_angRotationClosed: usize = 0xDC4; // QAngle
    pub const m_angRotationOpenForward: usize = 0xDD0; // QAngle
    pub const m_angRotationOpenBack: usize = 0xDDC; // QAngle
    pub const m_angGoal: usize = 0xDE8; // QAngle
    pub const m_vecForwardBoundsMin: usize = 0xDF4; // Vector
    pub const m_vecForwardBoundsMax: usize = 0xE00; // Vector
    pub const m_vecBackBoundsMin: usize = 0xE0C; // Vector
    pub const m_vecBackBoundsMax: usize = 0xE18; // Vector
    pub const m_bAjarDoorShouldntAlwaysOpen: usize = 0xE24; // bool
    pub const m_hEntityBlocker: usize = 0xE28; // CHandle<CEntityBlocker>
}

pub mod CPropDoorRotatingBreakable {
    pub const m_bBreakable: usize = 0xE30; // bool
    pub const m_isAbleToCloseAreaPortals: usize = 0xE31; // bool
    pub const m_currentDamageState: usize = 0xE34; // int32_t
    pub const m_damageStates: usize = 0xE38; // CUtlVector<CUtlSymbolLarge>
}

pub mod CPulseCell_Inflow_GameEvent {
    pub const m_EventName: usize = 0x70; // CBufferString
}

pub mod CPulseCell_Outflow_PlayVCD {
    pub const m_vcdFilename: usize = 0x48; // CUtlString
    pub const m_OnFinished: usize = 0x50; // CPulse_OutflowConnection
    pub const m_Triggers: usize = 0x60; // CUtlVector<CPulse_OutflowConnection>
}

pub mod CPulseCell_SoundEventStart {
    pub const m_Type: usize = 0x48; // SoundEventStartType_t
}

pub mod CPulseCell_Step_EntFire {
    pub const m_Input: usize = 0x48; // CUtlString
}

pub mod CPulseCell_Step_SetAnimGraphParam {
    pub const m_ParamName: usize = 0x48; // CUtlString
}

pub mod CPulseCell_Value_FindEntByName {
    pub const m_EntityType: usize = 0x48; // CUtlString
}

pub mod CRR_Response {
    pub const m_Type: usize = 0x0; // uint8_t
    pub const m_szResponseName: usize = 0x1; // char[192]
    pub const m_szMatchingRule: usize = 0xC1; // char[128]
    pub const m_Params: usize = 0x148; // ResponseParams
    pub const m_fMatchScore: usize = 0x168; // float
    pub const m_szSpeakerContext: usize = 0x170; // char*
    pub const m_szWorldContext: usize = 0x178; // char*
    pub const m_Followup: usize = 0x180; // ResponseFollowup
    pub const m_pchCriteriaNames: usize = 0x1B8; // CUtlVector<CUtlSymbol>
    pub const m_pchCriteriaValues: usize = 0x1D0; // CUtlVector<char*>
}

pub mod CRagdollConstraint {
    pub const m_xmin: usize = 0x508; // float
    pub const m_xmax: usize = 0x50C; // float
    pub const m_ymin: usize = 0x510; // float
    pub const m_ymax: usize = 0x514; // float
    pub const m_zmin: usize = 0x518; // float
    pub const m_zmax: usize = 0x51C; // float
    pub const m_xfriction: usize = 0x520; // float
    pub const m_yfriction: usize = 0x524; // float
    pub const m_zfriction: usize = 0x528; // float
}

pub mod CRagdollMagnet {
    pub const m_bDisabled: usize = 0x4B0; // bool
    pub const m_radius: usize = 0x4B4; // float
    pub const m_force: usize = 0x4B8; // float
    pub const m_axis: usize = 0x4BC; // Vector
}

pub mod CRagdollManager {
    pub const m_iCurrentMaxRagdollCount: usize = 0x4B0; // int8_t
    pub const m_iMaxRagdollCount: usize = 0x4B4; // int32_t
    pub const m_bSaveImportant: usize = 0x4B8; // bool
}

pub mod CRagdollProp {
    pub const m_ragdoll: usize = 0x898; // ragdoll_t
    pub const m_bStartDisabled: usize = 0x8D0; // bool
    pub const m_ragPos: usize = 0x8D8; // CNetworkUtlVectorBase<Vector>
    pub const m_ragAngles: usize = 0x8F0; // CNetworkUtlVectorBase<QAngle>
    pub const m_hRagdollSource: usize = 0x908; // CHandle<CBaseEntity>
    pub const m_lastUpdateTickCount: usize = 0x90C; // uint32_t
    pub const m_allAsleep: usize = 0x910; // bool
    pub const m_bFirstCollisionAfterLaunch: usize = 0x911; // bool
    pub const m_hDamageEntity: usize = 0x914; // CHandle<CBaseEntity>
    pub const m_hKiller: usize = 0x918; // CHandle<CBaseEntity>
    pub const m_hPhysicsAttacker: usize = 0x91C; // CHandle<CBasePlayerPawn>
    pub const m_flLastPhysicsInfluenceTime: usize = 0x920; // GameTime_t
    pub const m_flFadeOutStartTime: usize = 0x924; // GameTime_t
    pub const m_flFadeTime: usize = 0x928; // float
    pub const m_vecLastOrigin: usize = 0x92C; // Vector
    pub const m_flAwakeTime: usize = 0x938; // GameTime_t
    pub const m_flLastOriginChangeTime: usize = 0x93C; // GameTime_t
    pub const m_nBloodColor: usize = 0x940; // int32_t
    pub const m_strOriginClassName: usize = 0x948; // CUtlSymbolLarge
    pub const m_strSourceClassName: usize = 0x950; // CUtlSymbolLarge
    pub const m_bHasBeenPhysgunned: usize = 0x958; // bool
    pub const m_bShouldTeleportPhysics: usize = 0x959; // bool
    pub const m_flBlendWeight: usize = 0x95C; // float
    pub const m_flDefaultFadeScale: usize = 0x960; // float
    pub const m_ragdollMins: usize = 0x968; // CUtlVector<Vector>
    pub const m_ragdollMaxs: usize = 0x980; // CUtlVector<Vector>
    pub const m_bShouldDeleteActivationRecord: usize = 0x998; // bool
    pub const m_bValidatePoweredRagdollPose: usize = 0x9F8; // bool
}

pub mod CRagdollPropAttached {
    pub const m_boneIndexAttached: usize = 0xA38; // uint32_t
    pub const m_ragdollAttachedObjectIndex: usize = 0xA3C; // uint32_t
    pub const m_attachmentPointBoneSpace: usize = 0xA40; // Vector
    pub const m_attachmentPointRagdollSpace: usize = 0xA4C; // Vector
    pub const m_bShouldDetach: usize = 0xA58; // bool
    pub const m_bShouldDeleteAttachedActivationRecord: usize = 0xA68; // bool
}

pub mod CRandSimTimer {
    pub const m_minInterval: usize = 0x8; // float
    pub const m_maxInterval: usize = 0xC; // float
}

pub mod CRandStopwatch {
    pub const m_minInterval: usize = 0xC; // float
    pub const m_maxInterval: usize = 0x10; // float
}

pub mod CRangeFloat {
    pub const m_pValue: usize = 0x0; // float[2]
}

pub mod CRangeInt {
    pub const m_pValue: usize = 0x0; // int32_t[2]
}

pub mod CRectLight {
    pub const m_bShowLight: usize = 0x928; // bool
}

pub mod CRemapFloat {
    pub const m_pValue: usize = 0x0; // float[4]
}

pub mod CRenderComponent {
    pub const __m_pChainEntity: usize = 0x10; // CNetworkVarChainer
    pub const m_bIsRenderingWithViewModels: usize = 0x50; // bool
    pub const m_nSplitscreenFlags: usize = 0x54; // uint32_t
    pub const m_bEnableRendering: usize = 0x60; // bool
    pub const m_bInterpolationReadyToDraw: usize = 0xB0; // bool
}

pub mod CResponseCriteriaSet {
    pub const m_nNumPrefixedContexts: usize = 0x28; // int32_t
    pub const m_bOverrideOnAppend: usize = 0x2C; // bool
}

pub mod CResponseQueue {
    pub const m_ExpresserTargets: usize = 0x50; // CUtlVector<CAI_Expresser*>
}

pub mod CResponseQueue_CDeferredResponse {
    pub const m_contexts: usize = 0x10; // CResponseCriteriaSet
    pub const m_fDispatchTime: usize = 0x40; // float
    pub const m_hIssuer: usize = 0x44; // CHandle<CBaseEntity>
    pub const m_response: usize = 0x50; // CRR_Response
    pub const m_bResponseValid: usize = 0x238; // bool
}

pub mod CRetakeGameRules {
    pub const m_nMatchSeed: usize = 0xF8; // int32_t
    pub const m_bBlockersPresent: usize = 0xFC; // bool
    pub const m_bRoundInProgress: usize = 0xFD; // bool
    pub const m_iFirstSecondHalfRound: usize = 0x100; // int32_t
    pub const m_iBombSite: usize = 0x104; // int32_t
}

pub mod CRevertSaved {
    pub const m_loadTime: usize = 0x700; // float
    pub const m_Duration: usize = 0x704; // float
    pub const m_HoldTime: usize = 0x708; // float
}

pub mod CRopeKeyframe {
    pub const m_RopeFlags: usize = 0x708; // uint16_t
    pub const m_iNextLinkName: usize = 0x710; // CUtlSymbolLarge
    pub const m_Slack: usize = 0x718; // int16_t
    pub const m_Width: usize = 0x71C; // float
    pub const m_TextureScale: usize = 0x720; // float
    pub const m_nSegments: usize = 0x724; // uint8_t
    pub const m_bConstrainBetweenEndpoints: usize = 0x725; // bool
    pub const m_strRopeMaterialModel: usize = 0x728; // CUtlSymbolLarge
    pub const m_iRopeMaterialModelIndex: usize = 0x730; // CStrongHandle<InfoForResourceTypeIMaterial2>
    pub const m_Subdiv: usize = 0x738; // uint8_t
    pub const m_nChangeCount: usize = 0x739; // uint8_t
    pub const m_RopeLength: usize = 0x73A; // int16_t
    pub const m_fLockedPoints: usize = 0x73C; // uint8_t
    pub const m_bCreatedFromMapFile: usize = 0x73D; // bool
    pub const m_flScrollSpeed: usize = 0x740; // float
    pub const m_bStartPointValid: usize = 0x744; // bool
    pub const m_bEndPointValid: usize = 0x745; // bool
    pub const m_hStartPoint: usize = 0x748; // CHandle<CBaseEntity>
    pub const m_hEndPoint: usize = 0x74C; // CHandle<CBaseEntity>
    pub const m_iStartAttachment: usize = 0x750; // AttachmentHandle_t
    pub const m_iEndAttachment: usize = 0x751; // AttachmentHandle_t
}

pub mod CRotDoor {
    pub const m_bSolidBsp: usize = 0x988; // bool
}

pub mod CRuleEntity {
    pub const m_iszMaster: usize = 0x700; // CUtlSymbolLarge
}

pub mod CRulePointEntity {
    pub const m_Score: usize = 0x708; // int32_t
}

pub mod CSAdditionalMatchStats_t {
    pub const m_numRoundsSurvived: usize = 0x14; // int32_t
    pub const m_maxNumRoundsSurvived: usize = 0x18; // int32_t
    pub const m_numRoundsSurvivedTotal: usize = 0x1C; // int32_t
    pub const m_iRoundsWonWithoutPurchase: usize = 0x20; // int32_t
    pub const m_iRoundsWonWithoutPurchaseTotal: usize = 0x24; // int32_t
    pub const m_numFirstKills: usize = 0x28; // int32_t
    pub const m_numClutchKills: usize = 0x2C; // int32_t
    pub const m_numPistolKills: usize = 0x30; // int32_t
    pub const m_numSniperKills: usize = 0x34; // int32_t
    pub const m_iNumSuicides: usize = 0x38; // int32_t
    pub const m_iNumTeamKills: usize = 0x3C; // int32_t
    pub const m_iTeamDamage: usize = 0x40; // int32_t
}

pub mod CSAdditionalPerRoundStats_t {
    pub const m_numChickensKilled: usize = 0x0; // int32_t
    pub const m_killsWhileBlind: usize = 0x4; // int32_t
    pub const m_bombCarrierkills: usize = 0x8; // int32_t
    pub const m_iBurnDamageInflicted: usize = 0xC; // int32_t
    pub const m_iDinks: usize = 0x10; // int32_t
}

pub mod CSMatchStats_t {
    pub const m_iEnemy5Ks: usize = 0x68; // int32_t
    pub const m_iEnemy4Ks: usize = 0x6C; // int32_t
    pub const m_iEnemy3Ks: usize = 0x70; // int32_t
    pub const m_iEnemy2Ks: usize = 0x74; // int32_t
    pub const m_iUtility_Count: usize = 0x78; // int32_t
    pub const m_iUtility_Successes: usize = 0x7C; // int32_t
    pub const m_iUtility_Enemies: usize = 0x80; // int32_t
    pub const m_iFlash_Count: usize = 0x84; // int32_t
    pub const m_iFlash_Successes: usize = 0x88; // int32_t
    pub const m_nHealthPointsRemovedTotal: usize = 0x8C; // int32_t
    pub const m_nHealthPointsDealtTotal: usize = 0x90; // int32_t
    pub const m_nShotsFiredTotal: usize = 0x94; // int32_t
    pub const m_nShotsOnTargetTotal: usize = 0x98; // int32_t
    pub const m_i1v1Count: usize = 0x9C; // int32_t
    pub const m_i1v1Wins: usize = 0xA0; // int32_t
    pub const m_i1v2Count: usize = 0xA4; // int32_t
    pub const m_i1v2Wins: usize = 0xA8; // int32_t
    pub const m_iEntryCount: usize = 0xAC; // int32_t
    pub const m_iEntryWins: usize = 0xB0; // int32_t
}

pub mod CSPerRoundStats_t {
    pub const m_iKills: usize = 0x30; // int32_t
    pub const m_iDeaths: usize = 0x34; // int32_t
    pub const m_iAssists: usize = 0x38; // int32_t
    pub const m_iDamage: usize = 0x3C; // int32_t
    pub const m_iEquipmentValue: usize = 0x40; // int32_t
    pub const m_iMoneySaved: usize = 0x44; // int32_t
    pub const m_iKillReward: usize = 0x48; // int32_t
    pub const m_iLiveTime: usize = 0x4C; // int32_t
    pub const m_iHeadShotKills: usize = 0x50; // int32_t
    pub const m_iObjective: usize = 0x54; // int32_t
    pub const m_iCashEarned: usize = 0x58; // int32_t
    pub const m_iUtilityDamage: usize = 0x5C; // int32_t
    pub const m_iEnemiesFlashed: usize = 0x60; // int32_t
}

pub mod CSceneEntity {
    pub const m_iszSceneFile: usize = 0x4B8; // CUtlSymbolLarge
    pub const m_iszResumeSceneFile: usize = 0x4C0; // CUtlSymbolLarge
    pub const m_iszTarget1: usize = 0x4C8; // CUtlSymbolLarge
    pub const m_iszTarget2: usize = 0x4D0; // CUtlSymbolLarge
    pub const m_iszTarget3: usize = 0x4D8; // CUtlSymbolLarge
    pub const m_iszTarget4: usize = 0x4E0; // CUtlSymbolLarge
    pub const m_iszTarget5: usize = 0x4E8; // CUtlSymbolLarge
    pub const m_iszTarget6: usize = 0x4F0; // CUtlSymbolLarge
    pub const m_iszTarget7: usize = 0x4F8; // CUtlSymbolLarge
    pub const m_iszTarget8: usize = 0x500; // CUtlSymbolLarge
    pub const m_hTarget1: usize = 0x508; // CHandle<CBaseEntity>
    pub const m_hTarget2: usize = 0x50C; // CHandle<CBaseEntity>
    pub const m_hTarget3: usize = 0x510; // CHandle<CBaseEntity>
    pub const m_hTarget4: usize = 0x514; // CHandle<CBaseEntity>
    pub const m_hTarget5: usize = 0x518; // CHandle<CBaseEntity>
    pub const m_hTarget6: usize = 0x51C; // CHandle<CBaseEntity>
    pub const m_hTarget7: usize = 0x520; // CHandle<CBaseEntity>
    pub const m_hTarget8: usize = 0x524; // CHandle<CBaseEntity>
    pub const m_bIsPlayingBack: usize = 0x528; // bool
    pub const m_bPaused: usize = 0x529; // bool
    pub const m_bMultiplayer: usize = 0x52A; // bool
    pub const m_bAutogenerated: usize = 0x52B; // bool
    pub const m_flForceClientTime: usize = 0x52C; // float
    pub const m_flCurrentTime: usize = 0x530; // float
    pub const m_flFrameTime: usize = 0x534; // float
    pub const m_bCancelAtNextInterrupt: usize = 0x538; // bool
    pub const m_fPitch: usize = 0x53C; // float
    pub const m_bAutomated: usize = 0x540; // bool
    pub const m_nAutomatedAction: usize = 0x544; // int32_t
    pub const m_flAutomationDelay: usize = 0x548; // float
    pub const m_flAutomationTime: usize = 0x54C; // float
    pub const m_hWaitingForThisResumeScene: usize = 0x550; // CHandle<CBaseEntity>
    pub const m_bWaitingForResumeScene: usize = 0x554; // bool
    pub const m_bPausedViaInput: usize = 0x555; // bool
    pub const m_bPauseAtNextInterrupt: usize = 0x556; // bool
    pub const m_bWaitingForActor: usize = 0x557; // bool
    pub const m_bWaitingForInterrupt: usize = 0x558; // bool
    pub const m_bInterruptedActorsScenes: usize = 0x559; // bool
    pub const m_bBreakOnNonIdle: usize = 0x55A; // bool
    pub const m_hActorList: usize = 0x560; // CNetworkUtlVectorBase<CHandle<CBaseFlex>>
    pub const m_hRemoveActorList: usize = 0x578; // CUtlVector<CHandle<CBaseEntity>>
    pub const m_nSceneFlushCounter: usize = 0x5A0; // int32_t
    pub const m_nSceneStringIndex: usize = 0x5A4; // uint16_t
    pub const m_OnStart: usize = 0x5A8; // CEntityIOOutput
    pub const m_OnCompletion: usize = 0x5D0; // CEntityIOOutput
    pub const m_OnCanceled: usize = 0x5F8; // CEntityIOOutput
    pub const m_OnPaused: usize = 0x620; // CEntityIOOutput
    pub const m_OnResumed: usize = 0x648; // CEntityIOOutput
    pub const m_OnTrigger: usize = 0x670; // CEntityIOOutput[16]
    pub const m_hInterruptScene: usize = 0x980; // CHandle<CSceneEntity>
    pub const m_nInterruptCount: usize = 0x984; // int32_t
    pub const m_bSceneMissing: usize = 0x988; // bool
    pub const m_bInterrupted: usize = 0x989; // bool
    pub const m_bCompletedEarly: usize = 0x98A; // bool
    pub const m_bInterruptSceneFinished: usize = 0x98B; // bool
    pub const m_bRestoring: usize = 0x98C; // bool
    pub const m_hNotifySceneCompletion: usize = 0x990; // CUtlVector<CHandle<CSceneEntity>>
    pub const m_hListManagers: usize = 0x9A8; // CUtlVector<CHandle<CSceneListManager>>
    pub const m_iszSoundName: usize = 0x9E8; // CUtlSymbolLarge
    pub const m_hActor: usize = 0x9F0; // CHandle<CBaseFlex>
    pub const m_hActivator: usize = 0x9F4; // CHandle<CBaseEntity>
    pub const m_BusyActor: usize = 0x9F8; // int32_t
    pub const m_iPlayerDeathBehavior: usize = 0x9FC; // SceneOnPlayerDeath_t
}

pub mod CSceneEventInfo {
    pub const m_iLayer: usize = 0x0; // int32_t
    pub const m_iPriority: usize = 0x4; // int32_t
    pub const m_hSequence: usize = 0x8; // HSequence
    pub const m_flWeight: usize = 0xC; // float
    pub const m_bIsMoving: usize = 0x10; // bool
    pub const m_bHasArrived: usize = 0x11; // bool
    pub const m_flInitialYaw: usize = 0x14; // float
    pub const m_flTargetYaw: usize = 0x18; // float
    pub const m_flFacingYaw: usize = 0x1C; // float
    pub const m_nType: usize = 0x20; // int32_t
    pub const m_flNext: usize = 0x24; // GameTime_t
    pub const m_bIsGesture: usize = 0x28; // bool
    pub const m_bShouldRemove: usize = 0x29; // bool
    pub const m_hTarget: usize = 0x54; // CHandle<CBaseEntity>
    pub const m_nSceneEventId: usize = 0x58; // uint32_t
    pub const m_bClientSide: usize = 0x5C; // bool
    pub const m_bStarted: usize = 0x5D; // bool
}

pub mod CSceneListManager {
    pub const m_hListManagers: usize = 0x4B0; // CUtlVector<CHandle<CSceneListManager>>
    pub const m_iszScenes: usize = 0x4C8; // CUtlSymbolLarge[16]
    pub const m_hScenes: usize = 0x548; // CHandle<CBaseEntity>[16]
}

pub mod CScriptComponent {
    pub const m_scriptClassName: usize = 0x30; // CUtlSymbolLarge
}

pub mod CScriptItem {
    pub const m_OnPlayerPickup: usize = 0x968; // CEntityIOOutput
    pub const m_MoveTypeOverride: usize = 0x990; // MoveType_t
}

pub mod CScriptNavBlocker {
    pub const m_vExtent: usize = 0x710; // Vector
}

pub mod CScriptTriggerHurt {
    pub const m_vExtent: usize = 0x948; // Vector
}

pub mod CScriptTriggerMultiple {
    pub const m_vExtent: usize = 0x8D0; // Vector
}

pub mod CScriptTriggerOnce {
    pub const m_vExtent: usize = 0x8D0; // Vector
}

pub mod CScriptTriggerPush {
    pub const m_vExtent: usize = 0x8D0; // Vector
}

pub mod CScriptUniformRandomStream {
    pub const m_hScriptScope: usize = 0x8; // HSCRIPT
    pub const m_nInitialSeed: usize = 0x9C; // int32_t
}

pub mod CScriptedSequence {
    pub const m_iszEntry: usize = 0x4B0; // CUtlSymbolLarge
    pub const m_iszPreIdle: usize = 0x4B8; // CUtlSymbolLarge
    pub const m_iszPlay: usize = 0x4C0; // CUtlSymbolLarge
    pub const m_iszPostIdle: usize = 0x4C8; // CUtlSymbolLarge
    pub const m_iszModifierToAddOnPlay: usize = 0x4D0; // CUtlSymbolLarge
    pub const m_iszNextScript: usize = 0x4D8; // CUtlSymbolLarge
    pub const m_iszEntity: usize = 0x4E0; // CUtlSymbolLarge
    pub const m_iszSyncGroup: usize = 0x4E8; // CUtlSymbolLarge
    pub const m_nMoveTo: usize = 0x4F0; // ScriptedMoveTo_t
    pub const m_bIsPlayingPreIdle: usize = 0x4F4; // bool
    pub const m_bIsPlayingEntry: usize = 0x4F5; // bool
    pub const m_bIsPlayingAction: usize = 0x4F6; // bool
    pub const m_bIsPlayingPostIdle: usize = 0x4F7; // bool
    pub const m_bLoopPreIdleSequence: usize = 0x4F8; // bool
    pub const m_bLoopActionSequence: usize = 0x4F9; // bool
    pub const m_bLoopPostIdleSequence: usize = 0x4FA; // bool
    pub const m_bSynchPostIdles: usize = 0x4FB; // bool
    pub const m_bIgnoreGravity: usize = 0x4FC; // bool
    pub const m_bDisableNPCCollisions: usize = 0x4FD; // bool
    pub const m_bKeepAnimgraphLockedPost: usize = 0x4FE; // bool
    pub const m_bDontAddModifiers: usize = 0x4FF; // bool
    pub const m_flRadius: usize = 0x500; // float
    pub const m_flRepeat: usize = 0x504; // float
    pub const m_flPlayAnimFadeInTime: usize = 0x508; // float
    pub const m_flMoveInterpTime: usize = 0x50C; // float
    pub const m_flAngRate: usize = 0x510; // float
    pub const m_iDelay: usize = 0x514; // int32_t
    pub const m_startTime: usize = 0x518; // GameTime_t
    pub const m_bWaitForBeginSequence: usize = 0x51C; // bool
    pub const m_saved_effects: usize = 0x520; // int32_t
    pub const m_savedFlags: usize = 0x524; // int32_t
    pub const m_savedCollisionGroup: usize = 0x528; // int32_t
    pub const m_interruptable: usize = 0x52C; // bool
    pub const m_sequenceStarted: usize = 0x52D; // bool
    pub const m_bPrevAnimatedEveryTick: usize = 0x52E; // bool
    pub const m_bForcedAnimatedEveryTick: usize = 0x52F; // bool
    pub const m_bPositionRelativeToOtherEntity: usize = 0x530; // bool
    pub const m_hTargetEnt: usize = 0x534; // CHandle<CBaseEntity>
    pub const m_hNextCine: usize = 0x538; // CHandle<CScriptedSequence>
    pub const m_bThinking: usize = 0x53C; // bool
    pub const m_bInitiatedSelfDelete: usize = 0x53D; // bool
    pub const m_bIsTeleportingDueToMoveTo: usize = 0x53E; // bool
    pub const m_bAllowCustomInterruptConditions: usize = 0x53F; // bool
    pub const m_hLastFoundEntity: usize = 0x540; // CHandle<CBaseEntity>
    pub const m_hForcedTarget: usize = 0x544; // CHandle<CBaseAnimGraph>
    pub const m_bDontCancelOtherSequences: usize = 0x548; // bool
    pub const m_bForceSynch: usize = 0x549; // bool
    pub const m_bTargetWasAsleep: usize = 0x54A; // bool
    pub const m_bPreventUpdateYawOnFinish: usize = 0x54B; // bool
    pub const m_bEnsureOnNavmeshOnFinish: usize = 0x54C; // bool
    pub const m_onDeathBehavior: usize = 0x550; // ScriptedOnDeath_t
    pub const m_ConflictResponse: usize = 0x554; // ScriptedConflictResponse_t
    pub const m_OnBeginSequence: usize = 0x558; // CEntityIOOutput
    pub const m_OnActionStartOrLoop: usize = 0x580; // CEntityIOOutput
    pub const m_OnEndSequence: usize = 0x5A8; // CEntityIOOutput
    pub const m_OnPostIdleEndSequence: usize = 0x5D0; // CEntityIOOutput
    pub const m_OnCancelSequence: usize = 0x5F8; // CEntityIOOutput
    pub const m_OnCancelFailedSequence: usize = 0x620; // CEntityIOOutput
    pub const m_OnScriptEvent: usize = 0x648; // CEntityIOOutput[8]
    pub const m_matOtherToMain: usize = 0x790; // CTransform
    pub const m_hInteractionMainEntity: usize = 0x7B0; // CHandle<CBaseEntity>
    pub const m_iPlayerDeathBehavior: usize = 0x7B4; // int32_t
}

pub mod CSensorGrenadeProjectile {
    pub const m_fExpireTime: usize = 0xA40; // GameTime_t
    pub const m_fNextDetectPlayerSound: usize = 0xA44; // GameTime_t
    pub const m_hDisplayGrenade: usize = 0xA48; // CHandle<CBaseEntity>
}

pub mod CShatterGlassShard {
    pub const m_hShardHandle: usize = 0x8; // uint32_t
    pub const m_vecPanelVertices: usize = 0x10; // CUtlVector<Vector2D>
    pub const m_vLocalPanelSpaceOrigin: usize = 0x28; // Vector2D
    pub const m_hModel: usize = 0x30; // CStrongHandle<InfoForResourceTypeCModel>
    pub const m_hPhysicsEntity: usize = 0x38; // CHandle<CShatterGlassShardPhysics>
    pub const m_hParentPanel: usize = 0x3C; // CHandle<CFuncShatterglass>
    pub const m_hParentShard: usize = 0x40; // uint32_t
    pub const m_ShatterStressType: usize = 0x44; // ShatterGlassStressType
    pub const m_vecStressVelocity: usize = 0x48; // Vector
    pub const m_bCreatedModel: usize = 0x54; // bool
    pub const m_flLongestEdge: usize = 0x58; // float
    pub const m_flShortestEdge: usize = 0x5C; // float
    pub const m_flLongestAcross: usize = 0x60; // float
    pub const m_flShortestAcross: usize = 0x64; // float
    pub const m_flSumOfAllEdges: usize = 0x68; // float
    pub const m_flArea: usize = 0x6C; // float
    pub const m_nOnFrameEdge: usize = 0x70; // OnFrame
    pub const m_nParentPanelsNthShard: usize = 0x74; // int32_t
    pub const m_nSubShardGeneration: usize = 0x78; // int32_t
    pub const m_vecAverageVertPosition: usize = 0x7C; // Vector2D
    pub const m_bAverageVertPositionIsValid: usize = 0x84; // bool
    pub const m_vecPanelSpaceStressPositionA: usize = 0x88; // Vector2D
    pub const m_vecPanelSpaceStressPositionB: usize = 0x90; // Vector2D
    pub const m_bStressPositionAIsValid: usize = 0x98; // bool
    pub const m_bStressPositionBIsValid: usize = 0x99; // bool
    pub const m_bFlaggedForRemoval: usize = 0x9A; // bool
    pub const m_flPhysicsEntitySpawnedAtTime: usize = 0x9C; // GameTime_t
    pub const m_bShatterRateLimited: usize = 0xA0; // bool
    pub const m_hEntityHittingMe: usize = 0xA4; // CHandle<CBaseEntity>
    pub const m_vecNeighbors: usize = 0xA8; // CUtlVector<uint32_t>
}

pub mod CShatterGlassShardPhysics {
    pub const m_bDebris: usize = 0xB78; // bool
    pub const m_hParentShard: usize = 0xB7C; // uint32_t
    pub const m_ShardDesc: usize = 0xB80; // shard_model_desc_t
}

pub mod CSimTimer {
    pub const m_interval: usize = 0x8; // float
}

pub mod CSimpleSimTimer {
    pub const m_next: usize = 0x0; // GameTime_t
    pub const m_nWorldGroupId: usize = 0x4; // WorldGroupId_t
}

pub mod CSingleplayRules {
    pub const m_bSinglePlayerGameEnding: usize = 0x90; // bool
}

pub mod CSkeletonAnimationController {
    pub const m_pSkeletonInstance: usize = 0x8; // CSkeletonInstance*
}

pub mod CSkeletonInstance {
    pub const m_modelState: usize = 0x160; // CModelState
    pub const m_bIsAnimationEnabled: usize = 0x390; // bool
    pub const m_bUseParentRenderBounds: usize = 0x391; // bool
    pub const m_bDisableSolidCollisionsForHierarchy: usize = 0x392; // bool
    pub const m_bDirtyMotionType: usize = 0x0; // bitfield:1
    pub const m_bIsGeneratingLatchedParentSpaceState: usize = 0x0; // bitfield:1
    pub const m_materialGroup: usize = 0x394; // CUtlStringToken
    pub const m_nHitboxSet: usize = 0x398; // uint8_t
}

pub mod CSkillDamage {
    pub const m_flDamage: usize = 0x0; // CSkillFloat
    pub const m_flPhysicsForceDamage: usize = 0x10; // float
}

pub mod CSkillFloat {
    pub const m_pValue: usize = 0x0; // float[4]
}

pub mod CSkillInt {
    pub const m_pValue: usize = 0x0; // int32_t[4]
}

pub mod CSkyCamera {
    pub const m_skyboxData: usize = 0x4B0; // sky3dparams_t
    pub const m_skyboxSlotToken: usize = 0x540; // CUtlStringToken
    pub const m_bUseAngles: usize = 0x544; // bool
    pub const m_pNext: usize = 0x548; // CSkyCamera*
}

pub mod CSkyboxReference {
    pub const m_worldGroupId: usize = 0x4B0; // WorldGroupId_t
    pub const m_hSkyCamera: usize = 0x4B4; // CHandle<CSkyCamera>
}

pub mod CSmokeGrenadeProjectile {
    pub const m_nSmokeEffectTickBegin: usize = 0xA58; // int32_t
    pub const m_bDidSmokeEffect: usize = 0xA5C; // bool
    pub const m_nRandomSeed: usize = 0xA60; // int32_t
    pub const m_vSmokeColor: usize = 0xA64; // Vector
    pub const m_vSmokeDetonationPos: usize = 0xA70; // Vector
    pub const m_VoxelFrameData: usize = 0xA80; // CUtlVector<uint8_t>
    pub const m_flLastBounce: usize = 0xA98; // GameTime_t
    pub const m_fllastSimulationTime: usize = 0xA9C; // GameTime_t
}

pub mod CSmoothFunc {
    pub const m_flSmoothAmplitude: usize = 0x8; // float
    pub const m_flSmoothBias: usize = 0xC; // float
    pub const m_flSmoothDuration: usize = 0x10; // float
    pub const m_flSmoothRemainingTime: usize = 0x14; // float
    pub const m_nSmoothDir: usize = 0x18; // int32_t
}

pub mod CSound {
    pub const m_hOwner: usize = 0x0; // CHandle<CBaseEntity>
    pub const m_hTarget: usize = 0x4; // CHandle<CBaseEntity>
    pub const m_iVolume: usize = 0x8; // int32_t
    pub const m_flOcclusionScale: usize = 0xC; // float
    pub const m_iType: usize = 0x10; // int32_t
    pub const m_iNextAudible: usize = 0x14; // int32_t
    pub const m_flExpireTime: usize = 0x18; // GameTime_t
    pub const m_iNext: usize = 0x1C; // int16_t
    pub const m_bNoExpirationTime: usize = 0x1E; // bool
    pub const m_ownerChannelIndex: usize = 0x20; // int32_t
    pub const m_vecOrigin: usize = 0x24; // Vector
    pub const m_bHasOwner: usize = 0x30; // bool
}

pub mod CSoundAreaEntityBase {
    pub const m_bDisabled: usize = 0x4B0; // bool
    pub const m_iszSoundAreaType: usize = 0x4B8; // CUtlSymbolLarge
    pub const m_vPos: usize = 0x4C0; // Vector
}

pub mod CSoundAreaEntityOrientedBox {
    pub const m_vMin: usize = 0x4D0; // Vector
    pub const m_vMax: usize = 0x4DC; // Vector
}

pub mod CSoundAreaEntitySphere {
    pub const m_flRadius: usize = 0x4D0; // float
}

pub mod CSoundEnt {
    pub const m_iFreeSound: usize = 0x4B0; // int32_t
    pub const m_iActiveSound: usize = 0x4B4; // int32_t
    pub const m_cLastActiveSounds: usize = 0x4B8; // int32_t
    pub const m_SoundPool: usize = 0x4BC; // CSound[128]
}

pub mod CSoundEnvelope {
    pub const m_current: usize = 0x0; // float
    pub const m_target: usize = 0x4; // float
    pub const m_rate: usize = 0x8; // float
    pub const m_forceupdate: usize = 0xC; // bool
}

pub mod CSoundEventAABBEntity {
    pub const m_vMins: usize = 0x558; // Vector
    pub const m_vMaxs: usize = 0x564; // Vector
}

pub mod CSoundEventEntity {
    pub const m_bStartOnSpawn: usize = 0x4B0; // bool
    pub const m_bToLocalPlayer: usize = 0x4B1; // bool
    pub const m_bStopOnNew: usize = 0x4B2; // bool
    pub const m_bSaveRestore: usize = 0x4B3; // bool
    pub const m_bSavedIsPlaying: usize = 0x4B4; // bool
    pub const m_flSavedElapsedTime: usize = 0x4B8; // float
    pub const m_iszSourceEntityName: usize = 0x4C0; // CUtlSymbolLarge
    pub const m_iszAttachmentName: usize = 0x4C8; // CUtlSymbolLarge
    pub const m_onGUIDChanged: usize = 0x4D0; // CEntityOutputTemplate<uint64_t>
    pub const m_onSoundFinished: usize = 0x4F8; // CEntityIOOutput
    pub const m_iszSoundName: usize = 0x540; // CUtlSymbolLarge
    pub const m_hSource: usize = 0x550; // CEntityHandle
}

pub mod CSoundEventOBBEntity {
    pub const m_vMins: usize = 0x558; // Vector
    pub const m_vMaxs: usize = 0x564; // Vector
}

pub mod CSoundEventParameter {
    pub const m_iszParamName: usize = 0x4B8; // CUtlSymbolLarge
    pub const m_flFloatValue: usize = 0x4C0; // float
}

pub mod CSoundEventPathCornerEntity {
    pub const m_iszPathCorner: usize = 0x558; // CUtlSymbolLarge
    pub const m_iCountMax: usize = 0x560; // int32_t
    pub const m_flDistanceMax: usize = 0x564; // float
    pub const m_flDistMaxSqr: usize = 0x568; // float
    pub const m_flDotProductMax: usize = 0x56C; // float
    pub const bPlaying: usize = 0x570; // bool
}

pub mod CSoundOpvarSetAABBEntity {
    pub const m_vDistanceInnerMins: usize = 0x648; // Vector
    pub const m_vDistanceInnerMaxs: usize = 0x654; // Vector
    pub const m_vDistanceOuterMins: usize = 0x660; // Vector
    pub const m_vDistanceOuterMaxs: usize = 0x66C; // Vector
    pub const m_nAABBDirection: usize = 0x678; // int32_t
    pub const m_vInnerMins: usize = 0x67C; // Vector
    pub const m_vInnerMaxs: usize = 0x688; // Vector
    pub const m_vOuterMins: usize = 0x694; // Vector
    pub const m_vOuterMaxs: usize = 0x6A0; // Vector
}

pub mod CSoundOpvarSetEntity {
    pub const m_iszStackName: usize = 0x4B8; // CUtlSymbolLarge
    pub const m_iszOperatorName: usize = 0x4C0; // CUtlSymbolLarge
    pub const m_iszOpvarName: usize = 0x4C8; // CUtlSymbolLarge
    pub const m_nOpvarType: usize = 0x4D0; // int32_t
    pub const m_nOpvarIndex: usize = 0x4D4; // int32_t
    pub const m_flOpvarValue: usize = 0x4D8; // float
    pub const m_OpvarValueString: usize = 0x4E0; // CUtlSymbolLarge
    pub const m_bSetOnSpawn: usize = 0x4E8; // bool
}

pub mod CSoundOpvarSetOBBWindEntity {
    pub const m_vMins: usize = 0x548; // Vector
    pub const m_vMaxs: usize = 0x554; // Vector
    pub const m_vDistanceMins: usize = 0x560; // Vector
    pub const m_vDistanceMaxs: usize = 0x56C; // Vector
    pub const m_flWindMin: usize = 0x578; // float
    pub const m_flWindMax: usize = 0x57C; // float
    pub const m_flWindMapMin: usize = 0x580; // float
    pub const m_flWindMapMax: usize = 0x584; // float
}

pub mod CSoundOpvarSetPathCornerEntity {
    pub const m_flDistMinSqr: usize = 0x660; // float
    pub const m_flDistMaxSqr: usize = 0x664; // float
    pub const m_iszPathCornerEntityName: usize = 0x668; // CUtlSymbolLarge
}

pub mod CSoundOpvarSetPointBase {
    pub const m_bDisabled: usize = 0x4B0; // bool
    pub const m_hSource: usize = 0x4B4; // CEntityHandle
    pub const m_iszSourceEntityName: usize = 0x4C0; // CUtlSymbolLarge
    pub const m_vLastPosition: usize = 0x518; // Vector
    pub const m_iszStackName: usize = 0x528; // CUtlSymbolLarge
    pub const m_iszOperatorName: usize = 0x530; // CUtlSymbolLarge
    pub const m_iszOpvarName: usize = 0x538; // CUtlSymbolLarge
    pub const m_iOpvarIndex: usize = 0x540; // int32_t
    pub const m_bUseAutoCompare: usize = 0x544; // bool
}

pub mod CSoundOpvarSetPointEntity {
    pub const m_OnEnter: usize = 0x548; // CEntityIOOutput
    pub const m_OnExit: usize = 0x570; // CEntityIOOutput
    pub const m_bAutoDisable: usize = 0x598; // bool
    pub const m_flDistanceMin: usize = 0x5DC; // float
    pub const m_flDistanceMax: usize = 0x5E0; // float
    pub const m_flDistanceMapMin: usize = 0x5E4; // float
    pub const m_flDistanceMapMax: usize = 0x5E8; // float
    pub const m_flOcclusionRadius: usize = 0x5EC; // float
    pub const m_flOcclusionMin: usize = 0x5F0; // float
    pub const m_flOcclusionMax: usize = 0x5F4; // float
    pub const m_flValSetOnDisable: usize = 0x5F8; // float
    pub const m_bSetValueOnDisable: usize = 0x5FC; // bool
    pub const m_nSimulationMode: usize = 0x600; // int32_t
    pub const m_nVisibilitySamples: usize = 0x604; // int32_t
    pub const m_vDynamicProxyPoint: usize = 0x608; // Vector
    pub const m_flDynamicMaximumOcclusion: usize = 0x614; // float
    pub const m_hDynamicEntity: usize = 0x618; // CEntityHandle
    pub const m_iszDynamicEntityName: usize = 0x620; // CUtlSymbolLarge
    pub const m_flPathingDistanceNormFactor: usize = 0x628; // float
    pub const m_vPathingSourcePos: usize = 0x62C; // Vector
    pub const m_vPathingListenerPos: usize = 0x638; // Vector
    pub const m_nPathingSourceIndex: usize = 0x644; // int32_t
}

pub mod CSoundPatch {
    pub const m_pitch: usize = 0x8; // CSoundEnvelope
    pub const m_volume: usize = 0x18; // CSoundEnvelope
    pub const m_shutdownTime: usize = 0x30; // float
    pub const m_flLastTime: usize = 0x34; // float
    pub const m_iszSoundScriptName: usize = 0x38; // CUtlSymbolLarge
    pub const m_hEnt: usize = 0x40; // CHandle<CBaseEntity>
    pub const m_soundEntityIndex: usize = 0x44; // CEntityIndex
    pub const m_soundOrigin: usize = 0x48; // Vector
    pub const m_isPlaying: usize = 0x54; // int32_t
    pub const m_Filter: usize = 0x58; // CCopyRecipientFilter
    pub const m_flCloseCaptionDuration: usize = 0x80; // float
    pub const m_bUpdatedSoundOrigin: usize = 0x84; // bool
    pub const m_iszClassName: usize = 0x88; // CUtlSymbolLarge
}

pub mod CSoundStackSave {
    pub const m_iszStackName: usize = 0x4B0; // CUtlSymbolLarge
}

pub mod CSpotlightEnd {
    pub const m_flLightScale: usize = 0x700; // float
    pub const m_Radius: usize = 0x704; // float
    pub const m_vSpotlightDir: usize = 0x708; // Vector
    pub const m_vSpotlightOrg: usize = 0x714; // Vector
}

pub mod CSprite {
    pub const m_hSpriteMaterial: usize = 0x700; // CStrongHandle<InfoForResourceTypeIMaterial2>
    pub const m_hAttachedToEntity: usize = 0x708; // CHandle<CBaseEntity>
    pub const m_nAttachment: usize = 0x70C; // AttachmentHandle_t
    pub const m_flSpriteFramerate: usize = 0x710; // float
    pub const m_flFrame: usize = 0x714; // float
    pub const m_flDieTime: usize = 0x718; // GameTime_t
    pub const m_nBrightness: usize = 0x728; // uint32_t
    pub const m_flBrightnessDuration: usize = 0x72C; // float
    pub const m_flSpriteScale: usize = 0x730; // float
    pub const m_flScaleDuration: usize = 0x734; // float
    pub const m_bWorldSpaceScale: usize = 0x738; // bool
    pub const m_flGlowProxySize: usize = 0x73C; // float
    pub const m_flHDRColorScale: usize = 0x740; // float
    pub const m_flLastTime: usize = 0x744; // GameTime_t
    pub const m_flMaxFrame: usize = 0x748; // float
    pub const m_flStartScale: usize = 0x74C; // float
    pub const m_flDestScale: usize = 0x750; // float
    pub const m_flScaleTimeStart: usize = 0x754; // GameTime_t
    pub const m_nStartBrightness: usize = 0x758; // int32_t
    pub const m_nDestBrightness: usize = 0x75C; // int32_t
    pub const m_flBrightnessTimeStart: usize = 0x760; // GameTime_t
    pub const m_nSpriteWidth: usize = 0x764; // int32_t
    pub const m_nSpriteHeight: usize = 0x768; // int32_t
}

pub mod CStopwatch {
    pub const m_interval: usize = 0xC; // float
}

pub mod CStopwatchBase {
    pub const m_fIsRunning: usize = 0x8; // bool
}

pub mod CSun {
    pub const m_vDirection: usize = 0x700; // Vector
    pub const m_clrOverlay: usize = 0x70C; // Color
    pub const m_iszEffectName: usize = 0x710; // CUtlSymbolLarge
    pub const m_iszSSEffectName: usize = 0x718; // CUtlSymbolLarge
    pub const m_bOn: usize = 0x720; // bool
    pub const m_bmaxColor: usize = 0x721; // bool
    pub const m_flSize: usize = 0x724; // float
    pub const m_flRotation: usize = 0x728; // float
    pub const m_flHazeScale: usize = 0x72C; // float
    pub const m_flAlphaHaze: usize = 0x730; // float
    pub const m_flAlphaHdr: usize = 0x734; // float
    pub const m_flAlphaScale: usize = 0x738; // float
    pub const m_flHDRColorScale: usize = 0x73C; // float
    pub const m_flFarZScale: usize = 0x740; // float
}

pub mod CTakeDamageInfo {
    pub const m_vecDamageForce: usize = 0x8; // Vector
    pub const m_vecDamagePosition: usize = 0x14; // Vector
    pub const m_vecReportedPosition: usize = 0x20; // Vector
    pub const m_vecDamageDirection: usize = 0x2C; // Vector
    pub const m_hInflictor: usize = 0x38; // CHandle<CBaseEntity>
    pub const m_hAttacker: usize = 0x3C; // CHandle<CBaseEntity>
    pub const m_hAbility: usize = 0x40; // CHandle<CBaseEntity>
    pub const m_flDamage: usize = 0x44; // float
    pub const m_bitsDamageType: usize = 0x48; // int32_t
    pub const m_iDamageCustom: usize = 0x4C; // int32_t
    pub const m_iAmmoType: usize = 0x50; // AmmoIndex_t
    pub const m_flOriginalDamage: usize = 0x60; // float
    pub const m_bShouldBleed: usize = 0x64; // bool
    pub const m_bShouldSpark: usize = 0x65; // bool
    pub const m_nDamageFlags: usize = 0x70; // TakeDamageFlags_t
    pub const m_nNumObjectsPenetrated: usize = 0x74; // int32_t
    pub const m_hScriptInstance: usize = 0x78; // HSCRIPT
    pub const m_bInTakeDamageFlow: usize = 0x94; // bool
}

pub mod CTakeDamageResult {
    pub const m_nHealthLost: usize = 0x0; // int32_t
    pub const m_nDamageTaken: usize = 0x4; // int32_t
}

pub mod CTakeDamageSummaryScopeGuard {
    pub const m_vecSummaries: usize = 0x8; // CUtlVector<SummaryTakeDamageInfo_t*>
}

pub mod CTankTargetChange {
    pub const m_newTarget: usize = 0x4B0; // CVariantBase<CVariantDefaultAllocator>
    pub const m_newTargetName: usize = 0x4C0; // CUtlSymbolLarge
}

pub mod CTankTrainAI {
    pub const m_hTrain: usize = 0x4B0; // CHandle<CFuncTrackTrain>
    pub const m_hTargetEntity: usize = 0x4B4; // CHandle<CBaseEntity>
    pub const m_soundPlaying: usize = 0x4B8; // int32_t
    pub const m_startSoundName: usize = 0x4D0; // CUtlSymbolLarge
    pub const m_engineSoundName: usize = 0x4D8; // CUtlSymbolLarge
    pub const m_movementSoundName: usize = 0x4E0; // CUtlSymbolLarge
    pub const m_targetEntityName: usize = 0x4E8; // CUtlSymbolLarge
}

pub mod CTeam {
    pub const m_aPlayerControllers: usize = 0x4B0; // CNetworkUtlVectorBase<CHandle<CBasePlayerController>>
    pub const m_aPlayers: usize = 0x4C8; // CNetworkUtlVectorBase<CHandle<CBasePlayerPawn>>
    pub const m_iScore: usize = 0x4E0; // int32_t
    pub const m_szTeamname: usize = 0x4E4; // char[129]
}

pub mod CTestEffect {
    pub const m_iLoop: usize = 0x4B0; // int32_t
    pub const m_iBeam: usize = 0x4B4; // int32_t
    pub const m_pBeam: usize = 0x4B8; // CBeam*[24]
    pub const m_flBeamTime: usize = 0x578; // GameTime_t[24]
    pub const m_flStartTime: usize = 0x5D8; // GameTime_t
}

pub mod CTextureBasedAnimatable {
    pub const m_bLoop: usize = 0x700; // bool
    pub const m_flFPS: usize = 0x704; // float
    pub const m_hPositionKeys: usize = 0x708; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_hRotationKeys: usize = 0x710; // CStrongHandle<InfoForResourceTypeCTextureBase>
    pub const m_vAnimationBoundsMin: usize = 0x718; // Vector
    pub const m_vAnimationBoundsMax: usize = 0x724; // Vector
    pub const m_flStartTime: usize = 0x730; // float
    pub const m_flStartFrame: usize = 0x734; // float
}

pub mod CTimeline {
    pub const m_flValues: usize = 0x10; // float[64]
    pub const m_nValueCounts: usize = 0x110; // int32_t[64]
    pub const m_nBucketCount: usize = 0x210; // int32_t
    pub const m_flInterval: usize = 0x214; // float
    pub const m_flFinalValue: usize = 0x218; // float
    pub const m_nCompressionType: usize = 0x21C; // TimelineCompression_t
    pub const m_bStopped: usize = 0x220; // bool
}

pub mod CTimerEntity {
    pub const m_OnTimer: usize = 0x4B0; // CEntityIOOutput
    pub const m_OnTimerHigh: usize = 0x4D8; // CEntityIOOutput
    pub const m_OnTimerLow: usize = 0x500; // CEntityIOOutput
    pub const m_iDisabled: usize = 0x528; // int32_t
    pub const m_flInitialDelay: usize = 0x52C; // float
    pub const m_flRefireTime: usize = 0x530; // float
    pub const m_bUpDownState: usize = 0x534; // bool
    pub const m_iUseRandomTime: usize = 0x538; // int32_t
    pub const m_bPauseAfterFiring: usize = 0x53C; // bool
    pub const m_flLowerRandomBound: usize = 0x540; // float
    pub const m_flUpperRandomBound: usize = 0x544; // float
    pub const m_flRemainingTime: usize = 0x548; // float
    pub const m_bPaused: usize = 0x54C; // bool
}

pub mod CTonemapController2 {
    pub const m_flAutoExposureMin: usize = 0x4B0; // float
    pub const m_flAutoExposureMax: usize = 0x4B4; // float
    pub const m_flTonemapPercentTarget: usize = 0x4B8; // float
    pub const m_flTonemapPercentBrightPixels: usize = 0x4BC; // float
    pub const m_flTonemapMinAvgLum: usize = 0x4C0; // float
    pub const m_flExposureAdaptationSpeedUp: usize = 0x4C4; // float
    pub const m_flExposureAdaptationSpeedDown: usize = 0x4C8; // float
    pub const m_flTonemapEVSmoothingRange: usize = 0x4CC; // float
}

pub mod CTonemapTrigger {
    pub const m_tonemapControllerName: usize = 0x8A8; // CUtlSymbolLarge
    pub const m_hTonemapController: usize = 0x8B0; // CEntityHandle
}

pub mod CTriggerActiveWeaponDetect {
    pub const m_OnTouchedActiveWeapon: usize = 0x8A8; // CEntityIOOutput
    pub const m_iszWeaponClassName: usize = 0x8D0; // CUtlSymbolLarge
}

pub mod CTriggerBrush {
    pub const m_OnStartTouch: usize = 0x700; // CEntityIOOutput
    pub const m_OnEndTouch: usize = 0x728; // CEntityIOOutput
    pub const m_OnUse: usize = 0x750; // CEntityIOOutput
    pub const m_iInputFilter: usize = 0x778; // int32_t
    pub const m_iDontMessageParent: usize = 0x77C; // int32_t
}

pub mod CTriggerBuoyancy {
    pub const m_BuoyancyHelper: usize = 0x8A8; // CBuoyancyHelper
    pub const m_flFluidDensity: usize = 0x8C8; // float
}

pub mod CTriggerDetectBulletFire {
    pub const m_bPlayerFireOnly: usize = 0x8A8; // bool
    pub const m_OnDetectedBulletFire: usize = 0x8B0; // CEntityIOOutput
}

pub mod CTriggerDetectExplosion {
    pub const m_OnDetectedExplosion: usize = 0x8E0; // CEntityIOOutput
}

pub mod CTriggerFan {
    pub const m_vFanOrigin: usize = 0x8A8; // Vector
    pub const m_vFanEnd: usize = 0x8B4; // Vector
    pub const m_vNoise: usize = 0x8C0; // Vector
    pub const m_flForce: usize = 0x8CC; // float
    pub const m_flPlayerForce: usize = 0x8D0; // float
    pub const m_flRampTime: usize = 0x8D4; // float
    pub const m_bFalloff: usize = 0x8D8; // bool
    pub const m_bPushPlayer: usize = 0x8D9; // bool
    pub const m_bRampDown: usize = 0x8DA; // bool
    pub const m_bAddNoise: usize = 0x8DB; // bool
    pub const m_RampTimer: usize = 0x8E0; // CountdownTimer
}

pub mod CTriggerGameEvent {
    pub const m_strStartTouchEventName: usize = 0x8A8; // CUtlString
    pub const m_strEndTouchEventName: usize = 0x8B0; // CUtlString
    pub const m_strTriggerID: usize = 0x8B8; // CUtlString
}

pub mod CTriggerHurt {
    pub const m_flOriginalDamage: usize = 0x8A8; // float
    pub const m_flDamage: usize = 0x8AC; // float
    pub const m_flDamageCap: usize = 0x8B0; // float
    pub const m_flLastDmgTime: usize = 0x8B4; // GameTime_t
    pub const m_flForgivenessDelay: usize = 0x8B8; // float
    pub const m_bitsDamageInflict: usize = 0x8BC; // int32_t
    pub const m_damageModel: usize = 0x8C0; // int32_t
    pub const m_bNoDmgForce: usize = 0x8C4; // bool
    pub const m_vDamageForce: usize = 0x8C8; // Vector
    pub const m_thinkAlways: usize = 0x8D4; // bool
    pub const m_hurtThinkPeriod: usize = 0x8D8; // float
    pub const m_OnHurt: usize = 0x8E0; // CEntityIOOutput
    pub const m_OnHurtPlayer: usize = 0x908; // CEntityIOOutput
    pub const m_hurtEntities: usize = 0x930; // CUtlVector<CHandle<CBaseEntity>>
}

pub mod CTriggerImpact {
    pub const m_flMagnitude: usize = 0x8D0; // float
    pub const m_flNoise: usize = 0x8D4; // float
    pub const m_flViewkick: usize = 0x8D8; // float
    pub const m_pOutputForce: usize = 0x8E0; // CEntityOutputTemplate<Vector>
}

pub mod CTriggerLerpObject {
    pub const m_iszLerpTarget: usize = 0x8A8; // CUtlSymbolLarge
    pub const m_hLerpTarget: usize = 0x8B0; // CHandle<CBaseEntity>
    pub const m_iszLerpTargetAttachment: usize = 0x8B8; // CUtlSymbolLarge
    pub const m_hLerpTargetAttachment: usize = 0x8C0; // AttachmentHandle_t
    pub const m_flLerpDuration: usize = 0x8C4; // float
    pub const m_bLerpRestoreMoveType: usize = 0x8C8; // bool
    pub const m_bSingleLerpObject: usize = 0x8C9; // bool
    pub const m_vecLerpingObjects: usize = 0x8D0; // CUtlVector<lerpdata_t>
    pub const m_iszLerpEffect: usize = 0x8E8; // CUtlSymbolLarge
    pub const m_iszLerpSound: usize = 0x8F0; // CUtlSymbolLarge
    pub const m_OnLerpStarted: usize = 0x8F8; // CEntityIOOutput
    pub const m_OnLerpFinished: usize = 0x920; // CEntityIOOutput
}

pub mod CTriggerLook {
    pub const m_hLookTarget: usize = 0x8D0; // CHandle<CBaseEntity>
    pub const m_flFieldOfView: usize = 0x8D4; // float
    pub const m_flLookTime: usize = 0x8D8; // float
    pub const m_flLookTimeTotal: usize = 0x8DC; // float
    pub const m_flLookTimeLast: usize = 0x8E0; // GameTime_t
    pub const m_flTimeoutDuration: usize = 0x8E4; // float
    pub const m_bTimeoutFired: usize = 0x8E8; // bool
    pub const m_bIsLooking: usize = 0x8E9; // bool
    pub const m_b2DFOV: usize = 0x8EA; // bool
    pub const m_bUseVelocity: usize = 0x8EB; // bool
    pub const m_hActivator: usize = 0x8EC; // CHandle<CBaseEntity>
    pub const m_bTestOcclusion: usize = 0x8F0; // bool
    pub const m_OnTimeout: usize = 0x8F8; // CEntityIOOutput
    pub const m_OnStartLook: usize = 0x920; // CEntityIOOutput
    pub const m_OnEndLook: usize = 0x948; // CEntityIOOutput
}

pub mod CTriggerMultiple {
    pub const m_OnTrigger: usize = 0x8A8; // CEntityIOOutput
}

pub mod CTriggerPhysics {
    pub const m_gravityScale: usize = 0x8B8; // float
    pub const m_linearLimit: usize = 0x8BC; // float
    pub const m_linearDamping: usize = 0x8C0; // float
    pub const m_angularLimit: usize = 0x8C4; // float
    pub const m_angularDamping: usize = 0x8C8; // float
    pub const m_linearForce: usize = 0x8CC; // float
    pub const m_flFrequency: usize = 0x8D0; // float
    pub const m_flDampingRatio: usize = 0x8D4; // float
    pub const m_vecLinearForcePointAt: usize = 0x8D8; // Vector
    pub const m_bCollapseToForcePoint: usize = 0x8E4; // bool
    pub const m_vecLinearForcePointAtWorld: usize = 0x8E8; // Vector
    pub const m_vecLinearForceDirection: usize = 0x8F4; // Vector
    pub const m_bConvertToDebrisWhenPossible: usize = 0x900; // bool
}

pub mod CTriggerProximity {
    pub const m_hMeasureTarget: usize = 0x8A8; // CHandle<CBaseEntity>
    pub const m_iszMeasureTarget: usize = 0x8B0; // CUtlSymbolLarge
    pub const m_fRadius: usize = 0x8B8; // float
    pub const m_nTouchers: usize = 0x8BC; // int32_t
    pub const m_NearestEntityDistance: usize = 0x8C0; // CEntityOutputTemplate<float>
}

pub mod CTriggerPush {
    pub const m_angPushEntitySpace: usize = 0x8A8; // QAngle
    pub const m_vecPushDirEntitySpace: usize = 0x8B4; // Vector
    pub const m_bTriggerOnStartTouch: usize = 0x8C0; // bool
    pub const m_flAlternateTicksFix: usize = 0x8C4; // float
    pub const m_flPushSpeed: usize = 0x8C8; // float
}

pub mod CTriggerRemove {
    pub const m_OnRemove: usize = 0x8A8; // CEntityIOOutput
}

pub mod CTriggerSave {
    pub const m_bForceNewLevelUnit: usize = 0x8A8; // bool
    pub const m_fDangerousTimer: usize = 0x8AC; // float
    pub const m_minHitPoints: usize = 0x8B0; // int32_t
}

pub mod CTriggerSndSosOpvar {
    pub const m_hTouchingPlayers: usize = 0x8A8; // CUtlVector<CHandle<CBaseEntity>>
    pub const m_flPosition: usize = 0x8C0; // Vector
    pub const m_flCenterSize: usize = 0x8CC; // float
    pub const m_flMinVal: usize = 0x8D0; // float
    pub const m_flMaxVal: usize = 0x8D4; // float
    pub const m_flWait: usize = 0x8D8; // float
    pub const m_opvarName: usize = 0x8E0; // CUtlSymbolLarge
    pub const m_stackName: usize = 0x8E8; // CUtlSymbolLarge
    pub const m_operatorName: usize = 0x8F0; // CUtlSymbolLarge
    pub const m_bVolIs2D: usize = 0x8F8; // bool
    pub const m_opvarNameChar: usize = 0x8F9; // char[256]
    pub const m_stackNameChar: usize = 0x9F9; // char[256]
    pub const m_operatorNameChar: usize = 0xAF9; // char[256]
    pub const m_VecNormPos: usize = 0xBFC; // Vector
    pub const m_flNormCenterSize: usize = 0xC08; // float
}

pub mod CTriggerSoundscape {
    pub const m_hSoundscape: usize = 0x8A8; // CHandle<CEnvSoundscapeTriggerable>
    pub const m_SoundscapeName: usize = 0x8B0; // CUtlSymbolLarge
    pub const m_spectators: usize = 0x8B8; // CUtlVector<CHandle<CBasePlayerPawn>>
}

pub mod CTriggerTeleport {
    pub const m_iLandmark: usize = 0x8A8; // CUtlSymbolLarge
    pub const m_bUseLandmarkAngles: usize = 0x8B0; // bool
    pub const m_bMirrorPlayer: usize = 0x8B1; // bool
}

pub mod CTriggerToggleSave {
    pub const m_bDisabled: usize = 0x8A8; // bool
}

pub mod CTriggerVolume {
    pub const m_iFilterName: usize = 0x700; // CUtlSymbolLarge
    pub const m_hFilter: usize = 0x708; // CHandle<CBaseFilter>
}

pub mod CVoteController {
    pub const m_iActiveIssueIndex: usize = 0x4B0; // int32_t
    pub const m_iOnlyTeamToVote: usize = 0x4B4; // int32_t
    pub const m_nVoteOptionCount: usize = 0x4B8; // int32_t[5]
    pub const m_nPotentialVotes: usize = 0x4CC; // int32_t
    pub const m_bIsYesNoVote: usize = 0x4D0; // bool
    pub const m_acceptingVotesTimer: usize = 0x4D8; // CountdownTimer
    pub const m_executeCommandTimer: usize = 0x4F0; // CountdownTimer
    pub const m_resetVoteTimer: usize = 0x508; // CountdownTimer
    pub const m_nVotesCast: usize = 0x520; // int32_t[64]
    pub const m_playerHoldingVote: usize = 0x620; // CPlayerSlot
    pub const m_playerOverrideForVote: usize = 0x624; // CPlayerSlot
    pub const m_nHighestCountIndex: usize = 0x628; // int32_t
    pub const m_potentialIssues: usize = 0x630; // CUtlVector<CBaseIssue*>
    pub const m_VoteOptions: usize = 0x648; // CUtlVector<char*>
}

pub mod CWeaponBaseItem {
    pub const m_SequenceCompleteTimer: usize = 0xE20; // CountdownTimer
    pub const m_bRedraw: usize = 0xE38; // bool
}

pub mod CWeaponShield {
    pub const m_flBulletDamageAbsorbed: usize = 0xE40; // float
    pub const m_flLastBulletHitSoundTime: usize = 0xE44; // GameTime_t
    pub const m_flDisplayHealth: usize = 0xE48; // float
}

pub mod CWeaponTaser {
    pub const m_fFireTime: usize = 0xE40; // GameTime_t
}

pub mod CommandToolCommand_t {
    pub const m_bEnabled: usize = 0x0; // bool
    pub const m_bOpened: usize = 0x1; // bool
    pub const m_InternalId: usize = 0x4; // uint32_t
    pub const m_ShortName: usize = 0x8; // CUtlString
    pub const m_ExecMode: usize = 0x10; // CommandExecMode_t
    pub const m_SpawnGroup: usize = 0x18; // CUtlString
    pub const m_PeriodicExecDelay: usize = 0x20; // float
    pub const m_SpecType: usize = 0x24; // CommandEntitySpecType_t
    pub const m_EntitySpec: usize = 0x28; // CUtlString
    pub const m_Commands: usize = 0x30; // CUtlString
    pub const m_SetDebugBits: usize = 0x38; // DebugOverlayBits_t
    pub const m_ClearDebugBits: usize = 0x40; // DebugOverlayBits_t
}

pub mod ConceptHistory_t {
    pub const timeSpoken: usize = 0x0; // float
    pub const m_response: usize = 0x8; // CRR_Response
}

pub mod ConstraintSoundInfo {
    pub const m_vSampler: usize = 0x8; // VelocitySampler
    pub const m_soundProfile: usize = 0x20; // SimpleConstraintSoundProfile
    pub const m_forwardAxis: usize = 0x40; // Vector
    pub const m_iszTravelSoundFwd: usize = 0x50; // CUtlSymbolLarge
    pub const m_iszTravelSoundBack: usize = 0x58; // CUtlSymbolLarge
    pub const m_iszReversalSounds: usize = 0x68; // CUtlSymbolLarge[3]
    pub const m_bPlayTravelSound: usize = 0x80; // bool
    pub const m_bPlayReversalSound: usize = 0x81; // bool
}

pub mod CountdownTimer {
    pub const m_duration: usize = 0x8; // float
    pub const m_timestamp: usize = 0xC; // GameTime_t
    pub const m_timescale: usize = 0x10; // float
    pub const m_nWorldGroupId: usize = 0x14; // WorldGroupId_t
}

pub mod EngineCountdownTimer {
    pub const m_duration: usize = 0x8; // float
    pub const m_timestamp: usize = 0xC; // float
    pub const m_timescale: usize = 0x10; // float
}

pub mod EntityRenderAttribute_t {
    pub const m_ID: usize = 0x30; // CUtlStringToken
    pub const m_Values: usize = 0x34; // Vector4D
}

pub mod EntitySpottedState_t {
    pub const m_bSpotted: usize = 0x8; // bool
    pub const m_bSpottedByMask: usize = 0xC; // uint32_t[2]
}

pub mod Extent {
    pub const lo: usize = 0x0; // Vector
    pub const hi: usize = 0xC; // Vector
}

pub mod FilterDamageType {
    pub const m_iDamageType: usize = 0x508; // int32_t
}

pub mod FilterHealth {
    pub const m_bAdrenalineActive: usize = 0x508; // bool
    pub const m_iHealthMin: usize = 0x50C; // int32_t
    pub const m_iHealthMax: usize = 0x510; // int32_t
}

pub mod FilterTeam {
    pub const m_iFilterTeam: usize = 0x508; // int32_t
}

pub mod GameAmmoTypeInfo_t {
    pub const m_nBuySize: usize = 0x38; // int32_t
    pub const m_nCost: usize = 0x3C; // int32_t
}

pub mod GameTick_t {
    pub const m_Value: usize = 0x0; // int32_t
}

pub mod GameTime_t {
    pub const m_Value: usize = 0x0; // float
}

pub mod HullFlags_t {
    pub const m_bHull_Human: usize = 0x0; // bool
    pub const m_bHull_SmallCentered: usize = 0x1; // bool
    pub const m_bHull_WideHuman: usize = 0x2; // bool
    pub const m_bHull_Tiny: usize = 0x3; // bool
    pub const m_bHull_Medium: usize = 0x4; // bool
    pub const m_bHull_TinyCentered: usize = 0x5; // bool
    pub const m_bHull_Large: usize = 0x6; // bool
    pub const m_bHull_LargeCentered: usize = 0x7; // bool
    pub const m_bHull_MediumTall: usize = 0x8; // bool
    pub const m_bHull_Small: usize = 0x9; // bool
}

pub mod IntervalTimer {
    pub const m_timestamp: usize = 0x8; // GameTime_t
    pub const m_nWorldGroupId: usize = 0xC; // WorldGroupId_t
}

pub mod ModelConfigHandle_t {
    pub const m_Value: usize = 0x0; // uint32_t
}

pub mod ParticleIndex_t {
    pub const m_Value: usize = 0x0; // int32_t
}

pub mod PhysicsRagdollPose_t {
    pub const __m_pChainEntity: usize = 0x8; // CNetworkVarChainer
    pub const m_Transforms: usize = 0x30; // CNetworkUtlVectorBase<CTransform>
    pub const m_hOwner: usize = 0x48; // CHandle<CBaseEntity>
}

pub mod RagdollCreationParams_t {
    pub const m_vForce: usize = 0x0; // Vector
    pub const m_nForceBone: usize = 0xC; // int32_t
}

pub mod RelationshipOverride_t {
    pub const entity: usize = 0x8; // CHandle<CBaseEntity>
    pub const classType: usize = 0xC; // Class_T
}

pub mod Relationship_t {
    pub const disposition: usize = 0x0; // Disposition_t
    pub const priority: usize = 0x4; // int32_t
}

pub mod ResponseContext_t {
    pub const m_iszName: usize = 0x0; // CUtlSymbolLarge
    pub const m_iszValue: usize = 0x8; // CUtlSymbolLarge
    pub const m_fExpirationTime: usize = 0x10; // GameTime_t
}

pub mod ResponseFollowup {
    pub const followup_concept: usize = 0x0; // char*
    pub const followup_contexts: usize = 0x8; // char*
    pub const followup_delay: usize = 0x10; // float
    pub const followup_target: usize = 0x14; // char*
    pub const followup_entityiotarget: usize = 0x1C; // char*
    pub const followup_entityioinput: usize = 0x24; // char*
    pub const followup_entityiodelay: usize = 0x2C; // float
    pub const bFired: usize = 0x30; // bool
}

pub mod ResponseParams {
    pub const odds: usize = 0x10; // int16_t
    pub const flags: usize = 0x12; // int16_t
    pub const m_pFollowup: usize = 0x18; // ResponseFollowup*
}

pub mod SellbackPurchaseEntry_t {
    pub const m_unDefIdx: usize = 0x30; // uint16_t
    pub const m_nCost: usize = 0x34; // int32_t
    pub const m_nPrevArmor: usize = 0x38; // int32_t
    pub const m_bPrevHelmet: usize = 0x3C; // bool
    pub const m_hItem: usize = 0x40; // CEntityHandle
}

pub mod ServerAuthoritativeWeaponSlot_t {
    pub const unClass: usize = 0x28; // uint16_t
    pub const unSlot: usize = 0x2A; // uint16_t
    pub const unItemDefIdx: usize = 0x2C; // uint16_t
}

pub mod SimpleConstraintSoundProfile {
    pub const eKeypoints: usize = 0x8; // SimpleConstraintSoundProfile::SimpleConstraintsSoundProfileKeypoints_t
    pub const m_keyPoints: usize = 0xC; // float[2]
    pub const m_reversalSoundThresholds: usize = 0x14; // float[3]
}

pub mod SpawnPoint {
    pub const m_iPriority: usize = 0x4B0; // int32_t
    pub const m_bEnabled: usize = 0x4B4; // bool
    pub const m_nType: usize = 0x4B8; // int32_t
}

pub mod SpawnPointCoopEnemy {
    pub const m_szWeaponsToGive: usize = 0x4C0; // CUtlSymbolLarge
    pub const m_szPlayerModelToUse: usize = 0x4C8; // CUtlSymbolLarge
    pub const m_nArmorToSpawnWith: usize = 0x4D0; // int32_t
    pub const m_nDefaultBehavior: usize = 0x4D4; // SpawnPointCoopEnemy::BotDefaultBehavior_t
    pub const m_nBotDifficulty: usize = 0x4D8; // int32_t
    pub const m_bIsAgressive: usize = 0x4DC; // bool
    pub const m_bStartAsleep: usize = 0x4DD; // bool
    pub const m_flHideRadius: usize = 0x4E0; // float
    pub const m_szBehaviorTreeFile: usize = 0x4F0; // CUtlSymbolLarge
}

pub mod SummaryTakeDamageInfo_t {
    pub const nSummarisedCount: usize = 0x0; // int32_t
    pub const info: usize = 0x8; // CTakeDamageInfo
    pub const result: usize = 0xA0; // CTakeDamageResult
    pub const hTarget: usize = 0xA8; // CHandle<CBaseEntity>
}

pub mod VPhysicsCollisionAttribute_t {
    pub const m_nInteractsAs: usize = 0x8; // uint64_t
    pub const m_nInteractsWith: usize = 0x10; // uint64_t
    pub const m_nInteractsExclude: usize = 0x18; // uint64_t
    pub const m_nEntityId: usize = 0x20; // uint32_t
    pub const m_nOwnerId: usize = 0x24; // uint32_t
    pub const m_nHierarchyId: usize = 0x28; // uint16_t
    pub const m_nCollisionGroup: usize = 0x2A; // uint8_t
    pub const m_nCollisionFunctionMask: usize = 0x2B; // uint8_t
}

pub mod VelocitySampler {
    pub const m_prevSample: usize = 0x0; // Vector
    pub const m_fPrevSampleTime: usize = 0xC; // GameTime_t
    pub const m_fIdealSampleRate: usize = 0x10; // float
}

pub mod ViewAngleServerChange_t {
    pub const nType: usize = 0x30; // FixAngleSet_t
    pub const qAngle: usize = 0x34; // QAngle
    pub const nIndex: usize = 0x40; // uint32_t
}

pub mod WeaponPurchaseCount_t {
    pub const m_nItemDefIndex: usize = 0x30; // uint16_t
    pub const m_nCount: usize = 0x32; // uint16_t
}

pub mod WeaponPurchaseTracker_t {
    pub const m_weaponPurchases: usize = 0x8; // CUtlVectorEmbeddedNetworkVar<WeaponPurchaseCount_t>
}

pub mod audioparams_t {
    pub const localSound: usize = 0x8; // Vector[8]
    pub const soundscapeIndex: usize = 0x68; // int32_t
    pub const localBits: usize = 0x6C; // uint8_t
    pub const soundscapeEntityListIndex: usize = 0x70; // int32_t
    pub const soundEventHash: usize = 0x74; // uint32_t
}

pub mod dynpitchvol_base_t {
    pub const preset: usize = 0x0; // int32_t
    pub const pitchrun: usize = 0x4; // int32_t
    pub const pitchstart: usize = 0x8; // int32_t
    pub const spinup: usize = 0xC; // int32_t
    pub const spindown: usize = 0x10; // int32_t
    pub const volrun: usize = 0x14; // int32_t
    pub const volstart: usize = 0x18; // int32_t
    pub const fadein: usize = 0x1C; // int32_t
    pub const fadeout: usize = 0x20; // int32_t
    pub const lfotype: usize = 0x24; // int32_t
    pub const lforate: usize = 0x28; // int32_t
    pub const lfomodpitch: usize = 0x2C; // int32_t
    pub const lfomodvol: usize = 0x30; // int32_t
    pub const cspinup: usize = 0x34; // int32_t
    pub const cspincount: usize = 0x38; // int32_t
    pub const pitch: usize = 0x3C; // int32_t
    pub const spinupsav: usize = 0x40; // int32_t
    pub const spindownsav: usize = 0x44; // int32_t
    pub const pitchfrac: usize = 0x48; // int32_t
    pub const vol: usize = 0x4C; // int32_t
    pub const fadeinsav: usize = 0x50; // int32_t
    pub const fadeoutsav: usize = 0x54; // int32_t
    pub const volfrac: usize = 0x58; // int32_t
    pub const lfofrac: usize = 0x5C; // int32_t
    pub const lfomult: usize = 0x60; // int32_t
}

pub mod fogparams_t {
    pub const dirPrimary: usize = 0x8; // Vector
    pub const colorPrimary: usize = 0x14; // Color
    pub const colorSecondary: usize = 0x18; // Color
    pub const colorPrimaryLerpTo: usize = 0x1C; // Color
    pub const colorSecondaryLerpTo: usize = 0x20; // Color
    pub const start: usize = 0x24; // float
    pub const end: usize = 0x28; // float
    pub const farz: usize = 0x2C; // float
    pub const maxdensity: usize = 0x30; // float
    pub const exponent: usize = 0x34; // float
    pub const HDRColorScale: usize = 0x38; // float
    pub const skyboxFogFactor: usize = 0x3C; // float
    pub const skyboxFogFactorLerpTo: usize = 0x40; // float
    pub const startLerpTo: usize = 0x44; // float
    pub const endLerpTo: usize = 0x48; // float
    pub const maxdensityLerpTo: usize = 0x4C; // float
    pub const lerptime: usize = 0x50; // GameTime_t
    pub const duration: usize = 0x54; // float
    pub const blendtobackground: usize = 0x58; // float
    pub const scattering: usize = 0x5C; // float
    pub const locallightscale: usize = 0x60; // float
    pub const enable: usize = 0x64; // bool
    pub const blend: usize = 0x65; // bool
    pub const m_bNoReflectionFog: usize = 0x66; // bool
    pub const m_bPadding: usize = 0x67; // bool
}

pub mod fogplayerparams_t {
    pub const m_hCtrl: usize = 0x8; // CHandle<CFogController>
    pub const m_flTransitionTime: usize = 0xC; // float
    pub const m_OldColor: usize = 0x10; // Color
    pub const m_flOldStart: usize = 0x14; // float
    pub const m_flOldEnd: usize = 0x18; // float
    pub const m_flOldMaxDensity: usize = 0x1C; // float
    pub const m_flOldHDRColorScale: usize = 0x20; // float
    pub const m_flOldFarZ: usize = 0x24; // float
    pub const m_NewColor: usize = 0x28; // Color
    pub const m_flNewStart: usize = 0x2C; // float
    pub const m_flNewEnd: usize = 0x30; // float
    pub const m_flNewMaxDensity: usize = 0x34; // float
    pub const m_flNewHDRColorScale: usize = 0x38; // float
    pub const m_flNewFarZ: usize = 0x3C; // float
}

pub mod hudtextparms_t {
    pub const color1: usize = 0x0; // Color
    pub const color2: usize = 0x4; // Color
    pub const effect: usize = 0x8; // uint8_t
    pub const channel: usize = 0x9; // uint8_t
    pub const x: usize = 0xC; // float
    pub const y: usize = 0x10; // float
}

pub mod lerpdata_t {
    pub const m_hEnt: usize = 0x0; // CHandle<CBaseEntity>
    pub const m_MoveType: usize = 0x4; // MoveType_t
    pub const m_flStartTime: usize = 0x8; // GameTime_t
    pub const m_vecStartOrigin: usize = 0xC; // Vector
    pub const m_qStartRot: usize = 0x20; // Quaternion
    pub const m_nFXIndex: usize = 0x30; // ParticleIndex_t
}

pub mod locksound_t {
    pub const sLockedSound: usize = 0x8; // CUtlSymbolLarge
    pub const sUnlockedSound: usize = 0x10; // CUtlSymbolLarge
    pub const flwaitSound: usize = 0x18; // GameTime_t
}

pub mod magnetted_objects_t {
    pub const hEntity: usize = 0x8; // CHandle<CBaseEntity>
}

pub mod ragdoll_t {
    pub const list: usize = 0x0; // CUtlVector<ragdollelement_t>
    pub const boneIndex: usize = 0x18; // CUtlVector<int32_t>
    pub const allowStretch: usize = 0x30; // bool
    pub const unused: usize = 0x31; // bool
}

pub mod ragdollelement_t {
    pub const originParentSpace: usize = 0x0; // Vector
    pub const parentIndex: usize = 0x20; // int32_t
    pub const m_flRadius: usize = 0x24; // float
}

pub mod shard_model_desc_t {
    pub const m_nModelID: usize = 0x8; // int32_t
    pub const m_hMaterial: usize = 0x10; // CStrongHandle<InfoForResourceTypeIMaterial2>
    pub const m_solid: usize = 0x18; // ShardSolid_t
    pub const m_ShatterPanelMode: usize = 0x19; // ShatterPanelMode
    pub const m_vecPanelSize: usize = 0x1C; // Vector2D
    pub const m_vecStressPositionA: usize = 0x24; // Vector2D
    pub const m_vecStressPositionB: usize = 0x2C; // Vector2D
    pub const m_vecPanelVertices: usize = 0x38; // CNetworkUtlVectorBase<Vector2D>
    pub const m_flGlassHalfThickness: usize = 0x50; // float
    pub const m_bHasParent: usize = 0x54; // bool
    pub const m_bParentFrozen: usize = 0x55; // bool
    pub const m_SurfacePropStringToken: usize = 0x58; // CUtlStringToken
}

pub mod sky3dparams_t {
    pub const scale: usize = 0x8; // int16_t
    pub const origin: usize = 0xC; // Vector
    pub const bClip3DSkyBoxNearToWorldFar: usize = 0x18; // bool
    pub const flClip3DSkyBoxNearToWorldFarOffset: usize = 0x1C; // float
    pub const fog: usize = 0x20; // fogparams_t
    pub const m_nWorldGroupID: usize = 0x88; // WorldGroupId_t
}

pub mod thinkfunc_t {
    pub const m_hFn: usize = 0x8; // HSCRIPT
    pub const m_nContext: usize = 0x10; // CUtlStringToken
    pub const m_nNextThinkTick: usize = 0x14; // GameTick_t
    pub const m_nLastThinkTick: usize = 0x18; // GameTick_t
}
```

`SDK/soundsystem.dll.cs`:

```cs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.554529900 UTC
 */

public static class CDSPMixgroupModifier {
    public const nint m_mixgroup = 0x0; // CUtlString
    public const nint m_flModifier = 0x8; // float
    public const nint m_flModifierMin = 0xC; // float
    public const nint m_flSourceModifier = 0x10; // float
    public const nint m_flSourceModifierMin = 0x14; // float
    public const nint m_flListenerReverbModifierWhenSourceReverbIsActive = 0x18; // float
}

public static class CDSPPresetMixgroupModifierTable {
    public const nint m_table = 0x0; // CUtlVector<CDspPresetModifierList>
}

public static class CDspPresetModifierList {
    public const nint m_dspName = 0x0; // CUtlString
    public const nint m_modifiers = 0x8; // CUtlVector<CDSPMixgroupModifier>
}

public static class CSosGroupActionLimitSchema {
    public const nint m_nMaxCount = 0x18; // int32_t
    public const nint m_nStopType = 0x1C; // SosActionStopType_t
    public const nint m_nSortType = 0x20; // SosActionSortType_t
}

public static class CSosGroupActionSchema {
    public const nint m_name = 0x8; // CUtlString
    public const nint m_actionType = 0x10; // ActionType_t
    public const nint m_actionInstanceType = 0x14; // ActionType_t
}

public static class CSosGroupActionSetSoundeventParameterSchema {
    public const nint m_nMaxCount = 0x18; // int32_t
    public const nint m_flMinValue = 0x1C; // float
    public const nint m_flMaxValue = 0x20; // float
    public const nint m_opvarName = 0x28; // CUtlString
    public const nint m_nSortType = 0x30; // SosActionSortType_t
}

public static class CSosGroupActionTimeLimitSchema {
    public const nint m_flMaxDuration = 0x18; // float
}

public static class CSosGroupBranchPattern {
    public const nint m_bMatchEventName = 0x8; // bool
    public const nint m_bMatchEventSubString = 0x9; // bool
    public const nint m_bMatchEntIndex = 0xA; // bool
    public const nint m_bMatchOpvar = 0xB; // bool
}

public static class CSosGroupMatchPattern {
    public const nint m_matchSoundEventName = 0x10; // CUtlString
    public const nint m_matchSoundEventSubString = 0x18; // CUtlString
    public const nint m_flEntIndex = 0x20; // float
    public const nint m_flOpvar = 0x24; // float
}

public static class CSosSoundEventGroupListSchema {
    public const nint m_groupList = 0x0; // CUtlVector<CSosSoundEventGroupSchema>
}

public static class CSosSoundEventGroupSchema {
    public const nint m_name = 0x0; // CUtlString
    public const nint m_nType = 0x8; // SosGroupType_t
    public const nint m_bIsBlocking = 0xC; // bool
    public const nint m_nBlockMaxCount = 0x10; // int32_t
    public const nint m_bInvertMatch = 0x14; // bool
    public const nint m_matchPattern = 0x18; // CSosGroupMatchPattern
    public const nint m_branchPattern = 0x40; // CSosGroupBranchPattern
    public const nint m_vActions = 0xB0; // CSosGroupActionSchema*[4]
}

public static class CSoundEventMetaData {
    public const nint m_soundEventVMix = 0x0; // CStrongHandle<InfoForResourceTypeCVMixListResource>
}

public static class SelectedEditItemInfo_t {
    public const nint m_EditItems = 0x0; // CUtlVector<SosEditItemInfo_t>
}

public static class SosEditItemInfo_t {
    public const nint itemType = 0x0; // SosEditItemType_t
    public const nint itemName = 0x8; // CUtlString
    public const nint itemTypeName = 0x10; // CUtlString
    public const nint itemKVString = 0x20; // CUtlString
    public const nint itemPos = 0x28; // Vector2D
}

public static class VMixAutoFilterDesc_t {
    public const nint m_flEnvelopeAmount = 0x0; // float
    public const nint m_flAttackTimeMS = 0x4; // float
    public const nint m_flReleaseTimeMS = 0x8; // float
    public const nint m_filter = 0xC; // VMixFilterDesc_t
    public const nint m_flLFOAmount = 0x1C; // float
    public const nint m_flLFORate = 0x20; // float
    public const nint m_flPhase = 0x24; // float
    public const nint m_nLFOShape = 0x28; // VMixLFOShape_t
}

public static class VMixBoxverbDesc_t {
    public const nint m_flSizeMax = 0x0; // float
    public const nint m_flSizeMin = 0x4; // float
    public const nint m_flComplexity = 0x8; // float
    public const nint m_flDiffusion = 0xC; // float
    public const nint m_flModDepth = 0x10; // float
    public const nint m_flModRate = 0x14; // float
    public const nint m_bParallel = 0x18; // bool
    public const nint m_filterType = 0x1C; // VMixFilterDesc_t
    public const nint m_flWidth = 0x2C; // float
    public const nint m_flHeight = 0x30; // float
    public const nint m_flDepth = 0x34; // float
    public const nint m_flFeedbackScale = 0x38; // float
    public const nint m_flFeedbackWidth = 0x3C; // float
    public const nint m_flFeedbackHeight = 0x40; // float
    public const nint m_flFeedbackDepth = 0x44; // float
    public const nint m_flOutputGain = 0x48; // float
    public const nint m_flTaps = 0x4C; // float
}

public static class VMixConvolutionDesc_t {
    public const nint m_fldbGain = 0x0; // float
    public const nint m_flPreDelayMS = 0x4; // float
    public const nint m_flWetMix = 0x8; // float
    public const nint m_fldbLow = 0xC; // float
    public const nint m_fldbMid = 0x10; // float
    public const nint m_fldbHigh = 0x14; // float
    public const nint m_flLowCutoffFreq = 0x18; // float
    public const nint m_flHighCutoffFreq = 0x1C; // float
}

public static class VMixDelayDesc_t {
    public const nint m_feedbackFilter = 0x0; // VMixFilterDesc_t
    public const nint m_bEnableFilter = 0x10; // bool
    public const nint m_flDelay = 0x14; // float
    public const nint m_flDirectGain = 0x18; // float
    public const nint m_flDelayGain = 0x1C; // float
    public const nint m_flFeedbackGain = 0x20; // float
    public const nint m_flWidth = 0x24; // float
}

public static class VMixDiffusorDesc_t {
    public const nint m_flSize = 0x0; // float
    public const nint m_flComplexity = 0x4; // float
    public const nint m_flFeedback = 0x8; // float
    public const nint m_flOutputGain = 0xC; // float
}

public static class VMixDynamics3BandDesc_t {
    public const nint m_fldbGainOutput = 0x0; // float
    public const nint m_flRMSTimeMS = 0x4; // float
    public const nint m_fldbKneeWidth = 0x8; // float
    public const nint m_flDepth = 0xC; // float
    public const nint m_flWetMix = 0x10; // float
    public const nint m_flTimeScale = 0x14; // float
    public const nint m_flLowCutoffFreq = 0x18; // float
    public const nint m_flHighCutoffFreq = 0x1C; // float
    public const nint m_bPeakMode = 0x20; // bool
    public const nint m_bandDesc = 0x24; // VMixDynamicsBand_t[3]
}

public static class VMixDynamicsBand_t {
    public const nint m_fldbGainInput = 0x0; // float
    public const nint m_fldbGainOutput = 0x4; // float
    public const nint m_fldbThresholdBelow = 0x8; // float
    public const nint m_fldbThresholdAbove = 0xC; // float
    public const nint m_flRatioBelow = 0x10; // float
    public const nint m_flRatioAbove = 0x14; // float
    public const nint m_flAttackTimeMS = 0x18; // float
    public const nint m_flReleaseTimeMS = 0x1C; // float
    public const nint m_bEnable = 0x20; // bool
    public const nint m_bSolo = 0x21; // bool
}

public static class VMixDynamicsCompressorDesc_t {
    public const nint m_fldbOutputGain = 0x0; // float
    public const nint m_fldbCompressionThreshold = 0x4; // float
    public const nint m_fldbKneeWidth = 0x8; // float
    public const nint m_flCompressionRatio = 0xC; // float
    public const nint m_flAttackTimeMS = 0x10; // float
    public const nint m_flReleaseTimeMS = 0x14; // float
    public const nint m_flRMSTimeMS = 0x18; // float
    public const nint m_flWetMix = 0x1C; // float
    public const nint m_bPeakMode = 0x20; // bool
}

public static class VMixDynamicsDesc_t {
    public const nint m_fldbGain = 0x0; // float
    public const nint m_fldbNoiseGateThreshold = 0x4; // float
    public const nint m_fldbCompressionThreshold = 0x8; // float
    public const nint m_fldbLimiterThreshold = 0xC; // float
    public const nint m_fldbKneeWidth = 0x10; // float
    public const nint m_flRatio = 0x14; // float
    public const nint m_flLimiterRatio = 0x18; // float
    public const nint m_flAttackTimeMS = 0x1C; // float
    public const nint m_flReleaseTimeMS = 0x20; // float
    public const nint m_flRMSTimeMS = 0x24; // float
    public const nint m_flWetMix = 0x28; // float
    public const nint m_bPeakMode = 0x2C; // bool
}

public static class VMixEQ8Desc_t {
    public const nint m_stages = 0x0; // VMixFilterDesc_t[8]
}

public static class VMixEffectChainDesc_t {
    public const nint m_flCrossfadeTime = 0x0; // float
}

public static class VMixEnvelopeDesc_t {
    public const nint m_flAttackTimeMS = 0x0; // float
    public const nint m_flHoldTimeMS = 0x4; // float
    public const nint m_flReleaseTimeMS = 0x8; // float
}

public static class VMixFilterDesc_t {
    public const nint m_nFilterType = 0x0; // VMixFilterType_t
    public const nint m_nFilterSlope = 0x2; // VMixFilterSlope_t
    public const nint m_bEnabled = 0x3; // bool
    public const nint m_fldbGain = 0x4; // float
    public const nint m_flCutoffFreq = 0x8; // float
    public const nint m_flQ = 0xC; // float
}

public static class VMixFreeverbDesc_t {
    public const nint m_flRoomSize = 0x0; // float
    public const nint m_flDamp = 0x4; // float
    public const nint m_flWidth = 0x8; // float
    public const nint m_flLateReflections = 0xC; // float
}

public static class VMixModDelayDesc_t {
    public const nint m_feedbackFilter = 0x0; // VMixFilterDesc_t
    public const nint m_bPhaseInvert = 0x10; // bool
    public const nint m_flGlideTime = 0x14; // float
    public const nint m_flDelay = 0x18; // float
    public const nint m_flOutputGain = 0x1C; // float
    public const nint m_flFeedbackGain = 0x20; // float
    public const nint m_flModRate = 0x24; // float
    public const nint m_flModDepth = 0x28; // float
    public const nint m_bApplyAntialiasing = 0x2C; // bool
}

public static class VMixOscDesc_t {
    public const nint oscType = 0x0; // VMixLFOShape_t
    public const nint m_freq = 0x4; // float
    public const nint m_flPhase = 0x8; // float
}

public static class VMixPannerDesc_t {
    public const nint m_type = 0x0; // VMixPannerType_t
    public const nint m_flStrength = 0x4; // float
}

public static class VMixPitchShiftDesc_t {
    public const nint m_nGrainSampleCount = 0x0; // int32_t
    public const nint m_flPitchShift = 0x4; // float
    public const nint m_nQuality = 0x8; // int32_t
    public const nint m_nProcType = 0xC; // int32_t
}

public static class VMixPlateverbDesc_t {
    public const nint m_flPrefilter = 0x0; // float
    public const nint m_flInputDiffusion1 = 0x4; // float
    public const nint m_flInputDiffusion2 = 0x8; // float
    public const nint m_flDecay = 0xC; // float
    public const nint m_flDamp = 0x10; // float
    public const nint m_flFeedbackDiffusion1 = 0x14; // float
    public const nint m_flFeedbackDiffusion2 = 0x18; // float
}

public static class VMixShaperDesc_t {
    public const nint m_nShape = 0x0; // int32_t
    public const nint m_fldbDrive = 0x4; // float
    public const nint m_fldbOutputGain = 0x8; // float
    public const nint m_flWetMix = 0xC; // float
    public const nint m_nOversampleFactor = 0x10; // int32_t
}

public static class VMixSubgraphSwitchDesc_t {
    public const nint m_interpolationMode = 0x0; // VMixSubgraphSwitchInterpolationType_t
    public const nint m_bOnlyTailsOnFadeOut = 0x4; // bool
    public const nint m_flInterpolationTime = 0x8; // float
}

public static class VMixUtilityDesc_t {
    public const nint m_nOp = 0x0; // VMixChannelOperation_t
    public const nint m_flInputPan = 0x4; // float
    public const nint m_flOutputBalance = 0x8; // float
    public const nint m_fldbOutputGain = 0xC; // float
    public const nint m_bBassMono = 0x10; // bool
    public const nint m_flBassFreq = 0x14; // float
}

public static class VMixVocoderDesc_t {
    public const nint m_nBandCount = 0x0; // int32_t
    public const nint m_flBandwidth = 0x4; // float
    public const nint m_fldBModGain = 0x8; // float
    public const nint m_flFreqRangeStart = 0xC; // float
    public const nint m_flFreqRangeEnd = 0x10; // float
    public const nint m_fldBUnvoicedGain = 0x14; // float
    public const nint m_flAttackTimeMS = 0x18; // float
    public const nint m_flReleaseTimeMS = 0x1C; // float
    public const nint m_nDebugBand = 0x20; // int32_t
    public const nint m_bPeakMode = 0x24; // bool
}
```

`SDK/soundsystem.dll.hpp`:

```hpp
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.547979200 UTC
 */

#pragma once

#include <cstddef>

namespace CDSPMixgroupModifier {
    constexpr std::ptrdiff_t m_mixgroup = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_flModifier = 0x8; // float
    constexpr std::ptrdiff_t m_flModifierMin = 0xC; // float
    constexpr std::ptrdiff_t m_flSourceModifier = 0x10; // float
    constexpr std::ptrdiff_t m_flSourceModifierMin = 0x14; // float
    constexpr std::ptrdiff_t m_flListenerReverbModifierWhenSourceReverbIsActive = 0x18; // float
}

namespace CDSPPresetMixgroupModifierTable {
    constexpr std::ptrdiff_t m_table = 0x0; // CUtlVector<CDspPresetModifierList>
}

namespace CDspPresetModifierList {
    constexpr std::ptrdiff_t m_dspName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_modifiers = 0x8; // CUtlVector<CDSPMixgroupModifier>
}

namespace CSosGroupActionLimitSchema {
    constexpr std::ptrdiff_t m_nMaxCount = 0x18; // int32_t
    constexpr std::ptrdiff_t m_nStopType = 0x1C; // SosActionStopType_t
    constexpr std::ptrdiff_t m_nSortType = 0x20; // SosActionSortType_t
}

namespace CSosGroupActionSchema {
    constexpr std::ptrdiff_t m_name = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_actionType = 0x10; // ActionType_t
    constexpr std::ptrdiff_t m_actionInstanceType = 0x14; // ActionType_t
}

namespace CSosGroupActionSetSoundeventParameterSchema {
    constexpr std::ptrdiff_t m_nMaxCount = 0x18; // int32_t
    constexpr std::ptrdiff_t m_flMinValue = 0x1C; // float
    constexpr std::ptrdiff_t m_flMaxValue = 0x20; // float
    constexpr std::ptrdiff_t m_opvarName = 0x28; // CUtlString
    constexpr std::ptrdiff_t m_nSortType = 0x30; // SosActionSortType_t
}

namespace CSosGroupActionTimeLimitSchema {
    constexpr std::ptrdiff_t m_flMaxDuration = 0x18; // float
}

namespace CSosGroupBranchPattern {
    constexpr std::ptrdiff_t m_bMatchEventName = 0x8; // bool
    constexpr std::ptrdiff_t m_bMatchEventSubString = 0x9; // bool
    constexpr std::ptrdiff_t m_bMatchEntIndex = 0xA; // bool
    constexpr std::ptrdiff_t m_bMatchOpvar = 0xB; // bool
}

namespace CSosGroupMatchPattern {
    constexpr std::ptrdiff_t m_matchSoundEventName = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_matchSoundEventSubString = 0x18; // CUtlString
    constexpr std::ptrdiff_t m_flEntIndex = 0x20; // float
    constexpr std::ptrdiff_t m_flOpvar = 0x24; // float
}

namespace CSosSoundEventGroupListSchema {
    constexpr std::ptrdiff_t m_groupList = 0x0; // CUtlVector<CSosSoundEventGroupSchema>
}

namespace CSosSoundEventGroupSchema {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nType = 0x8; // SosGroupType_t
    constexpr std::ptrdiff_t m_bIsBlocking = 0xC; // bool
    constexpr std::ptrdiff_t m_nBlockMaxCount = 0x10; // int32_t
    constexpr std::ptrdiff_t m_bInvertMatch = 0x14; // bool
    constexpr std::ptrdiff_t m_matchPattern = 0x18; // CSosGroupMatchPattern
    constexpr std::ptrdiff_t m_branchPattern = 0x40; // CSosGroupBranchPattern
    constexpr std::ptrdiff_t m_vActions = 0xB0; // CSosGroupActionSchema*[4]
}

namespace CSoundEventMetaData {
    constexpr std::ptrdiff_t m_soundEventVMix = 0x0; // CStrongHandle<InfoForResourceTypeCVMixListResource>
}

namespace SelectedEditItemInfo_t {
    constexpr std::ptrdiff_t m_EditItems = 0x0; // CUtlVector<SosEditItemInfo_t>
}

namespace SosEditItemInfo_t {
    constexpr std::ptrdiff_t itemType = 0x0; // SosEditItemType_t
    constexpr std::ptrdiff_t itemName = 0x8; // CUtlString
    constexpr std::ptrdiff_t itemTypeName = 0x10; // CUtlString
    constexpr std::ptrdiff_t itemKVString = 0x20; // CUtlString
    constexpr std::ptrdiff_t itemPos = 0x28; // Vector2D
}

namespace VMixAutoFilterDesc_t {
    constexpr std::ptrdiff_t m_flEnvelopeAmount = 0x0; // float
    constexpr std::ptrdiff_t m_flAttackTimeMS = 0x4; // float
    constexpr std::ptrdiff_t m_flReleaseTimeMS = 0x8; // float
    constexpr std::ptrdiff_t m_filter = 0xC; // VMixFilterDesc_t
    constexpr std::ptrdiff_t m_flLFOAmount = 0x1C; // float
    constexpr std::ptrdiff_t m_flLFORate = 0x20; // float
    constexpr std::ptrdiff_t m_flPhase = 0x24; // float
    constexpr std::ptrdiff_t m_nLFOShape = 0x28; // VMixLFOShape_t
}

namespace VMixBoxverbDesc_t {
    constexpr std::ptrdiff_t m_flSizeMax = 0x0; // float
    constexpr std::ptrdiff_t m_flSizeMin = 0x4; // float
    constexpr std::ptrdiff_t m_flComplexity = 0x8; // float
    constexpr std::ptrdiff_t m_flDiffusion = 0xC; // float
    constexpr std::ptrdiff_t m_flModDepth = 0x10; // float
    constexpr std::ptrdiff_t m_flModRate = 0x14; // float
    constexpr std::ptrdiff_t m_bParallel = 0x18; // bool
    constexpr std::ptrdiff_t m_filterType = 0x1C; // VMixFilterDesc_t
    constexpr std::ptrdiff_t m_flWidth = 0x2C; // float
    constexpr std::ptrdiff_t m_flHeight = 0x30; // float
    constexpr std::ptrdiff_t m_flDepth = 0x34; // float
    constexpr std::ptrdiff_t m_flFeedbackScale = 0x38; // float
    constexpr std::ptrdiff_t m_flFeedbackWidth = 0x3C; // float
    constexpr std::ptrdiff_t m_flFeedbackHeight = 0x40; // float
    constexpr std::ptrdiff_t m_flFeedbackDepth = 0x44; // float
    constexpr std::ptrdiff_t m_flOutputGain = 0x48; // float
    constexpr std::ptrdiff_t m_flTaps = 0x4C; // float
}

namespace VMixConvolutionDesc_t {
    constexpr std::ptrdiff_t m_fldbGain = 0x0; // float
    constexpr std::ptrdiff_t m_flPreDelayMS = 0x4; // float
    constexpr std::ptrdiff_t m_flWetMix = 0x8; // float
    constexpr std::ptrdiff_t m_fldbLow = 0xC; // float
    constexpr std::ptrdiff_t m_fldbMid = 0x10; // float
    constexpr std::ptrdiff_t m_fldbHigh = 0x14; // float
    constexpr std::ptrdiff_t m_flLowCutoffFreq = 0x18; // float
    constexpr std::ptrdiff_t m_flHighCutoffFreq = 0x1C; // float
}

namespace VMixDelayDesc_t {
    constexpr std::ptrdiff_t m_feedbackFilter = 0x0; // VMixFilterDesc_t
    constexpr std::ptrdiff_t m_bEnableFilter = 0x10; // bool
    constexpr std::ptrdiff_t m_flDelay = 0x14; // float
    constexpr std::ptrdiff_t m_flDirectGain = 0x18; // float
    constexpr std::ptrdiff_t m_flDelayGain = 0x1C; // float
    constexpr std::ptrdiff_t m_flFeedbackGain = 0x20; // float
    constexpr std::ptrdiff_t m_flWidth = 0x24; // float
}

namespace VMixDiffusorDesc_t {
    constexpr std::ptrdiff_t m_flSize = 0x0; // float
    constexpr std::ptrdiff_t m_flComplexity = 0x4; // float
    constexpr std::ptrdiff_t m_flFeedback = 0x8; // float
    constexpr std::ptrdiff_t m_flOutputGain = 0xC; // float
}

namespace VMixDynamics3BandDesc_t {
    constexpr std::ptrdiff_t m_fldbGainOutput = 0x0; // float
    constexpr std::ptrdiff_t m_flRMSTimeMS = 0x4; // float
    constexpr std::ptrdiff_t m_fldbKneeWidth = 0x8; // float
    constexpr std::ptrdiff_t m_flDepth = 0xC; // float
    constexpr std::ptrdiff_t m_flWetMix = 0x10; // float
    constexpr std::ptrdiff_t m_flTimeScale = 0x14; // float
    constexpr std::ptrdiff_t m_flLowCutoffFreq = 0x18; // float
    constexpr std::ptrdiff_t m_flHighCutoffFreq = 0x1C; // float
    constexpr std::ptrdiff_t m_bPeakMode = 0x20; // bool
    constexpr std::ptrdiff_t m_bandDesc = 0x24; // VMixDynamicsBand_t[3]
}

namespace VMixDynamicsBand_t {
    constexpr std::ptrdiff_t m_fldbGainInput = 0x0; // float
    constexpr std::ptrdiff_t m_fldbGainOutput = 0x4; // float
    constexpr std::ptrdiff_t m_fldbThresholdBelow = 0x8; // float
    constexpr std::ptrdiff_t m_fldbThresholdAbove = 0xC; // float
    constexpr std::ptrdiff_t m_flRatioBelow = 0x10; // float
    constexpr std::ptrdiff_t m_flRatioAbove = 0x14; // float
    constexpr std::ptrdiff_t m_flAttackTimeMS = 0x18; // float
    constexpr std::ptrdiff_t m_flReleaseTimeMS = 0x1C; // float
    constexpr std::ptrdiff_t m_bEnable = 0x20; // bool
    constexpr std::ptrdiff_t m_bSolo = 0x21; // bool
}

namespace VMixDynamicsCompressorDesc_t {
    constexpr std::ptrdiff_t m_fldbOutputGain = 0x0; // float
    constexpr std::ptrdiff_t m_fldbCompressionThreshold = 0x4; // float
    constexpr std::ptrdiff_t m_fldbKneeWidth = 0x8; // float
    constexpr std::ptrdiff_t m_flCompressionRatio = 0xC; // float
    constexpr std::ptrdiff_t m_flAttackTimeMS = 0x10; // float
    constexpr std::ptrdiff_t m_flReleaseTimeMS = 0x14; // float
    constexpr std::ptrdiff_t m_flRMSTimeMS = 0x18; // float
    constexpr std::ptrdiff_t m_flWetMix = 0x1C; // float
    constexpr std::ptrdiff_t m_bPeakMode = 0x20; // bool
}

namespace VMixDynamicsDesc_t {
    constexpr std::ptrdiff_t m_fldbGain = 0x0; // float
    constexpr std::ptrdiff_t m_fldbNoiseGateThreshold = 0x4; // float
    constexpr std::ptrdiff_t m_fldbCompressionThreshold = 0x8; // float
    constexpr std::ptrdiff_t m_fldbLimiterThreshold = 0xC; // float
    constexpr std::ptrdiff_t m_fldbKneeWidth = 0x10; // float
    constexpr std::ptrdiff_t m_flRatio = 0x14; // float
    constexpr std::ptrdiff_t m_flLimiterRatio = 0x18; // float
    constexpr std::ptrdiff_t m_flAttackTimeMS = 0x1C; // float
    constexpr std::ptrdiff_t m_flReleaseTimeMS = 0x20; // float
    constexpr std::ptrdiff_t m_flRMSTimeMS = 0x24; // float
    constexpr std::ptrdiff_t m_flWetMix = 0x28; // float
    constexpr std::ptrdiff_t m_bPeakMode = 0x2C; // bool
}

namespace VMixEQ8Desc_t {
    constexpr std::ptrdiff_t m_stages = 0x0; // VMixFilterDesc_t[8]
}

namespace VMixEffectChainDesc_t {
    constexpr std::ptrdiff_t m_flCrossfadeTime = 0x0; // float
}

namespace VMixEnvelopeDesc_t {
    constexpr std::ptrdiff_t m_flAttackTimeMS = 0x0; // float
    constexpr std::ptrdiff_t m_flHoldTimeMS = 0x4; // float
    constexpr std::ptrdiff_t m_flReleaseTimeMS = 0x8; // float
}

namespace VMixFilterDesc_t {
    constexpr std::ptrdiff_t m_nFilterType = 0x0; // VMixFilterType_t
    constexpr std::ptrdiff_t m_nFilterSlope = 0x2; // VMixFilterSlope_t
    constexpr std::ptrdiff_t m_bEnabled = 0x3; // bool
    constexpr std::ptrdiff_t m_fldbGain = 0x4; // float
    constexpr std::ptrdiff_t m_flCutoffFreq = 0x8; // float
    constexpr std::ptrdiff_t m_flQ = 0xC; // float
}

namespace VMixFreeverbDesc_t {
    constexpr std::ptrdiff_t m_flRoomSize = 0x0; // float
    constexpr std::ptrdiff_t m_flDamp = 0x4; // float
    constexpr std::ptrdiff_t m_flWidth = 0x8; // float
    constexpr std::ptrdiff_t m_flLateReflections = 0xC; // float
}

namespace VMixModDelayDesc_t {
    constexpr std::ptrdiff_t m_feedbackFilter = 0x0; // VMixFilterDesc_t
    constexpr std::ptrdiff_t m_bPhaseInvert = 0x10; // bool
    constexpr std::ptrdiff_t m_flGlideTime = 0x14; // float
    constexpr std::ptrdiff_t m_flDelay = 0x18; // float
    constexpr std::ptrdiff_t m_flOutputGain = 0x1C; // float
    constexpr std::ptrdiff_t m_flFeedbackGain = 0x20; // float
    constexpr std::ptrdiff_t m_flModRate = 0x24; // float
    constexpr std::ptrdiff_t m_flModDepth = 0x28; // float
    constexpr std::ptrdiff_t m_bApplyAntialiasing = 0x2C; // bool
}

namespace VMixOscDesc_t {
    constexpr std::ptrdiff_t oscType = 0x0; // VMixLFOShape_t
    constexpr std::ptrdiff_t m_freq = 0x4; // float
    constexpr std::ptrdiff_t m_flPhase = 0x8; // float
}

namespace VMixPannerDesc_t {
    constexpr std::ptrdiff_t m_type = 0x0; // VMixPannerType_t
    constexpr std::ptrdiff_t m_flStrength = 0x4; // float
}

namespace VMixPitchShiftDesc_t {
    constexpr std::ptrdiff_t m_nGrainSampleCount = 0x0; // int32_t
    constexpr std::ptrdiff_t m_flPitchShift = 0x4; // float
    constexpr std::ptrdiff_t m_nQuality = 0x8; // int32_t
    constexpr std::ptrdiff_t m_nProcType = 0xC; // int32_t
}

namespace VMixPlateverbDesc_t {
    constexpr std::ptrdiff_t m_flPrefilter = 0x0; // float
    constexpr std::ptrdiff_t m_flInputDiffusion1 = 0x4; // float
    constexpr std::ptrdiff_t m_flInputDiffusion2 = 0x8; // float
    constexpr std::ptrdiff_t m_flDecay = 0xC; // float
    constexpr std::ptrdiff_t m_flDamp = 0x10; // float
    constexpr std::ptrdiff_t m_flFeedbackDiffusion1 = 0x14; // float
    constexpr std::ptrdiff_t m_flFeedbackDiffusion2 = 0x18; // float
}

namespace VMixShaperDesc_t {
    constexpr std::ptrdiff_t m_nShape = 0x0; // int32_t
    constexpr std::ptrdiff_t m_fldbDrive = 0x4; // float
    constexpr std::ptrdiff_t m_fldbOutputGain = 0x8; // float
    constexpr std::ptrdiff_t m_flWetMix = 0xC; // float
    constexpr std::ptrdiff_t m_nOversampleFactor = 0x10; // int32_t
}

namespace VMixSubgraphSwitchDesc_t {
    constexpr std::ptrdiff_t m_interpolationMode = 0x0; // VMixSubgraphSwitchInterpolationType_t
    constexpr std::ptrdiff_t m_bOnlyTailsOnFadeOut = 0x4; // bool
    constexpr std::ptrdiff_t m_flInterpolationTime = 0x8; // float
}

namespace VMixUtilityDesc_t {
    constexpr std::ptrdiff_t m_nOp = 0x0; // VMixChannelOperation_t
    constexpr std::ptrdiff_t m_flInputPan = 0x4; // float
    constexpr std::ptrdiff_t m_flOutputBalance = 0x8; // float
    constexpr std::ptrdiff_t m_fldbOutputGain = 0xC; // float
    constexpr std::ptrdiff_t m_bBassMono = 0x10; // bool
    constexpr std::ptrdiff_t m_flBassFreq = 0x14; // float
}

namespace VMixVocoderDesc_t {
    constexpr std::ptrdiff_t m_nBandCount = 0x0; // int32_t
    constexpr std::ptrdiff_t m_flBandwidth = 0x4; // float
    constexpr std::ptrdiff_t m_fldBModGain = 0x8; // float
    constexpr std::ptrdiff_t m_flFreqRangeStart = 0xC; // float
    constexpr std::ptrdiff_t m_flFreqRangeEnd = 0x10; // float
    constexpr std::ptrdiff_t m_fldBUnvoicedGain = 0x14; // float
    constexpr std::ptrdiff_t m_flAttackTimeMS = 0x18; // float
    constexpr std::ptrdiff_t m_flReleaseTimeMS = 0x1C; // float
    constexpr std::ptrdiff_t m_nDebugBand = 0x20; // int32_t
    constexpr std::ptrdiff_t m_bPeakMode = 0x24; // bool
}
```

`SDK/soundsystem.dll.json`:

```json
{
  "CDSPMixgroupModifier": {
    "m_flListenerReverbModifierWhenSourceReverbIsActive": 24,
    "m_flModifier": 8,
    "m_flModifierMin": 12,
    "m_flSourceModifier": 16,
    "m_flSourceModifierMin": 20,
    "m_mixgroup": 0
  },
  "CDSPPresetMixgroupModifierTable": {
    "m_table": 0
  },
  "CDspPresetModifierList": {
    "m_dspName": 0,
    "m_modifiers": 8
  },
  "CSosGroupActionLimitSchema": {
    "m_nMaxCount": 24,
    "m_nSortType": 32,
    "m_nStopType": 28
  },
  "CSosGroupActionSchema": {
    "m_actionInstanceType": 20,
    "m_actionType": 16,
    "m_name": 8
  },
  "CSosGroupActionSetSoundeventParameterSchema": {
    "m_flMaxValue": 32,
    "m_flMinValue": 28,
    "m_nMaxCount": 24,
    "m_nSortType": 48,
    "m_opvarName": 40
  },
  "CSosGroupActionTimeLimitSchema": {
    "m_flMaxDuration": 24
  },
  "CSosGroupBranchPattern": {
    "m_bMatchEntIndex": 10,
    "m_bMatchEventName": 8,
    "m_bMatchEventSubString": 9,
    "m_bMatchOpvar": 11
  },
  "CSosGroupMatchPattern": {
    "m_flEntIndex": 32,
    "m_flOpvar": 36,
    "m_matchSoundEventName": 16,
    "m_matchSoundEventSubString": 24
  },
  "CSosSoundEventGroupListSchema": {
    "m_groupList": 0
  },
  "CSosSoundEventGroupSchema": {
    "m_bInvertMatch": 20,
    "m_bIsBlocking": 12,
    "m_branchPattern": 64,
    "m_matchPattern": 24,
    "m_nBlockMaxCount": 16,
    "m_nType": 8,
    "m_name": 0,
    "m_vActions": 176
  },
  "CSoundEventMetaData": {
    "m_soundEventVMix": 0
  },
  "SelectedEditItemInfo_t": {
    "m_EditItems": 0
  },
  "SosEditItemInfo_t": {
    "itemKVString": 32,
    "itemName": 8,
    "itemPos": 40,
    "itemType": 0,
    "itemTypeName": 16
  },
  "VMixAutoFilterDesc_t": {
    "m_filter": 12,
    "m_flAttackTimeMS": 4,
    "m_flEnvelopeAmount": 0,
    "m_flLFOAmount": 28,
    "m_flLFORate": 32,
    "m_flPhase": 36,
    "m_flReleaseTimeMS": 8,
    "m_nLFOShape": 40
  },
  "VMixBoxverbDesc_t": {
    "m_bParallel": 24,
    "m_filterType": 28,
    "m_flComplexity": 8,
    "m_flDepth": 52,
    "m_flDiffusion": 12,
    "m_flFeedbackDepth": 68,
    "m_flFeedbackHeight": 64,
    "m_flFeedbackScale": 56,
    "m_flFeedbackWidth": 60,
    "m_flHeight": 48,
    "m_flModDepth": 16,
    "m_flModRate": 20,
    "m_flOutputGain": 72,
    "m_flSizeMax": 0,
    "m_flSizeMin": 4,
    "m_flTaps": 76,
    "m_flWidth": 44
  },
  "VMixConvolutionDesc_t": {
    "m_flHighCutoffFreq": 28,
    "m_flLowCutoffFreq": 24,
    "m_flPreDelayMS": 4,
    "m_flWetMix": 8,
    "m_fldbGain": 0,
    "m_fldbHigh": 20,
    "m_fldbLow": 12,
    "m_fldbMid": 16
  },
  "VMixDelayDesc_t": {
    "m_bEnableFilter": 16,
    "m_feedbackFilter": 0,
    "m_flDelay": 20,
    "m_flDelayGain": 28,
    "m_flDirectGain": 24,
    "m_flFeedbackGain": 32,
    "m_flWidth": 36
  },
  "VMixDiffusorDesc_t": {
    "m_flComplexity": 4,
    "m_flFeedback": 8,
    "m_flOutputGain": 12,
    "m_flSize": 0
  },
  "VMixDynamics3BandDesc_t": {
    "m_bPeakMode": 32,
    "m_bandDesc": 36,
    "m_flDepth": 12,
    "m_flHighCutoffFreq": 28,
    "m_flLowCutoffFreq": 24,
    "m_flRMSTimeMS": 4,
    "m_flTimeScale": 20,
    "m_flWetMix": 16,
    "m_fldbGainOutput": 0,
    "m_fldbKneeWidth": 8
  },
  "VMixDynamicsBand_t": {
    "m_bEnable": 32,
    "m_bSolo": 33,
    "m_flAttackTimeMS": 24,
    "m_flRatioAbove": 20,
    "m_flRatioBelow": 16,
    "m_flReleaseTimeMS": 28,
    "m_fldbGainInput": 0,
    "m_fldbGainOutput": 4,
    "m_fldbThresholdAbove": 12,
    "m_fldbThresholdBelow": 8
  },
  "VMixDynamicsCompressorDesc_t": {
    "m_bPeakMode": 32,
    "m_flAttackTimeMS": 16,
    "m_flCompressionRatio": 12,
    "m_flRMSTimeMS": 24,
    "m_flReleaseTimeMS": 20,
    "m_flWetMix": 28,
    "m_fldbCompressionThreshold": 4,
    "m_fldbKneeWidth": 8,
    "m_fldbOutputGain": 0
  },
  "VMixDynamicsDesc_t": {
    "m_bPeakMode": 44,
    "m_flAttackTimeMS": 28,
    "m_flLimiterRatio": 24,
    "m_flRMSTimeMS": 36,
    "m_flRatio": 20,
    "m_flReleaseTimeMS": 32,
    "m_flWetMix": 40,
    "m_fldbCompressionThreshold": 8,
    "m_fldbGain": 0,
    "m_fldbKneeWidth": 16,
    "m_fldbLimiterThreshold": 12,
    "m_fldbNoiseGateThreshold": 4
  },
  "VMixEQ8Desc_t": {
    "m_stages": 0
  },
  "VMixEffectChainDesc_t": {
    "m_flCrossfadeTime": 0
  },
  "VMixEnvelopeDesc_t": {
    "m_flAttackTimeMS": 0,
    "m_flHoldTimeMS": 4,
    "m_flReleaseTimeMS": 8
  },
  "VMixFilterDesc_t": {
    "m_bEnabled": 3,
    "m_flCutoffFreq": 8,
    "m_flQ": 12,
    "m_fldbGain": 4,
    "m_nFilterSlope": 2,
    "m_nFilterType": 0
  },
  "VMixFreeverbDesc_t": {
    "m_flDamp": 4,
    "m_flLateReflections": 12,
    "m_flRoomSize": 0,
    "m_flWidth": 8
  },
  "VMixModDelayDesc_t": {
    "m_bApplyAntialiasing": 44,
    "m_bPhaseInvert": 16,
    "m_feedbackFilter": 0,
    "m_flDelay": 24,
    "m_flFeedbackGain": 32,
    "m_flGlideTime": 20,
    "m_flModDepth": 40,
    "m_flModRate": 36,
    "m_flOutputGain": 28
  },
  "VMixOscDesc_t": {
    "m_flPhase": 8,
    "m_freq": 4,
    "oscType": 0
  },
  "VMixPannerDesc_t": {
    "m_flStrength": 4,
    "m_type": 0
  },
  "VMixPitchShiftDesc_t": {
    "m_flPitchShift": 4,
    "m_nGrainSampleCount": 0,
    "m_nProcType": 12,
    "m_nQuality": 8
  },
  "VMixPlateverbDesc_t": {
    "m_flDamp": 16,
    "m_flDecay": 12,
    "m_flFeedbackDiffusion1": 20,
    "m_flFeedbackDiffusion2": 24,
    "m_flInputDiffusion1": 4,
    "m_flInputDiffusion2": 8,
    "m_flPrefilter": 0
  },
  "VMixShaperDesc_t": {
    "m_flWetMix": 12,
    "m_fldbDrive": 4,
    "m_fldbOutputGain": 8,
    "m_nOversampleFactor": 16,
    "m_nShape": 0
  },
  "VMixSubgraphSwitchDesc_t": {
    "m_bOnlyTailsOnFadeOut": 4,
    "m_flInterpolationTime": 8,
    "m_interpolationMode": 0
  },
  "VMixUtilityDesc_t": {
    "m_bBassMono": 16,
    "m_flBassFreq": 20,
    "m_flInputPan": 4,
    "m_flOutputBalance": 8,
    "m_fldbOutputGain": 12,
    "m_nOp": 0
  },
  "VMixVocoderDesc_t": {
    "m_bPeakMode": 36,
    "m_flAttackTimeMS": 24,
    "m_flBandwidth": 4,
    "m_flFreqRangeEnd": 16,
    "m_flFreqRangeStart": 12,
    "m_flReleaseTimeMS": 28,
    "m_fldBModGain": 8,
    "m_fldBUnvoicedGain": 20,
    "m_nBandCount": 0,
    "m_nDebugBand": 32
  }
}
```

`SDK/soundsystem.dll.py`:

```py
'''
https://github.com/a2x/cs2-dumper
2023-11-23 10:28:25.561597200 UTC
'''

class CDSPMixgroupModifier:
    m_mixgroup = 0x0 # CUtlString
    m_flModifier = 0x8 # float
    m_flModifierMin = 0xC # float
    m_flSourceModifier = 0x10 # float
    m_flSourceModifierMin = 0x14 # float
    m_flListenerReverbModifierWhenSourceReverbIsActive = 0x18 # float

class CDSPPresetMixgroupModifierTable:
    m_table = 0x0 # CUtlVector<CDspPresetModifierList>

class CDspPresetModifierList:
    m_dspName = 0x0 # CUtlString
    m_modifiers = 0x8 # CUtlVector<CDSPMixgroupModifier>

class CSosGroupActionLimitSchema:
    m_nMaxCount = 0x18 # int32_t
    m_nStopType = 0x1C # SosActionStopType_t
    m_nSortType = 0x20 # SosActionSortType_t

class CSosGroupActionSchema:
    m_name = 0x8 # CUtlString
    m_actionType = 0x10 # ActionType_t
    m_actionInstanceType = 0x14 # ActionType_t

class CSosGroupActionSetSoundeventParameterSchema:
    m_nMaxCount = 0x18 # int32_t
    m_flMinValue = 0x1C # float
    m_flMaxValue = 0x20 # float
    m_opvarName = 0x28 # CUtlString
    m_nSortType = 0x30 # SosActionSortType_t

class CSosGroupActionTimeLimitSchema:
    m_flMaxDuration = 0x18 # float

class CSosGroupBranchPattern:
    m_bMatchEventName = 0x8 # bool
    m_bMatchEventSubString = 0x9 # bool
    m_bMatchEntIndex = 0xA # bool
    m_bMatchOpvar = 0xB # bool

class CSosGroupMatchPattern:
    m_matchSoundEventName = 0x10 # CUtlString
    m_matchSoundEventSubString = 0x18 # CUtlString
    m_flEntIndex = 0x20 # float
    m_flOpvar = 0x24 # float

class CSosSoundEventGroupListSchema:
    m_groupList = 0x0 # CUtlVector<CSosSoundEventGroupSchema>

class CSosSoundEventGroupSchema:
    m_name = 0x0 # CUtlString
    m_nType = 0x8 # SosGroupType_t
    m_bIsBlocking = 0xC # bool
    m_nBlockMaxCount = 0x10 # int32_t
    m_bInvertMatch = 0x14 # bool
    m_matchPattern = 0x18 # CSosGroupMatchPattern
    m_branchPattern = 0x40 # CSosGroupBranchPattern
    m_vActions = 0xB0 # CSosGroupActionSchema*[4]

class CSoundEventMetaData:
    m_soundEventVMix = 0x0 # CStrongHandle<InfoForResourceTypeCVMixListResource>

class SelectedEditItemInfo_t:
    m_EditItems = 0x0 # CUtlVector<SosEditItemInfo_t>

class SosEditItemInfo_t:
    itemType = 0x0 # SosEditItemType_t
    itemName = 0x8 # CUtlString
    itemTypeName = 0x10 # CUtlString
    itemKVString = 0x20 # CUtlString
    itemPos = 0x28 # Vector2D

class VMixAutoFilterDesc_t:
    m_flEnvelopeAmount = 0x0 # float
    m_flAttackTimeMS = 0x4 # float
    m_flReleaseTimeMS = 0x8 # float
    m_filter = 0xC # VMixFilterDesc_t
    m_flLFOAmount = 0x1C # float
    m_flLFORate = 0x20 # float
    m_flPhase = 0x24 # float
    m_nLFOShape = 0x28 # VMixLFOShape_t

class VMixBoxverbDesc_t:
    m_flSizeMax = 0x0 # float
    m_flSizeMin = 0x4 # float
    m_flComplexity = 0x8 # float
    m_flDiffusion = 0xC # float
    m_flModDepth = 0x10 # float
    m_flModRate = 0x14 # float
    m_bParallel = 0x18 # bool
    m_filterType = 0x1C # VMixFilterDesc_t
    m_flWidth = 0x2C # float
    m_flHeight = 0x30 # float
    m_flDepth = 0x34 # float
    m_flFeedbackScale = 0x38 # float
    m_flFeedbackWidth = 0x3C # float
    m_flFeedbackHeight = 0x40 # float
    m_flFeedbackDepth = 0x44 # float
    m_flOutputGain = 0x48 # float
    m_flTaps = 0x4C # float

class VMixConvolutionDesc_t:
    m_fldbGain = 0x0 # float
    m_flPreDelayMS = 0x4 # float
    m_flWetMix = 0x8 # float
    m_fldbLow = 0xC # float
    m_fldbMid = 0x10 # float
    m_fldbHigh = 0x14 # float
    m_flLowCutoffFreq = 0x18 # float
    m_flHighCutoffFreq = 0x1C # float

class VMixDelayDesc_t:
    m_feedbackFilter = 0x0 # VMixFilterDesc_t
    m_bEnableFilter = 0x10 # bool
    m_flDelay = 0x14 # float
    m_flDirectGain = 0x18 # float
    m_flDelayGain = 0x1C # float
    m_flFeedbackGain = 0x20 # float
    m_flWidth = 0x24 # float

class VMixDiffusorDesc_t:
    m_flSize = 0x0 # float
    m_flComplexity = 0x4 # float
    m_flFeedback = 0x8 # float
    m_flOutputGain = 0xC # float

class VMixDynamics3BandDesc_t:
    m_fldbGainOutput = 0x0 # float
    m_flRMSTimeMS = 0x4 # float
    m_fldbKneeWidth = 0x8 # float
    m_flDepth = 0xC # float
    m_flWetMix = 0x10 # float
    m_flTimeScale = 0x14 # float
    m_flLowCutoffFreq = 0x18 # float
    m_flHighCutoffFreq = 0x1C # float
    m_bPeakMode = 0x20 # bool
    m_bandDesc = 0x24 # VMixDynamicsBand_t[3]

class VMixDynamicsBand_t:
    m_fldbGainInput = 0x0 # float
    m_fldbGainOutput = 0x4 # float
    m_fldbThresholdBelow = 0x8 # float
    m_fldbThresholdAbove = 0xC # float
    m_flRatioBelow = 0x10 # float
    m_flRatioAbove = 0x14 # float
    m_flAttackTimeMS = 0x18 # float
    m_flReleaseTimeMS = 0x1C # float
    m_bEnable = 0x20 # bool
    m_bSolo = 0x21 # bool

class VMixDynamicsCompressorDesc_t:
    m_fldbOutputGain = 0x0 # float
    m_fldbCompressionThreshold = 0x4 # float
    m_fldbKneeWidth = 0x8 # float
    m_flCompressionRatio = 0xC # float
    m_flAttackTimeMS = 0x10 # float
    m_flReleaseTimeMS = 0x14 # float
    m_flRMSTimeMS = 0x18 # float
    m_flWetMix = 0x1C # float
    m_bPeakMode = 0x20 # bool

class VMixDynamicsDesc_t:
    m_fldbGain = 0x0 # float
    m_fldbNoiseGateThreshold = 0x4 # float
    m_fldbCompressionThreshold = 0x8 # float
    m_fldbLimiterThreshold = 0xC # float
    m_fldbKneeWidth = 0x10 # float
    m_flRatio = 0x14 # float
    m_flLimiterRatio = 0x18 # float
    m_flAttackTimeMS = 0x1C # float
    m_flReleaseTimeMS = 0x20 # float
    m_flRMSTimeMS = 0x24 # float
    m_flWetMix = 0x28 # float
    m_bPeakMode = 0x2C # bool

class VMixEQ8Desc_t:
    m_stages = 0x0 # VMixFilterDesc_t[8]

class VMixEffectChainDesc_t:
    m_flCrossfadeTime = 0x0 # float

class VMixEnvelopeDesc_t:
    m_flAttackTimeMS = 0x0 # float
    m_flHoldTimeMS = 0x4 # float
    m_flReleaseTimeMS = 0x8 # float

class VMixFilterDesc_t:
    m_nFilterType = 0x0 # VMixFilterType_t
    m_nFilterSlope = 0x2 # VMixFilterSlope_t
    m_bEnabled = 0x3 # bool
    m_fldbGain = 0x4 # float
    m_flCutoffFreq = 0x8 # float
    m_flQ = 0xC # float

class VMixFreeverbDesc_t:
    m_flRoomSize = 0x0 # float
    m_flDamp = 0x4 # float
    m_flWidth = 0x8 # float
    m_flLateReflections = 0xC # float

class VMixModDelayDesc_t:
    m_feedbackFilter = 0x0 # VMixFilterDesc_t
    m_bPhaseInvert = 0x10 # bool
    m_flGlideTime = 0x14 # float
    m_flDelay = 0x18 # float
    m_flOutputGain = 0x1C # float
    m_flFeedbackGain = 0x20 # float
    m_flModRate = 0x24 # float
    m_flModDepth = 0x28 # float
    m_bApplyAntialiasing = 0x2C # bool

class VMixOscDesc_t:
    oscType = 0x0 # VMixLFOShape_t
    m_freq = 0x4 # float
    m_flPhase = 0x8 # float

class VMixPannerDesc_t:
    m_type = 0x0 # VMixPannerType_t
    m_flStrength = 0x4 # float

class VMixPitchShiftDesc_t:
    m_nGrainSampleCount = 0x0 # int32_t
    m_flPitchShift = 0x4 # float
    m_nQuality = 0x8 # int32_t
    m_nProcType = 0xC # int32_t

class VMixPlateverbDesc_t:
    m_flPrefilter = 0x0 # float
    m_flInputDiffusion1 = 0x4 # float
    m_flInputDiffusion2 = 0x8 # float
    m_flDecay = 0xC # float
    m_flDamp = 0x10 # float
    m_flFeedbackDiffusion1 = 0x14 # float
    m_flFeedbackDiffusion2 = 0x18 # float

class VMixShaperDesc_t:
    m_nShape = 0x0 # int32_t
    m_fldbDrive = 0x4 # float
    m_fldbOutputGain = 0x8 # float
    m_flWetMix = 0xC # float
    m_nOversampleFactor = 0x10 # int32_t

class VMixSubgraphSwitchDesc_t:
    m_interpolationMode = 0x0 # VMixSubgraphSwitchInterpolationType_t
    m_bOnlyTailsOnFadeOut = 0x4 # bool
    m_flInterpolationTime = 0x8 # float

class VMixUtilityDesc_t:
    m_nOp = 0x0 # VMixChannelOperation_t
    m_flInputPan = 0x4 # float
    m_flOutputBalance = 0x8 # float
    m_fldbOutputGain = 0xC # float
    m_bBassMono = 0x10 # bool
    m_flBassFreq = 0x14 # float

class VMixVocoderDesc_t:
    m_nBandCount = 0x0 # int32_t
    m_flBandwidth = 0x4 # float
    m_fldBModGain = 0x8 # float
    m_flFreqRangeStart = 0xC # float
    m_flFreqRangeEnd = 0x10 # float
    m_fldBUnvoicedGain = 0x14 # float
    m_flAttackTimeMS = 0x18 # float
    m_flReleaseTimeMS = 0x1C # float
    m_nDebugBand = 0x20 # int32_t
    m_bPeakMode = 0x24 # bool

```

`SDK/soundsystem.dll.rs`:

```rs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.569803400 UTC
 */

#![allow(non_snake_case, non_upper_case_globals)]

pub mod CDSPMixgroupModifier {
    pub const m_mixgroup: usize = 0x0; // CUtlString
    pub const m_flModifier: usize = 0x8; // float
    pub const m_flModifierMin: usize = 0xC; // float
    pub const m_flSourceModifier: usize = 0x10; // float
    pub const m_flSourceModifierMin: usize = 0x14; // float
    pub const m_flListenerReverbModifierWhenSourceReverbIsActive: usize = 0x18; // float
}

pub mod CDSPPresetMixgroupModifierTable {
    pub const m_table: usize = 0x0; // CUtlVector<CDspPresetModifierList>
}

pub mod CDspPresetModifierList {
    pub const m_dspName: usize = 0x0; // CUtlString
    pub const m_modifiers: usize = 0x8; // CUtlVector<CDSPMixgroupModifier>
}

pub mod CSosGroupActionLimitSchema {
    pub const m_nMaxCount: usize = 0x18; // int32_t
    pub const m_nStopType: usize = 0x1C; // SosActionStopType_t
    pub const m_nSortType: usize = 0x20; // SosActionSortType_t
}

pub mod CSosGroupActionSchema {
    pub const m_name: usize = 0x8; // CUtlString
    pub const m_actionType: usize = 0x10; // ActionType_t
    pub const m_actionInstanceType: usize = 0x14; // ActionType_t
}

pub mod CSosGroupActionSetSoundeventParameterSchema {
    pub const m_nMaxCount: usize = 0x18; // int32_t
    pub const m_flMinValue: usize = 0x1C; // float
    pub const m_flMaxValue: usize = 0x20; // float
    pub const m_opvarName: usize = 0x28; // CUtlString
    pub const m_nSortType: usize = 0x30; // SosActionSortType_t
}

pub mod CSosGroupActionTimeLimitSchema {
    pub const m_flMaxDuration: usize = 0x18; // float
}

pub mod CSosGroupBranchPattern {
    pub const m_bMatchEventName: usize = 0x8; // bool
    pub const m_bMatchEventSubString: usize = 0x9; // bool
    pub const m_bMatchEntIndex: usize = 0xA; // bool
    pub const m_bMatchOpvar: usize = 0xB; // bool
}

pub mod CSosGroupMatchPattern {
    pub const m_matchSoundEventName: usize = 0x10; // CUtlString
    pub const m_matchSoundEventSubString: usize = 0x18; // CUtlString
    pub const m_flEntIndex: usize = 0x20; // float
    pub const m_flOpvar: usize = 0x24; // float
}

pub mod CSosSoundEventGroupListSchema {
    pub const m_groupList: usize = 0x0; // CUtlVector<CSosSoundEventGroupSchema>
}

pub mod CSosSoundEventGroupSchema {
    pub const m_name: usize = 0x0; // CUtlString
    pub const m_nType: usize = 0x8; // SosGroupType_t
    pub const m_bIsBlocking: usize = 0xC; // bool
    pub const m_nBlockMaxCount: usize = 0x10; // int32_t
    pub const m_bInvertMatch: usize = 0x14; // bool
    pub const m_matchPattern: usize = 0x18; // CSosGroupMatchPattern
    pub const m_branchPattern: usize = 0x40; // CSosGroupBranchPattern
    pub const m_vActions: usize = 0xB0; // CSosGroupActionSchema*[4]
}

pub mod CSoundEventMetaData {
    pub const m_soundEventVMix: usize = 0x0; // CStrongHandle<InfoForResourceTypeCVMixListResource>
}

pub mod SelectedEditItemInfo_t {
    pub const m_EditItems: usize = 0x0; // CUtlVector<SosEditItemInfo_t>
}

pub mod SosEditItemInfo_t {
    pub const itemType: usize = 0x0; // SosEditItemType_t
    pub const itemName: usize = 0x8; // CUtlString
    pub const itemTypeName: usize = 0x10; // CUtlString
    pub const itemKVString: usize = 0x20; // CUtlString
    pub const itemPos: usize = 0x28; // Vector2D
}

pub mod VMixAutoFilterDesc_t {
    pub const m_flEnvelopeAmount: usize = 0x0; // float
    pub const m_flAttackTimeMS: usize = 0x4; // float
    pub const m_flReleaseTimeMS: usize = 0x8; // float
    pub const m_filter: usize = 0xC; // VMixFilterDesc_t
    pub const m_flLFOAmount: usize = 0x1C; // float
    pub const m_flLFORate: usize = 0x20; // float
    pub const m_flPhase: usize = 0x24; // float
    pub const m_nLFOShape: usize = 0x28; // VMixLFOShape_t
}

pub mod VMixBoxverbDesc_t {
    pub const m_flSizeMax: usize = 0x0; // float
    pub const m_flSizeMin: usize = 0x4; // float
    pub const m_flComplexity: usize = 0x8; // float
    pub const m_flDiffusion: usize = 0xC; // float
    pub const m_flModDepth: usize = 0x10; // float
    pub const m_flModRate: usize = 0x14; // float
    pub const m_bParallel: usize = 0x18; // bool
    pub const m_filterType: usize = 0x1C; // VMixFilterDesc_t
    pub const m_flWidth: usize = 0x2C; // float
    pub const m_flHeight: usize = 0x30; // float
    pub const m_flDepth: usize = 0x34; // float
    pub const m_flFeedbackScale: usize = 0x38; // float
    pub const m_flFeedbackWidth: usize = 0x3C; // float
    pub const m_flFeedbackHeight: usize = 0x40; // float
    pub const m_flFeedbackDepth: usize = 0x44; // float
    pub const m_flOutputGain: usize = 0x48; // float
    pub const m_flTaps: usize = 0x4C; // float
}

pub mod VMixConvolutionDesc_t {
    pub const m_fldbGain: usize = 0x0; // float
    pub const m_flPreDelayMS: usize = 0x4; // float
    pub const m_flWetMix: usize = 0x8; // float
    pub const m_fldbLow: usize = 0xC; // float
    pub const m_fldbMid: usize = 0x10; // float
    pub const m_fldbHigh: usize = 0x14; // float
    pub const m_flLowCutoffFreq: usize = 0x18; // float
    pub const m_flHighCutoffFreq: usize = 0x1C; // float
}

pub mod VMixDelayDesc_t {
    pub const m_feedbackFilter: usize = 0x0; // VMixFilterDesc_t
    pub const m_bEnableFilter: usize = 0x10; // bool
    pub const m_flDelay: usize = 0x14; // float
    pub const m_flDirectGain: usize = 0x18; // float
    pub const m_flDelayGain: usize = 0x1C; // float
    pub const m_flFeedbackGain: usize = 0x20; // float
    pub const m_flWidth: usize = 0x24; // float
}

pub mod VMixDiffusorDesc_t {
    pub const m_flSize: usize = 0x0; // float
    pub const m_flComplexity: usize = 0x4; // float
    pub const m_flFeedback: usize = 0x8; // float
    pub const m_flOutputGain: usize = 0xC; // float
}

pub mod VMixDynamics3BandDesc_t {
    pub const m_fldbGainOutput: usize = 0x0; // float
    pub const m_flRMSTimeMS: usize = 0x4; // float
    pub const m_fldbKneeWidth: usize = 0x8; // float
    pub const m_flDepth: usize = 0xC; // float
    pub const m_flWetMix: usize = 0x10; // float
    pub const m_flTimeScale: usize = 0x14; // float
    pub const m_flLowCutoffFreq: usize = 0x18; // float
    pub const m_flHighCutoffFreq: usize = 0x1C; // float
    pub const m_bPeakMode: usize = 0x20; // bool
    pub const m_bandDesc: usize = 0x24; // VMixDynamicsBand_t[3]
}

pub mod VMixDynamicsBand_t {
    pub const m_fldbGainInput: usize = 0x0; // float
    pub const m_fldbGainOutput: usize = 0x4; // float
    pub const m_fldbThresholdBelow: usize = 0x8; // float
    pub const m_fldbThresholdAbove: usize = 0xC; // float
    pub const m_flRatioBelow: usize = 0x10; // float
    pub const m_flRatioAbove: usize = 0x14; // float
    pub const m_flAttackTimeMS: usize = 0x18; // float
    pub const m_flReleaseTimeMS: usize = 0x1C; // float
    pub const m_bEnable: usize = 0x20; // bool
    pub const m_bSolo: usize = 0x21; // bool
}

pub mod VMixDynamicsCompressorDesc_t {
    pub const m_fldbOutputGain: usize = 0x0; // float
    pub const m_fldbCompressionThreshold: usize = 0x4; // float
    pub const m_fldbKneeWidth: usize = 0x8; // float
    pub const m_flCompressionRatio: usize = 0xC; // float
    pub const m_flAttackTimeMS: usize = 0x10; // float
    pub const m_flReleaseTimeMS: usize = 0x14; // float
    pub const m_flRMSTimeMS: usize = 0x18; // float
    pub const m_flWetMix: usize = 0x1C; // float
    pub const m_bPeakMode: usize = 0x20; // bool
}

pub mod VMixDynamicsDesc_t {
    pub const m_fldbGain: usize = 0x0; // float
    pub const m_fldbNoiseGateThreshold: usize = 0x4; // float
    pub const m_fldbCompressionThreshold: usize = 0x8; // float
    pub const m_fldbLimiterThreshold: usize = 0xC; // float
    pub const m_fldbKneeWidth: usize = 0x10; // float
    pub const m_flRatio: usize = 0x14; // float
    pub const m_flLimiterRatio: usize = 0x18; // float
    pub const m_flAttackTimeMS: usize = 0x1C; // float
    pub const m_flReleaseTimeMS: usize = 0x20; // float
    pub const m_flRMSTimeMS: usize = 0x24; // float
    pub const m_flWetMix: usize = 0x28; // float
    pub const m_bPeakMode: usize = 0x2C; // bool
}

pub mod VMixEQ8Desc_t {
    pub const m_stages: usize = 0x0; // VMixFilterDesc_t[8]
}

pub mod VMixEffectChainDesc_t {
    pub const m_flCrossfadeTime: usize = 0x0; // float
}

pub mod VMixEnvelopeDesc_t {
    pub const m_flAttackTimeMS: usize = 0x0; // float
    pub const m_flHoldTimeMS: usize = 0x4; // float
    pub const m_flReleaseTimeMS: usize = 0x8; // float
}

pub mod VMixFilterDesc_t {
    pub const m_nFilterType: usize = 0x0; // VMixFilterType_t
    pub const m_nFilterSlope: usize = 0x2; // VMixFilterSlope_t
    pub const m_bEnabled: usize = 0x3; // bool
    pub const m_fldbGain: usize = 0x4; // float
    pub const m_flCutoffFreq: usize = 0x8; // float
    pub const m_flQ: usize = 0xC; // float
}

pub mod VMixFreeverbDesc_t {
    pub const m_flRoomSize: usize = 0x0; // float
    pub const m_flDamp: usize = 0x4; // float
    pub const m_flWidth: usize = 0x8; // float
    pub const m_flLateReflections: usize = 0xC; // float
}

pub mod VMixModDelayDesc_t {
    pub const m_feedbackFilter: usize = 0x0; // VMixFilterDesc_t
    pub const m_bPhaseInvert: usize = 0x10; // bool
    pub const m_flGlideTime: usize = 0x14; // float
    pub const m_flDelay: usize = 0x18; // float
    pub const m_flOutputGain: usize = 0x1C; // float
    pub const m_flFeedbackGain: usize = 0x20; // float
    pub const m_flModRate: usize = 0x24; // float
    pub const m_flModDepth: usize = 0x28; // float
    pub const m_bApplyAntialiasing: usize = 0x2C; // bool
}

pub mod VMixOscDesc_t {
    pub const oscType: usize = 0x0; // VMixLFOShape_t
    pub const m_freq: usize = 0x4; // float
    pub const m_flPhase: usize = 0x8; // float
}

pub mod VMixPannerDesc_t {
    pub const m_type: usize = 0x0; // VMixPannerType_t
    pub const m_flStrength: usize = 0x4; // float
}

pub mod VMixPitchShiftDesc_t {
    pub const m_nGrainSampleCount: usize = 0x0; // int32_t
    pub const m_flPitchShift: usize = 0x4; // float
    pub const m_nQuality: usize = 0x8; // int32_t
    pub const m_nProcType: usize = 0xC; // int32_t
}

pub mod VMixPlateverbDesc_t {
    pub const m_flPrefilter: usize = 0x0; // float
    pub const m_flInputDiffusion1: usize = 0x4; // float
    pub const m_flInputDiffusion2: usize = 0x8; // float
    pub const m_flDecay: usize = 0xC; // float
    pub const m_flDamp: usize = 0x10; // float
    pub const m_flFeedbackDiffusion1: usize = 0x14; // float
    pub const m_flFeedbackDiffusion2: usize = 0x18; // float
}

pub mod VMixShaperDesc_t {
    pub const m_nShape: usize = 0x0; // int32_t
    pub const m_fldbDrive: usize = 0x4; // float
    pub const m_fldbOutputGain: usize = 0x8; // float
    pub const m_flWetMix: usize = 0xC; // float
    pub const m_nOversampleFactor: usize = 0x10; // int32_t
}

pub mod VMixSubgraphSwitchDesc_t {
    pub const m_interpolationMode: usize = 0x0; // VMixSubgraphSwitchInterpolationType_t
    pub const m_bOnlyTailsOnFadeOut: usize = 0x4; // bool
    pub const m_flInterpolationTime: usize = 0x8; // float
}

pub mod VMixUtilityDesc_t {
    pub const m_nOp: usize = 0x0; // VMixChannelOperation_t
    pub const m_flInputPan: usize = 0x4; // float
    pub const m_flOutputBalance: usize = 0x8; // float
    pub const m_fldbOutputGain: usize = 0xC; // float
    pub const m_bBassMono: usize = 0x10; // bool
    pub const m_flBassFreq: usize = 0x14; // float
}

pub mod VMixVocoderDesc_t {
    pub const m_nBandCount: usize = 0x0; // int32_t
    pub const m_flBandwidth: usize = 0x4; // float
    pub const m_fldBModGain: usize = 0x8; // float
    pub const m_flFreqRangeStart: usize = 0xC; // float
    pub const m_flFreqRangeEnd: usize = 0x10; // float
    pub const m_fldBUnvoicedGain: usize = 0x14; // float
    pub const m_flAttackTimeMS: usize = 0x18; // float
    pub const m_flReleaseTimeMS: usize = 0x1C; // float
    pub const m_nDebugBand: usize = 0x20; // int32_t
    pub const m_bPeakMode: usize = 0x24; // bool
}
```

`SDK/vphysics2.dll.cs`:

```cs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.497197900 UTC
 */

public static class CFeIndexedJiggleBone {
    public const nint m_nNode = 0x0; // uint32_t
    public const nint m_nJiggleParent = 0x4; // uint32_t
    public const nint m_jiggleBone = 0x8; // CFeJiggleBone
}

public static class CFeJiggleBone {
    public const nint m_nFlags = 0x0; // uint32_t
    public const nint m_flLength = 0x4; // float
    public const nint m_flTipMass = 0x8; // float
    public const nint m_flYawStiffness = 0xC; // float
    public const nint m_flYawDamping = 0x10; // float
    public const nint m_flPitchStiffness = 0x14; // float
    public const nint m_flPitchDamping = 0x18; // float
    public const nint m_flAlongStiffness = 0x1C; // float
    public const nint m_flAlongDamping = 0x20; // float
    public const nint m_flAngleLimit = 0x24; // float
    public const nint m_flMinYaw = 0x28; // float
    public const nint m_flMaxYaw = 0x2C; // float
    public const nint m_flYawFriction = 0x30; // float
    public const nint m_flYawBounce = 0x34; // float
    public const nint m_flMinPitch = 0x38; // float
    public const nint m_flMaxPitch = 0x3C; // float
    public const nint m_flPitchFriction = 0x40; // float
    public const nint m_flPitchBounce = 0x44; // float
    public const nint m_flBaseMass = 0x48; // float
    public const nint m_flBaseStiffness = 0x4C; // float
    public const nint m_flBaseDamping = 0x50; // float
    public const nint m_flBaseMinLeft = 0x54; // float
    public const nint m_flBaseMaxLeft = 0x58; // float
    public const nint m_flBaseLeftFriction = 0x5C; // float
    public const nint m_flBaseMinUp = 0x60; // float
    public const nint m_flBaseMaxUp = 0x64; // float
    public const nint m_flBaseUpFriction = 0x68; // float
    public const nint m_flBaseMinForward = 0x6C; // float
    public const nint m_flBaseMaxForward = 0x70; // float
    public const nint m_flBaseForwardFriction = 0x74; // float
    public const nint m_flRadius0 = 0x78; // float
    public const nint m_flRadius1 = 0x7C; // float
    public const nint m_vPoint0 = 0x80; // Vector
    public const nint m_vPoint1 = 0x8C; // Vector
    public const nint m_nCollisionMask = 0x98; // uint16_t
}

public static class CFeMorphLayer {
    public const nint m_Name = 0x0; // CUtlString
    public const nint m_nNameHash = 0x8; // uint32_t
    public const nint m_Nodes = 0x10; // CUtlVector<uint16_t>
    public const nint m_InitPos = 0x28; // CUtlVector<Vector>
    public const nint m_Gravity = 0x40; // CUtlVector<float>
    public const nint m_GoalStrength = 0x58; // CUtlVector<float>
    public const nint m_GoalDamping = 0x70; // CUtlVector<float>
}

public static class CFeNamedJiggleBone {
    public const nint m_strParentBone = 0x0; // CUtlString
    public const nint m_transform = 0x10; // CTransform
    public const nint m_nJiggleParent = 0x30; // uint32_t
    public const nint m_jiggleBone = 0x34; // CFeJiggleBone
}

public static class CFeVertexMapBuildArray {
    public const nint m_Array = 0x0; // CUtlVector<FeVertexMapBuild_t*>
}

public static class CRegionSVM {
    public const nint m_Planes = 0x0; // CUtlVector<RnPlane_t>
    public const nint m_Nodes = 0x18; // CUtlVector<uint32_t>
}

public static class CastSphereSATParams_t {
    public const nint m_vRayStart = 0x0; // Vector
    public const nint m_vRayDelta = 0xC; // Vector
    public const nint m_flRadius = 0x18; // float
    public const nint m_flMaxFraction = 0x1C; // float
    public const nint m_flScale = 0x20; // float
    public const nint m_pHull = 0x28; // RnHull_t*
}

public static class CovMatrix3 {
    public const nint m_vDiag = 0x0; // Vector
    public const nint m_flXY = 0xC; // float
    public const nint m_flXZ = 0x10; // float
    public const nint m_flYZ = 0x14; // float
}

public static class Dop26_t {
    public const nint m_flSupport = 0x0; // float[26]
}

public static class FeAnimStrayRadius_t {
    public const nint nNode = 0x0; // uint16_t[2]
    public const nint flMaxDist = 0x4; // float
    public const nint flRelaxationFactor = 0x8; // float
}

public static class FeAxialEdgeBend_t {
    public const nint te = 0x0; // float
    public const nint tv = 0x4; // float
    public const nint flDist = 0x8; // float
    public const nint flWeight = 0xC; // float[4]
    public const nint nNode = 0x1C; // uint16_t[6]
}

public static class FeBandBendLimit_t {
    public const nint flDistMin = 0x0; // float
    public const nint flDistMax = 0x4; // float
    public const nint nNode = 0x8; // uint16_t[6]
}

public static class FeBoxRigid_t {
    public const nint tmFrame2 = 0x0; // CTransform
    public const nint nNode = 0x20; // uint16_t
    public const nint nCollisionMask = 0x22; // uint16_t
    public const nint vSize = 0x24; // Vector
    public const nint nVertexMapIndex = 0x30; // uint16_t
    public const nint nFlags = 0x32; // uint16_t
}

public static class FeBuildBoxRigid_t {
    public const nint m_nPriority = 0x40; // int32_t
    public const nint m_nVertexMapHash = 0x44; // uint32_t
}

public static class FeBuildSphereRigid_t {
    public const nint m_nPriority = 0x20; // int32_t
    public const nint m_nVertexMapHash = 0x24; // uint32_t
}

public static class FeBuildTaperedCapsuleRigid_t {
    public const nint m_nPriority = 0x30; // int32_t
    public const nint m_nVertexMapHash = 0x34; // uint32_t
}

public static class FeCollisionPlane_t {
    public const nint nCtrlParent = 0x0; // uint16_t
    public const nint nChildNode = 0x2; // uint16_t
    public const nint m_Plane = 0x4; // RnPlane_t
    public const nint flStrength = 0x14; // float
}

public static class FeCtrlOffset_t {
    public const nint vOffset = 0x0; // Vector
    public const nint nCtrlParent = 0xC; // uint16_t
    public const nint nCtrlChild = 0xE; // uint16_t
}

public static class FeCtrlOsOffset_t {
    public const nint nCtrlParent = 0x0; // uint16_t
    public const nint nCtrlChild = 0x2; // uint16_t
}

public static class FeCtrlSoftOffset_t {
    public const nint nCtrlParent = 0x0; // uint16_t
    public const nint nCtrlChild = 0x2; // uint16_t
    public const nint vOffset = 0x4; // Vector
    public const nint flAlpha = 0x10; // float
}

public static class FeEdgeDesc_t {
    public const nint nEdge = 0x0; // uint16_t[2]
    public const nint nSide = 0x4; // uint16_t[2][2]
    public const nint nVirtElem = 0xC; // uint16_t[2]
}

public static class FeEffectDesc_t {
    public const nint sName = 0x0; // CUtlString
    public const nint nNameHash = 0x8; // uint32_t
    public const nint nType = 0xC; // int32_t
    public const nint m_Params = 0x10; // KeyValues3
}

public static class FeFitInfluence_t {
    public const nint nVertexNode = 0x0; // uint32_t
    public const nint flWeight = 0x4; // float
    public const nint nMatrixNode = 0x8; // uint32_t
}

public static class FeFitMatrix_t {
    public const nint bone = 0x0; // CTransform
    public const nint vCenter = 0x20; // Vector
    public const nint nEnd = 0x2C; // uint16_t
    public const nint nNode = 0x2E; // uint16_t
    public const nint nBeginDynamic = 0x30; // uint16_t
}

public static class FeFitWeight_t {
    public const nint flWeight = 0x0; // float
    public const nint nNode = 0x4; // uint16_t
    public const nint nDummy = 0x6; // uint16_t
}

public static class FeFollowNode_t {
    public const nint nParentNode = 0x0; // uint16_t
    public const nint nChildNode = 0x2; // uint16_t
    public const nint flWeight = 0x4; // float
}

public static class FeKelagerBend2_t {
    public const nint flWeight = 0x0; // float[3]
    public const nint flHeight0 = 0xC; // float
    public const nint nNode = 0x10; // uint16_t[3]
    public const nint nReserved = 0x16; // uint16_t
}

public static class FeMorphLayerDepr_t {
    public const nint m_Name = 0x0; // CUtlString
    public const nint m_nNameHash = 0x8; // uint32_t
    public const nint m_Nodes = 0x10; // CUtlVector<uint16_t>
    public const nint m_InitPos = 0x28; // CUtlVector<Vector>
    public const nint m_Gravity = 0x40; // CUtlVector<float>
    public const nint m_GoalStrength = 0x58; // CUtlVector<float>
    public const nint m_GoalDamping = 0x70; // CUtlVector<float>
    public const nint m_nFlags = 0x88; // uint32_t
}

public static class FeNodeBase_t {
    public const nint nNode = 0x0; // uint16_t
    public const nint nDummy = 0x2; // uint16_t[3]
    public const nint nNodeX0 = 0x8; // uint16_t
    public const nint nNodeX1 = 0xA; // uint16_t
    public const nint nNodeY0 = 0xC; // uint16_t
    public const nint nNodeY1 = 0xE; // uint16_t
    public const nint qAdjust = 0x10; // QuaternionStorage
}

public static class FeNodeIntegrator_t {
    public const nint flPointDamping = 0x0; // float
    public const nint flAnimationForceAttraction = 0x4; // float
    public const nint flAnimationVertexAttraction = 0x8; // float
    public const nint flGravity = 0xC; // float
}

public static class FeNodeReverseOffset_t {
    public const nint vOffset = 0x0; // Vector
    public const nint nBoneCtrl = 0xC; // uint16_t
    public const nint nTargetNode = 0xE; // uint16_t
}

public static class FeNodeWindBase_t {
    public const nint nNodeX0 = 0x0; // uint16_t
    public const nint nNodeX1 = 0x2; // uint16_t
    public const nint nNodeY0 = 0x4; // uint16_t
    public const nint nNodeY1 = 0x6; // uint16_t
}

public static class FeProxyVertexMap_t {
    public const nint m_Name = 0x0; // CUtlString
    public const nint m_flWeight = 0x8; // float
}

public static class FeQuad_t {
    public const nint nNode = 0x0; // uint16_t[4]
    public const nint flSlack = 0x8; // float
    public const nint vShape = 0xC; // Vector4D[4]
}

public static class FeRigidColliderIndices_t {
    public const nint m_nTaperedCapsuleRigidIndex = 0x0; // uint16_t
    public const nint m_nSphereRigidIndex = 0x2; // uint16_t
    public const nint m_nBoxRigidIndex = 0x4; // uint16_t
    public const nint m_nCollisionPlaneIndex = 0x6; // uint16_t
}

public static class FeRodConstraint_t {
    public const nint nNode = 0x0; // uint16_t[2]
    public const nint flMaxDist = 0x4; // float
    public const nint flMinDist = 0x8; // float
    public const nint flWeight0 = 0xC; // float
    public const nint flRelaxationFactor = 0x10; // float
}

public static class FeSimdAnimStrayRadius_t {
    public const nint nNode = 0x0; // uint16_t[4][2]
    public const nint flMaxDist = 0x10; // fltx4
    public const nint flRelaxationFactor = 0x20; // fltx4
}

public static class FeSimdNodeBase_t {
    public const nint nNode = 0x0; // uint16_t[4]
    public const nint nNodeX0 = 0x8; // uint16_t[4]
    public const nint nNodeX1 = 0x10; // uint16_t[4]
    public const nint nNodeY0 = 0x18; // uint16_t[4]
    public const nint nNodeY1 = 0x20; // uint16_t[4]
    public const nint nDummy = 0x28; // uint16_t[4]
    public const nint qAdjust = 0x30; // FourQuaternions
}

public static class FeSimdQuad_t {
    public const nint nNode = 0x0; // uint16_t[4][4]
    public const nint f4Slack = 0x20; // fltx4
    public const nint vShape = 0x30; // FourVectors[4]
    public const nint f4Weights = 0xF0; // fltx4[4]
}

public static class FeSimdRodConstraint_t {
    public const nint nNode = 0x0; // uint16_t[4][2]
    public const nint f4MaxDist = 0x10; // fltx4
    public const nint f4MinDist = 0x20; // fltx4
    public const nint f4Weight0 = 0x30; // fltx4
    public const nint f4RelaxationFactor = 0x40; // fltx4
}

public static class FeSimdSpringIntegrator_t {
    public const nint nNode = 0x0; // uint16_t[4][2]
    public const nint flSpringRestLength = 0x10; // fltx4
    public const nint flSpringConstant = 0x20; // fltx4
    public const nint flSpringDamping = 0x30; // fltx4
    public const nint flNodeWeight0 = 0x40; // fltx4
}

public static class FeSimdTri_t {
    public const nint nNode = 0x0; // uint32_t[4][3]
    public const nint w1 = 0x30; // fltx4
    public const nint w2 = 0x40; // fltx4
    public const nint v1x = 0x50; // fltx4
    public const nint v2 = 0x60; // FourVectors2D
}

public static class FeSoftParent_t {
    public const nint nParent = 0x0; // int32_t
    public const nint flAlpha = 0x4; // float
}

public static class FeSourceEdge_t {
    public const nint nNode = 0x0; // uint16_t[2]
}

public static class FeSphereRigid_t {
    public const nint vSphere = 0x0; // fltx4
    public const nint nNode = 0x10; // uint16_t
    public const nint nCollisionMask = 0x12; // uint16_t
    public const nint nVertexMapIndex = 0x14; // uint16_t
    public const nint nFlags = 0x16; // uint16_t
}

public static class FeSpringIntegrator_t {
    public const nint nNode = 0x0; // uint16_t[2]
    public const nint flSpringRestLength = 0x4; // float
    public const nint flSpringConstant = 0x8; // float
    public const nint flSpringDamping = 0xC; // float
    public const nint flNodeWeight0 = 0x10; // float
}

public static class FeStiffHingeBuild_t {
    public const nint flMaxAngle = 0x0; // float
    public const nint flStrength = 0x4; // float
    public const nint flMotionBias = 0x8; // float[3]
    public const nint nNode = 0x14; // uint16_t[3]
}

public static class FeTaperedCapsuleRigid_t {
    public const nint vSphere = 0x0; // fltx4[2]
    public const nint nNode = 0x20; // uint16_t
    public const nint nCollisionMask = 0x22; // uint16_t
    public const nint nVertexMapIndex = 0x24; // uint16_t
    public const nint nFlags = 0x26; // uint16_t
}

public static class FeTaperedCapsuleStretch_t {
    public const nint nNode = 0x0; // uint16_t[2]
    public const nint nCollisionMask = 0x4; // uint16_t
    public const nint nDummy = 0x6; // uint16_t
    public const nint flRadius = 0x8; // float[2]
}

public static class FeTreeChildren_t {
    public const nint nChild = 0x0; // uint16_t[2]
}

public static class FeTri_t {
    public const nint nNode = 0x0; // uint16_t[3]
    public const nint w1 = 0x8; // float
    public const nint w2 = 0xC; // float
    public const nint v1x = 0x10; // float
    public const nint v2 = 0x14; // Vector2D
}

public static class FeTwistConstraint_t {
    public const nint nNodeOrient = 0x0; // uint16_t
    public const nint nNodeEnd = 0x2; // uint16_t
    public const nint flTwistRelax = 0x4; // float
    public const nint flSwingRelax = 0x8; // float
}

public static class FeVertexMapBuild_t {
    public const nint m_VertexMapName = 0x0; // CUtlString
    public const nint m_nNameHash = 0x8; // uint32_t
    public const nint m_Color = 0xC; // Color
    public const nint m_flVolumetricSolveStrength = 0x10; // float
    public const nint m_nScaleSourceNode = 0x14; // int32_t
    public const nint m_Weights = 0x18; // CUtlVector<float>
}

public static class FeVertexMapDesc_t {
    public const nint sName = 0x0; // CUtlString
    public const nint nNameHash = 0x8; // uint32_t
    public const nint nColor = 0xC; // uint32_t
    public const nint nFlags = 0x10; // uint32_t
    public const nint nVertexBase = 0x14; // uint16_t
    public const nint nVertexCount = 0x16; // uint16_t
    public const nint nMapOffset = 0x18; // uint32_t
    public const nint nNodeListOffset = 0x1C; // uint32_t
    public const nint vCenterOfMass = 0x20; // Vector
    public const nint flVolumetricSolveStrength = 0x2C; // float
    public const nint nScaleSourceNode = 0x30; // int16_t
    public const nint nNodeListCount = 0x32; // uint16_t
}

public static class FeWeightedNode_t {
    public const nint nNode = 0x0; // uint16_t
    public const nint nWeight = 0x2; // uint16_t
}

public static class FeWorldCollisionParams_t {
    public const nint flWorldFriction = 0x0; // float
    public const nint flGroundFriction = 0x4; // float
    public const nint nListBegin = 0x8; // uint16_t
    public const nint nListEnd = 0xA; // uint16_t
}

public static class FourCovMatrices3 {
    public const nint m_vDiag = 0x0; // FourVectors
    public const nint m_flXY = 0x30; // fltx4
    public const nint m_flXZ = 0x40; // fltx4
    public const nint m_flYZ = 0x50; // fltx4
}

public static class FourVectors2D {
    public const nint x = 0x0; // fltx4
    public const nint y = 0x10; // fltx4
}

public static class OldFeEdge_t {
    public const nint m_flK = 0x0; // float[3]
    public const nint invA = 0xC; // float
    public const nint t = 0x10; // float
    public const nint flThetaRelaxed = 0x14; // float
    public const nint flThetaFactor = 0x18; // float
    public const nint c01 = 0x1C; // float
    public const nint c02 = 0x20; // float
    public const nint c03 = 0x24; // float
    public const nint c04 = 0x28; // float
    public const nint flAxialModelDist = 0x2C; // float
    public const nint flAxialModelWeights = 0x30; // float[4]
    public const nint m_nNode = 0x40; // uint16_t[4]
}

public static class PhysFeModelDesc_t {
    public const nint m_CtrlHash = 0x0; // CUtlVector<uint32_t>
    public const nint m_CtrlName = 0x18; // CUtlVector<CUtlString>
    public const nint m_nStaticNodeFlags = 0x30; // uint32_t
    public const nint m_nDynamicNodeFlags = 0x34; // uint32_t
    public const nint m_flLocalForce = 0x38; // float
    public const nint m_flLocalRotation = 0x3C; // float
    public const nint m_nNodeCount = 0x40; // uint16_t
    public const nint m_nStaticNodes = 0x42; // uint16_t
    public const nint m_nRotLockStaticNodes = 0x44; // uint16_t
    public const nint m_nFirstPositionDrivenNode = 0x46; // uint16_t
    public const nint m_nSimdTriCount1 = 0x48; // uint16_t
    public const nint m_nSimdTriCount2 = 0x4A; // uint16_t
    public const nint m_nSimdQuadCount1 = 0x4C; // uint16_t
    public const nint m_nSimdQuadCount2 = 0x4E; // uint16_t
    public const nint m_nQuadCount1 = 0x50; // uint16_t
    public const nint m_nQuadCount2 = 0x52; // uint16_t
    public const nint m_nTreeDepth = 0x54; // uint16_t
    public const nint m_nNodeBaseJiggleboneDependsCount = 0x56; // uint16_t
    public const nint m_nRopeCount = 0x58; // uint16_t
    public const nint m_Ropes = 0x60; // CUtlVector<uint16_t>
    public const nint m_NodeBases = 0x78; // CUtlVector<FeNodeBase_t>
    public const nint m_SimdNodeBases = 0x90; // CUtlVector<FeSimdNodeBase_t>
    public const nint m_Quads = 0xA8; // CUtlVector<FeQuad_t>
    public const nint m_SimdQuads = 0xC0; // CUtlVector<FeSimdQuad_t>
    public const nint m_SimdTris = 0xD8; // CUtlVector<FeSimdTri_t>
    public const nint m_SimdRods = 0xF0; // CUtlVector<FeSimdRodConstraint_t>
    public const nint m_InitPose = 0x108; // CUtlVector<CTransform>
    public const nint m_Rods = 0x120; // CUtlVector<FeRodConstraint_t>
    public const nint m_Twists = 0x138; // CUtlVector<FeTwistConstraint_t>
    public const nint m_AxialEdges = 0x150; // CUtlVector<FeAxialEdgeBend_t>
    public const nint m_NodeInvMasses = 0x168; // CUtlVector<float>
    public const nint m_CtrlOffsets = 0x180; // CUtlVector<FeCtrlOffset_t>
    public const nint m_CtrlOsOffsets = 0x198; // CUtlVector<FeCtrlOsOffset_t>
    public const nint m_FollowNodes = 0x1B0; // CUtlVector<FeFollowNode_t>
    public const nint m_CollisionPlanes = 0x1C8; // CUtlVector<FeCollisionPlane_t>
    public const nint m_NodeIntegrator = 0x1E0; // CUtlVector<FeNodeIntegrator_t>
    public const nint m_SpringIntegrator = 0x1F8; // CUtlVector<FeSpringIntegrator_t>
    public const nint m_SimdSpringIntegrator = 0x210; // CUtlVector<FeSimdSpringIntegrator_t>
    public const nint m_WorldCollisionParams = 0x228; // CUtlVector<FeWorldCollisionParams_t>
    public const nint m_LegacyStretchForce = 0x240; // CUtlVector<float>
    public const nint m_NodeCollisionRadii = 0x258; // CUtlVector<float>
    public const nint m_DynNodeFriction = 0x270; // CUtlVector<float>
    public const nint m_LocalRotation = 0x288; // CUtlVector<float>
    public const nint m_LocalForce = 0x2A0; // CUtlVector<float>
    public const nint m_TaperedCapsuleStretches = 0x2B8; // CUtlVector<FeTaperedCapsuleStretch_t>
    public const nint m_TaperedCapsuleRigids = 0x2D0; // CUtlVector<FeTaperedCapsuleRigid_t>
    public const nint m_SphereRigids = 0x2E8; // CUtlVector<FeSphereRigid_t>
    public const nint m_WorldCollisionNodes = 0x300; // CUtlVector<uint16_t>
    public const nint m_TreeParents = 0x318; // CUtlVector<uint16_t>
    public const nint m_TreeCollisionMasks = 0x330; // CUtlVector<uint16_t>
    public const nint m_TreeChildren = 0x348; // CUtlVector<FeTreeChildren_t>
    public const nint m_FreeNodes = 0x360; // CUtlVector<uint16_t>
    public const nint m_FitMatrices = 0x378; // CUtlVector<FeFitMatrix_t>
    public const nint m_FitWeights = 0x390; // CUtlVector<FeFitWeight_t>
    public const nint m_ReverseOffsets = 0x3A8; // CUtlVector<FeNodeReverseOffset_t>
    public const nint m_AnimStrayRadii = 0x3C0; // CUtlVector<FeAnimStrayRadius_t>
    public const nint m_SimdAnimStrayRadii = 0x3D8; // CUtlVector<FeSimdAnimStrayRadius_t>
    public const nint m_KelagerBends = 0x3F0; // CUtlVector<FeKelagerBend2_t>
    public const nint m_CtrlSoftOffsets = 0x408; // CUtlVector<FeCtrlSoftOffset_t>
    public const nint m_JiggleBones = 0x420; // CUtlVector<CFeIndexedJiggleBone>
    public const nint m_SourceElems = 0x438; // CUtlVector<uint16_t>
    public const nint m_GoalDampedSpringIntegrators = 0x450; // CUtlVector<uint32_t>
    public const nint m_Tris = 0x468; // CUtlVector<FeTri_t>
    public const nint m_nTriCount1 = 0x480; // uint16_t
    public const nint m_nTriCount2 = 0x482; // uint16_t
    public const nint m_nReservedUint8 = 0x484; // uint8_t
    public const nint m_nExtraPressureIterations = 0x485; // uint8_t
    public const nint m_nExtraGoalIterations = 0x486; // uint8_t
    public const nint m_nExtraIterations = 0x487; // uint8_t
    public const nint m_BoxRigids = 0x488; // CUtlVector<FeBoxRigid_t>
    public const nint m_DynNodeVertexSet = 0x4A0; // CUtlVector<uint8_t>
    public const nint m_VertexSetNames = 0x4B8; // CUtlVector<uint32_t>
    public const nint m_RigidColliderPriorities = 0x4D0; // CUtlVector<FeRigidColliderIndices_t>
    public const nint m_MorphLayers = 0x4E8; // CUtlVector<FeMorphLayerDepr_t>
    public const nint m_MorphSetData = 0x500; // CUtlVector<uint8_t>
    public const nint m_VertexMaps = 0x518; // CUtlVector<FeVertexMapDesc_t>
    public const nint m_VertexMapValues = 0x530; // CUtlVector<uint8_t>
    public const nint m_Effects = 0x548; // CUtlVector<FeEffectDesc_t>
    public const nint m_LockToParent = 0x560; // CUtlVector<FeCtrlOffset_t>
    public const nint m_LockToGoal = 0x578; // CUtlVector<uint16_t>
    public const nint m_DynNodeWindBases = 0x590; // CUtlVector<FeNodeWindBase_t>
    public const nint m_flInternalPressure = 0x5A8; // float
    public const nint m_flDefaultTimeDilation = 0x5AC; // float
    public const nint m_flWindage = 0x5B0; // float
    public const nint m_flWindDrag = 0x5B4; // float
    public const nint m_flDefaultSurfaceStretch = 0x5B8; // float
    public const nint m_flDefaultThreadStretch = 0x5BC; // float
    public const nint m_flDefaultGravityScale = 0x5C0; // float
    public const nint m_flDefaultVelAirDrag = 0x5C4; // float
    public const nint m_flDefaultExpAirDrag = 0x5C8; // float
    public const nint m_flDefaultVelQuadAirDrag = 0x5CC; // float
    public const nint m_flDefaultExpQuadAirDrag = 0x5D0; // float
    public const nint m_flRodVelocitySmoothRate = 0x5D4; // float
    public const nint m_flQuadVelocitySmoothRate = 0x5D8; // float
    public const nint m_flAddWorldCollisionRadius = 0x5DC; // float
    public const nint m_flDefaultVolumetricSolveAmount = 0x5E0; // float
    public const nint m_nRodVelocitySmoothIterations = 0x5E4; // uint16_t
    public const nint m_nQuadVelocitySmoothIterations = 0x5E6; // uint16_t
}

public static class RnBlendVertex_t {
    public const nint m_nWeight0 = 0x0; // uint16_t
    public const nint m_nIndex0 = 0x2; // uint16_t
    public const nint m_nWeight1 = 0x4; // uint16_t
    public const nint m_nIndex1 = 0x6; // uint16_t
    public const nint m_nWeight2 = 0x8; // uint16_t
    public const nint m_nIndex2 = 0xA; // uint16_t
    public const nint m_nFlags = 0xC; // uint16_t
    public const nint m_nTargetIndex = 0xE; // uint16_t
}

public static class RnBodyDesc_t {
    public const nint m_sDebugName = 0x0; // CUtlString
    public const nint m_vPosition = 0x8; // Vector
    public const nint m_qOrientation = 0x14; // QuaternionStorage
    public const nint m_vLinearVelocity = 0x24; // Vector
    public const nint m_vAngularVelocity = 0x30; // Vector
    public const nint m_vLocalMassCenter = 0x3C; // Vector
    public const nint m_LocalInertiaInv = 0x48; // Vector[3]
    public const nint m_flMassInv = 0x6C; // float
    public const nint m_flGameMass = 0x70; // float
    public const nint m_flInertiaScaleInv = 0x74; // float
    public const nint m_flLinearDamping = 0x78; // float
    public const nint m_flAngularDamping = 0x7C; // float
    public const nint m_flLinearDrag = 0x80; // float
    public const nint m_flAngularDrag = 0x84; // float
    public const nint m_flLinearBuoyancyDrag = 0x88; // float
    public const nint m_flAngularBuoyancyDrag = 0x8C; // float
    public const nint m_vLastAwakeForceAccum = 0x90; // Vector
    public const nint m_vLastAwakeTorqueAccum = 0x9C; // Vector
    public const nint m_flBuoyancyFactor = 0xA8; // float
    public const nint m_flGravityScale = 0xAC; // float
    public const nint m_flTimeScale = 0xB0; // float
    public const nint m_nBodyType = 0xB4; // int32_t
    public const nint m_nGameIndex = 0xB8; // uint32_t
    public const nint m_nGameFlags = 0xBC; // uint32_t
    public const nint m_nMinVelocityIterations = 0xC0; // int8_t
    public const nint m_nMinPositionIterations = 0xC1; // int8_t
    public const nint m_nMassPriority = 0xC2; // int8_t
    public const nint m_bEnabled = 0xC3; // bool
    public const nint m_bSleeping = 0xC4; // bool
    public const nint m_bIsContinuousEnabled = 0xC5; // bool
    public const nint m_bDragEnabled = 0xC6; // bool
    public const nint m_bBuoyancyDragEnabled = 0xC7; // bool
    public const nint m_bGravityDisabled = 0xC8; // bool
    public const nint m_bSpeculativeEnabled = 0xC9; // bool
    public const nint m_bHasShadowController = 0xCA; // bool
}

public static class RnCapsuleDesc_t {
    public const nint m_Capsule = 0x10; // RnCapsule_t
}

public static class RnCapsule_t {
    public const nint m_vCenter = 0x0; // Vector[2]
    public const nint m_flRadius = 0x18; // float
}

public static class RnFace_t {
    public const nint m_nEdge = 0x0; // uint8_t
}

public static class RnHalfEdge_t {
    public const nint m_nNext = 0x0; // uint8_t
    public const nint m_nTwin = 0x1; // uint8_t
    public const nint m_nOrigin = 0x2; // uint8_t
    public const nint m_nFace = 0x3; // uint8_t
}

public static class RnHullDesc_t {
    public const nint m_Hull = 0x10; // RnHull_t
}

public static class RnHull_t {
    public const nint m_vCentroid = 0x0; // Vector
    public const nint m_flMaxAngularRadius = 0xC; // float
    public const nint m_Bounds = 0x10; // AABB_t
    public const nint m_vOrthographicAreas = 0x28; // Vector
    public const nint m_MassProperties = 0x34; // matrix3x4_t
    public const nint m_flVolume = 0x64; // float
    public const nint m_Vertices = 0x68; // CUtlVector<RnVertex_t>
    public const nint m_VertexPositions = 0x80; // CUtlVector<Vector>
    public const nint m_Edges = 0x98; // CUtlVector<RnHalfEdge_t>
    public const nint m_Faces = 0xB0; // CUtlVector<RnFace_t>
    public const nint m_FacePlanes = 0xC8; // CUtlVector<RnPlane_t>
    public const nint m_nFlags = 0xE0; // uint32_t
    public const nint m_pRegionSVM = 0xE8; // CRegionSVM*
}

public static class RnMeshDesc_t {
    public const nint m_Mesh = 0x10; // RnMesh_t
}

public static class RnMesh_t {
    public const nint m_vMin = 0x0; // Vector
    public const nint m_vMax = 0xC; // Vector
    public const nint m_Nodes = 0x18; // CUtlVector<RnNode_t>
    public const nint m_Vertices = 0x30; // CUtlVectorSIMDPaddedVector
    public const nint m_Triangles = 0x48; // CUtlVector<RnTriangle_t>
    public const nint m_Wings = 0x60; // CUtlVector<RnWing_t>
    public const nint m_Materials = 0x78; // CUtlVector<uint8_t>
    public const nint m_vOrthographicAreas = 0x90; // Vector
    public const nint m_nFlags = 0x9C; // uint32_t
    public const nint m_nDebugFlags = 0xA0; // uint32_t
}

public static class RnNode_t {
    public const nint m_vMin = 0x0; // Vector
    public const nint m_nChildren = 0xC; // uint32_t
    public const nint m_vMax = 0x10; // Vector
    public const nint m_nTriangleOffset = 0x1C; // uint32_t
}

public static class RnPlane_t {
    public const nint m_vNormal = 0x0; // Vector
    public const nint m_flOffset = 0xC; // float
}

public static class RnShapeDesc_t {
    public const nint m_nCollisionAttributeIndex = 0x0; // uint32_t
    public const nint m_nSurfacePropertyIndex = 0x4; // uint32_t
    public const nint m_UserFriendlyName = 0x8; // CUtlString
}

public static class RnSoftbodyCapsule_t {
    public const nint m_vCenter = 0x0; // Vector[2]
    public const nint m_flRadius = 0x18; // float
    public const nint m_nParticle = 0x1C; // uint16_t[2]
}

public static class RnSoftbodyParticle_t {
    public const nint m_flMassInv = 0x0; // float
}

public static class RnSoftbodySpring_t {
    public const nint m_nParticle = 0x0; // uint16_t[2]
    public const nint m_flLength = 0x4; // float
}

public static class RnSphereDesc_t {
    public const nint m_Sphere = 0x10; // RnSphere_t
}

public static class RnSphere_t {
    public const nint m_vCenter = 0x0; // Vector
    public const nint m_flRadius = 0xC; // float
}

public static class RnTriangle_t {
    public const nint m_nIndex = 0x0; // int32_t[3]
}

public static class RnVertex_t {
    public const nint m_nEdge = 0x0; // uint8_t
}

public static class RnWing_t {
    public const nint m_nIndex = 0x0; // int32_t[3]
}

public static class VertexPositionColor_t {
    public const nint m_vPosition = 0x0; // Vector
}

public static class VertexPositionNormal_t {
    public const nint m_vPosition = 0x0; // Vector
    public const nint m_vNormal = 0xC; // Vector
}

public static class constraint_axislimit_t {
    public const nint flMinRotation = 0x0; // float
    public const nint flMaxRotation = 0x4; // float
    public const nint flMotorTargetAngSpeed = 0x8; // float
    public const nint flMotorMaxTorque = 0xC; // float
}

public static class constraint_breakableparams_t {
    public const nint strength = 0x0; // float
    public const nint forceLimit = 0x4; // float
    public const nint torqueLimit = 0x8; // float
    public const nint bodyMassScale = 0xC; // float[2]
    public const nint isActive = 0x14; // bool
}

public static class constraint_hingeparams_t {
    public const nint worldPosition = 0x0; // Vector
    public const nint worldAxisDirection = 0xC; // Vector
    public const nint hingeAxis = 0x18; // constraint_axislimit_t
    public const nint constraint = 0x28; // constraint_breakableparams_t
}

public static class vphysics_save_cphysicsbody_t {
    public const nint m_nOldPointer = 0xD0; // uint64_t
}
```

`SDK/vphysics2.dll.hpp`:

```hpp
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.482765200 UTC
 */

#pragma once

#include <cstddef>

namespace CFeIndexedJiggleBone {
    constexpr std::ptrdiff_t m_nNode = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_nJiggleParent = 0x4; // uint32_t
    constexpr std::ptrdiff_t m_jiggleBone = 0x8; // CFeJiggleBone
}

namespace CFeJiggleBone {
    constexpr std::ptrdiff_t m_nFlags = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_flLength = 0x4; // float
    constexpr std::ptrdiff_t m_flTipMass = 0x8; // float
    constexpr std::ptrdiff_t m_flYawStiffness = 0xC; // float
    constexpr std::ptrdiff_t m_flYawDamping = 0x10; // float
    constexpr std::ptrdiff_t m_flPitchStiffness = 0x14; // float
    constexpr std::ptrdiff_t m_flPitchDamping = 0x18; // float
    constexpr std::ptrdiff_t m_flAlongStiffness = 0x1C; // float
    constexpr std::ptrdiff_t m_flAlongDamping = 0x20; // float
    constexpr std::ptrdiff_t m_flAngleLimit = 0x24; // float
    constexpr std::ptrdiff_t m_flMinYaw = 0x28; // float
    constexpr std::ptrdiff_t m_flMaxYaw = 0x2C; // float
    constexpr std::ptrdiff_t m_flYawFriction = 0x30; // float
    constexpr std::ptrdiff_t m_flYawBounce = 0x34; // float
    constexpr std::ptrdiff_t m_flMinPitch = 0x38; // float
    constexpr std::ptrdiff_t m_flMaxPitch = 0x3C; // float
    constexpr std::ptrdiff_t m_flPitchFriction = 0x40; // float
    constexpr std::ptrdiff_t m_flPitchBounce = 0x44; // float
    constexpr std::ptrdiff_t m_flBaseMass = 0x48; // float
    constexpr std::ptrdiff_t m_flBaseStiffness = 0x4C; // float
    constexpr std::ptrdiff_t m_flBaseDamping = 0x50; // float
    constexpr std::ptrdiff_t m_flBaseMinLeft = 0x54; // float
    constexpr std::ptrdiff_t m_flBaseMaxLeft = 0x58; // float
    constexpr std::ptrdiff_t m_flBaseLeftFriction = 0x5C; // float
    constexpr std::ptrdiff_t m_flBaseMinUp = 0x60; // float
    constexpr std::ptrdiff_t m_flBaseMaxUp = 0x64; // float
    constexpr std::ptrdiff_t m_flBaseUpFriction = 0x68; // float
    constexpr std::ptrdiff_t m_flBaseMinForward = 0x6C; // float
    constexpr std::ptrdiff_t m_flBaseMaxForward = 0x70; // float
    constexpr std::ptrdiff_t m_flBaseForwardFriction = 0x74; // float
    constexpr std::ptrdiff_t m_flRadius0 = 0x78; // float
    constexpr std::ptrdiff_t m_flRadius1 = 0x7C; // float
    constexpr std::ptrdiff_t m_vPoint0 = 0x80; // Vector
    constexpr std::ptrdiff_t m_vPoint1 = 0x8C; // Vector
    constexpr std::ptrdiff_t m_nCollisionMask = 0x98; // uint16_t
}

namespace CFeMorphLayer {
    constexpr std::ptrdiff_t m_Name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nNameHash = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_Nodes = 0x10; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_InitPos = 0x28; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_Gravity = 0x40; // CUtlVector<float>
    constexpr std::ptrdiff_t m_GoalStrength = 0x58; // CUtlVector<float>
    constexpr std::ptrdiff_t m_GoalDamping = 0x70; // CUtlVector<float>
}

namespace CFeNamedJiggleBone {
    constexpr std::ptrdiff_t m_strParentBone = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_transform = 0x10; // CTransform
    constexpr std::ptrdiff_t m_nJiggleParent = 0x30; // uint32_t
    constexpr std::ptrdiff_t m_jiggleBone = 0x34; // CFeJiggleBone
}

namespace CFeVertexMapBuildArray {
    constexpr std::ptrdiff_t m_Array = 0x0; // CUtlVector<FeVertexMapBuild_t*>
}

namespace CRegionSVM {
    constexpr std::ptrdiff_t m_Planes = 0x0; // CUtlVector<RnPlane_t>
    constexpr std::ptrdiff_t m_Nodes = 0x18; // CUtlVector<uint32_t>
}

namespace CastSphereSATParams_t {
    constexpr std::ptrdiff_t m_vRayStart = 0x0; // Vector
    constexpr std::ptrdiff_t m_vRayDelta = 0xC; // Vector
    constexpr std::ptrdiff_t m_flRadius = 0x18; // float
    constexpr std::ptrdiff_t m_flMaxFraction = 0x1C; // float
    constexpr std::ptrdiff_t m_flScale = 0x20; // float
    constexpr std::ptrdiff_t m_pHull = 0x28; // RnHull_t*
}

namespace CovMatrix3 {
    constexpr std::ptrdiff_t m_vDiag = 0x0; // Vector
    constexpr std::ptrdiff_t m_flXY = 0xC; // float
    constexpr std::ptrdiff_t m_flXZ = 0x10; // float
    constexpr std::ptrdiff_t m_flYZ = 0x14; // float
}

namespace Dop26_t {
    constexpr std::ptrdiff_t m_flSupport = 0x0; // float[26]
}

namespace FeAnimStrayRadius_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[2]
    constexpr std::ptrdiff_t flMaxDist = 0x4; // float
    constexpr std::ptrdiff_t flRelaxationFactor = 0x8; // float
}

namespace FeAxialEdgeBend_t {
    constexpr std::ptrdiff_t te = 0x0; // float
    constexpr std::ptrdiff_t tv = 0x4; // float
    constexpr std::ptrdiff_t flDist = 0x8; // float
    constexpr std::ptrdiff_t flWeight = 0xC; // float[4]
    constexpr std::ptrdiff_t nNode = 0x1C; // uint16_t[6]
}

namespace FeBandBendLimit_t {
    constexpr std::ptrdiff_t flDistMin = 0x0; // float
    constexpr std::ptrdiff_t flDistMax = 0x4; // float
    constexpr std::ptrdiff_t nNode = 0x8; // uint16_t[6]
}

namespace FeBoxRigid_t {
    constexpr std::ptrdiff_t tmFrame2 = 0x0; // CTransform
    constexpr std::ptrdiff_t nNode = 0x20; // uint16_t
    constexpr std::ptrdiff_t nCollisionMask = 0x22; // uint16_t
    constexpr std::ptrdiff_t vSize = 0x24; // Vector
    constexpr std::ptrdiff_t nVertexMapIndex = 0x30; // uint16_t
    constexpr std::ptrdiff_t nFlags = 0x32; // uint16_t
}

namespace FeBuildBoxRigid_t {
    constexpr std::ptrdiff_t m_nPriority = 0x40; // int32_t
    constexpr std::ptrdiff_t m_nVertexMapHash = 0x44; // uint32_t
}

namespace FeBuildSphereRigid_t {
    constexpr std::ptrdiff_t m_nPriority = 0x20; // int32_t
    constexpr std::ptrdiff_t m_nVertexMapHash = 0x24; // uint32_t
}

namespace FeBuildTaperedCapsuleRigid_t {
    constexpr std::ptrdiff_t m_nPriority = 0x30; // int32_t
    constexpr std::ptrdiff_t m_nVertexMapHash = 0x34; // uint32_t
}

namespace FeCollisionPlane_t {
    constexpr std::ptrdiff_t nCtrlParent = 0x0; // uint16_t
    constexpr std::ptrdiff_t nChildNode = 0x2; // uint16_t
    constexpr std::ptrdiff_t m_Plane = 0x4; // RnPlane_t
    constexpr std::ptrdiff_t flStrength = 0x14; // float
}

namespace FeCtrlOffset_t {
    constexpr std::ptrdiff_t vOffset = 0x0; // Vector
    constexpr std::ptrdiff_t nCtrlParent = 0xC; // uint16_t
    constexpr std::ptrdiff_t nCtrlChild = 0xE; // uint16_t
}

namespace FeCtrlOsOffset_t {
    constexpr std::ptrdiff_t nCtrlParent = 0x0; // uint16_t
    constexpr std::ptrdiff_t nCtrlChild = 0x2; // uint16_t
}

namespace FeCtrlSoftOffset_t {
    constexpr std::ptrdiff_t nCtrlParent = 0x0; // uint16_t
    constexpr std::ptrdiff_t nCtrlChild = 0x2; // uint16_t
    constexpr std::ptrdiff_t vOffset = 0x4; // Vector
    constexpr std::ptrdiff_t flAlpha = 0x10; // float
}

namespace FeEdgeDesc_t {
    constexpr std::ptrdiff_t nEdge = 0x0; // uint16_t[2]
    constexpr std::ptrdiff_t nSide = 0x4; // uint16_t[2][2]
    constexpr std::ptrdiff_t nVirtElem = 0xC; // uint16_t[2]
}

namespace FeEffectDesc_t {
    constexpr std::ptrdiff_t sName = 0x0; // CUtlString
    constexpr std::ptrdiff_t nNameHash = 0x8; // uint32_t
    constexpr std::ptrdiff_t nType = 0xC; // int32_t
    constexpr std::ptrdiff_t m_Params = 0x10; // KeyValues3
}

namespace FeFitInfluence_t {
    constexpr std::ptrdiff_t nVertexNode = 0x0; // uint32_t
    constexpr std::ptrdiff_t flWeight = 0x4; // float
    constexpr std::ptrdiff_t nMatrixNode = 0x8; // uint32_t
}

namespace FeFitMatrix_t {
    constexpr std::ptrdiff_t bone = 0x0; // CTransform
    constexpr std::ptrdiff_t vCenter = 0x20; // Vector
    constexpr std::ptrdiff_t nEnd = 0x2C; // uint16_t
    constexpr std::ptrdiff_t nNode = 0x2E; // uint16_t
    constexpr std::ptrdiff_t nBeginDynamic = 0x30; // uint16_t
}

namespace FeFitWeight_t {
    constexpr std::ptrdiff_t flWeight = 0x0; // float
    constexpr std::ptrdiff_t nNode = 0x4; // uint16_t
    constexpr std::ptrdiff_t nDummy = 0x6; // uint16_t
}

namespace FeFollowNode_t {
    constexpr std::ptrdiff_t nParentNode = 0x0; // uint16_t
    constexpr std::ptrdiff_t nChildNode = 0x2; // uint16_t
    constexpr std::ptrdiff_t flWeight = 0x4; // float
}

namespace FeKelagerBend2_t {
    constexpr std::ptrdiff_t flWeight = 0x0; // float[3]
    constexpr std::ptrdiff_t flHeight0 = 0xC; // float
    constexpr std::ptrdiff_t nNode = 0x10; // uint16_t[3]
    constexpr std::ptrdiff_t nReserved = 0x16; // uint16_t
}

namespace FeMorphLayerDepr_t {
    constexpr std::ptrdiff_t m_Name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nNameHash = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_Nodes = 0x10; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_InitPos = 0x28; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_Gravity = 0x40; // CUtlVector<float>
    constexpr std::ptrdiff_t m_GoalStrength = 0x58; // CUtlVector<float>
    constexpr std::ptrdiff_t m_GoalDamping = 0x70; // CUtlVector<float>
    constexpr std::ptrdiff_t m_nFlags = 0x88; // uint32_t
}

namespace FeNodeBase_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t
    constexpr std::ptrdiff_t nDummy = 0x2; // uint16_t[3]
    constexpr std::ptrdiff_t nNodeX0 = 0x8; // uint16_t
    constexpr std::ptrdiff_t nNodeX1 = 0xA; // uint16_t
    constexpr std::ptrdiff_t nNodeY0 = 0xC; // uint16_t
    constexpr std::ptrdiff_t nNodeY1 = 0xE; // uint16_t
    constexpr std::ptrdiff_t qAdjust = 0x10; // QuaternionStorage
}

namespace FeNodeIntegrator_t {
    constexpr std::ptrdiff_t flPointDamping = 0x0; // float
    constexpr std::ptrdiff_t flAnimationForceAttraction = 0x4; // float
    constexpr std::ptrdiff_t flAnimationVertexAttraction = 0x8; // float
    constexpr std::ptrdiff_t flGravity = 0xC; // float
}

namespace FeNodeReverseOffset_t {
    constexpr std::ptrdiff_t vOffset = 0x0; // Vector
    constexpr std::ptrdiff_t nBoneCtrl = 0xC; // uint16_t
    constexpr std::ptrdiff_t nTargetNode = 0xE; // uint16_t
}

namespace FeNodeWindBase_t {
    constexpr std::ptrdiff_t nNodeX0 = 0x0; // uint16_t
    constexpr std::ptrdiff_t nNodeX1 = 0x2; // uint16_t
    constexpr std::ptrdiff_t nNodeY0 = 0x4; // uint16_t
    constexpr std::ptrdiff_t nNodeY1 = 0x6; // uint16_t
}

namespace FeProxyVertexMap_t {
    constexpr std::ptrdiff_t m_Name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_flWeight = 0x8; // float
}

namespace FeQuad_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[4]
    constexpr std::ptrdiff_t flSlack = 0x8; // float
    constexpr std::ptrdiff_t vShape = 0xC; // Vector4D[4]
}

namespace FeRigidColliderIndices_t {
    constexpr std::ptrdiff_t m_nTaperedCapsuleRigidIndex = 0x0; // uint16_t
    constexpr std::ptrdiff_t m_nSphereRigidIndex = 0x2; // uint16_t
    constexpr std::ptrdiff_t m_nBoxRigidIndex = 0x4; // uint16_t
    constexpr std::ptrdiff_t m_nCollisionPlaneIndex = 0x6; // uint16_t
}

namespace FeRodConstraint_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[2]
    constexpr std::ptrdiff_t flMaxDist = 0x4; // float
    constexpr std::ptrdiff_t flMinDist = 0x8; // float
    constexpr std::ptrdiff_t flWeight0 = 0xC; // float
    constexpr std::ptrdiff_t flRelaxationFactor = 0x10; // float
}

namespace FeSimdAnimStrayRadius_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[4][2]
    constexpr std::ptrdiff_t flMaxDist = 0x10; // fltx4
    constexpr std::ptrdiff_t flRelaxationFactor = 0x20; // fltx4
}

namespace FeSimdNodeBase_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[4]
    constexpr std::ptrdiff_t nNodeX0 = 0x8; // uint16_t[4]
    constexpr std::ptrdiff_t nNodeX1 = 0x10; // uint16_t[4]
    constexpr std::ptrdiff_t nNodeY0 = 0x18; // uint16_t[4]
    constexpr std::ptrdiff_t nNodeY1 = 0x20; // uint16_t[4]
    constexpr std::ptrdiff_t nDummy = 0x28; // uint16_t[4]
    constexpr std::ptrdiff_t qAdjust = 0x30; // FourQuaternions
}

namespace FeSimdQuad_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[4][4]
    constexpr std::ptrdiff_t f4Slack = 0x20; // fltx4
    constexpr std::ptrdiff_t vShape = 0x30; // FourVectors[4]
    constexpr std::ptrdiff_t f4Weights = 0xF0; // fltx4[4]
}

namespace FeSimdRodConstraint_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[4][2]
    constexpr std::ptrdiff_t f4MaxDist = 0x10; // fltx4
    constexpr std::ptrdiff_t f4MinDist = 0x20; // fltx4
    constexpr std::ptrdiff_t f4Weight0 = 0x30; // fltx4
    constexpr std::ptrdiff_t f4RelaxationFactor = 0x40; // fltx4
}

namespace FeSimdSpringIntegrator_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[4][2]
    constexpr std::ptrdiff_t flSpringRestLength = 0x10; // fltx4
    constexpr std::ptrdiff_t flSpringConstant = 0x20; // fltx4
    constexpr std::ptrdiff_t flSpringDamping = 0x30; // fltx4
    constexpr std::ptrdiff_t flNodeWeight0 = 0x40; // fltx4
}

namespace FeSimdTri_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint32_t[4][3]
    constexpr std::ptrdiff_t w1 = 0x30; // fltx4
    constexpr std::ptrdiff_t w2 = 0x40; // fltx4
    constexpr std::ptrdiff_t v1x = 0x50; // fltx4
    constexpr std::ptrdiff_t v2 = 0x60; // FourVectors2D
}

namespace FeSoftParent_t {
    constexpr std::ptrdiff_t nParent = 0x0; // int32_t
    constexpr std::ptrdiff_t flAlpha = 0x4; // float
}

namespace FeSourceEdge_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[2]
}

namespace FeSphereRigid_t {
    constexpr std::ptrdiff_t vSphere = 0x0; // fltx4
    constexpr std::ptrdiff_t nNode = 0x10; // uint16_t
    constexpr std::ptrdiff_t nCollisionMask = 0x12; // uint16_t
    constexpr std::ptrdiff_t nVertexMapIndex = 0x14; // uint16_t
    constexpr std::ptrdiff_t nFlags = 0x16; // uint16_t
}

namespace FeSpringIntegrator_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[2]
    constexpr std::ptrdiff_t flSpringRestLength = 0x4; // float
    constexpr std::ptrdiff_t flSpringConstant = 0x8; // float
    constexpr std::ptrdiff_t flSpringDamping = 0xC; // float
    constexpr std::ptrdiff_t flNodeWeight0 = 0x10; // float
}

namespace FeStiffHingeBuild_t {
    constexpr std::ptrdiff_t flMaxAngle = 0x0; // float
    constexpr std::ptrdiff_t flStrength = 0x4; // float
    constexpr std::ptrdiff_t flMotionBias = 0x8; // float[3]
    constexpr std::ptrdiff_t nNode = 0x14; // uint16_t[3]
}

namespace FeTaperedCapsuleRigid_t {
    constexpr std::ptrdiff_t vSphere = 0x0; // fltx4[2]
    constexpr std::ptrdiff_t nNode = 0x20; // uint16_t
    constexpr std::ptrdiff_t nCollisionMask = 0x22; // uint16_t
    constexpr std::ptrdiff_t nVertexMapIndex = 0x24; // uint16_t
    constexpr std::ptrdiff_t nFlags = 0x26; // uint16_t
}

namespace FeTaperedCapsuleStretch_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[2]
    constexpr std::ptrdiff_t nCollisionMask = 0x4; // uint16_t
    constexpr std::ptrdiff_t nDummy = 0x6; // uint16_t
    constexpr std::ptrdiff_t flRadius = 0x8; // float[2]
}

namespace FeTreeChildren_t {
    constexpr std::ptrdiff_t nChild = 0x0; // uint16_t[2]
}

namespace FeTri_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[3]
    constexpr std::ptrdiff_t w1 = 0x8; // float
    constexpr std::ptrdiff_t w2 = 0xC; // float
    constexpr std::ptrdiff_t v1x = 0x10; // float
    constexpr std::ptrdiff_t v2 = 0x14; // Vector2D
}

namespace FeTwistConstraint_t {
    constexpr std::ptrdiff_t nNodeOrient = 0x0; // uint16_t
    constexpr std::ptrdiff_t nNodeEnd = 0x2; // uint16_t
    constexpr std::ptrdiff_t flTwistRelax = 0x4; // float
    constexpr std::ptrdiff_t flSwingRelax = 0x8; // float
}

namespace FeVertexMapBuild_t {
    constexpr std::ptrdiff_t m_VertexMapName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nNameHash = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_Color = 0xC; // Color
    constexpr std::ptrdiff_t m_flVolumetricSolveStrength = 0x10; // float
    constexpr std::ptrdiff_t m_nScaleSourceNode = 0x14; // int32_t
    constexpr std::ptrdiff_t m_Weights = 0x18; // CUtlVector<float>
}

namespace FeVertexMapDesc_t {
    constexpr std::ptrdiff_t sName = 0x0; // CUtlString
    constexpr std::ptrdiff_t nNameHash = 0x8; // uint32_t
    constexpr std::ptrdiff_t nColor = 0xC; // uint32_t
    constexpr std::ptrdiff_t nFlags = 0x10; // uint32_t
    constexpr std::ptrdiff_t nVertexBase = 0x14; // uint16_t
    constexpr std::ptrdiff_t nVertexCount = 0x16; // uint16_t
    constexpr std::ptrdiff_t nMapOffset = 0x18; // uint32_t
    constexpr std::ptrdiff_t nNodeListOffset = 0x1C; // uint32_t
    constexpr std::ptrdiff_t vCenterOfMass = 0x20; // Vector
    constexpr std::ptrdiff_t flVolumetricSolveStrength = 0x2C; // float
    constexpr std::ptrdiff_t nScaleSourceNode = 0x30; // int16_t
    constexpr std::ptrdiff_t nNodeListCount = 0x32; // uint16_t
}

namespace FeWeightedNode_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t
    constexpr std::ptrdiff_t nWeight = 0x2; // uint16_t
}

namespace FeWorldCollisionParams_t {
    constexpr std::ptrdiff_t flWorldFriction = 0x0; // float
    constexpr std::ptrdiff_t flGroundFriction = 0x4; // float
    constexpr std::ptrdiff_t nListBegin = 0x8; // uint16_t
    constexpr std::ptrdiff_t nListEnd = 0xA; // uint16_t
}

namespace FourCovMatrices3 {
    constexpr std::ptrdiff_t m_vDiag = 0x0; // FourVectors
    constexpr std::ptrdiff_t m_flXY = 0x30; // fltx4
    constexpr std::ptrdiff_t m_flXZ = 0x40; // fltx4
    constexpr std::ptrdiff_t m_flYZ = 0x50; // fltx4
}

namespace FourVectors2D {
    constexpr std::ptrdiff_t x = 0x0; // fltx4
    constexpr std::ptrdiff_t y = 0x10; // fltx4
}

namespace OldFeEdge_t {
    constexpr std::ptrdiff_t m_flK = 0x0; // float[3]
    constexpr std::ptrdiff_t invA = 0xC; // float
    constexpr std::ptrdiff_t t = 0x10; // float
    constexpr std::ptrdiff_t flThetaRelaxed = 0x14; // float
    constexpr std::ptrdiff_t flThetaFactor = 0x18; // float
    constexpr std::ptrdiff_t c01 = 0x1C; // float
    constexpr std::ptrdiff_t c02 = 0x20; // float
    constexpr std::ptrdiff_t c03 = 0x24; // float
    constexpr std::ptrdiff_t c04 = 0x28; // float
    constexpr std::ptrdiff_t flAxialModelDist = 0x2C; // float
    constexpr std::ptrdiff_t flAxialModelWeights = 0x30; // float[4]
    constexpr std::ptrdiff_t m_nNode = 0x40; // uint16_t[4]
}

namespace PhysFeModelDesc_t {
    constexpr std::ptrdiff_t m_CtrlHash = 0x0; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_CtrlName = 0x18; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_nStaticNodeFlags = 0x30; // uint32_t
    constexpr std::ptrdiff_t m_nDynamicNodeFlags = 0x34; // uint32_t
    constexpr std::ptrdiff_t m_flLocalForce = 0x38; // float
    constexpr std::ptrdiff_t m_flLocalRotation = 0x3C; // float
    constexpr std::ptrdiff_t m_nNodeCount = 0x40; // uint16_t
    constexpr std::ptrdiff_t m_nStaticNodes = 0x42; // uint16_t
    constexpr std::ptrdiff_t m_nRotLockStaticNodes = 0x44; // uint16_t
    constexpr std::ptrdiff_t m_nFirstPositionDrivenNode = 0x46; // uint16_t
    constexpr std::ptrdiff_t m_nSimdTriCount1 = 0x48; // uint16_t
    constexpr std::ptrdiff_t m_nSimdTriCount2 = 0x4A; // uint16_t
    constexpr std::ptrdiff_t m_nSimdQuadCount1 = 0x4C; // uint16_t
    constexpr std::ptrdiff_t m_nSimdQuadCount2 = 0x4E; // uint16_t
    constexpr std::ptrdiff_t m_nQuadCount1 = 0x50; // uint16_t
    constexpr std::ptrdiff_t m_nQuadCount2 = 0x52; // uint16_t
    constexpr std::ptrdiff_t m_nTreeDepth = 0x54; // uint16_t
    constexpr std::ptrdiff_t m_nNodeBaseJiggleboneDependsCount = 0x56; // uint16_t
    constexpr std::ptrdiff_t m_nRopeCount = 0x58; // uint16_t
    constexpr std::ptrdiff_t m_Ropes = 0x60; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_NodeBases = 0x78; // CUtlVector<FeNodeBase_t>
    constexpr std::ptrdiff_t m_SimdNodeBases = 0x90; // CUtlVector<FeSimdNodeBase_t>
    constexpr std::ptrdiff_t m_Quads = 0xA8; // CUtlVector<FeQuad_t>
    constexpr std::ptrdiff_t m_SimdQuads = 0xC0; // CUtlVector<FeSimdQuad_t>
    constexpr std::ptrdiff_t m_SimdTris = 0xD8; // CUtlVector<FeSimdTri_t>
    constexpr std::ptrdiff_t m_SimdRods = 0xF0; // CUtlVector<FeSimdRodConstraint_t>
    constexpr std::ptrdiff_t m_InitPose = 0x108; // CUtlVector<CTransform>
    constexpr std::ptrdiff_t m_Rods = 0x120; // CUtlVector<FeRodConstraint_t>
    constexpr std::ptrdiff_t m_Twists = 0x138; // CUtlVector<FeTwistConstraint_t>
    constexpr std::ptrdiff_t m_AxialEdges = 0x150; // CUtlVector<FeAxialEdgeBend_t>
    constexpr std::ptrdiff_t m_NodeInvMasses = 0x168; // CUtlVector<float>
    constexpr std::ptrdiff_t m_CtrlOffsets = 0x180; // CUtlVector<FeCtrlOffset_t>
    constexpr std::ptrdiff_t m_CtrlOsOffsets = 0x198; // CUtlVector<FeCtrlOsOffset_t>
    constexpr std::ptrdiff_t m_FollowNodes = 0x1B0; // CUtlVector<FeFollowNode_t>
    constexpr std::ptrdiff_t m_CollisionPlanes = 0x1C8; // CUtlVector<FeCollisionPlane_t>
    constexpr std::ptrdiff_t m_NodeIntegrator = 0x1E0; // CUtlVector<FeNodeIntegrator_t>
    constexpr std::ptrdiff_t m_SpringIntegrator = 0x1F8; // CUtlVector<FeSpringIntegrator_t>
    constexpr std::ptrdiff_t m_SimdSpringIntegrator = 0x210; // CUtlVector<FeSimdSpringIntegrator_t>
    constexpr std::ptrdiff_t m_WorldCollisionParams = 0x228; // CUtlVector<FeWorldCollisionParams_t>
    constexpr std::ptrdiff_t m_LegacyStretchForce = 0x240; // CUtlVector<float>
    constexpr std::ptrdiff_t m_NodeCollisionRadii = 0x258; // CUtlVector<float>
    constexpr std::ptrdiff_t m_DynNodeFriction = 0x270; // CUtlVector<float>
    constexpr std::ptrdiff_t m_LocalRotation = 0x288; // CUtlVector<float>
    constexpr std::ptrdiff_t m_LocalForce = 0x2A0; // CUtlVector<float>
    constexpr std::ptrdiff_t m_TaperedCapsuleStretches = 0x2B8; // CUtlVector<FeTaperedCapsuleStretch_t>
    constexpr std::ptrdiff_t m_TaperedCapsuleRigids = 0x2D0; // CUtlVector<FeTaperedCapsuleRigid_t>
    constexpr std::ptrdiff_t m_SphereRigids = 0x2E8; // CUtlVector<FeSphereRigid_t>
    constexpr std::ptrdiff_t m_WorldCollisionNodes = 0x300; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_TreeParents = 0x318; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_TreeCollisionMasks = 0x330; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_TreeChildren = 0x348; // CUtlVector<FeTreeChildren_t>
    constexpr std::ptrdiff_t m_FreeNodes = 0x360; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_FitMatrices = 0x378; // CUtlVector<FeFitMatrix_t>
    constexpr std::ptrdiff_t m_FitWeights = 0x390; // CUtlVector<FeFitWeight_t>
    constexpr std::ptrdiff_t m_ReverseOffsets = 0x3A8; // CUtlVector<FeNodeReverseOffset_t>
    constexpr std::ptrdiff_t m_AnimStrayRadii = 0x3C0; // CUtlVector<FeAnimStrayRadius_t>
    constexpr std::ptrdiff_t m_SimdAnimStrayRadii = 0x3D8; // CUtlVector<FeSimdAnimStrayRadius_t>
    constexpr std::ptrdiff_t m_KelagerBends = 0x3F0; // CUtlVector<FeKelagerBend2_t>
    constexpr std::ptrdiff_t m_CtrlSoftOffsets = 0x408; // CUtlVector<FeCtrlSoftOffset_t>
    constexpr std::ptrdiff_t m_JiggleBones = 0x420; // CUtlVector<CFeIndexedJiggleBone>
    constexpr std::ptrdiff_t m_SourceElems = 0x438; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_GoalDampedSpringIntegrators = 0x450; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_Tris = 0x468; // CUtlVector<FeTri_t>
    constexpr std::ptrdiff_t m_nTriCount1 = 0x480; // uint16_t
    constexpr std::ptrdiff_t m_nTriCount2 = 0x482; // uint16_t
    constexpr std::ptrdiff_t m_nReservedUint8 = 0x484; // uint8_t
    constexpr std::ptrdiff_t m_nExtraPressureIterations = 0x485; // uint8_t
    constexpr std::ptrdiff_t m_nExtraGoalIterations = 0x486; // uint8_t
    constexpr std::ptrdiff_t m_nExtraIterations = 0x487; // uint8_t
    constexpr std::ptrdiff_t m_BoxRigids = 0x488; // CUtlVector<FeBoxRigid_t>
    constexpr std::ptrdiff_t m_DynNodeVertexSet = 0x4A0; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_VertexSetNames = 0x4B8; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_RigidColliderPriorities = 0x4D0; // CUtlVector<FeRigidColliderIndices_t>
    constexpr std::ptrdiff_t m_MorphLayers = 0x4E8; // CUtlVector<FeMorphLayerDepr_t>
    constexpr std::ptrdiff_t m_MorphSetData = 0x500; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_VertexMaps = 0x518; // CUtlVector<FeVertexMapDesc_t>
    constexpr std::ptrdiff_t m_VertexMapValues = 0x530; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_Effects = 0x548; // CUtlVector<FeEffectDesc_t>
    constexpr std::ptrdiff_t m_LockToParent = 0x560; // CUtlVector<FeCtrlOffset_t>
    constexpr std::ptrdiff_t m_LockToGoal = 0x578; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_DynNodeWindBases = 0x590; // CUtlVector<FeNodeWindBase_t>
    constexpr std::ptrdiff_t m_flInternalPressure = 0x5A8; // float
    constexpr std::ptrdiff_t m_flDefaultTimeDilation = 0x5AC; // float
    constexpr std::ptrdiff_t m_flWindage = 0x5B0; // float
    constexpr std::ptrdiff_t m_flWindDrag = 0x5B4; // float
    constexpr std::ptrdiff_t m_flDefaultSurfaceStretch = 0x5B8; // float
    constexpr std::ptrdiff_t m_flDefaultThreadStretch = 0x5BC; // float
    constexpr std::ptrdiff_t m_flDefaultGravityScale = 0x5C0; // float
    constexpr std::ptrdiff_t m_flDefaultVelAirDrag = 0x5C4; // float
    constexpr std::ptrdiff_t m_flDefaultExpAirDrag = 0x5C8; // float
    constexpr std::ptrdiff_t m_flDefaultVelQuadAirDrag = 0x5CC; // float
    constexpr std::ptrdiff_t m_flDefaultExpQuadAirDrag = 0x5D0; // float
    constexpr std::ptrdiff_t m_flRodVelocitySmoothRate = 0x5D4; // float
    constexpr std::ptrdiff_t m_flQuadVelocitySmoothRate = 0x5D8; // float
    constexpr std::ptrdiff_t m_flAddWorldCollisionRadius = 0x5DC; // float
    constexpr std::ptrdiff_t m_flDefaultVolumetricSolveAmount = 0x5E0; // float
    constexpr std::ptrdiff_t m_nRodVelocitySmoothIterations = 0x5E4; // uint16_t
    constexpr std::ptrdiff_t m_nQuadVelocitySmoothIterations = 0x5E6; // uint16_t
}

namespace RnBlendVertex_t {
    constexpr std::ptrdiff_t m_nWeight0 = 0x0; // uint16_t
    constexpr std::ptrdiff_t m_nIndex0 = 0x2; // uint16_t
    constexpr std::ptrdiff_t m_nWeight1 = 0x4; // uint16_t
    constexpr std::ptrdiff_t m_nIndex1 = 0x6; // uint16_t
    constexpr std::ptrdiff_t m_nWeight2 = 0x8; // uint16_t
    constexpr std::ptrdiff_t m_nIndex2 = 0xA; // uint16_t
    constexpr std::ptrdiff_t m_nFlags = 0xC; // uint16_t
    constexpr std::ptrdiff_t m_nTargetIndex = 0xE; // uint16_t
}

namespace RnBodyDesc_t {
    constexpr std::ptrdiff_t m_sDebugName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_vPosition = 0x8; // Vector
    constexpr std::ptrdiff_t m_qOrientation = 0x14; // QuaternionStorage
    constexpr std::ptrdiff_t m_vLinearVelocity = 0x24; // Vector
    constexpr std::ptrdiff_t m_vAngularVelocity = 0x30; // Vector
    constexpr std::ptrdiff_t m_vLocalMassCenter = 0x3C; // Vector
    constexpr std::ptrdiff_t m_LocalInertiaInv = 0x48; // Vector[3]
    constexpr std::ptrdiff_t m_flMassInv = 0x6C; // float
    constexpr std::ptrdiff_t m_flGameMass = 0x70; // float
    constexpr std::ptrdiff_t m_flInertiaScaleInv = 0x74; // float
    constexpr std::ptrdiff_t m_flLinearDamping = 0x78; // float
    constexpr std::ptrdiff_t m_flAngularDamping = 0x7C; // float
    constexpr std::ptrdiff_t m_flLinearDrag = 0x80; // float
    constexpr std::ptrdiff_t m_flAngularDrag = 0x84; // float
    constexpr std::ptrdiff_t m_flLinearBuoyancyDrag = 0x88; // float
    constexpr std::ptrdiff_t m_flAngularBuoyancyDrag = 0x8C; // float
    constexpr std::ptrdiff_t m_vLastAwakeForceAccum = 0x90; // Vector
    constexpr std::ptrdiff_t m_vLastAwakeTorqueAccum = 0x9C; // Vector
    constexpr std::ptrdiff_t m_flBuoyancyFactor = 0xA8; // float
    constexpr std::ptrdiff_t m_flGravityScale = 0xAC; // float
    constexpr std::ptrdiff_t m_flTimeScale = 0xB0; // float
    constexpr std::ptrdiff_t m_nBodyType = 0xB4; // int32_t
    constexpr std::ptrdiff_t m_nGameIndex = 0xB8; // uint32_t
    constexpr std::ptrdiff_t m_nGameFlags = 0xBC; // uint32_t
    constexpr std::ptrdiff_t m_nMinVelocityIterations = 0xC0; // int8_t
    constexpr std::ptrdiff_t m_nMinPositionIterations = 0xC1; // int8_t
    constexpr std::ptrdiff_t m_nMassPriority = 0xC2; // int8_t
    constexpr std::ptrdiff_t m_bEnabled = 0xC3; // bool
    constexpr std::ptrdiff_t m_bSleeping = 0xC4; // bool
    constexpr std::ptrdiff_t m_bIsContinuousEnabled = 0xC5; // bool
    constexpr std::ptrdiff_t m_bDragEnabled = 0xC6; // bool
    constexpr std::ptrdiff_t m_bBuoyancyDragEnabled = 0xC7; // bool
    constexpr std::ptrdiff_t m_bGravityDisabled = 0xC8; // bool
    constexpr std::ptrdiff_t m_bSpeculativeEnabled = 0xC9; // bool
    constexpr std::ptrdiff_t m_bHasShadowController = 0xCA; // bool
}

namespace RnCapsuleDesc_t {
    constexpr std::ptrdiff_t m_Capsule = 0x10; // RnCapsule_t
}

namespace RnCapsule_t {
    constexpr std::ptrdiff_t m_vCenter = 0x0; // Vector[2]
    constexpr std::ptrdiff_t m_flRadius = 0x18; // float
}

namespace RnFace_t {
    constexpr std::ptrdiff_t m_nEdge = 0x0; // uint8_t
}

namespace RnHalfEdge_t {
    constexpr std::ptrdiff_t m_nNext = 0x0; // uint8_t
    constexpr std::ptrdiff_t m_nTwin = 0x1; // uint8_t
    constexpr std::ptrdiff_t m_nOrigin = 0x2; // uint8_t
    constexpr std::ptrdiff_t m_nFace = 0x3; // uint8_t
}

namespace RnHullDesc_t {
    constexpr std::ptrdiff_t m_Hull = 0x10; // RnHull_t
}

namespace RnHull_t {
    constexpr std::ptrdiff_t m_vCentroid = 0x0; // Vector
    constexpr std::ptrdiff_t m_flMaxAngularRadius = 0xC; // float
    constexpr std::ptrdiff_t m_Bounds = 0x10; // AABB_t
    constexpr std::ptrdiff_t m_vOrthographicAreas = 0x28; // Vector
    constexpr std::ptrdiff_t m_MassProperties = 0x34; // matrix3x4_t
    constexpr std::ptrdiff_t m_flVolume = 0x64; // float
    constexpr std::ptrdiff_t m_Vertices = 0x68; // CUtlVector<RnVertex_t>
    constexpr std::ptrdiff_t m_VertexPositions = 0x80; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_Edges = 0x98; // CUtlVector<RnHalfEdge_t>
    constexpr std::ptrdiff_t m_Faces = 0xB0; // CUtlVector<RnFace_t>
    constexpr std::ptrdiff_t m_FacePlanes = 0xC8; // CUtlVector<RnPlane_t>
    constexpr std::ptrdiff_t m_nFlags = 0xE0; // uint32_t
    constexpr std::ptrdiff_t m_pRegionSVM = 0xE8; // CRegionSVM*
}

namespace RnMeshDesc_t {
    constexpr std::ptrdiff_t m_Mesh = 0x10; // RnMesh_t
}

namespace RnMesh_t {
    constexpr std::ptrdiff_t m_vMin = 0x0; // Vector
    constexpr std::ptrdiff_t m_vMax = 0xC; // Vector
    constexpr std::ptrdiff_t m_Nodes = 0x18; // CUtlVector<RnNode_t>
    constexpr std::ptrdiff_t m_Vertices = 0x30; // CUtlVectorSIMDPaddedVector
    constexpr std::ptrdiff_t m_Triangles = 0x48; // CUtlVector<RnTriangle_t>
    constexpr std::ptrdiff_t m_Wings = 0x60; // CUtlVector<RnWing_t>
    constexpr std::ptrdiff_t m_Materials = 0x78; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_vOrthographicAreas = 0x90; // Vector
    constexpr std::ptrdiff_t m_nFlags = 0x9C; // uint32_t
    constexpr std::ptrdiff_t m_nDebugFlags = 0xA0; // uint32_t
}

namespace RnNode_t {
    constexpr std::ptrdiff_t m_vMin = 0x0; // Vector
    constexpr std::ptrdiff_t m_nChildren = 0xC; // uint32_t
    constexpr std::ptrdiff_t m_vMax = 0x10; // Vector
    constexpr std::ptrdiff_t m_nTriangleOffset = 0x1C; // uint32_t
}

namespace RnPlane_t {
    constexpr std::ptrdiff_t m_vNormal = 0x0; // Vector
    constexpr std::ptrdiff_t m_flOffset = 0xC; // float
}

namespace RnShapeDesc_t {
    constexpr std::ptrdiff_t m_nCollisionAttributeIndex = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_nSurfacePropertyIndex = 0x4; // uint32_t
    constexpr std::ptrdiff_t m_UserFriendlyName = 0x8; // CUtlString
}

namespace RnSoftbodyCapsule_t {
    constexpr std::ptrdiff_t m_vCenter = 0x0; // Vector[2]
    constexpr std::ptrdiff_t m_flRadius = 0x18; // float
    constexpr std::ptrdiff_t m_nParticle = 0x1C; // uint16_t[2]
}

namespace RnSoftbodyParticle_t {
    constexpr std::ptrdiff_t m_flMassInv = 0x0; // float
}

namespace RnSoftbodySpring_t {
    constexpr std::ptrdiff_t m_nParticle = 0x0; // uint16_t[2]
    constexpr std::ptrdiff_t m_flLength = 0x4; // float
}

namespace RnSphereDesc_t {
    constexpr std::ptrdiff_t m_Sphere = 0x10; // RnSphere_t
}

namespace RnSphere_t {
    constexpr std::ptrdiff_t m_vCenter = 0x0; // Vector
    constexpr std::ptrdiff_t m_flRadius = 0xC; // float
}

namespace RnTriangle_t {
    constexpr std::ptrdiff_t m_nIndex = 0x0; // int32_t[3]
}

namespace RnVertex_t {
    constexpr std::ptrdiff_t m_nEdge = 0x0; // uint8_t
}

namespace RnWing_t {
    constexpr std::ptrdiff_t m_nIndex = 0x0; // int32_t[3]
}

namespace VertexPositionColor_t {
    constexpr std::ptrdiff_t m_vPosition = 0x0; // Vector
}

namespace VertexPositionNormal_t {
    constexpr std::ptrdiff_t m_vPosition = 0x0; // Vector
    constexpr std::ptrdiff_t m_vNormal = 0xC; // Vector
}

namespace constraint_axislimit_t {
    constexpr std::ptrdiff_t flMinRotation = 0x0; // float
    constexpr std::ptrdiff_t flMaxRotation = 0x4; // float
    constexpr std::ptrdiff_t flMotorTargetAngSpeed = 0x8; // float
    constexpr std::ptrdiff_t flMotorMaxTorque = 0xC; // float
}

namespace constraint_breakableparams_t {
    constexpr std::ptrdiff_t strength = 0x0; // float
    constexpr std::ptrdiff_t forceLimit = 0x4; // float
    constexpr std::ptrdiff_t torqueLimit = 0x8; // float
    constexpr std::ptrdiff_t bodyMassScale = 0xC; // float[2]
    constexpr std::ptrdiff_t isActive = 0x14; // bool
}

namespace constraint_hingeparams_t {
    constexpr std::ptrdiff_t worldPosition = 0x0; // Vector
    constexpr std::ptrdiff_t worldAxisDirection = 0xC; // Vector
    constexpr std::ptrdiff_t hingeAxis = 0x18; // constraint_axislimit_t
    constexpr std::ptrdiff_t constraint = 0x28; // constraint_breakableparams_t
}

namespace vphysics_save_cphysicsbody_t {
    constexpr std::ptrdiff_t m_nOldPointer = 0xD0; // uint64_t
}
```

`SDK/vphysics2.dll.json`:

```json
{
  "CFeIndexedJiggleBone": {
    "m_jiggleBone": 8,
    "m_nJiggleParent": 4,
    "m_nNode": 0
  },
  "CFeJiggleBone": {
    "m_flAlongDamping": 32,
    "m_flAlongStiffness": 28,
    "m_flAngleLimit": 36,
    "m_flBaseDamping": 80,
    "m_flBaseForwardFriction": 116,
    "m_flBaseLeftFriction": 92,
    "m_flBaseMass": 72,
    "m_flBaseMaxForward": 112,
    "m_flBaseMaxLeft": 88,
    "m_flBaseMaxUp": 100,
    "m_flBaseMinForward": 108,
    "m_flBaseMinLeft": 84,
    "m_flBaseMinUp": 96,
    "m_flBaseStiffness": 76,
    "m_flBaseUpFriction": 104,
    "m_flLength": 4,
    "m_flMaxPitch": 60,
    "m_flMaxYaw": 44,
    "m_flMinPitch": 56,
    "m_flMinYaw": 40,
    "m_flPitchBounce": 68,
    "m_flPitchDamping": 24,
    "m_flPitchFriction": 64,
    "m_flPitchStiffness": 20,
    "m_flRadius0": 120,
    "m_flRadius1": 124,
    "m_flTipMass": 8,
    "m_flYawBounce": 52,
    "m_flYawDamping": 16,
    "m_flYawFriction": 48,
    "m_flYawStiffness": 12,
    "m_nCollisionMask": 152,
    "m_nFlags": 0,
    "m_vPoint0": 128,
    "m_vPoint1": 140
  },
  "CFeMorphLayer": {
    "m_GoalDamping": 112,
    "m_GoalStrength": 88,
    "m_Gravity": 64,
    "m_InitPos": 40,
    "m_Name": 0,
    "m_Nodes": 16,
    "m_nNameHash": 8
  },
  "CFeNamedJiggleBone": {
    "m_jiggleBone": 52,
    "m_nJiggleParent": 48,
    "m_strParentBone": 0,
    "m_transform": 16
  },
  "CFeVertexMapBuildArray": {
    "m_Array": 0
  },
  "CRegionSVM": {
    "m_Nodes": 24,
    "m_Planes": 0
  },
  "CastSphereSATParams_t": {
    "m_flMaxFraction": 28,
    "m_flRadius": 24,
    "m_flScale": 32,
    "m_pHull": 40,
    "m_vRayDelta": 12,
    "m_vRayStart": 0
  },
  "CovMatrix3": {
    "m_flXY": 12,
    "m_flXZ": 16,
    "m_flYZ": 20,
    "m_vDiag": 0
  },
  "Dop26_t": {
    "m_flSupport": 0
  },
  "FeAnimStrayRadius_t": {
    "flMaxDist": 4,
    "flRelaxationFactor": 8,
    "nNode": 0
  },
  "FeAxialEdgeBend_t": {
    "flDist": 8,
    "flWeight": 12,
    "nNode": 28,
    "te": 0,
    "tv": 4
  },
  "FeBandBendLimit_t": {
    "flDistMax": 4,
    "flDistMin": 0,
    "nNode": 8
  },
  "FeBoxRigid_t": {
    "nCollisionMask": 34,
    "nFlags": 50,
    "nNode": 32,
    "nVertexMapIndex": 48,
    "tmFrame2": 0,
    "vSize": 36
  },
  "FeBuildBoxRigid_t": {
    "m_nPriority": 64,
    "m_nVertexMapHash": 68
  },
  "FeBuildSphereRigid_t": {
    "m_nPriority": 32,
    "m_nVertexMapHash": 36
  },
  "FeBuildTaperedCapsuleRigid_t": {
    "m_nPriority": 48,
    "m_nVertexMapHash": 52
  },
  "FeCollisionPlane_t": {
    "flStrength": 20,
    "m_Plane": 4,
    "nChildNode": 2,
    "nCtrlParent": 0
  },
  "FeCtrlOffset_t": {
    "nCtrlChild": 14,
    "nCtrlParent": 12,
    "vOffset": 0
  },
  "FeCtrlOsOffset_t": {
    "nCtrlChild": 2,
    "nCtrlParent": 0
  },
  "FeCtrlSoftOffset_t": {
    "flAlpha": 16,
    "nCtrlChild": 2,
    "nCtrlParent": 0,
    "vOffset": 4
  },
  "FeEdgeDesc_t": {
    "nEdge": 0,
    "nSide": 4,
    "nVirtElem": 12
  },
  "FeEffectDesc_t": {
    "m_Params": 16,
    "nNameHash": 8,
    "nType": 12,
    "sName": 0
  },
  "FeFitInfluence_t": {
    "flWeight": 4,
    "nMatrixNode": 8,
    "nVertexNode": 0
  },
  "FeFitMatrix_t": {
    "bone": 0,
    "nBeginDynamic": 48,
    "nEnd": 44,
    "nNode": 46,
    "vCenter": 32
  },
  "FeFitWeight_t": {
    "flWeight": 0,
    "nDummy": 6,
    "nNode": 4
  },
  "FeFollowNode_t": {
    "flWeight": 4,
    "nChildNode": 2,
    "nParentNode": 0
  },
  "FeKelagerBend2_t": {
    "flHeight0": 12,
    "flWeight": 0,
    "nNode": 16,
    "nReserved": 22
  },
  "FeMorphLayerDepr_t": {
    "m_GoalDamping": 112,
    "m_GoalStrength": 88,
    "m_Gravity": 64,
    "m_InitPos": 40,
    "m_Name": 0,
    "m_Nodes": 16,
    "m_nFlags": 136,
    "m_nNameHash": 8
  },
  "FeNodeBase_t": {
    "nDummy": 2,
    "nNode": 0,
    "nNodeX0": 8,
    "nNodeX1": 10,
    "nNodeY0": 12,
    "nNodeY1": 14,
    "qAdjust": 16
  },
  "FeNodeIntegrator_t": {
    "flAnimationForceAttraction": 4,
    "flAnimationVertexAttraction": 8,
    "flGravity": 12,
    "flPointDamping": 0
  },
  "FeNodeReverseOffset_t": {
    "nBoneCtrl": 12,
    "nTargetNode": 14,
    "vOffset": 0
  },
  "FeNodeWindBase_t": {
    "nNodeX0": 0,
    "nNodeX1": 2,
    "nNodeY0": 4,
    "nNodeY1": 6
  },
  "FeProxyVertexMap_t": {
    "m_Name": 0,
    "m_flWeight": 8
  },
  "FeQuad_t": {
    "flSlack": 8,
    "nNode": 0,
    "vShape": 12
  },
  "FeRigidColliderIndices_t": {
    "m_nBoxRigidIndex": 4,
    "m_nCollisionPlaneIndex": 6,
    "m_nSphereRigidIndex": 2,
    "m_nTaperedCapsuleRigidIndex": 0
  },
  "FeRodConstraint_t": {
    "flMaxDist": 4,
    "flMinDist": 8,
    "flRelaxationFactor": 16,
    "flWeight0": 12,
    "nNode": 0
  },
  "FeSimdAnimStrayRadius_t": {
    "flMaxDist": 16,
    "flRelaxationFactor": 32,
    "nNode": 0
  },
  "FeSimdNodeBase_t": {
    "nDummy": 40,
    "nNode": 0,
    "nNodeX0": 8,
    "nNodeX1": 16,
    "nNodeY0": 24,
    "nNodeY1": 32,
    "qAdjust": 48
  },
  "FeSimdQuad_t": {
    "f4Slack": 32,
    "f4Weights": 240,
    "nNode": 0,
    "vShape": 48
  },
  "FeSimdRodConstraint_t": {
    "f4MaxDist": 16,
    "f4MinDist": 32,
    "f4RelaxationFactor": 64,
    "f4Weight0": 48,
    "nNode": 0
  },
  "FeSimdSpringIntegrator_t": {
    "flNodeWeight0": 64,
    "flSpringConstant": 32,
    "flSpringDamping": 48,
    "flSpringRestLength": 16,
    "nNode": 0
  },
  "FeSimdTri_t": {
    "nNode": 0,
    "v1x": 80,
    "v2": 96,
    "w1": 48,
    "w2": 64
  },
  "FeSoftParent_t": {
    "flAlpha": 4,
    "nParent": 0
  },
  "FeSourceEdge_t": {
    "nNode": 0
  },
  "FeSphereRigid_t": {
    "nCollisionMask": 18,
    "nFlags": 22,
    "nNode": 16,
    "nVertexMapIndex": 20,
    "vSphere": 0
  },
  "FeSpringIntegrator_t": {
    "flNodeWeight0": 16,
    "flSpringConstant": 8,
    "flSpringDamping": 12,
    "flSpringRestLength": 4,
    "nNode": 0
  },
  "FeStiffHingeBuild_t": {
    "flMaxAngle": 0,
    "flMotionBias": 8,
    "flStrength": 4,
    "nNode": 20
  },
  "FeTaperedCapsuleRigid_t": {
    "nCollisionMask": 34,
    "nFlags": 38,
    "nNode": 32,
    "nVertexMapIndex": 36,
    "vSphere": 0
  },
  "FeTaperedCapsuleStretch_t": {
    "flRadius": 8,
    "nCollisionMask": 4,
    "nDummy": 6,
    "nNode": 0
  },
  "FeTreeChildren_t": {
    "nChild": 0
  },
  "FeTri_t": {
    "nNode": 0,
    "v1x": 16,
    "v2": 20,
    "w1": 8,
    "w2": 12
  },
  "FeTwistConstraint_t": {
    "flSwingRelax": 8,
    "flTwistRelax": 4,
    "nNodeEnd": 2,
    "nNodeOrient": 0
  },
  "FeVertexMapBuild_t": {
    "m_Color": 12,
    "m_VertexMapName": 0,
    "m_Weights": 24,
    "m_flVolumetricSolveStrength": 16,
    "m_nNameHash": 8,
    "m_nScaleSourceNode": 20
  },
  "FeVertexMapDesc_t": {
    "flVolumetricSolveStrength": 44,
    "nColor": 12,
    "nFlags": 16,
    "nMapOffset": 24,
    "nNameHash": 8,
    "nNodeListCount": 50,
    "nNodeListOffset": 28,
    "nScaleSourceNode": 48,
    "nVertexBase": 20,
    "nVertexCount": 22,
    "sName": 0,
    "vCenterOfMass": 32
  },
  "FeWeightedNode_t": {
    "nNode": 0,
    "nWeight": 2
  },
  "FeWorldCollisionParams_t": {
    "flGroundFriction": 4,
    "flWorldFriction": 0,
    "nListBegin": 8,
    "nListEnd": 10
  },
  "FourCovMatrices3": {
    "m_flXY": 48,
    "m_flXZ": 64,
    "m_flYZ": 80,
    "m_vDiag": 0
  },
  "FourVectors2D": {
    "x": 0,
    "y": 16
  },
  "OldFeEdge_t": {
    "c01": 28,
    "c02": 32,
    "c03": 36,
    "c04": 40,
    "flAxialModelDist": 44,
    "flAxialModelWeights": 48,
    "flThetaFactor": 24,
    "flThetaRelaxed": 20,
    "invA": 12,
    "m_flK": 0,
    "m_nNode": 64,
    "t": 16
  },
  "PhysFeModelDesc_t": {
    "m_AnimStrayRadii": 960,
    "m_AxialEdges": 336,
    "m_BoxRigids": 1160,
    "m_CollisionPlanes": 456,
    "m_CtrlHash": 0,
    "m_CtrlName": 24,
    "m_CtrlOffsets": 384,
    "m_CtrlOsOffsets": 408,
    "m_CtrlSoftOffsets": 1032,
    "m_DynNodeFriction": 624,
    "m_DynNodeVertexSet": 1184,
    "m_DynNodeWindBases": 1424,
    "m_Effects": 1352,
    "m_FitMatrices": 888,
    "m_FitWeights": 912,
    "m_FollowNodes": 432,
    "m_FreeNodes": 864,
    "m_GoalDampedSpringIntegrators": 1104,
    "m_InitPose": 264,
    "m_JiggleBones": 1056,
    "m_KelagerBends": 1008,
    "m_LegacyStretchForce": 576,
    "m_LocalForce": 672,
    "m_LocalRotation": 648,
    "m_LockToGoal": 1400,
    "m_LockToParent": 1376,
    "m_MorphLayers": 1256,
    "m_MorphSetData": 1280,
    "m_NodeBases": 120,
    "m_NodeCollisionRadii": 600,
    "m_NodeIntegrator": 480,
    "m_NodeInvMasses": 360,
    "m_Quads": 168,
    "m_ReverseOffsets": 936,
    "m_RigidColliderPriorities": 1232,
    "m_Rods": 288,
    "m_Ropes": 96,
    "m_SimdAnimStrayRadii": 984,
    "m_SimdNodeBases": 144,
    "m_SimdQuads": 192,
    "m_SimdRods": 240,
    "m_SimdSpringIntegrator": 528,
    "m_SimdTris": 216,
    "m_SourceElems": 1080,
    "m_SphereRigids": 744,
    "m_SpringIntegrator": 504,
    "m_TaperedCapsuleRigids": 720,
    "m_TaperedCapsuleStretches": 696,
    "m_TreeChildren": 840,
    "m_TreeCollisionMasks": 816,
    "m_TreeParents": 792,
    "m_Tris": 1128,
    "m_Twists": 312,
    "m_VertexMapValues": 1328,
    "m_VertexMaps": 1304,
    "m_VertexSetNames": 1208,
    "m_WorldCollisionNodes": 768,
    "m_WorldCollisionParams": 552,
    "m_flAddWorldCollisionRadius": 1500,
    "m_flDefaultExpAirDrag": 1480,
    "m_flDefaultExpQuadAirDrag": 1488,
    "m_flDefaultGravityScale": 1472,
    "m_flDefaultSurfaceStretch": 1464,
    "m_flDefaultThreadStretch": 1468,
    "m_flDefaultTimeDilation": 1452,
    "m_flDefaultVelAirDrag": 1476,
    "m_flDefaultVelQuadAirDrag": 1484,
    "m_flDefaultVolumetricSolveAmount": 1504,
    "m_flInternalPressure": 1448,
    "m_flLocalForce": 56,
    "m_flLocalRotation": 60,
    "m_flQuadVelocitySmoothRate": 1496,
    "m_flRodVelocitySmoothRate": 1492,
    "m_flWindDrag": 1460,
    "m_flWindage": 1456,
    "m_nDynamicNodeFlags": 52,
    "m_nExtraGoalIterations": 1158,
    "m_nExtraIterations": 1159,
    "m_nExtraPressureIterations": 1157,
    "m_nFirstPositionDrivenNode": 70,
    "m_nNodeBaseJiggleboneDependsCount": 86,
    "m_nNodeCount": 64,
    "m_nQuadCount1": 80,
    "m_nQuadCount2": 82,
    "m_nQuadVelocitySmoothIterations": 1510,
    "m_nReservedUint8": 1156,
    "m_nRodVelocitySmoothIterations": 1508,
    "m_nRopeCount": 88,
    "m_nRotLockStaticNodes": 68,
    "m_nSimdQuadCount1": 76,
    "m_nSimdQuadCount2": 78,
    "m_nSimdTriCount1": 72,
    "m_nSimdTriCount2": 74,
    "m_nStaticNodeFlags": 48,
    "m_nStaticNodes": 66,
    "m_nTreeDepth": 84,
    "m_nTriCount1": 1152,
    "m_nTriCount2": 1154
  },
  "RnBlendVertex_t": {
    "m_nFlags": 12,
    "m_nIndex0": 2,
    "m_nIndex1": 6,
    "m_nIndex2": 10,
    "m_nTargetIndex": 14,
    "m_nWeight0": 0,
    "m_nWeight1": 4,
    "m_nWeight2": 8
  },
  "RnBodyDesc_t": {
    "m_LocalInertiaInv": 72,
    "m_bBuoyancyDragEnabled": 199,
    "m_bDragEnabled": 198,
    "m_bEnabled": 195,
    "m_bGravityDisabled": 200,
    "m_bHasShadowController": 202,
    "m_bIsContinuousEnabled": 197,
    "m_bSleeping": 196,
    "m_bSpeculativeEnabled": 201,
    "m_flAngularBuoyancyDrag": 140,
    "m_flAngularDamping": 124,
    "m_flAngularDrag": 132,
    "m_flBuoyancyFactor": 168,
    "m_flGameMass": 112,
    "m_flGravityScale": 172,
    "m_flInertiaScaleInv": 116,
    "m_flLinearBuoyancyDrag": 136,
    "m_flLinearDamping": 120,
    "m_flLinearDrag": 128,
    "m_flMassInv": 108,
    "m_flTimeScale": 176,
    "m_nBodyType": 180,
    "m_nGameFlags": 188,
    "m_nGameIndex": 184,
    "m_nMassPriority": 194,
    "m_nMinPositionIterations": 193,
    "m_nMinVelocityIterations": 192,
    "m_qOrientation": 20,
    "m_sDebugName": 0,
    "m_vAngularVelocity": 48,
    "m_vLastAwakeForceAccum": 144,
    "m_vLastAwakeTorqueAccum": 156,
    "m_vLinearVelocity": 36,
    "m_vLocalMassCenter": 60,
    "m_vPosition": 8
  },
  "RnCapsuleDesc_t": {
    "m_Capsule": 16
  },
  "RnCapsule_t": {
    "m_flRadius": 24,
    "m_vCenter": 0
  },
  "RnFace_t": {
    "m_nEdge": 0
  },
  "RnHalfEdge_t": {
    "m_nFace": 3,
    "m_nNext": 0,
    "m_nOrigin": 2,
    "m_nTwin": 1
  },
  "RnHullDesc_t": {
    "m_Hull": 16
  },
  "RnHull_t": {
    "m_Bounds": 16,
    "m_Edges": 152,
    "m_FacePlanes": 200,
    "m_Faces": 176,
    "m_MassProperties": 52,
    "m_VertexPositions": 128,
    "m_Vertices": 104,
    "m_flMaxAngularRadius": 12,
    "m_flVolume": 100,
    "m_nFlags": 224,
    "m_pRegionSVM": 232,
    "m_vCentroid": 0,
    "m_vOrthographicAreas": 40
  },
  "RnMeshDesc_t": {
    "m_Mesh": 16
  },
  "RnMesh_t": {
    "m_Materials": 120,
    "m_Nodes": 24,
    "m_Triangles": 72,
    "m_Vertices": 48,
    "m_Wings": 96,
    "m_nDebugFlags": 160,
    "m_nFlags": 156,
    "m_vMax": 12,
    "m_vMin": 0,
    "m_vOrthographicAreas": 144
  },
  "RnNode_t": {
    "m_nChildren": 12,
    "m_nTriangleOffset": 28,
    "m_vMax": 16,
    "m_vMin": 0
  },
  "RnPlane_t": {
    "m_flOffset": 12,
    "m_vNormal": 0
  },
  "RnShapeDesc_t": {
    "m_UserFriendlyName": 8,
    "m_nCollisionAttributeIndex": 0,
    "m_nSurfacePropertyIndex": 4
  },
  "RnSoftbodyCapsule_t": {
    "m_flRadius": 24,
    "m_nParticle": 28,
    "m_vCenter": 0
  },
  "RnSoftbodyParticle_t": {
    "m_flMassInv": 0
  },
  "RnSoftbodySpring_t": {
    "m_flLength": 4,
    "m_nParticle": 0
  },
  "RnSphereDesc_t": {
    "m_Sphere": 16
  },
  "RnSphere_t": {
    "m_flRadius": 12,
    "m_vCenter": 0
  },
  "RnTriangle_t": {
    "m_nIndex": 0
  },
  "RnVertex_t": {
    "m_nEdge": 0
  },
  "RnWing_t": {
    "m_nIndex": 0
  },
  "VertexPositionColor_t": {
    "m_vPosition": 0
  },
  "VertexPositionNormal_t": {
    "m_vNormal": 12,
    "m_vPosition": 0
  },
  "constraint_axislimit_t": {
    "flMaxRotation": 4,
    "flMinRotation": 0,
    "flMotorMaxTorque": 12,
    "flMotorTargetAngSpeed": 8
  },
  "constraint_breakableparams_t": {
    "bodyMassScale": 12,
    "forceLimit": 4,
    "isActive": 20,
    "strength": 0,
    "torqueLimit": 8
  },
  "constraint_hingeparams_t": {
    "constraint": 40,
    "hingeAxis": 24,
    "worldAxisDirection": 12,
    "worldPosition": 0
  },
  "vphysics_save_cphysicsbody_t": {
    "m_nOldPointer": 208
  }
}
```

`SDK/vphysics2.dll.py`:

```py
'''
https://github.com/a2x/cs2-dumper
2023-11-23 10:28:25.510165200 UTC
'''

class CFeIndexedJiggleBone:
    m_nNode = 0x0 # uint32_t
    m_nJiggleParent = 0x4 # uint32_t
    m_jiggleBone = 0x8 # CFeJiggleBone

class CFeJiggleBone:
    m_nFlags = 0x0 # uint32_t
    m_flLength = 0x4 # float
    m_flTipMass = 0x8 # float
    m_flYawStiffness = 0xC # float
    m_flYawDamping = 0x10 # float
    m_flPitchStiffness = 0x14 # float
    m_flPitchDamping = 0x18 # float
    m_flAlongStiffness = 0x1C # float
    m_flAlongDamping = 0x20 # float
    m_flAngleLimit = 0x24 # float
    m_flMinYaw = 0x28 # float
    m_flMaxYaw = 0x2C # float
    m_flYawFriction = 0x30 # float
    m_flYawBounce = 0x34 # float
    m_flMinPitch = 0x38 # float
    m_flMaxPitch = 0x3C # float
    m_flPitchFriction = 0x40 # float
    m_flPitchBounce = 0x44 # float
    m_flBaseMass = 0x48 # float
    m_flBaseStiffness = 0x4C # float
    m_flBaseDamping = 0x50 # float
    m_flBaseMinLeft = 0x54 # float
    m_flBaseMaxLeft = 0x58 # float
    m_flBaseLeftFriction = 0x5C # float
    m_flBaseMinUp = 0x60 # float
    m_flBaseMaxUp = 0x64 # float
    m_flBaseUpFriction = 0x68 # float
    m_flBaseMinForward = 0x6C # float
    m_flBaseMaxForward = 0x70 # float
    m_flBaseForwardFriction = 0x74 # float
    m_flRadius0 = 0x78 # float
    m_flRadius1 = 0x7C # float
    m_vPoint0 = 0x80 # Vector
    m_vPoint1 = 0x8C # Vector
    m_nCollisionMask = 0x98 # uint16_t

class CFeMorphLayer:
    m_Name = 0x0 # CUtlString
    m_nNameHash = 0x8 # uint32_t
    m_Nodes = 0x10 # CUtlVector<uint16_t>
    m_InitPos = 0x28 # CUtlVector<Vector>
    m_Gravity = 0x40 # CUtlVector<float>
    m_GoalStrength = 0x58 # CUtlVector<float>
    m_GoalDamping = 0x70 # CUtlVector<float>

class CFeNamedJiggleBone:
    m_strParentBone = 0x0 # CUtlString
    m_transform = 0x10 # CTransform
    m_nJiggleParent = 0x30 # uint32_t
    m_jiggleBone = 0x34 # CFeJiggleBone

class CFeVertexMapBuildArray:
    m_Array = 0x0 # CUtlVector<FeVertexMapBuild_t*>

class CRegionSVM:
    m_Planes = 0x0 # CUtlVector<RnPlane_t>
    m_Nodes = 0x18 # CUtlVector<uint32_t>

class CastSphereSATParams_t:
    m_vRayStart = 0x0 # Vector
    m_vRayDelta = 0xC # Vector
    m_flRadius = 0x18 # float
    m_flMaxFraction = 0x1C # float
    m_flScale = 0x20 # float
    m_pHull = 0x28 # RnHull_t*

class CovMatrix3:
    m_vDiag = 0x0 # Vector
    m_flXY = 0xC # float
    m_flXZ = 0x10 # float
    m_flYZ = 0x14 # float

class Dop26_t:
    m_flSupport = 0x0 # float[26]

class FeAnimStrayRadius_t:
    nNode = 0x0 # uint16_t[2]
    flMaxDist = 0x4 # float
    flRelaxationFactor = 0x8 # float

class FeAxialEdgeBend_t:
    te = 0x0 # float
    tv = 0x4 # float
    flDist = 0x8 # float
    flWeight = 0xC # float[4]
    nNode = 0x1C # uint16_t[6]

class FeBandBendLimit_t:
    flDistMin = 0x0 # float
    flDistMax = 0x4 # float
    nNode = 0x8 # uint16_t[6]

class FeBoxRigid_t:
    tmFrame2 = 0x0 # CTransform
    nNode = 0x20 # uint16_t
    nCollisionMask = 0x22 # uint16_t
    vSize = 0x24 # Vector
    nVertexMapIndex = 0x30 # uint16_t
    nFlags = 0x32 # uint16_t

class FeBuildBoxRigid_t:
    m_nPriority = 0x40 # int32_t
    m_nVertexMapHash = 0x44 # uint32_t

class FeBuildSphereRigid_t:
    m_nPriority = 0x20 # int32_t
    m_nVertexMapHash = 0x24 # uint32_t

class FeBuildTaperedCapsuleRigid_t:
    m_nPriority = 0x30 # int32_t
    m_nVertexMapHash = 0x34 # uint32_t

class FeCollisionPlane_t:
    nCtrlParent = 0x0 # uint16_t
    nChildNode = 0x2 # uint16_t
    m_Plane = 0x4 # RnPlane_t
    flStrength = 0x14 # float

class FeCtrlOffset_t:
    vOffset = 0x0 # Vector
    nCtrlParent = 0xC # uint16_t
    nCtrlChild = 0xE # uint16_t

class FeCtrlOsOffset_t:
    nCtrlParent = 0x0 # uint16_t
    nCtrlChild = 0x2 # uint16_t

class FeCtrlSoftOffset_t:
    nCtrlParent = 0x0 # uint16_t
    nCtrlChild = 0x2 # uint16_t
    vOffset = 0x4 # Vector
    flAlpha = 0x10 # float

class FeEdgeDesc_t:
    nEdge = 0x0 # uint16_t[2]
    nSide = 0x4 # uint16_t[2][2]
    nVirtElem = 0xC # uint16_t[2]

class FeEffectDesc_t:
    sName = 0x0 # CUtlString
    nNameHash = 0x8 # uint32_t
    nType = 0xC # int32_t
    m_Params = 0x10 # KeyValues3

class FeFitInfluence_t:
    nVertexNode = 0x0 # uint32_t
    flWeight = 0x4 # float
    nMatrixNode = 0x8 # uint32_t

class FeFitMatrix_t:
    bone = 0x0 # CTransform
    vCenter = 0x20 # Vector
    nEnd = 0x2C # uint16_t
    nNode = 0x2E # uint16_t
    nBeginDynamic = 0x30 # uint16_t

class FeFitWeight_t:
    flWeight = 0x0 # float
    nNode = 0x4 # uint16_t
    nDummy = 0x6 # uint16_t

class FeFollowNode_t:
    nParentNode = 0x0 # uint16_t
    nChildNode = 0x2 # uint16_t
    flWeight = 0x4 # float

class FeKelagerBend2_t:
    flWeight = 0x0 # float[3]
    flHeight0 = 0xC # float
    nNode = 0x10 # uint16_t[3]
    nReserved = 0x16 # uint16_t

class FeMorphLayerDepr_t:
    m_Name = 0x0 # CUtlString
    m_nNameHash = 0x8 # uint32_t
    m_Nodes = 0x10 # CUtlVector<uint16_t>
    m_InitPos = 0x28 # CUtlVector<Vector>
    m_Gravity = 0x40 # CUtlVector<float>
    m_GoalStrength = 0x58 # CUtlVector<float>
    m_GoalDamping = 0x70 # CUtlVector<float>
    m_nFlags = 0x88 # uint32_t

class FeNodeBase_t:
    nNode = 0x0 # uint16_t
    nDummy = 0x2 # uint16_t[3]
    nNodeX0 = 0x8 # uint16_t
    nNodeX1 = 0xA # uint16_t
    nNodeY0 = 0xC # uint16_t
    nNodeY1 = 0xE # uint16_t
    qAdjust = 0x10 # QuaternionStorage

class FeNodeIntegrator_t:
    flPointDamping = 0x0 # float
    flAnimationForceAttraction = 0x4 # float
    flAnimationVertexAttraction = 0x8 # float
    flGravity = 0xC # float

class FeNodeReverseOffset_t:
    vOffset = 0x0 # Vector
    nBoneCtrl = 0xC # uint16_t
    nTargetNode = 0xE # uint16_t

class FeNodeWindBase_t:
    nNodeX0 = 0x0 # uint16_t
    nNodeX1 = 0x2 # uint16_t
    nNodeY0 = 0x4 # uint16_t
    nNodeY1 = 0x6 # uint16_t

class FeProxyVertexMap_t:
    m_Name = 0x0 # CUtlString
    m_flWeight = 0x8 # float

class FeQuad_t:
    nNode = 0x0 # uint16_t[4]
    flSlack = 0x8 # float
    vShape = 0xC # Vector4D[4]

class FeRigidColliderIndices_t:
    m_nTaperedCapsuleRigidIndex = 0x0 # uint16_t
    m_nSphereRigidIndex = 0x2 # uint16_t
    m_nBoxRigidIndex = 0x4 # uint16_t
    m_nCollisionPlaneIndex = 0x6 # uint16_t

class FeRodConstraint_t:
    nNode = 0x0 # uint16_t[2]
    flMaxDist = 0x4 # float
    flMinDist = 0x8 # float
    flWeight0 = 0xC # float
    flRelaxationFactor = 0x10 # float

class FeSimdAnimStrayRadius_t:
    nNode = 0x0 # uint16_t[4][2]
    flMaxDist = 0x10 # fltx4
    flRelaxationFactor = 0x20 # fltx4

class FeSimdNodeBase_t:
    nNode = 0x0 # uint16_t[4]
    nNodeX0 = 0x8 # uint16_t[4]
    nNodeX1 = 0x10 # uint16_t[4]
    nNodeY0 = 0x18 # uint16_t[4]
    nNodeY1 = 0x20 # uint16_t[4]
    nDummy = 0x28 # uint16_t[4]
    qAdjust = 0x30 # FourQuaternions

class FeSimdQuad_t:
    nNode = 0x0 # uint16_t[4][4]
    f4Slack = 0x20 # fltx4
    vShape = 0x30 # FourVectors[4]
    f4Weights = 0xF0 # fltx4[4]

class FeSimdRodConstraint_t:
    nNode = 0x0 # uint16_t[4][2]
    f4MaxDist = 0x10 # fltx4
    f4MinDist = 0x20 # fltx4
    f4Weight0 = 0x30 # fltx4
    f4RelaxationFactor = 0x40 # fltx4

class FeSimdSpringIntegrator_t:
    nNode = 0x0 # uint16_t[4][2]
    flSpringRestLength = 0x10 # fltx4
    flSpringConstant = 0x20 # fltx4
    flSpringDamping = 0x30 # fltx4
    flNodeWeight0 = 0x40 # fltx4

class FeSimdTri_t:
    nNode = 0x0 # uint32_t[4][3]
    w1 = 0x30 # fltx4
    w2 = 0x40 # fltx4
    v1x = 0x50 # fltx4
    v2 = 0x60 # FourVectors2D

class FeSoftParent_t:
    nParent = 0x0 # int32_t
    flAlpha = 0x4 # float

class FeSourceEdge_t:
    nNode = 0x0 # uint16_t[2]

class FeSphereRigid_t:
    vSphere = 0x0 # fltx4
    nNode = 0x10 # uint16_t
    nCollisionMask = 0x12 # uint16_t
    nVertexMapIndex = 0x14 # uint16_t
    nFlags = 0x16 # uint16_t

class FeSpringIntegrator_t:
    nNode = 0x0 # uint16_t[2]
    flSpringRestLength = 0x4 # float
    flSpringConstant = 0x8 # float
    flSpringDamping = 0xC # float
    flNodeWeight0 = 0x10 # float

class FeStiffHingeBuild_t:
    flMaxAngle = 0x0 # float
    flStrength = 0x4 # float
    flMotionBias = 0x8 # float[3]
    nNode = 0x14 # uint16_t[3]

class FeTaperedCapsuleRigid_t:
    vSphere = 0x0 # fltx4[2]
    nNode = 0x20 # uint16_t
    nCollisionMask = 0x22 # uint16_t
    nVertexMapIndex = 0x24 # uint16_t
    nFlags = 0x26 # uint16_t

class FeTaperedCapsuleStretch_t:
    nNode = 0x0 # uint16_t[2]
    nCollisionMask = 0x4 # uint16_t
    nDummy = 0x6 # uint16_t
    flRadius = 0x8 # float[2]

class FeTreeChildren_t:
    nChild = 0x0 # uint16_t[2]

class FeTri_t:
    nNode = 0x0 # uint16_t[3]
    w1 = 0x8 # float
    w2 = 0xC # float
    v1x = 0x10 # float
    v2 = 0x14 # Vector2D

class FeTwistConstraint_t:
    nNodeOrient = 0x0 # uint16_t
    nNodeEnd = 0x2 # uint16_t
    flTwistRelax = 0x4 # float
    flSwingRelax = 0x8 # float

class FeVertexMapBuild_t:
    m_VertexMapName = 0x0 # CUtlString
    m_nNameHash = 0x8 # uint32_t
    m_Color = 0xC # Color
    m_flVolumetricSolveStrength = 0x10 # float
    m_nScaleSourceNode = 0x14 # int32_t
    m_Weights = 0x18 # CUtlVector<float>

class FeVertexMapDesc_t:
    sName = 0x0 # CUtlString
    nNameHash = 0x8 # uint32_t
    nColor = 0xC # uint32_t
    nFlags = 0x10 # uint32_t
    nVertexBase = 0x14 # uint16_t
    nVertexCount = 0x16 # uint16_t
    nMapOffset = 0x18 # uint32_t
    nNodeListOffset = 0x1C # uint32_t
    vCenterOfMass = 0x20 # Vector
    flVolumetricSolveStrength = 0x2C # float
    nScaleSourceNode = 0x30 # int16_t
    nNodeListCount = 0x32 # uint16_t

class FeWeightedNode_t:
    nNode = 0x0 # uint16_t
    nWeight = 0x2 # uint16_t

class FeWorldCollisionParams_t:
    flWorldFriction = 0x0 # float
    flGroundFriction = 0x4 # float
    nListBegin = 0x8 # uint16_t
    nListEnd = 0xA # uint16_t

class FourCovMatrices3:
    m_vDiag = 0x0 # FourVectors
    m_flXY = 0x30 # fltx4
    m_flXZ = 0x40 # fltx4
    m_flYZ = 0x50 # fltx4

class FourVectors2D:
    x = 0x0 # fltx4
    y = 0x10 # fltx4

class OldFeEdge_t:
    m_flK = 0x0 # float[3]
    invA = 0xC # float
    t = 0x10 # float
    flThetaRelaxed = 0x14 # float
    flThetaFactor = 0x18 # float
    c01 = 0x1C # float
    c02 = 0x20 # float
    c03 = 0x24 # float
    c04 = 0x28 # float
    flAxialModelDist = 0x2C # float
    flAxialModelWeights = 0x30 # float[4]
    m_nNode = 0x40 # uint16_t[4]

class PhysFeModelDesc_t:
    m_CtrlHash = 0x0 # CUtlVector<uint32_t>
    m_CtrlName = 0x18 # CUtlVector<CUtlString>
    m_nStaticNodeFlags = 0x30 # uint32_t
    m_nDynamicNodeFlags = 0x34 # uint32_t
    m_flLocalForce = 0x38 # float
    m_flLocalRotation = 0x3C # float
    m_nNodeCount = 0x40 # uint16_t
    m_nStaticNodes = 0x42 # uint16_t
    m_nRotLockStaticNodes = 0x44 # uint16_t
    m_nFirstPositionDrivenNode = 0x46 # uint16_t
    m_nSimdTriCount1 = 0x48 # uint16_t
    m_nSimdTriCount2 = 0x4A # uint16_t
    m_nSimdQuadCount1 = 0x4C # uint16_t
    m_nSimdQuadCount2 = 0x4E # uint16_t
    m_nQuadCount1 = 0x50 # uint16_t
    m_nQuadCount2 = 0x52 # uint16_t
    m_nTreeDepth = 0x54 # uint16_t
    m_nNodeBaseJiggleboneDependsCount = 0x56 # uint16_t
    m_nRopeCount = 0x58 # uint16_t
    m_Ropes = 0x60 # CUtlVector<uint16_t>
    m_NodeBases = 0x78 # CUtlVector<FeNodeBase_t>
    m_SimdNodeBases = 0x90 # CUtlVector<FeSimdNodeBase_t>
    m_Quads = 0xA8 # CUtlVector<FeQuad_t>
    m_SimdQuads = 0xC0 # CUtlVector<FeSimdQuad_t>
    m_SimdTris = 0xD8 # CUtlVector<FeSimdTri_t>
    m_SimdRods = 0xF0 # CUtlVector<FeSimdRodConstraint_t>
    m_InitPose = 0x108 # CUtlVector<CTransform>
    m_Rods = 0x120 # CUtlVector<FeRodConstraint_t>
    m_Twists = 0x138 # CUtlVector<FeTwistConstraint_t>
    m_AxialEdges = 0x150 # CUtlVector<FeAxialEdgeBend_t>
    m_NodeInvMasses = 0x168 # CUtlVector<float>
    m_CtrlOffsets = 0x180 # CUtlVector<FeCtrlOffset_t>
    m_CtrlOsOffsets = 0x198 # CUtlVector<FeCtrlOsOffset_t>
    m_FollowNodes = 0x1B0 # CUtlVector<FeFollowNode_t>
    m_CollisionPlanes = 0x1C8 # CUtlVector<FeCollisionPlane_t>
    m_NodeIntegrator = 0x1E0 # CUtlVector<FeNodeIntegrator_t>
    m_SpringIntegrator = 0x1F8 # CUtlVector<FeSpringIntegrator_t>
    m_SimdSpringIntegrator = 0x210 # CUtlVector<FeSimdSpringIntegrator_t>
    m_WorldCollisionParams = 0x228 # CUtlVector<FeWorldCollisionParams_t>
    m_LegacyStretchForce = 0x240 # CUtlVector<float>
    m_NodeCollisionRadii = 0x258 # CUtlVector<float>
    m_DynNodeFriction = 0x270 # CUtlVector<float>
    m_LocalRotation = 0x288 # CUtlVector<float>
    m_LocalForce = 0x2A0 # CUtlVector<float>
    m_TaperedCapsuleStretches = 0x2B8 # CUtlVector<FeTaperedCapsuleStretch_t>
    m_TaperedCapsuleRigids = 0x2D0 # CUtlVector<FeTaperedCapsuleRigid_t>
    m_SphereRigids = 0x2E8 # CUtlVector<FeSphereRigid_t>
    m_WorldCollisionNodes = 0x300 # CUtlVector<uint16_t>
    m_TreeParents = 0x318 # CUtlVector<uint16_t>
    m_TreeCollisionMasks = 0x330 # CUtlVector<uint16_t>
    m_TreeChildren = 0x348 # CUtlVector<FeTreeChildren_t>
    m_FreeNodes = 0x360 # CUtlVector<uint16_t>
    m_FitMatrices = 0x378 # CUtlVector<FeFitMatrix_t>
    m_FitWeights = 0x390 # CUtlVector<FeFitWeight_t>
    m_ReverseOffsets = 0x3A8 # CUtlVector<FeNodeReverseOffset_t>
    m_AnimStrayRadii = 0x3C0 # CUtlVector<FeAnimStrayRadius_t>
    m_SimdAnimStrayRadii = 0x3D8 # CUtlVector<FeSimdAnimStrayRadius_t>
    m_KelagerBends = 0x3F0 # CUtlVector<FeKelagerBend2_t>
    m_CtrlSoftOffsets = 0x408 # CUtlVector<FeCtrlSoftOffset_t>
    m_JiggleBones = 0x420 # CUtlVector<CFeIndexedJiggleBone>
    m_SourceElems = 0x438 # CUtlVector<uint16_t>
    m_GoalDampedSpringIntegrators = 0x450 # CUtlVector<uint32_t>
    m_Tris = 0x468 # CUtlVector<FeTri_t>
    m_nTriCount1 = 0x480 # uint16_t
    m_nTriCount2 = 0x482 # uint16_t
    m_nReservedUint8 = 0x484 # uint8_t
    m_nExtraPressureIterations = 0x485 # uint8_t
    m_nExtraGoalIterations = 0x486 # uint8_t
    m_nExtraIterations = 0x487 # uint8_t
    m_BoxRigids = 0x488 # CUtlVector<FeBoxRigid_t>
    m_DynNodeVertexSet = 0x4A0 # CUtlVector<uint8_t>
    m_VertexSetNames = 0x4B8 # CUtlVector<uint32_t>
    m_RigidColliderPriorities = 0x4D0 # CUtlVector<FeRigidColliderIndices_t>
    m_MorphLayers = 0x4E8 # CUtlVector<FeMorphLayerDepr_t>
    m_MorphSetData = 0x500 # CUtlVector<uint8_t>
    m_VertexMaps = 0x518 # CUtlVector<FeVertexMapDesc_t>
    m_VertexMapValues = 0x530 # CUtlVector<uint8_t>
    m_Effects = 0x548 # CUtlVector<FeEffectDesc_t>
    m_LockToParent = 0x560 # CUtlVector<FeCtrlOffset_t>
    m_LockToGoal = 0x578 # CUtlVector<uint16_t>
    m_DynNodeWindBases = 0x590 # CUtlVector<FeNodeWindBase_t>
    m_flInternalPressure = 0x5A8 # float
    m_flDefaultTimeDilation = 0x5AC # float
    m_flWindage = 0x5B0 # float
    m_flWindDrag = 0x5B4 # float
    m_flDefaultSurfaceStretch = 0x5B8 # float
    m_flDefaultThreadStretch = 0x5BC # float
    m_flDefaultGravityScale = 0x5C0 # float
    m_flDefaultVelAirDrag = 0x5C4 # float
    m_flDefaultExpAirDrag = 0x5C8 # float
    m_flDefaultVelQuadAirDrag = 0x5CC # float
    m_flDefaultExpQuadAirDrag = 0x5D0 # float
    m_flRodVelocitySmoothRate = 0x5D4 # float
    m_flQuadVelocitySmoothRate = 0x5D8 # float
    m_flAddWorldCollisionRadius = 0x5DC # float
    m_flDefaultVolumetricSolveAmount = 0x5E0 # float
    m_nRodVelocitySmoothIterations = 0x5E4 # uint16_t
    m_nQuadVelocitySmoothIterations = 0x5E6 # uint16_t

class RnBlendVertex_t:
    m_nWeight0 = 0x0 # uint16_t
    m_nIndex0 = 0x2 # uint16_t
    m_nWeight1 = 0x4 # uint16_t
    m_nIndex1 = 0x6 # uint16_t
    m_nWeight2 = 0x8 # uint16_t
    m_nIndex2 = 0xA # uint16_t
    m_nFlags = 0xC # uint16_t
    m_nTargetIndex = 0xE # uint16_t

class RnBodyDesc_t:
    m_sDebugName = 0x0 # CUtlString
    m_vPosition = 0x8 # Vector
    m_qOrientation = 0x14 # QuaternionStorage
    m_vLinearVelocity = 0x24 # Vector
    m_vAngularVelocity = 0x30 # Vector
    m_vLocalMassCenter = 0x3C # Vector
    m_LocalInertiaInv = 0x48 # Vector[3]
    m_flMassInv = 0x6C # float
    m_flGameMass = 0x70 # float
    m_flInertiaScaleInv = 0x74 # float
    m_flLinearDamping = 0x78 # float
    m_flAngularDamping = 0x7C # float
    m_flLinearDrag = 0x80 # float
    m_flAngularDrag = 0x84 # float
    m_flLinearBuoyancyDrag = 0x88 # float
    m_flAngularBuoyancyDrag = 0x8C # float
    m_vLastAwakeForceAccum = 0x90 # Vector
    m_vLastAwakeTorqueAccum = 0x9C # Vector
    m_flBuoyancyFactor = 0xA8 # float
    m_flGravityScale = 0xAC # float
    m_flTimeScale = 0xB0 # float
    m_nBodyType = 0xB4 # int32_t
    m_nGameIndex = 0xB8 # uint32_t
    m_nGameFlags = 0xBC # uint32_t
    m_nMinVelocityIterations = 0xC0 # int8_t
    m_nMinPositionIterations = 0xC1 # int8_t
    m_nMassPriority = 0xC2 # int8_t
    m_bEnabled = 0xC3 # bool
    m_bSleeping = 0xC4 # bool
    m_bIsContinuousEnabled = 0xC5 # bool
    m_bDragEnabled = 0xC6 # bool
    m_bBuoyancyDragEnabled = 0xC7 # bool
    m_bGravityDisabled = 0xC8 # bool
    m_bSpeculativeEnabled = 0xC9 # bool
    m_bHasShadowController = 0xCA # bool

class RnCapsuleDesc_t:
    m_Capsule = 0x10 # RnCapsule_t

class RnCapsule_t:
    m_vCenter = 0x0 # Vector[2]
    m_flRadius = 0x18 # float

class RnFace_t:
    m_nEdge = 0x0 # uint8_t

class RnHalfEdge_t:
    m_nNext = 0x0 # uint8_t
    m_nTwin = 0x1 # uint8_t
    m_nOrigin = 0x2 # uint8_t
    m_nFace = 0x3 # uint8_t

class RnHullDesc_t:
    m_Hull = 0x10 # RnHull_t

class RnHull_t:
    m_vCentroid = 0x0 # Vector
    m_flMaxAngularRadius = 0xC # float
    m_Bounds = 0x10 # AABB_t
    m_vOrthographicAreas = 0x28 # Vector
    m_MassProperties = 0x34 # matrix3x4_t
    m_flVolume = 0x64 # float
    m_Vertices = 0x68 # CUtlVector<RnVertex_t>
    m_VertexPositions = 0x80 # CUtlVector<Vector>
    m_Edges = 0x98 # CUtlVector<RnHalfEdge_t>
    m_Faces = 0xB0 # CUtlVector<RnFace_t>
    m_FacePlanes = 0xC8 # CUtlVector<RnPlane_t>
    m_nFlags = 0xE0 # uint32_t
    m_pRegionSVM = 0xE8 # CRegionSVM*

class RnMeshDesc_t:
    m_Mesh = 0x10 # RnMesh_t

class RnMesh_t:
    m_vMin = 0x0 # Vector
    m_vMax = 0xC # Vector
    m_Nodes = 0x18 # CUtlVector<RnNode_t>
    m_Vertices = 0x30 # CUtlVectorSIMDPaddedVector
    m_Triangles = 0x48 # CUtlVector<RnTriangle_t>
    m_Wings = 0x60 # CUtlVector<RnWing_t>
    m_Materials = 0x78 # CUtlVector<uint8_t>
    m_vOrthographicAreas = 0x90 # Vector
    m_nFlags = 0x9C # uint32_t
    m_nDebugFlags = 0xA0 # uint32_t

class RnNode_t:
    m_vMin = 0x0 # Vector
    m_nChildren = 0xC # uint32_t
    m_vMax = 0x10 # Vector
    m_nTriangleOffset = 0x1C # uint32_t

class RnPlane_t:
    m_vNormal = 0x0 # Vector
    m_flOffset = 0xC # float

class RnShapeDesc_t:
    m_nCollisionAttributeIndex = 0x0 # uint32_t
    m_nSurfacePropertyIndex = 0x4 # uint32_t
    m_UserFriendlyName = 0x8 # CUtlString

class RnSoftbodyCapsule_t:
    m_vCenter = 0x0 # Vector[2]
    m_flRadius = 0x18 # float
    m_nParticle = 0x1C # uint16_t[2]

class RnSoftbodyParticle_t:
    m_flMassInv = 0x0 # float

class RnSoftbodySpring_t:
    m_nParticle = 0x0 # uint16_t[2]
    m_flLength = 0x4 # float

class RnSphereDesc_t:
    m_Sphere = 0x10 # RnSphere_t

class RnSphere_t:
    m_vCenter = 0x0 # Vector
    m_flRadius = 0xC # float

class RnTriangle_t:
    m_nIndex = 0x0 # int32_t[3]

class RnVertex_t:
    m_nEdge = 0x0 # uint8_t

class RnWing_t:
    m_nIndex = 0x0 # int32_t[3]

class VertexPositionColor_t:
    m_vPosition = 0x0 # Vector

class VertexPositionNormal_t:
    m_vPosition = 0x0 # Vector
    m_vNormal = 0xC # Vector

class constraint_axislimit_t:
    flMinRotation = 0x0 # float
    flMaxRotation = 0x4 # float
    flMotorTargetAngSpeed = 0x8 # float
    flMotorMaxTorque = 0xC # float

class constraint_breakableparams_t:
    strength = 0x0 # float
    forceLimit = 0x4 # float
    torqueLimit = 0x8 # float
    bodyMassScale = 0xC # float[2]
    isActive = 0x14 # bool

class constraint_hingeparams_t:
    worldPosition = 0x0 # Vector
    worldAxisDirection = 0xC # Vector
    hingeAxis = 0x18 # constraint_axislimit_t
    constraint = 0x28 # constraint_breakableparams_t

class vphysics_save_cphysicsbody_t:
    m_nOldPointer = 0xD0 # uint64_t

```

`SDK/vphysics2.dll.rs`:

```rs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.523890700 UTC
 */

#![allow(non_snake_case, non_upper_case_globals)]

pub mod CFeIndexedJiggleBone {
    pub const m_nNode: usize = 0x0; // uint32_t
    pub const m_nJiggleParent: usize = 0x4; // uint32_t
    pub const m_jiggleBone: usize = 0x8; // CFeJiggleBone
}

pub mod CFeJiggleBone {
    pub const m_nFlags: usize = 0x0; // uint32_t
    pub const m_flLength: usize = 0x4; // float
    pub const m_flTipMass: usize = 0x8; // float
    pub const m_flYawStiffness: usize = 0xC; // float
    pub const m_flYawDamping: usize = 0x10; // float
    pub const m_flPitchStiffness: usize = 0x14; // float
    pub const m_flPitchDamping: usize = 0x18; // float
    pub const m_flAlongStiffness: usize = 0x1C; // float
    pub const m_flAlongDamping: usize = 0x20; // float
    pub const m_flAngleLimit: usize = 0x24; // float
    pub const m_flMinYaw: usize = 0x28; // float
    pub const m_flMaxYaw: usize = 0x2C; // float
    pub const m_flYawFriction: usize = 0x30; // float
    pub const m_flYawBounce: usize = 0x34; // float
    pub const m_flMinPitch: usize = 0x38; // float
    pub const m_flMaxPitch: usize = 0x3C; // float
    pub const m_flPitchFriction: usize = 0x40; // float
    pub const m_flPitchBounce: usize = 0x44; // float
    pub const m_flBaseMass: usize = 0x48; // float
    pub const m_flBaseStiffness: usize = 0x4C; // float
    pub const m_flBaseDamping: usize = 0x50; // float
    pub const m_flBaseMinLeft: usize = 0x54; // float
    pub const m_flBaseMaxLeft: usize = 0x58; // float
    pub const m_flBaseLeftFriction: usize = 0x5C; // float
    pub const m_flBaseMinUp: usize = 0x60; // float
    pub const m_flBaseMaxUp: usize = 0x64; // float
    pub const m_flBaseUpFriction: usize = 0x68; // float
    pub const m_flBaseMinForward: usize = 0x6C; // float
    pub const m_flBaseMaxForward: usize = 0x70; // float
    pub const m_flBaseForwardFriction: usize = 0x74; // float
    pub const m_flRadius0: usize = 0x78; // float
    pub const m_flRadius1: usize = 0x7C; // float
    pub const m_vPoint0: usize = 0x80; // Vector
    pub const m_vPoint1: usize = 0x8C; // Vector
    pub const m_nCollisionMask: usize = 0x98; // uint16_t
}

pub mod CFeMorphLayer {
    pub const m_Name: usize = 0x0; // CUtlString
    pub const m_nNameHash: usize = 0x8; // uint32_t
    pub const m_Nodes: usize = 0x10; // CUtlVector<uint16_t>
    pub const m_InitPos: usize = 0x28; // CUtlVector<Vector>
    pub const m_Gravity: usize = 0x40; // CUtlVector<float>
    pub const m_GoalStrength: usize = 0x58; // CUtlVector<float>
    pub const m_GoalDamping: usize = 0x70; // CUtlVector<float>
}

pub mod CFeNamedJiggleBone {
    pub const m_strParentBone: usize = 0x0; // CUtlString
    pub const m_transform: usize = 0x10; // CTransform
    pub const m_nJiggleParent: usize = 0x30; // uint32_t
    pub const m_jiggleBone: usize = 0x34; // CFeJiggleBone
}

pub mod CFeVertexMapBuildArray {
    pub const m_Array: usize = 0x0; // CUtlVector<FeVertexMapBuild_t*>
}

pub mod CRegionSVM {
    pub const m_Planes: usize = 0x0; // CUtlVector<RnPlane_t>
    pub const m_Nodes: usize = 0x18; // CUtlVector<uint32_t>
}

pub mod CastSphereSATParams_t {
    pub const m_vRayStart: usize = 0x0; // Vector
    pub const m_vRayDelta: usize = 0xC; // Vector
    pub const m_flRadius: usize = 0x18; // float
    pub const m_flMaxFraction: usize = 0x1C; // float
    pub const m_flScale: usize = 0x20; // float
    pub const m_pHull: usize = 0x28; // RnHull_t*
}

pub mod CovMatrix3 {
    pub const m_vDiag: usize = 0x0; // Vector
    pub const m_flXY: usize = 0xC; // float
    pub const m_flXZ: usize = 0x10; // float
    pub const m_flYZ: usize = 0x14; // float
}

pub mod Dop26_t {
    pub const m_flSupport: usize = 0x0; // float[26]
}

pub mod FeAnimStrayRadius_t {
    pub const nNode: usize = 0x0; // uint16_t[2]
    pub const flMaxDist: usize = 0x4; // float
    pub const flRelaxationFactor: usize = 0x8; // float
}

pub mod FeAxialEdgeBend_t {
    pub const te: usize = 0x0; // float
    pub const tv: usize = 0x4; // float
    pub const flDist: usize = 0x8; // float
    pub const flWeight: usize = 0xC; // float[4]
    pub const nNode: usize = 0x1C; // uint16_t[6]
}

pub mod FeBandBendLimit_t {
    pub const flDistMin: usize = 0x0; // float
    pub const flDistMax: usize = 0x4; // float
    pub const nNode: usize = 0x8; // uint16_t[6]
}

pub mod FeBoxRigid_t {
    pub const tmFrame2: usize = 0x0; // CTransform
    pub const nNode: usize = 0x20; // uint16_t
    pub const nCollisionMask: usize = 0x22; // uint16_t
    pub const vSize: usize = 0x24; // Vector
    pub const nVertexMapIndex: usize = 0x30; // uint16_t
    pub const nFlags: usize = 0x32; // uint16_t
}

pub mod FeBuildBoxRigid_t {
    pub const m_nPriority: usize = 0x40; // int32_t
    pub const m_nVertexMapHash: usize = 0x44; // uint32_t
}

pub mod FeBuildSphereRigid_t {
    pub const m_nPriority: usize = 0x20; // int32_t
    pub const m_nVertexMapHash: usize = 0x24; // uint32_t
}

pub mod FeBuildTaperedCapsuleRigid_t {
    pub const m_nPriority: usize = 0x30; // int32_t
    pub const m_nVertexMapHash: usize = 0x34; // uint32_t
}

pub mod FeCollisionPlane_t {
    pub const nCtrlParent: usize = 0x0; // uint16_t
    pub const nChildNode: usize = 0x2; // uint16_t
    pub const m_Plane: usize = 0x4; // RnPlane_t
    pub const flStrength: usize = 0x14; // float
}

pub mod FeCtrlOffset_t {
    pub const vOffset: usize = 0x0; // Vector
    pub const nCtrlParent: usize = 0xC; // uint16_t
    pub const nCtrlChild: usize = 0xE; // uint16_t
}

pub mod FeCtrlOsOffset_t {
    pub const nCtrlParent: usize = 0x0; // uint16_t
    pub const nCtrlChild: usize = 0x2; // uint16_t
}

pub mod FeCtrlSoftOffset_t {
    pub const nCtrlParent: usize = 0x0; // uint16_t
    pub const nCtrlChild: usize = 0x2; // uint16_t
    pub const vOffset: usize = 0x4; // Vector
    pub const flAlpha: usize = 0x10; // float
}

pub mod FeEdgeDesc_t {
    pub const nEdge: usize = 0x0; // uint16_t[2]
    pub const nSide: usize = 0x4; // uint16_t[2][2]
    pub const nVirtElem: usize = 0xC; // uint16_t[2]
}

pub mod FeEffectDesc_t {
    pub const sName: usize = 0x0; // CUtlString
    pub const nNameHash: usize = 0x8; // uint32_t
    pub const nType: usize = 0xC; // int32_t
    pub const m_Params: usize = 0x10; // KeyValues3
}

pub mod FeFitInfluence_t {
    pub const nVertexNode: usize = 0x0; // uint32_t
    pub const flWeight: usize = 0x4; // float
    pub const nMatrixNode: usize = 0x8; // uint32_t
}

pub mod FeFitMatrix_t {
    pub const bone: usize = 0x0; // CTransform
    pub const vCenter: usize = 0x20; // Vector
    pub const nEnd: usize = 0x2C; // uint16_t
    pub const nNode: usize = 0x2E; // uint16_t
    pub const nBeginDynamic: usize = 0x30; // uint16_t
}

pub mod FeFitWeight_t {
    pub const flWeight: usize = 0x0; // float
    pub const nNode: usize = 0x4; // uint16_t
    pub const nDummy: usize = 0x6; // uint16_t
}

pub mod FeFollowNode_t {
    pub const nParentNode: usize = 0x0; // uint16_t
    pub const nChildNode: usize = 0x2; // uint16_t
    pub const flWeight: usize = 0x4; // float
}

pub mod FeKelagerBend2_t {
    pub const flWeight: usize = 0x0; // float[3]
    pub const flHeight0: usize = 0xC; // float
    pub const nNode: usize = 0x10; // uint16_t[3]
    pub const nReserved: usize = 0x16; // uint16_t
}

pub mod FeMorphLayerDepr_t {
    pub const m_Name: usize = 0x0; // CUtlString
    pub const m_nNameHash: usize = 0x8; // uint32_t
    pub const m_Nodes: usize = 0x10; // CUtlVector<uint16_t>
    pub const m_InitPos: usize = 0x28; // CUtlVector<Vector>
    pub const m_Gravity: usize = 0x40; // CUtlVector<float>
    pub const m_GoalStrength: usize = 0x58; // CUtlVector<float>
    pub const m_GoalDamping: usize = 0x70; // CUtlVector<float>
    pub const m_nFlags: usize = 0x88; // uint32_t
}

pub mod FeNodeBase_t {
    pub const nNode: usize = 0x0; // uint16_t
    pub const nDummy: usize = 0x2; // uint16_t[3]
    pub const nNodeX0: usize = 0x8; // uint16_t
    pub const nNodeX1: usize = 0xA; // uint16_t
    pub const nNodeY0: usize = 0xC; // uint16_t
    pub const nNodeY1: usize = 0xE; // uint16_t
    pub const qAdjust: usize = 0x10; // QuaternionStorage
}

pub mod FeNodeIntegrator_t {
    pub const flPointDamping: usize = 0x0; // float
    pub const flAnimationForceAttraction: usize = 0x4; // float
    pub const flAnimationVertexAttraction: usize = 0x8; // float
    pub const flGravity: usize = 0xC; // float
}

pub mod FeNodeReverseOffset_t {
    pub const vOffset: usize = 0x0; // Vector
    pub const nBoneCtrl: usize = 0xC; // uint16_t
    pub const nTargetNode: usize = 0xE; // uint16_t
}

pub mod FeNodeWindBase_t {
    pub const nNodeX0: usize = 0x0; // uint16_t
    pub const nNodeX1: usize = 0x2; // uint16_t
    pub const nNodeY0: usize = 0x4; // uint16_t
    pub const nNodeY1: usize = 0x6; // uint16_t
}

pub mod FeProxyVertexMap_t {
    pub const m_Name: usize = 0x0; // CUtlString
    pub const m_flWeight: usize = 0x8; // float
}

pub mod FeQuad_t {
    pub const nNode: usize = 0x0; // uint16_t[4]
    pub const flSlack: usize = 0x8; // float
    pub const vShape: usize = 0xC; // Vector4D[4]
}

pub mod FeRigidColliderIndices_t {
    pub const m_nTaperedCapsuleRigidIndex: usize = 0x0; // uint16_t
    pub const m_nSphereRigidIndex: usize = 0x2; // uint16_t
    pub const m_nBoxRigidIndex: usize = 0x4; // uint16_t
    pub const m_nCollisionPlaneIndex: usize = 0x6; // uint16_t
}

pub mod FeRodConstraint_t {
    pub const nNode: usize = 0x0; // uint16_t[2]
    pub const flMaxDist: usize = 0x4; // float
    pub const flMinDist: usize = 0x8; // float
    pub const flWeight0: usize = 0xC; // float
    pub const flRelaxationFactor: usize = 0x10; // float
}

pub mod FeSimdAnimStrayRadius_t {
    pub const nNode: usize = 0x0; // uint16_t[4][2]
    pub const flMaxDist: usize = 0x10; // fltx4
    pub const flRelaxationFactor: usize = 0x20; // fltx4
}

pub mod FeSimdNodeBase_t {
    pub const nNode: usize = 0x0; // uint16_t[4]
    pub const nNodeX0: usize = 0x8; // uint16_t[4]
    pub const nNodeX1: usize = 0x10; // uint16_t[4]
    pub const nNodeY0: usize = 0x18; // uint16_t[4]
    pub const nNodeY1: usize = 0x20; // uint16_t[4]
    pub const nDummy: usize = 0x28; // uint16_t[4]
    pub const qAdjust: usize = 0x30; // FourQuaternions
}

pub mod FeSimdQuad_t {
    pub const nNode: usize = 0x0; // uint16_t[4][4]
    pub const f4Slack: usize = 0x20; // fltx4
    pub const vShape: usize = 0x30; // FourVectors[4]
    pub const f4Weights: usize = 0xF0; // fltx4[4]
}

pub mod FeSimdRodConstraint_t {
    pub const nNode: usize = 0x0; // uint16_t[4][2]
    pub const f4MaxDist: usize = 0x10; // fltx4
    pub const f4MinDist: usize = 0x20; // fltx4
    pub const f4Weight0: usize = 0x30; // fltx4
    pub const f4RelaxationFactor: usize = 0x40; // fltx4
}

pub mod FeSimdSpringIntegrator_t {
    pub const nNode: usize = 0x0; // uint16_t[4][2]
    pub const flSpringRestLength: usize = 0x10; // fltx4
    pub const flSpringConstant: usize = 0x20; // fltx4
    pub const flSpringDamping: usize = 0x30; // fltx4
    pub const flNodeWeight0: usize = 0x40; // fltx4
}

pub mod FeSimdTri_t {
    pub const nNode: usize = 0x0; // uint32_t[4][3]
    pub const w1: usize = 0x30; // fltx4
    pub const w2: usize = 0x40; // fltx4
    pub const v1x: usize = 0x50; // fltx4
    pub const v2: usize = 0x60; // FourVectors2D
}

pub mod FeSoftParent_t {
    pub const nParent: usize = 0x0; // int32_t
    pub const flAlpha: usize = 0x4; // float
}

pub mod FeSourceEdge_t {
    pub const nNode: usize = 0x0; // uint16_t[2]
}

pub mod FeSphereRigid_t {
    pub const vSphere: usize = 0x0; // fltx4
    pub const nNode: usize = 0x10; // uint16_t
    pub const nCollisionMask: usize = 0x12; // uint16_t
    pub const nVertexMapIndex: usize = 0x14; // uint16_t
    pub const nFlags: usize = 0x16; // uint16_t
}

pub mod FeSpringIntegrator_t {
    pub const nNode: usize = 0x0; // uint16_t[2]
    pub const flSpringRestLength: usize = 0x4; // float
    pub const flSpringConstant: usize = 0x8; // float
    pub const flSpringDamping: usize = 0xC; // float
    pub const flNodeWeight0: usize = 0x10; // float
}

pub mod FeStiffHingeBuild_t {
    pub const flMaxAngle: usize = 0x0; // float
    pub const flStrength: usize = 0x4; // float
    pub const flMotionBias: usize = 0x8; // float[3]
    pub const nNode: usize = 0x14; // uint16_t[3]
}

pub mod FeTaperedCapsuleRigid_t {
    pub const vSphere: usize = 0x0; // fltx4[2]
    pub const nNode: usize = 0x20; // uint16_t
    pub const nCollisionMask: usize = 0x22; // uint16_t
    pub const nVertexMapIndex: usize = 0x24; // uint16_t
    pub const nFlags: usize = 0x26; // uint16_t
}

pub mod FeTaperedCapsuleStretch_t {
    pub const nNode: usize = 0x0; // uint16_t[2]
    pub const nCollisionMask: usize = 0x4; // uint16_t
    pub const nDummy: usize = 0x6; // uint16_t
    pub const flRadius: usize = 0x8; // float[2]
}

pub mod FeTreeChildren_t {
    pub const nChild: usize = 0x0; // uint16_t[2]
}

pub mod FeTri_t {
    pub const nNode: usize = 0x0; // uint16_t[3]
    pub const w1: usize = 0x8; // float
    pub const w2: usize = 0xC; // float
    pub const v1x: usize = 0x10; // float
    pub const v2: usize = 0x14; // Vector2D
}

pub mod FeTwistConstraint_t {
    pub const nNodeOrient: usize = 0x0; // uint16_t
    pub const nNodeEnd: usize = 0x2; // uint16_t
    pub const flTwistRelax: usize = 0x4; // float
    pub const flSwingRelax: usize = 0x8; // float
}

pub mod FeVertexMapBuild_t {
    pub const m_VertexMapName: usize = 0x0; // CUtlString
    pub const m_nNameHash: usize = 0x8; // uint32_t
    pub const m_Color: usize = 0xC; // Color
    pub const m_flVolumetricSolveStrength: usize = 0x10; // float
    pub const m_nScaleSourceNode: usize = 0x14; // int32_t
    pub const m_Weights: usize = 0x18; // CUtlVector<float>
}

pub mod FeVertexMapDesc_t {
    pub const sName: usize = 0x0; // CUtlString
    pub const nNameHash: usize = 0x8; // uint32_t
    pub const nColor: usize = 0xC; // uint32_t
    pub const nFlags: usize = 0x10; // uint32_t
    pub const nVertexBase: usize = 0x14; // uint16_t
    pub const nVertexCount: usize = 0x16; // uint16_t
    pub const nMapOffset: usize = 0x18; // uint32_t
    pub const nNodeListOffset: usize = 0x1C; // uint32_t
    pub const vCenterOfMass: usize = 0x20; // Vector
    pub const flVolumetricSolveStrength: usize = 0x2C; // float
    pub const nScaleSourceNode: usize = 0x30; // int16_t
    pub const nNodeListCount: usize = 0x32; // uint16_t
}

pub mod FeWeightedNode_t {
    pub const nNode: usize = 0x0; // uint16_t
    pub const nWeight: usize = 0x2; // uint16_t
}

pub mod FeWorldCollisionParams_t {
    pub const flWorldFriction: usize = 0x0; // float
    pub const flGroundFriction: usize = 0x4; // float
    pub const nListBegin: usize = 0x8; // uint16_t
    pub const nListEnd: usize = 0xA; // uint16_t
}

pub mod FourCovMatrices3 {
    pub const m_vDiag: usize = 0x0; // FourVectors
    pub const m_flXY: usize = 0x30; // fltx4
    pub const m_flXZ: usize = 0x40; // fltx4
    pub const m_flYZ: usize = 0x50; // fltx4
}

pub mod FourVectors2D {
    pub const x: usize = 0x0; // fltx4
    pub const y: usize = 0x10; // fltx4
}

pub mod OldFeEdge_t {
    pub const m_flK: usize = 0x0; // float[3]
    pub const invA: usize = 0xC; // float
    pub const t: usize = 0x10; // float
    pub const flThetaRelaxed: usize = 0x14; // float
    pub const flThetaFactor: usize = 0x18; // float
    pub const c01: usize = 0x1C; // float
    pub const c02: usize = 0x20; // float
    pub const c03: usize = 0x24; // float
    pub const c04: usize = 0x28; // float
    pub const flAxialModelDist: usize = 0x2C; // float
    pub const flAxialModelWeights: usize = 0x30; // float[4]
    pub const m_nNode: usize = 0x40; // uint16_t[4]
}

pub mod PhysFeModelDesc_t {
    pub const m_CtrlHash: usize = 0x0; // CUtlVector<uint32_t>
    pub const m_CtrlName: usize = 0x18; // CUtlVector<CUtlString>
    pub const m_nStaticNodeFlags: usize = 0x30; // uint32_t
    pub const m_nDynamicNodeFlags: usize = 0x34; // uint32_t
    pub const m_flLocalForce: usize = 0x38; // float
    pub const m_flLocalRotation: usize = 0x3C; // float
    pub const m_nNodeCount: usize = 0x40; // uint16_t
    pub const m_nStaticNodes: usize = 0x42; // uint16_t
    pub const m_nRotLockStaticNodes: usize = 0x44; // uint16_t
    pub const m_nFirstPositionDrivenNode: usize = 0x46; // uint16_t
    pub const m_nSimdTriCount1: usize = 0x48; // uint16_t
    pub const m_nSimdTriCount2: usize = 0x4A; // uint16_t
    pub const m_nSimdQuadCount1: usize = 0x4C; // uint16_t
    pub const m_nSimdQuadCount2: usize = 0x4E; // uint16_t
    pub const m_nQuadCount1: usize = 0x50; // uint16_t
    pub const m_nQuadCount2: usize = 0x52; // uint16_t
    pub const m_nTreeDepth: usize = 0x54; // uint16_t
    pub const m_nNodeBaseJiggleboneDependsCount: usize = 0x56; // uint16_t
    pub const m_nRopeCount: usize = 0x58; // uint16_t
    pub const m_Ropes: usize = 0x60; // CUtlVector<uint16_t>
    pub const m_NodeBases: usize = 0x78; // CUtlVector<FeNodeBase_t>
    pub const m_SimdNodeBases: usize = 0x90; // CUtlVector<FeSimdNodeBase_t>
    pub const m_Quads: usize = 0xA8; // CUtlVector<FeQuad_t>
    pub const m_SimdQuads: usize = 0xC0; // CUtlVector<FeSimdQuad_t>
    pub const m_SimdTris: usize = 0xD8; // CUtlVector<FeSimdTri_t>
    pub const m_SimdRods: usize = 0xF0; // CUtlVector<FeSimdRodConstraint_t>
    pub const m_InitPose: usize = 0x108; // CUtlVector<CTransform>
    pub const m_Rods: usize = 0x120; // CUtlVector<FeRodConstraint_t>
    pub const m_Twists: usize = 0x138; // CUtlVector<FeTwistConstraint_t>
    pub const m_AxialEdges: usize = 0x150; // CUtlVector<FeAxialEdgeBend_t>
    pub const m_NodeInvMasses: usize = 0x168; // CUtlVector<float>
    pub const m_CtrlOffsets: usize = 0x180; // CUtlVector<FeCtrlOffset_t>
    pub const m_CtrlOsOffsets: usize = 0x198; // CUtlVector<FeCtrlOsOffset_t>
    pub const m_FollowNodes: usize = 0x1B0; // CUtlVector<FeFollowNode_t>
    pub const m_CollisionPlanes: usize = 0x1C8; // CUtlVector<FeCollisionPlane_t>
    pub const m_NodeIntegrator: usize = 0x1E0; // CUtlVector<FeNodeIntegrator_t>
    pub const m_SpringIntegrator: usize = 0x1F8; // CUtlVector<FeSpringIntegrator_t>
    pub const m_SimdSpringIntegrator: usize = 0x210; // CUtlVector<FeSimdSpringIntegrator_t>
    pub const m_WorldCollisionParams: usize = 0x228; // CUtlVector<FeWorldCollisionParams_t>
    pub const m_LegacyStretchForce: usize = 0x240; // CUtlVector<float>
    pub const m_NodeCollisionRadii: usize = 0x258; // CUtlVector<float>
    pub const m_DynNodeFriction: usize = 0x270; // CUtlVector<float>
    pub const m_LocalRotation: usize = 0x288; // CUtlVector<float>
    pub const m_LocalForce: usize = 0x2A0; // CUtlVector<float>
    pub const m_TaperedCapsuleStretches: usize = 0x2B8; // CUtlVector<FeTaperedCapsuleStretch_t>
    pub const m_TaperedCapsuleRigids: usize = 0x2D0; // CUtlVector<FeTaperedCapsuleRigid_t>
    pub const m_SphereRigids: usize = 0x2E8; // CUtlVector<FeSphereRigid_t>
    pub const m_WorldCollisionNodes: usize = 0x300; // CUtlVector<uint16_t>
    pub const m_TreeParents: usize = 0x318; // CUtlVector<uint16_t>
    pub const m_TreeCollisionMasks: usize = 0x330; // CUtlVector<uint16_t>
    pub const m_TreeChildren: usize = 0x348; // CUtlVector<FeTreeChildren_t>
    pub const m_FreeNodes: usize = 0x360; // CUtlVector<uint16_t>
    pub const m_FitMatrices: usize = 0x378; // CUtlVector<FeFitMatrix_t>
    pub const m_FitWeights: usize = 0x390; // CUtlVector<FeFitWeight_t>
    pub const m_ReverseOffsets: usize = 0x3A8; // CUtlVector<FeNodeReverseOffset_t>
    pub const m_AnimStrayRadii: usize = 0x3C0; // CUtlVector<FeAnimStrayRadius_t>
    pub const m_SimdAnimStrayRadii: usize = 0x3D8; // CUtlVector<FeSimdAnimStrayRadius_t>
    pub const m_KelagerBends: usize = 0x3F0; // CUtlVector<FeKelagerBend2_t>
    pub const m_CtrlSoftOffsets: usize = 0x408; // CUtlVector<FeCtrlSoftOffset_t>
    pub const m_JiggleBones: usize = 0x420; // CUtlVector<CFeIndexedJiggleBone>
    pub const m_SourceElems: usize = 0x438; // CUtlVector<uint16_t>
    pub const m_GoalDampedSpringIntegrators: usize = 0x450; // CUtlVector<uint32_t>
    pub const m_Tris: usize = 0x468; // CUtlVector<FeTri_t>
    pub const m_nTriCount1: usize = 0x480; // uint16_t
    pub const m_nTriCount2: usize = 0x482; // uint16_t
    pub const m_nReservedUint8: usize = 0x484; // uint8_t
    pub const m_nExtraPressureIterations: usize = 0x485; // uint8_t
    pub const m_nExtraGoalIterations: usize = 0x486; // uint8_t
    pub const m_nExtraIterations: usize = 0x487; // uint8_t
    pub const m_BoxRigids: usize = 0x488; // CUtlVector<FeBoxRigid_t>
    pub const m_DynNodeVertexSet: usize = 0x4A0; // CUtlVector<uint8_t>
    pub const m_VertexSetNames: usize = 0x4B8; // CUtlVector<uint32_t>
    pub const m_RigidColliderPriorities: usize = 0x4D0; // CUtlVector<FeRigidColliderIndices_t>
    pub const m_MorphLayers: usize = 0x4E8; // CUtlVector<FeMorphLayerDepr_t>
    pub const m_MorphSetData: usize = 0x500; // CUtlVector<uint8_t>
    pub const m_VertexMaps: usize = 0x518; // CUtlVector<FeVertexMapDesc_t>
    pub const m_VertexMapValues: usize = 0x530; // CUtlVector<uint8_t>
    pub const m_Effects: usize = 0x548; // CUtlVector<FeEffectDesc_t>
    pub const m_LockToParent: usize = 0x560; // CUtlVector<FeCtrlOffset_t>
    pub const m_LockToGoal: usize = 0x578; // CUtlVector<uint16_t>
    pub const m_DynNodeWindBases: usize = 0x590; // CUtlVector<FeNodeWindBase_t>
    pub const m_flInternalPressure: usize = 0x5A8; // float
    pub const m_flDefaultTimeDilation: usize = 0x5AC; // float
    pub const m_flWindage: usize = 0x5B0; // float
    pub const m_flWindDrag: usize = 0x5B4; // float
    pub const m_flDefaultSurfaceStretch: usize = 0x5B8; // float
    pub const m_flDefaultThreadStretch: usize = 0x5BC; // float
    pub const m_flDefaultGravityScale: usize = 0x5C0; // float
    pub const m_flDefaultVelAirDrag: usize = 0x5C4; // float
    pub const m_flDefaultExpAirDrag: usize = 0x5C8; // float
    pub const m_flDefaultVelQuadAirDrag: usize = 0x5CC; // float
    pub const m_flDefaultExpQuadAirDrag: usize = 0x5D0; // float
    pub const m_flRodVelocitySmoothRate: usize = 0x5D4; // float
    pub const m_flQuadVelocitySmoothRate: usize = 0x5D8; // float
    pub const m_flAddWorldCollisionRadius: usize = 0x5DC; // float
    pub const m_flDefaultVolumetricSolveAmount: usize = 0x5E0; // float
    pub const m_nRodVelocitySmoothIterations: usize = 0x5E4; // uint16_t
    pub const m_nQuadVelocitySmoothIterations: usize = 0x5E6; // uint16_t
}

pub mod RnBlendVertex_t {
    pub const m_nWeight0: usize = 0x0; // uint16_t
    pub const m_nIndex0: usize = 0x2; // uint16_t
    pub const m_nWeight1: usize = 0x4; // uint16_t
    pub const m_nIndex1: usize = 0x6; // uint16_t
    pub const m_nWeight2: usize = 0x8; // uint16_t
    pub const m_nIndex2: usize = 0xA; // uint16_t
    pub const m_nFlags: usize = 0xC; // uint16_t
    pub const m_nTargetIndex: usize = 0xE; // uint16_t
}

pub mod RnBodyDesc_t {
    pub const m_sDebugName: usize = 0x0; // CUtlString
    pub const m_vPosition: usize = 0x8; // Vector
    pub const m_qOrientation: usize = 0x14; // QuaternionStorage
    pub const m_vLinearVelocity: usize = 0x24; // Vector
    pub const m_vAngularVelocity: usize = 0x30; // Vector
    pub const m_vLocalMassCenter: usize = 0x3C; // Vector
    pub const m_LocalInertiaInv: usize = 0x48; // Vector[3]
    pub const m_flMassInv: usize = 0x6C; // float
    pub const m_flGameMass: usize = 0x70; // float
    pub const m_flInertiaScaleInv: usize = 0x74; // float
    pub const m_flLinearDamping: usize = 0x78; // float
    pub const m_flAngularDamping: usize = 0x7C; // float
    pub const m_flLinearDrag: usize = 0x80; // float
    pub const m_flAngularDrag: usize = 0x84; // float
    pub const m_flLinearBuoyancyDrag: usize = 0x88; // float
    pub const m_flAngularBuoyancyDrag: usize = 0x8C; // float
    pub const m_vLastAwakeForceAccum: usize = 0x90; // Vector
    pub const m_vLastAwakeTorqueAccum: usize = 0x9C; // Vector
    pub const m_flBuoyancyFactor: usize = 0xA8; // float
    pub const m_flGravityScale: usize = 0xAC; // float
    pub const m_flTimeScale: usize = 0xB0; // float
    pub const m_nBodyType: usize = 0xB4; // int32_t
    pub const m_nGameIndex: usize = 0xB8; // uint32_t
    pub const m_nGameFlags: usize = 0xBC; // uint32_t
    pub const m_nMinVelocityIterations: usize = 0xC0; // int8_t
    pub const m_nMinPositionIterations: usize = 0xC1; // int8_t
    pub const m_nMassPriority: usize = 0xC2; // int8_t
    pub const m_bEnabled: usize = 0xC3; // bool
    pub const m_bSleeping: usize = 0xC4; // bool
    pub const m_bIsContinuousEnabled: usize = 0xC5; // bool
    pub const m_bDragEnabled: usize = 0xC6; // bool
    pub const m_bBuoyancyDragEnabled: usize = 0xC7; // bool
    pub const m_bGravityDisabled: usize = 0xC8; // bool
    pub const m_bSpeculativeEnabled: usize = 0xC9; // bool
    pub const m_bHasShadowController: usize = 0xCA; // bool
}

pub mod RnCapsuleDesc_t {
    pub const m_Capsule: usize = 0x10; // RnCapsule_t
}

pub mod RnCapsule_t {
    pub const m_vCenter: usize = 0x0; // Vector[2]
    pub const m_flRadius: usize = 0x18; // float
}

pub mod RnFace_t {
    pub const m_nEdge: usize = 0x0; // uint8_t
}

pub mod RnHalfEdge_t {
    pub const m_nNext: usize = 0x0; // uint8_t
    pub const m_nTwin: usize = 0x1; // uint8_t
    pub const m_nOrigin: usize = 0x2; // uint8_t
    pub const m_nFace: usize = 0x3; // uint8_t
}

pub mod RnHullDesc_t {
    pub const m_Hull: usize = 0x10; // RnHull_t
}

pub mod RnHull_t {
    pub const m_vCentroid: usize = 0x0; // Vector
    pub const m_flMaxAngularRadius: usize = 0xC; // float
    pub const m_Bounds: usize = 0x10; // AABB_t
    pub const m_vOrthographicAreas: usize = 0x28; // Vector
    pub const m_MassProperties: usize = 0x34; // matrix3x4_t
    pub const m_flVolume: usize = 0x64; // float
    pub const m_Vertices: usize = 0x68; // CUtlVector<RnVertex_t>
    pub const m_VertexPositions: usize = 0x80; // CUtlVector<Vector>
    pub const m_Edges: usize = 0x98; // CUtlVector<RnHalfEdge_t>
    pub const m_Faces: usize = 0xB0; // CUtlVector<RnFace_t>
    pub const m_FacePlanes: usize = 0xC8; // CUtlVector<RnPlane_t>
    pub const m_nFlags: usize = 0xE0; // uint32_t
    pub const m_pRegionSVM: usize = 0xE8; // CRegionSVM*
}

pub mod RnMeshDesc_t {
    pub const m_Mesh: usize = 0x10; // RnMesh_t
}

pub mod RnMesh_t {
    pub const m_vMin: usize = 0x0; // Vector
    pub const m_vMax: usize = 0xC; // Vector
    pub const m_Nodes: usize = 0x18; // CUtlVector<RnNode_t>
    pub const m_Vertices: usize = 0x30; // CUtlVectorSIMDPaddedVector
    pub const m_Triangles: usize = 0x48; // CUtlVector<RnTriangle_t>
    pub const m_Wings: usize = 0x60; // CUtlVector<RnWing_t>
    pub const m_Materials: usize = 0x78; // CUtlVector<uint8_t>
    pub const m_vOrthographicAreas: usize = 0x90; // Vector
    pub const m_nFlags: usize = 0x9C; // uint32_t
    pub const m_nDebugFlags: usize = 0xA0; // uint32_t
}

pub mod RnNode_t {
    pub const m_vMin: usize = 0x0; // Vector
    pub const m_nChildren: usize = 0xC; // uint32_t
    pub const m_vMax: usize = 0x10; // Vector
    pub const m_nTriangleOffset: usize = 0x1C; // uint32_t
}

pub mod RnPlane_t {
    pub const m_vNormal: usize = 0x0; // Vector
    pub const m_flOffset: usize = 0xC; // float
}

pub mod RnShapeDesc_t {
    pub const m_nCollisionAttributeIndex: usize = 0x0; // uint32_t
    pub const m_nSurfacePropertyIndex: usize = 0x4; // uint32_t
    pub const m_UserFriendlyName: usize = 0x8; // CUtlString
}

pub mod RnSoftbodyCapsule_t {
    pub const m_vCenter: usize = 0x0; // Vector[2]
    pub const m_flRadius: usize = 0x18; // float
    pub const m_nParticle: usize = 0x1C; // uint16_t[2]
}

pub mod RnSoftbodyParticle_t {
    pub const m_flMassInv: usize = 0x0; // float
}

pub mod RnSoftbodySpring_t {
    pub const m_nParticle: usize = 0x0; // uint16_t[2]
    pub const m_flLength: usize = 0x4; // float
}

pub mod RnSphereDesc_t {
    pub const m_Sphere: usize = 0x10; // RnSphere_t
}

pub mod RnSphere_t {
    pub const m_vCenter: usize = 0x0; // Vector
    pub const m_flRadius: usize = 0xC; // float
}

pub mod RnTriangle_t {
    pub const m_nIndex: usize = 0x0; // int32_t[3]
}

pub mod RnVertex_t {
    pub const m_nEdge: usize = 0x0; // uint8_t
}

pub mod RnWing_t {
    pub const m_nIndex: usize = 0x0; // int32_t[3]
}

pub mod VertexPositionColor_t {
    pub const m_vPosition: usize = 0x0; // Vector
}

pub mod VertexPositionNormal_t {
    pub const m_vPosition: usize = 0x0; // Vector
    pub const m_vNormal: usize = 0xC; // Vector
}

pub mod constraint_axislimit_t {
    pub const flMinRotation: usize = 0x0; // float
    pub const flMaxRotation: usize = 0x4; // float
    pub const flMotorTargetAngSpeed: usize = 0x8; // float
    pub const flMotorMaxTorque: usize = 0xC; // float
}

pub mod constraint_breakableparams_t {
    pub const strength: usize = 0x0; // float
    pub const forceLimit: usize = 0x4; // float
    pub const torqueLimit: usize = 0x8; // float
    pub const bodyMassScale: usize = 0xC; // float[2]
    pub const isActive: usize = 0x14; // bool
}

pub mod constraint_hingeparams_t {
    pub const worldPosition: usize = 0x0; // Vector
    pub const worldAxisDirection: usize = 0xC; // Vector
    pub const hingeAxis: usize = 0x18; // constraint_axislimit_t
    pub const constraint: usize = 0x28; // constraint_breakableparams_t
}

pub mod vphysics_save_cphysicsbody_t {
    pub const m_nOldPointer: usize = 0xD0; // uint64_t
}
```

`SDK/worldrenderer.dll.cs`:

```cs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.596183100 UTC
 */

public static class AggregateLODSetup_t {
    public const nint m_vLODOrigin = 0x0; // Vector
    public const nint m_fMaxObjectScale = 0xC; // float
    public const nint m_fSwitchDistances = 0x10; // CUtlVectorFixedGrowable<float>
}

public static class AggregateMeshInfo_t {
    public const nint m_nVisClusterMemberOffset = 0x0; // uint32_t
    public const nint m_nVisClusterMemberCount = 0x4; // uint8_t
    public const nint m_bHasTransform = 0x5; // bool
    public const nint m_nDrawCallIndex = 0x6; // int16_t
    public const nint m_nLODSetupIndex = 0x8; // int16_t
    public const nint m_nLODGroupMask = 0xA; // uint8_t
    public const nint m_vTintColor = 0xB; // Color
    public const nint m_objectFlags = 0x10; // ObjectTypeFlags_t
    public const nint m_nLightProbeVolumePrecomputedHandshake = 0x14; // int32_t
}

public static class AggregateSceneObject_t {
    public const nint m_allFlags = 0x0; // ObjectTypeFlags_t
    public const nint m_anyFlags = 0x4; // ObjectTypeFlags_t
    public const nint m_nLayer = 0x8; // int16_t
    public const nint m_aggregateMeshes = 0x10; // CUtlVector<AggregateMeshInfo_t>
    public const nint m_lodSetups = 0x28; // CUtlVector<AggregateLODSetup_t>
    public const nint m_visClusterMembership = 0x40; // CUtlVector<uint16_t>
    public const nint m_fragmentTransforms = 0x58; // CUtlVector<matrix3x4_t>
    public const nint m_renderableModel = 0x70; // CStrongHandle<InfoForResourceTypeCModel>
}

public static class BakedLightingInfo_t {
    public const nint m_nLightmapVersionNumber = 0x0; // uint32_t
    public const nint m_nLightmapGameVersionNumber = 0x4; // uint32_t
    public const nint m_vLightmapUvScale = 0x8; // Vector2D
    public const nint m_bHasLightmaps = 0x10; // bool
    public const nint m_lightMaps = 0x18; // CUtlVector<CStrongHandle<InfoForResourceTypeCTextureBase>>
}

public static class BaseSceneObjectOverride_t {
    public const nint m_nSceneObjectIndex = 0x0; // uint32_t
}

public static class CEntityIdentity {
    public const nint m_nameStringableIndex = 0x14; // int32_t
    public const nint m_name = 0x18; // CUtlSymbolLarge
    public const nint m_designerName = 0x20; // CUtlSymbolLarge
    public const nint m_flags = 0x30; // uint32_t
    public const nint m_worldGroupId = 0x38; // WorldGroupId_t
    public const nint m_fDataObjectTypes = 0x3C; // uint32_t
    public const nint m_PathIndex = 0x40; // ChangeAccessorFieldPathIndex_t
    public const nint m_pPrev = 0x58; // CEntityIdentity*
    public const nint m_pNext = 0x60; // CEntityIdentity*
    public const nint m_pPrevByClass = 0x68; // CEntityIdentity*
    public const nint m_pNextByClass = 0x70; // CEntityIdentity*
}

public static class CEntityInstance {
    public const nint m_iszPrivateVScripts = 0x8; // CUtlSymbolLarge
    public const nint m_pEntity = 0x10; // CEntityIdentity*
    public const nint m_CScriptComponent = 0x28; // CScriptComponent*
}

public static class CScriptComponent {
    public const nint m_scriptClassName = 0x30; // CUtlSymbolLarge
}

public static class CVoxelVisibility {
    public const nint m_nBaseClusterCount = 0x40; // uint32_t
    public const nint m_nPVSBytesPerCluster = 0x44; // uint32_t
    public const nint m_vMinBounds = 0x48; // Vector
    public const nint m_vMaxBounds = 0x54; // Vector
    public const nint m_flGridSize = 0x60; // float
    public const nint m_nSkyVisibilityCluster = 0x64; // uint32_t
    public const nint m_nSunVisibilityCluster = 0x68; // uint32_t
    public const nint m_NodeBlock = 0x6C; // VoxelVisBlockOffset_t
    public const nint m_RegionBlock = 0x74; // VoxelVisBlockOffset_t
    public const nint m_EnclosedClusterListBlock = 0x7C; // VoxelVisBlockOffset_t
    public const nint m_EnclosedClustersBlock = 0x84; // VoxelVisBlockOffset_t
    public const nint m_MasksBlock = 0x8C; // VoxelVisBlockOffset_t
    public const nint m_nVisBlocks = 0x94; // VoxelVisBlockOffset_t
}

public static class ClutterSceneObject_t {
    public const nint m_Bounds = 0x0; // AABB_t
    public const nint m_flags = 0x18; // ObjectTypeFlags_t
    public const nint m_nLayer = 0x1C; // int16_t
    public const nint m_instancePositions = 0x20; // CUtlVector<Vector>
    public const nint m_instanceScales = 0x50; // CUtlVector<float>
    public const nint m_instanceTintSrgb = 0x68; // CUtlVector<Color>
    public const nint m_tiles = 0x80; // CUtlVector<ClutterTile_t>
    public const nint m_renderableModel = 0x98; // CStrongHandle<InfoForResourceTypeCModel>
}

public static class ClutterTile_t {
    public const nint m_nFirstInstance = 0x0; // uint32_t
    public const nint m_nLastInstance = 0x4; // uint32_t
    public const nint m_BoundsWs = 0x8; // AABB_t
}

public static class EntityIOConnectionData_t {
    public const nint m_outputName = 0x0; // CUtlString
    public const nint m_targetType = 0x8; // uint32_t
    public const nint m_targetName = 0x10; // CUtlString
    public const nint m_inputName = 0x18; // CUtlString
    public const nint m_overrideParam = 0x20; // CUtlString
    public const nint m_flDelay = 0x28; // float
    public const nint m_nTimesToFire = 0x2C; // int32_t
}

public static class EntityKeyValueData_t {
    public const nint m_connections = 0x8; // CUtlVector<EntityIOConnectionData_t>
    public const nint m_keyValuesData = 0x20; // CUtlBinaryBlock
}

public static class ExtraVertexStreamOverride_t {
    public const nint m_nSubSceneObject = 0x4; // uint32_t
    public const nint m_nDrawCallIndex = 0x8; // uint32_t
    public const nint m_nAdditionalMeshDrawPrimitiveFlags = 0xC; // MeshDrawPrimitiveFlags_t
    public const nint m_extraBufferBinding = 0x10; // CRenderBufferBinding
}

public static class InfoOverlayData_t {
    public const nint m_transform = 0x0; // matrix3x4_t
    public const nint m_flWidth = 0x30; // float
    public const nint m_flHeight = 0x34; // float
    public const nint m_flDepth = 0x38; // float
    public const nint m_vUVStart = 0x3C; // Vector2D
    public const nint m_vUVEnd = 0x44; // Vector2D
    public const nint m_pMaterial = 0x50; // CStrongHandle<InfoForResourceTypeIMaterial2>
    public const nint m_nRenderOrder = 0x58; // int32_t
    public const nint m_vTintColor = 0x5C; // Vector4D
    public const nint m_nSequenceOverride = 0x6C; // int32_t
}

public static class MaterialOverride_t {
    public const nint m_nSubSceneObject = 0x4; // uint32_t
    public const nint m_nDrawCallIndex = 0x8; // uint32_t
    public const nint m_pMaterial = 0x10; // CStrongHandle<InfoForResourceTypeIMaterial2>
}

public static class NodeData_t {
    public const nint m_nParent = 0x0; // int32_t
    public const nint m_vOrigin = 0x4; // Vector
    public const nint m_vMinBounds = 0x10; // Vector
    public const nint m_vMaxBounds = 0x1C; // Vector
    public const nint m_flMinimumDistance = 0x28; // float
    public const nint m_ChildNodeIndices = 0x30; // CUtlVector<int32_t>
    public const nint m_worldNodePrefix = 0x48; // CUtlString
}

public static class PermEntityLumpData_t {
    public const nint m_name = 0x8; // CUtlString
    public const nint m_hammerUniqueId = 0x10; // CUtlString
    public const nint m_childLumps = 0x18; // CUtlVector<CStrongHandleCopyable<InfoForResourceTypeCEntityLump>>
    public const nint m_entityKeyValues = 0x30; // CUtlLeanVector<EntityKeyValueData_t>
}

public static class SceneObject_t {
    public const nint m_nObjectID = 0x0; // uint32_t
    public const nint m_vTransform = 0x4; // Vector4D[3]
    public const nint m_flFadeStartDistance = 0x34; // float
    public const nint m_flFadeEndDistance = 0x38; // float
    public const nint m_vTintColor = 0x3C; // Vector4D
    public const nint m_skin = 0x50; // CUtlString
    public const nint m_nObjectTypeFlags = 0x58; // ObjectTypeFlags_t
    public const nint m_vLightingOrigin = 0x5C; // Vector
    public const nint m_nOverlayRenderOrder = 0x68; // int16_t
    public const nint m_nLODOverride = 0x6A; // int16_t
    public const nint m_nCubeMapPrecomputedHandshake = 0x6C; // int32_t
    public const nint m_nLightProbeVolumePrecomputedHandshake = 0x70; // int32_t
    public const nint m_renderableModel = 0x78; // CStrongHandle<InfoForResourceTypeCModel>
    public const nint m_renderable = 0x80; // CStrongHandle<InfoForResourceTypeCRenderMesh>
}

public static class VoxelVisBlockOffset_t {
    public const nint m_nOffset = 0x0; // uint32_t
    public const nint m_nElementCount = 0x4; // uint32_t
}

public static class WorldBuilderParams_t {
    public const nint m_flMinDrawVolumeSize = 0x0; // float
    public const nint m_bBuildBakedLighting = 0x4; // bool
    public const nint m_vLightmapUvScale = 0x8; // Vector2D
    public const nint m_nCompileTimestamp = 0x10; // uint64_t
    public const nint m_nCompileFingerprint = 0x18; // uint64_t
}

public static class WorldNodeOnDiskBufferData_t {
    public const nint m_nElementCount = 0x0; // int32_t
    public const nint m_nElementSizeInBytes = 0x4; // int32_t
    public const nint m_inputLayoutFields = 0x8; // CUtlVector<RenderInputLayoutField_t>
    public const nint m_pData = 0x20; // CUtlVector<uint8_t>
}

public static class WorldNode_t {
    public const nint m_sceneObjects = 0x0; // CUtlVector<SceneObject_t>
    public const nint m_infoOverlays = 0x18; // CUtlVector<InfoOverlayData_t>
    public const nint m_visClusterMembership = 0x30; // CUtlVector<uint16_t>
    public const nint m_aggregateSceneObjects = 0x48; // CUtlVector<AggregateSceneObject_t>
    public const nint m_clutterSceneObjects = 0x60; // CUtlVector<ClutterSceneObject_t>
    public const nint m_extraVertexStreamOverrides = 0x78; // CUtlVector<ExtraVertexStreamOverride_t>
    public const nint m_materialOverrides = 0x90; // CUtlVector<MaterialOverride_t>
    public const nint m_extraVertexStreams = 0xA8; // CUtlVector<WorldNodeOnDiskBufferData_t>
    public const nint m_layerNames = 0xC0; // CUtlVector<CUtlString>
    public const nint m_sceneObjectLayerIndices = 0xD8; // CUtlVector<uint8_t>
    public const nint m_overlayLayerIndices = 0xF0; // CUtlVector<uint8_t>
    public const nint m_grassFileName = 0x108; // CUtlString
    public const nint m_nodeLightingInfo = 0x110; // BakedLightingInfo_t
}

public static class World_t {
    public const nint m_builderParams = 0x0; // WorldBuilderParams_t
    public const nint m_worldNodes = 0x20; // CUtlVector<NodeData_t>
    public const nint m_worldLightingInfo = 0x38; // BakedLightingInfo_t
    public const nint m_entityLumps = 0x68; // CUtlVector<CStrongHandleCopyable<InfoForResourceTypeCEntityLump>>
}
```

`SDK/worldrenderer.dll.hpp`:

```hpp
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.591781 UTC
 */

#pragma once

#include <cstddef>

namespace AggregateLODSetup_t {
    constexpr std::ptrdiff_t m_vLODOrigin = 0x0; // Vector
    constexpr std::ptrdiff_t m_fMaxObjectScale = 0xC; // float
    constexpr std::ptrdiff_t m_fSwitchDistances = 0x10; // CUtlVectorFixedGrowable<float>
}

namespace AggregateMeshInfo_t {
    constexpr std::ptrdiff_t m_nVisClusterMemberOffset = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_nVisClusterMemberCount = 0x4; // uint8_t
    constexpr std::ptrdiff_t m_bHasTransform = 0x5; // bool
    constexpr std::ptrdiff_t m_nDrawCallIndex = 0x6; // int16_t
    constexpr std::ptrdiff_t m_nLODSetupIndex = 0x8; // int16_t
    constexpr std::ptrdiff_t m_nLODGroupMask = 0xA; // uint8_t
    constexpr std::ptrdiff_t m_vTintColor = 0xB; // Color
    constexpr std::ptrdiff_t m_objectFlags = 0x10; // ObjectTypeFlags_t
    constexpr std::ptrdiff_t m_nLightProbeVolumePrecomputedHandshake = 0x14; // int32_t
}

namespace AggregateSceneObject_t {
    constexpr std::ptrdiff_t m_allFlags = 0x0; // ObjectTypeFlags_t
    constexpr std::ptrdiff_t m_anyFlags = 0x4; // ObjectTypeFlags_t
    constexpr std::ptrdiff_t m_nLayer = 0x8; // int16_t
    constexpr std::ptrdiff_t m_aggregateMeshes = 0x10; // CUtlVector<AggregateMeshInfo_t>
    constexpr std::ptrdiff_t m_lodSetups = 0x28; // CUtlVector<AggregateLODSetup_t>
    constexpr std::ptrdiff_t m_visClusterMembership = 0x40; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_fragmentTransforms = 0x58; // CUtlVector<matrix3x4_t>
    constexpr std::ptrdiff_t m_renderableModel = 0x70; // CStrongHandle<InfoForResourceTypeCModel>
}

namespace BakedLightingInfo_t {
    constexpr std::ptrdiff_t m_nLightmapVersionNumber = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_nLightmapGameVersionNumber = 0x4; // uint32_t
    constexpr std::ptrdiff_t m_vLightmapUvScale = 0x8; // Vector2D
    constexpr std::ptrdiff_t m_bHasLightmaps = 0x10; // bool
    constexpr std::ptrdiff_t m_lightMaps = 0x18; // CUtlVector<CStrongHandle<InfoForResourceTypeCTextureBase>>
}

namespace BaseSceneObjectOverride_t {
    constexpr std::ptrdiff_t m_nSceneObjectIndex = 0x0; // uint32_t
}

namespace CEntityIdentity {
    constexpr std::ptrdiff_t m_nameStringableIndex = 0x14; // int32_t
    constexpr std::ptrdiff_t m_name = 0x18; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_designerName = 0x20; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flags = 0x30; // uint32_t
    constexpr std::ptrdiff_t m_worldGroupId = 0x38; // WorldGroupId_t
    constexpr std::ptrdiff_t m_fDataObjectTypes = 0x3C; // uint32_t
    constexpr std::ptrdiff_t m_PathIndex = 0x40; // ChangeAccessorFieldPathIndex_t
    constexpr std::ptrdiff_t m_pPrev = 0x58; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pNext = 0x60; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pPrevByClass = 0x68; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pNextByClass = 0x70; // CEntityIdentity*
}

namespace CEntityInstance {
    constexpr std::ptrdiff_t m_iszPrivateVScripts = 0x8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_pEntity = 0x10; // CEntityIdentity*
    constexpr std::ptrdiff_t m_CScriptComponent = 0x28; // CScriptComponent*
}

namespace CScriptComponent {
    constexpr std::ptrdiff_t m_scriptClassName = 0x30; // CUtlSymbolLarge
}

namespace CVoxelVisibility {
    constexpr std::ptrdiff_t m_nBaseClusterCount = 0x40; // uint32_t
    constexpr std::ptrdiff_t m_nPVSBytesPerCluster = 0x44; // uint32_t
    constexpr std::ptrdiff_t m_vMinBounds = 0x48; // Vector
    constexpr std::ptrdiff_t m_vMaxBounds = 0x54; // Vector
    constexpr std::ptrdiff_t m_flGridSize = 0x60; // float
    constexpr std::ptrdiff_t m_nSkyVisibilityCluster = 0x64; // uint32_t
    constexpr std::ptrdiff_t m_nSunVisibilityCluster = 0x68; // uint32_t
    constexpr std::ptrdiff_t m_NodeBlock = 0x6C; // VoxelVisBlockOffset_t
    constexpr std::ptrdiff_t m_RegionBlock = 0x74; // VoxelVisBlockOffset_t
    constexpr std::ptrdiff_t m_EnclosedClusterListBlock = 0x7C; // VoxelVisBlockOffset_t
    constexpr std::ptrdiff_t m_EnclosedClustersBlock = 0x84; // VoxelVisBlockOffset_t
    constexpr std::ptrdiff_t m_MasksBlock = 0x8C; // VoxelVisBlockOffset_t
    constexpr std::ptrdiff_t m_nVisBlocks = 0x94; // VoxelVisBlockOffset_t
}

namespace ClutterSceneObject_t {
    constexpr std::ptrdiff_t m_Bounds = 0x0; // AABB_t
    constexpr std::ptrdiff_t m_flags = 0x18; // ObjectTypeFlags_t
    constexpr std::ptrdiff_t m_nLayer = 0x1C; // int16_t
    constexpr std::ptrdiff_t m_instancePositions = 0x20; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_instanceScales = 0x50; // CUtlVector<float>
    constexpr std::ptrdiff_t m_instanceTintSrgb = 0x68; // CUtlVector<Color>
    constexpr std::ptrdiff_t m_tiles = 0x80; // CUtlVector<ClutterTile_t>
    constexpr std::ptrdiff_t m_renderableModel = 0x98; // CStrongHandle<InfoForResourceTypeCModel>
}

namespace ClutterTile_t {
    constexpr std::ptrdiff_t m_nFirstInstance = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_nLastInstance = 0x4; // uint32_t
    constexpr std::ptrdiff_t m_BoundsWs = 0x8; // AABB_t
}

namespace EntityIOConnectionData_t {
    constexpr std::ptrdiff_t m_outputName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_targetType = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_targetName = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_inputName = 0x18; // CUtlString
    constexpr std::ptrdiff_t m_overrideParam = 0x20; // CUtlString
    constexpr std::ptrdiff_t m_flDelay = 0x28; // float
    constexpr std::ptrdiff_t m_nTimesToFire = 0x2C; // int32_t
}

namespace EntityKeyValueData_t {
    constexpr std::ptrdiff_t m_connections = 0x8; // CUtlVector<EntityIOConnectionData_t>
    constexpr std::ptrdiff_t m_keyValuesData = 0x20; // CUtlBinaryBlock
}

namespace ExtraVertexStreamOverride_t {
    constexpr std::ptrdiff_t m_nSubSceneObject = 0x4; // uint32_t
    constexpr std::ptrdiff_t m_nDrawCallIndex = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_nAdditionalMeshDrawPrimitiveFlags = 0xC; // MeshDrawPrimitiveFlags_t
    constexpr std::ptrdiff_t m_extraBufferBinding = 0x10; // CRenderBufferBinding
}

namespace InfoOverlayData_t {
    constexpr std::ptrdiff_t m_transform = 0x0; // matrix3x4_t
    constexpr std::ptrdiff_t m_flWidth = 0x30; // float
    constexpr std::ptrdiff_t m_flHeight = 0x34; // float
    constexpr std::ptrdiff_t m_flDepth = 0x38; // float
    constexpr std::ptrdiff_t m_vUVStart = 0x3C; // Vector2D
    constexpr std::ptrdiff_t m_vUVEnd = 0x44; // Vector2D
    constexpr std::ptrdiff_t m_pMaterial = 0x50; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_nRenderOrder = 0x58; // int32_t
    constexpr std::ptrdiff_t m_vTintColor = 0x5C; // Vector4D
    constexpr std::ptrdiff_t m_nSequenceOverride = 0x6C; // int32_t
}

namespace MaterialOverride_t {
    constexpr std::ptrdiff_t m_nSubSceneObject = 0x4; // uint32_t
    constexpr std::ptrdiff_t m_nDrawCallIndex = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_pMaterial = 0x10; // CStrongHandle<InfoForResourceTypeIMaterial2>
}

namespace NodeData_t {
    constexpr std::ptrdiff_t m_nParent = 0x0; // int32_t
    constexpr std::ptrdiff_t m_vOrigin = 0x4; // Vector
    constexpr std::ptrdiff_t m_vMinBounds = 0x10; // Vector
    constexpr std::ptrdiff_t m_vMaxBounds = 0x1C; // Vector
    constexpr std::ptrdiff_t m_flMinimumDistance = 0x28; // float
    constexpr std::ptrdiff_t m_ChildNodeIndices = 0x30; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_worldNodePrefix = 0x48; // CUtlString
}

namespace PermEntityLumpData_t {
    constexpr std::ptrdiff_t m_name = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_hammerUniqueId = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_childLumps = 0x18; // CUtlVector<CStrongHandleCopyable<InfoForResourceTypeCEntityLump>>
    constexpr std::ptrdiff_t m_entityKeyValues = 0x30; // CUtlLeanVector<EntityKeyValueData_t>
}

namespace SceneObject_t {
    constexpr std::ptrdiff_t m_nObjectID = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_vTransform = 0x4; // Vector4D[3]
    constexpr std::ptrdiff_t m_flFadeStartDistance = 0x34; // float
    constexpr std::ptrdiff_t m_flFadeEndDistance = 0x38; // float
    constexpr std::ptrdiff_t m_vTintColor = 0x3C; // Vector4D
    constexpr std::ptrdiff_t m_skin = 0x50; // CUtlString
    constexpr std::ptrdiff_t m_nObjectTypeFlags = 0x58; // ObjectTypeFlags_t
    constexpr std::ptrdiff_t m_vLightingOrigin = 0x5C; // Vector
    constexpr std::ptrdiff_t m_nOverlayRenderOrder = 0x68; // int16_t
    constexpr std::ptrdiff_t m_nLODOverride = 0x6A; // int16_t
    constexpr std::ptrdiff_t m_nCubeMapPrecomputedHandshake = 0x6C; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeVolumePrecomputedHandshake = 0x70; // int32_t
    constexpr std::ptrdiff_t m_renderableModel = 0x78; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_renderable = 0x80; // CStrongHandle<InfoForResourceTypeCRenderMesh>
}

namespace VoxelVisBlockOffset_t {
    constexpr std::ptrdiff_t m_nOffset = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_nElementCount = 0x4; // uint32_t
}

namespace WorldBuilderParams_t {
    constexpr std::ptrdiff_t m_flMinDrawVolumeSize = 0x0; // float
    constexpr std::ptrdiff_t m_bBuildBakedLighting = 0x4; // bool
    constexpr std::ptrdiff_t m_vLightmapUvScale = 0x8; // Vector2D
    constexpr std::ptrdiff_t m_nCompileTimestamp = 0x10; // uint64_t
    constexpr std::ptrdiff_t m_nCompileFingerprint = 0x18; // uint64_t
}

namespace WorldNodeOnDiskBufferData_t {
    constexpr std::ptrdiff_t m_nElementCount = 0x0; // int32_t
    constexpr std::ptrdiff_t m_nElementSizeInBytes = 0x4; // int32_t
    constexpr std::ptrdiff_t m_inputLayoutFields = 0x8; // CUtlVector<RenderInputLayoutField_t>
    constexpr std::ptrdiff_t m_pData = 0x20; // CUtlVector<uint8_t>
}

namespace WorldNode_t {
    constexpr std::ptrdiff_t m_sceneObjects = 0x0; // CUtlVector<SceneObject_t>
    constexpr std::ptrdiff_t m_infoOverlays = 0x18; // CUtlVector<InfoOverlayData_t>
    constexpr std::ptrdiff_t m_visClusterMembership = 0x30; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_aggregateSceneObjects = 0x48; // CUtlVector<AggregateSceneObject_t>
    constexpr std::ptrdiff_t m_clutterSceneObjects = 0x60; // CUtlVector<ClutterSceneObject_t>
    constexpr std::ptrdiff_t m_extraVertexStreamOverrides = 0x78; // CUtlVector<ExtraVertexStreamOverride_t>
    constexpr std::ptrdiff_t m_materialOverrides = 0x90; // CUtlVector<MaterialOverride_t>
    constexpr std::ptrdiff_t m_extraVertexStreams = 0xA8; // CUtlVector<WorldNodeOnDiskBufferData_t>
    constexpr std::ptrdiff_t m_layerNames = 0xC0; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_sceneObjectLayerIndices = 0xD8; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_overlayLayerIndices = 0xF0; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_grassFileName = 0x108; // CUtlString
    constexpr std::ptrdiff_t m_nodeLightingInfo = 0x110; // BakedLightingInfo_t
}

namespace World_t {
    constexpr std::ptrdiff_t m_builderParams = 0x0; // WorldBuilderParams_t
    constexpr std::ptrdiff_t m_worldNodes = 0x20; // CUtlVector<NodeData_t>
    constexpr std::ptrdiff_t m_worldLightingInfo = 0x38; // BakedLightingInfo_t
    constexpr std::ptrdiff_t m_entityLumps = 0x68; // CUtlVector<CStrongHandleCopyable<InfoForResourceTypeCEntityLump>>
}
```

`SDK/worldrenderer.dll.json`:

```json
{
  "AggregateLODSetup_t": {
    "m_fMaxObjectScale": 12,
    "m_fSwitchDistances": 16,
    "m_vLODOrigin": 0
  },
  "AggregateMeshInfo_t": {
    "m_bHasTransform": 5,
    "m_nDrawCallIndex": 6,
    "m_nLODGroupMask": 10,
    "m_nLODSetupIndex": 8,
    "m_nLightProbeVolumePrecomputedHandshake": 20,
    "m_nVisClusterMemberCount": 4,
    "m_nVisClusterMemberOffset": 0,
    "m_objectFlags": 16,
    "m_vTintColor": 11
  },
  "AggregateSceneObject_t": {
    "m_aggregateMeshes": 16,
    "m_allFlags": 0,
    "m_anyFlags": 4,
    "m_fragmentTransforms": 88,
    "m_lodSetups": 40,
    "m_nLayer": 8,
    "m_renderableModel": 112,
    "m_visClusterMembership": 64
  },
  "BakedLightingInfo_t": {
    "m_bHasLightmaps": 16,
    "m_lightMaps": 24,
    "m_nLightmapGameVersionNumber": 4,
    "m_nLightmapVersionNumber": 0,
    "m_vLightmapUvScale": 8
  },
  "BaseSceneObjectOverride_t": {
    "m_nSceneObjectIndex": 0
  },
  "CEntityIdentity": {
    "m_PathIndex": 64,
    "m_designerName": 32,
    "m_fDataObjectTypes": 60,
    "m_flags": 48,
    "m_name": 24,
    "m_nameStringableIndex": 20,
    "m_pNext": 96,
    "m_pNextByClass": 112,
    "m_pPrev": 88,
    "m_pPrevByClass": 104,
    "m_worldGroupId": 56
  },
  "CEntityInstance": {
    "m_CScriptComponent": 40,
    "m_iszPrivateVScripts": 8,
    "m_pEntity": 16
  },
  "CScriptComponent": {
    "m_scriptClassName": 48
  },
  "CVoxelVisibility": {
    "m_EnclosedClusterListBlock": 124,
    "m_EnclosedClustersBlock": 132,
    "m_MasksBlock": 140,
    "m_NodeBlock": 108,
    "m_RegionBlock": 116,
    "m_flGridSize": 96,
    "m_nBaseClusterCount": 64,
    "m_nPVSBytesPerCluster": 68,
    "m_nSkyVisibilityCluster": 100,
    "m_nSunVisibilityCluster": 104,
    "m_nVisBlocks": 148,
    "m_vMaxBounds": 84,
    "m_vMinBounds": 72
  },
  "ClutterSceneObject_t": {
    "m_Bounds": 0,
    "m_flags": 24,
    "m_instancePositions": 32,
    "m_instanceScales": 80,
    "m_instanceTintSrgb": 104,
    "m_nLayer": 28,
    "m_renderableModel": 152,
    "m_tiles": 128
  },
  "ClutterTile_t": {
    "m_BoundsWs": 8,
    "m_nFirstInstance": 0,
    "m_nLastInstance": 4
  },
  "EntityIOConnectionData_t": {
    "m_flDelay": 40,
    "m_inputName": 24,
    "m_nTimesToFire": 44,
    "m_outputName": 0,
    "m_overrideParam": 32,
    "m_targetName": 16,
    "m_targetType": 8
  },
  "EntityKeyValueData_t": {
    "m_connections": 8,
    "m_keyValuesData": 32
  },
  "ExtraVertexStreamOverride_t": {
    "m_extraBufferBinding": 16,
    "m_nAdditionalMeshDrawPrimitiveFlags": 12,
    "m_nDrawCallIndex": 8,
    "m_nSubSceneObject": 4
  },
  "InfoOverlayData_t": {
    "m_flDepth": 56,
    "m_flHeight": 52,
    "m_flWidth": 48,
    "m_nRenderOrder": 88,
    "m_nSequenceOverride": 108,
    "m_pMaterial": 80,
    "m_transform": 0,
    "m_vTintColor": 92,
    "m_vUVEnd": 68,
    "m_vUVStart": 60
  },
  "MaterialOverride_t": {
    "m_nDrawCallIndex": 8,
    "m_nSubSceneObject": 4,
    "m_pMaterial": 16
  },
  "NodeData_t": {
    "m_ChildNodeIndices": 48,
    "m_flMinimumDistance": 40,
    "m_nParent": 0,
    "m_vMaxBounds": 28,
    "m_vMinBounds": 16,
    "m_vOrigin": 4,
    "m_worldNodePrefix": 72
  },
  "PermEntityLumpData_t": {
    "m_childLumps": 24,
    "m_entityKeyValues": 48,
    "m_hammerUniqueId": 16,
    "m_name": 8
  },
  "SceneObject_t": {
    "m_flFadeEndDistance": 56,
    "m_flFadeStartDistance": 52,
    "m_nCubeMapPrecomputedHandshake": 108,
    "m_nLODOverride": 106,
    "m_nLightProbeVolumePrecomputedHandshake": 112,
    "m_nObjectID": 0,
    "m_nObjectTypeFlags": 88,
    "m_nOverlayRenderOrder": 104,
    "m_renderable": 128,
    "m_renderableModel": 120,
    "m_skin": 80,
    "m_vLightingOrigin": 92,
    "m_vTintColor": 60,
    "m_vTransform": 4
  },
  "VoxelVisBlockOffset_t": {
    "m_nElementCount": 4,
    "m_nOffset": 0
  },
  "WorldBuilderParams_t": {
    "m_bBuildBakedLighting": 4,
    "m_flMinDrawVolumeSize": 0,
    "m_nCompileFingerprint": 24,
    "m_nCompileTimestamp": 16,
    "m_vLightmapUvScale": 8
  },
  "WorldNodeOnDiskBufferData_t": {
    "m_inputLayoutFields": 8,
    "m_nElementCount": 0,
    "m_nElementSizeInBytes": 4,
    "m_pData": 32
  },
  "WorldNode_t": {
    "m_aggregateSceneObjects": 72,
    "m_clutterSceneObjects": 96,
    "m_extraVertexStreamOverrides": 120,
    "m_extraVertexStreams": 168,
    "m_grassFileName": 264,
    "m_infoOverlays": 24,
    "m_layerNames": 192,
    "m_materialOverrides": 144,
    "m_nodeLightingInfo": 272,
    "m_overlayLayerIndices": 240,
    "m_sceneObjectLayerIndices": 216,
    "m_sceneObjects": 0,
    "m_visClusterMembership": 48
  },
  "World_t": {
    "m_builderParams": 0,
    "m_entityLumps": 104,
    "m_worldLightingInfo": 56,
    "m_worldNodes": 32
  }
}
```

`SDK/worldrenderer.dll.py`:

```py
'''
https://github.com/a2x/cs2-dumper
2023-11-23 10:28:25.601026400 UTC
'''

class AggregateLODSetup_t:
    m_vLODOrigin = 0x0 # Vector
    m_fMaxObjectScale = 0xC # float
    m_fSwitchDistances = 0x10 # CUtlVectorFixedGrowable<float>

class AggregateMeshInfo_t:
    m_nVisClusterMemberOffset = 0x0 # uint32_t
    m_nVisClusterMemberCount = 0x4 # uint8_t
    m_bHasTransform = 0x5 # bool
    m_nDrawCallIndex = 0x6 # int16_t
    m_nLODSetupIndex = 0x8 # int16_t
    m_nLODGroupMask = 0xA # uint8_t
    m_vTintColor = 0xB # Color
    m_objectFlags = 0x10 # ObjectTypeFlags_t
    m_nLightProbeVolumePrecomputedHandshake = 0x14 # int32_t

class AggregateSceneObject_t:
    m_allFlags = 0x0 # ObjectTypeFlags_t
    m_anyFlags = 0x4 # ObjectTypeFlags_t
    m_nLayer = 0x8 # int16_t
    m_aggregateMeshes = 0x10 # CUtlVector<AggregateMeshInfo_t>
    m_lodSetups = 0x28 # CUtlVector<AggregateLODSetup_t>
    m_visClusterMembership = 0x40 # CUtlVector<uint16_t>
    m_fragmentTransforms = 0x58 # CUtlVector<matrix3x4_t>
    m_renderableModel = 0x70 # CStrongHandle<InfoForResourceTypeCModel>

class BakedLightingInfo_t:
    m_nLightmapVersionNumber = 0x0 # uint32_t
    m_nLightmapGameVersionNumber = 0x4 # uint32_t
    m_vLightmapUvScale = 0x8 # Vector2D
    m_bHasLightmaps = 0x10 # bool
    m_lightMaps = 0x18 # CUtlVector<CStrongHandle<InfoForResourceTypeCTextureBase>>

class BaseSceneObjectOverride_t:
    m_nSceneObjectIndex = 0x0 # uint32_t

class CEntityIdentity:
    m_nameStringableIndex = 0x14 # int32_t
    m_name = 0x18 # CUtlSymbolLarge
    m_designerName = 0x20 # CUtlSymbolLarge
    m_flags = 0x30 # uint32_t
    m_worldGroupId = 0x38 # WorldGroupId_t
    m_fDataObjectTypes = 0x3C # uint32_t
    m_PathIndex = 0x40 # ChangeAccessorFieldPathIndex_t
    m_pPrev = 0x58 # CEntityIdentity*
    m_pNext = 0x60 # CEntityIdentity*
    m_pPrevByClass = 0x68 # CEntityIdentity*
    m_pNextByClass = 0x70 # CEntityIdentity*

class CEntityInstance:
    m_iszPrivateVScripts = 0x8 # CUtlSymbolLarge
    m_pEntity = 0x10 # CEntityIdentity*
    m_CScriptComponent = 0x28 # CScriptComponent*

class CScriptComponent:
    m_scriptClassName = 0x30 # CUtlSymbolLarge

class CVoxelVisibility:
    m_nBaseClusterCount = 0x40 # uint32_t
    m_nPVSBytesPerCluster = 0x44 # uint32_t
    m_vMinBounds = 0x48 # Vector
    m_vMaxBounds = 0x54 # Vector
    m_flGridSize = 0x60 # float
    m_nSkyVisibilityCluster = 0x64 # uint32_t
    m_nSunVisibilityCluster = 0x68 # uint32_t
    m_NodeBlock = 0x6C # VoxelVisBlockOffset_t
    m_RegionBlock = 0x74 # VoxelVisBlockOffset_t
    m_EnclosedClusterListBlock = 0x7C # VoxelVisBlockOffset_t
    m_EnclosedClustersBlock = 0x84 # VoxelVisBlockOffset_t
    m_MasksBlock = 0x8C # VoxelVisBlockOffset_t
    m_nVisBlocks = 0x94 # VoxelVisBlockOffset_t

class ClutterSceneObject_t:
    m_Bounds = 0x0 # AABB_t
    m_flags = 0x18 # ObjectTypeFlags_t
    m_nLayer = 0x1C # int16_t
    m_instancePositions = 0x20 # CUtlVector<Vector>
    m_instanceScales = 0x50 # CUtlVector<float>
    m_instanceTintSrgb = 0x68 # CUtlVector<Color>
    m_tiles = 0x80 # CUtlVector<ClutterTile_t>
    m_renderableModel = 0x98 # CStrongHandle<InfoForResourceTypeCModel>

class ClutterTile_t:
    m_nFirstInstance = 0x0 # uint32_t
    m_nLastInstance = 0x4 # uint32_t
    m_BoundsWs = 0x8 # AABB_t

class EntityIOConnectionData_t:
    m_outputName = 0x0 # CUtlString
    m_targetType = 0x8 # uint32_t
    m_targetName = 0x10 # CUtlString
    m_inputName = 0x18 # CUtlString
    m_overrideParam = 0x20 # CUtlString
    m_flDelay = 0x28 # float
    m_nTimesToFire = 0x2C # int32_t

class EntityKeyValueData_t:
    m_connections = 0x8 # CUtlVector<EntityIOConnectionData_t>
    m_keyValuesData = 0x20 # CUtlBinaryBlock

class ExtraVertexStreamOverride_t:
    m_nSubSceneObject = 0x4 # uint32_t
    m_nDrawCallIndex = 0x8 # uint32_t
    m_nAdditionalMeshDrawPrimitiveFlags = 0xC # MeshDrawPrimitiveFlags_t
    m_extraBufferBinding = 0x10 # CRenderBufferBinding

class InfoOverlayData_t:
    m_transform = 0x0 # matrix3x4_t
    m_flWidth = 0x30 # float
    m_flHeight = 0x34 # float
    m_flDepth = 0x38 # float
    m_vUVStart = 0x3C # Vector2D
    m_vUVEnd = 0x44 # Vector2D
    m_pMaterial = 0x50 # CStrongHandle<InfoForResourceTypeIMaterial2>
    m_nRenderOrder = 0x58 # int32_t
    m_vTintColor = 0x5C # Vector4D
    m_nSequenceOverride = 0x6C # int32_t

class MaterialOverride_t:
    m_nSubSceneObject = 0x4 # uint32_t
    m_nDrawCallIndex = 0x8 # uint32_t
    m_pMaterial = 0x10 # CStrongHandle<InfoForResourceTypeIMaterial2>

class NodeData_t:
    m_nParent = 0x0 # int32_t
    m_vOrigin = 0x4 # Vector
    m_vMinBounds = 0x10 # Vector
    m_vMaxBounds = 0x1C # Vector
    m_flMinimumDistance = 0x28 # float
    m_ChildNodeIndices = 0x30 # CUtlVector<int32_t>
    m_worldNodePrefix = 0x48 # CUtlString

class PermEntityLumpData_t:
    m_name = 0x8 # CUtlString
    m_hammerUniqueId = 0x10 # CUtlString
    m_childLumps = 0x18 # CUtlVector<CStrongHandleCopyable<InfoForResourceTypeCEntityLump>>
    m_entityKeyValues = 0x30 # CUtlLeanVector<EntityKeyValueData_t>

class SceneObject_t:
    m_nObjectID = 0x0 # uint32_t
    m_vTransform = 0x4 # Vector4D[3]
    m_flFadeStartDistance = 0x34 # float
    m_flFadeEndDistance = 0x38 # float
    m_vTintColor = 0x3C # Vector4D
    m_skin = 0x50 # CUtlString
    m_nObjectTypeFlags = 0x58 # ObjectTypeFlags_t
    m_vLightingOrigin = 0x5C # Vector
    m_nOverlayRenderOrder = 0x68 # int16_t
    m_nLODOverride = 0x6A # int16_t
    m_nCubeMapPrecomputedHandshake = 0x6C # int32_t
    m_nLightProbeVolumePrecomputedHandshake = 0x70 # int32_t
    m_renderableModel = 0x78 # CStrongHandle<InfoForResourceTypeCModel>
    m_renderable = 0x80 # CStrongHandle<InfoForResourceTypeCRenderMesh>

class VoxelVisBlockOffset_t:
    m_nOffset = 0x0 # uint32_t
    m_nElementCount = 0x4 # uint32_t

class WorldBuilderParams_t:
    m_flMinDrawVolumeSize = 0x0 # float
    m_bBuildBakedLighting = 0x4 # bool
    m_vLightmapUvScale = 0x8 # Vector2D
    m_nCompileTimestamp = 0x10 # uint64_t
    m_nCompileFingerprint = 0x18 # uint64_t

class WorldNodeOnDiskBufferData_t:
    m_nElementCount = 0x0 # int32_t
    m_nElementSizeInBytes = 0x4 # int32_t
    m_inputLayoutFields = 0x8 # CUtlVector<RenderInputLayoutField_t>
    m_pData = 0x20 # CUtlVector<uint8_t>

class WorldNode_t:
    m_sceneObjects = 0x0 # CUtlVector<SceneObject_t>
    m_infoOverlays = 0x18 # CUtlVector<InfoOverlayData_t>
    m_visClusterMembership = 0x30 # CUtlVector<uint16_t>
    m_aggregateSceneObjects = 0x48 # CUtlVector<AggregateSceneObject_t>
    m_clutterSceneObjects = 0x60 # CUtlVector<ClutterSceneObject_t>
    m_extraVertexStreamOverrides = 0x78 # CUtlVector<ExtraVertexStreamOverride_t>
    m_materialOverrides = 0x90 # CUtlVector<MaterialOverride_t>
    m_extraVertexStreams = 0xA8 # CUtlVector<WorldNodeOnDiskBufferData_t>
    m_layerNames = 0xC0 # CUtlVector<CUtlString>
    m_sceneObjectLayerIndices = 0xD8 # CUtlVector<uint8_t>
    m_overlayLayerIndices = 0xF0 # CUtlVector<uint8_t>
    m_grassFileName = 0x108 # CUtlString
    m_nodeLightingInfo = 0x110 # BakedLightingInfo_t

class World_t:
    m_builderParams = 0x0 # WorldBuilderParams_t
    m_worldNodes = 0x20 # CUtlVector<NodeData_t>
    m_worldLightingInfo = 0x38 # BakedLightingInfo_t
    m_entityLumps = 0x68 # CUtlVector<CStrongHandleCopyable<InfoForResourceTypeCEntityLump>>

```

`SDK/worldrenderer.dll.rs`:

```rs
/*
 * https://github.com/a2x/cs2-dumper
 * 2023-11-23 10:28:25.605484100 UTC
 */

#![allow(non_snake_case, non_upper_case_globals)]

pub mod AggregateLODSetup_t {
    pub const m_vLODOrigin: usize = 0x0; // Vector
    pub const m_fMaxObjectScale: usize = 0xC; // float
    pub const m_fSwitchDistances: usize = 0x10; // CUtlVectorFixedGrowable<float>
}

pub mod AggregateMeshInfo_t {
    pub const m_nVisClusterMemberOffset: usize = 0x0; // uint32_t
    pub const m_nVisClusterMemberCount: usize = 0x4; // uint8_t
    pub const m_bHasTransform: usize = 0x5; // bool
    pub const m_nDrawCallIndex: usize = 0x6; // int16_t
    pub const m_nLODSetupIndex: usize = 0x8; // int16_t
    pub const m_nLODGroupMask: usize = 0xA; // uint8_t
    pub const m_vTintColor: usize = 0xB; // Color
    pub const m_objectFlags: usize = 0x10; // ObjectTypeFlags_t
    pub const m_nLightProbeVolumePrecomputedHandshake: usize = 0x14; // int32_t
}

pub mod AggregateSceneObject_t {
    pub const m_allFlags: usize = 0x0; // ObjectTypeFlags_t
    pub const m_anyFlags: usize = 0x4; // ObjectTypeFlags_t
    pub const m_nLayer: usize = 0x8; // int16_t
    pub const m_aggregateMeshes: usize = 0x10; // CUtlVector<AggregateMeshInfo_t>
    pub const m_lodSetups: usize = 0x28; // CUtlVector<AggregateLODSetup_t>
    pub const m_visClusterMembership: usize = 0x40; // CUtlVector<uint16_t>
    pub const m_fragmentTransforms: usize = 0x58; // CUtlVector<matrix3x4_t>
    pub const m_renderableModel: usize = 0x70; // CStrongHandle<InfoForResourceTypeCModel>
}

pub mod BakedLightingInfo_t {
    pub const m_nLightmapVersionNumber: usize = 0x0; // uint32_t
    pub const m_nLightmapGameVersionNumber: usize = 0x4; // uint32_t
    pub const m_vLightmapUvScale: usize = 0x8; // Vector2D
    pub const m_bHasLightmaps: usize = 0x10; // bool
    pub const m_lightMaps: usize = 0x18; // CUtlVector<CStrongHandle<InfoForResourceTypeCTextureBase>>
}

pub mod BaseSceneObjectOverride_t {
    pub const m_nSceneObjectIndex: usize = 0x0; // uint32_t
}

pub mod CEntityIdentity {
    pub const m_nameStringableIndex: usize = 0x14; // int32_t
    pub const m_name: usize = 0x18; // CUtlSymbolLarge
    pub const m_designerName: usize = 0x20; // CUtlSymbolLarge
    pub const m_flags: usize = 0x30; // uint32_t
    pub const m_worldGroupId: usize = 0x38; // WorldGroupId_t
    pub const m_fDataObjectTypes: usize = 0x3C; // uint32_t
    pub const m_PathIndex: usize = 0x40; // ChangeAccessorFieldPathIndex_t
    pub const m_pPrev: usize = 0x58; // CEntityIdentity*
    pub const m_pNext: usize = 0x60; // CEntityIdentity*
    pub const m_pPrevByClass: usize = 0x68; // CEntityIdentity*
    pub const m_pNextByClass: usize = 0x70; // CEntityIdentity*
}

pub mod CEntityInstance {
    pub const m_iszPrivateVScripts: usize = 0x8; // CUtlSymbolLarge
    pub const m_pEntity: usize = 0x10; // CEntityIdentity*
    pub const m_CScriptComponent: usize = 0x28; // CScriptComponent*
}

pub mod CScriptComponent {
    pub const m_scriptClassName: usize = 0x30; // CUtlSymbolLarge
}

pub mod CVoxelVisibility {
    pub const m_nBaseClusterCount: usize = 0x40; // uint32_t
    pub const m_nPVSBytesPerCluster: usize = 0x44; // uint32_t
    pub const m_vMinBounds: usize = 0x48; // Vector
    pub const m_vMaxBounds: usize = 0x54; // Vector
    pub const m_flGridSize: usize = 0x60; // float
    pub const m_nSkyVisibilityCluster: usize = 0x64; // uint32_t
    pub const m_nSunVisibilityCluster: usize = 0x68; // uint32_t
    pub const m_NodeBlock: usize = 0x6C; // VoxelVisBlockOffset_t
    pub const m_RegionBlock: usize = 0x74; // VoxelVisBlockOffset_t
    pub const m_EnclosedClusterListBlock: usize = 0x7C; // VoxelVisBlockOffset_t
    pub const m_EnclosedClustersBlock: usize = 0x84; // VoxelVisBlockOffset_t
    pub const m_MasksBlock: usize = 0x8C; // VoxelVisBlockOffset_t
    pub const m_nVisBlocks: usize = 0x94; // VoxelVisBlockOffset_t
}

pub mod ClutterSceneObject_t {
    pub const m_Bounds: usize = 0x0; // AABB_t
    pub const m_flags: usize = 0x18; // ObjectTypeFlags_t
    pub const m_nLayer: usize = 0x1C; // int16_t
    pub const m_instancePositions: usize = 0x20; // CUtlVector<Vector>
    pub const m_instanceScales: usize = 0x50; // CUtlVector<float>
    pub const m_instanceTintSrgb: usize = 0x68; // CUtlVector<Color>
    pub const m_tiles: usize = 0x80; // CUtlVector<ClutterTile_t>
    pub const m_renderableModel: usize = 0x98; // CStrongHandle<InfoForResourceTypeCModel>
}

pub mod ClutterTile_t {
    pub const m_nFirstInstance: usize = 0x0; // uint32_t
    pub const m_nLastInstance: usize = 0x4; // uint32_t
    pub const m_BoundsWs: usize = 0x8; // AABB_t
}

pub mod EntityIOConnectionData_t {
    pub const m_outputName: usize = 0x0; // CUtlString
    pub const m_targetType: usize = 0x8; // uint32_t
    pub const m_targetName: usize = 0x10; // CUtlString
    pub const m_inputName: usize = 0x18; // CUtlString
    pub const m_overrideParam: usize = 0x20; // CUtlString
    pub const m_flDelay: usize = 0x28; // float
    pub const m_nTimesToFire: usize = 0x2C; // int32_t
}

pub mod EntityKeyValueData_t {
    pub const m_connections: usize = 0x8; // CUtlVector<EntityIOConnectionData_t>
    pub const m_keyValuesData: usize = 0x20; // CUtlBinaryBlock
}

pub mod ExtraVertexStreamOverride_t {
    pub const m_nSubSceneObject: usize = 0x4; // uint32_t
    pub const m_nDrawCallIndex: usize = 0x8; // uint32_t
    pub const m_nAdditionalMeshDrawPrimitiveFlags: usize = 0xC; // MeshDrawPrimitiveFlags_t
    pub const m_extraBufferBinding: usize = 0x10; // CRenderBufferBinding
}

pub mod InfoOverlayData_t {
    pub const m_transform: usize = 0x0; // matrix3x4_t
    pub const m_flWidth: usize = 0x30; // float
    pub const m_flHeight: usize = 0x34; // float
    pub const m_flDepth: usize = 0x38; // float
    pub const m_vUVStart: usize = 0x3C; // Vector2D
    pub const m_vUVEnd: usize = 0x44; // Vector2D
    pub const m_pMaterial: usize = 0x50; // CStrongHandle<InfoForResourceTypeIMaterial2>
    pub const m_nRenderOrder: usize = 0x58; // int32_t
    pub const m_vTintColor: usize = 0x5C; // Vector4D
    pub const m_nSequenceOverride: usize = 0x6C; // int32_t
}

pub mod MaterialOverride_t {
    pub const m_nSubSceneObject: usize = 0x4; // uint32_t
    pub const m_nDrawCallIndex: usize = 0x8; // uint32_t
    pub const m_pMaterial: usize = 0x10; // CStrongHandle<InfoForResourceTypeIMaterial2>
}

pub mod NodeData_t {
    pub const m_nParent: usize = 0x0; // int32_t
    pub const m_vOrigin: usize = 0x4; // Vector
    pub const m_vMinBounds: usize = 0x10; // Vector
    pub const m_vMaxBounds: usize = 0x1C; // Vector
    pub const m_flMinimumDistance: usize = 0x28; // float
    pub const m_ChildNodeIndices: usize = 0x30; // CUtlVector<int32_t>
    pub const m_worldNodePrefix: usize = 0x48; // CUtlString
}

pub mod PermEntityLumpData_t {
    pub const m_name: usize = 0x8; // CUtlString
    pub const m_hammerUniqueId: usize = 0x10; // CUtlString
    pub const m_childLumps: usize = 0x18; // CUtlVector<CStrongHandleCopyable<InfoForResourceTypeCEntityLump>>
    pub const m_entityKeyValues: usize = 0x30; // CUtlLeanVector<EntityKeyValueData_t>
}

pub mod SceneObject_t {
    pub const m_nObjectID: usize = 0x0; // uint32_t
    pub const m_vTransform: usize = 0x4; // Vector4D[3]
    pub const m_flFadeStartDistance: usize = 0x34; // float
    pub const m_flFadeEndDistance: usize = 0x38; // float
    pub const m_vTintColor: usize = 0x3C; // Vector4D
    pub const m_skin: usize = 0x50; // CUtlString
    pub const m_nObjectTypeFlags: usize = 0x58; // ObjectTypeFlags_t
    pub const m_vLightingOrigin: usize = 0x5C; // Vector
    pub const m_nOverlayRenderOrder: usize = 0x68; // int16_t
    pub const m_nLODOverride: usize = 0x6A; // int16_t
    pub const m_nCubeMapPrecomputedHandshake: usize = 0x6C; // int32_t
    pub const m_nLightProbeVolumePrecomputedHandshake: usize = 0x70; // int32_t
    pub const m_renderableModel: usize = 0x78; // CStrongHandle<InfoForResourceTypeCModel>
    pub const m_renderable: usize = 0x80; // CStrongHandle<InfoForResourceTypeCRenderMesh>
}

pub mod VoxelVisBlockOffset_t {
    pub const m_nOffset: usize = 0x0; // uint32_t
    pub const m_nElementCount: usize = 0x4; // uint32_t
}

pub mod WorldBuilderParams_t {
    pub const m_flMinDrawVolumeSize: usize = 0x0; // float
    pub const m_bBuildBakedLighting: usize = 0x4; // bool
    pub const m_vLightmapUvScale: usize = 0x8; // Vector2D
    pub const m_nCompileTimestamp: usize = 0x10; // uint64_t
    pub const m_nCompileFingerprint: usize = 0x18; // uint64_t
}

pub mod WorldNodeOnDiskBufferData_t {
    pub const m_nElementCount: usize = 0x0; // int32_t
    pub const m_nElementSizeInBytes: usize = 0x4; // int32_t
    pub const m_inputLayoutFields: usize = 0x8; // CUtlVector<RenderInputLayoutField_t>
    pub const m_pData: usize = 0x20; // CUtlVector<uint8_t>
}

pub mod WorldNode_t {
    pub const m_sceneObjects: usize = 0x0; // CUtlVector<SceneObject_t>
    pub const m_infoOverlays: usize = 0x18; // CUtlVector<InfoOverlayData_t>
    pub const m_visClusterMembership: usize = 0x30; // CUtlVector<uint16_t>
    pub const m_aggregateSceneObjects: usize = 0x48; // CUtlVector<AggregateSceneObject_t>
    pub const m_clutterSceneObjects: usize = 0x60; // CUtlVector<ClutterSceneObject_t>
    pub const m_extraVertexStreamOverrides: usize = 0x78; // CUtlVector<ExtraVertexStreamOverride_t>
    pub const m_materialOverrides: usize = 0x90; // CUtlVector<MaterialOverride_t>
    pub const m_extraVertexStreams: usize = 0xA8; // CUtlVector<WorldNodeOnDiskBufferData_t>
    pub const m_layerNames: usize = 0xC0; // CUtlVector<CUtlString>
    pub const m_sceneObjectLayerIndices: usize = 0xD8; // CUtlVector<uint8_t>
    pub const m_overlayLayerIndices: usize = 0xF0; // CUtlVector<uint8_t>
    pub const m_grassFileName: usize = 0x108; // CUtlString
    pub const m_nodeLightingInfo: usize = 0x110; // BakedLightingInfo_t
}

pub mod World_t {
    pub const m_builderParams: usize = 0x0; // WorldBuilderParams_t
    pub const m_worldNodes: usize = 0x20; // CUtlVector<NodeData_t>
    pub const m_worldLightingInfo: usize = 0x38; // BakedLightingInfo_t
    pub const m_entityLumps: usize = 0x68; // CUtlVector<CStrongHandleCopyable<InfoForResourceTypeCEntityLump>>
}
```