Project Path: arc_irisengine_iris_6v8af3eg

Source Tree:

```txt
arc_irisengine_iris_6v8af3eg
├── CMakeLists.txt
├── LICENSE
├── README.md
├── cmake
│   └── iris-config.cmake.in
├── include
│   └── iris
│       ├── concepts
│       │   └── is_pointer.h
│       ├── core
│       │   ├── auto_release.h
│       │   ├── camera.h
│       │   ├── camera_type.h
│       │   ├── colour.h
│       │   ├── context.h
│       │   ├── data_buffer.h
│       │   ├── default_resource_manager.h
│       │   ├── error_handling.h
│       │   ├── exception.h
│       │   ├── ios
│       │   │   ├── ios_resource_manager.h
│       │   │   └── utility.h
│       │   ├── looper.h
│       │   ├── macos
│       │   │   ├── macos_ios_utility.h
│       │   │   └── utility.h
│       │   ├── matrix4.h
│       │   ├── object_pool.h
│       │   ├── profiler.h
│       │   ├── profiler_analyser.h
│       │   ├── quaternion.h
│       │   ├── random.h
│       │   ├── resource_manager.h
│       │   ├── semaphore.h
│       │   ├── start.h
│       │   ├── static_buffer.h
│       │   ├── string_hash.h
│       │   ├── thread.h
│       │   ├── transform.h
│       │   ├── utils.h
│       │   └── vector3.h
│       ├── events
│       │   ├── event.h
│       │   ├── event_type.h
│       │   ├── keyboard_event.h
│       │   ├── mouse_button_event.h
│       │   ├── mouse_event.h
│       │   ├── quit_event.h
│       │   ├── scroll_wheel_event.h
│       │   └── touch_event.h
│       ├── graphics
│       │   ├── animation
│       │   │   ├── animation.h
│       │   │   ├── animation_controller.h
│       │   │   ├── animation_layer.h
│       │   │   ├── animation_state.h
│       │   │   ├── animation_transition.h
│       │   │   ├── bone_query.h
│       │   │   ├── cached_bone_query.h
│       │   │   └── utils.h
│       │   ├── bone.h
│       │   ├── constant_buffer_writer.h
│       │   ├── cube_map.h
│       │   ├── d3d12
│       │   │   ├── d3d12_buffer.h
│       │   │   ├── d3d12_constant_buffer.h
│       │   │   ├── d3d12_constant_buffer_pool.h
│       │   │   ├── d3d12_context.h
│       │   │   ├── d3d12_cpu_descriptor_handle_allocator.h
│       │   │   ├── d3d12_cube_map.h
│       │   │   ├── d3d12_descriptor_handle.h
│       │   │   ├── d3d12_descriptor_manager.h
│       │   │   ├── d3d12_gpu_descriptor_handle_allocator.h
│       │   │   ├── d3d12_material.h
│       │   │   ├── d3d12_material_manager.h
│       │   │   ├── d3d12_mesh.h
│       │   │   ├── d3d12_mesh_manager.h
│       │   │   ├── d3d12_render_target.h
│       │   │   ├── d3d12_render_target_manager.h
│       │   │   ├── d3d12_renderer.h
│       │   │   ├── d3d12_root_signature.h
│       │   │   ├── d3d12_sampler.h
│       │   │   ├── d3d12_structured_buffer.h
│       │   │   ├── d3d12_texture.h
│       │   │   └── d3d12_texture_manager.h
│       │   ├── default_shader_languages.h
│       │   ├── instanced_entity.h
│       │   ├── ios
│       │   │   ├── app_delegate.h
│       │   │   ├── ios_window.h
│       │   │   ├── ios_window_manager.h
│       │   │   ├── metal_view.h
│       │   │   └── metal_view_controller.h
│       │   ├── keyframe.h
│       │   ├── lights
│       │   │   ├── ambient_light.h
│       │   │   ├── directional_light.h
│       │   │   ├── light.h
│       │   │   ├── light_type.h
│       │   │   ├── lighting_rig.h
│       │   │   └── point_light.h
│       │   ├── linux
│       │   │   ├── linux_window.h
│       │   │   ├── linux_window_manager.h
│       │   │   └── scoped_error_handler.h
│       │   ├── macos
│       │   │   ├── macos_window.h
│       │   │   ├── macos_window_manager.h
│       │   │   ├── metal_app_delegate.h
│       │   │   ├── metal_view.h
│       │   │   ├── opengl_app_delegate.h
│       │   │   └── opengl_view.h
│       │   ├── material.h
│       │   ├── material_cache.h
│       │   ├── material_manager.h
│       │   ├── mesh.h
│       │   ├── mesh_loader.h
│       │   ├── mesh_manager.h
│       │   ├── metal
│       │   │   ├── metal_buffer.h
│       │   │   ├── metal_constant_buffer.h
│       │   │   ├── metal_cube_map.h
│       │   │   ├── metal_material.h
│       │   │   ├── metal_material_manager.h
│       │   │   ├── metal_mesh.h
│       │   │   ├── metal_mesh_manager.h
│       │   │   ├── metal_render_target.h
│       │   │   ├── metal_render_target_manager.h
│       │   │   ├── metal_renderer.h
│       │   │   ├── metal_sampler.h
│       │   │   ├── metal_texture.h
│       │   │   └── metal_texture_manager.h
│       │   ├── opengl
│       │   │   ├── opengl.h
│       │   │   ├── opengl_buffer.h
│       │   │   ├── opengl_cube_map.h
│       │   │   ├── opengl_defines.h
│       │   │   ├── opengl_frame_buffer.h
│       │   │   ├── opengl_material.h
│       │   │   ├── opengl_material_manager.h
│       │   │   ├── opengl_mesh.h
│       │   │   ├── opengl_mesh_manager.h
│       │   │   ├── opengl_render_target.h
│       │   │   ├── opengl_render_target_manager.h
│       │   │   ├── opengl_renderer.h
│       │   │   ├── opengl_sampler.h
│       │   │   ├── opengl_shader.h
│       │   │   ├── opengl_texture.h
│       │   │   ├── opengl_texture_manager.h
│       │   │   └── opengl_uniform.h
│       │   ├── post_processing_description.h
│       │   ├── primitive_type.h
│       │   ├── render_command.h
│       │   ├── render_command_type.h
│       │   ├── render_entity.h
│       │   ├── render_entity_type.h
│       │   ├── render_graph
│       │   │   ├── binary_operator_node.h
│       │   │   ├── blur_node.h
│       │   │   ├── camera_node.h
│       │   │   ├── colour_node.h
│       │   │   ├── combine_node.h
│       │   │   ├── component_node.h
│       │   │   ├── composite_node.h
│       │   │   ├── conditional_node.h
│       │   │   ├── fragment_node.h
│       │   │   ├── invert_node.h
│       │   │   ├── lerp_node.h
│       │   │   ├── node.h
│       │   │   ├── post_processing
│       │   │   │   ├── ambient_occlusion_node.h
│       │   │   │   ├── anti_aliasing_node.h
│       │   │   │   └── colour_adjust_node.h
│       │   │   ├── property.h
│       │   │   ├── property_node.h
│       │   │   ├── property_writer.h
│       │   │   ├── render_graph.h
│       │   │   ├── render_node.h
│       │   │   ├── shader_compiler.h
│       │   │   ├── sky_box_node.h
│       │   │   ├── texture_node.h
│       │   │   ├── time_node.h
│       │   │   ├── unary_operator_node.h
│       │   │   ├── value_node.h
│       │   │   ├── variable_node.h
│       │   │   └── vertex_node.h
│       │   ├── render_pass.h
│       │   ├── render_pipeline.h
│       │   ├── render_target.h
│       │   ├── render_target_manager.h
│       │   ├── renderer.h
│       │   ├── sampler.h
│       │   ├── scene.h
│       │   ├── shader_type.h
│       │   ├── single_entity.h
│       │   ├── skeleton.h
│       │   ├── text_factory.h
│       │   ├── texture.h
│       │   ├── texture_manager.h
│       │   ├── texture_usage.h
│       │   ├── utils.h
│       │   ├── vertex_attributes.h
│       │   ├── vertex_data.h
│       │   ├── weight.h
│       │   ├── win32
│       │   │   ├── win32_d3d12_window.h
│       │   │   ├── win32_opengl_window.h
│       │   │   ├── win32_window.h
│       │   │   └── win32_window_manager.h
│       │   ├── window.h
│       │   └── window_manager.h
│       ├── iris_version.h.in
│       ├── jobs
│       │   ├── arch
│       │   │   └── x86_64
│       │   │       ├── context.h
│       │   │       └── functions.S
│       │   ├── concurrent_queue.h
│       │   ├── context.h
│       │   ├── fiber
│       │   │   ├── counter.h
│       │   │   ├── fiber.h
│       │   │   ├── fiber_job_system.h
│       │   │   └── fiber_job_system_manager.h
│       │   ├── job.h
│       │   ├── job_system.h
│       │   ├── job_system_manager.h
│       │   └── thread
│       │       ├── thread_job_system.h
│       │       └── thread_job_system_manager.h
│       ├── log
│       │   ├── basic_formatter.h
│       │   ├── colour_formatter.h
│       │   ├── emoji_formatter.h
│       │   ├── file_outputter.h
│       │   ├── formatter.h
│       │   ├── log.h
│       │   ├── log_level.h
│       │   ├── logger.h
│       │   ├── outputter.h
│       │   └── stdout_outputter.h
│       ├── networking
│       │   ├── channel
│       │   │   ├── channel.h
│       │   │   ├── channel_type.h
│       │   │   ├── reliable_ordered_channel.h
│       │   │   ├── unreliable_sequenced_channel.h
│       │   │   └── unreliable_unordered_channel.h
│       │   ├── client_connection_handler.h
│       │   ├── data_buffer_deserialiser.h
│       │   ├── data_buffer_serialiser.h
│       │   ├── networking.h
│       │   ├── packet.h
│       │   ├── packet_type.h
│       │   ├── server_connection_handler.h
│       │   ├── server_socket.h
│       │   ├── server_socket_data.h
│       │   ├── simulated_server_socket.h
│       │   ├── simulated_socket.h
│       │   ├── socket.h
│       │   ├── udp_server_socket.h
│       │   ├── udp_socket.h
│       │   └── win32
│       │       └── winsock.h
│       ├── physics
│       │   ├── basic_character_controller.h
│       │   ├── bullet
│       │   │   ├── bullet_box_collision_shape.h
│       │   │   ├── bullet_capsule_collision_shape.h
│       │   │   ├── bullet_collision_shape.h
│       │   │   ├── bullet_heightmap_collision_shape.h
│       │   │   ├── bullet_mesh_collision_shape.h
│       │   │   ├── bullet_physics_manager.h
│       │   │   ├── bullet_physics_system.h
│       │   │   ├── bullet_rigid_body.h
│       │   │   ├── collision_callback.h
│       │   │   └── debug_draw.h
│       │   ├── character_controller.h
│       │   ├── collision_shape.h
│       │   ├── contact_point.h
│       │   ├── physics_manager.h
│       │   ├── physics_system.h
│       │   ├── ray_cast_result.h
│       │   ├── rigid_body.h
│       │   └── rigid_body_type.h
│       └── scripting
│           ├── lua
│           │   ├── interop
│           │   │   ├── class_interop.h
│           │   │   ├── quaternion.h
│           │   │   ├── register_class.h
│           │   │   └── vector3.h
│           │   └── lua_script.h
│           ├── script.h
│           └── script_runner.h
├── media
│   ├── logo.png
│   ├── physics.png
│   ├── trinket.png
│   └── zombie.png
├── samples
│   ├── CMakeLists.txt
│   ├── jobs
│   │   ├── CMakeLists.txt
│   │   └── main.cpp
│   ├── networking
│   │   ├── CMakeLists.txt
│   │   ├── client.cpp
│   │   ├── client_input.h
│   │   └── server.cpp
│   └── sample_browser
│       ├── CMakeLists.txt
│       ├── assets
│       │   ├── FlowMap2.png
│       │   ├── Port_SecondAge_Level3.fbx
│       │   ├── Voronoi2.png
│       │   ├── Zombie.fbx
│       │   ├── ZombieTexture.png
│       │   ├── brickwall.jpg
│       │   ├── brickwall_normal.jpg
│       │   ├── circle.png
│       │   ├── crate.png
│       │   ├── crate_specular.png
│       │   ├── port.fbx
│       │   ├── scene.fbx
│       │   ├── ship.fbx
│       │   ├── ship_texture.png
│       │   ├── space
│       │   │   ├── back.png
│       │   │   ├── bottom.png
│       │   │   ├── front.png
│       │   │   ├── left.png
│       │   │   ├── right.png
│       │   │   └── top.png
│       │   └── sphere.fbx
│       ├── main.cpp
│       └── samples
│           ├── animation_sample.cpp
│           ├── animation_sample.h
│           ├── physics_sample.cpp
│           ├── physics_sample.h
│           ├── render_graph_sample.cpp
│           ├── render_graph_sample.h
│           ├── sample.h
│           ├── water_sample.cpp
│           └── water_sample.h
├── shaders
│   ├── CMakeLists.txt
│   ├── glsl
│   │   ├── CMakeLists.txt
│   │   ├── ambient_occlusion_node_fragment.glsl
│   │   ├── ambient_occlusion_node_vertex.glsl
│   │   ├── anti_aliasing_node_fragment.glsl
│   │   ├── anti_aliasing_node_vertex.glsl
│   │   ├── binary_operator_node_chunk.glsl
│   │   ├── blur_function.glsl
│   │   ├── blur_node_chunk.glsl
│   │   ├── camera_node_chunk.glsl
│   │   ├── colour_adjust_node_fragment.glsl
│   │   ├── colour_adjust_node_vertex.glsl
│   │   ├── colour_node_chunk.glsl
│   │   ├── combine_node_chunk.glsl
│   │   ├── component_node_chunk.glsl
│   │   ├── composite_function.glsl
│   │   ├── composite_node_chunk.glsl
│   │   ├── conditional_node_chunk.glsl
│   │   ├── declare_property_chunk.glsl
│   │   ├── declare_variable_chunk.glsl
│   │   ├── fragment_node_chunk.glsl
│   │   ├── invert_function.glsl
│   │   ├── invert_node_chunk.glsl
│   │   ├── lerp_node_chunk.glsl
│   │   ├── property_chunk.glsl
│   │   ├── render_node_fragment.glsl
│   │   ├── render_node_vertex.glsl
│   │   ├── rgb_to_luma_function.glsl
│   │   ├── set_variable_chunk.glsl
│   │   ├── shadow_function.glsl
│   │   ├── sin_node_chunk.glsl
│   │   ├── sky_box_node_fragment.glsl
│   │   ├── sky_box_node_vertex.glsl
│   │   ├── texture_node_chunk.glsl
│   │   ├── time_node_chunk.glsl
│   │   ├── value_node_colour_chunk.glsl
│   │   ├── value_node_float_chunk.glsl
│   │   ├── value_node_vector3_chunk.glsl
│   │   ├── variable_node_chunk.glsl
│   │   └── vertex_node_chunk.glsl
│   ├── hlsl
│   │   ├── CMakeLists.txt
│   │   ├── ambient_occlusion_node_fragment.hlsl
│   │   ├── ambient_occlusion_node_vertex.hlsl
│   │   ├── anti_aliasing_node_fragment.hlsl
│   │   ├── anti_aliasing_node_vertex.hlsl
│   │   ├── binary_operator_node_chunk.hlsl
│   │   ├── blur_function.hlsl
│   │   ├── blur_node_chunk.hlsl
│   │   ├── camera_node_chunk.hlsl
│   │   ├── colour_adjust_node_fragment.hlsl
│   │   ├── colour_adjust_node_vertex.hlsl
│   │   ├── colour_node_chunk.hlsl
│   │   ├── combine_node_chunk.hlsl
│   │   ├── component_node_chunk.hlsl
│   │   ├── composite_function.hlsl
│   │   ├── composite_node_chunk.hlsl
│   │   ├── conditional_node_chunk.hlsl
│   │   ├── declare_property_chunk.hlsl
│   │   ├── declare_variable_chunk.hlsl
│   │   ├── fragment_node_chunk.hlsl
│   │   ├── invert_function.hlsl
│   │   ├── invert_node_chunk.hlsl
│   │   ├── lerp_node_chunk.hlsl
│   │   ├── property_chunk.hlsl
│   │   ├── render_node_fragment.hlsl
│   │   ├── render_node_vertex.hlsl
│   │   ├── rgb_to_luma_function.hlsl
│   │   ├── set_variable_chunk.hlsl
│   │   ├── shadow_function.hlsl
│   │   ├── sky_box_node_fragment.hlsl
│   │   ├── sky_box_node_vertex.hlsl
│   │   ├── texture_node_chunk.hlsl
│   │   ├── time_node_chunk.hlsl
│   │   ├── unary_operator_node_chunk.hlsl
│   │   ├── value_node_colour_chunk.hlsl
│   │   ├── value_node_float_chunk.hlsl
│   │   ├── value_node_vector3_chunk.hlsl
│   │   ├── variable_node_chunk.hlsl
│   │   └── vertex_node_chunk.hlsl
│   ├── msl
│   │   ├── CMakeLists.txt
│   │   ├── ambient_occlusion_node_fragment.msl
│   │   ├── ambient_occlusion_node_vertex.msl
│   │   ├── anti_aliasing_node_fragment.msl
│   │   ├── anti_aliasing_node_vertex.msl
│   │   ├── binary_operator_node_chunk.msl
│   │   ├── blur_function.msl
│   │   ├── blur_node_chunk.msl
│   │   ├── camera_node_chunk.msl
│   │   ├── colour_adjust_node_fragment.msl
│   │   ├── colour_adjust_node_vertex.msl
│   │   ├── colour_node_chunk.msl
│   │   ├── combine_node_chunk.msl
│   │   ├── component_node_chunk.msl
│   │   ├── composite_function.msl
│   │   ├── composite_node_chunk.msl
│   │   ├── conditional_node_chunk.msl
│   │   ├── declare_property_chunk.msl
│   │   ├── declare_variable_chunk.msl
│   │   ├── fragment_node_chunk.msl
│   │   ├── invert_function.msl
│   │   ├── invert_node_chunk.msl
│   │   ├── lerp_node_chunk.msl
│   │   ├── property_chunk.msl
│   │   ├── render_node_fragment.msl
│   │   ├── render_node_vertex.msl
│   │   ├── rgb_to_luma_function.msl
│   │   ├── set_variable_chunk.msl
│   │   ├── shadow_function.msl
│   │   ├── sky_box_node_fragment.msl
│   │   ├── sky_box_node_vertex.msl
│   │   ├── texture_node_chunk.msl
│   │   ├── time_node_chunk.msl
│   │   ├── unary_operator_node_chunk.msl
│   │   ├── value_node_colour_chunk.msl
│   │   ├── value_node_float_chunk.msl
│   │   ├── value_node_vector3_chunk.msl
│   │   ├── variable_node_chunk.msl
│   │   └── vertex_node_chunk.msl
│   ├── shader_include.in
│   └── shader_string.in
├── src
│   ├── CMakeLists.txt
│   ├── core
│   │   ├── CMakeLists.txt
│   │   ├── camera.cpp
│   │   ├── context.cpp
│   │   ├── default_resource_manager.cpp
│   │   ├── exception.cpp
│   │   ├── ios
│   │   │   ├── CMakeLists.txt
│   │   │   ├── ios_resource_manager.mm
│   │   │   └── start.mm
│   │   ├── linux
│   │   │   ├── CMakeLists.txt
│   │   │   ├── profiler.cpp
│   │   │   ├── semaphore.cpp
│   │   │   ├── start.cpp
│   │   │   ├── static_buffer.cpp
│   │   │   └── thread.cpp
│   │   ├── looper.cpp
│   │   ├── macos
│   │   │   ├── CMakeLists.txt
│   │   │   ├── macos_ios_utility.mm
│   │   │   ├── profiler.cpp
│   │   │   ├── semaphore.cpp
│   │   │   ├── start.mm
│   │   │   └── thread.cpp
│   │   ├── profiler_analyser.cpp
│   │   ├── random.cpp
│   │   ├── resource_manager.cpp
│   │   ├── transform.cpp
│   │   ├── utils.cpp
│   │   └── win32
│   │       ├── CMakeLists.txt
│   │       ├── profiler.cpp
│   │       ├── semaphore.cpp
│   │       ├── start.cpp
│   │       └── thread.cpp
│   ├── events
│   │   ├── CMakeLists.txt
│   │   └── event.cpp
│   ├── graphics
│   │   ├── CMakeLists.txt
│   │   ├── animation
│   │   │   ├── CMakeLists.txt
│   │   │   ├── animation.cpp
│   │   │   ├── animation_controller.cpp
│   │   │   ├── animation_state.cpp
│   │   │   ├── cached_bone_query.cpp
│   │   │   └── utils.cpp
│   │   ├── animation_blender.cpp
│   │   ├── bone.cpp
│   │   ├── cube_map.cpp
│   │   ├── d3d12
│   │   │   ├── CMakeLists.txt
│   │   │   ├── d3d12_buffer.cpp
│   │   │   ├── d3d12_constant_buffer.cpp
│   │   │   ├── d3d12_constant_buffer_pool.cpp
│   │   │   ├── d3d12_context.cpp
│   │   │   ├── d3d12_cube_map.cpp
│   │   │   ├── d3d12_descriptor_handle.cpp
│   │   │   ├── d3d12_descriptor_manager.cpp
│   │   │   ├── d3d12_material.cpp
│   │   │   ├── d3d12_material_manager.cpp
│   │   │   ├── d3d12_mesh.cpp
│   │   │   ├── d3d12_mesh_manager.cpp
│   │   │   ├── d3d12_render_target.cpp
│   │   │   ├── d3d12_render_target_manager.cpp
│   │   │   ├── d3d12_renderer.cpp
│   │   │   ├── d3d12_sampler.cpp
│   │   │   ├── d3d12_structured_buffer.cpp
│   │   │   ├── d3d12_texture.cpp
│   │   │   └── d3d12_texture_manager.cpp
│   │   ├── instanced_entity.cpp
│   │   ├── ios
│   │   │   ├── CMakeLists.txt
│   │   │   ├── app_delegate.mm
│   │   │   ├── ios_window.mm
│   │   │   ├── ios_window_manager.cpp
│   │   │   ├── metal_view.mm
│   │   │   └── metal_view_controller.mm
│   │   ├── lights
│   │   │   ├── CMakeLists.txt
│   │   │   ├── ambient_light.cpp
│   │   │   ├── directional_light.cpp
│   │   │   └── point_light.cpp
│   │   ├── linux
│   │   │   ├── CMakeLists.txt
│   │   │   ├── linux_window.cpp
│   │   │   └── linux_window_manager.cpp
│   │   ├── macos
│   │   │   ├── CMakeLists.txt
│   │   │   ├── macos_window.mm
│   │   │   ├── macos_window_manager.cpp
│   │   │   ├── metal_app_delegate.m
│   │   │   ├── metal_view.m
│   │   │   └── text_factory.mm
│   │   ├── material.cpp
│   │   ├── material_manager.cpp
│   │   ├── mesh.cpp
│   │   ├── mesh_loader.cpp
│   │   ├── mesh_manager.cpp
│   │   ├── metal
│   │   │   ├── CMakeLists.txt
│   │   │   ├── metal_buffer.mm
│   │   │   ├── metal_constant_buffer.mm
│   │   │   ├── metal_cube_map.mm
│   │   │   ├── metal_material.mm
│   │   │   ├── metal_material_manager.mm
│   │   │   ├── metal_mesh.mm
│   │   │   ├── metal_mesh_manager.mm
│   │   │   ├── metal_render_target.mm
│   │   │   ├── metal_render_target_manager.mm
│   │   │   ├── metal_renderer.mm
│   │   │   ├── metal_sampler.mm
│   │   │   ├── metal_texture.mm
│   │   │   └── metal_texture_manager.mm
│   │   ├── opengl
│   │   │   ├── CMakeLists.txt
│   │   │   ├── opengl.cpp
│   │   │   ├── opengl_cube_map.cpp
│   │   │   ├── opengl_frame_buffer.cpp
│   │   │   ├── opengl_material.cpp
│   │   │   ├── opengl_material_manager.cpp
│   │   │   ├── opengl_mesh.cpp
│   │   │   ├── opengl_mesh_manager.cpp
│   │   │   ├── opengl_render_target.cpp
│   │   │   ├── opengl_render_target_manager.cpp
│   │   │   ├── opengl_renderer.cpp
│   │   │   ├── opengl_sampler.cpp
│   │   │   ├── opengl_shader.cpp
│   │   │   ├── opengl_texture.cpp
│   │   │   ├── opengl_texture_manager.cpp
│   │   │   └── opengl_uniform.cpp
│   │   ├── render_command.cpp
│   │   ├── render_entity.cpp
│   │   ├── render_graph
│   │   │   ├── CMakeLists.txt
│   │   │   ├── binary_operator_node.cpp
│   │   │   ├── blur_node.cpp
│   │   │   ├── camera_node.cpp
│   │   │   ├── colour_node.cpp
│   │   │   ├── combine_node.cpp
│   │   │   ├── component_node.cpp
│   │   │   ├── composite_node.cpp
│   │   │   ├── conditional_node.cpp
│   │   │   ├── fragment_node.cpp
│   │   │   ├── invert_node.cpp
│   │   │   ├── lerp_node.cpp
│   │   │   ├── post_processing
│   │   │   │   ├── CMakeLists.txt
│   │   │   │   ├── ambient_occlusion_node.cpp
│   │   │   │   ├── anti_aliasing_node.cpp
│   │   │   │   └── colour_adjust_node.cpp
│   │   │   ├── property.cpp
│   │   │   ├── property_node.cpp
│   │   │   ├── render_graph.cpp
│   │   │   ├── render_node.cpp
│   │   │   ├── shader_compiler.cpp
│   │   │   ├── sky_box_node.cpp
│   │   │   ├── texture_node.cpp
│   │   │   ├── time_node.cpp
│   │   │   ├── unary_operator_node.cpp
│   │   │   ├── variable_node.cpp
│   │   │   └── vertex_node.cpp
│   │   ├── render_pipeline.cpp
│   │   ├── render_target.cpp
│   │   ├── renderer.cpp
│   │   ├── sampler.cpp
│   │   ├── scene.cpp
│   │   ├── single_animation.cpp
│   │   ├── single_entity.cpp
│   │   ├── skeleton.cpp
│   │   ├── texture.cpp
│   │   ├── texture_manager.cpp
│   │   ├── utils.cpp
│   │   ├── vertex_attributes.cpp
│   │   ├── win32
│   │   │   ├── CMakeLists.txt
│   │   │   ├── text_factory.cpp
│   │   │   ├── win32_d3d12_window.cpp
│   │   │   ├── win32_opengl_window.cpp
│   │   │   ├── win32_window.cpp
│   │   │   └── win32_window_manager.cpp
│   │   └── window.cpp
│   ├── jobs
│   │   ├── CMakeLists.txt
│   │   ├── fiber
│   │   │   ├── CMakeLists.txt
│   │   │   ├── counter.cpp
│   │   │   ├── fiber_job_system.cpp
│   │   │   ├── fiber_job_system_manager.cpp
│   │   │   ├── posix
│   │   │   │   ├── CMakeLists.txt
│   │   │   │   └── fiber.cpp
│   │   │   └── windows
│   │   │       ├── CMakeLists.txt
│   │   │       └── fiber.cpp
│   │   └── thread
│   │       ├── CMakeLists.txt
│   │       ├── thread_job_system.cpp
│   │       └── thread_job_system_manager.cpp
│   ├── log
│   │   ├── CMakeLists.txt
│   │   ├── basic_formatter.cpp
│   │   ├── colour_formatter.cpp
│   │   ├── emoji_formatter.cpp
│   │   ├── file_outputter.cpp
│   │   └── stdout_outputter.cpp
│   ├── networking
│   │   ├── CMakeLists.txt
│   │   ├── channel
│   │   │   ├── channel.cpp
│   │   │   ├── reliable_ordered_channel.cpp
│   │   │   ├── unreliable_sequenced_channel.cpp
│   │   │   └── unreliable_unordered_channel.cpp
│   │   ├── client_connection_handler.cpp
│   │   ├── packet.cpp
│   │   ├── server_connection_handler.cpp
│   │   ├── simulated_server_socket.cpp
│   │   ├── simulated_socket.cpp
│   │   ├── udp_server_socket.cpp
│   │   ├── udp_socket.cpp
│   │   └── win32
│   │       ├── CMakeLists.txt
│   │       └── winsock.cpp
│   ├── physics
│   │   ├── CMakeLists.txt
│   │   ├── basic_character_controller.cpp
│   │   └── bullet
│   │       ├── CMakeLists.txt
│   │       ├── bullet_box_collision_shape.cpp
│   │       ├── bullet_capsule_collision_shape.cpp
│   │       ├── bullet_heightmap_collision_shape.cpp
│   │       ├── bullet_mesh_collision_shape.cpp
│   │       ├── bullet_physics_manager.cpp
│   │       ├── bullet_physics_system.cpp
│   │       ├── bullet_rigid_body.cpp
│   │       ├── collision_callback.cpp
│   │       └── debug_draw.cpp
│   └── scripting
│       ├── CMakeLists.txt
│       └── lua
│           ├── CMakeLists.txt
│           ├── interop
│           │   ├── CMakeLists.txt
│           │   ├── quaternion.cpp
│           │   ├── register_class.cpp
│           │   └── vector3.cpp
│           └── lua_script.cpp
├── tests
│   ├── CMakeLists.txt
│   ├── core
│   │   ├── CMakeLists.txt
│   │   ├── auto_release_tests.cpp
│   │   ├── colour_tests.cpp
│   │   ├── error_handling_tests.cpp
│   │   ├── matrix4_tests.cpp
│   │   ├── object_pool_tests.cpp
│   │   ├── quaternion_tests.cpp
│   │   ├── transform_tests.cpp
│   │   └── vector3_tests.cpp
│   ├── fakes
│   │   ├── fake_light.h
│   │   ├── fake_material.h
│   │   ├── fake_mesh.h
│   │   ├── fake_render_target.h
│   │   ├── fake_renderer.h
│   │   └── fake_texture.h
│   ├── graphics
│   │   ├── CMakeLists.txt
│   │   ├── render_command_tests.cpp
│   │   └── render_graph_tests.cpp
│   ├── jobs
│   │   ├── CMakeLists.txt
│   │   ├── concurrent_queue_tests.cpp
│   │   ├── counter_tests.cpp
│   │   ├── fiber_job_system_tests.cpp
│   │   ├── job_system_tests.h
│   │   └── thread_job_system_tests.cpp
│   ├── mocks
│   │   ├── mock_material_manager.h
│   │   ├── mock_mesh_manager.h
│   │   ├── mock_render_target_manager.h
│   │   ├── mock_resource_manager.h
│   │   └── mock_script.h
│   ├── networking
│   │   ├── CMakeLists.txt
│   │   ├── data_buffer_serialiser_tests.cpp
│   │   ├── helper.h
│   │   ├── packet_tests.cpp
│   │   ├── reliable_ordered_channel_tests.cpp
│   │   ├── unreliable_sequenced_channel_tests.cpp
│   │   └── unreliable_unordered_channel_tests.cpp
│   ├── platform
│   │   ├── CMakeLists.txt
│   │   └── macos
│   │       ├── CMakeLists.txt
│   │       └── thread_tests.cpp
│   └── scripting
│       ├── CMakeLists.txt
│       ├── lua_script_tests.cpp
│       └── script_runner_tests.cpp
└── toolchains

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.18)

project(
  iris
  VERSION "4.0.1"
  DESCRIPTION "Cross-platform game engine"
  LANGUAGES C CXX)

include(CMakePackageConfigHelpers)
include(FetchContent)
include(GNUInstallDirs)
include(GenerateExportHeader)

# set options for library
option(IRIS_BUILD_UNIT_TESTS "whether to build unit tests" ON)

set(ASM_OPTIONS "-x assembler-with-cpp")

# if a platform wasn't supplied then default to current platform
if(NOT IRIS_PLATFORM)
  if(${CMAKE_SYSTEM_NAME} MATCHES "Darwin")
    set(CMAKE_CXX_STANDARD 20)
    set(IRIS_PLATFORM "MACOS")

    if(${CMAKE_SYSTEM_PROCESSOR} MATCHES "arm64")
      set(IRIS_ARCH "ARM64")
    else()
      set(IRIS_ARCH "X86_64")
    endif()
  elseif(${CMAKE_SYSTEM_NAME} MATCHES "Windows")
    set(IRIS_PLATFORM "WIN32")
    set(IRIS_ARCH "X86_64")
  elseif(${CMAKE_SYSTEM_NAME} MATCHES "Linux")
    set(IRIS_PLATFORM "LINUX")
    set(IRIS_ARCH "X86_64")
  else()
    message(FATAL_ERROR "Unsupported platform: ${CMAKE_SYSTEM_NAME}")
  endif()
endif()

if(IRIS_PLATFORM MATCHES "MACOS" OR IRIS_PLATFORM MATCHES "IOS")
  enable_language(OBJC)
  enable_language(OBJCXX)
  enable_language(ASM)
endif()

if(IRIS_PLATFORM MATCHES "LINUX")
  enable_language(ASM)
endif()

# set options for third party libraries
set(BUILD_UNIT_TESTS OFF CACHE BOOL "" FORCE)
set(BUILD_SHARED_LIBS OFF CACHE BOOL "" FORCE)
set(BUILD_CPU_DEMOS OFF CACHE BOOL "" FORCE)
set(BUILD_BULLET2_DEMOS OFF CACHE BOOL "" FORCE)
set(BUILD_EXTRAS OFF CACHE BOOL "" FORCE)
set(BUILD_DOCS OFF CACHE BOOL "" FORCE)
set(ASSIMP_BUILD_ASSIMP_TOOLS OFF CACHE BOOL "" FORCE)
set(ASSIMP_BUILD_SAMPLES OFF CACHE BOOL "" FORCE)
set(ASSIMP_BUILD_TESTS OFF CACHE BOOL "" FORCE)
set(ASSIMP_BUILD_ZLIB ON CACHE BOOL "" FORCE)
set(ASSIMP_BUILD_ALL_IMPORTERS_BY_DEFAULT OFF CACHE BOOL "" FORCE)
set(ASSIMP_BUILD_ALL_EXPORTERS_BY_DEFAULT OFF CACHE BOOL "" FORCE)
set(ASSIMP_BUILD_FBX_IMPORTER ON CACHE BOOL "" FORCE)
set(ASSIMP_NO_EXPORT ON CACHE BOOL "" FORCE)
set(INJA_BUILD_TESTS OFF CACHE BOOL "" FORCE)
set(BUILD_BENCHMARK OFF CACHE BOOL "" FORCE)
set(COVERALLS OFF CACHE BOOL "" FORCE)

# fetch third party libraries
# note that in most cases we manually populate and add, this alloes us to use
# EXCLUDE_FROM_ALL to prevent them from being included in the install step
FetchContent_Declare(
  assimp
  GIT_REPOSITORY https://github.com/assimp/assimp
  GIT_TAG v5.0.1)
FetchContent_GetProperties(assimp)

if(NOT assimp_POPULATED)
  FetchContent_Populate(assimp)
  add_subdirectory(${assimp_SOURCE_DIR} ${assimp_BINARY_DIR} EXCLUDE_FROM_ALL)
endif()

FetchContent_Declare(
  bullet
  GIT_REPOSITORY https://github.com/bulletphysics/bullet3
  GIT_TAG 3.17)
FetchContent_GetProperties(bullet)

if(NOT bullet_POPULATED)
  FetchContent_Populate(bullet)
  add_subdirectory(${bullet_SOURCE_DIR} ${bullet_BINARY_DIR} EXCLUDE_FROM_ALL)
endif()

# stb doesn't have a cmake file, so just make it available
FetchContent_Declare(
  stb
  GIT_REPOSITORY https://github.com/nothings/stb
  GIT_TAG c0c982601f40183e74d84a61237e968dca08380e
  CONFIGURE_COMMAND "" BUILD_COMMAND "")
FetchContent_MakeAvailable(stb)

FetchContent_Declare(
  lua
  GIT_REPOSITORY https://github.com/lua/lua.git
  GIT_TAG v5.4.3
  CONFIGURE_COMMAND "" BUILD_COMMAND "")
FetchContent_MakeAvailable(lua)

FetchContent_Declare(
  googletest
  GIT_REPOSITORY https://github.com/google/googletest.git
  GIT_TAG release-1.11.0)
FetchContent_GetProperties(googletest)

if(NOT googletest_POPULATED)
  FetchContent_Populate(googletest)
  add_subdirectory(${googletest_SOURCE_DIR} ${googletest_BINARY_DIR} EXCLUDE_FROM_ALL)
endif()

FetchContent_Declare(
  inja
  GIT_REPOSITORY https://github.com/pantor/inja
  GIT_TAG v3.3.0)
FetchContent_GetProperties(inja)

if(NOT inja_POPULATED)
  FetchContent_Populate(inja)
  add_subdirectory(${inja_SOURCE_DIR} ${inja_BINARY_DIR} EXCLUDE_FROM_ALL)
endif()

if(IRIS_PLATFORM MATCHES "WIN32")
  FetchContent_Declare(
    directx-headers
    GIT_REPOSITORY https://github.com/microsoft/DirectX-Headers.git
    GIT_TAG v1.4.9)
  FetchContent_GetProperties(directx-headers)

  if(NOT directx-headers_POPULATED)
    FetchContent_Populate(directx-headers)
    add_subdirectory(${directx-headers_SOURCE_DIR} ${directx-headers_BINARY_DIR} EXCLUDE_FROM_ALL)
  endif()
endif()

add_subdirectory("shaders")
add_subdirectory("src")
add_subdirectory("samples")

if(IRIS_BUILD_UNIT_TESTS)
  enable_testing()
  include(CTest)

  add_subdirectory("tests")
endif()

include(cmake/cpack.cmake)

```

`LICENSE`:

```
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

```

`README.md`:

```md
<p align="center">
  <img src="media/logo.png" />
</p>

# IRIS
Iris is a cross-platform game engine written in modern C++

[![build](https://github.com/irisengine/iris/actions/workflows/build.yml/badge.svg)](https://github.com/irisengine/iris/actions/workflows/build.yml) ![C++20](https://img.shields.io/badge/-20-f34b7d?logo=cplusplus) [![License](https://img.shields.io/badge/License-Boost%201.0-lightblue.svg)](https://www.boost.org/LICENSE_1_0.txt) ![Platforms](https://img.shields.io/badge/platforms-windows%20%7C%20macos%20%7C%20ios%20%7C%20linux-lightgrey)

# Table of Contents
1. [Screenshots](#screenshots)
2. [Features](#features)
3. [Dependencies](#dependencies)
4. [Included third-party libraries](#included-third-party-libraries)
5. [Using iris](#using-iris)
    1. [Prebuilt libraries](#prebuilt-libraries)
    2. [System install](#system-install)
    3. [Build in project](#build-in-project)
6. [Building](#building)
    1. [Options](#options)
    2. [Command line](#command-line)
    3. [Visual Studio Code / Visual Studio](#visual-studio-code-visual-studio)
7. [Examples](#examples)
8. [Design](#design)
    1. [Versioning](#versioning)
    2. [Compile/Runtime choices](#compileruntime-choices)
    3. [Managers](#managers)
    4. [Memory management](#memory-management)
    5. [core](#core)
    6. [events](#events)
    7. [graphics](#graphics)
        1. [render_graph](#render_graph)
    8. [jobs](#jobs)
    9. [log](#log)
    10. [networking](#networking)
    11. [physics](#physics)
    12. [scripting](#scripting)

---

## Screenshots
![trinket](media/trinket.png)
![zombie](media/zombie.png)
![physics](media/physics.png)

## Features
* Cross platform: Windows, Linux, macOS and iOS
* Multiple rendering backends: D3D12, Metal, OpenGL 
* 3D rendering and physics
* Custom sampling profiler
* Post processing effects:
    - FXAA
    - SSAO
    - Bloom
    - HDR
* Graph based shader compiler
* Skeleton animation
* Job based parallelism (fiber and thread implementations)
* Networking
* Lua scripting

## Dependencies
The following dependencies are required to build iris:
1. cmake > 3.18
2. C++20 compiler

The following compilers have been tested

| Platform | Version | Compiler |
| -------- | ------- | -------- |
| macOS | 14.0.5 | clang |
| macOS | 13.1.6 | Apple clang (Xcode) |
| linux | 14.0.5 | clang |
| linux | 12.1.0 | g++ |
| windows | 19.32.31332 | msvc |

## Included third-party libraries
The following dependencies are automatically checked out as part of the build:

| Dependency | Version | License |
| ---------- | ------- | ------- |
| [assimp](https://github.com/assimp/assimp) | [5.0.1](https://github.com/assimp/assimp/releases/tag/v5.0.1) | [![License](https://img.shields.io/badge/License-assimp-lightblue.svg)](https://github.com/assimp/assimp/blob/master/LICENSE)|
| [bullet](https://github.com/bulletphysics/bullet3) | [3.17](https://github.com/bulletphysics/bullet3/releases/tag/3.17) | [![License: Zlib](https://img.shields.io/badge/License-Zlib-lightblue.svg)](https://opensource.org/licenses/Zlib) |
| [stb](https://github.com/nothings/stb) | [c0c9826](https://github.com/nothings/stb/tree/c0c982601f40183e74d84a61237e968dca08380e) | [![License: MIT](https://img.shields.io/badge/License-MIT-lightblue.svg)](https://opensource.org/licenses/MIT) / [![License: Unlicense](https://img.shields.io/badge/License-Unlicense-lightblue.svg)](http://unlicense.org/)|
| [googletest](https://github.com/google/googletest.git) | [1.11.0](https://github.com/google/googletest/releases/tag/release-1.11.0) | [![License](https://img.shields.io/badge/License-BSD%203--Clause-lightblue.svg)](https://opensource.org/licenses/BSD-3-Clause) |
| [directx-headers](https://github.com/microsoft/DirectX-Headers.git) | [1.4.9](https://github.com/microsoft/DirectX-Headers/releases/tag/v1.4.9) | [![License: MIT](https://img.shields.io/badge/License-MIT-lightblue.svg)](https://opensource.org/licenses/MIT) |
| [lua](https://github.com/lua/lua) | [5.4.3](https://github.com/lua/lua/releases/tag/v5.4.3) | [![License: MIT](https://img.shields.io/badge/License-MIT-lightblue.svg)](https://opensource.org/licenses/MIT) |
| [inja](https://github.com/pantor/inja) | [3.3.0](https://github.com/pantor/inja/releases/tag/v3.3.0) | [![License: MIT](https://img.shields.io/badge/License-MIT-lightblue.svg)](https://opensource.org/licenses/MIT) |

Note that these libraries may themselves have other dependencies with different licenses.

## Using iris
Iris (and all of its dependencies) are built as static libraries. There are three ways you can include iris in your project. These all assume you are using cmake, it is theoretically possible to integrate iris into other build systems but that is beyond the scope of this document.

### Prebuilt libraries
Prebuilt binaries (and required headers) are available in [releases](https://github.com/irisengine/iris/releases). Simply download, extract and copy somewhere. They can be either checked into your project or stored externally. Then simply add the following to your project cmake:
```cmake
find_package(iris REQUIRED PATHS path/to/iris/lib/cmake)
target_link_libraries(my_project iris::iris)
```

### System install
After [building](#command-line) run the following as root/admin from the build directory to install iris into your system:
```cmake
cmake --install .
```

Then simply add the following to your project:
```cmake
find_package(iris REQUIRED)
target_link_libraries(my_project iris::iris)
```

### Build in project
It is also possible to build iris as part of your project. Add the source to your project (either by copying the files or as a git submodule). Then add the following to your project:
```cmake
add_subdirectory(iris)
target_include_directories(my_project PRIVATE iris/include)
target_link_libraries(my_project iris::iris)
```

Alternatively you can let cmake handle the checking out of iris:
```cmake
FetchContent_Declare(
  iris
  GIT_REPOSITORY https://github.com/irisengine/iris
  GIT_TAG v1.0.0)
FetchContent_GetProperties(iris)
if(NOT iris_POPULATED)
  FetchContent_Populate(iris)
  add_subdirectory(${iris_SOURCE_DIR} ${iris_BINARY_DIR} EXCLUDE_FROM_ALL)
endif()

target_include_directories(my_project PRIVATE iris/include)
target_link_libraries(my_project iris::iris)
```

## Building

### Options
| Cmake option | Default value |
| ------------ | ------------- |
| IRIS_BUILD_UNIT_TESTS | ON |

The following build methods are supported

### Command line
The following commands will build a debug version of iris. Note that this also works in PowerShell

```bash
mkdir build
cd build
cmake ..
cmake --build .

# to run tests
ctest
```

### Visual Studio Code / Visual Studio
Opening the root [`CMakeLists.txt`](/CMakeLists.txt) file in either tool should be sufficient. For vscode you will then have to select an appropriate kit. On Windows you will need to ensure the "Desktop development with C++" workload is installed.

Tests can be run with a googletest adaptor e.g. [visual studio](https://docs.microsoft.com/en-us/visualstudio/test/how-to-use-google-test-for-cpp?view=vs-2019) or [vscode](https://marketplace.visualstudio.com/items?itemName=DavidSchuldenfrei.gtest-adapter)

## Examples

The samples directory contains some basic usages.
* [sample_browser](/samples/sample_browser) - single executable with multiple graphics samples (tab to cycle through them)
* [jobs](/samples/jobs) - a quick and dirty path tracer to showcase and test the jobs system

Some additional snippets are included below.

**Create a window**
```c++
#include "iris/core/context.h"
#include "iris/events/event.h"
#include "iris/graphics/window.h"
#include "iris/graphics/window_manager.h"

void go(iris::Context context)
{
    auto *window = context.window_manager().create_window(800, 800);
    auto running = true;

    do
    {
        auto event = window->pump_event();
        while (event)
        {
            if (event->is_key(iris::Key::ESCAPE))
            {
                running = false;
                break;
            }

            event = window->pump_event();
        }

        window->render();
    } while (running);
}

int main(int argc, char **argv)
{
    iris::start(argc, argv, go);
}
```

## Design

### Versioning
The public API of iris is versioned using [semver](https://semver.org/). This means that when upgrading you can expect the following outcomes:
* Major version -> your project could no longer compile/link
* Minor version -> your project may not function the same as before
* Patch version -> your project should function the same, if you were not relying on the broken behaviour.

The internal API could change frequently and should not be used. As a rule of thumb the public API is defined in any header file in the top-level folders in `inlcude/iris` and any subfolders are internal.

### Compile/Runtime choices
Iris provides the user with several runtime choices e.g. rendering backend and physics engine. These are all runtime decisions (see [Managers](#managers)) and implemented via classic class inheritance. Some choices don't make sense to make at runtime e.g. `Semaphore` will be implemented with platform specific primitives so there is no runtime choice to make. To remove the overheard of inheritance and make this a simple compile time choice we define a single header ([semaphore.h](/include/iris/core/semaphore.h)) with the API and provide several different implementations ([macos](/src/core/macos/semaphore.cpp), [windows](/src/core/win32/semaphore.cpp)). Cmake can then pick the appropriate one when building. We use the [pimpl](https://en.cppreference.com/w/cpp/language/pimpl) idiom to keep implementation details out of the header.

### Context & Managers
To start the engine you call `iris::start` to which you pass a callback. Iris will perform all necessary startup and then call your callback passing to it an engine [`Context`](/include/iris/core/context.h). This [`Context`](/include/iris/core/context.h) object contains everything required to use the engine. In order to easily facilitate the runtime selection of components iris makes use of several manager classes. A manager class can be thought of as a factory class with state. Default managers are registered for you on the [`Context`](/include/iris/core/context.h). It may seem like a lot of machinery to have to registers managers but the advantage is a complete decoupling of the implementation from [`Context`](/include/iris/core/context.h). It is therefore possible to provide your own implementations of these components, register, then use them.

### Memory management
Iris manages the memory and lifetime of primitives for the user. If the engine is creating an object and returns a pointer it can be assumed that the pointer is not null and will remain valid until explicitly returned to the engine by the user.

### [`core`](/include/iris/core)
The directory contains primitives used throughout the engine. Details on some key parts are defined below.

#### Start
The [`start`](/include/iris/core/start.h) function allows iris to perform all engine start up and tear down before handing over to a user supplied function. All iris functions are undefined if called outside the provided callback.

#### Error handling
In iris errors are handled one of two ways, depending on the nature of the error:
1. Invariants that must hold but are not recoverable - in this case `expect` is used and `std::abort` is called on failure. This is analogous to an assert and thy are stripped in release. Example: failing to allocate a graphics api specific buffer.
2. Invariants that must hold but are recoverable - in this case `ensure` is used and an exception is thrown on failure. This allows someone further up the stack to catch and recover. Example: loading a texture from a missing file.

It's not always clear cut when which should be used, the main goal is that all potential errors are handled in some way. See [error_handling.h](/include/iris/core/error_handling.h) for `expect` and `ensure` documentation.

### [`events`](/include/iris/events)
These are user input events e.g. key press, screen touch. They are captured by a `Window` and can be pumped and then processed. Note that every tick all available events should be pumped.

```c++
auto event = window->pump_event();
while (event)
{
    // handle event here

    event = window->pump_event();
}
```

### [`graphics`](/include/iris/graphics)
All rendering logic is encapsulated in graphics. API agnostic interfaces are defined and implementations can be selected at runtime.

A simplified breakdown of the graphics design is below. The public interface is what users should use. The arrow is (mostly) used to denote ownership.

```text


                                                 +--------------+    +---------------------+
                                            .--->| GraphicsMesh |--->| Graphics primitives |
                                            |    +--------------+    +---------------------+
                                            |
                                            |    +----------------+    +------------------+
                                            .--->| ShaderCompiler |--->| GraphicsMaterial |
                                            |    +----------------+    +------------------+
                                            |
                                            |
                   +----------+    +------------------+
                   | OSWindow |    | GraphicsRenderer |
                   +----------+    +------------------+
                         |              | 
                         |              |
private interface        |              |
~~~~~~~~~~~~~~~~~~~~~~~~~|~~~~~~~~~~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
public interface         |              |
                         |              |
                         |              |
+---------------+    +--------+    +----------+     +----------+
| WindowManager |--->| Window |--->| Renderer |---->| render() |
+---------------+    +--------+    +----------+     +----------+
                         |
                         |   +-----------------------+      +------------+       +---------------+
                         '-->| set_render_pipeline() |<-----| RenderPass |<------| Render Target |
                             +-----------------------+   |  +------------+    |  +---------------+
                                                         |                    |  +-------------------------+
                                                         |                    '--| Post Processing Effects |
                                                         |                       +-------------------------+
                                                         |  +--------------+
                                                         |--| Render Graph |
                                                         |  +--------------+
                                                         |
                                                         |  +-------+
                                                          '-| Scene |
                                                            +-------+
                                                            |
                                                            |    +--------------+
                                                            '--->| RenderEntity | 
                                                            |    +--------------+
                                                            |           |    +------+
                                                            |           '--->| Mesh |
                                                            |           |    +------+
                                                            |           |    +----------+
                                                            |           '--->| Skeleton |
                                                            |                +----------+
                                                            |    +-------+
                                                            '--->| Light |
                                                                 +-------+

```

#### [`render_graph`](/include/iris/graphics/render_graph)
The render graph allows a user to define the effect of shaders in a shader language agnostic way. This is then compiled into the appropriate shader code (GLSL, HLSL, MSL) for the current window. [`Scene`](/include/iris/graphics/scene.h) creates and owns a [`RenderGraph`](/include/iris/graphics/render_graph/render_graph.h) which can be used for any [`RenderEntity`](/include/iris/graphics/render_entity.h) in that [`Scene`](/include/iris/graphics/scene.h) (it is undefined to use [`RenderGraph`](/include/iris/graphics/render_graph/render_graph.h) object in a [`Scene`](/include/iris/graphics/scene.h) that did not create it).

A [`RenderGraph`](/include/iris/graphics/render_graph/render_graph.h) owns a [`RenderNode`](/include/iris/graphics/render_graph/render_node.h) which is the root of the graph. To configure the output of the shader the inputs of the [`RenderNode`](/include/iris/graphics/render_graph/render_node.h) should be set. An example:

**Basic bloom**
Note that bloom is a provided as a built in post-processing effect - this is just used to illustrate the flexibility of the render graph.
```text
            Render
Main scene ~~~~~~~~ -----.
                         |
.------------------------'
|                                                                                        
|                  +---------------------+
|---------------.  |   Arithmetic Node   |      +----------------------+  +--------------+  
|               |  |=====================|      |   Conditional Node   |  | Render Node  |~~~~~~ -.
| +-----------+ '->O value1              |      |======================|  |==============|        |
| | Threshold |--->O value2              |----->O input_value1         |->O colour_input |        |
| +-----------+ .->O arithmetic operator | .--->O input_value2         |  +--------------|        |
|               |  +---------------------+ |.-->O output_value1        |                          |
| +-----+       |                          ||.->O output_value2        |                          |
| | DOT |-------'  +------+                |||.>O conditional_operator |                          |
| +-----+          | 1.0f |----------------'||| +----------------------+                          |
|                  +------+                 |||                                                   |
|-------------------------------------------'||                                                   |
|                  +-------------+           ||                                                   |
|                  | Zero colour |-----------'|                                                   |
|                  +-------------+            |                                                   |
|                                             |                                                   |
|                  +---------+                |                                                   |
|                  | GREATER |----------------'                                                   |
|                  +---------+                                                                    |
|                                                                                                 |
| .-----------------------------------------------------------------------------------------------'
| |
| |
| |    +------------+     +--------------+
| |    | Blur Node  |     | Render Node  |
| |    |============|     |==============| ~~~~~ --.
| '--->O input_node |---->O colour_input |         |
|      +------------+     +--------------+         |
|                                                  |
|           .--------------------------------------'
|           |
|           |   +---------------------+
|           |   | Arithmetic Node     |        +--------------+
|           |   |=====================|        | Render Node  |
|           '-->O value1              |        |==============|~~~~~~~~~~> Screen
'-------------->O value2              |------->O colour_input |
            .-->O arithmetic operator |        +--------------+
 +-----+    |   +---------------------+
 | ADD |----'
 +-----+
```

### [`jobs`](/include/iris/jobs)
Iris doesn't use separate threads for each component (e.g. one thread for rendering and another for physics) instead it provides an API for executing independent jobs. This allows for a more scalable approach to parallelism without having to worry about synchronisation between components.

A [`job`](/include/iris/jobs/job.h) represents a function call and can be a named function or a lambda.

Note that a key part of the design is to allow jobs to schedule other jobs with either method.

Provided in the engine are two implementations of the [`job_system`](/include/iris/jobs/job_system.h):

**Threads**

This uses [`std::async`](https://en.cppreference.com/w/cpp/thread/async) to create threads for each job. This is a simple and robust implementation that will work on any supported platform.

**Fibers**

There are two problems with the threading implementation:
1. Overheard of OS scheduling threads
2. If a job calls `wait_for_jobs()` it will block, meaning we lose one thread until it is complete

Fibers attempts to overcome both these issues. A [Fiber](https://en.wikipedia.org/wiki/Fiber_(computer_science)) is a userland execution primitive and yield themselves rather than relying on the OS. When the [FiberJobSystem](/src/jobs/fiber/fiber_job_system.cpp) starts it creates a series of worker threads. When a job is scheduled a Fiber is created for it and placed on a queue, which the worker threads pick up and execute. The key difference between just running on the threads is that if a Fiber calls `wait_for_jobs()` it will suspend and place itself back on the queue thus freeing up that worker thread to work on something else. This means fibers are free to migrate between threads and will not necessarily finish on the thread that started it.

Fibers are supported on Win32 natively and on Posix iris has an [x86_64](/include/iris/jobs/arch/x86_64/functions.S) [implementation](/src/jobs/fiber/posix/fiber.cpp). They are not currently supported on iOS.

### [`log`](/include/iris/log)
Iris provides a logging framework, which a user is under no obligation to use. The four log levels are:
1. DEBUG
2. INFO
3. WARN
3. ERROR

Logging is stripped in release. Internally iris uses an engine specific overload of the logging functions which are disabled by default unless you use `start_debug()` instead if `start()`.

Logging can be configured to use different outputters and formatters. Currently supported are:
* stdout outputter
* file outputter
* basic text formatter
* ansi terminal colouring formatter
* emoji formatter

To log use the macros defined in [`log.h`](/include/iris/log/log.h). The format of a log message is tag, message, args. This allows a user to filter out certain tags.
```c++
LOG_DEBUG("tag", "position: {} health: {}", iris::Vector3{1.0f, 2.0f, 3.0f}, 100.0f);
```

### [`networking`](/include/iris/networking)
Networking consists of a series of layered primitives, each one building on the one below and providing additional functionality. A user can use any (or none) of these primitives as they see fit.

**Socket/ServerSocket**

[`Socket`](/include/iris/networking/socket.h) and [`ServerSocket`](/include/iris/networking/server_socket.h) are the lowest level primitives and provide an in interface for transferring raw bytes. There are currently two implementations of these interfaces:
* [`UdpSocket`](/include/iris/networking/udp_socket.h) / [`UdpServerSocket`](/include/iris/networking/udp_server_socket.h) - unreliable networking protocol
* [`SimulatedSocket`](/include/iris/networking/simulated_socket.h) / [`SimulatedServerSocket`](/include/iris/networking/simulated_server_socket.h) - a `Socket` adaptor that allows a user to simulate certain networking conditions e.g. packet drop and delay

**Channels**

A [`Channel`](/include/iris/networking/channel/channel.h) provides guarantees over an unreliable networking protocol. It doesn't actually do any sending/receiving but buffers [`Packet`](/include/iris/networking/packet.h) objects and only yields them when certain conditions are met. Current channels are:
* [`UnreliableUnorderedChannel`](/include/iris/networking/channel/unreliable_unordered_channel.h) - provides no guarantees
* [`UnreliableSequencedChannel`](/include/iris/networking/channel/unreliable_sequenced_channel.h) - packets are in order, no duplicates but may have gaps
* [`ReliableOrderedChannel`](/include/iris/networking/channel/reliable_ordered_channel.h) - packets are in order, no gaps, no duplicates and guaranteed to arrive

**ClientConnectionHandler/ServerConnectionHandler**

[`ClientConnectionHandler`](/include/iris/networking/client_connection_handler.h) and [`ServerConnectionHandler`](/include/iris/networking/server_connection_handler.h) implement a lightweight protocol providing:
* Making a connection
* Handshake
* Clock sync
* Sending/receiving data

### [`physics`](/include/iris/physics)
Iris comes with bullet physics out the box. The [`physics_system`](/include/iris/physics/physics_system.h) abstract class details the provided functionality.

### [`scripting`](/include/iris/scripting)
Iris supports [Lua](https://www.lua.org/home.html) out of the box. The recommended way to use it is with the [`ScriptRunner`](/include/iris/scripting/script_runner.h) primitive.

```cpp
    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(
        function go()
            print('hello')
        end)")};
    runner.execute("go");
```

The return type of `execute` will be deduced based on the supplied template arguments, this allows for intuitive handling of void, single and multi argument functions.

```cpp
    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(
        function func1()
            print('hello')
        end

        function func2()
            return 1
        end

        function func3()
            return 'hello', 2.0
        end)")};

    // no arguments so execute returns void
    runner.execute("func1");

    // single type, so supplied type is returned
    const std::int32_t r1 = runner.execute<std::int32_t>("func2");

    // multiple types, so tuple of supplied types are returned   
    const std::tuple<std::string, float> r2 = runner.execute<std::string, float>("func3");
```

Lua scripts call also use (as well as return) [`Vector3`](/include/iris/core/vector3.h) and [`Quaternion`](/include/iris/core/quaternion.h) types. See [tests](/tests/scripting/lua_script_tests.cpp) for more examples.

```

`cmake/iris-config.cmake.in`:

```in
@PACKAGE_INIT@

if(NOT TARGET iris::iris)
    include(${CMAKE_CURRENT_LIST_DIR}/iris-targets.cmake)
endif()
```

`include/iris/concepts/is_pointer.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <type_traits>

namespace iris
{

template <class T>
concept IsPointer = std::is_pointer_v<T>;

}

```

`include/iris/core/auto_release.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <functional>
#include <type_traits>

#include "concepts/is_pointer.h"

namespace iris
{

/**
 * Generic RAII class for taking ownership of a resource and releasing it when
 * this class goes out of scope.
 */
template <class T, T Invalid>
class AutoRelease
{
  public:
    /**
     * Construct a new AutoRelease which doesn't own any object.
     */
    AutoRelease()
        : AutoRelease(Invalid, nullptr)
    {
    }

    /**
     * Construct a new AutoRelease which takes ownership of a resource
     *
     * @param resource
     *   Resource to own
     *
     * @param deleter
     *   Function to release resource at end of scope.
     */
    AutoRelease(T resource, std::function<void(T)> deleter)
        : resource_(resource)
        , deleter_(deleter)
    {
    }

    /**
     * Release resource with supplied deleter.
     */
    ~AutoRelease()
    {
        if ((resource_ != Invalid) && deleter_)
        {
            deleter_(resource_);
        }
    }

    /**
     * Move constructor. Steals ownership from supplied object.
     *
     * @param other
     *   Object to move construct from.
     */
    AutoRelease(AutoRelease<T, Invalid> &&other) noexcept
        : AutoRelease(Invalid, {})
    {
        swap(other);
    }

    /**
     * Move assignment. Steals ownership from supplied object.
     *
     * @param other
     *   Object to move assign from.
     */
    AutoRelease<T, Invalid> &operator=(AutoRelease<T, Invalid> &&other)
    {
        AutoRelease<T, Invalid> new_auto_release{std::move(other)};
        swap(new_auto_release);

        return *this;
    }

    AutoRelease(const AutoRelease<T, Invalid> &) = delete;
    AutoRelease<T, Invalid> &operator=(AutoRelease<T, Invalid> &) = delete;

    /**
     * Swap this object with another.
     *
     * @param other
     *   Object to swap with.
     */
    void swap(AutoRelease<T, Invalid> &other) noexcept
    {
        std::swap(resource_, other.resource_);
        std::swap(deleter_, other.deleter_);
    }

    /**
     * Get the managed resource.
     *
     * @returns
     *   Managed resource.
     */
    T get() const noexcept
    {
        return resource_;
    }

    /**
     * Get the address of the internally managed resource. This is useful if we
     * are managing a pointer and need to pass that to another function to get
     * set.
     *
     * @returns
     *   Address of managed resource.
     */
    T *operator&() noexcept
    {
        return std::addressof(resource_);
    }

    /**
     * Overload arrow operator (for pointer objects only).
     *
     * @returns
     *   Copy of resource (will be a pointer).
     */
    T operator->() const noexcept requires IsPointer<T>
    {
        return resource_;
    }

    /**
     * Get if this object manages a resource.
     *
     * @returns
     *   True if this object managed a resource, false otherwise.
     */
    explicit operator bool() const noexcept
    {
        return resource_ != Invalid;
    }

    /**
     * Cast operator.
     *
     * @returns
     *   Managed resource.
     */
    operator T() const noexcept
    {
        return resource_;
    }

  private:
    /** Managed resource. */
    T resource_;

    /** Resource delete function. */
    std::function<void(T)> deleter_;
};

}

```

`include/iris/core/camera.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>

#include "core/camera_type.h"
#include "core/matrix4.h"
#include "core/quaternion.h"
#include "core/vector3.h"

namespace iris
{

/**
 * Class representing the camera through which a scene is rendered.
 */
class Camera
{
  public:
    /**
     * Create a new camera, positioned at the origin.
     *
     * @param
     *   Type of camera.
     *
     * @param width
     *   Width of window.
     *
     * @param height
     *   Height of window.
     *
     * @param depth
     *   Depth of projection.
     */
    Camera(CameraType type, std::uint32_t width, std::uint32_t height, std::uint32_t depth = 1000u);

    /**
     * Translate the camera.
     *
     * @param translate
     *   Amount to translate.
     */
    void translate(const Vector3 &translat);

    /**
     * Set the view matrix for the camera.
     *
     * @param view
     *   New view matrix.
     */
    void set_view(const Matrix4 &view);

    /**
     * Get position of camera.
     *
     * @returns
     *   Camera position in world space.
     */
    Vector3 position() const;

    /**
     * Get orientation of camera.
     *
     * @returns
     *   Camera orientation.
     */
    Quaternion orientation() const;

    /**
     * Get direction camera is facing.
     *
     * @returns
     *   Camera direction.
     */
    Vector3 direction() const;

    /**
     * Get the right vector of the camera.
     *
     * @returns
     *   Camera right vector.
     */
    Vector3 right() const;

    /**
     * Get the view matrix4.
     *
     * @returns
     *   View matrix4.
     */
    Matrix4 view() const;

    /**
     * Get the projection matrix4.
     *
     * @returns
     *   Projection matrix4.
     */
    Matrix4 projection() const;

    /**
     * Get camera yaw.
     *
     * @returns
     *   Camera yaw.
     */
    float yaw() const;

    /**
     * Set the yaw of the camera.
     *
     * @param yaw
     *   New camera yaw.
     */
    void set_yaw(float yaw);

    /**
     * Adjust the camera yaw by the supplied value.
     *
     * @param adjust
     *   Amount to adjust yaw by.
     */
    void adjust_yaw(float adjust);

    /**
     * Get camera pitch.
     *
     * @returns
     *   Camera pitch.
     */
    float pitch() const;

    /**
     * Set the pitch of the camera.
     *
     * @param pitch
     *   New camera pitch.
     */
    void set_pitch(float pitch);

    /**
     * Adjust the camera pitch by the supplied value.
     *
     * @param adjust
     *   Amount to adjust pitch by.
     */
    void adjust_pitch(float adjust);

    /**
     * Set world position of camera.
     *
     * @param position
     *   New position.
     */
    void set_position(const Vector3 &position);

    /**
     * Get type of camera.
     *
     * @returns
     *   Camera type.
     */
    CameraType type() const;

  private:
    /** Camera position in world space. */
    Vector3 position_;

    /** Direction camera is facing. */
    Vector3 direction_;

    /** Camera up vector. */
    Vector3 up_;

    /** View Matrix4 for the camera. */
    Matrix4 view_;

    /** Projection Matrix4 for the camera. */
    Matrix4 projection_;

    /** Pitch of camera. */
    float pitch_;

    /** Yaw of camera. */
    float yaw_;

    /** Type of camera. */
    CameraType type_;
};

}

```

`include/iris/core/camera_type.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>

namespace iris
{

/**
 * Enumeration of camera types.
 */
enum class CameraType : std::uint8_t
{
    PERSPECTIVE,
    ORTHOGRAPHIC
};

}

```

`include/iris/core/colour.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <cstdint>
#include <functional>
#include <ostream>

#include "core/utils.h"

namespace iris
{
/**
 * A colour with red, green, blue and alpha components.
 */
class Colour
{
  public:
    /**
     * Create a black colour.
     */
    constexpr Colour()
        : Colour(0.0f, 0.0f, 0.0f, 1.0f)
    {
    }

    /**
     * Create a new colour with float components.
     *
     * @param r
     *   Red.
     *
     * @param g
     *   Green.
     *
     * @param b
     *   Blue.
     *
     * @param a
     *   Alpha.
     */
    constexpr Colour(float r, float g, float b, float a = 1.0f)
        : r(r)
        , g(g)
        , b(b)
        , a(a)
    {
    }

    /**
     * Create a new colour from another but specify the alpha.
     *
     * @param rgb
     *   Colour to get rgb from
     *
     * @param a
     *   Alpha.
     */
    constexpr Colour(const Colour &rgb, float a)
        : r(rgb.r)
        , g(rgb.g)
        , b(rgb.b)
        , a(a)
    {
    }

    /**
     * Create a new colour with integer components.
     *
     * Ideally this would take the values as std::uint8_t, but this causes an
     * ambiguity when integers are passes with the float constructor.
     *
     * @param r
     *   Red.
     *
     * @param g
     *   Green.
     *
     * @param b
     *   Blue.
     *
     * @param a
     *   Alpha.
     */
    constexpr Colour(std::int32_t r, std::int32_t g, std::int32_t b, std::int32_t a = 255)
        : Colour(
              static_cast<float>(r) / 255.0f,
              static_cast<float>(g) / 255.0f,
              static_cast<float>(b) / 255.0f,
              static_cast<float>(a) / 255.0f)
    {
    }

    /**
     * Multiply each component by a scalar value.
     *
     * @param scale
     *   Scalar value.
     *
     * @return
     *   Reference to this Colour.
     */
    constexpr Colour &operator*=(float scale)
    {
        r *= scale;
        g *= scale;
        b *= scale;
        a *= scale;

        return *this;
    }

    /**
     * Create a new Colour which is this Colour with each component
     * multiplied by a scalar value.
     *
     * @param scale
     *   scalar value.
     *
     * @return
     *   Copy of this Colour with each component multiplied by a
     *   scalar value.
     */
    constexpr Colour operator*(float scale) const
    {
        return Colour(*this) *= scale;
    }

    /**
     * Component wise add a Colour to this Colour.
     *
     * @param colour
     *   The Colour to add to this.
     *
     * @return
     *   Reference to this colour.
     */
    constexpr Colour &operator+=(const Colour &colour)
    {
        r += colour.r;
        g += colour.g;
        b += colour.b;
        a += colour.a;

        return *this;
    }

    /**
     * Create a new Colour which is this Colour added with a supplied
     * Colour.
     *
     * @param colour
     *   Colour to add to this.
     *
     * @return
     *   Copy of this Colour with each component added to the
     *   components of the supplied Colour.
     */
    constexpr Colour operator+(const Colour &colour) const
    {
        return Colour(*this) += colour;
    }

    /**
     * Component wise subtract a Colour to this Colour.
     *
     * @param v
     *   The Colour to subtract from this.
     *
     * @return
     *   Reference to this Colour.
     */
    constexpr Colour &operator-=(const Colour &colour)
    {
        r -= colour.r;
        g -= colour.g;
        b -= colour.b;
        a -= colour.a;

        return *this;
    }

    /**
     * Create a new Colour which is this Colour subtracted with a
     * supplied Colour.
     *
     * @param colour
     *   Colour to subtract from this.
     *
     * @return
     *   Copy of this Colour with each component subtracted to the
     *   components of the supplied Colour.
     */
    constexpr Colour operator-(const Colour &colour) const
    {
        return Colour(*this) -= colour;
    }

    /**
     * Component wise multiple a Colour to this Colour.
     *
     * @param colour
     *   The Colour to multiply.
     *
     * @returns
     *   Reference to this Colour.
     */
    constexpr Colour &operator*=(const Colour &colour)
    {
        r *= colour.r;
        g *= colour.g;
        b *= colour.b;
        a *= colour.a;

        return *this;
    }

    /**
     * Create a new Colour which us this Colour component wise multiplied
     * with a supplied Colour.
     *
     * @param colour
     *   Colour to multiply with this.
     *
     * @returns
     *   Copy of this Colour component wise multiplied with the supplied
     *   Colour.
     */
    constexpr Colour operator*(const Colour &colour) const
    {
        return Colour{*this} *= colour;
    }

    /**
     * Check if this colour is equal to another.
     *
     * @param other
     *   Colour to compare with.
     *
     * @returns
     *   True if both Colours are equal, otherwise false.
     */
    bool operator==(const Colour &other) const
    {
        return compare(r, other.r) && compare(g, other.g) && compare(b, other.b) && compare(a, other.a);
    }

    /**
     * Check if this colour is not equal to another.
     *
     * @param other
     *   Colour to compare with.
     *
     * @returns
     *   True if both Colours are unequal, otherwise false.
     */
    bool operator!=(const Colour &other) const
    {
        return !(other == *this);
    }

    /**
     * Linear interpolate between this and another colour.
     *
     * @param other
     *   Colour to interpolate to.
     *
     * @param amount
     *   Interpolation amount, must be in range [0.0, 1.0].
     */
    constexpr void lerp(const Colour &other, float amount)
    {
        *this *= (1.0f - amount);
        *this += (other * amount);
    }

    /**
     * Linear interpolate between two colours.
     *
     * @param start
     *   Colour to start from.
     *
     * @param end
     *   Colour to lerp towards.
     *
     * @param amount
     *   Interpolation amount, must be in range [0.0, 1.0].
     *
     * @returns
     *   Result of lerp.
     */
    constexpr static Colour lerp(const Colour &start, const Colour &end, float amount)
    {
        auto tmp = start;
        tmp.lerp(end, amount);

        return tmp;
    }

    /** Red. */
    float r;

    /** Green. */
    float g;

    /** Blue. */
    float b;

    /** Alpha. */
    float a;
};

/**
 * Write a Colour to a stream, useful for debugging.
 *
 * @param out
 *   Stream to write to.
 *
 * @param c
 *   Colour to write to stream.
 *
 * @return
 *   Reference to input stream.
 */
inline std::ostream &operator<<(std::ostream &out, const Colour &c)
{
    out << "r: " << c.r << " "
        << "g: " << c.g << " "
        << "b: " << c.b << " "
        << "a: " << c.a;

    return out;
}

}

// specialise std::hash for colour
namespace std
{
template <>
struct hash<iris::Colour>
{
    size_t operator()(const iris::Colour &colour) const
    {
        return iris::combine_hash(colour.r, colour.g, colour.b, colour.a);
    }
};

}

```

`include/iris/core/context.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <memory>
#include <string>
#include <unordered_map>
#include <vector>

namespace iris
{

class JobSystemManager;
class MaterialManager;
class RenderTargetManager;
class MeshManager;
class PhysicsManager;
class TextureManager;
class WindowManager;
class ResourceManager;

/**
 * This class allows for the runtime registration and retrieval of various manager classes. It is automatically created
 * by the engine and passed to the user via the entry function provided tio start().
 *
 * These managers are factory classes that can create engine components, the reason for all this machinery is:
 *  - it decouples actual implementation from the Context
 *  - start() can register all supported mangers for the current platform and set sane defaults
 *  - allows a user to register their own implementations (e.g. for a different physics library)
 */
class Context
{
  public:
    /**
     * Construct a new Context.
     *
     * @param argc
     *   Program argc.
     *
     * @param argv
     *   Program argv.
     */
    Context(int argc, char **argv);
    ~Context();

    Context(const Context &) = delete;
    Context &operator=(const Context &) = delete;
    Context(Context &&);
    Context &operator=(Context &&);

    /**
     * Get the program arguments.
     *
     * @returns
     *   Collection of program arguments.
     */
    const std::vector<std::string> &args() const;

    /**
     * Get the current WindowManager.
     *
     * @returns
     *   Current WindowManager.
     */
    WindowManager &window_manager() const;

    /**
     * Get the current MeshManager.
     *
     * @returns
     *   Current MeshManager.
     */
    MeshManager &mesh_manager() const;

    /**
     * Get the current TextureManager.
     *
     * @returns
     *   Current TextureManager.
     */
    TextureManager &texture_manager() const;

    /**
     * Get the current MaterialManager.
     *
     * @returns
     *   Current MaterialManager.
     */
    MaterialManager &material_manager() const;

    /**
     * Get the current RenderTargetManager.
     *
     * @returns
     *   Current RenderTargetManager.
     */
    RenderTargetManager &render_target_manager() const;

    /**
     * Get the current PhysicsManager.
     *
     * @returns
     *   Current PhysicsManager.
     */
    PhysicsManager &physics_manager() const;

    /**
     * Get the current JobSystemManager.
     *
     * @returns
     *   Current JobSystemManager.
     */
    JobSystemManager &jobs_manager() const;

    /**
     * Get the current ResourceManager.
     *
     * @returns
     *   Current ResourceManager.
     */
    ResourceManager &resource_manager() const;

    /**
     * Register managers for a given api name.
     *
     * @param api
     *   Name of api to register managers to,
     *
     * @param window_manager
     *   New WindowManager.
     *
     * @param mesh_manager
     *   New MeshManager.
     *
     * @param texture_manager
     *   New TextureManager.
     *
     * @param material_manager
     *   New MaterialManager.
     *
     * @param RenderTargetManager
     *   New RenderTargetManager.
     */
    void register_graphics_api(
        const std::string &api,
        std::unique_ptr<WindowManager> window_manager,
        std::unique_ptr<MeshManager> mesh_manager,
        std::unique_ptr<TextureManager> texture_manager,
        std::unique_ptr<MaterialManager> material_manager,
        std::unique_ptr<RenderTargetManager> render_target_manager);

    /**
     * Get the currently set graphics api.
     *
     * @returns
     *   Name of currently set graphics api.
     */
    std::string graphics_api() const;

    /**
     * Set the current graphics api.
     *
     * @param api
     *   New graphics api name.
     */
    void set_graphics_api(const std::string &api);

    /**
     * Get a collection of all registered api names.
     *
     * @returns
     *   Collection of registered api names.
     */
    std::vector<std::string> registered_graphics_apis() const;

    /**
     * Register managers for a given api name.
     *
     * @param api
     *   Name of api to register managers to,
     *
     * @param physics_manager
     *   New PhysicsManager.
     */
    void register_physics_api(const std::string &api, std::unique_ptr<PhysicsManager> physics_manager);

    /**
     * Get the currently set physics api.
     *
     * @returns
     *   Name of currently set physics api.
     */
    std::string physics_api() const;

    /**
     * Set the current physics api.
     *
     * @param api
     *   New physics api name.
     */
    void set_physics_api(const std::string &api);

    /**
     * Get a collection of all registered api names.
     *
     * @returns
     *   Collection of registered api names.
     */
    std::vector<std::string> registered_physics_apis() const;

    /**
     * Register managers for a given api name.
     *
     * @param api
     *   Name of api to register managers to,
     *
     * @param jobs_manager
     *   New JobSystemManager.
     */
    void register_jobs_api(const std::string &api, std::unique_ptr<JobSystemManager> jobs_manager);

    /**
     * Get the currently set jobs api.
     *
     * @returns
     *   Name of currently set jobs api.
     */
    std::string jobs_api() const;

    /**
     * Set the current jobs api.
     *
     * @param api
     *   New jobs api name.
     */
    void set_jobs_api(const std::string &api);

    /**
     * Get a collection of all registered api names.
     *
     * @returns
     *   Collection of registered api names.
     */
    std::vector<std::string> registered_jobs_apis() const;

    /**
     * Set the resource manager object.
     *
     * @param resource_manager
     *   New resource manager.
     */
    void set_resource_manager(std::unique_ptr<ResourceManager> resource_manager);

  private:
    /**
     * Helper struct encapsulating all managers for a graphics api.
     *
     * Note that the member order is important, we want the WindowManager to be destroyed first as some implementations
     * require the Renderer destructor to wait for gpu operations to finish before destroying other resources.
     */
    struct GraphicsApiManagers
    {
        std::unique_ptr<MeshManager> mesh_manager;
        std::unique_ptr<TextureManager> texture_manager;
        std::unique_ptr<MaterialManager> material_manager;
        std::unique_ptr<RenderTargetManager> render_target_manager;
        std::unique_ptr<WindowManager> window_manager;
    };

    /** Map of graphics api name to managers. */
    std::unordered_map<std::string, GraphicsApiManagers> graphics_api_managers_;

    /** Name of current graphics api. */
    std::string graphics_api_;

    /** Map of physics api name to managers. */
    std::unordered_map<std::string, std::unique_ptr<PhysicsManager>> physics_api_managers_;

    /** Name of current physics api. */
    std::string physics_api_;

    /** Map of jobs api name to managers. */
    std::unordered_map<std::string, std::unique_ptr<JobSystemManager>> jobs_api_managers_;

    /** Name of current jobs api. */
    std::string jobs_api_;

    /** Resource manager object. */
    std::unique_ptr<ResourceManager> resource_manager_;

    /** Collection of program arguments. */
    std::vector<std::string> args_;
};

}

```

`include/iris/core/data_buffer.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <vector>

namespace iris
{

using DataBuffer = std::vector<std::byte>;

}

```

`include/iris/core/default_resource_manager.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <string_view>

#include "core/data_buffer.h"
#include "core/resource_manager.h"

namespace iris
{

/**
 * Implementation of ResourceManager which loads resources off disk, relative to root.
 */
class DefaultResourceManager : public ResourceManager
{
  protected:
    /**
     * Load data frm disk.
     *
     * @param resource
     *   Name of resource.
     *
     * @returns
     *   Loaded data.
     */
    DataBuffer do_load(std::string_view resource) override;
};

}

```

`include/iris/core/error_handling.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdlib>
#include <functional>
#include <iostream>
#include <memory>
#include <optional>
#include <sstream>
#include <string>
#include <string_view>
#include <type_traits>

#if !defined(__clang__)
#include <source_location>
#endif

#if defined(IRIS_PLATFORM_WIN32)
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#endif

#include "core/auto_release.h"
#include "core/exception.h"

namespace iris
{

namespace impl
{

/**
 * Helper function to check an assertion and, if it's false, either log and
 * abort or throw an exception.
 *
 * @param assertion
 *   The assertion to check.
 *
 * @param message
 *   A user supplied message to either log (if abort) or throw with.
 *
 * @param line
 *   The source code line where the check was called from.
 *
 * @param file_name
 *   The file name where the check was called from.
 *
 * @param function_name
 *   The function where the check was called from.
 *
 * @param drop_mic
 *   If true then log and abort on assertion failure, else throw exception.
 */
inline void check_and_handle(
    bool assertion,
    std::string_view message,
    int line,
    const char *file_name,
    const char *function_name,
    bool drop_mic)
{
    if (!assertion)
    {
        std::stringstream strm{};

        // combine the user supplied message with the source location
        strm << message << " -> " << file_name << "(" << line << ") `" << function_name << "`";

        if (drop_mic)
        {
            // note we don't use the logging framework here as we don't know
            // how it's been configured, safest just to write to stderr
            std::cerr << strm.str() << std::endl;
            std::abort();
        }
        else
        {
            throw Exception(strm.str());
        }
    }
}

}

// define a platform specific macro that will break to an attached debugger
// this is useful if we cannot set a breakpoint in an IDE, for example as of
// writing VSCode cannot set a breakpoint in an objc++ (.mm) file
#if defined(IRIS_PLATFORM_WIN32)
#define IRIS_DEBUG_BREAK()                                                                                             \
    do                                                                                                                 \
    {                                                                                                                  \
        DebugBreak();                                                                                                  \
    } while (false)
#else
#if defined(IRIS_ARCH_X86_64)
#define IRIS_DEBUG_BREAK()                                                                                             \
    do                                                                                                                 \
    {                                                                                                                  \
        asm("int3");                                                                                                   \
    } while (false)
#elif defined(IRIS_ARCH_ARM64)
#define IRIS_DEBUG_BREAK()                                                                                             \
    do                                                                                                                 \
    {                                                                                                                  \
        __builtin_debugtrap();                                                                                         \
    } while (false)
#else
#error unsupported architecture
#endif
#endif

// here we define expect and ensure functions for error handling
// usage:
//   expect - check an unrecoverable invariant holds i.e. something that should always be true
//            will call abort on failure and is stripped from release builds
//   ensure - check a recoverable invariant holds i.e. something we want to verify at runtime
//            will throw an exception on failure and is never stripped
//
// annoyingly (as of writing) clang does not support std::source_location so we
// define two versions, one which uses the standard and another which uses
// clangs builtins
//
// we define the various expect/ensure functions below for different compiles
// and debug/release versions

#if !defined(NDEBUG) || defined(IRIS_FORCE_EXPECT)

#if defined(__clang__)
/**
 * Check invariant and abort on failure.
 *
 * @param expectation
 *   The assertion to check.
 *
 * @param message
 *   A user supplied message to log before abort.
 */
inline void expect(
    bool expectation,
    std::string_view message,
    int line = __builtin_LINE(),
    const char *file_name = __builtin_FILE(),
    const char *function_name = __builtin_FUNCTION())
{
    impl::check_and_handle(expectation, message, line, file_name, function_name, true);
}

/**
 * Check invariant and abort on failure. This specialisation allows a callback
 * to determine if an error occurred. This is useful if errors are detected
 * via some global state and need checking via a function e.g. glGetError.
 *
 * @param check_error
 *   Callback to determine if an error occurred. message is passed as the
 *   argument. The return value should be an en empty optional if no error
 *   occurred or an error message otherwise.
 *
 * @param message
 *   A user supplied message to log before abort.
 */
inline void expect(
    std::function<std::optional<std::string>(std::string_view)> check_error,
    std::string_view message,
    int line = __builtin_LINE(),
    const char *file_name = __builtin_FILE(),
    const char *function_name = __builtin_FUNCTION())
{
    if (const auto final_message = check_error(message); final_message)
    {
        impl::check_and_handle(false, *final_message, line, file_name, function_name, true);
    }
}

/**
 * Check invariant and abort on failure. This specialisation checks if a
 * unique_ptr is nullptr.
 *
 * @param ptr
 *   unique_ptr to check for nullptr.
 *
 * @param message
 *   A user supplied message to log before abort.
 */
template <class T>
inline void expect(
    const std::unique_ptr<T> &ptr,
    std::string_view message,
    int line = __builtin_LINE(),
    const char *file_name = __builtin_FILE(),
    const char *function_name = __builtin_FUNCTION())
{
    impl::check_and_handle(!!ptr, message, line, file_name, function_name, true);
}

/**
 * Check invariant and abort on failure. This specialisation checks if an
 * AutoRelease manages an object.
 *
 * @param auto_release
 *   AutoRelease to check.
 *
 * @param message
 *   A user supplied message to log before abort.
 */
template <class T, T Invalid>
inline void expect(
    const AutoRelease<T, Invalid> &auto_release,
    std::string_view message,
    int line = __builtin_LINE(),
    const char *file_name = __builtin_FILE(),
    const char *function_name = __builtin_FUNCTION())
{
    impl::check_and_handle(!!auto_release, message, line, file_name, function_name, true);
}

#else

// see __clang__ defines for documentation

inline void expect(
    bool expectation,
    std::string_view message,
    std::source_location location = std::source_location::current())
{
    impl::check_and_handle(expectation, message, location.line(), location.file_name(), location.function_name(), true);
}

inline void expect(
    std::function<std::optional<std::string>(std::string_view)> check_error,
    std::string_view message,
    std::source_location location = std::source_location::current())
{
    if (const auto final_message = check_error(message); final_message)
    {
        impl::check_and_handle(
            false, *final_message, location.line(), location.file_name(), location.function_name(), true);
    }
}

template <class T>
inline void expect(
    const std::unique_ptr<T> &ptr,
    std::string_view message,
    std::source_location location = std::source_location::current())
{
    impl::check_and_handle(!!ptr, message, location.line(), location.file_name(), location.function_name(), true);
}

template <class T, T Invalid>
inline void expect(
    const AutoRelease<T, Invalid> &auto_release,
    std::string_view message,
    std::source_location location = std::source_location::current())
{
    impl::check_and_handle(
        !!auto_release, message, location.line(), location.file_name(), location.function_name(), true);
}

#endif

#else

#if defined(__clang__)

inline void expect(
    bool,
    std::string_view,
    int = __builtin_LINE(),
    const char * = __builtin_FILE(),
    const char * = __builtin_FUNCTION())
{
}

inline void expect(
    std::function<std::optional<std::string>(std::string_view)>,
    std::string_view,
    int = __builtin_LINE(),
    const char * = __builtin_FILE(),
    const char * = __builtin_FUNCTION())
{
}

template <class T>
inline void expect(
    const std::unique_ptr<T> &,
    std::string_view,
    int = __builtin_LINE(),
    const char * = __builtin_FILE(),
    const char * = __builtin_FUNCTION())
{
}

template <class T, T Invalid>
inline void expect(
    const AutoRelease<T, Invalid> &,
    std::string_view,
    int = __builtin_LINE(),
    const char * = __builtin_FILE(),
    const char * = __builtin_FUNCTION())
{
}

#else

inline void expect(bool, std::string_view, std::source_location = std::source_location::current())
{
}

inline void expect(
    std::function<std::optional<std::string>(std::string_view)>,
    std::string_view,
    std::source_location = std::source_location::current())
{
}

template <class T>
inline void expect(const std::unique_ptr<T> &, std::string_view, std::source_location = std::source_location::current())
{
}

template <class T, T Invalid>
inline void expect(
    const AutoRelease<T, Invalid> &,
    std::string_view,
    std::source_location = std::source_location::current())
{
}

#endif

#endif

#if defined(__clang__)

/**
 * Check pre/post-condition and throw on failure.
 *
 * @param expectation
 *   The assertion to check.
 *
 * @param message
 *   A user supplied message to throw.
 */
inline void ensure(
    bool expectation,
    std::string_view message,
    int line = __builtin_LINE(),
    const char *file_name = __builtin_FILE(),
    const char *function_name = __builtin_FUNCTION())
{
    impl::check_and_handle(expectation, message, line, file_name, function_name, false);
}

/**
 * Check pre/post-condition and throw on failure. This specialisation allows a
 * callback to determine if an error occurred. This is useful if errors are
 * detected via some global state and need checking via a function e.g.
 * glGetError.
 *
 * @param check_error
 *   Callback to determine if an error occurred. message is passed as the
 *   argument. The return value should be an en empty optional if no error
 *   occurred or an error message otherwise.
 *
 * @param message
 *   A user supplied message to log before abort.
 */
inline void ensure(
    std::function<std::optional<std::string>(std::string_view)> check_error,
    std::string_view message,
    int line = __builtin_LINE(),
    const char *file_name = __builtin_FILE(),
    const char *function_name = __builtin_FUNCTION())
{
    if (const auto final_message = check_error(message); final_message)
    {
        impl::check_and_handle(false, *final_message, line, file_name, function_name, false);
    }
}

/**
 * Check pre/post-condition and throw on failure. This specialisation checks if
 * a unique_ptr is nullptr.
 *
 * @param ptr
 *   unique_ptr to check for nullptr.
 *
 * @param message
 *   A user supplied message to log before abort.
 */
template <class T>
inline void ensure(
    const std::unique_ptr<T> &ptr,
    std::string_view message,
    int line = __builtin_LINE(),
    const char *file_name = __builtin_FILE(),
    const char *function_name = __builtin_FUNCTION())
{
    impl::check_and_handle(!!ptr, message, line, file_name, function_name, false);
}

/**
 * Check pre/post-condition and throw on failure. This specialisation checks if
 * an AutoRelease manages an object.
 *
 * @param auto_release
 *   AutoRelease to check.
 *
 * @param message
 *   A user supplied message to log before abort.
 */
template <class T, T Invalid>
inline void ensure(
    const AutoRelease<T, Invalid> &auto_release,
    std::string_view message,
    int line = __builtin_LINE(),
    const char *file_name = __builtin_FILE(),
    const char *function_name = __builtin_FUNCTION())
{
    impl::check_and_handle(!!auto_release, message, line, file_name, function_name, false);
}

#else

// see __clang__ defines for documentation

/**
 * Check pre-condition and throw on failure.
 *
 * @param expectation
 *   The assertion to check.
 *
 * @param message
 *   A user supplied message to throw.
 */
inline void ensure(
    bool expectation,
    std::string_view message,
    std::source_location location = std::source_location::current())
{
    impl::check_and_handle(
        expectation, message, location.line(), location.file_name(), location.function_name(), false);
}

inline void ensure(
    std::function<std::optional<std::string>(std::string_view)> check_error,
    std::string_view message,
    std::source_location location = std::source_location::current())
{
    if (const auto final_message = check_error(message); final_message)
    {
        impl::check_and_handle(
            false, *final_message, location.line(), location.file_name(), location.function_name(), false);
    }
}

template <class T>
inline void ensure(
    const std::unique_ptr<T> &ptr,
    std::string_view message,
    std::source_location location = std::source_location::current())
{
    impl::check_and_handle(!!ptr, message, location.line(), location.file_name(), location.function_name(), false);
}

template <class T, T Invalid>
inline void ensure(
    const AutoRelease<T, Invalid> &auto_release,
    std::string_view message,
    std::source_location location = std::source_location::current())
{
    impl::check_and_handle(
        !!auto_release, message, location.line(), location.file_name(), location.function_name(), false);
}

#endif

}

```

`include/iris/core/exception.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <stdexcept>
#include <string>

namespace iris
{

/**
 * The general exception type for the engine.
 */
class Exception : public std::runtime_error
{
  public:
    /**
     * Construct a new exception.
     *
     * @param what
     *   Exception message.
     */
    explicit Exception(const std::string &what);
};

}

```

`include/iris/core/ios/ios_resource_manager.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <string_view>

#include "core/data_buffer.h"
#include "core/resource_manager.h"

namespace iris
{

/**
 * Implementation of ResourceManager which loads files on iOS.
 */
class IOSResourceManager : public ResourceManager
{
  protected:
    /**
     * Load files from disk o iOS.
     *
     * @param resource
     *   Name of resource.
     *
     * @returns
     *   Loaded data.
     */
    DataBuffer do_load(std::string_view resource) override;
};

}

```

`include/iris/core/ios/utility.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

/**
 * This is an incomplete file and is intended to be included in
 * mac_ios_utility.mm
 *
 * *DO NOT* include this file directly, use macos_ios_utility.h
 */

#import <MetalKit/MetalKit.h>
#import <UIKit/UIKit.h>

#include "core/exception.h"
#include "graphics/ios/metal_view.h"

namespace
{

MetalView *get_view()
{
    const auto *window = [[[UIApplication sharedApplication] windows] objectAtIndex:0];
    if (window == nullptr)
    {
        throw iris::Exception("unable to get main window");
    }

    auto *view = static_cast<MetalView *>([[window rootViewController] view]);
    if (view == nullptr)
    {
        throw iris::Exception("unable to get metal view");
    }

    return view;
}

}

namespace iris::core::utility
{

id<MTLDevice> metal_device()
{
    const auto *view = get_view();

    auto *device = [view device];
    if (device == nullptr)
    {
        throw Exception("unable to get metal device from view");
    }

    return device;
}

CAMetalLayer *metal_layer()
{
    const auto *view = get_view();

    const auto *device = [view device];
    if (device == nullptr)
    {
        throw Exception("unable to get metal device from view");
    }

    auto *layer = [view metalLayer];
    if (layer == nullptr)
    {
        throw Exception("unable to get layer from view");
    }

    return (CAMetalLayer *)layer;
}

}

```

`include/iris/core/looper.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <chrono>
#include <functional>

namespace iris
{

/**
 * This class provides a game looper. It takes two functions, one that is called
 * at a fixed time step and another that is run as frequently as possible. This
 * is based on the https://gafferongames.com/post/fix_your_timestep/ article.
 */
class Looper
{
  public:
    /**
     * Definition of a function to run in loop.
     *
     * @param clock
     *   Total elapsed time since loop started.
     *
     * @param delta
     *   Duration of frame.
     *
     * @returns
     *   True if loop should continue, false if it should exit.
     */
    using LoopFunction = std::function<bool(std::chrono::microseconds, std::chrono::microseconds)>;

    /**
     * Construct a new looper.
     *
     * @param clock
     *   Start time of looping.
     *
     * @param timestep
     *   How frequently to call the fixed time step function.
     *
     * @param fixed_timestep
     *   Function to call at the supplied fixed timestep.
     *
     * @param variable_timestep
     *   Function to call as frequently as possible.
     */
    Looper(
        std::chrono::microseconds clock,
        std::chrono::microseconds timestep,
        LoopFunction fixed_timestep,
        LoopFunction variable_timestep);

    /**
     * Run the loop. Will continue until one of the supplied functions
     * returns false. Clock time will start incrementing from this call.
     */
    void run();

  private:
    /** Elapsed time of loop. */
    std::chrono::microseconds clock_;

    /** Fixed time step. */
    std::chrono::microseconds timestep_;

    /** Function to run at foxed time step. */
    LoopFunction fixed_timestep_;

    /** Function to run at variable time step. */
    LoopFunction variable_timestep_;
};

}

```

`include/iris/core/macos/macos_ios_utility.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <string>

#import <MetalKit/MetalKit.h>

namespace iris::core::utility
{

/**
 * Helper function to convert a std::string to a NSString.
 *
 * @param str
 *   String to convert.
 *
 * @returns
 *   Supplied string converted to NSString.
 */
NSString *string_to_nsstring(const std::string &str);

/**
 * Get the metal device object for the current view.
 *
 * @returns
 *   Metal device.
 */
id<MTLDevice> metal_device();

/**
 * Get the metal layer for the current view.
 *
 * @returns
 *   Metal layer.
 */
CAMetalLayer *metal_layer();

}

```

`include/iris/core/macos/utility.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

/**
 * This is an incomplete file and is intended to be included in
 * mac_ios_utility.mm
 *
 * *DO NOT* include this file directly, use macos_ios_utility.h
 */

#import <Metal/Metal.h>

#include "core/exception.h"

namespace iris::core::utility
{

id<MTLDevice> metal_device()
{
    return ::CGDirectDisplayCopyCurrentMetalDevice(::CGMainDisplayID());
}

CAMetalLayer *metal_layer()
{
    // get a pointer to the main window
    auto *window = [[NSApp windows] firstObject];
    if (window == nullptr)
    {
        throw Exception("could not get main window");
    }

    // get a pointer to the metal layer to render to
    auto *layer = static_cast<CAMetalLayer *>([[window contentView] layer]);
    if (layer == nullptr)
    {
        throw Exception("could not get metal later");
    }

    return layer;
}

}

```

`include/iris/core/matrix4.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <array>
#include <cmath>
#include <ostream>

#include "core/quaternion.h"
#include "core/utils.h"
#include "core/vector3.h"

namespace iris
{

/**
 * Class represents a 4x4 matrix.
 *
 * This is a header only class to allow for constexpr methods.
 */
class Matrix4
{
  public:
    /**
     * Constructs a new identity Matrix4.
     */
    constexpr Matrix4()
        : elements_({{1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f}})
    {
    }

    /**
     * Constructs a new matrix with the supplied (row-major) values.
     *
     * @param elements
     *   Row major elements.
     */
    constexpr explicit Matrix4(const std::array<float, 16> &elements)
        : elements_(elements)
    {
    }

    /**
     * Construct a new Matrix4 which represents a rotation by the
     * supplied quaternion.
     *
     * @param rotation
     *   Rotation to represent.
     */
    constexpr explicit Matrix4(const Quaternion &rotation)
        : Matrix4()
    {
        elements_[0] = 1.0f - 2.0f * rotation.y * rotation.y - 2.0f * rotation.z * rotation.z;
        elements_[1] = 2.0f * rotation.x * rotation.y - 2.0f * rotation.z * rotation.w;
        elements_[2] = 2.0f * rotation.x * rotation.z + 2.0f * rotation.y * rotation.w;

        elements_[4] = 2.0f * rotation.x * rotation.y + 2.0f * rotation.z * rotation.w;
        elements_[5] = 1.0f - 2.0f * rotation.x * rotation.x - 2.0f * rotation.z * rotation.z;
        elements_[6] = 2.0f * rotation.y * rotation.z - 2.0f * rotation.x * rotation.w;

        elements_[8] = 2.0f * rotation.x * rotation.z - 2.0f * rotation.y * rotation.w;
        elements_[9] = 2.0f * rotation.y * rotation.z + 2.0f * rotation.x * rotation.w;
        elements_[10] = 1.0f - 2.0f * rotation.x * rotation.x - 2.0f * rotation.y * rotation.y;

        elements_[15] = 1.0f;
    }

    /**
     * Construct a new Matrix4 which represents a rotation and translation
     * by the supplied Quaternion and vector.
     *
     * @param rotation
     *   Rotation to represent.
     *
     * @param translation
     *   Translation to represent.
     */
    constexpr Matrix4(const Quaternion &rotation, const Vector3 &translation)
        : Matrix4(rotation)
    {
        elements_[3u] = translation.x;
        elements_[7u] = translation.y;
        elements_[11u] = translation.z;
    }

    /**
     * Static method to create an orthographic projection matrix.
     *
     * @param width
     *   width of window.
     *
     * @param height
     *   height of window.
     *
     * @param depth
     *   Depth of rendering view.
     *
     * @returns
     *   An orthographic projection matrix.
     */
    constexpr static Matrix4 make_orthographic_projection(float width, float height, float depth)
    {
        Matrix4 m{};

        const auto right = width;
        const auto left = -right;
        const auto top = height;
        const auto bottom = -top;
        const auto far_plane = depth;
        const auto near_plane = -far_plane;

        m.elements_ = {
            {2.0f / (right - left),
             0.0f,
             0.0f,
             -(right + left) / (right - left),
             0.0f,
             2.0f / (top - bottom),
             0.0f,
             -(top + bottom) / (top - bottom),
             0.0f,
             0.0f,
             -2.0f / (far_plane - near_plane),
             -(far_plane + near_plane) / (far_plane - near_plane),
             0.0f,
             0.0f,
             0.0f,
             1.0f}};

        return m;
    }

    /**
     * Static method to create a perspective projection matrix.
     *
     * @param fov
     *   Field of view.
     *
     * @param width
     *   Width of projection.
     *
     * @param height
     *   Height of projection.
     *
     * @param near_plane
     *   Near clipping plane.
     *
     * @param far_plane
     *   Far clipping plane.
     *
     * @returns
     *   A perspective projection matrix.
     */
    static Matrix4 make_perspective_projection(float fov, float width, float height, float near_plane, float far_plane)
    {
        Matrix4 m;

        const auto aspect_ratio = width / height;
        const auto tmp = ::tanf(fov / 2.0f);
        const auto t = tmp * near_plane;
        const auto b = -t;
        const auto r = t * aspect_ratio;
        const auto l = b * aspect_ratio;

        m.elements_ = {
            {(2.0f * near_plane) / (r - l),
             0.0f,
             (r + l) / (r - l),
             0.0f,
             0.0f,
             (2.0f * near_plane) / (t - b),
             (t + b) / (t - b),
             0.0f,
             0.0f,
             0.0f,
             -(far_plane + near_plane) / (far_plane - near_plane),
             -(2.0f * far_plane * near_plane) / (far_plane - near_plane),
             0.0f,
             0.0f,
             -1.0f,
             0.0f}};

        return m;
    }

    /**
     * Make a Matrix4 that can be used as a view matrix for a camera.
     *
     * @param eye
     *   Position of the camera.
     *
     * @param look_at
     *   The point where the camera is looking.
     *
     * @param up
     *   The up vector of the camera.
     *
     * @returns
     *   A Matrix4 that can be used as a camera view matrix.
     */
    static Matrix4 make_look_at(const Vector3 &eye, const Vector3 &look_at, const Vector3 &up)
    {
        const auto f = Vector3::normalise(look_at - eye);
        const auto up_normalised = Vector3::normalise(up);

        const auto s = Vector3::cross(f, up_normalised).normalise();
        const auto u = Vector3::cross(s, f).normalise();

        Matrix4 m;

        m.elements_ = {{s.x, s.y, s.z, 0.0f, u.x, u.y, u.z, 0.0f, -f.x, -f.y, -f.z, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f}};

        return m * make_translate(-eye);
    }

    /**
     * Static method to create a scale matrix.
     *
     * @param scale
     *   Vector3 specifying amount to scale along each axis.
     *
     * @returns
     *   Scale transformation matrix.
     */
    constexpr static Matrix4 make_scale(const Vector3 &scale)
    {
        Matrix4 m;

        m.elements_ = {
            {scale.x, 0.0f, 0.0f, 0.0f, 0.0f, scale.y, 0.0f, 0.0f, 0.0f, 0.0f, scale.z, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f}};

        return m;
    }

    /**
     * Static method to create translation matrix.
     *
     * @param translate
     *   Vector to translate by.
     */
    constexpr static Matrix4 make_translate(const Vector3 &translate)
    {
        Matrix4 m;

        m.elements_ = {
            {1.0f,
             0.0f,
             0.0f,
             translate.x,
             0.0f,
             1.0f,
             0.0f,
             translate.y,
             0.0f,
             0.0f,
             1.0f,
             translate.z,
             0.0f,
             0.0f,
             0.0f,
             1.0f}};

        return m;
    }

    /**
     * Invert a matrix. This produces a matrix such that:
     * M * invert(M) == Matrix4{ }
     *
     * @param m
     *   Matrix to invert.
     *
     * @returns
     *   Inverted matrix.
     */
    constexpr static Matrix4 invert(const Matrix4 &m)
    {
        Matrix4 inv{};

        inv[0] = m[5] * m[10] * m[15] - m[5] * m[11] * m[14] - m[9] * m[6] * m[15] + m[9] * m[7] * m[14] +
                 m[13] * m[6] * m[11] - m[13] * m[7] * m[10];

        inv[4] = -m[4] * m[10] * m[15] + m[4] * m[11] * m[14] + m[8] * m[6] * m[15] - m[8] * m[7] * m[14] -
                 m[12] * m[6] * m[11] + m[12] * m[7] * m[10];

        inv[8] = m[4] * m[9] * m[15] - m[4] * m[11] * m[13] - m[8] * m[5] * m[15] + m[8] * m[7] * m[13] +
                 m[12] * m[5] * m[11] - m[12] * m[7] * m[9];

        inv[12] = -m[4] * m[9] * m[14] + m[4] * m[10] * m[13] + m[8] * m[5] * m[14] - m[8] * m[6] * m[13] -
                  m[12] * m[5] * m[10] + m[12] * m[6] * m[9];

        inv[1] = -m[1] * m[10] * m[15] + m[1] * m[11] * m[14] + m[9] * m[2] * m[15] - m[9] * m[3] * m[14] -
                 m[13] * m[2] * m[11] + m[13] * m[3] * m[10];

        inv[5] = m[0] * m[10] * m[15] - m[0] * m[11] * m[14] - m[8] * m[2] * m[15] + m[8] * m[3] * m[14] +
                 m[12] * m[2] * m[11] - m[12] * m[3] * m[10];

        inv[9] = -m[0] * m[9] * m[15] + m[0] * m[11] * m[13] + m[8] * m[1] * m[15] - m[8] * m[3] * m[13] -
                 m[12] * m[1] * m[11] + m[12] * m[3] * m[9];

        inv[13] = m[0] * m[9] * m[14] - m[0] * m[10] * m[13] - m[8] * m[1] * m[14] + m[8] * m[2] * m[13] +
                  m[12] * m[1] * m[10] - m[12] * m[2] * m[9];

        inv[2] = m[1] * m[6] * m[15] - m[1] * m[7] * m[14] - m[5] * m[2] * m[15] + m[5] * m[3] * m[14] +
                 m[13] * m[2] * m[7] - m[13] * m[3] * m[6];

        inv[6] = -m[0] * m[6] * m[15] + m[0] * m[7] * m[14] + m[4] * m[2] * m[15] - m[4] * m[3] * m[14] -
                 m[12] * m[2] * m[7] + m[12] * m[3] * m[6];

        inv[10] = m[0] * m[5] * m[15] - m[0] * m[7] * m[13] - m[4] * m[1] * m[15] + m[4] * m[3] * m[13] +
                  m[12] * m[1] * m[7] - m[12] * m[3] * m[5];

        inv[14] = -m[0] * m[5] * m[14] + m[0] * m[6] * m[13] + m[4] * m[1] * m[14] - m[4] * m[2] * m[13] -
                  m[12] * m[1] * m[6] + m[12] * m[2] * m[5];

        inv[3] = -m[1] * m[6] * m[11] + m[1] * m[7] * m[10] + m[5] * m[2] * m[11] - m[5] * m[3] * m[10] -
                 m[9] * m[2] * m[7] + m[9] * m[3] * m[6];

        inv[7] = m[0] * m[6] * m[11] - m[0] * m[7] * m[10] - m[4] * m[2] * m[11] + m[4] * m[3] * m[10] +
                 m[8] * m[2] * m[7] - m[8] * m[3] * m[6];

        inv[11] = -m[0] * m[5] * m[11] + m[0] * m[7] * m[9] + m[4] * m[1] * m[11] - m[4] * m[3] * m[9] -
                  m[8] * m[1] * m[7] + m[8] * m[3] * m[5];

        inv[15] = m[0] * m[5] * m[10] - m[0] * m[6] * m[9] - m[4] * m[1] * m[10] + m[4] * m[2] * m[9] +
                  m[8] * m[1] * m[6] - m[8] * m[2] * m[5];

        auto det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];

        if (det != 0.0f)
        {
            det = 1.0f / det;

            for (auto i = 0; i < 16; i++)
            {
                inv[i] *= det;
            }
        }

        return inv;
    }

    /**
     * Transpose a matrix.
     *
     * @param matrix
     *   Matrix to transpose.
     *
     * @returns
     *   Transposed matrix.
     */
    constexpr static Matrix4 transpose(const Matrix4 &matrix)
    {
        auto m{matrix};

        std::swap(m[1], m[4]);
        std::swap(m[2], m[8]);
        std::swap(m[3], m[12]);
        std::swap(m[6], m[9]);
        std::swap(m[7], m[13]);
        std::swap(m[11], m[14]);

        return m;
    }

    /**
     * Performs matrix multiplication.
     *
     * @param matrix
     *   The Matrix4 to multiply.
     *
     * @returns
     *   This Matrix4 multiplied the supplied Matrix4.
     */
    constexpr Matrix4 &operator*=(const Matrix4 &matrix)
    {
        const auto e = elements_;

        const auto calculate_cell = [&e, &matrix](std::size_t row_num, std::size_t col_num) {
            return (e[row_num + 0u] * matrix[col_num + 0u]) + (e[row_num + 1u] * matrix[col_num + 4u]) +
                   (e[row_num + 2u] * matrix[col_num + 8u]) + (e[row_num + 3u] * matrix[col_num + 12u]);
        };

        elements_[0u] = calculate_cell(0u, 0u);
        elements_[1u] = calculate_cell(0u, 1u);
        elements_[2u] = calculate_cell(0u, 2u);
        elements_[3u] = calculate_cell(0u, 3u);

        elements_[4u] = calculate_cell(4u, 0u);
        elements_[5u] = calculate_cell(4u, 1u);
        elements_[6u] = calculate_cell(4u, 2u);
        elements_[7u] = calculate_cell(4u, 3u);

        elements_[8u] = calculate_cell(8u, 0u);
        elements_[9u] = calculate_cell(8u, 1u);
        elements_[10u] = calculate_cell(8u, 2u);
        elements_[11u] = calculate_cell(8u, 3u);

        elements_[12u] = calculate_cell(12u, 0u);
        elements_[13u] = calculate_cell(12u, 1u);
        elements_[14u] = calculate_cell(12u, 2u);
        elements_[15u] = calculate_cell(12u, 3u);

        return *this;
    }

    /**
     * Performs Matrix4 multiplication.
     *
     * @param matrix
     *   The Matrix4 to multiply.
     *
     * @returns
     *   New Matrix4 which is this Matrix4 multiplied the supplied Matrix4.
     */
    constexpr Matrix4 operator*(const Matrix4 &matrix) const
    {
        return Matrix4(*this) *= matrix;
    }

    /**
     * Multiply this matrix by a given vector3.
     *
     * Internally this extends the Vector3 to have a fourth element with
     * a value of 1.0
     *
     * @param vector
     *   Vector3 to multiply by.
     *
     * @returns
     *   This matrix multiplied by the supplied vector3.
     */
    constexpr Vector3 operator*(const Vector3 &vector) const
    {
        return {
            vector.x * elements_[0] + vector.y * elements_[1] + vector.z * elements_[2] + elements_[3],

            vector.x * elements_[4] + vector.y * elements_[5] + vector.z * elements_[6] + elements_[7],

            vector.x * elements_[8] + vector.y * elements_[9] + vector.z * elements_[10] + elements_[11],
        };
    }

    /**
     * Get a reference to the element at the supplied index.
     *
     * @param index
     *   Index of element to get.
     *
     * @returns
     *   Reference to element at supplied index.
     */
    constexpr float &operator[](const size_t index)
    {
        return elements_[index];
    }

    /**
     * Get a copy of the element at the supplied index.
     *
     * @param index
     *   Index of element to get.
     *
     * @returns
     *   Copy of element at supplied index.
     */
    constexpr float operator[](const size_t index) const
    {
        return elements_[index];
    }

    /**
     * Equality operator.
     *
     * @param other
     *   Matrix4 to check for equality.
     *
     * @returns
     *   True if both Matrix4 objects are the same, false otherwise.
     */
    bool operator==(const Matrix4 &other) const
    {
        return std::equal(std::cbegin(elements_), std::cend(elements_), std::cbegin(other.elements_), compare);
    }

    /**
     * Inequality operator.
     *
     * @param other
     *   Matrix4 to check for inequality.
     *
     * @returns
     *   True if both Matrix4 objects are not the same, false otherwise.
     */
    bool operator!=(const Matrix4 &other) const
    {
        return !(*this == other);
    }

    /**
     * Get a pointer to the start of the internal Matrix4 data array.
     *
     * @returns
     *   Pointer to start if Matrix4 data.
     */
    constexpr const float *data() const
    {
        return elements_.data();
    }

    /**
     * Get a column from the matrix and return as a vector3. This ignores
     * the bottom row of the matrix.
     *
     * @param index
     *   The index of the column to return.
     *
     * @returns
     *   The first three value of the supplied column.
     */
    constexpr Vector3 column(const std::size_t index) const
    {
        return {elements_[index], elements_[index + 4u], elements_[index + 8u]};
    }

  private:
    /** Matrix4 data */
    std::array<float, 16u> elements_;
};

/**
 * Writes the Matrix4 to the stream, useful for debugging.
 *
 * @param out
 *   The stream to write to.
 *
 * @param m
 *   The Matrix4 to write to the stream.
 *
 * @return
 *   A reference to the supplied stream, after the Matrix4 has been
 *   written.
 */
inline std::ostream &operator<<(std::ostream &out, const Matrix4 &m)
{
    out << m[0] << " " << m[1] << " " << m[2] << " " << m[3] << std::endl;
    out << m[4] << " " << m[5] << " " << m[6] << " " << m[7] << std::endl;
    out << m[8] << " " << m[9] << " " << m[10] << " " << m[11] << std::endl;
    out << m[12] << " " << m[13] << " " << m[14] << " " << m[15];

    return out;
}

}

```

`include/iris/core/object_pool.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <memory>
#include <mutex>

#include "core/error_handling.h"
#include "log/log.h"

namespace iris
{

/**
 * Simple thread-safe generic object pool class.
 *
 * Internally this allocates a large continuous block for all objects and returns/releases objects from the start.
 */
template <class T, std::size_t N = 50000, class Allocator = std::allocator<T>>
class ObjectPool
{
  public:
    /**
     * Construct a new ObjectPool.
     *
     * @param alloc
     *   Allocator for object in pool.
     */
    ObjectPool(const Allocator &alloc = Allocator())
        : alloc_(alloc)
        , free_list_alloc_()
        , objects_(nullptr)
        , free_list_(nullptr)
        , next_(nullptr)
    {
        static_assert(N > 0);

        // create the fixed array of objects and a free list
        // the free list is an array of pointers where each element points to an object on the pool
        // the next_ pointer tracks which will be the next object to be given out from the pool
        objects_ = alloc_.allocate(N);

        try
        {
            // ensure that if allocating the free list throws we don't leak the object pool
            free_list_ = free_list_alloc_.allocate(N);
        }
        catch (...)
        {
            alloc_.deallocate(objects_, N);
            throw;
        }

        auto *obj_cursor = objects_;
        auto **free_cursor = free_list_;

        // wire up the free list so each pointer is pointing to an object in the pool
        while (free_cursor != free_list_ + N)
        {
            *free_cursor = obj_cursor;
            ++free_cursor;
            ++obj_cursor;
        }

        // start handing out objects from the start of the free list
        next_ = free_list_;
    }

    /**
     * Frees the internal pool memory. Note that any objects not passed to release() will *not* have their destructor
     * called.
     */
    ~ObjectPool()
    {
        alloc_.deallocate(objects_, N);
        free_list_alloc_.deallocate(free_list_, N);
    }

    /**
     * Get the next object from the pool. Will construct it with the supplied args.
     *
     * @param args
     *   Argument to forward to the object constructor.
     *
     * @returns
     *   Next object.
     */
    template <class... Args>
    T *next(Args &&...args)
    {
        ensure(next_ != free_list_ + N, "object pool drained");

        T *object = nullptr;

        // get the next object and update the next pointer
        {
            std::unique_lock lock(mutex_);
            object = *next_;
            ++next_;
        }

        ::new (object) T(std::forward<Args>(args)...);

        return object;
    }

    /**
     * Returns an object to the pool.
     *
     * @param object
     *   Object to return to pool.
     */
    void release(const T *object)
    {
        // call the destructor of the returned object
        std::destroy_at(object);

        // return the object to the pool and move the next pointer back
        {
            std::unique_lock lock(mutex_);
            --next_;
            *next_ = const_cast<T *>(object);
        }
    }

  private:
    /** The allocator to use of T. */
    Allocator alloc_;

    /** Rebound allocator for allocating T* */
    typename std::allocator_traits<Allocator>::template rebind_alloc<T *> free_list_alloc_;

    /** Pool of allocated objects. */
    T *objects_;

    /** Array of pointers to allocated objects. */
    T **free_list_;

    /** Pointer into free list for next object to return. */
    T **next_;

    /** Mutex to ensure thread safety. */
    std::mutex mutex_;
};

}

```

`include/iris/core/profiler.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <memory>

namespace iris
{

/**
 * Sampling based profiler which periodically suspends and samples all running threads.
 * 
 * Currently prints the profile breakdown to stdout when program ends.
 */
class Profiler
{
  public:
    /**
     * Construct a new Profiler.
     */
    Profiler();
    
    /**
     * Signals profiling thread to stop
     */
    ~Profiler();

  private:
    /** Pointer to implementation. */
    struct implementation;
    std::unique_ptr<implementation> impl_;
};

}

```

`include/iris/core/profiler_analyser.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <string>
#include <unordered_map>
#include <vector>

namespace iris
{

/**
 * Class which records stack traces as they are generated and pretty prints the final profile stats.
 */
class ProfilerAnalyser
{
  public:
    /**
     * Add a stack trace to the analyser.
     *
     * @param stack_trace
     *   The stack trace to add.
     */
    void add_stack_trace(const std::vector<std::string> &stack_trace);

    /**
     * Pretty print all generated profile stats to stdout.
     */
    void print();

  private:
    /**
     * Struct to encapsulate recorded data.
     */
    struct Level
    {
        std::uint32_t hit_count = 0u;
        std::string name;
        std::vector<Level> children;
    };

    /** Start of the profiling heirarchy. */
    Level root_level_;
};

}

```

`include/iris/core/quaternion.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cmath>
#include <iosfwd>

#include "core/utils.h"
#include "core/vector3.h"

namespace iris
{

/**
 * Class representing a Quaternion.
 *
 * A Quaternion represents a rotation (w) about a vector (x, y, z).
 *
 * This is a header only class to allow for constexpr methods.
 */
class Quaternion
{
  public:
    /**
     * Construct a new unit Quaternion.
     */
    constexpr Quaternion()
        : w(1.0f)
        , x(0.0f)
        , y(0.0f)
        , z(0.0f)
    {
    }

    /**
     * Construct a Quaternion which represents a rotation about an axis.
     *
     * @param axis
     *   The axis about which to rotate.
     *
     * @param angle
     *   The rotation in radians.
     */
    Quaternion(const Vector3 &axis, float angle)
        : w(0.0f)
        , x(0.0f)
        , y(0.0f)
        , z(0.0f)
    {
        const auto half_angle = angle / 2.0f;
        const auto sin_angle = std::sin(half_angle);

        w = std::cos(half_angle);
        x = sin_angle * axis.x;
        y = sin_angle * axis.y;
        z = sin_angle * axis.z;

        normalise();
    }

    /**
     * Construct a Quaternion with supplied components.
     *
     * @param x
     *   x component.
     *
     * @param y
     *   x component.
     *
     * @param z
     *   x component.
     *
     * @param w
     *   x component.
     */
    constexpr Quaternion(float x, float y, float z, float w)
        : w(w)
        , x(x)
        , y(y)
        , z(z)
    {
    }

    /**
     * Construct a Quaternion with Euler angles.
     *
     * @param yaw
     *   Yaw angle in radians.
     *
     * @param pitch
     *   Pitch angle in radians.
     *
     * @param roll
     *   Roll angle in radians.
     */
    Quaternion(float yaw, float pitch, float roll)
        : Quaternion()
    {
        const auto cy = std::cos(yaw * 0.5f);
        const auto sy = std::sin(yaw * 0.5f);
        const auto cp = std::cos(pitch * 0.5f);
        const auto sp = std::sin(pitch * 0.5f);
        const auto cr = std::cos(roll * 0.5f);
        const auto sr = std::sin(roll * 0.5f);

        w = cr * cp * cy + sr * sp * sy;
        x = sr * cp * cy - cr * sp * sy;
        y = cr * sp * cy + sr * cp * sy;
        z = cr * cp * sy - sr * sp * cy;
    }

    /**
     * Multiply this Quaternion by another, therefore applying a composition
     * of both rotations.
     *
     * @param quaternion
     *   Quaternion to compose with this.
     *
     * @returns
     *   Reference to this Quaternion.
     */
    constexpr Quaternion &operator*=(const Quaternion &quaternion)
    {
        const Quaternion copy{*this};

        w = copy.w * quaternion.w - copy.x * quaternion.x - copy.y * quaternion.y - copy.z * quaternion.z;
        x = copy.w * quaternion.x + copy.x * quaternion.w + copy.y * quaternion.z - copy.z * quaternion.y;
        y = copy.w * quaternion.y + copy.y * quaternion.w + copy.z * quaternion.x - copy.x * quaternion.z;
        z = copy.w * quaternion.z + copy.z * quaternion.w + copy.x * quaternion.y - copy.y * quaternion.x;

        return *this;
    }

    /**
     * Create a new Quaternion which is the composition of this this
     * rotation with another.
     *
     * @param quaternion
     *   Quaternion to compose with this.
     *
     * @returns
     *   Copy of this Quaternion composed with the supplied one.
     */
    constexpr Quaternion operator*(const Quaternion &quaternion) const
    {
        return Quaternion{*this} *= quaternion;
    }

    /**
     * Add a rotation specified as a Vector3 to this Quaternion.
     *
     * @param vector
     *   Vector to add.
     *
     * @returns
     *   Reference to this Quaternion.
     */
    constexpr Quaternion &operator+=(const Vector3 &vector)
    {
        Quaternion q{};
        q.w = 0.0f;
        q.x = vector.x;
        q.y = vector.y;
        q.z = vector.z;

        q *= *this;

        w += q.w / 2.0f;
        x += q.x / 2.0f;
        y += q.y / 2.0f;
        z += q.z / 2.0f;

        return *this;
    }

    /**
     * Create a new Quaternion that is the composition of this rotation
     * and one specified as a vector3.
     *
     * @param vector
     *   Vector to add.
     *
     * @returns
     *   Copy of this Quaternion composed with the Vector3 rotation.
     */
    constexpr Quaternion operator+(const Vector3 &vector) const
    {
        return Quaternion{*this} += vector;
    }

    /**
     * Create a new Quaternion that is this value scaled.
     *
     * @param scale
     *   Amount to scale by.
     *
     * @returns
     *   Scaled quaternion.
     */
    constexpr Quaternion operator*(float scale) const
    {
        return Quaternion{*this} *= scale;
    }

    /**
     * Scale quaternion.
     *
     * @param scale
     *   Amount to scale by.
     *
     * @returns
     *   Reference to this Quaternion.
     */
    constexpr Quaternion &operator*=(float scale)
    {
        x *= scale;
        y *= scale;
        z *= scale;
        w *= scale;

        return *this;
    }

    /**
     * Create a new Quaternion that is this Quaternion subtracted with a
     * supplied Quaternion.
     *
     * @param other
     *   Quaternion to subtract from this.
     *
     * @returns
     *   Copy of this Quaternion after subtraction.
     */
    constexpr Quaternion operator-(const Quaternion &other) const
    {
        return Quaternion{*this} -= other;
    }

    /**
     * Subtract a Quaternion from this.
     *
     * @param other
     *   Quaternion to subtract from this.
     *
     * @returns
     *   Reference to this Quaternion.
     */
    constexpr Quaternion &operator-=(const Quaternion &other)
    {
        return *this += -other;
    }

    /**
     * Create a new Quaternion that is this Quaternion added with a
     * supplied Quaternion.
     *
     * @param other
     *   Quaternion to add to this.
     *
     * @returns
     *   Copy of this Quaternion after addition.
     */
    constexpr Quaternion operator+(const Quaternion &other) const
    {
        return Quaternion{*this} += other;
    }

    /**
     * Add a Quaternion from this.
     *
     * @param other
     *   Quaternion to subtract from this.
     *
     * @returns
     *   Reference to this Quaternion.
     */
    constexpr Quaternion &operator+=(const Quaternion &other)
    {
        x += other.x;
        y += other.y;
        z += other.z;
        w += other.w;

        return *this;
    }

    /**
     * Negate operator.
     *
     * @returns
     *   Copy of this Quaternion with each component negated.
     */
    constexpr Quaternion operator-() const
    {
        return {-x, -y, -z, -w};
    }

    /**
     * Calculate the Quaternion dot product.
     *
     * @param other
     *   Quaternion to calculate dot product with.
     *
     * @returns
     *   Dot product of this Quaternion with the supplied one.
     */
    constexpr float dot(const Quaternion &other) const
    {
        return x * other.x + y * other.y + z * other.z + w * other.w;
    }

    /**
     * Perform spherical linear interpolation toward target Quaternion.
     *
     * @param target
     *   Quaternion to interpolate towards.
     *
     * @param amount
     *   Amount to interpolate, must be in range [0.0, 1.0].
     */
    constexpr void slerp(Quaternion target, float amount)
    {
        auto dot = this->dot(target);
        if (dot < 0.0f)
        {
            target = -target;
            dot = -dot;
        }

        const auto threshold = 0.9995f;
        if (dot > threshold)
        {
            *this = *this + ((target - *this) * amount);
            normalise();
        }
        else
        {
            const auto theta_0 = std::acos(dot);
            const auto theta = theta_0 * amount;
            const auto sin_theta = std::sin(theta);
            const auto sin_theta_0 = std::sin(theta_0);

            const auto s0 = std::cos(theta) - dot * sin_theta / sin_theta_0;
            const auto s1 = sin_theta / sin_theta_0;

            *this = (*this * s0) + (target * s1);
        }
    }

    /**
     * Equality operator.
     *
     * @param other
     *   Quaternion to check for equality.
     *
     * @returns
     *   True if both Quaternion objects are the same, false otherwise.
     */
    bool operator==(const Quaternion &other) const
    {
        return compare(w, other.w) && compare(x, other.x) && compare(y, other.y) && compare(z, other.z);
    }

    /**
     * Inequality operator.
     *
     * @param other
     *   Quaternion to check for inequality.
     *
     * @returns
     *   True if both Quaternion objects are not the same, false otherwise.
     */
    bool operator!=(const Quaternion &other) const
    {
        return !(*this == other);
    }

    /**
     * Normalise this Quaternion.
     *
     * @returns
     *   A reference to this Quaternion.
     */
    Quaternion &normalise()
    {
        const auto magnitude = std::pow(w, 2.0f) + std::pow(x, 2.0f) + std::pow(y, 2.0f) + std::pow(z, 2.0f);

        if (magnitude == 0.0f)
        {
            w = 1.0f;
        }
        else
        {
            const auto d = std::sqrt(magnitude);

            w /= d;
            x /= d;
            y /= d;
            z /= d;
        }

        return *this;
    }

    /** Angle of rotation. */
    float w;

    /** x axis of rotation. */
    float x;

    /** y axis of rotation. */
    float y;

    /** z axis of rotation. */
    float z;
};

/**
 * Write a Quaternion to a stream, useful for debugging.
 *
 * @param out
 *   Stream to write to.
 *
 * @param q
 *   Quaternion to write to stream.
 *
 * @returns
 *   Reference to input stream.
 */
inline std::ostream &operator<<(std::ostream &out, const Quaternion &q)
{
    out << "x: " << q.x << " "
        << "y: " << q.y << " "
        << "z: " << q.z << " "
        << "w: " << q.w;

    return out;
}

}

```

`include/iris/core/random.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>

namespace iris
{

/**
 * Generate a uniform random integer in the range [min, max].
 *
 * @param min
 *   Minimum value.
 *
 * @param max
 *   Maximum value.
 *
 * @returns
 *   Random integer.
 */
std::uint32_t random_uint32(std::uint32_t min, std::uint32_t max);

/**
 * Generate a uniform random integer in the range [min, max].
 *
 * @param min
 *   Minimum value.
 *
 * @param max
 *   Maximum value.
 *
 * @returns
 *   Random integer.
 */
std::int32_t random_int32(std::int32_t min, std::int32_t max);

/**
 * Generate a uniform random float in the range [min, max).
 *
 * @param min
 *   Minimum value.
 *
 * @param max
 *   Maximum value.
 *
 * @returns
 *   Random integer.
 */
float random_float(float min, float max);

/**
 * Flip a (biased) coin.
 *
 * @param bias
 *   Possibility of heads [0.0, 1.0]. A value of 0.5 is a fair coin toss.
 *
 * @returns
 *   True if heads, false if tails.
 */
bool flip_coin(float bias = 0.5f);

/**
 * Get a random element from a collection.
 *
 * @param collection
 *   Collection to get element from.
 *
 * @returns
 *   Random element.
 */
template <class T>
typename T::reference random_element(T &container)
{
    const auto index = random_uint32(0u, container.size() - 1u);
    return container[index];
}

/**
 * Get a random element from a collection.
 *
 * @param collection
 *   Collection to get element from.
 *
 * @returns
 *   Random element.
 */
template <class T>
typename T::const_reference random_element(const T &container)
{
    const auto index = random_uint32(0u, container.size() - 1u);
    return container[index];
}

}

```

`include/iris/core/resource_manager.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <filesystem>
#include <string>
#include <string_view>
#include <unordered_map>
#include <vector>

#include "core/data_buffer.h"
#include "core/string_hash.h"

namespace iris
{

/**
 * An abstract class for loading and caching resources.
 */
class ResourceManager
{
  public:
    ResourceManager();

    virtual ~ResourceManager() = default;

    /**
     * Load a resource. If this is the first load of resource then it is fetched (via the deriving classes
     * implementation). Otherwise a cached copy is returned.
     *
     * @param resource
     *   Name of resource.
     *
     * @returns
     *   Const reference to loaded data.
     */
    const DataBuffer &load(std::string_view resource);

    /**
     * Set root resource location. Note that implementations may choose to ignore this.
     *
     * @param root
     *   New root location.
     */
    void set_root_directory(const std::filesystem::path &root);

  protected:
    /**
     * Implementations should override this to perform their specific data loading logic.
     *
     * @param resource
     *   Name of resource.
     *
     * @returns
     *   Loaded data.
     */
    virtual DataBuffer do_load(std::string_view resource) = 0;

    /** Resource root. */
    std::filesystem::path root_;

  private:
    /** Cache of loaded resources. */
    std::unordered_map<std::string, DataBuffer, StringHash, std::equal_to<>> resources_;
};

}

```

`include/iris/core/semaphore.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <memory>

namespace iris
{

/**
 * A syntonisation primitive which contains a counter that can be incremented
 * (release) or decremented (acquire) by any thread. Attempting to acquire a
 * semaphore when the internal count is 0 will block the calling thread until
 * another calls release.
 */
class Semaphore
{
  public:
    /**
     * Create a new Semaphore with an initial value for the counter.
     *
     * @param initial
     *   Initial value for counter.
     */
    Semaphore(std::ptrdiff_t initial = 0);

    ~Semaphore();

    Semaphore(const Semaphore &) = delete;
    Semaphore &operator=(const Semaphore &) = delete;
    Semaphore(Semaphore &&);
    Semaphore &operator=(Semaphore &&);

    /**
     * Increment counter and unblock any waiting threads.
     */
    void release();

    /**
     * Decrement counter or block until it can.
     */
    void acquire();

  private:
    /** Pointer to implementation. */
    struct implementation;
    std::unique_ptr<implementation> impl_;
};

}

```

`include/iris/core/start.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <functional>

#include "core/context.h"

namespace iris
{

/**
 * Start the engine! This performs all platform and subsystem initialisation before calling the supplied entry.
 *
 * @param argc
 *   argc from main()
 *
 * @param argv
 *   argv from main()
 *
 * @param entry
 *   Entry point into game, will be passed an engine context object.
 *
 * @param debug
 *   If the engine should be started in debug mode.
 */
void start(int argc, char **argv, std::function<void(Context)> entry, bool debug = false);

}

```

`include/iris/core/static_buffer.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <cstdint>
#include <memory>
#include <set>

namespace iris
{

/**
 * Fixed size managed buffer. Memory is allocated in pages and is read-writable.
 * Guard pages are also allocated before and after the memory region, so
 * out-of-bounds access fails fast and loud.
 */
class StaticBuffer
{
  public:
    /**
     * Create buffer with requested number of pages.
     *
     * @param pages
     *   Number of pages to allocate.
     */
    explicit StaticBuffer(std::size_t pages);

    /**
     * Release all allocated memory.
     */
    ~StaticBuffer();

    /**
     * Get page size in bytes.
     *
     * @returns
     *   Number of bytes in a page.
     */
    static std::size_t page_size();

    /**
     * Get start of allocated buffer.
     *
     * @returns
     *   Pointer to start of buffer.
     */
    operator std::byte *() const;

    /**
     * Number of allocated bytes. This does not include any guard pages.
     *
     * @returns
     *   Number of allocated bytes.
     */
    std::size_t size() const;

  private:
    /** Pointer to implementation. */
    struct implementation;
    std::unique_ptr<implementation> impl_;
};

}

```

`include/iris/core/string_hash.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.str)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

namespace iris
{

/**
 * A hash object fot std::unordered_map/set with a std::string key that enabled heterogeneous operations.
 */
struct StringHash
{
    using is_transparent = void;

    [[nodiscard]] size_t operator()(const char *str) const
    {
        return std::hash<std::string_view>{}(str);
    }

    [[nodiscard]] size_t operator()(std::string_view str) const
    {
        return std::hash<std::string_view>{}(str);
    }

    [[nodiscard]] size_t operator()(const std::string &str) const
    {
        return std::hash<std::string>{}(str);
    }
};

}
```

`include/iris/core/thread.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <thread>
#include <utility>

namespace iris
{

/**
 * Class encapsulating a thread. In general this is an internal class. For
 * parallelising work the JobSystem should be used.
 */
class Thread
{
  public:
    /**
     * Construct a new thread not associated with any function.
     */
    Thread();

    /**
     * Construct a thread and run the supplied function and args.
     *
     * @param function
     *   Function to run in thread.
     *
     * @param args
     *   Arguments of function, will be perfectly forwarded.
     */
    template <class Function, class... Args>
    Thread(Function &&function, Args &&...args)
        : thread_(std::forward<Function>(function), std::forward<Args>(args)...)
    {
    }

    /**
     * Checks if this thread is currently active.
     *
     * @returns
     *   True if this thread has started and not yet been joined, else
     *   False.
     */
    bool joinable() const;

    /**
     * Block and wait for this thread to finish executing.
     */
    void join();

    /**
     * Get id of thread.
     *
     * @returns
     *   Thread id.
     */
    std::thread::id get_id() const;

    /**
     * Bind this thread such that it only executes on the specified core,
     * preventing the kernel from scheduling it onto another core.
     *
     * Note that depending on the current platform this may act as a
     * suggestion to the kernel, rather than be honored.
     *
     * @param core
     *   Id of core to bind to in the range [0, number of cores)
     */
    void bind_to_core(std::size_t core);

  private:
    /** Internal thread object. */
    std::thread thread_;
};

}

```

`include/iris/core/transform.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include "core/matrix4.h"
#include "core/quaternion.h"
#include "core/vector3.h"

namespace iris
{

/**
 * Class representing transformation in 3D space. A transformation is formed of
 * a translation, rotation and scale. Conceptually this class provides a more
 * semantically specific api over a Matrix4.
 */
class Transform
{
  public:
    /**
     * Construct an empty Transform, this represents zero translation, zero
     * rotation and scale of 1.
     */
    Transform();

    /**
     * Construct a Transform from an existing Matrix4.
     *
     * @param matrix
     *   Matrix representing transform.
     */
    explicit Transform(const Matrix4 &matrix);

    /**
     * Construct a transform from component parts.
     *
     * @param translation
     *   Transform translation.
     *
     * @param rotation
     *   Transform rotation.
     *
     * @param scale
     *   Transform scale.
     */
    Transform(const Vector3 &translation, const Quaternion &rotation, const Vector3 &scale);

    /**
     * Get the matrix which represents this transformation.
     *
     * @returns
     *   Transformation matrix.
     */
    Matrix4 matrix() const;

    /**
     * Set matrix. Translation, rotation and scale will be derived from input.
     *
     * @param matrix
     *   New matrix.
     */
    void set_matrix(const Matrix4 &matrix);

    /**
     * Interpolate between this and another Transform.
     *
     * @param other
     *   Transform to interpolate to.
     *
     * @param amount
     *   Interpolation amount, must be in range [0.0, 1.0].
     */
    void interpolate(const Transform &other, float amount);

    /**
     * Get the translation component of the transform.
     *
     * @returns
     *   Translation component.
     */
    Vector3 translation() const;

    /**
     * Set translation.
     *
     * @param translation
     *   New translation.
     */
    void set_translation(const Vector3 &translation);

    /**
     * Get the rotation component of the transform.
     *
     * @returns
     *   Rotation component.
     */
    Quaternion rotation() const;

    /**
     * Set rotation.
     *
     * @param rotation
     *   New rotation.
     */
    void set_rotation(const Quaternion &rotation);

    /**
     * Get the scale component of the transform.
     *
     * @returns
     *   Scale component.
     */
    Vector3 scale() const;

    /**
     * Set scale.
     *
     * @param scale
     *   New scale.
     */
    void set_scale(const Vector3 &scale);

    /**
     * Equality operator.
     *
     * @param other
     *   Transform to compare for equality.
     *
     * @returns
     *   True if both transform are the same, false otherwise.
     */
    bool operator==(const Transform &other) const;

    /**
     * Inequality operator.
     *
     * @param other
     *   Transform to compare for inequality.
     *
     * @returns
     *   True if both transform are not the same, false otherwise.
     */
    bool operator!=(const Transform &other) const;

    /**
     * Performs transform multiplication. This results in a new transform, which
     * is this transform followed by the supplied one.
     *
     * @param other
     *   The transform to multiple.
     *
     * @returns
     *   New Transform which is this Transform multiplied by the supplied one.
     */
    Transform operator*(const Transform &other) const;

    /**
     * Performs transform multiplication. This results in a new transform, which
     * is this transform followed by the supplied one.
     *
     * @param other
     *   The transform to multiple.
     *
     * @returns
     *   This Transform after the supplied transform has been applied.
     */
    Transform &operator*=(const Transform &other);

    /**
     * Performs transform multiplication. This results in a new transform, which
     * is this transform followed by the supplied matrix.
     *
     * @param other
     *   The matrix to multiple.
     *
     * @returns
     *   This new Transform which is this transform multiplied by the supplied
     *   matrix.
     */
    Transform operator*(const Matrix4 &other) const;

    /**
     * Performs transform multiplication. This results in a new transform, which
     * is this transform followed by the supplied matrix.
     *
     * @param other
     *   The matrix to multiple.
     *
     * @returns
     *   This Transform after the supplied transform has been applied.
     */
    Transform &operator*=(const Matrix4 &other);

  private:
    /** Translation component. */
    Vector3 translation_;

    /** Rotation component. */
    Quaternion rotation_;

    /** Scale component. */
    Vector3 scale_;
};

}

```

`include/iris/core/utils.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <cstdint>
#include <functional>

namespace utils::detail
{

/**
 * Helper function to combine the hash values of supplied objects (using std::hash).
 *
 * @param seed
 *   Initial hash value, will be set to combined hash value.
 *
 * @param head
 *   Head of recursion.
 *
 * @param tail
 *   Remainder of recursion.
 */
template <class Head, class... Tail>
void do_combine_hash(std::size_t &seed, const Head &head, Tail... tail)
{
    // this algorithm is based on boost::combine_hash and is designed to mix/smear around values
    seed ^= std::hash<Head>{}(head) + 0x9e3779b97f4a7c55 + (seed << 6) + (seed >> 2);
    (do_combine_hash(seed, tail), ...);
}

}

namespace iris
{

/**
 * Compare two floating point numbers using a scaling epsilon.
 *
 * @param a
 *   First float.
 *
 * @param b
 *   Second float.
 *
 * @returns
 *   True if both floats are equal (within an epsilon), false otherwise.
 */
bool compare(float a, float b);

/**
 * Combine the hash values of supplied objects (using std::hash).
 *
 * @param args
 *   Variable list of objects to hash.
 *
 * @return
 *   Combined hash value of all objects.
 */
template <class... Args>
std::size_t combine_hash(Args... args)
{
    std::size_t seed = 0u;
    utils::detail::do_combine_hash(seed, args...);
    return seed;
}

}

```

`include/iris/core/vector3.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <algorithm>
#include <cmath>
#include <functional>
#include <limits>
#include <ostream>

#include "core/utils.h"

namespace iris
{

/**
 * Class representing a vector in 3D space. Comprises an x, y and z
 * component.
 *
 * This is a header only class to allow for constexpr methods.
 */
class Vector3
{
  public:
    /**
     * Constructs a new Vector3 with all components initialised to 0.
     */
    constexpr Vector3()
        : Vector3(0.0f)
    {
    }

    /**
     * Constructs a new Vector3 with all components initialised to the same
     * value.
     *
     * @param xyz
     *   Value for x, y and z.
     */
    constexpr Vector3(float xyz)
        : Vector3(xyz, xyz, xyz)
    {
    }

    /**
     * Constructs a new Vector3 with the supplied components.
     *
     * @param x
     *   x component.
     *
     * @param y
     *   y component.
     *
     * @param z
     *   z component.
     */
    constexpr Vector3(float x, float y, float z)
        : x(x)
        , y(y)
        , z(z)
    {
    }

    /**d221G
     * Multiply each component by a scalar value.
     *
     * @param scale
     *   scalar value.
     *
     * @return
     *   Reference to this vector3.
     */
    constexpr Vector3 &operator*=(float scale)
    {
        x *= scale;
        y *= scale;
        z *= scale;

        return *this;
    }

    /**
     * Create a new Vector3 which is this Vector3 with each component
     * multiplied by a scalar value.
     *
     * @param scale
     *   scalar value.
     *
     * @return
     *   Copy of this Vector3 with each component multiplied by a
     *   scalar value.
     */
    constexpr Vector3 operator*(float scale) const
    {
        return Vector3(*this) *= scale;
    }
    /**
     * Component wise add a Vector3 to this vector3.
     *
     * @param vector
     *   The Vector3 to add to this.
     *
     * @return
     *   Reference to this vector3.
     */
    constexpr Vector3 &operator+=(const Vector3 &vector)
    {
        x += vector.x;
        y += vector.y;
        z += vector.z;

        return *this;
    }

    /**
     * Create a new Vector3 which is this Vector3 added with a supplied
     * vector3.
     *
     * @param vector
     *   Vector3 to add to this.
     *
     * @return
     *   Copy of this Vector3 with each component added to the
     *   components of the supplied vector3.
     */
    constexpr Vector3 operator+(const Vector3 &vector) const
    {
        return Vector3(*this) += vector;
    }

    /**
     * Component wise subtract a Vector3 to this vector3.
     *
     * @param v
     *   The Vector3 to subtract from this.
     *
     * @return
     *   Reference to this vector3.
     */
    constexpr Vector3 &operator-=(const Vector3 &vector)
    {
        *this += -vector;
        return *this;
    }

    /**
     * Create a new Vector3 which is this Vector3 subtracted with a
     * supplied vector3.
     *
     * @param v
     *   Vector3 to subtract from this.
     *
     * @return
     *   Copy of this Vector3 with each component subtracted to the
     *   components of the supplied vector3.
     */
    constexpr Vector3 operator-(const Vector3 &vector) const
    {
        return Vector3(*this) -= vector;
    }

    /**
     * Component wise multiple a Vector3 to this vector3.
     *
     * @param vector
     *   The Vector3 to multiply.
     *
     * @returns
     *   Reference to this vector3.
     */
    constexpr Vector3 &operator*=(const Vector3 &vector)
    {
        x *= vector.x;
        y *= vector.y;
        z *= vector.z;

        return *this;
    }

    /**
     * Create a new Vector3 which us this Vector3 component wise multiplied
     * with a supplied vector3.
     *
     * @param vector
     *   Vector3 to multiply with this.
     *
     * @returns
     *   Copy of this Vector3 component wise multiplied with the supplied
     *   vector3.
     */
    constexpr Vector3 operator*(const Vector3 &vector) const
    {
        return Vector3{*this} *= vector;
    }

    /**
     * Negate operator.
     *
     * @return
     *   Return a copy of this Vector3 with each component negated.
     */
    constexpr Vector3 operator-() const
    {
        return Vector3{-x, -y, -z};
    }

    /**
     * Equality operator.
     *
     * @param other
     *   Vector3 to check for equality.
     *
     * @returns
     *   True if both Vector3 objects are the same, false otherwise.
     */
    bool operator==(const Vector3 &other) const
    {
        return compare(x, other.x) && compare(y, other.y) && compare(z, other.z);
    }

    /**
     * Inequality operator.
     *
     * @param other
     *   Vector3 to check for inequality.
     *
     * @returns
     *   True if both Vector3 objects are not the same, false otherwise.
     */
    bool operator!=(const Vector3 &other) const
    {
        return !(other == *this);
    }

    /**
     * Calculate the vector dot product.
     *
     * @param vector
     *   Vector3 to calculate dot product with.
     *
     * @returns
     *   Dot product of this vector with supplied one.
     */
    constexpr float dot(const Vector3 &vector) const
    {
        return x * vector.x + y * vector.y + z * vector.z;
    }

    /**
     * Perform cross product of this Vector3 with a supplied one.
     *
     * @param vector
     *   Vector3 to cross with.
     *
     * @return
     *   Reference to this vector3.
     */
    constexpr Vector3 &cross(const Vector3 &vector)
    {
        const auto i = (y * vector.z) - (z * vector.y);
        const auto j = (x * vector.z) - (z * vector.x);
        const auto k = (x * vector.y) - (y * vector.x);

        x = i;
        y = -j;
        z = k;

        return *this;
    }

    /**
     * Normalises this vector3.
     *
     * @return
     *   Reference to this vector3.
     */
    Vector3 &normalise()
    {
        const auto length =

            std::sqrt(std::pow(x, 2.0f) + std::pow(y, 2.0f) + std::pow(z, 2.0f));

        if (length != 0.0f)
        {
            x /= length;
            y /= length;
            z /= length;
        }

        return *this;
    }

    /**
     * Get the magnitude of this vector.
     *
     * @return
     *   Vector magnitude.
     */
    float magnitude() const
    {
        return std::hypot(x, y, z);
    }

    /**
     * Linear interpolate between this and another vector.
     *
     * @param other
     *   Vector3 to interpolate to.
     *
     * @param amount
     *   Interpolation amount, must be in range [0.0, 1.0].
     */
    constexpr void lerp(const Vector3 &other, float amount)
    {
        *this *= (1.0f - amount);
        *this += (other * amount);
    }

    /**
     * Linear interpolate between two vectors.
     *
     * @param start
     *   Vector3 to start from.
     *
     * @param end
     *   Vector3 to lerp towards.
     *
     * @param amount
     *   Interpolation amount, must be in range [0.0, 1.0].
     *
     * @returns
     *   Result of lerp.
     */
    constexpr static Vector3 lerp(const Vector3 &start, const Vector3 &end, float amount)
    {
        auto tmp = start;
        tmp.lerp(end, amount);

        return tmp;
    }

    /**
     * Cross two Vector3 objects with each other.
     *
     * @param v1
     *   First Vector3 to cross.
     *
     * @param v2
     *   Second Vector3 to cross.
     *
     * @return
     *   v1 cross v2.
     */
    constexpr static Vector3 cross(const Vector3 &v1, const Vector3 &v2)
    {
        return Vector3(v1).cross(v2);
    }

    /**
     * Normalise a supplied vector3.
     *
     * @param vector
     *   Vector3 to normalise.
     *
     * @return
     *   Supplied Vector3 normalised.
     */
    static Vector3 normalise(const Vector3 &vector)
    {
        return Vector3(vector).normalise();
    }

    /**
     * Get the Euclidean distance between two vectors.
     *
     * @param a
     *   Point to calculate distance from.
     *
     * @param b
     *   Point to calculate distance to.
     *
     * @returns
     *   Distance between point a and b.
     */
    static float distance(const Vector3 &a, const Vector3 &b)
    {
        return (b - a).magnitude();
    }

    /** x component */
    float x;

    /** y component */
    float y;

    /** z component */
    float z;
};

/**
 * Write a Vector3 to a stream, useful for debugging.
 *
 * @param out
 *   Stream to write to.
 *
 * @param v
 *   Vector3 to write to stream.
 *
 * @return
 *   Reference to input stream.
 */
inline std::ostream &operator<<(std::ostream &out, const Vector3 &v)
{
    out << "x: " << v.x << " "
        << "y: " << v.y << " "
        << "z: " << v.z;

    return out;
}

}

// specialise std::hash for colour
namespace std
{

template <>
struct hash<iris::Vector3>
{
    size_t operator()(const iris::Vector3 &vec) const
    {
        return iris::combine_hash(vec.x, vec.y, vec.z);
    }
};

}

```

`include/iris/events/event.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <variant>

#include "core/exception.h"
#include "events/event_type.h"
#include "events/keyboard_event.h"
#include "events/mouse_button_event.h"
#include "events/mouse_event.h"
#include "events/quit_event.h"
#include "events/scroll_wheel_event.h"
#include "events/touch_event.h"

namespace iris
{

/**
 * Class encapsulating a user input event. This provides common access to
 * specific Event types e.g. keyboard_event.
 */
class Event
{
  public:
    /**
     * Construct a new Quit event.
     *
     * @param event
     *   Quit event.
     */
    Event(QuitEvent event);
    /**
     * Construct a new keyboard event.
     *
     * @param event
     *   Keyboard event.
     */
    Event(KeyboardEvent event);

    /**
     * Construct a new mouse event.
     *
     * @param event
     *   Mouse event.
     */
    Event(MouseEvent event);

    /**
     * Construct a new mouse button event.
     *
     * @param event
     *   Mouse button event.
     */
    Event(MouseButtonEvent event);

    /**
     * Construct a new touch event.
     *
     * @param event
     *   Touch event.
     */
    Event(TouchEvent event);

    /**
     * Construct a new scroll wheel event.
     *
     * @param event
     *   Scroll wheel event.
     */
    Event(ScrollWheelEvent event);

    /**
     * Get type of event.
     *
     * @returns
     *   Event type.
     */
    EventType type() const;

    /**
     * Check if Event is a quit event.
     *
     * @returns
     *   True if this Event is a quit event, else false.
     */
    bool is_quit() const;

    /**
     * Check if Event is a keyboard event.
     *
     * @returns
     *   True if Event is a keyboard event, else false.
     */
    bool is_key() const;

    /**
     * Check if this Event is a specific Key event.
     *
     * @param key
     *   Key to check.
     *
     * @returns
     *   True if Event is a keyboard Event and matches supplied key.
     */
    bool is_key(Key key) const;

    /**
     * Check if this Event is a specific Key Event and state.
     *
     * @param key
     *   Key to check.
     *
     * @param state
     *   State to check.
     *
     * @returns
     *   True if Event is a keyboard Event and matches supplied Key and
     *   state.
     */
    bool is_key(Key key, KeyState state) const;

    /**
     * Get keyboard event, will throw if wrong type.
     *
     * @returns
     *   Keyboard event.
     */
    KeyboardEvent key() const;

    /**
     * Check if Event is a mouse event.
     *
     * @returns
     *   True if Event is a mouse event, else false.
     */
    bool is_mouse() const;

    /**
     * Get mouse event, will throw if wrong type.
     *
     * @returns
     *   Mouse event.
     */
    MouseEvent mouse() const;

    /**
     * Check if event is a mouse button event.
     *
     * @returns
     *   True if Event is a mouse button event, else false.
     */
    bool is_mouse_button() const;

    /**
     * Check if this event is a specific mouse button event
     *
     * @param button
     *   Mouse button to check.
     *
     * @returns
     *   True if Event is a mouse button Event and matches supplied button.
     */
    bool is_mouse_button(MouseButton button) const;

    /**
     * Check if this event is a specific mouse button event and state
     *
     * @param button
     *   Mouse button to check.
     *
     * @param state
     *   State to check.
     *
     * @returns
     *   True if Event is a mouse button Event and matches supplied button and
     *   state.
     */
    bool is_mouse_button(MouseButton button, MouseButtonState state) const;

    /**
     * Get mouse button event, will throw if wrong type.
     *
     * @returns
     *   Mouse button event.
     */
    MouseButtonEvent mouse_button() const;

    /**
     * Check if Event is a touch event.
     *
     * @returns
     *   True if Event is a touch event, else false.
     */
    bool is_touch() const;

    /**
     * Get touch event will throw if wrong type.
     *
     * @returns
     *   Touch event.
     */
    TouchEvent touch() const;

    /**
     * Check if Event is a scroll wheel event.
     *
     * @returns
     *   True if Event is a scroll whell event, else false.
     */
    bool is_scroll_wheel() const;

    /**
     * Get scroll wheel event will throw if wrong type.
     *
     * @returns
     *   scroll wheel event.
     */
    ScrollWheelEvent scroll_wheel() const;

  private:
    /** Type of event. */
    EventType type_;

    /** Variant of possible Event types. */
    std::variant<QuitEvent, KeyboardEvent, MouseEvent, MouseButtonEvent, TouchEvent, ScrollWheelEvent> event_;
};

}

```

`include/iris/events/event_type.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>

namespace iris
{

/**
 * Enumeration of possible Event types.
 */
enum class EventType : std::uint32_t
{
    QUIT,
    KEYBOARD,
    MOUSE,
    MOUSE_BUTTON,
    TOUCH,
    SCROLL_WHEEL
};

}

```

`include/iris/events/keyboard_event.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>

namespace iris
{

/** Encapsulated whether a Key was a down or up press */
enum class KeyState : std::uint32_t
{
    DOWN,
    UP
};

/** Encapsulates all Key presses */
enum class Key : std::uint32_t
{
    UNKNOWN,
    NUM_0,
    NUM_1,
    NUM_2,
    NUM_3,
    NUM_4,
    NUM_5,
    NUM_6,
    NUM_7,
    NUM_8,
    NUM_9,
    A,
    B,
    C,
    D,
    E,
    F,
    G,
    H,
    I,
    J,
    K,
    L,
    M,
    N,
    O,
    P,
    Q,
    R,
    S,
    T,
    U,
    V,
    W,
    X,
    Y,
    Z,
    EQUAL,
    MINUS,
    RIGHT_BRACKET,
    LEFT_BRACKET,
    QUOTE,
    SEMI_COLON,
    BACKSLASH,
    COMMA,
    SLASH,
    PERIOD,
    GRAVE,
    KEYPAD_DECIMAL,
    KEYPAD_MULTIPLY,
    KEYPAD_PLUS,
    KEYPAD_CLEAR,
    KEYPAD_DIVIDE,
    KEYPAD_ENTER,
    KEYPAD_MINUS,
    KEYPAD_EQUALS,
    KEYPAD_0,
    KEYPAD_1,
    KEYPAD_2,
    KEYPAD_3,
    KEYPAD_4,
    KEYPAD_5,
    KEYPAD_6,
    KEYPAD_7,
    KEYPAD_8,
    KEYPAD_9,
    RETURN,
    TAB,
    SPACE,
    DEL,
    ESCAPE,
    COMMAND,
    SHIFT,
    CAPS_LOCK,
    OPTION,
    CONTROL,
    RIGHT_SHIFT,
    RIGHT_OPTION,
    RIGHT_CONTROL,
    FUNCTION,
    VOLUME_UP,
    VOLUME_DOWN,
    MUTE,
    F1,
    F2,
    F3,
    F4,
    F5,
    F6,
    F7,
    F8,
    F9,
    F10,
    F11,
    F12,
    F13,
    F14,
    F15,
    F16,
    F17,
    F18,
    F19,
    F20,
    HELP,
    HOME,
    FORWARD_DELETE,
    END,
    PAGE_UP,
    PAGE_DOWN,
    LEFT_ARROW,
    RIGHT_ARROW,
    DOWN_ARROW,
    UP_ARROW,
};

/**
 * Encapsulated a keyboard event. Stores the Key that was pressed
 * as well as if the Key was a down or up press
 */
struct KeyboardEvent
{
    /**
     * Constructor
     *
     * @param k
     *   The Key that was pressed
     *
     *  @param type
     *    Down or up press
     */
    KeyboardEvent(const Key key, const KeyState state)
        : key(key)
        , state(state)
    {
    }

    /** Key that was pressed */
    Key key;

    /** Down or up press */
    KeyState state;
};

}

```

`include/iris/events/mouse_button_event.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>

namespace iris
{
/** Encapsulates whether a mouse button we a down or up press. */
enum class MouseButtonState : std::uint32_t
{
    DOWN,
    UP
};

/** Encapsulates mouse buttons. */
enum class MouseButton : std::uint32_t
{
    LEFT,
    RIGHT
};

/**
 * Encapsulates a mouse button event.
 */
struct MouseButtonEvent
{
    /**
     * Construct a new MouseButtonEvent.
     *
     *
     * @param button
     *   Which mouse button was pressed.
     *
     * @param state
     *   Down or up press.
     */
    MouseButtonEvent(MouseButton button, MouseButtonState state)
        : button(button)
        , state(state)
    {
    }

    /** Mouse button pressed. */
    MouseButton button;

    /* Down or up press. */
    MouseButtonState state;
};
}

```

`include/iris/events/mouse_event.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

namespace iris
{

/**
 * Encapsulates a mouse event. Stores delta x and y movement from previous
 * event.
 */
struct MouseEvent
{
    /**
     * Construct a new mouse Event with delta x and y coordinates.
     *
     * @param delta_x
     *   The amount the cursor has moved along the x-axis since the last event.
     *
     * @param delta_y
     *   The amount the cursor has moved along the y-axis since the last event.
     */
    MouseEvent(const float delta_x, const float delta_y)
        : delta_x(delta_x)
        , delta_y(delta_y)
    {
    }

    /** Amount cursor has moved along x-axis since last mouse Event */
    float delta_x;

    /** Amount cursor has moved along y-axis since last mouse Event */
    float delta_y;
};

}

```

`include/iris/events/quit_event.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

namespace iris
{

/**
 * An event that signals the program should quit.
 */
struct QuitEvent
{
};

}

```

`include/iris/events/scroll_wheel_event.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

namespace iris
{

/**
 * Encapsulates a scroll wheel event. Stores delta y movement from previous * event.
 */
struct ScrollWheelEvent
{
    /**
     * Construct a new scroll whell Event with delta y coordinates.
     *
     * @param delta_y
     *   The amount the scroll has moved along the y-axis since the last event.
     */
    ScrollWheelEvent(const float delta_y)
        : delta_y(delta_y)
    {
    }

    /** Amount scroll wheel has moved along y-axis since last Event. */
    float delta_y;
};

}

```

`include/iris/events/touch_event.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <cstdint>

namespace iris
{

/**
 * Enumeration of touch event types.
 */
enum class TouchType : std::uint32_t
{
    BEGIN,
    MOVE,
    END
};

/**
 * Encapsulates a touch event. Stores screen position of event, type and a
 * unique id for the event.
 *
 * The id will be the same for all related touch events, i.e. a BEGIN, MOVE and
 * END event for the same touch will all have the same id. Id's are unique
 * amongst all active touches but maybe reused for future events.
 */
struct TouchEvent
{
    /**
     * Construct a new touch event.
     *
     * @param id
     *   Id for this event.
     *
     * @param type
     *   Type of event.
     *
     * @param x
     *   x coordinate in screen space of event.
     *
     * @param y
     *   y coordinate in screen space of event.
     */
    TouchEvent(std::uintptr_t id, TouchType type, float x, float y)
        : id(id)
        , type(type)
        , x(x)
        , y(y)
    {
    }

    /** Id of event. */
    std::uintptr_t id;

    /** Type of event. */
    TouchType type;

    /** x screen coordinate. */
    float x;

    /** y screen coordinate. */
    float y;
};

}

```

`include/iris/graphics/animation/animation.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <chrono>
#include <functional>
#include <map>
#include <string>
#include <string_view>
#include <tuple>
#include <vector>

#include "core/matrix4.h"
#include "core/quaternion.h"
#include "core/transform.h"
#include "core/vector3.h"
#include "graphics/keyframe.h"

namespace iris
{

/**
 * Enumeration of possible animation playback types.
 */
enum class PlaybackType
{
    /** Animation should keep playing. */
    LOOPING,

    /** Animation should play once. */
    SINGLE
};

/**
 * An animation represents a collection of keyframes for bones as well as providing an interface for smoothly
 * interpolating through them.
 */
class Animation
{
  public:
    /**
     * Construct a new Animation.
     *
     * @param duration
     *   Length of animation.
     *
     * @param name
     *   Name of animation, should be unique within a skeleton.
     *
     * @param frames
     *   Map of bone names to keyframes. Keyframes must be in time order.
     */
    Animation(
        std::chrono::milliseconds duration,
        const std::string &name,
        const std::map<std::string, std::vector<KeyFrame>, std::less<>> &frames);

    /**
     * Get animation name.
     *
     * @returns
     *   Animation name.
     */
    std::string name() const;

    /**
     * Get the Transformation for a bone at the current animation time. If the
     * time falls between two keyframes then this method will interpolate
     * between them.
     *
     * @param bone
     *   Bone name.
     *
     * @returns
     *   Transformation of supplied bone at current animation time.
     */
    Transform transform(std::string_view bone) const;

    /**
     * Check if a bone exists in the animation.
     *
     * @param bone
     *   Bone name.
     *
     * @returns
     *   True if bone exists, false otherwise.
     */
    bool bone_exists(std::string_view bone) const;

    /**
     * Advances the animation by the amount of time since the last call.
     */
    void advance();

    /**
     * Reset animation time back to 0.
     */
    void reset();

    /**
     * Get playback type.
     *
     * @returns
     *   Playback type.
     */
    PlaybackType playback_type() const;

    /**
     * Set new playback type.
     *
     * @param playback_type
     *   New playback type.
     */
    void set_playback_type(PlaybackType playback_type);

    /**
     * Get if the animation is currently running.
     *
     * @returns
     *   True if playback type is SINGLE and the animation is running, always true for LOOPING.
     */
    bool running() const;

    /**
     * Get animation duration.
     *
     * @returns
     *   Duration of animation.
     */
    std::chrono::milliseconds duration() const;

    /**
     * Set the current time of animation, must be in range [0, duration()].
     *
     * @param time
     *   New time.
     */
    void set_time(std::chrono::milliseconds time);

  private:
    /** Current time of animation. */
    std::chrono::milliseconds time_;

    /** When the animation was last advanced. */
    std::chrono::steady_clock::time_point last_advance_;

    /** Length of the animation. */
    std::chrono::milliseconds duration_;

    /** Name of animation. */
    std::string name_;

    /** Collection of bones and their keyframes. */
    std::map<std::string, std::vector<KeyFrame>, std::less<>> frames_;

    /** Type of playback. */
    PlaybackType playback_type_;
};

}

```

`include/iris/graphics/animation/animation_controller.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <memory>
#include <string_view>
#include <vector>

#include "graphics/animation/animation.h"
#include "graphics/animation/animation_layer.h"
#include "graphics/animation/animation_state.h"
#include "graphics/animation/animation_transition.h"
#include "graphics/animation/cached_bone_query.h"

namespace iris
{

class Skeleton;

/**
 * The AnimationController class provides the mechanism for animating skeletons. The base layer applies to all bones and
 * all subsequent layers can provide a mask to only animate specific bones. For example a skeleton could be running and
 * a layer which masks the arm bones could be used to play an attack animation. In the case where a non-looping
 * animation is applied to a masked layer a small easing is applied at the end to blend the bone back to the base layer
 * animation.
 */
class AnimationController
{
  public:
    /**
     * Construct a new AnimationController.
     *
     * @param animations
     *   Collection of animations to control. Note that the name of the animations is used as the identifier for all
     * other operations.
     *
     * @param layers
     *   Collection of layers. Note that the first element is considered the "bae layer" and must apply to all bones
     * i.e. cannot have a mask.
     *
     * @param skeleton
     *   The skeleton to apply animations to.
     */
    AnimationController(
        const std::vector<Animation> &animations,
        const std::vector<AnimationLayer> &layers,
        Skeleton *skeleton);

    ~AnimationController();

    AnimationController(AnimationController &&) noexcept = default;
    AnimationController &operator=(AnimationController &&) noexcept = default;

    /**
     * Updates the animations on all layers, should be called once per frame.
     */
    void update();

    /**
     * Start playing the named animation on the supplied layer. Note that if the name animation is not a valid
     * transition from the current animation this call is a no-op.
     *
     * @param layer
     *   Layer to play animation on.
     *
     * @param animation
     *   Name of animation to play.
     */
    void play(std::size_t layer, std::string_view animation);

  private:
    /** Skeleton to animate. */
    Skeleton *skeleton_;

    /** Collection of possible animations. */
    std::vector<Animation> animations_;

    /** User defined animation layers. */
    std::vector<AnimationLayer> layers_;

    /** Collection of states for internal state machine. */
    std::vector<std::vector<std::unique_ptr<AnimationState>>> states_;

    /** Pointer to current state. */
    std::vector<AnimationState *> current_state_;

    /** Object for querying bone data. */
    std::unique_ptr<CachedBoneQuery> query_;
};

}

```

`include/iris/graphics/animation/animation_layer.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <memory>
#include <string>
#include <string_view>
#include <vector>

#include "graphics/animation/animation_transition.h"

namespace iris
{

/**
 * Struct encapsulating a layer of animation i.e. a masked set of transitions. An empty bone mask implies the
 * transitions should apply to all bones.
 */
struct AnimationLayer
{
    /**
     * Construct a new AnimationLayer with an empty bone mask.
     *
     * @param transitions
     *   Transitions for this layer.
     *
     * @param start_animation
     *   Name of starting animation.
     */
    AnimationLayer(const std::vector<AnimationTransition> &transitions, std::string_view start_animation)
        : AnimationLayer({}, transitions, start_animation)
    {
    }

    /**
     * Construct a new AnimationLayer with a bone mask.
     *
     * @param bone_mask
     *   Collection of bone names to apply transitions to.
     *
     * @param transitions
     *   Transitions for this layer.
     *
     * @param start_animation
     *   Name of starting animation.
     */
    AnimationLayer(
        const std::vector<std::string> &bone_mask,
        const std::vector<AnimationTransition> &transitions,
        std::string_view start_animation)
        : bone_mask(bone_mask)
        , transitions(transitions)
        , start_animation(start_animation)
    {
    }

    /** Name of bones to apply transitions to. */
    std::vector<std::string> bone_mask;

    /** Collection of transitions to apply to masked bones. */
    std::vector<AnimationTransition> transitions;

    /** Name of starting animation. */
    std::string start_animation;
};

}

```

`include/iris/graphics/animation/animation_state.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <chrono>
#include <cstddef>
#include <map>
#include <string>
#include <string_view>

namespace iris
{

class Animation;
class Skeleton;
class CachedBoneQuery;

/**
 * Internal class for a state in an animation state machine. Each state represents an animation and a
 * possible transitions to other states.
 */
class AnimationState
{
  public:
    // helper alias
    using TransitionMap = std::map<std::string, std::tuple<AnimationState *, std::chrono::milliseconds>, std::less<>>;

    /**
     * Construct a new AnimationState.
     *
     * @param animation
     *   Animation for this state.
     *
     * @param skeleton
     *   Skeleton to apply animation to (via the query object).
     *
     * @param query
     *   Query object to apply animations to.
     *
     * @param layer
     *   Which layer this state is in.
     */
    AnimationState(Animation *animation, Skeleton *skeleton, CachedBoneQuery *query, std::size_t layer);

    /**
     * Called when state is entered.
     */
    void enter();

    /**
     * Called when state is exited.
     */
    void exit();

    /**
     * Update the animation in this state.
     *
     * @returns
     *   If this state is complete and should transition to a new state, otherwise nullptr.
     */
    AnimationState *update();

    /**
     * Set the intention to transition to a new state, applying any transition time. If the transition is not valid then
     * this call is a no-op.
     *
     * @param next
     *   The name of the state to transition to.
     */
    void transition(std::string_view next);

    /**
     * Get the skeleton.
     *
     * @returns
     *   Skeleton.
     */
    Skeleton *skeleton() const;

    /**
     * Get the skeleton.
     *
     * @returns
     *   Skeleton.
     */
    CachedBoneQuery *bone_query() const;

    /**
     * Get the skeleton.
     *
     * @returns
     *   Skeleton.
     */
    Animation *animation() const;

    /**
     * Get the transitions.
     *
     * @returns
     *   Transitions.
     */
    TransitionMap &transitions();

    /**
     * Get the next state.
     *
     * @returns
     *   Next state.
     */
    AnimationState *next_state() const;

    /**
     * Get when the transition will be completed.
     *
     * @returns
     *   Completion time point of transition.
     */
    std::chrono::system_clock::time_point transition_complete() const;

    /**
     * Get the layer.
     *
     * @returns
     *   Layer of state.
     */
    std::size_t layer() const;

  private:
    /** Skeleton to update (via query) */
    Skeleton *skeleton_;

    /** Query to update. */
    CachedBoneQuery *query_;

    /** Animation for state. */
    Animation *animation_;

    /** Collection of transitions. */
    TransitionMap transitions_;

    /** State to transition to. */
    AnimationState *next_state_;

    /** Time point when transition should be complete. */
    std::chrono::system_clock::time_point transition_complete_;

    /** Layer of state. */
    std::size_t layer_;
};

}

```

`include/iris/graphics/animation/animation_transition.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <chrono>
#include <string>
#include <string_view>

namespace iris
{

/**
 * Struct encapsulating all the data needed for an animation transition.
 */
struct AnimationTransition
{
    /**
     * Construct a new AnimationTransition.
     *
     * @param from
     *   Name of animation to transition from.
     *
     * @param to
     *   Name of animation to transition from.
     *
     * @param duration
     *   How long the transition should take.
     */
    AnimationTransition(std::string_view from, std::string_view to, std::chrono::milliseconds duration)
        : from(from)
        , to(to)
        , duration(duration)
    {
    }

    /** Name of animation to transition from. */
    std::string from;

    /** Name of animation to transition to. */
    std::string to;

    /** Length of transition. */
    std::chrono::milliseconds duration;
};

}

```

`include/iris/graphics/animation/bone_query.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <optional>
#include <string_view>

#include "core/transform.h"

namespace iris
{

/**
 * Interface for querying bone transformations.
 */
class BoneQuery
{
  public:
    virtual ~BoneQuery() = default;

    /**
     * Get the transformation for a bone.
     *
     * @param bone_name
     *   Name of the bone to query.
     *
     * @returns
     *   Bone transform, if bone exists.
     */
    virtual std::optional<Transform> transform(std::string_view bone_name) = 0;
};

}

```

`include/iris/graphics/animation/cached_bone_query.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <chrono>
#include <functional>
#include <map>
#include <optional>
#include <set>
#include <string>
#include <string_view>
#include <vector>

#include "core/transform.h"
#include "graphics/animation/bone_query.h"

namespace iris
{

class Animation;
class Skeleton;

/**
 * Implementation of BoneQuery that caches the transform of each bone. This allows us to blend from whatever the current
 * state is towards a new state. This is required for implementing transitions and layers.
 */
class CachedBoneQuery : public BoneQuery
{
  public:
    /**
     * Construct a new CachedBoneQuery.
     *
     * @param skeleton
     *   Skeleton to get bone names from.
     * @param bone_masks
     *   Collection of masks for bones per layer.
     */
    CachedBoneQuery(const Skeleton *skeleton, const std::vector<std::set<std::string>> &bone_masks);

    /**
     * Get the transformation for a bone.
     *
     * @param bone_name
     *   Name of the bone to query.
     *
     * @returns
     *   Bone transform, if bone exists.
     */
    std::optional<Transform> transform(std::string_view bone_name) override;

    /**
     * Update the bone transformations for the supplied layer.
     *
     * @param layer
     *   Layer to update.
     *
     * @param animation
     *   Animation to apply to bones.
     */
    void update(std::size_t layer, Animation *animation);

    /**
     * Blend the current state of the bones towards another animation.
     *
     * @param layer
     *   Layer to update.
     *
     * @param animation
     *   Animation to blend towards.
     *
     * @param blend_amount
     * . Amount to blend [0.0, 1.0].
     */
    void blend(std::size_t layer, Animation *animation, float blend_amount);

  private:
    /**
     * Internal struct for a cached bone.
     */
    struct CachedBone
    {
        std::size_t layer;
        Transform transform;
        std::chrono::system_clock::time_point ease_end;
    };

    /** Collection mapping bone name to bone data. */
    std::map<std::string, CachedBone, std::less<>> transforms_;
};

}
```

`include/iris/graphics/animation/utils.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <chrono>

namespace iris
{

/**
 * Calculate the blend amount for the current time in an animation.
 *
 * @param duration
 *   Length of animation.
 *
 * @param end_time
 *   Time point when animation ends.
 *
 * @returns
 *   Blend amount for current progress in animation [0.0, 1.0].
 */
float blend_amount(std::chrono::milliseconds duration, std::chrono::system_clock::time_point end_time);

}

```

`include/iris/graphics/bone.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <string>
#include <vector>

#include "core/matrix4.h"
#include "core/transform.h"
#include "graphics/weight.h"

namespace iris
{

/**
 * A bone is a component of skeletal animation. It represents a series of
 * vertices it influences as well as the amount it influences them (weight).
 * Alternatively a bone may have zero weights, in this case it represents an
 * intermediate transformation in the bone hierarchy.
 *
 * A bone stores two matrices:
 *  offset - transforms vertices from local space to bone space
 *  transform - transforms vertices into the current bone pose
 *
 * During execution the offset is immutable but the transform will change as the
 * skeleton the bone is part of is animated.
 *
 * If a bone is set to "manual" then it's transform is absolute i.e. a Skeleton
 * will not apply its parent transformation. This is useful if you want to set
 * a position in world space.
 */
class Bone
{
  public:
    /**
     * Construct a new Bone.
     *
     * @param name
     *   Unique name of the bone.
     *
     * @param parent
     *   Unique name of the parent bone.
     *
     * @param offset
     *   Matrix which transforms vertices from local space to bone space.
     *
     * @param transform
     *   Initial matrix which transforms bone for an animation.
     */
    Bone(const std::string &name, const std::string &parent, const Matrix4 &offset, const Matrix4 &transform);

    /**
     * Get name of bone.
     *
     * @returns
     *  Bone name.
     */
    std::string name() const;

    /** Get name of parent pone.
     *
     * @returns
     *   Parent bone name.
     */
    std::string parent() const;

    /**
     * Get reference to offset matrix.
     *
     * @returns
     *   Reference to offset matrix.
     */
    const Matrix4 &offset() const;

    /**
     * Get reference to transformation matrix.
     *
     * @returns
     *   Reference to transform matrix.
     */
    const Matrix4 &transform() const;

    /**
     * Set the transformation matrix.
     *
     * @param transform
     *   New transform.
     */
    void set_transform(const Matrix4 &transform);

    /**
     * Check if the bone is manual.
     *
     * @returns
     *   True if bone is manual, false otherwise.
     */
    bool is_manual() const;

    /**
     * Set if bone is manual.
     *
     * @param is_manual
     *   New manual value
     */
    void set_manual(bool is_manual);

  private:
    /** Bone name. */
    std::string name_;

    /** Parent bone name. */
    std::string parent_;

    /** Offset matrix. */
    Matrix4 offset_;

    /** Transformation matrix. */
    Matrix4 transform_;

    /** If bone is manual. */
    bool is_manual_;
};

}

```

`include/iris/graphics/constant_buffer_writer.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <array>
#include <cstddef>

namespace iris
{

/**
 * This class provides a convenient way of writing to some (graphics api
 * specific) constant data buffer. It is designed such that subsequent calls to
 * write() will automatically advance, so the buffer can be filled by repeated
 * calls.
 */
template <class T>
class ConstantBufferWriter
{
  public:
    /**
     * Construct a new ConstantBufferWriter.
     *
     * @param buffer
     *   Buffer to write data to.
     */
    ConstantBufferWriter(T &buffer)
        : buffer_(buffer)
        , offset_(0u)
    {
    }

    /**
     * Write an object to the buffer at the current position.
     *
     * @param object
     *   Object to write.
     */
    template <class S>
    void write(const S &object)
    {
        buffer_.write(object, offset_);
        offset_ += sizeof(S);
    }

    /**
     * Write a collection of objects to the buffer at the current position.
     *
     * @param objects
     *   Objects to write.
     */
    template <class S>
    void write(const std::vector<S> &objects)
    {
        buffer_.write(objects.data(), sizeof(S) * objects.size(), offset_);
        offset_ += sizeof(S) * objects.size();
    }

    /**
     * Write an array of objects to the buffer at the current position.
     *
     * @param objects
     *   Objects to write.
     */
    template <class S, std::size_t N>
    void write(const std::array<S, N> &objects)
    {
        buffer_.write(objects.data(), sizeof(S) * N, offset_);
        offset_ += sizeof(S) * objects.size();
    }

    /**
     * Advance the internal offset into the buffer.
     *
     * @param offset
     *   Amount (in bytes) to increment internal offset.
     */
    void advance(std::size_t offset)
    {
        offset_ += offset;
    }

  private:
    /** Buffer to write to, */
    T &buffer_;

    /** Offset into buffer to write to. */
    std::size_t offset_;
};

}

```

`include/iris/graphics/cube_map.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>

#include "graphics/sampler.h"

namespace iris
{

/**
 * Abstract class for a cube map i.e. a texture with six slices, one for each face of a cube.
 */
class CubeMap
{
  public:
    /**
     * Construct a new CubeMap.
     *
     * @param sampler
     *   Sampler to use for this cube map.
     *
     * @param index
     *   Index into the global array of all allocated cube maps.
     */
    CubeMap(const Sampler *sampler, std::uint32_t index);
    virtual ~CubeMap() = default;

    /**
     * Get cube map sampler.
     *
     * @returns
     *   Sampler for cube map`.
     */
    const Sampler *sampler() const;

    /**
     * Get index into global array of all allocated cube maps.
     *
     * This is most useful for bindless cube maps as the cube map knows where in the mapped cube map table to find
     * itself.
     *
     * @returns
     *   Index of cube map.
     */
    std::uint32_t index() const;

  private:
    /** Sampler for cube map. */
    const Sampler *sampler_;

    /** Index into the global array of all allocated cube maps. */
    std::uint32_t index_;
};

}

```

`include/iris/graphics/d3d12/d3d12_buffer.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <cstdint>
#include <vector>

#include <wrl.h>

#include "directx/d3d12.h"

#include "graphics/vertex_data.h"

namespace iris
{

/**
 * This class encapsulates a d3d12 buffer. A buffer can be created with either
 * vertex or index data.
 *
 * Note that this class provides access to d3d12 views to the data stored. These
 * are accessed via either vertex_view() or index_view(), however only one of
 * these calls will be valid and that is based in which constructor was used.
 * This is an internal class and as such the engine knows how to correctly call
 * the required view. This class does *not* perform any checks on the view
 * class. Calling the incorrect view call is undefined.
 */
class D3D12Buffer
{
  public:
    /**
     * Construct a new D3D12Buffer with vertex data.
     *
     * @param vertex_data
     *   Vertex data to copy to buffer.
     */
    D3D12Buffer(const std::vector<VertexData> &vertex_data);

    /**
     * Construct a new D3D12Buffer with index data.
     *
     * @param vertex_data
     *   Index data to copy to buffer.
     */
    D3D12Buffer(const std::vector<std::uint32_t> &index_data);

    D3D12Buffer(const D3D12Buffer &) = delete;
    D3D12Buffer &operator=(const D3D12Buffer &) = delete;

    /**
     * Get the number of elements stored in the buffer.
     *
     * @returns
     *   Number of elements in buffer.
     */
    std::size_t element_count() const;

    /**
     * Get the native view to the vertex data. Only valid if the vertex data
     * constructor was used.
     *
     * @returns
     *   D3D12 view to vertex data.
     */
    D3D12_VERTEX_BUFFER_VIEW vertex_view() const;

    /**
     * Get the native view to the index data. Only valid if the index data
     * constructor was used.
     *
     * @returns
     *   D3D12 view to index data.
     */
    D3D12_INDEX_BUFFER_VIEW index_view() const;

    /**
     * Write vertex data to the buffer.
     *
     * @param vertex_data
     *   New vertex data.
     */
    void write(const std::vector<VertexData> &vertex_data);

    /**
     * Write index data to the buffer.
     *
     * @param index_data
     *   New index data.
     */
    void write(const std::vector<std::uint32_t> &index_data);

  private:
    /** D3D12 handle to buffer. */
    ::Microsoft::WRL::ComPtr<ID3D12Resource> resource_;

    /** View to vertex data, only valid for vertex data constructor. */
    D3D12_VERTEX_BUFFER_VIEW vertex_buffer_view_;

    /** View to index data, only valid for index data constructor. */
    D3D12_INDEX_BUFFER_VIEW index_buffer_view_;

    /** Number of elements in buffer. */
    std::size_t element_count_;

    /** Maximum number of elements that can be stored in buffer. */
    std::size_t capacity_;

    /** Pointer to mapped memory where new buffer data can be written. */
    std::byte *mapped_memory_;
};

}

```

`include/iris/graphics/d3d12/d3d12_constant_buffer.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <cstdint>
#include <iostream>

#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <wrl.h>

#include "directx/d3d12.h"
#include "directx/d3dx12.h"

#include "core/exception.h"
#include "graphics/d3d12/d3d12_descriptor_handle.h"

namespace iris
{

/**
 * This class encapsulates a constant shader buffer. This is data that is set once then made available to all
 * vertices/fragments.
 */
class D3D12ConstantBuffer
{
  public:
    /**
     * Construct a null D3D12ConstantBuffer.
     *
     * @param frame
     *   The frame number using this buffer.
     */
    D3D12ConstantBuffer(std::uint32_t frame);

    /**
     * Construct a new D3D12ConstantBuffer.
     *
     * @param frame
     *   The frame number using this buffer.
     *
     * @param capacity
     *   Size (in bytes) of buffer.
     */
    D3D12ConstantBuffer(std::uint32_t frame, std::size_t capacity);

    D3D12ConstantBuffer(const D3D12ConstantBuffer &) = delete;
    D3D12ConstantBuffer &operator=(const D3D12ConstantBuffer &) = delete;
    D3D12ConstantBuffer(D3D12ConstantBuffer &&) = default;
    D3D12ConstantBuffer &operator=(D3D12ConstantBuffer &&) = default;

    /**
     * Get descriptor handle to buffer.
     *
     * @returns
     *   Buffer handle.
     */
    D3D12DescriptorHandle descriptor_handle() const;

    /**
     * Write an object into the buffer at an offset.
     *
     * @param object
     *   Object to write.
     *
     * @param offset
     *   Offset into buffer to write object.
     */
    template <class T>
    void write(const T &object, std::size_t offset)
    {
        write(std::addressof(object), sizeof(T), offset);
    }

    /**
     * Write an object into the buffer at an offset.
     *
     * @param object
     *   Object to write.
     *
     * @param size
     *   Size (in bytes) of object to write.
     *
     * @param offset
     *   Offset into buffer to write object.
     */
    template <class T>
    void write(const T *object, std::size_t size, std::size_t offset)
    {
        if (offset + size > capacity_)
        {
            throw Exception("write would overflow");
        }

        std::memcpy(mapped_buffer_ + offset, object, size);
    }

    /**
     * Get D3D12 resource.
     *
     * @returns
     *   Internal resource for buffer.
     */
    ID3D12Resource *resource() const
    {
        return resource_.Get();
    }

  private:
    /** Capacity (in bytes) of buffer. */
    std::size_t capacity_;

    /** Pointer to mapped buffer where data can be written. */
    std::byte *mapped_buffer_;

    /** D3D12 handle to resource view. */
    Microsoft::WRL::ComPtr<ID3D12Resource> resource_;

    /** D3D12 handle to buffer. */
    D3D12DescriptorHandle descriptor_handle_;
};

}

```

`include/iris/graphics/d3d12/d3d12_constant_buffer_pool.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <vector>

#include "graphics/d3d12/d3d12_constant_buffer.h"

namespace iris
{

/**
 * This class encapsulates a pool of D3D12ConstantBuffer objects as a fixed size buffer.
 */
class D3D12ConstantBufferPool
{
  public:
    /**
     * Construct a new D3D12ConstantBufferPool.
     *
     * @param frame
     *   The frame number the pool is for.
     */
    D3D12ConstantBufferPool(std::uint32_t frame);

    /**
     * Get the next D3D12ConstantBuffer in the circular buffer.
     *
     * @returns
     *   Next D3D12ConstantBuffer.
     */
    D3D12ConstantBuffer &next();

    /**
     * Reset the pool to the beginning, this will cause next() to recycle buffers.
     */
    void reset();

  private:
    /** Pool of D3D12ConstantBuffer objects. */
    std::vector<D3D12ConstantBuffer> buffers_;

    /** Index into pool of next free object. */
    std::size_t index_;
};

}

```

`include/iris/graphics/d3d12/d3d12_context.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <memory>

#include <dxgi1_6.h>
#include <wrl.h>

#include "directx/d3d12.h"
#include "directx/d3dx12.h"

#include "graphics/d3d12/d3d12_root_signature.h"

namespace iris
{

/**
 * This class provides singleton access to various D3D12 primitives.
 */
class D3D12Context
{
  public:
    /**
     * Get the DXGI factory.c
     *
     * @returns
     *   DXGI factory.
     */
    static IDXGIFactory4 *dxgi_factory();

    /**
     * Get the D3D12 device.
     *
     * @returns
     *   D3D12 device.
     */
    static ID3D12Device2 *device();

    /**
     * Get the default root signature.
     *
     * @returns
     *   Default root signature.
     */
    inline static auto &root_signature();

  private:
    // private to force access through above public static methods
    D3D12Context();
    static D3D12Context &instance();

    // these are the member function equivalents of the above static methods
    // see their docs for details

    IDXGIFactory4 *dxgi_factory_impl() const;

    ID3D12Device2 *device_impl() const;

    auto &root_signature_impl()
    {
        return *root_signature_;
    }

    /** D3D12 handle to dxgi factory. */
    Microsoft::WRL::ComPtr<IDXGIFactory4> dxgi_factory_;

    /** D3D12 handle to d3d12 device. */
    Microsoft::WRL::ComPtr<ID3D12Device2> device_;

    /** D3D12 handle to d3d12 info queue. */
    Microsoft::WRL::ComPtr<ID3D12InfoQueue> info_queue_;

    /** Root signature for materials. */
    std::unique_ptr<D3D12RootSignature<
        ConstantBufferViewParameter<0u, 0u, D3D12_SHADER_VISIBILITY_ALL>,
        ConstantBufferViewParameter<1u, 0u, D3D12_SHADER_VISIBILITY_ALL>,
        ConstantBufferViewParameter<2u, 0u, D3D12_SHADER_VISIBILITY_ALL>,
        ConstantParameter<3u, 0u, D3D12_SHADER_VISIBILITY_ALL>,
        ConstantParameter<4u, 0u, D3D12_SHADER_VISIBILITY_ALL>,
        ConstantParameter<5u, 0u, D3D12_SHADER_VISIBILITY_ALL>,
        ConstantBufferViewParameter<6u, 0u, D3D12_SHADER_VISIBILITY_ALL>,
        ShaderResourceViewParameter<0u, 0u, D3D12_SHADER_VISIBILITY_ALL>,
        TableParameter<D3D12_DESCRIPTOR_RANGE_TYPE_SRV, UINT_MAX, 0u, 1u, D3D12_SHADER_VISIBILITY_PIXEL>,
        TableParameter<D3D12_DESCRIPTOR_RANGE_TYPE_SRV, UINT_MAX, 0u, 2u, D3D12_SHADER_VISIBILITY_PIXEL>,
        TableParameter<D3D12_DESCRIPTOR_RANGE_TYPE_SAMPLER, UINT_MAX, 0u, 0u, D3D12_SHADER_VISIBILITY_PIXEL>>>
        root_signature_;
};

auto &D3D12Context::root_signature()
{
    return instance().root_signature_impl();
}

}

```

`include/iris/graphics/d3d12/d3d12_cpu_descriptor_handle_allocator.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <array>
#include <cstdint>
#include <vector>

#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <wrl.h>

#include "directx/d3d12.h"
#include "directx/d3dx12.h"

#include "core/error_handling.h"
#include "graphics/d3d12/d3d12_context.h"
#include "graphics/d3d12/d3d12_descriptor_handle.h"
#include "log/log.h"

namespace iris
{

/**
 * This class provides the mechanisms for allocating cpu descriptor heaps and descriptor handles. An instance of this
 * class will pre-allocate a fixed sized pool of descriptors for a given d3d12 heap type, it then provides methods for
 * allocating handles from this pool. This class maintains two types of allocation:
 *  - static : allocated for the lifetime of the class
 *  - dynamic : reserved until reset
 *
 * This allows for handles to be allocated that only live for one render pass (dynamic) or multiple frames (static).
 *
 * The dynamic section is split into N sections, one for each frame in the swap chain. This allows a frame to
 * independently manage its own handles.
 *
 * Example heap layout:
 *
 *                Pool of all descriptor handles
 *               .- +----------------------+
 *               |  | static descriptor 1  |
 *               |  +----------------------+
 *               |  | static descriptor 2  |
 *               |  +----------------------+
 *  Static pool  |  |                      |
 *               |  |                      |
 *               |  |                      |
 *               |  |                      |
 *               |  |                      |
 *               +- +----------------------+ -.
 *               |  | dynamic descriptor 1 |  |
 *               |  +----------------------+  |
 *               |  | dynamic descriptor 2 |  |
 *               |  +----------------------+  | Frame 1
 *               |  | dynamic descriptor 3 |  |
 *               |  +----------------------+  |
 *               |  |          ...         |  |
 *               |  +----------------------+ -+
 *               |  | dynamic descriptor 1 |  |
 *               |  +----------------------+  |
 *  Dynamic pool |  | dynamic descriptor 2 |  |
 *               |  +----------------------+  | Frame 2
 *               |  | dynamic descriptor 3 |  |
 *               |  +----------------------+  |
 *               |  |          ...         |  |
 *               |  +----------------------+ -+
 *               |  | dynamic descriptor 1 |  |
 *               |  +----------------------+  |
 *               |  | dynamic descriptor 2 |  |
 *               |  +----------------------+  | Frame 3
 *               |  | dynamic descriptor 3 |  |
 *               |  +----------------------+  |
 *               |  |         ...          |  |
 *                '-+----------------------+ -'
 */
template <std::uint32_t N>
class D3D12CPUDescriptorHandleAllocator
{
  public:
    /**
     * Construct a new D3D12CPUDescriptorHandleAllocator.
     *
     * @param type
     *   D3D12 heap type to create.
     *
     * @param num_descriptors
     *   Number of descriptors to create in heap (static + dynamic).
     *
     * @param static_size
     *   The number of descriptors to reserve for static descriptors.
     *
     * @param shader_visible
     *   Flag indicating whether the allocated descriptors should be visible to
     *   the gpu or just the cpu.
     */
    D3D12CPUDescriptorHandleAllocator(
        D3D12_DESCRIPTOR_HEAP_TYPE type,
        std::uint32_t num_descriptors,
        std::uint32_t static_size,
        bool shader_visible = false)
        : descriptor_heap_(nullptr)
        , heap_start_()
        , descriptor_size_(0u)
        , static_index_(0u)
        , dynamic_indices_()
        , static_capacity_(static_size)
        , dynamic_capacity_((num_descriptors - static_size) / N)
        , static_free_list_()
    {
        auto *device = D3D12Context::device();

        // setup heap description
        D3D12_DESCRIPTOR_HEAP_DESC heap_description;
        heap_description.NumDescriptors = num_descriptors;
        heap_description.Type = type;
        heap_description.Flags =
            shader_visible ? D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE : D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
        heap_description.NodeMask = 0;

        // create heap
        expect(
            device->CreateDescriptorHeap(&heap_description, IID_PPV_ARGS(&descriptor_heap_)) == S_OK,
            "could not create descriptor heap");

        descriptor_size_ = device->GetDescriptorHandleIncrementSize(type);

        heap_start_ = descriptor_heap_->GetCPUDescriptorHandleForHeapStart();

        // set indices for dynamic pools
        for (auto i = 0u; i < N; ++i)
        {
            dynamic_indices_[i] = static_size + (i * dynamic_capacity_);
        }
    }

    /**
     * Allocate a static descriptor from the pool.
     *
     * @returns
     *   A new static descriptor.
     */
    D3D12DescriptorHandle allocate_static()
    {
        auto index = static_index_;

        // try and get an index from the free list before using the next available one
        if (!static_free_list_.empty())
        {
            index = static_free_list_.back();
            static_free_list_.pop_back();
        }
        else
        {
            expect(static_index_ < static_capacity_, "heap too small");
            ++static_index_;
        }

        // get next free descriptor form static pool
        D3D12_CPU_DESCRIPTOR_HANDLE cpu_handle = heap_start_;
        cpu_handle.ptr += descriptor_size_ * index;

        return {cpu_handle};
    }
    /**
     * Allocate a dynamic descriptor from the pool.
     *
     * @returns
     *   A new dynamic descriptor.
     */
    D3D12DescriptorHandle allocate_dynamic(std::uint32_t frame)
    {
        expect(frame < N, "invalid frame number");
        expect(dynamic_indices_[frame] < static_capacity_ + ((frame + 1u) * dynamic_capacity_), "heap too small");

        // get next free descriptor form dynamic pool
        D3D12_CPU_DESCRIPTOR_HANDLE cpu_handle = heap_start_;
        cpu_handle.ptr += descriptor_size_ * (static_capacity_ + dynamic_indices_[frame]);

        ++dynamic_indices_[frame];

        return {cpu_handle};
    }

    /**
     * Release a statically allocate handle.
     *
     * @param handle
     *   Handle to release.
     */
    void release_static(const D3D12DescriptorHandle &handle)
    {
        // recompute index from ptr
        const auto ptr = handle.cpu_handle().ptr;
        const auto index = (ptr - heap_start_.ptr) / descriptor_size_;

        static_free_list_.emplace_back(static_cast<std::uint32_t>(index));
    }

    /**
     * Get the size of a descriptor handle.
     *
     * @returns
     *   Descriptor handle size.
     */
    std::uint32_t descriptor_size() const
    {
        return descriptor_size_;
    }

    /**
     * Reset the dynamic allocation for a given frame. This means future calls to allocate_dynamic could return handles
     * that have been previously allocated.
     *
     * @param frame
     *   Frame number to reset.
     */
    void reset_dynamic(std::uint32_t frame)
    {
        expect(frame < N, "invalid frame number");

        dynamic_indices_[frame] = static_capacity_ + (frame * dynamic_capacity_);
    }

  private:
    /** D3D12 handle to descriptor heap. */
    ::Microsoft::WRL::ComPtr<::ID3D12DescriptorHeap> descriptor_heap_;

    /** D3D12 handle to start of heap. */
    D3D12_CPU_DESCRIPTOR_HANDLE heap_start_;

    /** Size of a single descriptor handle. */
    std::uint32_t descriptor_size_;

    /** The current index into the static pool. */
    std::uint32_t static_index_;

    /** The current index into each dynamic pool. */
    std::array<std::uint32_t, N> dynamic_indices_;

    /** Maximum number of static handles. */
    std::uint32_t static_capacity_;

    /** Maximum number of dynamic handles in a frame. */
    std::uint32_t dynamic_capacity_;

    /** Free list of released handles. */
    std::vector<std::uint32_t> static_free_list_;
};

}

```

`include/iris/graphics/d3d12/d3d12_cube_map.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <array>
#include <cstdint>

#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <wrl.h>

#include "directx/d3d12.h"
#include "directx/d3dx12.h"

#include "core/data_buffer.h"
#include "graphics/cube_map.h"
#include "graphics/d3d12/d3d12_descriptor_handle.h"

namespace iris
{

/**
 * Implementation of CubeMap for d3d12.
 */
class D3D12CubeMap : public CubeMap
{
  public:
    /**
     * Construct a new D3D12CubeMap.
     *
     * @param right_data
     *   Image data for right face of cube.
     *
     * @param left_data
     *   Image data for left face of cube.
     *
     * @param top_data
     *   Image data for top face of cube.
     *
     * @param bottom_data
     *   Image data for bottom face of cube.
     *
     * @param back_data
     *   Image data for back face of cube.
     *
     * @param front_data
     *   Image data for front face of cube.
     *
     * @param width
     *   Width of each image face.
     *
     * @param height
     *   Height of each image face.
     *
     * @param sampler
     *   Sampler to use for this cube map.
     *
     * @param index
     *   Index into the global array of all allocated textures.
     */
    D3D12CubeMap(
        const DataBuffer &right_data,
        const DataBuffer &left_data,
        const DataBuffer &top_data,
        const DataBuffer &bottom_data,
        const DataBuffer &back_data,
        const DataBuffer &front_data,
        std::uint32_t width,
        std::uint32_t height,
        const Sampler *sampler,
        std::uint32_t index);

    ~D3D12CubeMap() override = default;

    /*
     * Get the handle to the d3d12 resource where the image data will be copied
     * to.
     *
     * @returns
     *   D3D12 resource.
     */
    ID3D12Resource *resource() const;

    /**
     * Get the handle to the d3d12 resource where the image data is initially
     * uploaded to
     *
     * @returns
     *   D3D12 resource.
     */
    ID3D12Resource *upload() const;

    /**
     * Get the handle to the image resource view.
     *
     * @returns
     *   Resource view handle.
     */
    D3D12DescriptorHandle handle() const;

    /**
     * Get the d3d12 footprints describing the image data layout for each cube face.
     *
     * @returns
     *   D3D12 footprints.
     */
    std::array<D3D12_PLACED_SUBRESOURCE_FOOTPRINT, 6u> footprints() const;

  private:
    /** Handle to resource where image data will be coped to. */
    Microsoft::WRL::ComPtr<ID3D12Resource> resource_;

    /** Handle to resource where image data is uploaded to. */
    Microsoft::WRL::ComPtr<ID3D12Resource> upload_;

    /** Resource view to image data. */
    D3D12DescriptorHandle resource_view_;

    /** Type of heap to copy data to. */
    D3D12_DESCRIPTOR_HEAP_TYPE type_;

    /** Footprint describing the image data layout for each cube face. */
    std::array<D3D12_PLACED_SUBRESOURCE_FOOTPRINT, 6u> footprints_;
};

}

```

`include/iris/graphics/d3d12/d3d12_descriptor_handle.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include "directx/d3d12.h"
#include "directx/d3dx12.h"

namespace iris
{

/**
 * This class encapsulates a d3d12 descriptor handle, which is a unique handle
 * to an opaque block of data that fully describes an object to the gpu.
 *
 * For more information see:
 * https://docs.microsoft.com/en-us/windows/win32/direct3d12/descriptors-overview
 */
class D3D12DescriptorHandle
{
  public:
    /**
     * Construct an empty (or null) D3D12DescriptorHandle.
     */
    D3D12DescriptorHandle();

    /**
     * Construct a D3D12DescriptorHandle with a cpu handle.
     *
     * @param cpu_handle
     *   CPU handle for desciptor.
     */
    D3D12DescriptorHandle(D3D12_CPU_DESCRIPTOR_HANDLE cpu_handle);

    /**
     * Construct a D3D12DescriptorHandle with a cpu and gpu handle.
     *
     * @param cpu_handle
     *   CPU handle for descriptor.
     *
     * @param gpu_handle
     *   GPU handle for descriptor.
     */
    D3D12DescriptorHandle(D3D12_CPU_DESCRIPTOR_HANDLE cpu_handle, D3D12_GPU_DESCRIPTOR_HANDLE gpu_handle);

    /**
     * Get cpu handle, maybe null.
     *
     * @returns
     *   CPU handle.
     */
    D3D12_CPU_DESCRIPTOR_HANDLE cpu_handle() const;

    /**
     * Get gpu handle, maybe null.
     *
     * @returns
     *   GPU handle.
     */
    D3D12_GPU_DESCRIPTOR_HANDLE gpu_handle() const;

    /**
     * Get if this object has a descriptor.
     *
     * @returns
     *   True if object has a descriptor, false otherwise.
     */
    explicit operator bool() const;

  private:
    /** CPU descriptor handle, maybe null. */
    D3D12_CPU_DESCRIPTOR_HANDLE cpu_handle_;

    /** GPU descriptor handle, maybe null. */
    D3D12_GPU_DESCRIPTOR_HANDLE gpu_handle_;
};

}

```

`include/iris/graphics/d3d12/d3d12_descriptor_manager.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <unordered_map>

#include "directx/d3d12.h"
#include "directx/d3dx12.h"

#include "graphics/d3d12/d3d12_cpu_descriptor_handle_allocator.h"
#include "graphics/d3d12/d3d12_gpu_descriptor_handle_allocator.h"

namespace iris
{

/**
 * This class provides singleton access to heap allocators. It manages a
 * separate heap for various different d3d12 heap types.
 */
class D3D12DescriptorManager
{
  public:
    /**
     * Get the cpu allocator for a given heap type.
     *
     * @param type
     *   D3D12 heap type to get allocator for.
     *
     * @returns
     *   Heap allocator for provided type.
     */
    static D3D12CPUDescriptorHandleAllocator<3u> &cpu_allocator(D3D12_DESCRIPTOR_HEAP_TYPE type);

    /**
     * Get the gpu allocator for a given heap type.
     *
     * @param type
     *   D3D12 heap type to get allocator for.
     *
     * @returns
     *   Heap allocator for provided type.
     */
    static D3D12GPUDescriptorHandleAllocator<3u> &gpu_allocator(D3D12_DESCRIPTOR_HEAP_TYPE type);

  private:
    // private to force access through above public static methods
    D3D12DescriptorManager();
    static D3D12DescriptorManager &instance();

    // these are the member function equivalents of the above static methods
    // see their docs for details

    D3D12CPUDescriptorHandleAllocator<3u> &cpu_allocator_impl(D3D12_DESCRIPTOR_HEAP_TYPE type);

    D3D12GPUDescriptorHandleAllocator<3u> &gpu_allocator_impl(D3D12_DESCRIPTOR_HEAP_TYPE type);

    /** Map of D3D12 heap type to heap allocator. */
    std::unordered_map<D3D12_DESCRIPTOR_HEAP_TYPE, D3D12CPUDescriptorHandleAllocator<3u>> cpu_allocators_;

    /** Map of D3D12 heap type to heap allocator. */
    std::unordered_map<D3D12_DESCRIPTOR_HEAP_TYPE, D3D12GPUDescriptorHandleAllocator<3u>> gpu_allocators_;
};

}

```

`include/iris/graphics/d3d12/d3d12_gpu_descriptor_handle_allocator.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <array>
#include <cstdint>

#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <wrl.h>

#include "directx/d3d12.h"
#include "directx/d3dx12.h"

#include "core/error_handling.h"
#include "graphics/d3d12/d3d12_context.h"
#include "graphics/d3d12/d3d12_descriptor_handle.h"

namespace iris
{

/**
 * This class provides the mechanisms for allocating gpu descriptor heaps and descriptor handles. An instance of this
 * class will pre-allocate a fixed sized pool of descriptors for a given d3d12 heap type, it then provides methods for
 * allocating handles from this pool. This class maintains two types of allocation:
 *  - static : allocated for the lifetime of the class
 *  - dynamic : reserved until reset
 *
 * This allows for handles to be allocated that only live for one render pass (dynamic) or multiple frames (static).
 *
 * The dynamic section is split into N sections, one for each frame in the swap chain. This allows a frame to
 * independently manage its own handles.
 *
 * Example heap layout:
 *
 *                Pool of all descriptor handles
 *               .- +----------------------+
 *               |  | static descriptor 1  |
 *               |  +----------------------+
 *               |  | static descriptor 2  |
 *               |  +----------------------+
 *  Static pool  |  |                      |
 *               |  |                      |
 *               |  |                      |
 *               |  |                      |
 *               |  |                      |
 *               +- +----------------------+ -.
 *               |  | dynamic descriptor 1 |  |
 *               |  +----------------------+  |
 *               |  | dynamic descriptor 2 |  |
 *               |  +----------------------+  | Frame 1
 *               |  | dynamic descriptor 3 |  |
 *               |  +----------------------+  |
 *               |  |          ...         |  |
 *               |  +----------------------+ -+
 *               |  | dynamic descriptor 1 |  |
 *               |  +----------------------+  |
 *  Dynamic pool |  | dynamic descriptor 2 |  |
 *               |  +----------------------+  | Frame 2
 *               |  | dynamic descriptor 3 |  |
 *               |  +----------------------+  |
 *               |  |          ...         |  |
 *               |  +----------------------+ -+
 *               |  | dynamic descriptor 1 |  |
 *               |  +----------------------+  |
 *               |  | dynamic descriptor 2 |  |
 *               |  +----------------------+  | Frame 3
 *               |  | dynamic descriptor 3 |  |
 *               |  +----------------------+  |
 *               |  |         ...          |  |
 *                '-+----------------------+ -'
 *
 * */
template <std::uint32_t N>
class D3D12GPUDescriptorHandleAllocator
{
  public:
    /**
     * Construct a new D3D12GPUDescriptorHandleAllocator.
     *
     * @param type
     *   D3D12 heap type to create.
     *
     * @param num_descriptors
     *   Number of descriptors to create in heap (will be shared among each frame).
     *
     */
    D3D12GPUDescriptorHandleAllocator(
        D3D12_DESCRIPTOR_HEAP_TYPE type,
        std::uint32_t num_descriptors,
        std::uint32_t static_size)
        : descriptor_heap_(nullptr)
        , cpu_start_()
        , gpu_start_()
        , descriptor_size_(0u)
        , static_index_(0u)
        , dynamic_indices_()
        , static_capacity_(static_size)
        , dynamic_capacity_((num_descriptors - static_size) / N)
    {
        auto *device = D3D12Context::device();

        // setup heap description
        D3D12_DESCRIPTOR_HEAP_DESC heap_description;
        heap_description.NumDescriptors = num_descriptors;
        heap_description.Type = type;
        heap_description.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
        heap_description.NodeMask = 0;

        // create heap
        expect(
            device->CreateDescriptorHeap(&heap_description, IID_PPV_ARGS(&descriptor_heap_)) == S_OK,
            "could not create descriptor heap");

        cpu_start_ = descriptor_heap_->GetCPUDescriptorHandleForHeapStart();
        gpu_start_ = descriptor_heap_->GetGPUDescriptorHandleForHeapStart();

        descriptor_size_ = device->GetDescriptorHandleIncrementSize(type);

        // set the indices for each frames pool
        for (auto i = 0u; i < N; ++i)
        {
            dynamic_indices_[i] = static_size + (i * dynamic_capacity_);
        }
    }

    /**
     * Allocate a static descriptor from the pool.
     *
     * @returns
     *   A new static descriptor.
     */
    D3D12DescriptorHandle allocate_static(std::uint32_t count)
    {
        expect(static_index_ + count < static_capacity_, "heap too small");

        auto cpu_handle = cpu_start_;
        cpu_handle.ptr += descriptor_size_ * static_index_;

        auto gpu_handle = gpu_start_;
        gpu_handle.ptr += descriptor_size_ * static_index_;

        static_index_ += count;

        return {cpu_handle, gpu_handle};
    }

    /**
     * Allocate a contiguous  range of descriptor handles.
     *
     * @param frame
     *   Frame number to allocate for.
     *
     * @param count
     *   Number of handles to allocate.
     *
     * @returns
     *   Handle to to first allocated handle in range.
     */
    D3D12DescriptorHandle allocate_dynamic(std::uint32_t frame, std::uint32_t count)
    {
        expect(frame < N, "invalid frame number");
        expect(
            dynamic_indices_[frame] + count < static_capacity_ + ((frame + 1u) * dynamic_capacity_), "heap too small");

        auto cpu_handle = cpu_start_;
        cpu_handle.ptr += descriptor_size_ * (static_capacity_ + dynamic_indices_[frame]);

        auto gpu_handle = gpu_start_;
        gpu_handle.ptr += descriptor_size_ * (static_capacity_ + dynamic_indices_[frame]);

        dynamic_indices_[frame] += count;

        return {cpu_handle, gpu_handle};
    }
    /**
     * Get cpu handle of first descriptor in heap.
     *
     * @returns
     *   First cpu descriptor in heap.
     */
    D3D12_CPU_DESCRIPTOR_HANDLE cpu_start() const
    {
        return cpu_start_;
    }

    /**
     * Get gpu handle of first descriptor in heap.
     *
     * @returns
     *   First gpu descriptor in heap.
     */
    D3D12_GPU_DESCRIPTOR_HANDLE gpu_start() const
    {
        return gpu_start_;
    }

    /**
     * Get the size of a descriptor handle.
     *
     * @returns
     *   Descriptor handle size.
     */
    std::uint32_t descriptor_size() const
    {
        return descriptor_size_;
    }

    /**
     * Get native handle to heap.
     *
     * @returns
     *   Pointer to heap.
     */
    ID3D12DescriptorHeap *heap() const
    {
        return descriptor_heap_.Get();
    }

    /**
     * Reset the allocation for a frame. This means future calls to allocate could return handles that have been
     * previously allocated.
     *
     * @param frame
     *   Frame number to reset.
     *
     */
    void reset_dynamic(std::uint32_t frame)
    {
        expect(frame < N, "invalid frame number");

        dynamic_indices_[frame] = static_capacity_ + (frame * dynamic_capacity_);
    }

  private:
    /** D3D12 handle to descriptor heap. */
    ::Microsoft::WRL::ComPtr<::ID3D12DescriptorHeap> descriptor_heap_;

    /** First cpu handle. */
    D3D12_CPU_DESCRIPTOR_HANDLE cpu_start_;

    /** First gpu handle. */
    D3D12_GPU_DESCRIPTOR_HANDLE gpu_start_;

    /** Size of a single descriptor handle. */
    std::uint32_t descriptor_size_;

    /** The current index into the static pool. */
    std::uint32_t static_index_;

    /** Current index into each pool. */
    std::array<std::uint32_t, N> dynamic_indices_;

    /** Maximum number of static handles. */
    std::uint32_t static_capacity_;

    /** Maximum number of handles. */
    std::uint32_t dynamic_capacity_;
};
}

```

`include/iris/graphics/d3d12/d3d12_material.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <memory>
#include <string>
#include <vector>

#include <wrl.h>

#include "directx/d3d12.h"
#include "directx/d3dx12.h"

#include "graphics/lights/light_type.h"
#include "graphics/lights/lighting_rig.h"
#include "graphics/material.h"
#include "graphics/primitive_type.h"
#include "graphics/render_graph/render_graph.h"

namespace iris
{

/**
 * Implementation of Material for d3d12.
 */
class D3D12Material : public Material
{
  public:
    /**
     * Construct a new D3D12Material.
     *
     * @param render_graph
     *   RenderGraph describing material.
     *
     * @param input_descriptors
     *   D3D12 vertex descriptor describing how to organise vertex data.
     *
     * @param light_type
     *   Type of light for this material.
     *
     * @param root_signature
     *   The root signature to use for the shaders.
     *
     * @param render_to_swapchain
     *   True if material will be rendered to the swapchain, false otherwise (render target).
     *
     * @param render_to_normal_target
     *   Flag indicating whether the material should also write out screen space normals to a render texture.
     *
     * @param render_to_position_target
     *   Flag indicating whether the material should also write out screen space positions to a render texture.
     *
     * @param has_transparency
     *   Hint to the renderer that the material will contain transparency.
     *
     * @param wireframe
     *   Flag indicating if wireframe should be rendered.
     */
    D3D12Material(
        const RenderGraph *render_graph,
        const std::vector<D3D12_INPUT_ELEMENT_DESC> &input_descriptors,
        PrimitiveType primitive_type,
        LightType light_type,
        ID3D12RootSignature *root_signature,
        bool render_to_swapchain,
        bool render_to_normal_target,
        bool render_to_position_target,
        bool has_transparency,
        bool wireframe);

    ~D3D12Material() override = default;

    /**
     * Get the d3d12 pipeline state for this material.
     *
     * @returns
     *   Pipeline state.
     */
    ID3D12PipelineState *pso() const;

  private:
    /** Pipeline state object. */
    ::Microsoft::WRL::ComPtr<ID3D12PipelineState> pso_;
};

}

```

`include/iris/graphics/d3d12/d3d12_material_manager.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include "graphics/d3d12/d3d12_material.h"
#include "graphics/lights/light_type.h"
#include "graphics/material_cache.h"
#include "graphics/material_manager.h"

namespace iris
{

class Material;
class RenderGraph;
class RenderTarget;

/**
 * Implementation of MaterialManager for D3D12.
 */
class D3D12MaterialManager : public MaterialManager
{
  public:
    ~D3D12MaterialManager() override = default;

    /**
     * Create a new material.
     *
     * @param render_graph
     *   RenderGraph describing material.
     *
     * @param render_entity
     *   The entity material is for.
     *
     * @param light_type
     *   The type of light that material should use.
     *
     * @param render_to_colour_target
     *   Whether the material is rendering to a colour target or the back buffer.
     *
     * @param render_to_normal_target
     *   Whether to render screen space normals.
     *
     * @param render_to_position_target.
     *   Whether to render screen positions.
     *
     * @param has_transparency
     *   Hint to the renderer that the material will contain transparency.
     *
     * @returns
     *   Pointer to created Material.
     */
    Material *create(
        RenderGraph *render_graph,
        RenderEntity *render_entity,
        LightType light_type,
        bool render_to_colour_target,
        bool render_to_normal_target,
        bool render_to_position_target,
        bool has_transparency);

    /**
     * Clear all cached materials. This will invalidate any returned pointers.
     */
    void clear() override;

  private:
    /** Cache of created materials. */
    MaterialCache<D3D12Material, RenderGraph *, LightType, bool, bool> materials_;
};

}

```

`include/iris/graphics/d3d12/d3d12_mesh.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <vector>

#include "directx/d3d12.h"
#include "directx/d3dx12.h"

#include "graphics/d3d12/d3d12_buffer.h"
#include "graphics/mesh.h"
#include "graphics/vertex_data.h"

namespace iris
{

/**
 * Implementation of d3d12 for metal.
 */
class D3D12Mesh : public Mesh
{
  public:
    /**
     * Construct a new D3D12Mesh.
     *
     * @param vertices
     *   Vertices for the mesh.
     *
     * @param indices
     *   Indices for the mesh.
     *
     * @param attributes
     *   Attributes of the vertices.
     */
    D3D12Mesh(
        const std::vector<VertexData> &vertices,
        const std::vector<std::uint32_t> &indices,
        const VertexAttributes &attributes);

    ~D3D12Mesh() override = default;

    /**
     * Update the vertex data, this will also update any GPU data.
     *
     * @param data
     *   New vertex data.
     */
    void update_vertex_data(const std::vector<VertexData> &data) override;

    /**
     * Update the index data, this will also update any GPU data.
     *
     * @param data
     *   New index data.
     */
    void update_index_data(const std::vector<std::uint32_t> &data) override;

    /**
     * Get vertex buffer.
     *
     * @returns
     *   Const reference to vertex buffer object.
     */
    const D3D12Buffer &vertex_buffer() const;

    /**
     * Get index buffer.
     *
     * @returns
     *   Const reference to index buffer object.
     */
    const D3D12Buffer &index_buffer() const;

    /**
     * Get d3d12 object which describes vertex layout.
     *
     * @param
     *   D3D12 object describing vertex.
     */
    std::vector<D3D12_INPUT_ELEMENT_DESC> input_descriptors() const;

  private:
    /** Buffer for vertex data. */
    D3D12Buffer vertex_buffer_;

    /** Buffer for index data. */
    D3D12Buffer index_buffer_;

    /** D3D12 object describing vertex layout. */
    std::vector<D3D12_INPUT_ELEMENT_DESC> input_descriptors_;
};

}

```

`include/iris/graphics/d3d12/d3d12_mesh_manager.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <memory>

#include "core/resource_manager.h"
#include "graphics/mesh.h"
#include "graphics/mesh_manager.h"
#include "graphics/vertex_data.h"

namespace iris
{

/**
 * Implementation of MeshManager for d3d12.
 */
class D3D12MeshManager : public MeshManager
{
  public:
    /**
     * Construct a new D3D12MeshManager.
     *
     * @param resource_manager
     *   Resource manager object.
     */
    D3D12MeshManager(ResourceManager &resource_manager);

  protected:
    /**
     * Create a Mesh object from the provided vertex and index data.
     *
     * @param vertices
     *   Collection of vertices for the Mesh.
     *
     * @param indices
     *   Collection of indices for the Mesh.
     *
     * @returns
     *   Loaded Mesh.
     */
    std::unique_ptr<Mesh> create_mesh(
        const std::vector<iris::VertexData> &vertices,
        const std::vector<std::uint32_t> &indices) const override;
};

}

```

`include/iris/graphics/d3d12/d3d12_render_target.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include "graphics/d3d12/d3d12_descriptor_handle.h"
#include "graphics/render_target.h"


namespace iris
{

/**
 * Implementation of RenderTarget for d3d12.
 */
class D3D12RenderTarget : public RenderTarget
{
  public:
    /**
     * Construct a new D3D12RenderTarget.
     *
     * @param colour_texture
     *   Texture to render colour data to.
     *
     * @param depth_texture
     *   Texture to render depth data to.
     */
    D3D12RenderTarget(const Texture *colour_texture, const Texture *depth_texture);

    ~D3D12RenderTarget() override = default;

    /**
     * Get descriptor handle to render target.
     *
     * @returns
     *   D3D12 descriptor handle.
     */
    D3D12DescriptorHandle handle() const;

  private:
    /** D3D12 descriptor handle. */
    D3D12DescriptorHandle handle_;
};

}

```

`include/iris/graphics/d3d12/d3d12_render_target_manager.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <memory>
#include <vector>

#include "graphics/d3d12/d3d12_render_target.h"
#include "graphics/render_target_manager.h"
#include "graphics/texture_manager.h"
#include "graphics/window_manager.h"

namespace iris
{

/**
 * Implementation of RenderTargetManager for D3D12.
 */
class D3D12RenderTargetManager : public RenderTargetManager
{
  public:
    /**
     * Create a new D3D12RenderTargetManager object.
     *
     * @param window_manager
     *   Window manager object.
     *
     * @param texture_manager
     *   Texture manager object.
     */
    D3D12RenderTargetManager(WindowManager &window_manager, TextureManager &texture_manager);

    /**
     * Create a render target the size of the current window.
     *
     * @returns
     *   Pointer to the created render target.
     */
    RenderTarget *create() override;

    /**
     * Create a render target with the specified dimensions.
     *
     * @param width
     *   Width of render target.
     *
     * @param height
     *   Height of render target.
     *
     * @returns
     *   Pointer to the created render target.
     */
    RenderTarget *create(std::uint32_t width, std::uint32_t height) override;

    /**
     * Create a new render target which combines the colour target and depth target of two separate render targets.
     *
     * @param colour_target
     *   Render target to for colour target.
     *
     * @param depth_target
     *   Render target to for depth target.
     *
     * @returns
     *   Pointer to the created render target.
     */
    RenderTarget *create(const RenderTarget *colour_target, const RenderTarget *depth_target) override;

  private:
    /** Window manager object.  */
    WindowManager &window_manager_;

    /** Texture manager object.  */
    TextureManager &texture_manager_;

    /** Collection of created render targets. */
    std::vector<std::unique_ptr<D3D12RenderTarget>> render_targets_;
};

}

```

`include/iris/graphics/d3d12/d3d12_renderer.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <chrono>
#include <cstdint>
#include <deque>
#include <limits>
#include <memory>
#include <set>
#include <tuple>
#include <unordered_map>
#include <vector>

#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <Windowsx.h>
#include <dxgi1_6.h>
#include <wrl.h>

#include "directx/d3d12.h"
#include "directx/d3dx12.h"

#include "core/auto_release.h"
#include "graphics/d3d12/d3d12_constant_buffer.h"
#include "graphics/d3d12/d3d12_constant_buffer_pool.h"
#include "graphics/d3d12/d3d12_cube_map.h"
#include "graphics/d3d12/d3d12_descriptor_handle.h"
#include "graphics/d3d12/d3d12_root_signature.h"
#include "graphics/d3d12/d3d12_structured_buffer.h"
#include "graphics/d3d12/d3d12_texture.h"
#include "graphics/material_cache.h"
#include "graphics/material_manager.h"
#include "graphics/render_pipeline.h"
#include "graphics/render_target.h"
#include "graphics/renderer.h"
#include "graphics/texture_manager.h"
#include "graphics/window_manager.h"

namespace iris
{

/**
 * Implementation of Renderer for d3d12.
 *
 * This Renderer uses triple buffering to allow for greatest rendering
 * throughput. A frame if defined as all rendering passes that occur when
 * render() is called. This class uses a circular buffer of three frames. When
 * all the CPU processing of a frame is complete it is submitted to the GPU. At
 * this point the CPU is free to proceed to the next frame whilst the GPU works
 * asynchronously.
 */
class D3D12Renderer : public Renderer
{
  public:
    /**
     * Construct a new D3D12Renderer.
     *
     * @param window_manager
     *   Window manager object.
     *
     * @param texture_manager
     *   Texture manager object.
     *
     * @param material_manager
     *   Material manager object.
     *
     * @param window
     *   The window to present to.
     *
     * @param width
     *   Width of window being rendered to.
     *
     * @param height
     *   Height of window being rendered to.
     *
     * @param initial_screen_scale
     *   The natural scale of the screen with window is currently on.
     */
    D3D12Renderer(
        WindowManager &window_manager,
        TextureManager &texture_manager,
        MaterialManager &material_manager,
        HWND window,
        std::uint32_t width,
        std::uint32_t height,
        std::uint32_t initial_screen_scale);

    /**
     * Destructor, will block until all inflight frames have finished rendering.
     */
    ~D3D12Renderer() override;

  protected:
    /**
     * Render specific method to set the render pipeline.
     *
     * @param build_queue
     *   Function to build queue.
     */
    void do_set_render_pipeline(std::function<void()> build_queue) override;

    // handlers for the supported RenderCommandTypes

    void pre_render() override;
    void execute_pass_start(RenderCommand &command) override;
    void execute_draw(RenderCommand &command) override;
    void execute_pass_end(RenderCommand &command) override;
    void execute_present(RenderCommand &command) override;

  private:
    /**
     * Internal struct encapsulating data needed for a frame.
     */
    struct Frame
    {
        Frame(
            std::uint32_t frame,
            Microsoft::WRL::ComPtr<ID3D12Resource> buffer,
            D3D12DescriptorHandle render_target,
            std::unique_ptr<D3D12Texture> depth_buffer,
            Microsoft::WRL::ComPtr<ID3D12CommandAllocator> command_allocator)
            : frame_id(frame)
            , buffer(buffer)
            , render_target(render_target)
            , depth_buffer(std::move(depth_buffer))
            , command_allocator(command_allocator)
            , fence_value(0u)
            , bone_data_buffers()
            , model_data_buffers()
            , light_data_buffers()
            , camera_data_buffers()
            , property_buffers()
        {
        }

        /** Unique id for frame.*/
        std::uint32_t frame_id;

        /** D3D12 back buffer to render to and present. */
        Microsoft::WRL::ComPtr<ID3D12Resource> buffer;

        /** render target view for buffer. */
        D3D12DescriptorHandle render_target;

        /** Depth buffer for frame. */
        std::unique_ptr<D3D12Texture> depth_buffer;

        /** Command allocate for frame. */
        Microsoft::WRL::ComPtr<ID3D12CommandAllocator> command_allocator;

        /** Current fence value for frame. */
        std::uint64_t fence_value;

        /** Cache of bone data buffers for render entities in this frame. */
        std::unordered_map<const RenderEntity *, std::unique_ptr<D3D12ConstantBuffer>> bone_data_buffers;

        /** Cache of model data buffers for render entities in this frame. */
        std::unordered_map<const RenderEntity *, std::unique_ptr<D3D12StructuredBuffer>> model_data_buffers;

        /** Cache of data buffers for lights in this frame. */
        std::unordered_map<const Light *, std::unique_ptr<D3D12ConstantBuffer>> light_data_buffers;

        /** Cache of data buffers for cameras in this frame. */
        std::unordered_map<const Camera *, std::unique_ptr<D3D12ConstantBuffer>> camera_data_buffers;

        /** Cache of data buffers for material properties. */
        std::unordered_map<const Material *, std::unique_ptr<D3D12ConstantBuffer>> property_buffers;
    };

    /** Window manager object. */
    WindowManager &window_manager_;

    /** Texture manager object. */
    TextureManager &texture_manager_;

    /** Width of window to present to. */
    std::uint32_t width_;

    /** Height of window to present to. */
    std::uint32_t height_;

    /** Collection of frames for triple buffering. */
    std::vector<Frame> frames_;

    /** Index of current frame to render to. */
    std::uint32_t frame_index_;

    Microsoft::WRL::ComPtr<ID3D12Fence> fence_;

    AutoRelease<HANDLE, nullptr> fence_event_;

    /** Single command queue for all frames. */
    Microsoft::WRL::ComPtr<ID3D12CommandQueue> command_queue_;

    /** Single command list for all frames. */
    Microsoft::WRL::ComPtr<ID3D12GraphicsCommandList> command_list_;

    /** Swap chain for triple buffering. */
    Microsoft::WRL::ComPtr<IDXGISwapChain4> swap_chain_;

    /** Viewport for window. */
    CD3DX12_VIEWPORT viewport_;

    /** Scissor rect for window. */
    CD3DX12_RECT scissor_rect_;

    /** Collection of textures that have been uploaded. */
    std::set<const D3D12Texture *> uploaded_textures_;

    /** Collection of CubeMaps that have been uploaded. */
    std::set<const D3D12CubeMap *> uploaded_cube_maps_;

    /** Cache of instance model data buffers for instanced entities in the current scene. */
    std::unordered_map<const RenderEntity *, std::unique_ptr<D3D12StructuredBuffer>> instance_data_buffers_;

    /** Descriptor handle to a global texture table (for bindless). */
    D3D12DescriptorHandle texture_table_;

    /** Descriptor handle to a global cube map table (for bindless). */
    D3D12DescriptorHandle cube_map_table_;

    /** Descriptor handle to a global sampler table (for bindless). */
    D3D12DescriptorHandle sampler_table_;
};
}

```

`include/iris/graphics/d3d12/d3d12_root_signature.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <array>
#include <tuple>

#include "directx/d3d12.h"
#include "directx/d3dx12.h"

#include "core/error_handling.h"
#include "graphics/d3d12/d3d12_constant_buffer.h"
#include "graphics/d3d12/d3d12_descriptor_handle.h"
#include "graphics/d3d12/d3d12_structured_buffer.h"
#include "log/log.h"

namespace iris
{

// defined below are the various parameter types that can be passed to D3D12RootSignature (as template arguments)
// each one must have:
//  - size : how many DWORDS it takes up in the root signature
//  - init_parameter : method for initialising a d3d12 root parameter object.
//  - encode_set : method for encoding a value into a command list

template <std::uint32_t ShaderRegister, std::uint32_t RegisterSpace, D3D12_SHADER_VISIBILITY ShaderVisibility>
struct ConstantParameter
{
    static constexpr auto size = 1u;

    static void init_parameter(CD3DX12_ROOT_PARAMETER1 &parameter)
    {
        parameter.InitAsConstants(1u, ShaderRegister, RegisterSpace, ShaderVisibility);
    }

    static void encode_set(ID3D12GraphicsCommandList *command_list, std::uint32_t index, std::uint32_t value)
    {
        command_list->SetGraphicsRoot32BitConstant(index, value, 0u);
    }
};

template <std::uint32_t ShaderRegister, std::uint32_t RegisterSpace, D3D12_SHADER_VISIBILITY ShaderVisibility>
struct ConstantBufferViewParameter
{
    static constexpr auto size = 2u;

    static void init_parameter(CD3DX12_ROOT_PARAMETER1 &parameter)
    {
        parameter.InitAsConstantBufferView(ShaderRegister, RegisterSpace);
    }

    static void encode_set(
        ID3D12GraphicsCommandList *command_list,
        std::uint32_t index,
        const D3D12ConstantBuffer *buffer)
    {
        command_list->SetGraphicsRootConstantBufferView(index, buffer->resource()->GetGPUVirtualAddress());
    }
};

template <std::uint32_t ShaderRegister, std::uint32_t RegisterSpace, D3D12_SHADER_VISIBILITY ShaderVisibility>
struct ShaderResourceViewParameter
{
    static constexpr auto size = 2u;

    static void init_parameter(CD3DX12_ROOT_PARAMETER1 &parameter)
    {
        parameter.InitAsShaderResourceView(ShaderRegister, RegisterSpace);
    }

    static void encode_set(
        ID3D12GraphicsCommandList *command_list,
        std::uint32_t index,
        const D3D12ConstantBuffer *buffer)
    {
        command_list->SetGraphicsRootConstantBufferView(index, buffer->resource()->GetGPUVirtualAddress());
    }

    static void encode_set(
        ID3D12GraphicsCommandList *command_list,
        std::uint32_t index,
        const D3D12StructuredBuffer *buffer)
    {
        command_list->SetGraphicsRootShaderResourceView(index, buffer->resource()->GetGPUVirtualAddress());
    }
};

template <
    D3D12_DESCRIPTOR_RANGE_TYPE RangeType,
    std::uint32_t NumDescriptors,
    std::uint32_t ShaderRegister,
    std::uint32_t RegisterSpace,
    D3D12_SHADER_VISIBILITY ShaderVisibility>
struct TableParameter
{
    static constexpr auto size = 1u;

    static void init_parameter(CD3DX12_ROOT_PARAMETER1 &parameter)
    {
        static CD3DX12_DESCRIPTOR_RANGE1 range{};
        range.Init(RangeType, NumDescriptors, ShaderRegister, RegisterSpace);

        parameter.InitAsDescriptorTable(1u, &range, ShaderVisibility);
    }

    static void encode_set(
        ID3D12GraphicsCommandList *command_list,
        std::uint32_t index,
        const D3D12DescriptorHandle &handle)
    {
        command_list->SetGraphicsRootDescriptorTable(index, handle.gpu_handle());
    }
};

/**
 * A class encapsulating a d3d12 root signature - allows for root parameters to be described (at compile time) and
 * provides a runtime method for encoding arguments.
 */
template <class... Parameters>
class D3D12RootSignature
{
  public:
    /**
     * Construct a new D3D12RootSignature.
     */
    D3D12RootSignature(ID3D12Device2 *device)
        : root_signature_(nullptr)
    {
        static_assert((Parameters::size + ...) <= 64, "exceeded maximum root signature size");

        // create a root parameter object for all the provided template parameters.
        std::array<CD3DX12_ROOT_PARAMETER1, sizeof...(Parameters)> root_parameters;
        auto i = 0u;

        // call the init_parameter method for all the parameters
        (Parameters::init_parameter(root_parameters[i++]), ...);

        D3D12_ROOT_SIGNATURE_FLAGS root_signature_flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT |
                                                          D3D12_ROOT_SIGNATURE_FLAG_DENY_HULL_SHADER_ROOT_ACCESS |
                                                          D3D12_ROOT_SIGNATURE_FLAG_DENY_DOMAIN_SHADER_ROOT_ACCESS |
                                                          D3D12_ROOT_SIGNATURE_FLAG_DENY_GEOMETRY_SHADER_ROOT_ACCESS;

        CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC root_signature_description{};
        root_signature_description.Init_1_1(
            static_cast<UINT>(root_parameters.size()), root_parameters.data(), 0u, nullptr, root_signature_flags);

        Microsoft::WRL::ComPtr<ID3DBlob> signature = nullptr;
        Microsoft::WRL::ComPtr<ID3DBlob> error = nullptr;
        if (::D3DX12SerializeVersionedRootSignature(
                &root_signature_description, D3D_ROOT_SIGNATURE_VERSION_1, &signature, &error) != S_OK)
        {
            const std::string error_message(static_cast<char *>(error->GetBufferPointer()), error->GetBufferSize());

            LOG_ENGINE_ERROR("d3d12_root_signature", "{}", error_message);

            throw iris::Exception("root signature serialization failed: " + error_message);
        }

        expect(
            device->CreateRootSignature(
                0, signature->GetBufferPointer(), signature->GetBufferSize(), IID_PPV_ARGS(&root_signature_)) == S_OK,
            "could not create root signature");
    }

    /**
     * Encode a pack of commands. Each one should correspond to Parameter.
     *
     * @param args
     *   Pack of arguments, one for each Parameter.
     */
    template <class... Args>
    void encode_arguments(ID3D12GraphicsCommandList *command_list, Args &&...args)
    {
        auto i = 0u;

        // call encode_set of each parameter where each one gets its associated argument
        (Parameters::encode_set(command_list, i++, args), ...);
    }

    /**
     * Get a handle to the D3D12 root signature.
     *
     * @returns
     *   D3D12 root signature object.
     */
    ID3D12RootSignature *handle() const
    {
        return root_signature_.Get();
    }

  private:
    /** D3D12 root signature object. */
    Microsoft::WRL::ComPtr<ID3D12RootSignature> root_signature_;
};

}

```

`include/iris/graphics/d3d12/d3d12_sampler.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>

#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <wrl.h>

#include "directx/d3d12.h"
#include "directx/d3dx12.h"

#include "graphics/d3d12/d3d12_descriptor_handle.h"
#include "graphics/sampler.h"

namespace iris
{

/**
 * Implementation of Sampler for D3D12.
 */
class D3D12Sampler : public Sampler
{
  public:
    /**
     * Create a new D3D12Sampler.
     *
     * @param descriptor
     *   Description of sampler parameters.
     *
     * @param index
     *   Index into the global array of all allocated samplers.
     */
    D3D12Sampler(const SamplerDescriptor &descriptor, std::uint32_t index);
    ~D3D12Sampler();

    /**
     * Get the descriptor handle for the sampler object.
     *
     * @returns
     *   Descriptor handle.
     */
    D3D12DescriptorHandle handle() const;

  private:
    /** Descriptor handle for sampler object. */
    D3D12DescriptorHandle descriptor_;
};

}

```

`include/iris/graphics/d3d12/d3d12_structured_buffer.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <cstdint>

#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <wrl.h>

#include "directx/d3d12.h"
#include "directx/d3dx12.h"

#include "core/exception.h"
#include "graphics/d3d12/d3d12_descriptor_handle.h"

namespace iris
{

/**
 * Class encapsulating a D3D12 structured buffer. Represents an array of fixed sized objects accessible by a shader.
 */
class D3D12StructuredBuffer
{
  public:
    /**
     * Construct a new D3D12StructuredBuffer.
     *
     * @param object_count
     *   Number of objects to allocate.
     *
     * @param object_size
     *   Size of object (in bytes).
     */
    D3D12StructuredBuffer(std::size_t object_count, std::size_t object_size);

    /**
     * Construct a new D3D12StructuredBuffer for a given frame, the internal descriptor handle will be recycled at the
     * end of the supplied frame.
     *
     * @param object_count
     *   Number of objects to allocate.
     *
     * @param object_size
     *   Size of object (in bytes).
     *
     * @param frame
     *   Frame to allocate descriptor handle for.
     */
    D3D12StructuredBuffer(std::size_t object_count, std::size_t object_size, std::uint32_t frame);

    ~D3D12StructuredBuffer();

    D3D12StructuredBuffer(const D3D12StructuredBuffer &) = delete;
    D3D12StructuredBuffer &operator=(const D3D12StructuredBuffer &) = default;
    D3D12StructuredBuffer(D3D12StructuredBuffer &&) = default;
    D3D12StructuredBuffer &operator=(D3D12StructuredBuffer &&) = default;

    /**
     * Get descriptor handle to buffer.
     *
     * @returns
     *   Buffer handle.
     */
    D3D12DescriptorHandle descriptor_handle() const;

    /**
     * Write an object into the buffer at an offset.
     *
     * @param object
     *   Object to write.
     *
     * @param offset
     *   Offset into buffer to write object.
     */
    template <class T>
    void write(const T &object, std::size_t offset)
    {
        write(std::addressof(object), sizeof(T), offset);
    }

    /**
     * Write an object into the buffer at an offset.
     *
     * @param object
     *   Object to write.
     *
     * @param size
     *   Size (in bytes) of object to write.
     *
     * @param offset
     *   Offset into buffer to write object.
     */
    template <class T>
    void write(const T *object, std::size_t size, std::size_t offset)
    {
        if (offset + size > capacity_)
        {
            throw Exception("write would overflow");
        }

        std::memcpy(mapped_buffer_ + offset, object, size);
    }

    /**
     * Get D3D12 resource.
     *
     * @returns
     *   Internal resource for buffer.
     */
    ID3D12Resource *resource() const
    {
        return resource_.Get();
    }

  private:
    /** Capacity (in bytes) of buffer. */
    std::size_t capacity_;

    /** Pointer to mapped buffer where data can be written. */
    std::byte *mapped_buffer_;

    /** D3D12 handle to resource view. */
    Microsoft::WRL::ComPtr<ID3D12Resource> resource_;

    /** D3D12 handle to buffer. */
    D3D12DescriptorHandle descriptor_handle_;

    /** Flag indicating if the descriptor handle is static (or dynamic per frame). */
    bool static_descriptor_;
};

}

```

`include/iris/graphics/d3d12/d3d12_texture.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>

#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <wrl.h>

#include "directx/d3d12.h"
#include "directx/d3dx12.h"

#include "core/data_buffer.h"
#include "graphics/d3d12/d3d12_descriptor_handle.h"
#include "graphics/sampler.h"
#include "graphics/texture.h"
#include "graphics/texture_usage.h"

namespace iris
{

/**
 * Implementation of Texture for d3d12.
 *
 * Internally texture data is first copied to an upload heap. The renderer can then encode a command to copy that data
 * to a shader visible heap.
 */
class D3D12Texture : public Texture
{
  public:
    /**
     * Construct a new D3D12Texture.
     *
     * @param data
     *   Raw data of image, in pixel_format.
     *
     * @param width
     *   Width of image.
     *
     * @param height
     *   Height of image.
     *
     * @param sampler
     *   Sampler to use for this texture.
     *
     * @param usage
     *   Texture usage.
     *
     * @param index
     */
    D3D12Texture(
        const DataBuffer &data,
        std::uint32_t width,
        std::uint32_t height,
        const Sampler *sampler,
        TextureUsage usage,
        std::uint32_t index);

    ~D3D12Texture() override = default;

    /*
     * Get the handle to the d3d12 resource where the image data will be copied
     * to.
     *
     * @returns
     *   D3D12 resource.
     */
    ID3D12Resource *resource() const;

    /**
     * Get the handle to the d3d12 resource where the image data is initially
     * uploaded to
     *
     * @returns
     *   D3D12 resource.
     */
    ID3D12Resource *upload() const;

    /**
     * Get the d3d12 footprints describing the image data layout.
     *
     * @returns
     *   D3D12 footprints.
     */
    std::vector<D3D12_PLACED_SUBRESOURCE_FOOTPRINT> footprints() const;

    /**
     * Get the handle to the image resource view. Only valid if the object was
     * constructed for non-depth buffer usage.
     *
     * @returns
     *   Resource view handle.
     */
    D3D12DescriptorHandle handle() const;

    /**
     * Get the handle to the image resource view. Only valid if the object was
     * constructed for depth buffer usage.
     *
     * @returns
     *   Resource view handle (depth buffer only).
     */
    D3D12DescriptorHandle depth_handle() const;

    /**
     * Get the type of heap image data will be copied to.
     *
     * @returns
     *   Heap type.
     */
    D3D12_DESCRIPTOR_HEAP_TYPE type() const;

  private:
    /** Handle to resource where image data will be coped to. */
    Microsoft::WRL::ComPtr<ID3D12Resource> resource_;

    /** Handle to resource where image data is uploaded to. */
    Microsoft::WRL::ComPtr<ID3D12Resource> upload_;

    /** Resource view to image data. */
    D3D12DescriptorHandle resource_view_;

    /** Resource view to image data (depth only). */
    D3D12DescriptorHandle depth_resource_view_;

    /** Footprints describing image data layout. */
    std::vector<D3D12_PLACED_SUBRESOURCE_FOOTPRINT> footprints_;

    /** Type of heap to copy data to. */
    D3D12_DESCRIPTOR_HEAP_TYPE type_;
};

}

```

`include/iris/graphics/d3d12/d3d12_texture_manager.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <memory>

#include "core/data_buffer.h"
#include "core/resource_manager.h"
#include "graphics/cube_map.h"
#include "graphics/sampler.h"
#include "graphics/texture.h"
#include "graphics/texture_manager.h"
#include "graphics/texture_usage.h"

namespace iris
{

/**
 * Implementation of TextureManager for d3d12.
 */
class D3D12TextureManager : public TextureManager
{
  public:
    /**
     * Construct a new D3D12TextureManager object.
     *
     * @param resource_manager
     *   Resource manager object.
     */
    D3D12TextureManager(ResourceManager &resource_manager);

  protected:
    /**
     * Create a Texture object with the provided data.
     *
     * @param data
     *   Raw data of image, in pixel_format.
     *
     * @param width
     *   Width of image.
     *
     * @param height
     *   Height of image.
     *
     * @param sampler
     *   Sampler to use for this texture.
     *
     * @param usage
     *   Usage of the texture.
     *
     * @param index
     *   Index into the global array of all allocated textures.
     *
     * @returns
     *   Created texture.
     */
    std::unique_ptr<Texture> do_create(
        const DataBuffer &data,
        std::uint32_t width,
        std::uint32_t height,
        const Sampler *sampler,
        TextureUsage usage,
        std::uint32_t index) override;

    /**
     * Create a CubeMap from six DataBuffers (one for each face).
     *
     * @param right_data
     *   Image data for right face of cube.
     *
     * @param right_data
     *   Image data for right face of cube.
     *
     * @param left_data
     *   Image data for left face of cube.
     *
     * @param top_data
     *   Image data for top face of cube.
     *
     * @param bottom_data
     *   Image data for bottom face of cube.
     *
     * @param back_data
     *   Image data for back face of cube.
     *
     * @param front_data
     *   Image data for front face of cube.
     *
     * @param width
     *   Width of each image face.
     *
     * @param height
     *   Height of each image face.
     *
     * @param sampler
     *   Sampler to use for this texture.
     *
     * @param index
     *   Index into the global array of all allocated textures.
     *
     * @returns
     *   Created CubeMap.
     */
    std::unique_ptr<CubeMap> do_create(
        const DataBuffer &right_data,
        const DataBuffer &left_data,
        const DataBuffer &top_data,
        const DataBuffer &bottom_data,
        const DataBuffer &near_data,
        const DataBuffer &far_data,
        std::uint32_t width,
        std::uint32_t height,
        const Sampler *sampler,
        std::uint32_t index) override;

    std::unique_ptr<Sampler> do_create(const SamplerDescriptor &descriptor, std::uint32_t index) override;
};

}

```

`include/iris/graphics/default_shader_languages.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

namespace iris
{

/**
 * Enumeration of shader languages supports out-of-the-box.
 */
enum class ShaderLanguage
{
    HLSL,
    GLSL,
    MSL
};

}
```

`include/iris/graphics/instanced_entity.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <vector>

#include "core/matrix4.h"
#include "core/transform.h"
#include "graphics/mesh.h"
#include "graphics/render_entity.h"
#include "graphics/render_entity_type.h"

namespace iris
{

/**
 * Implementation of RenderEntity for an instanced mesh i.e. rendering multiple copies of a single mesh with a single
 * draw call.
 *
 * Note that instances are static and cannot be modified after creation.
 */
class InstancedEntity : public RenderEntity
{
  public:
    /**
     * Construct a new InstancedEntity object.
     *
     * @param mesh
     *   Mesh to render.
     *
     * @param instances
     *   Collection of transforms describing each instance, must be greater that one.
     */
    InstancedEntity(const Mesh *mesh, const std::vector<Transform> &instances);
    ~InstancedEntity() override = default;

    /**
     * Get entity type.
     *
     * @returns
     *   Entity type.
     */
    RenderEntityType type() const override;

    /**
     * Get if entity will be rendered with transparency.
     *
     * @returns
     *   True if entity will have transparency, otherwise false.
     */
    bool has_transparency() const override;

    /**
     * Get number of instances of mesh to render.
     *
     * @returns
     *   Number of instances.
     */
    std::size_t instance_count() const;

    /**
     * Get collection of Matrix4 objects for all instances. For each instance the transform and normal transform is
     * returned.
     *
     * @return
     *   [transform , normal transform] for each instance.
     */
    const std::vector<Matrix4> &data() const;

  private:
    /** Number of instances to render. */
    std::size_t instance_count_;

    /** Render data for instances. */
    std::vector<Matrix4> data_;
};

}
```

`include/iris/graphics/ios/app_delegate.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#import <UIKit/UIKit.h>

@interface AppDelegate : UIResponder <UIApplicationDelegate>

/** Main window. */
@property(strong, nonatomic) UIWindow *window;

/**
 * Calls entry into game.
 */
- (void)callEntry;

@end

```

`include/iris/graphics/ios/ios_window.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>

#include "graphics/window.h"

namespace iris
{

/**
 * Implementation of Window for iOS.
 */
class IOSWindow : public Window
{
  public:
    /**
     * Construct a new IOSWindow.
     *
     * @param width
     *   Width of window.
     *
     * @param height
     *   Height of window.
     */
    IOSWindow(std::uint32_t width, std::uint32_t height);
    ~IOSWindow() override = default;

    /**
     * Get the natural scale for the screen. This value reflects the scale
     * factor needed to convert from the default logical coordinate space into
     * the device coordinate space of this screen.
     *
     * @returns
     *   Screen scale factor.
     */
    std::uint32_t screen_scale() const override;

    /**
     * Pump the next user input event. Result will be empty if there are no
     * new events.
     *
     * @returns
     *   Optional event.
     */
    std::optional<Event> pump_event() override;
};

}

```

`include/iris/graphics/ios/ios_window_manager.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <memory>

#include "graphics/window.h"
#include "graphics/window_manager.h"

namespace iris
{

/**
 * Implementation of WindowManager for ios.
 */
class IOSWindowManager : public WindowManager
{
  public:
    ~IOSWindowManager() override = default;

    /**
     * Create a new Window.
     *
     * @param width
     *   Width of window.
     *
     * @param height
     *   Height of window.
     */
    Window *create_window(std::uint32_t width, std::uint32_t height) override;

    /**
     * Get the currently active window.
     *
     * @returns
     *   Pointer to current window, nullptr if one does not exist.
     */
    Window *current_window() const override;

  private:
    /** Current window .*/
    std::unique_ptr<Window> current_window_;
};

}

```

`include/iris/graphics/ios/metal_view.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#import <MetalKit/MetalKit.h>

@interface MetalView : UIView

@property(nonatomic, strong) id<MTLDevice> device;
@property(nonatomic, weak) CAMetalLayer *metalLayer;

@end

```

`include/iris/graphics/ios/metal_view_controller.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#import <MetalKit/MetalKit.h>

#include <UIKit/UIKit.h>

#include <queue>

#include "events/event.h"

@interface MetalViewController : UIViewController
{

  @public
    std::queue<iris::Event> events_;
}

@end

```

`include/iris/graphics/keyframe.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <chrono>

#include "core/transform.h"

namespace iris
{

/**
 * A KeyFrame represents a transformation at a given time in an animation.
 */
struct KeyFrame
{
    /**
     * Construct a new KeyFrame.
     *
     * @param transform
     *   Transform at time.
     *
     * @param time
     *   Time of keyframe (since start of animation).
     */
    KeyFrame(const Transform &transform, std::chrono::milliseconds time)
        : transform(transform)
        , time(time)
    {
    }

    /** Transform of frame. */
    Transform transform;

    /** Time of frame. */
    std::chrono::milliseconds time;
};

}

```

`include/iris/graphics/lights/ambient_light.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <array>

#include "core/colour.h"
#include "graphics/lights/light.h"
#include "graphics/lights/light_type.h"

namespace iris
{

/**
 * Implementation of Light for a constant and uniform light without direction or
 * position.
 */
class AmbientLight : public Light
{
  public:
    /**
     * Construct a new AmbientLight.
     *
     * @param colour
     *   The colour of the light.
     */
    AmbientLight(const Colour &colour);

    ~AmbientLight() override = default;

    /**
     * Get the type of light.
     *
     * @returns
     *   Light type.
     */
    LightType type() const override;

    /**
     * Get the raw data for the light colour.
     *
     * @returns
     *   Raw data (as floats) for the colour.
     */
    std::array<float, 4u> colour_data() const override;

    /**
     * Unused by this light type.
     *
     * @returns
     *   Array of 0.0f values.
     */
    std::array<float, 4u> world_space_data() const override;

    /**
     * Unused by this light type.
     *
     * @returns
     *   Array of 0.0f values.
     */
    std::array<float, 3u> attenuation_data() const override;

    /**
     * Get the colour of the light.
     *
     * @param
     *   Light colour.
     */
    Colour colour() const;

    /**
     * Set the colour of the light.
     *
     * @param
     *   New light colour.
     */
    void set_colour(const Colour &colour);

  private:
    /** Colour of ambient light. */
    Colour colour_;
};

}

```

`include/iris/graphics/lights/directional_light.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <array>

#include "core/camera.h"
#include "core/colour.h"
#include "core/vector3.h"
#include "graphics/lights/light.h"

namespace iris
{

/**
 * An implementation of Light for a directional light. This is a light
 * infinitely far away from the scene and consistent in all directions.
 *
 * A light may be constructed to cast shadows, this will cause extra render
 * passes to be created which can impact performance (depending on scene
 * complexity).
 */
class DirectionalLight : public Light
{
  public:
    /** Create a new DirectionalLight (white).
     *
     * @param direction
     *   The direction the rays of light are pointing, for examples to have a
     *   light shining directly down on a scene then its direction would be
     *   (0, -1, 0).
     *
     * @param cast_shadows
     *   True if this light should generate shadows, false otherwise.
     */
    DirectionalLight(const Vector3 &direction, bool cast_shadows = false);

    /** Create a new DirectionalLight.
     *
     * @param direction
     *   The direction the rays of light are pointing, for examples to have a
     *   light shining directly down on a scene then its direction would be
     *   (0, -1, 0).
     *
     * @param colour
     *   The colour of the light.
     *
     * @param cast_shadows
     *   True if this light should generate shadows, false otherwise.
     */
    DirectionalLight(const Vector3 &direction, const Colour &colour, bool cast_shadows = false);

    ~DirectionalLight() override = default;

    /**
     * Get the type of light.
     *
     * @returns
     *   Light type.
     */
    LightType type() const override;

    /**
     * Unused by this light type.
     *
     * @returns
     *   Array of 1.0f values.
     */
    std::array<float, 4u> colour_data() const override;

    /**
     * Get the raw data for the lights world space property i.e direction.
     *
     * @returns
     *   Raw data (as floats) for the world space property.
     */
    std::array<float, 4u> world_space_data() const override;

    /**
     * Unused by this light type.
     *
     * @returns
     *   Array of 0.0f values.
     */
    std::array<float, 3u> attenuation_data() const override;

    /**
     * Get direction of light.
     *
     * @returns
     *   Light direction.
     */
    Vector3 direction() const;

    /**
     * Set direction of light.
     *
     * @param direction
     *   New light direction.
     */
    void set_direction(const Vector3 &direction);

    /**
     * Check if this light should cast shadows.
     *
     * @returns
     *   True if light casts shadows, false otherwise.
     */
    bool casts_shadows() const;

    /**
     * Get the camera used for rendering the shadow map for this light.
     *
     * This is used internally and should not normally be called manually.
     *
     * @returns
     *   Shadow map camera.
     */
    const Camera &shadow_camera() const;

  private:
    /** Light direction. */
    Vector3 direction_;

    /** Shadow map camera. */
    Camera shadow_camera_;

    /** Should shadows be generated. */
    bool cast_shadows_;

    /** Light colour. */
    Colour colour_;
};

}

```

`include/iris/graphics/lights/light.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <array>

#include "graphics/lights/light_type.h"

namespace iris
{

/**
 * Interface for a Light - something which provides luminance in a rendered
 * scene.
 *
 * Whilst this interface defines methods for getting various properties, they
 * may not all be valid for all light types. In that case the return value
 * should be considered unspecified.
 */
class Light
{
  public:
    virtual ~Light() = default;

    /**
     * Get the type of light.
     *
     * @returns
     *   Light type.
     */
    virtual LightType type() const = 0;

    /**
     * Get the raw data for the light colour.
     *
     * @returns
     *   Raw data (as floats) for the colour.
     */
    virtual std::array<float, 4u> colour_data() const = 0;

    /**
     * Get the raw data for the lights world space property e.g. position or
     * direction.
     *
     * @returns
     *   Raw data (as floats) for the world space property.
     */
    virtual std::array<float, 4u> world_space_data() const = 0;

    /**
     * Get the raw data for the lights attenuation.
     *
     * @returns
     *   Raw data (as floats) for the attenuation.
     */
    virtual std::array<float, 3u> attenuation_data() const = 0;
};

}

```

`include/iris/graphics/lights/light_type.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>

namespace iris
{

/**
 * Enumeration of possible light types.
 */
enum class LightType : std::uint8_t
{
    AMBIENT,
    DIRECTIONAL,
    POINT
};

}

```

`include/iris/graphics/lights/lighting_rig.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include "core/colour.h"
#include "graphics/lights/ambient_light.h"
#include "graphics/lights/directional_light.h"
#include "graphics/lights/point_light.h"

#include <memory>
#include <vector>

namespace iris
{

/**
 * Encapsulates all the lights for a scene.
 */
struct LightingRig
{
    /* Collection of point lights. */
    std::vector<std::unique_ptr<PointLight>> point_lights;

    /** Collection of directional lights. */
    std::vector<std::unique_ptr<DirectionalLight>> directional_lights;

    /** Ambient light colour. */
    std::unique_ptr<AmbientLight> ambient_light;
};

}

```

`include/iris/graphics/lights/point_light.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <array>

#include "core/colour.h"
#include "core/vector3.h"
#include "graphics/lights/light.h"
#include "graphics/lights/light_type.h"

namespace iris
{

/**
 * Implementation of Light for a light emitting uniformly from a point in 3D
 * space.
 *
 * For this light attenuation is calculated as:
 * 1.0 / (constant + (linear * d) + (quadratic * d * d))
 *
 * WHere d is the distance of the fragment to the light source.
 */
class PointLight : public Light
{
  public:
    /**
     * Create a new white PointLight.
     *
     * @param position
     *   Position of light in 3D space.
     */
    PointLight(const Vector3 &position);

    /**
     * Create a new PointLight.
     *
     * @param position
     *   Position of light in 3D space.
     *
     * @param colour
     *   Colour of the light.
     */
    PointLight(const Vector3 &position, const Colour &colour);

    ~PointLight() override = default;

    /**
     * Get the type of light.
     *
     * @returns
     *   Light type.
     */
    LightType type() const override;

    /**
     * Get the raw data for the light colour.
     *
     * @returns
     *   Raw data (as floats) for the colour.
     */
    std::array<float, 4u> colour_data() const override;

    /**
     * Get the raw data for the lights world space property i.e position.
     *
     * @returns
     *   Raw data (as floats) for the world space property.
     */
    std::array<float, 4u> world_space_data() const override;

    /**
     * Get the raw data for the lights attenuation.
     *
     * @returns
     *   Raw data (as floats) for the attenuation.
     */
    std::array<float, 3u> attenuation_data() const override;

    /**
     * Get position of light.
     *
     * @returns
     *   Light position.
     */
    Vector3 position() const;

    /**
     * Set light position.
     *
     * @param position
     *   New position.
     */
    void set_position(const Vector3 &position);

    /**
     * Get light colour.
     *
     * @returns
     *   Light colour.
     */
    Colour colour() const;

    /**
     * Set light colour.
     *
     * @param colour
     *   New colour.
     */
    void set_colour(const Colour &colour);

    /**
     * Get constant attenuation term.
     *
     * @returns
     *   Constant attenuation term.
     */
    float attenuation_constant_term() const;

    /**
     * Set constant attenuation term.
     *
     * @param constant
     *   New constant term.
     */
    void set_attenuation_constant_term(float constant);

    /**
     * Get linear attenuation term.
     *
     * @returns
     *   Linear attenuation term.
     */
    float attenuation_linear_term() const;

    /**
     * Set linear attenuation term.
     *
     * @param linear
     *   New linear term.
     */
    void set_attenuation_linear_term(float linear);

    /**
     * Get quadratic attenuation term.
     *
     * @returns
     *   Quadratic attenuation term.
     */
    float attenuation_quadratic_term() const;

    /**
     * Set quadratic attenuation term.
     *
     * @param quadratic
     *   New quadratic term.
     */
    void set_attenuation_quadratic_term(float quadratic);

  private:
    /**
     * Struct storing all attenuation terms. This makes it convenient to memcpy
     */
    struct AttenuationTerms
    {
        float constant;
        float linear;
        float quadratic;
    };

    /** Light position. */
    Vector3 position_;

    /** Light colour. */
    Colour colour_;

    /** Attenuation terms. */
    AttenuationTerms attenuation_terms_;
};

}

```

`include/iris/graphics/linux/linux_window.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <optional>
#include <queue>

#include <GL/glx.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>

#include "core/auto_release.h"
#include "events/event.h"
#include "graphics/material_manager.h"
#include "graphics/texture_manager.h"
#include "graphics/window.h"
#include "graphics/window_manager.h"

namespace iris
{

/**
 * Abstract implementation of Window for linux.
 */
class LinuxWindow : public Window
{
  public:
    /**
     * Construct a new LinuxWindow.
     *
     * @param width
     *   Width of window.
     *
     * @param height
     *   Height of window.
     *
     * @param window_manager
     *   Window manager object.
     *
     * @param texture_manager
     *   Texture manager object.
     *
     * @param material_manager
     *   Material manager object.
     */
    LinuxWindow(
        std::uint32_t width,
        std::uint32_t height,
        WindowManager &window_manager,
        TextureManager &texture_manager,
        MaterialManager &material_manager);

    /**
     * Get the natural scale for the screen. This value reflects the scale
     * factor needed to convert from the default logical coordinate space into
     * the device coordinate space of this screen.
     *
     * @returns
     *   Screen scale factor.
     */
    std::uint32_t screen_scale() const override;

    /**
     * Pump the next user input event. Result will be empty if there are no
     * new events.
     *
     * @returns
     *   Optional event.
     */
    std::optional<Event> pump_event() override;

    /**
     * Get display handle.
     *
     * @returns
     *   Handle to X11 display.
     */
    Display *display() const;

    /**
     * Get window handle.
     *
     * @returns
     *   Handle to X11 window.
     */
    ::Window window() const;

  private:
    /** X11 display handle. */
    AutoRelease<Display *, nullptr> display_;

    /** X11 window handle. */
    AutoRelease<::Window, 0> window_;

    /** OpenGL context object. */
    AutoRelease<GLXContext, nullptr> context_;

    /** Queue of input events. */
    std::queue<Event> events_;
};

}

```

`include/iris/graphics/linux/linux_window_manager.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <memory>

#include "graphics/material_manager.h"
#include "graphics/texture_manager.h"
#include "graphics/window.h"
#include "graphics/window_manager.h"

namespace iris
{

/**
 * Implementation of WindowManager for linux.
 */
class LinuxWindowManager : public WindowManager
{
  public:
    /**
     * @param texture_manager
     *   Texture manager object.
     *
     * @param material_manager
     *   Material manager object.
     */
    LinuxWindowManager(TextureManager &texture_manager, MaterialManager &material_manager);

    /**
     * Create a new Window.
     *
     * @param width
     *   Width of window.
     *
     * @param height
     *   Height of window.
     */
    Window *create_window(std::uint32_t width, std::uint32_t height) override;

    /**
     * Get the currently active window.
     *
     * @returns
     *   Pointer to current window, nullptr if one does not exist.
     */
    Window *current_window() const override;

  private:
    /** Texture manager object. */
    TextureManager &texture_manager_;

    /** Material manager object. */
    MaterialManager &material_manager_;

    /** Current window .*/
    std::unique_ptr<Window> current_window_;
};

}

```

`include/iris/graphics/linux/scoped_error_handler.h`:

```h
#pragma once

#include <X11/Xlib.h>
#include <X11/Xutil.h>

namespace iris
{

/**
 * This struct sets a new X11 error handler to record errors. Restores original handler at end of scope.
 */
class ScopedErrorHandler
{
  public:
    /**
     * Construct a new ScopedErrorHandler, sets a new handler.
     */
    ScopedErrorHandler()
        : old_handler_(nullptr)
    {
        // set handler and store old one.
        old_handler_ = ::XSetErrorHandler(error_handler);
    }

    /**
     * Restores old handler.
     */
    ~ScopedErrorHandler()
    {
        ::XSetErrorHandler(old_handler_);
    }

    /**
     * Checks if an error has occurred.
     *
     * @returns
     *   True if an error has occurred, false otherwise.
     */
    operator bool() const
    {
        return error;
    }

    /**
     * Reset to a "no error" state.
     */
    void reset()
    {
        error = false;
    }

  private:
    /** Flag indicating if an error has occurred */
    static bool error;

    /**
     * Error handler function.
     *
     * @returns
     *   Always returns 0.
     */
    static int error_handler(Display *, XErrorEvent *)
    {
        error = true;
        return 0;
    }

    /** Original error handler function. */
    int (*old_handler_)(Display *, XErrorEvent *);
};

}

```

`include/iris/graphics/macos/macos_window.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>

#include "graphics/material_manager.h"
#include "graphics/texture_manager.h"
#include "graphics/window.h"

namespace iris
{

/**
 * Implementation of Window for macOS.
 */
class MacosWindow : public Window
{
  public:
    /**
     * Construct a new MacosWindow.
     *
     * @param width
     *   Width of window.
     *
     * @param height
     *   Height of window.
     *
     * @param texture_manager
     *   Texture manager object.
     *
     * @param material_manager
     *   Material manager object.
     */
    MacosWindow(
        std::uint32_t width,
        std::uint32_t height,
        TextureManager &texture_manager,
        MaterialManager &material_manager);
    ~MacosWindow() override = default;

    /**
     * Get the natural scale for the screen. This value reflects the scale
     * factor needed to convert from the default logical coordinate space into
     * the device coordinate space of this screen.
     *
     * @returns
     *   Screen scale factor.
     */
    std::uint32_t screen_scale() const override;

    /**
     * Pump the next user input event. Result will be empty if there are no
     * new events.
     *
     * @returns
     *   Optional event.
     */
    std::optional<Event> pump_event() override;
};

}

```

`include/iris/graphics/macos/macos_window_manager.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <memory>

#include "graphics/material_manager.h"
#include "graphics/texture_manager.h"
#include "graphics/window.h"
#include "graphics/window_manager.h"

namespace iris
{

/**
 * Implementation of WindowManager for macos.
 */
class MacosWindowManager : public WindowManager
{
  public:
    /**
     * @param texture_manager
     *   Texture manager object.
     *
     * @param material_manager
     *   Material manager object.
     */
    MacosWindowManager(TextureManager &texture_manager, MaterialManager &material_manager);

    /**
     * Create a new Window.
     *
     * @param width
     *   Width of window.
     *
     * @param height
     *   Height of window.
     */
    Window *create_window(std::uint32_t width, std::uint32_t height) override;

    /**
     * Get the currently active window.
     *
     * @returns
     *   Pointer to current window, nullptr if one does not exist.
     */
    Window *current_window() const override;

  private:
    /** Texture manager object. */
    TextureManager &texture_manager_;

    /** Material manager object. */
    MaterialManager &material_manager_;

    /** Current window .*/
    std::unique_ptr<Window> current_window_;
};

}

```

`include/iris/graphics/macos/metal_app_delegate.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#import <AppKit/AppKit.h>

/**
 * Delegate for our app which will handle window creation
 */
@interface MetalAppDelegate : NSObject <NSApplicationDelegate>
{
}

/**
 * Initialise a new MetalAppDelegate with an OpenGl window of the specified
 * dimensions.
 *
 * @param rect
 *   Dimensions of new window.
 */
- (id)initWithRect:(NSRect)rect;

/** Width of OpenGl window. */
@property(assign) CGFloat width;

/** Height of OpenGl window. */
@property(assign) CGFloat height;

@end

```

`include/iris/graphics/macos/metal_view.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#import <MetalKit/MetalKit.h>

@interface MetalView : MTKView

@end

```

`include/iris/graphics/macos/opengl_app_delegate.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#import <AppKit/AppKit.h>

/**
 * Delegate for our app which will handle window creation
 */
@interface OpenGLAppDelegate : NSObject <NSApplicationDelegate>
{
}

/**
 * Initialise a new OpenGLAppDelegate with an OpenGl window of the specified
 * dimensions.
 *
 * @param rect
 *   Dimensions of new window.
 */
- (id)initWithRect:(NSRect)rect;

/** Width of OpenGl window. */
@property(assign) CGFloat width;

/** Height of OpenGl window. */
@property(assign) CGFloat height;

@end

```

`include/iris/graphics/macos/opengl_view.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#import <Appkit/Appkit.h>

@interface OpenGLView : NSOpenGLView

@end

```

`include/iris/graphics/material.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <span>

namespace iris
{

class RenderGraph;

/**
 * Abstract class for a Material - a class which which encapsulates how to render a Mesh.
 *
 * This interface is deliberately limited, most of the functionality is provided by the implementations, which in turn
 * is only used internally by the engine.
 */
class Material
{
  public:
    /**
     * Construct a new Material.
     *
     * @param render_graph
     *   The render render_graph for this material.
     */
    Material(const RenderGraph *render_graph);
    virtual ~Material() = default;

    /**
     * Get the property buffer for this material.
     *
     * @returns
     *   Property buffer span.
     */
    std::span<std::byte> property_buffer() const;

  private:
    /** Property buffer span. */
    std::span<std::byte> property_buffer_;
};

}

```

`include/iris/graphics/material_cache.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <memory>
#include <tuple>
#include <unordered_map>

#include "core/utils.h"
#include "graphics/render_graph/render_graph.h"
#include "log/log.h"

namespace iris
{

/**
 * Simple caching class for material objects. Allows for a custom key (KeyParts) allowing the user to choose what
 * constitutes a unique material.
 */
template <class Material, class... KeyParts>
class MaterialCache
{
  public:
    /**
     * Clear the cache.
     */
    void clear()
    {
        materials_.clear();
    }

    /**
     * Try and emplace a new material into the cache with the supplies key parts. Does nothing if an entry already
     * exists.
     *
     * @param key_parts
     *   Data which uniquely identifies the material.
     *
     * @param args
     *   Arguments to construct the material with.
     *
     * @returns
     *   The newly created material if one didn't exist for key_parts, else the material already in the cache.
     */
    template <class... Args>
    Material *try_emplace(KeyParts... key_parts, Args &&...args)
    {
        // construct a key from the supplied parts
        Key k{std::forward<KeyParts>(key_parts)...};

        // check if key exists (so we don't create the material unless we know we're going to insert it)
        if (!materials_.contains(k))
        {
            materials_.try_emplace(k, std::make_unique<Material>(std::forward<Args>(args)...));
        }

        return materials_[k].get();
    }

  private:
    /**
     * Custom key class.
     */
    struct Key
    {
        /**
         * Construct a new key from the supplied parts.
         *
         * @param key_parts
         *   Data which uniquely identifies a material.
         */
        Key(KeyParts... key_parts)
            : parts(std::forward<KeyParts>(key_parts)...)
        {
        }

        /**
         * For the cache to work we need keys to compare equal only if their hashes are the same.
         *
         * @param other
         *   Key to compare with.
         *
         * @returns
         *   True if both keys hash the same, otherwise false.
         */
        bool operator==(const Key &other) const
        {
            const Hash hash{};
            return hash(*this) == hash(other);
        }

        /** Key data. */
        std::tuple<KeyParts...> parts;
    };

    /**
     * Custom hash function.
     */
    struct Hash
    {
        std::size_t operator()(const Key &key) const
        {
            return std::apply(combine_hash<KeyParts...>, key.parts);
        }
    };

    /** Material cache. */
    std::unordered_map<Key, std::unique_ptr<Material>, Hash> materials_;
};

}

```

`include/iris/graphics/material_manager.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <array>
#include <cstddef>
#include <span>
#include <vector>

#include "graphics/lights/light_type.h"

namespace iris
{

class Material;
class RenderGraph;
class RenderEntity;

/**
 * Abstract class for creating and managing materials.
 *
 * This class also manages property buffers. These are byte buffers into which user values are copied and then uploaded
 * to the gpu. This allows runtime changing of variables in shaders.
 */
class MaterialManager
{
  public:
    MaterialManager() = default;
    virtual ~MaterialManager() = default;

    MaterialManager(const MaterialManager &) = delete;
    MaterialManager &operator=(const MaterialManager &) = delete;
    MaterialManager(MaterialManager &&) = default;
    MaterialManager &operator=(MaterialManager &&) = default;

    /**
     * Create a new material. Implementations should use a cache to avoid recreating the same material.
     *
     * @param render_graph
     *   RenderGraph describing material.
     *
     * @param render_entity
     *   The entity material is for.
     *
     * @param light_type
     *   The type of light that material should use.
     *
     * @param render_to_colour_target
     *   Whether the material is rendering to a colour target or the back buffer.
     *
     * @param render_to_normal_target
     *   Whether to render screen space normals.
     *
     * @param render_to_position_target.
     *   Whether to render screen positions.
     *
     * @param has_transparency
     *   Hint to the renderer that the material will contain transparency.
     *
     * @returns
     *   Pointer to created Material.
     */
    virtual Material *create(
        RenderGraph *render_graph,
        RenderEntity *render_entity,
        LightType light_type,
        bool render_to_colour_target,
        bool render_to_normal_target,
        bool render_to_position_target,
        bool has_transparency) = 0;

    /**
     * Clear all cached materials. This will invalidate any returned pointers.
     */
    virtual void clear() = 0;

    /**
     * Get property buffer for a render graph.
     *
     * @returns
     *   A span to the allocated buffer.
     */
    std::span<std::byte> create_property_buffer();

  private:
    /** Collection of property buffers. */
    std::vector<std::array<std::byte, 256u>> property_buffers_;
};

}

```

`include/iris/graphics/mesh.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <functional>
#include <vector>

#include "graphics/vertex_data.h"

namespace iris
{

/**
 * Abstract class for a Mesh - a class which encapsulates all the vertex data needed to render a mesh.
 */
class Mesh
{
  public:
    /**
     * Construct a new Mesh.
     *
     * @param vertices
     *   Collection of vertices for mesh.
     *
     * @param indices
     *   Collection of indices for mesh.
     */
    Mesh(const std::vector<VertexData> &vertices, const std::vector<std::uint32_t> &indices);

    virtual ~Mesh() = default;

    /**
     * Update the vertex data, this will also update any GPU data.
     *
     * @param data
     *   New vertex data.
     */
    virtual void update_vertex_data(const std::vector<VertexData> &data) = 0;

    /**
     * Update the index data, this will also update any GPU data.
     *
     * @param data
     *   New index data.
     */
    virtual void update_index_data(const std::vector<std::uint32_t> &data) = 0;

    /**
     * Get a const reference to the vertex data.
     *
     * @returns
     *   Constant reference to vertex data.
     */
    const std::vector<VertexData> &vertices() const;

    /**
     * Get a const reference to the index data.
     *
     * @returns
     *   Constant reference to index data.
     */
    const std::vector<std::uint32_t> &indices() const;

  protected:
    /** Vertex data. */
    std::vector<VertexData> vertices_;

    /** Index data. */
    std::vector<std::uint32_t> indices_;
};

}

```

`include/iris/graphics/mesh_loader.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <functional>
#include <string_view>
#include <vector>

#include "core/resource_manager.h"
#include "graphics/animation/animation.h"
#include "graphics/skeleton.h"
#include "graphics/texture.h"
#include "graphics/vertex_data.h"
#include "graphics/weight.h"

namespace iris::mesh_loader
{

// callback aliases
using MeshDataCallback =
    std::function<void(std::vector<VertexData>, std::vector<std::uint32_t>, std::vector<Weight>, const std::string &)>;
using AnimationCallback = std::function<void(std::vector<Animation>, Skeleton)>;

/**
 * Load a mesh from file.
 *
 * @param resource_manager
 *   Resource manager object.
 *
 * @param mesh_name
 *   Name of of mesh to load, will be passed to ResourceLoader.
 *
 * @param flip_uvs
 *   True if uvs should be flipped, false otherwise.
 *
 * @param mesh_data_callback
 *   Callback for returning loaded mesh data.
 *
 * @param animation_callback
 *   Callback for returning loaded animation data.
 */
void load(
    ResourceManager &resource_manager,
    std::string_view mesh_name,
    bool flip_uvs,
    MeshDataCallback mesh_data_callback,
    AnimationCallback animation_callback);

}

```

`include/iris/graphics/mesh_manager.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <deque>
#include <functional>
#include <memory>
#include <string>
#include <tuple>
#include <unordered_map>

#include "core/colour.h"
#include "core/resource_manager.h"
#include "core/vector3.h"
#include "graphics/animation/animation.h"
#include "graphics/mesh.h"
#include "graphics/skeleton.h"
#include "graphics/texture.h"
#include "graphics/vertex_data.h"

namespace iris
{

class Texture;

/**
 * Abstract class for creating and managing Mesh objects. This class handles caching and lifetime management of all
 * created objects. Implementers just need to provide a graphics API specific method for creating Mesh objects.
 */
class MeshManager
{
  public:
    /**
     * Struct encapsulating all the data returned when loading a mesh file.
     */
    struct Meshes
    {
        /**
         * Data for a single mesh.
         */
        struct MeshData
        {
            /** Pointer to mesh name. */
            Mesh *mesh;

            /** Name of diffuse colour texture (if found in mesh file). */
            std::string texture_name;
        };

        /** Collection of loaded meshes. */
        std::vector<MeshData> mesh_data;

        /** Collection of animations. */
        std::vector<Animation> animations;

        /** Skeleton for all meshes. */
        Skeleton *skeleton;
    };

    /**
     * Construct a new MeshManager.
     *
     * @param resource_manager
     *   Resource manager object.
     *
     * @param flip_uvs_on_load
     *   True if uvs should be flipped for all loaded meshes, false otherwise.
     */
    MeshManager(ResourceManager &resource_manager, bool flip_uvs_on_load);
    virtual ~MeshManager() = default;

    /**
     * Create a Sprite mesh.
     *
     * @param colour
     *   Colour of sprite.
     *
     * @returns
     *   Mesh for sprite.
     */
    const Mesh *sprite(const Colour &colour);

    /**
     * Create a cube mesh.
     *
     * @param colour
     *   Colour of cube.
     *
     * @returns
     *   Mesh for cube.
     */
    const Mesh *cube(const Colour &colour);

    /**
     * Create a new cube, which is not cached. This should be used when the data of the cube Mesh needs to be mutated.
     * It returns a unique_ptr and therefore is not managed by this Manager.
     *
     * Most of the time you will want to use the cube method instead.
     *
     * @param colour
     *   Colour of cube.
     *
     * @returns
     *   Newly created cube mesh.
     */
    std::unique_ptr<Mesh> unique_cube(const Colour &colour) const;

    /**
     * Create a new Mesh, which is not cached. This should be used when the data of the Mesh needs to be mutated.
     * It returns a unique_ptr and therefore is not managed by this Manager.
     *
     * Most of the time you will want to use the other factory methods instead.
     *
     * @param verticies
     *   Vertex data of mesh.
     *
     * @param indices
     *   Indices of mesh.
     *
     * @returns
     *   Newly created mesh.
     */
    std::unique_ptr<Mesh> unique_mesh(
        const std::vector<iris::VertexData> &vertices,
        const std::vector<std::uint32_t> &indices) const;

    /**
     * Create a (XZ) plane mesh (normals pointing up along Y).
     *
     * @param colour
     *   Colour of plane.
     *
     * @param divisions
     *   Number of divisions (both horizontal and vertical).
     *
     * @param scale
     *   How much to scale each division by.
     *
     * @returns
     *   Mesh for place.
     */
    const Mesh *plane(const Colour &colour, std::uint32_t divisions, float scale = 1.0f);

    /**
     * Create a (XY) height map mesh.
     *
     * @param colour
     *   Colour of height map.
     *
     * @param height_image.
     *   Image data to source heights from (will use r component).
     *
     * @returns
     *   Mesh for heightmap.
     */
    const Mesh *heightmap(const Colour &colour, const Texture *height_image);

    /**
     * Create a Quad mesh.
     *
     * @param colour
     *   Colour of quad.
     *
     * @param lower_left
     *   World coords of lower left of quad.
     *
     * @param lower_right
     *   World coords of lower right of quad.
     *
     * @param upper_left
     *   World coords of upper left of quad.
     *
     * @param upper_right
     *   World coords of upper right of quad.
     *
     * @returns
     *   Mesh for quad.
     */
    const Mesh *quad(
        const Colour &colour,
        const Vector3 &lower_left,
        const Vector3 &lower_right,
        const Vector3 &upper_left,
        const Vector3 &upper_right);

    /**
     * Load a mesh from file.
     *
     * @param mesh_file
     *   File to load.
     *
     * @returns
     *   Mesh loaded from file.
     */
    Meshes load_mesh(const std::string &mesh_file);

    /**
     * Load a skeleton from a file.
     *
     * Note that unlike load_mesh this returns a new copy each time, this is so
     * each Skeleton can be mutated independently.
     *
     * @param mesh_file
     *   File to load.
     *
     * @returns
     *   Skeleton loaded from file.
     */
    // Skeleton* load_skeleton(const std::string &mesh_file);

    /**
     * Load animations from a file.
     *
     * Note that unlike load_mesh this returns a new copy each time, this is so
     * each Skeleton can be mutated independently.
     *
     * @param mesh_file
     *   File to load.
     *
     * @returns
     *   Animations loaded from file.
     */
    // std::vector<Animation> load_animations(const std::string &mesh_file);

  protected:
    /**
     * Create a Mesh object from the provided vertex and index data.
     *
     * @param vertices
     *   Collection of vertices for the Mesh.
     *
     * @param indices
     *   Collection of indices for the Mesh.
     *
     * @returns
     *   Loaded Mesh.
     */
    virtual std::unique_ptr<Mesh> create_mesh(
        const std::vector<VertexData> &vertices,
        const std::vector<std::uint32_t> &indices) const = 0;

  private:
    /**
     * Internal struct for caching loaded mesh data.
     */
    struct LoadedMesh
    {
        std::unique_ptr<Mesh> mesh;
        std::string texture_name;
    };

    /** Resource manager object. */
    ResourceManager &resource_manager_;

    /** Cache of created Mesh objects. */
    std::unordered_map<std::string, std::vector<LoadedMesh>> loaded_meshes_;

    /** Collection of created Animation objects. */
    std::unordered_map<std::string, std::vector<Animation>> loaded_animations_;

    /** Collection of loaded skeletons - these are the "master" copies. */
    std::unordered_map<std::string, Skeleton> loaded_skeletons_;

    /** Collection of skeletons returned to callers. */
    std::deque<Skeleton> skeleton_copies_;

    /** Flag indicating if uvs should be flipped for loaded meshes. */
    bool flip_uvs_on_load_;
};

}

```

`include/iris/graphics/metal/metal_buffer.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <cstdint>
#include <vector>

#import <Metal/Metal.h>

#include "graphics/vertex_data.h"

namespace iris
{

/**
 * This class encapsulates a metal buffer. A buffer can be created with either
 * vertex or index data.
 */
class MetalBuffer
{
  public:
    /**
     * Construct a new MetalBuffer with vertex data.
     *
     * @param vertex_data
     *   Vertex data to copy to buffer.
     */
    MetalBuffer(const std::vector<VertexData> &vertex_data);

    /**
     * Construct a new MetalBuffer with index data.
     *
     * @param vertex_data
     *   Index data to copy to buffer.
     */
    MetalBuffer(const std::vector<std::uint32_t> &index_data);

    MetalBuffer(const MetalBuffer &) = delete;
    MetalBuffer &operator=(const MetalBuffer &) = delete;

    /**
     * Get the metal handle to the buffer.
     *
     * @returns
     *   Metal handle.
     */
    id<MTLBuffer> handle() const;

    /**
     * Get the number of elements stored in the buffer.
     *
     * @returns
     *   Number of elements in buffer.
     */
    std::size_t element_count() const;

    /**
     * Write vertex data to the buffer.
     *
     * @param vertex_data
     *   New vertex data.
     */
    void write(const std::vector<VertexData> &vertex_data);

    /**
     * Write index data to the buffer.
     *
     * @param index_data
     *   New index data.
     */
    void write(const std::vector<std::uint32_t> &index_data);

  private:
    /** Metal handle for buffer. */
    id<MTLBuffer> handle_;

    /** Number of elements in buffer. */
    std::size_t element_count_;

    /** Maximum number of elements that can be stored in buffer. */
    std::size_t capacity_;
};

}

```

`include/iris/graphics/metal/metal_constant_buffer.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>

#import <Metal/Metal.h>

#include "core/exception.h"

@protocol MTLBuffer;

namespace iris
{

/**
 * This class encapsulates a constant shader buffer. This is data that is set
 * once then made available to all vertices/fragments. It is analogous to an
 * OpenGL uniform.
 */
class MetalConstantBuffer
{
  public:
    /**
     * Construct a new MetalConstantBuffer.
     *
     * @param capacity
     *   Size (in bytes) of buffer.
     */
    MetalConstantBuffer(std::size_t capacity);

    MetalConstantBuffer(const MetalConstantBuffer &) = delete;
    MetalConstantBuffer &operator=(const MetalConstantBuffer &) = delete;

    /**
     * Write an object into the buffer at an offset.
     *
     * @param object
     *   Object to write.
     *
     * @param offset
     *   Offset into buffer to write object.
     */
    template <class T>
    void write(const T &object, std::size_t offset)
    {
        write(std::addressof(object), sizeof(T), offset);
    }

    /**
     * Write an object into the buffer at an offset.
     *
     * @param object
     *   Object to write.
     *
     * @param size
     *   Size (in bytes) of object to write.
     *
     * @param offset
     *   Offset into buffer to write object.
     */
    template <class T>
    void write(const T *object, std::size_t size, std::size_t offset)
    {
        if (offset + size > capacity_)
        {
            throw Exception("write would overflow");
        }

        std::memcpy(static_cast<std::byte *>(buffer_.contents) + offset, object, size);
    }

    /**
     * Get metal handle to buffer.
     *
     * @returns
     *   Metal handle.
     */
    id<MTLBuffer> handle() const;

  private:
    /** Metal handle to buffer. */
    id<MTLBuffer> buffer_;

    /** Capacity (in bytes) of buffer. */
    std::size_t capacity_;
};

}

```

`include/iris/graphics/metal/metal_cube_map.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#import <Metal/Metal.h>

#include "core/data_buffer.h"
#include "graphics/cube_map.h"
#include "graphics/sampler.h"

namespace iris
{

/**
 * Implementation of CubeMap for Metal.
 */
class MetalCubeMap : public CubeMap
{
  public:
    /**
     * Construct a new MetalCubeMap.
     *
     * @param right_data
     *   Image data for right face of cube.
     *
     * @param left_data
     *   Image data for left face of cube.
     *
     * @param top_data
     *   Image data for top face of cube.
     *
     * @param bottom_data
     *   Image data for bottom face of cube.
     *
     * @param back_data
     *   Image data for back face of cube.
     *
     * @param front_data
     *   Image data for front face of cube.
     *
     * @param width
     *   Width of each image face.
     *
     * @param height
     *   Height of each image face.
     *
     * @param sampler
     *   Sampler to use for cube map.
     *
     * @param index
     *   Index into the global array of all allocated textures.
     */
    MetalCubeMap(
        const DataBuffer &right_data,
        const DataBuffer &left_data,
        const DataBuffer &top_data,
        const DataBuffer &bottom_data,
        const DataBuffer &back_data,
        const DataBuffer &front_data,
        std::uint32_t width,
        std::uint32_t height,
        const Sampler *sampler,
        std::uint32_t index);

    ~MetalCubeMap() override = default;

    /**
     * Get metal handle to texture.
     *
     * @returns
     *   Metal texture handle.
     */
    id<MTLTexture> handle() const;

  private:
    /** Metal texture handle. */
    id<MTLTexture> texture_;
};

}

```

`include/iris/graphics/metal/metal_material.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <vector>

#import <Metal/Metal.h>
#import <MetalKit/MetalKit.h>

#include "graphics/lights/light_type.h"
#include "graphics/material.h"
#include "graphics/render_graph/render_graph.h"

namespace iris
{

/**
 * Implementation of Material for metal.
 */
class MetalMaterial : public Material
{
  public:
    /**
     * Construct a new MetalMaterial.
     *
     * @param render_graph
     *   RenderGraph that describes the material.
     *
     * @param descriptors
     *   Metal vertex descriptor describing how to organise vertex data.
     *
     * @param light_type
     *   Type of light for this material.
     *
     * @param render_to_normal_target
     *   Flag indicating whether the material should also write out screen space normals to a render texture.
     *
     * @param render_to_position_target
     *   Flag indicating whether the material should also write out screen space positions to a render texture.
     *
     * @param has_transparency
     *   Hint to the renderer that the material will contain transparency.
     */
    MetalMaterial(
        const RenderGraph *render_graph,
        MTLVertexDescriptor *descriptors,
        LightType light_type,
        bool render_to_normal_target,
        bool render_to_position_target,
        bool has_transparency);

    ~MetalMaterial() override = default;

    /**
     * Get the metal pipeline state for this material.
     *
     * @returns
     *   Pipeline state.
     */
    id<MTLRenderPipelineState> pipeline_state() const;

  private:
    /** Pipeline state object. */
    id<MTLRenderPipelineState> pipeline_state_;
};

}

```

`include/iris/graphics/metal/metal_material_manager.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include "graphics/lights/light_type.h"
#include "graphics/material_cache.h"
#include "graphics/material_manager.h"
#include "graphics/metal/metal_material.h"

namespace iris
{

class Material;
class RenderGraph;
class RenderEntity;

/**
 * Implementation of MaterialManager for metal.
 */
class MetalMaterialManager : public MaterialManager
{
  public:
    ~MetalMaterialManager() override = default;

    /**
     * Create a new material.
     *
     * @param render_graph
     *   RenderGraph describing material.
     *
     * @param render_entity
     *   The entity material is for.
     *
     * @param light_type
     *   The type of light that material should use.
     *
     * @param render_to_colour_target
     *   Whether the material is rendering to a colour target or the back buffer.
     *
     * @param render_to_normal_target
     *   Whether to render screen space normals.
     *
     * @param render_to_position_target.
     *   Whether to render screen positions.
     *
     * @param has_transparency
     *   Hint to the renderer that the material will contain transparency.
     *
     * @returns
     *   Pointer to created Material.
     */
    Material *create(
        RenderGraph *render_graph,
        RenderEntity *render_entity,
        LightType light_type,
        bool render_to_colour_target,
        bool render_to_normal_target,
        bool render_to_position_target,
        bool has_transparency) override;

    /**
     * Clear all cached materials. This will invalidate any returned pointers.
     */
    void clear() override;

  private:
    /** Cache of created materials. */
    MaterialCache<MetalMaterial, RenderGraph *, LightType, bool, bool> materials_;
};

}

```

`include/iris/graphics/metal/metal_mesh.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <vector>

#import <Metal/Metal.h>

#include "graphics/mesh.h"
#include "graphics/metal/metal_buffer.h"
#include "graphics/vertex_data.h"

namespace iris
{

/**
 * Implementation of Mesh for metal.
 */
class MetalMesh : public Mesh
{
  public:
    /**
     * Construct a new MetalMesh.
     *
     * @param vertices
     *   Vertices for the mesh.
     *
     * @param indices
     *   Indices for the mesh.
     *
     * @param attributes
     *   Attributes of the vertices.
     */
    MetalMesh(
        const std::vector<VertexData> &vertices,
        const std::vector<std::uint32_t> &indices,
        const VertexAttributes &attributes);

    ~MetalMesh() override = default;

    /**
     * Update the vertex data, this will also update any GPU data.
     *
     * @param data
     *   New vertex data.
     */
    void update_vertex_data(const std::vector<VertexData> &data) override;

    /**
     * Update the index data, this will also update any GPU data.
     *
     * @param data
     *   New index data.
     */
    void update_index_data(const std::vector<std::uint32_t> &data) override;

    /**
     * Get vertex buffer.
     *
     * @returns
     *   Const reference to vertex buffer object.
     */
    const MetalBuffer &vertex_buffer() const;

    /**
     * Get index buffer.
     *
     * @returns
     *   Const reference to index buffer object.
     */
    const MetalBuffer &index_buffer() const;

    /**
     * Get Metal object which describes vertex layout.
     *
     * @param
     *   Metal object describing vertex.
     */
    MTLVertexDescriptor *descriptors() const;

  private:
    /** Buffer for vertex data. */
    MetalBuffer vertex_buffer_;

    /** Buffer for index data. */
    MetalBuffer index_buffer_;

    /** Metal object describing vertex layout. */
    MTLVertexDescriptor *descriptors_;
};

}

```

`include/iris/graphics/metal/metal_mesh_manager.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <memory>
#include <vector>

#include "core/resource_manager.h"
#include "graphics/mesh.h"
#include "graphics/mesh_manager.h"
#include "graphics/vertex_data.h"

namespace iris
{

/**
 * Implementation of MeshManager for metal.
 */
class MetalMeshManager : public MeshManager
{
  public:
    /**
     * Construct a new MetalMeshManager.
     *
     * @param resource_manager
     *   Resource manager object.
     */
    MetalMeshManager(ResourceManager &resource_manager);

    ~MetalMeshManager() override = default;

  protected:
    /**
     * Create a Mesh object from the provided vertex and index data.
     *
     * @param vertices
     *   Collection of vertices for the Mesh.
     *
     * @param indices
     *   Collection of indices fro the Mesh.
     *
     * @returns
     *   Loaded Mesh.
     */
    std::unique_ptr<Mesh> create_mesh(
        const std::vector<iris::VertexData> &vertices,
        const std::vector<std::uint32_t> &indices) const override;
};

}

```

`include/iris/graphics/metal/metal_render_target.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include "graphics/render_target.h"
#include "graphics/texture.h"

namespace iris
{

/**
 * Implementation of RenderTarget for metal.
 */
class MetalRenderTarget : public RenderTarget
{
  public:
    /**
     * Construct a new MetalRenderTarget.
     *
     * @param colour_texture
     *   Texture to render colour data to.
     *
     * @param depth_texture
     *   Texture to render depth data to.
     */
    MetalRenderTarget(const Texture *colour_texture, const Texture *depth_texture);

    ~MetalRenderTarget() override = default;
};

}

```

`include/iris/graphics/metal/metal_render_target_manager.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <memory>
#include <vector>

#include "graphics/metal/metal_render_target.h"
#include "graphics/render_target_manager.h"
#include "graphics/texture_manager.h"
#include "graphics/window_manager.h"

namespace iris
{

class RenderTarget;

/**
 * Implementation of RenderTargetManager for metal.
 */
class MetalRenderTargetManager : public RenderTargetManager
{
  public:
    /**
     * Create a new MetalRenderTargetManager object.
     *
     * @param window_manager
     *   Window manager object.
     *
     * @param texture_manager
     *   Texture manager object.
     */
    MetalRenderTargetManager(WindowManager &window_manager, TextureManager &texture_manager);

    /**
     * Create a render target the size of the current window.
     *
     * @returns
     *   Pointer to the created render target.
     */
    RenderTarget *create() override;

    /**
     * Create a render target with the specified dimensions.
     *
     * @param width
     *   Width of render target.
     *
     * @param height
     *   Height of render target.
     *
     * @returns
     *   Pointer to the created render target.
     */
    RenderTarget *create(std::uint32_t width, std::uint32_t height) override;

    /**
     * Create a new render target which combines the colour target and depth target of two separate render targets.
     *
     * @param colour_target
     *   Render target to for colour target.
     *
     * @param depth_target
     *   Render target to for depth target.
     *
     * @returns
     *   Pointer to the created render target.
     */
    RenderTarget *create(const RenderTarget *colour_target, const RenderTarget *depth_target) override;

  private:
    /** Window manager object.  */
    WindowManager &window_manager_;

    /** Texture manager object.  */
    TextureManager &texture_manager_;

    /** Collection of created render targets. */
    std::vector<std::unique_ptr<MetalRenderTarget>> render_targets_;
};

}

```

`include/iris/graphics/metal/metal_renderer.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <memory>
#include <mutex>
#include <unordered_map>
#include <vector>

#import <Metal/Metal.h>
#import <MetalKit/MetalKit.h>
#import <QuartzCore/QuartzCore.h>

#include "graphics/material_manager.h"
#include "graphics/metal/metal_constant_buffer.h"
#include "graphics/metal/metal_material.h"
#include "graphics/metal/metal_render_target.h"
#include "graphics/metal/metal_texture.h"
#include "graphics/render_command.h"
#include "graphics/render_graph/render_graph.h"
#include "graphics/render_pipeline.h"
#include "graphics/renderer.h"
#include "graphics/texture_manager.h"

namespace iris
{

/**
 * Implementation of Renderer for metal.
 *
 * This Renderer uses triple buffering to allow for greatest rendering
 * throughput. A frame if defined as all rendering passes that occur when
 * render() is called. This class uses a circular buffer of three frames. When
 * all the CPU processing of a frame is complete it is submitted to the GPU. At
 * this point the CPU is free to proceed to the next frame whilst the GPU works
 * asynchronously.
 */
class MetalRenderer : public Renderer
{
  public:
    /**
     * Construct a new MetalRenderer.
     *
     * @param texture_manager
     *   Texture manager object.
     *
     * @param material_manager
     *   Material manager object.
     *
     * @param width
     *   Width of window being rendered to.
     *
     * @param height
     *   Height of window being rendered to.
     */
    MetalRenderer(
        TextureManager &texture_manager,
        MaterialManager &material_manager,
        std::uint32_t width,
        std::uint32_t height);

    /**
     * Destructor, will block until all inflight frames have finished rendering.
     */
    ~MetalRenderer() override;

  protected:
    /**
     * Render specific method to set the render pipeline.
     *
     * @param build_queue
     *   Function to build queue.
     */
    void do_set_render_pipeline(std::function<void()> build_queue) override;

    // handlers for the supported RenderCommandTypes

    void pre_render() override;
    void execute_pass_start(RenderCommand &command) override;
    void execute_draw(RenderCommand &command) override;
    void execute_pass_end(RenderCommand &command) override;
    void execute_present(RenderCommand &command) override;
    void post_render() override;

  private:
    /**
     * Internal struct encapsulating data needed for a frame.
     */
    struct Frame
    {
        /**
         * Lock to ensure GPU has finished executing frame before we try and
         * write to it again.
         * */
        std::mutex lock;

        /** Map of bone data buffers to render entities. */
        std::unordered_map<const RenderEntity *, std::unique_ptr<MetalConstantBuffer>> bone_data;

        /** Map of model data buffers to render entities. */
        std::unordered_map<const RenderEntity *, std::unique_ptr<MetalConstantBuffer>> model_data;

        /** Map of light data buffers to lights. */
        std::unordered_map<const Light *, std::unique_ptr<MetalConstantBuffer>> light_data;

        std::unordered_map<const Camera *, std::unique_ptr<MetalConstantBuffer>> camera_data;

        std::unordered_map<const Material *, std::unique_ptr<MetalConstantBuffer>> property_data;
    };

    /** Texture manager object. */
    TextureManager &texture_manager_;

    /** Current command queue. */
    id<MTLCommandQueue> command_queue_;

    /** Default descriptor for all render passes. */
    MTLRenderPassDescriptor *single_pass_descriptor_;

    MTLRenderPassDescriptor *multi_pass_descriptor_;

    /** Current metal drawable. */
    id<CAMetalDrawable> drawable_;

    /** Current command buffer. */
    id<MTLCommandBuffer> command_buffer_;

    /** Default state for depth buffers. */
    id<MTLDepthStencilState> depth_stencil_state_;

    /** Current render encoder. */
    id<MTLRenderCommandEncoder> render_encoder_;

    /** Current frame number. */
    std::size_t current_frame_;

    /** Triple buffered frames. */
    std::array<Frame, 3u> frames_;

    /** Map of targets to render encoders. */
    std::unordered_map<const RenderTarget *, id<MTLRenderCommandEncoder>> render_encoders_;

    /** The depth buffer for the default frame. */
    std::unique_ptr<MetalTexture> default_depth_buffer_;

    /** Map of instance data buffers to render entities.  */
    std::unordered_map<const RenderEntity *, std::unique_ptr<MetalConstantBuffer>> instance_data_;

    /** Buffer for bindless texture table. */
    std::unique_ptr<MetalConstantBuffer> texture_table_;

    /** Buffer for bindless cube map table. */
    std::unique_ptr<MetalConstantBuffer> cube_map_table_;

    /** Buffer for bindless sampler table. */
    std::unique_ptr<MetalConstantBuffer> sampler_table_;

    /** Collection of resources that need to be made resident before rendering. */
    std::vector<id<MTLResource>> resident_resources_;
};

}

```

`include/iris/graphics/metal/metal_sampler.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include "graphics/sampler.h"

#import <Metal/Metal.h>

namespace iris
{

/**
 * Implementation of Sampler for D3D12.
 */
class MetalSampler : public Sampler
{
  public:
    /**
     * Create a new MetalSampler.
     *
     * @param descriptor
     *   Description of sampler parameters.
     *
     * @param index
     *   Index into the global array of all allocated samplers.
     */
    MetalSampler(const SamplerDescriptor &descriptor, std::uint32_t index);
    ~MetalSampler() override = default;

    /**
     * Get the metal handle for the sampler object.
     *
     * @returns
     *   Metal handle.
     */
    id<MTLSamplerState> handle() const;

  private:
    /** Native metal sampler object. */
    id<MTLSamplerState> sampler_;
};

}

```

`include/iris/graphics/metal/metal_texture.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>

#import <Metal/Metal.h>

#include "core/data_buffer.h"
#include "graphics/texture.h"
#include "graphics/texture_usage.h"

namespace iris
{

/**
 * Implementation of Texture for metal.
 */
class MetalTexture : public Texture
{
  public:
    /**
     * Construct a new MetalTexture.
     *
     * @param data
     *   Image data. This should be width * hight of pixel_format tuples.
     *
     * @param width
     *   Width of image.
     *
     * @param height
     *   Height of data.
     *
     * @param sampler
     *   Sampler to use for this texture.
     *
     * @param usage
     *   Texture usage.
     *
     * @param index
     *   Index into the global array of all allocated textures.
     */
    MetalTexture(
        const DataBuffer &data,
        std::uint32_t width,
        std::uint32_t height,
        const Sampler *sampler,
        TextureUsage usage,
        std::uint32_t index);

    ~MetalTexture() override = default;

    /**
     * Get metal handle to texture.
     *
     * @returns
     *   Metal texture handle.
     */
    id<MTLTexture> handle() const;

  private:
    /** Metal texture handle. */
    id<MTLTexture> texture_;
};

}

```

`include/iris/graphics/metal/metal_texture_manager.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <memory>

#include "core/data_buffer.h"
#include "graphics/cube_map.h"
#include "graphics/sampler.h"
#include "graphics/texture.h"
#include "graphics/texture_manager.h"
#include "graphics/texture_usage.h"

namespace iris
{

/**
 * Implementation of TextureManager for metal.
 */
class MetalTextureManager : public TextureManager
{
  public:
    /**
     * Construct a new MetalTextureManager object.
     *
     * @param resource_manager
     *   Resource manager object.
     */
    MetalTextureManager(ResourceManager &resource_manager);

  protected:
    /**
     * Create a Texture object with the provided data.
     *
     * @param data
     *   Raw data of image, in pixel_format.
     *
     * @param width
     *   Width of image.
     *
     * @param height
     *   Height of image.
     *
     * @param usage
     *   Usage of the texture.
     *
     * @param sampler
     *   Sampler to use for this texture.
     *
     * @param index
     *   Index into the global array of all allocated textures.
     *
     * @returns
     *   Created texture.
     */
    std::unique_ptr<Texture> do_create(
        const DataBuffer &data,
        std::uint32_t width,
        std::uint32_t height,
        const Sampler *sampler,
        TextureUsage usage,
        std::uint32_t index) override;

    /**
     * Create a CubeMap from six DataBuffers (one for each face).
     *
     * @param right_data
     *   Image data for right face of cube.
     *
     * @param right_data
     *   Image data for right face of cube.
     *
     * @param left_data
     *   Image data for left face of cube.
     *
     * @param top_data
     *   Image data for top face of cube.
     *
     * @param bottom_data
     *   Image data for bottom face of cube.
     *
     * @param back_data
     *   Image data for back face of cube.
     *
     * @param front_data
     *   Image data for front face of cube.
     *
     * @param width
     *   Width of each image face.
     *
     * @param height
     *   Height of each image face.
     *
     * @param sampler
     *   Sampler to use for this texture.
     *
     * @param index
     *   Index into the global array of all allocated textures.
     *
     * @returns
     *   Created CubeMap.
     */
    std::unique_ptr<CubeMap> do_create(
        const DataBuffer &right_data,
        const DataBuffer &left_data,
        const DataBuffer &top_data,
        const DataBuffer &bottom_data,
        const DataBuffer &near_data,
        const DataBuffer &far_data,
        std::uint32_t width,
        std::uint32_t height,
        const Sampler *sampler,
        std::uint32_t index) override;

    std::unique_ptr<Sampler> do_create(const SamplerDescriptor &descriptor, std::uint32_t index) override;
};

}

```

`include/iris/graphics/opengl/opengl.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <functional>
#include <optional>
#include <string>
#include <string_view>

// platform specific opengl includes

#if defined(IRIS_PLATFORM_WIN32)
#define WIN32_LEAN_AND_MEAN
// clang-format off
#include <Windows.h>
#include "gl/gl.h"
// clang-format on
#pragma comment(lib, "opengl32.lib")
#elif defined(IRIS_PLATFORM_LINUX)
#include <GL/gl.h>
#include <GL/glx.h>
#else
#error unsupported platform
#endif

// in order to avoid duplicating all the opengl function definitions as both extern and concrete we can use the EXTERN
// macro to control its linkage
// by default all functions will be marked as extern (the common case) unless this include is prefaced with
// DONT_MAKE_GL_FUNCTIONS_EXTERN
#if defined(DONT_MAKE_GL_FUNCTIONS_EXTERN)
#define EXTERN
#else
#define EXTERN extern
#endif
#include "graphics/opengl/opengl_defines.h"

namespace iris
{

/**
 * Throws an exception if an OpenGl error has occurred.
 *
 * @param error_message
 *   The message to include in the exception.
 *
 * @returns
 *   Empty optional if no error occurred, otherwise an error string.
 */
std::optional<std::string> do_check_opengl_error(std::string_view error_message);

// create std::function so it can be passed to ensure/expect
static const std::function<std::optional<std::string>(std::string_view)> check_opengl_error = do_check_opengl_error;

}

```

`include/iris/graphics/opengl/opengl_buffer.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>

#include "core/error_handling.h"
#include "graphics/opengl/opengl.h"
#include "graphics/vertex_data.h"

namespace iris
{

/**
 * This class encapsulates an opengl buffer template on target and usage.
 */
template <GLenum Target, GLenum Usage, bool FixedSize>
class OpenGLBuffer
{
  public:
    /**
     * Construct a new Open GLBuffer object with an initial capacity.
     *
     * @param capacity
     *   Capacity of buffer.
     */
    OpenGLBuffer(std::size_t capacity)
        : handle_(0u)
        , capacity_(capacity)
    {
        ::glGenBuffers(1, &handle_);
        iris::expect(iris::check_opengl_error, "could not generate opengl buffer");

        ::glBindBuffer(Target, handle_);
        expect(check_opengl_error, "could not bind buffer");

        ::glBufferData(Target, capacity_, nullptr, Usage);
        expect(check_opengl_error, "could not create buffer");

        ::glBindBuffer(Target, 0u);
        expect(check_opengl_error, "could not unbind buffer");
    }

    /**
     * Construct a new Open GLBuffer object with an initial capacity.
     *
     * @param capacity
     *   Capacity of buffer.
     *
     * @param index
     *   Index of binding point in Target.
     */
    OpenGLBuffer(std::size_t capacity, GLuint index)
        : handle_(0u)
        , capacity_(capacity)
    {
        ::glGenBuffers(1, &handle_);
        iris::expect(iris::check_opengl_error, "could not generate opengl buffer");

        ::glBindBuffer(Target, handle_);
        expect(check_opengl_error, "could not bind buffer");

        ::glBufferData(Target, capacity_, nullptr, Usage);
        expect(check_opengl_error, "could not create buffer");

        ::glBindBuffer(Target, 0u);
        expect(check_opengl_error, "could not unbind buffer");

        ::glBindBufferRange(Target, index, handle_, 0, capacity_);
        expect(check_opengl_error, "could not set buffer range");
    }

    ~OpenGLBuffer()
    {
        ::glDeleteBuffers(1, &handle_);
    }

    OpenGLBuffer(const OpenGLBuffer &) = delete;
    OpenGLBuffer &operator=(const OpenGLBuffer &) = delete;

    /**
     * Get the opengl handle to the buffer.
     *
     * @returns
     *   OpenGL handle.
     */
    GLuint handle() const
    {
        return handle_;
    }

    /**
     * Get capacity of buffer.
     *
     * @returns
     *   Buffer capacity.
     */
    std::size_t capacity() const
    {
        return capacity_;
    }

    /**
     * Write an object into the buffer at an offset.
     *
     * @param object
     *   Object to write.
     *
     * @param offset
     *   Offset into buffer to write object.
     */
    template <class T>
    void write(const T &object, std::size_t offset)
    {
        write(std::addressof(object), sizeof(T), offset);
    }

    /**
     * Write an object into the buffer at an offset.
     *
     * If offset + size > capacity then the behaviour depends on FixedSize:
     *   true - throws
     *   false - resizes the buffer
     *
     * @param object
     *   Object to write.
     *
     * @param size
     *   Size (in bytes) of object to write.
     *
     * @param offset
     *   Offset into buffer to write object.
     */
    template <class T>
    void write(const T *object, std::size_t size, std::size_t offset)
    {
        if (offset + size > capacity_)
        {
            if constexpr (FixedSize)
            {
                throw Exception("write would overflow");
            }
            else
            {
                // pick some sensible new capacity size
                const auto old_capacity = capacity_;
                capacity_ = std::max(offset + size, capacity_ * 2u);

                // bind current handle to copy target
                ::glBindBuffer(GL_COPY_READ_BUFFER, handle_);
                expect(check_opengl_error, "could not bind read buffer");

                // create a new handle
                GLuint new_handle = 0u;
                ::glGenBuffers(1u, &new_handle);
                expect(check_opengl_error, "could not create new buffer");

                // bind new handle to existing target
                ::glBindBuffer(Target, new_handle);
                expect(check_opengl_error, "could not bind write buffer");

                // allocate space for new handle
                ::glBufferData(Target, capacity_, nullptr, Usage);
                expect(check_opengl_error, "could not allocate write buffer");

                // copy data from old handle to new handle
                ::glCopyBufferSubData(GL_COPY_READ_BUFFER, Target, 0, 0, old_capacity);
                expect(check_opengl_error, "could not copy data");

                // delete old handle
                ::glDeleteBuffers(1, &handle_);
                expect(check_opengl_error, "could not delete old handle");

                // update new handle - note that if this buffer is a VBO or EBO it will invalidate any VAOs
                handle_ = new_handle;

                ::glBindBuffer(GL_COPY_READ_BUFFER, 0u);
                expect(check_opengl_error, "could not unbind read buffer");
            }
        }

        ::glBindBuffer(Target, handle_);
        expect(check_opengl_error, "could not bind buffer");

        ::glBufferSubData(Target, offset, size, object);
        expect(check_opengl_error, "could not set buffer data");

        ::glBindBuffer(Target, 0u);
        expect(check_opengl_error, "could not unbind buffer");
    }

  private:
    /** OpenGL handle for buffer. */
    GLuint handle_;

    /** Capacity of buffer. */
    std::size_t capacity_;
};

// helper aliases
using VBO = OpenGLBuffer<GL_ARRAY_BUFFER, GL_STATIC_DRAW, false>;
using EBO = OpenGLBuffer<GL_ELEMENT_ARRAY_BUFFER, GL_STATIC_DRAW, false>;
using UBO = OpenGLBuffer<GL_UNIFORM_BUFFER, GL_DYNAMIC_DRAW, true>;
using SSBO = OpenGLBuffer<GL_SHADER_STORAGE_BUFFER, GL_DYNAMIC_DRAW, true>;

}
```

`include/iris/graphics/opengl/opengl_cube_map.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>

#include "core/data_buffer.h"
#include "graphics/cube_map.h"
#include "graphics/opengl/opengl.h"
#include "graphics/sampler.h"

namespace iris
{

/**
 * Implementation of CubeMap for OpenGL.
 */
class OpenGLCubeMap : public CubeMap
{
  public:
    /**
     * Construct a new OpenGLCubeMap.
     *
     * @param right_data
     *   Image data for right face of cube.
     *
     * @param left_data
     *   Image data for left face of cube.
     *
     * @param top_data
     *   Image data for top face of cube.
     *
     * @param bottom_data
     *   Image data for bottom face of cube.
     *
     * @param back_data
     *   Image data for back face of cube.
     *
     * @param front_data
     *   Image data for front face of cube.
     *
     * @param width
     *   Width of each image face.
     *
     * @param height
     *   Height of each image face.
     *
     * @param sampler
     *   Sampler to use for this cube map.
     *
     * @param index
     *   Index into the global array of all allocated textures.
     */
    OpenGLCubeMap(
        const DataBuffer &right_data,
        const DataBuffer &left_data,
        const DataBuffer &top_data,
        const DataBuffer &bottom_data,
        const DataBuffer &back_data,
        const DataBuffer &front_data,
        std::uint32_t width,
        std::uint32_t height,
        const Sampler *sampler,
        std::uint32_t index);

    /**
     * Clean up OpenGL objects.
     */
    ~OpenGLCubeMap() override;

    /**
     * Get OpenGL handle to texture.
     *
     * @returns
     *   OpenGL texture handle.
     */
    GLuint handle() const;

    /**
     * Get the OpenGL bindless handle for this cube map.
     *
     * @returns
     *   Bindless handle.
     */
    GLuint64 bindless_handle() const;

  private:
    /** OpenGL texture handle. */
    GLuint handle_;

    /** OpengGL bindless handle. */
    GLuint64 bindless_handle_;
};

}

```

`include/iris/graphics/opengl/opengl_defines.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

/**
 * This is an incomplete file and is intended to be included in
 * include/opengl/opengl.h
 *
 * *DO NOT* include this file directly
 *
 * This file defines various opengl constants and functions required for windows
 */

#define GL_ARRAY_BUFFER 0x8892
#define GL_ELEMENT_ARRAY_BUFFER 0x8893
#define GL_STATIC_DRAW 0x88E4
#define GL_DYNAMIC_DRAW 0x88E8
#define GL_LINK_STATUS 0x8B82
#define GL_INFO_LOG_LENGTH 0x8B84
#define GL_FRAMEBUFFER 0x8D40
#define GL_COLOR_ATTACHMENT0 0x8CE0
#define GL_DEPTH_ATTACHMENT 0x8D00
#define GL_FRAMEBUFFER_COMPLETE 0x8CD5
#define GL_TEXTURE0 0x84C0
#define GL_READ_FRAMEBUFFER 0x8CA8
#define GL_DRAW_FRAMEBUFFER 0x8CA9
#define GL_FRAGMENT_SHADER 0x8B30
#define GL_VERTEX_SHADER 0x8B31
#define GL_COMPILE_STATUS 0x8B81
#define GL_READ_FRAMEBUFFER 0x8CA8
#define GL_MIRRORED_REPEAT 0x8370
#define GL_CLAMP_TO_BORDER 0x812D
#define GL_CLAMP_TO_EDGE 0x812F
#define GL_RGBA16F 0x881A
#define GL_SRGB 0x8C40
#define GL_SRGB_ALPHA 0x8C42
#define GL_FRAMEBUFFER_SRGB 0x8DB9
#define GL_TEXTURE_WRAP_R 0x8072
#define GL_TEXTURE_CUBE_MAP 0x8513
#define GL_TEXTURE_CUBE_MAP_POSITIVE_X 0x8515
#define GL_UNIFORM_BUFFER 0x8A11
#define GL_COPY_READ_BUFFER 0x8F36
#define GL_COPY_WRITE_BUFFER 0x8F37
#define GL_SHADER_STORAGE_BUFFER 0x90D2

#define WGL_CONTEXT_MAJOR_VERSION_ARB 0x2091
#define WGL_CONTEXT_MINOR_VERSION_ARB 0x2092
#define WGL_CONTEXT_PROFILE_MASK_ARB 0x9126
#define WGL_CONTEXT_CORE_PROFILE_BIT_ARB 0x00000001
#define WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB 0x00000002
#define WGL_DRAW_TO_WINDOW_ARB 0x2001
#define WGL_ACCELERATION_ARB 0x2003
#define WGL_SUPPORT_OPENGL_ARB 0x2010
#define WGL_DOUBLE_BUFFER_ARB 0x2011
#define WGL_PIXEL_TYPE_ARB 0x2013
#define WGL_COLOR_BITS_ARB 0x2014
#define WGL_DEPTH_BITS_ARB 0x2022
#define WGL_STENCIL_BITS_ARB 0x2023
#define WGL_FULL_ACCELERATION_ARB 0x2027
#define WGL_TYPE_RGBA_ARB 0x202B

// platform specific defines
#if defined(IRIS_PLATFORM_WIN32)
#define GL_COLOR_ATTACHMENT1 0x8CE1
#define GL_COLOR_ATTACHMENT2 0x8CE2
#endif

using GLsizeiptr = std::ptrdiff_t;
using GLintptr = std::ptrdiff_t;
using GLchar = char;
using GLuint64 = std::uint64_t;

// x-macro definition for all opengl functions we want to laod
// by default when we include opengl.h we want all these to be marked extern we will then define them all once in a
// single translation unit where they can be resolved
// read comments in opengl.h for more details on the EXTERN macro

// platform specific functions to resolve
#if defined(IRIS_PLATFORM_WIN32)
#define FOR_OPENGL_FUNCTIONS(DO)                                                                                       \
    DO(void, glDeleteBuffers, GLsizei, const GLuint *)                                                                 \
    DO(void, glUseProgram, GLuint)                                                                                     \
    DO(void, glBindBuffer, GLenum, GLuint)                                                                             \
    DO(void, glGenVertexArrays, GLsizei, GLuint *)                                                                     \
    DO(void, glDeleteVertexArrays, GLsizei, GLuint *)                                                                  \
    DO(void, glBindVertexArray, GLuint)                                                                                \
    DO(void, glEnableVertexAttribArray, GLuint)                                                                        \
    DO(void, glVertexAttribPointer, GLuint, GLint, GLenum, GLboolean, GLsizei, const void *)                           \
    DO(void, glVertexAttribIPointer, GLuint, GLint, GLenum, GLsizei, const void *)                                     \
    DO(GLuint, glCreateProgram, void)                                                                                  \
    DO(void, glAttachShader, GLuint, GLuint)                                                                           \
    DO(void, glGenBuffers, GLsizei, GLuint *)                                                                          \
    DO(void, glBufferData, GLenum, GLsizeiptr, const void *, GLenum)                                                   \
    DO(void, glBufferSubData, GLenum, GLintptr, GLsizeiptr, const void *)                                              \
    DO(void, glLinkProgram, GLuint)                                                                                    \
    DO(void, glGetProgramiv, GLuint, GLenum, GLint *)                                                                  \
    DO(void, glGetProgramInfoLog, GLuint, GLsizei, GLsizei *, GLchar *)                                                \
    DO(void, glDeleteProgram, GLuint)                                                                                  \
    DO(void, glGenFramebuffers, GLsizei, GLuint *)                                                                     \
    DO(void, glBindFramebuffer, GLenum, GLuint)                                                                        \
    DO(void, glFramebufferTexture2D, GLenum, GLenum, GLenum, GLuint, GLint)                                            \
    DO(GLenum, glCheckFramebufferStatus, GLenum)                                                                       \
    DO(void, glDeleteFramebuffers, GLsizei, const GLuint *)                                                            \
    DO(GLint, glGetUniformLocation, GLuint, const GLchar *)                                                            \
    DO(void, glUniformMatrix4fv, GLint, GLsizei, GLboolean, const GLfloat *)                                           \
    DO(void, glUniform3f, GLint, GLfloat, GLfloat, GLfloat)                                                            \
    DO(void, glUniform1fv, GLint, GLsizei, const GLfloat *)                                                            \
    DO(void, glUniform4fv, GLint, GLsizei, const GLfloat *)                                                            \
    DO(void, glUniform1i, GLint, GLint)                                                                                \
    DO(void, glBlitFramebuffer, GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLbitfield, GLenum)            \
    DO(GLuint, glCreateShader, GLenum)                                                                                 \
    DO(void, glShaderSource, GLuint, GLsizei, const GLchar **, const GLint *)                                          \
    DO(void, glCompileShader, GLuint)                                                                                  \
    DO(void, glGetShaderiv, GLuint, GLenum, GLint *)                                                                   \
    DO(void, glGetShaderInfoLog, GLuint, GLsizei, GLsizei *, GLchar *)                                                 \
    DO(void, glDeleteShader, GLuint)                                                                                   \
    DO(void, glGenerateMipmap, GLenum)                                                                                 \
    DO(void, glBindBufferBase, GLenum, GLuint, GLuint)                                                                 \
    DO(void, glBindBufferRange, GLenum, GLuint, GLuint, GLintptr, GLsizeiptr)                                          \
    DO(GLuint64, glGetTextureHandleARB, GLuint)                                                                        \
    DO(GLuint64, glGetTextureSamplerHandleARB, GLuint, GLuint)                                                         \
    DO(void, glMakeTextureHandleResidentARB, GLuint64)                                                                 \
    DO(void, glMakeTextureHandleNonResidentARB, GLuint64)                                                              \
    DO(void, glCopyBufferSubData, GLenum, GLenum, GLintptr, GLintptr, GLsizeiptr)                                      \
    DO(void, glDrawElementsInstanced, GLenum, GLsizei, GLenum, const void *, GLsizei)                                  \
    DO(void, glGenSamplers, GLsizei, GLuint *)                                                                         \
    DO(void, glBindSampler, GLuint, GLuint)                                                                            \
    DO(void, glDeleteSamplers, GLsizei, const GLuint *)                                                                \
    DO(void, glSamplerParameteri, GLuint, GLenum, GLint)                                                               \
    DO(void, glSamplerParameterfv, GLuint, GLenum, const GLfloat *)                                                    \
    DO(void, glDrawBuffers, GLsizei, const GLenum *)                                                                   \
    DO(void, glActiveTexture, GLenum)
#elif defined(IRIS_PLATFORM_LINUX)
#define FOR_OPENGL_FUNCTIONS(DO)                                                                                       \
    DO(void, glDeleteBuffers, GLsizei, const GLuint *)                                                                 \
    DO(void, glUseProgram, GLuint)                                                                                     \
    DO(void, glBindBuffer, GLenum, GLuint)                                                                             \
    DO(void, glGenVertexArrays, GLsizei, GLuint *)                                                                     \
    DO(void, glDeleteVertexArrays, GLsizei, GLuint *)                                                                  \
    DO(void, glBindVertexArray, GLuint)                                                                                \
    DO(void, glEnableVertexAttribArray, GLuint)                                                                        \
    DO(void, glVertexAttribPointer, GLuint, GLint, GLenum, GLboolean, GLsizei, const void *)                           \
    DO(void, glVertexAttribIPointer, GLuint, GLint, GLenum, GLsizei, const void *)                                     \
    DO(GLuint, glCreateProgram, void)                                                                                  \
    DO(void, glAttachShader, GLuint, GLuint)                                                                           \
    DO(void, glGenBuffers, GLsizei, GLuint *)                                                                          \
    DO(void, glBufferData, GLenum, GLsizeiptr, const void *, GLenum)                                                   \
    DO(void, glBufferSubData, GLenum, GLintptr, GLsizeiptr, const void *)                                              \
    DO(void, glLinkProgram, GLuint)                                                                                    \
    DO(void, glGetProgramiv, GLuint, GLenum, GLint *)                                                                  \
    DO(void, glGetProgramInfoLog, GLuint, GLsizei, GLsizei *, GLchar *)                                                \
    DO(void, glDeleteProgram, GLuint)                                                                                  \
    DO(void, glGenFramebuffers, GLsizei, GLuint *)                                                                     \
    DO(void, glBindFramebuffer, GLenum, GLuint)                                                                        \
    DO(void, glFramebufferTexture2D, GLenum, GLenum, GLenum, GLuint, GLint)                                            \
    DO(GLenum, glCheckFramebufferStatus, GLenum)                                                                       \
    DO(void, glDeleteFramebuffers, GLsizei, const GLuint *)                                                            \
    DO(GLint, glGetUniformLocation, GLuint, const GLchar *)                                                            \
    DO(void, glUniformMatrix4fv, GLint, GLsizei, GLboolean, const GLfloat *)                                           \
    DO(void, glUniform3f, GLint, GLfloat, GLfloat, GLfloat)                                                            \
    DO(void, glUniform1fv, GLint, GLsizei, const GLfloat *)                                                            \
    DO(void, glUniform4fv, GLint, GLsizei, const GLfloat *)                                                            \
    DO(void, glUniform1i, GLint, GLint)                                                                                \
    DO(void, glBlitFramebuffer, GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLbitfield, GLenum)            \
    DO(GLuint, glCreateShader, GLenum)                                                                                 \
    DO(void, glShaderSource, GLuint, GLsizei, const GLchar **, const GLint *)                                          \
    DO(void, glCompileShader, GLuint)                                                                                  \
    DO(void, glGetShaderiv, GLuint, GLenum, GLint *)                                                                   \
    DO(void, glGetShaderInfoLog, GLuint, GLsizei, GLsizei *, GLchar *)                                                 \
    DO(void, glDeleteShader, GLuint)                                                                                   \
    DO(void, glGenerateMipmap, GLenum)                                                                                 \
    DO(void, glBindBufferBase, GLenum, GLuint, GLuint)                                                                 \
    DO(void, glBindBufferRange, GLenum, GLuint, GLuint, GLintptr, GLsizeiptr)                                          \
    DO(GLuint64, glGetTextureHandleARB, GLuint)                                                                        \
    DO(GLuint64, glGetTextureSamplerHandleARB, GLuint, GLuint)                                                         \
    DO(void, glMakeTextureHandleResidentARB, GLuint64)                                                                 \
    DO(void, glMakeTextureHandleNonResidentARB, GLuint64)                                                              \
    DO(void, glCopyBufferSubData, GLenum, GLenum, GLintptr, GLintptr, GLsizeiptr)                                      \
    DO(void, glDrawElementsInstanced, GLenum, GLsizei, GLenum, const void *, GLsizei)                                  \
    DO(void, glGenSamplers, GLsizei, GLuint *)                                                                         \
    DO(void, glBindSampler, GLuint, GLuint)                                                                            \
    DO(void, glDeleteSamplers, GLsizei, const GLuint *)                                                                \
    DO(void, glSamplerParameteri, GLuint, GLenum, GLint)                                                               \
    DO(void, glSamplerParameterfv, GLuint, GLenum, const GLfloat *)                                                    \
    DO(void, glDrawBuffers, GLsizei, const GLenum *)
#endif

// declare all functions
#define DECLARE_FUNCTIONS(RETURN, NAME, ...) EXTERN RETURN (*NAME)(__VA_ARGS__);
FOR_OPENGL_FUNCTIONS(DECLARE_FUNCTIONS)

```

`include/iris/graphics/opengl/opengl_frame_buffer.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include "core/auto_release.h"
#include "graphics/opengl/opengl.h"
#include "graphics/opengl/opengl_render_target.h"

namespace iris
{

/**
 * This is an internal class which encapsulates an OpenGL Frame Buffer Object (FBO). This is separate to the
 * OpenGLRenderTarget because, annoyingly, if we want multiple render targets we need to know all the outputs at the
 * time we create the FBO. This is cumbersome and makes the RenderTarget API hard to use. Instead we keep the
 * RenderTarget API simple for the user and internally in the OpenGLRenderer we create these OpenGLFrameBuffer objects
 * when we set a scene.
 */
class OpenGLFrameBuffer
{
  public:
    /**
     * Create a new empty OpenGLFrameBuffer.
     */
    OpenGLFrameBuffer() = default;

    /**
     * Create a new OpenGLFrameBuffer.
     *
     * @param colour_target
     *   Optional target to write colour data to.
     *
     * @param normal_target
     *   Optional target to write screen space normals to.
     *
     * @param position_target
     *   Optional target to write screen space positions to.
     */
    OpenGLFrameBuffer(
        const OpenGLRenderTarget *colour_target,
        const OpenGLRenderTarget *normal_target,
        const OpenGLRenderTarget *position_target);

    OpenGLFrameBuffer(const OpenGLFrameBuffer &) = delete;
    OpenGLFrameBuffer &operator=(const OpenGLFrameBuffer &) = delete;

    OpenGLFrameBuffer(OpenGLFrameBuffer &&) = default;
    OpenGLFrameBuffer &operator=(OpenGLFrameBuffer &&) = default;

    /**
     * Bind the FBO for rendering.
     */
    void bind() const;

    /**
     * Unbind the FBO.
     */
    void unbind() const;

    /**
     * Get the colour target.
     *
     * @return
     *   Colour target if set, otherwise nullptr.
     */
    const OpenGLRenderTarget *colour_target() const;

    /**
     * Get the normal target.
     *
     * @return
     *   Normal target if set, otherwise nullptr.
     */
    const OpenGLRenderTarget *normal_target() const;

    /**
     * Get the position target.
     *
     * @return
     *   Position target if set, otherwise nullptr.
     */
    const OpenGLRenderTarget *position_target() const;

  private:
    /** OpenGL handle for FBO. */
    AutoRelease<GLuint, 0u> handle_;

    /** Optional colour target. */
    const OpenGLRenderTarget *colour_target_;

    /** Optional normal target. */
    const OpenGLRenderTarget *normal_target_;

    /** Optional position target. */
    const OpenGLRenderTarget *position_target_;
};

}

```

`include/iris/graphics/opengl/opengl_material.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <vector>

#include "graphics/lights/light_type.h"
#include "graphics/material.h"
#include "graphics/opengl/opengl.h"
#include "graphics/render_graph/render_graph.h"

namespace iris
{

/**
 * Implementation of Material for OpenGL.
 */
class OpenGLMaterial : public Material
{
  public:
    /**
     * Construct a new OpenGLMaterial.
     *
     * @param render_graph
     *   RenderGraph that describes the material.
     *
     * @param light_type
     *   Type of light for this material.
     *
     * @param render_to_normal_target
     *   Flag indicating whether the material should also write out screen space normals to a render texture.
     *
     * @param render_to_position_target
     *   Flag indicating whether the material should also write out screen space positions to a render texture.
     */
    OpenGLMaterial(
        const RenderGraph *render_graph,
        LightType light_type,
        bool render_to_normal_target,
        bool render_to_position_target);

    /**
     * Clean up OpenGL objects.
     */
    ~OpenGLMaterial() override;

    /**
     * Bind this material for rendering with.
     */
    void bind() const;

    /**
     * Get the OpenGL handle to this material.
     *
     * @returns
     *   OpenGL handle.
     */
    GLuint handle() const;

  private:
    /** OpenGL handle to material. */
    GLuint handle_;
};

}

```

`include/iris/graphics/opengl/opengl_material_manager.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include "graphics/lights/light_type.h"
#include "graphics/material_cache.h"
#include "graphics/material_manager.h"
#include "graphics/opengl/opengl_material.h"

namespace iris
{

class Material;
class RenderGraph;
class RenderTarget;

/**
 * Implementation of MaterialManager for OpenGL.
 */
class OpenGLMaterialManager : public MaterialManager
{
  public:
    ~OpenGLMaterialManager() override = default;

    /**
     * Create a new material.
     *
     * @param render_graph
     *   RenderGraph describing material.
     *
     * @param render_entity
     *   The entity material is for.
     *
     * @param light_type
     *   The type of light that material should use.
     *
     * @param render_to_colour_target
     *   Whether the material is rendering to a colour target or the back buffer.
     *
     * @param render_to_normal_target
     *   Whether to render screen space normals.
     *
     * @param render_to_position_target.
     *   Whether to render screen positions.
     *
     * @param has_transparency
     *   Hint to the renderer that the material will contain transparency.
     *
     * @returns
     *   Pointer to created Material.
     */
    Material *create(
        RenderGraph *render_graph,
        RenderEntity *render_entity,
        LightType light_type,
        bool render_to_colour_target,
        bool render_to_normal_target,
        bool render_to_position_target,
        bool has_transparency);

    /**
     * Clear all cached materials. This will invalidate any returned pointers.
     */
    void clear() override;

  private:
    /** Cache of created materials. */
    MaterialCache<OpenGLMaterial, RenderGraph *, LightType, bool, bool> materials_;
};

}

```

`include/iris/graphics/opengl/opengl_mesh.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <vector>

#include "graphics/mesh.h"
#include "graphics/opengl/opengl.h"
#include "graphics/opengl/opengl_buffer.h"
#include "graphics/vertex_attributes.h"
#include "graphics/vertex_data.h"

namespace iris
{

/**
 * Implementation of Mesh for OpenGL.
 */
class OpenGLMesh : public Mesh
{
  public:
    /**
     * Construct a new OpenGLMesh.
     *
     * @param vertices
     *   Vertices for the mesh.
     *
     * @param indices
     *   Indices for the mesh.
     *
     * @param attributes
     *   Attributes of the vertices.
     */
    OpenGLMesh(
        const std::vector<VertexData> &vertices,
        const std::vector<std::uint32_t> &indices,
        const VertexAttributes &attributes);

    /**
     * Clean up OpenGL objects.
     */
    ~OpenGLMesh();

    /**
     * Update the vertex data, this will also update any GPU data.
     *
     * @param data
     *   New vertex data.
     */
    void update_vertex_data(const std::vector<VertexData> &data) override;

    /**
     * Update the index data, this will also update any GPU data.
     *
     * @param data
     *   New index data.
     */
    void update_index_data(const std::vector<std::uint32_t> &data) override;

    /**
     * Get number of elements to be rendered.
     *
     * @returns
     *   Number of elements to render.
     */
    GLsizei element_count() const;

    /**
     * Bind this mesh for rendering.
     */
    void bind() const;

    /**
     * Unbind this mesh for rendering.
     */
    void unbind() const;

  private:
    /**
     * Helper method to setup the VAO.
     */
    void setup_vao();

    /** Attributes of the vertices. */
    VertexAttributes attributes_;

    /** Buffer for vertex data. */
    VBO vertex_buffer_;

    /** Buffer for index data. */
    EBO index_buffer_;

    /** OpenGL handle to a vertex array object for this mesh. */
    GLuint vao_;

    /** Number of elements to render. */
    GLsizei element_count_;
};

}

```

`include/iris/graphics/opengl/opengl_mesh_manager.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <memory>
#include <vector>

#include "core/resource_manager.h"
#include "graphics/mesh.h"
#include "graphics/mesh_manager.h"
#include "graphics/vertex_data.h"

namespace iris
{

/**
 * Implementation of MeshManager for OpenGL.
 */
class OpenGLMeshManager : public MeshManager
{
  public:
    /**
     * Construct a new OpenGLMeshManager.
     *
     * @param resource_manager
     *   Resource manager object.
     */
    OpenGLMeshManager(ResourceManager &resource_manager);

  protected:
    /**
     * Create a Mesh object from the provided vertex and index data.
     *
     * @param vertices
     *   Collection of vertices for the Mesh.
     *
     * @param indices
     *   Collection of indices fro the Mesh.
     *
     * @returns
     *   Loaded Mesh.
     */
    std::unique_ptr<Mesh> create_mesh(
        const std::vector<iris::VertexData> &vertices,
        const std::vector<std::uint32_t> &indices) const override;
};

}

```

`include/iris/graphics/opengl/opengl_render_target.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include "graphics/render_target.h"
#include "graphics/texture.h"

namespace iris
{

/**
 * Implementation of RenderTarget for OpenGL.
 */
class OpenGLRenderTarget : public RenderTarget
{
  public:
    /**
     * Construct a new OpenGLRenderTarget.
     *
     * @param colour_texture
     *   Texture to render colour data to.
     *
     * @param depth_texture
     *   Texture to render depth data to.
     */
    OpenGLRenderTarget(const Texture *colour_texture, const Texture *depth_texture);
};

}

```

`include/iris/graphics/opengl/opengl_render_target_manager.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <memory>
#include <vector>

#include "graphics/opengl/opengl_render_target.h"
#include "graphics/render_target_manager.h"
#include "graphics/texture_manager.h"
#include "graphics/window_manager.h"

namespace iris
{

/**
 * Implementation of RenderTargetManager for OpenGL.
 */
class OpenGLRenderTargetManager : public RenderTargetManager
{
  public:
    /**
     * Create a new OpenGLRenderTargetManager object.
     *
     * @param window_manager
     *   Window manager object.
     *
     * @param texture_manager
     *   Texture manager object.
     */
    OpenGLRenderTargetManager(WindowManager &window_manager, TextureManager &texture_manager);

    /**
     * Create a render target the size of the current window.
     *
     * @returns
     *   Pointer to the created render target.
     */
    RenderTarget *create() override;

    /**
     * Create a render target with the specified dimensions.
     *
     * @param width
     *   Width of render target.
     *
     * @param height
     *   Height of render target.
     *
     * @returns
     *   Pointer to the created render target.
     */
    RenderTarget *create(std::uint32_t width, std::uint32_t height) override;

    /**
     * Create a new render target which combines the colour target and depth target of two separate render targets.
     *
     * @param colour_target
     *   Render target to for colour target.
     *
     * @param depth_target
     *   Render target to for depth target.
     *
     * @returns
     *   Pointer to the created render target.
     */
    RenderTarget *create(const RenderTarget *colour_target, const RenderTarget *depth_target) override;

  private:
    /** Collection of created render targets. */
    std::vector<std::unique_ptr<OpenGLRenderTarget>> render_targets_;

    /** Window manager object.  */
    WindowManager &window_manager_;

    /** Texture manager object.  */
    TextureManager &texture_manager_;
};

}

```

`include/iris/graphics/opengl/opengl_renderer.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <deque>
#include <memory>
#include <unordered_map>
#include <vector>

#include "graphics/material_cache.h"
#include "graphics/material_manager.h"
#include "graphics/opengl/opengl_buffer.h"
#include "graphics/opengl/opengl_frame_buffer.h"
#include "graphics/opengl/opengl_material.h"
#include "graphics/opengl/opengl_render_target.h"
#include "graphics/opengl/opengl_uniform.h"
#include "graphics/render_pipeline.h"
#include "graphics/renderer.h"
#include "graphics/texture_manager.h"
#include "graphics/window_manager.h"

namespace iris
{

/**
 * Implementation of Renderer for OpenGL.
 */
class OpenGLRenderer : public Renderer
{
  public:
    /**
     * Construct a new OpenGLRenderer.
     *
     * @param window_manager
     *   Window manager object.
     *
     * @param texture_manager
     *   Texture manager object.
     *
     * @param material_manager
     *   Material manager object.
     *
     * @param width
     *   Width of window being rendered to.
     *
     * @param height
     *   Height of window being rendered to.
     */
    OpenGLRenderer(
        WindowManager &window_manager,
        TextureManager &texture_manager,
        MaterialManager &material_manager,
        std::uint32_t width,
        std::uint32_t height);
    ~OpenGLRenderer() override = default;

  protected:
    /**
     * Render specific method to set the render pipeline.
     *
     * @param build_queue
     *   Function to build queue.
     */
    void do_set_render_pipeline(std::function<void()> build_queue) override;

    // handlers for the supported RenderCommandTypes

    void execute_pass_start(RenderCommand &command) override;

    void execute_draw(RenderCommand &command) override;

    void execute_present(RenderCommand &command) override;

  private:
    /** Window manager object. */
    WindowManager &window_manager_;

    /** Texture manager object. */
    TextureManager &texture_manager_;

    // helper aliases to try and simplify the verbose types
    using LightMaterialMap = std::unordered_map<LightType, std::unique_ptr<OpenGLMaterial>>;

    /** Width of window being rendered to. */
    std::uint32_t width_;

    /** Height of window being rendered to. */
    std::uint32_t height_;

    /** Buffer for per pass camera data. */
    std::unique_ptr<UBO> camera_data_;

    /** Buffers for per pass entity bone data. */
    std::unordered_map<const RenderEntity *, std::unique_ptr<UBO>> bone_data_;

    /** Buffers for per pass entity model data. */
    std::unordered_map<const RenderEntity *, std::unique_ptr<SSBO>> model_data_;

    /** Buffers for per scene entity instance data. */
    std::unordered_map<const RenderEntity *, std::unique_ptr<SSBO>> instance_data_;

    /** Buffers for per scene texture data. */
    std::unique_ptr<SSBO> texture_table_;

    /** Buffers for per scene cube map data. */
    std::unique_ptr<SSBO> cube_map_table_;

    /** Buffer for render specific values. */
    std::unique_ptr<UBO> render_values_;

    /** Buffers for per pass light data. */
    std::unordered_map<const Light *, std::unique_ptr<UBO>> light_data_;

    /** Collection of frame buffers per render pass. */
    std::unordered_map<const RenderPass *, OpenGLFrameBuffer> pass_frame_buffers_;
};

}

```

`include/iris/graphics/opengl/opengl_sampler.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>

#include "graphics/opengl/opengl.h"
#include "graphics/sampler.h"

namespace iris
{

/**
 * Implementation of Sampler for OpenGL.
 */
class OpenGLSampler : public Sampler
{
  public:
    /**
     * Create a new OpenGLSampler.
     *
     * @param descriptor
     *   Description of sampler parameters.
     *
     * @param index
     *   Index into the global array of all allocated samplers.
     */
    OpenGLSampler(const SamplerDescriptor &descriptor, std::uint32_t index);
    ~OpenGLSampler();

    /**
     * Get OpenGL handle to sample.
     *
     * @returns
     *   OpenGL handle.
     */
    GLuint handle() const;

  private:
    /** OpenGL handle to sampler object. */
    GLuint handle_;
};

}

```

`include/iris/graphics/opengl/opengl_shader.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <string>

#include "graphics/opengl/opengl.h"
#include "graphics/shader_type.h"

namespace iris
{

/**
 * Class encapsulating an opengl shader.
 */
class OpenGLShader
{
  public:
    /**
     * Construct a new shader.
     *
     * @param source
     *   Source of the opengl shader.
     *
     * @param type
     *   The type of shader.
     */
    OpenGLShader(const std::string &source, ShaderType type);

    /**
     * Destructor, performs opengl cleanup.
     */
    ~OpenGLShader();

    /**
     * Move constructor, steals the state from the moved-in object.
     *
     * @param other
     *   Object to take state from. Do not use after this call.
     */
    OpenGLShader(OpenGLShader &&other);

    /**
     * Move operator, steals the state from the moved-in object.
     *
     * @param other
     *   Object to take state from. Do not use after this call.
     */
    OpenGLShader &operator=(OpenGLShader &&);

    /** Disabled */
    OpenGLShader(const OpenGLShader &) = delete;
    OpenGLShader &operator=(const OpenGLShader &) = delete;

    /**
     * Get the native opengl handle.
     *
     * @returns native opengl handle.
     */
    GLuint native_handle() const;

  private:
    /** Opengl shader object. */
    GLuint shader_;
};

}

```

`include/iris/graphics/opengl/opengl_texture.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>

#include "graphics/opengl/opengl.h"

#include "core/data_buffer.h"
#include "graphics/sampler.h"
#include "graphics/texture.h"
#include "graphics/texture_usage.h"

namespace iris
{

/**
 * Implementation of Texture for OpenGL.
 */
class OpenGLTexture : public Texture
{
  public:
    /**
     * Construct a new OpenGLTexture.
     *
     * @param data
     *   Image data. This should be width * hight of pixel_format tuples.
     *
     * @param width
     *   Width of image.
     *
     * @param height
     *   Height of data.
     *
     * @param sampler
     *   Sampler to use for this texture.
     *
     * @param usage
     *   Texture usage.
     *
     * @param index
     *   Index into the global array of all allocated textures.
     */
    OpenGLTexture(
        const DataBuffer &data,
        std::uint32_t width,
        std::uint32_t height,
        const Sampler *sampler,
        TextureUsage usage,
        std::uint32_t index);

    /**
     * Clean up OpenGL objects.
     */
    ~OpenGLTexture() override;

    /**
     * Get OpenGL handle to texture.
     *
     * @returns
     *   OpenGL texture handle.
     */
    GLuint handle() const;

    /**
     * Get the OpenGL bindless handle for this texture.
     *
     * @returns
     *   Bindless handle.
     */
    GLuint64 bindless_handle() const;

  private:
    /** OpenGL texture handle. */
    GLuint handle_;

    /** OpengGL bindless handle. */
    GLuint64 bindless_handle_;
};

}

```

`include/iris/graphics/opengl/opengl_texture_manager.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <memory>
#include <stack>

#include "core/data_buffer.h"
#include "core/resource_manager.h"
#include "graphics/cube_map.h"
#include "graphics/opengl/opengl.h"
#include "graphics/sampler.h"
#include "graphics/texture_manager.h"
#include "graphics/texture_usage.h"

namespace iris
{

/**
 * Implementation of TextureManager for OpenGL.
 */
class OpenGLTextureManager : public TextureManager
{
  public:
    /**
     * Construct a new OpenGLTextureManager.
     *
     * @param resource_manager
     *   Resource manager object.
     */
    OpenGLTextureManager(ResourceManager &resource_manager);

  protected:
    /**
     * Create a Texture object with the provided data.
     *
     * @param data
     *   Raw data of image, in pixel_format.
     *
     * @param width
     *   Width of image.
     *
     * @param height
     *   Height of image.
     *
     * @param sampler
     *   Sampler to use for this texture.
     *
     * @param usage
     *   Usage of the texture.
     *
     * @param index
     *   Index into the global array of all allocated textures.
     *
     * @returns
     *   Created texture.
     */
    std::unique_ptr<Texture> do_create(
        const DataBuffer &data,
        std::uint32_t width,
        std::uint32_t height,
        const Sampler *sampler,
        TextureUsage usage,
        std::uint32_t index) override;

    /**
     * Create a CubeMap from six DataBuffers (one for each face).
     *
     * @param right_data
     *   Image data for right face of cube.
     *
     * @param right_data
     *   Image data for right face of cube.
     *
     * @param left_data
     *   Image data for left face of cube.
     *
     * @param top_data
     *   Image data for top face of cube.
     *
     * @param bottom_data
     *   Image data for bottom face of cube.
     *
     * @param back_data
     *   Image data for back face of cube.
     *
     * @param front_data
     *   Image data for front face of cube.
     *
     * @param width
     *   Width of each image face.
     *
     * @param height
     *   Height of each image face.
     *
     * @param sampler
     *   Sampler to use for this texture.
     *
     * @param index
     *   Index into the global array of all allocated textures.
     *
     * @returns
     *   Created CubeMap.
     */
    std::unique_ptr<CubeMap> do_create(
        const DataBuffer &right_data,
        const DataBuffer &left_data,
        const DataBuffer &top_data,
        const DataBuffer &bottom_data,
        const DataBuffer &near_data,
        const DataBuffer &far_data,
        std::uint32_t width,
        std::uint32_t height,
        const Sampler *sampler,
        std::uint32_t index) override;

    std::unique_ptr<Sampler> do_create(const SamplerDescriptor &descriptor, std::uint32_t index) override;
};

}

```

`include/iris/graphics/opengl/opengl_uniform.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <array>
#include <cstdint>
#include <string>
#include <vector>

#include "core/matrix4.h"
#include "graphics/opengl/opengl.h"

namespace iris
{

/**
 * This class encapsulates an OpenGL uniform and provides methods for uploading
 * data. It is the callers responsability to ensure the correct sized data is
 * written to the uniform.
 *
 * Note that in the case where ensure_exists is false it is still valid to call
 * set_value.
 */
class OpenGLUniform
{
  public:
    /**
     * Construct a new OpenGLUniform.
     *
     * @param program
     *   OpenGL program uniform is for.
     *
     * @param name
     *   The name of the uniform.
     *
     * @param ensure_exists
     *   If true then an exception will be thrown if the uniform does not
     *   exists, else construction continues as normal.
     */
    OpenGLUniform(GLuint program, const std::string &name, bool ensure_exists = true);

    /**
     * Set a matrix value for the uniform.
     *
     * @param value
     *   The value to set.
     */
    void set_value(const Matrix4 &value) const;

    /**
     * Set an array of matrix values for the uniform.
     *
     * @param value
     *   The value to set.
     */
    void set_value(const std::vector<Matrix4> &value) const;

    /**
     * Set an array of float values for the uniform.
     *
     * @param value
     *   The value to set.
     */
    void set_value(const std::array<float, 4u> &value) const;

    /**
     * Set an array of float values for the uniform.
     *
     * @param value
     *   The value to set.
     */
    void set_value(const std::array<float, 3u> &value) const;

    /**
     * Set an integer value for the uniform.
     *
     * @param value
     *   The value to set.
     */
    void set_value(std::int32_t value) const;

  private:
    /** OpenGL location of uniform. */
    GLint location_;
};

}

```

`include/iris/graphics/post_processing_description.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <optional>

namespace iris
{

/**
 * User settings for SSAO.
 */
struct AmbientOcclusionDescription
{
    /** Number of samples to take when calculating occlusion. */
    std::uint32_t sample_count = 32u;

    /** Radius of each sample. */
    float radius = 0.5f;

    /** Bias to apply to random sample depth when comparing. */
    float bias = 0.025f;
};

/**
 * User settings for bloom.
 */
struct BloomDescription
{
    /** Threshold luminance to bloom.  */
    float threshold = 1.0f;

    /** Number of blur iterations. */
    std::uint32_t iterations = 5u;
};

/**
 * Enumeration of possible tone map curves.
 */
enum class ToneMapCurve
{
    REINHARD
};

/**
 * User settings for colour adjustment.
 */
struct ColourAdjustDescription
{
    /** Gamma amount. */
    float gamma = 2.2f;

    /** Tone map curve. */
    ToneMapCurve tone_map_curve = ToneMapCurve::REINHARD;
};

/**
 * User settings for FXAA.
 */
struct AntiAliasingDescription
{
};

/**
 * Description of post processing effects to apply a render pass.
 */
struct PostProcessingDescription
{
    std::optional<AmbientOcclusionDescription> ambient_occlusion = std::nullopt;
    std::optional<BloomDescription> bloom = std::nullopt;
    std::optional<ColourAdjustDescription> colour_adjust = std::nullopt;
    std::optional<AntiAliasingDescription> anti_aliasing = std::nullopt;
};

}

```

`include/iris/graphics/primitive_type.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>

namespace iris
{

/**
 * Enumeration of primitive types.
 */
enum class PrimitiveType : std::uint32_t
{
    LINES,
    TRIANGLES
};

}

```

`include/iris/graphics/render_command.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include "graphics/lights/light.h"
#include "graphics/lights/light_type.h"
#include "graphics/material.h"
#include "graphics/render_command_type.h"
#include "graphics/render_entity.h"
#include "graphics/render_pass.h"
#include "graphics/render_target.h"

namespace iris
{

/**
 * A RenderCommand represents an instruction to a Renderer. It is possible to
 * create a queue of these commands such that when executed by a Renderer the
 * desired output is presented to a Window. It is expected that each Renderer
 * implementation interprets these commands in such a way that the output is
 * always the same, therefore the command queue is agnostic to the graphics API.
 *
 * This class is just a grab-bag of pointers to various rendering objects. The
 * type will infer which are valid for any given command (can assume nullptr if
 * not valid for a given type).
 *
 * This is an internal class and a queue is built from RenderPass objects by a
 * Renderer.
 *
 * Note also that this class can violate the "correct by construction" paradigm
 * in that:
 *  - It has a zero argument constructor
 *  - Every member has a getter/setter and no validation is performed against
 *    the type.
 *
 * This is acceptable because:
 *  1. It's an internal class so the engine is aware of the limitations.
 *  2. It makes creating a queue easier as we can construct one and then just
 *     use the setters to update the fields as we need to. This is apposed to
 *     having to recreate the full state of each command every time we need a
 *     new one.
 */
class RenderCommand
{
  public:
    /**
     * Construct a new RenderCommand. Default type is PASS_START
     */
    RenderCommand();

    /**
     * Constructor a new RenderCommand.
     *
     * @param type
     *   Command type.
     *
     * @param render_pass
     *   Pointer to RenderPass.
     *
     * @param material
     *   Pointer to Material.
     *
     * @param render_entity
     *   Pointer to RenderEntity.
     *
     * @param shadow_map
     *   Pointer to shadow map RenderTarget.
     *
     * @param light
     *   Pointer to light.
     */
    RenderCommand(
        RenderCommandType type,
        const RenderPass *render_pass,
        const Material *material,
        const RenderEntity *render_entity,
        const RenderTarget *shadow_map,
        const Light *light);

    /**
     * Get command type.
     *
     * @returns
     *   Command type.
     */
    RenderCommandType type() const;

    /**
     * Set command type.
     *
     * @param type
     *   New command type.
     */
    void set_type(RenderCommandType type);

    /**
     * Get pointer to RenderPass.
     *
     * @returns
     *   Pointer to RenderPass.
     */
    const RenderPass *render_pass() const;

    /**
     * Set RenderPass.
     *
     * @param render_pass
     *   New RenderPass.
     */
    void set_render_pass(const RenderPass *render_pass);

    /**
     * Get pointer to Material.
     *
     * @returns
     *   Pointer to Material.
     */
    const Material *material() const;

    /**
     * Set Material.
     *
     * @param material
     *   New Material.
     */
    void set_material(const Material *material);

    /**
     * Get pointer to RenderEntity.
     *
     * @returns
     *   Pointer to RenderEntity.
     */
    const RenderEntity *render_entity() const;

    /**
     * Set RenderEntity.
     *
     * @param render_entity
     *   New Material.
     */
    void set_render_entity(const RenderEntity *render_entity);

    /**
     * Get pointer to Light.
     *
     * @returns
     *   Pointer to Light.
     */
    const Light *light() const;

    /**
     * Set Light.
     *
     * @param light
     *   New Light.
     */
    void set_light(const Light *light);

    /**
     * Get pointer to shadow map RenderTarget.
     *
     * @returns
     *   Pointer to shadow map RenderTarget.
     */
    const RenderTarget *shadow_map() const;

    /**
     * Set shadow map RenderTarget.
     *
     * @param light
     *   New shadow map RenderTarget.
     */
    void set_shadow_map(const RenderTarget *shadow_map);

    bool operator==(const RenderCommand &) const = default;
    bool operator!=(const RenderCommand &) const = default;

  private:
    /** Command type. */
    RenderCommandType type_;

    /** Pointer to RenderPass for command. */
    const RenderPass *render_pass_;

    /** Pointer to Material for command. */
    const Material *material_;

    /** Pointer to RenderEntity for command. */
    const RenderEntity *render_entity_;

    /** Pointer to shadow map RenderTarget for command. */
    const RenderTarget *shadow_map_;

    /** Pointer to Light for command. */
    const Light *light_;
};

}

```

`include/iris/graphics/render_command_type.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>

namespace iris
{

/**
 * Enumeration of possible render command types.
 */
enum class RenderCommandType : std::uint8_t
{
    PASS_START,
    DRAW,
    PASS_END,
    PRESENT
};

}
```

`include/iris/graphics/render_entity.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <string>
#include <string_view>

#include "graphics/mesh.h"
#include "graphics/primitive_type.h"
#include "graphics/render_entity_type.h"

namespace iris
{

/**
 * Abstract class representing a renderable entity.
 */
class RenderEntity
{
  public:
    /**
     * Construct a RenderEntity.
     *
     * @param mesh
     *   Mesh to render.
     *
     * @param primitive_type
     *   Primitive type of underlying mesh.
     */
    RenderEntity(const Mesh *mesh, PrimitiveType primitive_type = PrimitiveType::TRIANGLES);

    virtual ~RenderEntity() = default;

    RenderEntity(const RenderEntity &) = delete;
    RenderEntity &operator=(const RenderEntity &) = delete;
    RenderEntity(RenderEntity &&) = default;
    RenderEntity &operator=(RenderEntity &&) = default;

    /**
     * Get if entity will be rendered with transparency.
     *
     * @returns
     *   True if entity will have transparency, otherwise false.
     */
    virtual bool has_transparency() const = 0;

    /**
     * Get entity type.
     *
     * @returns
     *   Entity type.
     */
    virtual RenderEntityType type() const = 0;

    /**
     * Get all Mesh for this entity.
     *
     * @returns
     *   Mesh.
     */
    const Mesh *mesh() const;

    /**
     * Returns whether the object should be rendered as a wireframe.
     *
     * @returns
     *   True if should be rendered as a wireframe, false otherwise.
     */
    bool should_render_wireframe() const;

    /**
     * Sets whether the object should be rendered as a wireframe.
     *
     * @param wrireframe
     *   True if should be rendered as a wireframe, false otherwise.
     */
    void set_wireframe(const bool wireframe);

    /**
     * Get primitive type.
     *
     * @returns
     *   Primitive type.
     */
    PrimitiveType primitive_type() const;

    /**
     * Get (optional) name.
     *
     * @return
     *  Name of entity, empty string if not set.
     */
    std::string name() const;

    /**
     * Set the name of the entity.
     *
     * @param name
     *   New name.
     */
    void set_name(std::string_view name);

    /**
     * Can this entity have shadows rendered on it.
     *
     * @returns
     *   True if shadows should be rendered, false otherwise.
     */
    bool receive_shadow() const;

    /**
     * Set whether this object can have shadows rendered on it.
     *
     * @param receive_shadow
     *   New receive shadow option.
     */
    void set_receive_shadow(bool receive_shadow);

  protected:
    /** Mesh to render. */
    const Mesh *mesh_;

    /** Whether the object should be rendered as a wireframe. */
    bool wireframe_;

    /** Primitive type. */
    PrimitiveType primitive_type_;

    /** Optional name (default is empty string). */
    std::string name_;

    /** Should object render shadows. */
    bool receive_shadow_;
};

}

```

`include/iris/graphics/render_entity_type.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>

namespace iris
{

/**
 * Enumeration of possible render entity types.
 */
enum class RenderEntityType
{
    SINGLE,
    INSTANCED
};

}

```

`include/iris/graphics/render_graph/binary_operator_node.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <cstdint>

#include "graphics/render_graph/node.h"

namespace iris
{

class ShaderCompiler;

enum class BinaryOperator : std::uint8_t
{
    ADD,
    SUBTRACT,
    MULTIPLY,
    DIVIDE,
    DOT,
    CROSS,
    DISTANCE
};

/**
 * Implementation of Node which performs an BinaryOperator on two input
 * Nodes.
 *
 * The hierarchy of binary nodes can be used to set operator precedence,
 * for example:
 *
 *  ValueNode(3) ------\
 *                      BinaryOperatorNode(+) ------\
 *  ValueNode(4) ------/                         \
 *                                                ArithmeticNode(/)
 *  ValueNode(5) ------\                         /
 *                      BinaryOperatorNode(+) ------/
 *  ValueNode(6) ------/
 *
 * Will evaluate to ((3 + 4) / (5 + 6))
 */
class BinaryOperatorNode : public Node
{
  public:
    /**
     * Create a new BinaryOperatorNode.
     *
     * @param value1
     *   First input value.
     *
     * @param value2
     *   Second input value.
     *
     * @param binary_operator
     *   Operator to apply to value1 and value2.
     */
    BinaryOperatorNode(Node *value1, Node *value2, BinaryOperator binary_operator);

    ~BinaryOperatorNode() override = default;

    /**
     * Accept a compiler visitor.
     *
     * @param compiler
     *   Compiler to accept.
     */
    void accept(ShaderCompiler &compiler) const override;

    /**
     * Get value1.
     *
     * @returns
     *   value1.
     */
    Node *value1() const;

    /**
     * Get value2.
     *
     * @returns
     *   value2.
     */
    Node *value2() const;

    /**
     * Get binary operator.
     *
     * @returns
     *   Binary operator.
     */
    BinaryOperator binary_operator() const;

    /**
     * Compute hash of node.
     *
     * @return
     *   Hash of node.
     */
    std::size_t hash() const override;

  private:
    /** First value. */
    Node *value1_;

    /** Second value. */
    Node *value2_;

    /** Binary operator applied to value1 and value2. */
    BinaryOperator binary_operator_;
};
}

```

`include/iris/graphics/render_graph/blur_node.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <memory>

#include "graphics/render_graph/node.h"
#include "graphics/render_graph/texture_node.h"

namespace iris
{
class ShaderCompiler;

/**
 * Implementation of Node that performs a basic blur on an input texture.
 */
class BlurNode : public Node
{
  public:
    /**
     * Create a new BlurNode
     *
     * @param input_node
     *   Texture to blur.
     */
    BlurNode(TextureNode *input_node);

    ~BlurNode() override = default;

    /**
     * Accept a compiler visitor.
     *
     * @param compiler
     *   Compiler to accept.
     */
    void accept(ShaderCompiler &compiler) const override;

    /**
     * Get input texture.
     *
     * @returns
     *   Input texture.
     */
    TextureNode *input_node() const;

    /**
     * Compute hash of node.
     *
     * @return
     *   Hash of node.
     */
    std::size_t hash() const override;

  private:
    /** Input texture. */
    TextureNode *input_node_;
};
}

```

`include/iris/graphics/render_graph/camera_node.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <cstdint>
#include <optional>
#include <string>
#include <string_view>

#include "graphics/render_graph/node.h"

namespace iris
{

class ShaderCompiler;

/**
 * Enumeration of types of camera data that can be used.
 */
enum class CameraDataType : std::uint8_t
{
    POSITION,
};

/**
 * Implementation of Node for getting camera data.
 */
class CameraNode : public Node
{
  public:
    /**
     * Construct a new CameraNode
     *
     * @param camera_data_type
     *   The type of camera data to get.
     */
    CameraNode(CameraDataType camera_data_type);

    /**
     * Construct a new CameraNode
     *
     * @param camera_data_type
     *   The type of camera data to get.
     *
     * @param swizzle
     *   A swizzle to apply to the camera data.
     */
    CameraNode(CameraDataType camera_data_type, std::string_view swizzle);

    /**
     * Accept a compiler visitor.
     *
     * @param compiler
     *   Compiler to accept.
     */
    void accept(ShaderCompiler &compiler) const override;

    /**
     */
    CameraDataType camera_data_type() const;

    /**
     * Get swizzle.
     *
     * @return
     *   Swizzle, of one was set.
     */
    std::optional<std::string> swizzle() const;

    /**
     * Compute hash of node.
     *
     * @return
     *   Hash of node.
     */
    std::size_t hash() const override;

  private:
    /** Type of camera data to get. */
    CameraDataType camera_data_type_;

    /** Optional swizzle. */
    std::optional<std::string> swizzle_;
};

}

```

`include/iris/graphics/render_graph/colour_node.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>

#include "core/colour.h"
#include "graphics/render_graph/node.h"

namespace iris
{
class ShaderCompiler;

/**
 * Implementation of Node which represents a colour.
 */
class ColourNode : public Node
{
  public:
    /**
     * Create a new ColourNode.
     *
     * @param colour
     *   The colour to represent.
     */
    ColourNode(const Colour &colour);

    ~ColourNode() override = default;

    /**
     * Accept a compiler visitor.
     *
     * @param compiler
     *   Compiler to accept.
     */
    void accept(ShaderCompiler &compiler) const override;

    /**
     * Get colour.
     *
     * @returns
     *   Colour.
     */
    Colour colour() const;

    /**
     * Compute hash of node.
     *
     * @return
     *   Hash of node.
     */
    std::size_t hash() const override;

  private:
    /** Colour. */
    Colour colour_;
};
}

```

`include/iris/graphics/render_graph/combine_node.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <memory>

#include "graphics/render_graph/node.h"

namespace iris
{
class ShaderCompiler;

/**
 * Implementation of Node which takes four inputs to create a single
 * 4-dimensional value.
 */
class CombineNode : public Node
{
  public:
    /**
     * Create a new CombineNode.
     *
     * @param value1
     *   First value.
     *
     * @param value2
     *   Second value.
     *
     * @param value3
     *   Third value.
     *
     * @param value4
     *   Fourth value.
     */
    CombineNode(Node *value1, Node *value2, Node *value3, Node *value4);

    ~CombineNode() override = default;

    /**
     * Accept a compiler visitor.
     *
     * @param compiler
     *   Compiler to accept.
     */
    void accept(ShaderCompiler &compiler) const override;

    /**
     * Get first value.
     *
     * @returns
     *   First value.
     */
    Node *value1() const;

    /**
     * Get second value.
     *
     * @returns
     *   Second value.
     */
    Node *value2() const;

    /**
     * Get third value.
     *
     * @returns
     *   Third value.
     */
    Node *value3() const;

    /**
     * Get fourth value.
     *
     * @returns
     *   Fourth value.
     */
    Node *value4() const;

    /**
     * Compute hash of node.
     *
     * @return
     *   Hash of node.
     */
    std::size_t hash() const override;

  private:
    /** First value. */
    Node *value1_;

    /** Second value. */
    Node *value2_;

    /** Third value. */
    Node *value3_;

    /** Fourth value. */
    Node *value4_;
};
}

```

`include/iris/graphics/render_graph/component_node.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <memory>
#include <string>

#include "graphics/render_graph/node.h"

namespace iris
{
class ShaderCompiler;

/**
 * Implementation of Node for extracting components from an input_node.
 */
class ComponentNode : public Node
{
  public:
    /**
     * Create a new ComponentNode.
     *
     * @param input_node
     *   Node to get component from.
     *
     * @param component
     *   String representation of components, supports swizzling e.g. "x", "xy",
     *   "rgb".
     */
    ComponentNode(Node *input_node, const std::string &component);

    ~ComponentNode() override = default;

    /**
     * Accept a compiler visitor.
     *
     * @param compiler
     *   Compiler to accept.
     */
    void accept(ShaderCompiler &compiler) const override;

    /**
     * Get input_node node.
     *
     * @returns
     *   Input node.
     */
    Node *input_node() const;

    /**
     * Get component string.
     *
     * @returns
     *   Component string.
     */
    std::string component() const;

    /**
     * Compute hash of node.
     *
     * @return
     *   Hash of node.
     */
    std::size_t hash() const override;

  private:
    /** Input node. */
    Node *input_node_;

    /** Component string. */
    std::string component_;
};
}

```

`include/iris/graphics/render_graph/composite_node.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <memory>

#include "core/vector3.h"
#include "graphics/render_graph/node.h"

namespace iris
{
class ShaderCompiler;

/**
 * Implementation of Node that composites two other nodes together. For each
 * fragment colour1 or colour2 is picked based upon which has the closest depth
 * value.
 */
class CompositeNode : public Node
{
  public:
    /**
     * Create a new CompositeNode.
     *
     * @param colour1
     *   First colour node.
     *
     * @param colour2
     *   Second colour node.
     *
     * @param depth1
     *   Depth values for colour1.
     *
     * @param depth2
     *   Depth values for colour2.
     */
    CompositeNode(Node *colour1, Node *colour2, Node *depth1, Node *depth2);

    ~CompositeNode() override = default;

    /**
     * Accept a compiler visitor.
     *
     * @param compiler
     *   Compiler to accept.
     */
    void accept(ShaderCompiler &compiler) const override;

    /**
     * Get first colour.
     *
     * @returns
     *   First colour.
     */
    Node *colour1() const;

    /**
     * Get second colour.
     *
     * @returns
     *   Second colour.
     */
    Node *colour2() const;

    /**
     * Get first depth.
     *
     * @returns
     *   First depth.
     */
    Node *depth1() const;

    /**
     * Get second depth.
     *
     * @returns
     *   Second depth.
     */
    Node *depth2() const;

    /**
     * Compute hash of node.
     *
     * @return
     *   Hash of node.
     */
    std::size_t hash() const override;

  private:
    /** First colour. */
    Node *colour1_;

    /** Second colour. */
    Node *colour2_;

    /** First depth. */
    Node *depth1_;

    /** Second depth. */
    Node *depth2_;
};
}

```

`include/iris/graphics/render_graph/conditional_node.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <cstdint>

#include "graphics/render_graph/node.h"

namespace iris
{

class ShaderCompiler;

enum class ConditionalOperator : std::uint8_t
{
    GREATER,
    LESS,
};

/**
 * Implementation of Node which performs a conditional operation on two inputs
 * and selects one of two outputs based on the result.
 *
 * This can be summarised as:
 *  (input1 ConditionalOperator input2) ? output1 : output2
 */
class ConditionalNode : public Node
{
  public:
    /**
     * Create a new ConditionalNode.
     *
     * @param input_value1
     *   First input value (left side of operator).
     *
     * @param input_value2
     *   Second input value (right side of operator).
     *
     * @param output_value1
     *   First output value (if conditional is true).
     *
     * @param output_value2
     *   Second output value (if conditional is false).
     *
     * @param conditional_operator
     *   Conditional operator to use with inputs.
     */
    ConditionalNode(
        Node *input_value1,
        Node *input_value2,
        Node *output_value1,
        Node *output_value2,
        ConditionalOperator conditional_operator);

    ~ConditionalNode() override = default;

    /**
     * Accept a compiler visitor.
     *
     * @param compiler
     *   Compiler to accept.
     */
    void accept(ShaderCompiler &compiler) const override;

    /**
     * Get input_value1.
     *
     * @returns
     *   input_value1.
     */
    Node *input_value1() const;

    /**
     * Get input_value2.
     *
     * @returns
     *   input_value2.
     */
    Node *input_value2() const;

    /**
     * Get output_value1.
     *
     * @returns
     *   output_value1.
     */
    Node *output_value1() const;

    /**
     * Get output_value2.
     *
     * @returns
     *   output_value2.
     */
    Node *output_value2() const;

    /**
     * Get conditional operator.
     *
     * @returns
     *   Conditional operator.
     */
    ConditionalOperator conditional_operator() const;

    /**
     * Compute hash of node.
     *
     * @return
     *   Hash of node.
     */
    std::size_t hash() const override;

  private:
    /** First input value. */
    Node *input_value1_;

    /** Second input value. */
    Node *input_value2_;

    /** First output value. */
    Node *output_value1_;

    /** Second output value. */
    Node *output_value2_;

    /** Conditional operator to use with inputs. */
    ConditionalOperator conditional_operator_;
};
}

```

`include/iris/graphics/render_graph/fragment_node.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <cstdint>
#include <optional>
#include <string>
#include <string_view>

#include "graphics/render_graph/node.h"

namespace iris
{

class ShaderCompiler;

/**
 * Enumeration of types of fragment data that can be used.
 */
enum class FragmentDataType : std::uint8_t
{
    POSITION,
    VIEW_POSITION,
    FRAGMENT_POSITION,
    TEX_COORD,
    NORMAL
};

/**
 * Implementation of Node for getting fragment data.
 */
class FragmentNode : public Node
{
  public:
    /**
     * Construct a new FragmentNode
     *
     * @param fragment_data_type
     *   The type of fragment data to get.
     */
    FragmentNode(FragmentDataType fragment_data_type);

    /**
     * Construct a new FragmentNode
     *
     * @param fragment_data_type
     *   The type of fragment data to get.
     *
     * @param swizzle
     *   A swizzle to apply to the fragment data.
     */
    FragmentNode(FragmentDataType fragment_data_type, std::string_view swizzle);

    ~FragmentNode() override = default;

    /**
     * Accept a compiler visitor.
     *
     * @param compiler
     *   Compiler to accept.
     */
    void accept(ShaderCompiler &compiler) const override;

    /**
     */
    FragmentDataType fragment_data_type() const;

    /**
     * Get swizzle.
     *
     * @return
     *   Swizzle, if one was set.
     */
    std::optional<std::string> swizzle() const;

    /**
     * Compute hash of node.
     *
     * @return
     *   Hash of node.
     */
    std::size_t hash() const override;

  private:
    /** Type of fragment data to get. */
    FragmentDataType fragment_data_type_;

    /** Optional swizzle. */
    std::optional<std::string> swizzle_;
};

}

```

`include/iris/graphics/render_graph/invert_node.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <memory>

#include "graphics/render_graph/node.h"

namespace iris
{
class ShaderCompiler;

/**
 * Implementation of Node which inverts the input nodes colour.
 */
class InvertNode : public Node
{
  public:
    /**
     * Create a new InvertNode.
     *
     * @param input_node
     *   Node to invert.
     */
    InvertNode(Node *input_node);

    ~InvertNode() override = default;

    /**
     * Accept a compiler visitor.
     *
     * @param compiler
     *   Compiler to accept.
     */
    void accept(ShaderCompiler &compiler) const override;

    /**
     * Get input node.
     *
     * @returns
     *   Input node.
     */
    Node *input_node() const;

    /**
     * Compute hash of node.
     *
     * @return
     *   Hash of node.
     */
    std::size_t hash() const override;

  private:
    /** Input node. */
    Node *input_node_;
};
}

```

`include/iris/graphics/render_graph/lerp_node.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <cstdint>

#include "graphics/render_graph/node.h"

namespace iris
{

class ShaderCompiler;

/**
 * Implementation of Node for lerpinng - linear interpolating between two values.
 */
class LerpNode : public Node
{
  public:
    /**
     * Create a new LerpNode.
     *
     * @param input_value1
     *   First input value (left side of operator).
     *
     * @param input_value2
     *   Second input value (right side of operator).
     *
     * @param lerp_amount
     *   The amount to interpolate. Should evaluate to a float in the range [0.0, 1.0]
     */
    LerpNode(Node *input_value1, Node *input_value2, Node *lerp_amount);

    /**
     * Accept a compiler visitor.
     *
     * @param compiler
     *   Compiler to accept.
     */
    void accept(ShaderCompiler &compiler) const override;

    /**
     * Get input_value1.
     *
     * @returns
     *   input_value1.
     */
    Node *input_value1() const;

    /**
     * Get input_value2.
     *
     * @returns
     *   input_value2.
     */
    Node *input_value2() const;

    /**
     * Get lerp amount node.
     *
     * @returns
     *   Lerp amount node.
     */
    Node *lerp_amount() const;

    /**
     * Compute hash of node.
     *
     * @return
     *   Hash of node.
     */
    std::size_t hash() const override;

  private:
    /** First input value. */
    Node *input_value1_;

    /** Second input value. */
    Node *input_value2_;

    /** Lerp amount node. */
    Node *lerp_amount_;
};
}

```

`include/iris/graphics/render_graph/node.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <functional>

namespace iris
{

// forward declaration
class ShaderCompiler;

/**
 * This is an interface for Node, which forms part of a render graph. Node
 * implementations can be connected together to describe what a shader should
 * do.
 */
class Node
{
  public:
    virtual ~Node() = default;

    /**
     * Accept a compiler visitor.
     *
     * @param compiler
     *   Compiler to accept.
     */
    virtual void accept(ShaderCompiler &compiler) const = 0;

    /**
     * Compute hash of node. Implementations should combine hashes of any child nodes.
     *
     * @return
     *   Hash of node.
     */
    virtual std::size_t hash() const = 0;
};
}

// specialise std::hash for node pointer
namespace std
{

template <>
struct hash<iris::Node *>
{
    size_t operator()(const iris::Node *node) const
    {
        return node == nullptr ? std::hash<nullptr_t>{}(nullptr) : node->hash();
    }
};

}

```

`include/iris/graphics/render_graph/post_processing/ambient_occlusion_node.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <cstdint>

#include "graphics/post_processing_description.h"
#include "graphics/render_graph/render_node.h"
#include "graphics/render_graph/texture_node.h"

namespace iris
{

class ShaderCompiler;

/**
 * Implementation of Node which applies Screen Space Ambient Occlusion (SSAO) to the final output of a render pass.
 *
 * Note that internally this well be converted to a pre-processing step which calculates the occlusion, this will then
 * be integrated into the ambient lighting pass. For simplicity it is presented to the user as a post processing step.
 *
 */
class AmbientOcclusionNode : public RenderNode
{
  public:
    /**
     * Create a new AmbientOcclusionNode.
     *
     * @param input
     *   Colour input for RenderNode.
     *
     * @param normal_texture
     *   Texture containing screen space normals.
     *
     * @param position_texture
     *   Texture containing screen space positions.
     *
     * @param description
     *   User settings for effect.
     */
    AmbientOcclusionNode(
        TextureNode *input,
        TextureNode *normal_texture,
        TextureNode *position_texture,
        AmbientOcclusionDescription description);

    ~AmbientOcclusionNode() override = default;

    /**
     * Accept a compiler visitor.
     *
     * @param compiler
     *   Compiler to accept.
     */
    void accept(ShaderCompiler &compiler) const override;

    /**
     * Get screen space normals texture.
     *
     * @returns
     *   Texture containing screen space normals.
     */
    TextureNode *normal_texture() const;

    /**
     * Get screen space positions texture.
     *
     * @returns
     *   Texture containing screen space positions.
     */
    TextureNode *position_texture() const;

    /**
     * Get description of effect.
     *
     * @returns
     *   User settings for effect.
     */
    AmbientOcclusionDescription description() const;

    /**
     * Compute hash of node.
     *
     * @return
     *   Hash of node.
     */
    std::size_t hash() const override;

  private:
    /** Texture containing screen space normals. */
    TextureNode *normal_texture_;

    /** Texture containing screen space positions. */
    TextureNode *position_texture_;

    /** User settings for effect. */
    AmbientOcclusionDescription description_;
};

}

```

`include/iris/graphics/render_graph/post_processing/anti_aliasing_node.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>

#include "graphics/render_graph/render_node.h"
#include "graphics/render_graph/texture_node.h"

namespace iris
{

class ShaderCompiler;

/**
 * Implementation of Node which applies Fast Approximate Anti Aliasing (FXAA) to the final output of a render pass.
 */
class AntiAliasingNode : public RenderNode
{
  public:
    /**
     * Create a new AntiAliasingNode.
     *
     * @param input
     *   Colour input for RenderNode.
     */
    AntiAliasingNode(TextureNode *input);

    ~AntiAliasingNode() override = default;

    /**
     * Accept a compiler visitor.
     *
     * @param compiler
     *   Compiler to accept.
     */
    void accept(ShaderCompiler &compiler) const override;

    /**
     * Compute hash of node.
     *
     * @return
     *   Hash of node.
     */
    std::size_t hash() const override;
};

}

```

`include/iris/graphics/render_graph/post_processing/colour_adjust_node.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>

#include "graphics/post_processing_description.h"
#include "graphics/render_graph/render_node.h"
#include "graphics/render_graph/texture_node.h"

namespace iris
{

class ShaderCompiler;

/**
 * Implementation of Node which performs various colour adjustments to the final output of a render pass.
 *
 * See ColourAdjustDescription for possible adjustment options.
 */
class ColourAdjustNode : public RenderNode
{
  public:
    /**
     * Create a new ColourAdjustNode.
     *
     * @param input
     *   Colour input for RenderNode.
     *
     * @param description
     *   User settings for effect.
     */
    ColourAdjustNode(TextureNode *input, ColourAdjustDescription description);

    ~ColourAdjustNode() override = default;

    /**
     * Get description of effect.
     *
     * @returns
     *   User settings for effect.
     */
    ColourAdjustDescription description() const;

    /**
     * Accept a compiler visitor.
     *
     * @param compiler
     *   Compiler to accept.
     */
    void accept(ShaderCompiler &compiler) const override;

    /**
     * Compute hash of node.
     *
     * @return
     *   Hash of node.
     */
    std::size_t hash() const override;

  private:
    /** User settings for effect. */
    ColourAdjustDescription description_;
};

}

```

`include/iris/graphics/render_graph/property.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <array>
#include <cstddef>
#include <string>

namespace iris
{

/**
 * Enumeration of possible property types.
 */
enum class PropertyType
{
    FLOAT
};

/**
 * This class represents the cpu side of a property.
 *
 * It has a very restricted API (see PropertyWriter for public usage) but internally it has a pointer to a buffer it
 * can write property values to, the engine will then ensure it gets copied to the cpu.
 */
class Property
{
  public:
    ~Property();

    /**
     * Get property name.
     *
     * @returns
     *   User name of property.
     */
    std::string name() const;

    /**
     * Get type of property.
     *
     * @returns
     *   Property type.
     */
    PropertyType type() const;

  private:
    // we use friend classes to lock down the API and hand out access to various other classes
    template <class>
    friend class PropertyWriter;           // for writing
    friend class std::allocator<Property>; // for storing
    friend class RenderGraph;              // for creation

    /**
     * Construct a new Property storing a float.
     *
     * @param name
     *    User name of property.
     *
     * @param buffer
     *   Pointer to memory to write value to.
     *
     * @param value
     *   Initial value of property.
     */
    Property(const std::string &name, std::byte *buffer, float value);

    /**
     * Set the float value of the property.
     *
     * It is undefined to call this of the object was created with the float constructor, although the restricted API
     * should make that hard to do.
     *
     * @param value
     *   New value.
     */
    void set_value(float value);

    /** User name of parameter. */
    std::string name_;

    /** Parameter type. */
    PropertyType type_;

    /** Pointer to write values to. */
    std::byte *buffer_;
};

}

```

`include/iris/graphics/render_graph/property_node.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <string>

#include "graphics/render_graph/node.h"

namespace iris
{

class ShaderCompiler;

/**
 * Implementation of Node for getting a property value. A property is a runtime configurable variable in a shader.
 */
class PropertyNode : public Node
{
  public:
    /**
     * Create a new PropertyNode.
     *
     * @param name
     *   User name of the property.
     */
    PropertyNode(const std::string &name);

    /**
     * Accept a compiler visitor.
     *
     * @param compiler
     *   Compiler to accept.
     */
    void accept(ShaderCompiler &compiler) const override;

    /**
     * Get property name.
     *
     * @returns
     *   User name of property.
     */
    std::string name() const;

    /**
     * Compute hash of node.
     *
     * @return
     *   Hash of node.
     */
    std::size_t hash() const override;

  private:
    /** User name of property. */
    std::string name_;
};

}

```

`include/iris/graphics/render_graph/property_writer.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include "core/error_handling.h"
#include "graphics/render_graph/property.h"

namespace iris
{

/**
 * This class is used to write to Property objects. It's templated to restrict what types can be written, so for example
 * only floats can be written to a float property.
 */
template <class T>
class PropertyWriter
{
  public:
    /**
     * Construct a new PropertyWriter.
     */
    PropertyWriter()
        : property_(nullptr)
    {
    }

    /**
     * Set the value of the property.
     *
     * @param value
     *   New value.
     */
    void set_value(const T &value)
    {
        expect(property_ != nullptr, "no property set");
        property_->set_value(value);
    }

  private:
    friend class RenderGraph;

    /**
     * Construct a new PropertyWriter with a Property.
     *
     * @param property
     *   Property to write to.
     */
    PropertyWriter(Property *property)
        : property_(property)
    {
    }

    /** Property to write to. */
    Property *property_;
};

}

```

`include/iris/graphics/render_graph/render_graph.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <array>
#include <cstddef>
#include <deque>
#include <functional>
#include <memory>
#include <span>
#include <string>
#include <type_traits>
#include <vector>

#include "core/error_handling.h"
#include "graphics/render_graph/node.h"
#include "graphics/render_graph/property.h"
#include "graphics/render_graph/property_writer.h"
#include "graphics/render_graph/render_node.h"

namespace iris
{

template <class T>
concept IsNode = std::is_base_of_v<Node, T> && !std::is_same_v<RenderNode, T>;

/**
 * Enumeration of possible variable types.
 */
enum class VariableNodeType
{
    FLOAT,
    VEC3,
    VEC4
};

/**
 * Struct encapsulating all the data needed for a variable.
 */
struct RenderGraphVariable
{
    /** User name of variable. */
    std::string name;

    /** Type of variable. */
    VariableNodeType type;

    /** Node which when parsed will create the value for the variable. */
    Node *value;

    /** Whether this is declaring and setting (true) or just setting (false) a variable. */
    bool is_declaration;
};

/**
 * This class encapsulates a render graph - a series of connected nodes that
 * can be compiled into API specific shaders.
 *
 * This class automatically creates and manages a RenderNode.
 */
class RenderGraph
{
  public:
    /**
     * Get the RenderNode i.e. the root of the graph.
     *
     * @returns
     *   Render node.
     */
    RenderNode *render_node() const;

    /**
     * Create a Node and add it to the graph. Uses perfect forwarding to pass
     * along arguments.
     *
     * @param args
     *   Arguments for Node.
     *
     * @returns
     *   A pointer to the newly created Node.
     */
    template <IsNode T, class... Args>
    T *create(Args &&...args)
    {
        auto node = std::make_unique<T>(std::forward<Args>(args)...);
        return static_cast<T *>(add(std::move(node)));
    }

    /**
     * Create a new variable. This will be available to both vertex and fragment shaders, but will only be included if
     * it is actually used.
     *
     * @param name
     *   User name of variable.
     *
     * @param type
     *   Type of variable
     *
     * @param is_declaration
     *   Whether this is declaring and setting (true) or just setting (false) a variable.
     *
     * @param args
     *   Pack of arguments used to construct node of type T.
     */
    template <IsNode T, class... Args>
    void create_variable(const std::string &name, VariableNodeType type, bool is_declaration, Args &&...args)
    {
        auto *node = create<T>(std::forward<Args>(args)...);
        variables_.push_back({.name = name, .type = type, .value = node, .is_declaration = is_declaration});
    }

    /**
     * Create a new property.
     *
     * @param name
     *   User name of property.
     *
     * @param value
     *   Initial value.
     *
     * @returns
     *   A PropertyWriter which can be used to update the property value.
     */
    template <class T>
    PropertyWriter<T> create_property(const std::string &name, const T &value)
    {
        expect(property_buffer_.size_bytes() >= offset_ + sizeof(T), "not enough space in property buffer");

        properties_.push_back({name, property_buffer_.data() + offset_, value});
        offset_ += sizeof(T);

        return PropertyWriter<T>{std::addressof(properties_.back())};
    }

    /**
     * Set the render node.
     *
     * @param args
     *   Arguments for Node.
     *
     * @returns
     *   A pointer to the newly created Node.
     */
    template <IsNode T, class... Args>
    RenderNode *set_render_node(Args &&...args)
    {
        nodes_[0] = std::make_unique<T>(std::forward<Args>(args)...);
        return render_node();
    }

    /**
     * Add a Node to the graph.
     *
     * @param node
     *   Node to add.
     *
     * @returns
     *   Pointer to the added node.
     */
    Node *add(std::unique_ptr<Node> node);

    /**
     * Get all variables.
     *
     * @returns
     *   Collection of variables.
     */
    std::vector<RenderGraphVariable> variables() const;

    /**
     * Get a const reference to all properties.
     *
     * @returns
     *   Const reference to property collection.
     */
    const std::deque<Property> &properties() const;

    /**
     * Get property buffer.
     *
     * @returns
     *   Property buffer.
     */
    std::span<std::byte> property_buffer() const;

  private:
    // friend to allow only the RenderPipeline to create
    friend class RenderPipeline;

    /**
     * Create a new RenderGraph.
     *
     * @param property_buffer
     *   Property buffer for graph.
     */
    RenderGraph(std::span<std::byte> property_buffer);

    /** Collection of nodes in graph. */
    std::vector<std::unique_ptr<Node>> nodes_;

    /** Collection of variables. */
    std::vector<RenderGraphVariable> variables_;

    /** Collection of properties. */
    std::deque<Property> properties_;

    /** Span of property buffer. */
    std::span<std::byte> property_buffer_;

    /** Write offset into property buffer. */
    std::size_t offset_;
};

}

// specialise std::hash for RenderGraph pointer
namespace std
{

template <>
struct hash<iris::RenderGraph *>
{
    size_t operator()(const iris::RenderGraph *rg) const
    {
        return std::hash<iris::Node *>{}(rg->render_node());
    }
};

}

```

`include/iris/graphics/render_graph/render_node.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <memory>
#include <string>
#include <unordered_map>
#include <vector>

#include "graphics/render_graph/node.h"

namespace iris
{

class ShaderCompiler;

/**
 * A RenderNode is an implementation of Node which represents the final node in
 * a render graph. Whilst it is the final node it is effectively the root of the
 * DAG and the whole graph can be traversed top-down from here. Only one should
 * be in each render_graph.
 */
class RenderNode : public Node
{
  public:
    /**
     * Construct a new RenderNode. All input nodes are initialised to nullptr,
     * which tells the compiler to default to values in the vertex data.
     */
    RenderNode();

    ~RenderNode() override = default;

    /**
     * Accept a compiler visitor.
     *
     * @param compiler
     *   Compiler to accept.
     */
    void accept(ShaderCompiler &compiler) const override;

    /**
     * Get colour input.
     *
     * @returns
     *   Colour input.
     */
    Node *colour_input() const;

    /**
     * Set colour input.
     *
     * @param input
     *   New input.
     */
    void set_colour_input(Node *input);

    /**
     * Set specular power input i.e. how shiny an object is.
     *
     * @returns
     *   Specular power input.
     */
    Node *specular_power_input() const;

    /**
     * Set specular power input.
     *
     * @param input
     *   New input.
     */
    void set_specular_power_input(Node *input);

    /**
     * Set specular amount input i.e. a scale from [0, 1] how much to apply the
     * specular power. Useful for specular maps or to disable specular.
     *
     * @returns
     *   Specular amount input.
     */
    Node *specular_amount_input() const;

    /**
     * Set specular amount input.
     *
     * @param input
     *   New input.
     */
    void set_specular_amount_input(Node *input);

    /**
     * Get vertex normal input.
     *
     * @returns
     *   Normal input.
     */
    Node *vertex_normal_input() const;

    /**
     * Set vertex normal input.
     *
     * @param input
     *   New input.
     */
    void set_vertex_normal_input(Node *input);

    /**
     * Get fragment normal input.
     *
     * @returns
     *   Normal input.
     */
    Node *fragment_normal_input() const;

    /**
     * Set fragment normal input.
     *
     * @param input
     *   New input.
     */
    void set_fragment_normal_input(Node *input);

    /**
     * Get vertex position input.
     *
     * @returns
     *   Colour input.
     */
    Node *position_input() const;

    /**
     * Set vertex position input.
     *
     * @param input
     *   New input.
     */
    void set_position_input(Node *input);

    /**
     * Get the shadow map input node at a specified index.
     *
     * @param index
     *   Index of shadow map input.
     *
     * @returns
     *   Shadow map node at index if one exists, otherwise nullptr.
     */
    Node *shadow_map_input() const;

    /**
     * Add a new shadow map node.
     *
     * @param input
     *   Shadow map input node.
     */
    void set_shadow_map_input(Node *input);

    /**
     * Get ambient occlusion input.
     *
     * @returns
     *   Ambient occlusion input.
     */
    Node *ambient_occlusion_input() const;

    /**
     * Set ambient occlusion input.
     *
     * @param input
     *   New input.
     */
    void set_ambient_occlusion_input(Node *input);

    /**
     * Is this render node a depth only render.
     *
     * @returns
     *   True if depth only render, otherwise false.
     */
    bool is_depth_only() const;

    /**
     * Set if this node is for a depth only render.
     *
     * @param depth_only
     *   New depth only value.
     */
    void set_depth_only(bool depth_only);

    /**
     * Compute hash of node.
     *
     * @return
     *   Hash of node.
     */
    std::size_t hash() const override;

  protected:
    /** Colour input. */
    Node *colour_input_;

    /** Specular power input. */
    Node *specular_power_input_;

    /** Specular amount input. */
    Node *specular_amount_input_;

    /** Vertex normal input. */
    Node *vertex_normal_input_;

    /** Fragment normal input. */
    Node *fragment_normal_input_;

    /** Vertex position input. */
    Node *position_input_;

    /** Collection of shadow map inputs. */
    Node *shadow_map_input_;

    /** Ambient occlusion input. */
    Node *ambient_occlusion_input_;

    /** Is depth only render. */
    bool depth_only_;
};

}

```

`include/iris/graphics/render_graph/shader_compiler.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <memory>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <vector>

#include "core/colour.h"
#include "core/vector3.h"
#include "graphics/default_shader_languages.h"
#include "graphics/lights/light_type.h"
#include "graphics/render_graph/render_graph.h"

namespace inja
{
class Environment;
}

namespace iris
{

class RenderNode;
class SkyBoxNode;
class ColourNode;
class TextureNode;
class InvertNode;
class BlurNode;
class CompositeNode;
class BinaryOperatorNode;
class ConditionalNode;
class ComponentNode;
class CombineNode;
class UnaryOperatorNode;
template <typename>
class ValueNode;
class VertexNode;
class AmbientOcclusionNode;
class ColourAdjustNode;
class AntiAliasingNode;
class TimeNode;
class VariableNode;
class LerpNode;
class PropertyNode;
class FragmentNode;
class CameraNode;

/**
 * Interface for a class that compiles a RenderGraph into API specific shaders.
 * This treats the RenderGraph as an AST and parses it top-down.
 */
class ShaderCompiler
{
  public:
    ShaderCompiler(
        ShaderLanguage language,
        const RenderGraph *render_graph,
        LightType light_type,
        bool render_to_normal_target,
        bool render_to_position_target);

    ~ShaderCompiler();

    // visitor methods
    void visit(const RenderNode &node);
    void visit(const SkyBoxNode &node);
    void visit(const ColourNode &node);
    void visit(const TextureNode &node);
    void visit(const InvertNode &node);
    void visit(const BlurNode &node);
    void visit(const CompositeNode &node);
    void visit(const ValueNode<float> &node);
    void visit(const ValueNode<Vector3> &node);
    void visit(const ValueNode<Colour> &node);
    void visit(const BinaryOperatorNode &node);
    void visit(const ConditionalNode &node);
    void visit(const ComponentNode &node);
    void visit(const CombineNode &node);
    void visit(const UnaryOperatorNode &node);
    void visit(const VertexNode &node);
    void visit(const AmbientOcclusionNode &node);
    void visit(const ColourAdjustNode &node);
    void visit(const AntiAliasingNode &node);
    void visit(const TimeNode &node);
    void visit(const VariableNode &node);
    void visit(const LerpNode &node);
    void visit(const PropertyNode &node);
    void visit(const FragmentNode &node);
    void visit(const CameraNode &node);

    /**
     * Get the compiled vertex shader.
     *
     * Compiled here means from the render graph to a string, not to an API
     * specific object on the hardware.
     *
     * @returns
     *   Vertex shader.
     */
    std::string vertex_shader() const;

    /**
     * Get the compiled fragment shader.
     *
     * Compiled here means from the render graph to a string, not to an API
     * specific object on the hardware.
     *
     * @returns
     *   Fragment shader.
     */
    std::string fragment_shader() const;

  private:
    /**
     * Internal struct for variable bookkeeping.
     */
    struct Variable
    {
        /** Name of variable. */
        std::string name;

        /** Resolved variable value. */
        std::string value;

        /** Count of times variable is used in the vertex shader. */
        std::uint32_t vertex_count = 0u;

        /** Count of times variable is used in the fragment shader. */
        std::uint32_t fragment_count = 0u;
    };

    ShaderLanguage language_;

    /** Stream for vertex shader. */
    std::stringstream vertex_stream_;

    /** Stream for fragment shader. */
    std::stringstream fragment_stream_;

    /** Collection of fragment functions. */
    std::set<std::string> fragment_functions_;

    /** Type of light to render with. */
    LightType light_type_;

    /** Flag indicating whether the shader should also write out screen space normals to a render texture. */
    bool render_to_normal_target_;

    /** Flag indicating whether the shader should also write out screen space positions to a render texture. */
    bool render_to_position_target_;

    /** Stack of streams to be used the render graph is traversed. */
    std::stack<std::stringstream> stream_stack_;

    bool is_vertex_shader_;

    /** Collection of variable states. */
    std::vector<Variable> variables_;

    /** inja library environemnt. */
    std::unique_ptr<inja::Environment> env_;

    /** Render graph being compiled. */
    const RenderGraph *render_graph_;
};
}
```

`include/iris/graphics/render_graph/sky_box_node.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>

#include "graphics/cube_map.h"
#include "graphics/render_graph/render_node.h"

namespace iris
{

class ShaderCompiler;

class SkyBoxNode : public RenderNode
{
  public:
    /**
     * Implementation of RenderNode which renders a sky box.
     *
     * @param sky_box
     *   CubeMap to use for sky box.
     */
    SkyBoxNode(const CubeMap *sky_box);

    ~SkyBoxNode() override = default;

    /**
     * Accept a compiler visitor.
     *
     * @param compiler
     *   Compiler to accept.
     */
    void accept(ShaderCompiler &compiler) const override;

    /**
     * Get sky box.
     *
     * @returns
     *   Cube map for sky box.
     */
    const CubeMap *sky_box() const;

    /**
     * Compute hash of node.
     *
     * @return
     *   Hash of node.
     */
    std::size_t hash() const override;

  private:
    /** Cube map for sky box. */
    const CubeMap *sky_box_;
};

}

```

`include/iris/graphics/render_graph/texture_node.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>

#include "core/vector3.h"
#include "graphics/render_graph/node.h"
#include "graphics/sampler.h"
#include "graphics/texture.h"
#include "graphics/texture_usage.h"

namespace iris
{

class ShaderCompiler;

/**
 * Enumeration of possible sources of UV data.
 */
enum class UVSource
{
    /** Source from vertex data. */
    VERTEX_DATA,

    /** Source from screen space of fragment being rendered. */
    SCREEN_SPACE,

    /** Source from a node. */
    NODE
};

/**
 * Implementation of Node which provides access to a texture.
 */
class TextureNode : public Node
{
  public:
    /**
     * Create a new TextureNode.
     *
     * @param texture
     *   Texture to provide access to.
     *
     * @param uv_source
     *   Source of UV data.
     *
     * @param uv_input
     *   Optional node to calculate uv, only valid if uv_source is NODE.
     */
    TextureNode(const Texture *texture, UVSource uv_source = UVSource::VERTEX_DATA, const Node *uv_input = nullptr);

    ~TextureNode() override = default;

    /**
     * Accept a compiler visitor.
     *
     * @param compiler
     *   Compiler to accept.
     */
    void accept(ShaderCompiler &compiler) const override;

    /**
     * Get texture.
     *
     * @returns
     *   Texture.
     */
    const Texture *texture() const;

    /**
     * Get source of UV data.
     *
     * @returns
     *   UV data source.
     */
    UVSource uv_source() const;

    /**
     * Get node for uv input.
     *
     * @returns
     *   Node if source is NODE, otherwise nullptr.
     */
    const Node *uv_input() const;

    /**
     * Compute hash of node.
     *
     * @return
     *   Hash of node.
     */
    std::size_t hash() const override;

  private:
    /** Texture. */
    const Texture *texture_;

    /** Source of UV data. */
    UVSource uv_source_;

    /** Optional node for uv. */
    const Node *uv_input_;
};
}

```

`include/iris/graphics/render_graph/time_node.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <memory>

#include "graphics/render_graph/node.h"

namespace iris
{
class ShaderCompiler;

/**
 */
class TimeNode : public Node
{
  public:
    /**
     * Accept a compiler visitor.
     *
     * @param compiler
     *   Compiler to accept.
     */
    void accept(ShaderCompiler &compiler) const override;

    /**
     * Compute hash of node.
     *
     * @return
     *   Hash of node.
     */
    std::size_t hash() const override;
};
}

```

`include/iris/graphics/render_graph/unary_operator_node.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <memory>

#include "graphics/render_graph/node.h"

namespace iris
{

class ShaderCompiler;

enum class UnaryOperator
{
    NEGATE,
    NORMALISE,
    SIN,
    COS,
    SQUARE_ROOT
};

/**
 * Implementation of Node which performs a unary operator on an input.
 */
class UnaryOperatorNode : public Node
{
  public:
    /**
     * Create a new UnaryOperatorNode.
     *
     * @param input_node
     *   Input value for operator.
     *
     * @param unary_operator
     *   Operator to apply to input.
     */
    UnaryOperatorNode(Node *input_node, UnaryOperator unary_operator);

    /**
     * Accept a compiler visitor.
     *
     * @param compiler
     *   Compiler to accept.
     */
    void accept(ShaderCompiler &compiler) const override;

    /**
     * Get input node.
     *
     * @returns
     *   Input node.
     */
    Node *input_node() const;

    /**
     * Get unary operator.
     *
     * @returns
     *   Unary operator.
     */
    UnaryOperator unary_operator() const;

    /**
     * Compute hash of node.
     *
     * @return
     *   Hash of node.
     */
    std::size_t hash() const override;

  private:
    /** Input node. */
    Node *input_node_;

    /** Unary operator to apply to input. */
    UnaryOperator unary_operator_;
};
}

```

`include/iris/graphics/render_graph/value_node.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <string_view>
#include <typeindex>
#include <typeinfo>

#include "graphics/render_graph/node.h"
#include "graphics/render_graph/shader_compiler.h"

namespace iris
{
/**
 * Implementation of Node which provides access to a constant value. See
 * compiler.h for supported types.
 */
template <class T>
class ValueNode : public Node
{
  public:
    /**
     * Create a new ValueNode.
     *
     * @param value
     *   Value to provide access to.
     */
    ValueNode(const T &value)
        : value_(value)
    {
    }

    ~ValueNode() override = default;

    /**
     * Accept a compiler visitor.
     *
     * @param compiler
     *   Compiler to accept.
     */
    void accept(ShaderCompiler &compiler) const override
    {
        return compiler.visit(*this);
    }

    /**
     * Get value.
     *
     * @returns
     *   Value.
     */
    T value() const
    {
        return value_;
    }

    /**
     * Compute hash of node.
     *
     * @return
     *   Hash of node.
     */
    std::size_t hash() const override
    {
        return combine_hash(value_, std::string_view{"value_node"}, std::type_index(typeid(T)));
    }

  private:
    /** Value. */
    T value_;
};
}

```

`include/iris/graphics/render_graph/variable_node.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <memory>
#include <string>

#include "graphics/render_graph/node.h"

namespace iris
{

class ShaderCompiler;

/**
 * Implementation of Node which provides access to variables that have been created in the render graph.
 */
class VariableNode : public Node
{
  public:
    /**
     * Create a new VariableNode.
     *
     * @param name
     *   Name of the variable.
     */
    VariableNode(const std::string &name);

    /**
     * Accept a compiler visitor.
     *
     * @param compiler
     *   Compiler to accept.
     */
    void accept(ShaderCompiler &compiler) const override;

    /**
     * Get name of variable.
     *
     * @returns
     *   Variable name.
     */
    std::string name() const;

    /**
     * Compute hash of node.
     *
     * @return
     *   Hash of node.
     */
    std::size_t hash() const override;

  private:
    /** Variable name. */
    std::string name_;
};

}

```

`include/iris/graphics/render_graph/vertex_node.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <cstdint>
#include <optional>
#include <string>
#include <string_view>

#include "graphics/render_graph/node.h"

namespace iris
{

class ShaderCompiler;

/**
 * Enumeration of types of vertex data that can be used.
 */
enum class VertexDataType : std::uint8_t
{
    POSITION,
    NORMAL,
    UV
};

/**
 * Get vertex data. Note that this will be used in the fragment shader and so will be an interpolated value.
 */
class VertexNode : public Node
{
  public:
    /**
     * Construct a new VertexNode
     *
     * @param vertex_data_type
     *   The type of vertex data to get.
     */
    VertexNode(VertexDataType vertex_data_type);

    /**
     * Construct a new VertexNode
     *
     * @param vertex_data_type
     *   The type of vertex data to get.
     *
     * @param swizzle
     *   A swizzle to apply to the vertex data.
     */
    VertexNode(VertexDataType vertex_data_type, std::string_view swizzle);

    ~VertexNode() override = default;

    /**
     * Accept a compiler visitor.
     *
     * @param compiler
     *   Compiler to accept.
     */
    void accept(ShaderCompiler &compiler) const override;

    /**
     * Get arithmetic operator.
     *
     * @returns
     *   Arithmetic operator.
     */
    VertexDataType vertex_data_type() const;

    /**
     * Get swizzle.
     *
     * @return
     *   Swizzle, of one was set.
     */
    std::optional<std::string> swizzle() const;

    /**
     * Compute hash of node.
     *
     * @return
     *   Hash of node.
     */
    std::size_t hash() const override;

  private:
    /** Type of vertex data to get.c */
    VertexDataType vertex_data_type_;

    /** Optional swizzle. */
    std::optional<std::string> swizzle_;
};
}

```

`include/iris/graphics/render_pass.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include "core/camera.h"
#include "graphics/cube_map.h"
#include "graphics/post_processing_description.h"
#include "graphics/render_target.h"
#include "graphics/scene.h"

namespace iris
{

/**
 * Struct encapsulating data needed for a render pass.
 * This describes:
 *  - what to render
 *  - where to render it from
 *  - where to render it to
 *
 * It is an engine convention that a nullptr target means render to the default target i.e. the window.
 */
struct RenderPass
{
    RenderPass(RenderPass &) = delete;
    RenderPass &operator=(RenderPass &) = delete;
    RenderPass(RenderPass &&) = default;
    RenderPass &operator=(RenderPass &&) = default;

    /** Scene to render */
    Scene *scene = nullptr;

    /** Camera to render with. */
    const Camera *camera = nullptr;

    /** Target to render to. */
    const RenderTarget *colour_target = nullptr;

    /** Optional target to render screen space normals to. */
    const RenderTarget *normal_target = nullptr;

    /** Optional target to render screen space positions to. */
    const RenderTarget *position_target = nullptr;

    /** Flag indicating that only depth information should be rendered. */
    bool depth_only = false;

    /** Optional sky box. */
    const CubeMap *sky_box = nullptr;

    /** Should the colour buffer be cleared before rendering. */
    bool clear_colour = true;

    /** Should the depth buffer be cleared before rendering. */
    bool clear_depth = true;

    PostProcessingDescription post_processing_description = PostProcessingDescription{};

  private:
    // friend to allow only the RenderPipeline to create
    friend class RenderPipeline;
    RenderPass() = default;
};

}

```

`include/iris/graphics/render_pipeline.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <cstdint>
#include <deque>
#include <memory>
#include <vector>

#include "graphics/material_manager.h"
#include "graphics/mesh_manager.h"
#include "graphics/render_command.h"
#include "graphics/render_graph/render_graph.h"
#include "graphics/render_pass.h"
#include "graphics/render_target_manager.h"
#include "graphics/scene.h"
#include "graphics/single_entity.h"

namespace iris
{

/**
 * This class encapsulates all the logic and machinery of rendering. It creates and manages the primitives a user needs
 * to build their desired rendered output.
 *
 * Once a RenderPipeline is constructed it can be used to create scenes, render passes and render graphs. These can all
 * be assembled how the user wants. The RenderPipeline is then handed over to the Window, where it will be converted
 * into render commands.
 */
class RenderPipeline
{
  public:
    /**
     * Create a new RenderPipeline.
     *
     * @param material_manager
     *   Material manager object.
     *
     * @param mesh_manager
     *   Mesh manager object.
     *
     * @param render_target_manager
     *   Render target manager object.
     *
     * @param width
     *   Width of final render output.
     *
     * @param height
     *   Height of final render output.
     */
    RenderPipeline(
        MaterialManager &material_manager,
        MeshManager &mesh_manager,
        RenderTargetManager &render_target_manager,
        std::uint32_t width,
        std::uint32_t height);
    ~RenderPipeline();

    RenderPipeline(const RenderPipeline &) = delete;
    RenderPipeline &operator=(const RenderPipeline &) = delete;
    RenderPipeline(RenderPipeline &&) = delete;
    RenderPipeline &operator=(RenderPipeline &&) = delete;

    /**
     * Create a new scene.
     *
     * If the scene is modified after the RenderPipeline has been handed over to the Window any changes will be updated
     * on the next render call.
     *
     * @returns
     *   Pointer to Scene.
     */
    Scene *create_scene();

    /**
     * Create a RenderGraph for use with this pipeline.
     *
     * @returns
     *   Pointer to the newly created RenderGraph.
     */
    RenderGraph *create_render_graph();

    /**
     * Create a new render pass for a scene.
     *
     * @param scene
     *   Scene to create render pass for. The Scene must have been created by this RenderPipeline.
     *
     * @returns
     *   Pointer to RenderPass.
     */
    RenderPass *create_render_pass(Scene *scene);

    /**
     * This method adds additional passes as needed (e.g. shadow passes, SSAO) and then creates a collection of
     * RenderCommand objects, which can then be executed by a renderer.
     *
     * Note this should only be called internally by the engine, calling it manually may produce unexpected results.
     *
     * @returns
     *   Collection of RenderCommand objects representing the full pipeline.
     */
    std::vector<RenderCommand> build();

    /**
     * Rebuilds the RenderCommands as if build() was called but doesn't add additional passes.
     *
     * Note this should only be called internally by the engine, calling it manually may produce unexpected results.
     *
     * @returns
     *   Collection of RenderCommand objects representing the full pipeline.
     */
    std::vector<RenderCommand> rebuild();

    /**
     * Get collection of all RenderPass objects in this pipeline.
     *
     * @returns
     *   Collection of RenderPass objects.
     */
    std::vector<RenderPass *> render_passes() const;

    /**
     * Check if a created object has been mutated.
     *
     * @returns
     *   True if a created object has been mutated, false otherwise.
     */
    bool is_dirty() const;

    /**
     * Reset the dirty state to false.
     *
     * Note this should only be called internally by the engine, calling it manually may produce unexpected results.
     */
    void clear_dirty_bit();

    /**
     * Get scene buy index.
     *
     * @param index.
     *   Index of scene, scenes are created at index 0 and increase monotonically.
     */
    Scene *scene(std::size_t index) const;

  private:
    RenderPass *create_engine_render_pass(Scene *scene);

    /**
     * Add a new pass to collection of passes. This creates a new scene, camera and render target as well as using a
     * callback to allow the caller to set the render graph for the scene.
     *
     * The output from the last pass on input is propagated to the new pass.
     *
     * @param render_passes
     *   Collection to add new pass to.
     *
     * @param create_render_graph_callback
     *   Callback to create the render graph for the new scene.
     *
     * @returns
     *   Target for new pass.
     */
    const RenderTarget *add_pass(
        std::vector<RenderPass *> &render_passes,
        std::function<void(iris::RenderGraph *, const RenderTarget *)> create_render_graph_callback);

    /**
     * Add passes for all the post processing in the supplied passes.
     *
     * @param passes
     *   Passes to added post processing passes for.
     *
     * @param render_passes
     *   Collection of passes to add new passes to.
     */
    void add_post_processing_passes();

    /** Material manager object. */
    MaterialManager &material_manager_;

    /** Mesh manager object. */
    MeshManager &mesh_manager_;

    /** Render target manager object. */
    RenderTargetManager &render_target_manager_;

    /** Collection of created scenes. */
    std::vector<std::unique_ptr<Scene>> scenes_;

    /** Collection of created RenderGraphs. */
    std::vector<std::unique_ptr<RenderGraph>> render_graphs_;

    /** Collection of passes created by the user. */
    std::vector<std::unique_ptr<RenderPass>> user_created_passes_;

    /** Collection of passes created by the engine (in order to render what the user has requested). */
    std::vector<std::unique_ptr<RenderPass>> engine_created_passes_;

    /** Collection of pointers to all render passes in the pipeline. */
    std::vector<RenderPass *> render_passes_;

    /** Collection of created sky box entities. */
    std::unordered_map<const RenderPass *, SingleEntity *> sky_box_entities_;

    /** Collection of created sky box render graphs. */
    std::unordered_map<const RenderPass *, const RenderGraph *> sky_box_render_graphs_;

    /** Flag indicating a scene in the pipeline has changed. */
    bool dirty_;

    /** Width of final render target. */
    std::uint32_t width_;

    /** Height of final render target. */
    std::uint32_t height_;

    /** Cameras created for new passes. */
    std::deque<Camera> cameras_;

    /** Collection of created shadow maps. */
    std::unordered_map<DirectionalLight *, RenderTarget *> shadow_maps_;
};

}

```

`include/iris/graphics/render_target.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>

#include "graphics/texture.h"

namespace iris
{

/**
 * Abstract class for a RenderTarget - a class that encapsulates something the renderer can render to. It also provides
 * access to the colour and depth Texture objects.
 *
 * Note that you cannot access the colour or depth data directly after a render as it is not synchronised back to the
 * CPU, you can use those textures as inputs for other rendering operations.
 */
class RenderTarget
{
  public:
    /**
     * Create a new RenderTarget.
     *
     * @param colour_texture
     *   Texture to render colour data to.
     *
     * @param depth_texture
     *   Texture to render depth data to.
     */
    RenderTarget(const Texture *colour_texture, const Texture *depth_texture);

    virtual ~RenderTarget() = 0;

    /**
     * Get a pointer to the texture storing the target colour data.
     *
     * @returns
     *   Colour texture.
     */
    const Texture *colour_texture() const;

    /**
     * Get a pointer to the texture storing the target depth data.
     *
     * @returns
     *   Depth texture.
     */
    const Texture *depth_texture() const;

    /**
     * Get the width of the RenderTarget.
     *
     * @returns
     *   Render target width.
     */
    std::uint32_t width() const;

    /**
     * Get the height of the RenderTarget.
     *
     * @returns
     *   Render target height.
     */
    std::uint32_t height() const;

  protected:
    /** Colour texture. */
    const Texture *colour_texture_;

    /** Depth texture. */
    const Texture *depth_texture_;
};

}

```

`include/iris/graphics/render_target_manager.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>

namespace iris
{

class RenderTarget;

/**
 * Interface to create and manage render targets.
 */
class RenderTargetManager
{
  public:
    virtual ~RenderTargetManager() = default;

    /**
     * Create a render target the size of the current window.
     *
     * @returns
     *   Pointer to the created render target.
     */
    virtual RenderTarget *create() = 0;

    /**
     * Create a render target with the specified dimensions.
     *
     * @param width
     *   Width of render target.
     *
     * @param height
     *   Height of render target.
     *
     * @returns
     *   Pointer to the created render target.
     */
    virtual RenderTarget *create(std::uint32_t width, std::uint32_t height) = 0;

    /**
     * Create a new render target which combines the colour target and depth target of two separate render targets.
     *
     * @param colour_target
     *   Render target to for colour target.
     *
     * @param depth_target
     *   Render target to for depth target.
     *
     * @returns
     *   Pointer to the created render target.
     */
    virtual RenderTarget *create(const RenderTarget *colour_target, const RenderTarget *depth_target) = 0;
};

}

```

`include/iris/graphics/renderer.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <chrono>
#include <memory>
#include <vector>

#include "core/camera.h"
#include "graphics/lights/light_type.h"
#include "graphics/material_manager.h"
#include "graphics/render_command.h"
#include "graphics/render_pass.h"
#include "graphics/render_pipeline.h"
#include "graphics/render_target.h"
#include "graphics/scene.h"

namespace iris
{

/**
 * Interface for a Renderer - a class that executes a collection of RenderPass
 * objects.
 */
class Renderer
{
  public:
    /**
     * Construct a new Renderer.
     *
     * @param material_manager
     *   Material manager object.
     */
    Renderer(MaterialManager &material_manager);
    virtual ~Renderer() = default;

    /**
     * Render the current RenderPass objects.
     */
    virtual void render();

    /**
     * Set the render pipeline to execute with render().
     *
     * @param render_pipeline
     *   Pipeline to execute.
     */
    void set_render_pipeline(std::unique_ptr<RenderPipeline> render_pipeline);

    /**
     * Elapsed time since set_render_pipeline was called. This is also the value that is passed to shaders via TimeNode.
     *
     * @returns
     *   Elapsed time.
     */
    std::chrono::milliseconds time() const;

  protected:
    /**
     * Implementers should use this method to perform any engine specific tasks before/after building the render queue.
     *
     * @param build_queue
     *   This function builds the queue, it *must* be called.
     */
    virtual void do_set_render_pipeline(std::function<void()> build_queue) = 0;

    // these functions provide implementors a chance to handle each
    // RenderCommandType, where each function below corresponds to one of the
    // enum types - with the addition of pre_render and post_render which get
    // called before and after each frame
    // defaults are all no-ops so implementations only need to override the
    // ones needed for their graphics api

    virtual void pre_render();
    virtual void execute_pass_start(RenderCommand &command);
    virtual void execute_draw(RenderCommand &command);
    virtual void execute_pass_end(RenderCommand &command);
    virtual void execute_present(RenderCommand &command);
    virtual void post_render();

    /** The queue of RenderCommand objects created from the current RenderPass objects. */
    std::vector<RenderCommand> render_queue_;

    /** Pipeline to execute with render(). */
    std::unique_ptr<RenderPipeline> render_pipeline_;

    /** Time point when set_render_pipeline was called. */
    std::chrono::steady_clock::time_point start_;

    /** Elapsed time since set_render_pipeline was called. */
    std::chrono::steady_clock::duration time_;

  private:
    /** Material manager object. */
    MaterialManager &material_manager_;
};

}

```

`include/iris/graphics/sampler.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <functional>
#include <type_traits>

#include "core/colour.h"
#include "core/utils.h"

namespace iris
{

/**
 * Enumeration of possible sampling address modes, which describes the behaviour when a texture is sampled outside of
 * the range (0, 0) to (1, 1).
 *
 * As an example consider a 3-pixel wide 1D texture: ABC
 */
enum class SamplerAddressMode : std::uint8_t
{
    /** Repeat texture. Pattern ABC|ABC */
    REPEAT,

    /** Repeat but mirror the texture with each repeat. Pattern ABC|CBA */
    MIRROR,

    /** Use the colour at the edge of the texture. Pattern ABC|CCC */
    CLAMP_TO_EDGE,

    /** Use a custom colour. Pattern ABC|XXX */
    CLAMP_TO_BORDER
};

/**
 * Enumeration of possible filters, which describe how texture pixels (texels) should be mapped to a texture
 * coordinate.
 */
enum class SamplerFilter : std::uint8_t
{
    /** Use the texel that is closes to the texture coordinate. */
    NEAREST,

    /** Interpolate the nearest texels. */
    LINEAR
};

/**
 * Struct describing all sampler parameters.
 */
struct SamplerDescriptor
{
    /** Address mode along S coord. */
    SamplerAddressMode s_address_mode = SamplerAddressMode::REPEAT;

    /** Address mode along T coord. */
    SamplerAddressMode t_address_mode = SamplerAddressMode::REPEAT;

    /** Address mode along R coord (only applies to cube maps). */
    SamplerAddressMode r_address_mode = SamplerAddressMode::REPEAT;

    /** Border colour if address mode is CLAMP_TO_BORDER. */
    Colour border_colour = {0.0f, 0.0f, 0.0f};

    /** Filter to us when down-sampling texture. */
    SamplerFilter minification_filter = SamplerFilter::LINEAR;

    /** Filter to us when up-sampling texture. */
    SamplerFilter magnification_filter = SamplerFilter::LINEAR;

    /** Whether to generate and use mipmaps. */
    bool uses_mips = true;

    /** Filter mode for selecting between mipmap levels (only valid if uses_mips is true). */
    SamplerFilter mip_filter = SamplerFilter::LINEAR;

    bool operator==(const SamplerDescriptor &) const = default;
    bool operator!=(const SamplerDescriptor &) const = default;
};

/**
 * Abstract class that encapsulates sampling a texture.
 */
class Sampler
{
  public:
    /**
     * Construct a new Samper.
     *
     * @param descriptor
     *   Description of sampler parameters.
     *
     * @param index
     *   Index into the global array of all allocated samplers.
     */
    Sampler(const SamplerDescriptor &descriptor, std::uint32_t index);

    virtual ~Sampler() = default;

    Sampler(const Sampler &) = delete;
    Sampler &operator=(const Sampler &) = delete;

    /**
     * Get sampler descriptor.
     *
     * @returns
     *   Sampler descriptor.
     */
    SamplerDescriptor descriptor() const;

    /**
     * Get index into global array of all allocated samplers.
     *
     * This is most useful for bindless texturing as the sampler knows where in the mapped sampler table to find itself.
     *
     * @returns
     *   Index of sampler.
     */
    std::uint32_t index() const;

  private:
    /** Sampler description. */
    SamplerDescriptor descriptor_;

    /** Index into the global array of all allocated samplers. */
    std::uint32_t index_;
};

}

// specialise std::hash for SamplerDescriptor
namespace std
{

template <>
struct hash<iris::SamplerDescriptor>
{
    size_t operator()(const iris::SamplerDescriptor &descriptor) const
    {
        return iris::combine_hash(
            static_cast<std::underlying_type_t<iris::SamplerAddressMode>>(descriptor.s_address_mode),
            static_cast<std::underlying_type_t<iris::SamplerAddressMode>>(descriptor.t_address_mode),
            static_cast<std::underlying_type_t<iris::SamplerAddressMode>>(descriptor.r_address_mode),
            descriptor.border_colour,
            static_cast<std::underlying_type_t<iris::SamplerFilter>>(descriptor.minification_filter),
            static_cast<std::underlying_type_t<iris::SamplerFilter>>(descriptor.magnification_filter),
            descriptor.uses_mips,
            static_cast<std::underlying_type_t<iris::SamplerFilter>>(descriptor.mip_filter));
    }
};

}

```

`include/iris/graphics/scene.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <memory>
#include <tuple>
#include <vector>

#include "graphics/instanced_entity.h"
#include "graphics/lights/lighting_rig.h"
#include "graphics/render_entity.h"
#include "graphics/render_graph/render_graph.h"

namespace iris
{

/**
 * A scene is a collection of entities to be rendered. It owns the memory of its
 * render entities.
 */
class Scene
{
  public:
    /**
     * Create a RenderEntity and add it to the scene. Uses perfect forwarding to
     * pass along all arguments.
     *
     * @param render_graph
     *   RenderGraph for RenderEntity.
     *
     * @param args
     *   Arguments for RenderEntity.
     *
     * @returns
     *   Pointer to the newly created RenderEntity.
     */
    template <class T, class... Args>
    T *create_entity(RenderGraph *render_graph, Args &&...args)
    {
        auto element = std::make_unique<T>(std::forward<Args>(args)...);

        return static_cast<T *>(add(std::move(render_graph), std::move(element)));
    }

    /**
     * Add a RenderEntity to the scene.
     *
     * @param render_graph
     *   RenderGraph for RenderEntity.
     *
     * @param entity
     *   RenderEntity to add to scene.
     *
     * @returns
     *   Pointer to the added RenderEntity.
     */
    RenderEntity *add(RenderGraph *render_graph, std::unique_ptr<RenderEntity> entity);

    /**
     * Remove an entity from the scene.
     *
     * @param entity
     *   The entity to remove.
     */
    void remove(RenderEntity *entity);

    /**
     * Create a Light and add it to the scene. Uses perfect forwarding to pass
     * along all arguments.
     *
     * @param args
     *   Args for light.
     *
     * @returns
     *   Pointer to newly created light.
     */
    template <class T, class... Args>
    T *create_light(Args &&...args)
    {
        auto light = std::make_unique<T>(std::forward<Args>(args)...);
        return add(std::move(light));
    }

    /**
     * Add a point light to the scene.
     *
     * @param light
     *   Light to add to scene
     *
     * @returns
     *   Pointer to the added light.
     */
    PointLight *add(std::unique_ptr<PointLight> light);

    /**
     * Add a directional light to the scene.
     *
     * @param light
     *   Light to add to scene
     *
     * @returns
     *   Pointer to the added light.
     */
    DirectionalLight *add(std::unique_ptr<DirectionalLight> light);

    /**
     * Get ambient light colour.
     *
     * @returns
     *   Ambient light colour.
     */
    Colour ambient_light() const;

    /**
     * Set ambient light colour.
     *
     * @param colour
     *   New ambient light colour.
     */
    void set_ambient_light(const Colour &colour);

    /**
     * Get the RenderGraph for a given RenderEntity.
     *
     * @param entity
     *   RenderEntity to get RenderGraph for.
     *
     * @returns
     *   RenderGraph for supplied RenderEntity.
     */
    RenderGraph *render_graph(RenderEntity *entity) const;

    /**
     * Get a reference to all entities in the scene.
     *
     * @returns
     *   Collection of <RenderGraph, RenderEntity> tuples.
     */
    std::vector<std::tuple<RenderGraph *, std::unique_ptr<RenderEntity>>> &entities();

    /**
     * Get a const reference to all entities in the scene.
     *
     * @returns
     *   Collection of <RenderGraph, RenderEntity> tuples.
     */
    const std::vector<std::tuple<RenderGraph *, std::unique_ptr<RenderEntity>>> &entities() const;

    /**
     * Get LightingRig.
     *
     * @returns
     *   Pointer to LightingRig.
     */
    const LightingRig *lighting_rig() const;

  private:
    // friend to allow only the RenderPipeline to create
    friend class RenderPipeline;

    /**
     * Create new Scene.
     *
     * @param default_render_graph
     *   Render graph to use when a user does to supply one.
     *
     * @param dirty_pipeline
     *   Flag to set when the scene is modified.
     */
    Scene(RenderGraph *default_render_graph, bool *dirty_pipeline);

    /**
     * Create a RenderEntity and add it to the scene. Uses perfect forwarding to pass along all arguments.
     *
     * Note that this inserts into the internal collection of entities at the front. It's a private method so only
     * RenderPipeline can call it, this is because:
     *  1. A user shouldn't have to care about internal entity ordering
     *  2. RenderPipeline does care about ordering and needs a bit more control.
     *
     * @param render_graph
     *   RenderGraph for RenderEntity.
     *
     * @param args
     *   Arguments for RenderEntity.
     *
     * @returns
     *   Pointer to the newly created RenderEntity.
     */
    template <class T, class... Args>
    T *create_entity_at_front(RenderGraph *render_graph, Args &&...args)
    {
        auto element = std::make_unique<T>(std::forward<Args>(args)...);

        return static_cast<T *>(add_at_front(std::move(render_graph), std::move(element)));
    }

    /**
     * Add a RenderEntity to the scene.
     *
     * Note that this inserts into the internal collection of entities at the front. It's a private method so only
     * RenderPipeline can call it, this is because:
     *  1. A user shouldn't have to care about internal entity ordering
     *  2. RenderPipeline does care about ordering and needs a bit more control.
     *
     * @param render_graph
     *   RenderGraph for RenderEntity.
     *
     * @param entity
     *   RenderEntity to add to scene.
     *
     * @returns
     *   Pointer to the added RenderEntity.
     */
    RenderEntity *add_at_front(RenderGraph *render_graph, std::unique_ptr<RenderEntity> entity);

    /** Collection of <RenderGraph, RenderEntity> tuples. */
    std::vector<std::tuple<RenderGraph *, std::unique_ptr<RenderEntity>>> entities_;

    /** Collection of RenderGraphs. */
    std::vector<std::unique_ptr<RenderGraph>> render_graphs_;

    /** Lighting rig for scene. */
    LightingRig lighting_rig_;

    /** Handle to the default render graph. */
    RenderGraph *default_render_graph_;

    /** Flag to indicate user has changed the scene. */
    bool *dirty_pipeline_;
};

}

```

`include/iris/graphics/shader_type.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>

namespace iris
{

/**
 * Enumeration of shader types.
 */
enum ShaderType : std::uint32_t
{
    VERTEX,
    FRAGMENT
};

}

```

`include/iris/graphics/single_entity.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <memory>
#include <string>
#include <string_view>
#include <vector>

#include "core/camera_type.h"
#include "core/matrix4.h"
#include "core/quaternion.h"
#include "core/transform.h"
#include "graphics/mesh.h"
#include "graphics/primitive_type.h"
#include "graphics/render_entity.h"
#include "graphics/render_entity_type.h"
#include "graphics/render_graph/render_node.h"
#include "graphics/skeleton.h"
#include "graphics/texture.h"

namespace iris
{

/**
 * Implementation of RenderEntity for a single instance mesh.
 */
class SingleEntity : public RenderEntity
{
  public:
    /**
     * Construct a SingleEntity.
     *
     * @param mesh
     *   Mesh to render.
     *
     * @param position
     *   Centre of mesh in world space.
     *
     * @param has_transparency
     *   Whether entity will have transparency when rendered.
     *
     * @param primitive_type
     *   Primitive type of underlying mesh.
     */
    SingleEntity(
        const Mesh *mesh,
        const Vector3 &position,
        bool has_transparency = false,
        PrimitiveType primitive_type = PrimitiveType::TRIANGLES);

    /**
     * Construct a SingleEntity.
     *
     * @param mesh
     *   Mesh to render.
     *
     * @param transform
     *   Transform of entity in world space.
     *
     * @param has_transparency
     *   Whether entity will have transparency when rendered.
     *
     * @param primitive_type
     *   Primitive type of underlying mesh.
     */
    SingleEntity(
        const Mesh *mesh,
        const Transform &transform,
        bool has_transparency = false,
        PrimitiveType primitive_type = PrimitiveType::TRIANGLES);

    /**
     * Construct a SingleEntity.
     *
     * @param mesh
     *   Mesh to render.
     *
     * @param transform
     *   Transform of entity in world space.
     *
     * @param skeleton
     *   Skeleton.
     *
     * @param has_transparency
     *   Whether entity will have transparency when rendered.
     *
     * @param primitive_type
     *   Primitive type of underlying mesh.
     */
    SingleEntity(
        const Mesh *mesh,
        const Transform &transform,
        Skeleton *skeleton,
        bool has_transparency = false,
        PrimitiveType primitive_type = PrimitiveType::TRIANGLES);

    ~SingleEntity() override = default;

    SingleEntity(const SingleEntity &) = delete;
    SingleEntity &operator=(const SingleEntity &) = delete;
    SingleEntity(SingleEntity &&) = default;
    SingleEntity &operator=(SingleEntity &&) = default;

    /**
     * Get entity type.
     *
     * @returns
     *   Entity type.
     */
    RenderEntityType type() const override;

    /**
     * Get position.
     *
     * @returns
     *   Position.
     */
    Vector3 position() const;

    /**
     * Set the position of the SingleEntity.
     *
     * @param position
     *   New position.
     */
    void set_position(const Vector3 &position);

    /**
     * Get orientation.
     *
     * @return
     *   Orientation.
     */
    Quaternion orientation() const;

    /**
     * Set the orientation of the SingleEntity.
     *
     * @param orientation
     *   New orientation.
     */
    void set_orientation(const Quaternion &orientation);

    /**
     * Get scale.
     *
     * @return
     *   Scale.
     */
    Vector3 scale() const;

    /**
     * Set the scale of the SingleEntity.
     *
     * @param scale
     *   New scale.
     */
    void set_scale(const Vector3 &scale);

    /**
     * Get the transformation matrix of the SingleEntity.
     *
     * @returns
     *   Transformation matrix.
     */
    Matrix4 transform() const;

    /**
     * Set transformation matrix.
     *
     * @param transform
     *   New transform matrix.
     */
    void set_transform(const Matrix4 &transform);

    /**
     * Set transformation.
     *
     * @param transform
     *   New transform.
     */
    void set_transform(const Transform &transform);

    /**
     * Get the transformation matrix for the normals of the SingleEntity.
     *
     * @returns
     *   Normal transformation matrix.
     */
    Matrix4 normal_transform() const;

    /**
     * Set Mesh.
     *
     * @param mesh
     *   New Mesh.
     */
    void set_mesh(const Mesh *mesh);

    /**
     * Get pointer to skeleton.
     *
     * @returns
     *   Pointer to skeleton.
     */
    Skeleton *skeleton();

    /**
     * Get const pointer to skeleton.
     *
     * @returns
     *   Pointer to skeleton.
     */
    const Skeleton *skeleton() const;

    /**
     * Get if entity will be rendered with transparency.
     *
     * @returns
     *   True if entity will have transparency, otherwise false.
     */
    bool has_transparency() const override;

  private:
    /** World space transform. */
    Transform transform_;

    /** Normal transformation matrix. */
    Matrix4 normal_;

    /** Skeleton. */
    Skeleton *skeleton_;

    /** Flag indicating entity will have transparency. */
    bool has_transparency_;
};

}

```

`include/iris/graphics/skeleton.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <string>
#include <string_view>
#include <unordered_map>
#include <vector>

#include "core/matrix4.h"
#include "core/transform.h"
#include "core/utils.h"
#include "graphics/bone.h"

namespace iris
{

class BoneQuery;

/**
 * A skeleton provides an interface for animating bones.
 *
 * Internally bones are ordered into a tree hierarchy, setting an animation will
 * then walk the tree, applying transformations to bones and its children.
 *
 * A skeleton can only have a single root note (i.e. one without a parent).
 *
 * The internal order of bones is important (and may be different to the input
 * order), therefore an interface is also provided for querying bone index.
 *
 * The following diagram shows a skeleton and the bone hierarchy.
 *
 *                    +---+
 *                    | O | ---------- head
 * .                  +---+
 *                    | . | ---------- neck
 *                    +---+
 *              +---+ +---+ +---+
 * left_arm --- |  /| | | | |\ .| --- right_arm
 *              | / | | | | |  \|
 *              +---+ | | | +---+
 *                    | | |
 *                    | | | --------- spine
 *                    +---+
 *                    | . | --------- hip
 *                    +---+
 *              +---+       +---+
 * left_leg --- |  /|       |\ .| --- right_leg
 *              | / |       |  \|
 *              +---+       +---+
 * spine (root)
 * |
 * +--- neck
 * |    |
 * |    '--- head
 * |
 * '--- right_arm
 * |
 * '--- left_arm
 * |
 * '--- hip
 *      |
 *      '--- right_leg
 *      |
 *      '--- left_leg
 *
 */
class Skeleton
{
  public:
    /**
     * Construct an empty skeleton.
     */
    Skeleton();

    /**
     * Construct a skeleton.
     *
     * @param bones
     *   Collection of bones, these will be reordered.
     */
    Skeleton(std::vector<Bone> bones);

    /**
     * Get reference to collection of bones.
     *
     * @returns
     *   Reference to bone collection.
     */
    const std::vector<Bone> &bones() const;

    /**
     * Get reference to collection of transformation matrices for all bones (for
     * current animation). This is suitable for transferring to GPU.
     *
     * @returns
     *   Reference to bone transformations.
     */
    const std::vector<Matrix4> &transforms() const;

    /**
     * Update the bone transforms
     *
     * @param query
     *   Query object to get bone transforms (e.g. from an animation), can be nullptr.
     */
    void update(BoneQuery *query);

    /**
     * Check if a bone exists.
     *
     * @param name
     *   Name of bone to check.
     *
     * @returns
     *   True if bone exists, otherwise false.
     */
    bool has_bone(std::string_view name) const;

    /**
     * Get the index of the given bone name.
     *
     * @param name
     *   Name of bone.
     *
     * @returns
     *   Index of bone.
     */
    std::size_t bone_index(std::string_view name) const;

    /**
     * Get reference to bone at index.
     *
     * @param index
     *   Index of bone to get.
     *
     * @returns
     *   Reference to bone.
     */
    Bone &bone(std::size_t index);

    /**
     * Get transform for bone at index.
     *
     * @param index
     *   Index of bone to get.
     *
     * @returns
     *   Transform for bone.
     */
    Matrix4 transform(std::size_t index) const;

    /**
     * Get const reference to bone at index.
     *
     * @param index
     *   Index of bone to get.
     *
     * @returns
     *   Const reference to bone.
     */
    const Bone &bone(std::size_t index) const;

  private:
    /** Collection of bones, in hierarchical order. */
    std::vector<Bone> bones_;

    /** Index of parents for bones. */
    std::vector<std::size_t> parents_;

    /** Collection of transform matrices for bones. */
    std::vector<Matrix4> transforms_;
};

}

```

`include/iris/graphics/text_factory.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <memory>
#include <string>
#include <vector>

#include "core/colour.h"
#include "graphics/texture.h"

namespace iris::text_factory
{

/**
 * Construct a new font.
 *
 * @param font_name
 *   The name of a Font to load. This is located and loaded in a
 *   platform specific way, so the Font must exist for the current
 *   platform.
 *
 * @param size
 *   The Font size.
 *
 * @param text
 *   The text to render.
 *
 * @param colour
 *   The colour of the font.
 */
Texture *create(const std::string &font_name, std::uint32_t size, const std::string &text, const Colour &colour);

}

```

`include/iris/graphics/texture.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>

#include "core/data_buffer.h"
#include "graphics/sampler.h"
#include "graphics/texture_usage.h"

namespace iris
{

/**
 * Abstract class that encapsulates a renderable texture.
 */
class Texture
{
  public:
    /**
     * Creates a new Texture with custom data.
     *
     * @param data
     *   Raw data of image, in pixel_format.
     *
     * @param width
     *   Width of image.
     *
     * @param height
     *   Height of image.
     *
     * @param sampler
     *   Sampler to use for this texture.
     *
     * @param usage
     *   Texture usage.
     *
     * @param index
     *   Index into the global array of all allocated textures.
     */
    Texture(
        const DataBuffer &data,
        std::uint32_t width,
        std::uint32_t height,
        const Sampler *sampler,
        TextureUsage usage,
        std::uint32_t index);

    virtual ~Texture() = 0;

    Texture(const Texture &) = delete;
    Texture &operator=(const Texture &) = delete;

    /**
     * Get the raw image data.
     *
     * @returns
     *   Raw image data.
     */
    const DataBuffer &data() const;

    /**
     * Get the width of the image.
     *
     * @returns
     *   Image width.
     */
    std::uint32_t width() const;

    /**
     * Get the height of the image.
     *
     * @returns
     *   Image height.
     */
    std::uint32_t height() const;

    /**
     * Get texture sampler.
     *
     * @returns
     *   Sampler for texture.
     */
    const Sampler *sampler() const;

    /**
     * Get the texture usage.
     *
     * @returns
     *   Texture usage.
     */
    TextureUsage usage() const;

    /**
     * Get index into global array of all allocated textures.
     *
     * This is most useful for bindless texturing as the texture knows where in the mapped texture table to find itself.
     *
     * @returns
     *   Index of texture.
     */
    std::uint32_t index() const;

    /**
     * Whether the texture contains any transparent pixels.
     *
     * @returns
     *   True if texture has transparency, otherwise false.
     */
    bool has_transparency() const;

  protected:
    /** Raw image data. */
    DataBuffer data_;

    /** Image width. */
    std::uint32_t width_;

    /** Image height. */
    std::uint32_t height_;

    /** Sampler for texture. */
    const Sampler *sampler_;

    /** Texture usage. */
    TextureUsage usage_;

    /** Index into the global array of all allocated textures. */
    std::uint32_t index_;

    /** Whether texture has transparency. */
    bool has_transparency_;
};

}

```

`include/iris/graphics/texture_manager.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <memory>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <vector>

#include "core/colour.h"
#include "core/data_buffer.h"
#include "core/resource_manager.h"
#include "graphics/cube_map.h"
#include "graphics/sampler.h"
#include "graphics/texture.h"
#include "graphics/texture_usage.h"

namespace iris
{

/**
 * Abstract class for creating and managing Texture/CubeMap objects. This class handles caching and lifetime management
 * of all created objects. Implementers just need to provide a graphics API specific method for creating Texture
 * objects.
 */
class TextureManager
{
  public:
    TextureManager(ResourceManager &resource_manager);
    virtual ~TextureManager() = default;

    /**
     * Load a texture from the supplied file. Will use ResourceManager.
     *
     * This function uses caching, so loading the same resource more than once will return the same handle.
     *
     * @param resource
     *   File to load.
     *
     * @param usage
     *   The usage of the texture. Default is IMAGE i.e. something that will be rendered. If Texture represents
     *   something like a normal or height map the DATA should be used.
     *
     * @param sampler
     *   Sampler to sue for texture, if nullptr the default sampler will be used.
     *
     * @returns
     *   Pointer to loaded texture.
     */
    Texture *load(
        const std::string &resource,
        TextureUsage usage = TextureUsage::IMAGE,
        const Sampler *sampler = nullptr);

    /**
     * Load a CubeMap from the supplied file. Will use ResourceManager.
     *
     * This function uses caching, so loading the same series of six resources more than once will return the same
     * handle.
     *
     * @param right_resource
     *   File to load for right face of cube.
     *
     * @param left_resource
     *   File to load for left face of cube.
     *
     * @param top_resource
     *   File to load for top face of cube.
     *
     * @param bottom_resource
     *   File to load for bottom face of cube.
     *
     * @param back_resource
     *   File to load for back face of cube.
     *
     * @param front_resource
     *   File to load for front face of cube.
     *
     * @param sampler
     *   Sampler to sue for texture, if nullptr the default sampler will be used.
     *
     * @returns
     *   Pointer to loaded CubeMap.
     */
    CubeMap *load(
        const std::string &right_resource,
        const std::string &left_resource,
        const std::string &top_resource,
        const std::string &bottom_resource,
        const std::string &back_resource,
        const std::string &front_resource,
        const Sampler *sampler = nullptr);

    /**
     * Create a texture from a DataBuffer.
     *
     * @param data
     *   Raw data of image, in pixel_format.
     *
     * @param width
     *   Width of image.
     *
     * @param height
     *   Height of image.
     *
     * @param usage
     *   The usage of the texture.
     *
     * @param sampler
     *   Sampler to sue for texture, if nullptr the default sampler will be used.
     *
     * @returns
     *   Pointer to created texture.
     */
    Texture *create(
        const DataBuffer &data,
        std::uint32_t width,
        std::uint32_t height,
        TextureUsage usage,
        const Sampler *sampler = nullptr);

    /**
     * Create a CubeMap from six DataBuffers (one for each face).
     *
     * @param right_data
     *   Image data for right face of cube.
     *
     * @param right_data
     *   Image data for right face of cube.
     *
     * @param left_data
     *   Image data for left face of cube.
     *
     * @param top_data
     *   Image data for top face of cube.
     *
     * @param bottom_data
     *   Image data for bottom face of cube.
     *
     * @param back_data
     *   Image data for back face of cube.
     *
     * @param front_data
     *   Image data for front face of cube.
     *
     * @param width
     *   Width of each image face.
     *
     * @param height
     *   Height of each image face.
     *
     * @param sampler
     *   Sampler to sue for texture, if nullptr the default sampler will be used.
     *
     * @returns
     *   Pointer to created CubeMap.
     */
    CubeMap *create(
        const DataBuffer &right_data,
        const DataBuffer &left_data,
        const DataBuffer &top_data,
        const DataBuffer &bottom_data,
        const DataBuffer &near_data,
        const DataBuffer &far_data,
        std::uint32_t width,
        std::uint32_t height,
        const Sampler *sampler = nullptr);

    /**
     * Create a CubeMap with a vertical gradient.
     *
     * @param start
     *   Bottom colour.
     *
     * @param end
     *   Top colour.
     *
     * @param width
     *   Width of each image face.
     *
     * @param height
     *   Height of each image face.
     *
     * @param sampler
     *   Sampler to sue for texture, if nullptr the default sampler will be used.
     *
     * @returns
     *   Pointer to created CubeMap.
     */
    CubeMap *create(
        const Colour &start,
        const Colour &end,
        std::uint32_t width,
        std::uint32_t height,
        const Sampler *sampler = nullptr);

    /**
     * Create a Sampler.
     *
     * @param descriptor
     *   Description of sampler.
     *
     * @returns
     *   Pointer to created Sampler.
     */
    Sampler *create(const SamplerDescriptor &descriptor);

    /**
     * Unloaded the supplied texture (if there are no other references to it).
     *
     * Normally we would want textures to stay loaded to avoid excess loads. However in some cases it may be necessary
     * to unload a texture (if we know we don't want to use it again).
     *
     * This function decrements an internal reference count and will only actually unload texture memory if that
     * reference count reaches 0.
     *
     * @param texture
     *   Texture to unload.
     */
    void unload(const Texture *texture);

    /**
     * Unloaded the supplied CubeMap (if there are no other references to it).
     *
     * Normally we would want CubeMaps to stay loaded to avoid excess loads. However in some cases it may be necessary
     * to unload a CubeMap (if we know we don't want to use it again).
     *
     * This function decrements an internal reference count and will only actually unload texture memory if that
     * reference count reaches 0.
     *
     * @param cube_map
     *   CubeMap to unload.
     */
    void unload(const CubeMap *cube_map);

    /**
     * Unloaded the supplied Sampler (if there are no other references to it).
     *
     * Normally we would want samplers to stay loaded to avoid excess loads. However in some cases it may be necessary
     * to unload a sampler (if we know we don't want to use it again).
     *
     * This function decrements an internal reference count and will only actually unload if that reference count
     * reaches 0.
     *
     * @param sampler
     *   Sampler to unload.
     */
    void unload(const Sampler *sampler);

    /**
     * Get a blank 1x1 white texture
     *
     * @returns
     *   Blank texture.
     */
    Texture *blank_texture();

    /**
     * Get a blank white cube_map
     *
     * @returns
     *   Blank cube map.
     */
    CubeMap *blank_cube_map();

    /**
     * Default sampler to use for textures.
     *
     * @returns
     *   Default sampler.
     */
    Sampler *default_texture_sampler();

    /**
     * Default sampler to use for cube maps.
     *
     * @returns
     *   Default sampler.
     */
    Sampler *default_cube_map_sampler();

    /**
     * Get the next available index for a new texture.
     *
     * @returns
     *   Next available index.
     */
    std::uint32_t next_texture_index();

    /**
     * Get the next available index for a new cube map.
     *
     * @returns
     *   Next available index.
     */
    std::uint32_t next_cube_map_index();

    /**
     * Get the next available index for a new sampler.
     *
     * @returns
     *   Next available index.
     */
    std::uint32_t next_sampler_index();

    /**
     * Get a copy of all Texture pointers (sorted by index).
     *
     * @return
     *   All Texture pointers.
     */
    std::vector<const Texture *> textures() const;

    /**
     * Get a copy of all CubeMap pointers (sorted by index).
     *
     * @return
     *   All CubeMap pointers.
     */
    std::vector<const CubeMap *> cube_maps() const;

    /**
     * Get a copy of all Sampler pointers (sorted by index).
     *
     * @return
     *   All Sampler pointers.
     */
    std::vector<const Sampler *> samplers() const;

  protected:
    /**
     * Create a Texture object with the provided data.
     *
     * @param data
     *   Raw data of image, in pixel_format.
     *
     * @param width
     *   Width of image.
     *
     * @param height
     *   Height of image.
     *
     * @param sampler
     *   Sampler to use for this texture.
     *
     * @param usage
     *   Usage of the texture.
     *
     * @param index
     *   Index into the global array of all allocated textures.
     *
     * @returns
     *   Created texture.
     */
    virtual std::unique_ptr<Texture> do_create(
        const DataBuffer &data,
        std::uint32_t width,
        std::uint32_t height,
        const Sampler *sampler,
        TextureUsage usage,
        std::uint32_t index) = 0;

    /**
     * Create a CubeMap from six DataBuffers (one for each face).
     *
     * @param right_data
     *   Image data for right face of cube.
     *
     * @param right_data
     *   Image data for right face of cube.
     *
     * @param left_data
     *   Image data for left face of cube.
     *
     * @param top_data
     *   Image data for top face of cube.
     *
     * @param bottom_data
     *   Image data for bottom face of cube.
     *
     * @param back_data
     *   Image data for back face of cube.
     *
     * @param front_data
     *   Image data for front face of cube.
     *
     * @param width
     *   Width of each image face.
     *
     * @param height
     *   Height of each image face.
     *
     * @param sampler
     *   Sampler to use for this texture.
     *
     * @param index
     *   Index into the global array of all allocated textures.
     *
     * @returns
     *   Created CubeMap.
     */
    virtual std::unique_ptr<CubeMap> do_create(
        const DataBuffer &right_data,
        const DataBuffer &left_data,
        const DataBuffer &top_data,
        const DataBuffer &bottom_data,
        const DataBuffer &near_data,
        const DataBuffer &far_data,
        std::uint32_t width,
        std::uint32_t height,
        const Sampler *sampler,
        std::uint32_t index) = 0;

    virtual std::unique_ptr<Sampler> do_create(const SamplerDescriptor &descriptor, std::uint32_t index) = 0;

    /**
     * Implementers should override this method to provide implementation specific unloading logic. Called automatically
     * when a Texture is being unloaded (after its reference count is zero), default is a no-op.
     *
     * @param texture
     *   Texture about to be unloaded.
     */
    virtual void destroy(const Texture *texture);

    /**
     * Implementers should override this method to provide implementation specific unloading logic. Called automatically
     * when a CubeMap is being unloaded (after its reference count is zero), default is a no-op.
     *
     * @param cube_map
     *  CubeMap about to be unloaded.
     */
    virtual void destroy(const CubeMap *cube_map);

    /**
     * Implementers should override this method to provide implementation specific unloading logic. Called automatically
     * when a Sampler is being unloaded (after its reference count is zero), default is a no-op.
     *
     * @param sampler
     *  Sampler about to be unloaded.
     */
    virtual void destroy(const Sampler *sampler);

  private:
    /**
     * Support struct to store a loaded Texture and a reference count.
     */
    template <class T>
    struct LoadedAsset
    {
        std::size_t ref_count;
        std::unique_ptr<T> asset;
    };

    /** Resource manager object. */
    ResourceManager &resource_manager_;

    /** Collection of loaded textures. */
    std::unordered_map<std::string, LoadedAsset<Texture>> loaded_textures_;

    /** Collection of loaded CubeMaps. */
    std::unordered_map<std::string, LoadedAsset<CubeMap>> loaded_cube_maps_;

    /** Collection of loaded Samplers. */
    std::unordered_map<SamplerDescriptor, LoadedAsset<Sampler>> loaded_samplers_;

    /** Next index to use (if free list is empty). */
    std::uint32_t texture_index_counter_;

    /** Collection of returned indices (which will be recycled). */
    std::vector<std::uint32_t> texture_index_free_list_;

    /** Next index to use (if free list is empty). */
    std::uint32_t cube_map_index_counter_;

    /** Collection of returned indices (which will be recycled). */
    std::vector<std::uint32_t> cube_map_index_free_list_;

    /** Next index to use (if free list is empty). */
    std::uint32_t sampler_index_counter_;

    /** Collection of returned indices (which will be recycled). */
    std::vector<std::uint32_t> sampler_index_free_list_;
};

}

```

`include/iris/graphics/texture_usage.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>

namespace iris
{

/**
 * Encapsulation of the semantic usage of textures.
 */
enum class TextureUsage : std::uint8_t
{
    IMAGE,
    DATA,
    RENDER_TARGET,
    DEPTH
};

}

```

`include/iris/graphics/utils.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <vector>

#include "core/data_buffer.h"

namespace iris
{

/**
 * Struct encapsulating data at a mip level.
 */
struct MipLevelData
{
    /** Image data. */
    DataBuffer data;

    /** Width of mip level (in pixels). */
    std::uint32_t width;

    /** Height of mip level (in pixels). */
    std::uint32_t height;
};

/**
 * Generate mipmaps from a starting level down to a 1x1 pixel.
 *
 * Note that the supplied level will always be the first entry in the returned collection.
 *
 * The algorithm used is a simple downsize by averaging the values of a 2x2 kernel.
 *
 * @param start_level
 *   The first level of the mipmap chain, this is assumed to be the original full sized texture.
 *
 * @returns
 *   Collection of MipLevelData objects where each subsequent entry is half the size of the preceding one.
 */
std::vector<MipLevelData> generate_mip_maps(const MipLevelData &start_level);

}

```

`include/iris/graphics/vertex_attributes.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <vector>

#include "core/vector3.h"

namespace iris
{

/**
 * Enumeration of attribute types.
 */
enum class VertexAttributeType
{
    FLOAT_3,
    FLOAT_4,
    UINT32_1,
    UINT32_4
};

/**
 * Struct encapsulating data needed to describe a vertex attribute.
 */
struct VertexAttribute
{
    /** Attribute type. */
    VertexAttributeType type;

    /** Number of components in attribute, typically 1, 2, 3 or 4. */
    std::size_t components;

    /** Size of attribute (size(type) * components). */
    std::size_t size;

    /** Number of bytes from start of attribute collection. */
    std::size_t offset;
};

/**
 * Class encapsulating a series of vertex attributes. These describe how to
 * interpret a vertex buffer, which is just a series of bytes.
 */
class VertexAttributes
{
  public:
    //  useful aliases
    using attributes = std::vector<VertexAttribute>;
    using const_iterator = attributes::const_iterator;

    /**
     * Construct a new VertexAttributes.
     *
     * @param attributes
     *   Collection of attributes.
     */
    VertexAttributes(const std::vector<VertexAttributeType> &attributes);

    /**
     * Get size of all attributes. This will be the same as the size of a buffer
     * containing all vertex data.
     *
     * @returns
     *   Size of attributes.
     */
    std::size_t size() const;

    /**
     * Get iterator to start if attributes.
     *
     * Note that this class is immutable so this returns a const_iterator.
     *
     * @returns
     *   Iterator to start of attributes.
     */
    const_iterator begin() const;

    /**
     * Get iterator to end if attributes.
     *
     * Note that this class is immutable so this returns a const_iterator.
     *
     * @returns
     *   Iterator to end of attributes.
     */
    const_iterator end() const;

    /**
     * Get iterator to start if attributes.
     *
     * @returns
     *   Iterator to start of attributes.
     */
    const_iterator cbegin() const;

    /**
     * Get iterator to end if attributes.
     *
     * @returns
     *   Iterator to end of attributes.
     */
    const_iterator cend() const;

  private:
    /** Collection of attributes. */
    std::vector<VertexAttribute> attributes_;

    /** Size of attributes. */
    std::size_t size_;
};

}

```

`include/iris/graphics/vertex_data.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include "core/colour.h"
#include "core/vector3.h"
#include "graphics/bone.h"
#include "graphics/vertex_attributes.h"

namespace iris
{

/**
 * Struct encapsulating all data needed to render a vertex. This automatically
 * pads fields required by some graphics APIs.
 */
struct VertexData
{
    VertexData() = default;

    /**
     * Create a new VertexData.
     *
     * @param position
     *   The position of the vertex.
     *
     * @param normal
     *   The normal of the vertex.
     *
     * @param colour
     *   Colour of the vertex.
     *
     * @param texture_coords
     *   Coordinates of texture.
     */
    VertexData(const Vector3 &position, const Vector3 &normal, const Colour &colour, const Vector3 &texture_coords)
        : VertexData(
              position,
              normal,
              colour,
              texture_coords,
              {},
              {},
              {{{0u, 1.0f}, {0u, 0.0f}, {0u, 0.0f}, {0u, 0.0f}}})
    {
    }

    VertexData(
        const Vector3 &position,
        const Vector3 &normal,
        const Colour &colour,
        const Vector3 &texture_coords,
        const Vector3 &tangent,
        const Vector3 &bitangent)
        : VertexData(
              position,
              normal,
              colour,
              texture_coords,
              tangent,
              bitangent,
              {{{0u, 1.0f}, {0u, 0.0f}, {0u, 0.0f}, {0u, 0.0f}}})
    {
    }

    VertexData(
        const Vector3 &position,
        const Vector3 &normal,
        const Colour &colour,
        const Vector3 &texture_coords,
        const Vector3 &tangent,
        const Vector3 &bitangent,
        std::array<Weight, 4u> weights)
        : position(position)
        , pos_w(1.0f)
        , normal(normal)
        , normal_w(0.0f)
        , colour(colour)
        , texture_coords(texture_coords)
        , padding(1.0f)
        , tangent(tangent)
        , tangent_w(0.0f)
        , bitangent(bitangent)
        , bitangent_w(0.0f)
        , bone_ids({})
        , bone_weights({})
    {
        for (auto i = 0u; i < weights.size(); ++i)
        {
            bone_ids[i] = weights[i].vertex;
            bone_weights[i] = weights[i].weight;
        }
    }

    /** Vertex position. */
    Vector3 position;

    /** w component so we can pass position as 4 floats. */
    float pos_w;

    /** Vertex normal. */
    Vector3 normal;

    /** w component so we can pass normal as 4 floats. */
    float normal_w;

    /** Vertex colour. */
    Colour colour;

    /** Texture coordinates. */
    Vector3 texture_coords;

    /** Padding so we can pass normal as 4 floats. */
    float padding;

    /** Normal tangent. */
    Vector3 tangent;

    /** Padding so we can pass normal as 4 floats. */
    float tangent_w;

    /** Normal bitangent tangent. */
    Vector3 bitangent;

    /** Padding so we can pass normal as 4 floats. */
    float bitangent_w;

    /** Array of bone ids. */
    std::array<std::uint32_t, 4u> bone_ids;

    /** Array of bone weights. */
    std::array<float, 4u> bone_weights;
};

/**
 * VertexAttributes for above struct.
 */
static VertexAttributes DefaultVertexAttributes{
    {VertexAttributeType::FLOAT_4,
     VertexAttributeType::FLOAT_4,
     VertexAttributeType::FLOAT_4,
     VertexAttributeType::FLOAT_4,
     VertexAttributeType::FLOAT_4,
     VertexAttributeType::FLOAT_4,
     VertexAttributeType::UINT32_4,
     VertexAttributeType::FLOAT_4}};

}

```

`include/iris/graphics/weight.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>

namespace iris
{

/**
 * A struct encapsulating how much influence a bone has over a vertex (i.e. it's
 * weight).
 */
struct Weight
{
    /** Vertex index.*/
    std::uint32_t vertex;

    /** Influence. */
    float weight;

    /** Name of bone weight is for. */
    std::string bone_name;
};

}

```

`include/iris/graphics/win32/win32_d3d12_window.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>

#include "graphics/material_manager.h"
#include "graphics/texture_manager.h"
#include "graphics/win32/win32_window.h"
#include "graphics/window_manager.h"

namespace iris
{

/**
 * Implementation of Win32Window for d3d12.
 */
class Win32D3D12Window : public Win32Window
{
  public:
    /**
     * Create a Win32D3D12Window.
     *
     * @param window_manager
     *   Window manager object.
     *
     * @param texture_manager
     *   Texture manager object.
     *
     * @param material_manager
     *   Material manager object.
     *
     * @param width
     *   Width of window.
     *
     * @param height
     *   Height of window.
     */
    Win32D3D12Window(
        WindowManager &window_manager,
        TextureManager &texture_manager,
        MaterialManager &material_manager,
        std::uint32_t width,
        std::uint32_t height);
};

}

```

`include/iris/graphics/win32/win32_opengl_window.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>

#include "graphics/material_manager.h"
#include "graphics/texture_manager.h"
#include "graphics/win32/win32_window.h"
#include "graphics/window_manager.h"

namespace iris
{

/**
 * Implementation of Win32Window for OpenGL.
 */
class Win32OpenGLWindow : public Win32Window
{
  public:
    /**
     * Create a Win32OpenGLWindow.
     *
     * @param window_manager
     *   Window manager object.
     *
     * @param texture_manager
     *   Texture manager object.
     *
     * @param material_manager
     *   Material manager object.
     *
     * @param width
     *   Width of window.
     *
     * @param height
     *   Height of window.
     */
    Win32OpenGLWindow(
        WindowManager &window_manager,
        TextureManager &texture_manager,
        MaterialManager &material_manager,
        std::uint32_t width,
        std::uint32_t height);
};

}

```

`include/iris/graphics/win32/win32_window.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <optional>

#define WIN32_LEAN_AND_MEAN
#include <Windows.h>

#include "core/auto_release.h"
#include "events/event.h"
#include "graphics/window.h"

namespace iris
{

/**
 * Abstract implementation of Window for win32. This class has concrete
 * implementations for each supported graphics api.
 */
class Win32Window : public Window
{
  public:
    // helper aliases
    using AutoWindow = iris::AutoRelease<HWND, nullptr>;
    using AutoDC = iris::AutoRelease<HDC, nullptr>;

    /**
     * Construct a new Win32Window.
     *
     * @param width
     *   Width of window.
     *
     * @param height
     *   Height of window.
     */
    Win32Window(std::uint32_t width, std::uint32_t height);
    ~Win32Window() override = default;

    /**
     * Get the natural scale for the screen. This value reflects the scale
     * factor needed to convert from the default logical coordinate space into
     * the device coordinate space of this screen.
     *
     * @returns
     *   Screen scale factor.
     */
    std::uint32_t screen_scale() const override;

    /**
     * Pump the next user input event. Result will be empty if there are no
     * new events.
     *
     * @returns
     *   Optional event.
     */
    std::optional<Event> pump_event() override;

    /**
     * Get device context handle.
     *
     * @returns
     *   Device context handle.
     */
    HDC device_context() const;

    /**
     * Get DPI of screen window is on.
     *
     * @returns
     *   Screen DPI.
     */
    std::uint32_t dpi() const;

  protected:
    /** Win32 window handle. */
    AutoWindow window_;

    /** Win32 device context handle. */
    AutoDC dc_;

    /** Win32 window class object. */
    WNDCLASSA wc_;
};

}

```

`include/iris/graphics/win32/win32_window_manager.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <memory>
#include <string>

#include "graphics/material_manager.h"
#include "graphics/texture_manager.h"
#include "graphics/window.h"
#include "graphics/window_manager.h"

namespace iris
{

/**
 * Implementation of WindowManager for win32.
 */
class Win32WindowManager : public WindowManager
{
  public:
    /**
     * @param texture_manager
     *   Texture manager object.
     *
     * @param material_manager
     *   Material manager object.
     *
     * @param graphics_api
     *   The graphics api to create a window for.
     */
    Win32WindowManager(
        TextureManager &texture_manager,
        MaterialManager &material_manager,
        const std::string &graphics_api);

    /**
     * Create a new Window.
     *
     * @param width
     *   Width of window.
     *
     * @param height
     *   Height of window.
     */
    Window *create_window(std::uint32_t width, std::uint32_t height) override;

    /**
     * Get the currently active window.
     *
     * @returns
     *   Pointer to current window, nullptr if one does not exist.
     */
    Window *current_window() const override;

  private:
    /** Texture manager object. */
    TextureManager &texture_manager_;

    /** Material manager object. */
    MaterialManager &material_manager_;

    /** Graphics api to create windows for. */
    std::string graphics_api_;

    /** Current window .*/
    std::unique_ptr<Window> current_window_;
};

}

```

`include/iris/graphics/window.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <chrono>
#include <cstdint>
#include <deque>
#include <memory>
#include <optional>

#include "events/event.h"
#include "graphics/render_pass.h"
#include "graphics/render_pipeline.h"
#include "graphics/render_target.h"
#include "graphics/renderer.h"

namespace iris
{

/**
 * Abstract class for a native window.
 */
class Window
{
  public:
    /**
     * Create and display a new native window.
     *
     * @param width
     *   Width of the window.
     *
     * @param height
     *   Height of the window.
     */
    Window(std::uint32_t width, std::uint32_t height);

    virtual ~Window() = default;

    /** Disabled */
    Window(const Window &) = delete;
    Window &operator=(const Window &) = delete;

    /**
     * Pump the next user input event. Result will be empty if there are no
     * new events.
     *
     * @returns
     *   Optional event.
     */
    virtual std::optional<Event> pump_event() = 0;

    /**
     * Render the current scene.
     */
    virtual void render() const;

    /**
     * Get the natural scale for the screen. This value reflects the scale
     * factor needed to convert from the default logical coordinate space into
     * the device coordinate space of this screen.
     *
     * @returns
     *   Screen scale factor.
     */
    virtual std::uint32_t screen_scale() const = 0;

    /**
     * Get the width of the window.
     *
     * @returns
     *   Window width.
     */
    std::uint32_t width() const;

    /**
     * Get the height of the window.
     *
     * @returns
     *   Window height.
     */
    std::uint32_t height() const;

    /**
     * Set the render pipeline to execute with render().
     *
     * @param render_pipeline
     *   Pipeline to execute.
     */
    void set_render_pipeline(std::unique_ptr<RenderPipeline> render_pipeline);

    /**
     * Elapsed time since set_render_pipeline was called. This is also the value that is passed to shaders via TimeNode.
     *
     * @returns
     *   Elapsed time.
     */
    std::chrono::milliseconds time() const;

  protected:
    /** Window width. */
    std::uint32_t width_;

    /** Window height. */
    std::uint32_t height_;

    /** Renderer to use. */
    std::unique_ptr<Renderer> renderer_;
};

}

```

`include/iris/graphics/window_manager.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>

namespace iris
{

class Window;

/**
 * Interface for a class which creates Window objects.
 */
class WindowManager
{
  public:
    virtual ~WindowManager() = default;

    /**
     * Create a new Window.
     *
     * @param width
     *   Width of window.
     *
     * @param height
     *   Height of window.
     */
    virtual Window *create_window(std::uint32_t width, std::uint32_t height) = 0;

    /**
     * Get the currently active window.
     *
     * @returns
     *   Pointer to current window, nullptr if one does not exist.
     */
    virtual Window *current_window() const = 0;
};

}

```

`include/iris/iris_version.h.in`:

```in
#pragma once

#define IRIS_VERSION_MAJOR @iris_VERSION_MAJOR@
#define IRIS_VERSION_MINOR @iris_VERSION_MINOR@
#define IRIS_VERSION_PATCH @iris_VERSION_PATCH@
#define IRIS_VERSION_MAJOR_STR "@iris_VERSION_MAJOR@"
#define IRIS_VERSION_MINOR_STR "@iris_VERSION_MINOR@"
#define IRIS_VERSION_PATCH_STR "@iris_VERSION_PATCH@"
#define IRIS_VERSION_STR IRIS_VERSION_MAJOR_STR "." IRIS_VERSION_MINOR_STR "." IRIS_VERSION_PATCH_STR


```

`include/iris/jobs/arch/x86_64/context.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

/**
 * This is an incomplete file and is intended to be included in
 * include/jobs/context.h
 *
 * *DO NOT* include this file directly
 */

/**
 * x86_64 context, registers that need to be preserved when suspending a
 * function.
 */
struct Context
{
    void *rbx = nullptr;
    void *rbp = nullptr;
    void *rsp = nullptr;
    void *rip = nullptr;
    void *r12 = nullptr;
    void *r13 = nullptr;
    void *r14 = nullptr;
    void *r15 = nullptr;
};

```

`include/iris/jobs/arch/x86_64/functions.S`:

```S
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

.intel_syntax noprefix

#if defined(IRIS_PLATFORM_MACOS)
.section __TEXT,__text
#define GLOBAL(X) .globl _##X 
#define LABEL(X) _##X:
#else
.section .text
#define GLOBAL(X) .globl X 
#define LABEL(X) X:
#endif

/**
 * Change stack, performs all necessary patching such that the function can
 * return to the caller.
 *
 * @param rdi
 *   Pointer to new stack.
 */
GLOBAL(change_stack)
LABEL(change_stack)

push rax # stack alignment

mov r9, rbp
mov r8, [rbp] # get base-pointer for previous frame
sub r8, rbp # get offset between this and previous frame

mov rdx, rbp
sub rdx, rsp # get size of current frame
mov rax, rdi # preserve new stack address

# copy old stack to new stack
cld
mov rsi, rsp
mov rcx, 1024
rep movsb

mov rsp, rax # switch to new stack
mov rbp, rax # copy stack to base pointer
add rbp, rdx # restore stack frame by offseting base pointer the same amout as
             # when we entered the function

# patch base pointer for previous frame to point back into our new stack, this
# allows us one function return after this function
mov rax, r8
add r8, rbp
mov [rbp], r8

pop rax # stack alignment

ret

/**
 * Save current context.
 *
 * @param context
 *   Pointer to struct to save registers.
 */
GLOBAL(save_context)
LABEL(save_context)
mov [rdi], rbx
mov [rdi + 8], rbp
mov [rdi + 16], rsp
lea rax, [rip+end] # store end of this function in rip
mov [rdi + 24], rax
mov [rdi + 32], r12
mov [rdi + 40], r13
mov [rdi + 48], r14
mov [rdi + 56], r15
end:
ret

/**
 * Restore context.
 *
 * @param context
 *   Pointer to struct with registers to restore.
 */
GLOBAL(restore_context)
LABEL(restore_context)
mov rbx, [rdi]
mov rbp, [rdi + 8]
mov rsp, [rdi + 16]
mov r12, [rdi + 32]
mov r13, [rdi + 40]
mov r14, [rdi + 48]
mov r15, [rdi + 56]
mov rax, [rdi + 24]
jmp rax



```

`include/iris/jobs/concurrent_queue.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <atomic>
#include <deque>
#include <mutex>

#include "core/exception.h"

namespace iris
{

/**
 * A container adaptor for a thread-safe FIFO queue.
 */
template <class T, class Container = std::deque<T>>
class ConcurrentQueue
{
  public:
    // member types
    using container_type = Container;
    using size_type = typename Container::size_type;
    using value_type = typename Container::value_type;
    using reference = typename Container::reference;

    /**
     * Construct an empty queue.
     */
    ConcurrentQueue()
        : container_()
        , mutex_()
        , empty_(true)
    {
    }

    /**
     * Check if the queue is empty.
     *
     * @returns
     *   True if queue is empty, else false.
     */
    bool empty() const
    {
        return empty_;
    }

    /**
     * Add an item to the end of the queue.
     *
     * @param args
     *   Arguments for object being places in queue, will be
     *   perfectly forwarded.
     */
    template <class... Args>
    void enqueue(Args &&...args)
    {
        std::unique_lock lock(mutex_);

        container_.emplace_back(std::forward<Args>(args)...);

        empty_ = false;
    }

    /**
     * Tries to pop the next element off the queue.
     *
     * @param element
     *   Reference to store popped element.
     *
     * @returns
     *   True if an element could be dequeued, false otherwise.
     */
    bool try_dequeue(reference element)
    {
        auto dequeued = false;

        std::unique_lock lock(mutex_, std::try_to_lock);

        if (!empty_ && lock.owns_lock())
        {
            element = std::move(container_.front());
            container_.pop_front();

            empty_ = container_.empty();
            dequeued = true;
        }

        return dequeued;
    }

    /**
     * Pops the next element off the queue. Blocks until it can perform
     * operation.
     *
     * @returns
     *   Popped element.
     */
    value_type dequeue()
    {
        std::unique_lock lock(mutex_);

        value_type value(std::move(container_.front()));
        container_.pop_front();

        empty_ = container_.empty();

        return value;
    }

  private:
    /** Queue container. */
    container_type container_;

    /** Mutex for queue. */
    std::mutex mutex_;

    /** Flag indicating whether queue is empty. */
    std::atomic<bool> empty_;
};

}

```

`include/iris/jobs/context.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

namespace iris
{

// include arch specific files

#if defined(IRIS_ARCH_X86_64)
#include "jobs/arch/x86_64/context.h"
#else
#error unsupported architecture
#endif

}

```

`include/iris/jobs/fiber/counter.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <atomic>
#include <mutex>

namespace iris
{

/**
 * A thread-safe counter. Can be decremented and checked.
 */
class Counter
{
  public:
    /**
     * Construct counter with initial value.
     *
     * @param value
     *   Initial value of counter.
     */
    explicit Counter(int value);

    // disable copy and move
    Counter(const Counter &) = delete;
    Counter &operator=(const Counter &) = delete;
    Counter(Counter &&) = delete;
    Counter &operator=(Counter &&) = delete;

    /**
     * Cast counter value to int.
     *
     * @returns
     *   Value of counter.
     */
    operator int();

    /**
     * Prefix decrement counter.
     */
    void operator--();

    /**
     * Postfix decrement counter.
     */
    void operator--(int);

  private:
    /** Value of counter. */
    int value_;

    /** Lock for object. */
    std::mutex mutex_;
};

}

```

`include/iris/jobs/fiber/fiber.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <atomic>
#include <cstddef>
#include <memory>

#include "core/static_buffer.h"
#include "jobs/fiber/counter.h"
#include "jobs/job.h"

namespace iris
{

/*
 * A Fiber is a user-land thread. It maintains it's own stack and can be
 * suspended and resumed (cooperative multi-threading). A Fiber will be started
 * from a thread but can be suspended and resumed from a different one. In
 * general one should not have to manually create Fibers, they are an internal
 * class. For parallelising work the JobSystem should be used.
 */
class Fiber
{
  public:
    /**
     * Construct a Fiber with a job to run.
     *
     * @param job
     *   Job to run.
     */
    explicit Fiber(Job job);

    /**
     * Construct a Fiber with a job and a counter.
     *
     * @param job
     *   Job to run.
     *
     * @param counter
     *   Counter to decrement when job is done.
     */
    Fiber(Job job, Counter *counter);

    ~Fiber();

    Fiber(const Fiber &) = delete;
    Fiber &operator=(const Fiber &) = delete;
    Fiber(Fiber &&other) = delete;
    Fiber &operator=(Fiber &&other) = delete;

    /**
     * Start the fiber.
     */
    void start();

    /**
     * Suspends a Fibers execution, execution will continue from where
     * start was called.
     */
    void suspend();

    /**
     * Resume a suspended Fiber. Execution will continue from where suspend
     * was called.
     *
     * It is undefined behavior to resume a non-suspended Fiber.
     */
    void resume();

    /**
     * Check if a Fiber is safe to call methods on. It is only not safe when it
     * has been suspended but not yet restored its original context.
     *
     * @returns
     *   True if this Fiber is safe false otherwise.
     */
    bool is_safe() const;

    /**
     * Set fiber to be unsafe.
     */
    void set_unsafe();

    /**
     * Check if another fiber is waiting for this to finish.
     *
     * @returns
     *   True if another fiber is waiting on this, otherwise false.
     */
    bool is_being_waited_on() const;

    /**
     * Get any exception thrown during the execution of this fiber.
     *
     * @returns
     *   exception_ptr to throw exception, nullptr of none were thrown.
     */
    std::exception_ptr exception() const;

    /**
     * Convert current thread to fiber. This must be called once (and only once)
     * on each thread that wants to execute fibers.
     */
    static void thread_to_fiber();

    /**
     * Gets a pointer to the current fiber running on the calling thread.
     * If no Fiber is running then nullptr.
     *
     * @returns
     *   Pointer to pointer to running Fiber, or nullptr if no Fiber is
     *   running.
     */
    static Fiber **this_fiber();

  private:
    /** Job to run in Fiber. */
    Job job_;

    /** optional counter. */
    Counter *counter_;

    /** Optional parent fiber. */
    Fiber *parent_fiber_;

    /** Pointer storing job exception. */
    std::exception_ptr exception_;

    /** Flag if fiber is not safe to operator on. */
    std::atomic<bool> safe_;

    /** Pointer to implementation. */
    struct implementation;
    std::unique_ptr<implementation> impl_;
};

}

```

`include/iris/jobs/fiber/fiber_job_system.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <atomic>
#include <memory>
#include <vector>

#include "core/semaphore.h"
#include "core/thread.h"
#include "jobs/concurrent_queue.h"
#include "jobs/fiber/counter.h"
#include "jobs/fiber/fiber.h"
#include "jobs/job.h"
#include "jobs/job_system.h"

namespace iris
{

/**
 * Implementation of JobSystem that schedules its jobs using fibers.
 */
class FiberJobSystem : public JobSystem
{
  public:
    FiberJobSystem();
    ~FiberJobSystem() override;

    /**
     * Add a collection of jobs. Once added these are executed in a
     * fire-and-forget manner, there is no way to wait on them to finish or
     * to know when they have executed.
     *
     * @param jobs
     *   Jobs to execute.
     */
    void add_jobs(const std::vector<Job> &jobs) override;

    /**
     * Add a collection of jobs. Once added this call blocks until all
     * jobs have finished executing.
     *
     * @param jobs
     *   Jobs to execute.
     */
    void wait_for_jobs(const std::vector<Job> &jobs) override;

  private:
    /** Flag indicating of system is running. */
    std::atomic<bool> running_;

    /** Semaphore signally how many fibers are available. */
    Semaphore jobs_semaphore_;

    /** Worker threads which execute fibers. */
    std::vector<Thread> workers_;

    /** Queue of fibers.*/
    ConcurrentQueue<std::tuple<Fiber *, Counter *>> fibers_;
};

}

```

`include/iris/jobs/fiber/fiber_job_system_manager.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <memory>
#include <vector>

#include "jobs/fiber/fiber_job_system.h"
#include "jobs/job.h"
#include "jobs/job_system_manager.h"

namespace iris
{

/**
 * Implementation of JobSystemManager for FiberJobSystem.
 */
class FiberJobSystemManager : public JobSystemManager
{
  public:
    ~FiberJobSystemManager() override = default;

    /**
     * Create a JobSystem.
     *
     * @returns
     *   Pointer to JobSystem.
     */
    JobSystem *create_job_system() override;

    /**
     * Add a collection of jobs. Once added these are executed in a
     * fire-and-forget manner, there is no way to wait on them to finish or
     * to know when they have executed.
     *
     * @param jobs
     *   Jobs to execute.
     */
    void add(const std::vector<Job> &jobs) override;

    /**
     * Add a collection of jobs. Once added this call blocks until all
     * jobs have finished executing.
     *
     * @param jobs
     *   Jobs to execute.
     */
    void wait(const std::vector<Job> &jobs) override;

  private:
    /** Current JobSystem. */
    std::unique_ptr<FiberJobSystem> job_system_;
};

}

```

`include/iris/jobs/job.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <functional>
#include <ostream>
#include <vector>

namespace iris
{

// convenient alias for a job
using Job = std::function<void()>;

}

```

`include/iris/jobs/job_system.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <vector>

#include "jobs/job.h"

namespace iris
{

/**
 * Interface for a class managing the scheduling and running of jobs.
 */
class JobSystem
{
  public:
    JobSystem() = default;
    virtual ~JobSystem() = default;

    JobSystem(const JobSystem &) = delete;
    JobSystem &operator=(const JobSystem &) = delete;
    JobSystem(JobSystem &&) = delete;
    JobSystem &operator=(JobSystem &&) = delete;

    /**
     * Add a collection of jobs. Once added these are executed in a
     * fire-and-forget manner, there is no way to wait on them to finish or
     * to know when they have executed.
     *
     * @param jobs
     *   Jobs to execute.
     */
    virtual void add_jobs(const std::vector<Job> &jobs) = 0;

    /**
     * Add a collection of jobs. Once added this call blocks until all
     * jobs have finished executing.
     *
     * @param jobs
     *   Jobs to execute.
     */
    virtual void wait_for_jobs(const std::vector<Job> &jobs) = 0;
};

}

```

`include/iris/jobs/job_system_manager.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <vector>

#include "jobs/job.h"
#include "jobs/job_system.h"

namespace iris
{

/**
 * Interface for a class that manages JobSystem objects. This used as part of
 * component registration in the Root.
 */
class JobSystemManager
{
  public:
    virtual ~JobSystemManager() = default;

    /**
     * Create a JobSystem.
     *
     * @returns
     *   Pointer to JobSystem.
     */
    virtual JobSystem *create_job_system() = 0;

    /**
     * Add a collection of jobs. Once added these are executed in a
     * fire-and-forget manner, there is no way to wait on them to finish or
     * to know when they have executed.
     *
     * @param jobs
     *   Jobs to execute.
     */
    virtual void add(const std::vector<Job> &jobs) = 0;

    /**
     * Add a collection of jobs. Once added this call blocks until all
     * jobs have finished executing.
     *
     * @param jobs
     *   Jobs to execute.
     */
    virtual void wait(const std::vector<Job> &jobs) = 0;
};

}

```

`include/iris/jobs/thread/thread_job_system.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <atomic>
#include <memory>
#include <vector>

#include "jobs/job.h"
#include "jobs/job_system.h"

namespace iris
{

/**
 * Implementation of JobSystem that schedules its jobs using threads.
 */
class ThreadJobSystem : public JobSystem
{
  public:
    ThreadJobSystem();
    ~ThreadJobSystem() override = default;

    /**
     * Add a collection of jobs. Once added these are executed in a
     * fire-and-forget manner, there is no way to wait on them to finish or
     * to know when they have executed.
     *
     * @param jobs
     *   Jobs to execute.
     */
    void add_jobs(const std::vector<Job> &jobs) override;

    /**
     * Add a collection of jobs. Once added this call blocks until all
     * jobs have finished executing.
     *
     * @param jobs
     *   Jobs to execute.
     */
    void wait_for_jobs(const std::vector<Job> &jobs) override;

  private:
    /** Flag indicating of system is running. */
    std::atomic<bool> running_;
};

}

```

`include/iris/jobs/thread/thread_job_system_manager.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <memory>
#include <vector>

#include "jobs/job.h"
#include "jobs/job_system_manager.h"
#include "jobs/thread/thread_job_system.h"

namespace iris
{

/**
 * Implementation of JobSystemManager for ThreadJobSystem.
 */
class ThreadJobSystemManager : public JobSystemManager
{
  public:
    ~ThreadJobSystemManager() override = default;

    /**
     * Create a JobSystem.
     *
     * @returns
     *   Pointer to JobSystem.
     */
    JobSystem *create_job_system() override;

    /**
     * Add a collection of jobs. Once added these are executed in a
     * fire-and-forget manner, there is no way to wait on them to finish or
     * to know when they have executed.
     *
     * @param jobs
     *   Jobs to execute.
     */
    void add(const std::vector<Job> &jobs) override;

    /**
     * Add a collection of jobs. Once added this call blocks until all
     * jobs have finished executing.
     *
     * @param jobs
     *   Jobs to execute.
     */
    void wait(const std::vector<Job> &jobs) override;

  private:
    /** Current JobSystem. */
    std::unique_ptr<ThreadJobSystem> job_system_;
};

}

```

`include/iris/log/basic_formatter.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <string>

#include "log/formatter.h"
#include "log/log_level.h"

namespace iris
{

/**
 * Implementation of Formatter which formats log message details as:
 *   L T [t] F:L | M
 *
 *   Where:
 *     L : First letter of log level
 *     T : Time stamp
 *     t : Tag
 *     F : Filename
 *     L : Line number
 *     M : message
 *
 *  Example:
 *    D 17:38:28 [camera] camera.cpp:58 | x: -4.37114e-08 y: 0 z: -1
 */
class BasicFormatter : public Formatter
{
  public:
    /** Default */
    ~BasicFormatter() override = default;

    /**
     * Format the supplied log details into a string.
     *
     * @param level
     *   Log level.
     *
     * @param tag
     *   Tag for log message.
     *
     * @param message
     *   Log message.
     *
     * @param filename
     *   Name of the file logging the message.
     *
     * @param line
     *   Line of the log call in the file.
     */
    std::string format(
        const LogLevel level,
        const std::string &tag,
        const std::string &message,
        const std::string &filename,
        const int line) override;
};

}

```

`include/iris/log/colour_formatter.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <string>

#include "log/basic_formatter.h"
#include "log/formatter.h"
#include "log/log_level.h"

namespace iris
{

/**
 * Implementation of Formatter which applies colour to basic formatter.
 */
class ColourFormatter : public Formatter
{
  public:
    /** Default */
    ~ColourFormatter() override = default;

    /**
     * Format the supplied log details into a string.
     *
     * @param level
     *   Log level.
     *
     * @param tag
     *   Tag for log message.
     *
     * @param message
     *   Log message.
     *
     * @param filename
     *   Name of the file logging the message.
     *
     * @param line
     *   Line of the log call in the file.
     */
    std::string format(
        const LogLevel level,
        const std::string &tag,
        const std::string &message,
        const std::string &filename,
        const int line) override;

  private:
    /** Use BasicFormatter for formatting. */
    BasicFormatter formatter_;
};

}

```

`include/iris/log/emoji_formatter.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <string>

#include "log/basic_formatter.h"
#include "log/formatter.h"
#include "log/log_level.h"

namespace iris
{

/**
 * Implementation of Formatter which prepends messages with emojis. Useful for
 * consoles which do not support colour (e.g. Xcode).
 */
class EmojiFormatter : public Formatter
{
  public:
    /** Default */
    ~EmojiFormatter() override = default;

    /**
     * Format the supplied log details into a string.
     *
     * @param level
     *   Log level.
     *
     * @param tag
     *   Tag for log message.
     *
     * @param message
     *   Log message.
     *
     * @param filename
     *   Name of the file logging the message.
     *
     * @param line
     *   Line of the log call in the file.
     */
    std::string format(
        const LogLevel level,
        const std::string &tag,
        const std::string &message,
        const std::string &filename,
        const int line) override;

  private:
    /** Use BasicFormatter for formatting. */
    BasicFormatter formatter_;
};

}

```

`include/iris/log/file_outputter.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <fstream>
#include <string>

#include "log/outputter.h"

namespace iris
{

/**
 * Implementation of Outputter which writes log messages to filet.
 */
class FileOutputter : public Outputter
{
  public:
    /** Default */
    ~FileOutputter() override = default;

    /**
     * Construct a new file_outputter.
     *
     * @param filename
     *   Name of log file to write to.
     */
    explicit FileOutputter(const std::string &filename);

    /**
     * Output log.
     *
     * @param log
     *   Log message to output.
     */
    void output(const std::string &log) override;

  private:
    /** File stream to write to. */
    std::ofstream file_;
};

}

```

`include/iris/log/formatter.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <string>

#include "log/log_level.h"

namespace iris
{

/**
 * Interface for a formatter, a class which takes log message details and
 * formats them into a string.
 */
class Formatter
{
  public:
    /** Default */
    virtual ~Formatter() = default;

    /**
     * Format the supplied log details into a string.
     *
     * @param level
     *   Log level.
     *
     * @param tag
     *   Tag for log message.
     *
     * @param message
     *   Log message.
     *
     * @param filename
     *   Name of the file logging the message.
     *
     * @param line
     *   Line of the log call in the file.
     */
    virtual std::string format(
        const LogLevel level,
        const std::string &tag,
        const std::string &message,
        const std::string &filename,
        const int line) = 0;
};

}

```

`include/iris/log/log.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include "log/log_level.h"
#include "log/logger.h"

#if !defined(NDEBUG)

// convenient macros for logging
#define LOG_DEBUG(T, ...) iris::Logger::instance().log(iris::LogLevel::DEBUG, T, __FILE__, __LINE__, false, __VA_ARGS__)
#define LOG_INFO(T, ...) iris::Logger::instance().log(iris::LogLevel::INFO, T, __FILE__, __LINE__, false, __VA_ARGS__)
#define LOG_WARN(T, ...) iris::Logger::instance().log(iris::LogLevel::WARN, T, __FILE__, __LINE__, false, __VA_ARGS__)
#define LOG_ERROR(T, ...) iris::Logger::instance().log(iris::LogLevel::ERR, T, __FILE__, __LINE__, false, __VA_ARGS__)

// convenient macros for engine logging
#define LOG_ENGINE_DEBUG(T, ...)                                                                                       \
    iris::Logger::instance().log(iris::LogLevel::DEBUG, T, __FILE__, __LINE__, true, __VA_ARGS__)
#define LOG_ENGINE_INFO(T, ...)                                                                                        \
    iris::Logger::instance().log(iris::LogLevel::INFO, T, __FILE__, __LINE__, true, __VA_ARGS__)
#define LOG_ENGINE_WARN(T, ...)                                                                                        \
    iris::Logger::instance().log(iris::LogLevel::WARN, T, __FILE__, __LINE__, true, __VA_ARGS__)
#define LOG_ENGINE_ERROR(T, ...)                                                                                       \
    iris::Logger::instance().log(iris::LogLevel::ERR, T, __FILE__, __LINE__, true, __VA_ARGS__)

#else

// convenient macros for logging
#define LOG_DEBUG(T, ...)
#define LOG_INFO(T, ...)
#define LOG_WARN(T, ...)
#define LOG_ERROR(T, ...)

// convenient macros for engine logging
#define LOG_ENGINE_DEBUG(T, ...)
#define LOG_ENGINE_INFO(T, ...)
#define LOG_ENGINE_WARN(T, ...)
#define LOG_ENGINE_ERROR(T, ...)

#endif

```

`include/iris/log/log_level.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <iosfwd>
#include <iostream>

namespace iris
{

/**
 * Enumeration of log levels.
 */
enum class LogLevel : std::uint32_t
{
    DEBUG,
    INFO,
    WARN,
    ERR
};

/**
 * Helper function to write a string representation of a LogLevel enum to a
 * stream.
 *
 * @param out
 *   Stream to write to.
 *
 * @param level
 *   Log level to write.
 *
 * @returns
 *   Reference to input stream.
 */
inline std::ostream &operator<<(std::ostream &out, const LogLevel level)
{
    switch (level)
    {
        case LogLevel::DEBUG: out << "DEBUG"; break;
        case LogLevel::INFO: out << "INFO"; break;
        case LogLevel::WARN: out << "WARN"; break;
        case LogLevel::ERR: out << "ERROR"; break;
        default: out << "UNKNOWN"; break;
    }

    return out;
}

}

```

`include/iris/log/logger.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <iostream>
#include <iterator>
#include <memory>
#include <mutex>
#include <set>
#include <sstream>
#include <string>
#include <type_traits>

#include "log/colour_formatter.h"
#include "log/log_level.h"
#include "log/stdout_outputter.h"

namespace iris
{

namespace detail
{

/**
 * Helper function to write a string to a stream. Writes from the supplied
 * position to the first occurrence of '{}' (which is replaced by supplied
 * object). If '{}' is not found then nothing is written.
 *
 * @param format_str
 *   The format string to write.
 *
 * @param obj
 *   The object to write.
 *
 * @param pos
 *   [in/out] On function enter this is the position to start searching in
 *   format_str for '{}'. On exit in the position in format_str after the '{}'.
 *   If no '{}' is found in the string then it is std::string::npos.
 *
 * @param strm
 *   The stream to write to.
 */
template <class T>
void format(const std::string &format_str, T &&obj, std::size_t &pos, std::stringstream &strm)
{
    static const std::string format_pattern{"{}"};

    const auto current_pos = pos;

    // find the pattern
    pos = format_str.find(format_pattern, pos);
    if (pos != std::string::npos)
    {
        // write the string up to the pattern then the supplied object
        strm << format_str.substr(current_pos, pos - current_pos) << obj;

        // move position passed the format
        pos += format_pattern.length();
    }
}

/**
 * Base case for variadic template unpacking.
 *
 * @param message
 *   Format string message.
 *
 * @param pos
 *   [in/out] On function enter this is the position to start searching in
 *   format_str for '{}'. On exit in the position in format_str after the '{}'.
 *   If no '{}' is found in the string then it is std::string::npos.
 *
 * @param strm
 *   The stream to write to.
 *
 * @param head
 *   The object to write.
 */
template <class Head>
void unpack(const std::string &message, std::size_t &pos, std::stringstream &strm, Head &&head)
{
    // write object to stream (if '{}' is in message)
    format(message, head, pos, strm);

    // we have no more args to write to stream, so write the remainder of the
    // message to the string (if there is any left)
    if (pos != std::string::npos)
    {
        strm << message.substr(pos);
    }
}

/**
 * Variadic template argument unpacker.
 *
 * @param message
 *   Format string message.
 *
 * @param pos
 *   [in/out] On function enter this is the position to start searching in
 *   format_str for '{}'. On exit in the position in format_str after the '{}'.
 *   If no '{}' is found in the string then it is std::string::npos.
 *
 * @param strm
 *   The stream to write to.
 *
 * @param head
 *   Current object to write.
 *
 * @param args
 *   Remaining arguments
 */
template <class Head, class... Tail>
void unpack(const std::string &message, std::size_t &pos, std::stringstream &strm, Head &&head, Tail &&...tail)
{
    format(message, std::forward<Head>(head), pos, strm);
    unpack(message, pos, strm, std::forward<Tail>(tail)...);
}

}

/**
 * Singleton class for logging. Formatting and outputting are controlled via
 * settable classes, by default uses colour formatting and outputs to stdout.
 *
 * The supported log levels are:
 *   DEBUG,
 *   INFO,
 *   WARN,
 *   ERR
 *
 * It us up to you what to use each for however it is suggested that INFO be
 * used for the majority of logging, with WARN and ERR for warnings and errors
 * respectively (feel free to decide what constitutes as a warning and error).
 * Debug should be used for the log messages you use to diagnose a bug and will
 * probably later delete.
 */
class Logger
{
  public:
    /**
     * Get single instance of Logger.
     *
     * @returns
     *   Logger single instance.
     */
    static Logger &instance()
    {
        static Logger logger{};
        return logger;
    }

    Logger(const Logger &) = delete;
    Logger &operator=(const Logger &) = delete;
    Logger(Logger &&) = delete;
    Logger &operator=(Logger &&) = delete;

    /**
     * Add a tag to be ignored, this prevents any log messages from the
     * given tag being processed.
     *
     * Adding the same tag more than once is a no-op.
     *
     * @param tag
     *   Tag to ignore.
     */
    void ignore_tag(const std::string &tag)
    {
        ignore_.emplace(tag);
    }

    /**
     * Show a supplied tag. This ensures that log messages from the given
     * tag are processed.
     *
     * Adding the same tag more than once or showing a non-hidden tag is a
     * no-op.
     *
     * @param tag
     *   Tag to show.
     */
    void show_tag(const std::string &tag)
    {
        if (const auto find = ignore_.find(tag); find != std::cend(ignore_))
        {
            ignore_.erase(find);
        }
    }

    /**
     * Set minimum log level, anything above this level is not processed.
     *
     * See log_level.h for definition of log_level.
     *
     * @param min_level
     *   Minimum level to process.
     */
    void set_min_level(const LogLevel min_level)
    {
        min_level_ = min_level;
    }

    /**
     * Set whether internal engine messages should be processed.
     *
     * @param log_engine
     *   True if engine messages should be processed, false of not.
     */
    void set_log_engine(const bool log_engine)
    {
        log_engine_ = log_engine;
    }

    /**
     * Set the Formatter class.
     *
     * Uses perfect forwarding to construct object.
     *
     * @param args
     *   Varaidic list of arguments for Formatter constructor.
     */
    template <class T, class... Args, typename = std::enable_if_t<std::is_base_of<Formatter, T>::value>>
    void set_Formatter(Args &&...args)
    {
        formatter_ = std::make_unique<T>(std::forward<Args>(args)...);
    }

    /**
     * Set the Outputter class.
     *
     * Uses perfect forwarding to construct object.
     *
     * @param args
     *   Varaidic list of arguments for Outputter constructor.
     */
    template <class T, class... Args, typename = std::enable_if_t<std::is_base_of<Outputter, T>::value>>
    void set_Outputter(Args &&...args)
    {
        outputter_ = std::make_unique<T>(std::forward<Args>(args)...);
    }

    /**
     * Log a message. This function handles the case where no arguments
     * are supplied i.e. just a log message.
     *
     * @param level
     *   Log level.
     *
     * @param tag
     *   Tag for log message.
     *
     * @param filename
     *   Name of the file logging the message.
     *
     * @param line
     *   Line of the log call in the file.
     *
     * @param engine
     *   True if this log message is from the internal engine, false
     *   otherwise.
     *
     * @param message
     *   Log message.
     */
    void log(
        const LogLevel level,
        const std::string &tag,
        const std::string &filename,
        const int line,
        const bool engine,
        const std::string &message)
    {
        // check if we want to process this log message
        if ((!engine || log_engine_) && (level >= min_level_) && (ignore_.find(tag) == std::cend(ignore_)))
        {
            std::stringstream strm{};
            strm << message;

            const auto log = formatter_->format(level, tag, strm.str(), filename, line);

            std::unique_lock lock(mutex_);
            outputter_->output(log);
        }
    }

    /**
     * Log a message. This function handles the case where there are
     * arguments.
     *
     * @param level
     *   Log level.
     *
     * @param tag
     *   Tag for log message.
     *
     * @param filename
     *   Name of the file logging the message.
     *
     * @param line
     *   Line of the log call in the file.
     *
     * @param engine
     *   True if this log message is from the internal engine, false
     *   otherwise.
     *
     * @param message
     *   Log message.
     *
     * @param args
     *   Variadic list of arguments for log formatting.
     */
    template <class... Args>
    void log(
        const LogLevel level,
        const std::string &tag,
        const std::string &filename,
        const int line,
        const bool engine,
        const std::string &message,
        Args &&...args)
    {
        std::stringstream strm{};

        // apply string formatting
        std::size_t pos = 0u;
        detail::unpack(message, pos, strm, std::forward<Args>(args)...);

        log(level, tag, filename, line, engine, strm.str());
    }

  private:
    /**
     * Construct a new logger.
     */
    Logger()
        : formatter_(std::make_unique<ColourFormatter>())
        , outputter_(std::make_unique<StdoutFormatter>())
        , ignore_()
        , min_level_(LogLevel::DEBUG)
        , log_engine_(false)
        , mutex_(){};

    /** Formatter object. */
    std::unique_ptr<Formatter> formatter_;

    /** Outputter object. */
    std::unique_ptr<Outputter> outputter_;

    /** Collection of tags to ignore. */
    std::set<std::string> ignore_;

    /** Minimum log level. */
    LogLevel min_level_;

    /** Whether to log internal engine messages. */
    bool log_engine_;

    /** Lock for logging. */
    std::mutex mutex_;
};

}

```

`include/iris/log/outputter.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <string>

namespace iris
{

/**
 * Interface for an outputter, a class which writes a log message to some
 * implementation defined medium.
 */
class Outputter
{
  public:
    /** Default */
    virtual ~Outputter() = default;

    /**
     * Output log.
     *
     * @param log
     *   Log message to output.
     */
    virtual void output(const std::string &log) = 0;
};

}

```

`include/iris/log/stdout_outputter.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <string>

#include "log/outputter.h"

namespace iris
{

/**
 * Implementation of Outputter which writes log messages to stdout.
 */
class StdoutFormatter : public Outputter
{
  public:
    /** Default */
    ~StdoutFormatter() override = default;

    /**
     * Output log.
     *
     * @param log
     *   Log message to output.
     */
    void output(const std::string &log) override;
};

}

```

`include/iris/networking/channel/channel.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include "networking/packet.h"
#include <deque>
#include <vector>

namespace iris
{

/**
 * Abstract class for a channel, a class which enforces guarantees on unreliable
 * packet transfer. This class provides an interface for consuming incoming
 * and outgoing packets, which when yielded will be in order according to
 * the channel guarantees.
 *
 * For example a channel which provides reliable and ordered guarantee will only
 * yield packets that are in order, it will buffer out of order packets until
 * the gaps have also been received. It will also handle acks so that dropped
 * packets will be resent.
 *
 * This is built on top of the Packet primitive.
 *
 * Note that this interface is not responsible for the actual sending and
 * receiving of packets. Rather it is a buffer which all packets being sent
 * and received should be passed through, anything yielded can then be sent
 * over a socket or passed up the application.
 *
 *        local channel                    remote channel
 *     +----------------+                +----------------+
 * --->|===== send =====|Y~~~~~~~~~~~~~~~|=== received ===|Y-->
 *     |                |                |                |
 * <--Y|=== received ===|~~~~~~~~~~~~~~~Y|===== send =====|<---
 *     +----------------+                +----------------+
 *
 * Y - yield
 */
class Channel
{
  public:
    Channel() = default;
    virtual ~Channel() = default;

    /**
     * Enqueue a packet to be sent.
     *
     * @param packet
     *   Packet to be sent.
     */
    virtual void enqueue_send(Packet packet) = 0;

    /**
     * Enqueue a received packet.
     *
     * @param packet
     *   Packet received.
     */
    virtual void enqueue_receive(Packet packet) = 0;

    /**
     * Yield all packets to be sent, according to the channel guarantees.
     *
     * @returns
     *   Packets to be send.
     */
    virtual std::vector<Packet> yield_send_queue();

    /**
     * Yield all packets that have been received, according to the channel
     * guarantees.
     *
     * @returns
     *   Packets received.
     */
    virtual std::vector<Packet> yield_receive_queue();

  protected:
    /** Queue for send packets. */
    std::vector<Packet> send_queue_;

    /** Queue for received packets. */
    std::vector<Packet> receive_queue_;
};

}

```

`include/iris/networking/channel/channel_type.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>

namespace iris
{

/**
 * Enumeration of channel types.
 */
enum class ChannelType : std::uint8_t
{
    INVAlID,
    UNRELIABLE_UNORDERED,
    UNRELIABLE_SEQUENCED,
    RELIABLE_ORDERED,
};

}

```

`include/iris/networking/channel/reliable_ordered_channel.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <deque>
#include <vector>

#include "networking/channel/channel.h"
#include "networking/socket.h"

namespace iris
{

/**
 * Implementation of Channel with the following guarantees:
 *  - Packets are in order
 *  - Packets are guaranteed to arrive
 *  - No gaps
 *  - No duplicates
 *
 * This is the strictest channel and effectively provides reliable delivery over
 * an unreliable transport.
 *
 * e.g.
 *  received packets : 1, 1, 3, 2, 1, 5, 4
 *  yielded packets  : 1, 2, 3, 4, 5
 */
class ReliableOrderedChannel : public Channel
{
  public:
    /**
     * Construct a new ReliableOrderedChannel.
     */
    ReliableOrderedChannel();

    // default
    ~ReliableOrderedChannel() override = default;

    /**
     * Enqueue a packet to be sent.
     *
     * @param packet
     *   Packet to be sent.
     */
    void enqueue_send(Packet packet) override;

    /**
     * Enqueue a received packet.
     *
     * @param packet
     *   Packet received.
     */
    void enqueue_receive(Packet packet) override;

    /**
     * Yield all packets to be sent, according to the channel guarantees.
     *
     * @returns
     *   Packets to be send.
     */
    std::vector<Packet> yield_send_queue() override;

    /**
     * Yield all packets that have been received, according to the channel
     * guarantees.
     *
     * @returns
     *   Packets received.
     */
    std::vector<Packet> yield_receive_queue() override;

  private:
    /** The expected sequence number of the next packet. */
    std::uint16_t next_receive_seq_;

    /** The sequence number for the next sent packet. */
    std::uint16_t out_sequence_;
};

}

```

`include/iris/networking/channel/unreliable_sequenced_channel.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <deque>
#include <vector>

#include "networking/channel/channel.h"
#include "networking/socket.h"

namespace iris
{

/**
 * Implementation of Channel with the following guarantees:
 *  - Packets are sequenced but may have gaps
 *  - No duplicates
 *
 * e.g.
 *  received packets : 1, 1, 3, 2, 1, 5
 *  yielded packets  : 1, 3, 5
 */
class UnreliableSequencedChannel : public Channel
{
  public:
    /**
     * Construct a new UnreliableSequencedChannel.
     */
    UnreliableSequencedChannel();

    // default
    ~UnreliableSequencedChannel() override = default;

    /**
     * Enqueue a packet to be sent.
     *
     * @param packet
     *   Packet to be sent.
     */
    void enqueue_send(Packet packet) override;

    /**
     * Enqueue a received packet.
     *
     * @param packet
     *   Packet received.
     */
    void enqueue_receive(Packet packet) override;

  private:
    /** The minimum sequence number to yield for received packets. */
    std::uint16_t min_sequence_;

    /** The sequence number for the next sent packet. */
    std::uint16_t send_sequence_;
};

}

```

`include/iris/networking/channel/unreliable_unordered_channel.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include "networking/channel/channel.h"

namespace iris
{

/**
 * Implementation of Channel with no guarantees. This is the most basic channel
 * and is effectively a no-op for unreliable traffic.
 */
class UnreliableUnorderedChannel : public Channel
{
  public:
    // default
    ~UnreliableUnorderedChannel() override = default;

    /**
     * Enqueue a packet to be sent.
     *
     * @param packet
     *   Packet to be sent.
     */
    void enqueue_send(Packet packet) override;

    /**
     * Enqueue a received packet.
     *
     * @param packet
     *   Packet received.
     */
    void enqueue_receive(Packet packet) override;
};

}

```

`include/iris/networking/client_connection_handler.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <chrono>
#include <cstdint>
#include <map>
#include <memory>
#include <string>

#include "core/context.h"
#include "core/data_buffer.h"
#include "jobs/concurrent_queue.h"
#include "networking/channel/channel.h"
#include "networking/socket.h"

namespace iris
{

/**
 * This class provides an abstraction over the low-level handling of connecting
 * to a server.
 * It automatically handles:
 *  - making a connection
 *  - handshake
 *  - clock sync
 *  - sending/receiving data
 *
 * This is all done with the lightweight Packet protocol (see
 * server_connection_handler.h for details on the protocol).
 */
class ClientConnectionHandler
{
  public:
    /**
     * Create a new ClientConnectionHandler.
     *
     * @param context
     *   Engine context object.
     *
     * @param socket
     *   The underlying socket to use.
     */
    explicit ClientConnectionHandler(Context &context, std::unique_ptr<Socket> socket);

    /**
     * Try and read data from the supplied channel.
     *
     * @param channel_type
     *   Channel to read from.
     *
     * @returns
     *   DataBuffer of bytes if read succeeded, otherwise empty optional.
     */
    std::optional<DataBuffer> try_read(ChannelType channel_type);

    /**
     * Send data to the server on the supplied channel.
     *
     * @param data
     *   Data to send.
     *
     * @param channel_type
     *   Channel to send data on
     */
    void send(const DataBuffer &data, ChannelType channel_type);

    void flush();

    /**
     * Unique id of the client (as set by server).
     *
     * @returns
     *   Server id.
     */
    std::uint32_t id() const;

    /**
     * Estimate of the lag between the client and server. This is the round
     * trip time for a message to get to the server and back. Can change if
     * the server issues a sync.
     *
     * @returns
     *   Estimate of lag.
     */
    std::chrono::milliseconds lag() const;

  private:
    /** Underlying socket. */
    std::unique_ptr<Socket> socket_;

    /** Unique id of this client. */
    std::uint32_t id_;

    /** Estimate of lag between client and server. */
    std::chrono::milliseconds lag_;

    /** Map of channel types to channel objects. */
    std::map<ChannelType, std::unique_ptr<Channel>> channels_;

    /** Map of channel types to message queues. */
    std::map<ChannelType, std::unique_ptr<ConcurrentQueue<DataBuffer>>> queues_;
};

}

```

`include/iris/networking/data_buffer_deserialiser.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <cstring>
#include <iterator>
#include <memory>
#include <type_traits>

#include "core/data_buffer.h"
#include "core/exception.h"
#include "core/quaternion.h"
#include "core/vector3.h"

namespace iris
{

/**
 * Class for deserialising types stored in a DataBuffer. This is the inverse
 * operation to DataBufferSerialiser.
 */
class DataBufferDeserialiser
{
  public:
    /**
     * Construct a new DataBufferDeserialiser.
     *
     * @param buffer
     *   DataBuffer of serialised data.
     */
    explicit DataBufferDeserialiser(DataBuffer buffer)
        : buffer_(std::move(buffer))
        , cursor_(std::cbegin(buffer_))
    {
    }

    /**
     * Pop integral type.
     *
     * @returns
     *   Next element in buffer as supplied type.
     */
    template <class T, std::enable_if_t<std::is_arithmetic_v<T>> * = nullptr>
    T pop()
    {
        const auto size = static_cast<std::ptrdiff_t>(sizeof(T));
        if (size > std::distance(cursor_, std::cend(buffer_)))
        {
            throw Exception("not enough data left");
        }

        T value{};
        std::memcpy(&value, std::addressof(*cursor_), size);

        cursor_ += size;

        return value;
    }

    /**
     * Pop enum.
     *
     * @returns
     *   Next element in buffer as supplied type.
     */
    template <class T, std::enable_if_t<std::is_enum_v<T>> * = nullptr>
    T pop()
    {
        using type = std::underlying_type_t<T>;

        const auto value = pop<type>();

        return static_cast<T>(value);
    }

    /**
     * Pop Vector3.
     *
     * @returns
     *   Next element in buffer as supplied type.
     */
    template <class T, std::enable_if_t<std::is_same_v<T, Vector3>> * = nullptr>
    T pop()
    {
        return T{pop<float>(), pop<float>(), pop<float>()};
    }

    /**
     * Pop Quaternion.
     *
     * @returns
     *   Next element in buffer as supplied type.
     */
    template <class T, std::enable_if_t<std::is_same_v<T, Quaternion>> * = nullptr>
    T pop()
    {
        return T{pop<float>(), pop<float>(), pop<float>(), pop<float>()};
    }

    /**
     * Pop DataBuffer.
     *
     * @returns
     *   Next element in buffer as supplied type.
     */
    template <class T, std::enable_if_t<std::is_same_v<T, DataBuffer>> * = nullptr>
    T pop()
    {
        const auto size = pop<std::uint32_t>();

        DataBuffer value(cursor_, cursor_ + size);
        cursor_ += size;

        return value;
    }

    /**
     * Pop tuple of supplied types.
     *
     * @returns
     *   std::tuple of requested types from buffer.
     */
    template <class... Types>
    std::tuple<Types...> pop_tuple()
    {
        std::tuple<Types...> values;

        pop_tuple_impl<0u, std::tuple<Types...>, Types...>(values);

        return values;
    }

  private:
    /**
     * Helper recursive template method. Sets the next requested tuple
     * element.
     *
     * @param values
     *   Tuple of elements to append to.
     */
    template <std::size_t Index, class T, class Head, class... Tail>
    void pop_tuple_impl(T &values)
    {
        // set next tuple element
        std::get<Index>(values) = pop<Head>();

        // recurse to set next element
        pop_tuple_impl<Index + 1u, T, Tail...>(values);
    }

    /**
     * Base method for template recursion.
     */
    template <std::size_t Index, class T>
    void pop_tuple_impl(T &)
    {
    }

    /** Buffer of serialised data. */
    DataBuffer buffer_;

    /** Iterator into buffer, where next element will be popped from. */
    DataBuffer::const_iterator cursor_;
};

}

```

`include/iris/networking/data_buffer_serialiser.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <cstring>
#include <memory>
#include <type_traits>

#include "core/data_buffer.h"
#include "core/quaternion.h"
#include "core/vector3.h"

namespace iris
{

/**
 * Class for serialising types to a DataBuffer.
 *
 * Note this assumes little-endian.
 */
class DataBufferSerialiser
{
  public:
    /**
     * Get the serialised data.
     *
     * @returns
     *   DataBuffer of serialised data.
     */
    DataBuffer data() const
    {
        return buffer_;
    }

    /**
     * Serialise an integral type.
     *
     * @param value
     *   Value to serialise.
     */
    template <class T, std::enable_if_t<std::is_arithmetic_v<T>> * = nullptr>
    void push(T value)
    {
        const auto size = sizeof(T);
        buffer_.resize(buffer_.size() + size);
        std::memcpy(std::addressof(*(std::end(buffer_) - size)), &value, size);
    }

    /**
     * Serialise an enum.
     *
     * @param value
     *   Value to serialise.
     */
    template <class T, std::enable_if_t<std::is_enum_v<T>> * = nullptr>
    void push(T value)
    {
        using type = std::underlying_type_t<T>;

        push<type>(static_cast<type>(value));
    }

    /**
     * Serialise a Vector3.
     *
     * @param value
     *   Value to serialise.
     */
    void push(const Vector3 &value)
    {
        push(value.x);
        push(value.y);
        push(value.z);
    }

    /**
     * Serialise a Quaternion.
     *
     * @param value
     *   Value to serialise.
     */
    void push(const Quaternion &value)
    {
        push(value.x);
        push(value.y);
        push(value.z);
        push(value.w);
    }

    /**
     * Serialise a DataBuffer.
     *
     * @param value
     *   Value to serialise.
     */
    void push(const DataBuffer &value)
    {
        const auto size = value.size();
        push(static_cast<std::uint32_t>(size));
        buffer_.resize(buffer_.size() + size);
        std::memcpy(std::addressof(*(std::end(buffer_) - size)), value.data(), size);
    }

  private:
    /** Serialised data. */
    DataBuffer buffer_;
};

}

```

`include/iris/networking/networking.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

// this file abstracts away platform specific networking includes as we as
// several utility functions
// it should suffice to just include this file to use BSD socket functions

#include <functional>

#if defined(IRIS_PLATFORM_WIN32)
#include <winsock2.h>
#include <ws2tcpip.h>
#pragma comment(lib, "Ws2_32.lib")
#include "networking/win32/winsock.h"
static iris::Winsock ws_init;
#else
#include <arpa/inet.h>
#include <errno.h>
#include <fcntl.h>
#include <netdb.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>
#endif

#include "core/exception.h"

namespace iris
{

#if defined(IRIS_PLATFORM_WIN32)

using SocketHandle = SOCKET;
static std::function<int(SocketHandle)> CloseSocket = ::closesocket;

/**
 * Set whether a socket should block on read.
 *
 * @param socket
 *   Handle to socket to change.
 *
 * @param blocking
 *   Whether socket should block or not.
 */
inline void set_blocking(SocketHandle socket, bool blocking)
{
    u_long mode = blocking ? 0 : 1;
    if (::ioctlsocket(socket, FIONBIO, &mode) != NO_ERROR)
    {
        throw Exception("could not set blocking mode");
    }
}

/**
 * Check if the last read call would have blocked. i.e. no data was available.
 *
 * Note this is function is only valid following a read on a non-blocking
 * socket.
 *
 * @returns
 *   True if read would have blocked, false otherwise.
 */
inline bool last_call_blocked()
{
    return ::WSAGetLastError() == WSAEWOULDBLOCK;
}

#else

using SocketHandle = int;
static std::function<int(SocketHandle)> CloseSocket = ::close;
// this is already defined on windows so we define it again for consistency
#define INVALID_SOCKET -1

/**
 * Set whether a socket should block on read.
 *
 * @param socket
 *   Handle to socket to change.
 *
 * @param blocking
 *   Whether socket should block or not.
 */
inline void set_blocking(SocketHandle socket, bool blocking)
{
    auto flags = ::fcntl(socket, F_GETFL, 0);
    if (flags == -1)
    {
        throw Exception("could not get flags");
    }

    flags = blocking ? (flags & ~O_NONBLOCK) : (flags | O_NONBLOCK);

    if (::fcntl(socket, F_SETFL, flags) != 0)
    {
        throw Exception("could not set flags");
    }
}

/**
 * Check if the last read call would have blocked. i.e. no data was available.
 *
 * Note this is function is only valid following a read on a non-blocking
 * socket.
 *
 * @returns
 *   True if read would have blocked, false otherwise.
 */
inline bool last_call_blocked()
{
    return errno == EWOULDBLOCK;
}
#endif

}

```

`include/iris/networking/packet.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <cstdint>
#include <cstring>
#include <ostream>

#include "core/data_buffer.h"
#include "networking/channel/channel_type.h"
#include "networking/packet_type.h"

namespace iris
{

/**
 * Class encapsulating a packet the engine will send/receive. This is a
 * low-level primitive used to facilitate the basic protocol the engine
 * provides. It is expected that a user will not create and send/receive these
 * packets directly, but rather use other constructs in the engine to send their
 * own game-specific protocol.
 *
 * The Packet consists of a header then a fixed body buffer, which can contain
 * arbitrary data (may be smaller than the buffer size).
 *
 *                               +----------+ -.
 *                               |   type   |  |
 *                               +----------+  |
 *                               | channel  |  |- header
 *                               +----------+  |
 *                               | sequence |  |
 *                            .- +----------+ -'
 *                            |  |          |
 *                            |  |          |
 *                            |  |          |
 *                            |  |   body   |
 *                            |  |          |
 *               body buffer -|  |          |
 *                            |  |          |
 *                            |  |~~~~~~~~~~|- body size
 *                            |  |          |
 *                            |  |          |
 *                            |  |          |
 *                            '- +----------+
 */
class Packet
{
  public:
    /**
     * Construct an invalid Packet. All methods on an invalid packet should
     * be considered undefined except:
     *  - is_valid
     *  - data
     */
    Packet();

    /**
     * Construct a new Packet.
     *
     * @param type
     *   The type of packet.
     *
     * @param channel
     *   The channel the packet should be sent on.
     *
     * @param body
     *   The data of the packet, may be empty.
     */
    Packet(PacketType type, ChannelType channel, const DataBuffer &body);

    /**
     * Construct a new Packet from raw data.
     *
     * @param raw_data
     *   Raw Packet data
     */
    explicit Packet(const DataBuffer &raw_packet);

    /**
     * Get a pointer to the start of the packet.
     *
     * @returns
     *   Pointer to start of this Packet.
     */
    const std::byte *data() const;

    /**
     * Get a pointer to the start of the packet.
     *
     * @returns
     *   Pointer to start of this Packet.
     */
    std::byte *data();

    /**
     * Get a pointer to the body of the packet.
     *
     * @returns
     *   Pointer to start of the Packet body.
     */
    const std::byte *body() const;

    /**
     * Get a pointer to the body of the packet.
     *
     * @returns
     *   Pointer to start of the Packet body.
     */
    std::byte *body();

    /**
     * Get the contents of the body.
     *
     * @returns
     *   Body contents.
     */
    DataBuffer body_buffer() const;

    /**
     * Get the size of the packet i.e. sizeof(header) + sizeof(body).
     *
     * Note this may be less than sizeof(Packet) if the body buffer is not
     * full.
     *
     * @returns
     *   Size of Packet that is filled.
     */
    std::size_t packet_size() const;

    /**
     * Get the size of the body i.e. how much of the body buffer is filled.
     *
     * @returns
     *   Size of body.
     */
    std::size_t body_size() const;

    /**
     * Get packet type.
     *
     * @returns
     *   Type of packet.
     */
    PacketType type() const;

    /**
     * Get channel type.
     *
     * @returns
     *   Type of channel.
     */
    ChannelType channel() const;

    /**
     * Check if Packet is valid.
     *
     * @returns
     *   True if packet is valid, otherwise false.
     */
    bool is_valid() const;

    /**
     * Get the sequence number of the Packet.
     *
     * @returns
     *   Sequence number.
     */
    std::uint16_t sequence() const;

    /**
     * Set the sequence number.
     *
     * @param sequence
     *   New sequence number.
     */
    void set_sequence(std::uint16_t sequence);

    /**
     * Equality operator.
     *
     * @param other
     *   Packet to check for equality.
     *
     * @returns
     *   True if both Packet objects are the same, otherwise false.
     */
    bool operator==(const Packet &other) const;

    /**
     * Inequality operator.
     *
     * @param other
     *   Packet to check for inequality.
     *
     * @returns
     *   True if both Packet objects are not the same, otherwise false.
     */
    bool operator!=(const Packet &other) const;

    /**
     * Write a Packet to a stream, useful for debugging.
     *
     * @param out
     *   Stream to write to.
     *
     * @param packet
     *   Packet to write to stream.
     *
     * @returns
     *   Reference to input stream.
     */
    friend std::ostream &operator<<(std::ostream &out, const Packet &packet);

  private:
    /**
     * Internal struct for Packet header.
     */
    struct Header
    {
        /**
         * Construct a new Header.
         *
         * @param type
         *   Packet type.
         *
         * @param channel
         *   Channel type.
         */
        Header(PacketType type, ChannelType channel)
            : type(type)
            , channel(channel)
            , sequence(0u)
        {
            // check the header has no padding
            static_assert(sizeof(Header) == sizeof(type) + sizeof(channel) + sizeof(sequence), "header has padding");
        }

        /** Type of packet. */
        PacketType type;

        /** Type of channel. */
        ChannelType channel;

        /** Sequence number. */
        std::uint16_t sequence;
    };

    /** Packet header. */
    Header header_;

    /** Packet body buffer. */
    std::byte body_[128 - sizeof(Header)];

    // anything after here should be considered local bookkeeping and will
    // not be transmitted when a Packet is sent.

    /** Size of body buffer used. */
    std::size_t size_;
};

}

```

`include/iris/networking/packet_type.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>

namespace iris
{

/**
 * Enumeration of packet types.
 */
enum class PacketType : std::uint8_t
{
    INVAlID,
    HELLO,
    CONNECTED,
    DATA,
    ACK,
    SYNC_START,
    SYNC_RESPONSE,
    SYNC_FINISH
};

}

```

`include/iris/networking/server_connection_handler.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <chrono>
#include <cstddef>
#include <functional>
#include <map>
#include <memory>
#include <mutex>

#include "core/context.h"
#include "core/data_buffer.h"
#include "networking/channel/channel.h"
#include "networking/channel/channel_type.h"
#include "networking/server_socket.h"

namespace iris
{

/**
 * This class provides an abstraction over the low-level handling of
 * connections. It automatically handles:
 *  - accepting connections
 *  - handshakes
 *  - clock syncs
 *  - sending/receiving data
 *
 * This is all done with the lightweight Packet protocol and Channels. This
 * class can also be provided with callbacks for key events.
 *
 * Protocol:
 *
 * Handshake - must be performed when client connections.
 *
 * client           server
 *          HELLO
 *        -------->
 *
 *         CONNECTED
 *           [id]
 *        <--------
 *
 * Data - this is sent via DATA packets, ACKs may be sent in response depending
 * on the channel used.
 *
 * Sync - this allows the client to synchronise its clock with the server,
 * always happens after handshake but my happen again if the server thinks the
 * client is out of sync.
 *
 * client           server
 *        SYNC_START
 *        <--------
 *
 *      SYNC_RESPONSE
 *      [client_time]
 *        -------->
 *
 *       SYNC_START
 *      [client_time]
 *      [server_time]
 *        <--------
 */
class ServerConnectionHandler
{
  public:
    /**
     * Callback for new connections
     *
     * @param id
     *   A unique id for this connection.
     */
    using NewConnectionCallback = std::function<void(std::size_t id)>;

    /**
     * Callback for when a connection sends data.
     *
     * @param id
     *   Id of connection sending data.
     *
     * @param data
     *   The data send.
     *
     * @param channel
     *   The channel type the client sent the data on.
     */
    using RecvCallback = std::function<void(std::size_t id, const DataBuffer &data, ChannelType channel)>;

    /**
     * Create a new ServerConnectionHandler.
     *
     * @param context
     *   Engine context object.

     * @param socket
     *   The underlying socket to use.
     *
     * @param new_connection
     *   Callback to fire when a new connection is created.
     *
     * @param recv
     *   Callback to fire when data is received.
     */
    ServerConnectionHandler(
        Context &context,
        std::unique_ptr<ServerSocket> socket,
        NewConnectionCallback new_connection,
        RecvCallback recv);

    // defined in implementation
    ~ServerConnectionHandler();

    // deleted
    ServerConnectionHandler(const ServerConnectionHandler &) = delete;
    ServerConnectionHandler &operator=(const ServerConnectionHandler &) = delete;

    /**
     * Updates the connection handler, processes all messages and fires all
     * callbacks. This should be called regularly (e.g. from a game loop)
     */
    void update();

    /**
     * Send data to a connection.
     *
     * @param id
     *   Id of connection to send data to.
     *
     * @param message
     *   Data to send.
     *
     * @param channel_type
     *   The channel to send the data through
     */
    void send(std::size_t id, const DataBuffer &message, ChannelType channel_type);

  private:
    // forward declare internal struct
    struct Connection;

    /** Underlying socket. */
    std::unique_ptr<ServerSocket> socket_;

    /** New connection callback. */
    NewConnectionCallback new_connection_callback_;

    /** Received data callback. */
    RecvCallback recv_callback_;

    /** Start time of connection handler. */
    std::chrono::steady_clock::time_point start_;

    /** Map of connections to their unique id. */
    std::map<std::size_t, std::unique_ptr<Connection>> connections_;

    /** Mutex to control access to messages. */
    std::mutex mutex_;

    /** Collection of messages. */
    std::vector<DataBuffer> messages_;
};

}

```

`include/iris/networking/server_socket.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include "networking/server_socket_data.h"

namespace iris
{

/**
 * Interface for a server socket. This is a socket that will read data from all
 * clients, returning read data as well as a Socket object to communicate back
 * with them.
 *
 * See documentation in deriving classes for implementation specific caveats.
 */
class ServerSocket
{
  public:
    virtual ~ServerSocket() = default;

    /**
     * Block and wait for data.
     *
     * @returns
     *    A ServerSocketData for the read client and data.
     */
    virtual ServerSocketData read() = 0;
};

}

```

`include/iris/networking/server_socket_data.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include "core/data_buffer.h"
#include "networking/socket.h"

namespace iris
{

/**
 * Struct for data returned from a ServerSocket read.
 */
struct ServerSocketData
{
    /** A Socket which can be used to communicate with the client. */
    Socket *client;

    /** The data read. */
    DataBuffer data;

    /** Whether this is a new connection or not. */
    bool new_connection;
};

}

```

`include/iris/networking/simulated_server_socket.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <algorithm>
#include <chrono>
#include <memory>
#include <string>

#include "core/context.h"
#include "networking/server_socket.h"
#include "networking/server_socket_data.h"
#include "networking/simulated_socket.h"

namespace iris
{

/**
 * An adaptor for ServerSocket which can simulate different network conditions.
 * Note that these conditions are compounded with any properties of the
 * underlying Socket.
 *
 * Supports one clinet.
 */
class SimulatedServerSocket : public ServerSocket
{
  public:
    /**
     * Construct a new SimulatedServerSocket.
     *
     * @param context
     *   Engine context object.
     *
     * @param delay
     *   The fixed delay for all packets.
     *
     * @param jitter
     *   The random variance in delay. All packets will be delayed by:
     *      delay + rand[-jitter, jitter]
     *
     * @param drop_rate
     *   The rate at which packets will be dropped, must be in the range
     *   [0.0, 1.0] -> [no packets dropped, all packets dropped]
     *
     * @param socket
     *   ServerSocket to adapt. Will be used for underlying communication, but
     * with simulated conditions.
     */
    SimulatedServerSocket(
        Context &context,
        std::chrono::milliseconds delay,
        std::chrono::milliseconds jitter,
        float drop_rate,
        ServerSocket *socket);

    ~SimulatedServerSocket() override = default;

    /**
     * Block and wait for data.
     *
     * @returns
     *    A ServerSocketData for the read client and data.
     */
    ServerSocketData read() override;

  private:
    /** Underlying socket. */
    ServerSocket *socket_;

    /** The single client. */
    std::unique_ptr<SimulatedSocket> client_;

    /** Simulated delay. */
    std::chrono::milliseconds delay_;

    /** Simulated jitter. */
    std::chrono::milliseconds jitter_;

    /** Simulated packet drop rate. */
    float drop_rate_;

    /** Engine context. */
    Context &context_;
};

}

```

`include/iris/networking/simulated_socket.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <chrono>
#include <cstddef>
#include <optional>

#include "core/context.h"
#include "jobs/concurrent_queue.h"
#include "networking/socket.h"

namespace iris
{

/**
 * An adaptor for Socket which can simulate different network conditions. Note
 * that these conditions are compounded with any properties of the underlying
 * Socket.
 */
class SimulatedSocket : public Socket
{
  public:
    /**
     * Construct a new SimulatedSocket.
     *
     * @param context
     *   Engine context object.
     *
     * @param delay
     *   The fixed delay for all packets.
     *
     * @param jitter
     *   The random variance in delay. All packets will be delayed by:
     *      delay + rand[-jitter, jitter]
     *
     * @param drop_rate
     *   The rate at which packets will be dropped, must be in the range
     *   [0.0, 1.0] -> [no packets dropped, all packets dropped]
     *
     * @param socket
     *   Socket to adapt. Will be used for underlying communication, but with
     *   simulated conditions.
     */
    SimulatedSocket(
        Context &context,
        std::chrono::milliseconds delay,
        std::chrono::milliseconds jitter,
        float drop_rate,
        Socket *socket);

    // defined in implementation
    ~SimulatedSocket() override;

    // deleted
    SimulatedSocket(const SimulatedSocket &) = delete;
    SimulatedSocket &operator=(const SimulatedSocket &) = delete;

    /**
     * Try and read requested number bytes. Will return all bytes read up to
     * count, but maybe less.
     *
     * @param count
     *   Maximum number of bytes to read.
     *
     * @returns
     *   DataBuffer of bytes if read succeeded, otherwise empty optional.
     */
    std::optional<DataBuffer> try_read(std::size_t count) override;

    /**
     * Block and read up to count bytes. May return less.
     *
     * @param count
     *   Maximum number of bytes to read.
     *
     * @returns
     *   DataBuffer of bytes read.
     */
    DataBuffer read(std::size_t count) override;

    /**
     * Write DataBuffer to socket.
     *
     * @param buffer
     *   Bytes to write.
     */
    void write(const DataBuffer &buffer) override;

    /**
     * Write bytes to socket.
     *
     * @param data
     *   Pointer to bytes to write.
     *
     * @param size
     *   Amount of bytes to write.
     */
    void write(const std::byte *data, std::size_t size) override;

  private:
    /** Packet delay. */
    std::chrono::milliseconds delay_;

    /** Delay jitter. */
    std::chrono::milliseconds jitter_;

    /** Packet drop rate. */
    float drop_rate_;

    /** Underlying socket. */
    Socket *socket_;

    /** Queue of data to send and when. */
    ConcurrentQueue<std::tuple<DataBuffer, std::chrono::steady_clock::time_point>> write_queue_;
};

}

```

`include/iris/networking/socket.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <optional>

#include "core/data_buffer.h"

namespace iris
{

/**
 * Interface for a socket. This is an object that can read and write bytes
 * from/to another socket object (possibly on a separate machine).
 */
class Socket
{
  public:
    // default
    virtual ~Socket() = default;

    /**
     * Try and read count bytes if they are available (this should be a
     * non-blocking call).
     *
     * Note that if not all requested bytes are available it is down to the
     * implementation whether this is treated as error or just the bytes
     * read are returned.
     *
     * @param count
     *   Amount of bytes to read.
     *
     * @returns
     *   DataBuffer of bytes if read succeeded, otherwise empty optional.
     */
    virtual std::optional<DataBuffer> try_read(std::size_t count) = 0;

    /**
     * Read count bytes (this should be a blocking call).
     *
     * Note that if not all requested bytes are available it is down to the
     * implementation whether this is treated as error or just the bytes
     * read are returned.
     *
     * @param count
     *   Amount of bytes to read.
     *
     * @returns
     *   DataBuffer of bytes read.
     */
    virtual DataBuffer read(std::size_t count) = 0;

    /**
     * Write DataBuffer to socket.
     *
     * @param buffer
     *   Bytes to write.
     */
    virtual void write(const DataBuffer &buffer) = 0;

    /**
     * Write bytes to socket.
     *
     * @param data
     *   Pointer to bytes to write.
     *
     * @param size
     *   Amount of bytes to write.
     */
    virtual void write(const std::byte *data, std::size_t size) = 0;
};

}

```

`include/iris/networking/udp_server_socket.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <map>
#include <memory>
#include <string>

#include "core/auto_release.h"
#include "networking/networking.h"
#include "networking/server_socket.h"
#include "networking/server_socket_data.h"

namespace iris
{

/**
 * Implementation of ServerSocket which accepts UDP connections.
 *
 * The ServerSocketData provides a socket for communicating back with the
 * client. This behaves as any normal socket and can be read from and
 * written to.
 *
 * Note that in general one should avoid reading from the returned client
 * Socket object. This is because internally the client socket and this
 * ServerSocket hold the same underlying network primitive. Which means reading
 * from one could potentially interfere with the other. Best practice is to
 * only every read from the UdpServerSocket and write back with the returned
 * client Socket.
 */
class UdpServerSocket : public ServerSocket
{
  public:
    /**
     * Construct a new UdpServerSocket.
     *
     * @param address
     *   Address to listen to for connections.
     *
     * @param port
     *   Port to listen on.
     */
    UdpServerSocket(const std::string &address, std::uint32_t port);

    UdpServerSocket(const UdpServerSocket &) = delete;
    UdpServerSocket &operator=(const UdpServerSocket &) = delete;

    ~UdpServerSocket() override = default;

    /**
     * Block and wait for data.
     *
     * @returns
     *    A ServerSocketData for the read client and data.
     */
    ServerSocketData read() override;

  private:
    /** Map of address to Socket for clients. */
    std::map<std::uint32_t, std::unique_ptr<Socket>> connections_;

    /** Underlying server socket. */
    AutoRelease<SocketHandle, INVALID_SOCKET> socket_;
};

}

```

`include/iris/networking/udp_socket.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <cstdint>
#include <memory>
#include <optional>
#include <string>

#include "core/auto_release.h"
#include "core/data_buffer.h"
#include "networking/networking.h"
#include "networking/socket.h"

namespace iris
{

/**
 * Implementation of Socket using UDP. This class simply sends UDP datagrams and
 * makes no guarantees about deliveries or order.
 */
class UdpSocket : public Socket
{
  public:
    /**
     * Construct a new UdpSocket to the supplied address and port.
     *
     * @param address
     *   Address to communicate with.
     *
     * @param port
     *   Port on address to communicate with.
     */
    UdpSocket(const std::string &address, std::uint16_t port);

    /**
     * Construct a new UdpSocket from an existing BSD socket. This is non-owning
     * and will not close the SocketHandle when it goes out of scope.
     *
     * This constructor annoyingly breaks the abstraction around the BSD socket
     * primitives but is a necessary evil.
     *
     * @param socket_address
     *   BSD socket struct.
     *
     * @param socket_length
     *   Length (in bytes) of socket_address
     *
     * @param socket
     *   SocketHandle to take a non-owning copy of.
     */
    UdpSocket(struct sockaddr_in socket_address, socklen_t socket_length, SocketHandle socket);

    // disabled
    UdpSocket(const UdpSocket &) = delete;
    UdpSocket &operator=(const UdpSocket &) = delete;

    // defined in implementation
    ~UdpSocket() override = default;

    /**
     * Try and read requested number bytes. Will return all bytes read up to
     * count, but maybe less.
     *
     * @param count
     *   Maximum number of bytes to read.
     *
     * @returns
     *   DataBuffer of bytes if read succeeded, otherwise empty optional.
     */
    std::optional<DataBuffer> try_read(std::size_t count) override;

    /**
     * Block and read up to count bytes. May return less.
     *
     * @param count
     *   Maximum number of bytes to read.
     *
     * @returns
     *   DataBuffer of bytes read.
     */
    DataBuffer read(std::size_t count) override;

    /**
     * Write DataBuffer to socket.
     *
     * @param buffer
     *   Bytes to write.
     */
    void write(const DataBuffer &buffer) override;

    /**
     * Write bytes to socket.
     *
     * @param data
     *   Pointer to bytes to write.
     *
     * @param size
     *   Amount of bytes to write.
     */
    void write(const std::byte *data, std::size_t size) override;

  private:
    /** Socket wrapper. */
    AutoRelease<SocketHandle, INVALID_SOCKET> socket_;

    /** BSD socket. */
    struct sockaddr_in address_;

    /** BSD socket length. */
    socklen_t address_length_;
};

}

```

`include/iris/networking/win32/winsock.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

namespace iris
{
/**
 * RAII class to initialise and cleanup winsock.
 */
class Winsock
{
  public:
    /**
     * Initialise winsock.
     */
    Winsock();

    /**
     * Cleanup winsock.
     */
    ~Winsock();
};
}

```

`include/iris/physics/basic_character_controller.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <chrono>

#include "core/quaternion.h"
#include "core/vector3.h"
#include "physics/character_controller.h"
#include "physics/physics_system.h"
#include "physics/rigid_body.h"

namespace iris
{

class PhysicsSystem;

/**
 * Implementation of CharacterController for a basic walking character controller.
 * Uses a capsule shape for character.
 */
class BasicCharacterController : public CharacterController
{
  public:
    /**
     * Create a BasicCharacterController.
     *
     * @param physics_system
     *   Pointer to physics_system that owns this controller.
     */
    BasicCharacterController(PhysicsSystem *physics_system, float speed, float width, float height, float float_height);

    /**
     * Set the direction the character is walking. Should be a normalised
     * vector.
     *
     * @param direction
     *   Direction character is moving.
     */
    void set_movement_direction(const Vector3 &direction) override;

    /**
     * Get position of character in the world.
     *
     * @returns
     *   World coordinates of character.
     */
    Vector3 position() const override;

    /**
     * Get orientation of character.
     *
     * @returns
     *   Orientation of character
     */
    Quaternion orientation() const override;

    /**
     * Set speed of character.
     *
     * @param speed
     *   New speed.
     */
    void set_speed(float speed) override;

    /**
     * Reposition character.
     *
     * @param position
     *   New position.
     *
     * @param orientation
     *   New orientation.
     */
    void reposition(const Vector3 &position, const Quaternion &orientation) override;

    /**
     * Get the underlying RigidBody.
     *
     * @returns
     *   Underlying RigidBody.
     */
    RigidBody *rigid_body() const override;

    void update(PhysicsSystem *ps, std::chrono::milliseconds delta) override;

  protected:
    Vector3 movement_direction_;

    /** Speed of character. */
    float speed_;

    float float_height_;

    /** Underlying rigid body, */
    RigidBody *body_;
};

}

```

`include/iris/physics/bullet/bullet_box_collision_shape.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <memory>

#include <BulletCollision/CollisionShapes/btBoxShape.h>

#include "core/vector3.h"
#include "physics/bullet/bullet_collision_shape.h"

namespace iris
{

/**
 * Implementation of CollisionShape for a box.
 */
class BulletBoxCollisionShape : public BulletCollisionShape
{
  public:
    /**
     * Construct a new BoxCollisionShape
     *
     * @param half_size
     *   The extents from the centre of the box which define its size.
     */
    explicit BulletBoxCollisionShape(const Vector3 &half_size);

    ~BulletBoxCollisionShape() override = default;

    /**
     * Get box half size.
     *
     * @returns
     *   The extents from the centre of the box which define its size.
     */
    Vector3 half_size() const;

    /**
     * Get a handle to the bullet object.
     *
     * @returns
     *   Bullet object.
     */
    btCollisionShape *handle() const override;

  private:
    /** Bullet collision shape. */
    std::unique_ptr<btBoxShape> shape_;

    /** The extents from the centre of the box which define its size. */
    Vector3 half_size_;
};

}

```

`include/iris/physics/bullet/bullet_capsule_collision_shape.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <memory>

#include <BulletCollision/CollisionShapes/btCapsuleShape.h>

#include "physics/bullet/bullet_collision_shape.h"

namespace iris
{

/**
 * Implementation of CollisionShape for a capsule.
 */
class BulletCapsuleCollisionShape : public BulletCollisionShape
{
  public:
    /**
     * Construct new CapsuleCollisionShape
     *
     * @param width
     *   Diameter of capsule.
     *
     * @param height
     *   Height of capsule.
     */
    BulletCapsuleCollisionShape(float width, float height);

    ~BulletCapsuleCollisionShape() override = default;

    /**
     * Get width of capsule.
     *
     * @returns
     *   Capsule diameter.
     */
    float width() const;

    /**
     * Get height of capsule.
     *
     * @returns
     *   Capsule height.
     */
    float height() const;

    /**
     * Get a handle to the bullet object.
     *
     * @returns
     *   Bullet object.
     */
    btCollisionShape *handle() const override;

  private:
    /** Bullet collision shape. */
    std::unique_ptr<btCapsuleShape> shape_;

    /** Diameter of capsule. */
    float width_;

    /** Height of capsule. */
    float height_;
};

}

```

`include/iris/physics/bullet/bullet_collision_shape.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <BulletCollision/CollisionShapes/btCollisionShape.h>

#include "physics/collision_shape.h"

namespace iris
{

/**
 * Implementation of CollisionShape for bullet.
 */
class BulletCollisionShape : public CollisionShape
{
  public:
    ~BulletCollisionShape() override = default;

    /**
     * Get a handle to the bullet object.
     *
     * @returns
     *   Bullet object.
     */
    virtual btCollisionShape *handle() const = 0;
};

}

```

`include/iris/physics/bullet/bullet_heightmap_collision_shape.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <memory>
#include <vector>

#include <BulletCollision/CollisionShapes/btHeightfieldTerrainShape.h>

#include "core/vector3.h"
#include "physics/bullet/bullet_collision_shape.h"

namespace iris
{

class Texture;

/**
 * Implementation of CollisionShape for a texture (reads height data from r component).
 */
class BulletHeightmapCollisionShape : public BulletCollisionShape
{
  public:
    /**
     * Construct a new BulletHeightMaptCollisionShape
     *
     * @param texture
     *   Texture containing height data.
     *
     * @param scale
     *   The scale of the model as it will be rendered.
     */
    explicit BulletHeightmapCollisionShape(const Texture *heightmap, const Vector3 &scale);

    ~BulletHeightmapCollisionShape() override = default;

    /**
     * Get a handle to the bullet object.
     *
     * @returns
     *   Bullet object.
     */
    btCollisionShape *handle() const override;

  private:
    /** Bullet collision shape. */
    std::unique_ptr<btHeightfieldTerrainShape> shape_;

    /** Local copy of height data (bullet only doesn't make a copy) */
    std::vector<float> height_data_;
};

}

```

`include/iris/physics/bullet/bullet_mesh_collision_shape.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <memory>

#include <BulletCollision/CollisionShapes/btBvhTriangleMeshShape.h>
#include <BulletCollision/CollisionShapes/btTriangleIndexVertexArray.h>

#include "core/vector3.h"
#include "physics/bullet/bullet_collision_shape.h"

namespace iris
{

class Mesh;

/**
 * Implementation of CollisionShape for a mesh.
 */
class BulletMeshCollisionShape : public BulletCollisionShape
{
  public:
    /**
     * Construct a new BMeshCollisionShape
     *
     * @param mesh
     *   The mesh to create the collision shape from.
     *
     * @param scale
     *   The scale of the model as it will be rendered.
     */
    explicit BulletMeshCollisionShape(const Mesh *mesh, const Vector3 &scale);

    ~BulletMeshCollisionShape() override = default;

    /**
     * Get a handle to the bullet object.
     *
     * @returns
     *   Bullet object.
     */
    btCollisionShape *handle() const override;

  private:
    /** Bullet collision shape. */
    std::unique_ptr<btBvhTriangleMeshShape> shape_;

    /** Bullet object which stores pointers to vertex and index data. */
    std::unique_ptr<btTriangleIndexVertexArray> triangle_index_vertex_data_;
};

}

```

`include/iris/physics/bullet/bullet_physics_manager.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <memory>

#include "graphics/mesh_manager.h"
#include "physics/bullet/bullet_physics_system.h"
#include "physics/physics_manager.h"

namespace iris
{

/**
 * Implementation of PhysicsManager for bullet.
 */
class BulletPhysicsManager : public PhysicsManager
{
  public:
    /**
     * Create new BulletPhysicsManager object.
     *
     * @param mesh_manager
     *   Mesh manager object.
     */
    BulletPhysicsManager(MeshManager &mesh_manager);
    ~BulletPhysicsManager() override = default;

    /**
     * Create a new PhysicsSystem.
     */
    PhysicsSystem *create_physics_system() override;

    /**
     * Get the currently active PhysicsSystem.
     *
     * @returns
     *   Pointer to the current PhysicsSystem, nullptr if one does not exist.
     */
    PhysicsSystem *current_physics_system() override;

  private:
    /** Current physics system. */
    std::unique_ptr<BulletPhysicsSystem> physics_system_;

    /** Mesh manager object. */
    MeshManager &mesh_manager_;
};

}

```

`include/iris/physics/bullet/bullet_physics_system.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <chrono>
#include <memory>
#include <optional>
#include <set>
#include <vector>

#include <BulletCollision/CollisionDispatch/btCollisionObject.h>
#include <BulletCollision/CollisionDispatch/btGhostObject.h>
#include <BulletDynamics/Dynamics/btRigidBody.h>
#include <LinearMath/btMotionState.h>
#include <btBulletDynamicsCommon.h>

#include "core/quaternion.h"
#include "core/vector3.h"
#include "graphics/mesh_manager.h"
#include "graphics/scene.h"
#include "physics/bullet/bullet_collision_shape.h"
#include "physics/bullet/debug_draw.h"
#include "physics/character_controller.h"
#include "physics/collision_shape.h"
#include "physics/contact_point.h"
#include "physics/physics_system.h"
#include "physics/ray_cast_result.h"
#include "physics/rigid_body.h"

namespace iris
{

class Mesh;
class Texture;

/**
 * Implementation of PhysicsSystem for bullet.
 */
class BulletPhysicsSystem : public PhysicsSystem
{
  public:
    /**
     * Construct a new BulletPhysicsSystem.
     *
     * @param mesh_manager
     *   Mesh manager object.
     */
    BulletPhysicsSystem(MeshManager &mesh_manager);

    ~BulletPhysicsSystem() override;

    // disabled
    BulletPhysicsSystem(const BulletPhysicsSystem &) = delete;
    BulletPhysicsSystem &operator=(const BulletPhysicsSystem &) = delete;

    /**
     * Step the physics system by the supplied time.
     *
     * @param time_step
     *   The amount of time to simulate.
     */
    void step(std::chrono::milliseconds time_step) override;

    /**
     * Create a RigidBody and add it to the simulation.
     *
     * @param position
     *   Position in world space.
     *
     * @param collision_shape
     *   The shape that defined the rigid body, this is used for collision
     *   detection/response.
     *
     * @param type
     *   The type of rigid body, this effects how this body interacts with
     *   others.
     *
     * @returns
     *   A pointer to the newly created RigidBody.
     */
    RigidBody *create_rigid_body(const Vector3 &position, const CollisionShape *collision_shape, RigidBodyType type)
        override;

    /**
     * Create a CollisionShape for a box.
     *
     * @param half_size
     *   The extends from the center of the box which define its size.
     *
     * @returns
     *   Pointer to newly created CollisionShape.
     */
    const CollisionShape *create_box_collision_shape(const Vector3 &half_size) override;

    /**
     * Create a CollisionShape for a capsule.
     *
     * @param width
     *   Diameter of capsule.
     *
     * @param height
     *   Height of capsule.
     *
     * @returns
     *   Pointer to newly created CollisionShape.
     */
    const CollisionShape *create_capsule_collision_shape(float width, float height) override;

    /**
     * Create a CollisionShape from a Mesh.
     *
     * @param mesh
     *   Mesh to create collision shape from.
     *
     * @param scale
     *   Scale of mesh as it will be rendered.
     *
     * @returns
     *   Pointer to newly created CollisionShape.
     */
    const CollisionShape *create_mesh_collision_shape(const Mesh *mesh, const Vector3 &scale) override;

    /**
     * Create a CollisionShape from a Texture (reads height data from r component).
     *
     * @param heightmap
     *   Texture containing height data.
     *
     * @param scale
     *   Scale of mesh as it will be rendered.
     *
     * @returns
     *   Pointer to newly created CollisionShape.
     */
    const CollisionShape *create_heightmap_collision_shape(const Texture *heightmap, const Vector3 &scale) override;

    /**
     * Add a character controller.
     *
     * @param character_controller
     *   Character controller to add.
     *
     * @return
     *   Pointer to added character controller.
     */
    CharacterController *add(std::unique_ptr<CharacterController> character_controller) override;

    /**
     * Remove a body from the physics system.
     *
     * This will release all resources for the body, using the handle after this
     * call is undefined.
     *
     * @param body
     *   Body to remove.
     */
    void remove(RigidBody *body) override;

    /**
     * Character controller a body from the physics system.
     *
     * This will release all resources for the character, using the handle after
     * this call is undefined.
     *
     * @param body
     *   Body to remove.
     */
    void remove(CharacterController *charaacter) override;

    /**
     * Cast a ray into physics engine world and get all hits.
     *
     * @param origin
     *   Origin of ray.
     *
     * @param direction.
     *   Direction of ray.
     *
     * @param ignore
     *   Collection of rigid bodies that should be ignored from ray cast results.
     *
     * @returns
     *   Collection of RayCastResult objects for all intersection with ray. These will be sorted from distance to origin
     *   (closest first).
     */
    std::vector<RayCastResult> ray_cast(
        const Vector3 &origin,
        const Vector3 &direction,
        const std::set<const RigidBody *> &ignore) override;

    /**
     * Query all contacts with a body.
     *
     * @param body
     *   The body to test, note that this will be contact_a in all the returned ContactPoint objects.
     *
     * @returns
     *   Collection of ContactPoint objects for all bodies colliding with body.
     */
    std::vector<ContactPoint> contacts(RigidBody *body) override;

    /**
     * Save the current state of the simulation.
     *
     * Note that depending on the implementation this may be a "best guess"
     * state save. Restoring isn't guaranteed to produce identical results
     * although it should be close enough.
     *
     * @returns
     *   Saved state.
     */
    std::unique_ptr<PhysicsState> save() override;

    /**
     * Load saved state. This will restore the simulation to that of the
     * supplied state.
     *
     * See save() comments for details of limitations.
     *
     * @param state
     *   State to restore from.
     */
    void load(const PhysicsState *state) override;

    /**
     * Enable debug rendering. This should only be called once.
     *
     * @param entity.
     *   The RenderEntity to store debug render data in.
     */
    void enable_debug_draw(Scene *scene) override;

  private:
    /** Bullet interface for detecting AABB overlapping pairs. */
    std::unique_ptr<btBroadphaseInterface> broadphase_;

    /**
     * Bullet callback for adding and removing overlapping pairs from the
     * broadphase.
     */
    std::unique_ptr<btGhostPairCallback> ghost_pair_callback_;

    /** Bullet collision config object, */
    std::unique_ptr<btDefaultCollisionConfiguration> collision_config_;

    /** Object containing algorithms for handling collision pairs. */
    std::unique_ptr<btCollisionDispatcher> collision_dispatcher_;

    /** Bullet constraint solver. */
    std::unique_ptr<btSequentialImpulseConstraintSolver> solver_;

    /** Bullet simulated world. */
    std::unique_ptr<btDiscreteDynamicsWorld> world_;

    /** Collection of rigid bodies. */
    std::vector<std::unique_ptr<RigidBody>> bodies_;

    /** Collection of character controllers. */
    std::vector<std::unique_ptr<CharacterController>> character_controllers_;

    /** DebugDraw object. */
    DebugDraw debug_draw_;

    /** Collection of collision shapes. */
    std::vector<std::unique_ptr<BulletCollisionShape>> collision_shapes_;

    /** To prevent overloading the rendering with debug data we only update the debug geometry at a fixed interval. */
    std::chrono::system_clock::time_point next_debug_update_;
};

}

```

`include/iris/physics/bullet/bullet_rigid_body.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <any>
#include <cstdint>
#include <memory>

#include <BulletCollision/CollisionDispatch/btCollisionObject.h>
#include <LinearMath/btDefaultMotionState.h>

#include "core/quaternion.h"
#include "core/vector3.h"
#include "physics/bullet/bullet_collision_shape.h"
#include "physics/rigid_body.h"
#include "physics/rigid_body_type.h"

namespace iris
{

/**
 * Implementation of RigidBody for bullet.
 */
class BulletRigidBody : public RigidBody
{
  public:
    /**
     * Construct a new BulletRigidBody.
     *
     * @param position
     *   Position in world space.
     *
     * @param collision_shape
     *   The shape that defined the rigid body, this is used for collision
     *   detection/response.
     *
     * @param type
     *   The type of rigid body, this effects how this body interacts with
     *   others.
     */
    BulletRigidBody(const Vector3 &position, const BulletCollisionShape *collision_shape, RigidBodyType type);

    ~BulletRigidBody() override = default;

    /**
     * Get position of rigid body centre of mass.
     *
     * @returns
     *   Rigid body position.
     */
    Vector3 position() const override;

    /**
     * Get orientation of rigid body.
     *
     * @returns
     *   Rigid body orientation.
     */
    Quaternion orientation() const override;

    /**
     * Get linear velocity.
     *
     * This is only valid for non GHOST type rigid bodies.
     *
     * @returns
     *   Linear velocity.
     */
    Vector3 linear_velocity() const override;

    /**
     * Get angular velocity.
     *
     * This is only valid for non GHOST type rigid bodies.
     *
     * @returns
     *   Angular velocity.
     */
    Vector3 angular_velocity() const override;

    /**
     * Set linear velocity.
     *
     * This is only valid for non GHOST type rigid bodies.
     *
     * @param linear_velocity
     *   New linear velocity.
     */
    void set_linear_velocity(const Vector3 &linear_velocity) override;

    /**
     * Set angular velocity.
     *
     * This is only valid for non GHOST type rigid bodies.
     *
     * @param angular_velocity
     *   New angular velocity.
     */
    void set_angular_velocity(const Vector3 &angular_velocity) override;

    /**
     * Reposition rigid body.
     *
     * @param position
     *   New position.
     *
     * @param orientation
     *   New orientation.
     */
    void reposition(const Vector3 &position, const Quaternion &orientation) override;

    /**
     * Get the name of the rigid body. This is an optional trait and will return
     * an empty string if a name has not already been set.
     *
     * @returns
     *   Optional name of rigid body.
     */
    std::string name() const override;

    /**
     * Set name.
     *
     * @param name
     *   New name.
     */
    void set_name(const std::string &name) override;

    /**
     * Get type.
     *
     * @returns
     *   Type of rigid body.
     */
    RigidBodyType type() const override;

    /**
     * Pointer to collision shape.
     *
     * @returns
     *   Collision shape.
     */
    const CollisionShape *collision_shape() const override;

    /**
     * Set collision shape.
     *
     * @param collision_shape
     *   New collision shape.
     */
    void set_collision_shape(const CollisionShape *collision_shape) override;

    /**
     * Apply an impulse (at the centre of mass).
     *
     * @param impulse
     *   Impulse to apply.
     */
    void apply_impulse(const Vector3 &impulse) override;

    /**
     * Get a handle to the bullet object.
     *
     * @returns
     *   Bullet object.
     */
    btCollisionObject *handle() const;

  private:
    /** Name of rigid body.*/
    std::string name_;

    /** Type of rigid body. */
    RigidBodyType type_;

    /** Collision shape of rigid body. */
    const BulletCollisionShape *collision_shape_;

    /** Bullet collision object. */
    std::unique_ptr<btCollisionObject> body_;

    /** Bullet motion state. */
    std::unique_ptr<btDefaultMotionState> motion_state_;
};

}

```

`include/iris/physics/bullet/collision_callback.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <vector>

#include <BulletCollision/CollisionDispatch/btCollisionObject.h>
#include <BulletCollision/CollisionDispatch/btCollisionWorld.h>

#include "core/vector3.h"
#include "physics/contact_point.h"
#include "physics/rigid_body.h"

namespace iris
{

/**
 * Implementation of bullet ContactResultCallback, which is used for testing collisions with a rigid body.
 */
class CollisionCallback : public btCollisionWorld::ContactResultCallback
{
  public:
    /**
     * Construct a new CollisionCallback.
     *
     * @param testing_body
     *   The body being tested for collisions, this will always be "contact_a" in ContactPoint.
     */
    CollisionCallback(RigidBody *testing_body);

    /**
     * Callback to register a collision with the testing body.
     *
     * @param cp
     *   Information of contact point.
     *
     * @param colObj0Wrap
     *   First colliding object.
     *
     * @param colObj1Wrap
     *   Second colliding object.
     *
     * @returns
     *   Unused by bullet, we always return 0.
     */
    btScalar addSingleResult(
        btManifoldPoint &cp,
        const btCollisionObjectWrapper *colObj0Wrap,
        int,
        int,
        const btCollisionObjectWrapper *colObj1Wrap,
        int,
        int) override;

    /**
     * Yields all registered ContactPoint objects.
     *
     * @returns
     *   All registered contacts.
     */
    std::vector<ContactPoint> yield_contact_points();

  private:
    /** The rigid body being tested for collisions. */
    RigidBody *testing_body_;

    /** Collection of registered contacts. */
    std::vector<ContactPoint> contact_points_;
};

}

```

`include/iris/physics/bullet/debug_draw.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <memory>
#include <unordered_map>
#include <vector>

#include <LinearMath/btIDebugDraw.h>
#include <LinearMath/btVector3.h>

#include "core/exception.h"
#include "core/vector3.h"
#include "graphics/mesh.h"
#include "graphics/mesh_manager.h"
#include "graphics/scene.h"
#include "graphics/single_entity.h"
#include "physics/bullet/bullet_box_collision_shape.h"
#include "physics/bullet/bullet_capsule_collision_shape.h"
#include "physics/bullet/bullet_heightmap_collision_shape.h"
#include "physics/bullet/bullet_mesh_collision_shape.h"
#include "physics/collision_shape.h"
#include "physics/rigid_body.h"

namespace iris
{

/**
 * Class for rendering bullet physics debug geometry to a scene.
 *
 * Whilst bullet does provide a btIDebugDraw interface it's designed around immediate mode rendering i.e. each update
 * it provides a stream of lines to draw. Forcing this into the design of the engine is cumbersome and slow. Instead
 * we expose methods for registering bullet objects we want to debug draw and internally use a btIDebugDraw to generate
 * the debug lines These are then converted to a Mesh which we add to a Scene and can transform as normal.
 */

class DebugDraw
{
  public:
    /**
     * Construct a new DebugDraw.
     *
     * @param mesh_manager
     *   Mesh manager object.
     */
    DebugDraw(MeshManager &mesh_manager);

    /**
     * Update all the registered rigid bodies.
     */
    void update();

    /**
     * Set the scene to render to.
     *
     * Note that if no scene is set the class will buffer all registered classes until a scene is set. This method
     * effectively enables debug drawing.
     *
     * @param scene
     *   Scene to render debug geometry to.
     */
    void set_scene(Scene *scene);

    /**
     * Register a new BoxCollisionShape, this allows any rigid body registered with this shape to be debug drawn.
     *
     * @param collision_shape
     *   The collision shape object to register.
     */
    void register_box_collision_shape(const BulletBoxCollisionShape *collision_shape);

    /**
     * Register a new CapsuleCollisionShape, this allows any rigid body registered with this shape to be debug drawn.
     *
     * @param collision_shape
     *   The collision shape object to register.
     */
    void register_capsule_collision_shape(const BulletCapsuleCollisionShape *collision_shape);

    /**
     * Register a new MeshCollisionShape, this allows any rigid body registered with this shape to be debug drawn.
     *
     * @param collision_shape
     *   The collision shape object to register.
     */
    void register_mesh_collision_shape(const BulletMeshCollisionShape *collision_shape);

    /**
     * Register a new HeightMapCollisionShape, this allows any rigid body registered with this shape to be debug drawn.
     *
     * @param collision_shape
     *   The collision shape object to register.
     */
    void register_height_map_collision_shape(const BulletHeightmapCollisionShape *collision_shape);

    /**
     * Register a new RigidBody for debug drawing.
     *
     * @param rigid_body
     *   The rigid body to register.
     */
    void register_rigid_body(const RigidBody *rigid_body);

    /**
     * Deregister a new RigidBody for debug drawing.
     *
     * @param rigid_body
     *   The rigid body to deregister.
     */
    void deregister_rigid_body(const RigidBody *rigid_body);

  private:
    /**
     * Implementation of btIDebugDraw which allows us to get debug geometry. This works because the base implementation
     * of all the debug methods call drawLine, which we override to store the drawn line.
     */
    struct BulletDebugDraw : btIDebugDraw
    {
        BulletDebugDraw(MeshManager &mesh_manager)
            : mesh_manager_(mesh_manager)
            , vertices_()
        {
        }

        void drawLine(const btVector3 &from, const btVector3 &to, const btVector3 &colour) override
        {
            vertices_.emplace_back(
                Vector3{from.x(), from.y(), from.z()},
                Colour{colour.x(), colour.y(), colour.z()},
                Vector3{to.x(), to.y(), to.z()},
                Colour{colour.x(), colour.y(), colour.z()});
        }

        ~BulletDebugDraw() override = default;

        void drawContactPoint(const btVector3 &, const btVector3 &, btScalar, int, const btVector3 &) override
        {
            throw Exception("unimplemented");
        }

        void reportErrorWarning(const char *) override
        {
            throw Exception("unimplemented");
        }

        void draw3dText(const ::btVector3 &, const char *) override
        {
            throw Exception("unimplemented");
        }

        void setDebugMode(int) override
        {
        }

        int getDebugMode() const override
        {
            return 0;
        }

        /**
         * Flush all the previously drawn lines to a Mesh.
         *
         * @returns
         *   A Mesh containing all the previously drawn lines.
         */
        std::unique_ptr<Mesh> flush()
        {
            std::vector<VertexData> vertices{};
            std::vector<std::uint32_t> indices;

            // convert all drawn lines to vertex and index data
            for (const auto &[from_position, from_colour, to_position, to_colour] : vertices_)
            {
                vertices.emplace_back(from_position, Vector3{1.0f}, from_colour, Vector3{});
                indices.emplace_back(static_cast<std::uint32_t>(vertices.size() - 1u));

                vertices.emplace_back(to_position, Vector3{1.0f}, to_colour, Vector3{});
                indices.emplace_back(static_cast<std::uint32_t>(vertices.size() - 1u));
            }

            // clear the drawn line store for future calls
            vertices_.clear();

            return mesh_manager_.unique_mesh(vertices, indices);
        }

        MeshManager &mesh_manager_;

        /** Cached drawn lines from bullet. */
        std::vector<std::tuple<Vector3, Colour, Vector3, Colour>> vertices_;
    };

    /** Scene to render to debug geometry to. */
    Scene *scene_;

    /** Object used to generate bullet debug geometry. */
    BulletDebugDraw bullet_debug_draw_;

    /** Collection of engine mesh objects for registered collision shapes. */
    std::unordered_map<const CollisionShape *, std::unique_ptr<Mesh>> meshes_;

    /** Collection of engine entities for registered rigid bodies. */
    std::unordered_map<const RigidBody *, SingleEntity *> bodies_;
};
}

```

`include/iris/physics/character_controller.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <chrono>

#include "core/quaternion.h"
#include "core/vector3.h"

namespace iris
{

class RigidBody;
class PhysicsSystem;

/**
 * Interface for a character controller. Deriving classes should use this interface to implement how a character should
 * move for their game.
 */
class CharacterController
{
  public:
    virtual ~CharacterController() = default;

    virtual void set_movement_direction(const Vector3 &direction) = 0;

    /**
     * Get position of character in the world.
     *
     * @returns
     *   World coordinates of character.
     */
    virtual Vector3 position() const = 0;

    /**
     * Get orientation of character.
     *
     * @returns
     *   Orientation of character
     */
    virtual Quaternion orientation() const = 0;

    /**
     * Set speed of character.
     *
     * @param speed
     *   New speed.
     */
    virtual void set_speed(float speed) = 0;

    /**
     * Reposition character.
     *
     * @param position
     *   New position.
     *
     * @param orientation
     *   New orientation.
     */
    virtual void reposition(const Vector3 &position, const Quaternion &orientation) = 0;

    /**
     * Get the underlying RigidBody.
     *
     * @returns
     *   Underlying RigidBody.
     */
    virtual RigidBody *rigid_body() const = 0;

    virtual void update(PhysicsSystem *ps, std::chrono::milliseconds delta) = 0;
};

}

```

`include/iris/physics/collision_shape.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <any>

namespace iris
{

/**
 * This is an interface for 3D shape used for collision detection and
 * resolution.
 */
class CollisionShape
{
  public:
    virtual ~CollisionShape() = default;
};

}

```

`include/iris/physics/contact_point.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include "core/vector3.h"

namespace iris
{

class RigidBody;

/**
 * Struct encapsulating data that describes a rigid body contact.
 */
struct ContactPoint
{
    /** Rigid body in contact. */
    RigidBody *contact;

    /** Position in world space of contact. */
    Vector3 position;

    /** Amount contact is penetrating. */
    float penetration;

    /** Normal of contact in world space. */
    Vector3 normal;
};

}

```

`include/iris/physics/physics_manager.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

namespace iris
{

class PhysicsSystem;

/**
 * Interface for a class which creates PhysicsSystem objects.
 */
class PhysicsManager
{
  public:
    virtual ~PhysicsManager() = default;

    /**
     * Create a new PhysicsSystem.
     */
    virtual PhysicsSystem *create_physics_system() = 0;

    /**
     * Get the currently active PhysicsSystem.
     *
     * @returns
     *   Pointer to the current PhysicsSystem, nullptr if one does not exist.
     */
    virtual PhysicsSystem *current_physics_system() = 0;
};

}

```

`include/iris/physics/physics_system.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <chrono>
#include <memory>
#include <optional>
#include <set>
#include <vector>

#include "core/quaternion.h"
#include "core/vector3.h"
#include "graphics/scene.h"
#include "physics/character_controller.h"
#include "physics/collision_shape.h"
#include "physics/contact_point.h"
#include "physics/ray_cast_result.h"
#include "physics/rigid_body.h"


namespace iris
{

class RenderEntity;
class Mesh;
class Texture;

/**
 * Interface for a class which stores the current state of a PhysicsSystem.
 */
struct PhysicsState
{
    virtual ~PhysicsState() = default;
};

/**
 * Interface for a class which can manage and simulate a physics world.
 */
class PhysicsSystem
{
  public:
    PhysicsSystem() = default;

    virtual ~PhysicsSystem() = default;

    // disabled
    PhysicsSystem(const PhysicsSystem &) = delete;
    PhysicsSystem &operator=(const PhysicsSystem &) = delete;

    /**
     * Step the physics system by the supplied time.
     *
     * @param time_step
     *   The amount of time to simulate.
     */
    virtual void step(std::chrono::milliseconds time_step) = 0;

    /**
     * Create a RigidBody and add it to the simulation.
     *
     * @param position
     *   Position in world space.
     *
     * @param collision_shape
     *   The shape that defined the rigid body, this is used for collision
     *   detection/response.
     *
     * @param type
     *   The type of rigid body, this effects how this body interacts with
     *   others.
     *
     * @returns
     *   A pointer to the newly created RigidBody.
     */
    virtual RigidBody *create_rigid_body(
        const Vector3 &position,
        const CollisionShape *collision_shape,
        RigidBodyType type) = 0;

    /**
     * Create a CollisionShape for a box.
     *
     * @param half_size
     *   The extends from the center of the box which define its size.
     *
     * @returns
     *   Pointer to newly created CollisionShape.
     */
    virtual const CollisionShape *create_box_collision_shape(const Vector3 &half_size) = 0;

    /**
     * Create a CollisionShape for a capsule.
     *
     * @param width
     *   Diameter of capsule.
     *
     * @param height
     *   Height of capsule.
     *
     * @returns
     *   Pointer to newly created CollisionShape.
     */
    virtual const CollisionShape *create_capsule_collision_shape(float width, float height) = 0;

    /**
     * Create a CollisionShape from a Mesh.
     *
     * @param mesh
     *   Mesh to create collision shape from.
     *
     * @param scale
     *   Scale of mesh as it will be rendered.
     *
     * @returns
     *   Pointer to newly created CollisionShape.
     */
    virtual const CollisionShape *create_mesh_collision_shape(const Mesh *mesh, const Vector3 &scale) = 0;

    /**
     * Create a CollisionShape from a Texture (reads height data from r component).
     *
     * @param heightmap
     *   Texture containing height data.
     *
     * @param scale
     *   Scale of mesh as it will be rendered.
     *
     * @returns
     *   Pointer to newly created CollisionShape.
     */
    virtual const CollisionShape *create_heightmap_collision_shape(const Texture *heightmap, const Vector3 &scale) = 0;

    /**
     * Add a character controller.
     *
     * @param character_controller
     *   Character controller to add.
     *
     * @return
     *   Pointer to added character controller.
     */
    virtual CharacterController *add(std::unique_ptr<CharacterController> character_controller) = 0;

    /**
     * Create a CharacterController object.
     *
     * @param args
     *   Arguments to forward to CharacterController constructor.
     *
     * @returns
     *   Pointer to newly added CharacterController.
     */
    template <class T, class... Args>
    T *create_character_controller(Args &&...args)
    {
        return static_cast<T *>(add(std::make_unique<T>(std::forward<Args>(args)...)));
    }

    /**
     * Remove a body from the physics system.
     *
     * This will release all resources for the body, using the handle after this
     * call is undefined.
     *
     * @param body
     *   Body to remove.
     */
    virtual void remove(RigidBody *body) = 0;

    /**
     * Character controller a body from the physics system.
     *
     * This will release all resources for the character, using the handle after
     * this call is undefined.
     *
     * @param character
     *   Character to remove.
     */
    virtual void remove(CharacterController *character) = 0;

    /**
     * Cast a ray into physics engine world and get all hits.
     *
     * @param origin
     *   Origin of ray.
     *
     * @param direction.
     *   Direction of ray.
     *
     * @param ignore
     *   Collection of rigid bodies that should be ignored from ray cast results.
     *
     * @returns
     *   Collection of RayCastResult objects for all intersection with ray. These will be sorted from distance to origin
     *   (closest first).
     */
    virtual std::vector<RayCastResult> ray_cast(
        const Vector3 &origin,
        const Vector3 &direction,
        const std::set<const RigidBody *> &ignore) = 0;

    /**
     * Query all contacts with a body.
     *
     * @param body
     *   The body to test, note that this will be contact_a in all the returned ContactPoint objects.
     *
     * @returns
     *   Collection of ContactPoint objects for all bodies colliding with body.
     */
    virtual std::vector<ContactPoint> contacts(RigidBody *body) = 0;

    /**
     * Save the current state of the simulation.
     *
     * Note that depending on the implementation this may be a "best guess"
     * state save. Restoring isn't guaranteed to produce identical results
     * although it should be close enough.
     *
     * @returns
     *   Saved state.
     */
    virtual std::unique_ptr<PhysicsState> save() = 0;

    /**
     * Load saved state. This will restore the simulation to that of the
     * supplied state.
     *
     * See save() comments for details of limitations.
     *
     * @param state
     *   State to restore from.
     */
    virtual void load(const PhysicsState *state) = 0;

    /**
     * Enable debug rendering. This should only be called once.
     *
     * @param entity.
     *   The RenderEntity to store debug render data in.
     */
    virtual void enable_debug_draw(Scene *scene) = 0;
};

}

```

`include/iris/physics/ray_cast_result.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include "core/vector3.h"

namespace iris
{

class RigidBody;

/**
 * Struct encapsulating a hit from a ray cast.
 */
struct RayCastResult
{
    /** Body hit. */
    RigidBody *body;

    /** Worlds space of ray intersection with body. */
    Vector3 position;
};

}

```

`include/iris/physics/rigid_body.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <any>
#include <cstdint>
#include <memory>

#include "core/quaternion.h"
#include "core/vector3.h"
#include "physics/collision_shape.h"
#include "physics/rigid_body_type.h"

namespace iris
{

/**
 * Interface for a  rigid body, a physics entity that can be added to the
 * physics systems and simulated. It can collide and interact with other rigid
 * bodies.
 */
class RigidBody
{
  public:
    virtual ~RigidBody() = default;

    /**
     * Get position of rigid body centre of mass.
     *
     * @returns
     *   Rigid body position.
     */
    virtual Vector3 position() const = 0;

    /**
     * Get orientation of rigid body.
     *
     * @returns
     *   Rigid body orientation.
     */
    virtual Quaternion orientation() const = 0;

    /**
     * Get linear velocity.
     *
     * This is only valid for non GHOST type rigid bodies.
     *
     * @returns
     *   Linear velocity.
     */
    virtual Vector3 linear_velocity() const = 0;

    /**
     * Get angular velocity.
     *
     * This is only valid for non GHOST type rigid bodies.
     *
     * @returns
     *   Angular velocity.
     */
    virtual Vector3 angular_velocity() const = 0;

    /**
     * Set linear velocity.
     *
     * This is only valid for non GHOST type rigid bodies.
     *
     * @param linear_velocity
     *   New linear velocity.
     */
    virtual void set_linear_velocity(const Vector3 &linear_velocity) = 0;

    /**
     * Set angular velocity.
     *
     * This is only valid for non GHOST type rigid bodies.
     *
     * @param angular_velocity
     *   New angular velocity.
     */
    virtual void set_angular_velocity(const Vector3 &angular_velocity) = 0;

    /**
     * Reposition rigid body.
     *
     * @param position
     *   New position.
     *
     * @param orientation
     *   New orientation.
     */
    virtual void reposition(const Vector3 &position, const Quaternion &orientation) = 0;

    /**
     * Get the name of the rigid body. This is an optional trait and will return
     * an empty string if a name has not already been set.
     *
     * @returns
     *   Optional name of rigid body.
     */
    virtual std::string name() const = 0;

    /**
     * Set name.
     *
     * @param name
     *   New name.
     */
    virtual void set_name(const std::string &name) = 0;

    /**
     * Get type.
     *
     * @returns
     *   Type of rigid body.
     */
    virtual RigidBodyType type() const = 0;

    /**
     * Pointer to collision shape.
     *
     * @returns
     *   Collision shape.
     */
    virtual const CollisionShape *collision_shape() const = 0;

    /**
     * Set collision shape.
     *
     * @param collision_shape
     *   New collision shape.
     */
    virtual void set_collision_shape(const CollisionShape *collision_shape) = 0;

    /**
     * Apply an impulse (at the centre of mass).
     *
     * @param impulse
     *   Impulse to apply.
     */
    virtual void apply_impulse(const Vector3 &impulse) = 0;
};

}

```

`include/iris/physics/rigid_body_type.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>

namespace iris
{

/**
 * Enumeration of possible rigid body types.
 */
enum class RigidBodyType : std::uint32_t
{
    /**
     * A rigid body that is simulated as part of the physics engine and
     * approximates a real world object (forces, velocity, collision, etc.).
     */
    NORMAL,

    /**
     * A rigid body that does not move. Other non static rigid bodies will
     * collide with it.
     */
    STATIC,

    /**
     * A rigid body that can be moved and detects collision, although it does
     * not perform collision resolution.
     */
    GHOST,

    /**
     * A specialisation of GHOST for character controllers. This behaves exactly the same as GHOST but allows custom
     * character controller logic to differentiate between ghosts and characters, so they can apply collision resolution
     * (if needed).
     */
    CHARACTER_CONTROLLER
};

}

```

`include/iris/scripting/lua/interop/class_interop.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <functional>
#include <map>
#include <string>

struct lua_State;

namespace iris::interop::lua
{

using LuaInteropFunction = std::function<int(lua_State *)>;

/**
 * Struct encapsulating all the data needed to register a class for lua interop.
 */
struct ClassInterop
{
    /** Name of class. */
    std::string name;

    /** Constructor function. */
    LuaInteropFunction constructor;

    /** Constructor function. */
    LuaInteropFunction destructor;

    /** Collection of named member functions. */
    std::map<std::string, LuaInteropFunction> members;
};

}

```

`include/iris/scripting/lua/interop/quaternion.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <sstream>
#include <string>

#include "core/error_handling.h"
#include "core/quaternion.h"
#include "core/vector3.h"
#include "scripting/lua/interop/class_interop.h"

struct lua_State;

namespace iris::interop::lua
{

void quaternion_construct_raw(lua_State *state, const Quaternion &quaternion);

Quaternion **get_quaternion(lua_State *state);

// these functions all represent the various supported interop functionality

int quaternion_constructor(lua_State *state);

int quaternion_destructor(lua_State *state);

int quaternion_x(lua_State *state);

int quaternion_set_x(lua_State *state);

int quaternion_y(lua_State *state);

int quaternion_set_y(lua_State *state);

int quaternion_z(lua_State *state);

int quaternion_set_z(lua_State *state);

int quaternion_w(lua_State *state);

int quaternion_set_w(lua_State *state);

int quaternion_to_string(lua_State *state);

int quaternion_equality(lua_State *state);

int quaternion_negate(lua_State *state);

int quaternion_add(lua_State *state);

int quaternion_sub(lua_State *state);

int quaternion_mul(lua_State *state);

int quaternion_dot(lua_State *state);

int quaternion_slerp(lua_State *state);

int quaternion_normalise(lua_State *state);

static const ClassInterop quaternion_class_interop{
    .name = "Quaternion",
    .constructor = quaternion_constructor,
    .destructor = quaternion_destructor,
    .members = {
        {"__tostring", quaternion_to_string},
        {"__eq", quaternion_to_string},
        {"__unm", quaternion_negate},
        {"__add", quaternion_add},
        {"__sub", quaternion_sub},
        {"__mul", quaternion_mul},
        {"x", quaternion_x},
        {"set_x", quaternion_set_x},
        {"y", quaternion_y},
        {"set_y", quaternion_set_y},
        {"z", quaternion_z},
        {"set_z", quaternion_set_z},
        {"w", quaternion_w},
        {"set_w", quaternion_set_w},
        {"dot", quaternion_dot},
        {"slerp", quaternion_slerp},
        {"normalise", quaternion_normalise}}};

}

```

`include/iris/scripting/lua/interop/register_class.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include "scripting/lua/interop/class_interop.h"

struct lua_State;

namespace iris::interop::lua
{

/**
 * Register a class for lua interop.
 *
 * @param state
 *   Lua state object.
 *
 * @param class_interop
 *   Class data to register.
 */
void register_class(lua_State *state, const ClassInterop &class_interop);

}

```

`include/iris/scripting/lua/interop/vector3.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <sstream>
#include <string>

#include "core/error_handling.h"
#include "core/vector3.h"
#include "scripting/lua/interop/class_interop.h"

struct lua_State;

namespace iris::interop::lua
{

void vector3_construct_raw(lua_State *state, const Vector3 &vec);

Vector3 **get_vector3(lua_State *state);

// these functions all represent the various supported interop functionality

int vector3_constructor(lua_State *state);

int vector3_destructor(lua_State *state);

int vector3_x(lua_State *state);

int vector3_set_x(lua_State *state);

int vector3_y(lua_State *state);

int vector3_set_y(lua_State *state);

int vector3_z(lua_State *state);

int vector3_set_z(lua_State *state);

int vector3_to_string(lua_State *state);

int vector3_equality(lua_State *state);

int vector3_negate(lua_State *state);

int vector3_add(lua_State *state);

int vector3_sub(lua_State *state);

int vector3_mul(lua_State *state);

int vector3_dot(lua_State *state);

int vector3_cross(lua_State *state);

int vector3_normalise(lua_State *state);

int vector3_magnitude(lua_State *state);

int vector3_lerp(lua_State *state);

static const ClassInterop vector3_class_interop{
    .name = "Vector3",
    .constructor = vector3_constructor,
    .destructor = vector3_destructor,
    .members = {
        {"__tostring", vector3_to_string},
        {"__eq", vector3_to_string},
        {"__unm", vector3_negate},
        {"__add", vector3_add},
        {"__sub", vector3_sub},
        {"__mul", vector3_mul},
        {"x", vector3_x},
        {"set_x", vector3_set_x},
        {"y", vector3_y},
        {"set_y", vector3_set_y},
        {"z", vector3_z},
        {"set_z", vector3_set_z},
        {"dot", vector3_dot},
        {"cross", vector3_cross},
        {"normalise", vector3_normalise},
        {"magnitude", vector3_magnitude},
        {"lerp", vector3_lerp}}};

}

```

`include/iris/scripting/lua/lua_script.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <memory>
#include <string>

#include "core/quaternion.h"
#include "core/resource_manager.h"
#include "core/vector3.h"
#include "scripting/script.h"

namespace iris
{

/**
 * Implementation of Script for Lua.
 *
 * Note that this interface is deliberately verbose. It's effectively a state machine where you:
 * - set the function you want to call
 * - set the arguments (on order)
 * - call execute (with the number of arguments and results)
 * - get all the results (in reverse order)
 *
 * Whilst flexible this is error prone, the preferred way to execute a script is to use the ScriptRunner class, which
 * handles all the complexity and provides a much simpler interface.
 */
class LuaScript : public Script
{
  public:
    /**
     * Construct a new LuaScript.
     *
     * @param source
     *   The source for the lua script.
     */
    explicit LuaScript(const std::string &source);

    /**
     * Construct a new LuaScript.
     *
     * @param file
     *   File to load script from (via ResourceLoader).
     *
     * @param
     *   Tag to indicate script should be loaded from a file.
     */
    LuaScript(ResourceManager &resource_manager, const std::string &file);

    ~LuaScript() override;

    LuaScript(const LuaScript &) = delete;
    LuaScript &operator=(const LuaScript &) = delete;

    /**
     * Set the name of the function in the script to call.
     *
     * @param function
     *   Name of function to call.
     */
    void set_function(const std::string &function) override;

    /**
     * Set an argument for the executing function.
     *
     * @param argument
     *   Argument for function.
     */
    void set_argument(bool argument) override;

    /**
     * Set an argument for the executing function.
     *
     * @param argument
     *   Argument for function.
     */
    void set_argument(std::int32_t argument) override;

    /**
     * Set an argument for the executing function.
     *
     * @param argument
     *   Argument for function.
     */
    void set_argument(float argument) override;

    /**
     * Set an argument for the executing function.
     *
     * @param argument
     *   Argument for function.
     */
    void set_argument(const char *argument) override;

    /**
     * Set an argument for the executing function.
     *
     * @param argument
     *   Argument for function.
     */
    void set_argument(const std::string &argument) override;

    /**
     * Set an argument for the executing function.
     *
     * @param argument
     *   Argument for function.
     */
    void set_argument(const Vector3 &argument) override;

    /**
     * Set an argument for the executing function.
     *
     * @param argument
     *   Argument for function.
     */
    void set_argument(const Quaternion &argument) override;

    /**
     * Execute the set function.
     *
     * Note it is undefined to call this method without first correctly setting the function name and arguments.
     *
     * @param num_args
     *   Number of arguments to pass to the function.
     *
     * @param num_results
     *   Number if results expected from the script.
     */
    void execute(std::uint32_t num_args, std::uint32_t num_results) override;

    /**
     * Get a result from the executed function.
     *
     * @param result
     *   Out parameter for result.
     */
    void get_result(bool &result) override;

    /**
     * Get a result from the executed function.
     *
     * @param result
     *   Out parameter for result.
     */
    void get_result(std::int32_t &result) override;

    /**
     * Get a result from the executed function.
     *
     * @param result
     *   Out parameter for result.
     */
    void get_result(float &result) override;

    /**
     * Get a result from the executed function.
     *
     * @param result
     *   Out parameter for result.
     */
    void get_result(std::string &result) override;

    /**
     * Get a result from the executed function.
     *
     * @param result
     *   Out parameter for result.
     */
    void get_result(Vector3 &result) override;

    /**
     * Get a result from the executed function.
     *
     * @param result
     *   Out parameter for result.
     */
    void get_result(Quaternion &result) override;

  private:
    /** Pointer to implementation. */
    struct implementation;
    std::unique_ptr<implementation> impl_;
};

}

```

`include/iris/scripting/script.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <string>

#include "core/quaternion.h"
#include "core/vector3.h"

namespace iris
{

/**
 * Interface for script, an object which can execute code from another language embedded in the engine.
 *
 * Note that this interface is deliberately verbose. It's effectively a state machine where you:
 * - set the function you want to call
 * - set the arguments (on order)
 * - call execute (with the number of arguments and results)
 * - get all the results (in reverse order)
 *
 * Whilst flexible this is error prone, the preferred way to execute a script is to use the ScriptRunner class, which
 * handles all the complexity and provides a much simpler interface.
 */
class Script
{
  public:
    virtual ~Script() = default;

    /**
     * Set the name of the function in the script to call.
     *
     * @param function
     *   Name of function to call.
     */
    virtual void set_function(const std::string &function) = 0;

    /**
     * Set an argument for the executing function.
     *
     * @param argument
     *   Argument for function.
     */
    virtual void set_argument(bool argument) = 0;

    /**
     * Set an argument for the executing function.
     *
     * @param argument
     *   Argument for function.
     */
    virtual void set_argument(std::int32_t argument) = 0;

    /**
     * Set an argument for the executing function.
     *
     * @param argument
     *   Argument for function.
     */
    virtual void set_argument(float argument) = 0;

    /**
     * Set an argument for the executing function.
     *
     * @param argument
     *   Argument for function.
     */
    virtual void set_argument(const char *argument) = 0;

    /**
     * Set an argument for the executing function.
     *
     * @param argument
     *   Argument for function.
     */
    virtual void set_argument(const std::string &argument) = 0;

    /**
     * Set an argument for the executing function.
     *
     * @param argument
     *   Argument for function.
     */
    virtual void set_argument(const Vector3 &argument) = 0;

    /**
     * Set an argument for the executing function.
     *
     * @param argument
     *   Argument for function.
     */
    virtual void set_argument(const Quaternion &argument) = 0;

    /**
     * Execute the set function.
     *
     * Note it is undefined to call this method without first correctly setting the function name and arguments.
     *
     * @param num_args
     *   Number of arguments to pass to the function.
     *
     * @param num_results
     *   Number if results expected from the script.
     */
    virtual void execute(std::uint32_t num_args, std::uint32_t num_results) = 0;

    /**
     * Get a result from the executed function.
     *
     * @param result
     *   Out parameter for result.
     */
    virtual void get_result(bool &result) = 0;

    /**
     * Get a result from the executed function.
     *
     * @param result
     *   Out parameter for result.
     */
    virtual void get_result(std::int32_t &result) = 0;

    /**
     * Get a result from the executed function.
     *
     * @param result
     *   Out parameter for result.
     */
    virtual void get_result(float &result) = 0;

    /**
     * Get a result from the executed function.
     *
     * @param result
     *   Out parameter for result.
     */
    virtual void get_result(std::string &result) = 0;

    /**
     * Get a result from the executed function.
     *
     * @param result
     *   Out parameter for result.
     */
    virtual void get_result(Vector3 &result) = 0;

    /**
     * Get a result from the executed function.
     *
     * @param result
     *   Out parameter for result.
     */
    virtual void get_result(Quaternion &result) = 0;
};

}

```

`include/iris/scripting/script_runner.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <memory>
#include <tuple>
#include <type_traits>

#include "scripting/script.h"

namespace script_runner_impl
{

/**
 * Helper function to get results of script.
 *
 * @param script
 *   Script to get results from.
 *
 * @param result
 *   Tuple to store results in.
 */
template <int I, int M, class T>
inline void get_results(iris::Script *script, T &result)
{
    script->get_result(std::get<M - I - 1>(result));

    if constexpr (I != M - 1)
    {
        get_results<I + 1, M>(script, result);
    }
}

/**
 * Base case no arguments specialisation.
 */
inline void handle_args(iris::Script *)
{
}

/**
 * Base case single arguments specialisation.
 *
 * @param script
 *   Script to set arguments for.
 *
 * @param head
 *   Head of variadic list.
 *
 */
template <class Head>
inline void handle_args(iris::Script *script, Head head)
{
    script->set_argument(head);
}

/**
 * Template function to recursively set each argument in a variadic list.
 *
 * @param script
 *   Script to set arguments for.
 *
 * @param head
 *   Head of variadic list.
 *
 * @param tail
 *   Rest of variadic list.
 */
template <class Head, class... Tail>
inline void handle_args(iris::Script *script, Head head, Tail... tail)
{
    handle_args(script, head);
    handle_args(script, tail...);
}

}

namespace iris
{

// Base struct for deducing return type of ScriptRunner::execute.
template <class... R>
struct ReturnHelper;

// Specialisation - no arguments then type is void.
template <>
struct ReturnHelper<>
{
    using type = void;
};

// Specialisation - single argument then type is that argument
template <class R>
struct ReturnHelper<R>
{
    using type = R;
};

// Specialisation - multiple argumetns then type is tuple of all arguments
template <class... R>
struct ReturnHelper
{
    using type = std::tuple<R...>;
};

// convenience alias
template <class... R>
using return_type_t = typename ReturnHelper<R...>::type;

/**
 * This is a convenience class for executing a Script object. It abstracts away the need for calling all the individual
 * functions in Script.
 */
class ScriptRunner
{
  public:
    /**
     * Construct a new ScriptRunner.
     *
     * @param script
     *   Script to run.
     */
    ScriptRunner(std::unique_ptr<Script> script)
        : script_(std::move(script))
    {
    }

    ScriptRunner(const ScriptRunner &) = delete;
    ScriptRunner &operator=(const ScriptRunner &) = delete;

    /**
     * Execute a function in the script with the supplied arguments.
     *
     * The supplied template parameters should be the expected result types.
     *
     * @param function
     *   Name of function to execute.
     *
     * @param args
     *   Arguments to function.
     *
     * @return
     *   Either void, a single type or tuple of multiple types depending on supplied template parameters.
     */
    template <class... R, class... Args>
    return_type_t<R...> execute(const std::string &function, Args &&...args)
    {
        if constexpr (sizeof...(R) == 0)
        {
            // no return type (a void function)
            std::tuple<> result;
            do_execute(function, result, std::forward<Args>(args)...);
        }
        else if constexpr (sizeof...(R) == 1)
        {
            // single return type

            // create a result tuple of just the single type and we will extract it at the end
            std::tuple<return_type_t<R...>> result;
            do_execute(function, result, std::forward<Args>(args)...);
            return std::get<0>(result);
        }
        else
        {
            // multiple return types
            return_type_t<R...> result;
            do_execute(function, result, std::forward<Args>(args)...);
            return result;
        }
    }

  private:
    /**
     * Do the execution of the script.
     *
     * @param function
     *   Name of function to execute.
     *
     * @param result
     *   Out parameter for script results. Must be a tuple.
     *
     * @param args
     *   Arguments to function.
     */
    template <class... Args, class T>
    void do_execute(const std::string &function, T &result, Args &&...args)
    {
        // set function name
        script_->set_function(function);

        // set function arguments
        script_runner_impl::handle_args(script_.get(), std::forward<Args>(args)...);

        // execute function
        script_->execute(sizeof...(Args), std::tuple_size_v<T>);

        // get results (if any)
        if constexpr (std::tuple_size_v<T> != 0)
        {
            script_runner_impl::get_results<0, std::tuple_size_v<T>>(script_.get(), result);
        }
    }

  private:
    /** Script object to run. */
    std::unique_ptr<Script> script_;
};

}

```

`samples/CMakeLists.txt`:

```txt
add_subdirectory("sample_browser")
add_subdirectory("jobs")

```

`samples/jobs/CMakeLists.txt`:

```txt
add_executable(jobs main.cpp)

target_include_directories(jobs PRIVATE ${stb_SOURCE_DIR})

target_link_libraries(jobs iris)

if(IRIS_PLATFORM MATCHES "WIN32")
  set_target_properties(jobs PROPERTIES MSVC_RUNTIME_LIBRARY "MultiThreadedDebug")
endif()


```

`samples/jobs/main.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include <chrono>
#define _USE_MATH_DEFINES
#include <cmath>
#include <iostream>
#include <random>
#include <vector>

#define STB_IMAGE_WRITE_IMPLEMENTATION
#include <stb_image_write.h>

#include "core/colour.h"
#include "core/context.h"
#include "core/exception.h"
#include "core/start.h"
#include "core/vector3.h"
#include "jobs/job.h"
#include "jobs/job_system_manager.h"
#include "log/log.h"

/**
 * Simple ray class.
 */
struct Ray
{
    Ray(const iris::Vector3 &origin, const iris::Vector3 &direction)
        : origin(origin)
        , direction(direction)
    {
    }

    iris::Vector3 origin;
    iris::Vector3 direction;
};

/**
 * Simple sphere class.
 */
struct Sphere
{
    Sphere(const iris::Vector3 &origin, float radius, const iris::Colour &colour)
        : origin(origin)
        , radius(radius)
        , colour(colour)
    {
    }

    std::tuple<float, iris::Vector3, iris::Vector3> intersects(const Ray &ray) const
    {
        auto L = origin - ray.origin;
        auto tca = L.dot(ray.direction);
        auto d2 = L.dot(L) - tca * tca;
        if (d2 > radius * radius)
        {
            return {std::numeric_limits<float>::max(), {}, {}};
        }

        auto thc = sqrtf(radius * radius - d2);
        auto t0 = tca - thc;
        auto t1 = tca + thc;
        if (t0 < 0)
        {
            t0 = t1;
        }

        if (t0 < 0)
        {
            return {std::numeric_limits<float>::max(), {}, {}};
        }

        auto q = ray.origin + (ray.direction * t0);
        return {t0, q, iris::Vector3::normalise(q - origin)};
    }

    iris::Vector3 origin;
    float radius;
    iris::Colour colour;
    bool is_metal = false;

    float rougness = 0.0f;
};

// helpful globals
std::random_device rd;
std::mt19937 generator(rd());
static std::vector<Sphere> scene;

iris::Vector3 random_unit_vector()
{
    std::uniform_real_distribution<float> dist1(0.0f, 1.0f);
    float z = dist1(generator) * 2.0f - 1.0f;
    float a = dist1(generator) * 2.0f * M_PI;
    float r = sqrtf(1.0f - z * z);
    float x = r * cosf(a);
    float y = r * sinf(a);
    return {x, y, z};
}

iris::Vector3 random_in_unit_sphere()
{
    std::uniform_real_distribution<float> dist1(0.0f, 1.0f);
    iris::Vector3 p;
    do
    {
        p = iris::Vector3{dist1(generator), dist1(generator), dist1(generator)} * 2.0 - iris::Vector3(1, 1, 1);
    } while (p.dot(p) >= 1.0);
    return p;
}

/**
 * Recursively trace a ray through a scene, to a max depth.
 */
iris::Colour trace(const Ray &ray, int depth)
{
    const Sphere *hit = nullptr;
    auto distance = std::numeric_limits<float>::max();
    iris::Vector3 point;
    iris::Vector3 normal;

    for (const auto &shape : scene)
    {
        const auto &[d, p, n] = shape.intersects(ray);

        if (d < distance)
        {
            distance = d;
            point = p;
            normal = n;
            hit = &shape;
        }
    }

    // return sky colour if we don't hit anything
    if (hit == nullptr)
    {
        return {0.9f, 0.9f, 0.9f};
    }

    const auto emittance = hit->colour;

    // return black if we hit max depth
    if (depth > 4)
    {
        return {0.0f, 0.0f, 0.0f};
    }

    Ray newRay{{}, {}};

    // create another ray to trace, based on material
    if (hit->is_metal)
    {
        auto reflect = ray.direction - normal * ray.direction.dot(normal) * 2;
        newRay = {point, iris::Vector3::normalise(reflect + random_in_unit_sphere() * hit->rougness)};
        newRay.origin += newRay.direction * 0.01f;
    }
    else
    {
        auto target = point + normal + random_unit_vector();

        newRay = {point, iris::Vector3::normalise(target - point)};
        newRay.origin += newRay.direction * 0.001f;
    }

    // trace next ray and mix in its colour
    return emittance * trace(newRay, depth + 1);
}

void go(iris::Context context)
{
    iris::Logger::instance().ignore_tag("js");

    scene.emplace_back(iris::Vector3{150.0f, 0.0f, -600.0f}, 100.0f, iris::Colour{0.58f, 0.49f, 0.67f});
    scene.emplace_back(iris::Vector3{-150.0f, 0.0f, -600.0f}, 100.0f, iris::Colour{0.99f, 0.78f, 0.84f});
    scene.emplace_back(iris::Vector3{00.0f, 0.0f, -750.0f}, 100.0f, iris::Colour{1.0f, 0.87f, 0.82f});
    scene.emplace_back(iris::Vector3{0.0f, -10100.0f, -600.0f}, 10000.0f, iris::Colour{1.0f, 1.0f, 1.0f});

    scene[2].is_metal = true;
    scene[2].rougness = 0.9;

    static const auto width = 600;
    static const auto height = 400;
    std::vector<std::uint8_t> pixels(width * height * 3);
    std::size_t counter = 0u;

    const float fov = M_PI / 3.;
    std::uniform_real_distribution<float> dist1(-0.5f, 0.5f);

    std::vector<iris::Job> jobs;

    LOG_INFO("job_system", "starting");
    auto start = std::chrono::high_resolution_clock::now();

    for (std::size_t j = 0; j < height; j++)
    {
        for (std::size_t i = 0; i < width; i++)
        {
            jobs.emplace_back(
                [i, j, fov, counter, &pixels, &dist1]()
                {
                    const auto dir_x = (i + 0.5f) - width / 2.0f;
                    const auto dir_y = -(j + 0.5f) + height / 2.0f;
                    const auto dir_z = -height / (2.0f * tan(fov / 2.0f));

                    iris::Colour pixel;

                    auto samples = 100;

                    for (int i = 0; i < samples; i++)
                    {
                        pixel += trace(
                            {{0, 0, 0},
                             iris::Vector3::normalise({dir_x + dist1(generator), dir_y + dist1(generator), dir_z})},
                            1);
                    }

                    pixel *= (1.0 / (float)samples);

                    // clamp colours
                    pixels[counter + 0u] =
                        static_cast<std::uint8_t>((255.0f * std::max(0.0f, std::min(1.0f, (float)pixel.r))));
                    pixels[counter + 1u] =
                        static_cast<std::uint8_t>((255.0f * std::max(0.0f, std::min(1.0f, (float)pixel.g))));
                    pixels[counter + 2u] =
                        static_cast<std::uint8_t>((255.0f * std::max(0.0f, std::min(1.0f, (float)pixel.b))));
                });

            counter += 3u;
        }
    }

    do
    {
        const auto count = std::min((std::size_t)900ul, jobs.size());
        std::vector<iris::Job> batch(std::cend(jobs) - count, std::cend(jobs));
        jobs.erase(std::cend(jobs) - count, std::cend(jobs));

        context.jobs_manager().wait(batch);

    } while (!jobs.empty());

    auto end = std::chrono::high_resolution_clock::now();

    LOG_INFO(
        "job_sample", "render time: {}ms", std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count());

    stbi_write_png("render.png", width, height, 3, pixels.data(), 3 * width);

    LOG_INFO("job_sample", "done");
}

int main(int argc, char **argv)
{
    iris::start(argc, argv, go);

    return 0;
}

```

`samples/networking/CMakeLists.txt`:

```txt
set(CLIENT_SRCS client.cpp)

set(SERVER_SRCS server.cpp)

if(IRIS_PLATFORM MATCHES "IOS")
  set(IOS_RESOURCES "Default-568h@2x.png")

  add_executable(client MACOSX_BUNDLE ${CLIENT_SRCS} ${IOS_RESOURCES})
  set(MACOSX_BUNDLE_GUI_IDENTIFIER "${IRIS_BUNDLE_IDENTIFIER}.client")

  set_target_properties(
    client
    PROPERTIES MACOSX_BUNDLE YES
               XCODE_ATTRIBUTE_CODE_SIGN_IDENTITY "iPhone Developer"
               XCODE_ATTRIBUTE_DEVELOPMENT_TEAM "${IRIS_DEVELOPMENT_TEAM}"
               RESOURCE "${IOS_RESOURCES}")

else()
  add_executable(client ${CLIENT_SRCS})
endif()

add_executable(server ${SERVER_SRCS})

target_link_libraries(client iris)
target_link_libraries(server iris)

```

`samples/networking/client.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include <cassert>
#include <chrono>
#include <cstddef>
#include <cstdint>
#include <cstring>
#include <deque>
#include <limits>
#include <map>
#include <memory>
#include <numeric>
#include <optional>
#include <ratio>
#include <tuple>
#include <vector>

#include "core/camera.h"
#include "core/data_buffer.h"
#include "core/exception.h"
#include "core/looper.h"
#include "core/quaternion.h"
#include "core/start.h"
#include "core/vector3.h"
#include "core/window.h"
#include "events/keyboard_event.h"
#include "graphics/mesh_factory.h"
#include "graphics/pipeline.h"
#include "graphics/render_entity.h"
#include "graphics/scene.h"
#include "graphics/stage.h"
#include "log/emoji_formatter.h"
#include "log/log.h"
#include "networking/client_connection_handler.h"
#include "networking/data_buffer_deserialiser.h"
#include "networking/data_buffer_serialiser.h"
#include "networking/packet.h"
#include "networking/udp_socket.h"
#include "physics/basic_character_controller.h"
#include "physics/box_collision_shape.h"
#include "physics/physics_system.h"
#include "physics/rigid_body.h"

#include "client_input.h"

using namespace std::chrono_literals;

/**
 * Process all pending user input. This will send input to the server as well as
 * store it locally.
 *
 * @param inputs
 *   Collection to store inputs in.
 *
 * @param camera
 *   Camera to update.
 *
 * @param tick
 *   Current client tick number.
 *
 * @param client
 *   Object to communicate with server.
 *
 * @returns
 *   True if user has quit, false otherwise.
 */
bool handle_input(
    std::deque<ClientInput> &inputs,
    iris::Camera &camera,
    std::uint32_t tick,
    iris::ClientConnectionHandler &client,
    iris::Window &window)
{
    auto quit = false;

    // we just continuously update a static input object, this ensures the
    // object always represents the current input state
    static ClientInput input;

    auto has_input = false;

    // consume all inputs
    for (;;)
    {
        auto evt = window.pump_event();
        if (!evt)
        {
            break;
        }

        if (evt->is_key(iris::Key::ESCAPE))
        {
            quit = true;
        }
        else if (evt->is_key())
        {
            const auto keyboard = evt->key();

            // convert input keys to client input
            switch (keyboard.key)
            {
                case iris::Key::W:
                    input.forward =
                        keyboard.state == iris::KeyState::DOWN ? -1.0f : 0.0f;
                    break;
                case iris::Key::S:
                    input.forward =
                        keyboard.state == iris::KeyState::DOWN ? 1.0f : 0.0f;
                    break;
                case iris::Key::A:
                    input.side =
                        keyboard.state == iris::KeyState::DOWN ? -1.0f : 0.0f;
                    break;
                case iris::Key::D:
                    input.side =
                        keyboard.state == iris::KeyState::DOWN ? 1.0f : 0.0f;
                    break;
                default: break;
            }

            has_input = true;
        }
        else if (evt->is_mouse())
        {
            // update camera based on mouse movement
            static const auto sensitivity = 0.0025f;
            const auto mouse = evt->mouse();

            camera.adjust_yaw(mouse.delta_x * sensitivity);
            camera.adjust_pitch(-mouse.delta_y * sensitivity);
        }
    }

    // if we processed any input then send the latest input state to the server
    // and store a copy locally
    if (has_input)
    {
        input.tick = tick;

        iris::DataBufferSerialiser serialiser;
        input.serialise(serialiser);
        client.send(serialiser.data(), iris::ChannelType::RELIABLE_ORDERED);

        inputs.emplace_back(input);
    }

    return quit;
}

/**
 * Process an update from the server on the state of the world.
 *
 * @param server_data
 *   Data from server
 *
 * @param snapshots
 *   Collection snapshots of server updates (of non player entity).
 *
 * @param history
 *   Collection of local state history.
 *
 * @param inputs
 *   Collection of stored user inputs.
 *
 * @returns
 *   Tuple of various server data.
 */
std::tuple<std::uint32_t, iris::Vector3, iris::Vector3, iris::Vector3>
process_server_update(
    const iris::DataBuffer &server_data,
    std::deque<std::tuple<
        std::chrono::steady_clock::time_point,
        iris::Vector3,
        iris::Quaternion>> &snapshots,
    std::vector<std::tuple<
        std::uint32_t,
        iris::Vector3,
        std::unique_ptr<iris::PhysicsState, iris::PhysicsStateDeleter>>>
        &history,
    std::deque<ClientInput> &inputs)
{
    // deserialise server update
    iris::DataBufferDeserialiser deserialiser(server_data);
    const auto position = deserialiser.pop<iris::Vector3>();
    const auto linear_velocity = deserialiser.pop<iris::Vector3>();
    const auto angular_velocity = deserialiser.pop<iris::Vector3>();
    const auto last_acked = deserialiser.pop<std::uint32_t>();
    const auto box_pos = deserialiser.pop<iris::Vector3>();
    auto box_rot = deserialiser.pop<iris::Quaternion>();
    box_rot.normalise();

    // store server update of box, put the time in the future so we can easily
    // interpolate between snapshots
    snapshots.emplace_back(
        std::chrono::steady_clock::now() + 100ms, box_pos, box_rot);

    // find the last input acknowledged by the server
    const auto acked_input = std::find_if(
        std::cbegin(inputs),
        std::cend(inputs),
        [last_acked](const ClientInput &element) {
            return element.tick >= last_acked;
        });

    // cleanup old inputs
    if (acked_input != std::cend(inputs))
    {
        inputs.erase(std::cbegin(inputs), acked_input);
    }

    // find last history entry acknowledged by the server
    const auto acked_history = std::find_if(
        std::cbegin(history),
        std::cend(history),
        [last_acked](const auto &element) {
            return std::get<0>(element) == last_acked;
        });

    // cleanup old history
    if (acked_history != std::cend(history))
    {
        history.erase(std::cbegin(history), acked_history);
    }

    // return useful data
    return {last_acked, position, linear_velocity, angular_velocity};
}

/**
 * Update the client prediction based on server updates. This will compare the
 * actual server position at a given tick to our historical prediction at that
 * time. If they differ by more than some threshold we will:
 *  - reset to that state
 *  - apply the correct server details
 *  - replay all user inputs since that tick
 *
 * @param last_acked
 *   The last tick the server acknowledged.
 *
 * @param history
 *   Collection of local state history.
 *
 * @param server_position
 *   The true position of the client at last_acked.
 *
 * @param linear_velocity
 *   The true linear_velocity of the client at last_acked.
 *
 * @param angular_velocity
 *   The true angular_velocity of the client at last_acked.
 *
 * @param character_controller
 *   Pointer to character controller.
 *
 * @param inputs
 *   Collection of stored user inputs.
 *
 * @param physics_system
 *   Physics system.
 */
void client_prediciton(
    std::uint32_t last_acked,
    std::vector<std::tuple<
        std::uint32_t,
        iris::Vector3,
        std::unique_ptr<iris::PhysicsState, iris::PhysicsStateDeleter>>>
        &history,
    const iris::Vector3 &server_position,
    const iris::Vector3 &linear_velocity,
    const iris::Vector3 &angular_velocity,
    iris::CharacterController *character_controller,
    std::deque<ClientInput> &inputs,
    iris::PhysicsSystem *physics_system)
{
    const auto &[tck_num, pos, state] = history.front();

    // as we periodically purge acked history if we have an entry for the last
    // acked tick it will be the first in our collection
    if (tck_num == last_acked)
    {
        // get the difference between our saved predicted position and the
        // actual server prediction
        static const auto threshold = 0.3f;
        const auto diff = std::abs((pos - server_position).magnitude());

        // if the difference is above our threshold (which account for floating
        // point rounding errors) then we have gone out of sync with the server
        if (diff >= threshold)
        {
            // reset to the stored state
            physics_system->load(state.get());

            // update the player with the server supplied data
            character_controller->reposition(
                server_position, iris::Quaternion{0.0f, 1.0f, 0.0f, 0.0f});
            character_controller->set_linear_velocity(linear_velocity);
            character_controller->set_angular_velocity(angular_velocity);

            // update the history entry
            history[0] = std::make_tuple(
                tck_num,
                character_controller->position(),
                physics_system->save());

            // update every other history entry by replaying user inputs
            for (auto i = 1u; i < history.size(); ++i)
            {
                auto current_tick = tck_num + i;

                // replay user inputs for our current history entry
                for (const auto &input : inputs)
                {
                    if (input.tick == current_tick)
                    {
                        iris::Vector3 walk_direction{
                            input.side, 0.0f, input.forward};
                        walk_direction.normalise();
                        character_controller->set_walk_direction(
                            walk_direction);
                    }
                }

                // step physics
                physics_system->step(std::chrono::milliseconds(33));

                // update history
                history[i] = std::make_tuple(
                    current_tick,
                    character_controller->position(),
                    physics_system->save());
            }
        }
    }

    // we should now be back in sync with the server
}

/**
 * Interpolate updates from the server. As the server send updates at fixed
 * intervals rendering each update would give jerky motion. Instead we delay
 * rendering by a small amount so we have two snapshots of the entity positions,
 * we can then interpolate between them for smoother motion.
 *
 * @param snapshots
 *   Collection snapshots of server updates (of non player entity).
 *
 * @param box
 *   Pointer to RenderEntity for box.
 */
void entity_interpolation(
    std::deque<std::tuple<
        std::chrono::steady_clock::time_point,
        iris::Vector3,
        iris::Quaternion>> &snapshots,
    iris::RenderEntity *box)
{
    const auto now = std::chrono::steady_clock::now();

    // find the first snapshot that is ahead of us in time, this will be the
    // snapshot we interpolate towards
    const auto second_snapshot = std::find_if(
        std::cbegin(snapshots) + 1u,
        std::cend(snapshots),
        [&now](const auto &element) { return std::get<0>(element) >= now; });

    // check we have two snapshots
    if (second_snapshot != std::cend(snapshots))
    {
        const auto first_snapshot = second_snapshot - 1u;

        auto [time_start, pos_start, rot_start] = *first_snapshot;
        const auto &[time_end, pos_end, rot_end] = *second_snapshot;

        // calculate the interpolate amount
        const auto delta1 = now - time_start;
        const auto delta2 = time_end - time_start;
        const auto lerp_amount = static_cast<float>(delta1.count()) /
                                 static_cast<float>(delta2.count());

        pos_start.lerp(pos_end, lerp_amount);
        rot_start.slerp(rot_end, lerp_amount);

        box->set_position(pos_start);
        box->set_orientation(rot_start);

        // purge old snapshots
        snapshots.erase(std::cbegin(snapshots), first_snapshot);
    }
}

void go(int, char **)
{
    LOG_DEBUG("client", "hello world");

    auto socket = std::make_unique<iris::UdpSocket>("127.0.0.1", 8888);

    iris::ClientConnectionHandler client{std::move(socket)};

    iris::Window window{800u, 800u};
    iris::Camera camera{iris::CameraType::PERSPECTIVE, 800u, 800u};

    auto scene = std::make_unique<iris::Scene>();

    scene->create_entity(
        nullptr,
        iris::mesh_factory::cube({1.0f, 1.0f, 1.0f}),
        iris::Transform{
            iris::Vector3{0.0f, -50.0f, 0.0f},
            {},
            iris::Vector3{500.0f, 50.0f, 500.0f}});

    auto *box = scene->create_entity(
        nullptr,
        iris::mesh_factory::cube({1.0f, 0.0f, 0.0f}),
        iris::Transform{
            iris::Vector3{0.0f, 1.0f, 0.0f},
            {},
            iris::Vector3{0.5f, 0.5f, 0.5f}});

    iris::Pipeline pipeline{};
    pipeline.add_stage(std::move(scene), camera);

    std::deque<std::tuple<
        std::chrono::steady_clock::time_point,
        iris::Vector3,
        iris::Quaternion>>
        snapshots;
    std::deque<ClientInput> inputs;

    iris::PhysicsSystem ps{};
    auto *character_controller =
        ps.create_character_controller<iris::BasicCharacterController>(&ps);
    ps.create_rigid_body(
        iris::Vector3{0.0f, -50.0f, 0.0f},
        std::make_unique<iris::BoxCollisionShape>(
            iris::Vector3{500.0f, 50.0f, 500.0f}),
        iris::RigidBodyType::STATIC);

    std::vector<std::tuple<
        std::uint32_t,
        iris::Vector3,
        std::unique_ptr<iris::PhysicsState, iris::PhysicsStateDeleter>>>
        history;
    std::uint32_t tick = 0u;

    ClientInput input;

    // keep looping till handshake and sync is complete which will give us a lag
    // estimate
    while (client.lag().count() == 0)
    {
        client.flush();
    }

    LOG_WARN("client", "lag: {}", client.lag().count());

    // calculate how many ticks we are behind the server based on lag
    const auto ticks_behind = (client.lag().count() / 33u) + 20u;
    LOG_INFO("client", "ticks behind {}", ticks_behind);

    // step ourselves forward in time
    // we want be a head of the server just enough so that it received input for
    // the frame it is about to execute
    for (auto i = 0u; i < ticks_behind; ++i)
    {
        ps.step(std::chrono::milliseconds(33));
    }

    tick = ticks_behind;

    iris::Looper looper(
        33ms * ticks_behind,
        33ms,
        [&](std::chrono::microseconds, std::chrono::microseconds) {
            // fixed timestep function
            // this simulates the same physics code as in the server, with the
            // same inputs

            auto keep_looping = false;

            // process user inputs
            if (!handle_input(inputs, camera, tick, client, window))
            {
                // apply inputs to physics simulation
                for (const auto &input : inputs)
                {
                    // only process inputs for this tick
                    if (input.tick == tick)
                    {
                        iris::Vector3 walk_direction{
                            input.side, 0.0f, input.forward};
                        walk_direction.normalise();

                        character_controller->set_walk_direction(
                            walk_direction);
                    }
                }

                ps.step(33ms);

                // snapshot the state of the simulation at this tick, this is
                // needed so we can rewind the state of we get out of sync with
                // the server
                history.emplace_back(
                    tick, character_controller->position(), ps.save());

                ++tick;
                keep_looping = true;
            }

            return keep_looping;
        },
        [&](std::chrono::microseconds, std::chrono::microseconds) {
            // variable timestep function
            // this handles various lag compensation techniques as well as
            // renders the world

            // process all pending messages from the server
            for (;;)
            {
                const auto server_data =
                    client.try_read(iris::ChannelType::RELIABLE_ORDERED);
                if (!server_data)
                {
                    break;
                }

                // process the message
                const auto
                    [last_acked,
                     server_position,
                     linear_velocity,
                     angular_velocity] =
                        process_server_update(
                            *server_data, snapshots, history, inputs);

                // if we have history then update the client prediction based
                // upon the latest information from the server
                if (!history.empty())
                {
                    client_prediciton(
                        last_acked,
                        history,
                        server_position,
                        linear_velocity,
                        angular_velocity,
                        character_controller,
                        inputs,
                        &ps);
                }
            }

            // put the camera where the player is
            camera.set_position(character_controller->position());

            // if we have snapshots then interpolate the server entity for
            // smooth motion
            if (snapshots.size() >= 2u)
            {
                entity_interpolation(snapshots, box);
            }

            // render the world
            window.render(pipeline);

            return true;
        });

    looper.run();

    LOG_ERROR("client", "goodbye!");
}

int main(int argc, char **argv)
{
    iris::start_debug(argc, argv, go);

    return 0;
}

```

`samples/networking/client_input.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include "core/vector3.h"
#include "networking/data_buffer_deserialiser.h"
#include "networking/data_buffer_serialiser.h"
#include <cstdint>

/**
 * Struct encapsulating user input.
 */
struct ClientInput
{
    /**
     * Create new ClientInput.
     */
    ClientInput()
        : forward(0.0f)
        , side(0.0f)
        , tick(0u)
    {
    }

    /**
     * Create new ClientInput with a deserialiser.
     *
     * @param deserialiser
     *   Deserialiser object.
     */
    ClientInput(iris::DataBufferDeserialiser &deserialiser)
        : forward(deserialiser.pop<float>())
        , side(deserialiser.pop<float>())
        , tick(deserialiser.pop<std::uint32_t>())
    {
    }

    /**
     * Serialise object.
     *
     * @param serialiser.
     *   Serialiser object.
     */
    void serialise(iris::DataBufferSerialiser &serialiser) const
    {
        serialiser.push(forward);
        serialiser.push(side);
        serialiser.push(tick);
    }

    /** Relative amount user is moving forward, should be in range [-1.0, 1.0].
     */
    float forward;

    /** Relative amount user is moving sideways, should be in range [-1.0, 1.0].
     */
    float side;

    /** Client tick input is for. */
    std::uint32_t tick;
};

```

`samples/networking/server.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include <chrono>
#include <cstddef>
#include <cstdint>
#include <cstring>
#include <deque>
#include <iostream>
#include <iterator>
#include <limits>
#include <memory>
#include <string>
#include <thread>

#include "core/data_buffer.h"
#include "core/exception.h"
#include "core/looper.h"
#include "core/vector3.h"
#include "log/log.h"
#include "networking/data_buffer_deserialiser.h"
#include "networking/data_buffer_serialiser.h"
#include "networking/networking.h"
#include "networking/packet.h"
#include "networking/server_connection_handler.h"
#include "networking/udp_server_socket.h"
#include "physics/basic_character_controller.h"
#include "physics/box_collision_shape.h"
#include "physics/physics_system.h"
#include "physics/rigid_body.h"
#include "events/keyboard_event.h"

#include "client_input.h"

using namespace std::chrono_literals;

iris::CharacterController *character_controller = nullptr;
std::size_t player_id = std::numeric_limits<std::size_t>::max();

void go(int, char **)
{
    iris::Logger::instance().set_log_engine(true);

    LOG_DEBUG("server_sample", "hello world");

    std::deque<ClientInput> inputs;
    auto tick = 0u;

    auto socket = std::make_unique<iris::UdpServerSocket>("127.0.0.1", 8888);

    iris::ServerConnectionHandler connection_handler(
        std::move(socket),
        [](std::size_t id) {
            LOG_DEBUG("server", "new connection {}", id);

            // just support a single player
            player_id = id;
        },
        [&inputs, &tick](
            std::size_t id,
            const iris::DataBuffer &data,
            iris::ChannelType type) {
            if (type == iris::ChannelType::RELIABLE_ORDERED)
            {
                iris::DataBufferDeserialiser deserialiser(data);
                ClientInput input{deserialiser};

                if (input.tick >= tick)
                {
                    // if input is for now or the future (which it should be as
                    // the client runs ahead) then store it
                    inputs.emplace_back(input);
                }
                else
                {
                    LOG_WARN("server", "stale input: {} {}", tick, input.tick);
                }
            }
        });

    iris::PhysicsSystem ps{};
    character_controller =
        ps.create_character_controller<iris::BasicCharacterController>(&ps);
    ps.create_rigid_body(
        iris::Vector3{0.0f, -50.0f, 0.0f},
        std::make_unique<iris::BoxCollisionShape>(
            iris::Vector3{500.0f, 50.0f, 500.0f}),
        iris::RigidBodyType::STATIC);
    auto *box = ps.create_rigid_body(
        iris::Vector3{0.0f, 1.0f, 0.0f},
        std::make_unique<iris::BoxCollisionShape>(
            iris::Vector3{0.5f, 0.5f, 0.5f}),
        iris::RigidBodyType::NORMAL);

    // block and wait for client to connect
    while (player_id == std::numeric_limits<std::size_t>::max())
    {
        connection_handler.update();
        std::this_thread::sleep_for(100ms);
    }

    std::chrono::microseconds step(0);

    ps.step(33ms);

    iris::Looper looper{
        0ms,
        33ms,
        [&](std::chrono::microseconds clock,
            std::chrono::microseconds time_step) {
            // fixed timestep function
            // this runs the physics and processes player input

            for (const auto &input : inputs)
            {
                // if stored input is for our current tick then apply it to
                // the physics simulation
                if (input.tick == tick)
                {
                    iris::Vector3 walk_direction{
                        input.side, 0.0f, input.forward};
                    walk_direction.normalise();

                    character_controller->set_walk_direction(walk_direction);
                }
                if (input.tick > tick)
                {
                    break;
                }
            }

            ps.step(33ms);
            ++tick;

            return true;
        },
        [&](std::chrono::microseconds clock,
            std::chrono::microseconds time_step) {
            // variable timestep function
            // sends snapshots of the world to the client

            connection_handler.update();

            // whilst this is a variable time function we only want to send out
            // updates every 100ms
            if (clock > step + 100ms)
            {
                // serialise world state
                iris::DataBufferSerialiser serialiser;
                serialiser.push(character_controller->position());
                serialiser.push(character_controller->linear_velocity());
                serialiser.push(character_controller->angular_velocity());
                serialiser.push(tick);
                serialiser.push(box->position());
                serialiser.push(box->orientation());

                connection_handler.send(
                    player_id,
                    serialiser.data(),
                    iris::ChannelType::RELIABLE_ORDERED);

                step = clock;
            }

            return true;
        }};

    looper.run();
}

int main(int argc, char **argv)
{
    go(argc, argv);

    return 0;
}

```

`samples/sample_browser/CMakeLists.txt`:

```txt
add_executable(sample_browser
  main.cpp
  samples/animation_sample.cpp
  samples/animation_sample.h
  samples/physics_sample.cpp
  samples/physics_sample.h
  samples/render_graph_sample.cpp
  samples/render_graph_sample.h
  samples/sample.h
  samples/water_sample.cpp
  samples/water_sample.h
)

file(COPY assets DESTINATION ${PROJECT_BINARY_DIR}/samples/sample_browser)

target_include_directories(sample_browser
  PRIVATE ${stb_SOURCE_DIR})
target_include_directories(
  sample_browser PUBLIC "${PROJECT_SOURCE_DIR}/samples/sample_browser")
target_link_libraries(sample_browser iris)

if(IRIS_PLATFORM MATCHES "WIN32")
  set_target_properties(sample_browser PROPERTIES MSVC_RUNTIME_LIBRARY "MultiThreadedDebug")
endif()

```

`samples/sample_browser/main.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include <chrono>
#include <cstdint>
#include <memory>
#include <string>
#include <tuple>

#include <core/context.h>
#include <core/exception.h>
#include <core/looper.h>
#include <core/start.h>
#include <graphics/mesh_manager.h>
#include <graphics/post_processing_description.h>
#include <graphics/render_graph/render_graph.h>
#include <graphics/render_graph/texture_node.h>
#include <graphics/render_pipeline.h>
#include <graphics/render_target.h>
#include <graphics/render_target_manager.h>
#include <graphics/scene.h>
#include <graphics/single_entity.h>
#include <graphics/text_factory.h>
#include <graphics/texture_manager.h>
#include <graphics/window.h>
#include <graphics/window_manager.h>

#define STB_IMAGE_WRITE_IMPLEMENTATION
#include <stb_image_write.h>

#include "samples/animation_sample.h"
#include "samples/physics_sample.h"
#include "samples/render_graph_sample.h"
#include "samples/sample.h"
#include "samples/water_sample.h"

static constexpr std::size_t sample_count = 4u;

using namespace std::chrono_literals;

struct RenderState
{
    std::unique_ptr<iris::RenderPipeline> render_pipeline;
    std::unique_ptr<Sample> sample;
};

std::unique_ptr<Sample> create_sample(
    iris::Context &context,
    iris::Window *window,
    iris::RenderPipeline &render_pipeline,
    std::size_t index)
{
    switch (index)
    {
        case 0: return std::make_unique<AnimationSample>(window, render_pipeline, context); break;
        case 1: return std::make_unique<RenderGraphSample>(window, render_pipeline, context); break;
        case 2: return std::make_unique<PhysicsSample>(window, render_pipeline, context); break;
        case 3: return std::make_unique<WaterSample>(window, render_pipeline, context); break;
        default: throw iris::Exception("unknown sample index");
    }
}

RenderState create_render_state(iris::Context &context, iris::Window *window, iris::Camera *camera, std::size_t index)
{
    auto render_pipeline = std::make_unique<iris::RenderPipeline>(
        context.material_manager(),
        context.mesh_manager(),
        context.render_target_manager(),
        window->width(),
        window->height());
    auto sample = create_sample(context, window, *render_pipeline, index % sample_count);

    const auto *sample_target = sample->target();

    auto *scene = render_pipeline->create_scene();
    auto *rg = render_pipeline->create_render_graph();
    rg->render_node()->set_colour_input(rg->create<iris::TextureNode>(sample_target->colour_texture()));
    scene->create_entity<iris::SingleEntity>(
        rg, context.mesh_manager().sprite({1.0f, 1.0f, 1.0f}), iris::Transform{{0.0f}, {}, {1920.0f, 1080.0f, 1.0f}});

    iris::PostProcessingDescription post_processing_description{
        .bloom = {iris::BloomDescription{6.0f}},
        .colour_adjust = {iris::ColourAdjustDescription{}},
        .anti_aliasing = {iris::AntiAliasingDescription{}}};

    auto *pass = render_pipeline->create_render_pass(scene);
    pass->camera = camera;
    pass->post_processing_description = post_processing_description;

    return {std::move(render_pipeline), std::move(sample)};
}

void go(iris::Context context)
{
    context.resource_manager().set_root_directory("assets");
    auto &rtm = context.render_target_manager();

    auto window = context.window_manager().create_window(1920, 1080);
    std::size_t sample_number = 0u;

    iris::Camera camera{iris::CameraType::ORTHOGRAPHIC, window->width(), window->height()};

    auto [render_pipeline, sample] = create_render_state(context, window, &camera, sample_number);

    window->set_render_pipeline(std::move(render_pipeline));

    std::size_t frame_counter = 0u;
    std::size_t next_update = 1u;

    iris::Looper looper{
        0ms,
        16ms,
        [&sample = sample](auto, auto)
        {
            sample->fixed_update();
            return true;
        },
        [&, &sample = sample](std::chrono::microseconds elapsed, auto)
        {
            auto running = true;
            auto event = window->pump_event();
            while (event)
            {
                if (event->is_quit() || event->is_key(iris::Key::ESCAPE))
                {
                    running = false;
                }
                else if (event->is_key(iris::Key::TAB, iris::KeyState::UP))
                {
                    ++sample_number;

                    auto [new_render_pipeline, new_sample] =
                        create_render_state(context, window, &camera, sample_number);
                    sample = std::move(new_sample);
                    window->set_render_pipeline(std::move(new_render_pipeline));
                }
                else
                {
                    sample->handle_input(*event);
                }
                event = window->pump_event();
            }

            sample->variable_update();
            window->render();

            return running;
        }};

    looper.run();
}

int main(int argc, char **argv)
{
    iris::start(argc, argv, go, true);
}
```

`samples/sample_browser/samples/animation_sample.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "animation_sample.h"

#include <cmath>
#include <map>
#include <memory>
#include <string>
#include <vector>

#include <core/camera.h>
#include <core/context.h>
#include <core/error_handling.h>
#include <core/matrix4.h>
#include <core/quaternion.h>
#include <core/transform.h>
#include <core/vector3.h>
#include <graphics/animation/animation_controller.h>
#include <graphics/cube_map.h>
#include <graphics/lights/point_light.h>
#include <graphics/mesh_manager.h>
#include <graphics/post_processing_description.h>
#include <graphics/render_graph/binary_operator_node.h>
#include <graphics/render_graph/blur_node.h>
#include <graphics/render_graph/colour_node.h>
#include <graphics/render_graph/composite_node.h>
#include <graphics/render_graph/invert_node.h>
#include <graphics/render_graph/render_graph.h>
#include <graphics/render_graph/render_node.h>
#include <graphics/render_graph/texture_node.h>
#include <graphics/render_graph/value_node.h>
#include <graphics/render_graph/vertex_node.h>
#include <graphics/render_pipeline.h>
#include <graphics/render_target.h>
#include <graphics/render_target_manager.h>
#include <graphics/scene.h>
#include <graphics/single_entity.h>
#include <graphics/texture_manager.h>
#include <graphics/window.h>
#include <physics/physics_manager.h>
#include <physics/rigid_body.h>

using namespace std::literals::chrono_literals;

namespace
{

/**
 * Helper function to update camera based on user input.
 *
 * @param camera
 *   Camera to update.
 *
 * @param key_map
 *   Map of user pressed keys.
 */
void update_camera(iris::Camera &camera, const std::map<iris::Key, iris::KeyState> &key_map)
{
    static auto speed = 2.0f;
    iris::Vector3 velocity;

    if (key_map.at(iris::Key::W) == iris::KeyState::DOWN)
    {
        velocity += camera.direction() * speed;
    }

    if (key_map.at(iris::Key::S) == iris::KeyState::DOWN)
    {
        velocity -= camera.direction() * speed;
    }

    if (key_map.at(iris::Key::A) == iris::KeyState::DOWN)
    {
        velocity -= camera.right() * speed;
    }

    if (key_map.at(iris::Key::D) == iris::KeyState::DOWN)
    {
        velocity += camera.right() * speed;
    }

    if (key_map.at(iris::Key::Q) == iris::KeyState::DOWN)
    {
        velocity += camera.right().cross(camera.direction()) * speed;
    }

    if (key_map.at(iris::Key::E) == iris::KeyState::DOWN)
    {
        velocity -= camera.right().cross(camera.direction()) * speed;
    }

    camera.translate(velocity);
}

}

AnimationSample::AnimationSample(iris::Window *window, iris::RenderPipeline &render_pipeline, iris::Context &context)
    : light_transform_()
    , light_(nullptr)
    , camera_(iris::CameraType::PERSPECTIVE, window->width(), window->height())
    , physics_(context.physics_manager().create_physics_system())
    , zombie_(nullptr)
    , animation_(0u)
    , animations_()
    , hit_boxes_()
    , hit_box_data_()
    , key_map_()
    , sky_box_(nullptr)
    , debug_mesh_(nullptr)
    , animation_controller_()
    , render_target_(nullptr)
{
    key_map_ = {
        {iris::Key::W, iris::KeyState::UP},
        {iris::Key::A, iris::KeyState::UP},
        {iris::Key::S, iris::KeyState::UP},
        {iris::Key::D, iris::KeyState::UP},
        {iris::Key::Q, iris::KeyState::UP},
        {iris::Key::E, iris::KeyState::UP},
    };

    camera_.set_position(camera_.position() + iris::Vector3{0.0f, 5.0f, 0.0f});

    scene_ = render_pipeline.create_scene();

    scene_->set_ambient_light({0.5f, 0.5f, 0.5f, 1.0f});

    auto *floor_graph = render_pipeline.create_render_graph();

    floor_graph->render_node()->set_specular_amount_input(floor_graph->create<iris::ValueNode<float>>(0.0f));
    floor_graph->render_node()->set_colour_input(floor_graph->create<iris::ColourNode>(iris::Colour{0.9f, 0.9f, 0.9f}));

    auto &mesh_manager = context.mesh_manager();
    auto &texture_manager = context.texture_manager();
    auto &render_target_manager = context.render_target_manager();

    scene_->create_entity<iris::SingleEntity>(
        floor_graph,
        mesh_manager.cube({1.0f, 1.0f, 1.0f}),
        iris::Transform{iris::Vector3{0.0f, -500.0f, 0.0f}, {}, iris::Vector3{500.0f}});

    auto meshes = mesh_manager.load_mesh("Zombie.fbx");
    iris::ensure(meshes.mesh_data.size() == 1u, "expecting single mesh");

    auto [mesh, texture_name] = meshes.mesh_data.front();
    const auto *texture = texture_manager.load(texture_name);

    auto *render_graph = render_pipeline.create_render_graph();
    render_graph->render_node()->set_colour_input(render_graph->create<iris::TextureNode>(texture));
    zombie_ = scene_->create_entity<iris::SingleEntity>(
        render_graph,
        mesh,
        iris::Transform{iris::Vector3{0.0f, 0.0f, 0.0f}, {}, iris::Vector3{0.05f}},
        meshes.skeleton);

    zombie_->set_receive_shadow(false);

    sky_box_ =
        texture_manager.create(iris::Colour{0.275f, 0.51f, 0.796f}, iris::Colour{0.5f, 0.5f, 0.5f}, 2048u, 2048u);

    light_ = scene_->create_light<iris::DirectionalLight>(iris::Vector3{-1.0f, -1.0f, 0.0f}, true);
    light_transform_ = iris::Transform{light_->direction(), {}, {1.0f}};

    auto *pass = render_pipeline.create_render_pass(scene_);
    pass->post_processing_description = {.ambient_occlusion = {iris::AmbientOcclusionDescription{}}};
    pass->colour_target = render_target_manager.create();
    pass->camera = &camera_;
    pass->sky_box = sky_box_;

    render_target_ = pass->colour_target;

    animations_ = {
        "Zombie|ZombieWalk", "Zombie|ZombieBite", "Zombie|ZombieCrawl", "Zombie|ZombieIdle", "Zombie|ZombieRun"};

    animation_controller_ = std::make_unique<iris::AnimationController>(
        meshes.animations,
        std::vector<iris::AnimationLayer>{
            {{{animations_[0], animations_[1], 500ms},
              {animations_[1], animations_[2], 500ms},
              {animations_[2], animations_[3], 500ms},
              {animations_[3], animations_[4], 500ms},
              {animations_[4], animations_[0], 500ms}},
             animations_.front()}},
        zombie_->skeleton());

    // offsets and scales for bones we want to add rigid bodies to, these were
    // all handcrafted
    hit_box_data_ = {
        {"Head", {{}, {1.0f}}},
        {"HeadTop_End", {{0.0f, -0.2f, 0.0f}, {1.0f}}},

        {"RightArm", {{}, {1.0f}}},
        {"RightForeArm", {{}, {1.0f, 2.5f, 1.0f}}},
        {"RightHand", {{}, {1.0f}}},

        {"LeftArm", {{}, {1.0f}}},
        {"LeftForeArm", {{}, {1.0f, 2.5f, 1.0f}}},
        {"LeftHand", {{}, {1.0f}}},

        {"Spine", {{}, {2.0f, 1.0f, 1.0f}}},
        {"Spine1", {{}, {2.0f, 1.0f, 1.0f}}},
        {"Spine2", {{}, {2.0f, 1.0f, 1.0f}}},
        {"Hips", {{}, {1.0f}}},

        {"LeftUpLeg", {{0.0f, 0.6f, 0.0f}, {1.0f, 2.5f, 1.0f}}},
        {"LeftLeg", {{0.0f, 0.6f, 0.0f}, {1.0f, 3.0f, 1.0f}}},
        {"LeftFoot", {{}, {1.0f, 2.5f, 1.0f}}},

        {"RightUpLeg", {{0.0f, 0.6f, 0.0f}, {1.0f, 2.5f, 1.0f}}},
        {"RightLeg", {{0.0f, 0.6f, 0.0f}, {1.0f, 3.0f, 1.0f}}},
        {"RightFoot", {{}, {1.0f, 2.5f, 1.0f}}}};

    // iterate all bones and create hit boxes for those we have data for
    for (auto i = 0u; i < zombie_->skeleton()->bones().size(); ++i)
    {
        const auto &bone = zombie_->skeleton()->bone(i);

        const auto box_data = hit_box_data_.find(bone.name());
        if (box_data != std::end(hit_box_data_))
        {
            const auto &[pos_offset, scale_offset] = box_data->second;

            // get bone transform in world space
            const auto transform = iris::Transform{
                zombie_->transform() * zombie_->skeleton()->transforms()[i] * iris::Matrix4::invert(bone.offset())};

            // create hit box
            hit_boxes_[box_data->first] = {
                i,
                physics_->create_rigid_body(
                    iris::Vector3{}, physics_->create_box_collision_shape(scale_offset), iris::RigidBodyType::GHOST)};

            // calculate hit box location after offset is applied
            const auto offset = transform * iris::Matrix4::make_translate(pos_offset);

            // update hit box
            std::get<1>(hit_boxes_[box_data->first])->reposition(offset.translation(), transform.rotation());
            std::get<1>(hit_boxes_[box_data->first])->set_name(box_data->first);
        }
    }

    fixed_update();
}

void AnimationSample::fixed_update()
{
    update_camera(camera_, key_map_);

    light_transform_.set_matrix(
        iris::Matrix4(iris::Quaternion{{0.0f, 1.0f, 0.0f}, -0.01f}) * light_transform_.matrix());
    light_->set_direction(light_transform_.translation());

    physics_->step(13ms);
}

void AnimationSample::variable_update()
{
    animation_controller_->update();

    // update hit boxes
    for (auto &[name, data] : hit_boxes_)
    {
        auto &[index, body] = data;

        // get hotbox transform in world space
        const auto transform = iris::Transform{
            zombie_->transform() * zombie_->skeleton()->transforms()[index] *
            iris::Matrix4::invert(zombie_->skeleton()->bone(index).offset())};
        const auto offset = transform * iris::Matrix4::make_translate(std::get<0>(hit_box_data_[name]));

        body->reposition(offset.translation(), transform.rotation());
    }
}

void AnimationSample::handle_input(const iris::Event &event)
{
    if (event.is_key())
    {
        const auto keyboard = event.key();
        key_map_[keyboard.key] = keyboard.state;

        if ((keyboard.key == iris::Key::SPACE) && (keyboard.state == iris::KeyState::UP))
        {
            animation_ = (animation_ + 1u) % animations_.size();
            animation_controller_->play(0u, animations_[animation_]);
        }
    }
    else if (event.is_mouse())
    {
        static const auto sensitivity = 0.0025f;
        const auto mouse = event.mouse();

        camera_.adjust_yaw(mouse.delta_x * sensitivity);
        camera_.adjust_pitch(-mouse.delta_y * sensitivity);
    }
}

std::string AnimationSample::title() const
{
    return "Animation";
}

const iris::RenderTarget *AnimationSample::target() const
{
    return render_target_;
}

```

`samples/sample_browser/samples/animation_sample.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <map>
#include <string>

#include <core/camera.h>
#include <core/context.h>
#include <core/transform.h>
#include <events/event.h>
#include <graphics/animation/animation_controller.h>
#include <graphics/cube_map.h>
#include <graphics/lights/directional_light.h>
#include <graphics/render_entity.h>
#include <graphics/render_graph/render_graph.h>
#include <graphics/render_pipeline.h>
#include <graphics/single_entity.h>
#include <graphics/skeleton.h>
#include <graphics/window.h>
#include <physics/physics_system.h>
#include <physics/rigid_body.h>

#include "sample.h"

/**
 * Sample showcasing animation.
 */
class AnimationSample : public Sample
{
  public:
    /**
     * Create a new AnimationSample.
     *
     * @param window
     *   Window to render with.
     *
     * @param render_pipeline
     *   Render pipeline to use for sample.
     *
     * @param context
     *   Engine context object.
     */
    AnimationSample(iris::Window *window, iris::RenderPipeline &render_pipeline, iris::Context &context);
    ~AnimationSample() override = default;

    /**
     * Fixed rate update function.
     */
    void fixed_update() override;

    /**
     * Variable rate update function.
     */
    void variable_update() override;

    /**
     * Handle a user input.
     *
     * @param event
     *   User input event.
     */
    void handle_input(const iris::Event &event) override;

    /**
     * Title of sample.
     *
     * @returns
     *   Sample title.
     */
    std::string title() const override;

    /**
     * Get the target the sample will render to.
     *
     * @returns
     *   Sample render target.
     */
    const iris::RenderTarget *target() const override;

  private:
    /** Transform for moving light. */
    iris::Transform light_transform_;

    /** Scene light */
    iris::DirectionalLight *light_;

    /** Render camera. */
    iris::Camera camera_;

    /** Physics system */
    iris::PhysicsSystem *physics_;

    /** Zombie entity. */
    iris::SingleEntity *zombie_;

    /** Current animation number. */
    std::size_t animation_;

    /** Collection of animation names. */
    std::vector<std::string> animations_;

    /** Mapping of bone name to index and rigid body. */
    std::map<std::string, std::tuple<std::size_t, iris::RigidBody *>> hit_boxes_;

    /** Mapping of bone name to offsets. */
    std::map<std::string, std::tuple<iris::Vector3, iris::Vector3>> hit_box_data_;

    /** User input key map. */
    std::map<iris::Key, iris::KeyState> key_map_;

    /** Sky box for sample. */
    iris::CubeMap *sky_box_;

    /** Mesh for debug rendering. */
    std::unique_ptr<iris::Mesh> debug_mesh_;

    /** Animation controller for zombie. */
    std::unique_ptr<iris::AnimationController> animation_controller_;

    /** Scene for sample. */
    iris::Scene *scene_;

    /** Render target for sample. */
    const iris::RenderTarget *render_target_;
};

```

`samples/sample_browser/samples/physics_sample.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "physics_sample.h"

#include <chrono>
#include <cmath>
#include <memory>
#include <sstream>

#include <core/camera.h>
#include <core/context.h>
#include <core/matrix4.h>
#include <core/quaternion.h>
#include <core/transform.h>
#include <core/vector3.h>
#include <graphics/cube_map.h>
#include <graphics/lights/point_light.h>
#include <graphics/mesh_manager.h>
#include <graphics/render_graph/component_node.h>
#include <graphics/render_graph/render_graph.h>
#include <graphics/render_graph/render_node.h>
#include <graphics/render_graph/texture_node.h>
#include <graphics/render_graph/value_node.h>
#include <graphics/render_pipeline.h>
#include <graphics/render_target.h>
#include <graphics/render_target_manager.h>
#include <graphics/sampler.h>
#include <graphics/scene.h>
#include <graphics/single_entity.h>
#include <graphics/texture_manager.h>
#include <graphics/window.h>
#include <log/log.h>
#include <physics/basic_character_controller.h>
#include <physics/physics_manager.h>

using namespace std::chrono_literals;

namespace
{

/**
 * Helper function to update camera based on user input.
 *
 * @param camera
 *   Camera to update.
 *
 * @param character_controller
 *   Player character controller.
 *
 * @param key_map
 *   Map of user pressed keys.
 */
void update_camera(
    iris::Camera &camera,
    iris::CharacterController *character_controller,
    const std::map<iris::Key, iris::KeyState> &key_map)
{
    iris::Vector3 walk_direction{};

    if (key_map.at(iris::Key::W) == iris::KeyState::DOWN)
    {
        walk_direction += camera.direction();
    }

    if (key_map.at(iris::Key::S) == iris::KeyState::DOWN)
    {
        walk_direction -= camera.direction();
    }

    if (key_map.at(iris::Key::A) == iris::KeyState::DOWN)
    {
        walk_direction -= camera.right();
    }

    if (key_map.at(iris::Key::D) == iris::KeyState::DOWN)
    {
        walk_direction += camera.right();
    }

    walk_direction.normalise();
    character_controller->set_movement_direction(walk_direction);

    const auto cam_pos = character_controller->position();

    camera.translate(cam_pos - camera.position() + iris::Vector3{0.0f, 0.5f, 0.0f});
}

}

PhysicsSample::PhysicsSample(iris::Window *window, iris::RenderPipeline &render_pipeline, iris::Context &context)
    : render_target_(nullptr)
    , physics_(context.physics_manager().create_physics_system())
    , light_transform_()
    , light_(nullptr)
    , camera_(iris::CameraType::PERSPECTIVE, window->width(), window->height())
    , key_map_()
    , boxes_()
    , character_controller_(nullptr)
{
    key_map_ = {
        {iris::Key::W, iris::KeyState::UP},
        {iris::Key::A, iris::KeyState::UP},
        {iris::Key::S, iris::KeyState::UP},
        {iris::Key::D, iris::KeyState::UP},
        {iris::Key::Q, iris::KeyState::UP},
        {iris::Key::E, iris::KeyState::UP},
        {iris::Key::SPACE, iris::KeyState::UP},
    };

    camera_.set_position(camera_.position() + iris::Vector3{0.0f, 5.0f, 0.0f});

    auto *scene = render_pipeline.create_scene();

    scene->set_ambient_light({0.4f, 0.4f, 0.4f});
    scene->create_light<iris::DirectionalLight>(iris::Vector3{0.0f, -1.0f, -1.0f}, true);
    light_ = scene->create_light<iris::PointLight>(iris::Vector3{0.0f, 1.0f, -10.0f});

    auto *floor_graph = render_pipeline.create_render_graph();
    floor_graph->render_node()->set_specular_amount_input(floor_graph->create<iris::ValueNode<float>>(0.0f));

    auto &mesh_manager = context.mesh_manager();
    auto &texture_manager = context.texture_manager();
    auto &render_target_manager = context.render_target_manager();

    scene->create_entity<iris::SingleEntity>(
        floor_graph,
        mesh_manager.cube({1.0f, 1.0f, 1.0f}),
        iris::Transform{iris::Vector3{0.0f, -50.0f, 0.0f}, {}, iris::Vector3{500.0f, 50.0f, 500.0f}});

    auto width = 10u;
    auto height = 5u;

    const auto *texture = texture_manager.load("crate.png");

    for (auto y = 0u; y < height; ++y)
    {
        for (auto x = 0u; x < width; ++x)
        {
            auto *box_graph = render_pipeline.create_render_graph();
            box_graph->render_node()->set_colour_input(box_graph->create<iris::TextureNode>(texture));

            const iris::Vector3 pos{static_cast<float>(x), static_cast<float>(y + 0.5f), 0.0f};
            static const iris::Vector3 half_size{0.5f, 0.5f, 0.5f};
            auto colour =
                ((y * height) + x + (y % 2)) % 2 == 0 ? iris::Colour{1.0f, 0.0f, 0.0f} : iris::Colour{0.0f, 0.0f, 1.0f};

            boxes_.emplace_back(
                scene->create_entity<iris::SingleEntity>(
                    box_graph, mesh_manager.cube({1.0f, 1.0f, 1.0f}), iris::Transform{pos, {}, half_size}),
                physics_->create_rigid_body(
                    pos, physics_->create_box_collision_shape(half_size), iris::RigidBodyType::NORMAL));

            std::stringstream strm{};
            strm << "box_" << x << "_" << y;
            std::get<0>(boxes_.back())->set_name(strm.str());
        }
    }

    light_transform_ = iris::Transform{light_->position(), {}, {1.0f}};

    character_controller_ =
        physics_->create_character_controller<iris::BasicCharacterController>(physics_, 12.0f, 0.5f, 1.7f, 0.1f);

    physics_->create_rigid_body(
        iris::Vector3{0.0f, -50.0f, 0.0f},
        physics_->create_box_collision_shape({500.0f, 50.0f, 500.0f}),
        iris::RigidBodyType::STATIC);

    const auto *sky_box =
        texture_manager.create(iris::Colour{0.275f, 0.51f, 0.796f}, iris::Colour{0.5f, 0.5f, 0.5f}, 2048u, 2048u);

    auto *pass = render_pipeline.create_render_pass(scene);
    pass->colour_target = render_target_manager.create();
    pass->camera = &camera_;
    pass->sky_box = sky_box;

    render_target_ = pass->colour_target;

    physics_->enable_debug_draw(scene);
}

void PhysicsSample::fixed_update()
{
    update_camera(camera_, character_controller_, key_map_);

    light_transform_.set_matrix(
        iris::Matrix4(iris::Quaternion{{0.0f, 1.0f, 0.0f}, -0.01f}) * light_transform_.matrix());
    light_->set_position(light_transform_.translation());

    physics_->step(16ms);
}

void PhysicsSample::variable_update()
{
    // update each entity to have the same position and orientation as the
    // physics simulation
    for (const auto &[g, p] : boxes_)
    {
        g->set_position(p->position());
        g->set_orientation(p->orientation());
    }
}

void PhysicsSample::handle_input(const iris::Event &event)
{
    if (event.is_key())
    {
        const auto keyboard = event.key();
        key_map_[keyboard.key] = keyboard.state;
    }
    else if (event.is_mouse())
    {
        static const auto sensitivity = 0.0025f;
        const auto mouse = event.mouse();

        camera_.adjust_yaw(mouse.delta_x * sensitivity);
        camera_.adjust_pitch(-mouse.delta_y * sensitivity);
    }
}

std::string PhysicsSample::title() const
{
    return "Physics";
}

const iris::RenderTarget *PhysicsSample::target() const
{
    return render_target_;
}

```

`samples/sample_browser/samples/physics_sample.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <map>
#include <string>

#include <core/camera.h>
#include <core/context.h>
#include <core/transform.h>
#include <events/event.h>
#include <graphics/cube_map.h>
#include <graphics/lights/point_light.h>
#include <graphics/render_entity.h>
#include <graphics/render_graph/render_graph.h>
#include <graphics/render_pipeline.h>
#include <graphics/single_entity.h>
#include <graphics/window.h>
#include <physics/character_controller.h>
#include <physics/physics_system.h>
#include <physics/rigid_body.h>

#include "sample.h"

/**
 * Sample showcasing the physics engine.
 */
class PhysicsSample : public Sample
{
  public:
    /**
     * Create a new PhysicsSample.
     *
     * @param window
     *   Window to render with.
     *
     * @param render_pipeline
     *   Render pipeline to use for sample.
     *
     * @param context
     *   Engine context object.
     */
    PhysicsSample(iris::Window *window, iris::RenderPipeline &render_pipeline, iris::Context &context);

    /**
     * Fixed rate update function.
     */
    void fixed_update() override;

    /**
     * Variable rate update function.
     */
    void variable_update() override;

    /**
     * Handle a user input.
     *
     * @param event
     *   User input event.
     */
    void handle_input(const iris::Event &event) override;

    /**
     * Title of sample.
     *
     * @returns
     *   Sample title.
     */
    std::string title() const override;

    /**
     * Get the target the sample will render to.
     *
     * @returns
     *   Sample render target.
     */
    const iris::RenderTarget *target() const override;

  private:
    /** Render target for sample. */
    const iris::RenderTarget *render_target_;

    /** Physics system */
    iris::PhysicsSystem *physics_;

    /** Transform for moving light. */
    iris::Transform light_transform_;

    /** Scene light */
    iris::PointLight *light_;

    /** Render camera. */
    iris::Camera camera_;

    /** User input key map. */
    std::map<iris::Key, iris::KeyState> key_map_;

    /** Collection of render entity and rigid body pairs. */
    std::vector<std::tuple<iris::SingleEntity *, iris::RigidBody *>> boxes_;

    /** Character controller. */
    iris::CharacterController *character_controller_;
};

```

`samples/sample_browser/samples/render_graph_sample.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "render_graph_sample.h"

#include <cmath>
#include <memory>

#include <core/camera.h>
#include <core/context.h>
#include <core/error_handling.h>
#include <core/matrix4.h>
#include <core/quaternion.h>
#include <core/transform.h>
#include <core/vector3.h>
#include <graphics/lights/point_light.h>
#include <graphics/mesh_manager.h>
#include <graphics/render_graph/blur_node.h>
#include <graphics/render_graph/combine_node.h>
#include <graphics/render_graph/composite_node.h>
#include <graphics/render_graph/fragment_node.h>
#include <graphics/render_graph/invert_node.h>
#include <graphics/render_graph/render_graph.h>
#include <graphics/render_graph/render_node.h>
#include <graphics/render_graph/texture_node.h>
#include <graphics/render_graph/value_node.h>
#include <graphics/render_graph/vertex_node.h>
#include <graphics/render_pipeline.h>
#include <graphics/render_target.h>
#include <graphics/render_target_manager.h>
#include <graphics/scene.h>
#include <graphics/single_entity.h>
#include <graphics/texture_manager.h>
#include <graphics/window.h>

namespace
{

/**
 * Helper function to update camera based on user input.
 *
 * @param camera
 *   Camera to update.
 *
 * @param key_map
 *   Map of user pressed keys.
 */
void update_camera(iris::Camera &camera, const std::map<iris::Key, iris::KeyState> &key_map)
{
    static auto speed = 2.0f;
    iris::Vector3 velocity;

    if (key_map.at(iris::Key::W) == iris::KeyState::DOWN)
    {
        velocity += camera.direction() * speed;
    }

    if (key_map.at(iris::Key::S) == iris::KeyState::DOWN)
    {
        velocity -= camera.direction() * speed;
    }

    if (key_map.at(iris::Key::A) == iris::KeyState::DOWN)
    {
        velocity -= camera.right() * speed;
    }

    if (key_map.at(iris::Key::D) == iris::KeyState::DOWN)
    {
        velocity += camera.right() * speed;
    }

    if (key_map.at(iris::Key::Q) == iris::KeyState::DOWN)
    {
        velocity += camera.right().cross(camera.direction()) * speed;
    }

    if (key_map.at(iris::Key::E) == iris::KeyState::DOWN)
    {
        velocity -= camera.right().cross(camera.direction()) * speed;
    }

    camera.translate(velocity);
}

}

RenderGraphSample::RenderGraphSample(
    iris::Window *window,
    iris::RenderPipeline &render_pipeline,
    iris::Context &context)
    : light_transform_()
    , light1_(nullptr)
    , light2_(nullptr)
    , camera_(iris::CameraType::PERSPECTIVE, window->width(), window->height())
    , screen_camera_(iris::CameraType::ORTHOGRAPHIC, window->width(), window->height())
    , key_map_()
    , sky_box_(nullptr)
{
    key_map_ = {
        {iris::Key::W, iris::KeyState::UP},
        {iris::Key::A, iris::KeyState::UP},
        {iris::Key::S, iris::KeyState::UP},
        {iris::Key::D, iris::KeyState::UP},
        {iris::Key::Q, iris::KeyState::UP},
        {iris::Key::E, iris::KeyState::UP},
    };

    auto &mesh_manager = context.mesh_manager();
    auto &texture_manager = context.texture_manager();
    auto &render_target_manager = context.render_target_manager();

    auto meshes = mesh_manager.load_mesh("sphere.fbx");
    iris::ensure(meshes.mesh_data.size() == 1u, "expecting single mesh");

    const auto *texture = texture_manager.load("brickwall.jpg");
    const auto *normal = texture_manager.load("brickwall_normal.jpg", iris::TextureUsage::DATA);

    auto *scene1 = render_pipeline.create_scene();
    auto *graph1 = render_pipeline.create_render_graph();
    graph1->render_node()->set_colour_input(
        graph1->create<iris::InvertNode>(graph1->create<iris::TextureNode>(texture)));
    graph1->render_node()->set_fragment_normal_input(graph1->create<iris::TextureNode>(normal));

    scene1->set_ambient_light({0.15f, 0.15f, 0.15f});
    light1_ = scene1->create_light<iris::PointLight>(
        iris::Vector3{0.0f, 50.0f, -50.0f}, iris::Colour{200.0f, 200.0f, 200.0f});

    auto *mesh = meshes.mesh_data.front().mesh;

    auto *sphere1_rt = render_target_manager.create();
    auto *sphere1 = scene1->create_entity<iris::SingleEntity>(
        graph1,
        mesh,
        iris::Transform{
            iris::Vector3{-20.0f, 0.0f, 0.0f},
            iris::Quaternion({1.0f, 0.0f, 0.0f}, 1.57079632679489661923f),
            iris::Vector3{10.0f}});

    auto *scene2 = render_pipeline.create_scene();
    auto *graph2 = render_pipeline.create_render_graph();
    graph2->render_node()->set_colour_input(graph2->create<iris::TextureNode>(texture));
    scene2->set_ambient_light({0.15f, 0.15f, 0.15f});
    light2_ = scene2->create_light<iris::PointLight>(
        iris::Vector3{0.0f, 50.0f, -50.0f}, iris::Colour{100.0f, 100.0f, 100.0f});

    auto *sphere2_rt = render_target_manager.create();
    auto *sphere2 = scene2->create_entity<iris::SingleEntity>(
        graph2,
        mesh,
        iris::Transform{
            iris::Vector3{20.0f, 0.0f, 0.0f},
            iris::Quaternion({1.0f, 0.0f, 0.0f}, 1.57079632679489661923f),
            iris::Vector3{10.0f}});

    auto *scene3 = render_pipeline.create_scene();
    auto *graph3 = render_pipeline.create_render_graph();
    graph3->render_node()->set_colour_input(graph3->create<iris::CompositeNode>(
        graph3->create<iris::BlurNode>(graph3->create<iris::TextureNode>(sphere2_rt->colour_texture())),
        graph3->create<iris::TextureNode>(sphere1_rt->colour_texture()),
        graph3->create<iris::TextureNode>(sphere2_rt->depth_texture()),
        graph3->create<iris::TextureNode>(sphere1_rt->depth_texture())));

    scene3->create_entity<iris::SingleEntity>(
        graph3,
        mesh_manager.sprite({}),
        iris::Transform{
            iris::Vector3{},
            {},
            iris::Vector3{static_cast<float>(window->width()), static_cast<float>(window->height()), 1.0f}});

    auto *graph4 = render_pipeline.create_render_graph();
    graph4->render_node()->set_colour_input(graph4->create<iris::CombineNode>(
        graph4->create<iris::FragmentNode>(iris::FragmentDataType::NORMAL, ".r"),
        graph4->create<iris::FragmentNode>(iris::FragmentDataType::NORMAL, ".g"),
        graph4->create<iris::FragmentNode>(iris::FragmentDataType::NORMAL, ".b"),
        graph4->create<iris::ValueNode<float>>(1.0f)));

    auto *sphere3 = scene1->create_entity<iris::SingleEntity>(
        graph4, mesh, iris::Transform{iris::Vector3{60.0f, 0.0f, 0.0f}, iris::Quaternion{}, iris::Vector3{10.0f}});

    auto *graph5 = render_pipeline.create_render_graph();
    graph5->render_node()->set_colour_input(
        graph5->create<iris::ValueNode<iris::Colour>>(iris::Colour{100.0f, 0.0f, 0.0f, 1.0f}));

    auto *sphere4 = scene1->create_entity<iris::SingleEntity>(
        graph5,
        mesh,
        iris::Transform{
            iris::Vector3{-60.0f, 0.0f, 0.0f},
            iris::Quaternion({1.0f, 0.0f, 0.0f}, 1.57079632679489661923f),
            iris::Vector3{10.0f}});

    light_transform_ = iris::Transform{light1_->position(), {}, {1.0f}};

    sky_box_ = texture_manager.load(
        "space/right.png", "space/left.png", "space/top.png", "space/bottom.png", "space/back.png", "space/front.png");

    auto *pass1 = render_pipeline.create_render_pass(scene1);
    pass1->colour_target = sphere1_rt;
    pass1->camera = &camera_;
    pass1->sky_box = sky_box_;

    auto *pass2 = render_pipeline.create_render_pass(scene2);
    pass2->colour_target = sphere2_rt;
    pass2->camera = &camera_;
    pass2->sky_box = sky_box_;

    auto *pass3 = render_pipeline.create_render_pass(scene3);
    pass3->colour_target = render_target_manager.create();
    pass3->camera = &screen_camera_;
    pass3->sky_box = sky_box_;

    render_target_ = pass3->colour_target;
}

void RenderGraphSample::fixed_update()
{
    update_camera(camera_, key_map_);

    light_transform_.set_matrix(
        iris::Matrix4(iris::Quaternion{{0.0f, 1.0f, 0.0f}, -0.01f}) * light_transform_.matrix());
    light1_->set_position(light_transform_.translation());
    light2_->set_position(light_transform_.translation());
}

void RenderGraphSample::variable_update()
{
}

void RenderGraphSample::handle_input(const iris::Event &event)
{
    if (event.is_key())
    {
        const auto keyboard = event.key();
        key_map_[keyboard.key] = keyboard.state;
    }
    else if (event.is_mouse())
    {
        static const auto sensitivity = 0.0025f;
        const auto mouse = event.mouse();

        camera_.adjust_yaw(mouse.delta_x * sensitivity);
        camera_.adjust_pitch(-mouse.delta_y * sensitivity);
    }
}

std::string RenderGraphSample::title() const
{
    return "Render graph";
}

const iris::RenderTarget *RenderGraphSample::target() const
{
    return render_target_;
}

```

`samples/sample_browser/samples/render_graph_sample.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <deque>
#include <map>
#include <string>

#include <core/camera.h>
#include <core/context.h>
#include <core/transform.h>
#include <events/event.h>
#include <graphics/cube_map.h>
#include <graphics/lights/point_light.h>
#include <graphics/render_graph/render_graph.h>
#include <graphics/render_pipeline.h>
#include <graphics/render_target.h>
#include <graphics/window.h>

#include "sample.h"

/**
 * Sample showcasing the render graph.
 */
class RenderGraphSample : public Sample
{
  public:
    /**
     * Create a new RenderGraphSample.
     *
     * @param window
     *   Window to render with.
     *
     * @param render_pipeline
     *   Render pipeline to use for sample.
     *
     * @param context
     *   Engine context object.
     */
    RenderGraphSample(iris::Window *window, iris::RenderPipeline &render_pipeline, iris::Context &context);
    ~RenderGraphSample() override = default;

    /**
     * Fixed rate update function.
     */
    void fixed_update() override;

    /**
     * Variable rate update function.
     */
    void variable_update() override;

    /**
     * Handle a user input.
     *
     * @param event
     *   User input event.
     */
    void handle_input(const iris::Event &event) override;

    /**
     * Title of sample.
     *
     * @returns
     *   Sample title.
     */
    std::string title() const override;

    /**
     * Get the target the sample will render to.
     *
     * @returns
     *   Sample render target.
     */
    const iris::RenderTarget *target() const override;

  private:
    /** Transform for moving light. */
    iris::Transform light_transform_;

    /** Scene light */
    iris::PointLight *light1_;

    /** Scene light */
    iris::PointLight *light2_;

    /** Render camera. */
    iris::Camera camera_;

    /** Composite camera. */
    iris::Camera screen_camera_;

    /** User input key map. */
    std::map<iris::Key, iris::KeyState> key_map_;

    /** Sky box for scene. */
    iris::CubeMap *sky_box_;

    /** Render target for scene. */
    const iris::RenderTarget *render_target_;
};

```

`samples/sample_browser/samples/sample.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <string>

#include <events/event.h>
#include <graphics/render_target.h>
#include <graphics/renderer.h>

/**
 * Interface for a sample in the sample browser.
 */
class Sample
{
  public:
    virtual ~Sample() = default;

    /**
     * Fixed rate update function e.g. physics.
     */
    virtual void fixed_update() = 0;

    /**
     * Variable rate update function e.g. rendering.
     */
    virtual void variable_update() = 0;

    /**
     * Handle a user input.
     *
     * @param event
     *   User input event.
     */
    virtual void handle_input(const iris::Event &event) = 0;

    /**
     * Title of sample.
     *
     * @returns
     *   Sample title.
     */
    virtual std::string title() const = 0;

    /**
     * Get the target the sample will render to.
     *
     * @returns
     *   Sample render target.
     */
    virtual const iris::RenderTarget *target() const = 0;
};

```

`samples/sample_browser/samples/water_sample.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "water_sample.h"

#include <cmath>
#include <map>
#include <memory>
#include <numbers>
#include <string>
#include <vector>

#include <core/camera.h>
#include <core/context.h>
#include <core/error_handling.h>
#include <core/matrix4.h>
#include <core/quaternion.h>
#include <core/transform.h>
#include <core/vector3.h>
#include <graphics/cube_map.h>
#include <graphics/lights/point_light.h>
#include <graphics/mesh_manager.h>
#include <graphics/post_processing_description.h>
#include <graphics/render_graph/binary_operator_node.h>
#include <graphics/render_graph/blur_node.h>
#include <graphics/render_graph/camera_node.h>
#include <graphics/render_graph/colour_node.h>
#include <graphics/render_graph/combine_node.h>
#include <graphics/render_graph/component_node.h>
#include <graphics/render_graph/composite_node.h>
#include <graphics/render_graph/conditional_node.h>
#include <graphics/render_graph/fragment_node.h>
#include <graphics/render_graph/invert_node.h>
#include <graphics/render_graph/lerp_node.h>
#include <graphics/render_graph/property_node.h>
#include <graphics/render_graph/render_graph.h>
#include <graphics/render_graph/render_node.h>
#include <graphics/render_graph/texture_node.h>
#include <graphics/render_graph/time_node.h>
#include <graphics/render_graph/unary_operator_node.h>
#include <graphics/render_graph/value_node.h>
#include <graphics/render_graph/variable_node.h>
#include <graphics/render_graph/vertex_node.h>
#include <graphics/render_pipeline.h>
#include <graphics/render_target.h>
#include <graphics/render_target_manager.h>
#include <graphics/scene.h>
#include <graphics/single_entity.h>
#include <graphics/texture_manager.h>
#include <graphics/window.h>
#include <physics/physics_manager.h>
#include <physics/rigid_body.h>

using namespace std::literals::chrono_literals;

namespace
{

/**
 * Helper function to update camera based on user input.
 *
 * @param camera
 *   Camera to update.
 *
 * @param key_map
 *   Map of user pressed keys.
 */
iris::Vector3 calculate_velocity(iris::Camera &camera, const std::map<iris::Key, iris::KeyState> &key_map)
{
    static auto speed = 2.0f;
    iris::Vector3 velocity;

    if (key_map.at(iris::Key::W) == iris::KeyState::DOWN)
    {
        velocity += camera.direction() * speed;
    }

    if (key_map.at(iris::Key::S) == iris::KeyState::DOWN)
    {
        velocity -= camera.direction() * speed;
    }

    if (key_map.at(iris::Key::A) == iris::KeyState::DOWN)
    {
        velocity -= camera.right() * speed;
    }

    if (key_map.at(iris::Key::D) == iris::KeyState::DOWN)
    {
        velocity += camera.right() * speed;
    }

    if (key_map.at(iris::Key::Q) == iris::KeyState::DOWN)
    {
        velocity += camera.right().cross(camera.direction()) * speed;
    }

    if (key_map.at(iris::Key::E) == iris::KeyState::DOWN)
    {
        velocity -= camera.right().cross(camera.direction()) * speed;
    }

    velocity.y = 0.0f;
    return velocity;
}

void add_wave(float dx, float dy, float wavelength, float steepness, iris::RenderGraph *water_graph)
{
    const auto n_dx = dx / std::hypot(dx, dy);
    const auto n_dy = dy / std::hypot(dx, dy);

    static auto counter = 1u;

    water_graph->create_variable<iris::ValueNode<float>>(
        "wavelength" + std::to_string(counter), iris::VariableNodeType::FLOAT, true, wavelength);
    water_graph->create_variable<iris::ValueNode<float>>(
        "steepness" + std::to_string(counter), iris::VariableNodeType::FLOAT, true, steepness);

    water_graph->create_variable<iris::BinaryOperatorNode>(
        "k" + std::to_string(counter),
        iris::VariableNodeType::FLOAT,
        true,
        water_graph->create<iris::ValueNode<float>>(6.2831853f),
        water_graph->create<iris::VariableNode>("wavelength" + std::to_string(counter)),
        iris::BinaryOperator::DIVIDE);

    water_graph->create_variable<iris::BinaryOperatorNode>(
        "a" + std::to_string(counter),
        iris::VariableNodeType::FLOAT,
        true,
        water_graph->create<iris::VariableNode>("steepness" + std::to_string(counter)),
        water_graph->create<iris::VariableNode>("k" + std::to_string(counter)),
        iris::BinaryOperator::DIVIDE);

    water_graph->create_variable<iris::UnaryOperatorNode>(
        "c" + std::to_string(counter),
        iris::VariableNodeType::FLOAT,
        true,
        water_graph->create<iris::BinaryOperatorNode>(
            water_graph->create<iris::ValueNode<float>>(9.8f),
            water_graph->create<iris::VariableNode>("k" + std::to_string(counter)),
            iris::BinaryOperator::DIVIDE),
        iris::UnaryOperator::SQUARE_ROOT);

    water_graph->create_variable<iris::CombineNode>(
        "d" + std::to_string(counter),
        iris::VariableNodeType::VEC4,
        true,
        water_graph->create<iris::ValueNode<float>>(n_dx),
        water_graph->create<iris::ValueNode<float>>(n_dy),
        water_graph->create<iris::ValueNode<float>>(0.0f),
        water_graph->create<iris::ValueNode<float>>(0.0f));

    water_graph->create_variable<iris::BinaryOperatorNode>(
        "f" + std::to_string(counter),
        iris::VariableNodeType::FLOAT,
        true,
        water_graph->create<iris::VariableNode>("k" + std::to_string(counter)),
        water_graph->create<iris::BinaryOperatorNode>(
            water_graph->create<iris::BinaryOperatorNode>(
                water_graph->create<iris::ComponentNode>(
                    water_graph->create<iris::VariableNode>("d" + std::to_string(counter)), ".xy"),
                water_graph->create<iris::VertexNode>(iris::VertexDataType::POSITION, ".xz"),
                iris::BinaryOperator::DOT),
            water_graph->create<iris::BinaryOperatorNode>(
                water_graph->create<iris::VariableNode>("c" + std::to_string(counter)),
                water_graph->create<iris::TimeNode>(),
                iris::BinaryOperator::MULTIPLY),
            iris::BinaryOperator::SUBTRACT),
        iris::BinaryOperator::MULTIPLY);

    water_graph->create_variable<iris::CombineNode>(
        "t" + std::to_string(counter),
        iris::VariableNodeType::VEC4,
        true,
        water_graph->create<iris::BinaryOperatorNode>(
            water_graph->create<iris::ValueNode<float>>(1.0f),
            water_graph->create<iris::BinaryOperatorNode>(
                water_graph->create<iris::BinaryOperatorNode>(
                    water_graph->create<iris::ComponentNode>(
                        water_graph->create<iris::VariableNode>("d" + std::to_string(counter)), ".x"),
                    water_graph->create<iris::ComponentNode>(
                        water_graph->create<iris::VariableNode>("d" + std::to_string(counter)), ".x"),
                    iris::BinaryOperator::MULTIPLY),
                water_graph->create<iris::BinaryOperatorNode>(
                    water_graph->create<iris::UnaryOperatorNode>(
                        water_graph->create<iris::VariableNode>("f" + std::to_string(counter)),
                        iris::UnaryOperator::SIN),
                    water_graph->create<iris::VariableNode>("steepness" + std::to_string(counter)),
                    iris::BinaryOperator::MULTIPLY),
                iris::BinaryOperator::MULTIPLY),
            iris::BinaryOperator::SUBTRACT),
        water_graph->create<iris::BinaryOperatorNode>(
            water_graph->create<iris::ComponentNode>(
                water_graph->create<iris::VariableNode>("d" + std::to_string(counter)), ".x"),
            water_graph->create<iris::BinaryOperatorNode>(
                water_graph->create<iris::UnaryOperatorNode>(
                    water_graph->create<iris::VariableNode>("f" + std::to_string(counter)), iris::UnaryOperator::COS),
                water_graph->create<iris::VariableNode>("steepness" + std::to_string(counter)),
                iris::BinaryOperator::MULTIPLY),
            iris::BinaryOperator::MULTIPLY),
        water_graph->create<iris::BinaryOperatorNode>(
            water_graph->create<iris::BinaryOperatorNode>(
                water_graph->create<iris::UnaryOperatorNode>(
                    water_graph->create<iris::ComponentNode>(
                        water_graph->create<iris::VariableNode>("d" + std::to_string(counter)), ".x"),
                    iris::UnaryOperator::NEGATE),
                water_graph->create<iris::ComponentNode>(
                    water_graph->create<iris::VariableNode>("d" + std::to_string(counter)), ".y"),
                iris::BinaryOperator::MULTIPLY),
            water_graph->create<iris::BinaryOperatorNode>(
                water_graph->create<iris::UnaryOperatorNode>(
                    water_graph->create<iris::VariableNode>("f" + std::to_string(counter)), iris::UnaryOperator::SIN),
                water_graph->create<iris::VariableNode>("steepness" + std::to_string(counter)),
                iris::BinaryOperator::MULTIPLY),
            iris::BinaryOperator::MULTIPLY),
        water_graph->create<iris::ValueNode<float>>(0.0f));

    water_graph->create_variable<iris::CombineNode>(
        "b" + std::to_string(counter),
        iris::VariableNodeType::VEC4,
        true,
        water_graph->create<iris::BinaryOperatorNode>(
            water_graph->create<iris::BinaryOperatorNode>(
                water_graph->create<iris::UnaryOperatorNode>(
                    water_graph->create<iris::ComponentNode>(
                        water_graph->create<iris::VariableNode>("d" + std::to_string(counter)), ".x"),
                    iris::UnaryOperator::NEGATE),
                water_graph->create<iris::ComponentNode>(
                    water_graph->create<iris::VariableNode>("d" + std::to_string(counter)), ".y"),
                iris::BinaryOperator::MULTIPLY),
            water_graph->create<iris::BinaryOperatorNode>(
                water_graph->create<iris::UnaryOperatorNode>(
                    water_graph->create<iris::VariableNode>("f" + std::to_string(counter)), iris::UnaryOperator::SIN),
                water_graph->create<iris::VariableNode>("steepness" + std::to_string(counter)),
                iris::BinaryOperator::MULTIPLY),
            iris::BinaryOperator::MULTIPLY),
        water_graph->create<iris::BinaryOperatorNode>(
            water_graph->create<iris::ComponentNode>(
                water_graph->create<iris::VariableNode>("d" + std::to_string(counter)), ".y"),
            water_graph->create<iris::BinaryOperatorNode>(
                water_graph->create<iris::UnaryOperatorNode>(
                    water_graph->create<iris::VariableNode>("f" + std::to_string(counter)), iris::UnaryOperator::COS),
                water_graph->create<iris::VariableNode>("steepness" + std::to_string(counter)),
                iris::BinaryOperator::MULTIPLY),
            iris::BinaryOperator::MULTIPLY),
        water_graph->create<iris::BinaryOperatorNode>(
            water_graph->create<iris::ValueNode<float>>(1.0f),
            water_graph->create<iris::BinaryOperatorNode>(
                water_graph->create<iris::BinaryOperatorNode>(
                    water_graph->create<iris::ComponentNode>(
                        water_graph->create<iris::VariableNode>("d" + std::to_string(counter)), ".y"),
                    water_graph->create<iris::ComponentNode>(
                        water_graph->create<iris::VariableNode>("d" + std::to_string(counter)), ".y"),
                    iris::BinaryOperator::MULTIPLY),
                water_graph->create<iris::BinaryOperatorNode>(
                    water_graph->create<iris::UnaryOperatorNode>(
                        water_graph->create<iris::VariableNode>("f" + std::to_string(counter)),
                        iris::UnaryOperator::SIN),
                    water_graph->create<iris::VariableNode>("steepness" + std::to_string(counter)),
                    iris::BinaryOperator::MULTIPLY),
                iris::BinaryOperator::MULTIPLY),
            iris::BinaryOperator::SUBTRACT),
        water_graph->create<iris::ValueNode<float>>(0.0f));

    water_graph->create_variable<iris::UnaryOperatorNode>(
        "tb" + std::to_string(counter),
        iris::VariableNodeType::VEC3,
        true,
        water_graph->create<iris::BinaryOperatorNode>(
            water_graph->create<iris::ComponentNode>(
                water_graph->create<iris::VariableNode>("b" + std::to_string(counter)), ".xyz"),
            water_graph->create<iris::ComponentNode>(
                water_graph->create<iris::VariableNode>("t" + std::to_string(counter)), ".xyz"),
            iris::BinaryOperator::CROSS),
        iris::UnaryOperator::NORMALISE);

    water_graph->create_variable<iris::CombineNode>(
        "n" + std::to_string(counter),
        iris::VariableNodeType::VEC4,
        true,
        water_graph->create<iris::ComponentNode>(
            water_graph->create<iris::VariableNode>("tb" + std::to_string(counter)), ".x"),
        water_graph->create<iris::ComponentNode>(
            water_graph->create<iris::VariableNode>("tb" + std::to_string(counter)), ".y"),
        water_graph->create<iris::ComponentNode>(
            water_graph->create<iris::VariableNode>("tb" + std::to_string(counter)), ".z"),
        water_graph->create<iris::ValueNode<float>>(0.0f));

    water_graph->create_variable<iris::CombineNode>(
        "p" + std::to_string(counter),
        iris::VariableNodeType::VEC4,
        true,
        water_graph->create<iris::BinaryOperatorNode>(
            water_graph->create<iris::VertexNode>(iris::VertexDataType::POSITION, ".x"),
            water_graph->create<iris::BinaryOperatorNode>(
                water_graph->create<iris::ComponentNode>(
                    water_graph->create<iris::VariableNode>("d" + std::to_string(counter)), ".x"),
                water_graph->create<iris::BinaryOperatorNode>(
                    water_graph->create<iris::VariableNode>("a" + std::to_string(counter)),
                    water_graph->create<iris::UnaryOperatorNode>(
                        water_graph->create<iris::VariableNode>("f" + std::to_string(counter)),
                        iris::UnaryOperator::COS),
                    iris::BinaryOperator::MULTIPLY),
                iris::BinaryOperator::MULTIPLY),
            iris::BinaryOperator::ADD),
        water_graph->create<iris::BinaryOperatorNode>(
            water_graph->create<iris::VariableNode>("a" + std::to_string(counter)),
            water_graph->create<iris::UnaryOperatorNode>(
                water_graph->create<iris::VariableNode>("f" + std::to_string(counter)), iris::UnaryOperator::SIN),
            iris::BinaryOperator::MULTIPLY),
        water_graph->create<iris::BinaryOperatorNode>(
            water_graph->create<iris::VertexNode>(iris::VertexDataType::POSITION, ".z"),
            water_graph->create<iris::BinaryOperatorNode>(
                water_graph->create<iris::ComponentNode>(
                    water_graph->create<iris::VariableNode>("d" + std::to_string(counter)), ".y"),
                water_graph->create<iris::BinaryOperatorNode>(
                    water_graph->create<iris::VariableNode>("a" + std::to_string(counter)),
                    water_graph->create<iris::UnaryOperatorNode>(
                        water_graph->create<iris::VariableNode>("f" + std::to_string(counter)),
                        iris::UnaryOperator::COS),
                    iris::BinaryOperator::MULTIPLY),
                iris::BinaryOperator::MULTIPLY),
            iris::BinaryOperator::ADD),
        water_graph->create<iris::ValueNode<float>>(1.0f));

    water_graph->create_variable<iris::BinaryOperatorNode>(
        "p",
        iris::VariableNodeType::VEC4,
        false,
        water_graph->create<iris::VariableNode>("p"),
        water_graph->create<iris::VariableNode>("p" + std::to_string(counter)),
        iris::BinaryOperator::ADD);

    water_graph->create_variable<iris::BinaryOperatorNode>(
        "n",
        iris::VariableNodeType::VEC4,
        false,
        water_graph->create<iris::VariableNode>("n"),
        water_graph->create<iris::VariableNode>("n" + std::to_string(counter)),
        iris::BinaryOperator::ADD);

    ++counter;
}

iris::Vector3 wave_height(const iris::Vector3 &p, float dx, float dy, float wavelength, float steepness, float time)
{
    const auto d = iris::Vector3::normalise({dx, dy, 0.0f});
    const auto k = (std::numbers::pi_v<float> * 2.0f) / wavelength;
    const auto c = std::sqrt(9.8f / k);
    const auto f = k * (d.dot(iris::Vector3{p.x, p.z, 0.0f}) - c * time);
    const auto a = steepness / k;

    return {d.x * (a * std::cos(f)), a * std::sin(f), d.y * (a * std::cos(f))};
}

std::vector<std::tuple<float, float, float, float>> waves{
    {1.0f, 1.0f, 60.0f, 0.15f},
    {1.0f, 0.6f, 30.0f, 0.15f},
    {1.0f, 1.3f, 20.0f, 0.15f},
};

}

WaterSample::WaterSample(iris::Window *window, iris::RenderPipeline &render_pipeline, iris::Context &context)
    : light_transform_()
    , light_(nullptr)
    , camera_(iris::CameraType::PERSPECTIVE, window->width(), window->height(), 10000u)
    , key_map_()
    , sky_box_(nullptr)
    , scene_(nullptr)
    , player_()
    , azimuth_(std::numbers::pi_v<float> / 2.0f)
    , altitude_(std::numbers::pi_v<float> / 8.0f)
    , camera_distance_(200.0f)
    , render_target_(nullptr)
    , water_offset_x_property_()
    , water_offset_y_property_()
    , water_offset_x_(0.0f)
    , water_offset_y_(0.0f)
    , water_(nullptr)
    , window_(window)
{
    key_map_ = {
        {iris::Key::W, iris::KeyState::UP},
        {iris::Key::A, iris::KeyState::UP},
        {iris::Key::S, iris::KeyState::UP},
        {iris::Key::D, iris::KeyState::UP},
        {iris::Key::Q, iris::KeyState::UP},
        {iris::Key::E, iris::KeyState::UP},
    };

    camera_.set_position(camera_.position() + iris::Vector3{0.0f, 5.0f, 0.0f});

    scene_ = render_pipeline.create_scene();
    scene_->set_ambient_light({0.5f, 0.5f, 0.5f, 1.0f});

    auto &mesh_manager = context.mesh_manager();
    auto &texture_manager = context.texture_manager();
    auto &render_target_manager = context.render_target_manager();

    sky_box_ =
        texture_manager.create(iris::Colour{0.275f, 0.51f, 0.796f}, iris::Colour{0.5f, 0.5f, 0.5f}, 2048u, 2048u);

    auto *water_graph = render_pipeline.create_render_graph();

    water_offset_x_property_ = water_graph->create_property<float>("water_offset_x", water_offset_x_);
    water_offset_y_property_ = water_graph->create_property<float>("water_offset_y", water_offset_y_);

    // create variables to store vertex position and normal

    water_graph->create_variable<iris::CombineNode>(
        "p",
        iris::VariableNodeType::VEC4,
        true,
        water_graph->create<iris::ValueNode<float>>(0.0f),
        water_graph->create<iris::ValueNode<float>>(0.0f),
        water_graph->create<iris::ValueNode<float>>(0.0f),
        water_graph->create<iris::ValueNode<float>>(0.0f));

    water_graph->create_variable<iris::CombineNode>(
        "n",
        iris::VariableNodeType::VEC4,
        true,
        water_graph->create<iris::ValueNode<float>>(0.0f),
        water_graph->create<iris::ValueNode<float>>(0.0f),
        water_graph->create<iris::ValueNode<float>>(0.0f),
        water_graph->create<iris::ValueNode<float>>(0.0f));

    // add all waves to graph
    for (const auto &[dx, dy, wavelength, steepness] : waves)
    {
        add_wave(dx, dy, wavelength, steepness, water_graph);
    }

    const auto flow_map = texture_manager.load("FlowMap2.png", iris::TextureUsage::DATA);

    auto *uv_node = water_graph->create<iris::BinaryOperatorNode>(
        water_graph->create<iris::BinaryOperatorNode>(
            water_graph->create<iris::ComponentNode>(
                water_graph->create<iris::CombineNode>(
                    water_graph->create<iris::PropertyNode>("water_offset_x"),
                    water_graph->create<iris::PropertyNode>("water_offset_y"),
                    water_graph->create<iris::ValueNode<float>>(0.0f),
                    water_graph->create<iris::ValueNode<float>>(0.0f)),
                ".xy"),
            water_graph->create<iris::FragmentNode>(iris::FragmentDataType::TEX_COORD, ".xy"),
            iris::BinaryOperator::ADD),
        water_graph->create<iris::ComponentNode>(
            water_graph->create<iris::TextureNode>(
                flow_map,
                iris::UVSource::NODE,
                water_graph->create<iris::BinaryOperatorNode>(
                    water_graph->create<iris::BinaryOperatorNode>(
                        water_graph->create<iris::ComponentNode>(
                            water_graph->create<iris::CombineNode>(
                                water_graph->create<iris::PropertyNode>("water_offset_x"),
                                water_graph->create<iris::PropertyNode>("water_offset_y"),
                                water_graph->create<iris::ValueNode<float>>(0.0f),
                                water_graph->create<iris::ValueNode<float>>(0.0f)),
                            ".xy"),
                        water_graph->create<iris::BinaryOperatorNode>(
                            water_graph->create<iris::TimeNode>(),
                            water_graph->create<iris::ValueNode<float>>(0.01f),
                            iris::BinaryOperator::MULTIPLY),
                        iris::BinaryOperator::ADD),
                    water_graph->create<iris::FragmentNode>(iris::FragmentDataType::TEX_COORD, ".xy"),
                    iris::BinaryOperator::ADD)),
            ".xy"),
        iris::BinaryOperator::ADD);

    static constexpr iris::Colour water_base_colour{0.17f, 0.53f, 0.54f};
    static constexpr iris::Colour water_dark_colour{0.12f, 0.22f, 0.22f};
    static constexpr iris::Colour water_light_colour{1.0f, 1.0f, 1.0f};

    const auto *voronoi = texture_manager.load("Voronoi2.png");

    water_graph->create_variable<iris::BinaryOperatorNode>(
        "dist",
        iris::VariableNodeType::FLOAT,
        true,
        water_graph->create<iris::FragmentNode>(iris::FragmentDataType::VIEW_POSITION, ".xyz"),
        water_graph->create<iris::CameraNode>(iris::CameraDataType::POSITION, ".xyz"),
        iris::BinaryOperator::DISTANCE);

    water_graph->create_variable<iris::LerpNode>(
        "water_colour",
        iris::VariableNodeType::VEC4,
        true,
        water_graph->create<iris::LerpNode>(
            water_graph->create<iris::ColourNode>(water_base_colour),
            water_graph->create<iris::ColourNode>(water_dark_colour),
            water_graph->create<iris::TextureNode>(voronoi, iris::UVSource::NODE, uv_node)),
        water_graph->create<iris::ColourNode>(water_light_colour),
        water_graph->create<iris::TextureNode>(
            voronoi,
            iris::UVSource::NODE,
            water_graph->create<iris::BinaryOperatorNode>(
                uv_node,
                water_graph->create<iris::ComponentNode>(
                    water_graph->create<iris::CombineNode>(
                        water_graph->create<iris::ValueNode<float>>(0.1f),
                        water_graph->create<iris::ValueNode<float>>(0.1f),
                        water_graph->create<iris::ValueNode<float>>(0.0f),
                        water_graph->create<iris::ValueNode<float>>(0.0f)),
                    ".xy"),
                iris::BinaryOperator::ADD)));

    static const auto min_fog_distance = 2000.0f;
    static const auto max_fog_distance = 3000.0f;

    water_graph->render_node()->set_position_input(water_graph->create<iris::VariableNode>("p"));
    water_graph->render_node()->set_vertex_normal_input(water_graph->create<iris::VariableNode>("n"));
    water_graph->render_node()->set_colour_input(water_graph->create<iris::ConditionalNode>(
        water_graph->create<iris::VariableNode>("dist"),
        water_graph->create<iris::ValueNode<float>>(min_fog_distance),
        water_graph->create<iris::VariableNode>("water_colour"),
        water_graph->create<iris::ConditionalNode>(
            water_graph->create<iris::VariableNode>("dist"),
            water_graph->create<iris::ValueNode<float>>(max_fog_distance),
            water_graph->create<iris::ColourNode>(iris::Colour{water_base_colour, 0.0f}),

            water_graph->create<iris::LerpNode>(
                water_graph->create<iris::VariableNode>("water_colour"),
                water_graph->create<iris::ColourNode>(iris::Colour{water_base_colour, 0.0f}),

                water_graph->create<iris::BinaryOperatorNode>(
                    water_graph->create<iris::BinaryOperatorNode>(
                        water_graph->create<iris::VariableNode>("dist"),
                        water_graph->create<iris::ValueNode<float>>(min_fog_distance),
                        iris::BinaryOperator::SUBTRACT),
                    water_graph->create<iris::ValueNode<float>>(max_fog_distance - min_fog_distance),
                    iris::BinaryOperator::DIVIDE)),

            iris::ConditionalOperator::GREATER),
        iris::ConditionalOperator::LESS));

    auto *water_graph2 = render_pipeline.create_render_graph();

    water_graph2->create_variable<iris::ValueNode<float>>("a", iris::VariableNodeType::FLOAT, true, 0.5f);
    water_graph2->create_variable<iris::ValueNode<float>>("s", iris::VariableNodeType::FLOAT, true, 5.0f);
    water_graph2->create_variable<iris::ValueNode<float>>("w", iris::VariableNodeType::FLOAT, true, 10.0f);
    water_graph2->create_variable<iris::BinaryOperatorNode>(
        "k",
        iris::VariableNodeType::FLOAT,
        true,
        water_graph2->create<iris::ValueNode<float>>(std::numbers::pi_v<float> * 2.0f),
        water_graph2->create<iris::VariableNode>("w"),
        iris::BinaryOperator::DIVIDE);

    water_graph2->create_variable<iris::BinaryOperatorNode>(
        "new_y",
        iris::VariableNodeType::FLOAT,
        true,
        water_graph2->create<iris::VariableNode>("a"),
        water_graph2->create<iris::UnaryOperatorNode>(
            water_graph2->create<iris::BinaryOperatorNode>(
                water_graph2->create<iris::VariableNode>("k"),
                water_graph2->create<iris::BinaryOperatorNode>(
                    water_graph2->create<iris::VertexNode>(iris::VertexDataType::POSITION, ".x"),
                    water_graph2->create<iris::BinaryOperatorNode>(
                        water_graph2->create<iris::VariableNode>("s"),
                        water_graph2->create<iris::TimeNode>(),
                        iris::BinaryOperator::MULTIPLY),
                    iris::BinaryOperator::SUBTRACT),
                iris::BinaryOperator::MULTIPLY),
            iris::UnaryOperator::SIN),
        iris::BinaryOperator::MULTIPLY);

    water_graph2->render_node()->set_position_input(water_graph2->create<iris::CombineNode>(
        water_graph2->create<iris::VertexNode>(iris::VertexDataType::POSITION, ".x"),
        water_graph2->create<iris::VariableNode>("new_y"),
        water_graph2->create<iris::VertexNode>(iris::VertexDataType::POSITION, ".z"),
        water_graph2->create<iris::VertexNode>(iris::VertexDataType::POSITION, ".w")));

    water_ = scene_->create_entity<iris::SingleEntity>(
        water_graph,
        mesh_manager.plane({0.0f, 0.5f, 1.0f}, 100, 200.0f),
        iris::Transform{{0.0f, 0.0f, 0.0f}, {}, {20.0f}},
        true);

    const iris::Vector3 light_pos{0.0f, 5.0f, 0.0f};

    light_ = scene_->create_light<iris::DirectionalLight>(
        iris::Vector3{1.0f, -1.0f, 0.0f}, iris::Colour{0.3f, 0.3f, 0.3f, 1.0f});

    auto ship_meshes = mesh_manager.load_mesh("ship.fbx");
    auto *ship_graph = render_pipeline.create_render_graph();
    const auto *ship_texture = texture_manager.load("ship_texture.png");
    ship_graph->render_node()->set_colour_input(ship_graph->create<iris::TextureNode>(ship_texture));

    for (const auto &mesh : ship_meshes.mesh_data)
    {
        auto *entity = scene_->create_entity<iris::SingleEntity>(
            ship_graph, mesh.mesh, iris::Transform{{0.0f, 40.0f, 0.0f}, {}, {20.0f}});
        entity->set_wireframe(false);

        player_.push_back({entity, entity->position()});
    }

    auto *island_graph = render_pipeline.create_render_graph();

    island_graph->create_variable<iris::BinaryOperatorNode>(
        "dist",
        iris::VariableNodeType::FLOAT,
        true,
        island_graph->create<iris::FragmentNode>(iris::FragmentDataType::VIEW_POSITION, ".xyz"),
        island_graph->create<iris::CameraNode>(iris::CameraDataType::POSITION, ".xyz"),
        iris::BinaryOperator::DISTANCE);

    island_graph->create_variable<iris::ColourNode>(
        "island_colour", iris::VariableNodeType::VEC4, true, iris::Colour{1.0f, 1.0f, 1.0f, 1.0f});

    static const auto min_fade_distance = 3000.0f;
    static const auto max_fade_distance = 4000.0f;

    island_graph->render_node()->set_colour_input(island_graph->create<iris::ConditionalNode>(
        island_graph->create<iris::VariableNode>("dist"),
        island_graph->create<iris::ValueNode<float>>(min_fade_distance),
        island_graph->create<iris::VariableNode>("island_colour"),
        island_graph->create<iris::ConditionalNode>(
            island_graph->create<iris::VariableNode>("dist"),
            island_graph->create<iris::ValueNode<float>>(max_fade_distance),
            island_graph->create<iris::ColourNode>(iris::Colour{0.0f, 0.0f, 0.0f, 0.0f}),

            island_graph->create<iris::LerpNode>(
                island_graph->create<iris::VariableNode>("island_colour"),
                island_graph->create<iris::ColourNode>(iris::Colour{0.0f, 0.0f, 0.0f, 0.0f}),

                island_graph->create<iris::BinaryOperatorNode>(
                    island_graph->create<iris::BinaryOperatorNode>(
                        island_graph->create<iris::VariableNode>("dist"),
                        island_graph->create<iris::ValueNode<float>>(min_fade_distance),
                        iris::BinaryOperator::SUBTRACT),
                    island_graph->create<iris::ValueNode<float>>(max_fade_distance - min_fade_distance),
                    iris::BinaryOperator::DIVIDE)),

            iris::ConditionalOperator::GREATER),
        iris::ConditionalOperator::LESS));

    island_ = scene_->create_entity<iris::SingleEntity>(
        island_graph,
        mesh_manager.load_mesh("sphere.fbx").mesh_data.front().mesh,
        iris::Transform{{0.0f, 900000.0f, -400.0f}, {}, {40.0f}},
        true);

    const auto mesh_parts = mesh_manager.load_mesh("scene.fbx");
    for (const auto &mesh : mesh_parts.mesh_data)
    {
        scene_->create_entity<iris::SingleEntity>(
            nullptr,
            mesh.mesh,
            iris::Transform{{0.0f, 30.0f, -400.0f}, {{1.0f, 0.0f, 0.0f}, -std::numbers::pi_v<float> / 2.0f}, {40.0f}},
            true);
    }

    auto *pass = render_pipeline.create_render_pass(scene_);
    pass->post_processing_description = {.ambient_occlusion = {iris::AmbientOcclusionDescription{}}};
    pass->colour_target = render_target_manager.create();
    pass->camera = &camera_;
    pass->sky_box = sky_box_;

    render_target_ = pass->colour_target;
}

void WaterSample::fixed_update()
{
}

void WaterSample::variable_update()
{
    const auto velocity = calculate_velocity(camera_, key_map_);
    player_position_ = player_position_ + velocity;

    water_->set_position({player_position_.x, 0.0f, player_position_.z});

    iris::Quaternion player_orientation{{0.0f, 0.0f, 1.0f}, -azimuth_};
    player_orientation.normalise();
    const auto mesh_rotate = iris::Quaternion{{1.0f, 0.0f, 0.0f}, -std::numbers::pi_v<float> / 2.0f} *
                             player_orientation *
                             iris::Quaternion{{0.0f, 0.0f, 1.0f}, -std::numbers::pi_v<float> / 2.0f};

    for (auto &[entity, offset] : player_)
    {
        entity->set_position(player_position_ + offset);
        entity->set_orientation(mesh_rotate);
    }

    const iris::Vector3 offset{
        camera_distance_ * std::sin((std::numbers::pi_v<float> / 2.0f) - altitude_) * std::cos(azimuth_),
        camera_distance_ * std::cos((std::numbers::pi_v<float> / 2.0f) - altitude_),
        camera_distance_ * std::sin((std::numbers::pi_v<float> / 2.0f) - altitude_) * std::sin(azimuth_)};

    // update camera position to always follow player
    camera_.set_position(iris::Vector3{player_position_.x, 0.0f, player_position_.z} + offset);

    if (key_map_.at(iris::Key::W) == iris::KeyState::DOWN)
    {
        const auto direction = camera_.direction();

        water_offset_x_ += direction.x * 0.1f;
        water_offset_y_ -= direction.z * 0.1f;

        water_offset_x_property_.set_value(water_offset_x_);
        water_offset_y_property_.set_value(water_offset_y_);
    }

    // drop island at a distance
    const auto drop_amount = 70.0f;
    const auto min_drop_distance = 1800.0f;
    const auto max_drop_distance = 2000.0f;
    const auto distance = iris::Vector3::distance(player_position_, island_->position());

    auto drop = 0.0f;

    if (distance <= min_drop_distance)
    {
        drop = 0.0f;
    }
    else if (distance >= max_drop_distance)
    {
        drop = drop_amount;
    }
    else
    {
        drop = ((distance - min_drop_distance) / (max_drop_distance - min_drop_distance)) * drop_amount;
    }

    auto island_position = island_->position();
    island_position.y = -drop;
    island_->set_position(island_position);

    // calculate wave height on cpu and set player to it

    const iris::Vector3 wave_base{};
    iris::Vector3 new_pos{};

    for (const auto &[dx, dy, wavelength, steepness] : waves)
    {
        new_pos += wave_height(wave_base, dx, dy, wavelength, steepness, window_->time().count() / 1000.0f) * 20.0f;
    }

    player_position_.y = new_pos.y - 8.0f;
}

void WaterSample::handle_input(const iris::Event &event)
{
    if (event.is_key())
    {
        const auto keyboard = event.key();
        key_map_[keyboard.key] = keyboard.state;

        if (keyboard.key == iris::Key::SPACE)
        {
            for (auto [e, _] : player_)
            {
                auto p = e->position();
                p.y = 40.0f;
                e->set_position(p);
            }
        }
    }
    else if (event.is_mouse())
    {
        static const auto sensitivity = 0.0025f;
        const auto mouse = event.mouse();

        //  adjust camera azimuth and ensure we are still pointing at the player
        azimuth_ += mouse.delta_x * sensitivity;
        camera_.adjust_yaw(mouse.delta_x * sensitivity);

        static constexpr auto offset = 0.01f;

        // adjust camera altitude and ensure we are still pointing at the player
        // we clamp the altitude [0, pi/2] to ensure no weirdness happens
        altitude_ += mouse.delta_y * sensitivity;
        altitude_ = std::clamp(altitude_, 0.0f, (std::numbers::pi_v<float> / 2.0f) - offset);

        camera_.set_pitch(-altitude_);
    }
    else if (event.is_scroll_wheel())
    {
        const auto scroll = event.scroll_wheel();
        camera_distance_ += scroll.delta_y * -15.0f;
    }
}

std::string WaterSample::title() const
{
    return "Water";
}

const iris::RenderTarget *WaterSample::target() const
{
    return render_target_;
}

```

`samples/sample_browser/samples/water_sample.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <chrono>
#include <cstddef>
#include <map>
#include <string>

#include <core/camera.h>
#include <core/context.h>
#include <core/transform.h>
#include <events/event.h>
#include <graphics/animation/animation_controller.h>
#include <graphics/cube_map.h>
#include <graphics/lights/directional_light.h>
#include <graphics/render_entity.h>
#include <graphics/render_graph/property_writer.h>
#include <graphics/render_graph/render_graph.h>
#include <graphics/render_pipeline.h>
#include <graphics/single_entity.h>
#include <graphics/window.h>

#include "sample.h"

/**
 */
class WaterSample : public Sample
{
  public:
    /**
     * Create a new WaterSample.
     *
     * @param window
     *   Window to render with.
     *
     * @param render_pipeline
     *   Render pipeline to use for sample.
     *
     * @param context
     *   Engine context object.
     */
    WaterSample(iris::Window *window, iris::RenderPipeline &render_pipeline, iris::Context &context);
    ~WaterSample() override = default;

    /**
     * Fixed rate update function.
     */
    void fixed_update() override;

    /**
     * Variable rate update function.
     */
    void variable_update() override;

    /**
     * Handle a user input.
     *
     * @param event
     *   User input event.
     */
    void handle_input(const iris::Event &event) override;

    /**
     * Title of sample.
     *
     * @returns
     *   Sample title.
     */
    std::string title() const override;

    /**
     * Get the target the sample will render to.
     *
     * @returns
     *   Sample render target.
     */
    const iris::RenderTarget *target() const override;

  private:
    /** Transform for moving light. */
    iris::Transform light_transform_;

    /** Scene light */
    iris::DirectionalLight *light_;

    /** Render camera. */
    iris::Camera camera_;

    /** User input key map. */
    std::map<iris::Key, iris::KeyState> key_map_;

    /** Sky box for sample. */
    iris::CubeMap *sky_box_;

    /** Scene for sample. */
    iris::Scene *scene_;

    std::vector<std::tuple<iris::SingleEntity *, iris::Vector3>> player_;

    /** Camera azimuth. */
    float azimuth_;

    /** Camera altitude. */
    float altitude_;

    /** Distance to player. */
    float camera_distance_;

    /** Render target for sample. */
    const iris::RenderTarget *render_target_;

    /** Writer for water texture uv. */
    iris::PropertyWriter<float> water_offset_x_property_;

    /** Writer for water texture uv. */
    iris::PropertyWriter<float> water_offset_y_property_;

    /** Offset for water texture uv. */
    float water_offset_x_;

    /** Offset for water texture uv. */
    float water_offset_y_;

    /** Water entity. */
    iris::SingleEntity *water_;

    /** Player position. */
    iris::Vector3 player_position_;

    /** Island entity. */
    iris::SingleEntity *island_;

    /** Window object. */
    iris::Window *window_;
};

```

`shaders/CMakeLists.txt`:

```txt
function(iris_generate_shaders SHADER_LANGUAGE)
    set(SHADER_INCLUDES "")

    file(GLOB FILES ${PROJECT_SOURCE_DIR}/shaders/${SHADER_LANGUAGE}/*.${SHADER_LANGUAGE})

    foreach(FILE ${FILES})
        string(REGEX REPLACE "[.]${SHADER_LANGUAGE}$" "" SHADER_NAME ${FILE})
        cmake_path(GET SHADER_NAME FILENAME SHADER_NAME)
        string(REGEX REPLACE "[.]${SHADER_LANGUAGE}$" ".h" SHADER_FILE_NAME ${FILE})
        cmake_path(GET SHADER_FILE_NAME FILENAME SHADER_FILE_NAME)

        SET(SHADER_INCLUDES "${SHADER_INCLUDES}\n#include \"${SHADER_LANGUAGE}/${SHADER_FILE_NAME}\"")

        file(READ ${FILE} SHADER_SOURCE)
        configure_file(../shader_string.in ${SHADER_FILE_NAME})
    endforeach()

    configure_file(../shader_include.in "${SHADER_LANGUAGE}.h")
endfunction()

add_subdirectory("glsl")
add_subdirectory("hlsl")
add_subdirectory("msl")
```

`shaders/glsl/CMakeLists.txt`:

```txt
iris_generate_shaders("glsl")
```

`shaders/glsl/ambient_occlusion_node_fragment.glsl`:

```glsl
in vec2 tex_coord;
in vec3 tangent_frag_pos;
in vec3 tangent_light_pos;
in vec3 tangent_view_pos;
in vec4 col;
in vec4 frag_pos;
in vec4 frag_pos_light_space;
in vec4 norm;
in vec4 vertex_pos;
in vec4 view_norm;
in vec4 view_position;

layout (location = 0) out vec4 out_colour;

layout (std140, binding = 0) uniform CameraData
{
    mat4 projection;
    mat4 view;
    mat4 normal_view;
    vec3 camera;
};

layout (std140, binding = 2) uniform LightData
{
    mat4 light_projection;
    mat4 light_view;
    vec4 light_colour;
    vec4 light_position;
    vec4 light_attenuation;
};

layout (std430, binding = 3) buffer TextureData
{
    uvec2 texture_table[];
};

layout (std430, binding = 4) buffer CubeMapData
{
    uvec2 cube_map_table[];
};

uniform int shadow_map_index;

void main()
{
    const vec4 fragment_colour = {{ fragment_colour }};

    const vec3 samples[] = {
        vec3(-0.00886638, 0.00229353, 0.0231249), vec3(-0.000634795, 0.0456608, 0.0796033),
        vec3(0.00276396, 0.038391, 0.051785), vec3(0.000758422, 0.0368439, 0.0226108),
        vec3(-0.0210339, -0.0251614, 0.00471135), vec3(-0.0077157, 0.0156199, 0.0450549),
        vec3(-0.0539939, 0.0648841, 0.0591181), vec3(0.072815, -0.0666652, 0.00620315),
        vec3(-0.00919381, -0.00449068, 0.00473938), vec3(-0.104514, -0.0203993, 0.00417302),
        vec3(-0.109165, -0.0305201, 0.0141049), vec3(0.0424682, 0.0210869, 0.0302346),
        vec3(0.0159805, -0.00986693, 1.3074e-05), vec3(0.000889632, 0.00126402, 0.0648331),
        vec3(-0.0785, -0.0148912, 0.0617556), vec3(0.0810225, -0.0301, 0.0296346),
        vec3(0.0905632, -0.0689013, 0.0126851), vec3(0.0414047, 0.0489806, 0.0333673),
        vec3(-0.0111549, -0.0129772, 0.00831587), vec3(-0.0327198, 0.023108, 0.0101144),
        vec3(-0.0248668, -0.0307488, 0.0313254), vec3(-0.00400038, -0.0168738, 0.00877024),
        vec3(0.16404, -0.0637624, 0.0455338), vec3(0.0734847, 0.0766196, 0.0272843),
        vec3(0.0871256, 0.0227383, 0.00885513), vec3(0.0191078, -0.00586284, 0.0375503),
        vec3(-0.00139819, -0.00164079, 0.00227057), vec3(0.137097, -0.105593, 0.0516416),
        vec3(-0.0115462, -0.00991795, 0.0116921), vec3(0.0147203, -0.0119939, 0.00783621),
        vec3(0.0377106, 0.0794236, 0.158526), vec3(-0.205867, 0.102649, 0.00129098),
        vec3(0.0067215, -0.00561246, 0.00643123), vec3(0.0727398, -0.0334538, 0.163939),
        vec3(0.0804173, -0.0935365, 0.0692903), vec3(0.0519014, 0.276055, 0.172247),
        vec3(-0.350498, 0.154156, 0.0152109), vec3(-0.0765435, -0.184808, 0.0878499),
        vec3(0.0229437, -0.337212, 0.227193), vec3(0.245147, -0.0672405, 0.174766),
        vec3(-0.269699, 0.218419, 0.277733), vec3(-0.0226895, -0.0909222, 0.0906554),
        vec3(-0.138153, 0.0324949, 0.400103), vec3(0.0382081, -0.107126, 0.103821),
        vec3(0.172096, 0.0158331, 0.142202), vec3(-0.275107, -0.424418, 0.0449334),
        vec3(-0.00638451, 0.235465, 0.212274), vec3(0.249825, -0.34683, 0.367554),
        vec3(0.310481, 0.225706, 0.38594), vec3(0.00561876, 0.0713732, 0.16017),
        vec3(-0.0805308, -0.0039723, 0.00282647), vec3(-0.0165996, -0.000963676, 0.0139403),
        vec3(0.371335, 0.376646, 0.333897), vec3(-0.0242451, 0.0228724, 0.0762239),
        vec3(0.0868034, 0.0415974, 0.140887), vec3(-0.0342928, 0.0116279, 0.0615761),
        vec3(0.45093, -0.0762613, 0.16263), vec3(-0.0300036, 0.00125506, 0.0126724),
        vec3(0.0579732, -0.0307036, 0.0701422), vec3(0.474882, 0.536485, 0.364894),
        vec3(0.0534704, -0.0184046, 0.0217006), vec3(-0.626959, 0.290028, 0.17594),
        vec3(0.0670969, -0.0771161, 0.0286401), vec3(0.732737, -0.580259, 0.00029956)
    };
    const vec3 noise_data[] = {
        vec3(-0.595906, -0.156549, 0.0f), vec3(-0.631204, -0.049680, 0.0f),
        vec3(0.850768, -0.577690, 0.0f), vec3(-0.576086, 0.813602, 0.0f),
        vec3(0.585386, 0.520160, 0.0f), vec3(0.542889, -0.034259, 0.0f),
        vec3(-0.338602, -0.899637, 0.0f), vec3(0.298322, -0.040603, 0.0f),
        vec3(-0.345729, 0.861361, 0.0f), vec3(0.729817, -0.604520, 0.0f),
        vec3(0.258031, 0.804646, 0.0f), vec3(0.487633, -0.194988, 0.0f),
        vec3(-0.104914, -0.366919, 0.0f), vec3(-0.478404, 0.212103, 0.0f),
        vec3(-0.598677, -0.779258, 0.0f), vec3(0.837367, 0.120391, 0.0f)
    };
    
    const vec2 size = vec2({{width}}.f, {{height}}.f);
    const vec2 uv = vec2(tex_coord.x, 1.0 - tex_coord.y);
    const vec3 frag_pos = texture(sampler2D(texture_table[{{position_texture_index}}]), uv).xyz;
    const vec3 normal = normalize(texture(sampler2D(texture_table[{{normal_texture_index}}]), uv).rgb);

    const int sample_count = {{sample_count}};
    const float radius = {{radius}};
    const float bias = {{bias}};

    const int x = int(uv.x * size.x) % 4;
    const int y = int(uv.y * size.y) % 4;
    const int index = (y * 4) + x;
    const vec3 rand = normalize(noise_data[index]);

    const vec3 tangent = normalize(rand - normal * dot(rand, normal));
    const vec3 bitangent = cross(normal, tangent);
    const mat3 tbn = mat3(tangent, bitangent, normal);

    float occlusion = 0.0;

    for (int i = 0; i < sample_count; ++i)
    {
        vec3 sample_pos = tbn * samples[i];
        sample_pos = frag_pos + sample_pos * radius; 

        vec4 offset = transpose(projection) * vec4(sample_pos, 1.0);
        offset.xy /= offset.w;
        offset.x = offset.x * 0.5f + 0.5f;
        offset.y = -offset.y * 0.5f + 0.5f;

        const vec3 sample_normal = normalize(texture(sampler2D(texture_table[{{normal_texture_index}}]), offset.xy).rgb);
        if (dot(normal, sample_normal) > 0.99f)
        {
            continue;
        }

        const float sample_depth =
            texture(sampler2D(texture_table[{{position_texture_index}}]), vec2(offset.x, 1.0 - offset.y)).z;

        const float range_check = smoothstep(0.0, 1.0, radius / abs(frag_pos.z - sample_depth));
        occlusion += (sample_depth >= sample_pos.z + bias ? 1.0 : 0.0) * range_check;           
    }

    occlusion = 1.0 - (occlusion / sample_count);
    
    out_colour = light_colour * fragment_colour * vec4(occlusion, occlusion, occlusion, 1.0f);
}
```

`shaders/glsl/ambient_occlusion_node_vertex.glsl`:

```glsl
layout(location = 0) in vec4 position;
layout(location = 1) in vec4 normal;
layout(location = 2) in vec4 colour;
layout(location = 3) in vec4 tex;
layout(location = 4) in vec4 tangent;
layout(location = 5) in vec4 bitangent;
layout(location = 6) in ivec4 bone_ids;
layout(location = 7) in vec4 bone_weights;

out vec4 vertex_pos;
out vec4 frag_pos;
out vec2 tex_coord;
out vec4 col;
out vec4 norm;
out vec4 frag_pos_light_space;
out vec3 tangent_light_pos;
out vec3 tangent_view_pos;
out vec3 tangent_frag_pos;

void main()
{
    tex_coord = vec2(tex.x, tex.y);
    gl_Position = position;
}


```

`shaders/glsl/anti_aliasing_node_fragment.glsl`:

```glsl
in vec4 vertex_pos;
in vec2 tex_coord;
in vec4 col;
in vec4 norm;
in vec4 frag_pos;
in vec4 frag_pos_light_space;
in vec3 tangent_light_pos;
in vec3 tangent_view_pos;
in vec3 tangent_frag_pos;

out vec4 out_colour;

layout (std140, binding = 2) uniform LightData
{
    mat4 light_projection;
    mat4 light_view;
    vec4 light_colour;
    vec4 light_position;
    vec4 light_attenuation;
};

layout (std430, binding = 3) buffer TextureData
{
    uvec2 texture_table[];
};

layout (std430, binding = 4) buffer CubeMapData
{
    uvec2 cube_map_table[];
};

uniform int shadow_map_index;

void main()
{
    const vec4 fragment_colour = {{ fragment_colour }};

    const int up_offset = -1;
    const int down_offset = 1;
    const int left_offset = -1;
    const int right_offset = 1;

    const vec2 uv = vec2(tex_coord.x, 1.0 - tex_coord.y);
    const sampler2D tex = sampler2D(texture_table[{{input_texture_index}}]);
    const vec2 inverse_size = vec2({{inverse_width}}f, {{inverse_height}}f);

    // get luminance for current sample
    const vec3 colour_centre = texture(tex, uv).rgb;
    const float luma_centre = rgb_to_luma(colour_centre);
    
    // get luminance for surrounding samples
    const float luma_down = rgb_to_luma(textureOffset(tex, uv, ivec2(0, down_offset)).rgb);
    const float luma_up = rgb_to_luma(textureOffset(tex, uv, ivec2(0, up_offset)).rgb);
    const float luma_left = rgb_to_luma(textureOffset(tex, uv, ivec2(left_offset, 0)).rgb);
    const float luma_right = rgb_to_luma(textureOffset(tex, uv, ivec2(right_offset, 0)).rgb);
    
    // get min and max luminance
    const float luma_min = min(luma_centre, min(min(luma_down, luma_up), min(luma_left, luma_right)));
    const float luma_max = max(luma_centre, max(max(luma_down, luma_up), max(luma_left, luma_right)));
    
    const float luma_range = luma_max - luma_min;

    // filter anything outside of the accepted range
    if (luma_range < max(0.0312f, 0.125f * luma_max))
    {
        out_colour = vec4(colour_centre, 1.0);
        return;
    }
    
    // get corner luminance
    const float luma_down_left = rgb_to_luma(textureOffset(tex, uv, ivec2(left_offset, down_offset)).rgb);
    const float luma_up_right = rgb_to_luma(textureOffset(tex, uv, ivec2(right_offset, up_offset)).rgb);
    const float luma_up_left = rgb_to_luma(textureOffset(tex, uv, ivec2(left_offset, up_offset)).rgb);
    const float luma_down_right = rgb_to_luma(textureOffset(tex, uv, ivec2(right_offset, down_offset)).rgb);
    
    const float luma_down_up = luma_down + luma_up;
    const float luma_left_right = luma_left + luma_right;
    
    // get side luminance
    const float luma_left_corners = luma_down_left + luma_up_left;
    const float luma_down_corners = luma_down_left + luma_down_right;
    const float luma_right_corners = luma_down_right + luma_up_right;
    const float luma_up_corners = luma_up_right + luma_up_left;
    
    // calculate string of luminance along the horizontal
    const float edge_h =  abs(-2.0f * luma_left + luma_left_corners) +
                    abs(-2.0f * luma_centre + luma_down_up) * 2.0f +
                    abs(-2.0f * luma_right + luma_right_corners);
    
    // calculate string of luminance along the vertical
    const float edge_v =  abs(-2.0f * luma_up + luma_up_corners) +
                    abs(-2.0f * luma_centre + luma_left_right) * 2.0f +
                    abs(-2.0f * luma_down + luma_down_corners);
    
    // check if current sample lies among a mostly horizontal (or vertical) line
    const bool is_horiz = (edge_h >= edge_v);

    // get directions to test if we are on the positive or negative side of the line
    const float luma_neg = is_horiz ? luma_up : luma_left;
    const float luma_pos = is_horiz ? luma_down : luma_right;
    
    // get the gradient of the luminance in both positive and negative directions
    const float gradient_neg = abs(luma_neg - luma_centre);
    const float gradient_pos = abs(luma_pos - luma_centre);
    
    float step_length = is_horiz ? -inverse_size.y : -inverse_size.x;
    
    // calculate if we are on the negative or positive side of the line and adjust step length if needed
    float luma_local_avg = 0.0f;
    float gradient_scaled = 0.0f;
    if (gradient_neg < gradient_pos)
    {
        luma_local_avg = 0.5f * (luma_pos + luma_centre);
        gradient_scaled = gradient_pos;
        step_length = -step_length;
    }
    else
    {
        luma_local_avg = 0.5f * (luma_neg + luma_centre);
        gradient_scaled = gradient_neg;
    }

    // get blend direction
    vec2 current_uv = uv;
    if (is_horiz)
    {
        current_uv.y += step_length * 0.5f;
    }
    else
    {
        current_uv.x += step_length * 0.5f;
    }

    gradient_scaled *= 0.25f;
    
    const vec2 offset = is_horiz ? vec2(inverse_size.x, 0.0f) : vec2(0.0f, inverse_size.y);
    
    vec2 uv1 = current_uv - offset;
    vec2 uv2 = current_uv + offset;

    float luma_end1 = 0.0f;
    float luma_end2 = 0.0f;

    bool reached1 = false;
    bool reached2 = false;

    // try to find the length of the line by walking both ends of the line until we get a drop in luminance
    // we use increasing step sizes for performance
    for (int i = 0; i < 24; ++i)
    {
        float steps[] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.5f, 2.0f, 2.0f, 2.0f, 2.0f, 4.0f, 8.0f,
                          8.0f, 8.0f, 8.0f, 8.0f, 8.0f, 8.0f, 8.0f, 8.0f, 8.0f, 8.0f, 8.0f, 8.0f };
        if (!reached1)
        {
            luma_end1 = rgb_to_luma(texture(tex, uv1).rgb) - luma_local_avg;
        }

        if (!reached2)
        {
            luma_end2 = rgb_to_luma(texture(tex, uv2).rgb) - luma_local_avg;
        }
        
        // check if we have reached the end of either line
        reached1 = reached1 || abs(luma_end1) >= gradient_scaled;
        reached2 = reached2 || abs(luma_end2) >= gradient_scaled;

        if (reached1 && reached2)
        {
            break;
        }

        if (!reached1)
        {
            uv1 -= offset * steps[0];
        }

        if (!reached2)
        {
            uv2 += offset * steps[0];
        }
    }

    
    // get distance we travelled in both directions
    const float distance1 = is_horiz ? (uv.x - uv1.x) : (uv.y - uv1.y);
    const float distance2 = is_horiz ? (uv2.x - uv.x) : (uv2.y - uv.y);
    
    const bool is_direction1 = distance1 < distance2;
    const float distance_final = min(distance1, distance2);
    
    const float edge_thickness = (distance1 + distance2);
    
    const float pixel_offset = -distance_final / edge_thickness + 0.5f;
    
    const bool is_luma_centre_smaller = luma_centre < luma_local_avg;
    const bool correct_variation = ((is_direction1 ? luma_end1 : luma_end2) < 0.0f) != is_luma_centre_smaller;
    float final_offset = correct_variation ? pixel_offset : 0.0f;
    
    // perform subpixel blending
    const float luma_average = (1.0f / 12.0f) * (2.0f * (luma_down_up + luma_left_right) + luma_left_corners + luma_right_corners);
    const float sub_pixel_offset1 = clamp(abs(luma_average - luma_centre) / luma_range, 0.0f, 1.0f);
    const float sub_pixel_offset2 = (-2.0f * sub_pixel_offset1 + 3.0f) * sub_pixel_offset1 * sub_pixel_offset1;
    const float sub_pixel_offset_final = sub_pixel_offset2 * sub_pixel_offset2 * 0.75f;
    
    final_offset = max(final_offset, sub_pixel_offset_final);
    
    vec2 final_uv = uv;
    if (is_horiz)
    {
        final_uv.y += final_offset * step_length;
    }
    else
    {
        final_uv.x += final_offset * step_length;
    }
    
    // use the bilinear sampling of the original image to blur and soften the hard edges
    out_colour = texture(tex, vec2(final_uv.x, final_uv.y));
}
```

`shaders/glsl/anti_aliasing_node_vertex.glsl`:

```glsl
layout(location = 0) in vec4 position;
layout(location = 1) in vec4 normal;
layout(location = 2) in vec4 colour;
layout(location = 3) in vec4 tex;
layout(location = 4) in vec4 tangent;
layout(location = 5) in vec4 bitangent;
layout(location = 6) in ivec4 bone_ids;
layout(location = 7) in vec4 bone_weights;

out vec4 vertex_pos;
out vec4 frag_pos;
out vec2 tex_coord;
out vec4 col;
out vec4 norm;
out vec4 frag_pos_light_space;
out vec3 tangent_light_pos;
out vec3 tangent_view_pos;
out vec3 tangent_frag_pos;

layout (std140, binding = 0) uniform CameraData
{
    mat4 projection;
    mat4 view;
    vec3 camera;
};

layout (std140, binding = 1) uniform BoneData
{
    mat4 bones[100];
};

layout (std140, binding = 2) uniform LightData
{
    mat4 light_projection;
    mat4 light_view;
    vec4 light_colour;
    vec4 light_position;
    vec4 light_attenuation;
};

struct Model
{
    mat4 model;
    mat4 normal_matrix;
};
layout (std430, binding = 5) buffer ModelData
{
    Model models[];
};


void main()
{
    vertex_pos = position;
    tex_coord = tex.xy;
    gl_Position = position;
}

```

`shaders/glsl/binary_operator_node_chunk.glsl`:

```glsl
{% if operator == 0 %}
    ({{value1}} + {{value2}})
{% else if operator == 1 %}
    ({{value1}} - {{value2}})
{% else if operator == 2 %}
    ({{value1}} * {{value2}})
{% else if operator == 3 %}
    ({{value1}} / {{value2}})
{% else if operator == 4 %}
    dot({{value1}}, {{value2}})
{% else if operator == 5 %}
    cross({{value1}}, {{value2}})
{% else if operator == 6 %}
    distance({{value1}}, {{value2}})
{% endif %}
```

`shaders/glsl/blur_function.glsl`:

```glsl
vec4 blur(sampler2D tex, vec2 tex_coords)
{
    const float offset[5] = {0.0, 1.0, 2.0, 3.0, 4.0};
    const float weight[5] = {0.2270270270, 0.1945945946, 0.1216216216, 0.0540540541, 0.0162162162};

    vec4 colour = texture(tex, tex_coords) * weight[0];

    for (int i = 1; i < 5; ++i)
    {
        colour += texture(tex, tex_coords + vec2(0.0f, offset[i] / 800.0f)) * weight[i];
        colour += texture(tex, tex_coords - vec2(0.0f, offset[i] / 800.0f)) * weight[i];
    }

    for (int i = 1; i < 5; ++i)
    {
        colour += texture(tex, tex_coords + vec2(offset[i] / 800.0f, 0.0f)) * weight[i];
        colour += texture(tex, tex_coords - vec2(offset[i] / 800.0f, 0.0f)) * weight[i];
    }

    return colour;
}
```

`shaders/glsl/blur_node_chunk.glsl`:

```glsl
blur(sampler2D(texture_table[{{texture_index}}]), vec2(tex_coord.s, 1.0 - tex_coord.t))
```

`shaders/glsl/camera_node_chunk.glsl`:

```glsl
{% if type == 0 %}
    camera{{swizzle}}
{% endif %}
```

`shaders/glsl/colour_adjust_node_fragment.glsl`:

```glsl
in vec4 vertex_pos;
in vec2 tex_coord;
in vec4 col;
in vec4 norm;
in vec4 frag_pos;
in vec4 frag_pos_light_space;
in vec3 tangent_light_pos;
in vec3 tangent_view_pos;
in vec3 tangent_frag_pos;

out vec4 out_colour;

layout (std430, binding = 3) buffer TextureData
{
    uvec2 texture_table[];
};

void main()
{
    const vec4 fragment_colour = {{ fragment_colour }};
    const float gamma = {{gamma}};

    vec3 mapped = fragment_colour.rgb / (fragment_colour.rgb + vec3(1.0, 1.0, 1.0));
    mapped = pow(fragment_colour.rgb, vec3(gamma, gamma, gamma));

    out_colour = vec4(mapped.r, mapped.g, mapped.b, 1.0);
}

```

`shaders/glsl/colour_adjust_node_vertex.glsl`:

```glsl
layout(location = 0) in vec4 position;
layout(location = 1) in vec4 normal;
layout(location = 2) in vec4 colour;
layout(location = 3) in vec4 tex;
layout(location = 4) in vec4 tangent;
layout(location = 5) in vec4 bitangent;
layout(location = 6) in ivec4 bone_ids;
layout(location = 7) in vec4 bone_weights;

out vec4 vertex_pos;
out vec4 frag_pos;
out vec2 tex_coord;
out vec4 col;
out vec4 norm;
out vec4 frag_pos_light_space;
out vec3 tangent_light_pos;
out vec3 tangent_view_pos;
out vec3 tangent_frag_pos;

void main()
{
    tex_coord = vec2(tex.x, tex.y);
    gl_Position = position;
}

```

`shaders/glsl/colour_node_chunk.glsl`:

```glsl
vec4({{r}}, {{g}}, {{b}}, {{a}})
```

`shaders/glsl/combine_node_chunk.glsl`:

```glsl
vec4({{x}}, {{y}}, {{z}}, {{w}})
```

`shaders/glsl/component_node_chunk.glsl`:

```glsl
{{value}}{{component}}
```

`shaders/glsl/composite_function.glsl`:

```glsl
vec4 composite(vec4 colour1, vec4 colour2, vec4 depth1, vec4 depth2, vec2 tex_coord)
{
    vec4 colour = colour2;

    if(depth1.r < depth2.r)
    {
        colour = colour1;
    }

    return colour;
}
```

`shaders/glsl/composite_node_chunk.glsl`:

```glsl
composite({{colour1}}, {{colour2}}, {{depth1}}, {{depth2}}, vec2(tex_coord.s, 1.0 - tex_coord.t))
```

`shaders/glsl/conditional_node_chunk.glsl`:

```glsl
({{input1}} {{operator}} {{input2}} ? {{output1}} : {{output2}})
```

`shaders/glsl/declare_property_chunk.glsl`:

```glsl
layout (std430, binding = 5) buffer Properties
{
{% for property in properties %}
    {% if property.1 == 0 %}
    float property_{{property.0}};
    {% endif %}
{% endfor %}
    float _dummy;
};

```

`shaders/glsl/declare_variable_chunk.glsl`:

```glsl
{% if type == 0 %}
float {{name}} = {{value}};
{% else if type == 1 %}
vec3 {{name}} = {{value}};
{% else if type == 2 %}
vec4 {{name}} = {{value}};
{% endif %}
```

`shaders/glsl/fragment_node_chunk.glsl`:

```glsl
{% if type == 0 %}
    gl_Position{{swizzle}}
{% else if type == 1 %}
    view_position{{swizzle}}
{% else if type == 2 %}
    fragment_pos{{swizzle}}
{% else if type == 3 %}
    tex_coord{{swizzle}}
{% else if type == 4 %}
    normal{{swizzle}}
{% endif %}
```

`shaders/glsl/invert_function.glsl`:

```glsl
vec4 invert(vec4 colour)
{
    return vec4(1.0 - colour.r, 1.0 - colour.g, 1.0 - colour.b, colour.a);
}

```

`shaders/glsl/invert_node_chunk.glsl`:

```glsl
invert({{input}})
```

`shaders/glsl/lerp_node_chunk.glsl`:

```glsl
mix({{input1}}, {{input2}}, {{lerp_amount}})
```

`shaders/glsl/property_chunk.glsl`:

```glsl
{{name}}
```

`shaders/glsl/render_node_fragment.glsl`:

```glsl
in vec2 tex_coord;
in vec3 tangent_frag_pos;
in vec3 tangent_light_pos;
in vec3 tangent_view_pos;
in vec4 col;
in vec4 frag_pos;
in vec4 frag_pos_light_space;
in vec4 norm;
in vec4 vertex_pos;
in vec4 view_norm;
in vec4 view_position;

layout (location = 0) out vec4 out_colour;

{%if render_normal %}
layout (location = 1) out vec4 out_normal;
{% endif %}

{%if render_position %}
layout (location = 2) out vec4 out_position;
{% endif %}

layout (std140, binding = 0) uniform CameraData
{
    mat4 projection;
    mat4 view;
    mat4 normal_view;
    vec3 camera;
};

layout (std140, binding = 2) uniform LightData
{
    mat4 light_projection;
    mat4 light_view;
    vec4 light_colour;
    vec4 light_position;
    vec4 light_attenuation;
};

layout (std430, binding = 3) buffer TextureData
{
    uvec2 texture_table[];
};

layout (std430, binding = 4) buffer CubeMapData
{
    uvec2 cube_map_table[];
};

layout (std140, binding = 6) uniform RenderValues
{
    float time;
};

uniform int shadow_map_index;

{{properties}}

void main()
{
    {% for variable in variables %}
        {{variable}}
    {% endfor %}

    {% if exists("fragment_colour") %}
        vec4 fragment_colour = {{ fragment_colour }};
    {% else %}
        vec4 fragment_colour = col;
    {% endif %}

    {% if exists("normal") %}
        vec3 normal = {{ normal }}.xyz;
        normal = normalize(normal * 2.0 - 1.0); 
    {% else %}
        vec3 normal = normalize(norm.xyz);
    {% endif %}

    {% if light_type == 0 %}
        {% if exists("ambient_input") %}
            out_colour = {{ambient_input}};
        {% else %}
            out_colour = light_colour * fragment_colour;
        {% endif %}
    {% endif %}
    {% if light_type == 1 %}
        {% if exists("normal") %}
            vec3 light_dir = normalize(-tangent_light_pos.xyz);
        {% else %}
            vec3 light_dir = normalize(-light_position.xyz);
        {% endif %}

        float shadow = 0.0;
        shadow = calculate_shadow(
            normal,
            frag_pos_light_space,
            light_position.xyz,
            sampler2D(texture_table[shadow_map_index]));

        float diff = (1.0 - shadow) * max(dot(normal, light_dir), 0.0);
        vec3 diffuse = vec3(diff);
        out_colour = vec4(diffuse * fragment_colour.xyz, 1.0);
    {% endif %}
    {% if light_type == 2 %}
        {% if exists("normal") %}
            vec3 light_dir = normalize(tangent_light_pos.xyz - tangent_frag_pos.xyz);
        {% else %}
            vec3 light_dir = normalize(light_position.xyz - frag_pos.xyz);
        {% endif %}
    
        float distance  = length(light_position.xyz - frag_pos.xyz);
        float constant = light_attenuation.x;
        float linear_term = light_attenuation.y;
        float quadratic = light_attenuation.z;
        float attenuation = 1.0 / (constant + linear_term * distance + quadratic * (distance * distance));    
        vec3 att = {attenuation, attenuation, attenuation};
    
        float diff = max(dot(normal, light_dir), 0.0);
        vec3 diffuse = {diff, diff, diff};
        
        out_colour = vec4(diffuse * light_colour.xyz * fragment_colour.xyz * att, 1.0);
    {% endif %}

    {%if render_normal %}
        out_normal = vec4(normalize(view_norm.xyz), 1.0);
    {% endif %}

    {%if render_position %}
        out_position = view_position;
    {% endif %}

    if (fragment_colour.a < 0.01)
    {
        discard;
    }
}

```

`shaders/glsl/render_node_vertex.glsl`:

```glsl
layout(location = 0) in vec4 position;
layout(location = 1) in vec4 normal;
layout(location = 2) in vec4 colour;
layout(location = 3) in vec4 tex;
layout(location = 4) in vec4 tangent;
layout(location = 5) in vec4 bitangent;
layout(location = 6) in ivec4 bone_ids;
layout(location = 7) in vec4 bone_weights;

out vec2 tex_coord;
out vec3 tangent_frag_pos;
out vec3 tangent_light_pos;
out vec3 tangent_view_pos;
out vec4 col;
out vec4 frag_pos;
out vec4 frag_pos_light_space;
out vec4 norm;
out vec4 vertex_pos;
out vec4 view_norm;
out vec4 view_position;

layout (std140, binding = 0) uniform CameraData
{
    mat4 projection;
    mat4 view;
    mat4 normal_view;
    vec3 camera;
};

layout (std140, binding = 1) uniform BoneData
{
    mat4 bones[100];
};

layout (std140, binding = 2) uniform LightData
{
    mat4 light_projection;
    mat4 light_view;
    vec4 light_colour;
    vec4 light_position;
    vec4 light_attenuation;
};

struct Model
{
    mat4 model;
    mat4 normal_matrix;
};
layout (std430, binding = 5) buffer ModelData
{
    Model models[];
};

layout (std430, binding = 6) buffer RenderValues
{
    float time;
};

void main()
{
    {% for variable in variables %}
        {{variable}}
    {% endfor %}

    mat4 bone_transform = bones[bone_ids[0]] * bone_weights[0];
    bone_transform += bones[bone_ids[1]] * bone_weights[1];
    bone_transform += bones[bone_ids[2]] * bone_weights[2];
    bone_transform += bones[bone_ids[3]] * bone_weights[3];
    bone_transform = transpose(bone_transform);

    mat4 normal_matrix = transpose(models[gl_InstanceID].normal_matrix);
    vec3 T = normalize(vec3(normal_matrix * bone_transform * tangent));
    vec3 B = normalize(vec3(normal_matrix * bone_transform * bitangent));
    vec3 N = normalize(vec3(normal_matrix * bone_transform * normal));
    mat3 tbn = transpose(mat3(T, B, N));

    vertex_pos = position;

    {% if exists("position") %}
        vertex_pos = {{position}};
    {% endif %}

    frag_pos = transpose(models[gl_InstanceID].model) * bone_transform * position;
    view_position = transpose(view) * frag_pos;
    gl_Position = transpose(projection) * view_position;
    norm = transpose(models[gl_InstanceID].normal_matrix) * bone_transform * normal;
    col = colour;
    tex_coord = vec2(tex.x, tex.y);

    {% if is_directional_light %}
        frag_pos_light_space = transpose(light_projection) * transpose(light_view) * frag_pos;
    {% endif %}

    tangent_light_pos = tbn * light_position.xyz;
    tangent_view_pos = tbn * camera.xyz;
    tangent_frag_pos = tbn * frag_pos.xyz;

    view_norm = transpose(normal_view) * norm;
    
}

```

`shaders/glsl/rgb_to_luma_function.glsl`:

```glsl
float rgb_to_luma(vec3 rgb)
{
    // calculate luminance based on how sensitive the human light is to each channel
    return sqrt(dot(rgb, vec3(0.299f, 0.587f, 0.114f)));
}

```

`shaders/glsl/set_variable_chunk.glsl`:

```glsl
{{name}} = {{value}};
```

`shaders/glsl/shadow_function.glsl`:

```glsl
float calculate_shadow(vec3 n, vec4 frag_pos_light_space, vec3 light_dir, sampler2D tex)
{
    float shadow = 0.0;
    vec3 proj_coord = frag_pos_light_space.xyz / frag_pos_light_space.w;
    proj_coord = proj_coord * 0.5 + 0.5;

    float closest_depth = texture(tex, proj_coord.xy).r;
    float current_depth = proj_coord.z;
    float bias = 0.001;

    shadow = (current_depth - bias) > closest_depth ? 1.0 : 0.0;

    if (proj_coord.z > 1.0)
    {
        shadow = 0.0;
    }

    return shadow;
}

```

`shaders/glsl/sin_node_chunk.glsl`:

```glsl
sin({{value}})
```

`shaders/glsl/sky_box_node_fragment.glsl`:

```glsl
in vec4 vertex_pos;
in vec2 tex_coord;
in vec4 col;
in vec4 norm;
in vec4 frag_pos;
in vec4 frag_pos_light_space;
in vec3 tangent_light_pos;
in vec3 tangent_view_pos;
in vec3 tangent_frag_pos;

out vec4 out_colour;

layout (std430, binding = 4) buffer CubeMapData
{
    uvec2 cube_map_table[];
};

void main()
{
    out_colour = texture(samplerCube(cube_map_table[{{cube_map_index}}]), vertex_pos.xyz);
}

```

`shaders/glsl/sky_box_node_vertex.glsl`:

```glsl
layout(location = 0) in vec4 position;
layout(location = 1) in vec4 normal;
layout(location = 2) in vec4 colour;
layout(location = 3) in vec4 tex;
layout(location = 4) in vec4 tangent;
layout(location = 5) in vec4 bitangent;
layout(location = 6) in ivec4 bone_ids;
layout(location = 7) in vec4 bone_weights;

out vec4 vertex_pos;
out vec4 frag_pos;
out vec2 tex_coord;
out vec4 col;
out vec4 norm;
out vec4 frag_pos_light_space;
out vec3 tangent_light_pos;
out vec3 tangent_view_pos;
out vec3 tangent_frag_pos;

layout (std140, binding = 0) uniform CameraData
{
    mat4 projection;
    mat4 view;
    vec3 camera;
};

layout (std140, binding = 1) uniform BoneData
{
    mat4 bones[100];
};

struct Model
{
    mat4 model;
    mat4 normal_matrix;
};
layout (std430, binding = 5) buffer ModelData
{
    Model models[];
};

void main()
{
    vertex_pos = position;
    gl_Position = (transpose(projection) * transpose(mat4(mat3(view))) * position).xyww;
}

```

`shaders/glsl/texture_node_chunk.glsl`:

```glsl
{% if uv_source == 0 %}
    texture(sampler2D(texture_table[{{texture_index}}]), vec2(tex_coord.s, 1.0 - tex_coord.t))
{% else if uv_source == 1 %}
    texture(sampler2D(texture_table[{{texture_index}}]), vec2(tex_coord.s * {{reciprocal_width}}, 1.0 - (tex_coord.t * {{reciprocal_height}})))
{% else if uv_source == 2 %}
    texture(sampler2D(texture_table[{{texture_index}}]), vec2({{tex_coord}}.x, 1.0 - {{tex_coord}}.y))
{% endif %}

```

`shaders/glsl/time_node_chunk.glsl`:

```glsl
time
```

`shaders/glsl/value_node_colour_chunk.glsl`:

```glsl
vec4({{r}}, {{g}}, {{b}}, {{a}})
```

`shaders/glsl/value_node_float_chunk.glsl`:

```glsl
{{value}}
```

`shaders/glsl/value_node_vector3_chunk.glsl`:

```glsl
vec3({{x}}, {{y}}, {{z}})
```

`shaders/glsl/variable_node_chunk.glsl`:

```glsl
{{name}}
```

`shaders/glsl/vertex_node_chunk.glsl`:

```glsl
{% if type == 0 %}
    vertex_pos{{swizzle}}
{% else if type == 1 %}
    norm{{swizzle}}
{% else if type == 2 %}
    vec3(tex_coord{{swizzle}}, 0.0)
{% endif %}
```

`shaders/hlsl/CMakeLists.txt`:

```txt
iris_generate_shaders("hlsl")
```

`shaders/hlsl/ambient_occlusion_node_fragment.hlsl`:

```hlsl
cbuffer Light : register(b1)
{
    matrix light_projection;
    matrix light_view;
    float4 light_colour;
    float4 light_position;
    float4 light_attenuation;
};

cbuffer CameraData : register(b2)
{
    matrix projection;
    matrix view;
    matrix normal_view;
    float4 camera;
};

SamplerState sampler_table[] : register(s0);
Texture2D texture_table[] : register(t0, space1);

struct PSInput
{
    precise float4 position : SV_POSITION;
    precise float2 tex_coord : TEXCOORD;
    precise float4 vertex_position : TEXCOORD1;
    precise float4 frag_position : TEXCOORD2;
    precise float4 view_position : COLOR1;
    precise float4 tangent_view_pos : TEXCOORD4;
    precise float4 tangent_frag_pos : TEXCOORD5;
    precise float4 tangent_light_pos : TEXCOORD6;
    precise float4 frag_pos_light_space : TEXCOORD7;
    precise float4 normal : NORMAL;
    precise float4 view_normal : NORMAL1;
    precise float4 colour : COLOR;
};

float4 main(PSInput input) : SV_TARGET
{
    const float4 fragment_colour = {{ fragment_colour }};

    const float3 samples[] = {
        float3(-0.00886638, 0.00229353, 0.0231249), float3(-0.000634795, 0.0456608, 0.0796033),
        float3(0.00276396, 0.038391, 0.051785), float3(0.000758422, 0.0368439, 0.0226108),
        float3(-0.0210339, -0.0251614, 0.00471135), float3(-0.0077157, 0.0156199, 0.0450549),
        float3(-0.0539939, 0.0648841, 0.0591181), float3(0.072815, -0.0666652, 0.00620315),
        float3(-0.00919381, -0.00449068, 0.00473938), float3(-0.104514, -0.0203993, 0.00417302),
        float3(-0.109165, -0.0305201, 0.0141049), float3(0.0424682, 0.0210869, 0.0302346),
        float3(0.0159805, -0.00986693, 1.3074e-05), float3(0.000889632, 0.00126402, 0.0648331),
        float3(-0.0785, -0.0148912, 0.0617556), float3(0.0810225, -0.0301, 0.0296346),
        float3(0.0905632, -0.0689013, 0.0126851), float3(0.0414047, 0.0489806, 0.0333673),
        float3(-0.0111549, -0.0129772, 0.00831587), float3(-0.0327198, 0.023108, 0.0101144),
        float3(-0.0248668, -0.0307488, 0.0313254), float3(-0.00400038, -0.0168738, 0.00877024),
        float3(0.16404, -0.0637624, 0.0455338), float3(0.0734847, 0.0766196, 0.0272843),
        float3(0.0871256, 0.0227383, 0.00885513), float3(0.0191078, -0.00586284, 0.0375503),
        float3(-0.00139819, -0.00164079, 0.00227057), float3(0.137097, -0.105593, 0.0516416),
        float3(-0.0115462, -0.00991795, 0.0116921), float3(0.0147203, -0.0119939, 0.00783621),
        float3(0.0377106, 0.0794236, 0.158526), float3(-0.205867, 0.102649, 0.00129098),
        float3(0.0067215, -0.00561246, 0.00643123), float3(0.0727398, -0.0334538, 0.163939),
        float3(0.0804173, -0.0935365, 0.0692903), float3(0.0519014, 0.276055, 0.172247),
        float3(-0.350498, 0.154156, 0.0152109), float3(-0.0765435, -0.184808, 0.0878499),
        float3(0.0229437, -0.337212, 0.227193), float3(0.245147, -0.0672405, 0.174766),
        float3(-0.269699, 0.218419, 0.277733), float3(-0.0226895, -0.0909222, 0.0906554),
        float3(-0.138153, 0.0324949, 0.400103), float3(0.0382081, -0.107126, 0.103821),
        float3(0.172096, 0.0158331, 0.142202), float3(-0.275107, -0.424418, 0.0449334),
        float3(-0.00638451, 0.235465, 0.212274), float3(0.249825, -0.34683, 0.367554),
        float3(0.310481, 0.225706, 0.38594), float3(0.00561876, 0.0713732, 0.16017),
        float3(-0.0805308, -0.0039723, 0.00282647), float3(-0.0165996, -0.000963676, 0.0139403),
        float3(0.371335, 0.376646, 0.333897), float3(-0.0242451, 0.0228724, 0.0762239),
        float3(0.0868034, 0.0415974, 0.140887), float3(-0.0342928, 0.0116279, 0.0615761),
        float3(0.45093, -0.0762613, 0.16263), float3(-0.0300036, 0.00125506, 0.0126724),
        float3(0.0579732, -0.0307036, 0.0701422), float3(0.474882, 0.536485, 0.364894),
        float3(0.0534704, -0.0184046, 0.0217006), float3(-0.626959, 0.290028, 0.17594),
        float3(0.0670969, -0.0771161, 0.0286401), float3(0.732737, -0.580259, 0.00029956)
    };
    const float3 noise_data[] = {
        float3(-0.595906, -0.156549, 0.0f), float3(-0.631204, -0.049680, 0.0f),
        float3(0.850768, -0.577690, 0.0f), float3(-0.576086, 0.813602, 0.0f),
        float3(0.585386, 0.520160, 0.0f), float3(0.542889, -0.034259, 0.0f),
        float3(-0.338602, -0.899637, 0.0f), float3(0.298322, -0.040603, 0.0f),
        float3(-0.345729, 0.861361, 0.0f), float3(0.729817, -0.604520, 0.0f),
        float3(0.258031, 0.804646, 0.0f), float3(0.487633, -0.194988, 0.0f),
        float3(-0.104914, -0.366919, 0.0f), float3(-0.478404, 0.212103, 0.0f),
        float3(-0.598677, -0.779258, 0.0f), float3(0.837367, 0.120391, 0.0f)
    };

    const float2 size = float2({{width}}.f, {{height}}.f);
    const float2 uv = input.tex_coord.xy;
    const float3 frag_pos = texture_table[{{position_texture_index}}].Sample(sampler_table[{{position_sampler_index}}], uv).xyz;
    const float3 normal = normalize(texture_table[{{normal_texture_index}}].Sample(sampler_table[{{normal_sampler_index}}], uv).rgb);
    const int sample_count = {{sample_count}};
    const float radius = {{radius}};
    const float bias = {{bias}};

    const int x = int(uv.x * size.x) % 4;
    const int y = int(uv.y * size.y) % 4;
    const int index = (y * 4) + x;
    const float3 rand = normalize(noise_data[index]);

    const float3 tangent = normalize(rand - normal * dot(rand, normal));
    const float3 bitangent = cross(normal, tangent);
    const float3x3 tbn = float3x3(tangent, bitangent, normal);

    float occlusion = 0.0;

    for (int i = 0; i < sample_count; ++i)
    {
        float3 sample_pos = mul(float4(samples[i], 1.0), tbn);
        sample_pos = frag_pos + sample_pos * radius; 

        float4 offset = mul(sample_pos, projection);
        offset.xy /= offset.w;
        offset.x = offset.x * 0.5f + 0.5f;
        offset.y = -offset.y * 0.5f + 0.5f;

        const float3 sample_normal = normalize(texture_table[{{normal_texture_index}}].Sample(sampler_table[{{normal_sampler_index}}], offset.xy).rgb);
        if (dot(normal, sample_normal) > 0.99f)
        {
            continue;
        }

        const float sample_depth =
            texture_table[{{position_texture_index}}].Sample(sampler_table[{{position_sampler_index}}], offset.xy).z;

        const float range_check = smoothstep(0.0, 1.0, radius / abs(frag_pos.z - sample_depth));
        occlusion += (sample_depth >= sample_pos.z + bias ? 1.0 : 0.0) * range_check;           
    }

    occlusion = 1.0 - (occlusion / sample_count);
    
    return light_colour * fragment_colour * float4(occlusion, occlusion, occlusion, 1.0f);
}
```

`shaders/hlsl/ambient_occlusion_node_vertex.hlsl`:

```hlsl
struct PSInput
{
    precise float4 position : SV_POSITION;
    precise float2 tex_coord : TEXCOORD;
    precise float4 vertex_position : TEXCOORD1;
    precise float4 frag_position : TEXCOORD2;
    precise float4 view_position : COLOR1;
    precise float4 tangent_view_pos : TEXCOORD4;
    precise float4 tangent_frag_pos : TEXCOORD5;
    precise float4 tangent_light_pos : TEXCOORD6;
    precise float4 frag_pos_light_space : TEXCOORD7;
    precise float4 normal : NORMAL;
    precise float4 view_normal : NORMAL1;
    precise float4 colour : COLOR;
};

PSInput main(
    float4 position : TEXCOORD0,
    float4 normal : TEXCOORD1,
    float4 colour : TEXCOORD2,
    float4 tex_coord : TEXCOORD3,
    float4 tangent : TEXCOORD4,
    float4 bitangent : TEXCOORD5,
    uint4 bone_ids : TEXCOORD6,
    float4 bone_weights : TEXCOORD7,
    uint instance_id : SV_InstanceID)
{
    PSInput result;

    result.position = position;
    result.tex_coord = tex_coord;
    result.normal = normal;

    return result;
}

```

`shaders/hlsl/anti_aliasing_node_fragment.hlsl`:

```hlsl
SamplerState sampler_table[] : register(s0);
Texture2D texture_table[] : register(t0, space1);

struct PSInput
{
    precise float4 position : SV_POSITION;
    precise float2 tex_coord : TEXCOORD;
    precise float4 vertex_position : TEXCOORD1;
    precise float4 frag_position : TEXCOORD2;
    precise float4 view_position : COLOR1;
    precise float4 tangent_view_pos : TEXCOORD4;
    precise float4 tangent_frag_pos : TEXCOORD5;
    precise float4 tangent_light_pos : TEXCOORD6;
    precise float4 frag_pos_light_space : TEXCOORD7;
    precise float4 normal : NORMAL;
    precise float4 view_normal : NORMAL1;
    precise float4 colour : COLOR;
};

float4 main(PSInput input) : SV_TARGET
{
    const float4 fragment_colour = {{ fragment_colour }};

    const int up_offset = -1;
    const int down_offset = 1;
    const int left_offset = -1;
    const int right_offset = 1;

    const float2 uv = input.tex_coord.xy;
    const Texture2D tex = texture_table[{{input_texture_index}}];
    const SamplerState smplr = sampler_table[{{input_sampler_index}}];
    const float2 inverse_size = float2({{inverse_width}}f, {{inverse_height}}f);

    // get luminance for current sample
    const float4 colour_centre_full = tex.Sample(smplr, uv).rgba;
    const float3 colour_centre = colour_centre_full.rgb;
    const float luma_centre = rgb_to_luma(colour_centre);
    
    // get luminance for surrounding samples
    const float luma_down = rgb_to_luma(tex.Sample(smplr, uv, int2(0, down_offset)).rgb);
    const float luma_up = rgb_to_luma(tex.Sample(smplr, uv, int2(0, up_offset)).rgb);
    const float luma_left = rgb_to_luma(tex.Sample(smplr, uv, int2(left_offset, 0)).rgb);
    const float luma_right = rgb_to_luma(tex.Sample(smplr, uv, int2(right_offset, 0)).rgb);
    
    // get min and max luminance
    const float luma_min = min(luma_centre, min(min(luma_down, luma_up), min(luma_left, luma_right)));
    const float luma_max = max(luma_centre, max(max(luma_down, luma_up), max(luma_left, luma_right)));
    
    const float luma_range = luma_max - luma_min;
    
    // filter anything outside of the accepted range
    if (luma_range < max(0.0312f, 0.125f * luma_max))
    {
        return colour_centre_full;
    }
    
    // get corner luminance
    const float luma_down_left = rgb_to_luma(tex.Sample(smplr, uv, int2(left_offset, down_offset)).rgb);
    const float luma_up_right = rgb_to_luma(tex.Sample(smplr, uv, int2(right_offset, up_offset)).rgb);
    const float luma_up_left = rgb_to_luma(tex.Sample(smplr, uv, int2(left_offset, up_offset)).rgb);
    const float luma_down_right = rgb_to_luma(tex.Sample(smplr, uv, int2(right_offset, down_offset)).rgb);
    
    const float luma_down_up = luma_down + luma_up;
    const float luma_left_right = luma_left + luma_right;
    
    // get side luminance
    const float luma_left_corners = luma_down_left + luma_up_left;
    const float luma_down_corners = luma_down_left + luma_down_right;
    const float luma_right_corners = luma_down_right + luma_up_right;
    const float luma_up_corners = luma_up_right + luma_up_left;
    
    // calculate string of luminance along the horizontal
    const float edge_h =  abs(-2.0f * luma_left + luma_left_corners) +
                    abs(-2.0f * luma_centre + luma_down_up) * 2.0f +
                    abs(-2.0f * luma_right + luma_right_corners);
    
    // calculate string of luminance along the vertical
    const float edge_v =  abs(-2.0f * luma_up + luma_up_corners) +
                    abs(-2.0f * luma_centre + luma_left_right) * 2.0f +
                    abs(-2.0f * luma_down + luma_down_corners);
    
    // check if current sample lies among a mostly horizontal (or vertical) line
    const bool is_horiz = (edge_h >= edge_v);

    // get directions to test if we are on the positive or negative side of the line
    const float luma_neg = is_horiz ? luma_up : luma_left;
    const float luma_pos = is_horiz ? luma_down : luma_right;
    
    // get the gradient of the luminance in both positive and negative directions
    const float gradient_neg = abs(luma_neg - luma_centre);
    const float gradient_pos = abs(luma_pos - luma_centre);
    
    float step_length = is_horiz ? -inverse_size.y : -inverse_size.x;
    
    // calculate if we are on the negative or positive side of the line and adjust step length if needed
    float luma_local_avg = 0.0f;
    float gradient_scaled = 0.0f;
    if (gradient_neg < gradient_pos)
    {
        luma_local_avg = 0.5f * (luma_pos + luma_centre);
        gradient_scaled = gradient_pos;
        step_length = -step_length;
    }
    else
    {
        luma_local_avg = 0.5f * (luma_neg + luma_centre);
        gradient_scaled = gradient_neg;
    }

    // get blend direction
    float2 current_uv = uv;
    if (is_horiz)
    {
        current_uv.y += step_length * 0.5f;
    }
    else
    {
        current_uv.x += step_length * 0.5f;
    }

    gradient_scaled *= 0.25f;
    
    const float2 offset = is_horiz ? float2(inverse_size.x, 0.0f) : float2(0.0f, inverse_size.y);
    
    float2 uv1 = current_uv - offset;
    float2 uv2 = current_uv + offset;

    float luma_end1 = 0.0f;
    float luma_end2 = 0.0f;

    bool reached1 = false;
    bool reached2 = false;

    // try to find the length of the line by walking both ends of the line until we get a drop in luminance
    // we use increasing step sizes for performance
    for (int i = 0; i < 24; ++i)
    {
        float steps[] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.5f, 2.0f, 2.0f, 2.0f, 2.0f, 4.0f, 8.0f,
                          8.0f, 8.0f, 8.0f, 8.0f, 8.0f, 8.0f, 8.0f, 8.0f, 8.0f, 8.0f, 8.0f, 8.0f };
        if (!reached1)
        {
            luma_end1 = rgb_to_luma(tex.SampleLevel(smplr, uv1, 0).rgb) - luma_local_avg;
        }

        if (!reached2)
        {
            luma_end2 = rgb_to_luma(tex.SampleLevel(smplr, uv2, 0).rgb) - luma_local_avg;
        }
        
        // check if we have reached the end of either line
        reached1 = reached1 || abs(luma_end1) >= gradient_scaled;
        reached2 = reached2 || abs(luma_end2) >= gradient_scaled;

        if (reached1 && reached2)
        {
            break;
        }

        if (!reached1)
        {
            uv1 -= offset * steps[0];
        }

        if (!reached2)
        {
            uv2 += offset * steps[0];
        }
    }

    
    // get distance we travelled in both directions
    const float distance1 = is_horiz ? (uv.x - uv1.x) : (uv.y - uv1.y);
    const float distance2 = is_horiz ? (uv2.x - uv.x) : (uv2.y - uv.y);
    
    const bool is_direction1 = distance1 < distance2;
    const float distance_final = min(distance1, distance2);
    
    const float edge_thickness = (distance1 + distance2);
    
    const float pixel_offset = -distance_final / edge_thickness + 0.5f;
    
    const bool is_luma_centre_smaller = luma_centre < luma_local_avg;
    const bool correct_variation = ((is_direction1 ? luma_end1 : luma_end2) < 0.0f) != is_luma_centre_smaller;
    float final_offset = correct_variation ? pixel_offset : 0.0f;
    
    // perform subpixel blending
    const float luma_average = (1.0f / 12.0f) * (2.0f * (luma_down_up + luma_left_right) + luma_left_corners + luma_right_corners);
    const float sub_pixel_offset1 = clamp(abs(luma_average - luma_centre) / luma_range, 0.0f, 1.0f);
    const float sub_pixel_offset2 = (-2.0f * sub_pixel_offset1 + 3.0f) * sub_pixel_offset1 * sub_pixel_offset1;
    const float sub_pixel_offset_final = sub_pixel_offset2 * sub_pixel_offset2 * 0.75f;
    
    final_offset = max(final_offset, sub_pixel_offset_final);
    
    float2 final_uv = uv;
    if (is_horiz)
    {
        final_uv.y += final_offset * step_length;
    }
    else
    {
        final_uv.x += final_offset * step_length;
    }
    
    // use the bilinear sampling of the original image to blur and soften the hard edges
    return tex.SampleLevel(smplr, float2(final_uv.x, final_uv.y), 0);
}
```

`shaders/hlsl/anti_aliasing_node_vertex.hlsl`:

```hlsl
struct PSInput
{
    precise float4 position : SV_POSITION;
    precise float2 tex_coord : TEXCOORD;
    precise float4 vertex_position : TEXCOORD1;
    precise float4 frag_position : TEXCOORD2;
    precise float4 view_position : COLOR1;
    precise float4 tangent_view_pos : TEXCOORD4;
    precise float4 tangent_frag_pos : TEXCOORD5;
    precise float4 tangent_light_pos : TEXCOORD6;
    precise float4 frag_pos_light_space : TEXCOORD7;
    precise float4 normal : NORMAL;
    precise float4 view_normal : NORMAL1;
    precise float4 colour : COLOR;
};

PSInput main(
    float4 position : TEXCOORD0,
    float4 normal : TEXCOORD1,
    float4 colour : TEXCOORD2,
    float4 tex_coord : TEXCOORD3,
    float4 tangent : TEXCOORD4,
    float4 bitangent : TEXCOORD5,
    uint4 bone_ids : TEXCOORD6,
    float4 bone_weights : TEXCOORD7,
    uint instance_id : SV_InstanceID)
{
    PSInput result;

    result.position = position;
    result.tex_coord = tex_coord;

    return result;
}

```

`shaders/hlsl/binary_operator_node_chunk.hlsl`:

```hlsl
{% if operator == 0 %}
    ({{value1}} + {{value2}})
{% else if operator == 1 %}
    ({{value1}} - {{value2}})
{% else if operator == 2 %}
    ({{value1}} * {{value2}})
{% else if operator == 3 %}
    ({{value1}} / {{value2}})
{% else if operator == 4 %}
    dot({{value1}}, {{value2}})
{% else if operator == 5 %}
    cross({{value1}}, {{value2}})
{% else if operator == 6 %}
    distance({{value1}}, {{value2}})
{% endif %}
```

`shaders/hlsl/blur_function.hlsl`:

```hlsl
float4 blur(Texture2D tex, float2 tex_coords, SamplerState smpler)
{
    float offset[5] = {0.0, 1.0, 2.0, 3.0, 4.0};
    float weight[5] = {0.2270270270, 0.1945945946, 0.1216216216, 0.0540540541, 0.0162162162};

    float4 colour = tex.Sample(smpler, tex_coords) * weight[0];

    for (int i = 1; i < 5; ++i)
    {
        colour += tex.Sample(smpler, tex_coords + float2(0.0f, offset[i] / 800.0f)) * weight[i];
        colour += tex.Sample(smpler, tex_coords - float2(0.0f, offset[i] / 800.0f)) * weight[i];
    }

    for (int i = 1; i < 5; ++i)
    {
        colour += tex.Sample(smpler, tex_coords + float2(offset[i] / 800.0f, 0.0f)) * weight[i];
        colour += tex.Sample(smpler, tex_coords - float2(offset[i] / 800.0f, 0.0f)) * weight[i];
    }

    return colour;
}
```

`shaders/hlsl/blur_node_chunk.hlsl`:

```hlsl
blur(texture_table[{{texture_index}}], input.tex_coord, sampler_table[{{sampler_index}}])
```

`shaders/hlsl/camera_node_chunk.hlsl`:

```hlsl
{% if type == 0 %}
    camera{{swizzle}}
{% endif %}
```

`shaders/hlsl/colour_adjust_node_fragment.hlsl`:

```hlsl
SamplerState sampler_table[] : register(s0);
Texture2D texture_table[] : register(t0, space1);

struct PSInput
{
    precise float4 position : SV_POSITION;
    precise float2 tex_coord : TEXCOORD;
    precise float4 vertex_position : TEXCOORD1;
    precise float4 frag_position : TEXCOORD2;
    precise float4 view_position : COLOR1;
    precise float4 tangent_view_pos : TEXCOORD4;
    precise float4 tangent_frag_pos : TEXCOORD5;
    precise float4 tangent_light_pos : TEXCOORD6;
    precise float4 frag_pos_light_space : TEXCOORD7;
    precise float4 normal : NORMAL;
    precise float4 view_normal : NORMAL1;
    precise float4 colour : COLOR;
};

float4 main(PSInput input) : SV_TARGET
{
    const float4 fragment_colour = {{ fragment_colour }};
    const float gamma = {{gamma}};

    float3 mapped = fragment_colour.rgb / (fragment_colour.rgb + float3(1.0, 1.0, 1.0));
    mapped = pow(fragment_colour.rgb, float3(gamma, gamma, gamma));

    return float4(mapped.r, mapped.g, mapped.b, fragment_colour.a);
}

```

`shaders/hlsl/colour_adjust_node_vertex.hlsl`:

```hlsl
struct PSInput
{
    precise float4 position : SV_POSITION;
    precise float2 tex_coord : TEXCOORD;
    precise float4 vertex_position : TEXCOORD1;
    precise float4 frag_position : TEXCOORD2;
    precise float4 view_position : COLOR1;
    precise float4 tangent_view_pos : TEXCOORD4;
    precise float4 tangent_frag_pos : TEXCOORD5;
    precise float4 tangent_light_pos : TEXCOORD6;
    precise float4 frag_pos_light_space : TEXCOORD7;
    precise float4 normal : NORMAL;
    precise float4 view_normal : NORMAL1;
    precise float4 colour : COLOR;
};

PSInput main(
    float4 position : TEXCOORD0,
    float4 normal : TEXCOORD1,
    float4 colour : TEXCOORD2,
    float4 tex_coord : TEXCOORD3,
    float4 tangent : TEXCOORD4,
    float4 bitangent : TEXCOORD5,
    uint4 bone_ids : TEXCOORD6,
    float4 bone_weights : TEXCOORD7,
    uint instance_id : SV_InstanceID)
{
    PSInput result;

    result.position = position;
    result.tex_coord = tex_coord;

    return result;
}

```

`shaders/hlsl/colour_node_chunk.hlsl`:

```hlsl
float4({{r}}, {{g}}, {{b}}, {{a}})
```

`shaders/hlsl/combine_node_chunk.hlsl`:

```hlsl
float4({{x}}, {{y}}, {{z}}, {{w}})
```

`shaders/hlsl/component_node_chunk.hlsl`:

```hlsl
{{value}}{{component}}
```

`shaders/hlsl/composite_function.hlsl`:

```hlsl
float4 composite(float4 colour1, float4 colour2, float4 depth1, float4 depth2, float2 tex_coord)
{
    float4 colour = colour2;

    if(depth1.r < depth2.r)
    {
        colour = colour1;
    }

    return colour;
}
```

`shaders/hlsl/composite_node_chunk.hlsl`:

```hlsl
composite({{colour1}}, {{colour2}}, {{depth1}}, {{depth2}}, input.tex_coord)
```

`shaders/hlsl/conditional_node_chunk.hlsl`:

```hlsl
({{input1}} {{operator}} {{input2}} ? {{output1}} : {{output2}})
```

`shaders/hlsl/declare_property_chunk.hlsl`:

```hlsl
cbuffer Properties : register(b6)
{
{% for property in properties %}
    {% if property.1 == 0 %}
    float property_{{property.0}};
    {% endif %}
{% endfor %}
};

```

`shaders/hlsl/declare_variable_chunk.hlsl`:

```hlsl
{% if type == 0 %}
float {{name}} = {{value}};
{% else if type == 1 %}
float3 {{name}} = {{value}};
{% else if type == 2 %}
float4 {{name}} = {{value}};
{% endif %}
```

`shaders/hlsl/fragment_node_chunk.hlsl`:

```hlsl
{% if type == 0 %}
    input.position{{swizzle}}
{% else if type == 1 %}
    input.view_position{{swizzle}}
{% else if type == 2 %}
    input.fragment_position{{swizzle}}
{% else if type == 3 %}
    input.tex_coord{{swizzle}}
{% else if type == 4 %}
    input.normal{{swizzle}}
{% endif %}
```

`shaders/hlsl/invert_function.hlsl`:

```hlsl
float4 invert(float4 colour)
{
    return float4(1.0 - colour.r, 1.0 - colour.g, 1.0 - colour.b, colour.a);
}

```

`shaders/hlsl/invert_node_chunk.hlsl`:

```hlsl
invert({{input}})
```

`shaders/hlsl/lerp_node_chunk.hlsl`:

```hlsl
lerp({{input1}}, {{input2}}, {{lerp_amount}})
```

`shaders/hlsl/property_chunk.hlsl`:

```hlsl
{{name}}
```

`shaders/hlsl/render_node_fragment.hlsl`:

```hlsl
cbuffer BoneData : register(b0)
{
    matrix bones[100];
};

cbuffer Light : register(b1)
{
    matrix light_projection;
    matrix light_view;
    float4 light_colour;
    float4 light_position;
    float4 light_attenuation;
};

cbuffer CameraData : register(b2)
{
    matrix projection;
    matrix view;
    matrix normal_view;
    float4 camera;
};

struct ShadowMapIndex
{
    int index;
};

ConstantBuffer<ShadowMapIndex> shadow_map_index : register(b3);

ConstantBuffer<ShadowMapIndex> shadow_map_sampler_index : register(b4);

struct ModelData
{
    matrix model;
    matrix normal_matrix;
};

struct RenderValues
{
    float time;
};

StructuredBuffer<ModelData> model_data : register(t0);
SamplerState sampler_table[] : register(s0);
Texture2D texture_table[] : register(t0, space1);
TextureCube cube_map_table[] : register(t0, space2);
ConstantBuffer<RenderValues> render_values : register(b5);

{{properties}}

struct PSInput
{
    precise float4 position : SV_POSITION;
    precise float2 tex_coord : TEXCOORD;
    precise float4 vertex_position : TEXCOORD1;
    precise float4 frag_position : TEXCOORD2;
    precise float4 view_position : COLOR1;
    precise float4 tangent_view_pos : TEXCOORD4;
    precise float4 tangent_frag_pos : TEXCOORD5;
    precise float4 tangent_light_pos : TEXCOORD6;
    precise float4 frag_pos_light_space : TEXCOORD7;
    precise float4 normal : NORMAL;
    precise float4 view_normal : NORMAL1;
    precise float4 colour : COLOR;
};

{% if not render_normal and not render_position %}
float4 main(PSInput input) : SV_TARGET
{% else %}
struct PS_OUTPUT
{
    float4 colour: SV_Target0;

    {% if render_normal %}
        float4 normal: SV_Target1;
    {% endif %}

    {% if render_position %}
        float4 position: SV_Target2;
    {% endif %}
};
PS_OUTPUT main(PSInput input)
{% endif %}
{
    {% for variable in variables %}
        {{variable}}
    {% endfor %}

    {% if exists("fragment_colour") %}
        float4 fragment_colour = {{ fragment_colour }};
    {% else %}
        float4 fragment_colour = input.colour;
    {% endif %}

    {% if exists("normal") %}
        float3 normal = {{ normal }}.xyz;
        normal = normalize(normal * 2.0 - 1.0); 
    {% else %}
        float3 normal = normalize(input.normal.xyz);
    {% endif %}

    {% if light_type == 0 %}
        {% if exists("ambient_input") %}
            float4 out_colour = {{ambient_input}};
        {% else %}
            float4 out_colour = light_colour * fragment_colour;
        {% endif %}
    {% endif %}
    {% if light_type == 1 %}
        {% if exists("normal") %}
            float3 light_dir = normalize(-input.tangent_light_pos.xyz);
        {% else %}
            float3 light_dir = normalize(-light_position.xyz);
        {% endif %}

        float shadow = 0.0;
        shadow = calculate_shadow(
            normal,
            input.frag_pos_light_space,
            light_dir,
            texture_table[shadow_map_index.index],
            sampler_table[shadow_map_sampler_index.index]);

        float diff = (1.0 - shadow) * max(dot(normal, light_dir), 0.0);
        float3 diffuse = {diff, diff, diff};

        float3 view_dir = normalize(camera - input.frag_position.xyz);
        float3 reflect_dir = reflect(-light_dir, normal);
        float spec = pow(max(dot(view_dir, reflect_dir), 0.0), 32);
        float spec_strength = 0.5;
        float3 specular = {spec * spec_strength, spec * spec_strength, spec * spec_strength};

        float4 out_colour = float4((diffuse + specular) * light_colour.xyz, 1.0) * fragment_colour;
    {% endif %}
    {% if light_type == 2 %}
        {% if exists("normal") %}
            float3 light_dir = normalize(input.tangent_light_pos.xyz - input.tangent_frag_pos.xyz);
        {% else %}
            float3 light_dir = normalize(light_position.xyz - input.frag_position.xyz);
        {% endif %}
    
        float distance  = length(light_position.xyz - input.frag_position.xyz);
        float constant = light_attenuation.x;
        float linear_term = light_attenuation.y;
        float quadratic = light_attenuation.z;
        float attenuation = 1.0 / (constant + linear_term * distance + quadratic * (distance * distance));    
        float3 att = {attenuation, attenuation, attenuation};
    
        float diff = max(dot(normal, light_dir), 0.0);
        float3 diffuse = {diff, diff, diff};

        float3 view_dir = normalize(camera - input.frag_position.xyz);
        float3 reflect_dir = reflect(-light_dir, normal);
        float spec = pow(max(dot(view_dir, reflect_dir), 0.0), 64);
        float spec_strength = 1.0;
        float3 specular = {spec * spec_strength, spec * spec_strength, spec * spec_strength};
        
        float4 out_colour = float4((diffuse + specular) * light_colour.xyz * att, 1.0) * fragment_colour;
    {% endif %}

    {% if not render_normal and not render_position %}
        return out_colour;
    {% else %}
        PS_OUTPUT output;
        output.colour = out_colour;
    
        {% if render_normal %}
            output.normal = float4(normalize(input.view_normal.xyz), 1.0f);
        {% endif %}
    
        {% if render_position %}
            output.position = input.view_position;
        {% endif %}

        return output;
    {% endif %}
}

```

`shaders/hlsl/render_node_vertex.hlsl`:

```hlsl
cbuffer BoneData : register(b0)
{
    matrix bones[100];
};

cbuffer Light : register(b1)
{
    matrix light_projection;
    matrix light_view;
    float4 light_colour;
    float4 light_position;
    float4 light_attenuation;
};

cbuffer CameraData : register(b2)
{
    matrix projection;
    matrix view;
    matrix normal_view;
    float4 camera;
};

struct ModelData
{
    matrix model;
    matrix normal_matrix;
};

struct RenderValues
{
    float time;
};

StructuredBuffer<ModelData> model_data : register(t0);
ConstantBuffer<RenderValues> render_values : register(b5);

struct PSInput
{
    precise float4 position : SV_POSITION;
    precise float2 tex_coord : TEXCOORD;
    precise float4 vertex_position : TEXCOORD1;
    precise float4 frag_position : TEXCOORD2;
    precise float4 view_position : COLOR1;
    precise float4 tangent_view_pos : TEXCOORD4;
    precise float4 tangent_frag_pos : TEXCOORD5;
    precise float4 tangent_light_pos : TEXCOORD6;
    precise float4 frag_pos_light_space : TEXCOORD7;
    precise float4 normal : NORMAL;
    precise float4 view_normal : NORMAL1;
    precise float4 colour : COLOR;
};

PSInput main(
    float4 position : TEXCOORD0,
    float4 normal : TEXCOORD1,
    float4 colour : TEXCOORD2,
    float4 tex_coord : TEXCOORD3,
    float4 tangent : TEXCOORD4,
    float4 bitangent : TEXCOORD5,
    uint4 bone_ids : TEXCOORD6,
    float4 bone_weights : TEXCOORD7,
    uint instance_id : SV_InstanceID)
{
    {% for variable in variables %}
        {{variable}}
    {% endfor %}

    matrix bone_transform = mul(bones[bone_ids[0]], bone_weights[0]);
    bone_transform += mul(bones[bone_ids[1]], bone_weights[1]);
    bone_transform += mul(bones[bone_ids[2]], bone_weights[2]);
    bone_transform += mul(bones[bone_ids[3]], bone_weights[3]);

    float3 T = normalize(mul(mul(bone_transform, tangent), model_data[instance_id].normal_matrix).xyz);
    float3 B = normalize(mul(mul(bone_transform, bitangent), model_data[instance_id].normal_matrix).xyz);
    float3 N = normalize(mul(mul(bone_transform, normal), model_data[instance_id].normal_matrix).xyz);

    float3x3 tbn = transpose(float3x3(T, B, N));

    PSInput result;

    result.vertex_position = position;
    result.normal = normal;

    {% if exists("position") %}
        result.vertex_position = {{ position }};
    {% endif %}

    {% if exists("normal") %}
        result.normal = {{ normal }};
    {% endif %}

    result.frag_position = mul(result.vertex_position, bone_transform);
    result.frag_position = mul(result.frag_position, model_data[instance_id].model);
    result.view_position = mul(result.frag_position, view);
    result.position = mul(result.view_position, projection);

    result.normal = mul(result.normal, bone_transform);
    result.normal = mul(result.normal, model_data[instance_id].normal_matrix);
    result.view_normal = mul(result.normal, normal_view);
    result.colour = colour;
    result.tex_coord = tex_coord;

    result.tangent_light_pos = float4(mul(light_position.xyz, tbn), 0.0);
    result.tangent_view_pos = float4(mul(camera.xyz, tbn), 0.0);
    result.tangent_frag_pos = float4(mul(result.frag_position, tbn), 0.0);
    
    {% if is_directional_light %}
        result.frag_pos_light_space = mul(result.frag_position, light_view);
        result.frag_pos_light_space = mul(result.frag_pos_light_space, light_projection);
    {% endif %}

    return result;
}

```

`shaders/hlsl/rgb_to_luma_function.hlsl`:

```hlsl
float rgb_to_luma(float3 rgb)
{
    // calculate luminance based on how sensitive the human light is to each channel
    return sqrt(dot(rgb, float3(0.299f, 0.587f, 0.114f)));
}

```

`shaders/hlsl/set_variable_chunk.hlsl`:

```hlsl
{{name}} = {{value}};
```

`shaders/hlsl/shadow_function.hlsl`:

```hlsl
float calculate_shadow(float3 n, float4 frag_pos_light_space, float3 light_dir, Texture2D tex, SamplerState smpler)
{
    float shadow = 0.0;

    float3 proj_coord = frag_pos_light_space.xyz / frag_pos_light_space.w;

    float2 proj_uv = float2(proj_coord.x, -proj_coord.y);
    proj_uv = proj_uv * 0.5 + 0.5;

    float closest_depth = tex.Sample(smpler, proj_uv).r;
    float current_depth = proj_coord.z;
    float bias = 0.001;

    shadow = current_depth - bias > closest_depth ? 1.0 : 0.0;
    if(proj_coord.z > 1.0)
    {
        shadow = 0.0;
    }

    return shadow;
}
```

`shaders/hlsl/sky_box_node_fragment.hlsl`:

```hlsl
SamplerState sampler_table[] : register(s0);
Texture2D texture_table[] : register(t0, space1);
TextureCube cube_map_table[] : register(t0, space2);

struct PSInput
{
    precise float4 position : SV_POSITION;
    precise float2 tex_coord : TEXCOORD;
    precise float4 vertex_position : TEXCOORD1;
    precise float4 frag_position : TEXCOORD2;
    precise float4 view_position : COLOR1;
    precise float4 tangent_view_pos : TEXCOORD4;
    precise float4 tangent_frag_pos : TEXCOORD5;
    precise float4 tangent_light_pos : TEXCOORD6;
    precise float4 frag_pos_light_space : TEXCOORD7;
    precise float4 normal : NORMAL;
    precise float4 view_normal : NORMAL1;
    precise float4 colour : COLOR;
};

float4 main(PSInput input) : SV_TARGET
{
    return cube_map_table[{{cube_map_index}}].SampleLevel(
        sampler_table[{{sampler_index}}], 
        normalize(input.normal.xyz),
        0).rgba;
}

```

`shaders/hlsl/sky_box_node_vertex.hlsl`:

```hlsl
cbuffer CameraData : register(b2)
{
    matrix projection;
    matrix view;
    matrix normal_view;
    float4 camera;
};

struct PSInput
{
    precise float4 position : SV_POSITION;
    precise float2 tex_coord : TEXCOORD;
    precise float4 vertex_position : TEXCOORD1;
    precise float4 frag_position : TEXCOORD2;
    precise float4 view_position : COLOR1;
    precise float4 tangent_view_pos : TEXCOORD4;
    precise float4 tangent_frag_pos : TEXCOORD5;
    precise float4 tangent_light_pos : TEXCOORD6;
    precise float4 frag_pos_light_space : TEXCOORD7;
    precise float4 normal : NORMAL;
    precise float4 view_normal : NORMAL1;
    precise float4 colour : COLOR;
};

PSInput main(
    float4 position : TEXCOORD0,
    float4 normal : TEXCOORD1,
    float4 colour : TEXCOORD2,
    float4 tex_coord : TEXCOORD3,
    float4 tangent : TEXCOORD4,
    float4 bitangent : TEXCOORD5,
    uint4 bone_ids : TEXCOORD6,
    float4 bone_weights : TEXCOORD7)
{
    PSInput result;

    float4x4 adj_view = view;
    adj_view[3][0] = 0.0f;
    adj_view[3][1] = 0.0f;
    adj_view[3][2] = 0.0f;
    adj_view[3][3] = 1.0f;

    result.normal = position;
    result.position = mul(position, adj_view);
    result.position = mul(result.position, projection);
    result.position = result.position.xyww;

    return result;
}

```

`shaders/hlsl/texture_node_chunk.hlsl`:

```hlsl
{% if uv_source == 0 %}
    texture_table[{{texture_index}}].Sample(sampler_table[{{sampler_index}}], input.tex_coord)
{% else if uv_source == 1 %}
    texture_table[{{texture_index}}].Sample(sampler_table[{{sampler_index}}], input.position.xy * float2({{reciprocal_width}}, {{reciprocal_height}}))
{% else if uv_source == 2 %}
    texture_table[{{texture_index}}].Sample(sampler_table[{{sampler_index}}], {{tex_coord}})
{% endif %}

```

`shaders/hlsl/time_node_chunk.hlsl`:

```hlsl
render_values.time
```

`shaders/hlsl/unary_operator_node_chunk.hlsl`:

```hlsl
{% if type == 0 %} 
    -{{value}}
{% else if type == 1 %}
    normalize({{value}})
{% else if type == 2 %}
    sin({{value}})
{% else if type == 3 %}
    cos({{value}})
{% else if type == 4 %}
    sqrt({{value}})
{% endif %}
```

`shaders/hlsl/value_node_colour_chunk.hlsl`:

```hlsl
float4({{r}}, {{g}}, {{b}}, {{a}})
```

`shaders/hlsl/value_node_float_chunk.hlsl`:

```hlsl
{{value}}
```

`shaders/hlsl/value_node_vector3_chunk.hlsl`:

```hlsl
float3({{x}}, {{y}}, {{z}})
```

`shaders/hlsl/variable_node_chunk.hlsl`:

```hlsl
{{name}}
```

`shaders/hlsl/vertex_node_chunk.hlsl`:

```hlsl
{% if type == 0 %}
    position{{swizzle}}
{% else if type == 1 %}
    normal{{swizzle}}
{% else if type == 2 %}
    tex_coord{{swizzle}}
{% endif %}
```

`shaders/msl/CMakeLists.txt`:

```txt
iris_generate_shaders("msl")
```

`shaders/msl/ambient_occlusion_node_fragment.msl`:

```msl
#include <metal_relational>
#include <metal_stdlib>
#include <simd/simd.h>
using namespace metal;

struct VertexOut
{
    float4 position [[position]];
    float4 vertex_position;
    float4 frag_position;
    float3 tangent_view_pos;
    float3 tangent_frag_pos;
    float3 tangent_light_pos;
    float4 frag_pos_light_space;
    float4 normal;
    float4 colour;
    float4 tex;
};

struct BoneData
{
    float4x4 bones[100];
};

struct CameraData
{
    float4x4 projection;
    float4x4 view;
    float4 camera;
};

struct LightData
{
    float4 colour;
    float4 position;
    float4 attenuation;
    float4x4 proj;
    float4x4 view;
};

struct Texture
{
    texture2d<float> texture;
};

struct CubeMap
{
    texturecube<float> cube_map;
};

struct Sampler
{
    sampler smplr;
};

fragment float4 fragment_main(
    VertexOut in [[stage_in]],
    constant CameraData *camera_data [[buffer(0)]],
    constant LightData *light_data [[buffer(1)]],
    device Texture *texture_table [[buffer(2)]],
    device CubeMap *cube_map_table [[buffer(3)]],
    device Sampler* sampler_table [[buffer(4)]],
    constant int &shadow_map_index [[buffer(5)]],
    constant int &shadow_map_sampler_index [[buffer(6)]])
{
    const float4 fragment_colour = {{ fragment_colour }};

    const float3 samples[] = {
        float3(-0.00886638, 0.00229353, 0.0231249), float3(-0.000634795, 0.0456608, 0.0796033),
        float3(0.00276396, 0.038391, 0.051785), float3(0.000758422, 0.0368439, 0.0226108),
        float3(-0.0210339, -0.0251614, 0.00471135), float3(-0.0077157, 0.0156199, 0.0450549),
        float3(-0.0539939, 0.0648841, 0.0591181), float3(0.072815, -0.0666652, 0.00620315),
        float3(-0.00919381, -0.00449068, 0.00473938), float3(-0.104514, -0.0203993, 0.00417302),
        float3(-0.109165, -0.0305201, 0.0141049), float3(0.0424682, 0.0210869, 0.0302346),
        float3(0.0159805, -0.00986693, 1.3074e-05), float3(0.000889632, 0.00126402, 0.0648331),
        float3(-0.0785, -0.0148912, 0.0617556), float3(0.0810225, -0.0301, 0.0296346),
        float3(0.0905632, -0.0689013, 0.0126851), float3(0.0414047, 0.0489806, 0.0333673),
        float3(-0.0111549, -0.0129772, 0.00831587), float3(-0.0327198, 0.023108, 0.0101144),
        float3(-0.0248668, -0.0307488, 0.0313254), float3(-0.00400038, -0.0168738, 0.00877024),
        float3(0.16404, -0.0637624, 0.0455338), float3(0.0734847, 0.0766196, 0.0272843),
        float3(0.0871256, 0.0227383, 0.00885513), float3(0.0191078, -0.00586284, 0.0375503),
        float3(-0.00139819, -0.00164079, 0.00227057), float3(0.137097, -0.105593, 0.0516416),
        float3(-0.0115462, -0.00991795, 0.0116921), float3(0.0147203, -0.0119939, 0.00783621),
        float3(0.0377106, 0.0794236, 0.158526), float3(-0.205867, 0.102649, 0.00129098),
        float3(0.0067215, -0.00561246, 0.00643123), float3(0.0727398, -0.0334538, 0.163939),
        float3(0.0804173, -0.0935365, 0.0692903), float3(0.0519014, 0.276055, 0.172247),
        float3(-0.350498, 0.154156, 0.0152109), float3(-0.0765435, -0.184808, 0.0878499),
        float3(0.0229437, -0.337212, 0.227193), float3(0.245147, -0.0672405, 0.174766),
        float3(-0.269699, 0.218419, 0.277733), float3(-0.0226895, -0.0909222, 0.0906554),
        float3(-0.138153, 0.0324949, 0.400103), float3(0.0382081, -0.107126, 0.103821),
        float3(0.172096, 0.0158331, 0.142202), float3(-0.275107, -0.424418, 0.0449334),
        float3(-0.00638451, 0.235465, 0.212274), float3(0.249825, -0.34683, 0.367554),
        float3(0.310481, 0.225706, 0.38594), float3(0.00561876, 0.0713732, 0.16017),
        float3(-0.0805308, -0.0039723, 0.00282647), float3(-0.0165996, -0.000963676, 0.0139403),
        float3(0.371335, 0.376646, 0.333897), float3(-0.0242451, 0.0228724, 0.0762239),
        float3(0.0868034, 0.0415974, 0.140887), float3(-0.0342928, 0.0116279, 0.0615761),
        float3(0.45093, -0.0762613, 0.16263), float3(-0.0300036, 0.00125506, 0.0126724),
        float3(0.0579732, -0.0307036, 0.0701422), float3(0.474882, 0.536485, 0.364894),
        float3(0.0534704, -0.0184046, 0.0217006), float3(-0.626959, 0.290028, 0.17594),
        float3(0.0670969, -0.0771161, 0.0286401), float3(0.732737, -0.580259, 0.00029956)
    };
    const float3 noise_data[] = {
        float3(-0.595906, -0.156549, 0.0f), float3(-0.631204, -0.049680, 0.0f),
        float3(0.850768, -0.577690, 0.0f), float3(-0.576086, 0.813602, 0.0f),
        float3(0.585386, 0.520160, 0.0f), float3(0.542889, -0.034259, 0.0f),
        float3(-0.338602, -0.899637, 0.0f), float3(0.298322, -0.040603, 0.0f),
        float3(-0.345729, 0.861361, 0.0f), float3(0.729817, -0.604520, 0.0f),
        float3(0.258031, 0.804646, 0.0f), float3(0.487633, -0.194988, 0.0f),
        float3(-0.104914, -0.366919, 0.0f), float3(-0.478404, 0.212103, 0.0f),
        float3(-0.598677, -0.779258, 0.0f), float3(0.837367, 0.120391, 0.0f)
    };

    const float2 size = float2({{width}}.f, {{height}}.f);
    const float2 uv = in.tex.xy;
    const float3 frag_pos = texture_table[{{position_texture_index}}].texture.sample(sampler_table[{{position_sampler_index}}].smplr, uv).xyz;
    const float3 normal = normalize(texture_table[{{normal_texture_index}}].texture.sample(sampler_table[{{normal_sampler_index}}].smplr, uv).rgb);
    const int sample_count = {{sample_count}};
    const float radius = {{radius}};
    const float bias = {{bias}};

    const int x = int(uv.x * size.x) % 4;
    const int y = int(uv.y * size.y) % 4;
    const int index = (y * 4) + x;
    const float3 rand = normalize(noise_data[index]);

    const float3 tangent = normalize(rand - normal * dot(rand, normal));
    const float3 bitangent = cross(normal, tangent);
    const float3x3 tbn = float3x3(tangent, bitangent, normal);

    float occlusion = 0.0;

    for (int i = 0; i < sample_count; ++i)
    {
        float3 sample_pos = tbn * samples[i];
        sample_pos = frag_pos + sample_pos * radius; 

        float4 offset = transpose(camera_data->projection) * float4(sample_pos, 1.0);
        offset.xy /= offset.w;
        offset.x = offset.x * 0.5f + 0.5f;
        offset.y = -offset.y * 0.5f + 0.5f;

        const float sample_depth =
            texture_table[{{position_texture_index}}].texture.sample(sampler_table[{{position_sampler_index}}].smplr, offset.xy).z;

        const float range_check = smoothstep(0.0, 1.0, radius / abs(frag_pos.z - sample_depth));
        occlusion += (sample_depth >= sample_pos.z + bias ? 1.0 : 0.0) * range_check;           
    }

    occlusion = 1.0 - (occlusion / sample_count);
    
    return light_data->colour * fragment_colour * float4(occlusion, occlusion, occlusion, 1.0f);
}
```

`shaders/msl/ambient_occlusion_node_vertex.msl`:

```msl
#include <metal_relational>
#include <metal_stdlib>
#include <simd/simd.h>
using namespace metal;

struct VertexIn
{
    float4 position;
    float4 normal;
    float4 color;
    float4 tex;
    float4 tangent;
    float4 bitangent;
    int4 bone_ids;
    float4 bone_weights;
};

struct VertexOut
{
    float4 position [[position]];
    float4 vertex_position;
    float4 frag_position;
    float3 tangent_view_pos;
    float3 tangent_frag_pos;
    float3 tangent_light_pos;
    float4 frag_pos_light_space;
    float4 normal;
    float4 color;
    float4 tex;
};

struct BoneData
{
    float4x4 bones[100];
};

struct CameraData
{
    float4x4 projection;
    float4x4 view;
    float4 camera;
};

struct LightData
{
    float4 colour;
    float4 position;
    float4 attenuation;
    float4x4 proj;
    float4x4 view;
};

struct ModelData
{
    float4x4 model;
    float4x4 normal_matrix;
};

vertex VertexOut vertex_main(
    device VertexIn *vertices [[buffer(0)]],
    constant BoneData *bone_data [[buffer(1)]],
    constant CameraData *camera_data [[buffer(2)]],
    constant LightData *light_data [[buffer(3)]],
    constant ModelData *model_data [[buffer(4)]],
    uint vid [[vertex_id]],
    uint instance_id [[instance_id]])
{
    VertexOut out;
    out.position = vertices[vid].position;
    out.tex = vertices[vid].tex;

    return out;
}

```

`shaders/msl/anti_aliasing_node_fragment.msl`:

```msl
#include <metal_relational>
#include <metal_stdlib>
#include <simd/simd.h>
using namespace metal;

struct VertexOut
{
    float4 position [[position]];
    float4 vertex_position;
    float4 frag_position;
    float3 tangent_view_pos;
    float3 tangent_frag_pos;
    float3 tangent_light_pos;
    float4 frag_pos_light_space;
    float4 normal;
    float4 colour;
    float4 tex;
};

struct BoneData
{
    float4x4 bones[100];
};

struct CameraData
{
    float4x4 projection;
    float4x4 view;
    float4 camera;
};

struct LightData
{
    float4 colour;
    float4 position;
    float4 attenuation;
    float4x4 proj;
    float4x4 view;
};

struct Texture
{
    texture2d<float> texture;
};

struct CubeMap
{
    texturecube<float> cube_map;
};

struct Sampler
{
    sampler smplr;
};

fragment float4 fragment_main(
    VertexOut in [[stage_in]],
    constant CameraData *camera_data [[buffer(0)]],
    constant LightData *light_data [[buffer(1)]],
    device Texture *texture_table [[buffer(2)]],
    device CubeMap *cube_map_table [[buffer(3)]],
    device Sampler* sampler_table [[buffer(4)]],
    constant int &shadow_map_index [[buffer(5)]],
    constant int &shadow_map_sampler_index [[buffer(6)]])
{
    const float4 fragment_colour = {{ fragment_colour }};

    const int up_offset = -1;
    const int down_offset = 1;
    const int left_offset = -1;
    const int right_offset = 1;

    const float2 uv = in.tex.xy;
    const auto tex = texture_table[{{input_texture_index}}].texture;
    const auto smplr = sampler_table[{{input_sampler_index}}].smplr;
    const float2 inverse_size = float2({{inverse_width}}f, {{inverse_height}}f);

    // get luminance for current sample
    const float3 colour_centre = tex.sample(smplr, uv).rgb;
    const float luma_centre = rgb_to_luma(colour_centre);
    
    // get luminance for surrounding samples
    const float luma_down = rgb_to_luma(tex.sample(smplr, uv, int2(0, down_offset)).rgb);
    const float luma_up = rgb_to_luma(tex.sample(smplr, uv, int2(0, up_offset)).rgb);
    const float luma_left = rgb_to_luma(tex.sample(smplr, uv, int2(left_offset, 0)).rgb);
    const float luma_right = rgb_to_luma(tex.sample(smplr, uv, int2(right_offset, 0)).rgb);
    
    // get min and max luminance
    const float luma_min = min(luma_centre, min(min(luma_down, luma_up), min(luma_left, luma_right)));
    const float luma_max = max(luma_centre, max(max(luma_down, luma_up), max(luma_left, luma_right)));
    
    const float luma_range = luma_max - luma_min;
    
    // filter anything outside of the accepted range
    if (luma_range < max(0.0312f, 0.125f * luma_max))
    {
        return float4(colour_centre, 1.0);
    }
    
    // get corner luminance
    const float luma_down_left = rgb_to_luma(tex.sample(smplr, uv, int2(left_offset, down_offset)).rgb);
    const float luma_up_right = rgb_to_luma(tex.sample(smplr, uv, int2(right_offset, up_offset)).rgb);
    const float luma_up_left = rgb_to_luma(tex.sample(smplr, uv, int2(left_offset, up_offset)).rgb);
    const float luma_down_right = rgb_to_luma(tex.sample(smplr, uv, int2(right_offset, down_offset)).rgb);
    
    const float luma_down_up = luma_down + luma_up;
    const float luma_left_right = luma_left + luma_right;
    
    // get side luminance
    const float luma_left_corners = luma_down_left + luma_up_left;
    const float luma_down_corners = luma_down_left + luma_down_right;
    const float luma_right_corners = luma_down_right + luma_up_right;
    const float luma_up_corners = luma_up_right + luma_up_left;
    
    // calculate string of luminance along the horizontal
    const float edge_h =  abs(-2.0f * luma_left + luma_left_corners) +
                    abs(-2.0f * luma_centre + luma_down_up) * 2.0f +
                    abs(-2.0f * luma_right + luma_right_corners);
    
    // calculate string of luminance along the vertical
    const float edge_v =  abs(-2.0f * luma_up + luma_up_corners) +
                    abs(-2.0f * luma_centre + luma_left_right) * 2.0f +
                    abs(-2.0f * luma_down + luma_down_corners);
    
    // check if current sample lies among a mostly horizontal (or vertical) line
    const bool is_horiz = (edge_h >= edge_v);

    // get directions to test if we are on the positive or negative side of the line
    const float luma_neg = is_horiz ? luma_up : luma_left;
    const float luma_pos = is_horiz ? luma_down : luma_right;
    
    // get the gradient of the luminance in both positive and negative directions
    const float gradient_neg = abs(luma_neg - luma_centre);
    const float gradient_pos = abs(luma_pos - luma_centre);
    
    float step_length = is_horiz ? -inverse_size.y : -inverse_size.x;
    
    // calculate if we are on the negative or positive side of the line and adjust step length if needed
    float luma_local_avg = 0.0f;
    float gradient_scaled = 0.0f;
    if (gradient_neg < gradient_pos)
    {
        luma_local_avg = 0.5f * (luma_pos + luma_centre);
        gradient_scaled = gradient_pos;
        step_length = -step_length;
    }
    else
    {
        luma_local_avg = 0.5f * (luma_neg + luma_centre);
        gradient_scaled = gradient_neg;
    }

    // get blend direction
    float2 current_uv = uv;
    if (is_horiz)
    {
        current_uv.y += step_length * 0.5f;
    }
    else
    {
        current_uv.x += step_length * 0.5f;
    }

    gradient_scaled *= 0.25f;
    
    const float2 offset = is_horiz ? float2(inverse_size.x, 0.0f) : float2(0.0f, inverse_size.y);
    
    float2 uv1 = current_uv - offset;
    float2 uv2 = current_uv + offset;

    float luma_end1 = 0.0f;
    float luma_end2 = 0.0f;

    bool reached1 = false;
    bool reached2 = false;

    // try to find the length of the line by walking both ends of the line until we get a drop in luminance
    // we use increasing step sizes for performance
    for (int i = 0; i < 24; ++i)
    {
        float steps[] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.5f, 2.0f, 2.0f, 2.0f, 2.0f, 4.0f, 8.0f,
                          8.0f, 8.0f, 8.0f, 8.0f, 8.0f, 8.0f, 8.0f, 8.0f, 8.0f, 8.0f, 8.0f, 8.0f };
        if (!reached1)
        {
            luma_end1 = rgb_to_luma(tex.sample(smplr, uv1).rgb) - luma_local_avg;
        }

        if (!reached2)
        {
            luma_end2 = rgb_to_luma(tex.sample(smplr, uv2).rgb) - luma_local_avg;
        }
        
        // check if we have reached the end of either line
        reached1 = reached1 || abs(luma_end1) >= gradient_scaled;
        reached2 = reached2 || abs(luma_end2) >= gradient_scaled;

        if (reached1 && reached2)
        {
            break;
        }

        if (!reached1)
        {
            uv1 -= offset * steps[0];
        }

        if (!reached2)
        {
            uv2 += offset * steps[0];
        }
    }

    
    // get distance we travelled in both directions
    const float distance1 = is_horiz ? (uv.x - uv1.x) : (uv.y - uv1.y);
    const float distance2 = is_horiz ? (uv2.x - uv.x) : (uv2.y - uv.y);
    
    const bool is_direction1 = distance1 < distance2;
    const float distance_final = min(distance1, distance2);
    
    const float edge_thickness = (distance1 + distance2);
    
    const float pixel_offset = -distance_final / edge_thickness + 0.5f;
    
    const bool is_luma_centre_smaller = luma_centre < luma_local_avg;
    const bool correct_variation = ((is_direction1 ? luma_end1 : luma_end2) < 0.0f) != is_luma_centre_smaller;
    float final_offset = correct_variation ? pixel_offset : 0.0f;
    
    // perform subpixel blending
    const float luma_average = (1.0f / 12.0f) * (2.0f * (luma_down_up + luma_left_right) + luma_left_corners + luma_right_corners);
    const float sub_pixel_offset1 = clamp(abs(luma_average - luma_centre) / luma_range, 0.0f, 1.0f);
    const float sub_pixel_offset2 = (-2.0f * sub_pixel_offset1 + 3.0f) * sub_pixel_offset1 * sub_pixel_offset1;
    const float sub_pixel_offset_final = sub_pixel_offset2 * sub_pixel_offset2 * 0.75f;
    
    final_offset = max(final_offset, sub_pixel_offset_final);
    
    float2 final_uv = uv;
    if (is_horiz)
    {
        final_uv.y += final_offset * step_length;
    }
    else
    {
        final_uv.x += final_offset * step_length;
    }
    
    // use the bilinear sampling of the original image to blur and soften the hard edges
    return tex.sample(smplr, float2(final_uv.x, final_uv.y));
}
```

`shaders/msl/anti_aliasing_node_vertex.msl`:

```msl
#include <metal_relational>
#include <metal_stdlib>
#include <simd/simd.h>
using namespace metal;

struct VertexIn
{
    float4 position;
    float4 normal;
    float4 color;
    float4 tex;
    float4 tangent;
    float4 bitangent;
    int4 bone_ids;
    float4 bone_weights;
};

struct VertexOut
{
    float4 position [[position]];
    float4 vertex_position;
    float4 frag_position;
    float3 tangent_view_pos;
    float3 tangent_frag_pos;
    float3 tangent_light_pos;
    float4 frag_pos_light_space;
    float4 normal;
    float4 color;
    float4 tex;
};

struct BoneData
{
    float4x4 bones[100];
};

struct CameraData
{
    float4x4 projection;
    float4x4 view;
    float4 camera;
};

struct LightData
{
    float4 colour;
    float4 position;
    float4 attenuation;
    float4x4 proj;
    float4x4 view;
};

struct ModelData
{
    float4x4 model;
    float4x4 normal_matrix;
};

vertex VertexOut vertex_main(
    device VertexIn *vertices [[buffer(0)]],
    constant BoneData *bone_data [[buffer(1)]],
    constant CameraData *camera_data [[buffer(2)]],
    constant LightData *light_data [[buffer(3)]],
    constant ModelData *model_data [[buffer(4)]],
    uint vid [[vertex_id]],
    uint instance_id [[instance_id]])
{
    VertexOut out;
    out.position = vertices[vid].position;
    out.tex = vertices[vid].tex;

    return out;
}

```

`shaders/msl/binary_operator_node_chunk.msl`:

```msl
{% if operator == 0 %}
    ({{value1}} + {{value2}})
{% else if operator == 1 %}
    ({{value1}} - {{value2}})
{% else if operator == 2 %}
    ({{value1}} * {{value2}})
{% else if operator == 3 %}
    ({{value1}} / {{value2}})
{% else if operator == 4 %}
    dot({{value1}}, {{value2}})
{% else if operator == 5 %}
    cross({{value1}}, {{value2}})
{% else if operator == 6 %}
    distance({{value1}}, {{value2}})
{% endif %}
```

`shaders/msl/blur_function.msl`:

```msl
float4 blur(metal::texture2d<float> tex, float2 tex_coords, metal::sampler smpler)
{
    const float offset[5] = {0.0, 1.0, 2.0, 3.0, 4.0};
    const float weight[5] = {0.2270270270, 0.1945945946, 0.1216216216, 0.0540540541, 0.0162162162};

    float4 colour = tex.sample(smpler, tex_coords) * weight[0];

    for (int i = 1; i < 5; ++i)
    {
        colour += tex.sample(smpler, tex_coords + float2(0.0f, offset[i] / 800.0f)) * weight[i];
        colour += tex.sample(smpler, tex_coords - float2(0.0f, offset[i] / 800.0f)) * weight[i];
    }

    for (int i = 1; i < 5; ++i)
    {
        colour += tex.sample(smpler, tex_coords + float2(offset[i] / 800.0f, 0.0f)) * weight[i];
        colour += tex.sample(smpler, tex_coords - float2(offset[i] / 800.0f, 0.0f)) * weight[i];
    }

    return colour;
}
```

`shaders/msl/blur_node_chunk.msl`:

```msl
blur(texture_table[{{texture_index}}].texture, in.tex.xy, sampler_table[{{sampler_index}}].smplr)
```

`shaders/msl/camera_node_chunk.msl`:

```msl
{% if type == 0 %}
    camera_data->camera{{swizzle}}
{% endif %}
```

`shaders/msl/colour_adjust_node_fragment.msl`:

```msl
#include <metal_relational>
#include <metal_stdlib>
#include <simd/simd.h>
using namespace metal;

struct VertexOut
{
    float4 position [[position]];
    float4 vertex_position;
    float4 frag_position;
    float3 tangent_view_pos;
    float3 tangent_frag_pos;
    float3 tangent_light_pos;
    float4 frag_pos_light_space;
    float4 normal;
    float4 colour;
    float4 tex;
};

struct BoneData
{
    float4x4 bones[100];
};

struct CameraData
{
    float4x4 projection;
    float4x4 view;
    float4 camera;
};

struct LightData
{
    float4 colour;
    float4 position;
    float4 attenuation;
    float4x4 proj;
    float4x4 view;
};

struct Texture
{
    texture2d<float> texture;
};

struct CubeMap
{
    texturecube<float> cube_map;
};

struct Sampler
{
    sampler smplr;
};

fragment float4 fragment_main(
    VertexOut in [[stage_in]],
    constant CameraData *camera_data [[buffer(0)]],
    constant LightData *light_data [[buffer(1)]],
    device Texture *texture_table [[buffer(2)]],
    device CubeMap *cube_map_table [[buffer(3)]],
    device Sampler* sampler_table [[buffer(4)]],
    constant int &shadow_map_index [[buffer(5)]],
    constant int &shadow_map_sampler_index [[buffer(6)]])
{
    const float4 fragment_colour = {{ fragment_colour }};
    const float gamma = {{gamma}};

    float3 mapped = fragment_colour.rgb / (fragment_colour.rgb + float3(1.0, 1.0, 1.0));
    mapped = pow(fragment_colour.rgb, float3(gamma, gamma, gamma));

    return float4(mapped.r, mapped.g, mapped.b, 1.0);
}

```

`shaders/msl/colour_adjust_node_vertex.msl`:

```msl
#include <metal_relational>
#include <metal_stdlib>
#include <simd/simd.h>
using namespace metal;

struct VertexIn
{
    float4 position;
    float4 normal;
    float4 color;
    float4 tex;
    float4 tangent;
    float4 bitangent;
    int4 bone_ids;
    float4 bone_weights;
};

struct VertexOut
{
    float4 position [[position]];
    float4 vertex_position;
    float4 frag_position;
    float3 tangent_view_pos;
    float3 tangent_frag_pos;
    float3 tangent_light_pos;
    float4 frag_pos_light_space;
    float4 normal;
    float4 color;
    float4 tex;
};

struct BoneData
{
    float4x4 bones[100];
};

struct CameraData
{
    float4x4 projection;
    float4x4 view;
    float4 camera;
};

struct LightData
{
    float4 colour;
    float4 position;
    float4 attenuation;
    float4x4 proj;
    float4x4 view;
};

struct ModelData
{
    float4x4 model;
    float4x4 normal_matrix;
};

vertex VertexOut vertex_main(
    device VertexIn *vertices [[buffer(0)]],
    constant BoneData *bone_data [[buffer(1)]],
    constant CameraData *camera_data [[buffer(2)]],
    constant LightData *light_data [[buffer(3)]],
    constant ModelData *model_data [[buffer(4)]],
    uint vid [[vertex_id]],
    uint instance_id [[instance_id]])
{
    VertexOut out;
    out.position = vertices[vid].position;
    out.tex = vertices[vid].tex;

    return out;
}

```

`shaders/msl/colour_node_chunk.msl`:

```msl
float4({{r}}, {{g}}, {{b}}, {{a}})

```

`shaders/msl/combine_node_chunk.msl`:

```msl
float4({{x}}, {{y}}, {{z}}, {{w}})
```

`shaders/msl/component_node_chunk.msl`:

```msl
{{value}}{{component}}
```

`shaders/msl/composite_function.msl`:

```msl
float4 composite(float4 colour1, float4 colour2, float4 depth1, float4 depth2, float2 tex_coord)
{
    float4 colour = colour2;

    if(depth1.r < depth2.r)
    {
        colour = colour1;
    }

    return colour;
}
```

`shaders/msl/composite_node_chunk.msl`:

```msl
composite({{colour1}}, {{colour2}}, {{depth1}}, {{depth2}}, in.tex.xy)
```

`shaders/msl/conditional_node_chunk.msl`:

```msl
({{input1}} {{operator}} {{input2}} ? {{output1}} : {{output2}})
```

`shaders/msl/declare_property_chunk.msl`:

```msl
struct Properties
{
{% for property in properties %}
    {% if property.1 == 0 %}
    float property_{{property.0}};
    {% endif %}
{% endfor %}
};

```

`shaders/msl/declare_variable_chunk.msl`:

```msl
{% if type == 0 %}
float {{name}} = {{value}};
{% else if type == 1 %}
float3 {{name}} = {{value}};
{% else if type == 2 %}
float4 {{name}} = {{value}};
{% endif %}
```

`shaders/msl/fragment_node_chunk.msl`:

```msl
{% if type == 0 %}
    in.position{{swizzle}}
{% else if type == 1 %}
    in.view_position{{swizzle}}
{% else if type == 2 %}
    in.fragment_position{{swizzle}}
{% else if type == 3 %}
    in.tex{{swizzle}}
{% else if type == 4 %}
    in.normal{{swizzle}}
{% endif %}
```

`shaders/msl/invert_function.msl`:

```msl
float4 invert(float4 colour)
{
    return float4(1.0 - colour.r, 1.0 - colour.g, 1.0 - colour.b, colour.a);
}

```

`shaders/msl/invert_node_chunk.msl`:

```msl
invert({{input}})
```

`shaders/msl/lerp_node_chunk.msl`:

```msl
mix({{input1}}, {{input2}}, {{lerp_amount}})
```

`shaders/msl/property_chunk.msl`:

```msl
properties->{{name}}
```

`shaders/msl/render_node_fragment.msl`:

```msl
#include <metal_relational>
#include <metal_stdlib>
#include <simd/simd.h>
using namespace metal;

struct VertexOut
{
    float4 position [[position]];
    float4 vertex_position;
    float4 frag_position;
    float4 view_position;
    float3 tangent_view_pos;
    float3 tangent_frag_pos;
    float3 tangent_light_pos;
    float4 frag_pos_light_space;
    float4 normal;
    float4 view_normal;
    float4 colour;
    float4 tex;
};

struct BoneData
{
    float4x4 bones[100];
};

struct CameraData
{
    float4x4 projection;
    float4x4 view;
    float4x4 normal_view;
    float4 camera;
};

struct LightData
{
    float4 colour;
    float4 position;
    float4 attenuation;
    float4x4 proj;
    float4x4 view;
};

struct Texture
{
    texture2d<float> texture;
};

struct CubeMap
{
    texturecube<float> cube_map;
};

struct Sampler
{
    sampler smplr;
};

struct RenderValues
{
    float time;
};

struct FragmentOutput
{
    float4 colour [[color(0)]];

    {% if render_normal %}
        float4 normal [[color(1)]];
    {% endif %}

    {% if render_position %}
        float4 position [[color(2)]];
    {% endif %}
};

{{properties}}

fragment FragmentOutput fragment_main(
    VertexOut in [[stage_in]],
    constant CameraData *camera_data [[buffer(0)]],
    constant LightData *light_data [[buffer(1)]],
    device Texture *texture_table [[buffer(2)]],
    device CubeMap *cube_map_table [[buffer(3)]],
    device Sampler* sampler_table [[buffer(4)]],
    constant int &shadow_map_index [[buffer(5)]],
    constant int &shadow_map_sampler_index [[buffer(6)]],
    constant Properties *properties [[buffer(7)]],
    constant RenderValues *render_values [[buffer(8)]])
{
    {% for variable in variables %}
        {{variable}}
    {% endfor %}

    {% if exists("fragment_colour") %}
        float4 fragment_colour = {{ fragment_colour }};
    {% else %}
        float4 fragment_colour = in.colour;
    {% endif %}

    {% if exists("normal") %}
        float3 normal = {{ normal }}.xyz;
        normal = normalize(normal * 2.0 - 1.0); 
    {% else %}
        float3 normal = normalize(in.normal.xyz);
    {% endif %}

    {% if light_type == 0 %}
        {% if exists("ambient_input") %}
            float4 out_colour = {{ambient_input}};
        {% else %}
            float4 out_colour = light_data->colour * fragment_colour;
        {% endif %}
    {% endif %}
    {% if light_type == 1 %}
        {% if exists("normal") %}
            float3 light_dir = normalize(-in.tangent_light_pos.xyz);
        {% else %}
            float3 light_dir = normalize(-light_data->position.xyz);
        {% endif %}

        float shadow = 0.0;
        shadow = calculate_shadow(
            normal,
            in.frag_pos_light_space,
            light_dir,
            texture_table[shadow_map_index].texture,
            sampler_table[shadow_map_sampler_index].smplr);

        float diff = (1.0 - shadow) * max(dot(normal, light_dir), 0.0);
        float3 diffuse = {diff, diff, diff};
        float4 out_colour = float4(diffuse * fragment_colour.xyz, 1.0);
    {% endif %}
    {% if light_type == 2 %}
        {% if exists("normal") %}
            float3 light_dir = normalize(in.tangent_light_pos.xyz - in.tangent_frag_pos.xyz);
        {% else %}
            float3 light_dir = normalize(light_data->position.xyz - in.frag_position.xyz);
        {% endif %}
    
        float distance  = length(light_data->position.xyz - in.frag_position.xyz);
        float constant_term = light_data->attenuation.x;
        float linear_term = light_data->attenuation.y;
        float quadratic = light_data->attenuation.z;
        float attenuation = 1.0 / (constant_term + linear_term * distance + quadratic * (distance * distance));    
        float3 att = {attenuation, attenuation, attenuation};
    
        float diff = max(dot(normal, light_dir), 0.0);
        float3 diffuse = {diff, diff, diff};
        
        float4 out_colour = float4(diffuse * light_data->colour.xyz * fragment_colour.xyz * att, 1.0);
    {% endif %}


    FragmentOutput out;
    out.colour = out_colour;

    {% if render_normal %}
        out.normal = float4(normalize(in.view_normal.xyz), 1.0f);
    {% endif %}

    {% if render_position %}
        out.position = in.view_position;
    {% endif %}

    return out;
}

```

`shaders/msl/render_node_vertex.msl`:

```msl
#include <metal_relational>
#include <metal_stdlib>
#include <simd/simd.h>
using namespace metal;

struct VertexIn
{
    float4 position;
    float4 normal;
    float4 colour;
    float4 tex;
    float4 tangent;
    float4 bitangent;
    int4 bone_ids;
    float4 bone_weights;
};

struct VertexOut
{
    float4 position [[position]];
    float4 vertex_position;
    float4 frag_position;
    float4 view_position;
    float3 tangent_view_pos;
    float3 tangent_frag_pos;
    float3 tangent_light_pos;
    float4 frag_pos_light_space;
    float4 normal;
    float4 view_normal;
    float4 colour;
    float4 tex;
};

struct BoneData
{
    float4x4 bones[100];
};

struct CameraData
{
    float4x4 projection;
    float4x4 view;
    float4x4 normal_view;
    float4 camera;
};

struct LightData
{
    float4 colour;
    float4 position;
    float4 attenuation;
    float4x4 proj;
    float4x4 view;
};

struct ModelData
{
    float4x4 model;
    float4x4 normal_matrix;
};

float3x3 calculate_tbn(float4x4 bone_transform, uint vid, device VertexIn *vertices, float4x4 normal_matrix)
{
    float3 T = normalize(float3(normal_matrix * bone_transform * vertices[vid].tangent));
    float3 B = normalize(float3(normal_matrix * bone_transform * vertices[vid].bitangent));
    float3 N = normalize(float3(normal_matrix * bone_transform * vertices[vid].normal));
    return transpose(float3x3(T, B, N));
}

float4x4 calculate_bone_transform(constant BoneData *bone_data, uint vid, device VertexIn *vertices)
{
    float4x4 bone_transform = bone_data->bones[vertices[vid].bone_ids.x] * vertices[vid].bone_weights.x;
    bone_transform += bone_data->bones[vertices[vid].bone_ids.y] * vertices[vid].bone_weights.y;
    bone_transform += bone_data->bones[vertices[vid].bone_ids.z] * vertices[vid].bone_weights.z;
    bone_transform += bone_data->bones[vertices[vid].bone_ids.w] * vertices[vid].bone_weights.w;

    return transpose(bone_transform);
}

vertex VertexOut vertex_main(
    device VertexIn *vertices [[buffer(0)]],
    constant BoneData *bone_data [[buffer(1)]],
    constant CameraData *camera_data [[buffer(2)]],
    constant LightData *light_data [[buffer(3)]],
    constant ModelData *model_data [[buffer(4)]],
    uint vid [[vertex_id]],
    uint instance_id [[instance_id]])
{
    float4x4 bone_transform = calculate_bone_transform(bone_data, vid, vertices);
    float2 uv = vertices[vid].tex.xy;

    VertexOut out;
    out.vertex_position = vertices[vid].position;
    out.frag_position = transpose(model_data[instance_id].model) * bone_transform * out.vertex_position;
    out.view_position = transpose(camera_data->view) * out.frag_position;
    out.position = transpose(camera_data->projection) * out.view_position;
    out.normal = transpose(model_data[instance_id].normal_matrix) * bone_transform * vertices[vid].normal;
    out.view_normal = transpose(camera_data->normal_view) * out.normal;
    out.colour = vertices[vid].colour;
    out.tex = vertices[vid].tex;

    const float3x3 tbn = calculate_tbn(bone_transform, vid, vertices, transpose(model_data[instance_id].normal_matrix));

    out.tangent_light_pos = tbn * light_data->position.xyz;
    out.tangent_view_pos = tbn * camera_data->camera.xyz;
    out.tangent_frag_pos = tbn * out.frag_position.xyz;

    {% if is_directional_light %}
        out.frag_pos_light_space = transpose(light_data->proj) * transpose(light_data->view) * out.frag_position;
    {% endif %}

    return out;
}

```

`shaders/msl/rgb_to_luma_function.msl`:

```msl
float rgb_to_luma(float3 rgb)
{
    // calculate luminance based on how sensitive the human light is to each channel
    return metal::sqrt(metal::dot(rgb, float3(0.299f, 0.587f, 0.114f)));
}

```

`shaders/msl/set_variable_chunk.msl`:

```msl
{{name}} = {{value}};
```

`shaders/msl/shadow_function.msl`:

```msl
float calculate_shadow(float3 n, float4 frag_pos_light_space, float3 light_dir, metal::texture2d<float> texture, metal::sampler smp)
{
    float shadow = 0.0;

    float3 proj_coord = frag_pos_light_space.xyz / frag_pos_light_space.w;

    float2 proj_uv = float2(proj_coord.x, -proj_coord.y);
    proj_uv = proj_uv * 0.5 + 0.5;

    float closest_depth = texture.sample(smp, proj_uv).r;
    float current_depth = proj_coord.z;
    float bias = 0.001;

    shadow = current_depth - bias > closest_depth ? 1.0 : 0.0;
    if(proj_coord.z > 1.0)
    {
        shadow = 0.0;
    }

    return shadow;
}
```

`shaders/msl/sky_box_node_fragment.msl`:

```msl
#include <metal_relational>
#include <metal_stdlib>
#include <simd/simd.h>
using namespace metal;

struct VertexOut
{
    float4 position [[position]];
    float4 vertex_position;
    float4 frag_position;
    float3 tangent_view_pos;
    float3 tangent_frag_pos;
    float3 tangent_light_pos;
    float4 frag_pos_light_space;
    float4 normal;
    float4 colour;
    float4 tex;
};

struct BoneData
{
    float4x4 bones[100];
};

struct CameraData
{
    float4x4 projection;
    float4x4 view;
    float4 camera;
};

struct LightData
{
    float4 colour;
    float4 position;
    float4 attenuation;
    float4x4 proj;
    float4x4 view;
};

struct Texture
{
    texture2d<float> texture;
};

struct CubeMap
{
    texturecube<float> cube_map;
};

struct Sampler
{
    sampler smplr;
};

fragment float4 fragment_main(
    VertexOut in [[stage_in]],
    constant CameraData *camera_data [[buffer(0)]],
    constant LightData *light_data [[buffer(1)]],
    device Texture *texture_table [[buffer(2)]],
    device CubeMap *cube_map_table [[buffer(3)]],
    device Sampler* sampler_table [[buffer(4)]],
    constant int &shadow_map_index [[buffer(5)]],
    constant int &shadow_map_sampler_index [[buffer(6)]])
{
    return cube_map_table[{{cube_map_index}}].cube_map.sample(
        sampler_table[{{sampler_index}}].smplr, 
        float3(in.tex.x, in.tex.y, -in.tex.z));
}

```

`shaders/msl/sky_box_node_vertex.msl`:

```msl
#include <metal_relational>
#include <metal_stdlib>
#include <simd/simd.h>
using namespace metal;

struct VertexIn
{
    float4 position;
    float4 normal;
    float4 color;
    float4 tex;
    float4 tangent;
    float4 bitangent;
    int4 bone_ids;
    float4 bone_weights;
};

struct VertexOut
{
    float4 position [[position]];
    float4 vertex_position;
    float4 frag_position;
    float3 tangent_view_pos;
    float3 tangent_frag_pos;
    float3 tangent_light_pos;
    float4 frag_pos_light_space;
    float4 normal;
    float4 color;
    float4 tex;
};

struct BoneData
{
    float4x4 bones[100];
};

struct CameraData
{
    float4x4 projection;
    float4x4 view;
    float4 camera;
};

struct LightData
{
    float4 colour;
    float4 position;
    float4 attenuation;
    float4x4 proj;
    float4x4 view;
};

struct ModelData
{
    float4x4 model;
    float4x4 normal_matrix;
};

vertex VertexOut vertex_main(
    device VertexIn *vertices [[buffer(0)]],
    constant BoneData *bone_data [[buffer(1)]],
    constant CameraData *camera_data [[buffer(2)]],
    constant LightData *light_data [[buffer(3)]],
    constant ModelData *model_data [[buffer(4)]],
    uint vid [[vertex_id]],
    uint instance_id [[instance_id]])
{
    VertexOut out;

    float4x4 adj_view = transpose(camera_data->view);
    adj_view[3] = 0.0f;
    adj_view[3][3] = 1.0f;
        
    out.tex = vertices[vid].position;
    out.position = float4(transpose(camera_data->projection) * adj_view * out.tex).xyww;

    return out;
}

```

`shaders/msl/texture_node_chunk.msl`:

```msl
{% if uv_source == 0 %}
    texture_table[{{texture_index}}].texture.sample(sampler_table[{{sampler_index}}].smplr, in.tex.xy)
{% else if uv_source == 1 %}
    texture_table[{{texture_index}}].texture.sample(sampler_table[{{sampler_index}}].smplr, in.position.xy * float2({{reciprocal_width}}, {{reciprocal_height}}))
{% else if uv_source == 2 %}
    texture_table[{{texture_index}}].texture.sample(sampler_table[{{sampler_index}}].smplr, {{tex_coord}})
{% endif %}

```

`shaders/msl/time_node_chunk.msl`:

```msl
render_values->time
```

`shaders/msl/unary_operator_node_chunk.msl`:

```msl
{% if type == 0 %} 
    -{{value}}
{% else if type == 1 %}
    normalize({{value}})
{% else if type == 2 %}
    sin({{value}})
{% else if type == 3 %}
    cos({{value}})
{% else if type == 4 %}
    sqrt({{value}})
{% endif %}
```

`shaders/msl/value_node_colour_chunk.msl`:

```msl
float4({{r}}, {{g}}, {{b}}, {{a}})
```

`shaders/msl/value_node_float_chunk.msl`:

```msl
{{value}}
```

`shaders/msl/value_node_vector3_chunk.msl`:

```msl
float3({{x}}, {{y}}, {{z}})
```

`shaders/msl/variable_node_chunk.msl`:

```msl
{{name}}
```

`shaders/msl/vertex_node_chunk.msl`:

```msl
{% if type == 0 %}
    in.vertex_position{{swizzle}}
{% else if type == 1 %}
    in.normal{{swizzle}}
{% else if type == 2 %}
    float3(in.tex.xy, 0.0)
{% endif %}
```

`shaders/shader_include.in`:

```in
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

${SHADER_INCLUDES}

```

`shaders/shader_string.in`:

```in
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

namespace iris::${SHADER_LANGUAGE}
{

static constexpr auto ${SHADER_NAME} = R"(${SHADER_SOURCE})";

}

```

`src/CMakeLists.txt`:

```txt
add_library(iris STATIC "")

add_subdirectory("core")
add_subdirectory("events")
add_subdirectory("graphics")
add_subdirectory("jobs")
add_subdirectory("log")
add_subdirectory("networking")
add_subdirectory("physics")
add_subdirectory("scripting")

add_library(iris::iris ALIAS iris)
generate_export_header(iris)

target_compile_features(iris PUBLIC cxx_std_20)

# hide symbols
set_target_properties(iris PROPERTIES
  CMAKE_CXX_VISIBILITY_PRESET hidden
  CMAKE_VISIBILITY_INLINES_HIDDEN 1)

target_include_directories(
  iris
  PUBLIC $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include/iris>
  $<INSTALL_INTERFACE:include/iris>)

target_include_directories(
  iris SYSTEM
  PRIVATE ${stb_SOURCE_DIR} ${bullet_SOURCE_DIR}/src ${lua_SOURCE_DIR} ${inja_SOURCE_DIR}/include ${inja_SOURCE_DIR}/third_party/include)

target_include_directories(
  iris SYSTEM
  PRIVATE ${PROJECT_BINARY_DIR}/shaders)

# lua does not use cmake, so we build it as a separate library
add_library(lua STATIC ${lua_SOURCE_DIR}/onelua.c)
target_compile_definitions(lua PRIVATE MAKE_LIB)

# configure version file
configure_file(${PROJECT_SOURCE_DIR}/include/iris/iris_version.h.in ${PROJECT_SOURCE_DIR}/include/iris/iris_version.h)

# set macos/ios framework includes
if(IRIS_PLATFORM MATCHES "MACOS")
  target_link_libraries(iris PUBLIC "-framework AppKit -framework CoreFoundation -framework CoreGraphics -framework Metal -framework MetalKit -framework MetalPerformanceShaders -framework QuartzCore")
elseif(IRIS_PLATFORM MATCHES "IOS")
  target_link_libraries(iris PUBLIC "-framework AppKit -framework CoreFoundation -framework UIKit -framework Foundation -framework Metal -framework MetalKit -framework MetalPerformanceShaders -framework QuartzCore")
endif()

# default link options (maybe extended by platform below)
set(IRIS_LINKED_LIBS IrrXML zlibstatic BulletDynamics BulletCollision LinearMath assimp lua)
set(IRIS_LINKED_LIBS_PRIVATE)

# handle platform specific setup including setting default graphics apis
if(IRIS_PLATFORM MATCHES "MACOS")
  target_compile_definitions(iris PUBLIC IRIS_PLATFORM_MACOS)

  if(IRIS_ARCH MATCHES "ARM64")
    target_compile_definitions(iris PUBLIC IRIS_ARCH_ARM64)
  else()
    target_compile_definitions(iris PUBLIC IRIS_ARCH_X86_64)
  endif()

  target_compile_options(iris PRIVATE -Wall -Werror -pedantic -glldb -fobjc-arc)
elseif(IRIS_PLATFORM MATCHES "IOS")
  target_compile_definitions(iris PUBLIC IRIS_PLATFORM_IOS)
  target_compile_definitions(iris PUBLIC IRIS_ARCH_ARM64)
  target_compile_options(iris PRIVATE -Wall -Werror -pedantic -glldb -fobjc-arc)
  set(IRIS_ARCH "ARM64")
elseif(IRIS_PLATFORM MATCHES "WIN32")
  target_compile_definitions(iris PUBLIC IRIS_PLATFORM_WIN32)
  target_compile_definitions(iris PUBLIC IRIS_ARCH_X86_64)
  target_compile_definitions(iris PUBLIC NOMINMAX)

  # on windows SYSTEM includes do not prevent warnings - so we add bullet using
  # the /external flag
  target_compile_options(iris PRIVATE /W4 /WX /experimental:external
    /external:W0 /external:I ${bullet_SOURCE_DIR})
  target_link_options(iris PUBLIC /subsystem:windows /ENTRY:mainCRTStartup)

  list(APPEND IRIS_LINKED_LIBS DirectX-Headers)

  set_target_properties(iris PROPERTIES MSVC_RUNTIME_LIBRARY "MultiThreadedDebug")
  set_target_properties(assimp PROPERTIES MSVC_RUNTIME_LIBRARY "MultiThreadedDebug")
  set_target_properties(inja PROPERTIES MSVC_RUNTIME_LIBRARY "MultiThreadedDebug")
  set_target_properties(LinearMath PROPERTIES MSVC_RUNTIME_LIBRARY "MultiThreadedDebug")
  set_target_properties(BulletDynamics PROPERTIES MSVC_RUNTIME_LIBRARY "MultiThreadedDebug")
  set_target_properties(BulletCollision PROPERTIES MSVC_RUNTIME_LIBRARY "MultiThreadedDebug")
  set_target_properties(IrrXML PROPERTIES MSVC_RUNTIME_LIBRARY "MultiThreadedDebug")
  set_target_properties(zlibstatic PROPERTIES MSVC_RUNTIME_LIBRARY "MultiThreadedDebug")
  set_target_properties(lua PROPERTIES MSVC_RUNTIME_LIBRARY "MultiThreadedDebug")
elseif(IRIS_PLATFORM MATCHES "LINUX")
  target_compile_definitions(iris PUBLIC IRIS_PLATFORM_LINUX)
  target_compile_definitions(iris PUBLIC IRIS_ARCH_X86_64)
  target_compile_options(iris PRIVATE -Wall -Werror)
  target_link_options(iris PUBLIC -rdynamic)

  list(APPEND IRIS_LINKED_LIBS_PRIVATE pthread GL Xfixes X11)
else()
  message(FATAL_ERROR "Unsupported platform")
endif()

# find opengl on supported platforms
if(IRIS_PLATFORM MATCHES "LINUX" OR IRIS_PLATFORM MATCHES "WINDOWS")
  find_package(OpenGL REQUIRED)
  target_include_directories(iris SYSTEM PRIVATE ${OPENGL_INCLUDE_DIR})
endif()

message(STATUS "Building iris-${CMAKE_PROJECT_VERSION} for ${IRIS_PLATFORM})")

target_link_libraries(iris PUBLIC ${IRIS_LINKED_LIBS})
target_link_libraries(iris PRIVATE ${IRIS_LINKED_LIBS_PRIVATE})

# various install commands to ensure all files get put in the right place
install(
  TARGETS iris ${IRIS_LINKED_LIBS}
  EXPORT iris-targets
  ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
  LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
  RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})

install(
  DIRECTORY ${PROJECT_SOURCE_DIR}/include/iris
  DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})

configure_package_config_file(
  ${PROJECT_SOURCE_DIR}/cmake/iris-config.cmake.in
  ${PROJECT_BINARY_DIR}/cmake/iris-config.cmake
  INSTALL_DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/iris)

write_basic_package_version_file(
  iris-version.cmake
  VERSION ${PACKAGE_VERSION}
  COMPATIBILITY AnyNewerVersion)

install(
  EXPORT iris-targets
  FILE iris-targets.cmake
  NAMESPACE iris::
  DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/iris)

install(
  FILES ${PROJECT_BINARY_DIR}/cmake/iris-config.cmake
  ${CMAKE_CURRENT_BINARY_DIR}/iris-version.cmake
  DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/iris)

install(
  FILES ${CMAKE_CURRENT_BINARY_DIR}/iris_export.h
  DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/iris)

export(
  EXPORT iris-targets
  FILE ${PROJECT_BINARY_DIR}/cmake/iris-targets.cmake
  NAMESPACE iris::)

```

`src/core/CMakeLists.txt`:

```txt
set(INCLUDE_ROOT "${PROJECT_SOURCE_DIR}/include/iris/core")

if(IRIS_PLATFORM MATCHES "MACOS")
  add_subdirectory("macos")
elseif(IRIS_PLATFORM MATCHES "IOS")
  add_subdirectory("ios")
elseif(IRIS_PLATFORM MATCHES "WIN32")
  add_subdirectory("win32")
elseif(IRIS_PLATFORM MATCHES "LINUX")
  add_subdirectory("linux")
endif()

target_sources(iris PRIVATE
  ${INCLUDE_ROOT}/auto_release.h
  ${INCLUDE_ROOT}/camera.h
  ${INCLUDE_ROOT}/camera_type.h
  ${INCLUDE_ROOT}/colour.h
  ${INCLUDE_ROOT}/context.h
  ${INCLUDE_ROOT}/data_buffer.h
  ${INCLUDE_ROOT}/default_resource_manager.h
  ${INCLUDE_ROOT}/error_handling.h
  ${INCLUDE_ROOT}/exception.h
  ${INCLUDE_ROOT}/looper.h
  ${INCLUDE_ROOT}/matrix4.h
  ${INCLUDE_ROOT}/object_pool.h
  ${INCLUDE_ROOT}/profiler.h
  ${INCLUDE_ROOT}/profiler_analyser.h
  ${INCLUDE_ROOT}/quaternion.h
  ${INCLUDE_ROOT}/random.h
  ${INCLUDE_ROOT}/resource_manager.h
  ${INCLUDE_ROOT}/start.h
  ${INCLUDE_ROOT}/static_buffer.h
  ${INCLUDE_ROOT}/string_hash.h
  ${INCLUDE_ROOT}/thread.h
  ${INCLUDE_ROOT}/transform.h
  ${INCLUDE_ROOT}/utils.h
  ${INCLUDE_ROOT}/vector3.h
  camera.cpp
  context.cpp
  default_resource_manager.cpp
  exception.cpp
  looper.cpp
  profiler_analyser.cpp
  random.cpp
  resource_manager.cpp
  transform.cpp
  utils.cpp
)

```

`src/core/camera.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "core/camera.h"

#include <cmath>

#include "core/camera_type.h"
#include "core/matrix4.h"
#include "core/quaternion.h"
#include "core/vector3.h"
#include "log/log.h"

namespace
{

/**
 * Helper method to create a direction vector from a pitch and yaw
 *
 * @param pitch
 *   pitch (in radians) of camera
 *
 * @param yaw
 *   yaw (in radians) of camera
 *
 * @returns
 *   A new direction vector for the camera
 */
iris::Vector3 create_direction(float pitch, float yaw)
{
    iris::Vector3 direction;

    direction.x = std::cos(yaw) * std::cos(pitch);
    direction.y = std::sin(pitch);
    direction.z = std::sin(yaw) * std::cos(pitch);

    direction.normalise();

    return direction;
}

}

namespace iris
{

Camera::Camera(CameraType type, std::uint32_t width, std::uint32_t height, std::uint32_t depth)
    : position_(0.0f, 0.0f, 100.0f)
    , direction_(0.0f, 0.0f, -1.0f)
    , up_(0.0f, 1.0f, 0.0f)
    , view_()
    , projection_()
    , pitch_(0.0f)
    , yaw_(-3.141592654f / 2.0f)
    , type_(type)
{
    const auto width_f = static_cast<float>(width);
    const auto height_f = static_cast<float>(height);
    const auto depth_f = static_cast<float>(depth);

    switch (type_)
    {
        case CameraType::PERSPECTIVE:
            projection_ = Matrix4::make_perspective_projection(0.785398f, width_f, height_f, 0.1f, depth_f);
            break;
        case CameraType::ORTHOGRAPHIC:
            projection_ = Matrix4::make_orthographic_projection(width_f, height_f, depth_f);
            break;
    }

    direction_ = create_direction(pitch_, yaw_);
    view_ = Matrix4::make_look_at(position_, position_ + direction_, up_);

    LOG_ENGINE_INFO("camera", "constructed");
}

void Camera::translate(const Vector3 &translate)
{
    position_ += translate;
    view_ = Matrix4::make_look_at(position_, position_ + direction_, up_);
}

void Camera::set_view(const Matrix4 &view)
{
    view_ = view;
}

Vector3 Camera::position() const
{
    return position_;
}

Quaternion Camera::orientation() const
{
    return {yaw_, pitch_, 0.0f};
}

Vector3 Camera::direction() const
{
    return direction_;
}

Vector3 Camera::right() const
{
    return Vector3::normalise(Vector3::cross(direction_, up_));
}

Matrix4 Camera::view() const
{
    return view_;
}

Matrix4 Camera::projection() const
{
    return projection_;
}

float Camera::yaw() const
{
    return yaw_;
}

void Camera::set_yaw(float yaw)
{
    yaw_ = yaw;

    direction_ = create_direction(pitch_, yaw_);
    view_ = Matrix4::make_look_at(position_, position_ + direction_, up_);
}

void Camera::adjust_yaw(float adjust)
{
    set_yaw(yaw_ + adjust);
}

float Camera::pitch() const
{
    return pitch_;
}

void Camera::set_pitch(float pitch)
{
    pitch_ = pitch;

    direction_ = create_direction(pitch_, yaw_);
    view_ = Matrix4::make_look_at(position_, position_ + direction_, up_);
}

void Camera::set_position(const Vector3 &position)
{
    position_ = position;
    view_ = Matrix4::make_look_at(position_, position_ + direction_, up_);
}

void Camera::adjust_pitch(float adjust)
{
    set_pitch(pitch_ + adjust);
}

CameraType Camera::type() const
{
    return type_;
}

}

```

`src/core/context.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "core/context.h"

#include <algorithm>
#include <map>
#include <memory>
#include <string>
#include <vector>

#include "core/error_handling.h"
#include "core/resource_manager.h"
#include "graphics/material_manager.h"
#include "graphics/mesh_manager.h"
#include "graphics/render_target_manager.h"
#include "graphics/texture_manager.h"
#include "graphics/window_manager.h"
#include "jobs/job_system_manager.h"
#include "physics/physics_manager.h"

namespace iris
{

Context::Context(int argc, char **argv)
    : graphics_api_managers_()
    , graphics_api_()
    , physics_api_managers_()
    , physics_api_()
    , jobs_api_managers_()
    , jobs_api_()
    , resource_manager_()
    , args_(argc)
{
    std::transform(argv, argv + argc, std::begin(args_), [](const char *arg) -> std::string { return arg; });
}

Context::~Context()
{
    graphics_api_managers_.clear();
    physics_api_managers_.clear();
    jobs_api_managers_.clear();
}

Context::Context(Context &&) = default;
Context &Context::operator=(Context &&) = default;

const std::vector<std::string> &Context::args() const
{
    return args_;
}
WindowManager &Context::window_manager() const
{
    return *graphics_api_managers_.at(graphics_api_).window_manager;
}

MeshManager &Context::mesh_manager() const
{
    return *graphics_api_managers_.at(graphics_api_).mesh_manager;
}

TextureManager &Context::texture_manager() const
{
    return *graphics_api_managers_.at(graphics_api_).texture_manager;
}

MaterialManager &Context::material_manager() const
{
    return *graphics_api_managers_.at(graphics_api_).material_manager;
}

RenderTargetManager &Context::render_target_manager() const
{
    return *graphics_api_managers_.at(graphics_api_).render_target_manager;
}

PhysicsManager &Context::physics_manager() const
{
    return *physics_api_managers_.at(physics_api_);
}

JobSystemManager &Context::jobs_manager() const
{
    return *jobs_api_managers_.at(jobs_api_);
}

ResourceManager &Context::resource_manager() const
{
    return *resource_manager_;
}

void Context::register_graphics_api(
    const std::string &api,
    std::unique_ptr<WindowManager> window_manager,
    std::unique_ptr<MeshManager> mesh_manager,
    std::unique_ptr<TextureManager> texture_manager,
    std::unique_ptr<MaterialManager> material_manager,
    std::unique_ptr<RenderTargetManager> render_target_manager)
{
    GraphicsApiManagers managers{
        .mesh_manager = std::move(mesh_manager),
        .texture_manager = std::move(texture_manager),
        .material_manager = std::move(material_manager),
        .render_target_manager = std::move(render_target_manager),
        .window_manager = std::move(window_manager)};

    graphics_api_managers_[api] = std::move(managers);
}

std::string Context::graphics_api() const
{
    return graphics_api_;
}

void Context::set_graphics_api(const std::string &api)
{
    ensure(graphics_api_managers_.count(api) != 0u, "api not registered");

    graphics_api_ = api;
}

std::vector<std::string> Context::registered_graphics_apis() const
{
    std::vector<std::string> apis{};

    for (const auto &[api, _] : graphics_api_managers_)
    {
        apis.emplace_back(api);
    }

    return apis;
}

void Context::register_physics_api(const std::string &api, std::unique_ptr<PhysicsManager> physics_manager)
{
    physics_api_managers_[api] = std::move(physics_manager);
}

std::string Context::physics_api() const
{
    return physics_api_;
}

void Context::set_physics_api(const std::string &api)
{
    ensure(physics_api_managers_.count(api) != 0u, "api not registered");

    physics_api_ = api;
}

std::vector<std::string> Context::registered_physics_apis() const
{
    std::vector<std::string> apis{};

    for (const auto &[api, _] : physics_api_managers_)
    {
        apis.emplace_back(api);
    }

    return apis;
}

void Context::register_jobs_api(const std::string &api, std::unique_ptr<JobSystemManager> jobs_manager)
{
    jobs_api_managers_[api] = std::move(jobs_manager);
}

std::string Context::jobs_api() const
{
    return jobs_api_;
}

void Context::set_jobs_api(const std::string &api)
{
    ensure(jobs_api_managers_.count(api) != 0u, "api not registered");

    jobs_api_ = api;

    jobs_manager().create_job_system();
}

std::vector<std::string> Context::registered_jobs_apis() const
{
    std::vector<std::string> apis{};

    for (const auto &[api, _] : jobs_api_managers_)
    {
        apis.emplace_back(api);
    }

    return apis;
}

void Context::set_resource_manager(std::unique_ptr<ResourceManager> resource_manager)
{
    resource_manager_ = std::move(resource_manager);
}

}

```

`src/core/default_resource_manager.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "core/default_resource_manager.h"

#include <filesystem>
#include <fstream>
#include <sstream>
#include <string_view>

#include "core/error_handling.h"

namespace iris
{

DataBuffer DefaultResourceManager::do_load(std::string_view resource)
{
    std::stringstream strm{};
    std::fstream f(root_ / resource, std::ios::in | std::ios::binary);

    strm << f.rdbuf();

    ensure(f.good() && !f.bad(), "failed to read file");

    const auto str = strm.str();
    const auto *str_ptr = reinterpret_cast<const std::byte *>(str.data());

    return {str_ptr, str_ptr + str.length()};
}

}

```

`src/core/exception.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "core/exception.h"

#include <stdexcept>
#include <string>

namespace iris
{

Exception::Exception(const std::string &what)
    : std::runtime_error(what)
{
}

}

```

`src/core/ios/CMakeLists.txt`:

```txt
set(INCLUDE_ROOT "${PROJECT_SOURCE_DIR}/include/iris/core/ios")

target_sources(iris PRIVATE
    ${INCLUDE_ROOT}/ios_resource_manager.h
    ${INCLUDE_ROOT}/utility.h
    ../macos/macos_ios_utility.mm
    ios_resource_manager.mm
    start.mm
)

```

`src/core/ios/ios_resource_manager.mm`:

```mm
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "core/ios_resource_manager.h"

#include <fstream>
#include <sstream>
#include <string_view>

#import <UIKit/UIKit.h>

#include "core/exception.h"
#include "core/macos/macos_ios_utility.h"

namespace iris
{

DataBuffer ResourceManager::load(std::string_view resource)
{
    const auto *bundle = [NSBundle mainBundle];
    if (bundle == nullptr)
    {
        throw Exception("could not get main bundle");
    }

    const auto *dir = [bundle resourcePath];
    if (dir == nullptr)
    {
        throw Exception("could not resolve path to resouce path");
    }

    const auto *resource_ns = core::utility::string_to_nsstring(resource);
    auto *parts = [NSArray arrayWithObjects:dir, resource_ns, (void *)nil];
    const auto *path = [NSString pathWithComponents:parts];
    const auto *cpath = [path fileSystemRepresentation];

    std::stringstream strm{};
    std::fstream f(cpath, std::ios::in | std::ios::binary);
    strm << f.rdbuf();

    const auto str = strm.str();
    const auto *ptr = reinterpret_cast<const std::byte *>(str.data());

    return {ptr, ptr + str.size()};
}

}

```

`src/core/ios/start.mm`:

```mm
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "core/start.h"

#include <functional>

#import <UIKit/UIKit.h>

#import "graphics/ios/app_delegate.h"

#include "core/root.h"
#include "graphics/ios/ios_window_manager.h"
#include "graphics/metal/metal_mesh_manager.h"
#include "graphics/metal/metal_texture_manager.h"
#include "iris_version.h"
#include "jobs/thread/thread_job_system_manager.h"
#include "log/emoji_formatter.h"
#include "log/log.h"
#include "log/logger.h"
#include "physics/bullet/bullet_physics_manager.h"

namespace
{

/**
 * Register apis and set default.s
 */
void register_apis()
{
    iris::Root::register_graphics_api(
        "metal",
        std::make_unique<iris::IOSWindowManager>(),
        std::make_unique<iris::MetalMeshManager>(),
        std::make_unique<iris::MetalTextureManager>());
    iris::Root::set_graphics_api("metal");

    iris::Root::register_physics_api("bullet", std::make_unique<iris::BulletPhysicsManager>());
    iris::Root::set_physics_api("bullet");

    iris::Root::register_jobs_api("thread", std::make_unique<iris::ThreadJobSystemManager>());
    iris::Root::set_jobs_api("thread");
}

}

namespace iris
{

// globals so we can call back into game
// nasty but effective
std::function<void(int, char **)> g_entry;
int g_argc;
char **g_argv;

void start(int argc, char **argv, std::function<void(int, char **)> entry)
{
    // xcode doesn't support ANSI colour codes so we default to the emoji
    // formatter
    Logger::instance().set_Formatter<EmojiFormatter>();

    register_apis();

    LOG_ENGINE_INFO("start", "engine start");

    // save off supplied variables for use later
    g_entry = entry;
    g_argc = argc;
    g_argv = argv;

    @autoreleasepool
    {
        // start the main ios application
        // this is why we have to store the function arguments as globals as
        // we have no way of accessing them in the AppDelegate
        ::UIApplicationMain(argc, argv, nil, ::NSStringFromClass([AppDelegate class]));

        Root::reset();
    }
}

void start_debug(int argc, char **argv, std::function<void(int, char **)> entry)
{
    // enable engine logging
    Logger::instance().set_Formatter<EmojiFormatter>();
    Logger::instance().set_log_engine(true);

    LOG_ENGINE_INFO("start", "engine start (with debugging)");

    register_apis();

    start(argc, argv, entry);
}

}

```

`src/core/linux/CMakeLists.txt`:

```txt
target_sources(iris PRIVATE
    profiler.cpp
    semaphore.cpp
    start.cpp
    static_buffer.cpp
    thread.cpp)

```

`src/core/linux/profiler.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "core/profiler.h"

#include <filesystem>
#include <iostream>
#include <latch>
#include <memory>
#include <regex>
#include <string>
#include <thread>
#include <unordered_map>
#include <vector>

#include <cxxabi.h>
#include <execinfo.h>
#include <signal.h>
#include <unistd.h>

#include "core/auto_release.h"
#include "core/error_handling.h"
#include "core/profiler_analyser.h"
#include "core/thread.h"

namespace
{

// global state, needed as a signal handler is a global function
static constexpr auto stack_frame_size = 100u;
static std::vector<std::byte> proc_info_buffer(1024u * 1024u * 100u);
static const auto max_thread_count = std::thread::hardware_concurrency() * 10u;
static std::vector<void *> stack_traces;
static std::unordered_map<pid_t, std::size_t> index_lookup;
static std::unique_ptr<std::latch> threads_done;

/**
 * Custom signal handler that effectively allows us to suspend a thread.
 */
void signal_handler(int)
{
    // get the index into the global stack trace buffer we can write into, also sanity checks we are expecting to
    // profile this thread
    if (const auto iter = index_lookup.find(::gettid()); iter != std::cend(index_lookup))
    {
        // get stack trace
        const auto index = 100u * iter->second;
        const auto stack_size = ::backtrace(&stack_traces[index], 100u);

        // terminate the stack trace so we can find the end
        if (stack_size != 100u)
        {
            stack_traces[index + stack_size] = nullptr;
        }
    }

    // signal that this thread is done sampling
    threads_done->count_down();
}

}

namespace iris
{

struct Profiler::implementation
{
    Thread worker;
    std::atomic<bool> running;
};

Profiler::Profiler()
    : impl_(std::make_unique<implementation>())
{
    // register custom signal handler
    expect(::signal(SIGUSR1, &signal_handler) != SIG_ERR, "could not set signal handler");

    // reserve space for a stack frame for each thread
    stack_traces = std::vector<void *>(max_thread_count * stack_frame_size, nullptr);
    impl_->running = true;

    // ensure libgcc is initialised, if we don't do this here then the first call to backtrace might try to do the
    // initilisation which involves calls to malloc
    // if this happens from a suspended thread then it could cause a deadlock
    void *buffer = nullptr;
    expect(::backtrace(&buffer, 1u) == 1u, "failed to initialise libgcc");

    // create a new thread for handling the sampling, this thread will be excluded from the sampling
    impl_->worker = Thread([&]() {
        ProfilerAnalyser pa{};

        while (impl_->running)
        {
            std::vector<pid_t> tids{};

            // get all threads for the current process
            for (const auto &dir_entry : std::filesystem::directory_iterator{"/proc/self/task"})
            {
                const auto tid_str = dir_entry.path().filename().string();
                const auto tid = std::stoi(tid_str);
                tids.push_back(tid);
            }

            expect(tids.size() > 1, "found no threads");

            index_lookup.clear();

            // calculate indices for all the threads to write into
            auto index = 0u;
            for (const auto tid : tids)
            {
                index_lookup[tid] = index;
                ++index;
            }

            // we use a latch to know when all paused threads have resumed
            threads_done = std::make_unique<std::latch>(tids.size() - 1u);

            // DANGER ZONE START
            // as we don't know what a thread was doing when we suspended it we have to be careful what we do
            // we cannot allocate memory, most platform/system calls or anything which might involve trying to
            // take a lock that a suspended thread might be holding

            for (const auto tid : tids)
            {
                // skip the thread if it is the current thread, otherwise we will end up suspending ourselves
                if (tid == ::gettid())
                {
                    continue;
                }

                // send custom signal to the thread which will cause it to suspend
                ::syscall(SYS_tkill, tid, SIGUSR1);
            }

            threads_done->wait();

            // DANGER ZONE END

            std::regex symbol_regex{".*\\(([_a-zA-Z0-9]*).*"};

            // now that all threads have resumed we can resolve the symbols for all the stack traces
            for (auto i = 0u; i < stack_traces.size() / 100u; ++i)
            {
                std::vector<std::string> stack_trace{};
                auto index = i * 100u;

                const auto *begin = &stack_traces[index];
                const auto *end = &stack_traces[index + 100u];
                const auto size = std::find(begin, end, nullptr) - begin;

                // resolve stack trace to symbols
                AutoRelease<char **, nullptr> symbols(::backtrace_symbols(begin, size), ::free);

                // try and demangle each symbol
                for (auto i = 0u; i < size; ++i)
                {
                    if (const auto *symbol = symbols[i]; symbol != nullptr)
                    {
                        std::cmatch cmatch{};
                        std::string symbol_str = "unknown";

                        if (std::regex_match(symbol, cmatch, symbol_regex))
                        {
                            if ((cmatch.size() == 2u) && (cmatch[1].length() > 0u))
                            {
                                AutoRelease<char *, nullptr> auto_demangle(
                                    ::abi::__cxa_demangle(cmatch[1].str().c_str(), nullptr, nullptr, nullptr), ::free);
                                ;
                                if (auto_demangle)
                                {
                                    symbol_str = auto_demangle;
                                }
                            }
                        }

                        stack_trace.push_back(symbol_str);
                    }
                    else
                    {
                        break;
                    }
                }

                // record the resolved stack trace
                pa.add_stack_trace(stack_trace);
            }

            std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }

        pa.print();
    });
}

Profiler::~Profiler()
{
    impl_->running = false;
    impl_->worker.join();
}

}

```

`src/core/linux/semaphore.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "core/semaphore.h"

#include <atomic>
#include <cstdint>
#include <memory>

#include <semaphore.h>

#include "core/auto_release.h"
#include "core/error_handling.h"

namespace iris
{

struct Semaphore::implementation
{
    sem_t semaphore;
    AutoRelease<sem_t *, nullptr> auto_semaphore;
    std::atomic<std::ptrdiff_t> count;
};

Semaphore::Semaphore(std::ptrdiff_t initial)
    : impl_(std::make_unique<implementation>())
{
    ensure(::sem_init(&impl_->semaphore, 0, initial) == 0, "could not create semaphore");

    impl_->auto_semaphore = {&impl_->semaphore, ::sem_destroy};
    impl_->count = initial;
}

Semaphore::~Semaphore() = default;
Semaphore::Semaphore(Semaphore &&) = default;
Semaphore &Semaphore::operator=(Semaphore &&) = default;

void Semaphore::release()
{
    ++impl_->count;
    expect(::sem_post(impl_->auto_semaphore) == 0, "coult not release semaphore");
}

void Semaphore::acquire()
{
    expect(::sem_wait(impl_->auto_semaphore) == 0, "could not acquire semaphore");
    --impl_->count;
}

}

```

`src/core/linux/start.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "core/start.h"

#include <memory>

#include "core/context.h"
#include "core/default_resource_manager.h"
#include "core/profiler.h"
#include "graphics/linux/linux_window_manager.h"
#include "graphics/opengl/opengl_material_manager.h"
#include "graphics/opengl/opengl_mesh_manager.h"
#include "graphics/opengl/opengl_render_target_manager.h"
#include "graphics/opengl/opengl_texture_manager.h"
#include "iris_version.h"
#include "jobs/fiber/fiber_job_system_manager.h"
#include "jobs/thread/thread_job_system_manager.h"
#include "log/log.h"
#include "log/logger.h"
#include "physics/bullet/bullet_physics_manager.h"

namespace
{

/**
 * Create the engine context object, with defaults for the current platform.
 *
 * @param argc
 *   Number of command line arguments.
 *
 * @param argv
 *   Array of command line arguments.
 *
 * @returns
 *   Engine conetext object.
 */
iris::Context create_context(int argc, char **argv)
{
    iris::Context ctx{argc, argv};

    auto resource_manager = std::make_unique<iris::DefaultResourceManager>();

    auto opengl_texture_manager = std::make_unique<iris::OpenGLTextureManager>(*resource_manager);
    auto opengl_material_manager = std::make_unique<iris::OpenGLMaterialManager>();
    auto opengl_window_manager =
        std::make_unique<iris::LinuxWindowManager>(*opengl_texture_manager, *opengl_material_manager);
    auto opengl_mesh_manager = std::make_unique<iris::OpenGLMeshManager>(*resource_manager);
    auto opengl_render_target_manager =
        std::make_unique<iris::OpenGLRenderTargetManager>(*opengl_window_manager, *opengl_texture_manager);

    ctx.register_graphics_api(
        "opengl",
        std::move(opengl_window_manager),
        std::move(opengl_mesh_manager),
        std::move(opengl_texture_manager),
        std::move(opengl_material_manager),
        std::move(opengl_render_target_manager));

    ctx.set_graphics_api("d3d12");

    ctx.register_physics_api("bullet", std::make_unique<iris::BulletPhysicsManager>(ctx.mesh_manager()));
    ctx.set_physics_api("bullet");

    ctx.register_jobs_api("thread", std::make_unique<iris::ThreadJobSystemManager>());
    ctx.register_jobs_api("fiber", std::make_unique<iris::FiberJobSystemManager>());
    ctx.set_jobs_api("fiber");

    ctx.set_resource_manager(std::move(resource_manager));

    return ctx;
}

}

namespace iris
{

void start(int argc, char **argv, std::function<void(Context)> entry, bool debug)
{
    std::unique_ptr<Profiler> profiler;

    if (debug)
    {
        profiler = std::make_unique<Profiler>();

        Logger::instance().set_log_engine(true);
        LOG_ENGINE_INFO("start", "debug mode on");
    }

    LOG_ENGINE_INFO("start", "engine start {}", IRIS_VERSION_STR);

    entry(create_context(argc, argv));
}

}

```

`src/core/linux/static_buffer.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "core/static_buffer.h"

#include <cstddef>
#include <cstdint>
#include <memory>
#include <set>

#include <sys/mman.h>
#include <unistd.h>

#include "core/error_handling.h"

namespace iris
{

struct StaticBuffer::implementation
{
    std::byte *allocated_region;
    std::size_t allocated_size;
    std::byte *usable_region;
    std::size_t usable_size;
};

StaticBuffer::StaticBuffer(std::size_t pages)
    : impl_(std::make_unique<implementation>())
{
    // calculate amount of bytes to allocate, including guard pages
    impl_->allocated_size = (pages + 2u) * page_size();

    impl_->allocated_region = static_cast<std::byte *>(
        ::mmap(0, impl_->allocated_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0));

    expect(impl_->allocated_region != MAP_FAILED, "failed to mmap memory");

    // set head guard page
    const auto remove_protection = ::mprotect(impl_->allocated_region, page_size(), PROT_NONE);
    expect(remove_protection != -1, "failed to set head guard page");

    // set tail guard page
    const auto set_protection =
        ::mprotect(impl_->allocated_region + ((pages + 1u) * page_size()), page_size(), PROT_NONE);
    expect(set_protection != -1, "failed to set tail guard page");

    // calculate usable region pointer and size
    impl_->usable_region = impl_->allocated_region + page_size();
    impl_->usable_size = impl_->allocated_size - (2u * page_size());
}

StaticBuffer::~StaticBuffer()
{
    ::munmap(impl_->allocated_region, impl_->allocated_size);
}

std::size_t StaticBuffer::page_size()
{
    return static_cast<std::size_t>(::getpagesize());
}

StaticBuffer::operator std::byte *() const
{
    return impl_->usable_region;
}

std::size_t StaticBuffer::size() const
{
    return impl_->usable_size;
}

}

```

`src/core/linux/thread.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "core/thread.h"

#include <thread>

#include <pthread.h>

#include "core/error_handling.h"

namespace iris
{

Thread::Thread()
    : thread_()
{
}

bool Thread::joinable() const
{
    return thread_.joinable();
}

void Thread::join()
{
    thread_.join();
}

std::thread::id Thread::get_id() const
{
    return thread_.get_id();
}

void Thread::bind_to_core(std::size_t core)
{
    ensure(core < std::thread::hardware_concurrency(), "invalid core id");

    const auto pthread_handle = thread_.native_handle();

    cpu_set_t cpuset;
    CPU_ZERO(&cpuset);
    CPU_SET(core, &cpuset);

    ensure(::pthread_setaffinity_np(pthread_handle, sizeof(cpuset), &cpuset) == 0, "could not set cputset");
}

}

```

`src/core/looper.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "core/looper.h"

#include <chrono>

namespace iris
{

Looper::Looper(
    std::chrono::microseconds clock,
    std::chrono::microseconds timestep,
    LoopFunction fixed_timestep,
    LoopFunction variable_timestep)
    : clock_(clock)
    , timestep_(timestep)
    , fixed_timestep_(fixed_timestep)
    , variable_timestep_(variable_timestep)
{
}

void Looper::run()
{
    auto run = true;
    auto start = std::chrono::steady_clock::now();
    std::chrono::steady_clock::duration accumulator(0);

    do
    {
        // calculate duration of last frame
        const auto end = std::chrono::steady_clock::now();
        const auto frame_time = end - start;
        start = end;

        // variable time step function produces time
        accumulator += frame_time;

        // fixed time step function consumed time
        while (run && (accumulator >= timestep_))
        {
            run &= fixed_timestep_(clock_, timestep_);

            accumulator -= timestep_;
            clock_ += timestep_;
        }

        run &= variable_timestep_(clock_, std::chrono::duration_cast<std::chrono::microseconds>(frame_time));
    } while (run);
}

}

```

`src/core/macos/CMakeLists.txt`:

```txt
set(LINUX_ROOT "${PROJECT_SOURCE_DIR}/src/core/linux")
set(INCLUDE_ROOT "${PROJECT_SOURCE_DIR}/include/iris/core/macos")

target_sources(iris PRIVATE
    ${INCLUDE_ROOT}/macos_ios_utility.h
    ${INCLUDE_ROOT}/utility.h
    ${LINUX_ROOT}/static_buffer.cpp
    macos_ios_utility.mm
    profiler.cpp
    semaphore.cpp
    start.mm
    thread.cpp)

```

`src/core/macos/macos_ios_utility.mm`:

```mm
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "core/macos/macos_ios_utility.h"

#import <Foundation/Foundation.h>
#import <Metal/Metal.h>

namespace iris::core::utility
{

// common utilities

NSString *string_to_nsstring(const std::string &str)
{
    return [NSString stringWithUTF8String:str.c_str()];
}

}

// platform specific implementations

#if defined(IRIS_PLATFORM_MACOS)
#include "core/macos/utility.h"
#elif defined(IRIS_PLATFORM_IOS)
#include "core/ios/utility.h"
#endif

```

`src/core/macos/profiler.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "core/profiler.h"

#include <atomic>
#include <cstddef>
#include <memory>
#include <numeric>
#include <regex>
#include <thread>
#include <vector>

#include <cxxabi.h>
#include <execinfo.h>
#include <mach/mach.h>
#include <mach/mach_traps.h>
#include <mach/task.h>
#include <unistd.h>

#include "core/error_handling.h"
#include "core/profiler_analyser.h"
#include "core/thread.h"

namespace
{

static constexpr auto stack_frame_size = 100u;
static std::vector<std::byte> proc_info_buffer(1024u * 1024u * 100u);
static const auto max_thread_count = std::thread::hardware_concurrency() * 10u;

/**
 * Helper RAII class to suspend thread on construction and resume it on destruction
 */
class AutoSuspendThread
{
  public:
    /**
     * Construct a new AutoSuspendThread.
     *
     * @param thread
     *   Thread to suspend
     */
    AutoSuspendThread(thread_act_t thread)
        : thread_(thread)
        , suspend_result_(::thread_suspend(thread_))
    {
    }

    /**
     * Bool operator to check if thread was suspended.
     *
     * @returns
     *   True if thread was suspended, otherwise false.
     */
    explicit operator bool() const
    {
        return suspend_result_ == KERN_SUCCESS;
    }

    /**
     * Get the result of suspending the thread.
     *
     * @returns
     *   Thread suspend result.
     */
    kern_return_t suspend_result() const
    {
        return suspend_result_;
    }

    /**
     * Resume the thread (if it was suspended).
     */
    ~AutoSuspendThread()
    {
        if (*this)
        {
            ::thread_resume(thread_);
        }
    }

  private:
    /** Handle to thread to suspend/resume. */
    thread_act_t thread_;

    /** Result of suspending the thread. */
    kern_return_t suspend_result_;
};

}

namespace iris
{

struct Profiler::implementation
{
    Thread worker;
    std::atomic<bool> running;
    std::vector<void *> stack_traces;
};

Profiler::Profiler()
    : impl_(std::make_unique<implementation>())
{
    // reserve space for a stack frame for each thread
    impl_->stack_traces.resize(max_thread_count * stack_frame_size);
    impl_->running = true;

    // create a new thread for handling the sampling, this thread will be excluded from the sampling
    impl_->worker = Thread([&]() {
        ProfilerAnalyser pa{};

        while (impl_->running)
        {
            // get current task
            task_t t;
            expect(::task_for_pid(mach_task_self(), ::getpid(), &t) == KERN_SUCCESS, "could not get task");

            // get all threads for task
            thread_act_array_t thread_list;
            mach_msg_type_number_t thread_count = 0u;
            expect(::task_threads(t, &thread_list, &thread_count) == KERN_SUCCESS, "could not get threads");

            const auto loop_limit = std::min(thread_count, max_thread_count);

            for (auto i = 0u; i < loop_limit; ++i)
            {
                const auto thread = thread_list[i];

                // skip the thread if it is the current thread, otherwise we will end up suspending ourselves
                if (thread == mach_thread_self())
                {
                    continue;
                }

                const auto index = i * stack_frame_size;

                impl_->stack_traces[index] = nullptr;

                // suspend the thread
                AutoSuspendThread auto_suspend(thread);

                // DANGER ZONE START
                // as we don't know what a thread was doing when we suspended it we have to be careful what we do
                // we cannot allocate memory, most platform/system calls or anything which might involve trying to
                // take a lock that a suspended thread might be holding

                if (!auto_suspend)
                {
                    continue;
                }

// arch specific structs
#if defined(IRIS_ARCH_ARM64)
                arm_thread_state64_t state;
                mach_msg_type_number_t state_count = ARM_THREAD_STATE64_COUNT;
                const auto flavour = ARM_THREAD_STATE64;
#elif defined(IRIS_ARCH_X86_64)
                x86_thread_state64_t state;
                mach_msg_type_number_t state_count = x86_THREAD_STATE64_COUNT;
                const auto flavour = x86_THREAD_STATE64;
#else
#error unsupported architecture
#endif

                // get the state of the thread
                if (::thread_get_state(thread, flavour, reinterpret_cast<thread_state_t>(&state), &state_count) !=
                    KERN_SUCCESS)
                {
                    continue;
                }

#if defined(IRIS_ARCH_ARM64)
                // get the stack trace
                const auto stack_size = ::backtrace_from_fp(
                    reinterpret_cast<void *>(state.__fp), &impl_->stack_traces[index], stack_frame_size);
#elif defined(IRIS_ARCH_X86_64)
                // get the stack trace
                const auto stack_size = ::backtrace_from_fp(
                    reinterpret_cast<void *>(state.__rbp), &impl_->stack_traces[index], stack_frame_size);
#else
#error unsupported architecture
#endif

                if (stack_size < stack_frame_size)
                {
                    impl_->stack_traces[stack_size] = nullptr;
                }

                // DANGER ZONE END
            }

            // now that all threads have resumed we can resolve the symbols for all the stack traces

            std::regex symbol_regex{"[0-9]+\\s+[^\\s]*\\s+0x[0-9a-fA-f]*\\s([^\\s]+).*"};

            for (auto i = 0u; i < loop_limit; ++i)
            {
                std::vector<std::string> stack_trace{};
                const auto index = i * stack_frame_size;
                const auto begin = std::cbegin(impl_->stack_traces) + index;
                const auto end = std::find(begin, begin + stack_frame_size, nullptr);
                const auto size = std::distance(begin, end);

                // resolve stack trace to symbols
                AutoRelease<char **, nullptr> symbols(::backtrace_symbols(std::addressof(*begin), size), ::free);

                // try and demangle each symbol
                for (auto i = 0u; i < size; ++i)
                {
                    if (const auto *symbol = symbols[i]; symbol != nullptr)
                    {
                        std::cmatch cmatch{};
                        std::string symbol_str = "unknown";

                        if (std::regex_match(symbol, cmatch, symbol_regex))
                        {
                            if ((cmatch.size() == 2u) && (cmatch[1].length() > 0u))
                            {
                                AutoRelease<char *, nullptr> auto_demangle(
                                    ::abi::__cxa_demangle(cmatch[1].str().c_str(), nullptr, nullptr, nullptr), ::free);
                                ;
                                if (auto_demangle)
                                {
                                    symbol_str = auto_demangle;
                                }
                            }
                        }

                        stack_trace.push_back(symbol_str);
                    }
                    else
                    {
                        break;
                    }
                }

                // record the resolved stack trace
                pa.add_stack_trace(stack_trace);
            }

            std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }

        pa.print();
    });
}

Profiler::~Profiler()
{
    impl_->running = false;
    impl_->worker.join();
}
}

```

`src/core/macos/semaphore.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "core/semaphore.h"

#include <cstdint>
#include <memory>

#include <dispatch/dispatch.h>

#include "core/auto_release.h"

namespace iris
{

struct Semaphore::implementation
{
    AutoRelease<::dispatch_semaphore_t, nullptr> semaphore;
    std::atomic<std::ptrdiff_t> count;
};

Semaphore::Semaphore(std::ptrdiff_t initial)
    : impl_(std::make_unique<implementation>())
{
    impl_->semaphore = {::dispatch_semaphore_create(initial), ::dispatch_release};
    impl_->count = initial;
}

Semaphore::~Semaphore() = default;
Semaphore::Semaphore(Semaphore &&) = default;
Semaphore &Semaphore::operator=(Semaphore &&) = default;

void Semaphore::release()
{
    ++impl_->count;
    ::dispatch_semaphore_signal(impl_->semaphore);
}

void Semaphore::acquire()
{
    ::dispatch_semaphore_wait(impl_->semaphore, DISPATCH_TIME_FOREVER);
    --impl_->count;
}

}

```

`src/core/macos/start.mm`:

```mm
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "core/start.h"

#include <memory>

#include "core/context.h"
#include "core/default_resource_manager.h"
#include "core/profiler.h"
#include "graphics/macos/macos_window_manager.h"
#include "graphics/metal/metal_material_manager.h"
#include "graphics/metal/metal_mesh_manager.h"
#include "graphics/metal/metal_render_target_manager.h"
#include "graphics/metal/metal_texture_manager.h"
#include "iris_version.h"
#include "jobs/thread/thread_job_system_manager.h"
#include "log/emoji_formatter.h"
#include "log/log.h"
#include "log/logger.h"
#include "physics/bullet/bullet_physics_manager.h"

#if defined(IRIS_ARCH_X86_64)
#include "jobs/fiber/fiber_job_system_manager.h"
#endif

namespace
{

/**
 * Create the engine context object, with defaults for the current platform.
 *
 * @param argc
 *   Number of command line arguments.
 *
 * @param argv
 *   Array of command line arguments.
 *
 * @returns
 *   Engine conetext object.
 */
iris::Context create_context(int argc, char **argv)
{
    iris::Context ctx{argc, argv};

    auto resource_manager = std::make_unique<iris::DefaultResourceManager>();

    auto metal_texture_manager = std::make_unique<iris::MetalTextureManager>(*resource_manager);
    auto metal_material_manager = std::make_unique<iris::MetalMaterialManager>();
    auto metal_window_manager =
        std::make_unique<iris::MacosWindowManager>(*metal_texture_manager, *metal_material_manager);
    auto metal_mesh_manager = std::make_unique<iris::MetalMeshManager>(*resource_manager);
    auto metal_render_target_manager =
        std::make_unique<iris::MetalRenderTargetManager>(*metal_window_manager, *metal_texture_manager);

    ctx.register_graphics_api(
        "metal",
        std::move(metal_window_manager),
        std::move(metal_mesh_manager),
        std::move(metal_texture_manager),
        std::move(metal_material_manager),
        std::move(metal_render_target_manager));

    ctx.set_graphics_api("metal");

    ctx.register_physics_api("bullet", std::make_unique<iris::BulletPhysicsManager>(ctx.mesh_manager()));
    ctx.set_physics_api("bullet");

#if defined(IRIS_ARCH_X86_64)
    ctx.register_jobs_api("thread", std::make_unique<iris::ThreadJobSystemManager>());
    ctx.register_jobs_api("fiber", std::make_unique<iris::FiberJobSystemManager>());
    ctx.set_jobs_api("fiber");
#else
    ctx.register_jobs_api("thread", std::make_unique<iris::ThreadJobSystemManager>());
    ctx.set_jobs_api("thread");
#endif

    ctx.set_resource_manager(std::move(resource_manager));

    return ctx;
}

}

namespace iris
{

void start(int argc, char **argv, std::function<void(Context)> entry, bool debug)
{
    Logger::instance().set_Formatter<EmojiFormatter>();

    std::unique_ptr<Profiler> profiler;

    if (debug)
    {
        profiler = std::make_unique<Profiler>();

        Logger::instance().set_log_engine(true);
        LOG_ENGINE_INFO("start", "debug mode on");
    }

    LOG_ENGINE_INFO("start", "engine start {}", IRIS_VERSION_STR);

    entry(create_context(argc, argv));
}

}

```

`src/core/macos/thread.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "core/thread.h"

#include <thread>

#include <mach/mach.h>
#include <mach/thread_policy.h>
#include <pthread.h>

#include "core/error_handling.h"

namespace iris
{

Thread::Thread()
    : thread_()
{
}

bool Thread::joinable() const
{
    return thread_.joinable();
}

void Thread::join()
{
    thread_.join();
}

std::thread::id Thread::get_id() const
{
    return thread_.get_id();
}

void Thread::bind_to_core(std::size_t core)
{
    ensure(core < std::thread::hardware_concurrency(), "invalid core id");

    // convert pthread to mach_thread
    thread_affinity_policy_data_t policy = {static_cast<int>(core)};
    const auto mach_thread = pthread_mach_thread_np(thread_.native_handle());

    // set affinity policy, this is merely a suggestion to the kernel
    const auto set_policy =
        ::thread_policy_set(mach_thread, THREAD_AFFINITY_POLICY, reinterpret_cast<thread_policy_t>(&policy), 1);
    expect(set_policy == KERN_SUCCESS, "failed to bind thread to core");
}

}

```

`src/core/profiler_analyser.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "core/profiler_analyser.h"

#include <algorithm>
#include <iostream>
#include <numeric>
#include <stack>
#include <vector>

namespace iris
{

void ProfilerAnalyser::add_stack_trace(const std::vector<std::string> &stack_trace)
{
    Level *cursor = &root_level_;

    // walk back through the stack trace
    for (auto iter = std::crbegin(stack_trace); iter != std::crend(stack_trace); ++iter)
    {
        const auto &function = *iter;

        // see if the current function has already been seen at this level
        auto child =
            std::find_if(std::begin(cursor->children), std::end(cursor->children), [&function](const auto &level) {
                return level.name == function;
            });

        if (child == std::end(cursor->children))
        {
            // if it hasn't then add it
            cursor->children.push_back({.name = function});
            ++cursor->hit_count;
            cursor = std::addressof(cursor->children.back());
        }
        else
        {
            // else then keep searching from the child
            ++cursor->hit_count;
            cursor = std::addressof(*child);
        }
    }
}

void ProfilerAnalyser::print()
{
    const auto total_hits = root_level_.hit_count;
    std::stack<std::tuple<Level *, std::uint32_t>> stack;
    stack.emplace(&root_level_, 0u);

    // depth first walk all the recorded levels
    while (!stack.empty())
    {
        auto [level, indent] = stack.top();
        stack.pop();

        // sort the children so we print most hit first
        std::sort(std::begin(level->children), std::end(level->children), [](const auto &a, const auto &b) {
            return a.hit_count < b.hit_count;
        });

        const auto percentage = static_cast<float>(level->hit_count) / static_cast<float>(total_hits);

        // print out line
        std::cout << "|-" << std::string(indent, '-') << level->name << " (" << level->hit_count << " | "
                  << percentage * 100.0f << ")" << std::endl;

        for (auto &child : level->children)
        {
            stack.emplace(std::addressof(child), indent + 1u);
        }
    }
}

}

```

`src/core/random.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "core/random.h"

#include <random>

namespace
{

// ensure each thread gets its own random_device
thread_local std::random_device device;

/**
 * Helper function to generate a random value with a given distribution.
 *
 * @param distribution
 *   Distribution of random value.
 *
 * @returns
 *   Random value with given distribution.
 */
template <class T>
typename T::result_type generate(T distribution)
{
    std::mt19937 engine(device());
    return distribution(engine);
}

}

namespace iris
{

std::uint32_t random_uint32(std::uint32_t min, std::uint32_t max)
{
    return generate(std::uniform_int_distribution<>(min, max));
}

std::int32_t random_int32(std::int32_t min, std::int32_t max)
{
    return generate(std::uniform_int_distribution<>(min, max));
}

float random_float(float min, float max)
{
    return generate(std::uniform_real_distribution<float>(min, max));
}

bool flip_coin(float bias)
{
    return generate(std::bernoulli_distribution(bias));
}

}

```

`src/core/resource_manager.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "core/resource_manager.h"

#include <filesystem>
#include <fstream>
#include <sstream>

#include "core/error_handling.h"

namespace iris
{

ResourceManager::ResourceManager()
    : root_(".")
{
}

const DataBuffer &ResourceManager::load(std::string_view resource)
{
    // lookup resource
    auto loaded_resource = resources_.find(resource);

    // if not found load from disk, treat resource as a path relative to
    // root
    if (loaded_resource == std::cend(resources_))
    {
        const auto [iter, _] = resources_.insert({std::string{resource}, do_load(resource)});
        loaded_resource = iter;
    }

    return loaded_resource->second;
}

void ResourceManager::set_root_directory(const std::filesystem::path &root)
{
    root_ = root;
}

}

```

`src/core/transform.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "core/transform.h"

#include <cmath>

#include "core/matrix4.h"
#include "core/quaternion.h"
#include "core/vector3.h"

/**
 * Convert a transformation matrix into translation, rotation and scale
 * components.
 *
 * @param matrix
 *   Matrix to decompose.
 *
 * @returns
 *   Tuple of <translation, rotation, scale>
 */
std::tuple<iris::Vector3, iris::Quaternion, iris::Vector3> decompose(iris::Matrix4 matrix)
{
    // extract translation
    const iris::Vector3 translation = matrix.column(3u);

    // extract scale
    const iris::Vector3 scale = {
        matrix.column(0u).magnitude(), matrix.column(1u).magnitude(), matrix.column(2u).magnitude()};

    // convert upper left 3x3 matrix to rotation matrix
    matrix[0] /= scale.x;
    matrix[1] /= scale.y;
    matrix[2] /= scale.z;
    matrix[4] /= scale.x;
    matrix[5] /= scale.y;
    matrix[6] /= scale.z;
    matrix[8] /= scale.x;
    matrix[9] /= scale.y;
    matrix[10] /= scale.z;

    matrix[3] = 0.0f;
    matrix[7] = 0.0f;
    matrix[11] = 0.0f;

    iris::Quaternion rotation{};

    // the following code is cribbed from OgreQuaternion.cpp FromRotatinMatrix
    // commit: e1c3732c51f9099bed10d36805b738015adc8f47
    // which in turn is based on:
    //  Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    //  article "Quaternion Calculus and Fast Animation".

    const auto trace = matrix[0] + matrix[5] + matrix[10];
    float root = 0.0f;

    if (trace > 0.0f)
    {
        root = std::sqrt(trace + 1.0f);
        rotation.w = 0.5f * root;
        root = 0.5f / root;
        rotation.x = (matrix[9] - matrix[6]) * root;
        rotation.y = (matrix[2] - matrix[8]) * root;
        rotation.z = (matrix[4] - matrix[1]) * root;
    }
    else
    {
        static std::size_t next[3] = {1, 2, 0};
        std::size_t i = 0;

        if (matrix[5] > matrix[0])
        {
            i = 1;
        }

        if (matrix[10] > matrix[(i * 4u) + i])
        {
            i = 2;
        }

        const auto j = next[i];
        const auto k = next[j];

        root = std::sqrt(matrix[(i * 4u) + i] - matrix[(j * 4u) + j] - matrix[(k * 4u) + k] + 1.0f);

        float *quat[3] = {&rotation.x, &rotation.y, &rotation.z};

        *quat[i] = 0.5f * root;
        root = 0.5f / root;
        rotation.w = (matrix[(k * 4u) + j] - matrix[(j * 4u) + k]) * root;
        *quat[j] = (matrix[(j * 4u) + i] + matrix[(i * 4u) + j]) * root;
        *quat[k] = (matrix[(k * 4u) + i] + matrix[(i * 4u) + k]) * root;
    }

    return {translation, rotation, scale};
}

namespace iris
{

Transform::Transform()
    : Transform({}, {}, {1.0f})
{
}

Transform::Transform(const Matrix4 &matrix)
    : Transform({0.0f}, {}, {0.0f})
{
    const auto [translation, rotation, scale] = decompose(matrix);

    translation_ = translation;
    rotation_ = rotation;
    scale_ = scale;
}

Transform::Transform(const Vector3 &translation, const Quaternion &rotation, const Vector3 &scale)
    : translation_(translation)
    , rotation_(rotation)
    , scale_(scale)
{
}

Matrix4 Transform::matrix() const
{
    return Matrix4::make_translate(translation_) * Matrix4(rotation_) * Matrix4::make_scale(scale_);
}

void Transform::set_matrix(const Matrix4 &matrix)
{
    const auto [translation, rotation, scale] = decompose(matrix);

    translation_ = translation;
    rotation_ = rotation;
    scale_ = scale;
}

void Transform::interpolate(const Transform &other, float amount)
{
    translation_.lerp(other.translation_, amount);
    rotation_.slerp(other.rotation_, amount);
    scale_.lerp(other.scale_, amount);
}

Vector3 Transform::translation() const
{
    return translation_;
}

void Transform::set_translation(const Vector3 &translation)
{
    translation_ = translation;
}

Quaternion Transform::rotation() const
{
    return rotation_;
}

void Transform::set_rotation(const Quaternion &rotation)
{
    rotation_ = rotation;
}

Vector3 Transform::scale() const
{
    return scale_;
}

void Transform::set_scale(const Vector3 &scale)
{
    scale_ = scale;
}

bool Transform::operator==(const Transform &other) const
{
    return (translation_ == other.translation_) && (rotation_ == other.rotation_) && (scale_ == other.scale_);
}

bool Transform::operator!=(const Transform &other) const
{
    return !(*this == other);
}

Transform Transform::operator*(const Transform &other) const
{
    return Transform{*this} *= other;
}

Transform &Transform::operator*=(const Transform &other)
{
    return *this *= other.matrix();
}

Transform Transform::operator*(const Matrix4 &other) const
{
    return Transform{*this} *= other;
}

Transform &Transform::operator*=(const Matrix4 &other)
{
    auto new_matrix = matrix() * other;

    const auto [translation, rotation, scale] = decompose(new_matrix);

    translation_ = translation;
    rotation_ = rotation;
    scale_ = scale;

    return *this;
}

}

```

`src/core/utils.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "core/utils.h"

#include <algorithm>
#include <cmath>
#include <limits>

namespace iris
{

bool compare(float a, float b)
{
    static constexpr auto epsilon = std::numeric_limits<float>::epsilon();

    const auto diff = std::fabs(a - b);
    a = std::fabs(a);
    b = std::fabs(b);

    // find largest value
    // use an upper of one to prevent our scaled epsilon getting too large
    const auto largest = std::max({1.0f, a, b});

    // compare using a relative epsilon
    return diff <= (largest * epsilon);
}

}

```

`src/core/win32/CMakeLists.txt`:

```txt
target_sources(iris PRIVATE
    profiler.cpp
    semaphore.cpp
    start.cpp
    thread.cpp)

```

`src/core/win32/profiler.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "core/profiler.h"

#include <atomic>
#include <cstddef>
#include <memory>
#include <thread>
#include <vector>

#include "Windows.h"
#include "dbghelp.h"
#include "winternl.h"

#include "core/error_handling.h"
#include "core/profiler_analyser.h"
#include "core/thread.h"

#pragma comment(lib, "DbgHelp.lib")
#pragma comment(lib, "ntdll.lib")

namespace
{

static constexpr auto stack_frame_size = 100u;
static std::vector<std::byte> proc_info_buffer;
static const auto max_thread_count = std::thread::hardware_concurrency() * 10u;

/**
 * Helper RAII class to suspend thread on construction and resume it on destruction
 */
class AutoSuspendThread
{
  public:
    /**
     * Construct a new AutoSuspendThread.
     *
     * @param thread
     *   Thread to suspend
     */
    AutoSuspendThread(HANDLE thread)
        : thread_(thread)
        , suspend_result_(::SuspendThread(thread_))
    {
    }

    /**
     * Get the result of suspending the thread.
     *
     * @returns
     *   Thread suspend result.
     */
    DWORD suspend_result() const
    {
        return suspend_result_;
    }

    /**
     * Resume the thread (if it was suspended).
     */
    ~AutoSuspendThread()
    {
        if (suspend_result_ != -1)
        {
            ::ResumeThread(thread_);
        }
    }

  private:
    /** Handle to thread to suspend/resume. */
    HANDLE thread_;

    /** Result of suspending the thread. */
    DWORD suspend_result_;
};

/**
 * Helper function to get all threads for the current process.
 *
 * @returns
 *   Collection of all thread handles for current process, or an empty optional on failure.
 */
std::optional<std::vector<HANDLE>> threads_for_current_process()
{
    std::optional<std::vector<HANDLE>> handles{};

    ULONG return_length = 0u;

    // get all process information
    if (NT_SUCCESS(::NtQuerySystemInformation(
            SystemProcessInformation,
            proc_info_buffer.data(),
            static_cast<ULONG>(proc_info_buffer.size()),
            &return_length)) == TRUE)
    {
        std::size_t proc_index = 0u;
        std::size_t offset = 0u;

        iris::ensure(return_length <= proc_info_buffer.size(), "buffer too small");

        // walk through the buffer of all process information looking for the one for this process
        do
        {
            proc_index += offset;

            const auto *proc_info = reinterpret_cast<const SYSTEM_PROCESS_INFORMATION *>(&proc_info_buffer[proc_index]);
            const auto pid = reinterpret_cast<HANDLE>(static_cast<std::uint64_t>(::GetCurrentProcessId()));

            // check if the current process is ours
            if (proc_info->UniqueProcessId == pid)
            {
                // thread information comes straight after the process information
                std::size_t thread_index = proc_index + sizeof(SYSTEM_PROCESS_INFORMATION);
                const auto *thread_info_array =
                    reinterpret_cast<const SYSTEM_THREAD_INFORMATION *>(&proc_info_buffer[thread_index]);

                handles = std::vector<HANDLE>();
                handles->reserve(proc_info->NumberOfThreads);

                // copy all thread handles
                for (auto i = 0u; i < proc_info->NumberOfThreads; ++i)
                {
                    const auto &thread_info = thread_info_array[i];

                    iris::expect(thread_info.ClientId.UniqueProcess == pid, "wrong process id");

                    // despite being a HANDLE the UniqueThread field is actually a thread id, so we need to resolve
                    // that back to a handle
                    auto handle = ::OpenThread(
                        THREAD_ALL_ACCESS,
                        FALSE,
                        static_cast<DWORD>(reinterpret_cast<std::ptrdiff_t>(thread_info.ClientId.UniqueThread)));

                    handles->push_back(handle);
                }

                break;
            }

            offset = proc_info->NextEntryOffset;

        } while (offset != 0u);
    }

    return handles;
}

}

namespace iris
{

struct Profiler::implementation
{
    Thread worker;
    std::atomic<bool> running;
    std::vector<DWORD64> stack_traces;
};

Profiler::Profiler()
    : impl_(std::make_unique<implementation>())
{
    proc_info_buffer.resize(1024u * 1024u * 100u);

    // ensure we can resolve symbols
    ensure(::SymInitialize(::GetCurrentProcess(), NULL, TRUE) == TRUE, "failed to init symbol handler");

    // reserve space for a stack frame for each thread
    impl_->stack_traces.resize(max_thread_count * stack_frame_size);
    impl_->running = true;

    // create a new thread for handling the sampling, this thread will be excluded from the sampling
    impl_->worker = Thread(
        [&]()
        {
            ProfilerAnalyser pa{};

            while (impl_->running)
            {
                // get all threads for the current process
                if (const auto &thread_handles = threads_for_current_process(); thread_handles)
                {
                    auto i = 0u;
                    for (const auto &handle : *thread_handles)
                    {
                        // skip the thread if it is the current thread, otherwise we will end up suspending ourselves
                        if (::GetThreadId(handle) == ::GetThreadId(::GetCurrentThread()))
                        {
                            continue;
                        }

                        // suspend the thread
                        AutoSuspendThread auto_suspend(handle);

                        // DANGER ZONE START
                        // as we don't know what a thread was doing when we suspended it we have to be careful what we
                        // do we cannot allocate memory, most platform/system calls or anything which might involve
                        // trying to take a lock that a suspended thread might be holding

                        if (auto_suspend.suspend_result() == -1)
                        {
                            break;
                        }

                        CONTEXT context = {.ContextFlags = CONTEXT_FULL};
                        if (::GetThreadContext(handle, &context) == 0)
                        {
                            break;
                        }

                        // build the STACKFRAME64 object based on the thread context
                        STACKFRAME64 stack_frame = {
                            .AddrPC = {.Offset = context.Rip, .Mode = AddrModeFlat},
                            .AddrFrame = {.Offset = context.Rbp, .Mode = AddrModeFlat},
                            .AddrStack = {.Offset = context.Rsp, .Mode = AddrModeFlat}};

                        // get the stack trace for the thread
                        auto index = i++ * 100u;
                        while (::StackWalk64(
                                   IMAGE_FILE_MACHINE_AMD64,
                                   ::GetCurrentProcess(),
                                   handle,
                                   &stack_frame,
                                   &context,
                                   NULL,
                                   ::SymFunctionTableAccess64,
                                   ::SymGetModuleBase64,
                                   NULL) == TRUE)
                        {
                            impl_->stack_traces[index] = stack_frame.AddrPC.Offset;
                            ++index;

                            if (index == 100u)
                            {
                                break;
                            }
                        }

                        // terminate the stack trace so we can find the end
                        if (index != 100u)
                        {
                            impl_->stack_traces[index] = 0u;
                        }

                        // DANGER ZONE END
                    }
                }

                // now that all threads have resumed we can resolve the symbols for all the stack traces
                for (auto i = 0u; i < max_thread_count; ++i)
                {
                    std::vector<std::string> stack_trace{};
                    auto index = i * 100u;

                    while (impl_->stack_traces[index] != 0u)
                    {
                        char buffer[sizeof(SYMBOL_INFO) + MAX_SYM_NAME];
                        auto *symbol_info = reinterpret_cast<SYMBOL_INFO *>(buffer);
                        symbol_info->SizeOfStruct = sizeof(SYMBOL_INFO);
                        symbol_info->MaxNameLen = MAX_SYM_NAME;
                        DWORD64 displacement = 0u;

                        if (::SymFromAddr(
                                ::GetCurrentProcess(), impl_->stack_traces[index], &displacement, symbol_info) == TRUE)
                        {
                            stack_trace.emplace_back(symbol_info->Name, symbol_info->NameLen);
                        }
                        else
                        {
                            stack_trace.push_back("unknown");
                        }

                        ++index;
                    }

                    // record the resolved stack trace
                    pa.add_stack_trace(stack_trace);
                }

                ::Sleep(10);
            }

            pa.print();
        });
}

Profiler::~Profiler()
{
    impl_->running = false;
    impl_->worker.join();
}
}

```

`src/core/win32/semaphore.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "core/semaphore.h"

#include <atomic>
#include <cstdint>
#include <memory>

#include <windows.h>

#include "core/auto_release.h"
#include "core/error_handling.h"

namespace iris
{

struct Semaphore::implementation
{
    AutoRelease<HANDLE, nullptr> semaphore;
};

Semaphore::Semaphore(std::ptrdiff_t initial)
    : impl_(std::make_unique<implementation>())
{
    impl_->semaphore = {::CreateSemaphoreA(NULL, static_cast<LONG>(initial), 10000u, NULL), ::CloseHandle};

    expect(impl_, "could not create semaphore");
}

Semaphore::~Semaphore() = default;
Semaphore::Semaphore(Semaphore &&) = default;
Semaphore &Semaphore::operator=(Semaphore &&) = default;

void Semaphore::release()
{
    const auto release = ::ReleaseSemaphore(impl_->semaphore, 1, NULL);
    expect(release != 0, "could not release semaphore");
}

void Semaphore::acquire()
{
    const auto wait = ::WaitForSingleObject(impl_->semaphore, INFINITE);
    expect(wait != WAIT_FAILED, "could not acquire semaphore");
}

}

```

`src/core/win32/start.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "core/start.h"

#include <algorithm>
#include <memory>

#include "core/context.h"
#include "core/default_resource_manager.h"
#include "core/error_handling.h"
#include "core/profiler.h"
#include "graphics/d3d12/d3d12_material_manager.h"
#include "graphics/d3d12/d3d12_mesh_manager.h"
#include "graphics/d3d12/d3d12_render_target_manager.h"
#include "graphics/d3d12/d3d12_texture_manager.h"
#include "graphics/opengl/opengl_material_manager.h"
#include "graphics/opengl/opengl_mesh_manager.h"
#include "graphics/opengl/opengl_render_target_manager.h"
#include "graphics/opengl/opengl_texture_manager.h"
#include "graphics/win32/win32_window_manager.h"
#include "iris_version.h"
#include "jobs/fiber/fiber_job_system_manager.h"
#include "jobs/thread/thread_job_system_manager.h"
#include "log/log.h"
#include "log/logger.h"
#include "physics/bullet/bullet_physics_manager.h"

#include <objbase.h>

namespace
{

/**
 * Create the engine context object, with defaults for the current platform.
 *
 * @param argc
 *   Number of command line arguments.
 *
 * @param argv
 *   Array of command line arguments.
 *
 * @returns
 *   Engine conetext object.
 */
iris::Context create_context(int argc, char **argv)
{
    iris::Context ctx{argc, argv};

    auto resource_manager = std::make_unique<iris::DefaultResourceManager>();

    auto d3d12_texture_manager = std::make_unique<iris::D3D12TextureManager>(*resource_manager);
    auto d3d12_material_manager = std::make_unique<iris::D3D12MaterialManager>();
    auto d3d12_window_manager =
        std::make_unique<iris::Win32WindowManager>(*d3d12_texture_manager, *d3d12_material_manager, "d3d12");
    auto d3d12_mesh_manager = std::make_unique<iris::D3D12MeshManager>(*resource_manager);
    auto d3d12_render_target_manager =
        std::make_unique<iris::D3D12RenderTargetManager>(*d3d12_window_manager, *d3d12_texture_manager);

    ctx.register_graphics_api(
        "d3d12",
        std::move(d3d12_window_manager),
        std::move(d3d12_mesh_manager),
        std::move(d3d12_texture_manager),
        std::move(d3d12_material_manager),
        std::move(d3d12_render_target_manager));

    auto opengl_texture_manager = std::make_unique<iris::OpenGLTextureManager>(*resource_manager);
    auto opengl_material_manager = std::make_unique<iris::OpenGLMaterialManager>();
    auto opengl_window_manager =
        std::make_unique<iris::Win32WindowManager>(*opengl_texture_manager, *opengl_material_manager, "opengl");
    auto opengl_mesh_manager = std::make_unique<iris::OpenGLMeshManager>(*resource_manager);
    auto opengl_render_target_manager =
        std::make_unique<iris::OpenGLRenderTargetManager>(*opengl_window_manager, *opengl_texture_manager);

    ctx.register_graphics_api(
        "opengl",
        std::move(opengl_window_manager),
        std::move(opengl_mesh_manager),
        std::move(opengl_texture_manager),
        std::move(opengl_material_manager),
        std::move(opengl_render_target_manager));

    ctx.set_graphics_api("d3d12");

    ctx.register_physics_api("bullet", std::make_unique<iris::BulletPhysicsManager>(ctx.mesh_manager()));
    ctx.set_physics_api("bullet");

    ctx.register_jobs_api("thread", std::make_unique<iris::ThreadJobSystemManager>());
    ctx.register_jobs_api("fiber", std::make_unique<iris::FiberJobSystemManager>());
    ctx.set_jobs_api("fiber");

    ctx.set_resource_manager(std::move(resource_manager));

    return ctx;
}

}

namespace iris
{

void start(int argc, char **argv, std::function<void(Context)> entry, bool debug)
{
    std::unique_ptr<Profiler> profiler;

    if (debug)
    {
        profiler = std::make_unique<Profiler>();

        Logger::instance().set_log_engine(true);
        LOG_ENGINE_INFO("start", "debug mode on");
    }

    LOG_ENGINE_INFO("start", "engine start {}", IRIS_VERSION_STR);

    ensure(::CoInitializeEx(nullptr, COINIT_MULTITHREADED) == S_OK, "CoInitialize failed");

    entry(create_context(argc, argv));
}

}

```

`src/core/win32/thread.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "core/thread.h"

#include <thread>

#include <Windows.h>

#include "core/error_handling.h"

namespace iris
{

Thread::Thread()
    : thread_()
{
}

bool Thread::joinable() const
{
    return thread_.joinable();
}

void Thread::join()
{
    thread_.join();
}

std::thread::id Thread::get_id() const
{
    return thread_.get_id();
}

void Thread::bind_to_core(std::size_t core)
{
    DWORD affinity_mask = (1u << core);

    expect(::SetThreadAffinityMask(thread_.native_handle(), affinity_mask) != 0u, "could not bind thread to core");
}

}

```

`src/events/CMakeLists.txt`:

```txt
set(INCLUDE_ROOT "${PROJECT_SOURCE_DIR}/include/iris/events")

target_sources(iris PRIVATE
    ${INCLUDE_ROOT}/event.h
    ${INCLUDE_ROOT}/event_type.h
    ${INCLUDE_ROOT}/keyboard_event.h
    ${INCLUDE_ROOT}/mouse_event.h
    ${INCLUDE_ROOT}/quit_event.h
    ${INCLUDE_ROOT}/scroll_wheel_event.h
    ${INCLUDE_ROOT}/touch_event.h
    event.cpp)

```

`src/events/event.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "events/event.h"

#include "core/error_handling.h"
#include "events/event_type.h"
#include "events/keyboard_event.h"
#include "events/mouse_button_event.h"
#include "events/mouse_event.h"
#include "events/quit_event.h"
#include "events/scroll_wheel_event.h"
#include "events/touch_event.h"

namespace iris
{

Event::Event(QuitEvent event)
    : type_(EventType::QUIT)
    , event_(event)
{
}

Event::Event(const KeyboardEvent event)
    : type_(EventType::KEYBOARD)
    , event_(event)
{
}

Event::Event(const MouseEvent event)
    : type_(EventType::MOUSE)
    , event_(event)
{
}

Event::Event(MouseButtonEvent event)
    : type_(EventType::MOUSE_BUTTON)
    , event_(event)
{
}

Event::Event(TouchEvent event)
    : type_(EventType::TOUCH)
    , event_(event)
{
}

Event::Event(ScrollWheelEvent event)
    : type_(EventType::SCROLL_WHEEL)
    , event_(event)
{
}

EventType Event::type() const
{
    return type_;
}

bool Event::is_quit() const
{
    return std::holds_alternative<QuitEvent>(event_);
}

bool Event::is_key() const
{
    return std::holds_alternative<KeyboardEvent>(event_);
}

bool Event::is_key(Key key) const
{
    auto match = false;

    if (auto val = std::get_if<KeyboardEvent>(&event_); val)
    {
        match = val->key == key;
    }

    return match;
}

bool Event::is_key(Key key, KeyState state) const
{
    auto match = false;

    if (auto val = std::get_if<KeyboardEvent>(&event_); val)
    {
        match = (val->key) == key && (val->state == state);
    }

    return match;
}

KeyboardEvent Event::key() const
{
    expect(is_key(), "not keyboard event");

    return std::get<KeyboardEvent>(event_);
}

bool Event::is_mouse() const
{
    return std::holds_alternative<MouseEvent>(event_);
}

MouseEvent Event::mouse() const
{
    expect(is_mouse(), "not mouse event");

    return std::get<MouseEvent>(event_);
}

bool Event::is_mouse_button() const
{
    return std::holds_alternative<MouseButtonEvent>(event_);
}

bool Event::is_mouse_button(MouseButton button) const
{
    auto match = false;

    if (auto val = std::get_if<MouseButtonEvent>(&event_); val)
    {
        match = val->button == button;
    }

    return match;
}

bool Event::is_mouse_button(MouseButton button, MouseButtonState state) const
{
    auto match = false;

    if (auto val = std::get_if<MouseButtonEvent>(&event_); val)
    {
        match = (val->button == button) && (val->state == state);
    }

    return match;
}

MouseButtonEvent Event::mouse_button() const
{
    expect(is_mouse_button(), "not mouse button event");

    return std::get<MouseButtonEvent>(event_);
}

bool Event::is_touch() const
{
    return std::holds_alternative<TouchEvent>(event_);
}

TouchEvent Event::touch() const
{
    expect(is_touch(), "not touch event");

    return std::get<TouchEvent>(event_);
}

bool Event::is_scroll_wheel() const
{
    return std::holds_alternative<ScrollWheelEvent>(event_);
}

ScrollWheelEvent Event::scroll_wheel() const
{
    return std::get<ScrollWheelEvent>(event_);
}

}

```

`src/graphics/CMakeLists.txt`:

```txt
set(INCLUDE_ROOT "${PROJECT_SOURCE_DIR}/include/iris/graphics")

if(IRIS_PLATFORM MATCHES "MACOS")
  add_subdirectory("macos")
  add_subdirectory("metal")
elseif(IRIS_PLATFORM MATCHES "IOS")
  add_subdirectory("ios")
  add_subdirectory("metal")
elseif(IRIS_PLATFORM MATCHES "WIN32")
  add_subdirectory("win32")
  add_subdirectory("opengl")
  add_subdirectory("d3d12")
elseif(IRIS_PLATFORM MATCHES "LINUX")
  add_subdirectory("linux")
  add_subdirectory("opengl")
endif()

add_subdirectory("animation")
add_subdirectory("lights")
add_subdirectory("render_graph")

target_sources(iris PRIVATE
  ${INCLUDE_ROOT}/bone.h
  ${INCLUDE_ROOT}/cube_map.h
  ${INCLUDE_ROOT}/default_shader_languages.h
  ${INCLUDE_ROOT}/instanced_entity.h
  ${INCLUDE_ROOT}/keyframe.h
  ${INCLUDE_ROOT}/material.h
  ${INCLUDE_ROOT}/material_cache.h
  ${INCLUDE_ROOT}/material_manager.h
  ${INCLUDE_ROOT}/mesh.h
  ${INCLUDE_ROOT}/mesh_loader.h
  ${INCLUDE_ROOT}/mesh_manager.h
  ${INCLUDE_ROOT}/post_processing_description.h
  ${INCLUDE_ROOT}/primitive_type.h
  ${INCLUDE_ROOT}/render_command.h
  ${INCLUDE_ROOT}/render_command_type.h
  ${INCLUDE_ROOT}/render_entity.h
  ${INCLUDE_ROOT}/render_entity_type.h
  ${INCLUDE_ROOT}/render_pass.h
  ${INCLUDE_ROOT}/render_pipeline.h
  ${INCLUDE_ROOT}/render_target.h
  ${INCLUDE_ROOT}/render_target_manager.h
  ${INCLUDE_ROOT}/renderer.h
  ${INCLUDE_ROOT}/sampler.h
  ${INCLUDE_ROOT}/scene.h
  ${INCLUDE_ROOT}/single_entity.h
  ${INCLUDE_ROOT}/skeleton.h
  ${INCLUDE_ROOT}/text_factory.h
  ${INCLUDE_ROOT}/texture.h
  ${INCLUDE_ROOT}/texture_manager.h
  ${INCLUDE_ROOT}/texture_usage.h
  ${INCLUDE_ROOT}/utils.h
  ${INCLUDE_ROOT}/vertex_attributes.h
  ${INCLUDE_ROOT}/vertex_data.h
  ${INCLUDE_ROOT}/weight.h
  ${INCLUDE_ROOT}/window.h
  ${INCLUDE_ROOT}/window_manager.h
  bone.cpp
  cube_map.cpp
  instanced_entity.cpp
  material.cpp
  material_manager.cpp
  mesh.cpp
  mesh_loader.cpp
  mesh_manager.cpp
  render_command.cpp
  render_entity.cpp
  render_pipeline.cpp
  render_target.cpp
  renderer.cpp
  sampler.cpp
  scene.cpp
  single_entity.cpp
  skeleton.cpp
  texture.cpp
  texture_manager.cpp
  utils.cpp
  vertex_attributes.cpp
  window.cpp
)

```

`src/graphics/animation/CMakeLists.txt`:

```txt
set(INCLUDE_ROOT "${PROJECT_SOURCE_DIR}/include/iris/graphics/animation")

target_sources(iris PRIVATE
    ${INCLUDE_ROOT}/animation.h
    ${INCLUDE_ROOT}/animation_controller.h
    ${INCLUDE_ROOT}/animation_layer.h
    ${INCLUDE_ROOT}/animation_state.h
    ${INCLUDE_ROOT}/animation_transition.h
    ${INCLUDE_ROOT}/bone_query.h
    ${INCLUDE_ROOT}/cached_bone_query.h
    ${INCLUDE_ROOT}/utils.h
    animation.cpp
    animation_controller.cpp
    animation_state.cpp
    cached_bone_query.cpp
    utils.cpp)

```

`src/graphics/animation/animation.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/animation/animation.h"

#include <map>
#include <string>
#include <string_view>
#include <tuple>

#include "core/error_handling.h"
#include "core/matrix4.h"
#include "core/quaternion.h"
#include "core/vector3.h"
#include "log/log.h"

using namespace std::chrono_literals;

namespace iris
{

Animation::Animation(
    std::chrono::milliseconds duration,
    const std::string &name,
    const std::map<std::string, std::vector<KeyFrame>, std::less<>> &frames)
    : time_(duration) // this has the nice property that looping animations will start from the beginning (modulo) but
                      // single play animations will be stopped
    , last_advance_(std::chrono::steady_clock::now())
    , duration_(duration)
    , name_(name)
    , frames_(frames)
    , playback_type_(PlaybackType::LOOPING)
{
}

std::string Animation::name() const
{
    return name_;
}

Transform Animation::transform(std::string_view bone) const
{
    expect(bone_exists(bone), "no animation for bone");

    const auto &keyframes = frames_.find(bone)->second;

    // find the first keyframe *after* current time
    auto second_keyframe = std::find_if(std::cbegin(keyframes) + 1u, std::cend(keyframes), [this](const KeyFrame &kf) {
        return kf.time >= time_;
    });

    // if we are past the end of the animation then use the last keyframe
    if (second_keyframe == std::cend(keyframes))
    {
        --second_keyframe;
    }

    const auto first_keyframe = second_keyframe - 1u;

    // calculate interpolation amount
    const auto delta1 = second_keyframe->time - first_keyframe->time;
    const auto delta2 = time_ - first_keyframe->time;
    const auto interpolation = static_cast<float>(delta2.count()) / static_cast<float>(delta1.count());

    // interpolate between frames
    auto transform = first_keyframe->transform;
    transform.interpolate(second_keyframe->transform, interpolation);

    return transform;
}

bool Animation::bone_exists(std::string_view bone) const
{
    return frames_.count(bone) != 0u;
}

void Animation::advance()
{
    const auto now = std::chrono::steady_clock::now();
    const auto delta = std::chrono::duration_cast<std::chrono::milliseconds>(now - last_advance_);

    // update time
    time_ += delta;

    if (playback_type_ == PlaybackType::LOOPING)
    {
        // looping animations wrap back round
        time_ = time_ % duration_;
    }

    last_advance_ = now;
}

void Animation::reset()
{
    time_ = 0ms;
    last_advance_ = std::chrono::steady_clock::now();
}

PlaybackType Animation::playback_type() const
{
    return playback_type_;
}

void Animation::set_playback_type(PlaybackType playback_type)
{
    playback_type_ = playback_type;
}

bool Animation::running() const
{
    return playback_type_ == PlaybackType::LOOPING ? true : (time_ < duration_);
}

std::chrono::milliseconds Animation::duration() const
{
    return duration_;
}

void Animation::set_time(std::chrono::milliseconds time)
{
    time_ = time;
}

}

```

`src/graphics/animation/animation_controller.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/animation/animation_controller.h"

#include <chrono>
#include <cstddef>
#include <functional>
#include <map>
#include <string>
#include <string_view>
#include <vector>

#include "core/error_handling.h"
#include "core/transform.h"
#include "graphics/animation/animation.h"
#include "graphics/animation/animation_layer.h"
#include "graphics/animation/animation_state.h"
#include "graphics/animation/animation_transition.h"
#include "graphics/animation/cached_bone_query.h"
#include "graphics/skeleton.h"
#include "log/log.h"

namespace
{

iris::AnimationState *get_state(std::string_view name, const std::vector<std::unique_ptr<iris::AnimationState>> &states)
{
    auto state = std::find_if(std::begin(states), std::end(states), [name](const auto &element) {
        return element->animation()->name() == name;
    });

    iris::expect(state != std::end(states), "missing state");

    return state->get();
}

}

namespace iris
{

AnimationController::AnimationController(
    const std::vector<Animation> &animations,
    const std::vector<AnimationLayer> &layers,
    Skeleton *skeleton)
    : skeleton_(skeleton)
    , animations_(animations)
    , layers_(layers)
    , states_(layers_.size())
    , current_state_(layers_.size())
    , query_()
{
    ensure(!layers.empty(), "must have at least one layer");
    ensure(layers.front().bone_mask.empty(), "base layer cannot have a mask");

    std::vector<std::set<std::string>> bone_masks{};

    for (auto i = 1u; i < layers.size(); ++i)
    {
        bone_masks.emplace_back(std::cbegin(layers[i].bone_mask), std::cend(layers[i].bone_mask));
    }

    query_ = std::make_unique<CachedBoneQuery>(skeleton_, bone_masks);

    for (auto i = 0u; i < layers_.size(); ++i)
    {
        const auto &layer = layers_[i];
        current_state_[i] = nullptr;

        for (auto &animation : animations_)
        {
            states_[i].emplace_back(
                std::make_unique<AnimationState>(std::addressof(animation), skeleton_, query_.get(), i));

            if (animation.name() == layer.start_animation)
            {
                current_state_[i] = states_[i].back().get();
            }
        }

        for (const auto &[from, to, duration] : layer.transitions)
        {
            auto *from_state = get_state(from, states_[i]);
            auto *to_state = get_state(to, states_[i]);

            from_state->transitions()[to_state->animation()->name()] = {to_state, duration};
        }

        ensure(current_state_[i] != nullptr, "no valid start start");
        current_state_[i]->enter();
    }
}

AnimationController::~AnimationController() = default;

void AnimationController::update()
{
    for (auto i = 0u; i < layers_.size(); ++i)
    {
        auto *next_state = current_state_[i]->update();
        if (next_state != nullptr)
        {
            current_state_[i]->exit();
            current_state_[i] = next_state;
            current_state_[i]->enter();
        }
    }
}

void AnimationController::play(std::size_t layer, std::string_view animation)
{
    current_state_[layer]->transition(animation);
}

}

```

`src/graphics/animation/animation_state.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/animation/animation_state.h"

#include <chrono>
#include <cstddef>
#include <map>
#include <string>
#include <string_view>

#include "graphics/animation/animation.h"
#include "graphics/animation/cached_bone_query.h"
#include "graphics/animation/utils.h"
#include "graphics/skeleton.h"
#include "log/log.h"

namespace iris
{

AnimationState::AnimationState(Animation *animation, Skeleton *skeleton, CachedBoneQuery *query, std::size_t layer)
    : skeleton_(skeleton)
    , query_(query)
    , animation_(animation)
    , transitions_()
    , next_state_(nullptr)
    , transition_complete_()
    , layer_(layer)
{
}

void AnimationState::enter()
{
    // nothing to do but can be used for logging
}

void AnimationState::exit()
{
    // state has exited so reset next state
    next_state_ = nullptr;
}

AnimationState *AnimationState::update()
{
    AnimationState *transition_state = nullptr;

    if (next_state_ != nullptr)
    {
        // we are transitioning to a new state

        const auto now = std::chrono::system_clock::now();

        if (now < transition_complete_)
        {
            // still transitioning so blend in current transition
            const auto duration = std::get<1>(transitions_[next_state_->animation_->name()]);
            query_->blend(layer_, next_state_->animation_, blend_amount(duration, transition_complete_));
        }
        else
        {
            // transition complete so update query with new state
            transition_state = next_state_;
            query_->update(layer_, next_state_->animation_);
        }
    }
    else
    {
        // no transition so just update animation
        query_->update(layer_, animation_);
    }

    skeleton_->update(query_);

    return transition_state;
}

void AnimationState::transition(std::string_view next)
{
    // if transition is valid then apply it, else no-op
    auto find_state = transitions_.find(next);
    if (find_state != std::end(transitions_))
    {
        const auto &[state, duration] = find_state->second;
        next_state_ = state;
        transition_complete_ = std::chrono::system_clock::now() + duration;

        next_state_->animation_->reset();
    }
}

Skeleton *AnimationState::skeleton() const
{
    return skeleton_;
}

CachedBoneQuery *AnimationState::bone_query() const
{
    return query_;
}

Animation *AnimationState::animation() const
{
    return animation_;
}

AnimationState::TransitionMap &AnimationState::transitions()
{
    return transitions_;
}

AnimationState *AnimationState::next_state() const
{
    return next_state_;
}

std::chrono::system_clock::time_point AnimationState::transition_complete() const
{
    return transition_complete_;
}

std::size_t AnimationState::layer() const
{
    return layer_;
}

}

```

`src/graphics/animation/cached_bone_query.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/animation/cached_bone_query.h"

#include <chrono>
#include <optional>
#include <set>
#include <string>
#include <string_view>
#include <vector>

#include "core/transform.h"
#include "graphics/animation/animation.h"
#include "graphics/animation/bone_query.h"
#include "graphics/animation/utils.h"
#include "graphics/skeleton.h"

using namespace std::literals::chrono_literals;

namespace iris
{

CachedBoneQuery::CachedBoneQuery(const Skeleton *skeleton, const std::vector<std::set<std::string>> &bone_masks)
{
    // create an empty transform for all bones on layer 0 (the base layer)
    for (const auto &bone : skeleton->bones())
    {
        transforms_[bone.name()] = {0u, {}, {}};
    }

    // set the layer for any bones in the supplied mask
    // note this starts at layer 1 and goes up, so a mask in a higher layer will overwrite one from a lower layer
    for (auto i = 0u; i < bone_masks.size(); ++i)
    {
        for (const auto &bone : bone_masks[i])
        {
            transforms_[bone].layer = i + 1u;
        }
    }
}

std::optional<Transform> CachedBoneQuery::transform(std::string_view bone_name)
{
    auto find = transforms_.find(bone_name);
    return find != std::end(transforms_) ? std::optional<Transform>{find->second.transform} : std::nullopt;
}

void CachedBoneQuery::update(std::size_t layer, Animation *animation)
{
    // the logic for this is a little complex as we need to achieve several things:
    // - update bone transform for base layer
    // - update bone transform for supplied layer (if in mask)
    // - if upper layer is a non-looping animation and it has finished then ease it back to the base layer animation
    //   to prevent snapping

    // we need to know if this update caused a non-looping animation to finish, the easiest way is to check if
    // running() is true before *and* false after advance()
    const auto running_pre_advance = animation->running();

    animation->advance();

    const auto running_post_advance = animation->running();
    const auto animation_finished_this_update = running_pre_advance && !running_post_advance;

    // update all transforms
    for (auto &[name, data] : transforms_)
    {
        auto &[bone_layer, transform, ease_end] = data;

        // layer 0 (base layer) always gets updated, if an upper layer masks this bone then it will be overwritten,
        // this isn't the most efficient as we are doing an extra update on masked layers, but it makes logic
        // slightly simpler
        if ((layer == 0u || layer == bone_layer) && animation->bone_exists(name))
        {
            if (animation->running())
            {
                // animation is running so overwrite the base layer transform with the one for this layer
                transform = animation->transform(name);
            }
            else
            {
                // animation has ended - we have the base animation layer already in the transform (this is why we
                // pay the cost and be slightly inefficient) - however we don't want to just snap to it as this will
                // look weird
                // instead we want to ease the current state to the base layer animation over a short time
                const auto now = std::chrono::system_clock::now();
                static constexpr auto ease_duration = 250ms;

                if (animation_finished_this_update)
                {
                    // we finished the animation this update call, so so set the time we want the easing to end
                    ease_end = now + ease_duration;

                    // we want to interpolate here, otherwise we will get one frame where we are in the wring place
                    transform.interpolate(animation->transform(name), 1.0f - blend_amount(ease_duration, ease_end));
                }
                else if (now < ease_end)
                {
                    // still easing, so interpolate
                    transform.interpolate(animation->transform(name), 1.0f - blend_amount(ease_duration, ease_end));
                }
            }
        }
    }
}

void CachedBoneQuery::blend(std::size_t layer, Animation *animation, float blend_amount)
{
    // update supplied animation
    animation->advance();

    for (auto &[name, data] : transforms_)
    {
        auto &[bone_layer, transform, ease_end] = data;

        if ((layer == 0u || layer == bone_layer) && animation->bone_exists(name))
        {
            // layer 0 (base layer) always gets updated, if an upper layer masks this bone then it will be overwritten,
            // this isn't the most efficient as we are doing an extra update on masked layers
            transform.interpolate(animation->transform(name), blend_amount);
        }
    }
}

}

```

`src/graphics/animation/utils.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/animation/utils.h"

#include <chrono>

namespace iris
{

float blend_amount(std::chrono::milliseconds duration, std::chrono::system_clock::time_point end_time)
{
    const auto now = std::chrono::system_clock::now();
    const auto remaining = end_time - now;
    const auto remaining_percentage =
        static_cast<float>(std::chrono::duration_cast<std::chrono::milliseconds>(remaining).count()) /
        static_cast<float>(duration.count());
    return 1.0f - remaining_percentage;
}

}

```

`src/graphics/animation_blender.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/animation_blender.h"

#include <string_view>
#include <vector>

#include "core/transform.h"
#include "graphics/animation/animation.h"

namespace iris
{

AnimationBlender::AnimationBlender()
{
}

AnimationBlender::AnimationBlender(Animation *animation_a, Animation *animation_b, float blend_amount)
    : animation_a_(animation_a)
    , animation_b_(animation_b)
    , blend_amount_(blend_amount)
{
}

Transform AnimationBlender::transform(std::string_view bone) const
{
    auto transform_a = animation_a_->transform(bone);
    const auto transform_b = animation_b_->transform(bone);

    transform_a.interpolate(transform_b, blend_amount_);
    return transform_a;
}

bool AnimationBlender::bone_exists(std::string_view bone) const
{
    return animation_a_->bone_exists(bone) && animation_b_->bone_exists(bone);
}

void AnimationBlender::advance()
{
    animation_a_->advance();
    animation_b_->advance();
}

void AnimationBlender::set_blend_amount(float blend_amount)
{
    blend_amount_ = blend_amount;
}

}

```

`src/graphics/bone.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/bone.h"

#include <cstddef>
#include <limits>
#include <string>
#include <vector>

#include "core/matrix4.h"
#include "core/transform.h"
#include "graphics/weight.h"

namespace iris
{

Bone::Bone(const std::string &name, const std::string &parent, const Matrix4 &offset, const Matrix4 &transform)
    : name_(name)
    , parent_(parent)
    , offset_(offset)
    , transform_(transform)
    , is_manual_(false)
{
}

std::string Bone::name() const
{
    return name_;
}

const Matrix4 &Bone::offset() const
{
    return offset_;
}

std::string Bone::parent() const
{
    return parent_;
}

const Matrix4 &Bone::transform() const
{
    return transform_;
}

void Bone::set_transform(const Matrix4 &transform)
{
    transform_ = transform;
}

bool Bone::is_manual() const
{
    return is_manual_;
}

void Bone::set_manual(bool is_manual)
{
    is_manual_ = is_manual;
}

}

```

`src/graphics/cube_map.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/cube_map.h"

#include <cstdint>

#include "graphics/sampler.h"

namespace iris
{

CubeMap::CubeMap(const Sampler *sampler, std::uint32_t index)
    : sampler_(sampler)
    , index_(index)
{
}

std::uint32_t CubeMap::index() const
{
    return index_;
}

const Sampler *CubeMap::sampler() const
{
    return sampler_;
}

}

```

`src/graphics/d3d12/CMakeLists.txt`:

```txt
set(INCLUDE_ROOT "${PROJECT_SOURCE_DIR}/include/iris/graphics/d3d12")

target_sources(iris PRIVATE
    ${INCLUDE_ROOT}/d3d12_buffer.h
    ${INCLUDE_ROOT}/d3d12_constant_buffer.h
    ${INCLUDE_ROOT}/d3d12_constant_buffer_pool.h
    ${INCLUDE_ROOT}/d3d12_context.h
    ${INCLUDE_ROOT}/d3d12_cpu_descriptor_handle_allocator.h
    ${INCLUDE_ROOT}/d3d12_cube_map.h
    ${INCLUDE_ROOT}/d3d12_descriptor_handle.h
    ${INCLUDE_ROOT}/d3d12_descriptor_manager.h
    ${INCLUDE_ROOT}/d3d12_gpu_descriptor_handle_allocator.h
    ${INCLUDE_ROOT}/d3d12_material.h
    ${INCLUDE_ROOT}/d3d12_material_manager.h
    ${INCLUDE_ROOT}/d3d12_mesh.h
    ${INCLUDE_ROOT}/d3d12_mesh_manager.h
    ${INCLUDE_ROOT}/d3d12_render_target.h
    ${INCLUDE_ROOT}/d3d12_render_target_manager.h
    ${INCLUDE_ROOT}/d3d12_renderer.h
    ${INCLUDE_ROOT}/d3d12_root_signature.h
    ${INCLUDE_ROOT}/d3d12_sampler.h
    ${INCLUDE_ROOT}/d3d12_structured_buffer.h
    ${INCLUDE_ROOT}/d3d12_texture.h
    ${INCLUDE_ROOT}/d3d12_texture_manager.h
    d3d12_buffer.cpp
    d3d12_constant_buffer.cpp
    d3d12_constant_buffer_pool.cpp
    d3d12_context.cpp
    d3d12_cube_map.cpp
    d3d12_descriptor_handle.cpp
    d3d12_descriptor_manager.cpp
    d3d12_material.cpp
    d3d12_material_manager.cpp
    d3d12_mesh.cpp
    d3d12_mesh_manager.cpp
    d3d12_render_target.cpp
    d3d12_render_target_manager.cpp
    d3d12_renderer.cpp
    d3d12_sampler.cpp
    d3d12_structured_buffer.cpp
    d3d12_texture.cpp
    d3d12_texture_manager.cpp)

```

`src/graphics/d3d12/d3d12_buffer.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/d3d12/d3d12_buffer.h"

#include <any>
#include <cstring>

#include <wrl.h>

#include "directx/d3d12.h"

#include "core/data_buffer.h"
#include "core/error_handling.h"
#include "graphics/d3d12/d3d12_context.h"
#include "graphics/vertex_data.h"

namespace
{

/**
 * Helper function to create a new GPU D3D12 buffer.
 *
 * @param size
 *   Size of buffer (in bytes).
 *
 * @param mapped_memory
 *   Out pointer (to a pointer) where the buffer will be mapped to the CPU.
 */
Microsoft::WRL::ComPtr<ID3D12Resource> create_resource(std::size_t size, std::byte **mapped_memory)
{
    auto *device = iris::D3D12Context::device();

    // create the buffer on the upload heap
    CD3DX12_HEAP_PROPERTIES heap_properties(D3D12_HEAP_TYPE_UPLOAD);
    const auto buffer_descriptor = CD3DX12_RESOURCE_DESC::Buffer(static_cast<UINT>(size));
    Microsoft::WRL::ComPtr<ID3D12Resource> resource = nullptr;

    const auto commit_resource = device->CreateCommittedResource(
        &heap_properties,
        D3D12_HEAP_FLAG_NONE,
        &buffer_descriptor,
        D3D12_RESOURCE_STATE_GENERIC_READ,
        nullptr,
        IID_PPV_ARGS(&resource));
    iris::expect(commit_resource == S_OK, "could not create committed resource");

    CD3DX12_RANGE read_range(0, 0);

    // map the gpu buffer to the cpu, so it can be written to
    iris::expect(
        resource->Map(0u, &read_range, reinterpret_cast<void **>(mapped_memory)) == S_OK, "could not map buffer");

    return resource;
}

}

namespace iris
{

D3D12Buffer::D3D12Buffer(const std::vector<VertexData> &vertex_data)
    : resource_()
    , vertex_buffer_view_()
    , index_buffer_view_()
    , element_count_(vertex_data.size())
    , capacity_(element_count_)
    , mapped_memory_(nullptr)
{
    resource_ = create_resource(capacity_ * sizeof(VertexData), &mapped_memory_);

    write(vertex_data);

    vertex_buffer_view_.BufferLocation = resource_->GetGPUVirtualAddress();
    vertex_buffer_view_.SizeInBytes = static_cast<UINT>(element_count_ * sizeof(VertexData));
    vertex_buffer_view_.StrideInBytes = sizeof(VertexData);
}

D3D12Buffer::D3D12Buffer(const std::vector<std::uint32_t> &index_data)
    : resource_()
    , vertex_buffer_view_()
    , index_buffer_view_()
    , element_count_(index_data.size())
    , capacity_(element_count_)
    , mapped_memory_(nullptr)
{
    resource_ = create_resource(capacity_ * sizeof(std::uint32_t), &mapped_memory_);

    write(index_data);

    index_buffer_view_.BufferLocation = resource_->GetGPUVirtualAddress();
    index_buffer_view_.SizeInBytes = static_cast<UINT>(element_count_ * sizeof(std::uint32_t));
    index_buffer_view_.Format = DXGI_FORMAT_R32_UINT;
}

std::size_t D3D12Buffer::element_count() const
{
    return element_count_;
}

D3D12_VERTEX_BUFFER_VIEW D3D12Buffer::vertex_view() const
{
    return vertex_buffer_view_;
}

D3D12_INDEX_BUFFER_VIEW D3D12Buffer::index_view() const
{
    return index_buffer_view_;
}

void D3D12Buffer::write(const std::vector<VertexData> &vertex_data)
{
    element_count_ = vertex_data.size();

    // if buffer is too small for new data then reallocate
    if (element_count_ > capacity_)
    {
        capacity_ = element_count_;
        resource_ = create_resource(capacity_ * sizeof(VertexData), &mapped_memory_);

        vertex_buffer_view_.BufferLocation = resource_->GetGPUVirtualAddress();
        vertex_buffer_view_.SizeInBytes = static_cast<UINT>(capacity_ * sizeof(VertexData));
        vertex_buffer_view_.StrideInBytes = sizeof(VertexData);
    }

    // copy new data
    std::memcpy(mapped_memory_, vertex_data.data(), element_count_ * sizeof(VertexData));
}

void D3D12Buffer::write(const std::vector<std::uint32_t> &index_data)
{
    element_count_ = index_data.size();

    // if buffer is too small for new data then reallocate
    if (element_count_ > capacity_)
    {
        capacity_ = element_count_;
        resource_ = create_resource(capacity_ * sizeof(std::uint32_t), &mapped_memory_);

        index_buffer_view_.BufferLocation = resource_->GetGPUVirtualAddress();
        index_buffer_view_.SizeInBytes = static_cast<UINT>(capacity_ * sizeof(std::uint32_t));
        index_buffer_view_.Format = DXGI_FORMAT_R32_UINT;
    }

    // copy new data
    std::memcpy(mapped_memory_, index_data.data(), element_count_ * sizeof(std::uint32_t));
}

}

```

`src/graphics/d3d12/d3d12_constant_buffer.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/d3d12/d3d12_constant_buffer.h"

#include <cstddef>
#include <cstdint>
#include <optional>
#include <sstream>

#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <wrl.h>

#include "directx/d3d12.h"
#include "directx/d3dx12.h"

#include "core/error_handling.h"
#include "graphics/d3d12/d3d12_context.h"
#include "graphics/d3d12/d3d12_cpu_descriptor_handle_allocator.h"
#include "graphics/d3d12/d3d12_descriptor_handle.h"
#include "graphics/d3d12/d3d12_descriptor_manager.h"
#include "graphics/d3d12/d3d12_gpu_descriptor_handle_allocator.h"
#include "graphics/texture_manager.h"

namespace
{

/**
 * Helper function to create a D3D12 buffer on the upload heap.
 *
 * @param frame
 *   The frame number using this buffer.
 *
 * @param capacity
 *   Size of buffer (in bytes).
 *
 * @param resource
 *   A D3D12 handle to be set to the new resource.
 *
 * @returns
 *   Descriptor handle to buffer.
 */
iris::D3D12DescriptorHandle create_resource(
    std::uint32_t frame,
    std::size_t capacity,
    Microsoft::WRL::ComPtr<ID3D12Resource> &resource)
{
    const auto upload_heap = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
    const auto heap_descriptor = CD3DX12_RESOURCE_DESC::Buffer(capacity);

    auto *device = iris::D3D12Context::device();

    // create the buffer
    const auto commit_resource = device->CreateCommittedResource(
        &upload_heap,
        D3D12_HEAP_FLAG_NONE,
        &heap_descriptor,
        D3D12_RESOURCE_STATE_GENERIC_READ,
        nullptr,
        IID_PPV_ARGS(&resource));
    iris::expect(commit_resource == S_OK, "could not create constant buffer");

    // set a name for the resource
    static int counter = 0;
    std::wstringstream strm{};
    strm << L"cb_" << counter++;
    const auto name = strm.str();

    resource->SetName(name.c_str());

    // allocate descriptor for buffer
    return iris::D3D12DescriptorManager::cpu_allocator(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV).allocate_dynamic(frame);
}

}

namespace iris
{

D3D12ConstantBuffer::D3D12ConstantBuffer(std::uint32_t frame)
    : capacity_(1u)
    , mapped_buffer_(nullptr)
    , resource_(nullptr)
    , descriptor_handle_(create_resource(frame, capacity_, resource_))
{
    auto *device = iris::D3D12Context::device();

    device->CreateConstantBufferView(nullptr, descriptor_handle_.cpu_handle());

    // note we don't create a view or map the resource, it's a null buffer so
    // there are no valid actions on it
}

D3D12ConstantBuffer::D3D12ConstantBuffer(std::uint32_t frame, std::size_t capacity)
    : capacity_(capacity)
    , mapped_buffer_(nullptr)
    , resource_(nullptr)
    , descriptor_handle_(create_resource(frame, capacity_, resource_))
{
    auto *device = D3D12Context::device();

    D3D12_CONSTANT_BUFFER_VIEW_DESC cbv_descriptor = {0};
    cbv_descriptor.BufferLocation = resource_->GetGPUVirtualAddress();
    cbv_descriptor.SizeInBytes = static_cast<UINT>(capacity_);

    // create a view onto the buffer
    device->CreateConstantBufferView(&cbv_descriptor, descriptor_handle_.cpu_handle());

    // map the buffer to the cpu so we can write to it
    const auto map_resource = resource_->Map(0u, NULL, reinterpret_cast<void **>(&mapped_buffer_));
    expect(map_resource == S_OK, "failed to map constant buffer");
}

D3D12DescriptorHandle D3D12ConstantBuffer::descriptor_handle() const
{
    return descriptor_handle_;
}

}

```

`src/graphics/d3d12/d3d12_constant_buffer_pool.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/d3d12/d3d12_constant_buffer_pool.h"

#include <cstdint>

#include "core/error_handling.h"

namespace iris
{

D3D12ConstantBufferPool::D3D12ConstantBufferPool(std::uint32_t frame)
    : buffers_()
    , index_(0u)
{
    for (auto i = 0u; i < 400; ++i)
    {
        buffers_.emplace_back(frame, 7168u);
    }
}

D3D12ConstantBuffer &D3D12ConstantBufferPool::next()
{
    ensure(index_ < buffers_.size(), "pool drained");

    return buffers_[index_++];
}

void D3D12ConstantBufferPool::reset()
{
    index_ = 0u;
}

}

```

`src/graphics/d3d12/d3d12_context.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/d3d12/d3d12_context.h"

#include <dxgi1_6.h>
#include <wrl.h>

#include "directx/d3d12.h"
#include "directx/d3dx12.h"

#include "core/error_handling.h"
#include "graphics/d3d12/d3d12_root_signature.h"

namespace iris
{

D3D12Context::D3D12Context()
    : dxgi_factory_(nullptr)
    , device_(nullptr)
    , info_queue_(nullptr)
    , root_signature_()
{
    // create and enable a debug layer
    Microsoft::WRL::ComPtr<ID3D12Debug> debug_interface = nullptr;
    expect(::D3D12GetDebugInterface(IID_PPV_ARGS(&debug_interface)) == S_OK, "could not create debug interface");

    debug_interface->EnableDebugLayer();

    expect(
        ::CreateDXGIFactory2(DXGI_CREATE_FACTORY_DEBUG, IID_PPV_ARGS(&dxgi_factory_)) == S_OK,
        "could not create dxgi factory");

    Microsoft::WRL::ComPtr<IDXGIAdapter1> dxgi_adaptor_tmp = nullptr;
    Microsoft::WRL::ComPtr<IDXGIAdapter4> dxgi_adaptor = nullptr;
    SIZE_T max_dedicated_memory = 0u;
    UINT32 index = 0u;

    // search all adaptors for one that can be used to create a d3d12 device
    // (with the most amount of dedicated video memory)
    while (dxgi_factory_->EnumAdapters1(index++, &dxgi_adaptor_tmp) != DXGI_ERROR_NOT_FOUND)
    {
        DXGI_ADAPTER_DESC1 adaptor_descriptor = {0};
        dxgi_adaptor_tmp->GetDesc1(&adaptor_descriptor);

        // ignore the software renderer
        if ((adaptor_descriptor.Flags & DXGI_ADAPTER_FLAG_SOFTWARE) == 0)
        {
            // test if we can create a d3d12 device with this adaptor
            if (::D3D12CreateDevice(dxgi_adaptor_tmp.Get(), D3D_FEATURE_LEVEL_11_0, __uuidof(ID3D12Device), nullptr) ==
                S_FALSE)
            {
                // check if this adaptor has more available memory
                if (adaptor_descriptor.DedicatedVideoMemory > max_dedicated_memory)
                {
                    const auto cast = dxgi_adaptor_tmp.As(&dxgi_adaptor);
                    expect(cast == S_OK, "failed to cast dxgi adaptor");

                    max_dedicated_memory = adaptor_descriptor.DedicatedVideoMemory;
                }
            }
        }
    }

    ensure(dxgi_adaptor != nullptr, "could not find a directx12 adapter");

    // create actual d3d12 device
    expect(
        ::D3D12CreateDevice(dxgi_adaptor.Get(), D3D_FEATURE_LEVEL_11_0, IID_PPV_ARGS(&device_)) == S_OK,
        "could not create directx12 device");

    expect(device_.As(&info_queue_) == S_OK, "could not cast device to info queue");

    // hide warnings we don't care about
    D3D12_MESSAGE_ID hide[] = {
        D3D12_MESSAGE_ID_CLEARRENDERTARGETVIEW_MISMATCHINGCLEARVALUE,
        D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_RENDERTARGETVIEW_NOT_SET};

    D3D12_INFO_QUEUE_FILTER filter = {0};
    filter.DenyList.NumIDs = _countof(hide);
    filter.DenyList.pIDList = hide;
    info_queue_->AddStorageFilterEntries(&filter);

    // set break on error and warning
    info_queue_->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_CORRUPTION, TRUE);
    info_queue_->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_ERROR, TRUE);
    info_queue_->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_WARNING, TRUE);

    root_signature_ = std::make_unique<D3D12RootSignature<
        ConstantBufferViewParameter<0u, 0u, D3D12_SHADER_VISIBILITY_ALL>,
        ConstantBufferViewParameter<1u, 0u, D3D12_SHADER_VISIBILITY_ALL>,
        ConstantBufferViewParameter<2u, 0u, D3D12_SHADER_VISIBILITY_ALL>,
        ConstantParameter<3u, 0u, D3D12_SHADER_VISIBILITY_ALL>,
        ConstantParameter<4u, 0u, D3D12_SHADER_VISIBILITY_ALL>,
        ConstantParameter<5u, 0u, D3D12_SHADER_VISIBILITY_ALL>,
        ConstantBufferViewParameter<6u, 0u, D3D12_SHADER_VISIBILITY_ALL>,
        ShaderResourceViewParameter<0u, 0u, D3D12_SHADER_VISIBILITY_ALL>,
        TableParameter<D3D12_DESCRIPTOR_RANGE_TYPE_SRV, UINT_MAX, 0u, 1u, D3D12_SHADER_VISIBILITY_PIXEL>,
        TableParameter<D3D12_DESCRIPTOR_RANGE_TYPE_SRV, UINT_MAX, 0u, 2u, D3D12_SHADER_VISIBILITY_PIXEL>,
        TableParameter<D3D12_DESCRIPTOR_RANGE_TYPE_SAMPLER, UINT_MAX, 0u, 0u, D3D12_SHADER_VISIBILITY_PIXEL>>>(
        device_.Get());
}

D3D12Context &D3D12Context::instance()
{
    static D3D12Context instance{};
    return instance;
}

IDXGIFactory4 *D3D12Context::dxgi_factory()
{
    return instance().dxgi_factory_impl();
}

ID3D12Device2 *D3D12Context::device()
{
    return instance().device_impl();
}

IDXGIFactory4 *D3D12Context::dxgi_factory_impl() const
{
    return dxgi_factory_.Get();
}

ID3D12Device2 *D3D12Context::device_impl() const
{
    return device_.Get();
}

}

```

`src/graphics/d3d12/d3d12_cube_map.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/d3d12/d3d12_cube_map.h"

#include <cstdint>
#include <vector>

#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <wrl.h>

#include "directx/d3d12.h"
#include "directx/d3dx12.h"

#include "core/data_buffer.h"
#include "core/error_handling.h"
#include "graphics/d3d12/d3d12_context.h"
#include "graphics/d3d12/d3d12_descriptor_handle.h"
#include "graphics/d3d12/d3d12_descriptor_manager.h"
#include "graphics/sampler.h"

namespace iris
{

D3D12CubeMap::D3D12CubeMap(
    const DataBuffer &right_data,
    const DataBuffer &left_data,
    const DataBuffer &top_data,
    const DataBuffer &bottom_data,
    const DataBuffer &back_data,
    const DataBuffer &front_data,
    std::uint32_t width,
    std::uint32_t height,
    const Sampler *sampler,
    std::uint32_t index)
    : CubeMap(sampler, index)
    , resource_()
    , upload_()
    , resource_view_()
    , type_()
{
    auto *device = D3D12Context::device();
    const auto default_heap = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT);

    D3D12_RESOURCE_DESC texture_description{};
    texture_description.Format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
    texture_description.Width = width;
    texture_description.Height = height;
    texture_description.Flags = D3D12_RESOURCE_FLAG_NONE;
    texture_description.DepthOrArraySize = 6;
    texture_description.MipLevels = 1;
    texture_description.SampleDesc.Count = 1;
    texture_description.SampleDesc.Quality = 0;
    texture_description.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
    texture_description.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN;
    texture_description.Alignment = 0;

    // create a resource where image data will be coped to
    expect(
        device->CreateCommittedResource(
            &default_heap,
            D3D12_HEAP_FLAG_NONE,
            &texture_description,
            D3D12_RESOURCE_STATE_COPY_DEST,
            nullptr,
            IID_PPV_ARGS(&resource_)) == S_OK,
        "could not create resource");

    const UINT64 capacity = GetRequiredIntermediateSize(resource_.Get(), 0, 6);

    const auto upload_heap = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
    const auto heap_description = CD3DX12_RESOURCE_DESC::Buffer(capacity);

    // create resource for initial upload of texture data
    expect(
        device->CreateCommittedResource(
            &upload_heap,
            D3D12_HEAP_FLAG_NONE,
            &heap_description,
            D3D12_RESOURCE_STATE_GENERIC_READ,
            nullptr,
            IID_PPV_ARGS(&upload_)) == S_OK,
        "could not create resource");

    type_ = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
    resource_view_ = D3D12DescriptorManager::cpu_allocator(type_).allocate_static();

    D3D12_SHADER_RESOURCE_VIEW_DESC shader_view_description = {0};
    shader_view_description.Format = texture_description.Format;
    shader_view_description.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
    shader_view_description.ViewDimension = D3D12_SRV_DIMENSION_TEXTURECUBE;
    shader_view_description.TextureCube.MipLevels = 1;
    shader_view_description.TextureCube.MostDetailedMip = 0;
    shader_view_description.TextureCube.ResourceMinLODClamp = 0.0f;

    device->CreateShaderResourceView(resource_.Get(), &shader_view_description, resource_view_.cpu_handle());

    // map the upload buffer so we can write to it
    void *mapped_buffer = nullptr;
    expect(upload_->Map(0u, NULL, reinterpret_cast<void **>(&mapped_buffer)) == S_OK, "failed to map constant buffer");

    const std::byte *data_ptrs[] = {
        right_data.data(), left_data.data(), top_data.data(), bottom_data.data(), back_data.data(), front_data.data()};

    UINT heights[] = {height, height, height, height, height, height};
    UINT64 row_sizes[] = {width * 4u, width * 4u, width * 4u, width * 4u, width * 4u, width * 4u};

    // create footprint for image data layout
    std::uint64_t memory_size = 0u;
    device->GetCopyableFootprints(
        &texture_description,
        0,
        static_cast<UINT>(footprints_.size()),
        0,
        footprints_.data(),
        heights,
        row_sizes,
        &memory_size);

    for (auto i = 0u; i < 6u; ++i)
    {
        auto *dst_cursor = reinterpret_cast<std::byte *>(mapped_buffer) + footprints_[i].Offset;
        auto *src_cursor = data_ptrs[i];

        // copy texture data with respect to footprint
        for (auto j = 0u; j < heights[i]; ++j)
        {
            std::memcpy(dst_cursor, src_cursor, static_cast<std::size_t>(row_sizes[i]));
            dst_cursor += footprints_[i].Footprint.RowPitch;
            src_cursor += row_sizes[i];
        }
    }
}

ID3D12Resource *D3D12CubeMap::resource() const
{
    return resource_.Get();
}

ID3D12Resource *D3D12CubeMap::upload() const
{
    return upload_.Get();
}

D3D12DescriptorHandle D3D12CubeMap::handle() const
{
    return resource_view_;
}

std::array<D3D12_PLACED_SUBRESOURCE_FOOTPRINT, 6u> D3D12CubeMap::footprints() const
{
    return footprints_;
}

}

```

`src/graphics/d3d12/d3d12_descriptor_handle.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/d3d12/d3d12_descriptor_handle.h"

#include "directx/d3d12.h"
#include "directx/d3dx12.h"

namespace iris
{

D3D12DescriptorHandle::D3D12DescriptorHandle()
    : cpu_handle_()
    , gpu_handle_()
{
    cpu_handle_.ptr = NULL;
    gpu_handle_.ptr = NULL;
}

D3D12DescriptorHandle::D3D12DescriptorHandle(D3D12_CPU_DESCRIPTOR_HANDLE cpu_handle)
    : cpu_handle_(cpu_handle)
    , gpu_handle_()
{
    gpu_handle_.ptr = NULL;
}

D3D12DescriptorHandle::D3D12DescriptorHandle(
    D3D12_CPU_DESCRIPTOR_HANDLE cpu_handle,
    D3D12_GPU_DESCRIPTOR_HANDLE gpu_handle)
    : cpu_handle_(cpu_handle)
    , gpu_handle_(gpu_handle)
{
}

D3D12_CPU_DESCRIPTOR_HANDLE D3D12DescriptorHandle::cpu_handle() const
{
    return cpu_handle_;
}

D3D12_GPU_DESCRIPTOR_HANDLE D3D12DescriptorHandle::gpu_handle() const
{
    return gpu_handle_;
}

D3D12DescriptorHandle::operator bool() const
{
    // only need to check cpu handle as there is no situation where we could
    // have a gpu handle without a cpu handle
    return cpu_handle_.ptr != NULL;
}

}
```

`src/graphics/d3d12/d3d12_descriptor_manager.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/d3d12/d3d12_descriptor_manager.h"

#include "directx/d3d12.h"
#include "directx/d3dx12.h"

#include "graphics/d3d12/d3d12_cpu_descriptor_handle_allocator.h"
#include "graphics/d3d12/d3d12_gpu_descriptor_handle_allocator.h"

namespace iris
{

D3D12CPUDescriptorHandleAllocator<3u> &D3D12DescriptorManager::cpu_allocator(D3D12_DESCRIPTOR_HEAP_TYPE type)
{
    return instance().cpu_allocator_impl(type);
}

D3D12GPUDescriptorHandleAllocator<3u> &D3D12DescriptorManager::gpu_allocator(D3D12_DESCRIPTOR_HEAP_TYPE type)
{
    return instance().gpu_allocator_impl(type);
}

D3D12DescriptorManager::D3D12DescriptorManager()
    : cpu_allocators_()
    , gpu_allocators_()
{
    for (auto i = 0u; i < D3D12_DESCRIPTOR_HEAP_TYPE_NUM_TYPES; ++i)
    {
        const auto type = static_cast<D3D12_DESCRIPTOR_HEAP_TYPE>(i);
        cpu_allocators_.insert({type, {type, 10240u * 20u, 1000u}});
    }

    gpu_allocators_.insert(
        {D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV, {D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV, 10240u * 20u, 1000u}});
    gpu_allocators_.insert({D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER, {D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER, 2048u, 100u}});
}

D3D12DescriptorManager &D3D12DescriptorManager::instance()
{
    static D3D12DescriptorManager dm{};
    return dm;
}

D3D12CPUDescriptorHandleAllocator<3u> &D3D12DescriptorManager::cpu_allocator_impl(D3D12_DESCRIPTOR_HEAP_TYPE type)
{
    return cpu_allocators_.at(type);
}

D3D12GPUDescriptorHandleAllocator<3u> &D3D12DescriptorManager::gpu_allocator_impl(D3D12_DESCRIPTOR_HEAP_TYPE type)
{
    return gpu_allocators_.at(type);
}

}

```

`src/graphics/d3d12/d3d12_material.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/d3d12/d3d12_material.h"

#include <any>
#include <functional>
#include <memory>
#include <sstream>
#include <string>
#include <vector>

#include <d3dcompiler.h>
#include <wrl.h>

#include "directx/d3d12.h"
#include "directx/d3dx12.h"

#include "core/error_handling.h"
#include "graphics/d3d12/d3d12_context.h"
#include "graphics/d3d12/d3d12_root_signature.h"
#include "graphics/lights/lighting_rig.h"
#include "graphics/render_graph/shader_compiler.h"
#include "graphics/shader_type.h"
#include "log/log.h"

#pragma comment(lib, "d3dcompiler.lib")

namespace
{
/**
 * Helper function to create a d3d12 shader.
 *
 * @param source
 *   Shader source.
 *
 * @param type
 *   Type of shader.
 *
 * @returns
 *   D3D12 handle to created shader.
 */
Microsoft::WRL::ComPtr<ID3DBlob> create_shader(const std::string &source, iris::ShaderType type)
{
    const auto target = type == iris::ShaderType::VERTEX ? "vs_5_1" : "ps_5_1";

    Microsoft::WRL::ComPtr<ID3DBlob> shader = nullptr;
    Microsoft::WRL::ComPtr<ID3DBlob> error = nullptr;
    if (::D3DCompile(
            source.c_str(),
            source.length(),
            NULL,
            NULL,
            NULL,
            "main",
            target,
            D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION | D3DCOMPILE_ENABLE_UNBOUNDED_DESCRIPTOR_TABLES,
            0u,
            &shader,
            &error) != S_OK)
    {
        const std::string error_message(static_cast<char *>(error->GetBufferPointer()), error->GetBufferSize());

        auto line_number = 1u;

        std::istringstream strm{source};
        for (std::string line; std::getline(strm, line);)
        {
            LOG_ENGINE_ERROR("d3d12_material", "{}: {}", line_number, line);
            ++line_number;
        }

        LOG_ENGINE_ERROR("d3d12_material", "{}", error_message);

        throw iris::Exception("shader compile failed: " + error_message);
    }

    LOG_ENGINE_INFO("d3d12_material", "shader created");

    return shader;
}

}

namespace iris
{

D3D12Material::D3D12Material(
    const RenderGraph *render_graph,
    const std::vector<D3D12_INPUT_ELEMENT_DESC> &input_descriptors,
    PrimitiveType primitive_type,
    LightType light_type,
    ID3D12RootSignature *root_signature,
    bool render_to_swapchain,
    bool render_to_normal_target,
    bool render_to_position_target,
    bool has_transparency,
    bool wireframe)
    : Material(render_graph)
    , pso_()
{
    ShaderCompiler compiler{
        ShaderLanguage::HLSL, render_graph, light_type, render_to_normal_target, render_to_position_target};
    const auto vertex_source = compiler.vertex_shader();
    const auto fragment_source = compiler.fragment_shader();

    const auto vertex_shader = create_shader(vertex_source, ShaderType::VERTEX);
    const auto fragment_shader = create_shader(fragment_source, ShaderType::FRAGMENT);

    auto *device = D3D12Context::device();

    // setup various descriptors for pipeline state

    auto blend_state = CD3DX12_BLEND_DESC(D3D12_DEFAULT);
    blend_state.RenderTarget[0].BlendEnable = FALSE;

    if (light_type == LightType::AMBIENT)
    {
        if (has_transparency)
        {
            blend_state.RenderTarget[0].BlendEnable = TRUE;
            blend_state.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;
            blend_state.RenderTarget[0].SrcBlend = D3D12_BLEND_SRC_ALPHA;
            blend_state.RenderTarget[0].DestBlend = D3D12_BLEND_INV_SRC_ALPHA;
        }
    }
    else
    {
        blend_state.RenderTarget[0].BlendEnable = TRUE;
        blend_state.RenderTarget[0].DestBlend = D3D12_BLEND_ONE;
        blend_state.RenderTarget[0].SrcBlend = D3D12_BLEND_SRC_ALPHA;
    }

    auto depth_state = CD3DX12_DEPTH_STENCIL_DESC(D3D12_DEFAULT);
    depth_state.DepthFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL;
    depth_state.DepthWriteMask =
        (light_type == LightType::AMBIENT) ? D3D12_DEPTH_WRITE_MASK_ALL : D3D12_DEPTH_WRITE_MASK_ZERO;

    D3D12_RASTERIZER_DESC rasterizer_description = {0};
    rasterizer_description.FillMode = wireframe ? D3D12_FILL_MODE_WIREFRAME : D3D12_FILL_MODE_SOLID;
    rasterizer_description.CullMode = D3D12_CULL_MODE_NONE;
    rasterizer_description.FrontCounterClockwise = TRUE;
    rasterizer_description.DepthClipEnable = TRUE;
    rasterizer_description.ConservativeRaster = D3D12_CONSERVATIVE_RASTERIZATION_MODE_OFF;

    D3D12_GRAPHICS_PIPELINE_STATE_DESC descriptor = {};
    descriptor.InputLayout = {input_descriptors.data(), static_cast<UINT>(input_descriptors.size())};
    descriptor.pRootSignature = root_signature;
    descriptor.VS = CD3DX12_SHADER_BYTECODE(vertex_shader.Get());
    descriptor.PS = CD3DX12_SHADER_BYTECODE(fragment_shader.Get());
    descriptor.RasterizerState = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT);
    descriptor.BlendState = blend_state;
    descriptor.DepthStencilState = depth_state;
    descriptor.DSVFormat = DXGI_FORMAT_D24_UNORM_S8_UINT;
    descriptor.SampleMask = UINT_MAX;
    descriptor.RasterizerState = rasterizer_description;
    descriptor.SampleDesc.Count = 1;

    // set formats for all render targets we might use, it's ok to set these even if they are unused
    descriptor.NumRenderTargets = 3;
    descriptor.RTVFormats[0] = !render_to_swapchain ? DXGI_FORMAT_R16G16B16A16_FLOAT : DXGI_FORMAT_R8G8B8A8_UNORM;
    descriptor.RTVFormats[1] = DXGI_FORMAT_R16G16B16A16_FLOAT;
    descriptor.RTVFormats[2] = DXGI_FORMAT_R16G16B16A16_FLOAT;

    switch (primitive_type)
    {
        case PrimitiveType::TRIANGLES: descriptor.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE; break;
        case PrimitiveType::LINES: descriptor.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_LINE; break;
    }

    // create pipeline state
    expect(device->CreateGraphicsPipelineState(&descriptor, IID_PPV_ARGS(&pso_)) == S_OK, "could not create pso");

    static int counter = 0;
    std::wstringstream strm{};
    strm << L"pso_" << counter++;
    const auto name = strm.str();
    pso_->SetName(name.c_str());
}

ID3D12PipelineState *D3D12Material::pso() const
{
    return pso_.Get();
}

}

```

`src/graphics/d3d12/d3d12_material_manager.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/d3d12/d3d12_material_manager.h"

#include "graphics/d3d12/d3d12_context.h"
#include "graphics/d3d12/d3d12_mesh.h"
#include "graphics/d3d12/d3d12_render_target.h"
#include "graphics/material_cache.h"
#include "graphics/render_entity.h"
#include "graphics/render_graph/render_graph.h"

namespace iris
{

Material *D3D12MaterialManager::create(
    RenderGraph *render_graph,
    RenderEntity *render_entity,
    LightType light_type,
    bool render_to_colour_target,
    bool render_to_normal_target,
    bool render_to_position_target,
    bool has_transparency)
{
    return materials_.try_emplace(
        render_graph,
        light_type,
        render_to_normal_target,
        render_to_position_target,
        render_graph,
        static_cast<const D3D12Mesh *>(render_entity->mesh())->input_descriptors(),
        render_entity->primitive_type(),
        light_type,
        D3D12Context::root_signature().handle(),
        !render_to_colour_target,
        render_to_normal_target,
        render_to_position_target,
        has_transparency,
        render_entity->should_render_wireframe());
}

void D3D12MaterialManager::clear()
{
    materials_.clear();
}

}

```

`src/graphics/d3d12/d3d12_mesh.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/d3d12/d3d12_mesh.h"

#include <memory>
#include <tuple>
#include <vector>

#include "directx/d3d12.h"
#include "directx/d3dx12.h"

#include "core/exception.h"
#include "graphics/vertex_attributes.h"

namespace
{

/**
 * Helper function to map engine attribute types to D3D12 types.
 *
 * @param type
 *   Engine type
 *
 * @returns
 *   D3D12 type.
 */
DXGI_FORMAT to_directx_format(iris::VertexAttributeType type)
{
    auto format = DXGI_FORMAT_UNKNOWN;

    switch (type)
    {
        case iris::VertexAttributeType::FLOAT_3: format = DXGI_FORMAT_R32G32B32_FLOAT; break;
        case iris::VertexAttributeType::FLOAT_4: format = DXGI_FORMAT_R32G32B32A32_FLOAT; break;
        case iris::VertexAttributeType::UINT32_1: format = DXGI_FORMAT_R32_UINT; break;
        case iris::VertexAttributeType::UINT32_4: format = DXGI_FORMAT_R32G32B32A32_UINT; break;
        default: throw iris::Exception("unknown vertex attribute type");
    }

    return format;
}
}

namespace iris
{

D3D12Mesh::D3D12Mesh(
    const std::vector<VertexData> &vertices,
    const std::vector<std::uint32_t> &indices,
    const VertexAttributes &attributes)
    : Mesh(vertices, indices)
    , vertex_buffer_(vertices_)
    , index_buffer_(indices_)
    , input_descriptors_()
{
    // build a D3D12 descriptors from supplied attributes
    auto index = 0u;
    for (const auto &[type, _1, _2, offset] : attributes)
    {
        // the engine doesn't care too much about vertex semantics, so we just
        // call everything a TEXCOORD
        input_descriptors_.push_back(
            {"TEXCOORD",
             index,
             to_directx_format(type),
             0u,
             static_cast<UINT>(offset),
             D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA,
             0u});

        ++index;
    }
}

void D3D12Mesh::update_vertex_data(const std::vector<VertexData> &data)
{
    vertex_buffer_.write(data);
}

void D3D12Mesh::update_index_data(const std::vector<std::uint32_t> &data)
{
    index_buffer_.write(data);
}

const D3D12Buffer &D3D12Mesh::vertex_buffer() const
{
    return vertex_buffer_;
}

const D3D12Buffer &D3D12Mesh::index_buffer() const
{
    return index_buffer_;
}

std::vector<D3D12_INPUT_ELEMENT_DESC> D3D12Mesh::input_descriptors() const
{
    return input_descriptors_;
}

}

```

`src/graphics/d3d12/d3d12_mesh_manager.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/d3d12/d3d12_mesh_manager.h"

#include <cstdint>
#include <memory>

#include "core/resource_manager.h"
#include "graphics/d3d12/d3d12_mesh.h"
#include "graphics/mesh.h"
#include "graphics/mesh_manager.h"
#include "graphics/vertex_data.h"

namespace iris
{

D3D12MeshManager::D3D12MeshManager(ResourceManager &resource_manager)
    : MeshManager(resource_manager, false)
{
}

std::unique_ptr<Mesh> D3D12MeshManager::create_mesh(
    const std::vector<iris::VertexData> &vertices,
    const std::vector<std::uint32_t> &indices) const
{
    return std::make_unique<D3D12Mesh>(vertices, indices, DefaultVertexAttributes);
}

}

```

`src/graphics/d3d12/d3d12_render_target.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/d3d12/d3d12_render_target.h"

#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <Windowsx.h>

#include "graphics/d3d12/d3d12_context.h"
#include "graphics/d3d12/d3d12_descriptor_handle.h"
#include "graphics/d3d12/d3d12_descriptor_manager.h"
#include "graphics/d3d12/d3d12_texture.h"
#include "graphics/texture.h"

namespace iris
{

D3D12RenderTarget::D3D12RenderTarget(const Texture *colour_texture, const Texture *depth_texture)
    : RenderTarget(colour_texture, depth_texture)
    , handle_()
{
    auto *device = D3D12Context::device();

    handle_ = D3D12DescriptorManager::cpu_allocator(D3D12_DESCRIPTOR_HEAP_TYPE_RTV).allocate_static();

    device->CreateRenderTargetView(
        static_cast<const D3D12Texture *>(colour_texture_)->resource(), nullptr, handle_.cpu_handle());
}

D3D12DescriptorHandle D3D12RenderTarget::handle() const
{
    return handle_;
}

}

```

`src/graphics/d3d12/d3d12_render_target_manager.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/d3d12/d3d12_render_target_manager.h"

#include "graphics/d3d12/d3d12_render_target.h"
#include "graphics/d3d12/d3d12_texture.h"
#include "graphics/sampler.h"
#include "graphics/texture_manager.h"
#include "graphics/window.h"
#include "graphics/window_manager.h"

namespace iris
{

D3D12RenderTargetManager::D3D12RenderTargetManager(WindowManager &window_manager, TextureManager &texture_manager)
    : window_manager_(window_manager)
    , texture_manager_(texture_manager)
    , render_targets_()
{
}

RenderTarget *D3D12RenderTargetManager::create()
{
    const auto *window = window_manager_.current_window();
    return create(window->width(), window->height());
}

RenderTarget *D3D12RenderTargetManager::create(std::uint32_t width, std::uint32_t height)
{
    const auto scale = window_manager_.current_window()->screen_scale();
    const auto *sampler = texture_manager_.create(SamplerDescriptor{.uses_mips = false});
    const auto *depth_sampler = texture_manager_.create(SamplerDescriptor{
        .s_address_mode = SamplerAddressMode::CLAMP_TO_BORDER,
        .t_address_mode = SamplerAddressMode::CLAMP_TO_BORDER,
        .border_colour = Colour{1.0f, 1.0f, 1.0f, 1.0f},
        .uses_mips = false});

    return render_targets_
        .emplace_back(std::make_unique<D3D12RenderTarget>(
            texture_manager_.create(DataBuffer{}, width * scale, height * scale, TextureUsage::RENDER_TARGET, sampler),
            texture_manager_.create(DataBuffer{}, width * scale, height * scale, TextureUsage::DEPTH, depth_sampler)))
        .get();
}

RenderTarget *D3D12RenderTargetManager::create(const RenderTarget *colour_target, const RenderTarget *depth_target)
{
    return render_targets_
        .emplace_back(
            std::make_unique<D3D12RenderTarget>(colour_target->colour_texture(), depth_target->depth_texture()))
        .get();
}

}

```

`src/graphics/d3d12/d3d12_renderer.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/d3d12/d3d12_renderer.h"

#include <algorithm>
#include <array>
#include <cassert>
#include <cstdint>
#include <deque>
#include <iostream>
#include <map>
#include <ranges>
#include <unordered_map>
#include <vector>

#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <Windowsx.h>
#include <dxgi1_6.h>
#include <hidusage.h>
#include <wrl.h>

#include "directx/d3d12.h"
#include "directx/d3dx12.h"

#include "core/error_handling.h"
#include "graphics/constant_buffer_writer.h"
#include "graphics/d3d12/d3d12_constant_buffer.h"
#include "graphics/d3d12/d3d12_context.h"
#include "graphics/d3d12/d3d12_cube_map.h"
#include "graphics/d3d12/d3d12_descriptor_manager.h"
#include "graphics/d3d12/d3d12_material.h"
#include "graphics/d3d12/d3d12_mesh.h"
#include "graphics/d3d12/d3d12_render_target.h"
#include "graphics/d3d12/d3d12_sampler.h"
#include "graphics/d3d12/d3d12_texture.h"
#include "graphics/mesh_manager.h"
#include "graphics/render_command_type.h"
#include "graphics/render_entity.h"
#include "graphics/render_graph/sky_box_node.h"
#include "graphics/render_graph/texture_node.h"
#include "graphics/single_entity.h"
#include "graphics/texture.h"
#include "graphics/texture_manager.h"
#include "graphics/window.h"
#include "graphics/window_manager.h"
#include "log/log.h"

#pragma comment(lib, "dxgi.lib")
#pragma comment(lib, "d3d12.lib")
#pragma comment(lib, "dxguid.lib")

namespace
{

// this matrix is used to translate projection matrices from engine NDC to
// d3d12 NDC
static const iris::Matrix4 directx_translate{
    {1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.5f, 0.5f, 0.0f, 0.0f, 0.0f, 1.0f}};

/**
 * Helper function to write entity data to buffers.
 *
 * @param bone_buffer
 *   D3D12ConstantBuffer object to write bone data to.
 *
 * @param model_buffer
 *   D3D12StructuredBuffer object to write model data to.
 *
 * @param entity
 *   Entity being rendered.
 */
void write_entity_data_constant_buffer(
    iris::D3D12ConstantBuffer &bone_buffer,
    iris::D3D12StructuredBuffer &model_buffer,
    const iris::RenderEntity *entity)
{
    static std::vector<iris::Matrix4> default_bones(100u);

    iris::ConstantBufferWriter writer(bone_buffer);

    if (entity->type() == iris::RenderEntityType::SINGLE)
    {
        const auto *single_entity = static_cast<const iris::SingleEntity *>(entity);

        if (single_entity->skeleton() != nullptr)
        {
            const auto &bones = single_entity->skeleton()->transforms();
            writer.write(bones);
        }
        else
        {
            writer.write(default_bones);
        }

        iris::ConstantBufferWriter writer2(model_buffer);
        writer2.write(single_entity->transform());
        writer2.write(single_entity->normal_transform());
    }
    else
    {
        writer.write(default_bones);
    }
}

/**
 * Helper function to write light specific data to a constant buffer.
 *
 * @param constant_buffer
 *   D3D12ConstantBuffer object to write to.
 *
 * @param light
 *   Light to get data from.
 */
void write_light_data_constant_buffer(iris::D3D12ConstantBuffer &constant_buffer, const iris::Light *light)
{
    iris::ConstantBufferWriter writer(constant_buffer);

    if (light->type() == iris::LightType::DIRECTIONAL)
    {
        const auto *d3d12_light = static_cast<const iris::DirectionalLight *>(light);

        writer.write(directx_translate * d3d12_light->shadow_camera().projection());
        writer.write(d3d12_light->shadow_camera().view());
    }
    else
    {
        writer.advance(sizeof(iris::Matrix4) * 2u);
    }

    writer.write(light->colour_data());
    writer.write(light->world_space_data());
    writer.write(light->attenuation_data());
    writer.write(0.0f);
}

/**
 * Helper function to copy a descriptor handle.
 *
 * @param dest
 *   Where to write the descriptor to. This is advanced by descriptor_size.
 *
 * @param source
 *   Source handle to copy from.
 *
 * @param descriptor_size
 *   Size of the descriptor handle.
 *
 * @param heap_type
 *   Type of heap being copied to.
 */
void copy_descriptor(
    D3D12_CPU_DESCRIPTOR_HANDLE &dest,
    const iris::D3D12DescriptorHandle &source,
    std::size_t descriptor_size,
    D3D12_DESCRIPTOR_HEAP_TYPE heap_type)
{
    auto *device = iris::D3D12Context::device();

    device->CopyDescriptorsSimple(1u, dest, source.cpu_handle(), heap_type);

    dest.ptr += descriptor_size;
}

/**
 * Helper function to encode commands for uploading textures.
 *
 * @param texture_manager
 *   Texture manager object.
 *
 * @param uploaded_textures
 *   Set of all textures that have been uploaded (will be updated).
 *
 * @param uploaded_cube_maps
 *   Set of all cube maps that have been uploaded (will be updated).
 *
 * @param command_list
 *   D3D12 command list to encode command to.
 */
void upload_textures(
    iris::TextureManager &texture_manager,
    std::set<const iris::D3D12Texture *> &uploaded_textures,
    std::set<const iris::D3D12CubeMap *> &uploaded_cube_maps,
    ID3D12GraphicsCommandList *command_list)
{
    // encode commands to copy all textures to their target heaps
    for (auto *texture :
         texture_manager.textures() | std::views::filter(
                                          [](const auto *element)
                                          {
                                              return !(
                                                  (element->usage() == iris::TextureUsage::RENDER_TARGET) ||
                                                  (element->usage() == iris::TextureUsage::DEPTH));
                                          }))
    {
        const auto *d3d12_tex = static_cast<const iris::D3D12Texture *>(texture);

        // only upload once
        if (!uploaded_textures.contains(d3d12_tex))
        {
            uploaded_textures.emplace(d3d12_tex);

            const auto footprints = d3d12_tex->footprints();

            for (auto i = 0u; i < footprints.size(); ++i)
            {
                D3D12_TEXTURE_COPY_LOCATION destination = {};
                destination.pResource = d3d12_tex->resource();
                destination.Type = D3D12_TEXTURE_COPY_TYPE_SUBRESOURCE_INDEX;
                destination.SubresourceIndex = i;

                D3D12_TEXTURE_COPY_LOCATION source = {};
                source.pResource = d3d12_tex->upload();
                source.Type = D3D12_TEXTURE_COPY_TYPE_PLACED_FOOTPRINT;
                source.PlacedFootprint = footprints[i];

                command_list->CopyTextureRegion(&destination, 0u, 0u, 0u, &source, NULL);
            }

            const auto barrier = ::CD3DX12_RESOURCE_BARRIER::Transition(
                d3d12_tex->resource(), D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE);

            command_list->ResourceBarrier(1u, &barrier);
        }
    }

    // encode commands to copy all cube maps to their target heaps
    for (auto *cube_map : texture_manager.cube_maps())
    {
        const auto *d3d12_cube_map = static_cast<const iris::D3D12CubeMap *>(cube_map);

        // encode commands to copy all cube map textures to their target heaps
        if (!uploaded_cube_maps.contains(d3d12_cube_map))
        {
            uploaded_cube_maps.emplace(d3d12_cube_map);

            // encode a copy command for each face
            UINT index = 0u;
            for (const auto &footprint : d3d12_cube_map->footprints())
            {
                D3D12_TEXTURE_COPY_LOCATION destination = {};
                destination.pResource = d3d12_cube_map->resource();
                destination.Type = D3D12_TEXTURE_COPY_TYPE_SUBRESOURCE_INDEX;
                destination.SubresourceIndex = index++;

                D3D12_TEXTURE_COPY_LOCATION source = {};
                source.pResource = d3d12_cube_map->upload();
                source.Type = D3D12_TEXTURE_COPY_TYPE_PLACED_FOOTPRINT;
                source.PlacedFootprint = footprint;

                command_list->CopyTextureRegion(&destination, 0u, 0u, 0u, &source, NULL);
            }

            const auto barrier = ::CD3DX12_RESOURCE_BARRIER::Transition(
                d3d12_cube_map->resource(), D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE);

            command_list->ResourceBarrier(1u, &barrier);
        }
    }
}

/**
 * Helper function to build the texture table - a global GPU buffer of all textures (used for bindless rendering)
 *
 * @param texture_manager
 *   Texture manager object.
 *
 * @returns
 *   D3D12DescriptorHandle to a first element in table with all loaded textures.
 */
iris::D3D12DescriptorHandle create_texture_table(iris::TextureManager &texture_manager)
{
    const auto textures = texture_manager.textures();
    const auto max_index = textures.back()->index();
    const auto *blank_texture = static_cast<const iris::D3D12Texture *>(texture_manager.blank_texture());
    auto iter = std::cbegin(textures);

    // create table buffer
    auto texture_table = iris::D3D12DescriptorManager::gpu_allocator(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV)
                             .allocate_static(static_cast<std::uint32_t>(max_index + 1u));
    const auto descriptor_size =
        iris::D3D12DescriptorManager::gpu_allocator(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV).descriptor_size();
    auto texture_table_descriptor_start = texture_table.cpu_handle();

    for (auto i = 0u; i <= max_index; ++i)
    {
        // if a texture exits at the current index we write it in
        if (i == (*iter)->index())
        {
            const auto *d3d12_texture = static_cast<const iris::D3D12Texture *>(*iter);
            copy_descriptor(
                texture_table_descriptor_start,
                d3d12_texture->handle(),
                descriptor_size,
                D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
            ++iter;
        }
        else
        {
            // no texture at current index, so write default texture
            copy_descriptor(
                texture_table_descriptor_start,
                blank_texture->handle(),
                descriptor_size,
                D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
        }
    }

    return texture_table;
}

/**
 * Helper function to build the cube map table - a global GPU buffer of all cube maps (used for bindless rendering)
 *
 * @param texture_manager
 *   Texture manager object.
 *
 * @returns
 *   D3D12DescriptorHandle to a first element in table with all loaded cube maps.
 */
iris::D3D12DescriptorHandle create_cube_map_table(iris::TextureManager &texture_manager)
{
    const auto cube_maps = texture_manager.cube_maps();
    const auto max_index = cube_maps.back()->index();
    const auto *blank_cube_map = static_cast<const iris::D3D12CubeMap *>(texture_manager.blank_cube_map());
    auto iter = std::cbegin(cube_maps);

    auto cube_map_table = iris::D3D12DescriptorManager::gpu_allocator(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV)
                              .allocate_static(static_cast<std::uint32_t>(max_index + 1u));
    const auto descriptor_size =
        iris::D3D12DescriptorManager::gpu_allocator(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV).descriptor_size();
    auto cube_map_table_descriptor_start = cube_map_table.cpu_handle();

    for (auto i = 0u; i <= max_index; ++i)
    {
        // if a cube map exits at the current index we write it in
        if (i == (*iter)->index())
        {
            const auto *d3d12_cube_map = static_cast<const iris::D3D12CubeMap *>(*iter);
            copy_descriptor(
                cube_map_table_descriptor_start,
                d3d12_cube_map->handle(),
                descriptor_size,
                D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
            ++iter;
        }
        else
        {
            // no cube map at current index, so write default cube map
            copy_descriptor(
                cube_map_table_descriptor_start,
                blank_cube_map->handle(),
                descriptor_size,
                D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
        }
    }

    return cube_map_table;
}

/**
 * Helper function to build the sampler table - a global GPU buffer of all samplers (used for bindless rendering)
 *
 * @returns
 *   D3D12DescriptorHandle to a first element in table with all loaded samplers.
 */
iris::D3D12DescriptorHandle create_sampler_table(iris::TextureManager &texture_manager)
{
    const auto samplers = texture_manager.samplers();
    const auto max_index = samplers.back()->index();
    const auto *default_sampler = static_cast<const iris::D3D12Sampler *>(texture_manager.default_texture_sampler());
    auto iter = std::cbegin(samplers);

    // create table buffer
    auto sampler_table = iris::D3D12DescriptorManager::gpu_allocator(D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER)
                             .allocate_static(static_cast<std::uint32_t>(max_index + 1u));
    const auto descriptor_size =
        iris::D3D12DescriptorManager::gpu_allocator(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV).descriptor_size();
    auto sampler_table_descriptor_start = sampler_table.cpu_handle();

    for (auto i = 0u; i <= max_index; ++i)
    {
        // if a sampler exits at the current index we write it in
        if (i == (*iter)->index())
        {
            const auto *d3d12_sampler = static_cast<const iris::D3D12Sampler *>(*iter);
            copy_descriptor(
                sampler_table_descriptor_start,
                d3d12_sampler->handle(),
                descriptor_size,
                D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER);
            ++iter;
        }
        else
        {
            // no sampler at current index, so write default sampler
            copy_descriptor(
                sampler_table_descriptor_start,
                default_sampler->handle(),
                descriptor_size,
                D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER);
        }
    }

    return sampler_table;
}

}

namespace iris
{

D3D12Renderer::D3D12Renderer(
    WindowManager &window_manager,
    TextureManager &texture_manager,
    MaterialManager &material_manager,
    HWND window,
    std::uint32_t width,
    std::uint32_t height,
    std::uint32_t initial_screen_scale)
    : Renderer(material_manager)
    , window_manager_(window_manager)
    , texture_manager_(texture_manager)
    , width_(width)
    , height_(height)
    , frames_()
    , frame_index_(0u)
    , fence_(nullptr)
    , fence_event_()
    , command_queue_(nullptr)
    , command_list_(nullptr)
    , swap_chain_(nullptr)
    , viewport_()
    , scissor_rect_()
    , uploaded_textures_()
    , uploaded_cube_maps_()
    , instance_data_buffers_()
    , texture_table_()
    , cube_map_table_()
    , sampler_table_()
{
    // we will use triple buffering
    const auto num_frames = 3u;

    D3D12_COMMAND_QUEUE_DESC desc = {0};
    desc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;
    desc.Priority = D3D12_COMMAND_QUEUE_PRIORITY_NORMAL;
    desc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;
    desc.NodeMask = 0;

    auto *device = D3D12Context::device();
    auto *dxgi_factory = D3D12Context::dxgi_factory();

    // create command queue
    ensure(device->CreateCommandQueue(&desc, IID_PPV_ARGS(&command_queue_)) == S_OK, "could not create command queue");

    // build swap chain description
    DXGI_SWAP_CHAIN_DESC1 swap_chain_descriptor = {0};
    swap_chain_descriptor.Width = width_ * initial_screen_scale;
    swap_chain_descriptor.Height = height_ * initial_screen_scale;
    swap_chain_descriptor.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
    swap_chain_descriptor.Stereo = FALSE;
    swap_chain_descriptor.SampleDesc = {1, 0};
    swap_chain_descriptor.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
    swap_chain_descriptor.BufferCount = num_frames;
    swap_chain_descriptor.Scaling = DXGI_SCALING_STRETCH;
    swap_chain_descriptor.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;
    swap_chain_descriptor.AlphaMode = DXGI_ALPHA_MODE_UNSPECIFIED;
    swap_chain_descriptor.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING;

    // create swap chain for window
    Microsoft::WRL::ComPtr<IDXGISwapChain1> swap_chain_tmp = nullptr;
    ensure(
        dxgi_factory->CreateSwapChainForHwnd(
            command_queue_.Get(), window, &swap_chain_descriptor, nullptr, nullptr, &swap_chain_tmp) == S_OK,
        "could not create swap chain");

    // cast to type we want to use
    ensure(swap_chain_tmp.As(&swap_chain_) == S_OK, "could not cast swap chain");

    // get initial frame index
    frame_index_ = swap_chain_->GetCurrentBackBufferIndex();

    // build our frame buffers
    for (auto i = 0u; i < num_frames; ++i)
    {
        // get a back buffer
        Microsoft::WRL::ComPtr<ID3D12Resource> frame = nullptr;
        ensure(swap_chain_->GetBuffer(i, IID_PPV_ARGS(&frame)) == S_OK, "could not get back buffer");

        static int counter = 0;
        std::wstringstream strm{};
        strm << L"frame_" << counter++;
        const auto name = strm.str();
        frame->SetName(name.c_str());

        // create a static descriptor handle for the render target
        auto rtv_handle = D3D12DescriptorManager::cpu_allocator(D3D12_DESCRIPTOR_HEAP_TYPE_RTV).allocate_static();

        device->CreateRenderTargetView(frame.Get(), nullptr, rtv_handle.cpu_handle());

        Microsoft::WRL::ComPtr<ID3D12CommandAllocator> command_allocator = nullptr;

        // create command allocator, we use one per frame but have a single
        // command queue
        ensure(
            device->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&command_allocator)) == S_OK,
            "could not create command allocator");

        const auto *rt_sampler = texture_manager_.create(SamplerDescriptor{
            .s_address_mode = SamplerAddressMode::CLAMP_TO_BORDER,
            .t_address_mode = SamplerAddressMode::CLAMP_TO_BORDER,
            .border_colour = Colour{1.0f, 1.0f, 1.0f, 1.0f},
            .uses_mips = false});

        frames_.emplace_back(
            i,
            frame,
            rtv_handle,
            std::make_unique<D3D12Texture>(
                DataBuffer{},
                width_ * initial_screen_scale,
                height_ * initial_screen_scale,
                rt_sampler,
                TextureUsage::DEPTH,
                texture_manager_.next_texture_index()),
            command_allocator);
    }

    // create a fence, used to signal when gpu has completed a frame
    ensure(
        device->CreateFence(frames_[frame_index_].fence_value, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&fence_)) == S_OK,
        "could not create fence");
    fence_event_ = {::CreateEventA(NULL, FALSE, FALSE, NULL), ::CloseHandle};
    ++frames_[frame_index_].fence_value;

    command_queue_->Signal(fence_.Get(), frames_[frame_index_].fence_value);
    fence_->SetEventOnCompletion(frames_[frame_index_].fence_value, fence_event_);
    ::WaitForSingleObject(fence_event_, INFINITE);
    ++frames_[frame_index_].fence_value;

    ensure(
        device->CreateCommandList(
            0u,
            D3D12_COMMAND_LIST_TYPE_DIRECT,
            frames_[frame_index_].command_allocator.Get(),
            nullptr,
            IID_PPV_ARGS(&command_list_)) == S_OK,
        "could not create command list");

    // close the list so we can start recording to it
    command_list_->Close();
}

D3D12Renderer::~D3D12Renderer()
{
    // block and wait for current frame to finish - this prevents us unloading resources whilst the gpu is still using
    // them
    command_queue_->Signal(fence_.Get(), frames_[frame_index_].fence_value);
    fence_->SetEventOnCompletion(frames_[frame_index_].fence_value, fence_event_);
    ::WaitForSingleObject(fence_event_, INFINITE);
    ++frames_[frame_index_].fence_value;
}

void D3D12Renderer::do_set_render_pipeline(std::function<void()> build_queue)
{
    command_queue_->Signal(fence_.Get(), frames_[frame_index_].fence_value);
    fence_->SetEventOnCompletion(frames_[frame_index_].fence_value, fence_event_);
    ::WaitForSingleObject(fence_event_, INFINITE);
    ++frames_[frame_index_].fence_value;

    build_queue();

    instance_data_buffers_.clear();

    for (auto &frame : frames_)
    {
        frame.model_data_buffers.clear();
    }

    // create structured buffers for any instanced entities in the scene
    for (const auto &command : render_queue_)
    {
        if (command.type() == RenderCommandType::DRAW)
        {
            const auto *render_entity = command.render_entity();

            if (render_entity->type() == RenderEntityType::INSTANCED)
            {
                const auto *instanced_entity = static_cast<const InstancedEntity *>(render_entity);
                instance_data_buffers_[render_entity] =
                    std::make_unique<D3D12StructuredBuffer>(instanced_entity->data().size(), sizeof(Matrix4) * 2u);

                ConstantBufferWriter writer{*instance_data_buffers_[render_entity]};

                writer.write(instanced_entity->data());
            }
        }
    }

    texture_table_ = create_texture_table(texture_manager_);
    cube_map_table_ = create_cube_map_table(texture_manager_);
    sampler_table_ = create_sampler_table(texture_manager_);
}

void D3D12Renderer::pre_render()
{
    auto &frame = frames_[frame_index_];

    // reset command allocator and list for new frame
    frame.command_allocator->Reset();
    command_list_->Reset(frame.command_allocator.Get(), nullptr);

    // reset descriptor allocations for new frame
    D3D12DescriptorManager::gpu_allocator(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV).reset_dynamic(frame.frame_id);
    D3D12DescriptorManager::cpu_allocator(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV).reset_dynamic(frame.frame_id);

    // upload any new textures
    upload_textures(texture_manager_, uploaded_textures_, uploaded_cube_maps_, command_list_.Get());

    // clear frame specific buffers
    frame.bone_data_buffers.clear();
    frame.light_data_buffers.clear();
    frame.camera_data_buffers.clear();
    frame.property_buffers.clear();
}

void D3D12Renderer::execute_pass_start(RenderCommand &command)
{
    ID3D12DescriptorHeap *heaps[] = {
        D3D12DescriptorManager::gpu_allocator(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV).heap(),
        D3D12DescriptorManager::gpu_allocator(D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER).heap()};
    command_list_->SetDescriptorHeaps(_countof(heaps), heaps);

    // setup the render targets, which are:
    // - colour
    // - screen space normals
    // - screen space positions
    //
    // note that they may not all be used
    std::uint32_t rt_count = 1u;
    D3D12_CPU_DESCRIPTOR_HANDLE rt_handles[3];
    D3D12_CPU_DESCRIPTOR_HANDLE depth_handle;

    auto *colour_target = static_cast<const D3D12RenderTarget *>(command.render_pass()->colour_target);
    auto *normal_target = static_cast<const D3D12RenderTarget *>(command.render_pass()->normal_target);
    auto *position_target = static_cast<const D3D12RenderTarget *>(command.render_pass()->position_target);

    const auto scale = window_manager_.current_window()->screen_scale();
    auto width = width_ * scale;
    auto height = height_ * scale;

    auto &frame = frames_[frame_index_];

    if (colour_target == nullptr)
    {
        rt_handles[0] = frame.render_target.cpu_handle();
        depth_handle = frame.depth_buffer->depth_handle().cpu_handle();

        // if the current frame is the default render target i.e. not one
        // manually created we need to transition it from PRESENT and make the
        // depth buffer writable
        const D3D12_RESOURCE_BARRIER barriers[] = {
            ::CD3DX12_RESOURCE_BARRIER::Transition(
                frame.buffer.Get(), D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET),
            ::CD3DX12_RESOURCE_BARRIER::Transition(
                frame.depth_buffer->resource(),
                D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE,
                D3D12_RESOURCE_STATE_DEPTH_WRITE)};

        command_list_->ResourceBarrier(2u, barriers);
    }
    else
    {
        width = colour_target->width();
        height = colour_target->height();

        rt_handles[0] = colour_target->handle().cpu_handle();
        depth_handle = static_cast<const D3D12Texture *>(colour_target->depth_texture())->depth_handle().cpu_handle();

        // if we are rendering to a custom render target we just need to make
        // its depth buffer writable

        const auto barrier = ::CD3DX12_RESOURCE_BARRIER::Transition(
            static_cast<const D3D12Texture *>(colour_target->depth_texture())->resource(),
            D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE,
            D3D12_RESOURCE_STATE_DEPTH_WRITE);

        command_list_->ResourceBarrier(1u, &barrier);
    }

    if (normal_target != nullptr)
    {
        rt_handles[1] = normal_target->handle().cpu_handle();
        rt_count = 2u;
    }

    if (position_target != nullptr)
    {
        rt_handles[2] = position_target->handle().cpu_handle();
        rt_count = 3u;
    }

    command_list_->OMSetRenderTargets(rt_count, rt_handles, FALSE, &depth_handle);

    // clear any supplied targets
    if (command.render_pass()->clear_colour)
    {
        static const Colour clear_colour{0.4f, 0.6f, 0.9f, 1.0f};
        command_list_->ClearRenderTargetView(rt_handles[0], reinterpret_cast<const FLOAT *>(&clear_colour), 0, nullptr);

        // for the extra targets we clear to black
        // this technically issues a d3d12 warning (which we supress) as clearing to a colour other that the one set
        // when the resource was created is less efficient, however:
        //  - for how often we will be doing it we will take the hit on performance
        //  - it simplifies the code

        if (normal_target != nullptr)
        {
            static const Colour normal_clear_colour{0.0f, 0.0f, 0.0f, 0.0f};
            command_list_->ClearRenderTargetView(
                rt_handles[1], reinterpret_cast<const FLOAT *>(&normal_clear_colour), 0, nullptr);
        }

        if (position_target != nullptr)
        {
            static const Colour position_clear_colour{0.0f, 0.0f, 0.0f, 0.0f};
            command_list_->ClearRenderTargetView(
                rt_handles[2], reinterpret_cast<const FLOAT *>(&position_clear_colour), 0, nullptr);
        }
    }
    if (command.render_pass()->clear_depth)
    {
        command_list_->ClearDepthStencilView(depth_handle, D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0u, 0u, nullptr);
    }

    command_list_->SetGraphicsRootSignature(D3D12Context::root_signature().handle());

    // update viewport incase it's changed for current render target
    viewport_ = CD3DX12_VIEWPORT{0.0f, 0.0f, static_cast<float>(width), static_cast<float>(height)};
    scissor_rect_ = CD3DX12_RECT{0u, 0u, static_cast<LONG>(width), static_cast<LONG>(height)};

    command_list_->RSSetViewports(1u, &viewport_);
    command_list_->RSSetScissorRects(1u, &scissor_rect_);
}

void D3D12Renderer::execute_pass_end(RenderCommand &command)
{
    const auto *target = static_cast<const D3D12RenderTarget *>(command.render_pass()->colour_target);

    if (target != nullptr)
    {
        // if we are rendering to a custom render target then we need to make
        // the depth buffer accessible to the shader
        const auto barrier = ::CD3DX12_RESOURCE_BARRIER::Transition(
            static_cast<const D3D12Texture *>(target->depth_texture())->resource(),
            D3D12_RESOURCE_STATE_DEPTH_WRITE,
            D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE);

        command_list_->ResourceBarrier(1u, &barrier);
    }
}

void D3D12Renderer::execute_draw(RenderCommand &command)
{
    const auto *entity = command.render_entity();
    const auto *material = static_cast<const D3D12Material *>(command.material());
    const auto *mesh = static_cast<const D3D12Mesh *>(entity->mesh());
    const auto *light = command.light();
    const auto *camera = command.render_pass()->camera;

    command_list_->SetPipelineState(material->pso());

    auto &frame = frames_[frame_index_];

    // any frame specific buffers that we are seeing for the first time need to be created

    if (!frame.bone_data_buffers.contains(entity))
    {
        frame.bone_data_buffers[entity] = std::make_unique<D3D12ConstantBuffer>(frame_index_, 7168u);
        frame.model_data_buffers[entity] =
            std::make_unique<D3D12StructuredBuffer>(1u, sizeof(Matrix4) * 2u, frame_index_);

        write_entity_data_constant_buffer(*frame.bone_data_buffers[entity], *frame.model_data_buffers[entity], entity);
    }

    if (!frame.light_data_buffers.contains(light))
    {
        frame.light_data_buffers[light] = std::make_unique<D3D12ConstantBuffer>(frame_index_, 256u);
        write_light_data_constant_buffer(*frame.light_data_buffers[light], light);
    }

    if (!frame.camera_data_buffers.contains(camera))
    {
        frame.camera_data_buffers[camera] = std::make_unique<D3D12ConstantBuffer>(frame_index_, 512u);

        // calculate view matrix for normals
        auto normal_view = Matrix4::transpose(Matrix4::invert(camera->view()));
        normal_view[3] = 0.0f;
        normal_view[7] = 0.0f;
        normal_view[11] = 0.0f;

        ConstantBufferWriter writer{*frame.camera_data_buffers[camera]};
        writer.write(directx_translate * camera->projection());
        writer.write(camera->view());
        writer.write(normal_view);
        writer.write(camera->position());
    }

    if (!frame.property_buffers.contains(material))
    {
        const auto property_buffer = material->property_buffer();
        frame.property_buffers[material] =
            std::make_unique<D3D12ConstantBuffer>(frame_index_, property_buffer.size_bytes());
        frame.property_buffers[material]->write(property_buffer.data(), property_buffer.size_bytes(), 0u);
    }

    auto *bone_buffer = frame.bone_data_buffers[entity].get();
    auto *light_buffer = frame.light_data_buffers[light].get();
    auto *model_buffer = (entity->type() != RenderEntityType::INSTANCED) ? frame.model_data_buffers[entity].get()
                                                                         : instance_data_buffers_[entity].get();
    auto *property_buffer = frame.property_buffers[material].get();
    auto *camera_buffer = frame.camera_data_buffers[camera].get();
    const auto shadow_map_index =
        (command.shadow_map() == nullptr) ? 0u : command.shadow_map()->depth_texture()->index();
    const auto shadow_map_sampler_index =
        (command.shadow_map() == nullptr) ? 0u : command.shadow_map()->depth_texture()->sampler()->index();

    const auto time_value = static_cast<float>(time().count()) / 1000.0f;

    // encode all out root signature arguments
    D3D12Context::root_signature().encode_arguments(
        command_list_.Get(),
        bone_buffer,
        light_buffer,
        camera_buffer,
        shadow_map_index,
        shadow_map_sampler_index,
        std::bit_cast<std::uint32_t>(time_value),
        property_buffer,
        model_buffer,
        texture_table_,
        cube_map_table_,
        sampler_table_);

    const auto vertex_view = mesh->vertex_buffer().vertex_view();
    const auto index_view = mesh->index_buffer().index_view();
    const auto num_indices = static_cast<UINT>(mesh->index_buffer().element_count());

    switch (entity->primitive_type())
    {
        case PrimitiveType::TRIANGLES:
            command_list_->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
            break;
        case PrimitiveType::LINES: command_list_->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_LINELIST); break;
    }

    const auto instance_count = (entity->type() == RenderEntityType::INSTANCED)
                                    ? static_cast<const InstancedEntity *>(entity)->instance_count()
                                    : 1u;

    command_list_->IASetVertexBuffers(0u, 1u, &vertex_view);
    command_list_->IASetIndexBuffer(&index_view);
    command_list_->DrawIndexedInstanced(num_indices, static_cast<UINT>(instance_count), 0u, 0u, 0u);
}

void D3D12Renderer::execute_present(RenderCommand &)
{
    auto &frame = frames_[frame_index_];

    // transition the frame render target to present and depth buffer to shader
    // visible
    const D3D12_RESOURCE_BARRIER barriers[] = {
        ::CD3DX12_RESOURCE_BARRIER::Transition(
            frame.buffer.Get(), D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT),
        ::CD3DX12_RESOURCE_BARRIER::Transition(
            frame.depth_buffer->resource(),
            D3D12_RESOURCE_STATE_DEPTH_WRITE,
            D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE)};

    command_list_->ResourceBarrier(2u, barriers);

    command_list_->Close();

    // execute command list
    ID3D12CommandList *const command_lists[] = {command_list_.Get()};
    command_queue_->ExecuteCommandLists(1u, command_lists);

    // present frame to window
    expect(swap_chain_->Present(0u, DXGI_PRESENT_ALLOW_TEARING) == S_OK, "could not present");

    const auto fence_value = frame.fence_value;
    expect(command_queue_->Signal(fence_.Get(), fence_value) == S_OK, "could not signal");

    frame_index_ = swap_chain_->GetCurrentBackBufferIndex();

    if (fence_->GetCompletedValue() < frames_[frame_index_].fence_value)
    {
        fence_->SetEventOnCompletion(frames_[frame_index_].fence_value, fence_event_);
        ::WaitForSingleObject(fence_event_, INFINITE);
    }

    frames_[frame_index_].fence_value = fence_value + 1u;
}

}

```

`src/graphics/d3d12/d3d12_sampler.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/d3d12/d3d12_sampler.h"

#include <cstdint>

#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <wrl.h>

#include "directx/d3d12.h"
#include "directx/d3dx12.h"

#include "core/error_handling.h"
#include "graphics/d3d12/d3d12_context.h"
#include "graphics/d3d12/d3d12_descriptor_handle.h"
#include "graphics/d3d12/d3d12_descriptor_manager.h"
#include "graphics/sampler.h"

namespace
{

/**
 * Helper function to convert an engine address mode to a D3D12 address mode.
 *
 * @param address_mode
 *   Engine address mode.
 *
 * @returns
 *   D3D12 address mode.
 */
D3D12_TEXTURE_ADDRESS_MODE to_d3d12(iris::SamplerAddressMode address_mode)
{
    switch (address_mode)
    {
        case iris::SamplerAddressMode::REPEAT: return D3D12_TEXTURE_ADDRESS_MODE_WRAP;
        case iris::SamplerAddressMode::MIRROR: return D3D12_TEXTURE_ADDRESS_MODE_MIRROR;
        case iris::SamplerAddressMode::CLAMP_TO_EDGE: return D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
        case iris::SamplerAddressMode::CLAMP_TO_BORDER: return D3D12_TEXTURE_ADDRESS_MODE_BORDER;
        default: throw iris::Exception("unknown address mode");
    }
}

/**
 * Helper method to convert an engine filter to a D3D12 filter.
 *
 * @param descriptor
 *   SamplerDescriptor.
 *
 * @returns
 *   D3D12 filter.
 */
D3D12_FILTER to_d3d12(const iris::SamplerDescriptor &descriptor)
{
    if ((descriptor.minification_filter == iris::SamplerFilter::NEAREST) &&
        (descriptor.magnification_filter == iris::SamplerFilter::NEAREST) &&
        (descriptor.mip_filter == iris::SamplerFilter::NEAREST))
    {
        return D3D12_FILTER_MIN_MAG_MIP_POINT;
    }
    else if (
        (descriptor.minification_filter == iris::SamplerFilter::NEAREST) &&
        (descriptor.magnification_filter == iris::SamplerFilter::NEAREST) &&
        (descriptor.mip_filter == iris::SamplerFilter::LINEAR))
    {
        return D3D12_FILTER_MIN_MAG_POINT_MIP_LINEAR;
    }
    else if (
        (descriptor.minification_filter == iris::SamplerFilter::NEAREST) &&
        (descriptor.magnification_filter == iris::SamplerFilter::LINEAR) &&
        (descriptor.mip_filter == iris::SamplerFilter::NEAREST))
    {
        return D3D12_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT;
    }
    else if (
        (descriptor.minification_filter == iris::SamplerFilter::NEAREST) &&
        (descriptor.magnification_filter == iris::SamplerFilter::LINEAR) &&
        (descriptor.mip_filter == iris::SamplerFilter::LINEAR))
    {
        return D3D12_FILTER_MIN_POINT_MAG_MIP_LINEAR;
    }
    else if (
        (descriptor.minification_filter == iris::SamplerFilter::LINEAR) &&
        (descriptor.magnification_filter == iris::SamplerFilter::NEAREST) &&
        (descriptor.mip_filter == iris::SamplerFilter::NEAREST))
    {
        return D3D12_FILTER_MIN_LINEAR_MAG_MIP_POINT;
    }
    else if (
        (descriptor.minification_filter == iris::SamplerFilter::LINEAR) &&
        (descriptor.magnification_filter == iris::SamplerFilter::NEAREST) &&
        (descriptor.mip_filter == iris::SamplerFilter::LINEAR))
    {
        return D3D12_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR;
    }
    else if (
        (descriptor.minification_filter == iris::SamplerFilter::LINEAR) &&
        (descriptor.magnification_filter == iris::SamplerFilter::LINEAR) &&
        (descriptor.mip_filter == iris::SamplerFilter::NEAREST))
    {
        return D3D12_FILTER_MIN_MAG_LINEAR_MIP_POINT;
    }
    else if (
        (descriptor.minification_filter == iris::SamplerFilter::LINEAR) &&
        (descriptor.magnification_filter == iris::SamplerFilter::LINEAR) &&
        (descriptor.mip_filter == iris::SamplerFilter::LINEAR))
    {
        return D3D12_FILTER_MIN_MAG_MIP_LINEAR;
    }

    throw iris::Exception("unknown filter combination");
}

}

namespace iris
{

D3D12Sampler::D3D12Sampler(const SamplerDescriptor &descriptor, std::uint32_t index)
    : Sampler(descriptor, index)
    , descriptor_(D3D12DescriptorManager::cpu_allocator(D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER).allocate_static())
{
    const D3D12_SAMPLER_DESC sampler{
        .Filter = to_d3d12(descriptor),
        .AddressU = to_d3d12(descriptor.s_address_mode),
        .AddressV = to_d3d12(descriptor.t_address_mode),
        .AddressW = to_d3d12(descriptor.r_address_mode),
        .MipLODBias = 0,
        .MaxAnisotropy = 0,
        .ComparisonFunc = D3D12_COMPARISON_FUNC_LESS,
        .BorderColor =
            {descriptor.border_colour.r,
             descriptor.border_colour.g,
             descriptor.border_colour.b,
             descriptor.border_colour.a},
        .MinLOD = 0.0f,
        .MaxLOD = D3D12_FLOAT32_MAX};

    D3D12Context::device()->CreateSampler(&sampler, descriptor_.cpu_handle());
}

D3D12Sampler::~D3D12Sampler()
{
    D3D12DescriptorManager::cpu_allocator(D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER).release_static(descriptor_);
}

D3D12DescriptorHandle D3D12Sampler::handle() const
{
    return descriptor_;
}

}

```

`src/graphics/d3d12/d3d12_structured_buffer.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/d3d12/d3d12_structured_buffer.h"

#include <cstddef>
#include <cstdint>
#include <optional>
#include <sstream>

#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <wrl.h>

#include "directx/d3d12.h"
#include "directx/d3dx12.h"

#include "core/error_handling.h"
#include "graphics/d3d12/d3d12_context.h"
#include "graphics/d3d12/d3d12_cpu_descriptor_handle_allocator.h"
#include "graphics/d3d12/d3d12_descriptor_handle.h"
#include "graphics/d3d12/d3d12_descriptor_manager.h"
#include "graphics/d3d12/d3d12_gpu_descriptor_handle_allocator.h"

namespace
{

/**
 * Helper function to create a D3D12 buffer on the upload heap.
 *
 * @param capacity
 *   Size of buffer (in bytes).
 *
 * @param resource
 *   A D3D12 handle to be set to the new resource.
 *
 * @param frame
 *   Optional name frame number - if supplied descriptor handle will be allocated for that frame, else it will be
 * statically allocated.
 *
 * @returns
 *   Descriptor handle to buffer.
 */
iris::D3D12DescriptorHandle create_resource(
    std::size_t capacity,
    Microsoft::WRL::ComPtr<ID3D12Resource> &resource,
    std::optional<std::uint32_t> frame)
{
    const auto upload_heap = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
    const auto heap_descriptor = CD3DX12_RESOURCE_DESC::Buffer(capacity);

    auto *device = iris::D3D12Context::device();

    // create the buffer
    const auto commit_resource = device->CreateCommittedResource(
        &upload_heap,
        D3D12_HEAP_FLAG_NONE,
        &heap_descriptor,
        D3D12_RESOURCE_STATE_GENERIC_READ,
        nullptr,
        IID_PPV_ARGS(&resource));
    iris::expect(commit_resource == S_OK, "could not create constant buffer");

    // name resource
    static int counter = 0;
    std::wstringstream strm{};
    strm << L"sb_" << counter++;
    const auto name = strm.str();
    resource->SetName(name.c_str());

    // allocate descriptor for buffer
    return frame
               ? iris::D3D12DescriptorManager::cpu_allocator(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV)
                     .allocate_dynamic(*frame)
               : iris::D3D12DescriptorManager::cpu_allocator(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV).allocate_static();
}

}

namespace iris
{

D3D12StructuredBuffer::D3D12StructuredBuffer(std::size_t object_count, std::size_t object_size)
    : capacity_(object_count * object_size)
    , mapped_buffer_(nullptr)
    , resource_(nullptr)
    , descriptor_handle_(create_resource(capacity_, resource_, std::nullopt))
    , static_descriptor_(true)
{
    auto *device = D3D12Context::device();

    D3D12_SHADER_RESOURCE_VIEW_DESC srv_descriptor = {0};
    srv_descriptor.Format = DXGI_FORMAT_UNKNOWN;
    srv_descriptor.ViewDimension = D3D12_SRV_DIMENSION_BUFFER;
    srv_descriptor.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
    srv_descriptor.Buffer.FirstElement = 0;
    srv_descriptor.Buffer.NumElements = static_cast<UINT>(object_count);
    srv_descriptor.Buffer.StructureByteStride = static_cast<UINT>(object_size);
    srv_descriptor.Buffer.Flags = D3D12_BUFFER_SRV_FLAG_NONE;

    // create a view onto the buffer
    device->CreateShaderResourceView(resource_.Get(), &srv_descriptor, descriptor_handle_.cpu_handle());

    // map the buffer to the cpu so we can write to it
    const auto map_resource = resource_->Map(0u, NULL, reinterpret_cast<void **>(&mapped_buffer_));
    expect(map_resource == S_OK, "failed to map constant buffer");
}

D3D12StructuredBuffer::D3D12StructuredBuffer(std::size_t object_count, std::size_t object_size, std::uint32_t frame)
    : capacity_(object_count * object_size)
    , mapped_buffer_(nullptr)
    , resource_(nullptr)
    , descriptor_handle_(create_resource(capacity_, resource_, frame))
    , static_descriptor_(false)
{
    auto *device = D3D12Context::device();

    D3D12_SHADER_RESOURCE_VIEW_DESC srv_descriptor = {0};
    srv_descriptor.Format = DXGI_FORMAT_UNKNOWN;
    srv_descriptor.ViewDimension = D3D12_SRV_DIMENSION_BUFFER;
    srv_descriptor.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
    srv_descriptor.Buffer.FirstElement = 0;
    srv_descriptor.Buffer.NumElements = static_cast<UINT>(object_count);
    srv_descriptor.Buffer.StructureByteStride = static_cast<UINT>(object_size);
    srv_descriptor.Buffer.Flags = D3D12_BUFFER_SRV_FLAG_NONE;

    // create a view onto the buffer
    device->CreateShaderResourceView(resource_.Get(), &srv_descriptor, descriptor_handle_.cpu_handle());

    // map the buffer to the cpu so we can write to it
    const auto map_resource = resource_->Map(0u, NULL, reinterpret_cast<void **>(&mapped_buffer_));
    expect(map_resource == S_OK, "failed to map constant buffer");
}

D3D12StructuredBuffer::~D3D12StructuredBuffer()
{
    if (static_descriptor_)
    {
        iris::D3D12DescriptorManager::cpu_allocator(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV)
            .release_static(descriptor_handle_);
    }
}

D3D12DescriptorHandle D3D12StructuredBuffer::descriptor_handle() const
{
    return descriptor_handle_;
}

}

```

`src/graphics/d3d12/d3d12_texture.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/d3d12/d3d12_texture.h"

#include <sstream>

#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <wrl.h>

#include "directx/d3d12.h"
#include "directx/d3dx12.h"

#include "core/colour.h"
#include "core/error_handling.h"
#include "graphics/d3d12/d3d12_context.h"
#include "graphics/d3d12/d3d12_descriptor_handle.h"
#include "graphics/d3d12/d3d12_descriptor_manager.h"
#include "graphics/sampler.h"
#include "graphics/texture_usage.h"
#include "graphics/utils.h"

namespace
{

/**
 * Helper function to set the name of the ID3D12Resource.
 *
 * The prefix will have a unique integer appended, hence why this is templated,
 * so each enum type gets its own range of numbers.
 *
 * @param prefix
 *   Prefix for name.
 *
 * @param resource
 *   The resource to set the name of.
 */
template <iris::TextureUsage T>
void set_name(const std::wstring &prefix, ID3D12Resource *resource)
{
    static int counter = 0;

    std::wstringstream strm{};
    strm << prefix << L"_" << counter++;
    const auto name = strm.str();

    resource->SetName(name.c_str());
}

/**
 * Helper function to create a d3d12 resource description suitable for the
 * texture usage.
 *
 * @param width
 *   Width of texture.
 *
 * @param height
 *   Height of texture.
 *
 * @param mip_count
 *   The number of mipmap levels.
 *
 * @param resource
 *   Handle to store created resource in.
 *
 * @returns
 *   D3D12_RESOURCE_DESC for texture.
 */
D3D12_RESOURCE_DESC image_texture_descriptor(
    std::uint32_t width,
    std::uint32_t height,
    std::size_t mip_count,
    Microsoft::WRL::ComPtr<ID3D12Resource> &resource)
{
    auto *device = iris::D3D12Context::device();
    const auto default_heap = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT);

    D3D12_RESOURCE_DESC texture_description{};
    texture_description.Format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
    texture_description.Width = width;
    texture_description.Height = height;
    texture_description.Flags = D3D12_RESOURCE_FLAG_NONE;
    texture_description.DepthOrArraySize = 1;
    texture_description.MipLevels = static_cast<UINT16>(mip_count);
    texture_description.SampleDesc.Count = 1;
    texture_description.SampleDesc.Quality = 0;
    texture_description.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
    texture_description.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN;
    texture_description.Alignment = 0;

    // create a resource where image data will be coped to
    iris::expect(
        device->CreateCommittedResource(
            &default_heap,
            D3D12_HEAP_FLAG_NONE,
            &texture_description,
            D3D12_RESOURCE_STATE_COPY_DEST,
            nullptr,
            IID_PPV_ARGS(&resource)) == S_OK,
        "could not create resource");

    set_name<iris::TextureUsage::IMAGE>(L"tex", resource.Get());

    return texture_description;
}

/**
 * Helper function to create a d3d12 resource description suitable for the
 * data usage.
 *
 * @param width
 *   Width of texture.
 *
 * @param height
 *   Height of texture.
 *
 * @param mip_count
 *   The number of mipmap levels.
 *
 * @param resource
 *   Handle to store created resource in.
 *
 * @returns
 *   D3D12_RESOURCE_DESC for texture.
 */
D3D12_RESOURCE_DESC data_texture_descriptor(
    std::uint32_t width,
    std::uint32_t height,
    std::size_t mip_count,
    Microsoft::WRL::ComPtr<ID3D12Resource> &resource)
{
    auto *device = iris::D3D12Context::device();
    const auto default_heap = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT);

    D3D12_RESOURCE_DESC texture_description{};
    texture_description.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
    texture_description.Width = width;
    texture_description.Height = height;
    texture_description.Flags = D3D12_RESOURCE_FLAG_NONE;
    texture_description.DepthOrArraySize = 1;
    texture_description.MipLevels = static_cast<UINT16>(mip_count);
    texture_description.SampleDesc.Count = 1;
    texture_description.SampleDesc.Quality = 0;
    texture_description.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
    texture_description.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN;
    texture_description.Alignment = 0;

    // create a resource where image data will be coped to
    iris::expect(
        device->CreateCommittedResource(
            &default_heap,
            D3D12_HEAP_FLAG_NONE,
            &texture_description,
            D3D12_RESOURCE_STATE_COPY_DEST,
            nullptr,
            IID_PPV_ARGS(&resource)) == S_OK,
        "could not create resource");

    set_name<iris::TextureUsage::IMAGE>(L"tex", resource.Get());

    return texture_description;
}

/**
 * Helper function to create a d3d12 resource description suitable for the
 * render target usage.
 *
 * @param width
 *   Width of texture.
 *
 * @param height
 *   Height of texture.
 *
 * @param resource
 *   Handle to store created resource in.
 *
 * @returns
 *   D3D12_RESOURCE_DESC for texture.
 */
D3D12_RESOURCE_DESC
render_target_texture_descriptor(
    std::uint32_t width,
    std::uint32_t height,
    Microsoft::WRL::ComPtr<ID3D12Resource> &resource)
{
    auto *device = iris::D3D12Context::device();
    const auto default_heap = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT);

    D3D12_RESOURCE_DESC texture_description{};
    texture_description.Format = DXGI_FORMAT_R16G16B16A16_FLOAT;
    texture_description.Width = width;
    texture_description.Height = height;
    texture_description.Flags = D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET;
    texture_description.DepthOrArraySize = 1;
    texture_description.MipLevels = 1;
    texture_description.SampleDesc.Count = 1;
    texture_description.SampleDesc.Quality = 0;
    texture_description.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
    texture_description.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN;
    texture_description.Alignment = 0;

    const iris::Colour clear_colour{0.4f, 0.6f, 0.9f, 1.0f};
    D3D12_CLEAR_VALUE clear_value = {0};
    clear_value.Format = texture_description.Format;
    std::memcpy(&clear_value.Color, &clear_colour, sizeof(clear_colour));

    // create a resource where image data will be coped to
    iris::expect(
        device->CreateCommittedResource(
            &default_heap,
            D3D12_HEAP_FLAG_NONE,
            &texture_description,
            D3D12_RESOURCE_STATE_RENDER_TARGET,
            &clear_value,
            IID_PPV_ARGS(&resource)) == S_OK,
        "could not create resource");

    set_name<iris::TextureUsage::IMAGE>(L"rt", resource.Get());

    return texture_description;
}

/**
 * Helper function to create a d3d12 resource description suitable for the
 * depth usage.
 *
 * @param width
 *   Width of texture.
 *
 * @param height
 *   Height of texture.
 *
 * @param resource
 *   Handle to store created resource in.
 *
 * @returns
 *   D3D12_RESOURCE_DESC for texture.
 */
D3D12_RESOURCE_DESC depth_texture_descriptor(
    std::uint32_t width,
    std::uint32_t height,
    Microsoft::WRL::ComPtr<ID3D12Resource> &resource)
{
    auto *device = iris::D3D12Context::device();
    const auto default_heap = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT);

    D3D12_RESOURCE_DESC texture_description{};
    texture_description.Format = DXGI_FORMAT_R24G8_TYPELESS;
    texture_description.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
    texture_description.Alignment = 0;
    texture_description.Width = width;
    texture_description.Height = height;
    texture_description.DepthOrArraySize = 1;
    texture_description.MipLevels = 1;
    texture_description.SampleDesc.Count = 1;
    texture_description.SampleDesc.Quality = 0;
    texture_description.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN;
    texture_description.Flags = D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;

    D3D12_CLEAR_VALUE clear_value = {};
    clear_value.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
    clear_value.DepthStencil.Depth = 1.0f;
    clear_value.DepthStencil.Stencil = 0u;

    iris::expect(
        device->CreateCommittedResource(
            &default_heap,
            D3D12_HEAP_FLAG_NONE,
            &texture_description,
            D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE,
            &clear_value,
            IID_PPV_ARGS(&resource)) == S_OK,
        "could not create resource");

    set_name<iris::TextureUsage::IMAGE>(L"depth", resource.Get());

    return texture_description;
}

}

namespace iris
{

D3D12Texture::D3D12Texture(
    const DataBuffer &data,
    std::uint32_t width,
    std::uint32_t height,
    const Sampler *sampler,
    TextureUsage usage,
    std::uint32_t index)
    : Texture(data, width, height, sampler, usage, index)
    , resource_()
    , upload_()
    , resource_view_()
    , depth_resource_view_()
    , footprints_()
    , type_()
{
    auto *device = D3D12Context::device();
    const auto default_heap = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT);

    std::vector<MipLevelData> mip_levels{{.data = data, .width = width_, .height = height_}};

    if (sampler->descriptor().uses_mips)
    {
        mip_levels = generate_mip_maps(mip_levels.front());
    }

    const auto mip_count = mip_levels.size();
    footprints_.resize(mip_count);

    const auto texture_description = [this, usage, mip_count]() {
        switch (usage)
        {
            case TextureUsage::IMAGE: return image_texture_descriptor(width_, height_, mip_count, resource_); break;
            case TextureUsage::DATA: return data_texture_descriptor(width_, height_, mip_count, resource_); break;
            case TextureUsage::RENDER_TARGET:
                return render_target_texture_descriptor(width_, height_, resource_);
                break;
            case TextureUsage::DEPTH: return depth_texture_descriptor(width_, height_, resource_); break;
            default: throw Exception("unknown texture usage");
        }
    }();

    // finish off setting up the resource, note that DEPTH has some some special
    // case handling

    if (usage != TextureUsage::DEPTH)
    {
        const UINT64 capacity = GetRequiredIntermediateSize(resource_.Get(), 0, static_cast<UINT>(mip_count));

        const auto upload_heap = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
        const auto heap_description = CD3DX12_RESOURCE_DESC::Buffer(capacity);

        // create resource for initial upload of texture data
        expect(
            device->CreateCommittedResource(
                &upload_heap,
                D3D12_HEAP_FLAG_NONE,
                &heap_description,
                D3D12_RESOURCE_STATE_GENERIC_READ,
                nullptr,
                IID_PPV_ARGS(&upload_)) == S_OK,
            "could not create resource");

        type_ = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;

        resource_view_ = D3D12DescriptorManager::cpu_allocator(type_).allocate_static();

        device->CreateShaderResourceView(resource_.Get(), NULL, resource_view_.cpu_handle());

        // map the upload buffer so we can write to it
        void *mapped_buffer = nullptr;
        expect(
            upload_->Map(0u, NULL, reinterpret_cast<void **>(&mapped_buffer)) == S_OK, "failed to map constant buffer");

        if (!data.empty())
        {
            std::vector<UINT> heights(mip_count);
            std::vector<UINT64> row_size(mip_count);

            // create footprint for image data layout
            std::uint64_t memory_size = 0u;
            device->GetCopyableFootprints(
                &texture_description,
                0,
                static_cast<UINT>(mip_count),
                0,
                footprints_.data(),
                heights.data(),
                row_size.data(),
                &memory_size);

            // copy texture data with respect to each footprint
            for (auto i = 0u; i < mip_count; ++i)
            {
                const auto &footprint = footprints_[i];

                const auto sub_resource_height = heights[i];
                const auto sub_resource_pitch = footprint.Footprint.RowPitch;
                auto *dst_cursor = reinterpret_cast<std::byte *>(mapped_buffer) + footprint.Offset;
                auto *src_cursor = mip_levels[i].data.data();

                for (auto j = 0u; j < sub_resource_height; ++j)
                {
                    std::memcpy(dst_cursor, src_cursor, static_cast<std::size_t>(row_size[i]));
                    dst_cursor += sub_resource_pitch;
                    src_cursor += row_size[i];
                }
            }
        }
    }
    else
    {
        type_ = D3D12_DESCRIPTOR_HEAP_TYPE_DSV;

        depth_resource_view_ = D3D12DescriptorManager::cpu_allocator(type_).allocate_static();

        D3D12_DEPTH_STENCIL_VIEW_DESC depth_view_description = {0};
        depth_view_description.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
        depth_view_description.ViewDimension = D3D12_DSV_DIMENSION_TEXTURE2D;
        depth_view_description.Flags = D3D12_DSV_FLAG_NONE;
        depth_view_description.Texture2D.MipSlice = 0;

        // create the depth/stencil view into the texture
        device->CreateDepthStencilView(resource_.Get(), &depth_view_description, depth_resource_view_.cpu_handle());

        resource_view_ =
            D3D12DescriptorManager::cpu_allocator(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV).allocate_static();

        D3D12_SHADER_RESOURCE_VIEW_DESC shader_view_description = {0};
        shader_view_description.Format = DXGI_FORMAT_R24_UNORM_X8_TYPELESS;
        shader_view_description.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
        shader_view_description.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
        shader_view_description.Texture2D.MipLevels = 1;
        shader_view_description.Texture2D.MostDetailedMip = 0;

        device->CreateShaderResourceView(resource_.Get(), &shader_view_description, resource_view_.cpu_handle());
    }
}

ID3D12Resource *D3D12Texture::resource() const
{
    return resource_.Get();
}

ID3D12Resource *D3D12Texture::upload() const
{
    return upload_.Get();
}

std::vector<D3D12_PLACED_SUBRESOURCE_FOOTPRINT> D3D12Texture::footprints() const
{
    return footprints_;
}

D3D12DescriptorHandle D3D12Texture::handle() const
{
    return resource_view_;
}

D3D12DescriptorHandle D3D12Texture::depth_handle() const
{
    return depth_resource_view_;
}

D3D12_DESCRIPTOR_HEAP_TYPE D3D12Texture::type() const
{
    return type_;
}

}

```

`src/graphics/d3d12/d3d12_texture_manager.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/d3d12/d3d12_texture_manager.h"

#include <cstdint>
#include <memory>

#include "core/data_buffer.h"
#include "core/resource_manager.h"
#include "graphics/cube_map.h"
#include "graphics/d3d12/d3d12_cube_map.h"
#include "graphics/d3d12/d3d12_sampler.h"
#include "graphics/d3d12/d3d12_texture.h"
#include "graphics/sampler.h"
#include "graphics/texture.h"
#include "graphics/texture_manager.h"
#include "graphics/texture_usage.h"


namespace iris
{

D3D12TextureManager::D3D12TextureManager(ResourceManager &resource_manager)
    : TextureManager(resource_manager)
{
}

std::unique_ptr<Texture> D3D12TextureManager::do_create(
    const DataBuffer &data,
    std::uint32_t width,
    std::uint32_t height,
    const Sampler *sampler,
    TextureUsage usage,
    std::uint32_t index)

{
    return std::make_unique<D3D12Texture>(data, width, height, sampler, usage, index);
}

std::unique_ptr<CubeMap> D3D12TextureManager::do_create(
    const DataBuffer &right_data,
    const DataBuffer &left_data,
    const DataBuffer &top_data,
    const DataBuffer &bottom_data,
    const DataBuffer &near_data,
    const DataBuffer &far_data,
    std::uint32_t width,
    std::uint32_t height,
    const Sampler *sampler,
    std::uint32_t index)
{
    return std::make_unique<D3D12CubeMap>(
        right_data, left_data, top_data, bottom_data, near_data, far_data, width, height, sampler, index);
}

std::unique_ptr<Sampler> D3D12TextureManager::do_create(const SamplerDescriptor &descriptor, std::uint32_t index)
{
    return std::make_unique<D3D12Sampler>(descriptor, index);
}

}

```

`src/graphics/instanced_entity.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/instanced_entity.h"

#include <vector>

#include "core/error_handling.h"
#include "core/matrix4.h"
#include "core/transform.h"
#include "graphics/mesh.h"
#include "graphics/render_entity_type.h"

namespace
{

/**
 * Helper function to create a normal transformation matrix from a model
 * matrix.
 *
 * @param model
 *   The model matrix to calculate from.
 *
 * @returns
 *   Normal transformation matrix.
 */
iris::Matrix4 create_normal_transform(const iris::Matrix4 &model)
{
    auto normal = iris::Matrix4::transpose(iris::Matrix4::invert(model));

    // remove the translation components
    normal[3] = 0.0f;
    normal[7] = 0.0f;
    normal[11] = 0.0f;

    return normal;
}

}

namespace iris
{

InstancedEntity::InstancedEntity(const Mesh *mesh, const std::vector<Transform> &instances)
    : RenderEntity(mesh, PrimitiveType::TRIANGLES)
    , instance_count_(instances.size())
{
    ensure(instances.size() > 1, "must have at least two instances");

    for (const auto &instance : instances)
    {
        data_.emplace_back(instance.matrix());
        data_.emplace_back(create_normal_transform(instance.matrix()));
    }
}

RenderEntityType InstancedEntity::type() const
{
    return RenderEntityType::INSTANCED;
}

const std::vector<Matrix4> &InstancedEntity::data() const
{
    return data_;
}

bool InstancedEntity::has_transparency() const
{
    return false;
}

std::size_t InstancedEntity::instance_count() const
{
    return instance_count_;
}

}

```

`src/graphics/ios/CMakeLists.txt`:

```txt
set(DEFAULT_ROOT "${PROJECT_SOURCE_DIR}/src/core/default")
set(INCLUDE_ROOT "${PROJECT_SOURCE_DIR}/include/iris/graphics/ios")

target_sources(iris PRIVATE
    ${INCLUDE_ROOT}/app_delegate.h
    ${INCLUDE_ROOT}/ios_window.h
    ${INCLUDE_ROOT}/ios_window_manager.h
    ${INCLUDE_ROOT}/metal_view.h
    ${INCLUDE_ROOT}/metal_view_controller.h
    app_delegate.mm
    ios_window.mm
    ios_window_manager.cpp
    metal_view.mm
    metal_view_controller.mm)

```

`src/graphics/ios/app_delegate.mm`:

```mm
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#import "graphics/ios/app_delegate.h"

#include <functional>

#import <CoreGraphics/CoreGraphics.h>
#import <Foundation/Foundation.h>
#import <Metal/Metal.h>
#import <MetalKit/MetalKit.h>
#import <QuartzCore/QuartzCore.h>

#include "graphics/ios/metal_view_controller.h"
#include "log/log.h"

namespace iris
{

// globals for calling back into game
extern std::function<void(int, char **)> g_entry;
extern int g_argc;
extern char **g_argv;

}

@interface AppDelegate ()

@end

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    LOG_ENGINE_INFO("AppDelegate", "setting up window and view");

    // create a new window the size of the screen
    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];

    // create metal view controller
    auto *view_controller = [[MetalViewController alloc] init];

    // make window visible
    [[self window] makeKeyAndVisible];
    [[self window] setRootViewController:view_controller];
    [[self window] setNeedsDisplay];

    // fire of a call so the game entry point gets called
    // this has to be done via a selector as didFinishLaunchingWithOptions
    // must return, or else nothing will get rendered
    [self performSelector:@selector(callEntry) withObject:nil afterDelay:0.0];

    LOG_ENGINE_INFO("AppDelegate", "launch done");

    return YES;
}

- (void)callEntry
{
    LOG_ENGINE_INFO("AppDelegate", "calling main");

    iris::g_entry(iris::g_argc, iris::g_argv);

    LOG_ENGINE_INFO("AppDelegate", "main done");
}

@end

```

`src/graphics/ios/ios_window.mm`:

```mm
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/ios/ios_window.h"

#include <cstdint>
#include <memory>

#import <UIKit/UIKit.h>

#import "graphics/ios/metal_view_controller.h"
#include "graphics/metal/metal_renderer.h"
#include "log/log.h"

namespace iris
{

IOSWindow::IOSWindow(std::uint32_t width, std::uint32_t height)
    : Window(width, height)
{
    const auto bounds = [[UIScreen mainScreen] bounds];
    width_ = bounds.size.width;
    height_ = bounds.size.height;

    renderer_ = std::make_unique<MetalRenderer>(width_, height_);
}

std::optional<Event> IOSWindow::pump_event()
{
    const CFTimeInterval seconds = 0.000002;

    // run the default loop, this pumps touch events which will then be picked
    // up by our view
    auto result = kCFRunLoopRunHandledSource;
    do
    {
        result = CFRunLoopRunInMode(kCFRunLoopDefaultMode, seconds, TRUE);
    } while (result == kCFRunLoopRunHandledSource);

    const auto *window = [[[UIApplication sharedApplication] windows] objectAtIndex:0];
    const auto *root_view_controller = static_cast<MetalViewController *>([window rootViewController]);

    std::optional<Event> event;

    // get next event from view (if one is available)
    if (!root_view_controller->events_.empty())
    {
        event = root_view_controller->events_.front();
        root_view_controller->events_.pop();
    }

    return event;
}

std::uint32_t IOSWindow::screen_scale() const
{
    static std::uint32_t scale = 0u;

    if (scale == 0u)
    {
        scale = static_cast<std::uint32_t>([[UIScreen mainScreen] scale]);
    }

    return scale;
}

}

```

`src/graphics/ios/ios_window_manager.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/ios/ios_window_manager.h"

#include <cstdint>
#include <memory>

#include "core/error_handling.h"
#include "graphics/ios/ios_window.h"

namespace iris
{

Window *IOSWindowManager::create_window(std::uint32_t width, std::uint32_t height)
{
    ensure(!current_window_, "window already created");

    current_window_ = std::make_unique<IOSWindow>(width, height);
    return current_window_.get();
}

Window *IOSWindowManager::current_window() const
{
    return current_window_.get();
}

}

```

`src/graphics/ios/metal_view.mm`:

```mm
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#import "graphics/ios/metal_view.h"

#include <functional>

#import <Metal/Metal.h>
#import <QuartzCore/CAMetalLayer.h>

#include "core/root.h"
#include "graphics/ios/ios_window.h"
#include "graphics/ios/ios_window_manager.h"

@implementation MetalView

CADisplayLink *_displayLink;

+ (id)layerClass
{
    // we need to change the backing layer so metal can be used
    return [CAMetalLayer class];
}

- (instancetype)init
{
    if ((self = [super initWithFrame:[[UIScreen mainScreen] bounds]]))
    {
        // basic metal setup
        _metalLayer = (CAMetalLayer *)[self layer];
        _device = MTLCreateSystemDefaultDevice();
        _metalLayer.device = _device;
        _metalLayer.pixelFormat = MTLPixelFormatBGRA8Unorm;
        _metalLayer.frame = self.layer.frame;
        self.contentScaleFactor = iris::Root::window_manager().current_window()->screen_scale();
        [self setUserInteractionEnabled:YES];
        [super setUserInteractionEnabled:YES];
        [self setBackgroundColor:[UIColor redColor]];
    }

    return self;
}

@end

```

`src/graphics/ios/metal_view_controller.mm`:

```mm
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#import "graphics/ios/metal_view_controller.h"

#include <queue>
#include <tuple>

#import "graphics/ios/metal_view.h"

@interface MetalViewController ()
@end

@implementation MetalViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    [[self view] setMultipleTouchEnabled:YES];
}

- (void)viewDidAppear:(BOOL)animated
{
    [super viewDidAppear:animated];
    NSNumber *value = [NSNumber numberWithInt:UIInterfaceOrientationLandscapeLeft];
    [[UIDevice currentDevice] setValue:value forKey:@"orientation"];
}

- (void)loadView
{
    MetalView *view = [[MetalView alloc] init];
    [self setView:view];
}

- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event
{
    for (UITouch *touch in touches)
    {
        CGPoint touchPosition = [touch locationInView:[touch window]];
        events_.emplace(iris::TouchEvent(
            reinterpret_cast<std::uintptr_t>(touch), iris::TouchType::BEGIN, touchPosition.x, touchPosition.y));
    }
}

- (void)touchesMoved:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event
{
    for (UITouch *touch in touches)
    {
        CGPoint touchPosition = [touch locationInView:[touch window]];
        events_.emplace(iris::TouchEvent(
            reinterpret_cast<std::uintptr_t>(touch), iris::TouchType::MOVE, touchPosition.x, touchPosition.y));
    }
}

- (void)touchesEnded:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event
{
    for (UITouch *touch in touches)
    {
        CGPoint touchPosition = [touch locationInView:[touch window]];
        events_.emplace(iris::TouchEvent(
            reinterpret_cast<std::uintptr_t>(touch), iris::TouchType::END, touchPosition.x, touchPosition.y));
    }
}

- (BOOL)prefersStatusBarHidden
{
    return YES;
}

@end

```

`src/graphics/lights/CMakeLists.txt`:

```txt
set(INCLUDE_ROOT "${PROJECT_SOURCE_DIR}/include/iris/graphics/lights")

target_sources(iris PRIVATE
    ${INCLUDE_ROOT}/ambient_light.h
    ${INCLUDE_ROOT}/directional_light.h
    ${INCLUDE_ROOT}/light.h
    ${INCLUDE_ROOT}/light_type.h
    ${INCLUDE_ROOT}/lighting_rig.h
    ${INCLUDE_ROOT}/point_light.h
    ambient_light.cpp
    directional_light.cpp
    point_light.cpp)

```

`src/graphics/lights/ambient_light.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/lights/ambient_light.h"

#include <array>
#include <cstring>

#include "core/colour.h"
#include "graphics/lights/light.h"
#include "graphics/lights/light_type.h"

namespace iris
{

AmbientLight::AmbientLight(const Colour &colour)
    : colour_(colour)
{
}

LightType AmbientLight::type() const
{
    return LightType::AMBIENT;
}

std::array<float, 4u> AmbientLight::colour_data() const
{
    std::array<float, 4u> light_data{};
    light_data.fill(0.0f);

    // sanity check we have enough space
    static_assert(light_data.size() * sizeof(decltype(light_data)::value_type) >= sizeof(colour_));

    // copy light data straight into buffer
    std::memcpy(light_data.data(), &colour_, sizeof(colour_));

    return light_data;
}

std::array<float, 4u> AmbientLight::world_space_data() const
{
    std::array<float, 4u> light_data{};
    light_data.fill(0.0f);

    return light_data;
}

std::array<float, 3u> AmbientLight::attenuation_data() const
{
    std::array<float, 3u> light_data{};
    light_data.fill(0.0f);

    return light_data;
}

Colour AmbientLight::colour() const
{
    return colour_;
}

void AmbientLight::set_colour(const Colour &colour)
{
    colour_ = colour;
}

}

```

`src/graphics/lights/directional_light.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/lights/directional_light.h"

#include <array>
#include <cstring>

#include "core/camera.h"
#include "core/matrix4.h"
#include "core/vector3.h"
#include "graphics/lights/light_type.h"

namespace iris
{

DirectionalLight::DirectionalLight(const Vector3 &direction, bool cast_shadows)
    : DirectionalLight(direction, {1.0f, 1.0f, 1.0f, 1.0f}, cast_shadows)
{
}

DirectionalLight::DirectionalLight(const Vector3 &direction, const Colour &colour, bool cast_shadows)
    : direction_(direction)
    , shadow_camera_(CameraType::ORTHOGRAPHIC, 100u, 100u, 1000u)
    , cast_shadows_(cast_shadows)
    , colour_(colour)
{
    shadow_camera_.set_view(Matrix4::make_look_at(-direction_, {}, {0.0f, 1.0f, 0.0f}));
}

LightType DirectionalLight::type() const
{
    return LightType::DIRECTIONAL;
}

std::array<float, 4u> DirectionalLight::colour_data() const
{
    std::array<float, 4u> light_data{};
    light_data.fill(0.0f);

    // sanity check we have enough space
    static_assert(light_data.size() * sizeof(decltype(light_data)::value_type) >= sizeof(colour_));

    // copy light data straight into buffer
    std::memcpy(light_data.data(), &colour_, sizeof(colour_));

    return light_data;
}

std::array<float, 4u> DirectionalLight::world_space_data() const
{
    std::array<float, 4u> light_data{};
    light_data.fill(0.0f);

    // sanity check we have enough space
    static_assert(light_data.size() * sizeof(decltype(light_data)::value_type) >= sizeof(direction_));

    // copy light data straight into buffer
    std::memcpy(light_data.data(), &direction_, sizeof(direction_));

    return light_data;
}

std::array<float, 3u> DirectionalLight::attenuation_data() const
{
    std::array<float, 3u> light_data{};
    light_data.fill(1.0f);

    return light_data;
}

Vector3 DirectionalLight::direction() const
{
    return direction_;
}

void DirectionalLight::set_direction(const Vector3 &direction)
{
    direction_ = direction;
    shadow_camera_.set_view(Matrix4::make_look_at(-direction_, {}, {0.0f, 1.0f, 0.0f}));
}

bool DirectionalLight::casts_shadows() const
{
    return cast_shadows_;
}

const Camera &DirectionalLight::shadow_camera() const
{
    return shadow_camera_;
}

}

```

`src/graphics/lights/point_light.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/lights/point_light.h"

#include <array>
#include <cstring>

#include "core/vector3.h"
#include "graphics/lights/light_type.h"

namespace iris
{

PointLight::PointLight(const Vector3 &position)
    : PointLight(position, {1.0f, 1.0f, 1.0f, 1.0f})
{
}

PointLight::PointLight(const Vector3 &position, const Colour &colour)
    : position_(position)
    , colour_(colour)
    , attenuation_terms_()
{
    attenuation_terms_.constant = 0.0f;
    attenuation_terms_.linear = 1.0f;
    attenuation_terms_.quadratic = 0.0f;
}

LightType PointLight::type() const
{
    return LightType::POINT;
}

std::array<float, 4u> PointLight::colour_data() const
{
    std::array<float, 4u> light_data{};
    light_data.fill(0.0f);

    // sanity check we have enough space
    static_assert(light_data.size() * sizeof(decltype(light_data)::value_type) >= sizeof(colour_));

    // copy light data straight into buffer
    std::memcpy(light_data.data(), &colour_, sizeof(colour_));

    return light_data;
}

std::array<float, 4u> PointLight::world_space_data() const
{
    std::array<float, 4u> light_data{};
    light_data.fill(0.0f);

    // sanity check we have enough space
    static_assert(light_data.size() * sizeof(decltype(light_data)::value_type) >= sizeof(position_));

    // copy light data straight into buffer
    std::memcpy(light_data.data(), &position_, sizeof(position_));

    return light_data;
}

std::array<float, 3u> PointLight::attenuation_data() const
{
    std::array<float, 3u> light_data{};
    light_data.fill(0.0f);

    // sanity check we have enough space
    static_assert(light_data.size() * sizeof(decltype(light_data)::value_type) == sizeof(attenuation_terms_));

    // copy light data straight into buffer
    std::memcpy(light_data.data(), &attenuation_terms_, sizeof(attenuation_terms_));

    return light_data;
}

Vector3 PointLight::position() const
{
    return position_;
}

void PointLight::set_position(const Vector3 &position)
{
    position_ = position;
}

Colour PointLight::colour() const
{
    return colour_;
}

void PointLight::set_colour(const Colour &colour)
{
    colour_ = colour;
}

float PointLight::attenuation_constant_term() const
{
    return attenuation_terms_.constant;
}

void PointLight::set_attenuation_constant_term(float constant)
{
    attenuation_terms_.constant = constant;
}

float PointLight::attenuation_linear_term() const
{
    return attenuation_terms_.linear;
}

void PointLight::set_attenuation_linear_term(float linear)
{
    attenuation_terms_.linear = linear;
}

float PointLight::attenuation_quadratic_term() const
{
    return attenuation_terms_.quadratic;
}

void PointLight::set_attenuation_quadratic_term(float quadratic)
{
    attenuation_terms_.quadratic = quadratic;
}

}

```

`src/graphics/linux/CMakeLists.txt`:

```txt
set(INCLUDE_ROOT "${PROJECT_SOURCE_DIR}/include/iris/graphics/linux")

target_sources(iris PRIVATE
    ${INCLUDE_ROOT}/linux_window.h
    ${INCLUDE_ROOT}/linux_window_manager.h
    ${INCLUDE_ROOT}/scoped_error_handler.h
    linux_window.cpp
    linux_window_manager.cpp)

```

`src/graphics/linux/linux_window.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/linux/linux_window.h"

#include <cmath>
#include <iostream>
#include <optional>
#include <queue>

#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/extensions/Xfixes.h>

#include "core/auto_release.h"
#include "core/error_handling.h"
#include "events/event.h"
#include "events/keyboard_event.h"
#include "events/mouse_button_event.h"
#include "events/mouse_event.h"
#include "events/quit_event.h"
#include "events/scroll_wheel_event.h"
#include "graphics/linux/scoped_error_handler.h"
#include "graphics/window_manager.h"
#define DONT_MAKE_GL_FUNCTIONS_EXTERN // get concrete function pointers for all
                                      // opengl functions
#include "graphics/opengl/opengl.h"
#include "graphics/opengl/opengl_renderer.h"

bool iris::ScopedErrorHandler::error = false;

// x-macro argument to resolve functions
#define RESOLVE_FUNCTION(_, NAME, ...) resolve_opengl_function(NAME, #NAME);

namespace
{

/**
 * Helper function to resolve a single opengl function.
 *
 * @param function
 *   Reference to function pointer to resolve.
 *
 * @param name
 *   Name of function.
 */
template <class T>
void resolve_opengl_function(T &function, const std::string &name)
{
    const auto address = ::glXGetProcAddressARB(reinterpret_cast<const GLubyte *>(name.c_str()));
    iris::ensure(address != NULL, "could not resolve: " + name);

    function = reinterpret_cast<T>(address);
}

/**
 * Helper function to resolve all opengl functions.
 */
void resolve_global_opengl_functions()
{
    FOR_OPENGL_FUNCTIONS(RESOLVE_FUNCTION);
}

/**
 * Helper function to convert an X11 key code to an engine key type.
 *
 * @param key_code
 *   X11 key code.
 *
 * @returns
 *   Engine Key.
 */
iris::Key x11_key_to_engine_key(unsigned int key_code)
{
    iris::Key key;

    switch (key_code)
    {
        case XK_0: key = iris::Key::NUM_0; break;
        case XK_1: key = iris::Key::NUM_1; break;
        case XK_2: key = iris::Key::NUM_2; break;
        case XK_3: key = iris::Key::NUM_3; break;
        case XK_4: key = iris::Key::NUM_4; break;
        case XK_5: key = iris::Key::NUM_5; break;
        case XK_6: key = iris::Key::NUM_6; break;
        case XK_7: key = iris::Key::NUM_7; break;
        case XK_8: key = iris::Key::NUM_8; break;
        case XK_9: key = iris::Key::NUM_9; break;
        case XK_a: key = iris::Key::A; break;
        case XK_b: key = iris::Key::B; break;
        case XK_c: key = iris::Key::C; break;
        case XK_d: key = iris::Key::D; break;
        case XK_e: key = iris::Key::E; break;
        case XK_f: key = iris::Key::F; break;
        case XK_g: key = iris::Key::G; break;
        case XK_h: key = iris::Key::H; break;
        case XK_i: key = iris::Key::I; break;
        case XK_j: key = iris::Key::J; break;
        case XK_k: key = iris::Key::K; break;
        case XK_l: key = iris::Key::L; break;
        case XK_m: key = iris::Key::M; break;
        case XK_n: key = iris::Key::N; break;
        case XK_o: key = iris::Key::O; break;
        case XK_p: key = iris::Key::P; break;
        case XK_q: key = iris::Key::Q; break;
        case XK_r: key = iris::Key::R; break;
        case XK_s: key = iris::Key::S; break;
        case XK_t: key = iris::Key::T; break;
        case XK_u: key = iris::Key::U; break;
        case XK_v: key = iris::Key::V; break;
        case XK_w: key = iris::Key::W; break;
        case XK_x: key = iris::Key::X; break;
        case XK_y: key = iris::Key::Y; break;
        case XK_z: key = iris::Key::Z; break;
        case XK_Tab: key = iris::Key::TAB; break;
        case XK_space: key = iris::Key::SPACE; break;
        case XK_Escape: key = iris::Key::ESCAPE; break;
        case XK_Shift_L: key = iris::Key::SHIFT; break;
        case XK_Shift_R: key = iris::Key::RIGHT_SHIFT; break;
        case XK_F17: key = iris::Key::F17; break;
        case XK_period: key = iris::Key::KEYPAD_DECIMAL; break;
        case XK_multiply: key = iris::Key::KEYPAD_MULTIPLY; break;
        case XK_plus: key = iris::Key::KEYPAD_PLUS; break;
        case XK_division: key = iris::Key::KEYPAD_DIVIDE; break;
        case XK_minus: key = iris::Key::KEYPAD_MINUS; break;
        case XK_F18: key = iris::Key::F18; break;
        case XK_F19: key = iris::Key::F19; break;
        case XK_KP_0: key = iris::Key::KEYPAD_0; break;
        case XK_KP_1: key = iris::Key::KEYPAD_1; break;
        case XK_KP_2: key = iris::Key::KEYPAD_2; break;
        case XK_KP_3: key = iris::Key::KEYPAD_3; break;
        case XK_KP_4: key = iris::Key::KEYPAD_4; break;
        case XK_KP_5: key = iris::Key::KEYPAD_5; break;
        case XK_KP_6: key = iris::Key::KEYPAD_6; break;
        case XK_KP_7: key = iris::Key::KEYPAD_7; break;
        case XK_F20: key = iris::Key::F20; break;
        case XK_KP_8: key = iris::Key::KEYPAD_8; break;
        case XK_KP_9: key = iris::Key::KEYPAD_9; break;
        case XK_F5: key = iris::Key::F5; break;
        case XK_F6: key = iris::Key::F6; break;
        case XK_F7: key = iris::Key::F7; break;
        case XK_F3: key = iris::Key::F3; break;
        case XK_F8: key = iris::Key::F8; break;
        case XK_F9: key = iris::Key::F9; break;
        case XK_F11: key = iris::Key::F11; break;
        case XK_F13: key = iris::Key::F13; break;
        case XK_F16: key = iris::Key::F16; break;
        case XK_F14: key = iris::Key::F14; break;
        case XK_F10: key = iris::Key::F10; break;
        case XK_F12: key = iris::Key::F12; break;
        case XK_F15: key = iris::Key::F15; break;
        case XK_F4: key = iris::Key::F4; break;
        case XK_F2: key = iris::Key::F2; break;
        case XK_F1: key = iris::Key::F1; break;
        case XK_Left: key = iris::Key::LEFT_ARROW; break;
        case XK_Right: key = iris::Key::RIGHT_ARROW; break;
        case XK_Down: key = iris::Key::DOWN_ARROW; break;
        case XK_Up: key = iris::Key::UP_ARROW; break;
        default: key = iris::Key::UNKNOWN;
    }

    return key;
}

}

namespace iris
{

LinuxWindow::LinuxWindow(
    std::uint32_t width,
    std::uint32_t height,
    WindowManager &window_manager,
    TextureManager &texture_manager,
    MaterialManager &material_manager)
    : Window(width, height)
{
    display_ = {::XOpenDisplay(nullptr), ::XCloseDisplay};
    ensure(display_, "could not open display");

    static const int visual_attribs[] = {
        GLX_X_RENDERABLE,
        True,
        GLX_DRAWABLE_TYPE,
        GLX_WINDOW_BIT,
        GLX_RENDER_TYPE,
        GLX_RGBA_BIT,
        GLX_X_VISUAL_TYPE,
        GLX_TRUE_COLOR,
        GLX_RED_SIZE,
        8,
        GLX_GREEN_SIZE,
        8,
        GLX_BLUE_SIZE,
        8,
        GLX_ALPHA_SIZE,
        8,
        GLX_DEPTH_SIZE,
        24,
        GLX_STENCIL_SIZE,
        8,
        GLX_DOUBLEBUFFER,
        True,
        None};

    int glx_major = 0;
    int glx_minor = 0;

    // check we have the minimum version of glx (the opengl extension to x11)
    ensure(::glXQueryVersion(display_, &glx_major, &glx_minor) == True, "could not query extension version");
    ensure((glx_major > 1) || ((glx_major == 1) && (glx_minor >= 3)), "incompatible glx version");

    int fb_count = 0;

    // get all the frame buffer configurations that match our attributes
    AutoRelease<GLXFBConfig *, nullptr> fb_config = {
        ::glXChooseFBConfig(display_, DefaultScreen(display_.get()), visual_attribs, &fb_count), ::XFree};
    ensure(fb_config && (fb_count > 0), "could not get framebuffer config");

    int best_fb_config = -1;
    int best_num_samples = -1;

    // find the config with the most samples
    for (auto i = 0; i < fb_count; ++i)
    {
        AutoRelease<XVisualInfo *, nullptr> info = {::glXGetVisualFromFBConfig(display_, fb_config[i]), ::XFree};
        if (info)
        {
            int sample_buffer = 0;
            int samples = 0;

            if (::glXGetFBConfigAttrib(display_, fb_config[i], GLX_SAMPLE_BUFFERS, &sample_buffer) == Success)
            {
                if (::glXGetFBConfigAttrib(display_, fb_config[i], GLX_SAMPLES, &samples) == Success)
                {
                    if (samples > best_num_samples)
                    {
                        best_num_samples = samples;
                        best_fb_config = i;
                    }
                }
            }
        }
    }

    auto config = fb_config[best_fb_config];

    // get the visual info for our chosen config
    AutoRelease<XVisualInfo *, nullptr> visual_info = {::glXGetVisualFromFBConfig(display_, config), ::XFree};
    ensure(visual_info, "could not get visual info");

    AutoRelease<Colormap, 0> colour_map = {
        ::XCreateColormap(
            display_, RootWindow(display_.get(), visual_info.get()->screen), visual_info.get()->visual, AllocNone),
        [this](Colormap colour_map) { ::XFreeColormap(display_, colour_map); }};

    XSetWindowAttributes attributes{0};
    attributes.colormap = colour_map;
    attributes.background_pixmap = 0;
    attributes.border_pixel = 0;
    attributes.event_mask = StructureNotifyMask;

    // create an x11 window
    window_ = {
        ::XCreateWindow(
            display_,
            RootWindow(display_.get(), visual_info.get()->screen),
            0,
            0,
            width_,
            height_,
            0,
            visual_info.get()->depth,
            InputOutput,
            visual_info.get()->visual,
            CWBorderPixel | CWColormap | CWEventMask,
            &attributes),
        [this](::Window window) { ::XDestroyWindow(display_, window); }};
    ensure(window_, "could not create widnow");

    // set which events we want to receive
    ::XSelectInput(
        display_,
        window_,
        KeyPressMask | KeyReleaseMask | ButtonPressMask | ButtonReleaseMask | PointerMotionMask | ExposureMask);

    // register for close window events
    Atom wmDeleteMessage = XInternAtom(display_, "WM_DELETE_WINDOW", False);
    XSetWMProtocols(display_, window_, &wmDeleteMessage, 1);

    ::XMapWindow(display_, window_);

    // check opengl version

    {
        ScopedErrorHandler error_handler;

        // we need to find this function first
        auto *glXCreateContextAttribsARB =
            reinterpret_cast<GLXContext (*)(Display *, GLXFBConfig, GLXContext, Bool, const int *)>(
                ::glXGetProcAddressARB(reinterpret_cast<const GLubyte *>("glXCreateContextAttribsARB")));
        ensure(glXCreateContextAttribsARB != nullptr, "unsupported extension");

        resolve_global_opengl_functions();

        // want at least opengl 3.3
        const int context_attribs[] = {GLX_CONTEXT_MAJOR_VERSION_ARB, 3, GLX_CONTEXT_MINOR_VERSION_ARB, 3, None};

        context_ = {glXCreateContextAttribsARB(display_, config, 0, True, context_attribs), [this](GLXContext context) {
                        ::glXDestroyContext(display_, context);
                    }};

        ::XSync(display_, False);
        ensure(context_ && (error_handler == false), "could not create context");
    }

    ensure(::glXMakeCurrent(display_, window_, context_) == True, "could not make context current");

    renderer_ = std::make_unique<OpenGLRenderer>(window_manager, texture_manager, material_manager, width_, height_);

    const auto scale = screen_scale();

    XWindowChanges changes{0};
    changes.width = width_ * scale;
    changes.height = height_ * scale;

    // resize window based on scale
    ::XConfigureWindow(display_, window_, CWWidth | CWHeight, &changes);

    ::XSetLocaleModifiers("");

    // hide cursor
    ::XFixesHideCursor(display_, window_);
    ::XFlush(display_);

    // move cursor to centre of screen
    ::XWarpPointer(display_, None, window_, 0, 0, 0, 0, changes.width / 2, changes.height / 2);
}

std::uint32_t LinuxWindow::screen_scale() const
{
    const auto dpi = ((double)DisplayWidth(display_.get(), 0)) / (((double)DisplayWidthMM(display_.get(), 0)) / 25.4);
    return static_cast<std::uint32_t>(std::floor(static_cast<float>(dpi) / 96.0f));
}

std::optional<Event> LinuxWindow::pump_event()
{
    XEvent event{0};

    while (::XCheckWindowEvent(
               display_,
               window_,
               KeyPressMask | KeyReleaseMask | ButtonPressMask | ButtonReleaseMask | PointerMotionMask | ExposureMask,
               &event) == True)
    {
        if (event.type == KeyPress)
        {
            events_.emplace(KeyboardEvent{x11_key_to_engine_key(::XLookupKeysym(&event.xkey, 0)), KeyState::DOWN});
        }
        else if (event.type == KeyRelease)
        {
            events_.emplace(KeyboardEvent{x11_key_to_engine_key(::XLookupKeysym(&event.xkey, 0)), KeyState::UP});
        }
        else if (event.type == ButtonPress)
        {
            if (event.xbutton.button == Button1)
            {
                events_.emplace(MouseButtonEvent{MouseButton::LEFT, MouseButtonState::DOWN});
            }
            else if (event.xbutton.button == Button2)
            {
                events_.emplace(MouseButtonEvent{MouseButton::RIGHT, MouseButtonState::DOWN});
            }
            else if (event.xbutton.button == Button4)
            {
                events_.emplace(ScrollWheelEvent{1.0f});
            }
            else if (event.xbutton.button == Button5)
            {
                events_.emplace(ScrollWheelEvent{-1.0f});
            }
        }
        else if (event.type == ButtonRelease)
        {
            if (event.xbutton.button == Button1)
            {
                events_.emplace(MouseButtonEvent{MouseButton::LEFT, MouseButtonState::UP});
            }
            else if (event.xbutton.button == Button2)
            {
                events_.emplace(MouseButtonEvent{MouseButton::RIGHT, MouseButtonState::UP});
            }
        }
        else if (event.type == MotionNotify)
        {
            static auto x = event.xmotion.x;
            static auto y = event.xmotion.y;

            events_.emplace(
                MouseEvent{static_cast<float>(event.xmotion.x - x), static_cast<float>(event.xmotion.y - y)});

            x = event.xmotion.x;
            y = event.xmotion.y;
        }
    }

    std::optional<Event> next_event{};

    if (!events_.empty())
    {
        next_event = events_.front();
        events_.pop();
    }

    return next_event;
}

Display *LinuxWindow::display() const
{
    return display_.get();
}

::Window LinuxWindow::window() const
{
    return window_.get();
}

}

```

`src/graphics/linux/linux_window_manager.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/linux/linux_window_manager.h"

#include <cstdint>
#include <memory>

#include "core/error_handling.h"
#include "graphics/linux/linux_window.h"
#include "graphics/linux/linux_window_manager.h"
#include "graphics/window.h"
#include "graphics/window_manager.h"

namespace iris
{

LinuxWindowManager::LinuxWindowManager(TextureManager &texture_manager, MaterialManager &material_manager)
    : texture_manager_(texture_manager)
    , material_manager_(material_manager)
    , current_window_()
{
}

Window *LinuxWindowManager::create_window(std::uint32_t width, std::uint32_t height)
{
    // only support one window at the moment
    ensure(!current_window_, "window already created");

    current_window_ = std::make_unique<LinuxWindow>(width, height, *this, texture_manager_, material_manager_);

    return current_window_.get();
}

Window *LinuxWindowManager::current_window() const
{
    return current_window_.get();
}
}

```

`src/graphics/macos/CMakeLists.txt`:

```txt
set(INCLUDE_ROOT "${PROJECT_SOURCE_DIR}/include/iris/graphics/macos")

target_sources(iris PRIVATE
    ${INCLUDE_ROOT}/macos_window.h
    ${INCLUDE_ROOT}/macos_window_manager.h
    ${INCLUDE_ROOT}/metal_app_delegate.h
    ${INCLUDE_ROOT}/metal_view.h
    macos_window.mm
    macos_window_manager.cpp
    metal_app_delegate.m
    metal_view.m
)

```

`src/graphics/macos/macos_window.mm`:

```mm
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/macos/macos_window.h"

#include <memory>

#import <Appkit/Appkit.h>
#import <Foundation/Foundation.h>

#include "core/error_handling.h"
#include "events/keyboard_event.h"
#include "events/mouse_button_event.h"
#include "events/mouse_event.h"
#include "events/scroll_wheel_event.h"
#include "graphics/macos/metal_app_delegate.h"
#include "graphics/material_manager.h"
#include "graphics/metal/metal_renderer.h"
#include "graphics/render_target.h"
#include "graphics/texture_manager.h"
#include "log/log.h"

namespace
{

/**
 * Helper function to convert an OS X Key code to an engine specific key.
 *
 * @param key_code
 *   OS X specific Key code.
 *
 * @returns
 *   Emgine specific Key representation.
 */
iris::Key macos_key_to_engine_Key(const std::uint16_t key_code)
{
    iris::Key key;

    switch (key_code)
    {
        case 0x00: key = iris::Key::A; break;
        case 0x01: key = iris::Key::S; break;
        case 0x02: key = iris::Key::D; break;
        case 0x03: key = iris::Key::F; break;
        case 0x04: key = iris::Key::H; break;
        case 0x05: key = iris::Key::G; break;
        case 0x06: key = iris::Key::Z; break;
        case 0x07: key = iris::Key::X; break;
        case 0x08: key = iris::Key::C; break;
        case 0x09: key = iris::Key::V; break;
        case 0x0B: key = iris::Key::B; break;
        case 0x0C: key = iris::Key::Q; break;
        case 0x0D: key = iris::Key::W; break;
        case 0x0E: key = iris::Key::E; break;
        case 0x0F: key = iris::Key::R; break;
        case 0x10: key = iris::Key::Y; break;
        case 0x11: key = iris::Key::T; break;
        case 0x12: key = iris::Key::NUM_1; break;
        case 0x13: key = iris::Key::NUM_2; break;
        case 0x14: key = iris::Key::NUM_3; break;
        case 0x15: key = iris::Key::NUM_4; break;
        case 0x16: key = iris::Key::NUM_6; break;
        case 0x17: key = iris::Key::NUM_5; break;
        case 0x18: key = iris::Key::EQUAL; break;
        case 0x19: key = iris::Key::NUM_9; break;
        case 0x1A: key = iris::Key::NUM_7; break;
        case 0x1B: key = iris::Key::MINUS; break;
        case 0x1C: key = iris::Key::NUM_8; break;
        case 0x1D: key = iris::Key::NUM_0; break;
        case 0x1E: key = iris::Key::RIGHT_BRACKET; break;
        case 0x1F: key = iris::Key::O; break;
        case 0x20: key = iris::Key::U; break;
        case 0x21: key = iris::Key::LEFT_BRACKET; break;
        case 0x22: key = iris::Key::I; break;
        case 0x23: key = iris::Key::P; break;
        case 0x24: key = iris::Key::RETURN; break;
        case 0x25: key = iris::Key::L; break;
        case 0x26: key = iris::Key::J; break;
        case 0x27: key = iris::Key::QUOTE; break;
        case 0x28: key = iris::Key::K; break;
        case 0x29: key = iris::Key::SEMI_COLON; break;
        case 0x2A: key = iris::Key::BACKSLASH; break;
        case 0x2B: key = iris::Key::COMMA; break;
        case 0x2C: key = iris::Key::SLASH; break;
        case 0x2D: key = iris::Key::N; break;
        case 0x2E: key = iris::Key::M; break;
        case 0x2F: key = iris::Key::PERIOD; break;
        case 0x30: key = iris::Key::TAB; break;
        case 0x31: key = iris::Key::SPACE; break;
        case 0x32: key = iris::Key::GRAVE; break;
        case 0x33: key = iris::Key::FORWARD_DELETE; break;
        case 0x35: key = iris::Key::ESCAPE; break;
        case 0x37: key = iris::Key::COMMAND; break;
        case 0x38: key = iris::Key::SHIFT; break;
        case 0x39: key = iris::Key::CAPS_LOCK; break;
        case 0x3A: key = iris::Key::OPTION; break;
        case 0x3B: key = iris::Key::CONTROL; break;
        case 0x3C: key = iris::Key::RIGHT_SHIFT; break;
        case 0x3D: key = iris::Key::RIGHT_OPTION; break;
        case 0x3E: key = iris::Key::RIGHT_CONTROL; break;
        case 0x3F: key = iris::Key::FUNCTION; break;
        case 0x40: key = iris::Key::F17; break;
        case 0x41: key = iris::Key::KEYPAD_DECIMAL; break;
        case 0x43: key = iris::Key::KEYPAD_MULTIPLY; break;
        case 0x45: key = iris::Key::KEYPAD_PLUS; break;
        case 0x47: key = iris::Key::KEYPAD_CLEAR; break;
        case 0x48: key = iris::Key::VOLUME_UP; break;
        case 0x49: key = iris::Key::VOLUME_DOWN; break;
        case 0x4A: key = iris::Key::MUTE; break;
        case 0x4B: key = iris::Key::KEYPAD_DIVIDE; break;
        case 0x4C: key = iris::Key::KEYPAD_ENTER; break;
        case 0x4E: key = iris::Key::KEYPAD_MINUS; break;
        case 0x4F: key = iris::Key::F18; break;
        case 0x50: key = iris::Key::F19; break;
        case 0x51: key = iris::Key::KEYPAD_EQUALS; break;
        case 0x52: key = iris::Key::KEYPAD_0; break;
        case 0x53: key = iris::Key::KEYPAD_1; break;
        case 0x54: key = iris::Key::KEYPAD_2; break;
        case 0x55: key = iris::Key::KEYPAD_3; break;
        case 0x56: key = iris::Key::KEYPAD_4; break;
        case 0x57: key = iris::Key::KEYPAD_5; break;
        case 0x58: key = iris::Key::KEYPAD_6; break;
        case 0x59: key = iris::Key::KEYPAD_7; break;
        case 0x5A: key = iris::Key::F20; break;
        case 0x5B: key = iris::Key::KEYPAD_8; break;
        case 0x5C: key = iris::Key::KEYPAD_9; break;
        case 0x60: key = iris::Key::F5; break;
        case 0x61: key = iris::Key::F6; break;
        case 0x62: key = iris::Key::F7; break;
        case 0x63: key = iris::Key::F3; break;
        case 0x64: key = iris::Key::F8; break;
        case 0x65: key = iris::Key::F9; break;
        case 0x67: key = iris::Key::F11; break;
        case 0x69: key = iris::Key::F13; break;
        case 0x6A: key = iris::Key::F16; break;
        case 0x6B: key = iris::Key::F14; break;
        case 0x6D: key = iris::Key::F10; break;
        case 0x6F: key = iris::Key::F12; break;
        case 0x71: key = iris::Key::F15; break;
        case 0x72: key = iris::Key::HELP; break;
        case 0x73: key = iris::Key::HOME; break;
        case 0x74: key = iris::Key::PAGE_UP; break;
        case 0x75: key = iris::Key::FORWARD_DELETE; break;
        case 0x76: key = iris::Key::F4; break;
        case 0x77: key = iris::Key::END; break;
        case 0x78: key = iris::Key::F2; break;
        case 0x79: key = iris::Key::PAGE_DOWN; break;
        case 0x7A: key = iris::Key::F1; break;
        case 0x7B: key = iris::Key::LEFT_ARROW; break;
        case 0x7C: key = iris::Key::RIGHT_ARROW; break;
        case 0x7D: key = iris::Key::DOWN_ARROW; break;
        case 0x7E: key = iris::Key::UP_ARROW; break;
        default: key = iris::Key::UNKNOWN;
    }

    return key;
}

/**
 * Helper method to handle native keyboard events.
 *
 * @param event
 *   Native Event object.
 */
iris::KeyboardEvent handle_keyboard_event(NSEvent *event)
{
    // extract the Key code from the event
    const std::uint16_t key_code = [event keyCode];

    // convert the NSEventType to our Event state
    const auto type = ([event type] == NSEventTypeKeyDown) ? iris::KeyState::DOWN : iris::KeyState::UP;

    // convert Key code and dispatch
    const auto key = macos_key_to_engine_Key(key_code);

    return {key, type};
}

/**
 * Helper method to handle native mouse events.
 *
 * @param event
 *   Native Event object.
 */
iris::MouseEvent handle_mouse_event(NSEvent *event)
{
    // get mouse delta
    std::int32_t dx = 0;
    std::int32_t dy = 0;
    ::CGGetLastMouseDelta(&dx, &dy);

    // convert and dispatch
    return {static_cast<float>(dx), static_cast<float>(dy)};
}

}

namespace iris
{

MacosWindow::MacosWindow(
    std::uint32_t width,
    std::uint32_t height,
    TextureManager &texture_manager,
    MaterialManager &material_manager)
    : Window(width, height)
{
    // get and/or create the application singleton
    NSApplication *app = [NSApplication sharedApplication];

    // this is an ordinary app
    [NSApp setActivationPolicy:NSApplicationActivationPolicyRegular];

    // make this app the active app
    [NSApp activateIgnoringOtherApps:YES];

    id<NSApplicationDelegate> app_delegate = nullptr;

    // create a metal renderer and app delegate
    app_delegate = [[MetalAppDelegate alloc] initWithRect:NSMakeRect(0.0f, 0.0f, width_, height_)];
    ensure(app_delegate != nil, "failed to create AppDelegate");

    renderer_ = std::make_unique<MetalRenderer>(texture_manager, material_manager, width_, height_);

    // set the delegate
    [app setDelegate:app_delegate];

    // activate the app
    [app finishLaunching];

    [NSCursor hide];

    LOG_ENGINE_INFO("window", "macos window created {} {}", width_, height_);
}

std::uint32_t MacosWindow::screen_scale() const
{
    auto *window = [[NSApp windows] firstObject];
    return static_cast<std::uint32_t>([[window screen] backingScaleFactor]);
}

std::optional<Event> MacosWindow::pump_event()
{
    std::optional<Event> evt{};

    NSEvent *event = nil;

    // flush next event
    event = [NSApp nextEventMatchingMask:NSEventMaskAny
                               untilDate:[NSDate distantPast]
                                  inMode:NSDefaultRunLoopMode
                                 dequeue:YES];

    if (event != nil)
    {
        // handle native event
        switch ([event type])
        {
            case NSEventTypeKeyDown: [[fallthrough]];
            case NSEventTypeKeyUp:
                if (!event.ARepeat)
                {
                    evt = handle_keyboard_event(event);
                }
                break;
            case NSEventTypeLeftMouseDragged: [[fallthrough]];
            case NSEventTypeRightMouseDragged: [[fallthrough]];
            case NSEventTypeMouseMoved: evt = handle_mouse_event(event); break;
            case NSEventTypeLeftMouseDown: evt = MouseButtonEvent{MouseButton::LEFT, MouseButtonState::DOWN}; break;
            case NSEventTypeLeftMouseUp: evt = MouseButtonEvent{MouseButton::LEFT, MouseButtonState::UP}; break;
            case NSEventTypeRightMouseDown: evt = MouseButtonEvent{MouseButton::RIGHT, MouseButtonState::DOWN}; break;
            case NSEventTypeRightMouseUp: evt = MouseButtonEvent{MouseButton::RIGHT, MouseButtonState::UP}; break;
            case NSEventTypeScrollWheel: evt = ScrollWheelEvent{static_cast<float>([event scrollingDeltaY])}; break;
            default: break;
        }

        // dispatch the Event to other objects, this stops us swallowing
        // all events and preventing anything else from receiving them
        [NSApp sendEvent:event];
    }

    return evt;
}

}

```

`src/graphics/macos/macos_window_manager.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/macos/macos_window_manager.h"

#include <cstdint>
#include <memory>

#include "core/error_handling.h"
#include "graphics/macos/macos_window.h"

namespace iris
{

MacosWindowManager::MacosWindowManager(TextureManager &texture_manager, MaterialManager &material_manager)
    : texture_manager_(texture_manager)
    , material_manager_(material_manager)
    , current_window_()
{
}

Window *MacosWindowManager::create_window(std::uint32_t width, std::uint32_t height)
{
    ensure(!current_window_, "window already created");

    current_window_ = std::make_unique<MacosWindow>(width, height, texture_manager_, material_manager_);
    return current_window_.get();
}

Window *MacosWindowManager::current_window() const
{
    return current_window_.get();
}

}

```

`src/graphics/macos/metal_app_delegate.m`:

```m
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#import "graphics/macos/metal_app_delegate.h"

#import <Appkit/Appkit.h>
#import <CoreGraphics/CoreGraphics.h>
#import <Foundation/Foundation.h>
#import <Metal/Metal.h>
#import <MetalKit/MetalKit.h>
#import <QuartzCore/QuartzCore.h>

#include "graphics/macos/metal_view.h"

@implementation MetalAppDelegate

- (id)initWithRect:(NSRect)rect
{
    // call the super init, perform custom initialisation if this succeeds
    if (self = [super init])
    {
        [self setWidth:rect.size.width];
        [self setHeight:rect.size.height];

        MTLCreateSystemDefaultDevice();

        // create our window. It should have a title and render all content
        // to a buffer before being flushed, do not defer the creation of the
        // window
        NSWindow *window = [[NSWindow alloc] initWithContentRect:rect
                                                       styleMask:NSWindowStyleMaskTitled
                                                         backing:NSBackingStoreBuffered
                                                           defer:NO];

        // create and setup a metal view
        MetalView *view = [[MetalView alloc] initWithFrame:rect device:MTLCreateSystemDefaultDevice()];
        [view setClearColor:MTLClearColorMake(0, 0, 0, 1)];
        [view setColorPixelFormat:MTLPixelFormatRGBA16Float];
        [view setDepthStencilPixelFormat:MTLPixelFormatDepth32Float];

        CAMetalLayer *layer = (CAMetalLayer *)view.layer;

        const CFStringRef name = kCGColorSpaceExtendedSRGB;
        CGColorSpaceRef colorspace = CGColorSpaceCreateWithName(name);
        layer.colorspace = colorspace;
        layer.wantsExtendedDynamicRangeContent = YES;

        // add the view to the window
        [window setContentView:view];

        // centre the window on the screen
        [window center];

        // release window when it is closed
        [window setReleasedWhenClosed:YES];

        // show the window
        [window makeKeyAndOrderFront:self];

        [window makeFirstResponder:view];
        [window setColorSpace:[NSColorSpace genericRGBColorSpace]];
        [window setTitle:@"iris::metal"];

        // redraw the view before displaying
        [view setNeedsDisplay:YES];

        // create a tracking area the size of the screen
        NSTrackingArea *tracking = [[NSTrackingArea alloc] initWithRect:rect
                                                                options:NSTrackingMouseMoved | NSTrackingActiveAlways
                                                                  owner:view
                                                               userInfo:nil];

        // add the tracking area
        [view addTrackingArea:tracking];

        // hide and lock the cursor
        CGDisplayHideCursor(kCGDirectMainDisplay);
        CGAssociateMouseAndMouseCursorPosition(NO);
    }

    return self;
}

@end

```

`src/graphics/macos/metal_view.m`:

```m
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#import "graphics/macos/metal_view.h"

@implementation MetalView
{
}

- (BOOL)acceptsFirstResponder
{
    // make sure we receive key events
    return YES;
}

- (void)keyDown:(NSEvent *)theEvent
{
    // once we receive a key event we completely ignore it! This is because we
    // are handling these elsewhere, but having the view accept and ignore key
    // events prevents the annoying OS X doonk noise
}

@end

```

`src/graphics/macos/text_factory.mm`:

```mm
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/text_factory.h"

#include <array>
#include <cmath>
#include <memory>
#include <vector>

//#import <AppKit/AppKit.h>
#import <CoreFoundation/CoreFoundation.h>
#import <CoreGraphics/CoreGraphics.h>
#import <CoreText/CoreText.h>

#include "core/auto_release.h"
#include "core/colour.h"
#include "core/data_buffer.h"
#include "core/error_handling.h"
#include "core/root.h"
#include "graphics/sampler.h"
#include "graphics/texture.h"
#include "graphics/texture_manager.h"
#include "log/log.h"

namespace iris::text_factory
{

Texture *create(const std::string &font_name, const std::uint32_t size, const std::string &text, const Colour &colour)
{
    // create a CoreFoundation string object from supplied Font name
    const auto font_name_cf = AutoRelease<CFStringRef, nullptr>{
        ::CFStringCreateWithCString(kCFAllocatorDefault, font_name.c_str(), kCFStringEncodingUTF8), ::CFRelease};
    expect(font_name_cf, "failed to create CF string");

    // create Font object
    AutoRelease<CTFontRef, nullptr> font = {
        ::CTFontCreateWithName(font_name_cf, static_cast<CGFloat>(size), nullptr), ::CFRelease};
    ensure(font, "failed to create font");

    // create a device dependant colour space
    AutoRelease<CGColorSpaceRef, nullptr> colour_space = {::CGColorSpaceCreateDeviceRGB(), ::CGColorSpaceRelease};
    expect(colour_space, "failed to create colour space");

    // create a CoreFoundation colour object from supplied colour
    const CGFloat components[] = {colour.r, colour.g, colour.b, colour.a};
    AutoRelease<CGColorRef, nullptr> font_colour = {::CGColorCreate(colour_space, components), ::CGColorRelease};
    expect(font_colour, "failed to create colour");

    std::array<CFStringRef, 2> keys = {{kCTFontAttributeName, kCTForegroundColorAttributeName}};
    std::array<CFTypeRef, 2> values = {{font, font_colour}};

    // create string attributes dictionary, containing Font name and colour
    AutoRelease<CFDictionaryRef, nullptr> attributes = {
        ::CFDictionaryCreate(
            kCFAllocatorDefault,
            reinterpret_cast<const void **>(keys.data()),
            reinterpret_cast<const void **>(values.data()),
            keys.size(),
            &kCFTypeDictionaryKeyCallBacks,
            &kCFTypeDictionaryValueCallBacks),
        ::CFRelease};
    expect(attributes, "failed to create attributes");

    LOG_DEBUG("font", "creating sprites for string: {}", text);

    // create CoreFoundation string object from supplied text
    const auto text_cf = AutoRelease<CFStringRef, nullptr>{
        ::CFStringCreateWithCString(kCFAllocatorDefault, text.c_str(), kCFStringEncodingUTF8), ::CFRelease};

    // create a CoreFoundation attributed string object
    const auto attr_string = AutoRelease<CFAttributedStringRef, nullptr>{
        ::CFAttributedStringCreate(kCFAllocatorDefault, text_cf, attributes), ::CFRelease};

    const auto frame_setter =
        AutoRelease<CTFramesetterRef, nullptr>{::CTFramesetterCreateWithAttributedString(attr_string), ::CFRelease};

    // calculate minimal size required to render text
    CFRange range;
    const auto rect = ::CTFramesetterSuggestFrameSizeWithConstraints(
        frame_setter, CFRangeMake(0, 0), nullptr, CGSizeMake(CGFLOAT_MAX, CGFLOAT_MAX), &range);

    // create a path object to render text
    const auto path = AutoRelease<CGPathRef, nullptr>{
        ::CGPathCreateWithRect(CGRectMake(0, 0, std::ceil(rect.width), std::ceil(rect.height)), nullptr), nullptr};
    expect(path, "failed to create path");

    // create a frame to render text
    const auto frame =
        AutoRelease<CTFrameRef, nullptr>{::CTFramesetterCreateFrame(frame_setter, range, path, nullptr), ::CFRelease};
    expect(frame, "failed to create frame");

    const auto width = static_cast<std::uint32_t>(rect.width);
    const auto height = static_cast<std::uint32_t>(rect.height);

    // allocate enough space to store RGBA tuples for each pixel
    DataBuffer pixel_data(width * height * 4u);

    const auto bits_per_pixel = 8u;
    const auto bytes_per_row = width * 4u;

    // create a context for rendering text
    const auto context = AutoRelease<CGContextRef, nullptr>{
        ::CGBitmapContextCreateWithData(
            pixel_data.data(),
            width,
            height,
            bits_per_pixel,
            bytes_per_row,
            colour_space,
            kCGImageAlphaPremultipliedLast,
            nullptr,
            nullptr),
        nullptr};
    expect(context, "failed to create context");

    // render text, pixel data will be stored in our pixel data buffer
    ::CTFrameDraw(frame, context);
    ::CGContextFlush(context);

    // we have rendered the font with premultiplied alpha - which will change the rgb values based on the alpha
    // component and can leave dark artifacts around the letters (especially with a light font on a light background)
    // to fix this we remove the premultiplied alpha component from the rgb
    for (auto i = 0u; i < pixel_data.size(); i += 4u)
    {
        if (pixel_data[i + 3u] != std::byte{0x00})
        {
            const auto alpha = static_cast<float>(pixel_data[i + 3u]) / 255.0f;
            pixel_data[i + 0u] =
                static_cast<std::byte>(((static_cast<float>(pixel_data[i + 0u]) / 255.0f) / alpha) * 255.0f);
            pixel_data[i + 1u] =
                static_cast<std::byte>(((static_cast<float>(pixel_data[i + 1u]) / 255.0f) / alpha) * 255.0f);
            pixel_data[i + 2u] =
                static_cast<std::byte>(((static_cast<float>(pixel_data[i + 2u]) / 255.0f) / alpha) * 255.0f);
        }
    }

    // using linear filters can also lead to dark borders - so set an appropriate sampler
    auto *sampler = Root::texture_manager().create(SamplerDescriptor{
        .minification_filter = SamplerFilter::NEAREST,
        .magnification_filter = SamplerFilter::NEAREST,
        .uses_mips = false,
        .mip_filter = SamplerFilter::NEAREST});
    auto *texture = Root::texture_manager().create(pixel_data, width, height, TextureUsage::IMAGE, sampler);

    return texture;
}

}

```

`src/graphics/material.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/material.h"

#include <cstddef>
#include <span>

#include "graphics/material_manager.h"
#include "graphics/render_graph/render_graph.h"

namespace iris
{

Material::Material(const RenderGraph *render_graph)
    : property_buffer_()
{
    if (render_graph != nullptr)
    {
        property_buffer_ = render_graph->property_buffer();
    }
}

std::span<std::byte> Material::property_buffer() const
{
    return property_buffer_;
}

}

```

`src/graphics/material_manager.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/material_manager.h"

#include <array>
#include <cstddef>
#include <span>

namespace iris
{

std::span<std::byte> MaterialManager::create_property_buffer()
{
    auto &new_buffer = property_buffers_.emplace_back();
    return {std::begin(new_buffer), std::end(new_buffer)};
}

}

```

`src/graphics/mesh.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/mesh.h"

#include <cstdint>
#include <functional>
#include <vector>

#include "graphics/vertex_data.h"

namespace iris
{

Mesh::Mesh(const std::vector<VertexData> &vertices, const std::vector<std::uint32_t> &indices)
    : vertices_(vertices)
    , indices_(indices)
{
}

const std::vector<VertexData> &Mesh::vertices() const
{
    return vertices_;
}

const std::vector<std::uint32_t> &Mesh::indices() const
{
    return indices_;
}

}

```

`src/graphics/mesh_loader.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/mesh_loader.h"

#include <cstdint>
#include <functional>
#include <stack>
#include <string>
#include <vector>

#include <assimp/Importer.hpp>
#include <assimp/postprocess.h>
#include <assimp/scene.h>

#include "core/colour.h"
#include "core/error_handling.h"
#include "core/matrix4.h"
#include "core/quaternion.h"
#include "core/resource_manager.h"
#include "core/transform.h"
#include "core/vector3.h"
#include "graphics/animation/animation.h"
#include "graphics/bone.h"
#include "graphics/skeleton.h"
#include "graphics/vertex_data.h"
#include "log/log.h"

namespace
{

/**
 * Helper function to convert an assimp Matrix to an engine one.
 *
 * @param matrix
 *   Assimp matrix.
 *
 * @returns
 *   Engine matrix.
 */
iris::Matrix4 convert_matrix(const ::aiMatrix4x4 &matrix)
{
    return iris::Matrix4{
        {{matrix.a1,
          matrix.a2,
          matrix.a3,
          matrix.a4,
          matrix.b1,
          matrix.b2,
          matrix.b3,
          matrix.b4,
          matrix.c1,
          matrix.c2,
          matrix.c3,
          matrix.c4,
          matrix.d1,
          matrix.d2,
          matrix.d3,
          matrix.d4}}};
}

/**
 * Get the animations from an assimp scene.
 *
 * @param scene
 *   Scene to get animations from.
 *
 * @returns
 *   Animations.
 */
std::vector<iris::Animation> process_animations(const ::aiScene *scene)
{
    std::vector<iris::Animation> animations{};

    // parse each animation
    for (auto i = 0u; i < scene->mNumAnimations; ++i)
    {
        const auto *animation = scene->mAnimations[i];

        auto ticks_per_second = animation->mTicksPerSecond;
        if (ticks_per_second == 0.0f)
        {
            LOG_WARN("ms", "no ticks per second - guessing");
            ticks_per_second = 33.0f;
        }

        const std::chrono::milliseconds tick_time{static_cast<std::uint32_t>((1.0f / ticks_per_second) * 1000u)};
        const auto duration = tick_time * static_cast<std::uint32_t>(animation->mDuration);

        std::map<std::string, std::vector<iris::KeyFrame>, std::less<>> nodes;

        // each channel is a collection of keys
        for (auto j = 0u; j < animation->mNumChannels; ++j)
        {
            const auto *channel = animation->mChannels[j];

            // sanity check we have an equal number of keys for position,
            // rotation and scale
            iris::ensure(
                (channel->mNumPositionKeys == channel->mNumRotationKeys) ||
                    (channel->mNumRotationKeys == channel->mNumScalingKeys),
                "incomplete frame data");

            std::vector<iris::KeyFrame> keyframes{};

            // convert assimp keys into keyframes
            for (auto k = 0u; k < channel->mNumPositionKeys; ++k)
            {
                const auto assimp_pos = channel->mPositionKeys[k].mValue;
                const auto assimp_rot = channel->mRotationKeys[k].mValue;
                const auto assimp_scale = channel->mScalingKeys[k].mValue;
                const auto time = static_cast<std::uint32_t>(channel->mPositionKeys[k].mTime);

                keyframes.emplace_back(
                    iris::Transform{
                        {assimp_pos.x, assimp_pos.y, assimp_pos.z},
                        {assimp_rot.x, assimp_rot.y, assimp_rot.z, assimp_rot.w},
                        {assimp_scale.x, assimp_scale.y, assimp_scale.z}},
                    time * tick_time);
            }

            nodes[channel->mNodeName.C_Str()] = keyframes;
        }

        animations.emplace_back(duration, animation->mName.C_Str(), nodes);
    }

    return animations;
}

/**
 * Get the bones from an assimp scene.
 *
 * Assimp has two separate concepts for animation data:
 *   bone - offset matrix and collection of vertices it effects
 *   node - hierarchical object containing transformation
 *
 * An assimp node may refer to a bone, or it may just represent an intermediate
 * transformation between bones. We unify both of these assimp concepts into an
 * engine Bone. Our Bone may or may not effect vertices and maintains the same
 * hierarchy as the assimp nodes.
 *
 * @param scene
 *   Scene to get bones from.
 *
 * @returns
 *   Bones.
 */
std::vector<iris::Bone> process_bones(const aiScene *scene)
{
    std::vector<iris::Bone> bones{};

    std::stack<std::tuple<const ::aiNode *, std::string>> nodes;
    nodes.emplace(scene->mRootNode, std::string{});

    // walk the node hierarchy
    do
    {
        auto [node, parent_name] = nodes.top();
        nodes.pop();

        const std::string name{node->mName.C_Str()};

        // create a bone which represents the nodes transformation but effects
        // no vertices
        iris::Bone bone{name, parent_name, {}, convert_matrix(node->mTransformation)};

        for (auto i = 0u; i < scene->mNumMeshes; ++i)
        {
            const auto *mesh = scene->mMeshes[i];

            // see if this node represents an assimp bone
            for (auto j = 0u; j < mesh->mNumBones; ++j)
            {
                const ::aiBone *ai_bone = mesh->mBones[j];

                if (std::string(ai_bone->mName.C_Str()) == name)
                {
                    // replace bone with one that stores the weights as well the correct matrices
                    bone = {
                        name,
                        parent_name,
                        convert_matrix(ai_bone->mOffsetMatrix),
                        convert_matrix(node->mTransformation)};

                    break;
                }
            }
        }

        bones.emplace_back(bone);

        for (auto i = 0u; i < node->mNumChildren; ++i)
        {
            nodes.emplace(node->mChildren[i], name);
        }
    } while (!nodes.empty());

    // always return at least one default bone
    if (bones.empty())
    {
        bones.emplace_back("root", "", iris::Matrix4{}, iris::Matrix4{});
    }

    return bones;
}

/**
 * Get the weights for a given assimp mesh.
 *
 * @param mesh
 *   Mesh to get weights for.
 *
 * @returns
 *   Collection of bone weights.
 */
std::vector<iris::Weight> process_weights(const aiMesh *mesh)
{
    std::vector<iris::Weight> weights{};

    for (auto j = 0u; j < mesh->mNumBones; ++j)
    {
        const ::aiBone *ai_bone = mesh->mBones[j];

        for (auto k = 0u; k < ai_bone->mNumWeights; ++k)
        {
            const auto &weight = ai_bone->mWeights[k];
            weights.push_back(
                {.vertex = weight.mVertexId, .weight = weight.mWeight, .bone_name = ai_bone->mName.C_Str()});
        }
    }

    return weights;
}

/**
 * Get the indices for the given mesh.
 *
 * @param mesh
 *   Mesh to get vertices for.
 *
 * @returns
 *   Indices.
 */
std::vector<std::uint32_t> process_indices(const ::aiMesh *mesh)
{
    std::vector<std::uint32_t> indices{};

    for (auto i = 0u; i < mesh->mNumFaces; ++i)
    {
        const auto &face = mesh->mFaces[i];
        for (auto j = 0u; j < face.mNumIndices; ++j)
        {
            indices.emplace_back(face.mIndices[j]);
        }
    }

    return indices;
}

/**
 * Get the vertices for the given mesh.
 *
 * @param mesh
 *   Mesh to get vertices for.
 *
 * @param material
 *   Material for current mesh.
 *
 * @returns
 *   Vertex data.
 */
std::vector<iris::VertexData> process_vertices(const ::aiMesh *mesh, const ::aiMaterial *material)
{
    std::vector<iris::VertexData> vertices{};

    for (auto i = 0u; i < mesh->mNumVertices; ++i)
    {
        const auto &vertex = mesh->mVertices[i];
        const auto &normal = mesh->mNormals[i];
        iris::Colour colour{1.0f, 1.0f, 1.0f};
        iris::Vector3 texture_coords{};
        iris::Vector3 tangent{};
        iris::Vector3 bitangent{};

        // get texture coordinates if they exist
        if (mesh->HasTextureCoords(0))
        {
            texture_coords.x = mesh->mTextureCoords[0][i].x;
            texture_coords.y = mesh->mTextureCoords[0][i].y;

            tangent.x = mesh->mTangents[i].x;
            tangent.y = mesh->mTangents[i].y;
            tangent.z = mesh->mTangents[i].z;

            bitangent.x = mesh->mBitangents[i].x;
            bitangent.y = mesh->mBitangents[i].y;
            bitangent.z = mesh->mBitangents[i].z;
        }

        // only support diffuse colour
        ::aiColor3D c(0.f, 0.f, 0.f);
        material->Get(AI_MATKEY_COLOR_DIFFUSE, c);
        colour.r = c.r;
        colour.g = c.g;
        colour.b = c.b;

        vertices.emplace_back(
            iris::Vector3(vertex.x, vertex.y, vertex.z),
            iris::Vector3(normal.x, normal.y, normal.z),
            colour,
            texture_coords,
            tangent,
            bitangent);
    }

    return vertices;
}
}

namespace iris::mesh_loader
{

void load(
    ResourceManager &resource_manager,
    std::string_view mesh_name,
    bool flip_uvs,
    MeshDataCallback mesh_data_callback,
    AnimationCallback animation_callback)
{
    const auto file_data = resource_manager.load(mesh_name);

    const auto import_flags = flip_uvs ? aiProcess_Triangulate | aiProcess_CalcTangentSpace | aiProcess_FlipUVs
                                       : aiProcess_Triangulate | aiProcess_CalcTangentSpace;

    // parse file using assimp
    ::Assimp::Importer importer{};
    const auto *scene = importer.ReadFileFromMemory(file_data.data(), file_data.size(), import_flags);

    ensure(
        (scene != nullptr) && !(scene->mFlags & AI_SCENE_FLAGS_INCOMPLETE) && (scene->mRootNode != nullptr),
        std::string{"could not load mesh: "} + importer.GetErrorString());

    if (scene->mAnimations != 0u)
    {
        animation_callback(process_animations(scene), {process_bones(scene)});
    }

    const auto *root = scene->mRootNode;

    std::stack<const aiNode *> to_process;
    to_process.emplace(root);

    // walk the assimp scene
    do
    {
        const auto *node = to_process.top();
        to_process.pop();

        for (auto i = 0u; i < node->mNumMeshes; ++i)
        {
            const auto *mesh = scene->mMeshes[node->mMeshes[i]];
            const auto *material = scene->mMaterials[mesh->mMaterialIndex];

            std::string texture_name;
            aiString assimp_str{};
            if (material->GetTexture(aiTextureType_DIFFUSE, 0u, &assimp_str) == aiReturn_SUCCESS)
            {
                texture_name = assimp_str.C_Str();
            }

            mesh_data_callback(
                process_vertices(mesh, material), process_indices(mesh), process_weights(mesh), texture_name);
        }

        // add child nodes so we visit all meshes
        for (auto i = 0u; i < node->mNumChildren; ++i)
        {
            to_process.emplace(node->mChildren[i]);
        }
    } while (!to_process.empty());
}

}

```

`src/graphics/mesh_manager.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/mesh_manager.h"

#include <cmath>
#include <cstdint>
#include <queue>
#include <sstream>
#include <stack>
#include <vector>

#include "core/colour.h"
#include "core/error_handling.h"
#include "core/transform.h"
#include "core/vector3.h"
#include "graphics/bone.h"
#include "graphics/mesh.h"
#include "graphics/mesh_loader.h"
#include "graphics/skeleton.h"
#include "graphics/texture.h"
#include "graphics/vertex_data.h"
#include "log/log.h"

namespace iris
{

MeshManager::MeshManager(ResourceManager &resource_manager, bool flip_uvs_on_load)
    : resource_manager_(resource_manager)
    , loaded_meshes_()
    , loaded_animations_()
    , loaded_skeletons_()
    , skeleton_copies_()
    , flip_uvs_on_load_(flip_uvs_on_load)
{
}

const Mesh *MeshManager::sprite(const Colour &colour)
{
    // create a unique for this mesh
    std::stringstream strm{};
    strm << "!sprite" << colour;
    const auto id = strm.str();

    if (loaded_meshes_.count(id) == 0u)
    {
        std::vector<VertexData> vertices{
            {{-1.0, 1.0, 0.0f}, {}, colour, {0.0f, 0.0f, 0.0f}},
            {{1.0, 1.0, 0.0f}, {}, colour, {1.0f, 0.0f, 0.0f}},
            {{1.0, -1.0, 0.0f}, {}, colour, {1.0f, 1.0f, 0.0f}},
            {{-1.0, -1.0, 0.0f}, {}, colour, {0.0f, 1.0f, 0.0f}}};

        std::vector<std::uint32_t> indices{0, 2, 1, 3, 2, 0};

        loaded_meshes_[id].push_back({.mesh = create_mesh(vertices, indices)});
    }

    return loaded_meshes_[id].front().mesh.get();
}

const Mesh *MeshManager::cube(const Colour &colour)
{
    // create a unique for this mesh
    std::stringstream strm{};
    strm << "!cube" << colour;

    const auto id = strm.str();

    if (loaded_meshes_.count(id) == 0u)
    {
        loaded_meshes_[id].push_back({.mesh = unique_cube(colour)});
    }

    return loaded_meshes_[id].front().mesh.get();
}

std::unique_ptr<Mesh> MeshManager::unique_cube(const Colour &colour) const
{
    std::vector<VertexData> vertices{
        {{1.0f, 1.0f, 1.0f}, {0.0f, 0.0f, 1.0f}, colour, {0.0f, 0.0f, 0.0f}},
        {{-1.0f, 1.0f, 1.0f}, {0.0f, 0.0f, 1.0f}, colour, {1.0f, 0.0f, 0.0f}},
        {{-1.0f, -1.0f, 1.0f}, {0.0f, 0.0f, 1.0f}, colour, {1.0f, 1.0f, 0.0f}},
        {{1.0f, -1.0f, 1.0f}, {0.0f, 0.0f, 1.0f}, colour, {0.0f, 1.0f, 0.0f}},
        {{1.0f, -1.0f, -1.0f}, {0.0f, -1.0f, 0.0f}, colour, {0.0f, 0.0f, 0.0f}},
        {{1.0f, -1.0f, 1.0f}, {0.0f, -1.0f, 0.0f}, colour, {1.0f, 0.0f, 0.0f}},
        {{-1.0f, -1.0f, 1.0f}, {0.0f, -1.0f, 0.0f}, colour, {1.0f, 1.0f, 0.0f}},
        {{-1.0f, -1.0f, -1.0f}, {0.0f, -1.0f, 0.0f}, colour, {0.0f, 1.0f, 0.0f}},
        {{-1.0f, -1.0f, -1.0f}, {-1.0f, 0.0f, 0.0f}, colour, {0.0f, 0.0f, 0.0f}},
        {{-1.0f, -1.0f, 1.0f}, {-1.0f, 0.0f, 0.0f}, colour, {1.0f, 0.0f, 0.0f}},
        {{-1.0f, 1.0f, 1.0f}, {-1.0f, 0.0f, 0.0f}, colour, {1.0f, 1.0f, 0.0f}},
        {{-1.0f, 1.0f, -1.0f}, {-1.0f, 0.0f, 0.0f}, colour, {0.0f, 1.0f, 0.0f}},
        {{-1.0f, 1.0f, -1.0f}, {0.0f, 0.0f, -1.0f}, colour, {0.0f, 0.0f, 0.0f}},
        {{1.0f, 1.0f, -1.0f}, {0.0f, 0.0f, -1.0f}, colour, {1.0f, 0.0f, 0.0f}},
        {{1.0f, -1.0f, -1.0f}, {0.0f, 0.0f, -1.0f}, colour, {1.0f, 1.0f, 0.0f}},
        {{-1.0f, -1.0f, -1.0f}, {0.0f, 0.0f, -1.0f}, colour, {0.0f, 1.0f, 0.0f}},
        {{1.0f, 1.0f, -1.0f}, {1.0f, 0.0f, 0.0f}, colour, {0.0f, 0.0f, 0.0f}},
        {{1.0f, 1.0f, 1.0f}, {1.0f, 0.0f, 0.0f}, colour, {1.0f, 0.0f, 0.0f}},
        {{1.0f, -1.0f, 1.0f}, {1.0f, 0.0f, 0.0f}, colour, {1.0f, 1.0f, 0.0f}},
        {{1.0f, -1.0f, -1.0f}, {1.0f, 0.0f, 0.0f}, colour, {0.0f, 1.0f, 0.0f}},
        {{-1.0f, 1.0f, -1.0f}, {0.0f, 1.0f, 0.0f}, colour, {0.0f, 0.0f, 0.0f}},
        {{-1.0f, 1.0f, 1.0f}, {0.0f, 1.0f, 0.0f}, colour, {1.0f, 0.0f, 0.0f}},
        {{1.0f, 1.0f, 1.0f}, {0.0f, 1.0f, 0.0f}, colour, {1.0f, 1.0f, 0.0f}},
        {{1.0f, 1.0f, -1.0f}, {0.0f, 1.0f, 0.0f}, colour, {0.0f, 1.0f, 0.0f}}};

    std::vector<std::uint32_t> indices{0,  1,  2,  0,  2,  3,  4,  5,  6,  4,  6,  7,  8,  9,  10, 8,  10, 11,
                                       12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23};

    return create_mesh(vertices, indices);
}

std::unique_ptr<Mesh> MeshManager::unique_mesh(
    const std::vector<iris::VertexData> &vertices,
    const std::vector<std::uint32_t> &indices) const
{
    return create_mesh(vertices, indices);
}

const Mesh *MeshManager::plane(const Colour &colour, std::uint32_t divisions, float scale)
{
    expect(divisions != 0, "divisions must be >= 0");

    // create a unique for this mesh
    std::stringstream strm{};
    strm << "!plane" << colour << ":" << divisions;
    const auto id = strm.str();

    if (loaded_meshes_.count(id) == 0u)
    {
        std::vector<VertexData> vertices(static_cast<std::size_t>(std::pow(divisions + 1u, 2u)));

        const Vector3 normal{0.0f, 1.0f, 0.0f};
        const Vector3 tangent{1.0f, 0.0f, 0.0f};
        const Vector3 bitangent{0.0f, 0.0f, 1.0f};

        const auto width_unit = (1.0f / static_cast<float>(divisions));
        const auto width = width_unit * scale;
        const auto offset = 0.5f * scale;

        for (auto y = 0u; y <= divisions; ++y)
        {
            for (auto x = 0u; x <= divisions; ++x)
            {
                vertices[(y * (divisions + 1u)) + x] = {
                    {(x * width) - offset, 0.0f, (y * width) - offset},
                    normal,
                    colour,
                    {(x * width_unit) * divisions, (scale - (y * width_unit)) * divisions, 0.0f},
                    tangent,
                    bitangent};
            }
        }

        std::vector<std::uint32_t> indices{};

        for (auto y = 0u; y < divisions; ++y)
        {
            for (auto x = 0u; x < divisions; ++x)
            {
                indices.emplace_back((y * (divisions + 1u) + x));
                indices.emplace_back(((y + 1) * (divisions + 1u) + x));
                indices.emplace_back((y * (divisions + 1u) + x + 1u));
                indices.emplace_back((y * (divisions + 1u) + x + 1u));
                indices.emplace_back(((y + 1) * (divisions + 1u) + x));
                indices.emplace_back(((y + 1) * (divisions + 1u) + x + 1u));
            }
        }

        loaded_meshes_[id].push_back({.mesh = create_mesh(vertices, indices)});
    }

    return loaded_meshes_[id].front().mesh.get();
}

const Mesh *MeshManager::heightmap(const Colour &colour, const Texture *height_image)
{
    ensure(height_image->width() == height_image->height(), "height_image must be square");

    // create a unique for this mesh
    std::stringstream strm{};
    strm << "!height_map" << colour << ":" << height_image;
    const auto id = strm.str();

    const auto divisions = height_image->width();
    const auto &height_data = height_image->data();

    if (loaded_meshes_.count(id) == 0u)
    {
        std::vector<VertexData> vertices(static_cast<std::size_t>(std::pow(divisions, 2u)));

        const Vector3 tangent{1.0f, 0.0f, 0.0f};
        const Vector3 bitangent{0.0f, 1.0f, 0.0f};

        const auto width = 1.0f / static_cast<float>(divisions);

        // lambda to get adjacent points (clamped to edges)
        const auto get_adjacent =
            [&height_data,
             divisions,
             width](std::uint32_t x, std::uint32_t z, std::int32_t offset_x, std::int32_t offset_z) -> Vector3 {
            auto adj_x = x;
            if (x != 0u && offset_x == -1)
            {
                --adj_x;
            }
            else if (x != (divisions - 1u) && offset_x == 1)
            {
                ++adj_x;
            }

            auto adj_z = z;
            if (z != 0u && offset_z == -1)
            {
                --adj_z;
            }
            else if (z != (divisions - 1u) && offset_z == 1)
            {
                ++adj_z;
            }

            const auto raw_y = height_data[((adj_z * divisions) + adj_x) * 4u];
            const auto y = static_cast<float>(raw_y) / 255.0f;

            return {(adj_x * width) - 0.5f, y, (adj_z * width) - 0.5f};
        };

        for (auto z = 0u; z < divisions; ++z)
        {
            for (auto x = 0u; x < divisions; ++x)
            {
                const auto right = get_adjacent(x, z, 1, 0);
                const auto left = get_adjacent(x, z, -1, 0);
                const auto top = get_adjacent(x, z, 0, -1);
                const auto bottom = get_adjacent(x, z, 0, 1);

                const auto raw_y = height_data[((z * divisions) + x) * 4u];
                const auto y = static_cast<float>(raw_y) / 255.0f;

                vertices[(z * (divisions)) + x] = {
                    {(x * width) - 0.5f, y, (z * width) - 0.5f},
                    Vector3::normalise(Vector3::cross((right - left), (top - bottom))),
                    colour,
                    {(x * width) * 30.0f, (1.0f - (z * width)) * 30.0f, 0.0f},
                    tangent,
                    bitangent};
            }
        }

        std::vector<std::uint32_t> indices{};

        for (auto z = 0u; z < divisions - 1u; ++z)
        {
            for (auto x = 0u; x < divisions - 1u; ++x)
            {
                indices.emplace_back((z * (divisions) + x));
                indices.emplace_back(((z + 1) * (divisions) + x));
                indices.emplace_back((z * (divisions) + x + 1u));
                indices.emplace_back((z * (divisions) + x + 1u));
                indices.emplace_back(((z + 1) * (divisions) + x));
                indices.emplace_back(((z + 1) * (divisions) + x + 1u));
            }
        }

        loaded_meshes_[id].push_back({.mesh = create_mesh(vertices, indices)});
    }

    return loaded_meshes_[id].front().mesh.get();
}

const Mesh *MeshManager::quad(
    const Colour &colour,
    const Vector3 &lower_left,
    const Vector3 &lower_right,
    const Vector3 &upper_left,
    const Vector3 &upper_right)
{
    // create a unique for this mesh
    std::stringstream strm{};
    strm << "!quad" << colour << ":" << lower_left << ":" << lower_right << ":" << upper_left << ":" << upper_right;
    const auto id = strm.str();

    if (loaded_meshes_.count(id) == 0u)
    {
        std::vector<VertexData> vertices{
            {upper_left, {}, colour, {0.0f, 1.0f, 0.0f}},
            {upper_right, {}, colour, {1.0f, 1.0f, 0.0f}},
            {lower_right, {}, colour, {1.0f, 0.0f, 0.0f}},
            {lower_left, {}, colour, {0.0f, 0.0f, 0.0f}}};

        std::vector<std::uint32_t> indices{0, 2, 1, 3, 2, 0};

        loaded_meshes_[id].push_back({.mesh = create_mesh(vertices, indices)});
    }

    return loaded_meshes_[id].front().mesh.get();
}

MeshManager::Meshes MeshManager::load_mesh(const std::string &mesh_file)
{
    if (!loaded_meshes_.contains(mesh_file))
    {
        expect(!loaded_animations_.contains(mesh_file), "unexpected animations");
        expect(!loaded_skeletons_.contains(mesh_file), "unexpected skeleton");

        mesh_loader::load(
            resource_manager_,
            mesh_file,
            flip_uvs_on_load_,
            [this, &mesh_file](auto vertices, auto indices, auto weights, const auto &texture_name) {
                if (loaded_skeletons_.contains(mesh_file))
                {
                    const auto &skeleton = loaded_skeletons_[mesh_file];

                    std::vector<std::uint32_t> bone_indices(vertices.size());

                    // stamp bone data into loaded vertices
                    for (const auto &[id, weight, bone_name] : weights)
                    {
                        if (weight == 0.0f)
                        {
                            continue;
                        }

                        // only support four bones per vertex
                        if (bone_indices[id] >= 4)
                        {
                            LOG_ENGINE_WARN("mf", "too many weights {} {}", id, weight);
                            continue;
                        }

                        const auto bone_index = skeleton.bone_index(bone_name);

                        // update vertex data with bone data
                        vertices[id].bone_ids[bone_indices[id]] = static_cast<std::uint32_t>(bone_index);
                        vertices[id].bone_weights[bone_indices[id]] = weight;

                        ++bone_indices[id];
                    }
                }

                loaded_meshes_[mesh_file].push_back(
                    {.mesh = create_mesh(vertices, indices), .texture_name = texture_name});
            },
            [this, &mesh_file](auto animations, auto skeleton) {
                loaded_animations_[mesh_file] = std::move(animations);
                loaded_skeletons_[mesh_file] = std::move(skeleton);
            });
    }

    Meshes meshes{};

    for (const auto &[mesh, texture_name] : loaded_meshes_[mesh_file])
    {
        meshes.mesh_data.push_back({.mesh = mesh.get(), .texture_name = texture_name});
    };

    meshes.animations = loaded_animations_[mesh_file];
    meshes.skeleton = std::addressof(skeleton_copies_.emplace_back(loaded_skeletons_[mesh_file]));

    return meshes;
}

}

```

`src/graphics/metal/CMakeLists.txt`:

```txt
set(INCLUDE_ROOT "${PROJECT_SOURCE_DIR}/include/iris/graphics/metal")

target_sources(iris PRIVATE
    ${INCLUDE_ROOT}/metal_buffer.h
    ${INCLUDE_ROOT}/metal_constant_buffer.h
    ${INCLUDE_ROOT}/metal_cube_map.h
    ${INCLUDE_ROOT}/metal_material.h
    ${INCLUDE_ROOT}/metal_material_manager.h
    ${INCLUDE_ROOT}/metal_mesh.h
    ${INCLUDE_ROOT}/metal_mesh_manager.h
    ${INCLUDE_ROOT}/metal_render_target.h
    ${INCLUDE_ROOT}/metal_render_target_manager.h
    ${INCLUDE_ROOT}/metal_renderer.h
    ${INCLUDE_ROOT}/metal_sampler.h
    ${INCLUDE_ROOT}/metal_texture.h
    ${INCLUDE_ROOT}/metal_texture_manager.h
    metal_buffer.mm
    metal_constant_buffer.mm
    metal_cube_map.mm
    metal_material.mm
    metal_material_manager.mm
    metal_mesh.mm
    metal_mesh_manager.mm
    metal_render_target.mm
    metal_render_target_manager.mm
    metal_renderer.mm
    metal_sampler.mm
    metal_texture.mm
    metal_texture_manager.mm)

```

`src/graphics/metal/metal_buffer.mm`:

```mm
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/metal/metal_buffer.h"

#include <cstddef>
#include <cstdint>
#include <vector>

#import <Metal/Metal.h>

#include "core/macos/macos_ios_utility.h"
#include "graphics/vertex_data.h"

namespace
{

/**
 * Helper function to create a metal Buffer from a collection of objects.
 *
 * @param data
 *   Data to store on buffer.
 *
 * @returns
 *   Handle to metal buffer.
 */
template <class T>
id<MTLBuffer> create_buffer(const std::vector<T> &data)
{
    auto *device = iris::core::utility::metal_device();

    // create buffer with data
    return [device newBufferWithBytes:static_cast<const void *>(data.data())
                               length:sizeof(T) * data.size()
                              options:MTLResourceCPUCacheModeDefaultCache];
}

}

namespace iris
{

MetalBuffer::MetalBuffer(const std::vector<VertexData> &vertex_data)
    : handle_(create_buffer(vertex_data))
    , element_count_(vertex_data.size())
    , capacity_(vertex_data.size())
{
}

MetalBuffer::MetalBuffer(const std::vector<std::uint32_t> &index_data)
    : handle_(create_buffer(index_data))
    , element_count_(index_data.size())
    , capacity_(index_data.size())
{
}

id<MTLBuffer> MetalBuffer::handle() const
{
    return handle_;
}

std::size_t MetalBuffer::element_count() const
{
    return element_count_;
}

void MetalBuffer::write(const std::vector<VertexData> &vertex_data)
{
    // if the new data is larger than existing buffer then allocate a new,
    // larger, buffer (with the new data
    // else copy new data into existing buffer
    if (vertex_data.size() > capacity_)
    {
        handle_ = create_buffer(vertex_data);
        element_count_ = vertex_data.size();
        capacity_ = element_count_;
    }
    else
    {
        std::memcpy(handle_.contents, vertex_data.data(), vertex_data.size() * sizeof(VertexData));
        element_count_ = vertex_data.size();
    }
}

void MetalBuffer::write(const std::vector<std::uint32_t> &index_data)
{
    // if the new data is larger than existing buffer then allocate a new,
    // larger, buffer (with the new data
    // else copy new data into existing buffer
    if (index_data.size() > capacity_)
    {
        handle_ = create_buffer(index_data);
        element_count_ = index_data.size();
        capacity_ = element_count_;
    }
    else
    {
        std::memcpy(handle_.contents, index_data.data(), index_data.size() * sizeof(std::uint32_t));
        element_count_ = index_data.size();
    }
}

}

```

`src/graphics/metal/metal_constant_buffer.mm`:

```mm
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/metal/metal_constant_buffer.h"

#include <cstddef>

#import <Metal/Metal.h>

#include "core/macos/macos_ios_utility.h"

namespace iris
{

MetalConstantBuffer::MetalConstantBuffer(std::size_t capacity)
    : buffer_(nullptr)
    , capacity_(capacity)
{
    auto *device = iris::core::utility::metal_device();

    // create buffer with data
    buffer_ = [device newBufferWithLength:capacity_ options:MTLResourceCPUCacheModeDefaultCache];
}

id<MTLBuffer> MetalConstantBuffer::handle() const
{
    return buffer_;
}

}

```

`src/graphics/metal/metal_cube_map.mm`:

```mm
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/metal/metal_cube_map.h"

#include <cstddef>

#import <Metal/Metal.h>

#include "core/data_buffer.h"
#include "core/error_handling.h"
#include "core/macos/macos_ios_utility.h"
#include "graphics/cube_map.h"
#include "graphics/sampler.h"

namespace iris
{

MetalCubeMap::MetalCubeMap(
    const DataBuffer &right_data,
    const DataBuffer &left_data,
    const DataBuffer &top_data,
    const DataBuffer &bottom_data,
    const DataBuffer &back_data,
    const DataBuffer &front_data,
    std::uint32_t width,
    std::uint32_t height,
    const Sampler *sampler,
    std::uint32_t index)
    : CubeMap(sampler, index)
    , texture_(nullptr)
{
    ensure(width == height, "cube map image must be square");

    auto *device = iris::core::utility::metal_device();

    const auto texture_descriptor =
        [MTLTextureDescriptor textureCubeDescriptorWithPixelFormat:MTLPixelFormatRGBA8Unorm_sRGB
                                                              size:width
                                                         mipmapped:NO];
    texture_descriptor.resourceOptions = MTLResourceStorageModeShared;
    texture_ = [device newTextureWithDescriptor:texture_descriptor];

    const std::byte *data_ptrs[] = {
        right_data.data(), left_data.data(), top_data.data(), bottom_data.data(), back_data.data(), front_data.data()};

    // setup region and byte properties of textures
    const auto region = MTLRegionMake2D(0, 0, width, height);
    const auto bytes_per_row = width * 4u;
    const auto bytes_per_image = bytes_per_row * height;

    // set data for each cube face
    for (auto i = 0u; i < 6u; ++i)
    {
        [texture_ replaceRegion:region
                    mipmapLevel:0
                          slice:i
                      withBytes:data_ptrs[i]
                    bytesPerRow:bytes_per_row
                  bytesPerImage:bytes_per_image];
    }
}

id<MTLTexture> MetalCubeMap::handle() const
{
    return texture_;
}

}

```

`src/graphics/metal/metal_material.mm`:

```mm
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/metal/metal_material.h"

#include <any>
#include <fstream>
#include <memory>
#include <string>

#import <Metal/Metal.h>

#include "core/error_handling.h"
#include "core/macos/macos_ios_utility.h"
#include "graphics/lights/lighting_rig.h"
#include "graphics/mesh.h"
#include "graphics/render_graph/render_graph.h"
#include "graphics/render_graph/shader_compiler.h"
#include "log/log.h"

namespace
{

/**
 * Helper function to load a metal shader and get a handle to a function.
 *
 * @param source
 *   Source of shader.
 *
 * @param function_name
 *   Name of function to get handle to.
 *
 * @returns
 *   Handle to function in loaded source.
 */
id<MTLFunction> load_function(const std::string &source, const std::string &function_name)
{
    auto *device = iris::core::utility::metal_device();

    NSError *error = nullptr;

    // load source
    const auto *library = [device newLibraryWithSource:iris::core::utility::string_to_nsstring(source)
                                               options:nullptr
                                                 error:&error];

    if (library == nullptr)
    {
        auto line_number = 1u;

        std::istringstream strm{source};
        for (std::string line; std::getline(strm, line);)
        {
            LOG_ENGINE_ERROR("metal_material", "{}: {}", line_number, line);
            ++line_number;
        }
        // an error occurred so parse error and throw
        const std::string error_message{[[error localizedDescription] UTF8String]};

        LOG_ENGINE_ERROR("metal_material", "{}", error_message);

        throw iris::Exception("failed to load shader: " + error_message);
    }

    return [library newFunctionWithName:iris::core::utility::string_to_nsstring(function_name)];
}

}

namespace iris
{

MetalMaterial::MetalMaterial(
    const RenderGraph *render_graph,
    MTLVertexDescriptor *descriptors,
    LightType light_type,
    bool render_to_normal_target,
    bool render_to_position_target,
    bool has_transparency)
    : Material(render_graph)
    , pipeline_state_()
{
    ShaderCompiler compiler{
        ShaderLanguage::MSL, render_graph, light_type, render_to_normal_target, render_to_position_target};

    const auto vertex_program = load_function(compiler.vertex_shader(), "vertex_main");
    const auto fragment_program = load_function(compiler.fragment_shader(), "fragment_main");

    auto *device = core::utility::metal_device();

    // get pipeline state handle
    auto *pipeline_state_descriptor = [[MTLRenderPipelineDescriptor alloc] init];
    [pipeline_state_descriptor setVertexFunction:vertex_program];
    [pipeline_state_descriptor setFragmentFunction:fragment_program];
    pipeline_state_descriptor.colorAttachments[0].pixelFormat = MTLPixelFormatRGBA16Float;
    [pipeline_state_descriptor setDepthAttachmentPixelFormat:MTLPixelFormatDepth32Float];
    [pipeline_state_descriptor setVertexDescriptor:descriptors];

    if (render_to_normal_target)
    {
        pipeline_state_descriptor.colorAttachments[1].pixelFormat = MTLPixelFormatRGBA16Float;
    }

    if (render_to_position_target)
    {
        pipeline_state_descriptor.colorAttachments[2].pixelFormat = MTLPixelFormatRGBA16Float;
    }

    [[[pipeline_state_descriptor colorAttachments] objectAtIndexedSubscript:0] setBlendingEnabled:false];

    if (light_type == LightType::AMBIENT)
    {
        if (has_transparency)
        {
            [[[pipeline_state_descriptor colorAttachments] objectAtIndexedSubscript:0] setBlendingEnabled:true];
            pipeline_state_descriptor.colorAttachments[0].rgbBlendOperation = MTLBlendOperationAdd;
            pipeline_state_descriptor.colorAttachments[0].sourceRGBBlendFactor = MTLBlendFactorSourceAlpha;
            pipeline_state_descriptor.colorAttachments[0].destinationRGBBlendFactor = MTLBlendFactorOneMinusSourceAlpha;
        }
    }
    else
    {
        [[[pipeline_state_descriptor colorAttachments] objectAtIndexedSubscript:0] setBlendingEnabled:true];
        pipeline_state_descriptor.colorAttachments[0].rgbBlendOperation = MTLBlendOperationAdd;
        pipeline_state_descriptor.colorAttachments[0].sourceRGBBlendFactor = MTLBlendFactorSourceAlpha;
        pipeline_state_descriptor.colorAttachments[0].destinationRGBBlendFactor = MTLBlendFactorOne;
    }

    NSError *error = nullptr;

    pipeline_state_ = [device newRenderPipelineStateWithDescriptor:pipeline_state_descriptor error:&error];

    expect(error == nullptr, "failed to create pipeline state");
}

id<MTLRenderPipelineState> MetalMaterial::pipeline_state() const
{
    return pipeline_state_;
}

}

```

`src/graphics/metal/metal_material_manager.mm`:

```mm
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/metal/metal_material_manager.h"

#include "graphics/lights/light_type.h"
#include "graphics/metal/metal_mesh.h"
#include "graphics/render_entity.h"
#include "graphics/render_graph/render_graph.h"

namespace iris
{

Material *MetalMaterialManager::create(
    RenderGraph *render_graph,
    RenderEntity *render_entity,
    LightType light_type,
    bool,
    bool render_to_normal_target,
    bool render_to_position_target,
    bool has_transparency)
{
    return materials_.try_emplace(
        render_graph,
        light_type,
        render_to_normal_target,
        render_to_position_target,
        render_graph,
        static_cast<const MetalMesh *>(render_entity->mesh())->descriptors(),
        light_type,
        render_to_normal_target,
        render_to_position_target,
        has_transparency);
}

void MetalMaterialManager::clear()
{
    materials_.clear();
}

}

```

`src/graphics/metal/metal_mesh.mm`:

```mm
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/metal/metal_mesh.h"

#include <cstdint>
#include <vector>

#import <Metal/Metal.h>

#include "core/exception.h"
#include "graphics/mesh.h"
#include "graphics/metal/metal_buffer.h"
#include "graphics/vertex_data.h"

namespace
{

/**
 * Helper function to convert engine attribute type to metal attribute type.
 *
 * @param type
 *   Engine type.
 *
 * @returns
 *    Metal type.
 */
MTLVertexFormat to_metal_format(iris::VertexAttributeType type)
{
    auto format = MTLVertexFormatInvalid;

    switch (type)
    {
        case iris::VertexAttributeType::FLOAT_3: format = MTLVertexFormatFloat3; break;
        case iris::VertexAttributeType::FLOAT_4: format = MTLVertexFormatFloat4; break;
        case iris::VertexAttributeType::UINT32_1: format = MTLVertexFormatUInt; break;
        case iris::VertexAttributeType::UINT32_4: format = MTLVertexFormatUInt4; break;
        default: throw iris::Exception("unknown vertex attribute type");
    }

    return format;
}

}

namespace iris
{

MetalMesh::MetalMesh(
    const std::vector<VertexData> &vertices,
    const std::vector<std::uint32_t> &indices,
    const VertexAttributes &attributes)
    : Mesh(vertices, indices)
    , vertex_buffer_(vertices_)
    , index_buffer_(indices_)
    , descriptors_(nullptr)
{
    descriptors_ = [[MTLVertexDescriptor alloc] init];

    auto index = 0u;

    // convert engine attribute information to metal
    for (const auto &[type, components, size, offset] : attributes)
    {
        descriptors_.attributes[index].format = to_metal_format(type);
        descriptors_.attributes[index].offset = offset;
        descriptors_.attributes[index].bufferIndex = 0u;

        ++index;
    }

    descriptors_.layouts[0u].stride = attributes.size();
}

void MetalMesh::update_vertex_data(const std::vector<VertexData> &data)
{
    vertex_buffer_.write(data);
}

void MetalMesh::update_index_data(const std::vector<std::uint32_t> &data)
{
    index_buffer_.write(data);
}

const MetalBuffer &MetalMesh::vertex_buffer() const
{
    return vertex_buffer_;
}

const MetalBuffer &MetalMesh::index_buffer() const
{
    return index_buffer_;
}

MTLVertexDescriptor *MetalMesh::descriptors() const
{
    return descriptors_;
}

}

```

`src/graphics/metal/metal_mesh_manager.mm`:

```mm
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/metal/metal_mesh_manager.h"

#include <cstdint>
#include <memory>
#include <vector>

#include "core/resource_manager.h"
#include "graphics/mesh.h"
#include "graphics/mesh_manager.h"
#include "graphics/metal/metal_mesh.h"
#include "graphics/vertex_data.h"

namespace iris
{

MetalMeshManager::MetalMeshManager(ResourceManager &resource_manager)
    : MeshManager(resource_manager, false)
{
}

std::unique_ptr<Mesh> MetalMeshManager::create_mesh(
    const std::vector<iris::VertexData> &vertices,
    const std::vector<std::uint32_t> &indices) const
{
    return std::make_unique<MetalMesh>(vertices, indices, DefaultVertexAttributes);
}

}

```

`src/graphics/metal/metal_render_target.mm`:

```mm
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/metal/metal_render_target.h"

#import <Metal/Metal.h>

#include "graphics/texture.h"

namespace iris
{

MetalRenderTarget::MetalRenderTarget(const Texture *colour_texture, const Texture *depth_texture)
    : RenderTarget(colour_texture, depth_texture)
{
}

}

```

`src/graphics/metal/metal_render_target_manager.mm`:

```mm
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/metal/metal_render_target_manager.h"

#include "graphics/metal/metal_render_target.h"
#include "graphics/metal/metal_texture.h"
#include "graphics/sampler.h"
#include "graphics/texture_manager.h"
#include "graphics/window.h"
#include "graphics/window_manager.h"

namespace iris
{

MetalRenderTargetManager::MetalRenderTargetManager(WindowManager &window_manager, TextureManager &texture_manager)
    : window_manager_(window_manager)
    , texture_manager_(texture_manager)
    , render_targets_()
{
}

RenderTarget *MetalRenderTargetManager::create()
{
    const auto *window = window_manager_.current_window();
    return create(window->width(), window->height());
}

RenderTarget *MetalRenderTargetManager::create(std::uint32_t width, std::uint32_t height)
{
    const auto scale = window_manager_.current_window()->screen_scale();
    const auto *sampler = texture_manager_.create(SamplerDescriptor{.uses_mips = false});
    const auto *depth_sampler = texture_manager_.create(SamplerDescriptor{
        .s_address_mode = SamplerAddressMode::CLAMP_TO_BORDER,
        .t_address_mode = SamplerAddressMode::CLAMP_TO_BORDER,
        .border_colour = Colour{1.0f, 1.0f, 1.0f, 1.0f},
        .uses_mips = false});

    return render_targets_
        .emplace_back(std::make_unique<MetalRenderTarget>(
            texture_manager_.create(DataBuffer{}, width * scale, height * scale, TextureUsage::RENDER_TARGET, sampler),
            texture_manager_.create(DataBuffer{}, width * scale, height * scale, TextureUsage::DEPTH, depth_sampler)))
        .get();
}

RenderTarget *MetalRenderTargetManager::create(const RenderTarget *colour_target, const RenderTarget *depth_target)
{
    return render_targets_
        .emplace_back(std::make_unique<MetalRenderTarget>(
            static_cast<const MetalTexture *>(colour_target->colour_texture()),
            static_cast<const MetalTexture *>(depth_target->depth_texture())))
        .get();
}

}

```

`src/graphics/metal/metal_renderer.mm`:

```mm
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/metal/metal_renderer.h"

#include <cstdint>
#include <memory>
#include <mutex>
#include <vector>

#import <Metal/Metal.h>
#import <MetalKit/MetalKit.h>
#import <MetalPerformanceShaders/MetalPerformanceShaders.h>
#import <QuartzCore/QuartzCore.h>

#include "core/error_handling.h"
#include "core/macos/macos_ios_utility.h"
#include "core/matrix4.h"
#include "core/vector3.h"
#include "graphics/constant_buffer_writer.h"
#include "graphics/instanced_entity.h"
#include "graphics/lights/lighting_rig.h"
#include "graphics/mesh_manager.h"
#include "graphics/metal/metal_constant_buffer.h"
#include "graphics/metal/metal_cube_map.h"
#include "graphics/metal/metal_material.h"
#include "graphics/metal/metal_mesh.h"
#include "graphics/metal/metal_render_target.h"
#include "graphics/metal/metal_sampler.h"
#include "graphics/metal/metal_texture.h"
#include "graphics/render_entity.h"
#include "graphics/render_entity_type.h"
#include "graphics/render_pipeline.h"
#include "graphics/render_target.h"
#include "graphics/single_entity.h"
#include "graphics/texture_manager.h"
#include "graphics/window.h"
#include "log/log.h"

namespace
{

// this matrix is used to translate projection matrices from engine NDC to
// metal NDC
static const iris::Matrix4 metal_translate{
    {{1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.5f, 0.5f, 0.0f, 0.0f, 0.0f, 1.0f}}};

/**
 * Helper function to create a render encoder for render pass.
 *
 * @param colour
 *   Metal texture to write colour data to.
 *
 * @param depth
 *   Metal texture to write depth data to.
 *
 * @param descriptor
 *   Descriptor for render pass.
 *
 * @param depth_stencil_state
 *   State for depth/stencil.
 *
 * @param commands_buffer
 *   Command buffer to create encoder from.
 *
 * @returns
 *   RenderCommandEncoder object for a render pass.
 */
id<MTLRenderCommandEncoder> create_render_encoder(
    id<MTLTexture> colour,
    id<MTLTexture> normal,
    id<MTLTexture> position,
    id<MTLTexture> depth,
    MTLRenderPassDescriptor *descriptor,
    const id<MTLDepthStencilState> depth_stencil_state,
    id<MTLCommandBuffer> command_buffer)
{
    descriptor.colorAttachments[0].texture = colour;

    if (normal != nil)
    {
        descriptor.colorAttachments[1].texture = normal;
    }

    if (position != nil)
    {
        descriptor.colorAttachments[2].texture = position;
    }

    descriptor.depthAttachment.texture = depth;

    const auto render_encoder = [command_buffer renderCommandEncoderWithDescriptor:descriptor];
    [render_encoder setDepthStencilState:depth_stencil_state];
    [render_encoder setFrontFacingWinding:MTLWindingCounterClockwise];
    [render_encoder setCullMode:MTLCullModeBack];
    [render_encoder setTriangleFillMode:MTLTriangleFillModeFill];

    return render_encoder;
}

/**
 * Helper function to build the texture table - a global GPU buffer of all textures (used for bindless rendering)
 *
 * @param resident_resources
 *   Collection to add any resources that should be made resident before rendering.
 *
 * @param texture_manager
 *   Texture manager object.
 *
 * @returns
 *   Metal buffer with all loaded textures.
 */
std::unique_ptr<iris::MetalConstantBuffer> create_texture_table(
    std::vector<id<MTLResource>> &resident_resources,
    iris::TextureManager &texture_manager)
{
    const auto *device = iris::core::utility::metal_device();

    const auto textures = texture_manager.textures();
    const auto max_index = textures.back()->index();
    const auto *blank_texture = static_cast<const iris::MetalTexture *>(texture_manager.blank_texture());
    auto iter = std::cbegin(textures);

    resident_resources.push_back(blank_texture->handle());

    // create descriptor for arguments we want to write
    auto *argument_descriptor = [MTLArgumentDescriptor argumentDescriptor];
    [argument_descriptor setIndex:0];
    [argument_descriptor setDataType:MTLDataTypeTexture];
    [argument_descriptor setAccess:MTLArgumentAccessReadOnly];
    [argument_descriptor setTextureType:MTLTextureType2D];
    [argument_descriptor setArrayLength:max_index + 1u];

    auto *argument_descriptors = [NSArray arrayWithObjects:argument_descriptor, nil];

    // create encoder to actually set arguments
    auto texture_table_argument_encoder = [device newArgumentEncoderWithArguments:argument_descriptors];

    // create table buffer
    auto texture_table =
        std::make_unique<iris::MetalConstantBuffer>([texture_table_argument_encoder encodedLength] * (max_index + 1u));
    [texture_table_argument_encoder setArgumentBuffer:texture_table->handle() offset:0];

    for (auto i = 0u; i <= max_index; ++i)
    {
        // if a texture exits at the current index we write it in
        if (i == (*iter)->index())
        {
            const auto *metal_texture = static_cast<const iris::MetalTexture *>(*iter);
            [texture_table_argument_encoder setTexture:metal_texture->handle() atIndex:i];
            ++iter;
            resident_resources.push_back(metal_texture->handle());
        }
        else
        {
            // no texture at current index, so write default texture
            [texture_table_argument_encoder setTexture:blank_texture->handle() atIndex:i];
        }
    }

    return texture_table;
}

/**
 * Helper function to build the cube map table - a global GPU buffer of all cube maps (used for bindless rendering)
 *
 * @param resident_resources
 *   Collection to add any resources that should be made resident before rendering.
 *
 * @param texture_manager
 *   Texture manager object.
 *
 * @returns
 *   Metal buffer with all loaded cube map.
 */
std::unique_ptr<iris::MetalConstantBuffer> create_cube_map_table(
    std::vector<id<MTLResource>> &resident_resources,
    iris::TextureManager &texture_manager)
{
    const auto *device = iris::core::utility::metal_device();

    const auto cube_maps = texture_manager.cube_maps();
    const auto max_index = cube_maps.back()->index();
    const auto *blank_cube_map = static_cast<const iris::MetalCubeMap *>(texture_manager.blank_cube_map());
    auto iter = std::cbegin(cube_maps);
    resident_resources.push_back(blank_cube_map->handle());

    // create descriptor for arguments we want to write
    auto *argument_descriptor = [MTLArgumentDescriptor argumentDescriptor];
    [argument_descriptor setIndex:0];
    [argument_descriptor setDataType:MTLDataTypeTexture];
    [argument_descriptor setAccess:MTLArgumentAccessReadOnly];
    [argument_descriptor setTextureType:MTLTextureTypeCube];
    [argument_descriptor setArrayLength:max_index + 1u];

    auto *argument_descriptors = [NSArray arrayWithObjects:argument_descriptor, nil];

    // create encoder to actually set arguments
    auto cube_map_table_argument_encoder = [device newArgumentEncoderWithArguments:argument_descriptors];

    // create table buffer
    auto cube_map_table =
        std::make_unique<iris::MetalConstantBuffer>([cube_map_table_argument_encoder encodedLength] * (max_index + 1u));
    [cube_map_table_argument_encoder setArgumentBuffer:cube_map_table->handle() offset:0];

    for (auto i = 0u; i <= max_index; ++i)
    {
        // if a cube map exits at the current index we write it in
        if (i == (*iter)->index())
        {
            const auto *metal_cube_map = static_cast<const iris::MetalCubeMap *>(*iter);
            [cube_map_table_argument_encoder setTexture:metal_cube_map->handle() atIndex:i];
            ++iter;
            resident_resources.push_back(metal_cube_map->handle());
        }
        else
        {
            // no cube map at current index, so write default cube map
            [cube_map_table_argument_encoder setTexture:blank_cube_map->handle() atIndex:i];
        }
    }

    return cube_map_table;
}

/**
 * Helper function to build the sampler table - a global GPU buffer of all samplers (used for bindless rendering)
 *
 * @param texture_manager
 *   Texture manager object.
 *
 * @returns
 *   Metal buffer with all loaded samplers.
 */
std::unique_ptr<iris::MetalConstantBuffer> create_sampler_table(iris::TextureManager &texture_manager)
{
    const auto *device = iris::core::utility::metal_device();

    const auto samplers = texture_manager.samplers();
    const auto max_index = samplers.back()->index();
    const auto *default_sampler = static_cast<const iris::MetalSampler *>(texture_manager.default_texture_sampler());
    auto iter = std::cbegin(samplers);

    // create descriptor for arguments we want to write
    auto *argument_descriptor = [MTLArgumentDescriptor argumentDescriptor];
    [argument_descriptor setIndex:0];
    [argument_descriptor setDataType:MTLDataTypeSampler];
    [argument_descriptor setAccess:MTLArgumentAccessReadOnly];
    [argument_descriptor setArrayLength:max_index + 1u];

    auto *argument_descriptors = [NSArray arrayWithObjects:argument_descriptor, nil];

    // create encoder to actually set arguments
    auto sampler_table_argument_encoder = [device newArgumentEncoderWithArguments:argument_descriptors];

    // create table buffer
    auto sampler_table =
        std::make_unique<iris::MetalConstantBuffer>([sampler_table_argument_encoder encodedLength] * (max_index + 1u));
    [sampler_table_argument_encoder setArgumentBuffer:sampler_table->handle() offset:0];

    for (auto i = 0u; i <= max_index; ++i)
    {
        // if a cube map exits at the current index we write it in
        if (i == (*iter)->index())
        {
            const auto *metal_sampler = static_cast<const iris::MetalSampler *>(*iter);
            [sampler_table_argument_encoder setSamplerState:metal_sampler->handle() atIndex:i];
            ++iter;
        }
        else
        {
            // no cube map at current index, so write default cube map
            [sampler_table_argument_encoder setSamplerState:default_sampler->handle() atIndex:i];
        }
    }

    return sampler_table;
}

}

namespace iris
{

MetalRenderer::MetalRenderer(
    TextureManager &texture_manager,
    MaterialManager &material_manager,
    std::uint32_t width,
    std::uint32_t height)
    : Renderer(material_manager)
    , texture_manager_(texture_manager)
    , command_queue_()
    , single_pass_descriptor_()
    , drawable_()
    , command_buffer_()
    , depth_stencil_state_()
    , render_encoder_()
    , current_frame_(0u)
    , frames_()
    , render_encoders_()
    , default_depth_buffer_()
    , instance_data_()
    , texture_table_()
    , cube_map_table_()
{
    const auto *device = iris::core::utility::metal_device();

    ensure(
        [device argumentBuffersSupport] == MTLArgumentBuffersTier::MTLArgumentBuffersTier2,
        "need tier 2 argument buffer support");

    command_queue_ = [device newCommandQueue];
    ensure(command_queue_ != nullptr, "could not create command queue");

    const auto scale = 2;

    // create and setup descriptor for depth texture
    auto *texture_description = [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:MTLPixelFormatDepth32Float
                                                                                   width:width * scale
                                                                                  height:height * scale
                                                                               mipmapped:NO];
    [texture_description setResourceOptions:MTLResourceStorageModePrivate];
    [texture_description setUsage:MTLTextureUsageRenderTarget];

    // create descriptor for depth checking
    auto *depth_stencil_descriptor = [MTLDepthStencilDescriptor new];
    [depth_stencil_descriptor setDepthCompareFunction:MTLCompareFunctionLessEqual];
    [depth_stencil_descriptor setDepthWriteEnabled:YES];

    // create depth state
    depth_stencil_state_ = [device newDepthStencilStateWithDescriptor:depth_stencil_descriptor];

    // create and setup a render pass descriptor
    single_pass_descriptor_ = [MTLRenderPassDescriptor renderPassDescriptor];
    [[[single_pass_descriptor_ colorAttachments] objectAtIndexedSubscript:0] setLoadAction:MTLLoadActionClear];
    [[[single_pass_descriptor_ colorAttachments] objectAtIndexedSubscript:0]
        setClearColor:MTLClearColorMake(0.39f, 0.58f, 0.93f, 1.0f)];
    [[[single_pass_descriptor_ colorAttachments] objectAtIndexedSubscript:0] setStoreAction:MTLStoreActionStore];
    [[[single_pass_descriptor_ colorAttachments] objectAtIndexedSubscript:0] setTexture:nullptr];
    [[single_pass_descriptor_ depthAttachment] setTexture:nullptr];
    [[single_pass_descriptor_ depthAttachment] setClearDepth:1.0f];
    [[single_pass_descriptor_ depthAttachment] setLoadAction:MTLLoadActionClear];
    [[single_pass_descriptor_ depthAttachment] setStoreAction:MTLStoreActionStore];

    multi_pass_descriptor_ = [MTLRenderPassDescriptor renderPassDescriptor];
    for (auto i = 0u; i < 3u; ++i)
    {
        [[[multi_pass_descriptor_ colorAttachments] objectAtIndexedSubscript:i] setLoadAction:MTLLoadActionClear];
        [[[multi_pass_descriptor_ colorAttachments] objectAtIndexedSubscript:i]
            setClearColor:MTLClearColorMake(0.39f, 0.58f, 0.93f, 1.0f)];
        [[[multi_pass_descriptor_ colorAttachments] objectAtIndexedSubscript:i] setStoreAction:MTLStoreActionStore];
        [[[multi_pass_descriptor_ colorAttachments] objectAtIndexedSubscript:i] setTexture:nullptr];
    }
    [[multi_pass_descriptor_ depthAttachment] setTexture:nullptr];
    [[multi_pass_descriptor_ depthAttachment] setClearDepth:1.0f];
    [[multi_pass_descriptor_ depthAttachment] setLoadAction:MTLLoadActionClear];
    [[multi_pass_descriptor_ depthAttachment] setStoreAction:MTLStoreActionStore];

    const auto *rt_sampler = texture_manager_.create(SamplerDescriptor{
        .s_address_mode = SamplerAddressMode::CLAMP_TO_BORDER,
        .t_address_mode = SamplerAddressMode::CLAMP_TO_BORDER,
        .border_colour = Colour{1.0f, 1.0f, 1.0f, 1.0f},
        .uses_mips = false});
    // create default depth buffer
    default_depth_buffer_ = std::make_unique<MetalTexture>(
        DataBuffer{}, width * 2u, height * 2u, rt_sampler, TextureUsage::DEPTH, texture_manager_.next_texture_index()),

    render_encoder_ = nullptr;
}

MetalRenderer::~MetalRenderer()
{
    // we need to wait for any inflight frames to have finished being rendered
    // by the GPU before we can destruct
    // this line very deliberately creates an unnamed scoped_lock, this
    // ensures the locks for all frames will be waited on, acquired and then
    // immediately released
    std::scoped_lock{frames_[0].lock, frames_[1].lock, frames_[2].lock};
}

void MetalRenderer::do_set_render_pipeline(std::function<void()> build_queue)
{
    build_queue();

    instance_data_.clear();

    for (auto &frame : frames_)
    {
        frame.model_data.clear();
    }

    // find all instanced render entities and write their instance data to buffers - this allows us to quickly set them
    // during rendering
    for (const auto &command : render_queue_)
    {
        if (command.type() == RenderCommandType::DRAW)
        {
            const auto *render_entity = command.render_entity();

            if (render_entity->type() == RenderEntityType::INSTANCED)
            {
                const auto *instanced_entity = static_cast<const InstancedEntity *>(render_entity);
                instance_data_[render_entity] =
                    std::make_unique<MetalConstantBuffer>(instanced_entity->data().size() * sizeof(Matrix4) * 2u);

                ConstantBufferWriter writer{*instance_data_[render_entity]};

                writer.write(instanced_entity->data());
            }
        }
    }

    resident_resources_.clear();
    texture_table_ = create_texture_table(resident_resources_, texture_manager_);
    cube_map_table_ = create_cube_map_table(resident_resources_, texture_manager_);
    sampler_table_ = create_sampler_table(texture_manager_);
}

void MetalRenderer::pre_render()
{
    @autoreleasepool
    {
        // acquire the lock, this will be released when the GPU has finished rendering the frame
        frames_[current_frame_ % 3u].lock.lock();

        const auto layer = core::utility::metal_layer();
#if defined(IRIS_PLATFORM_MACOS)
        // can only disable vsync on macos
        [layer setDisplaySyncEnabled:NO];
#endif
        drawable_ = [layer nextDrawable];
        command_buffer_ = [command_queue_ commandBuffer];

        // create render encoders fresh each frame
        render_encoders_.clear();
    }
}

void MetalRenderer::execute_pass_start(RenderCommand &)
{
    const auto frame_index = current_frame_ % 3u;
    auto &frame = frames_[frame_index];

    frame.bone_data.clear();
    frame.light_data.clear();
    frame.camera_data.clear();
    frame.property_data.clear();
}

void MetalRenderer::execute_draw(RenderCommand &command)
{
    const auto *material = static_cast<const MetalMaterial *>(command.material());
    const auto *entity = command.render_entity();
    const auto *mesh = static_cast<const MetalMesh *>(entity->mesh());
    const auto *colour_target = command.render_pass()->colour_target;
    const auto *normal_target = command.render_pass()->normal_target;
    const auto *position_target = command.render_pass()->position_target;
    const auto *light = command.light();
    const auto *camera = command.render_pass()->camera;
    auto &frame = frames_[current_frame_ % 3u];

    @autoreleasepool
    {
        // create a render encoder based on the render command target
        if (render_encoders_.count(colour_target) == 0u)
        {
            id<MTLRenderCommandEncoder> encoder;
            if (colour_target == nullptr)
            {
                // no target means render to the window frame buffer
                encoder = create_render_encoder(
                    drawable_.texture,
                    nil,
                    nil,
                    default_depth_buffer_->handle(),
                    single_pass_descriptor_,
                    depth_stencil_state_,
                    command_buffer_);
            }
            else
            {
                encoder = create_render_encoder(
                    static_cast<const MetalTexture *>(colour_target->colour_texture())->handle(),
                    (normal_target != nullptr)
                        ? static_cast<const MetalTexture *>(normal_target->colour_texture())->handle()
                        : nil,
                    (position_target != nullptr)
                        ? static_cast<const MetalTexture *>(position_target->colour_texture())->handle()
                        : nil,
                    static_cast<const MetalTexture *>(colour_target->depth_texture())->handle(),
                    ((normal_target == nullptr) && (position_target == nullptr)) ? single_pass_descriptor_
                                                                                 : multi_pass_descriptor_,
                    depth_stencil_state_,
                    command_buffer_);
            }

            render_encoders_[colour_target] = encoder;
        }
    }

    render_encoder_ = render_encoders_[colour_target];

    // make resident any resources we need to
    for (const auto &resource : resident_resources_)
    {
        [render_encoder_ useResource:resource usage:MTLResourceUsageRead stages:MTLRenderStageFragment];
    }

    // if we haven't seen this entity yet this pass then create buffers for its data
    if (!frame.bone_data.contains(entity))
    {
        static std::vector<iris::Matrix4> default_bones(100u);

        frame.bone_data[entity] = std::make_unique<MetalConstantBuffer>(sizeof(Matrix4) * 100u);
        frame.model_data[entity] = std::make_unique<MetalConstantBuffer>(sizeof(Matrix4) * 2u);

        ConstantBufferWriter writer{*frame.bone_data[entity]};

        if (entity->type() == RenderEntityType::SINGLE)
        {
            const auto *single_entity = static_cast<const SingleEntity *>(entity);

            if (single_entity->skeleton() != nullptr)
            {
                const auto &bones = single_entity->skeleton()->transforms();
                writer.write(bones);
            }
            else
            {
                writer.write(default_bones);
            }

            iris::ConstantBufferWriter writer2(*frame.model_data[entity]);
            writer2.write(single_entity->transform());
            writer2.write(single_entity->normal_transform());
        }
        else
        {
            writer.write(default_bones);
        }
    }

    // if we haven't seen this light yet this pass then create buffers for its data
    if (!frame.light_data.contains(light))
    {
        frame.light_data[light] = std::make_unique<MetalConstantBuffer>(176u);

        ConstantBufferWriter writer{*frame.light_data[light]};
        writer.write(light->colour_data());
        writer.write(light->world_space_data());
        writer.write(light->attenuation_data());
        writer.write(0.0f);

        if (light->type() == LightType::DIRECTIONAL)
        {
            const auto *directional_light = static_cast<const iris::DirectionalLight *>(light);
            writer.write(metal_translate * directional_light->shadow_camera().projection());
            writer.write(directional_light->shadow_camera().view());
        }
    }

    // if we haven't seen this camera yet this pass then create buffers for its data
    if (!frame.camera_data.contains(camera))
    {
        frame.camera_data[camera] = std::make_unique<MetalConstantBuffer>(512u);

        // calculate view matrix for normals
        auto normal_view = Matrix4::transpose(Matrix4::invert(camera->view()));
        normal_view[3] = 0.0f;
        normal_view[7] = 0.0f;
        normal_view[11] = 0.0f;

        ConstantBufferWriter writer{*frame.camera_data[camera]};
        writer.write(metal_translate * camera->projection());
        writer.write(camera->view());
        writer.write(normal_view);
        writer.write(camera->position());
    }

    if(!frame.property_data.contains(material))
    {
        const auto property_buffer = material->property_buffer();
        frame.property_data[material] = std::make_unique<MetalConstantBuffer>(property_buffer.size_bytes());
        frame.property_data[material]->write(property_buffer.data(), property_buffer.size_bytes(), 0u);
    }

    auto *model_buffer =
        entity->type() == RenderEntityType::SINGLE ? frame.model_data[entity].get() : instance_data_[entity].get();
    const std::uint32_t shadow_map_index =
        (command.shadow_map() == nullptr) ? 0u : command.shadow_map()->depth_texture()->index();
    const std::uint32_t shadow_map_sampler_index =
        (command.shadow_map() == nullptr) ? 0u : command.shadow_map()->depth_texture()->sampler()->index();

    const auto time_value = static_cast<float>(time().count()) / 1000.0f;

    [render_encoder_ setVertexBuffer:frame.bone_data[entity]->handle() offset:0 atIndex:1];
    [render_encoder_ setVertexBuffer:frame.camera_data[camera]->handle() offset:0 atIndex:2];
    [render_encoder_ setVertexBuffer:frame.light_data[light]->handle() offset:0 atIndex:3];
    [render_encoder_ setVertexBuffer:model_buffer->handle() offset:0 atIndex:4];

    [render_encoder_ setFragmentBuffer:frame.camera_data[camera]->handle() offset:0 atIndex:0];
    [render_encoder_ setFragmentBuffer:frame.light_data[light]->handle() offset:0 atIndex:1];
    [render_encoder_ setFragmentBuffer:texture_table_->handle() offset:0 atIndex:2];
    [render_encoder_ setFragmentBuffer:cube_map_table_->handle() offset:0 atIndex:3];
    [render_encoder_ setFragmentBuffer:sampler_table_->handle() offset:0 atIndex:4];
    [render_encoder_ setFragmentBytes:&shadow_map_index length:sizeof(shadow_map_index) atIndex:5];
    [render_encoder_ setFragmentBytes:&shadow_map_sampler_index length:sizeof(shadow_map_sampler_index) atIndex:6];
    [render_encoder_ setFragmentBuffer:frame.property_data[material]->handle() offset:0 atIndex:7];
    [render_encoder_ setFragmentBytes:&time_value length:time_value atIndex:8];

    const auto &vertex_buffer = mesh->vertex_buffer();
    const auto &index_buffer = mesh->index_buffer();

    // encode render commands
    [render_encoder_ setRenderPipelineState:material->pipeline_state()];
    [render_encoder_ setVertexBuffer:vertex_buffer.handle() offset:0 atIndex:0];
    [render_encoder_ setCullMode:MTLCullModeNone];

    const auto type =
        entity->primitive_type() == iris::PrimitiveType::TRIANGLES ? MTLPrimitiveTypeTriangle : MTLPrimitiveTypeLine;

    const auto instance_count = entity->type() == RenderEntityType::INSTANCED
                                    ? static_cast<const InstancedEntity *>(entity)->instance_count()
                                    : 1u;

    // draw command
    [render_encoder_ drawIndexedPrimitives:type
                                indexCount:index_buffer.element_count()
                                 indexType:MTLIndexTypeUInt32
                               indexBuffer:index_buffer.handle()
                         indexBufferOffset:0
                             instanceCount:instance_count];
}

void MetalRenderer::execute_pass_end(RenderCommand &)
{
    // end encoding for pass
    [render_encoder_ endEncoding];
}

void MetalRenderer::execute_present(RenderCommand &)
{
    [command_buffer_ presentDrawable:drawable_];

    // store local copy of frame so it can be correctly accessed via the completion handler
    const auto frame = current_frame_ % 3u;

    // set completion handler for command buffer, when the GPU is finished rendering it will fire the handler, which
    // will unlock the lock, allowing the frame to be rendered to again
    [command_buffer_ addCompletedHandler:^(id<MTLCommandBuffer> commandBuffer) {
      frames_[frame].lock.unlock();
    }];

    [command_buffer_ commit];
}

void MetalRenderer::post_render()
{
    ++current_frame_;
}

}

```

`src/graphics/metal/metal_sampler.mm`:

```mm
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/metal/metal_sampler.h"

#include "core/colour.h"
#include "core/error_handling.h"
#include "core/macos/macos_ios_utility.h"
#include "graphics/sampler.h"

#import <Metal/Metal.h>

namespace
{

/**
 * Helper function to convert an engine address mode to a metal address mode.
 *
 * @param address_mode
 *   Engine address mode.
 *
 * @returns
 *   Metal address mode.
 */
MTLSamplerAddressMode to_metal(iris::SamplerAddressMode address_mode)
{
    switch (address_mode)
    {
        case iris::SamplerAddressMode::REPEAT: return MTLSamplerAddressModeRepeat;
        case iris::SamplerAddressMode::MIRROR: return MTLSamplerAddressModeMirrorRepeat;
        case iris::SamplerAddressMode::CLAMP_TO_EDGE: return MTLSamplerAddressModeClampToEdge;
        case iris::SamplerAddressMode::CLAMP_TO_BORDER: return MTLSamplerAddressModeClampToBorderColor;
        default: throw iris::Exception("unknown address mode");
    }
}

/**
 * Helper method to convert an engine filter to a metal filter.
 *
 * @param filter
 *   Engine filter.
 *
 * @returns
 *   Metal filter.
 */
MTLSamplerMinMagFilter to_metal(iris::SamplerFilter filter)
{
    switch (filter)
    {
        case iris::SamplerFilter::NEAREST: return MTLSamplerMinMagFilterNearest;
        case iris::SamplerFilter::LINEAR: return MTLSamplerMinMagFilterLinear;
        default: throw iris::Exception("unknown filter");
    }
}

/**
 * Helper method to convert an engine mip filter to a metal filter.
 *
 * @param filter
 *   Engine filter.
 *
 * @param uses_mips
 *   Flag indicating if mips are used.

 * @returns
 *   Metal filter.
 */
MTLSamplerMipFilter to_metal(iris::SamplerFilter filter, [[maybe_unused]] bool uses_mips)
{
    if (!uses_mips)
    {
        return MTLSamplerMipFilterNotMipmapped;
    }

    switch (filter)
    {
        case iris::SamplerFilter::NEAREST: return MTLSamplerMipFilterNearest;
        case iris::SamplerFilter::LINEAR: return MTLSamplerMipFilterLinear;
        default: throw iris::Exception("unknown filter");
    }
}

MTLSamplerBorderColor to_metal(const iris::Colour &colour)
{
    if (colour == iris::Colour{0.0f, 0.0f, 0.0f, 0.0f})
    {
        return MTLSamplerBorderColorTransparentBlack;
    }
    else if (colour == iris::Colour{0.0f, 0.0f, 0.0f, 1.0f})
    {
        return MTLSamplerBorderColorOpaqueBlack;
    }
    else if (colour == iris::Colour{1.0f, 1.0f, 1.0f, 1.0f})
    {
        return MTLSamplerBorderColorOpaqueWhite;
    }
    else
    {
        throw iris::Exception("unsupported border colour");
    }
}

}

namespace iris
{

MetalSampler::MetalSampler(const SamplerDescriptor &descriptor, std::uint32_t index)
    : Sampler(descriptor, index)
    , sampler_()
{
    const auto *device = iris::core::utility::metal_device();

    auto *metal_sampler_descriptor = [MTLSamplerDescriptor new];
    metal_sampler_descriptor.sAddressMode = to_metal(descriptor.s_address_mode);
    metal_sampler_descriptor.tAddressMode = to_metal(descriptor.t_address_mode);
    metal_sampler_descriptor.rAddressMode = to_metal(descriptor.r_address_mode);
    metal_sampler_descriptor.borderColor = to_metal(descriptor.border_colour);
    metal_sampler_descriptor.minFilter = to_metal(descriptor.minification_filter);
    metal_sampler_descriptor.magFilter = to_metal(descriptor.magnification_filter);
    metal_sampler_descriptor.mipFilter = to_metal(descriptor.mip_filter, descriptor.uses_mips);
    metal_sampler_descriptor.supportArgumentBuffers = YES;
    metal_sampler_descriptor.compareFunction = MTLCompareFunctionNever;
    sampler_ = [device newSamplerStateWithDescriptor:metal_sampler_descriptor];
}

id<MTLSamplerState> MetalSampler::handle() const
{
    return sampler_;
}

}

```

`src/graphics/metal/metal_texture.mm`:

```mm
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/metal/metal_texture.h"

#include <any>
#include <cstdint>
#include <memory>
#include <string>
#include <utility>
#include <vector>

#import <Metal/Metal.h>

#include "core/data_buffer.h"
#include "core/error_handling.h"
#include "core/exception.h"
#include "core/macos/macos_ios_utility.h"
#include "core/vector3.h"
#include "graphics/sampler.h"
#include "graphics/texture_usage.h"
#include "log/log.h"

namespace
{

/**
 * Helper function to create a metal texture descriptor suitable for the texture
 * usage.
 *
 * @param width
 *   Width of texture.
 *
 * @param height
 *   Height of texture.
 *
 * @returns
 *   MTLTextureDescriptor for texture.
 */
MTLTextureDescriptor *image_texture_descriptor(std::uint32_t width, std::uint32_t height)
{
    auto *texture_descriptor = [MTLTextureDescriptor new];
    texture_descriptor.textureType = MTLTextureType2D;
    texture_descriptor.width = width;
    texture_descriptor.height = height;
    texture_descriptor.pixelFormat = MTLPixelFormatRGBA8Unorm_sRGB;
    texture_descriptor.resourceOptions = MTLResourceStorageModeShared;
    texture_descriptor.usage = MTLTextureUsageShaderRead;

    return texture_descriptor;
}

/**
 * Helper function to create a metal texture descriptor suitable for the data
 * usage.
 *
 * @param width
 *   Width of texture.
 *
 * @param height
 *   Height of texture.
 *
 * @returns
 *   MTLTextureDescriptor for texture.
 */
MTLTextureDescriptor *data_texture_descriptor(std::uint32_t width, std::uint32_t height)
{
    auto *texture_descriptor = [MTLTextureDescriptor new];
    texture_descriptor.textureType = MTLTextureType2D;
    texture_descriptor.width = width;
    texture_descriptor.height = height;
    texture_descriptor.pixelFormat = MTLPixelFormatRGBA8Unorm;
    texture_descriptor.resourceOptions = MTLResourceStorageModeShared;
    texture_descriptor.usage = MTLTextureUsageShaderRead;

    return texture_descriptor;
}

/**
 * Helper function to create a metal texture descriptor suitable for the render
 * target usage.
 *
 * @param width
 *   Width of texture.
 *
 * @param height
 *   Height of texture.
 *
 * @returns
 *   MTLTextureDescriptor for texture.
 */
MTLTextureDescriptor *render_target_texture_descriptor(std::uint32_t width, std::uint32_t height)
{
    auto *texture_descriptor = [MTLTextureDescriptor new];
    texture_descriptor.textureType = MTLTextureType2D;
    texture_descriptor.width = width;
    texture_descriptor.height = height;
    texture_descriptor.pixelFormat = MTLPixelFormatRGBA16Float;
    texture_descriptor.usage = MTLTextureUsageRenderTarget | MTLTextureUsageShaderRead;

    return texture_descriptor;
}

/**
 * Helper function to create a metal texture descriptor suitable for the depth
 * usage.
 *
 * @param width
 *   Width of texture.
 *
 * @param height
 *   Height of texture.
 *
 * @returns
 *   MTLTextureDescriptor for texture.
 */
MTLTextureDescriptor *depth_texture_descriptor(std::uint32_t width, std::uint32_t height)
{
    auto *texture_descriptor = [MTLTextureDescriptor new];
    texture_descriptor.textureType = MTLTextureType2D;
    texture_descriptor.width = width;
    texture_descriptor.height = height;
    texture_descriptor.pixelFormat = MTLPixelFormatDepth32Float;
    texture_descriptor.resourceOptions = MTLResourceStorageModePrivate;
    texture_descriptor.usage = MTLTextureUsageRenderTarget | MTLTextureUsageShaderRead;

    return texture_descriptor;
}

/**
 * Helper function to create a metal Texture from pixel data.
 *
 * @param data
 *   Raw data of image.
 *
 * @param width
 *   Width of image.
 *
 * @param height
 *   Height of image.
 *
 * @param usage
 *   Texture usage.
 *
 * @returns
 *   Handle to texture.
 */
id<MTLTexture> create_texture(
    iris::DataBuffer data,
    std::uint32_t width,
    std::uint32_t height,
    iris::TextureUsage usage)
{
    auto *data_ptr = data.data();

    iris::DataBuffer padded{};

    MTLTextureDescriptor *texture_descriptor = nullptr;

    switch (usage)
    {
        case iris::TextureUsage::IMAGE: texture_descriptor = image_texture_descriptor(width, height); break;
        case iris::TextureUsage::DATA: texture_descriptor = data_texture_descriptor(width, height); break;
        case iris::TextureUsage::RENDER_TARGET:
            texture_descriptor = render_target_texture_descriptor(width, height);
            break;
        case iris::TextureUsage::DEPTH: texture_descriptor = depth_texture_descriptor(width, height); break;
        default: throw iris::Exception("unknown texture usage");
    }

    auto *device = iris::core::utility::metal_device();

    // create new texture
    auto texture = [device newTextureWithDescriptor:texture_descriptor];

    // set data if it was supplied
    if (!data.empty())
    {
        auto region = MTLRegionMake2D(0, 0, width, height);
        const auto bytes_per_row = width * 4u;

        // set image data for texture
        [texture replaceRegion:region mipmapLevel:0 withBytes:data_ptr bytesPerRow:bytes_per_row];
    }

    return texture;
}

}

namespace iris
{

MetalTexture::MetalTexture(
    const DataBuffer &data,
    std::uint32_t width,
    std::uint32_t height,
    const Sampler *sampler,
    TextureUsage usage,
    std::uint32_t index)
    : Texture(data, width, height, sampler, usage, index)
    , texture_()
{
    texture_ = create_texture(data, width, height, usage);

    LOG_ENGINE_INFO("texture", "loaded from data");
}

id<MTLTexture> MetalTexture::handle() const
{
    return texture_;
}

}

```

`src/graphics/metal/metal_texture_manager.mm`:

```mm
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/metal/metal_texture_manager.h"

#include <cstdint>
#include <memory>

#include "core/data_buffer.h"
#include "core/resource_manager.h"
#include "graphics/metal/metal_cube_map.h"
#include "graphics/metal/metal_sampler.h"
#include "graphics/metal/metal_texture.h"
#include "graphics/sampler.h"
#include "graphics/texture.h"
#include "graphics/texture_manager.h"
#include "graphics/texture_usage.h"

namespace iris
{

MetalTextureManager::MetalTextureManager(ResourceManager &resource_manager)
    : TextureManager(resource_manager)
{
}

std::unique_ptr<Texture> MetalTextureManager::do_create(
    const DataBuffer &data,
    std::uint32_t width,
    std::uint32_t height,
    const Sampler *sampler,
    TextureUsage usage,
    std::uint32_t index)
{
    return std::make_unique<MetalTexture>(data, width, height, sampler, usage, index);
}

std::unique_ptr<CubeMap> MetalTextureManager::do_create(
    const DataBuffer &right_data,
    const DataBuffer &left_data,
    const DataBuffer &top_data,
    const DataBuffer &bottom_data,
    const DataBuffer &near_data,
    const DataBuffer &far_data,
    std::uint32_t width,
    std::uint32_t height,
    const Sampler *sampler,
    std::uint32_t index)
{
    return std::make_unique<MetalCubeMap>(
        right_data, left_data, top_data, bottom_data, near_data, far_data, width, height, sampler, index);
}

std::unique_ptr<Sampler> MetalTextureManager::do_create(const SamplerDescriptor &descriptor, std::uint32_t index)
{
    return std::make_unique<MetalSampler>(descriptor, index);
}

}

```

`src/graphics/opengl/CMakeLists.txt`:

```txt
set(INCLUDE_ROOT "${PROJECT_SOURCE_DIR}/include/iris/graphics/opengl")

target_sources(iris PRIVATE
    ${INCLUDE_ROOT}/opengl.h
    ${INCLUDE_ROOT}/opengl_buffer.h
    ${INCLUDE_ROOT}/opengl_cube_map.h
    ${INCLUDE_ROOT}/opengl_defines.h
    ${INCLUDE_ROOT}/opengl_frame_buffer.h
    ${INCLUDE_ROOT}/opengl_material.h
    ${INCLUDE_ROOT}/opengl_material_manager.h
    ${INCLUDE_ROOT}/opengl_mesh.h
    ${INCLUDE_ROOT}/opengl_mesh_manager.h
    ${INCLUDE_ROOT}/opengl_render_target.h
    ${INCLUDE_ROOT}/opengl_render_target_manager.h
    ${INCLUDE_ROOT}/opengl_renderer.h
    ${INCLUDE_ROOT}/opengl_sampler.h
    ${INCLUDE_ROOT}/opengl_shader.h
    ${INCLUDE_ROOT}/opengl_texture.h
    ${INCLUDE_ROOT}/opengl_material_manager.h
    ${INCLUDE_ROOT}/opengl_texture_manager.h
    ${INCLUDE_ROOT}/opengl_uniform.h
    opengl.cpp
    opengl_cube_map.cpp
    opengl_frame_buffer.cpp
    opengl_material.cpp
    opengl_material_manager.cpp
    opengl_mesh.cpp
    opengl_mesh_manager.cpp
    opengl_render_target.cpp
    opengl_render_target_manager.cpp
    opengl_renderer.cpp
    opengl_sampler.cpp
    opengl_shader.cpp
    opengl_texture.cpp
    opengl_texture_manager.cpp
    opengl_uniform.cpp)

```

`src/graphics/opengl/opengl.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/opengl/opengl.h"

#include <optional>
#include <sstream>
#include <string>
#include <string_view>

namespace iris
{

std::optional<std::string> do_check_opengl_error(std::string_view error_message)
{
    std::optional<std::string> final_message{};

    if (const auto error = ::glGetError(); error != GL_NO_ERROR)
    {
        std::stringstream strm{};
        strm << error_message << " : " << error;
        final_message = strm.str();
    }

    return final_message;
}

}

```

`src/graphics/opengl/opengl_cube_map.cpp`:

```cpp
#include "graphics/opengl/opengl_cube_map.h"

#include <cstdint>
#include <memory>
#include <tuple>
#include <vector>

#include "core/data_buffer.h"
#include "core/error_handling.h"
#include "graphics/cube_map.h"
#include "graphics/opengl/opengl.h"
#include "graphics/opengl/opengl_sampler.h"
#include "graphics/opengl/opengl_texture.h"
#include "graphics/sampler.h"
#include "log/log.h"

namespace iris
{

OpenGLCubeMap::OpenGLCubeMap(
    const DataBuffer &right_data,
    const DataBuffer &left_data,
    const DataBuffer &top_data,
    const DataBuffer &bottom_data,
    const DataBuffer &back_data,
    const DataBuffer &front_data,
    std::uint32_t width,
    std::uint32_t height,
    const Sampler *sampler,
    std::uint32_t index)
    : CubeMap(sampler, index)
    , handle_(0u)
{
    const auto *opengl_sampler = static_cast<const iris::OpenGLSampler *>(sampler);

    ::glGenTextures(1u, &handle_);
    expect(check_opengl_error, "could not generate texture");

    ::glBindTexture(GL_TEXTURE_CUBE_MAP, handle_);
    expect(check_opengl_error, "could not bind texture");

    const std::byte *data_ptrs[] = {
        right_data.data(), left_data.data(), top_data.data(), bottom_data.data(), back_data.data(), front_data.data()};

    // specify data for each cube face
    for (auto i = 0u; i < 6u; ++i)
    {
        ::glTexImage2D(
            GL_TEXTURE_CUBE_MAP_POSITIVE_X + i,
            0,
            GL_SRGB_ALPHA,
            width,
            height,
            0,
            GL_RGBA,
            GL_UNSIGNED_BYTE,
            data_ptrs[i]);
        expect(check_opengl_error, "could not specify image texture");
    }

    // create a bindless handle and make it resident
    bindless_handle_ = ::glGetTextureSamplerHandleARB(handle_, opengl_sampler->handle());
    expect(check_opengl_error, "could not create bindless handle");

    ::glMakeTextureHandleResidentARB(bindless_handle_);
    expect(check_opengl_error, "could not make bindless handle resident");

    LOG_ENGINE_INFO("opengl_cube_map", "loaded from data");
}

OpenGLCubeMap::~OpenGLCubeMap()
{
    ::glMakeTextureHandleNonResidentARB(bindless_handle_);
    ::glDeleteTextures(1, &handle_);
}

GLuint OpenGLCubeMap::handle() const
{
    return handle_;
}

GLuint64 OpenGLCubeMap::bindless_handle() const
{
    return bindless_handle_;
}

}

```

`src/graphics/opengl/opengl_frame_buffer.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/opengl/opengl_frame_buffer.h"

#include <algorithm>
#include <array>

#include "core/error_handling.h"
#include "graphics/opengl/opengl.h"
#include "graphics/opengl/opengl_render_target.h"
#include "graphics/opengl/opengl_texture.h"

namespace
{

void delete_frame_buffer(GLuint handle)
{
    ::glDeleteFramebuffers(1, &handle);
}

}

namespace iris
{

OpenGLFrameBuffer::OpenGLFrameBuffer(
    const OpenGLRenderTarget *colour_target,
    const OpenGLRenderTarget *normal_target,
    const OpenGLRenderTarget *position_target)
    : handle_(0u, delete_frame_buffer)
    , colour_target_(colour_target)
    , normal_target_(normal_target)
    , position_target_(position_target)
{
    // create a frame buffer for our target
    ::glGenFramebuffers(1, &handle_);
    expect(check_opengl_error, "could not generate fbo");

    bind();

    // array of symbols describing the render targets
    std::array<GLenum, 3u> attachments{{GL_NONE, GL_NONE, GL_NONE}};

    if (colour_target != nullptr)
    {
        const auto colour_handle = static_cast<const OpenGLTexture *>(colour_target->colour_texture())->handle();
        ::glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, colour_handle, 0);
        expect(check_opengl_error, "could not attach colour texture");

        attachments[0] = GL_COLOR_ATTACHMENT0;

        // also set depth
        const auto depth_handle = static_cast<const OpenGLTexture *>(colour_target->depth_texture())->handle();
        ::glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, depth_handle, 0);
        expect(check_opengl_error, "could not attach depth texture");
    }

    if (normal_target != nullptr)
    {
        const auto normal_handle = static_cast<const OpenGLTexture *>(normal_target->colour_texture())->handle();
        ::glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, GL_TEXTURE_2D, normal_handle, 0);
        expect(check_opengl_error, "could not attach normal texture");

        attachments[1] = GL_COLOR_ATTACHMENT1;
    }

    if (position_target != nullptr)
    {
        const auto position_handle = static_cast<const OpenGLTexture *>(position_target->colour_texture())->handle();
        ::glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT2, GL_TEXTURE_2D, position_handle, 0);
        expect(check_opengl_error, "could not attach position texture");

        attachments[2] = GL_COLOR_ATTACHMENT2;
    }

    // if we set at least one buffer then we need to call glDrawBuffers to tell opengl what we will be rendering to
    if (std::any_of(std::cbegin(attachments), std::cend(attachments), [](auto value) { return value != GL_NONE; }))
    {
        ::glDrawBuffers(static_cast<GLsizei>(attachments.size()), attachments.data());
        expect(check_opengl_error, "could not set draw buffers");

        // check everything worked
        const auto status = ::glCheckFramebufferStatus(GL_FRAMEBUFFER);
        expect(status == GL_FRAMEBUFFER_COMPLETE, "fbo in invalid state: " + std::to_string(status));
    }

    unbind();
}

void OpenGLFrameBuffer::bind() const
{
    expect(handle_, "invalid handle");

    ::glBindFramebuffer(GL_FRAMEBUFFER, handle_);
    expect(check_opengl_error, "could not bind framebuffer");
}

void OpenGLFrameBuffer::unbind() const
{
    expect(handle_, "invalid handle");

    ::glBindFramebuffer(GL_FRAMEBUFFER, 0u);
    expect(check_opengl_error, "could not bind framebuffer");
}

const OpenGLRenderTarget *OpenGLFrameBuffer::colour_target() const
{
    return colour_target_;
}

const OpenGLRenderTarget *OpenGLFrameBuffer::normal_target() const
{
    return normal_target_;
}

const OpenGLRenderTarget *OpenGLFrameBuffer::position_target() const
{
    return position_target_;
}

}

```

`src/graphics/opengl/opengl_material.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/opengl/opengl_material.h"

#include <cstdint>
#include <string>
#include <vector>

#include "core/error_handling.h"
#include "graphics/default_shader_languages.h"
#include "graphics/opengl/opengl.h"
#include "graphics/opengl/opengl_shader.h"
#include "graphics/render_graph/render_graph.h"
#include "graphics/render_graph/shader_compiler.h"
#include "graphics/shader_type.h"
#include "log/log.h"

namespace
{

/**
 * Helper function to create an opengl program.
 *
 * @param vertex_shader_source
 *   Source for vertex shader.
 *
 * @param fragment_shader_source
 *   Source for fragment shader.
 *
 * @returns
 *   Opengl program object.
 */
GLuint create_program(const std::string &vertex_shader_source, const std::string &fragment_shader_source)
{
    const auto program = ::glCreateProgram();
    iris::expect(iris::check_opengl_error, "could not create new program");

    const iris::OpenGLShader vertex_shader{vertex_shader_source, iris::ShaderType::VERTEX};
    const iris::OpenGLShader fragment_shader{fragment_shader_source, iris::ShaderType::FRAGMENT};

    ::glAttachShader(program, vertex_shader.native_handle());
    iris::expect(iris::check_opengl_error, "could not attach vertex shader");

    ::glAttachShader(program, fragment_shader.native_handle());
    iris::expect(iris::check_opengl_error, "could not attach fragment shader");

    ::glLinkProgram(program);

    GLint programparam = 0;
    ::glGetProgramiv(program, GL_LINK_STATUS, &programparam);

    // if program failed to link then get the opengl error
    if (programparam != GL_TRUE)
    {
        ::glGetProgramiv(program, GL_INFO_LOG_LENGTH, &programparam);
        iris::expect(iris::check_opengl_error, "could not get program log length");

        if (programparam == 0)
        {
            throw iris::Exception("program link failed: no log");
        }
        else
        {
            std::vector<char> error_log(programparam);

            // get opengl error log
            GLsizei log_length = 0;
            ::glGetProgramInfoLog(program, static_cast<std::int32_t>(error_log.size()), &log_length, error_log.data());
            iris::expect(iris::check_opengl_error, "failed to get error log");

            const std::string error(error_log.data(), log_length);
            LOG_ENGINE_ERROR("opengl_material", "{}\n{}\n{}", vertex_shader_source, fragment_shader_source, error);

            throw iris::Exception("program link failed: " + error);
        }
    }

    return program;
}

}

namespace iris
{

OpenGLMaterial::OpenGLMaterial(
    const RenderGraph *render_graph,
    LightType light_type,
    bool render_to_normal_target,
    bool render_to_position_target)
    : Material(render_graph)
    , handle_(0u)
{
    ShaderCompiler compiler{
        ShaderLanguage::GLSL, render_graph, light_type, render_to_normal_target, render_to_position_target};

    handle_ = create_program(compiler.vertex_shader(), compiler.fragment_shader());
}

OpenGLMaterial::~OpenGLMaterial()
{
    ::glDeleteProgram(handle_);
}

void OpenGLMaterial::bind() const
{
    ::glUseProgram(handle_);
    expect(check_opengl_error, "could not bind program");
}

GLuint OpenGLMaterial::handle() const
{
    return handle_;
}

}

```

`src/graphics/opengl/opengl_material_manager.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/opengl/opengl_material_manager.h"

#include "graphics/material_cache.h"
#include "graphics/opengl/opengl_render_target.h"
#include "graphics/render_entity.h"
#include "graphics/render_graph/render_graph.h"

namespace iris
{

Material *OpenGLMaterialManager::create(
    RenderGraph *render_graph,
    RenderEntity *,
    LightType light_type,
    bool,
    bool render_to_normal_target,
    bool render_to_position_target,
    bool)
{
    return materials_.try_emplace(
        render_graph,
        light_type,
        render_to_normal_target,
        render_to_position_target,
        render_graph,
        light_type,
        render_to_normal_target,
        render_to_position_target);
}

void OpenGLMaterialManager::clear()
{
    materials_.clear();
}

}

```

`src/graphics/opengl/opengl_mesh.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/opengl/opengl_mesh.h"

#include <memory>
#include <tuple>

#include "core/error_handling.h"
#include "graphics/constant_buffer_writer.h"
#include "graphics/opengl/opengl.h"
#include "graphics/vertex_attributes.h"

namespace
{

/**
 * Convert an engine VertexAttributeType to an OpenGL data type.
 *
 * @param type
 *   Type to convert
 *
 * @returns
 *   Tuple of OpenGL type and boolean indicating if the returned type is a float type.
 */
std::tuple<GLenum, bool> to_opengl_format(iris::VertexAttributeType type)
{
    GLenum format = 0u;
    auto is_float = true;

    switch (type)
    {
        case iris::VertexAttributeType::FLOAT_3:
        case iris::VertexAttributeType::FLOAT_4: format = GL_FLOAT; break;
        case iris::VertexAttributeType::UINT32_1:
        case iris::VertexAttributeType::UINT32_4:
            format = GL_UNSIGNED_INT;
            is_float = false;
            break;
        default: throw iris::Exception("unknown vertex attribute type");
    }

    return {format, is_float};
}

}

namespace iris
{

OpenGLMesh::OpenGLMesh(
    const std::vector<VertexData> &vertices,
    const std::vector<std::uint32_t> &indices,
    const VertexAttributes &attributes)
    : Mesh(vertices, indices)
    , attributes_(attributes)
    , vertex_buffer_(vertices_.size() * sizeof(VertexData))
    , index_buffer_(indices_.size() * sizeof(std::uint32_t))
    , vao_(0u)
    , element_count_(0u)
{
    update_vertex_data(vertices_);
    update_index_data(indices_);

    // create vao
    ::glGenVertexArrays(1, &vao_);
    expect(check_opengl_error, "could not generate vao");

    setup_vao();
}

OpenGLMesh::~OpenGLMesh()
{
    ::glDeleteVertexArrays(1u, &vao_);
}

void OpenGLMesh::update_vertex_data(const std::vector<VertexData> &data)
{
    const auto capacity = vertex_buffer_.capacity();

    ConstantBufferWriter writer{vertex_buffer_};
    writer.write(data);

    // if buffer resized then we need to re-setup the vao
    if (capacity != vertex_buffer_.capacity())
    {
        setup_vao();
    }
}

void OpenGLMesh::update_index_data(const std::vector<std::uint32_t> &data)
{
    const auto capacity = index_buffer_.capacity();

    ConstantBufferWriter writer{index_buffer_};
    writer.write(data);

    element_count_ = static_cast<GLsizei>(data.size());

    // if buffer resized then we need to re-setup the vao
    if (capacity != index_buffer_.capacity())
    {
        setup_vao();
    }
}

GLsizei OpenGLMesh::element_count() const
{
    return element_count_;
}

void OpenGLMesh::bind() const
{
    ::glBindVertexArray(vao_);
    expect(check_opengl_error, "could not bind vao");
}

void OpenGLMesh::unbind() const
{
    ::glBindVertexArray(0u);
    expect(check_opengl_error, "could not unbind vao");
}

void OpenGLMesh::setup_vao()
{
    bind();

    // ensure both buffers are bound for the vao
    ::glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer_.handle());
    expect(check_opengl_error, "could not bind buffer");
    ::glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, index_buffer_.handle());
    expect(check_opengl_error, "could not bind buffer");

    auto index = 0u;

    // define the vertex attribute data for opengl
    for (const auto &attribute : attributes_)
    {
        const auto &[type, components, _, offset] = attribute;

        ::glEnableVertexAttribArray(index);
        expect(check_opengl_error, "could not enable attribute");

        const auto &[open_gl_type, is_float] = to_opengl_format(type);

        if (is_float)
        {
            ::glVertexAttribPointer(
                index,
                static_cast<GLint>(components),
                open_gl_type,
                GL_FALSE,
                static_cast<GLsizei>(attributes_.size()),
                reinterpret_cast<void *>(offset));
            expect(check_opengl_error, "could not set attributes");
        }
        else
        {
            ::glVertexAttribIPointer(
                index,
                static_cast<GLint>(components),
                open_gl_type,
                static_cast<GLsizei>(attributes_.size()),
                reinterpret_cast<void *>(offset));
            expect(check_opengl_error, "could not set attributes");
        }

        ++index;
    }

    unbind();
}

}

```

`src/graphics/opengl/opengl_mesh_manager.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/opengl/opengl_mesh_manager.h"

#include <cstdint>
#include <memory>
#include <vector>

#include "core/resource_manager.h"
#include "graphics/mesh.h"
#include "graphics/mesh_manager.h"
#include "graphics/opengl/opengl_mesh.h"
#include "graphics/vertex_data.h"

namespace iris
{

OpenGLMeshManager::OpenGLMeshManager(ResourceManager &resource_manager)
    : MeshManager(resource_manager, true)
{
}

std::unique_ptr<Mesh> OpenGLMeshManager::create_mesh(
    const std::vector<iris::VertexData> &vertices,
    const std::vector<std::uint32_t> &indices) const
{
    return std::make_unique<OpenGLMesh>(vertices, indices, DefaultVertexAttributes);
}

}

```

`src/graphics/opengl/opengl_render_target.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/opengl/opengl_render_target.h"

#include "graphics/texture.h"

namespace iris
{

OpenGLRenderTarget::OpenGLRenderTarget(const Texture *colour_texture, const Texture *depth_texture)
    : RenderTarget(colour_texture, depth_texture)
{
}

}

```

`src/graphics/opengl/opengl_render_target_manager.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/opengl/opengl_render_target_manager.h"

#include "graphics/opengl/opengl_render_target.h"
#include "graphics/opengl/opengl_texture.h"
#include "graphics/sampler.h"
#include "graphics/texture_manager.h"
#include "graphics/window.h"
#include "graphics/window_manager.h"

namespace iris
{

OpenGLRenderTargetManager::OpenGLRenderTargetManager(WindowManager &window_manager, TextureManager &texture_manager)
    : window_manager_(window_manager)
    , texture_manager_(texture_manager)
{
}

RenderTarget *OpenGLRenderTargetManager::create()
{
    const auto *window = window_manager_.current_window();
    return create(window->width(), window->height());
}

RenderTarget *OpenGLRenderTargetManager::create(std::uint32_t width, std::uint32_t height)
{
    const auto scale = window_manager_.current_window()->screen_scale();
    const auto *sampler = texture_manager_.create(SamplerDescriptor{.uses_mips = false});
    const auto *depth_sampler = texture_manager_.create(SamplerDescriptor{
        .s_address_mode = SamplerAddressMode::CLAMP_TO_BORDER,
        .t_address_mode = SamplerAddressMode::CLAMP_TO_BORDER,
        .border_colour = Colour{1.0f, 1.0f, 1.0f, 1.0f},
        .uses_mips = false});

    return render_targets_
        .emplace_back(std::make_unique<OpenGLRenderTarget>(
            texture_manager_.create(DataBuffer{}, width * scale, height * scale, TextureUsage::RENDER_TARGET, sampler),
            texture_manager_.create(DataBuffer{}, width * scale, height * scale, TextureUsage::DEPTH, depth_sampler)))
        .get();
}

RenderTarget *OpenGLRenderTargetManager::create(const RenderTarget *colour_target, const RenderTarget *depth_target)
{
    return render_targets_
        .emplace_back(
            std::make_unique<OpenGLRenderTarget>(colour_target->colour_texture(), depth_target->depth_texture()))
        .get();
}

}

```

`src/graphics/opengl/opengl_renderer.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/opengl/opengl_renderer.h"

#include <cassert>
#include <deque>
#include <string>
#include <utility>

#include "core/camera.h"
#include "core/error_handling.h"
#include "core/vector3.h"
#include "graphics/constant_buffer_writer.h"
#include "graphics/instanced_entity.h"
#include "graphics/lights/lighting_rig.h"
#include "graphics/material_manager.h"
#include "graphics/mesh_manager.h"
#include "graphics/opengl/opengl.h"
#include "graphics/opengl/opengl_cube_map.h"
#include "graphics/opengl/opengl_material.h"
#include "graphics/opengl/opengl_mesh.h"
#include "graphics/opengl/opengl_render_target.h"
#include "graphics/opengl/opengl_texture.h"
#include "graphics/opengl/opengl_texture_manager.h"
#include "graphics/render_entity.h"
#include "graphics/render_entity_type.h"
#include "graphics/render_graph/sky_box_node.h"
#include "graphics/render_graph/texture_node.h"
#include "graphics/sampler.h"
#include "graphics/single_entity.h"
#include "graphics/texture_manager.h"
#include "graphics/window.h"
#include "graphics/window_manager.h"
#include "log/log.h"

#if defined(IRIS_PLATFORM_WIN32)
#include "graphics/win32/win32_opengl_window.h"
#elif defined(IRIS_PLATFORM_LINUX)
#include "graphics/linux/linux_window.h"
#endif

namespace
{

/**
 * Helper function to setup opengl for a render pass.
 *
 * @param target
 *   RenderTarget for render pass.
 */
void render_setup(const iris::OpenGLFrameBuffer &frame_buffer)
{
    if (frame_buffer.colour_target() == nullptr)
    {
        ::glBindFramebuffer(GL_FRAMEBUFFER, 0u);
    }
    else
    {
        ::glViewport(0, 0, frame_buffer.colour_target()->width(), frame_buffer.colour_target()->height());
        iris::expect(iris::check_opengl_error, "could not set viewport");

        frame_buffer.bind();
    }
}

/**
 * Helper function to draw all meshes in a RenderEntity.
 *
 * @param entity
 *   RenderEntity to draw
 */
void draw_meshes(const iris::RenderEntity *entity)
{
    const auto *mesh = static_cast<const iris::OpenGLMesh *>(entity->mesh());
    mesh->bind();

    const auto type = entity->primitive_type() == iris::PrimitiveType::TRIANGLES ? GL_TRIANGLES : GL_LINES;
    const auto instance_count = (entity->type() == iris::RenderEntityType::INSTANCED)
                                    ? static_cast<const iris::InstancedEntity *>(entity)->instance_count()
                                    : 1u;

    // draw!
    ::glDrawElementsInstanced(type, mesh->element_count(), GL_UNSIGNED_INT, 0, static_cast<GLsizei>(instance_count));
    iris::expect(iris::check_opengl_error, "could not draw triangles");

    mesh->unbind();

    if (entity->should_render_wireframe())
    {
        ::glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
    }
}

/**
 * Helper function to create a SSBO for the global texture table.
 *
 * @return
 *   SSBO with all textures loaded at the correct index.
 */
std::unique_ptr<iris::SSBO> create_texture_table_ssbo(iris::TextureManager &texture_manager)
{
    const auto textures = texture_manager.textures();
    const auto max_index = textures.back()->index();
    auto texture_table = std::make_unique<iris::SSBO>((max_index + 1u) * sizeof(GLuint64), 3u);
    const auto *blank_texture = static_cast<const iris::OpenGLTexture *>(texture_manager.blank_texture());
    auto iter = std::cbegin(textures);

    // write bindless handles into the SSBO
    iris::ConstantBufferWriter writer{*texture_table};
    for (auto i = 0u; i <= max_index; ++i)
    {
        // if a texture exits at the current index we write it in
        if (i == (*iter)->index())
        {
            const auto *opengl_texture = static_cast<const iris::OpenGLTexture *>(*iter);
            writer.write(opengl_texture->bindless_handle());
            ++iter;
        }
        else
        {
            // no texture at current index, so write default texture
            writer.write(blank_texture->bindless_handle());
        }
    }

    return texture_table;
}

/**
 * Helper function to create a SSBO for the global cube map table.
 *
 * @return
 *   SSBO with all cube maps loaded at the correct index.
 */
std::unique_ptr<iris::SSBO> create_cube_map_table_ssbo(iris::TextureManager &texture_manager)
{
    const auto cube_maps = texture_manager.cube_maps();
    const auto max_index = cube_maps.back()->index();
    auto cube_map_table = std::make_unique<iris::SSBO>((max_index + 1u) * sizeof(GLuint64), 4u);
    const auto *blank_cube_map = static_cast<const iris::OpenGLCubeMap *>(texture_manager.blank_cube_map());
    auto iter = std::cbegin(cube_maps);

    // write bindless handles into the SSBO
    iris::ConstantBufferWriter writer{*cube_map_table};
    for (auto i = 0u; i <= max_index; ++i)
    {
        // if a cube map exits at the current index we write it in
        if (i == (*iter)->index())
        {
            const auto *opengl_cube_map = static_cast<const iris::OpenGLCubeMap *>(*iter);
            writer.write(opengl_cube_map->bindless_handle());
            ++iter;
        }
        else
        {
            // no cube map at current index, so write default cube map
            writer.write(blank_cube_map->bindless_handle());
        }
    }

    return cube_map_table;
}

}

namespace iris
{

OpenGLRenderer::OpenGLRenderer(
    WindowManager &window_manager,
    TextureManager &texture_manager,
    MaterialManager &material_manager,
    std::uint32_t width,
    std::uint32_t height)
    : Renderer(material_manager)
    , window_manager_(window_manager)
    , texture_manager_(texture_manager)
    , width_(width)
    , height_(height)
    , bone_data_()
    , light_data_()
{
    ::glClearColor(0.39f, 0.58f, 0.93f, 1.0f);
    expect(check_opengl_error, "could not set clear colour");

    ::glEnable(GL_DEPTH_TEST);
    expect(check_opengl_error, "could not enable depth testing");

    ::glDepthFunc(GL_LEQUAL);
    expect(check_opengl_error, "could not set depth test function");

    LOG_ENGINE_INFO("render_system", "constructed opengl renderer");
}

void OpenGLRenderer::do_set_render_pipeline(std::function<void()> build_queue)
{
    instance_data_.clear();
    pass_frame_buffers_.clear();

    build_queue();

    // loop through all draw commands, for each drawn entity create a uniform object so they can be easily set during
    // render
    for (const auto &command : render_queue_)
    {
        if (command.type() == RenderCommandType::DRAW)
        {
            const auto *render_entity = command.render_entity();

            if (render_entity->type() == RenderEntityType::INSTANCED)
            {
                const auto *instanced_entity = static_cast<const InstancedEntity *>(render_entity);
                instance_data_[render_entity] =
                    std::make_unique<SSBO>(instanced_entity->data().size() * sizeof(Matrix4), 5u);

                ConstantBufferWriter writer{*instance_data_[render_entity]};

                writer.write(instanced_entity->data());
            }
        }
    }

    for (const auto *pass : render_pipeline_->render_passes())
    {
        pass_frame_buffers_[pass] = OpenGLFrameBuffer{
            static_cast<const OpenGLRenderTarget *>(pass->colour_target),
            static_cast<const OpenGLRenderTarget *>(pass->normal_target),
            static_cast<const OpenGLRenderTarget *>(pass->position_target)};
    }

    texture_table_ = create_texture_table_ssbo(texture_manager_);
    cube_map_table_ = create_cube_map_table_ssbo(texture_manager_);
}

void OpenGLRenderer::execute_pass_start(RenderCommand &command)
{
    const auto &frame_buffer = pass_frame_buffers_.at(command.render_pass());
    const auto *camera = command.render_pass()->camera;

    // if we have no target then we render to the default framebuffer
    // else we bind the supplied target
    if (frame_buffer.colour_target() == nullptr)
    {
        const auto scale = window_manager_.current_window()->screen_scale();

        ::glViewport(0, 0, width_ * scale, height_ * scale);
        expect(check_opengl_error, "could not set viewport");

        ::glBindFramebuffer(GL_FRAMEBUFFER, 0);
        expect(check_opengl_error, "could not bind default buffer");
    }
    else
    {
        ::glViewport(0, 0, frame_buffer.colour_target()->width(), frame_buffer.colour_target()->height());
        expect(check_opengl_error, "could not set viewport");

        frame_buffer.bind();
    }

    // clear current target

    if (command.render_pass()->clear_colour)
    {
        ::glClear(GL_COLOR_BUFFER_BIT);
        expect(check_opengl_error, "could not clear");
    }

    if (command.render_pass()->clear_depth)
    {
        ::glClear(GL_DEPTH_BUFFER_BIT);
        expect(check_opengl_error, "could not clear");
    }

    bone_data_.clear();
    model_data_.clear();
    light_data_.clear();

    camera_data_ = std::make_unique<UBO>((sizeof(Matrix4) * 3u) + sizeof(Vector3), 0u);
    render_values_ = std::make_unique<UBO>(64u, 6u);

    // calculate view matrix for normals
    auto normal_view = Matrix4::transpose(Matrix4::invert(camera->view()));
    normal_view[3] = 0.0f;
    normal_view[7] = 0.0f;
    normal_view[11] = 0.0f;

    ConstantBufferWriter writer{*camera_data_};
    writer.write(camera->projection());
    writer.write(camera->view());
    writer.write(normal_view);
    writer.write(camera->position());
}

void OpenGLRenderer::execute_draw(RenderCommand &command)
{
    const auto *render_entity = command.render_entity();
    const auto *light = command.light();
    const auto &frame_buffer = pass_frame_buffers_.at(command.render_pass());

    static const OpenGLRenderTarget *previous_target = nullptr;
    const auto *target = static_cast<const OpenGLRenderTarget *>(frame_buffer.colour_target());

    // optimisation, we only call render_setup when the target changes
    if (target != previous_target)
    {
        render_setup(frame_buffer);
        previous_target = target;
    }

    static const OpenGLMaterial *previous_material = nullptr;
    auto *material = static_cast<const OpenGLMaterial *>(command.material());

    // optimisation, we only bind a material when it changes
    if (material != previous_material)
    {
        material->bind();
        previous_material = material;
    }

    // set blend mode based on light
    // ambient is always rendered first (no blending)
    // directional and point are always rendered after (blending)
    switch (light->type())
    {
        case LightType::AMBIENT: ::glDisable(GL_BLEND); break;
        case LightType::DIRECTIONAL:
        case LightType::POINT:
            ::glEnable(GL_BLEND);
            ::glBlendFunc(GL_ONE, GL_ONE);
            break;
    }

    if (render_entity->should_render_wireframe())
    {
        ::glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
    }

    // we use caching to minimise the CPU->GPU communication
    // the first time we see a RenderEntity we cache its bone data (and if its single entity its transform data) we can
    // then reuse these buffers for any subsequent renders of that entity (in this pass)

    if (!bone_data_.contains(render_entity))
    {
        static std::vector<Matrix4> default_bones(100u);

        // first time seeing this entity this pass, so create a new UBO
        bone_data_[render_entity] = std::make_unique<UBO>(sizeof(Matrix4) * 100u, 1u);

        ConstantBufferWriter writer{*bone_data_[render_entity]};

        if (render_entity->type() == RenderEntityType::SINGLE)
        {
            // a single entity, so write in bone data

            const auto *single_entity = static_cast<const SingleEntity *>(render_entity);

            if (single_entity->skeleton() != nullptr)
            {
                const auto &bones = single_entity->skeleton()->transforms();
                writer.write(bones);
                writer.advance((100u - bones.size()) * sizeof(iris::Matrix4));
            }
            else
            {
                writer.write(default_bones);
            }

            // also cache the entities transform data
            model_data_[render_entity] = std::make_unique<SSBO>(128u, 5u);
            ConstantBufferWriter writer2{*model_data_[render_entity]};
            writer2.write(single_entity->transform());
            writer2.write(single_entity->normal_transform());
        }
        else
        {
            // we don't support animation of instanced entities - so just send default bone transforms
            writer.write(default_bones);
        }
    }

    // we also cache light data per pass
    // the first time we see  alight we write its data to a UBO and reuse it for subsequent renders

    if (!light_data_.contains(light))
    {
        light_data_[light] = std::make_unique<UBO>(256u, 2u);

        ConstantBufferWriter writer{*light_data_[light]};

        if (light->type() == iris::LightType::DIRECTIONAL)
        {
            // directional lights have additional data
            const auto *direction_light = static_cast<const iris::DirectionalLight *>(light);

            writer.write(direction_light->shadow_camera().projection());
            writer.write(direction_light->shadow_camera().view());
        }
        else
        {
            // skip over directional light specific data
            writer.advance(sizeof(iris::Matrix4) * 2u);
        }

        writer.write(light->colour_data());
        writer.write(light->world_space_data());
        const auto attenuation = light->attenuation_data();
        std::array<float, 4u> padded{attenuation[0], attenuation[1], attenuation[2], 0.0f};
        writer.write(padded);
    }

    // if we are rendering with a directional light check if it casts shadows
    if (light->type() == LightType::DIRECTIONAL)
    {
        const auto *directional_light = static_cast<const DirectionalLight *>(light);
        if ((directional_light->casts_shadows() && (command.render_entity()->receive_shadow())))
        {
            // if we are rendering with a shadow casting directional light then pass the index of the shadow map (into
            // the texture table) as a uniform
            OpenGLUniform shadow_map_index_uniform{material->handle(), "shadow_map_index", true};
            shadow_map_index_uniform.set_value(command.shadow_map()->depth_texture()->index());
        }
    }

    const auto time_value = static_cast<float>(time().count()) / 1000.0f;
    ConstantBufferWriter writer(*render_values_);
    writer.write(time_value);

    ::glBindBufferBase(GL_UNIFORM_BUFFER, 0, camera_data_->handle());
    expect(check_opengl_error, "could not bind camera data ubo");

    ::glBindBufferBase(GL_UNIFORM_BUFFER, 1, bone_data_[render_entity]->handle());
    expect(check_opengl_error, "could not bind vertex data ubo");

    ::glBindBufferBase(GL_UNIFORM_BUFFER, 2, light_data_[light]->handle());
    expect(check_opengl_error, "could not bind light data ubo");

    ::glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 3, texture_table_->handle());
    expect(check_opengl_error, "could not bind texture data ssbo");

    ::glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 4, cube_map_table_->handle());
    expect(check_opengl_error, "could not bind cube map data ssbo");

    ::glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 6, render_values_->handle());
    expect(check_opengl_error, "could not bind cube render value ssbo");

    // bind model data, depending on if we're rendering a single or instanced entity
    if (render_entity->type() != RenderEntityType::INSTANCED)
    {
        ::glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 5, model_data_[render_entity]->handle());
        expect(check_opengl_error, "could not bind model data ssbo");
    }
    else
    {
        ::glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 5, instance_data_[render_entity]->handle());
        expect(check_opengl_error, "could not bind model data ssbo");
    }

    draw_meshes(render_entity);
}

void OpenGLRenderer::execute_present(RenderCommand &)
{
#if defined(IRIS_PLATFORM_MACOS)
    ::glSwapAPPLE();
#elif defined(IRIS_PLATFORM_WIN32)
    const auto *window = static_cast<Win32OpenGLWindow *>(window_manager_.current_window());
    ::SwapBuffers(window->device_context());
#elif defined(IRIS_PLATFORM_LINUX)
    const auto *window = static_cast<LinuxWindow *>(window_manager_.current_window());
    ::glXSwapBuffers(window->display(), window->window());
#endif
}
}

```

`src/graphics/opengl/opengl_sampler.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/opengl/opengl_sampler.h"

#include <cstdint>

#include "core/error_handling.h"
#include "graphics/opengl/opengl.h"

namespace
{

/**
 * Helper function to convert an engine address mode to an OpenGL address mode.
 *
 * @param address_mode
 *   Engine address mode.
 *
 * @returns
 *   OpenGL address mode.
 */
GLint to_opengl(iris::SamplerAddressMode address_mode)
{
    switch (address_mode)
    {
        case iris::SamplerAddressMode::REPEAT: return GL_REPEAT;
        case iris::SamplerAddressMode::MIRROR: return GL_MIRRORED_REPEAT;
        case iris::SamplerAddressMode::CLAMP_TO_EDGE: return GL_CLAMP_TO_EDGE;
        case iris::SamplerAddressMode::CLAMP_TO_BORDER: return GL_CLAMP_TO_BORDER;
        default: throw iris::Exception("unknown address mode");
    }
}

/**
 * Helper method to convert an engine filter to an OpenGL filter.
 *
 * @param filter
 *   Engine filter.
 *
 * @returns
 *   OpenGL filter.
 */
GLint to_opengl(iris::SamplerFilter filter)
{
    switch (filter)
    {
        case iris::SamplerFilter::NEAREST: return GL_NEAREST;
        case iris::SamplerFilter::LINEAR: return GL_LINEAR;
        default: throw iris::Exception("unknown filter");
    }
}

}

namespace iris
{

OpenGLSampler::OpenGLSampler(const SamplerDescriptor &descriptor, std::uint32_t index)
    : Sampler(descriptor, index)
    , handle_(0u)
{
    ::glGenSamplers(1u, &handle_);
    ensure(check_opengl_error, "could not generate sampler");

    ::glSamplerParameteri(handle_, GL_TEXTURE_WRAP_S, to_opengl(descriptor.s_address_mode));
    ensure(check_opengl_error, "could not set s wrap mode");

    ::glSamplerParameteri(handle_, GL_TEXTURE_WRAP_T, to_opengl(descriptor.t_address_mode));
    ensure(check_opengl_error, "could not set t wrap mode");

    ::glSamplerParameteri(handle_, GL_TEXTURE_WRAP_R, to_opengl(descriptor.r_address_mode));
    ensure(check_opengl_error, "could not set r wrap mode");

    ::glSamplerParameterfv(
        handle_, GL_TEXTURE_BORDER_COLOR, reinterpret_cast<const float *>(&descriptor.border_colour));

    ::glSamplerParameteri(handle_, GL_TEXTURE_MAG_FILTER, to_opengl(descriptor.magnification_filter));
    ensure(iris::check_opengl_error, "could not set max filter");

    // set mip-specific minification filters
    if (descriptor.uses_mips)
    {
        if ((descriptor.minification_filter == SamplerFilter::NEAREST) &&
            (descriptor.mip_filter == SamplerFilter::NEAREST))
        {
            ::glSamplerParameteri(handle_, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_NEAREST);
            ensure(iris::check_opengl_error, "could not set min filter");
        }
        else if (
            (descriptor.minification_filter == SamplerFilter::LINEAR) &&
            (descriptor.mip_filter == SamplerFilter::NEAREST))
        {
            ::glSamplerParameteri(handle_, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_NEAREST);
            ensure(iris::check_opengl_error, "could not set min filter");
        }
        else if (
            (descriptor.minification_filter == SamplerFilter::NEAREST) &&
            (descriptor.mip_filter == SamplerFilter::LINEAR))
        {
            ::glSamplerParameteri(handle_, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_LINEAR);
            ensure(iris::check_opengl_error, "could not set min filter");
        }
        else if (
            (descriptor.minification_filter == SamplerFilter::LINEAR) &&
            (descriptor.mip_filter == SamplerFilter::LINEAR))
        {
            ::glSamplerParameteri(handle_, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
            ensure(iris::check_opengl_error, "could not set min filter");
        }
        else
        {
            throw Exception("unknown min filter");
        }
    }
    else
    {
        ::glSamplerParameteri(handle_, GL_TEXTURE_MIN_FILTER, to_opengl(descriptor.minification_filter));
        ensure(iris::check_opengl_error, "could not set min filter");
    }
}

OpenGLSampler::~OpenGLSampler()
{
    ::glDeleteSamplers(1u, &handle_);
}

GLuint OpenGLSampler::handle() const
{
    return handle_;
}

};

```

`src/graphics/opengl/opengl_shader.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/opengl/opengl_shader.h"

#include <cstdint>
#include <iomanip>
#include <iostream>
#include <string>
#include <string_view>
#include <utility>
#include <vector>

#include "core/error_handling.h"
#include "graphics/opengl/opengl.h"
#include "graphics/shader_type.h"
#include "log/log.h"

namespace iris
{

OpenGLShader::OpenGLShader(const std::string &source, ShaderType type)
    : shader_(0u)
{
    const auto native_type = (type == ShaderType::VERTEX) ? GL_VERTEX_SHADER : GL_FRAGMENT_SHADER;

    shader_ = ::glCreateShader(native_type);
    expect(check_opengl_error, "could not create vertex shader");

    auto shader_c_str = source.data();

    ::glShaderSource(shader_, 1, &shader_c_str, nullptr);
    expect(check_opengl_error, "could not set shader source");

    ::glCompileShader(shader_);

    GLint shader_param = 0;

    ::glGetShaderiv(shader_, GL_COMPILE_STATUS, &shader_param);
    expect(check_opengl_error, "could not get shader parameter");

    // if shader failed to compile then get the opengl error
    if (shader_param != GL_TRUE)
    {
        ::glGetShaderiv(shader_, GL_INFO_LOG_LENGTH, &shader_param);
        expect(check_opengl_error, "could not get shader log length");

        if (shader_param == 0)
        {
            throw Exception("shader compilation failed: no log");
        }
        else
        {
            std::vector<char> error_log(shader_param);

            // get opengl error log
            GLsizei log_length = 0;
            ::glGetShaderInfoLog(shader_, static_cast<std::int32_t>(error_log.size()), &log_length, error_log.data());
            expect(check_opengl_error, "failed to get error log");

            // convert to string and throw
            const std::string error(error_log.data(), log_length);

            auto line_number = 1u;

            std::istringstream strm{source};
            for (std::string line; std::getline(strm, line);)
            {
                LOG_ENGINE_ERROR("opengl_shader", "{}: {}", line_number, line);
                ++line_number;
            }

            LOG_ENGINE_ERROR("opengl_shader", "{}", error);

            throw Exception("shader compilation failed: " + error);
        }
    }
}

OpenGLShader::~OpenGLShader()
{
    ::glDeleteShader(shader_);
}

OpenGLShader::OpenGLShader(OpenGLShader &&other)
    : shader_(0u)
{
    std::swap(shader_, other.shader_);
}

OpenGLShader &OpenGLShader::operator=(OpenGLShader &&other)
{
    // create a new shader object to 'steal' the internal state of the supplied
    // object then swap
    // this ensures that the current shader is correctly deleted at the end
    // of this call
    OpenGLShader new_shader{std::move(other)};
    std::swap(shader_, new_shader.shader_);

    return *this;
}

GLuint OpenGLShader::native_handle() const
{
    return shader_;
}

}

```

`src/graphics/opengl/opengl_texture.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/opengl/opengl_texture.h"

#include <any>
#include <cstdint>
#include <filesystem>
#include <memory>
#include <stack>
#include <vector>

#include "core/data_buffer.h"
#include "core/error_handling.h"
#include "graphics/opengl/opengl.h"
#include "graphics/opengl/opengl_sampler.h"
#include "graphics/sampler.h"
#include "graphics/texture_usage.h"
#include "graphics/utils.h"
#include "log/log.h"

namespace
{

/**
 * Helper function to specify a texture suitable for the texture usage.
 * usage.
 *
 * @param width
 *   Width of texture.
 *
 * @param height
 *   Height of texture.
 *
 * @param data
 *   Image data.
 *
 * @param sampler_descriptor
 *   Sampler description.
 */
void specify_image_texture(
    std::uint32_t width,
    std::uint32_t height,
    const iris::DataBuffer &data,
    const iris::SamplerDescriptor &sampler_descriptor)
{
    if (!sampler_descriptor.uses_mips)
    {
        ::glTexImage2D(GL_TEXTURE_2D, 0, GL_SRGB_ALPHA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data.data());
        iris::ensure(iris::check_opengl_error, "could not set specify image texture");
    }
    else
    {
        // generate mipmaps and upload each one
        auto level = 0u;
        for (const auto &[mip_data, mip_width, mip_height] :
             iris::generate_mip_maps({.data = data, .width = width, .height = height}))
        {
            ::glTexImage2D(
                GL_TEXTURE_2D,
                level,
                GL_SRGB_ALPHA,
                mip_width,
                mip_height,
                0,
                GL_RGBA,
                GL_UNSIGNED_BYTE,
                mip_data.data());
            iris::ensure(iris::check_opengl_error, "could not set specify image texture");

            ++level;
        }
    }
}

/**
 * Helper function to specify a texture suitable for the data usage.
 * usage.
 *
 * @param width
 *   Width of texture.
 *
 * @param height
 *   Height of texture.
 *
 * @param data
 *   Image data.
 *
 * @param sampler_descriptor
 *   Sampler description.
 */
void specify_data_texture(
    std::uint32_t width,
    std::uint32_t height,
    const iris::DataBuffer &data,
    const iris::SamplerDescriptor &sampler_descriptor)
{
    if (!sampler_descriptor.uses_mips)
    {
        ::glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data.data());
        iris::ensure(iris::check_opengl_error, "could not set specify data texture");
    }
    else
    {
        // generate mipmaps and upload each one
        auto level = 0u;
        for (const auto &[mip_data, mip_width, mip_height] :
             iris::generate_mip_maps({.data = data, .width = width, .height = height}))
        {
            ::glTexImage2D(
                GL_TEXTURE_2D, level, GL_RGBA, mip_width, mip_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, mip_data.data());
            iris::ensure(iris::check_opengl_error, "could not set specify image texture");

            ++level;
        }
    }
}

/**
 * Helper function to specify a texture suitable for the render target usage.
 * usage.
 *
 * @param width
 *   Width of texture.
 *
 * @param height
 *   Height of texture.
 */
void specify_render_target_texture(std::uint32_t width, std::uint32_t height)
{
    ::glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA16F, width, height, 0, GL_RGBA, GL_FLOAT, nullptr);
    iris::ensure(iris::check_opengl_error, "could not set specify render target texture");
}

/**
 * Helper function to specify a texture suitable for the depth usage.
 * usage.
 *
 * @param width
 *   Width of texture.
 *
 * @param height
 *   Height of texture.
 */
void specify_depth_texture(std::uint32_t width, std::uint32_t height)
{
    ::glTexImage2D(
        GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, width, height, 0, GL_DEPTH_COMPONENT, GL_UNSIGNED_SHORT, nullptr);
    iris::ensure(iris::check_opengl_error, "could not set specify depth texture");
}

/**
 * Helper function to create an opengl Texture from data.
 *
 * @param data
 *   Image data. This should be width * hight of pixel_format tuples.
 *
 * @param width
 *   Width of image.
 *
 * @param height
 *   Height of image.
 *
 * @param sampler
 *   Sampler to use for this texture.
 *
 * @param usage
 *   Texture usage.
 *
 * @returns
 *   Handle to texture.
 */
GLuint create_texture(
    const iris::DataBuffer &data,
    std::uint32_t width,
    std::uint32_t height,
    const iris::Sampler *sampler,
    iris::TextureUsage usage)
{
    auto texture = 0u;

    ::glGenTextures(1, &texture);
    iris::ensure(iris::check_opengl_error, "could not generate texture");

    ::glBindTexture(GL_TEXTURE_2D, texture);
    iris::ensure(iris::check_opengl_error, "could not bind texture");

    // specify the image data based on the usage type
    switch (usage)
    {
        case iris::TextureUsage::IMAGE: specify_image_texture(width, height, data, sampler->descriptor()); break;
        case iris::TextureUsage::DATA: specify_data_texture(width, height, data, sampler->descriptor()); break;
        case iris::TextureUsage::RENDER_TARGET: specify_render_target_texture(width, height); break;
        case iris::TextureUsage::DEPTH: specify_depth_texture(width, height); break;
        default: throw iris::Exception("unknown usage");
    }

    return texture;
}

}

namespace iris
{

OpenGLTexture::OpenGLTexture(
    const DataBuffer &data,
    std::uint32_t width,
    std::uint32_t height,
    const Sampler *sampler,
    TextureUsage usage,
    std::uint32_t index)
    : Texture(data, width, height, sampler, usage, index)
    , handle_(create_texture(data, width, height, sampler, usage))
    , bindless_handle_(0u)
{
    const auto *opengl_sampler = static_cast<const iris::OpenGLSampler *>(sampler);

    // create a bindless handle and make it resident
    bindless_handle_ = ::glGetTextureSamplerHandleARB(handle_, opengl_sampler->handle());
    ensure(check_opengl_error, "could not create bindless handle");

    ::glMakeTextureHandleResidentARB(bindless_handle_);
    ensure(check_opengl_error, "could not make bindless handle resident");

    LOG_ENGINE_INFO("opengl_texture", "loaded from data");
}

OpenGLTexture::~OpenGLTexture()
{
    ::glMakeTextureHandleNonResidentARB(bindless_handle_);
    ::glDeleteTextures(1, &handle_);
}

GLuint OpenGLTexture::handle() const
{
    return handle_;
}

GLuint64 OpenGLTexture::bindless_handle() const
{
    return bindless_handle_;
}

}

```

`src/graphics/opengl/opengl_texture_manager.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/opengl/opengl_texture_manager.h"

#include <cstdint>
#include <memory>
#include <stack>

#include "core/data_buffer.h"
#include "core/error_handling.h"
#include "core/resource_manager.h"
#include "graphics/opengl/opengl.h"
#include "graphics/opengl/opengl_cube_map.h"
#include "graphics/opengl/opengl_sampler.h"
#include "graphics/opengl/opengl_texture.h"
#include "graphics/sampler.h"
#include "graphics/texture_manager.h"
#include "graphics/texture_usage.h"


namespace iris
{

OpenGLTextureManager::OpenGLTextureManager(ResourceManager &resource_manager)
    : TextureManager(resource_manager)
{
}

std::unique_ptr<Texture> OpenGLTextureManager::do_create(
    const DataBuffer &data,
    std::uint32_t width,
    std::uint32_t height,
    const Sampler *sampler,
    TextureUsage usage,
    std::uint32_t index)
{
    return std::make_unique<OpenGLTexture>(data, width, height, sampler, usage, index);
}

std::unique_ptr<CubeMap> OpenGLTextureManager::do_create(
    const DataBuffer &right_data,
    const DataBuffer &left_data,
    const DataBuffer &top_data,
    const DataBuffer &bottom_data,
    const DataBuffer &near_data,
    const DataBuffer &far_data,
    std::uint32_t width,
    std::uint32_t height,
    const Sampler *sampler,
    std::uint32_t index)
{
    return std::make_unique<OpenGLCubeMap>(
        right_data, left_data, top_data, bottom_data, near_data, far_data, width, height, sampler, index);
}

std::unique_ptr<Sampler> OpenGLTextureManager::do_create(const SamplerDescriptor &descriptor, std::uint32_t index)
{
    return std::make_unique<OpenGLSampler>(descriptor, index);
}

}

```

`src/graphics/opengl/opengl_uniform.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/opengl/opengl_uniform.h"

#include <array>
#include <cstdint>
#include <string>
#include <vector>

#include "core/error_handling.h"
#include "core/matrix4.h"
#include "graphics/opengl/opengl.h"

namespace iris
{

OpenGLUniform::OpenGLUniform(GLuint program, const std::string &name, bool ensure_exists)
    : location_(-1)
{
    location_ = ::glGetUniformLocation(program, name.c_str());
    expect(check_opengl_error, "could not get uniform location");

    if (ensure_exists)
    {
        expect(location_ != -1, "uniform location does not exist");
    }
}

void OpenGLUniform::set_value(const Matrix4 &value) const
{
    ::glUniformMatrix4fv(location_, 1, GL_TRUE, reinterpret_cast<const float *>(value.data()));
    expect(check_opengl_error, "could not set uniform data");
}

void OpenGLUniform::set_value(const std::vector<Matrix4> &value) const
{
    ::glUniformMatrix4fv(
        location_, static_cast<GLsizei>(value.size()), GL_TRUE, reinterpret_cast<const float *>(value.data()));
    expect(check_opengl_error, "could not set uniform data");
}

void OpenGLUniform::set_value(const std::array<float, 4u> &value) const
{
    ::glUniform4fv(location_, 1u, value.data());
    expect(check_opengl_error, "could not set uniform data");
}

void OpenGLUniform::set_value(const std::array<float, 3u> &value) const
{
    ::glUniform1fv(location_, 3u, value.data());
    expect(check_opengl_error, "could not set uniform data");
}

void OpenGLUniform::set_value(std::int32_t value) const
{
    ::glUniform1i(location_, value);
    expect(check_opengl_error, "could not set uniform data");
}

}

```

`src/graphics/render_command.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/render_command.h"

#include "graphics/lights/light.h"
#include "graphics/lights/light_type.h"
#include "graphics/material.h"
#include "graphics/render_command_type.h"
#include "graphics/render_entity.h"
#include "graphics/render_pass.h"
#include "graphics/render_target.h"

namespace iris
{

RenderCommand::RenderCommand()
    : type_(RenderCommandType::PASS_START)
    , render_pass_(nullptr)
    , material_(nullptr)
    , render_entity_(nullptr)
    , shadow_map_(nullptr)
    , light_(nullptr)
{
}

RenderCommand::RenderCommand(
    RenderCommandType type,
    const RenderPass *render_pass,
    const Material *material,
    const RenderEntity *render_entity,
    const RenderTarget *shadow_map,
    const Light *light)
    : type_(type)
    , render_pass_(render_pass)
    , material_(material)
    , render_entity_(render_entity)
    , shadow_map_(shadow_map)
    , light_(light)
{
}

RenderCommandType RenderCommand::type() const
{
    return type_;
}

void RenderCommand::set_type(RenderCommandType type)
{
    type_ = type;
}

const RenderPass *RenderCommand::render_pass() const
{
    return render_pass_;
}

void RenderCommand::set_render_pass(const RenderPass *render_pass)
{
    render_pass_ = render_pass;
}

const Material *RenderCommand::material() const
{
    return material_;
}

void RenderCommand::set_material(const Material *material)
{
    material_ = material;
}

const RenderEntity *RenderCommand::render_entity() const
{
    return render_entity_;
}

void RenderCommand::set_render_entity(const RenderEntity *render_entity)
{
    render_entity_ = render_entity;
}

const Light *RenderCommand::light() const
{
    return light_;
}

void RenderCommand::set_light(const Light *light)
{
    light_ = light;
}

const RenderTarget *RenderCommand::shadow_map() const
{
    return shadow_map_;
}

void RenderCommand::set_shadow_map(const RenderTarget *shadow_map)
{
    shadow_map_ = shadow_map;
}

}

```

`src/graphics/render_entity.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/render_entity.h"

#include <string>
#include <string_view>

#include "graphics/mesh.h"
#include "graphics/primitive_type.h"

namespace iris
{

RenderEntity::RenderEntity(const Mesh *mesh, PrimitiveType primitive_type)
    : mesh_(mesh)
    , wireframe_(false)
    , primitive_type_(primitive_type)
    , name_()
    , receive_shadow_(true)
{
}

const Mesh *RenderEntity::mesh() const
{
    return mesh_;
}

bool RenderEntity::should_render_wireframe() const
{
    return wireframe_;
}

void RenderEntity::set_wireframe(const bool wireframe)
{
    wireframe_ = wireframe;
}

PrimitiveType RenderEntity::primitive_type() const
{
    return primitive_type_;
}

std::string RenderEntity::name() const
{
    return name_;
}

void RenderEntity::set_name(std::string_view name)
{
    name_ = name;
}

bool RenderEntity::receive_shadow() const
{
    return receive_shadow_;
}

void RenderEntity::set_receive_shadow(bool receive_shadow)
{
    receive_shadow_ = receive_shadow;
}

}

```

`src/graphics/render_graph/CMakeLists.txt`:

```txt
set(INCLUDE_ROOT "${PROJECT_SOURCE_DIR}/include/iris/graphics/render_graph")

add_subdirectory("post_processing")

target_sources(iris PRIVATE
    ${INCLUDE_ROOT}/binary_operator_node.h
    ${INCLUDE_ROOT}/blur_node.h
    ${INCLUDE_ROOT}/camera_node.h
    ${INCLUDE_ROOT}/colour_node.h
    ${INCLUDE_ROOT}/combine_node.h
    ${INCLUDE_ROOT}/component_node.h
    ${INCLUDE_ROOT}/composite_node.h
    ${INCLUDE_ROOT}/conditional_node.h
    ${INCLUDE_ROOT}/fragment_node.h
    ${INCLUDE_ROOT}/invert_node.h
    ${INCLUDE_ROOT}/lerp_node.h
    ${INCLUDE_ROOT}/node.h
    ${INCLUDE_ROOT}/property.h
    ${INCLUDE_ROOT}/property_node.h
    ${INCLUDE_ROOT}/property_writer.h
    ${INCLUDE_ROOT}/render_graph.h
    ${INCLUDE_ROOT}/render_node.h
    ${INCLUDE_ROOT}/shader_compiler.h
    ${INCLUDE_ROOT}/sky_box_node.h
    ${INCLUDE_ROOT}/texture_node.h
    ${INCLUDE_ROOT}/time_node.h
    ${INCLUDE_ROOT}/unary_operator_node.h
    ${INCLUDE_ROOT}/variable_node.h
    ${INCLUDE_ROOT}/vertex_node.h
    binary_operator_node.cpp
    blur_node.cpp
    camera_node.cpp
    colour_node.cpp
    combine_node.cpp
    component_node.cpp
    composite_node.cpp
    conditional_node.cpp
    fragment_node.cpp
    invert_node.cpp
    lerp_node.cpp
    property.cpp
    property_node.cpp
    render_graph.cpp
    render_node.cpp
    shader_compiler.cpp
    sky_box_node.cpp
    texture_node.cpp
    time_node.cpp
    unary_operator_node.cpp
    variable_node.cpp
    vertex_node.cpp
)

```

`src/graphics/render_graph/binary_operator_node.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/render_graph/binary_operator_node.h"

#include <cstddef>
#include <functional>

#include "core/utils.h"
#include "graphics/render_graph/node.h"
#include "graphics/render_graph/shader_compiler.h"

namespace iris
{

BinaryOperatorNode::BinaryOperatorNode(Node *value1, Node *value2, BinaryOperator binary_operator)
    : value1_(value1)
    , value2_(value2)
    , binary_operator_(binary_operator)
{
}

void BinaryOperatorNode::accept(ShaderCompiler &compiler) const
{
    compiler.visit(*this);
}

Node *BinaryOperatorNode::value1() const
{
    return value1_;
}

Node *BinaryOperatorNode::value2() const
{
    return value2_;
}

BinaryOperator BinaryOperatorNode::binary_operator() const
{
    return binary_operator_;
}

std::size_t BinaryOperatorNode::hash() const
{
    return combine_hash(value1_, value2_, binary_operator_, "binary_operator_node");
}

}

```

`src/graphics/render_graph/blur_node.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/render_graph/blur_node.h"

#include <cstddef>
#include <string>

#include "core/utils.h"
#include "graphics/render_graph/shader_compiler.h"
#include "graphics/render_graph/texture_node.h"

namespace iris
{

BlurNode::BlurNode(TextureNode *input_node)
    : input_node_(input_node)
{
}

void BlurNode::accept(ShaderCompiler &compiler) const
{
    compiler.visit(*this);
}

TextureNode *BlurNode::input_node() const
{
    return input_node_;
}

std::size_t BlurNode::hash() const
{
    return combine_hash(input_node_, "blue_node");
}

}

```

`src/graphics/render_graph/camera_node.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/render_graph/camera_node.h"

#include <cstddef>
#include <functional>
#include <optional>
#include <string>
#include <string_view>

#include "core/utils.h"
#include "graphics/render_graph/node.h"
#include "graphics/render_graph/shader_compiler.h"

namespace iris
{

CameraNode::CameraNode(CameraDataType camera_data_type)
    : camera_data_type_(camera_data_type)
    , swizzle_(std::nullopt)
{
}

CameraNode::CameraNode(CameraDataType camera_data_type, std::string_view swizzle)
    : camera_data_type_(camera_data_type)
    , swizzle_(swizzle)
{
}

void CameraNode::accept(ShaderCompiler &compiler) const
{
    compiler.visit(*this);
}

CameraDataType CameraNode::camera_data_type() const
{
    return camera_data_type_;
}

std::optional<std::string> CameraNode::swizzle() const
{
    return swizzle_;
}

std::size_t CameraNode::hash() const
{
    return combine_hash(camera_data_type_, swizzle_, "camera_node");
}

}

```

`src/graphics/render_graph/colour_node.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/render_graph/colour_node.h"

#include <cstddef>

#include "core/colour.h"
#include "core/utils.h"
#include "graphics/render_graph/shader_compiler.h"

namespace iris
{

ColourNode::ColourNode(const Colour &colour)
    : colour_(colour)
{
}

void ColourNode::accept(ShaderCompiler &compiler) const
{
    compiler.visit(*this);
}

Colour ColourNode::colour() const
{
    return colour_;
}

std::size_t ColourNode::hash() const
{
    return combine_hash(colour_, "colour_node");
}

}

```

`src/graphics/render_graph/combine_node.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/render_graph/combine_node.h"

#include <cstddef>

#include "graphics/render_graph/shader_compiler.h"

namespace iris
{

CombineNode::CombineNode(Node *value1, Node *value2, Node *value3, Node *value4)
    : value1_(value1)
    , value2_(value2)
    , value3_(value3)
    , value4_(value4)
{
}

void CombineNode::accept(ShaderCompiler &compiler) const
{
    compiler.visit(*this);
}

Node *CombineNode::value1() const
{
    return value1_;
}

Node *CombineNode::value2() const
{
    return value2_;
}

Node *CombineNode::value3() const
{
    return value3_;
}

Node *CombineNode::value4() const
{
    return value4_;
}

std::size_t CombineNode::hash() const
{
    return combine_hash(value1_, value2_, value3_, value4_, "combine_node");
}

}

```

`src/graphics/render_graph/component_node.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/render_graph/component_node.h"

#include <cstddef>
#include <memory>
#include <string>

#include "graphics/render_graph/shader_compiler.h"

namespace iris
{

ComponentNode::ComponentNode(Node *input_node, const std::string &component)
    : input_node_(input_node)
    , component_(component)
{
}

void ComponentNode::accept(ShaderCompiler &compiler) const
{
    compiler.visit(*this);
}

Node *ComponentNode::input_node() const
{
    return input_node_;
}

std::string ComponentNode::component() const
{
    return component_;
}

std::size_t ComponentNode::hash() const
{
    return combine_hash(input_node_, component_, "component_node");
}

}

```

`src/graphics/render_graph/composite_node.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/render_graph/composite_node.h"

#include <cstddef>
#include <memory>

#include "core/vector3.h"
#include "graphics/render_graph/shader_compiler.h"
#include "graphics/texture.h"

namespace iris
{

CompositeNode::CompositeNode(Node *colour1, Node *colour2, Node *depth1, Node *depth2)
    : colour1_(colour1)
    , colour2_(colour2)
    , depth1_(depth1)
    , depth2_(depth2)
{
}

void CompositeNode::accept(ShaderCompiler &compiler) const
{
    compiler.visit(*this);
}

Node *CompositeNode::colour1() const
{
    return colour1_;
}

Node *CompositeNode::colour2() const
{
    return colour2_;
}

Node *CompositeNode::depth1() const
{
    return depth1_;
}

Node *CompositeNode::depth2() const
{
    return depth2_;
}

std::size_t CompositeNode::hash() const
{
    return combine_hash(colour1_, colour2_, depth1_, depth2_, "composite_node");
}

}

```

`src/graphics/render_graph/conditional_node.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/render_graph/conditional_node.h"

#include <cstddef>

#include "graphics/render_graph/node.h"
#include "graphics/render_graph/shader_compiler.h"

namespace iris
{

ConditionalNode::ConditionalNode(
    Node *input_value1,
    Node *input_value2,
    Node *output_value1,
    Node *output_value2,
    ConditionalOperator conditional_operator)
    : input_value1_(input_value1)
    , input_value2_(input_value2)
    , output_value1_(output_value1)
    , output_value2_(output_value2)
    , conditional_operator_(conditional_operator)
{
}

void ConditionalNode::accept(ShaderCompiler &compiler) const
{
    compiler.visit(*this);
}

Node *ConditionalNode::input_value1() const
{
    return input_value1_;
}

Node *ConditionalNode::input_value2() const
{
    return input_value2_;
}

Node *ConditionalNode::output_value1() const
{
    return output_value1_;
}

Node *ConditionalNode::output_value2() const
{
    return output_value2_;
}

ConditionalOperator ConditionalNode::conditional_operator() const
{
    return conditional_operator_;
}

std::size_t ConditionalNode::hash() const
{
    return combine_hash(
        input_value1_, input_value2_, output_value1_, output_value2_, conditional_operator_, "conditional_node");
}

}

```

`src/graphics/render_graph/fragment_node.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/render_graph/fragment_node.h"

#include <cstddef>
#include <functional>
#include <optional>
#include <string>
#include <string_view>

#include "core/utils.h"
#include "graphics/render_graph/node.h"
#include "graphics/render_graph/shader_compiler.h"

namespace iris
{

FragmentNode::FragmentNode(FragmentDataType fragment_data_type)
    : fragment_data_type_(fragment_data_type)
    , swizzle_(std::nullopt)
{
}

FragmentNode::FragmentNode(FragmentDataType fragment_data_type, std::string_view swizzle)
    : fragment_data_type_(fragment_data_type)
    , swizzle_(swizzle)
{
}

void FragmentNode::accept(ShaderCompiler &compiler) const
{
    compiler.visit(*this);
}

FragmentDataType FragmentNode::fragment_data_type() const
{
    return fragment_data_type_;
}

std::optional<std::string> FragmentNode::swizzle() const
{
    return swizzle_;
}

std::size_t FragmentNode::hash() const
{
    return combine_hash(fragment_data_type_, swizzle_, "fragment_node");
}

}

```

`src/graphics/render_graph/invert_node.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/render_graph/invert_node.h"

#include <cstddef>
#include <memory>

#include "graphics/render_graph/shader_compiler.h"

namespace iris
{

InvertNode::InvertNode(Node *input_node)
    : input_node_(input_node)
{
}

void InvertNode::accept(ShaderCompiler &compiler) const
{
    compiler.visit(*this);
}

Node *InvertNode::input_node() const
{
    return input_node_;
}

std::size_t InvertNode::hash() const
{
    return combine_hash(input_node_, "invert_node");
}

}

```

`src/graphics/render_graph/lerp_node.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/render_graph/lerp_node.h"

#include <cstddef>

#include "graphics/render_graph/node.h"
#include "graphics/render_graph/shader_compiler.h"

namespace iris
{

LerpNode::LerpNode(Node *input_value1, Node *input_value2, Node *lerp_amount)
    : input_value1_(input_value1)
    , input_value2_(input_value2)
    , lerp_amount_(lerp_amount)
{
}

void LerpNode::accept(ShaderCompiler &compiler) const
{
    compiler.visit(*this);
}

Node *LerpNode::input_value1() const
{
    return input_value1_;
}

Node *LerpNode::input_value2() const
{
    return input_value2_;
}

Node *LerpNode::lerp_amount() const
{
    return lerp_amount_;
}

std::size_t LerpNode::hash() const
{
    return combine_hash(input_value1_, input_value2_, lerp_amount_, "lerp_node");
}

}

```

`src/graphics/render_graph/post_processing/CMakeLists.txt`:

```txt
set(INCLUDE_ROOT "${PROJECT_SOURCE_DIR}/include/iris/graphics/render_graph/post_processing")

target_sources(iris PRIVATE
    ${INCLUDE_ROOT}/ambient_occlusion_node.h
    ${INCLUDE_ROOT}/anti_aliasing_node.h
    ${INCLUDE_ROOT}/colour_adjust_node.h
    ambient_occlusion_node.cpp
    anti_aliasing_node.cpp
    colour_adjust_node.cpp)

```

`src/graphics/render_graph/post_processing/ambient_occlusion_node.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/render_graph/post_processing/ambient_occlusion_node.h"

#include <cstddef>

#include "graphics/post_processing_description.h"
#include "graphics/render_graph/shader_compiler.h"
#include "graphics/render_graph/texture_node.h"

namespace iris
{

AmbientOcclusionNode::AmbientOcclusionNode(
    TextureNode *input,
    TextureNode *normal_texture,
    TextureNode *position_texture,
    AmbientOcclusionDescription description)
    : RenderNode()
    , normal_texture_(normal_texture)
    , position_texture_(position_texture)
    , description_(description)
{
    set_colour_input(input);
}

void AmbientOcclusionNode::accept(ShaderCompiler &compiler) const
{
    compiler.visit(*this);
}

TextureNode *AmbientOcclusionNode::normal_texture() const
{
    return normal_texture_;
}

TextureNode *AmbientOcclusionNode::position_texture() const
{
    return position_texture_;
}

AmbientOcclusionDescription AmbientOcclusionNode::description() const
{
    return description_;
}

std::size_t AmbientOcclusionNode::hash() const
{
    return combine_hash(colour_input_, "ambient_occlusion_node");
}

}

```

`src/graphics/render_graph/post_processing/anti_aliasing_node.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/render_graph/post_processing/anti_aliasing_node.h"

#include <cstddef>

#include "graphics/render_graph/shader_compiler.h"
#include "graphics/render_graph/texture_node.h"

namespace iris
{

AntiAliasingNode::AntiAliasingNode(TextureNode *input)
    : RenderNode()
{
    set_colour_input(input);
}

void AntiAliasingNode::accept(ShaderCompiler &compiler) const
{
    compiler.visit(*this);
}

std::size_t AntiAliasingNode::hash() const
{
    return combine_hash(colour_input_, "anti_aliasing_node");
}

}

```

`src/graphics/render_graph/post_processing/colour_adjust_node.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/render_graph/post_processing/colour_adjust_node.h"

#include <cstddef>

#include "graphics/post_processing_description.h"
#include "graphics/render_graph/shader_compiler.h"
#include "graphics/render_graph/texture_node.h"

namespace iris
{

ColourAdjustNode::ColourAdjustNode(TextureNode *input, ColourAdjustDescription description)
    : RenderNode()
    , description_(description)
{
    set_colour_input(input);
}

ColourAdjustDescription ColourAdjustNode::description() const
{
    return description_;
}

void ColourAdjustNode::accept(ShaderCompiler &compiler) const
{
    compiler.visit(*this);
}

std::size_t ColourAdjustNode::hash() const
{
    return combine_hash(colour_input_, description_.gamma, description_.tone_map_curve, "colour_adjust_node");
}

}

```

`src/graphics/render_graph/property.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/render_graph/property.h"

#include <array>
#include <cstddef>
#include <memory>
#include <string>

#include "core/error_handling.h"

namespace
{

/**
 * Helper function to write value into buffer.
 *
 * @param buffer
 *   Where to write value to.
 *
 * @param value
 *   Value to write.
 */
template <class T>
void do_set_value(std::byte *buffer, const T &value)
{
    // by convention the buffer always has a value - so destruct it first
    std::destroy_at(reinterpret_cast<T *>(buffer));

    // write the new value in via its copy constructor
    std::construct_at(reinterpret_cast<T *>(buffer), value);
}

}

namespace iris
{

Property::Property(const std::string &name, std::byte *buffer, float value)
    : name_(name)
    , type_(PropertyType::FLOAT)
    , buffer_(buffer)
{
    expect(buffer_ != nullptr, "must supply buffer for value");
    std::construct_at(reinterpret_cast<float *>(buffer_), value);
}

Property::~Property()
{
    // ensure correct destructor is called
    switch (type_)
    {
        using enum PropertyType;

        case FLOAT: std::destroy_at(reinterpret_cast<float *>(buffer_)); break;
        default: expect(false, "unknown property type");
    }
}

std::string Property::name() const
{
    return name_;
}

PropertyType Property::type() const
{
    return type_;
}

void Property::set_value(float value)
{
    do_set_value(buffer_, value);
}

}
```

`src/graphics/render_graph/property_node.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/render_graph/property_node.h"

#include <string>

#include "core/utils.h"
#include "graphics/render_graph/shader_compiler.h"

namespace iris
{

PropertyNode::PropertyNode(const std::string &name)
    : name_(name)
{
}

std::string PropertyNode::name() const
{
    return name_;
}

void PropertyNode::accept(ShaderCompiler &compiler) const
{
    compiler.visit(*this);
}

std::size_t PropertyNode::hash() const
{
    return combine_hash(name_, "property_node");
}

}

```

`src/graphics/render_graph/render_graph.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/render_graph/render_graph.h"

#include <memory>

#include "graphics/render_graph/node.h"
#include "graphics/render_graph/property.h"
#include "graphics/render_graph/render_node.h"

namespace iris
{

RenderGraph::RenderGraph(std::span<std::byte> property_buffer)
    : nodes_()
    , variables_()
    , properties_()
    , property_buffer_(property_buffer)
    , offset_(0u)
{
    nodes_.emplace_back(std::make_unique<RenderNode>());
}

RenderNode *RenderGraph::render_node() const
{
    return static_cast<RenderNode *>(nodes_.front().get());
}

Node *RenderGraph::add(std::unique_ptr<Node> node)
{
    nodes_.emplace_back(std::move(node));
    return nodes_.back().get();
}

std::vector<RenderGraphVariable> RenderGraph::variables() const
{
    return variables_;
}

const std::deque<Property> &RenderGraph::properties() const
{
    return properties_;
}

std::span<std::byte> RenderGraph::property_buffer() const
{
    return property_buffer_;
}

}

```

`src/graphics/render_graph/render_node.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/render_graph/render_node.h"

#include <cstddef>
#include <memory>

#include "graphics/render_graph/shader_compiler.h"

namespace iris
{

RenderNode::RenderNode()
    : colour_input_(nullptr)
    , specular_power_input_(nullptr)
    , specular_amount_input_(nullptr)
    , vertex_normal_input_(nullptr)
    , fragment_normal_input_(nullptr)
    , position_input_(nullptr)
    , shadow_map_input_(nullptr)
    , ambient_occlusion_input_(nullptr)
    , depth_only_(false)
{
}

void RenderNode::accept(ShaderCompiler &compiler) const
{
    compiler.visit(*this);
}

Node *RenderNode::colour_input() const
{
    return colour_input_;
}

void RenderNode::set_colour_input(Node *input)
{
    colour_input_ = input;
}

Node *RenderNode::specular_power_input() const
{
    return specular_power_input_;
}

void RenderNode::set_specular_power_input(Node *input)
{
    specular_power_input_ = input;
}

Node *RenderNode::specular_amount_input() const
{
    return specular_amount_input_;
}

void RenderNode::set_specular_amount_input(Node *input)
{
    specular_amount_input_ = input;
}

Node *RenderNode::vertex_normal_input() const
{
    return vertex_normal_input_;
}

void RenderNode::set_vertex_normal_input(Node *input)
{
    vertex_normal_input_ = input;
}

Node *RenderNode::fragment_normal_input() const
{
    return fragment_normal_input_;
}

void RenderNode::set_fragment_normal_input(Node *input)
{
    fragment_normal_input_ = input;
}

Node *RenderNode::position_input() const
{
    return position_input_;
}

void RenderNode::set_position_input(Node *input)
{
    position_input_ = input;
}

Node *RenderNode::shadow_map_input() const
{
    return shadow_map_input_;
}

void RenderNode::set_shadow_map_input(Node *input)
{
    shadow_map_input_ = input;
}

Node *RenderNode::ambient_occlusion_input() const
{
    return ambient_occlusion_input_;
}

void RenderNode::set_ambient_occlusion_input(Node *input)
{
    ambient_occlusion_input_ = input;
}

bool RenderNode::is_depth_only() const
{
    return depth_only_;
}

void RenderNode::set_depth_only(bool depth_only)
{
    depth_only_ = depth_only;
}

std::size_t RenderNode::hash() const
{
    return combine_hash(
        colour_input_,
        specular_amount_input_,
        vertex_normal_input_,
        fragment_normal_input_,
        position_input_,
        shadow_map_input_,
        ambient_occlusion_input_,
        depth_only_,
        "render_node");
}

}

```

`src/graphics/render_graph/shader_compiler.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/render_graph/shader_compiler.h"

#include <deque>
#include <iterator>
#include <sstream>
#include <string>

#include "inja/inja.hpp"

#include "glsl/glsl.h"
#include "hlsl/hlsl.h"
#include "msl/msl.h"

#include "core/colour.h"
#include "core/error_handling.h"
#include "core/exception.h"
#include "core/random.h"
#include "core/vector3.h"
#include "graphics/default_shader_languages.h"
#include "graphics/lights/lighting_rig.h"
#include "graphics/render_graph/binary_operator_node.h"
#include "graphics/render_graph/blur_node.h"
#include "graphics/render_graph/camera_node.h"
#include "graphics/render_graph/colour_node.h"
#include "graphics/render_graph/combine_node.h"
#include "graphics/render_graph/component_node.h"
#include "graphics/render_graph/composite_node.h"
#include "graphics/render_graph/conditional_node.h"
#include "graphics/render_graph/fragment_node.h"
#include "graphics/render_graph/invert_node.h"
#include "graphics/render_graph/lerp_node.h"
#include "graphics/render_graph/post_processing/ambient_occlusion_node.h"
#include "graphics/render_graph/post_processing/anti_aliasing_node.h"
#include "graphics/render_graph/post_processing/colour_adjust_node.h"
#include "graphics/render_graph/property.h"
#include "graphics/render_graph/property_node.h"
#include "graphics/render_graph/render_node.h"
#include "graphics/render_graph/sky_box_node.h"
#include "graphics/render_graph/texture_node.h"
#include "graphics/render_graph/time_node.h"
#include "graphics/render_graph/unary_operator_node.h"
#include "graphics/render_graph/value_node.h"
#include "graphics/render_graph/variable_node.h"
#include "graphics/render_graph/vertex_node.h"
#include "graphics/sampler.h"
#include "graphics/texture.h"
#include "graphics/texture_manager.h"

namespace
{

/**
 * Return a shader language specific string.
 *
 * @param language
 *   The language to get string for.
 *
 * @param hlsl
 *   HLSL compiler string.
 *
 * @param glsl
 *   GLSL compiler string.
 *
 * @param metal
 *   Metal compiler string.
 *
 * @returns
 *   Language specific string.
 */
std::string language_string(
    iris::ShaderLanguage language,
    const std::string &hlsl_str,
    const std::string &glsl_str,
    const std::string &metal_str)
{
    switch (language)
    {
        case iris::ShaderLanguage::HLSL: return hlsl_str; break;
        case iris::ShaderLanguage::GLSL: return glsl_str; break;
        case iris::ShaderLanguage::MSL: return metal_str; break;
        default: throw iris::Exception("unsupported shader language");
    }
}

/**
 * Helper function to build a string declaring all properties.
 *
 * @param properties
 *   Properties to build string for.
 *
 * @param env
 *   inja environment.
 *
 * @param language
 *   The shader language to build the string in.
 *
 * @returns
 *   Language specific string for declaring properties.
 */
std::string build_properties_string(
    const std::deque<iris::Property> &properties,
    inja::Environment &env,
    iris::ShaderLanguage language)
{
    ::inja::json args{{"properties", std::vector<std::tuple<std::string, std::uint32_t>>{}}};

    for (const auto &property : properties)
    {
        args["properties"].push_back({property.name(), static_cast<std::uint32_t>(property.type())});
    }

    return env.render(
        language_string(
            language,
            iris::hlsl::declare_property_chunk,
            iris::glsl::declare_property_chunk,
            iris::msl::declare_property_chunk),
        args);
}

}

namespace iris
{

ShaderCompiler::ShaderCompiler(
    ShaderLanguage language,
    const RenderGraph *render_graph,
    LightType light_type,
    bool render_to_normal_target,
    bool render_to_position_target)
    : language_(language)
    , vertex_stream_()
    , fragment_stream_()
    , fragment_functions_()
    , light_type_(light_type)
    , render_to_normal_target_(render_to_normal_target)
    , render_to_position_target_(render_to_position_target)
    , is_vertex_shader_(true)
    , variables_()
    , env_(std::make_unique<inja::Environment>())
    , render_graph_(render_graph)
{
    env_->set_trim_blocks(true);
    env_->set_lstrip_blocks(true);

    // evaluate and store all variables from the render graph
    for (const auto &[name, type, value, is_declaration] : render_graph->variables())
    {
        ::inja::json args{{"name", name}, {"type", static_cast<std::uint32_t>(type)}};

        stream_stack_.push(std::stringstream{});
        value->accept(*this);
        args["value"] = stream_stack_.top().str();
        stream_stack_.pop();

        const auto parsed_value =
            is_declaration
                ? env_->render(
                      language_string(
                          language_,
                          hlsl::declare_variable_chunk,
                          glsl::declare_variable_chunk,
                          msl::declare_variable_chunk),
                      args)
                : env_->render(
                      language_string(
                          language_, hlsl::set_variable_chunk, glsl::set_variable_chunk, msl::set_variable_chunk),
                      args);

        variables_.push_back({.name = name, .value = parsed_value});
    }

    render_graph->render_node()->accept(*this);
}

ShaderCompiler::~ShaderCompiler() = default;

void ShaderCompiler::visit(const RenderNode &node)
{
    // build vertex shader

    ::inja::json vertex_args{
        {"is_directional_light", light_type_ == LightType::DIRECTIONAL},
        {"is_vertex_shader", true},
        {"variables", std::vector<std::string>{}}};

    if (node.position_input() != nullptr)
    {
        stream_stack_.push(std::stringstream{});
        node.position_input()->accept(*this);
        vertex_args["position"] = stream_stack_.top().str();
        stream_stack_.pop();
    }

    if (node.vertex_normal_input() != nullptr)
    {
        stream_stack_.push(std::stringstream{});
        node.vertex_normal_input()->accept(*this);
        vertex_args["normal"] = stream_stack_.top().str();
        stream_stack_.pop();
    }

    // add any used variables
    for (const auto &[_1, value, vertex_count, _2] : variables_)
    {
        if (vertex_count > 0u)
        {
            vertex_args["variables"].push_back(value);
        }
    }

    vertex_stream_ << env_->render(
        language_string(language_, hlsl::render_node_vertex, glsl::render_node_vertex, msl::render_node_vertex),
        vertex_args);

    // build fragment shader

    is_vertex_shader_ = false;

    fragment_functions_.emplace(
        language_string(language_, hlsl::shadow_function, glsl::shadow_function, msl::shadow_function));

    ::inja::json fragment_args{
        {"properties", build_properties_string(render_graph_->properties(), *env_, language_)},
        {"render_normal", render_to_normal_target_},
        {"render_position", render_to_position_target_},
        {"light_type", static_cast<std::uint32_t>(light_type_)},
        {"variables", std::vector<std::string>{}}};

    if (node.colour_input() != nullptr)
    {
        stream_stack_.push(std::stringstream{});
        node.colour_input()->accept(*this);
        fragment_args["fragment_colour"] = stream_stack_.top().str();
        stream_stack_.pop();
    }

    if (node.fragment_normal_input() != nullptr)
    {
        stream_stack_.push(std::stringstream{});
        node.fragment_normal_input()->accept(*this);
        fragment_args["normal"] = stream_stack_.top().str();
        stream_stack_.pop();
    }

    if (node.ambient_occlusion_input() != nullptr)
    {
        stream_stack_.push(std::stringstream{});
        node.ambient_occlusion_input()->accept(*this);
        fragment_args["ambient_input"] = stream_stack_.top().str();
        stream_stack_.pop();
    }

    // add any used variables
    for (const auto &[_1, value, _2, fragment_count] : variables_)
    {
        if (fragment_count > 0u)
        {
            fragment_args["variables"].push_back(value);
        }
    }

    fragment_stream_ << env_->render(
        language_string(language_, hlsl::render_node_fragment, glsl::render_node_fragment, msl::render_node_fragment),
        fragment_args);
}

void ShaderCompiler::visit(const SkyBoxNode &node)
{
    // build vertex shader

    const ::inja::json vertex_args;
    vertex_stream_ << env_->render(
        language_string(language_, hlsl::sky_box_node_vertex, glsl::sky_box_node_vertex, msl::sky_box_node_vertex),
        vertex_args);

    // build fragment shader

    fragment_functions_.emplace(
        language_string(language_, hlsl::shadow_function, glsl::shadow_function, msl::shadow_function));

    const ::inja::json fragment_args{
        {"cube_map_index", node.sky_box()->index()}, {"sampler_index", node.sky_box()->sampler()->index()}};

    fragment_stream_ << env_->render(
        language_string(
            language_, hlsl::sky_box_node_fragment, glsl::sky_box_node_fragment, msl::sky_box_node_fragment),
        fragment_args);
}

void ShaderCompiler::visit(const ColourNode &node)
{
    const auto colour = node.colour();

    const ::inja::json args{
        {"is_vertex_shader", is_vertex_shader_}, {"r", colour.r}, {"g", colour.g}, {"b", colour.b}, {"a", colour.a}};

    stream_stack_.top() << env_->render(
        language_string(language_, hlsl::colour_node_chunk, glsl::colour_node_chunk, msl::colour_node_chunk), args);
}

void ShaderCompiler::visit(const TextureNode &node)
{
    std::string tex_coord;
    if (node.uv_input() != nullptr)
    {
        stream_stack_.push(std::stringstream{});
        node.uv_input()->accept(*this);
        tex_coord = stream_stack_.top().str();
        stream_stack_.pop();
    }

    const ::inja::json args{
        {"is_vertex_shader", is_vertex_shader_},
        {"uv_source", static_cast<std::uint32_t>(node.uv_source())},
        {"texture_index", node.texture()->index()},
        {"sampler_index", node.texture()->sampler()->index()},
        {"reciprocal_width", 1.0f / node.texture()->width()},
        {"reciprocal_height", 1.0f / node.texture()->height()},
        {"tex_coord", tex_coord}};

    stream_stack_.top() << env_->render(
        language_string(language_, hlsl::texture_node_chunk, glsl::texture_node_chunk, msl::texture_node_chunk), args);
}

void ShaderCompiler::visit(const InvertNode &node)
{
    fragment_functions_.emplace(
        language_string(language_, hlsl::invert_function, glsl::invert_function, msl::invert_function));

    stream_stack_.push(std::stringstream{});
    node.input_node()->accept(*this);

    const ::inja::json args{{"is_vertex_shader", is_vertex_shader_}, {"input", stream_stack_.top().str()}};

    stream_stack_.pop();
    stream_stack_.top() << env_->render(
        language_string(language_, hlsl::invert_node_chunk, glsl::invert_node_chunk, msl::invert_node_chunk), args);
}

void ShaderCompiler::visit(const BlurNode &node)
{
    fragment_functions_.emplace(
        language_string(language_, hlsl::blur_function, glsl::blur_function, msl::blur_function));

    const ::inja::json args{
        {"is_vertex_shader", is_vertex_shader_},
        {"texture_index", node.input_node()->texture()->index()},
        {"sampler_index", node.input_node()->texture()->sampler()->index()}};

    stream_stack_.top() << env_->render(
        language_string(language_, hlsl::blur_node_chunk, glsl::blur_node_chunk, msl::blur_node_chunk), args);
}

void ShaderCompiler::visit(const CompositeNode &node)
{
    fragment_functions_.emplace(
        language_string(language_, hlsl::composite_function, glsl::composite_function, msl::composite_function));

    std::array<Node *, 4u> nodes{{node.colour1(), node.colour2(), node.depth1(), node.depth2()}};
    std::array<std::string, 4u> node_strs{};

    for (auto i = 0u; i < nodes.size(); ++i)
    {
        stream_stack_.push(std::stringstream{});
        nodes[i]->accept(*this);
        node_strs[i] = stream_stack_.top().str();
        stream_stack_.pop();
    }

    const ::inja::json args{
        {"is_vertex_shader", is_vertex_shader_},
        {"colour1", node_strs[0]},
        {"colour2", node_strs[1]},
        {"depth1", node_strs[2]},
        {"depth2", node_strs[3]}};

    stream_stack_.top() << env_->render(
        language_string(language_, hlsl::composite_node_chunk, glsl::composite_node_chunk, msl::composite_node_chunk),
        args);
}

void ShaderCompiler::visit(const ValueNode<float> &node)
{
    const ::inja::json args{{"is_vertex_shader", is_vertex_shader_}, {"value", node.value()}};
    stream_stack_.top() << env_->render(
        language_string(
            language_, hlsl::value_node_float_chunk, glsl::value_node_float_chunk, msl::value_node_float_chunk),
        args);
}

void ShaderCompiler::visit(const ValueNode<Vector3> &node)
{
    const auto value = node.value();

    const ::inja::json args{{"is_vertex_shader", is_vertex_shader_}, {"x", value.x}, {"y", value.y}, {"z", value.z}};
    stream_stack_.top() << env_->render(
        language_string(
            language_, hlsl::value_node_vector3_chunk, glsl::value_node_vector3_chunk, msl::value_node_vector3_chunk),
        args);
}

void ShaderCompiler::visit(const ValueNode<Colour> &node)
{
    const auto value = node.value();

    const ::inja::json args{
        {"is_vertex_shader", is_vertex_shader_}, {"r", value.r}, {"g", value.g}, {"b", value.b}, {"a", value.a}};
    stream_stack_.top() << env_->render(
        language_string(
            language_, hlsl::value_node_colour_chunk, glsl::value_node_colour_chunk, msl::value_node_colour_chunk),
        args);
}

void ShaderCompiler::visit(const BinaryOperatorNode &node)
{
    std::array<Node *, 2u> nodes{{node.value1(), node.value2()}};
    std::array<std::string, 2u> node_strs{};

    for (auto i = 0u; i < nodes.size(); ++i)
    {
        stream_stack_.push(std::stringstream{});
        nodes[i]->accept(*this);
        node_strs[i] = stream_stack_.top().str();
        stream_stack_.pop();
    }

    const ::inja::json args{
        {"is_vertex_shader", is_vertex_shader_},
        {"operator", static_cast<std::uint32_t>(node.binary_operator())},
        {"value1", node_strs[0]},
        {"value2", node_strs[1]}};

    stream_stack_.top() << env_->render(
        language_string(
            language_,
            hlsl::binary_operator_node_chunk,
            glsl::binary_operator_node_chunk,
            msl::binary_operator_node_chunk),
        args);
}

void ShaderCompiler::visit(const ConditionalNode &node)
{
    std::array<Node *, 4u> nodes{
        {node.input_value1(), node.input_value2(), node.output_value1(), node.output_value2()}};
    std::array<std::string, 4u> node_strs{};

    for (auto i = 0u; i < nodes.size(); ++i)
    {
        stream_stack_.push(std::stringstream{});
        nodes[i]->accept(*this);
        node_strs[i] = stream_stack_.top().str();
        stream_stack_.pop();
    }

    std::string op{};
    switch (node.conditional_operator())
    {
        using enum ConditionalOperator;
        case GREATER: op = ">"; break;
        case LESS: op = "<"; break;
    }

    const ::inja::json args{
        {"is_vertex_shader", is_vertex_shader_},
        {"input1", node_strs[0]},
        {"input2", node_strs[1]},
        {"output1", node_strs[2]},
        {"output2", node_strs[3]},
        {"operator", op}};

    stream_stack_.top() << env_->render(
        language_string(
            language_, hlsl::conditional_node_chunk, glsl::conditional_node_chunk, msl::conditional_node_chunk),
        args);
}

void ShaderCompiler::visit(const ComponentNode &node)
{
    stream_stack_.push(std::stringstream{});
    node.input_node()->accept(*this);
    const auto value = stream_stack_.top().str();
    stream_stack_.pop();

    const ::inja::json args{{"is_vertex_shader", is_vertex_shader_}, {"value", value}, {"component", node.component()}};

    stream_stack_.top() << env_->render(
        language_string(language_, hlsl::component_node_chunk, glsl::component_node_chunk, msl::component_node_chunk),
        args);
}

void ShaderCompiler::visit(const CombineNode &node)
{
    std::array<Node *, 4u> nodes{{node.value1(), node.value2(), node.value3(), node.value4()}};
    std::array<std::string, 4u> node_strs{};

    for (auto i = 0u; i < nodes.size(); ++i)
    {
        stream_stack_.push(std::stringstream{});
        nodes[i]->accept(*this);
        node_strs[i] = stream_stack_.top().str();
        stream_stack_.pop();
    }

    const ::inja::json args{
        {"is_vertex_shader", is_vertex_shader_},
        {"x", node_strs[0]},
        {"y", node_strs[1]},
        {"z", node_strs[2]},
        {"w", node_strs[3]}};

    stream_stack_.top() << env_->render(
        language_string(language_, hlsl::combine_node_chunk, glsl::combine_node_chunk, msl::combine_node_chunk), args);
}

void ShaderCompiler::visit(const UnaryOperatorNode &node)
{
    stream_stack_.push(std::stringstream{});
    node.input_node()->accept(*this);
    const auto value = stream_stack_.top().str();
    stream_stack_.pop();

    const ::inja::json args{
        {"is_vertex_shader", is_vertex_shader_},
        {"type", static_cast<std::uint32_t>(node.unary_operator())},
        {"value", value}};

    stream_stack_.top() << env_->render(
        language_string(
            language_, hlsl::unary_operator_node_chunk, glsl::sin_node_chunk, msl::unary_operator_node_chunk),
        args);
}

void ShaderCompiler::visit(const VertexNode &node)
{
    const ::inja::json args{
        {"is_vertex_shader", is_vertex_shader_},
        {"type", static_cast<std::uint32_t>(node.vertex_data_type())},
        {"swizzle", node.swizzle().value_or("")}};

    stream_stack_.top() << env_->render(
        language_string(language_, hlsl::vertex_node_chunk, glsl::vertex_node_chunk, msl::vertex_node_chunk), args);
}

void ShaderCompiler::visit(const AmbientOcclusionNode &node)
{
    // build vertex shader

    ::inja::json vertex_args;
    vertex_stream_ << env_->render(
        language_string(
            language_,
            hlsl::ambient_occlusion_node_vertex,
            glsl::ambient_occlusion_node_vertex,
            msl::ambient_occlusion_node_vertex),
        vertex_args);

    // build fragment shader

    const auto *input_texture = static_cast<const TextureNode *>(node.colour_input())->texture();

    stream_stack_.push(std::stringstream{});
    std::string fragment_colour;
    if (node.colour_input() == nullptr)
    {
        fragment_colour = "input.colour";
    }
    else
    {
        node.colour_input()->accept(*this);
        fragment_colour = stream_stack_.top().str();
    }

    const ::inja::json fragment_args{
        {"fragment_colour", fragment_colour},
        {"width", input_texture->width()},
        {"height", input_texture->height()},
        {"position_texture_index", node.position_texture()->texture()->index()},
        {"position_sampler_index", node.position_texture()->texture()->sampler()->index()},
        {"normal_texture_index", node.normal_texture()->texture()->index()},
        {"normal_sampler_index", node.normal_texture()->texture()->sampler()->index()},
        {"sample_count", node.description().sample_count},
        {"radius", node.description().radius},
        {"bias", node.description().bias}};

    fragment_stream_ << env_->render(
        language_string(
            language_,
            hlsl::ambient_occlusion_node_fragment,
            glsl::ambient_occlusion_node_fragment,
            msl::ambient_occlusion_node_fragment),
        fragment_args);
}

void ShaderCompiler::visit(const ColourAdjustNode &node)
{
    // build vertex shader

    ::inja::json vertex_args;
    vertex_stream_ << env_->render(
        language_string(
            language_,
            hlsl::colour_adjust_node_vertex,
            glsl::colour_adjust_node_vertex,
            msl::colour_adjust_node_vertex),
        vertex_args);

    // build fragment shader

    stream_stack_.push(std::stringstream{});
    std::string fragment_colour;
    if (node.colour_input() == nullptr)
    {
        fragment_colour = "input.colour";
    }
    else
    {
        node.colour_input()->accept(*this);
        fragment_colour = stream_stack_.top().str();
    }

    const ::inja::json fragment_args{{"fragment_colour", fragment_colour}, {"gamma", 1.0f / node.description().gamma}};
    fragment_stream_ << env_->render(
        language_string(
            language_,
            hlsl::colour_adjust_node_fragment,
            glsl::colour_adjust_node_fragment,
            msl::colour_adjust_node_fragment),
        fragment_args);
}

void ShaderCompiler::visit(const AntiAliasingNode &node)
{
    // build vertex shader

    ::inja::json vertex_args;
    vertex_stream_ << env_->render(
        language_string(
            language_,
            hlsl::anti_aliasing_node_vertex,
            glsl::anti_aliasing_node_vertex,
            msl::anti_aliasing_node_vertex),
        vertex_args);

    // build fragment shader

    const auto *input_texture = static_cast<const TextureNode *>(node.colour_input())->texture();

    fragment_functions_.emplace(
        language_string(language_, hlsl::rgb_to_luma_function, glsl::rgb_to_luma_function, msl::rgb_to_luma_function));

    stream_stack_.push(std::stringstream{});
    std::string fragment_colour;
    if (node.colour_input() == nullptr)
    {
        fragment_colour = "input.colour";
    }
    else
    {
        node.colour_input()->accept(*this);
        fragment_colour = stream_stack_.top().str();
    }

    const ::inja::json fragment_args{
        {"fragment_colour", fragment_colour},
        {"input_texture_index", input_texture->index()},
        {"input_sampler_index", input_texture->sampler()->index()},
        {"inverse_width", 1.0f / static_cast<float>(input_texture->width())},
        {"inverse_height", 1.0f / static_cast<float>(input_texture->height())}};

    fragment_stream_ << env_->render(
        language_string(
            language_,
            hlsl::anti_aliasing_node_fragment,
            glsl::anti_aliasing_node_fragment,
            msl::anti_aliasing_node_fragment),
        fragment_args);
}

void ShaderCompiler::visit(const TimeNode &)
{
    stream_stack_.top() << language_string(
        language_, hlsl::time_node_chunk, glsl::time_node_chunk, msl::time_node_chunk);
}

void ShaderCompiler::visit(const VariableNode &node)
{
    auto found = false;
    for (auto &variable : variables_)
    {
        if (variable.name == node.name())
        {
            found = true;

            if (is_vertex_shader_)
            {
                ++variable.vertex_count;
            }
            else
            {
                ++variable.fragment_count;
            }
        }
    }
    ensure(found, "variable node declared");

    const ::inja::json args{{"is_vertex_shader", is_vertex_shader_}, {"name", node.name()}};

    stream_stack_.top() << env_->render(
        language_string(language_, hlsl::variable_node_chunk, glsl::variable_node_chunk, msl::variable_node_chunk),
        args);
}

void ShaderCompiler::visit(const LerpNode &node)
{
    std::array<Node *, 3u> nodes{{node.input_value1(), node.input_value2(), node.lerp_amount()}};
    std::array<std::string, 3u> node_strs{};

    for (auto i = 0u; i < nodes.size(); ++i)
    {
        stream_stack_.push(std::stringstream{});
        nodes[i]->accept(*this);
        node_strs[i] = stream_stack_.top().str();
        stream_stack_.pop();
    }

    const ::inja::json args{
        {"is_vertex_shader", is_vertex_shader_},
        {"input1", node_strs[0]},
        {"input2", node_strs[1]},
        {"lerp_amount", node_strs[2]}};

    stream_stack_.top() << env_->render(
        language_string(language_, hlsl::lerp_node_chunk, glsl::lerp_node_chunk, msl::lerp_node_chunk), args);
}

void ShaderCompiler::visit(const PropertyNode &node)
{
    const ::inja::json args{{"is_vertex_shader", is_vertex_shader_}, {"name", "property_" + node.name()}};

    stream_stack_.top() << env_->render(
        language_string(language_, hlsl::property_chunk, glsl::property_chunk, msl::property_chunk), args);
}

void ShaderCompiler::visit(const FragmentNode &node)
{
    const ::inja::json args{
        {"is_vertex_shader", is_vertex_shader_},
        {"type", static_cast<std::uint32_t>(node.fragment_data_type())},
        {"swizzle", node.swizzle().value_or("")}};

    stream_stack_.top() << env_->render(
        language_string(language_, hlsl::fragment_node_chunk, glsl::fragment_node_chunk, msl::fragment_node_chunk),
        args);
}

void ShaderCompiler::visit(const CameraNode &node)
{
    const ::inja::json args{
        {"is_vertex_shader", is_vertex_shader_},
        {"type", static_cast<std::uint32_t>(node.camera_data_type())},
        {"swizzle", node.swizzle().value_or("")}};

    stream_stack_.top() << env_->render(
        language_string(language_, hlsl::camera_node_chunk, glsl::camera_node_chunk, msl::camera_node_chunk), args);
}

std::string ShaderCompiler::vertex_shader() const
{
    std::stringstream strm{};

    if (language_ == ShaderLanguage::GLSL)
    {
        strm << R"(
#version 430 core
precision mediump float;
#extension GL_ARB_bindless_texture : require
        )";
    }

    strm << vertex_stream_.str() << '\n';

    return strm.str();
}

std::string ShaderCompiler::fragment_shader() const
{
    std::stringstream strm{};

    if (language_ == ShaderLanguage::GLSL)
    {
        strm << R"(
#version 430 core
precision mediump float;
#extension GL_ARB_bindless_texture : require
        )";
    }

    for (const auto &function : fragment_functions_)
    {
        strm << function << '\n';
    }

    strm << fragment_stream_.str() << '\n';

    return strm.str();
}
}

```

`src/graphics/render_graph/sky_box_node.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/render_graph/sky_box_node.h"

#include <cstddef>

#include "graphics/cube_map.h"
#include "graphics/render_graph/shader_compiler.h"

namespace iris
{

SkyBoxNode::SkyBoxNode(const CubeMap *sky_box)
    : RenderNode()
    , sky_box_(sky_box)
{
}

void SkyBoxNode::accept(ShaderCompiler &compiler) const
{
    compiler.visit(*this);
}

const CubeMap *SkyBoxNode::sky_box() const
{
    return sky_box_;
}

std::size_t SkyBoxNode::hash() const
{
    return combine_hash(reinterpret_cast<std::ptrdiff_t>(sky_box_), "sky_box_node");
}

}

```

`src/graphics/render_graph/texture_node.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/render_graph/texture_node.h"

#include <cstddef>

#include "core/error_handling.h"
#include "graphics/render_graph/shader_compiler.h"
#include "graphics/texture.h"

namespace iris
{

TextureNode::TextureNode(const Texture *texture, UVSource uv_source, const Node *uv_input)
    : texture_(texture)
    , uv_source_(uv_source)
    , uv_input_(uv_input)
{
    ensure(
        (uv_source_ == UVSource::NODE && uv_input_ != nullptr) ||
            (uv_source_ != UVSource::NODE && uv_input_ == nullptr),
        "invalid configuration");
}

void TextureNode::accept(ShaderCompiler &compiler) const
{
    compiler.visit(*this);
}

const Texture *TextureNode::texture() const
{
    return texture_;
}

UVSource TextureNode::uv_source() const
{
    return uv_source_;
}

const Node *TextureNode::uv_input() const
{
    return uv_input_;
}

std::size_t TextureNode::hash() const
{
    return combine_hash(reinterpret_cast<std::ptrdiff_t>(texture_), uv_source_, uv_input_, "texture_node");
}

}

```

`src/graphics/render_graph/time_node.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/render_graph/time_node.h"

#include <functional>
#include <string_view>

#include "graphics/render_graph/shader_compiler.h"

using namespace std::literals;

namespace iris
{

void TimeNode::accept(ShaderCompiler &compiler) const
{
    compiler.visit(*this);
}

std::size_t TimeNode::hash() const
{
    return std::hash<std::string_view>{}("time_node"sv);
}

}

```

`src/graphics/render_graph/unary_operator_node.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/render_graph/unary_operator_node.h"

#include <cstddef>
#include <memory>

#include "graphics/render_graph/shader_compiler.h"

namespace iris
{

UnaryOperatorNode::UnaryOperatorNode(Node *input_node, UnaryOperator unary_operator)
    : input_node_(input_node)
    , unary_operator_(unary_operator)
{
}

void UnaryOperatorNode::accept(ShaderCompiler &compiler) const
{
    compiler.visit(*this);
}

Node *UnaryOperatorNode::input_node() const
{
    return input_node_;
}

UnaryOperator UnaryOperatorNode::unary_operator() const
{
    return unary_operator_;
}

std::size_t UnaryOperatorNode::hash() const
{
    return combine_hash(input_node_, unary_operator_, "unary_operator_node");
}

}

```

`src/graphics/render_graph/variable_node.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/render_graph/variable_node.h"

#include <cstddef>
#include <memory>
#include <string>

#include "core/utils.h"
#include "graphics/render_graph/shader_compiler.h"

namespace iris
{

VariableNode::VariableNode(const std::string &name)
    : name_(name)
{
}

std::string VariableNode::name() const
{
    return name_;
}

void VariableNode::accept(ShaderCompiler &compiler) const
{
    compiler.visit(*this);
}

std::size_t VariableNode::hash() const
{
    return combine_hash(name_, "variable_node");
}

}

```

`src/graphics/render_graph/vertex_node.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/render_graph/vertex_node.h"

#include <cstddef>
#include <functional>
#include <optional>
#include <string>
#include <string_view>

#include "core/utils.h"
#include "graphics/render_graph/node.h"
#include "graphics/render_graph/shader_compiler.h"

namespace iris
{

VertexNode::VertexNode(VertexDataType vertex_data_type)
    : vertex_data_type_(vertex_data_type)
    , swizzle_(std::nullopt)
{
}

VertexNode::VertexNode(VertexDataType vertex_data_type, std::string_view swizzle)
    : vertex_data_type_(vertex_data_type)
    , swizzle_(swizzle)
{
}

void VertexNode::accept(ShaderCompiler &compiler) const
{
    compiler.visit(*this);
}

VertexDataType VertexNode::vertex_data_type() const
{
    return vertex_data_type_;
}

std::optional<std::string> VertexNode::swizzle() const
{
    return swizzle_;
}

std::size_t VertexNode::hash() const
{
    return combine_hash(vertex_data_type_, swizzle_, "vertex_node");
}

}

```

`src/graphics/render_pipeline.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/render_pipeline.h"

#include <cstddef>
#include <memory>
#include <vector>

#include "core/error_handling.h"
#include "graphics/material_manager.h"
#include "graphics/mesh_manager.h"
#include "graphics/render_graph/binary_operator_node.h"
#include "graphics/render_graph/blur_node.h"
#include "graphics/render_graph/component_node.h"
#include "graphics/render_graph/conditional_node.h"
#include "graphics/render_graph/node.h"
#include "graphics/render_graph/post_processing/ambient_occlusion_node.h"
#include "graphics/render_graph/post_processing/anti_aliasing_node.h"
#include "graphics/render_graph/post_processing/colour_adjust_node.h"
#include "graphics/render_graph/render_graph.h"
#include "graphics/render_graph/sky_box_node.h"
#include "graphics/render_graph/texture_node.h"
#include "graphics/render_graph/value_node.h"
#include "graphics/render_pass.h"
#include "graphics/render_pipeline.h"
#include "graphics/render_target.h"
#include "graphics/render_target_manager.h"
#include "graphics/renderer.h"
#include "graphics/scene.h"
#include "graphics/single_entity.h"
#include "log/log.h"

namespace
{

/**
 * Helper function to create and enqueue all commands for rendering a Scene with
 * a given light type.
 *
 * @param scene
 *   Scene to render.
 *
 * @param light_type
 *   Type of light for the scene.
 *
 * @param has_normal_target
 *   Flag indicating if normals should be rendered.
 *
 * @param has_position_target
 *   Flag indicating if positions should be rendered.
 *
 * @param sky_box_render_graph
 *   Render graph for the sky box for this scene (if one is present), otherwise nullptr.
 *
 * @param cmd
 *   Command object to mutate and enqueue, this is passed in so it can be "pre-loaded" with the correct state.
 *
 * @param render_queue
 *   Queue to add render commands to.
 *
 * @param shadow_maps
 *   Map of directional lights to their associated shadow map render target.
 */
void encode_light_pass_commands(
    iris::MaterialManager &material_manager,
    const iris::Scene *scene,
    iris::LightType light_type,
    bool has_normal_target,
    bool has_position_target,
    const iris::RenderGraph *sky_box_render_graph,
    iris::RenderCommand &cmd,
    std::vector<iris::RenderCommand> &render_queue,
    const std::unordered_map<iris::DirectionalLight *, iris::RenderTarget *> &shadow_maps)
{
    for (const auto &[render_graph, render_entity] : scene->entities())
    {
        // if we have a sky box we only want to render it once on the ambient pass
        if ((render_graph == sky_box_render_graph) && (light_type != iris::LightType::AMBIENT))
        {
            continue;
        }

        auto *material = material_manager.create(
            render_graph,
            render_entity.get(),
            light_type,
            cmd.render_pass()->colour_target != nullptr,
            has_normal_target && (light_type == iris::LightType::AMBIENT),
            has_position_target && (light_type == iris::LightType::AMBIENT),
            render_entity->has_transparency());
        cmd.set_material(material);

        cmd.set_render_entity(render_entity.get());

        // light specific draw commands
        switch (light_type)
        {
            case iris::LightType::AMBIENT:
                cmd.set_type(iris::RenderCommandType::DRAW);
                cmd.set_light(scene->lighting_rig()->ambient_light.get());
                render_queue.push_back(cmd);
                break;
            case iris::LightType::POINT:
                // a draw command for each light
                for (auto &light : scene->lighting_rig()->point_lights)
                {
                    cmd.set_type(iris::RenderCommandType::DRAW);
                    cmd.set_light(light.get());
                    render_queue.push_back(cmd);
                }
                break;
            case iris::LightType::DIRECTIONAL:
                // a draw command for each light
                for (auto &light : scene->lighting_rig()->directional_lights)
                {
                    cmd.set_type(iris::RenderCommandType::DRAW);
                    cmd.set_light(light.get());

                    // set shadow map in render command
                    if (render_entity->receive_shadow())
                    {
                        auto *shadow_map = shadow_maps.count(light.get()) == 0u ? nullptr : shadow_maps.at(light.get());
                        cmd.set_shadow_map(shadow_map);
                    }

                    render_queue.push_back(cmd);
                }
                break;
        }
    }
}
}

namespace iris
{

RenderPipeline::RenderPipeline(
    MaterialManager &material_manager,
    MeshManager &mesh_manager,
    RenderTargetManager &render_target_manager,
    std::uint32_t width,
    std::uint32_t height)
    : material_manager_(material_manager)
    , mesh_manager_(mesh_manager)
    , render_target_manager_(render_target_manager)
    , scenes_()
    , render_graphs_()
    , user_created_passes_()
    , engine_created_passes_()
    , render_passes_()
    , sky_box_entities_()
    , dirty_(false)
    , width_(width)
    , height_(height)
    , cameras_()
    , shadow_maps_()
{
}

RenderPipeline::~RenderPipeline() = default;

Scene *RenderPipeline::create_scene()
{
    static RenderGraph default_render_graph{material_manager_.create_property_buffer()};

    // using new to access private ctor
    scenes_.push_back(std::unique_ptr<Scene>(new Scene{&default_render_graph, &dirty_}));

    return scenes_.back().get();
}

RenderGraph *RenderPipeline::create_render_graph()
{
    // using new to access private ctor
    render_graphs_.push_back(std::unique_ptr<RenderGraph>(new RenderGraph{material_manager_.create_property_buffer()}));

    return render_graphs_.back().get();
}

RenderPass *RenderPipeline::create_render_pass(Scene *scene)
{
    // using new to access private ctor
    auto pass = std::unique_ptr<RenderPass>(new RenderPass{});
    pass->scene = scene;

    user_created_passes_.push_back(std::move(pass));

    return user_created_passes_.back().get();
}

std::vector<RenderCommand> RenderPipeline::build()
{
    engine_created_passes_.clear();
    sky_box_entities_.clear();
    shadow_maps_.clear();
    std::vector<RenderPass *> pre_process_passes{};

    // for each shadow casting light create a render target for the shadow map
    // and enqueue commands so they are rendered
    for (const auto &pass : user_created_passes_)
    {
        for (const auto &light : pass->scene->lighting_rig()->directional_lights)
        {
            if (light->casts_shadows())
            {
                auto *rt = render_target_manager_.create(1024u, 1024u);
                RenderPass *shadow_pass = create_engine_render_pass(pass->scene);
                shadow_pass->post_processing_description = {};
                shadow_pass->camera = std::addressof(light->shadow_camera());
                shadow_pass->colour_target = rt;
                shadow_pass->normal_target = nullptr;
                shadow_pass->position_target = nullptr;
                shadow_pass->depth_only = true;
                shadow_pass->clear_colour = true;
                shadow_pass->clear_depth = true;

                pre_process_passes.push_back(shadow_pass);

                shadow_maps_[light.get()] = rt;
            }
        }

        // SSAO is a bit messy to integrate, we first need to create a pass to output all the required information
        // such as screen space normals and positions and then add the pass to combine all this data into our
        // occlusion texture later on we will then wire this into the normal lighting passes, due to how the render
        // is setup it's not easy to just add the occlusion texture into the ambient light pass, so instead we do
        // that whole calculation in the SSAO pass and use that instead of recalculating the ambient pass
        if (const auto ssao = pass->post_processing_description.ambient_occlusion; ssao)
        {
            // add a pass to output the data we need
            RenderPass *ao_data_pass = create_engine_render_pass(pass->scene);
            ao_data_pass->post_processing_description = {};
            ao_data_pass->colour_target = nullptr;
            ao_data_pass->normal_target = render_target_manager_.create(width_, height_);
            ao_data_pass->position_target = render_target_manager_.create(width_, height_);
            ao_data_pass->depth_only = true;
            ao_data_pass->clear_colour = true;
            ao_data_pass->camera = pass->camera;

            pre_process_passes.push_back(ao_data_pass);
            auto *prev = pre_process_passes.back();

            const auto prev_camera = prev->camera;

            // add a pass to calculate ssao (combined with the ambient light pass)
            auto *ao_target = add_pass(pre_process_passes, [prev, ssao](RenderGraph *rg, const RenderTarget *target) {
                rg->set_render_node<AmbientOcclusionNode>(
                    rg->create<TextureNode>(target->colour_texture()),
                    rg->create<TextureNode>(prev->normal_target->colour_texture()),
                    rg->create<TextureNode>(prev->position_target->colour_texture()),
                    *ssao);
            });

            // ensure we render with the perspective camera not the orthographic camera that will be created for the
            // new pass
            cameras_.back() = *prev_camera;

            prev = pre_process_passes.back();
            prev->colour_target = pass->colour_target;

            // fudge the colour target of the pre pass and the depth target of the ssao pass into one render target
            pass->colour_target = render_target_manager_.create(prev->colour_target, ao_target);
            pass->clear_colour = false;
            pass->clear_depth = false;
        }

        // if a skybox has been added ensure it has an entity in the scene
        if (pass->sky_box != nullptr)
        {
            auto *scene = pass->scene;

            auto *sky_box_rg = create_render_graph();
            sky_box_rg->set_render_node<SkyBoxNode>(pass->sky_box);

            const auto [_, inserted] = sky_box_entities_.try_emplace(
                pass.get(),
                scene->create_entity_at_front<SingleEntity>(
                    sky_box_rg, mesh_manager_.cube({}), Transform({}, {}, {0.5f})));
            expect(inserted, "sky box exists");

            sky_box_entities_[pass.get()]->set_receive_shadow(false);
            sky_box_render_graphs_[pass.get()] = sky_box_rg;
        }
    }

    render_passes_ = pre_process_passes;
    std::transform(
        std::begin(user_created_passes_),
        std::end(user_created_passes_),
        std::back_insert_iterator(render_passes_),
        [](const auto &element) { return element.get(); });

    add_post_processing_passes();

    return rebuild();
}

std::vector<RenderCommand> RenderPipeline::rebuild()
{
    std::vector<RenderCommand> render_queue;
    RenderCommand cmd{};

    // convert each pass into a series of commands which will render it
    for (auto *pass : render_passes_)
    {
        cmd.set_render_pass(pass);

        cmd.set_type(RenderCommandType::PASS_START);
        render_queue.push_back(cmd);

        const auto has_normal_target = pass->normal_target != nullptr;
        const auto has_position_target = pass->position_target != nullptr;

        const auto *sky_box_rg = (sky_box_render_graphs_.contains(pass)) ? sky_box_render_graphs_[pass] : nullptr;

        // encode ambient light pass unless we have used ssao (in which case this gets done by the ssao pass itself)
        if (!pass->post_processing_description.ambient_occlusion)
        {
            encode_light_pass_commands(
                material_manager_,
                pass->scene,
                LightType::AMBIENT,
                has_normal_target,
                has_position_target,
                sky_box_rg,
                cmd,
                render_queue,
                shadow_maps_);
        }

        if (!pass->depth_only)
        {
            // encode point lights if there are any
            if (!pass->scene->lighting_rig()->point_lights.empty())
            {
                encode_light_pass_commands(
                    material_manager_,
                    pass->scene,
                    LightType::POINT,
                    has_normal_target,
                    has_position_target,
                    sky_box_rg,
                    cmd,
                    render_queue,
                    shadow_maps_);
            }

            // encode directional lights if there are any
            if (!pass->scene->lighting_rig()->directional_lights.empty())
            {
                encode_light_pass_commands(
                    material_manager_,
                    pass->scene,
                    LightType::DIRECTIONAL,
                    has_normal_target,
                    has_position_target,
                    sky_box_rg,
                    cmd,
                    render_queue,
                    shadow_maps_);
            }
        }

        cmd.set_type(RenderCommandType::PASS_END);
        render_queue.push_back(cmd);
    }

    cmd.set_type(RenderCommandType::PRESENT);
    render_queue.push_back(cmd);

    return render_queue;
}

std::vector<RenderPass *> RenderPipeline::render_passes() const
{
    return render_passes_;
}

bool RenderPipeline::is_dirty() const
{
    return dirty_;
}

void RenderPipeline::clear_dirty_bit()
{
    dirty_ = false;
}

RenderPass *RenderPipeline::create_engine_render_pass(Scene *scene)
{
    // using new to access private ctor
    auto pass = std::unique_ptr<RenderPass>(new RenderPass{});
    pass->scene = scene;

    engine_created_passes_.push_back(std::move(pass));

    return engine_created_passes_.back().get();
}

const RenderTarget *RenderPipeline::add_pass(
    std::vector<RenderPass *> &render_passes,
    std::function<void(RenderGraph *, const RenderTarget *)> create_render_graph_callback)
{
    // create new pass with
    cameras_.push_back({CameraType::ORTHOGRAPHIC, width_, height_});
    auto *camera = std::addressof(cameras_.back());
    const auto *target = render_target_manager_.create(width_, height_);

    auto *scene = create_scene();
    auto *rg = create_render_graph();
    create_render_graph_callback(rg, target);
    scene->create_entity<SingleEntity>(
        rg,
        mesh_manager_.sprite({}),
        Transform({}, {}, {static_cast<float>(width_), static_cast<float>(height_), 1. - 1}));

    auto *pass = create_engine_render_pass(scene);
    pass->camera = camera;

    // wire up this pass
    render_passes.back()->colour_target = target;
    render_passes.push_back(pass);

    return target;
}

void RenderPipeline::add_post_processing_passes()
{
    // our class member render_passes_ contains all the user passes and *some* engine passes
    // in order to add the rest we copy them one by one to a new collection and, for each one, add any additioanl
    // post processing passes
    // at the end we copy that back to the class member render_passes_
    std::vector<RenderPass *> render_passes{};

    for (auto *render_pass : render_passes_)
    {
        auto &last_pass = render_passes.emplace_back(render_pass);
        const auto *input_target = last_pass->colour_target;

        const auto description = render_pass->post_processing_description;

        if (const auto bloom = description.bloom; bloom)
        {
            const auto *null_target = add_pass(render_passes, [](RenderGraph *rg, const RenderTarget *target) {
                rg->render_node()->set_colour_input(rg->create<TextureNode>(target->colour_texture()));
            });

            add_pass(render_passes, [&bloom](RenderGraph *rg, const RenderTarget *target) {
                rg->render_node()->set_colour_input(rg->create<ConditionalNode>(
                    rg->create<BinaryOperatorNode>(
                        rg->create<TextureNode>(target->colour_texture()),
                        rg->create<ValueNode<Colour>>(Colour{0.2126f, 0.7152f, 0.0722f, 0.0f}),
                        BinaryOperator::DOT),
                    rg->create<ValueNode<float>>(bloom->threshold),
                    rg->create<TextureNode>(target->colour_texture()),
                    rg->create<ValueNode<Colour>>(Colour{0.0f, 0.0f, 0.0f, 1.0f}),
                    ConditionalOperator::GREATER));
            });

            for (auto i = 0u; i < bloom->iterations; ++i)
            {
                add_pass(render_passes, [](RenderGraph *rg, const RenderTarget *target) {
                    rg->render_node()->set_colour_input(
                        rg->create<BlurNode>(rg->create<TextureNode>(target->colour_texture())));
                });
            }

            add_pass(render_passes, [null_target](RenderGraph *rg, const RenderTarget *target) {
                rg->render_node()->set_colour_input(rg->create<BinaryOperatorNode>(
                    rg->create<TextureNode>(null_target->colour_texture()),
                    rg->create<TextureNode>(target->colour_texture()),
                    BinaryOperator::ADD));
            });
        }

        if (const auto colour_adjust = description.colour_adjust; colour_adjust)
        {
            add_pass(render_passes, [&colour_adjust](RenderGraph *rg, const RenderTarget *target) {
                rg->set_render_node<ColourAdjustNode>(
                    rg->create<TextureNode>(target->colour_texture()), *colour_adjust);
            });
        }

        if (description.anti_aliasing)
        {
            add_pass(render_passes, [](RenderGraph *rg, const RenderTarget *target) {
                rg->set_render_node<AntiAliasingNode>(rg->create<TextureNode>(target->colour_texture()));
            });
        }

        render_passes.back()->colour_target = input_target;
    }

    render_passes_ = render_passes;
}

Scene *RenderPipeline::scene(std::size_t index) const
{
    ensure(index < scenes_.size(), "index out of bounds");
    return scenes_[index].get();
}

}

```

`src/graphics/render_target.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/render_target.h"

#include <cstdint>
#include <iostream>
#include <memory>

#include "core/error_handling.h"
#include "graphics/texture.h"
#include "graphics/texture_manager.h"

namespace iris
{

RenderTarget::RenderTarget(const Texture *colour_texture, const Texture *depth_texture)
    : colour_texture_(colour_texture)
    , depth_texture_(depth_texture)
{
    expect(
        (colour_texture_->width() == depth_texture_->width()) &&
            (colour_texture_->height() == depth_texture_->height()),
        "colour and depth dimensions must match");
}

RenderTarget::~RenderTarget() = default;

const Texture *RenderTarget::colour_texture() const
{
    return colour_texture_;
}

const Texture *RenderTarget::depth_texture() const
{
    return depth_texture_;
}

std::uint32_t RenderTarget::width() const
{
    return colour_texture_->width();
}

std::uint32_t RenderTarget::height() const
{
    return colour_texture_->height();
}

}

```

`src/graphics/renderer.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/renderer.h"

#include <cassert>

#include "core/exception.h"
#include "graphics/material_manager.h"

namespace iris
{

Renderer::Renderer(MaterialManager &material_manager)
    : render_queue_()
    , render_pipeline_()
    , start_(std::chrono::steady_clock::now())
    , time_(0u)
    , material_manager_(material_manager)
{
}

void Renderer::render()
{
    if (render_pipeline_->is_dirty())
    {
        render_queue_ = render_pipeline_->rebuild();
        render_pipeline_->clear_dirty_bit();
    }

    pre_render();

    // update time
    // this is calculated here rather than in time() so all calls to time() produce the same value for a given frame
    time_ = std::chrono::steady_clock::now() - start_;

    // call each command with the appropriate handler
    for (auto &command : render_queue_)
    {
        switch (command.type())
        {
            case RenderCommandType::PASS_START: execute_pass_start(command); break;
            case RenderCommandType::DRAW: execute_draw(command); break;
            case RenderCommandType::PASS_END: execute_pass_end(command); break;
            case RenderCommandType::PRESENT: execute_present(command); break;
            default: throw Exception("unknown render queue command");
        }
    }

    post_render();
}

void Renderer::set_render_pipeline(std::unique_ptr<RenderPipeline> render_pipeline)
{
    material_manager_.clear();
    start_ = std::chrono::steady_clock::now();

    render_pipeline_ = std::move(render_pipeline);
    do_set_render_pipeline(
        [this]
        {
            render_queue_ = render_pipeline_->build();
            render_pipeline_->clear_dirty_bit();
        });
}

std::chrono::milliseconds Renderer::time() const
{
    return std::chrono::duration_cast<std::chrono::milliseconds>(time_);
}

void Renderer::pre_render()
{
    // default is to do nothing
}

void Renderer::execute_pass_start(RenderCommand &)
{
    // default is to do nothing
}

void Renderer::execute_draw(RenderCommand &)
{
    // default is to do nothing
}

void Renderer::execute_pass_end(RenderCommand &)
{
    // default is to do nothing
}

void Renderer::execute_present(RenderCommand &)
{
    // default is to do nothing
}

void Renderer::post_render()
{
    // default is to do nothing
}

}

```

`src/graphics/sampler.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/sampler.h"

#include <cstdint>

namespace iris
{

Sampler::Sampler(const SamplerDescriptor &descriptor, std::uint32_t index)
    : descriptor_(descriptor)
    , index_(index)
{
}

SamplerDescriptor Sampler::descriptor() const
{
    return descriptor_;
}

std::uint32_t Sampler::index() const
{
    return index_;
}

}

```

`src/graphics/scene.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/scene.h"

#include <vector>

#include "core/colour.h"
#include "core/error_handling.h"
#include "graphics/lights/lighting_rig.h"
#include "graphics/render_entity.h"
#include "graphics/render_graph/render_graph.h"

namespace iris
{
Scene::Scene(RenderGraph *default_render_graph, bool *dirty_pipeline)
    : entities_()
    , render_graphs_()
    , lighting_rig_()
    , default_render_graph_(default_render_graph)
    , dirty_pipeline_(dirty_pipeline)
{
    lighting_rig_.ambient_light = std::make_unique<AmbientLight>(Colour{1.0f, 1.0f, 1.0f});
}

RenderEntity *Scene::add(RenderGraph *render_graph, std::unique_ptr<RenderEntity> entity)
{
    *dirty_pipeline_ = true;

    if (render_graph == nullptr)
    {
        render_graph = default_render_graph_;
        entity->set_receive_shadow(false);
    }

    entities_.emplace_back(render_graph, std::move(entity));

    return std::get<1>(entities_.back()).get();
}

RenderEntity *Scene::add_at_front(RenderGraph *render_graph, std::unique_ptr<RenderEntity> entity)
{
    *dirty_pipeline_ = true;

    if (render_graph == nullptr)
    {
        render_graph = default_render_graph_;
        entity->set_receive_shadow(false);
    }

    entities_.insert(std::begin(entities_), {render_graph, std::move(entity)});

    return std::get<1>(entities_.front()).get();
}

void Scene::remove(RenderEntity *entity)
{
    *dirty_pipeline_ = true;

    entities_.erase(
        std::remove_if(
            std::begin(entities_),
            std::end(entities_),
            [entity](const auto &e) { return std::get<1>(e).get() == entity; }),
        std::end(entities_));
}

PointLight *Scene::add(std::unique_ptr<PointLight> light)
{
    *dirty_pipeline_ = true;

    lighting_rig_.point_lights.emplace_back(std::move(light));
    return lighting_rig_.point_lights.back().get();
}

DirectionalLight *Scene::add(std::unique_ptr<DirectionalLight> light)
{
    *dirty_pipeline_ = true;

    lighting_rig_.directional_lights.emplace_back(std::move(light));
    return lighting_rig_.directional_lights.back().get();
}

Colour Scene::ambient_light() const
{
    return lighting_rig_.ambient_light->colour();
}

void Scene::set_ambient_light(const Colour &colour)
{
    *dirty_pipeline_ = true;

    lighting_rig_.ambient_light->set_colour(colour);
}

RenderGraph *Scene::render_graph(RenderEntity *entity) const
{
    auto found = std::find_if(std::cbegin(entities_), std::cend(entities_), [entity](const auto &element) {
        return std::get<1>(element).get() == entity;
    });

    expect(found == std::cend(entities_), "entity not in scene");

    return std::get<0>(*found);
}

std::vector<std::tuple<RenderGraph *, std::unique_ptr<RenderEntity>>> &Scene::entities()
{
    return entities_;
}

const std::vector<std::tuple<RenderGraph *, std::unique_ptr<RenderEntity>>> &Scene::entities() const
{
    return entities_;
}

const LightingRig *Scene::lighting_rig() const
{
    return &lighting_rig_;
}

}

```

`src/graphics/single_animation.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/animation/animation.h"

#include <map>
#include <string>
#include <tuple>

#include "core/error_handling.h"
#include "core/matrix4.h"
#include "core/quaternion.h"
#include "core/vector3.h"
#include "log/log.h"

using namespace std::chrono_literals;

namespace iris
{

Animation::Animation(
    std::chrono::milliseconds duration,
    const std::string &name,
    const std::map<std::string, std::vector<KeyFrame>> &frames)
    : time_(0ms)
    , last_advance_(std::chrono::steady_clock::now())
    , duration_(duration)
    , name_(name)
    , frames_(frames)
{
}

std::string Animation::name() const
{
    return name_;
}

Transform Animation::transform(const std::string &bone) const
{
    expect(bone_exists(bone), "no animation for bone");

    const auto &keyframes = frames_.at(bone);

    // find the first keyframe *after* current time
    const auto &second_keyframe = std::find_if(
        std::cbegin(keyframes) + 1u, std::cend(keyframes), [this](const KeyFrame &kf) { return kf.time >= time_; });

    expect(second_keyframe != std::cend(keyframes), "cannot find keyframe");

    const auto first_keyframe = second_keyframe - 1u;

    // calculate interpolation amount
    const auto delta1 = second_keyframe->time - first_keyframe->time;
    const auto delta2 = time_ - first_keyframe->time;
    const auto interpolation = static_cast<float>(delta2.count()) / static_cast<float>(delta1.count());

    // interpolate between frames
    auto transform = first_keyframe->transform;
    transform.interpolate(second_keyframe->transform, interpolation);

    return transform;
}

bool Animation::bone_exists(const std::string &bone) const
{
    return frames_.count(bone) != 0u;
}

void Animation::advance()
{
    const auto now = std::chrono::steady_clock::now();
    const auto delta = std::chrono::duration_cast<std::chrono::milliseconds>(now - last_advance_);

    // update time, ensuring we wrap around so animation loops
    time_ = (time_ + delta) % duration_;

    last_advance_ = now;
}

void Animation::reset()
{
    time_ = 0ms;
    last_advance_ = std::chrono::steady_clock::now();
}

std::chrono::milliseconds Animation::duration() const
{
    return duration_;
}

void Animation::set_time(std::chrono::milliseconds time)
{
    time_ = time;
}

}

```

`src/graphics/single_entity.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/single_entity.h"

#include <string>
#include <string_view>

#include "core/camera_type.h"
#include "core/error_handling.h"
#include "core/matrix4.h"
#include "core/quaternion.h"
#include "core/transform.h"
#include "core/vector3.h"
#include "graphics/render_entity.h"
#include "graphics/render_entity_type.h"
#include "graphics/skeleton.h"

namespace
{

/**
 * Helper function to create a normal transformation matrix from a model
 * matrix.
 *
 * @param model
 *   The model matrix to calculate from.
 *
 * @returns
 *   Normal transformation matrix.
 */
iris::Matrix4 create_normal_transform(const iris::Matrix4 &model)
{
    auto normal = iris::Matrix4::transpose(iris::Matrix4::invert(model));

    // remove the translation components
    normal[3] = 0.0f;
    normal[7] = 0.0f;
    normal[11] = 0.0f;

    return normal;
}

}

namespace iris
{

SingleEntity::SingleEntity(
    const Mesh *mesh,
    const Vector3 &position,
    bool has_transparency,
    PrimitiveType primitive_type)
    : SingleEntity(mesh, {position, {}, {1.0f}}, has_transparency, primitive_type)
{
}

SingleEntity::SingleEntity(
    const Mesh *mesh,
    const Transform &transform,
    bool has_transparency,
    PrimitiveType primitive_type)
    : SingleEntity(mesh, transform, nullptr, has_transparency, primitive_type)
{
}

SingleEntity::SingleEntity(
    const Mesh *mesh,
    const Transform &transform,
    Skeleton *skeleton,
    bool has_transparency,
    PrimitiveType primitive_type)
    : RenderEntity(mesh, primitive_type)
    , transform_(transform)
    , normal_()
    , skeleton_(skeleton)
    , has_transparency_(has_transparency)
{
    ensure(mesh != nullptr, "must supply mesh");

    normal_ = create_normal_transform(transform_.matrix());
}

RenderEntityType SingleEntity::type() const
{
    return RenderEntityType::SINGLE;
}

Vector3 SingleEntity::position() const
{
    return transform_.translation();
}

void SingleEntity::set_position(const Vector3 &position)
{
    transform_.set_translation(position);
    normal_ = create_normal_transform(transform_.matrix());
}

Quaternion SingleEntity::orientation() const
{
    return transform_.rotation();
}

void SingleEntity::set_orientation(const Quaternion &orientation)
{
    transform_.set_rotation(orientation);
    normal_ = create_normal_transform(transform_.matrix());
}

Vector3 SingleEntity::scale() const
{
    return transform_.scale();
}

void SingleEntity::set_scale(const Vector3 &scale)
{
    transform_.set_scale(scale);
    normal_ = create_normal_transform(transform_.matrix());
}

Matrix4 SingleEntity::transform() const
{
    return transform_.matrix();
}

void SingleEntity::set_transform(const Matrix4 &transform)
{
    transform_.set_matrix(transform);
    normal_ = create_normal_transform(transform_.matrix());
}

void SingleEntity::set_transform(const Transform &transform)
{
    set_transform(transform.matrix());
}

Matrix4 SingleEntity::normal_transform() const
{
    return normal_;
}

void SingleEntity::set_mesh(const Mesh *mesh)
{
    mesh_ = mesh;
}

Skeleton *SingleEntity::skeleton()
{
    return skeleton_;
}

const Skeleton *SingleEntity::skeleton() const
{
    return skeleton_;
}

bool SingleEntity::has_transparency() const
{
    return has_transparency_;
}

}

```

`src/graphics/skeleton.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/skeleton.h"

#include <cassert>
#include <cstddef>
#include <queue>
#include <string>
#include <string_view>
#include <vector>

#include "core/error_handling.h"
#include "core/matrix4.h"
#include "graphics/animation/animation.h"
#include "graphics/animation/bone_query.h"
#include "graphics/bone.h"
#include "graphics/weight.h"

namespace
{

/**
 * Helper function to update transformation matrices. This is done by walking
 * the bone hierarchy and applying the bone transformations (optionally also
 * applied animation transformations).
 *
 * @param transforms
 *   Collection to update.
 *
 * @param bones
 *   Bones to calculate.
 *
 * @param parents
 *   Index of parents of bones.
 *
 * @param query
 *   Optional object to query bone transforms (for example from an animation).
 */
void update_transforms(
    std::vector<iris::Matrix4> &transforms,
    const std::vector<iris::Bone> &bones,
    const std::vector<std::size_t> &parents,
    iris::BoneQuery *query)
{
    // get inverse transform of root node
    const auto inverse = iris::Matrix4::invert(bones.front().transform());

    // we need some scratch space to save bone transformations as we calculate
    // them, this allows us to look up a parents transform
    // we don't want to update the actual bones transform as this causes issues
    // when we change animation
    std::vector<iris::Matrix4> cache(transforms.size());
    transforms[0] = bones.front().transform();

    // walk remaining bones - these are in hierarchal order so we will always
    // update a parent before its children
    for (auto i = 1u; i < bones.size(); ++i)
    {
        auto &bone = bones[i];

        if (bone.is_manual())
        {
            // if a bone is manual then its transform is absolute, so no need
            // to apply parents transform
            cache[i] = bone.transform();
            transforms[i] = inverse * cache[i] * bone.offset();
        }
        else if (query != nullptr)
        {
            // check if our bone exists in the supplied animation
            if (const auto transform = query->transform(bone.name()); transform)
            {
                // apply parent transform with animation transform
                cache[i] = cache[parents[i]] * transform->matrix();
                transforms[i] = inverse * cache[i] * bone.offset();
            }
        }
        else
        {
            // apply parent transform
            cache[i] = cache[parents[i]] * bone.transform();
            transforms[i] = inverse * cache[i] * bone.offset();
        }
    }
}

}

namespace iris
{

Skeleton::Skeleton()
    : Skeleton({{"root", {}, {}, {}}})
{
}

Skeleton::Skeleton(std::vector<Bone> bones)
    : bones_()
    , parents_()
    , transforms_(100)
{
    // a root bone is one without a parent, only support one
    ensure(
        std::count_if(std::cbegin(bones), std::cend(bones), [](const Bone &bone) { return bone.parent().empty(); }) ==
            1,
        "only support one root bones");

    auto root =
        std::find_if(std::begin(bones), std::end(bones), [](const Bone &bone) { return bone.parent().empty(); });

    // we need to copy the supplied bones in a specific order
    // the aim is to flatten the hierarchy so that the root node is first,
    // then its children, then grand children etc
    // this ordering guarantees that a nodes always precedes its children, which
    // makes updating transforms much simpler (as we can just iterate through
    // the list as we know a parents transformation will be updated by the time
    // we reach the child)

    std::queue<std::vector<Bone>::iterator> queue;
    queue.emplace(root);
    parents_.emplace_back(std::numeric_limits<std::size_t>::max());

    // breadth-first walk the hierarchy
    do
    {
        const auto iter = queue.front();
        queue.pop();

        // move the bone to the back of our list
        std::move(iter, iter + 1u, std::back_inserter(bones_));

        const auto name = bones_.back().name();

        // have to search all bones for children every time, not the most
        // efficient but its a one off cost
        for (auto i = std::begin(bones); i != std::end(bones); ++i)
        {
            if (i->parent() == name)
            {
                queue.emplace(i);
                parents_.emplace_back(bones_.size() - 1u);
            }
        }

    } while (!queue.empty());
}

const std::vector<Bone> &Skeleton::bones() const
{
    return bones_;
}

const std::vector<Matrix4> &Skeleton::transforms() const
{
    return transforms_;
}

void Skeleton::update(BoneQuery *query)
{
    update_transforms(transforms_, bones_, parents_, query);
}

bool Skeleton::has_bone(std::string_view name) const
{
    const auto bone =
        std::find_if(std::cbegin(bones_), std::cend(bones_), [&name](const Bone &bone) { return bone.name() == name; });

    return bone != std::cend(bones_);
}

std::size_t Skeleton::bone_index(std::string_view name) const
{
    const auto bone =
        std::find_if(std::cbegin(bones_), std::cend(bones_), [&name](const Bone &bone) { return bone.name() == name; });

    expect(bone != std::cend(bones_), "unknown bone");

    return std::distance(std::cbegin(bones_), bone);
}

Bone &Skeleton::bone(std::size_t index)
{
    return bones_[index];
}

Matrix4 Skeleton::transform(std::size_t index) const
{
    return transforms_[index];
}

const Bone &Skeleton::bone(std::size_t index) const
{
    return bones_[index];
}

}

```

`src/graphics/texture.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/texture.h"

#include <cstdint>

#include "graphics/sampler.h"
#include "graphics/texture_usage.h"

namespace iris
{

Texture::Texture(
    const DataBuffer &data,
    std::uint32_t width,
    std::uint32_t height,
    const Sampler *sampler,
    TextureUsage usage,
    std::uint32_t index)
    : data_(data)
    , width_(width)
    , height_(height)
    , sampler_(sampler)
    , usage_(usage)
    , index_(index)
    , has_transparency_(false)
{
    for (auto i = 3u; i < data_.size(); i += 4u)
    {
        if (data_[i] != std::byte{0xFF})
        {
            has_transparency_ = true;
            break;
        }
    }
}

Texture::~Texture() = default;

const DataBuffer &Texture::data() const
{
    return data_;
}

std::uint32_t Texture::width() const
{
    return width_;
}

std::uint32_t Texture::height() const
{
    return height_;
}

const Sampler *Texture::sampler() const
{
    return sampler_;
}

TextureUsage Texture::usage() const
{
    return usage_;
}

std::uint32_t Texture::index() const
{
    return index_;
}

bool Texture::has_transparency() const
{
    return has_transparency_;
}

}

```

`src/graphics/texture_manager.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/texture_manager.h"

#include <cstdint>
#include <cstdlib>
#include <map>
#include <memory>
#include <sstream>
#include <string>
#include <vector>

#define STB_IMAGE_IMPLEMENTATION
#include <stb_image.h>

#include "core/auto_release.h"
#include "core/data_buffer.h"
#include "core/error_handling.h"
#include "core/resource_manager.h"
#include "graphics/cube_map.h"
#include "graphics/sampler.h"
#include "graphics/texture.h"
#include "graphics/texture_usage.h"

namespace
{

/**
 * Load an image from a data buffer.
 *
 * @param data
 *   Image data.
 *
 * @returns
 *   Tuple of <data, width, height, number of channels>.
 */
std::tuple<iris::DataBuffer, std::uint32_t, std::uint32_t> parse_image(
    const iris::DataBuffer &data,
    bool flip_on_load = true)
{
    int width = 0;
    int height = 0;
    int num_channels = 0;

    // ensure that images are flipped along the y axis when loaded, this is so
    // they work with what the graphics api treats as the origin
    ::stbi_set_flip_vertically_on_load(flip_on_load);

    // load image using stb library
    iris::AutoRelease<::stbi_uc *, nullptr> raw_data(
        ::stbi_load_from_memory(
            reinterpret_cast<const stbi_uc *>(data.data()),
            static_cast<int>(data.size()),
            &width,
            &height,
            &num_channels,
            0),
        ::stbi_image_free);

    iris::ensure(raw_data && (num_channels != 0), "failed to load image");

    // calculate the total number of bytes needed for the raw data
    const auto size = width * height * num_channels;

    static constexpr auto output_channels = 4u;

    // create buffer big enough for RGBA data
    iris::DataBuffer padded_data{width * height * output_channels};

    // we only store image data as RGBA in the engine, so extend the data if
    // we have less than four channels

    auto dst_ptr = padded_data.data();
    auto *src_ptr = reinterpret_cast<const std::byte *>(raw_data.get());
    const auto *end_ptr = reinterpret_cast<const std::byte *>(raw_data.get() + size);

    while (src_ptr != end_ptr)
    {
        // default pixel value (black with alpha)
        // this allows us to memcpy over the data we do have and leaves the
        // correct defaults if we have less than four channels
        std::byte rgba[] = {std::byte{0x0}, std::byte{0x0}, std::byte{0x0}, std::byte{0xff}};

        memcpy(rgba, src_ptr, num_channels);
        memcpy(dst_ptr, rgba, output_channels);

        dst_ptr += output_channels;
        src_ptr += num_channels;
    }

    return std::make_tuple(
        std::move(padded_data), static_cast<std::uint32_t>(width), static_cast<std::uint32_t>(height));
}

/**
 * Create data for a texture which is just one colour.
 *
 * @param colour
 *   Colour of texture.
 *
 * @param width
 *   Width of texture to create.
 *
 * @param height
 *   Height of texture to create.
 *
 * @returns
 *   Texture data.
 */
iris::DataBuffer create_texture_data(const iris::Colour &colour, std::uint32_t width, std::uint32_t height)
{
    const std::byte colour_bytes[] = {
        static_cast<std::byte>(colour.r * 0xff),
        static_cast<std::byte>(colour.g * 0xff),
        static_cast<std::byte>(colour.b * 0xff),
        static_cast<std::byte>(colour.a * 0xff)};

    iris::DataBuffer colour_data(width * height * 4u);
    auto *cursor = colour_data.data();

    for (auto i = 0u; i < width * height; ++i)
    {
        memcpy(cursor, colour_bytes, sizeof(colour_bytes));
        cursor += 4u;
    }

    return colour_data;
}

/**
 * Create data for a texture which is a vertical gradient.
 *
 * @param start
 *   Bottom colour.
 *
 * @param end
 *   Top colour.
 *
 * @param width
 *   Width of texture to create.
 *
 * @param height
 *   Height of texture to create.
 *
 * @returns
 *   Texture data.
 */
iris::DataBuffer create_texture_data(
    const iris::Colour &start,
    const iris::Colour &end,
    std::uint32_t width,
    std::uint32_t height)
{
    iris::DataBuffer colour_data(width * height * 4u);
    auto *cursor = colour_data.data();

    for (auto y = 0u; y < height; ++y)
    {
        const auto row_colour = iris::Colour::lerp(start, end, static_cast<float>(y) / static_cast<float>(height));

        const std::byte colour_bytes[] = {
            static_cast<std::byte>(row_colour.r * 0xff),
            static_cast<std::byte>(row_colour.g * 0xff),
            static_cast<std::byte>(row_colour.b * 0xff),
            static_cast<std::byte>(row_colour.a * 0xff)};

        for (auto x = 0u; x < width; ++x)
        {
            memcpy(cursor, colour_bytes, sizeof(colour_bytes));
            cursor += 4u;
        }
    }

    return colour_data;
}

}

namespace iris
{

TextureManager::TextureManager(ResourceManager &resource_manager)
    : resource_manager_(resource_manager)
    , loaded_textures_()
    , loaded_cube_maps_()
    , loaded_samplers_()
    , texture_index_counter_(0u)
    , texture_index_free_list_()
    , cube_map_index_counter_(0u)
    , cube_map_index_free_list_()
    , sampler_index_counter_(0u)
    , sampler_index_free_list_()
{
}

Texture *TextureManager::load(const std::string &resource, TextureUsage usage, const Sampler *sampler)
{
    expect((usage == TextureUsage::IMAGE) || (usage == TextureUsage::DATA), "can only load IMAGE or DATA from file");

    // check if texture has been loaded before, if not then load it
    if (!loaded_textures_.contains(resource))
    {
        const auto file_data = resource_manager_.load(resource);
        auto [data, width, height] = parse_image(file_data, true);

        auto texture = do_create(
            data, width, height, sampler == nullptr ? default_texture_sampler() : sampler, usage, next_texture_index());

        loaded_textures_[resource] = {1u, std::move(texture)};
    }
    else
    {
        ++loaded_textures_[resource].ref_count;
    }

    return loaded_textures_[resource].asset.get();
}

CubeMap *TextureManager::load(
    const std::string &right_resource,
    const std::string &left_resource,
    const std::string &top_resource,
    const std::string &bottom_resource,
    const std::string &back_resource,
    const std::string &front_resource,
    const Sampler *sampler)
{
    std::stringstream strm{};
    strm << right_resource << left_resource << top_resource << bottom_resource << back_resource << front_resource;

    const auto resource = strm.str();

    if (!loaded_cube_maps_.contains(resource))
    {
        const std::vector<std::tuple<iris::DataBuffer, std::uint32_t, std::uint32_t>> parsed_sides = {
            parse_image(resource_manager_.load(right_resource), false),
            parse_image(resource_manager_.load(left_resource), false),
            parse_image(resource_manager_.load(top_resource), false),
            parse_image(resource_manager_.load(bottom_resource), false),
            parse_image(resource_manager_.load(back_resource), false),
            parse_image(resource_manager_.load(front_resource), false)};

        const auto width = std::get<1>(parsed_sides.front());
        const auto height = std::get<2>(parsed_sides.front());

        ensure(
            std::all_of(
                std::cbegin(parsed_sides) + 1u,
                std::cend(parsed_sides),
                [width, height](const auto &side) {
                    return (std::get<1>(side) == width) && (std::get<2>(side) == height);
                }),
            "cube map images must all have the same dimensions");

        auto cube_map = do_create(
            std::get<0>(parsed_sides[0]),
            std::get<0>(parsed_sides[1]),
            std::get<0>(parsed_sides[2]),
            std::get<0>(parsed_sides[3]),
            std::get<0>(parsed_sides[4]),
            std::get<0>(parsed_sides[5]),
            width,
            height,
            sampler == nullptr ? default_cube_map_sampler() : sampler,
            next_cube_map_index());

        loaded_cube_maps_[resource] = {1u, std::move(cube_map)};
    }
    else
    {
        ++loaded_cube_maps_[resource].ref_count;
    }

    return loaded_cube_maps_[resource].asset.get();
}

Texture *TextureManager::create(
    const DataBuffer &data,
    std::uint32_t width,
    std::uint32_t height,
    TextureUsage usage,
    const Sampler *sampler)
{
    static std::uint32_t counter = 0u;

    // create a unique name for the in-memory texture
    std::stringstream strm;
    strm << "!" << counter;
    ++counter;

    const auto resource = strm.str();

    auto texture = do_create(
        data, width, height, sampler == nullptr ? default_texture_sampler() : sampler, usage, next_texture_index());

    loaded_textures_[resource] = {1u, std::move(texture)};

    return loaded_textures_[resource].asset.get();
}

CubeMap *TextureManager::create(
    const DataBuffer &right_data,
    const DataBuffer &left_data,
    const DataBuffer &top_data,
    const DataBuffer &bottom_data,
    const DataBuffer &near_data,
    const DataBuffer &far_data,
    std::uint32_t width,
    std::uint32_t height,
    const Sampler *sampler)
{
    static std::uint32_t counter = 0u;

    // create a unique name for the in-memory texture
    std::stringstream strm;
    strm << "!" << counter;
    ++counter;

    const auto resource = strm.str();

    auto cube_map = do_create(
        right_data,
        left_data,
        top_data,
        bottom_data,
        near_data,
        far_data,
        width,
        height,
        sampler == nullptr ? default_cube_map_sampler() : sampler,
        next_cube_map_index());

    loaded_cube_maps_[resource] = {1u, std::move(cube_map)};

    return loaded_cube_maps_[resource].asset.get();
}

CubeMap *TextureManager::create(
    const Colour &start,
    const Colour &end,
    std::uint32_t width,
    std::uint32_t height,
    const Sampler *sampler)
{
    const auto top = create_texture_data(start, width, height);
    const auto bottom = create_texture_data(end, width, height);
    const auto side = create_texture_data(start, end, width, height);

    return create(
        side, side, top, bottom, side, side, width, height, sampler == nullptr ? default_cube_map_sampler() : sampler);
}

Sampler *TextureManager::create(const SamplerDescriptor &descriptor)
{
    if (!loaded_samplers_.contains(descriptor))
    {
        auto sampler = do_create(descriptor, next_sampler_index());
        loaded_samplers_[descriptor] = {1u, std::move(sampler)};
    }
    else
    {
        ++loaded_samplers_[descriptor].ref_count;
    }

    return loaded_samplers_[descriptor].asset.get();
}

void TextureManager::unload(const Texture *texture)
{
    // don't unload the static blank texture!
    if (texture != blank_texture())
    {
        // find the texture that we want to unload
        auto loaded =
            std::find_if(std::begin(loaded_textures_), std::end(loaded_textures_), [texture](const auto &element) {
                return element.second.asset.get() == texture;
            });

        expect(loaded != std::cend(loaded_textures_), "texture has not been loaded");

        // decrement reference count and, if 0, unload
        --loaded->second.ref_count;
        if (loaded->second.ref_count == 0u)
        {
            unload(texture->sampler());

            // allow for implementation specific unloading logic
            destroy(texture);

            texture_index_free_list_.emplace_back(texture->index());
            loaded_textures_.erase(loaded);
        }
    }
}

void TextureManager::unload(const CubeMap *cube_map)
{
    // don't unload the static blank cube map!
    if (cube_map != blank_cube_map())
    {
        // find the texture that we want to unload
        auto loaded =
            std::find_if(std::begin(loaded_cube_maps_), std::end(loaded_cube_maps_), [cube_map](const auto &element) {
                return element.second.asset.get() == cube_map;
            });

        expect(loaded != std::cend(loaded_cube_maps_), "cube_map has not been loaded");

        // decrement reference count and, if 0, unload
        --loaded->second.ref_count;
        if (loaded->second.ref_count == 0u)
        {
            unload(cube_map->sampler());

            // allow for implementation specific unloading logic
            destroy(cube_map);

            cube_map_index_free_list_.emplace_back(cube_map->index());
            loaded_cube_maps_.erase(loaded);
        }
    }
}

void TextureManager::unload(const Sampler *sampler)
{
    // don't unload the default sampler!
    if ((sampler != default_texture_sampler()) && (sampler != default_cube_map_sampler()))
    {
        auto loaded =
            std::find_if(std::begin(loaded_samplers_), std::end(loaded_samplers_), [sampler](const auto &element) {
                return element.second.asset.get() == sampler;
            });

        expect(loaded != std::end(loaded_samplers_), "sampler has not been loaded");

        // decrement reference count and, if 0, unload
        --loaded->second.ref_count;
        if (loaded->second.ref_count == 0u)
        {
            // allow for implementation specific unloading logic
            destroy(sampler);

            sampler_index_free_list_.emplace_back(sampler->index());
            loaded_samplers_.erase(loaded);
        }
    }
}

Texture *TextureManager::blank_texture()
{
    static auto *texture =
        create({std::byte{0xff}, std::byte{0xff}, std::byte{0xff}, std::byte{0xff}}, 1u, 1u, TextureUsage::IMAGE);

    return texture;
}

CubeMap *TextureManager::blank_cube_map()
{
    static auto *cube_map = create(
        {std::byte{0xff}, std::byte{0xff}, std::byte{0xff}, std::byte{0xff}},
        {std::byte{0xff}, std::byte{0xff}, std::byte{0xff}, std::byte{0xff}},
        {std::byte{0xff}, std::byte{0xff}, std::byte{0xff}, std::byte{0xff}},
        {std::byte{0xff}, std::byte{0xff}, std::byte{0xff}, std::byte{0xff}},
        {std::byte{0xff}, std::byte{0xff}, std::byte{0xff}, std::byte{0xff}},
        {std::byte{0xff}, std::byte{0xff}, std::byte{0xff}, std::byte{0xff}},
        1u,
        1u);

    return cube_map;
}

Sampler *TextureManager::default_texture_sampler()
{
    static auto *sampler = create(SamplerDescriptor{});
    return sampler;
}

Sampler *TextureManager::default_cube_map_sampler()
{
    static auto *sampler = create(SamplerDescriptor{.uses_mips = false});
    return sampler;
}

std::uint32_t TextureManager::next_texture_index()
{
    auto index = 0u;

    // first check free list for available indices, if empty then use main counter

    if (!texture_index_free_list_.empty())
    {
        index = texture_index_free_list_.back();
        texture_index_free_list_.pop_back();
    }
    else
    {
        index = texture_index_counter_++;
    }

    return index;
}

std::uint32_t TextureManager::next_cube_map_index()
{
    auto index = 0u;

    // first check free list for available indices, if empty then use main counter

    if (!cube_map_index_free_list_.empty())
    {
        index = cube_map_index_free_list_.back();
        cube_map_index_free_list_.pop_back();
    }
    else
    {
        index = cube_map_index_counter_++;
    }

    return index;
}

std::uint32_t TextureManager::next_sampler_index()
{
    auto index = 0u;

    // first check free list for available indices, if empty then use main counter

    if (!sampler_index_free_list_.empty())
    {
        index = sampler_index_free_list_.back();
        sampler_index_free_list_.pop_back();
    }
    else
    {
        index = sampler_index_counter_++;
    }

    return index;
}

std::vector<const Texture *> TextureManager::textures() const
{
    std::vector<const Texture *> textures{};

    std::transform(
        std::cbegin(loaded_textures_),
        std::cend(loaded_textures_),
        std::back_inserter(textures),
        [](const auto &element) { return element.second.asset.get(); });

    std::sort(std::begin(textures), std::end(textures), [](const Texture *a, const Texture *b) {
        return a->index() < b->index();
    });

    return textures;
}

std::vector<const Sampler *> TextureManager::samplers() const
{
    std::vector<const Sampler *> samplers{};

    std::transform(
        std::cbegin(loaded_samplers_),
        std::cend(loaded_samplers_),
        std::back_inserter(samplers),
        [](const auto &element) { return element.second.asset.get(); });

    std::sort(std::begin(samplers), std::end(samplers), [](const Sampler *a, const Sampler *b) {
        return a->index() < b->index();
    });

    return samplers;
}

std::vector<const CubeMap *> TextureManager::cube_maps() const
{
    std::vector<const CubeMap *> cube_maps{};

    std::transform(
        std::cbegin(loaded_cube_maps_),
        std::cend(loaded_cube_maps_),
        std::back_inserter(cube_maps),
        [](const auto &element) { return element.second.asset.get(); });

    std::sort(std::begin(cube_maps), std::end(cube_maps), [](const CubeMap *a, const CubeMap *b) {
        return a->index() < b->index();
    });

    return cube_maps;
}

void TextureManager::destroy(const Texture *)
{
    // by default do nothing
}

void TextureManager::destroy(const CubeMap *)
{
    // by default do nothing
}

void TextureManager::destroy(const Sampler *)
{
    // by default do nothing
}

}

```

`src/graphics/utils.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/utils.h"

#include <cmath>
#include <cstdint>
#include <cstdlib>
#include <cstring>
#include <string>
#include <vector>

#include "core/data_buffer.h"

#include <stb_image_write.h>

namespace iris
{

std::vector<MipLevelData> generate_mip_maps(const MipLevelData &start_level)
{
    std::vector<MipLevelData> mip_maps{start_level};

    // each subsequent mipmap is half the size of the preceding one
    static constexpr auto scale = 2u;

    // next mip level dimensions
    auto width = start_level.width / scale;
    auto height = start_level.height / scale;

    while ((width > 0u) && (height > 0u))
    {
        const auto scale_x = static_cast<float>(mip_maps.back().width) / static_cast<float>(width);
        const auto scale_y = static_cast<float>(mip_maps.back().height) / static_cast<float>(height);

        // we work on RGBA images
        static constexpr auto stride = 4u;

        DataBuffer mip_data(width * height * stride);

        auto *dst = mip_data.data();
        const auto *src = reinterpret_cast<const std::uint8_t *>(mip_maps.back().data.data());

        // simple downsize algorithm by skipping pixels, will produce aliasing
        for (auto y = 0u; y < height; ++y)
        {
            const auto y_nearest = static_cast<int>(std::floor(y * scale_y));

            for (auto x = 0u; x < width; ++x)
            {
                const auto x_nearest = static_cast<int>(std::floor(x * scale_x));

                std::memcpy(dst, src + ((y_nearest * mip_maps.back().width) + x_nearest) * stride, stride);
                dst += stride;
            }
        }

        mip_maps.push_back({.data = std::move(mip_data), .width = width, .height = height});

        width /= scale;
        height /= scale;
    }

    return mip_maps;
}

}

```

`src/graphics/vertex_attributes.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/vertex_attributes.h"

#include <cstddef>
#include <iterator>
#include <tuple>
#include <vector>

#include "core/exception.h"
#include "core/vector3.h"

namespace
{
/**
 * Helper function to convert a VertexAttributeType to a tuple of:
 * <number of components, size of singe component>
 *
 * @param type
 *   Type to convert.
 *
 * @returns
 *   Tuple of <number of components, size of single component>.
 */
std::tuple<std::size_t, std::size_t> type_information(iris::VertexAttributeType type)
{
    std::tuple<std::size_t, std::size_t> info(0u, 0u);

    switch (type)
    {
        case iris::VertexAttributeType::FLOAT_3: info = {3u, sizeof(float)}; break;
        case iris::VertexAttributeType::FLOAT_4: info = {4u, sizeof(float)}; break;
        case iris::VertexAttributeType::UINT32_1: info = {1u, sizeof(std::uint32_t)}; break;
        case iris::VertexAttributeType::UINT32_4: info = {4u, sizeof(std::uint32_t)}; break;
        default: throw iris::Exception("unknown vertex attribute type");
    }

    return info;
}
}

namespace iris
{

VertexAttributes::VertexAttributes(const std::vector<VertexAttributeType> &types)
    : attributes_()
    , size_(0u)
{
    std::size_t offset = 0u;

    for (const auto type : types)
    {
        const auto [components, size] = type_information(type);
        attributes_.emplace_back(VertexAttribute{type, components, size, offset});
        offset += components * size;
    }

    size_ = offset;
}

std::size_t VertexAttributes::size() const
{
    return size_;
}

VertexAttributes::const_iterator VertexAttributes::begin() const
{
    return cbegin();
}

VertexAttributes::const_iterator VertexAttributes::end() const
{
    return cend();
}

VertexAttributes::const_iterator VertexAttributes::cbegin() const
{
    return std::cbegin(attributes_);
}

VertexAttributes::const_iterator VertexAttributes::cend() const
{
    return std::cend(attributes_);
}

}

```

`src/graphics/win32/CMakeLists.txt`:

```txt
set(INCLUDE_ROOT "${PROJECT_SOURCE_DIR}/include/iris/graphics/win32")

target_sources(iris PRIVATE
    ${INCLUDE_ROOT}/win32_d3d12_window.h
    ${INCLUDE_ROOT}/win32_opengl_window.h
    ${INCLUDE_ROOT}/win32_window.h
    ${INCLUDE_ROOT}/win32_window_manager.h
    win32_d3d12_window.cpp
    win32_opengl_window.cpp
    win32_window.cpp
    win32_window_manager.cpp)

```

`src/graphics/win32/text_factory.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/text_factory.h"

#include <cmath>
#include <memory>
#include <string>
#include <vector>

#include <d2d1.h>
#include <dwrite.h>
#include <wincodec.h>
#include <windows.h>

#include "core/auto_release.h"
#include "core/error_handling.h"
#include "core/root.h"
#include "graphics/sampler.h"
#include "graphics/texture.h"
#include "graphics/texture_manager.h"
#include "graphics/win32/win32_window.h"
#include "graphics/window.h"
#include "graphics/window_manager.h"
#include "log/log.h"

#pragma comment(lib, "d2d1.lib")
#pragma comment(lib, "dwrite")

namespace
{

/**
 * Helper function to convert a utf-8 string to a utf-16 string.
 *
 * @param str
 *   String to covert.
 *
 * @returns
 *   Converted string.
 */
std::wstring widen(const std::string &str)
{
    // calculate number of characters in wide string
    const auto expected_size =
        ::MultiByteToWideChar(CP_UTF8, MB_PRECOMPOSED, str.c_str(), static_cast<int>(str.length()), NULL, 0);

    iris::ensure(expected_size != 0, "could not get wstring size");

    std::wstring wide_str(expected_size, L'\0');

    // widen
    iris::ensure(
        ::MultiByteToWideChar(
            CP_UTF8,
            MB_PRECOMPOSED,
            str.c_str(),
            static_cast<int>(str.length()),
            wide_str.data(),
            static_cast<int>(wide_str.length())) == expected_size,
        "could not widen string");

    return wide_str;
}

/**
 * Helper function to call Release on an object.
 *
 * @param ptr
 *   Ptr to release.
 */
template <class T>
void SafeRelease(T ptr)
{
    if (ptr != nullptr)
    {
        ptr->Release();
    }
}

}

namespace iris::text_factory
{

Texture *create(const std::string &font_name, const std::uint32_t size, const std::string &text, const Colour &colour)
{
    // create factory for creating Direct2d objects
    ID2D1Factory *direct2d_factory = nullptr;
    expect(
        ::D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, &direct2d_factory) == S_OK,
        "failed to create d2d factory");

    // create factory for creating DirectWrite objects
    IDWriteFactory *write_factory = nullptr;
    expect(
        ::DWriteCreateFactory(
            DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory), reinterpret_cast<IUnknown **>(&write_factory)) ==
            S_OK,
        "failed to create write factory");

    // widen font name for win32 api calls
    const auto font_name_wide = widen(font_name);

    // widen text for win32 api calls
    const auto text_wide = widen(text);
    ensure(!text_wide.empty(), "cannot render empty string");

    // create object describing text format
    IDWriteTextFormat *text_format = nullptr;
    ensure(
        write_factory->CreateTextFormat(
            font_name_wide.c_str(),
            NULL,
            DWRITE_FONT_WEIGHT_REGULAR,
            DWRITE_FONT_STYLE_NORMAL,
            DWRITE_FONT_STRETCH_NORMAL,
            static_cast<float>(size),
            L"en-us",
            &text_format) == S_OK,
        "failed to create text format");

    // create object for text layout
    // we assume a very large size, but can query after this call for actual
    // size
    IDWriteTextLayout *text_layout = nullptr;
    expect(
        write_factory->CreateTextLayout(
            text_wide.c_str(),
            static_cast<UINT32>(text_wide.length()),
            text_format,
            99999.0f,
            99999.0f,
            &text_layout) == S_OK,
        "failed to create text layout");

    // get actual text dimension
    DWRITE_TEXT_METRICS metrics = {0};
    text_layout->GetMetrics(&metrics);

    const auto width = static_cast<std::uint32_t>(metrics.width);
    const auto height = static_cast<std::uint32_t>(metrics.height);

    // create factory for creating WIC objects
    IWICImagingFactory *image_factory = nullptr;
    expect(
        ::CoCreateInstance(
            CLSID_WICImagingFactory2,
            NULL,
            CLSCTX_INPROC_SERVER,
            __uuidof(IWICImagingFactory2),
            reinterpret_cast<LPVOID *>(&image_factory)) == S_OK,
        "failed to create image factory");

    // create a bitmap to render text to
    IWICBitmap *bitmap = nullptr;
    expect(
        image_factory->CreateBitmap(width, height, GUID_WICPixelFormat32bppPBGRA, WICBitmapCacheOnDemand, &bitmap) ==
            S_OK,
        "failed to create bitmap");

    // default render properties
    const auto properties = ::D2D1::RenderTargetProperties(
        D2D1_RENDER_TARGET_TYPE_DEFAULT,
        ::D2D1::PixelFormat(DXGI_FORMAT_B8G8R8A8_UNORM, D2D1_ALPHA_MODE_PREMULTIPLIED),
        0.0f,
        0.0f,
        D2D1_RENDER_TARGET_USAGE_NONE);

    // create a render target to render font to bitmap
    AutoRelease<ID2D1RenderTarget *, nullptr> render_target = {nullptr, &SafeRelease<ID2D1RenderTarget *>};
    expect(
        direct2d_factory->CreateWicBitmapRenderTarget(bitmap, &properties, &render_target) == S_OK,
        "failed to create render target");

    // create a brush with supplied colour
    AutoRelease<ID2D1SolidColorBrush *, nullptr> brush = {nullptr, &SafeRelease<ID2D1SolidColorBrush *>};
    expect(
        render_target->CreateSolidColorBrush(
            ::D2D1::ColorF(::D2D1::ColorF::ColorF(colour.r, colour.g, colour.b)), &brush) == S_OK,
        "failed to create brush");

    const auto origin = ::D2D1::Point2F(0.0f, 0.0f);

    // render text
    render_target->BeginDraw();
    render_target->Clear();
    render_target->DrawTextLayout(origin, text_layout, brush);
    render_target->EndDraw();

    // get size of bitmap
    UINT bitmap_width = 0u;
    UINT bitmap_height = 0u;
    expect(bitmap->GetSize(&bitmap_width, &bitmap_height) == S_OK, "failed to get bitmap size");

    WICRect rect = {0, 0, (INT)bitmap_width, (INT)bitmap_height};

    // lock bitmap to read data
    // will auto release lock at end of function scope
    AutoRelease<IWICBitmapLock *, nullptr> lock = {nullptr, [](IWICBitmapLock *lock) { lock->Release(); }};
    expect(bitmap->Lock(&rect, WICBitmapLockRead, &lock) == S_OK, "failed to get lock");

    // get pointer to raw bitmap data
    UINT buffer_size = 0u;
    std::byte *buffer = nullptr;
    expect(
        lock.get()->GetDataPointer(&buffer_size, reinterpret_cast<BYTE **>(&buffer)) == S_OK,
        "failed to get data pointer");

    DataBuffer pixel_data(buffer, buffer + buffer_size);

    // we have rendered the font with premultiplied alpha - which will change the rgb values based on the alpha
    // component and can leave dark artifacts around the letters (especially with a light font on a light background)
    // to fix this we remove the premultiplied alpha component from the rgb
    for (auto i = 0u; i < pixel_data.size(); i += 4u)
    {
        if (pixel_data[i + 3u] != std::byte{0x00})
        {
            const auto alpha = static_cast<float>(pixel_data[i + 3u]) / 255.0f;
            pixel_data[i + 0u] =
                static_cast<std::byte>(((static_cast<float>(pixel_data[i + 0u]) / 255.0f) / alpha) * 255.0f);
            pixel_data[i + 1u] =
                static_cast<std::byte>(((static_cast<float>(pixel_data[i + 1u]) / 255.0f) / alpha) * 255.0f);
            pixel_data[i + 2u] =
                static_cast<std::byte>(((static_cast<float>(pixel_data[i + 2u]) / 255.0f) / alpha) * 255.0f);
        }
    }

    // using linear filters can also lead to dark borders - so set an appropriate sampler
    auto *sampler = Root::texture_manager().create(SamplerDescriptor{
        .minification_filter = SamplerFilter::NEAREST,
        .magnification_filter = SamplerFilter::NEAREST,
        .uses_mips = false,
        .mip_filter = SamplerFilter::NEAREST});
    auto *texture = Root::texture_manager().create(pixel_data, width, height, TextureUsage::IMAGE, sampler);

    return texture;
}
}
```

`src/graphics/win32/win32_d3d12_window.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/win32/win32_d3d12_window.h"

#include <any>
#include <optional>
#include <queue>

#define WIN32_LEAN_AND_MEAN
#include <ShellScalingApi.h>
#include <Windows.h>
#include <Windowsx.h>
#include <hidusage.h>

#include "core/auto_release.h"
#include "core/colour.h"
#include "core/exception.h"
#include "events/event.h"
#include "events/quit_event.h"
#include "graphics/d3d12/d3d12_renderer.h"
#include "graphics/material_manager.h"
#include "graphics/render_target.h"
#include "log/log.h"


#pragma comment(lib, "Shcore.lib")

namespace iris
{

Win32D3D12Window::Win32D3D12Window(
    WindowManager &window_manager,
    TextureManager &texture_manager,
    MaterialManager &material_manager,
    std::uint32_t width,
    std::uint32_t height)
    : Win32Window(width, height)
{
    renderer_ = std::make_unique<D3D12Renderer>(
        window_manager, texture_manager, material_manager, window_, width_, height_, screen_scale());

    ::SetWindowTextA(window_, "iris::d3d12");
}

}

```

`src/graphics/win32/win32_opengl_window.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/win32/win32_opengl_window.h"

#include <optional>
#include <queue>

#define WIN32_LEAN_AND_MEAN
#include <ShellScalingApi.h>
#include <Windows.h>
#include <Windowsx.h>
#include <hidusage.h>

#include "core/auto_release.h"
#include "core/error_handling.h"
#include "events/event.h"
#include "events/quit_event.h"
#include "graphics/material_manager.h"
#define DONT_MAKE_GL_FUNCTIONS_EXTERN // get concrete function pointers for all opengl functions
#include "graphics/opengl/opengl.h"
#include "graphics/opengl/opengl_renderer.h"

#pragma comment(lib, "Shcore.lib")

// additional functions we don't want to make public
HGLRC (*wglCreateContextAttribsARB)(HDC, HGLRC, const int *);
BOOL(*wglChoosePixelFormatARB)
(HDC, const int *, const FLOAT *, UINT, int *, UINT *);
BOOL (*wglSwapIntervalEXT)(int);

// x-macro argument to resolve functions
#define RESOLVE_FUNCTION(_, NAME, ...) resolve_opengl_function(NAME, #NAME);

namespace
{

/**
 * Helper function to resolve a single opengl function.
 *
 * @param function
 *   Reference to function pointer to resolve.
 *
 * @param name
 *   Name of function.
 */
template <class T>
void resolve_opengl_function(T &function, const std::string &name)
{
    const auto address = ::wglGetProcAddress(name.c_str());
    iris::ensure(address != NULL, "could not resolve: " + name);

    function = reinterpret_cast<T>(address);
}

/**
 * Helper function to resolve all opengl functions.
 */
void resolve_global_opengl_functions()
{
    FOR_OPENGL_FUNCTIONS(RESOLVE_FUNCTION);
}

/**
 * Helper function to resolve the wgl functions needed to setup an opengl
 * window.
 *
 * We cannot create a win32 opengl window without certain wgl functions, but
 * they cannot be resolved without a window.
 *
 * To get around this catch-22 we create a dummy window, resole the functions
 * then destroy the window. We are then free to setup a proper opengl window.
 *
 * @param instance
 *   A handle to the instance of the module to be associated with the window.
 */
void resolve_wgl_functions(HINSTANCE instance)
{
    // dummy window class
    WNDCLASSA wc = {};
    wc.lpfnWndProc = ::DefWindowProcA;
    wc.hInstance = instance;
    wc.lpszClassName = "dummy window class";
    wc.style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;

    iris::ensure(::RegisterClassA(&wc) != 0, "could not register class");

    // create dummy window
    const iris::Win32OpenGLWindow::AutoWindow dummy_window = {
        CreateWindowExA(
            0,
            wc.lpszClassName,
            "dummy window",
            0,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            0,
            0,
            wc.hInstance,
            0),
        ::DestroyWindow};

    iris::ensure(dummy_window, "could not create window");

    iris::Win32OpenGLWindow::AutoDC dc = {::GetDC(dummy_window), [&dummy_window](HDC dc) {
                                              ::ReleaseDC(dummy_window, dc);
                                          }};
    iris::ensure(dc, "could not get dc");

    // pixel format descriptor for dummy window
    PIXELFORMATDESCRIPTOR pfd = {0};
    pfd.nSize = sizeof(pfd);
    pfd.nVersion = 1;
    pfd.iPixelType = PFD_TYPE_RGBA;
    pfd.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER;
    pfd.cColorBits = 32;
    pfd.cAlphaBits = 8;
    pfd.iLayerType = PFD_MAIN_PLANE;
    pfd.cDepthBits = 24;
    pfd.cStencilBits = 8;

    const auto pixel_format = ::ChoosePixelFormat(dc, &pfd);
    iris::ensure(pixel_format != 0, "could not choose pixel format");

    if (::SetPixelFormat(dc, pixel_format, &pfd) == FALSE)
    {
        throw iris::Exception("could not set pixel format");
    }

    // get a wgl context
    const iris::AutoRelease<HGLRC, nullptr> context = {::wglCreateContext(dc), ::wglDeleteContext};
    iris::ensure(context, "could not create gl context");

    iris::ensure(::wglMakeCurrent(dc, context) == TRUE, "could not make current context");

    // resolve our needed functions
    resolve_opengl_function(wglChoosePixelFormatARB, "wglChoosePixelFormatARB");
    resolve_opengl_function(wglCreateContextAttribsARB, "wglCreateContextAttribsARB");
    resolve_opengl_function(wglSwapIntervalEXT, "wglSwapIntervalEXT");

    ::wglMakeCurrent(dc, 0);
}

/**
 * Initialise opengl for a window.
 *
 * @param dc
 *   Device context for window.
 */
void init_opengl(HDC dc)
{
    int pixel_format_attribs[] = {
        WGL_DRAW_TO_WINDOW_ARB,
        GL_TRUE,
        WGL_SUPPORT_OPENGL_ARB,
        GL_TRUE,
        WGL_DOUBLE_BUFFER_ARB,
        GL_TRUE,
        WGL_ACCELERATION_ARB,
        WGL_FULL_ACCELERATION_ARB,
        WGL_PIXEL_TYPE_ARB,
        WGL_TYPE_RGBA_ARB,
        WGL_COLOR_BITS_ARB,
        32,
        WGL_DEPTH_BITS_ARB,
        24,
        WGL_STENCIL_BITS_ARB,
        8,
        0};

    int pixel_format = 0;
    UINT num_formats = 0u;
    ::wglChoosePixelFormatARB(dc, pixel_format_attribs, 0, 1, &pixel_format, &num_formats);

    iris::ensure(num_formats != 0, "could not choose pixel format");

    // set pixel format

    PIXELFORMATDESCRIPTOR pfd;
    iris::ensure(::DescribePixelFormat(dc, pixel_format, sizeof(pfd), &pfd) != 0, "could not describe pixel format");

    iris::ensure(::SetPixelFormat(dc, pixel_format, &pfd) == TRUE, "could not set pixel format");

    // opengl 4.3
    int gl_attribs[] = {
        WGL_CONTEXT_MAJOR_VERSION_ARB,
        4,
        WGL_CONTEXT_MINOR_VERSION_ARB,
        3,
        WGL_CONTEXT_PROFILE_MASK_ARB,
        WGL_CONTEXT_CORE_PROFILE_BIT_ARB,
        0,
    };

    const auto context = ::wglCreateContextAttribsARB(dc, 0, gl_attribs);
    iris::ensure(context != NULL, "could not create gl context");

    iris::ensure(::wglMakeCurrent(dc, context) == TRUE, "could not set make current context");

    // disable vsync
    iris::ensure(::wglSwapIntervalEXT(0) == TRUE, "could not disable vsync");
}
}

namespace iris
{

Win32OpenGLWindow::Win32OpenGLWindow(
    WindowManager &window_manager,
    TextureManager &texture_manager,
    MaterialManager &material_manager,
    std::uint32_t width,
    std::uint32_t height)
    : Win32Window(width, height)
{
    // initialise opengl
    resolve_wgl_functions(wc_.hInstance);
    init_opengl(dc_);

    // we can now resolve all our opengl functions
    resolve_global_opengl_functions();

    renderer_ = std::make_unique<OpenGLRenderer>(window_manager, texture_manager, material_manager, width_, height_);

    ::SetWindowTextA(window_, "iris::opengl");
}

}

```

`src/graphics/win32/win32_window.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/win32/win32_window.h"

#include <cmath>
#include <optional>
#include <queue>
#include <set>

#define WIN32_LEAN_AND_MEAN
#include <ShellScalingApi.h>
#include <Windows.h>
#include <Windowsx.h>
#include <hidusage.h>

#include "core/auto_release.h"
#include "core/error_handling.h"
#include "events/event.h"
#include "events/keyboard_event.h"
#include "events/mouse_button_event.h"
#include "events/quit_event.h"
#include "events/scroll_wheel_event.h"
#include "graphics/texture_manager.h"
#include "graphics/window_manager.h"
#include "log/log.h"

#pragma comment(lib, "Shcore.lib")

namespace
{

// as we have to provide a callback to windows for event data and there is no
// way of passing in custom data we use a global queue to store events
std::queue<iris::Event> event_queue;

/**
 * Helper function to convert a windows key code to an engine key type.
 *
 * @param key_code
 *   Windows key code.
 *
 * @returns
 *   Engine Key.
 */
iris::Key windows_key_to_engine_Key(WPARAM key_code)
{
    iris::Key key;

    switch (key_code)
    {
        case 0x30: key = iris::Key::NUM_0; break;
        case 0x31: key = iris::Key::NUM_1; break;
        case 0x32: key = iris::Key::NUM_2; break;
        case 0x33: key = iris::Key::NUM_3; break;
        case 0x34: key = iris::Key::NUM_4; break;
        case 0x35: key = iris::Key::NUM_5; break;
        case 0x36: key = iris::Key::NUM_6; break;
        case 0x37: key = iris::Key::NUM_7; break;
        case 0x38: key = iris::Key::NUM_8; break;
        case 0x39: key = iris::Key::NUM_9; break;
        case 0x41: key = iris::Key::A; break;
        case 0x42: key = iris::Key::B; break;
        case 0x43: key = iris::Key::C; break;
        case 0x44: key = iris::Key::D; break;
        case 0x45: key = iris::Key::E; break;
        case 0x46: key = iris::Key::F; break;
        case 0x47: key = iris::Key::G; break;
        case 0x48: key = iris::Key::H; break;
        case 0x49: key = iris::Key::I; break;
        case 0x4a: key = iris::Key::J; break;
        case 0x4b: key = iris::Key::K; break;
        case 0x4c: key = iris::Key::L; break;
        case 0x4d: key = iris::Key::M; break;
        case 0x4e: key = iris::Key::N; break;
        case 0x4f: key = iris::Key::O; break;
        case 0x50: key = iris::Key::P; break;
        case 0x51: key = iris::Key::Q; break;
        case 0x52: key = iris::Key::R; break;
        case 0x53: key = iris::Key::S; break;
        case 0x54: key = iris::Key::T; break;
        case 0x55: key = iris::Key::U; break;
        case 0x56: key = iris::Key::V; break;
        case 0x57: key = iris::Key::W; break;
        case 0x58: key = iris::Key::X; break;
        case 0x59: key = iris::Key::Y; break;
        case 0x5a: key = iris::Key::Z; break;
        case VK_TAB: key = iris::Key::TAB; break;
        case VK_SPACE: key = iris::Key::SPACE; break;
        case VK_ESCAPE: key = iris::Key::ESCAPE; break;
        case VK_LSHIFT: key = iris::Key::SHIFT; break;
        case VK_RSHIFT: key = iris::Key::RIGHT_SHIFT; break;
        case VK_F17: key = iris::Key::F17; break;
        case VK_DECIMAL: key = iris::Key::KEYPAD_DECIMAL; break;
        case VK_MULTIPLY: key = iris::Key::KEYPAD_MULTIPLY; break;
        case VK_OEM_PLUS: key = iris::Key::KEYPAD_PLUS; break;
        case VK_VOLUME_UP: key = iris::Key::VOLUME_UP; break;
        case VK_VOLUME_DOWN: key = iris::Key::VOLUME_DOWN; break;
        case VK_VOLUME_MUTE: key = iris::Key::MUTE; break;
        case VK_DIVIDE: key = iris::Key::KEYPAD_DIVIDE; break;
        case VK_OEM_MINUS: key = iris::Key::KEYPAD_MINUS; break;
        case VK_F18: key = iris::Key::F18; break;
        case VK_F19: key = iris::Key::F19; break;
        case VK_NUMPAD0: key = iris::Key::KEYPAD_0; break;
        case VK_NUMPAD1: key = iris::Key::KEYPAD_1; break;
        case VK_NUMPAD2: key = iris::Key::KEYPAD_2; break;
        case VK_NUMPAD3: key = iris::Key::KEYPAD_3; break;
        case VK_NUMPAD4: key = iris::Key::KEYPAD_4; break;
        case VK_NUMPAD5: key = iris::Key::KEYPAD_5; break;
        case VK_NUMPAD6: key = iris::Key::KEYPAD_6; break;
        case VK_NUMPAD7: key = iris::Key::KEYPAD_7; break;
        case VK_F20: key = iris::Key::F20; break;
        case VK_NUMPAD8: key = iris::Key::KEYPAD_8; break;
        case VK_NUMPAD9: key = iris::Key::KEYPAD_9; break;
        case VK_F5: key = iris::Key::F5; break;
        case VK_F6: key = iris::Key::F6; break;
        case VK_F7: key = iris::Key::F7; break;
        case VK_F3: key = iris::Key::F3; break;
        case VK_F8: key = iris::Key::F8; break;
        case VK_F9: key = iris::Key::F9; break;
        case VK_F11: key = iris::Key::F11; break;
        case VK_F13: key = iris::Key::F13; break;
        case VK_F16: key = iris::Key::F16; break;
        case VK_F14: key = iris::Key::F14; break;
        case VK_F10: key = iris::Key::F10; break;
        case VK_F12: key = iris::Key::F12; break;
        case VK_F15: key = iris::Key::F15; break;
        case VK_HELP: key = iris::Key::HELP; break;
        case VK_HOME: key = iris::Key::HOME; break;
        case VK_F4: key = iris::Key::F4; break;
        case VK_END: key = iris::Key::END; break;
        case VK_F2: key = iris::Key::F2; break;
        case VK_F1: key = iris::Key::F1; break;
        case VK_LEFT: key = iris::Key::LEFT_ARROW; break;
        case VK_RIGHT: key = iris::Key::RIGHT_ARROW; break;
        case VK_DOWN: key = iris::Key::DOWN_ARROW; break;
        case VK_UP: key = iris::Key::UP_ARROW; break;
        default: key = iris::Key::UNKNOWN;
    }

    return key;
}

/**
 * Callback function for windows events.
 *
 * See:
 * https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)
 * for details
 */
LRESULT CALLBACK window_proc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT result = 0;

    static std::set<WPARAM> pressed{};

    switch (uMsg)
    {
        case WM_CLOSE: event_queue.emplace(iris::QuitEvent{}); break;
        case WM_KEYDOWN:
            if (!pressed.contains(wParam))
            {
                event_queue.emplace(iris::KeyboardEvent{windows_key_to_engine_Key(wParam), iris::KeyState::DOWN});
                pressed.emplace(wParam);
            }
            break;
        case WM_KEYUP:
            event_queue.emplace(iris::KeyboardEvent{windows_key_to_engine_Key(wParam), iris::KeyState::UP});
            pressed.erase(wParam);
            break;
        case WM_LBUTTONDOWN:
            event_queue.emplace(iris::MouseButtonEvent{iris::MouseButton::LEFT, iris::MouseButtonState::DOWN});
            break;
        case WM_LBUTTONUP:
            event_queue.emplace(iris::MouseButtonEvent{iris::MouseButton::LEFT, iris::MouseButtonState::UP});
            break;
        case WM_RBUTTONDOWN:
            event_queue.emplace(iris::MouseButtonEvent{iris::MouseButton::RIGHT, iris::MouseButtonState::DOWN});
            break;
        case WM_RBUTTONUP:
            event_queue.emplace(iris::MouseButtonEvent{iris::MouseButton::RIGHT, iris::MouseButtonState::UP});
            break;
        case WM_MOUSEWHEEL:
            event_queue.emplace(
                iris::ScrollWheelEvent{static_cast<float>(GET_WHEEL_DELTA_WPARAM(wParam)) / WHEEL_DELTA});
            break;
        case WM_INPUT:
        {
            UINT dwSize = sizeof(RAWINPUT);
            BYTE lpb[sizeof(RAWINPUT)];

            ::GetRawInputData(reinterpret_cast<HRAWINPUT>(lParam), RID_INPUT, lpb, &dwSize, sizeof(RAWINPUTHEADER));

            RAWINPUT raw = {0};
            std::memcpy(&raw, lpb, sizeof(raw));

            if (raw.header.dwType == RIM_TYPEMOUSE)
            {
                // get mouse delta from raw input data
                int x = raw.data.mouse.lLastX;
                int y = raw.data.mouse.lLastY;

                event_queue.emplace(iris::MouseEvent{static_cast<float>(x), static_cast<float>(y)});
            }
            else if ((raw.data.mouse.usButtonFlags & RI_MOUSE_WHEEL) == RI_MOUSE_WHEEL)
            {
                const auto delta = static_cast<float>(static_cast<std::uint16_t>(raw.data.mouse.usButtonData));
                event_queue.emplace(iris::ScrollWheelEvent{delta});
            }

            break;
        }
        default: result = ::DefWindowProc(hWnd, uMsg, wParam, lParam);
    }

    return result;
}

}

namespace iris
{

Win32Window::Win32Window(std::uint32_t width, std::uint32_t height)
    : Window(width, height)
    , window_()
    , dc_()
    , wc_()
{
    // ensure process is aware of high dpi monitors
    ensure(::SetProcessDpiAwareness(PROCESS_SYSTEM_DPI_AWARE) == S_OK, "could not set process dpi awareness");

    const auto instance = ::GetModuleHandleA(NULL);

    // create window class
    wc_ = {};
    wc_.lpfnWndProc = window_proc;
    wc_.hInstance = instance;
    wc_.lpszClassName = "window class";
    wc_.style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;

    ensure(::RegisterClassA(&wc_) != 0, "could not register class");

    // create RECT for specified window size
    RECT rect = {0};
    rect.right = static_cast<int>(width_);
    rect.bottom = static_cast<int>(height_);

    ensure(::AdjustWindowRect(&rect, WS_OVERLAPPEDWINDOW, false) != 0, "could not resize window");

    // create window
    // we cannot query dpi without first creating a window, so we will resize afterwards
    window_ = {
        CreateWindowExA(
            0,
            wc_.lpszClassName,
            "iris",
            WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            rect.right - rect.left,
            rect.bottom - rect.top,
            NULL,
            NULL,
            wc_.hInstance,
            NULL),
        ::DestroyWindow};
    ensure(window_, "could not create window");

    const auto screen_width = ::GetSystemMetrics(SM_CXSCREEN);
    const auto screen_height = ::GetSystemMetrics(SM_CYSCREEN);

    const auto scale = screen_scale();

    rect = {0};
    rect.right = static_cast<int>(width_ * scale);
    rect.bottom = static_cast<int>(height_ * scale);

    ensure(::AdjustWindowRect(&rect, WS_OVERLAPPEDWINDOW, false) != 0, "could not resize window");

    // ensure window size is correctly scaled for current dpi
    ensure(
        ::SetWindowPos(
            window_,
            window_,
            rect.left + (screen_width / 2) - ((width_ * scale) / 2),
            rect.top + (screen_height / 2) - ((height_ * scale) / 2),
            rect.right - rect.left,
            rect.bottom - rect.top,
            SWP_NOZORDER | SWP_NOACTIVATE) != 0,
        "could not set window position");

    dc_ = {::GetDC(window_), [this](HDC dc) { ::ReleaseDC(window_, dc); }};
    ensure(dc_, "could not get dc");

    ::ShowWindow(window_, SW_SHOW);
    ::UpdateWindow(window_);

    // register for raw mouse events
    RAWINPUTDEVICE rid;
    rid.usUsagePage = HID_USAGE_PAGE_GENERIC;
    rid.usUsage = HID_USAGE_GENERIC_MOUSE;
    rid.dwFlags = RIDEV_INPUTSINK;
    rid.hwndTarget = window_;

    ensure(::RegisterRawInputDevices(&rid, 1, sizeof(rid)) == TRUE, "could not register raw input device");

    // ensure mouse visibility reference count is 0 (mouse is hidden)
    while (::ShowCursor(FALSE) >= 0)
    {
    }

    auto clip_rect = rect;
    clip_rect.left += (screen_width / 2) - ((width_ * scale) / 2),
        clip_rect.bottom += (screen_height / 2) - ((height_ * scale) / 2),
        clip_rect.right += (screen_width / 2) - ((width_ * scale) / 2),
        clip_rect.top += (screen_height / 2) - ((height_ * scale) / 2);

    // confine cursor to window
    ensure(::ClipCursor(&clip_rect) == TRUE, "could not confine cursor");
}

std::uint32_t Win32Window::screen_scale() const
{
    return static_cast<std::uint32_t>(std::ceil(static_cast<float>(dpi()) / 96.0f));
}

std::optional<Event> Win32Window::pump_event()
{
    // non-blocking loop to drain all available windows messages
    MSG message = {0};
    while (::PeekMessageA(&message, NULL, 0, 0, PM_REMOVE) != 0)
    {
        ::TranslateMessage(&message);
        ::DispatchMessageA(&message);
    }

    std::optional<Event> event;

    // get next engine event if one exists
    if (!event_queue.empty())
    {
        event = event_queue.front();
        event_queue.pop();
    }

    return event;
}

HDC Win32Window::device_context() const
{
    return dc_;
}

std::uint32_t Win32Window::dpi() const
{
    return ::GetDpiForWindow(window_);
}

}

```

`src/graphics/win32/win32_window_manager.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/win32/win32_window_manager.h"

#include <cstdint>
#include <memory>

#include "core/error_handling.h"
#include "graphics/material_manager.h"
#include "graphics/win32/win32_d3d12_window.h"
#include "graphics/win32/win32_opengl_window.h"
#include "graphics/window.h"
#include "graphics/window_manager.h"

namespace iris
{

Win32WindowManager::Win32WindowManager(
    TextureManager &texture_manager,
    MaterialManager &material_manager,
    const std::string &graphics_api)
    : texture_manager_(texture_manager)
    , material_manager_(material_manager)
    , graphics_api_(graphics_api)
    , current_window_()
{
}

Window *Win32WindowManager::create_window(std::uint32_t width, std::uint32_t height)
{
    // only support onw window at the moment
    ensure(!current_window_, "window already created");

    if (graphics_api_ == "d3d12")
    {
        current_window_ = std::make_unique<Win32D3D12Window>(*this, texture_manager_, material_manager_, width, height);
    }
    else if (graphics_api_ == "opengl")
    {
        current_window_ =
            std::make_unique<Win32OpenGLWindow>(*this, texture_manager_, material_manager_, width, height);
    }
    else
    {
        throw Exception("unknown graphics api");
    }

    return current_window_.get();
}

Window *Win32WindowManager::current_window() const
{
    return current_window_.get();
}

}

```

`src/graphics/window.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "graphics/window.h"

#include <chrono>
#include <cstdint>
#include <deque>
#include <memory>

#include "graphics/render_pass.h"
#include "graphics/render_pipeline.h"
#include "graphics/render_target.h"

namespace iris
{

Window::Window(std::uint32_t width, std::uint32_t height)
    : width_(width)
    , height_(height)
    , renderer_(nullptr)
{
}

void Window::render() const
{
    renderer_->render();
}

std::uint32_t Window::width() const
{
    return width_;
}

std::uint32_t Window::height() const
{
    return height_;
}

void Window::set_render_pipeline(std::unique_ptr<RenderPipeline> render_pipeline)
{
    render_pipeline->clear_dirty_bit();
    renderer_->set_render_pipeline(std::move(render_pipeline));
}

std::chrono::milliseconds Window::time() const
{
    return renderer_->time();
}

}

```

`src/jobs/CMakeLists.txt`:

```txt
set(INCLUDE_ROOT "${PROJECT_SOURCE_DIR}/include/iris/jobs")

if(IRIS_ARCH MATCHES "X86_64")
    add_subdirectory("fiber")
endif()

add_subdirectory("thread")

target_sources(iris PRIVATE
    ${INCLUDE_ROOT}/concurrent_queue.h
    ${INCLUDE_ROOT}/context.h
    ${INCLUDE_ROOT}/job.h
    ${INCLUDE_ROOT}/job_system.h
    ${INCLUDE_ROOT}/job_system_manager.h)

```

`src/jobs/fiber/CMakeLists.txt`:

```txt
set(INCLUDE_ROOT "${PROJECT_SOURCE_DIR}/include/iris/jobs/fiber")

if(IRIS_PLATFORM MATCHES "MACOS" OR IRIS_PLATFORM MATCHES "LINUX")
  add_subdirectory("posix")
elseif(IRIS_PLATFORM MATCHES "WIN32")
  add_subdirectory("windows")
endif()

target_sources(iris PRIVATE
    ${INCLUDE_ROOT}/counter.h
    ${INCLUDE_ROOT}/fiber.h
    ${INCLUDE_ROOT}/fiber_job_system.h
    counter.cpp
    fiber_job_system.cpp
    fiber_job_system_manager.cpp)

```

`src/jobs/fiber/counter.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "jobs/fiber/counter.h"

#include <atomic>
#include <mutex>

namespace iris
{

Counter::Counter(int value)
    : value_(value)
    , mutex_()
{
}

Counter::operator int()
{
    std::unique_lock lock(mutex_);

    return value_;
}

void Counter::operator--()
{
    std::unique_lock lock(mutex_);

    --value_;
}

void Counter::operator--(int)
{
    std::unique_lock lock(mutex_);

    --value_;
}

}

```

`src/jobs/fiber/fiber_job_system.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "jobs/fiber/fiber_job_system.h"

#include <atomic>
#include <cassert>
#include <condition_variable>
#include <exception>
#include <memory>
#include <mutex>
#include <sstream>
#include <string>
#include <tuple>
#include <vector>

#include "core/auto_release.h"
#include "core/semaphore.h"
#include "core/thread.h"
#include "jobs/concurrent_queue.h"
#include "jobs/fiber/counter.h"
#include "jobs/fiber/fiber.h"
#include "jobs/job.h"
#include "log/log.h"

namespace
{

/**
 * This is the main function for the worker threads. It's responsible for
 * taking fibers off the queue, executing them and performing all necessary
 * bookkeeping.
 *
 * @param id
 *   Unique id for thread.
 *
 * @param jobs_semaphore
 *   Semaphore signaling how many fibers are available to run.
 *
 * @param running
 *   Flag to indicate if this thread should keep running.
 *
 * @param fibers
 *   Queue of fibers to pop from.e
 */
void job_thread(
    [[maybe_unused]] int id,
    iris::Semaphore &jobs_semaphore,
    std::atomic<bool> &running,
    iris::ConcurrentQueue<std::tuple<iris::Fiber *, iris::Counter *>> &fibers)
{
    iris::Fiber::thread_to_fiber();

    LOG_DEBUG("job_system", "{} thread start [{}]", id, (void *)*iris::Fiber::this_fiber());

    while (running)
    {
        // wait for jobs to become available
        jobs_semaphore.acquire();

        if (!running)
        {
            break;
        }

        // block and wait for fiber from queue, this should be low contention
        // as most of the waiting is handled by the semaphore
        auto [fiber, wait_counter] = fibers.dequeue();

        // we cannot safely use a fiber whilst it is resuming
        // as a fiber should never be in the resuming state for long (the time
        // it takes to suspend and return to previous context) we use a
        // primitive spin lock
        while (!fiber->is_safe())
        {
        }

        if (wait_counter == nullptr)
        {
            // if we have no wait counter then this is the first time we are
            // seeing this fibre - so start it
            fiber->start();
        }
        else
        {
            // if we have a wait counter then this is a suspended fiber thats
            // been put back on the queue

            if (*wait_counter == 0)
            {
                // wait counter of zero means all its children jobs have
                // finished so we can resume
                fiber->resume();

                // if nothing is waiting on us then we were a fire-and-forget
                // job so need to cleanup
                if (!fiber->is_being_waited_on())
                {
                    delete fiber;
                }
            }
            else
            {
                // we are still waiting on at least one child job to finish so
                // put the fiber back on the queue
                fibers.enqueue(fiber, wait_counter);
                jobs_semaphore.release();
            }
        }
    }

    LOG_DEBUG("job_system", "{} thread end [{}]", id, (void *)*iris::Fiber::this_fiber());

    // safe to cleanup fiber we created for thread
    delete *iris::Fiber::this_fiber();
    *iris::Fiber::this_fiber() = nullptr;
}

/**
 * If the main thread (which is not a fiber) wants to wait on a job then it
 * cannot. We bootstrap that by using traditional signaling primitives.
 *
 * @param jobs
 *   Jobs to wait on
 *
 * @param js
 *   Pointer to JoSystem.
 */
void bootstrap_first_job(const std::vector<iris::Job> &jobs, iris::FiberJobSystem *js)
{
    std::mutex m;
    std::condition_variable cv;
    std::atomic<bool> done = false;
    std::exception_ptr exception;

    // wrap everything up in a fire-and-forget job
    js->add_jobs({{[&cv, &done, &jobs, &exception, js]()
                   {
                       LOG_ENGINE_INFO("job_system", "bootstrap started");

                       try
                       {
                           // we can now call wait for jobs because we are
                           // within another fiber
                           js->wait_for_jobs(jobs);
                       }
                       catch (...)
                       {
                           // capture any exception
                           exception = std::current_exception();
                       }

                       // signal calling thread we are finished
                       done = true;
                       cv.notify_one();
                       LOG_ENGINE_INFO("job_system", "bootstrap lambda done");
                   }}});

    // block and wait for wrapping fiber to finish
    if (!done)
    {
        std::unique_lock lock(m);
        cv.wait(lock, [&done]() { return done.load(); });
    }

    LOG_ENGINE_INFO("job_system", "non-fiber wait complete");

    // rethrow any exception
    if (exception)
    {
        std::rethrow_exception(exception);
    }
}

}

namespace iris
{

FiberJobSystem::FiberJobSystem()
    : running_(true)
    , jobs_semaphore_()
    , workers_()
    , fibers_()
{
    auto thread_count = std::max(1u, std::thread::hardware_concurrency() - 1u);

    LOG_ENGINE_INFO("job_system", "creating {} threads", thread_count);
    for (auto i = 0u; i < thread_count; ++i)
    {
        workers_.emplace_back(job_thread, i + 1, std::ref(jobs_semaphore_), std::ref(running_), std::ref(fibers_));
    }
}

FiberJobSystem::~FiberJobSystem()
{
    running_ = false;

    for (auto i = 0u; i < workers_.size() + 1u; i++)
    {
        jobs_semaphore_.release();
    }

    for (auto &worker : workers_)
    {
        worker.join();
    }
}

void FiberJobSystem::add_jobs(const std::vector<Job> &jobs)
{
    for (const auto &job : jobs)
    {
        // we rely on the worker thread to clean up after us
        auto *f = new Fiber{job};

        fibers_.enqueue(f, nullptr);
        jobs_semaphore_.release();
    }
}

void FiberJobSystem::wait_for_jobs(const std::vector<Job> &jobs)
{
    if (*Fiber::this_fiber() == nullptr)
    {
        bootstrap_first_job(jobs, this);
    }
    else
    {
        auto counter = std::make_unique<Counter>(static_cast<int>(jobs.size()));
        std::vector<std::unique_ptr<Fiber>> fibers{};

        // create fibers and add to the queue
        for (const auto &job : jobs)
        {
            fibers.emplace_back(std::make_unique<Fiber>(job, counter.get()));

            fibers_.enqueue(fibers.back().get(), nullptr);
            jobs_semaphore_.release();
        }

        // mark current fiber as unsafe (so another thread doesn't preemptively
        // try to resume it), stick it on the queue
        (*Fiber::this_fiber())->set_unsafe();
        fibers_.enqueue(*Fiber::this_fiber(), counter.get());
        jobs_semaphore_.release();

        // suspend current thread - this will internally mark the fiber as safe
        (*Fiber::this_fiber())->suspend();

        // the above line will not return
        // if we get there then all children jobs have finished and resume has
        // been called

        std::exception_ptr job_exception;

        for (const auto &fiber : fibers)
        {
            // find first exception that was throw, first come first served
            if ((fiber->exception() != nullptr) && !job_exception)
            {
                job_exception = fiber->exception();
                break;
            }
        }

        if (job_exception)
        {
            std::rethrow_exception(job_exception);
        }
    }
}

}

```

`src/jobs/fiber/fiber_job_system_manager.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "jobs/fiber/fiber_job_system_manager.h"

#include <memory>
#include <vector>

#include "core/error_handling.h"
#include "jobs/fiber/fiber_job_system.h"
#include "jobs/job.h"
#include "jobs/job_system_manager.h"

namespace iris
{

JobSystem *FiberJobSystemManager::create_job_system()
{
    ensure(!job_system_, "job system already created");

    job_system_ = std::make_unique<FiberJobSystem>();
    return job_system_.get();
}

void FiberJobSystemManager::add(const std::vector<Job> &jobs)
{
    job_system_->add_jobs(jobs);
}

void FiberJobSystemManager::wait(const std::vector<Job> &jobs)
{
    job_system_->wait_for_jobs(jobs);
}
}

```

`src/jobs/fiber/posix/CMakeLists.txt`:

```txt
set(ARCH_ROOT "${PROJECT_SOURCE_DIR}/include/iris/jobs/arch/x86_64")

target_sources(iris PRIVATE
    fiber.cpp
    ${ARCH_ROOT}/context.h
    ${ARCH_ROOT}/functions.S)

```

`src/jobs/fiber/posix/fiber.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "jobs/fiber/fiber.h"

#include <atomic>
#include <cassert>
#include <cstddef>
#include <exception>
#include <memory>

#include "core/error_handling.h"
#include "core/static_buffer.h"
#include "jobs/context.h"
#include "jobs/job.h"
#include "log/log.h"

#if defined(__clang__)
#define NO_OPT __attribute__((noinline, optnone))
#elif defined(__GNUC__)
#define NO_OPT __attribute__((noinline, optimize("O0")))
#endif

extern "C"
{
    // these will be defined with arch specific assembler
    extern void save_context(iris::Context *);
    extern void restore_context(iris::Context *);
    extern void change_stack(void *stack);
}

namespace iris
{

struct Fiber::implementation
{
    std::unique_ptr<StaticBuffer> stack_buffer;
    std::byte *stack;
    Context context;
    Context suspended_context;

    // all these functions are noinline and noopt
    // we require a very strict ordering of instructions in order to save and
    // restore contexts and we don't want the compiler to alter that

    /**
     * Starts a Fiber. Once completed will restore the previously saved context.
     *
     * @param fiber
     *   Fiber to start.
     */
    NO_OPT static void do_start(Fiber *fiber)
    {
        try
        {
            // swap to new stack and execute job
            change_stack(fiber->impl_->stack);
            fiber->job_();
        }
        catch (...)
        {
            // store any exceptions so it can possibly be rethrown later
            if (fiber->exception_ == nullptr)
            {
                fiber->exception_ = std::current_exception();
            }
        }

        *this_fiber() = fiber->parent_fiber_;

        restore_context(&fiber->impl_->context);
    }

    /**
     * Suspend the Fiber.
     *
     * @param fiber
     *   Fiber to suspend.
     */
    NO_OPT static void do_suspend(Fiber *fiber)
    {
        // no code between these lines
        // restoring this saved context will cause execution to continue from
        // *after* the following line
        save_context(&fiber->impl_->suspended_context);
        restore_context(&fiber->impl_->context);

        // the above call will not return
        // we get here when the suspended context is restored
    }

    /**
     * Resume the Fiber.
     *
     * @param fiber
     *   Fiber to resume.
     *
     * @returns
     *   Always returns 0 - this is to prevent tail-call optimisation which
     *   can mess up the assembly calls.
     */
    NO_OPT static int do_resume(Fiber *fiber)
    {
        // store context so we can resume from here once our job has finished
        save_context(&fiber->impl_->context);
        restore_context(&fiber->impl_->suspended_context);

        return 0;
    }
};

Fiber::Fiber(Job job)
    : Fiber(job, nullptr)
{
}

Fiber::Fiber(Job job, Counter *counter)
    : job_(nullptr)
    , counter_(counter)
    , parent_fiber_(nullptr)
    , exception_(nullptr)
    , safe_(true)
    , impl_(std::make_unique<implementation>())
{
    job_ = job;

    impl_->stack_buffer = std::make_unique<StaticBuffer>(10u);

    // stack grows from high -> low memory so move our pointer down, not all the
    // way as we need some space to copy the previous stack frame
    impl_->stack = *impl_->stack_buffer + (StaticBuffer::page_size() * 9);
}

Fiber::~Fiber() = default;

void Fiber::start()
{
    // bookkeeping
    parent_fiber_ = *this_fiber();
    *this_fiber() = this;

    // save our context and kick off the job, we will return from here when the
    // job is done (but possible on a different thread)
    save_context(&impl_->context);
    implementation::do_start(this);

    if (!safe_)
    {
        // we are no longer suspending if we are here i.e. it is now safe for
        // another thread to pick us up
        safe_ = true;
    }
    else
    {
        // update counter if another fiber was waiting on us
        if (counter_ != nullptr)
        {
            (*counter_)--;
        }
    }
}

void Fiber::suspend()
{
    *this_fiber() = parent_fiber_;

    implementation::do_suspend(this);

    // if we get here then we have been resumed, so rethrow any stored
    // exception
    if (exception_)
    {
        std::rethrow_exception(exception_);
    }
}

void Fiber::resume()
{
    // bookkeeping
    parent_fiber_ = *this_fiber();
    *this_fiber() = this;

    implementation::do_resume(this);

    if (!safe_)
    {
        // we are no longer suspending if we are here i.e. it is now safe for
        // another thread to pick us up
        safe_ = true;
    }
    else
    {
        // update counter if another fiber was waiting on us
        if (counter_ != nullptr)
        {
            (*counter_)--;
        }
    }
}

bool Fiber::is_safe() const
{
    return safe_;
}

void Fiber::set_unsafe()
{
    safe_ = false;
}

bool Fiber::is_being_waited_on() const
{
    return counter_ != nullptr;
}

std::exception_ptr Fiber::exception() const
{
    return exception_;
}

void Fiber::thread_to_fiber()
{
    expect(*this_fiber() == nullptr, "thread already a fiber");

    // thread will clean this up when it ends
    *this_fiber() = new Fiber(nullptr);
}

Fiber **Fiber::this_fiber()
{
    // this allows us to get a pointer to the fiber being executed in the
    // current thread
    thread_local Fiber *current_fiber = nullptr;
    return &current_fiber;
}

}

```

`src/jobs/fiber/windows/CMakeLists.txt`:

```txt
target_sources(iris PRIVATE fiber.cpp)

```

`src/jobs/fiber/windows/fiber.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "jobs/fiber/fiber.h"

#include <cassert>
#include <exception>

#include <Windows.h>

#include "core/auto_release.h"
#include "core/error_handling.h"
#include "jobs/job.h"

namespace iris
{

// we disable optimisations for job_runner as the inlining messes up with the
// fiber resuming code
#pragma optimize("", off)
struct Fiber::implementation
{
    AutoRelease<LPVOID, nullptr> handle;

    /**
     * Start function for win32 fiber.
     *
     * @param data
     *   Data passed to start function.
     */
    static void job_runner(void *data)
    {

        auto *fiber = static_cast<Fiber *>(data);
        *this_fiber() = fiber;

        try
        {
            fiber->job_();
        }
        catch (...)
        {
            // store any exceptions so it can possibly be rethrown later
            if (fiber->exception_ == nullptr)
            {
                fiber->exception_ = std::current_exception();
            }
        }

        fiber->parent_fiber_->resume();
    }
};
#pragma optimize("", on)

Fiber::Fiber(Job job)
    : Fiber(job, nullptr)
{
}

Fiber::Fiber(Job job, Counter *counter)
    : job_()
    , counter_(counter)
    , parent_fiber_(nullptr)
    , exception_(nullptr)
    , safe_(true)
    , impl_(std::make_unique<Fiber::implementation>())
{
    job_ = job;
    impl_->handle = {
        ::CreateFiberEx(0, 0, FIBER_FLAG_FLOAT_SWITCH, reinterpret_cast<LPFIBER_START_ROUTINE>(implementation::job_runner), static_cast<void *>(this)),
        ::DeleteFiber};

    expect(impl_->handle, "create fiber failed");
}

Fiber::~Fiber() = default;

void Fiber::start()
{
    // bookkeeping
    parent_fiber_ = *this_fiber();
    *this_fiber() = this;

    // switch to fiber (this will kick-off the job)
    ::SwitchToFiber(impl_->handle);

    if (!safe_)
    {
        // we are no longer suspending if we are here i.e. it is now safe for
        // another thread to pick us up
        safe_ = true;
    }
    else
    {
        // update counter if another fiber was waiting on us
        if (counter_ != nullptr)
        {
            --(*counter_);
        }
    }
}

void Fiber::suspend()
{
    *this_fiber() = parent_fiber_;

    ::SwitchToFiber(parent_fiber_->impl_->handle);

    // if we get here then we have been resumed, so rethrow any stored
    // exception
    if (exception_ != nullptr)
    {
        std::rethrow_exception(exception_);
    }
}

void Fiber::resume()
{
    // bookkeeping
    parent_fiber_ = *this_fiber();
    *this_fiber() = this;

    ::SwitchToFiber(impl_->handle);

    if (!safe_)
    {
        // we are no longer suspending if we are here i.e. it is now safe for
        // another thread to pick us up
        safe_ = true;
    }
    else
    {
        // update counter if another fiber was waiting on us
        if (counter_ != nullptr)
        {
            --(*counter_);
        }
    }
}

bool Fiber::is_safe() const
{
    return safe_;
}

void Fiber::set_unsafe()
{
    safe_ = false;
}

bool Fiber::is_being_waited_on() const
{
    return counter_ != nullptr;
}

std::exception_ptr Fiber::exception() const
{
    return exception_;
}

void Fiber::thread_to_fiber()
{
    expect(*this_fiber() == nullptr, "thread already a fiber");

    // thread will clean this up when it ends
    auto *fiber = new Fiber{nullptr, nullptr};

    fiber->impl_->handle = {::ConvertThreadToFiberEx(NULL, FIBER_FLAG_FLOAT_SWITCH), [fiber](auto) {
                                ::ConvertFiberToThread();
                            }};

    expect(fiber->impl_->handle, "convert thread to fiber failed");

    *this_fiber() = fiber;
}

Fiber **Fiber::this_fiber()
{
    // this allows us to get a pointer to the fiber being executed in the
    // current thread
    thread_local Fiber *this_fiber = nullptr;
    return &this_fiber;
}

}

```

`src/jobs/thread/CMakeLists.txt`:

```txt
set(INCLUDE_ROOT "${PROJECT_SOURCE_DIR}/include/iris/jobs/thread")

target_sources(iris PRIVATE
    ${INCLUDE_ROOT}/thread_job_system.h
    ${INCLUDE_ROOT}/thread_job_system_manager.h
    thread_job_system.cpp
    thread_job_system_manager.cpp)


```

`src/jobs/thread/thread_job_system.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "jobs/thread/thread_job_system.h"

#include <chrono>
#include <future>
#include <vector>

#include "jobs/job.h"
#include "log/log.h"

namespace iris
{

ThreadJobSystem::ThreadJobSystem()
    : running_(true)
{
}

void ThreadJobSystem::add_jobs(const std::vector<Job> &jobs)
{
    for (const auto &job : jobs)
    {
        // we cannot simply call std::async here as the std::future destructor
        // will block and wait for the job to finish
        // instead we create a shared_ptr for the future and copy it by value
        // into the async task
        // this ensures it keeps a reference to itself and won't go out of
        // scope until the job is complete
        auto future = std::make_shared<std::future<void>>();

        *future = std::async(std::launch::async, [future, job] { job(); });
    }
}

void ThreadJobSystem::wait_for_jobs(const std::vector<Job> &jobs)
{
    std::vector<std::future<void>> waiting_jobs{};

    for (const auto &job : jobs)
    {
        waiting_jobs.emplace_back(std::async(std::launch::async, job));
    }

    for (auto &waiting_job : waiting_jobs)
    {
        waiting_job.get();
    }
}
}

```

`src/jobs/thread/thread_job_system_manager.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "jobs/thread/thread_job_system_manager.h"

#include <memory>
#include <vector>

#include "core/error_handling.h"
#include "jobs/job.h"
#include "jobs/job_system_manager.h"
#include "jobs/thread/thread_job_system.h"

namespace iris
{

JobSystem *ThreadJobSystemManager::create_job_system()
{
    ensure(job_system_ == nullptr, "job system already created");

    job_system_ = std::make_unique<ThreadJobSystem>();
    return job_system_.get();
}

void ThreadJobSystemManager::add(const std::vector<Job> &jobs)
{
    job_system_->add_jobs(jobs);
}

void ThreadJobSystemManager::wait(const std::vector<Job> &jobs)
{
    job_system_->wait_for_jobs(jobs);
}

}

```

`src/log/CMakeLists.txt`:

```txt
set(INCLUDE_ROOT "${PROJECT_SOURCE_DIR}/include/iris/log")

target_sources(iris PRIVATE
    ${INCLUDE_ROOT}/basic_formatter.h
    ${INCLUDE_ROOT}/colour_formatter.h
    ${INCLUDE_ROOT}/emoji_formatter.h
    ${INCLUDE_ROOT}/file_outputter.h
    ${INCLUDE_ROOT}/log_level.h
    ${INCLUDE_ROOT}/log.h
    ${INCLUDE_ROOT}/logger.h
    ${INCLUDE_ROOT}/stdout_outputter.h
    basic_formatter.cpp
    colour_formatter.cpp
    emoji_formatter.cpp
    file_outputter.cpp
    stdout_outputter.cpp)

```

`src/log/basic_formatter.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "log/basic_formatter.h"

#include <chrono>
#include <filesystem>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>

#include "log/log_level.h"

namespace
{

/**
 * Helper function to extract just the filename from a full path.
 *
 * @param filename
 *   Filename to extract from.
 *
 * @returns
 *   Filename from supplied string.
 */
std::string format_filename(const std::string &filename)
{
    // find last occurrence of file separator
    const auto index = filename.rfind(std::filesystem::path::preferred_separator);

    return std::string{filename.substr(index + 1)};
}

/**
 * Convert log level to string and get first character.
 *
 * @param level
 *   Log level to get first character of.
 *
 * @returns
 *   First character of log level.
 */
char first_char_of_level(const iris::LogLevel level)
{
    std::stringstream strm{};
    strm << level;

    const auto str = strm.str();

    return !str.empty() ? str.front() : 'U';
}

}

namespace iris
{

std::string BasicFormatter::format(
    const LogLevel level,
    const std::string &tag,
    const std::string &message,
    const std::string &filename,
    const int line)
{
    const auto now = std::chrono::system_clock::now();
    const auto seconds = std::chrono::duration_cast<std::chrono::seconds>(now.time_since_epoch());

    std::stringstream strm{};

    strm << first_char_of_level(level) << " " << seconds.count() << " [" << tag << "] " << format_filename(filename)
         << ":" << line << " | " << message;
    return strm.str();
}

}

```

`src/log/colour_formatter.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "log/colour_formatter.h"

#include <chrono>
#include <filesystem>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>

#include "log/log_level.h"

namespace iris
{

std::string ColourFormatter::format(
    const LogLevel level,
    const std::string &tag,
    const std::string &message,
    const std::string &filename,
    const int line)
{
    std::stringstream strm{};

    // apply an ANSI escape sequence to start colour output
    switch (level)
    {
        case LogLevel::DEBUG: strm << "\x1b[35m"; break;
        case LogLevel::INFO: strm << "\x1b[34m"; break;
        case LogLevel::WARN: strm << "\x1b[33m"; break;
        case LogLevel::ERR: strm << "\x1b[31m"; break;
        default: break;
    }

    // write message and reset ANSI escape code
    strm << formatter_.format(level, tag, message, filename, line) << "\x1b[0m";

    return strm.str();
}

}

```

`src/log/emoji_formatter.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "log/emoji_formatter.h"

#include <chrono>
#include <filesystem>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>

#include "log/log_level.h"

namespace iris
{

std::string EmojiFormatter::format(
    const LogLevel level,
    const std::string &tag,
    const std::string &message,
    const std::string &filename,
    const int line)
{
    std::stringstream strm{};

    // apply an emoji to start of output
    // depending on your text editor the emojis below may not display, but they
    // are there!
    switch (level)
    {
        case LogLevel::DEBUG: strm << "🔵 "; break;
        case LogLevel::INFO: strm << "ℹ️ "; break;
        case LogLevel::WARN: strm << "⚠️ "; break;
        case LogLevel::ERR: strm << "❌ "; break;
        default: break;
    }

    // write message
    strm << formatter_.format(level, tag, message, filename, line);

    return strm.str();
}

}

```

`src/log/file_outputter.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "log/file_outputter.h"

#include <string>

#include "core/error_handling.h"

namespace iris
{

FileOutputter::FileOutputter(const std::string &filename)
    : file_(filename, std::ios::out | std::ios::app)
{
    // better check all of these
    ensure(file_.is_open() && !file_.bad() && file_.good() && !file_.fail(), "failed to open log file");
}

void FileOutputter::output(const std::string &log)
{
    file_ << log << std::endl;
}

}

```

`src/log/stdout_outputter.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "log/stdout_outputter.h"

#include <iostream>
#include <string>

namespace iris
{

void StdoutFormatter::output(const std::string &log)
{
    std::cout << log << std::endl;
}

}

```

`src/networking/CMakeLists.txt`:

```txt
set(INCLUDE_ROOT "${PROJECT_SOURCE_DIR}/include/iris/networking")

if(IRIS_PLATFORM MATCHES "WIN32")
  add_subdirectory("win32")
endif()

target_sources(iris PRIVATE
    ${INCLUDE_ROOT}/channel/channel.h
    ${INCLUDE_ROOT}/channel/channel_type.h
    ${INCLUDE_ROOT}/channel/reliable_ordered_channel.h
    ${INCLUDE_ROOT}/channel/unreliable_sequenced_channel.h
    ${INCLUDE_ROOT}/channel/unreliable_unordered_channel.h
    ${INCLUDE_ROOT}/client_connection_handler.h
    ${INCLUDE_ROOT}/data_buffer_deserialiser.h
    ${INCLUDE_ROOT}/data_buffer_serialiser.h
    ${INCLUDE_ROOT}/networking.h
    ${INCLUDE_ROOT}/packet.h
    ${INCLUDE_ROOT}/packet_type.h
    ${INCLUDE_ROOT}/server_connection_handler.h
    ${INCLUDE_ROOT}/server_socket.h
    ${INCLUDE_ROOT}/simulated_server_socket.h
    ${INCLUDE_ROOT}/simulated_socket.h
    ${INCLUDE_ROOT}/socket.h
    ${INCLUDE_ROOT}/udp_server_socket.h
    ${INCLUDE_ROOT}/udp_socket.h
    channel/channel.cpp
    channel/reliable_ordered_channel.cpp
    channel/unreliable_sequenced_channel.cpp
    channel/unreliable_unordered_channel.cpp
    client_connection_handler.cpp
    packet.cpp
    server_connection_handler.cpp
    simulated_server_socket.cpp
    simulated_socket.cpp
    udp_server_socket.cpp
    udp_socket.cpp)

```

`src/networking/channel/channel.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "networking/channel/channel.h"

namespace iris
{

std::vector<Packet> Channel::yield_send_queue()
{
    std::vector<Packet> queue;
    std::swap(queue, send_queue_);
    return queue;
}

std::vector<Packet> Channel::yield_receive_queue()
{
    std::vector<Packet> queue;
    std::swap(queue, receive_queue_);
    return queue;
}

}

```

`src/networking/channel/reliable_ordered_channel.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "networking/channel/reliable_ordered_channel.h"

#include <algorithm>
#include <vector>

#include "networking/packet.h"

namespace iris
{

ReliableOrderedChannel::ReliableOrderedChannel()
    : Channel()
    , next_receive_seq_(0u)
    , out_sequence_(0u)
{
}

void ReliableOrderedChannel::enqueue_send(Packet packet)
{
    // set sequence number of each packet to be once greater than the previous
    packet.set_sequence(out_sequence_);
    ++out_sequence_;

    send_queue_.emplace_back(std::move(packet));
}

void ReliableOrderedChannel::enqueue_receive(Packet packet)
{
    if (packet.type() == PacketType::ACK)
    {
        // we got an ack so remove the corresponding packet from the send queue
        // also use the opportunity to purge acks we've sent from the send queue
        send_queue_.erase(
            std::remove_if(
                std::begin(send_queue_),
                std::end(send_queue_),
                [&packet](const Packet &p)
                { return (p.type() == PacketType::ACK) || (p.sequence() == packet.sequence()); }),
            std::end(send_queue_));
    }
    else
    {
        // we got non-ack i.e. something we will want to yield

        // we only care about packets which are the one we are expecting or
        // after, anything before will have been yielded
        if (packet.sequence() >= next_receive_seq_)
        {
            // calculate index of packet into our receive queue
            const auto index = static_cast<std::size_t>(packet.sequence() - next_receive_seq_);

            // if index is larger than queue then grow the queue
            if (index >= receive_queue_.size())
            {
                receive_queue_.resize(receive_queue_.size() + index + 1u);
            }

            // if this is a new packet i.e. not a duplicate then put it in the
            // queue
            if (!receive_queue_[index].is_valid())
            {
                receive_queue_[index] = packet;
            }
        }

        // always send an ack, this is because acks aren't reliable so we may
        // keep receiving the same packet until an ack finally makes it
        // this is why we discard duplicates but still ack
        Packet ack{PacketType::ACK, ChannelType::RELIABLE_ORDERED, {}};
        ack.set_sequence(packet.sequence());
        send_queue_.emplace_back(std::move(ack));
    }
}

std::vector<Packet> ReliableOrderedChannel::yield_send_queue()
{
    // note that we don't yield the queue but return a copy, this is because
    // we want to keep sending packets until we receive an ack

    return send_queue_;
}

std::vector<Packet> ReliableOrderedChannel::yield_receive_queue()
{
    // find the first non-valid packet, everything before that will be a
    // continuous range of valid packets ready to be yielded
    const auto end_of_valid = std::find_if(
        std::cbegin(receive_queue_),
        std::cend(receive_queue_),
        [](const Packet &element) { return !element.is_valid(); });

    std::vector<Packet> packets{};

    if (end_of_valid != std::cbegin(receive_queue_))
    {
        // move packets from queue to output collection
        packets = std::vector<Packet>(std::cbegin(receive_queue_), end_of_valid);
        receive_queue_.erase(std::begin(receive_queue_), end_of_valid);

        // our next expected sequence number will be one greater than the last
        // packet we yield
        next_receive_seq_ = packets.back().sequence() + 1u;
    }

    return packets;
}

}

```

`src/networking/channel/unreliable_sequenced_channel.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "networking/channel/unreliable_sequenced_channel.h"
#include <vector>

namespace iris
{

UnreliableSequencedChannel::UnreliableSequencedChannel()
    : Channel()
    , min_sequence_(0u)
    , send_sequence_(0u)
{
}

void UnreliableSequencedChannel::enqueue_send(Packet packet)
{
    // set sequence number of each packet to be once greater than the previous
    packet.set_sequence(send_sequence_);
    send_queue_.emplace_back(std::move(packet));

    ++send_sequence_;
}

void UnreliableSequencedChannel::enqueue_receive(Packet packet)
{
    // discard all packets that are behind the largest sequence number we've
    // seen
    if (packet.sequence() >= min_sequence_)
    {
        receive_queue_.emplace_back(std::move(packet));

        // by always incrementing here we automatically drop duplicates
        min_sequence_ = receive_queue_.back().sequence() + 1u;
    }
}

}

```

`src/networking/channel/unreliable_unordered_channel.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "networking/channel/unreliable_unordered_channel.h"

namespace iris
{

void UnreliableUnorderedChannel::enqueue_send(Packet packet)
{
    send_queue_.emplace_back(std::move(packet));
}

void UnreliableUnorderedChannel::enqueue_receive(Packet packet)
{
    receive_queue_.emplace_back(std::move(packet));
}

}

```

`src/networking/client_connection_handler.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "networking/client_connection_handler.h"

#include <algorithm>
#include <cassert>
#include <chrono>
#include <cstddef>
#include <cstdint>
#include <cstdlib>
#include <cstring>
#include <exception>
#include <functional>
#include <limits>
#include <memory>
#include <string>

#include "core/context.h"
#include "core/data_buffer.h"
#include "core/error_handling.h"
#include "jobs/concurrent_queue.h"
#include "jobs/job.h"
#include "jobs/job_system_manager.h"
#include "log/log.h"
#include "networking/channel/channel.h"
#include "networking/channel/reliable_ordered_channel.h"
#include "networking/channel/unreliable_sequenced_channel.h"
#include "networking/channel/unreliable_unordered_channel.h"
#include "networking/data_buffer_deserialiser.h"
#include "networking/data_buffer_serialiser.h"
#include "networking/packet.h"
#include "networking/socket.h"

namespace
{

/**
 * Initiate and perform a handshake with the server.
 *
 * @param socket
 *   Socket for the connection.
 *
 * @param channel
 *   Channel to perform handshake on.
 */
std::uint32_t handshake(iris::Socket *socket, iris::Channel *channel)
{
    auto id = std::numeric_limits<std::uint32_t>::max();

    // create and enqueue a HELLO packet
    static const auto hello = iris::Packet(iris::PacketType::HELLO, iris::ChannelType::RELIABLE_ORDERED, {});
    channel->enqueue_send(hello);

    // send all packets
    for (const auto &packet : channel->yield_send_queue())
    {
        socket->write(packet.data(), packet.packet_size());
    }

    // keep going until we complete handshake
    for (;;)
    {
        // read a packet
        const auto raw_packet = socket->read(sizeof(iris::Packet));
        iris::Packet packet{raw_packet};

        // enqueue the packet into the channel
        channel->enqueue_receive(std::move(packet));

        // get all received packets
        const auto responses = channel->yield_receive_queue();

        // find the CONNECTED packet
        const auto connected = std::find_if(
            std::cbegin(responses),
            std::cend(responses),
            [](const iris::Packet &p) { return p.type() == iris::PacketType::CONNECTED; });

        // if we got it then get the id from the server and stop looping
        if (connected != std::cend(responses))
        {
            iris::DataBufferDeserialiser deserialiser{connected->body_buffer()};
            id = deserialiser.pop<std::uint32_t>();
            break;
        }
    }

    iris::ensure(id == std::numeric_limits<std::uint32_t>::max(), "connection timeout");

    LOG_ENGINE_INFO("client_connection_handler", "i am: {}", id);

    return id;
}

/**
 * Helper function to handle the start of a sync.
 *
 * @param channel
 *   The channel to communicate on.
 *
 * @param socket
 *   Socket for the connection.
 */
void handle_sync_start(iris::Channel *channel, iris::Socket *socket)
{
    // serialise our time
    const auto now =
        std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now().time_since_epoch());
    iris::DataBufferSerialiser serialiser{};
    serialiser.push<std::uint32_t>(static_cast<std::uint32_t>(now.count()));

    // create and enqueue SYNC_RESPONSE
    iris::Packet response{iris::PacketType::SYNC_RESPONSE, iris::ChannelType::RELIABLE_ORDERED, serialiser.data()};
    channel->enqueue_send(std::move(response));

    // send all packets
    for (const auto &packet : channel->yield_send_queue())
    {
        socket->write(packet.data(), packet.packet_size());
    }
}

/**
 * Helper function to handle sync finish.
 *
 * @param packet
 *   SYNC_FINSIH packet.
 *
 * @returns
 *   Estimate of lag between client and server.
 */
std::chrono::milliseconds handle_sync_finish(const iris::Packet &packet)
{
    // deserialise times sent from server
    iris::DataBufferDeserialiser deserialiser{packet.body_buffer()};
    const auto [client_time_raw, server_time_raw] = deserialiser.pop_tuple<std::uint32_t, std::uint32_t>();
    const std::chrono::milliseconds client_time(client_time_raw);
    const std::chrono::milliseconds server_time(server_time_raw);

    // estimate lag
    const auto server_to_client = std::chrono::duration_cast<std::chrono::milliseconds>(
        std::chrono::steady_clock::now().time_since_epoch() - server_time);
    const auto client_to_server = server_time - client_time;

    return server_to_client + client_to_server;
}

}

namespace iris
{

ClientConnectionHandler::ClientConnectionHandler(Context &context, std::unique_ptr<Socket> socket)
    : socket_(std::move(socket))
    , id_(std::numeric_limits<std::uint32_t>::max())
    , lag_(0u)
    , channels_()
    , queues_()
{
    // setup channels
    channels_[ChannelType::UNRELIABLE_UNORDERED] = std::make_unique<UnreliableUnorderedChannel>();
    channels_[ChannelType::UNRELIABLE_SEQUENCED] = std::make_unique<UnreliableSequencedChannel>();
    channels_[ChannelType::RELIABLE_ORDERED] = std::make_unique<ReliableOrderedChannel>();

    queues_[ChannelType::UNRELIABLE_UNORDERED] = std::make_unique<ConcurrentQueue<DataBuffer>>();
    queues_[ChannelType::UNRELIABLE_SEQUENCED] = std::make_unique<ConcurrentQueue<DataBuffer>>();
    queues_[ChannelType::RELIABLE_ORDERED] = std::make_unique<ConcurrentQueue<DataBuffer>>();

    id_ = handshake(socket_.get(), channels_[ChannelType::RELIABLE_ORDERED].get());

    LOG_ENGINE_INFO("client_connection_handler", "connected!");

    // we want to continually read data as fast as possible, so we do reading in
    // a background job
    // this will handle any protocol packets and stick data into queues, which
    // can then be retrieved by calls to try_read
    context.jobs_manager().add(
        {[this]()
         {
             for (;;)
             {
                 // block and read the next Packet
                 const auto raw_packet = socket_->read(sizeof(Packet));
                 iris::Packet packet{raw_packet};

                 // enqueue the packet into the right channel
                 const auto channel_type = packet.channel();
                 auto *channel = channels_.at(channel_type).get();
                 channel->enqueue_receive(std::move(packet));

                 // handle all received packets from that channel
                 for (const auto &p : channel->yield_receive_queue())
                 {
                     switch (p.type())
                     {
                         case PacketType::DATA:
                             // we got data, stick it in the queue for this
                             // channel
                             queues_[channel_type]->enqueue(p.body_buffer());
                             break;
                         case PacketType::SYNC_START: handle_sync_start(channel, socket_.get()); break;
                         case PacketType::SYNC_FINISH: lag_ = handle_sync_finish(packet); break;
                         default:
                             LOG_ERROR(
                                 "client_connection_handler", "unknown packet type {}", static_cast<int>(p.type()));
                             break;
                     }
                 }
             }
         }});
}

std::optional<DataBuffer> ClientConnectionHandler::try_read(ChannelType channel_type)
{
    DataBuffer buffer;

    // try and read data from the supplied channel
    return queues_[channel_type]->try_dequeue(buffer) ? std::optional<DataBuffer>{buffer} : std::nullopt;
}

void ClientConnectionHandler::send(const DataBuffer &data, ChannelType channel_type)
{
    auto *channel = channels_[channel_type].get();

    // wrap data in a Packet and enqueue
    Packet packet{PacketType::DATA, channel_type, data};
    channel->enqueue_send(std::move(packet));

    // send all packets
    for (const auto &p : channel->yield_send_queue())
    {
        socket_->write(p.data(), p.packet_size());
    }
}

void ClientConnectionHandler::flush()
{
    for (auto &[type, channel] : channels_)
    {
        for (const auto &p : channel->yield_send_queue())
        {
            socket_->write(p.data(), p.packet_size());
        }
    }
}

std::uint32_t ClientConnectionHandler::id() const
{
    return id_;
}

std::chrono::milliseconds ClientConnectionHandler::lag() const
{
    return lag_;
}

}

```

`src/networking/packet.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "networking/packet.h"

#include <algorithm>
#include <cstddef>
#include <cstdint>
#include <cstring>
#include <ostream>

#include "core/data_buffer.h"
#include "core/error_handling.h"
#include "networking/channel/channel_type.h"
#include "networking/packet_type.h"

namespace iris
{

Packet::Packet()
    : Packet(PacketType::INVAlID, ChannelType::INVAlID, {})
{
}

Packet::Packet(PacketType type, ChannelType channel, const DataBuffer &body)
    : header_(type, channel)
    , body_()
    , size_(body.size())
{
    expect(body.size() <= sizeof(body_), "body too large");

    std::memcpy(body_, body.data(), body.size());
}

Packet::Packet(const DataBuffer &raw_packet)
    : Packet()
{
    const auto size_to_copy = std::min<std::size_t>(128ul, raw_packet.size());

    std::memcpy(this, raw_packet.data(), size_to_copy);

    size_ = size_to_copy - sizeof(Header);
}

const std::byte *Packet::data() const
{
    return reinterpret_cast<const std::byte *>(this);
}

std::byte *Packet::data()
{
    return reinterpret_cast<std::byte *>(this);
}

const std::byte *Packet::body() const
{
    return body_;
}

std::byte *Packet::body()
{
    return body_;
}

DataBuffer Packet::body_buffer() const
{
    return DataBuffer(body(), body() + size_);
}

std::size_t Packet::packet_size() const
{
    // sanity check the Packet class is the expected size
    static_assert(sizeof(Packet) == 128 + sizeof(size_), "packet has invalid size");

    return sizeof(Header) + body_size();
}

std::size_t Packet::body_size() const
{
    return size_;
}

PacketType Packet::type() const
{
    return header_.type;
}

ChannelType Packet::channel() const
{
    return header_.channel;
}

bool Packet::is_valid() const
{
    return header_.type != PacketType::INVAlID;
}

std::uint16_t Packet::sequence() const
{
    return header_.sequence;
}

void Packet::set_sequence(std::uint16_t sequence)
{
    header_.sequence = sequence;
}

bool Packet::operator==(const Packet &other) const
{
    return ((packet_size() == other.packet_size()) && (std::memcmp(data(), other.data(), packet_size()) == 0));
}

bool Packet::operator!=(const Packet &other) const
{
    return !(*this == other);
}

std::ostream &operator<<(std::ostream &out, const Packet &packet)
{
    switch (packet.header_.type)
    {
        case PacketType::INVAlID: out << "INVALID"; break;
        case PacketType::HELLO: out << "HELLO"; break;
        case PacketType::CONNECTED: out << "CONNECTED"; break;
        case PacketType::DATA: out << "DATA"; break;
        case PacketType::ACK: out << "ACK"; break;
        default: out << "UNKNOWN"; break;
    }

    out << ", ";

    switch (packet.header_.channel)
    {
        case ChannelType::INVAlID: out << "INVALID"; break;
        case ChannelType::UNRELIABLE_UNORDERED: out << "UNRELIABLE_UNORDERED"; break;
        case ChannelType::UNRELIABLE_SEQUENCED: out << "UNRELIABLE_SEQUENCED"; break;
        case ChannelType::RELIABLE_ORDERED: out << "RELIABLE_ORDERED"; break;
        default: out << "UNKNOWN"; break;
    }

    out << ", ";

    out << "[" << packet.header_.sequence << "]";
    out << "  ";
    out << packet.size_;
    out << " | ";

    out << std::hex;

    for (auto i = 0u; i < std::min(static_cast<std::uint32_t>(packet.size_), 8u); ++i)
    {
        out << static_cast<int>(packet.body_[i]) << " ";
    }

    out << std::dec << std::endl;

    return out;
}
}
```

`src/networking/server_connection_handler.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "networking/server_connection_handler.h"

#include <chrono>
#include <cstddef>
#include <cstdint>
#include <cstring>
#include <functional>
#include <iterator>
#include <map>
#include <memory>
#include <mutex>
#include <numeric>
#include <vector>

#include "core/context.h"
#include "core/data_buffer.h"
#include "jobs/concurrent_queue.h"
#include "jobs/job.h"
#include "jobs/job_system_manager.h"
#include "log/log.h"
#include "networking/channel/channel_type.h"
#include "networking/channel/reliable_ordered_channel.h"
#include "networking/channel/unreliable_sequenced_channel.h"
#include "networking/channel/unreliable_unordered_channel.h"
#include "networking/data_buffer_deserialiser.h"
#include "networking/data_buffer_serialiser.h"
#include "networking/packet.h"
#include "networking/socket.h"

namespace
{

/**
 * Helper function to handle a hello message. This is the first part of the
 * handshake and the server needs to respond with CONNECTED. We also use this
 * opportunity to start a sync request.
 *
 * @param id
 *   Id of connection.
 *
 * @param channel
 *   The channel HELLO was received on.
 *
 * @param socket
 *   Socket for the connection.
 */
void handle_hello(std::size_t id, iris::Channel *channel, iris::Socket *socket, std::mutex &mutex)
{
    // we will send the client their id
    iris::DataBufferSerialiser serialiser{};
    serialiser.push(static_cast<std::uint32_t>(id));

    // create and enqueue response packets
    iris::Packet connected{iris::PacketType::CONNECTED, iris::ChannelType::RELIABLE_ORDERED, serialiser.data()};
    iris::Packet sync_start{iris::PacketType::SYNC_START, iris::ChannelType::RELIABLE_ORDERED, {}};

    std::vector<iris::Packet> send_queue{};

    {
        std::unique_lock lock(mutex);

        channel->enqueue_send(std::move(connected));
        channel->enqueue_send(std::move(sync_start));
        send_queue = channel->yield_send_queue();
    }

    // send all packets
    for (const auto &packet : send_queue)
    {
        socket->write(packet.data(), packet.packet_size());
    }
}

/**
 * Helper function to handle the response to a sync.
 *
 * @param channel
 *   The channel to communicate on.
 *
 * @param socket
 *   Socket for the connection.
 *
 * @param packet
 *   The received SYNC_RESPONSE packet.
 */
void handle_sync_response(iris::Channel *channel, iris::Socket *socket, const iris::Packet &packet, std::mutex &mutex)
{
    // get the client time and our time
    iris::DataBufferDeserialiser deserialiser{packet.body_buffer()};
    const auto client_time_raw = deserialiser.pop<std::uint32_t>();
    const auto now =
        std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now().time_since_epoch());

    // send the client back their time and out time
    iris::DataBufferSerialiser serialiser{};
    serialiser.push(client_time_raw);
    serialiser.push(static_cast<std::uint32_t>(now.count()));
    iris::Packet sync_finish{iris::PacketType::SYNC_FINISH, iris::ChannelType::RELIABLE_ORDERED, serialiser.data()};

    std::vector<iris::Packet> send_queue{};

    {
        std::unique_lock lock(mutex);
        channel->enqueue_send(std::move(sync_finish));
        send_queue = channel->yield_send_queue();
    }

    // send all packets
    for (const auto &p : send_queue)
    {
        socket->write(p.data(), p.packet_size());
    }
}

}

namespace iris
{

/**
 * Helper struct to encapsulate data for a connection.
 */
struct ServerConnectionHandler::Connection
{
    Socket *socket;
    std::map<ChannelType, std::unique_ptr<Channel>> channels;
    std::chrono::milliseconds rtt;
};

ServerConnectionHandler::ServerConnectionHandler(
    Context &context,
    std::unique_ptr<ServerSocket> socket,
    NewConnectionCallback new_connection_callback,
    RecvCallback recv_callback)
    : socket_(std::move(socket))
    , new_connection_callback_(new_connection_callback)
    , recv_callback_(recv_callback)
    , start_(std::chrono::steady_clock::now())
    , connections_()
    , mutex_()
    , messages_()
{
    // we want to always be accepting connections, so we do this in a background
    // job
    context.jobs_manager().add(
        {[this]()
         {
             for (;;)
             {
                 auto [client_socket, raw_packet, new_connection] = socket_->read();

                 std::hash<Socket *> hash{};

                 const auto id = hash(client_socket);

                 if (new_connection)
                 {
                     // setup internal struct to manage connection
                     auto connection = std::make_unique<Connection>();
                     connection->socket = client_socket;
                     connection->channels[ChannelType::UNRELIABLE_UNORDERED] =
                         std::make_unique<UnreliableUnorderedChannel>();
                     connection->channels[ChannelType::UNRELIABLE_SEQUENCED] =
                         std::make_unique<UnreliableSequencedChannel>();
                     connection->channels[ChannelType::RELIABLE_ORDERED] = std::make_unique<ReliableOrderedChannel>();

                     connections_[id] = std::move(connection);
                 }

                 auto *connection = connections_[id].get();

                 iris::Packet packet{raw_packet};

                 // enqueue the packet into the right channel
                 const auto channel_type = packet.channel();
                 auto *channel = connection->channels.at(channel_type).get();

                 std::vector<Packet> receive_queue{};

                 {
                     std::unique_lock lock(mutex_);
                     channel->enqueue_receive(std::move(packet));
                     receive_queue = channel->yield_receive_queue();
                 }

                 // handle all received packets from that channel
                 for (const auto &p : receive_queue)
                 {
                     switch (p.type())
                     {
                         case PacketType::HELLO:
                         {
                             handle_hello(id, channel, connection->socket, mutex_);

                             // we got a new client, fire it back to the
                             // application
                             new_connection_callback_(id);
                             break;
                         }
                         case PacketType::DATA:
                         {
                             // we got data, fire it back to the application
                             recv_callback_(id, p.body_buffer(), p.channel());
                             break;
                         }
                         case PacketType::SYNC_RESPONSE:
                         {
                             handle_sync_response(channel, connection->socket, packet, mutex_);
                             break;
                         }
                         default: LOG_ENGINE_ERROR("server_connection_handler", "unknown packet type");
                     }
                 }
             }
         }});
}

ServerConnectionHandler::~ServerConnectionHandler() = default;

void ServerConnectionHandler::update()
{
}

void ServerConnectionHandler::send(std::size_t id, const DataBuffer &message, ChannelType channel_type)
{
    auto *channel = connections_[id]->channels[channel_type].get();
    auto *socket = connections_[id]->socket;

    {
        std::unique_lock lock(mutex_);

        // wrap data in a Packet and enqueue
        Packet packet(PacketType::DATA, channel_type, message);
        channel->enqueue_send(std::move(packet));

        // send all packets
        for (const auto &p : channel->yield_send_queue())
        {
            socket->write(p.data(), p.packet_size());
        }
    }
}

}

```

`src/networking/simulated_server_socket.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "networking/simulated_server_socket.h"

#include <chrono>
#include <memory>

#include "networking/server_socket_data.h"
#include "networking/simulated_socket.h"

namespace iris
{

SimulatedServerSocket::SimulatedServerSocket(
    Context &context,
    std::chrono::milliseconds delay,
    std::chrono::milliseconds jitter,
    float drop_rate,
    ServerSocket *socket)
    : socket_(socket)
    , client_(nullptr)
    , delay_(delay)
    , jitter_(jitter)
    , drop_rate_(drop_rate)
    , context_(context)
{
}

ServerSocketData SimulatedServerSocket::read()
{
    auto [client_socket, data, new_client] = socket_->read();

    if (!client_)
    {
        client_ = std::make_unique<SimulatedSocket>(context_, delay_, jitter_, drop_rate_, client_socket);
    }

    return {client_.get(), data, new_client};
}

}

```

`src/networking/simulated_socket.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "networking/simulated_socket.h"

#include <chrono>
#include <cstddef>
#include <optional>
#include <random>
#include <thread>

#include "core/context.h"
#include "core/random.h"
#include "jobs/concurrent_queue.h"
#include "jobs/job.h"
#include "jobs/job_system_manager.h"
#include "log/log.h"

using namespace std::chrono_literals;

namespace iris
{

SimulatedSocket::SimulatedSocket(
    Context &context,
    std::chrono::milliseconds delay,
    std::chrono::milliseconds jitter,
    float drop_rate,
    Socket *socket)
    : delay_(delay)
    , jitter_(jitter)
    , drop_rate_(drop_rate)
    , socket_(socket)
{
    // in order to facilitate message delay without blocking we have write()
    // enqueue data with a time point, this job then grabs them and can wait
    // until the delay has passed before sending
    context.jobs_manager().add({[this]()
                                {
                                    for (;;)
                                    {
                                        if (write_queue_.empty())
                                        {
                                            std::this_thread::sleep_for(10ms);
                                        }
                                        else
                                        {
                                            const auto &[buffer, time_point] = write_queue_.dequeue();

                                            // wait until its time to send the data
                                            std::this_thread::sleep_until(time_point);

                                            socket_->write(buffer);
                                        }
                                    }
                                }});
}

SimulatedSocket::~SimulatedSocket() = default;

std::optional<DataBuffer> SimulatedSocket::try_read(std::size_t count)
{
    return socket_->try_read(count);
}

DataBuffer SimulatedSocket::read(std::size_t count)
{
    return socket_->read(count);
}

void SimulatedSocket::write(const DataBuffer &buffer)
{
    if (!flip_coin(drop_rate_))
    {
        const auto jitter =
            random_int32(static_cast<std::int32_t>(-jitter_.count()), static_cast<std::int32_t>(jitter_.count()));

        // stick the data to be sent on the queue (with the delay time) and
        const auto delay = delay_ + std::chrono::milliseconds(jitter);
        write_queue_.enqueue(buffer, std::chrono::steady_clock::now() + delay);
    }
}

void SimulatedSocket::write(const std::byte *data, std::size_t size)
{
    write({data, data + size});
}

}

```

`src/networking/udp_server_socket.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "networking/udp_server_socket.h"

#include <cstddef>
#include <cstdint>
#include <cstring>
#include <memory>

#include "core/auto_release.h"
#include "core/data_buffer.h"
#include "core/error_handling.h"
#include "log/log.h"
#include "networking/networking.h"
#include "networking/server_socket_data.h"
#include "networking/socket.h"
#include "networking/udp_socket.h"

namespace iris
{

UdpServerSocket::UdpServerSocket(const std::string &address, std::uint32_t port)
    : connections_()
    , socket_()
{
    LOG_ENGINE_INFO("udp_server_socket", "creating server socket ({}:{})", address, port);

    // create socket
    socket_ = {::socket(AF_INET, SOCK_DGRAM, 0), CloseSocket};
    ensure(socket_ == INVALID_SOCKET, "socket failed");

    // configure address
    struct sockaddr_in address_storage = {0};
    socklen_t address_length = sizeof(struct sockaddr_in);
    memset(&address_storage, 0x0, address_length);

    address_storage.sin_family = AF_INET;
    inet_pton(AF_INET, address.c_str(), &address_storage.sin_addr.s_addr);
    address_storage.sin_port = htons(static_cast<std::uint16_t>(port));

    // enable multicast
    int reuse = 1;
    ensure(
        ::setsockopt(socket_, SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<const char *>(&reuse), sizeof(reuse)) == 0,
        "setsockopt failed");

    // bind socket so we can accept connections
    ensure(::bind(socket_, reinterpret_cast<struct sockaddr *>(&address_storage), address_length) == 0, "bind failed");

    LOG_ENGINE_INFO("udp_server_socket", "connected!");
}

ServerSocketData UdpServerSocket::read()
{
    struct sockaddr_in address;
    socklen_t length = sizeof(address);

    static constexpr auto new_connection_size = 1024u;
    DataBuffer buffer(new_connection_size);

    // block and wait for a new connection
    const auto read = ::recvfrom(
        socket_,
        reinterpret_cast<char *>(buffer.data()),
        static_cast<int>(buffer.size()),
        0,
        reinterpret_cast<struct sockaddr *>(&address),
        &length);

    ensure(read != -1, "recvfrom failed");

    // resize buffer to amount of data read
    buffer.resize(read);

    const auto byte_address = address.sin_addr.s_addr;

    auto new_connection = false;

    if (connections_.count(byte_address) == 0u)
    {
        connections_[byte_address] = std::make_unique<UdpSocket>(address, length, socket_.get());

        new_connection = true;

        LOG_ENGINE_INFO("udp_server_socket", "new connection");
    }

    return {connections_[byte_address].get(), buffer, new_connection};
}

}

```

`src/networking/udp_socket.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "networking/udp_socket.h"

#include <cstddef>
#include <cstdint>
#include <cstring>
#include <memory>
#include <optional>
#include <string>

#include "core/data_buffer.h"
#include "core/exception.h"
#include "log/log.h"
#include "networking/networking.h"
#include "networking/socket.h"

namespace iris
{

UdpSocket::UdpSocket(const std::string &address, std::uint16_t port)
    : socket_()
    , address_()
    , address_length_(0)
{
    LOG_ENGINE_INFO("udp_socket", "creating socket ({}:{})", address, port);

    // create socket
    socket_ = {::socket(AF_INET, SOCK_DGRAM, 0), CloseSocket};
    if (!socket_)
    {
        throw Exception("socket failed");
    }

    // configure address
    std::memset(&address_, 0x0, sizeof(address_));
    address_length_ = sizeof(address_);
    address_.sin_family = AF_INET;
    address_.sin_port = htons(port);

    // convert address from text to binary
    if (::inet_pton(AF_INET, address.c_str(), &address_.sin_addr.s_addr) != 1)
    {
        throw Exception("failed to convert ip address");
    }

    // enable socket reuse
    int reuse = 1;
    if (::setsockopt(socket_, SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<const char *>(&reuse), sizeof(reuse)) < 0)
    {
        throw iris::Exception("setsockopt failed");
    }

    LOG_ENGINE_INFO("udp_socket", "connected!");
}

UdpSocket::UdpSocket(struct sockaddr_in socket_address, socklen_t socket_length, SocketHandle socket)
    : socket_(socket, nullptr)
    , address_(socket_address)
    , address_length_(socket_length)
{
}

std::optional<DataBuffer> UdpSocket::try_read(std::size_t count)
{
    std::optional<DataBuffer> out = DataBuffer(count);

    set_blocking(socket_, false);

    // perform non-blocking read
    auto read = ::recvfrom(
        socket_,
        reinterpret_cast<char *>(out->data()),
        static_cast<int>(out->size()),
        0,
        reinterpret_cast<struct sockaddr *>(&address_),
        &address_length_);

    if (read == -1)
    {
        // read failed but not because there was no data
        if (!last_call_blocked())
        {
            throw iris::Exception("read failed");
        }

        // no data, so reset optional
        out.reset();
    }
    else
    {
        // resize buffer to amount of data read
        out->resize(read);
    }

    return out;
}

DataBuffer UdpSocket::read(std::size_t count)
{
    DataBuffer buffer(count);

    set_blocking(socket_, true);

    // perform blocking read
    auto read = ::recvfrom(
        socket_,
        reinterpret_cast<char *>(buffer.data()),
        static_cast<int>(buffer.size()),
        0,
        reinterpret_cast<struct sockaddr *>(&address_),
        &address_length_);

    if (read == -1)
    {
        throw Exception("recvfrom failed");
    }

    // resize buffer to amount of data read
    buffer.resize(read);

    return buffer;
}

void UdpSocket::write(const DataBuffer &buffer)
{
    write(buffer.data(), buffer.size());
}

void UdpSocket::write(const std::byte *data, std::size_t size)
{
    const auto size_check = static_cast<int>(size);
    if (::sendto(
            socket_,
            reinterpret_cast<const char *>(data),
            static_cast<int>(size),
            0,
            reinterpret_cast<struct sockaddr *>(&address_),
            address_length_) != size_check)
    {
        throw Exception("sendto failed");
    }
}

}

```

`src/networking/win32/CMakeLists.txt`:

```txt
set(SOURCE_ROOT "${CMAKE_CURRENT_SOURCE_DIR}")
set(INCLUDE_ROOT "${PROJECT_SOURCE_DIR}/include/iris/networking/windows")

set(NETWORKING_SRCS
    "${INCLUDE_ROOT}/winsock.h" "${SOURCE_ROOT}/winsock.cpp"
    PARENT_SCOPE)

```

`src/networking/win32/winsock.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "networking/windows/winsock.h"

#include <winsock2.h>
#include <ws2tcpip.h>
#pragma comment(lib, "Ws2_32.lib")

#include "core/error_handling.h"

namespace iris
{
Winsock::Winsock()
{
    WSADATA data = {0};

    ensure(::WSAStartup(MAKEWORD(2, 2), &data) == 0, "failed to init winsock");
}

/**
 * Cleanup winsock.
 */
Winsock::~Winsock()
{
    ::WSACleanup();
}

}

```

`src/physics/CMakeLists.txt`:

```txt
set(INCLUDE_ROOT "${PROJECT_SOURCE_DIR}/include/iris/physics")

add_subdirectory("bullet")

target_sources(iris PRIVATE
    ${INCLUDE_ROOT}/basic_character_controller.h
    ${INCLUDE_ROOT}/character_controller.h
    ${INCLUDE_ROOT}/collision_shape.h
    ${INCLUDE_ROOT}/contact_point.h
    ${INCLUDE_ROOT}/physics_manager.h
    ${INCLUDE_ROOT}/physics_system.h
    ${INCLUDE_ROOT}/ray_cast_result.h
    ${INCLUDE_ROOT}/rigid_body.h
    ${INCLUDE_ROOT}/rigid_body_type.h
    basic_character_controller.cpp)

```

`src/physics/basic_character_controller.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "physics/basic_character_controller.h"

#include <chrono>
#include <vector>

#include "core/error_handling.h"
#include "core/vector3.h"
#include "log/log.h"
#include "physics/collision_shape.h"
#include "physics/contact_point.h"
#include "physics/physics_system.h"
#include "physics/rigid_body_type.h"

namespace iris
{

BasicCharacterController::BasicCharacterController(
    PhysicsSystem *physics_system,
    float speed,
    float width,
    float height,
    float float_height)
    : CharacterController()
    , movement_direction_()
    , speed_(speed)
    , float_height_(float_height)
    , body_(nullptr)
{
    // use capsule shape for character
    body_ = physics_system->create_rigid_body(
        Vector3{0.0f, 0.0f, 10.0f},
        physics_system->create_capsule_collision_shape(width, height),
        RigidBodyType::CHARACTER_CONTROLLER);
}

void BasicCharacterController::set_movement_direction(const Vector3 &direction)
{
    movement_direction_ = direction;
}

Vector3 BasicCharacterController::position() const
{
    return body_->position();
}

Quaternion BasicCharacterController::orientation() const
{
    return body_->orientation();
}

void BasicCharacterController::set_speed(float speed)
{
    speed_ = speed;
}

void BasicCharacterController::reposition(const Vector3 &position, const Quaternion &orientation)
{
    body_->reposition(position, orientation);
}

RigidBody *BasicCharacterController::rigid_body() const
{
    return body_;
}

void BasicCharacterController::update(PhysicsSystem *ps, std::chrono::milliseconds delta)
{
    // simple three phase approach to updating a character controller

    const auto delta_seconds_fraction = static_cast<float>(delta.count()) / 1000.0f;

    // phase 1:
    // calculate the target position after the update based on the velocity and elapsed time (delta)

    const auto start_position = position();
    auto target_position = start_position + (movement_direction_ * speed_ * delta_seconds_fraction);

    // always update rigid body location position for future tests
    reposition(target_position, orientation());

    // phase 2:
    // ensure the target position is always a fixed distance above whatever object is below it

    // cast a ray down
    const auto rays_cast_results = ps->ray_cast(target_position, {0.0f, -1.0f, 0.0f}, {body_});
    if (!rays_cast_results.empty())
    {
        const auto hit = rays_cast_results.front();

        // if we are too far above our fixed distance then adjust the y component of the target position
        if ((hit.body->type() != RigidBodyType::GHOST) &&
            (Vector3::distance(hit.position, target_position) >= float_height_))
        {
            target_position.y = hit.position.y + float_height_;
        }
    }

    // always update rigid body location position for future tests
    reposition(target_position, orientation());

    static constexpr auto penetration_tolerance = 0.05f;
    static constexpr auto max_iterations = 5u;

    auto collisions_resolved = true;
    auto iteration = 0u;

    // phase 3:
    // check if target position is colliding with anything and attempt to resolve, if we cannot resolve then cancel the
    // movement this update

    do
    {
        collisions_resolved = true;

        // get all contacts with the body (which is at target position)
        const auto contacts = ps->contacts(body_);

        // find the first contact which is not a ghost and has a penetration above our tolerance
        // as contacts() provides us contact points sorted by penetration and we only want negative penetrations this
        // will also find us the largest penetration
        const auto valid_contact = std::find_if(std::cbegin(contacts), std::cend(contacts), [](const ContactPoint &cp) {
            return (cp.contact->type() != RigidBodyType::GHOST) && (cp.penetration > penetration_tolerance);
        });

        // if we found a valid contact then resolve
        if (valid_contact != std::cend(contacts))
        {
            // move target position back along penetration direction
            target_position += valid_contact->normal * valid_contact->penetration;

            // always update rigid body location position for future tests
            reposition(target_position, orientation());

            valid_contact->contact->apply_impulse(valid_contact->normal + 10.0f);

            collisions_resolved = false;
        }
    } while (!collisions_resolved && (iteration++ < max_iterations));

    // if we could not resolve collisions then revert the rigid body position and do nothing this update
    if (!collisions_resolved)
    {
        reposition(start_position, orientation());
    }
}

}

```

`src/physics/bullet/CMakeLists.txt`:

```txt
set(INCLUDE_ROOT "${PROJECT_SOURCE_DIR}/include/iris/physics/bullet")

target_sources(iris PRIVATE
    ${INCLUDE_ROOT}/bullet_box_collision_shape.h
    ${INCLUDE_ROOT}/bullet_capsule_collision_shape.h
    ${INCLUDE_ROOT}/bullet_collision_shape.h
    ${INCLUDE_ROOT}/bullet_heightmap_collision_shape.h
    ${INCLUDE_ROOT}/bullet_mesh_collision_shape.h
    ${INCLUDE_ROOT}/bullet_physics_manager.h
    ${INCLUDE_ROOT}/bullet_physics_system.h
    ${INCLUDE_ROOT}/bullet_rigid_body.h
    ${INCLUDE_ROOT}/collision_callback.h
    ${INCLUDE_ROOT}/debug_draw.h
    bullet_box_collision_shape.cpp
    bullet_capsule_collision_shape.cpp
    bullet_heightmap_collision_shape.cpp
    bullet_mesh_collision_shape.cpp
    bullet_physics_manager.cpp
    bullet_physics_system.cpp
    bullet_rigid_body.cpp
    collision_callback
    debug_draw.cpp)

```

`src/physics/bullet/bullet_box_collision_shape.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "physics/bullet/bullet_box_collision_shape.h"

#include <memory>

#include <BulletCollision/CollisionShapes/btBoxShape.h>

#include "core/vector3.h"

namespace iris
{

BulletBoxCollisionShape::BulletBoxCollisionShape(const Vector3 &half_size)
    : shape_(std::make_unique<btBoxShape>(btVector3{half_size.x, half_size.y, half_size.z}))
    , half_size_(half_size)
{
}

Vector3 BulletBoxCollisionShape::half_size() const
{
    return half_size_;
}

btCollisionShape *BulletBoxCollisionShape::handle() const
{
    return shape_.get();
}

}

```

`src/physics/bullet/bullet_capsule_collision_shape.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "physics/bullet/bullet_capsule_collision_shape.h"

#include <memory>

#include <BulletCollision/CollisionShapes/btCapsuleShape.h>

namespace iris
{

BulletCapsuleCollisionShape::BulletCapsuleCollisionShape(float width, float height)
    : shape_(std::make_unique<btCapsuleShape>(width, height))
    , width_(width)
    , height_(height)
{
}

float BulletCapsuleCollisionShape::width() const
{
    return width_;
}

float BulletCapsuleCollisionShape::height() const
{
    return height_;
}

btCollisionShape *BulletCapsuleCollisionShape::handle() const
{
    return shape_.get();
}

}

```

`src/physics/bullet/bullet_heightmap_collision_shape.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "physics/bullet/bullet_heightmap_collision_shape.h"

#include <memory>
#include <vector>

#include <BulletCollision/CollisionShapes/btHeightfieldTerrainShape.h>

#include "core/error_handling.h"
#include "graphics/texture.h"

namespace iris
{

BulletHeightmapCollisionShape::BulletHeightmapCollisionShape(const Texture *heightmap, const Vector3 &scale)
    : shape_(nullptr)
    , height_data_()
{
    // extract r component from heightmap and store in a local copy, this is needed as bullet only takes a pointer
    // to the data and doesn't make a copy
    for (auto iter = std::cbegin(heightmap->data()); iter != std::cend(heightmap->data()); iter += 4u)
    {
        height_data_.emplace_back((static_cast<float>(*iter) / 255.0f) * scale.y);
    }

    shape_ = std::make_unique<btHeightfieldTerrainShape>(
        static_cast<int>(heightmap->width()),
        static_cast<int>(heightmap->height()),
        height_data_.data(),
        1.0f,
        0.0f,
        scale.y,
        1,
        PHY_FLOAT,
        false);

    shape_->setLocalScaling(btVector3{scale.x, scale.y, scale.z});
}

btCollisionShape *BulletHeightmapCollisionShape::handle() const
{
    return shape_.get();
}

}

```

`src/physics/bullet/bullet_mesh_collision_shape.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "physics/bullet/bullet_mesh_collision_shape.h"

#include <memory>

#include <BulletCollision/CollisionShapes/btBvhTriangleMeshShape.h>
#include <BulletCollision/CollisionShapes/btTriangleIndexVertexArray.h>

#include "core/error_handling.h"
#include "graphics/mesh.h"
#include "graphics/vertex_data.h"

namespace iris
{

BulletMeshCollisionShape::BulletMeshCollisionShape(const Mesh *mesh, const Vector3 &scale)
    : shape_(nullptr)
    , triangle_index_vertex_data_(nullptr)
{
    const auto &mesh_index_data = mesh->indices();
    const auto &mesh_vertex_data = mesh->vertices();
    const auto num_faces = static_cast<int>(mesh_index_data.size()) / 3;

    // get pointers to the vertex and index data
    // annoyingly bullet expects this data as non-const int pointers, so we needed a bit of casting to massage our data
    // into the expected format
    auto *index_ptr = reinterpret_cast<int *>(const_cast<std::uint32_t *>(mesh_index_data.data()));
    auto *vertex_ptr = reinterpret_cast<float *>(const_cast<VertexData *>(mesh_vertex_data.data()));

    triangle_index_vertex_data_ = std::make_unique<btTriangleIndexVertexArray>(
        num_faces,
        index_ptr,
        static_cast<int>(sizeof(int) * 3),
        static_cast<int>(mesh_vertex_data.size()),
        vertex_ptr,
        static_cast<int>(sizeof(VertexData)));

    shape_ = std::make_unique<btBvhTriangleMeshShape>(triangle_index_vertex_data_.get(), true);
    shape_->setLocalScaling({scale.x, scale.y, scale.z});
}

btCollisionShape *BulletMeshCollisionShape::handle() const
{
    return shape_.get();
}

}

```

`src/physics/bullet/bullet_physics_manager.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "physics/bullet/bullet_physics_manager.h"

#include <memory>

#include "graphics/mesh_manager.h"
#include "physics/basic_character_controller.h"
#include "physics/bullet/bullet_physics_system.h"
#include "physics/bullet/bullet_rigid_body.h"
#include "physics/physics_manager.h"
#include "physics/rigid_body.h"

namespace iris
{

BulletPhysicsManager::BulletPhysicsManager(MeshManager &mesh_manager)
    : mesh_manager_(mesh_manager)
{
}

PhysicsSystem *BulletPhysicsManager::create_physics_system()
{
    physics_system_ = std::make_unique<BulletPhysicsSystem>(mesh_manager_);
    return current_physics_system();
}

PhysicsSystem *BulletPhysicsManager::current_physics_system()
{
    return physics_system_.get();
}

}

```

`src/physics/bullet/bullet_physics_system.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "physics/bullet/bullet_physics_system.h"

#include <chrono>
#include <map>
#include <memory>
#include <optional>
#include <set>
#include <vector>

#include <BulletCollision/CollisionDispatch/btGhostObject.h>
#include <BulletDynamics/Dynamics/btRigidBody.h>
#include <LinearMath/btMotionState.h>
#include <LinearMath/btQuaternion.h>
#include <LinearMath/btTransform.h>
#include <LinearMath/btVector3.h>
#include <btBulletDynamicsCommon.h>

#include "core/error_handling.h"
#include "core/quaternion.h"
#include "core/vector3.h"
#include "graphics/mesh_manager.h"
#include "log/log.h"
#include "physics/basic_character_controller.h"
#include "physics/bullet/bullet_box_collision_shape.h"
#include "physics/bullet/bullet_capsule_collision_shape.h"
#include "physics/bullet/bullet_collision_shape.h"
#include "physics/bullet/bullet_heightmap_collision_shape.h"
#include "physics/bullet/bullet_mesh_collision_shape.h"
#include "physics/bullet/bullet_rigid_body.h"
#include "physics/bullet/collision_callback.h"
#include "physics/bullet/debug_draw.h"
#include "physics/character_controller.h"
#include "physics/contact_point.h"
#include "physics/ray_cast_result.h"
#include "physics/rigid_body.h"

using namespace std::literals::chrono_literals;

namespace
{
/**
 * Helper function to remove a rigid body from a bullet dynamics world.
 *
 * @param body
 *   Body to remove.
 *
 * @param world
 *   World to remove from.
 */
void remove_body_from_world(iris::RigidBody *body, btDynamicsWorld *world)
{
    auto *bullet_body = static_cast<iris::BulletRigidBody *>(body);

    if ((body->type() == iris::RigidBodyType::GHOST) || (body->type() == iris::RigidBodyType::CHARACTER_CONTROLLER))
    {
        auto *bullet_ghost = static_cast<::btGhostObject *>(bullet_body->handle());
        world->removeCollisionObject(bullet_ghost);
    }
    else
    {
        auto *bullet_rigid = static_cast<::btRigidBody *>(bullet_body->handle());
        world->removeRigidBody(bullet_rigid);
    }
}
}

namespace iris
{

/**
 * Saved information about a rigid body. Used in PhysicsState.
 */
struct RigidBodyState
{
    RigidBodyState(const btTransform &transform, const btVector3 &linear_velocity, const btVector3 &angular_velocity)
        : transform(transform)
        , linear_velocity(linear_velocity)
        , angular_velocity(angular_velocity)
    {
    }

    btTransform transform;
    btVector3 linear_velocity;
    btVector3 angular_velocity;
};

/**
 * Struct for saving the state of the physics simulation. It simply stores
 * RigidBodyState for all rigid bodies. Note that collision information is
 * *not* saved.
 */
struct BulletPhysicsState : public PhysicsState
{
    ~BulletPhysicsState() override = default;

    std::map<btRigidBody *, RigidBodyState> bodies;
};

BulletPhysicsSystem::BulletPhysicsSystem(MeshManager &mesh_manager)
    : PhysicsSystem()
    , broadphase_(nullptr)
    , ghost_pair_callback_(nullptr)
    , collision_config_(nullptr)
    , collision_dispatcher_(nullptr)
    , solver_(nullptr)
    , world_(nullptr)
    , bodies_()
    , character_controllers_()
    , debug_draw_(mesh_manager)
    , collision_shapes_()
    , next_debug_update_(std::chrono::system_clock::now())
{
    collision_config_ = std::make_unique<::btDefaultCollisionConfiguration>();
    collision_dispatcher_ = std::make_unique<::btCollisionDispatcher>(collision_config_.get());
    broadphase_ = std::make_unique<::btDbvtBroadphase>();
    solver_ = std::make_unique<::btSequentialImpulseConstraintSolver>();
    world_ = std::make_unique<::btDiscreteDynamicsWorld>(
        collision_dispatcher_.get(), broadphase_.get(), solver_.get(), collision_config_.get());
    ghost_pair_callback_ = std::make_unique<::btGhostPairCallback>();
    broadphase_->getOverlappingPairCache()->setInternalGhostPairCallback(ghost_pair_callback_.get());

    world_->setGravity({0.0f, -10.0f, 0.0f});
}

BulletPhysicsSystem::~BulletPhysicsSystem()
{
    try
    {
        for (const auto &body : bodies_)
        {
            remove_body_from_world(body.get(), world_.get());
        }

        for (const auto &controller : character_controllers_)
        {
            remove_body_from_world(controller->rigid_body(), world_.get());
        }
    }
    catch (...)
    {
        LOG_ERROR("physics_system", "exception caught during dtor");
    }
}

void BulletPhysicsSystem::step(std::chrono::milliseconds time_step)
{
    for (auto &controller : character_controllers_)
    {
        controller->update(this, time_step);
    }

    const auto ticks = static_cast<float>(time_step.count());
    world_->stepSimulation(ticks / 1000.0f, 1);

    debug_draw_.update();
}

RigidBody *BulletPhysicsSystem::create_rigid_body(
    const Vector3 &position,
    const CollisionShape *collision_shape,
    RigidBodyType type)
{
    bodies_.emplace_back(
        std::make_unique<BulletRigidBody>(position, static_cast<const BulletCollisionShape *>(collision_shape), type));
    auto *body = static_cast<BulletRigidBody *>(bodies_.back().get());

    if ((body->type() == RigidBodyType::GHOST) || (body->type() == RigidBodyType::CHARACTER_CONTROLLER))
    {
        auto *bullet_ghost = static_cast<btGhostObject *>(body->handle());
        world_->addCollisionObject(bullet_ghost);
    }
    else
    {
        auto *bullet_rigid = static_cast<btRigidBody *>(body->handle());
        world_->addRigidBody(bullet_rigid);
    }

    debug_draw_.register_rigid_body(body);

    return body;
}

const CollisionShape *BulletPhysicsSystem::create_box_collision_shape(const Vector3 &half_size)
{
    const auto &collision_shape = collision_shapes_.emplace_back(std::make_unique<BulletBoxCollisionShape>(half_size));
    debug_draw_.register_box_collision_shape(static_cast<const BulletBoxCollisionShape *>(collision_shape.get()));

    return collision_shape.get();
}

const CollisionShape *BulletPhysicsSystem::create_capsule_collision_shape(float width, float height)
{
    const auto &collision_shape =
        collision_shapes_.emplace_back(std::make_unique<BulletCapsuleCollisionShape>(width, height));
    debug_draw_.register_capsule_collision_shape(
        static_cast<const BulletCapsuleCollisionShape *>(collision_shape.get()));

    return collision_shapes_.back().get();
}

const CollisionShape *BulletPhysicsSystem::create_mesh_collision_shape(const Mesh *mesh, const Vector3 &scale)
{
    const auto &collision_shape =
        collision_shapes_.emplace_back(std::make_unique<BulletMeshCollisionShape>(mesh, scale));
    debug_draw_.register_mesh_collision_shape(static_cast<const BulletMeshCollisionShape *>(collision_shape.get()));

    return collision_shapes_.back().get();
}

const CollisionShape *BulletPhysicsSystem::create_heightmap_collision_shape(
    const Texture *heightmap,
    const Vector3 &scale)
{
    const auto &collision_shape =
        collision_shapes_.emplace_back(std::make_unique<BulletHeightmapCollisionShape>(heightmap, scale));
    debug_draw_.register_height_map_collision_shape(
        static_cast<const BulletHeightmapCollisionShape *>(collision_shape.get()));

    return collision_shapes_.back().get();
}

CharacterController *BulletPhysicsSystem::add(std::unique_ptr<CharacterController> character_controller)
{
    character_controllers_.emplace_back(std::move(character_controller));
    return character_controllers_.back().get();
}

void BulletPhysicsSystem::remove(RigidBody *body)
{
    debug_draw_.deregister_rigid_body(body);
    remove_body_from_world(body, world_.get());

    bodies_.erase(
        std::remove_if(
            std::begin(bodies_), std::end(bodies_), [body](const auto &element) { return element.get() == body; }),
        std::end(bodies_));
}

void BulletPhysicsSystem::remove(CharacterController *character)
{
    remove_body_from_world(character->rigid_body(), world_.get());

    character_controllers_.erase(
        std::remove_if(
            std::begin(character_controllers_),
            std::end(character_controllers_),
            [character](const auto &element) { return element.get() == character; }),
        std::end(character_controllers_));
}

std::vector<RayCastResult> BulletPhysicsSystem::ray_cast(
    const Vector3 &origin,
    const Vector3 &direction,
    const std::set<const RigidBody *> &ignore)
{
    std::vector<RayCastResult> hits;

    // bullet does ray tracing between two vectors, so we create an end vector
    // some great distance away
    btVector3 from{origin.x, origin.y, origin.z};
    const auto far_away = origin + (direction * 10000.0f);
    btVector3 to{far_away.x, far_away.y, far_away.z};

    // create an ignore list of bullet objects
    std::set<const btCollisionObject *> bullet_ignore{};
    std::transform(
        std::cbegin(ignore),
        std::cend(ignore),
        std::inserter(bullet_ignore, std::begin(bullet_ignore)),
        [](const RigidBody *element) {
            const auto *bullet_body = static_cast<const iris::BulletRigidBody *>(element);
            return bullet_body->handle();
        });

    // do the ray cast
    btCollisionWorld::AllHitsRayResultCallback callback{from, to};
    world_->rayTest(from, to, callback);

    if (callback.hasHit())
    {
        // build up collection of hits which aren't being ignored
        for (auto i = 0; i < callback.m_collisionObjects.size(); ++i)
        {
            if (bullet_ignore.count(callback.m_collisionObjects[i]) == 0)
            {
                const auto hit_position = callback.m_hitPointWorld[i];
                const auto *bullet_body = static_cast<const btRigidBody *>(callback.m_collisionObjects[i]);
                auto *body = static_cast<RigidBody *>(bullet_body->getUserPointer());

                hits.push_back(
                    {.body = body, .position = Vector3{hit_position.x(), hit_position.y(), hit_position.z()}});
            }
        }
    }

    // sort the hits from closest to origin
    std::sort(std::begin(hits), std::end(hits), [&origin](const auto &e1, const auto &e2) {
        return Vector3::distance(origin, e1.position) < Vector3::distance(origin, e2.position);
    });

    return hits;
}

std::vector<ContactPoint> BulletPhysicsSystem::contacts(RigidBody *body)
{
    auto *bullet_body = static_cast<iris::BulletRigidBody *>(body);

    CollisionCallback callback{body};
    world_->contactTest(bullet_body->handle(), callback);

    return callback.yield_contact_points();
}

std::unique_ptr<PhysicsState> BulletPhysicsSystem::save()
{
    auto state = std::make_unique<BulletPhysicsState>();

    // save data for all rigid bodies
    for (const auto &body : bodies_)
    {
        auto *bullet_body = static_cast<iris::BulletRigidBody *>(body.get());
        auto *bullet_rigid = static_cast<btRigidBody *>(bullet_body->handle());

        state->bodies.try_emplace(
            bullet_rigid,
            bullet_rigid->getWorldTransform(),
            bullet_rigid->getLinearVelocity(),
            bullet_rigid->getAngularVelocity());
    }

    // save data for all character controllers
    for (const auto &character : character_controllers_)
    {
        auto *bullet_body = static_cast<iris::BulletRigidBody *>(character->rigid_body());
        auto *bullet_rigid = static_cast<btRigidBody *>(bullet_body->handle());

        state->bodies.try_emplace(
            bullet_rigid,
            bullet_rigid->getWorldTransform(),
            bullet_rigid->getLinearVelocity(),
            bullet_rigid->getAngularVelocity());
    }

    return state;
}

void BulletPhysicsSystem::load(const PhysicsState *state)
{
    const auto *bullet_state = static_cast<const BulletPhysicsState *>(state);

    // restore state for each rigid body
    for (const auto &[bullet_body, body_state] : bullet_state->bodies)
    {
        bullet_body->clearForces();

        bullet_body->setWorldTransform(body_state.transform);
        bullet_body->setCenterOfMassTransform(body_state.transform);
        bullet_body->setLinearVelocity(body_state.linear_velocity);
        bullet_body->setAngularVelocity(body_state.angular_velocity);
    }
}

void BulletPhysicsSystem::enable_debug_draw(Scene *scene)
{
    debug_draw_.set_scene(scene);
}

}

```

`src/physics/bullet/bullet_rigid_body.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "physics/bullet/bullet_rigid_body.h"

#include <chrono>
#include <memory>
#include <optional>
#include <set>
#include <vector>

#include <BulletCollision/CollisionDispatch/btCollisionObject.h>
#include <BulletCollision/CollisionDispatch/btGhostObject.h>
#include <BulletCollision/CollisionShapes/btBoxShape.h>
#include <LinearMath/btDefaultMotionState.h>
#include <btBulletCollisionCommon.h>
#include <btBulletDynamicsCommon.h>

#include "core/exception.h"
#include "core/quaternion.h"
#include "core/vector3.h"
#include "log/log.h"
#include "physics/bullet/bullet_collision_shape.h"
#include "physics/bullet/debug_draw.h"
#include "physics/collision_shape.h"

namespace iris
{

BulletRigidBody::BulletRigidBody(
    const Vector3 &position,
    const BulletCollisionShape *collision_shape,
    RigidBodyType type)
    : name_()
    , type_(type)
    , collision_shape_(collision_shape)
    , body_(nullptr)
    , motion_state_(nullptr)
{
    // convert engine position to bullet form
    btTransform start_transform;
    start_transform.setIdentity();
    start_transform.setOrigin(btVector3(position.x, position.y, position.z));

    auto *shape = collision_shape_->handle();

    // internally we use a derivation of ::btCollisionObject for our rigid
    // body, which one depends on the type:
    //   * GHOST         - ::btGhostObject
    //   * NORMAL/STATIC - ::btRigidBody

    if (type_ == RigidBodyType::GHOST)
    {
        body_ = std::make_unique<btGhostObject>();
        body_->setCollisionShape(shape);
        body_->setWorldTransform(start_transform);
        body_->setCollisionFlags(btCollisionObject::CF_NO_CONTACT_RESPONSE);
    }
    else
    {
        // 0 mass means static rigid body
        btScalar mass = (type_ == RigidBodyType::STATIC) ? 0.0f : 10.0f;
        btVector3 localInertia(0, 0, 0);

        if (type_ != RigidBodyType::STATIC)
        {
            shape->calculateLocalInertia(mass, localInertia);
        }

        motion_state_ = std::make_unique<btDefaultMotionState>(start_transform);

        btRigidBody::btRigidBodyConstructionInfo rbInfo(mass, motion_state_.get(), shape, localInertia);

        body_ = std::make_unique<btRigidBody>(rbInfo);

        body_->setFriction(1.0f);
    }

    // set the user pointer of the bullet object to our engine object, this
    // allows us to get back the RigidBody* when doing collision detection
    body_->setUserPointer(this);
}

Vector3 BulletRigidBody::position() const
{
    const auto transform = body_->getWorldTransform();

    return {transform.getOrigin().x(), transform.getOrigin().y(), transform.getOrigin().z()};
}

Quaternion BulletRigidBody::orientation() const
{
    const auto transform = body_->getWorldTransform();
    const auto orientation = transform.getRotation();

    return {orientation.x(), orientation.y(), orientation.z(), orientation.w()};
}

Vector3 BulletRigidBody::linear_velocity() const
{
    Vector3 velocity{};

    if (type_ != RigidBodyType::GHOST)
    {
        const auto bullet_velocity = static_cast<btRigidBody *>(body_.get())->getLinearVelocity();

        velocity = {bullet_velocity.x(), bullet_velocity.y(), bullet_velocity.z()};
    }
    else
    {
        LOG_ENGINE_WARN("physics", "calling linear_velocity on ghost object");
    }

    return velocity;
}

Vector3 BulletRigidBody::angular_velocity() const
{
    Vector3 velocity{};

    if (type_ != RigidBodyType::GHOST)
    {
        const auto bullet_velocity = static_cast<btRigidBody *>(body_.get())->getAngularVelocity();

        velocity = {bullet_velocity.x(), bullet_velocity.y(), bullet_velocity.z()};
    }
    else
    {
        LOG_ENGINE_WARN("physics", "calling angular_velocity on ghost object");
    }

    return velocity;
}

void BulletRigidBody::set_linear_velocity(const Vector3 &linear_velocity)
{
    if (type_ != RigidBodyType::GHOST)
    {
        btVector3 velocity{linear_velocity.x, linear_velocity.y, linear_velocity.z};

        static_cast<btRigidBody *>(body_.get())->setLinearVelocity(velocity);
    }
    else
    {
        LOG_ENGINE_WARN("physics", "calling set_linear_velocity on ghost object");
    }
}

void BulletRigidBody::set_angular_velocity(const Vector3 &angular_velocity)
{
    if (type_ != RigidBodyType::GHOST)
    {
        btVector3 velocity{angular_velocity.x, angular_velocity.y, angular_velocity.z};

        static_cast<btRigidBody *>(body_.get())->setAngularVelocity(velocity);
    }
    else
    {
        LOG_ENGINE_WARN("physics", "calling set_angular_velocity on ghost object");
    }
}

void BulletRigidBody::reposition(const Vector3 &position, const Quaternion &orientation)
{
    btTransform transform;
    transform.setOrigin(btVector3(position.x, position.y, position.z));
    transform.setRotation(btQuaternion(orientation.x, orientation.y, orientation.z, orientation.w));

    body_->setWorldTransform(transform);

    // also update the motion state for non ghost rigid bodies
    if (motion_state_ != nullptr)
    {
        motion_state_->setWorldTransform(transform);
    }
}

std::string BulletRigidBody::name() const
{
    return name_;
}

void BulletRigidBody::set_name(const std::string &name)
{
    name_ = name;
}

RigidBodyType BulletRigidBody::type() const
{
    return type_;
}

const CollisionShape *BulletRigidBody::collision_shape() const
{
    return collision_shape_;
}

void BulletRigidBody::set_collision_shape(const CollisionShape *collision_shape)
{
    collision_shape_ = static_cast<const BulletCollisionShape *>(collision_shape);

    body_->setCollisionShape(collision_shape_->handle());
}

void BulletRigidBody::apply_impulse(const Vector3 &impulse)
{
    if (type_ != RigidBodyType::GHOST)
    {
        static_cast<btRigidBody *>(body_.get())
            ->applyImpulse(btVector3{impulse.x, impulse.y, impulse.z}, ::btVector3{});
    }
    else
    {
        LOG_ENGINE_WARN("physics", "calling apply_impulse on ghost object");
    }
}

btCollisionObject *BulletRigidBody::handle() const
{
    return body_.get();
}

}

```

`src/physics/bullet/collision_callback.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "physics/bullet/collision_callback.h"

#include <vector>

#include <BulletCollision/CollisionDispatch/btCollisionObject.h>
#include <BulletCollision/CollisionDispatch/btCollisionWorld.h>

#include "core/vector3.h"
#include "physics/contact_point.h"
#include "physics/rigid_body.h"

namespace
{

/**
 * Helper function to get the engine rigid body object from the bullet object provided in the callback.
 *
 * @param bullet_collision_wrapper
 *   Bullet object provided in collision callback.
 *
 * @returns
 *   Engine rigid body object.
 */
iris::RigidBody *get_engine_body(const btCollisionObjectWrapper *bullet_collision_wrapper)
{
    auto *user_ptr = bullet_collision_wrapper->getCollisionObject()->getUserPointer();

    return user_ptr != nullptr ? static_cast<iris::RigidBody *>(user_ptr) : nullptr;
}

}

namespace iris
{

CollisionCallback::CollisionCallback(RigidBody *testing_body)
    : testing_body_(testing_body)
    , contact_points_()
{
}

btScalar CollisionCallback::addSingleResult(
    btManifoldPoint &cp,
    const btCollisionObjectWrapper *colObj0Wrap,
    int,
    int,
    const btCollisionObjectWrapper *colObj1Wrap,
    int,
    int)
{
    // get the engine rigid body objects from the bullet objects
    RigidBody *body_a = get_engine_body(colObj0Wrap);
    RigidBody *body_b = get_engine_body(colObj1Wrap);

    // get penetration - the way bullet does its collision detection it may return contacts that are not actually
    // penetrating however we can use the distance to differentiate false positives
    // a negative depth means the object is penetrating and positive depth means it is not
    const auto penetration = cp.getDistance();

    if ((penetration < 0.0f) && (body_a != nullptr) && (body_b != nullptr))
    {
        // get world position and normal of collision contact point
        const auto bullet_world_pos = cp.getPositionWorldOnA();
        const auto normal = cp.m_normalWorldOnB;

        contact_points_.push_back(
            {.contact = (body_a == testing_body_) ? body_b : body_a,
             .position = {bullet_world_pos.x(), bullet_world_pos.y(), bullet_world_pos.z()},
             .penetration = -penetration, // normalise penetration value to be positive
             .normal = {normal.x(), normal.y(), normal.z()}});
    }

    // bullet ignores the return value of this function
    return 0;
}

std::vector<ContactPoint> CollisionCallback::yield_contact_points()
{
    std::vector<ContactPoint> contacts{};
    std::swap(contacts, contact_points_);

    // sort from most to least penetrated
    std::sort(
        std::begin(contacts),
        std::end(contacts),
        [](const ContactPoint &cp1, const ContactPoint &cp2) { return cp1.penetration > cp2.penetration; });

    return contacts;
}

}

```

`src/physics/bullet/debug_draw.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "physics/bullet/debug_draw.h"

#include <cstdint>
#include <vector>

#include <BulletCollision/CollisionShapes/btBvhTriangleMeshShape.h>
#include <BulletCollision/CollisionShapes/btHeightfieldTerrainShape.h>
#include <BulletCollision/CollisionShapes/btTriangleCallback.h>
#include <btBulletDynamicsCommon.h>

#include "core/colour.h"
#include "core/error_handling.h"
#include "core/exception.h"
#include "core/vector3.h"
#include "graphics/mesh.h"
#include "graphics/mesh_manager.h"
#include "graphics/scene.h"
#include "graphics/single_entity.h"
#include "graphics/vertex_data.h"
#include "physics/bullet/bullet_box_collision_shape.h"
#include "physics/bullet/bullet_capsule_collision_shape.h"
#include "physics/bullet/bullet_heightmap_collision_shape.h"
#include "physics/bullet/bullet_mesh_collision_shape.h"


namespace
{

/**
 * Bullet provides a callback class for debug drawing triangle meshes, however it is an internal class. We copy and
 * paste it here:
 * https://github.com/bulletphysics/bullet3/blob/06a212e66724f67f8abc8e927ac11facb063059a/src/BulletCollision/CollisionDispatch/btCollisionWorld.cpp#L1260-L1298
 */
class DebugDrawcallback : public btTriangleCallback, public btInternalTriangleIndexCallback
{
    btIDebugDraw *m_debugDrawer;
    btVector3 m_color;
    btTransform m_worldTrans;

  public:
    DebugDrawcallback(btIDebugDraw *debugDrawer, const btTransform &worldTrans, const btVector3 &color)
        : m_debugDrawer(debugDrawer)
        , m_color(color)
        , m_worldTrans(worldTrans)
    {
    }

    virtual void internalProcessTriangleIndex(btVector3 *triangle, int partId, int triangleIndex)
    {
        processTriangle(triangle, partId, triangleIndex);
    }

    virtual void processTriangle(btVector3 *triangle, int partId, int triangleIndex)
    {
        (void)partId;
        (void)triangleIndex;

        btVector3 wv0, wv1, wv2;
        wv0 = m_worldTrans * triangle[0];
        wv1 = m_worldTrans * triangle[1];
        wv2 = m_worldTrans * triangle[2];
        btVector3 center = (wv0 + wv1 + wv2) * btScalar(1. / 3.);

        if (m_debugDrawer->getDebugMode() & btIDebugDraw::DBG_DrawNormals)
        {
            btVector3 normal = (wv1 - wv0).cross(wv2 - wv0);
            normal.normalize();
            btVector3 normalColor(1, 1, 0);
            m_debugDrawer->drawLine(center, center + normal, normalColor);
        }
        m_debugDrawer->drawLine(wv0, wv1, m_color);
        m_debugDrawer->drawLine(wv1, wv2, m_color);
        m_debugDrawer->drawLine(wv2, wv0, m_color);
    }
};

}

namespace iris
{

DebugDraw::DebugDraw(MeshManager &mesh_manager)
    : scene_(nullptr)
    , bullet_debug_draw_(mesh_manager)
    , meshes_()
    , bodies_()
{
}

void DebugDraw::update()
{
    // if no scene has been set then we do not want debug drawing
    if (scene_ != nullptr)
    {
        for (auto &[body, entity] : bodies_)
        {
            expect(entity != nullptr, "corrupt debug state");

            entity->set_position(body->position());
            entity->set_orientation(body->orientation());
        }
    }
}

void DebugDraw::set_scene(Scene *scene)
{
    scene_ = scene;

    // add any previously registered objects to the scene
    for (auto &[body, entity] : bodies_)
    {
        entity = scene_->create_entity<SingleEntity>(
            nullptr,
            meshes_[body->collision_shape()].get(),
            Transform{body->position(), body->orientation(), {1.0f, 1.0f, 1.0f}},
            false,
            PrimitiveType::LINES);
    }
}

void DebugDraw::register_box_collision_shape(const BulletBoxCollisionShape *collision_shape)
{
    const auto half_size = collision_shape->half_size();
    bullet_debug_draw_.drawBox(
        {-half_size.x, -half_size.y, -half_size.z}, {half_size.x, half_size.y, half_size.z}, {0.0f, 1.0f, 0.0f});

    meshes_[collision_shape] = bullet_debug_draw_.flush();
}

void DebugDraw::register_capsule_collision_shape(const BulletCapsuleCollisionShape *collision_shape)
{
    bullet_debug_draw_.drawCapsule(
        collision_shape->width(),
        collision_shape->height(),
        1,
        btTransform{{{0.0f, 1.0f, 0.0f}, 0.0f}, {0.0f, 0.0f, 0.0f}},
        {0.0f, 1.0f, 0.0f});

    meshes_[collision_shape] = bullet_debug_draw_.flush();
}

void DebugDraw::register_mesh_collision_shape(const BulletMeshCollisionShape *collision_shape)
{
    const auto *bullet_shape = static_cast<btTriangleMeshShape *>(collision_shape->handle());
    DebugDrawcallback callback{
        &bullet_debug_draw_, btTransform{{{0.0f, 1.0f, 0.0f}, 0.0f}, {0.0f, 0.0f, 0.0f}}, {0.0f, 1.0f, 0.0f}};
    bullet_shape->processAllTriangles(&callback, {-10000.0f, -10000.0f, -10000.0f}, {10000.0f, 10000.0f, 10000.0f});

    meshes_[collision_shape] = bullet_debug_draw_.flush();
}

void DebugDraw::register_height_map_collision_shape(const BulletHeightmapCollisionShape *collision_shape)
{
    const auto *bullet_shape = static_cast<btHeightfieldTerrainShape *>(collision_shape->handle());
    DebugDrawcallback callback{
        &bullet_debug_draw_, btTransform{{{0.0f, 1.0f, 0.0f}, 0.0f}, {0.0f, 0.0f, 0.0f}}, {0.0f, 1.0f, 0.0f}};
    bullet_shape->processAllTriangles(&callback, {-10000.0f, -10000.0f, -10000.0f}, {10000.0f, 10000.0f, 10000.0f});

    meshes_[collision_shape] = bullet_debug_draw_.flush();
}

void DebugDraw::register_rigid_body(const RigidBody *rigid_body)
{
    const auto &[iter, _] = bodies_.emplace(rigid_body, nullptr);

    if (scene_ != nullptr)
    {
        iter->second = scene_->create_entity<SingleEntity>(
            nullptr,
            meshes_[rigid_body->collision_shape()].get(),
            Transform{rigid_body->position(), rigid_body->orientation(), {1.0f, 1.0f, 1.0f}},
            false,
            PrimitiveType::LINES);
    }
}

void DebugDraw::deregister_rigid_body(const RigidBody *rigid_body)
{
    if (scene_ != nullptr)
    {
        scene_->remove(bodies_[rigid_body]);
        bodies_.erase(rigid_body);
    }
}

}

```

`src/scripting/CMakeLists.txt`:

```txt
set(INCLUDE_ROOT "${PROJECT_SOURCE_DIR}/include/iris/scripting")

add_subdirectory("lua")

target_sources(iris PRIVATE
    ${INCLUDE_ROOT}/script.h
    ${INCLUDE_ROOT}/script_runner.h)

```

`src/scripting/lua/CMakeLists.txt`:

```txt
set(INCLUDE_ROOT "${PROJECT_SOURCE_DIR}/include/iris/scripting/lua")

add_subdirectory(interop)

target_sources(iris PRIVATE
    ${INCLUDE_ROOT}/lua_script.h
    lua_script.cpp)

```

`src/scripting/lua/interop/CMakeLists.txt`:

```txt
set(INCLUDE_ROOT "${PROJECT_SOURCE_DIR}/include/iris/scripting/lua/interop")

target_sources(iris PRIVATE
    ${INCLUDE_ROOT}/class_interop.h
    ${INCLUDE_ROOT}/register_class.h
    ${INCLUDE_ROOT}/quaternion.h
    ${INCLUDE_ROOT}/vector3.h
    register_class.cpp
    quaternion.cpp
    vector3.cpp)

```

`src/scripting/lua/interop/quaternion.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "scripting/lua/interop/quaternion.h"

#include <sstream>
#include <string>

extern "C"
{
#include "lauxlib.h"
#include "lua.h"
#include "lualib.h"
}

#include "core/error_handling.h"
#include "core/object_pool.h"
#include "core/quaternion.h"
#include "core/vector3.h"
#include "scripting/lua/interop/vector3.h"

namespace iris::interop::lua
{

static ObjectPool<Quaternion> quaternion_pool;

void quaternion_construct_raw(lua_State *state, const Quaternion &quaternion)
{
    auto **user_data = reinterpret_cast<Quaternion **>(::lua_newuserdata(state, sizeof(Quaternion *)));
    *user_data = quaternion_pool.next(quaternion);
    luaL_setmetatable(state, "Quaternion");
}

Quaternion **get_quaternion(lua_State *state)
{
    auto *user_data = luaL_checkudata(state, 1, "Quaternion");
    expect(user_data != nullptr, "incorrect user data");

    return reinterpret_cast<Quaternion **>(user_data);
}

int quaternion_constructor(lua_State *state)
{
    // if first argument on the stack is a number then we assume we've been passed four numbers and use the appropriate
    // constructor otherwise we assume the vector constructor
    if (::lua_isnumber(state, 1))
    {
        const auto arg1 = static_cast<float>(::luaL_checknumber(state, 1));
        const auto arg2 = static_cast<float>(::luaL_checknumber(state, 2));
        const auto arg3 = static_cast<float>(::luaL_checknumber(state, 3));
        const auto arg4 = static_cast<float>(::luaL_checknumber(state, 4));
        auto **user_data = reinterpret_cast<Quaternion **>(::lua_newuserdata(state, sizeof(Quaternion *)));
        *user_data = quaternion_pool.next(arg1, arg2, arg3, arg4);
        luaL_setmetatable(state, "Quaternion");
    }
    else
    {
        const auto arg1 = get_vector3(state);
        const auto arg2 = static_cast<float>(::luaL_checknumber(state, 2));
        auto **user_data = reinterpret_cast<Quaternion **>(::lua_newuserdata(state, sizeof(Quaternion *)));
        *user_data = quaternion_pool.next(**arg1, arg2);
        luaL_setmetatable(state, "Quaternion");
    }

    return 1;
}

int quaternion_destructor(lua_State *state)
{
    quaternion_pool.release(*get_quaternion(state));
    return 0;
}

int quaternion_x(lua_State *state)
{
    auto **q = get_quaternion(state);

    ::lua_pushnumber(state, (*q)->x);
    return 1;
}

int quaternion_set_x(lua_State *state)
{
    auto **q = get_quaternion(state);

    (*q)->x = static_cast<float>(::luaL_checknumber(state, 2));

    return 0;
}

int quaternion_y(lua_State *state)
{
    auto **q = get_quaternion(state);

    ::lua_pushnumber(state, (*q)->y);
    return 1;
}

int quaternion_set_y(lua_State *state)
{
    auto **q = get_quaternion(state);

    (*q)->y = static_cast<float>(::luaL_checknumber(state, 2));

    return 0;
}

int quaternion_z(lua_State *state)
{
    auto **q = get_quaternion(state);

    ::lua_pushnumber(state, (*q)->z);
    return 1;
}

int quaternion_set_z(lua_State *state)
{
    auto **q = get_quaternion(state);

    (*q)->z = static_cast<float>(::luaL_checknumber(state, 2));

    return 0;
}

int quaternion_w(lua_State *state)
{
    auto **q = get_quaternion(state);

    ::lua_pushnumber(state, (*q)->w);
    return 1;
}

int quaternion_set_w(lua_State *state)
{
    auto **q = get_quaternion(state);

    (*q)->w = static_cast<float>(::luaL_checknumber(state, 2));

    return 0;
}

int quaternion_to_string(lua_State *state)
{
    auto **q = get_quaternion(state);

    std::stringstream strm{};
    strm << **q;
    const auto str = strm.str();

    ::lua_pushstring(state, str.c_str());

    return 1;
}

int equality_equality(lua_State *state)
{
    auto *user_data1 = luaL_checkudata(state, 1, "Quaternion");
    expect(user_data1 != nullptr, "incorrect user data");
    auto **q1 = reinterpret_cast<Quaternion **>(user_data1);

    auto *user_data2 = luaL_checkudata(state, 2, "Quaternion");
    expect(user_data2 != nullptr, "incorrect user data");
    auto **q2 = reinterpret_cast<Quaternion **>(user_data2);

    ::lua_pushboolean(state, **q1 == **q2);

    return 1;
}

int quaternion_negate(lua_State *state)
{
    auto **q = get_quaternion(state);

    quaternion_construct_raw(state, -**q);

    return 1;
}

int quaternion_add(lua_State *state)
{
    auto *user_data1 = luaL_checkudata(state, 2, "Quaternion");
    expect(user_data1 != nullptr, "incorrect user data");
    auto **q1 = reinterpret_cast<Quaternion **>(user_data1);

    auto *user_data2 = luaL_checkudata(state, 1, "Quaternion");
    expect(user_data2 != nullptr, "incorrect user data");
    auto **q2 = reinterpret_cast<Quaternion **>(user_data2);

    quaternion_construct_raw(state, **q1 + **q2);

    return 1;
}

int quaternion_sub(lua_State *state)
{
    auto *user_data1 = luaL_checkudata(state, 1, "Quaternion");
    expect(user_data1 != nullptr, "incorrect user data");
    auto **q1 = reinterpret_cast<Quaternion **>(user_data1);

    auto *user_data2 = luaL_checkudata(state, 2, "Quaternion");
    expect(user_data2 != nullptr, "incorrect user data");
    auto **q2 = reinterpret_cast<Quaternion **>(user_data2);

    quaternion_construct_raw(state, **q1 - **q2);

    return 1;
}

int quaternion_mul(lua_State *state)
{
    auto *user_data1 = luaL_checkudata(state, 1, "Quaternion");
    expect(user_data1 != nullptr, "incorrect user data");
    auto **q1 = reinterpret_cast<Quaternion **>(user_data1);

    auto *user_data2 = luaL_checkudata(state, 2, "Quaternion");
    expect(user_data2 != nullptr, "incorrect user data");
    auto **q2 = reinterpret_cast<Quaternion **>(user_data2);

    quaternion_construct_raw(state, **q1 * **q2);

    return 1;
}

int quaternion_dot(lua_State *state)
{
    auto *user_data1 = luaL_checkudata(state, 1, "Quaternion");
    expect(user_data1 != nullptr, "incorrect user data");
    auto **q1 = reinterpret_cast<Quaternion **>(user_data1);

    auto *user_data2 = luaL_checkudata(state, 2, "Quaternion");
    expect(user_data2 != nullptr, "incorrect user data");
    auto **q2 = reinterpret_cast<Quaternion **>(user_data2);

    ::lua_pushnumber(state, (*q1)->dot(**q2));

    return 1;
}

int quaternion_slerp(lua_State *state)
{
    auto *user_data1 = luaL_checkudata(state, 1, "Quaternion");
    expect(user_data1 != nullptr, "incorrect user data");
    auto **q1 = reinterpret_cast<Quaternion **>(user_data1);

    auto *user_data2 = luaL_checkudata(state, 2, "Quaternion");
    expect(user_data2 != nullptr, "incorrect user data");
    auto **q2 = reinterpret_cast<Quaternion **>(user_data2);

    const auto amount = static_cast<float>(::luaL_checknumber(state, 3));

    auto tmp_q = **q1;
    tmp_q.slerp(**q2, amount);

    quaternion_construct_raw(state, tmp_q);

    return 1;
}

int quaternion_normalise(lua_State *state)
{
    auto **q = get_quaternion(state);

    auto tmp_q = **q;
    tmp_q.normalise();

    quaternion_construct_raw(state, tmp_q);

    return 1;
}

}

```

`src/scripting/lua/interop/register_class.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "scripting/lua/interop/register_class.h"

extern "C"
{
#include "lauxlib.h"
#include "lua.h"
#include "lualib.h"
}

#include "core/error_handling.h"
#include "scripting/lua/interop/class_interop.h"

namespace
{

/**
 * Helper function to register a function with lua.
 *
 * @param state
 *   Lua state object.
 *
 * @param lua_name
 *   Name to register function with.
 *
 * @param function
 *   Function to register with name.
 */
void register_function(lua_State *state, const std::string &lua_name, iris::interop::lua::LuaInteropFunction function)
{
    auto raw_func = function.target<int (*)(lua_State *)>();
    iris::ensure(*raw_func != nullptr, "could not get raw function pointer");

    ::lua_pushcfunction(state, *raw_func);
    ::lua_setfield(state, -2, lua_name.c_str());
}

}

namespace iris::interop::lua
{

void register_class(lua_State *state, const ClassInterop &class_interop)
{
    // must have ctor and stor
    ensure(class_interop.constructor != nullptr, "missing class constructor");
    ensure(class_interop.destructor != nullptr, "missing class destructor");

    // register class
    lua_register(state, class_interop.name.c_str(), *class_interop.constructor.target<int (*)(lua_State *)>());
    ::luaL_newmetatable(state, class_interop.name.c_str());

    // register dtor
    register_function(state, "__gc", class_interop.destructor);

    // we don't support index
    ::lua_pushvalue(state, -1);
    ::lua_setfield(state, -2, "__index");

    // register all supplied members
    for (const auto &[name, function] : class_interop.members)
    {
        ensure(function != nullptr, "missing function");
        register_function(state, name, function);
    }

    ::lua_pop(state, 1);
}

}

```

`src/scripting/lua/interop/vector3.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include <sstream>
#include <string>

extern "C"
{
#include "lauxlib.h"
#include "lua.h"
#include "lualib.h"
}

#include "core/error_handling.h"
#include "core/object_pool.h"
#include "core/vector3.h"

namespace iris::interop::lua
{

static ObjectPool<Vector3> vector3_pool;

void vector3_construct_raw(lua_State *state, const Vector3 &vec)
{
    auto **user_data = reinterpret_cast<Vector3 **>(::lua_newuserdata(state, sizeof(Vector3 *)));
    *user_data = vector3_pool.next(vec);
    luaL_setmetatable(state, "Vector3");
}

Vector3 **get_vector3(lua_State *state)
{
    auto *user_data = luaL_checkudata(state, 1, "Vector3");
    expect(user_data != nullptr, "incorrect user data");

    return reinterpret_cast<Vector3 **>(user_data);
}

int vector3_constructor(lua_State *state)
{
    const auto arg1 = static_cast<float>(::luaL_checknumber(state, 1));
    const auto arg2 = static_cast<float>(::luaL_checknumber(state, 2));
    const auto arg3 = static_cast<float>(::luaL_checknumber(state, 3));
    auto **user_data = reinterpret_cast<Vector3 **>(::lua_newuserdata(state, sizeof(Vector3 *)));
    *user_data = vector3_pool.next(arg1, arg2, arg3);
    luaL_setmetatable(state, "Vector3");

    return 1;
}

int vector3_destructor(lua_State *state)
{
    vector3_pool.release(*get_vector3(state));
    return 0;
}

int vector3_x(lua_State *state)
{
    auto **vector = get_vector3(state);

    ::lua_pushnumber(state, (*vector)->x);
    return 1;
}

int vector3_set_x(lua_State *state)
{
    auto **vector = get_vector3(state);

    (*vector)->x = static_cast<float>(::luaL_checknumber(state, 2));

    return 0;
}

int vector3_y(lua_State *state)
{
    auto **vector = get_vector3(state);

    ::lua_pushnumber(state, (*vector)->y);
    return 1;
}

int vector3_set_y(lua_State *state)
{
    auto **vector = get_vector3(state);

    (*vector)->y = static_cast<float>(::luaL_checknumber(state, 2));

    return 0;
}

int vector3_z(lua_State *state)
{
    auto **vector = get_vector3(state);

    ::lua_pushnumber(state, (*vector)->z);
    return 1;
}

int vector3_set_z(lua_State *state)
{
    auto **vector = get_vector3(state);

    (*vector)->z = static_cast<float>(::luaL_checknumber(state, 2));

    return 0;
}

int vector3_to_string(lua_State *state)
{
    auto **vector = get_vector3(state);

    std::stringstream strm{};
    strm << **vector;
    const auto str = strm.str();

    ::lua_pushstring(state, str.c_str());

    return 1;
}

int vector3_equality(lua_State *state)
{
    auto *user_data1 = luaL_checkudata(state, 1, "Vector3");
    expect(user_data1 != nullptr, "incorrect user data");
    auto **vec1 = reinterpret_cast<Vector3 **>(user_data1);

    auto *user_data2 = luaL_checkudata(state, 2, "Vector3");
    expect(user_data2 != nullptr, "incorrect user data");
    auto **vec2 = reinterpret_cast<Vector3 **>(user_data2);

    ::lua_pushboolean(state, **vec1 == **vec2);

    return 1;
}

int vector3_negate(lua_State *state)
{
    auto **vector = get_vector3(state);

    vector3_construct_raw(state, -**vector);

    return 1;
}

int vector3_add(lua_State *state)
{
    auto *user_data1 = luaL_checkudata(state, 2, "Vector3");
    expect(user_data1 != nullptr, "incorrect user data");
    auto **vec1 = reinterpret_cast<Vector3 **>(user_data1);

    auto *user_data2 = luaL_checkudata(state, 1, "Vector3");
    expect(user_data2 != nullptr, "incorrect user data");
    auto **vec2 = reinterpret_cast<Vector3 **>(user_data2);

    vector3_construct_raw(state, **vec1 + **vec2);

    return 1;
}

int vector3_sub(lua_State *state)
{
    auto *user_data1 = luaL_checkudata(state, 1, "Vector3");
    expect(user_data1 != nullptr, "incorrect user data");
    auto **vec1 = reinterpret_cast<Vector3 **>(user_data1);

    auto *user_data2 = luaL_checkudata(state, 2, "Vector3");
    expect(user_data2 != nullptr, "incorrect user data");
    auto **vec2 = reinterpret_cast<Vector3 **>(user_data2);

    vector3_construct_raw(state, **vec1 - **vec2);

    return 1;
}

int vector3_mul(lua_State *state)
{
    auto *user_data1 = luaL_checkudata(state, 1, "Vector3");
    expect(user_data1 != nullptr, "incorrect user data");
    auto **vec1 = reinterpret_cast<Vector3 **>(user_data1);

    auto *user_data2 = luaL_checkudata(state, 2, "Vector3");
    expect(user_data2 != nullptr, "incorrect user data");
    auto **vec2 = reinterpret_cast<Vector3 **>(user_data2);

    vector3_construct_raw(state, **vec1 * **vec2);

    return 1;
}

int vector3_dot(lua_State *state)
{
    auto *user_data1 = luaL_checkudata(state, 1, "Vector3");
    expect(user_data1 != nullptr, "incorrect user data");
    auto **vec1 = reinterpret_cast<Vector3 **>(user_data1);

    auto *user_data2 = luaL_checkudata(state, 2, "Vector3");
    expect(user_data2 != nullptr, "incorrect user data");
    auto **vec2 = reinterpret_cast<Vector3 **>(user_data2);

    ::lua_pushnumber(state, (*vec1)->dot(**vec2));

    return 1;
}

int vector3_cross(lua_State *state)
{
    auto *user_data1 = luaL_checkudata(state, 1, "Vector3");
    expect(user_data1 != nullptr, "incorrect user data");
    auto **vec1 = reinterpret_cast<Vector3 **>(user_data1);

    auto *user_data2 = luaL_checkudata(state, 2, "Vector3");
    expect(user_data2 != nullptr, "incorrect user data");
    auto **vec2 = reinterpret_cast<Vector3 **>(user_data2);

    vector3_construct_raw(state, (*vec1)->cross(**vec2));

    return 1;
}

int vector3_normalise(lua_State *state)
{
    auto **vector = get_vector3(state);

    (*vector)->normalise();

    return 0;
}

int vector3_magnitude(lua_State *state)
{
    auto **vector = get_vector3(state);

    ::lua_pushnumber(state, (*vector)->magnitude());

    return 1;
}

int vector3_lerp(lua_State *state)
{
    auto *user_data1 = luaL_checkudata(state, 1, "Vector3");
    expect(user_data1 != nullptr, "incorrect user data");
    auto **vec1 = reinterpret_cast<Vector3 **>(user_data1);

    auto *user_data2 = luaL_checkudata(state, 2, "Vector3");
    expect(user_data2 != nullptr, "incorrect user data");
    auto **vec2 = reinterpret_cast<Vector3 **>(user_data2);

    const auto amount = static_cast<float>(::luaL_checknumber(state, 3));

    (*vec1)->lerp(**vec2, amount);

    return 0;
}

}

```

`src/scripting/lua/lua_script.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "scripting/lua/lua_script.h"

#include <cstdint>
#include <memory>
#include <sstream>
#include <string>

extern "C"
{
#include "lauxlib.h"
#include "lua.h"
#include "lualib.h"
}

#include "core/auto_release.h"
#include "core/error_handling.h"
#include "core/vector3.h"
#include "scripting/lua/interop/quaternion.h"
#include "scripting/lua/interop/register_class.h"
#include "scripting/lua/interop/vector3.h"

namespace
{

/**
 * Helper function to create a lua state from a script string.
 *
 * @param source
 *   Lua script source.
 *
 * @return
 *   Lua state object.
 */
iris::AutoRelease<lua_State *, nullptr> create_lua_state(const std::string &source)
{
    auto *state = ::luaL_newstate();
    iris::ensure(state != nullptr, "could not create lua state");

    // register standard library and engine custom classes
    ::luaL_openlibs(state);
    iris::interop::lua::register_class(state, iris::interop::lua::vector3_class_interop);
    iris::interop::lua::register_class(state, iris::interop::lua::quaternion_class_interop);

    // try and load the script
    if (::luaL_loadstring(state, source.c_str()) == LUA_OK)
    {
        if (::lua_pcall(state, 0, 0, 0) == LUA_OK)
        {
            ::lua_pop(state, ::lua_gettop(state));
        }
    }
    else
    {
        // if the script failed to load then get the error string from the lua stack and throw it
        const auto error_msg = ::lua_tostring(state, -1);

        std::stringstream strm{};
        strm << "Execution of function failed: " << error_msg;

        throw iris::Exception(strm.str());
    }

    return {state, ::lua_close};
}

}

namespace iris
{

struct LuaScript::implementation
{
    AutoRelease<lua_State *, nullptr> state;
};

LuaScript::LuaScript(const std::string &source)
    : Script()
    , impl_(std::make_unique<implementation>())
{
    impl_->state = create_lua_state(source);
}

LuaScript::LuaScript(ResourceManager &resource_manager, const std::string &file)
    : Script()
    , impl_(std::make_unique<implementation>())
{
    const auto script_data = resource_manager.load(file);
    const std::string source(reinterpret_cast<const char *>(script_data.data()), script_data.size());

    impl_->state = create_lua_state(source);
}

LuaScript::~LuaScript() = default;

void LuaScript::set_argument(bool argument)
{
    ::lua_pushboolean(impl_->state, argument);
}

void LuaScript::set_function(const std::string &function)
{
    ensure(::lua_getglobal(impl_->state, function.c_str()) == LUA_TFUNCTION, "missing function");
}

void LuaScript::set_argument(std::int32_t argument)
{
    ::lua_pushinteger(impl_->state, argument);
}

void LuaScript::set_argument(float argument)
{
    ::lua_pushnumber(impl_->state, argument);
}

void LuaScript::set_argument(const char *argument)
{
    ::lua_pushstring(impl_->state, argument);
}

void LuaScript::set_argument(const std::string &argument)
{
    set_argument(argument.c_str());
}

void LuaScript::set_argument(const Vector3 &argument)
{
    interop::lua::vector3_construct_raw(impl_->state, argument);
}

void LuaScript::set_argument(const Quaternion &argument)
{
    interop::lua::quaternion_construct_raw(impl_->state, argument);
}

void LuaScript::execute(std::uint32_t num_args, std::uint32_t num_results)
{
    if (::lua_pcall(impl_->state, num_args, num_results, 0) != LUA_OK)
    {
        std::string error_msg;
        get_result(error_msg);

        std::stringstream strm{};
        strm << "Execution of function failed: " << error_msg;

        throw Exception(strm.str());
    }
}

void LuaScript::get_result(bool &result)
{
    ensure(lua_isboolean(impl_->state, -1) == 1, "incorrect result type");

    result = ::lua_toboolean(impl_->state, -1);
    ::lua_pop(impl_->state, 1);
}

void LuaScript::get_result(std::int32_t &result)
{
    ensure(lua_isinteger(impl_->state, -1) == 1, "incorrect result type");

    result = static_cast<std::int32_t>(::lua_tointeger(impl_->state, -1));
    ::lua_pop(impl_->state, 1);
}

void LuaScript::get_result(float &result)
{
    ensure(lua_isnumber(impl_->state, -1) == 1, "incorrect result type");

    result = static_cast<float>(::lua_tonumber(impl_->state, -1));
    ::lua_pop(impl_->state, 1);
}

void LuaScript::get_result(std::string &result)
{
    ensure(lua_isstring(impl_->state, -1) == 1, "incorrect result type");

    result = ::lua_tostring(impl_->state, -1);
    ::lua_pop(impl_->state, 1);
}

void LuaScript::get_result(Vector3 &result)
{
    auto **vector = interop::lua::get_vector3(impl_->state);
    result = **vector;

    ::lua_pop(impl_->state, 1);
}

void LuaScript::get_result(Quaternion &result)
{
    auto **q = interop::lua::get_quaternion(impl_->state);
    result = **q;

    ::lua_pop(impl_->state, 1);
}

}

```

`tests/CMakeLists.txt`:

```txt

FetchContent_MakeAvailable(googletest)

include(GoogleTest)

mark_as_advanced(BUILD_GMOCK BUILD_GTEST gtest_hide_internal_symbols)

add_executable(unit_tests "")

add_subdirectory("core")
add_subdirectory("graphics")
add_subdirectory("jobs")
add_subdirectory("networking")
add_subdirectory("platform")
add_subdirectory("scripting")

target_include_directories(unit_tests PRIVATE ${CMAKE_CURRENT_SOURCE_DIR})

if(IRIS_PLATFORM MATCHES "WIN32")
  set_target_properties(unit_tests PROPERTIES MSVC_RUNTIME_LIBRARY "MultiThreadedDebug")
  set_target_properties(gmock_main PROPERTIES MSVC_RUNTIME_LIBRARY "MultiThreadedDebug")
endif()

target_include_directories(
  unit_tests SYSTEM
  PRIVATE ${inja_SOURCE_DIR}/include ${inja_SOURCE_DIR}/third_party/include)
target_link_libraries(unit_tests iris gmock_main)
target_compile_definitions(unit_tests PRIVATE IRIS_FORCE_EXPECT)
gtest_discover_tests(unit_tests)

```

`tests/core/CMakeLists.txt`:

```txt
target_sources(unit_tests PRIVATE
    auto_release_tests.cpp
    colour_tests.cpp
    error_handling_tests.cpp
    matrix4_tests.cpp
    object_pool_tests.cpp
    quaternion_tests.cpp
    transform_tests.cpp
    vector3_tests.cpp)

```

`tests/core/auto_release_tests.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include <gtest/gtest.h>

#include "core/auto_release.h"

namespace
{

using AutoIntPtr = iris::AutoRelease<int *, nullptr>;

void deleter(int *value)
{
    --*value;
}

}

TEST(auto_release, ctor)
{
    int x = 1;
    AutoIntPtr v{&x, deleter};

    ASSERT_EQ(v.get(), &x);
    ASSERT_EQ(static_cast<int *>(v), &x);
    ASSERT_TRUE(v);
}

TEST(auto_release, function_deleter)
{
    int x = 1;

    {
        AutoIntPtr v{&x, deleter};
    }

    ASSERT_EQ(x, 0);
}

TEST(auto_release, lambda_deleter)
{
    int x = 1;
    int y = 2;

    {
        AutoIntPtr v{&x, [y](int *p) { *p += y; }};
    }

    ASSERT_EQ(x, 3);
}

TEST(auto_release, invalid)
{
    AutoIntPtr v{nullptr, deleter};

    ASSERT_EQ(v.get(), nullptr);
    ASSERT_FALSE(v);
}

TEST(auto_release, move_ctor)
{
    int x = 1;

    {
        AutoIntPtr v1{&x, deleter};
        AutoIntPtr v2{std::move(v1)};

        ASSERT_FALSE(v1);
        ASSERT_EQ(v1.get(), nullptr);
        ASSERT_TRUE(v2);
        ASSERT_EQ(v2.get(), &x);
    }

    ASSERT_EQ(x, 0);
}

TEST(auto_release, move_assignment)
{
    int x = 1;
    int y = 1;

    {
        AutoIntPtr v1{&x, deleter};
        AutoIntPtr v2{&y, deleter};

        v2 = std::move(v1);

        ASSERT_FALSE(v1);
        ASSERT_EQ(v1.get(), nullptr);
        ASSERT_TRUE(v2);
        ASSERT_EQ(v2.get(), &x);
    }

    ASSERT_EQ(x, 0);
    ASSERT_EQ(y, 0);
}

TEST(auto_release, address)
{
    int x = 1;

    {
        AutoIntPtr v{nullptr, deleter};

        const auto setter = [&x](int **p) { *p = std::addressof(x); };
        setter(&v);
    }

    ASSERT_EQ(x, 0);
}

TEST(auto_release, pointer)
{
    std::string str;

    iris::AutoRelease<std::string *, nullptr> v{&str, nullptr};
    v->push_back('c');

    ASSERT_EQ(str, "c");
}

```

`tests/core/colour_tests.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include <gtest/gtest.h>

#include "core/colour.h"

TEST(colour, empty_ctor)
{
    const iris::Colour c{};

    ASSERT_EQ(c.r, 0.0f);
    ASSERT_EQ(c.g, 0.0f);
    ASSERT_EQ(c.b, 0.0f);
    ASSERT_EQ(c.a, 1.0f);
}

TEST(colour, float_ctor)
{
    const iris::Colour c{0.1f, 0.2f, 0.3f, 0.4f};

    ASSERT_EQ(c.r, 0.1f);
    ASSERT_EQ(c.g, 0.2f);
    ASSERT_EQ(c.b, 0.3f);
    ASSERT_EQ(c.a, 0.4f);
}

TEST(colour, colour_alpha_ctor)
{
    const iris::Colour c1{0.1f, 0.2f, 0.3f, 0.4f};
    const iris::Colour c2{c1, 0.9f};

    ASSERT_EQ(c2.r, 0.1f);
    ASSERT_EQ(c2.g, 0.2f);
    ASSERT_EQ(c2.b, 0.3f);
    ASSERT_EQ(c2.a, 0.9f);
}

TEST(colour, byte_ctor)
{
    const iris::Colour c{0x0, 0x7f, 0xff, 0x33};

    ASSERT_EQ(c, iris::Colour(0.0f, 0.498039216f, 1.0f, 0.2f));
}

TEST(colour, byte_ctor_no_alpha)
{
    const iris::Colour c{0x0, 0x7f, 0xff};

    ASSERT_EQ(c, iris::Colour(0.0f, 0.498039216f, 1.0f, 1.0f));
}

TEST(colour, scale)
{
    iris::Colour c1{1.1f, 2.2f, 3.3f};
    auto c2 = c1 * 2.0f;

    ASSERT_EQ(c2, iris::Colour(2.2f, 4.4f, 6.6f, 2.0f));
}

TEST(colour, scale_assignment)
{
    iris::Colour c{1.1f, 2.2f, 3.3f};
    c *= 2.0f;

    ASSERT_EQ(c, iris::Colour(2.2f, 4.4f, 6.6f, 2.0f));
}

TEST(colour, add)
{
    iris::Colour c1{1.1f, 2.2f, 3.3f};
    auto c2 = c1 + iris::Colour{1.0f, 2.0f, 3.0f};

    ASSERT_EQ(c2, iris::Colour(2.1f, 4.2f, 6.3f, 2.0f));
}

TEST(colour, add_assignment)
{
    iris::Colour c{1.1f, 2.2f, 3.3f};
    c += iris::Colour{1.0f, 2.0f, 3.0f};

    ASSERT_EQ(c, iris::Colour(2.1f, 4.2f, 6.3f, 2.0f));
}

TEST(colour, subtract)
{
    iris::Colour c1{1.1f, 2.2f, 3.3f};
    auto c2 = c1 - iris::Colour{1.0f, 2.0f, 3.0f};

    ASSERT_EQ(c2, iris::Colour(0.1f, 0.2f, 0.3f, 0.0f));
}

TEST(colour, subtract_assignment)
{
    iris::Colour c{1.1f, 2.2f, 3.3f};
    c -= iris::Colour{1.0f, 2.0f, 3.0f};

    ASSERT_EQ(c, iris::Colour(0.1f, 0.2f, 0.3f, 0.0f));
}

TEST(colour, multiply)
{
    iris::Colour c1{1.1f, 2.2f, 3.3f};
    auto c2 = c1 * iris::Colour{1.0f, 2.0f, 3.0f};

    ASSERT_EQ(c2, iris::Colour(1.1f, 4.4f, 9.9f, 1.0f));
}

TEST(colour, multiply_assignment)
{
    iris::Colour c{1.1f, 2.2f, 3.3f};
    c *= iris::Colour{1.0f, 2.0f, 3.0f};

    ASSERT_EQ(c, iris::Colour(1.1f, 4.4f, 9.9f, 1.0f));
}

TEST(colour, equality)
{
    const iris::Colour c1{0.1f, 0.2f, 0.3f, 0.4f};
    const auto c2 = c1;

    ASSERT_EQ(c1, c2);
}

TEST(colour, inequality)
{
    const iris::Colour c1{0.1f, 0.2f, 0.3f, 0.4f};
    const iris::Colour c2{0.1f, 0.2f, 0.4f, 0.4f};

    ASSERT_NE(c1, c2);
}

TEST(colour, lerp)
{
    iris::Colour colour(0.0f, 0.0f, 0.0f, 0.0f);
    iris::Colour end(1.0f, 1.0f, 1.0f, 1.0f);

    colour.lerp(end, 0.5f);

    ASSERT_EQ(colour, iris::Colour(0.5f, 0.5f, 0.5f, 0.5f));
}

TEST(colour, lerp_static)
{
    iris::Colour start(0.0f, 0.0f, 0.f, 0.0f);
    iris::Colour end(1.0f, 1.0f, 1.0f, 1.0f);

    const auto result = iris::Colour::lerp(start, end, 0.5f);

    ASSERT_EQ(result, iris::Colour(0.5f, 0.5f, 0.5f, 0.5f));
}

```

`tests/core/error_handling_tests.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include <functional>
#include <memory>
#include <optional>
#include <string>
#include <string_view>

#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include "core/auto_release.h"
#include "core/error_handling.h"

namespace
{

using AutoIntPtr = iris::AutoRelease<int *, nullptr>;

void deleter(int *value)
{
    --*value;
}

}

TEST(expect, bool_expectation_true)
{
    ASSERT_NO_FATAL_FAILURE(iris::expect(true, ""));
}

TEST(expectDeathTest, bool_expectation_false)
{
    ASSERT_DEATH(
        iris::expect(false, "msg"), "msg -> .*error_handling_tests\\.cpp.*");
}

TEST(expect, function_expectation_true)
{
    std::function<std::optional<std::string>(std::string_view)> func =
        [](auto) { return std::optional<std::string>{}; };

    ASSERT_NO_FATAL_FAILURE(iris::expect(func, ""));
}

TEST(expectDeathTest, function_expectation_false)
{
    std::function<std::optional<std::string>(std::string_view)> func =
        [](auto) { return std::optional<std::string>{"err: 1"}; };

    ASSERT_DEATH(
        iris::expect(func, "msg"), "err: 1 -> .*error_handling_tests\\.cpp.*");
}

TEST(expect, unique_ptr_expectation_true)
{
    auto ptr = std::make_unique<int>(0);

    ASSERT_NO_FATAL_FAILURE(iris::expect(ptr, ""));
}

TEST(expectDeathTest, unique_ptr_expectation_false)
{
    std::unique_ptr<int> ptr;

    ASSERT_DEATH(
        iris::expect(ptr, "msg"), "msg -> .*error_handling_tests\\.cpp.*");
}

TEST(expect, auto_release_expectation_true)
{
    int x = 1;
    AutoIntPtr auto_release{&x, deleter};

    ASSERT_NO_FATAL_FAILURE(iris::expect(auto_release, ""));
}

TEST(expectDeathTest, auto_release_expectation_false)
{
    AutoIntPtr auto_release{};

    ASSERT_DEATH(
        iris::expect(auto_release, "msg"),
        "msg -> .*error_handling_tests\\.cpp.*");
}

TEST(ensure, bool_expectation_true)
{
    ASSERT_NO_THROW(iris::ensure(true, ""));
}

TEST(ensure, bool_expectation_false)
{
    auto thrown = false;
    try
    {
        iris::ensure(false, "msg");
    }
    catch (iris::Exception &e)
    {
        ASSERT_THAT(
            e.what(),
            ::testing::MatchesRegex("msg -> .*error_handling_tests\\.cpp.*"));
        thrown = true;
    }

    ASSERT_TRUE(thrown);
}

TEST(ensure, function_expectation_true)
{
    std::function<std::optional<std::string>(std::string_view)> func =
        [](auto) { return std::optional<std::string>{}; };

    ASSERT_NO_THROW(iris::ensure(func, ""));
}

TEST(ensure, function_expectation_false)
{
    auto thrown = false;

    try
    {
        std::function<std::optional<std::string>(std::string_view)> func =
            [](auto) { return std::optional<std::string>{"err: 1"}; };

        iris::ensure(func, "msg");
    }
    catch (iris::Exception &e)
    {
        ASSERT_THAT(
            e.what(),
            ::testing::MatchesRegex(
                "err: 1 -> .*error_handling_tests\\.cpp.*"));
        thrown = true;
    }

    ASSERT_TRUE(thrown);
}

TEST(ensure, unique_ptr_expectation_true)
{
    auto ptr = std::make_unique<int>(0);

    ASSERT_NO_THROW(iris::ensure(ptr, ""));
}

TEST(ensure, unique_ptr_expectation_false)
{
    auto thrown = false;

    try
    {
        std::unique_ptr<int> ptr;

        iris::ensure(ptr, "msg");
    }
    catch (iris::Exception &e)
    {
        ASSERT_THAT(
            e.what(),
            ::testing::MatchesRegex("msg -> .*error_handling_tests\\.cpp.*"));
        thrown = true;
    }

    ASSERT_TRUE(thrown);
}

TEST(ensure, auto_release_expectation_true)
{
    int x = 1;
    AutoIntPtr auto_release{&x, deleter};

    ASSERT_NO_THROW(iris::ensure(auto_release, ""));
}

TEST(ensure, auto_release_expectation_false)
{
    auto thrown = false;

    try
    {
        AutoIntPtr auto_release{};

        iris::ensure(auto_release, "msg");
    }
    catch (iris::Exception &e)
    {
        ASSERT_THAT(
            e.what(),
            ::testing::MatchesRegex("msg -> .*error_handling_tests\\.cpp.*"));
        thrown = true;
    }

    ASSERT_TRUE(thrown);
}

```

`tests/core/matrix4_tests.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include <array>
#include <cstring>

#include <gtest/gtest.h>

#include "core/matrix4.h"
#include "core/quaternion.h"
#include "core/vector3.h"

TEST(matrix4, constructor)
{
    iris::Matrix4 m{};

    ASSERT_EQ(m[0], 1.0f);
    ASSERT_EQ(m[1], 0.0f);
    ASSERT_EQ(m[2], 0.0f);
    ASSERT_EQ(m[3], 0.0f);
    ASSERT_EQ(m[4], 0.0f);
    ASSERT_EQ(m[5], 1.0f);
    ASSERT_EQ(m[6], 0.0f);
    ASSERT_EQ(m[7], 0.0f);
    ASSERT_EQ(m[8], 0.0f);
    ASSERT_EQ(m[9], 0.0f);
    ASSERT_EQ(m[10], 1.0f);
    ASSERT_EQ(m[11], 0.0f);
    ASSERT_EQ(m[12], 0.0f);
    ASSERT_EQ(m[13], 0.0f);
    ASSERT_EQ(m[14], 0.0f);
    ASSERT_EQ(m[15], 1.0f);
}

TEST(matrix4, value_constructor)
{
    iris::Matrix4 m{{{
        1.0f,
        2.0f,
        3.0f,
        4.0f,
        5.0f,
        6.0f,
        7.0f,
        8.0f,
        9.0f,
        10.0f,
        11.0f,
        12.0f,
        13.0f,
        14.0f,
        15.0f,
        16.0f,
    }}};

    ASSERT_EQ(m[0], 1.0f);
    ASSERT_EQ(m[1], 2.0f);
    ASSERT_EQ(m[2], 3.0f);
    ASSERT_EQ(m[3], 4.0f);
    ASSERT_EQ(m[4], 5.0f);
    ASSERT_EQ(m[5], 6.0f);
    ASSERT_EQ(m[6], 7.0f);
    ASSERT_EQ(m[7], 8.0f);
    ASSERT_EQ(m[8], 9.0f);
    ASSERT_EQ(m[9], 10.0f);
    ASSERT_EQ(m[10], 11.0f);
    ASSERT_EQ(m[11], 12.0f);
    ASSERT_EQ(m[12], 13.0f);
    ASSERT_EQ(m[13], 14.0f);
    ASSERT_EQ(m[14], 15.0f);
    ASSERT_EQ(m[15], 16.0f);
}

TEST(matrix4, rotation_constructor)
{
    iris::Matrix4 m{iris::Quaternion{1.0f, 2.0f, 3.0f, 4.0f}};

    iris::Matrix4 expected{{
        -25.0f,
        -20.0f,
        22.0f,
        0.0f,
        28.0f,
        -19.0f,
        4.0f,
        0.0f,
        -10.0f,
        20.0f,
        -9.0f,
        0.0f,
        0.0f,
        0.0f,
        0.0f,
        1.0f,
    }};

    ASSERT_EQ(m, expected);
}

TEST(matrix4, rotation_translation_constructor)
{
    iris::Matrix4 m{{1.0f, 2.0f, 3.0f, 4.0f}, {1.0f, 2.0f, 3.0f}};

    iris::Matrix4 expected{{
        -25.0f,
        -20.0f,
        22.0f,
        1.0f,
        28.0f,
        -19.0f,
        4.0f,
        2.0f,
        -10.0f,
        20.0f,
        -9.0f,
        3.0f,
        0.0f,
        0.0f,
        0.0f,
        1.0f,
    }};

    ASSERT_EQ(m, expected);
}

TEST(matrix4, equality)
{
    iris::Matrix4 m1{{{
        1.0f,
        2.0f,
        3.0f,
        4.0f,
        5.0f,
        6.0f,
        7.0f,
        8.0f,
        9.0f,
        10.0f,
        11.0f,
        12.0f,
        13.0f,
        14.0f,
        15.0f,
        16.0f,
    }}};

    auto m2 = m1;

    ASSERT_EQ(m1, m2);
}

TEST(matrix4, inequality)
{
    iris::Matrix4 m1{{{
        1.0f,
        2.0f,
        3.0f,
        4.0f,
        5.0f,
        6.0f,
        7.0f,
        8.0f,
        9.0f,
        10.0f,
        11.0f,
        12.0f,
        13.0f,
        14.0f,
        15.0f,
        16.0f,
    }}};

    auto m2 = m1;
    m2[0] = 100.0f;

    ASSERT_TRUE(m1 != m2);
}

TEST(matrix4, data)
{
    std::array<float, 16> elements{{
        1.0f,
        2.0f,
        3.0f,
        4.0f,
        5.0f,
        6.0f,
        7.0f,
        8.0f,
        9.0f,
        10.0f,
        11.0f,
        12.0f,
        13.0f,
        14.0f,
        15.0f,
        16.0f,
    }};

    iris::Matrix4 m{elements};

    ASSERT_EQ(
        std::memcmp(elements.data(), m.data(), sizeof(float) * elements.size()),
        0);
}

TEST(matrix4, column)
{
    iris::Matrix4 m{{{
        1.0f,
        2.0f,
        3.0f,
        4.0f,
        5.0f,
        6.0f,
        7.0f,
        8.0f,
        9.0f,
        10.0f,
        11.0f,
        12.0f,
        13.0f,
        14.0f,
        15.0f,
        16.0f,
    }}};

    ASSERT_EQ(m.column(0u), iris::Vector3(1.0f, 5.0f, 9.0f));
    ASSERT_EQ(m.column(1u), iris::Vector3(2.0f, 6.0f, 10.0f));
    ASSERT_EQ(m.column(2u), iris::Vector3(3.0f, 7.0f, 11.0f));
    ASSERT_EQ(m.column(3u), iris::Vector3(4.0f, 8.0f, 12.0f));
}

TEST(matrix4, matrix_multiplication)
{
    iris::Matrix4 m1{{{
        1.0f,
        2.0f,
        3.0f,
        4.0f,
        5.0f,
        6.0f,
        7.0f,
        8.0f,
        9.0f,
        10.0f,
        11.0f,
        12.0f,
        13.0f,
        14.0f,
        15.0f,
        16.0f,
    }}};

    iris::Matrix4 m2 = m1;
    auto m3 = m1 * m2;

    iris::Matrix4 expected{
        {{90.0f,
          100.0f,
          110.0f,
          120.0f,
          202.0f,
          228.0f,
          254.0f,
          280.0f,
          314.0f,
          356.0f,
          398.0f,
          440.0f,
          426.0f,
          484.0f,
          542.0f,
          600.0f}}};

    ASSERT_EQ(m3, expected);
}

TEST(matrix4, matrix_multiplication_assignment)
{
    iris::Matrix4 m1{{{
        1.0f,
        2.0f,
        3.0f,
        4.0f,
        5.0f,
        6.0f,
        7.0f,
        8.0f,
        9.0f,
        10.0f,
        11.0f,
        12.0f,
        13.0f,
        14.0f,
        15.0f,
        16.0f,
    }}};

    iris::Matrix4 m2 = m1;
    m2 *= m1;

    iris::Matrix4 expected{
        {{90.0f,
          100.0f,
          110.0f,
          120.0f,
          202.0f,
          228.0f,
          254.0f,
          280.0f,
          314.0f,
          356.0f,
          398.0f,
          440.0f,
          426.0f,
          484.0f,
          542.0f,
          600.0f}}};

    ASSERT_EQ(m2, expected);
}

TEST(matrix4, vector_multiplication)
{
    iris::Matrix4 m1{{{
        1.0f,
        2.0f,
        3.0f,
        4.0f,
        5.0f,
        6.0f,
        7.0f,
        8.0f,
        9.0f,
        10.0f,
        11.0f,
        12.0f,
        13.0f,
        14.0f,
        15.0f,
        16.0f,
    }}};

    auto m2 = m1 * iris::Vector3{1.1f, 2.2f, 3.3f};

    ASSERT_EQ(m2, iris::Vector3(19.4f, 49.8f, 80.2f));
}

TEST(matrix4, make_orthographic_projection)
{
    auto m =
        iris::Matrix4::make_orthographic_projection(100.0f, 100.0f, 100.0f);
    iris::Matrix4 expected{
        {{0.01f,
          0.0f,
          0.0f,
          0.0f,
          0.0f,
          0.01f,
          0.0f,
          0.0f,
          0.0f,
          0.0f,
          -0.01f,
          0.0f,
          0.0f,
          0.0f,
          0.0f,
          1.0f}}};

    ASSERT_EQ(m, expected);
}

TEST(matrix4, make_perspective_projection)
{
    auto m = iris::Matrix4::make_perspective_projection(
        0.785398f, 1.0f, 100.0f, 0.1f, 100.0f);

    iris::Matrix4 expected{
        {{241.421402f,
          0.0f,
          0.0f,
          0.0f,
          0.0f,
          2.414213896f,
          0.0f,
          0.0f,
          0.0f,
          0.0f,
          -1.002002001f,
          -0.2002002001f,
          0.0f,
          0.0f,
          -1.0f,
          0.0f}}};

    ASSERT_EQ(m, expected);
}

TEST(matrix4, make_look_at)
{
    auto m =
        iris::Matrix4::make_look_at({1.0f, 2.0f, 3.0f}, {}, {0.0f, 1.0f, 0.0f});

    iris::Matrix4 expected{
        {{0.9486833215f,
          0.0f,
          -0.3162277937f,
          5.960464478e-08f,
          -0.1690308601f,
          0.8451542854f,
          -0.5070925355f,
          0.0f,
          0.2672612369f,
          0.5345224738f,
          0.8017836809f,
          -3.741657257f,
          0.0f,
          0.0f,
          0.0f,
          1.0f}}};

    ASSERT_EQ(m, expected);
}

TEST(matrix4, make_scale)
{
    auto m = iris::Matrix4::make_scale({1.0f, 2.0f, 3.0f});

    iris::Matrix4 expected{
        {{1.0f,
          0.0f,
          0.0f,
          0.0f,
          0.0f,
          2.0f,
          0.0f,
          0.0f,
          0.0f,
          0.0f,
          3.0f,
          0.0f,
          0.0f,
          0.0f,
          0.0f,
          1.0f}}};

    ASSERT_EQ(m, expected);
}

TEST(matrix4, make_translate)
{
    auto m = iris::Matrix4::make_translate({1.0f, 2.0f, 3.0f});

    iris::Matrix4 expected{
        {{1.0f,
          0.0f,
          0.0f,
          1.0f,
          0.0f,
          1.0f,
          0.0f,
          2.0f,
          0.0f,
          0.0f,
          1.0f,
          3.0f,
          0.0f,
          0.0f,
          0.0f,
          1.0f}}};

    ASSERT_EQ(m, expected);
}

TEST(matrix4, transpose)
{
    iris::Matrix4 m{{{
        1.0f,
        2.0f,
        3.0f,
        4.0f,
        5.0f,
        6.0f,
        7.0f,
        8.0f,
        9.0f,
        10.0f,
        11.0f,
        12.0f,
        13.0f,
        14.0f,
        15.0f,
        16.0f,
    }}};

    iris::Matrix4 expected{{{
        1.0f,
        5.0f,
        9.0f,
        13.0f,
        2.0f,
        6.0f,
        10.0f,
        14.0f,
        3.0f,
        7.0f,
        11.0f,
        15.0f,
        4.0f,
        8.0f,
        12.0f,
        16.0f,
    }}};

    ASSERT_EQ(iris::Matrix4::transpose(m), expected);
}

TEST(matrix4, invert)
{
    iris::Matrix4 m{{{
        1.0f,
        1.0f,
        1.0f,
        -1.0f,
        1.0f,
        1.0f,
        -1.0f,
        1.0f,
        1.0f,
        -1.0f,
        1.0f,
        1.0f,
        -1.0f,
        1.0f,
        1.0f,
        1.0f,
    }}};

    iris::Matrix4 expected{{{
        0.25f,
        0.25f,
        0.25f,
        -0.25f,
        0.25f,
        0.25f,
        -0.25f,
        0.25f,
        0.25f,
        -0.25f,
        0.25f,
        0.25f,
        -0.25f,
        0.25f,
        0.25f,
        0.25f,
    }}};

    ASSERT_EQ(iris::Matrix4::invert(m), expected);
}

TEST(matrix4, invert_round_trip)
{
    iris::Matrix4 m{{{
        1.0f,
        1.0f,
        1.0f,
        -1.0f,
        1.0f,
        1.0f,
        -1.0f,
        1.0f,
        1.0f,
        -1.0f,
        1.0f,
        1.0f,
        -1.0f,
        1.0f,
        1.0f,
        1.0f,
    }}};

    ASSERT_EQ(m * iris::Matrix4::invert(m), iris::Matrix4{});
}

```

`tests/core/object_pool_tests.cpp`:

```cpp
#include "core/object_pool.h"

#include <gtest/gtest.h>

#include "core/thread.h"
#include "core/vector3.h"

TEST(object_pool, single)
{
    iris::ObjectPool<iris::Vector3> pool{};
    const auto *v = pool.next(1.0f, 2.0f, 3.0f);

    ASSERT_EQ(*v, iris::Vector3(1.0f, 2.0f, 3.0f));
}

TEST(object_pool, multiple)
{
    iris::ObjectPool<iris::Vector3> pool{};
    const auto *v1 = pool.next(1.0f, 2.0f, 3.0f);
    const auto *v2 = pool.next(1.1f, 2.1f, 3.1f);
    const auto *v3 = pool.next(1.2f, 2.2f, 3.2f);

    ASSERT_NE(v1, v2);
    ASSERT_NE(v1, v3);
    ASSERT_NE(v2, v3);
    ASSERT_EQ(*v1, iris::Vector3(1.0f, 2.0f, 3.0f));
    ASSERT_EQ(*v2, iris::Vector3(1.1f, 2.1f, 3.1f));
    ASSERT_EQ(*v3, iris::Vector3(1.2f, 2.2f, 3.2f));
}

TEST(object_pool, multiple_of_order)
{
    iris::ObjectPool<iris::Vector3> pool{};
    const auto *v1 = pool.next(1.0f, 2.0f, 3.0f);
    const auto *v2 = pool.next(1.1f, 2.1f, 3.1f);
    pool.release(v1);
    const auto *v3 = pool.next(1.2f, 2.2f, 3.2f);

    ASSERT_NE(v2, v3);
    ASSERT_EQ(*v2, iris::Vector3(1.1f, 2.1f, 3.1f));
    ASSERT_EQ(*v3, iris::Vector3(1.2f, 2.2f, 3.2f));
}

TEST(object_pool, drained_pool)
{
    iris::ObjectPool<int, 3> pool{};

    pool.next();
    pool.next();
    pool.next();
    ASSERT_THROW(pool.next(), iris::Exception);
}

TEST(object_pool, release)
{
    iris::ObjectPool<int> pool{};

    auto i1 = pool.next();
    pool.release(i1);
    auto i2 = pool.next();

    ASSERT_EQ(i1, i2);
}

TEST(object_pool, thread_safe_next)
{
    iris::ObjectPool<iris::Vector3> pool{};
    std::vector<iris::Vector3> vec1;
    std::vector<iris::Vector3> vec2;
    std::atomic<bool> start = false;

    iris::Thread t1 = [&start, &vec1, &pool]()
    {
        while (!start)
        {
        }

        for (auto i = 0u; i < 500u; ++i)
        {
            vec1.emplace_back(*pool.next(1.0f, 1.0f, 1.0f));
        }
    };

    iris::Thread t2 = [&start, &vec2, &pool]()
    {
        while (!start)
        {
        }

        for (auto i = 0u; i < 500u; ++i)
        {
            vec2.emplace_back(*pool.next(2.0f, 2.0f, 2.0f));
        }
    };

    start = true;
    t1.join();
    t2.join();

    ASSERT_EQ(vec1.size(), 500u);
    ASSERT_EQ(vec2.size(), 500u);
    ASSERT_TRUE(std::all_of(
        std::cbegin(vec1), std::cend(vec1), [&vec1](const auto &element) { return vec1.front() == element; }));
    ASSERT_TRUE(std::all_of(
        std::cbegin(vec2), std::cend(vec2), [&vec2](const auto &element) { return vec2.front() == element; }));
}

```

`tests/core/quaternion_tests.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include <gtest/gtest.h>

#include "core/quaternion.h"
#include "core/vector3.h"

TEST(quaternion, basic_constructor)
{
    iris::Quaternion q{};
    ASSERT_EQ(q, iris::Quaternion(0.0f, 0.0f, 0.0f, 1.0f));
}

TEST(quaternion, axis_angle_constructor)
{
    iris::Quaternion q{{1.0f, 0.0f, 0.0f}, 0.5f};
    ASSERT_EQ(q, iris::Quaternion(0.2474039644f, 0.0f, 0.0f, 0.9689124227f));
}

TEST(quaternion, compontent_constructor)
{
    iris::Quaternion q{1.0f, 2.0f, 3.0f, 4.0f};
    ASSERT_EQ(q, iris::Quaternion(1.0f, 2.0f, 3.0f, 4.0f));
}

TEST(quaternion, euler_constructor)
{
    iris::Quaternion q{0.1f, 0.2f, 0.3f};
    std::cout << std::setprecision(10) << q << std::endl;
    ASSERT_EQ(q, iris::Quaternion(0.1435721964f, 0.1060205176f, 0.0342707932f, 0.9833474755f));
}

TEST(quaternion, multiply)
{
    iris::Quaternion q1{{1.0f, 0.0f, 0.0f}, 0.5f};
    iris::Quaternion q2{{0.0f, 0.0f, 1.0f}, 0.2f};
    auto q3 = q1 * q2;

    ASSERT_EQ(q3, iris::Quaternion(0.2461679727f, -0.02469918504f, 0.09672984481f, 0.9640719295f));
}

TEST(quaternion, multiply_assignment)
{
    iris::Quaternion q1{{1.0f, 0.0f, 0.0f}, 0.5f};
    iris::Quaternion q2{{0.0f, 0.0f, 1.0f}, 0.2f};
    q1 *= q2;

    ASSERT_EQ(q1, iris::Quaternion(0.2461679727f, -0.02469918504f, 0.09672984481f, 0.9640719295f));
}

TEST(quaternion, vector_addition)
{
    iris::Quaternion q1{{1.0f, 0.0f, 0.0f}, 0.5f};
    iris::Vector3 v{0.0f, 0.0f, 1.0f};
    auto q2 = q1 + v;

    ASSERT_EQ(q2, iris::Quaternion(0.2474039644f, 0.1237019822f, 0.4844562113f, 0.9689124227f));
}

TEST(quaternion, vector_addition_assignment)
{
    iris::Quaternion q{{1.0f, 0.0f, 0.0f}, 0.5f};
    iris::Vector3 v{0.0f, 0.0f, 1.0f};
    q += v;

    ASSERT_EQ(q, iris::Quaternion(0.2474039644f, 0.1237019822f, 0.4844562113f, 0.9689124227f));
}

TEST(quaternion, scale)
{
    const iris::Quaternion q1{1.0f, 2.0f, 3.0f, 4.0f};
    const auto q2 = q1 * 1.5f;

    ASSERT_EQ(q2, iris::Quaternion(1.5f, 3.0f, 4.5f, 6.0f));
}

TEST(quaternion, scale_assignment)
{
    iris::Quaternion q{1.0f, 2.0f, 3.0f, 4.0f};
    q *= 1.5f;

    ASSERT_EQ(q, iris::Quaternion(1.5f, 3.0f, 4.5f, 6.0f));
}

TEST(quaternion, subtraction)
{
    const iris::Quaternion q1(1.0f, 2.0f, 3.0f, 4.0f);
    const auto q2 = q1 - iris::Quaternion{0.1f, 0.2, 0.3f, 0.4f};

    ASSERT_EQ(q2, iris::Quaternion(0.9f, 1.8f, 2.7f, 3.6f));
}

TEST(quaternion, subtraction_assignment)
{
    iris::Quaternion q(1.0f, 2.0f, 3.0f, 4.0f);
    q -= iris::Quaternion{0.1f, 0.2, 0.3f, 0.4f};

    ASSERT_EQ(q, iris::Quaternion(0.9f, 1.8f, 2.7f, 3.6f));
}

TEST(quaternion, addition)
{
    const iris::Quaternion q1(1.0f, 2.0f, 3.0f, 4.0f);
    const auto q2 = q1 + iris::Quaternion{0.1f, 0.2, 0.3f, 0.4f};

    ASSERT_EQ(q2, iris::Quaternion(1.1f, 2.2f, 3.3f, 4.4f));
}

TEST(quaternion, addition_assignment)
{
    iris::Quaternion q(1.0f, 2.0f, 3.0f, 4.0f);
    q += iris::Quaternion{0.1f, 0.2, 0.3f, 0.4f};

    ASSERT_EQ(q, iris::Quaternion(1.1f, 2.2f, 3.3f, 4.4f));
}

TEST(quaternion, negate)
{
    iris::Quaternion q(1.0f, 2.0f, 3.0f, 4.0f);

    ASSERT_EQ(-q, iris::Quaternion(-1.0f, -2.0f, -3.0f, -4.0f));
}

TEST(quaternion, dot)
{
    const iris::Quaternion q1(1.1f, 2.2f, 1.1f, 2.2f);
    const iris::Quaternion q2(0.1f, 0.2f, 0.3f, 0.4f);

    ASSERT_FLOAT_EQ(q1.dot(q2), 1.76f);
}

TEST(quaternion, slerp)
{
    iris::Quaternion q1(1.1f, 2.2f, 1.1f, 2.2f);
    const iris::Quaternion q2(0.1f, 0.2f, 0.3f, 0.4f);

    q1.slerp(q2, 0.5f);

    ASSERT_EQ(q1, iris::Quaternion(0.3007528484f, 0.6015056968f, 0.3508783281f, 0.6516311169f));
}

TEST(quaternion, slerp_zero)
{
    iris::Quaternion q1(1.1f, 2.2f, 1.1f, 2.2f);
    iris::Quaternion q2(0.1f, 0.2f, 0.3f, 0.4f);

    q1.normalise();
    q2.normalise();

    q1.slerp(q2, 0.0f);

    ASSERT_EQ(q1, q1);
}

TEST(quaternion, slerp_one)
{
    iris::Quaternion q1(1.1f, 2.2f, 1.1f, 2.2f);
    iris::Quaternion q2(0.1f, 0.2f, 0.3f, 0.4f);

    q1.normalise();
    q2.normalise();

    q1.slerp(q2, 1.0f);

    ASSERT_EQ(q1, q2);
}

TEST(quaternion, normalise)
{
    iris::Quaternion q{1.0f, 2.0f, 3.0f, 4.0f};
    q.normalise();

    ASSERT_EQ(q, iris::Quaternion(0.1825741827f, 0.3651483655f, 0.5477225184f, 0.730296731f));
}

```

`tests/core/transform_tests.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include <gtest/gtest.h>

#include "core/matrix4.h"
#include "core/quaternion.h"
#include "core/transform.h"
#include "core/vector3.h"

TEST(transform, empty_ctor)
{
    const iris::Transform transform{};

    const auto expected = iris::Matrix4::make_translate({}) *
                          iris::Matrix4(iris::Quaternion{}) *
                          iris::Matrix4::make_scale({1.0f});

    EXPECT_EQ(transform.matrix(), expected);
}

TEST(transform, transform_ctor)
{
    const iris::Vector3 translate{1.0f, 2.0f, 3.0f};
    const iris::Quaternion rotation{1.0f, 2.0f, 3.0f, 4.0f};
    const iris::Vector3 scale{2.0f};

    const auto expected = iris::Matrix4::make_translate(translate) *
                          iris::Matrix4(rotation) *
                          iris::Matrix4::make_scale(scale);
    const iris::Transform transform{translate, rotation, scale};

    EXPECT_EQ(transform.matrix(), expected);
}

TEST(transform, transform)
{
    const iris::Vector3 translate1{1.0f, 2.0f, 3.0f};
    const iris::Vector3 translate2{1.1f, 2.2f, 3.3f};
    const iris::Quaternion rotation{1.0f, 2.0f, 3.0f, 4.0f};
    const iris::Vector3 scale{2.0f};

    iris::Transform transform{translate1, rotation, scale};
    const auto get_translate1 = transform.translation();
    transform.set_translation(translate2);
    const auto get_translate2 = transform.translation();

    ASSERT_EQ(get_translate1, translate1);
    ASSERT_EQ(get_translate2, translate2);
}

TEST(transform, rotation)
{
    const iris::Vector3 translate{1.0f, 2.0f, 3.0f};
    const iris::Quaternion rotation1{1.0f, 2.0f, 3.0f, 4.0f};
    const iris::Quaternion rotation2{1.1f, 2.2f, 3.3f, 4.4f};
    const iris::Vector3 scale{2.0f};

    iris::Transform transform{translate, rotation1, scale};
    const auto get_rotation1 = transform.rotation();
    transform.set_rotation(rotation2);
    const auto get_rotation2 = transform.rotation();

    ASSERT_EQ(get_rotation1, rotation1);
    ASSERT_EQ(get_rotation2, rotation2);
}

TEST(transform, scale)
{
    const iris::Vector3 translate{1.0f, 2.0f, 3.0f};
    const iris::Quaternion rotation{1.0f, 2.0f, 3.0f, 4.0f};
    const iris::Vector3 scale1{2.0f};
    const iris::Vector3 scale2{2.2f};

    iris::Transform transform{translate, rotation, scale1};
    const auto get_scale1 = transform.scale();
    transform.set_scale(scale2);
    const auto get_scale2 = transform.scale();

    ASSERT_EQ(get_scale1, scale1);
    ASSERT_EQ(get_scale2, scale2);
}

TEST(transform, equality)
{
    const iris::Vector3 translate{1.0f, 2.0f, 3.0f};
    const iris::Quaternion rotation{1.0f, 2.0f, 3.0f, 4.0f};
    const iris::Vector3 scale{2.0f};

    const iris::Transform transform1{translate, rotation, scale};
    const iris::Transform transform2{translate, rotation, scale};

    ASSERT_EQ(transform1, transform2);
}

TEST(transform, inequality)
{
    const iris::Vector3 translate1{1.0f, 2.0f, 3.0f};
    const iris::Vector3 translate2{2.0f, 2.0f, 3.0f};
    const iris::Quaternion rotation{1.0f, 2.0f, 3.0f, 4.0f};
    const iris::Vector3 scale{2.0f};

    const iris::Transform transform1{translate1, rotation, scale};
    const iris::Transform transform2{translate2, rotation, scale};

    ASSERT_NE(translate1, translate2);
}

```

`tests/core/vector3_tests.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include <gtest/gtest.h>

#include "core/vector3.h"

TEST(vector3, default_constructor)
{
    iris::Vector3 v{};

    ASSERT_EQ(v.x, 0.0f);
    ASSERT_EQ(v.y, 0.0f);
    ASSERT_EQ(v.x, 0.0f);
}

TEST(vector3, single_value_constructor)
{
    iris::Vector3 v{1.1f};

    ASSERT_EQ(v.x, 1.1f);
    ASSERT_EQ(v.y, 1.1f);
    ASSERT_EQ(v.z, 1.1f);
}

TEST(vector3, multi_value_constructor)
{
    iris::Vector3 v{1.1f, 2.2f, 3.3f};

    ASSERT_EQ(v.x, 1.1f);
    ASSERT_EQ(v.y, 2.2f);
    ASSERT_EQ(v.z, 3.3f);
}

TEST(vector3, equality)
{
    iris::Vector3 v1{1.0f, 2.0f, 3.0f};
    iris::Vector3 v2{1.0f, 2.0f, 3.0f};

    ASSERT_EQ(v1, v2);
}

TEST(vector3, inequality)
{
    iris::Vector3 v1{1.0f, 2.0f, 3.0f};
    iris::Vector3 v2{1.1f, 2.2f, 3.2f};

    ASSERT_NE(v1, v2);
}

TEST(vector3, scale)
{
    iris::Vector3 v1{1.1f, 2.2f, 3.3f};
    auto v2 = v1 * 2.0f;

    ASSERT_EQ(v2, iris::Vector3(2.2f, 4.4f, 6.6f));
}

TEST(vector3, scale_assignment)
{
    iris::Vector3 v{1.1f, 2.2f, 3.3f};
    v *= 2.0f;

    ASSERT_EQ(v, iris::Vector3(2.2f, 4.4f, 6.6f));
}

TEST(vector3, add)
{
    iris::Vector3 v1{1.1f, 2.2f, 3.3f};
    auto v2 = v1 + iris::Vector3{1.0f, 2.0f, 3.0f};

    ASSERT_EQ(v2, iris::Vector3(2.1f, 4.2f, 6.3f));
}

TEST(vector3, add_assignment)
{
    iris::Vector3 v{1.1f, 2.2f, 3.3f};
    v += iris::Vector3{1.0f, 2.0f, 3.0f};

    ASSERT_EQ(v, iris::Vector3(2.1f, 4.2f, 6.3f));
}

TEST(vector3, subtract)
{
    iris::Vector3 v1{1.1f, 2.2f, 3.3f};
    auto v2 = v1 - iris::Vector3{1.0f, 2.0f, 3.0f};

    ASSERT_EQ(v2, iris::Vector3(0.1f, 0.2f, 0.3f));
}

TEST(vector3, subtract_assignment)
{
    iris::Vector3 v{1.1f, 2.2f, 3.3f};
    v -= iris::Vector3{1.0f, 2.0f, 3.0f};

    ASSERT_EQ(v, iris::Vector3(0.1f, 0.2f, 0.3f));
}

TEST(vector3, multiply)
{
    iris::Vector3 v1{1.1f, 2.2f, 3.3f};
    auto v2 = v1 * iris::Vector3{1.0f, 2.0f, 3.0f};

    ASSERT_EQ(v2, iris::Vector3(1.1f, 4.4f, 9.9f));
}

TEST(vector3, multiply_assignment)
{
    iris::Vector3 v{1.1f, 2.2f, 3.3f};
    v *= iris::Vector3{1.0f, 2.0f, 3.0f};

    ASSERT_EQ(v, iris::Vector3(1.1f, 4.4f, 9.9f));
}

TEST(vector3, negate)
{
    iris::Vector3 v{1.1f, 2.2f, 3.3f};

    ASSERT_EQ(-v, iris::Vector3(-1.1f, -2.2f, -3.3f));
}

TEST(vector3, dot)
{
    ASSERT_EQ(iris::Vector3(1.0f, 3.0f, -5.0f).dot(iris::Vector3(4.0f, -2.0f, -1.0f)), 3.0f);
}

TEST(vector3, cross)
{
    ASSERT_EQ(
        iris::Vector3(2.0f, 3.0f, 4.0f).cross(iris::Vector3(5.0f, 6.0f, 7.0f)), iris::Vector3(-3.0f, 6.0f, -3.0f));
}

TEST(vector3, cross_static)
{
    ASSERT_EQ(iris::Vector3::cross({2.0f, 3.0f, 4.0f}, {5.0f, 6.0f, 7.0f}), iris::Vector3(-3.0f, 6.0f, -3.0f));
}

TEST(vector3, normalise)
{
    iris::Vector3 v{1.0f, 2.0f, 3.0f};
    v.normalise();

    ASSERT_EQ(v, iris::Vector3(0.2672612f, 0.5345225f, 0.8017837f));
}

TEST(vector3, normalise_zero_vector3)
{
    iris::Vector3 v{};
    v.normalise();

    ASSERT_EQ(v, iris::Vector3());
}

TEST(vector3, normalise_static)
{
    ASSERT_EQ(
        iris::Vector3::normalise(iris::Vector3(1.0f, 2.0f, 3.0f)), iris::Vector3(0.2672612f, 0.5345225f, 0.8017837f));
}

TEST(vector3, magnitude)
{
    iris::Vector3 v{1.0f, 2.0f, 3.0f};

    ASSERT_FLOAT_EQ(v.magnitude(), 3.7416574954986572265625f);
}

TEST(vector3, lerp)
{
    iris::Vector3 vec(0.0f, 0.0f, 0.0f);
    iris::Vector3 end(1.0f, 1.0f, 1.0f);

    vec.lerp(end, 0.75f);

    ASSERT_EQ(vec, iris::Vector3(0.75f, 0.75f, 0.75f));
}

TEST(vector3, lerp_zero)
{
    iris::Vector3 vec(0.0f, 0.0f, 0.0f);
    iris::Vector3 end(1.0f, 1.0f, 1.0f);

    vec.lerp(end, 0.0f);

    ASSERT_EQ(vec, vec);
}

TEST(vector3, lerp_one)
{
    iris::Vector3 vec(0.0f, 0.0f, 0.0f);
    iris::Vector3 end(1.0f, 1.0f, 1.0f);

    vec.lerp(end, 1.0f);

    ASSERT_EQ(vec, end);
}

TEST(vector3, lerp_static)
{
    iris::Vector3 start(0.0f, 0.0f, 0.f);
    iris::Vector3 end(1.0f, 1.0f, 1.0f);

    const auto result = iris::Vector3::lerp(start, end, 0.5f);

    ASSERT_EQ(result, iris::Vector3(0.5f, 0.5f, 0.5f));
}

```

`tests/fakes/fake_light.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <array>
#include <limits>

#include "graphics/lights/light.h"
#include "graphics/lights/light_type.h"

class FakeLight : public iris::Light
{
  public:
    ~FakeLight() override = default;

    iris::LightType type() const override
    {
        return static_cast<iris::LightType>(
            std::numeric_limits<iris::LightType>::max());
    }

    std::array<float, 4u> colour_data() const override
    {
        return {};
    }

    std::array<float, 4u> world_space_data() const override
    {
        return {};
    }

    std::array<float, 3u> attenuation_data() const override
    {
        return {};
    }
};

```

`tests/fakes/fake_material.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <vector>

#include "graphics/cube_map.h"
#include "graphics/material.h"
#include "graphics/texture.h"

class FakeMaterial : public iris::Material
{
  public:
    FakeMaterial()
        : Material(nullptr)
    {
    }

    ~FakeMaterial() override = default;
};

```

`tests/fakes/fake_mesh.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <vector>

#include "graphics/mesh.h"
#include "graphics/vertex_data.h"

class FakeMesh : public iris::Mesh
{
  public:
    FakeMesh()
        : Mesh({}, {})
    {
    }

    ~FakeMesh() override = default;

    void update_vertex_data(const std::vector<iris::VertexData> &data) override
    {
    }

    void update_index_data(const std::vector<std::uint32_t> &data) override
    {
    }
};

```

`tests/fakes/fake_render_target.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <memory>

#include "fakes/fake_texture.h"
#include "graphics/render_target.h"
#include "graphics/texture.h"


#include "fakes/fake_texture.h"

class FakeRenderTarget : public iris::RenderTarget
{
  public:
    FakeRenderTarget()
        : iris::RenderTarget(new FakeTexture{}, new FakeTexture{})
    {
    }

    ~FakeRenderTarget() override = default;
};

```

`tests/fakes/fake_renderer.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <deque>
#include <functional>
#include <vector>

#include "graphics/render_command.h"
#include "graphics/render_command_type.h"
#include "graphics/render_pass.h"
#include "graphics/render_target.h"
#include "graphics/renderer.h"

class FakeRenderer : public iris::Renderer
{
  public:
    FakeRenderer(const std::vector<iris::RenderCommand> &render_queue)
        : iris::Renderer()
    {
        render_queue_ = render_queue;
    }

    std::vector<iris::RenderCommandType> call_log() const
    {
        return call_log_;
    }

    ~FakeRenderer() override = default;

    // overridden methods which just log when they are called

    void pre_render() override
    {
    }

    void execute_pass_start(iris::RenderCommand &) override
    {
        call_log_.emplace_back(iris::RenderCommandType::PASS_START);
    }

    void execute_draw(iris::RenderCommand &) override
    {
        call_log_.emplace_back(iris::RenderCommandType::DRAW);
    }

    void execute_pass_end(iris::RenderCommand &) override
    {
        call_log_.emplace_back(iris::RenderCommandType::PASS_END);
    }

    void execute_present(iris::RenderCommand &) override
    {
        call_log_.emplace_back(iris::RenderCommandType::PRESENT);
    }

    void post_render() override
    {
    }

  protected:
    void do_set_render_pipeline(std::function<void()> build_queue)
    {
        build_queue();
    }

  private:
    std::vector<iris::RenderCommandType> call_log_;
};
```

`tests/fakes/fake_texture.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include "graphics/texture.h"
#include "graphics/texture_usage.h"

class FakeTexture : public iris::Texture
{
  public:
    FakeTexture()
        : iris::Texture({}, 1u, 1u, nullptr, iris::TextureUsage::IMAGE, 0u)
    {
    }

    ~FakeTexture() override = default;
};

```

`tests/graphics/CMakeLists.txt`:

```txt
target_sources(unit_tests PRIVATE
    render_command_tests.cpp
    render_graph_tests.cpp)

```

`tests/graphics/render_command_tests.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include "core/vector3.h"
#include "graphics/mesh_loader.h"
#include "graphics/render_command.h"
#include "graphics/render_command_type.h"
#include "graphics/render_pass.h"
#include "graphics/render_pipeline.h"
#include "graphics/scene.h"
#include "graphics/single_entity.h"

#include "fakes/fake_light.h"
#include "fakes/fake_material.h"
#include "fakes/fake_mesh.h"
#include "fakes/fake_render_target.h"
#include "mocks/mock_material_manager.h"
#include "mocks/mock_mesh_manager.h"
#include "mocks/mock_render_target_manager.h"
#include "mocks/mock_resource_manager.h"

TEST(render_command_tests, default_ctor)
{
    iris::RenderCommand cmd{};

    ASSERT_EQ(cmd.type(), iris::RenderCommandType::PASS_START);
    ASSERT_EQ(cmd.render_pass(), nullptr);
    ASSERT_EQ(cmd.material(), nullptr);
    ASSERT_EQ(cmd.render_entity(), nullptr);
    ASSERT_EQ(cmd.shadow_map(), nullptr);
    ASSERT_EQ(cmd.light(), nullptr);
}

TEST(render_command_tests, ctor)
{
    MockResourceManager resource_manager{};
    MockMaterialManager material_manager{};
    MockMeshManager mesh_manager{resource_manager};
    MockRenderTargetManager render_target_manager{};

    iris::RenderPipeline pipeline{material_manager, mesh_manager, render_target_manager, 600u, 600u};
    FakeMesh mesh{};
    const auto type = iris::RenderCommandType::DRAW;
    const FakeMaterial material{};
    const iris::SingleEntity render_entity{&mesh, iris::Vector3{}};
    const FakeRenderTarget shadow_map{};
    const FakeLight light{};
    auto *scene = pipeline.create_scene();
    const auto *render_pass = pipeline.create_render_pass(scene);

    const iris::RenderCommand cmd{type, render_pass, &material, &render_entity, &shadow_map, &light};

    ASSERT_EQ(cmd.type(), type);
    ASSERT_EQ(cmd.render_pass(), render_pass);
    ASSERT_EQ(cmd.material(), &material);
    ASSERT_EQ(cmd.render_entity(), &render_entity);
    ASSERT_EQ(cmd.shadow_map(), &shadow_map);
    ASSERT_EQ(cmd.light(), &light);
}

TEST(render_command_tests, get_set_type)
{
    iris::RenderCommand cmd{};
    const auto new_value = iris::RenderCommandType::DRAW;

    cmd.set_type(new_value);

    ASSERT_EQ(cmd.type(), new_value);
}

TEST(render_command_tests, get_set_render_pass)
{
    MockResourceManager resource_manager{};
    MockMaterialManager material_manager{};
    MockMeshManager mesh_manager{resource_manager};
    MockRenderTargetManager render_target_manager{};

    iris::RenderPipeline pipeline{material_manager, mesh_manager, render_target_manager, 600u, 600u};
    auto *scene = pipeline.create_scene();
    const auto *render_pass = pipeline.create_render_pass(scene);
    iris::RenderCommand cmd{};

    cmd.set_render_pass(render_pass);

    ASSERT_EQ(cmd.render_pass(), render_pass);
}

TEST(render_command_tests, get_set_material)
{
    iris::RenderCommand cmd{};
    const FakeMaterial new_value{};

    cmd.set_material(&new_value);

    ASSERT_EQ(cmd.material(), &new_value);
}

TEST(render_command_tests, get_set_render_entity)
{
    FakeMesh mesh{};
    iris::RenderCommand cmd{};
    const iris::SingleEntity new_value{&mesh, iris::Vector3{}};

    cmd.set_render_entity(&new_value);

    ASSERT_EQ(cmd.render_entity(), &new_value);
}

TEST(render_command_tests, get_set_shadow_map)
{
    iris::RenderCommand cmd{};
    const FakeRenderTarget new_value{};

    cmd.set_shadow_map(&new_value);

    ASSERT_EQ(cmd.shadow_map(), &new_value);
}

TEST(render_command_tests, get_set_light)
{
    iris::RenderCommand cmd{};
    const FakeLight new_value{};

    cmd.set_light(&new_value);

    ASSERT_EQ(cmd.light(), &new_value);
}

```

`tests/graphics/render_graph_tests.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include <functional>

#include <gtest/gtest.h>

#include "fakes/fake_texture.h"
#include "graphics/render_graph/component_node.h"
#include "graphics/render_graph/render_graph.h"
#include "graphics/render_graph/texture_node.h"
#include "graphics/render_graph/value_node.h"
#include "graphics/render_pipeline.h"

#include "mocks/mock_material_manager.h"
#include "mocks/mock_mesh_manager.h"
#include "mocks/mock_render_target_manager.h"
#include "mocks/mock_resource_manager.h"

class RenderGraphTest : public ::testing::Test
{
  public:
    RenderGraphTest()
        : resource_manager_()
        , material_manager_()
        , mesh_manager_(resource_manager_)
        , render_target_manager_()
        , pipeline_(material_manager_, mesh_manager_, render_target_manager_, 600u, 600u)
    {
    }

    iris::RenderGraph *create_render_graph()
    {
        return pipeline_.create_render_graph();
    }

  private:
    MockResourceManager resource_manager_;
    MockMaterialManager material_manager_;
    MockMeshManager mesh_manager_;
    MockRenderTargetManager render_target_manager_;
    iris::RenderPipeline pipeline_;
};

TEST_F(RenderGraphTest, empty_graph_hash_the_same)
{
    const auto *rg1 = create_render_graph();
    const auto *rg2 = create_render_graph();

    ASSERT_EQ(std::hash<iris::RenderGraph *>{}(rg1), std::hash<iris::RenderGraph *>{}(rg2));
}

TEST_F(RenderGraphTest, simple_value_node_hash_the_same)
{
    auto *rg1 = create_render_graph();
    rg1->render_node()->set_colour_input(rg1->create<iris::ValueNode<float>>(1.2f));

    auto *rg2 = create_render_graph();
    rg2->render_node()->set_colour_input(rg2->create<iris::ValueNode<float>>(1.2f));

    ASSERT_EQ(std::hash<iris::RenderGraph *>{}(rg1), std::hash<iris::RenderGraph *>{}(rg2));
}

TEST_F(RenderGraphTest, simple_value_node_hash_different)
{
    auto *rg1 = create_render_graph();
    rg1->render_node()->set_colour_input(rg1->create<iris::ValueNode<float>>(1.2f));

    auto *rg2 = create_render_graph();
    rg2->render_node()->set_colour_input(rg2->create<iris::ValueNode<float>>(1.3f));

    ASSERT_NE(std::hash<iris::RenderGraph *>{}(rg1), std::hash<iris::RenderGraph *>{}(rg2));
}

TEST_F(RenderGraphTest, texture_node_single_texture_hash_the_same)
{
    FakeTexture texture{};

    auto *rg1 = create_render_graph();
    rg1->render_node()->set_colour_input(rg1->create<iris::TextureNode>(&texture));

    auto *rg2 = create_render_graph();
    rg2->render_node()->set_colour_input(rg2->create<iris::TextureNode>(&texture));

    ASSERT_EQ(std::hash<iris::RenderGraph *>{}(rg1), std::hash<iris::RenderGraph *>{}(rg2));
}

TEST_F(RenderGraphTest, texture_node_multiple_texture_hash_different)
{
    FakeTexture texture1{};
    FakeTexture texture2{};

    auto *rg1 = create_render_graph();
    rg1->render_node()->set_colour_input(rg1->create<iris::TextureNode>(&texture1));

    auto *rg2 = create_render_graph();
    rg2->render_node()->set_colour_input(rg2->create<iris::TextureNode>(&texture2));

    ASSERT_NE(std::hash<iris::RenderGraph *>{}(rg1), std::hash<iris::RenderGraph *>{}(rg2));
}

TEST_F(RenderGraphTest, complex_graph_hash_the_same)
{
    FakeTexture texture1{};
    FakeTexture texture2{};

    auto *rg1 = create_render_graph();
    rg1->render_node()->set_colour_input(rg1->create<iris::TextureNode>(&texture1));
    rg1->render_node()->set_specular_amount_input(
        rg1->create<iris::ComponentNode>(rg1->create<iris::TextureNode>(&texture2), "r"));

    auto *rg2 = create_render_graph();
    rg2->render_node()->set_colour_input(rg1->create<iris::TextureNode>(&texture1));
    rg2->render_node()->set_specular_amount_input(
        rg2->create<iris::ComponentNode>(rg2->create<iris::TextureNode>(&texture2), "r"));

    ASSERT_EQ(std::hash<iris::RenderGraph *>{}(rg1), std::hash<iris::RenderGraph *>{}(rg2));
}

```

`tests/jobs/CMakeLists.txt`:

```txt
target_sources(unit_tests PRIVATE
    concurrent_queue_tests.cpp
    thread_job_system_tests.cpp)

if(IRIS_ARCH MATCHES "X86_64")
    target_sources(unit_tests PRIVATE
        fiber_job_system_tests.cpp
        counter_tests.cpp)
endif()
```

`tests/jobs/concurrent_queue_tests.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include <algorithm>
#include <numeric>
#include <thread>
#include <vector>

#include <gtest/gtest.h>

#include "jobs/concurrent_queue.h"

TEST(concurrent_queue, constructor)
{
    iris::ConcurrentQueue<int> q;
    ASSERT_TRUE(q.empty());
}

TEST(concurrent_queue, enqueue)
{
    iris::ConcurrentQueue<int> q;
    q.enqueue(1);

    ASSERT_FALSE(q.empty());
}

TEST(concurrent_queue, try_dequeue)
{
    iris::ConcurrentQueue<int> q;
    q.enqueue(1);
    int value = 0;

    ASSERT_TRUE(q.try_dequeue(value));
    ASSERT_TRUE(q.empty());
    ASSERT_EQ(value, 1);
}

TEST(concurrent_queue, enqueue_thread_safe)
{
    static constexpr auto value_count = 10000;
    iris::ConcurrentQueue<int> q;
    std::vector<int> values(value_count);
    std::iota(std::begin(values), std::end(values), 0);

    const auto worker = [&q, &values](int start)
    {
        for (int i = start; i < start + (value_count / 4); i++)
        {
            q.enqueue(values[i]);
        }
    };

    std::thread thrd1{worker, (value_count / 4) * 0};
    std::thread thrd2{worker, (value_count / 4) * 1};
    std::thread thrd3{worker, (value_count / 4) * 2};
    std::thread thrd4{worker, (value_count / 4) * 3};

    thrd1.join();
    thrd2.join();
    thrd3.join();
    thrd4.join();

    std::vector<int> popped;

    for (int i = 0; i < value_count; ++i)
    {
        int element = 0;
        ASSERT_TRUE(q.try_dequeue(element));
        popped.emplace_back(element);
    }

    std::sort(std::begin(popped), std::end(popped));
    ASSERT_EQ(popped, values);
}

```

`tests/jobs/counter_tests.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include <gtest/gtest.h>

#include <mutex>
#include <thread>

#include "core/exception.h"
#include "jobs/fiber/counter.h"

TEST(counter, constructor)
{
    iris::Counter ctr(3);

    ASSERT_EQ(static_cast<int>(ctr), 3);
}

TEST(counter, prefix_decrement)
{
    iris::Counter ctr(3);
    --ctr;

    ASSERT_EQ(static_cast<int>(ctr), 2);
}

TEST(counter, postfix_decrement)
{
    iris::Counter ctr(3);
    ctr--;

    ASSERT_EQ(static_cast<int>(ctr), 2);
}

TEST(counter, thread_safe)
{
    static constexpr auto value = 10000;
    iris::Counter ctr(value);

    auto dec_thread = [&ctr]() {
        for (auto i = 0; i < value / 4; ++i)
        {
            --ctr;
        }
    };

    std::thread thrd1{dec_thread};
    std::thread thrd2{dec_thread};
    std::thread thrd3{dec_thread};
    std::thread thrd4{dec_thread};

    thrd1.join();
    thrd2.join();
    thrd3.join();
    thrd4.join();

    ASSERT_EQ(static_cast<int>(ctr), 0);
}

```

`tests/jobs/fiber_job_system_tests.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "jobs/job_system_tests.h"

#include "jobs/fiber/fiber_job_system.h"

INSTANTIATE_TYPED_TEST_SUITE_P(fiber, JobSystemTests, iris::FiberJobSystem);

```

`tests/jobs/job_system_tests.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include <atomic>
#include <stdexcept>
#include <thread>

#include <jobs/job_system.h>

#include <gtest/gtest.h>

template <class T>
class JobSystemTests : public ::testing::Test
{
  protected:
    T js_;
};

TYPED_TEST_SUITE_P(JobSystemTests);

TYPED_TEST_P(JobSystemTests, add_jobs_single)
{
    std::atomic<int> counter = 0;

    this->js_.add_jobs({[&counter]() { ++counter; }});

    while (counter != 1)
    {
    }

    ASSERT_EQ(counter, 1);
}

TYPED_TEST_P(JobSystemTests, add_jobs_multiple)
{
    std::atomic<int> counter = 0;

    this->js_.add_jobs(
        {[&counter]() { ++counter; },
         [&counter]() { ++counter; },
         [&counter]() { ++counter; },
         [&counter]() { ++counter; }});

    while (counter != 4)
    {
    }

    ASSERT_EQ(counter, 4);
}

TYPED_TEST_P(JobSystemTests, wait_for_jobs_single)
{
    std::atomic<bool> done = false;

    this->js_.wait_for_jobs({[&done]() { done = true; }});

    ASSERT_TRUE(done);
}

TYPED_TEST_P(JobSystemTests, wait_for_jobs_multiple)
{
    std::atomic<int> counter = 0;

    this->js_.wait_for_jobs(
        {[&counter]() {
             std::this_thread::sleep_for(std::chrono::milliseconds(1000));
             ++counter;
         },
         [&counter]() { ++counter; },
         [&counter]() { ++counter; },
         [&counter]() { ++counter; }});

    ASSERT_EQ(counter, 4);
}

TYPED_TEST_P(JobSystemTests, wait_for_jobs_nested)
{
    std::atomic<int> counter = 0;

    this->js_.wait_for_jobs({[&counter, this]() {
        this->js_.wait_for_jobs({[&counter, this]() {
            this->js_.wait_for_jobs({[&counter]() { ++counter; }});
            ++counter;
        }});
        ++counter;
    }});

    ASSERT_EQ(counter, 3);
}

TYPED_TEST_P(JobSystemTests, wait_for_jobs_sequential)
{
    std::atomic<int> counter = 0;

    this->js_.wait_for_jobs({[&counter]() { ++counter; }});
    this->js_.wait_for_jobs({[&counter]() { ++counter; }});

    ASSERT_EQ(counter, 2);
}

TYPED_TEST_P(JobSystemTests, exceptions_propagate)
{
    const auto throws = []() { throw std::runtime_error(""); };
    ASSERT_THROW(this->js_.wait_for_jobs({throws}), std::runtime_error);
}

TYPED_TEST_P(JobSystemTests, exceptions_propagate_complex)
{
    ASSERT_THROW(
        this->js_.wait_for_jobs(
            {[this]() {
                 this->js_.wait_for_jobs(
                     {[]() {},
                      [this]() {
                          this->js_.wait_for_jobs(
                              {[]() { throw std::runtime_error(""); }});
                      },
                      []() {},
                      []() {}});
             },
             []() {}}),
        std::runtime_error);
}

TYPED_TEST_P(JobSystemTests, exceptions_propagate_first_job)
{
    ASSERT_THROW(
        this->js_.wait_for_jobs({[]() { throw std::runtime_error(""); }}),
        std::runtime_error);
}

REGISTER_TYPED_TEST_SUITE_P(
    JobSystemTests,
    add_jobs_single,
    add_jobs_multiple,
    wait_for_jobs_single,
    wait_for_jobs_multiple,
    wait_for_jobs_nested,
    wait_for_jobs_sequential,
    exceptions_propagate,
    exceptions_propagate_complex,
    exceptions_propagate_first_job);

```

`tests/jobs/thread_job_system_tests.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "jobs/job_system_tests.h"

#include "jobs/thread/thread_job_system.h"

INSTANTIATE_TYPED_TEST_SUITE_P(thread, JobSystemTests, iris::ThreadJobSystem);

```

`tests/mocks/mock_material_manager.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>

#include <gmock/gmock.h>

#include "graphics/lights/light_type.h"
#include "graphics/material.h"
#include "graphics/material_manager.h"
#include "graphics/render_entity.h"

class MockMaterialManager : public iris::MaterialManager
{
  public:
    MOCK_METHOD(
        iris::Material *,
        create,
        (iris::RenderGraph *, iris::RenderEntity *, iris::LightType, bool, bool, bool, bool),
        (override));
    MOCK_METHOD(void, clear, (), (override));
};

```

`tests/mocks/mock_mesh_manager.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <memory>
#include <vector>

#include <gmock/gmock.h>

#include "core/resource_manager.h"
#include "graphics/mesh.h"
#include "graphics/mesh_manager.h"
#include "graphics/vertex_data.h"

class MockMeshManager : public iris::MeshManager
{
  public:
    MockMeshManager(iris::ResourceManager &resource_manager)
        : MeshManager(resource_manager, true)
    {
    }

  protected:
    MOCK_METHOD(
        std::unique_ptr<iris::Mesh>,
        create_mesh,
        (const std::vector<iris::VertexData> &, const std::vector<std::uint32_t> &),
        (const, override));
};

```

`tests/mocks/mock_render_target_manager.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>

#include <gmock/gmock.h>

#include "graphics/render_target.h"
#include "graphics/render_target_manager.h"

class MockRenderTargetManager : public iris::RenderTargetManager
{
  protected:
    MOCK_METHOD(iris::RenderTarget *, create, (), (override));
    MOCK_METHOD(iris::RenderTarget *, create, (std::uint32_t, std::uint32_t), (override));
    MOCK_METHOD(iris::RenderTarget *, create, (const iris::RenderTarget *, const iris::RenderTarget *), (override));
};

```

`tests/mocks/mock_resource_manager.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <string_view>

#include <gmock/gmock.h>

#include "core/data_buffer.h"
#include "core/resource_manager.h"

class MockResourceManager : public iris::ResourceManager
{
  protected:
    MOCK_METHOD(iris::DataBuffer, do_load, (std::string_view), (override));
};

```

`tests/mocks/mock_script.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>

#include <gmock/gmock.h>

#include "core/quaternion.h"
#include "core/vector3.h"
#include "scripting/script.h"

class MockScript : public iris::Script
{
  public:
    ~MockScript() override = default;

    MOCK_METHOD(void, set_function, (const std::string &), (override));
    MOCK_METHOD(void, set_argument, (bool), (override));
    MOCK_METHOD(void, set_argument, (std::int32_t), (override));
    MOCK_METHOD(void, set_argument, (float), (override));
    MOCK_METHOD(void, set_argument, (const char *), (override));
    MOCK_METHOD(void, set_argument, (const std::string &), (override));
    MOCK_METHOD(void, set_argument, (const iris::Vector3 &), (override));
    MOCK_METHOD(void, set_argument, (const iris::Quaternion &), (override));

    MOCK_METHOD(void, execute, (std::uint32_t, std::uint32_t), (override));

    MOCK_METHOD(void, get_result, (bool &), (override));
    MOCK_METHOD(void, get_result, (std::int32_t &), (override));
    MOCK_METHOD(void, get_result, (float &), (override));
    MOCK_METHOD(void, get_result, (std::string &), (override));
    MOCK_METHOD(void, get_result, (iris::Vector3 &), (override));
    MOCK_METHOD(void, get_result, (iris::Quaternion &), (override));
};

```

`tests/networking/CMakeLists.txt`:

```txt
target_sources(unit_tests PRIVATE
    data_buffer_serialiser_tests.cpp
    packet_tests.cpp
    reliable_ordered_channel_tests.cpp
    unreliable_sequenced_channel_tests.cpp
    unreliable_unordered_channel_tests.cpp)

```

`tests/networking/data_buffer_serialiser_tests.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include <gtest/gtest.h>

#include "networking/data_buffer_deserialiser.h"
#include "networking/data_buffer_serialiser.h"

TEST(data_buffer_seraliser_tests, constructor)
{
    iris::DataBufferSerialiser ser{};

    ASSERT_TRUE(ser.data().empty());
}

TEST(data_buffer_seraliser_tests, 8bit_int)
{
    std::uint8_t val = 12u;

    iris::DataBufferSerialiser ser{};

    ser.push(val);
    iris::DataBufferDeserialiser der{ser.data()};

    ASSERT_EQ(der.pop<std::uint8_t>(), val);
}

TEST(data_buffer_seraliser_tests, 16bit_int)
{
    std::uint16_t val = 12345u;

    iris::DataBufferSerialiser ser{};

    ser.push(val);
    iris::DataBufferDeserialiser der{ser.data()};

    ASSERT_EQ(der.pop<std::uint16_t>(), val);
}

TEST(data_buffer_seraliser_tests, 32bit_int)
{
    std::uint32_t val = 123456789u;

    iris::DataBufferSerialiser ser{};

    ser.push(val);
    iris::DataBufferDeserialiser der{ser.data()};

    ASSERT_EQ(der.pop<std::uint32_t>(), val);
}

TEST(data_buffer_seraliser_tests, 64bit_int)
{
    std::uint64_t val = 12345678901233456u;

    iris::DataBufferSerialiser ser{};

    ser.push(val);
    iris::DataBufferDeserialiser der{ser.data()};

    ASSERT_EQ(der.pop<std::uint64_t>(), val);
}

TEST(data_buffer_seraliser_tests, enum)
{
    enum class Val : std::uint8_t
    {
        A = 12
    };

    auto val = Val::A;

    iris::DataBufferSerialiser ser{};

    ser.push(val);
    iris::DataBufferDeserialiser der{ser.data()};

    ASSERT_EQ(der.pop<Val>(), val);
}

TEST(data_buffer_seraliser_tests, float)
{
    float val = 1.2345f;

    iris::DataBufferSerialiser ser{};

    ser.push(val);
    iris::DataBufferDeserialiser der{ser.data()};

    ASSERT_EQ(der.pop<float>(), val);
}

TEST(data_buffer_seraliser_tests, vector3)
{
    iris::Vector3 val{1.1f, 2.2f, 3.3f};

    iris::DataBufferSerialiser ser{};

    ser.push(val);
    iris::DataBufferDeserialiser der{ser.data()};

    ASSERT_EQ(der.pop<iris::Vector3>(), val);
}

TEST(data_buffer_seraliser_tests, quaternion)
{
    iris::Quaternion val{1.1f, 2.2f, 3.3f, 4.4f};

    iris::DataBufferSerialiser ser{};

    ser.push(val);
    iris::DataBufferDeserialiser der{ser.data()};

    ASSERT_EQ(der.pop<iris::Quaternion>(), val);
}

TEST(data_buffer_seraliser_tests, data_buffer)
{
    iris::DataBuffer val{
        static_cast<std::byte>(0x0),
        static_cast<std::byte>(0x1),
        static_cast<std::byte>(0x2)};

    iris::DataBufferSerialiser ser{};

    ser.push(val);
    iris::DataBufferDeserialiser der{ser.data()};

    ASSERT_EQ(der.pop<iris::DataBuffer>(), val);
}

TEST(data_buffer_seraliser_tests, complex)
{
    iris::DataBuffer val1{
        static_cast<std::byte>(0x0),
        static_cast<std::byte>(0x1),
        static_cast<std::byte>(0x2)};
    iris::Vector3 val2{1.1f, 2.2f, 3.3};
    std::int32_t val3 = -4;

    iris::DataBufferSerialiser ser{};

    ser.push(val1);
    ser.push(val2);
    ser.push(val3);
    iris::DataBufferDeserialiser der{ser.data()};

    const auto &[pop1, pop2, pop3] =
        der.pop_tuple<iris::DataBuffer, iris::Vector3, std::int32_t>();
    ASSERT_EQ(pop1, val1);
    ASSERT_EQ(pop2, val2);
    ASSERT_EQ(pop3, val3);
}

```

`tests/networking/helper.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <tuple>
#include <vector>

#include "core/data_buffer.h"
#include "networking/packet.h"

static const iris::DataBuffer test_data{
    static_cast<std::byte>(0xaa),
    static_cast<std::byte>(0xbb),
    static_cast<std::byte>(0xcc),
};

/**
 * Helper method to create a collection of packets with supplied sequence
 * numbers and types.
 *
 * @param packet_sequence
 *   Collection of sequence numbers and types.
 *
 * @returns
 *   Packets created using supplied data.
 */
inline std::vector<iris::Packet>
create_packets(const std::vector<std::tuple<std::uint16_t, iris::PacketType>>
                   &packet_sequence)
{
    std::vector<iris::Packet> packets;

    for (const auto &[sequence, type] : packet_sequence)
    {
        // acks don't have data
        const auto data =
            type == iris::PacketType::ACK ? iris::DataBuffer{} : test_data;

        iris::Packet packet{type, iris::ChannelType::RELIABLE_ORDERED, data};
        packet.set_sequence(sequence);
        packets.emplace_back(packet);
    }

    return packets;
}

```

`tests/networking/packet_tests.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include <gtest/gtest.h>

#include "core/exception.h"
#include "networking/packet.h"
#include "networking/packet_type.h"

static const iris::DataBuffer test_data{
    static_cast<std::byte>(0x0),
    static_cast<std::byte>(0x1),
    static_cast<std::byte>(0x2)};

TEST(packet, construct_invalid)
{
    iris::Packet p{};

    ASSERT_FALSE(p.is_valid());
}

TEST(packet, construct_normal)
{
    iris::Packet p{
        iris::PacketType::DATA, iris::ChannelType::RELIABLE_ORDERED, test_data};

    ASSERT_TRUE(p.is_valid());
    ASSERT_EQ(p.type(), iris::PacketType::DATA);
    ASSERT_EQ(p.channel(), iris::ChannelType::RELIABLE_ORDERED);
    ASSERT_EQ(p.body_buffer(), test_data);
    ASSERT_EQ(p.body_size(), test_data.size());
    ASSERT_EQ(p.sequence(), 0u);
    ASSERT_EQ(iris::DataBuffer(p.body(), p.body() + p.body_size()), test_data);
    ASSERT_EQ(std::memcmp(p.data(), &p, p.packet_size()), 0u);
}

TEST(packet, construct_raw_packet)
{
    iris::Packet p1{
        iris::PacketType::DATA, iris::ChannelType::RELIABLE_ORDERED, test_data};

    iris::DataBuffer raw_packet{p1.data(), p1.data() + p1.packet_size()};

    iris::Packet p2{raw_packet};

    ASSERT_EQ(p1, p2);
}

TEST(packet, sequence)
{
    iris::Packet p{
        iris::PacketType::DATA, iris::ChannelType::RELIABLE_ORDERED, test_data};

    p.set_sequence(10u);

    ASSERT_EQ(p.sequence(), 10u);
}

TEST(packet, equality)
{
    iris::Packet p1{
        iris::PacketType::DATA, iris::ChannelType::RELIABLE_ORDERED, test_data};
    iris::Packet p2{
        iris::PacketType::DATA, iris::ChannelType::RELIABLE_ORDERED, test_data};

    ASSERT_EQ(p1, p2);
}

TEST(packet, inequality)
{
    iris::Packet p1{
        iris::PacketType::HELLO,
        iris::ChannelType::RELIABLE_ORDERED,
        test_data};
    iris::Packet p2{
        iris::PacketType::DATA, iris::ChannelType::RELIABLE_ORDERED, test_data};

    ASSERT_NE(p1, p2);
}

```

`tests/networking/reliable_ordered_channel_tests.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include <gtest/gtest.h>

#include <vector>

#include "networking/channel/reliable_ordered_channel.h"
#include "networking/packet.h"

#include "helper.h"

TEST(reliable_ordered_channel, unacked_packet_is_resent)
{
    const auto in_packets = create_packets({
        {0u, iris::PacketType::DATA},
    });
    iris::ReliableOrderedChannel channel{};

    for (const auto &packet : in_packets)
    {
        channel.enqueue_send(packet);
    }

    ASSERT_EQ(channel.yield_send_queue(), in_packets);
    ASSERT_EQ(channel.yield_send_queue(), in_packets);
    ASSERT_TRUE(channel.yield_receive_queue().empty());
}

TEST(reliable_ordered_channel, packet_sequence_set)
{
    const auto in_packets = create_packets({
        {0u, iris::PacketType::DATA},
        {0u, iris::PacketType::DATA},
        {0u, iris::PacketType::DATA},
    });
    const auto expected = create_packets({
        {0u, iris::PacketType::DATA},
        {1u, iris::PacketType::DATA},
        {2u, iris::PacketType::DATA},
    });
    iris::ReliableOrderedChannel channel{};

    for (const auto &packet : in_packets)
    {
        channel.enqueue_send(packet);
    }

    ASSERT_EQ(channel.yield_send_queue(), expected);
    ASSERT_TRUE(channel.yield_receive_queue().empty());
}

TEST(reliable_ordered_channel, single_ack_single_packet)
{
    const auto in_packets = create_packets({
        {0u, iris::PacketType::DATA},
    });
    const auto out_packets = create_packets({
        {0u, iris::PacketType::ACK},
    });
    iris::ReliableOrderedChannel channel{};

    for (const auto &packet : in_packets)
    {
        channel.enqueue_send(packet);
    }

    for (const auto &packet : out_packets)
    {
        channel.enqueue_receive(packet);
    }

    ASSERT_TRUE(channel.yield_send_queue().empty());
    ASSERT_TRUE(channel.yield_receive_queue().empty());
}

TEST(reliable_ordered_channel, single_ack_multi_packet)
{
    const auto in_packets = create_packets({
        {0u, iris::PacketType::DATA},
        {0u, iris::PacketType::DATA},
        {0u, iris::PacketType::DATA},
    });
    const auto out_packets = create_packets({
        {1u, iris::PacketType::ACK},
    });
    const auto expected = create_packets({
        {0u, iris::PacketType::DATA},
        {2u, iris::PacketType::DATA},
    });
    iris::ReliableOrderedChannel channel{};

    for (const auto &packet : in_packets)
    {
        channel.enqueue_send(packet);
    }

    for (const auto &packet : out_packets)
    {
        channel.enqueue_receive(packet);
    }

    ASSERT_EQ(channel.yield_send_queue(), expected);
    ASSERT_TRUE(channel.yield_receive_queue().empty());
}

TEST(reliable_ordered_channel, multi_ack_single_packet)
{
    const auto in_packets = create_packets({
        {0u, iris::PacketType::DATA},
    });
    const auto out_packets = create_packets({
        {1u, iris::PacketType::ACK},
        {2u, iris::PacketType::ACK},
        {3u, iris::PacketType::ACK},
    });
    iris::ReliableOrderedChannel channel{};

    for (const auto &packet : in_packets)
    {
        channel.enqueue_send(packet);
    }

    for (const auto &packet : out_packets)
    {
        channel.enqueue_receive(packet);
    }

    ASSERT_EQ(channel.yield_send_queue(), in_packets);
    ASSERT_TRUE(channel.yield_receive_queue().empty());
}

TEST(reliable_ordered_channel, multi_ack_multi_packet)
{
    const auto in_packets = create_packets({
        {0u, iris::PacketType::DATA},
        {0u, iris::PacketType::DATA},
        {0u, iris::PacketType::DATA},
        {0u, iris::PacketType::DATA},
    });
    const auto out_packets = create_packets({
        {4u, iris::PacketType::ACK},
        {4u, iris::PacketType::ACK},
        {4u, iris::PacketType::ACK},
        {1u, iris::PacketType::ACK},
        {2u, iris::PacketType::ACK},
        {1u, iris::PacketType::ACK},
        {3u, iris::PacketType::ACK},
        {3u, iris::PacketType::ACK},
        {1u, iris::PacketType::ACK},
        {0u, iris::PacketType::ACK},
    });
    iris::ReliableOrderedChannel channel{};

    for (const auto &packet : in_packets)
    {
        channel.enqueue_send(packet);
    }

    for (const auto &packet : out_packets)
    {
        channel.enqueue_receive(packet);
    }

    ASSERT_TRUE(channel.yield_send_queue().empty());
    ASSERT_TRUE(channel.yield_receive_queue().empty());
}

TEST(reliable_ordered_channel, single_out_acked)
{
    const auto in_packets = create_packets({
        {0u, iris::PacketType::ACK},
    });
    const auto out_packets = create_packets({
        {0u, iris::PacketType::DATA},
    });
    iris::ReliableOrderedChannel channel{};

    for (const auto &packet : out_packets)
    {
        channel.enqueue_receive(packet);
    }

    ASSERT_EQ(channel.yield_receive_queue(), out_packets);
    ASSERT_EQ(channel.yield_send_queue(), in_packets);
}

TEST(reliable_ordered_channel, multi_out_acked)
{
    const auto in_packets = create_packets({
        {0u, iris::PacketType::ACK},
        {1u, iris::PacketType::ACK},
        {2u, iris::PacketType::ACK},
    });
    const auto out_packets = create_packets({
        {0u, iris::PacketType::DATA},
        {1u, iris::PacketType::DATA},
        {2u, iris::PacketType::DATA},
    });
    iris::ReliableOrderedChannel channel{};

    for (const auto &packet : out_packets)
    {
        channel.enqueue_receive(packet);
    }

    ASSERT_EQ(channel.yield_receive_queue(), out_packets);
    ASSERT_EQ(channel.yield_send_queue(), in_packets);
}

TEST(reliable_ordered_channel, multi_out_acked_unordered)
{
    const auto in_packets = create_packets({
        {2u, iris::PacketType::ACK},
        {0u, iris::PacketType::ACK},
        {1u, iris::PacketType::ACK},
        {3u, iris::PacketType::ACK},
    });
    const auto out_packets = create_packets({
        {2u, iris::PacketType::DATA},
        {0u, iris::PacketType::DATA},
        {1u, iris::PacketType::DATA},
        {3u, iris::PacketType::DATA},
    });
    const auto expected = create_packets({
        {0u, iris::PacketType::DATA},
        {1u, iris::PacketType::DATA},
        {2u, iris::PacketType::DATA},
        {3u, iris::PacketType::DATA},
    });
    iris::ReliableOrderedChannel channel{};

    for (const auto &packet : out_packets)
    {
        channel.enqueue_receive(packet);
    }

    ASSERT_EQ(channel.yield_receive_queue(), expected);
    ASSERT_EQ(channel.yield_send_queue(), in_packets);
}

TEST(reliable_ordered_channel, multi_out_acked_early_yield)
{
    const auto in_packets = create_packets({
        {3u, iris::PacketType::ACK},
        {1u, iris::PacketType::ACK},
        {0u, iris::PacketType::ACK},
        {2u, iris::PacketType::ACK},
    });
    const auto out_packets = create_packets({
        {3u, iris::PacketType::DATA},
        {1u, iris::PacketType::DATA},
        {0u, iris::PacketType::DATA},
        {2u, iris::PacketType::DATA},
    });
    const auto expected1 = create_packets({
        {0u, iris::PacketType::DATA},
        {1u, iris::PacketType::DATA},
    });
    const auto expected2 = create_packets({
        {2u, iris::PacketType::DATA},
        {3u, iris::PacketType::DATA},
    });
    iris::ReliableOrderedChannel channel{};

    channel.enqueue_receive(out_packets[0u]);
    channel.enqueue_receive(out_packets[1u]);
    channel.enqueue_receive(out_packets[2u]);
    const auto out_queue1 = channel.yield_receive_queue();
    channel.enqueue_receive(out_packets[3u]);
    const auto out_queue2 = channel.yield_receive_queue();
    const auto out_queue3 = channel.yield_receive_queue();

    ASSERT_EQ(out_queue1, expected1);
    ASSERT_EQ(out_queue2, expected2);
    ASSERT_TRUE(out_queue3.empty());
    ASSERT_EQ(channel.yield_send_queue(), in_packets);
}

```

`tests/networking/unreliable_sequenced_channel_tests.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include <gtest/gtest.h>

#include <vector>

#include "networking/channel/unreliable_sequenced_channel.h"
#include "networking/packet.h"

#include "helper.h"

TEST(unreliable_sequenced_channel, in_queue_single)
{
    const auto in_packets = create_packets({
        {0u, iris::PacketType::DATA},
    });
    iris::UnreliableSequencedChannel channel{};

    for (const auto &packet : in_packets)
    {
        channel.enqueue_send(packet);
    }

    ASSERT_EQ(channel.yield_send_queue(), in_packets);
    ASSERT_TRUE(channel.yield_send_queue().empty());
}

TEST(unreliable_sequenced_channel, in_queue_multi)
{
    const auto in_packets = create_packets({
        {0u, iris::PacketType::DATA},
        {1u, iris::PacketType::DATA},
        {2u, iris::PacketType::DATA},
    });
    iris::UnreliableSequencedChannel channel{};

    for (const auto &packet : in_packets)
    {
        channel.enqueue_send(packet);
    }

    ASSERT_EQ(channel.yield_send_queue(), in_packets);
    ASSERT_TRUE(channel.yield_send_queue().empty());
}

TEST(unreliable_sequenced_channel, in_queue_multi_incrementing_seq)
{
    const auto in_packets = create_packets({
        {0u, iris::PacketType::DATA},
        {0u, iris::PacketType::DATA},
        {0u, iris::PacketType::DATA},
    });
    const auto expected = create_packets({
        {0u, iris::PacketType::DATA},
        {1u, iris::PacketType::DATA},
        {2u, iris::PacketType::DATA},
    });
    iris::UnreliableSequencedChannel channel{};

    for (const auto &packet : in_packets)
    {
        channel.enqueue_send(packet);
    }

    ASSERT_EQ(channel.yield_send_queue(), expected);
    ASSERT_TRUE(channel.yield_send_queue().empty());
}

TEST(unreliable_sequenced_channel, in_queue_multi_early_yield)
{
    const auto in_packets = create_packets({
        {0u, iris::PacketType::DATA},
        {1u, iris::PacketType::DATA},
        {2u, iris::PacketType::DATA},
    });
    iris::UnreliableSequencedChannel channel{};
    std::vector<std::vector<iris::Packet>> yielded_packets{};

    channel.enqueue_send(in_packets[0u]);
    channel.enqueue_send(in_packets[1u]);
    yielded_packets.emplace_back(channel.yield_send_queue());
    yielded_packets.emplace_back(channel.yield_send_queue());
    channel.enqueue_send(in_packets[2u]);
    yielded_packets.emplace_back(channel.yield_send_queue());
    yielded_packets.emplace_back(channel.yield_send_queue());

    ASSERT_EQ(yielded_packets.size(), 4u);
    ASSERT_EQ(yielded_packets[0u].size(), 2u);
    ASSERT_EQ(
        yielded_packets[0u],
        std::vector<iris::Packet>(
            std::cbegin(in_packets), std::cbegin(in_packets) + 2u));
    ASSERT_TRUE(yielded_packets[1u].empty());
    ASSERT_EQ(yielded_packets[2u].size(), 1u);
    ASSERT_EQ(
        yielded_packets[2u],
        std::vector<iris::Packet>(
            std::cbegin(in_packets) + 2u, std::cend(in_packets)));
    ASSERT_TRUE(yielded_packets[3u].empty());
}

TEST(unreliable_sequenced_channel, out_queue_single)
{
    const auto out_packets = create_packets({
        {0u, iris::PacketType::DATA},
    });
    iris::UnreliableSequencedChannel channel{};

    for (const auto &packet : out_packets)
    {
        channel.enqueue_receive(packet);
    }

    ASSERT_EQ(channel.yield_receive_queue(), out_packets);
    ASSERT_TRUE(channel.yield_receive_queue().empty());
}

TEST(unreliable_sequenced_channel, out_queue_multi)
{
    const auto out_packets = create_packets({
        {0u, iris::PacketType::DATA},
        {1u, iris::PacketType::DATA},
        {2u, iris::PacketType::DATA},
    });
    iris::UnreliableSequencedChannel channel{};

    for (const auto &packet : out_packets)
    {
        channel.enqueue_receive(packet);
    }

    ASSERT_EQ(channel.yield_receive_queue(), out_packets);
    ASSERT_TRUE(channel.yield_receive_queue().empty());
}

TEST(unreliable_sequenced_channel, out_queue_duplicates)
{
    const auto out_packets = create_packets({
        {0u, iris::PacketType::DATA},
        {0u, iris::PacketType::DATA},
        {1u, iris::PacketType::DATA},
        {1u, iris::PacketType::DATA},
        {1u, iris::PacketType::DATA},
        {2u, iris::PacketType::DATA},
        {2u, iris::PacketType::DATA},
        {2u, iris::PacketType::DATA},
        {2u, iris::PacketType::DATA},
    });
    const auto expected = create_packets({
        {0u, iris::PacketType::DATA},
        {1u, iris::PacketType::DATA},
        {2u, iris::PacketType::DATA},
    });
    iris::UnreliableSequencedChannel channel{};

    for (const auto &packet : out_packets)
    {
        channel.enqueue_receive(packet);
    }

    ASSERT_EQ(channel.yield_receive_queue(), expected);
    ASSERT_TRUE(channel.yield_receive_queue().empty());
}

TEST(unreliable_sequenced_channel, out_queue_unordered)
{
    const auto out_packets = create_packets({
        {1u, iris::PacketType::DATA},
        {0u, iris::PacketType::DATA},
        {4u, iris::PacketType::DATA},
        {3u, iris::PacketType::DATA},
        {5u, iris::PacketType::DATA},
        {7u, iris::PacketType::DATA},
    });
    const auto expected = create_packets({
        {1u, iris::PacketType::DATA},
        {4u, iris::PacketType::DATA},
        {5u, iris::PacketType::DATA},
        {7u, iris::PacketType::DATA},
    });
    iris::UnreliableSequencedChannel channel{};

    for (const auto &packet : out_packets)
    {
        channel.enqueue_receive(packet);
    }

    ASSERT_EQ(channel.yield_receive_queue(), expected);
    ASSERT_TRUE(channel.yield_receive_queue().empty());
}

TEST(unreliable_sequenced_channel, out_queue_unordered_and_duplicates)
{
    const auto out_packets = create_packets({
        {1u, iris::PacketType::DATA},
        {0u, iris::PacketType::DATA},
        {0u, iris::PacketType::DATA},
        {0u, iris::PacketType::DATA},
        {4u, iris::PacketType::DATA},
        {0u, iris::PacketType::DATA},
        {1u, iris::PacketType::DATA},
        {3u, iris::PacketType::DATA},
        {0u, iris::PacketType::DATA},
        {5u, iris::PacketType::DATA},
        {4u, iris::PacketType::DATA},
        {5u, iris::PacketType::DATA},
        {5u, iris::PacketType::DATA},
        {7u, iris::PacketType::DATA},
        {5u, iris::PacketType::DATA},
    });
    const auto expected = create_packets({
        {1u, iris::PacketType::DATA},
        {4u, iris::PacketType::DATA},
        {5u, iris::PacketType::DATA},
        {7u, iris::PacketType::DATA},
    });
    iris::UnreliableSequencedChannel channel{};

    for (const auto &packet : out_packets)
    {
        channel.enqueue_receive(packet);
    }

    ASSERT_EQ(channel.yield_receive_queue(), expected);
    ASSERT_TRUE(channel.yield_receive_queue().empty());
}

TEST(
    unreliable_sequenced_channel,
    out_queue_unordered_and_duplicates_early_yield)
{
    const auto out_packets = create_packets({
        {1u, iris::PacketType::DATA},
        {0u, iris::PacketType::DATA},
        {0u, iris::PacketType::DATA},
        {0u, iris::PacketType::DATA},
        {4u, iris::PacketType::DATA},
        {0u, iris::PacketType::DATA},
        {1u, iris::PacketType::DATA},
        {3u, iris::PacketType::DATA},
        {0u, iris::PacketType::DATA},
        {5u, iris::PacketType::DATA},
        {4u, iris::PacketType::DATA},
        {5u, iris::PacketType::DATA},
        {5u, iris::PacketType::DATA},
        {7u, iris::PacketType::DATA},
        {5u, iris::PacketType::DATA},
    });
    const auto expected1 = create_packets({
        {1u, iris::PacketType::DATA},
        {4u, iris::PacketType::DATA},
    });
    const auto expected2 = create_packets({
        {5u, iris::PacketType::DATA},
        {7u, iris::PacketType::DATA},
    });
    iris::UnreliableSequencedChannel channel{};
    std::vector<std::vector<iris::Packet>> yielded_packets{};

    channel.enqueue_receive(out_packets[0u]);
    channel.enqueue_receive(out_packets[1u]);
    channel.enqueue_receive(out_packets[2u]);
    channel.enqueue_receive(out_packets[3u]);
    channel.enqueue_receive(out_packets[4u]);
    yielded_packets.emplace_back(channel.yield_receive_queue());
    yielded_packets.emplace_back(channel.yield_receive_queue());
    channel.enqueue_receive(out_packets[5u]);
    channel.enqueue_receive(out_packets[6u]);
    channel.enqueue_receive(out_packets[7u]);
    channel.enqueue_receive(out_packets[8u]);
    channel.enqueue_receive(out_packets[9u]);
    channel.enqueue_receive(out_packets[10u]);
    channel.enqueue_receive(out_packets[11u]);
    channel.enqueue_receive(out_packets[12u]);
    channel.enqueue_receive(out_packets[12u]);
    channel.enqueue_receive(out_packets[13u]);
    yielded_packets.emplace_back(channel.yield_receive_queue());
    yielded_packets.emplace_back(channel.yield_receive_queue());
    channel.enqueue_receive(out_packets[14u]);
    yielded_packets.emplace_back(channel.yield_receive_queue());

    ASSERT_EQ(yielded_packets.size(), 5u);
    ASSERT_EQ(yielded_packets[0u], expected1);
    ASSERT_TRUE(yielded_packets[1u].empty());
    ASSERT_EQ(yielded_packets[2u], expected2);
    ASSERT_TRUE(yielded_packets[3u].empty());
    ASSERT_TRUE(yielded_packets[4u].empty());
}

```

`tests/networking/unreliable_unordered_channel_tests.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include <algorithm>
#include <cstdint>
#include <gtest/gtest.h>
#include <iterator>
#include <tuple>
#include <vector>

#include "core/data_buffer.h"
#include "networking/channel/unreliable_unordered_channel.h"
#include "networking/packet.h"

#include "helper.h"

TEST(unreliable_unordered_channel, in_queue_single)
{
    const auto in_packets = create_packets({
        {0u, iris::PacketType::DATA},
    });
    iris::UnreliableUnorderedChannel channel{};

    for (const auto &packet : in_packets)
    {
        channel.enqueue_send(packet);
    }

    ASSERT_EQ(channel.yield_send_queue(), in_packets);
    ASSERT_TRUE(channel.yield_send_queue().empty());
}

TEST(unreliable_unordered_channel, in_queue_multi)
{
    const auto in_packets = create_packets({
        {0u, iris::PacketType::DATA},
        {1u, iris::PacketType::DATA},
        {2u, iris::PacketType::DATA},
    });
    iris::UnreliableUnorderedChannel channel{};

    for (const auto &packet : in_packets)
    {
        channel.enqueue_send(packet);
    }

    ASSERT_EQ(channel.yield_send_queue(), in_packets);
    ASSERT_TRUE(channel.yield_send_queue().empty());
}

TEST(unreliable_unordered_channel, in_queue_multi_early_yield)
{
    const auto in_packets = create_packets({
        {0u, iris::PacketType::DATA},
        {1u, iris::PacketType::DATA},
        {2u, iris::PacketType::DATA},
    });
    iris::UnreliableUnorderedChannel channel{};
    std::vector<std::vector<iris::Packet>> yielded_packets{};

    channel.enqueue_send(in_packets[0u]);
    channel.enqueue_send(in_packets[1u]);
    yielded_packets.emplace_back(channel.yield_send_queue());
    yielded_packets.emplace_back(channel.yield_send_queue());
    channel.enqueue_send(in_packets[2u]);
    yielded_packets.emplace_back(channel.yield_send_queue());
    yielded_packets.emplace_back(channel.yield_send_queue());

    ASSERT_EQ(yielded_packets.size(), 4u);
    ASSERT_EQ(yielded_packets[0u].size(), 2u);
    ASSERT_EQ(
        yielded_packets[0u],
        std::vector<iris::Packet>(
            std::cbegin(in_packets), std::cbegin(in_packets) + 2u));
    ASSERT_TRUE(yielded_packets[1u].empty());
    ASSERT_EQ(yielded_packets[2u].size(), 1u);
    ASSERT_EQ(
        yielded_packets[2u],
        std::vector<iris::Packet>(
            std::cbegin(in_packets) + 2u, std::cend(in_packets)));
    ASSERT_TRUE(yielded_packets[3u].empty());
}

TEST(unreliable_unordered_channel, out_queue_single)
{
    const auto out_packets = create_packets({
        {0u, iris::PacketType::DATA},
    });
    iris::UnreliableUnorderedChannel channel{};

    for (const auto &packet : out_packets)
    {
        channel.enqueue_receive(packet);
    }

    ASSERT_EQ(channel.yield_receive_queue(), out_packets);
    ASSERT_TRUE(channel.yield_receive_queue().empty());
}

TEST(unreliable_unordered_channel, out_queue_multi)
{
    const auto out_packets = create_packets({
        {0u, iris::PacketType::DATA},
        {1u, iris::PacketType::DATA},
        {2u, iris::PacketType::DATA},
    });
    iris::UnreliableUnorderedChannel channel{};

    for (const auto &packet : out_packets)
    {
        channel.enqueue_receive(packet);
    }

    ASSERT_EQ(channel.yield_receive_queue(), out_packets);
    ASSERT_TRUE(channel.yield_receive_queue().empty());
}

TEST(unreliable_unordered_channel, out_queue_multi_early_yield)
{
    const auto out_packets = create_packets({
        {0u, iris::PacketType::DATA},
        {1u, iris::PacketType::DATA},
        {2u, iris::PacketType::DATA},
    });
    iris::UnreliableUnorderedChannel channel{};
    std::vector<std::vector<iris::Packet>> yielded_packets{};

    channel.enqueue_receive(out_packets[0u]);
    channel.enqueue_receive(out_packets[1u]);
    yielded_packets.emplace_back(channel.yield_receive_queue());
    yielded_packets.emplace_back(channel.yield_receive_queue());
    channel.enqueue_receive(out_packets[2u]);
    yielded_packets.emplace_back(channel.yield_receive_queue());
    yielded_packets.emplace_back(channel.yield_receive_queue());

    ASSERT_EQ(yielded_packets.size(), 4u);
    ASSERT_EQ(yielded_packets[0u].size(), 2u);
    ASSERT_EQ(
        yielded_packets[0u],
        std::vector<iris::Packet>(
            std::cbegin(out_packets), std::cbegin(out_packets) + 2u));
    ASSERT_TRUE(yielded_packets[1u].empty());
    ASSERT_EQ(yielded_packets[2u].size(), 1u);
    ASSERT_EQ(
        yielded_packets[2u],
        std::vector<iris::Packet>(
            std::cbegin(out_packets) + 2u, std::cend(out_packets)));
    ASSERT_TRUE(yielded_packets[3u].empty());
}

```

`tests/platform/CMakeLists.txt`:

```txt
if(IRIS_PLATFORM MATCHES "MACOS")
  add_subdirectory("macos")
endif()

```

`tests/platform/macos/CMakeLists.txt`:

```txt
target_sources(unit_tests PRIVATE
    thread_tests.cpp)

```

`tests/platform/macos/thread_tests.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include "core/thread.h"

#include <atomic>
#include <thread>

#include <gtest/gtest.h>

#include "core/exception.h"

TEST(thread, default_constructor)
{
    iris::Thread thrd{};
    ASSERT_FALSE(thrd.joinable());
}

TEST(thread, function_constructor)
{
    std::atomic<bool> done = false;

    iris::Thread thrd{[](std::atomic<bool> *done) { *done = true; }, &done};

    ASSERT_TRUE(thrd.joinable());

    thrd.join();

    ASSERT_TRUE(done);
    ASSERT_FALSE(thrd.joinable());
}

TEST(thread, invalid_bind)
{
    iris::Thread thrd{};
    ASSERT_THROW(
        thrd.bind_to_core(std::thread::hardware_concurrency()),
        iris::Exception);
}

```

`tests/scripting/CMakeLists.txt`:

```txt
target_sources(unit_tests PRIVATE
    lua_script_tests.cpp
    script_runner_tests.cpp)

```

`tests/scripting/lua_script_tests.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include <memory>
#include <sstream>
#include <string>

#include <gtest/gtest.h>

#include "core/exception.h"
#include "scripting/lua/lua_script.h"
#include "scripting/script_runner.h"

TEST(lua_script, void_function)
{
    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(function go() print('hello') end)")};
    runner.execute("go");
}

TEST(lua_script, missing_function)
{
    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(function go() print('hello') end)")};
    EXPECT_THROW(runner.execute("go2"), iris::Exception);
}

TEST(lua_script, add_function)
{
    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(function add(a, b) return a + b end)")};
    EXPECT_EQ(runner.execute<int>("add", 3, 4), 7);
}

TEST(lua_script, string_reverse_function)
{
    iris::ScriptRunner runner{
        std::make_unique<iris::LuaScript>(R"(function reverse(str) return string.reverse(str) end)")};
    EXPECT_EQ(runner.execute<std::string>("reverse", "abcd"), "dcba");
}

TEST(lua_script, add_multiple_return)
{
    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(
            function add(x)
                return x + 1, x + 2
            end
        )")};
    EXPECT_EQ((runner.execute<std::int32_t, std::int32_t>("add", 5)), std::make_tuple(6, 7));
}

TEST(lua_script, add_multiple_functions)
{
    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(
            function func1(x)
                return x + 1
            end

            function func2(x)
                return x + 2
            end
        )")};
    EXPECT_EQ((runner.execute<std::int32_t>("func1", 5)), 6);
    EXPECT_EQ((runner.execute<std::int32_t>("func2", 5)), 7);
}

TEST(lua_script, shared_state)
{
    iris::Vector3 v1{1.0f, 2.0f, 3.0f};
    iris::Vector3 v2{1.0f, 2.0f, 3.0f};

    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(
            function func1(v1, v2)
                v = v1 + v2
            end

            function func2()
                return v
            end
        )")};

    runner.execute("func1", v1, v2);
    EXPECT_EQ((runner.execute<iris::Vector3>("func2")), v1 + v2);
}

TEST(lua_script, vector3_function)
{
    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(
            function vec3()
                local v = Vector3(1.0, 2.0, 3.0)
                return v:x(), v:y(), v:z()
            end)")};
    EXPECT_EQ((runner.execute<float, float, float>("vec3")), std::make_tuple(1.0f, 2.0f, 3.0f));
}

TEST(lua_script, pass_vector3)
{
    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(
            function split(vec3)
                return vec3:x(), vec3:y(), vec3:z()
            end)")};
    EXPECT_EQ(
        (runner.execute<float, float, float>("split", iris::Vector3(1.1f, 2.2f, 3.3f))),
        std::make_tuple(1.1f, 2.2f, 3.3f));
}

TEST(lua_script, get_vector3)
{
    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(
            function create_vector(x, y, z)
                local vec = Vector3(x, y, z)
                return vec
            end)")};
    EXPECT_EQ((runner.execute<iris::Vector3>("create_vector", 2.1f, 2.2f, 2.3f)), iris::Vector3(2.1f, 2.2f, 2.3f));
}

TEST(lua_script, vector3_setters)
{
    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(
            function set(vec3)
                vec3:set_x(-1.0);
                vec3:set_y(-2.0);
                vec3:set_z(-3.0);

                return vec3:x(), vec3:y(), vec3:z()
            end)")};
    EXPECT_EQ(
        (runner.execute<float, float, float>("set", iris::Vector3(1.1f, 2.2f, 3.3f))),
        std::make_tuple(-1.0f, -2.0f, -3.0f));
}

TEST(lua_script, vector3_to_string)
{
    const iris::Vector3 vec{2.1f, 2.2f, 2.3f};

    std::stringstream strm{};
    strm << vec;

    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(
            function vec_tostring(vec)
                return tostring(vec)
            end)")};
    EXPECT_EQ((runner.execute<std::string>("vec_tostring", vec)), strm.str());
}

TEST(lua_script, vector3_equality)
{
    const iris::Vector3 vec1{2.1f, 2.2f, 2.3f};
    const iris::Vector3 vec2{vec1};

    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(
            function vec_compare(vec1, vec2)
                return vec1 == vec2
            end)")};
    EXPECT_TRUE(runner.execute<bool>("vec_compare", vec1, vec2));
}

TEST(lua_script, vector3_negate)
{
    iris::Vector3 vec{2.1f, 2.2f, 2.3f};

    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(
            function vec_negate(vec)
                return -vec;
            end)")};
    EXPECT_EQ((runner.execute<iris::Vector3>("vec_negate", vec)), -vec);
}

TEST(lua_script, vector3_add)
{
    const iris::Vector3 vec1{2.1f, 2.2f, 2.3f};
    const iris::Vector3 vec2{3.1f, 3.2f, 3.3f};

    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(
            function vec_add(vec1, vec2)
                return vec1 + vec2;
            end)")};
    EXPECT_EQ((runner.execute<iris::Vector3>("vec_add", vec1, vec2)), vec1 + vec2);
}

TEST(lua_script, vector3_sub)
{
    const iris::Vector3 vec1{2.1f, 2.2f, 2.3f};
    const iris::Vector3 vec2{3.1f, 3.2f, 3.3f};

    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(
            function vec_sub(vec1, vec2)
                return vec1 - vec2;
            end)")};
    EXPECT_EQ((runner.execute<iris::Vector3>("vec_sub", vec1, vec2)), vec1 - vec2);
}

TEST(lua_script, vector3_mul)
{
    const iris::Vector3 vec1{2.1f, 2.2f, 2.3f};
    const iris::Vector3 vec2{3.1f, 3.2f, 3.3f};

    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(
            function vec_mul(vec1, vec2)
                return vec1 * vec2;
            end)")};
    EXPECT_EQ((runner.execute<iris::Vector3>("vec_mul", vec1, vec2)), vec1 * vec2);
}

TEST(lua_script, vector3_dot)
{
    iris::Vector3 vec1{1.0f, 3.0f, -5.0f};
    const iris::Vector3 vec2{4.0f, -2.0f, -1.0f};

    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(
            function vec_dot(vec1, vec2)
                return vec1:dot(vec2);
            end)")};
    EXPECT_EQ((runner.execute<float>("vec_dot", vec1, vec2)), vec1.dot(vec2));
}

TEST(lua_script, vector3_cross)
{
    const iris::Vector3 vec1{1.0f, 3.0f, -5.0f};
    const iris::Vector3 vec2{4.0f, -2.0f, -1.0f};

    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(
            function vec_cross(vec1, vec2)
                return vec1:cross(vec2);
            end)")};
    EXPECT_EQ((runner.execute<iris::Vector3>("vec_cross", vec1, vec2)), iris::Vector3::cross(vec1, vec2));
}

TEST(lua_script, vector3_normalise)
{
    const iris::Vector3 vec{1.0f, 3.0f, -5.0f};

    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(
            function vec_normalise(vec)
                vec:normalise()
                return vec
            end)")};
    EXPECT_EQ((runner.execute<iris::Vector3>("vec_normalise", vec)), iris::Vector3::normalise(vec));
}

TEST(lua_script, vector3_magnitude)
{
    const iris::Vector3 vec{1.0f, 3.0f, -5.0f};

    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(
            function vec_magnitude(vec)
                return vec:magnitude()
            end)")};
    EXPECT_EQ((runner.execute<float>("vec_magnitude", vec)), vec.magnitude());
}

TEST(lua_script, vector3_lerp)
{
    const iris::Vector3 vec1{1.0f, 3.0f, -5.0f};
    const iris::Vector3 vec2{4.0f, -2.0f, -1.0f};

    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(
            function vec_lerp(vec1, vec2, amount)
                vec1:lerp(vec2, amount)
                return vec1
            end)")};
    EXPECT_EQ((runner.execute<iris::Vector3>("vec_lerp", vec1, vec2, 0.5f)), iris::Vector3::lerp(vec1, vec2, 0.5f));
}

TEST(lua_script, quaternion_function)
{
    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(
            function quaternion()
                local q = Quaternion(1.0, 2.0, 3.0, 4.0)
                return q:x(), q:y(), q:z(), q:w()
            end)")};
    EXPECT_EQ((runner.execute<float, float, float, float>("quaternion")), std::make_tuple(1.0f, 2.0f, 3.0f, 4.0f));
}

TEST(lua_script, pass_quaternion)
{
    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(
            function split(q)
                return q:x(), q:y(), q:z(), q:w()
            end)")};
    EXPECT_EQ(
        (runner.execute<float, float, float, float>("split", iris::Quaternion(1.1f, 2.2f, 3.3f, 4.4f))),
        std::make_tuple(1.1f, 2.2f, 3.3f, 4.4f));
}

TEST(lua_script, get_quaternion_with_components)
{
    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(
            function create_quaternion(x, y, z, w)
                local q = Quaternion(x, y, z, w)
                return q
            end)")};
    EXPECT_EQ(
        (runner.execute<iris::Quaternion>("create_quaternion", 2.1f, 2.2f, 2.3f, 2.4f)),
        iris::Quaternion(2.1f, 2.2f, 2.3f, 2.4f));
}

TEST(lua_script, get_quaternion_with_vector)
{
    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(
            function create_quaternion(x, y, z, w)
                local q = Quaternion(Vector3(x, y, z), w)
                return q
            end)")};
    EXPECT_EQ(
        (runner.execute<iris::Quaternion>("create_quaternion", 2.1f, 2.2f, 2.3f, 2.4f)),
        iris::Quaternion(iris::Vector3(2.1f, 2.2f, 2.3f), 2.4f));
}

TEST(lua_script, quaternion_setters)
{
    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(
            function set(q)
                q:set_x(-1.0);
                q:set_y(-2.0);
                q:set_z(-3.0);
                q:set_w(-4.0);

                return q:x(), q:y(), q:z(), q:w()
            end)")};
    EXPECT_EQ(
        (runner.execute<float, float, float, float>("set", iris::Quaternion(1.1f, 2.2f, 3.3f, 4.4f))),
        std::make_tuple(-1.0f, -2.0f, -3.0f, -4.0f));
}

TEST(lua_script, quaternion_to_string)
{
    const iris::Quaternion q{1.0f, 2.0f, 3.0f, 4.0f};

    std::stringstream strm{};
    strm << q;

    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(
            function quaternion_tostring(q)
                return tostring(q)
            end)")};
    EXPECT_EQ((runner.execute<std::string>("quaternion_tostring", q)), strm.str());
}

TEST(lua_script, quaternion_equality)
{
    const iris::Quaternion q1{1.0f, 2.0f, 3.0f, 4.0f};
    const iris::Quaternion q2{q1};

    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(
            function quaternion_compare(q1, q2)
                return q1 == q2
            end)")};
    EXPECT_TRUE(runner.execute<bool>("quaternion_compare", q1, q2));
}

TEST(lua_script, quaternion_negate)
{
    const iris::Quaternion q{1.0f, 2.0f, 3.0f, 4.0f};

    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(
            function quaternion_negate(q)
                return -q
            end)")};
    EXPECT_EQ((runner.execute<iris::Quaternion>("quaternion_negate", q)), -q);
}

TEST(lua_script, quaternion_add)
{
    const iris::Quaternion q1{1.0f, 2.0f, 3.0f, 4.0f};
    const iris::Quaternion q2{1.2f, 2.4f, 3.6f, 4.6f};

    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(
            function quaternion_add(q1, q2)
                return q1 + q2
            end)")};
    EXPECT_EQ((runner.execute<iris::Quaternion>("quaternion_add", q1, q2)), q1 + q2);
}

TEST(lua_script, quaternion_sub)
{
    const iris::Quaternion q1{1.0f, 2.0f, 3.0f, 4.0f};
    const iris::Quaternion q2{1.2f, 2.4f, 3.6f, 4.6f};

    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(
            function quaternion_sub(q1, q2)
                return q1 - q2
            end)")};
    EXPECT_EQ((runner.execute<iris::Quaternion>("quaternion_sub", q1, q2)), q1 - q2);
}

TEST(lua_script, quaternion_mul)
{
    const iris::Quaternion q1{1.0f, 2.0f, 3.0f, 4.0f};
    const iris::Quaternion q2{1.2f, 2.4f, 3.6f, 4.6f};

    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(
            function quaternion_mul(q1, q2)
                return q1 * q2
            end)")};
    EXPECT_EQ((runner.execute<iris::Quaternion>("quaternion_mul", q1, q2)), q1 * q2);
}

TEST(lua_script, quaternion_dot)
{
    const iris::Quaternion q1{1.0f, 2.0f, 3.0f, 4.0f};
    const iris::Quaternion q2{1.2f, 2.4f, 3.6f, 4.6f};

    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(
            function quaternion_dot(q1, q2)
                return q1:dot(q2)
            end)")};
    EXPECT_EQ((runner.execute<float>("quaternion_dot", q1, q2)), q1.dot(q2));
}

TEST(lua_script, quaternion_slerp)
{
    const iris::Quaternion q1{1.0f, 2.0f, 3.0f, 4.0f};
    const iris::Quaternion q2{1.2f, 2.4f, 3.6f, 4.6f};
    const auto amount = 0.5f;
    auto expected = q1;
    expected.slerp(q2, amount);

    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(
            function quaternion_slerp(q1, q2, amount)
                return q1:slerp(q2, amount)
            end)")};
    EXPECT_EQ((runner.execute<iris::Quaternion>("quaternion_slerp", q1, q2, amount)), expected);
}

TEST(lua_script, quaternion_normalise)
{
    const iris::Quaternion q{1.0f, 2.0f, 3.0f, 4.0f};
    auto expected = q;
    expected.normalise();

    iris::ScriptRunner runner{std::make_unique<iris::LuaScript>(R"(
            function quaternion_normalise(q)
                return q:normalise()
            end)")};
    EXPECT_EQ((runner.execute<iris::Quaternion>("quaternion_normalise", q)), expected);
}

```

`tests/scripting/script_runner_tests.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
//         Distributed under the Boost Software License, Version 1.0.         //
//            (See accompanying file LICENSE or copy at                       //
//                 https://www.boost.org/LICENSE_1_0.txt)                     //
////////////////////////////////////////////////////////////////////////////////

#include <memory>

#include <gmock/gmock.h>

#include "core/quaternion.h"
#include "core/vector3.h"
#include "mocks/mock_script.h"
#include "scripting/script_runner.h"

TEST(script_runner, no_args_no_results)
{
    ::testing::InSequence s;

    auto script = std::make_unique<MockScript>();
    EXPECT_CALL(*script, set_function("func"));
    EXPECT_CALL(*script, execute(0u, 0u));

    iris::ScriptRunner runner(std::move(script));
    runner.execute("func");
}

TEST(script_runner, single_bool_argument)
{
    ::testing::InSequence s;

    auto script = std::make_unique<MockScript>();
    EXPECT_CALL(*script, set_function("func"));
    EXPECT_CALL(*script, set_argument(::testing::Matcher<bool>(false)));
    EXPECT_CALL(*script, execute(1u, 0u));

    iris::ScriptRunner runner(std::move(script));
    runner.execute("func", false);
}

TEST(script_runner, single_int_argument)
{
    ::testing::InSequence s;

    auto script = std::make_unique<MockScript>();
    EXPECT_CALL(*script, set_function("func"));
    EXPECT_CALL(*script, set_argument(::testing::Matcher<std::int32_t>(123)));
    EXPECT_CALL(*script, execute(1u, 0u));

    iris::ScriptRunner runner(std::move(script));
    runner.execute("func", 123);
}

TEST(script_runner, single_float_argument)
{
    ::testing::InSequence s;

    auto script = std::make_unique<MockScript>();
    EXPECT_CALL(*script, set_function("func"));
    EXPECT_CALL(*script, set_argument(::testing::Matcher<float>(3.34f)));
    EXPECT_CALL(*script, execute(1u, 0u));

    iris::ScriptRunner runner(std::move(script));
    runner.execute("func", 3.34f);
}

TEST(script_runner, single_c_string_argument)
{
    ::testing::InSequence s;

    auto script = std::make_unique<MockScript>();
    EXPECT_CALL(*script, set_function("func"));
    EXPECT_CALL(*script, set_argument(::testing::Matcher<const char *>(::testing::StrEq("c_string"))));
    EXPECT_CALL(*script, execute(1u, 0u));

    iris::ScriptRunner runner(std::move(script));
    runner.execute("func", "c_string");
}

TEST(script_runner, single_string_argument)
{
    ::testing::InSequence s;

    auto script = std::make_unique<MockScript>();
    EXPECT_CALL(*script, set_function("func"));
    EXPECT_CALL(*script, set_argument(::testing::Matcher<const std::string &>("string")));
    EXPECT_CALL(*script, execute(1u, 0u));

    iris::ScriptRunner runner(std::move(script));
    runner.execute("func", std::string("string"));
}

TEST(script_runner, single_vector3_argument)
{
    iris::Vector3 vec{1.1f, 2.2f, 3.3f};

    ::testing::InSequence s;

    auto script = std::make_unique<MockScript>();
    EXPECT_CALL(*script, set_function("func"));
    EXPECT_CALL(*script, set_argument(::testing::Matcher<const iris::Vector3 &>(vec)));
    EXPECT_CALL(*script, execute(1u, 0u));

    iris::ScriptRunner runner(std::move(script));
    runner.execute("func", vec);
}

TEST(script_runner, single_quaternion_argument)
{
    iris::Quaternion q{1.0f, 2.0f, 3.0f, 4.0f};

    ::testing::InSequence s;

    auto script = std::make_unique<MockScript>();
    EXPECT_CALL(*script, set_function("func"));
    EXPECT_CALL(*script, set_argument(::testing::Matcher<const iris::Quaternion &>(q)));
    EXPECT_CALL(*script, execute(1u, 0u));

    iris::ScriptRunner runner(std::move(script));
    runner.execute("func", q);
}

TEST(script_runner, single_bool_result)
{
    ::testing::InSequence s;

    auto script = std::make_unique<MockScript>();
    EXPECT_CALL(*script, set_function("func"));
    EXPECT_CALL(*script, execute(0u, 1u));
    EXPECT_CALL(*script, get_result(::testing::Matcher<bool &>(::testing::_)))
        .WillOnce(::testing::SetArgReferee<0>(true));

    iris::ScriptRunner runner(std::move(script));
    EXPECT_EQ(runner.execute<bool>("func"), true);
}

TEST(script_runner, single_int_result)
{
    ::testing::InSequence s;

    auto script = std::make_unique<MockScript>();
    EXPECT_CALL(*script, set_function("func"));
    EXPECT_CALL(*script, execute(0u, 1u));
    EXPECT_CALL(*script, get_result(::testing::Matcher<std::int32_t &>(::testing::_)))
        .WillOnce(::testing::SetArgReferee<0>(321));

    iris::ScriptRunner runner(std::move(script));
    EXPECT_EQ(runner.execute<std::int32_t>("func"), 321);
}

TEST(script_runner, single_float_result)
{
    ::testing::InSequence s;

    auto script = std::make_unique<MockScript>();
    EXPECT_CALL(*script, set_function("func"));
    EXPECT_CALL(*script, execute(0u, 1u));
    EXPECT_CALL(*script, get_result(::testing::Matcher<float &>(::testing::_)))
        .WillOnce(::testing::SetArgReferee<0>(4.567f));

    iris::ScriptRunner runner(std::move(script));
    EXPECT_EQ(runner.execute<float>("func"), 4.567f);
}

TEST(script_runner, single_string_result)
{
    ::testing::InSequence s;

    auto script = std::make_unique<MockScript>();
    EXPECT_CALL(*script, set_function("func"));
    EXPECT_CALL(*script, execute(0u, 1u));
    EXPECT_CALL(*script, get_result(::testing::Matcher<std::string &>(::testing::_)))
        .WillOnce(::testing::SetArgReferee<0>("abcd"));

    iris::ScriptRunner runner(std::move(script));
    EXPECT_EQ(runner.execute<std::string>("func"), "abcd");
}

TEST(script_runner, single_vector3_result)
{
    iris::Vector3 vec{1.1f, 2.2f, 3.3f};

    ::testing::InSequence s;

    auto script = std::make_unique<MockScript>();
    EXPECT_CALL(*script, set_function("func"));
    EXPECT_CALL(*script, execute(0u, 1u));
    EXPECT_CALL(*script, get_result(::testing::Matcher<iris::Vector3 &>(::testing::_)))
        .WillOnce(::testing::SetArgReferee<0>(vec));

    iris::ScriptRunner runner(std::move(script));
    EXPECT_EQ(runner.execute<iris::Vector3>("func"), vec);
}

TEST(script_runner, single_quaternion_result)
{
    iris::Quaternion q{1.0f, 2.0f, 3.0f, 4.0f};

    ::testing::InSequence s;

    auto script = std::make_unique<MockScript>();
    EXPECT_CALL(*script, set_function("func"));
    EXPECT_CALL(*script, execute(0u, 1u));
    EXPECT_CALL(*script, get_result(::testing::Matcher<iris::Quaternion &>(::testing::_)))
        .WillOnce(::testing::SetArgReferee<0>(q));

    iris::ScriptRunner runner(std::move(script));
    EXPECT_EQ(runner.execute<iris::Quaternion>("func"), q);
}

TEST(script_runner, multiple_arguments)
{
    iris::Vector3 vec{1.1f, 2.2f, 3.3f};
    iris::Quaternion q{1.0f, 2.0f, 3.0f, 4.0f};

    ::testing::InSequence s;

    auto script = std::make_unique<MockScript>();
    EXPECT_CALL(*script, set_function("func"));
    EXPECT_CALL(*script, set_argument(::testing::Matcher<bool>(true)));
    EXPECT_CALL(*script, set_argument(::testing::Matcher<int>(-10)));
    EXPECT_CALL(*script, set_argument(::testing::Matcher<float>(7.8f)));
    EXPECT_CALL(*script, set_argument(::testing::Matcher<const char *>(::testing::StrEq("str1"))));
    EXPECT_CALL(*script, set_argument(::testing::Matcher<const std::string &>("str2")));
    EXPECT_CALL(*script, set_argument(::testing::Matcher<const iris::Vector3 &>(vec)));
    EXPECT_CALL(*script, set_argument(::testing::Matcher<const iris::Quaternion &>(q)));
    EXPECT_CALL(*script, execute(7u, 0u));

    iris::ScriptRunner runner(std::move(script));
    runner.execute("func", true, -10, 7.8f, "str1", std::string("str2"), vec, q);
}

TEST(script_runner, multiple_results)
{
    iris::Vector3 vec{1.1f, 2.2f, 3.3f};
    iris::Quaternion q{1.0f, 2.0f, 3.0f, 4.0f};

    ::testing::InSequence s;

    auto script = std::make_unique<MockScript>();
    EXPECT_CALL(*script, set_function("func"));
    EXPECT_CALL(*script, execute(0u, 6u));
    EXPECT_CALL(*script, get_result(::testing::Matcher<iris::Quaternion &>(::testing::_)))
        .WillOnce(::testing::SetArgReferee<0>(q));
    EXPECT_CALL(*script, get_result(::testing::Matcher<iris::Vector3 &>(::testing::_)))
        .WillOnce(::testing::SetArgReferee<0>(vec));
    EXPECT_CALL(*script, get_result(::testing::Matcher<std::string &>(::testing::_)))
        .WillOnce(::testing::SetArgReferee<0>("efg"));
    EXPECT_CALL(*script, get_result(::testing::Matcher<float &>(::testing::_)))
        .WillOnce(::testing::SetArgReferee<0>(99.9f));
    EXPECT_CALL(*script, get_result(::testing::Matcher<std::int32_t &>(::testing::_)))
        .WillOnce(::testing::SetArgReferee<0>(-32));
    EXPECT_CALL(*script, get_result(::testing::Matcher<bool &>(::testing::_)))
        .WillOnce(::testing::SetArgReferee<0>(true));

    iris::ScriptRunner runner(std::move(script));
    EXPECT_EQ(
        (runner.execute<bool, std::int32_t, float, std::string, iris::Vector3, iris::Quaternion>("func")),
        (std::make_tuple(true, -32, 99.9f, std::string("efg"), vec, q)));
}

TEST(script_runner, multiple_arguments_and_multiple_results)
{
    iris::Vector3 vec{1.1f, 2.2f, 3.3f};
    iris::Quaternion q{1.0f, 2.0f, 3.0f, 4.0f};

    ::testing::InSequence s;

    auto script = std::make_unique<MockScript>();
    EXPECT_CALL(*script, set_function("func"));
    EXPECT_CALL(*script, set_argument(::testing::Matcher<bool>(true)));
    EXPECT_CALL(*script, set_argument(::testing::Matcher<int>(-10)));
    EXPECT_CALL(*script, set_argument(::testing::Matcher<float>(7.8f)));
    EXPECT_CALL(*script, set_argument(::testing::Matcher<const char *>(::testing::StrEq("str1"))));
    EXPECT_CALL(*script, set_argument(::testing::Matcher<const std::string &>("str2")));
    EXPECT_CALL(*script, set_argument(::testing::Matcher<const iris::Vector3 &>(vec)));
    EXPECT_CALL(*script, set_argument(::testing::Matcher<const iris::Quaternion &>(q)));
    EXPECT_CALL(*script, execute(7u, 6u));

    EXPECT_CALL(*script, get_result(::testing::Matcher<iris::Quaternion &>(::testing::_)))
        .WillOnce(::testing::SetArgReferee<0>(q));
    EXPECT_CALL(*script, get_result(::testing::Matcher<iris::Vector3 &>(::testing::_)))
        .WillOnce(::testing::SetArgReferee<0>(vec));
    EXPECT_CALL(*script, get_result(::testing::Matcher<std::string &>(::testing::_)))
        .WillOnce(::testing::SetArgReferee<0>("efg"));
    EXPECT_CALL(*script, get_result(::testing::Matcher<float &>(::testing::_)))
        .WillOnce(::testing::SetArgReferee<0>(99.9f));
    EXPECT_CALL(*script, get_result(::testing::Matcher<std::int32_t &>(::testing::_)))
        .WillOnce(::testing::SetArgReferee<0>(-32));
    EXPECT_CALL(*script, get_result(::testing::Matcher<bool &>(::testing::_)))
        .WillOnce(::testing::SetArgReferee<0>(true));

    iris::ScriptRunner runner(std::move(script));
    EXPECT_EQ(
        (runner.execute<bool, std::int32_t, float, std::string, iris::Vector3, iris::Quaternion>(
            "func", true, -10, 7.8f, "str1", std::string("str2"), vec, q)),
        (std::make_tuple(true, -32, 99.9f, std::string("efg"), vec, q)));
}

```