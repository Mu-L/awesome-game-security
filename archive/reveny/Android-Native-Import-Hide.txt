Project Path: arc_reveny_Android-Native-Import-Hide_h8gvhqcc

Source Tree:

```txt
arc_reveny_Android-Native-Import-Hide_h8gvhqcc
├── LICENSE
├── README.md
├── Test.cpp
├── images
│   ├── preview.png
│   └── preview2.png
├── single_header
│   └── HideImport.hpp
└── src
    ├── HideImport.cpp
    ├── HideImport.hpp
    └── syscall_shellcode.s

```

`LICENSE`:

```
MIT License

Copyright (c) 2025 Reveny

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# Android-Native-Import-Hide
A library for hiding and retrieving imports in ELF binaries.

[![Stars](https://img.shields.io/github/stars/reveny/Android-Native-Import-Hide?label=Stars)](https://github.com/reveny)
[![Channel](https://img.shields.io/badge/Telegram-Channel-blue.svg?logo=telegram)](https://t.me/reveny1)

## Features
- [x] Hide and retrieve symbols in ELF binaries
- [x] Support for multiple architectures (x86, x86_64, ARM, ARM64)
- [x] Cache resolved symbols for performance
- [x] Thread-safe symbol resolution
- [x] Detailed logging for debugging purposes
- [x] Check hooking before calling (ARM and ARM64 only)
- [ ] Prevent hooking completely 

## Build and Installation
Compatible Compilers
- GCC or Clang
- Make
- CMake

Clone the repository:
```sh
git clone https://github.com/reveny/Android-Native-Import-Hide.git
cd Android-Native-Import-Hide
```

To include the library in your project, add the following line to your source code:

```cpp
#include "HideImport.hpp"
```
## Usage
Here is a simple example demonstrating how to use the library and make sure to include HideImport.cpp in the source file list:

## Using `HI_GET`
```cpp
#include <stdio.h>
#include "HideImport.hpp"

int main() {
    HI_FUNCTION_POINTER(my_malloc, void*, size_t size) = HI_GET("libc.so", "malloc");

    void *testMemory = my_malloc(20);
    printf("my_malloc test returned: %p\n", testMemory);
    free(testMemory);

    return 0;
}
```

## Using `HI_CALL`
```cpp
#include <stdio.h>
#include "HideImport.hpp"

int main() {
    void *testMemory2 = HI_CALL("libc.so", malloc, void*, size_t)(15);
    printf("malloc test 2 returned: %p\n", testMemory2);
    free(testMemory2);

    return 0;
}
```

## Using `HI_SAFE`
```cpp
#include <stdio.h>
#include "HideImport.hpp"

int main() {
    void *testMemory2 = HI_CALL_SAFE("libc.so", malloc, void*, size_t)(15);
    printf("malloc test 2 returned: %p\n", testMemory2);
    free(testMemory2);

    return 0;
}
```
The SAFE version will check if the function is hooked before calling. If the function happens to be hooked, the call will not be executed and return NULL.

## Single Header Library
A single header version of the library is available for convenience. Simply include single_header/HideImport.hpp in your project.

## Preview
Disassembly without string encryption: <br>
![Preview](https://github.com/reveny/Android-Native-Import-Hide/blob/main/images/preview.png)

Disassembly with string encryption: <br>
![Preview](https://github.com/reveny/Android-Native-Import-Hide/blob/main/images/preview2.png)

## Credits
Special thanks to:
- [ARandomPerson](https://github.com/ARandomPerson7) for doing a lot of the work and the significant contribution and collaboration on this project.
- [Ac3ss0r](https://github.com/ac3ss0r) for some inspiration from [ShellcodeLab](https://github.com/ac3ss0r/ShellcodeLab)
- LSPlt for inspiration from their module listing implementation: [LSPlt](https://github.com/LSPosed/LSPlt)

## Contact
Feel free to reach out via:
- Telegram Group: [Join Group](https://t.me/reveny1)
- Telegram Contact: [Contact](https://t.me/revenyy)

## License
This project is licensed under the MIT License. See the [LICENSE](LICENSE) file for details.

```

`Test.cpp`:

```cpp
#include <stdio.h>

#define USE_SINGLE_HEADER 1

#if USE_SINGLE_HEADER
#include "single_header/HideImport.hpp"
#else
#include "src/HideImport.hpp"
#endif

int main() {
    printf("Hello World!\n");

    HI_FUNCTION_POINTER(my_malloc, void*, size_t size) = HI_GET_SAFE("libc.so", "malloc");

    void *testMemory = my_malloc(20);
    printf("my_malloc test returned: %p\n", testMemory);
    free(testMemory);

    void *testMemory2 = HI_CALL_SAFE("libc.so", malloc, void*, size_t)(15);
    printf("malloc test 2 returned: %p\n", testMemory2);
    free(testMemory2);

    return 0;
}
```

`single_header/HideImport.hpp`:

```hpp
//
// HideImport.hpp - A single header library for hiding and retrieving symbols in ELF binaries.
// Created by reveny and ARandomPerson on 6/6/24.
// Copyright (c) 2024. All rights reserved.
//
#pragma once

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>
#include <elf.h>
#include <stdint.h>
#include <dlfcn.h>
#include <vector>
#include <array>
#include <memory>
#include <cinttypes>
#include <dirent.h>
#include <ctype.h>
#include <string>
#include <cstdio>
#include <unordered_map>
#include <set>
#include <fstream>
#include <mutex>
#include <sstream>

#include <sys/mman.h>
#include <sys/types.h>
#include <sys/sysmacros.h>
#include <sys/syscall.h>
#include <sys/mman.h>
#include <sys/stat.h>

#define HI_INLINE __attribute__((always_inline))

#define HI_ENABLE_DEBUG 0
    #if HI_ENABLE_DEBUG
    #define HI_TAG "HideImport"
    #if defined(__ANDROID__)
        #include <android/log.h>
        #define HI_LOGE(...) ((void)__android_log_print(ANDROID_LOG_ERROR, HI_TAG, __VA_ARGS__))
        #define HI_LOGI(...) ((void)__android_log_print(ANDROID_LOG_INFO, HI_TAG, __VA_ARGS__))
    #else
        #include <stdio.h>
        #define HI_LOGE(fmt, ...) printf("ERROR: [%s] " fmt "\n", HI_TAG, ##__VA_ARGS__)
        #define HI_LOGI(fmt, ...) printf("INFO: [%s] " fmt "\n", HI_TAG, ##__VA_ARGS__)
    #endif
#else
#define HI_LOGE(fmt, ...)
#define HI_LOGI(fmt, ...)
#endif

// Template to simplify function pointer assignment
template <typename FuncSignature>
class SimpleFunctionPointer;

template <typename R, typename... Args>
class SimpleFunctionPointer<R(Args...)> {
public:
    using Type = R (*)(Args...);

    // Constructor from uintptr_t
    SimpleFunctionPointer(uintptr_t address) : ptr(reinterpret_cast<Type>(address)) {}

    // Overload the function call operator
    R operator()(Args... args) const {
        if (ptr) {
            return ptr(args...);
        } else {
            throw std::runtime_error("Function pointer is null");
        }
    }

    // Assignment operator for function pointer
    SimpleFunctionPointer& operator=(Type p) {
        ptr = p;
        return *this;
    }

    // Assignment operator for uintptr_t
    SimpleFunctionPointer& operator=(uintptr_t address) {
        ptr = reinterpret_cast<Type>(address);
        return *this;
    }
private:
    Type ptr;
};

#define HI_FUNCTION_POINTER(func_name, ret_type, ...) \
    SimpleFunctionPointer<ret_type(__VA_ARGS__)> func_name

#define HI_GET(library, symbol) \
    HideImport::GetSymbol(library, symbol)

#define HI_CALL(library, symbol, ret_type, ...) \
    reinterpret_cast<SimpleFunctionPointer<ret_type(__VA_ARGS__)>::Type>(HI_GET(library, #symbol))

#define HI_GET_SAFE(library, symbol) \
({ \
    auto func = HI_GET(library, symbol); \
    IS_FUNCTION_HOOKED(func) ? NULL : func; \
})

#define HI_CALL_SAFE(library, symbol, ret_type, ...) \
    reinterpret_cast<SimpleFunctionPointer<ret_type(__VA_ARGS__)>::Type>(HI_GET_SAFE(library, #symbol))

#if defined(__x86_64) || defined(__aarch64__)
    #define Elf_Ehdr Elf64_Ehdr
    #define Elf_Shdr Elf64_Shdr
    #define Elf_Sym Elf64_Sym
    #define _ELF_ST_BIND(x) ELF64_ST_BIND(x)
#else
    #define Elf_Ehdr Elf32_Ehdr
    #define Elf_Shdr Elf32_Shdr
    #define Elf_Sym Elf32_Sym
    #define _ELF_ST_BIND(x) ELF32_ST_BIND(x)
#endif

// arm and arm64 only for now.
// Detected on shadowhook, dobbyhook and and64inlinehook
// TODO: Arm has not been fully tested on all hooking frameworks.
#if defined(__aarch64__)
    #define IS_LDR_X17(instr) (((instr) & 0xFF000000) == 0x58000000)
    #define IS_BR_X17(instr) ((instr) == 0xd61f0220)
    #define IS_HOOKED_CONDITION (IS_LDR_X17(instr1) && IS_BR_X17(instr2))
#elif defined(__arm__)
    #define IS_LDR_PC(instr) (((instr) & 0x0F7FF000) == 0x051FF000)
    #define IS_BLX_R3(instr) ((instr) == 0xE12FFF33)
    #define IS_HOOKED_CONDITION (IS_LDR_PC(instr1) && IS_BLX_R3(instr2))
#else
    #define IS_HOOKED_CONDITION 0
#endif

#define IS_FUNCTION_HOOKED(function) ({ \
    uint32_t *addr = (uint32_t *)(function); \
    uint32_t instr1 = *addr; \
    uint32_t instr2 = *(addr + 1); \
    int result = 0; \
    if (IS_HOOKED_CONDITION) { \
        uintptr_t *hook_addr_ptr = (uintptr_t *)(addr + 2); \
        result = 1; \
    } \
    result; \
})

template <typename T>
constexpr long to_long(const T& arg) {
    if constexpr (std::is_pointer_v<T>) {
        return reinterpret_cast<long>(arg); // Cast pointers to long
    } else if constexpr (std::is_integral_v<T>) {
        return static_cast<long>(arg); // Convert integral types to long
    } else if constexpr (std::is_same_v<T, std::nullptr_t>) {
        return 0; // Convert nullptr to 0
    } else {
        static_assert(!std::is_same_v<T, T>, "Unsupported argument type for syscall");
    }
}

#define SYSCALL(...) inline_syscall(__VA_ARGS__)
template <typename... Args>
inline long inline_syscall(long syscall_number, Args... args) {
    long ret;

    long syscall_args[] = {to_long(args)...};
    constexpr size_t num_args = sizeof...(Args);

    #if defined(__x86_64__)
        __asm__ volatile (
            "mov %1, %%rax;"
            "mov %2, %%rdi;"
            "mov %3, %%rsi;"
            "mov %4, %%rdx;"
            "mov %5, %%r10;"
            "mov %6, %%r8;"
            "mov %7, %%r9;"
            "syscall;"
            "mov %%rax, %0;"
            : "=r" (ret)
            : "r" (syscall_number),
            "r" (num_args > 0 ? syscall_args[0] : 0),
            "r" (num_args > 1 ? syscall_args[1] : 0),
            "r" (num_args > 2 ? syscall_args[2] : 0),
            "r" (num_args > 3 ? syscall_args[3] : 0),
            "r" (num_args > 4 ? syscall_args[4] : 0),
            "r" (num_args > 5 ? syscall_args[5] : 0)
            : "%rax", "%rdi", "%rsi", "%rdx", "%r10", "%r8", "%r9"
        );
    #elif defined(__i386__)
        __asm__ volatile (
            "mov %1, %%eax;"
            "mov %2, %%ebx;"
            "mov %3, %%ecx;"
            "mov %4, %%edx;"
            "mov %5, %%esi;"
            "mov %6, %%edi;"
            "int $0x80;"
            "mov %%eax, %0;"
            : "=r" (ret)
            : "r" (syscall_number),
            "r" (num_args > 0 ? syscall_args[0] : 0),
            "r" (num_args > 1 ? syscall_args[1] : 0),
            "r" (num_args > 2 ? syscall_args[2] : 0),
            "r" (num_args > 3 ? syscall_args[3] : 0),
            "r" (num_args > 4 ? syscall_args[4] : 0)
            : "%eax", "%ebx", "%ecx", "%edx", "%esi", "%edi"
        );
    #elif defined(__arm__)
        __asm__ volatile (
            "mov r7, %1;"
            "mov r0, %2;"
            "mov r1, %3;"
            "mov r2, %4;"
            "mov r3, %5;"
            "mov r4, %6;"
            "mov r5, %7;"
            "swi 0;"
            "mov %0, r0;"
            : "=r" (ret)
            : "r" (syscall_number),
            "r" (num_args > 0 ? syscall_args[0] : 0),
            "r" (num_args > 1 ? syscall_args[1] : 0),
            "r" (num_args > 2 ? syscall_args[2] : 0),
            "r" (num_args > 3 ? syscall_args[3] : 0),
            "r" (num_args > 4 ? syscall_args[4] : 0),
            "r" (num_args > 5 ? syscall_args[5] : 0)
            : "r0", "r1", "r2", "r3", "r4", "r5", "r7"
        );
    #elif defined(__aarch64__)
        __asm__ volatile (
            "mov x8, %1;"
            "mov x0, %2;"
            "mov x1, %3;"
            "mov x2, %4;"
            "mov x3, %5;"
            "mov x4, %6;"
            "mov x5, %7;"
            "svc 0;"
            "mov %0, x0;"
            : "=r" (ret)
            : "r" (syscall_number),
            "r" (num_args > 0 ? syscall_args[0] : 0),
            "r" (num_args > 1 ? syscall_args[1] : 0),
            "r" (num_args > 2 ? syscall_args[2] : 0),
            "r" (num_args > 3 ? syscall_args[3] : 0),
            "r" (num_args > 4 ? syscall_args[4] : 0),
            "r" (num_args > 5 ? syscall_args[5] : 0)
            : "x0", "x1", "x2", "x3", "x4", "x5", "x8"
        );
    #else
        #error "Unsupported architecture"
    #endif

    return ret;
}

namespace HideImport {
    std::unordered_map<std::string, uintptr_t> symbolCache;
    std::mutex cacheMutex;  // Mutex for thread safe access

    enum class MachineType : uint16_t {
        ELF_EM_NONE = EM_NONE,       // No machine
        ELF_EM_386 = EM_386,         // Intel 80386
        ELF_EM_ARM = EM_ARM,         // ARM
        ELF_EM_X86_64 = EM_X86_64,   // x86_64
        ELF_EM_AARCH64 = EM_AARCH64  // ARM64
    };

    namespace Memory {
        constexpr static auto K_PERM_LENGTH = 5;
        constexpr static auto K_MAP_ENTRY = 7;
        struct MapInfo {
            std::string name;
            uintptr_t start;
            uintptr_t end;
            int perms;
            bool private_map;
            uintptr_t offset;
            dev_t dev;
            ino_t inode;
            std::string path;
        };

        // Inspired by LSPlt's implementation of module listing.
        // Reference: https://github.com/LSPosed/LSPlt/blob/a674793be6bc060b6d695c0cb481e8262c763885/lsplt/src/main/jni/lsplt.cc#L245
        /**
         * ListModulesNew - Lists memory mappings of the current process by reading /proc/self/maps.
         * Parses each line of the maps file and extracts memory region information.
         *
         * @return A vector of MapInfo structures containing details about each memory region.
         */
        std::vector<MapInfo> ListModulesNew() {
            std::vector<MapInfo> info;
            int fd = SYSCALL(__NR_openat, AT_FDCWD, "/proc/self/maps", O_RDONLY);
            if (fd == -1) {
                HI_LOGE("Failed to open /proc/self/maps with error: %s", strerror(errno));
                return info;
            }

            char buffer[4096];
            ssize_t bytesRead;
            std::string line;
            while ((bytesRead = SYSCALL(__NR_read, fd, buffer, sizeof(buffer) - 1)) > 0) {
                buffer[bytesRead] = '\0';
                line += buffer;

                size_t pos;
                while ((pos = line.find('\n')) != std::string::npos) {
                    std::string entry = line.substr(0, pos);
                    line.erase(0, pos + 1);

                    uintptr_t start = 0;
                    uintptr_t end = 0;
                    uintptr_t offset = 0;
                    ino_t inode = 0;
                    unsigned int devMajor = 0;
                    unsigned int devMinor = 0;
                    std::array<char, K_PERM_LENGTH> perm{'\0'};
                    int pathOff;

                    // Extract fields from the entry line
                    if (sscanf(entry.c_str(), "%" PRIxPTR "-%" PRIxPTR " %4s %" PRIxPTR " %x:%x %lu %n", &start, &end, perm.data(), &offset, &devMajor, &devMinor, &inode, &pathOff) != K_MAP_ENTRY) {
                        continue;
                    }

                    // Skip spaces to find the path offset
                    while (pathOff < entry.size() && isspace(entry[pathOff])) {
                        pathOff++;
                    }

                    auto &ref = info.emplace_back(MapInfo{
                        entry,
                        start,
                        end,
                        0,
                        perm[3] == 'p',
                        offset,
                        makedev(devMajor, devMinor),
                        inode,
                        entry.substr(pathOff)
                    });

                    if (perm[0] == 'r') ref.perms |= PROT_READ;
                    if (perm[1] == 'w') ref.perms |= PROT_WRITE;
                    if (perm[2] == 'x') ref.perms |= PROT_EXEC;
                }
            }

            if (bytesRead == -1) {
                HI_LOGE("Failed to read /proc/self/maps file: %s", strerror(errno));
                perror("read");
            }

            close(fd);
            return info;
        }

        /**
         * GetLibraryPath - Retrieves the full path of a loaded library by matching the provided substring.
         * 
         * @param path The substring to match against the library paths.
         * @return The full path of the matching library, or an empty string if not found.
         */
        std::string GetLibraryPath(const std::string &path) {
            std::vector<MapInfo> modules = ListModulesNew();
            for (const auto& module : modules) {
                if (module.path.find(path) != std::string::npos) {
                    return module.path;
                }
            }
            return "";
        }

        /**
         * FindLibraryBase - Finds the base address of a loaded library by matching the provided substring.
         *
         * @param path The substring to match against the library paths.
         * @return The base address of the matching library, or 0 if not found.
         */
        uintptr_t FindLibraryBase(const std::string &path) {
            auto modules = ListModulesNew();
            for (const auto& module : modules) {
                if (module.path.find(path) != std::string::npos) {
                    return module.start;
                }
            }
            return 0;
        }
    };

    /**
     * GetELFSymbolOffset - Retrieves the offset of a symbol within an ELF binary.
     *
     * @param entryAddr The base address of the ELF binary in memory.
     * @param entryElf The ELF header of the binary.
     * @param symbolName The name of the symbol to find.
     * @return The offset of the symbol within the ELF binary, or -1 if not found.
     */
    uintptr_t GetELFSymbolOffset(uintptr_t entryAddr, Elf_Ehdr *entryElf, const char* symbolName) {
        uintptr_t result = static_cast<uintptr_t>(-1);

        Elf_Shdr* sections = reinterpret_cast<Elf_Shdr*>(entryAddr + static_cast<uintptr_t>(entryElf->e_shoff));
        Elf_Shdr* symtab = nullptr;

        // Find the symbol table section
        for (int i = 0; i < entryElf->e_shnum; i++) {
            if (sections[i].sh_type == SHT_SYMTAB || sections[i].sh_type == SHT_DYNSYM) {
                symtab = sections + i;
                break;
            }
        }

        if (!symtab) {
            return result;
        }

        const char* strSecAddr = reinterpret_cast<const char*>(entryAddr + static_cast<uintptr_t>(sections[symtab->sh_link].sh_offset));
        Elf_Sym* symSec = reinterpret_cast<Elf_Sym*>(entryAddr + static_cast<uintptr_t>(symtab->sh_offset));
        int nSymbols = symtab->sh_size / sizeof(Elf_Sym);

        // Search for the symbol by name
        for (int i = 0; i < nSymbols; i++) {
            if (!(_ELF_ST_BIND(symSec[i].st_info) & (STT_FUNC | STB_GLOBAL))) {
                continue;
            }

            const char* currSymbolName = strSecAddr + symSec[i].st_name;
            if (strcmp(currSymbolName, symbolName) == 0) {
                result = symSec[i].st_value;
                break;
            }
        }

        HI_LOGI("Found offset (%p) of %s.", result, symbolName);
        return result;
    }

    /**
     * MapELFFile - Maps an ELF file into memory and retrieves the address of a specified symbol.
     *
     * @param baseAddr The base address of the ELF library in memory.
     * @param path The file path of the ELF library.
     * @param symbolName The name of the symbol to find.
     * @return The absolute address of the symbol, or -1 if not found.
     */
    uintptr_t MapELFFile(uintptr_t baseAddr, std::string path, std::string symbolName) {
        uintptr_t result = static_cast<uintptr_t>(-1);

        int fd = SYSCALL(__NR_openat, AT_FDCWD, path.c_str(), O_RDONLY);
        if (fd < 0) {
            return result;
        }

        struct stat elfStat;
        if (fstat(fd, &elfStat) < 0) {
            close(fd);
            return result;
        }

        void *entryRaw = (void *)SYSCALL(__NR_mmap, NULL, static_cast<size_t>(elfStat.st_size), PROT_READ, MAP_SHARED, fd, 0);
        if (entryRaw == MAP_FAILED) {
            close(fd);
            return result;
        }

        // Get the symbol offset and calculate the absolute address
        auto* elfEntry = static_cast<Elf_Ehdr*>(entryRaw);
        uintptr_t offset = GetELFSymbolOffset(reinterpret_cast<uintptr_t>(entryRaw), elfEntry, symbolName.c_str());
        
        if (offset != static_cast<uintptr_t>(-1)) {
            result = (uintptr_t)baseAddr + offset;
        } else {
            result = 0;
        }

        HI_LOGI("Found absolute address %p of symbol %s in %s", result, symbolName.c_str(), path.c_str());

        // Clean up
        SYSCALL(__NR_munmap, entryRaw, static_cast<size_t>(elfStat.st_size));
        close(fd);

        return result;
    }

    /**
     * GetSymbol - Retrieves the address of a symbol within a specified ELF library.
     *
     * @param elfName The name of the ELF library.
     * @param symbolName The name of the symbol to find.
     * @return The address of the symbol, or 0 if not found.
     */
    uintptr_t GetSymbol(std::string elfName, std::string symbolName) {
        std::string key = elfName + ":" + symbolName;
        {
            // Check the cache first
            std::lock_guard<std::mutex> lock(cacheMutex);
            if (symbolCache.find(key) != symbolCache.end()) {
                HI_LOGI("Cache hit for symbol %s in %s", symbolName.c_str(), elfName.c_str());
                return symbolCache[key];
            }
        }

        uintptr_t base = Memory::FindLibraryBase(elfName);
        if (base == 0) {
            return 0;
        }
        HI_LOGI("Found memory base: %p", base);

        std::string path = Memory::GetLibraryPath(elfName);
        uintptr_t result = MapELFFile(base, path, symbolName);

        // Cache the result
        {
            std::lock_guard<std::mutex> lock(cacheMutex);
            symbolCache[key] = result;
        }

        return result;
    }
}

```

`src/HideImport.cpp`:

```cpp
//
// HideImport.cpp - A library for hiding and retrieving symbols in ELF binaries.
// Created by reveny and ARandomPerson on 6/6/24.
// Copyright (c) 2024. All rights reserved.
//
#include "HideImport.hpp"

namespace HideImport {
    std::unordered_map<std::string, uintptr_t> symbolCache;
    std::mutex cacheMutex;
}

// Inspired by LSPlt's implementation of module listing.
// Reference: https://github.com/LSPosed/LSPlt/blob/a674793be6bc060b6d695c0cb481e8262c763885/lsplt/src/main/jni/lsplt.cc#L245
/**
 * ListModulesNew - Lists memory mappings of the current process by reading /proc/self/maps.
 * Parses each line of the maps file and extracts memory region information.
 *
 * @return A vector of MapInfo structures containing details about each memory region.
 */
std::vector<HideImport::Memory::MapInfo> HideImport::Memory::ListModulesNew() {
    std::vector<MapInfo> info;
    int fd = SYSCALL(__NR_openat, AT_FDCWD, "/proc/self/maps", O_RDONLY);
    if (fd == -1) {
        HI_LOGE("Failed to open /proc/self/maps with error: %s", strerror(errno));
        return info;
    }

    char buffer[4096];
    ssize_t bytesRead;
    std::string line;
    while ((bytesRead = SYSCALL(__NR_read, fd, buffer, sizeof(buffer) - 1)) > 0) {
        buffer[bytesRead] = '\0';
        line += buffer;

        size_t pos;
        while ((pos = line.find('\n')) != std::string::npos) {
            std::string entry = line.substr(0, pos);
            line.erase(0, pos + 1);

            uintptr_t start = 0;
            uintptr_t end = 0;
            uintptr_t offset = 0;
            ino_t inode = 0;
            unsigned int devMajor = 0;
            unsigned int devMinor = 0;
            std::array<char, K_PERM_LENGTH> perm{'\0'};
            int pathOff;

            // Extract fields from the entry line
            if (sscanf(entry.c_str(), "%" PRIxPTR "-%" PRIxPTR " %4s %" PRIxPTR " %x:%x %lu %n", &start, &end, perm.data(), &offset, &devMajor, &devMinor, &inode, &pathOff) != K_MAP_ENTRY) {
                continue;
            }

            // Skip spaces to find the path offset
            while (pathOff < entry.size() && isspace(entry[pathOff])) {
                pathOff++;
            }

            auto &ref = info.emplace_back(MapInfo{
                entry,
                start,
                end,
                0,
                perm[3] == 'p',
                offset,
                makedev(devMajor, devMinor),
                inode,
                entry.substr(pathOff)
            });

            if (perm[0] == 'r') ref.perms |= PROT_READ;
            if (perm[1] == 'w') ref.perms |= PROT_WRITE;
            if (perm[2] == 'x') ref.perms |= PROT_EXEC;
        }
    }

    if (bytesRead == -1) {
        HI_LOGE("Failed to read /proc/self/maps file: %s", strerror(errno));
        perror("read");
    }

    close(fd);
    return info;
}

/**
 * GetLibraryPath - Retrieves the full path of a loaded library by matching the provided substring.
 * 
 * @param path The substring to match against the library paths.
 * @return The full path of the matching library, or an empty string if not found.
 */
std::string HideImport::Memory::GetLibraryPath(const std::string &path) {
    std::vector<MapInfo> modules = ListModulesNew();
    for (const auto& module : modules) {
        if (module.path.find(path) != std::string::npos) {
            return module.path;
        }
    }
    return "";
}

/**
 * FindLibraryBase - Finds the base address of a loaded library by matching the provided substring.
 *
 * @param path The substring to match against the library paths.
 * @return The base address of the matching library, or 0 if not found.
 */
uintptr_t HideImport::Memory::FindLibraryBase(const std::string &path) {
    auto modules = ListModulesNew();
    for (const auto& module : modules) {
        if (module.path.find(path) != std::string::npos) {
            return module.start;
        }
    }
    return 0;
}

/**
 * GetELFSymbolOffset - Retrieves the offset of a symbol within an ELF binary.
 *
 * @param entryAddr The base address of the ELF binary in memory.
 * @param entryElf The ELF header of the binary.
 * @param symbolName The name of the symbol to find.
 * @return The offset of the symbol within the ELF binary, or -1 if not found.
 */
uintptr_t HideImport::GetELFSymbolOffset(uintptr_t entryAddr, Elf_Ehdr *entryElf, const char* symbolName) {
    uintptr_t result = static_cast<uintptr_t>(-1);
    Elf_Shdr* sections = reinterpret_cast<Elf_Shdr*>(entryAddr + static_cast<uintptr_t>(entryElf->e_shoff));
    Elf_Shdr* symtab = nullptr;

    // Find the symbol table section
    for (int i = 0; i < entryElf->e_shnum; i++) {
        if (sections[i].sh_type == SHT_SYMTAB || sections[i].sh_type == SHT_DYNSYM) {
            // symtab = &sections[i];
            symtab = sections + i;
            break;
        }
    }

    if (!symtab) {
        HI_LOGE("Failed to resolve symtab.");
        return result;
    }

    const char* strSecAddr = reinterpret_cast<const char*>(entryAddr + static_cast<uintptr_t>(sections[symtab->sh_link].sh_offset));
    Elf_Sym* symSec = reinterpret_cast<Elf_Sym*>(entryAddr + static_cast<uintptr_t>(symtab->sh_offset));
    int nSymbols = symtab->sh_size / sizeof(Elf_Sym);

    // Search for the symbol by name
    for (int i = 0; i < nSymbols; i++) {
        if (!(_ELF_ST_BIND(symSec[i].st_info) & (STT_FUNC | STB_GLOBAL))) {
            continue;
        }

        const char* currSymbolName = strSecAddr + symSec[i].st_name;
        if (strcmp(currSymbolName, symbolName) == 0) {
            result = symSec[i].st_value;
            break;
        }
    }

    HI_LOGI("Found offset (%p) of %s.", result, symbolName);
    return result;
}

/**
 * MapELFFile - Maps an ELF file into memory and retrieves the address of a specified symbol.
 *
 * @param baseAddr The base address of the ELF library in memory.
 * @param path The file path of the ELF library.
 * @param symbolName The name of the symbol to find.
 * @return The absolute address of the symbol, or -1 if not found.
 */
uintptr_t HideImport::MapELFFile(uintptr_t baseAddr, std::string path, std::string symbolName) {
    uintptr_t result = static_cast<uintptr_t>(-1);

    int fd = SYSCALL(__NR_openat, AT_FDCWD, path.c_str(), O_RDONLY);
    if (fd < 0) {
        return result;
    }

    struct stat elfStat;
    if (fstat(fd, &elfStat) < 0) {
        close(fd);
        return result;
    }

    void *entryRaw = (void *)SYSCALL(__NR_mmap, NULL, static_cast<size_t>(elfStat.st_size), PROT_READ, MAP_SHARED, fd, 0);
    if (entryRaw == MAP_FAILED) {
        close(fd);
        return result;
    }

    // Get the symbol offset and calculate the absolute address
    auto* elfEntry = static_cast<Elf_Ehdr*>(entryRaw);
    uintptr_t offset = GetELFSymbolOffset(reinterpret_cast<uintptr_t>(entryRaw), elfEntry, symbolName.c_str());
    
    if (offset != static_cast<uintptr_t>(-1)) {
        result = (uintptr_t)baseAddr + offset;
    } else {
        result = 0;
    }

    HI_LOGI("Found absolute address %p of symbol %s in %s", result, symbolName.c_str(), path.c_str());

    // Clean up
    SYSCALL(__NR_munmap, entryRaw, static_cast<size_t>(elfStat.st_size));
    close(fd);

    return result;
}

/**
 * GetSymbol - Retrieves the address of a symbol within a specified ELF library.
 *
 * @param elfName The name of the ELF library.
 * @param symbolName The name of the symbol to find.
 * @return The address of the symbol, or 0 if not found.
 */
HI_INLINE uintptr_t HideImport::GetSymbol(std::string elfName, std::string symbolName) {
    std::string key = elfName + ":" + symbolName;
    {
        // Check the cache first
        std::lock_guard<std::mutex> lock(cacheMutex);
        if (symbolCache.find(key) != symbolCache.end()) {
            HI_LOGI("Cache hit for symbol %s in %s", symbolName.c_str(), elfName.c_str());
            return symbolCache[key];
        }
    }

    uintptr_t base = Memory::FindLibraryBase(elfName);
    if (base == 0) {
        return 0;
    }
    HI_LOGI("Found memory base: %p", base);

    std::string path = Memory::GetLibraryPath(elfName);
    uintptr_t result = MapELFFile(base, path, symbolName);

    // Cache the result
    {
        std::lock_guard<std::mutex> lock(cacheMutex);
        symbolCache[key] = result;
    }

    return result;
}
```

`src/HideImport.hpp`:

```hpp
//
// HideImport.hpp - A library for hiding and retrieving symbols in ELF binaries.
// Created by reveny and ARandomPerson on 6/6/24.
// Copyright (c) 2024. All rights reserved.
//
#pragma once

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>
#include <elf.h>
#include <stdint.h>
#include <dlfcn.h>
#include <vector>
#include <array>
#include <memory>
#include <cinttypes>
#include <dirent.h>
#include <ctype.h>
#include <string>
#include <cstdio>
#include <unordered_map>
#include <set>
#include <fstream>
#include <mutex>
#include <sstream>

#include <sys/mman.h>
#include <sys/types.h>
#include <sys/sysmacros.h>
#include <sys/syscall.h>
#include <sys/mman.h>
#include <sys/stat.h>

#define HI_INLINE __attribute__((always_inline))

#define HI_ENABLE_DEBUG 1
#if HI_ENABLE_DEBUG
    #define HI_TAG "HideImport"
    #if defined(__ANDROID__)
        #include <android/log.h>
        #define HI_LOGE(...) ((void)__android_log_print(ANDROID_LOG_ERROR, HI_TAG, __VA_ARGS__))
        #define HI_LOGI(...) ((void)__android_log_print(ANDROID_LOG_INFO, HI_TAG, __VA_ARGS__))
    #else
        #include <stdio.h>
        #define HI_LOGE(fmt, ...) printf("ERROR: [%s] " fmt "\n", HI_TAG, ##__VA_ARGS__)
        #define HI_LOGI(fmt, ...) printf("INFO: [%s] " fmt "\n", HI_TAG, ##__VA_ARGS__)
    #endif
#else
#define HI_LOGE(fmt, ...)
#define HI_LOGI(fmt, ...)
#endif

// Template to simplify function pointer assignment
template <typename FuncSignature>
class SimpleFunctionPointer;

template <typename R, typename... Args>
class SimpleFunctionPointer<R(Args...)> {
public:
    using Type = R (*)(Args...);

    // Constructor from uintptr_t
    SimpleFunctionPointer(uintptr_t address) : ptr(reinterpret_cast<Type>(address)) {}

    // Overload the function call operator
    R operator()(Args... args) const {
        if (ptr) {
            return ptr(args...);
        } else {
            throw std::runtime_error("Function pointer is null");
        }
    }

    // Assignment operator for function pointer
    SimpleFunctionPointer& operator=(Type p) {
        ptr = p;
        return *this;
    }

    // Assignment operator for uintptr_t
    SimpleFunctionPointer& operator=(uintptr_t address) {
        ptr = reinterpret_cast<Type>(address);
        return *this;
    }
private:
    Type ptr;
};

#define HI_FUNCTION_POINTER(func_name, ret_type, ...) \
    SimpleFunctionPointer<ret_type(__VA_ARGS__)> func_name

#define HI_GET(library, symbol) \
    HideImport::GetSymbol(library, symbol)

#define HI_CALL(library, symbol, ret_type, ...) \
    reinterpret_cast<SimpleFunctionPointer<ret_type(__VA_ARGS__)>::Type>(HI_GET(library, #symbol))

#define HI_GET_SAFE(library, symbol) \
({ \
    auto func = HI_GET(library, symbol); \
    IS_FUNCTION_HOOKED(func) ? NULL : func; \
})

#define HI_CALL_SAFE(library, symbol, ret_type, ...) \
    reinterpret_cast<SimpleFunctionPointer<ret_type(__VA_ARGS__)>::Type>(HI_GET_SAFE(library, #symbol))

#if defined(__x86_64) || defined(__aarch64__)
    #define Elf_Ehdr Elf64_Ehdr
    #define Elf_Shdr Elf64_Shdr
    #define Elf_Sym Elf64_Sym
    #define _ELF_ST_BIND(x) ELF64_ST_BIND(x)
#else
    #define Elf_Ehdr Elf32_Ehdr
    #define Elf_Shdr Elf32_Shdr
    #define Elf_Sym Elf32_Sym
    #define _ELF_ST_BIND(x) ELF32_ST_BIND(x)
#endif

// arm and arm64 only for now.
#if defined(__aarch64__)
    #define IS_LDR_X17(instr) (((instr) & 0xFF000000) == 0x58000000)
    #define IS_BR_X17(instr) ((instr) == 0xd61f0220)
    #define IS_HOOKED_CONDITION (IS_LDR_X17(instr1) && IS_BR_X17(instr2))
#elif defined(__arm__)
    #define IS_LDR_PC(instr) (((instr) & 0x0F7FF000) == 0x051FF000)
    #define IS_BLX_R3(instr) ((instr) == 0xE12FFF33)
    #define IS_HOOKED_CONDITION (IS_LDR_PC(instr1) && IS_BLX_R3(instr2))
#else
    #define IS_HOOKED_CONDITION 0
#endif

#define IS_FUNCTION_HOOKED(function) ({ \
    uint32_t *addr = (uint32_t *)(function); \
    uint32_t instr1 = *addr; \
    uint32_t instr2 = *(addr + 1); \
    int result = 0; \
    if (IS_HOOKED_CONDITION) { \
        uintptr_t *hook_addr_ptr = (uintptr_t *)(addr + 2); \
        result = 1; \
    } \
    result; \
})


template <typename T>
constexpr long to_long(const T& arg) {
    if constexpr (std::is_pointer_v<T>) {
        return reinterpret_cast<long>(arg); // Cast pointers to long
    } else if constexpr (std::is_integral_v<T>) {
        return static_cast<long>(arg); // Convert integral types to long
    } else if constexpr (std::is_same_v<T, std::nullptr_t>) {
        return 0; // Convert nullptr to 0
    } else {
        static_assert(!std::is_same_v<T, T>, "Unsupported argument type for syscall");
    }
}

#define SYSCALL(...) inline_syscall(__VA_ARGS__)
template <typename... Args>
inline long inline_syscall(long syscall_number, Args... args) {
    long ret;

    long syscall_args[] = {to_long(args)...};
    constexpr size_t num_args = sizeof...(Args);

    #if defined(__x86_64__)
        __asm__ volatile (
            "mov %1, %%rax;"
            "mov %2, %%rdi;"
            "mov %3, %%rsi;"
            "mov %4, %%rdx;"
            "mov %5, %%r10;"
            "mov %6, %%r8;"
            "mov %7, %%r9;"
            "syscall;"
            "mov %%rax, %0;"
            : "=r" (ret)
            : "r" (syscall_number),
            "r" (num_args > 0 ? syscall_args[0] : 0),
            "r" (num_args > 1 ? syscall_args[1] : 0),
            "r" (num_args > 2 ? syscall_args[2] : 0),
            "r" (num_args > 3 ? syscall_args[3] : 0),
            "r" (num_args > 4 ? syscall_args[4] : 0),
            "r" (num_args > 5 ? syscall_args[5] : 0)
            : "%rax", "%rdi", "%rsi", "%rdx", "%r10", "%r8", "%r9"
        );
    #elif defined(__i386__)
        __asm__ volatile (
            "mov %1, %%eax;"
            "mov %2, %%ebx;"
            "mov %3, %%ecx;"
            "mov %4, %%edx;"
            "mov %5, %%esi;"
            "mov %6, %%edi;"
            "int $0x80;"
            "mov %%eax, %0;"
            : "=r" (ret)
            : "r" (syscall_number),
            "r" (num_args > 0 ? syscall_args[0] : 0),
            "r" (num_args > 1 ? syscall_args[1] : 0),
            "r" (num_args > 2 ? syscall_args[2] : 0),
            "r" (num_args > 3 ? syscall_args[3] : 0),
            "r" (num_args > 4 ? syscall_args[4] : 0)
            : "%eax", "%ebx", "%ecx", "%edx", "%esi", "%edi"
        );
    #elif defined(__arm__)
        __asm__ volatile (
            "mov r7, %1;"
            "mov r0, %2;"
            "mov r1, %3;"
            "mov r2, %4;"
            "mov r3, %5;"
            "mov r4, %6;"
            "mov r5, %7;"
            "swi 0;"
            "mov %0, r0;"
            : "=r" (ret)
            : "r" (syscall_number),
            "r" (num_args > 0 ? syscall_args[0] : 0),
            "r" (num_args > 1 ? syscall_args[1] : 0),
            "r" (num_args > 2 ? syscall_args[2] : 0),
            "r" (num_args > 3 ? syscall_args[3] : 0),
            "r" (num_args > 4 ? syscall_args[4] : 0),
            "r" (num_args > 5 ? syscall_args[5] : 0)
            : "r0", "r1", "r2", "r3", "r4", "r5", "r7"
        );
    #elif defined(__aarch64__)
        __asm__ volatile (
            "mov x8, %1;"
            "mov x0, %2;"
            "mov x1, %3;"
            "mov x2, %4;"
            "mov x3, %5;"
            "mov x4, %6;"
            "mov x5, %7;"
            "svc 0;"
            "mov %0, x0;"
            : "=r" (ret)
            : "r" (syscall_number),
            "r" (num_args > 0 ? syscall_args[0] : 0),
            "r" (num_args > 1 ? syscall_args[1] : 0),
            "r" (num_args > 2 ? syscall_args[2] : 0),
            "r" (num_args > 3 ? syscall_args[3] : 0),
            "r" (num_args > 4 ? syscall_args[4] : 0),
            "r" (num_args > 5 ? syscall_args[5] : 0)
            : "x0", "x1", "x2", "x3", "x4", "x5", "x8"
        );
    #else
        #error "Unsupported architecture"
    #endif

    return ret;
}

namespace HideImport {
    extern std::unordered_map<std::string, uintptr_t> symbolCache;
    extern std::mutex cacheMutex;  // Mutex for thread safe access

    enum class MachineType : uint16_t {
        ELF_EM_NONE = EM_NONE,       // No machine
        ELF_EM_386 = EM_386,         // Intel 80386
        ELF_EM_ARM = EM_ARM,         // ARM
        ELF_EM_X86_64 = EM_X86_64,   // x86_64
        ELF_EM_AARCH64 = EM_AARCH64  // ARM64
    };

    namespace Memory {
        constexpr static auto K_PERM_LENGTH = 5;
        constexpr static auto K_MAP_ENTRY = 7;
        struct MapInfo {
            std::string name;
            uintptr_t start;
            uintptr_t end;
            int perms;
            bool private_map;
            uintptr_t offset;
            dev_t dev;
            ino_t inode;
            std::string path;
        };

        std::vector<MapInfo> ListModulesNew();
        std::string GetLibraryPath(const std::string &path);
        uintptr_t FindLibraryBase(const std::string &path);
    };

    uintptr_t GetELFSymbolOffset(uintptr_t entryAddr, Elf_Ehdr *elfEntry, const char *symbolName);
    uintptr_t MapELFFile(uintptr_t baseAddr, std::string path, std::string symbolName);
    uintptr_t GetSymbol(std::string elfName, std::string symbolName);
};
```

`src/syscall_shellcode.s`:

```s
.text
.global perform_syscall
.type perform_syscall,@function

perform_syscall:
    MOV             X8, X0
    MOV             X0, X1
    MOV             X1, X2
    MOV             X2, X3
    MOV             X3, X4
    MOV             X4, X5
    MOV             X5, X6
    SVC             0
    RET
```