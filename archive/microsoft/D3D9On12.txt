Project Path: arc_microsoft_D3D9On12_v_z_4u2e

Source Tree:

```txt
arc_microsoft_D3D9On12_v_z_4u2e
├── CMakeLists.txt
├── CONTRIBUTING.md
├── DirectX-Direct3D9on12.man
├── LICENSE
├── README.md
├── SECURITY.md
├── ShaderConverter
│   ├── CMakeLists.txt
│   ├── Inc
│   │   ├── ShaderBinary.h
│   │   ├── ShaderConv.h
│   │   ├── ShaderConvCommon.h
│   │   └── ShaderConvInternal.h
│   ├── ShaderBinary
│   │   ├── ShaderBinary.cpp
│   │   └── pch.hpp
│   └── ShaderConv
│       ├── ShaderBinaryEx.cpp
│       ├── ShaderBinaryEx.hpp
│       ├── ShaderConv.cpp
│       ├── context.cpp
│       ├── context.hpp
│       ├── disasm.hpp
│       ├── disasm20.cpp
│       ├── gsconv.cpp
│       ├── pch.h
│       ├── psconv.cpp
│       ├── shaderconv.hpp
│       ├── tlvsconv.cpp
│       ├── translator.cpp
│       └── vsconv.cpp
├── external
│   └── ddithunk.h
├── include
│   ├── 9on12.h
│   ├── 9on12Adapter.h
│   ├── 9on12AppCompat.h
│   ├── 9on12Caps.h
│   ├── 9on12Constants.h
│   ├── 9on12DDI.h
│   ├── 9on12DataLogger.h
│   ├── 9on12DecodeDevice.h
│   ├── 9on12Device.h
│   ├── 9on12FastUploadAllocator.h
│   ├── 9on12Fence.h
│   ├── 9on12InputAssembly.h
│   ├── 9on12InputLayout.h
│   ├── 9on12PipelineState.h
│   ├── 9on12PipelineStateCache.h
│   ├── 9on12PipelineStateStructures.h
│   ├── 9on12PixelStage.h
│   ├── 9on12Query.h
│   ├── 9on12Registry.h
│   ├── 9on12Resource.h
│   ├── 9on12Shader.h
│   ├── 9on12SwapChain.h
│   ├── 9on12Util.h
│   ├── 9on12VertexStage.h
│   ├── 9on12VideoDevice.h
│   ├── 9on12VideoProcessDevice.h
│   ├── 9on12VideoTranslate.h
│   ├── 9on12Warning.h
│   ├── 9on12draw.inl
│   └── pch.h
├── interface
│   └── d3d9on12ddi.h
├── packages.config
└── src
    ├── 9on12.cpp
    ├── 9on12Adapter.cpp
    ├── 9on12AppCompat.cpp
    ├── 9on12Blit.cpp
    ├── 9on12Constants.cpp
    ├── 9on12DDIStub.cpp
    ├── 9on12DecodeDevice.cpp
    ├── 9on12Device.cpp
    ├── 9on12Draw.cpp
    ├── 9on12FastUploadAllocator.cpp
    ├── 9on12Fence.cpp
    ├── 9on12InputAssembly.cpp
    ├── 9on12InputLayout.cpp
    ├── 9on12PipelineState.cpp
    ├── 9on12PipelineStateCache.cpp
    ├── 9on12PixelStage.cpp
    ├── 9on12Query.cpp
    ├── 9on12Resource.cpp
    ├── 9on12Shader.cpp
    ├── 9on12SwapChain.cpp
    ├── 9on12VertexStage.cpp
    ├── 9on12VideoDevice.cpp
    ├── 9on12VideoProcessDevice.cpp
    ├── CMakeLists.txt
    ├── d3d9on12.def
    └── d3d9on12.rc

```

`CMakeLists.txt`:

```txt
# Copyright (c) Microsoft Corporation.
# Licensed under the MIT license.
cmake_minimum_required(VERSION 3.13)
project(d3d9on12)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

add_subdirectory(ShaderConverter)
add_subdirectory(src)
```

`CONTRIBUTING.md`:

```md
# Contributing

This project welcomes contributions and suggestions. Most contributions require you to
agree to a Contributor License Agreement (CLA) declaring that you have the right to,
and actually do, grant us the rights to use your contribution. For details, visit
https://cla.microsoft.com.

When you submit a pull request, a CLA-bot will automatically determine whether you need
to provide a CLA and decorate the PR appropriately (e.g., label, comment). Simply follow the
instructions provided by the bot. You will only need to do this once across all repositories using our CLA.

This project has adopted the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/).
For more information see the [Code of Conduct FAQ](https://opensource.microsoft.com/codeofconduct/faq/)
or contact [opencode@microsoft.com](mailto:opencode@microsoft.com) with any additional questions or comments.
```

`DirectX-Direct3D9on12.man`:

```man
<?xml version='1.0' encoding='utf-8' standalone='yes'?>
<assembly
    xmlns="urn:schemas-microsoft-com:asm.v3"
    xmlns:win="http://manifests.microsoft.com/win/2004/08/windows/events"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    manifestVersion="1.0"
    >
  <assemblyIdentity
      buildType="$(build.buildType)"
      language="neutral"
      name="Microsoft-Windows-DirectX-Direct3D9on12"
      processorArchitecture="$(build.arch)"
      publicKeyToken="$(Build.WindowsPublicKeyToken)"
      version="$(build.version)"
      versionScope="nonSxS"
      />
  <file
      destinationPath="$(runtime.system32)\"
      importPath="$(build.nttree)\"
      name="d3d9on12.dll"
      sourceName="d3d9on12.dll"
      sourcePath=".\"
      >
    <signatureInfo>
      <signatureDescriptor PETrust="true"/>
    </signatureInfo>
  </file>
  <localization>
    <resources culture="en-US">
      <stringTable>
        <string
            id="displayName0"
            value="Direct3D9on12"
            />
        <string
            id="description1"
            value="Direct3D D3D9 DDI to D3D12 API Mapper"
            />
        <string
            id="displayName2"
            value="WRP_FILE_DEFAULT_SDDL"
            />
        <string
            id="description3"
            value="Default SDDL for Windows Resource Protected file"
            />
      </stringTable>
    </resources>
  </localization>
</assembly>

```

`LICENSE`:

```
Copyright (c) Microsoft Corporation.

MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`README.md`:

```md
# D3D9On12

D3D9On12 is a mapping layer, which maps graphics commands from D3D9 to D3D12. D3D9On12 is **not** an implementation of the D3D9 **API**, but is instead an implementation of the D3D9 usermode **DDI** (device driver interface). That means it is not a binary named d3d9.dll, but is named d3d9on12.dll.

When an application creates a D3D9 device, they may choose for it to be a D3D9On12 device, rather than a native D3D9 device (see [Direct3DCreate9On12](https://github.com/microsoft/DirectX-Specs/blob/master/d3d/TranslationLayerResourceInterop.md#function-direct3dcreate9on12) and [Direct3DCreate9On12Ex](https://github.com/microsoft/DirectX-Specs/blob/master/d3d/TranslationLayerResourceInterop.md#function-direct3dcreate9on12ex)). When this happens, d3d9on12.dll is loaded by the D3D9 runtime and initialized. When the application calls rendering commands, D3D9 will validate those commands, and then will convert those commands to the D3D9 DDI and send it to D3D9On12, just like any D3D9 driver. D3D9On12 will take these commands and convert them into D3D12 API calls, which are further validated by the D3D12 runtime, optionally including the D3D12 debug layer, which are then converted to the D3D12 DDI and sent to the D3D12 driver.

Note that D3D9On12 is an *enlightened* D3D9 driver, and there are several places where it receives additional information compared to a traditional D3D9 driver, either to enable it to provide API-level information to D3D12 rather than driver-level information (as is the case for shaders), or to enable interop scenarios. When a D3D9 device is created with D3D9On12, the device will expose an `IDirect3DDevice9On12` interface which enables applications to submit work to both the D3D9 API and the D3D12 API with lightweight sharing and synchronization.

For more details about D3D9On12, see:
* [D3D Translation Layer spec](https://github.com/microsoft/DirectX-Specs/blob/master/d3d/TranslationLayerResourceInterop.md)
* [D3D9On12 blog posts](https://devblogs.microsoft.com/directx/coming-to-directx-12-d3d9on12-and-d3d11on12-resource-interop-apis/)

Make sure that you visit the [DirectX Landing Page](https://devblogs.microsoft.com/directx/landing-page/) for more resources for DirectX developers.

## How does it work?

The primary entrypoint to D3D9On12 is a custom version of the normal D3D9 driver [OpenAdapter](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/d3dumddi/nc-d3dumddi-pfnd3dddi_openadapter) entrypoint, named `OpenAdapter_Private`, where D3D9 provides additional information to the mapping layer. In response to this, like a normal driver, D3D9On12 returns an adapter object, which exposes DDIs to create a device. The device is created like normal, but in addition to the normal DDI tables, D3D9on12 also exposes a set of DDIs defined by the `D3D9ON12_PRIVATE_DDI_TABLE` which can be retrieved by calling `GetPrivateDDITable`.

The device object internally uses an instance of the D3D12TranslationLayer immediate context to record commands. Similarly, most D3D9On12 objects are backed by an implementation from the D3D12TranslationLayer library. The code in this repository is largely an adaptor from the D3D9 DDI to the D3D12TranslationLayer library, where the real heavy lifting of converting to the D3D12 domain is done.

## Building

In order to build D3D9On12, the [WDK](https://docs.microsoft.com/en-us/windows-hardware/drivers/download-the-wdk) (Windows Driver Kit) must be installed, in order to provide `d3d10umddi.h` to D3D9On12, and in order to generate the D3D12TranslationLayer_WDK project, which hosts some code required to parse DXBC shaders and containers. The D3D12TranslationLayer and its subprojects, D3D12TranslationLayer_WDK and DXBCParser, will be fetched from GitHub when building with CMake if D3D12TranslationLayer_WDK isn't already included, such as by a parent CMakeLists.txt that has already entered that project. The `DxbcSigner.dll` will be pulled in automatically from NuGet.

If you had a local copy of the D3D12TranslationLayer project, your top level project would look something like this:

```CMake
cmake_minimum_required(VERSION 3.14)
include(FetchContent)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

project(parent)

FetchContent_Declare(
    d3d12translationlayer
    SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/D3D12TranslationLayer
)
FetchContent_MakeAvailable(d3d12translationlayer)

add_subdirectory(D3D9On12)
```

At the time of publishing, the D3D9On12 and D3D12TranslationLayer require **insider** versions of the SDK and WDK. Those can be found [here](https://www.microsoft.com/en-us/software-download/windowsinsiderpreviewWDK).

D3D9On12 requires C++17, and only supports building with MSVC at the moment.

### Troubleshoot building
A somewhat common issue when trying to build the mapping layers is that there are multiple Windows SDKs installed, but only a subset of them has a corresponding WDK also installed. You can specify which version of the SDK to use when generating the solution by adding the following to your cmake command: `-DCMAKE_SYSTEM_VERSION=<SDK_VERSION>`.

### Usage
Note that in order to use your custom version of D3D9on12 you will also need to copy `WinPixEventRuntime.dll` (will automatically be placed in D3D9on12's build output) and `dxbcsigner.dll` along with it.

## Why open source?

The D3D9On12 mapping layer is included as an operating system component of Windows 10. Over the years and Windows 10 releases, it has grown in functionality, to the point where it is a complete and relatively performant implementation of a D3D9 driver. We are choosing to release the source to this component for two primary reasons:
1. To enable the community to contribute bugfixes and further performance improvements, which will improve the stability and performance of Windows 10. See [CONTRIBUTING](CONTRIBUTING.md).
2. To serve as an example of how to use the D3D12TranslationLayer library.

### What can you do with this?

There are minor differences between binaries built out of this repository and the versions that are included in the OS. To that end, shipping applications should not attempt to override the OS version of D3D9On12 with versions that they have built. We will not guarantee that newer versions of Windows will continue to support older versions of D3D9On12, since it is an OS component which may be revised together with D3D9. However, developers are welcome to override the Windows version of D3D9On12 for *local testing and experimentation*.

### Compatibility

When possible, we will attempt to maintain compatibility between D3D9 and D3D9On12. One should expect that the tip of D3D9On12's `master` branch should work nicely with the latest release of Windows 10. Support for configurations other than that are not guaranteed to work.

## Data Collection

The software may collect information about you and your use of the software and send it to Microsoft. Microsoft may use this information to provide services and improve our products and services. You may turn off the telemetry as described in the repository. There are also some features in the software that may enable you and Microsoft to collect data from users of your applications. If you use these features, you must comply with applicable law, including providing appropriate notices to users of your applications together with a copy of Microsoft's privacy statement. Our privacy statement is located at https://go.microsoft.com/fwlink/?LinkID=824704. You can learn more about data collection and use in the help documentation and our privacy statement. Your use of the software operates as your consent to these practices.

Note however that no data collection is performed when using your private builds.

```

`SECURITY.md`:

```md
<!-- BEGIN MICROSOFT SECURITY.MD V0.0.7 BLOCK -->

## Security

Microsoft takes the security of our software products and services seriously, which includes all source code repositories managed through our GitHub organizations, which include [Microsoft](https://github.com/Microsoft), [Azure](https://github.com/Azure), [DotNet](https://github.com/dotnet), [AspNet](https://github.com/aspnet), [Xamarin](https://github.com/xamarin), and [our GitHub organizations](https://opensource.microsoft.com/).

If you believe you have found a security vulnerability in any Microsoft-owned repository that meets [Microsoft's definition of a security vulnerability](https://aka.ms/opensource/security/definition), please report it to us as described below.

## Reporting Security Issues

**Please do not report security vulnerabilities through public GitHub issues.**

Instead, please report them to the Microsoft Security Response Center (MSRC) at [https://msrc.microsoft.com/create-report](https://aka.ms/opensource/security/create-report).

If you prefer to submit without logging in, send email to [secure@microsoft.com](mailto:secure@microsoft.com).  If possible, encrypt your message with our PGP key; please download it from the [Microsoft Security Response Center PGP Key page](https://aka.ms/opensource/security/pgpkey).

You should receive a response within 24 hours. If for some reason you do not, please follow up via email to ensure we received your original message. Additional information can be found at [microsoft.com/msrc](https://aka.ms/opensource/security/msrc). 

Please include the requested information listed below (as much as you can provide) to help us better understand the nature and scope of the possible issue:

  * Type of issue (e.g. buffer overflow, SQL injection, cross-site scripting, etc.)
  * Full paths of source file(s) related to the manifestation of the issue
  * The location of the affected source code (tag/branch/commit or direct URL)
  * Any special configuration required to reproduce the issue
  * Step-by-step instructions to reproduce the issue
  * Proof-of-concept or exploit code (if possible)
  * Impact of the issue, including how an attacker might exploit the issue

This information will help us triage your report more quickly.

If you are reporting for a bug bounty, more complete reports can contribute to a higher bounty award. Please visit our [Microsoft Bug Bounty Program](https://aka.ms/opensource/security/bounty) page for more details about our active programs.

## Preferred Languages

We prefer all communications to be in English.

## Policy

Microsoft follows the principle of [Coordinated Vulnerability Disclosure](https://aka.ms/opensource/security/cvd).

<!-- END MICROSOFT SECURITY.MD BLOCK -->

```

`ShaderConverter/CMakeLists.txt`:

```txt
# Copyright (c) Microsoft Corporation.
# Licensed under the MIT license.
cmake_minimum_required(VERSION 3.13)

file(GLOB SRC CONFIGURE_DEPENDS ShaderConv/*.cpp ShaderBinary/*.cpp)
file(GLOB INC Inc/*.h Inc/*.hpp ShaderConv/*.h ShaderConv/*.hpp)
file(GLOB_RECURSE EXTERNAL_INC ../external/*.h ../external/*.hpp)

add_library(d3d9on12_shaderconv STATIC ${SRC} ${INC} ${EXTERNAL_INC})
target_include_directories(d3d9on12_shaderconv
    PUBLIC Inc
    PUBLIC ../external
    PRIVATE ShaderConv)
source_group("Header Files\\External" FILES ${EXTERNAL_INC})

target_link_libraries(d3d9on12_shaderconv d3d12translationlayer)

if(MSVC)
    #This is the same set of options provided to d3d12translationlayer + /wd4201
    #/wd4201 disables the warning for "nonstandard extension used : nameless struct/union"
    target_compile_options(d3d9on12_shaderconv PRIVATE /W4 /WX /wd4238 /wd4324 /wd4201)
endif()
```

`ShaderConverter/Inc/ShaderBinary.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  Content: shader binary format parsing and encoding.
 *
 ***************************************************************************/
#pragma once

typedef UINT CShaderToken;

const UINT MAX_INSTRUCTION_LENGTH = 128;
const UINT D3D11_SB_MAX_INSTRUCTION_OPERANDS = 8;
const UINT D3D11_SB_MAX_FP_ENTRIES = 253;


typedef enum D3D11_SB_OPCODE_CLASS
{
    D3D11_SB_FLOAT_OP,
    D3D11_SB_INT_OP,
    D3D11_SB_UINT_OP,
    D3D11_SB_BIT_OP,
    D3D11_SB_FLOW_OP,
    D3D11_SB_TEX_OP,
    D3D11_SB_DCL_OP,
} D3D11_SB_OPCODE_CLASS;

struct CInstructionInfo
{
    void Set (BYTE NumDstOperands, BYTE NumSrcOperands, LPCSTR Name, D3D11_SB_OPCODE_CLASS OpClass)
    {
        m_NumSrcOperands = NumSrcOperands;
        m_NumDstOperands = NumDstOperands;
        m_Name = Name;
        m_OpClass = OpClass;
    }
    LPCSTR          m_Name;
    BYTE            m_NumSrcOperands;
    BYTE            m_NumDstOperands;
    D3D11_SB_OPCODE_CLASS m_OpClass;
};

extern CInstructionInfo g_InstructionInfo[D3D10_SB_NUM_OPCODES];

UINT GetNumInstructionOperands(D3D10_SB_OPCODE_TYPE OpCode);
UINT GetNumInstructionSrcOperands(D3D10_SB_OPCODE_TYPE OpCode);
UINT GetNumInstructionDstOperands(D3D10_SB_OPCODE_TYPE OpCode);
D3D11_SB_OPCODE_CLASS GetOpcodeClass(D3D10_SB_OPCODE_TYPE OpCode);
LPCSTR GetOpcodeString(D3D10_SB_OPCODE_TYPE OpCode);

//*****************************************************************************
//
// class COperandIndex
//
// Represents a dimension index of an operand
//
//*****************************************************************************

class COperandIndex
{
public:
    COperandIndex() {}
    // Value for the immediate index type
    union
    {
        UINT        m_RegIndex;
        UINT        m_RegIndexA[2];
        INT64       m_RegIndex64;
    };
    // Data for the relative index type
    D3D10_SB_OPERAND_TYPE    m_RelRegType;
    D3D10_SB_4_COMPONENT_NAME m_ComponentName;
    D3D10_SB_OPERAND_INDEX_DIMENSION         m_IndexDimension;
    // First index of the relative register
    union
    {
        UINT        m_RelIndex;
        UINT        m_RelIndexA[2];
        INT64       m_RelIndex64;
    };
    // Second index of the relative register
    union
    {
        UINT        m_RelIndex1;
        UINT        m_RelIndexA1[2];
        INT64       m_RelIndex641;
    };
};

//*****************************************************************************
//
// class COperandBase
//
// A base class for shader instruction operands
//
//*****************************************************************************

class COperandBase
{
public:
    COperandBase() {Clear();}
    COperandBase(const COperandBase & Op) { memcpy(this, &Op, sizeof(*this)); }
    bool operator!=(const COperandBase & Op) const { return memcmp(this, &Op, sizeof(*this)) != 0; }
    D3D10_SB_OPERAND_TYPE OperandType() const {return m_Type;}
    const COperandIndex* OperandIndex(UINT Index) const {return &m_Index[Index];}
    D3D10_SB_OPERAND_INDEX_REPRESENTATION OperandIndexType(UINT Index) const {return m_IndexType[Index];}
    D3D10_SB_OPERAND_INDEX_DIMENSION OperandIndexDimension() const {return m_IndexDimension;}
    D3D10_SB_OPERAND_NUM_COMPONENTS NumComponents() const {return m_NumComponents;}
    // Get the register index for a given dimension
    UINT RegIndex(UINT Dimension = 0) const {return m_Index[Dimension].m_RegIndex;}
    // Get the register index from the lowest dimension
    UINT RegIndexForMinorDimension() const
    {
        switch (m_IndexDimension)
        {
            default:
            case D3D10_SB_OPERAND_INDEX_1D:
                return RegIndex(0);
            case D3D10_SB_OPERAND_INDEX_2D:
                return RegIndex(1);
            case D3D10_SB_OPERAND_INDEX_3D:
                return RegIndex(2);
        }
    }
    // Get the write mask
    UINT WriteMask() const {return m_WriteMask;}
    // Get the swizzle
    UINT SwizzleComponent(UINT index) const {return m_Swizzle[index];}
    // Get immediate 32 bit value
    UINT Imm32() const {return m_Value[0];}
    void SetModifier(D3D10_SB_OPERAND_MODIFIER Modifier)
    {
        m_Modifier = Modifier;
        if (Modifier != D3D10_SB_OPERAND_MODIFIER_NONE)
        {
            m_bExtendedOperand = true;
            m_ExtendedOperandType = D3D10_SB_EXTENDED_OPERAND_MODIFIER;
        }
    }
    D3D10_SB_OPERAND_MODIFIER Modifier() const {return m_Modifier;}

    //__success(return != FALSE) BOOL Disassemble(__out_ecount(StringSize) LPSTR pString, __in_range(>,0) UINT StringSize) const;

public:  //esp in the unions...it's just redundant to not directly access things
    void Clear()
    {
        memset(this, 0, sizeof(*this));
    }
    D3D10_SB_OPERAND_TYPE                        m_Type;
    COperandIndex                             m_Index[3];
    D3D10_SB_OPERAND_NUM_COMPONENTS              m_NumComponents;
    D3D10_SB_OPERAND_4_COMPONENT_SELECTION_MODE  m_ComponentSelection;
    BOOL                                      m_bExtendedOperand;
    D3D10_SB_OPERAND_MODIFIER                    m_Modifier;
    D3D10_SB_EXTENDED_OPERAND_TYPE               m_ExtendedOperandType;
    D3D11_SB_OPERAND_MIN_PRECISION               m_MinPrecision;

    union
    {
        UINT                   m_WriteMask;
        BYTE                    m_Swizzle[4];
    };
    D3D10_SB_4_COMPONENT_NAME    m_ComponentName;
    union
    {
        UINT                               m_Value[4];
        float                               m_Valuef[4];
        UINT                               m_ValueA[4][2];
        INT64                               m_Value64[4];
    };
    struct
    {
        D3D10_SB_OPERAND_INDEX_REPRESENTATION    m_IndexType[3];
        D3D10_SB_OPERAND_INDEX_DIMENSION         m_IndexDimension;
    };

    friend class CShaderAsm;
    friend class CShaderCodeParser;
    friend class CInstruction;
    friend class COperand;
    friend class COperandDst;
};

//*****************************************************************************
//
// class COperand
//
// Encapsulates a source operand in shader instructions
//
//*****************************************************************************

class COperand: public COperandBase
{
public:
    COperand(): COperandBase() {}
    COperand(UINT Imm32): COperandBase()
    {
        m_Modifier = D3D10_SB_OPERAND_MODIFIER_NONE;
        m_WriteMask = 0;
        m_Type = D3D10_SB_OPERAND_TYPE_IMMEDIATE32;
        m_bExtendedOperand = FALSE;
        m_IndexDimension = D3D10_SB_OPERAND_INDEX_0D;
        m_Value[0] = Imm32;
        m_NumComponents = D3D10_SB_OPERAND_1_COMPONENT;
    }
    COperand(int Imm32): COperandBase()
    {
        m_Modifier = D3D10_SB_OPERAND_MODIFIER_NONE;
        m_WriteMask = 0;
        m_Type = D3D10_SB_OPERAND_TYPE_IMMEDIATE32;
        m_bExtendedOperand = FALSE;
        m_IndexDimension = D3D10_SB_OPERAND_INDEX_0D;
        m_Value[0] = Imm32;
        m_NumComponents = D3D10_SB_OPERAND_1_COMPONENT;
    }
    COperand(float Imm32): COperandBase()
    {
        m_Modifier = D3D10_SB_OPERAND_MODIFIER_NONE;
        m_WriteMask = 0;
        m_Type = D3D10_SB_OPERAND_TYPE_IMMEDIATE32;
        m_bExtendedOperand = FALSE;
        m_IndexDimension = D3D10_SB_OPERAND_INDEX_0D;
        m_Valuef[0] = Imm32;
        m_NumComponents = D3D10_SB_OPERAND_1_COMPONENT;
    }
    COperand(D3D10_SB_OPERAND_TYPE Type, UINT RegIndex): COperandBase()
    {
        m_Modifier = D3D10_SB_OPERAND_MODIFIER_NONE;
        m_Type = Type;
        m_bExtendedOperand = FALSE;
        m_NumComponents = D3D10_SB_OPERAND_0_COMPONENT;
        m_IndexDimension = D3D10_SB_OPERAND_INDEX_1D;
        m_IndexType[0] = D3D10_SB_OPERAND_INDEX_IMMEDIATE32;
        m_Index[0].m_RegIndex = RegIndex;
    }
    // Immediate constant
    COperand(float v1, float v2, float v3, float v4): COperandBase()
    {
        m_Modifier = D3D10_SB_OPERAND_MODIFIER_NONE;
        m_ComponentSelection = D3D10_SB_OPERAND_4_COMPONENT_SWIZZLE_MODE;
        m_Swizzle[0] = D3D10_SB_4_COMPONENT_X;
        m_Swizzle[1] = D3D10_SB_4_COMPONENT_Y;
        m_Swizzle[2] = D3D10_SB_4_COMPONENT_Z;
        m_Swizzle[3] = D3D10_SB_4_COMPONENT_W;
        m_Type = D3D10_SB_OPERAND_TYPE_IMMEDIATE32;
        m_bExtendedOperand = FALSE;
        m_NumComponents = D3D10_SB_OPERAND_4_COMPONENT;
        m_IndexDimension = D3D10_SB_OPERAND_INDEX_0D;
        m_Valuef[0] = v1;
        m_Valuef[1] = v2;
        m_Valuef[2] = v3;
        m_Valuef[3] = v4;
    }
    // Immediate constant
    COperand(float v1, float v2, float v3, float v4,
             BYTE SwizzleX, BYTE SwizzleY, BYTE SwizzleZ, BYTE SwizzleW): COperandBase()
    {
        m_Modifier = D3D10_SB_OPERAND_MODIFIER_NONE;
        m_ComponentSelection = D3D10_SB_OPERAND_4_COMPONENT_SWIZZLE_MODE;
        m_Swizzle[0] = SwizzleX;
        m_Swizzle[1] = SwizzleY;
        m_Swizzle[2] = SwizzleZ;
        m_Swizzle[3] = SwizzleW;
        m_Type = D3D10_SB_OPERAND_TYPE_IMMEDIATE32;
        m_bExtendedOperand = FALSE;
        m_NumComponents = D3D10_SB_OPERAND_4_COMPONENT;
        m_IndexDimension = D3D10_SB_OPERAND_INDEX_0D;
        m_Valuef[0] = v1;
        m_Valuef[1] = v2;
        m_Valuef[2] = v3;
        m_Valuef[3] = v4;
    }

    // Immediate constant
    COperand(int v1, int v2, int v3, int v4): COperandBase()
    {
        m_Modifier = D3D10_SB_OPERAND_MODIFIER_NONE;
        m_ComponentSelection = D3D10_SB_OPERAND_4_COMPONENT_SWIZZLE_MODE;
        m_Swizzle[0] = D3D10_SB_4_COMPONENT_X;
        m_Swizzle[1] = D3D10_SB_4_COMPONENT_Y;
        m_Swizzle[2] = D3D10_SB_4_COMPONENT_Z;
        m_Swizzle[3] = D3D10_SB_4_COMPONENT_W;
        m_Type = D3D10_SB_OPERAND_TYPE_IMMEDIATE32;
        m_bExtendedOperand = FALSE;
        m_NumComponents = D3D10_SB_OPERAND_4_COMPONENT;
        m_IndexDimension = D3D10_SB_OPERAND_INDEX_0D;
        m_Value[0] = v1;
        m_Value[1] = v2;
        m_Value[2] = v3;
        m_Value[3] = v4;
    }
    // Immediate constant
    COperand(int v1, int v2, int v3, int v4,
             BYTE SwizzleX, BYTE SwizzleY, BYTE SwizzleZ, BYTE SwizzleW): COperandBase()
    {
        m_Modifier = D3D10_SB_OPERAND_MODIFIER_NONE;
        m_ComponentSelection = D3D10_SB_OPERAND_4_COMPONENT_SWIZZLE_MODE;
        m_Swizzle[0] = SwizzleX;
        m_Swizzle[1] = SwizzleY;
        m_Swizzle[2] = SwizzleZ;
        m_Swizzle[3] = SwizzleW;
        m_Type = D3D10_SB_OPERAND_TYPE_IMMEDIATE32;
        m_bExtendedOperand = FALSE;
        m_NumComponents = D3D10_SB_OPERAND_4_COMPONENT;
        m_IndexDimension = D3D10_SB_OPERAND_INDEX_0D;
        m_Value[0] = v1;
        m_Value[1] = v2;
        m_Value[2] = v3;
        m_Value[3] = v4;
    }

    COperand(D3D10_SB_OPERAND_TYPE Type, UINT RegIndex,
             BYTE SwizzleX, BYTE SwizzleY, BYTE SwizzleZ, BYTE SwizzleW): COperandBase()
    {
        m_Modifier = D3D10_SB_OPERAND_MODIFIER_NONE;
        m_ComponentSelection = D3D10_SB_OPERAND_4_COMPONENT_SWIZZLE_MODE;
        m_Swizzle[0] = SwizzleX;
        m_Swizzle[1] = SwizzleY;
        m_Swizzle[2] = SwizzleZ;
        m_Swizzle[3] = SwizzleW;
        m_Type = Type;
        m_bExtendedOperand = FALSE;
        m_NumComponents = D3D10_SB_OPERAND_4_COMPONENT;
        m_IndexDimension = D3D10_SB_OPERAND_INDEX_1D;
        m_IndexType[0] = D3D10_SB_OPERAND_INDEX_IMMEDIATE32;
        m_Index[0].m_RegIndex = RegIndex;
    }

    // Used for operands without indices
    COperand(D3D10_SB_OPERAND_TYPE Type): COperandBase()
    {
        m_Type = Type;
        m_Modifier = D3D10_SB_OPERAND_MODIFIER_NONE;
        m_bExtendedOperand = FALSE;
        m_IndexDimension = D3D10_SB_OPERAND_INDEX_0D;
        if( Type == D3D10_SB_OPERAND_TYPE_INPUT_PRIMITIVEID )
        {
            m_NumComponents = D3D10_SB_OPERAND_1_COMPONENT;
        }
        else
        {
            m_NumComponents = D3D10_SB_OPERAND_0_COMPONENT;
        }
    }

    friend class CShaderAsm;
    friend class CShaderCodeParser;
    friend class CInstruction;
};

//*****************************************************************************
//
// class COperand4
//
// Encapsulates a source operand with 4 components in shader instructions
//
//*****************************************************************************

class COperand4: public COperandBase
{
public:
    COperand4(D3D10_SB_OPERAND_TYPE Type, UINT RegIndex): COperandBase()
    {
        m_Modifier = D3D10_SB_OPERAND_MODIFIER_NONE;
        m_ComponentSelection = D3D10_SB_OPERAND_4_COMPONENT_SWIZZLE_MODE;
        m_Swizzle[0] = D3D10_SB_4_COMPONENT_X;
        m_Swizzle[1] = D3D10_SB_4_COMPONENT_Y;
        m_Swizzle[2] = D3D10_SB_4_COMPONENT_Z;
        m_Swizzle[3] = D3D10_SB_4_COMPONENT_W;
        m_Type = Type;
        m_bExtendedOperand = FALSE;
        m_NumComponents = D3D10_SB_OPERAND_4_COMPONENT;
        m_IndexDimension = D3D10_SB_OPERAND_INDEX_1D;
        m_IndexType[0] = D3D10_SB_OPERAND_INDEX_IMMEDIATE32;
        m_Index[0].m_RegIndex = RegIndex;
    }
    COperand4(D3D10_SB_OPERAND_TYPE Type, UINT RegIndex, D3D10_SB_4_COMPONENT_NAME Component): COperandBase()
    {
        m_Modifier = D3D10_SB_OPERAND_MODIFIER_NONE;
        m_ComponentSelection = D3D10_SB_OPERAND_4_COMPONENT_SELECT_1_MODE;
        m_ComponentName = Component;
        m_Type = Type;
        m_bExtendedOperand = FALSE;
        m_NumComponents = D3D10_SB_OPERAND_4_COMPONENT;
        m_IndexDimension = D3D10_SB_OPERAND_INDEX_1D;
        m_IndexType[0] = D3D10_SB_OPERAND_INDEX_IMMEDIATE32;
        m_Index[0].m_RegIndex = RegIndex;
    }
    // 4-component source operand with relative addressing
    COperand4(D3D10_SB_OPERAND_TYPE Type, UINT RegIndex,
             D3D10_SB_OPERAND_TYPE RelRegType, UINT RelRegIndex, D3D10_SB_4_COMPONENT_NAME RelComponentName): COperandBase()
    {
        m_Modifier = D3D10_SB_OPERAND_MODIFIER_NONE;
        m_ComponentSelection = D3D10_SB_OPERAND_4_COMPONENT_SWIZZLE_MODE;
        m_Swizzle[0] = D3D10_SB_4_COMPONENT_X;
        m_Swizzle[1] = D3D10_SB_4_COMPONENT_Y;
        m_Swizzle[2] = D3D10_SB_4_COMPONENT_Z;
        m_Swizzle[3] = D3D10_SB_4_COMPONENT_W;
        m_Type = Type;
        m_bExtendedOperand = FALSE;
        m_NumComponents = D3D10_SB_OPERAND_4_COMPONENT;
        m_IndexDimension = D3D10_SB_OPERAND_INDEX_1D;
        if (RegIndex == 0)
            m_IndexType[0] = D3D10_SB_OPERAND_INDEX_RELATIVE;
        else
            m_IndexType[0] = D3D10_SB_OPERAND_INDEX_IMMEDIATE32_PLUS_RELATIVE;
        m_Index[0].m_RegIndex = RegIndex;
        m_Index[0].m_RelRegType = RelRegType;
        if( RelRegType == D3D10_SB_OPERAND_TYPE_INDEXABLE_TEMP )
        {
            m_Index[0].m_IndexDimension = D3D10_SB_OPERAND_INDEX_2D;
        }
        else
        {
            m_Index[0].m_IndexDimension = D3D10_SB_OPERAND_INDEX_1D;
        }
        m_Index[0].m_RelIndex = RelRegIndex;
        m_Index[0].m_RelIndex1 = 0xFFFFFFFF;
        m_Index[0].m_ComponentName = RelComponentName;
    }
    // 4-component source operand with relative addressing
    COperand4(D3D10_SB_OPERAND_TYPE Type, UINT RegIndex,
        D3D10_SB_OPERAND_TYPE RelRegType, UINT RelRegIndex, UINT RelRegIndex1, D3D10_SB_4_COMPONENT_NAME RelComponentName): COperandBase()
    {
        m_Modifier = D3D10_SB_OPERAND_MODIFIER_NONE;
        m_ComponentSelection = D3D10_SB_OPERAND_4_COMPONENT_SWIZZLE_MODE;
        m_Swizzle[0] = D3D10_SB_4_COMPONENT_X;
        m_Swizzle[1] = D3D10_SB_4_COMPONENT_Y;
        m_Swizzle[2] = D3D10_SB_4_COMPONENT_Z;
        m_Swizzle[3] = D3D10_SB_4_COMPONENT_W;
        m_Type = Type;
        m_bExtendedOperand = FALSE;
        m_NumComponents = D3D10_SB_OPERAND_4_COMPONENT;
        m_IndexDimension = D3D10_SB_OPERAND_INDEX_1D;
        if (RegIndex == 0)
            m_IndexType[0] = D3D10_SB_OPERAND_INDEX_RELATIVE;
        else
            m_IndexType[0] = D3D10_SB_OPERAND_INDEX_IMMEDIATE32_PLUS_RELATIVE;
        m_Index[0].m_RegIndex = RegIndex;
        m_Index[0].m_RelRegType = RelRegType;
        if( RelRegType == D3D10_SB_OPERAND_TYPE_INDEXABLE_TEMP )
        {
            m_Index[0].m_IndexDimension = D3D10_SB_OPERAND_INDEX_2D;
        }
        else
        {
            m_Index[0].m_IndexDimension = D3D10_SB_OPERAND_INDEX_1D;
        }
        m_Index[0].m_RelIndex = RelRegIndex;
        m_Index[0].m_RelIndex1 = RelRegIndex1;
        m_Index[0].m_ComponentName = RelComponentName;
    }
    COperand4(D3D10_SB_OPERAND_TYPE Type, UINT RegIndex,
             BYTE SwizzleX, BYTE SwizzleY, BYTE SwizzleZ, BYTE SwizzleW): COperandBase()
    {
        m_Modifier = D3D10_SB_OPERAND_MODIFIER_NONE;
        m_ComponentSelection = D3D10_SB_OPERAND_4_COMPONENT_SWIZZLE_MODE;
        m_Swizzle[0] = SwizzleX;
        m_Swizzle[1] = SwizzleY;
        m_Swizzle[2] = SwizzleZ;
        m_Swizzle[3] = SwizzleW;
        m_Type = Type;
        m_bExtendedOperand = FALSE;
        m_NumComponents = D3D10_SB_OPERAND_4_COMPONENT;
        m_IndexDimension = D3D10_SB_OPERAND_INDEX_1D;
        m_IndexType[0] = D3D10_SB_OPERAND_INDEX_IMMEDIATE32;
        m_Index[0].m_RegIndex = RegIndex;
    }
    // 4-component source operand with relative addressing
    COperand4(D3D10_SB_OPERAND_TYPE Type, UINT RegIndex,
             BYTE SwizzleX, BYTE SwizzleY, BYTE SwizzleZ, BYTE SwizzleW,
             D3D10_SB_OPERAND_TYPE RelRegType, UINT RelRegIndex, UINT RelRegIndex1,
             D3D10_SB_4_COMPONENT_NAME RelComponentName): COperandBase()
    {
        m_Modifier = D3D10_SB_OPERAND_MODIFIER_NONE;
        m_ComponentSelection = D3D10_SB_OPERAND_4_COMPONENT_SWIZZLE_MODE;
        m_Swizzle[0] = SwizzleX;
        m_Swizzle[1] = SwizzleY;
        m_Swizzle[2] = SwizzleZ;
        m_Swizzle[3] = SwizzleW;
        m_Type = Type;
        m_bExtendedOperand = FALSE;
        m_NumComponents = D3D10_SB_OPERAND_4_COMPONENT;
        m_IndexDimension = D3D10_SB_OPERAND_INDEX_1D;
        if (RegIndex == 0)
            m_IndexType[0] = D3D10_SB_OPERAND_INDEX_RELATIVE;
        else
            m_IndexType[0] = D3D10_SB_OPERAND_INDEX_IMMEDIATE32_PLUS_RELATIVE;
        m_Index[0].m_RelRegType = RelRegType;
        if( RelRegType == D3D10_SB_OPERAND_TYPE_INDEXABLE_TEMP )
        {
            m_Index[0].m_IndexDimension = D3D10_SB_OPERAND_INDEX_2D;
        }
        else
        {
            m_Index[0].m_IndexDimension = D3D10_SB_OPERAND_INDEX_1D;
        }
        m_Index[0].m_RegIndex = RegIndex;
        m_Index[0].m_RelIndex = RelRegIndex;
        m_Index[0].m_RelIndex1 = RelRegIndex1;
        m_Index[0].m_ComponentName = RelComponentName;
    }

    friend class CShaderAsm;
    friend class CShaderCodeParser;
    friend class CInstruction;
};
//*****************************************************************************
//
// class COperandDst
//
// Encapsulates a destination operand in shader instructions
//
//*****************************************************************************

class COperandDst: public COperandBase
{
public:
    COperandDst(D3D10_SB_OPERAND_TYPE Type, UINT RegIndex): COperandBase()
    {
        m_Modifier = D3D10_SB_OPERAND_MODIFIER_NONE;
        m_ComponentSelection = D3D10_SB_OPERAND_4_COMPONENT_MASK_MODE;
        m_WriteMask = D3D10_SB_OPERAND_4_COMPONENT_MASK_ALL;
        m_Type = Type;
        m_bExtendedOperand = FALSE;
        m_NumComponents = D3D10_SB_OPERAND_4_COMPONENT;
        m_IndexDimension = D3D10_SB_OPERAND_INDEX_1D;
        m_IndexType[0] = D3D10_SB_OPERAND_INDEX_IMMEDIATE32;
        m_Index[0].m_RegIndex = RegIndex;
    }
    COperandDst(D3D10_SB_OPERAND_TYPE Type, UINT RegIndex, UINT WriteMask): COperandBase()
    {
        m_Modifier = D3D10_SB_OPERAND_MODIFIER_NONE;
        m_ComponentSelection = D3D10_SB_OPERAND_4_COMPONENT_MASK_MODE;
        m_WriteMask = WriteMask;
        m_Type = Type;
        m_bExtendedOperand = FALSE;
        m_NumComponents = D3D10_SB_OPERAND_4_COMPONENT;
        m_IndexDimension = D3D10_SB_OPERAND_INDEX_1D;
        m_IndexType[0] = D3D10_SB_OPERAND_INDEX_IMMEDIATE32;
        m_Index[0].m_RegIndex = RegIndex;
    }
    COperandDst(D3D10_SB_OPERAND_TYPE Type, UINT RegIndex, UINT WriteMask,
         D3D10_SB_OPERAND_TYPE RelRegType,
         UINT RelRegIndex, UINT RelRegIndex1,
         D3D10_SB_4_COMPONENT_NAME RelComponentName):COperandBase()
    {
        m_Modifier = D3D10_SB_OPERAND_MODIFIER_NONE;
        m_ComponentSelection = D3D10_SB_OPERAND_4_COMPONENT_MASK_MODE;
        m_WriteMask = WriteMask;
        m_Type = Type;
        m_bExtendedOperand = FALSE;
        m_NumComponents = D3D10_SB_OPERAND_4_COMPONENT;
        m_IndexDimension = D3D10_SB_OPERAND_INDEX_1D;
        if (RegIndex == 0)
            m_IndexType[0] = D3D10_SB_OPERAND_INDEX_RELATIVE;
        else
            m_IndexType[0] = D3D10_SB_OPERAND_INDEX_IMMEDIATE32_PLUS_RELATIVE;
        m_Index[0].m_RelRegType = RelRegType;
        if( RelRegType == D3D10_SB_OPERAND_TYPE_INDEXABLE_TEMP )
        {
            m_Index[0].m_IndexDimension = D3D10_SB_OPERAND_INDEX_2D;
        }
        else
        {
            m_Index[0].m_IndexDimension = D3D10_SB_OPERAND_INDEX_1D;
        }
        m_Index[0].m_RegIndex = RegIndex;
        m_Index[0].m_RelIndex  = RelRegIndex;
        m_Index[0].m_RelIndex1 = RelRegIndex1;
        m_Index[0].m_ComponentName = RelComponentName;

    }
    COperandDst(D3D10_SB_OPERAND_TYPE Type, UINT RegIndex, UINT WriteMask,
                D3D10_SB_OPERAND_TYPE RelRegType, UINT RelRegIndex, UINT RelRegIndex1,
                D3D10_SB_4_COMPONENT_NAME RelComponentName, UINT) : COperandBase()
    {
        m_Modifier = D3D10_SB_OPERAND_MODIFIER_NONE;
        m_ComponentSelection = D3D10_SB_OPERAND_4_COMPONENT_MASK_MODE;
        m_WriteMask = WriteMask;
        m_Type = Type;
        m_bExtendedOperand = FALSE;
        m_NumComponents = D3D10_SB_OPERAND_4_COMPONENT;
        m_IndexDimension = D3D10_SB_OPERAND_INDEX_2D;
        m_IndexType[0] = D3D10_SB_OPERAND_INDEX_IMMEDIATE32;
        m_Index[0].m_RegIndex = RegIndex;
        if (RelRegIndex == 0)
            m_IndexType[1] = D3D10_SB_OPERAND_INDEX_RELATIVE;
        else
            m_IndexType[1] = D3D10_SB_OPERAND_INDEX_IMMEDIATE32_PLUS_RELATIVE;
        m_Index[1].m_RelRegType = RelRegType;
        if( RelRegType == D3D10_SB_OPERAND_TYPE_INDEXABLE_TEMP )
        {
            m_Index[1].m_IndexDimension = D3D10_SB_OPERAND_INDEX_2D;
        }
        else
        {
            m_Index[1].m_IndexDimension = D3D10_SB_OPERAND_INDEX_1D;
        }
        m_Index[1].m_RegIndex = RelRegIndex;
        m_Index[1].m_RelIndex  = RelRegIndex1;
        m_Index[1].m_RelIndex1 = 0;
        m_Index[1].m_ComponentName = RelComponentName;

    }
    // 2D dst (e.g. for GS input decl)
    COperandDst(D3D10_SB_OPERAND_TYPE Type, UINT RegIndex0, UINT RegIndex1,UINT WriteMask): COperandBase()
    {
        m_Modifier = D3D10_SB_OPERAND_MODIFIER_NONE;
        m_ComponentSelection = D3D10_SB_OPERAND_4_COMPONENT_MASK_MODE;
        m_WriteMask = WriteMask;
        m_Type = Type;
        m_bExtendedOperand = FALSE;
        m_NumComponents = D3D10_SB_OPERAND_4_COMPONENT;
        m_IndexDimension = D3D10_SB_OPERAND_INDEX_2D;
        m_IndexType[0] = D3D10_SB_OPERAND_INDEX_IMMEDIATE32;
        m_Index[0].m_RegIndex = RegIndex0;
        m_IndexType[1] = D3D10_SB_OPERAND_INDEX_IMMEDIATE32;
        m_Index[1].m_RegIndex = RegIndex1;
    }
    // Used for operands without indices
    COperandDst(D3D10_SB_OPERAND_TYPE Type): COperandBase()
    {
        if( Type == D3D10_SB_OPERAND_TYPE_OUTPUT_DEPTH )
        {
            m_NumComponents = D3D10_SB_OPERAND_1_COMPONENT;
        }
        else
        {
            m_NumComponents = D3D10_SB_OPERAND_0_COMPONENT;
        }
        m_Modifier = D3D10_SB_OPERAND_MODIFIER_NONE;
        m_IndexDimension = D3D10_SB_OPERAND_INDEX_0D;
        m_Type = Type;
        m_bExtendedOperand = FALSE;
    }

    friend class CShaderAsm;
    friend class CShaderCodeParser;
    friend class CInstruction;
};

//*****************************************************************************
//
// class COperand2D
//
// Encapsulates 2 dimensional source operand with 4 components in shader instructions
//
//*****************************************************************************

class COperand2D: public COperandBase
{
public:
    COperand2D(D3D10_SB_OPERAND_TYPE Type, UINT RegIndex0, UINT RegIndex1): COperandBase()
    {
        m_Modifier = D3D10_SB_OPERAND_MODIFIER_NONE;
        m_ComponentSelection = D3D10_SB_OPERAND_4_COMPONENT_SWIZZLE_MODE;
        m_Swizzle[0] = D3D10_SB_4_COMPONENT_X;
        m_Swizzle[1] = D3D10_SB_4_COMPONENT_Y;
        m_Swizzle[2] = D3D10_SB_4_COMPONENT_Z;
        m_Swizzle[3] = D3D10_SB_4_COMPONENT_W;
        m_Type = Type;
        m_bExtendedOperand = FALSE;
        m_NumComponents = D3D10_SB_OPERAND_4_COMPONENT;
        m_IndexDimension = D3D10_SB_OPERAND_INDEX_2D;
        m_IndexType[0] = D3D10_SB_OPERAND_INDEX_IMMEDIATE32;
        m_Index[0].m_RegIndex = RegIndex0;
        m_IndexType[1] = D3D10_SB_OPERAND_INDEX_IMMEDIATE32;
        m_Index[1].m_RegIndex = RegIndex1;
    }
    COperand2D(D3D10_SB_OPERAND_TYPE Type, UINT RegIndex0, UINT RegIndex1, D3D10_SB_4_COMPONENT_NAME Component): COperandBase()
    {
        m_Modifier = D3D10_SB_OPERAND_MODIFIER_NONE;
        m_ComponentSelection = D3D10_SB_OPERAND_4_COMPONENT_SELECT_1_MODE;
        m_ComponentName = Component;
        m_Type = Type;
        m_bExtendedOperand = FALSE;
        m_NumComponents = D3D10_SB_OPERAND_4_COMPONENT;
        m_IndexDimension = D3D10_SB_OPERAND_INDEX_2D;
        m_IndexType[0] = D3D10_SB_OPERAND_INDEX_IMMEDIATE32;
        m_Index[0].m_RegIndex = RegIndex0;
        m_IndexType[1] = D3D10_SB_OPERAND_INDEX_IMMEDIATE32;
        m_Index[1].m_RegIndex = RegIndex1;
    }
    // 2-dimensional 4-component operand with relative addressing the second index
    // For example:
    //      c2[x12[3].w + 7]
    //  Type = c
    //  RelRegType = x
    //  RegIndex0 = 2
    //  RegIndex1 = 7
    //  RelRegIndex = 12
    //  RelRegIndex1 = 3
    //  RelComponentName = w
    //
    COperand2D(D3D10_SB_OPERAND_TYPE Type,
              UINT RegIndex0,
              UINT RegIndex1,
              D3D10_SB_OPERAND_TYPE RelRegType,
              UINT RelRegIndex,
              UINT RelRegIndex1,
              D3D10_SB_4_COMPONENT_NAME RelComponentName): COperandBase()
    {
        m_Modifier = D3D10_SB_OPERAND_MODIFIER_NONE;
        m_ComponentSelection = D3D10_SB_OPERAND_4_COMPONENT_SWIZZLE_MODE;
        m_Swizzle[0] = D3D10_SB_4_COMPONENT_X;
        m_Swizzle[1] = D3D10_SB_4_COMPONENT_Y;
        m_Swizzle[2] = D3D10_SB_4_COMPONENT_Z;
        m_Swizzle[3] = D3D10_SB_4_COMPONENT_W;
        m_Type = Type;
        m_bExtendedOperand = FALSE;
        m_NumComponents = D3D10_SB_OPERAND_4_COMPONENT;
        m_IndexDimension = D3D10_SB_OPERAND_INDEX_2D;
        m_IndexType[0] = D3D10_SB_OPERAND_INDEX_IMMEDIATE32;
        m_Index[0].m_RegIndex = RegIndex0;
        m_IndexType[1] = D3D10_SB_OPERAND_INDEX_IMMEDIATE32_PLUS_RELATIVE;
        m_Index[1].m_RegIndex = RegIndex1;
        m_Index[1].m_RelRegType = RelRegType;
        if( RelRegType == D3D10_SB_OPERAND_TYPE_INDEXABLE_TEMP )
        {
            m_Index[1].m_IndexDimension = D3D10_SB_OPERAND_INDEX_2D;
        }
        else
        {
            m_Index[1].m_IndexDimension = D3D10_SB_OPERAND_INDEX_1D;
        }
        m_Index[1].m_RelIndex  = RelRegIndex;
        m_Index[1].m_RelIndex1 = RelRegIndex1;
        m_Index[1].m_ComponentName = RelComponentName;
    }
    // 2-dimensional 4-component operand with relative addressing a second index
    // For example:
    //      c2[r12.y + 7]
    //  Type = c
    //  RelRegType = r
    //  RegIndex0 = 2
    //  RegIndex1 = 7
    //  RelRegIndex = 12
    //  RelRegIndex1 = 3
    //  RelComponentName = y
    //
    COperand2D(D3D10_SB_OPERAND_TYPE Type,
              UINT RegIndex0,
              UINT RegIndex1,
              D3D10_SB_OPERAND_TYPE RelRegType,
              UINT RelRegIndex,
              D3D10_SB_4_COMPONENT_NAME RelComponentName): COperandBase()
    {
        m_Modifier = D3D10_SB_OPERAND_MODIFIER_NONE;
        m_ComponentSelection = D3D10_SB_OPERAND_4_COMPONENT_SWIZZLE_MODE;
        m_Swizzle[0] = D3D10_SB_4_COMPONENT_X;
        m_Swizzle[1] = D3D10_SB_4_COMPONENT_Y;
        m_Swizzle[2] = D3D10_SB_4_COMPONENT_Z;
        m_Swizzle[3] = D3D10_SB_4_COMPONENT_W;
        m_Type = Type;
        m_bExtendedOperand = FALSE;
        m_NumComponents = D3D10_SB_OPERAND_4_COMPONENT;
        m_IndexDimension = D3D10_SB_OPERAND_INDEX_2D;
        m_IndexType[0] = D3D10_SB_OPERAND_INDEX_IMMEDIATE32;
        m_Index[0].m_RegIndex = RegIndex0;
        m_IndexType[1] = D3D10_SB_OPERAND_INDEX_IMMEDIATE32_PLUS_RELATIVE;
        m_Index[1].m_RegIndex = RegIndex1;
        m_Index[1].m_RelRegType = RelRegType;
        if( RelRegType == D3D10_SB_OPERAND_TYPE_INDEXABLE_TEMP )
        {
            m_Index[1].m_IndexDimension = D3D10_SB_OPERAND_INDEX_2D;
        }
        else
        {
            m_Index[1].m_IndexDimension = D3D10_SB_OPERAND_INDEX_1D;
        }
        m_Index[1].m_RelIndex  = RelRegIndex;
        m_Index[1].m_ComponentName = RelComponentName;
    }
    // 2-dimensional 4-component operand with relative addressing both operands
    COperand2D(D3D10_SB_OPERAND_TYPE Type,
              BOOL bIndexRelative0, BOOL bIndexRelative1,
              UINT RegIndex0, UINT RegIndex1,
              D3D10_SB_OPERAND_TYPE RelRegType0, UINT RelRegIndex0, UINT RelRegIndex10, D3D10_SB_4_COMPONENT_NAME RelComponentName0,
              D3D10_SB_OPERAND_TYPE RelRegType1, UINT RelRegIndex1, UINT RelRegIndex11, D3D10_SB_4_COMPONENT_NAME RelComponentName1): COperandBase()
    {
        m_Modifier = D3D10_SB_OPERAND_MODIFIER_NONE;
        m_ComponentSelection = D3D10_SB_OPERAND_4_COMPONENT_SWIZZLE_MODE;
        m_Swizzle[0] = D3D10_SB_4_COMPONENT_X;
        m_Swizzle[1] = D3D10_SB_4_COMPONENT_Y;
        m_Swizzle[2] = D3D10_SB_4_COMPONENT_Z;
        m_Swizzle[3] = D3D10_SB_4_COMPONENT_W;
        m_Type = Type;
        m_bExtendedOperand = FALSE;
        m_NumComponents = D3D10_SB_OPERAND_4_COMPONENT;
        m_IndexDimension = D3D10_SB_OPERAND_INDEX_2D;
        if (bIndexRelative0)
            if (RegIndex0 == 0)
                m_IndexType[0] = D3D10_SB_OPERAND_INDEX_RELATIVE;
            else
                m_IndexType[0] = D3D10_SB_OPERAND_INDEX_IMMEDIATE32_PLUS_RELATIVE;
        else
            m_IndexType[0] = D3D10_SB_OPERAND_INDEX_IMMEDIATE32;
        m_Index[0].m_RegIndex = RegIndex0;
        m_Index[0].m_RelRegType = RelRegType0;
        if( RelRegType0 == D3D10_SB_OPERAND_TYPE_INDEXABLE_TEMP )
        {
            m_Index[0].m_IndexDimension = D3D10_SB_OPERAND_INDEX_2D;
        }
        else
        {
            m_Index[0].m_IndexDimension = D3D10_SB_OPERAND_INDEX_1D;
        }
        m_Index[0].m_RelIndex = RelRegIndex0;
        m_Index[0].m_RelIndex1 = RelRegIndex10;
        m_Index[0].m_ComponentName = RelComponentName0;
        if (bIndexRelative1)
            if (RegIndex1 == 0)
                m_IndexType[1] = D3D10_SB_OPERAND_INDEX_RELATIVE;
            else
                m_IndexType[1] = D3D10_SB_OPERAND_INDEX_IMMEDIATE32_PLUS_RELATIVE;
        else
            m_IndexType[1] = D3D10_SB_OPERAND_INDEX_IMMEDIATE32;
        m_Index[1].m_RegIndex = RegIndex1;
        m_Index[1].m_RelRegType = RelRegType1;
        if( RelRegType1 == D3D10_SB_OPERAND_TYPE_INDEXABLE_TEMP )
        {
            m_Index[1].m_IndexDimension = D3D10_SB_OPERAND_INDEX_2D;
        }
        else
        {
            m_Index[1].m_IndexDimension = D3D10_SB_OPERAND_INDEX_1D;
        }
        m_Index[1].m_RelIndex = RelRegIndex1;
        m_Index[1].m_RelIndex1 = RelRegIndex11;
        m_Index[1].m_ComponentName = RelComponentName1;
    }
    COperand2D(D3D10_SB_OPERAND_TYPE Type, UINT RegIndex0, UINT RegIndex1,
              BYTE SwizzleX, BYTE SwizzleY, BYTE SwizzleZ, BYTE SwizzleW): COperandBase()
    {
        m_Modifier = D3D10_SB_OPERAND_MODIFIER_NONE;
        m_ComponentSelection = D3D10_SB_OPERAND_4_COMPONENT_SWIZZLE_MODE;
        m_Swizzle[0] = SwizzleX;
        m_Swizzle[1] = SwizzleY;
        m_Swizzle[2] = SwizzleZ;
        m_Swizzle[3] = SwizzleW;
        m_Type = Type;
        m_bExtendedOperand = FALSE;
        m_NumComponents = D3D10_SB_OPERAND_4_COMPONENT;
        m_IndexDimension = D3D10_SB_OPERAND_INDEX_2D;
        m_IndexType[0] = D3D10_SB_OPERAND_INDEX_IMMEDIATE32;
        m_Index[0].m_RegIndex = RegIndex0;
        m_IndexType[1] = D3D10_SB_OPERAND_INDEX_IMMEDIATE32;
        m_Index[1].m_RegIndex = RegIndex1;
    }
    // 2-dimensional 4-component operand with relative addressing and swizzle
    COperand2D(D3D10_SB_OPERAND_TYPE Type,
              BYTE SwizzleX, BYTE SwizzleY, BYTE SwizzleZ, BYTE SwizzleW,
              BOOL bIndexRelative0, BOOL bIndexRelative1,
              UINT RegIndex0, D3D10_SB_OPERAND_TYPE RelRegType0, UINT RelRegIndex0, UINT RelRegIndex10, D3D10_SB_4_COMPONENT_NAME RelComponentName0,
              UINT RegIndex1, D3D10_SB_OPERAND_TYPE RelRegType1, UINT RelRegIndex1, UINT RelRegIndex11, D3D10_SB_4_COMPONENT_NAME RelComponentName1): COperandBase()
    {
        m_Modifier = D3D10_SB_OPERAND_MODIFIER_NONE;
        m_ComponentSelection = D3D10_SB_OPERAND_4_COMPONENT_SWIZZLE_MODE;
        m_Swizzle[0] = SwizzleX;
        m_Swizzle[1] = SwizzleY;
        m_Swizzle[2] = SwizzleZ;
        m_Swizzle[3] = SwizzleW;
        m_Type = Type;
        m_bExtendedOperand = FALSE;
        m_NumComponents = D3D10_SB_OPERAND_4_COMPONENT;
        m_IndexDimension = D3D10_SB_OPERAND_INDEX_2D;
        if (bIndexRelative0)
            if (RegIndex0 == 0)
                m_IndexType[0] = D3D10_SB_OPERAND_INDEX_RELATIVE;
            else
                m_IndexType[0] = D3D10_SB_OPERAND_INDEX_IMMEDIATE32_PLUS_RELATIVE;
        else
            m_IndexType[0] = D3D10_SB_OPERAND_INDEX_IMMEDIATE32;
        m_Index[0].m_RegIndex = RegIndex0;
        m_Index[0].m_RelRegType = RelRegType0;
        if( RelRegType0 == D3D10_SB_OPERAND_TYPE_INDEXABLE_TEMP )
        {
            m_Index[0].m_IndexDimension = D3D10_SB_OPERAND_INDEX_2D;
        }
        else
        {
            m_Index[0].m_IndexDimension = D3D10_SB_OPERAND_INDEX_1D;
        }
        m_Index[0].m_RelIndex = RelRegIndex0;
        m_Index[0].m_RelIndex1 = RelRegIndex10;
        m_Index[0].m_ComponentName = RelComponentName0;
        if (bIndexRelative1)
            if (RegIndex1 == 0)
                m_IndexType[1] = D3D10_SB_OPERAND_INDEX_RELATIVE;
            else
                m_IndexType[1] = D3D10_SB_OPERAND_INDEX_IMMEDIATE32_PLUS_RELATIVE;
        else
            m_IndexType[1] = D3D10_SB_OPERAND_INDEX_IMMEDIATE32;
        m_Index[1].m_RegIndex = RegIndex1;
        m_Index[1].m_RelRegType = RelRegType1;
        if( RelRegType1 == D3D10_SB_OPERAND_TYPE_INDEXABLE_TEMP )
        {
            m_Index[1].m_IndexDimension = D3D10_SB_OPERAND_INDEX_2D;
        }
        else
        {
            m_Index[1].m_IndexDimension = D3D10_SB_OPERAND_INDEX_1D;
        }
        m_Index[1].m_RelIndex = RelRegIndex1;
        m_Index[1].m_RelIndex1 = RelRegIndex11;
        m_Index[1].m_ComponentName = RelComponentName1;
    }

    friend class CShaderAsm;
    friend class CShaderCodeParser;
    friend class CInstruction;
};

//*****************************************************************************
//
//  CInstruction
//
//*****************************************************************************

// Structures for additional per-instruction fields unioned in CInstruction.
// These structures don't contain ALL info used by the particular instruction,
// only additional info not already in CInstruction.  Some instructions don't
// need such structures because CInstruction already has the correct data
// fields.

struct CGlobalFlagsDecl
{
    UINT Flags;
};

struct CInputSystemInterpretedValueDecl
{
    D3D10_SB_NAME  Name;
};

struct CInputSystemGeneratedValueDecl
{
    D3D10_SB_NAME  Name;
};

struct CInputPSDecl
{
    D3D10_SB_INTERPOLATION_MODE InterpolationMode;
};

struct CInputPSSystemInterpretedValueDecl
{
    D3D10_SB_NAME  Name;
    D3D10_SB_INTERPOLATION_MODE InterpolationMode;
};

struct CInputPSSystemGeneratedValueDecl
{
    D3D10_SB_NAME  Name;
    D3D10_SB_INTERPOLATION_MODE InterpolationMode;
};

struct COutputSystemInterpretedValueDecl
{
    D3D10_SB_NAME  Name;
};

struct COutputSystemGeneratedValueDecl
{
    D3D10_SB_NAME  Name;
};

struct CIndexRangeDecl
{
    UINT    RegCount;
};

struct CResourceDecl
{
    D3D10_SB_RESOURCE_DIMENSION      Dimension;
    D3D10_SB_RESOURCE_RETURN_TYPE    ReturnType[4];
    UINT                             SampleCount;
};

struct CConstantBufferDecl
{
    D3D10_SB_CONSTANT_BUFFER_ACCESS_PATTERN AccessPattern;
};

struct COutputTopologyDecl
{
    D3D10_SB_PRIMITIVE_TOPOLOGY    Topology;
};

struct CInputPrimitiveDecl
{
    D3D10_SB_PRIMITIVE             Primitive;
};

struct CGSMaxOutputVertexCountDecl
{
    UINT    MaxOutputVertexCount;
};

struct CGSInstanceCountDecl
{
    UINT    InstanceCount;
};

//
// Used for typed, raw and structured UAVs
//
struct CUAVDecl
{
    D3D10_SB_OPCODE_TYPE UAVType;
    //Used for all uavs
    UINT Index;
    UINT Coherency; //0 if local
    //Used for structured uavs
    UINT Stride;
    UINT Counter;
    //Used for typed uavs
    D3D10_SB_RESOURCE_DIMENSION Dimension;
    D3D10_SB_RESOURCE_RETURN_TYPE Type;
};

//
// Used for raw and structured thread group shared memory
//
struct CTGSMDecl
{
    D3D10_SB_OPCODE_TYPE Type;
    UINT Index;
    UINT StructStride;
    UINT StructCount;
};

struct CSamplerDecl
{
    D3D10_SB_SAMPLER_MODE          SamplerMode;
};

struct CTempsDecl
{
    UINT    NumTemps;
};

struct CIndexableTempDecl
{
    UINT    IndexableTempNumber;
    UINT    NumRegisters;
    UINT    Mask; // .x, .xy, .xzy or .xyzw (D3D10_SB_OPERAND_4_COMPONENT_MASK_* )
};

struct CCustomData
{
    D3D10_SB_CUSTOMDATA_CLASS  Type;
    UINT                    DataSizeInBytes;
    void*                   pData;
};

struct CSyncFlags
{
    bool bThreadsInGroup;
    bool bThreadGroupSharedMemory;
    bool bUnorderedAccessViewMemoryGlobal;
    bool bUnorderedAccessViewMemoryGroup; // exclusive to global
};

struct CFunctionTable
{
    int FtIdx;
    UINT FbCount;
    CShaderToken* pFbStartToken;
};

struct CInterfaceTable
{
    int FpIdx;
    bool bDynamic;
    UINT NumCallSites;
    UINT FpArraySize;
    UINT FtCount;
    CShaderToken* pFtStartToken;
};

struct CHSDSInputControlPointCountDecl
{
    UINT    InputControlPointCount;
};

struct CHSOutputControlPointCountDecl
{
    UINT    OutputControlPointCount;
};

struct CTessellatorDomainDecl
{
    D3D11_SB_TESSELLATOR_DOMAIN TessellatorDomain;
};

struct CTessellatorPartitioningDecl
{
    D3D11_SB_TESSELLATOR_PARTITIONING TessellatorPartitioning;
};

struct CTessellatorOutputPrimitiveDecl
{
    D3D11_SB_TESSELLATOR_OUTPUT_PRIMITIVE TessellatorOutputPrimitive;
};

struct CHSMaxTessFactorDecl
{
    float MaxTessFactor;
};

struct CHSForkPhaseDecl
{
    UINT InstanceCount;
};

struct CHSJoinPhaseDecl
{
    UINT InstanceCount;
};

class CInstruction
{
protected:
    static const UINT MAX_PRIVATE_DATA_COUNT = 2;

public:
    
    CInstruction() : m_OpCode(D3D10_SB_OPCODE_ADD) 
    { 
        Clear(); 
    }

    CInstruction(D3D10_SB_OPCODE_TYPE OpCode)
    {
        Clear();
        m_OpCode = OpCode;
    }

    CInstruction(D3D10_SB_OPCODE_TYPE OpCode, 
                 const COperandBase& Operand0,
                 D3D10_SB_INSTRUCTION_TEST_BOOLEAN Test)
    {
        Clear();
        m_OpCode = OpCode;
        m_NumOperands = 1;
        m_Test = Test;
        m_Operands[0] = Operand0;
    }

    CInstruction(D3D10_SB_OPCODE_TYPE OpCode, 
                 const COperandBase& Operand0, 
                 const COperandBase& Operand1)
    {
        Clear();
        m_OpCode = OpCode;
        m_NumOperands = 2;
        m_Operands[0] = Operand0;
        m_Operands[1] = Operand1;
    }

    CInstruction(D3D10_SB_OPCODE_TYPE OpCode, 
                 const COperandBase& Operand0, 
                 const COperandBase& Operand1, 
                 const COperandBase& Operand2)
    {
        Clear();
        m_OpCode = OpCode;
        m_NumOperands = 3;
        m_Operands[0] = Operand0;
        m_Operands[1] = Operand1;
        m_Operands[2] = Operand2;

    }

    CInstruction(D3D10_SB_OPCODE_TYPE OpCode, 
                 const COperandBase& Operand0, 
                 const COperandBase& Operand1,
                 const COperandBase& Operand2, 
                 const COperandBase& Operand3)
    {
        Clear();
        m_OpCode = OpCode;
        m_NumOperands = 4;
        m_Operands[0] = Operand0;
        m_Operands[1] = Operand1;
        m_Operands[2] = Operand2;
        m_Operands[3] = Operand3;
    }    

    ~CInstruction()
    {
        if (m_OpCode == D3D10_SB_OPCODE_CUSTOMDATA)
        {
            if (m_CustomData.pData) { delete(m_CustomData.pData); }
        }
    }

    void Clear(bool bFullInitialization = false)
    {
        if (bFullInitialization)
        {
            if (m_OpCode == D3D10_SB_OPCODE_CUSTOMDATA)
            {
                if (m_CustomData.pData) { delete(m_CustomData.pData); }
            }

            memset(this, 0, sizeof(CInstruction));
        }
        else
        {
            memset(this, 0, offsetof(CInstruction, m_Operands));
        }
    }
    
    const COperandBase& Operand(UINT Index) const 
    {
        return m_Operands[Index];
    }
    
    D3D10_SB_OPCODE_TYPE OpCode() const 
    {
        return m_OpCode;
    }
    
    void SetNumOperands(UINT NumOperands) 
    {
        m_NumOperands = NumOperands;
    }
    
    UINT NumOperands() const 
    {
        return m_NumOperands;
    }
    
    void SetTest(D3D10_SB_INSTRUCTION_TEST_BOOLEAN Test) 
    {
        m_Test = Test;
    }
    
    D3D10_SB_INSTRUCTION_TEST_BOOLEAN Test() const 
    {
        return m_Test;
    }

    void SetTexelOffset( const INT8 texelOffset[3] )
    {
        m_bExtended = TRUE;
        m_OpCodeEx[m_ExtendedOpCodeCount++] = D3D10_SB_EXTENDED_OPCODE_SAMPLE_CONTROLS;
        memcpy(m_TexelOffset, texelOffset,sizeof(m_TexelOffset));
    }

    void SetTexelOffset( INT8 x, INT8 y, INT8 z)
    {
        m_bExtended = TRUE;
        m_OpCodeEx[m_ExtendedOpCodeCount++] = D3D10_SB_EXTENDED_OPCODE_SAMPLE_CONTROLS;
        m_TexelOffset[0] = x;
        m_TexelOffset[1] = y;
        m_TexelOffset[2] = z;
    }

    __success(return != FALSE) BOOL Disassemble(__out_ecount(StringSize) __nullterminated LPSTR pString, __in_range(>,0) UINT StringSize);

    // Private data is used by D3D runtime
    void SetPrivateData(UINT Value, UINT index = 0)
    {
        if (index < MAX_PRIVATE_DATA_COUNT)
        {
            m_PrivateData[index] = Value;
        }
    }

    UINT PrivateData(UINT index = 0) const
    {
        if (index >= MAX_PRIVATE_DATA_COUNT)
            return 0xFFFFFFFF;
        return m_PrivateData[index];
    }

    D3D10_SB_OPCODE_TYPE        m_OpCode;
    UINT                        m_NumOperands;
    BOOL                        m_bExtended;
    UINT                        m_ExtendedOpCodeCount;
    D3D10_SB_EXTENDED_OPCODE_TYPE  m_OpCodeEx[D3D11_SB_MAX_SIMULTANEOUS_EXTENDED_OPCODES];
    INT8                        m_TexelOffset[3];
    UINT                        m_PrivateData[MAX_PRIVATE_DATA_COUNT];
    BOOL                        m_bSaturate;

    union // extra info needed by some instructions
    {
        CInputSystemInterpretedValueDecl    m_InputDeclSIV;
        CInputSystemGeneratedValueDecl      m_InputDeclSGV;
        CInputPSDecl                        m_InputPSDecl;
        CInputPSSystemInterpretedValueDecl  m_InputPSDeclSIV;
        CInputPSSystemGeneratedValueDecl    m_InputPSDeclSGV;
        COutputSystemInterpretedValueDecl   m_OutputDeclSIV;
        COutputSystemGeneratedValueDecl     m_OutputDeclSGV;
        CIndexRangeDecl                     m_IndexRangeDecl;
        CResourceDecl                       m_ResourceDecl;
        CConstantBufferDecl                 m_ConstantBufferDecl;
        CInputPrimitiveDecl                 m_InputPrimitiveDecl;
        COutputTopologyDecl                 m_OutputTopologyDecl;
        CGSMaxOutputVertexCountDecl         m_GSMaxOutputVertexCountDecl;
        CGSInstanceCountDecl                m_GSInstanceCount;
        CUAVDecl                            m_UAVInfo;
        CTGSMDecl                           m_TGSMInfo;
        CSamplerDecl                        m_SamplerDecl;
        CTempsDecl                          m_TempsDecl;
        CIndexableTempDecl                  m_IndexableTempDecl;
        CGlobalFlagsDecl                    m_GlobalFlagsDecl;
        CCustomData                         m_CustomData;
        D3D10_SB_INSTRUCTION_TEST_BOOLEAN   m_Test;
        D3D10_SB_RESINFO_INSTRUCTION_RETURN_TYPE m_ResInfoReturnType;
        D3D10_SB_INSTRUCTION_RETURN_TYPE    m_InstructionReturnType;
        CSyncFlags                          m_SyncFlags;
        int                                 m_FunctionBodyIdx;
        CFunctionTable                      m_FunctionTable;
        CInterfaceTable                     m_InterfaceTable;
        int                                 m_InterfaceCallSiteIdx;
        CHSDSInputControlPointCountDecl     m_InputControlPointCountDecl;
        CHSOutputControlPointCountDecl      m_OutputControlPointCountDecl;
        CTessellatorDomainDecl              m_TessellatorDomainDecl;
        CTessellatorPartitioningDecl        m_TessellatorPartitioningDecl;
        CTessellatorOutputPrimitiveDecl     m_TessellatorOutputPrimitiveDecl;
        CHSMaxTessFactorDecl                m_HSMaxTessFactorDecl;
        CHSForkPhaseDecl                    m_HSForkPhaseDecl;
        CHSJoinPhaseDecl                    m_HSJoinPhaseDecl;
    };

    // Carefull: the memory is zeroes by the constructors up to this point!
    COperandBase                m_Operands[D3D11_SB_MAX_INSTRUCTION_OPERANDS];
};

// ****************************************************************************
//
// class CShaderAsm
//
// The class is used to build a binary representation of a shader.
// Usage scenario:
//      1. Call Init with the initial internal buffer size in UINTs. The
//         internal buffer will grow if needed
//      2. Call StartShader()
//      3. Call Emit*() functions to assemble a shader
//      4. Call EndShader()
//      5. Call GetShader() to get the binary representation
//
//
// ****************************************************************************
class CShaderAsm 
{
public:
    CShaderAsm():
        m_dwFunc(NULL),
        m_Status(S_OK),
        m_Index(0),
        m_StartOpIndex(0),
        m_BufferSize(0)
    {
    };

    ~CShaderAsm()
    {
        if (m_dwFunc) { delete(m_dwFunc); };
    };

    // Initializes the object with the initial buffer size in UINTs
    __checkReturn HRESULT Init()
    {
        HRESULT hr = S_OK;

        m_BufferSize = 1024;

        m_dwFunc = new UINT[m_BufferSize];
        if (!m_dwFunc)
        {
           SHADER_CONV_ASSERT(FALSE);
            goto Cleanup;
        }

        Reset();

Cleanup:
        m_Status = hr;
        return hr;
    }

    UINT* GetShader()               {return m_dwFunc;}
    UINT  ShaderSizeInDWORDs()      {return m_Index;}
    HRESULT GetStatus()             {return m_Status;}
    void SetStatus(HRESULT hr)      {m_Status = hr;}

    // This function should be called to mark the start of a shader
    void StartShader(D3D10_SB_TOKENIZED_PROGRAM_TYPE ShaderType, UINT vermajor,UINT verminor)
    {
        Reset();
        UINT Token = ENCODE_D3D10_SB_TOKENIZED_PROGRAM_VERSION_TOKEN(ShaderType, vermajor, verminor);
        OPCODE(Token);
        OPCODE(0);        // Reserve space for length
    }

    // Should be called at the end of the shader
    __checkReturn HRESULT EndShader()
    {
        if (1 < m_BufferSize)
            m_dwFunc[1] = ENCODE_D3D10_SB_TOKENIZED_PROGRAM_LENGTH(m_Index);

        return m_Status;
    }

    // Emit a resource declaration
    void EmitResourceDecl(D3D10_SB_RESOURCE_DIMENSION Dimension, UINT TRegIndex,
                          D3D10_SB_RESOURCE_RETURN_TYPE ReturnTypeForX,
                          D3D10_SB_RESOURCE_RETURN_TYPE ReturnTypeForY,
                          D3D10_SB_RESOURCE_RETURN_TYPE ReturnTypeForZ,
                          D3D10_SB_RESOURCE_RETURN_TYPE ReturnTypeForW)
    {
        m_bExecutableInstruction = FALSE;
        OPCODE(ENCODE_D3D10_SB_OPCODE_TYPE(D3D10_SB_OPCODE_DCL_RESOURCE) |
               ENCODE_D3D10_SB_RESOURCE_DIMENSION(Dimension) );
        EmitOperand(COperand(D3D10_SB_OPERAND_TYPE_RESOURCE, TRegIndex));
        FUNC(ENCODE_D3D10_SB_RESOURCE_RETURN_TYPE(ReturnTypeForX, 0) |
             ENCODE_D3D10_SB_RESOURCE_RETURN_TYPE(ReturnTypeForY, 1) |
             ENCODE_D3D10_SB_RESOURCE_RETURN_TYPE(ReturnTypeForZ, 2) |
             ENCODE_D3D10_SB_RESOURCE_RETURN_TYPE(ReturnTypeForW, 3));
        ENDINSTRUCTION();
    }
    // Emit a resource declaration (multisampled)
    void EmitResourceMSDecl(D3D10_SB_RESOURCE_DIMENSION Dimension, UINT TRegIndex,
                          D3D10_SB_RESOURCE_RETURN_TYPE ReturnTypeForX,
                          D3D10_SB_RESOURCE_RETURN_TYPE ReturnTypeForY,
                          D3D10_SB_RESOURCE_RETURN_TYPE ReturnTypeForZ,
                          D3D10_SB_RESOURCE_RETURN_TYPE ReturnTypeForW,
                          UINT SampleCount)
    {
        m_bExecutableInstruction = FALSE;
        OPCODE(ENCODE_D3D10_SB_OPCODE_TYPE(D3D10_SB_OPCODE_DCL_RESOURCE) |
               ENCODE_D3D10_SB_RESOURCE_DIMENSION(Dimension) |
               ENCODE_D3D10_SB_RESOURCE_SAMPLE_COUNT(SampleCount));
        EmitOperand(COperand(D3D10_SB_OPERAND_TYPE_RESOURCE, TRegIndex));
        FUNC(ENCODE_D3D10_SB_RESOURCE_RETURN_TYPE(ReturnTypeForX, 0) |
             ENCODE_D3D10_SB_RESOURCE_RETURN_TYPE(ReturnTypeForY, 1) |
             ENCODE_D3D10_SB_RESOURCE_RETURN_TYPE(ReturnTypeForZ, 2) |
             ENCODE_D3D10_SB_RESOURCE_RETURN_TYPE(ReturnTypeForW, 3));
        ENDINSTRUCTION();
    }
    // Emit a sampler declaration
    void EmitSamplerDecl(UINT SRegIndex, D3D10_SB_SAMPLER_MODE Mode)
    {
        m_bExecutableInstruction = FALSE;
        OPCODE( ENCODE_D3D10_SB_OPCODE_TYPE(D3D10_SB_OPCODE_DCL_SAMPLER) |
                ENCODE_D3D10_SB_SAMPLER_MODE(Mode) );
        EmitOperand(COperand(D3D10_SB_OPERAND_TYPE_SAMPLER, SRegIndex));
        ENDINSTRUCTION();
    }

    // Emit an input declaration
    void EmitInputDecl(UINT RegIndex, UINT WriteMask)
    {
        m_bExecutableInstruction = FALSE;
        OPCODE(ENCODE_D3D10_SB_OPCODE_TYPE(D3D10_SB_OPCODE_DCL_INPUT));
        EmitOperand(COperandDst(D3D10_SB_OPERAND_TYPE_INPUT, RegIndex, WriteMask));
        ENDINSTRUCTION();
    }
    void EmitInputDecl2D(UINT RegIndex, UINT RegIndex2, UINT WriteMask)
    {
        m_bExecutableInstruction = FALSE;
        OPCODE(ENCODE_D3D10_SB_OPCODE_TYPE(D3D10_SB_OPCODE_DCL_INPUT));
        EmitOperand(COperandDst(D3D10_SB_OPERAND_TYPE_INPUT, RegIndex, RegIndex2, WriteMask));
        ENDINSTRUCTION();
    }

    // Emit an input declaration for a system interpreted value
    void EmitInputSystemInterpretedValueDecl(UINT RegIndex, UINT WriteMask, D3D10_SB_NAME Name)
    {
        m_bExecutableInstruction = FALSE;
        OPCODE(ENCODE_D3D10_SB_OPCODE_TYPE(D3D10_SB_OPCODE_DCL_INPUT_SIV));
        EmitOperand(COperandDst(D3D10_SB_OPERAND_TYPE_INPUT, RegIndex, WriteMask));
        FUNC(ENCODE_D3D10_SB_NAME(Name));
        ENDINSTRUCTION();
    }
    void EmitInputSystemInterpretedValueDecl2D(UINT RegIndex, UINT RegIndex2, UINT WriteMask, D3D10_SB_NAME Name)
    {
        m_bExecutableInstruction = FALSE;
        OPCODE(ENCODE_D3D10_SB_OPCODE_TYPE(D3D10_SB_OPCODE_DCL_INPUT_SIV));
        EmitOperand(COperandDst(D3D10_SB_OPERAND_TYPE_INPUT, RegIndex, RegIndex2, WriteMask));
        FUNC(ENCODE_D3D10_SB_NAME(Name));
        ENDINSTRUCTION();
    }
    // Emit an input declaration for a system generated value
    void EmitInputSystemGeneratedValueDecl(UINT RegIndex, UINT WriteMask, D3D10_SB_NAME Name)
    {
        m_bExecutableInstruction = FALSE;
        OPCODE(ENCODE_D3D10_SB_OPCODE_TYPE(D3D10_SB_OPCODE_DCL_INPUT_SGV));
        EmitOperand(COperandDst(D3D10_SB_OPERAND_TYPE_INPUT, RegIndex, WriteMask));
        FUNC(ENCODE_D3D10_SB_NAME(Name));
        ENDINSTRUCTION();
    }
    void EmitInputSystemGeneratedValueDecl2D(UINT RegIndex, UINT RegIndex2, UINT WriteMask, D3D10_SB_NAME Name)
    {
        m_bExecutableInstruction = FALSE;
        OPCODE(ENCODE_D3D10_SB_OPCODE_TYPE(D3D10_SB_OPCODE_DCL_INPUT_SGV));
        EmitOperand(COperandDst(D3D10_SB_OPERAND_TYPE_INPUT, RegIndex, RegIndex2, WriteMask));
        FUNC(ENCODE_D3D10_SB_NAME(Name));
        ENDINSTRUCTION();
    }
    // Emit a PS input declaration
    void EmitPSInputDecl(UINT RegIndex, UINT WriteMask, D3D10_SB_INTERPOLATION_MODE Mode)
    {
        m_bExecutableInstruction = FALSE;
        OPCODE( ENCODE_D3D10_SB_OPCODE_TYPE(D3D10_SB_OPCODE_DCL_INPUT_PS) |
                ENCODE_D3D10_SB_INPUT_INTERPOLATION_MODE(Mode));
        EmitOperand(COperandDst(D3D10_SB_OPERAND_TYPE_INPUT, RegIndex, WriteMask));
        ENDINSTRUCTION();
    }
    // Emit a PS input declaration for a system interpreted value
    void EmitPSInputSystemInterpretedValueDecl(UINT RegIndex, UINT WriteMask, D3D10_SB_INTERPOLATION_MODE Mode, D3D10_SB_NAME Name)
    {
        m_bExecutableInstruction = FALSE;
        OPCODE( ENCODE_D3D10_SB_OPCODE_TYPE(D3D10_SB_OPCODE_DCL_INPUT_PS_SIV) |
                ENCODE_D3D10_SB_INPUT_INTERPOLATION_MODE(Mode));
        EmitOperand(COperandDst(D3D10_SB_OPERAND_TYPE_INPUT, RegIndex, WriteMask));
        FUNC(ENCODE_D3D10_SB_NAME(Name));
        ENDINSTRUCTION();
    }
    // Emit a PS input declaration for a system generated value
    void EmitPSInputSystemGeneratedValueDecl(UINT RegIndex, UINT WriteMask, D3D10_SB_INTERPOLATION_MODE Mode, D3D10_SB_NAME Name)
    {
        m_bExecutableInstruction = FALSE;
        OPCODE( ENCODE_D3D10_SB_OPCODE_TYPE(D3D10_SB_OPCODE_DCL_INPUT_PS_SGV) |
                ENCODE_D3D10_SB_INPUT_INTERPOLATION_MODE(Mode));
        EmitOperand(COperandDst(D3D10_SB_OPERAND_TYPE_INPUT, RegIndex, WriteMask));
        FUNC(ENCODE_D3D10_SB_NAME(Name));
        ENDINSTRUCTION();
    }
    // Emit input primitive id declaration
    void EmitInputPrimIdDecl()
    {
        m_bExecutableInstruction = FALSE;
        OPCODE(ENCODE_D3D10_SB_OPCODE_TYPE(D3D10_SB_OPCODE_DCL_INPUT));
        EmitOperand(COperandDst(D3D10_SB_OPERAND_TYPE_INPUT_PRIMITIVEID));
        ENDINSTRUCTION();
    }
    // Emit and oDepth declaration
    void EmitODepthDecl()
    {
        m_bExecutableInstruction = FALSE;
        OPCODE(ENCODE_D3D10_SB_OPCODE_TYPE(D3D10_SB_OPCODE_DCL_OUTPUT));
        EmitOperand(COperandDst(D3D10_SB_OPERAND_TYPE_OUTPUT_DEPTH));
        ENDINSTRUCTION();
    }
    // Emit an oMask declaration
    void EmitOMaskDecl()
    {
        m_bExecutableInstruction = FALSE;
        OPCODE(ENCODE_D3D10_SB_OPCODE_TYPE(D3D10_SB_OPCODE_DCL_OUTPUT));
        EmitOperand(COperandDst(D3D10_SB_OPERAND_TYPE_OUTPUT_COVERAGE_MASK));
        ENDINSTRUCTION();
    }
    // Emit an output declaration
    void EmitOutputDecl(UINT RegIndex, UINT WriteMask)
    {
        m_bExecutableInstruction = FALSE;
        OPCODE(ENCODE_D3D10_SB_OPCODE_TYPE(D3D10_SB_OPCODE_DCL_OUTPUT));
        EmitOperand(COperandDst(D3D10_SB_OPERAND_TYPE_OUTPUT, RegIndex, WriteMask));
        ENDINSTRUCTION();
    }
    // Emit an output declaration for a system interpreted value
    void EmitOutputSystemInterpretedValueDecl(UINT RegIndex, UINT WriteMask, D3D10_SB_NAME Name)
    {
        m_bExecutableInstruction = FALSE;
        OPCODE(ENCODE_D3D10_SB_OPCODE_TYPE(D3D10_SB_OPCODE_DCL_OUTPUT_SIV));
        EmitOperand(COperandDst(D3D10_SB_OPERAND_TYPE_OUTPUT, RegIndex, WriteMask));
        FUNC(ENCODE_D3D10_SB_NAME(Name));
        ENDINSTRUCTION();
    }
    // Emit an output declaration for a system generated value
    void EmitOutputSystemGeneratedValueDecl(UINT RegIndex, UINT WriteMask, D3D10_SB_NAME Name)
    {
        m_bExecutableInstruction = FALSE;
        OPCODE(ENCODE_D3D10_SB_OPCODE_TYPE(D3D10_SB_OPCODE_DCL_OUTPUT_SGV));
        EmitOperand(COperandDst(D3D10_SB_OPERAND_TYPE_OUTPUT, RegIndex, WriteMask));
        FUNC(ENCODE_D3D10_SB_NAME(Name));
        ENDINSTRUCTION();
    }

    // Emit an input register indexing range declaration
    void EmitInputIndexingRangeDecl(UINT RegIndex, UINT Count, UINT WriteMask)
    {
        m_bExecutableInstruction = FALSE;
        OPCODE(ENCODE_D3D10_SB_OPCODE_TYPE(D3D10_SB_OPCODE_DCL_INDEX_RANGE));
        EmitOperand(COperandDst(D3D10_SB_OPERAND_TYPE_INPUT, RegIndex, WriteMask));
        FUNC((UINT)Count);
        ENDINSTRUCTION();
    }

    // 2D indexing range decl (indexing is for second dimension)
    void EmitInputIndexingRangeDecl2D(UINT RegIndex, UINT RegIndex2Min, UINT Reg2Count, UINT WriteMask)
    {
        m_bExecutableInstruction = FALSE;
        OPCODE(ENCODE_D3D10_SB_OPCODE_TYPE(D3D10_SB_OPCODE_DCL_INDEX_RANGE));
        EmitOperand(COperandDst(D3D10_SB_OPERAND_TYPE_INPUT, RegIndex, RegIndex2Min, WriteMask));
        FUNC((UINT)Reg2Count);
        ENDINSTRUCTION();
    }

    // Emit an output register indexing range declaration
    void EmitOutputIndexingRangeDecl(UINT RegIndex, UINT Count, UINT WriteMask)
    {
        m_bExecutableInstruction = FALSE;
        OPCODE(ENCODE_D3D10_SB_OPCODE_TYPE(D3D10_SB_OPCODE_DCL_INDEX_RANGE));
        EmitOperand(COperandDst(D3D10_SB_OPERAND_TYPE_OUTPUT, RegIndex, WriteMask));
        FUNC((UINT)Count);
        ENDINSTRUCTION();
    }

    // Emit a temp registers ( r0...r(n-1) ) declaration
    void EmitTempsDecl(UINT NumTemps)
    {
        m_bExecutableInstruction = FALSE;
        OPCODE(ENCODE_D3D10_SB_OPCODE_TYPE(D3D10_SB_OPCODE_DCL_TEMPS));
        FUNC((UINT)NumTemps);
        ENDINSTRUCTION();
    }

    // Emit an indexable temp register (x#) declaration
    void EmitIndexableTempDecl(UINT TempNumber, UINT RegCount, UINT ComponentCount )
    {
        m_bExecutableInstruction = FALSE;
        OPCODE(ENCODE_D3D10_SB_OPCODE_TYPE(D3D10_SB_OPCODE_DCL_INDEXABLE_TEMP));
        FUNC((UINT)TempNumber);
        FUNC((UINT)RegCount);
        FUNC((UINT)ComponentCount);
        ENDINSTRUCTION();
    }

    // Emit a constant buffer (cb#) declaration
    void EmitConstantBufferDecl(UINT RegIndex, UINT Size, // size 0 means unknown/any size
                                D3D10_SB_CONSTANT_BUFFER_ACCESS_PATTERN AccessPattern)
    {
        m_bExecutableInstruction = FALSE;
        OPCODE( ENCODE_D3D10_SB_OPCODE_TYPE(D3D10_SB_OPCODE_DCL_CONSTANT_BUFFER) |
                ENCODE_D3D10_SB_D3D10_SB_CONSTANT_BUFFER_ACCESS_PATTERN(AccessPattern));
        EmitOperand(COperand2D(D3D10_SB_OPERAND_TYPE_CONSTANT_BUFFER, RegIndex, Size));
        ENDINSTRUCTION();
    }

    // Emit Immediate Constant Buffer (icb) declaration
    void EmitImmediateConstantBufferDecl(UINT Num4Tuples, const UINT* pImmediateConstantBufferData)
    {
        m_bExecutableInstruction = FALSE;
        EmitCustomData( D3D10_SB_CUSTOMDATA_DCL_IMMEDIATE_CONSTANT_BUFFER,
                        4*Num4Tuples /*2 UINTS will be added during encoding */,
                        pImmediateConstantBufferData);
    }

    // Emit a GS input primitive declaration
    void EmitGSInputPrimitiveDecl(D3D10_SB_PRIMITIVE Primitive)
    {
        m_bExecutableInstruction = FALSE;
        OPCODE(ENCODE_D3D10_SB_OPCODE_TYPE(D3D10_SB_OPCODE_DCL_GS_INPUT_PRIMITIVE) |
               ENCODE_D3D10_SB_GS_INPUT_PRIMITIVE(Primitive));
        ENDINSTRUCTION();
    }

    // Emit a GS output topology declaration
    void EmitGSOutputTopologyDecl(D3D10_SB_PRIMITIVE_TOPOLOGY Topology)
    {
        m_bExecutableInstruction = FALSE;
        OPCODE(ENCODE_D3D10_SB_OPCODE_TYPE(D3D10_SB_OPCODE_DCL_GS_OUTPUT_PRIMITIVE_TOPOLOGY) |
               ENCODE_D3D10_SB_GS_OUTPUT_PRIMITIVE_TOPOLOGY(Topology));
        ENDINSTRUCTION();
    }

    // Emit GS Maximum Output Vertex Count declaration
    void EmitGSMaxOutputVertexCountDecl(UINT Count)
    {
        m_bExecutableInstruction = FALSE;
        OPCODE(ENCODE_D3D10_SB_OPCODE_TYPE(D3D10_SB_OPCODE_DCL_MAX_OUTPUT_VERTEX_COUNT));
        FUNC((UINT)Count);
        ENDINSTRUCTION();
    }
    // Emit global flags declaration
    void EmitGlobalFlagsDecl(UINT Flags)
    {
        m_bExecutableInstruction = FALSE;
        OPCODE(ENCODE_D3D10_SB_OPCODE_TYPE(D3D10_SB_OPCODE_DCL_GLOBAL_FLAGS) |
               ENCODE_D3D10_SB_GLOBAL_FLAGS(Flags));
        ENDINSTRUCTION();
    }

    // Emit an instruction. Custom-data is not handled by this function.
    void EmitInstruction(const CInstruction& instruction);
    // Emit an operand
    void EmitOperand(const COperandBase& operand);
    // Emit an instruction without operands
    void Emit(UINT OpCode)
    {
        OPCODE(OpCode);
        ENDINSTRUCTION();
    }

    void EmitCustomData( D3D10_SB_CUSTOMDATA_CLASS CustomDataClass,
                         UINT SizeInUINTs /*2 UINTS will be added during encoding */,
                         const UINT* pCustomData)
    {
        if (SUCCEEDED(m_Status))
        {
            if( ((m_Index + SizeInUINTs) < m_Index) ||  // wrap
                 (SizeInUINTs > 0xfffffffd) )           // need to add 2, also 0xffffffff isn't caught above
            {
                m_Status = E_OUTOFMEMORY;
            }

            UINT FullSizeInUINTs = SizeInUINTs + 2; // include opcode and size
            if( m_Index + FullSizeInUINTs >= m_BufferSize )
            {
                Reserve(FullSizeInUINTs);
            }

            if (SUCCEEDED(m_Status))
            {
                if (m_Index < m_BufferSize)
                    m_dwFunc[m_Index++] = ENCODE_D3D10_SB_CUSTOMDATA_CLASS(CustomDataClass);
                if (m_Index < m_BufferSize)
                    m_dwFunc[m_Index++] = FullSizeInUINTs;
                if (m_Index < m_BufferSize)
                    memcpy(&m_dwFunc[m_Index],pCustomData,sizeof(UINT)*SizeInUINTs);

               SHADER_CONV_ASSERT((m_Index + SizeInUINTs) <= m_BufferSize);
                m_Index += SizeInUINTs;
            }
        }
    }

    // Returns number of executable instructions in the current shader
    UINT GetNumExecutableInstructions() {return m_NumExecutableInstructions;}

    void EmitBinary(CONST DWORD*, DWORD);

    struct SnapShot
    {
        UINT    Index;
        UINT    StartOpIndex;
        UINT    StatementIndex;
        UINT    NumExecutableInstructions;
        bool    ExecutableInstruction;
    };

    SnapShot SnapShotState()
    {
        SnapShot Ret;

        Ret.Index                     = m_Index;
        Ret.StartOpIndex              = m_StartOpIndex;
        Ret.StatementIndex            = m_StatementIndex;
        Ret.NumExecutableInstructions = m_NumExecutableInstructions;
        Ret.ExecutableInstruction     = m_bExecutableInstruction;

        return Ret;
    }

    void RestoreState(const SnapShot& Token)
    {
       SHADER_CONV_ASSERT(Token.Index <= m_BufferSize);

        m_Index                     = Token.Index;
        m_StartOpIndex              = Token.StartOpIndex;
        m_StatementIndex            = Token.StatementIndex;
        m_NumExecutableInstructions = Token.NumExecutableInstructions;
        m_bExecutableInstruction    = Token.ExecutableInstruction;
    }

    UINT InstructionCount()
    {
        return m_NumExecutableInstructions;
    }

protected:
    void OPCODE(UINT x)
    {
        if (SUCCEEDED(m_Status))
        {
            if (m_Index < m_BufferSize)
            {
                m_dwFunc[m_Index] = x;
                m_StartOpIndex = m_Index++;
            }
            if (m_Index >= m_BufferSize)
                Reserve(1024);
        }
    }
    // Should be called after end of each instruction
    void ENDINSTRUCTION()
    {
        if (m_StartOpIndex < m_Index)
        {
            m_dwFunc[m_StartOpIndex] |= ENCODE_D3D10_SB_TOKENIZED_INSTRUCTION_LENGTH(m_Index - m_StartOpIndex);
            Reserve(MAX_INSTRUCTION_LENGTH);

            if (SUCCEEDED(m_Status))
            {
                m_StatementIndex++;
                if (m_bExecutableInstruction)
                    m_NumExecutableInstructions++;
                m_bExecutableInstruction = true;
            }
        }
    }
    void FUNC(UINT x)
    {
        if (SUCCEEDED(m_Status))
        {
            if (m_Index < m_BufferSize)
                m_dwFunc[m_Index++] = x;
            if (m_Index >= m_BufferSize)
                Reserve(1024);
        }
    }
    // Prepare assembler for a new shader
    void Reset()
    {
        m_Index = 0;
        m_Status = S_OK;
        m_StartOpIndex = 0;
        m_StatementIndex = 1;
        m_NumExecutableInstructions = 0;
        m_bExecutableInstruction = TRUE;
    }
    // Reserve SizeInUINTs UINTs in the m_dwFunc array
    void Reserve(UINT SizeInUINTs)
    {
        if (SUCCEEDED(m_Status))
        {
            if( m_Index + SizeInUINTs < m_Index ) // overflow (prefix)
            {
                m_Status = E_OUTOFMEMORY;
                return;
            }
            if (m_BufferSize < (m_Index + SizeInUINTs))
            {
                UINT NewSize = m_BufferSize + SizeInUINTs + 1024;
                UINT* pNewBuffer = (UINT*)new UINT[NewSize];

                if (pNewBuffer == NULL)
                {
                    m_Status = E_OUTOFMEMORY;
                    return;
                }
                memcpy(pNewBuffer, m_dwFunc, sizeof(UINT)*m_Index);
                delete(m_dwFunc);

                m_dwFunc = pNewBuffer;
                m_BufferSize = NewSize;
            }
        }
    }
    // Buffer where the binary representation is built
    // Had to use xcount as it doesn't realize that when m_Index is > m_BufferSize then in OPCODE and FUNC the buffer is expanded
    __field_xcount_part(m_BufferSize, m_Index) UINT*  m_dwFunc;
    // Index where to place the next token in the m_dwFunc array
    UINT    m_Index;
    // Index of the start of the current instruction in the m_dwFunc array
    UINT    m_StartOpIndex;
    // Current buffer size in UINTs
    UINT    m_BufferSize;
    // Current statement index of the current vertex shader
    UINT    m_StatementIndex;
    // Number of executable instructions in the shader
    UINT    m_NumExecutableInstructions;
    // Current error code while writing out shader (S_OK, E_INVALIDARG or E_OUTOFMEMORY)
    HRESULT m_Status;
    // "true" when the current instruction is executable
    bool    m_bExecutableInstruction;
};

//*****************************************************************************
//
//  CShaderCodeParser
//
//*****************************************************************************

struct ParserPositionToken
{
    CShaderToken* Inst;
    UINT          InstCount;
};

class CShaderCodeParser
{
public:
    CShaderCodeParser():
        m_pShaderCode(NULL),
        m_pOriginalShaderCode(NULL),
        m_pCurrentToken(NULL),
        m_pShaderEndToken(NULL),
        m_NumParsedInstructions(0)
    {
    }
    CShaderCodeParser(CONST CShaderToken* pBuffer):
        m_pShaderCode(NULL),
        m_pOriginalShaderCode(NULL),
        m_pCurrentToken(NULL),
        m_pShaderEndToken(NULL),
        m_NumParsedInstructions(0)
    {
        SetShader(pBuffer);
    }
    ~CShaderCodeParser()    {}
    void SetShader(CONST CShaderToken* pBuffer);
    D3D10_SB_OPCODE_TYPE PeekNextInstructionOpCode();
    __checkReturn HRESULT ParseInstruction(CInstruction* pInstruction);
    __checkReturn HRESULT ParseOperand(COperandBase* pOperand);
    bool EndOfShader() {return m_pCurrentToken >= m_pShaderEndToken;}
    D3D10_SB_TOKENIZED_PROGRAM_TYPE ShaderType();
    UINT ShaderMinorVersion();
    UINT ShaderMajorVersion();
    UINT ShaderLengthInTokens();
    ParserPositionToken GetCurrentToken();
    UINT CurrentTokenOffsetInBytes();
    void SetCurrentToken(ParserPositionToken In);
    D3D10_SB_OPCODE_TYPE CurrentOpcode(); // Returns the OpCode for the next instruction to be parsed
    DWORD CurrentInstructionLength(); // Number of DWORDS in the current instruction
    void Advance(UINT InstructionSize);
    UINT ParsedInstructionCount() {return m_NumParsedInstructions;}
protected:
    CShaderToken*   m_pCurrentToken;
    CShaderToken*   m_pShaderCode;
    CShaderToken*   m_pOriginalShaderCode;
    // Points to the last token of the current shader
    CShaderToken*   m_pShaderEndToken;

    UINT            m_NumParsedInstructions;
};


```

`ShaderConverter/Inc/ShaderConv.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/*==========================================================================;
*
*  Copyright (C) Microsoft Corporation.  All Rights Reserved.
*
*  Header Definitions for the Shader Translator
*
****************************************************************************/
#pragma once
namespace ShaderConv
{

#define Check(a) {if(!(a)) {DebugBreak();}}

#define D3DDECLUSAGE_VFACE (D3DDECLUSAGE_SAMPLE+1)
#define D3DDECLUSAGE_VPOS  (D3DDECLUSAGE_VFACE+1)
#define D3DDECLUSAGE_CLIPDISTANCE  (D3DDECLUSAGE_VPOS+1)
#define D3DDECLUSAGE_POINTSPRITE  (D3DDECLUSAGE_CLIPDISTANCE+1)

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
enum eConstants
{
    //--
    MAX_CLIPLANES       = 6,
    MAX_TEXCOORDS       = 8,

    // VS input registers
    MAX_VS_INPUT_REGS   = 16,
    MAX_VS_TEMP_REGS    = 32,

    // VS output registers
    MAX_VS_OUTPUT_REGS  = 12,
    MAX_VS_COLOR_REGS   = 2,    // vs 1.x & 2.0
    MAX_VS_TEXCOORD_REGS= MAX_TEXCOORDS,    // vs 1.x & 2.0
    MAX_VS_SAMPLER_REGS = 4,    // vs 3.0

    // PS input registers
    MAX_PS_INPUT_REGS   = 10,    // ps 3.0
    MAX_PS_COLORIN_REGS = 2,    // ps 2.0
    MAX_PS_TEXCOORD_REGS= MAX_TEXCOORDS,    // ps 2.0
    MAX_PS_TEMP_REGS    = 32,
    MAX_PS1X_TEXTURE_REGS=4,    // ps 1.x
    MAX_PS1X_SAMPLER_REGS=8,    // ps 1.x
    MAX_PS_SAMPLER_REGS = 16,   // ps 2.0+

    // PS output registers
    MAX_PS_COLOROUT_REGS= 4,
    MAX_PS_DEPTHOUT_REGS= 1,    // ps 2.0+

    DEPTH_OUTPUT_MASK = 1 << MAX_PS_COLOROUT_REGS,

    // Common registers
    MAX_INPUT_REGS      = ( MAX_VS_INPUT_REGS > MAX_PS_INPUT_REGS ) ? MAX_VS_INPUT_REGS : MAX_PS_INPUT_REGS,
    MAX_TEMP_REGS       = ( MAX_VS_TEMP_REGS > MAX_PS_TEMP_REGS ) ? MAX_VS_TEMP_REGS : MAX_PS_TEMP_REGS,
    MAX_SAMPLER_REGS    = ( MAX_VS_SAMPLER_REGS > MAX_PS_SAMPLER_REGS ) ? MAX_VS_SAMPLER_REGS : MAX_PS_SAMPLER_REGS,

    //--
    INVALID_INDEX       = 0xff,

    //--
    __D3DSP_WRITEMASK_MASK  = 0x000F0000,
    __D3DSP_WRITEMASK_SHIFT = 16,

    //--
    MAX_VS_CONSTANTSF    = 256,
    MAX_VS_CONSTANTSI    = 16,
    MAX_VS_CONSTANTSB    = 16,

    //--
    MAX_PS_CONSTANTSF    = 224,
    MAX_PS_CONSTANTSI    = 16,
    MAX_PS_CONSTANTSB    = 16,

    //--
    TCIMASK_PASSTHRU     = 0x76543210,

};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
struct VSCBExtension
{
    enum
    {
        VIEWPORTSCALE = 0,
        POINTSIZE     = 1,
        CLIPPLANE0    = 2,
        SCREENTOCLIPOFFSET = 8,
        SCREENTOCLIPSCALE = 9,
    };

    FLOAT vViewPortScale[4]; // { 1/vw, -1/vh, 0, 0 }
    FLOAT vPointSize[4];     // { psize, min, max, 0 }
    FLOAT vClipPlanes[MAX_CLIPLANES][4];
    FLOAT vScreenToClipOffset[4];
    FLOAT vScreenToClipScale[4];
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
struct GSCBExtension
{
    enum
    {
        POINTSIZE = 0,
    };

    FLOAT vPointSize[4]; // { psize, min, max, 0 }
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
struct PSCBExtension
{
    enum
    {
        FOGCOLOR_XYZ,
        ALPHATEST_W  = FOGCOLOR_XYZ,
        FOGSTART_X,
        FOGEND_Y     = FOGSTART_X,
        FOGDISTINV_Z = FOGSTART_X,
        FOGDENSITY_W = FOGSTART_X,
    };

    FLOAT   vFogColor[3];
    FLOAT   fAlphaRef;

    FLOAT   fFogStart;
    FLOAT   fFogEnd;
    FLOAT   fFogDistInv;
    FLOAT   fFogDensity;
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
struct PSCBExtension2
{
    enum
    {
        BUMPENVMAT0,
        BUMPENVMAT1,
        BUMPENVMAT2,
        BUMPENVMAT3,
        BUMPENVMAT4,
        BUMPENVMAT5,
        BUMPENVMAT6,
        BUMPENVMAT7,
        BUMPENVL0,
        BUMPENVL1,
        BUMPENVL2,
        BUMPENVL3,
        BUMPENVL4,
        BUMPENVL5,
        BUMPENVL6,
        BUMPENVL7,
    };

    FLOAT vBumpEnvMat[8][4];
    FLOAT vBumpEnvL[8][4];
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
struct PSCBExtension3
{
    enum
    {
        COLORKEY0,
        COLORKEY1,
        COLORKEY2,
        COLORKEY3,
        COLORKEY4,
        COLORKEY5,
        COLORKEY6,
        COLORKEY7,
    };

    FLOAT vColorKey[8][4];
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
enum eConstantBuffers
{
    CB_FLOAT    = 0,
    CB_INT      = 1,
    CB_BOOL     = 2,
    CB_VS_EXT   = 3,
    CB_PS_EXT   = 3,
    CB_PS_EXT2  = 4,
    CB_PS_EXT3  = 5,
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
enum TEXTURETYPE
{
    TEXTURETYPE_UNKNOWN,
    TEXTURETYPE_2D,
    TEXTURETYPE_CUBE,
    TEXTURETYPE_VOLUME,
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
struct SamplerInfo
{
    union
    {
        BYTE Value;
        struct
        {
            BYTE TextureType  : 2;
            BYTE TexCoordWrap : 4;
        };
    };

    // Initially set all texture types to TEXTURETYPE_2D - we can't go with TEXTURETYPE_UNKNOWN
    // because the shader converter needs a valid texture type for the shader declaration, even
    // when a null resource is bound.
    SamplerInfo() : TextureType( TEXTURETYPE_2D ), TexCoordWrap( 0 )
    {
        C_ASSERT( sizeof( SamplerInfo ) == sizeof( Value ) );
    }
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
enum SAMPLER_SWIZZLE
{
    SAMPLER_SWIZZLE_NONE = 0,
    SAMPLER_SWIZZLE_RRRA = 1,   // For luminance texture formats.
    SAMPLER_SWIZZLE_RAAA = 2,   // For single channel texture formats.
    SAMPLER_SWIZZLE_RGAA = 3,   // For two channel texture formats.
    
    // Two bits of state per sampler.
    SAMPLER_SWIZZLE_BITS = 2,
    SAMPLER_SWIZZLE_MASK = 3,
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
struct RasterStates
{
    SamplerInfo PSSamplers[D3DHAL_SAMPLER_MAXSAMP];
    UINT TCIMapping;

    union
    {
        struct
        {
            UINT Flags1;
            UINT Flags2;
            UINT Flags3;
        };

        struct
        {
            UINT ProjectedTCsMask   : MAX_TEXCOORDS;
            UINT UserClipPlanes     : MAX_CLIPLANES;
            UINT FillMode           : 2;
            UINT ShadeMode          : 2;
            UINT PrimitiveType      : 3;
            UINT AlphaFunc          : 4;
            UINT FogEnable          : 1;
            UINT FogTableMode       : 2;
            UINT WFogEnable         : 1;
            UINT AlphaTestEnable    : 1;
            UINT PointSizeEnable    : 1;
            UINT PointSpriteEnable  : 1;
            UINT ColorKeyEnable     : 1;
            UINT ColorKeyBlendEnable: 1;
            UINT ColorKeyTSSDisable : MAX_TEXCOORDS;
            UINT HasTLVertices      : 1;
            UINT HardwareShadowMappingRequiredPS : MAX_PS_SAMPLER_REGS;
            UINT HardwareShadowMappingRequiredVS : MAX_VS_SAMPLER_REGS;
            UINT SwapRBOnOutputMask : MAX_PS_COLOROUT_REGS;
        };
    };

    UINT SamplerSwizzleMask;

    RasterStates() :
        TCIMapping( 0 ),
        Flags1( 0 ),
        Flags2( 0 ),
        Flags3( 0 ),
        SamplerSwizzleMask( 0 )
    {
        static_assert( sizeof( RasterStates ) == sizeof( PSSamplers ) +
                                                 sizeof( TCIMapping ) +
                                                 sizeof( Flags1 ) +
                                                 sizeof( Flags2 ) +
                                                 sizeof( Flags3 ) +
                                                 sizeof( SamplerSwizzleMask ), "Struct packing broke." );
    }
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
struct VSInputDecl
{
    enum { None, NeedsIntToFloatConversion, UDEC3, DEC3N };
    WORD Usage      : 4;
    WORD UsageIndex : 4;
    WORD RegIndex   : 4;
    WORD IsTransformedPosition : 1;
    WORD InputConversion : 2;
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
struct VSInputDecls
{
public:

    union
    {
        UINT Flags;
        struct
        {
            UINT Position   : 1;
            UINT BlendWeight: 1;
            UINT BlendIndices:1;
            UINT Normal     : 1;
            UINT PSize      : 1;
            UINT TexCoord   : 1;
            UINT Tangent    : 1;
            UINT Binormal   : 1;
            UINT TessFactor : 1;
            UINT PositionT  : 1;
            UINT Color      : 1;            
            UINT Fog        : 1;
            UINT Depth      : 1;
            UINT Sample     : 1;
        };
    };

    enum { INVALID_INDEX = -1 };

    VSInputDecls(UINT maxAllowableEntries)
    {
        Flags = 0;
        m_maxAllowableEntries = maxAllowableEntries;
    }

    bool operator==( const VSInputDecls& rhs ) const
    {
        return Flags == rhs.Flags
            && m_maxAllowableEntries == rhs.m_maxAllowableEntries
            && m_entries.size() == rhs.m_entries.size()
            && (0 == memcmp( m_entries.data(), rhs.m_entries.data(), m_entries.size() * sizeof( VSInputDecl ) ));
    }

    bool operator!=( const VSInputDecls& rhs ) const
    {
        return !(*this==rhs);
    }

    const VSInputDecl& operator[] ( UINT index ) const
    {
        Check( index < GetSize() );
        return m_entries[index];
    }

    VSInputDecl& operator[] ( UINT index )
    {
        Check( index < GetSize());
        return m_entries[index];
    }

    UINT GetSize() const
    {
        return static_cast<UINT>(m_entries.size());
    }

    void AddDecl(UINT usage, UINT usageIndex, UINT regIndex, UINT isTransformedPosition = 0, UINT InputConversion = 0)
    {
        if (m_entries.size() + 1 > m_maxAllowableEntries)
        {
            Check(false);
            return;
        }

        VSInputDecl entry;
        entry.Usage = usage;
        entry.UsageIndex = usageIndex;
        entry.RegIndex = regIndex;
        entry.IsTransformedPosition = isTransformedPosition;
        entry.InputConversion = InputConversion;
        m_entries.push_back(entry);

        this->Flags |= (1 << usage);
    }

    UINT FindRegisterIndex( UINT usage, UINT usageIndex ) const
    {
        const VSInputDecl *pDecl = FindInputDecl(usage, usageIndex);

        return pDecl ? pDecl->RegIndex : INVALID_INDEX;
    }

    const VSInputDecl *FindInputDecl(UINT usage, UINT usageIndex) const
    {
        for (size_t i = 0, n = m_entries.size(); i < n; ++i)
        {
            if (m_entries[i].Usage == usage &&
                m_entries[i].UsageIndex == usageIndex)
            {
                return &m_entries[i];
            }
        }

        return nullptr;
    }


protected:
    std::vector<VSInputDecl> m_entries;
    UINT m_maxAllowableEntries;
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
struct VSOutputDecl
{
    UINT Usage      : 5;
    UINT UsageIndex : 4;
    UINT RegIndex   : 4;
    UINT WriteMask  : 4;    
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
struct VSOutputDecls
{
public:  

    enum {
        MAX_SIZE_VS   = 1 + (MAX_VS_OUTPUT_REGS - 1) * 4, // Removed 1 for Position
        MAX_SIZE_PS   = MAX_PS_INPUT_REGS * 4,
        MAX_SIZE      = (MAX_SIZE_VS > MAX_SIZE_PS) ? MAX_SIZE_VS : MAX_SIZE_PS,
        INVALID_INDEX = MAX_SIZE,
    };

    union
    {
        UINT Flags;
        struct
        {
            UINT Position  : 1;
            UINT Colors    : 2;
            UINT TexCoords : MAX_SAMPLER_REGS;
            UINT Fog       : 1;
            UINT PointSize : 1;
            UINT vFace     : 1;
            UINT vPos      : 1;
        };
    }; 

    union 
    {
        UINT64 CentroidMask : MAX_SIZE;
    };

    VSOutputDecls()
    {   
        this->CentroidMask = 0;
        this->Flags = 0;        
        m_size = 0;
        memset(m_entries, 0, sizeof(m_entries));
    }  

    VSOutputDecls(const VSOutputDecls& rhs) 
    {
        *this = rhs;
    }

    void operator=(const VSOutputDecls& rhs)
    {
        this->Flags = rhs.Flags;     
        this->CentroidMask = rhs.CentroidMask;        
        memcpy(m_entries, &rhs.m_entries, rhs.m_size * sizeof(VSOutputDecl));        
        m_size = rhs.m_size;       
    } 

    bool operator==(const VSOutputDecls& rhs) const
    {
        return (this->Flags == rhs.Flags)
            && (this->CentroidMask == rhs.CentroidMask)
            && (m_size == rhs.m_size) 
            && ((0 == rhs.m_size) 
             || (0 == memcmp(m_entries, &rhs.m_entries, rhs.m_size * sizeof(VSOutputDecl))));
    } 

    const VSOutputDecl& operator[](UINT index) const
    {
        Check(index < m_size);
        return m_entries[index];
    }

    VSOutputDecl& operator[](UINT index)
    {
        Check(index < m_size);
        return m_entries[index];
    }

    UINT GetSize() const
    {
        return m_size;
    }
    
    void AddDecl(UINT usage, UINT usageIndex, UINT regIndex, UINT writeMask, bool bCentroid = false)
    {
        // Should never hit a vertex declaration bigger than MAX_SIZE
        if (m_size >= MAX_SIZE)
        {
            Check(false);
            return;
        }

        {
            // Compress the writemask
            writeMask = (writeMask & __D3DSP_WRITEMASK_MASK) >> __D3DSP_WRITEMASK_SHIFT;

            // First check if the entry already exists
            for (UINT i = 0, n = m_size; i < n; ++i)
            {
                if ((m_entries[i].Usage == usage)
                    && (m_entries[i].UsageIndex == usageIndex))
                {
                    // Ensure unique register assignment
                    //SHADER_CONV_ASSERT(m_entries[i].RegIndex == regIndex);

                    // Extend to the existing writemask
                    m_entries[i].WriteMask |= writeMask;
                    return;
                }
            }

            const UINT index = m_size++;
            Check(index < _countof(m_entries));

            m_entries[index].Usage = usage;
            m_entries[index].UsageIndex = usageIndex;
            m_entries[index].RegIndex = regIndex;
            m_entries[index].WriteMask = writeMask;

            this->CentroidMask |= bCentroid ? (((__int64)1) << index) : 0;

            switch (usage)
            {
            case D3DDECLUSAGE_POSITION:
            case D3DDECLUSAGE_POSITIONT:
                if (0 == usageIndex)
                {
                    this->Position = 1;
                }
                break;

            case D3DDECLUSAGE_COLOR:
                if (usageIndex <= 1)
                {
                    this->Colors |= (1 << usageIndex);
                }
                break;

            case D3DDECLUSAGE_TEXCOORD:
                //SHADER_CONV_ASSERT(usageIndex < MAX_SAMPLER_REGS);
                this->TexCoords |= (1 << usageIndex);
                break;

            case D3DDECLUSAGE_FOG:
                if (0 == usageIndex)
                {
                    this->Fog = 1;
                }
                break;

            case D3DDECLUSAGE_PSIZE:
                if (0 == usageIndex)
                {
                    this->PointSize = 1;
                }
                break;

            case D3DDECLUSAGE_VFACE:
                this->vFace = 1;
                break;

            case D3DDECLUSAGE_VPOS:
                this->vPos = 1;
                break;
            }
        }
    }
    
    void AddDecl(const VSOutputDecl& decl)
    {
        this->AddDecl(decl.Usage, decl.UsageIndex, decl.RegIndex, decl.WriteMask << __D3DSP_WRITEMASK_SHIFT);
    }

    UINT FindRegisterIndex(UINT usage, UINT usageIndex) const
    {
        const VSOutputDecl *pDecl = FindOutputDecl(usage, usageIndex);

        return pDecl ? pDecl->RegIndex : INVALID_INDEX;
    }

    const VSOutputDecl *FindOutputDecl(UINT usage, UINT usageIndex) const
    {
        for (size_t i = 0, n = m_size; i < n; ++i)
        {
            if (m_entries[i].Usage == usage &&
                m_entries[i].UsageIndex == usageIndex)
            {
                return &m_entries[i];
            }
        }

        return nullptr;
    }

protected:    

    VSOutputDecl m_entries[MAX_SIZE];    
    _Field_range_(0, MAX_SIZE) UINT m_size;
};

class InputRegister
{
public:
    enum RegisterType { Undeclared, Input, Temp };

    InputRegister(BYTE nReg, RegisterType type, BYTE nWriteMask = D3DSP_WRITEMASK_ALL >> __D3DSP_WRITEMASK_SHIFT) : m_Reg(nReg), m_Type(type), m_WriteMask(nWriteMask) {}
    InputRegister() : InputRegister(INVALID_INDEX, Undeclared, 0) {}

    RegisterType GetType() const { return m_Type; }

    BYTE Reg() const { return m_Reg; }
    BYTE WriteMask() const { return m_WriteMask; }
private:
    RegisterType m_Type;
    BYTE m_Reg;
    BYTE m_WriteMask;
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
struct InputRegs
{
    BYTE s[MAX_SAMPLER_REGS];
    InputRegister v[MAX_INPUT_REGS];
    BYTE r[MAX_TEMP_REGS];

    union
    {
        struct // Pixel shader specifics
        {
            BYTE _t[MAX_PS1X_TEXTURE_REGS];
        };
        struct // Vertex shader specifics
        {
            BYTE a0;
        };
    };

    BYTE aL;
    BYTE p0;

    InputRegs()
    {
        aL = p0 = INVALID_INDEX;
        memset(_t, INVALID_INDEX, sizeof(_t));
        memset(s, INVALID_INDEX, sizeof(s));
        memset(r, INVALID_INDEX, sizeof(r));
    }
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
struct OutputRegs
{
    union
    {
        // Vertex shader ouput registers
        struct
        {
            BYTE O[MAX_VS_OUTPUT_REGS];
        };

        // Pixel shader ouput registers
        struct
        {
            BYTE oC[MAX_PS_COLOROUT_REGS];
            BYTE oDepth;
        };
    };

    OutputRegs()
    {
        memset( this, INVALID_INDEX, sizeof( OutputRegs ) );
    }
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
struct PSUsageFlags
{
    union
    {
        UINT Value;
        struct
        {
            UINT BumpEnvMat       : 1;
            UINT ProjectedTCsMask : 8;
            UINT IndexableInputs  : 1;
        };
    };

    PSUsageFlags() : Value( 0 )
    {
        C_ASSERT( sizeof( PSUsageFlags ) == sizeof( Value ) );
    }
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
struct VSUsageFlags
{
    union
    {
        UINT Value;
        struct
        {
            UINT OutputRegsAddressing : 1;
        };
    };

    VSUsageFlags() : Value( 0 )
    {
        C_ASSERT( sizeof( VSUsageFlags ) == sizeof( Value ) );
    }
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
enum eDirtyConsts
{
    DIRTY_CONSTSF = 1 << 0,
    DIRTY_CONSTSI = 1 << 1,
    DIRTY_CONSTSB = 1 << 2,

    DIRTY_CONSTS_ALL = ( DIRTY_CONSTSF |
                         DIRTY_CONSTSI |
                         DIRTY_CONSTSB ),
};

struct ByteCode
{
    ByteCode() : m_pByteCode(nullptr), m_byteCodeSize(0){}

    void* m_pByteCode;
    size_t m_byteCodeSize;
};

struct ShaderConst
{
    ShaderConst() {}

    ShaderConst(UINT regIndex, const FLOAT value[4])
    {
        this->RegIndex = regIndex;
        this->fValue[0] = value[0];
        this->fValue[1] = value[1];
        this->fValue[2] = value[2];
        this->fValue[3] = value[3];
    }

    ShaderConst(UINT regIndex, const INT value[4])
    {
        this->RegIndex = regIndex;
        this->iValue[0] = value[0];
        this->iValue[1] = value[1];
        this->iValue[2] = value[2];
        this->iValue[3] = value[3];
    }

    ShaderConst(UINT regIndex, const BOOL value)
    {
        this->RegIndex = regIndex;
        this->bValue = value;
    }

    UINT  RegIndex;

    union
    {
        struct
        {
            UINT Value[4];
        };
        struct
        {
            FLOAT fValue[4];
        };
        struct
        {
            INT iValue[4];
        };
        struct
        {
            BOOL  bValue;
        };
    };
};

//--
typedef std::vector<ShaderConst> ShaderConsts;

enum ShaderSettings
{
    AnythingTimes0Equals0 = 0x1
};

struct ConvertShaderArgs
{
    enum class SHADER_TYPE
    {
        SHADER_TYPE_VERTEX,
        SHADER_TYPE_PIXEL
    };

    ConvertShaderArgs(UINT d3dAPIVersionm, UINT d3dShaderSettings, const RasterStates& raster) :
        apiVersion(d3dAPIVersionm),
        shaderSettings(d3dShaderSettings),
        rasterStates(raster),
        convertedByteCode(),
        legacyByteCode(),
        maxFloatConstsUsed(0),
        maxIntConstsUsed(0),
        maxBoolConstsUsed(0)
    {}

    SHADER_TYPE type;
    UINT shaderSettings;
    UINT apiVersion;
    _In_ const RasterStates& rasterStates;
    _In_ VSOutputDecls* pPsInputDecl;
    _Inout_ VSInputDecls* pVsInputDecl;
    _In_ ByteCode legacyByteCode;
    _Out_ VSOutputDecls *pVsOutputDecl;
    _Out_ ByteCode convertedByteCode;

    _Out_ UINT8 outputRegistersMask;

    _Out_ ShaderConsts m_inlineConsts[3];

    _Out_ UINT maxFloatConstsUsed;
    _Out_ UINT maxIntConstsUsed;
    _Out_ UINT maxBoolConstsUsed;

    _Out_ UINT totalInstructionsEmitted;
    _Out_ UINT totalExtraInstructionsEmitted;
    _Out_ std::vector<VSOutputDecl> AddedSystemSemantics;
};

struct ConvertTLShaderArgs
{
    ConvertTLShaderArgs(UINT d3dAPIVersion, UINT d3dShaderSettings, VSInputDecls& inputDecl, VSOutputDecls &outputDecl) :
        apiVersion(d3dAPIVersion),
        shaderSettings(d3dShaderSettings),
        vsInputDecl(inputDecl),
        vsOutputDecl(outputDecl),
        maxFloatConstsUsed(0),
        maxIntConstsUsed(0),
        maxBoolConstsUsed(0)
    {}

    UINT apiVersion;
    _In_ UINT shaderSettings;

    _In_ VSInputDecls& vsInputDecl;
    _Out_ ByteCode convertedByteCode;
    _Out_ VSOutputDecls& vsOutputDecl;

    _Out_ UINT maxFloatConstsUsed;
    _Out_ UINT maxIntConstsUsed;
    _Out_ UINT maxBoolConstsUsed;

    _Out_ UINT totalInstructionsEmitted;
    _Out_ UINT totalExtraInstructionsEmitted;
};

struct CreateGeometryShaderArgs
{
    CreateGeometryShaderArgs(UINT apiVersion, UINT d3dShaderSettings, VSOutputDecls& vsOutputDecls, VSOutputDecls *pGSOutputDecls, const RasterStates& rasterStates) :
        m_ApiVersion(apiVersion),
        m_ShaderSettings(d3dShaderSettings),
        m_VsOutputDecls(vsOutputDecls),
        m_pGsOutputDecls(pGSOutputDecls),
        m_RasterStates(rasterStates),
        m_GSByteCode()
    {};

    _In_ UINT m_ShaderSettings;
    _In_ UINT m_ApiVersion;
    _In_ VSOutputDecls& m_VsOutputDecls;
    _Out_ VSOutputDecls *m_pGsOutputDecls;
    _In_ const RasterStates& m_RasterStates;

    _Out_ ByteCode m_GSByteCode;
};

class ITranslator;
struct ShaderConverterAPI
{
    ShaderConverterAPI() = default;
    ~ShaderConverterAPI();

    HRESULT ConvertShader(ConvertShaderArgs& args);
    HRESULT ConvertTLShader(ConvertTLShaderArgs& args);
    HRESULT CreateGeometryShader(CreateGeometryShaderArgs& args);

    static void CleanUpConvertedShader(ByteCode& byteCode);

private:
    ITranslator* m_pTranslator = nullptr;
};

} // namespace ShaderConv
```

`ShaderConverter/Inc/ShaderConvCommon.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/*==========================================================================;
*
*  Copyright (C) Microsoft Corporation.  All rights reserved.
*
*  Common header file
*
****************************************************************************/
#pragma once

#ifndef SHADER_CONV_COMMON
#define SHADER_CONV_COMMON

#include <assert.h>
#include <cstddef>

#define SHADER_CONV_ASSERT(x) assert(x)

#define NO_DEFAULT  {__assume(0);}

#define IntMax(a,b) (((a) > (b)) ? (a) : (b))
#define IntMin(a,b) (((a) < (b)) ? (a) : (b))

#define IFC(x) {hr = (x); if (FAILED(hr)) { goto Cleanup;} }

#define IFCOOM(x) {if ((x) == NULL) {hr = E_OUTOFMEMORY; goto Cleanup;}}

#define RRETURN(x) return x;
#endif
```

`ShaderConverter/Inc/ShaderConvInternal.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#pragma once
#include "ShaderConv.h"
#include <vector>

namespace ShaderConv
{
    class IObject
    {
    public:

        virtual LONG AddRef() const = 0;
        virtual LONG Release() const = 0;

    protected:

        IObject() {}
        virtual ~IObject() {}
    };

    ///---------------------------------------------------------------------------
    /// <summary>
    /// </summary>
    ///---------------------------------------------------------------------------
    class CObject : public IObject
    {
    public:

        LONG AddRef() const;
        LONG Release() const;

    protected:

        CObject() : m_lRefCount(0) {}

        virtual ~CObject() {}

        mutable LONG m_lRefCount;
    };

    ///---------------------------------------------------------------------------
    /// <summary>
    /// </summary>
    ///---------------------------------------------------------------------------
    class CShaderDesc : public CObject
    {
    public:
        UINT GetShaderSettings() const
        {
            return m_shaderSettings;
        }

        UINT GetVersion() const
        {
            return m_version;
        }

        UINT GetMinUsedConsts(eConstantBuffers type) const
        {
            return m_minUsedConsts[type];
        }

        UINT GetMaxUsedConsts(eConstantBuffers type) const
        {
            return m_maxUsedConsts[type];
        }

        bool HasRelAddrConsts(eConstantBuffers type) const
        {
            return m_bRelAddrConsts[type];
        }

        const InputRegs& GetInputRegs() const
        {
            return m_inputRegs;
        }

        const OutputRegs& GetOutputRegs() const
        {
            return m_outputRegs;
        }

        const DWORD* GetInstructions() const
        {
            return m_pdwInstrs;
        }

        UINT GetCodeSize() const
        {
            return m_cbCodeSize;
        }

        BYTE GetNumLoopRegs() const
        {
            return m_numLoopRegs;
        }

        BYTE GetNumTempRegs() const
        {
            return m_numTempRegs;
        }

        const ShaderConsts& GetInlineConstants(eConstantBuffers type) const
        {
            return m_inlineConsts[type];
        }

        ShaderConsts&& MoveInlineConstants(eConstantBuffers type)
        {
            return std::move(m_inlineConsts[type]);
        }

        bool FindInlineConstant(eConstantBuffers type, UINT regIndex, ShaderConst* pShaderConst = NULL) const;

    protected:

        CShaderDesc() : m_pdwInstrs(NULL),
            m_cbCodeSize(0),
            m_numLoopRegs(0),
            m_numTempRegs(0),
            m_version(0)
        {
            for (UINT i = 0; i < _countof(m_minUsedConsts); ++i)
            {
                m_minUsedConsts[i] = 0xFFFFFFFF;
                m_maxUsedConsts[i] = 0;
                m_bRelAddrConsts[i] = false;
            }
        }

        virtual ~CShaderDesc()
        {
            if (m_pdwInstrs)
            {
                delete(m_pdwInstrs);
            }
        }

        void SetShaderSettings(UINT shaderSettings)
        {
            m_shaderSettings = shaderSettings;
        }

        void SetVersion(UINT version)
        {
            m_version = version;
        }

        void SetMinUsedConsts(eConstantBuffers type, UINT value)
        {
            m_minUsedConsts[type] = value;
        }

        void SetMaxUsedConsts(eConstantBuffers type, UINT value)
        {
            m_maxUsedConsts[type] = value;
        }

        void SetRelAddrConsts(eConstantBuffers type, bool bValue)
        {
            m_bRelAddrConsts[type] = bValue;
        }

        HRESULT AddInlineConstsF(UINT regIndex, const FLOAT value[4])
        {
            m_inlineConsts[CB_FLOAT].push_back(ShaderConst(regIndex * 4, value));
            return S_OK;
        }

        HRESULT AddInlineConstsI(UINT regIndex, const INT value[4])
        {
            m_inlineConsts[CB_INT].push_back(ShaderConst(regIndex * 4, value));
            return S_OK;
        }

        HRESULT AddInlineConstsB(UINT regIndex, const BOOL value)
        {
            m_inlineConsts[CB_BOOL].push_back(ShaderConst(regIndex, value));
            return S_OK;
        }

        void SetInputRegs(const InputRegs& inputRegs)
        {
            m_inputRegs = inputRegs;
        }

        void SetOutputRegs(const OutputRegs& outputRegs)
        {
            m_outputRegs = outputRegs;
        }

        void SetNumTempRegs(BYTE numTempRegs)
        {
            m_numTempRegs = numTempRegs;
        }

        void SetNumLoopRegs(BYTE numLoopRegs)
        {
            m_numLoopRegs = numLoopRegs;
        }

        HRESULT CopyInstructions(const void* pInstrs, UINT cbSize);

        ShaderConsts m_inlineConsts[3];

        UINT m_minUsedConsts[3];
        UINT m_maxUsedConsts[3];
        bool m_bRelAddrConsts[3];

        InputRegs  m_inputRegs;
        OutputRegs m_outputRegs;

        DWORD* m_pdwInstrs;
        UINT   m_cbCodeSize;

        BYTE m_numLoopRegs;
        BYTE m_numTempRegs;

        UINT m_version;
        UINT m_shaderSettings;

        friend class CTranslator;
    };

    ///---------------------------------------------------------------------------
    /// <summary>
    /// </summary>
    ///---------------------------------------------------------------------------
    class CVertexShaderDesc : public CShaderDesc
    {
    public:

        const VSInputDecls& GetInputDecls() const
        {
            return m_inputDecls;
        }

        const VSOutputDecls& GetOutputDecls() const
        {
            return m_outputDecls;
        }

        VSUsageFlags GetUsageFlags() const
        {
            return m_usageFlags;
        }

    protected:

        CVertexShaderDesc() : m_inputDecls(MAX_VS_INPUT_REGS) {}
        virtual ~CVertexShaderDesc() {}

        static HRESULT Create(CVertexShaderDesc** ppVertexShaderDesc);

        void SetInputDecls(const VSInputDecls& inputDecls)
        {
            m_inputDecls = inputDecls;
        }

        void SetOutputDecls(const VSOutputDecls& outputDecls)
        {
            m_outputDecls = outputDecls;
        }

        void SetUsageFlags(const VSUsageFlags& usageFlags)
        {
            m_usageFlags = usageFlags;
        }

        VSOutputDecls m_outputDecls;
        VSInputDecls  m_inputDecls;
        VSUsageFlags  m_usageFlags;

        friend class CTranslator;
    };

    ///---------------------------------------------------------------------------
    /// <summary>
    /// </summary>
    ///---------------------------------------------------------------------------
    class CTLVertexShaderDesc : public CObject
    {
    public:

        CTLVertexShaderDesc() : m_vsInputDecls(MAX_VS_INPUT_REGS) {}

        CTLVertexShaderDesc(const VSInputDecls& vsInputDecls, UINT shaderSettings);

        virtual ~CTLVertexShaderDesc() {}

        UINT GetShaderSettings() const 
        { 
            return m_shaderSettings; 
        }

        const VSInputDecls& GetInputDecls() const
        {
            return m_vsInputDecls;
        }

        const VSOutputDecls& GetOutputDecls() const
        {
            return m_vsOutputDecls;
        }

    protected:
        UINT m_shaderSettings;
        VSInputDecls  m_vsInputDecls;
        VSOutputDecls m_vsOutputDecls;
    };

    ///---------------------------------------------------------------------------
    /// <summary>
    /// </summary>
    ///---------------------------------------------------------------------------
    class CPixelShaderDesc : public CShaderDesc
    {
    public:
        const VSOutputDecls& GetInputDecls() const
        {
            return m_inputDecls;
        }

        const PSUsageFlags& GetUsageFlags() const
        {
            return m_usageFlags;
        }

        UINT8 GetOutputRegistersMask() const
        {
            return m_outputRegistersMask;
        }

        void AddOutputDepthRegister()
        {
            m_outputRegistersMask |= DEPTH_OUTPUT_MASK;
        }

        void AddOutputRegisters(UINT registerIndex)
        {
            m_outputRegistersMask |= (1 << registerIndex);
        }

        HRESULT UpdateInputDecls(const VSOutputDecls& vsOuputDecls,
            const ShaderConv::RasterStates& rasterStates,
            VSOutputDecls* pMergedDecls);

        BYTE GetPositionRegister() const { return m_positionRegister; }

    protected:

        CPixelShaderDesc() : m_outputRegistersMask(0), m_positionRegister(0) {}
        virtual ~CPixelShaderDesc() {}

        static HRESULT Create(CPixelShaderDesc** ppPixelShaderDesc);

        void SetUsageFlags(const PSUsageFlags& usageFlags)
        {
            m_usageFlags = usageFlags;
        }

        void SetInputDecls(const VSOutputDecls& inputDecls)
        {
            m_inputDecls = inputDecls;
        }

        void SetPositionRegister(BYTE positionRegister) { m_positionRegister = positionRegister; }

        UINT8 m_outputRegistersMask;
        BYTE m_positionRegister;
        VSOutputDecls m_inputDecls;
        PSUsageFlags  m_usageFlags;

        friend class CTranslator;
    };

    ///---------------------------------------------------------------------------
    /// <summary>
    /// </summary>
    ///---------------------------------------------------------------------------
    struct GSFLAGS
    {
        union
        {
            UINT Value;
            struct
            {
                UINT PrimitiveSize : 2;
                UINT PointFill : 1;
                UINT FlatColorFill : 1;
                UINT PointSize : 1;
                UINT PointSprite : 1;
                UINT TextureWrap : 1;
                UINT HasTLVertices : 1;
                UINT UserClipPlanes : MAX_CLIPLANES;
            };
        };

        GSFLAGS() : Value(0)
        {
            C_ASSERT(sizeof(GSFLAGS) == sizeof(Value));
        }
    };

    ///---------------------------------------------------------------------------
    /// <summary>
    /// </summary>
    ///---------------------------------------------------------------------------
    class CGeometryShaderDesc : public CObject
    {
    public:

        CGeometryShaderDesc()
        {
            this->Clear();
        }

        CGeometryShaderDesc(UINT runtimeVersion,
            UINT shaderSettings,
            const VSOutputDecls& vsOutputDecls,
            const RasterStates& rasterStates);

        virtual ~CGeometryShaderDesc() {}

        void Clear()
        {
            memset(m_textureWraps, 0, sizeof(m_textureWraps));
            m_flags.Value = 0;
        }

        bool IsValid() const
        {
            return (m_flags.Value != 0);
        }

        UINT GetShaderSettings() const 
        {
            return m_shaderSettings;
        };

        UINT GetPrimitiveSize() const
        {
            return m_flags.PrimitiveSize;
        }

        const VSOutputDecls& GetInputDecls() const
        {
            return m_inputDecls;
        }

        const VSOutputDecls& GetOutputDecls() const
        {
            return m_outputDecls;
        }

        bool PointFillEnable() const
        {
            return (m_flags.PointFill != 0);
        }

        bool FlatColorFillEnable() const
        {
            return (m_flags.FlatColorFill != 0);
        }

        bool PointSizeEnable() const
        {
            return (m_flags.PointSize != 0);
        }

        bool PointSpriteEnable() const
        {
            return (m_flags.PointSprite != 0);
        }

        bool TextureWrapEnable() const
        {
            return (m_flags.TextureWrap != 0);
        }

        bool HasTLVertices() const
        {
            return (m_flags.HasTLVertices != 0);
        }

        UINT GetUserClipPlanes() const
        {
            return m_flags.UserClipPlanes;
        }

        UINT GetTextureWrap(UINT uiTexCoordIndex) const
        {
            return m_textureWraps[uiTexCoordIndex];
        }

        UINT GetFlagsID() const
        {
            return m_flags.Value;
        }

        bool operator==(const CGeometryShaderDesc& rhs) const
        {
            return (m_flags.Value == rhs.m_flags.Value)
                && (m_inputDecls == rhs.m_inputDecls)
                && (0 == memcmp(m_textureWraps, rhs.m_textureWraps, sizeof(m_textureWraps)));
        }

        bool operator!=(const CGeometryShaderDesc& rhs) const
        {
            return !(*this == rhs);
        }

    private:

        VSOutputDecls m_inputDecls;
        VSOutputDecls m_outputDecls;
        BYTE          m_textureWraps[MAX_PS_SAMPLER_REGS];
        GSFLAGS       m_flags;
        UINT m_shaderSettings;
    };

    ///---------------------------------------------------------------------------
    /// <summary>
    /// </summary>
    ///---------------------------------------------------------------------------
    class CCodeBlob : public CObject
    {
    public:

        static HRESULT Create(size_t cbSize, const void* pBuffer, CCodeBlob** ppCodeBlob);

        void* GetBufferPointer() const
        {
            return m_pBits;
        }

        size_t GetBufferSize() const
        {
            return m_cbSize;
        }

    protected:

        CCodeBlob() : m_cbSize(0),
            m_pBits(NULL) {}

        virtual ~CCodeBlob()
        {
            if (m_pBits) { delete(m_pBits); }
        }

        size_t m_cbSize;
        LPVOID m_pBits;
    };

    ///---------------------------------------------------------------------------
    /// <summary>
    /// </summary>
    ///---------------------------------------------------------------------------
    class ITranslator : public CObject
    {
    public:

        virtual HRESULT AnalyzeVS(const void* pSrcBytes,
            UINT cbCodeSize,
            UINT shaderSettings,
            const RasterStates& rasterStates,
            const VSInputDecls *pReferenceInputDecls,
            CVertexShaderDesc** ppShaderDesc) = 0;

        virtual HRESULT AnalyzePS(const void* pSrcBytes,
            UINT cbCodeSize,
            UINT shaderSettings,
            const RasterStates& rasterStates,
            CPixelShaderDesc** ppShaderDesc) = 0;

        virtual HRESULT TranslateVS(const CVertexShaderDesc* pShaderDesc,
            const RasterStates& rasterStates,
            CCodeBlob** ppCodeBlob) = 0;

        virtual HRESULT TranslateTLVS(const CTLVertexShaderDesc* pShaderDesc,
            CCodeBlob** ppCodeBlob) = 0;

        virtual HRESULT TranslatePS(const CPixelShaderDesc* pShaderDesc,
            const RasterStates& rasterStates,
            const ShaderConv::VSOutputDecls& inputDecls,
            CCodeBlob** ppCodeBlob) = 0;

        virtual HRESULT TranslateGS(const CGeometryShaderDesc* pShaderDesc,
            CCodeBlob** ppCodeBlob) = 0;

        struct TranslationData
        {
            UINT NumInstructionsEmitted;
            UINT NumExtraInstructionsEmitted;
        };

        virtual TranslationData GetTranslationData() = 0;
    protected:

        ITranslator() {}
        virtual ~ITranslator() {}
    };


    TEXTURETYPE ToTextureType(D3D10DDIRESOURCE_TYPE resourceType);

    HRESULT CreateTranslator(UINT runtimeVersion, ITranslator** ppTranslator);
};
```

`ShaderConverter/ShaderBinary/ShaderBinary.cpp`:

```cpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  Content: Vertex shader binary format parsing and encoding
 *
 ***************************************************************************/
 #include "pch.hpp"

BOOL IsOpCodeValid(D3D10_SB_OPCODE_TYPE OpCode)
{
    return OpCode < D3D10_SB_NUM_OPCODES;
}

UINT GetNumInstructionOperands(D3D10_SB_OPCODE_TYPE OpCode)
{
    return GetNumInstructionSrcOperands(OpCode) + GetNumInstructionDstOperands(OpCode);
}

UINT GetNumInstructionSrcOperands(D3D10_SB_OPCODE_TYPE OpCode)
{
   SHADER_CONV_ASSERT(IsOpCodeValid(OpCode));
    return g_InstructionInfo[OpCode].m_NumSrcOperands;
}

UINT GetNumInstructionDstOperands(D3D10_SB_OPCODE_TYPE OpCode)
{
   SHADER_CONV_ASSERT(IsOpCodeValid(OpCode));
    return g_InstructionInfo[OpCode].m_NumDstOperands;
}

D3D11_SB_OPCODE_CLASS GetOpcodeClass(D3D10_SB_OPCODE_TYPE OpCode)
{
   SHADER_CONV_ASSERT(IsOpCodeValid(OpCode));
    return g_InstructionInfo[OpCode].m_OpClass;
}

LPCSTR GetOpcodeString(D3D10_SB_OPCODE_TYPE OpCode)
{
   SHADER_CONV_ASSERT(IsOpCodeValid(OpCode));
    return g_InstructionInfo[OpCode].m_Name;
}

CInstructionInfo g_InstructionInfo[D3D10_SB_NUM_OPCODES];

void InitInstructionInfo()
{
#if WARP_INTERNAL
#define SET(OpCode, NumDstOperands, NumSrcOperands, Name, OpClass) \
    (g_InstructionInfo[OpCode].Set(NumDstOperands, NumSrcOperands, Name, OpClass))
#else
#define SET(OpCode, NumDstOperands, NumSrcOperands, Name, OpClass) \
    (g_InstructionInfo[OpCode].Set(NumDstOperands, NumSrcOperands, "", OpClass))
#endif

    SET (D3D10_SB_OPCODE_ADD,        1, 2,  "add", D3D11_SB_FLOAT_OP);
    SET (D3D10_SB_OPCODE_AND,        1, 2,  "and", D3D11_SB_BIT_OP);
    SET (D3D10_SB_OPCODE_BREAK,      0, 0,  "break", D3D11_SB_FLOW_OP);
    SET (D3D10_SB_OPCODE_BREAKC,     0, 1,  "breakc", D3D11_SB_FLOW_OP);
    SET (D3D10_SB_OPCODE_CALL,       0, 1,  "call", D3D11_SB_FLOW_OP);
    SET (D3D10_SB_OPCODE_CALLC,      0, 2,  "callc", D3D11_SB_FLOW_OP);
    SET (D3D10_SB_OPCODE_CONTINUE,   0, 0,  "continue", D3D11_SB_FLOW_OP);
    SET (D3D10_SB_OPCODE_CONTINUEC,  0, 1,  "continuec", D3D11_SB_FLOW_OP);
    SET (D3D10_SB_OPCODE_CASE,       0, 1,  "case", D3D11_SB_FLOW_OP);
    SET (D3D10_SB_OPCODE_CUT,        0, 0,  "cut", D3D11_SB_FLOW_OP);
    SET (D3D10_SB_OPCODE_CUSTOMDATA, 0, 0,  "customdata", D3D11_SB_FLOW_OP);
    SET (D3D10_SB_OPCODE_DEFAULT,    0, 0,  "default", D3D11_SB_FLOW_OP);
    SET (D3D10_SB_OPCODE_DISCARD,    0, 1,  "discard", D3D11_SB_FLOW_OP);
    SET (D3D10_SB_OPCODE_DIV,        1, 2,  "div", D3D11_SB_FLOAT_OP);
    SET (D3D10_SB_OPCODE_DP2,        1, 2,  "dp2", D3D11_SB_FLOAT_OP);
    SET (D3D10_SB_OPCODE_DP3,        1, 2,  "dp3", D3D11_SB_FLOAT_OP);
    SET (D3D10_SB_OPCODE_DP4,        1, 2,  "dp4", D3D11_SB_FLOAT_OP);
    SET (D3D10_SB_OPCODE_ELSE,       0, 0,  "else", D3D11_SB_FLOW_OP);
    SET (D3D10_SB_OPCODE_EMIT,       0, 0,  "emit", D3D11_SB_FLOW_OP);
    SET (D3D10_SB_OPCODE_EMITTHENCUT,0, 0,  "emit_then_cut", D3D11_SB_FLOW_OP);
    SET (D3D10_SB_OPCODE_ENDIF,      0, 0,  "endif", D3D11_SB_FLOW_OP);
    SET (D3D10_SB_OPCODE_ENDLOOP,    0, 0,  "endloop", D3D11_SB_FLOW_OP);
    SET (D3D10_SB_OPCODE_ENDSWITCH,  0, 0,  "endswitch", D3D11_SB_FLOW_OP);
    SET (D3D10_SB_OPCODE_EQ,         1, 2,  "eq", D3D11_SB_FLOAT_OP);
    SET (D3D10_SB_OPCODE_EXP,        1, 1,  "exp", D3D11_SB_FLOAT_OP);
    SET (D3D10_SB_OPCODE_FRC,        1, 1,  "frc", D3D11_SB_FLOAT_OP);
    SET (D3D10_SB_OPCODE_FTOI,       1, 1,  "ftoi", D3D11_SB_FLOAT_OP);
    SET (D3D10_SB_OPCODE_FTOU,       1, 1,  "ftou", D3D11_SB_FLOAT_OP);
    SET (D3D10_SB_OPCODE_GE,         1, 2,  "ge", D3D11_SB_FLOAT_OP);
    SET (D3D10_SB_OPCODE_DERIV_RTX,  1, 1,  "rtx", D3D11_SB_FLOAT_OP);
    SET (D3D10_SB_OPCODE_DERIV_RTY,  1, 1,  "rty", D3D11_SB_FLOAT_OP);
    SET (D3D10_SB_OPCODE_IADD,       1, 2,  "iadd", D3D11_SB_INT_OP);
    SET (D3D10_SB_OPCODE_IF,         0, 1,  "if", D3D11_SB_FLOW_OP);
    SET (D3D10_SB_OPCODE_IEQ,        1, 2,  "ieq", D3D11_SB_INT_OP);
    SET (D3D10_SB_OPCODE_IGE,        1, 2,  "ige", D3D11_SB_INT_OP);
    SET (D3D10_SB_OPCODE_ILT,        1, 2,  "ilt", D3D11_SB_INT_OP);
    SET (D3D10_SB_OPCODE_IMAD,       1, 3,  "imad", D3D11_SB_INT_OP);
    SET (D3D10_SB_OPCODE_IMAX,       1, 2,  "imax", D3D11_SB_INT_OP);
    SET (D3D10_SB_OPCODE_IMIN,       1, 2,  "imin", D3D11_SB_INT_OP);
    SET (D3D10_SB_OPCODE_IMUL,       2, 2,  "imul", D3D11_SB_INT_OP);
    SET (D3D10_SB_OPCODE_INE,        1, 2,  "ine", D3D11_SB_INT_OP);
    SET (D3D10_SB_OPCODE_INEG,       1, 1,  "ineg", D3D11_SB_INT_OP);
    SET (D3D10_SB_OPCODE_ISHL,       1, 2,  "ishl", D3D11_SB_INT_OP);
    SET (D3D10_SB_OPCODE_ISHR,       1, 2,  "ishr", D3D11_SB_INT_OP);
    SET (D3D10_SB_OPCODE_ITOF,       1, 1,  "itof", D3D11_SB_INT_OP);
    SET (D3D10_SB_OPCODE_LABEL,      0, 1,  "label", D3D11_SB_FLOW_OP);
    SET (D3D10_SB_OPCODE_LD,         1, 2,  "ld", D3D11_SB_TEX_OP);
    SET (D3D10_SB_OPCODE_LD_MS,      1, 3,  "ldms", D3D11_SB_TEX_OP);
    SET (D3D10_SB_OPCODE_LOG,        1, 1,  "log", D3D11_SB_FLOAT_OP);
    SET (D3D10_SB_OPCODE_LOOP,       0, 0,  "loop", D3D11_SB_FLOW_OP);
    SET (D3D10_SB_OPCODE_LT,         1, 2,  "lt", D3D11_SB_FLOAT_OP);
    SET (D3D10_SB_OPCODE_MAD,        1, 3,  "mad", D3D11_SB_FLOAT_OP);
    SET (D3D10_SB_OPCODE_MAX,        1, 2,  "max", D3D11_SB_FLOAT_OP);
    SET (D3D10_SB_OPCODE_MIN,        1, 2,  "min", D3D11_SB_FLOAT_OP);
    SET (D3D10_SB_OPCODE_MOV,        1, 1,  "mov", D3D11_SB_FLOAT_OP);
    SET (D3D10_SB_OPCODE_MOVC,       1, 3,  "movc", D3D11_SB_FLOAT_OP);
    SET (D3D10_SB_OPCODE_MUL,        1, 2,  "mul", D3D11_SB_FLOAT_OP);
    SET (D3D10_SB_OPCODE_NE,         1, 2,  "ne", D3D11_SB_FLOAT_OP);
    SET (D3D10_SB_OPCODE_NOP,        0, 0,  "nop", D3D11_SB_FLOW_OP);
    SET (D3D10_SB_OPCODE_NOT,        1, 1,  "not", D3D11_SB_BIT_OP);
    SET (D3D10_SB_OPCODE_OR,         1, 2,  "or", D3D11_SB_BIT_OP);
    SET (D3D10_SB_OPCODE_RESINFO,    1, 2,  "resinfo", D3D11_SB_FLOW_OP);
    SET (D3D10_SB_OPCODE_RET,        0, 0,  "ret", D3D11_SB_FLOW_OP);
    SET (D3D10_SB_OPCODE_RETC,       0, 1,  "retc", D3D11_SB_FLOW_OP);
    SET (D3D10_SB_OPCODE_ROUND_NE,   1, 1,  "round_ne", D3D11_SB_FLOAT_OP);
    SET (D3D10_SB_OPCODE_ROUND_NI,   1, 1,  "round_ni", D3D11_SB_FLOAT_OP);
    SET (D3D10_SB_OPCODE_ROUND_PI,   1, 1,  "round_pi", D3D11_SB_FLOAT_OP);
    SET (D3D10_SB_OPCODE_ROUND_Z,    1, 1,  "round_z", D3D11_SB_FLOAT_OP);
    SET (D3D10_SB_OPCODE_RSQ,        1, 1,  "rsq", D3D11_SB_FLOAT_OP);
    SET (D3D10_SB_OPCODE_SAMPLE,     1, 3,  "sample", D3D11_SB_TEX_OP);
    SET (D3D10_SB_OPCODE_SAMPLE_B,   1, 4, "sample_b", D3D11_SB_TEX_OP);
    SET (D3D10_SB_OPCODE_SAMPLE_L,   1, 4,  "sample_l", D3D11_SB_TEX_OP);
    SET (D3D10_SB_OPCODE_SAMPLE_D,   1, 5,  "sample_d", D3D11_SB_TEX_OP);
    SET (D3D10_SB_OPCODE_SAMPLE_C,   1, 4,  "sample_c", D3D11_SB_TEX_OP);
    SET (D3D10_SB_OPCODE_SAMPLE_C_LZ,1, 4,  "sample_c_lz", D3D11_SB_TEX_OP);
    SET (D3D10_SB_OPCODE_SQRT,       1, 1,  "sqrt", D3D11_SB_FLOAT_OP);
    SET (D3D10_SB_OPCODE_SWITCH,     0, 1,  "switch", D3D11_SB_FLOW_OP);
    SET (D3D10_SB_OPCODE_SINCOS,     1, 2,  "sincos", D3D11_SB_FLOAT_OP);
    SET (D3D10_SB_OPCODE_UDIV,       2, 2,  "udiv", D3D11_SB_UINT_OP);
    SET (D3D10_SB_OPCODE_ULT,        1, 2,  "ult", D3D11_SB_UINT_OP);
    SET (D3D10_SB_OPCODE_UGE,        1, 2,  "uge", D3D11_SB_UINT_OP);
    SET (D3D10_SB_OPCODE_UMAX,       1, 2,  "umax", D3D11_SB_UINT_OP);
    SET (D3D10_SB_OPCODE_UMIN,       1, 2,  "umin", D3D11_SB_UINT_OP);
    SET (D3D10_SB_OPCODE_UMUL,       2, 2,  "umul", D3D11_SB_UINT_OP);
    SET (D3D10_SB_OPCODE_UMAD,       1, 3,  "umad", D3D11_SB_UINT_OP);
    SET (D3D10_SB_OPCODE_USHR,       1, 2,  "ushr", D3D11_SB_UINT_OP);
    SET (D3D10_SB_OPCODE_UTOF,       1, 1,  "utof", D3D11_SB_UINT_OP);
    SET (D3D10_SB_OPCODE_XOR,        1, 2,  "xor", D3D11_SB_BIT_OP);
    SET (D3D10_SB_OPCODE_RESERVED0,  0, 0,  "jmp", D3D11_SB_FLOW_OP);
    SET (D3D10_SB_OPCODE_DCL_INPUT,                          0, 1, "dcl_input", D3D11_SB_DCL_OP);
    SET (D3D10_SB_OPCODE_DCL_OUTPUT,                         0, 1, "dcl_output", D3D11_SB_DCL_OP);
    SET (D3D10_SB_OPCODE_DCL_INPUT_SGV,                      0, 1, "dcl_input_sgv", D3D11_SB_DCL_OP);
    SET (D3D10_SB_OPCODE_DCL_INPUT_PS_SGV,                   0, 1, "dcl_input_sgv", D3D11_SB_DCL_OP);
    SET (D3D10_SB_OPCODE_DCL_GS_INPUT_PRIMITIVE,             0, 0, "dcl_inputprimitive", D3D11_SB_DCL_OP);
    SET (D3D10_SB_OPCODE_DCL_GS_OUTPUT_PRIMITIVE_TOPOLOGY,   0, 0, "dcl_outputtopology", D3D11_SB_DCL_OP);
    SET (D3D10_SB_OPCODE_DCL_MAX_OUTPUT_VERTEX_COUNT,        0, 0, "dcl_maxout", D3D11_SB_DCL_OP);
    SET (D3D10_SB_OPCODE_DCL_INPUT_PS,                       0, 1, "dcl_input", D3D11_SB_DCL_OP);
    SET (D3D10_SB_OPCODE_DCL_CONSTANT_BUFFER,                0, 1, "dcl_constantbuffer", D3D11_SB_DCL_OP);
    SET (D3D10_SB_OPCODE_DCL_SAMPLER,                        0, 1, "dcl_sampler", D3D11_SB_DCL_OP);
    SET (D3D10_SB_OPCODE_DCL_RESOURCE,                       0, 1, "dcl_resource", D3D11_SB_DCL_OP);
    SET (D3D10_SB_OPCODE_DCL_INPUT_SIV,                      0, 1, "dcl_input_siv", D3D11_SB_DCL_OP);
    SET (D3D10_SB_OPCODE_DCL_INPUT_PS_SIV,                   0, 1, "dcl_input_siv", D3D11_SB_DCL_OP);
    SET (D3D10_SB_OPCODE_DCL_OUTPUT_SIV,                     0, 1, "dcl_output_siv", D3D11_SB_DCL_OP);
    SET (D3D10_SB_OPCODE_DCL_OUTPUT_SGV,                     0, 1, "dcl_output_sgv", D3D11_SB_DCL_OP);
    SET (D3D10_SB_OPCODE_DCL_TEMPS,                          0, 0, "dcl_temps", D3D11_SB_DCL_OP);
    SET (D3D10_SB_OPCODE_DCL_INDEXABLE_TEMP,                 0, 0, "dcl_indexableTemp", D3D11_SB_DCL_OP);
    SET (D3D10_SB_OPCODE_DCL_INDEX_RANGE,                    0, 1, "dcl_indexrange", D3D11_SB_DCL_OP);
    SET (D3D10_SB_OPCODE_DCL_GLOBAL_FLAGS,                   0, 0, "dcl_globalFlags", D3D11_SB_DCL_OP);

    SET (D3D10_1_SB_OPCODE_SAMPLE_INFO,                      1, 1, "sampleinfo", D3D11_SB_TEX_OP);
    SET (D3D10_1_SB_OPCODE_SAMPLE_POS,                       1, 2, "samplepos", D3D11_SB_TEX_OP);
    SET (D3D10_1_SB_OPCODE_GATHER4,                          1, 3, "gather4", D3D11_SB_TEX_OP);
    SET (D3D10_1_SB_OPCODE_LOD,                              1, 3, "lod", D3D11_SB_TEX_OP);

    //
    // DX11 opcodes
    //
    SET (D3D11_SB_OPCODE_HS_DECLS,                          0, 0, "hs_decls", D3D11_SB_DCL_OP);
    SET (D3D11_SB_OPCODE_HS_CONTROL_POINT_PHASE,            0, 0, "hs_control_point_phase", D3D11_SB_DCL_OP);
    SET (D3D11_SB_OPCODE_HS_FORK_PHASE,                     0, 0, "hs_fork_phase", D3D11_SB_DCL_OP);
    SET (D3D11_SB_OPCODE_HS_JOIN_PHASE,                     0, 0, "hs_join_phase", D3D11_SB_DCL_OP);

    SET (D3D11_SB_OPCODE_INTERFACE_CALL,                    0, 1, "fcall", D3D11_SB_FLOW_OP);

    SET (D3D11_SB_OPCODE_BUFINFO,                           1, 1, "bufinfo", D3D11_SB_TEX_OP);
    SET (D3D11_SB_OPCODE_DERIV_RTX_COARSE,                  1, 1, "deriv_rtx_coarse", D3D11_SB_FLOAT_OP);
    SET (D3D11_SB_OPCODE_DERIV_RTX_FINE,                    1, 1, "deriv_rtx_fine", D3D11_SB_FLOAT_OP);
    SET (D3D11_SB_OPCODE_DERIV_RTY_COARSE,                  1, 1, "deriv_rty_coarse", D3D11_SB_FLOAT_OP);
    SET (D3D11_SB_OPCODE_DERIV_RTY_FINE,                    1, 1, "deriv_rty_fine", D3D11_SB_FLOAT_OP);
    SET (D3D11_SB_OPCODE_GATHER4_C,                         1, 4, "gather4_c", D3D11_SB_TEX_OP);
    SET (D3D11_SB_OPCODE_GATHER4_PO,                        1, 4, "gather4_po", D3D11_SB_TEX_OP);
    SET (D3D11_SB_OPCODE_GATHER4_PO_C,                      1, 5, "gather4_po_c", D3D11_SB_TEX_OP);
    SET (D3D11_SB_OPCODE_RCP,                               1, 1, "rcp", D3D11_SB_FLOAT_OP);
    SET (D3D11_SB_OPCODE_F32TOF16,                          1, 1, "f32tof16", D3D11_SB_FLOAT_OP);
    SET (D3D11_SB_OPCODE_F16TOF32,                          1, 1, "f16tof32", D3D11_SB_FLOAT_OP);
    SET (D3D11_SB_OPCODE_UADDC,                             2, 2, "uaddc", D3D11_SB_UINT_OP);
    SET (D3D11_SB_OPCODE_USUBB,                             2, 2, "usubb", D3D11_SB_UINT_OP);
    SET (D3D11_SB_OPCODE_COUNTBITS,                         1, 1, "countbits", D3D11_SB_UINT_OP);
    SET (D3D11_SB_OPCODE_FIRSTBIT_HI,                       1, 1, "firstbit_hi", D3D11_SB_UINT_OP);
    SET (D3D11_SB_OPCODE_FIRSTBIT_LO,                       1, 1, "firstbit_lo", D3D11_SB_UINT_OP);
    SET (D3D11_SB_OPCODE_FIRSTBIT_SHI,                      1, 1, "firstbit_shi", D3D11_SB_INT_OP);
    SET (D3D11_SB_OPCODE_UBFE,                              1, 3, "ubfe", D3D11_SB_UINT_OP);
    SET (D3D11_SB_OPCODE_IBFE,                              1, 3, "ibfe", D3D11_SB_INT_OP);
    SET (D3D11_SB_OPCODE_BFI,                               1, 4, "bfi", D3D11_SB_UINT_OP);
    SET (D3D11_SB_OPCODE_BFREV,                             1, 1, "bfrev", D3D11_SB_UINT_OP);
    SET (D3D11_SB_OPCODE_SWAPC,                             2, 3, "swapc", D3D11_SB_UINT_OP);

    SET (D3D11_SB_OPCODE_DCL_STREAM,                        0, 1, "dcl_stream", D3D11_SB_DCL_OP);
    SET (D3D11_SB_OPCODE_DCL_FUNCTION_BODY,                 0, 0, "dcl_function_body", D3D11_SB_DCL_OP);
    SET (D3D11_SB_OPCODE_DCL_FUNCTION_TABLE,                0, 0, "dcl_function_table ", D3D11_SB_DCL_OP);
    SET (D3D11_SB_OPCODE_DCL_INTERFACE,                     0, 0, "dcl_interface", D3D11_SB_DCL_OP);

    SET (D3D11_SB_OPCODE_DCL_INPUT_CONTROL_POINT_COUNT,     0, 1, "dcl_input_control_point_count", D3D11_SB_DCL_OP);
    SET (D3D11_SB_OPCODE_DCL_OUTPUT_CONTROL_POINT_COUNT,    0, 1, "dcl_output_control_point_count", D3D11_SB_DCL_OP);
    SET (D3D11_SB_OPCODE_DCL_TESS_DOMAIN,                   0, 1, "dcl_tessellator_domain", D3D11_SB_DCL_OP);
    SET (D3D11_SB_OPCODE_DCL_TESS_PARTITIONING,             0, 1, "dcl_tessellator_partitioning", D3D11_SB_DCL_OP);
    SET (D3D11_SB_OPCODE_DCL_TESS_OUTPUT_PRIMITIVE,         0, 1, "dcl_tessellator_output_primitive", D3D11_SB_DCL_OP);
    SET (D3D11_SB_OPCODE_DCL_HS_MAX_TESSFACTOR,             0, 1, "dcl_hs_max_tessfactor", D3D11_SB_DCL_OP);
    SET (D3D11_SB_OPCODE_DCL_HS_FORK_PHASE_INSTANCE_COUNT,  0, 1, "dcl_hs_fork_phase_instance_count", D3D11_SB_DCL_OP);
    SET (D3D11_SB_OPCODE_DCL_HS_JOIN_PHASE_INSTANCE_COUNT,  0, 1, "dcl_hs_join_phase_instance_count", D3D11_SB_DCL_OP);

    SET (D3D11_SB_OPCODE_DCL_THREAD_GROUP,                          0, 3, "dcl_thread_group", D3D11_SB_DCL_OP);
    SET (D3D11_SB_OPCODE_DCL_UNORDERED_ACCESS_VIEW_TYPED,           0, 3, "dcl_uav_typed", D3D11_SB_DCL_OP);
    SET (D3D11_SB_OPCODE_DCL_UNORDERED_ACCESS_VIEW_RAW,             0, 1, "dcl_uav_raw", D3D11_SB_DCL_OP);
    SET (D3D11_SB_OPCODE_DCL_UNORDERED_ACCESS_VIEW_STRUCTURED,      0, 2, "dcl_uav_structured", D3D11_SB_DCL_OP);
    SET (D3D11_SB_OPCODE_DCL_THREAD_GROUP_SHARED_MEMORY_RAW,        0, 2, "dcl_tgsm_raw", D3D11_SB_DCL_OP);
    SET (D3D11_SB_OPCODE_DCL_THREAD_GROUP_SHARED_MEMORY_STRUCTURED, 0, 3, "dcl_tgsm_structured", D3D11_SB_DCL_OP);
    SET (D3D11_SB_OPCODE_DCL_RESOURCE_RAW,                          0, 1, "dcl_resource_raw", D3D11_SB_DCL_OP);
    SET (D3D11_SB_OPCODE_DCL_RESOURCE_STRUCTURED,                   0, 2, "dcl_resource_structured", D3D11_SB_DCL_OP);

    SET (D3D11_SB_OPCODE_LD_UAV_TYPED,                              1, 2, "ld_uav_typed", D3D11_SB_TEX_OP);
    SET (D3D11_SB_OPCODE_STORE_UAV_TYPED,                           1, 2, "store_uav_typed", D3D11_SB_TEX_OP);
    SET (D3D11_SB_OPCODE_LD_RAW,                                    1, 2, "ld_raw", D3D11_SB_TEX_OP);
    SET (D3D11_SB_OPCODE_STORE_RAW,                                 1, 2, "store_raw", D3D11_SB_TEX_OP);
    SET (D3D11_SB_OPCODE_LD_STRUCTURED,                             1, 3, "ld_structured", D3D11_SB_TEX_OP);
    SET (D3D11_SB_OPCODE_STORE_STRUCTURED,                          1, 3, "store_structured ", D3D11_SB_TEX_OP);

    SET (D3D11_SB_OPCODE_ATOMIC_AND,                                1, 2, "atomic_and", D3D11_SB_UINT_OP);
    SET (D3D11_SB_OPCODE_ATOMIC_OR,                                 1, 2, "atomic_or", D3D11_SB_UINT_OP);
    SET (D3D11_SB_OPCODE_ATOMIC_XOR,                                1, 2, "atomic_xor", D3D11_SB_UINT_OP);
    SET (D3D11_SB_OPCODE_ATOMIC_CMP_STORE,                          1, 3, "atomic_cmp_store", D3D11_SB_UINT_OP);
    SET (D3D11_SB_OPCODE_ATOMIC_IADD,                               1, 2, "atomic_iadd", D3D11_SB_INT_OP);
    SET (D3D11_SB_OPCODE_ATOMIC_IMAX,                               1, 2, "atomic_imax", D3D11_SB_INT_OP);
    SET (D3D11_SB_OPCODE_ATOMIC_IMIN,                               1, 2, "atomic_imin", D3D11_SB_INT_OP);
    SET (D3D11_SB_OPCODE_ATOMIC_UMAX,                               1, 2, "atomic_umax", D3D11_SB_UINT_OP);
    SET (D3D11_SB_OPCODE_ATOMIC_UMIN,                               1, 2, "atomic_umin", D3D11_SB_UINT_OP);
    SET (D3D11_SB_OPCODE_IMM_ATOMIC_ALLOC,                          1, 1, "imm_atomic_alloc", D3D11_SB_UINT_OP);
    SET (D3D11_SB_OPCODE_IMM_ATOMIC_CONSUME,                        1, 1, "imm_atomic_consume", D3D11_SB_UINT_OP);
    SET (D3D11_SB_OPCODE_IMM_ATOMIC_IADD,                           2, 2, "imm_atomic_iadd", D3D11_SB_INT_OP);
    SET (D3D11_SB_OPCODE_IMM_ATOMIC_AND,                            2, 2, "imm_atomic_and", D3D11_SB_UINT_OP);
    SET (D3D11_SB_OPCODE_IMM_ATOMIC_OR,                             2, 2, "imm_atomic_or", D3D11_SB_UINT_OP);
    SET (D3D11_SB_OPCODE_IMM_ATOMIC_XOR,                            2, 2, "imm_atomic_xor", D3D11_SB_UINT_OP);
    SET (D3D11_SB_OPCODE_IMM_ATOMIC_EXCH,                           2, 2, "imm_atomic_exch", D3D11_SB_UINT_OP);
    SET (D3D11_SB_OPCODE_IMM_ATOMIC_CMP_EXCH,                       2, 3, "imm_atomic_cmp_exch", D3D11_SB_UINT_OP);
    SET (D3D11_SB_OPCODE_IMM_ATOMIC_IMAX,                           2, 2, "imm_atomic_imax", D3D11_SB_INT_OP);
    SET (D3D11_SB_OPCODE_IMM_ATOMIC_IMIN,                           2, 2, "imm_atomic_imin", D3D11_SB_INT_OP);
    SET (D3D11_SB_OPCODE_IMM_ATOMIC_UMAX,                           2, 2, "imm_atomic_umax", D3D11_SB_UINT_OP);
    SET (D3D11_SB_OPCODE_IMM_ATOMIC_UMIN,                           2, 2, "imm_atomic_umin", D3D11_SB_UINT_OP);
    SET (D3D11_SB_OPCODE_SYNC,                                      0, 0, "sync", D3D11_SB_FLOW_OP);

    SET (D3D11_SB_OPCODE_DADD,                                      1, 2, "dadd", D3D11_SB_FLOAT_OP);
    SET (D3D11_SB_OPCODE_DMAX,                                      1, 2, "dmax", D3D11_SB_FLOAT_OP);
    SET (D3D11_SB_OPCODE_DMIN,                                      1, 2, "dmin", D3D11_SB_FLOAT_OP);
    SET (D3D11_SB_OPCODE_DMUL,                                      1, 2, "dmul", D3D11_SB_FLOAT_OP);
    SET (D3D11_SB_OPCODE_DEQ,                                       1, 2, "deq", D3D11_SB_FLOAT_OP);
    SET (D3D11_SB_OPCODE_DGE,                                       1, 2, "dge", D3D11_SB_FLOAT_OP);
    SET (D3D11_SB_OPCODE_DLT,                                       1, 2, "dlt", D3D11_SB_FLOAT_OP);
    SET (D3D11_SB_OPCODE_DNE,                                       1, 2, "dne", D3D11_SB_FLOAT_OP);
    SET (D3D11_SB_OPCODE_DMOV,                                      1, 1, "dmov", D3D11_SB_FLOAT_OP);
    SET (D3D11_SB_OPCODE_DMOVC,                                     1, 3, "dmovc", D3D11_SB_FLOAT_OP);
    SET (D3D11_SB_OPCODE_DTOF,                                      1, 1, "dtof", D3D11_SB_FLOAT_OP);
    SET (D3D11_SB_OPCODE_FTOD,                                      1, 1, "ftod", D3D11_SB_FLOAT_OP);

    SET (D3D11_1_SB_OPCODE_DDIV,                                    1, 2, "ddiv", D3D11_SB_FLOAT_OP);
    SET (D3D11_1_SB_OPCODE_DFMA,                                    1, 3, "dfma", D3D11_SB_FLOAT_OP);
    SET (D3D11_1_SB_OPCODE_DRCP,                                    1, 1, "drcp", D3D11_SB_FLOAT_OP);

    SET (D3D11_1_SB_OPCODE_MSAD,                                    1, 3, "msad", D3D11_SB_UINT_OP);

    SET (D3D11_1_SB_OPCODE_DTOI,                                    1, 1, "dtoi", D3D11_SB_FLOAT_OP);
    SET (D3D11_1_SB_OPCODE_DTOU,                                    1, 1, "dtou", D3D11_SB_FLOAT_OP);
    SET (D3D11_1_SB_OPCODE_ITOD,                                    1, 1, "itod", D3D11_SB_FLOAT_OP);
    SET (D3D11_1_SB_OPCODE_UTOD,                                    1, 1, "utod", D3D11_SB_FLOAT_OP);

    SET (D3D11_SB_OPCODE_EVAL_SNAPPED,                              1, 2, "eval_snapped", D3D11_SB_TEX_OP);
    SET (D3D11_SB_OPCODE_EVAL_SAMPLE_INDEX,                         1, 2, "eval_sample_index", D3D11_SB_TEX_OP);
    SET (D3D11_SB_OPCODE_EVAL_CENTROID,                             1, 1, "eval_centroid", D3D11_SB_TEX_OP);

    SET (D3D11_SB_OPCODE_DCL_GS_INSTANCE_COUNT,                     0, 0, "dcl_input", D3D11_SB_DCL_OP);
    SET (D3D11_SB_OPCODE_EMIT_STREAM,                               0, 1, "emit_stream", D3D11_SB_FLOW_OP);
    SET (D3D11_SB_OPCODE_CUT_STREAM,                                0, 1, "cut_stream", D3D11_SB_FLOW_OP);
    SET (D3D11_SB_OPCODE_EMITTHENCUT_STREAM,                        0, 1, "emitThenCut_stream", D3D11_SB_FLOW_OP);

    SET (D3D11_SB_OPCODE_ABORT,                                     0, 0, "abort", D3D11_SB_FLOW_OP); //TODO: correct this
    SET (D3D11_SB_OPCODE_DEBUG_BREAK,                               0, 0, "debug_break", D3D11_SB_FLOW_OP); //TODO: correct this

    SET (D3DWDDM1_3_SB_OPCODE_GATHER4_FEEDBACK,                     2, 3, "gather4_fb", D3D11_SB_TEX_OP);
    SET (D3DWDDM1_3_SB_OPCODE_GATHER4_C_FEEDBACK,                   2, 4, "gather4_c_fb", D3D11_SB_TEX_OP);
    SET (D3DWDDM1_3_SB_OPCODE_GATHER4_PO_FEEDBACK,                  2, 4, "gather4_po_fb", D3D11_SB_TEX_OP);
    SET (D3DWDDM1_3_SB_OPCODE_GATHER4_PO_C_FEEDBACK,                2, 5, "gather4_po_c_fb", D3D11_SB_TEX_OP);
    SET (D3DWDDM1_3_SB_OPCODE_LD_FEEDBACK,                          2, 2, "ld_fb", D3D11_SB_TEX_OP);
    SET (D3DWDDM1_3_SB_OPCODE_LD_MS_FEEDBACK,                       2, 3, "ldms_fb", D3D11_SB_TEX_OP);
    SET (D3DWDDM1_3_SB_OPCODE_LD_UAV_TYPED_FEEDBACK,                2, 2, "ld_uav_typed_fb", D3D11_SB_TEX_OP);
    SET (D3DWDDM1_3_SB_OPCODE_LD_RAW_FEEDBACK,                      2, 2, "ld_raw_fb", D3D11_SB_TEX_OP);
    SET (D3DWDDM1_3_SB_OPCODE_LD_STRUCTURED_FEEDBACK,               2, 3, "ld_structured_fb", D3D11_SB_TEX_OP);
    SET (D3DWDDM1_3_SB_OPCODE_SAMPLE_L_FEEDBACK,                    2, 4, "sample_l_fb", D3D11_SB_TEX_OP);
    SET (D3DWDDM1_3_SB_OPCODE_SAMPLE_C_LZ_FEEDBACK,                 2, 4, "sample_c_lz_fb", D3D11_SB_TEX_OP);

    SET (D3DWDDM1_3_SB_OPCODE_SAMPLE_CLAMP_FEEDBACK,                2, 4, "sample_clamp_fb", D3D11_SB_TEX_OP);
    SET (D3DWDDM1_3_SB_OPCODE_SAMPLE_B_CLAMP_FEEDBACK,              2, 5, "sample_clamp_b_fb", D3D11_SB_TEX_OP);
    SET (D3DWDDM1_3_SB_OPCODE_SAMPLE_D_CLAMP_FEEDBACK,              2, 6, "sample_clamp_d_fb", D3D11_SB_TEX_OP);
    SET (D3DWDDM1_3_SB_OPCODE_SAMPLE_C_CLAMP_FEEDBACK,              2, 5, "sample_clamp_c_fb", D3D11_SB_TEX_OP);

    SET (D3DWDDM1_3_SB_OPCODE_CHECK_ACCESS_FULLY_MAPPED,            1, 1, "checkAccess", D3D11_SB_UINT_OP);


}
//*****************************************************************************
//
//  CShaderCodeParser
//
//*****************************************************************************

void CShaderCodeParser::SetShader(CONST CShaderToken* pBuffer)
{
    m_NumParsedInstructions = 0;

    m_pShaderCode = (CShaderToken*)pBuffer;
    m_pShaderEndToken = (CShaderToken*)pBuffer + pBuffer[1];
    // First OpCode token
    m_pCurrentToken = (CShaderToken*)&pBuffer[2];
}

ParserPositionToken CShaderCodeParser::GetCurrentToken()
{
    ParserPositionToken Ret;
    Ret.Inst      = m_pCurrentToken;
    Ret.InstCount = m_NumParsedInstructions;
    return Ret;
}

UINT CShaderCodeParser::CurrentTokenOffsetInBytes()
{
    return UINT(m_pCurrentToken - m_pShaderCode) * sizeof(CShaderToken);
}

void CShaderCodeParser::SetCurrentToken(ParserPositionToken In)
{
    m_pCurrentToken         = In.Inst;
    m_NumParsedInstructions = In.InstCount;
}

D3D10_SB_TOKENIZED_PROGRAM_TYPE CShaderCodeParser::ShaderType()
{
    return (D3D10_SB_TOKENIZED_PROGRAM_TYPE)DECODE_D3D10_SB_TOKENIZED_PROGRAM_TYPE(*m_pShaderCode);
}

UINT CShaderCodeParser::ShaderLengthInTokens()
{
    return m_pShaderCode[1];
}

UINT CShaderCodeParser::ShaderMinorVersion()
{
    return DECODE_D3D10_SB_TOKENIZED_PROGRAM_MINOR_VERSION(m_pShaderCode[0]);
}

UINT CShaderCodeParser::ShaderMajorVersion()
{
    return DECODE_D3D10_SB_TOKENIZED_PROGRAM_MAJOR_VERSION(m_pShaderCode[0]);
}

__checkReturn HRESULT CShaderCodeParser::ParseOperand(COperandBase* pOperand)
{
    HRESULT hr = S_OK;

    CShaderToken Token = *m_pCurrentToken++;

    pOperand->m_Type = DECODE_D3D10_SB_OPERAND_TYPE(Token);
    pOperand->m_NumComponents = DECODE_D3D10_SB_OPERAND_NUM_COMPONENTS(Token);
    pOperand->m_bExtendedOperand = DECODE_IS_D3D10_SB_OPERAND_EXTENDED(Token);

    UINT NumComponents = 0;
    switch (pOperand->m_NumComponents)
    {
    case D3D10_SB_OPERAND_1_COMPONENT:   NumComponents = 1; break;
    case D3D10_SB_OPERAND_4_COMPONENT:   NumComponents = 4; break;
    }

    switch (pOperand->m_Type)
    {
    case D3D10_SB_OPERAND_TYPE_IMMEDIATE32:
    case D3D10_SB_OPERAND_TYPE_IMMEDIATE64:
        pOperand->m_IndexDimension = DECODE_D3D10_SB_OPERAND_INDEX_DIMENSION(Token);
        break;
    default:
        {
            if (pOperand->m_NumComponents == D3D10_SB_OPERAND_4_COMPONENT)
            {
                // Component selection mode
                pOperand->m_ComponentSelection = DECODE_D3D10_SB_OPERAND_4_COMPONENT_SELECTION_MODE(Token);
                switch(pOperand->m_ComponentSelection)
                {
                case D3D10_SB_OPERAND_4_COMPONENT_MASK_MODE:
                    pOperand->m_WriteMask = DECODE_D3D10_SB_OPERAND_4_COMPONENT_MASK(Token);
                    break;
                case D3D10_SB_OPERAND_4_COMPONENT_SWIZZLE_MODE:
                    pOperand->m_Swizzle[0] = (BYTE)DECODE_D3D10_SB_OPERAND_4_COMPONENT_SWIZZLE_SOURCE(Token, 0);
                    pOperand->m_Swizzle[1] = (BYTE)DECODE_D3D10_SB_OPERAND_4_COMPONENT_SWIZZLE_SOURCE(Token, 1);
                    pOperand->m_Swizzle[2] = (BYTE)DECODE_D3D10_SB_OPERAND_4_COMPONENT_SWIZZLE_SOURCE(Token, 2);
                    pOperand->m_Swizzle[3] = (BYTE)DECODE_D3D10_SB_OPERAND_4_COMPONENT_SWIZZLE_SOURCE(Token, 3);
                    break;
                case D3D10_SB_OPERAND_4_COMPONENT_SELECT_1_MODE:
                {
                    D3D10_SB_4_COMPONENT_NAME Component = DECODE_D3D10_SB_OPERAND_4_COMPONENT_SELECT_1(Token);
                    pOperand->m_Swizzle[0] = (BYTE)Component;
                    pOperand->m_Swizzle[1] = (BYTE)Component;
                    pOperand->m_Swizzle[2] = (BYTE)Component;
                    pOperand->m_Swizzle[3] = (BYTE)Component;
                    pOperand->m_ComponentName = Component;
                    break;
                }
                default:
                    hr = E_OUTOFMEMORY; // Can't return E_INVALIDARG because that is not allowed by the runtime (causes device removed);
                    goto Cleanup;
                }
            }
            pOperand->m_IndexDimension = DECODE_D3D10_SB_OPERAND_INDEX_DIMENSION(Token);
            if (pOperand->m_IndexDimension != D3D10_SB_OPERAND_INDEX_0D)
            {
                UINT NumDimensions = pOperand->m_IndexDimension;
                // Index representation
                for (UINT i=0; i < NumDimensions; i++)
                {
                    pOperand->m_IndexType[i] = DECODE_D3D10_SB_OPERAND_INDEX_REPRESENTATION(i, Token);
                }
            }
            break;
        }
    }

    // Extended operand
    if (pOperand->m_bExtendedOperand)
    {
        Token = *m_pCurrentToken++;
        pOperand->m_ExtendedOperandType = DECODE_D3D10_SB_EXTENDED_OPERAND_TYPE(Token);
        if (pOperand->m_ExtendedOperandType == D3D10_SB_EXTENDED_OPERAND_MODIFIER)
        {
            pOperand->m_Modifier = DECODE_D3D10_SB_OPERAND_MODIFIER(Token);
        }
        pOperand->m_MinPrecision = DECODE_D3D11_SB_OPERAND_MIN_PRECISION(Token);
    }

    if (pOperand->m_Type == D3D10_SB_OPERAND_TYPE_IMMEDIATE32 || 
            pOperand->m_Type == D3D10_SB_OPERAND_TYPE_IMMEDIATE64)
    {
        for (UINT i=0 ; i < NumComponents; i++)
        {
            pOperand->m_Value[i] = *m_pCurrentToken++;
        }
    }

    // Operand indices
    if (pOperand->m_IndexDimension != D3D10_SB_OPERAND_INDEX_0D)
    {
        const UINT NumDimensions = pOperand->m_IndexDimension;
        // Index representation
        for (UINT i=0; i < NumDimensions; i++)
        {
            switch (pOperand->m_IndexType[i])
            {
            case D3D10_SB_OPERAND_INDEX_IMMEDIATE32:
                pOperand->m_Index[i].m_RegIndex = *m_pCurrentToken++;
                pOperand->m_Index[i].m_ComponentName = pOperand->m_ComponentName;
                pOperand->m_Index[i].m_RelRegType = pOperand->m_Type;
                break;
            case D3D10_SB_OPERAND_INDEX_IMMEDIATE64:
                pOperand->m_Index[i].m_RegIndexA[0] = *m_pCurrentToken++;
                pOperand->m_Index[i].m_RegIndexA[1] = *m_pCurrentToken++;
                pOperand->m_Index[i].m_ComponentName = pOperand->m_ComponentName;
                pOperand->m_Index[i].m_RelRegType = pOperand->m_Type;
                break;
            case D3D10_SB_OPERAND_INDEX_RELATIVE:
                {
                    COperand operand;

                    IFC (ParseOperand(&operand));

                    pOperand->m_Index[i].m_RelIndex = operand.m_Index[0].m_RegIndex;
                    pOperand->m_Index[i].m_RelIndex1 = operand.m_Index[1].m_RegIndex;
                    pOperand->m_Index[i].m_RelRegType = operand.m_Type;
                    pOperand->m_Index[i].m_IndexDimension = operand.m_IndexDimension;
                    pOperand->m_Index[i].m_ComponentName = operand.m_Index[0].m_ComponentName;
                    break;
                }
            case D3D10_SB_OPERAND_INDEX_IMMEDIATE32_PLUS_RELATIVE:
                {
                    pOperand->m_Index[i].m_RegIndex = *m_pCurrentToken++;
                    COperand operand;

                    IFC (ParseOperand(&operand));

                    pOperand->m_Index[i].m_RelIndex = operand.m_Index[0].m_RegIndex;
                    pOperand->m_Index[i].m_RelIndex1 = operand.m_Index[1].m_RegIndex;
                    pOperand->m_Index[i].m_RelRegType = operand.m_Index[0].m_RelRegType;
                    pOperand->m_Index[i].m_IndexDimension = operand.m_IndexDimension;
                    pOperand->m_Index[i].m_ComponentName = operand.m_Index[0].m_ComponentName;
                }
                break;
            default:
                hr = E_OUTOFMEMORY; // Can't return E_INVALIDARG because that is not allowed by the runtime (causes device removed)
                goto Cleanup;
            }
        }
    }

Cleanup:
    RRETURN(hr);
}

//
// Returns the opcode of the next instruction to be read. If the end of the shader has been reached, D3D10_SB_OPCODE_MAX is returned
//
D3D10_SB_OPCODE_TYPE CShaderCodeParser::PeekNextInstructionOpCode()
{
    if (EndOfShader())
    {
        return D3D10_SB_OPCODE_MAX;
    }
    else
    {
        return DECODE_D3D10_SB_OPCODE_TYPE(*m_pCurrentToken);
    }
}

__checkReturn HRESULT CShaderCodeParser::ParseInstruction(CInstruction* pInstruction)
{
    HRESULT hr = S_OK;

    pInstruction->Clear(true);
    CShaderToken* pStart = m_pCurrentToken;
    CShaderToken Token = *m_pCurrentToken++;
    pInstruction->m_OpCode = DECODE_D3D10_SB_OPCODE_TYPE(Token);
    pInstruction->m_bSaturate = DECODE_IS_D3D10_SB_INSTRUCTION_SATURATE_ENABLED(Token);
    pInstruction->m_bExtended = DECODE_IS_D3D10_SB_OPCODE_EXTENDED(Token);
    UINT InstructionLength = DECODE_D3D10_SB_TOKENIZED_INSTRUCTION_LENGTH(Token);
    pInstruction->m_NumOperands = GetNumInstructionOperands(pInstruction->m_OpCode);
    pInstruction->m_ExtendedOpCodeCount = 0;

    if(pInstruction->m_bExtended)
    {
        if(pInstruction->m_OpCode == D3D11_SB_OPCODE_DCL_INTERFACE ||
           pInstruction->m_OpCode == D3D11_SB_OPCODE_DCL_FUNCTION_TABLE)
        {
            pInstruction->m_ExtendedOpCodeCount = 1;
    #pragma prefast (suppress : __WARNING_LOCALDECLHIDESLOCAL, "This uses the same variable name for continuity.")
            // these instructions may be longer than can fit in the normal instructionlength field
            InstructionLength = (UINT)(*m_pCurrentToken++);
        }
        else
        {
            BOOL bExtended = TRUE;
            for(int i = 0; i < D3D11_SB_MAX_SIMULTANEOUS_EXTENDED_OPCODES; i++)
            {
                pInstruction->m_ExtendedOpCodeCount++;
        #pragma prefast (suppress : __WARNING_LOCALDECLHIDESLOCAL, "This uses the same variable name for continuity.")
                CShaderToken ExtToken = *m_pCurrentToken++;
                bExtended = DECODE_IS_D3D10_SB_OPCODE_EXTENDED(ExtToken);
                pInstruction->m_OpCodeEx[i] = DECODE_D3D10_SB_EXTENDED_OPCODE_TYPE(ExtToken);
                switch(pInstruction->m_OpCodeEx[i])
                {
                case D3D10_SB_EXTENDED_OPCODE_SAMPLE_CONTROLS:
                    {
                        pInstruction->m_TexelOffset[0] = (INT8)DECODE_IMMEDIATE_D3D10_SB_ADDRESS_OFFSET(D3D10_SB_IMMEDIATE_ADDRESS_OFFSET_U, ExtToken);
                        pInstruction->m_TexelOffset[1] = (INT8)DECODE_IMMEDIATE_D3D10_SB_ADDRESS_OFFSET(D3D10_SB_IMMEDIATE_ADDRESS_OFFSET_V, ExtToken);
                        pInstruction->m_TexelOffset[2] = (INT8)DECODE_IMMEDIATE_D3D10_SB_ADDRESS_OFFSET(D3D10_SB_IMMEDIATE_ADDRESS_OFFSET_W, ExtToken);
                        for(UINT j = 0; j < 3; j++)
                        {
                            if(pInstruction->m_TexelOffset[j] & 0x8)
                                pInstruction->m_TexelOffset[j] |= 0xfffffff0;
                        }
                        break;
                    }
                    break;
                case D3D11_SB_EXTENDED_OPCODE_RESOURCE_DIM:
                    {
                        pInstruction->m_ResourceDecl.Dimension = DECODE_D3D11_SB_EXTENDED_RESOURCE_DIMENSION(ExtToken);
                        //pInstruction->m_ResourceDimEx = DECODE_D3D11_SB_EXTENDED_RESOURCE_DIMENSION(ExtToken);
                        //pInstruction->m_ResourceDimStructureStrideEx = DECODE_D3D11_SB_EXTENDED_RESOURCE_DIMENSION_STRUCTURE_STRIDE(ExtToken);
                    }
                    break;
                case D3D11_SB_EXTENDED_OPCODE_RESOURCE_RETURN_TYPE:
                    {
                        for(UINT j = 0; j < 4; j++)
                        {
                            //pInstruction->m_ResourceReturnTypeEx[j] = DECODE_D3D11_SB_EXTENDED_RESOURCE_RETURN_TYPE(ExtToken,j);
                        }
                    }
                    break;
                }
                if( !bExtended )
                {
                    break;
                }
            }
        }
    }

    switch (pInstruction->m_OpCode)
    {
    case D3D10_SB_OPCODE_CUSTOMDATA:
        // not bothering to keep custom-data for now. TODO: store
        pInstruction->m_CustomData.Type = DECODE_D3D10_SB_CUSTOMDATA_CLASS(Token);
        InstructionLength = *m_pCurrentToken;
        if (*m_pCurrentToken <2)
        {
            InstructionLength = 2;
            pInstruction->m_CustomData.pData = 0;
            pInstruction->m_CustomData.DataSizeInBytes = 0;
        }
        else
        {
            pInstruction->m_CustomData.DataSizeInBytes = (*m_pCurrentToken-2)*4;
            IFCOOM (pInstruction->m_CustomData.pData = new byte [(*m_pCurrentToken - 2)*sizeof(UINT)]);

            memcpy(pInstruction->m_CustomData.pData, m_pCurrentToken+1, (*m_pCurrentToken - 2)*4);
        }
        break;

    case D3D10_SB_OPCODE_DCL_RESOURCE:
        pInstruction->m_ResourceDecl.Dimension = DECODE_D3D10_SB_RESOURCE_DIMENSION(Token);
        IFC (ParseOperand(&pInstruction->m_Operands[0]));
        pInstruction->m_ResourceDecl.ReturnType[0] = DECODE_D3D10_SB_RESOURCE_RETURN_TYPE(*m_pCurrentToken, 0);
        pInstruction->m_ResourceDecl.ReturnType[1] = DECODE_D3D10_SB_RESOURCE_RETURN_TYPE(*m_pCurrentToken, 1);
        pInstruction->m_ResourceDecl.ReturnType[2] = DECODE_D3D10_SB_RESOURCE_RETURN_TYPE(*m_pCurrentToken, 2);
        pInstruction->m_ResourceDecl.ReturnType[3] = DECODE_D3D10_SB_RESOURCE_RETURN_TYPE(*m_pCurrentToken, 3);
        pInstruction->m_ResourceDecl.SampleCount = DECODE_D3D10_SB_RESOURCE_SAMPLE_COUNT(Token);
        m_pCurrentToken++;
        break;

    case D3D10_SB_OPCODE_DCL_SAMPLER:
        pInstruction->m_SamplerDecl.SamplerMode = DECODE_D3D10_SB_SAMPLER_MODE(Token);
        IFC (ParseOperand(&pInstruction->m_Operands[0]));
        break;

    case D3D10_SB_OPCODE_DCL_TEMPS:
        pInstruction->m_TempsDecl.NumTemps = (UINT)(*m_pCurrentToken);
        m_pCurrentToken++;
        break;

    case D3D10_SB_OPCODE_DCL_INDEXABLE_TEMP:
        pInstruction->m_IndexableTempDecl.IndexableTempNumber = (UINT)(*m_pCurrentToken);
        m_pCurrentToken++;
        pInstruction->m_IndexableTempDecl.NumRegisters  = (UINT)(*m_pCurrentToken);
        m_pCurrentToken++;
        switch( IntMin( 4, IntMax( 1, (UINT)(*m_pCurrentToken) ) ) )
        {
        case 1:
            pInstruction->m_IndexableTempDecl.Mask = D3D10_SB_OPERAND_4_COMPONENT_MASK_X;
            break;
        case 2:
            pInstruction->m_IndexableTempDecl.Mask = D3D10_SB_OPERAND_4_COMPONENT_MASK_X |
                                                     D3D10_SB_OPERAND_4_COMPONENT_MASK_Y;
            break;
        case 3:
            pInstruction->m_IndexableTempDecl.Mask = D3D10_SB_OPERAND_4_COMPONENT_MASK_X |
                                                     D3D10_SB_OPERAND_4_COMPONENT_MASK_Y |
                                                     D3D10_SB_OPERAND_4_COMPONENT_MASK_Z;
            break;
        case 4:
            pInstruction->m_IndexableTempDecl.Mask = D3D10_SB_OPERAND_4_COMPONENT_MASK_ALL;
            break;
        }
        m_pCurrentToken++;
        break;

    case D3D10_SB_OPCODE_DCL_INPUT:
    case D3D10_SB_OPCODE_DCL_OUTPUT:
        IFC (ParseOperand(&pInstruction->m_Operands[0]));
        break;

    case D3D10_SB_OPCODE_DCL_INPUT_SIV:
        IFC (ParseOperand(&pInstruction->m_Operands[0]));
        pInstruction->m_InputDeclSIV.Name = DECODE_D3D10_SB_NAME(*m_pCurrentToken);
        m_pCurrentToken++;
        break;

    case D3D10_SB_OPCODE_DCL_INPUT_SGV:
        IFC (ParseOperand(&pInstruction->m_Operands[0]));
        pInstruction->m_InputDeclSIV.Name = DECODE_D3D10_SB_NAME(*m_pCurrentToken);
        m_pCurrentToken++;
        break;

    case D3D10_SB_OPCODE_DCL_INPUT_PS:
        pInstruction->m_InputPSDecl.InterpolationMode = DECODE_D3D10_SB_INPUT_INTERPOLATION_MODE(Token);
        IFC (ParseOperand(&pInstruction->m_Operands[0]));
        break;

    case D3D10_SB_OPCODE_DCL_INPUT_PS_SIV:
        pInstruction->m_InputPSDeclSIV.InterpolationMode = DECODE_D3D10_SB_INPUT_INTERPOLATION_MODE(Token);
        IFC (ParseOperand(&pInstruction->m_Operands[0]));
        pInstruction->m_InputPSDeclSIV.Name = DECODE_D3D10_SB_NAME(*m_pCurrentToken);
        m_pCurrentToken++;
        break;

    case D3D10_SB_OPCODE_DCL_INPUT_PS_SGV:
        pInstruction->m_InputPSDeclSGV.InterpolationMode = DECODE_D3D10_SB_INPUT_INTERPOLATION_MODE(Token);
        IFC (ParseOperand(&pInstruction->m_Operands[0]));
        pInstruction->m_InputPSDeclSGV.Name = DECODE_D3D10_SB_NAME(*m_pCurrentToken);
        m_pCurrentToken++;
        break;

    case D3D10_SB_OPCODE_DCL_OUTPUT_SIV:
        IFC (ParseOperand(&pInstruction->m_Operands[0]));
        pInstruction->m_OutputDeclSIV.Name = DECODE_D3D10_SB_NAME(*m_pCurrentToken);
        m_pCurrentToken++;
        break;

    case D3D10_SB_OPCODE_DCL_OUTPUT_SGV:
        IFC (ParseOperand(&pInstruction->m_Operands[0]));
        pInstruction->m_OutputDeclSGV.Name = DECODE_D3D10_SB_NAME(*m_pCurrentToken);
        m_pCurrentToken++;
        break;

    case D3D10_SB_OPCODE_DCL_INDEX_RANGE:
        IFC (ParseOperand(&pInstruction->m_Operands[0]));
        pInstruction->m_IndexRangeDecl.RegCount = (UINT)(*m_pCurrentToken);
        m_pCurrentToken++;
        break;

    case D3D10_SB_OPCODE_DCL_CONSTANT_BUFFER:
        pInstruction->m_ConstantBufferDecl.AccessPattern = DECODE_D3D10_SB_CONSTANT_BUFFER_ACCESS_PATTERN(Token);
        IFC (ParseOperand(&pInstruction->m_Operands[0]));
        break;

    case D3D10_SB_OPCODE_DCL_GS_OUTPUT_PRIMITIVE_TOPOLOGY:
        pInstruction->m_OutputTopologyDecl.Topology = DECODE_D3D10_SB_GS_OUTPUT_PRIMITIVE_TOPOLOGY(Token);
        break;

    case D3D10_SB_OPCODE_DCL_GS_INPUT_PRIMITIVE:
        pInstruction->m_InputPrimitiveDecl.Primitive = DECODE_D3D10_SB_GS_INPUT_PRIMITIVE(Token);
        break;

    case D3D10_SB_OPCODE_DCL_MAX_OUTPUT_VERTEX_COUNT:
        pInstruction->m_GSMaxOutputVertexCountDecl.MaxOutputVertexCount = (UINT)(*m_pCurrentToken);
        m_pCurrentToken++;
        break;

    case D3D11_SB_OPCODE_DCL_GS_INSTANCE_COUNT:
        pInstruction->m_GSInstanceCount.InstanceCount = (UINT)(*m_pCurrentToken);
        m_pCurrentToken++;
        break;

    case D3D11_SB_OPCODE_DCL_UNORDERED_ACCESS_VIEW_RAW:
        pInstruction->m_UAVInfo.UAVType = pInstruction->m_OpCode;
        pInstruction->m_UAVInfo.Coherency = DECODE_D3D11_SB_ACCESS_COHERENCY_FLAGS(Token);
        pInstruction->m_UAVInfo.Dimension = D3D11_SB_RESOURCE_DIMENSION_RAW_BUFFER;
        IFC (ParseOperand(&pInstruction->m_Operands[0]));
        pInstruction->m_UAVInfo.Index = pInstruction->Operand(0).RegIndex();
        pInstruction->m_UAVInfo.Type = (D3D10_SB_RESOURCE_RETURN_TYPE)D3D11_RETURN_TYPE_UINT;
        break;

    case D3D11_SB_OPCODE_DCL_UNORDERED_ACCESS_VIEW_STRUCTURED:
        pInstruction->m_UAVInfo.UAVType = pInstruction->m_OpCode;
        pInstruction->m_UAVInfo.Coherency = DECODE_D3D11_SB_ACCESS_COHERENCY_FLAGS(Token);
        pInstruction->m_UAVInfo.Counter = DECODE_D3D11_SB_UAV_FLAGS(Token);
        pInstruction->m_UAVInfo.Dimension = D3D11_SB_RESOURCE_DIMENSION_STRUCTURED_BUFFER;
        IFC (ParseOperand(&pInstruction->m_Operands[0]));
        pInstruction->m_UAVInfo.Index = pInstruction->Operand(0).RegIndex();
        pInstruction->m_UAVInfo.Stride = (DWORD)(*m_pCurrentToken);
        pInstruction->m_UAVInfo.Type = (D3D10_SB_RESOURCE_RETURN_TYPE)D3D11_RETURN_TYPE_UINT;
        break;

    case D3D11_SB_OPCODE_DCL_UNORDERED_ACCESS_VIEW_TYPED:
        pInstruction->m_UAVInfo.UAVType = pInstruction->m_OpCode;
        pInstruction->m_UAVInfo.Coherency = DECODE_D3D11_SB_ACCESS_COHERENCY_FLAGS(Token);
        pInstruction->m_UAVInfo.Dimension = DECODE_D3D10_SB_RESOURCE_DIMENSION(Token);
        IFC (ParseOperand(&pInstruction->m_Operands[0]));
        pInstruction->m_UAVInfo.Index = pInstruction->Operand(0).RegIndex();
        pInstruction->m_UAVInfo.Type = DECODE_D3D10_SB_RESOURCE_RETURN_TYPE(*m_pCurrentToken,0);
        break;

    case D3D11_SB_OPCODE_DCL_RESOURCE_RAW:
        pInstruction->m_UAVInfo.UAVType = D3D11_SB_OPCODE_DCL_RESOURCE_RAW;
        IFC (ParseOperand(&pInstruction->m_Operands[0]));
        pInstruction->m_UAVInfo.Index = pInstruction->Operand(0).RegIndex();
        break;

    case D3D11_SB_OPCODE_DCL_RESOURCE_STRUCTURED:
        pInstruction->m_UAVInfo.UAVType = D3D11_SB_OPCODE_DCL_RESOURCE_STRUCTURED;
        IFC (ParseOperand(&pInstruction->m_Operands[0]));
        pInstruction->m_UAVInfo.Index = pInstruction->Operand(0).RegIndex();
        pInstruction->m_UAVInfo.Stride = (DWORD)(*m_pCurrentToken);
        break;

    case D3D11_SB_OPCODE_DCL_THREAD_GROUP_SHARED_MEMORY_RAW:
        pInstruction->m_TGSMInfo.Type = D3D11_SB_OPCODE_DCL_THREAD_GROUP_SHARED_MEMORY_RAW;
        m_pCurrentToken++;
        pInstruction->m_TGSMInfo.Index = (DWORD)(*m_pCurrentToken);
        m_pCurrentToken++;
        pInstruction->m_TGSMInfo.StructCount = (DWORD)(*m_pCurrentToken);
        pInstruction->m_TGSMInfo.StructStride = 4;
        break;

    case D3D11_SB_OPCODE_DCL_THREAD_GROUP_SHARED_MEMORY_STRUCTURED:
        pInstruction->m_TGSMInfo.Type = D3D11_SB_OPCODE_DCL_THREAD_GROUP_SHARED_MEMORY_STRUCTURED;
        m_pCurrentToken++;
        pInstruction->m_TGSMInfo.Index = (DWORD)(*m_pCurrentToken);
        m_pCurrentToken++;
        pInstruction->m_TGSMInfo.StructStride = (DWORD)(*m_pCurrentToken);
        m_pCurrentToken++;
        pInstruction->m_TGSMInfo.StructCount = (DWORD)(*m_pCurrentToken);
        break;

    case D3D10_SB_OPCODE_DCL_GLOBAL_FLAGS:
        pInstruction->m_GlobalFlagsDecl.Flags = DECODE_D3D10_SB_GLOBAL_FLAGS(Token);
        break;

    case D3D10_SB_OPCODE_RESINFO:
        pInstruction->m_ResInfoReturnType = DECODE_D3D10_SB_RESINFO_INSTRUCTION_RETURN_TYPE(Token);
        IFC (ParseOperand(&pInstruction->m_Operands[0]));
        IFC (ParseOperand(&pInstruction->m_Operands[1]));
        IFC (ParseOperand(&pInstruction->m_Operands[2]));
        break;

    case D3D10_1_SB_OPCODE_SAMPLE_INFO:
        pInstruction->m_InstructionReturnType = DECODE_D3D10_SB_INSTRUCTION_RETURN_TYPE(Token);
        IFC (ParseOperand(&pInstruction->m_Operands[0]));
        IFC (ParseOperand(&pInstruction->m_Operands[1]));
        break;

    case D3D10_SB_OPCODE_IF:
    case D3D10_SB_OPCODE_BREAKC:
    case D3D10_SB_OPCODE_CONTINUEC:
    case D3D10_SB_OPCODE_RETC:
    case D3D10_SB_OPCODE_DISCARD:
        pInstruction->SetTest(DECODE_D3D10_SB_INSTRUCTION_TEST_BOOLEAN(Token));
        IFC (ParseOperand(&pInstruction->m_Operands[0]));
        break;

    case D3D10_SB_OPCODE_CALLC:
        pInstruction->SetTest(DECODE_D3D10_SB_INSTRUCTION_TEST_BOOLEAN(Token));
        IFC (ParseOperand(&pInstruction->m_Operands[0]));
        IFC (ParseOperand(&pInstruction->m_Operands[1]));
        break;

    case D3D11_SB_OPCODE_DCL_THREAD_GROUP:
        for(int i = 0 ; i < 3; i++)
        {
            COperandBase* pOperand = &pInstruction->m_Operands[i];
            pOperand->m_NumComponents = D3D10_SB_OPERAND_1_COMPONENT;
            pOperand->m_Type = D3D10_SB_OPERAND_TYPE_IMMEDIATE32;
            pOperand->m_ComponentName = D3D10_SB_4_COMPONENT_X;
            pOperand->m_ComponentSelection = D3D10_SB_OPERAND_4_COMPONENT_SELECT_1_MODE;
            pOperand->m_Value[0] = *m_pCurrentToken++;
        }
        break;

    case D3D11_SB_OPCODE_DCL_FUNCTION_BODY:
        pInstruction->m_FunctionBodyIdx = *m_pCurrentToken++;
        if(pInstruction->m_FunctionBodyIdx < 0) IFC(E_OUTOFMEMORY);
        break;

    case D3D11_SB_OPCODE_DCL_FUNCTION_TABLE:
        pInstruction->m_FunctionTable.FtIdx = *m_pCurrentToken++;
        if(pInstruction->m_FunctionTable.FtIdx < 0) IFC(E_OUTOFMEMORY);
        pInstruction->m_FunctionTable.FbCount = *m_pCurrentToken++;
        pInstruction->m_FunctionTable.pFbStartToken = m_pCurrentToken;
        m_pCurrentToken += pInstruction->m_FunctionTable.FbCount;
        break;

    case D3D11_SB_OPCODE_DCL_INTERFACE:
        pInstruction->m_InterfaceTable.bDynamic = DECODE_D3D11_SB_INTERFACE_INDEXED_BIT(Token);
        pInstruction->m_InterfaceTable.FpIdx = *m_pCurrentToken++;
        if(pInstruction->m_InterfaceTable.FpIdx < 0) IFC(E_OUTOFMEMORY);
        pInstruction->m_InterfaceTable.NumCallSites = *m_pCurrentToken++;
        pInstruction->m_InterfaceTable.FtCount = DECODE_D3D11_SB_INTERFACE_TABLE_LENGTH(*m_pCurrentToken);
        pInstruction->m_InterfaceTable.FpArraySize = DECODE_D3D11_SB_INTERFACE_ARRAY_LENGTH(*m_pCurrentToken++);
        pInstruction->m_InterfaceTable.pFtStartToken = m_pCurrentToken;
        m_pCurrentToken += pInstruction->m_InterfaceTable.FtCount;
        break;

    case D3D11_SB_OPCODE_INTERFACE_CALL:
        pInstruction->m_InterfaceCallSiteIdx = *m_pCurrentToken++;
        if(pInstruction->m_InterfaceCallSiteIdx < 0) IFC(E_OUTOFMEMORY);
        IFC (ParseOperand(&pInstruction->m_Operands[0]));
        break;

    case D3D11_SB_OPCODE_DCL_INPUT_CONTROL_POINT_COUNT:
        pInstruction->m_InputControlPointCountDecl.InputControlPointCount = DECODE_D3D11_SB_INPUT_CONTROL_POINT_COUNT(Token);
        break;
    case D3D11_SB_OPCODE_DCL_OUTPUT_CONTROL_POINT_COUNT:
        pInstruction->m_OutputControlPointCountDecl.OutputControlPointCount = DECODE_D3D11_SB_OUTPUT_CONTROL_POINT_COUNT(Token);
        break;
    case D3D11_SB_OPCODE_DCL_TESS_DOMAIN:
        pInstruction->m_TessellatorDomainDecl.TessellatorDomain = DECODE_D3D11_SB_TESS_DOMAIN(Token);
        break;
    case D3D11_SB_OPCODE_DCL_TESS_PARTITIONING:
        pInstruction->m_TessellatorPartitioningDecl.TessellatorPartitioning = DECODE_D3D11_SB_TESS_PARTITIONING(Token);
        break;
    case D3D11_SB_OPCODE_DCL_TESS_OUTPUT_PRIMITIVE:
        pInstruction->m_TessellatorOutputPrimitiveDecl.TessellatorOutputPrimitive = DECODE_D3D11_SB_TESS_OUTPUT_PRIMITIVE(Token);
        break;
    case D3D11_SB_OPCODE_DCL_HS_MAX_TESSFACTOR:
        pInstruction->m_HSMaxTessFactorDecl.MaxTessFactor = (float)*m_pCurrentToken++;
        break;
    case D3D11_SB_OPCODE_DCL_HS_FORK_PHASE_INSTANCE_COUNT:
        pInstruction->m_HSForkPhaseDecl.InstanceCount = *m_pCurrentToken++;
        break;
    case D3D11_SB_OPCODE_DCL_HS_JOIN_PHASE_INSTANCE_COUNT:
        pInstruction->m_HSJoinPhaseDecl.InstanceCount = *m_pCurrentToken++;
        break;
    case D3D11_SB_OPCODE_HS_CONTROL_POINT_PHASE:
    case D3D11_SB_OPCODE_HS_FORK_PHASE:
    case D3D11_SB_OPCODE_HS_JOIN_PHASE:
           //m_pCurrentToken++;
        break;
    case D3D11_SB_OPCODE_SYNC:
        {
            UINT SyncFlags = DECODE_D3D11_SB_SYNC_FLAGS(Token);
            pInstruction->m_SyncFlags.bThreadsInGroup = (SyncFlags & D3D11_SB_SYNC_THREADS_IN_GROUP) != 0;
            pInstruction->m_SyncFlags.bThreadGroupSharedMemory = (SyncFlags & D3D11_SB_SYNC_THREAD_GROUP_SHARED_MEMORY) != 0;
            pInstruction->m_SyncFlags.bUnorderedAccessViewMemoryGlobal = (SyncFlags & D3D11_SB_SYNC_UNORDERED_ACCESS_VIEW_MEMORY_GLOBAL) != 0;
            pInstruction->m_SyncFlags.bUnorderedAccessViewMemoryGroup = (SyncFlags & D3D11_SB_SYNC_UNORDERED_ACCESS_VIEW_MEMORY_GROUP) != 0;
        }
        break;

    default:
        //
        // It is assumed that operands follow the (extended) instruction token immediatedly.
        //
        for (UINT i = 0; i < pInstruction->m_NumOperands; i++)
        {
            IFC (ParseOperand(&pInstruction->m_Operands[i]));
        }
        break;
    }

    //
    // If ParseOperand() pushed m_pCurrentToken beyond the length of the instruction
    // encoded in the instruction, then something went very wrong.
    //
    // Suggestion: replace <= with a stricter == check to make sure that we do parse instructions correctly.
    //
   SHADER_CONV_ASSERT(m_pCurrentToken <= (pStart + InstructionLength));

    m_pCurrentToken = pStart + InstructionLength;

    m_NumParsedInstructions++;

Cleanup:
    RRETURN(hr);
}

void CShaderCodeParser::Advance(UINT InstructionSize)
{
    m_pCurrentToken += InstructionSize;
    m_NumParsedInstructions++;
}

D3D10_SB_OPCODE_TYPE CShaderCodeParser::CurrentOpcode()
{
   SHADER_CONV_ASSERT(!EndOfShader());

    CONST DWORD CurrentToken = *m_pCurrentToken;

    return DECODE_D3D10_SB_OPCODE_TYPE(CurrentToken);
}

DWORD CShaderCodeParser::CurrentInstructionLength()
{
   SHADER_CONV_ASSERT(!EndOfShader());

    CONST D3D10_SB_OPCODE_TYPE OpCode = DECODE_D3D10_SB_OPCODE_TYPE(m_pCurrentToken[0]);

    if(D3D10_SB_OPCODE_CUSTOMDATA == OpCode)
    {
        return m_pCurrentToken[1];
    }
    else
    {
        return DECODE_D3D10_SB_TOKENIZED_INSTRUCTION_LENGTH(m_pCurrentToken[0]);
    }
}

// ****************************************************************************
//
// class CShaderAsm
//
// ****************************************************************************

void CShaderAsm::EmitOperand(const COperandBase& operand)
{
    if (FAILED(m_Status))
        return;

    HRESULT hr = S_OK;

    CShaderToken Token = ENCODE_D3D10_SB_OPERAND_TYPE(operand.m_Type) |
                            ENCODE_D3D10_SB_OPERAND_NUM_COMPONENTS(operand.m_NumComponents) |
                            ENCODE_D3D10_SB_OPERAND_EXTENDED(operand.m_bExtendedOperand);

    BOOL bProcessOperandIndices = FALSE;
    if (!(operand.m_Type == D3D10_SB_OPERAND_TYPE_IMMEDIATE32 ||
          operand.m_Type == D3D10_SB_OPERAND_TYPE_IMMEDIATE64))
    {
        Token |= ENCODE_D3D10_SB_OPERAND_INDEX_DIMENSION(operand.m_IndexDimension);
        if (operand.m_NumComponents == D3D10_SB_OPERAND_4_COMPONENT)
        {
            // Component selection mode
            Token |= ENCODE_D3D10_SB_OPERAND_4_COMPONENT_SELECTION_MODE(operand.m_ComponentSelection);
            switch(operand.m_ComponentSelection)
            {
            case D3D10_SB_OPERAND_4_COMPONENT_MASK_MODE:
                Token |= ENCODE_D3D10_SB_OPERAND_4_COMPONENT_MASK(operand.m_WriteMask );
                break;
            case D3D10_SB_OPERAND_4_COMPONENT_SWIZZLE_MODE:
                Token |= ENCODE_D3D10_SB_OPERAND_4_COMPONENT_SWIZZLE(operand.m_Swizzle[0],
                                                                operand.m_Swizzle[1],
                                                                operand.m_Swizzle[2],
                                                                operand.m_Swizzle[3]);
                break;
            case D3D10_SB_OPERAND_4_COMPONENT_SELECT_1_MODE:
                Token |= ENCODE_D3D10_SB_OPERAND_4_COMPONENT_SELECT_1(operand.m_ComponentName);
                break;
            default:
                hr = E_OUTOFMEMORY; // Can't return E_INVALIDARG because that is not allowed by the runtime (causes device removed)
                goto Cleanup;
            }
        }

        UINT NumDimensions = operand.m_IndexDimension;
        if (NumDimensions > 0)
        {
            bProcessOperandIndices = TRUE;
            // Encode index representation
            for (UINT i=0; i < NumDimensions; i++)
            {
                Token |= ENCODE_D3D10_SB_OPERAND_INDEX_REPRESENTATION(i, operand.m_IndexType[i]);
            }
        }
        FUNC(Token);
    }

    // Extended operand
    if (operand.m_bExtendedOperand)
    {
        Token = ENCODE_D3D10_SB_EXTENDED_OPERAND_TYPE(operand.m_ExtendedOperandType);
        if (operand.m_ExtendedOperandType == D3D10_SB_EXTENDED_OPERAND_MODIFIER)
        {
            Token |= ENCODE_D3D10_SB_EXTENDED_OPERAND_MODIFIER(operand.m_Modifier);
        }
        FUNC(Token);
    }

    if (operand.m_Type == D3D10_SB_OPERAND_TYPE_IMMEDIATE32 ||
        operand.m_Type == D3D10_SB_OPERAND_TYPE_IMMEDIATE64)
    {
        FUNC(Token);
        UINT n = 0;
        if (operand.m_NumComponents == D3D10_SB_OPERAND_4_COMPONENT)
            n = 4;
        else
        if (operand.m_NumComponents == D3D10_SB_OPERAND_1_COMPONENT)
            n = 1;
        else
        {
            hr = E_OUTOFMEMORY; // Can't return E_INVALIDARG because that is not allowed by the runtime (causes device removed)
            goto Cleanup;
        }
        for (UINT i=0 ; i < n; i++)
        {
            FUNC(operand.m_Value[i]);
        }
    }

    // Operand indices
    if (bProcessOperandIndices)
    {
        const UINT NumDimensions = operand.m_IndexDimension;
        // Encode index representation
        for (UINT i=0; i < NumDimensions; i++)
        {
            switch (operand.m_IndexType[i])
            {
            case D3D10_SB_OPERAND_INDEX_IMMEDIATE32:
                FUNC(operand.m_Index[i].m_RegIndex);
                break;
            case D3D10_SB_OPERAND_INDEX_IMMEDIATE64:
                FUNC(operand.m_Index[i].m_RegIndexA[0]);
                FUNC(operand.m_Index[i].m_RegIndexA[1]);
                break;
            case D3D10_SB_OPERAND_INDEX_IMMEDIATE32_PLUS_RELATIVE:
                FUNC(operand.m_Index[i].m_RegIndex);
                // Fall through
            case D3D10_SB_OPERAND_INDEX_RELATIVE:
                {
                    D3D10_SB_OPERAND_TYPE RelRegType = operand.m_Index[i].m_RelRegType;
                    if( operand.m_Index[i].m_IndexDimension == D3D10_SB_OPERAND_INDEX_2D )
                    {
                        EmitOperand(COperand2D(RelRegType,
                                                    operand.m_Index[i].m_RelIndex,
                                                    operand.m_Index[i].m_RelIndex1,
                                               operand.m_Index[i].m_ComponentName));
                    }
                    else
                    {
                        EmitOperand(COperand4(RelRegType,
                                                   operand.m_Index[i].m_RelIndex,
                                              operand.m_Index[i].m_ComponentName));
                    }
                }
                break;
            default:
                hr = E_OUTOFMEMORY; // Can't return E_INVALIDARG because that is not allowed by the runtime (causes device removed)
                goto Cleanup;
            }
        }
    }

Cleanup:
    if (FAILED(hr))
        m_Status = hr;
}
//-----------------------------------------------------------------------------
void CShaderAsm::EmitInstruction(const CInstruction& instruction)
{
    UINT  OpCode;

    if(instruction.m_OpCode == D3D10_SB_OPCODE_CUSTOMDATA)
    {
        OPCODE(D3D10_SB_OPCODE_CUSTOMDATA);
        FUNC(instruction.m_CustomData.DataSizeInBytes/4 + 2);
        for(UINT i = 0;i < instruction.m_CustomData.DataSizeInBytes/4; i++)
            FUNC(((UINT*)instruction.m_CustomData.pData)[i]);

        ENDINSTRUCTION();
        return;
    }

    OpCode = ENCODE_D3D10_SB_OPCODE_TYPE(instruction.m_OpCode) | ENCODE_D3D10_SB_OPCODE_EXTENDED(instruction.m_bExtended);
    switch (instruction.m_OpCode)
    {
    case D3D10_SB_OPCODE_IF:
    case D3D10_SB_OPCODE_BREAKC:
    case D3D10_SB_OPCODE_CALLC:
    case D3D10_SB_OPCODE_CONTINUEC:
    case D3D10_SB_OPCODE_RETC:
    case D3D10_SB_OPCODE_DISCARD:
        OpCode |= ENCODE_D3D10_SB_INSTRUCTION_TEST_BOOLEAN(instruction.Test());
        break;
    case D3D10_SB_OPCODE_RESINFO:
        OpCode |= ENCODE_D3D10_SB_RESINFO_INSTRUCTION_RETURN_TYPE(instruction.m_ResInfoReturnType);
        break;
    case D3D10_1_SB_OPCODE_SAMPLE_INFO:
        OpCode |= ENCODE_D3D10_SB_INSTRUCTION_RETURN_TYPE(instruction.m_InstructionReturnType);
        break;
    case D3D11_SB_OPCODE_SYNC:
        OpCode |= ENCODE_D3D11_SB_SYNC_FLAGS(
                  ( instruction.m_SyncFlags.bThreadsInGroup ? D3D11_SB_SYNC_THREADS_IN_GROUP : 0 ) |
                  ( instruction.m_SyncFlags.bThreadGroupSharedMemory ? D3D11_SB_SYNC_THREAD_GROUP_SHARED_MEMORY : 0 ) |
                  ( instruction.m_SyncFlags.bUnorderedAccessViewMemoryGlobal ? D3D11_SB_SYNC_UNORDERED_ACCESS_VIEW_MEMORY_GLOBAL : 0 ) |
                  ( instruction.m_SyncFlags.bUnorderedAccessViewMemoryGroup ? D3D11_SB_SYNC_UNORDERED_ACCESS_VIEW_MEMORY_GROUP : 0 ) );
        break;
    };
    OpCode |= ENCODE_D3D10_SB_INSTRUCTION_SATURATE(instruction.m_bSaturate);
    OPCODE(OpCode);

    for(UINT i = 0; i < IntMin(instruction.m_ExtendedOpCodeCount,D3D11_SB_MAX_SIMULTANEOUS_EXTENDED_OPCODES); i++)
    {
        UINT  Extended = ENCODE_D3D10_SB_EXTENDED_OPCODE_TYPE(instruction.m_OpCodeEx[i]);
        switch( instruction.m_OpCodeEx[i] )
        {
        case D3D10_SB_EXTENDED_OPCODE_SAMPLE_CONTROLS:
            {
                Extended |= ENCODE_IMMEDIATE_D3D10_SB_ADDRESS_OFFSET(D3D10_SB_IMMEDIATE_ADDRESS_OFFSET_U, instruction.m_TexelOffset[0]);
                Extended |= ENCODE_IMMEDIATE_D3D10_SB_ADDRESS_OFFSET(D3D10_SB_IMMEDIATE_ADDRESS_OFFSET_V, instruction.m_TexelOffset[1]);
                Extended |= ENCODE_IMMEDIATE_D3D10_SB_ADDRESS_OFFSET(D3D10_SB_IMMEDIATE_ADDRESS_OFFSET_W, instruction.m_TexelOffset[2]);
            }
            break;
        }
        Extended |= ENCODE_D3D10_SB_OPCODE_EXTENDED((i + 1 < instruction.m_ExtendedOpCodeCount) ? true : false);
        FUNC(Extended);
    }

    for (UINT i=0; i < instruction.m_NumOperands; i++)
    {
        EmitOperand(instruction.m_Operands[i]);
    }

    ENDINSTRUCTION();
}

//-----------------------------------------------------------------------------
void CShaderAsm::EmitBinary(CONST DWORD* Ptr, DWORD Count)
{
    Reserve(Count);

    if (SUCCEEDED(m_Status))
    {
       SHADER_CONV_ASSERT((m_Index + Count) <= m_BufferSize);

        CONST D3D10_SB_OPCODE_TYPE OpCode = DECODE_D3D10_SB_OPCODE_TYPE(Ptr[0]);

        if(D3D10_SB_OPCODE_CUSTOMDATA == OpCode)
        {
            CONST D3D10_SB_CUSTOMDATA_CLASS Class = DECODE_D3D10_SB_CUSTOMDATA_CLASS(Ptr[0]);
            CONST DWORD DataSize = Ptr[1];
           SHADER_CONV_ASSERT(DataSize == Count);
           SHADER_CONV_ASSERT(DataSize >= 2);

            EmitCustomData(Class, DataSize - 2, (CONST UINT*)(Ptr + 2));
        }
        else
        {
           SHADER_CONV_ASSERT((m_Index + Count) <= m_BufferSize);

            memcpy(m_dwFunc + m_Index, Ptr, sizeof(DWORD) * Count);

            m_StartOpIndex = m_Index; // so that ENDINSTRUCTION writes the instruction length to the correct place

            m_Index += Count;

            ENDINSTRUCTION();
        }
    }
}


```

`ShaderConverter/ShaderBinary/pch.hpp`:

```hpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/*==========================================================================;
*
*  Copyright (C) Microsoft Corporation.  All rights reserved.
*
*  Precompiled header file
*
****************************************************************************/
#pragma once

//
// Disable optimize for speed and instead optimize for size in this library
//
#pragma optimize ("s", on)
#pragma optimize ("t", off)

//
// DDK headers
//
#pragma warning( push,3 )
#undef WIN32_LEAN_AND_MEAN
#include "d3d11.h"
#include "d3d10_1.h"
#define D3D12_TOKENIZED_PROGRAM_FORMAT_HEADER
#include "d3d10umddi.h"
#pragma warning( pop )

#include <ShaderConvCommon.h>

//
// Other external headers
//
#include <stdio.h>

//
// WARP headers
//
#include <ShaderBinary.h>

```

`ShaderConverter/ShaderConv/ShaderBinaryEx.cpp`:

```cpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/*==========================================================================;
*
*  Copyright (C) Microsoft Corporation.  All Rights Reserved.
*
*  Implementation for The Shader Binary Extension class
*
****************************************************************************/

#include "pch.h"

#if DBG && WARP_INTERNAL

namespace ShaderConv
{

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
bool
DisassembleInstruction( const CInstruction& instruction,
                        __out_ecount(StringSize) __nullterminated LPSTR pString,
                        __in_range(>,0) UINT StringSize )
{
    char szName[33] = {'\0'};

    //if ( !const_cast<CInstruction&>( instruction ).Disassemble( szName, _countof( szName ) ) )
    //{
    //    return false;
    //}

    int Ret = -1;

    switch ( instruction.OpCode() )
    {
    case D3D10_SB_OPCODE_DCL_TEMPS:
        Ret = WarpPlatform::StringPrintf(pString, StringSize, "%s %u", szName, instruction.m_TempsDecl.NumTemps );
        break;

    default:
        Ret = WarpPlatform::StringPrintf(pString, StringSize, "%s", szName );
        break;
    }

    return Ret != -1;
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
bool
DisassembleOperand( const COperandBase& operand,
                    __out_ecount(StringSize) LPSTR pString,
                    __in_range(>,0) UINT StringSize )
{
    int Ret = -1;

    *pString = '\0';

    switch ( operand.OperandType() )
    {
    case D3D10_SB_OPERAND_TYPE_TEMP:
        Ret = WarpPlatform::StringPrintf(pString, StringSize, "r%u", operand.RegIndex(0));
        break;

    case D3D10_SB_OPERAND_TYPE_INPUT:
        Ret = WarpPlatform::StringPrintf(pString, StringSize, "v[%u]", operand.RegIndex(0));
        break;

    case D3D10_SB_OPERAND_TYPE_OUTPUT:
        Ret = WarpPlatform::StringPrintf(pString, StringSize, "o[%u]", operand.RegIndex(0));
        break;

    case D3D10_SB_OPERAND_TYPE_INDEXABLE_TEMP:
        Ret = WarpPlatform::StringPrintf(pString, StringSize, "x[Unknown Index]");
        break;

    case D3D10_SB_OPERAND_TYPE_IMMEDIATE32:
        Ret = WarpPlatform::StringPrintf(pString, StringSize, "vec4(%u, %u, %u, %u)", operand.m_Value[0], operand.m_Value[1], operand.m_Value[2], operand.m_Value[3]);
        break;

    case D3D10_SB_OPERAND_TYPE_SAMPLER:
        Ret = WarpPlatform::StringPrintf(pString, StringSize, "s%u", operand.RegIndex(0));
        break;

    case D3D10_SB_OPERAND_TYPE_RESOURCE:
        Ret = WarpPlatform::StringPrintf(pString, StringSize, "t%u", operand.RegIndex(0));
        break;

    case D3D10_SB_OPERAND_TYPE_CONSTANT_BUFFER:
        if ( D3D10_SB_OPERAND_INDEX_IMMEDIATE32 == operand.OperandIndexType( 1 ) )
        {
            Ret = WarpPlatform::StringPrintf(pString, StringSize, "cb%u[%u]", operand.RegIndex(0), operand.RegIndex(1));
        }
        else
        {
            Ret = WarpPlatform::StringPrintf(pString, StringSize, "cb%u", operand.RegIndex(0));
        }
        break;

    case D3D10_SB_OPERAND_TYPE_IMMEDIATE_CONSTANT_BUFFER:
        if ( D3D10_SB_OPERAND_INDEX_IMMEDIATE32 == operand.OperandIndexType( 1 ) )
        {
            Ret = WarpPlatform::StringPrintf(pString, StringSize, "icb%u[%u]", operand.RegIndex(0), operand.RegIndex(1));
        }
        else
        {
            Ret = WarpPlatform::StringPrintf(pString, StringSize, "icb%u", operand.RegIndex(0));
        }
        break;

    case D3D10_SB_OPERAND_TYPE_LABEL:
        Ret = WarpPlatform::StringPrintf(pString, StringSize, "L%u", operand.RegIndex(0));
        break;

    case D3D10_SB_OPERAND_TYPE_INPUT_PRIMITIVEID:
        Ret = WarpPlatform::StringPrintf(pString, StringSize, "PrimID");
        break;

    case D3D10_SB_OPERAND_TYPE_OUTPUT_DEPTH:
        Ret = WarpPlatform::StringPrintf(pString, StringSize, "oDepth");
        break;

    case D3D10_SB_OPERAND_TYPE_NULL:
        Ret = WarpPlatform::StringPrintf(pString, StringSize, "NULL");
        break;

    case D3D10_SB_OPERAND_TYPE_RASTERIZER:
        Ret = WarpPlatform::StringPrintf(pString, StringSize, "Rasterizer");
        break;

    case D3D10_SB_OPERAND_TYPE_OUTPUT_COVERAGE_MASK:
        Ret = WarpPlatform::StringPrintf(pString, StringSize, "oMask");
        break;
    }

    return ( Ret != -1 );
}

} // namespace ShaderConv

#endif //DBG && WARP_INTERNAL

```

`ShaderConverter/ShaderConv/ShaderBinaryEx.hpp`:

```hpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/*==========================================================================;
*
*  Copyright (C) Microsoft Corporation.  All Rights Reserved.
*
*  Header Definitions for The Shader Binary Extension class
*
****************************************************************************/

#pragma once
#include <cmath>

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
#define __SWIZZLE1( x ) \
    ( ( (x) << 7 ) | ( (x) << 5 ) | ( (x) << 3 ) | ( (x) << 1 ) | 0x1 )

#define __SWIZZLE2( x, y ) \
    ( ( (y) << 7 ) | ( (y) << 5 ) | ( (y) << 3 ) | ( (x) << 1 ) | 0x1 )

#define __SWIZZLE3( x, y, z ) \
    ( ( (z) << 7 ) | ( (z) << 5 ) | ( (y) << 3 ) | ( (x) << 1 ) | 0x1 )

#define __SWIZZLE4( x, y, z, w ) \
    ( ( (w) << 7 ) | ( (z) << 5 ) | ( (y) << 3 ) | ( (x) << 1 ) | 0x1 )

#define __SWIZZLE_ALL \
    __SWIZZLE4(D3D10_SB_4_COMPONENT_X, \
               D3D10_SB_4_COMPONENT_Y, \
               D3D10_SB_4_COMPONENT_Z, \
               D3D10_SB_4_COMPONENT_W)

#define __SWIZZLEN( i, value ) \
    ( ( (value) << ( 1 + 2 * (i) ) ) | 0x1 )

#define __UNSWIZZLEN( i, mask ) \
    ( ( (mask) >> ( 1 + 2 * (i) ) ) & 0x3 )

#define __SWIZZLE_X \
    __SWIZZLE1(D3D10_SB_4_COMPONENT_X)

#define __SWIZZLE_Y \
    __SWIZZLE1(D3D10_SB_4_COMPONENT_Y)

#define __SWIZZLE_Z \
    __SWIZZLE1(D3D10_SB_4_COMPONENT_Z)

#define __SWIZZLE_W \
    __SWIZZLE1(D3D10_SB_4_COMPONENT_W)

#define __SWIZZLE_XY \
    __SWIZZLE2(D3D10_SB_4_COMPONENT_X, \
               D3D10_SB_4_COMPONENT_Y)

#define __SWIZZLE_YZ \
    __SWIZZLE2(D3D10_SB_4_COMPONENT_Y, \
               D3D10_SB_4_COMPONENT_Z)

#define __SWIZZLE_ZY \
    __SWIZZLE2(D3D10_SB_4_COMPONENT_Z, \
               D3D10_SB_4_COMPONENT_Y)

#define __SWIZZLE_ZW \
    __SWIZZLE2(D3D10_SB_4_COMPONENT_Z, \
               D3D10_SB_4_COMPONENT_W)

#define __SWIZZLE_WX \
    __SWIZZLE2(D3D10_SB_4_COMPONENT_W, \
               D3D10_SB_4_COMPONENT_X)

#define __SWIZZLE_XYZ \
    __SWIZZLE3(D3D10_SB_4_COMPONENT_X, \
               D3D10_SB_4_COMPONENT_Y, \
               D3D10_SB_4_COMPONENT_Z)

#define __SWIZZLE_XXY \
    __SWIZZLE3(D3D10_SB_4_COMPONENT_X, \
               D3D10_SB_4_COMPONENT_X, \
               D3D10_SB_4_COMPONENT_Y)

#define __SWIZZLE_XZX \
    __SWIZZLE3(D3D10_SB_4_COMPONENT_X, \
               D3D10_SB_4_COMPONENT_Z, \
               D3D10_SB_4_COMPONENT_X)

#define __SWIZZLE_XXZ \
    __SWIZZLE3(D3D10_SB_4_COMPONENT_X, \
               D3D10_SB_4_COMPONENT_X, \
               D3D10_SB_4_COMPONENT_Z)

#define __SWIZZLE_ZXY \
    __SWIZZLE3(D3D10_SB_4_COMPONENT_Z, \
               D3D10_SB_4_COMPONENT_X, \
               D3D10_SB_4_COMPONENT_Y)

#define __SWIZZLE_YZX \
    __SWIZZLE3(D3D10_SB_4_COMPONENT_Y, \
               D3D10_SB_4_COMPONENT_Z, \
               D3D10_SB_4_COMPONENT_X)

#define __SWIZZLE_XXXY \
    __SWIZZLE4(D3D10_SB_4_COMPONENT_X, \
               D3D10_SB_4_COMPONENT_X, \
               D3D10_SB_4_COMPONENT_X, \
               D3D10_SB_4_COMPONENT_Y)

#define __SWIZZLE_XXYX \
    __SWIZZLE4(D3D10_SB_4_COMPONENT_X, \
               D3D10_SB_4_COMPONENT_X, \
               D3D10_SB_4_COMPONENT_Y, \
               D3D10_SB_4_COMPONENT_X)

#define __WRITEMASK_XY \
    ( D3D10_SB_OPERAND_4_COMPONENT_MASK_X | \
      D3D10_SB_OPERAND_4_COMPONENT_MASK_Y )

#define __WRITEMASK_XZ \
    ( D3D10_SB_OPERAND_4_COMPONENT_MASK_X | \
      D3D10_SB_OPERAND_4_COMPONENT_MASK_Z )

#define __WRITEMASK_XW \
    ( D3D10_SB_OPERAND_4_COMPONENT_MASK_X | \
      D3D10_SB_OPERAND_4_COMPONENT_MASK_W )

#define __WRITEMASK_YZ \
    ( D3D10_SB_OPERAND_4_COMPONENT_MASK_Y | \
      D3D10_SB_OPERAND_4_COMPONENT_MASK_Z )

#define __WRITEMASK_ZW \
    ( D3D10_SB_OPERAND_4_COMPONENT_MASK_Z | \
      D3D10_SB_OPERAND_4_COMPONENT_MASK_W )

#define __WRITEMASK_YZW \
    ( D3D10_SB_OPERAND_4_COMPONENT_MASK_Y | \
      D3D10_SB_OPERAND_4_COMPONENT_MASK_Z | \
      D3D10_SB_OPERAND_4_COMPONENT_MASK_W )

#define __WRITEMASK_XYZ \
    ( D3D10_SB_OPERAND_4_COMPONENT_MASK_X | \
      D3D10_SB_OPERAND_4_COMPONENT_MASK_Y | \
      D3D10_SB_OPERAND_4_COMPONENT_MASK_Z )

namespace ShaderConv
{

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
inline
void
SetSwizzle( COperandBase& operand, UINT swizzle)
{
    if ( swizzle )
    {
        if ( D3D10_SB_OPERAND_TYPE_IMMEDIATE32 == operand.OperandType() )
        {
            float fTmp[4];
            for ( UINT i = 0; i < 4; ++i )
            {
                const UINT comp = __UNSWIZZLEN( i, swizzle );
                fTmp[i] = operand.m_Valuef[comp];
            }

            for ( UINT i = 0; i < 4; ++i )
            {
                operand.m_Valuef[i] = fTmp[i];
            }
        }
        else
        {
            operand.m_ComponentSelection = D3D10_SB_OPERAND_4_COMPONENT_SWIZZLE_MODE;
            for ( UINT i = 0; i < 4; ++i )
            {
                operand.m_Swizzle[i] = (BYTE)__UNSWIZZLEN( i, swizzle );
            }
        }
    }
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
inline
void
SetAsSingleComponent(COperandBase& operand, D3D10_SB_4_COMPONENT_NAME component)
{
    if (operand.m_Type == D3D10_SB_OPERAND_TYPE_IMMEDIATE32)
    {
        operand.m_NumComponents = D3D10_SB_OPERAND_1_COMPONENT;
        operand.m_Value[0] = operand.m_Value[component];
    }
    else
    {
        operand.m_NumComponents = D3D10_SB_OPERAND_4_COMPONENT;
    }
    operand.m_ComponentSelection = D3D10_SB_OPERAND_4_COMPONENT_SELECT_1_MODE;
    operand.m_ComponentName = component;
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
inline
void
SetRelAddress( COperandBase& operand,
               UINT index,
               D3D10_SB_OPERAND_TYPE relRegType,
               UINT relRegIndex,
               D3D10_SB_4_COMPONENT_NAME relComponentName )
{
    operand.m_IndexType[index]                = D3D10_SB_OPERAND_INDEX_IMMEDIATE32_PLUS_RELATIVE;
    operand.m_Index[index].m_RelRegType        = relRegType;
    operand.m_Index[index].m_RelIndex        = relRegIndex;
    operand.m_Index[index].m_IndexDimension = D3D10_SB_OPERAND_INDEX_1D;
    operand.m_Index[index].m_ComponentName    = relComponentName;
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
class COperand2DEx: public COperand2D
{
public:
    COperand2DEx( D3D10_SB_OPERAND_TYPE type, UINT regIndex0, UINT regIndex1 ) :
      COperand2D( type, regIndex0, regIndex1 ) {}

    COperand2DEx( D3D10_SB_OPERAND_TYPE type, UINT regIndex0, UINT regIndex1, UINT swizzle ) :
        COperand2D( type, regIndex0, regIndex1 )
    {
        SetSwizzle( *this, swizzle );
    }
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
class CCBOperand2D: public COperand2DEx
{
public:
    CCBOperand2D( UINT regIndex0, UINT regIndex1 ) :
      COperand2DEx( D3D10_SB_OPERAND_TYPE_CONSTANT_BUFFER, regIndex0, regIndex1 ) {}

    CCBOperand2D( UINT regIndex0, UINT regIndex1, UINT swizzle ) :
      COperand2DEx( D3D10_SB_OPERAND_TYPE_CONSTANT_BUFFER, regIndex0, regIndex1, swizzle ) {}
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
class CTempOperand2D: public COperand2DEx
{
public:
    CTempOperand2D( UINT regIndex0, UINT regIndex1 ) :
        COperand2DEx( D3D10_SB_OPERAND_TYPE_INDEXABLE_TEMP, regIndex0, regIndex1 ) {}

    CTempOperand2D( UINT regIndex0, UINT regIndex1, UINT swizzle ) :
        COperand2DEx( D3D10_SB_OPERAND_TYPE_INDEXABLE_TEMP, regIndex0, regIndex1, swizzle ) {}
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
class COperand1Ex : public COperand4
{
public:
    COperand1Ex(D3D10_SB_OPERAND_TYPE type, UINT regIndex, D3D10_SB_4_COMPONENT_NAME component) :
        COperand4(type, regIndex, component) {}
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
class CTempOperand1 : public COperand1Ex
{
public:
    CTempOperand1(UINT regIndex, D3D10_SB_4_COMPONENT_NAME component) :
        COperand1Ex(D3D10_SB_OPERAND_TYPE_TEMP, regIndex, component) {}
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
class COperand4Ex : public COperand4
{
public:

    COperand4Ex(D3D10_SB_OPERAND_TYPE type, UINT regIndex) :
        COperand4(type, regIndex) {}

    COperand4Ex(D3D10_SB_OPERAND_TYPE type, UINT regIndex, UINT swizzle) :
        COperand4(type, regIndex)
    {
        SetSwizzle(*this, swizzle);
    }
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
class CTempOperandDst : public COperandDst
{
public:

    CTempOperandDst( UINT regIndex, UINT writeMask = D3D10_SB_OPERAND_4_COMPONENT_MASK_ALL ) :
        COperandDst( D3D10_SB_OPERAND_TYPE_TEMP, regIndex, writeMask ) {}
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
class CTempOperandDst2D : public COperandDst
{
public:

    CTempOperandDst2D( UINT regIndex0, UINT regIndex1, UINT writeMask = D3D10_SB_OPERAND_4_COMPONENT_MASK_ALL ) :
        COperandDst( D3D10_SB_OPERAND_TYPE_INDEXABLE_TEMP, regIndex0, regIndex1, writeMask ) {}
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
class CTempOperand4 : public COperand4Ex
{
public:

    CTempOperand4( UINT regIndex ) :
        COperand4Ex( D3D10_SB_OPERAND_TYPE_TEMP, regIndex ) {}

    CTempOperand4( UINT regIndex, UINT swizzle ) :
        COperand4Ex( D3D10_SB_OPERAND_TYPE_TEMP, regIndex, swizzle ) {}
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
class CInputOperand4 : public COperand4Ex
{
public:

    CInputOperand4( UINT regIndex ) :
        COperand4Ex( D3D10_SB_OPERAND_TYPE_INPUT, regIndex ) {}

    CInputOperand4( UINT regIndex, UINT swizzle ) :
        COperand4Ex( D3D10_SB_OPERAND_TYPE_INPUT, regIndex, swizzle ) {}
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
class CResOperand4 : public COperand4Ex
{
public:

    CResOperand4( UINT regIndex ) :
        COperand4Ex( D3D10_SB_OPERAND_TYPE_RESOURCE, regIndex ) {}

    CResOperand4( UINT regIndex, UINT swizzle ) :
        COperand4Ex( D3D10_SB_OPERAND_TYPE_RESOURCE, regIndex, swizzle ) {}
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
class CWriteMask : public COperandBase
{
public:

    CWriteMask( const COperandBase& operand, UINT writeMask ) : COperandBase( operand )
    {
        m_WriteMask = writeMask;
    }
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
class CSwizzle : public COperandBase
{
public:

    CSwizzle( const COperandBase& operand, UINT swizzle ) : COperandBase( operand )
    {
        SetSwizzle( *this, swizzle );
    }
};

class CSingleComponent : public COperandBase
{
public:

    CSingleComponent(const COperandBase& operand, D3D10_SB_4_COMPONENT_NAME component) : COperandBase(operand)
    {
        SetAsSingleComponent(*this, component);
    }
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
class CNegate : public COperandBase
{
public:

    CNegate( const COperandBase& operand ) : COperandBase( operand )
    {
        if ( D3D10_SB_OPERAND_TYPE_IMMEDIATE32 == m_Type )
        {
            for ( UINT i = 0; i < 4; ++i )
            {
                m_Valuef[i] = -m_Valuef[i];
            }
        }
        else
        {
            const D3D10_SB_OPERAND_MODIFIER modifier = m_Modifier;
            switch ( modifier )
            {
            case D3D10_SB_OPERAND_MODIFIER_NONE:
                this->SetModifier( D3D10_SB_OPERAND_MODIFIER_NEG );
                break;

            case D3D10_SB_OPERAND_MODIFIER_NEG:
                this->SetModifier( D3D10_SB_OPERAND_MODIFIER_NONE );
                break;

            case D3D10_SB_OPERAND_MODIFIER_ABS:
                this->SetModifier( D3D10_SB_OPERAND_MODIFIER_ABSNEG );
                break;

            case D3D10_SB_OPERAND_MODIFIER_ABSNEG:
                this->SetModifier( D3D10_SB_OPERAND_MODIFIER_ABS );
                break;
            }
        }
    }
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
class CAbs : public COperandBase
{
public:

    CAbs( const COperandBase& operand ) : COperandBase( operand )
    {
        if ( D3D10_SB_OPERAND_TYPE_IMMEDIATE32 == m_Type )
        {
            for ( UINT i = 0; i < 4; ++i )
            {
                m_Valuef[i] = fabs( m_Valuef[i] );
            }
        }
        else
        {
            const D3D10_SB_OPERAND_MODIFIER modifier = m_Modifier;
            switch ( modifier )
            {
            case D3D10_SB_OPERAND_MODIFIER_NONE:
            case D3D10_SB_OPERAND_MODIFIER_NEG:
            case D3D10_SB_OPERAND_MODIFIER_ABSNEG:
                this->SetModifier( D3D10_SB_OPERAND_MODIFIER_ABS );
                break;
            }
        }
    }
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
class CInstructionEx : public CInstruction
{
public:

    CInstructionEx(D3D10_SB_OPCODE_TYPE opCode) :
      CInstruction(opCode) {}

    CInstructionEx( D3D10_SB_OPCODE_TYPE opCode,
                    bool bSaturate,
                    const COperandBase& dstOperand,
                    const COperandBase& srcOperand0 ) :
        CInstruction( opCode, dstOperand, srcOperand0 )
    {
        m_bSaturate = bSaturate;
    }

    CInstructionEx( D3D10_SB_OPCODE_TYPE OpCode,
                    D3D10_SB_INSTRUCTION_TEST_BOOLEAN Test,
                    const COperandBase& Operand0,
                    const COperandBase& Operand1 )
    {
        this->Clear();
        m_OpCode = OpCode;
        m_NumOperands = 2;
        m_bExtended = FALSE;
        m_Test = Test;
        m_Operands[0] = Operand0;
        m_Operands[1] = Operand1;
    }

    CInstructionEx( D3D10_SB_OPCODE_TYPE opCode,
                    bool bSaturate,
                    const COperandBase& dstOperand,
                    const COperandBase& srcOperand0,
                    const COperandBase& srcOperand1 ) :
        CInstruction( opCode, dstOperand, srcOperand0, srcOperand1 )
    {
        m_bSaturate = bSaturate;
    }

    CInstructionEx( D3D10_SB_OPCODE_TYPE opCode,
                    bool bSaturate,
                    const COperandBase& dstOperand,
                    const COperandBase& srcOperand0,
                    const COperandBase& srcOperand1,
                    const COperandBase& srcOperand2 ) :
        CInstruction( opCode, dstOperand, srcOperand0, srcOperand1, srcOperand2 )
    {
        m_bSaturate = bSaturate;
    }

    CInstructionEx( D3D10_SB_OPCODE_TYPE opCode, const COperandBase& dstOperand )
    {
        this->Clear();
        m_OpCode      = opCode;
        m_NumOperands = 1;
        m_bExtended   = FALSE;
        m_Operands[0] = dstOperand;
    }

    void SetOperand(UINT index, const COperandBase& operand)
    {
        m_Operands[index] = operand;
        if (++index > m_NumOperands)
        {
            m_NumOperands = index;
        }
    }

    void SetSaturate(bool bSaturate)
    {
        m_bSaturate = bSaturate;
    }
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
class CCallInstruction : public CInstruction
{
public:

    CCallInstruction( UINT uiLabel )
    {
        m_Operands[0] = COperand( uiLabel );
        m_Operands[0].m_Type = D3D10_SB_OPERAND_TYPE_LABEL;
        m_Operands[0].m_NumComponents = D3D10_SB_OPERAND_0_COMPONENT;
        m_Operands[0].m_IndexDimension = D3D10_SB_OPERAND_INDEX_1D;
        m_Operands[0].m_IndexType[0] = D3D10_SB_OPERAND_INDEX_IMMEDIATE32;
        m_Operands[0].m_Index[0].m_RegIndex = uiLabel;
        m_NumOperands = 1;
        m_OpCode = D3D10_SB_OPCODE_CALL;
    }
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
class CLabelInstruction : public CInstruction
{
public:

    CLabelInstruction( UINT uiLabel )
    {
        m_Operands[0] = COperand( uiLabel );
        m_Operands[0].m_Type = D3D10_SB_OPERAND_TYPE_LABEL;
        m_Operands[0].m_NumComponents = D3D10_SB_OPERAND_0_COMPONENT;
        m_Operands[0].m_IndexDimension = D3D10_SB_OPERAND_INDEX_1D;
        m_Operands[0].m_IndexType[0] = D3D10_SB_OPERAND_INDEX_IMMEDIATE32;
        m_Operands[0].m_Index[0].m_RegIndex = uiLabel;
        m_NumOperands = 1;
        m_OpCode = D3D10_SB_OPCODE_LABEL;
    }
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
class CLoopInstruction : public CInstruction
{
public:

    CLoopInstruction()
    {
        m_NumOperands = 0;
        m_OpCode = D3D10_SB_OPCODE_LOOP;
    }
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
class CEndLoopInstruction : public CInstruction
{
public:

    CEndLoopInstruction()
    {
        m_NumOperands = 0;
        m_OpCode = D3D10_SB_OPCODE_ENDLOOP;
    }
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
class CRetInstruction : public CInstruction
{
public:

    CRetInstruction()
    {
        m_NumOperands = 0;
        m_OpCode = D3D10_SB_OPCODE_RET;
    }
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
class CBreakInstruction : public CInstruction
{
public:

    CBreakInstruction()
    {
        m_NumOperands = 0;
        m_OpCode = D3D10_SB_OPCODE_BREAK;
    }
};

} // namespace ShaderConv
```

`ShaderConverter/ShaderConv/ShaderConv.cpp`:

```cpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/*==========================================================================;
*
*  Copyright (C) Microsoft Corporation.  All Rights Reserved.
*
*  Implementation for the Shader Converter objects
*
****************************************************************************/

#include "pch.h"
#include "shaderconv.hpp"

namespace ShaderConv
{

void ShaderConverterAPI::CleanUpConvertedShader(ByteCode& byteCode)
{
    free(byteCode.m_pByteCode);
}

ShaderConverterAPI::~ShaderConverterAPI()
{
    if (m_pTranslator)
    {
        m_pTranslator->Release();
    }
}

HRESULT AllocTemporarySpace(ByteCode& code, size_t size)
{
    code.m_pByteCode = malloc(size);

    if (code.m_pByteCode)
    {
        code.m_byteCodeSize = size;
        return S_OK;
    }

    code.m_byteCodeSize = 0;
    return E_OUTOFMEMORY;
}

HRESULT ShaderConverterAPI::ConvertTLShader(ConvertTLShaderArgs& args)
{
    HRESULT hr = S_OK;

    if (m_pTranslator == nullptr)
    {
        hr = ShaderConv::CreateTranslator(args.apiVersion, &m_pTranslator);
    }
    if (SUCCEEDED(hr) && m_pTranslator)
    {
        const CTLVertexShaderDesc desc(args.vsInputDecl, args.shaderSettings);
        CComPtr<CCodeBlob> pCodeBlob;
        
        hr = m_pTranslator->TranslateTLVS(&desc, &pCodeBlob);
        if (SUCCEEDED(hr) && pCodeBlob)
        {
            hr = AllocTemporarySpace(args.convertedByteCode, pCodeBlob->GetBufferSize());

            if (SUCCEEDED(hr))
            {
                memcpy(args.convertedByteCode.m_pByteCode, pCodeBlob->GetBufferPointer(), pCodeBlob->GetBufferSize());

                args.vsOutputDecl = desc.GetOutputDecls();
            }
            else
            {
                Check(false);
            }
        }

        auto translationData = m_pTranslator->GetTranslationData();
        args.totalInstructionsEmitted = translationData.NumInstructionsEmitted;
        args.totalExtraInstructionsEmitted = translationData.NumExtraInstructionsEmitted;
    }

    return hr;
}

void AddAllAddedSystemSemantics(const VSOutputDecls &pixelShaderInput, std::vector<VSOutputDecl> &addedSystemSemantics)
{
    // This informs 9on12 that it can't just re-use the vertex-shader's output signature for 
    // the pixel shader's input signature when the pixel shader has added an extra system value input. 
    auto pDecl = pixelShaderInput.FindOutputDecl(D3DDECLUSAGE_VFACE, 0);
    if (pDecl)
    {
        addedSystemSemantics.push_back(*pDecl);
    }
}

HRESULT ShaderConverterAPI::ConvertShader(ConvertShaderArgs& args)
{
    HRESULT hr = S_OK;

    if (args.legacyByteCode.m_pByteCode == nullptr)
    {
        hr = E_INVALIDARG;
    }

    VSOutputDecls* pPSin = args.pPsInputDecl;
    VSInputDecls* pVSin = args.pVsInputDecl;
    VSOutputDecls* pVSout = args.pVsOutputDecl;
    const RasterStates& rasterState = args.rasterStates;
    CComPtr<CCodeBlob> pCodeBlob;

    if (m_pTranslator == nullptr)
    {
        hr = ShaderConv::CreateTranslator(args.apiVersion, &m_pTranslator);
    }
    if (SUCCEEDED(hr) && m_pTranslator)
    {
        if (args.type == ConvertShaderArgs::SHADER_TYPE::SHADER_TYPE_VERTEX)//VS
        {
            CVertexShaderDesc* pDesc = nullptr;
            hr = m_pTranslator->AnalyzeVS(args.legacyByteCode.m_pByteCode, UINT(args.legacyByteCode.m_byteCodeSize), args.shaderSettings, args.rasterStates, args.pVsInputDecl, &pDesc);
            if (SUCCEEDED(hr) && pDesc)
            {
                // If the shader uses dynamic indexing, we have no way of knowing how large the CB is
                if (pDesc->HasRelAddrConsts(ShaderConv::CB_FLOAT))
                {
                    args.maxFloatConstsUsed = MAX_VS_CONSTANTSF * 4;
                }
                else
                {
                    args.maxFloatConstsUsed = pDesc->GetMaxUsedConsts(eConstantBuffers::CB_FLOAT);
                }

                Check(!pDesc->HasRelAddrConsts(ShaderConv::CB_INT));
                Check(!pDesc->HasRelAddrConsts(ShaderConv::CB_BOOL));
                args.maxIntConstsUsed = pDesc->GetMaxUsedConsts(eConstantBuffers::CB_INT);
                args.maxBoolConstsUsed = pDesc->GetMaxUsedConsts(eConstantBuffers::CB_BOOL);

                *pVSin = pDesc->GetInputDecls();
                memcpy(pVSout, &pDesc->GetOutputDecls(), sizeof(*pVSout));

                hr = m_pTranslator->TranslateVS(pDesc, rasterState, &pCodeBlob);

                for (UINT i = 0; i < ARRAYSIZE(args.m_inlineConsts); i++)
                {
                    args.m_inlineConsts[i] = std::move(pDesc->MoveInlineConstants((eConstantBuffers)i));
                }

                pDesc->Release();
            }
        }
        else//PS
        {
            if (pPSin)
            {
                CPixelShaderDesc* pDesc = nullptr;
                hr = m_pTranslator->AnalyzePS(args.legacyByteCode.m_pByteCode, UINT(args.legacyByteCode.m_byteCodeSize), args.shaderSettings, args.rasterStates, &pDesc);

                if (SUCCEEDED(hr) && pDesc)
                {
                    if (pDesc->HasRelAddrConsts(ShaderConv::CB_FLOAT))
                    {
                        args.maxFloatConstsUsed = MAX_PS_CONSTANTSF * 4;
                    }
                    else
                    {
                        args.maxFloatConstsUsed = pDesc->GetMaxUsedConsts(eConstantBuffers::CB_FLOAT);
                    }

                    Check(!pDesc->HasRelAddrConsts(ShaderConv::CB_INT));
                    Check(!pDesc->HasRelAddrConsts(ShaderConv::CB_BOOL));
                    args.maxIntConstsUsed = pDesc->GetMaxUsedConsts(eConstantBuffers::CB_INT);
                    args.maxBoolConstsUsed = pDesc->GetMaxUsedConsts(eConstantBuffers::CB_BOOL);

                    VSOutputDecls updatedInputDecls;
                    pDesc->UpdateInputDecls(*pPSin, rasterState, &updatedInputDecls);
                    hr = m_pTranslator->TranslatePS(pDesc, rasterState, updatedInputDecls, &pCodeBlob);
                    
                    AddAllAddedSystemSemantics(updatedInputDecls, args.AddedSystemSemantics);

                    for (UINT i = 0; i < ARRAYSIZE(args.m_inlineConsts); i++)
                    {
                        args.m_inlineConsts[i] = std::move(pDesc->MoveInlineConstants((eConstantBuffers)i));
                    }
                    args.outputRegistersMask = pDesc->GetOutputRegistersMask();

                    pDesc->Release();
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }
        auto translationData = m_pTranslator->GetTranslationData();
        args.totalInstructionsEmitted = translationData.NumInstructionsEmitted;
        args.totalExtraInstructionsEmitted = translationData.NumExtraInstructionsEmitted;

        if (SUCCEEDED(hr) && pCodeBlob)
        {
            // DXBC needs to be 4 byte aligned for dxilconv
            UINT padding = 0;
            UINT bufferSizeMod4 = pCodeBlob->GetBufferSize() % 4;
            if (bufferSizeMod4 != 0)
            {
                padding = 4 - bufferSizeMod4;
            }
            hr = AllocTemporarySpace(args.convertedByteCode, pCodeBlob->GetBufferSize());
            if (SUCCEEDED(hr))
            {
                memcpy(args.convertedByteCode.m_pByteCode, pCodeBlob->GetBufferPointer(), pCodeBlob->GetBufferSize());
                if (padding > 0)
                {
                    ZeroMemory((BYTE*)args.convertedByteCode.m_pByteCode + pCodeBlob->GetBufferSize(), padding);
                }
            }
            else
            {
                Check(false);
            }
        }
    }

    return hr;
}

HRESULT ShaderConverterAPI::CreateGeometryShader(CreateGeometryShaderArgs& args)
{
    HRESULT hr = S_OK;

    CGeometryShaderDesc geoDesc = CGeometryShaderDesc(args.m_ApiVersion, args.m_ShaderSettings, args.m_VsOutputDecls, args.m_RasterStates);

    CComPtr<CCodeBlob> pCodeBlob;

    // Translate the shader code from HLSL 2.0 to 4.0
    hr = m_pTranslator->TranslateGS(&geoDesc, &pCodeBlob);

    if (SUCCEEDED(hr))
    {
        // DXBC needs to be 4 byte aligned for dxilconv
        UINT padding = 0;
        UINT bufferSizeMod4 = pCodeBlob->GetBufferSize() % 4;
        if (bufferSizeMod4 != 0)
        {
            padding = 4 - bufferSizeMod4;
        }
        hr = AllocTemporarySpace(args.m_GSByteCode, pCodeBlob->GetBufferSize());

        if (SUCCEEDED(hr))
        {
            memcpy(args.m_GSByteCode.m_pByteCode, pCodeBlob->GetBufferPointer(), pCodeBlob->GetBufferSize());
            if (padding > 0)
            {
                ZeroMemory((BYTE*)args.m_GSByteCode.m_pByteCode + pCodeBlob->GetBufferSize(), padding);
            }
            *args.m_pGsOutputDecls = geoDesc.GetOutputDecls();
        }
        else
        {
            Check(false);
        }
    }

    return hr;
}

LONG
CObject::AddRef() const
{
    return ::InterlockedIncrement( &m_lRefCount );
}

LONG
CObject::Release() const
{
    SHADER_CONV_ASSERT( m_lRefCount > 0 );
    const LONG lRefCount = ::InterlockedDecrement( &m_lRefCount );
    if ( 0 == lRefCount )
    {
        delete this;
    }
    return lRefCount;
}

//////////////////////////////////////////////////////////////////////////////

TEXTURETYPE 
ToTextureType(D3D10DDIRESOURCE_TYPE resourceType)
{
    ShaderConv::TEXTURETYPE textureType;

    switch (resourceType)
    {
    case D3D10DDIRESOURCE_TEXTURE2D:
        textureType = TEXTURETYPE_2D;
        break;

    case D3D10DDIRESOURCE_TEXTURE3D:
        textureType = TEXTURETYPE_VOLUME;
        break;

    case D3D10DDIRESOURCE_TEXTURECUBE:
        textureType = TEXTURETYPE_CUBE;
        break;

    default:
        textureType = TEXTURETYPE_UNKNOWN;
        break;
    }

    return textureType;
}

//////////////////////////////////////////////////////////////////////////////

HRESULT
CCodeBlob::Create( size_t cbSize, const void* pBuffer, CCodeBlob** ppCodeBlob )
{
    SHADER_CONV_ASSERT( pBuffer && ppCodeBlob );

    CCodeBlob* const pCodeBlog = new CCodeBlob();
    if ( NULL == pCodeBlog )
    {
        SHADER_CONV_ASSERT(!"CCodeBlob() allocation failed, out of memory\n" );
        return E_OUTOFMEMORY;
    }

    pCodeBlog->AddRef();

    // Allocate necessary memory for the buffer
    BYTE* const pBits = new BYTE[cbSize];

    if ( NULL == pBits )
    {
        pCodeBlog->Release();
        SHADER_CONV_ASSERT(!"WarpPlatform::AllocateMemory() failed, out of memory\n" );
        return E_OUTOFMEMORY;
    }

    // Copy the buffer to destination
    memcpy( pBits, pBuffer, cbSize );

    // Set the blob properties
    pCodeBlog->m_cbSize = cbSize;
    pCodeBlog->m_pBits = pBits;

    // Return the blob
    *ppCodeBlob = pCodeBlog;

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////

HRESULT
CShaderDesc::CopyInstructions( const void* pInstrs, UINT cbSize )
{
    SHADER_CONV_ASSERT( pInstrs && cbSize );

    m_pdwInstrs = new DWORD[cbSize];

    if ( NULL == m_pdwInstrs )
    {
        return E_OUTOFMEMORY;
    }

    memcpy( m_pdwInstrs, pInstrs, cbSize );

    m_cbCodeSize = cbSize;

    return S_OK;
}

bool
CShaderDesc::FindInlineConstant( eConstantBuffers type, UINT regIndex, ShaderConst* pShaderConst ) const
{
    for ( size_t i = 0, n = m_inlineConsts[type].size(); i < n; ++i )
    {
        const ShaderConst& shaderConst = m_inlineConsts[type][i];
        if ( shaderConst.RegIndex == regIndex )
        {
            if ( pShaderConst )
            {
                *pShaderConst = shaderConst;
            }

            return true;
        }
    }

    return false;
}

} // namespace ShaderConv

```

`ShaderConverter/ShaderConv/context.cpp`:

```cpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/*==========================================================================;
*
*  Copyright (C) Microsoft Corporation.  All Rights Reserved.
*
*  Implementation for The translator context
*
****************************************************************************/

#include "pch.h"
#include "context.hpp"

namespace ShaderConv
{

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
HRESULT
CContext::TranslateInstructions()
{
    const UINT cbCodeSize = m_pShaderDesc->GetCodeSize();
    const DWORD* const pdwCodeBytes = m_pShaderDesc->GetInstructions();
    const DWORD* pdwCurToken = pdwCodeBytes + 1;
    while( *pdwCurToken != D3DPS_END() )
    {
        if ( static_cast<UINT>( reinterpret_cast<const BYTE*>( pdwCurToken ) -
                                reinterpret_cast<const BYTE*>( pdwCodeBytes ) ) > cbCodeSize )
        {
            SHADER_CONV_ASSERT(FALSE);
            return E_FAIL;
        }

        CInstr instr( *pdwCurToken, this );

        const D3DSHADER_INSTRUCTION_OPCODE_TYPE opCode = instr.GetOpCode();

        switch ( opCode )
        {
        case D3DSIO_NOP:
        case D3DSIO_COMMENT:
        case D3DSIO_DCL:
            pdwCurToken += instr.GetLength();
            continue;

        case D3DSIO_DEF:
        case D3DSIO_DEFI:
        case D3DSIO_DEFB:
            pdwCurToken += instr.GetLength();
            continue;
        }

        //
        // Decode src and dst params
        //

        ++pdwCurToken;

        //
        // Some tokens have no parameters at all (like endrep)
        // so there is nothing to decode
        //
        if ( ( *pdwCurToken & ( 1L << 31 ) ) )
        {
            switch ( opCode )
            {
            case D3DSIO_CALL:
            case D3DSIO_REP:
            case D3DSIO_LOOP:
            case D3DSIO_CALLNZ:
            case D3DSIO_IF:
            case D3DSIO_IFC:
            case D3DSIO_BREAK:
            case D3DSIO_BREAKC:
            case D3DSIO_BREAKP:
            case D3DSIO_LABEL:
            case D3DSIO_TEXKILL:
                // No dst param, only src params.
                break;

            default:
                pdwCurToken = instr.SetDstToken( pdwCurToken );
                break;
            }

            if ( instr.HasPredicate() )
            {
                pdwCurToken = instr.SetPredicate( pdwCurToken );
            }

            while ( *pdwCurToken & ( 1L << 31 ) )
            {
                pdwCurToken = instr.AddSrcToken( pdwCurToken );
            }
        }

        switch ( opCode )
        {
        case D3DSIO_MOV:
            this->Translate_MOV( instr );
            break;

        case D3DSIO_ADD:
            this->Translate_ADD( instr );
            break;

        case D3DSIO_SUB:
            this->Translate_SUB( instr );
            break;

        case D3DSIO_MAD:
            this->Translate_MAD( instr );
            break;

         case D3DSIO_MUL:
            this->Translate_MUL( instr );
            break;

        case D3DSIO_RCP:
            this->Translate_RCP( instr );
            break;

        case D3DSIO_RSQ:
            this->Translate_RSQ( instr );
            break;

        case D3DSIO_DP3:
            this->Translate_DP3( instr );
            break;

        case D3DSIO_DP4:
            this->Translate_DP4( instr );
            break;

        case D3DSIO_MIN:
            this->Translate_MIN( instr );
            break;

        case D3DSIO_MAX:
            this->Translate_MAX( instr );
            break;

        case D3DSIO_SLT:
            this->Translate_SLT( instr );
            break;

        case D3DSIO_SGE:
            this->Translate_SGE( instr );
            break;

        case D3DSIO_EXP:
            this->Translate_EXP( instr );
            break;

        case D3DSIO_LOG:
            this->Translate_LOG( instr );
            break;

        case D3DSIO_LIT:
            this->Translate_LIT( instr );
            break;

        case D3DSIO_DST:

            this->Translate_DST( instr );
            break;

        case D3DSIO_LRP:
            this->Translate_LRP( instr );
            break;

        case D3DSIO_FRC:
            this->Translate_FRC( instr );
            break;

        case D3DSIO_M4x4:
            this->Translate_M4x4( instr );
            break;

        case D3DSIO_M4x3:
            this->Translate_M4x3( instr );
            break;

        case D3DSIO_M3x4:
            this->Translate_M3x4( instr );
            break;

        case D3DSIO_M3x3:
            this->Translate_M3x3( instr );
            break;

        case D3DSIO_M3x2:
            this->Translate_M3x2( instr );
            break;

        case D3DSIO_CALL:
            this->Translate_CALL( instr );
            break;

        case D3DSIO_CALLNZ:
            this->Translate_CALLNZ( instr );
            break;

        case D3DSIO_LOOP:
            this->Translate_LOOP( instr );
            break;

        case D3DSIO_RET:
            this->Translate_RET( instr );
            break;

        case D3DSIO_ENDLOOP:
            this->Translate_ENDLOOP( instr );
            break;

        case D3DSIO_LABEL:
            this->Translate_LABEL( instr );
            break;

        case D3DSIO_POW:
            this->Translate_POW( instr );
            break;

        case D3DSIO_CRS:
            this->Translate_CRS( instr );
            break;

        case D3DSIO_SGN:
            this->Translate_SGN( instr );
            break;

        case D3DSIO_ABS:
            this->Translate_ABS( instr );
            break;

        case D3DSIO_NRM:
            this->Translate_NRM( instr );
            break;

        case D3DSIO_SINCOS:
            this->Translate_SINCOS( instr );
            break;

        case D3DSIO_REP:
            this->Translate_REP( instr );
            break;

        case D3DSIO_ENDREP:
            this->Translate_ENDREP( instr );
            break;

        case D3DSIO_IF:
            this->Translate_IF( instr );
            break;

        case D3DSIO_IFC:
            this->Translate_IFC( instr );
            break;

        case D3DSIO_ELSE:
            this->Translate_ELSE( instr );
            break;

        case D3DSIO_ENDIF:
            this->Translate_ENDIF( instr );
            break;

        case D3DSIO_BREAK:
            pdwCurToken = this->Translate_BREAK( instr, pdwCurToken );
            break;

        case D3DSIO_BREAKC:
            this->Translate_BREAKC( instr );
            break;

        case D3DSIO_MOVA:
            this->Translate_MOVA( instr );
            break;

        case D3DSIO_TEXCOORD:
            this->Translate_TEXCOORD( instr );
            break;

        case D3DSIO_TEXKILL:
            this->Translate_TEXKILL( instr );
            break;

        case D3DSIO_TEX:
            this->Translate_TEX( instr );
            break;

        case D3DSIO_TEXLDD:
            this->Translate_TEXLDD( instr );
            break;

        case D3DSIO_TEXBEM:
            this->Translate_TEXBEM( instr );
            break;

        case D3DSIO_TEXBEML:
            this->Translate_TEXBEML( instr );
            break;

        case D3DSIO_TEXREG2AR:
            this->Translate_TEXREG2AR( instr );
            break;

        case D3DSIO_TEXREG2GB:
            this->Translate_TEXREG2GB( instr );
            break;

        case D3DSIO_TEXREG2RGB:
            this->Translate_TEXREG2RGB( instr );
            break;

        case D3DSIO_TEXM3x2PAD:
            this->Translate_TEXM3x2PAD( instr );
            break;

        case D3DSIO_TEXM3x2TEX:
            this->Translate_TEXM3x2TEX( instr );
            break;

        case D3DSIO_TEXM3x2DEPTH:
            this->Translate_TEXM3x2DEPTH( instr );
            break;

        case D3DSIO_TEXM3x3PAD:
            this->Translate_TEXM3x3PAD( instr );
            break;

        case D3DSIO_TEXM3x3:
            this->Translate_TEXM3x3( instr );
            break;

        case D3DSIO_TEXM3x3TEX:
            this->Translate_TEXM3x3TEX( instr );
            break;

        case D3DSIO_TEXM3x3SPEC:
            this->Translate_TEXM3x3SPEC( instr );
            break;

        case D3DSIO_TEXM3x3VSPEC:
            this->Translate_TEXM3x3VSPEC( instr );
            break;

        case D3DSIO_CND:
            this->Translate_CND( instr );
            break;

        case D3DSIO_TEXDP3TEX:
            this->Translate_TEXDP3TEX( instr );
            break;

        case D3DSIO_TEXDP3:
            this->Translate_TEXDP3( instr );
            break;

        case D3DSIO_TEXDEPTH:
            this->Translate_TEXDEPTH( instr );
            break;

        case D3DSIO_CMP:
            this->Translate_CMP( instr );
            break;

        case D3DSIO_BEM:
            this->Translate_BEM( instr );
            break;

        case D3DSIO_DP2ADD:
            this->Translate_DP2ADD( instr );
            break;

        case D3DSIO_DSX:
            this->Translate_DSX( instr );
            break;

        case D3DSIO_DSY:
            this->Translate_DSY( instr );
            break;

         case D3DSIO_BREAKP:
            this->Translate_BREAKP( instr );
            break;

        case D3DSIO_PHASE:
            this->Translate_PHASE( instr );
            break;

        case D3DSIO_SETP:
            this->Translate_SETP( instr );
            break;

        case D3DSIO_EXPP:
            this->Translate_EXPP( instr );
            break;

        case D3DSIO_LOGP:
            this->Translate_LOGP( instr );
            break;

        case D3DSIO_TEXLDL:
            this->Translate_TEXLDL( instr );
            break;

         default:
            SHADER_CONV_ASSERT(!"Invalid instruction opcode.");
            return E_INVALIDARG;
        }

        m_bLastInstrBreak = opCode == D3DSIO_BREAK;

        //
        // Handle predicated instructions
        //

        if ( instr.HasPredicate() )
        {
            // Clear the predicate flag
            instr.ClearPredicateFlag();

            // If D3DSPSM_NOT is set, flip the order of dwSrcToken and SaveReg
            const COperandBase operands[2] = { instr.CreateDstOperand(),
                                               CTempOperand4( SREG_PRED ) };
            const DWORD dwPredicate = instr.GetPredicate();
            const UINT srcSelect = ( dwPredicate & D3DSPSM_NOT ) ? 2 : 1;

            m_pShaderAsm->EmitInstruction(
                    CInstruction( D3D10_SB_OPCODE_MOVC,
                                  operands[0],
                                  this->EmitPredOperand( instr ),
                                  operands[srcSelect & 1 ],
                                  operands[srcSelect >> 1] ) );
        }
    }

    SHADER_CONV_ASSERT( 0 == m_controlFlowDepth );

    return S_OK;
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_MOV( const CInstr& instr )
{
    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );

    const DWORD dwRegType = D3DSI_GETREGTYPE_RESOLVING_CONSTANTS( instr.GetDstToken() );
    if ( D3DSPR_ADDR == dwRegType )
    {
        // round_ne s0, src0
        // ftoi dest, s0

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_ROUND_NE,
                          CTempOperandDst( SREG_TMP0 ),
                          src0 ) );

        this->EmitDstInstruction( instr.GetModifiers(),
                                  D3D10_SB_OPCODE_FTOI,
                                  dest,
                                  CTempOperand4( SREG_TMP0 ) );
    }
    else
    {
        // mov dest, src0

        this->EmitDstInstruction( instr.GetModifiers(),
                                  D3D10_SB_OPCODE_MOV,
                                  dest,
                                  src0 );
    }
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_ADD( const CInstr& instr )
{
    // add dest, src0, src1

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );
    const COperandBase src1 = this->EmitSrcOperand( instr, 1 );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_ADD,
                              dest,
                              src0,
                              src1 );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_SUB( const CInstr& instr )
{
    // add dest, src0, -src1

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );
    const COperandBase src1 = this->EmitSrcOperand( instr, 1 );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_ADD,
                              dest,
                              src0,
                              CNegate( src1 ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_MAD( const CInstr& instr )
{
    // mad dest, src0, src1, src2

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );
    const COperandBase src1 = this->EmitSrcOperand( instr, 1 );
    const COperandBase src2 = this->EmitSrcOperand( instr, 2 );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_MAD,
                              dest,
                              src0,
                              src1,
                              src2 );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_MUL( const CInstr& instr )
{
    // mul dest, src0, src1

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );
    const COperandBase src1 = this->EmitSrcOperand( instr, 1 );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_MUL,
                              dest,
                              src0,
                              src1 );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_RSQ( const CInstr& instr )
{
    // mov  s0.z, abs( src0 )
    // rsq  dest, src0
    // movc dest, s0.z, dest, vec4( FLT_MAX, FLT_MAX, FLT_MAX, FLT_MAX )

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );

    m_pShaderAsm->EmitInstruction(
        CInstruction(D3D10_SB_OPCODE_MOV,
            CTempOperandDst(SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Z),
            CAbs(src0)));

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_RSQ,
                              dest,
                              CAbs( src0 ) );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_MOVC,
                              dest,
                              CTempOperand4( SREG_TMP0, __SWIZZLE_Z ),
                              dest,
                              COperand( FLT_MAX, FLT_MAX, FLT_MAX, FLT_MAX ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_DP3( const CInstr& instr )
{
    // dp3 dest, src0, src1

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0, 0, 3 );
    const COperandBase src1 = this->EmitSrcOperand( instr, 1, 0, 3 );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_DP3,
                              dest,
                              src0,
                              src1 );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_DP4( const CInstr& instr )
{
    // dp4 dest, src0, src1

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );
    const COperandBase src1 = this->EmitSrcOperand( instr, 1 );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_DP4,
                              dest,
                              src0,
                              src1 );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_MIN( const CInstr& instr )
{
    // lt s0, src0, src1
    // movc dest, s0, src0, src1

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );
    const COperandBase src1 = this->EmitSrcOperand( instr, 1 );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_LT,
                      CTempOperandDst( SREG_TMP0 ),
                      src0,
                      src1 ) );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_MOVC,
                              dest,
                              CTempOperand4( SREG_TMP0 ),
                              src0,
                              src1 );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_MAX( const CInstr& instr )
{
    // ge s0, src0, src1
    // movc dest, s0, src0, src1

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );
    const COperandBase src1 = this->EmitSrcOperand( instr, 1 );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_GE,
                      CTempOperandDst( SREG_TMP0 ),
                      src0,
                      src1 ) );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_MOVC,
                              dest,
                              CTempOperand4( SREG_TMP0 ),
                              src0,
                              src1 );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_SLT( const CInstr& instr )
{
    // lt s0, src0, src1
    // movc dest, s0, vec4(1.0f), vec4(0.0f)

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );
    const COperandBase src1 = this->EmitSrcOperand( instr, 1 );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_LT,
                      CTempOperandDst( SREG_TMP0 ),
                      src0,
                      src1 ) );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_MOVC,
                              dest,
                              CTempOperand4( SREG_TMP0 ),
                              COperand( 1.0f ),
                              COperand( 0.0f ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_EXP( const CInstr& instr )
{
    // exp dest, src0

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_EXP,
                              dest,
                              src0 );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_EXPP( const CInstr& instr )
{
    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );

    SHADER_CONV_ASSERT( __IS_VS( m_version ) );
    if ( m_version >= D3DVS_VERSION(2,0) )
    {
        // exp s0.w, src0
        // and dest, s0.w, vec4(0xffffff00)

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_EXP,
                          CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_W ),
                          src0 ) );

        this->EmitDstInstruction( instr.GetModifiers(),
                                  D3D10_SB_OPCODE_AND,
                                  dest,
                                  CTempOperand4( SREG_TMP0, __SWIZZLE_W ),
                                  COperand( 0xffffff00 ) );
    }
    else
    {
        // round_ni s0.y, src0
        // exp s0.x, s0.y
        // add s0.y, src0, -s0.y
        // exp s0.z, src0
        // and s0.z, s0.z, vec4(0xffffff00)
        // mov s0.w, vec4(1.0f)
        // mov dest, s0

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_ROUND_NI,
                          CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Y ),
                          src0 ) );

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_EXP,
                          CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                          CTempOperand4( SREG_TMP0, __SWIZZLE_Y ) ) );

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_ADD,
                          CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Y ),
                          src0,
                          CNegate( CTempOperand4( SREG_TMP0, __SWIZZLE_Y ) ) ) );

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_EXP,
                          CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Z ),
                          src0 ) );

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_AND,
                          CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Z ),
                          CTempOperand4( SREG_TMP0, __SWIZZLE_Z ),
                          COperand( 0xffffff00 ) ) );

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_MOV,
                          CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_W ),
                          COperand( 1.0f ) ) );

        this->EmitDstInstruction( instr.GetModifiers(),
                                  D3D10_SB_OPCODE_MOV,
                                  dest,
                                  CTempOperand4( SREG_TMP0 ) );
    }
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_FRC( const CInstr& instr )
{
    // frc dest, src0

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_FRC,
                              dest,
                              src0 );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_MOVA( const CInstr& instr )
{
    // round_ne s0, src0
    // ftoi dest, s0

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );

    m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_ROUND_NE,
                          CTempOperandDst( SREG_TMP0 ),
                          src0 ) );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_FTOI,
                              dest,
                              CTempOperand4( SREG_TMP0 ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_LIT( const CInstr& instr )
{
    // min  s0.x, src0.w, vec4( 127.9961f )
    // max  s0.x, s0.x, vec4( -127.9961f )
    // max  s0.yz, src0.xxy, vec4( 0.0f )
    // log  s0.w, s0.z
    // mov  s0.z, abs( s0.z )
    // movc s0.z, s0.z, s0.w, vec4( -FLT_MAX, -FLT_MAX, -FLT_MAX, -FLT_MAX )
    // mul  s0.z, s0.z, s0.x
    // exp  s0.z, s0.z
    // mov  s0.xw, vec4( 1.0f, 0.0f, 0.0f, 1.0f )
    // mov  dest,  s0

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MIN,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                      CSwizzle( src0, __SWIZZLE_W ),
                      COperand( 127.9961f ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MAX,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                      CTempOperand4( SREG_TMP0, __SWIZZLE_X ),
                      COperand( -127.9961f ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MAX,
                      CTempOperandDst( SREG_TMP0, __WRITEMASK_YZ ),
                      CSwizzle( src0, __SWIZZLE_XXY ),
                      COperand( 0.0f ) ) );
    
    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_LOG,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_W ),
                      CTempOperand4( SREG_TMP0, __SWIZZLE_Z ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MOV,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Z ),
                      CAbs( CTempOperand4( SREG_TMP0, __SWIZZLE_Z) ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MOVC,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Z ),
                      CTempOperand4( SREG_TMP0, __SWIZZLE_Z ),
                      CTempOperand4( SREG_TMP0, __SWIZZLE_W ),
                      COperand(-(FLT_MAX), -(FLT_MAX), -(FLT_MAX), -(FLT_MAX) ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MUL,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Z ),
                      CTempOperand4( SREG_TMP0, __SWIZZLE_Z ),
                      CTempOperand4( SREG_TMP0, __SWIZZLE_X ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_EXP,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Z ),
                      CTempOperand4( SREG_TMP0, __SWIZZLE_Z ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MOV,
                      CTempOperandDst( SREG_TMP0, __WRITEMASK_XW ),
                      COperand( 1.0f, 0.0f, 0.0f, 1.0f ) ) );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_MOV,
                              dest,
                              CTempOperand4( SREG_TMP0 ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_DST( const CInstr& instr )
{
    // mov s0.x, vec4(1.0f)
    // mul s0.y, src0.y, src1.y
    // mov s0.z, src0.z
    // mov s0.w, src1.w
    // mov dest,  s0

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );
    const COperandBase src1 = this->EmitSrcOperand( instr, 1 );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MOV,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                      COperand( 1.0f ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MUL,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Y ),
                      CSwizzle( src0, __SWIZZLE_Y ),
                      CSwizzle( src1, __SWIZZLE_Y ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MOV,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Z ),
                      CSwizzle( src0, __SWIZZLE_Z ) ) );


    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MOV,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_W ),
                      CSwizzle( src1, __SWIZZLE_W ) ) );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_MOV,
                              dest,
                              CTempOperand4( SREG_TMP0 ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_LRP( const CInstr& instr )
{
    // add s0,  src1, -src2
    // mad dest, src0, s0, src2

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );
    const COperandBase src1 = this->EmitSrcOperand( instr, 1 );
    const COperandBase src2 = this->EmitSrcOperand( instr, 2 );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_ADD,
                      CTempOperandDst( SREG_TMP0 ),
                      src1,
                      CNegate( src2 ) ) );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_MAD,
                              dest,
                              src0,
                              CTempOperand4( SREG_TMP0 ),
                              src2 );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_M4x4( const CInstr& instr )
{
    // dp4 s0.x, src0, src1[0]
    // dp4 s0.y, src0, src1[1]
    // dp4 s0.z, src0, src1[2]
    // dp4 s0.w, src0, src1[3]
    // mov dest, s0

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_DP4,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                      src0,
                      this->EmitSrcOperand( instr, 1, 0 ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_DP4,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Y ),
                      src0,
                      this->EmitSrcOperand( instr, 1, 1 ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_DP4,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Z ),
                      src0,
                      this->EmitSrcOperand( instr, 1, 2 ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_DP4,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_W ),
                      src0,
                      this->EmitSrcOperand( instr, 1, 3 ) ) );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_MOV,
                              dest,
                              CTempOperand4( SREG_TMP0 ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_M4x3( const CInstr& instr )
{
    // dp4 s0.x, src0, src1[0]
    // dp4 s0.y, src0, src1[1]
    // dp4 s0.z, src0, src1[2]
    // mov dest.xyz, s0

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_DP4,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                      src0,
                      this->EmitSrcOperand( instr, 1, 0 ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_DP4,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Y ),
                      src0,
                      this->EmitSrcOperand( instr, 1, 1 ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_DP4,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Z ),
                      src0,
                      this->EmitSrcOperand( instr, 1, 2 ) ) );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_MOV,
                              CWriteMask( dest, __WRITEMASK_XYZ ),
                              CTempOperand4( SREG_TMP0 ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_M3x4( const CInstr& instr )
{
    // dp3 s0.x, src0, src1[0]
    // dp3 s0.y, src0, src1[1]
    // dp3 s0.z, src0, src1[2]
    // dp3 s0.w, src0, src1[3]
    // mov dest, s0

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_DP3,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                      src0,
                      this->EmitSrcOperand( instr, 1, 0 ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_DP3,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Y ),
                      src0,
                      this->EmitSrcOperand( instr, 1, 1 ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_DP3,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Z ),
                      src0,
                      this->EmitSrcOperand( instr, 1, 2 ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_DP3,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_W ),
                      src0,
                      this->EmitSrcOperand( instr, 1, 3 ) ) );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_MOV,
                              dest,
                              CTempOperand4( SREG_TMP0 ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_M3x3( const CInstr& instr )
{
    // dp3 s0.x, src0, src1[0]
    // dp3 s0.y, src0, src1[1]
    // dp3 s0.z, src0, src1[2]
    // mov dest.xyz, s0

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_DP3,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                      src0,
                      this->EmitSrcOperand( instr, 1, 0 ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_DP3,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Y ),
                      src0,
                      this->EmitSrcOperand( instr, 1, 1 ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_DP3,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Z ),
                      src0,
                      this->EmitSrcOperand( instr, 1, 2 ) ) );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_MOV,
                              CWriteMask( dest, __WRITEMASK_XYZ ),
                              CTempOperand4( SREG_TMP0 ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_M3x2( const CInstr& instr )
{
    // dp3 s0.x, src0, src1[0]
    // dp3 s0.y, src0, src1[1]
    // mov dest.xy, s0

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_DP3,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                      src0,
                      this->EmitSrcOperand( instr, 1, 0 ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_DP3,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Y ),
                      src0,
                      this->EmitSrcOperand( instr, 1, 1 ) ) );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_MOV,
                              CWriteMask( dest, __WRITEMASK_XY ),
                              CTempOperand4( SREG_TMP0 ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_POW( const CInstr& instr )
{
    // log  s0.y,  abs( src0 )
    // mov  s0.x, abs( src0 )
    // movc s0, s0.x, s0.y, vec4( -FLT_MAX, -FLT_MAX, -FLT_MAX, -FLT_MAX )
    // mul  s0,  s0, src1
    // exp  dest, s0

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );
    const COperandBase src1 = this->EmitSrcOperand( instr, 1 );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_LOG,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Y ),
                      CAbs( src0 ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MOV,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                      CAbs( src0 ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MOVC,
                      CTempOperandDst( SREG_TMP0 ),
                      CTempOperand4( SREG_TMP0, __SWIZZLE_X ),
                      CTempOperand4( SREG_TMP0, __SWIZZLE_Y ),
                      COperand( -(FLT_MAX), -(FLT_MAX), -(FLT_MAX), -(FLT_MAX) ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MUL,
                      CTempOperandDst( SREG_TMP0 ),
                      CTempOperand4( SREG_TMP0 ),
                      src1 ) );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_EXP,
                              dest,
                              CTempOperand4( SREG_TMP0 ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_CRS( const CInstr& instr )
{
    // mul s0.xy, src0.yz, src1.zy
    // add s0.x, s0.x, -s0.y
    // mul s0.yz, src0.xzx, src1.xxz
    // add s0.y, s0.y, -s0.z
    // mul s0.zw, src0.xxxy, src1.xxyx
    // add s0.z, s0.z, -s0.w
    // mov dest, s0

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );
    const COperandBase src1 = this->EmitSrcOperand( instr, 1 );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MUL,
                      CTempOperandDst( SREG_TMP0, __WRITEMASK_XY ),
                      CSwizzle( src0, __SWIZZLE_YZ ),
                      CSwizzle( src1, __SWIZZLE_ZY ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_ADD,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                      CTempOperand4( SREG_TMP0, __SWIZZLE_X ),
                      CNegate( CTempOperand4( SREG_TMP0, __SWIZZLE_Y ) ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MUL,
                      CTempOperandDst( SREG_TMP0, __WRITEMASK_YZ ),
                      CSwizzle( src0, __SWIZZLE_XZX ),
                      CSwizzle( src1, __SWIZZLE_XXZ ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_ADD,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Y ),
                      CTempOperand4( SREG_TMP0, __SWIZZLE_Y ),
                      CNegate( CTempOperand4( SREG_TMP0, __SWIZZLE_Z ) ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MUL,
                      CTempOperandDst( SREG_TMP0, __WRITEMASK_ZW ),
                      CSwizzle( src0, __SWIZZLE_XXXY ),
                      CSwizzle( src1, __SWIZZLE_XXYX ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_ADD,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Z ),
                      CTempOperand4( SREG_TMP0, __SWIZZLE_Z ),
                      CNegate( CTempOperand4( SREG_TMP0, __SWIZZLE_W ) ) ) );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_MOV,
                              dest,
                              CTempOperand4( SREG_TMP0 ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_SGN( const CInstr& instr )
{
    // eq   s0,  src0, vec4(0.0f)
    // movc s1,  s0,   vec4(0.0f), vec4(1.0f)
    // lt   s0,  src0, vec4(0.0f)
    // movc dest, s0,  vec4(-1.0f), s1

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_EQ,
                      CTempOperandDst( SREG_TMP0 ),
                      src0,
                      COperand( 0.0f ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MOVC,
                      CTempOperandDst( SREG_TMP1 ),
                      CTempOperand4( SREG_TMP0 ),
                      COperand( 0.0f ),
                      COperand( 1.0f ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_LT,
                      CTempOperandDst( SREG_TMP0 ),
                      src0,
                      COperand( 0.0f ) ) );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_MOVC,
                              dest,
                              CTempOperand4( SREG_TMP0 ),
                              COperand( -1.0f ),
                              CTempOperand4( SREG_TMP1 ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_ABS( const CInstr& instr )
{
    // mov dest, abs( src0 )

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_MOV,
                              dest,
                              CAbs( src0 ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_NRM( const CInstr& instr )
{
    // dp3  s0.x, src0, src0
    // rsq  s0.y, s0.x
    // movc s0.z, s0.x, s0.y, vec4( FLT_MAX, FLT_MAX, FLT_MAX, FLT_MAX )
    // mul  dest, src0, s0.z

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_DP3,
            CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
            src0,
            src0 ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_RSQ,
            CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Y ),
            CTempOperand4( SREG_TMP0, __SWIZZLE_X ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MOVC,
            CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Z ),
            CTempOperand4( SREG_TMP0, __SWIZZLE_X ),
            CTempOperand4( SREG_TMP0, __SWIZZLE_Y ),
            COperand( FLT_MAX, FLT_MAX, FLT_MAX, FLT_MAX ) ) );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_MUL,
                              dest,
                              src0,
                              CTempOperand4( SREG_TMP0, __SWIZZLE_Z ) );

}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_SINCOS( const CInstr& instr )
{
    // sincos s0.x, s0.y, src0
    // mov dest,  s0

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_SINCOS,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Y ),
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                      src0 ) );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_MOV,
                              dest,
                              CTempOperand4( SREG_TMP0 ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_CMP( const CInstr& instr )
{
    // ge s0 src0 vec4(0.0f)
    // movc dest, s0, src1, src2

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );
    const COperandBase src1 = this->EmitSrcOperand( instr, 1 );
    const COperandBase src2 = this->EmitSrcOperand( instr, 2 );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_GE,
                      CTempOperandDst( SREG_TMP0 ),
                      src0,
                      COperand( 0.0f ) ) );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_MOVC,
                              dest,
                              CTempOperand4( SREG_TMP0 ),
                              src1,
                              src2 );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_DP2ADD( const CInstr& instr )
{
    // dp2 s0, src0, src1
    // add dest, s0, src2

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0, 0, 2 );
    const COperandBase src1 = this->EmitSrcOperand( instr, 1, 0, 2 );
    const COperandBase src2 = this->EmitSrcOperand( instr, 2 );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_DP2,
                      CTempOperandDst( SREG_TMP0 ),
                      src0,
                      src1 ) );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_ADD,
                              dest,
                              CTempOperand4( SREG_TMP0 ),
                              src2 );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_RCP( const CInstr& instr )
{
    // div  dest, vec4( 1.0f ), src0

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );
    const DWORD dwToken = instr.GetSrcToken( 0 );
    const DWORD dwModifier = ( dwToken & D3DSP_SRCMOD_MASK );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_DIV,
                              dest,
                              COperand( 1.0f ),
                              src0 );

    // movc doesn't allow modifiers on the comparison param, so if src0 has modifiers we need to apply those and mov into a temp register
    // note that according to spec, rcp can only act on scalar values, so we just mov into r0.z
    if ( dwModifier != D3DSPSM_NONE ) 
    {
        // mov  r0.z, src0
        // movc dest, r0.z, dest, src0


        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_MOV,
                CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Z ),
                src0 ) );

        this->EmitDstInstruction( instr.GetModifiers(),
                                  D3D10_SB_OPCODE_MOVC,
                                  dest,
                                  CTempOperand4( SREG_TMP0, __SWIZZLE_Z ),
                                  dest,
                                  src0 );
    }
    else
    {
        // movc dest, src0, dest, src0

        this->EmitDstInstruction( instr.GetModifiers(),
                                  D3D10_SB_OPCODE_MOVC,
                                  dest,
                                  src0,
                                  dest,
                                  src0 );
    }
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_CND( const CInstr& instr )
{
    SHADER_CONV_ASSERT( __IS_PS( m_version ) );
    SHADER_CONV_ASSERT( m_version < D3DPS_VERSION(2,0) );

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );
    const COperandBase src1 = this->EmitSrcOperand( instr, 1 );
    const COperandBase src2 = this->EmitSrcOperand( instr, 2 );

    if ( m_version > D3DPS_VERSION(1,3) )
    {
        // lt s0, vec4(0.5f), src0
        // movc dest, s0, src1, src2

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_LT,
                          CTempOperandDst( SREG_TMP0 ),
                          COperand( 0.5f ),
                          src0 ) );

        this->EmitDstInstruction( instr.GetModifiers(),
                                  D3D10_SB_OPCODE_MOVC,
                                  dest,
                                  CTempOperand4( SREG_TMP0 ),
                                  src1,
                                  src2 );
    }
    else
    {
        if ( instr.HasCoissue() )
        {
            // mov dest, src1

            this->EmitDstInstruction( instr.GetModifiers(),
                                      D3D10_SB_OPCODE_MOV,
                                      dest,
                                      src1 );
        }
        else
        {
            // lt s0.x, vec4(0.5f), src0.a
            // movc dest, s0.x, src1, src2

            m_pShaderAsm->EmitInstruction(
                CInstruction( D3D10_SB_OPCODE_LT,
                              CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                              COperand( 0.5f ),
                              CSwizzle( src0, __SWIZZLE_W ) ) );

            this->EmitDstInstruction( instr.GetModifiers(),
                                      D3D10_SB_OPCODE_MOVC,
                                      dest,
                                      CTempOperand4( SREG_TMP0, __SWIZZLE_X ),
                                      src1,
                                      src2 );
        }
    }
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_SGE( const CInstr& instr )
{
    // ge s0, src0, src1
    // movc dest, s0, vec4(1.0f), vec4(0.0f)

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );
    const COperandBase src1 = this->EmitSrcOperand( instr, 1 );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_GE,
                      CTempOperandDst( SREG_TMP0 ),
                      src0,
                      src1 ) );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_MOVC,
                              dest,
                              CTempOperand4( SREG_TMP0 ),
                              COperand( 1.0f ),
                              COperand( 0.0f ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_LOG( const CInstr& instr )
{
    // mov  s0.x, abs( src0 )
    // log  dest, abs( src0 )
    // movc dest, s0.x, dest, vec4( -FLT_MAX, -FLT_MAX, -FLT_MAX,-FLT_MAX )

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );

    m_pShaderAsm->EmitInstruction(
        CInstruction(D3D10_SB_OPCODE_MOV,
            CTempOperandDst(SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X),
            CAbs(src0)));

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_LOG,
                              dest,
                              CAbs( src0 ) );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_MOVC,
                              dest,
                              CTempOperand4( SREG_TMP0, __SWIZZLE_X ),
                              dest,
                              COperand( -(FLT_MAX), -(FLT_MAX), -(FLT_MAX), -(FLT_MAX) ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_LOGP( const CInstr& instr )
{
    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );

    SHADER_CONV_ASSERT( __IS_VS( m_version ) );
    if ( m_version >= D3DVS_VERSION(2,0) )
    {
        // log  s0.w, abs( src0 )
        // mov  s0.x, abs( src0 )
        // movc s0.w, s0.x, s0.w, vec4( -FLT_MAX,-FLT_MAX,-FLT_MAX,-FLT_MAX )
        // and  dest, s0.w, vec4(0xffffff00)

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_LOG,
                          CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_W ),
                          CAbs( src0 ) ) );

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_MOV,
                          CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                          CAbs( src0 ) ) );

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_MOVC,
                          CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_W ),
                          CTempOperand4( SREG_TMP0, __SWIZZLE_X ),
                          CTempOperand4( SREG_TMP0, __SWIZZLE_W ),
                          COperand( -(FLT_MAX), -(FLT_MAX), -(FLT_MAX), -(FLT_MAX) ) ) );

        this->EmitDstInstruction( instr.GetModifiers(),
                                  D3D10_SB_OPCODE_AND,
                                  dest,
                                  CTempOperand4( SREG_TMP0, __SWIZZLE_W ),
                                  COperand( 0xffffff00 ) );
    }
    else
    {
        // mov  s0.w, abs(src0)
        // ushr s0.x, s0.w, vec4(23)
        // iadd s0.x, s0.x, vec4(-127)
        // itof s0.x, s0.x
        // and  s0.y, s0.w, vec4(0x7fffff)
        // or   s0.y, s0.y, vec4(0x3f800000)
        // log  s0.z, s0.w
        // movc s0.z, s0.w, s0.z, vec4( -FLT_MAX, -FLT_MAX, -FLT_MAX, -FLT_MAX )
        // and  s0.z, s0.z, vec4(0xffffff00)
        // eq   s0.w, s0.w, vec4(0.0f)
        // movc s0.xz, s0.w, vec4(0xFF7FFFFF), s0.xxz
        // movc s0.y, s0.w, vec4(1.0f), s0.y
        // mov  s0.w, vec4(1.0f)
        // mov  dest, s0

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_MOV,
                          CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_W ),
                          CAbs( src0 ) ) );

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_USHR,
                          CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                          CTempOperand4( SREG_TMP0, __SWIZZLE_W ),
                          COperand( 23 ) ) );

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_IADD,
                          CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                          CTempOperand4( SREG_TMP0, __SWIZZLE_X ),
                          COperand( -127 ) ) );

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_ITOF,
                          CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                          CTempOperand4( SREG_TMP0, __SWIZZLE_X ) ) );

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_AND,
                          CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Y ),
                          CTempOperand4( SREG_TMP0, __SWIZZLE_W ),
                          COperand( 0x7fffff ) ) );

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_OR,
                          CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Y ),
                          CTempOperand4( SREG_TMP0, __SWIZZLE_Y ),
                          COperand( 0x3f800000 ) ) );

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_LOG,
                          CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Z ),
                          CTempOperand4( SREG_TMP0, __SWIZZLE_W ) ) );
        
        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_MOVC,
                          CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Z ),
                          CTempOperand4( SREG_TMP0, __SWIZZLE_W ),
                          CTempOperand4( SREG_TMP0, __SWIZZLE_Z ),
                          COperand(-(FLT_MAX), -(FLT_MAX), -(FLT_MAX), -(FLT_MAX) ) ) );

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_AND,
                          CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Z ),
                          CTempOperand4( SREG_TMP0, __SWIZZLE_Z ),
                          COperand( 0xffffff00 ) ) );

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_EQ,
                          CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_W ),
                          CTempOperand4( SREG_TMP0, __SWIZZLE_W ),
                          COperand( 0.0f ) ) );

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_MOVC,
                          CTempOperandDst( SREG_TMP0, __WRITEMASK_XZ ),
                          CTempOperand4( SREG_TMP0, __SWIZZLE_W ),
                          COperand( 0xFF7FFFFF ),
                          CTempOperand4( SREG_TMP0, __SWIZZLE_XXZ ) ) );

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_MOVC,
                          CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Y ),
                          CTempOperand4( SREG_TMP0, __SWIZZLE_W ),
                          COperand( 1.0f ),
                          CTempOperand4( SREG_TMP0, __SWIZZLE_Y ) ) );

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_MOV,
                          CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_W ),
                          COperand( 1.0f ) ) );

        this->EmitDstInstruction( instr.GetModifiers(),
                                  D3D10_SB_OPCODE_MOV,
                                  dest,
                                  CTempOperand4( SREG_TMP0 ) );
    }
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_DSX( const CInstr& instr )
{
    // dsx dest, src0

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D11_SB_OPCODE_DERIV_RTX_COARSE,
                              dest,
                              src0 );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_DSY( const CInstr& instr )
{
    // dsy dest, src0

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D11_SB_OPCODE_DERIV_RTY_COARSE,
                              dest,
                              src0 );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_PHASE( const CInstr& /*instr*/ )
{
    // Phase blocks are not needed by this compiler.
    SHADER_CONV_ASSERT( __IS_PS( m_version ) );
    SHADER_CONV_ASSERT( D3DPS_VERSION(1,4) == m_version );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_LABEL( const CInstr& instr )
{
    // label #n

    m_pShaderAsm->EmitInstruction(
        CLabelInstruction( D3DSI_GETREGNUM( instr.GetSrcToken( 0 ) ) ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_REP( const CInstr& instr )
{
    // mov rep.x, src0.x
    // loop
    // breakc_z rep.x

    ++m_controlFlowDepth;
    ++m_loopNestingDepth;

    this->AllocateLoopRegister();

    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MOV,
                      CTempOperandDst( this->GetLoopRegister(), D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                      CSwizzle( src0, __SWIZZLE_X ) ) );

    m_pShaderAsm->EmitInstruction( CLoopInstruction() );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_BREAKC,
                      CTempOperand1( this->GetLoopRegister(), D3D10_SB_4_COMPONENT_X),
                      D3D10_SB_INSTRUCTION_TEST_ZERO ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_ENDREP( const CInstr& /*instr*/ )
{
    // iadd rep.x, rep.x, vec4(-1)
    // endloop

    // The loop counter isn't necessary if there was an unconditional break in the loop
    if (!m_bLastInstrBreak)
    {
        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_IADD,
                          CTempOperandDst( this->GetLoopRegister(),
                                           D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                          CTempOperand4( this->GetLoopRegister(), __SWIZZLE_X ),
                          COperand( -1 ) ) );
    }

    m_pShaderAsm->EmitInstruction( CEndLoopInstruction() );

    --m_loopNestingDepth;
    --m_controlFlowDepth;
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_LOOP( const CInstr& instr )
{
    // mov rep, src1
    // loop
    // breakc_z rep.x
    // ? mov aL, rep.y

    ++m_controlFlowDepth;
    ++m_loopNestingDepth;

    this->AllocateLoopRegister();

    const COperandBase src1 = this->EmitSrcOperand( instr, 1 );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MOV,
                      CTempOperandDst( this->GetLoopRegister() ),
                      src1 ) );

    m_pShaderAsm->EmitInstruction( CLoopInstruction() );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_BREAKC,
                      CTempOperand1( this->GetLoopRegister(), D3D10_SB_4_COMPONENT_X),
                      D3D10_SB_INSTRUCTION_TEST_ZERO ) );

    if ( m_inputRegs.aL != INVALID_INDEX )
    {
        // Update the loop counter register value
        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_MOV,
                          CTempOperandDst( m_inputRegs.aL ),
                          CTempOperand4( this->GetLoopRegister(), __SWIZZLE_Y ) ) );
    }
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_ENDLOOP( const CInstr& /*instr*/ )
{
    // iadd rep.x, rep.x, vec4(-1)
    // iadd rep.y, rep.y, rep.z
    // endloop
    // ? mov aL, rep.y

    // The loop counter isn't necessary if there was an unconditional break in the loop
    if (!m_bLastInstrBreak)
    {
        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_IADD,
                          CTempOperandDst( this->GetLoopRegister(),
                                           D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                          CTempOperand4( this->GetLoopRegister(), __SWIZZLE_X ),
                          COperand( -1 ) ) );

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_IADD,
                          CTempOperandDst( this->GetLoopRegister(),
                                           D3D10_SB_OPERAND_4_COMPONENT_MASK_Y ),
                          CTempOperand4( this->GetLoopRegister(), __SWIZZLE_Y ),
                          CTempOperand4( this->GetLoopRegister(), __SWIZZLE_Z ) ) );
    }

    m_pShaderAsm->EmitInstruction( CEndLoopInstruction() );

    --m_loopNestingDepth;
    --m_controlFlowDepth;

    if ( m_loopNestingDepth != 0xff &&
         m_inputRegs.aL != INVALID_INDEX )
    {
        // Restore the loop counter register value
        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_MOV,
                          CTempOperandDst( m_inputRegs.aL ),
                          CTempOperand4( this->GetLoopRegister(), __SWIZZLE_Y ) ) );
    }
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_CALL( const CInstr& instr )
{
    // call

    m_pShaderAsm->EmitInstruction(
        CCallInstruction( D3DSI_GETREGNUM( instr.GetSrcToken( 0 ) ) ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_CALLNZ( const CInstr& instr )
{
    // call_[z|nz] src0.c[0], label

    SHADER_CONV_ASSERT( !instr.HasPredicate() );

    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );
    const COperandBase src1 = this->EmitSrcOperand( instr, 1, 0, 1 );
    const DWORD dwSrcToken1 = instr.GetSrcToken( 1 );

    m_pShaderAsm->EmitInstruction(
        CInstructionEx( D3D10_SB_OPCODE_CALLC,
                        ( dwSrcToken1 & D3DSPSM_NOT ) ?
                            D3D10_SB_INSTRUCTION_TEST_ZERO :
                            D3D10_SB_INSTRUCTION_TEST_NONZERO,
                        CSingleComponent(src1, (D3D10_SB_4_COMPONENT_NAME)src1.SwizzleComponent(0)),
                        src0 ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_RET( const CInstr& /*instr*/ )
{
    // ret

    // If we are not inside a nested call,
    // ensure that the ouput registers are written before exiting the shader

    if ( 0 == m_controlFlowDepth )
    {
        this->WriteOutputs();
    }

    m_pShaderAsm->EmitInstruction( CRetInstruction() );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_IF( const CInstr& instr )
{
    // if_[z|nz] src0.c[0]

    SHADER_CONV_ASSERT( !instr.HasPredicate() );

    ++m_controlFlowDepth;

    const COperandBase src0 = this->EmitSrcOperand( instr, 0, 0, 1 );
    const DWORD dwSrcToken  = instr.GetSrcToken( 0 );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_IF, 
                      CSingleComponent(src0, (D3D10_SB_4_COMPONENT_NAME)src0.SwizzleComponent(0)),
                      ( dwSrcToken & D3DSPSM_NOT ) ?
                        D3D10_SB_INSTRUCTION_TEST_ZERO :
                        D3D10_SB_INSTRUCTION_TEST_NONZERO ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_IFC( const CInstr& instr )
{
    // <comp> s0.x, src0, src1
    // if_nz s0.x,

    ++m_controlFlowDepth;

    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );
    const COperandBase src1 = this->EmitSrcOperand( instr, 1 );

    const D3DSHADER_COMPARISON compare = D3DSI_GETCOMPARISON( instr.GetToken() );

    this->Compare( compare,
                   CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                   src0,
                   src1 );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_IF,
                      CTempOperand1( SREG_TMP0, D3D10_SB_4_COMPONENT_X),
                      D3D10_SB_INSTRUCTION_TEST_NONZERO ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_ELSE( const CInstr& /*instr*/ )
{
    // else

    m_pShaderAsm->EmitInstruction( CInstruction( D3D10_SB_OPCODE_ELSE ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_ENDIF( const CInstr& /*instr*/ )
{
    // endif

    m_pShaderAsm->EmitInstruction( CInstruction( D3D10_SB_OPCODE_ENDIF ) );
    SHADER_CONV_ASSERT( m_controlFlowDepth );
    --m_controlFlowDepth;
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
const DWORD*
CContext::Translate_BREAK( const CInstr& /*instr*/, const DWORD* pdwCurToken )
{
    // break

    m_pShaderAsm->EmitInstruction( CBreakInstruction() );

    // D3D9 allows computation instructions to follow a break instruction
    // inside the conditional branch statement even though it is impossible
    // for those instructions to ever execute
    // The D3D10 shader assembler does not allow this
    // so skip all computational instructions that follow this instruction

    for ( bool bContinue = true; bContinue; )
    {
        const DWORD dwInstr = *pdwCurToken++;
        D3DSHADER_INSTRUCTION_OPCODE_TYPE opCode = (D3DSHADER_INSTRUCTION_OPCODE_TYPE)( dwInstr & D3DSI_OPCODE_MASK );
        switch ( opCode )
        {
        case D3DSIO_COMMENT:
            pdwCurToken += ( dwInstr & D3DSI_COMMENTSIZE_MASK ) >> D3DSI_COMMENTSIZE_SHIFT;
            break;

        case D3DSIO_DCL:
            pdwCurToken += 2;
            break;

        case D3DSIO_RET:
        case D3DSIO_ENDLOOP:
        case D3DSIO_ENDREP:
        case D3DSIO_ELSE:
        case D3DSIO_ENDIF:
        case D3DSIO_END:
            bContinue = false;
            --pdwCurToken;
            break;

        default:
            while ( *pdwCurToken & ( 1L << 31 ) )
            {
                ++pdwCurToken;
            }
        }
    }

    return pdwCurToken;
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_BREAKC( const CInstr& instr )
{
    // <lt|eq|ge|ne> s0, src0, src1
    // breakc_nz s0.x

    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );
    const COperandBase src1 = this->EmitSrcOperand( instr, 1 );

    const D3DSHADER_COMPARISON compare = D3DSI_GETCOMPARISON( instr.GetToken() );

    this->Compare( compare,
                   CTempOperandDst( SREG_TMP0 ),
                   src0,
                   src1 );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_BREAKC,
                      CTempOperand1( SREG_TMP0, D3D10_SB_4_COMPONENT_X),
                      D3D10_SB_INSTRUCTION_TEST_NONZERO ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_BREAKP( const CInstr& instr )
{
    // break_[z|nz] src0.c[0]

    const COperandBase src0 = this->EmitSrcOperand( instr, 0, 0, 1 );

    // If D3DSPSM_NOT is set, then flip the order of dwSrcToken
    const DWORD dwSrcToken = instr.GetSrcToken( 0 );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_BREAKC,
                      CSingleComponent(src0, (D3D10_SB_4_COMPONENT_NAME)src0.SwizzleComponent(0)),
                      ( dwSrcToken & D3DSPSM_NOT ) ?
                        D3D10_SB_INSTRUCTION_TEST_ZERO :
                        D3D10_SB_INSTRUCTION_TEST_NONZERO ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_TEXKILL( const CInstr& instr )
{
    // lt s0.mask, src0.xyzw, vec4(0.0f)
    // ? { or s0.i, s0.i, s0.j }
    // discard_nz s0.i

    SHADER_CONV_ASSERT( __IS_PS( m_version ) );

    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );

    const UINT writeMask = ( m_version >= D3DPS_VERSION(2,0) ) ?
                                __getWriteMask( instr.GetSrcToken( 0 ) ) : __WRITEMASK_XYZ;

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_LT,
                      CTempOperandDst( SREG_TMP0, writeMask ),
                      CSwizzle( src0, __SWIZZLE_ALL ),
                      COperand( 0.0f ) ) );

    D3D10_SB_4_COMPONENT_NAME component = D3D10_SB_4_COMPONENT_X;
    UINT selectMask = 0;

    if ( writeMask & D3D10_SB_OPERAND_4_COMPONENT_MASK_W )
    {
        selectMask |= ( 1 << 3 );
        component = D3D10_SB_4_COMPONENT_W;
    }

    if ( writeMask & D3D10_SB_OPERAND_4_COMPONENT_MASK_Z )
    {
        selectMask |= ( 1 << 2 );
        component = D3D10_SB_4_COMPONENT_Z;
    }

    if ( writeMask & D3D10_SB_OPERAND_4_COMPONENT_MASK_Y )
    {
        selectMask |= ( 1 << 1 );
        component = D3D10_SB_4_COMPONENT_Y;
    }

    if ( writeMask & D3D10_SB_OPERAND_4_COMPONENT_MASK_X )
    {
        selectMask |= ( 1 << 0 );
        component = D3D10_SB_4_COMPONENT_X;
    }

    const UINT compWriteMask = ( 1 << component ) << D3D10_SB_OPERAND_4_COMPONENT_MASK_SHIFT;

    for ( int i = 0 ; i < 4; ++i )
    {
        if ( i != component &&
             selectMask & ( 1 << i ) )
        {
            m_pShaderAsm->EmitInstruction(
                CInstruction( D3D10_SB_OPCODE_OR,
                              CTempOperandDst( SREG_TMP0, compWriteMask ),
                              CTempOperand4( SREG_TMP0, __SWIZZLE1(component) ),
                              CTempOperand4( SREG_TMP0, __SWIZZLE1(i) ) ) );
        }
    }

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_DISCARD,
                      CTempOperand1( SREG_TMP0, component ),
                      D3D10_SB_INSTRUCTION_TEST_NONZERO ) );
}


void CContext::EmitSampleCmp(const CInstr& instr, const COperandBase dest, const DWORD dwStage, const COperandBase src0)
{
    SHADER_CONV_ASSERT(__IS_PS(m_version));

    COperandBase depth = COperand4(src0.m_Type, src0.RegIndex(), D3D10_SB_4_COMPONENT_Z);
    if (src0.m_Type == D3D10_SB_OPERAND_TYPE_INPUT)
    {
        if ((m_inputRegs.v[src0.RegIndex()].WriteMask() & D3D10_SB_COMPONENT_MASK_Z) == 0)
        {
            depth = COperand(0.0f);
        }
    }

    this->EmitDstInstruction(instr.GetModifiers(),
        D3D10_SB_OPCODE_SAMPLE_C,
        dwStage,
        dest,//dest
        src0,//texcoord
        CResOperand4(dwStage, __SWIZZLE_X),//texture
        COperand(D3D10_SB_OPERAND_TYPE_SAMPLER, dwStage),//sampler
        depth);
}
///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_TEX( const CInstr& instr )
{
    SHADER_CONV_ASSERT( __IS_PS( m_version ) );

    const COperandBase dest = instr.CreateDstOperand();

    if ( m_version < D3DPS_VERSION(2,0) )
    {
        // tex instruction
        // sample dest, src0, t#i, s#i

        const DWORD dwStage = D3DSI_GETREGNUM( instr.GetDstToken() );

        const COperandBase src0 = this->EmitSrcOperand(instr, 0, 0);

        // if reading from a specialized depth texture implicitly use a comparison sample for 'Hardware Shadow Maps'
        if (TextureUsesHardwareShadowMapping(dwStage))
        {
            EmitSampleCmp(instr, dest, dwStage, src0);
        }
        else
        {
            this->EmitDstInstruction( instr.GetModifiers(),
                                      D3D10_SB_OPCODE_SAMPLE,
                                      dwStage,
                                      dest,
                                      src0,
                                      CResOperand4( dwStage ),
                                      COperand( D3D10_SB_OPERAND_TYPE_SAMPLER, dwStage ) );
        }
    }
    else
    {
        const DWORD dwInstr = instr.GetToken();
        const DWORD dwSrcToken1 = instr.GetSrcToken( 1 );
        const DWORD dwStage = D3DSI_GETREGNUM( dwSrcToken1 );
        CONST UINT maxComponentsNeeded = __getComponentsNeeded((TEXTURETYPE)m_rasterStates.PSSamplers[dwStage].TextureType, (m_rasterStates.HardwareShadowMappingRequiredPS & (1 << dwStage)) != 0);
        
        const COperandBase src0 = this->EmitSrcOperand(instr, 0);

        // Use the maskedSrc0 for the actual texture coordinate, masks off unused channels to ensure that the shader validator
        // doesn't complain about using an undeclared color channel
        const COperandBase maskedSrc0 = this->EmitSrcOperand(instr, 0, 0, maxComponentsNeeded);
        const UINT resSwizzle = __getSwizzle( dwSrcToken1, 4 );

        if ( dwInstr & D3DSI_TEXLD_PROJECT )
        {
            // texldp instruction: divide texture coordinates by 4th element
            // div    s0,  src0, src0.w
            // sample dest, s0, t#i, s#i

            m_pShaderAsm->EmitInstruction(
                CInstruction( D3D10_SB_OPCODE_DIV,
                              CTempOperandDst( SREG_TMP0 ),
                              maskedSrc0,
                              CSwizzle( src0, __SWIZZLE_W ) ) );

            if (TextureUsesHardwareShadowMapping(dwStage))
            {
                EmitSampleCmp(instr, dest, dwStage, CTempOperand4(SREG_TMP0));
            }
            else
            {
                this->EmitDstInstruction( instr.GetModifiers(),
                                          D3D10_SB_OPCODE_SAMPLE,
                                          dwStage,
                                          dest,
                                          CTempOperand4( SREG_TMP0 ),
                                          CResOperand4( dwStage, resSwizzle ),
                                          COperand( D3D10_SB_OPERAND_TYPE_SAMPLER, dwStage ) );
            }
        }
        else
        if ( dwInstr & D3DSI_TEXLD_BIAS )
        {
            if (TextureUsesHardwareShadowMapping(dwStage))
            {
                EmitSampleCmp(instr, dest, dwStage, maskedSrc0);
            }
            else 
            {
                // texldb instruction:/ bias lod with 4th element of texture coordinates
                // sample_b dest, src0, t#i, s#i, src0.w

                this->EmitDstInstruction( instr.GetModifiers(),
                                          D3D10_SB_OPCODE_SAMPLE_B,
                                          dwStage,
                                          dest,
                                          maskedSrc0,
                                          CResOperand4( dwStage, resSwizzle ),
                                          COperand( D3D10_SB_OPERAND_TYPE_SAMPLER, dwStage ),
                                          CSingleComponent( src0, D3D10_SB_4_COMPONENT_W ) );
            }
        }
        else
        {
            // texld instruction

            if (TextureUsesHardwareShadowMapping(dwStage))
            {
                EmitSampleCmp(instr, dest, dwStage, maskedSrc0);
            }
            else
            {
                // sample dest, src0, t#i, s#i

                this->EmitDstInstruction( instr.GetModifiers(),
                                          D3D10_SB_OPCODE_SAMPLE,
                                          dwStage,
                                          dest,
                                          maskedSrc0,
                                          CResOperand4( dwStage, resSwizzle ),
                                          COperand( D3D10_SB_OPERAND_TYPE_SAMPLER, dwStage ) );
            };
        }
    }
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_TEXLDD( const CInstr& instr )
{
    // sample_d dest, src0, t#i, s#i, src2, src3

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );
    const COperandBase src2 = this->EmitSrcOperand( instr, 2 );
    const COperandBase src3 = this->EmitSrcOperand( instr, 3 );

    const DWORD dwSrcToken1 = instr.GetSrcToken( 1 );
    const DWORD dwStage = D3DSI_GETREGNUM( dwSrcToken1 );
    const UINT resSwizzle = __getSwizzle( dwSrcToken1, 4 );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_SAMPLE_D,
                              dwStage,
                              dest,
                              src0,
                              CResOperand4( dwStage, resSwizzle ),
                              COperand( D3D10_SB_OPERAND_TYPE_SAMPLER, dwStage ),
                              src2,
                              src3 );
}

bool CContext::TextureUsesHardwareShadowMapping(DWORD stage) const
{
    bool bUsesHardwareShadowMapping = false;
    if (__IS_PS(m_version))
    {
        bUsesHardwareShadowMapping = m_rasterStates.HardwareShadowMappingRequiredPS & (1 << stage);
    }
    else if (__IS_VS(m_version))
    {
        if (m_rasterStates.HardwareShadowMappingRequiredVS & (1 << stage))
        {
            // Not expecting to need support for Hardware Shadow Mapping for VS
            SHADER_CONV_ASSERT(false);
        }
    }
    return bUsesHardwareShadowMapping;
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_TEXLDL( const CInstr& instr )
{
    // sample_l dest, src0, t#i, s#i, src0.w

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );

    const DWORD dwSrcToken1 = instr.GetSrcToken( 1 );
    const DWORD dwStage = D3DSI_GETREGNUM( dwSrcToken1 );
    const UINT resSwizzle = __getSwizzle( dwSrcToken1, 4 );

    if (TextureUsesHardwareShadowMapping(dwStage))
    {
        EmitSampleCmp(instr, dest, dwStage, src0);
    }
    else
    {
        this->EmitDstInstruction(instr.GetModifiers(),
            D3D10_SB_OPCODE_SAMPLE_L,
            dwStage,
            dest,
            src0,
            CResOperand4(dwStage, resSwizzle),
            COperand(D3D10_SB_OPERAND_TYPE_SAMPLER, dwStage),
            CSingleComponent(src0, D3D10_SB_4_COMPONENT_W));
    }
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_TEXREG2AR( const CInstr& instr )
{
    // mov s0, src0.wx
    // sample dest, s0, t#i, s#i

    SHADER_CONV_ASSERT( __IS_PS( m_version ) );
    SHADER_CONV_ASSERT( m_version <= D3DPS_VERSION(1,3) );

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );

    m_pShaderAsm->EmitInstruction(
                CInstruction( D3D10_SB_OPCODE_MOV,
                              CTempOperandDst( SREG_TMP0 ),
                              CSwizzle( src0, __SWIZZLE_WX ) ) );

    const DWORD dwStage = D3DSI_GETREGNUM( instr.GetDstToken() );
    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_SAMPLE,
                              dwStage,
                              dest,
                              CTempOperand4( SREG_TMP0 ),
                              CResOperand4( dwStage ),
                              COperand( D3D10_SB_OPERAND_TYPE_SAMPLER, dwStage ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_TEXREG2GB( const CInstr& instr )
{
    // mov s0, src0.yz
    // sample dest, s0, t#i, s#i

    SHADER_CONV_ASSERT( __IS_PS( m_version ) );
    SHADER_CONV_ASSERT( m_version <= D3DPS_VERSION(1,3) );

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );

    m_pShaderAsm->EmitInstruction(
                CInstruction( D3D10_SB_OPCODE_MOV,
                              CTempOperandDst( SREG_TMP0 ),
                              CSwizzle( src0,__SWIZZLE_YZ ) ) );

    const DWORD dwStage = D3DSI_GETREGNUM( instr.GetDstToken() );
    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_SAMPLE,
                              dwStage,
                              dest,
                              CTempOperand4( SREG_TMP0 ),
                              CResOperand4( dwStage ),
                              COperand( D3D10_SB_OPERAND_TYPE_SAMPLER, dwStage ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_TEXREG2RGB( const CInstr& instr )
{
    // mov s0, src0.xyz
    // sample dest, s0, t#i, s#i

    SHADER_CONV_ASSERT( __IS_PS( m_version ) );
    SHADER_CONV_ASSERT( m_version <= D3DPS_VERSION(1,3) );

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );

    m_pShaderAsm->EmitInstruction(
                CInstruction( D3D10_SB_OPCODE_MOV,
                              CTempOperandDst( SREG_TMP0 ),
                              CSwizzle( src0, __SWIZZLE_XYZ ) ) );

    const DWORD dwStage = D3DSI_GETREGNUM( instr.GetDstToken() );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_SAMPLE,
                              dwStage,
                              dest,
                              CTempOperand4( SREG_TMP0 ),
                              CResOperand4( dwStage ),
                              COperand( D3D10_SB_OPERAND_TYPE_SAMPLER, dwStage ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_TEXM3x2PAD( const CInstr& instr )
{
    // dp3 s0.x, src0, src1

    SHADER_CONV_ASSERT( __IS_PS( m_version ) );
    SHADER_CONV_ASSERT( m_version <= D3DPS_VERSION(1,3) );

    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );
    const COperandBase src1 = this->EmitSrcOperand( instr, 1 );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_DP3,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                      src0,
                      src1 ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_TEXM3x2TEX( const CInstr& instr )
{
    // dp3 s0.y, src0, src1
    // sample dest, s0, t#i, s#i

    SHADER_CONV_ASSERT( __IS_PS( m_version ) );
    SHADER_CONV_ASSERT( m_version <= D3DPS_VERSION(1,3) );

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );
    const COperandBase src1 = this->EmitSrcOperand( instr, 1 );

    const DWORD dwStage = D3DSI_GETREGNUM( instr.GetDstToken() );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_DP3,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Y ),
                      src0,
                      src1 ) );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_SAMPLE,
                              dwStage,
                              dest,
                              CTempOperand4( SREG_TMP0 ),
                              CResOperand4( dwStage ),
                              COperand( D3D10_SB_OPERAND_TYPE_SAMPLER, dwStage ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_TEXM3x2DEPTH( const CInstr& instr )
{
    // dp3 s0.y, src0, src1
    // ne s0.z, s0.y, vec4(0.0f)
    // movc s0.xy, s0.z, s0.xy, vec4(1.0f)
    // div oDepth, s0.x, s0.y

    SHADER_CONV_ASSERT( __IS_PS( m_version ) );
    SHADER_CONV_ASSERT( D3DPS_VERSION(1,3) == m_version );

    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );
    const COperandBase src1 = this->EmitSrcOperand( instr, 1 );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_DP3,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Y ),
                      src0,
                      src1 ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_NE,
                      CTempOperandDst( SREG_TMP0,D3D10_SB_OPERAND_4_COMPONENT_MASK_Z ),
                      CTempOperand4( SREG_TMP0, __SWIZZLE_Y ),
                      COperand( 0.0f ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MOVC,
                      CTempOperandDst( SREG_TMP0,__WRITEMASK_XY ),
                      CTempOperand4( SREG_TMP0, __SWIZZLE_Z ),
                      CTempOperand4( SREG_TMP0, __SWIZZLE_XY ),
                      COperand( 1.0f ) ) );

    Modifiers modifiers = instr.GetModifiers();
    modifiers._SATURATE = 1;

    this->EmitDstInstruction( modifiers,
                              D3D10_SB_OPCODE_DIV,
                              CTempOperandDst( m_outputRegs.oDepth ),
                              CTempOperand4( SREG_TMP0, __SWIZZLE_X ),
                              CTempOperand4( SREG_TMP0, __SWIZZLE_Y ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_TEXM3x3PAD( const CInstr& instr )
{
    // dp3 s0.[i], src0, src1

    SHADER_CONV_ASSERT( __IS_PS( m_version ) );
    SHADER_CONV_ASSERT( m_version <= D3DPS_VERSION(1,3) );

    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );
    const COperandBase src1 = this->EmitSrcOperand( instr, 1 );

    const UINT writeMask = ( m_toggleTEXM3x3PAD ) ? D3D10_SB_OPERAND_4_COMPONENT_MASK_Y :
                                                    D3D10_SB_OPERAND_4_COMPONENT_MASK_X;
    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_DP3,
                      CTempOperandDst( SREG_TMP0, writeMask ),
                      src0,
                      src1 ) );

    // Toggle the bit for the next instruction
    m_toggleTEXM3x3PAD ^= 1;
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_TEXM3x3( const CInstr& instr )
{
    // dp3 s0.z, src0, src1
    // mov s0.w, vec4(1.0f)
    // mov dest, s0

    SHADER_CONV_ASSERT( __IS_PS( m_version ) );
    SHADER_CONV_ASSERT( m_version >= D3DPS_VERSION(1,2) &&
                m_version <= D3DPS_VERSION(1,3) );

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );
    const COperandBase src1 = this->EmitSrcOperand( instr, 1 );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_DP3,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Z ),
                      src0,
                      src1 ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MOV,
                      CTempOperandDst( SREG_TMP0,D3D10_SB_OPERAND_4_COMPONENT_MASK_W ),
                      COperand( 1.0f ) ) );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_MOV,
                              dest,
                              CTempOperand4( SREG_TMP0 ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_TEXM3x3TEX( const CInstr& instr )
{
    // dp3 s0.z, src0, src1
    // sample dest, s0, t#i, s#i

    SHADER_CONV_ASSERT( __IS_PS( m_version ) );
    SHADER_CONV_ASSERT( m_version <= D3DPS_VERSION(1,3) );

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );
    const COperandBase src1 = this->EmitSrcOperand( instr, 1 );

    const DWORD dwStage = D3DSI_GETREGNUM( instr.GetDstToken() );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_DP3,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Z ),
                      src0,
                      src1 ) );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_SAMPLE,
                              dwStage,
                              dest,
                              CTempOperand4( SREG_TMP0 ),
                              CResOperand4( dwStage ),
                              COperand( D3D10_SB_OPERAND_TYPE_SAMPLER, dwStage ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_TEXM3x3SPEC( const CInstr& instr )
{
    // RF = 2.0f * N.E * N - E * N.N

    // dp3 s0.z, src0, src1
    // dp3 s1.w, s0, s0
    // mul s1, src2, s1.w
    // dp3 s0.w, s0, src2
    // mul s0, s0, s0.w
    // mad s0, vec4(2.0f), s0, -s1
    // sample dest, s0, t#i, s#i

    SHADER_CONV_ASSERT( __IS_PS( m_version ) );
    SHADER_CONV_ASSERT( m_version <= D3DPS_VERSION(1,3) );

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );
    const COperandBase src1 = this->EmitSrcOperand( instr, 1 );
    const COperandBase src2 = this->EmitSrcOperand( instr, 2 );

    const DWORD dwStage = D3DSI_GETREGNUM( instr.GetDstToken() );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_DP3,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Z ),
                      src0,
                      src1 ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_DP3,
                      CTempOperandDst( SREG_TMP1, D3D10_SB_OPERAND_4_COMPONENT_MASK_W ),
                      CTempOperand4( SREG_TMP0 ),
                      CTempOperand4( SREG_TMP0 ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MUL,
                      CTempOperandDst( SREG_TMP1 ),
                      src2,
                      CTempOperand4( SREG_TMP1, __SWIZZLE_W ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_DP3,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_W ),
                      CTempOperand4( SREG_TMP0 ),
                      src2 ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MUL,
                      CTempOperandDst( SREG_TMP0 ),
                      CTempOperand4( SREG_TMP0 ),
                      CTempOperand4( SREG_TMP0, __SWIZZLE_W ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MAD,
                      CTempOperandDst( SREG_TMP0 ),
                      COperand( 2.0f ),
                      CTempOperand4( SREG_TMP0 ),
                      CNegate( CTempOperand4( SREG_TMP1 ) ) ) );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_SAMPLE,
                              dwStage,
                              dest,
                              CTempOperand4( SREG_TMP0 ),
                              CResOperand4( dwStage ),
                              COperand( D3D10_SB_OPERAND_TYPE_SAMPLER, dwStage ) );
}

DWORD
GetTextureRegisterIndex([[maybe_unused]] UINT version, DWORD dwRegNum)
{
    SHADER_CONV_ASSERT(__IS_PS(version));
    DWORD dwRegIndex = dwRegNum + VSOREG_TexCoord0;
    return dwRegIndex;
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_TEXM3x3VSPEC( const CInstr& instr )
{
    // RF = 2.0f * N.E * N - E * N.N

    // dp3 s0.z, src0, src1
    // mov s1.x, TC[stage-2].w
    // mov s1.y, TC[stage-1].w
    // mov s1.z, TC[stage].w
    // dp3 s0.w, s0, s1
    // dp3 s1.w, s0, s0
    // mul s1, s1, s1.w
    // mul s0, s0, s0.w
    // mad s0, vec4(2.0f), s0, -s1
    // sample dest, s0, t#i, s#i

    SHADER_CONV_ASSERT( __IS_PS( m_version ) );
    SHADER_CONV_ASSERT( m_version <= D3DPS_VERSION(1,3) );

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );
    const COperandBase src1 = this->EmitSrcOperand( instr, 1 );

    const DWORD dwStage = D3DSI_GETREGNUM( instr.GetDstToken() );
    SHADER_CONV_ASSERT( dwStage >= 2 );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_DP3,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Z ),
                      src0,
                      src1 ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction(D3D10_SB_OPCODE_MOV,
                     CTempOperandDst(SREG_TMP1, D3D10_SB_OPERAND_4_COMPONENT_MASK_X),
                     this->EmitInputOperand(GetTextureRegisterIndex(m_version, dwStage-2), __SWIZZLE_W)));

    m_pShaderAsm->EmitInstruction(
        CInstruction(D3D10_SB_OPCODE_MOV,
                     CTempOperandDst(SREG_TMP1, D3D10_SB_OPERAND_4_COMPONENT_MASK_Y),
                     this->EmitInputOperand(GetTextureRegisterIndex(m_version, dwStage-1), __SWIZZLE_W)));

    m_pShaderAsm->EmitInstruction(
        CInstruction(D3D10_SB_OPCODE_MOV,
                     CTempOperandDst(SREG_TMP1, D3D10_SB_OPERAND_4_COMPONENT_MASK_Z),
                     this->EmitInputOperand(GetTextureRegisterIndex(m_version, dwStage), __SWIZZLE_W)));

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_DP3,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_W ),
                      CTempOperand4( SREG_TMP0 ),
                      CTempOperand4( SREG_TMP1 ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_DP3,
                      CTempOperandDst( SREG_TMP1, D3D10_SB_OPERAND_4_COMPONENT_MASK_W ),
                      CTempOperand4( SREG_TMP0 ),
                      CTempOperand4( SREG_TMP0 ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MUL,
                      CTempOperandDst( SREG_TMP1 ),
                      CTempOperand4( SREG_TMP1 ),
                      CTempOperand4( SREG_TMP1, __SWIZZLE_W ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MUL,
                      CTempOperandDst( SREG_TMP0 ),
                      CTempOperand4( SREG_TMP0 ),
                      CTempOperand4( SREG_TMP0, __SWIZZLE_W ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MAD,
                      CTempOperandDst( SREG_TMP0 ),
                      COperand( 2.0f ),
                      CTempOperand4( SREG_TMP0 ),
                      CNegate( CTempOperand4( SREG_TMP1 ) ) ) );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_SAMPLE,
                              dwStage,
                              dest,
                              CTempOperand4( SREG_TMP0 ),
                              CResOperand4( dwStage ),
                              COperand( D3D10_SB_OPERAND_TYPE_SAMPLER, dwStage ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_TEXCOORD( const CInstr& instr )
{
    // mov[_sat] dest, src0

    SHADER_CONV_ASSERT( __IS_PS( m_version ) );
    SHADER_CONV_ASSERT( m_version < D3DPS_VERSION(2,0) );

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );    

    // Retrieve the input write mask
    UINT writeMask = D3D10_SB_OPERAND_4_COMPONENT_MASK_ALL;
    {
        const UINT regIndex = src0.RegIndex();    
        const VSOutputDecls& inputDecls = reinterpret_cast<CPSContext*>(this)->GetInputDecls();
        for (UINT i = 0, n = inputDecls.GetSize(); i < n; ++i)
        {
            if ((inputDecls[i].WriteMask != 0)
             && (regIndex == inputDecls[i].RegIndex))
            {
                writeMask = inputDecls[i].WriteMask << D3D10_SB_OPERAND_4_COMPONENT_MASK_SHIFT;
                break;
            }
        }
    }

    Modifiers modifiers = instr.GetModifiers();

    if ( m_version <= D3DPS_VERSION(1,3) )
    {
        modifiers._SATURATE = 1;
    }

    // Move source texture coordinate value to destination register
    this->EmitDstInstruction( modifiers,
                              D3D10_SB_OPCODE_MOV,
                              CWriteMask( dest, writeMask ),
                              src0 );

    //
    // Set the default value for missing components
    //

    switch ( writeMask )
    {
    case D3D10_SB_OPERAND_4_COMPONENT_MASK_X:
        writeMask = __WRITEMASK_YZW;
        break;

    case D3D10_SB_OPERAND_4_COMPONENT_MASK_X |
         D3D10_SB_OPERAND_4_COMPONENT_MASK_Y :
        writeMask = __WRITEMASK_ZW;
        break;

    case D3D10_SB_OPERAND_4_COMPONENT_MASK_X |
         D3D10_SB_OPERAND_4_COMPONENT_MASK_Y |
         D3D10_SB_OPERAND_4_COMPONENT_MASK_Z:
        writeMask = D3D10_SB_OPERAND_4_COMPONENT_MASK_W;
        break;
    }

    if ( writeMask != D3D10_SB_OPERAND_4_COMPONENT_MASK_ALL)
    {
        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_MOV,
                          CWriteMask( dest, writeMask ),
                          COperand( 0.0f, 0.0f, 0.0f, 1.0f ) ) );
    }
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_TEXDEPTH( const CInstr& instr )
{
    SHADER_CONV_ASSERT( __IS_PS( m_version ) );
    SHADER_CONV_ASSERT( D3DPS_VERSION(1,4) == m_version );

    // ne s0.z, dst.y, vec4(0.0f)
    // movc s0.xy, s0.z, dst.xy, vec4(1.0f)
    // div oDepth, s0.x, s0.y

    const DWORD dwRegNum = D3DSI_GETREGNUM( instr.GetDstToken() );

    SHADER_CONV_ASSERT( dwRegNum < MAX_TEMP_REGS );
    const DWORD dwRegIndex = m_inputRegs.r[dwRegNum];

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_NE,
                      CTempOperandDst( SREG_TMP0,D3D10_SB_OPERAND_4_COMPONENT_MASK_Z ),
                      CTempOperand4( dwRegIndex, __SWIZZLE_Y ),
                      COperand( 0.0f ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MOVC,
                      CTempOperandDst( SREG_TMP0, __WRITEMASK_XY ),
                      CTempOperand4( SREG_TMP0, __SWIZZLE_Z ),
                      CTempOperand4( dwRegIndex, __SWIZZLE_XY ),
                      COperand( 1.0f ) ) );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_DIV,
                              CTempOperandDst( m_outputRegs.oDepth ),
                              CTempOperand4( SREG_TMP0, __SWIZZLE_X ),
                              CTempOperand4( SREG_TMP0, __SWIZZLE_Y ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_TEXDP3( const CInstr& instr )
{
    // dp3 dest, src0, src1

    SHADER_CONV_ASSERT( __IS_PS( m_version ) );
    SHADER_CONV_ASSERT( m_version >= D3DPS_VERSION(1,2) &&
                m_version <= D3DPS_VERSION(1,3) );

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );
    const COperandBase src1 = this->EmitSrcOperand( instr, 1 );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_DP3,
                              dest,
                              src0,
                              src1 );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_TEXDP3TEX( const CInstr& instr )
{
    // dp3 s0.x, src0, src1
    // mov s0.yz vec4(0.0f)
    // sample dest, s0, t#i, s#i

    SHADER_CONV_ASSERT( __IS_PS( m_version ) );
    SHADER_CONV_ASSERT( m_version >= D3DPS_VERSION(1,2) &&
                m_version <= D3DPS_VERSION(1,3) );

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );
    const COperandBase src1 = this->EmitSrcOperand( instr, 1 );

    const DWORD dwStage = D3DSI_GETREGNUM( instr.GetDstToken() );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_DP3,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                      src0,
                      src1 ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MOV,
                      CTempOperandDst( SREG_TMP0, __WRITEMASK_YZ ),
                      COperand( 0.0f ) ) );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_SAMPLE,
                              dwStage,
                              dest,
                              CTempOperand4( SREG_TMP0 ),
                              CResOperand4( dwStage ),
                              COperand( D3D10_SB_OPERAND_TYPE_SAMPLER, dwStage ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_BEM( const CInstr& instr )
{
    SHADER_CONV_ASSERT( __IS_PS( m_version ) );
    SHADER_CONV_ASSERT( D3DPS_VERSION(1,4) == m_version );

    // mul s0.x, cb3[i].x, src1.x
    // mad s0.x, cb3[i].z, src1.y, s0.x
    // add s0.x, s0.x, src0.x
    // mul s0.y, cb3[i].y, src1.x
    // mad s0.y, cb3[i].w, src1.y, s0.y
    // add s0.y, s0.y, src0.y
    // mov dest, s0

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );
    const COperandBase src1 = this->EmitSrcOperand( instr, 1 );

    const DWORD dwDstReg = D3DSI_GETREGNUM( instr.GetDstToken() );
    const UINT i = PSCBExtension2::BUMPENVMAT0 + dwDstReg;

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MUL,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                      CCBOperand2D( CB_PS_EXT2, i, __SWIZZLE_X ),
                      CSwizzle( src1, __SWIZZLE_X ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MAD,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                      CCBOperand2D( CB_PS_EXT2, i, __SWIZZLE_Z ),
                      CSwizzle( src1, __SWIZZLE_Y ),
                      CTempOperand4( SREG_TMP0, __SWIZZLE_X ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_ADD,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                      CTempOperand4( SREG_TMP0, __SWIZZLE_X ),
                      CSwizzle( src0, __SWIZZLE_X ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MUL,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Y ),
                      CCBOperand2D( CB_PS_EXT2, i, __SWIZZLE_Y ),
                      CSwizzle( src1, __SWIZZLE_X ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MAD,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Y ),
                      CCBOperand2D( CB_PS_EXT2, i, __SWIZZLE_W ),
                      CSwizzle( src1, __SWIZZLE_Y ),
                      CTempOperand4( SREG_TMP0, __SWIZZLE_Y ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_ADD,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Y ),
                      CTempOperand4( SREG_TMP0, __SWIZZLE_Y ),
                      CSwizzle( src0, __SWIZZLE_Y ) ) );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_MOV,
                              dest,
                              CTempOperand4( SREG_TMP0 ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_TEXBEM( const CInstr& instr )
{
    SHADER_CONV_ASSERT( __IS_PS( m_version ) );
    SHADER_CONV_ASSERT( m_version <= D3DPS_VERSION(1,3) );

    // mul s0.x, c3[i].x, src0.x
    // mad s0.x, c3[i].y, src0.y, s0.x
    // add s0.x, s0.x, TC[i].x
    // mul s0.y, c3[i].z, src0.x
    // mad s0.y, c3[i].w, src0.y, s0.y
    // add s0.y, s0.y, TC[i].y
    // sample dest, s0, t#i, s#i

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );
    const COperandBase src1 = this->EmitSrcOperand( instr, 1 );

    const DWORD dwStage = D3DSI_GETREGNUM( instr.GetDstToken() );
    const UINT i = PSCBExtension2::BUMPENVMAT0 + dwStage;

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MUL,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                      CCBOperand2D( CB_PS_EXT2, i, __SWIZZLE_X ),
                      CSwizzle( src1, __SWIZZLE_X ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MAD,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                      CCBOperand2D( CB_PS_EXT2, i, __SWIZZLE_Y ),
                      CSwizzle( src1, __SWIZZLE_Y ),
                      CTempOperand4( SREG_TMP0, __SWIZZLE_X ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_ADD,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                      CTempOperand4( SREG_TMP0, __SWIZZLE_X ),
                      CSwizzle( src0, __SWIZZLE_X ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MUL,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Y ),
                      CCBOperand2D( CB_PS_EXT2, i, __SWIZZLE_Z ),
                      CSwizzle( src1, __SWIZZLE_X ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MAD,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Y ),
                      CCBOperand2D( CB_PS_EXT2, i, __SWIZZLE_W ),
                      CSwizzle( src1, __SWIZZLE_Y ),
                      CTempOperand4( SREG_TMP0, __SWIZZLE_Y ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_ADD,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Y ),
                      CTempOperand4( SREG_TMP0, __SWIZZLE_Y ),
                      CSwizzle( src0, __SWIZZLE_Y ) ) );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_SAMPLE,
                              dwStage,
                              dest,
                              CTempOperand4( SREG_TMP0 ),
                              CResOperand4( dwStage ),
                              COperand( D3D10_SB_OPERAND_TYPE_SAMPLER, dwStage ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_TEXBEML( const CInstr& instr )
{
    // mul s0.x, c3[i].x, src0.x
    // mad s0.x, c3[i].y, src0.y, s0.x
    // add s0.x, s0.x, TC[i].x
    // mul s0.y, c3[i].z, src0.x
    // mad s0.y, c3[i].w, src0.y, s0.y
    // add s0.y, s0.y, TC[i].y
    // sample s0, s0, t#i, s#i
    // mad s1.x, c3[j].x, src0.z, c3[j].y
    // mul dest, s0, s1.x

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );
    const COperandBase src1 = this->EmitSrcOperand( instr, 1 );

    const DWORD dwStage = D3DSI_GETREGNUM( instr.GetDstToken() );
    const UINT i = PSCBExtension2::BUMPENVMAT0 + dwStage;
    const UINT j = PSCBExtension2::BUMPENVL0 + dwStage;

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MUL,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                      CCBOperand2D( CB_PS_EXT2, i, __SWIZZLE_X ),
                      CSwizzle( src1, __SWIZZLE_X ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MAD,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                      CCBOperand2D( CB_PS_EXT2, i, __SWIZZLE_Y ),
                      CSwizzle( src1, __SWIZZLE_Y ),
                      CTempOperand4( SREG_TMP0, __SWIZZLE_X ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_ADD,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                      CTempOperand4( SREG_TMP0, __SWIZZLE_X ),
                      CSwizzle( src0, __SWIZZLE_X ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MUL,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Y ),
                      CCBOperand2D( CB_PS_EXT2, i, __SWIZZLE_Z ),
                      CSwizzle( src1, __SWIZZLE_X ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MAD,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Y ),
                      CCBOperand2D( CB_PS_EXT2, i, __SWIZZLE_W ),
                      CSwizzle( src1, __SWIZZLE_Y ),
                      CTempOperand4( SREG_TMP0, __SWIZZLE_Y ) ) );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_ADD,
                      CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Y ),
                      CTempOperand4( SREG_TMP0, __SWIZZLE_Y ),
                      CSwizzle( src0, __SWIZZLE_Y ) ) );

    COperandBase resOperand = CResOperand4( dwStage );

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_SAMPLE,
                      CTempOperandDst( SREG_TMP0 ),
                      CTempOperand4( SREG_TMP0 ),
                      resOperand,
                      COperand( D3D10_SB_OPERAND_TYPE_SAMPLER, dwStage ) ) );

    UINT samplerSwizzle = (m_rasterStates.SamplerSwizzleMask >> (dwStage * SAMPLER_SWIZZLE_BITS)) & SAMPLER_SWIZZLE_MASK;

    if (samplerSwizzle)
    {
        this->EmitSamplerSwizzle(CTempOperandDst(SREG_TMP0), CTempOperand4(SREG_TMP0), (SAMPLER_SWIZZLE)samplerSwizzle);
    }

    if (m_rasterStates.ColorKeyEnable
     || m_rasterStates.ColorKeyBlendEnable)
    {
        this->EmitColorKeyModifier(dwStage, CTempOperandDst(SREG_TMP0), CTempOperand4(SREG_TMP0));
    }

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MAD,
                      CTempOperandDst( SREG_TMP1, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                      CCBOperand2D( CB_PS_EXT2, j, __SWIZZLE_X ),
                      CSwizzle( src0, __SWIZZLE_Z ),
                      CCBOperand2D( CB_PS_EXT2, j, __SWIZZLE_Y ) ) );

    this->EmitDstInstruction( instr.GetModifiers(),
                              D3D10_SB_OPCODE_MUL,
                              dest,
                              CTempOperand4( SREG_TMP0 ),
                              CTempOperand4( SREG_TMP1, __SWIZZLE_X ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Translate_SETP( const CInstr& instr )
{
    // <comp> dest, src0, src1

    const COperandBase dest = instr.CreateDstOperand();
    const COperandBase src0 = this->EmitSrcOperand( instr, 0 );
    const COperandBase src1 = this->EmitSrcOperand( instr, 1 );

    const D3DSHADER_COMPARISON compare = D3DSI_GETCOMPARISON( instr.GetToken() );

    this->Compare( compare, dest, src0, src1 );
}

//////////////////////////////////////////////////////////////////////////////

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::Compare( D3DSHADER_COMPARISON comp,
                   const COperandBase& dstOperand,
                   const COperandBase& srcOperand0,
                   const COperandBase& srcOperand1 ) const
{
    D3D10_SB_OPCODE_TYPE opcode;
    bool bSwapOperands = false;

    switch ( comp )
    {
    default:
        NO_DEFAULT;

    case D3DSPC_GT:
        opcode = D3D10_SB_OPCODE_LT;
        bSwapOperands = true;
        break;

    case D3DSPC_EQ:
        opcode = D3D10_SB_OPCODE_EQ;
        break;

    case D3DSPC_GE:
        opcode = D3D10_SB_OPCODE_GE;
        break;

    case D3DSPC_LT:
        opcode = D3D10_SB_OPCODE_LT;
        break;

    case D3DSPC_NE:
        opcode = D3D10_SB_OPCODE_NE;
        break;

    case D3DSPC_LE:
        opcode = D3D10_SB_OPCODE_GE;
        bSwapOperands = true;
        break;
    }

    m_pShaderAsm->EmitInstruction(
        CInstruction( opcode,
                      dstOperand,
                      bSwapOperands ? srcOperand1 : srcOperand0,
                      bSwapOperands ? srcOperand0 : srcOperand1 ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::EmitShiftModifier( UINT shiftMask,
                             bool bSaturate,
                             const COperandBase& dstOperand,
                             const COperandBase& srcOperand )
{
    float fValue;

    switch ( shiftMask )
    {
    default:
        NO_DEFAULT;

    case 0x1:   // x2
        fValue = 2.0f;
        break;

    case 0x2:   // x4
        fValue = 4.0f;
        break;

    case 0x3:   // x8
        fValue = 8.0f;
        break;

    case 0xF:   // d2
        fValue = 0.5f;
        break;

    case 0xE:   // d4
        fValue = 0.25f;
        break;

    case 0xD:   // d8
        fValue = 0.125f;
        break;
    }

     m_pShaderAsm->EmitInstruction(
            CInstructionEx( D3D10_SB_OPCODE_MUL,
                            bSaturate,
                            dstOperand,
                            srcOperand,
                            COperand( fValue ) ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::EmitSamplerSwizzle( const COperandBase& dstOperand,
                              const COperandBase& srcOperand,
                              SAMPLER_SWIZZLE swizzle )
{
    // Converts data sampled from a D3D11 texture to D3D9 format:
    //
    //  mov dest, src.rrra  ; for luminance formats
    //  mov dest, src.raaa  ; for single channel formats
    //  mov dest, src.rgaa  ; for two channel formats

    COperandBase swizzledSrc(srcOperand);

    switch (swizzle)
    {
        case SAMPLER_SWIZZLE_RRRA:
            // Luminance texture format: swizzle (r, 0, 0, 1) -> (r, r, r, 1)
            // This is because shim uses D3D11 R8/R16 formats to emulate D3D9 L8/L16 types.
            swizzledSrc.m_Swizzle[1] = swizzledSrc.m_Swizzle[0];
            swizzledSrc.m_Swizzle[2] = swizzledSrc.m_Swizzle[0];
            break;
            
        case SAMPLER_SWIZZLE_RAAA:
            // Single channel texture format: swizzle (r, 0, 0, 1) -> (r, 1, 1, 1)
            // This is because D3D11 DDI returns 0 in unused g/b channels, but D3D9 expects 1.
            // We have no good way to generate a 1 value in patched shader code, but can simply
            // copy this over from the alpha component, which is always 1 for these formats.
            swizzledSrc.m_Swizzle[1] = swizzledSrc.m_Swizzle[3];
            swizzledSrc.m_Swizzle[2] = swizzledSrc.m_Swizzle[3];
            break;
            
        case SAMPLER_SWIZZLE_RGAA:
            // Two channel texture format: swizzle (r, g, 0, 1) -> (r, g, 1, 1)
            swizzledSrc.m_Swizzle[2] = swizzledSrc.m_Swizzle[3];
            break;
        
        default:
            SHADER_CONV_ASSERT(false);
    }

    m_pShaderAsm->EmitInstruction(
        CInstruction( D3D10_SB_OPCODE_MOV, dstOperand, swizzledSrc ) );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::EmitColorKeyModifier( UINT stage,
                                const COperandBase& dstOperand,
                                const COperandBase& srcOperand )
{
    SHADER_CONV_ASSERT(m_rasterStates.ColorKeyEnable || m_rasterStates.ColorKeyBlendEnable);

    if (0 == (m_rasterStates.ColorKeyTSSDisable & (1 << stage)))
    {
        // Apply colorkey

        // eq m0, src, colorkey[i]
        // and m0.x, m0.x, m0.y
        // and m0.x, m0.x, m0.z
        // and m0.x, m0.x, m0.w
        // (1) discard_nz s0.i
        // (2) movc dst, m0, zero, src

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_EQ,
                            CTempOperandDst( SREG_MOD0 ),
                            srcOperand,
                            CCBOperand2D( CB_PS_EXT3, PSCBExtension3::COLORKEY0 + stage ) ) );

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_AND,
                            CTempOperandDst( SREG_MOD0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                            CTempOperand4( SREG_MOD0, __SWIZZLE_X ),
                            CTempOperand4( SREG_MOD0, __SWIZZLE_Y ) ) );

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_AND,
                            CTempOperandDst( SREG_MOD0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                            CTempOperand4( SREG_MOD0, __SWIZZLE_X ),
                            CTempOperand4( SREG_MOD0, __SWIZZLE_Z ) ) );

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_AND,
                            CTempOperandDst( SREG_MOD0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                            CTempOperand4( SREG_MOD0, __SWIZZLE_X ),
                            CTempOperand4( SREG_MOD0, __SWIZZLE_W ) ) );

        if (m_rasterStates.ColorKeyEnable)
        {
            m_pShaderAsm->EmitInstruction(
                CInstruction( D3D10_SB_OPCODE_DISCARD,
                                CTempOperand1( SREG_MOD0, D3D10_SB_4_COMPONENT_X),
                                D3D10_SB_INSTRUCTION_TEST_NONZERO ) );

            m_pShaderAsm->EmitInstruction(
                CInstruction( D3D10_SB_OPCODE_MOV, dstOperand, srcOperand ) );
        }
        else
        {
            m_pShaderAsm->EmitInstruction(
                CInstruction( D3D10_SB_OPCODE_MOVC,
                                dstOperand,
                                CTempOperand4( SREG_MOD0, __SWIZZLE_X ),
                                COperand( 0.0f ),
                                srcOperand ) );
        }
    }


    else
    {
        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_MOV, dstOperand, srcOperand ) );
    }
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CContext::EmitDstInstruction( const Modifiers& modifiers,
                              D3D10_SB_OPCODE_TYPE opCode,
                              UINT stage,
                              UINT NumSrcOperands,
                              const COperandBase* pDst,
                              ...)
{
    CInstructionEx instruction(opCode);

    va_list args;
    va_start(args, pDst);

    for (UINT i = 0; i < NumSrcOperands; ++i)
    {
        const COperandBase* const pOperand = va_arg(args, const COperandBase*);
        instruction.SetOperand(i + 1, *pOperand);
    }

    va_end(args);

    const bool bSaturate = modifiers._SATURATE ? true : false;

    const bool isSampleInstruction = (opCode == D3D10_SB_OPCODE_SAMPLE) ||
                                     (opCode == D3D10_SB_OPCODE_SAMPLE_B) ||
                                     (opCode == D3D10_SB_OPCODE_SAMPLE_D) ||
                                     (opCode == D3D10_SB_OPCODE_SAMPLE_L);

    const UINT samplerSwizzle = (m_rasterStates.SamplerSwizzleMask >> (stage * SAMPLER_SWIZZLE_BITS)) & SAMPLER_SWIZZLE_MASK;

    const bool needsSamplerSwizzle = isSampleInstruction && (samplerSwizzle != 0);

    if (modifiers._SHIFT
     || needsSamplerSwizzle
     || m_rasterStates.ColorKeyEnable
     || m_rasterStates.ColorKeyBlendEnable)
    {
        CTempOperandDst dstTmp0(SREG_TMP0);
        CTempOperand4   srcTmp0(SREG_TMP0);

        instruction.SetOperand(0, dstTmp0);
        m_pShaderAsm->EmitInstruction(instruction);

        if (needsSamplerSwizzle)
        {
            this->EmitSamplerSwizzle(dstTmp0, srcTmp0, (SAMPLER_SWIZZLE)samplerSwizzle);
        }

        if (m_rasterStates.ColorKeyEnable
         || m_rasterStates.ColorKeyBlendEnable)
        {
            this->EmitColorKeyModifier(stage, dstTmp0, srcTmp0);
        }

        if (modifiers._SHIFT)
        {
            this->EmitShiftModifier(modifiers._SHIFT, bSaturate, *pDst, srcTmp0);
        }
        else
        {
            m_pShaderAsm->EmitInstruction(
                CInstructionEx(D3D10_SB_OPCODE_MOV, bSaturate, *pDst, srcTmp0));
        }
    }
    else
    {
        instruction.SetOperand(0, *pDst);
        instruction.SetSaturate(bSaturate);
        m_pShaderAsm->EmitInstruction(instruction);
    }
}


UINT MaskSwizzleWithWriteMask(UINT swizzle, UINT writeMask)
{
    UINT newSwizzle = 0;
    for (UINT i = 0; i < 4; ++i)
    {
        const UINT comp = __UNSWIZZLEN(i, swizzle);
        if (D3D10_SB_OPERAND_4_COMPONENT_MASK(comp) & writeMask)
        {
            newSwizzle |= __SWIZZLEN(i, comp);
        }
    }
    return newSwizzle;
}


DWORD
GetInputRegisterIndex(UINT version, DWORD dwRegNum)
{
    DWORD dwRegIndex = dwRegNum;
    if (__IS_PS(version) && version < D3DPS_VERSION(3, 0))
    {
        dwRegIndex += VSOREG_Color0;
    }

    return dwRegIndex;
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
COperandBase
CContext::EmitSrcOperand( const CInstr& instr,
                          DWORD dwIndex,
                          DWORD dwOffset,
                          DWORD dwSwizzleCount)
{
    const DWORD dwToken    = instr.GetSrcToken( dwIndex );
    const DWORD dwModifier = ( dwToken & D3DSP_SRCMOD_MASK );
    const DWORD dwRegType  = D3DSI_GETREGTYPE_RESOLVING_CONSTANTS( dwToken );

    if (dwRegType == D3DSPR_TEXTURE)
    {
        [[maybe_unused]] const DWORD dwRegNum = D3DSI_GETREGNUM_RESOLVING_CONSTANTS(dwToken) + dwOffset;
        SHADER_CONV_ASSERT(dwRegNum < MAX_PS_TEXCOORD_REGS);
    }

    UINT swizzle     = __getSwizzle( dwToken, dwSwizzleCount);

    COperandBase srcOperand = instr.CreateSrcOperand( dwToken, dwOffset );

    if ( D3DSPR_CONSTBOOL == dwRegType )
    {
        return srcOperand;
    }

    if ( D3D10_SB_OPERAND_TYPE_IMMEDIATE32 == srcOperand.OperandType() )
    {
        return this->EmitImmOperand( srcOperand, dwModifier, swizzle );
    }

    //
    // Apply register addressing
    //

    if ( D3DSI_GETADDRESSMODE( dwToken ) & D3DSHADER_ADDRMODE_RELATIVE )
    {
        const DWORD dwAddrToken = instr.GetSrcAddress( dwIndex );
        instr.ApplyAddressing( srcOperand, dwAddrToken, ( D3DSPR_INPUT == dwRegType ) ? 0 : 1 );
    }

    // Force a [-1,1] clamp after applying modifier (for PS 1.x constants only)
    // This overrides the the standard [-PixelShader1xMaxValue,PixelShader1xMaxValue] clamp.

    if ( __IS_PS( m_version ) &&
         m_version < D3DPS_VERSION(2,0) &&
         D3DSPR_CONST == dwRegType )
    {
        // max s2, src[i], vec4(-1.0f)
        // min m[i], s2, vec4(1.0f)

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_MAX,
                          CTempOperandDst( SREG_TMP2 ),
                          srcOperand,
                          COperand( -1.0f ) ) );

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_MIN,
                          CTempOperandDst( SREG_MOD0 + dwIndex ),
                          CTempOperand4( SREG_TMP2 ),
                          COperand( 1.0f ) ) );

        srcOperand = CTempOperand4( SREG_MOD0 + dwIndex );
    }

    switch ( dwModifier )
    {
    case D3DSPSM_DZ:
    case D3DSPSM_DW:
        // mov  s2, src
        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_MOV, CTempOperandDst( SREG_TMP2 ), srcOperand ) );

        switch ( dwModifier )
        {
        case D3DSPSM_DZ:
            // div  m[i].xy, s2.xy, s2.z
            m_pShaderAsm->EmitInstruction(
                CInstruction( D3D10_SB_OPCODE_DIV,
                              CTempOperandDst( SREG_MOD0 + dwIndex, __WRITEMASK_XY ),
                              CTempOperand4( SREG_TMP2, __SWIZZLE_XY ),
                              CTempOperand4( SREG_TMP2, __SWIZZLE_Z ) ) );
            break;

        case D3DSPSM_DW:
            // div  m[i].xy, s2.xy, s2.w
            m_pShaderAsm->EmitInstruction(
                CInstruction( D3D10_SB_OPCODE_DIV,
                              CTempOperandDst( SREG_MOD0 + dwIndex, __WRITEMASK_XYZ ),
                              CTempOperand4( SREG_TMP2, __SWIZZLE_XYZ ),
                              CTempOperand4( SREG_TMP2, __SWIZZLE_W ) ) );
            break;
        }
        srcOperand = CTempOperand4( SREG_MOD0 + dwIndex );
        break;

    case D3DSPSM_BIASNEG:
    case D3DSPSM_BIAS:
        // add  m[i], src, vec4(-0.5f)
        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_ADD,
                          CTempOperandDst( SREG_MOD0 + dwIndex ),
                          srcOperand,
                          COperand( -0.5f ) ) );
        srcOperand = CTempOperand4( SREG_MOD0 + dwIndex );
        break;

    case D3DSPSM_SIGNNEG:
    case D3DSPSM_SIGN:
        // mad m[i], src, vec4(2.0f), vec4(-1.0f)
        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_MAD,
                          CTempOperandDst( SREG_MOD0 + dwIndex ),
                          srcOperand,
                          COperand( 2.0f ),
                          COperand( -1.0f ) ) );
        srcOperand = CTempOperand4( SREG_MOD0 + dwIndex );
        break;

    case D3DSPSM_COMP:
        // add  m[i], vec4(1.0f), -src
        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_ADD,
                          CTempOperandDst( SREG_MOD0 + dwIndex ),
                          COperand( 1.0f ),
                          CNegate( srcOperand ) ) );
        srcOperand = CTempOperand4( SREG_MOD0 + dwIndex );
        break;

    case D3DSPSM_X2NEG:
    case D3DSPSM_X2:
        // mul  m[i], src[i], vec4(2.0f)
        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_MUL,
                          CTempOperandDst( SREG_MOD0 + dwIndex ),
                          srcOperand,
                          COperand( 2.0f ) ) );
        srcOperand = CTempOperand4( SREG_MOD0 + dwIndex );
        break;
    }

    //
    // Apply D3D10 modifier if available
    //

    switch ( dwModifier )
    {
    case D3DSPSM_NEG:
    case D3DSPSM_BIASNEG:
    case D3DSPSM_SIGNNEG:
    case D3DSPSM_X2NEG:
        srcOperand.SetModifier( D3D10_SB_OPERAND_MODIFIER_NEG );
        break;

    case D3DSPSM_ABSNEG:
        srcOperand.SetModifier( D3D10_SB_OPERAND_MODIFIER_ABSNEG );
        break;

    case D3DSPSM_ABS:
        srcOperand.SetModifier( D3D10_SB_OPERAND_MODIFIER_ABS );
        break;

    default:
        srcOperand.SetModifier( D3D10_SB_OPERAND_MODIFIER_NONE );
        break;
    }

    // Apply the swizzle mask
    if (dwRegType == D3DSPR_INPUT || dwRegType == D3DSPR_TEXTURE)
    {
        const DWORD dwRegNum = D3DSI_GETREGNUM_RESOLVING_CONSTANTS(dwToken) + dwOffset;
        DWORD dwRegIndex;
        if (dwRegType == D3DSPR_INPUT)
        {
            dwRegIndex = GetInputRegisterIndex(m_version, dwRegNum);
        }
        else
        {
            SHADER_CONV_ASSERT(dwRegType == D3DSPR_TEXTURE);
            dwRegIndex = GetTextureRegisterIndex(m_version, dwRegNum);
        }

        if (m_inputRegs.v[dwRegIndex].Reg() != INVALID_INDEX)
        {
            if (swizzle)
            {
                swizzle = MaskSwizzleWithWriteMask(swizzle, m_inputRegs.v[dwRegIndex].WriteMask() << D3D10_SB_OPERAND_4_COMPONENT_MASK_SHIFT);
            }
            else
            {
                swizzle = __swizzleFromWriteMask(m_inputRegs.v[dwRegIndex].WriteMask() << D3D10_SB_OPERAND_4_COMPONENT_MASK_SHIFT);
            }
        }

    }

    if ( swizzle )
    {
        SetSwizzle(srcOperand, swizzle);
    }

    return srcOperand;
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
COperandBase
CContext::EmitImmOperand( COperandBase& srcOperand, DWORD dwModifier, UINT swizzle )
{
    // Force a [-1,1] clamp after applying modifier (for PS 1.x constants only)
    // This overrides the the standard [-PixelShader1xMaxValue,PixelShader1xMaxValue] clamp.

    if ( __IS_PS( m_version ) &&
         m_version < D3DPS_VERSION(2,0) )
    {
        // max s2, src[i], vec4(-1.0f)
        // min m[i], s2, vec4(1.0f)
        for ( UINT i = 0; i < 4; ++i )
        {
            srcOperand.m_Valuef[i] = max( srcOperand.m_Valuef[i], -1.0f );
            srcOperand.m_Valuef[i] = min( srcOperand.m_Valuef[i], 1.0f );
        }
    }

    switch ( dwModifier )
    {
    case D3DSPSM_DZ:
        // div  m[i].xy, s2.xy, s2.zz
        srcOperand.m_Valuef[0] /= srcOperand.m_Valuef[2];
        srcOperand.m_Valuef[1] /= srcOperand.m_Valuef[2];
        break;

    case D3DSPSM_DW:
        // div  m[i].xy, s2.xy, s2.ww
        srcOperand.m_Valuef[0] /= srcOperand.m_Valuef[3];
        srcOperand.m_Valuef[1] /= srcOperand.m_Valuef[3];
        break;

    case D3DSPSM_BIASNEG:
    case D3DSPSM_BIAS:
        // add  m[i], src, vec4(-0.5f)
        for ( UINT i = 0; i < 4; ++i )
        {
srcOperand.m_Valuef[i] -= 0.5f;
        }
        break;

    case D3DSPSM_SIGNNEG:
    case D3DSPSM_SIGN:
        // mad m[i], src, vec4(2.0f), vec4(-1.0f)
        for (UINT i = 0; i < 4; ++i)
        {
            srcOperand.m_Valuef[i] = 2.0f * srcOperand.m_Valuef[i] - 1.0f;
        }
        break;

    case D3DSPSM_COMP:
        // add  m[i], vec4(1.0f), -src
        for (UINT i = 0; i < 4; ++i)
        {
            srcOperand.m_Valuef[i] = 1.0f - srcOperand.m_Valuef[i];
        }
        break;

    case D3DSPSM_X2NEG:
    case D3DSPSM_X2:
        // mul  m[i], src[i], vec4(2.0f)
        for (UINT i = 0; i < 4; ++i)
        {
            srcOperand.m_Valuef[i] = 2.0f * srcOperand.m_Valuef[i];
        }
        break;

    case D3DSPSM_ABSNEG:
    case D3DSPSM_ABS:
        // mov  m[i], abs(src[i])
        for (UINT i = 0; i < 4; ++i)
        {
            srcOperand.m_Valuef[i] = abs(srcOperand.m_Valuef[i]);
        }
        break;
    }

    //
    // Apply negation if needed
    //

    switch (dwModifier)
    {
    case D3DSPSM_NEG:
    case D3DSPSM_BIASNEG:
    case D3DSPSM_SIGNNEG:
    case D3DSPSM_X2NEG:
    case D3DSPSM_ABSNEG:
        for (UINT i = 0; i < 4; ++i)
        {
            srcOperand.m_Valuef[i] = -srcOperand.m_Valuef[i];
        }
        break;
    }

    if (swizzle)
    {
        // Apply the swizzle mask
        SetSwizzle(srcOperand, swizzle);
    }

    return srcOperand;
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
COperandBase
CContext::EmitInputOperand(DWORD dwRegIndex, UINT swizzle) const
{
    const InputRegister &inputRegister = m_inputRegs.v[dwRegIndex];
    switch (inputRegister.GetType())
    {
    case InputRegister::Temp:
        return CTempOperand4(m_inputRegs.v[dwRegIndex].Reg(), swizzle);
    case InputRegister::Input:
        return CInputOperand4(m_inputRegs.v[dwRegIndex].Reg(), swizzle);
    default:
        {
            // Use the default constant value
            SHADER_CONV_ASSERT(inputRegister.GetType() == InputRegister::Undeclared);
            dwRegIndex = GetDefaultInputRegister(dwRegIndex);
            return CTempOperand4(dwRegIndex, swizzle);
        }
    }
}

//////////////////////////////////////////////////////////////////////////////

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
CInstr::CInstr( DWORD dwInstr, const CContext* pContext ) :
    m_version( pContext->m_version ),
    m_inputRegs( pContext->m_inputRegs ),
    m_outputRegs( pContext->m_outputRegs )
{
    SHADER_CONV_ASSERT( pContext );

    if ( D3DSI_COISSUE & dwInstr )
    {
        m_modifiers._COISSUE = 1;
    }

    if ( D3DSHADER_INSTRUCTION_PREDICATED & dwInstr )
    {
        m_modifiers._PREDICATE = 1;
    }

    m_token         = dwInstr;
    m_opCode        = (D3DSHADER_INSTRUCTION_OPCODE_TYPE)( dwInstr & D3DSI_OPCODE_MASK );
    m_length        = __getInstrLength( dwInstr, m_version );
    m_srcTokenCount = 0;
    m_pContext      = pContext;
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
const DWORD*
CInstr::SetDstToken( const DWORD* pdwToken )
{
    SHADER_CONV_ASSERT( pdwToken );
    DWORD dwToken = *pdwToken++;
    DWORD dwAddress = 0;

    if ( D3DSI_GETADDRESSMODE( dwToken ) & D3DSHADER_ADDRMODE_RELATIVE )
    {
        if ( ( __IS_VS( m_version ) && m_version >= D3DVS_VERSION(2,0) ) ||
             ( __IS_PS( m_version ) && m_version >= D3DPS_VERSION(3,0) ) )
        {
            dwAddress = *pdwToken++;
        }
    }

    // Get the PS 1.x shift modifiers
    if ( __IS_PS( m_version ) &&
         m_version < D3DPS_VERSION(2,0) )
    {
        m_modifiers._SHIFT = ( dwToken & D3DSP_DSTSHIFT_MASK ) >> D3DSP_DSTSHIFT_SHIFT;
    }

    // Get the saturation modifier
    m_modifiers._SATURATE = ( dwToken & D3DSPDM_SATURATE ) ? 1 : 0;

    // Get the partial precision modifier
    if ( dwToken & D3DSPDM_PARTIALPRECISION )
    {
        m_modifiers._PPRECISION = 1;
    }

    // Get the multi sample centroid modifier
    if ( dwToken & D3DSPDM_MSAMPCENTROID )
    {
        m_modifiers._CENTROID = 1;
    }

    const DWORD dwRegNum = D3DSI_GETREGNUM_RESOLVING_CONSTANTS( dwToken );
    const DWORD dwRegType = D3DSI_GETREGTYPE_RESOLVING_CONSTANTS( dwToken );

    if ( __IS_PS( m_version ) &&
         m_version < D3DPS_VERSION(2,0) &&
         D3DSPR_TEXTURE == dwRegType )
    {
        switch ( m_opCode )
        {
        case D3DSIO_TEXM3x2PAD:
        case D3DSIO_TEXM3x3PAD:
            // These instructions use a system register to keep their destination value.
            break;

        default:
            // In ps_1_x, texture registers are used as temp registers,
            // we need to change their type to our custom register type
            dwToken &= ~( D3DSP_REGTYPE_MASK | D3DSP_REGTYPE_MASK2 );
            dwToken |= __D3DI_TYPE_TOKEN( __D3DSPR_TEXTURE1X );
            break;
        }

        switch ( m_opCode )
        {
        case D3DSIO_TEXCOORD:
        case D3DSIO_TEX:
        case D3DSIO_TEXM3x2PAD:
        case D3DSIO_TEXM3x2TEX:
        case D3DSIO_TEXM3x2DEPTH:
        case D3DSIO_TEXM3x3PAD:
        case D3DSIO_TEXM3x3:
        case D3DSIO_TEXM3x3TEX:
        case D3DSIO_TEXM3x3SPEC:
        case D3DSIO_TEXM3x3VSPEC:
        case D3DSIO_TEXDP3TEX:
        case D3DSIO_TEXDP3:
        case D3DSIO_TEXBEM:
        case D3DSIO_TEXBEML:

            // In ps_1_x, these instructions read from a texcoords register,
            // we need to manually define the register

            DWORD dwModifier = D3DSPSM_NONE;
            if ( m_pContext->m_rasterStates.ProjectedTCsMask & ( 1 << dwRegNum ) )
            {
                dwModifier = D3DSPSM_DW;
            }

            DWORD dwSrcToken = __D3DI_SRC_TOKEN( D3DSPR_TEXTURE,
                                                 dwRegNum,
                                                 D3DVS_NOSWIZZLE,
                                                 dwModifier );

            m_srcTokens[ m_srcTokenCount++ ] = Token( dwSrcToken, 0 );

            break;
        }
    }

    m_dstToken = Token( dwToken, dwAddress );

    return pdwToken;
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
const DWORD*
CInstr::AddSrcToken( const DWORD* pdwToken )
{
    SHADER_CONV_ASSERT( pdwToken );

    DWORD dwToken   = *pdwToken++;
    DWORD dwAddress = 0;

    if ( D3DSI_GETADDRESSMODE( dwToken ) & D3DSHADER_ADDRMODE_RELATIVE )
    {
        if ( ( __IS_VS( m_version ) && m_version >= D3DVS_VERSION(2,0) ) ||
             ( __IS_PS( m_version ) && m_version >= D3DPS_VERSION(3,0) ) )
        {
            dwAddress = *pdwToken++;
        }
    }

    const DWORD dwRegType = D3DSI_GETREGTYPE_RESOLVING_CONSTANTS( dwToken );

    if ( __IS_PS( m_version ) &&
         m_version <= D3DPS_VERSION(1,3) &&
         D3DSIO_TEXKILL != m_opCode &&
         D3DSPR_TEXTURE == dwRegType )
    {
        // In ps_1_x, the texture register are used as temp registers,
        // we need to change the type to our custom register type
        dwToken &= ~( D3DSP_REGTYPE_MASK | D3DSP_REGTYPE_MASK2 );
        dwToken |= __D3DI_TYPE_TOKEN( __D3DSPR_TEXTURE1X );
    }

    if ( m_srcTokenCount < MAX_SRC_REGISTERS )
    {
        m_srcTokens[ m_srcTokenCount++ ] = Token( dwToken, dwAddress );
    }

    return pdwToken;
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
COperandBase
CInstr::CreateDstOperand() const
{
    const DWORD dwToken   = m_dstToken.Value;
    const DWORD dwRegNum  = D3DSI_GETREGNUM_RESOLVING_CONSTANTS( dwToken );
    const DWORD dwRegType = D3DSI_GETREGTYPE_RESOLVING_CONSTANTS( dwToken );

    // Compute the write mask
    UINT writeMask = __getWriteMask( dwToken );

    //
    //  Get the register index
    //

    UINT regIndex = INVALID_INDEX;


    if ( m_modifiers._PREDICATE )
    {
        regIndex = SREG_PRED;
    }
    else
    {
        switch ( dwRegType )
        {
        default:
            SHADER_CONV_ASSERT(!"Invalid register type.");

        case D3DSPR_TEMP:
            // Temporary register
            SHADER_CONV_ASSERT( dwRegNum < MAX_TEMP_REGS );
            regIndex = m_inputRegs.r[dwRegNum];
            break;

        case D3DSPR_COLOROUT:
            // PS output color register
            SHADER_CONV_ASSERT( dwRegNum < MAX_PS_COLOROUT_REGS );
            regIndex = m_outputRegs.oC[dwRegNum];
            break;

        case D3DSPR_DEPTHOUT:
            // PS output depth register
            SHADER_CONV_ASSERT( dwRegNum < MAX_PS_DEPTHOUT_REGS );
            regIndex = m_outputRegs.oDepth;
            break;

        case D3DSPR_PREDICATE:
            // Predicate register
            regIndex = m_inputRegs.p0;
            break;

        case D3DSPR_RASTOUT:
            switch ( dwRegNum )
            {
            case D3DSRO_POSITION:
                // VS output position register
                regIndex = m_outputRegs.O[VSOREG_Position];
                break;

            case D3DSRO_FOG:
                // VS output fog register
                regIndex = m_outputRegs.O[VSOREG_FogPSize];
                writeMask = D3D10_SB_OPERAND_4_COMPONENT_MASK_X;
                break;

            case D3DSRO_POINT_SIZE:
                // VS output point size register
                regIndex = m_outputRegs.O[VSOREG_FogPSize];
                writeMask = D3D10_SB_OPERAND_4_COMPONENT_MASK_Y;
                break;

            default:
                SHADER_CONV_ASSERT(!"Invalid register number.");
                break;
            }
            break;

        case D3DSPR_ATTROUT:
            // VS output color register
            SHADER_CONV_ASSERT( dwRegNum < MAX_VS_COLOR_REGS );
            regIndex = m_outputRegs.O[VSOREG_Color0 + dwRegNum];
            break;

        case D3DSPR_TEXCRDOUT:
            SHADER_CONV_ASSERT( __IS_VS( m_version ) );
            if ( m_version >= D3DVS_VERSION(3,0) )
            {
                // VS output register
                SHADER_CONV_ASSERT( dwRegNum < MAX_VS_OUTPUT_REGS );
                regIndex = m_outputRegs.O[dwRegNum];
            }
            else
            {
                // VS output texture coordinates register
                SHADER_CONV_ASSERT( dwRegNum < MAX_VS_TEXCOORD_REGS );
                regIndex = m_outputRegs.O[VSOREG_TexCoord0 + dwRegNum];
            }
            break;

        case D3DSPR_ADDR:
            // VS input address register
            regIndex = m_inputRegs.a0;
            break;

        case __D3DSPR_TEXTURE1X:
            // PS 1.x texture register
            SHADER_CONV_ASSERT( dwRegNum < MAX_PS1X_TEXTURE_REGS );
            regIndex = m_inputRegs._t[dwRegNum];
            break;
        }
    }

    if ( regIndex != INVALID_INDEX )
    {
        return CTempOperandDst( regIndex, writeMask );
    }
    else
    {
        SHADER_CONV_ASSERT( D3DSPR_TEXCRDOUT == dwRegType );
        SHADER_CONV_ASSERT( m_version >= D3DVS_VERSION(3,0) );

        COperandBase dstOperand = CTempOperandDst2D( 0, dwRegNum, writeMask );

        if ( D3DSI_GETADDRESSMODE( dwToken ) & D3DSHADER_ADDRMODE_RELATIVE )
        {
            const DWORD dwAddrToken = this->GetDstAddress();
            this->ApplyAddressing( dstOperand, dwAddrToken, 1 );
        }

        return dstOperand;
    }
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
COperandBase
CInstr::CreateSrcOperand( DWORD dwToken, DWORD dwOffset ) const
{
    const DWORD dwRegNum  = D3DSI_GETREGNUM_RESOLVING_CONSTANTS( dwToken ) + dwOffset;
    const DWORD dwRegType = D3DSI_GETREGTYPE_RESOLVING_CONSTANTS( dwToken );

    // Determine if the operand has a relative address
    const bool hasRelativeAddress = ( D3DSI_GETADDRESSMODE( dwToken ) & D3DSHADER_ADDRMODE_RELATIVE ) ? true : false;

    // Determine if inline shader constants is supported (only available to Dx9 and above)
    const bool bInlineConstsEnabled = (m_pContext->m_runtimeVersion >= 9);

    ShaderConst shaderConst;

    switch ( dwRegType )
    {
    default:
        NO_DEFAULT;

    case D3DSPR_TEMP:
        // Temporary register
        SHADER_CONV_ASSERT( dwRegNum < MAX_TEMP_REGS );
        return CTempOperand4( m_inputRegs.r[dwRegNum] );

    case D3DSPR_INPUT:
        {
            DWORD dwRegIndex = GetInputRegisterIndex(m_version, dwRegNum);
            if (__IS_PS(m_version) || __IS_VS(m_version))
            {
                return m_pContext->EmitInputOperand(dwRegIndex);
            }
            else
            {
                return CInputOperand4(dwRegIndex);
            }
        }

    case D3DSPR_TEXTURE:
        // Input texture register
        SHADER_CONV_ASSERT(dwRegNum < MAX_PS_TEXCOORD_REGS);
        return m_pContext->EmitInputOperand(GetTextureRegisterIndex(m_version, dwRegNum));
    case D3DSPR_CONST:
        // Constant float register
        if ( !bInlineConstsEnabled ||
             hasRelativeAddress ||
             !m_pContext->m_pShaderDesc->FindInlineConstant( CB_FLOAT, dwRegNum * 4, &shaderConst ) )
        {
            return CCBOperand2D( CB_FLOAT, dwRegNum );
        }
        else
        {
            return COperand( shaderConst.fValue[0],
                             shaderConst.fValue[1],
                             shaderConst.fValue[2],
                             shaderConst.fValue[3] );
        }

    case D3DSPR_CONSTINT:
        // Constant integer register
        if ( !bInlineConstsEnabled ||
             hasRelativeAddress ||
             !m_pContext->m_pShaderDesc->FindInlineConstant( CB_INT, dwRegNum * 4, &shaderConst ) )
        {
            return CCBOperand2D( CB_INT, dwRegNum );
        }
        else
        {
            return COperand( shaderConst.iValue[0],
                             shaderConst.iValue[1],
                             shaderConst.iValue[2],
                             shaderConst.iValue[3] );
        }

    case D3DSPR_CONSTBOOL:
        // Constant boolean register
        if ( !bInlineConstsEnabled ||
             hasRelativeAddress ||
             !m_pContext->m_pShaderDesc->FindInlineConstant( CB_BOOL, dwRegNum, &shaderConst ) )
        {
            // Bool constant registers have 1 dimension,
            // need to recompute the index and appy the correct swizzle
            const UINT regIndex = dwRegNum >> 2;
            const UINT componentIndex = dwRegNum & 3;

            return CSwizzle( CCBOperand2D( CB_BOOL, regIndex ), __SWIZZLE1( componentIndex )  );
        }
        else
        {
            return COperand( shaderConst.bValue );
        }

    case D3DSPR_SAMPLER:
        // Sampler input register
        return COperand( D3D10_SB_OPERAND_TYPE_SAMPLER, dwRegNum );

    case D3DSPR_LABEL:
        // label register
        return COperand( D3D10_SB_OPERAND_TYPE_LABEL, dwRegNum );

    case D3DSPR_PREDICATE:
        // Predicate register
        return CTempOperand4( m_inputRegs.p0 );

    case D3DSPR_LOOP:
        // Loop counter register
        return CTempOperand4( m_inputRegs.aL );

    case __D3DSPR_TEXTURE1X:
        // PS 1.x texture register
        SHADER_CONV_ASSERT( dwRegNum < MAX_PS1X_TEXTURE_REGS );
        return CTempOperand4( m_inputRegs._t[dwRegNum] );

    case D3DSPR_MISCTYPE:
        {
            UINT regIndex;
            switch ( dwRegNum )
            {
            default:
                NO_DEFAULT;

            case D3DSMO_POSITION:
                regIndex = m_inputRegs.v[PSIREG_VPos].Reg();
                break;

            case D3DSMO_FACE:
                regIndex = m_inputRegs.v[PSIREG_VFace].Reg();
                break;
            }
            return CTempOperand4( regIndex );
        }
    }
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CInstr::ApplyAddressing( COperandBase& operand, DWORD dwAddrToken, UINT relIndex ) const
{
    if ( dwAddrToken )
    {
        UINT regIndex;

        const DWORD dwAddrRegType = D3DSI_GETREGTYPE_RESOLVING_CONSTANTS( dwAddrToken );
        switch ( dwAddrRegType )
        {
        default:
            NO_DEFAULT;

        case D3DSPR_ADDR:
            regIndex = m_inputRegs.a0;
            break;

        case D3DSPR_LOOP:
            regIndex = m_inputRegs.aL;
            break;
        }

        D3D10_SB_4_COMPONENT_NAME componentName;

        const DWORD dwSwizzle = dwAddrToken & D3DVS_SWIZZLE_MASK;
        switch ( ( dwSwizzle >> D3DVS_SWIZZLE_SHIFT ) & 0x3 )
        {
        default:
            NO_DEFAULT;

        case 0:
            componentName = D3D10_SB_4_COMPONENT_X;
            break;

        case 1:
            componentName = D3D10_SB_4_COMPONENT_Y;
            break;

        case 2:
            componentName = D3D10_SB_4_COMPONENT_Z;
            break;

        case 3:
            componentName = D3D10_SB_4_COMPONENT_W;
            break;
        }

        SHADER_CONV_ASSERT( regIndex != INVALID_INDEX );
        SetRelAddress( operand,
                       relIndex,
                       D3D10_SB_OPERAND_TYPE_TEMP,
                       regIndex,
                       componentName );
    }
    else
    {
        SHADER_CONV_ASSERT( m_inputRegs.a0 != INVALID_INDEX );
        SetRelAddress( operand,
                       relIndex,
                       D3D10_SB_OPERAND_TYPE_TEMP,
                       m_inputRegs.a0,
                       D3D10_SB_4_COMPONENT_X );
    }
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
IContext::WriteClipplanes( UINT activeClipPlanesMask, const COperandBase& position )
{
    // dp4 oC.[i], pos, cb3[clipplane[0..i]]
    for ( UINT i = 0, j = 0; i < MAX_CLIPLANES; ++i )
    {
        const UINT clipRegIndex = ( j < 4 ) ? VSOREG_ClipDist0 : VSOREG_ClipDist1;
        if ( activeClipPlanesMask & ( 1 << i ) )
        {
            m_pShaderAsm->EmitInstruction(
                CInstruction(
                    D3D10_SB_OPCODE_DP4,
                    COperandDst( D3D10_SB_OPERAND_TYPE_OUTPUT,
                                 clipRegIndex,
                                 D3D10_SB_OPERAND_4_COMPONENT_MASK_X << ( j % 4 ) ),
                    position,
                    CCBOperand2D( CB_VS_EXT, VSCBExtension::CLIPPLANE0 + i ) ) );
            ++j;
        }
    }
}

bool OperandCanBeInfinityOrNan(const COperandBase &op)
{
    bool operandCanBeInfinity = true;
    if (op.OperandType() == D3D10_SB_OPERAND_TYPE_CONSTANT_BUFFER)
    {
        // EXT constants created directly by 9on12 are verified to be floats that aren't nan or inf
        UINT regIndex0 = op.OperandIndex(0)->m_RegIndex;
        const bool bIsVSExt = regIndex0 == CB_VS_EXT;
        const bool bIsPSExt = regIndex0 == CB_PS_EXT || regIndex0 == CB_PS_EXT2 || regIndex0 == CB_PS_EXT3;
        operandCanBeInfinity = !bIsVSExt && !bIsPSExt;
    }

    return operandCanBeInfinity;
}

void CShaderAsmWrapper::PatchMultiplicandArgs(
    _In_ COperandBase &src0,
    _In_ COperandBase &src1)
{
    if (IsMultiplicationPatchingEnabled() &&

        // Anything times itself can never result in a 0 * nan or 0 * inf situation
        src0 != src1 &&

        // If either of the sources are a non-zero, float literal, then there's no 
        // need for a check since the literal can't be inf/nan.
        !(src0.OperandType() == D3D10_SB_OPERAND_TYPE_IMMEDIATE32 && src0.m_Valuef[0] != 0.0f) &&
        !(src1.OperandType() == D3D10_SB_OPERAND_TYPE_IMMEDIATE32 && src1.m_Valuef[0] != 0.0f))
    {
        // Assuming neither src's are safe as multiplicands, the emitted asm is:
        //
        // mov  temp0, _abs(src0)
        // movc temp0, temp0, src1, 0.0f
        // mov  temp1, _abs(src1)
        // movc temp1, temp1, src0, 0.0f
        //
        // This ensures that temp0 * temp1 == src0 * src1 except for cases when
        // either may have inf/nan. In these cases, the movc ensures that if the 
        // other multiplicand has 0, then the nan/inf will be overwritten with 0.0f
        if (OperandCanBeInfinityOrNan(src1))
        {
            EmitExtraInstructionInternal(
                CInstruction(
                    D3D10_SB_OPCODE_MOV,
                    CTempOperandDst(SREG_MUL0),
                    CAbs(src0)));

            EmitExtraInstructionInternal(
                CInstruction(
                    D3D10_SB_OPCODE_MOVC,
                    CTempOperandDst(SREG_MUL0),
                    CTempOperand4(SREG_MUL0),
                    src1,
                    COperand(0.0f)));

            src1 = CTempOperand4(SREG_MUL0);
        }

        if (OperandCanBeInfinityOrNan(src0))
        {
            EmitExtraInstructionInternal(
                CInstruction(
                    D3D10_SB_OPCODE_MOV,
                    CTempOperandDst(SREG_MUL1),
                    CAbs(src1)));

            EmitExtraInstructionInternal(
                CInstruction(
                    D3D10_SB_OPCODE_MOVC,
                    CTempOperandDst(SREG_MUL1),
                    CTempOperand4(SREG_MUL1),
                    src0,
                    COperand(0.0f)));
            src0 = CTempOperand4(SREG_MUL1);
        }
    }
}
} // namespace ShaderConv
```

`ShaderConverter/ShaderConv/context.hpp`:

```hpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/*==========================================================================;
*
*  Copyright (C) Microsoft Corporation.  All Rights Reserved.
*
*  Header Definitions for The translator context
*
****************************************************************************/

#pragma once

#include "ShaderConv.hpp"

namespace ShaderConv
{

class CContext;

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
enum eSystemRegister
{
    SREG_TMP0,
    SREG_TMP1,
    SREG_TMP2,

    SREG_MUL0,
    SREG_MUL1,

    SREG_MOD0,
    SREG_MOD1,
    SREG_MOD2,
    SREG_MOD3,

    SREG_PRED,

    SREG_SIZE,
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
struct Modifiers
{
    union
    {
        UINT Value;
        struct
        {
            UINT _SHIFT       : 4;
            UINT _SATURATE    : 1;
            UINT _CENTROID    : 1;
            UINT _PPRECISION  : 1;
            UINT _PREDICATE   : 1;
            UINT _COISSUE     : 1;
        };
    };

    Modifiers() : Value( 0 ) {}
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
class CInstr
{
public:

    enum
    {
        SRC_REG0,
        SRC_REG1,
        SRC_REG2,
        SRC_REG3,
        SRC_PREDICATE,
        MAX_SRC_REGISTERS,
    };

    struct Token
    {
        UINT Value;
        UINT Address;

        Token() : Value( 0 ), Address( 0 ) {}

        Token( UINT value, UINT address ) : Value( value ), Address( address ) {}
    };

    CInstr( DWORD dwInstr, const CContext* pContext );

    const DWORD* SetDstToken( const DWORD* pdwToken );

    const DWORD* AddSrcToken( const DWORD* pdwToken );

    const DWORD* SetPredicate( const DWORD* pdwToken )
    {
        SHADER_CONV_ASSERT( pdwToken );
        m_srcTokens[SRC_PREDICATE].Value = *pdwToken++;
        return pdwToken;
    }

    COperandBase CreateDstOperand() const;

    COperandBase CreateSrcOperand( DWORD dwToken, DWORD dwOffset = 0 ) const;

    UINT GetToken() const
    {
        return m_token;
    }

    D3DSHADER_INSTRUCTION_OPCODE_TYPE GetOpCode() const
    {
        return m_opCode;
    }

    UINT GetLength() const
    {
        return m_length;
    }

    bool HasPredicate() const
    {
        return m_modifiers._PREDICATE ? true : false;
    }

    void ClearPredicateFlag()
    {
        m_modifiers._PREDICATE = 0;
    }

    bool HasCoissue() const
    {
        return m_modifiers._COISSUE ? true : false;
    }

    const Modifiers& GetModifiers() const
    {
        return m_modifiers;
    }

    UINT GetDstToken() const
    {
        return m_dstToken.Value;
    }

    UINT GetDstAddress() const
    {
        return m_dstToken.Address;
    }

    UINT GetSrcToken( UINT index ) const
    {
        SHADER_CONV_ASSERT( index < _countof( m_srcTokens ) );
        return m_srcTokens[index].Value;
    }

    UINT GetSrcAddress( UINT index ) const
    {
        SHADER_CONV_ASSERT( index < _countof( m_srcTokens ) );
        return m_srcTokens[index].Address;
    }

    UINT GetSrcTokenCount() const
    {
        return m_srcTokenCount;
    }

    UINT GetPredicate() const
    {
        return m_srcTokens[SRC_PREDICATE].Value;
    }

    void ApplyAddressing( COperandBase& operand,
                          DWORD dwAddrToken,
                          UINT relIndex ) const;

private:

    D3DSHADER_INSTRUCTION_OPCODE_TYPE m_opCode;

    UINT        m_token;
    UINT        m_length;
    Token       m_dstToken;
    Modifiers   m_modifiers;

    Token       m_srcTokens[MAX_SRC_REGISTERS];
    UINT        m_srcTokenCount;

    UINT                m_version;
    const InputRegs&    m_inputRegs;
    const OutputRegs&   m_outputRegs;
    const CContext*     m_pContext;
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
class IContext
{
public:

    IContext( UINT runtimeVersion, CShaderAsmWrapper* pShaderAsm ) :
        m_runtimeVersion( runtimeVersion ),
        m_pShaderAsm( pShaderAsm ) {}

    virtual ~IContext() {}

    virtual HRESULT WriteDeclarations() = 0;

    virtual HRESULT TranslateInstructions() = 0;

    virtual void WriteOutputs() = 0;

protected:
    void WriteClipplanes( UINT activeClipPlanesMask,
                          const COperandBase& position );

    UINT        m_runtimeVersion;
    CShaderAsmWrapper* m_pShaderAsm;
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
class CContext : public IContext
{
public:

    CContext( UINT runtimeVersion,
              const CShaderDesc* pShaderDesc,
              const RasterStates& rasterStates,
              CShaderAsmWrapper* pShaderAsm ) :
        IContext( runtimeVersion, pShaderAsm ),
        m_rasterStates( rasterStates ),
        m_version( pShaderDesc->GetVersion() ),
        m_inputRegs( pShaderDesc->GetInputRegs() ),
        m_outputRegs( pShaderDesc->GetOutputRegs() ),
        m_toggleTEXM3x3PAD( 0 ),
        m_controlFlowDepth( 0 ),
        m_nextLoopRegister( 0 ),
        m_bOutputWritten( false ),
        m_pShaderDesc( pShaderDesc ),
        m_bLastInstrBreak( false )
    {
        m_loopNestingDepth = 0xff;
    }

    virtual ~CContext()
    {
        //--
    }

    virtual HRESULT WriteDeclarations() = 0;

    HRESULT TranslateInstructions();

    virtual void WriteOutputs() = 0;

protected:

    void Translate_MOV( const CInstr& instr );
    void Translate_ADD( const CInstr& instr );
    void Translate_SUB( const CInstr& instr );
    void Translate_MAD( const CInstr& instr );
    void Translate_MUL( const CInstr& instr );
    void Translate_RSQ( const CInstr& instr );
    void Translate_DP3( const CInstr& instr );
    void Translate_DP4( const CInstr& instr );
    void Translate_MIN( const CInstr& instr );
    void Translate_MAX( const CInstr& instr );
    void Translate_SLT( const CInstr& instr );
    void Translate_EXP( const CInstr& instr );
    void Translate_EXPP( const CInstr& instr );
    void Translate_FRC( const CInstr& instr );
    void Translate_MOVA( const CInstr& instr );
    void Translate_LIT( const CInstr& instr );
    void Translate_DST( const CInstr& instr );
    void Translate_LRP( const CInstr& instr );
    void Translate_M4x4( const CInstr& instr );
    void Translate_M4x3( const CInstr& instr );
    void Translate_M3x4( const CInstr& instr );
    void Translate_M3x3( const CInstr& instr );
    void Translate_M3x2( const CInstr& instr );
    void Translate_POW( const CInstr& instr );
    void Translate_CRS( const CInstr& instr );
    void Translate_SGN( const CInstr& instr );
    void Translate_ABS( const CInstr& instr );
    void Translate_NRM( const CInstr& instr );
    void Translate_SINCOS( const CInstr& instr );
    void Translate_CMP( const CInstr& instr );
    void Translate_DP2ADD( const CInstr& instr );
    void Translate_RCP( const CInstr& instr );
    void Translate_CND( const CInstr& instr );
    void Translate_SGE( const CInstr& instr );
    void Translate_LOG( const CInstr& instr );
    void Translate_LOGP( const CInstr& instr );
    void Translate_DSX( const CInstr& instr );
    void Translate_DSY( const CInstr& instr );
    void Translate_PHASE( const CInstr& instr );

    void Translate_LABEL( const CInstr& instr );
    void Translate_LOOP( const CInstr& instr );
    void Translate_ENDLOOP( const CInstr& instr );
    void Translate_ENDREP( const CInstr& instr );
    void Translate_ENDIF( const CInstr& instr );
    void Translate_REP( const CInstr& instr );
    void Translate_CALL( const CInstr& instr );
    void Translate_CALLNZ( const CInstr& instr );
    void Translate_RET( const CInstr& instr );
    void Translate_IF( const CInstr& instr );
    void Translate_IFC( const CInstr& instr );
    void Translate_ELSE( const CInstr& instr );
    const DWORD* Translate_BREAK( const CInstr& instr, const DWORD* pdwCurToken );
    void Translate_BREAKC( const CInstr& instr );
    void Translate_BREAKP( const CInstr& instr );

    void Translate_TEXKILL( const CInstr& instr );
    void Translate_TEX( const CInstr& instr );
    void Translate_TEXLDD( const CInstr& instr );
    void Translate_TEXLDL( const CInstr& instr );
    void Translate_TEXREG2AR( const CInstr& instr );
    void Translate_TEXREG2GB( const CInstr& instr );
    void Translate_TEXREG2RGB( const CInstr& instr );
    void Translate_TEXM3x2PAD( const CInstr& instr );
    void Translate_TEXM3x2TEX( const CInstr& instr );
    void Translate_TEXM3x2DEPTH( const CInstr& instr );
    void Translate_TEXM3x3PAD( const CInstr& instr );
    void Translate_TEXM3x3( const CInstr& instr );
    void Translate_TEXM3x3TEX( const CInstr& instr );
    void Translate_TEXM3x3SPEC( const CInstr& instr );
    void Translate_TEXM3x3VSPEC( const CInstr& instr );
    void Translate_TEXCOORD( const CInstr& instr );
    void Translate_BEM( const CInstr& instr );
    void Translate_TEXDEPTH( const CInstr& instr );
    void Translate_TEXDP3( const CInstr& instr );
    void Translate_TEXDP3TEX( const CInstr& instr );
    void Translate_TEXBEM( const CInstr& instr );
    void Translate_TEXBEML( const CInstr& instr );
    void Translate_SETP( const CInstr& instr );

    void Compare( D3DSHADER_COMPARISON comp,
                  const COperandBase& dstOperand,
                  const COperandBase& srcOperand0,
                  const COperandBase& srcOperand1 ) const;

    void EmitShiftModifier( UINT shiftMask,
                            bool bSaturate,
                            const COperandBase& dstOperand,
                            const COperandBase& srcOperand );

    void EmitSamplerSwizzle( const COperandBase& dstOperand,
                             const COperandBase& srcOperand,
                             SAMPLER_SWIZZLE swizzle );

    void EmitColorKeyModifier( UINT stage,
                               const COperandBase& dstOperand,
                               const COperandBase& srcOperand );

    void EmitDstInstruction( const Modifiers& modifiers,
                             D3D10_SB_OPCODE_TYPE opCode,
                             UINT stage,
                             UINT NumSrcOperands,
                             const COperandBase* pDst,
                             ...);

    void EmitDstInstruction( const Modifiers& modifiers,
                             D3D10_SB_OPCODE_TYPE opCode,
                             const COperandBase& dstOperand,
                             const COperandBase& srcOperand )
    {
        this->EmitDstInstruction(modifiers, opCode, 0, 1, &dstOperand, &srcOperand);
    }

    void EmitDstInstruction( const Modifiers& modifiers,
                             D3D10_SB_OPCODE_TYPE opCode,
                             const COperandBase& dstOperand,
                             const COperandBase& srcOperand0,
                             const COperandBase& srcOperand1 )
    {
        this->EmitDstInstruction(modifiers, opCode, 0, 2, &dstOperand, &srcOperand0, &srcOperand1);
    }

    void EmitDstInstruction( const Modifiers& modifiers,
                             D3D10_SB_OPCODE_TYPE opCode,
                             const COperandBase& dstOperand,
                             const COperandBase& srcOperand0,
                             const COperandBase& srcOperand1,
                             const COperandBase& srcOperand2 )
    {
        this->EmitDstInstruction(modifiers, opCode, 0, 3, &dstOperand, &srcOperand0, &srcOperand1, &srcOperand2);
    }

    void EmitDstInstruction( const Modifiers& modifiers,
                             D3D10_SB_OPCODE_TYPE opCode,
                             const COperandBase& dstOperand,
                             const COperandBase& srcOperand0,
                             const COperandBase& srcOperand1,
                             const COperandBase& srcOperand2,
                             const COperandBase& srcOperand3 )
    {
        this->EmitDstInstruction(modifiers, opCode, 0, 4, &dstOperand, &srcOperand0, &srcOperand1, &srcOperand2, &srcOperand3);
    }

    void EmitDstInstruction( const Modifiers& modifiers,
                             D3D10_SB_OPCODE_TYPE opCode,
                             const COperandBase& dstOperand,
                             const COperandBase& srcOperand0,
                             const COperandBase& srcOperand1,
                             const COperandBase& srcOperand2,
                             const COperandBase& srcOperand3,
                             const COperandBase& srcOperand4 )
    {
        this->EmitDstInstruction(modifiers, opCode, 0, 5, &dstOperand, &srcOperand0, &srcOperand1, &srcOperand2, &srcOperand3, &srcOperand4);
    }

    void EmitDstInstruction( const Modifiers& modifiers,
                             D3D10_SB_OPCODE_TYPE opCode,
                             UINT stage,
                             const COperandBase& dstOperand,
                             const COperandBase& srcOperand0,
                             const COperandBase& srcOperand1,
                             const COperandBase& srcOperand2 )
    {
        this->EmitDstInstruction(modifiers, opCode, stage, 3, &dstOperand, &srcOperand0, &srcOperand1, &srcOperand2);
    }

    void EmitDstInstruction( const Modifiers& modifiers,
                             D3D10_SB_OPCODE_TYPE opCode,
                             UINT stage,
                             const COperandBase& dstOperand,
                             const COperandBase& srcOperand0,
                             const COperandBase& srcOperand1,
                             const COperandBase& srcOperand2,
                             const COperandBase& srcOperand3 )
    {
        this->EmitDstInstruction(modifiers, opCode, stage, 4, &dstOperand, &srcOperand0, &srcOperand1, &srcOperand2, &srcOperand3);
    }

    void EmitDstInstruction( const Modifiers& modifiers,
                             D3D10_SB_OPCODE_TYPE opCode,
                             UINT stage,
                             const COperandBase& dstOperand,
                             const COperandBase& srcOperand0,
                             const COperandBase& srcOperand1,
                             const COperandBase& srcOperand2,
                             const COperandBase& srcOperand3,
                             const COperandBase& srcOperand4 )
    {
        this->EmitDstInstruction(modifiers, opCode, stage, 5, &dstOperand, &srcOperand0, &srcOperand1, &srcOperand2, &srcOperand3, &srcOperand4);
    }

    void EmitSampleCmp(const CInstr& instr, const COperandBase dest, const DWORD dwStage, const COperandBase src0);

    COperandBase EmitSrcOperand( const CInstr& instr,
                                 DWORD dwIndex,
                                 DWORD dwOffset = 0,
                                 DWORD dwSwizzleCount = 4 );

    COperandBase EmitImmOperand( COperandBase& srcOperand, DWORD dwModifier, UINT swizzle );

    COperandBase EmitPredOperand( const CInstr& instr )
    {
        return this->EmitSrcOperand( instr, CInstr::SRC_PREDICATE );
    }

    COperandBase EmitInputOperand(DWORD dwRegIndex, UINT sizzle = 0) const;

    void AllocateLoopRegister()
    {
        m_loopRegs[m_loopNestingDepth] = m_nextLoopRegister++;
    }

    UINT GetLoopRegister() const
    {
        return m_loopRegs[m_loopNestingDepth];
    }

    bool IsImplicitFogCalculationNeeded() { return ShaderConv::IsImplicitFogCalculationNeeded(m_rasterStates, m_version); }

    UINT GetDefaultInputRegister(UINT regIndex) const
    {
        SHADER_CONV_ASSERT(regIndex < _countof(m_defaultInputRegs));
        return m_defaultInputRegs[regIndex];
    }

    template <typename InputDecls>
    void AllocateTempRegistersForUndeclaredInputs(const InputDecls &inputDecls, BYTE &uiTotalTempRegs)
    {
        for (UINT i = 0, n = inputDecls.GetSize(); i < n; ++i)
        {
            const UINT regIndex = inputDecls[i].RegIndex;
            if (m_inputRegs.v[regIndex].GetType() == InputRegister::Undeclared)
            {
                m_defaultInputRegs[regIndex] = uiTotalTempRegs++;
            }
        }
    }

    template <typename InputDecls>
    void InitializeTempRegistersForUndeclaredInputs(const InputDecls &inputDecls, UINT numTempRegisters)
    {
        std::vector<bool> registerIsInitialized(numTempRegisters, false);
        for (UINT i = 0, n = inputDecls.GetSize(); i < n; ++i)
        {
            UINT regIndex = inputDecls[i].RegIndex;
            switch(m_inputRegs.v[regIndex].GetType())
            {
                case InputRegister::Undeclared:
                {
                    COperandBase defaultValue;

                    const UINT usage = inputDecls[i].Usage;
                    switch (usage)
                    {
                    case D3DDECLUSAGE_COLOR:
                        defaultValue = COperand(0.0f, 0.0f, 0.0f, 1.0f);
                        break;

                    case D3DDECLUSAGE_PSIZE:
                        defaultValue = COperand(1.0f);
                        break;

                    case D3DDECLUSAGE_TEXCOORD:
                        defaultValue = COperand(0.0f, 0.0f, 0.0f, 1.0f);
                        break;

                    default:
                        defaultValue = COperand(0.0f);
                        break;
                    }

                    // Assign default value to the input register
                    regIndex = inputDecls[i].RegIndex;
                    m_pShaderAsm->EmitInstruction(
                        CInstruction(D3D10_SB_OPCODE_MOV,
                            CTempOperandDst(m_defaultInputRegs[regIndex]),
                            defaultValue));
                    registerIsInitialized[m_defaultInputRegs[regIndex]] = true;
                    break;
                }
                case  InputRegister::Temp:
                    registerIsInitialized[m_inputRegs.v[regIndex].Reg()] = true;
                    break;
            }
            
        }
        
        
        for (UINT i = 0; i < numTempRegisters; i++)
        {
            if (!registerIsInitialized[i])
            {
                m_pShaderAsm->EmitInstruction(
                    CInstruction(D3D10_SB_OPCODE_MOV,
                        CTempOperandDst(i),
                        COperand(0.0f)));
                registerIsInitialized[i] = true;
            }
        }
    }

    bool TextureUsesHardwareShadowMapping(DWORD stage) const;
    
protected:
    UINT m_version;

    const RasterStates& m_rasterStates;

    const InputRegs&    m_inputRegs;
    const OutputRegs&   m_outputRegs;
    const CShaderDesc*  m_pShaderDesc;

    BYTE m_defaultInputRegs[MAX_INPUT_REGS];

    UINT m_loopRegs[D3DVS20_MAX_STATICFLOWCONTROLDEPTH];
    BYTE m_toggleTEXM3x3PAD;
    BYTE m_controlFlowDepth;
    bool m_bOutputWritten;
    BYTE m_loopNestingDepth;
    UINT m_nextLoopRegister;
    bool m_bLastInstrBreak;

    friend class CInstr;
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
class CVSContext : public CContext
{
public:

    CVSContext( UINT runtimeVersion,
                const CVertexShaderDesc* pShaderDesc,
                const RasterStates& rasterStates,
                CShaderAsmWrapper* pShaderAsm );

    HRESULT WriteDeclarations();

    void WriteOutputs();

protected:

    const VSInputDecls&     m_inputDecls;
    const VSOutputDecls&    m_outputDecls;
    const VSUsageFlags      m_usageFlags;
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
class CTLVSContext : public IContext
{
public:

    CTLVSContext(
        UINT runtimeVersion, 
        const CTLVertexShaderDesc* pShaderDesc, 
        CShaderAsmWrapper* pShaderAsm
        );

    HRESULT WriteDeclarations();

    HRESULT TranslateInstructions();

    void WriteOutputs();

protected:

    const CTLVertexShaderDesc* m_pShaderDesc;
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
class CPSContext : public CContext
{
public:

    CPSContext( UINT runtimeVersion,
                const CPixelShaderDesc* pShaderDesc,
                const RasterStates& rasterStates,
                const ShaderConv::VSOutputDecls& inputDecls,
                CShaderAsmWrapper* pShaderAsm );

    HRESULT WriteDeclarations();

    void WriteOutputs();

    const VSOutputDecls& GetInputDecls() const
    {
        return m_inputDecls;
    }

protected:

    void ComputeAlphaTest();

    void ComputeFogBlend();

    void ComputePixelFog();


    const VSOutputDecls& m_inputDecls;
    const PSUsageFlags   m_usageFlags;
    const VSOutputDecl*  m_pInputFog;
    const VSOutputDecl*  m_pInputSpecular;
    const BYTE           m_positionRegister;
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
class CGSContext : public IContext
{
public:

    CGSContext( UINT runtimeVersion,
                const CGeometryShaderDesc* pShaderDesc,
                CShaderAsmWrapper* pShaderAsm );

    HRESULT WriteDeclarations();

    HRESULT TranslateInstructions();

    void WriteOutputs();

protected:

    void EmitTexWrap( UINT primitive, UINT usageIndex, const InputRegister &regIndex );

    COperandBase CreateInputSrcOperand( UINT primitive, const InputRegister &inputReg, UINT swizzle = 0 );
    COperandBase CreateInputDstOperand( BYTE tempRegIndex, UINT primitive, UINT regIndex, UINT writeMask = D3D10_SB_OPERAND_4_COMPONENT_MASK_ALL );

    BYTE                    m_tempRegs[3][MAX_VS_OUTPUT_REGS];
    BYTE                    m_uiNumTempRegs;
    VSOutputDecl            m_texcoordDecls[MAX_SAMPLER_REGS];
    VSOutputDecl            m_positionDecl;
    VSOutputDecl            m_psizeDecl;
    UINT                    m_uiPrimitiveSize;
    const CGeometryShaderDesc* m_pShaderDesc;
};

} // namespace ShaderConv
```

`ShaderConverter/ShaderConv/disasm.hpp`:

```hpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/*==========================================================================;
*
*  Copyright (C) Microsoft Corporation.  All Rights Reserved.
*
*  Header Definitions for The Shader Disassembler
*
****************************************************************************/

namespace ShaderConv
{

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
HRESULT Disasm20( const DWORD* pdwShaderAsm, DWORD dwFlags );

} // namespace ShaderConv
```

`ShaderConverter/ShaderConv/disasm20.cpp`:

```cpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/*==========================================================================;
*
*  Copyright (C) Microsoft Corporation.  All Rights Reserved.
*
*  Implementation for The Shader Disassembler for HLSL 2.0
*
****************************************************************************/

#include "pch.h"
#include "disasm.hpp"

#if DBG && WARP_INTERNAL

// SHADER_CONV_ASSERT with simple string
#undef _SHADER_CONV_ASSERT
#define _SHADER_CONV_ASSERT( value, string )    \
if ( !(value) ) {                   \
    WarpError( string );            \
}

#define __IS_VS( version ) \
    ( ( version & 0xFFFF0000 ) == 0xFFFE0000 )

#define __IS_PS( version ) \
    ( ( version & 0xFFFF0000 ) == 0xFFFF0000 )

#define SWIZZLE_BUF_SIZE    10
#define DISASM_STR_LENGTH   256
#define _ADDSTR( _Str )             {StringCchPrintfA( pStr, DISASM_STR_LENGTH, "%s" _Str , pStr );}
#define _ADDSTRP( _Str, _Param )    {StringCchPrintfA( pStr, DISASM_STR_LENGTH, "%s" _Str , pStr, _Param );}

// sizes for internal register arrays
const DWORD PSTR_MAX_COISSUED_INSTRUCTIONS  = 2;
const DWORD PSTR_NUM_COMPONENTS_IN_REGISTER = 4;
const DWORD PSTR_PIXEL_QUAD                 = 4;
const DWORD PSTR_MAX_REGISTER_STACK_DEPTH   = 8; // 4 * (aL+internal loop counter); aka
const DWORD PSTR_MAX_NUMQUEUEDWRITEREG      = PSTR_MAX_COISSUED_INSTRUCTIONS - 1;
const DWORD PSTR_MAX_NUMSRCPARAMS           = 4;
const DWORD PSTR_MAX_NUMPOSTMODSRCREG       = PSTR_MAX_NUMSRCPARAMS;
const DWORD PSTR_MAX_NUMSCRATCHREG          = 5;

// refdev-specific pixel shader 'instructions' to match legacy pixel processing
#define D3DSIO_TEXBEM_LEGACY    ((D3DSHADER_INSTRUCTION_OPCODE_TYPE)0xC001)
#define D3DSIO_TEXBEML_LEGACY   ((D3DSHADER_INSTRUCTION_OPCODE_TYPE)0xC002)

namespace ShaderConv
{

    //-----------------------------------------------------------------------------
// GetSwizzleName - Returns a string name for a swizzle in buffer provided.
// ----------------------------------------------------------------------------
HRESULT
GetSwizzleName( __out_ecount(StrCharsRet) char* pStrRet, int StrCharsRet, DWORD Swizzle )
{
    char pStr[DISASM_STR_LENGTH] = "";
    switch (Swizzle)
    {
    case D3DSP_NOSWIZZLE:       break;
    case D3DSP_REPLICATEALPHA:  _ADDSTR(".a"); break;
    case D3DSP_REPLICATERED:    _ADDSTR(".r"); break;
    case D3DSP_REPLICATEGREEN:  _ADDSTR(".g"); break;
    case D3DSP_REPLICATEBLUE:   _ADDSTR(".b"); break;
    default:
        _ADDSTR(".");
        for(UINT j = 0; j < 4; j++)
        {
            switch((Swizzle >> (D3DVS_SWIZZLE_SHIFT + 2*j)) & 0x3)
            {
            case 0:
                _ADDSTR("r");
                break;
            case 1:
                _ADDSTR("g");
                break;
            case 2:
                _ADDSTR("b");
                break;
            case 3:
                _ADDSTR("a");
                break;
            }
        }
        break;
    }

    return StringCchPrintfA( pStrRet, StrCharsRet, "%s", pStr );
}

//-----------------------------------------------------------------------------
//
// DisAsmInstr - Generates instruction disassembly string for a single
// D3D (pre-translation) pixel shader instruction.
// String interface is similar to _snprintf.
//
//-----------------------------------------------------------------------------
HRESULT
DisAsmInstr(
    __out_ecount(cchNumChars) LPSTR lpszRet,
    int                             cchNumChars,
    const DWORD**                   ppdwShader,
    DWORD                           dwVersion )
{
    SHADER_CONV_ASSERT( lpszRet && ppdwShader );

    UINT    i;
    const DWORD* pdwToken = *ppdwShader;
    char SwizzleBuf[SWIZZLE_BUF_SIZE];

    // stage in local string, then copy
    char pStr[DISASM_STR_LENGTH] = "";
    char pPrefix[DISASM_STR_LENGTH] = "";

    DWORD dwInstr = *pdwToken++;

    if( D3DSI_COISSUE & dwInstr )
    {
        _ADDSTR("+");
    }

    DWORD Opcode = (dwInstr & D3DSI_OPCODE_MASK);
    DWORD DstParam = 0;
    DWORD SrcParam[PSTR_MAX_NUMSRCPARAMS];
    DWORD SrcRelAddrToken[PSTR_MAX_NUMSRCPARAMS];
    DWORD SrcParamCount = 0;
    DWORD DstParamCount = 0;
    DWORD DclInfoToken = 0;
    BOOL bPredicated = (D3DSHADER_INSTRUCTION_PREDICATED & dwInstr);
    DWORD SrcPredicateToken = 0;

    union
    {
        // DEF'd constants (only for DEF statements)
        FLOAT   fDefValues[PSTR_NUM_COMPONENTS_IN_REGISTER];
        INT     iDefValues[PSTR_NUM_COMPONENTS_IN_REGISTER];
        DWORD   dwDefValues[PSTR_NUM_COMPONENTS_IN_REGISTER];
        BOOL    bDefValue;
    };

    switch ( D3DSI_OPCODE_MASK & dwInstr )
    {
    case D3DSIO_COMMENT:
        _ADDSTR("/* ");
        _ADDSTRP("%s", pdwToken);
        _ADDSTR(" */");
        pdwToken += ( dwInstr & D3DSI_COMMENTSIZE_MASK ) >> D3DSI_COMMENTSIZE_SHIFT;
        goto EXIT;

    case D3DSIO_NOP:
        goto EXIT;

    case D3DSIO_DCL:
        DclInfoToken = *pdwToken++;
        break;

    case D3DSIO_END:
        _ADDSTR("end");
        goto EXIT;
    }

    // Decode dest param.
    if ( *pdwToken & ( 1L << 31 ) )
    {
        switch(D3DSI_OPCODE_MASK & dwInstr)
        {
        case D3DSIO_CALL:
        case D3DSIO_REP:
        case D3DSIO_LOOP:
        case D3DSIO_CALLNZ:
        case D3DSIO_IF:
        case D3DSIO_IFC:
        case D3DSIO_BREAKC:
        case D3DSIO_BREAKP:
        case D3DSIO_LABEL:
            // no dst param, only src params.
            break;
        case D3DSIO_DEF:
        case D3DSIO_DEFI:
            DstParam = *pdwToken++;
            DstParamCount++;
            for(UINT Component = 0; Component < PSTR_NUM_COMPONENTS_IN_REGISTER; Component++)
            {
                dwDefValues[Component] = *pdwToken++;
            }
            break;
        case D3DSIO_DEFB:
            DstParam = *pdwToken++;
            DstParamCount++;
            bDefValue = *pdwToken++;
            break;
        default:
            DstParam = *pdwToken++;
            DstParamCount++;
            break;
        }

        // Decode predicate token
        if(bPredicated)
        {
            _SHADER_CONV_ASSERT(*pdwToken & (1L<<31),"D3DPSInstDisAsm - Expected predicate token");
            SrcPredicateToken = *pdwToken++;
        }

        // Decode source tokens
        while ( *pdwToken & ( 1L << 31 ) )
        {
            SHADER_CONV_ASSERT( SrcParamCount < _countof( SrcParam ) );
            SrcParam[SrcParamCount] = *pdwToken++;
            if ( D3DSI_GETADDRESSMODE( SrcParam[SrcParamCount] ) & D3DSHADER_ADDRMODE_RELATIVE )
            {
                if ( ( __IS_VS( dwVersion ) && dwVersion >= D3DVS_VERSION(2,0) ) ||
                     ( __IS_PS( dwVersion ) && dwVersion >= D3DPS_VERSION(3,0) ) )
                {
                    SrcRelAddrToken[SrcParamCount] = *pdwToken++;
                }
                else
                {
                    SrcRelAddrToken[SrcParamCount] = 0xffffffff;
                }
            }
            else
            {
                SrcRelAddrToken[SrcParamCount] = 0;
            }
            SrcParamCount++;
        }
    }

    // Emit disassembly

    // Emit predicate
    if(bPredicated)
    {
        _ADDSTR("(");

        switch (SrcPredicateToken & D3DSP_SRCMOD_MASK)
        {
        case D3DSPSM_NONE:
            break;
        case D3DSPSM_NOT:
            _ADDSTR("!");
            break;
        default:
            WarpError("D3DPSInstDisAsm - Unexpected source modifier on predicate token.");
        }
        switch (D3DSI_GETREGTYPE(SrcPredicateToken))
        {
        case D3DSPR_PREDICATE: _ADDSTR( "p" ); _SHADER_CONV_ASSERT(0==D3DSI_GETREGNUM(SrcPredicateToken),
                                   "D3DPSInstDisAsm - predicate register with nonzero regnum is unexpected");
            break;
        default:
            WarpError("D3DPSInstDisAsm - Expected predicate token to have predicate register type.");
            break;
        }
        _ADDSTRP( "%d", D3DSI_GETREGNUM(SrcPredicateToken));

        switch (SrcPredicateToken & D3DSP_SRCMOD_MASK)
        {
        case D3DSPSM_NONE:
        case D3DSPSM_NOT:
            break;
        default:
            WarpError("Unexpected srcmod for predicate token.");
            break;
        }
        GetSwizzleName(SwizzleBuf,SWIZZLE_BUF_SIZE,SrcPredicateToken & D3DVS_SWIZZLE_MASK);
        _ADDSTRP("%s",SwizzleBuf);
        _ADDSTR(") ");
    }

    switch (Opcode)
    {
    case D3DSIO_BEM:    _ADDSTR("bem"); break;
    case D3DSIO_PHASE:  _ADDSTR("phase"); break;
    case D3DSIO_ABS:    _ADDSTR("abs"); break;
    case D3DSIO_ADD:    _ADDSTR("add"); break;
    case D3DSIO_BREAK:  _ADDSTR("break"); break;
    case D3DSIO_BREAKC: _ADDSTR("break"); break;
    case D3DSIO_BREAKP: _ADDSTR("breakp"); break;
    case D3DSIO_CALL:   _ADDSTR("call"); break;
    case D3DSIO_CALLNZ: _ADDSTR("callnz"); break;
    case D3DSIO_CMP:    _ADDSTR("cmp"); break;
    case D3DSIO_CND:    _ADDSTR("cnd"); break;
    case D3DSIO_CRS:    _ADDSTR("crs"); break;
    case D3DSIO_DCL:    _ADDSTR("dcl"); break;
    case D3DSIO_DEF:    _ADDSTR("def"); break;
    case D3DSIO_DEFI:   _ADDSTR("defi"); break;
    case D3DSIO_DEFB:   _ADDSTR("defb"); break;
    case D3DSIO_DP2ADD: _ADDSTR("dp2add"); break;
    case D3DSIO_DP3:    _ADDSTR("dp3"); break;
    case D3DSIO_DP4:    _ADDSTR("dp4"); break;
    case D3DSIO_DSX:    _ADDSTR("dsx"); break;
    case D3DSIO_DSY:    _ADDSTR("dsy"); break;
    case D3DSIO_ELSE:   _ADDSTR("else");  break;
    case D3DSIO_ENDIF:  _ADDSTR("endif"); break;
    case D3DSIO_ENDLOOP:_ADDSTR("endloop"); break;
    case D3DSIO_ENDREP: _ADDSTR("endrep"); break;
    case D3DSIO_EXP:    _ADDSTR("exp"); break;
    case D3DSIO_EXPP:   _ADDSTR("expp"); break;
    case D3DSIO_FRC:    _ADDSTR("frc"); break;
    case D3DSIO_IF:     _ADDSTR("if");  break;
    case D3DSIO_IFC:    _ADDSTR("if");  break;
    case D3DSIO_LABEL:  _ADDSTR("label");  break;
    case D3DSIO_LOG:    _ADDSTR("log"); break;
    case D3DSIO_LOGP:   _ADDSTR("logp"); break;
    case D3DSIO_LOOP:   _ADDSTR("loop"); break;
    case D3DSIO_LRP:    _ADDSTR("lrp"); break;
    case D3DSIO_M3x2:   _ADDSTR("m3x2"); break;
    case D3DSIO_M3x3:   _ADDSTR("m3x3"); break;
    case D3DSIO_M3x4:   _ADDSTR("m3x4"); break;
    case D3DSIO_M4x3:   _ADDSTR("m4x3"); break;
    case D3DSIO_M4x4:   _ADDSTR("m4x4"); break;
    case D3DSIO_MAD:    _ADDSTR("mad"); break;
    case D3DSIO_MIN:    _ADDSTR("min"); break;
    case D3DSIO_MAX:    _ADDSTR("max"); break;
    case D3DSIO_MOV:    _ADDSTR("mov"); break;
    case D3DSIO_MOVA:   _ADDSTR("mova"); break;
    case D3DSIO_MUL:    _ADDSTR("mul"); break;
    case D3DSIO_NOP:    _ADDSTR("nop"); break;
    case D3DSIO_NRM:    _ADDSTR("nrm"); break;
    case D3DSIO_RCP:    _ADDSTR("rcp"); break;
    case D3DSIO_REP:    _ADDSTR("rep"); break;
    case D3DSIO_RET:    _ADDSTR("ret"); break;
    case D3DSIO_RSQ:    _ADDSTR("rsq"); break;
    case D3DSIO_POW:    _ADDSTR("pow"); break;
    case D3DSIO_SETP:   _ADDSTR("setp"); break;
    case D3DSIO_SINCOS: _ADDSTR("sincos"); break;
    case D3DSIO_SUB:    _ADDSTR("sub"); break;
    case D3DSIO_LIT:    _ADDSTR("lit"); break;
    case D3DSIO_SGE:    _ADDSTR("sge"); break;
    case D3DSIO_SLT:    _ADDSTR("slt"); break;
    case D3DSIO_SGN:    _ADDSTR("sgn"); break;
    case D3DSIO_DST:    _ADDSTR("dst"); break;
    case D3DSIO_TEXCOORD:
        if(SrcParamCount)
            _ADDSTR("texcrd")
        else
            _ADDSTR("texcoord")
        break;
    case D3DSIO_TEX:
        if(SrcParamCount)
        {
          _ADDSTR("texld")
          if(D3DSI_TEXLD_PROJECT==(dwInstr&D3DSP_OPCODESPECIFICCONTROL_MASK))
              _ADDSTR("p")
          else if(D3DSI_TEXLD_BIAS==(dwInstr&D3DSP_OPCODESPECIFICCONTROL_MASK))
              _ADDSTR("b")
        }
        else
          _ADDSTR("tex")
        break;
    case D3DSIO_TEXLDD      : _ADDSTR("texldd"); break;
    case D3DSIO_TEXLDL      : _ADDSTR("texldl"); break;
    case D3DSIO_TEXKILL     : _ADDSTR("texkill"); break;
    case D3DSIO_TEXBEM_LEGACY:
    case D3DSIO_TEXBEM      : _ADDSTR("texbem"); break;
    case D3DSIO_TEXBEML_LEGACY:
    case D3DSIO_TEXBEML     : _ADDSTR("texbeml"); break;
    case D3DSIO_TEXREG2AR   : _ADDSTR("texreg2ar"); break;
    case D3DSIO_TEXREG2GB   : _ADDSTR("texreg2gb"); break;
    case D3DSIO_TEXM3x2PAD  : _ADDSTR("texm3x2pad"); break;
    case D3DSIO_TEXM3x2TEX  : _ADDSTR("texm3x2tex"); break;
    case D3DSIO_TEXM3x3PAD  : _ADDSTR("texm3x3pad"); break;
    case D3DSIO_TEXM3x3TEX  : _ADDSTR("texm3x3tex"); break;
    case D3DSIO_TEXM3x3SPEC : _ADDSTR("texm3x3spec"); break;
    case D3DSIO_TEXM3x3VSPEC: _ADDSTR("texm3x3vspec"); break;
    case D3DSIO_TEXM3x2DEPTH: _ADDSTR("texm3x2depth"); break;
    case D3DSIO_TEXDP3      : _ADDSTR("texdp3"); break;
    case D3DSIO_TEXREG2RGB  : _ADDSTR("texreg2rgb"); break;
    case D3DSIO_TEXDEPTH    : _ADDSTR("texdepth"); break;
    case D3DSIO_TEXDP3TEX   : _ADDSTR("texdp3tex"); break;
    case D3DSIO_TEXM3x3     : _ADDSTR("texm3x3"); break;
    case D3DSIO_END         : _ADDSTR("end"); break;
    default:
        WarpError("Attempt to disassemble unknown instruction!");
        break;
    }

    switch (Opcode)
    {
    case D3DSIO_IFC:
    case D3DSIO_BREAKC:
    case D3DSIO_SETP:
        switch(D3DSI_GETCOMPARISON(dwInstr))
        {
        case D3DSPC_GT: _ADDSTR("_gt"); break;
        case D3DSPC_EQ: _ADDSTR("_eq"); break;
        case D3DSPC_GE: _ADDSTR("_ge"); break;
        case D3DSPC_LT: _ADDSTR("_lt"); break;
        case D3DSPC_NE: _ADDSTR("_ne"); break;
        case D3DSPC_LE: _ADDSTR("_le"); break;
        default:
            WarpError("D3DPSInstDisAsm - Unexpected comparison type.");
            break;
        }
        break;
    case D3DSIO_DCL:
        switch (D3DSI_GETTEXTURETYPE(DclInfoToken))
        {
        case D3DSTT_2D:
            _ADDSTR("_2d");
            break;

        case D3DSTT_CUBE:
            _ADDSTR("_cube");
            break;

        case D3DSTT_VOLUME:
            _ADDSTR("_volume");
            break;

        default:
            switch (D3DSI_GETUSAGE(DclInfoToken))
            {
            case D3DDECLUSAGE_POSITION:
                _ADDSTRP("_position%d",D3DSI_GETUSAGEINDEX(DclInfoToken));
                break;
            case D3DDECLUSAGE_BLENDWEIGHT:
                _ADDSTRP("_blendweight%d",D3DSI_GETUSAGEINDEX(DclInfoToken));
                break;
            case D3DDECLUSAGE_BLENDINDICES:
                _ADDSTRP("_blendindices%d",D3DSI_GETUSAGEINDEX(DclInfoToken));
                break;
            case D3DDECLUSAGE_NORMAL:
                _ADDSTRP("_normal%d",D3DSI_GETUSAGEINDEX(DclInfoToken));
                break;
            case D3DDECLUSAGE_PSIZE:
                _ADDSTRP("_psize%d",D3DSI_GETUSAGEINDEX(DclInfoToken));
                break;
            case D3DDECLUSAGE_TEXCOORD:
                _ADDSTRP("_texcoord%d",D3DSI_GETUSAGEINDEX(DclInfoToken));
                break;
            case D3DDECLUSAGE_TANGENT:
                _ADDSTRP("_tangent%d",D3DSI_GETUSAGEINDEX(DclInfoToken));
                break;
            case D3DDECLUSAGE_BINORMAL:
                _ADDSTRP("_binormal%d",D3DSI_GETUSAGEINDEX(DclInfoToken));
                break;
            case D3DDECLUSAGE_TESSFACTOR:
                _ADDSTRP("_tessfactor%d",D3DSI_GETUSAGEINDEX(DclInfoToken));
                break;
            case D3DDECLUSAGE_POSITIONT:
                _ADDSTRP("_positiont%d",D3DSI_GETUSAGEINDEX(DclInfoToken));
                break;
            case D3DDECLUSAGE_COLOR:
                _ADDSTRP("_color%d",D3DSI_GETUSAGEINDEX(DclInfoToken));
                break;
            case D3DDECLUSAGE_FOG:
                _ADDSTRP("_fog%d",D3DSI_GETUSAGEINDEX(DclInfoToken));
                break;
            case D3DDECLUSAGE_DEPTH:
                _ADDSTRP("_depth%d",D3DSI_GETUSAGEINDEX(DclInfoToken));
                break;
            case D3DDECLUSAGE_SAMPLE:
                _ADDSTRP("_sample%d",D3DSI_GETUSAGEINDEX(DclInfoToken));
                break;
            }
        }
        break;
    }
    if (DstParam)
    {
        switch ( (DstParam & D3DSP_DSTSHIFT_MASK) >> D3DSP_DSTSHIFT_SHIFT )
        {
        default:
        case 0x0: break;
        case 0x1: _ADDSTR("_x2"); break;
        case 0x2: _ADDSTR("_x4"); break;
        case 0x3: _ADDSTR("_x8"); break;
        case 0xF: _ADDSTR("_d2"); break;
        case 0xE: _ADDSTR("_d4"); break;
        case 0xD: _ADDSTR("_d8"); break;
        }
        if(DstParam & D3DSPDM_SATURATE)
        {
            _ADDSTR("_sat");
        }
        if(DstParam & D3DSPDM_PARTIALPRECISION)
        {
            _ADDSTR("_pp");
        }
        if(DstParam & D3DSPDM_MSAMPCENTROID)
        {
            _ADDSTR("_centroid");
        }

        switch (D3DSI_GETREGTYPE_RESOLVING_CONSTANTS(DstParam))
        {
        case D3DSPR_RASTOUT:
            switch ( D3DSI_GETREGNUM(DstParam) )
            {
            case D3DSRO_POSITION:   _ADDSTR(" oPos"); break;
            case D3DSRO_FOG:        _ADDSTR(" oFog"); break;
            case D3DSRO_POINT_SIZE: _ADDSTR(" oPts"); break;
            default:
                WarpError("D3DPSInstDisAsm - Unexpected dest register type.");
                break;
            }
            break;

        case D3DSPR_ATTROUT:    _ADDSTRP(" oD%d", D3DSI_GETREGNUM(DstParam) ); break;
        case D3DSPR_TEXCRDOUT:  _ADDSTRP(" oT%d", D3DSI_GETREGNUM(DstParam) ); break;
        case D3DSPR_INPUT:      _ADDSTRP(" v%d", D3DSI_GETREGNUM(DstParam) ); break;
        case D3DSPR_TEMP:       _ADDSTRP(" r%d", D3DSI_GETREGNUM(DstParam) ); break;

        case D3DSPR_TEXTURE:
        //   D3DSPR_ADDR:
            if ( __IS_VS(dwVersion) )
            {
                _ADDSTR(" a0");
            }
            else
            {
                _ADDSTRP(" t%d", D3DSI_GETREGNUM(DstParam) );
            }
            break;

        case D3DSPR_CONST:      _ADDSTRP(" c%d", D3DSI_GETREGNUM_RESOLVING_CONSTANTS(DstParam) ); break;
        case D3DSPR_CONSTINT:   _ADDSTRP(" i%d", D3DSI_GETREGNUM(DstParam) ); break;
        case D3DSPR_CONSTBOOL:  _ADDSTRP(" b%d", D3DSI_GETREGNUM(DstParam) ); break;
        case D3DSPR_SAMPLER:    _ADDSTRP(" s%d", D3DSI_GETREGNUM(DstParam) ); break;
        case D3DSPR_DEPTHOUT:   _ADDSTR(" oDepth"); _SHADER_CONV_ASSERT(0==D3DSI_GETREGNUM(DstParam),"D3DPSInstDisAsm - oDepth with nonzero regnum is unexpected"); break;
        case D3DSPR_COLOROUT:   _ADDSTRP(" oC%d", D3DSI_GETREGNUM(DstParam) ); break;
        case D3DSPR_LABEL:      _ADDSTRP(" l%d", D3DSI_GETREGNUM(DstParam) ); break;
        case D3DSPR_LOOP:       _ADDSTR(" aL"); _SHADER_CONV_ASSERT(0==D3DSI_GETREGNUM(DstParam),"D3DPSInstDisAsm - aL with nonzero regnum is unexpected"); break;
        case D3DSPR_PREDICATE:  _ADDSTRP(" p%d", D3DSI_GETREGNUM(DstParam) ); _SHADER_CONV_ASSERT(0==D3DSI_GETREGNUM(DstParam),"D3DPSInstDisAsm - predicate with nonzero regnum is unexpected"); break;
        case D3DSPR_MISCTYPE:
            switch(D3DSI_GETREGNUM(DstParam))
            {
            case D3DSMO_POSITION:
                _ADDSTR(" vPos");
                break;
            case D3DSMO_FACE:
                _ADDSTR(" vFace");
                break;
            }
            break;
        default:
            WarpError("D3DPSInstDisAsm - Unexpected dest register type.");
            break;
        }
        if (D3DSP_WRITEMASK_ALL != (DstParam & D3DSP_WRITEMASK_ALL))
        {
            _ADDSTR(".");
            if (DstParam & D3DSP_WRITEMASK_0) _ADDSTR("r");
            if (DstParam & D3DSP_WRITEMASK_1) _ADDSTR("g");
            if (DstParam & D3DSP_WRITEMASK_2) _ADDSTR("b");
            if (DstParam & D3DSP_WRITEMASK_3) _ADDSTR("a");
        }
    }

    if( D3DSIO_DEF == Opcode )
    {
        _ADDSTRP(", %f, ",fDefValues[0]);
        _ADDSTRP("%f, ",fDefValues[1]);
        _ADDSTRP("%f, ",fDefValues[2]);
        _ADDSTRP("%f",fDefValues[3]);
        goto EXIT;
    }
    else if( D3DSIO_DEFI == Opcode )
    {
        _ADDSTRP(", %d, ",iDefValues[0]);
        _ADDSTRP("%d, ",iDefValues[1]);
        _ADDSTRP("%d, ",iDefValues[2]);
        _ADDSTRP("%d",iDefValues[3]);
        goto EXIT;
    }
    else if( D3DSIO_DEFB == Opcode )
    {
        _ADDSTRP(", %s",bDefValue ? "true" : "false");
        goto EXIT;
    }

    if(!DstParam && SrcParamCount)
    {
        _ADDSTR(" ");
    }

    for( i = 0; i < SrcParamCount; i++ )
    {
        if( DstParamCount || (i > 0) )
        {
            _ADDSTR( ", ");
        }

        switch (SrcParam[i] & D3DSP_SRCMOD_MASK)
        {
        default:
        case D3DSPSM_NONE:
        case D3DSPSM_BIAS:
        case D3DSPSM_SIGN:
        case D3DSPSM_X2:
        case D3DSPSM_DZ:
        case D3DSPSM_DW:
            break;
        case D3DSPSM_NEG:
        case D3DSPSM_BIASNEG:
        case D3DSPSM_SIGNNEG:
        case D3DSPSM_X2NEG:
        case D3DSPSM_ABSNEG:
            _ADDSTR( "-");
            break;
        case D3DSPSM_COMP:
            _ADDSTR( "1-");
            break;
        case D3DSPSM_NOT:
            _ADDSTR( "!" );
            break;
        }
        switch (D3DSI_GETREGTYPE_RESOLVING_CONSTANTS(SrcParam[i]))
        {
        case D3DSPR_TEMP:       _ADDSTR("r"); break;
        case D3DSPR_INPUT:      _ADDSTR("v"); break;
        case D3DSPR_CONST:      _ADDSTR("c"); break;
        case D3DSPR_CONSTINT:   _ADDSTR("i"); break;
        case D3DSPR_CONSTBOOL:  _ADDSTR("b"); break;
        case D3DSPR_SAMPLER:    _ADDSTR("s");break;
        case D3DSPR_LABEL:      _ADDSTR("l"); break;

        case D3DSPR_TEXTURE:
        //   D3DSPR_ADDR:
            if ( __IS_VS(dwVersion) )
            {
                _ADDSTR("a0");
            }
            else
            {
                _ADDSTR("t");
            }
            break;

        case D3DSPR_MISCTYPE:
            switch(D3DSI_GETREGNUM(SrcParam[i]))
            {
            case D3DSMO_POSITION:
                _ADDSTR( "vPos");
                break;
            case D3DSMO_FACE:
                _ADDSTR( "face");
                break;
            }
            break;
        case D3DSPR_LOOP: _ADDSTR( "aL" ); _SHADER_CONV_ASSERT(0==D3DSI_GETREGNUM(SrcParam[i]),"D3DPSInstDisAsm - aL with nonzero regnum is unexpected"); break;
        case D3DSPR_PREDICATE: _ADDSTR( "p" ); _SHADER_CONV_ASSERT(0==D3DSI_GETREGNUM(SrcParam[i]),"D3DPSInstDisAsm - predicate register with nonzero regnum is unexpected"); break;
        default:
            WarpError("D3DPSInstDisAsm - Unexpected source register type");
            break;
        }
        switch (D3DSI_GETREGTYPE_RESOLVING_CONSTANTS(SrcParam[i]))
        {
        case D3DSPR_TEMP:
        case D3DSPR_INPUT:
        case D3DSPR_TEXTURE:
        case D3DSPR_CONST:
        case D3DSPR_CONSTINT:
        case D3DSPR_CONSTBOOL:
        case D3DSPR_SAMPLER:
        case D3DSPR_LABEL:
        case D3DSPR_PREDICATE:
            if( SrcRelAddrToken[i] )
            {
                _ADDSTR( "[");

                if ( 0xffffffff == SrcRelAddrToken[i] )
                {
                    _ADDSTR( "a0");
                }
                else
                {
                    switch(D3DSI_GETREGTYPE(SrcRelAddrToken[i]))
                    {
                    case D3DSPR_LOOP:
                        _ADDSTR( "aL");
                        _SHADER_CONV_ASSERT(0 == D3DSI_GETREGNUM_RESOLVING_CONSTANTS(SrcRelAddrToken[i]),"D3DPSInstDisAsm - Unexpected nonzero register # for aL.");
                        break;
                    case D3DSPR_ADDR:
                        _ADDSTR( "a0");
                        _SHADER_CONV_ASSERT(0 == D3DSI_GETREGNUM_RESOLVING_CONSTANTS(SrcRelAddrToken[i]),"D3DPSInstDisAsm - Unexpected nonzero register # for a0.");
                        break;
                    default:
                        WarpError("D3DPSInstDisAsm - Unexpected relative addressing register type.");
                        break;
                    }

                    GetSwizzleName(SwizzleBuf,SWIZZLE_BUF_SIZE,SrcParam[i] & D3DVS_SWIZZLE_MASK);
                    _ADDSTRP( "%s",SwizzleBuf);
                }

                if(D3DSI_GETREGNUM_RESOLVING_CONSTANTS(SrcParam[i])>0)
                {
                    _ADDSTRP( "+%d",D3DSI_GETREGNUM_RESOLVING_CONSTANTS(SrcParam[i]));
                }
                _ADDSTR( "]");
            }
            else
            {
                _ADDSTRP( "%d", D3DSI_GETREGNUM(SrcParam[i]));
            }
            break;
        case D3DSPR_MISCTYPE:
        case D3DSPR_LOOP:
            break;
        default:
            WarpError("D3DPSInstDisAsm - Unexpected source register type");
            break;
        }
        switch (SrcParam[i] & D3DSP_SRCMOD_MASK)
        {
        default:
        case D3DSPSM_NONE:    break;
        case D3DSPSM_NEG:     break;
        case D3DSPSM_BIAS:
        case D3DSPSM_BIASNEG:
            _ADDSTR( "_bias");
            break;
        case D3DSPSM_SIGN:
        case D3DSPSM_SIGNNEG:
            _ADDSTR( "_bx2");
            break;
        case D3DSPSM_COMP:
            break;
        case D3DSPSM_X2:
        case D3DSPSM_X2NEG:
            _ADDSTR( "_x2");
            break;
        case D3DSPSM_DZ:
            _ADDSTR( "_db");
            break;
        case D3DSPSM_DW:
            _ADDSTR( "_da");
            break;
        case D3DSPSM_ABS:
        case D3DSPSM_ABSNEG:
            _ADDSTR( "_abs");
            break;
        }
        GetSwizzleName(SwizzleBuf,SWIZZLE_BUF_SIZE,SrcParam[i] & D3DVS_SWIZZLE_MASK);
        _ADDSTRP( "%s",SwizzleBuf);
    }

EXIT:

    *ppdwShader = pdwToken;

    return StringCchPrintfA( lpszRet, cchNumChars, "%s%s", pPrefix, pStr );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
HRESULT
Disasm20( const DWORD* pdwShaderAsm, DWORD /*dwFlags*/ )
{
    HRESULT hr;

    char szInstr[256] = { 0 };

    // Get the shader version
    const DWORD dwVersion = *pdwShaderAsm++;
    switch ( dwVersion )
    {
    // Pixel shader

    case D3DPS_VERSION(3,0):
        StringCchPrintfA(szInstr,256,"ps 3.0");
        break;

    case D3DPS_VERSION(2,1):
        StringCchPrintfA(szInstr,256,"ps 2.1");
        break;

    case D3DPS_VERSION(2,0):
        StringCchPrintfA(szInstr,256,"ps 2.0");
        break;

    case D3DPS_VERSION(1,4):
        StringCchPrintfA(szInstr,256,"ps 1.4");
        break;

    case D3DPS_VERSION(1,3):
        StringCchPrintfA(szInstr,256,"ps 1.3");
        break;

    case D3DPS_VERSION(1,2):
        StringCchPrintfA(szInstr,256,"ps 1.2");
        break;

    case D3DPS_VERSION(1,1):
        StringCchPrintfA(szInstr,256,"ps 1.1");
        break;

    case D3DPS_VERSION(1,0):
        StringCchPrintfA(szInstr,256,"ps 1.0");
        break;

    // Vertex shader

    case D3DVS_VERSION(3,0):
        StringCchPrintfA(szInstr,256,"vs 3.0");
        break;

    case D3DVS_VERSION(2,1):
        StringCchPrintfA(szInstr,256,"vs 2.1");
        break;

    case D3DVS_VERSION(2,0):
        StringCchPrintfA(szInstr,256,"vs 2.0");
        break;

    case D3DVS_VERSION(1,4):
        StringCchPrintfA(szInstr,256,"vs 1.4");
        break;

    case D3DVS_VERSION(1,3):
        StringCchPrintfA(szInstr,256,"vs 1.3");
        break;

    case D3DVS_VERSION(1,2):
        StringCchPrintfA(szInstr,256,"vs 1.2");
        break;

    case D3DVS_VERSION(1,1):
        StringCchPrintfA(szInstr,256,"vs 1.1");
        break;

    case D3DVS_VERSION(1,0):
        StringCchPrintfA(szInstr,256,"vs 1.0");
        break;

    default:
        return E_INVALIDARG;
    }

    while ( *pdwShaderAsm != D3DPS_END() )
    {
        hr = DisAsmInstr( szInstr, 256, &pdwShaderAsm, dwVersion );
        if ( FAILED( hr ) )
        {
            return hr;
        }

    }

    return S_OK;
}

} // namespace ShaderConv

#endif //DBG && WARP_INTERNAL

```

`ShaderConverter/ShaderConv/gsconv.cpp`:

```cpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/*==========================================================================;
*
*  Copyright (C) Microsoft Corporation.  All Rights Reserved.
*
*  Implementation for The Geometry Shader Converter
*
****************************************************************************/

#include "pch.h"
#include "context.hpp"

namespace ShaderConv
{

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
enum eSystemRegister2
{
    SYS_REG0,
    SYS_REG1,
    SYS_REG2,
    SYS_REG3,

    SYS_PSCALE0,
    SYS_PSCALE1,
    SYS_PSCALE2,
    SYS_PSCALE3,

    SYS_REG_SIZE,
};

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
HRESULT
CTranslator::TranslateGS( const CGeometryShaderDesc* pShaderDesc,
                          CCodeBlob** ppCodeBlob )
{
    HRESULT hr;

    if ( NULL == ppCodeBlob )
    {
        SHADER_CONV_ASSERT(FALSE);
        return E_INVALIDARG;
    }

    // Verify that this geometry shader descriptor is valid
    if ( !pShaderDesc->IsValid() )
    {
        SHADER_CONV_ASSERT(FALSE);
        return E_INVALIDARG;
    }

    // Create a new geometry shader context
    CGSContext* pContext = new CGSContext( m_runtimeVersion, pShaderDesc, m_pShaderAsm );
    if ( NULL == pContext )
    {
        return E_OUTOFMEMORY;
    }

    // Start the shader assembler
    m_pShaderAsm->StartShader( D3D10_SB_GEOMETRY_SHADER, 4, 0, pShaderDesc->GetShaderSettings());

    // Write the shader declarations
    hr = pContext->WriteDeclarations();
    if ( FAILED( hr ) )
    {
        __safeDelete( pContext );
        SHADER_CONV_ASSERT(FALSE);
        return hr;
    }

    // Translate instructions
    hr = pContext->TranslateInstructions();
    if ( FAILED( hr ) )
    {
        __safeDelete( pContext );
        SHADER_CONV_ASSERT(FALSE);
        return hr;
    }

    // Write the ouput registers
    pContext->WriteOutputs();

    // Delete the context
    __safeDelete( pContext );

    // End the shader assembler
    hr = m_pShaderAsm->EndShader();
    if (FAILED(hr))
    {
        SHADER_CONV_ASSERT(FALSE);
        return hr;
    }

    // Create the code blob
    hr = CCodeBlob::Create( m_pShaderAsm->ShaderSizeInDWORDs() * sizeof( UINT ),
                            m_pShaderAsm->GetShader(),
                            ppCodeBlob );
    if ( FAILED( hr ) )
    {
        SHADER_CONV_ASSERT(FALSE);
        return hr;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////

CGeometryShaderDesc::CGeometryShaderDesc(
    UINT runtimeVersion,
    UINT shaderSettings,
    const VSOutputDecls& vsOutputDecls,
    const RasterStates& rasterStates ) :
    m_shaderSettings(shaderSettings)
{
    this->Clear();

    GSFLAGS flags;

    if ( D3DFILL_POINT == rasterStates.FillMode &&
         rasterStates.PrimitiveType >= D3DPT_TRIANGLELIST )
    {
        // Triangle Point fill enabled
        flags.PointFill = 1;

        if ((runtimeVersion < 9)
         && (D3DSHADE_FLAT == rasterStates.ShadeMode))
        {
            flags.FlatColorFill = 1;
        }
    }

    if ( flags.PointFill ||
         D3DPT_POINTLIST == rasterStates.PrimitiveType )
    {
        if ( rasterStates.PointSpriteEnable )
        {
            // Point sprite enabled
            flags.PointSprite = 1;
        }

        if ( flags.PointFill ||
             flags.PointSprite ||
             vsOutputDecls.PointSize ||
             rasterStates.PointSizeEnable )
        {
            // Point size enabled
            flags.PointSize = 1;
        }
    }

    if (vsOutputDecls.TexCoords 
     && !flags.PointSprite 
     && (D3DPT_POINTLIST != rasterStates.PrimitiveType))
    {
        for (UINT i = 0, mask = vsOutputDecls.TexCoords; mask; mask >>= 1, ++i)
        {
            if (mask & 1)
            {
                const BYTE texCoordWrap = rasterStates.PSSamplers[i].TexCoordWrap;
                if (texCoordWrap)
                {
                    // Copy the texture wrap value
                    m_textureWraps[i] = texCoordWrap;

                    // Enable Texture wrapping
                    flags.TextureWrap = 1;
                }
            }
        }
    }

    if (flags.Value)
    {
        // Select input/output topology
        switch (rasterStates.PrimitiveType)
        {
        default:
            NO_DEFAULT;

        case D3DPT_POINTLIST:
            flags.PrimitiveSize = 1;
            break;

        case D3DPT_LINELIST:
        case D3DPT_LINESTRIP:
            flags.PrimitiveSize = 2;
            break;

        case D3DPT_TRIANGLELIST:
        case D3DPT_TRIANGLESTRIP:
        case D3DPT_TRIANGLEFAN:
            flags.PrimitiveSize = 3;
            break;
        }

        flags.UserClipPlanes = rasterStates.UserClipPlanes;
        flags.HasTLVertices  = rasterStates.HasTLVertices;                

        // Copy the input declaration
        m_inputDecls = vsOutputDecls;
        m_outputDecls = vsOutputDecls;

        // Update the flags
        m_flags = flags;
    }
    
    if (rasterStates.PointSpriteEnable)
    {
        m_outputDecls.AddDecl(D3DDECLUSAGE_POINTSPRITE, 0, VSOREG_PointSprite, D3DSP_WRITEMASK_ALL);
    }
}

//////////////////////////////////////////////////////////////////////////////

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
CGSContext::CGSContext( 
    UINT runtimeVersion,
    const CGeometryShaderDesc* pShaderDesc,
    CShaderAsmWrapper* pShaderAsm) 
    : IContext(runtimeVersion, pShaderAsm)
    , m_pShaderDesc(pShaderDesc)
{
    // Get the primitive size
    m_uiPrimitiveSize = pShaderDesc->GetPrimitiveSize();

    // Cache needed declarations
    const VSOutputDecls& vsInputDecls = pShaderDesc->GetInputDecls();
    for (UINT i = 0, n = vsInputDecls.GetSize(); i < n; ++i)
    {
        const UINT usage = vsInputDecls[i].Usage;
        const UINT usageIndex = vsInputDecls[i].UsageIndex;

        if (D3DDECLUSAGE_TEXCOORD == usage)
        {
            m_texcoordDecls[usageIndex] = vsInputDecls[i];
        }
        else
        if (((D3DDECLUSAGE_POSITION == usage) 
          || (D3DDECLUSAGE_POSITIONT == usage)) 
         && (0 == usageIndex))
        {
            m_positionDecl = vsInputDecls[i];
        }
        else
        if ((D3DDECLUSAGE_PSIZE == usage)
         && (0 == usageIndex))
        {
            m_psizeDecl = vsInputDecls[i];
        }
    }

    // Reset temp registers
    memset(m_tempRegs, INVALID_INDEX, sizeof(m_tempRegs));
    m_uiNumTempRegs = SYS_REG_SIZE;
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
HRESULT
CGSContext::WriteDeclarations()
{
    const bool isPointSizeEnable   = m_pShaderDesc->PointSizeEnable();

    D3D10_SB_PRIMITIVE_TOPOLOGY topology;
    D3D10_SB_PRIMITIVE primitive;

    const UINT uiPrimitiveSize = m_uiPrimitiveSize;
    switch (uiPrimitiveSize)
    {
    default:
        NO_DEFAULT;

    case 1:
        primitive = D3D10_SB_PRIMITIVE_POINT;
        topology  = D3D10_SB_PRIMITIVE_TOPOLOGY_POINTLIST;
        break;

    case 2:
        primitive = D3D10_SB_PRIMITIVE_LINE;
        topology  = D3D10_SB_PRIMITIVE_TOPOLOGY_LINESTRIP;
        break;

    case 3:
        primitive = D3D10_SB_PRIMITIVE_TRIANGLE;
        topology  = D3D10_SB_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP;
        break;
    }

    UINT uiMaxVertices = uiPrimitiveSize;

    if (isPointSizeEnable)
    {
        uiMaxVertices *= 4;
        topology = D3D10_SB_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP;
    }

    // Declare maximum output vertex count
    m_pShaderAsm->EmitGSMaxOutputVertexCountDecl(uiMaxVertices);

    // Declare temp registers
    const VSOutputDecls& gsOutputDecls = m_pShaderDesc->GetOutputDecls();
    const UINT uNumTempRegs = m_uiNumTempRegs + gsOutputDecls.GetSize();
    SHADER_CONV_ASSERT(uNumTempRegs <= 0xff);
    m_pShaderAsm->EmitTempsDecl(uNumTempRegs);

    // Declare extension constant buffer
    m_pShaderAsm->EmitConstantBufferDecl(
        CB_VS_EXT, __sizeof16( VSCBExtension), D3D10_SB_CONSTANT_BUFFER_IMMEDIATE_INDEXED);

    // Declare input primitive type
    m_pShaderAsm->EmitGSInputPrimitiveDecl(primitive);

    // Declare output topology
    m_pShaderAsm->EmitGSOutputTopologyDecl(topology);

    // Declare input/output registers
    for (UINT i = 0, n = gsOutputDecls.GetSize(); i < n; ++i)
    {
        const UINT usage      = gsOutputDecls[i].Usage;
        const UINT usageIndex = gsOutputDecls[i].UsageIndex;
        const UINT regIndex   = gsOutputDecls[i].RegIndex;
        const UINT writeMask  = gsOutputDecls[i].WriteMask << D3D10_SB_OPERAND_4_COMPONENT_MASK_SHIFT;

        if ((D3DDECLUSAGE_POSITIONT == usage) 
         && (0 == usageIndex))
        {
            // D3D10_SB_NAME_POSITIONT is WARP only.
            //
            // // Declare input position register
            // m_pShaderAsm->EmitInputSystemInterpretedValueDecl2D(
            //    uiPrimitiveSize, regIndex, writeMask, D3D10_SB_NAME_POSITIONT );

            // // Declare output position register
            // m_pShaderAsm->EmitOutputSystemInterpretedValueDecl(
            //    regIndex, writeMask, D3D10_SB_NAME_POSITIONT);

            return E_FAIL;
        }
        else
        if ((D3DDECLUSAGE_POSITION == usage) 
         && (0 == usageIndex))
        {
            // Declare input position register
            m_pShaderAsm->EmitInputSystemInterpretedValueDecl2D(
                uiPrimitiveSize, regIndex, writeMask, D3D10_SB_NAME_POSITION);

            // Declare output position register
            m_pShaderAsm->EmitOutputSystemInterpretedValueDecl(
                regIndex, writeMask, D3D10_SB_NAME_POSITION);
        }
        else if (usage == D3DDECLUSAGE_POINTSPRITE)
        {
            // GS generates this value so don't declare an input declaration
            m_pShaderAsm->EmitOutputDecl(regIndex, writeMask);
        }
        else if (usage == D3DDECLUSAGE_CLIPDISTANCE)
        {
            // Declare input position register
            m_pShaderAsm->EmitInputSystemInterpretedValueDecl2D(
                uiPrimitiveSize, regIndex, writeMask, D3D10_SB_NAME_CLIP_DISTANCE);

            // Declare output position register
            m_pShaderAsm->EmitOutputSystemInterpretedValueDecl(
                regIndex, writeMask, D3D10_SB_NAME_CLIP_DISTANCE);
        }
        else 
        {
            m_pShaderAsm->EmitInputDecl2D(uiPrimitiveSize, regIndex, writeMask);
            
            // Do not output the pointsize register
            if (usage != D3DDECLUSAGE_PSIZE)
            {
                m_pShaderAsm->EmitOutputDecl(regIndex, writeMask);
            }
        }
    }

    return S_OK;
}


///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
HRESULT
CGSContext::TranslateInstructions()
{
    //--

    return S_OK;
}


///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CGSContext::WriteOutputs()
{
    const float vPointScaleCW[4][2] = {
        {-1.0f,-1.0f },
        { 1.0f,-1.0f },
        {-1.0f, 1.0f },
        { 1.0f, 1.0f },
    };

    const float vPointScaleCCW[4][2] = {
        {-1.0f,-1.0f },
        {-1.0f, 1.0f },
        { 1.0f,-1.0f },
        { 1.0f, 1.0f },
    };

    const UINT uiPrimitiveSize = m_uiPrimitiveSize;
    const VSOutputDecls& gsOutputDecls = m_pShaderDesc->GetOutputDecls();
    const UINT uiInputDeclSize = gsOutputDecls.GetSize();

    const bool isPointSizeEnable     = m_pShaderDesc->PointSizeEnable();
    const bool isPointFillEnable     = m_pShaderDesc->PointFillEnable();
    const bool isFlatColorFillEnable = m_pShaderDesc->FlatColorFillEnable();
    [[maybe_unused]] const bool isPointSpriteEnable   = m_pShaderDesc->PointSpriteEnable();
    const bool isTextureWrapEnable   = m_pShaderDesc->TextureWrapEnable();
    const bool hasTLVertices         = m_pShaderDesc->HasTLVertices();
    const UINT userClipPlanes        = m_pShaderDesc->GetUserClipPlanes();

    if ( isPointSizeEnable )
    {
        const InputRegister posReg(m_positionDecl.RegIndex, InputRegister::Input, m_positionDecl.WriteMask);
        const InputRegister psizeReg(m_psizeDecl.RegIndex, InputRegister::Input, m_psizeDecl.WriteMask);
        const UINT psizeSwizzle  = __swizzleFromWriteMask(
            m_psizeDecl.WriteMask << D3D10_SB_OPERAND_4_COMPONENT_MASK_SHIFT );

        if ( isPointFillEnable )
        {
            // The three vertices might be orriented counter clock wise,
            // then allowing culling to reject the generated quads.
            // We need to make sure that this doesn't happen by performing
            // our own cull test here and reverting the triangles direction.

            if ( hasTLVertices )
            {
                // Calculate backface culling
                // sign = ( ( x1 - x0 ) * ( y2 - y0 ) ) -
                //        ( ( x2 - x0 ) * ( y1 - y0 ) );
                // if ( sign < 0 ) => "is front face"

                m_pShaderAsm->EmitInstruction(
                    CInstruction( D3D10_SB_OPCODE_ADD,
                                  CTempOperandDst( SYS_REG0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                                  this->CreateInputSrcOperand( 1, posReg, __SWIZZLE_X ),
                                  CNegate( this->CreateInputSrcOperand( 0, posReg, __SWIZZLE_X ) ) ) );

                m_pShaderAsm->EmitInstruction(
                    CInstruction( D3D10_SB_OPCODE_ADD,
                                  CTempOperandDst( SYS_REG0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Y ),
                                  this->CreateInputSrcOperand( 2, posReg, __SWIZZLE_Y ),
                                  CNegate( this->CreateInputSrcOperand( 0, posReg, __SWIZZLE_Y ) ) ) );

                m_pShaderAsm->EmitInstruction(
                    CInstruction( D3D10_SB_OPCODE_MUL,
                                  CTempOperandDst( SYS_REG0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Z ),
                                  CTempOperand4( SYS_REG0, __SWIZZLE_X ),
                                  CTempOperand4( SYS_REG0, __SWIZZLE_Y ) ) );

                m_pShaderAsm->EmitInstruction(
                    CInstruction( D3D10_SB_OPCODE_ADD,
                                  CTempOperandDst( SYS_REG0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                                  this->CreateInputSrcOperand( 2, posReg, __SWIZZLE_X ),
                                  CNegate( this->CreateInputSrcOperand( 0, posReg, __SWIZZLE_X ) ) ) );

                m_pShaderAsm->EmitInstruction(
                    CInstruction( D3D10_SB_OPCODE_ADD,
                                  CTempOperandDst( SYS_REG0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Y ),
                                  this->CreateInputSrcOperand( 1, posReg, __SWIZZLE_Y ),
                                  CNegate( this->CreateInputSrcOperand( 0, posReg, __SWIZZLE_Y ) ) ) );

                m_pShaderAsm->EmitInstruction(
                    CInstruction( D3D10_SB_OPCODE_MAD,
                                  CTempOperandDst( SYS_REG0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                                  CTempOperand4( SYS_REG0, __SWIZZLE_X ),
                                  CTempOperand4( SYS_REG0, __SWIZZLE_Y ),
                                  CNegate( CTempOperand4( SYS_REG0, __SWIZZLE_Z ) ) ) );
            }
            else
            {
                // Calculate backface culling
                // sign = ( w0 * ( x1 * y2 - x2 * y1 ) -
                //          w1 * ( x0 * y2 - x2 * y0 ) +
                //          w2 * ( x0 * y1 - x1 * y0 ) );
                // if ( sign < 0 ) => "is front face"

                m_pShaderAsm->EmitInstruction(
                    CInstruction( D3D10_SB_OPCODE_MUL,
                                  CTempOperandDst( SYS_REG0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                                  this->CreateInputSrcOperand( 1, posReg, __SWIZZLE_X ),
                                  this->CreateInputSrcOperand( 2, posReg, __SWIZZLE_Y ) ) );

                m_pShaderAsm->EmitInstruction(
                    CInstruction( D3D10_SB_OPCODE_MUL,
                                  CTempOperandDst( SYS_REG0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Y ),
                                  this->CreateInputSrcOperand( 2, posReg, __SWIZZLE_X ),
                                  this->CreateInputSrcOperand( 1, posReg, __SWIZZLE_Y ) ) );

                m_pShaderAsm->EmitInstruction(
                    CInstruction( D3D10_SB_OPCODE_MUL,
                                  CTempOperandDst( SYS_REG1, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                                  this->CreateInputSrcOperand( 0, posReg, __SWIZZLE_X ),
                                  this->CreateInputSrcOperand( 2, posReg, __SWIZZLE_Y ) ) );

                m_pShaderAsm->EmitInstruction(
                    CInstruction( D3D10_SB_OPCODE_MUL,
                                  CTempOperandDst( SYS_REG1, D3D10_SB_OPERAND_4_COMPONENT_MASK_Y ),
                                  this->CreateInputSrcOperand( 2, posReg, __SWIZZLE_X ),
                                  this->CreateInputSrcOperand( 0, posReg, __SWIZZLE_Y ) ) );

                m_pShaderAsm->EmitInstruction(
                    CInstruction( D3D10_SB_OPCODE_MUL,
                                  CTempOperandDst( SYS_REG2, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                                  this->CreateInputSrcOperand( 0, posReg, __SWIZZLE_X ),
                                  this->CreateInputSrcOperand( 1, posReg, __SWIZZLE_Y ) ) );

                m_pShaderAsm->EmitInstruction(
                    CInstruction( D3D10_SB_OPCODE_MUL,
                                  CTempOperandDst( SYS_REG2, D3D10_SB_OPERAND_4_COMPONENT_MASK_Y ),
                                  this->CreateInputSrcOperand( 1, posReg, __SWIZZLE_X ),
                                  this->CreateInputSrcOperand( 0, posReg, __SWIZZLE_Y ) ) );

                m_pShaderAsm->EmitInstruction(
                    CInstruction( D3D10_SB_OPCODE_ADD,
                                  CTempOperandDst( SYS_REG0, D3D10_SB_OPERAND_4_COMPONENT_MASK_Z ),
                                  CTempOperand4( SYS_REG0, __SWIZZLE_X ),
                                  CNegate( CTempOperand4( SYS_REG0, __SWIZZLE_Y ) ) ) );

                m_pShaderAsm->EmitInstruction(
                    CInstruction( D3D10_SB_OPCODE_ADD,
                                  CTempOperandDst( SYS_REG1, D3D10_SB_OPERAND_4_COMPONENT_MASK_Z ),
                                  CTempOperand4( SYS_REG1, __SWIZZLE_X ),
                                  CNegate( CTempOperand4( SYS_REG1, __SWIZZLE_Y ) ) ) );
                m_pShaderAsm->EmitInstruction(
                    CInstruction( D3D10_SB_OPCODE_ADD,
                                  CTempOperandDst( SYS_REG2, D3D10_SB_OPERAND_4_COMPONENT_MASK_Z ),
                                  CTempOperand4( SYS_REG2, __SWIZZLE_X ),
                                  CNegate( CTempOperand4( SYS_REG2, __SWIZZLE_Y ) ) ) );

                m_pShaderAsm->EmitInstruction(
                    CInstruction( D3D10_SB_OPCODE_MUL,
                                  CTempOperandDst( SYS_REG0, D3D10_SB_OPERAND_4_COMPONENT_MASK_W ),
                                  this->CreateInputSrcOperand( 1, posReg, __SWIZZLE_W ),
                                  CTempOperand4( SYS_REG1, __SWIZZLE_Z ) ) );

                m_pShaderAsm->EmitInstruction(
                    CInstruction( D3D10_SB_OPCODE_MAD,
                                  CTempOperandDst( SYS_REG0, D3D10_SB_OPERAND_4_COMPONENT_MASK_W ),
                                  this->CreateInputSrcOperand( 0, posReg, __SWIZZLE_W ),
                                  CTempOperand4( SYS_REG0, __SWIZZLE_Z ),
                                  CNegate( CTempOperand4( SYS_REG0, __SWIZZLE_W ) ) ) );

                m_pShaderAsm->EmitInstruction(
                    CInstruction( D3D10_SB_OPCODE_MAD,
                                  CTempOperandDst( SYS_REG0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                                  this->CreateInputSrcOperand( 2, posReg, __SWIZZLE_W ),
                                  CTempOperand4( SYS_REG2, __SWIZZLE_Z ),
                                  CTempOperand4( SYS_REG0, __SWIZZLE_W ) ) );
            }

            m_pShaderAsm->EmitInstruction(
                CInstruction( D3D10_SB_OPCODE_LT,
                              CTempOperandDst( SYS_REG0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                              CTempOperand4( SYS_REG0, __SWIZZLE_X ),
                              COperand( 0.0f ) ) );

            for ( UINT i = 0; i < 4; ++i )
            {
                m_pShaderAsm->EmitInstruction(
                    CInstruction( D3D10_SB_OPCODE_MOVC,
                                  COperandDst( D3D10_SB_OPERAND_TYPE_TEMP, SYS_PSCALE0 + i, __WRITEMASK_XY ),
                                  CTempOperand4( SYS_REG0, __SWIZZLE_X ),
                                  COperand( vPointScaleCW[i][0], vPointScaleCW[i][1], 0.0f, 0.0f ),
                                  COperand( vPointScaleCCW[i][0], vPointScaleCCW[i][1], 0.0f, 0.0f ) ) );
            }
        }

        for ( UINT primitive = 0; primitive < uiPrimitiveSize; ++primitive )
        {
            if ( gsOutputDecls.PointSize )
            {
                // max r0.x, i_pts.swizzle, cb3[pointsize].y
                // min r0.x, r0.x, cb3[pointsize].z

                m_pShaderAsm->EmitInstruction(
                    CInstruction( D3D10_SB_OPCODE_MAX,
                                  CTempOperandDst( SYS_REG0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                                  this->CreateInputSrcOperand( primitive, psizeReg, psizeSwizzle ),
                                  CCBOperand2D( CB_VS_EXT,
                                                VSCBExtension::POINTSIZE,
                                                __SWIZZLE_Y ) ) );

                m_pShaderAsm->EmitInstruction(
                CInstruction( D3D10_SB_OPCODE_MIN,
                              CTempOperandDst( SYS_REG0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                              CTempOperand4( SYS_REG0, __SWIZZLE_X ),
                              CCBOperand2D( CB_VS_EXT,
                                            VSCBExtension::POINTSIZE,
                                            __SWIZZLE_Z ) ) );
            }
            else
            {
                // mov r0.x, cb3[pointsize].x

                m_pShaderAsm->EmitInstruction(
                    CInstruction( D3D10_SB_OPCODE_MOV,
                                  CTempOperandDst( SYS_REG0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                                  CCBOperand2D( CB_VS_EXT,
                                                VSCBExtension::POINTSIZE,
                                                __SWIZZLE_X ) ) );
            }

            if ( hasTLVertices )
            {
                // mul r0.xy, r0.x, 0.5f
                m_pShaderAsm->EmitInstruction(
                CInstruction( D3D10_SB_OPCODE_MUL,
                              CTempOperandDst( SYS_REG0, __WRITEMASK_XY ),
                              CTempOperand4( SYS_REG0, __SWIZZLE_X ),
                              COperand( 0.5f ) ) );
            }
            else
            {
                // Convert the point size from screen to clip space
                // The divide by 2 is consumed inside cb3[viewportscale].
                // mul r0.x, r0.x, t_pos.w
                // mul r0.xy, r0.x, cb3[viewportscale].xy

                m_pShaderAsm->EmitInstruction(
                    CInstruction( D3D10_SB_OPCODE_MUL,
                                  CTempOperandDst( SYS_REG0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                                  CTempOperand4( SYS_REG0, __SWIZZLE_X ),
                                  this->CreateInputSrcOperand( primitive, posReg, __SWIZZLE_W ) ) );

                m_pShaderAsm->EmitInstruction(
                    CInstruction( D3D10_SB_OPCODE_MUL,
                                  CTempOperandDst( SYS_REG0, __WRITEMASK_XY ),
                                  CTempOperand4( SYS_REG0, __SWIZZLE_X ),
                                  CCBOperand2D( CB_VS_EXT, VSCBExtension::VIEWPORTSCALE, __SWIZZLE_XY ) ) );
            }

            for ( UINT v = 0; v < 4; ++v )
            {
                BYTE tempRegs = m_uiNumTempRegs;
                const BYTE tempRegPos = tempRegs++;

                if ( isPointFillEnable )
                {
                    // mad o_pos.xy, r0.xy, pscale[v], i_pos.xy
                    m_pShaderAsm->EmitInstruction(
                        CInstruction( D3D10_SB_OPCODE_MAD,
                                      this->CreateInputDstOperand( tempRegPos, primitive, posReg.Reg(), __WRITEMASK_XY ),
                                      CTempOperand4( SYS_REG0, __SWIZZLE_XY ),
                                      CTempOperand4( SYS_PSCALE0 + v, __SWIZZLE_XY ),
                                      COperand2DEx( D3D10_SB_OPERAND_TYPE_INPUT, primitive, posReg.Reg(), __SWIZZLE_XY ) ) );
                }
                else
                {
                    // mad o_pos.xy, r0.xy, scalecw, i_pos.xy
                    m_pShaderAsm->EmitInstruction(
                        CInstruction( D3D10_SB_OPCODE_MAD,
                                      this->CreateInputDstOperand( tempRegPos, primitive, posReg.Reg(), __WRITEMASK_XY ),
                                      CTempOperand4( SYS_REG0, __SWIZZLE_XY ),
                                      COperand( vPointScaleCW[v][0], vPointScaleCW[v][1], 0.0f, 0.0f ),
                                      COperand2DEx( D3D10_SB_OPERAND_TYPE_INPUT, primitive, posReg.Reg(), __SWIZZLE_XY ) ) );
                }

                // mov o_pos.zw, t_pos
                m_pShaderAsm->EmitInstruction(
                        CInstruction( D3D10_SB_OPCODE_MOV,
                                      this->CreateInputDstOperand( tempRegPos, primitive, posReg.Reg(), __WRITEMASK_ZW ),
                                      COperand2DEx( D3D10_SB_OPERAND_TYPE_INPUT, primitive, posReg.Reg() ) ) );

                if ( userClipPlanes )
                {
                    // Output user-defined clipplane distances
                    this->WriteClipplanes( userClipPlanes, this->CreateInputSrcOperand( primitive, posReg ) );
                }

                // Write to output registers
                for ( UINT i = 0; i < uiInputDeclSize; ++i )
                {
                    const UINT usage     = gsOutputDecls[i].Usage;
                    const InputRegister regIndex(gsOutputDecls[i].RegIndex, InputRegister::Input, gsOutputDecls[i].WriteMask);
                    const UINT writeMask = gsOutputDecls[i].WriteMask << D3D10_SB_OPERAND_4_COMPONENT_MASK_SHIFT;

                    if (isFlatColorFillEnable
                     && (D3DDECLUSAGE_COLOR == usage))
                    {
                        // Copy primitive 0 color data
                        m_pShaderAsm->EmitInstruction(
                            CInstruction( D3D10_SB_OPCODE_MOV,
                                          COperandDst( D3D10_SB_OPERAND_TYPE_OUTPUT, regIndex.Reg(), writeMask ),
                                          this->CreateInputSrcOperand( 0, regIndex ) ) );
                    }
                    else if (usage == D3DDECLUSAGE_POINTSPRITE)
                    {
                        SHADER_CONV_ASSERT(isPointSpriteEnable);
                        const float vTexCoords[4][2] = {
                            { 0.0f, 0.0f },
                            { 1.0f, 0.0f },
                            { 0.0f, 1.0f },
                            { 1.0f, 1.0f },
                        };

                        // Ouput pointsprite texture coordinates
                        m_pShaderAsm->EmitInstruction(
                            CInstruction(D3D10_SB_OPCODE_MOV,
                                COperandDst(D3D10_SB_OPERAND_TYPE_OUTPUT, VSOREG_PointSprite, D3D10_SB_OPERAND_4_COMPONENT_MASK_ALL),
                                COperand(vTexCoords[v][0], vTexCoords[v][1], 0.0f, 1.0f)));
                    }
                    else if (usage == D3DDECLUSAGE_CLIPDISTANCE)
                    {
                        // Do nothing, already handled by WriteClipPlanes
                    }
                    else // Do not output the pointsize register
                    if (usage != D3DDECLUSAGE_PSIZE)
                    {
                        m_pShaderAsm->EmitInstruction(
                            CInstruction( D3D10_SB_OPCODE_MOV,
                                          COperandDst( D3D10_SB_OPERAND_TYPE_OUTPUT, regIndex.Reg(), writeMask ),
                                          this->CreateInputSrcOperand( primitive, regIndex ) ) );
                    }
                }

                m_pShaderAsm->Emit( D3D10_SB_OPCODE_EMIT );
            }

            m_pShaderAsm->Emit( D3D10_SB_OPCODE_CUT );
        }
    }
    else
    {
        const InputRegister posReg(m_positionDecl.RegIndex, InputRegister::Input, m_positionDecl.WriteMask);

        for ( UINT primitive = 0; primitive < uiPrimitiveSize; ++primitive )
        {
            if ( userClipPlanes )
            {
                // Output user-defined clipplane distances
                this->WriteClipplanes( userClipPlanes, this->CreateInputSrcOperand( primitive, posReg ) );
            }

            // Write to output registers
            for ( UINT i = 0; i < uiInputDeclSize; ++i )
            {
                const UINT usage      = gsOutputDecls[i].Usage;
                const UINT usageIndex = gsOutputDecls[i].UsageIndex;
                const InputRegister regIndex(gsOutputDecls[i].RegIndex, InputRegister::Input, gsOutputDecls[i].WriteMask);
                const UINT writeMask  = gsOutputDecls[i].WriteMask << D3D10_SB_OPERAND_4_COMPONENT_MASK_SHIFT;

                if ((D3DDECLUSAGE_TEXCOORD == usage)
                 && isTextureWrapEnable
                 && (primitive > 0))
                {
                    this->EmitTexWrap( primitive, usageIndex, regIndex);
                }
                else
                if (usage != D3DDECLUSAGE_PSIZE)
                {
                    m_pShaderAsm->EmitInstruction(
                        CInstruction( D3D10_SB_OPCODE_MOV,
                                      COperandDst( D3D10_SB_OPERAND_TYPE_OUTPUT, regIndex.Reg(), writeMask ),
                                      this->CreateInputSrcOperand( primitive, regIndex ) ) );
                }
            }

            m_pShaderAsm->Emit( D3D10_SB_OPCODE_EMIT );
        }
    }
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CGSContext::EmitTexWrap(
    UINT primitive,
    UINT usageIndex,
    const InputRegister &regIndex)
{
    UINT swizzle = 0;
    UINT origWriteMask = regIndex.WriteMask() << D3D10_SB_OPERAND_4_COMPONENT_MASK_SHIFT;
    UINT writeMask = 0;

    const UINT textureWrap = m_pShaderDesc->GetTextureWrap( usageIndex );

    if ( origWriteMask & D3D10_SB_OPERAND_4_COMPONENT_MASK_X )
    {
        if ( textureWrap & D3DWRAPCOORD_0 )
        {
            writeMask |= D3D10_SB_OPERAND_4_COMPONENT_MASK_X;
            swizzle |= __SWIZZLEN( 0, D3D10_SB_4_COMPONENT_X );
        }
    }

    if ( origWriteMask & D3D10_SB_OPERAND_4_COMPONENT_MASK_Y )
    {
        if ( textureWrap & D3DWRAPCOORD_1 )
        {
            writeMask |= D3D10_SB_OPERAND_4_COMPONENT_MASK_Y;
            swizzle |= __SWIZZLEN( 1, D3D10_SB_4_COMPONENT_Y );
        }
    }

    if ( origWriteMask & D3D10_SB_OPERAND_4_COMPONENT_MASK_Z )
    {
        if ( textureWrap & D3DWRAPCOORD_2 )
        {
            writeMask |= D3D10_SB_OPERAND_4_COMPONENT_MASK_Z;
            swizzle |= __SWIZZLEN( 2, D3D10_SB_4_COMPONENT_Z );
        }
    }

    if ( origWriteMask & D3D10_SB_OPERAND_4_COMPONENT_MASK_W )
    {
        if ( textureWrap & D3DWRAPCOORD_3 )
        {
            writeMask |= D3D10_SB_OPERAND_4_COMPONENT_MASK_W;
            swizzle |= __SWIZZLEN( 3, D3D10_SB_4_COMPONENT_W );
        }
    }

    // mov  out, t[p]
    // add  r0.writemask, t[p].swizzle, -t[0].swizzle
    // add  r1.writemask, r0.swizzle, vec4(1.0f)
    // add  r2.writemask, r0.swizzle, vec4(-1.0f)
    // lt   r3.writemask, r0.swizzle, vec4(0.0f)
    // movc r1.writemask, r3.swizzle, r1.swizzle, r2.swizzle
    // lt   r3.writemask, abs( r0.swizzle ), abs( r1.swizzle )
    // movc r0.writemask, r3.swizzle, r0.swizzle, r1.swizzle
    // add  out.writemask, r0.swizzle, t[0].swizzle

    if (writeMask)
    {
        m_pShaderAsm->EmitInstruction(
            CInstruction(D3D10_SB_OPCODE_ADD,
                CTempOperandDst(SYS_REG0, writeMask),
                this->CreateInputSrcOperand(primitive, regIndex, swizzle),
                CNegate(this->CreateInputSrcOperand(0, regIndex, swizzle))));

        m_pShaderAsm->EmitInstruction(
            CInstruction(D3D10_SB_OPCODE_ADD,
                CTempOperandDst(SYS_REG1, writeMask),
                CTempOperand4(SYS_REG0, swizzle),
                COperand(1.0f)));

        m_pShaderAsm->EmitInstruction(
            CInstruction(D3D10_SB_OPCODE_ADD,
                CTempOperandDst(SYS_REG2, writeMask),
                CTempOperand4(SYS_REG0, swizzle),
                COperand(-1.0f)));

        m_pShaderAsm->EmitInstruction(
            CInstruction(D3D10_SB_OPCODE_LT,
                CTempOperandDst(SYS_REG3, writeMask),
                CTempOperand4(SYS_REG0, swizzle),
                COperand(0.0f)));

        m_pShaderAsm->EmitInstruction(
            CInstruction(D3D10_SB_OPCODE_MOVC,
                CTempOperandDst(SYS_REG1, writeMask),
                CTempOperand4(SYS_REG3, swizzle),
                CTempOperand4(SYS_REG1, swizzle),
                CTempOperand4(SYS_REG2, swizzle)));

        m_pShaderAsm->EmitInstruction(
            CInstruction(D3D10_SB_OPCODE_LT,
                CTempOperandDst(SYS_REG3, writeMask),
                CAbs(CTempOperand4(SYS_REG0, swizzle)),
                CAbs(CTempOperand4(SYS_REG1, swizzle))));

        m_pShaderAsm->EmitInstruction(
            CInstruction(D3D10_SB_OPCODE_MOVC,
                CTempOperandDst(SYS_REG0, writeMask),
                CTempOperand4(SYS_REG3, swizzle),
                CTempOperand4(SYS_REG0, swizzle),
                CTempOperand4(SYS_REG1, swizzle)));

        m_pShaderAsm->EmitInstruction(
            CInstruction(D3D10_SB_OPCODE_ADD,
                COperandDst(D3D10_SB_OPERAND_TYPE_OUTPUT, regIndex.Reg(), writeMask),
                CTempOperand4(SYS_REG0, swizzle),
                this->CreateInputSrcOperand(0, regIndex, swizzle)));
    }

    if ( origWriteMask != writeMask )
    {
        // Need to copy the remaining components
        const UINT writeMaskDiff = writeMask ^ origWriteMask;
        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_MOV,
                          COperandDst( D3D10_SB_OPERAND_TYPE_OUTPUT, regIndex.Reg(), writeMaskDiff ),
                          this->CreateInputSrcOperand( primitive, regIndex ) ) );
    }
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
COperandBase
CGSContext::CreateInputSrcOperand( UINT primitive, const InputRegister &inputReg, UINT swizzle )
{
    if (!swizzle)
    {
        swizzle = __swizzleFromWriteMask(inputReg.WriteMask() << D3D10_SB_OPERAND_4_COMPONENT_MASK_SHIFT);
    }

    if ( m_tempRegs[primitive][inputReg.Reg()] != INVALID_INDEX )
    {
        return CTempOperand4( m_tempRegs[primitive][inputReg.Reg()], swizzle );
    }
    else
    {
        return COperand2DEx( D3D10_SB_OPERAND_TYPE_INPUT, primitive, inputReg.Reg(), swizzle );
    }
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
COperandBase
CGSContext::CreateInputDstOperand( BYTE tempRegIndex, UINT primitive, UINT regIndex, UINT writeMask )
{
    if ( INVALID_INDEX == m_tempRegs[primitive][regIndex] )
    {
        m_tempRegs[primitive][regIndex] = tempRegIndex;
    }

    return CTempOperandDst( m_tempRegs[primitive][regIndex], writeMask );
}

} // namespace ShaderConv

```

`ShaderConverter/ShaderConv/pch.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/*==========================================================================;
*
*  Copyright (C) Microsoft Corporation.  All rights reserved.
*
*  Precompiled header file
*
****************************************************************************/
#pragma once

//
// Disable optimize for speed and instead optimize for size in this library
//
#pragma optimize ("s", on)
#pragma optimize ("t", off)
#undef WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <atlbase.h>
#include <strsafe.h>
#include <ShaderConvCommon.h>

#pragma warning(push, 3)
#include <d3d9.h>
#include <d3dhal.h>
#define _d3d9TYPES_H_    // Fix d3d9 types redefinitions errors in d3d10umddi.h
#define D3D12_TOKENIZED_PROGRAM_FORMAT_HEADER
#include <d3d10umddi.h>
#pragma warning(pop)

#include <math.h>

#include <ShaderBinary.h>

#include "ShaderBinaryEx.hpp"
#include "disasm.hpp"

#include <vector>


```

`ShaderConverter/ShaderConv/psconv.cpp`:

```cpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/*==========================================================================;
*
*  Copyright (C) Microsoft Corporation.  All Rights Reserved.
*
*  Implementation for The Pixel Shader Converter
*
****************************************************************************/

#include "pch.h"
#include "context.hpp"

namespace ShaderConv
{

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
HRESULT
CPixelShaderDesc::Create( CPixelShaderDesc** ppPixelShaderDesc )
{
    SHADER_CONV_ASSERT( ppPixelShaderDesc );

    CPixelShaderDesc* const pPixelShaderDesc = new CPixelShaderDesc();
    if ( NULL == pPixelShaderDesc )
    {
        SHADER_CONV_ASSERT(FALSE);
        return E_OUTOFMEMORY;
    }

    pPixelShaderDesc->AddRef();
    *ppPixelShaderDesc = pPixelShaderDesc;

    return S_OK;
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
HRESULT
CPixelShaderDesc::UpdateInputDecls( 
    const VSOutputDecls& vsOuputDecls,
    const ShaderConv::RasterStates& rasterStates,
    VSOutputDecls* pMergedDecls
    )
{
    SHADER_CONV_ASSERT(pMergedDecls);

    // Obtain the current TCI mapping (ignored for PS3.0)
    const UINT uiTCIMapping = m_version < D3DPS_VERSION(3,0) ?
        rasterStates.TCIMapping : TCIMASK_PASSTHRU;

    // Check if point sprite processing is enabled
    const bool bPointSpriteEnabled = rasterStates.PointSpriteEnable 
                                  && ((D3DPT_POINTLIST == rasterStates.PrimitiveType) 
                                   || (D3DFILL_POINT == rasterStates.FillMode));

    BYTE positionRegister = (BYTE)vsOuputDecls.FindRegisterIndex(D3DDECLUSAGE_POSITION, 0);
    SHADER_CONV_ASSERT(positionRegister != VSOutputDecls::INVALID_INDEX);
    SetPositionRegister(positionRegister);

    // Copy the current input declarion
    *pMergedDecls = m_inputDecls;

    const UINT nNumMergedDecls = pMergedDecls->GetSize();
    const UINT nNumInputDecls  = vsOuputDecls.GetSize();

    for (UINT i = 0; i < nNumMergedDecls; ++i)
    {
        const UINT usage = (*pMergedDecls)[i].Usage;
        UINT usageIndex = (*pMergedDecls)[i].UsageIndex;

        // Skip VPOS and VFACE input registers
        // since they are not produced by the vertex shader
        if (usage <= D3DDECLUSAGE_SAMPLE)
        {
            if (D3DDECLUSAGE_TEXCOORD == usage)
            {
                if (bPointSpriteEnabled 
                 && ((m_version < D3DPS_VERSION(2,0)) 
                  || (0 == usageIndex)))
                {
                    // Pointsprite generated texture coordinates map to VSOREG_TexCoord0
                    const BYTE regIndexIn = (*pMergedDecls)[i].RegIndex;
                    (*pMergedDecls)[i].RegIndex  = VSOREG_PointSprite;
                    (*pMergedDecls)[i].WriteMask = D3DSP_WRITEMASK_ALL >> __D3DSP_WRITEMASK_SHIFT;
                    SHADER_CONV_ASSERT(regIndexIn < _countof(m_inputRegs.v));
                    m_inputRegs.v[regIndexIn] = InputRegister(VSOREG_PointSprite, InputRegister::Input, (*pMergedDecls)[i].WriteMask);
                    continue;
                }

                if (uiTCIMapping != TCIMASK_PASSTHRU)
                {
                    // Compute the new usage index from TCI mask
                    usageIndex = (uiTCIMapping >> (4 * usageIndex)) & 0xf;
                }
            }

            const VSOutputDecl *pOutputDecl = vsOuputDecls.FindOutputDecl(usage, usageIndex);
            if (pOutputDecl)
            {
                const BYTE regIndexIn = (*pMergedDecls)[i].RegIndex;
                (*pMergedDecls)[i].RegIndex = pOutputDecl->RegIndex;
                (*pMergedDecls)[i].WriteMask = pOutputDecl->WriteMask;
                SHADER_CONV_ASSERT(regIndexIn < _countof(m_inputRegs.v));
                m_inputRegs.v[regIndexIn] = InputRegister(pOutputDecl->RegIndex, InputRegister::Input, (*pMergedDecls)[i].WriteMask);
            }
            else
            {
                // The input register could not be found, 
                // clear its writemask and input register
                (*pMergedDecls)[i].WriteMask = 0;
                const BYTE regIndexIn = (*pMergedDecls)[i].RegIndex;                
                SHADER_CONV_ASSERT(regIndexIn < _countof(m_inputRegs.v));
                m_inputRegs.v[regIndexIn] = InputRegister(INVALID_INDEX, InputRegister::Undeclared, (*pMergedDecls)[i].WriteMask);
                continue;
            }
        }
        else if(D3DDECLUSAGE_VPOS == usage && usageIndex == 0)
        {
            // Patch VPOS to use the position register declared by the Vertex Shader
            (*pMergedDecls)[i].RegIndex = positionRegister;
        }
    }

    // Resolve pixel fog extension
    if (rasterStates.FogEnable)
    {
        // Check if the input fog or specular is available
        if (vsOuputDecls.Fog 
        ||  (vsOuputDecls.Colors & 0x2))
        {
            UINT uiFogInputDcl      = VSOutputDecls::INVALID_INDEX;
            UINT uiSpecularInputDcl = VSOutputDecls::INVALID_INDEX;

            for (UINT j = 0; j < nNumInputDecls; ++j)
            {
                const VSOutputDecl ouputDecl = vsOuputDecls[j];
                if (D3DDECLUSAGE_FOG == ouputDecl.Usage)
                {                  
                    uiFogInputDcl = j;
                }
                else
                if ((D3DDECLUSAGE_COLOR == ouputDecl.Usage) 
                 && (1 == ouputDecl.UsageIndex))
                {                  
                    uiSpecularInputDcl = j;
                }
            }

            if (uiFogInputDcl != VSOutputDecls::INVALID_INDEX)
            {
                pMergedDecls->AddDecl(vsOuputDecls[uiFogInputDcl]);
            }
            else
            {
                SHADER_CONV_ASSERT(uiSpecularInputDcl != VSOutputDecls::INVALID_INDEX);
                pMergedDecls->AddDecl(vsOuputDecls[uiSpecularInputDcl]);
            }
        }
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
HRESULT
CTranslator::AnalyzePS( const void* pSrcBytes,
                        UINT cbCodeSize,
                        UINT shaderSettings,
                        const RasterStates& rasterStates,
                        CPixelShaderDesc** ppShaderDesc )
{
    HRESULT hr;

    if ( NULL == pSrcBytes ||
         NULL == ppShaderDesc )
    {
        SHADER_CONV_ASSERT(!"CTranslator::AnalyzePS() failed, invalid parameters\n");
        return E_INVALIDARG;
    }

    // Get the shader version
    const DWORD* const pdwCodeBytes = reinterpret_cast<const DWORD*>( pSrcBytes );
    const DWORD dwVersion = *pdwCodeBytes;

    // Validate supported shader versions
    switch ( dwVersion )
    {
    case D3DPS_VERSION(1,0):
    case D3DPS_VERSION(1,1):
    case D3DPS_VERSION(1,2):
    case D3DPS_VERSION(1,3):
    case D3DPS_VERSION(1,4):
    case D3DPS_VERSION(2,0):
    case D3DPS_VERSION(2,1):
    case D3DPS_VERSION(3,0):
        break;

    default:
        SHADER_CONV_ASSERT(!"CTranslator::AnalyzePS() failed, shader version not supported: 0x%x\n");
        return E_INVALIDARG;
    }

#if DBG && WARP_INTERNAL
    // Disassemble input the shader code to the debug output
    hr = Disasm20( pdwCodeBytes, 0 );
    if ( FAILED( hr ) )
    {
        SHADER_CONV_ASSERT(!"Disasm20() failed, hr = %d\n");
        return hr;
    }

#endif

    VSOutputDecls inputDecls;
    InputRegs      inputRegs;
    OutputRegs      outputRegs;
    PSUsageFlags  usageFlags;

    UINT minUsedConstantsF = 0xFFFFFFFF;
    UINT minUsedConstantsI = 0xFFFFFFFF;
    UINT minUsedConstantsB = 0xFFFFFFFF;

    UINT maxUsedConstantsF = 0;
    UINT maxUsedConstantsI = 0;
    UINT maxUsedConstantsB = 0;

    bool hasRelativeAddressF = false;

    BYTE ubNumTempRegs = SREG_SIZE;
    BYTE uiNumLoopRegs = 0;

    // Determine if inline shader constants is supported (only available to Dx9 and above)
    const bool bInlineConstsEnabled = (m_runtimeVersion >= 9);

    // Create the shader descriptor
    CPixelShaderDesc* pShaderDesc;
    hr = CPixelShaderDesc::Create( &pShaderDesc );
    if ( FAILED( hr ) )
    {
        SHADER_CONV_ASSERT(FALSE);
        return hr;
    }

    // TODO: This looks like it's allocating sizeof(DWORD) times to many arrays
    // Allocate instructions buffer
    DWORD* pdwInstrs = new DWORD[cbCodeSize];
    if ( NULL == pdwInstrs )
    {
        hr = E_OUTOFMEMORY;
        goto L_ERROR;
    }

    DWORD* pdwCurInstr = pdwInstrs;
    *pdwCurInstr++ = dwVersion;

    //
    // Parse the shader to find the input and output registers
    //

    const DWORD* pdwCurToken = pdwCodeBytes + 1;
    while ( *pdwCurToken != D3DPS_END() )
    {
        if ( static_cast<UINT>( reinterpret_cast<const BYTE*>( pdwCurToken ) -
                                reinterpret_cast<const BYTE*>( pdwCodeBytes ) ) > cbCodeSize )
        {
            SHADER_CONV_ASSERT(!"CTranslator::AnalyzePS() failed, invalid shader\n");
            hr = E_FAIL;
            goto L_ERROR;
        }

        const DWORD dwInstr = *pdwCurToken;
        const UINT uiLength = __getInstrLength( dwInstr, dwVersion );
        const D3DSHADER_INSTRUCTION_OPCODE_TYPE opCode =
            (D3DSHADER_INSTRUCTION_OPCODE_TYPE)( dwInstr & D3DSI_OPCODE_MASK );

        switch ( opCode )
        {
        case D3DSIO_COMMENT:
        case D3DSIO_NOP:
            pdwCurToken += uiLength;
            continue;

        case D3DSIO_DCL:
            {
                const DWORD dwDclDesc = pdwCurToken[1];
                const DWORD dwDclReg  = pdwCurToken[2];
                const DWORD dwRegNum  = D3DSI_GETREGNUM( dwDclReg );
                const D3DSHADER_PARAM_REGISTER_TYPE regType = D3DSI_GETREGTYPE( dwDclReg );

                switch ( regType )
                {
                case D3DSPR_INPUT:
                    if ( dwVersion >= D3DPS_VERSION(3,0) )
                    {
                        // Generic input registers declaration
                        const UINT usage       = (D3DDECLUSAGE)D3DSI_GETUSAGE( dwDclDesc );
                        const UINT usageIndex  = D3DSI_GETUSAGEINDEX( dwDclDesc );
                        const UINT writeMask   = D3DSI_GETWRITEMASK( dwDclReg );
                        const bool bDoCentroid = ( ( D3DSPDM_MSAMPCENTROID & dwDclReg ) ? true : false ) || ( D3DDECLUSAGE_COLOR == usage );
                        inputDecls.AddDecl( usage, usageIndex, dwRegNum, writeMask, bDoCentroid );
                    }
                    else
                    {
                        // Input color register declaration
                        inputDecls.AddDecl( D3DDECLUSAGE_COLOR, dwRegNum, VSOREG_Color0 + dwRegNum, D3DSP_WRITEMASK_ALL );
                    }
                    break;

                case D3DSPR_TEXTURE:
                    {
                        // Input texture coordinates register declaration
                        const bool bDoCentroid = ( D3DSPDM_MSAMPCENTROID & dwDclReg ) ? true : false;
                        inputDecls.AddDecl( D3DDECLUSAGE_TEXCOORD, dwRegNum, VSOREG_TexCoord0 + dwRegNum, D3DSP_WRITEMASK_ALL, bDoCentroid );
                    }
                    break;

                case D3DSPR_SAMPLER:
                    {
                        // Texture sampler declaration
                        SHADER_CONV_ASSERT( dwRegNum < MAX_PS_SAMPLER_REGS );
                        inputRegs.s[dwRegNum] = (BYTE)__toTextureType( (D3DSAMPLER_TEXTURE_TYPE)( dwDclDesc & D3DSP_TEXTURETYPE_MASK ) );
                    }
                    break;

                case D3DSPR_MISCTYPE:
                    // Miscaleneous input registers declaration
                    switch ( dwRegNum )
                    {
                    case D3DSMO_POSITION:
                        inputDecls.AddDecl( D3DDECLUSAGE_VPOS, 0, PSIREG_VPos, D3DSP_WRITEMASK_ALL);
                        inputRegs.v[PSIREG_VPos] = InputRegister(ubNumTempRegs++, InputRegister::Temp, inputDecls[inputDecls.GetSize() - 1].WriteMask);
                        break;

                    case D3DSMO_FACE:
                        inputDecls.AddDecl( D3DDECLUSAGE_VFACE, 0, PSIREG_VFace, D3DSP_WRITEMASK_0 );
                        inputRegs.v[PSIREG_VFace] = InputRegister(ubNumTempRegs++, InputRegister::Temp, inputDecls[inputDecls.GetSize() - 1].WriteMask);
                        break;

                    default:
                        SHADER_CONV_ASSERT(!"CTranslator::AnalyzeVS() failed, invalid register number: %d\n");
                        hr = E_FAIL;
                        goto L_ERROR;
                    }
                    break;

                default:
                    SHADER_CONV_ASSERT(!"CTranslator::AnalyzeVS() failed, invalid register type: %d\n");
                    hr = E_FAIL;
                    goto L_ERROR;
                }
                pdwCurToken += uiLength;
            }
            continue;

        case D3DSIO_DEF:
            {
                const DWORD dwRegNum = D3DSI_GETREGNUM_RESOLVING_CONSTANTS( pdwCurToken[1] );
                hr = pShaderDesc->AddInlineConstsF( dwRegNum, reinterpret_cast<const FLOAT*>( &pdwCurToken[2] ) );
                if ( FAILED( hr ) )
                {
                    SHADER_CONV_ASSERT(!"CShaderDesc::AddInlineConstsF() failed, hr = %d\n");
                    goto L_ERROR;
                }
                pdwCurToken += uiLength;
            }
            continue;

        case D3DSIO_DEFI:
            {
                const DWORD dwRegNum = D3DSI_GETREGNUM_RESOLVING_CONSTANTS( pdwCurToken[1] );
                hr = pShaderDesc->AddInlineConstsI( dwRegNum, reinterpret_cast<const INT*>( &pdwCurToken[2] ) );
                if ( FAILED( hr ) )
                {
                    SHADER_CONV_ASSERT(!"CShaderDesc::AddInlineConstsI() failed, hr = %d\n");
                    goto L_ERROR;
                }
                pdwCurToken += uiLength;
            }
            continue;

        case D3DSIO_DEFB:
            {
                const DWORD dwRegNum = D3DSI_GETREGNUM_RESOLVING_CONSTANTS( pdwCurToken[1] );
                hr = pShaderDesc->AddInlineConstsB( dwRegNum, pdwCurToken[2] );
                if ( FAILED( hr ) )
                {
                    SHADER_CONV_ASSERT(!"CShaderDesc::AddInlineConstsB() failed, hr = %d\n");
                    goto L_ERROR;
                }
                pdwCurToken += uiLength;
            }
            continue;
        }

        *pdwCurInstr++ = *pdwCurToken++;

        // Check if the intruction has parameters
        if ( *pdwCurToken & ( 1L << 31 ) )
        {
            // Parse destination parameter
            switch ( opCode )
            {
            case D3DSIO_REP:
            case D3DSIO_LOOP:

                // Allocate loop registers
                ++uiNumLoopRegs;

            case D3DSIO_CALL:
            case D3DSIO_CALLNZ:
            case D3DSIO_IF:
            case D3DSIO_IFC:
            case D3DSIO_BREAK:
            case D3DSIO_BREAKC:
            case D3DSIO_BREAKP:
            case D3DSIO_LABEL:
            case D3DSIO_TEXKILL:
                // No destination parameter
                break;

            case D3DSIO_BEM:
            case D3DSIO_TEXBEM:
            case D3DSIO_TEXBEML:
            case D3DSIO_TEX:
            case D3DSIO_TEXREG2AR:
            case D3DSIO_TEXREG2GB:
            case D3DSIO_TEXREG2RGB:
            case D3DSIO_TEXM3x2TEX:
            case D3DSIO_TEXM3x3TEX:
            case D3DSIO_TEXM3x3SPEC:
            case D3DSIO_TEXM3x3VSPEC:
            case D3DSIO_TEXM3x2DEPTH:
            case D3DSIO_TEXDP3TEX:
            case D3DSIO_TEXDEPTH:

                switch ( opCode )
                {
                case D3DSIO_TEXM3x2DEPTH:
                case D3DSIO_TEXDEPTH:
                    // These instructions implicitly write out to the depth register
                    outputRegs.oDepth = ubNumTempRegs++;
                    break;

                case D3DSIO_BEM:
                case D3DSIO_TEXBEM:
                case D3DSIO_TEXBEML:
                    // These instructions implicitely use bump environment materials
                    usageFlags.BumpEnvMat = 1;
                    if ( D3DSIO_BEM == opCode )
                    {
                        break;
                    }

                default:
                    if ( dwVersion < D3DPS_VERSION(2,0) )
                    {
                        // These instructions implicitly use texture resources & samplers
                        const DWORD dwRegNum = D3DSI_GETREGNUM( pdwCurToken[0] );
                        SHADER_CONV_ASSERT( dwRegNum < MAX_SAMPLER_REGS );
                        inputRegs.s[dwRegNum] = TEXTURETYPE_UNKNOWN;
                    }
                    break;
                }
                __fallthrough;

            default:

                const DWORD dwDstToken = *pdwCurToken++;
                *pdwCurInstr++ = dwDstToken;

                const DWORD dwRegNum = D3DSI_GETREGNUM( dwDstToken );
                const D3DSHADER_PARAM_REGISTER_TYPE regType = D3DSI_GETREGTYPE( dwDstToken );

                switch ( regType )
                {
                case D3DSPR_SAMPLER:
                    // Already processed in D3DSIO_DCL.
                    SHADER_CONV_ASSERT( inputRegs.s[dwRegNum] != INVALID_INDEX );
                    break;

                case D3DSPR_COLOROUT:
                    SHADER_CONV_ASSERT( dwRegNum < MAX_PS_COLOROUT_REGS );
                    if ( INVALID_INDEX == outputRegs.oC[dwRegNum] )
                    {
                        outputRegs.oC[dwRegNum] = ubNumTempRegs++;
                    }
                    break;

                case D3DSPR_DEPTHOUT:
                    if ( INVALID_INDEX == outputRegs.oDepth )
                    {
                        outputRegs.oDepth = ubNumTempRegs++;
                    }
                    break;

                case D3DSPR_TEMP:
                    SHADER_CONV_ASSERT( dwRegNum < MAX_PS_TEMP_REGS );
                    if ( INVALID_INDEX == inputRegs.r[dwRegNum] )
                    {
                        inputRegs.r[dwRegNum] = ubNumTempRegs++;
                    }

                    if ( 0 == dwRegNum &&
                         dwVersion < D3DPS_VERSION(2,0) &&
                         INVALID_INDEX == outputRegs.oC[0] )
                    {
                        // In PS 1.x, r0 is also used as the ouput color register
                        outputRegs.oC[0] = inputRegs.r[0];
                    }
                    break;

                case D3DSPR_PREDICATE:
                    if ( INVALID_INDEX == inputRegs.p0 )
                    {
                        inputRegs.p0 = ubNumTempRegs++;
                    }
                    break;

                case D3DSPR_TEXTURE:

                    switch ( opCode )
                    {
                    case D3DSIO_TEXM3x2PAD:
                    case D3DSIO_TEXM3x3PAD:
                        // These are speudo instructions use
                        // a system register for destination.
                        break;

                    default:
                        SHADER_CONV_ASSERT( dwVersion <= D3DPS_VERSION(1,3) );
                        SHADER_CONV_ASSERT( dwRegNum < MAX_PS1X_TEXTURE_REGS );
                        inputRegs._t[dwRegNum] = ubNumTempRegs++;
                        break;
                    }

                    switch ( opCode )
                    {
                    case D3DSIO_TEXCOORD:
                    case D3DSIO_TEX:
                    case D3DSIO_TEXM3x2PAD:
                    case D3DSIO_TEXM3x2TEX:
                    case D3DSIO_TEXM3x2DEPTH:
                    case D3DSIO_TEXM3x3PAD:
                    case D3DSIO_TEXM3x3:
                    case D3DSIO_TEXM3x3TEX:
                    case D3DSIO_TEXM3x3SPEC:
                    case D3DSIO_TEXM3x3VSPEC:
                    case D3DSIO_TEXDP3TEX:
                    case D3DSIO_TEXDP3:
                    case D3DSIO_TEXBEM:
                    case D3DSIO_TEXBEML:
                        // ps_1_x doesn't support dcl's, need to add it explicitly
                        if ( 0 == ( inputDecls.TexCoords & ( 1 << dwRegNum ) ) )
                        {
                            // Input texture coordinates register declaration
                            inputDecls.AddDecl( D3DDECLUSAGE_TEXCOORD, dwRegNum, VSOREG_TexCoord0 + dwRegNum, D3DSP_WRITEMASK_ALL );

                            // Enable texture coordinates custom projection
                            usageFlags.ProjectedTCsMask |= ( 1 << dwRegNum );
                        }
                        break;
                    }
                    break;

                default:
                    SHADER_CONV_ASSERT(!"CTranslator::AnalyzeVS() failed, invalid register type: %d\n");
                    hr = E_FAIL;
                    goto L_ERROR;
                }
            }

            // Skip the destination write predicate
            if ( dwInstr & D3DSHADER_INSTRUCTION_PREDICATED )
            {
                *pdwCurInstr++ = *pdwCurToken++;
            }

            // Parse source parameters
            while ( *pdwCurToken & ( 1L << 31 ) )
            {
                const DWORD dwSrcToken = *pdwCurToken++;
                *pdwCurInstr++ = dwSrcToken;

                const DWORD dwRegNum = D3DSI_GETREGNUM_RESOLVING_CONSTANTS( dwSrcToken );
                const D3DSHADER_PARAM_REGISTER_TYPE regType = D3DSI_GETREGTYPE_RESOLVING_CONSTANTS( dwSrcToken );
                const BOOL hasRelativeAddress = ( D3DSI_GETADDRESSMODE( dwSrcToken ) & D3DSHADER_ADDRMODE_RELATIVE );

                switch ( regType )
                {
                case D3DSPR_SAMPLER:
                    // Already processed in D3DSIO_DCL.
                    SHADER_CONV_ASSERT( dwRegNum < MAX_PS_SAMPLER_REGS );
                    SHADER_CONV_ASSERT( inputRegs.s[dwRegNum] != INVALID_INDEX );
                    break;

                case D3DSPR_TEMP:
                    SHADER_CONV_ASSERT( dwRegNum < MAX_PS_TEMP_REGS );
                    if ( INVALID_INDEX == inputRegs.r[dwRegNum] )
                    {
                        inputRegs.r[dwRegNum] = ubNumTempRegs++;
                    }
                    break;

                case D3DSPR_PREDICATE:
                    if ( INVALID_INDEX == inputRegs.p0 )
                    {
                        inputRegs.p0 = ubNumTempRegs++;
                    }
                    break;

                case D3DSPR_LABEL:
                case D3DSPR_MISCTYPE:
                    break;

                case D3DSPR_INPUT:
                    if ( dwVersion >= D3DPS_VERSION(3,0) )
                    {
                        if ( hasRelativeAddress )
                        {
                            usageFlags.IndexableInputs = 1;
                        }
                    }
                    else
                    if ( dwVersion < D3DPS_VERSION(2,0) )
                    {
                        // ps_1_x doesn't support dcl's, add it manually
                        if ( 0 == ( inputDecls.Colors & ( 1 << dwRegNum ) ) )
                        {
                            // Input color register declaration
                            inputDecls.AddDecl( D3DDECLUSAGE_COLOR, dwRegNum, VSOREG_Color0 + dwRegNum, D3DSP_WRITEMASK_ALL );
                        }
                    }
                    break;

                case D3DSPR_TEXTURE:
                    if ( dwVersion <= D3DPS_VERSION(1,3) &&
                         D3DSIO_TEXKILL != opCode )
                    {
                        // Should have been already defined in previous destination registers.
                        SHADER_CONV_ASSERT( dwRegNum < MAX_PS1X_TEXTURE_REGS );
                        SHADER_CONV_ASSERT( inputRegs._t[dwRegNum] != INVALID_INDEX );
                    }
                    else
                    if ( dwVersion < D3DPS_VERSION(2,0) )
                    {
                        // ps_1_4 doesn't support dcl's, need to add it explicitly.
                        if ( 0 == ( inputDecls.TexCoords & ( 1 << dwRegNum ) ) )
                        {
                            // Input texture coordinates register declaration
                            inputDecls.AddDecl( D3DDECLUSAGE_TEXCOORD, dwRegNum, VSOREG_TexCoord0 + dwRegNum, D3DSP_WRITEMASK_ALL );
                        }
                    }
                    break;

                case D3DSPR_CONST:
                    if ( hasRelativeAddress )
                    {
                        hasRelativeAddressF = true;
                    }
                    for ( UINT i = dwRegNum, n = i + __getConstRegSize( opCode ); i < n; ++i )
                    {
                        if ( hasRelativeAddressF ||
                             !bInlineConstsEnabled ||
                             !pShaderDesc->FindInlineConstant( CB_FLOAT, i * 4 ) )
                        {
                            __mincountof( minUsedConstantsF, i );
                            __maxcountof( maxUsedConstantsF, i + 1 );
                        }
                    }
                    break;

                case D3DSPR_CONSTINT:
                    if ( !bInlineConstsEnabled ||
                         !pShaderDesc->FindInlineConstant( CB_INT, dwRegNum * 4 ) )
                    {
                        __mincountof( minUsedConstantsI, dwRegNum );
                        __maxcountof( maxUsedConstantsI, dwRegNum + 1 );
                    }
                    break;

                case D3DSPR_CONSTBOOL:
                    if ( !bInlineConstsEnabled ||
                         !pShaderDesc->FindInlineConstant( CB_BOOL, dwRegNum ) )
                    {
                        __mincountof( minUsedConstantsB, dwRegNum );
                        __maxcountof( maxUsedConstantsB, dwRegNum + 1 );
                    }
                    break;

                case D3DSPR_LOOP:
                    if ( INVALID_INDEX == inputRegs.aL )
                    {
                       inputRegs.aL = ubNumTempRegs++;
                    }
                    break;

                default:
                    SHADER_CONV_ASSERT(!"CTranslator::AnalyzeVS() failed, invalid register type: %d\n");
                    hr = E_FAIL;
                    goto L_ERROR;
                }
            }
        }
    }

    if (IsImplicitFogCalculationNeeded(rasterStates, m_runtimeVersion) && rasterStates.FogTableMode != D3DFOG_NONE)
    {
        inputDecls.AddDecl(D3DDECLUSAGE_POSITION, 0, INVALID_INDEX, D3DSP_WRITEMASK_ALL);
    }

    *pdwCurInstr++ = D3DPS_END();

    for (UINT i = 0; i < MAX_PS_COLOROUT_REGS; i++)
    {
        if (outputRegs.oC[i] != INVALID_INDEX)
        {
            pShaderDesc->AddOutputRegisters(i);
        }
    }

    if (outputRegs.oDepth != INVALID_INDEX)
    {
        pShaderDesc->AddOutputDepthRegister();
    }


    // Copy shader instructions
#if DBG
    hr = pShaderDesc->CopyInstructions( pSrcBytes, cbCodeSize );
#else
    hr = pShaderDesc->CopyInstructions( pdwInstrs, (UINT)( pdwCurInstr - pdwInstrs ) * sizeof( DWORD ) );
#endif
    if ( FAILED( hr ) )
    {
        SHADER_CONV_ASSERT(!"CShaderDesc::CopyInstructions() failed, hr = %d\n");
        goto L_ERROR;
    }

    if (pdwInstrs) { delete[] pdwInstrs; }

    // Update the shader description
    pShaderDesc->SetVersion( dwVersion );
    pShaderDesc->SetUsageFlags( usageFlags );
    pShaderDesc->SetInputDecls( inputDecls );
    pShaderDesc->SetInputRegs( inputRegs );
    pShaderDesc->SetOutputRegs( outputRegs );
    pShaderDesc->SetMinUsedConsts( CB_FLOAT, minUsedConstantsF * 4 );
    pShaderDesc->SetMinUsedConsts( CB_INT, minUsedConstantsI * 4 );
    pShaderDesc->SetMinUsedConsts( CB_BOOL, minUsedConstantsB );
    pShaderDesc->SetMaxUsedConsts( CB_FLOAT, maxUsedConstantsF * 4 );
    pShaderDesc->SetMaxUsedConsts( CB_INT, maxUsedConstantsI * 4 );
    pShaderDesc->SetMaxUsedConsts( CB_BOOL, maxUsedConstantsB );
    pShaderDesc->SetRelAddrConsts( CB_FLOAT, hasRelativeAddressF );
    pShaderDesc->SetNumTempRegs( ubNumTempRegs );
    pShaderDesc->SetNumLoopRegs( uiNumLoopRegs );
    pShaderDesc->SetShaderSettings(shaderSettings);

    // Set the returned shader description
    *ppShaderDesc = pShaderDesc;

    return S_OK;

L_ERROR:

    if ( pdwInstrs )
    {
        delete[] pdwInstrs;
    }

    __safeRelease( pShaderDesc );

    return hr;
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
HRESULT
CTranslator::TranslatePS( const CPixelShaderDesc* pShaderDesc,
                          const RasterStates& rasterStates,
                          const ShaderConv::VSOutputDecls& inputDecls,
                          CCodeBlob** ppCodeBlob )
{
    HRESULT hr;

    if ( NULL == pShaderDesc ||
         NULL == ppCodeBlob )
    {
        SHADER_CONV_ASSERT(!"CTranslator::TranslatePS() failed, invalid parameters\n");
        return E_INVALIDARG;
    }

#if DBG && WARP_INTERNAL

    // Disassemble input the shader code to the debug output
    hr = Disasm20( pShaderDesc->GetInstructions(), 0 );
    if ( FAILED( hr ) )
    {
        SHADER_CONV_ASSERT(!"Disasm20() failed, hr = %d\n");
        return hr;
    }

#endif

    // Create a new pixel shader context
    CPSContext* pContext = new CPSContext( m_runtimeVersion, pShaderDesc, rasterStates, inputDecls, m_pShaderAsm );
    if ( NULL == pContext )
    {
        return E_OUTOFMEMORY;
    }

    // Start the shader assembler
    // Note: Upgraded from SM 4.0 -> SM 5.0 because rcp is only supported on SM 5.0
    m_pShaderAsm->StartShader(D3D10_SB_PIXEL_SHADER, 5, 0, pShaderDesc->GetShaderSettings());

    // Write the shader declarations
    hr = pContext->WriteDeclarations();
    if ( FAILED( hr ) )
    {
        __safeDelete( pContext );
        SHADER_CONV_ASSERT(!"CPSContext::WriteDeclarations() failed, hr = %d\n");
        return hr;
    }

    // Translate instructions
    hr = pContext->TranslateInstructions();
    if ( FAILED( hr ) )
    {
        __safeDelete( pContext );
        SHADER_CONV_ASSERT(!"CPSContext::TranslateInstructions() failed, hr = %d\n");
        return hr;
    }

    // Write the ouput registers
    pContext->WriteOutputs();

    // Delete the context
    __safeDelete( pContext );

    // End the shader assembler
    hr = m_pShaderAsm->EndShader();
    if ( FAILED( hr ) )
    {
        SHADER_CONV_ASSERT(!"CShaderAsm::EndShader() failed, hr = %d\n");
        return hr;
    }

        // Create the code blob
    hr = CCodeBlob::Create( m_pShaderAsm->ShaderSizeInDWORDs() * sizeof( UINT ),
                            m_pShaderAsm->GetShader(),
                            ppCodeBlob );
    if ( FAILED( hr ) )
    {
        SHADER_CONV_ASSERT(!"CCodeBlob::Create() failed, hr = %d\n");
        return hr;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
CPSContext::CPSContext( UINT runtimeVersion,
                        const CPixelShaderDesc* pShaderDesc,
                        const RasterStates& rasterStates,
                        const ShaderConv::VSOutputDecls& inputDecls,
                        CShaderAsmWrapper* pShaderAsm) :
    CContext( runtimeVersion, pShaderDesc, rasterStates, pShaderAsm ),
    m_inputDecls( inputDecls ),
    m_usageFlags( pShaderDesc->GetUsageFlags() ),
    m_pInputFog( NULL ),
    m_pInputSpecular( NULL ),
    m_positionRegister(pShaderDesc->GetPositionRegister())
{
    //--
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
HRESULT
CPSContext::WriteDeclarations()
{
    // Set the next loop register
    BYTE uiTotalTempRegs = m_pShaderDesc->GetNumTempRegs();

    // Store the loop registers base index
    m_nextLoopRegister = uiTotalTempRegs;

    // Add the loop registers count
    uiTotalTempRegs += m_pShaderDesc->GetNumLoopRegs();

    AllocateTempRegistersForUndeclaredInputs(m_inputDecls, uiTotalTempRegs);

    // Declare temp registers
    m_pShaderAsm->EmitTempsDecl( uiTotalTempRegs );

    // Declare floats constant buffers
    UINT nFloatConstRegs = m_pShaderDesc->GetMaxUsedConsts( ShaderConv::CB_FLOAT );
    if ( nFloatConstRegs )
    {
        if ( m_pShaderDesc->HasRelAddrConsts( ShaderConv::CB_FLOAT ) )
        {
            nFloatConstRegs = 0; // ie any size
        }

        m_pShaderAsm->EmitConstantBufferDecl(
            CB_FLOAT, nFloatConstRegs / 4, D3D10_SB_CONSTANT_BUFFER_IMMEDIATE_INDEXED );
    }

    // Declare intergers constant buffers
    const UINT nIntConstRegs = m_pShaderDesc->GetMaxUsedConsts( CB_INT );
    if ( nIntConstRegs )
    {
        m_pShaderAsm->EmitConstantBufferDecl(
            CB_INT, nIntConstRegs / 4, D3D10_SB_CONSTANT_BUFFER_IMMEDIATE_INDEXED );
    }

    // Declare booleans constant buffers
    const UINT nBoolConstRegs = m_pShaderDesc->GetMaxUsedConsts( CB_BOOL );
    if ( nBoolConstRegs )
    {
        m_pShaderAsm->EmitConstantBufferDecl(
            CB_BOOL, ( nBoolConstRegs + 3) / 4, D3D10_SB_CONSTANT_BUFFER_IMMEDIATE_INDEXED );
    }

    // Declare extension constant buffer
    if ( IsImplicitFogCalculationNeeded() ||
         m_rasterStates.AlphaTestEnable )
    {
        m_pShaderAsm->EmitConstantBufferDecl(
            CB_PS_EXT, __sizeof16( PSCBExtension ), D3D10_SB_CONSTANT_BUFFER_IMMEDIATE_INDEXED );
    }

    // Declare extension2 constant buffer
    if ( m_usageFlags.BumpEnvMat )
    {
        m_pShaderAsm->EmitConstantBufferDecl(
            CB_PS_EXT2, __sizeof16( PSCBExtension2 ), D3D10_SB_CONSTANT_BUFFER_IMMEDIATE_INDEXED );
    }

    // Declare extension3 constant buffer
    if ( m_rasterStates.ColorKeyEnable ||
         m_rasterStates.ColorKeyBlendEnable )
    {
        m_pShaderAsm->EmitConstantBufferDecl(
            CB_PS_EXT3, __sizeof16( PSCBExtension3 ), D3D10_SB_CONSTANT_BUFFER_IMMEDIATE_INDEXED );
    }

    // Declare pixel shader samplers
    for ( UINT i = 0; i < MAX_PS_SAMPLER_REGS; ++i )
    {
        TEXTURETYPE textureType = (TEXTURETYPE)m_inputRegs.s[i];
        if ( textureType != INVALID_INDEX )
        {
            if ( TEXTURETYPE_UNKNOWN == textureType )
            {
                textureType = (TEXTURETYPE)m_rasterStates.PSSamplers[i].TextureType;
            }

            // if reading from a specialized depth texture implicitly use a comparison 
            // sample for 'Hardware Shadow Maps'
            if (TextureUsesHardwareShadowMapping(i))
            {
                m_pShaderAsm->EmitSamplerDecl(i, D3D10_SB_SAMPLER_MODE_COMPARISON);
            }
            else
            {
                m_pShaderAsm->EmitSamplerDecl(i, D3D10_SB_SAMPLER_MODE_DEFAULT);
            }

            m_pShaderAsm->EmitResourceDecl( __toResourceDimension10( textureType ),
                                            i,
                                            D3D10_SB_RETURN_TYPE_FLOAT,
                                            D3D10_SB_RETURN_TYPE_FLOAT,
                                            D3D10_SB_RETURN_TYPE_FLOAT,
                                            D3D10_SB_RETURN_TYPE_FLOAT );
        }
    }

    BYTE declaredRegisterMasks[16] = { 0 };

    bool bDeclInputPosition = false;
    // Declare input registers
    for (UINT i = 0, n = m_inputDecls.GetSize(); i < n; ++i)
    {
        // Check if the input register is available        
        if (m_inputDecls[i].WriteMask)
        {
            const UINT usage      = m_inputDecls[i].Usage;
            const UINT usageIndex = m_inputDecls[i].UsageIndex;        
            const UINT regIndex   = m_inputDecls[i].RegIndex;
            const UINT writeMask  = m_inputDecls[i].WriteMask;
            const bool bCentroid  = ((m_inputDecls.CentroidMask >> i) & 0x1) ? true : false;

            if ((D3DDECLUSAGE_POSITION == usage) ||
                (D3DDECLUSAGE_VPOS == usage && 0 == usageIndex))
            {
                bDeclInputPosition = true;
            }
            else
            if ( D3DDECLUSAGE_VFACE == usage &&
                 0 == usageIndex )
            {
                m_pShaderAsm->EmitPSInputSystemGeneratedValueDecl(
                    PSIREG_VFace, writeMask << D3D10_SB_OPERAND_4_COMPONENT_MASK_SHIFT, D3D10_SB_INTERPOLATION_CONSTANT, D3D10_SB_NAME_IS_FRONT_FACE );
            }
            else
            {
                // Ensure that there is no duplicate declarations
                __assume(regIndex < _countof(declaredRegisterMasks));
                if (0 ==(declaredRegisterMasks[regIndex] & writeMask))
                {                    
                    declaredRegisterMasks[regIndex] |= writeMask;

                    D3D10_SB_INTERPOLATION_MODE interpolation;

                    if ((D3DDECLUSAGE_COLOR == usage) 
                     && (0 == usageIndex)
                     && (D3DSHADE_FLAT == m_rasterStates.ShadeMode))
                    {
                        interpolation = D3D10_SB_INTERPOLATION_CONSTANT;
                    }
                    else
                    if (bCentroid)
                    {
                        interpolation = D3D10_SB_INTERPOLATION_LINEAR_CENTROID;
                    }
                    else
                    {
                        interpolation = D3D10_SB_INTERPOLATION_LINEAR;
                    }

                    if (D3DDECLUSAGE_FOG == usage)
                    {
                        m_pInputFog = &m_inputDecls[i];
                    }
                    else
                    if ((D3DDECLUSAGE_COLOR == usage) 
                     && (1 == usageIndex))
                    {
                        m_pInputSpecular = &m_inputDecls[i];
                    }

                    m_pShaderAsm->EmitPSInputDecl(regIndex, writeMask << D3D10_SB_OPERAND_4_COMPONENT_MASK_SHIFT, interpolation);
                }
            }
        }
    }

    if (m_usageFlags.IndexableInputs)
    {
        // Declare input registers indexing range
        for (UINT baseReg = 0; baseReg < MAX_PS_INPUT_REGS; ++baseReg)
        {
            UINT regCount = 0;
            while (baseReg + regCount < MAX_PS_INPUT_REGS && declaredRegisterMasks[baseReg + regCount] != 0)
            {
                ++regCount;
            }
            if (regCount > 0)
            {
                m_pShaderAsm->EmitInputIndexingRangeDecl(
                    baseReg, regCount, D3D10_SB_OPERAND_4_COMPONENT_MASK_ALL);
            }
            baseReg += regCount;
        }
    }

    if (bDeclInputPosition)
    {
        m_pShaderAsm->EmitPSInputSystemInterpretedValueDecl(
            m_positionRegister,
            D3D10_SB_OPERAND_4_COMPONENT_MASK_ALL,
            D3D10_SB_INTERPOLATION_LINEAR_NOPERSPECTIVE,
            D3D10_SB_NAME_POSITION);
    }

    // Declare color ouput registers
    for ( UINT i = 0; i < MAX_PS_COLOROUT_REGS; ++i )
    {
        if ( m_outputRegs.oC[i] != INVALID_INDEX )
        {
            m_pShaderAsm->EmitOutputDecl( i, D3D10_SB_OPERAND_4_COMPONENT_MASK_ALL );
        }
    }

    // Declare depth ouput registers
    if ( m_outputRegs.oDepth != INVALID_INDEX )
    {
        m_pShaderAsm->EmitODepthDecl();
    }

    InitializeTempRegistersForUndeclaredInputs(m_inputDecls, uiTotalTempRegs);

    if ( m_inputRegs.v[PSIREG_VPos].Reg() != INVALID_INDEX && m_version >= D3DPS_VERSION(3, 0))
    {
        // Convert the position register value to integral float
        // round_ni t#, v#

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_ROUND_NI,
                          CTempOperandDst( m_inputRegs.v[PSIREG_VPos].Reg(), __WRITEMASK_XY ),
                          CInputOperand4(m_positionRegister, __SWIZZLE_XY ) ) );
    }

    if ( m_inputRegs.v[PSIREG_VFace].Reg() != INVALID_INDEX )
    {
        // Convert the face register boolean value to float
        // movc t#, v#, 1.0f, -1.0f

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_MOVC,
                          CTempOperandDst( m_inputRegs.v[PSIREG_VFace].Reg() ),
                          CInputOperand4( PSIREG_VFace, __SWIZZLE_X ),
                          COperand( 1.0f ),
                          COperand(-1.0f ) ) );
    }

    return S_OK;
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CPSContext::WriteOutputs()
{
    if ( m_bOutputWritten )
    {
        return;
    }

    if ( m_version < D3DPS_VERSION(2,0) )
    {
        // In PS 1.x, clamp the output color to [0..1]
        for ( UINT i = 0; i < MAX_PS_COLOROUT_REGS; ++i )
        {
            const UINT regIndex = m_outputRegs.oC[i];
            if ( regIndex != INVALID_INDEX )
            {
                m_pShaderAsm->EmitInstruction(
                    CInstructionEx( D3D10_SB_OPCODE_MOV,
                                    true,
                                    CTempOperandDst( regIndex ),
                                    CTempOperand4( regIndex ) ) );
            }
        }
    }

    //
    // Apply Fixed function extensions
    //

    if ( m_rasterStates.AlphaTestEnable &&
         D3DCMP_ALWAYS != m_rasterStates.AlphaFunc )
    {
        // Do alpha test
        this->ComputeAlphaTest();
    }

    if ( IsImplicitFogCalculationNeeded() )
    {
        // Do fog blend
        this->ComputeFogBlend();
    }

    //
    // Output color registers
    //

    for ( UINT i = 0; i < MAX_PS_COLOROUT_REGS; ++i )
    {
        const UINT regIndex = m_outputRegs.oC[i];
        if ( regIndex != INVALID_INDEX )
        {
            UINT swizzle = (m_rasterStates.SwapRBOnOutputMask & (1 << i))
                ? __SWIZZLE4(D3D10_SB_4_COMPONENT_Z,
                             D3D10_SB_4_COMPONENT_Y,
                             D3D10_SB_4_COMPONENT_X,
                             D3D10_SB_4_COMPONENT_W)
                : __SWIZZLE_ALL;
            m_pShaderAsm->EmitInstruction(
                CInstruction( D3D10_SB_OPCODE_MOV,
                              COperandDst( D3D10_SB_OPERAND_TYPE_OUTPUT, i ),
                              CTempOperand4( regIndex, swizzle ) ) );
        }
    }

    //
    // Output depth register
    //

    if ( m_outputRegs.oDepth != INVALID_INDEX )
    {
        auto depthOperand = CTempOperand4(m_outputRegs.oDepth);
        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_MOV,
                          COperandDst( D3D10_SB_OPERAND_TYPE_OUTPUT_DEPTH ),
                          CSingleComponent(depthOperand, D3D10_SB_4_COMPONENT_X) ) );
    }

    m_bOutputWritten = true;
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CPSContext::ComputeAlphaTest()
{
    if ( D3DCMP_NEVER == m_rasterStates.AlphaFunc )
    {
        // discard_z 0.0f
        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_DISCARD,
                          COperand( 0.0f ),
                          D3D10_SB_INSTRUCTION_TEST_ZERO ) );
    }
    else
    {
        const UINT colorIndex = m_outputRegs.oC[0];
        if ( colorIndex != INVALID_INDEX )
        {
            // <comp> s0.x, tC[0].w, cb3.alpharef.w
            // discard_z s0.x

            D3DSHADER_COMPARISON compare;

            switch ( m_rasterStates.AlphaFunc )
            {
            default:
                NO_DEFAULT;

            case D3DCMP_LESS:
                compare = D3DSPC_LT;
                break;

            case D3DCMP_EQUAL:
                compare = D3DSPC_EQ;
                break;

            case D3DCMP_LESSEQUAL:
                compare = D3DSPC_LE;
                break;

            case D3DCMP_GREATER:
                compare = D3DSPC_GT;
                break;

            case D3DCMP_NOTEQUAL:
                compare = D3DSPC_NE;
                break;

            case D3DCMP_GREATEREQUAL:
                compare = D3DSPC_GE;
                break;
            }

            // Generate compare instructions
            this->Compare( compare,
                           CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                           CTempOperand4( colorIndex, __SWIZZLE_W ),
                           CCBOperand2D( CB_PS_EXT,
                                         PSCBExtension::ALPHATEST_W,
                                         __SWIZZLE_W ) );

            // Execute the alpha test
            m_pShaderAsm->EmitInstruction(
                CInstruction( D3D10_SB_OPCODE_DISCARD,
                              CTempOperand1( SREG_TMP0, D3D10_SB_4_COMPONENT_X),
                              D3D10_SB_INSTRUCTION_TEST_ZERO ) );
        }
    }
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CPSContext::ComputeFogBlend()
{
    assert(IsImplicitFogCalculationNeeded());
    const UINT colorIndex = m_outputRegs.oC[0];
    if ( colorIndex != INVALID_INDEX )
    {
        if ( m_rasterStates.FogTableMode != D3DFOG_NONE )
        {
            // Execute pixel fog
            this->ComputePixelFog();
        }
        else
        {
            if ( m_pInputFog )
            {
                // mov_sat s0.w, fog.mask
                m_pShaderAsm->EmitInstruction(
                    CInstructionEx( D3D10_SB_OPCODE_MOV,
                                    true,
                                    CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_W ),
                                    CInputOperand4( m_pInputFog->RegIndex, __swizzleFromWriteMask( m_pInputFog->WriteMask ) ) ) );
            }
            else
            if ( m_pInputSpecular )
            {
                // mov_sat s0.w, specular.w
                m_pShaderAsm->EmitInstruction(
                    CInstructionEx( D3D10_SB_OPCODE_MOV,
                                    true,
                                    CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_W ),
                                    CInputOperand4( m_pInputSpecular->RegIndex, __SWIZZLE_W ) ) );
            }
            else
            {
                // No input fog is available, set the fog factor to Zero
                // mov_sat s0.w, 0.0f
                m_pShaderAsm->EmitInstruction(
                    CInstructionEx( D3D10_SB_OPCODE_MOV,
                                    true,
                                    CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_W ),
                                    COperand( 0.0f ) ) );
            }
        }

        // add s0.xyz, tC[0], -cb3.fogcolor.xyz
        // mad tC[0].xyz, s0, s0.w, cb3.fogcolor.xyz

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_ADD,
                          CTempOperandDst( SREG_TMP0, __WRITEMASK_XYZ ),
                          CTempOperand4( colorIndex ),
                          CNegate( CCBOperand2D( CB_PS_EXT, PSCBExtension::FOGCOLOR_XYZ, __SWIZZLE_XYZ ) ) ) );

         m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_MAD,
                          CTempOperandDst( colorIndex, __WRITEMASK_XYZ ),
                          CTempOperand4( SREG_TMP0 ),
                          CTempOperand4( SREG_TMP0, __SWIZZLE_W ),
                          CCBOperand2D( CB_PS_EXT, PSCBExtension::FOGCOLOR_XYZ, __SWIZZLE_XYZ ) ) );
    }
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CPSContext::ComputePixelFog()
{
    assert(IsImplicitFogCalculationNeeded());
    
    // Get the fog index value
    const COperandBase srcFogIndex = ( m_rasterStates.WFogEnable ) ?
        CInputOperand4(m_positionRegister, __SWIZZLE_W) :
        CInputOperand4(m_positionRegister, __SWIZZLE_Z);

    switch ( m_rasterStates.FogTableMode )
    {
    default:
        NO_DEFAULT;

    case D3DFOG_LINEAR:

        // ge s0.x, fogIndex, cb3.fogEnd
        // if s0.x
        //   mov s0.w, vec4(0.0f)
        // else
        //   ge s0.x, cb3.fogStart, fogIndex
        //   if s0.x
        //     mov s0.w, vec4(1.0f)
        //   else
        //     add s0.w, cb3.fogEnd, -fogIndex
        //     mul s0.w, s0.w, cb3.fogDistInv
        //   endif
        // endif

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_GE,
                          CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                          srcFogIndex,
                          CCBOperand2D( CB_PS_EXT, PSCBExtension::FOGEND_Y, __SWIZZLE_Y ) ) );

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_IF,
                          CTempOperand1( SREG_TMP0, D3D10_SB_4_COMPONENT_X),
                          D3D10_SB_INSTRUCTION_TEST_NONZERO ) );

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_MOV,
                          CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_W ),
                          COperand( 0.0f ) ) );

        m_pShaderAsm->EmitInstruction( CInstruction( D3D10_SB_OPCODE_ELSE ) );

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_GE,
                          CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                          CCBOperand2D( CB_PS_EXT, PSCBExtension::FOGSTART_X, __SWIZZLE_X ),
                          srcFogIndex ) );

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_IF,
                          CTempOperand1( SREG_TMP0, D3D10_SB_4_COMPONENT_X),
                          D3D10_SB_INSTRUCTION_TEST_NONZERO ) );

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_MOV,
                          CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_W ),
                          COperand( 1.0f ) ) );

        m_pShaderAsm->EmitInstruction( CInstruction( D3D10_SB_OPCODE_ELSE ) );

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_ADD,
                          CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_W ),
                          CCBOperand2D( CB_PS_EXT, PSCBExtension::FOGEND_Y, __SWIZZLE_Y ),
                          CNegate( srcFogIndex ) ) );

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_MUL,
                          CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_W ),
                          CTempOperand4( SREG_TMP0, __SWIZZLE_W ),
                          CCBOperand2D( CB_PS_EXT, PSCBExtension::FOGDISTINV_Z, __SWIZZLE_Z ) ) );

        m_pShaderAsm->EmitInstruction( CInstruction( D3D10_SB_OPCODE_ENDIF ) );
        m_pShaderAsm->EmitInstruction( CInstruction( D3D10_SB_OPCODE_ENDIF ) );

        break;

    case D3DFOG_EXP:

        // in D3D10, EXP(x) instruction is actually EXP2( x ) = 2^x.
        // EXP( x ) = EXP2( x * LOG2( e ) )
        // mul s0.x, fogIndex, cb3.fogDensity
        // mul s0.x, s0.x, vec4(-1.44269504088896f)
        // exp s0.w, s0.x

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_MUL,
                          CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                          srcFogIndex,
                          CCBOperand2D( CB_PS_EXT, PSCBExtension::FOGDENSITY_W, __SWIZZLE_W ) ) );

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_MUL,
                          CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                          CTempOperand4( SREG_TMP0, __SWIZZLE_X ),
                          COperand( -1.44269504088896f ) ) );

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_EXP,
                          CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_W ),
                          CTempOperand4( SREG_TMP0, __SWIZZLE_X ) ) );

        break;

    case D3DFOG_EXP2:

        // in D3D10, EXP(x) instruction is actually EXP2( x ) = 2^x.
        // EXP( x ) = EXP2( x * LOG2( e ) )
        // mul s0.x, fogIndex, cb3.fogDensity
        // mul s0.x, s0.x, s0.x
        // mul s0.x, s0.x, vec4(-1.44269504088896f)
        // exp s0.w, s0.x

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_MUL,
                          CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                          srcFogIndex,
                          CCBOperand2D( CB_PS_EXT, PSCBExtension::FOGDENSITY_W, __SWIZZLE_W ) ) );

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_MUL,
                          CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                          CTempOperand4( SREG_TMP0, __SWIZZLE_X ),
                          CTempOperand4( SREG_TMP0, __SWIZZLE_X ) ) );

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_MUL,
                          CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                          CTempOperand4( SREG_TMP0, __SWIZZLE_X ),
                          COperand( -1.44269504088896f ) ) );

        m_pShaderAsm->EmitInstruction(
            CInstruction( D3D10_SB_OPCODE_EXP,
                          CTempOperandDst( SREG_TMP0, D3D10_SB_OPERAND_4_COMPONENT_MASK_W ),
                          CTempOperand4( SREG_TMP0, __SWIZZLE_X ) ) );

        break;
    }
}

} // namespace ShaderConv
```

`ShaderConverter/ShaderConv/shaderconv.hpp`:

```hpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/*==========================================================================;
*
*  Copyright (C) Microsoft Corporation.  All Rights Reserved.
*
*  Header Definitions for The Shader Converter objects
*
****************************************************************************/

#pragma once

#include "ShaderConvInternal.h"

namespace ShaderConv
{

#define __safeRelease( p )      if ( p ) { p->Release(); p = NULL; }

#define __safeDelete( p )       if ( p ) { delete p; p = NULL; }

#define __safeDeleteArray( p )  if ( p ) { delete[] p; p = NULL; }

#define __mincountof( min, reg ) \
    if ( (reg) < min ) { min = (reg); }

#define __maxcountof( max, reg ) \
    if ( (reg) > max ) { max = (reg); }

#define __sizeofn( type, bytes ) \
    ( ( sizeof( type ) + ( (bytes) - 1 ) ) / (bytes) )

#define __sizeof16( type )    __sizeofn( type, 16 )

#define __IS_VS( version ) \
    ( ( (version) & 0xFFFF0000 ) == 0xFFFE0000 )

#define __IS_PS( version ) \
    ( ( (version) & 0xFFFF0000 ) == 0xFFFF0000 )

#define __D3DSPR_TEXTURE1X  20

#define __D3DI_TYPE_TOKEN( regType ) \
    ( ( ( (regType) << D3DSP_REGTYPE_SHIFT  ) & D3DSP_REGTYPE_MASK ) | \
      ( ( (regType) << D3DSP_REGTYPE_SHIFT2 ) & D3DSP_REGTYPE_MASK2 ) )

#define __D3DI_SRC_TOKEN( regType, index, swizzle, mod ) \
    __D3DI_TYPE_TOKEN( regType ) | (index) | (swizzle) | (mod) | 0x80000000

#define __D3DI_DST_TOKEN( regType, index, writeMask ) \
    __D3DI_TYPE_TOKEN( regType ) | (index) | (writeMask) | 0x80000000

#define D3DSP_WRITEMASK_SHIFT 16
#define D3DSP_WRITEMASK_MASK  0x000f0000

inline UINT
__getInstrLength( DWORD dwInstr, DWORD dwVersion )
{
    const D3DSHADER_INSTRUCTION_OPCODE_TYPE opCode =
            (D3DSHADER_INSTRUCTION_OPCODE_TYPE)( dwInstr & D3DSI_OPCODE_MASK );

    if ( D3DSIO_COMMENT == opCode )
    {
        return ( ( (UINT)dwInstr & D3DSI_COMMENTSIZE_MASK ) >> D3DSI_COMMENTSIZE_SHIFT ) + 1;
    }
    else
    if ( D3DSIO_DEF == opCode ||
         D3DSIO_DEFI == opCode )
    {
        return 6;
    }
    else
    if ( D3DSIO_DEFB == opCode )
    {
        return 3;
    }
    else
    if ( __IS_PS( dwVersion ) ||
         dwVersion >= D3DVS_VERSION(2,0) )
    {
        return D3DSI_GETINSTLENGTH( dwInstr ) + 1;
    }
    else
    {
        switch ( opCode )
        {
        case D3DSIO_DCL :
            return 3;

        case D3DSIO_DEF :
            return 6;

        // 0 source instructions
        case D3DSIO_END :
        case D3DSIO_NOP :
            return 1;

        // 1 source instructions
        case D3DSIO_EXP :
        case D3DSIO_EXPP:
        case D3DSIO_FRC :
        case D3DSIO_LIT :
        case D3DSIO_LOG :
        case D3DSIO_LOGP:
        case D3DSIO_MOV :
        case D3DSIO_RCP :
        case D3DSIO_RSQ :
            return 3;

        // 2 source instructions
        case D3DSIO_ADD  :
        case D3DSIO_DP3  :
        case D3DSIO_DP4  :
        case D3DSIO_DST  :
        case D3DSIO_M4x4 :
        case D3DSIO_M4x3 :
        case D3DSIO_M3x4 :
        case D3DSIO_M3x3 :
        case D3DSIO_M3x2 :
        case D3DSIO_MAX  :
        case D3DSIO_MIN  :
        case D3DSIO_MUL  :
        case D3DSIO_SGE  :
        case D3DSIO_SLT  :
            return 4;

        // 3 source instructions
        case D3DSIO_MAD  :
            return 4;

        default:
            //WarpError("Invalid instruction opCode.");
            return 1;
        }
    }
}

inline BYTE
__getConstRegSize( UINT opCode )
{
    switch ( opCode )
    {
    case D3DSIO_M3x2:
        return 2;

    case D3DSIO_M3x3:
    case D3DSIO_M4x3:
        return 3;

    case D3DSIO_M3x4:
    case D3DSIO_M4x4:
        return 4;
    }

    return 1;
}

inline D3D10_SB_RESOURCE_DIMENSION
__toResourceDimension10( TEXTURETYPE textureType )
{
    switch ( textureType )
    {
    default:
    case TEXTURETYPE_UNKNOWN:
        // Default to Tex2D in cases where we don't have enough information to make a better decision.
        // Better to have a valid shader which isn't exactly what was asked for, than an invalid shader.
    case TEXTURETYPE_2D:
        return D3D10_SB_RESOURCE_DIMENSION_TEXTURE2D;

    case TEXTURETYPE_CUBE:
        return D3D10_SB_RESOURCE_DIMENSION_TEXTURECUBE;

    case TEXTURETYPE_VOLUME:
        return D3D10_SB_RESOURCE_DIMENSION_TEXTURE3D;
    }
}

inline TEXTURETYPE
__toTextureType( D3DSAMPLER_TEXTURE_TYPE samplerType )
{
    switch ( samplerType )
    {
    default:
    case D3DSTT_UNKNOWN:
        return TEXTURETYPE_UNKNOWN;

    case D3DSTT_2D:
        return TEXTURETYPE_2D;

    case D3DSTT_CUBE:
        return TEXTURETYPE_CUBE;

    case D3DSTT_VOLUME:
        return TEXTURETYPE_VOLUME;
    }
}

inline UINT
__getComponentsNeeded(TEXTURETYPE samplerType, bool UsingHardwareShadowMapping)
{
    switch (samplerType)
    {
    default:
    case TEXTURETYPE_UNKNOWN:
        return 4;

    case TEXTURETYPE_2D:
        // When using hardware shadow mapping, a third channel is used as the comparison value for SampleCmp
        if (UsingHardwareShadowMapping)
        {
            return 3;
        }
        else
        {
            return 2;
        }

    case TEXTURETYPE_CUBE:
    case TEXTURETYPE_VOLUME:
        return 3;
    }
}

inline UINT __getWriteMaskFromTextureType(TEXTURETYPE samplerType)
{
    switch (samplerType)
    {
    default:
    case TEXTURETYPE_UNKNOWN:
        return D3D10_SB_OPERAND_4_COMPONENT_MASK_X | D3D10_SB_OPERAND_4_COMPONENT_MASK_Y | D3D10_SB_OPERAND_4_COMPONENT_MASK_Z | D3D10_SB_OPERAND_4_COMPONENT_MASK_W;

    case TEXTURETYPE_2D:
        return D3D10_SB_OPERAND_4_COMPONENT_MASK_X | D3D10_SB_OPERAND_4_COMPONENT_MASK_Y;

    case TEXTURETYPE_CUBE:
    case TEXTURETYPE_VOLUME:
        return D3D10_SB_OPERAND_4_COMPONENT_MASK_X | D3D10_SB_OPERAND_4_COMPONENT_MASK_Y | D3D10_SB_OPERAND_4_COMPONENT_MASK_Z;
    }
}

inline UINT
__getWriteMask( DWORD dwToken )
{
    UINT writeMask = 0;

    if ( dwToken & D3DSP_WRITEMASK_0 )
    {
        writeMask |= D3D10_SB_OPERAND_4_COMPONENT_MASK_X;
    }

    if ( dwToken & D3DSP_WRITEMASK_1 )
    {
        writeMask |= D3D10_SB_OPERAND_4_COMPONENT_MASK_Y;
    }

    if ( dwToken & D3DSP_WRITEMASK_2 )
    {
        writeMask |= D3D10_SB_OPERAND_4_COMPONENT_MASK_Z;
    }

    if ( dwToken & D3DSP_WRITEMASK_3 )
    {
        writeMask |= D3D10_SB_OPERAND_4_COMPONENT_MASK_W;
    }

    return writeMask;
}

inline UINT
__getSwizzle( DWORD dwToken, UINT numComponents )
{
    UINT value   = 0;
    UINT swizzle = 0;

    const DWORD dwSwizzleMask = dwToken & D3DVS_SWIZZLE_MASK;
    for ( UINT i = 0; i < numComponents; ++i )
    {
        value = ( ( dwSwizzleMask >> ( D3DVS_SWIZZLE_SHIFT + 2 * i ) ) & 0x3 );
        swizzle |= __SWIZZLEN( i, value );
    }

    for ( UINT i = numComponents; i < 4; ++i )
    {
       swizzle |= __SWIZZLEN( i, value );
    }

    return swizzle;
}

inline UINT
__swizzleFromWriteMask( UINT writeMask )
{
    UINT swizzle  = 0;
    UINT position = 0;
    UINT lastcomp = 0;

    if ( writeMask & D3D10_SB_OPERAND_4_COMPONENT_MASK_X )
    {
        swizzle |= __SWIZZLEN( position++, D3D10_SB_4_COMPONENT_X );
        lastcomp = D3D10_SB_4_COMPONENT_X;
    }

    if ( writeMask & D3D10_SB_OPERAND_4_COMPONENT_MASK_Y )
    {
        swizzle |= __SWIZZLEN( position++, D3D10_SB_4_COMPONENT_Y );
        lastcomp = D3D10_SB_4_COMPONENT_Y;
    }

    if ( writeMask & D3D10_SB_OPERAND_4_COMPONENT_MASK_Z )
    {
        swizzle |= __SWIZZLEN( position++, D3D10_SB_4_COMPONENT_Z );
        lastcomp = D3D10_SB_4_COMPONENT_Z;
    }

    if ( writeMask & D3D10_SB_OPERAND_4_COMPONENT_MASK_W )
    {
        swizzle |= __SWIZZLEN( position++, D3D10_SB_4_COMPONENT_W );
        lastcomp = D3D10_SB_4_COMPONENT_W;
    }

    while ( position < 4 )
    {
        swizzle |= __SWIZZLEN( position++, lastcomp );
    }

    return swizzle;
}

enum eVSOuputRegister
{
    VSOREG_Position     = 0,
    VSOREG_Color0       = 1,
    VSOREG_Color1       = 2,
    VSOREG_TexCoord0    = 3,
    VSOREG_TexCoord1    = 4,
    VSOREG_TexCoord2    = 5,
    VSOREG_TexCoord3    = 6,
    VSOREG_TexCoord4    = 7,
    VSOREG_TexCoord5    = 8,
    VSOREG_TexCoord6    = 9,
    VSOREG_TexCoord7    = 10,
    VSOREG_FogPSize     = 11,    
    VSOREG_PointSprite  = 12,    

    VSOREG_ClipDist0    = 13,
    VSOREG_ClipDist1    = 14,

    VSOREG_SIZE,
};

enum ePSInputRegister
{
    PSIREG_V0    = 0,
    PSIREG_V1    = 1,
    PSIREG_V2    = 2,
    PSIREG_V3    = 3,
    PSIREG_V4    = 4,
    PSIREG_V5    = 5,
    PSIREG_V6    = 6,
    PSIREG_V7    = 7,
    PSIREG_V8    = 8,
    PSIREG_V9    = 9,
    PSIREG_V10   = 10,
    PSIREG_V11   = 11,
    PSIREG_V12   = 12,

    PSIREG_VPos  = 13,
    PSIREG_VFace = 14,

    PSIREG_SIZE,
};

inline bool IsImplicitFogCalculationNeeded(const RasterStates& rasterStates, UINT version)
{
    return version < D3DPS_VERSION(3, 0) && rasterStates.FogEnable;
}

// Wraps CShaderASM so that extra commands can be patched in at EmitInstruction.
// Allows for specifying special shader behavior like enforcing "anything time 0 
// always equals 0"
class CShaderAsmWrapper : public CShaderAsm
{
public:
    CShaderAsmWrapper(){}

    void StartShader(D3D10_SB_TOKENIZED_PROGRAM_TYPE ShaderType, UINT vermajor, UINT verminor, UINT ShaderSettings)
    {
        m_ShaderFlags = ShaderSettings;
        m_InstructionsEmitted = m_ExtraInstructionsEmitted = 0;
        CShaderAsm::StartShader(ShaderType, vermajor, verminor);
    }

    void EmitInstruction(const CInstruction& inst)
    {
        CInstruction patchedInstruction = inst;
        if (InstructionRequiresMultiplicationPatch(patchedInstruction))
        {
            COperandBase multiplicandSrc0;
            COperandBase multiplicandSrc1;

            UINT multiplicandIndex0 = 1, multiplicandIndex1 = 2;
            switch (patchedInstruction.OpCode())
            {
            case D3D10_SB_OPCODE_DP2:
            case D3D10_SB_OPCODE_DP3:
            case D3D10_SB_OPCODE_DP4:
            case D3D10_SB_OPCODE_MUL:
            case D3D10_SB_OPCODE_MAD:
                break;
            default:
                assert(false);
            }

            PatchMultiplicandArgs(
                patchedInstruction.m_Operands[multiplicandIndex0],
                patchedInstruction.m_Operands[multiplicandIndex1]);
        }
        EmitInstructionInternal(patchedInstruction);
    }

    bool IsMultiplicationPatchingEnabled()
    {
        return (m_ShaderFlags & ShaderSettings::AnythingTimes0Equals0);
    }

    UINT GetTotalInstructionsEmitted() const 
    {
        return m_InstructionsEmitted;
    }

    UINT GetTotalExtraInstructionsEmitted() const
    {
        return m_ExtraInstructionsEmitted;
    }

protected:
    void EmitExtraInstructionInternal(const CInstruction& inst)
    {
        m_ExtraInstructionsEmitted++;
        EmitInstructionInternal(inst);
    }

    void EmitInstructionInternal(const CInstruction& inst) 
    { 
        m_InstructionsEmitted++;
        CShaderAsm::EmitInstruction(inst);
    }


    UINT m_ShaderFlags;

    UINT m_InstructionsEmitted;
    UINT m_ExtraInstructionsEmitted;

    bool InstructionRequiresMultiplicationPatch(const CInstruction& instruction)
    {
        return IsMultiplicationPatchingEnabled() && OpTypeImpliesFloatMultiplication(instruction.OpCode());
    }

    void PatchMultiplicandArgs(
        _In_ COperandBase &src0,
        _In_ COperandBase &src1);

    // Returns true for any optype that would imply that the hardware needs 
    // to do any sort of float multiplication
    static bool OpTypeImpliesFloatMultiplication(D3D10_SB_OPCODE_TYPE opType)
    {
        switch (opType)
        {
        case D3D10_SB_OPCODE_DP2:
        case D3D10_SB_OPCODE_DP3:
        case D3D10_SB_OPCODE_DP4:
        case D3D10_SB_OPCODE_MUL:
        case D3D10_SB_OPCODE_MAD:
            return true;
        default:
            return false;
        }
    }
};

class CTranslator : public ITranslator
{
public:

    static HRESULT Create( UINT runtimeVersion, ITranslator** ppTranslator );

    HRESULT AnalyzeVS( const void* pSrcBytes,
                       UINT cbCodeSize,
                       UINT shaderSettings,
                       const RasterStates& rasterStates,
                       const VSInputDecls *pReferenceInputDecls,
                       CVertexShaderDesc** ppShaderDesc );

    HRESULT AnalyzePS( const void* pSrcBytes,
                       UINT cbCodeSize,
                       UINT shaderSettings,
                       const RasterStates& rasterStates,
                       CPixelShaderDesc** ppShaderDesc );

    HRESULT TranslateVS( const CVertexShaderDesc* pShaderDesc,
                         const RasterStates& rasterStates,
                         CCodeBlob** ppCodeBlob );

    HRESULT TranslateTLVS( const CTLVertexShaderDesc* pShaderDesc,
                           CCodeBlob** ppCodeBlob );    

    HRESULT TranslatePS( const CPixelShaderDesc* pShaderDesc,
                         const RasterStates& rasterStates,
                         const ShaderConv::VSOutputDecls& inputDecls,
                         CCodeBlob** ppCodeBlob );

    HRESULT TranslateGS( const CGeometryShaderDesc* pShaderDesc,
                         CCodeBlob** ppCodeBlob );

    TranslationData GetTranslationData()
    {
        return{ m_pShaderAsm->GetTotalInstructionsEmitted(), m_pShaderAsm->GetTotalExtraInstructionsEmitted() };
    }
private:
    void DeclareClipplaneRegisters(
        VSOutputDecls &outputDecls,
        UINT activeClipPlanesMask);

    CTranslator( UINT runtimeVersion );
    virtual ~CTranslator();

    HRESULT Initialize();

    UINT        m_runtimeVersion;
    CShaderAsmWrapper* m_pShaderAsm;
};

} // namespace ShaderConv

```

`ShaderConverter/ShaderConv/tlvsconv.cpp`:

```cpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/*==========================================================================;
*
*  Copyright (C) Microsoft Corporation.  All Rights Reserved.
*
*  Implementation for The Vertex Shader Converter
*
****************************************************************************/

#include "pch.h"
#include "context.hpp"

namespace ShaderConv
{

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
HRESULT
CTranslator::TranslateTLVS(
    const CTLVertexShaderDesc* pShaderDesc,
    CCodeBlob** ppCodeBlob
    )
{
    HRESULT hr;

    if ((NULL == pShaderDesc)
     || (NULL == ppCodeBlob))
    {
        SHADER_CONV_ASSERT(!"CTranslator::TranslateTLVS() failed, invalid parameters\n");
        return E_INVALIDARG;
    }

    // Create a new geometry shader context
    CTLVSContext* pContext = new CTLVSContext(m_runtimeVersion, pShaderDesc, m_pShaderAsm);
    if (NULL == pContext)
    {
        return E_OUTOFMEMORY;
    }

    // Start the shader assembler
    m_pShaderAsm->StartShader(D3D10_SB_VERTEX_SHADER, 5, 0, pShaderDesc->GetShaderSettings());

    // Write the shader declarations
    hr = pContext->WriteDeclarations();
    if (FAILED(hr))
    {
        __safeDelete(pContext);
        SHADER_CONV_ASSERT(!"CTLVSContext::WriteDeclarations() failed, hr = %d\n");
        return hr;
    }

    // Translate instructions
    hr = pContext->TranslateInstructions();
    if (FAILED(hr))
    {
        __safeDelete(pContext);
        SHADER_CONV_ASSERT(!"CTLVSContext::TranslateInstructions() failed, hr = %d\n");
        return hr;
    }

    // Write the ouput registers
    pContext->WriteOutputs();

    // Delete the context
    __safeDelete( pContext );

    // End the shader assembler
    hr = m_pShaderAsm->EndShader();
    if (FAILED(hr))
    {
        SHADER_CONV_ASSERT(!"CShaderAsm::EndShader() failed, hr = %d\n");
        return hr;
    }

    // Create the code blob
    hr = CCodeBlob::Create(
        m_pShaderAsm->ShaderSizeInDWORDs() * sizeof(UINT),
        m_pShaderAsm->GetShader(),
        ppCodeBlob
        );
    if (FAILED(hr))
    {
        SHADER_CONV_ASSERT(!"CCodeBlob::Create() failed, hr = %d\n");
        return hr;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
CTLVertexShaderDesc::CTLVertexShaderDesc(const VSInputDecls& vsInputDecls, UINT shaderSettings) : 
    m_vsInputDecls(MAX_VS_INPUT_REGS),
    m_shaderSettings(shaderSettings)
{
    for (UINT i = 0, n = vsInputDecls.GetSize(); i < n; ++i)
    {
        const UINT usage = vsInputDecls[i].Usage;
        switch (usage)
        {        
        case D3DDECLUSAGE_POSITIONT:
            // This should already have D3DDECLUSAGE_POSITIONT replaced with D3DDECLUSAGE_POSITION.
            SHADER_CONV_ASSERT(false);
            break;
        case D3DDECLUSAGE_POSITION:
        case D3DDECLUSAGE_COLOR:
        case D3DDECLUSAGE_TEXCOORD:
        case D3DDECLUSAGE_FOG:
        case D3DDECLUSAGE_PSIZE:
            m_vsInputDecls.AddDecl(
                usage,
                vsInputDecls[i].UsageIndex,
                vsInputDecls[i].RegIndex,
                vsInputDecls[i].IsTransformedPosition
                );

            m_vsOutputDecls.AddDecl(
                usage, 
                vsInputDecls[i].UsageIndex,
                vsInputDecls[i].RegIndex,
                D3DSP_WRITEMASK_ALL
                );
            break;
        default:
            NO_DEFAULT;
        }
    }
}

//////////////////////////////////////////////////////////////////////////////

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
CTLVSContext::CTLVSContext(
    UINT runtimeVersion, 
    const CTLVertexShaderDesc* pShaderDesc, 
    CShaderAsmWrapper* pShaderAsm) :
    IContext(runtimeVersion, pShaderAsm),
    m_pShaderDesc(pShaderDesc)
{
    //--
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
HRESULT
CTLVSContext::WriteDeclarations()
{
    const VSInputDecls& vsInputDecls = m_pShaderDesc->GetInputDecls();

    // Declare temp registers.  Currently transformed vertices use a hard coded shader that uses exactly 3 temp registers.
    m_pShaderAsm->EmitTempsDecl(12);

    // Declare extension constant buffer.
    m_pShaderAsm->EmitConstantBufferDecl(
        CB_VS_EXT, __sizeof16( VSCBExtension ), D3D10_SB_CONSTANT_BUFFER_IMMEDIATE_INDEXED );

    // Declare input registers
    for (UINT i = 0, n = vsInputDecls.GetSize(); i < n; ++i)
    {
        const UINT regIndex = vsInputDecls[i].RegIndex;
        m_pShaderAsm->EmitInputDecl(regIndex, D3D10_SB_OPERAND_4_COMPONENT_MASK_ALL);
    }
        
    // Declare other output registerss
    for (UINT i = 0, n = vsInputDecls.GetSize(); i < n; ++i)
    {
        const UINT usage      = vsInputDecls[i].Usage;
        const UINT usageIndex = vsInputDecls[i].UsageIndex;
        const UINT regIndex   = vsInputDecls[i].RegIndex;

        if ((D3DDECLUSAGE_POSITIONT == usage) 
        && (0 == usageIndex))
        {
            // D3D10_SB_NAME_POSITIONT is WARP only
            //
            // Declare the output position register
            // m_pShaderAsm->EmitOutputSystemInterpretedValueDecl(
            //    0, D3D10_SB_OPERAND_4_COMPONENT_MASK_ALL, D3D10_SB_NAME_POSITIONT);

            // All vertex declarations should already have D3DDECLUSAGE_POSITIONT replaced with D3DDECLUSAGE_POSITION
            SHADER_CONV_ASSERT(false);
            return E_FAIL;
        }
        else if ( D3DDECLUSAGE_POSITION == usage &&
             0 == usageIndex )
        {
            // Declare the position ouput register.
            m_pShaderAsm->EmitOutputSystemInterpretedValueDecl(regIndex, D3D10_SB_OPERAND_4_COMPONENT_MASK_ALL, D3D10_SB_NAME_POSITION );
        }
        else
        {
            m_pShaderAsm->EmitOutputDecl(regIndex, D3D10_SB_OPERAND_4_COMPONENT_MASK_ALL);
        }
    }

    return S_OK;
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
HRESULT
CTLVSContext::TranslateInstructions()
{
    //--

    return S_OK;
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CTLVSContext::WriteOutputs()
{
    const VSInputDecls& vsInputDecls = m_pShaderDesc->GetInputDecls();

    //
    // Write other output registers
    //

    for (UINT i = 0, n = vsInputDecls.GetSize(); i < n; ++i)
    {
        const UINT usage = vsInputDecls[i].Usage;

        bool bSaturate = false;

#if 1 // start - pixel center workaround
        if (D3DDECLUSAGE_POSITIONT == usage
            && 0 == vsInputDecls[i].UsageIndex)
        {
            // Any instance of D3DDECLUSAGE_POSITIONT should have already been replaced by D3DDECLUSAGE_POSITION at this stage.
            SHADER_CONV_ASSERT(false);
        }
        else if (D3DDECLUSAGE_POSITION == usage
            && vsInputDecls[i].IsTransformedPosition
            && 0 == vsInputDecls[i].UsageIndex)
        {
            // The vertex shader input declaration should already have D3DDECLUSAGE_POSITIONT replaced with D3DDECLUSAGE_POSITION at this stage.

            // First transform from screen space (the original input space) and clip space.

            // Xclip = ( Xscrn + 0.5 - ( VP.width/2 + VP.left ) ) * 2/VP.width * 1/Wscrn
            // Yclip = ( Yscrn + 0.5 - ( VP.height/2 + VP.top ) ) * -2/VP.height * 1/Wscrn
            // Zclip = ( Zscrn - VP.zmin ) * 1/VP.depth * 1/Wscrn
            // Wclip = 1/Wscrn

            // cb3[ScreenToClipOffset] = (  
            //     0.5 - ( VP.width/2 + VP.left ),
            //     0.5 - ( VP.height/2 + VP.top ),
            //     - VP.zmin,
            //     0
            // )

            // v0 contains the original vertex input positionT value
            // By reading v0 directly this will ignore any world/view/projection transform applied as part of fixed function shader translation.
            // s0.xyzw = post.xyzw + cb3[ScreenToClipOffset].xyzw 
            // add s0.xyzw, v0.xyzw, cb3[ScreenToClipOffset].xyzw
            m_pShaderAsm->EmitInstruction(
                CInstruction(
                    D3D10_SB_OPCODE_ADD,
                    CTempOperandDst( SREG_TMP0 ),
                    CInputOperand4(0),
                    CCBOperand2D( CB_VS_EXT, VSCBExtension::SCREENTOCLIPOFFSET )));

            // cb3[ScreenToClipScale] = (  
            //     2/VP.width,
            //     -2/VP.height,
            //     1/VP.depth,
            //     1
            // )

            // s1.xyzw = s0.xyzw * cb3[ScreenToClipScale].xyzw
            // mul s1.xyzw, s0.xyzw, cb3[ScreenToClipScale].xyzw
            m_pShaderAsm->EmitInstruction(
                CInstruction(
                    D3D10_SB_OPCODE_MUL,
                    CTempOperandDst( SREG_TMP1 ),
                    CTempOperand4( SREG_TMP0 ),
                    CCBOperand2D( CB_VS_EXT, VSCBExtension::SCREENTOCLIPSCALE )));

            // s2.x = 1 / post.w
            // rcp s2.x, v0.w
            m_pShaderAsm->EmitInstruction(
                CInstruction(
                    D3D11_SB_OPCODE_RCP,
                    CTempOperandDst( SREG_TMP2, D3D10_SB_OPERAND_4_COMPONENT_MASK_X ),
                    CSwizzle( CInputOperand4(0), __SWIZZLE_W )));

            // pos.xyzw = (1 / post.w) * s1.xyzw
            // mul pos.xyzw, s2.x, s1.xyzw
            m_pShaderAsm->EmitInstruction(
                CInstruction(
                    D3D10_SB_OPCODE_MUL,
                    COperandDst(D3D10_SB_OPERAND_TYPE_OUTPUT, 0),
                    CSwizzle( CTempOperand4( SREG_TMP2 ), __SWIZZLE_X ),
                    CTempOperand4( SREG_TMP1 )));

            // At this point pos.w = ((post.w + 0) * 1) / post.w  = 1
            // Need an extra divide by Wscrn for pos.w only

            // pos.w = 1 / post.w
            // mov pos.w, s2.x
            m_pShaderAsm->EmitInstruction(
                CInstruction(
                    D3D10_SB_OPCODE_MOV,
                    COperandDst(D3D10_SB_OPERAND_TYPE_OUTPUT, 0, D3D10_SB_OPERAND_4_COMPONENT_MASK_W),
                    CSwizzle( CTempOperand4( SREG_TMP2 ), __SWIZZLE_X )));


            // Alternate Implemenation
            // (this was not implemented due to lack of time, but would be a cleaner solution)

            // To assign  1/Wscrn to Wclip, first force Wclip to 1 and then olny divide pos by Wscrn once.
            // Could simplify the vertex shader instructions due to no extra divide by Wscrn at the end.

            // Xclip = ( Xscrn * (2/VP.width)        + (1/VP.width - ( VP.width/2 + VP.left ) * 2/VP.width) )             * 1/Wscrn
            // Yclip = ( Yscrn * (-2/VP.height)      + (- 1/VP.height - ( VP.height/2 + VP.top ) * -2/VP.height) )        * 1/Wscrn
            // Zclip = ( Zscrn * (2/VP.depth)        + (- VP.zmin * 2/VP.depth) )                                         * 1/Wscrn
            // Wclip = ( Wscrn * 0                   + 1 )                                                                * 1/Wscrn

            // s0.xyzw = v0.xyzw * cb3[ScreenToClipScale].xyzw + cb3[ScreenToClipOffset].xyzw
            // mad s0.xyzw, v0.xyzw, cb3[ScreenToClipScale].xyzw, cb3[ScreenToClipOffset].xyzw
        }
        else
        {
#endif // end - pixel center workaround

            switch (usage)
            {
            case D3DDECLUSAGE_COLOR:
                bSaturate = true;
                break;

            case D3DDECLUSAGE_FOG:
                bSaturate = (m_runtimeVersion < 9);
                break;
            }

            const UINT regIndex = vsInputDecls[i].RegIndex;
            const CInputOperand4 inOperand(regIndex);
            const COperandDst outOperand(D3D10_SB_OPERAND_TYPE_OUTPUT, regIndex);

            m_pShaderAsm->EmitInstruction(
                CInstructionEx(D3D10_SB_OPCODE_MOV, bSaturate, outOperand, inOperand));

#if 1 // start - pixel center workaround
        }
#endif // end - pixel center workaround
    }
}

} // namespace ShaderConv

```

`ShaderConverter/ShaderConv/translator.cpp`:

```cpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/*==========================================================================;
*
*  Copyright (C) Microsoft Corporation.  All Rights Reserved.
*
*  Implementation for the Shader Translator
*
****************************************************************************/

#include "pch.h"
#include "shaderconv.hpp"

namespace ShaderConv
{

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
/// <param name=""></param>
/// <param name=""></param>
/// <param name=""></param>
/// <returns></returns>
///---------------------------------------------------------------------------
HRESULT
CreateTranslator( UINT runtimeVersion, ITranslator** ppTranslator )
{
    SHADER_CONV_ASSERT( ppTranslator );
    return CTranslator::Create( runtimeVersion, ppTranslator );
}

//////////////////////////////////////////////////////////////////////////////

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
CTranslator::CTranslator( UINT runtimeVersion )
{
    m_runtimeVersion = runtimeVersion;
    m_pShaderAsm = NULL;
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
CTranslator::~CTranslator()
{
    __safeDelete( m_pShaderAsm );
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
HRESULT
CTranslator::Create( UINT runtimeVersion, ITranslator** ppTranslator )
{
    HRESULT hr;

    if ( NULL == ppTranslator )
    {
        return E_INVALIDARG;
    }

    CTranslator* pTranslator = new CTranslator( runtimeVersion );
    if ( NULL == pTranslator )
    {
        return E_OUTOFMEMORY;
    }

    pTranslator->AddRef();

    hr = pTranslator->Initialize();
    if ( FAILED( hr ) )
    {
        pTranslator->Release();
        SHADER_CONV_ASSERT(!"CTranslator::Initialize() failed, hr = %d\n");
        return hr;
    }

    *ppTranslator = pTranslator;

    return S_OK;
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
HRESULT
CTranslator::Initialize()
{
    // Create the shader assembler
    m_pShaderAsm = new CShaderAsmWrapper();
    if ( NULL == m_pShaderAsm )
    {
        SHADER_CONV_ASSERT(!"CShaderAsm() allocation failed, out of memory\n");
        return E_OUTOFMEMORY;;
    }

    if (FAILED(m_pShaderAsm->Init()))
    {
        SHADER_CONV_ASSERT(!"Init() failed, out of memory\n");
        return E_OUTOFMEMORY;;
    }

    return S_OK;
}

} // namespace ShaderConv
```

`ShaderConverter/ShaderConv/vsconv.cpp`:

```cpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/*==========================================================================;
*
*  Copyright (C) Microsoft Corporation.  All Rights Reserved.
*
*  Implementation for The Vertex Shader Converter
*
****************************************************************************/

#include "pch.h"
#include "context.hpp"

namespace ShaderConv
{

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
HRESULT
CVertexShaderDesc::Create( CVertexShaderDesc** ppVertexShaderDesc )
{
    SHADER_CONV_ASSERT( ppVertexShaderDesc );

    CVertexShaderDesc* const pVertexShaderDesc = new CVertexShaderDesc();
    if ( NULL == pVertexShaderDesc )
    {
        SHADER_CONV_ASSERT(!"CVertexShaderDesc() allocation failed, out of memory\n" );
        return E_OUTOFMEMORY;
    }

    pVertexShaderDesc->AddRef();
    *ppVertexShaderDesc = pVertexShaderDesc;

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
HRESULT
CTranslator::AnalyzeVS( const void* pSrcBytes,
                        UINT cbCodeSize,
                        UINT shaderSettings,
                        const RasterStates& rasterStates,
                        const VSInputDecls *pReferenceInputDecls,
                        CVertexShaderDesc** ppShaderDesc )
{
    HRESULT hr;

    if ( NULL == pSrcBytes ||
         NULL == ppShaderDesc ||
         0 == cbCodeSize )
    {
        SHADER_CONV_ASSERT(!"CTranslator::AnalyzeVS() failed, invalid parameters\n");
        return E_INVALIDARG;
    }

    // Get the shader version
    const DWORD* const pdwCodeBytes = reinterpret_cast<const DWORD*>( pSrcBytes );
    const DWORD dwVersion = *pdwCodeBytes;

    switch ( dwVersion )
    {
    case D3DVS_VERSION(1,0):
    case D3DVS_VERSION(1,1):
    case D3DVS_VERSION(1,2):
    case D3DVS_VERSION(1,3):
    case D3DVS_VERSION(1,4):
    case D3DVS_VERSION(2,0):
    case D3DVS_VERSION(2,1):
    case D3DVS_VERSION(3,0):
        break;

    default:
        SHADER_CONV_ASSERT(!"CTranslator::AnalyzeVS() failed, shader version not supported: 0x%x\n");
        return E_INVALIDARG;
    }

#if DBG && WARP_INTERNAL
    // Disassemble input the shader code to the debug output
    hr = Disasm20( pdwCodeBytes, 0 );
    if ( FAILED( hr ) )
    {
        SHADER_CONV_ASSERT(!"Disasm20() failed, hr = %d\n");
        return hr;
    }
#endif

    VSInputDecls  inputDecls(MAX_VS_INPUT_REGS);
    VSOutputDecls outputDecls;
    InputRegs     inputRegs;
    OutputRegs    outputRegs;
    VSUsageFlags  usageFlags;

    UINT minUsedConstantsF = 0xFFFFFFFF;
    UINT minUsedConstantsI = 0xFFFFFFFF;
    UINT minUsedConstantsB = 0xFFFFFFFF;

    UINT maxUsedConstantsF = 0;
    UINT maxUsedConstantsI = 0;
    UINT maxUsedConstantsB = 0;

    bool hasRelativeAddressF = false;

    BYTE ubNumTempRegs = SREG_SIZE;
    BYTE uiNumLoopRegs = 0;

    // Determine if inline shader constants is supported (only available to Dx9 and above)
    const bool bInlineConstsEnabled = (m_runtimeVersion >= 9);

    // Create the shader descriptor
    CVertexShaderDesc* pShaderDesc;
    hr = CVertexShaderDesc::Create( &pShaderDesc );
    if ( FAILED( hr ) )
    {
        SHADER_CONV_ASSERT(!"CVertexShaderDesc::Create() failed, hr = %d\n");
        return hr;
    }

    // Allocate instructions buffer
    DWORD* pdwInstrs = new DWORD [cbCodeSize];
    if ( NULL == pdwInstrs )
    {
        hr = E_OUTOFMEMORY;
        goto L_ERROR;
    }

    DWORD* pdwCurInstr = pdwInstrs;
    *pdwCurInstr++ = dwVersion;

    //
    // Parse the shader to find the input and output registers
    //

    const DWORD* pdwCurToken = pdwCodeBytes + 1;
    while ( *pdwCurToken != D3DVS_END() )
    {
        if ( static_cast<UINT>( reinterpret_cast<const BYTE*>( pdwCurToken ) -
                                reinterpret_cast<const BYTE*>( pdwCodeBytes ) ) > cbCodeSize )
        {
            SHADER_CONV_ASSERT(!"CTranslator::AnalyzeVS() failed, invalid shader\n");
            hr = E_FAIL;
            goto L_ERROR;
        }

        const DWORD dwInstr = *pdwCurToken;
        const UINT uiLength = __getInstrLength( dwInstr, dwVersion );
        const D3DSHADER_INSTRUCTION_OPCODE_TYPE opCode =
            (D3DSHADER_INSTRUCTION_OPCODE_TYPE)( dwInstr & D3DSI_OPCODE_MASK );

        switch ( opCode )
        {
        case D3DSIO_COMMENT:
        case D3DSIO_NOP:
            pdwCurToken += uiLength;
            continue;

        case D3DSIO_DCL:
            {
                const DWORD dwDclDesc = pdwCurToken[1];
                const DWORD dwDclReg  = pdwCurToken[2];
                const DWORD dwRegNum  = D3DSI_GETREGNUM( dwDclReg );
                const D3DSHADER_PARAM_REGISTER_TYPE regType = D3DSI_GETREGTYPE( dwDclReg );

                switch ( regType )
                {
                case D3DSPR_INPUT:
                    {
                        // Input registers declaration
                        const UINT usage      = D3DSI_GETUSAGE( dwDclDesc );
                        const UINT usageIndex = D3DSI_GETUSAGEINDEX( dwDclDesc );
                        const VSInputDecl *pDecl = pReferenceInputDecls->FindInputDecl(usage, usageIndex);
                        if (pDecl)
                        {
                            inputDecls.AddDecl(usage, usageIndex, dwRegNum, pDecl->IsTransformedPosition, pDecl->InputConversion);
                        }
                        else
                        {
                            inputDecls.AddDecl(usage, usageIndex, dwRegNum);
                        }
                    }
                    break;

                case D3DSPR_TEXCRDOUT:
                    {
                        // Output registers declaration
                        const UINT usage      = D3DSI_GETUSAGE( dwDclDesc );
                        const UINT usageIndex = D3DSI_GETUSAGEINDEX( dwDclDesc );
                        const UINT writeMask  = D3DSI_GETWRITEMASK( dwDclReg );
                        outputDecls.AddDecl( usage, usageIndex, dwRegNum, writeMask );

                        // Assign output register
                        SHADER_CONV_ASSERT( dwRegNum < MAX_VS_OUTPUT_REGS );
                        if ( INVALID_INDEX == outputRegs.O[dwRegNum] )
                        {                            
                            outputRegs.O[dwRegNum] = ubNumTempRegs++;
                        }
                    }
                    break;

                case D3DSPR_SAMPLER:
                    {
                        // Texture sampler declaration
                        SHADER_CONV_ASSERT( dwRegNum < MAX_VS_SAMPLER_REGS );
                        inputRegs.s[dwRegNum] =
                            (BYTE)__toTextureType( (D3DSAMPLER_TEXTURE_TYPE)( dwDclDesc & D3DSP_TEXTURETYPE_MASK ) );
                    }
                    break;

                default:
                    SHADER_CONV_ASSERT(!"CShaderDesc::CTranslator::AnalyzeVS() failed, invalid dcl instruction type: %d\n");
                    hr = E_FAIL;
                    goto L_ERROR;
                }
                pdwCurToken += uiLength;
            }
            continue;

        case D3DSIO_DEF:
            {
                const DWORD dwRegNum = D3DSI_GETREGNUM_RESOLVING_CONSTANTS( pdwCurToken[1] );
                hr = pShaderDesc->AddInlineConstsF( dwRegNum, reinterpret_cast<const FLOAT*>( &pdwCurToken[2] ) );
                if ( FAILED( hr ) )
                {
                    SHADER_CONV_ASSERT(!"CShaderDesc::AddInlineConstsF() failed, hr = %d\n");
                    goto L_ERROR;
                }
                pdwCurToken += uiLength;
            }
            continue;

        case D3DSIO_DEFI:
            {
                const DWORD dwRegNum = D3DSI_GETREGNUM_RESOLVING_CONSTANTS( pdwCurToken[1] );
                hr = pShaderDesc->AddInlineConstsI( dwRegNum, reinterpret_cast<const INT*>( &pdwCurToken[2] ) );
                if ( FAILED( hr ) )
                {
                    SHADER_CONV_ASSERT(!"CShaderDesc::AddInlineConstsI() failed, hr = %d\n");
                    goto L_ERROR;
                }
                pdwCurToken += uiLength;
            }
            continue;

        case D3DSIO_DEFB:
            {
                const DWORD dwRegNum = D3DSI_GETREGNUM_RESOLVING_CONSTANTS( pdwCurToken[1] );
                hr = pShaderDesc->AddInlineConstsB( dwRegNum, pdwCurToken[2] );
                if ( FAILED( hr ) )
                {
                    SHADER_CONV_ASSERT(!"CShaderDesc::AddInlineConstsB() failed, hr = %d\n");
                    goto L_ERROR;
                }
                pdwCurToken += uiLength;
            }
            continue;
        }

        *pdwCurInstr++ = *pdwCurToken++;

        // Check if the intruction has parameters
        if ( *pdwCurToken & ( 1L << 31 ) )
        {
            switch ( opCode )
            {
            case D3DSIO_REP:
            case D3DSIO_LOOP:

                // Allocate loop registers
                ++uiNumLoopRegs;

            case D3DSIO_CALL:
            case D3DSIO_CALLNZ:
            case D3DSIO_IF:
            case D3DSIO_IFC:
            case D3DSIO_BREAK:
            case D3DSIO_BREAKC:
            case D3DSIO_BREAKP:
            case D3DSIO_LABEL:
            case D3DSIO_TEXKILL:
                // No destination parameter
                break;

            default:

                // Parse destination parameter
                const DWORD dwDstToken = *pdwCurToken++;
                *pdwCurInstr++ = dwDstToken;

                const DWORD dwRegNum = D3DSI_GETREGNUM( dwDstToken );
                const D3DSHADER_PARAM_REGISTER_TYPE regType = D3DSI_GETREGTYPE( dwDstToken );
                const BOOL hasRelativeAddress = D3DSI_GETADDRESSMODE( dwDstToken ) & D3DSHADER_ADDRMODE_RELATIVE;

                switch ( regType )
                {
                case D3DSPR_RASTOUT:
                    switch ( dwRegNum )
                    {
                    case D3DSRO_POSITION:
                        if ( !outputDecls.Position )
                        {
                            outputDecls.AddDecl( D3DDECLUSAGE_POSITION, 0, VSOREG_Position, D3DSP_WRITEMASK_ALL );
                        }

                        if ( INVALID_INDEX == outputRegs.O[VSOREG_Position] )
                        {
                            outputRegs.O[VSOREG_Position] = ubNumTempRegs++;
                        }
                        break;

                    case D3DSRO_FOG:
                        if ( !outputDecls.Fog )
                        {
                            outputDecls.AddDecl( D3DDECLUSAGE_FOG, 0, VSOREG_FogPSize, D3DSP_WRITEMASK_0 );
                        }

                        if ( INVALID_INDEX == outputRegs.O[VSOREG_FogPSize] )
                        {
                            outputRegs.O[VSOREG_FogPSize] = ubNumTempRegs++;
                        }
                        break;

                    case D3DSRO_POINT_SIZE:
                        if ( !outputDecls.PointSize )
                        {
                            outputDecls.AddDecl( D3DDECLUSAGE_PSIZE, 0, VSOREG_FogPSize, D3DSP_WRITEMASK_1 );
                        }

                        if ( INVALID_INDEX == outputRegs.O[VSOREG_FogPSize] )
                        {
                            outputRegs.O[VSOREG_FogPSize] = ubNumTempRegs++;
                        }
                        break;

                    default:
                        SHADER_CONV_ASSERT(!"CTranslator::AnalyzeVS() failed, invalid register number: %d\n");
                        hr = E_FAIL;
                        goto L_ERROR;
                    }
                    break;

                case D3DSPR_ATTROUT:
                    {
                        const UINT regIndex = VSOREG_Color0 + dwRegNum;
                        if ( 0 == ( outputDecls.Colors & ( 1 << dwRegNum ) ) )
                        {
                            outputDecls.AddDecl( D3DDECLUSAGE_COLOR, dwRegNum, regIndex, D3DSP_WRITEMASK_ALL );
                        }

                        SHADER_CONV_ASSERT( dwRegNum < MAX_VS_COLOR_REGS );
                        if ( INVALID_INDEX == outputRegs.O[regIndex] )
                        {
                            outputRegs.O[regIndex] = ubNumTempRegs++;
                        }
                    }
                    break;

                case D3DSPR_TEXCRDOUT:
                    {
                        if ( dwVersion >= D3DVS_VERSION(3,0) )
                        {
                            // In VS 3.0, this register type is considered the default output register
                            // and can support addressing via the aL register
                            if ( hasRelativeAddress )
                            {
                                usageFlags.OutputRegsAddressing = 1;
                            }
                        }
                        else
                        {
                            const UINT regIndex = VSOREG_TexCoord0 + dwRegNum;

                            const DWORD dwWriteMask = D3DSI_GETWRITEMASK( dwDstToken );
                            outputDecls.AddDecl( D3DDECLUSAGE_TEXCOORD, dwRegNum, regIndex, dwWriteMask );

                            SHADER_CONV_ASSERT( dwRegNum < MAX_VS_TEXCOORD_REGS );
                            if ( INVALID_INDEX == outputRegs.O[regIndex] )
                            {
                                outputRegs.O[regIndex] = ubNumTempRegs++;
                            }
                        }
                    }
                    break;

                case D3DSPR_TEMP:
                    SHADER_CONV_ASSERT( dwRegNum < MAX_VS_TEMP_REGS );
                    if ( INVALID_INDEX == inputRegs.r[dwRegNum] )
                    {
                        inputRegs.r[dwRegNum] = ubNumTempRegs++;
                    }
                    break;

                case D3DSPR_ADDR:
                    if ( INVALID_INDEX == inputRegs.a0 )
                    {
                        inputRegs.a0 = ubNumTempRegs++;
                    }
                    break;

                case D3DSPR_PREDICATE:
                    if ( INVALID_INDEX == inputRegs.p0 )
                    {
                        inputRegs.p0 = ubNumTempRegs++;
                    }
                    break;

                default:
                    SHADER_CONV_ASSERT(!"CTranslator::AnalyzeVS() failed, invalid register type: %d\n");
                    hr = E_FAIL;
                    goto L_ERROR;
                }
            }

            // Skip the destination write predicate
            if ( dwInstr & D3DSHADER_INSTRUCTION_PREDICATED )
            {
                *pdwCurInstr++ = *pdwCurToken++;
            }

            // Parse source parameters
            while ( *pdwCurToken & ( 1L << 31 ) )
            {
                const DWORD dwSrcToken = *pdwCurToken++;
                *pdwCurInstr++ = dwSrcToken;

                const DWORD dwRegNum = D3DSI_GETREGNUM_RESOLVING_CONSTANTS( dwSrcToken );
                const D3DSHADER_PARAM_REGISTER_TYPE regType = D3DSI_GETREGTYPE_RESOLVING_CONSTANTS( dwSrcToken );
                const BOOL hasRelativeAddress = D3DSI_GETADDRESSMODE( dwSrcToken ) & D3DSHADER_ADDRMODE_RELATIVE;

                switch ( regType )
                {
                case D3DSPR_SAMPLER:
                case D3DSPR_INPUT:
                     // Already processed in D3DSIO_DCL.
                    break;

                case D3DSPR_TEMP:
                    SHADER_CONV_ASSERT( dwRegNum < MAX_VS_TEMP_REGS );
                    if ( INVALID_INDEX == inputRegs.r[dwRegNum] )
                    {
                        inputRegs.r[dwRegNum] = ubNumTempRegs++;
                    }
                    break;

                case D3DSPR_CONST:
                    if ( hasRelativeAddress )
                    {
                        hasRelativeAddressF = true;
                    }
                    for ( UINT i = dwRegNum, n = i + __getConstRegSize( opCode ); i < n; ++i )
                    {
                        if ( hasRelativeAddressF ||
                             !bInlineConstsEnabled ||
                             !pShaderDesc->FindInlineConstant( CB_FLOAT, i * 4 ) )
                        {
                            __mincountof( minUsedConstantsF, i );
                            __maxcountof( maxUsedConstantsF, i + 1 );
                        }
                    }
                    break;

                case D3DSPR_CONSTINT:
                    if ( !bInlineConstsEnabled ||
                         !pShaderDesc->FindInlineConstant( CB_INT, dwRegNum * 4 ) )
                    {
                        __mincountof( minUsedConstantsI, dwRegNum );
                        __maxcountof( maxUsedConstantsI, dwRegNum + 1 );
                    }
                    break;

                case D3DSPR_CONSTBOOL:
                    if ( !bInlineConstsEnabled ||
                         !pShaderDesc->FindInlineConstant( CB_BOOL, dwRegNum ) )
                    {
                        __mincountof( minUsedConstantsB, dwRegNum );
                        __maxcountof( maxUsedConstantsB, dwRegNum + 1 );
                    }
                    break;

                case D3DSPR_ADDR:
                    if ( INVALID_INDEX == inputRegs.a0 )
                    {
                       inputRegs.a0 = ubNumTempRegs++;
                    }
                    break;

                case D3DSPR_LOOP:
                    if ( INVALID_INDEX == inputRegs.aL )
                    {
                       inputRegs.aL = ubNumTempRegs++;
                    }
                    break;

                case D3DSPR_PREDICATE:
                    if ( INVALID_INDEX == inputRegs.p0 )
                    {
                        inputRegs.p0 = ubNumTempRegs++;
                    }
                    break;

                case D3DSPR_LABEL:
                    //--
                    break;

                default:
                    SHADER_CONV_ASSERT(!"CTranslator::AnalyzeVS() failed, invalid register type: %d\n");
                    hr = E_FAIL;
                    goto L_ERROR;
                }
            }
        }
    }

    *pdwCurInstr++ = D3DVS_END();

    if ( usageFlags.OutputRegsAddressing )
    {
        // Clear all allocated output registers
        for ( UINT i = 0; i < MAX_VS_OUTPUT_REGS; ++i )
        {
            outputRegs.O[i] = INVALID_INDEX;
        }
    }

    for (UINT i = 0, n = inputDecls.GetSize(); i < n; ++i)
    {
        const BYTE regIndex = inputDecls[i].RegIndex;
        const VSInputDecl *pDecl = pReferenceInputDecls->FindInputDecl(inputDecls[i].Usage, inputDecls[i].UsageIndex);
        if (pDecl)
        {
            if (inputDecls[i].InputConversion != VSInputDecl::None)
            {
                inputRegs.v[regIndex] = InputRegister(ubNumTempRegs++, InputRegister::Temp);
            }
            else
            {
                inputRegs.v[regIndex] = InputRegister(regIndex, InputRegister::Input);
            }
        }
    }

    // Check if user planes clipping is enabled
    if (rasterStates.UserClipPlanes)
    {
        // Declare clipping output registers
        this->DeclareClipplaneRegisters(outputDecls, rasterStates.UserClipPlanes);
    }


    // Copy shader instructions
#if DBG
    hr = pShaderDesc->CopyInstructions( pSrcBytes, cbCodeSize );
#else
    hr = pShaderDesc->CopyInstructions( pdwInstrs, (UINT)( pdwCurInstr - pdwInstrs ) * sizeof( DWORD ) );
#endif
    if ( FAILED( hr ) )
    {
        SHADER_CONV_ASSERT(!"CShaderDesc::CopyInstructions() failed, hr = %d\n");
        goto L_ERROR;
    }

    if (pdwInstrs) { delete[] pdwInstrs; }

    // Update the shader description
    pShaderDesc->SetVersion( dwVersion );
    pShaderDesc->SetUsageFlags( usageFlags );
    pShaderDesc->SetInputDecls( inputDecls );
    pShaderDesc->SetOutputDecls( outputDecls );
    pShaderDesc->SetInputRegs( inputRegs );
    pShaderDesc->SetOutputRegs( outputRegs );
    pShaderDesc->SetMinUsedConsts( CB_FLOAT, minUsedConstantsF * 4 );
    pShaderDesc->SetMinUsedConsts( CB_INT, minUsedConstantsI * 4 );
    pShaderDesc->SetMinUsedConsts( CB_BOOL, minUsedConstantsB );
    pShaderDesc->SetMaxUsedConsts( CB_FLOAT, maxUsedConstantsF * 4 );
    pShaderDesc->SetMaxUsedConsts( CB_INT, maxUsedConstantsI * 4 );
    pShaderDesc->SetMaxUsedConsts( CB_BOOL, maxUsedConstantsB );
    pShaderDesc->SetRelAddrConsts( CB_FLOAT, hasRelativeAddressF );
    pShaderDesc->SetNumTempRegs( ubNumTempRegs );
    pShaderDesc->SetNumLoopRegs( uiNumLoopRegs );
    pShaderDesc->SetShaderSettings( shaderSettings );

    // Set the returned shader description
    *ppShaderDesc = pShaderDesc;

    return S_OK;

L_ERROR:

    if ( pdwInstrs )
    {
        delete[] pdwInstrs;
    }

    __safeRelease( pShaderDesc );

    return hr;
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CTranslator::DeclareClipplaneRegisters(
    VSOutputDecls &outputDecls,
    UINT activeClipPlanesMask)
{
    UINT numClipPlanes = 0;

    // Calculate the number of active clip planes
    for (; activeClipPlanesMask; activeClipPlanesMask >>= 1)
    {
        if (activeClipPlanesMask & 1)
        {
            ++numClipPlanes;
        }
    }

    UINT writeMask = 0;

    // Build the register write mask
    switch (numClipPlanes % 4)
    {
    case 0: writeMask |= D3DSP_WRITEMASK_3;
    case 3: writeMask |= D3DSP_WRITEMASK_2;
    case 2: writeMask |= D3DSP_WRITEMASK_1;
    case 1: writeMask |= D3DSP_WRITEMASK_0;
    }

    if (numClipPlanes > 4)
    {
        outputDecls.AddDecl(D3DDECLUSAGE_CLIPDISTANCE, 0, VSOREG_ClipDist0, D3DSP_WRITEMASK_ALL);
        outputDecls.AddDecl(D3DDECLUSAGE_CLIPDISTANCE, 1, VSOREG_ClipDist1, writeMask);
    }
    else
    {
        outputDecls.AddDecl(D3DDECLUSAGE_CLIPDISTANCE, 0, VSOREG_ClipDist0, writeMask);
    }
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
HRESULT
CTranslator::TranslateVS( const CVertexShaderDesc* pShaderDesc,
                          const RasterStates& rasterStates,
                          CCodeBlob** ppCodeBlob )
{
    HRESULT hr;

    if ( NULL == pShaderDesc ||
         NULL == ppCodeBlob )
    {
        SHADER_CONV_ASSERT(!"CTranslator::TranslateVS() failed, invalid parameters\n");
        return E_INVALIDARG;
    }

#if DBG && WARP_INTERNAL

    // Disassemble input the shader code to the debug output
    hr = Disasm20( pShaderDesc->GetInstructions(), 0 );
    if ( FAILED( hr ) )
    {
        SHADER_CONV_ASSERT(!"Disasm20() failed, hr = %d\n");
        return hr;
    }

#endif

     // Create a new vertex shader context
    CVSContext* pContext = new CVSContext( m_runtimeVersion, pShaderDesc, rasterStates, m_pShaderAsm );
    if ( NULL == pContext )
    {
        return E_OUTOFMEMORY;
    }

    // Start the shader assembler
    // Note: Upgraded from SM 4.0 -> SM 5.0 because rcp is only supported on SM 5.0
    m_pShaderAsm->StartShader( D3D10_SB_VERTEX_SHADER, 5, 0, pShaderDesc->GetShaderSettings() );

    // Write the shader declarations
    hr = pContext->WriteDeclarations();
    if ( FAILED( hr ) )
    {
        __safeDelete( pContext );
        SHADER_CONV_ASSERT(!"CVSContext::WriteDeclarations() failed, hr = %d\n");
        return hr;
    }

    // Translate instructions
    hr = pContext->TranslateInstructions();
    if ( FAILED( hr ) )
    {
        __safeDelete( pContext );
        SHADER_CONV_ASSERT(!"CVSContext::TranslateInstructions() failed, hr = %d\n");
        return hr;
    }

    // Write the ouput registers
    pContext->WriteOutputs();

    // Delete the context
    __safeDelete( pContext );

    // End the shader assembler
    hr = m_pShaderAsm->EndShader();
    if ( FAILED( hr ) )
    {
        SHADER_CONV_ASSERT(!"CShaderAsm::EndShader() failed, hr = %d\n");
        return hr;
    }

    // Create the code blob
    hr = CCodeBlob::Create( m_pShaderAsm->ShaderSizeInDWORDs() * sizeof( UINT ),
                            m_pShaderAsm->GetShader(),
                            ppCodeBlob );
    if ( FAILED( hr ) )
    {
        SHADER_CONV_ASSERT(!"CCodeBlob::Create() failed, hr = %d\n");
        return hr;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
CVSContext::CVSContext( UINT runtimeVersion,
                        const CVertexShaderDesc* pShaderDesc,
                        const RasterStates& rasterStates,
                        CShaderAsmWrapper* pShaderAsm) :
    CContext( runtimeVersion, pShaderDesc, rasterStates, pShaderAsm ),
    m_usageFlags( pShaderDesc->GetUsageFlags() ),
    m_inputDecls( pShaderDesc->GetInputDecls() ),
    m_outputDecls( pShaderDesc->GetOutputDecls() )
{
    //--
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
HRESULT
CVSContext::WriteDeclarations()
{
    BYTE ubNumTempRegs = m_pShaderDesc->GetNumTempRegs();

    // Set the next loop register
    m_nextLoopRegister = ubNumTempRegs;

    // Calculate the total number of allocated temp registers
    BYTE uiTotalTempRegs = ubNumTempRegs  + m_pShaderDesc->GetNumLoopRegs();

    AllocateTempRegistersForUndeclaredInputs(m_inputDecls, uiTotalTempRegs);

    // Declare temp registers
    m_pShaderAsm->EmitTempsDecl( uiTotalTempRegs );

    // Declare indexable temp registers
    if ( m_usageFlags.OutputRegsAddressing )
    {
        m_pShaderAsm->EmitIndexableTempDecl( 0, MAX_VS_OUTPUT_REGS, 4 );
    }

    const UINT nFloatConstRegs = m_pShaderDesc->GetMaxUsedConsts( ShaderConv::CB_FLOAT );
    const UINT nIntConstRegs = m_pShaderDesc->GetMaxUsedConsts( CB_INT );
    const UINT nBoolConstRegs = m_pShaderDesc->GetMaxUsedConsts( CB_BOOL );

    // Declare floats constant buffers
    if ( nFloatConstRegs )
    {
        if ( m_pShaderDesc->HasRelAddrConsts( ShaderConv::CB_FLOAT ) )
        {
            // Qualcomm has problem with 0 size, so set maximum possbile size.
            // Also, while bool/int has separate limits on SM2.x/3.x, conservatively
            // substract those from float limit as well.
            //
            // nFloatConstRegs = 0; // ie any size
            m_pShaderAsm->EmitConstantBufferDecl(
                CB_FLOAT, 
                MAX_VS_CONSTANTSF - ((nIntConstRegs / 4) + (nBoolConstRegs / 4) + __sizeof16( VSCBExtension )),
                D3D10_SB_CONSTANT_BUFFER_DYNAMIC_INDEXED );
        }
        else
        {
            m_pShaderAsm->EmitConstantBufferDecl(
                CB_FLOAT, nFloatConstRegs / 4, D3D10_SB_CONSTANT_BUFFER_IMMEDIATE_INDEXED );
        }
    }

    // Declare intergers constant buffers
    if ( nIntConstRegs )
    {
        m_pShaderAsm->EmitConstantBufferDecl(
            CB_INT, nIntConstRegs / 4, D3D10_SB_CONSTANT_BUFFER_IMMEDIATE_INDEXED );
    }

    // Declare booleans constant buffers
    if ( nBoolConstRegs )
    {
        m_pShaderAsm->EmitConstantBufferDecl(
            CB_BOOL, ( nBoolConstRegs + 3 ) / 4, D3D10_SB_CONSTANT_BUFFER_IMMEDIATE_INDEXED );
    }

    // Declare extension constant buffer
    m_pShaderAsm->EmitConstantBufferDecl(
        CB_VS_EXT, __sizeof16( VSCBExtension ), D3D10_SB_CONSTANT_BUFFER_IMMEDIATE_INDEXED );

    // Declare vertex shader samplers
    for ( UINT i = 0; i < MAX_VS_SAMPLER_REGS; ++i )
    {
        TEXTURETYPE textureType = (TEXTURETYPE)m_inputRegs.s[i];
        if ( textureType != INVALID_INDEX )
        {
            // if reading from a specialized depth texture implicitly use a comparison 
            // sample for 'Hardware Shadow Maps'
            if (m_rasterStates.HardwareShadowMappingRequiredVS & (1 << i))
            {
                m_pShaderAsm->EmitSamplerDecl(i, D3D10_SB_SAMPLER_MODE_COMPARISON);
            }
            else
            {
                m_pShaderAsm->EmitSamplerDecl(i, D3D10_SB_SAMPLER_MODE_DEFAULT);
            }
            m_pShaderAsm->EmitResourceDecl( __toResourceDimension10( textureType ),
                                            i,
                                            D3D10_SB_RETURN_TYPE_FLOAT,
                                            D3D10_SB_RETURN_TYPE_FLOAT,
                                            D3D10_SB_RETURN_TYPE_FLOAT,
                                            D3D10_SB_RETURN_TYPE_FLOAT );
        }
    }

    // Declare input registers
    for ( UINT i = 0, n = m_inputDecls.GetSize(); i < n; ++i )
    {
        const UINT regIndex = m_inputDecls[i].RegIndex;
        if (m_inputRegs.v[regIndex].WriteMask() != 0)
        {
            m_pShaderAsm->EmitInputDecl(regIndex, D3D10_SB_OPERAND_4_COMPONENT_MASK_ALL);
        }
    }

    // Declare output registers
    for ( UINT i = 0, n = m_outputDecls.GetSize(); i < n; ++i )
    {
        const UINT usage      = m_outputDecls[i].Usage;
        const UINT usageIndex = m_outputDecls[i].UsageIndex;
        const UINT regIndex   = m_outputDecls[i].RegIndex;
        const UINT writeMask  = m_outputDecls[i].WriteMask << D3D10_SB_OPERAND_4_COMPONENT_MASK_SHIFT;

        if ( D3DDECLUSAGE_POSITION == usage &&
             0 == usageIndex )
        {
            // Declare the position ouput register
            m_pShaderAsm->EmitOutputSystemInterpretedValueDecl( regIndex, writeMask, D3D10_SB_NAME_POSITION );
        }
        else if (D3DDECLUSAGE_CLIPDISTANCE == usage)
        {
            m_pShaderAsm->EmitOutputSystemInterpretedValueDecl(regIndex, writeMask, D3D10_SB_NAME_CLIP_DISTANCE);
        }
        else
        {
            m_pShaderAsm->EmitOutputDecl( regIndex, writeMask );
        }
    }

    InitializeTempRegistersForUndeclaredInputs(m_inputDecls, uiTotalTempRegs);

    // In DX9, the input assembler would automatically convert int inputs to
    // float since shaders didn't support ints. In DX10+, this has been removed
    // so we need to emulate the input assembler conversion with itof
    for (UINT i = 0, n = m_inputDecls.GetSize(); i < n; ++i)
    {
        if (m_inputDecls[i].InputConversion != VSInputDecl::None)
        {
            const UINT regIndex = m_inputDecls[i].RegIndex;
            SHADER_CONV_ASSERT(m_inputRegs.v[regIndex].Reg() != INVALID_INDEX);

            switch (m_inputDecls[i].InputConversion)
            {
            case VSInputDecl::NeedsIntToFloatConversion:
            case VSInputDecl::UDEC3:
            {
                m_pShaderAsm->EmitInstruction(
                    CInstruction(D3D10_SB_OPCODE_ITOF,
                    CTempOperandDst(m_inputRegs.v[regIndex].Reg()),
                    CInputOperand4(regIndex)));
                if (m_inputDecls[i].InputConversion == VSInputDecl::UDEC3)
                {
                    // UDEC3 should have 1 for the alpha regardless of what 2 bits were in the input stream
                    m_pShaderAsm->EmitInstruction(
                        CInstruction(D3D10_SB_OPCODE_MOV,
                        CTempOperandDst(m_inputRegs.v[regIndex].Reg(), D3D10_SB_OPERAND_4_COMPONENT_MASK_W),
                        COperand(1.0f)));
                }
            } break;
            case VSInputDecl::DEC3N:
            {
                // First, sign extend to get a proper integer instead of a UINT
                m_pShaderAsm->EmitInstruction(
                    CInstruction(D3D11_SB_OPCODE_IBFE,  // integer bitfield extract
                    CTempOperandDst(SREG_TMP0),
                    COperand(10, 10, 10, 0),            // width of 10 for each 10bit value, and write 0 into w
                    COperand(0, 0, 0, 0),               // offset of 0
                    CInputOperand4(regIndex)));

                // Next, convert to float
                m_pShaderAsm->EmitInstruction(
                    CInstruction(D3D10_SB_OPCODE_ITOF,
                    CTempOperandDst(SREG_TMP1),
                    CTempOperand4(SREG_TMP0)));

                // Divide by 2^9-1
                m_pShaderAsm->EmitInstruction(
                    CInstruction(D3D10_SB_OPCODE_DIV,
                    CTempOperandDst(SREG_TMP2),
                    CTempOperand4(SREG_TMP1),
                    COperand(511.0f, 511.0f, 511.0f, 1.0f)));

                // The 10bit int was in [-512, 511] range, so clamp this value into [-1, 1]
                // and make sure there's a 1 instead of a 0 in w.
                m_pShaderAsm->EmitInstruction(
                    CInstruction(D3D10_SB_OPCODE_MAX,
                    CTempOperandDst(m_inputRegs.v[regIndex].Reg()),
                    CTempOperand4(SREG_TMP2),
                    COperand(-1.0f, -1.0f, -1.0f, 1.0f)));
            } break;
            }
        }

    }

    return S_OK;
}

///---------------------------------------------------------------------------
/// <summary>
/// </summary>
///---------------------------------------------------------------------------
void
CVSContext::WriteOutputs()
{
    if ( m_bOutputWritten )
    {
        return;
    }

    // Write to output registers
    for ( UINT i = 0, n = m_outputDecls.GetSize(); i < n; ++i )
    {
        const UINT usage      = m_outputDecls[i].Usage;
        const UINT usageIndex = m_outputDecls[i].UsageIndex;
        const UINT regIndex   = m_outputDecls[i].RegIndex;
        const UINT writeMask  = m_outputDecls[i].WriteMask << D3D10_SB_OPERAND_4_COMPONENT_MASK_SHIFT;

        COperandBase dstOperand;
        COperandBase srcOperand;

        if ( m_outputRegs.O[regIndex] != INVALID_INDEX )
        {
            dstOperand = CTempOperandDst( m_outputRegs.O[regIndex] );
            srcOperand = CTempOperand4( m_outputRegs.O[regIndex] );
        }
        else
        {
            dstOperand = CTempOperandDst2D( 0, regIndex );
            srcOperand = CTempOperand2D( 0, regIndex );
        }

        const COperandDst outputDst( D3D10_SB_OPERAND_TYPE_OUTPUT, regIndex, writeMask );

        bool bSaturate = false;
        bool bMovToOutputRegister = true;

        switch ( usage )
        {
#if 1 // start - pixel center workaround
        case D3DDECLUSAGE_POSITION:
            if ( 0 == usageIndex )
            {
                // If there is a clip plane, wsd e need to do the math before the half pixel offset,
                // otherwise the half pixel offset could potentially move the pixel from one side of 
                // the plane to the other.
                if (m_rasterStates.UserClipPlanes
                    && (D3DDECLUSAGE_POSITION == usage)
                    && (0 == usageIndex))
                {
                    // Output user-defined clipplane distances
                    this->WriteClipplanes(m_rasterStates.UserClipPlanes, srcOperand);
                }

                // Need to scale the XY coordinates by w/vp to math the D3D9 rasterization rule.
                // This is because D3D10 has a half-pixel offset to render target pixel centers
                // D3D9 screen space to D3D10 clipspace transformation:
                //
                // Xclip = ( Xscrn + 0.5 - ( VP.width/2 + VP.left ) ) * 2/VP.width * 1/Wscrn
                // Yclip = ( Yscrn + 0.5 - ( VP.height/2 + VP.top ) ) * -2/VP.height * 1/Wscrn
                // Zclip = ( Zscrn - VP.zmin ) * 2/VP.depth * 1/Wscrn
                // Wclip = 1/Wscrn
                //
                // Taking out the 0.5 factor out of the equation give the following equation:
                // Xclip = Xclip( D3D9 ) + Wclip/VP.width
                // Yclip = Yclip( D3D9 ) - Wclip/VP.height
                //
                // mad pos.xy, cb3[viewportscale].xy, pos.w, pos.xy
                m_pShaderAsm->EmitInstruction(
                    CInstruction(D3D10_SB_OPCODE_MAD,
                        CWriteMask( dstOperand, __WRITEMASK_XY ),
                        CCBOperand2D( CB_VS_EXT, VSCBExtension::VIEWPORTSCALE, __SWIZZLE_XY ),
                        CSwizzle( srcOperand, __SWIZZLE_W ),
                        CSwizzle( srcOperand, __SWIZZLE_XY ) ) );
            }
            break;
#endif // end - pixel center workaround
        case D3DDECLUSAGE_COLOR:
            bSaturate = ( m_version < D3DVS_VERSION(3,0) );
            break;

        case D3DDECLUSAGE_FOG:
            bSaturate = ( m_runtimeVersion < 9 );
            break;
        case D3DDECLUSAGE_CLIPDISTANCE:
            // Handled by WriteClipPlanes, required to be done before half pixel offset
            bMovToOutputRegister = false;
            break;
        }
        
        if (bMovToOutputRegister)
        {
            m_pShaderAsm->EmitInstruction(
                CInstructionEx(D3D10_SB_OPCODE_MOV, bSaturate, outputDst, srcOperand));
        }
    }

    m_bOutputWritten = true;
}

} // namespace ShaderConv

```

`external/ddithunk.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/*==========================================================================;
 *
 *  Copyright (C) 1994-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddithunk.h
 *  Content:    header file used by the NT DDI thunk layer
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   03-Dec-99  smac    Created it
 *
 ***************************************************************************/

#ifndef __DDITHUNK_INCLUDED__
#define __DDITHUNK_INCLUDED__

// Entire file should not be used in Win9x builds
#ifndef WIN95
#include <d3dkmthk.h>

#define MAX_ZSTENCIL_FORMATS    40

typedef struct _DDSURFHANDLE *PDDSURFHANDLE;
typedef struct _LHSURFHANDLE *PLHSURFHANDLE;
typedef struct _DEFERREDCREATE *PDEFERREDCREATE;

typedef struct _D3DCONTEXTHANDLE
{
    HANDLE                      dwhContext;
    DWORD                       dwFlags;
    struct _DDDEVICEHANDLE*     pDevice;
    DWORD                       dwPID;
    HANDLE                      hDeferHandle;
    struct _DDSURFHANDLE*       pSurface;
    struct _DDSURFHANDLE*       pDDSZ;
} D3DCONTEXTHANDLE, * PD3DCONTEXTHANDLE;

#define D3DCONTEXT_DEFERCREATE  0x00000001

typedef struct _GPUCONTEXTHANDLE *PGPUCONTEXTHANDLE;
typedef struct _GPUCONTEXTHANDLE
{
    D3DKMT_HANDLE                   hContext;
    PVOID                           pCachedCommandBuffer;
    UINT                            CachedCommandBufferSize;
    D3DDDI_ALLOCATIONLIST*          pCachedAllocationList;
    UINT                            CachedAllocationListSize;
    D3DDDI_PATCHLOCATIONLIST*       pCachedPatchLocationList;
    UINT                            CachedPatchLocationListSize;
    D3DGPU_VIRTUAL_ADDRESS          CachedCommandBuffer; // hideyukn_fix: should be unioned with above unused for advsch.
    PGPUCONTEXTHANDLE               pNextContext;
} GPUCONTEXTHANDLE, *PGPUCONTEXTHANDLE;

typedef enum _OVERLAYDWMSTATE
{
    OVERLAYSTATE_UNINITIALIZED = 0,
    OVERLAYSTATE_NODWM         = 1,
    OVERLAYSTATE_DWM           = 2
} OVERLAYDWMSTATE;

typedef struct _CONTENT_PROTECTION
{
    BOOL  ProtectionEnabled;
    BOOL  OverlayOrFullscreenRequired;
    BOOL  RDPDriverActive;
    UINT  DisplayUniqueness;
} CONTENT_PROTECTION;

typedef struct _HANDLE_LIST
{
    HANDLE* pList;
    UINT    Entries;
} HANDLE_LIST;

// Maximum number of cached shared redirection surfaces whose destruction is delayed until a space is needed in the cache
// to store a newer redirection surface, at which point surfaces are disposed of in a LRU fashion.
#define DDMAX_CACHED_REDIRECTION_SURFACES    8

typedef struct _DDDEVICEHANDLE
{
    union
    {
        HANDLE                  hDD;        // XDDM DD Local handle (for REF)
        D3DKMT_HANDLE           hDevice;    // LDDM KM device handle
    };
    DWLIST                      SurfaceHandleList;
    char                        szDeviceName[MAX_DRIVER_NAME];
    UINT                        AdapterIndex;
    LPDDRAWI_DIRECTDRAW_LCL     pDD;    // Used by Refrast and RGB HEL
    UINT                        DisplayUniqueness;
    PDDSURFHANDLE               pSurfList;
    PLHSURFHANDLE               pLHSurfList;
    PD3DCONTEXTHANDLE           pContext;
    D3DFORMAT                   DisplayFormatWithoutAlpha;
    D3DFORMAT                   DisplayFormatWithAlpha;
    UINT                        DisplayPitch;
    DWORD                       DriverLevel;
    RECT                        rcMonitor;
    DWORD                       dwVisUnique;    //updated after every SetVisRgn()
    VOID*                       pSwInitFunction;
    DWORD                       PCIID;
    DWORD                       DriverVersionHigh;
    DWORD                       DriverVersionLow;
    DWORD                       ForceFlagsOff;
    DWORD                       ForceFlagsOn;
    DWORD                       dwFlags;
    union
    {
        UINT                        DeviceFlags;        //bitwise flags defined by following booleans
        struct
        {
            UINT    bExclusiveMode          : 1;
            UINT    bDeviceLost             : 1;
            UINT    bIsWhistler             : 1;
            UINT    PresentRedirected       : 1;
            UINT    bLegacyMode             : 1;
            UINT    bRequestVSync           : 1;
            UINT    bRotationAware          : 1;
            UINT    bAsyncCallbacks         : 1; //True when async callbacks are enabled
            UINT    bDDIThreadingEnabled    : 1; //True when the DDI multithreading is enabled in the D3D runtime
            UINT    bAllowDriverMultithreading : 1; //True when the user mode driver is not allowed to use multithreading
            UINT    bMaster                 : 1; // This master device has subordinate devices associated with it
            UINT    PrimaryLockRectValid    : 1;
            UINT    bVideo                  : 1; // Indicates that the device is used for rendering video
            UINT    bCapsOnly               : 1; // Indicates that the device is not used for rendering, so we do not need to
                                                 // call the UMD's CreateDevice call (saves time and resources)
            UINT    bGpuVirtualAddressSupported : 1;
            UINT    bCheckedContentProtection   : 1;
            UINT    bSupportsContentProtection  : 1;
            UINT    bSupportsRestrictedAccess   : 1;
            UINT    bDisableOfferReclaim    : 1;
            UINT    bEmulatedLegacyMode     : 1;
            UINT    bDeferMarkDeviceAsError : 1;
            UINT    bSupportsMaximizedWindowedModeForGameDVR : 1;
        };
    };

    LONG volatile   bDeviceLostAsync;            //True when device is lost and async callbacks are enabled
                                                 //This was pulled out of the above union to avoid false data
                                                 //sharing on multiple threads

    UINT                            DeferredDeviceErrorReason;

    RECTL                           PrimaryLockRect;                // Valid only when PrimaryLockRectValid is true
    D3DKMT_HANDLE                   SharedPrimaryAllocationHandle;  // Device handle of shared primary    
    D3DKMT_DEVICEEXECUTION_STATE    ExecutionState;
    VOID*                           pCurrentFrontBuffer;
    DWORD                           DDCaps;
    DWORD                           SVBCaps;
    HANDLE                          hLibrary;
    PDEFERREDCREATE                 pDeferList;
    D3DDEVTYPE                      DeviceType;
    D3DKMT_PRESENT                  PresentKmtArg;        // Modified by the batch thread in batched present mode
    HANDLE                          hPresentLimitSemaphore;
    UINT64                          PresentLimitSemaphoreID;    
    UINT                            PresentLimitSemaphoreUsers;
    INT                             PresentLimitAdjust;
    BOOL volatile                   bPresentSubmitted;    // TRUE when a present DDI call has been made and the coressponding PresentCB call has not yet been made                   
    HRESULT                         PresentResult;        // Modified by the batch thread in batched present mode
    HRESULT                         SetDisplayModeResult;
    HANDLE                          hUMDrv;
    HANDLE                          hDrvInst;
    D3DDDI_DEVICEFUNCS              UMFunctions;
    D3DDDI_ADAPTERFUNCS             AdapterFunctions;
    D3DDDI_DEVICEFUNCS              CachedDeviceFunctions;
    D3DDDI_ADAPTERFUNCS             CachedAdapterFunctions;
    HANDLE                          hDriverAdapter;
#ifdef DWMREDIRECTION
    BOOL                            PresentRedirectionEnabled;

    // Redirection surface caching.
    struct
    {
        HANDLE  hSharedHandle;
        HANDLE  hRedirectionSurface;
    }
    CachedRedirectionSurfaceHandle[DDMAX_CACHED_REDIRECTION_SURFACES];

    // Video devices: DDMAX_CACHED_REDIRECTION_SURFACES,
    // Otherwise: 1.
    UCHAR                           RedirectionSurfaceCacheSize;
    UCHAR                           NumCachedRedirectionSurfaces;

    UINT                            RedirectionSurfaceCacheHit;
    UINT                            RedirectionSurfaceCacheMiss;    
#endif // DWMREDIRECTION
    SRWLOCK                         TrackedFencesSRWLock;
    TRACKED_FENCE**                 apTrackedFence;
    UINT                            TrackedFences;
    UINT                            TrackedFenceCapacity;
    UINT                            NumVidMemSurfaces;
    UINT                            NumDecodeRenderTargetFormats;
    GUID*                           pDeinterlaceGuids;
    UINT                            NumDeinterlaceGuids;
    D3DFORMAT*                      pDecodeRenderTargetFormats;
    D3DKMT_HANDLE                   hAdapter;
    LUID                            AdapterLuid;
    D3DDDI_VIDEO_PRESENT_SOURCE_ID  VidPnSourceId;
    D3DGAMMARAMP                    OrigGammaRamp;
    ULONGLONG                       TotalTexturePoolSize;
    ULONGLONG                       FreeTexturePoolSize;
    INT                             SchedulingPriority;
    UINT64                          PresentCount;
    ULONGLONG                       VistaBltPresentHistoryToken;
    UINT                            MaxHardwareFlipQueueLength;
    UINT                            MaxSoftwareFlipQueueLength;
    BOOL                            DriverSupportFlipIntervals;
    UINT                            MaxFrameLatency;
    D3DDDI_ROTATION                 DisplayOrientation;
    D3DDDI_VIDEO_SIGNAL_SCANLINE_ORDERING ScanLineOrdering; 
    PGPUCONTEXTHANDLE               DefaultGPUContext;
    SRWLOCK                         GPUContextListSRWLock;
    PGPUCONTEXTHANDLE               GPUContextList;
    HMONITOR                        hMasterMonitor;
    UINT                            DisplayWidth;
    UINT                            DisplayHeight;
    UINT                            DriverVersion;
    BOOL                            m_bSupportsWDDM1_3PerfDDIs;
    CONTENT_PROTECTION              ContentProtection;
    struct _DDDEVICEHANDLE*         pSubordinateDevices[D3DKMDT_MAX_VIDPN_SOURCES];
    HANDLE                          hOverlay;
    RECT                            OverlaySrcRect;
    RECT                            OverlayDstRect;
    RECT                            OverlayClientRect;
    UINT                            OverlayColorkey;
    UINT                            OverlayHardwareColorkey;
    UINT                            OverlayHardwareColorkeyUpper;
    UINT                            OverlayDisplayUniqueness;
    D3DFORMAT                       OverlayDisplayFormat;
    OVERLAYDWMSTATE                 OverlayDWMState;
    HANDLE_LIST                     RestrictedSharedSurfaces;
    HANDLE_LIST                     RestrictedSharedProcesses;
    ULONGLONG                       LastPresentQPCTime;
    D3DKMT_HANDLE                   hKernelOverlay;
    D3DKMT_WDDM_1_2_CAPS            Wddm12Caps;
    D3DKMT_ADAPTERTYPE              AdapterType;
    HANDLE                          hDDHybridChildDevice;
    UINT                            hPresentFence;
    UINT64                          uPresentSignalValue;
    UINT64                          uPresentWaitValue;
    BOOL                            bSingleVendorLda;
    BOOL                            bEverFullscreen;
    BOOL                            bEverAppSetFrameLimit;
    HANDLE                          hTrimNotification;
} DDDEVICEHANDLE, * PDDDEVICEHANDLE;

typedef struct
{
    UINT                            ModeCount;
    D3DKMT_DISPLAYMODE*             pModeList;
} DDMODEINFO;


//
// Synchronization around the members of DDDEVICEHANDLE and LHSURFHANDLE is important
// because this structure can be accessed by 2 threads on multi-processor systems.
// The main application thread can be accessing these members
// while the worker thread is accessing them inside a callback
//
// If a worker thread is inside of a runtime callback it must be the only
// thread in any callback reference a particular device.  Additionally
// DDDEVICEHANDLE::bAsyncCallbacks must be = TRUE
//
// In this case, the only variables that are written to by the worker thread are
// DDDEVICEHANDLE::bDeviceLostAsync and GPUContextList
// The write to bDeviceLostAsync is safe, because it is only read in a call to
// SetAsyncCallbacksCB(FALSE), which must be made only after the worker thread is flushed
// The write to GPUContextList is safe because the main app thread only access this list in the following
// circumstances:
//
// When destroying the device (after the user-mode device has been destroyed, and hence the worker thread has been flushed)
// When setting the GPU thread priority (the worker thread is flushed before this is done)
// 
//
// The worker thread reads DDDEVICEHANDLE::DefaultGPUContext
// and LHSURFHANDLE members that are initialized
// at surface/device creation time, and never changed again (like Format and Width)
// These reads are safe, because the values can't be changed while the worker thread is running
//

#define DDDEVICE_SUPPORTD3DBUF        0x00000001    // this device has D3DBuf callbacks
#define DDDEVICE_DP2ERROR             0x00000002    // A DP2 call failed
#define DDDEVICE_SUPPORTSUBVOLUMELOCK 0x00000004    // this device supports sub-volume texture lock
#define DDDEVICE_CANCREATESURFACE     0x00000008    // OK to call CanCreateSurface with this device
#define DDDEVICE_READY                0x00000010    // All vidmem surfs have been destroyed for this device
#define DDDEVICE_GETDRIVERINFO2       0x00000020    // Driver support the GetDriverInfo2 call
#define DDDEVICE_INITIALIZED          0x00000040    // The device has been initialized
#define DDDEVICE_GAMMASET             0x00000080    // A gamma ramp is currently set for this device
#define DDDEVICE_MPEG2IDCT            0x00000100    // The device supports MPEG2 IDCT
#define DDDEVICE_MPEG2VLD             0x00000200    // The device supports MPEG2 VLD
#define DDDEVICE_GETCOMPRESSEDCALLED  0x00000400    // DXVA GetCompressedBufferInfo has been called
#define DDDEVICE_QUERIEDPROCAMP       0x00000800    // Indicates we have queried for ProcAmp support
#define DDDEVICE_PROCAMPSUPPORTED     0x00001000    // Indicates that ProcAmp is supported

#ifdef DWMREDIRECTION
#define ISPRESENTREDIRECTED(x)  (((PDDDEVICEHANDLE)(x))->PresentRedirectionEnabled)    // Present needs to redirect
#else
#define ISPRESENTREDIRECTED(x)  NULL
#endif
#define DDHANDLE(x)  \
    (((PDDDEVICEHANDLE)(x))->hDD)

typedef struct _LHSURFHANDLE
{
    HANDLE                      hUMDriverResourceHandle;    // User mode driver returned handle
    UINT                        Index;      //sub resource index
    UINT                        MipCount;
    D3DKMT_HANDLE               hSurface;
    HANDLE                      hSharedHandle; // Cross process surface handle for redirection
    
    // Runtime resource data. Note that enumerants use D3D types, not DDI ones.
    // This data shadows the runtime information in this DDI accessible struct. Used by several functions:
    // a) Width and Height used by DWM redirected present, in DdBltLH
    // b) All of them by D3D9ResetDevice, when recreating the sysmem surfaces in the new device
    // c) All of them in AllocSurfaceWhenLost (when the surface is moved to sysmem while the device is lost)
    // d) All of them in DdLockLH (when the dummy sysmem surface is locked)
    D3DFORMAT                   Format;
    D3DRESOURCETYPE             ResourceType;
    UINT                        Width;
    UINT                        Height;
    UINT                        Depth;
    UINT                        FVF;            
    // These two are only shadowed for validation purposes when a shared surface is opened in-API
    D3DMULTISAMPLE_TYPE         MultiSampleType;
    UINT                        MultiSampleQuality;
    DWORD                       Usage;

    UINT                        LockRefCnt;
    D3DDDI_RESOURCEFLAGS        Caps;
    D3DDDI_POOL                 Pool;
    PDDDEVICEHANDLE             pDevice;
    UINT                        Flags;
    union
    {
        UINT                    ResourceFlags;  //bitwise flags defined by following booleans
        struct
        {
            UINT    bIsGdiPrimary           : 1;
            UINT    bMappedCompressedBuffer : 1;
            UINT    bRawDisplayModePrimary  : 1;
            UINT    bRotated                : 1;
            UINT    bAsyncLockable          : 1; //TRUE if a surface can be locked with asynchrounous lock flags
            UINT    bAsyncLocked            : 1; //TRUE if the surf is currently locked with the AsyncLock DDI    
            UINT    bReadOnly               : 1; //TRUE if surface is read only
            UINT    bRestrictedAccess       : 1; 
            UINT    bUserMemory             : 1; 
            UINT    bCrossAdapter           : 1;
        };
    };
    VOID*                           pSysmem;
    UINT                            SysmemPitch;    // Required for handling Locks/Creations when the device is removed
    UINT                            VidMemSize;
    UINT                            RawDisplayModeWidth;     // Due to NOAUTOROTATE feature, display mode width & Resource width
    UINT                            RawDisplayModeHeight;    // are not always equal. Therefore, they must be stored here for matching
    UINT                            RawDisplayModeFrequency; // against changing the display mode to the current display mode.
    HANDLE                          ApiSurfPointer; // API-visible surface pointer.  Used for event tracing only.
    HDC                             hDC;
    HBITMAP                         hBitmap;
    D3DDDI_VIDEO_PRESENT_SOURCE_ID  VidPnSourceIdOverride; // Used if LHSURF_HIDDENPRIMARY is set.

    struct _LHSURFHANDLE*       pNext;
    struct _LHSURFHANDLE*       pPrevious;
} LHSURFHANDLE, * PLHSURFHANDLE;

#define LHSURF_CREATESHARED             0x00000002      // Surface is created as shared
#define LHSURF_PICPARAMS                0x00000004      // Needs to stay in sync with DXVAMAPPER flag
#define LHSURF_MBCONTROLBUFF            0x00000008      // Needs to stay in sync with DXVAMAPPER flag
#define LHSURF_RESIDUALDIFFBUFF         0x00000010      // Needs to stay in sync with DXVAMAPPER flag
#define LHSURF_DEBLOCKBUFF              0x00000020      // Needs to stay in sync with DXVAMAPPER flag
#define LHSURF_INVERSEQUANTBUFF         0x00000040      // Needs to stay in sync with DXVAMAPPER flag
#define LHSURF_SLICEBUFF                0x00000080      // Needs to stay in sync with DXVAMAPPER flag
#define LHSURF_BITSTREAMBUFF            0x00000100      // Needs to stay in sync with DXVAMAPPER flag
#define LHSURF_SYSMEMALLOCATED          0x00000200      // Fake vidmem surface created while device lost
#define LHSURF_TREATASOUSTANDINGVIDMEM  0x00000400      // Used for DoVidmemSurfacesExist check
#define LHSURF_CREATEDWHILEDEVICELOST   0x00000800      // Surface created while device is lost
#define LHSURF_NONSECURE                0x00001000      // Allow surface to be opened by non-secure processes
#define LHSURF_DESTROYEDINRESETDEVICE   0x00002000      // Track which surfaces were invalidated due to our device lost handling
#define LHSURF_NTSHARING                0x00004000      // NT Handle sharing (introduced for Flip Model backbuffers)
#define LHSURF_DEFERREDFENCEWAITS       0x00008000      // Used for Flip Model backbuffers which can be used with deferred fence waits
#define LHSURF_UNSYNCHRONIZEDFLIPS      0x00010000      // Used to indicate that this resource can be flipped immediately in dFlip or iFlip
#define LHSURF_HIDDENPRIMARY            0x00020000      // Kernel needs to see primary flag but not the UMD.

typedef struct _DDSURFHANDLE
{
    DWORD                       dwCookie;   // CreateSurfaceEx handle
    HANDLE                      hSurface;   // Kernel mode surface handle
    HANDLE                      hSharedHandle; // Cross process surface handle for redirection
    D3DPOOL                     Pool;       // Location of surface
    D3DFORMAT                   Format;
    D3DRESOURCETYPE             Type;       // What kind of surface it is
    ULONG_PTR                   fpVidMem;
    DWORD                       dwLinearSize;
    LONG                        lPitch;
    LPDDRAWI_DDRAWSURFACE_LCL   pLcl;
    PDDDEVICEHANDLE             pDevice;
    PDDDEVICEHANDLE             pDeviceMaster; // Used only with additional primary surface
    DWORD                       dwFlags;
    DWORD                       dwWidth;
    DWORD                       dwHeight;
    DWORD                       dwDepth;
    LONG                        lSlicePitch; // Offset to next slice for volume texture
    struct _DDSURFHANDLE*       pNext;
    struct _DDSURFHANDLE*       pPrevious;
    UINT                        LockRefCnt;
    HDC                         hDC;
    HBITMAP                     hBitmap;

#ifdef DEBUG
    DWORD                       dwUsage;
#endif // DEBUG
} DDSURFHANDLE, * PDDSURFHANDLE;

typedef struct _DEFERREDCREATE
{
    D3D9_CREATESURFACEDATA      CreateData;
    BOOL                        bLightWeight;
    struct _DEFERREDCREATE     *pNext;
} DEFERREDCREATE, *PDEFERREDCREATE;

#define DDSURF_SYSMEMALLOCATED      0x00000001
#define DDSURF_DEFERCREATEEX        0x00000002
#define DDSURF_HAL                  0x00000004
#define DDSURF_SOFTWARE             0x00000008
#define DDSURF_CREATECOMPLETE       0x00000010
#define DDSURF_TREATASVIDMEM        0x00000020      // Flag to indicate that surf should
                                                    // be treated as vid-mem for the
                                                    // "do vid-mem surfaces exist" case
#define DDSURF_ADDITIONALPRIMARY    0x00000040
#define DDSURF_LHHANDLE             0x00000100

#define IS_SOFTWARE_DRIVER(x)                                       \
    (((PDDDEVICEHANDLE)(x))->pDD != NULL)

#define IS_SOFTWARE_DRIVER_SURFACE(x)                               \
    (((PDDSURFHANDLE)(x))->dwFlags & DDSURF_SOFTWARE)

#define IS_SURFACE_LOOSABLE(x)                                      \
    (!IS_SOFTWARE_DRIVER_SURFACE(x) &&                              \
    ((((PDDSURFHANDLE)(x))->Pool == D3DPOOL_LOCALVIDMEM) ||        \
    (((PDDSURFHANDLE)(x))->Pool == D3DPOOL_NONLOCALVIDMEM)))

__inline HANDLE GetSurfHandle(HANDLE hSurface)
{
    if(hSurface)
    {
        return(((PDDSURFHANDLE)hSurface)->hSurface);
    }
    return NULL;
}

__inline D3DRESOURCETYPE GetSurfType(HANDLE hSurface)
{
    if(hSurface)
    {
        return(((PDDSURFHANDLE)hSurface)->Type);
    }
    return (D3DRESOURCETYPE) 0;
}

typedef enum _DXVATYPE {
    DXVATYPE_DECODE         = 1,
    DXVATYPE_DEINTERLACE    = 2,
    DXVATYPE_PROCAMP        = 3,
    DXVATYPE_CONTAINER      = 4,
    DXVATYPE_EXTENSION      = 5,
    DXVATYPE_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
} DXVATYPE;

typedef struct _DXVAMAPPER
{
    UINT                          Flags;
    DXVATYPE                      Type;
    HANDLE                        hDxva;
    HRESULT                       PreviousError;
    GUID                          Guid;
    UINT                          Width;
    UINT                          Height;
    D3DFORMAT                     Format;
    DXVADDI_CONFIGPICTUREDECODE   LockedConfig;
    DXVADDI_DECODEBUFFERDESC      PictureParamsHeader;
    HANDLE                        hPictureParamsResource;
    UINT                          PictureParamsResourceIndex;
    DXVADDI_DECODEBUFFERDESC      MBControlHeader;
    HANDLE                        hMBControlResource;
    UINT                          MBControlSubResourceIndex;
    DXVADDI_DECODEBUFFERDESC      ResidualDiffHeader;
    HANDLE                        hResidualDiffResource;
    UINT                          ResidualDiffSubResourceIndex;
    DXVADDI_DECODEBUFFERDESC      DeblockingControlHeader;
    HANDLE                        hDeblockingControlResource;
    UINT                          DeblockingControlSubResourceIndex;
    DXVADDI_DECODEBUFFERDESC      InverseQuantizationHeader;
    HANDLE                        hInverseQuantizationResource;
    UINT                          InverseQuantizationSubResourceIndex;
    DXVADDI_DECODEBUFFERDESC      SliceControlHeader;
    HANDLE                        hSliceControlResource;
    UINT                          SliceControlSubResourceIndex;
    DXVADDI_DECODEBUFFERDESC      BitStreamHeader;
    HANDLE                        hBitStreamResource;
    UINT                          BitStreamSubResourceIndex;
    DXVADDI_VIDEOSAMPLE*          pDeinterlaceSampleBuffer;
    UINT                          DeinterlaceSampleBufferSize;
} DXVAMAPPER;

#define DXVAFLAG_NODEVICE        0x00000001
#define DXVAFLAG_PICPARAMSSET    LHSURF_PICPARAMS
#define DXVAFLAG_MBCONTROLSET    LHSURF_MBCONTROLBUFF
#define DXVAFLAG_RESIDUALDIFFSET LHSURF_RESIDUALDIFFBUFF
#define DXVAFLAG_DEBLOCKSET      LHSURF_DEBLOCKBUFF
#define DXVAFLAG_INVERSEQUANTSET LHSURF_INVERSEQUANTBUFF
#define DXVAFLAG_SLICESET        LHSURF_SLICEBUFF
#define DXVAFLAG_BITSTREAMSET    LHSURF_BITSTREAMBUFF
#define DXVAFLAG_CONFIGLOCKED    0x00000200

#define DXVAFLAG_BUFFERMASK      (DXVAFLAG_PICPARAMSSET | DXVAFLAG_MBCONTROLSET | DXVAFLAG_RESIDUALDIFFSET | \
                                  DXVAFLAG_DEBLOCKSET | DXVAFLAG_INVERSEQUANTSET | DXVAFLAG_SLICESET | DXVAFLAG_BITSTREAMSET)

#define _FACD3D  0x876
#define MAKE_D3DHRESULT( code )  MAKE_HRESULT( 1, _FACD3D, code )
#define MAKE_D3DSTATUS( code )  MAKE_HRESULT( 0, _FACD3D, code )

//
// !!! Make sure that these values are the same as in d3d9.w !!!
//

#define D3DERR_WASSTILLDRAWING                  MAKE_D3DHRESULT(540)
#define D3DERR_DEVICELOST                       MAKE_D3DHRESULT(2152)
#define D3DERR_DEVICEREMOVED                    MAKE_D3DHRESULT(2160)
#define D3DERR_DRIVERINTERNALERROR              MAKE_D3DHRESULT(2087)
#define D3DERR_NOTAVAILABLE                     MAKE_D3DHRESULT(2154)
#define D3DERR_OUTOFVIDEOMEMORY                 MAKE_D3DHRESULT(380)
#define D3DERR_DEFERRED_DP2ERROR                MAKE_D3DHRESULT(2158)
#define S_PRESENT_MODE_CHANGED                  MAKE_D3DSTATUS(2167)
#define S_PRESENT_OCCLUDED                      MAKE_D3DSTATUS(2168)
#define D3DERR_DEVICEHUNG                       MAKE_D3DHRESULT(2164)

// Function protoptypes

extern LPDDRAWI_DIRECTDRAW_LCL SwDDICreateDirectDraw( void);
extern void SwDDIMungeCaps (HINSTANCE hLibrary, HANDLE hDD, PD3D9_DRIVERCAPS pDriverCaps, PD3D9_CALLBACKS pCallbacks, LPDDSURFACEDESC, UINT*, D3DQUERYTYPE*, UINT*, VOID* pSwInitFunction);
extern LPDDRAWI_DDRAWSURFACE_LCL SwDDIBuildHeavyWeightSurface (LPDDRAWI_DIRECTDRAW_LCL, PD3D9_CREATESURFACEDATA pCreateSurface, DD_SURFACE_LOCAL* pSurfaceLocal, DD_SURFACE_GLOBAL* pSurfaceGlobal, DD_SURFACE_MORE* pSurfaceMore, DWORD index);
extern void SwDDICreateSurfaceEx(LPDDRAWI_DIRECTDRAW_LCL pDrv, LPDDRAWI_DDRAWSURFACE_LCL pLcl);
extern void SwDDIAttachSurfaces (LPDDRAWI_DDRAWSURFACE_LCL pFrom, LPDDRAWI_DDRAWSURFACE_LCL pTo);
extern HRESULT SwDDICreateSurface( PD3D9_CREATESURFACEDATA pCreateSurface, DD_SURFACE_LOCAL* pDDSurfaceLocal, DD_SURFACE_GLOBAL* pDDSurfaceGlobal, DD_SURFACE_MORE*  pDDSurfaceMore);
extern void AddUnknownZFormats( UINT NumFormats, DDPIXELFORMAT* pFormats, UINT* pNumUnknownFormats, D3DFORMAT* pUnknownFormats);
extern DWORD SwDDILock( HANDLE hDD, PDDSURFHANDLE   pSurf, DD_LOCKDATA* pLockData);
extern DWORD SwDDIUnlock( HANDLE hDD, PDDSURFHANDLE   pSurf, DD_UNLOCKDATA* pUnlockData);
extern DWORD SwDDIDestroySurface( HANDLE hDD, PDDSURFHANDLE pSurf);
extern HRESULT MapLegacyResult(HRESULT hr);
extern HRESULT CreateDeviceLHDDI(HDC hDC, PDDDEVICEHANDLE pDeviceHandle, BOOL bDeferTrimRegistration);
extern void DestroyDeviceLHDDI(PDDDEVICEHANDLE pDevice, BOOL bDDIOnly);
extern BOOL QueryLHDDICaps(__inout PDDDEVICEHANDLE         pDevice,
                           HINSTANCE                       hLibrary,
                           __inout PD3D9_DRIVERCAPS        pDriverCaps,
                           __inout PD3D9_CALLBACKS         pCallbacks,
                           __in LPSTR                      pDeviceName,
                           __out_opt LPDDSURFACEDESC       pTextureFormats,
                           __out_opt D3DDISPLAYMODE*       pExtendedModeFormats,
                           __out_opt D3DQUERYTYPE*         pQueries,
                           __inout UINT*                   pcTextureFormats,
                           __inout UINT*                   pcExtendedModeFormats,
                           __inout UINT*                   pcQueries,
                           BOOL                            bUpdateDisplayModeOnly);
extern DWORD GetDriverInfo2LH(DWORD* pdwDrvRet, PDDDEVICEHANDLE pDevice, DWORD Type, DWORD Size, void* pBuffer);
extern HRESULT BuildModeTableLH(PD3D9_DEVICEDATA pDD, D3DDISPLAYMODEEX** ppModeTable, DWORD* pNumEntries, DWORD* pNumUnprunedEntries);
extern HRESULT APIENTRY DdCreateSurfaceLH(PD3D9_CREATESURFACEDATA pCreateSurface);
extern HRESULT APIENTRY DdDestroySurfaceLH(PD3D8_DESTROYSURFACEDATA pDestroySurface);
extern DWORD APIENTRY DdBltLH(PD3D8_BLTDATA pBlt);
extern HRESULT APIENTRY DdLockLH(PD3D8_LOCKDATA pLock);
extern HRESULT APIENTRY DdUnlockLH(PD3D8_UNLOCKDATA pUnlock);
extern DWORD APIENTRY DdFlipLH(PD3D8_FLIPDATA pFlip);
extern VOID LoseDeviceLH(PDDDEVICEHANDLE pDeviceHandle);
extern VOID LoseDeviceWithReasonLH(PDDDEVICEHANDLE pDeviceHandle, D3DKMT_DEVICE_ERROR_REASON Reason);
extern BOOL CanRestoreNowLH(PDDDEVICEHANDLE pDeviceHandle);
extern VOID RestoreDeviceLH(PDDDEVICEHANDLE pDevice);
extern BOOL DdSetGammaRampLH(PDDDEVICEHANDLE pDevice, PDDDEVICEHANDLE pMaster, LPVOID pGammaRamp);
extern HRESULT APIENTRY D3D9SetDisplayModeLH(HANDLE hDevice, HANDLE hMaster, HANDLE hPrimarySurf);

extern HRESULT APIENTRY DdCreateSurface(PD3D9_CREATESURFACEDATA pCreateSurface);
extern DWORD APIENTRY DdDestroySurface(PD3D8_DESTROYSURFACEDATA pDestroySurface);
extern HRESULT APIENTRY DdLock(PD3D8_LOCKDATA pLock);
extern HRESULT APIENTRY DdUnlock(PD3D8_UNLOCKDATA pUnlock);
extern DWORD WINAPI DdBlt(PD3D8_BLTDATA pBlt);
extern DWORD APIENTRY DdFlip(PD3D8_FLIPDATA pFlip);

extern BOOL CheckForDeviceLost (HANDLE hDD);

#endif // !WIN95

#endif // __DDITHUNK_INCLUDED__


```

`include/9on12.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#pragma once

#ifdef __cplusplus
extern "C"
#endif
PFND3DDDI_OPENADAPTER Get9on12OpenAdapter();

```

`include/9on12Adapter.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#pragma once

namespace D3D9on12
{
    class Adapter
    {
    public:
        Adapter( _Inout_ D3DDDIARG_OPENADAPTER& OpenAdapter, LUID* pAdapterLUID, D3D9ON12_CREATE_DEVICE_ARGS2* pArgs );

        ~Adapter();

        HRESULT Destroy();

        static FORCEINLINE HANDLE GetHandleFromAdapter(Adapter* pAdapter){ return static_cast<HANDLE>(pAdapter); }
        static FORCEINLINE Adapter* GetAdapterFromHandle(HANDLE hAdapter){ return static_cast<Adapter*>(hAdapter); }

        CONST D3DDDI_ADAPTERCALLBACKS& GetRuntimeCallbacks() { return m_AdapterCallbacks; }
        
        void GetVideoCaps(_Inout_ CONST D3DDDIARG_GETCAPS* pGetCaps);
        void DeviceCreated(_In_ Device *pDevice) { m_pDevice = pDevice; }
        void DeviceDestroyed(_In_ Device *pDevice) { UNREFERENCED_PARAMETER(pDevice);  assert(pDevice == m_pDevice);  m_pDevice = nullptr; }

        static const UINT MAX_SURFACE_FORMATS = 48;
        UINT GetFormatData(FORMATOP* pFormatOPs, UINT uiNumFormats = 0);

        ID3D12Device *GetDevice() { return m_pD3D12Device; }
        ID3D12CommandQueue *GetCommandQueue() { return m_pD3D12CommandQueue; }

        bool SupportsCastingTypelessResources() { return m_bSupportsCastingTypelessResources; }
        bool RequiresYUY2BlitWorkaround() const;

    protected:
        virtual void LogAdapterCreated( LUID *pluid, HRESULT hr );

    private:
        void InitDebugLayer();

        CONST D3DDDI_ADAPTERCALLBACKS& m_AdapterCallbacks;
        bool m_bSupportsCastingTypelessResources;
        Device *m_pDevice;      // weak-ref

        CComPtr<ID3D12Device> m_pD3D12Device;
        CComPtr<ID3D12CommandQueue> m_pD3D12CommandQueue;
        DXCoreHardwareID m_HWIDs;
        uint64_t m_DriverVersion;

    public:
        const D3D9ON12_PRIVATE_CALLBACKS m_privateCallbacks;

        const bool m_bSupportsNewPresent;
        const bool m_bSupportsShaderSigning;
    };
};

```

`include/9on12AppCompat.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#pragma once

namespace D3D9on12
{
    extern D3D9ON12_APP_COMPAT_INFO g_AppCompatInfo;
};
```

`include/9on12Caps.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#pragma once

namespace D3D9on12
{
    static const D3DCAPS9 cD3D9Caps =
    {
        // DeviceType  
        D3DDEVTYPE_HAL,
        // AdapterOrdinal  
        0,
        // Caps  
        DDCAPS_BLTFOURCC |
        D3DCAPS_READ_SCANLINE |
        //D3DCAPS_OVERLAY |      
        0,
        // Caps2  
        D3DCAPS2_CANAUTOGENMIPMAP |
        D3DCAPS2_FULLSCREENGAMMA |
        //D3DCAPS2_CANMANAGERESOURCE |  
        D3DCAPS2_DYNAMICTEXTURES |
        D3DCAPS2_CANSHARERESOURCE |
        //D3DCAPS2_CANCALIBRATEGAMMA |     
        0,
        // Caps3  
        //D3DCAPS3_RESERVED  
        D3DCAPS3_ALPHA_FULLSCREEN_FLIP_OR_DISCARD |
        //D3DCAPS3_MANAGEDDEVICE |  
        D3DCAPS3_LINEAR_TO_SRGB_PRESENTATION |
        D3DCAPS3_COPY_TO_VIDMEM |
        D3DCAPS3_COPY_TO_SYSTEMMEM |
        D3DCAPS3_DXVAHD |
        //D3DCAPS3_DXVAHD_LIMITED |  
        0,
        // PresentationIntervals  
        D3DPRESENT_INTERVAL_ONE |
        D3DPRESENT_INTERVAL_TWO |
        D3DPRESENT_INTERVAL_THREE |
        D3DPRESENT_INTERVAL_FOUR |
        D3DPRESENT_INTERVAL_IMMEDIATE |
        0,
        // CursorCaps  
        D3DCURSORCAPS_COLOR,
        // DevCaps  
        //D3DDEVCAPS_FLOATTLVERTEX |  
        //D3DDEVCAPS_SORTINCREASINGZ |  
        //D3DDEVCAPS_SORTDECREASINGZ |  
        //D3DDEVCAPS_SORTEXACT |  
        D3DDEVCAPS_EXECUTESYSTEMMEMORY |
        D3DDEVCAPS_EXECUTEVIDEOMEMORY |
        D3DDEVCAPS_TLVERTEXSYSTEMMEMORY |
        D3DDEVCAPS_TLVERTEXVIDEOMEMORY |
        D3DDEVCAPS_TEXTURESYSTEMMEMORY |
        D3DDEVCAPS_TEXTUREVIDEOMEMORY |
        D3DDEVCAPS_DRAWPRIMTLVERTEX |
        D3DDEVCAPS_CANRENDERAFTERFLIP |
        D3DDEVCAPS_TEXTURENONLOCALVIDMEM |
        D3DDEVCAPS_DRAWPRIMITIVES2 |
        //D3DDEVCAPS_SEPARATETEXTUREMEMORIES |  
        D3DDEVCAPS_DRAWPRIMITIVES2EX |
        D3DDEVCAPS_HWTRANSFORMANDLIGHT |
        D3DDEVCAPS_CANBLTSYSTONONLOCAL |
        D3DDEVCAPS_HWRASTERIZATION |
        D3DDEVCAPS_PUREDEVICE |
        //D3DDEVCAPS_QUINTICRTPATCHES |  
        //D3DDEVCAPS_RTPATCHES |  
        //D3DDEVCAPS_RTPATCHHANDLEZERO |  
        //D3DDEVCAPS_NPATCHES |  
        D3DDEVCAPS_HWVERTEXBUFFER |
        D3DDEVCAPS_HWINDEXBUFFER |
        0,
        // PrimitiveMiscCaps  
        //D3DPMISCCAPS_MASKPLANES  
        D3DPMISCCAPS_MASKZ |
        //D3DPMISCCAPS_LINEPATTERNREP |  
        //D3DPMISCCAPS_CONFORMANT |  
        D3DPMISCCAPS_CULLNONE |
        D3DPMISCCAPS_CULLCW |
        D3DPMISCCAPS_CULLCCW |
        D3DPMISCCAPS_COLORWRITEENABLE |
        D3DPMISCCAPS_CLIPPLANESCALEDPOINTS |
        D3DPMISCCAPS_CLIPTLVERTS |
        D3DPMISCCAPS_TSSARGTEMP |
        D3DPMISCCAPS_BLENDOP |
        //D3DPMISCCAPS_NULLREFERENCE |  
        D3DPMISCCAPS_FOGINFVF |
        D3DPMISCCAPS_INDEPENDENTWRITEMASKS |
        D3DPMISCCAPS_PERSTAGECONSTANT |
        D3DPMISCCAPS_SEPARATEALPHABLEND |
        D3DPMISCCAPS_MRTINDEPENDENTBITDEPTHS |
        D3DPMISCCAPS_MRTPOSTPIXELSHADERBLENDING |
        //D3DPMISCCAPS_FOGVERTEXCLAMPED |  
        D3DPMISCCAPS_POSTBLENDSRGBCONVERT |
        0,
        // RasterCaps,  
        D3DPRASTERCAPS_DITHER |  
        //D3DPRASTERCAPS_ROP2 |  
        //D3DPRASTERCAPS_XOR |  
        //D3DPRASTERCAPS_PAT |  
        D3DPRASTERCAPS_ZTEST |
        //D3DPRASTERCAPS_SUBPIXEL |  
        //D3DPRASTERCAPS_SUBPIXELX |  
        D3DPRASTERCAPS_FOGVERTEX |
        D3DPRASTERCAPS_FOGTABLE |
        //D3DPRASTERCAPS_STIPPLE |  
        //D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT |  
        //D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT |  
        //D3DPRASTERCAPS_ANTIALIASEDGES |  
        D3DPRASTERCAPS_MIPMAPLODBIAS |
        //D3DPRASTERCAPS_ZBIAS |  
        //D3DPRASTERCAPS_ZBUFFERLESSHSR |  
        D3DPRASTERCAPS_FOGRANGE |
        D3DPRASTERCAPS_ANISOTROPY |
        //D3DPRASTERCAPS_WBUFFER |  
        //D3DPRASTERCAPS_TRANSLUCENTSORTINDEPENDENT |  
        D3DPRASTERCAPS_WFOG |
        D3DPRASTERCAPS_ZFOG |
        D3DPRASTERCAPS_COLORPERSPECTIVE |
        //D3DPRASTERCAPS_STRETCHBLTMULTISAMPLE |  
        D3DPRASTERCAPS_SCISSORTEST |
        D3DPRASTERCAPS_SLOPESCALEDEPTHBIAS |
        D3DPRASTERCAPS_DEPTHBIAS |
        D3DPRASTERCAPS_MULTISAMPLE_TOGGLE |
        0,
        // ZCmpCaps  
        D3DPCMPCAPS_NEVER |
        D3DPCMPCAPS_LESS |
        D3DPCMPCAPS_EQUAL |
        D3DPCMPCAPS_LESSEQUAL |
        D3DPCMPCAPS_GREATER |
        D3DPCMPCAPS_NOTEQUAL |
        D3DPCMPCAPS_GREATEREQUAL |
        D3DPCMPCAPS_ALWAYS |
        0,
        // SrcBlendCaps  
        D3DPBLENDCAPS_ZERO |
        D3DPBLENDCAPS_ONE |
        D3DPBLENDCAPS_SRCCOLOR |
        D3DPBLENDCAPS_INVSRCCOLOR |
        D3DPBLENDCAPS_SRCALPHA |
        D3DPBLENDCAPS_INVSRCALPHA |
        D3DPBLENDCAPS_DESTALPHA |
        D3DPBLENDCAPS_INVDESTALPHA |
        D3DPBLENDCAPS_DESTCOLOR |
        D3DPBLENDCAPS_INVDESTCOLOR |
        D3DPBLENDCAPS_SRCALPHASAT |
        D3DPBLENDCAPS_BOTHSRCALPHA |
        D3DPBLENDCAPS_BOTHINVSRCALPHA |
        D3DPBLENDCAPS_BLENDFACTOR |
        D3DPBLENDCAPS_SRCCOLOR2 |
        D3DPBLENDCAPS_INVSRCCOLOR2 |
        0,
        // DestBlendCaps  
        D3DPBLENDCAPS_ZERO |
        D3DPBLENDCAPS_ONE |
        D3DPBLENDCAPS_SRCCOLOR |
        D3DPBLENDCAPS_INVSRCCOLOR |
        D3DPBLENDCAPS_SRCALPHA |
        D3DPBLENDCAPS_INVSRCALPHA |
        D3DPBLENDCAPS_DESTALPHA |
        D3DPBLENDCAPS_INVDESTALPHA |
        D3DPBLENDCAPS_DESTCOLOR |
        D3DPBLENDCAPS_INVDESTCOLOR |
        D3DPBLENDCAPS_SRCALPHASAT |
        D3DPBLENDCAPS_BOTHSRCALPHA |
        D3DPBLENDCAPS_BOTHINVSRCALPHA |
        D3DPBLENDCAPS_BLENDFACTOR |
        D3DPBLENDCAPS_SRCCOLOR2 |
        D3DPBLENDCAPS_INVSRCCOLOR2 |
        0,
        // AlphaCmpCaps  
        D3DPCMPCAPS_NEVER |
        D3DPCMPCAPS_LESS |
        D3DPCMPCAPS_EQUAL |
        D3DPCMPCAPS_LESSEQUAL |
        D3DPCMPCAPS_GREATER |
        D3DPCMPCAPS_NOTEQUAL |
        D3DPCMPCAPS_GREATEREQUAL |
        D3DPCMPCAPS_ALWAYS |
        0,
        // ShadeCaps  
        //D3DPSHADECAPS_COLORFLATMONO |  
        //D3DPSHADECAPS_COLORFLATRGB |  
        //D3DPSHADECAPS_COLORGOURAUDMONO |  
        D3DPSHADECAPS_COLORGOURAUDRGB |
        //D3DPSHADECAPS_COLORPHONGMONO |  
        //D3DPSHADECAPS_COLORPHONGRGB |  
        //D3DPSHADECAPS_SPECULARFLATMONO |  
        //D3DPSHADECAPS_SPECULARFLATRGB |  
        //D3DPSHADECAPS_SPECULARGOURAUDMONO |  
        D3DPSHADECAPS_SPECULARGOURAUDRGB |
        //D3DPSHADECAPS_SPECULARPHONGMONO |  
        //D3DPSHADECAPS_SPECULARPHONGRGB |  
        //D3DPSHADECAPS_ALPHAFLATBLEND |  
        //D3DPSHADECAPS_ALPHAFLATSTIPPLED |  
        D3DPSHADECAPS_ALPHAGOURAUDBLEND |
        //D3DPSHADECAPS_ALPHAGOURAUDSTIPPLED |  
        //D3DPSHADECAPS_ALPHAPHONGBLEND |  
        //D3DPSHADECAPS_ALPHAPHONGSTIPPLED |  
        //D3DPSHADECAPS_FOGFLAT |  
        D3DPSHADECAPS_FOGGOURAUD |
        //D3DPSHADECAPS_FOGPHONG |  
        0,
        // TextureCaps      
        D3DPTEXTURECAPS_PERSPECTIVE |
        //D3DPTEXTURECAPS_POW2 |  
        D3DPTEXTURECAPS_ALPHA |
        D3DPTEXTURECAPS_TRANSPARENCY |
        D3DPTEXTURECAPS_BORDER |
        //D3DPTEXTURECAPS_SQUAREONLY |  
        D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE |
        D3DPTEXTURECAPS_ALPHAPALETTE |
        //D3DPTEXTURECAPS_NONPOW2CONDITIONAL |      
        /*RESERVED |*/
        D3DPTEXTURECAPS_PROJECTED |
        D3DPTEXTURECAPS_CUBEMAP |
        D3DPTEXTURECAPS_VOLUMEMAP |
        D3DPTEXTURECAPS_MIPMAP |
        D3DPTEXTURECAPS_MIPVOLUMEMAP |
        D3DPTEXTURECAPS_MIPCUBEMAP |
        //D3DPTEXTURECAPS_CUBEMAP_POW2 |  
        //D3DPTEXTURECAPS_VOLUMEMAP_POW2 |      
        //D3DPTEXTURECAPS_NOPROJECTEDBUMPENV |  
        0,
        // TextureFilterCaps      
        //D3DPTFILTERCAPS_NEAREST |  
        //D3DPTFILTERCAPS_LINEAR |  
        //D3DPTFILTERCAPS_MIPNEAREST |  
        //D3DPTFILTERCAPS_MIPLINEAR |  
        //D3DPTFILTERCAPS_LINEARMIPNEAREST |  
        //D3DPTFILTERCAPS_LINEARMIPLINEAR |  
        /*RESERVED |*/
        /*RESERVED |*/
        D3DPTFILTERCAPS_MINFPOINT |
        D3DPTFILTERCAPS_MINFLINEAR |
        D3DPTFILTERCAPS_MINFANISOTROPIC |
        //D3DPTFILTERCAPS_MINFPYRAMIDALQUAD |  
        //D3DPTFILTERCAPS_MINFGAUSSIANQUAD |  
        /*RESERVED |*/
        /*RESERVED |*/
        /*RESERVED |*/
        D3DPTFILTERCAPS_MIPFPOINT |
        D3DPTFILTERCAPS_MIPFLINEAR |
        //D3DPTFILTERCAPS_CONVOLUTIONMONO |  
        /*RESERVED |*/
        /*RESERVED |*/
        /*RESERVED |*/
        /*RESERVED |*/
        /*RESERVED |*/
        D3DPTFILTERCAPS_MAGFPOINT |
        D3DPTFILTERCAPS_MAGFLINEAR |
        D3DPTFILTERCAPS_MAGFANISOTROPIC |
        //D3DPTFILTERCAPS_MAGFAFLATCUBIC |  
        //D3DPTFILTERCAPS_MAGFGAUSSIANCUBIC |  
        0,
        // CubeTextureFilterCaps  
        //D3DPTFILTERCAPS_NEAREST |  
        //D3DPTFILTERCAPS_LINEAR |  
        //D3DPTFILTERCAPS_MIPNEAREST |  
        //D3DPTFILTERCAPS_MIPLINEAR |  
        //D3DPTFILTERCAPS_LINEARMIPNEAREST |  
        //D3DPTFILTERCAPS_LINEARMIPLINEAR |  
        /*RESERVED |*/
        /*RESERVED |*/
        D3DPTFILTERCAPS_MINFPOINT |
        D3DPTFILTERCAPS_MINFLINEAR |
        D3DPTFILTERCAPS_MINFANISOTROPIC |
        //D3DPTFILTERCAPS_MINFPYRAMIDALQUAD |  
        //D3DPTFILTERCAPS_MINFGAUSSIANQUAD |  
        /*RESERVED |*/
        /*RESERVED |*/
        /*RESERVED |*/
        D3DPTFILTERCAPS_MIPFPOINT |
        D3DPTFILTERCAPS_MIPFLINEAR |
        //D3DPTFILTERCAPS_CONVOLUTIONMONO |  
        /*RESERVED |*/
        /*RESERVED |*/
        /*RESERVED |*/
        /*RESERVED |*/
        /*RESERVED |*/
        D3DPTFILTERCAPS_MAGFPOINT |
        D3DPTFILTERCAPS_MAGFLINEAR |
        D3DPTFILTERCAPS_MAGFANISOTROPIC |
        //D3DPTFILTERCAPS_MAGFAFLATCUBIC |  
        //D3DPTFILTERCAPS_MAGFGAUSSIANCUBIC |  
        0,
        // VolumeTextureFilterCaps  
        //D3DPTFILTERCAPS_NEAREST |  
        //D3DPTFILTERCAPS_LINEAR |  
        //D3DPTFILTERCAPS_MIPNEAREST |  
        //D3DPTFILTERCAPS_MIPLINEAR |  
        //D3DPTFILTERCAPS_LINEARMIPNEAREST |  
        //D3DPTFILTERCAPS_LINEARMIPLINEAR |  
        /*RESERVED |*/
        /*RESERVED |*/
        D3DPTFILTERCAPS_MINFPOINT |
        D3DPTFILTERCAPS_MINFLINEAR |
        D3DPTFILTERCAPS_MINFANISOTROPIC |
        //D3DPTFILTERCAPS_MINFPYRAMIDALQUAD |  
        //D3DPTFILTERCAPS_MINFGAUSSIANQUAD |  
        /*RESERVED |*/
        /*RESERVED |*/
        /*RESERVED |*/
        D3DPTFILTERCAPS_MIPFPOINT |
        D3DPTFILTERCAPS_MIPFLINEAR |
        //D3DPTFILTERCAPS_CONVOLUTIONMONO |  
        /*RESERVED |*/
        /*RESERVED |*/
        /*RESERVED |*/
        /*RESERVED |*/
        /*RESERVED |*/
        D3DPTFILTERCAPS_MAGFPOINT |
        D3DPTFILTERCAPS_MAGFLINEAR |
        D3DPTFILTERCAPS_MAGFANISOTROPIC |
        //D3DPTFILTERCAPS_MAGFAFLATCUBIC |  
        //D3DPTFILTERCAPS_MAGFGAUSSIANCUBIC |  
        0,
        // TextureAddressCaps  
        D3DPTADDRESSCAPS_WRAP |
        D3DPTADDRESSCAPS_MIRROR |
        D3DPTADDRESSCAPS_CLAMP |
        D3DPTADDRESSCAPS_BORDER |
        D3DPTADDRESSCAPS_INDEPENDENTUV |
        D3DPTADDRESSCAPS_MIRRORONCE |
        0,
        // VolumeTextureAddressCaps  
        D3DPTADDRESSCAPS_WRAP |
        D3DPTADDRESSCAPS_MIRROR |
        D3DPTADDRESSCAPS_CLAMP |
        D3DPTADDRESSCAPS_BORDER |
        D3DPTADDRESSCAPS_INDEPENDENTUV |
        D3DPTADDRESSCAPS_MIRRORONCE |
        0,
        // LineCaps  
        // Not required in FL9_x, so not all driver respects D3D11_RASTERIZER_DESC.AntialiasedLineEnable.  
        // D3DLINECAPS_ANTIALIAS |  
        D3DLINECAPS_TEXTURE |
        D3DLINECAPS_ZTEST |
        D3DLINECAPS_BLEND |
        D3DLINECAPS_ALPHACMP |
        D3DLINECAPS_FOG |
        0,
        // MaxTextureWidth  
        MAX_TEXTURE_WIDTH_SIZE,
        // MaxTextureHeight  
        MAX_TEXTURE_HEIGHT_SIZE,
        // MaxVolumeExtent  
        MAX_VOLUME_EXTENT,
        // MaxTextureRepeat  
        MAX_TEXTURE_REPEAT,
        // MaxTextureAspectRatio  
        MAX_TEXTURE_ASPECT_RATIO,
        // MaxAnisotropy  
        16,
        // MaxVertexW  
        1.0e10,
        // GuardBandLeft  
        -1.0e8,
        // GuardBandTop  
        -1.0e8,
        // GuardBandRight  
        1.0e8,
        // GuardBandBottom  
        1.0e8,
        // ExtentsAdjust  
        0.0,
        // StencilCaps  
        D3DSTENCILCAPS_KEEP |
        D3DSTENCILCAPS_ZERO |
        D3DSTENCILCAPS_REPLACE |
        D3DSTENCILCAPS_INCRSAT |
        D3DSTENCILCAPS_DECRSAT |
        D3DSTENCILCAPS_INVERT |
        D3DSTENCILCAPS_INCR |
        D3DSTENCILCAPS_DECR |
        D3DSTENCILCAPS_TWOSIDED |
        0,
        // FVFCaps  
        //D3DFVFCAPS_DONOTSTRIPELEMENTS |  
        8 /*D3DFVFCAPS_TEXCOORDCOUNTMASK*/ |
        D3DFVFCAPS_PSIZE |
        0,
        // TextureOpCaps  
        D3DTEXOPCAPS_DISABLE |
        D3DTEXOPCAPS_SELECTARG1 |
        D3DTEXOPCAPS_SELECTARG2 |
        D3DTEXOPCAPS_MODULATE |
        D3DTEXOPCAPS_MODULATE2X |
        D3DTEXOPCAPS_MODULATE4X |
        D3DTEXOPCAPS_ADD |
        D3DTEXOPCAPS_ADDSIGNED |
        D3DTEXOPCAPS_ADDSIGNED2X |
        D3DTEXOPCAPS_SUBTRACT |
        D3DTEXOPCAPS_ADDSMOOTH |
        D3DTEXOPCAPS_BLENDDIFFUSEALPHA |
        D3DTEXOPCAPS_BLENDTEXTUREALPHA |
        D3DTEXOPCAPS_BLENDFACTORALPHA |
        D3DTEXOPCAPS_BLENDTEXTUREALPHAPM |
        D3DTEXOPCAPS_BLENDCURRENTALPHA |
        D3DTEXOPCAPS_PREMODULATE |
        D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR |
        D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA |
        D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR |
        D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA |
        D3DTEXOPCAPS_BUMPENVMAP |
        D3DTEXOPCAPS_BUMPENVMAPLUMINANCE |
        D3DTEXOPCAPS_DOTPRODUCT3 |
        D3DTEXOPCAPS_MULTIPLYADD |
        D3DTEXOPCAPS_LERP |
        0,
        // MaxTextureBlendStages  
        8,
        // MaxSimultaneousTextures  
        8,
        // VertexProcessingCaps  
        D3DVTXPCAPS_TEXGEN_SPHEREMAP |
        D3DVTXPCAPS_TEXGEN |
        D3DVTXPCAPS_MATERIALSOURCE7 |
        D3DVTXPCAPS_DIRECTIONALLIGHTS |
        D3DVTXPCAPS_POSITIONALLIGHTS |
        D3DVTXPCAPS_TWEENING |
        D3DVTXPCAPS_LOCALVIEWER |
        0,
        // MaxActiveLights  
        MAX_ACTIVE_LIGHTS,
        // MaxUserClipPlanes  
        MAX_USER_CLIPPLANES,
        // MaxVertexBlendMatrices  
        MAX_VERTEX_BLEND_MATRICES,
        // MaxVertexBlendMatrixIndex  
        MAX_VERTEX_BLEND_MATRIX_INDEX,
        // MaxPointSize  
        MAX_POINT_SIZE,
        // MaxPrimitiveCount  
        0x007fffff,
        // MaxVertexIndex  
        0x00ffffff,
        // MaxStreams  
        MAX_VERTEX_STREAMS,
        // MaxStreamStride  
        255,
        // VertexShaderVersion  
        D3DVS_VERSION(3, 0),
        // MaxVertexShaderConst  
        MAX_VS_CONSTANTSF,
        // PixelShaderVersion  
        D3DPS_VERSION(3, 0),
        // PixelShader1xMaxValue  
        FLT_MAX,
        // DevCaps2  
        D3DDEVCAPS2_STREAMOFFSET |
        D3DDEVCAPS2_VERTEXELEMENTSCANSHARESTREAMOFFSET |
        0,
        // MaxNpatchTessellationLevel  
        1,
        // Reserved5  
        0,
        // MasterAdapterOrdinal  
        0,
        // AdapterOrdinalInGroup  
        0,
        // NumberOfAdaptersInGroup  
        0,
        // DeclTypes  
        (D3DDTCAPS_UBYTE4 |
        D3DDTCAPS_UBYTE4N |
        D3DDTCAPS_SHORT2N |
        D3DDTCAPS_SHORT4N |
        D3DDTCAPS_USHORT2N |
        D3DDTCAPS_USHORT4N |
        D3DDTCAPS_UDEC3 |
        D3DDTCAPS_FLOAT16_2 |
        D3DDTCAPS_FLOAT16_4 |
        D3DDTCAPS_DEC3N),
        // NumSimultaneousRTs  
        MAX_RENDER_TARGETS,
        // StretchRectFilterCaps  
        D3DPTFILTERCAPS_MINFPOINT |
        D3DPTFILTERCAPS_MINFLINEAR |
        D3DPTFILTERCAPS_MAGFPOINT |
        D3DPTFILTERCAPS_MAGFLINEAR |
        0,
        // VS20Caps  
        {
            // Caps  
            D3DVS20CAPS_PREDICATION,
            // DynamicFlowControlDepth  
            D3DVS20_MAX_DYNAMICFLOWCONTROLDEPTH,
            // NumTemps  
            D3DVS20_MAX_NUMTEMPS,
            // StaticFlowControlDepth  
            D3DVS20_MAX_STATICFLOWCONTROLDEPTH,
        },
        // PS20Caps  
        {
            // Caps  
            D3DPS20CAPS_ARBITRARYSWIZZLE |
            D3DPS20CAPS_GRADIENTINSTRUCTIONS |
            D3DPS20CAPS_PREDICATION |
            D3DPS20CAPS_NODEPENDENTREADLIMIT |
            D3DPS20CAPS_NOTEXINSTRUCTIONLIMIT |
            0,
            // DynamicFlowControlDepth  
            D3DPS20_MAX_DYNAMICFLOWCONTROLDEPTH,
            // NumTemps  
            D3DPS20_MAX_NUMTEMPS,
            // StaticFlowControlDepth  
            D3DPS20_MAX_STATICFLOWCONTROLDEPTH,
            // NumInstructionSlots  
            D3DPS20_MAX_NUMINSTRUCTIONSLOTS,
        },
        // VertexTextureFilterCaps  
        //D3DPTFILTERCAPS_NEAREST |  
        //D3DPTFILTERCAPS_LINEAR |  
        //D3DPTFILTERCAPS_MIPNEAREST |  
        //D3DPTFILTERCAPS_MIPLINEAR |  
        //D3DPTFILTERCAPS_LINEARMIPNEAREST |  
        //D3DPTFILTERCAPS_LINEARMIPLINEAR |  
        /*RESERVED |*/
        /*RESERVED |*/
        D3DPTFILTERCAPS_MINFPOINT |
        D3DPTFILTERCAPS_MINFLINEAR |
        //D3DPTFILTERCAPS_MINFANISOTROPIC |  
        //D3DPTFILTERCAPS_MINFPYRAMIDALQUAD |  
        //D3DPTFILTERCAPS_MINFGAUSSIANQUAD |  
        /*RESERVED |*/
        /*RESERVED |*/
        /*RESERVED |*/
        D3DPTFILTERCAPS_MIPFPOINT |
        D3DPTFILTERCAPS_MIPFLINEAR |
        //D3DPTFILTERCAPS_CONVOLUTIONMONO |  
        /*RESERVED |*/
        /*RESERVED |*/
        /*RESERVED |*/
        /*RESERVED |*/
        /*RESERVED |*/
        D3DPTFILTERCAPS_MAGFPOINT |
        D3DPTFILTERCAPS_MAGFLINEAR |
        //D3DPTFILTERCAPS_MAGFANISOTROPIC |  
        //D3DPTFILTERCAPS_MAGFAFLATCUBIC |  
        //D3DPTFILTERCAPS_MAGFGAUSSIANCUBIC |  
        0,
        // MaxVShaderInstructionsExecuted  
        D3DINFINITEINSTRUCTIONS,
        // MaxPShaderInstructionsExecuted  
        D3DINFINITEINSTRUCTIONS,
        // MaxVertexShader30InstructionSlots  
        D3DMAX30SHADERINSTRUCTIONS,
        // MaxPixelShader30InstructionSlots  
        D3DMAX30SHADERINSTRUCTIONS,
    };
    static void GetD3D9Caps(D3DCAPS9* pCaps)
    {
        memcpy(pCaps, &cD3D9Caps, sizeof(D3DCAPS9));
    }

    static void GetD3D8Caps(D3DCAPS8* pCaps)
    {
        memcpy(pCaps, &cD3D9Caps, sizeof(D3DCAPS8));
        pCaps->Caps = DDCAPS_3D |
            //DDCAPS_ALIGNBOUNDARYDEST |
            //DDCAPS_ALIGNSIZEDEST |
            //DDCAPS_ALIGNBOUNDARYSRC |
            //DDCAPS_ALIGNSIZESRC |
            //DDCAPS_ALIGNSTRIDE |
            DDCAPS_BLT |
            DDCAPS_BLTQUEUE |
            DDCAPS_BLTFOURCC |
            DDCAPS_BLTSTRETCH |
            //DDCAPS_GDI |
            //DDCAPS_OVERLAY |
            //DDCAPS_OVERLAYCANTCLIP |
            //DDCAPS_OVERLAYFOURCC |
            //DDCAPS_OVERLAYSTRETCH |
            //DDCAPS_PALETTE |
            //DDCAPS_PALETTEVSYNC |
            DDCAPS_READSCANLINE |
            //DDCAPS_RESERVED1 |
            //DDCAPS_VBI |
            //DDCAPS_ZBLTS |
            //DDCAPS_ZOVERLAYS |
            DDCAPS_COLORKEY |
            DDCAPS_ALPHA |
            //DDCAPS_COLORKEYHWASSIST |
            //DDCAPS_NOHARDWARE |
            DDCAPS_BLTCOLORFILL |
            //DDCAPS_BANKSWITCHED |
            DDCAPS_BLTDEPTHFILL |
            //DDCAPS_CANCLIP |
            //DDCAPS_CANCLIPSTRETCHED |
            DDCAPS_CANBLTSYSMEM |
            0;
        pCaps->Caps2 = DDCAPS2_CERTIFIED |
            //DDCAPS2_NO2DDURING3DSCENE |
            //DDCAPS2_VIDEOPORT |
            //DDCAPS2_AUTOFLIPOVERLAY |
            //DDCAPS2_CANBOBINTERLEAVED |
            //DDCAPS2_CANBOBNONINTERLEAVED |
            //DDCAPS2_COLORCONTROLOVERLAY |
            //DDCAPS2_COLORCONTROLPRIMARY |
            //DDCAPS2_CANDROPZ16BIT |
            DDCAPS2_NONLOCALVIDMEM |
            DDCAPS2_NONLOCALVIDMEMCAPS |
            DDCAPS2_NOPAGELOCKREQUIRED |
            DDCAPS2_WIDESURFACES |
            //DDCAPS2_CANFLIPODDEVEN |
            //DDCAPS2_CANBOBHARDWARE |
            DDCAPS2_COPYFOURCC |
            /*RESERVED |*/
            DDCAPS2_PRIMARYGAMMA |
            /*RESERVED |*/
            DDCAPS2_CANRENDERWINDOWED |
            //DDCAPS2_CANCALIBRATEGAMMA |
            DDCAPS2_FLIPINTERVAL |
            DDCAPS2_FLIPNOVSYNC |
            //DDCAPS2_CANMANAGETEXTURE |
            //DDCAPS2_TEXMANINNONLOCALVIDMEM |
            //DDCAPS2_STEREO |
            //DDCAPS2_SYSTONONLOCAL_AS_SYSTOLOCAL |
            //DDCAPS2_RESERVED1 |
            //DDCAPS2_CANMANAGERESOURCE |
            DDCAPS2_DYNAMICTEXTURES |
            DDCAPS2_CANAUTOGENMIPMAP |
            //DDCAPS2_CANSHARERESOURCE |
            0;
        pCaps->Caps3 = //D3DCAPS3_RESERVED
            D3DCAPS3_ALPHA_FULLSCREEN_FLIP_OR_DISCARD |
            //D3DCAPS3_MANAGEDDEVICE |
            D3DCAPS3_LINEAR_TO_SRGB_PRESENTATION |
            //D3DCAPS3_COPY_TO_VIDMEM |
            //D3DCAPS3_COPY_TO_SYSTEMMEM |
            //D3DCAPS3_DXVAHD |
            //D3DCAPS3_DXVAHD_LIMITED |
            0;

#define D3DPRESENT_INTERVAL_DX8VALID    0x8000000fL
#define D3DCURSORCAPS_DX8VALID          0x00000003L
#define D3DDEVCAPS_DX8VALID             0x0ffbfff0L
#define D3DPMISCCAPS_DX8VALID           0x00003FF6L
#define D3DPRASTERCAPS_DX8VALID         0x00f7f19fL
#define D3DPCMPCAPS_DX8VALID            0x000000ffL
#define D3DPBLENDCAPS_DX8VALID          0x00001FFFL
#define D3DPSHADECAPS_DX8VALID          0x00084208L
#define D3DPTEXTURECAPS_DX8VALID        0x0007EDE7L
#define D3DPTFILTERCAPS_DX8VALID        0x1F030700L
#define D3DPTADDRESSCAPS_DX8VALID       0x0000003FL
#define D3DLINECAPS_DX8VALID            0x0000001FL
#define D3DSTENCILCAPS_DX8VALID         0x000000FFL
#define D3DFVFCAPS_DX8VALID             0x0018ffffL
#define D3DTEXOPCAPS_DX8VALID           0x03ffffffL
#define D3DVTXPCAPS_DX8VALID            0x000000fbL
        pCaps->PresentationIntervals &= D3DPRESENT_INTERVAL_DX8VALID;
        pCaps->CursorCaps &= D3DCURSORCAPS_DX8VALID;
        pCaps->DevCaps &= D3DDEVCAPS_DX8VALID;
        pCaps->PrimitiveMiscCaps &= D3DPMISCCAPS_DX8VALID;
        pCaps->RasterCaps &= D3DPRASTERCAPS_DX8VALID;
        pCaps->ZCmpCaps &= D3DPCMPCAPS_DX8VALID;
        pCaps->SrcBlendCaps &= D3DPBLENDCAPS_DX8VALID;
        pCaps->DestBlendCaps &= D3DPBLENDCAPS_DX8VALID;
        pCaps->AlphaCmpCaps &= D3DPCMPCAPS_DX8VALID;
        pCaps->ShadeCaps &= D3DPSHADECAPS_DX8VALID;
        pCaps->TextureCaps &= D3DPTEXTURECAPS_DX8VALID;
        pCaps->TextureFilterCaps &= D3DPTFILTERCAPS_DX8VALID;
        pCaps->CubeTextureFilterCaps &= D3DPTFILTERCAPS_DX8VALID;
        pCaps->VolumeTextureFilterCaps &= D3DPTFILTERCAPS_DX8VALID;
        pCaps->TextureAddressCaps &= D3DPTADDRESSCAPS_DX8VALID;
        pCaps->VolumeTextureAddressCaps &= D3DPTADDRESSCAPS_DX8VALID;
        pCaps->LineCaps &= D3DLINECAPS_DX8VALID;
        pCaps->StencilCaps &= D3DSTENCILCAPS_DX8VALID;
        pCaps->FVFCaps &= D3DFVFCAPS_DX8VALID;
        pCaps->TextureOpCaps &= D3DTEXOPCAPS_DX8VALID;
        pCaps->VertexProcessingCaps &= D3DVTXPCAPS_DX8VALID;
        pCaps->VertexShaderVersion = D3DVS_VERSION(1, 1);
        pCaps->PixelShaderVersion = D3DPS_VERSION(1, 4);
    }

    static void GetD3D7Caps(D3DHAL_D3DEXTENDEDCAPS* pCaps)
    {
        pCaps->dwSize = sizeof(D3DHAL_D3DEXTENDEDCAPS);
        pCaps->dwMinTextureWidth = 1;
        pCaps->dwMaxTextureWidth = cD3D9Caps.MaxTextureWidth;
        pCaps->dwMinTextureHeight = 1;
        pCaps->dwMaxTextureHeight = cD3D9Caps.MaxTextureHeight;
        pCaps->dwMinStippleWidth = 0;
        pCaps->dwMaxStippleWidth = 0;
        pCaps->dwMinStippleHeight = 0;
        pCaps->dwMaxStippleHeight = 0;
        pCaps->dwMaxTextureRepeat = cD3D9Caps.MaxTextureRepeat;
        pCaps->dwMaxTextureAspectRatio = cD3D9Caps.MaxTextureAspectRatio;
        pCaps->dwMaxAnisotropy = cD3D9Caps.MaxAnisotropy;
        pCaps->dvGuardBandLeft = cD3D9Caps.GuardBandLeft;
        pCaps->dvGuardBandTop = cD3D9Caps.GuardBandTop;
        pCaps->dvGuardBandRight = cD3D9Caps.GuardBandRight;
        pCaps->dvGuardBandBottom = cD3D9Caps.GuardBandBottom;
        pCaps->dvExtentsAdjust = cD3D9Caps.ExtentsAdjust;
        pCaps->dwStencilCaps = cD3D9Caps.StencilCaps & ~(D3DSTENCILCAPS_TWOSIDED);
        pCaps->dwFVFCaps = cD3D9Caps.FVFCaps & ~(D3DFVFCAPS_PSIZE);
        pCaps->dwTextureOpCaps = cD3D9Caps.TextureOpCaps & ~(D3DTEXOPCAPS_MULTIPLYADD | D3DTEXOPCAPS_LERP);
        pCaps->wMaxTextureBlendStages = (WORD)cD3D9Caps.MaxTextureBlendStages;
        pCaps->wMaxSimultaneousTextures = (WORD)cD3D9Caps.MaxSimultaneousTextures;
        pCaps->dwMaxActiveLights = cD3D9Caps.MaxActiveLights;
        pCaps->dvMaxVertexW = cD3D9Caps.MaxVertexW;
        pCaps->wMaxUserClipPlanes = (WORD)cD3D9Caps.MaxUserClipPlanes;
        pCaps->wMaxVertexBlendMatrices = (WORD)cD3D9Caps.MaxVertexBlendMatrices;
        pCaps->dwVertexProcessingCaps = cD3D9Caps.VertexProcessingCaps & ~(D3DVTXPCAPS_TWEENING | D3DVTXPCAPS_TEXGEN_SPHEREMAP);
        pCaps->dwReserved1 = 0;
        pCaps->dwReserved2 = 0;
        pCaps->dwReserved3 = 0;
        pCaps->dwReserved4 = 0;
    }

    static void GetDDrawCaps(DDRAW_CAPS* pCaps)
    {
        static const DDRAW_CAPS cDdrawCaps =
        {
            // Caps
            DDRAW_CAPS_ZBLTS |
            //DDRAW_CAPS_COLORKEY |
            DDRAW_CAPS_BLTDEPTHFILL |
            0,

            // Caps2
            //DDRAW_CAPS2_CANDROPZ16BIT |
            //DDRAW_CAPS2_FLIPINTERVAL |
            //DDRAW_CAPS2_FLIPNOVSYNC |
            DDRAW_CAPS2_DYNAMICTEXTURES |
            0,

            // CKeyCaps
            DDRAW_CKEYCAPS_SRCBLT |
            DDRAW_CKEYCAPS_DESTBLT |
            0,

            // FxCaps
            DDRAW_FXCAPS_BLTMIRRORLEFTRIGHT |
            DDRAW_FXCAPS_BLTMIRRORUPDOWN |
            0,

            // MaxVideoPorts
            0,
        };

        memcpy(pCaps, &cDdrawCaps, sizeof(DDRAW_CAPS));
    }

    static void GetD3D3Caps(D3DHAL_GLOBALDRIVERDATA* pCaps)
    {
        static const D3DHAL_GLOBALDRIVERDATA cD3d3Caps = {
            // dwSize
            sizeof(D3DHAL_GLOBALDRIVERDATA),
            // hwCaps
        {
            // dwSize
            sizeof(D3DDEVICEDESC_V1),

            // dwFlags
            D3DDD_COLORMODEL |
            D3DDD_DEVCAPS |
            //D3DDD_TRANSFORMCAPS |
            //D3DDD_LIGHTINGCAPS |
            //D3DDD_BCLIPPING |
            D3DDD_LINECAPS |
            D3DDD_TRICAPS |
            D3DDD_DEVICERENDERBITDEPTH |
            D3DDD_DEVICEZBUFFERBITDEPTH |
            //D3DDD_MAXBUFFERSIZE |
            //D3DDD_MAXVERTEXCOUNT |
            0,

            // dcmColorModel
            D3DCOLOR_RGB,

            // dwDevCaps
            D3DDEVCAPS_FLOATTLVERTEX |
            //D3DDEVCAPS_SORTINCREASINGZ |
            //D3DDEVCAPS_SORTDECREASINGZ |
            //D3DDEVCAPS_SORTEXACT |
            D3DDEVCAPS_EXECUTESYSTEMMEMORY |
            D3DDEVCAPS_EXECUTEVIDEOMEMORY |
            D3DDEVCAPS_TLVERTEXSYSTEMMEMORY |
            D3DDEVCAPS_TLVERTEXVIDEOMEMORY |
            D3DDEVCAPS_TEXTURESYSTEMMEMORY |
            D3DDEVCAPS_TEXTUREVIDEOMEMORY |
            D3DDEVCAPS_DRAWPRIMTLVERTEX |
            D3DDEVCAPS_CANRENDERAFTERFLIP |
            D3DDEVCAPS_TEXTURENONLOCALVIDMEM |
            D3DDEVCAPS_DRAWPRIMITIVES2 |
            //D3DDEVCAPS_SEPARATETEXTUREMEMORIES |
            D3DDEVCAPS_DRAWPRIMITIVES2EX |
            D3DDEVCAPS_HWTRANSFORMANDLIGHT |
            D3DDEVCAPS_CANBLTSYSTONONLOCAL |
            D3DDEVCAPS_HWRASTERIZATION |
            //D3DDEVCAPS_PUREDEVICE |
            //D3DDEVCAPS_QUINTICRTPATCHES |
            //D3DDEVCAPS_RTPATCHES |
            //D3DDEVCAPS_RTPATCHHANDLEZERO |
            //D3DDEVCAPS_NPATCHES |
            //D3DDEVCAPS_HWVERTEXBUFFER |
            //D3DDEVCAPS_HWINDEXBUFFER |
            0,

            // dtcTransformCaps
        {
            0, 0
        },
            // bClipping
            TRUE,
            // dlcLightingCaps
        {
            0, 0, 0, 0,
        },
            {   // dpcLineCaps
                sizeof(D3DPRIMCAPS),

                // dwMiscCaps
                //D3DPMISCCAPS_MASKPLANES
                D3DPMISCCAPS_MASKZ |
                //D3DPMISCCAPS_LINEPATTERNREP |
                //D3DPMISCCAPS_CONFORMANT |
                //D3DPMISCCAPS_CULLNONE |
                //D3DPMISCCAPS_CULLCW |
                //D3DPMISCCAPS_CULLCCW |
                //D3DPMISCCAPS_COLORWRITEENABLE |
                //D3DPMISCCAPS_CLIPPLANESCALEDPOINTS |
                //D3DPMISCCAPS_CLIPTLVERTS |
                //D3DPMISCCAPS_TSSARGTEMP |
                //D3DPMISCCAPS_BLENDOP |
                //D3DPMISCCAPS_NULLREFERENCE |
                //D3DPMISCCAPS_FOGINFVF |
                //D3DPMISCCAPS_INDEPENDENTWRITEMASKS |
                //D3DPMISCCAPS_PERSTAGECONSTANT |
                //D3DPMISCCAPS_SEPARATEALPHABLEND |
                //D3DPMISCCAPS_MRTINDEPENDENTBITDEPTHS |
                //D3DPMISCCAPS_MRTPOSTPIXELSHADERBLENDING |
                //D3DPMISCCAPS_FOGVERTEXCLAMPED |
                //D3DPMISCCAPS_POSTBLENDSRGBCONVERT |
            0,

            // dwRasterCaps
            D3DPRASTERCAPS_DITHER |
            //D3DPRASTERCAPS_ROP2 |
            //D3DPRASTERCAPS_XOR |
            //D3DPRASTERCAPS_PAT |
            D3DPRASTERCAPS_ZTEST |
            D3DPRASTERCAPS_SUBPIXEL |
            //D3DPRASTERCAPS_SUBPIXELX |
            D3DPRASTERCAPS_FOGVERTEX |
            D3DPRASTERCAPS_FOGTABLE |
            //D3DPRASTERCAPS_STIPPLE |
            //D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT |
            D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT |
            D3DPRASTERCAPS_ANTIALIASEDGES |
            D3DPRASTERCAPS_MIPMAPLODBIAS |
            D3DPRASTERCAPS_ZBIAS |
            //D3DPRASTERCAPS_ZBUFFERLESSHSR |
            D3DPRASTERCAPS_FOGRANGE |
            D3DPRASTERCAPS_ANISOTROPY |
            //D3DPRASTERCAPS_WBUFFER |
            //D3DPRASTERCAPS_TRANSLUCENTSORTINDEPENDENT |
            D3DPRASTERCAPS_WFOG |
            D3DPRASTERCAPS_ZFOG |
            //D3DPRASTERCAPS_COLORPERSPECTIVE |
            //D3DPRASTERCAPS_STRETCHBLTMULTISAMPLE |
            //D3DPRASTERCAPS_SCISSORTEST |
            //D3DPRASTERCAPS_SLOPESCALEDEPTHBIAS |
            //D3DPRASTERCAPS_DEPTHBIAS |
            //D3DPRASTERCAPS_MULTISAMPLE_TOGGLE |
            0,

            // dwZCmpCaps
            D3DPCMPCAPS_NEVER |
            D3DPCMPCAPS_LESS |
            D3DPCMPCAPS_EQUAL |
            D3DPCMPCAPS_LESSEQUAL |
            D3DPCMPCAPS_GREATER |
            D3DPCMPCAPS_NOTEQUAL |
            D3DPCMPCAPS_GREATEREQUAL |
            D3DPCMPCAPS_ALWAYS |
            0,

            // dwSrcBlendCaps
            D3DPBLENDCAPS_ZERO |
            D3DPBLENDCAPS_ONE |
            D3DPBLENDCAPS_SRCCOLOR |
            D3DPBLENDCAPS_INVSRCCOLOR |
            D3DPBLENDCAPS_SRCALPHA |
            D3DPBLENDCAPS_INVSRCALPHA |
            D3DPBLENDCAPS_DESTALPHA |
            D3DPBLENDCAPS_INVDESTALPHA |
            D3DPBLENDCAPS_DESTCOLOR |
            D3DPBLENDCAPS_INVDESTCOLOR |
            D3DPBLENDCAPS_SRCALPHASAT |
            D3DPBLENDCAPS_BOTHSRCALPHA |
            D3DPBLENDCAPS_BOTHINVSRCALPHA |
            //D3DPBLENDCAPS_BLENDFACTOR |
            //D3DPBLENDCAPS_SRCCOLOR2 |
            //D3DPBLENDCAPS_INVSRCCOLOR2 |
            0,

            // dwDestBlendCaps
            D3DPBLENDCAPS_ZERO |
            D3DPBLENDCAPS_ONE |
            D3DPBLENDCAPS_SRCCOLOR |
            D3DPBLENDCAPS_INVSRCCOLOR |
            D3DPBLENDCAPS_SRCALPHA |
            D3DPBLENDCAPS_INVSRCALPHA |
            D3DPBLENDCAPS_DESTALPHA |
            D3DPBLENDCAPS_INVDESTALPHA |
            D3DPBLENDCAPS_DESTCOLOR |
            D3DPBLENDCAPS_INVDESTCOLOR |
            D3DPBLENDCAPS_SRCALPHASAT |
            D3DPBLENDCAPS_BOTHSRCALPHA |
            D3DPBLENDCAPS_BOTHINVSRCALPHA |
            //D3DPBLENDCAPS_BLENDFACTOR |
            //D3DPBLENDCAPS_SRCCOLOR2 |
            //D3DPBLENDCAPS_INVSRCCOLOR2 |
            0,

            // dwAlphaCmpCaps
            D3DPCMPCAPS_NEVER |
            D3DPCMPCAPS_LESS |
            D3DPCMPCAPS_EQUAL |
            D3DPCMPCAPS_LESSEQUAL |
            D3DPCMPCAPS_GREATER |
            D3DPCMPCAPS_NOTEQUAL |
            D3DPCMPCAPS_GREATEREQUAL |
            D3DPCMPCAPS_ALWAYS |
            0,

            // dwShadeCaps
            //D3DPSHADECAPS_COLORFLATMONO |
            D3DPSHADECAPS_COLORFLATRGB |
            //D3DPSHADECAPS_COLORGOURAUDMONO |
            D3DPSHADECAPS_COLORGOURAUDRGB |
            //D3DPSHADECAPS_COLORPHONGMONO |
            //D3DPSHADECAPS_COLORPHONGRGB |
            //D3DPSHADECAPS_SPECULARFLATMONO |
            D3DPSHADECAPS_SPECULARFLATRGB |
            //D3DPSHADECAPS_SPECULARGOURAUDMONO |
            D3DPSHADECAPS_SPECULARGOURAUDRGB |
            //D3DPSHADECAPS_SPECULARPHONGMONO |
            //D3DPSHADECAPS_SPECULARPHONGRGB |
            D3DPSHADECAPS_ALPHAFLATBLEND |
            //D3DPSHADECAPS_ALPHAFLATSTIPPLED |
            D3DPSHADECAPS_ALPHAGOURAUDBLEND |
            //D3DPSHADECAPS_ALPHAGOURAUDSTIPPLED |
            //D3DPSHADECAPS_ALPHAPHONGBLEND |
            //D3DPSHADECAPS_ALPHAPHONGSTIPPLED |
            D3DPSHADECAPS_FOGFLAT |
            D3DPSHADECAPS_FOGGOURAUD |
            //D3DPSHADECAPS_FOGPHONG |
            0,

            // dwTextureCaps
            D3DPTEXTURECAPS_PERSPECTIVE |
            //D3DPTEXTURECAPS_POW2 |
            D3DPTEXTURECAPS_ALPHA |
            D3DPTEXTURECAPS_TRANSPARENCY |
            D3DPTEXTURECAPS_BORDER |
            //D3DPTEXTURECAPS_SQUAREONLY |
            D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE |
            D3DPTEXTURECAPS_ALPHAPALETTE |
            //D3DPTEXTURECAPS_NONPOW2CONDITIONAL |
            /*RESERVED |*/
            D3DPTEXTURECAPS_PROJECTED |
            D3DPTEXTURECAPS_CUBEMAP |
            //D3DPTEXTURECAPS_VOLUMEMAP |
            //D3DPTEXTURECAPS_MIPMAP |
            //D3DPTEXTURECAPS_MIPVOLUMEMAP |
            //D3DPTEXTURECAPS_MIPCUBEMAP |
            //D3DPTEXTURECAPS_CUBEMAP_POW2 |
            //D3DPTEXTURECAPS_VOLUMEMAP_POW2 |
            //D3DPTEXTURECAPS_NOPROJECTEDBUMPENV |
            0,

            // dwTextureFilterCaps
            D3DPTFILTERCAPS_NEAREST |
            D3DPTFILTERCAPS_LINEAR |
            D3DPTFILTERCAPS_MIPNEAREST |
            D3DPTFILTERCAPS_MIPLINEAR |
            D3DPTFILTERCAPS_LINEARMIPNEAREST |
            D3DPTFILTERCAPS_LINEARMIPLINEAR |
            /*RESERVED |*/
            /*RESERVED |*/
            D3DPTFILTERCAPS_MINFPOINT |
            D3DPTFILTERCAPS_MINFLINEAR |
            D3DPTFILTERCAPS_MINFANISOTROPIC |
            //D3DPTFILTERCAPS_MINFPYRAMIDALQUAD |
            //D3DPTFILTERCAPS_MINFGAUSSIANQUAD |
            /*RESERVED |*/
            /*RESERVED |*/
            /*RESERVED |*/
            D3DPTFILTERCAPS_MIPFPOINT |
            D3DPTFILTERCAPS_MIPFLINEAR |
            //D3DPTFILTERCAPS_CONVOLUTIONMONO |
            /*RESERVED |*/
            /*RESERVED |*/
            /*RESERVED |*/
            /*RESERVED |*/
            /*RESERVED |*/
            D3DPTFILTERCAPS_MAGFPOINT |
            D3DPTFILTERCAPS_MAGFLINEAR |
            //D3DPTFILTERCAPS_MAGFANISOTROPIC |
            //D3DPTFILTERCAPS_MAGFAFLATCUBIC |
            //D3DPTFILTERCAPS_MAGFGAUSSIANCUBIC |
            0,

            // dwTextureBlendCaps
            D3DPTBLENDCAPS_DECAL |
            D3DPTBLENDCAPS_MODULATE |
            D3DPTBLENDCAPS_DECALALPHA |
            D3DPTBLENDCAPS_MODULATEALPHA |
            //D3DPTBLENDCAPS_DECALMASK |
            //D3DPTBLENDCAPS_MODULATEMASK |
            D3DPTBLENDCAPS_COPY |
            D3DPTBLENDCAPS_ADD |
            0,

            // dwTextureAddressCaps
            D3DPTADDRESSCAPS_WRAP |
            D3DPTADDRESSCAPS_MIRROR |
            D3DPTADDRESSCAPS_CLAMP |
            D3DPTADDRESSCAPS_BORDER |
            D3DPTADDRESSCAPS_INDEPENDENTUV |
            //D3DPTADDRESSCAPS_MIRRORONCE |
            0,

            // dwStippleWidth
            0,

            // dwStippleHeight
            0,
            },
            {   // dpcTriCaps
                sizeof(D3DPRIMCAPS),

                // dwMiscCaps
                //D3DPMISCCAPS_MASKPLANES
                D3DPMISCCAPS_MASKZ |
                //D3DPMISCCAPS_LINEPATTERNREP |
                //D3DPMISCCAPS_CONFORMANT |
            D3DPMISCCAPS_CULLNONE |
            D3DPMISCCAPS_CULLCW |
            D3DPMISCCAPS_CULLCCW |
            //D3DPMISCCAPS_COLORWRITEENABLE |
            //D3DPMISCCAPS_CLIPPLANESCALEDPOINTS |
            //D3DPMISCCAPS_CLIPTLVERTS |
            //D3DPMISCCAPS_TSSARGTEMP |
            //D3DPMISCCAPS_BLENDOP |
            //D3DPMISCCAPS_NULLREFERENCE |
            //D3DPMISCCAPS_FOGINFVF |
            //D3DPMISCCAPS_INDEPENDENTWRITEMASKS |
            //D3DPMISCCAPS_PERSTAGECONSTANT |
            //D3DPMISCCAPS_SEPARATEALPHABLEND |
            //D3DPMISCCAPS_MRTINDEPENDENTBITDEPTHS |
            //D3DPMISCCAPS_MRTPOSTPIXELSHADERBLENDING |
            //D3DPMISCCAPS_FOGVERTEXCLAMPED |
            //D3DPMISCCAPS_POSTBLENDSRGBCONVERT |
            0,

            // dwRasterCaps
            D3DPRASTERCAPS_DITHER |
            //D3DPRASTERCAPS_ROP2 |
            //D3DPRASTERCAPS_XOR |
            //D3DPRASTERCAPS_PAT |
            D3DPRASTERCAPS_ZTEST |
            D3DPRASTERCAPS_SUBPIXEL |
            //D3DPRASTERCAPS_SUBPIXELX |
            D3DPRASTERCAPS_FOGVERTEX |
            D3DPRASTERCAPS_FOGTABLE |
            //D3DPRASTERCAPS_STIPPLE |
            //D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT |
            D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT |
            D3DPRASTERCAPS_ANTIALIASEDGES |
            D3DPRASTERCAPS_MIPMAPLODBIAS |
            D3DPRASTERCAPS_ZBIAS |
            //D3DPRASTERCAPS_ZBUFFERLESSHSR |
            D3DPRASTERCAPS_FOGRANGE |
            D3DPRASTERCAPS_ANISOTROPY |
            //D3DPRASTERCAPS_WBUFFER |
            //D3DPRASTERCAPS_TRANSLUCENTSORTINDEPENDENT |
            D3DPRASTERCAPS_WFOG |
            D3DPRASTERCAPS_ZFOG |
            //D3DPRASTERCAPS_COLORPERSPECTIVE |
            //D3DPRASTERCAPS_STRETCHBLTMULTISAMPLE |
            //D3DPRASTERCAPS_SCISSORTEST |
            //D3DPRASTERCAPS_SLOPESCALEDEPTHBIAS |
            //D3DPRASTERCAPS_DEPTHBIAS |
            //D3DPRASTERCAPS_MULTISAMPLE_TOGGLE |
            0,

            // dwZCmpCaps
            D3DPCMPCAPS_NEVER |
            D3DPCMPCAPS_LESS |
            D3DPCMPCAPS_EQUAL |
            D3DPCMPCAPS_LESSEQUAL |
            D3DPCMPCAPS_GREATER |
            D3DPCMPCAPS_NOTEQUAL |
            D3DPCMPCAPS_GREATEREQUAL |
            D3DPCMPCAPS_ALWAYS |
            0,

            // dwSrcBlendCaps
            D3DPBLENDCAPS_ZERO |
            D3DPBLENDCAPS_ONE |
            D3DPBLENDCAPS_SRCCOLOR |
            D3DPBLENDCAPS_INVSRCCOLOR |
            D3DPBLENDCAPS_SRCALPHA |
            D3DPBLENDCAPS_INVSRCALPHA |
            D3DPBLENDCAPS_DESTALPHA |
            D3DPBLENDCAPS_INVDESTALPHA |
            D3DPBLENDCAPS_DESTCOLOR |
            D3DPBLENDCAPS_INVDESTCOLOR |
            D3DPBLENDCAPS_SRCALPHASAT |
            D3DPBLENDCAPS_BOTHSRCALPHA |
            D3DPBLENDCAPS_BOTHINVSRCALPHA |
            //D3DPBLENDCAPS_BLENDFACTOR |
            //D3DPBLENDCAPS_SRCCOLOR2 |
            //D3DPBLENDCAPS_INVSRCCOLOR2 |
            0,

            // dwDestBlendCaps
            D3DPBLENDCAPS_ZERO |
            D3DPBLENDCAPS_ONE |
            D3DPBLENDCAPS_SRCCOLOR |
            D3DPBLENDCAPS_INVSRCCOLOR |
            D3DPBLENDCAPS_SRCALPHA |
            D3DPBLENDCAPS_INVSRCALPHA |
            D3DPBLENDCAPS_DESTALPHA |
            D3DPBLENDCAPS_INVDESTALPHA |
            D3DPBLENDCAPS_DESTCOLOR |
            D3DPBLENDCAPS_INVDESTCOLOR |
            D3DPBLENDCAPS_SRCALPHASAT |
            D3DPBLENDCAPS_BOTHSRCALPHA |
            D3DPBLENDCAPS_BOTHINVSRCALPHA |
            //D3DPBLENDCAPS_BLENDFACTOR |
            //D3DPBLENDCAPS_SRCCOLOR2 |
            //D3DPBLENDCAPS_INVSRCCOLOR2 |
            0,

            // dwAlphaCmpCaps
            D3DPCMPCAPS_NEVER |
            D3DPCMPCAPS_LESS |
            D3DPCMPCAPS_EQUAL |
            D3DPCMPCAPS_LESSEQUAL |
            D3DPCMPCAPS_GREATER |
            D3DPCMPCAPS_NOTEQUAL |
            D3DPCMPCAPS_GREATEREQUAL |
            D3DPCMPCAPS_ALWAYS |
            0,

            // dwShadeCaps
            //D3DPSHADECAPS_COLORFLATMONO |
            D3DPSHADECAPS_COLORFLATRGB |
            //D3DPSHADECAPS_COLORGOURAUDMONO |
            D3DPSHADECAPS_COLORGOURAUDRGB |
            //D3DPSHADECAPS_COLORPHONGMONO |
            //D3DPSHADECAPS_COLORPHONGRGB |
            //D3DPSHADECAPS_SPECULARFLATMONO |
            D3DPSHADECAPS_SPECULARFLATRGB |
            //D3DPSHADECAPS_SPECULARGOURAUDMONO |
            D3DPSHADECAPS_SPECULARGOURAUDRGB |
            //D3DPSHADECAPS_SPECULARPHONGMONO |
            //D3DPSHADECAPS_SPECULARPHONGRGB |
            D3DPSHADECAPS_ALPHAFLATBLEND |
            //D3DPSHADECAPS_ALPHAFLATSTIPPLED |
            D3DPSHADECAPS_ALPHAGOURAUDBLEND |
            //D3DPSHADECAPS_ALPHAGOURAUDSTIPPLED |
            //D3DPSHADECAPS_ALPHAPHONGBLEND |
            //D3DPSHADECAPS_ALPHAPHONGSTIPPLED |
            D3DPSHADECAPS_FOGFLAT |
            D3DPSHADECAPS_FOGGOURAUD |
            //D3DPSHADECAPS_FOGPHONG |
            0,

            // dwTextureCaps
            D3DPTEXTURECAPS_PERSPECTIVE |
            //D3DPTEXTURECAPS_POW2 |
            D3DPTEXTURECAPS_ALPHA |
            D3DPTEXTURECAPS_TRANSPARENCY |
            D3DPTEXTURECAPS_BORDER |
            //D3DPTEXTURECAPS_SQUAREONLY |
            D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE |
            D3DPTEXTURECAPS_ALPHAPALETTE |
            //D3DPTEXTURECAPS_NONPOW2CONDITIONAL |
            /*RESERVED |*/
            D3DPTEXTURECAPS_PROJECTED |
            D3DPTEXTURECAPS_CUBEMAP |
            //D3DPTEXTURECAPS_VOLUMEMAP |
            //D3DPTEXTURECAPS_MIPMAP |
            //D3DPTEXTURECAPS_MIPVOLUMEMAP |
            //D3DPTEXTURECAPS_MIPCUBEMAP |
            //D3DPTEXTURECAPS_CUBEMAP_POW2 |
            //D3DPTEXTURECAPS_VOLUMEMAP_POW2 |
            //D3DPTEXTURECAPS_NOPROJECTEDBUMPENV |
            0,

            // dwTextureFilterCaps
            D3DPTFILTERCAPS_NEAREST |
            D3DPTFILTERCAPS_LINEAR |
            D3DPTFILTERCAPS_MIPNEAREST |
            D3DPTFILTERCAPS_MIPLINEAR |
            D3DPTFILTERCAPS_LINEARMIPNEAREST |
            D3DPTFILTERCAPS_LINEARMIPLINEAR |
            /*RESERVED |*/
            /*RESERVED |*/
            D3DPTFILTERCAPS_MINFPOINT |
            D3DPTFILTERCAPS_MINFLINEAR |
            D3DPTFILTERCAPS_MINFANISOTROPIC |
            //D3DPTFILTERCAPS_MINFPYRAMIDALQUAD |
            //D3DPTFILTERCAPS_MINFGAUSSIANQUAD |
            /*RESERVED |*/
            /*RESERVED |*/
            /*RESERVED |*/
            D3DPTFILTERCAPS_MIPFPOINT |
            D3DPTFILTERCAPS_MIPFLINEAR |
            //D3DPTFILTERCAPS_CONVOLUTIONMONO |
            /*RESERVED |*/
            /*RESERVED |*/
            /*RESERVED |*/
            /*RESERVED |*/
            /*RESERVED |*/
            D3DPTFILTERCAPS_MAGFPOINT |
            D3DPTFILTERCAPS_MAGFLINEAR |
            D3DPTFILTERCAPS_MAGFANISOTROPIC |
            //D3DPTFILTERCAPS_MAGFAFLATCUBIC |
            //D3DPTFILTERCAPS_MAGFGAUSSIANCUBIC |
            0,

            // dwTextureBlendCaps
            D3DPTBLENDCAPS_DECAL |
            D3DPTBLENDCAPS_MODULATE |
            D3DPTBLENDCAPS_DECALALPHA |
            D3DPTBLENDCAPS_MODULATEALPHA |
            //D3DPTBLENDCAPS_DECALMASK |
            //D3DPTBLENDCAPS_MODULATEMASK |
            D3DPTBLENDCAPS_COPY |
            D3DPTBLENDCAPS_ADD |
            0,

            // dwTextureAddressCaps
            D3DPTADDRESSCAPS_WRAP |
            D3DPTADDRESSCAPS_MIRROR |
            D3DPTADDRESSCAPS_CLAMP |
            D3DPTADDRESSCAPS_BORDER |
            D3DPTADDRESSCAPS_INDEPENDENTUV |
            //D3DPTADDRESSCAPS_MIRRORONCE |
            0,

            // dwStippleWidth
            0,

            // dwStippleHeight
            0,
            },
            DDBD_16 | DDBD_32,
            DDBD_16 | DDBD_24 | DDBD_32,
            0,
            0,
        },
            0,
            0,
            0,
            NULL
        };

        memcpy(pCaps, &cD3d3Caps, sizeof(D3DHAL_GLOBALDRIVERDATA));
    }

    /*
    * List of operations supported on formats in DX8+ texture list.
    * See the DX8 DDK for a complete description of these flags.
    */
#define D3DFORMAT_OP_TEXTURE                    0x00000001L
#define D3DFORMAT_OP_VOLUMETEXTURE              0x00000002L
#define D3DFORMAT_OP_CUBETEXTURE                0x00000004L
#define D3DFORMAT_OP_OFFSCREEN_RENDERTARGET     0x00000008L
#define D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET   0x00000010L
#define D3DFORMAT_OP_ZSTENCIL                   0x00000040L
#define D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH 0x00000080L

    /*
    * This DDPF flag is used by drivers to signify that this format is new and may be
    * a candidate for hiding from certain applications
    * KEEP THIS DEFINITION IN SYNC WITH THAT OF DDPF_RESERVED1 IN DDRAW.H
    */
#define DDPF_NOVEL_TEXTURE_FORMAT                               0x00100000l


    /*
    * This DDPF flag is used to indicate a DX8+ format capability entry in
    * the texture format list. It is not visible to applications.
    */
#define DDPF_D3DFORMAT                                          0x00200000l

    /*
    * List of operations supported on formats in DX8+ texture list.
    * See the DX8 DDK for a complete description of these flags.
    */
#define D3DFORMAT_OP_TEXTURE                    0x00000001L
#define D3DFORMAT_OP_VOLUMETEXTURE              0x00000002L
#define D3DFORMAT_OP_CUBETEXTURE                0x00000004L
#define D3DFORMAT_OP_OFFSCREEN_RENDERTARGET     0x00000008L
#define D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET   0x00000010L
#define D3DFORMAT_OP_ZSTENCIL                   0x00000040L
#define D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH 0x00000080L

    // This format can be used as a render target if the current display mode
    // is the same depth if the alpha channel is ignored. e.g. if the device 
    // can render to A8R8G8B8 when the display mode is X8R8G8B8, then the
    // format op list entry for A8R8G8B8 should have this cap. 
#define D3DFORMAT_OP_SAME_FORMAT_UP_TO_ALPHA_RENDERTARGET 0x00000100L

    // This format contains DirectDraw support (including Flip).  This flag
    // should not to be set on alpha formats.
#define D3DFORMAT_OP_DISPLAYMODE                0x00000400L

    // The rasterizer can support some level of Direct3D support in this format
    // and implies that the driver can create a Context in this mode (for some 
    // render target format).  When this flag is set, the D3DFORMAT_OP_DISPLAYMODE
    // flag must also be set.
#define D3DFORMAT_OP_3DACCELERATION             0x00000800L

    // If the driver needs a private format to be D3D or driver manageable,
    // then it needs to tell D3D the pixelsize in bits per pixel by setting
    // dwPrivateFormatBitCount in DDPIXELFORMAT and by setting the below
    // format op. If the below format op is not set, then D3D or the driver
    // will NOT be allowed to manage the format.
#define D3DFORMAT_OP_PIXELSIZE                  0x00001000L

    // Indicates that this format can be converted to any RGB format for which
    // D3DFORMAT_MEMBEROFGROUP_ARGB is specified
#define D3DFORMAT_OP_CONVERT_TO_ARGB            0x00002000L

    // Indicates that this format can be used to create offscreen plain surfaces.
#define D3DFORMAT_OP_OFFSCREENPLAIN             0x00004000L

    // Indicated that this format can be read as an SRGB texture (meaning that the
    // sampler will linearize the looked up data)
#define D3DFORMAT_OP_SRGBREAD                   0x00008000L

    // Indicates that this format can be used in the bumpmap instructions
#define D3DFORMAT_OP_BUMPMAP                    0x00010000L

    // Indicates that this format can be sampled by the displacement map sampler
#define D3DFORMAT_OP_DMAP                       0x00020000L

    // Indicates that this format cannot be used with texture filtering
#define D3DFORMAT_OP_NOFILTER                   0x00040000L

    // Indicates that format conversions are supported to this RGB format if
    // D3DFORMAT_OP_CONVERT_TO_ARGB is specified in the source format.
#define D3DFORMAT_MEMBEROFGROUP_ARGB            0x00080000L

    // Indicated that this format can be written as an SRGB target (meaning that the
    // pixel pipe will DE-linearize data on output to format)
#define D3DFORMAT_OP_SRGBWRITE                  0x00100000L

    // Indicates that this format cannot be used with alpha blending
#define D3DFORMAT_OP_NOALPHABLEND               0x00200000L

    //Indicates that the device can auto-generated sublevels for resources
    //of this format
#define D3DFORMAT_OP_AUTOGENMIPMAP              0x00400000L

    // Indicates that this format cannot be used by vertex texture sampler
#define D3DFORMAT_OP_VERTEXTEXTURE              0x00800000L 

    // Indicates that this format supports neither texture coordinate wrap modes, nor mipmapping
#define D3DFORMAT_OP_NOTEXCOORDWRAPNORMIP		0x01000000L

    static UINT GetD3DQueryTypes(D3DQUERYTYPE* pQueryTypes, UINT NumQueries)
    {
        UINT NumQueriesOut = _countof(g_cSupportedQueryTypes);
        if (pQueryTypes)
        {
            NumQueriesOut = min(NumQueriesOut, NumQueries);
            memcpy(pQueryTypes, g_cSupportedQueryTypes, sizeof(D3DQUERYTYPE) * NumQueriesOut);
        }
        return NumQueriesOut;
    }
}

```

`include/9on12Constants.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#pragma once

namespace D3D9on12
{
    class HeapAllocator;

    struct Float4
    {
        float data[4];

        Float4(){};

        Float4(const Float4&  other)
        {
            data[0] = other.data[0];
            data[1] = other.data[1];
            data[2] = other.data[2];
            data[3] = other.data[3];
        }
    };

    struct Int4
    {
        UINT data[4];
        Int4(){};

        Int4(const Int4&  other)
        {
            data[0] = other.data[0];
            data[1] = other.data[1];
            data[2] = other.data[2];
            data[3] = other.data[3];
        }
    };

    struct ConstantBufferBinding
    {
        ConstantBufferBinding(UINT shaderRegister, Device& device) :
            m_allocator(device, 1024*1024, D3D12_CONSTANT_BUFFER_DATA_PLACEMENT_ALIGNMENT),
            m_shaderRegister(shaderRegister){};

        void Version(const void* pData, UINT dataSize);
        void Destroy();

        // Because a roll over may happen at any time, 
        // each binding must have it's own allocator so 
        // that the resource doesn't get pulled from under it
        FastUploadAllocator m_allocator;
        FastUploadAllocator::SubBuffer m_buffer;
        UINT m_shaderRegister;
    };

    class ConstantsManager
    {
        struct ConstantBufferData
        {
            ConstantBufferData(UINT SizePerElement, UINT NumElements, UINT shaderRegister, Device& device) :
                m_sizePerElement(SizePerElement),
                m_lastCopySize(0),
                m_dataDirty(false),
                m_binding(shaderRegister, device)
            {
                m_data.resize(m_sizePerElement * NumElements);
                memset(m_data.data(), 0, m_data.size());
            }

            void Destroy() { m_binding.Destroy(); }

            void SetData(const void* pData, UINT startReg, UINT num)
            {
                UINT copySize = num * m_sizePerElement;
                UINT startOffset = startReg * m_sizePerElement;
                BYTE *pDest = m_data.data() + startOffset;
                Check9on12(startOffset + copySize <= m_data.size());

                memcpy(pDest, pData, copySize);
                m_dataDirty = true;
            }

            Result UpdateData(Device& /*device*/, UINT maxSet)
            {
                Result result = Result::S_SUCCESS;
                // Even if the contents aren't dirty, we should update the data if 
                // the maxSet has increased from the last binding
                if (maxSet && (m_dataDirty || maxSet > m_lastCopySize))
                {
                    UINT dataSize = min(maxSet * m_sizePerElement, static_cast<UINT>(m_data.size()));
                    m_binding.Version(m_data.data(), dataSize);

                    m_dataDirty = false;
                    m_lastCopySize = maxSet;
                    result = Result::S_CHANGE;
                }

                return result;
            }

            void ReplaceResource(ConstantBufferBinding& nullCB)
            {
                m_binding.m_buffer = nullCB.m_buffer;
            }

            ConstantBufferBinding m_binding;

        private:
            std::vector<BYTE> m_data;
            const UINT m_sizePerElement;
            size_t m_lastCopySize;

            bool m_dataDirty;
        };

        struct StageConstants
        {
            StageConstants(D3D12TranslationLayer::EShaderStage type, Device& device) :
                m_floats(sizeof(Float4), max(MAX_VS_CONSTANTSF, MAX_PS_CONSTANTSF), ShaderConv::CB_FLOAT, device),
                m_integers(sizeof(Int4), max(MAX_VS_CONSTANTSI, MAX_PS_CONSTANTSI), ShaderConv::CB_INT, device),
                m_booleans(sizeof(BOOL), max(MAX_VS_CONSTANTSB, MAX_PS_CONSTANTSB), ShaderConv::CB_BOOL, device),
                m_shaderType(type){}

            void Destroy();

            ConstantBufferData &GetConstantBufferData(ShaderConv::eConstantBuffers type)
            {
                switch (type)
                {
                case ShaderConv::CB_FLOAT:
                    return m_floats;
                case ShaderConv::CB_INT:
                    return m_integers;
                case ShaderConv::CB_BOOL:
                    return m_booleans;
                default:
                    Check9on12(false); // Invalid type passed in
                    return *(ConstantBufferData*)nullptr;
                }
            }

            void UpdateAppVisibleAndBindToPipeline(Device& device, UINT maxFloats, UINT maxInts, UINT maxBools);
            void NullOutBindings(Device& device, ConstantBufferBinding& nullCB);

        private:
            const D3D12TranslationLayer::EShaderStage m_shaderType;
            ConstantBufferData m_floats;
            ConstantBufferData m_integers;
            ConstantBufferData m_booleans;
        };

        struct VertexShaderConstants : public StageConstants
        {
            VertexShaderConstants(Device& device) :
                m_extension(ShaderConv::CB_VS_EXT, device),
                StageConstants(D3D12TranslationLayer::EShaderStage::e_VS, device){};
            void Destroy();

            ConstantBufferBinding m_extension;
            bool m_dirty = true;
        };

        struct GeometryShaderConstants
        {
            GeometryShaderConstants(Device& device) :
                m_extension(ShaderConv::CB_VS_EXT, device) {};

            void Destroy();

            ConstantBufferBinding m_extension;
            bool m_dirty = true;
        };

        struct PixelShaderConstants : public StageConstants
        {
            PixelShaderConstants(Device& device) :
                m_extension1(ShaderConv::CB_PS_EXT, device),
                m_extension2(ShaderConv::CB_PS_EXT2, device),
                m_extension3(ShaderConv::CB_PS_EXT3, device),
                StageConstants(D3D12TranslationLayer::EShaderStage::e_PS, device){};
            void Destroy();

            ConstantBufferBinding m_extension1;
            ConstantBufferBinding m_extension2;
            ConstantBufferBinding m_extension3;

            bool m_dirty = true;
        };

    public:
        ConstantsManager(Device &device) :
            m_device(device),
            m_vertexShaderData(device),
            m_geometryShaderData(device),
            m_pixelShaderData(device),
            m_nullCB(0, device)
            {}

        void Destroy();

        HRESULT Init();

        void BindShaderConstants();

        VertexShaderConstants& GetVertexShaderConstants() { return m_vertexShaderData; }
        PixelShaderConstants& GetPixelShaderConstants() { return m_pixelShaderData; }
        ConstantBufferBinding& NullCB() { return m_nullCB; }

        void UpdateVertexShaderExtension(const ShaderConv::VSCBExtension& data);
        void UpdateGeometryShaderExtension(const ShaderConv::VSCBExtension& data);
        Result UpdatePixelShaderExtension(const ShaderConv::eConstantBuffers extension, const void* pData, size_t dataSize);

        static void BindToPipeline(Device& device, ConstantBufferBinding& buffer, D3D12TranslationLayer::EShaderStage shaderStage);

        static const size_t g_cMaxConstantBufferSize = 256 * (sizeof(float) * 4); //256 float4 registers
    private:

        Device &m_device;
        VertexShaderConstants m_vertexShaderData;
        GeometryShaderConstants m_geometryShaderData;
        PixelShaderConstants m_pixelShaderData;

        ConstantBufferBinding m_nullCB;
    };

};
```

`include/9on12DDI.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#pragma once

namespace D3D9on12
{
    void APIENTRY GetPrivateDDITable(D3D9ON12_PRIVATE_DDI_TABLE *pPrivateDDITable);
    HRESULT APIENTRY GetPrivateDDITableVersioned(_Inout_updates_bytes_(ddiTableSize) void* pPrivateDDITableVersioned, UINT ddiTableSize);

    /* Private DDI for 9on12 */
    _Check_return_ HRESULT APIENTRY OpenAdapter_Private(_Inout_ D3DDDIARG_OPENADAPTER* pOpenAdapter, _In_ LUID *pLUID, _In_opt_ D3D9ON12_CREATE_DEVICE_ARGS* pArgs);

    _Check_return_ HRESULT APIENTRY GetSharedGDIHandle_Private(_In_ HANDLE hDevice, HANDLE DriverResource, HANDLE *pSharedHandle);
    _Check_return_ HRESULT APIENTRY CreateSharedNTHandle_Private(_In_ HANDLE hDevice, HANDLE DriverResource, SECURITY_DESCRIPTOR *pSD, HANDLE *pSharedHandle);
    _Check_return_ HRESULT APIENTRY GetDeviceExecutionState_Private(_In_ HANDLE hDevice);
    _Check_return_ HRESULT APIENTRY KmdPresent(_In_ HANDLE hDevice, D3DKMT_PRESENT *pKMTArgs);

    _Check_return_ UINT APIENTRY QueryResourcePrivateDriverDataSize(HANDLE hDD);
    _Check_return_ HRESULT APIENTRY OpenResource_Private(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_OPENRESOURCE* hOpenResource, _In_ _D3D9ON12_OPEN_RESOURCE_ARGS *pD3D9on12OpenResource);

    _Check_return_ HRESULT APIENTRY CreateKMTHandle(HANDLE hDD, _In_ HANDLE resourceHandle, _Out_ D3DKMT_HANDLE *pHKMResource, _Out_writes_bytes_(dataSize) void *pResourcePrivateDriverData, _In_ UINT dataSize);
    _Check_return_ HRESULT APIENTRY QueryResourceInfoFromKMTHandle(HANDLE hDD, D3DKMT_HANDLE hKMResource, _Out_ D3D9ON12_RESOURCE_INFO *pResourceInfo);
    _Check_return_ HRESULT APIENTRY DestroyKMTHandle(HANDLE hDD, D3DKMT_HANDLE hKMResource);

    _Check_return_ HRESULT APIENTRY CreateFence(HANDLE hDD, UINT64 InitialValue, UINT Flags, __out HANDLE* phFence);
    _Check_return_ HRESULT APIENTRY OpenFence(HANDLE hDD, HANDLE hSharedHandle, __out BOOL* pbMonitored, __out HANDLE* phFence);
    _Check_return_ HRESULT APIENTRY ShareFence(HANDLE hFence, __in_opt SECURITY_DESCRIPTOR*, __out HANDLE*);
    _Check_return_ HRESULT APIENTRY WaitForFence(HANDLE hFence, UINT64 NewFenceValue);
    _Check_return_ HRESULT APIENTRY SignalFence(HANDLE hFence, UINT64 NewFenceValue);
    void APIENTRY DestroyTrackedFence(HANDLE hFence);
    UINT64 APIENTRY GetCompletedFenceValue(HANDLE hFence);

    _Check_return_ HRESULT APIENTRY CreateResourceWrappingHandle(HANDLE hDD, _In_ IUnknown* pD3D12Resource, _Out_ HANDLE* phWrappingHandle);
    void APIENTRY DestroyResourceWrappingHandle(HANDLE hDD, HANDLE hWrappingHandle);
    _Check_return_ HRESULT APIENTRY GetD3D12Device(HANDLE hDD, REFIID riid, void** ppv);
    _Check_return_ HRESULT APIENTRY GetD3D12Resource(HANDLE hResource, REFIID riid, void** ppv);
    _Check_return_ HRESULT APIENTRY AddResourceWaitsToQueue(HANDLE hResource, ID3D12CommandQueue* pCommmandQueue);
    _Check_return_ HRESULT APIENTRY AddDeferredWaitsToResource(HANDLE hResource, UINT NumSync, UINT64* pSignalValues, ID3D12Fence** ppFences);
    void APIENTRY SetCurrentResourceState(HANDLE hDD, HANDLE hResource, UINT State);
    void APIENTRY TransitionResource(HANDLE hDD, HANDLE hResource, UINT State);

    void APIENTRY SetMaximumFrameLatency(HANDLE hDD, UINT MaxFrameLatency);
    BOOL APIENTRY IsMaximumFrameLatencyReached(HANDLE hDD);

    /*interface version 2*/
    _Check_return_ HRESULT APIENTRY OpenAdapter2_Private(_Inout_ D3DDDIARG_OPENADAPTER* pOpenAdapter, _In_ LUID* pLUID, _In_opt_ D3D9ON12_CREATE_DEVICE_ARGS2* pArgs);
    _Check_return_ HRESULT APIENTRY CloseAndSubmitGraphicsCommandListForPresent(_In_ HANDLE hDevice, BOOL commandsAdded, _In_reads_(numSrcSurfaces) const D3DDDIARG_PRESENTSURFACE* pSrcSurfaces, UINT numSrcSurfaces, _In_opt_ HANDLE hDestResource, _In_ D3DKMT_PRESENT* pKMTPresent);
    _Check_return_ HRESULT APIENTRY PreExecuteCommandList(_In_ HANDLE hDevice, D3D9ON12_COMMANDLIST_TYPE commandListType);
    _Check_return_ HRESULT APIENTRY PostExecuteCommandList(_In_ HANDLE hDevice, D3D9ON12_COMMANDLIST_TYPE commandListType);

    /* Adapter forward declarations */
    _Check_return_ HRESULT APIENTRY GetCaps(_In_ HANDLE hAdapter, _Inout_ CONST D3DDDIARG_GETCAPS* pGetCaps);
    _Check_return_ HRESULT APIENTRY CreateDevice(_In_ HANDLE hAdapter, _Inout_ D3DDDIARG_CREATEDEVICE* pCreateDevice);
    _Check_return_ HRESULT APIENTRY CloseAdapter(_In_ HANDLE hAdapter);
    _Check_return_ HRESULT APIENTRY OpenAdapter(_Inout_ D3DDDIARG_OPENADAPTER* pOpenAdapter);

    /* Device forward declarations */
    _Check_return_ HRESULT APIENTRY SetRenderState(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_RENDERSTATE*);
    _Check_return_ HRESULT APIENTRY UpdateWindowInfo(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_WINFO*);
    _Check_return_ HRESULT APIENTRY ValidateDevice(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_VALIDATETEXTURESTAGESTATE*);
    _Check_return_ HRESULT APIENTRY SetTextureStageState(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_TEXTURESTAGESTATE*);
    _Check_return_ HRESULT APIENTRY SetTexture(_In_ HANDLE hDevice, _In_ UINT, _In_ HANDLE);
    _Check_return_ HRESULT APIENTRY SetPixelShader(_In_ HANDLE hDevice, _In_ HANDLE);
    _Check_return_ HRESULT APIENTRY SetPixleShaderConstant(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETPIXELSHADERCONST*, _In_ CONST FLOAT*);
    _Check_return_ HRESULT APIENTRY SetStreamSourceUM(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETSTREAMSOURCEUM*, _In_ CONST VOID*);
    _Check_return_ HRESULT APIENTRY SetIndices(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETINDICES*);
    _Check_return_ HRESULT APIENTRY SetIndicesUM(_In_ HANDLE hDevice, _In_ UINT, _In_ CONST VOID*);    
    _Check_return_ HRESULT APIENTRY DrawPrimitive(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_DRAWPRIMITIVE*, _In_opt_ CONST UINT*);
    _Check_return_ HRESULT APIENTRY DrawIndexedPrimitive(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_DRAWINDEXEDPRIMITIVE*);
    _Check_return_ HRESULT APIENTRY DrawRectPatch(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_DRAWRECTPATCH*, _In_ CONST D3DDDIRECTPATCH_INFO*, _In_ CONST FLOAT*);
    _Check_return_ HRESULT APIENTRY DrawTriPatch(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_DRAWTRIPATCH*, _In_ CONST D3DDDITRIPATCH_INFO*, _In_ CONST FLOAT*);
    _Check_return_ HRESULT APIENTRY DrawPrimitive2(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_DRAWPRIMITIVE2*);
    _Check_return_ HRESULT APIENTRY DrawIndexedPrimitive2(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_DRAWINDEXEDPRIMITIVE2*, _In_ UINT, _In_ CONST VOID*, _In_opt_ CONST UINT*);
    _Check_return_ HRESULT APIENTRY SetState(_In_ HANDLE hDevice, _In_ D3DDDIARG_STATESET*);
    _Check_return_ HRESULT APIENTRY SetPriority(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETPRIORITY*);
    _Check_return_ HRESULT APIENTRY Clear(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_CLEAR*, _In_ UINT, _In_ CONST RECT*);
    _Check_return_ HRESULT APIENTRY UpdatePalette(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_UPDATEPALETTE*, _In_ CONST PALETTEENTRY*);
    _Check_return_ HRESULT APIENTRY SetPalette(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETPALETTE*);
    _Check_return_ HRESULT APIENTRY SetVertexShaderConstF(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETVERTEXSHADERCONST*, _In_ CONST VOID*);
    _Check_return_ HRESULT APIENTRY MultiplyTransform(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_MULTIPLYTRANSFORM*);
    _Check_return_ HRESULT APIENTRY SetTransform(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETTRANSFORM*);
    _Check_return_ HRESULT APIENTRY SetViewport(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_VIEWPORTINFO*);
    _Check_return_ HRESULT APIENTRY SetZRange(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_ZRANGE*);
    _Check_return_ HRESULT APIENTRY SetMaterial(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETMATERIAL*);
    _Check_return_ HRESULT APIENTRY SetLight(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETLIGHT*, _In_ CONST D3DDDI_LIGHT*);
    _Check_return_ HRESULT APIENTRY CreateLight(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_CREATELIGHT*);
    _Check_return_ HRESULT APIENTRY DestroyLight(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_DESTROYLIGHT*);
    _Check_return_ HRESULT APIENTRY SetClipPlane(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETCLIPPLANE*);
    _Check_return_ HRESULT APIENTRY GetInfo(_In_ HANDLE hDevice, _In_ UINT, _Out_writes_bytes_(DevInfoSize)VOID*, _In_ UINT DevInfoSize);
    _Check_return_ HRESULT APIENTRY Lock(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_LOCK*);
    _Check_return_ HRESULT APIENTRY Unlock(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_UNLOCK*);
    _Check_return_ HRESULT APIENTRY LockAsync(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_LOCKASYNC*);
    _Check_return_ HRESULT APIENTRY UnlockAsync(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_UNLOCKASYNC*);
    _Check_return_ HRESULT APIENTRY Rename(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_RENAME*);
    _Check_return_ HRESULT APIENTRY DestroyResource(_In_ HANDLE hDevice, _In_ HANDLE);
    _Check_return_ HRESULT APIENTRY SetDisplayMode(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETDISPLAYMODE*);
    _Check_return_ HRESULT APIENTRY CreateVertexShaderDecl(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_CREATEVERTEXSHADERDECL*, _In_ CONST D3DDDIVERTEXELEMENT*);
    _Check_return_ HRESULT APIENTRY SetVertexShaderDecl(_In_ HANDLE hDevice, _In_ HANDLE);
    _Check_return_ HRESULT APIENTRY DeleteVertexShaderDecl(_In_ HANDLE hDevice, _In_ HANDLE);
    _Check_return_ HRESULT APIENTRY CreateVertexShaderFunc(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_CREATEVERTEXSHADERFUNC*, _In_ CONST UINT*);
    _Check_return_ HRESULT APIENTRY SetVertexShaderFunc(_In_ HANDLE hDevice, _In_ HANDLE);
    _Check_return_ HRESULT APIENTRY DeleteVertexShaderFunc(_In_ HANDLE hDevice, _In_ HANDLE);
    _Check_return_ HRESULT APIENTRY SetVertexShaderConstI(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETVERTEXSHADERCONSTI*, _In_ CONST INT*);
    _Check_return_ HRESULT APIENTRY SetVertexShaderConstB(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETVERTEXSHADERCONSTB*, _In_ CONST BOOL*);
    _Check_return_ HRESULT APIENTRY SetScissorRect(_In_ HANDLE hDevice, _In_ CONST RECT*);
    _Check_return_ HRESULT APIENTRY SetStreamSource(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETSTREAMSOURCE*);
    _Check_return_ HRESULT APIENTRY SetStreamSourceFreq(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETSTREAMSOURCEFREQ*);
    _Check_return_ HRESULT APIENTRY SetConvolutionKernelMono(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETCONVOLUTIONKERNELMONO*);
    _Check_return_ HRESULT APIENTRY ComposeRects(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_COMPOSERECTS*);
    _Check_return_ HRESULT APIENTRY Blit(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_BLT*);
    _Check_return_ HRESULT APIENTRY ColorFill(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_COLORFILL*);
    _Check_return_ HRESULT APIENTRY DepthFill(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_DEPTHFILL*);
    _Check_return_ HRESULT APIENTRY CreateQuery(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_CREATEQUERY*);
    _Check_return_ HRESULT APIENTRY DestroyQuery(_In_ HANDLE hDevice, _In_ CONST HANDLE);
    _Check_return_ HRESULT APIENTRY IssueQuery(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_ISSUEQUERY*);
    _Check_return_ HRESULT APIENTRY GetQueryData(_In_ HANDLE hDevice, _Inout_ CONST D3DDDIARG_GETQUERYDATA*);
    _Check_return_ HRESULT APIENTRY SetRenderTarget(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETRENDERTARGET*);
    _Check_return_ HRESULT APIENTRY SetDepthStencil(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETDEPTHSTENCIL*);
    _Check_return_ HRESULT APIENTRY GenerateMipSubLevels(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_GENERATEMIPSUBLEVELS*);
    _Check_return_ HRESULT APIENTRY SetPixelShaderConstI(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETPIXELSHADERCONSTI*, _In_ CONST INT*);
    _Check_return_ HRESULT APIENTRY SetPixelShaderConstB(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETPIXELSHADERCONSTB*, _In_ CONST BOOL*);
    _Check_return_ HRESULT APIENTRY CreatePixelShader(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_CREATEPIXELSHADER*, _In_ CONST UINT*);
    _Check_return_ HRESULT APIENTRY DeletePixelShader(_In_ HANDLE hDevice, _In_ HANDLE);
    _Check_return_ HRESULT APIENTRY CreateDecodeDevice(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_CREATEDECODEDEVICE*);
    _Check_return_ HRESULT APIENTRY DestroyDecodeDevice(_In_ HANDLE hDevice, _In_ HANDLE);
    _Check_return_ HRESULT APIENTRY SetDecodeRenderTarget(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETDECODERENDERTARGET*);
    _Check_return_ HRESULT APIENTRY DecodeBeginFrame(_In_ HANDLE hDevice, _In_ D3DDDIARG_DECODEBEGINFRAME*);
    _Check_return_ HRESULT APIENTRY DecodeEndFrame(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_DECODEENDFRAME*);
    _Check_return_ HRESULT APIENTRY DecodeExecute(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_DECODEEXECUTE*);
    _Check_return_ HRESULT APIENTRY DecodeExtensionExecuter(_In_ HANDLE hDevice, _Inout_ CONST D3DDDIARG_DECODEEXTENSIONEXECUTE*);
    _Check_return_ HRESULT APIENTRY CreateVideoProcessDevice(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_CREATEVIDEOPROCESSDEVICE*);
    _Check_return_ HRESULT APIENTRY DestroyVideoProcessDevice(_In_ HANDLE hDevice, _In_ HANDLE hVideoProcessor);
    _Check_return_ HRESULT APIENTRY VideoProcessBeginFrame(_In_ HANDLE hDevice, _In_ HANDLE hVideoProcess);
    _Check_return_ HRESULT APIENTRY VideoProcessEndFrame(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_VIDEOPROCESSENDFRAME*);
    _Check_return_ HRESULT APIENTRY SetVideoProcessRenderTarget(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETVIDEOPROCESSRENDERTARGET*);
    _Check_return_ HRESULT APIENTRY VideoProcessBlit(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_VIDEOPROCESSBLT*);
    _Check_return_ HRESULT APIENTRY CreateExtensionDevice(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_CREATEEXTENSIONDEVICE*);
    _Check_return_ HRESULT APIENTRY DestroyExtensionDevice(_In_ HANDLE hDevice, _In_ HANDLE hExtension);
    _Check_return_ HRESULT APIENTRY ExtensionExecute(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_EXTENSIONEXECUTE*);
    _Check_return_ HRESULT APIENTRY DestroyDevice(_In_ HANDLE hDevice);
    _Check_return_ HRESULT APIENTRY CreateOverlay(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_CREATEOVERLAY*);
    _Check_return_ HRESULT APIENTRY UpdateOverlay(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_UPDATEOVERLAY*);
    _Check_return_ HRESULT APIENTRY FlipOverlay(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_FLIPOVERLAY*);
    _Check_return_ HRESULT APIENTRY GetOverlayColorControls(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_GETOVERLAYCOLORCONTROLS*);
    _Check_return_ HRESULT APIENTRY SetOverlayColorControls(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETOVERLAYCOLORCONTROLS*);
    _Check_return_ HRESULT APIENTRY DestroyOverlay(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_DESTROYOVERLAY*);
    _Check_return_ HRESULT APIENTRY QueryResourceResidency(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_QUERYRESOURCERESIDENCY*);
    _Check_return_ HRESULT APIENTRY OpenResource(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_OPENRESOURCE*);
    _Check_return_ HRESULT APIENTRY GetCaptureAllocationHandle(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_GETCAPTUREALLOCATIONHANDLE*);
    _Check_return_ HRESULT APIENTRY CaptureToSystem(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_CAPTURETOSYSMEM*);
    _Check_return_ HRESULT APIENTRY DXVAHD_CreateVideoProcessor(_In_ HANDLE, _Inout_ D3DDDIARG_DXVAHD_CREATEVIDEOPROCESSOR*);
    _Check_return_ HRESULT APIENTRY DXVAHD_SetVideoProcessorBlitState(_In_ HANDLE, _In_ CONST D3DDDIARG_DXVAHD_SETVIDEOPROCESSBLTSTATE*);
    _Check_return_ HRESULT APIENTRY DXVAHD_GetVideoProcessorBlitState(_In_ HANDLE, _Inout_ D3DDDIARG_DXVAHD_GETVIDEOPROCESSBLTSTATEPRIVATE*);
    _Check_return_ HRESULT APIENTRY DXVAHD_SetVideoProcessorStreamState(_In_ HANDLE, _In_ CONST D3DDDIARG_DXVAHD_SETVIDEOPROCESSSTREAMSTATE*);
    _Check_return_ HRESULT APIENTRY DXVAHD_GetVideoProcessorStreamState(_In_ HANDLE, _Inout_ D3DDDIARG_DXVAHD_GETVIDEOPROCESSSTREAMSTATEPRIVATE*);
    _Check_return_ HRESULT APIENTRY DXVAHD_VideoProcessBlitHD(_In_ HANDLE, _In_ CONST D3DDDIARG_DXVAHD_VIDEOPROCESSBLTHD*);
    _Check_return_ HRESULT APIENTRY DXVAHD_DestroyVideoProcessor(_In_ HANDLE, _In_ HANDLE);
    _Check_return_ HRESULT APIENTRY CreateAuthenticatedChannel(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_CREATEAUTHENTICATEDCHANNEL*);
    _Check_return_ HRESULT APIENTRY AuthenticatedChannelKeyExchange(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_AUTHENTICATEDCHANNELKEYEXCHANGE*);
    _Check_return_ HRESULT APIENTRY QueryAuthenticatedChannel(_In_ HANDLE hDevice, _Inout_ CONST D3DDDIARG_QUERYAUTHENTICATEDCHANNEL*);
    _Check_return_ HRESULT APIENTRY ConfigureAuthenticatedChannel(_In_ HANDLE hDevice, _Inout_ CONST D3DDDIARG_CONFIGUREAUTHENTICATEDCHANNEL*);
    _Check_return_ HRESULT APIENTRY DestroyAuthenticatedChannel(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_DESTROYAUTHENTICATEDCHANNEL*);
    _Check_return_ HRESULT APIENTRY CreateCrytoSession(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_CREATECRYPTOSESSION*);
    _Check_return_ HRESULT APIENTRY CrytoSessionKeyExchange(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_CRYPTOSESSIONKEYEXCHANGE*);
    _Check_return_ HRESULT APIENTRY DestroyCryptoSession(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_DESTROYCRYPTOSESSION*);
    _Check_return_ HRESULT APIENTRY EncryptionBlit(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_ENCRYPTIONBLT*);
    _Check_return_ HRESULT APIENTRY GetPitch(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_GETPITCH*);
    _Check_return_ HRESULT APIENTRY StartSessionKeyReresh(_In_ HANDLE hDevice, _Inout_ CONST D3DDDIARG_STARTSESSIONKEYREFRESH*);
    _Check_return_ HRESULT APIENTRY FinishSessionKeyRefresh(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_FINISHSESSIONKEYREFRESH*);
    _Check_return_ HRESULT APIENTRY GetEncryptionBlitKey(_In_ HANDLE hDevice, _Inout_ CONST D3DDDIARG_GETENCRYPTIONBLTKEY*);
    _Check_return_ HRESULT APIENTRY DecryptionBlit(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_DECRYPTIONBLT*);
    _Check_return_ HRESULT APIENTRY ResolveSharedResource(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_RESOLVESHAREDRESOURCE*);
    _Check_return_ HRESULT APIENTRY VolumeBlit1(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_VOLUMEBLT1*);
    _Check_return_ HRESULT APIENTRY BufferBlit1(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_BUFFERBLT1*);
    _Check_return_ HRESULT APIENTRY TextureBlit1(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_TEXBLT1*);
    _Check_return_ HRESULT APIENTRY Discard(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_DISCARD*);
    _Check_return_ HRESULT APIENTRY OfferResources(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_OFFERRESOURCES*);
    _Check_return_ HRESULT APIENTRY ReclaimResources(_In_ HANDLE hDevice, _Inout_ CONST D3DDDIARG_RECLAIMRESOURCES*);
    _Check_return_ HRESULT APIENTRY CheckDirectFlipSupport(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_CHECKDIRECTFLIPSUPPORT*);
    _Check_return_ HRESULT APIENTRY CreateResource2(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_CREATERESOURCE2*);
    _Check_return_ HRESULT APIENTRY CheckMultiplaneOverlaySupport(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_CHECKMULTIPLANEOVERLAYSUPPORT*);
    _Check_return_ HRESULT APIENTRY PresentMultiplaneOverlay(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_PRESENTMULTIPLANEOVERLAY*);
    _Check_return_ HRESULT APIENTRY Flush1(_In_ HANDLE hDevice, UINT /*D3DDDI_FLUSH_FLAGS*/ FlushFlags);
    _Check_return_ HRESULT APIENTRY UpdateSubresourceUP(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_UPDATESUBRESOURCEUP*);
    _Check_return_ HRESULT APIENTRY Present1(_In_ HANDLE hDevice, _In_ D3DDDIARG_PRESENT1*);
    _Check_return_ HRESULT APIENTRY CheckPresentDurationSupport(_In_ HANDLE hDevice, _In_ D3DDDIARG_CHECKPRESENTDURATIONSUPPORT*);
    _Check_return_ HRESULT APIENTRY SetMarkerMode(_In_ HANDLE hDevice, _In_ D3DDDI_MARKERTYPE Type, /*D3DDDI_SETMARKERMODE*/ UINT Flags);
    _Check_return_ HRESULT APIENTRY SetMarker(_In_ HANDLE hDevice);
    VOID APIENTRY AcquireResource(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SYNCTOKEN*);
    VOID APIENTRY ReleaseResource(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SYNCTOKEN*);
    _Check_return_ HRESULT APIENTRY CheckCounter(_In_ HANDLE hDevice, _In_ D3DDDIQUERYTYPE, _Out_ D3DDDI_COUNTER_TYPE*, _Out_ UINT*, _Out_writes_to_opt_(*pNameLength, *pNameLength) LPSTR, _Inout_opt_ UINT* pNameLength, _Out_writes_to_opt_(*pUnitsLength, *pUnitsLength) LPSTR, _Inout_opt_ UINT* pUnitsLength, _Out_writes_to_opt_(*pDescriptionLength, *pDescriptionLength) LPSTR, _Inout_opt_ UINT* pDescriptionLength);
    VOID APIENTRY CheckCounterInfo(_In_ HANDLE hDevice, _Out_ D3DDDIARG_COUNTER_INFO*);

    static const D3DDDI_ADAPTERFUNCS g_9on12AdapterFunctions =
    {
        GetCaps,                                                     /*PFND3DDDI_GETCAPS                       pfnGetCaps;                                           */
        CreateDevice,                                                /*PFND3DDDI_CREATEDEVICE                  pfnCreateDevice;                                      */
        CloseAdapter,                                                /*PFND3DDDI_CLOSEADAPTER                  pfnCloseAdapter;                                      */
    };

   _Check_return_ HRESULT APIENTRY SetPixelShaderConstF(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETPIXELSHADERCONST* pSetConst, _In_ CONST FLOAT* pFloat);

    static const D3DDDI_DEVICEFUNCS g_9on12DeviceFuntions =
    {
        SetRenderState,                         /*PFND3DDDI_SETRENDERSTATE                            pfnSetRenderState;                        */
        UpdateWindowInfo,                       /*PFND3DDDI_UPDATEWINFO                               pfnUpdateWInfo;                           */
        ValidateDevice,                         /*PFND3DDDI_VALIDATEDEVICE                            pfnValidateDevice;                        */
        SetTextureStageState,                   /*PFND3DDDI_SETTEXTURESTAGESTATE                      pfnSetTextureStageState;                  */
        SetTexture,                             /*PFND3DDDI_SETTEXTURE                                pfnSetTexture;                            */
        SetPixelShader,                         /*PFND3DDDI_SETPIXELSHADER                            pfnSetPixelShader;                        */
        SetPixelShaderConstF,                   /*PFND3DDDI_SETPIXELSHADERCONST                       pfnSetPixelShaderConst;                   */
        SetStreamSourceUM,                      /*PFND3DDDI_SETSTREAMSOURCEUM                         pfnSetStreamSourceUm;                     */
        SetIndices,                             /*PFND3DDDI_SETINDICES                                pfnSetIndices;                            */
        SetIndicesUM,                           /*PFND3DDDI_SETINDICESUM                              pfnSetIndicesUm;                          */
        DrawPrimitive,                          /*PFND3DDDI_DRAWPRIMITIVE                             pfnDrawPrimitive;                         */
        DrawIndexedPrimitive,                   /*PFND3DDDI_DRAWINDEXEDPRIMITIVE                      pfnDrawIndexedPrimitive;                  */
        DrawRectPatch,                          /*PFND3DDDI_DRAWRECTPATCH                             pfnDrawRectPatch;                         */
        DrawTriPatch,                           /*PFND3DDDI_DRAWTRIPATCH                              pfnDrawTriPatch;                          */
        DrawPrimitive2,                         /*PFND3DDDI_DRAWPRIMITIVE2                            pfnDrawPrimitive2;                        */
        DrawIndexedPrimitive2,                  /*PFND3DDDI_DRAWINDEXEDPRIMITIVE2                     pfnDrawIndexedPrimitive2;                 */
        nullptr,                                /*PFND3DDDI_VOLBLT                                    pfnVolBlt;                                */
        nullptr,                                /*PFND3DDDI_BUFBLT                                    pfnBufBlt;                                */
        nullptr,                                /*PFND3DDDI_TEXBLT                                    pfnTexBlt;                                */
        SetState,                               /*PFND3DDDI_STATESET                                  pfnStateSet;                              */
        SetPriority,                            /*PFND3DDDI_SETPRIORITY                               pfnSetPriority;                           */
        Clear,                                  /*PFND3DDDI_CLEAR                                     pfnClear;                                 */
        UpdatePalette,                          /*PFND3DDDI_UPDATEPALETTE                             pfnUpdatePalette;                         */
        SetPalette,                             /*PFND3DDDI_SETPALETTE                                pfnSetPalette;                            */
        SetVertexShaderConstF,                  /*PFND3DDDI_SETVERTEXSHADERCONST                      pfnSetVertexShaderConst;                  */
        MultiplyTransform,                      /*PFND3DDDI_MULTIPLYTRANSFORM                         pfnMultiplyTransform;                     */
        SetTransform,                           /*PFND3DDDI_SETTRANSFORM                              pfnSetTransform;                          */
        SetViewport,                            /*PFND3DDDI_SETVIEWPORT                               pfnSetViewport;                           */
        SetZRange,                              /*PFND3DDDI_SETZRANGE                                 pfnSetZRange;                             */
        SetMaterial,                            /*PFND3DDDI_SETMATERIAL                               pfnSetMaterial;                           */
        SetLight,                               /*PFND3DDDI_SETLIGHT                                  pfnSetLight;                              */
        CreateLight,                            /*PFND3DDDI_CREATELIGHT                               pfnCreateLight;                           */
        DestroyLight,                           /*PFND3DDDI_DESTROYLIGHT                              pfnDestroyLight;                          */
        SetClipPlane,                           /*PFND3DDDI_SETCLIPPLANE                              pfnSetClipPlane;                          */
        GetInfo,                                /*PFND3DDDI_GETINFO                                   pfnGetInfo;                               */
        Lock,                                   /*PFND3DDDI_LOCK                                      pfnLock;                                  */
        Unlock,                                 /*PFND3DDDI_UNLOCK                                    pfnUnlock;                                */
        nullptr,                                /*PFND3DDDI_CREATERESOURCE                            pfnCreateResource;                        */
        DestroyResource,                        /*PFND3DDDI_DESTROYRESOURCE                           pfnDestroyResource;                       */
        SetDisplayMode,                         /*PFND3DDDI_SETDISPLAYMODE                            pfnSetDisplayMode;                        */
        nullptr,                                /*PFND3DDDI_PRESENT                                   pfnPresent;                               */
        nullptr,                                /*PFND3DDDI_FLUSH                                     pfnFlush;                                 */
        CreateVertexShaderFunc,                 /*PFND3DDDI_CREATEVERTEXSHADERFUNC                    pfnCreateVertexShaderFunc;                */
        DeleteVertexShaderFunc,                 /*PFND3DDDI_DELETEVERTEXSHADERFUNC                    pfnDeleteVertexShaderFunc;                */
        SetVertexShaderFunc,                    /*PFND3DDDI_SETVERTEXSHADERFUNC                       pfnSetVertexShaderFunc;                   */
        CreateVertexShaderDecl,                 /*PFND3DDDI_CREATEVERTEXSHADERDECL                    pfnCreateVertexShaderDecl;                */
        DeleteVertexShaderDecl,                 /*PFND3DDDI_DELETEVERTEXSHADERDECL                    pfnDeleteVertexShaderDecl;                */
        SetVertexShaderDecl,                    /*PFND3DDDI_SETVERTEXSHADERDECL                       pfnSetVertexShaderDecl;                   */
        SetVertexShaderConstI,                  /*PFND3DDDI_SETVERTEXSHADERCONSTI                     pfnSetVertexShaderConstI;                 */
        SetVertexShaderConstB,                  /*PFND3DDDI_SETVERTEXSHADERCONSTB                     pfnSetVertexShaderConstB;                 */
        SetScissorRect,                         /*PFND3DDDI_SETSCISSORRECT                            pfnSetScissorRect;                        */
        SetStreamSource,                        /*PFND3DDDI_SETSTREAMSOURCE                           pfnSetStreamSource;                       */
        SetStreamSourceFreq,                    /*PFND3DDDI_SETSTREAMSOURCEFREQ                       pfnSetStreamSourceFreq;                   */
        SetConvolutionKernelMono,               /*PFND3DDDI_SETCONVOLUTIONKERNELMONO                  pfnSetConvolutionKernelMono;              */
        ComposeRects,                           /*PFND3DDDI_COMPOSERECTS                              pfnComposeRects;                          */
        Blit,                                   /*PFND3DDDI_BLT                                       pfnBlt;                                   */
        ColorFill,                              /*PFND3DDDI_COLORFILL                                 pfnColorFill;                             */
        DepthFill,                              /*PFND3DDDI_DEPTHFILL                                 pfnDepthFill;                             */
        CreateQuery,                            /*PFND3DDDI_CREATEQUERY                               pfnCreateQuery;                           */
        DestroyQuery,                           /*PFND3DDDI_DESTROYQUERY                              pfnDestroyQuery;                          */
        IssueQuery,                             /*PFND3DDDI_ISSUEQUERY                                pfnIssueQuery;                            */
        GetQueryData,                           /*PFND3DDDI_GETQUERYDATA                              pfnGetQueryData;                          */
        SetRenderTarget,                        /*PFND3DDDI_SETRENDERTARGET                           pfnSetRenderTarget;                       */
        SetDepthStencil,                        /*PFND3DDDI_SETDEPTHSTENCIL                           pfnSetDepthStencil;                       */
        GenerateMipSubLevels,                   /*PFND3DDDI_GENERATEMIPSUBLEVELS                      pfnGenerateMipSubLevels;                  */
        SetPixelShaderConstI,                   /*PFND3DDDI_SETPIXELSHADERCONSTI                      pfnSetPixelShaderConstI;                  */
        SetPixelShaderConstB,                   /*PFND3DDDI_SETPIXELSHADERCONSTB                      pfnSetPixelShaderConstB;                  */
        CreatePixelShader,                      /*PFND3DDDI_CREATEPIXELSHADER                         pfnCreatePixelShader;                     */
        DeletePixelShader,                      /*PFND3DDDI_DELETEPIXELSHADER                         pfnDeletePixelShader;                     */
        CreateDecodeDevice,                     /*PFND3DDDI_CREATEDECODEDEVICE                        pfnCreateDecodeDevice;                    */
        DestroyDecodeDevice,                    /*PFND3DDDI_DESTROYDECODEDEVICE                       pfnDestroyDecodeDevice;                   */
        SetDecodeRenderTarget,                  /*PFND3DDDI_SETDECODERENDERTARGET                     pfnSetDecodeRenderTarget;                 */
        DecodeBeginFrame,                       /*PFND3DDDI_DECODEBEGINFRAME                          pfnDecodeBeginFrame;                      */
        DecodeEndFrame,                         /*PFND3DDDI_DECODEENDFRAME                            pfnDecodeEndFrame;                        */
        DecodeExecute,                          /*PFND3DDDI_DECODEEXECUTE                             pfnDecodeExecute;                         */
        DecodeExtensionExecuter,                /*PFND3DDDI_DECODEEXTENSIONEXECUTE                    pfnDecodeExtensionExecute;                */
        CreateVideoProcessDevice,               /*PFND3DDDI_CREATEVIDEOPROCESSDEVICE                  pfnCreateVideoProcessDevice;              */
        DestroyVideoProcessDevice,              /*PFND3DDDI_DESTROYVIDEOPROCESSDEVICE                 pfnDestroyVideoProcessDevice;             */
        VideoProcessBeginFrame,                 /*PFND3DDDI_VIDEOPROCESSBEGINFRAME                    pfnVideoProcessBeginFrame;                */
        VideoProcessEndFrame,                   /*PFND3DDDI_VIDEOPROCESSENDFRAME                      pfnVideoProcessEndFrame;                  */
        SetVideoProcessRenderTarget,            /*PFND3DDDI_SETVIDEOPROCESSRENDERTARGET               pfnSetVideoProcessRenderTarget;           */
        VideoProcessBlit,                       /*PFND3DDDI_VIDEOPROCESSBLT                           pfnVideoProcessBlt;                       */
        CreateExtensionDevice,                  /*PFND3DDDI_CREATEEXTENSIONDEVICE                     pfnCreateExtensionDevice;                 */
        DestroyExtensionDevice,                 /*PFND3DDDI_DESTROYEXTENSIONDEVICE                    pfnDestroyExtensionDevice;                */
        ExtensionExecute,                       /*PFND3DDDI_EXTENSIONEXECUTE                          pfnExtensionExecute;                      */
        CreateOverlay,                          /*PFND3DDDI_CREATEOVERLAY                             pfnCreateOverlay;                         */
        UpdateOverlay,                          /*PFND3DDDI_UPDATEOVERLAY                             pfnUpdateOverlay;                         */
        FlipOverlay,                            /*PFND3DDDI_FLIPOVERLAY                               pfnFlipOverlay;                           */
        GetOverlayColorControls,                /*PFND3DDDI_GETOVERLAYCOLORCONTROLS                   pfnGetOverlayColorControls;               */
        SetOverlayColorControls,                /*PFND3DDDI_SETOVERLAYCOLORCONTROLS                   pfnSetOverlayColorControls;               */
        DestroyOverlay,                         /*PFND3DDDI_DESTROYOVERLAY                            pfnDestroyOverlay;                        */
        DestroyDevice,                          /*PFND3DDDI_DESTROYDEVICE                             pfnDestroyDevice;                         */
        QueryResourceResidency,                 /*PFND3DDDI_QUERYRESOURCERESIDENCY                    pfnQueryResourceResidency;                */
        OpenResource,                           /*PFND3DDDI_OPENRESOURCE                              pfnOpenResource;                          */
        GetCaptureAllocationHandle,             /*PFND3DDDI_GETCAPTUREALLOCATIONHANDLE                pfnGetCaptureAllocationHandle;            */
        CaptureToSystem,                        /*PFND3DDDI_CAPTURETOSYSMEM                           pfnCaptureToSysMem;                       */
        LockAsync,                              /*PFND3DDDI_LOCKASYNC                                 pfnLockAsync;                             */
        UnlockAsync,                            /*PFND3DDDI_UNLOCKASYNC                               pfnUnlockAsync;                           */
        Rename,                                 /*PFND3DDDI_RENAME                                    pfnRename;                                */
        DXVAHD_CreateVideoProcessor,            /*PFND3DDDI_DXVAHD_CREATEVIDEOPROCESSOR               pfnCreateVideoProcessor;                  */
        DXVAHD_SetVideoProcessorBlitState,      /*PFND3DDDI_DXVAHD_SETVIDEOPROCESSBLTSTATE            pfnSetVideoProcessBltState;               */
        DXVAHD_GetVideoProcessorBlitState,      /*PFND3DDDI_DXVAHD_GETVIDEOPROCESSBLTSTATEPRIVATE     pfnGetVideoProcessBltStatePrivate;        */
        DXVAHD_SetVideoProcessorStreamState,    /*PFND3DDDI_DXVAHD_SETVIDEOPROCESSSTREAMSTATE         pfnSetVideoProcessStreamState;            */
        DXVAHD_GetVideoProcessorStreamState,    /*PFND3DDDI_DXVAHD_GETVIDEOPROCESSSTREAMSTATEPRIVATE  pfnGetVideoProcessStreamStatePrivate;     */
        DXVAHD_VideoProcessBlitHD,              /*PFND3DDDI_DXVAHD_VIDEOPROCESSBLTHD                  pfnVideoProcessBltHD;                     */
        DXVAHD_DestroyVideoProcessor,           /*PFND3DDDI_DXVAHD_DESTROYVIDEOPROCESSOR              pfnDestroyVideoProcessor;                 */
        CreateAuthenticatedChannel,             /*PFND3DDDI_CREATEAUTHENTICATEDCHANNEL                pfnCreateAuthenticatedChannel;            */
        AuthenticatedChannelKeyExchange,        /*PFND3DDDI_AUTHENTICATEDCHANNELKEYEXCHANGE           pfnAuthenticatedChannelKeyExchange;       */
        QueryAuthenticatedChannel,              /*PFND3DDDI_QUERYAUTHENTICATEDCHANNEL                 pfnQueryAuthenticatedChannel;             */
        ConfigureAuthenticatedChannel,          /*PFND3DDDI_CONFIGUREAUTHENICATEDCHANNEL              pfnConfigureAuthenticatedChannel;         */
        DestroyAuthenticatedChannel,            /*PFND3DDDI_DESTROYAUTHENTICATEDCHANNEL               pfnDestroyAuthenticatedChannel;           */
        CreateCrytoSession,                     /*PFND3DDDI_CREATECRYPTOSESSION                       pfnCreateCryptoSession;                   */
        CrytoSessionKeyExchange,                /*PFND3DDDI_CRYPTOSESSIONKEYEXCHANGE                  pfnCryptoSessionKeyExchange;              */
        DestroyCryptoSession,                   /*PFND3DDDI_DESTROYCRYPTOSESSION                      pfnDestroyCryptoSession;                  */
        EncryptionBlit,                         /*PFND3DDDI_ENCRYPTIONBLT                             pfnEncryptionBlt;                         */
        GetPitch,                               /*PFND3DDDI_GETPITCH                                  pfnGetPitch;                              */
        StartSessionKeyReresh,                  /*PFND3DDDI_STARTSESSIONKEYREFRESH                    pfnStartSessionKeyRefresh;                */
        FinishSessionKeyRefresh,                /*PFND3DDDI_FINISHSESSIONKEYREFRESH                   pfnFinishSessionKeyRefresh;               */
        GetEncryptionBlitKey,                   /*PFND3DDDI_GETENCRYPTIONBLTKEY                       pfnGetEncryptionBltKey;                   */
        DecryptionBlit,                         /*PFND3DDDI_DECRYPTIONBLT                             pfnDecryptionBlt;                         */
        ResolveSharedResource,                  /*PFND3DDDI_RESOLVESHAREDRESOURCE                     pfnResolveSharedResource;                 */
        VolumeBlit1,                            /*PFND3DDDI_VOLBLT1                                   pfnVolBlt1;                               */
        BufferBlit1,                            /*PFND3DDDI_BUFBLT1                                   pfnBufBlt1;                               */
        TextureBlit1,                           /*PFND3DDDI_TEXBLT1                                   pfnTexBlt1;                               */
        Discard,                                /*PFND3DDDI_DISCARD                                   pfnDiscard;                               */
        OfferResources,                         /*PFND3DDDI_OFFERRESOURCES                            pfnOfferResources;                        */
        ReclaimResources,                       /*PFND3DDDI_RECLAIMRESOURCES                          pfnReclaimResources;                      */
        CheckDirectFlipSupport,                 /*PFND3DDDI_CHECKDIRECTFLIPSUPPORT                    pfnCheckDirectFlipSupport;                */
        CreateResource2,                        /*PFND3DDDI_CREATERESOURCE2                           pfnCreateResource2;                       */
        CheckMultiplaneOverlaySupport,          /*PFND3DDDI_CHECKMULTIPLANEOVERLAYSUPPORT             pfnCheckMultiPlaneOverlaySupport;         */
        PresentMultiplaneOverlay,               /*PFND3DDDI_PRESENTMULTIPLANEOVERLAY                  pfnPresentMultiPlaneOverlay;              */
        nullptr,                                /*                                                    pfnReserved1;                             */
        Flush1,                                 /*PFND3DDDI_FLUSH1                                    pfnFlush1;                                */
        CheckCounterInfo,                       /*PFND3DDDI_CHECKCOUNTERINFO                          pfnCheckCounterInfo;                      */
        CheckCounter,                           /*PFND3DDDI_CHECKCOUNTER                              pfnCheckCounter;                          */
        UpdateSubresourceUP,                    /*PFND3DDDI_UPDATESUBRESOURCEUP                       pfnUpdateSubresourceUP;                   */
        Present1,                               /*PFND3DDDI_PRESENT1                                  pfnPresent1;                              */
        CheckPresentDurationSupport,            /*PFND3DDDI_CHECKPRESENTDURATIONSUPPORT               pfnCheckPresentDurationSupport;           */
        SetMarker,                              /*PFND3DDDI_SETMARKER                                 pfnSetMarker;                             */
        SetMarkerMode,                          /*PFND3DDDI_SETMARKERMODE                             pfnSetMarkerMode;                         */
        /* Opt out of having the DX9 runtime manage residency by leaving TrimResidencySet null, the translation layer does this internally      */
        nullptr,                                /*PFND3DDDI_TRIMRESIDENCYSET                          pfnTrimResidencySet;                      */
        AcquireResource,                        /*PFND3DDDI_SYNCTOKEN                                 pfnAcquireResource                        */
        ReleaseResource,                        /*PFND3DDDI_SYNCTOKEN                                 pfnReleaseResource                        */
    };
};

```

`include/9on12DataLogger.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#pragma once

namespace D3D9on12
{
    class ShaderDataLogger
    {
    public:
        ShaderDataLogger() : m_WorstCaseShader(1, 0) {}

        void AddShaderData(D3D10_SB_TOKENIZED_PROGRAM_TYPE shaderType, UINT numInstructions, UINT numExtraInstructions)
        {
            float extraInstructionOverhead = (float)numExtraInstructions / (float)numInstructions;
            float worstShaderOverhead = (float)m_WorstCaseShader.m_numExtraInstructions / (float)m_WorstCaseShader.m_numInstructions;
            if (extraInstructionOverhead > worstShaderOverhead)
            {
                m_WorstCaseShader = ShaderInfo(numInstructions, numExtraInstructions );
            }

            m_shaderData[shaderType].m_totalInstructions += numInstructions;
            m_shaderData[shaderType].m_totalExtraInstructions += numExtraInstructions;
            m_shaderData[shaderType].m_totalShaders++;
        }

    private:
        class ShaderInfo
        {
        public:
            ShaderInfo() : m_numInstructions(0), m_numExtraInstructions(0) {}
            ShaderInfo(UINT numInstructions, UINT numExtraInstructions) : m_numInstructions(numInstructions), m_numExtraInstructions(numExtraInstructions) {}

            UINT m_numInstructions;
            UINT m_numExtraInstructions;
        };

        struct AccumulatedShaderData
        {
            AccumulatedShaderData() { memset(this, 0, sizeof(*this)); }

            UINT64 m_totalInstructions;
            UINT64 m_totalExtraInstructions;
            UINT64 m_totalShaders;
        };

        AccumulatedShaderData m_shaderData[2];
        ShaderInfo m_WorstCaseShader;
    };

    struct DataLogger
    {

        void AddShaderData(D3D10_SB_TOKENIZED_PROGRAM_TYPE shaderType, UINT numInstructions, UINT numExtraInstructions)
        {
            m_shaderDataLogger.AddShaderData(shaderType, numInstructions, numExtraInstructions);
        }

        ShaderDataLogger m_shaderDataLogger;
    };
};
```

`include/9on12DecodeDevice.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#pragma once

namespace D3D9on12
{
    class Device; // Forward declaration

    class DecodeDevice
    {
    public:
        DecodeDevice(HANDLE runtimeHandle, _In_ Device *pParent, _In_ const D3DDDIARG_CREATEDECODEDEVICE *pCreateDecodeDevice);
        ~DecodeDevice();

        HANDLE GetRuntimeHandle() { return m_runtimeHandle; }
        Device* GetParent() { return m_pParentDevice; }

        static FORCEINLINE HANDLE GetHandleFromDecodeDevice(DecodeDevice* pDecodeDevice) { return (pDecodeDevice) ? static_cast<HANDLE>(pDecodeDevice) : NULL_HANDLE; }
        static FORCEINLINE DecodeDevice* GetDecodeDeviceFromHandle(HANDLE hDecodeDevice) { return (hDecodeDevice != NULL_HANDLE) ? static_cast<DecodeDevice*>(hDecodeDevice) : nullptr; }
        static void GetCaps(_Inout_ CONST D3DDDIARG_GETCAPS* pGetCaps);

        void BeginFrame(_In_ D3DDDIARG_DECODEBEGINFRAME *pBeginFrame);
        void EndFrame(_Inout_ D3DDDIARG_DECODEENDFRAME *pEndFrame);
        void Execute(_In_ CONST D3DDDIARG_DECODEEXECUTE *pExecute);
        void SetDecodeRenderTarget(_In_ CONST D3DDDIARG_SETDECODERENDERTARGET *pRenderTarget);
        HRESULT ExecuteExtension(_In_ CONST D3DDDIARG_DECODEEXTENSIONEXECUTE* pExtensionExecute);

    protected:
        D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE GetInterlaceType(DXVADDI_SAMPLEFORMAT format);

        BYTE m_pUnderlyingSpace[sizeof(D3D12TranslationLayer::VideoDecode)];
        Device *m_pParentDevice = nullptr;
        HANDLE m_runtimeHandle = NULL_HANDLE;
        D3D12TranslationLayer::VideoDecode *m_pUnderlyingVideoDecode = nullptr;
        GUID m_decodeProfile = GUID_NULL;
        D3D12TranslationLayer::VIDEO_DECODE_INPUT_STREAM_ARGUMENTS m_inputArguments = {};
        D3D12TranslationLayer::VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS m_outputArguments = {};
        UINT m_frameNestCount = 0;
        struct {
            unique_comptr<D3D12TranslationLayer::Resource> frameArguments[D3D12_VIDEO_DECODE_MAX_ARGUMENTS];
            unique_comptr<D3D12TranslationLayer::Resource> compressedBitstream;
            unique_comptr<D3D12TranslationLayer::Resource> output;
        } m_inUseResources;
    };
};

```

`include/9on12Device.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#pragma once
#include "SharedResourceHelpers.hpp"

namespace D3D9on12
{
    struct Context
    {
        HANDLE m_runtimeHandle;
    };

    class VideoDevice;

    class Device
    {
    public:
        Device( Adapter& Adapter, _Inout_ D3DDDIARG_CREATEDEVICE& CreateDeviceArgs );
        ~Device();

        static void ReportError(HRESULT /*hr*/) {};

        HRESULT Init(ID3D12Device *pDevice, ID3D12CommandQueue *pCommandQueue);

        HRESULT Destroy();
        HRESULT FlushWork(bool WaitOnCompletion, UINT FlushFlags = 0);
        HRESULT Present(CONST D3DDDIARG_PRESENT1& PresentArgs, D3DKMT_PRESENT *pKMTArgs);
        HRESULT CloseAndSubmitGraphicsCommandListForPresent(BOOL commandsAdded, _In_reads_(numSrcSurfaces) const D3DDDIARG_PRESENTSURFACE* pSrcSurfaces, UINT numSrcSurfaces, _In_opt_ HANDLE hDestResource, _In_ D3DKMT_PRESENT* pKMTPresent);

        void MarkStateAsDirty();

        static FORCEINLINE HANDLE GetHandleFromDevice(Device* pDevice){ return static_cast<HANDLE>(pDevice); }
        static FORCEINLINE Device* GetDeviceFromHandle(HANDLE hDevice){ return static_cast<Device*>(hDevice); }
        std::shared_ptr<D3D12TranslationLayer::SwapChainManager> GetSwapChainManager();

        ConstantsManager &GetConstantsManager() { return m_constantsManager; }

        UINT32 GetNodeMask() { return m_NodeMask; }

        Adapter& GetAdapter() { return m_Adapter; }
        HANDLE GetRuntimeHandle() { return m_runtimeHandle; }
        Context& GetRuntimeContext() { return m_runtimeContext; }


        PipelineState& GetPipelineState() { return m_pipelineState; }
        PipelineStateCache& GetPipelineStateCache() { return m_pipelineStateCache; }

        UINT GetD3D9ApiVersion() { return m_d3d9APIVersion; }

        void SetStreamFrequency(_In_range_(0, MAX_VERTEX_STREAMS - 1 ) UINT streamIndex, UINT divider)
        {
            Check9on12(streamIndex < MAX_VERTEX_STREAMS);
            if (m_streamFrequency[streamIndex] != divider){ m_pipelineState.MarkInputLayoutAsDirty(); }
            m_streamFrequency[streamIndex] = divider;
        }

        UINT GetStreamFrequency(_In_range_(0, MAX_VERTEX_STREAMS - 1) UINT streamIndex)
        {
            Check9on12(streamIndex < MAX_VERTEX_STREAMS);
            return m_streamFrequency[streamIndex];
        }

        UINT* GetPointerToStreamFrequencies() { return m_streamFrequency; }

        WeakHash HashStreamFrequencyData(WeakHash inputHash);

        HRESULT ResolveDeferredState(OffsetArg BaseVertexStart, OffsetArg BaseIndexStart);

        D3DDDI_DEVICECALLBACKS& GetRuntimeCallbacks() { return m_Callbacks; }

        ID3D12CommandQueue& GetCommandQueue(){ return *m_pCommandQueue; }
        ID3D12Device &GetDevice() { return *m_pDevice; }
        D3D_FEATURE_LEVEL GetFeatureLevel() { return GetContext().FeatureLevel();}
        
        CComPtr<ID3D12Device> m_pDevice;
        CComPtr<ID3D12CommandQueue> m_pCommandQueue;

        D3D12TranslationLayer::ImmediateContext& GetContext() { return *m_pImmediateContext; }
        
        D3D12TranslationLayer::SharedResourceHelpers& GetSharedResourceHelper() { return *m_pSharedResourceHelpers; }
        D3D12TranslationLayer::BlitHelper& GetBlitHelper() { return GetContext().m_BlitHelper; }

        HRESULT DrawTriangleFan(_In_ OffsetArg baseVertex, _In_ UINT primitiveCount);
        HRESULT DrawWireframeTriangleFanWithEdgeFlags(_In_ OffsetArg baseVertex, _In_ UINT primitiveCount, _In_ UINT edgeFlags);
        HRESULT DrawTriangleFanIndexed(_In_ OffsetArg baseVertex, _In_ UINT vertexCount, _In_ OffsetArg baseIndex, _In_ UINT primitiveCount);

        FastUploadAllocator& GetSystemMemoryAllocator() { return m_systemMemoryAllocator; }
        DataLogger &GetDataLogger() { return m_dataLogger; }
        template<D3D12TranslationLayer::EShaderStage ShaderStage>
        void SetConstantBuffer(UINT shaderRegister, D3D12TranslationLayer::Resource *pResource, UINT offsetInBytes)
        {
            const UINT CONSTANT_BUFFER_ELEMENT_SIZE = sizeof(FLOAT) * 4;
            UINT firstConstant = offsetInBytes / CONSTANT_BUFFER_ELEMENT_SIZE;
            UINT maxConstantBufferElements = ConstantsManager::g_cMaxConstantBufferSize / CONSTANT_BUFFER_ELEMENT_SIZE;
            GetContext().SetConstantBuffers<ShaderStage>(shaderRegister, 1, &pResource, &firstConstant, &maxConstantBufferElements);
        }

        void EnsureVideoDevice();
        VideoDevice *GetVideoDevice();
        HRESULT DoBlit(_In_ CONST D3DDDIARG_BLT* pBltArgs, BOOL EnableAlpha);

        D3DDDIARG_PRESENT1* m_pUMDPresentArgs;

        std::mutex m_WrappingResourceSetLock;
        std::set<IUnknown*> m_WrappingResourceSet;

        ShaderConv::ShaderConverterAPI m_ShaderConvAPI;

        ShaderDedupe<VertexShader> m_VSDedupe;
        ShaderDedupe<PixelShader> m_PSDedupe;

        D3D12_FEATURE_DATA_D3D12_OPTIONS19 m_Options19;

        D3D12TranslationLayer::COptLockedContainer<std::unordered_map<Resource*, std::vector<LockRange>>> m_lockedResourceRanges;
        void SetDrawingPreTransformedVerts(bool preTransformedVerts);

    protected:
        virtual void LogCreateVideoDevice( HRESULT hr );

    private:

        struct  TriangleFanIndexBufferCache
        {
            
            InputBuffer highestPCIndexBufferTriFan;
            UINT highestPrimitiveCountTriFan;
            bool isTriFanCacheInitialized;

            TriangleFanIndexBufferCache() : highestPrimitiveCountTriFan(0), isTriFanCacheInitialized(false)
            {}
        } ;

        // Make sure this is the last thing that gets called by the destructor
        std::optional<D3D12TranslationLayer::ImmediateContext> m_pImmediateContext;
        std::optional<D3D12TranslationLayer::SharedResourceHelpers> m_pSharedResourceHelpers;

        std::mutex m_SwapChainManagerMutex;
        std::shared_ptr<D3D12TranslationLayer::SwapChainManager> m_SwapChainManager;

        CComPtr<ID3DBlob> m_pSerializedLayout;
    
        Adapter& m_Adapter;
        HANDLE m_runtimeHandle;

        Context m_runtimeContext;

        D3DDDI_DEVICECALLBACKS m_Callbacks;

        ConstantsManager m_constantsManager;

        PipelineStateCache m_pipelineStateCache;
        PipelineState m_pipelineState;

        UINT32 m_NodeMask;

        UINT m_streamFrequency[MAX_VERTEX_STREAMS];

        UINT m_d3d9APIVersion;

        FastUploadAllocator m_systemMemoryAllocator;

        TriangleFanIndexBufferCache m_triangleFanIndexBufferCache;
        DataLogger m_dataLogger;

        BYTE m_pVideoDeviceSpace[sizeof(VideoDevice)];
        VideoDevice *m_pVideoDevice;

        //This should be cleared before each use. we're just saving the allocation
        std::vector<D3D12TranslationLayer::PresentSurface> m_d3d12tlPresentSurfaces;
        //This should be cleared before each use. we're just saving the allocation
        std::vector<D3DDDIARG_PRESENTSURFACE> m_d3d9PresentSurfaces;
    };
};

```

`include/9on12FastUploadAllocator.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#pragma once

namespace D3D9on12
{
    class Device;

    class FastUploadAllocator
    {
    public:
        struct SubBuffer
        {
            SubBuffer() :
                m_pResource(0),
                m_pMappedAddress(nullptr),
                m_offsetFromBase(0){};

            SubBuffer(D3D12TranslationLayer::Resource *pResource, void* mapped, UINT offset) :
                m_pResource(pResource), m_pMappedAddress(mapped), m_offsetFromBase(offset){};

            D3D12TranslationLayer::Resource *m_pResource;
            void* m_pMappedAddress;
            UINT m_offsetFromBase;
        };

        FastUploadAllocator(Device& device, UINT size, UINT alignment, bool bDeferDestroyDuringRealloc = false);
        ~FastUploadAllocator() = default;

        SubBuffer Allocate(UINT size);
        void Destroy();
        void ClearDeferredDestroyedResource();

    private:
        void Realloc();

        Device& m_parentDevice;
        const bool m_bDeferDestroyDuringRealloc;
        UINT m_size;
        const UINT m_alignmentRequired;
        UINT m_spaceUsed;

        unique_unbind_resourceptr m_pResource;
        void* m_pMappedAddress;

        unique_unbind_resourceptr m_pDeferredDestroyedResource;
    };
};
```

`include/9on12Fence.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#pragma once

namespace D3D9on12
{
    class Fence
    {
    public:
        Fence(Device* pDevice, UINT64 InitialValue, UINT Flags);
        Fence(Device* pDevice, HANDLE hSharedHandle);
        void Signal(UINT64 Value);
        void Wait(UINT64 Value);
        
        UINT64 GetFenceValue();

        HANDLE Share(_In_opt_ SECURITY_DESCRIPTOR* pSD);

        static FORCEINLINE HANDLE GetHandleFromFence(Fence* pFence){ return static_cast<HANDLE>(pFence); }
        static FORCEINLINE Fence* GetFenceFromHandle(HANDLE hFence){ return static_cast<Fence*>(hFence); }

        bool IsMonitored() const;

    private:
        Device* const m_pDevice;
        std::shared_ptr<D3D12TranslationLayer::Fence> m_spUnderlyingFence;
    };
}
```

`include/9on12InputAssembly.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#pragma once

namespace D3D9on12
{
    class Device;

    struct InputBuffer
    {
        void InitWithUploadData(Device& device, UINT strideInBytes, CONST VOID* pDataToUpload = nullptr);
        void InitWithResource(Device& device, Resource* pAppResource, UINT64 bufferSize, UINT64 offset, UINT strideInBytes);
        void InitAsPersistentTriangleFan(Device & device, UINT64 bufferSize, UINT strideInBytes);

        UINT GetOffsetInBytesAPI() { return m_bufferOffset; }
        UINT GetOffsetInBytesD3D12();
        UINT GetStrideInBytes() { return m_bufferStride; }

        VOID* GetSystemMemoryBase() { return (byte*)m_pDeferredSystemMemoryData + m_bufferOffset; }
        VOID* GetTriangleFanMemory() { Check9on12(m_isTriangleFanIndexBuffer); return m_tempGPUBuffer.m_pMappedAddress; }

        HRESULT Upload(Device& device, OffsetArg baseVertexIndex, UINT vertexCount);
        void ResetUploadedData();

        bool IsSystemMemory() { return m_isSystemMemory; }
        bool IsTriangleFan() { return m_isTriangleFanIndexBuffer; }

        Resource* GetAppResource() { return m_pAppProvidedResource; }
        D3D12TranslationLayer::Resource * GetUnderlyingResource();

    private:
        Resource* m_pAppProvidedResource = nullptr;
        std::shared_ptr<D3D12TranslationLayer::Resource> m_pInternallyProvidedResource;

        const void* m_pDeferredSystemMemoryData = nullptr;
        bool m_isSystemMemory = false;
        bool m_isTriangleFanIndexBuffer = false;

        FastUploadAllocator::SubBuffer m_tempGPUBuffer = {};

        UINT m_bufferStride = 0;
        UINT m_bufferOffset = 0;
        // Only used for bounds checking in Upload() when possible. This default may not make sense if that changes.
        // Primarily a risk due to InputAssembly::Set*BufferUM not knowing buffer size.
        UINT m_sizeInBytes = UINT32_MAX;
    };

    class InputAssembly
    {
    public:
        InputAssembly(PipelineStateDirtyFlags& pipelineStateDirtyFlags, RasterStatesWrapper& rasterStates);

        InputLayout &GetInputLayout() { return *m_pInputLayout; }

        void SetVertexDeclaration(InputLayout *pInputLayout);

        UINT GetStream0Stride() { return m_inputStreams[0].GetStrideInBytes(); }

        HRESULT SetVertexBuffer(Device &device, Resource *pVertexBuffer, UINT vbSlot, UINT offset, UINT stride);
        void SetVertexBufferUM(Device& device, UINT vbSlot, UINT stride, _In_ CONST VOID* pData);
        HRESULT SetIndexBuffer(Device &device, Resource *pResource, UINT stride);
        HRESULT SetIndexBufferUM(Device &device, UINT indexBufferStride, _In_ const void *pIndices);

        HRESULT UploadDeferredInputBufferData(Device& device, OffsetArg baseVertexIndex, UINT vertexCount, OffsetArg baseIndexLocation, UINT indexCount);
        void ResetUploadBufferData();

        void SetPrimitiveTopology(Device &device, D3DPRIMITIVETYPE primitiveType);

        HRESULT ResolveDeferredState(Device &device, const D3D12_GRAPHICS_PIPELINE_STATE_DESC& psoDesc, OffsetArg BaseVertexStart, OffsetArg BaseIndexStart);

        void RestorePreviousIB(Device &device);

        InputBuffer& CurrentIndexBuffer() { return m_IndexBufferStack.top(); }
        
        static void CreateTriangleFanIndexBuffer(_In_ Device &device, _Out_ InputBuffer& targetBuffer, _In_ UINT& indexCount);
        static void CreateTriangleListIBFromTriangleFanIB(_In_ Device &device, 
            _In_ CONST void * pIndexBuffer, 
            _In_ UINT indexBufferStride, _In_ UINT baseIndexLocation, _In_ UINT indexCount, _Out_ InputBuffer & convertedBuffer);
        void PushNewIndexBuffer(_In_ InputBuffer & targetBuffer);

        void MarkIndexBufferDirty() { m_dirtyFlags.IndexBuffer = true; }
        void MarkVertexBufferDirty() { m_dirtyFlags.VertexBuffers = true; }
        UINT GetNumBoundStreams() { return m_numBoundVBs; }

    private:
        bool InputBufferNeedsUpload(UINT streamIndex);
        void ResolveVertexBuffers(Device& device, OffsetArg BaseVertexStart);

        InputBuffer m_inputStreams[MAX_VERTEX_STREAMS];
        UINT m_numBoundVBs;


        std::stack<InputBuffer> m_IndexBufferStack;
        D3D12_PRIMITIVE_TOPOLOGY m_topology;
        InputLayout *m_pInputLayout;

        PipelineStateDirtyFlags& m_dirtyFlags;
        RasterStatesWrapper& m_rasterStates;

        bool m_hasTLVertices;
    };

};
```

`include/9on12InputLayout.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#pragma once

namespace D3D9on12
{
    class InputLayout
    {
    public:
        InputLayout(Device &device);
        ~InputLayout();

        static FORCEINLINE HANDLE GetHandleFromInputLayout(InputLayout* pInputLayout){ return static_cast<HANDLE>(pInputLayout); }
        static FORCEINLINE InputLayout* GetInputLayoutFromHandle(HANDLE hInputLayout){ return static_cast<InputLayout*>(hInputLayout); }

        HRESULT Init(_In_ CONST D3DDDIVERTEXELEMENT* pVertexElements, UINT numElements);

        UINT GetVertexElementCount() { return m_numVertexElements; }
        D3DDDIVERTEXELEMENT &GetVertexElement(UINT elementIndex) 
        { 
            Check9on12(elementIndex < m_numVertexElements); 
            return m_pVertexElements[elementIndex]; 
        }

        bool VerticesArePreTransformed(){ return m_hasPreTransformedVertices; }
        bool HasPointSizePerVertex(){ return m_hasPerVertexPointSize; }
        ShaderConv::VSInputDecls& GetVSInputDecls() { return m_vsInputDecls; }

        WeakHash GetHash();
        UINT GetStreamMask() { return m_streamMask; }

    private:
        D3DDDIVERTEXELEMENT m_pVertexElements[MAX_INPUT_ELEMENTS];
        UINT m_numVertexElements;
        UINT m_streamMask;

        bool m_hasPreTransformedVertices;

        //If the vertex has a point size, we must use that over the 
        //size set by raster states. Also hints that we need a GS.
        bool m_hasPerVertexPointSize;
        ShaderConv::VSInputDecls m_vsInputDecls;
        Device &m_device;

        WeakHash m_hash;
    };
}
```

`include/9on12PipelineState.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#pragma once

namespace D3D9on12
{
    class Device; // Forward declaration
    class ShaderCache;

    class PipelineState
    {
    public:
        PipelineState(Device& device);

        HRESULT Init(Device& device);

        HRESULT ResolveDeferredState(Device &device, OffsetArg BaseVertexStart, OffsetArg BaseIndexStart);

        void SetRenderState(Device& device, DWORD dwState, DWORD dwValue);
        void SetTextureStageState(DWORD dwStage, DWORD dwState, DWORD dwValue);

        InputAssembly& GetInputAssembly() { return m_inputAssembly; }
        VertexStage& GetVertexStage() { return m_vertexStage; }
        PixelStage& GetPixelStage() { return m_pixelStage; }

        void MarkPipelineStateNeeded() { m_bNeedsPipelineState = true; }
        void MarkInputLayoutAsDirty() { m_dirtyFlags.InputLayout = true; }

        D3D12_GRAPHICS_PIPELINE_STATE_DESC& CurrentPSODesc() { return m_PSODesc; }

        void SetIntzRestoreZWrite(BOOL value) { m_intzRestoreZWrite = value; }
        BOOL GetIntzRestoreZWrite() { return m_intzRestoreZWrite; }

    private:
        PipelineStateDirtyFlags     m_dirtyFlags;

        InputAssembly m_inputAssembly;
        VertexStage m_vertexStage;
        PixelStage m_pixelStage;

        // This is used to avoid creating a PSO before we have enough state
        // (this can happen when ResolveDeferredState is called due to a Map()
        // before some important SetRenderState is called). This is somewhat hacky
        // and we should likely build on this to have more complex checks that 
        // don't set/create the PSO unless we know we absolutely need it
        BOOL m_bNeedsPipelineState;

        RasterStatesWrapper m_rasterStates;

        union
        {
            DWORD m_dwTextureStageStates[MAX_SAMPLERS_STAGES][MAX_D3DTSS];
            FLOAT m_fTextureStageStates[MAX_SAMPLERS_STAGES][MAX_D3DTSS];
        };

        union
        {
            DWORD m_dwRenderStates[D3DHAL_MAX_RSTATES];
            FLOAT m_fRenderStates[D3DHAL_MAX_RSTATES];
        };

        D3D12_GRAPHICS_PIPELINE_STATE_DESC m_PSODesc;
        
        BOOL m_intzRestoreZWrite;
    };
};

```

`include/9on12PipelineStateCache.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#pragma once

namespace D3D9on12
{
    class Device; // Forward declaration
    struct D3D12VertexShader;
    struct D3D12PixelShader;
    struct D3D12GeometryShader;
    class Shader;

#pragma pack(push, 1)
    struct PipelineStateKey
    {
        // Hash in the constructor so that his key can be used several times efficiently
        PipelineStateKey(D3D12_GRAPHICS_PIPELINE_STATE_DESC& desc, D3D12VertexShader* pVS, D3D12PixelShader* pPS, D3D12GeometryShader* pGS) :
            m_desc(desc, pVS, pPS, pGS)
        {
        };

        bool operator==(const PipelineStateKey &key) const
        {
            return memcmp(&m_desc, &key.m_desc, sizeof(key.m_desc)) == 0;
        }

        // Hashing and comparison of PSO descriptors is slow and expensive. Optimize by bitpacking only the values that we care about
        // for D3D9 this way we can hash and compare 64 bytes vs 572
        struct D3D9on12PipelineStateDesc
        {
            D3D9on12PipelineStateDesc(D3D12_GRAPHICS_PIPELINE_STATE_DESC& desc, D3D12VertexShader* pVS, D3D12PixelShader* pPS, D3D12GeometryShader* pGS) :
                m_pVS(pVS), m_pPS(pPS), m_pGS(pGS), m_compressedData(desc)
            {
                //Values which can be compressed further
                SampleMask = desc.SampleMask;
                DepthBias = desc.RasterizerState.DepthBias;
                DepthBiasClamp = desc.RasterizerState.DepthBiasClamp;
                SlopeScaledDepthBias = desc.RasterizerState.SlopeScaledDepthBias;
                StencilReadMask = desc.DepthStencilState.StencilReadMask;
                StencilWriteMask = desc.DepthStencilState.StencilWriteMask;
            }

            D3D12VertexShader* m_pVS;// Vertex Shaders and Input layouts are tied together so only need the VS
            D3D12PixelShader* m_pPS;
            D3D12GeometryShader* m_pGS;
            UINT SampleMask;
            INT DepthBias;
            FLOAT DepthBiasClamp;
            FLOAT SlopeScaledDepthBias;
            UINT8 StencilReadMask;
            UINT8 StencilWriteMask;

#define BitPackedBlendDesc(number) \
                UINT BlendDescBlendEnable##number            : 1; \
                UINT BlendDescLogicOpEnable##number          : 1; \
                UINT BlendDescSrcBlend##number               : 5; \
                UINT BlendDescDestBlend##number              : 5; \
                UINT BlendDescBlendOp##number                : 3; \
                UINT BlendDescSrcBlendAlpha##number          : 5; \
                UINT BlendDescDestBlendAlpha##number         : 5; \
                UINT BlendDescBlendOpAlpha##number           : 3; \
                UINT BlendDescLogicOp##number                : 4; \
                UINT BlendDescRenderTargetWriteMask##number  : 8; 

            struct CompressedData
            {
                static const UINT m_RemderTargetFormatBits = 5;
                static const UINT m_SampleCountBits = 4;

                CompressedData(D3D12_GRAPHICS_PIPELINE_STATE_DESC& desc);
                FORCEINLINE UINT8 CompressDepthFormat(DXGI_FORMAT);
                FORCEINLINE UINT8 CompressRenderTargetFormat(DXGI_FORMAT);

                UINT PrimitiveTopologyType      : 3;
                // Render Targets
                UINT NumRenderTargets           : 2;
                UINT RenderTargetFormat0        : m_RemderTargetFormatBits;//We expose < 32 RT formats so 5 bits will do, if caps change so might this!
                UINT RenderTargetFormat1        : m_RemderTargetFormatBits;
                UINT RenderTargetFormat2        : m_RemderTargetFormatBits;
                UINT RenderTargetFormat3        : m_RemderTargetFormatBits;
                UINT DepthStencilFormat         : 3;
                // Sample Desc
                UINT SampleCount                : m_SampleCountBits;
                UINT SampleQuality              : m_SampleCountBits;
                // RasterState
                UINT FillMode                   : 1;
                UINT CullMode                   : 2;
                UINT FrontCounterClockwise      : 1;
                UINT DepthClipEnable            : 1;
                UINT MultisampleEnable          : 1;
                UINT AntialiasedLineEnable      : 1;
                UINT ForcedSampleCount          : m_SampleCountBits;
                // Depth Desc
                UINT DepthEnable                : 1;
                UINT DepthWriteMask             : 1;
                UINT DepthFunc                  : 3;
                UINT StencilEnable              : 1;
                UINT FrontStencilFailOp         : 3;
                UINT FrontStencilDepthFailOp    : 3;
                UINT FrontStencilPassOp         : 3;
                UINT FrontStencilFunc           : 3;
                UINT BackStencilFailOp          : 3; 
                UINT BackStencilDepthFailOp     : 3;
                UINT BackStencilPassOp          : 3;
                UINT BackStencilFunc            : 3;

                BitPackedBlendDesc(0);
                BitPackedBlendDesc(1);
                BitPackedBlendDesc(2);
                BitPackedBlendDesc(3);
            };

            CompressedData m_compressedData;

        };

        D3D9on12PipelineStateDesc m_desc;
    };
#pragma pack(pop)
}

namespace std
{
    template<>
    struct hash<D3D9on12::PipelineStateKey>
    {

        size_t operator()(D3D9on12::PipelineStateKey const& key) const
        {
            return size_t(D3D9on12::HashData(&key.m_desc, sizeof(key.m_desc)).m_data);
        }
    };
}

namespace D3D9on12
{
    struct PipelineStateCacheEntry
    {
        PipelineStateCacheEntry(const PipelineStateKey& key) : m_key(key) {}

        std::unique_ptr<D3D12TranslationLayer::PipelineState> m_pPipelineState;
        UINT64 m_timestamp;
        std::list<std::shared_ptr<PipelineStateCacheEntry>>::iterator m_accessOrderPos;
        PipelineStateKey m_key;
    };

    struct PipelineStateCacheImpl
    {
        std::list<std::shared_ptr<PipelineStateCacheEntry>> m_accessOrder;
        std::unordered_map<PipelineStateKey, std::shared_ptr<PipelineStateCacheEntry>> m_map;
    };

    struct PipelineStateCacheKeyComponent
    {
    public:
        PipelineStateCacheKeyComponent(PipelineStateCacheImpl &cache) : m_cache(cache) {}
        ~PipelineStateCacheKeyComponent() 
        { 
            for (auto &key : m_pPSOKeys)
            {
                auto it = m_cache.m_map.find(key);

                if (it != m_cache.m_map.end())
                {
                    assert(m_cache.m_map.size() == m_cache.m_accessOrder.size());
                    assert(it->second.get() == it->second->m_accessOrderPos->get());
                    m_cache.m_accessOrder.erase(it->second->m_accessOrderPos);
                    m_cache.m_map.erase(it);
                }
            }
        }

        // Move-only
        PipelineStateCacheKeyComponent() = default;
        PipelineStateCacheKeyComponent(PipelineStateCacheKeyComponent const&) = delete;
        PipelineStateCacheKeyComponent& operator=(PipelineStateCacheKeyComponent const&) = delete;
        PipelineStateCacheKeyComponent(PipelineStateCacheKeyComponent&&) = default;
        PipelineStateCacheKeyComponent& operator=(PipelineStateCacheKeyComponent&&) = default;

        void AddPSO(const PipelineStateKey &key)
        {
            m_pPSOKeys.insert(key);
        }

        void RemovePSO(const PipelineStateKey& key)
        {
            m_pPSOKeys.erase(key);
        }

    private:
        std::unordered_set<PipelineStateKey> m_pPSOKeys;
        PipelineStateCacheImpl &m_cache;
    };

    class PipelineStateCache
    {
    public:
        PipelineStateCache(Device &device) : 
            m_device(device) {}

        D3D12TranslationLayer::PipelineState * GetPipelineState(D3D12_GRAPHICS_PIPELINE_STATE_DESC &psoDesc, D3D12VertexShader* pVS, D3D12PixelShader* pPS, D3D12GeometryShader* pGS);
        
        PipelineStateCacheImpl &GetCache() { return m_cache; }
    private:
        void AddUses(Shader &ps, Shader &vs, PipelineStateKey key);
        void Trim();

        Device &m_device;
        PipelineStateCacheImpl m_cache;
    };

    struct ShaderKey
    {
        const byte *pBytecode;
        size_t size;
        WeakHash hash;

        struct Hasher
        {
            size_t operator()(ShaderKey const& key) const { return key.hash.m_data; }
        };
        bool operator==(ShaderKey const& o) const
        {
            return size == o.size &&
                (pBytecode == o.pBytecode ||
                    memcmp(pBytecode, o.pBytecode, size) == 0);
        }
    };

    template <typename TShader>
    struct ShaderDedupe
    {
        std::unordered_map<ShaderKey, std::unique_ptr<TShader>, ShaderKey::Hasher> map;
        TShader *GetOrCreate(Device& device, const byte *pBytecode, size_t size)
        {
            ShaderKey searchKey{ pBytecode, size, HashData(pBytecode, size) };
            auto iter = map.find(searchKey);
            if (iter != map.end())
            {
                iter->second->AddRef();
                return iter->second.get();
            }

            std::unique_ptr<TShader> shader(new TShader(device, *pBytecode, size, searchKey.hash));
            ShaderKey insertKey{ shader->GetLegacyByteCode().m_ptr, shader->GetLegacyByteCode().m_size, searchKey.hash };
            auto ret = map.emplace(insertKey, std::move(shader));
            assert(ret.second);
            return ret.first->second.get();
        }

        void Release(TShader *shader)
        {
            UINT refCount = shader->Release();
            if (refCount == 0)
            {
                ShaderKey searchKey{ shader->GetLegacyByteCode().m_ptr, shader->GetLegacyByteCode().m_size, shader->GetHashForLegacyByteCode() };
                [[maybe_unused]] size_t num_erased = map.erase(searchKey);
                assert(num_erased == 1);
            }
        }
    };

};

```

`include/9on12PipelineStateStructures.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#pragma once

namespace D3D9on12
{
    struct PipelineStateDirtyFlags
    {
        union
        {
            UINT64 MiscFlags;
            struct
            {
                UINT VSExtension : 1;
                UINT PSExtension : 1;
                UINT PSExtension2 : 1;
                UINT PSExtension3 : 1;
                UINT VertexBuffers : 1;
                UINT IndexBuffer : 1;
                UINT Samplers : MAX_SAMPLERS_STAGES;
                UINT Textures : MAX_SAMPLERS_STAGES;
            };
        };

        union
        {
            UINT64 PSOFlags;
            struct
            {
                UINT RenderTargets : MAX_RENDER_TARGETS;
                UINT DepthStencil : 1;
                UINT Viewport : 1;
                UINT Topology : 1;
                UINT InputLayout : 1;
                UINT RasterizerState : 1;
                UINT DepthStencilState : 1;
                UINT BlendState : 1;
                UINT PointSize : 1;
                UINT IndexedStream : 1;
                UINT VertexShader : 1;
                UINT PixelShader : 1;
            };
        };


        PipelineStateDirtyFlags()
        {
            Clear();
            C_ASSERT(sizeof(PipelineStateDirtyFlags) == 2 * sizeof(UINT64));
        }

        void Clear()
        {
            memset(&MiscFlags, 0, sizeof(MiscFlags));
            memset(&PSOFlags, 0, sizeof(MiscFlags));
        }

        bool IsPSOChangeRequired()
        {
            return PSOFlags != 0;
        }
    };

    class Resource;

    struct BoundRenderTarget
    {
        BoundRenderTarget() : m_pResource(nullptr), m_subresource(0) {}

        BoundRenderTarget(Resource *pResource, UINT subresource) :
            m_pResource(pResource), m_subresource(subresource) {}

        Resource *m_pResource;
        UINT m_subresource;
    };

    struct RasterizerStateID
    {
        union
        {
            UINT Flags;
            struct
            {
                UINT TriangleMode : 1;
                UINT FillMode : 2;
                UINT CullMode : 2;
                UINT MultiSampleRenderTarget : 1;
                UINT MultiSampleAntiAlias : 1;
                UINT AntialiasedLineEnable : 1;
                UINT DepthClipEnable : 1;
                UINT DrawingPreTransformedVertices : 1;
            };
        };
        FLOAT DepthBias;
        FLOAT SlopeScaleDepthBias;
        RasterizerStateID() : Flags(0),
            DepthBias(0.0f),
            SlopeScaleDepthBias(0.0f)
        {
            C_ASSERT(sizeof(RasterizerStateID) == sizeof(Flags) +
                sizeof(DepthBias) +
                sizeof(SlopeScaleDepthBias));
        }
        bool operator==(const RasterizerStateID& rhs) const
        {
            return (this->Flags == rhs.Flags)
                && (this->DepthBias == rhs.DepthBias)
                && (this->SlopeScaleDepthBias == rhs.SlopeScaleDepthBias);
        }
        bool operator!=(const RasterizerStateID& rhs) const
        {
            return !(*this == rhs);
        }
        operator UINT() const
        {
            return this->Flags;
        }

        bool RequiresForcedSampleCount() const
        {
            return MultiSampleRenderTarget && !MultiSampleAntiAlias;
        }
    };

    struct DepthStencilStateID
    {
        union
        {
            UINT Flags1;
            struct
            {
                UINT ZEnable : 1;
                UINT ZWriteEnable : 1;
                UINT ZFunc : 3;
                UINT StencilEnable : 1;
                UINT TwoSidedStencil : 1;
                UINT StencilFail : 3;
                UINT StencilZFail : 3;
                UINT StencilPass : 3;
                UINT StencilFunc : 3;
                UINT CCWStencilFail : 3;
                UINT CCWStencilZFail : 3;
                UINT CCWStencilPass : 3;
                UINT CCWStencilFunc : 3;
            };
        };
        union
        {
            UINT Flags2;
            struct
            {
                UINT StencilMask : 8;
                UINT StencilWriteMask : 8;
                UINT StencilRef : 8;
            };
        };
        DepthStencilStateID() : Flags1(0), Flags2(0)
        {
            C_ASSERT(sizeof(DepthStencilStateID) == sizeof(Flags1) + sizeof(Flags2));
        }
        bool operator==(const DepthStencilStateID& rhs) const
        {
            return (this->Flags1 == rhs.Flags1)
                && (this->Flags2 == rhs.Flags2);
        }
        bool operator!=(const DepthStencilStateID& rhs) const
        {
            return !(*this == rhs);
        }
        operator UINT() const
        {
            return this->Flags1;
        }

        bool DepthStencilViewBindingOptional()
        {
            return !ZEnable && !StencilEnable;
        }
    };

    struct BlendStateID
    {
        union
        {
            UINT Flags;
            struct
            {
                UINT AlphaBlendEnable : 1;
                UINT AlphaToCoverageEnable : 1;
                UINT SrcBlend : 5;
                UINT DstBlend : 5;
                UINT BlendOp : 3;
                UINT SeparateAlphaBlend : 1;
                UINT SrcBlendAlpha : 5;
                UINT DstBlendAlpha : 5;
                UINT BlendOpAlpha : 3;
            };
        };
        union
        {
            UINT ColorWriteFullMask;
            struct
            {
                BYTE ColorWriteMasks[MAX_RENDER_TARGETS];
            };
            struct
            {
                BYTE ColorWriteMask0;
                BYTE ColorWriteMask1;
                BYTE ColorWriteMask2;
                BYTE ColorWriteMask3;
            };
        };
        BlendStateID() : Flags(0), ColorWriteFullMask(0)
        {
            C_ASSERT(sizeof(BlendStateID) == sizeof(Flags) + sizeof(ColorWriteFullMask));
        }
        bool operator==(const BlendStateID& rhs) const
        {
            return (this->ColorWriteFullMask == rhs.ColorWriteFullMask)
                && (this->Flags == rhs.Flags);
        }
        bool operator!=(const BlendStateID& rhs) const
        {
            return !(*this == rhs);
        }
        operator UINT() const
        {
            return this->Flags;
        }
    };

    struct SamplerStateID
    {
        union
        {
            UINT Flags;
            struct
            {
                UINT MagFilter : 4;
                UINT MinFilter : 4;
                UINT MipFilter : 4;
                UINT AddressU : 3;
                UINT AddressV : 3;
                UINT AddressW : 3;
                UINT MaxAnisotropy : 8;
                UINT UseHardwareShadowMapping : 1;
                UINT SwapRBBorderColors : 1;
            };
        };
        UINT  BorderColor;
        UINT  MaxMipLevel;
        FLOAT MipLODBias;

        SamplerStateID() : Flags(0),
            BorderColor(0),
            MaxMipLevel(0),
            MipLODBias(0.0f)
        {
            C_ASSERT(sizeof(SamplerStateID) == sizeof(Flags) +
                sizeof(BorderColor) +
                sizeof(MaxMipLevel) +
                sizeof(MipLODBias));
        }
        bool operator==(const SamplerStateID& rhs) const
        {
            return (this->Flags == rhs.Flags)
                && (this->BorderColor == rhs.BorderColor)
                && (this->MaxMipLevel == rhs.MaxMipLevel)
                && (this->MipLODBias == rhs.MipLODBias);
        }
        bool operator!=(const SamplerStateID& rhs) const
        {
            return !(*this == rhs);
        }
        operator UINT() const
        {
            return this->Flags;
        }
    };

    static D3D12_RASTERIZER_DESC ConvertRasterizerState(RasterizerStateID rasterizerID, bool bDepthEnabledAndBound, DXGI_FORMAT dsvFormat)
    {
        D3D12_RASTERIZER_DESC rasterizerDesc = {};

        rasterizerDesc.ConservativeRaster = D3D12_CONSERVATIVE_RASTERIZATION_MODE_OFF;
        if (rasterizerID.TriangleMode)
        {
            switch (rasterizerID.FillMode)
            {
            case D3DFILL_WIREFRAME:
                rasterizerDesc.FillMode = D3D12_FILL_MODE_WIREFRAME;
                break;
            default:
            case D3DFILL_SOLID:
                rasterizerDesc.FillMode = D3D12_FILL_MODE_SOLID;
                break;
            }
            switch (rasterizerID.CullMode)
            {
            default:
                Check9on12(false);
                // Fall through to a reasonable default - hit by Tree of Savior
            case D3DCULL_NONE:
                rasterizerDesc.CullMode = D3D12_CULL_MODE_NONE;
                break;
            case D3DCULL_CW:
                rasterizerDesc.CullMode = D3D12_CULL_MODE_FRONT;
                break;
            case D3DCULL_CCW:
                rasterizerDesc.CullMode = D3D12_CULL_MODE_BACK;
                break;
            }
        }
        else
        {
            rasterizerDesc.FillMode = D3D12_FILL_MODE_SOLID;
            rasterizerDesc.CullMode = D3D12_CULL_MODE_NONE;
        }
        rasterizerDesc.FrontCounterClockwise = FALSE;

        if (bDepthEnabledAndBound)
        {
            if (rasterizerID.TriangleMode)
            {
                const UINT uiDepthBiasFactor = DepthBiasFactorFromDSVFormat(dsvFormat);
                rasterizerDesc.DepthBias = static_cast<INT32>(rasterizerID.DepthBias * uiDepthBiasFactor);
                rasterizerDesc.SlopeScaledDepthBias = rasterizerID.SlopeScaleDepthBias;
            }
            else
            {
                rasterizerDesc.DepthBias = 0;
                rasterizerDesc.SlopeScaledDepthBias = 0.0f;
            }
        }
        rasterizerDesc.DepthBiasClamp = 0.0f;

        if (rasterizerID.DrawingPreTransformedVertices && !bDepthEnabledAndBound)
        {
            rasterizerDesc.DepthClipEnable = false;
        }
        else
        {
            rasterizerDesc.DepthClipEnable = rasterizerID.DepthClipEnable ? TRUE : FALSE;
        }

        rasterizerDesc.AntialiasedLineEnable = rasterizerID.AntialiasedLineEnable ? TRUE : FALSE;

        rasterizerDesc.MultisampleEnable = (rasterizerID.MultiSampleRenderTarget
            && rasterizerID.MultiSampleAntiAlias) ? TRUE : FALSE;

        // In DX10.1+ MultisampleEnabled has a different meaning from DX9. In DX9 "MultiSampleEnabled == false"
        // means only sample from center of the pixel. In DX10.1+ "MultiSampleEnabled == false" means use
        // alpha line anti-aliasing. We can emulate DX9 by setting the ForcedSampleCount = 1.
        // If the D3D9 app disabled depth before turning off anti-aliasing, we'll respect it and use ForcedSampleCount = 1.
        // But if the app left depth enabled, we have to choose between turning off depth or leaving on anti-aliasing.
        // The safer thing is to just leave on anti-aliasing.
        if (rasterizerID.RequiresForcedSampleCount() && !bDepthEnabledAndBound)
        {
            rasterizerDesc.ForcedSampleCount = 1;
        }

        return rasterizerDesc;
    }

    static void PatchBlendForDisaledAlpha(D3D12_BLEND &blend)
    {
        // Only the destination blend is disabled. Because the "source" alpha for the blend
        // operation is calculated in the shader, it's not affected by whether the render target
        // has alpha disabled because this is only applied after the color is written out to the RTV
        switch (blend)
        {
        case D3D12_BLEND_DEST_ALPHA:
            blend =  D3D12_BLEND_ONE;
            break;
        case D3D12_BLEND_INV_DEST_ALPHA:
            blend = D3D12_BLEND_ZERO;
            break;
        }
    }


    static void PatchRenderTargetBlendDescForDisaledAlpha(D3D12_RENDER_TARGET_BLEND_DESC &desc)
    {
        PatchBlendForDisaledAlpha(desc.SrcBlend);
        PatchBlendForDisaledAlpha(desc.DestBlend);
    }

    static D3D12_BLEND_DESC ConvertBlendState(BlendStateID blendID, const RTVBitMask alphaDisabledMask, _In_reads_(MAX_RENDER_TARGETS) UINT *pRTVShaderComponentMappings)
    {
        D3D12_BLEND_DESC blendDesc = {};

        blendDesc.AlphaToCoverageEnable = blendID.AlphaToCoverageEnable ? TRUE : FALSE;
        blendDesc.IndependentBlendEnable = TRUE;
        blendDesc.RenderTarget[0].BlendEnable = blendID.AlphaBlendEnable ? TRUE : FALSE;
        if (blendID.AlphaBlendEnable)
        {
            UINT srcBlend = blendID.SrcBlend;
            UINT dstBlend = blendID.DstBlend;
            if (D3DBLEND_BOTHSRCALPHA == srcBlend)
            {
                srcBlend = D3DBLEND_SRCALPHA;
                dstBlend = D3DBLEND_INVSRCALPHA;
            }
            else if (D3DBLEND_BOTHINVSRCALPHA == srcBlend)
            {
                srcBlend = D3DBLEND_INVSRCALPHA;
                dstBlend = D3DBLEND_SRCALPHA;
            }

            blendDesc.RenderTarget[0].SrcBlend = ConvertToD3D12Blend(static_cast<D3DBLEND>(srcBlend));
            blendDesc.RenderTarget[0].DestBlend = ConvertToD3D12Blend(static_cast<D3DBLEND>(dstBlend));
            blendDesc.RenderTarget[0].BlendOp = ConvertToD3D12BlendOp(static_cast<D3DBLENDOP>(blendID.BlendOp));
            if (blendID.SeparateAlphaBlend)
            {
                blendDesc.RenderTarget[0].SrcBlendAlpha = ConvertToD3D12AlphaBlend(static_cast<D3DBLEND>(blendID.SrcBlendAlpha));
                blendDesc.RenderTarget[0].DestBlendAlpha = ConvertToD3D12AlphaBlend(static_cast<D3DBLEND>(blendID.DstBlendAlpha));
                blendDesc.RenderTarget[0].BlendOpAlpha = ConvertToD3D12BlendOp(static_cast<D3DBLENDOP>(blendID.BlendOpAlpha));
            }
            else
            {
                blendDesc.RenderTarget[0].SrcBlendAlpha = ConvertToD3D12AlphaBlend(static_cast<D3DBLEND>(srcBlend));
                blendDesc.RenderTarget[0].DestBlendAlpha = ConvertToD3D12AlphaBlend(static_cast<D3DBLEND>(dstBlend));

                blendDesc.RenderTarget[0].BlendOpAlpha = blendDesc.RenderTarget[0].BlendOp;
            }
        }

        for (UINT i = 0; i < MAX_RENDER_TARGETS; ++i)
        {
            if (i > 0)
            {
                blendDesc.RenderTarget[i] = blendDesc.RenderTarget[0];
            }

            UINT8 renderTargetWriteMask = blendID.ColorWriteMasks[i] & COLOR_CHANNEL_MASK;
            blendDesc.RenderTarget[i].RenderTargetWriteMask = SwizzleRenderTargetMask(
                renderTargetWriteMask,
                pRTVShaderComponentMappings[i]);
            if (alphaDisabledMask[i])
            {
                PatchRenderTargetBlendDescForDisaledAlpha(blendDesc.RenderTarget[i]);
            }

        }

        return blendDesc;
    }

    static D3D12_DEPTH_STENCIL_DESC ConvertDepthStencilState(DepthStencilStateID depthStencilID, bool bDsvBound)
    {
        D3D12_DEPTH_STENCIL_DESC depthStencilDesc{};

        depthStencilDesc.DepthEnable = (bDsvBound && depthStencilID.ZEnable) ? TRUE : FALSE;
        depthStencilDesc.DepthWriteMask =
            depthStencilID.ZWriteEnable ? D3D12_DEPTH_WRITE_MASK_ALL : D3D12_DEPTH_WRITE_MASK_ZERO;
        depthStencilDesc.DepthFunc = ConvertToD3D12ComparisonFunc(static_cast<D3DCMPFUNC>(depthStencilID.ZFunc + 1));
        depthStencilDesc.StencilEnable = depthStencilID.StencilEnable ? TRUE : FALSE;
        depthStencilDesc.StencilReadMask = depthStencilID.StencilMask;
        depthStencilDesc.StencilWriteMask = depthStencilID.StencilWriteMask;
        depthStencilDesc.FrontFace.StencilFailOp = ConvertToD3D12StencilOp(static_cast<D3DSTENCILOP>(depthStencilID.StencilFail + 1));
        depthStencilDesc.FrontFace.StencilDepthFailOp = ConvertToD3D12StencilOp(static_cast<D3DSTENCILOP>(depthStencilID.StencilZFail + 1));
        depthStencilDesc.FrontFace.StencilPassOp = ConvertToD3D12StencilOp(static_cast<D3DSTENCILOP>(depthStencilID.StencilPass + 1));
        depthStencilDesc.FrontFace.StencilFunc = ConvertToD3D12ComparisonFunc(static_cast<D3DCMPFUNC>(depthStencilID.StencilFunc + 1));
        if (depthStencilID.TwoSidedStencil)
        {
            depthStencilDesc.BackFace.StencilFailOp = ConvertToD3D12StencilOp(static_cast<D3DSTENCILOP>(depthStencilID.CCWStencilFail + 1));
            depthStencilDesc.BackFace.StencilDepthFailOp = ConvertToD3D12StencilOp(static_cast<D3DSTENCILOP>(depthStencilID.CCWStencilZFail + 1));
            depthStencilDesc.BackFace.StencilPassOp = ConvertToD3D12StencilOp(static_cast<D3DSTENCILOP>(depthStencilID.CCWStencilPass + 1));
            depthStencilDesc.BackFace.StencilFunc = ConvertToD3D12ComparisonFunc(static_cast<D3DCMPFUNC>(depthStencilID.CCWStencilFunc + 1));
        }
        else
        {
            depthStencilDesc.BackFace = depthStencilDesc.FrontFace;
        }

        return depthStencilDesc;
    }

    static D3D12_SAMPLER_DESC ConvertSampler(SamplerStateID samplerID, bool supportAnisoPointMip)
    {
        D3D12_SAMPLER_DESC samplerDesc = {};
        samplerDesc.MinLOD = static_cast<float>(samplerID.MaxMipLevel);
        samplerDesc.MaxLOD = FLT_MAX;

        samplerDesc.Filter = ConvertToD3D12SamplerFilter(
            static_cast<D3DTEXTUREFILTERTYPE>(samplerID.MagFilter),
            static_cast<D3DTEXTUREFILTERTYPE>(samplerID.MinFilter),
            static_cast<D3DTEXTUREFILTERTYPE>(samplerID.MipFilter),
            samplerID.UseHardwareShadowMapping,
            supportAnisoPointMip);

        samplerDesc.AddressU = ConvertToD3D12TextureAddress(static_cast<D3DTEXTUREADDRESS>(samplerID.AddressU));
        samplerDesc.AddressV = ConvertToD3D12TextureAddress(static_cast<D3DTEXTUREADDRESS>(samplerID.AddressV));
        samplerDesc.AddressW = ConvertToD3D12TextureAddress(static_cast<D3DTEXTUREADDRESS>(samplerID.AddressW));
        samplerDesc.MipLODBias = samplerID.MipLODBias;
        samplerDesc.MaxAnisotropy = samplerID.MaxAnisotropy;
        
        samplerDesc.ComparisonFunc = (samplerID.UseHardwareShadowMapping) ? D3D12_COMPARISON_FUNC_LESS_EQUAL : D3D12_COMPARISON_FUNC_NEVER;
       
        ConvertToRGBA(samplerID.BorderColor, samplerDesc.BorderColor);
        if (samplerID.SwapRBBorderColors)
        {
            std::swap(samplerDesc.BorderColor[0], samplerDesc.BorderColor[2]);
        }

        return samplerDesc;
    }

    static DWORD MapSamplerStage9on12(DWORD dwStage)
    {
        if (D3DDMAPSAMPLER == dwStage)
        {
            return DMAP_SAMPLER;
        }
        else
        {
            if ((dwStage >= D3DVERTEXTEXTURESAMPLER0) && (dwStage < (D3DVERTEXTEXTURESAMPLER0 + D3DHAL_SAMPLER_MAXVERTEXSAMP)))
            {
                return VERTEX_SAMPLER0 + (dwStage - D3DVERTEXTEXTURESAMPLER0);
            }
        }

        return dwStage;
    }

    class RasterStatesWrapper : private ShaderConv::RasterStates
    {

    public:
        RasterStatesWrapper(PipelineStateDirtyFlags &dirtyFlags) : m_dirtyFlags(dirtyFlags) {}

        const ShaderConv::RasterStates &GetRasterState()
        {
            return *dynamic_cast<ShaderConv::RasterStates *>(this);
        }

        void SetUserClipplanes(UINT inUserClipPlanes)
        {
            if (!IsEquals(inUserClipPlanes, UserClipPlanes))
            {
                UserClipPlanes = inUserClipPlanes;
                MarkVSDirty();
            }
        }

        void SetFillMode(_D3DFILLMODE inFillMode)
        {
            if (!IsEquals((_D3DFILLMODE)FillMode, inFillMode))
            {
                FillMode = inFillMode;
                MarkPSDirty();
            }
        }

        void SetShadeMode(_D3DSHADEMODE inShadeMode)
        {
            if (!IsEquals((_D3DSHADEMODE)ShadeMode, inShadeMode))
            {
                ShadeMode = inShadeMode;
                MarkPSDirty();
                MarkGSDirty();
            }
        }

        void SetPrimitiveType(D3DPRIMITIVETYPE inPrimitiveType)
        {
            if (!IsEquals((D3DPRIMITIVETYPE)PrimitiveType, inPrimitiveType))
            {
                PrimitiveType = inPrimitiveType;
                MarkGSDirty();
                MarkPSDirty();
            }
        }

        void SetAlphaFunc(_D3DCMPFUNC inAlphaFunc)
        {
            if (!IsEquals((_D3DCMPFUNC)AlphaFunc, inAlphaFunc))
            {
                AlphaFunc = inAlphaFunc;
                MarkPSDirty();
            }
        }

        void SetFogEnable(bool inFogEnable)
        {
            if (!IsEquals((bool)FogEnable, inFogEnable))
            {
                FogEnable = inFogEnable;
                MarkPSDirty();
            }
        }

        void SetFogTableMode(UINT inFogTableMode)
        {
            if (!IsEquals(FogTableMode, inFogTableMode))
            {
                FogTableMode = inFogTableMode;
                MarkPSDirty();
            }
        }

        void SetWFogEnable(bool inWFogEnable)
        {
            if (!IsEquals((bool)WFogEnable, inWFogEnable))
            {
                WFogEnable = inWFogEnable;
                MarkPSDirty();
            }
        }

        void SetAlphaTestEnable(bool inAlphaTestEnable)
        {
            if (!IsEquals((bool)AlphaTestEnable, inAlphaTestEnable))
            {
                AlphaTestEnable = inAlphaTestEnable;
                MarkPSDirty();
            }
        }

        void SetPointSizeEnable(bool inPointSizeEnable)
        {
            if (!IsEquals((bool)PointSizeEnable, inPointSizeEnable))
            {
                PointSizeEnable = inPointSizeEnable;
                MarkGSDirty();
            }
        }

        void SetPointSpriteEnable(bool inPointSpriteEnable)
        {
            if (!IsEquals((bool)PointSpriteEnable, inPointSpriteEnable))
            {
                PointSpriteEnable = inPointSpriteEnable;
                MarkGSDirty();
            }
        }

        void SetColorKeyEnable(bool inColorKeyEnable)
        {
            if (!IsEquals((bool)ColorKeyEnable, inColorKeyEnable))
            {
                ColorKeyEnable = inColorKeyEnable;
                MarkPSDirty();
            }
        }

        void SetColorKeyBlendEnable(bool inColorKeyBlendEnable)
        {
            if (!IsEquals((bool)ColorKeyBlendEnable, inColorKeyBlendEnable))
            {
                ColorKeyBlendEnable = inColorKeyBlendEnable;
                MarkPSDirty();
            }
        }

        void SetHasTLVertices(bool inHasTLVertices)
        {
            if (!IsEquals((bool)HasTLVertices, inHasTLVertices))
            {
                HasTLVertices = inHasTLVertices;
                MarkPSDirty();
            }
        }

        void SetPSSamplerTextureType(_In_range_(0, D3DHAL_SAMPLER_MAXSAMP - 1) UINT samplerIndex, ShaderConv::TEXTURETYPE inTextureType)
        {
            Check9on12(samplerIndex < ARRAYSIZE(PSSamplers));
            if (!IsEquals((ShaderConv::TEXTURETYPE)PSSamplers[samplerIndex].TextureType, inTextureType))
            {
                PSSamplers[samplerIndex].TextureType = inTextureType;
                MarkPSDirty();
            }
        }

        void SetPSSamplerTexCoordWrap(_In_range_(0, D3DHAL_SAMPLER_MAXSAMP - 1) UINT samplerIndex, BYTE inTexCoordWrap)
        {
            Check9on12(samplerIndex < ARRAYSIZE(PSSamplers));
            if (!IsEquals(PSSamplers[samplerIndex].TexCoordWrap, inTexCoordWrap))
            {
                PSSamplers[samplerIndex].TexCoordWrap = inTexCoordWrap;
                MarkPSDirty();
            }
        }

        void ClearTCIMappingFlags(UINT mask)
        {
            if (TCIMapping & mask)
            {
                TCIMapping &= ~mask;
                MarkPSDirty();
            }
        }

        void SetTCIMappingFlags(UINT mask)
        {
            if ((TCIMapping | mask) != TCIMapping)
            {
                TCIMapping |= mask;
                MarkPSDirty();
            }
        }

        void SetProjectedTCsMask(UINT mask)
        {
            if ((ProjectedTCsMask | mask) != ProjectedTCsMask)
            {
                ProjectedTCsMask |= mask;
                MarkPSDirty();
            }
        }

        void ClearProjectedTCsMask(UINT mask)
        {
            if (ProjectedTCsMask & mask)
            {
                ProjectedTCsMask &= ~mask;
                MarkPSDirty();
            }
        }

        void SetColorKeyTSSDisable(UINT mask)
        {
            if ((ColorKeyTSSDisable | mask) != ColorKeyTSSDisable)
            {
                ColorKeyTSSDisable |= mask;
                MarkPSDirty();
            }
        }

        void ClearColorKeyTSSDisable(UINT mask)
        {
            if (ColorKeyTSSDisable & mask)
            {
                ColorKeyTSSDisable &= ~mask;
                MarkPSDirty();
            }
        }

        bool IsUsingPointFill()
        {
            return FillMode == D3DFILL_POINT && PrimitiveType >= D3DPT_TRIANGLELIST;
        }
        
        bool IsUsingPointSpritesOrSizes(const ShaderConv::VSOutputDecls &vsOutputDecls)
        {
            return (PointSizeEnable || PointSpriteEnable || vsOutputDecls.PointSize) && PrimitiveType == D3DPT_POINTLIST;
        }

        BYTE GetPSTexCoordWrap(UINT regIndex)
        {
            return PSSamplers[regIndex].TexCoordWrap;
        }

        D3DSHADEMODE GetShadingMode()
        {
            return (D3DSHADEMODE)ShadeMode;
        }

        void SetHardwareShadowMappingFlag(D3D12TranslationLayer::EShaderStage shaderType, UINT textureIndex, bool enabled)
        {
            Check9on12(textureIndex <= ShaderConv::MAX_PS_SAMPLER_REGS);
            Check9on12(shaderType == D3D12TranslationLayer::e_PS || shaderType == D3D12TranslationLayer::e_VS);

           if (shaderType == D3D12TranslationLayer::e_PS)
           {
               if (enabled)
               {
                   HardwareShadowMappingRequiredPS |= BIT(textureIndex);
               }
               else
               {
                   HardwareShadowMappingRequiredPS &= ~BIT(textureIndex);
               }
               MarkPSDirty();
           }
           else
           {
               if (enabled)
               {
                   HardwareShadowMappingRequiredVS |= BIT(textureIndex);
               }
               else
               {
                   HardwareShadowMappingRequiredVS &= ~BIT(textureIndex);
               }
               MarkVSDirty();
           }
        }

        void SetSwapRBOutputChannelsFlag(UINT outputIndex, bool enabled)
        {
            if (enabled)
            {
                SwapRBOnOutputMask |= BIT(outputIndex);
            }
            else
            {
                SwapRBOnOutputMask &= ~BIT(outputIndex);
            }
            MarkPSDirty();
        }

    private:
        PipelineStateDirtyFlags &m_dirtyFlags;
        void MarkPSDirty()
        {
            m_dirtyFlags.PixelShader = true;
        }

        void MarkVSDirty()
        {
            m_dirtyFlags.VertexShader = true;
        }

        void MarkGSDirty()
        {
        }

        template<typename T>
        FORCEINLINE bool IsEquals(T objA, T objB)
        {
            return objA == objB;
        }
    };

    class VSCBExntensionWrapper : private ShaderConv::VSCBExtension
    {
        const UINT POINT_SIZE_INDEX = 0;
        const UINT MIN_POINT_SIZE_INDEX = 1;
        const UINT MAX_POINT_SIZE_INDEX = 2;
    public:
        VSCBExntensionWrapper(PipelineStateDirtyFlags &dirtyFlags) : m_dirtyFlags(dirtyFlags) {
            memset((void *)&GetVSCBExtension(), 0, sizeof(GetVSCBExtension()));
        }

        const ShaderConv::VSCBExtension &GetUnderlyingData() { return *this; }

        void SetViewportScale(float xScale, float yScale)
        {
            AssertFloatNotInfOrNan(xScale);
            AssertFloatNotInfOrNan(yScale);
            if (xScale != vViewPortScale[0] || yScale != vViewPortScale[1])
            {
                vViewPortScale[0] = xScale;
                vViewPortScale[1] = yScale;

                MarkVSExtensionDirty();
            }
        }
        
        void SetMaxPointSize(float maxPointSize)
        {
            AssertFloatNotInfOrNan(maxPointSize);
            if (vPointSize[MAX_POINT_SIZE_INDEX] != maxPointSize)
            {
                vPointSize[MAX_POINT_SIZE_INDEX] = maxPointSize;
                MarkVSExtensionDirty();
                MarkPointSizeDirty();
            }
        }

        void SetMinPointSize(float minPointSize)
        {
            AssertFloatNotInfOrNan(minPointSize);
            if (vPointSize[MIN_POINT_SIZE_INDEX] != minPointSize)
            {
                vPointSize[MIN_POINT_SIZE_INDEX] = minPointSize;
                MarkVSExtensionDirty();
                MarkPointSizeDirty();
            }
        }

        void SetPointSize(float pointSize)
        {
            AssertFloatNotInfOrNan(pointSize);
            if (vPointSize[POINT_SIZE_INDEX] != pointSize)
            {
                vPointSize[POINT_SIZE_INDEX] = pointSize;
                MarkVSExtensionDirty();
                MarkPointSizeDirty();
            }
        }

        void SetClipPlane(_In_range_(0, ShaderConv::MAX_CLIPLANES - 1) UINT clipPlaneIndex, _In_reads_(4) const float *pClipPlane)
        {
            for (UINT i = 0; i < 4; i++) AssertFloatNotInfOrNan(pClipPlane[i]);

            if (memcmp(pClipPlane, vClipPlanes[clipPlaneIndex], sizeof(vClipPlanes[clipPlaneIndex])) != 0)
            {
                memcpy(vClipPlanes[clipPlaneIndex], pClipPlane, sizeof(vClipPlanes[clipPlaneIndex]));
                MarkVSExtensionDirty();
            }
        }

        void SetScreenToClipOffset(float xOffset, float yOffset, float zOffset, float wOffset = 0.0f)
        {
            AssertFloatNotInfOrNan(xOffset);
            AssertFloatNotInfOrNan(yOffset);
            AssertFloatNotInfOrNan(zOffset);
            AssertFloatNotInfOrNan(wOffset);

            if (xOffset != vScreenToClipOffset[0] || yOffset != vScreenToClipOffset[1] || zOffset != vScreenToClipOffset[2] || wOffset != vScreenToClipOffset[3])
            {
                vScreenToClipOffset[0] = xOffset;
                vScreenToClipOffset[1] = yOffset;
                vScreenToClipOffset[2] = zOffset;
                vScreenToClipOffset[3] = wOffset;
                MarkVSExtensionDirty();
            }
        }

        void SetScreenToClipScale(float xScale, float yScale, float zScale, float wScale = 1.0f)
        {
            AssertFloatNotInfOrNan(xScale);
            AssertFloatNotInfOrNan(yScale);
            AssertFloatNotInfOrNan(zScale);
            AssertFloatNotInfOrNan(wScale);

            if (xScale != vScreenToClipScale[0] || yScale != vScreenToClipScale[1] || zScale != vScreenToClipScale[2] || wScale != vScreenToClipScale[3])
            {
                vScreenToClipScale[0] = xScale;
                vScreenToClipScale[1] = yScale;
                vScreenToClipScale[2] = zScale;
                vScreenToClipScale[3] = wScale;
                MarkVSExtensionDirty();
            }
        }

        void ResolvePointSize()
        {
            const float pointSizeMin = vPointSize[MIN_POINT_SIZE_INDEX];
            const float pointSizeMax = vPointSize[MAX_POINT_SIZE_INDEX];

            // Clamp the point size  
            const float pointSize = min(max(GetPointSize(), pointSizeMin), pointSizeMax);

            // Update the vertex extension  
            SetPointSize(pointSize);
        }

        float GetPointSize()
        {
            return vPointSize[POINT_SIZE_INDEX];
        }

        const ShaderConv::VSCBExtension &GetVSCBExtension()
        {
            return *dynamic_cast<ShaderConv::VSCBExtension *>(this);
        }
            
    private:
        PipelineStateDirtyFlags &m_dirtyFlags;
        void MarkVSExtensionDirty()
        {
            m_dirtyFlags.VSExtension = true;
        }

        void MarkPointSizeDirty()
        {
            m_dirtyFlags.PointSize = true;
        }
    };
};

```

`include/9on12PixelStage.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#pragma once

namespace D3D9on12
{
    class Device;
    class PixelShader;
    struct D3D12PixelShader;

    class PixelStage
    {
    public:
        PixelStage(PipelineStateDirtyFlags& pipelineStateDirtyFlags, RasterStatesWrapper& rasterStates);

        HRESULT Init(Device& device);

        UINT GetNumBoundRenderTargets() { return m_numBoundRenderTargets; }
        const BoundRenderTarget &GetRenderTarget(UINT renderTargetIndex) { return m_pRenderTargets[renderTargetIndex]; }
        void SetDepthStencil(Resource *pDepthStencil);
        Resource *GetDepthStencil() { return m_pDepthStencil; }
        void SetMultiSampleMask(DWORD value) { m_multiSampleMask = value; }

        SamplerStateID& GetSamplerID(DWORD dwStage){ return m_samplerStateIDs[dwStage]; }
        Resource* GetSRV(DWORD dwStage) { return m_shaderResources[dwStage]; }

        void SetRenderTarget(UINT renderTargetIndex, BoundRenderTarget boundRenderTarget);
        void UpdateWInfo(_In_ CONST D3DDDIARG_WINFO& winInfo); // this is used for setting fog values
        void SetPixelShader(PixelShader* pShader);
        void SetRasterState(DWORD dwState, DWORD dwValue);
        void SetDepthStencilState(Device& device, DWORD dwState, DWORD dwValue);
        void SetBlendState(Device& device, DWORD dwState, DWORD dwValue);
        void SetPSExtensionState(DWORD dwState, DWORD dwValue);
        void SetPSExtension2State(DWORD dwStage, DWORD dwState, DWORD dwValue);
        void SetPreTransformedVertexMode(bool drawingPretransformedVerts);

        HRESULT ResolveDeferredState(Device &device, D3D12_GRAPHICS_PIPELINE_STATE_DESC& psoDesc, UINT& textureDirtyMaskToKeep);

        HRESULT SetSRV(Device& device, Resource* resource, UINT dx9TextureIndex);
        void SetSRGBTexture(UINT index, bool srgbEnabled);
        void SetSRGBWriteEnable(bool srgbEnabled);
        bool GetSRGBWriteEnable() { return m_SRGBWriteEnabled; }

        RasterizerStateID& GetRasterizerStateID() { return m_rasterizerStateID; }
        DepthStencilStateID& GetDepthStencilStateID() { return m_depthStencilStateID; }
        D3D12PixelShader* GetCurrentD3D12PixelShader() { return m_pCurrentD3D12PixelShader; }

        PixelShader* GetCurrentD3D9PixelShader() { return m_pCurrentPS; }
        void MarkSRVIndicesDirty(const std::vector<UINT> &indices);

    private: // Types
        struct SamplerCache
        {
            D3D12TranslationLayer::Sampler* GetSampler( Device& device, SamplerStateID& id );
        private:
            //Required for stl map
            struct Hasher {
                size_t operator()( SamplerStateID const& other ) const { return size_t( HashData( &other, sizeof( other ) ).m_data ); }
            };


            typedef std::unordered_map < SamplerStateID, std::unique_ptr<D3D12TranslationLayer::Sampler>, Hasher > MapType;

            MapType m_map;
        };

        struct ComputedRasterStates {
            UINT m_alphaTestEnable;
            UINT m_alphaFunc;
        };

    private: // Methods
        void ResolveRenderTargets(Device &device, D3D12_GRAPHICS_PIPELINE_STATE_DESC& psoDesc, bool bDSVBound);
        Resource* FindFirstValidBoundWritableResource();
        inline void SetAlphaToCoverageEnabled( const bool enabled );

    private: // Members
        DepthStencilStateID         m_depthStencilStateID;
        RasterizerStateID           m_rasterizerStateID;
        BlendStateID                m_blendStateID;
        UINT                        m_blendFactor;
        UINT                        m_multiSampleMask;
        RTVBitMask                  m_alphaDisabledMask;
        UINT                        m_rtvShaderComponentMapping[MAX_RENDER_TARGETS];
        SamplerStateID              m_samplerStateIDs[MAX_SAMPLERS_STAGES];

        Resource*                   m_shaderResources[MAX_SAMPLERS_STAGES];
        bool                        m_SRGBTexture[MAX_SAMPLERS_STAGES];
        bool                        m_SRGBWriteEnabled;
        bool                        m_hideDepthStencil;

        /* Extensions to handle 9 APIs */
        ShaderConv::PSCBExtension           m_PSExtension;
        ShaderConv::PSCBExtension2          m_PSExtension2;

        PipelineStateDirtyFlags& m_dirtyFlags;
        RasterStatesWrapper& m_rasterStates;
        ComputedRasterStates m_computedRasterStates;

        PixelShader* m_pCurrentPS;
        D3D12PixelShader* m_pCurrentD3D12PixelShader;

        UINT m_rtSetMask;
        _Field_range_(0, MAX_RENDER_TARGETS) DWORD m_numBoundRenderTargets;
        BoundRenderTarget m_pRenderTargets[MAX_RENDER_TARGETS];

        Resource *m_pDepthStencil;
        D3D12_DSV_FLAGS m_dsvRWType;

        SamplerCache m_samplerCache;
    };
};

```

`include/9on12Query.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#pragma once

namespace D3D9on12
{
    static const D3DQUERYTYPE g_cSupportedQueryTypes[] =
    {
        D3DQUERYTYPE_VCACHE,
        D3DQUERYTYPE_EVENT,
        D3DQUERYTYPE_OCCLUSION,
        D3DQUERYTYPE_TIMESTAMP,
        D3DQUERYTYPE_TIMESTAMPDISJOINT,
        D3DQUERYTYPE_TIMESTAMPFREQ,
    };

    class Query
    {
    public:
        Query(D3DDDIQUERYTYPE queryType);

        static FORCEINLINE HANDLE GetHandleFromQuery(Query* pQuery){ return static_cast<HANDLE>(pQuery); }
        static FORCEINLINE Query* GetQueryFromHandle(HANDLE hQuery){ return static_cast<Query*>(hQuery); }

        HRESULT Init(Device& device);
        HRESULT Issue(Device& device, D3DDDI_ISSUEQUERYFLAGS flags);
        HRESULT GetData(Device& device, VOID* pData);

    private:
        D3DDDIQUERYTYPE m_type;

        std::unique_ptr<D3D12TranslationLayer::Async> m_pUnderlyingQuery;

        static const UINT64 m_cUnitializedFenceValue = _UI64_MAX;
        UINT64 m_eventFenceValue;
    };
};
```

`include/9on12Registry.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#pragma once

namespace D3D9on12
{
    namespace RegistryKeys
    {
        static const LPCTSTR g_cRegKeyPath = __TEXT("Software\\Microsoft\\Direct3D\\Direct3D9on12");

        static const LPCSTR g_cDebugLayerEnabledKey = "UseDebugLayer";
        static const LPCSTR g_cBreakOnLoadKey = "BreakOnLoad";
        static const LPCSTR g_cEnableDDISpewKey = "EnableDDISpew";
        static const LPCSTR g_cBreakOnMissingDDI = "BreakOnMissingDDI";
        static const LPCSTR g_cBreakOnInvalidArg = "BreakOnInvalidArg";
        static const LPCSTR g_cSpewDXGIFormatWarnings = "SpewDXGIFormatWarnings";
        static const LPCSTR g_cBreakOnDXGIFormatWarnings = "BreakOnDXGIFormatWarnings";
        static const LPCSTR g_cSpewPerformanceWarnings = "SpewPerformanceWarnings";
        static const LPCSTR g_cSpewConvertedShaders = "SpewConvertedShaders";
        static const LPCSTR g_cSpewD3D9Shaders = "SpewD3D9Shaders";
        static const LPCSTR g_cDebugRedPixelShader = "DebugRedPixelShader";
        static const LPCSTR g_cDebugPassThroughVertexShader = "DebugPassThroughVertexShader";
        static const LPCSTR g_cValidateShaders = "ValidateShaders";
        static const LPCSTR g_cSingleThread = "Singlethread";
        static const LPCSTR g_cPresentWithDummyWindow = "PresentWithDummyWindow";
        static const LPCSTR g_cAnythingTimes0Equals0 = "AnythingTimes0Equals0";
        static const LPCSTR g_cPSOCacheTrimLimitSize = "PSOCacheTrimLimitSize";
        static const LPCSTR g_cPSOCacheTrimLimitAge = "PSOCacheTrimLimitAge";
        static const LPCSTR g_cMaxAllocatedUploadHeapSpacePerCommandList = "MaxAllocatedUploadHeapSpacePerCommandList";
        static const LPCSTR g_cMaxSRVHeapSize = "MaxSRVHeapSize";
        static const LPCSTR g_cBufferPoolTrimThreshold = "BufferPoolTrimThreshold"; // Must be in the range 5-100 to be used by the translation layer. If there is a compat shim, will take the lesser of the two values
        static const LPCSTR g_cLockDiscardOptimization = "LockDiscardOptimization";
    };

    static DWORD CheckRegistryKeyDWORD(LPCSTR key, DWORD defaultValue = 0)
    {
        DWORD keyValue = defaultValue;
        HKEY hKey = {};

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, RegistryKeys::g_cRegKeyPath, 0, KEY_READ, &hKey))
        {
            DWORD value = 0, valueSize = sizeof(DWORD);
            LONG result = RegQueryValueEx(hKey, key, NULL, NULL, (LPBYTE)&value, &valueSize);
            RegCloseKey(hKey);
            if (result == ERROR_SUCCESS)
            {
                keyValue = value;
            }
        }
        return keyValue;
    }

    static bool CheckRegistryKey(LPCSTR key, bool defaultValue = false)
    {
        bool keyEnabled = defaultValue;
        HKEY hKey = {};

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, RegistryKeys::g_cRegKeyPath, 0, KEY_READ, &hKey))
        {
            DWORD value = 0, valueSize = sizeof(DWORD);
            LONG result = RegQueryValueEx(hKey, key, NULL, NULL, (LPBYTE)&value, &valueSize);
            RegCloseKey(hKey);
            if (result == ERROR_SUCCESS)
            {
                keyEnabled = value != 0;
            } 
        }
        return keyEnabled;
    }

    //Some regkey options will still result in branches and overhead
    //so only enable them in debug mode.
    static bool CheckRegistryKeyOnDebug(LPCSTR key)
    {
#if DBG
        return CheckRegistryKey(key);
#else
        UNREFERENCED_PARAMETER(key);
        return false;
#endif
    }

    namespace RegistryConstants
    {
        /* Debug Keys */
        static const bool g_cEnableDDISpew = CheckRegistryKeyOnDebug(RegistryKeys::g_cEnableDDISpewKey);
        static const bool g_cBreakOnMissingDDI = CheckRegistryKeyOnDebug(RegistryKeys::g_cBreakOnMissingDDI);
        static const bool g_cCheckOnInvalidArg = CheckRegistryKeyOnDebug(RegistryKeys::g_cBreakOnInvalidArg);
        static const bool g_cSpewDXGIFormatWarnings = CheckRegistryKeyOnDebug(RegistryKeys::g_cSpewDXGIFormatWarnings);
        static const bool g_cAssertDXGIFormatWarnings = CheckRegistryKeyOnDebug(RegistryKeys::g_cBreakOnDXGIFormatWarnings);
        static const bool g_cSpewPerformanceWarnings = CheckRegistryKeyOnDebug(RegistryKeys::g_cSpewPerformanceWarnings);
        static const bool g_cSpewConvertedShaders = CheckRegistryKeyOnDebug(RegistryKeys::g_cSpewConvertedShaders);
        static const bool g_cSpewD3D9Shaders = CheckRegistryKeyOnDebug(RegistryKeys::g_cSpewD3D9Shaders);
        static const bool g_cDebugRedPixelShader = CheckRegistryKeyOnDebug(RegistryKeys::g_cDebugRedPixelShader);
        static const bool g_cDebugPassThroughVertexShader = CheckRegistryKeyOnDebug(RegistryKeys::g_cDebugPassThroughVertexShader);
        static const bool g_cValidateShaders = CheckRegistryKeyOnDebug(RegistryKeys::g_cValidateShaders);

        /* Keys that work on Release as well*/
        static const bool g_cAnythingTimes0Equals0 = CheckRegistryKey(RegistryKeys::g_cAnythingTimes0Equals0);
        static const bool g_cUseDebugLayer = CheckRegistryKey(RegistryKeys::g_cDebugLayerEnabledKey);
        static const bool g_cBreakOnLoad = CheckRegistryKey(RegistryKeys::g_cBreakOnLoadKey);
        static const bool g_cSingleThread = CheckRegistryKey(RegistryKeys::g_cSingleThread);  
        static const DWORD g_cPSOCacheTrimLimitSize = CheckRegistryKeyDWORD(RegistryKeys::g_cPSOCacheTrimLimitSize, MAXDWORD);
        static const DWORD g_cPSOCacheTrimLimitAge = CheckRegistryKeyDWORD(RegistryKeys::g_cPSOCacheTrimLimitAge, MAXDWORD);
        static const DWORD g_cMaxAllocatedUploadHeapSpacePerCommandList = CheckRegistryKeyDWORD(RegistryKeys::g_cMaxAllocatedUploadHeapSpacePerCommandList, MAXDWORD);
        static const DWORD g_cMaxSRVHeapSize = CheckRegistryKeyDWORD(RegistryKeys::g_cMaxSRVHeapSize, MAXDWORD);
        static const DWORD g_cBufferPoolTrimThreshold = CheckRegistryKeyDWORD(RegistryKeys::g_cBufferPoolTrimThreshold, MAXDWORD);
        static const bool g_cLockDiscardOptimization = CheckRegistryKeyDWORD(RegistryKeys::g_cLockDiscardOptimization, 1);
    };
};
```

`include/9on12Resource.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#pragma once

namespace D3D9on12
{
    class Device; // Forward Declaration
    class Resource;
    const HANDLE NULL_HANDLE = (HANDLE)1;

    struct ResourceCopyArgs
    {
        ResourceCopyArgs(Resource& destination, Resource& source);
        void AsBufferBlit(UINT dstOffset, D3DDDIRANGE srcRange);
        void AsTextureBlit(const POINT &dstPoint, const RECT &srcRect, UINT cubeFace = UINT_MAX);
        void AsSubresourceBlit(UINT dstSubresourceIndex, UINT srcSubresourceIndex, CONST RECT* pDstRect = nullptr, CONST RECT* pSrcRect = nullptr);
        void AsStretchBlit(UINT dstSubresourceIndex, UINT srcSubresourceIndex, CONST RECT* pDstRect = nullptr, CONST RECT* pSrcRect = nullptr);
        void AsVolumeBlit(UINT dstX, UINT dstY, UINT dstZ, const D3D12_BOX &srcBox);
        bool IsBufferBlit() const;

        ResourceCopyArgs GetSubArgs(UINT arrayLevel, UINT sourceMipLevel, UINT destinationMipLevel) const;

        // Align the source box and destination to meet Block compressed and
        // Planar requirements
        void AlignCopyDimensions();

        // ClipSourceBox to respect the src and dst resource's dimensions
        void ClipSourceBox(UINT sourceMipLevel, UINT destinationMipLevel);

        UINT m_sourceSubresourceIndex;
        UINT m_destinationSubresourceIndex;
        UINT m_cubeFace;
        UINT m_numSubresources;
        bool m_allSubresources;
        bool m_mipsAlreadyExpanded;

        UINT m_destinationX, m_destinationY, m_destinationZ;
        D3D12_BOX m_sourceBox;
        bool m_dimensionsCoverEntireResource;

        RECT m_stretchSource;
        RECT m_stretchDestination;
        bool m_isStretchCopy;

        Resource& m_destination;
        Resource& m_source;

        BOOL m_EnableAlpha;
    };

    struct LockRange
    {
        LockRange(const D3DDDIARG_LOCKASYNC &lockArgs)
        {
            // Regardless of what union member is initialized, Box should cover it since it's the biggest struct
            Box = lockArgs.Box;
        }

        LockRange(const D3DDDIARG_LOCK &lockArgs)
        {
            // Regardless of what union member is initialized, Box should cover it since it's the biggest struct
            Box = lockArgs.Box;
        }

        union
        {
            D3DDDIRANGE     Range;              // in: range being locked
            RECT            Area;               // in: area being locked
            D3DDDIBOX       Box;                // in: volume being locked
        };
    };

    static UINT64 g_globalResourceID = 0;

    static const D3D12_DSV_FLAGS g_cPossibleDepthStencilStates[] = 
    {
        D3D12_DSV_FLAG_NONE,
        D3D12_DSV_FLAG_READ_ONLY_DEPTH,
        D3D12_DSV_FLAG_READ_ONLY_STENCIL,
         (D3D12_DSV_FLAGS)COMPILETIME_OR_2FLAGS(D3D12_DSV_FLAG_READ_ONLY_DEPTH, D3D12_DSV_FLAG_READ_ONLY_STENCIL),
    };

    class Resource
    {
    public:
        Resource();

        Resource(HANDLE runtimeHandle, Device* parent);
        virtual ~Resource();

        HRESULT Init(_In_ D3DDDIARG_CREATERESOURCE2& createArgs);
        HRESULT Init(UINT width, UINT height, D3DFORMAT format, D3DDDI_RESOURCEFLAGS resourceFlags, UINT mipLevels = 1, UINT depth = 1, UINT arraySize = 1, bool DoNotCreateAsTypelessResource = false);
        HRESULT Init(unique_comptr<D3D12TranslationLayer::Resource> pResource, D3D9ON12_OPEN_RESOURCE_ARGS *pD3d9on12Args, bool DoNotCreateAsTypelessResource = false);

        HRESULT OpenResource(D3DKMT_HANDLE kmtHandle, void *pPrivateResourceDriverData, UINT privateResourceDriverDataSize, D3D9ON12_OPEN_RESOURCE_ARGS *pD3d9on12Args);

        D3D12TranslationLayer::Resource *GetUnderlyingResource() { return m_pResource.get(); }

        ID3D12Resource &GetResource();
        D3D12TranslationLayer::ResourceCreationArgs &GetTranslationLayerCreateArgs() { return m_TranslationLayerCreateArgs; }
        const D3D12_RESOURCE_DESC &GetDesc() { return m_desc; };
        DXGI_FORMAT GetViewFormat(bool sRGBEnabled);
        D3DFORMAT GetD3DFormat() { return m_dx9Format; }
        const D3D12_RESOURCE_DESC &GetLogicalDesc() { return m_logicalDesc; };
        HANDLE GetRuntimeHandle() { return m_runtimeHandle; }

        HRESULT Lock(Device &device,
            _In_ UINT subresourceIndex,
            _In_ D3DDDI_LOCKFLAGS flags,
            _In_ LockRange lock,
            _In_ bool bAsyncLock,
            _Out_ VOID* &pSurfData,
            _Out_ UINT &pitch,
            _Out_ UINT &slicePitch,
            _Out_opt_ HANDLE *phCookie = nullptr);

        void Unlock(Device &device, 
            UINT subresourceIndex,
            D3DDDI_UNLOCKFLAGS flags,
            bool bAsyncUnlock);

        HRESULT Rename(Device& device, CONST D3DDDIARG_RENAME& arg);

        HRESULT GenerateMips(D3DDDITEXTUREFILTERTYPE filterType);

        HRESULT PreBind();

        static FORCEINLINE HANDLE GetHandleFromResource(Resource* pResource) { return (pResource) ? static_cast<HANDLE>(pResource) : NULL_HANDLE; }
        static FORCEINLINE Resource* GetResourceFromHandle(HANDLE hResource) { return (hResource != NULL_HANDLE) ? static_cast<Resource*>(hResource) : nullptr; }

        HRESULT Clear(_In_ UINT SubResourceIndex, _In_ const RECT* dstRects, _In_ UINT numRects, _In_ D3DCOLOR  Color);
        void ClearAllPlanesInArraySlice(_In_ UINT ArrayIndex, _In_ const RECT* dstRects, _In_ UINT numRects, _In_ D3DCOLOR  Color);
        HRESULT ClearDepthStencil(UINT flag, _In_ const RECT* dstRects, _In_ UINT numRects, float depthValue, UINT stencilValue);

        D3D12TranslationLayer::RTV* GetRenderTargetView(UINT subresourceIndex, bool srgbEnabled = false);
        D3D12TranslationLayer::DSV* &GetDepthStencilView(D3D12_DSV_FLAGS flags);
        enum ShaderResourceViewFlags
        {
            None = 0x0,
            SRGBEnabled = 0x1,
            DisableMips = 0x2,
            NumPermutations = 4
        };
        D3D12TranslationLayer::SRV* GetShaderResourceView(DWORD flags = ShaderResourceViewFlags::None);


        // Gets a resource that has all the same contents as this resource
        // but is a "plain" DX12 resource (single sample, no CPU access, optionally 
        // not as a TypelessResource) This is helpful when we need to pass a resource 
        // into an API that only expects "plain" DX12 resources. Some examples:
        // * Binding System Memory as an SRV
        // * A resource that's the source of a DX12 internal blt present.
        virtual Resource *GetBackingPlainResource(bool bDoNotCreateAsTypelessResource = false);
        
        // Returns a resource that has the current contents of this resource
        // copied into a readback heap. Generally expected to be a short-lived
        // resource only used for reading the data on the CPU
        unique_comptr<D3D12TranslationLayer::Resource> GetStagingCopy();
        
        ShaderConv::TEXTURETYPE GetShaderResourceTextureType();
        HANDLE GetSharedGDIHandle();
        virtual HANDLE CreateSharedNTHandle(SECURITY_DESCRIPTOR *pSD);

        UINT ConvertAppSubresourceToDX12Subresource(UINT index);

        void ConvertAppSubresourceToDX12SubresourceIndices(
            _In_ UINT subresourceIndex,
            _Out_writes_(MAX_PLANES) UINT *pSubresourceIndices,
            _Out_range_(0, MAX_PLANES) UINT &pPlaneCountToMap,
            bool bMipAlreadyExpanded = false);

        UINT ConvertAppSubresourceToDX12SubresourceInternal(UINT appIndex, UINT planeIndex, bool bMipAlreadyExpanded);

        UINT GetNumSubresources() { return m_numSubresources; }
        UINT GetNumAppVisibleMips() { return m_mipMapsHiddenFromApp ? 1 : GetLogicalDesc().MipLevels; }
        bool IsCubeMap() const { return m_cubeMap; }
        D3D12_PLACED_SUBRESOURCE_FOOTPRINT &GetSubresourceFootprint(UINT subresource);

        UINT8 GetArraySize();
        UINT GetMipLevelFromSubresourceIndex(UINT subresourceIndex);
        UINT8 GetArraySliceFromSubresourceIndex(UINT subresourceIndex);
        bool IsSystemMemory() { return m_isD3D9SystemMemoryPool; }
        bool IsAlphaChannelDisabled() { return m_DisableAlphaChannel; }
        bool NeedsSwapRBOutputChannels() { return FormatRequiresSwappedRBChannels(m_dx9Format); }
        bool IsEligibleForHardwareShadowMapping() { return m_compatOptions.m_isEligibleForHardwareShadowMapping; }
        bool IsResident() { return GetUnderlyingResource()->IsResident(); }

        static void CopyPrologue(Device& device, ResourceCopyArgs& args);
        static void CopyResource(Device& device, ResourceCopyArgs& args);
        static void CopySubResource(Device& device, ResourceCopyArgs& args);
        static void CopyToSystemMemoryResource(Device& device, ResourceCopyArgs& args);
        static void CopyMatchingMipLevels(Device& device, ResourceCopyArgs& args);

        DXGI_FORMAT DepthStencilViewFormat() { return m_dsvFormat; }

        UINT64 ID(){ return m_ID; }

        void* GetSystemMemoryBase() { return m_appLinearRepresentation.m_systemData[0].pData; }

        // ---- Triangle fan index buffer cache methods ----        
        void GetTriFanIB(_Out_ InputBuffer& convertedIB, _In_ UINT baseIndexLocation, _In_ UINT indexCount, _In_ UINT ibStride);
        bool IsTriangleFanIBCacheDirty(UINT baseIndexLocation);


        Device* GetParent() { return m_pParentDevice; }
    private:
        class BindingTracker
        {
        public:
            void Bind(UINT bindIndex) { m_boundIndices.push_back(bindIndex); }
            void Unbind(UINT bindIndex)
            {
                // Doing an inefficient O(N) delete, betting that this is generally okay
                // because a resource should generally only be bound at a couple of places
                // at any given time.
                if (m_boundIndices.size() > 5)
                {
                    INEFFICIENT_UNBINDING_ARRAY_DELETION();
                }

                for (size_t i = 0; i < m_boundIndices.size(); i++)
                {
                    if (bindIndex == m_boundIndices[i])
                    {
                        m_boundIndices.erase(m_boundIndices.begin() + i);
                        return;
                    }
                }
            }

            bool IsBound() { return m_boundIndices.size() > 0; }
            const std::vector<UINT> &GetBindingIndices() { return m_boundIndices; }
        private:
            std::vector<UINT> m_boundIndices;
        };

        BindingTracker m_SRVBindingTracker;
        BindingTracker m_RTVBindingTracker;
        BindingTracker m_DSVBindingTracker;
        BindingTracker m_VBBindingTracker;
        BindingTracker m_IBBindingTracker;
    public:
        BindingTracker &GetRTVBindingTracker() { return m_RTVBindingTracker; }
        BindingTracker &GetSRVBindingTracker() { return m_SRVBindingTracker; }
        BindingTracker &GetDSVBindingTracker() { return m_DSVBindingTracker; }
        BindingTracker &GetVBBindingTracker() { return m_VBBindingTracker; }
        BindingTracker &GetIBBindingTracker() { return m_IBBindingTracker; }

        D3D12_SHADER_RESOURCE_VIEW_DESC GetShaderResourceViewDescForArraySlice(UINT8 arraySlice, UINT8 arraySize);
        UINT GetVidPnSourceId() const { return m_VidPnSourceId; }

    protected:
        virtual void CreateUnderlyingResource( D3D12TranslationLayer::ResourceCreationArgs& underlyingResourceCreateArgs, _Inout_ D3DDDIARG_CREATERESOURCE2& createArgs );
        void CreateUnderlyingResource( D3D12TranslationLayer::ResourceCreationArgs& createArgs );
        Resource* m_pBackingShaderResource;

    private:
        void UpdateTriangleFanIBCache(InputBuffer& newIBToStore, UINT baseIndexLocation);
        // Buffer used to cache conversion between triangle fan and triangle list topologies. This allows us to avoid maping(and blocking the gpu) the index buffer in each draw call.
        // This stores the TRIANGLE LIST CONVERTED INDEX BUFFER, actually enabling us to avoid the conversion as well.
        struct TriangleFanIBCache {
            TriangleFanIBCache() : 
                m_baseIndexOffsetInBytes(0), 
                m_dirtyFlag(true)
            {}

            InputBuffer m_TriangleFanConvertedTriangleListIndexBuffer;
            UINT m_baseIndexOffsetInBytes;
            bool m_dirtyFlag;
        } m_TriFanIBCache;

        void NotifyResourceChanged();
        bool IsSRGBCompatibleTexture();

        HRESULT InitInternal(
            _In_ D3DDDIARG_CREATERESOURCE2& createArgs, 
            bool onlyFirstSurfInfoInitialized, 
            unique_comptr<D3D12TranslationLayer::Resource> pAlreadyCreatedResource = {},
            bool DoNotCreateAsTypelessResource = false);

        HRESULT ClearResourceWithNoRenderTarget(_In_ UINT SubResourceIndex, _In_ const RECT* dstRects, _In_ UINT numRects, _In_ D3DCOLOR  Color);
        void CreateRenderTargetViews(DXGI_FORMAT rtvFormat, bool GenerateSRGBRTV);
        void CreateDepthStencilViews();
        void CreateVideoDecoderOutputViews();
        void CreateVideoProcessorOutputViews();

        static void InitializeSRVDescFormatAndShaderComponentMapping(_In_ D3DFORMAT d3dFormat, _Out_ D3D12_SHADER_RESOURCE_VIEW_DESC &desc, bool disableAlphaChannel);
        D3D12_SHADER_RESOURCE_VIEW_DESC GetShaderResourceViewDesc();
        D3D12TranslationLayer::SRV * CreateShaderResourceView(ShaderResourceViewFlags flag);

        UINT64 m_ID;

        Device* m_pParentDevice;

        D3D12TranslationLayer::D3D12ResourceSuballocation m_LastRenamedResource;

        unique_unbind_resourceptr m_pResource;

        HANDLE m_runtimeHandle;

        bool m_DisableAlphaChannel = false;
        bool m_IsLockable;
        UINT m_numSubresources;
        UINT8 m_numArrayLevels;
        UINT8 m_NonOpaquePlaneCount;
        UINT64 m_totalSize;
        bool m_mipMapsHiddenFromApp;
        bool m_cubeMap;

#if DBG
        D3DDDIARG_CREATERESOURCE2 m_d3d9Desc;
#endif
        D3D12_RESOURCE_DESC m_desc;
        D3DFORMAT m_dx9Format;
        DXGI_FORMAT m_dsvFormat;
        DXGI_FORMAT m_ViewFormat;
        D3D12_RESOURCE_DESC m_logicalDesc;
        UINT m_CpuAccessFlags;
        UINT m_VidPnSourceId;

        D3D12TranslationLayer::ResourceCreationArgs m_TranslationLayerCreateArgs;

        std::vector<std::unique_ptr<D3D12TranslationLayer::RTV>> m_renderTargetViews;
        std::vector<std::unique_ptr<D3D12TranslationLayer::RTV>> m_SRGBRenderTargetViews;

        byte m_depthStencilViewSpace[sizeof(D3D12TranslationLayer::DSV) * _countof(g_cPossibleDepthStencilStates)];
        D3D12TranslationLayer::DSV* m_pDepthStencilViews[_countof(g_cPossibleDepthStencilStates)];

        std::unique_ptr<D3D12TranslationLayer::SRV> m_shaderResourceViews[ShaderResourceViewFlags::NumPermutations];

        std::vector<std::unique_ptr<D3D12TranslationLayer::VDOV>> m_videoDecoderOutputViews;
        std::vector<std::unique_ptr<D3D12TranslationLayer::VPOV>> m_videoProcessorOutputViews;

        ShaderConv::TEXTURETYPE m_srvTextureType;

        bool m_isDecodeCompressedBuffer;
        bool m_isD3D9SystemMemoryPool; //System memory resources need to be updated at bind time
        

        struct LockData
        {
            LockData() : m_LockCount(0) {}

            D3DDDI_LOCKFLAGS m_Flags;
            D3D12_BOX m_Box;
            UINT m_LockCount;
        };

        std::vector<LockData> m_lockData;

        // Information which describes how the app 
        // represents the resource in system memory
        struct AppLinearRepresentation
        {
            std::vector<D3D12_MEMCPY_DEST> m_systemData;
        };

        // Information which describes how the resource
        // will be represented as a linear buffer for each
        // subresource
        struct PhysicalLinearRepresentation
        {
            std::vector<D3D12_PLACED_SUBRESOURCE_FOOTPRINT> m_footprints;
            std::vector<UINT64> m_rowPitces;
            std::vector<UINT> m_numRows;
        };

        AppLinearRepresentation m_appLinearRepresentation;
        PhysicalLinearRepresentation m_physicalLinearRepresentation;

        // Contains information about possible runtime extensions e.g. Hardware shadow maps.
        struct ResourceCompatibilityOptions
        {
            ResourceCompatibilityOptions() : m_isEligibleForHardwareShadowMapping(false){};

            void Init(D3DFORMAT format);

            bool m_isEligibleForHardwareShadowMapping;
        };

        ResourceCompatibilityOptions m_compatOptions;

        class CreateTextureArgHelper
        {
        public:

            CreateTextureArgHelper(UINT width, UINT height, DXGI_FORMAT format, D3DDDI_RESOURCEFLAGS resourceFlags, UINT mipLevels = 1, UINT depth = 1, UINT arraySize = 1) :
                CreateTextureArgHelper(width, height, ConvertFromDXGIFormatToD3DDDIFormat(format), resourceFlags, mipLevels, depth, arraySize) {}
                
            CreateTextureArgHelper(UINT width, UINT height, D3DDDIFORMAT format, D3DDDI_RESOURCEFLAGS resourceFlags, UINT mipLevels = 1, UINT depth = 1, UINT arraySize = 1)
            {
                // Arrays of 3D textures are not allowed
                Check9on12(!(depth > 1 && arraySize > 1));
                const UINT surfCount = mipLevels * arraySize;

                // Don't waste time calculating the height and width for other mip levels, 9on12 doesn't need that information
                m_surfaceInfo = {};
                m_surfaceInfo.Height = static_cast<UINT>(height);
                m_surfaceInfo.Width = static_cast<UINT>(width);
                m_surfaceInfo.Depth = depth;

                m_createArg = {};
                m_createArg.Flags = resourceFlags;
                m_createArg.MipLevels = mipLevels;
                m_createArg.MultisampleQuality = 0;
                m_createArg.Pool = D3DDDIPOOL_LOCALVIDMEM;
                m_createArg.MultisampleType = D3DDDIMULTISAMPLE_NONE;
                m_createArg.SurfCount = surfCount;
                m_createArg.pSurfList = &m_surfaceInfo;
                m_createArg.Format = format;
            }


            _D3DDDIARG_CREATERESOURCE2 &GetCreateArgs()
            {
                return m_createArg;
            }

        private:

            _D3DDDI_SURFACEINFO m_surfaceInfo;
            _D3DDDIARG_CREATERESOURCE2 m_createArg;
        };
    };
};

```

`include/9on12Shader.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#pragma once

#include <DxbcBuilder.hpp>

typedef struct _D3D10_INTERNALSHADER_SIGNATURE
{
    UINT Parameters;      // Number of parameters
    UINT ParameterInfo;   // Offset to D3D10_INTERNALSHADER_PARAMETER[Parameters]
} D3D10_INTERNALSHADER_SIGNATURE, *LPD3D10_INTERNALSHADER_SIGNATURE;

typedef struct _D3D11_INTERNALSHADER_PARAMETER_11_1
{
    UINT Stream;                                    // Stream index (parameters must appear in non-decreasing stream order)
    UINT SemanticName;                              // Offset to LPCSTR
    UINT SemanticIndex;                             // Semantic Index
    D3D10_NAME SystemValue;                         // Internally defined enumeration
    D3D10_REGISTER_COMPONENT_TYPE  ComponentType;   // Type of  of bits
    UINT Register;                                  // Register Index
    BYTE Mask;                                      // Combination of D3D10_COMPONENT_MASK values

    // The following unioned fields, NeverWrites_Mask and AlwaysReads_Mask, are exclusively used for 
    // output signatures or input signatures, respectively.
    //
    // For an output signature, NeverWrites_Mask indicates that the shader the signature belongs to never 
    // writes to the masked components of the output register.  Meaningful bits are the ones set in Mask above.
    //
    // For an input signature, AlwaysReads_Mask indicates that the shader the signature belongs to always
    // reads the masked components of the input register.  Meaningful bits are the ones set in the Mask above.
    //
    // This allows many shaders to share similar signatures even though some of them may not happen to use
    // all of the inputs/outputs - something which may not be obvious when authored.  The NeverWrites_Mask
    // and AlwaysReads_Mask can be checked in a debug layer at runtime for the one interesting case: that a 
    // shader that always reads a value is fed by a shader that always writes it.  Cases where shaders may
    // read values or may not cannot be validated unfortunately.  
    //
    // In scenarios where a signature is being passed around standalone (so it isn't tied to input or output 
    // of a given shader), this union can be zeroed out in the absence of more information.  This effectively
    // forces off linkage validation errors with the signature, since if interpreted as a input or output signature
    // somehow, since the meaning on output would be "everything is always written" and on input it would be 
    // "nothing is always read".
    union
    {
        BYTE NeverWrites_Mask;  // For an output signature, the shader the signature belongs to never 
                                // writes the masked components of the output register.
        BYTE AlwaysReads_Mask;  // For an input signature, the shader the signature belongs to always
                                // reads the masked components of the input register.
    };

    D3D_MIN_PRECISION MinPrecision;                 // Minimum precision of input/output data
} D3D11_INTERNALSHADER_PARAMETER_11_1, *LPD3D11_INTERNALSHADER_PARAMETER_11_1;

namespace D3D9on12
{
    struct SizedBuffer
    {
        SizedBuffer() : m_ptr(nullptr), m_size(0) {};
        SizedBuffer(byte* ptr, size_t size) : m_ptr(ptr), m_size(size) {};
        SizedBuffer(void* ptr, size_t size) : m_ptr((byte*)ptr), m_size(size) {};

        byte* m_ptr;
        size_t m_size;
    };

    class InputLayout;
    class DXBCInputSignatureBuilder
    {
    public:
        DXBCInputSignatureBuilder() : m_dataSize(0) {}

        // Semantic Names are passed in separately in pNameList so that they can be serialized, therefore the
        // SemanticName field in pInputParameters can be left uninitialized
        HRESULT SetParameters(_D3D11_INTERNALSHADER_PARAMETER_11_1 *pInputParameters, std::string *pNameList, UINT numParameters);

        // Data valid until DXBCInputSignatureBuilder goes out of scope;
        SizedBuffer GetData() { return SizedBuffer(m_pData.get(), m_dataSize);}

    private:
        std::vector<_D3D11_INTERNALSHADER_PARAMETER_11_1> m_pParameters;
        std::unique_ptr<byte[]> m_pData;
        UINT m_dataSize;
    };

    class Shader;
    struct D3D12Shader
    {
        D3D12Shader(Shader *pD3D9ParentShader) : 
            m_pD3D9ParentShader(pD3D9ParentShader), m_pUnderlying(nullptr), m_floatConstsUsed(0), m_intConstsUsed(0), m_boolConstsUsed(0){};
        // These point to their corresponding positions in the 
        // DXBC blob preamble of the m_byteCode member

        HRESULT Create(Device &device, std::unique_ptr<BYTE[]> byteCode, SIZE_T bytecodeSize);
        void Destroy();
        SizedBuffer m_inputSignature;
        SizedBuffer m_outputSignature;

        _Out_ ShaderConv::ShaderConsts m_inlineConsts[3];

        UINT m_floatConstsUsed;
        UINT m_intConstsUsed;
        UINT m_boolConstsUsed;

        D3D12TranslationLayer::Shader* GetUnderlying() { return m_pUnderlying; }
        Shader *GetD3D9ParentShader() const { return m_pD3D9ParentShader; }
    protected:
        Shader *m_pD3D9ParentShader;
        byte m_pUnderlyingSpace[sizeof(D3D12TranslationLayer::Shader)];
        D3D12TranslationLayer::Shader *m_pUnderlying;
    };

    struct D3D12VertexShader : public D3D12Shader
    {
        D3D12VertexShader(Shader *pD3D9ParentShader = nullptr) : m_vsOutputDecls(), D3D12Shader(pD3D9ParentShader){};

        std::vector<D3D12_INPUT_ELEMENT_DESC> m_inputElementDescs;
        ShaderConv::VSOutputDecls m_vsOutputDecls;
    };

    struct D3D12GeometryShader : public D3D12Shader
    { 
        D3D12GeometryShader(Shader *pD3D9ParentShader = nullptr) : D3D12Shader(pD3D9ParentShader){}; 

        ShaderConv::VSOutputDecls m_gsOutputDecls;
    };

    struct D3D12PixelShader : public D3D12Shader
    { 
        D3D12PixelShader(Shader *pD3D9ParentShader = nullptr) : D3D12Shader(pD3D9ParentShader){}; 
    };

    class Shader : public PipelineStateCacheKeyComponent
    {
    public:
        Shader(Device& device, _In_ CONST byte& byteCode, _In_ size_t byteCodeLength, WeakHash hash);
        Shader(Device& device);
        ~Shader();

        void AddRef() { ++m_refCount; }
        UINT Release() { return --m_refCount; }

        static FORCEINLINE HANDLE GetHandleFromShader(Shader* pShader){ return static_cast<HANDLE>(pShader); }
        static FORCEINLINE Shader* GetShaderFromHandle(HANDLE hShader){ return static_cast<Shader*>(hShader); }

        WeakHash GetHashForLegacyByteCode() { return m_legacyCodeHash; }
        const SizedBuffer& GetLegacyByteCode() { return m_d3d9ByteCode; }

        HRESULT ShaderConversionPrologue();
    protected:
        static void GenerateSignatureFromVSOutput(ShaderConv::VSOutputDecls& vsOut, DXBCInputSignatureBuilder& signature);

        HRESULT GenerateFinalD3D12Shader(SizedBuffer& upgradedByteCode, _Out_ D3D12Shader& d3d12ShaderOut, SizedBuffer& inputSignature, SizedBuffer& outputSignature);

        static HRESULT DisassembleShader(CComPtr<ID3DBlob> &pBlob, const D3D12_SHADER_BYTECODE &shaderByteCode);
        static HRESULT ValidateShader(const D3D12_SHADER_BYTECODE &shaderByteCode);

        UINT m_refCount = 1;
        SizedBuffer m_d3d9ByteCode;

        const WeakHash m_legacyCodeHash;

        CDXBCBuilder m_DXBCBuilder;

        Device& m_parentDevice;

        // TODO: The map looks ups require us to make deep copies of the state. Technically
        //       we only need references to these objects during a map.find(key) (so that it 
        //       can do comparisons during a hash collision). If this path turns out to be hot 
        //       we should rethink this and possibly use our own map implementation.
        struct DerivedShaderKey
        {
            DerivedShaderKey(const ShaderConv::RasterStates& rasterStates) : m_hash(0)
            {
                //memcpy because assignment can add alignment which can throw off hashing
                memcpy(&m_rasterStates, &rasterStates, sizeof(m_rasterStates));
            };

            ShaderConv::RasterStates m_rasterStates;
            size_t m_hash;

            template<typename KeyType>
            struct Hasher
            {
                std::size_t operator()(KeyType const& other) const
                {
                    return other.m_hash;
                }
            };
        };
    };

    class VertexShader : public Shader
    {
    public:

        VertexShader(Device& parentDevice, _In_ CONST byte& byteCode, _In_ size_t byteCodeLength, WeakHash hash);
        VertexShader(Device& parentDevice);
        ~VertexShader();

        D3D12VertexShader& GetD3D12Shader(const ShaderConv::RasterStates &rasterStates, InputLayout& inputLayout);

        // Get the shader for pre-Transformed and Lit vertices (essentially a pass through).
        D3D12VertexShader& GetD3D12ShaderForTL(InputLayout& inputLayout, const ShaderConv::RasterStates &rasterStates);

    private:

        HRESULT SetupInputSignaturesAndGetFinalCode(SizedBuffer& upgradedByteCode, ShaderConv::VSInputDecls& vsInputDecls, InputLayout* pInputLayout, _Out_ D3D12VertexShader& outputVS);

        struct DerivedVertexShaderKey : public DerivedShaderKey
        {
            // Hash in the constructor so that his key can be used several times efficiently
            DerivedVertexShaderKey(const ShaderConv::RasterStates& rasterStates, InputLayout& inputLayout, _In_reads_(MAX_VERTEX_STREAMS) UINT* streamFrequencies) : DerivedShaderKey(rasterStates)
            {
                //memcpy because assignment can add alignment which can throw off hashing
                memcpy(&m_inputLayoutHash, &inputLayout.GetHash(), sizeof(m_inputLayoutHash));
                memcpy(m_streamFrequencies, streamFrequencies, sizeof(m_streamFrequencies));

                WeakHash hash = HashData(&m_rasterStates, sizeof(m_rasterStates), m_inputLayoutHash);//Add the hash from the IL
                hash = HashData(streamFrequencies, sizeof(streamFrequencies), hash);
                m_hash = size_t(hash.m_data);
            };

            //Needs to be a deep copy as it's essentially a snapshot of the state at the time
            WeakHash m_inputLayoutHash;
            UINT     m_streamFrequencies[MAX_VERTEX_STREAMS];

            struct Comparator
            {
                bool operator()(const DerivedVertexShaderKey& a, const DerivedVertexShaderKey& b) const
                {
                    return memcmp(&a.m_rasterStates, &b.m_rasterStates, sizeof(a.m_rasterStates)) == 0 &&
                        memcmp(&a.m_streamFrequencies, &b.m_streamFrequencies, sizeof(a.m_streamFrequencies)) == 0 &&
                        a.m_inputLayoutHash == b.m_inputLayoutHash;
                }
            };
        };

        typedef std::unordered_map<DerivedVertexShaderKey, D3D12VertexShader, DerivedShaderKey::Hasher<DerivedVertexShaderKey>, DerivedVertexShaderKey::Comparator> MapType;
        MapType m_derivedShaders;
    };

    class GeometryShader : public Shader
    {
    public:
        GeometryShader(Device& parentDevice, _In_ CONST byte& byteCode, _In_ size_t byteCodeLength, WeakHash hash);
        GeometryShader(Device& parentDevice);
        ~GeometryShader();

        D3D12GeometryShader& GetD3D12Shader(D3D12VertexShader& currentVS, const ShaderConv::RasterStates& rasterStates);

    private:

        struct DerivedGeometryShaderKey : public DerivedShaderKey
        {
            // Hash in the constructor so that his key can be used several times efficiently
            DerivedGeometryShaderKey(const ShaderConv::RasterStates& rasterStates, ShaderConv::VSOutputDecls& vsOutDecls) : DerivedShaderKey(rasterStates)
            {
                //memcpy because assignment can add alignment which can throw off hashing
                memcpy(&m_vsOutDecls, &vsOutDecls, sizeof(m_vsOutDecls));

                WeakHash hash = HashData(&m_rasterStates, sizeof(m_rasterStates));
                hash = HashData(&m_vsOutDecls[0], m_vsOutDecls.GetSize() * sizeof(m_vsOutDecls[0]), hash);
                m_hash = size_t(hash.m_data);
            };

            //Needs to be a deep copy as it's essentially a snapshot of the state at the time
            ShaderConv::VSOutputDecls m_vsOutDecls;

            struct Comparator
            {
                bool operator()(const DerivedGeometryShaderKey& a, const DerivedGeometryShaderKey& b) const
                {
                    if (a.m_vsOutDecls.GetSize() != b.m_vsOutDecls.GetSize()) { return false; }

                    for (UINT i = 0; i < a.m_vsOutDecls.GetSize(); i++)
                    {
                        if (memcmp(&a.m_vsOutDecls[i], &b.m_vsOutDecls[i], sizeof(a.m_vsOutDecls[i])) != 0) { return false; }
                    }
                    return memcmp(&a.m_rasterStates, &b.m_rasterStates, sizeof(a.m_rasterStates)) == 0;
                }
            };
        };

        typedef std::unordered_map<DerivedGeometryShaderKey, D3D12GeometryShader, DerivedShaderKey::Hasher<DerivedGeometryShaderKey>, DerivedGeometryShaderKey::Comparator> MapType;
        MapType m_derivedShaders;
    };

    class PixelShader : public Shader
    {
    public:
        PixelShader(Device& parentDevice, _In_ CONST byte& byteCode, _In_ size_t byteCodeLength, WeakHash hash);
        ~PixelShader();

        D3D12PixelShader& GetD3D12Shader(ShaderConv::RasterStates rasterStates, const ShaderConv::VSOutputDecls& vsOutputDecls, D3D12Shader& inputShader);

    private:

        struct DerivedPixelShaderKey : public DerivedShaderKey
        {
            // Hash in the constructor so that his key can be used several times efficiently
            DerivedPixelShaderKey(const ShaderConv::RasterStates& rasterStates, ShaderConv::VSOutputDecls& vsOutDecls) : DerivedShaderKey(rasterStates)
            {
                //memcpy because assignment can add alignment which can throw off hashing
                memcpy(&m_vsOutDecls, &vsOutDecls, sizeof(m_vsOutDecls));
                
                WeakHash hash = HashData(&m_rasterStates, sizeof(m_rasterStates));
                hash = HashData(&m_vsOutDecls[0], m_vsOutDecls.GetSize() * sizeof(m_vsOutDecls[0]), hash);
                m_hash = size_t(hash.m_data);
            };

            //Needs to be a deep copy as it's essentially a snapshot of the state at the time
            ShaderConv::VSOutputDecls m_vsOutDecls;

            struct Comparator
            {
                bool operator()(const DerivedPixelShaderKey& a, const DerivedPixelShaderKey& b) const
                {
                    if (a.m_vsOutDecls.GetSize() != b.m_vsOutDecls.GetSize()) { return false; }

                    for (UINT i = 0; i < a.m_vsOutDecls.GetSize(); i++)
                    {
                        if (memcmp(&a.m_vsOutDecls[i], &b.m_vsOutDecls[i], sizeof(a.m_vsOutDecls[i])) != 0) { return false; }
                    }

                    return memcmp(&a.m_rasterStates, &b.m_rasterStates, sizeof(a.m_rasterStates)) == 0;
                }
            };
        };

        typedef std::unordered_map<DerivedPixelShaderKey, D3D12PixelShader, DerivedShaderKey::Hasher<DerivedPixelShaderKey>, DerivedPixelShaderKey::Comparator> MapType;
        MapType m_derivedShaders;
    };

    template<typename tupleType>
    struct less_than_key
    {
        inline bool operator() (const tupleType& struct1, const tupleType& struct2)
        {
            return (std::get<0>(struct1).Register < std::get<0>(struct2).Register);
        }
    };
};
```

`include/9on12SwapChain.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#pragma once

namespace D3D9on12
{
}
```

`include/9on12Util.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#pragma once
#include <intrin.h>

#if _M_AMD64
#define SSE4_CRC_INPUT_TYPE UINT64
#define SSE4_CRC_FUNCTION _mm_crc32_u64
#elif _M_IX86
#define SSE4_CRC_INPUT_TYPE UINT32
#define SSE4_CRC_FUNCTION _mm_crc32_u32
#endif

#pragma warning(disable: 4063) // Cases in a switch with values that don't belong to the enum

namespace D3D9on12
{
    static volatile long g_CommandID = 0;

    template <typename T> using unique_comptr = D3D12TranslationLayer::unique_comptr<T>;

    struct CleanupResourceBindingsAndRelease
    {
        void operator()(D3D12TranslationLayer::Resource*);
    };
    typedef D3D12TranslationLayer::unique_comptr<D3D12TranslationLayer::Resource,
        CleanupResourceBindingsAndRelease> unique_unbind_resourceptr;

    template<typename T>
    struct inline_destructor
    {
        void operator()(T *pT) const
        {
            pT->~T();
        }
    };

    class Result
    {
    public:
        enum Value : uint8_t
        {
            S_SUCCESS = 0x00,
            S_CHANGE = 0x01,
            E_FAILURE = 0x10,
            E_INVALID_ARG = 0x20
        };

        Result() = default;
        constexpr Result(Value result) : value(result) {}

        constexpr Result operator||(const Result result) { return result.value > value ? result : *this; }

        constexpr bool Succeeded() const { return value < Result::E_FAILURE; }
        constexpr bool Failed() const { return value >= Result::E_FAILURE; }
        constexpr bool operator==(Result other) const noexcept { return value == other.value; }
        constexpr bool operator!=(Result other) const noexcept { return value != other.value; }

        //Get the underlying enum value. This allows nice switch syntax without enabling implicit casting of Result to HRESULT
        constexpr Value AsEnum() const { return value; }
        //Explicit way of translating to HRESULT for communicating with parts of the codebase that haven't been migrated from HRESULT.
        constexpr HRESULT AsHresult() const 
        {
            switch (value)
            {
            case S_SUCCESS:
            case S_CHANGE:
                return S_OK;
            case E_FAILURE: return E_FAIL;
            case E_INVALID_ARG: return E_INVALIDARG;
            default:
                Check9on12(false);
                return E_ILLEGAL_STATE_CHANGE;
            }
        }

        /* Updates the result such that the higher valued result takes precedence */
        void Update(Result newResult)
        {
            if (newResult.value > value)
            {
                value = newResult.value;
            }
        }

    private:
        Value value;
    };

    //
    // Translates DXGI error codes to their D3D9 equivalents so that the
    // correct HRESULTs propagate to the D3D9 runtime.  Non-DXGI codes pass
    // through unchanged.
    //
    // Not an exhuastive list, but the ones most likely to be hit
    //
    inline HRESULT TranslateDxgiHrToD3D9(HRESULT hr)
    {
        switch (hr)
        {
        case DXGI_ERROR_DEVICE_REMOVED:         return D3DDDIERR_DEVICEREMOVED;
        case DXGI_ERROR_DEVICE_HUNG:            return D3DERR_DEVICEHUNG;
        case DXGI_ERROR_DEVICE_RESET:           return D3DERR_DEVICELOST;
        case DXGI_ERROR_DRIVER_INTERNAL_ERROR:  return D3DERR_DRIVERINTERNALERROR;
        case DXGI_ERROR_INVALID_CALL:           return D3DERR_DRIVERINTERNALERROR; // This is a driver error from the app's perspective as it means that 9on12 made an invalid call
        default:                                return hr;
        }
    }

#define D3D9on12_DDI_ENTRYPOINT_START(implemented) \
__pragma(warning(suppress:4127)) /* conditional is constant due to constant macro parameter(s) */ \
    if((implemented) == false && RegistryConstants::g_cBreakOnMissingDDI) \
    { \
        DebugBreak();\
    } \
    if(RegistryConstants::g_cEnableDDISpew)\
    {\
        PrintDebugMessage(std::string(std::string("Command ID: ") + std::to_string(InterlockedIncrement(&g_CommandID))));\
        PrintDebugMessage(WarningStrings::g_cDDIEntryHeader + std::string(__FUNCTION__));\
    }\
    \
    HRESULT EntryPointHr = S_OK; \
    try \
    { \

#define CLOSE_TRYCATCH_AND_STORE_HRESULT(hr) \
        EntryPointHr = hr; \
    } \
    catch (_com_error& hrEx) \
    { \
        EntryPointHr = hrEx.Error(); \
    } \
    catch (std::bad_alloc&) \
    { \
        EntryPointHr = E_OUTOFMEMORY; \
    } \
    EntryPointHr = TranslateDxgiHrToD3D9(EntryPointHr); \

#define D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr) \
    CLOSE_TRYCATCH_AND_STORE_HRESULT(hr) \
    return EntryPointHr; \

#define D3D9on12_DDI_ENTRYPOINT_END_AND_REPORT_HR(hDevice, hr) \
    CLOSE_TRYCATCH_AND_STORE_HRESULT(hr) \
__pragma(warning(suppress:4127)) /* conditional is constant due to constant macro parameter(s) */ \
    if(FAILED(hr)) \
    { \
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);  \
        if (pDevice) \
            pDevice->ReportError(EntryPointHr); \
    }

#define D3D9on12_DDI_ENTRYPOINT_END_REPORT_HR_AND_RETURN(hDevice, hr, value) \
    CLOSE_TRYCATCH_AND_STORE_HRESULT(hr) \
__pragma(warning(suppress:4127)) /* conditional is constant due to constant macro parameter(s) */ \
    if(FAILED(hr)) \
    { \
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);  \
        if (pDevice) \
            pDevice->ReportError(EntryPointHr); \
    } \
    return value;


#define RETURN_E_INVALIDARG_AND_CHECK() \
    { \
        if (RegistryConstants::g_cCheckOnInvalidArg) \
        { \
            DebugBreak(); \
        } \
        return E_INVALIDARG; \
    }

    //
    // Converts an HRESULT to an exception.  This matches ThrowFailure used
    // elsewhere in dxg.
    //
    inline void ThrowFailure(HRESULT hr)
    {
        if (FAILED(hr))
        {
            throw _com_error(hr);
        }
    }

    static void PrintErrorText()
    {
        DWORD retSize;
        LPTSTR pString = NULL;

        retSize = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_FROM_SYSTEM |
            FORMAT_MESSAGE_ARGUMENT_ARRAY,
            NULL,
            GetLastError(),
            LANG_NEUTRAL,
            (LPTSTR)&pString,
            0,
            NULL);
        PrintDebugMessage(std::string(CStringA(pString)));
    }

    const BYTE g_redOutputPS[] =
    {
        0, 2, 255, 255, 254, 255,
        22, 0, 67, 84, 65, 66,
        28, 0, 0, 0, 35, 0,
        0, 0, 0, 2, 255, 255,
        0, 0, 0, 0, 0, 0,
        0, 0, 0, 1, 0, 0,
        28, 0, 0, 0, 112, 115,
        95, 50, 95, 48, 0, 77,
        105, 99, 114, 111, 115, 111,
        102, 116, 32, 40, 82, 41,
        32, 72, 76, 83, 76, 32,
        83, 104, 97, 100, 101, 114,
        32, 67, 111, 109, 112, 105,
        108, 101, 114, 32, 57, 46,
        50, 55, 46, 57, 53, 50,
        46, 51, 48, 50, 50, 0,
        81, 0, 0, 5, 0, 0,
        15, 160, 0, 0, 128, 63,
        0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 128, 63,
        1, 0, 0, 2, 0, 8,
        15, 128, 0, 0, 228, 160,
        255, 255, 0, 0
    };

    const BYTE g_passThroughVS[] =
    {
        0, 2, 254, 255, 254, 255,
        22, 0, 67, 84, 65, 66,
        28, 0, 0, 0, 35, 0,
        0, 0, 0, 2, 254, 255,
        0, 0, 0, 0, 0, 0,
        0, 0, 0, 1, 0, 0,
        28, 0, 0, 0, 118, 115,
        95, 50, 95, 48, 0, 77,
        105, 99, 114, 111, 115, 111,
        102, 116, 32, 40, 82, 41,
        32, 72, 76, 83, 76, 32,
        83, 104, 97, 100, 101, 114,
        32, 67, 111, 109, 112, 105,
        108, 101, 114, 32, 49, 48,
        46, 48, 46, 49, 48, 48,
        49, 49, 46, 48, 0, 171,
        31, 0, 0, 2, 0, 0,
        0, 128, 0, 0, 15, 144,
        1, 0, 0, 2, 0, 0,
        15, 192, 0, 0, 228, 144,
        255, 255, 0, 0
    };

    // Can't use the std libraries implementation because the internal build tools don't have the latest std library
    static inline BOOL isnan(const float& a)
    {
        static const UINT exponentMask = 0x7f800000;
        static const UINT mantissaMask = 0x007fffff;

        UINT u = *(const UINT*)&a;
        return (((u & exponentMask) == exponentMask) && (u & mantissaMask)); // NaN  
    }

    static bool isinf(const float &f)
    {
        static const INT32 Max32 = 0x7f7FFFFF;
        UINT n = *(UINT*)&f;
        UINT abs = n & 0x7FFFFFFF;
        return abs > Max32;
    }

    static void AssertFloatNotInfOrNan(float f)
    {
        Check9on12(!isnan(f));
        Check9on12(!isinf(f));
    }

    template<typename DataType>
    static FORCEINLINE DataType Align(DataType location, size_t alignment)
    {
        return (DataType)((location + (alignment - 1)) & ~(alignment - 1));
    }

    template<typename DataType>
    static FORCEINLINE bool IsAligned(DataType location, size_t alignment)
    {
        return location % alignment == 0;
    }

    static FORCEINLINE UINT CeilToClosestPowerOfTwo(UINT32 n)
    {
        // Accomplished using bit magic, only works on numbers
        // won't overflow a 32 bit UINT
        assert(n <= BIT(31));

        n--;
        n |= n >> 1;
        n |= n >> 2;
        n |= n >> 4;
        n |= n >> 8;
        n |= n >> 16;
        n++;

        return n;
    }

    static RECT RectThatCoversEntireResource(const D3D12_PLACED_SUBRESOURCE_FOOTPRINT &footprint)
    {
        RECT rect = {};
        rect.right = (LONG)footprint.Footprint.Width;
        rect.bottom = (LONG)footprint.Footprint.Height;
        return rect;
    }

    static RECT RectThatCoversEntireResource(const D3D12_RESOURCE_DESC& desc)
    {
        RECT rect = {};
        rect.right = (LONG)desc.Width;
        rect.bottom = (LONG)desc.Height;
        return rect;
    }

    static bool RectsAreEqual(const RECT& a, const RECT& b)
    {
        return a.bottom == b.bottom && a.left == b.left && a.right == b.right && a.top == b.top;
    }

    static UINT BoxWidth(const D3D12_BOX &b)
    {
        Check9on12(b.right >= b.left);
        return b.right - b.left;
    }

    static UINT BoxHeight(const D3D12_BOX &b)
    {
        Check9on12(b.bottom >= b.top);
        return b.bottom - b.top;
    }

    static UINT BoxDepth(const D3D12_BOX &b)
    {
        Check9on12(b.back >= b.front);
        return b.back - b.front;
    }

    static UINT RectHeight(const RECT& r)
    {
        Check9on12(r.bottom >= r.top);
        return r.bottom - r.top;
    }

    static UINT RectWidth(const RECT& r)
    {
        Check9on12(r.right >= r.left);
        return r.right - r.left;
    }

    static bool IsRectEmpty(const RECT& r)
    {
        return r.left == 0 && r.right == 0 && r.top == 0 && r.bottom == 0;
    }

    static bool IsBoxValid(const D3D12_BOX& box)
    {
        return box.right > box.left && box.bottom > box.top && box.back > box.front;
    }

    static D3D12_BOX BoxFromDesc(const D3D12_RESOURCE_DESC &desc)
    {
        return CD3DX12_BOX(0, 0, 0, static_cast<LONG>(desc.Width), static_cast<LONG>(desc.Height), static_cast<LONG>(desc.DepthOrArraySize));
    }

    // We round down on for left and top; and we round up for  
    // right and bottom  inline void CBaseTexture::ScaleRectDown(RECT *pRect, UINT PowersOfTwo)  
    static void ScaleRectDown(RECT& rect, UINT PowersOfTwo)
    {
        Check9on12(PowersOfTwo > 0);
        Check9on12(PowersOfTwo < 32);
        Check9on12(rect.right > 0);
        Check9on12(rect.bottom > 0);
        Check9on12(rect.left < rect.right);
        Check9on12(rect.top < rect.bottom);
        Check9on12(rect.left >= 0);
        Check9on12(rect.top >= 0);

        // Rounding down is automatic with the shift operator
        rect.left >>= PowersOfTwo; 
        rect.top >>= PowersOfTwo;

        if (rect.right & ((1 << PowersOfTwo) - 1))
        {
            rect.right >>= PowersOfTwo;
            rect.right++;
        }
        else
        {
            rect.right >>= PowersOfTwo;
        }

        if (rect.bottom & ((1 << PowersOfTwo) - 1))
        {
            rect.bottom >>= PowersOfTwo;
            rect.bottom++;
        }
        else
        {
            rect.bottom >>= PowersOfTwo;
        }
    }

    static void ClipBox(D3D12_BOX& box, const D3D12_PLACED_SUBRESOURCE_FOOTPRINT &footprint)
    {
        if (BoxWidth(box) > footprint.Footprint.Width)
        {
            box.right = box.left + footprint.Footprint.Width;
        }

        if (BoxHeight(box) > footprint.Footprint.Height)
        {
            box.bottom = box.left + footprint.Footprint.Height;
        }

        if (BoxDepth(box) > footprint.Footprint.Depth)
        {
            box.back = box.front + footprint.Footprint.Depth;
        }
    }

    static void ScaleBoxDown(D3D12_BOX& box, UINT PowersOfTwo)
    {
        Check9on12(box.front < box.back);
        Check9on12(box.back > 0);

        RECT tempRect = {};
        tempRect.left = box.left;
        tempRect.right = box.right;
        tempRect.top = box.top;
        tempRect.bottom = box.bottom;

        ScaleRectDown(tempRect, PowersOfTwo);

        box.left= tempRect.left;
        box.right = tempRect.right;
        box.top = tempRect.top;
        box.bottom = tempRect.bottom;

        // Rounding down is automatic with the shift operator      
        box.front >>= PowersOfTwo;  
        if (box.back & ((1 << PowersOfTwo) - 1))
        {
            box.back >>= PowersOfTwo;
            box.back++;
        }
        else
        {
            box.back >>= PowersOfTwo;
        }
    }

    static bool IsLumaPlane(UINT PlaneIndex)
    {
        return PlaneIndex == 0;
    }

    static bool IsChromaPlane(UINT PlaneIndex)
    {
        return !IsLumaPlane(PlaneIndex);
    }

    static RECT ConvertLumaRectToChromaRect(const RECT& lumaRect, UINT subsampleX, UINT subsampleY)
    {
        RECT chromaRect;
        chromaRect.left = (lumaRect.left + subsampleX - 1) / subsampleX;
        chromaRect.right = (lumaRect.right + subsampleX - 1) / subsampleX;
        chromaRect.top = (lumaRect.top + subsampleY - 1) / subsampleY;
        chromaRect.bottom = (lumaRect.bottom + subsampleY - 1) / subsampleY;
        return chromaRect;
    }

    static D3DDDI_UNLOCKFLAGS ConvertUnlockAsyncFlag(const D3DDDI_UNLOCKASYNCFLAGS &asyncFlag)
    {
        D3DDDI_UNLOCKFLAGS unlockFlag = {};
        unlockFlag.NotifyOnly = asyncFlag.NotifyOnly;
        return unlockFlag;
    }


    static D3DDDI_LOCKFLAGS ConvertLockAsyncFlags(const D3DDDI_LOCKASYNCFLAGS &asyncFlag)
    {
        D3DDDI_LOCKFLAGS lockFlag = {};

        // TODO: Can we do anything with this info?
        // NoExistingReferences : 1;           // 0x00000020

        lockFlag.NoOverwrite = asyncFlag.NoOverwrite;
        lockFlag.Discard = asyncFlag.Discard;
        lockFlag.RangeValid = asyncFlag.RangeValid;
        lockFlag.AreaValid = asyncFlag.AreaValid;
        lockFlag.BoxValid = asyncFlag.BoxValid;
        lockFlag.NotifyOnly = asyncFlag.NotifyOnly;
        lockFlag.WriteOnly = TRUE;

        return lockFlag;
    }

    static SECURITY_ATTRIBUTES ConvertSecurityDescriptorToSecurityAttributes(const SECURITY_DESCRIPTOR *pDesc)
    {
        SECURITY_ATTRIBUTES attributes = {};
        attributes.lpSecurityDescriptor = (LPVOID)pDesc;
        return attributes;
    }

    // Clip the src/dst rects for a copy based on a boundingRect (usually either a dirty rect or resource boundaries)
    static void ClipCopyRectsWithBoudingRect(RECT &sourceRect, RECT &destRect, RECT &boundingRect)
    {
        const FLOAT widthScalingFactor = (FLOAT)RectWidth(destRect) / (FLOAT)RectWidth(sourceRect);
        const FLOAT heightScalingFactor = (FLOAT)RectHeight(destRect) / (FLOAT)RectHeight(sourceRect);

        // Clamp any negative values
        boundingRect.left = max(0l, boundingRect.left);
        boundingRect.top = max(0l, boundingRect.top);

        // Using ceil for all floating point operation here is what allows us to be "conformant" for the HLK Present2.exe
        if (sourceRect.left < boundingRect.left)
        {
            const FLOAT clippedAmount = (FLOAT)(boundingRect.left - sourceRect.left);
            sourceRect.left = boundingRect.left;
            destRect.left += (LONG)ceil(clippedAmount * widthScalingFactor);
        }

        if (sourceRect.right > boundingRect.right)
        {
            const FLOAT clippedAmount = (FLOAT)(sourceRect.right - boundingRect.right);
            sourceRect.right = boundingRect.right;
            destRect.right -= (LONG)ceil(clippedAmount * widthScalingFactor);
        }

        if (sourceRect.top < boundingRect.top)
        {
            const FLOAT clippedAmount = (FLOAT)(boundingRect.top - sourceRect.top);
            sourceRect.top = boundingRect.top;
            destRect.top += (LONG)ceil(clippedAmount * heightScalingFactor);
        }

        if (sourceRect.bottom > boundingRect.bottom)
        {
            const FLOAT clippedAmount = (FLOAT)(sourceRect.bottom - boundingRect.bottom);
            sourceRect.bottom = boundingRect.bottom;
            destRect.bottom -= (LONG)ceil(clippedAmount * heightScalingFactor);
        }
    }

    // Clips rects being used for a copy so that they fit DX12 requirements. PairedRect is the other source/destination
    // rect corresponding to rectToClip
    static void ClipCopyRect(RECT &rectToClip, RECT &pairedRect, INT resourceWidth, INT resourceHeight)
    {
        RECT resourceBounds;
        resourceBounds.left = 0;
        resourceBounds.top = 0;
        resourceBounds.right = resourceWidth;
        resourceBounds.bottom = resourceHeight;
        ClipCopyRectsWithBoudingRect(rectToClip, pairedRect, resourceBounds);
    }

    static const D3D12TranslationLayer::EQueryType g_cNoD3D12EquivalentQuery = (D3D12TranslationLayer::EQueryType) - 1;
    static D3D12TranslationLayer::EQueryType ConvertQueryType(D3DDDIQUERYTYPE type)
    {
        switch (type)
        {
        case D3DDDIQUERYTYPE_OCCLUSION:
            return D3D12TranslationLayer::e_QUERY_OCCLUSION;
        case D3DDDIQUERYTYPE_TIMESTAMP:
            return D3D12TranslationLayer::e_QUERY_TIMESTAMP;
        case D3DDDIQUERYTYPE_TIMESTAMPDISJOINT:
            return D3D12TranslationLayer::e_QUERY_TIMESTAMPDISJOINT;
        case D3DDDIQUERYTYPE_EVENT:
            return D3D12TranslationLayer::e_QUERY_EVENT;
        case D3DDDIQUERYTYPE_TIMESTAMPFREQ:
        case D3DDDIQUERYTYPE_VCACHE:
        case D3DDDIQUERYTYPE_RESOURCEMANAGER:
        case D3DDDIQUERYTYPE_VERTEXSTATS:
        case D3DDDIQUERYTYPE_DDISTATS:
        case D3DDDIQUERYTYPE_PIPELINETIMINGS:
        case D3DDDIQUERYTYPE_INTERFACETIMINGS:
        case D3DDDIQUERYTYPE_VERTEXTIMINGS:
        case D3DDDIQUERYTYPE_PIXELTIMINGS:
        case D3DDDIQUERYTYPE_BANDWIDTHTIMINGS:
        case D3DDDIQUERYTYPE_CACHEUTILIZATION:
        case D3DDDIQUERYTYPE_COUNTER_DEVICE_DEPENDENT:
        default:
            Check9on12(false);
            break; 
        }

        return g_cNoD3D12EquivalentQuery;
    }

    static D3D12TranslationLayer::EShaderStage ConvertFrom9on12ShaderType(ShaderType shaderType)
    {
        switch (shaderType )
        {
        case D3D9on12::VERTEX_SHADER:
            return D3D12TranslationLayer::e_VS;
        case D3D9on12::GEOMETRY_SHADER:
            return D3D12TranslationLayer::e_GS;
        case D3D9on12::PIXEL_SHADER:
            return D3D12TranslationLayer::e_PS;
        case D3D9on12::NUM_SHADER_TYPES:
        default:
            Check9on12(false);
            return D3D12TranslationLayer::e_VS;
        }
    }

    static D3D12_TEXTURE_ADDRESS_MODE ConvertToD3D12TextureAddress(D3DTEXTUREADDRESS d3dTextureAddress)
    {
        switch (d3dTextureAddress)
        {
        case D3DTADDRESS_WRAP:
            return D3D12_TEXTURE_ADDRESS_MODE_WRAP;
        case D3DTADDRESS_MIRROR:
            return D3D12_TEXTURE_ADDRESS_MODE_MIRROR;
        case D3DTADDRESS_CLAMP:
            return D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
        case D3DTADDRESS_BORDER:
            return D3D12_TEXTURE_ADDRESS_MODE_BORDER;
        case D3DTADDRESS_MIRRORONCE:
            return D3D12_TEXTURE_ADDRESS_MODE_MIRROR_ONCE;
        default:
            Check9on12(false);
            return (D3D12_TEXTURE_ADDRESS_MODE)-1;
        }
    }

    static D3D12_FILTER ConvertToD3D12ComparisonFilter(D3D12_FILTER filter)
    {
        switch (filter)
        {
            case D3D12_FILTER_MIN_MAG_MIP_POINT              :
                return D3D12_FILTER_COMPARISON_MIN_MAG_MIP_POINT;
            case D3D12_FILTER_MIN_MAG_POINT_MIP_LINEAR       :
                return D3D12_FILTER_COMPARISON_MIN_MAG_POINT_MIP_LINEAR;
            case D3D12_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT :
                return D3D12_FILTER_COMPARISON_MIN_POINT_MAG_LINEAR_MIP_POINT;
            case D3D12_FILTER_MIN_POINT_MAG_MIP_LINEAR       :
                return D3D12_FILTER_COMPARISON_MIN_POINT_MAG_MIP_LINEAR;
            case D3D12_FILTER_MIN_LINEAR_MAG_MIP_POINT       :
                return D3D12_FILTER_COMPARISON_MIN_LINEAR_MAG_MIP_POINT;
            case D3D12_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR: 
                return D3D12_FILTER_COMPARISON_MIN_LINEAR_MAG_POINT_MIP_LINEAR;
            case D3D12_FILTER_MIN_MAG_LINEAR_MIP_POINT       :
                return D3D12_FILTER_COMPARISON_MIN_MAG_LINEAR_MIP_POINT;
            case D3D12_FILTER_MIN_MAG_MIP_LINEAR             :
                return D3D12_FILTER_COMPARISON_MIN_MAG_MIP_LINEAR;
            case D3D12_FILTER_ANISOTROPIC                    :
                return D3D12_FILTER_COMPARISON_ANISOTROPIC;
            case D3D12_FILTER_MIN_MAG_ANISOTROPIC_MIP_POINT  :
                return D3D12_FILTER_COMPARISON_MIN_MAG_ANISOTROPIC_MIP_POINT;
            default:
                Check9on12(false);
                return (D3D12_FILTER)-1;
        }
    }

    static D3D12_FILTER ConvertToD3D12Filter(
        D3DTEXTUREFILTERTYPE magFilter,
        D3DTEXTUREFILTERTYPE minFilter,
        D3DTEXTUREFILTERTYPE mipFilter,
        bool supportAnisoPointMip)
    {
        if ((D3DTEXF_ANISOTROPIC == minFilter)
            || (D3DTEXF_ANISOTROPIC == magFilter))
        {
            return (mipFilter == D3DTEXF_POINT && supportAnisoPointMip) ?
                D3D12_FILTER_MIN_MAG_ANISOTROPIC_MIP_POINT :
                D3D12_FILTER_ANISOTROPIC;
        }
        switch (mipFilter)
        {
        case D3DTEXF_POINT:
            if ((D3DTEXF_POINT == minFilter)
                && (D3DTEXF_POINT == magFilter))
            {
                return D3D12_FILTER_MIN_MAG_MIP_POINT;
            }
            if ((D3DTEXF_POINT == minFilter)
                && (D3DTEXF_LINEAR == magFilter))
            {
                return D3D12_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT;
            }
            if ((D3DTEXF_LINEAR == minFilter)
                && (D3DTEXF_POINT == magFilter))
            {
                return D3D12_FILTER_MIN_LINEAR_MAG_MIP_POINT;
            }
            if ((D3DTEXF_LINEAR == minFilter)
                && (D3DTEXF_LINEAR == magFilter))
            {
                return D3D12_FILTER_MIN_MAG_LINEAR_MIP_POINT;
            }
            break;
        default:
        // D3D12 doesn't support a "none", filter. Instead we fake this by disabling mips outside of mip 0 via SRVs.
        // It's important that we pick LINEAR for the mip filter instead of POINT because hardware that does LOD 
        // clamping BEFORE determining whether to minify vs magnify (QC), will have a 0.5 rounding factor to the LOD
        // when doing POINT. This is enough to change the decision on whether to minify/magnify. This causes multiple 
        // issues in the DX9 HCK tests.
        //
        // Note DX9 tests assumed clamping happened after the minify/magnify decision, with contradicts the DX11 HW spec
        // that says it's undefined when clamping happens. This means that 9on12 can't properly support tests that try to
        // verify mip:point + mismatching min/mag filters match exactly with the ref rast. These tests have been modified to
        // no longer have this requirement
        case D3DTEXF_NONE:
        case D3DTEXF_LINEAR:
            if ((D3DTEXF_POINT == minFilter)
                && (D3DTEXF_POINT == magFilter))
            {
                return D3D12_FILTER_MIN_MAG_POINT_MIP_LINEAR;
            }
            if ((D3DTEXF_POINT == minFilter)
                && (D3DTEXF_LINEAR == magFilter))
            {
                return D3D12_FILTER_MIN_POINT_MAG_MIP_LINEAR;
            }
            if ((D3DTEXF_LINEAR == minFilter)
                && (D3DTEXF_POINT == magFilter))
            {
                return D3D12_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR;
            }
            if ((D3DTEXF_LINEAR == minFilter)
                && (D3DTEXF_LINEAR == magFilter))
            {
                return D3D12_FILTER_MIN_MAG_MIP_LINEAR;
            }
            break;
        }
        return D3D12_FILTER_MIN_MAG_MIP_POINT;
    }


    static D3D12_FILTER ConvertToD3D12SamplerFilter(
        D3DTEXTUREFILTERTYPE magFilter,
        D3DTEXTUREFILTERTYPE minFilter,
        D3DTEXTUREFILTERTYPE mipFilter,
        bool comparisonEnabled,
        bool supportAnisoPointMip)
    {
        D3D12_FILTER filter = ConvertToD3D12Filter(magFilter, minFilter, mipFilter, supportAnisoPointMip);
        if (comparisonEnabled)
        {
            filter = ConvertToD3D12ComparisonFilter(filter);
        }
        return filter;
    }

    static D3D12_STENCIL_OP ConvertToD3D12StencilOp(D3DSTENCILOP d3dStencilOp)
    {
        switch (d3dStencilOp)
        {
        default:
            Check9on12(false);
            return (D3D12_STENCIL_OP)-1;
        case D3DSTENCILOP_KEEP:
            return D3D12_STENCIL_OP_KEEP;
        case D3DSTENCILOP_ZERO:
            return D3D12_STENCIL_OP_ZERO;
        case D3DSTENCILOP_REPLACE:
            return D3D12_STENCIL_OP_REPLACE;
        case D3DSTENCILOP_INCRSAT:
            return D3D12_STENCIL_OP_INCR_SAT;
        case D3DSTENCILOP_DECRSAT:
            return D3D12_STENCIL_OP_DECR_SAT;
        case D3DSTENCILOP_INVERT:
            return D3D12_STENCIL_OP_INVERT;
        case D3DSTENCILOP_INCR:
            return D3D12_STENCIL_OP_INCR;
        case D3DSTENCILOP_DECR:
            return D3D12_STENCIL_OP_DECR;
        }
    }

    static D3D12_COMPARISON_FUNC ConvertToD3D12ComparisonFunc(D3DCMPFUNC d3dFunc)
    {
        switch (d3dFunc)
        {
        default:
            Check9on12(false);
            return (D3D12_COMPARISON_FUNC)-1;
        case D3DCMP_NEVER:
            return D3D12_COMPARISON_FUNC_NEVER;
        case D3DCMP_LESS:
            return D3D12_COMPARISON_FUNC_LESS;
        case D3DCMP_EQUAL:
            return D3D12_COMPARISON_FUNC_EQUAL;
        case D3DCMP_LESSEQUAL:
            return D3D12_COMPARISON_FUNC_LESS_EQUAL;
        case D3DCMP_GREATER:
            return D3D12_COMPARISON_FUNC_GREATER;
        case D3DCMP_NOTEQUAL:
            return D3D12_COMPARISON_FUNC_NOT_EQUAL;
        case D3DCMP_GREATEREQUAL:
            return D3D12_COMPARISON_FUNC_GREATER_EQUAL;
        case D3DCMP_ALWAYS:
            return D3D12_COMPARISON_FUNC_ALWAYS;
        }
    }

    static D3D12_BLEND_OP ConvertToD3D12BlendOp(D3DBLENDOP d3dBlendOp)
    {
        switch (d3dBlendOp)
        {
        default:
            Check9on12(false);
            // This is still an unexpected scenario, but we've encountered at least
            // one app that hits this (World of Warplanes). To avoid failing PSO creation,
            // we're falling through to a 'reasonable' fallback.
        case D3DBLENDOP_ADD:
            return D3D12_BLEND_OP_ADD;
        case D3DBLENDOP_SUBTRACT:
            return D3D12_BLEND_OP_SUBTRACT;
        case D3DBLENDOP_REVSUBTRACT:
            return D3D12_BLEND_OP_REV_SUBTRACT;
        case D3DBLENDOP_MIN:
            return D3D12_BLEND_OP_MIN;
        case D3DBLENDOP_MAX:
            return D3D12_BLEND_OP_MAX;
        }
    }

    static D3D12_BLEND ConvertToD3D12Blend(D3DBLEND d3dBlend)
    {
        switch (d3dBlend)
        {
        default:
        case D3DBLEND_ZERO:
            return D3D12_BLEND_ZERO;
        case D3DBLEND_ONE:
            return D3D12_BLEND_ONE;
        case D3DBLEND_SRCCOLOR:
            return D3D12_BLEND_SRC_COLOR;
        case D3DBLEND_INVSRCCOLOR:
            return D3D12_BLEND_INV_SRC_COLOR;
        case D3DBLEND_SRCALPHA:
            return D3D12_BLEND_SRC_ALPHA;
        case D3DBLEND_INVSRCALPHA:
            return D3D12_BLEND_INV_SRC_ALPHA;
        case D3DBLEND_DESTALPHA:
            return D3D12_BLEND_DEST_ALPHA;
        case D3DBLEND_INVDESTALPHA:
            return D3D12_BLEND_INV_DEST_ALPHA;
        case D3DBLEND_DESTCOLOR:
            return D3D12_BLEND_DEST_COLOR;
        case D3DBLEND_INVDESTCOLOR:
            return D3D12_BLEND_INV_DEST_COLOR;
        case D3DBLEND_SRCALPHASAT:
            return D3D12_BLEND_SRC_ALPHA_SAT;
        case D3DBLEND_BLENDFACTOR:
            return D3D12_BLEND_BLEND_FACTOR;
        case D3DBLEND_INVBLENDFACTOR:
            return D3D12_BLEND_INV_BLEND_FACTOR;
        case D3DBLEND_SRCCOLOR2:
            return D3D12_BLEND_SRC1_COLOR;
        case D3DBLEND_INVSRCCOLOR2:
            return D3D12_BLEND_INV_SRC1_COLOR;
        }
    }

    // In DX9 "COLOR" referred to both COLOR and ALPHA, but in DX12 COLOR specifically 
    // means just the color and not the alpha. Convert anything that says "COLOR"
    // to just it's "ALPHA" variant
    static D3D12_BLEND ConvertToD3D12AlphaBlend(D3DBLEND d3dBlend)
    {
        switch (d3dBlend)
        {
        default:
        case D3DBLEND_ZERO:
            return D3D12_BLEND_ZERO;
        case D3DBLEND_ONE:
            return D3D12_BLEND_ONE;
        case D3DBLEND_SRCCOLOR:
        case D3DBLEND_SRCALPHA:
            return D3D12_BLEND_SRC_ALPHA;
        case D3DBLEND_INVSRCCOLOR:
        case D3DBLEND_INVSRCALPHA:
            return D3D12_BLEND_INV_SRC_ALPHA;
        case D3DBLEND_DESTALPHA:
        case D3DBLEND_DESTCOLOR:
            return D3D12_BLEND_DEST_ALPHA;
        case D3DBLEND_INVDESTALPHA:
        case D3DBLEND_INVDESTCOLOR:
            return D3D12_BLEND_INV_DEST_ALPHA;
        case D3DBLEND_SRCALPHASAT:
            return D3D12_BLEND_SRC_ALPHA_SAT;
        case D3DBLEND_BLENDFACTOR:
            return D3D12_BLEND_BLEND_FACTOR;
        case D3DBLEND_INVBLENDFACTOR:
            return D3D12_BLEND_INV_BLEND_FACTOR;
        case D3DBLEND_SRCCOLOR2:
            return D3D12_BLEND_SRC1_ALPHA;
        case D3DBLEND_INVSRCCOLOR2:
            return D3D12_BLEND_INV_SRC1_ALPHA;
        }
    }

    static bool D3D12BlendAppliesToAlpha(D3D12_BLEND d3dBlend)
    {
        switch (d3dBlend)
        {
        case D3D12_BLEND_SRC_COLOR:
        case D3D12_BLEND_INV_SRC_COLOR:
        case D3D12_BLEND_DEST_COLOR:
        case D3D12_BLEND_INV_DEST_COLOR:
        case D3D12_BLEND_SRC1_COLOR:
        case D3D12_BLEND_INV_SRC1_COLOR:
            return false;
        case D3D12_BLEND_SRC_ALPHA:
        case D3D12_BLEND_INV_SRC_ALPHA:
        case D3D12_BLEND_DEST_ALPHA:
        case D3D12_BLEND_INV_DEST_ALPHA:
        case D3D12_BLEND_SRC_ALPHA_SAT:
        case D3D12_BLEND_BLEND_FACTOR:
        case D3D12_BLEND_INV_BLEND_FACTOR:
        case D3D12_BLEND_ZERO:
        case D3D12_BLEND_ONE:
        case D3D12_BLEND_SRC1_ALPHA:
        case D3D12_BLEND_INV_SRC1_ALPHA:
            return true;
        default:
            Check9on12(FALSE);
            return false;
        }
        
    }

    static DirectX::XMFLOAT4 ARGBToUNORMFloat(D3DCOLOR color)
    {
        DirectX::XMFLOAT4 output;
        output.x = float((color >> 16) & 0xff) / 255.0f;
        output.y = float((color >> 8) & 0xff) / 255.0f;
        output.z = float(color & 0xff) / 255.0f;
        output.w = float((color >> 24) & 0xff) / 255.0f;
        return output;
    }

    static D3DFORMAT ConvertDDIFormatToAPI(D3DDDIFORMAT format)
    {
        // DDI format is equivalent to the API format
        return (D3DFORMAT)format;
    }

    static DXGI_FORMAT ConvertToSRGB(DXGI_FORMAT Format)
    {
        const DXGI_FORMAT *pFormatSet = CD3D11FormatHelper::GetFormatCastSet(Format);
        for (; *pFormatSet != DXGI_FORMAT_UNKNOWN; pFormatSet++)
        {
            if (CD3D11FormatHelper::IsSRGBFormat(*pFormatSet))
            {
                return *pFormatSet;
            }
        }

        return DXGI_FORMAT_UNKNOWN;
    }

    static bool IsSRGBCompatible(DXGI_FORMAT Format)
    {
        return ConvertToSRGB(Format) != DXGI_FORMAT_UNKNOWN;
    }

    static DXGI_FORMAT ConvertToTypeless(DXGI_FORMAT format)
    {
        return CD3D11FormatHelper::GetParentFormat(format);
    }

    static bool IsBlockCompressedFormat(DXGI_FORMAT format)
    {
        return CD3D11FormatHelper::IsBlockCompressFormat(format);
    }

    static bool IsYUVFormat(DXGI_FORMAT format)
    {
        return CD3D11FormatHelper::YUV(format);
    }

    static bool IsDepthStencilFormat(DXGI_FORMAT format)
    {
        return CD3D11FormatHelper::GetComponentName(format, 0) == D3D11FCN_D;
    }

    static DXGI_FORMAT ConvertDepthFormatToCompanionSRVFormat(DXGI_FORMAT format)
    {
        Check9on12(IsDepthStencilFormat(format));

        D3D11_FORMAT_COMPONENT_INTERPRETATION componentInterpretation = CD3D11FormatHelper::GetFormatComponentInterpretation(format, 0);
        const DXGI_FORMAT *pFormatSet = CD3D11FormatHelper::GetFormatCastSet(format);
        for (; *pFormatSet != DXGI_FORMAT_UNKNOWN; pFormatSet++)
        {
            if (CD3D11FormatHelper::GetTypeLevel(*pFormatSet) == D3D11_FORMAT_TYPE_LEVEL::D3D11FTL_FULL_TYPE && 
                CD3D11FormatHelper::GetComponentName(*pFormatSet, 0) == D3D11FCN_R &&
                CD3D11FormatHelper::GetFormatComponentInterpretation(*pFormatSet, 0) == componentInterpretation)
            {
                return *pFormatSet;
            }
        }

        Check9on12(false); // We should always be able to find a companion SRV format
        return DXGI_FORMAT_UNKNOWN;
    }

    static bool IsTypelessFormat(DXGI_FORMAT format)
    {
        return CD3D11FormatHelper::GetTypeLevel(format) == D3D11_FORMAT_TYPE_LEVEL::D3D11FTL_PARTIAL_TYPE;
    }

    static DXGI_FORMAT ConvertToDisplayCompatibleFormat(DXGI_FORMAT format)
    {
        if (IsTypelessFormat(format))
        {
            const DXGI_FORMAT *pFormatSet = CD3D11FormatHelper::GetFormatCastSet(format);
            for (; *pFormatSet != DXGI_FORMAT_UNKNOWN; pFormatSet++)
            {
                if (CD3D11FormatHelper::GetTypeLevel(*pFormatSet) == D3D11_FORMAT_TYPE_LEVEL::D3D11FTL_FULL_TYPE && !CD3D11FormatHelper::IsSRGBFormat(*pFormatSet))
                {
                    return *pFormatSet;
                }
            }
        }
        return format;
    }

    static bool FormatSupportsStencil(DXGI_FORMAT format)
    {
        return CD3D11FormatHelper::GetComponentName(format, 1) == D3D11FCN_S;
    }

    static bool IsCompatibleAsSourceForBltPresent(const D3D12_RESOURCE_DESC &desc)
    {
        return !IsTypelessFormat(desc.Format) && desc.SampleDesc.Count == 1;
    }

    static bool IsIHVFormat(D3DFORMAT d3dFormat)
    {
        switch (d3dFormat)
        {
        case D3DFMT_ATI2:
        case D3DFMT_ATI1:
        case D3DFMT_INTZ:
        case D3DFMT_RAWZ:
        case D3DFMT_DF16:
        case D3DFMT_DF24:
        case D3DFMT_NULL:
            return true;
        default:
            return false;
        }
    }

    static D3DFORMAT GetFormatWithSwappedRBChannels(D3DFORMAT format)
    {
        D3DFORMAT formatWithSwappedRBChannels = D3DFMT_UNKNOWN;
        switch (format)
        {
        case D3DFMT_A2R10G10B10:
            formatWithSwappedRBChannels = D3DFMT_A2B10G10R10;
        }

        return formatWithSwappedRBChannels;
    }

    static bool FormatRequiresSwappedRBChannels(D3DFORMAT format)
    {
        return GetFormatWithSwappedRBChannels(format) != D3DFMT_UNKNOWN;
    }

    static bool IsIHVFormat(D3DDDIFORMAT d3dFormat)
    {
        return IsIHVFormat(ConvertDDIFormatToAPI(d3dFormat));
    }

    static DXGI_FORMAT ConvertToDXGIFORMAT(D3DFORMAT d3dFormat)
    {
        switch ((DWORD)d3dFormat)
        {
        case D3DFMT_A8:
            return DXGI_FORMAT_A8_UNORM;
        case D3DFMT_L8:
            return DXGI_FORMAT_R8_UNORM;  
        case D3DFMT_A8L8:
            return DXGI_FORMAT_R8G8_UNORM;
        case D3DFMT_L16:
            return DXGI_FORMAT_R16_UNORM;  
        case D3DFMT_R5G6B5:
            return DXGI_FORMAT_B5G6R5_UNORM;
        case D3DFMT_A1R5G5B5:
        case D3DFMT_X1R5G5B5:
            return DXGI_FORMAT_B5G5R5A1_UNORM;
        case D3DFMT_A8R8G8B8:
            return DXGI_FORMAT_B8G8R8A8_UNORM;
        case D3DFMT_X8R8G8B8:
            return DXGI_FORMAT_B8G8R8X8_UNORM;
        case D3DFMT_A8B8G8R8:
            return DXGI_FORMAT_R8G8B8A8_UNORM;
        case D3DFMT_AYUV:
            return DXGI_FORMAT_AYUV;
        case D3DFMT_YUY2:
            return DXGI_FORMAT_YUY2;
        case D3DFMT_YV12:
        case D3DFMT_NV12:
            return DXGI_FORMAT_NV12;
        case  D3DFMT_420O:
            return  DXGI_FORMAT_420_OPAQUE;
        case  D3DFMT_NV11:
            return DXGI_FORMAT_NV11;
        case  D3DFMT_AI44:
            return DXGI_FORMAT_AI44;
        case  D3DFMT_IA44:
            return DXGI_FORMAT_IA44;
        case D3DFMT_Y410:
            return DXGI_FORMAT_Y410;
        case  D3DFMT_Y416:
            return DXGI_FORMAT_Y416;
        case  D3DFMT_P010:
            return DXGI_FORMAT_P010;
        case  D3DFMT_P016:
            return DXGI_FORMAT_P016;
        case  D3DFMT_Y210:
            return DXGI_FORMAT_Y210;
        case  D3DFMT_Y216:
            return DXGI_FORMAT_Y216;
        case D3DFMT_DXT1:
            return DXGI_FORMAT_BC1_UNORM;
        case D3DFMT_DXT2:
        case D3DFMT_DXT3:
            return DXGI_FORMAT_BC2_UNORM;
        case D3DFMT_DXT4:
        case D3DFMT_DXT5:
            return DXGI_FORMAT_BC3_UNORM;
        case D3DFMT_ATI1:
            return DXGI_FORMAT_BC4_UNORM;
        case D3DFMT_ATI2:
            return DXGI_FORMAT_BC5_UNORM;
        case D3DFMT_V8U8:
            return DXGI_FORMAT_R8G8_SNORM;
        case D3DFMT_D16:
        case D3DFMT_D16_LOCKABLE:
        case D3DFMT_RAWZ:
        case D3DFMT_DF16:
            return DXGI_FORMAT_D16_UNORM;
        case D3DFMT_D32F_LOCKABLE:
            return DXGI_FORMAT_D32_FLOAT;
        case D3DFMT_S8D24:
        case D3DFMT_X8D24:
        case D3DFMT_D24S8:
        case D3DFMT_D24FS8:
        case D3DFMT_D24X8:
        case D3DFMT_DF24:
        case D3DFMT_INTZ:
            return DXGI_FORMAT_D24_UNORM_S8_UINT;
        case D3DFMT_A16B16G16R16:
            return DXGI_FORMAT_R16G16B16A16_UNORM;
        case D3DFMT_R16F:
            return DXGI_FORMAT_R16_FLOAT;
        case D3DFMT_G16R16F:
            return DXGI_FORMAT_R16G16_FLOAT;
        case D3DFMT_A16B16G16R16F:
            return DXGI_FORMAT_R16G16B16A16_FLOAT;
        case D3DFMT_R32F:
            return DXGI_FORMAT_R32_FLOAT;
        case D3DFMT_G32R32F:
            return DXGI_FORMAT_R32G32_FLOAT;
        case D3DFMT_A32B32G32R32F:
            return DXGI_FORMAT_R32G32B32A32_FLOAT;
        case D3DFMT_A2B10G10R10:
        case D3DFMT_A2R10G10B10:
            return DXGI_FORMAT_R10G10B10A2_UNORM;
        case D3DFMT_G16R16:
            return DXGI_FORMAT_R16G16_UNORM;
        case D3DFMT_V16U16:
            return DXGI_FORMAT_R16G16_SNORM;
        case D3DFMT_Q8W8V8U8:
            return DXGI_FORMAT_R8G8B8A8_SNORM;
        case D3DFMT_Q16W16V16U16:
            return DXGI_FORMAT_R16G16B16A16_SNORM;
        case D3DFMT_A4R4G4B4:
            return DXGI_FORMAT_B4G4R4A4_UNORM;
        case D3DFMT_P8:
            return DXGI_FORMAT_P8;
        case D3DFMT_A8P8:
            return DXGI_FORMAT_A8P8;
        case D3DFMT_X4R4G4B4:
            return DXGI_FORMAT_B4G4R4A4_UNORM;
        case D3DFMT_VERTEXDATA:
        case D3DFMT_INDEX16:
        case D3DFMT_INDEX32:
        case D3DFMT_UNKNOWN:
            return DXGI_FORMAT_UNKNOWN;
        default:
            {
                Check9on12(FALSE);
                return DXGI_FORMAT_UNKNOWN;
            }
        }
    }

    static bool IsLockable(D3DFORMAT d3dFormat)
    {
        switch (d3dFormat)
        {
        case D3DFMT_D16_LOCKABLE:
        case D3DFMT_D32F_LOCKABLE:
            return true;
        default:
            return IsIHVFormat(d3dFormat) || !IsDepthStencilFormat(ConvertToDXGIFORMAT(d3dFormat));
        }
    }

    static DXGI_FORMAT ConvertFromDDIToDXGIFORMAT(D3DDDIFORMAT ddiFormat)
    {
        return ConvertToDXGIFORMAT((D3DFORMAT)ddiFormat);
    }

    static UINT ConvertFormatToShaderResourceViewComponentMapping(D3DFORMAT d3dFormat, bool disableAlpha = false)
    {
        // From MSDN:
        // The default value for formats that contain undefined channels (G16R16, A8, and so on) is 1. 
        // The only exception is the A8 format, which is initialized to 000 for the three color channels.

        // In DX10+ reading from undefined channels is usually either 0 or undefined so we're explicitly filling these in
        // with D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_1 (with the special exception of D3DFMT_A8)

        switch (d3dFormat)
        {
        case D3DFMT_ATI1:
            return D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(0, D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_1, D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_1, D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_1);
        case D3DFMT_ATI2:
            return D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(1, 0, D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_1, D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_1);
        case D3DFMT_A8:
            return D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_0, D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_0, D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_0, 3);
        case D3DFMT_A8R8G8B8:
        case D3DFMT_A1R5G5B5:
        case D3DFMT_A4R4G4B4:
        case D3DFMT_A8R3G3B2:
        case D3DFMT_A2B10G10R10:
        case D3DFMT_A8B8G8R8:
        case D3DFMT_A16B16G16R16:
        case D3DFMT_A2W10V10U10:
        case D3DFMT_Q8W8V8U8:
        case D3DFMT_Q16W16V16U16:
        case D3DFMT_A16B16G16R16F:
        case D3DFMT_A32B32G32R32F:
        case D3DFMT_A2B10G10R10_XR_BIAS:
        case D3DFMT_DXT1:
        case D3DFMT_DXT2:
        case D3DFMT_DXT3:
        case D3DFMT_DXT4:
        case D3DFMT_DXT5:
        case D3DFMT_MULTI2_ARGB8:
            if (disableAlpha)
            {
                return D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(0, 1, 2, D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_1);
            }
            else
            {
                return D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
            }
        case D3DFMT_A2R10G10B10:
                return D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(2, 1, 0, disableAlpha ? D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_1 : 3);
        case D3DFMT_R8G8B8:
        case D3DFMT_X8R8G8B8:
        case D3DFMT_R5G6B5:
        case D3DFMT_X1R5G5B5:
        case D3DFMT_R3G3B2:
        case D3DFMT_X4R4G4B4:
        case D3DFMT_X8B8G8R8:
        case D3DFMT_L6V5U5:
        case D3DFMT_X8L8V8U8:
        case D3DFMT_UYVY:
        case D3DFMT_R8G8_B8G8:
        case D3DFMT_G8R8_G8B8:
            return D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(0, 1, 2, D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_1);
        case D3DFMT_G16R16:
        case D3DFMT_V8U8:
        case D3DFMT_V16U16:
        case D3DFMT_G16R16F:
        case D3DFMT_G32R32F:
        case D3DFMT_CxV8U8:
            return D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(0, 1, D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_1, D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_1);
        case D3DFMT_YUY2:
        case D3DFMT_NV12:
        case D3DFMT_NV11:
        case D3DFMT_AI44:
        case D3DFMT_IA44:
        case D3DFMT_Y410:
        case D3DFMT_Y416:
        case D3DFMT_P010:
        case D3DFMT_P016:
        case D3DFMT_Y210:
        case D3DFMT_Y216:
            return D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(0, 1, D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_0, D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_1);

        case D3DFMT_R16F:
        case D3DFMT_R32F:
            return D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(0, D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_1, D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_1, D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_1);
        
        // From MSDN: A one - bit surface has one bit per texel; therefore, a one would mean that all components(r, g, b, a) of a pixel are 1, 
        // and zero would mean that all components are equal to 0. You may use one - bit surfaces with the following APIs : 
        // ColorFill, UpdateSurface and UpdateTexture.
        case D3DFMT_A1:
            return D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(0, 0, 0, 0);

        // Luminance applies to all color channels
        case D3DFMT_L16:
        case D3DFMT_L8:
            return D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(0, 0, 0, D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_1);
        case D3DFMT_A8L8:
        case D3DFMT_A4L4:
            return D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(0, 0, 0, 1);
        case D3DFMT_X8D24:
        case D3DFMT_D24S8:
        case D3DFMT_D24X8:
        case D3DFMT_INTZ:
        case D3DFMT_RAWZ:
        case D3DFMT_DF16:
        case D3DFMT_DF24:
        case D3DFMT_D16:
        case D3DFMT_D32:
            // It is important that the y,z, and w values are forced to 1, games depend on this behavior (most notably is Diablo III)
            return D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(0, D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_1, D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_1, D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_1);
        //TODO: These formats when they get hit
        case D3DFMT_D16_LOCKABLE:
        case D3DFMT_D15S1:
        case D3DFMT_D24X4S4:
        case D3DFMT_D32F_LOCKABLE:
        case D3DFMT_D24FS8:
        case D3DFMT_D32_LOCKABLE:
        case  D3DFMT_S8_LOCKABLE:
        // Not expecting VB/IBbuffer formats either
        case D3DFMT_VERTEXDATA:
        case D3DFMT_INDEX16:
        case D3DFMT_INDEX32:
        case D3DFMT_BINARYBUFFER:
        case D3DFMT_UNKNOWN:
        // Need to figure out expectations for palletized formats
        case D3DFMT_P8:
        case D3DFMT_A8P8:
        default:
            Check9on12(false);
            return (UINT)-1;

        }
    }

    static UINT8 SwizzleRenderTargetMask(UINT8 mask, UINT rtvShaderComponentMapping)
    {
        if (rtvShaderComponentMapping == D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING)
        {
            return mask;
        }

        UINT8 swizzledMask = 0;
        for (UINT srcChannelIndex = 0; srcChannelIndex < 4; srcChannelIndex++)
        {
            UINT dstChannelIndex = D3D12_SHADER_COMPONENT_MAPPING_MASK & (rtvShaderComponentMapping >> (D3D12_SHADER_COMPONENT_MAPPING_SHIFT * srcChannelIndex));
            
            // Can be greater than D3D12_SHADER_COMPONENT_MAPPING_FROM_MEMORY_COMPONENT_3 if using FORCE_VALUE.
            // In these cases the value is never read so we can safely ignore them
            if (dstChannelIndex <= D3D12_SHADER_COMPONENT_MAPPING_FROM_MEMORY_COMPONENT_3)
            {
                UINT bit = (mask & BIT(srcChannelIndex)) != 0;
                swizzledMask |= bit << dstChannelIndex;
            }
        }
        return swizzledMask;
    }

    // Completely arbitrary picked default formats, should investigate if these are optimal
    static D3DFORMAT GetDefaultFormat(D3DDDI_RESOURCEFLAGS flag)
    {
        if (flag.IndexBuffer || flag.VertexBuffer)
        {
            return D3DFMT_R32F;
        }
        else
        {
            return D3DFMT_UNKNOWN;
        }
    }

    static D3D12_HEAP_TYPE ConvertToD3D12HeapType(D3DDDI_POOL PoolType)
    {
        switch (PoolType)
        {
        case D3DDDIPOOL_SYSTEMMEM:
            return D3D12_HEAP_TYPE_UPLOAD;
        case D3DDDIPOOL_VIDEOMEMORY:
        case D3DDDIPOOL_LOCALVIDMEM:
        case D3DDDIPOOL_NONLOCALVIDMEM:
            return D3D12_HEAP_TYPE_DEFAULT;
        case D3DDDIPOOL_STAGINGMEM:
            // Only used for 10level9
            Check9on12(false);
        }
        return (D3D12_HEAP_TYPE)-1;
    }

    static bool IsBuffer(D3DDDI_RESOURCEFLAGS ResourceFlags)
    {
        return ResourceFlags.IndexBuffer || ResourceFlags.VertexBuffer  || ResourceFlags.DecodeCompressedBuffer;
    }

    static D3D12_RESOURCE_DIMENSION ConvertToD3D12Dimension(D3DDDI_RESOURCEFLAGS ResourceFlags, UINT Width, UINT Height, UINT Depth)
    {
        D3D12_RESOURCE_DIMENSION Dimension = D3D12_RESOURCE_DIMENSION_UNKNOWN;
        if (IsBuffer(ResourceFlags))
        {
            Check9on12(Depth <= 1 && Height <= 1);
            Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
        }
        else
        {
            if (Depth > 1)
            {
                Check9on12(Height >= 1 && Width >= 1);
                Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE3D;
            }
            else
            {
                Check9on12(Depth <= 1);
                Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
            }
        }
        return Dimension;
    }
    
    // This excludes CBVs, which are can be created on any memory
    static bool PoolAllowsViews(D3DDDI_POOL poolType)
    {
        return poolType != D3DDDIPOOL_SYSTEMMEM && poolType != D3DDDIPOOL_STAGINGMEM;
    }

    static bool NeedsDepthStencil(D3DDDI_RESOURCEFLAGS ResourceFlags, D3DDDI_POOL poolType)
    {
        return PoolAllowsViews(poolType) && ResourceFlags.ZBuffer;
    }

    static bool IsDecoderSurface(D3DDDI_RESOURCEFLAGS ResourceFlags)
    {
        return ResourceFlags.DecodeRenderTarget  ||  ResourceFlags.DecodeCompressedBuffer;
    }

    static bool NeedsRenderTarget(D3DDDI_RESOURCEFLAGS ResourceFlags, D3DDDI_POOL poolType)
    {
        return PoolAllowsViews(poolType) &&
            (ResourceFlags.RenderTarget ||
            ResourceFlags.AutogenMipmap); // We'll need to internally create an RTV to the resource if we want to generate mipmaps
    }

    static bool NeedsShaderResourceView(D3DDDI_RESOURCEFLAGS ResourceFlags, D3DDDI_POOL poolType)
    {
        return PoolAllowsViews(poolType) && !ResourceFlags.DecodeRenderTarget && !ResourceFlags.VideoProcessRenderTarget && (ResourceFlags.Texture || ResourceFlags.CubeMap || ResourceFlags.Volume);
    }

    static bool NeedsVideoDecoderOutputView(D3DDDI_RESOURCEFLAGS ResourceFlags, D3DDDI_POOL poolType)
    {
        return PoolAllowsViews(poolType) && (ResourceFlags.DecodeRenderTarget);
    }

    static bool NeedsVideoProcessorOutputView(D3DDDI_RESOURCEFLAGS ResourceFlags, D3DDDI_POOL poolType)
    {
        return PoolAllowsViews(poolType) && (ResourceFlags.VideoProcessRenderTarget);
    }

    static D3D12_HEAP_FLAGS ConvertToD3D12HeapFlag(D3DDDI_RESOURCEFLAGS ResourceFlags, D3DDDI_POOL poolType)
    {
        D3D12_HEAP_FLAGS Flag = D3D12_HEAP_FLAG_NONE;
        if (IsBuffer(ResourceFlags))
        {
            Flag = D3D12_HEAP_FLAG_ALLOW_ONLY_BUFFERS;
        }
        else
        {
            
            if (NeedsRenderTarget(ResourceFlags, poolType) || NeedsDepthStencil(ResourceFlags, poolType))
            {
                Flag = D3D12_HEAP_FLAG_ALLOW_ONLY_RT_DS_TEXTURES;
            }
            else
            {
                Flag = D3D12_HEAP_FLAG_ALLOW_ONLY_NON_RT_DS_TEXTURES;
            }
        }
        return Flag;
    }

    static D3D12_RESOURCE_FLAGS ConvertToD3D12ResourceFlags(D3DDDI_RESOURCEFLAGS dx9Flag, D3DDDI_RESOURCEFLAGS2 dx9Flag2, D3DDDI_POOL poolType)
    {
        D3D12_RESOURCE_FLAGS flag = D3D12_RESOURCE_FLAG_NONE;
        if (NeedsRenderTarget(dx9Flag, poolType))
        {
            flag |= D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET;
        }
        if (NeedsDepthStencil(dx9Flag, poolType))
        {
            flag |= D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;
            if (!dx9Flag.Texture)
            {
                flag |= D3D12_RESOURCE_FLAG_DENY_SHADER_RESOURCE;

            }
        }

        if (dx9Flag2.CrossAdapter)
        {
            flag |= D3D12_RESOURCE_FLAG_ALLOW_CROSS_ADAPTER;
        }
        return flag;
    }

    static D3D12_TEXTURE_LAYOUT ConvertToD3D12TextureLayout(D3D12_RESOURCE_DIMENSION dimension, D3DDDI_RESOURCEFLAGS2 dx9Flag2)
    {
        if (dimension == D3D12_RESOURCE_DIMENSION_BUFFER || (dx9Flag2.CrossAdapter && dimension == D3D12_RESOURCE_DIMENSION_TEXTURE2D))
        {
            return D3D12_TEXTURE_LAYOUT_ROW_MAJOR;
        }
        else
        {
            return D3D12_TEXTURE_LAYOUT_UNKNOWN;
        }
    }

    static D3D12_PRIMITIVE_TOPOLOGY_TYPE ConvertToD3D12TopologyType(D3D12_PRIMITIVE_TOPOLOGY primitiveType)
    {
        switch (primitiveType)
        {
        case D3D_PRIMITIVE_TOPOLOGY_POINTLIST:
            return D3D12_PRIMITIVE_TOPOLOGY_TYPE_POINT;
        case D3D_PRIMITIVE_TOPOLOGY_LINELIST:
        case D3D_PRIMITIVE_TOPOLOGY_LINESTRIP:
            return D3D12_PRIMITIVE_TOPOLOGY_TYPE_LINE;
        case D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST:
        case D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP:
            return D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
        default:
            Check9on12(false); // DX9 shouldn't trigger any other topologies
            return (D3D12_PRIMITIVE_TOPOLOGY_TYPE)-1;
        }
    }

    static bool IsTriangleFan(D3DPRIMITIVETYPE primitiveType)
    {
        return primitiveType == D3DPT_TRIANGLEFAN;
    }

    static D3D_PRIMITIVE_TOPOLOGY ConvertToD3D12Topology(D3DPRIMITIVETYPE primitiveType)
    {
        switch (primitiveType)
        {
        case D3DPT_POINTLIST:
            return D3D_PRIMITIVE_TOPOLOGY_POINTLIST;
        case D3DPT_LINELIST:
            return D3D_PRIMITIVE_TOPOLOGY_LINELIST;
        case D3DPT_LINESTRIP:
            return D3D_PRIMITIVE_TOPOLOGY_LINESTRIP;
        case D3DPT_TRIANGLELIST:
            return D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST;
        case D3DPT_TRIANGLESTRIP:
            return D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP;

        // We convert triangle fans into triangle fans
        case D3DPT_TRIANGLEFAN:
            return D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST;
        //case D3D_PT_ODD_TRIANGLE_STRIP:
        //case D3D_PT_TRIANGLE_FAN2:
        default:
            Check9on12(false); // Topologies not supported yet
            return (D3D_PRIMITIVE_TOPOLOGY)-1;
        }
    }

    static bool IsIntType(D3DDECLTYPE d3dDeclType)
    {
        switch (d3dDeclType)
        {
            case D3DDECLTYPE_FLOAT1       :
            case D3DDECLTYPE_FLOAT2       :
            case D3DDECLTYPE_FLOAT3       :
            case D3DDECLTYPE_FLOAT4       :
            case D3DDECLTYPE_D3DCOLOR     :
            case D3DDECLTYPE_FLOAT16_2:
            case D3DDECLTYPE_FLOAT16_4:
            //We are making the asumption that normalized values are floats
            case D3DDECLTYPE_UBYTE4N:
            case D3DDECLTYPE_SHORT2N:
            case D3DDECLTYPE_SHORT4N:
            case D3DDECLTYPE_USHORT2N:
            case D3DDECLTYPE_USHORT4N:
            case D3DDECLTYPE_DEC3N:
                return false;
            case D3DDECLTYPE_UDEC3:
            case D3DDECLTYPE_UBYTE4       :
            case D3DDECLTYPE_SHORT2       :
            case D3DDECLTYPE_SHORT4       :
                return true;
            default:
            case D3DDECLTYPE_UNUSED:
                Check9on12(false); 
                return false;
        }
    }

    static DXGI_FORMAT ConvertToDXGIFormat(D3DDECLTYPE d3dDeclType)
    {
        static const DXGI_FORMAT s_declTypeToDXGIFORMAT[] = {
            DXGI_FORMAT_R32_FLOAT,          // D3DDECLTYPE_FLOAT1  
            DXGI_FORMAT_R32G32_FLOAT,       // D3DDECLTYPE_FLOAT2  
            DXGI_FORMAT_R32G32B32_FLOAT,    // D3DDECLTYPE_FLOAT3  
            DXGI_FORMAT_R32G32B32A32_FLOAT, // D3DDECLTYPE_FLOAT4  
            DXGI_FORMAT_B8G8R8A8_UNORM,     // D3DDECLTYPE_D3DCOLOR  
            DXGI_FORMAT_R8G8B8A8_UINT,      // D3DDECLTYPE_UBYTE4  
            DXGI_FORMAT_R16G16_SINT,        // D3DDECLTYPE_SHORT2  
            DXGI_FORMAT_R16G16B16A16_SINT,  // D3DDECLTYPE_SHORT4  
            DXGI_FORMAT_R8G8B8A8_UNORM,     // D3DDECLTYPE_UBYTE4N  
            DXGI_FORMAT_R16G16_SNORM,       // D3DDECLTYPE_SHORT2N  
            DXGI_FORMAT_R16G16B16A16_SNORM, // D3DDECLTYPE_SHORT4N  
            DXGI_FORMAT_R16G16_UNORM,       // D3DDECLTYPE_USHORT2N  
            DXGI_FORMAT_R16G16B16A16_UNORM, // D3DDECLTYPE_USHORT4N  
            DXGI_FORMAT_R10G10B10A2_UINT,   // D3DDECLTYPE_UDEC3  
            DXGI_FORMAT_R10G10B10A2_UINT,   // D3DDECLTYPE_DEC3N  
            DXGI_FORMAT_R16G16_FLOAT,       // D3DDECLTYPE_FLOAT16_2  
            DXGI_FORMAT_R16G16B16A16_FLOAT, // D3DDECLTYPE_FLOAT16_4  
            DXGI_FORMAT_UNKNOWN,            // D3DDECLTYPE_UNUSED  
        };
        return s_declTypeToDXGIFORMAT[d3dDeclType];
    }

    static D3DFORMAT ConvertToD3DFORMAT(DXGI_FORMAT dxgiFormat)
    {
        switch ((DWORD)dxgiFormat)
        {
        case DXGI_FORMAT_UNKNOWN:
            return D3DFMT_UNKNOWN;
        case DXGI_FORMAT_A8_UNORM:
            return D3DFMT_A8;
        case DXGI_FORMAT_R8_UNORM:
            return D3DFMT_L8;
        case DXGI_FORMAT_R16_UNORM:
            return D3DFMT_L16;
        case DXGI_FORMAT_B5G6R5_UNORM:
            return D3DFMT_R5G6B5;
        case DXGI_FORMAT_B5G5R5A1_UNORM:
            return D3DFMT_A1R5G5B5;
        case DXGI_FORMAT_B8G8R8A8_UNORM:
        case DXGI_FORMAT_B8G8R8A8_UNORM_SRGB:
        case DXGI_FORMAT_B8G8R8A8_TYPELESS:
            return D3DFMT_A8R8G8B8;
        case DXGI_FORMAT_B8G8R8X8_UNORM:
        case DXGI_FORMAT_B8G8R8X8_UNORM_SRGB:
        case DXGI_FORMAT_B8G8R8X8_TYPELESS:
            return D3DFMT_X8R8G8B8;
        case DXGI_FORMAT_R8G8B8A8_UNORM:
        case DXGI_FORMAT_R8G8B8A8_TYPELESS:
        case DXGI_FORMAT_R8G8B8A8_UNORM_SRGB:
            return D3DFMT_A8B8G8R8;
        case DXGI_FORMAT_AYUV:
            return D3DFMT_AYUV;
        case DXGI_FORMAT_YUY2:
            return D3DFMT_YUY2;
        case DXGI_FORMAT_NV12:
            return D3DFORMAT(MAKEFOURCC('N', 'V', '1', '2'));
        case  DXGI_FORMAT_420_OPAQUE:
            return D3DFORMAT(MAKEFOURCC('4', '2', '0', 'O'));
        case DXGI_FORMAT_NV11:
            return D3DFORMAT(MAKEFOURCC('N', 'V', '1', '1'));
        case DXGI_FORMAT_AI44:
            return D3DFORMAT(MAKEFOURCC('A', 'I', '4', '4'));
        case DXGI_FORMAT_IA44:
            return D3DFORMAT(MAKEFOURCC('I', 'A', '4', '4'));
        case DXGI_FORMAT_Y410:
            return  D3DFORMAT(MAKEFOURCC('Y', '4', '1', '0'));
        case DXGI_FORMAT_Y416:
            return D3DFORMAT(MAKEFOURCC('Y', '4', '1', '6'));
        case DXGI_FORMAT_P010:
            return D3DFORMAT(MAKEFOURCC('P', '0', '1', '0'));
        case DXGI_FORMAT_P016:
            return D3DFORMAT(MAKEFOURCC('P', '0', '1', '6'));
        case DXGI_FORMAT_Y210:
            return D3DFORMAT(MAKEFOURCC('Y', '2', '1', '0'));
        case DXGI_FORMAT_Y216:
            return D3DFORMAT(MAKEFOURCC('Y', '2', '1', '6'));
        case DXGI_FORMAT_BC1_UNORM:
            return D3DFMT_DXT1;
        case DXGI_FORMAT_BC2_UNORM:
            return D3DFMT_DXT2;
        case DXGI_FORMAT_BC3_UNORM:
            return D3DFMT_DXT4;
        case DXGI_FORMAT_R8G8_SNORM:
        case DXGI_FORMAT_R8G8_TYPELESS:
            return D3DFMT_V8U8;
        case DXGI_FORMAT_D16_UNORM:
            return D3DFMT_D16;
        case DXGI_FORMAT_D32_FLOAT:
            return D3DFMT_D32F_LOCKABLE;
        case DXGI_FORMAT_D24_UNORM_S8_UINT:
            return D3DFMT_D24S8;
        case DXGI_FORMAT_R16G16B16A16_UNORM:
            return D3DFMT_A16B16G16R16;
        case DXGI_FORMAT_R16_FLOAT:
            return D3DFMT_R16F;
        case DXGI_FORMAT_R16G16_FLOAT:
            return D3DFMT_G16R16F;
        case DXGI_FORMAT_R16G16B16A16_FLOAT:
            return D3DFMT_A16B16G16R16F;
        case DXGI_FORMAT_R32_FLOAT:
            return D3DFMT_R32F;
        case DXGI_FORMAT_R32G32_FLOAT:
            return D3DFMT_G32R32F;
        case DXGI_FORMAT_R32G32B32A32_FLOAT:
            return D3DFMT_A32B32G32R32F;
        case DXGI_FORMAT_R10G10B10A2_UNORM:
            return D3DFMT_A2B10G10R10;
        case DXGI_FORMAT_R16G16_UNORM:
            return D3DFMT_G16R16;
        case DXGI_FORMAT_R16G16_SNORM:
            return D3DFMT_V16U16;
        case DXGI_FORMAT_R8G8B8A8_SNORM:
            return D3DFMT_Q8W8V8U8;
        case DXGI_FORMAT_R16G16B16A16_SNORM:
            return D3DFMT_Q16W16V16U16;
        case DXGI_FORMAT_B4G4R4A4_UNORM:
            return D3DFMT_A4R4G4B4;
        case DXGI_FORMAT_R8G8_UNORM:
            return D3DFMT_A8L8;
        // Can't convert DXGI_FORMAT_R16G16_TYPELESS because it could either bet D3DFMT_G16R16 or D3DFMT_V16U16
        case DXGI_FORMAT_R16G16_TYPELESS:
        default:
            // Do nothing        
            Check9on12(false);
            return D3DFMT_UNKNOWN;
        }

    }

    static D3DDDIFORMAT ConvertD3DFormatToDDIFormat(D3DFORMAT format)
    {
        // These enums map 1-1 so this is a safe cast
        return (D3DDDIFORMAT)format;
    }

    static D3DDDIFORMAT ConvertFromDXGIFormatToD3DDDIFormat(DXGI_FORMAT dxgiFormat)
    {
        return ConvertD3DFormatToDDIFormat(ConvertToD3DFORMAT(dxgiFormat));
    }

    static D3D12TranslationLayer::AppResourceDesc ConvertToAppResourceDesc(const D3D12_RESOURCE_DESC &desc12, D3D12TranslationLayer::RESOURCE_USAGE Usage, DWORD Access, DWORD BindFlags)
    {
        UINT16 depth = desc12.Dimension != D3D12_RESOURCE_DIMENSION_TEXTURE3D ? 1 : desc12.DepthOrArraySize;
        UINT16 arraySize = desc12.Dimension == D3D12_RESOURCE_DIMENSION_TEXTURE3D ? 1 : desc12.DepthOrArraySize;
        UINT8 nonOpaquePlaneCount = (UINT8)CD3D11FormatHelper::NonOpaquePlaneCount(desc12.Format);
        UINT numSubresources = desc12.MipLevels * arraySize * nonOpaquePlaneCount;

        return D3D12TranslationLayer::AppResourceDesc(
            desc12.MipLevels * arraySize,
            nonOpaquePlaneCount,
            numSubresources,
            (UINT8)desc12.MipLevels,
            arraySize,
            depth,
            (UINT)desc12.Width,
            (UINT)desc12.Height,
            desc12.Format,
            desc12.SampleDesc.Count,
            desc12.SampleDesc.Quality,
            Usage,
            (D3D12TranslationLayer::RESOURCE_CPU_ACCESS)Access,
            (D3D12TranslationLayer::RESOURCE_BIND_FLAGS)BindFlags,
            desc12.Dimension);
    }

    static UINT ConvertTranslationLayerBindFlagsToD3D11BindFlags(UINT flags)
    {
        UINT d3d11Flags = 0;
        if (flags & D3D12TranslationLayer::RESOURCE_BIND_VERTEX_BUFFER    ) d3d11Flags |= D3D11_BIND_VERTEX_BUFFER;
        if (flags & D3D12TranslationLayer::RESOURCE_BIND_INDEX_BUFFER     ) d3d11Flags |= D3D11_BIND_INDEX_BUFFER;
        if (flags & D3D12TranslationLayer::RESOURCE_BIND_CONSTANT_BUFFER  ) d3d11Flags |= D3D11_BIND_CONSTANT_BUFFER;
        if (flags & D3D12TranslationLayer::RESOURCE_BIND_SHADER_RESOURCE  ) d3d11Flags |= D3D11_BIND_SHADER_RESOURCE;
        if (flags & D3D12TranslationLayer::RESOURCE_BIND_STREAM_OUTPUT    ) d3d11Flags |= D3D11_BIND_STREAM_OUTPUT;
        if (flags & D3D12TranslationLayer::RESOURCE_BIND_RENDER_TARGET    ) d3d11Flags |= D3D11_BIND_RENDER_TARGET;
        if (flags & D3D12TranslationLayer::RESOURCE_BIND_DEPTH_STENCIL    ) d3d11Flags |= D3D11_BIND_DEPTH_STENCIL;
        if (flags & D3D12TranslationLayer::RESOURCE_BIND_UNORDERED_ACCESS ) d3d11Flags |= D3D11_BIND_UNORDERED_ACCESS;
        if (flags & D3D12TranslationLayer::RESOURCE_BIND_DECODER          ) d3d11Flags |= D3D11_BIND_DECODER;
        if (flags & D3D12TranslationLayer::RESOURCE_BIND_VIDEO_ENCODER    ) d3d11Flags |= D3D11_BIND_VIDEO_ENCODER;

        return d3d11Flags;
    }

    static D3D12TranslationLayer::ResourceCreationArgs GetCreateArgsFromExistingResource(ID3D12Device *pDevice, const D3D12_RESOURCE_DESC &desc12)
    {
        D3D12TranslationLayer::ResourceCreationArgs CreateArgs{};
        CreateArgs.m_desc12 = desc12;
        UINT bindFlags = 0;

        // TODO:  #11976715 Workaround for a bug where the surface we get back from DWM has a invalid desc (alignment must be
        // D3D12_DEFAULT_RESOURCE_PLACEMENT_ALIGNMENT for resources with ALLOW_RENDER_TARGET/DEPTH_STENCIL, 4096 instead). 
        // Working around this by putting a "correct" alignment
        if ((desc12.Flags & (D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET | D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL)) && desc12.Alignment == 4096)
        {
            CreateArgs.m_desc12.Alignment = 0;
        }

        if (CreateArgs.m_desc12.Flags & D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET)
        {
            bindFlags |= D3D12TranslationLayer::RESOURCE_BIND_RENDER_TARGET;
        }

        if (CreateArgs.m_desc12.Flags & D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL)
        {
            bindFlags |= D3D12TranslationLayer::RESOURCE_BIND_DEPTH_STENCIL;
        }

        if ((CreateArgs.m_desc12.Flags & D3D12_RESOURCE_FLAG_DENY_SHADER_RESOURCE) == 0)
        {
            bindFlags |= D3D12TranslationLayer::RESOURCE_BIND_SHADER_RESOURCE;
        }

        CreateArgs.m_appDesc = ConvertToAppResourceDesc(CreateArgs.m_desc12,
            D3D12TranslationLayer::RESOURCE_USAGE_DEFAULT,
            (D3D12TranslationLayer::RESOURCE_CPU_ACCESS)0,
            (D3D12TranslationLayer::RESOURCE_BIND_FLAGS)bindFlags);
        CreateArgs.m_heapDesc = CD3DX12_HEAP_DESC(pDevice->GetResourceAllocationInfo(0, 1, &CreateArgs.m_desc12), D3D12_HEAP_TYPE_DEFAULT);
        CreateArgs.m_bBoundForStreamOut = false;
        CreateArgs.m_isPlacedTexture = 0;
        CreateArgs.m_OffsetToStreamOutputSuffix = 0;

        return CreateArgs;
    }

    static D3D12TranslationLayer::ResourceCreationArgs GetCreateBufferArgs(ID3D12Device *pDevice, size_t SizeInBytes, size_t AlignmentRequired, D3D12_HEAP_TYPE heapType)
    {
        D3D12TranslationLayer::RESOURCE_CPU_ACCESS cpuAccess;
        D3D12TranslationLayer::RESOURCE_USAGE usage;
        if (heapType == D3D12_HEAP_TYPE_READBACK)
        {
            cpuAccess = D3D12TranslationLayer::RESOURCE_CPU_ACCESS_READ;
            usage = D3D12TranslationLayer::RESOURCE_USAGE_STAGING;
        }
        else
        {
            cpuAccess = D3D12TranslationLayer::RESOURCE_CPU_ACCESS_WRITE;
            usage = D3D12TranslationLayer::RESOURCE_USAGE_DYNAMIC;
        }

        D3D12TranslationLayer::ResourceCreationArgs args{};
        AlignmentRequired = Align(AlignmentRequired, D3D12_DEFAULT_RESOURCE_PLACEMENT_ALIGNMENT);
        args.m_desc12 = CD3DX12_RESOURCE_DESC::Buffer(SizeInBytes, D3D12_RESOURCE_FLAG_NONE, AlignmentRequired);
        UINT BindFlags = D3D12TranslationLayer::RESOURCE_BIND_INDEX_BUFFER | D3D12TranslationLayer::RESOURCE_BIND_CONSTANT_BUFFER | D3D12TranslationLayer::RESOURCE_BIND_VERTEX_BUFFER;
        args.m_appDesc = ConvertToAppResourceDesc(args.m_desc12, usage, cpuAccess, (D3D12TranslationLayer::RESOURCE_BIND_FLAGS)BindFlags);
        args.m_heapDesc = CD3DX12_HEAP_DESC(pDevice->GetResourceAllocationInfo(0, 1, &args.m_desc12), CD3DX12_HEAP_PROPERTIES(heapType));

        return args;
    }

    static D3D12TranslationLayer::ResourceCreationArgs GetCreateReadbackBufferArgs(ID3D12Device *pDevice, size_t SizeInBytes, size_t AlignmentRequired)
    {
        return GetCreateBufferArgs(pDevice, SizeInBytes, AlignmentRequired, D3D12_HEAP_TYPE_READBACK);
    }

    static D3D12TranslationLayer::ResourceCreationArgs GetCreateUploadBufferArgs(ID3D12Device *pDevice, size_t SizeInBytes, size_t AlignmentRequired)
    {
        return GetCreateBufferArgs(pDevice, SizeInBytes, AlignmentRequired, D3D12_HEAP_TYPE_UPLOAD);
    }

    static D3D10_REGISTER_COMPONENT_TYPE ConvertToRegisterComponentType(D3DDECLTYPE d3dDeclType)
    {
        switch (d3dDeclType)
        {
             case D3DDECLTYPE_FLOAT1      :
             case D3DDECLTYPE_FLOAT2      :
             case D3DDECLTYPE_FLOAT3      :
             case D3DDECLTYPE_FLOAT4      :
             case D3DDECLTYPE_FLOAT16_2:
             case D3DDECLTYPE_FLOAT16_4:
             case D3DDECLTYPE_D3DCOLOR:
             case D3DDECLTYPE_UBYTE4N:
             case D3DDECLTYPE_USHORT2N:
             case D3DDECLTYPE_USHORT4N:
             case D3DDECLTYPE_SHORT2N:
             case D3DDECLTYPE_SHORT4N:
             case D3DDECLTYPE_DEC3N:
                 return D3D10_REGISTER_COMPONENT_FLOAT32;
             case D3DDECLTYPE_UBYTE4      :
             case D3DDECLTYPE_UDEC3       :
                 return D3D10_REGISTER_COMPONENT_UINT32;
             case D3DDECLTYPE_SHORT2:
             case D3DDECLTYPE_SHORT4:
                 return D3D10_REGISTER_COMPONENT_SINT32;
             case D3DDECLTYPE_UNUSED:
            default:
                Check9on12(false); // TODO: Unsure what these fall under
                return D3D10_REGISTER_COMPONENT_UNKNOWN;
        }
    }

    static D3D12TranslationLayer::RESOURCE_USAGE GetResourceUsage(D3DDDI_RESOURCEFLAGS flags, UINT cpuAccessFlags)
    {
        if (flags.DecodeCompressedBuffer)
        {
            return D3D12TranslationLayer::RESOURCE_USAGE_DYNAMIC;
        }
        else if(cpuAccessFlags & (D3D12TranslationLayer::RESOURCE_CPU_ACCESS_READ | D3D12TranslationLayer::RESOURCE_CPU_ACCESS_WRITE))
        {
            return  D3D12TranslationLayer::RESOURCE_USAGE_DYNAMIC;
        }
        else
        {
            return D3D12TranslationLayer::RESOURCE_USAGE_DEFAULT;
        }
    }

    // Returns a mask that represents which color channels that shader will use
    // (i.e. Using just color channels R and G would return the bitmask 0011).
    static BYTE ConvertToMask(D3DDECLTYPE d3dDeclType)
    {
        switch (d3dDeclType)
        {
        case D3DDECLTYPE_FLOAT1:
            return R_MASK;
        case D3DDECLTYPE_FLOAT2:
        case D3DDECLTYPE_FLOAT16_2:
        case D3DDECLTYPE_USHORT2N:
        case D3DDECLTYPE_SHORT2N:
        case D3DDECLTYPE_SHORT2:
            return RG_MASK;
        case D3DDECLTYPE_UDEC3:
        case D3DDECLTYPE_DEC3N:
        case D3DDECLTYPE_FLOAT3:
            return RGB_MASK;
        case D3DDECLTYPE_SHORT4N:
        case D3DDECLTYPE_SHORT4:
        case D3DDECLTYPE_FLOAT4:
        case D3DDECLTYPE_UBYTE4:
        case D3DDECLTYPE_FLOAT16_4:
        case D3DDECLTYPE_UBYTE4N:
        case D3DDECLTYPE_USHORT4N:
        case D3DDECLTYPE_D3DCOLOR:
            return RGBA_MASK;
        case D3DDECLTYPE_UNUSED:
        default:
            Check9on12(false); // TODO: Unsure what these fall under
            return 0;
        }
    }

    static BYTE ConvertToRWMask(D3DDECLTYPE d3dDeclType)
    {
        switch (d3dDeclType)
        {
        case D3DDECLTYPE_FLOAT1:
            return R_MASK;
        case D3DDECLTYPE_FLOAT2:
        case D3DDECLTYPE_FLOAT16_2:
        case D3DDECLTYPE_USHORT2N:
        case D3DDECLTYPE_SHORT2N:
        case D3DDECLTYPE_SHORT2:
            return RG_MASK;
        case D3DDECLTYPE_UDEC3:
        case D3DDECLTYPE_DEC3N:
        case D3DDECLTYPE_FLOAT3:
            return RGB_MASK;
        case D3DDECLTYPE_SHORT4N:
        case D3DDECLTYPE_SHORT4:
        case D3DDECLTYPE_FLOAT4:
        case D3DDECLTYPE_UBYTE4:
        case D3DDECLTYPE_FLOAT16_4:
        case D3DDECLTYPE_UBYTE4N:
        case D3DDECLTYPE_USHORT4N:
        case D3DDECLTYPE_D3DCOLOR:
            return RGBA_MASK;
        case D3DDECLTYPE_UNUSED:
        default:
            Check9on12(false); // TODO: Unsure what these fall under
            return 0;
        }
    }

    static D3D_REGISTER_COMPONENT_TYPE ConvertToComponentType(D3DDECLUSAGE usage)
    {
        //  D3D9 can only work in floats, VFACE (a.k.a. IsFrontFace) is the only exception
        if (usage == D3DDECLUSAGE_VFACE)
        {
            return D3D_REGISTER_COMPONENT_UINT32;
        }
        return D3D_REGISTER_COMPONENT_FLOAT32;
    }

    static D3D10_NAME ConvertToName(D3DDECLUSAGE usage)
    {
        switch (usage)
        {
        case D3DDECLUSAGE_VPOS:
        case D3DDECLUSAGE_POSITION:
            return D3D10_NAME_POSITION;
        case D3DDECLUSAGE_CLIPDISTANCE:
            return D3D10_NAME_CLIP_DISTANCE;
        case D3DDECLUSAGE_VFACE:
            return D3D_NAME_IS_FRONT_FACE;
        case D3DDECLUSAGE_DEPTH:
        case D3DDECLUSAGE_TEXCOORD:
        case D3DDECLUSAGE_COLOR:
        case D3DDECLUSAGE_NORMAL:
        case D3DDECLUSAGE_TANGENT:
        case D3DDECLUSAGE_BLENDWEIGHT:
        case D3DDECLUSAGE_BLENDINDICES:
        case D3DDECLUSAGE_FOG:
        case D3DDECLUSAGE_SAMPLE:
        case D3DDECLUSAGE_PSIZE:
        case D3DDECLUSAGE_BINORMAL:
        case D3DDECLUSAGE_TESSFACTOR:
        case D3DDECLUSAGE_POINTSPRITE:
            return D3D10_NAME_UNDEFINED;
        case D3DDECLUSAGE_POSITIONT:
        default:
            // Verify if this should be getting past the FFconversion layer
            Check9on12(false);
            return D3D10_NAME_UNDEFINED;
        }
    }

    // Returns the semantic name without any number appended at the end
    static const char *ConvertToSemanticNameForInputLayout(D3DDECLUSAGE usage)
    {
        switch (usage)
        {
        case D3DDECLUSAGE_POSITION:
            return "POSITION";
        case D3DDECLUSAGE_TEXCOORD:
            return "TEXCOORD";
        case D3DDECLUSAGE_COLOR:
            return "COLOR";
        case D3DDECLUSAGE_NORMAL:
            return "NORMAL";
        case D3DDECLUSAGE_TANGENT:
            return "TANGENT";
        case D3DDECLUSAGE_BLENDWEIGHT:
            return "BLENDWEIGHT";
        case D3DDECLUSAGE_BLENDINDICES:
            return "BLENDINDICES";
        case D3DDECLUSAGE_PSIZE:
            return "PSIZE";
        case D3DDECLUSAGE_BINORMAL:
            return "BINORMAL";
        case D3DDECLUSAGE_TESSFACTOR:
            return "TESSFACTOR";
        case D3DDECLUSAGE_FOG:
            return "FOG";
        case D3DDECLUSAGE_DEPTH:
            return "DEPTH";
        case D3DDECLUSAGE_SAMPLE:
            return "SAMPLE";
        case D3DDECLUSAGE_POSITIONT:
        default:
            Check9on12(false);
            return "";
        }
    }

    static const char *ConvertToSemanticNameForDXBCLinkage(D3DDECLUSAGE usage)
    {
        switch (usage)
        {
        case D3DDECLUSAGE_VPOS:
        case D3DDECLUSAGE_POSITION:
            return "SV_POSITION";
        case D3DDECLUSAGE_TEXCOORD:
            return "TEXCOORD";
        case D3DDECLUSAGE_COLOR:
            return "COLOR";
        case D3DDECLUSAGE_NORMAL:
            return "NORMAL";
        case D3DDECLUSAGE_TANGENT:
            return "TANGENT";
        case D3DDECLUSAGE_BLENDWEIGHT:
            return "BLENDWEIGHT";
        case D3DDECLUSAGE_BLENDINDICES:
            return "BLENDINDICES";
        case D3DDECLUSAGE_PSIZE:
            return "PSIZE";
        case D3DDECLUSAGE_BINORMAL:
            return "BINORMAL";
        case D3DDECLUSAGE_TESSFACTOR:
            return "TESSFACTOR";
        case D3DDECLUSAGE_FOG:
            return "FOG";
        case D3DDECLUSAGE_DEPTH:
            return "DEPTH";
        case D3DDECLUSAGE_SAMPLE:
            return "SAMPLE";
        case D3DDECLUSAGE_CLIPDISTANCE:
            return "SV_ClipDistance";
        case D3DDECLUSAGE_POINTSPRITE:
            return "POINTSPRITE";
        case D3DDECLUSAGE_VFACE:
            return "SV_IsFrontFace";
        case D3DDECLUSAGE_POSITIONT:
        default:
            Check9on12(false);
            return "";
        }
    }

    static ShaderConv::TEXTURETYPE ConvertShaderResourceDimensionToTextureType(D3D12_SRV_DIMENSION dim)
    {
        switch (dim)
        {
            case D3D12_SRV_DIMENSION_TEXTURE2D:
            case D3D12_SRV_DIMENSION_TEXTURE2DMS:
                return ShaderConv::TEXTURETYPE_2D;
            case D3D12_SRV_DIMENSION_TEXTURE3D:
                return ShaderConv::TEXTURETYPE_VOLUME;
            case D3D12_SRV_DIMENSION_TEXTURECUBE:
                return ShaderConv::TEXTURETYPE_CUBE;
            case D3D12_SRV_DIMENSION_BUFFER:
            case D3D12_SRV_DIMENSION_UNKNOWN:
            case D3D12_SRV_DIMENSION_TEXTURE1D:
            case D3D12_SRV_DIMENSION_TEXTURE2DARRAY:
            case D3D12_SRV_DIMENSION_TEXTURE2DMSARRAY:
            case D3D12_SRV_DIMENSION_TEXTURECUBEARRAY:
            case D3D12_SRV_DIMENSION_TEXTURE1DARRAY:
            default:
                Check9on12(false); // Unsupported SRV dimension
                return ShaderConv::TEXTURETYPE_UNKNOWN;
        }
    }

    static void ConvertToRGBA(DWORD dwValueIn, FLOAT vOut[4])
    {
        vOut[0] = ((dwValueIn >> 16) & 0xFF) / 255.0f;
        vOut[1] = ((dwValueIn >> 8) & 0xFF) / 255.0f;
        vOut[2] = ((dwValueIn >> 0) & 0xFF) / 255.0f;
        vOut[3] = ((dwValueIn >> 24) & 0xFF) / 255.0f;
    }

    static void ConvertToRGB(DWORD dwValueIn, FLOAT vOut[3])
    {
        vOut[0] = ((dwValueIn >> 16) & 0xFF) / 255.0f;
        vOut[1] = ((dwValueIn >> 8) & 0xFF) / 255.0f;
        vOut[2] = ((dwValueIn >> 0) & 0xFF) / 255.0f;
    }

    static float ConvertToFloat(DWORD dwValueIn)
    {
        return (dwValueIn & 0xFF) / 255.0f;
    }

    // DX9 combined both the specified shader and shader register into a single DWORD
    static void ConvertDX9TextureIndexToShaderStageAndRegisterIndex(_In_ DWORD dwStage, _Out_ D3D12TranslationLayer::EShaderStage &shaderStage, _Out_ DWORD &shaderRegister)
    {
        if (dwStage < MAX_PIXEL_SAMPLERS)
        {
            shaderStage = D3D12TranslationLayer::e_PS;
            shaderRegister = dwStage;
        }
        else if ((dwStage >= VERTEX_SAMPLER0) && (dwStage < (VERTEX_SAMPLER0 + D3DHAL_SAMPLER_MAXVERTEXSAMP)))
        {
            shaderStage = D3D12TranslationLayer::e_VS;;
            shaderRegister = dwStage - VERTEX_SAMPLER0;
        }
        else
        {
            Check9on12(false);
        }
    }

    static DXGI_FORMAT ConvertStrideToIndexBufferFormat(UINT stride)
    {
        switch (stride)
        {
        case 2:
            return DXGI_FORMAT_R16_UINT;
        case 4:
            return DXGI_FORMAT_R32_UINT;
        default:
            Check9on12(false);
            return DXGI_FORMAT_UNKNOWN;
        }
    }

    static UINT CalcVertexCount(D3DPRIMITIVETYPE primitiveType, UINT primitiveCount)
    {
        switch (primitiveType)
        {
        case D3DPT_POINTLIST:
            return primitiveCount;
        case D3DPT_LINELIST:
            return primitiveCount * 2;
        case D3DPT_LINESTRIP:
            return primitiveCount + 1;
        case D3DPT_TRIANGLELIST:
            return primitiveCount * 3;
        case D3DPT_TRIANGLESTRIP:
            return primitiveCount + 2;
        case D3DPT_TRIANGLEFAN:
            return primitiveCount + 2;
        }
        return 0;
    }

    static D3D12_RESOURCE_STATES GetDefaultResourceState(D3D12_HEAP_TYPE heapType)
    {
        switch (heapType)
        {
        case D3D12_HEAP_TYPE_READBACK:
            return D3D12_RESOURCE_STATE_COPY_DEST;
        case D3D12_HEAP_TYPE_UPLOAD:
            return D3D12_RESOURCE_STATE_GENERIC_READ;
        default:
            return D3D12_RESOURCE_STATE_COMMON;
        }
    }

    static UINT8 GetBlockWidth(DXGI_FORMAT format)
    {
        if (IsBlockCompressedFormat(format))
        {
            return 4;
        }
        else
        {
            return 1;
        }

    }


    static UINT8 GetBytesPerUnit(DXGI_FORMAT format)
    {
        return static_cast<UINT8>(CD3D11FormatHelper::GetBitsPerUnit(format) / 8);
    }

    static UINT DepthBiasFactorFromDSVFormat(DXGI_FORMAT dxgiFormat)
    {
        switch (dxgiFormat)
        {
        default:
            Check9on12(false);
            return 0;
        case DXGI_FORMAT_D32_FLOAT_S8X24_UINT:
        case DXGI_FORMAT_D32_FLOAT:
            return 1 << 23;
        case DXGI_FORMAT_D16_UNORM:
            return 1 << 16;
        case DXGI_FORMAT_D24_UNORM_S8_UINT:
            return 1 << 24;
        }
    }

    static D3D12_FILTER_TYPE ConvertD3D9GenMipsFilterType(D3DDDITEXTUREFILTERTYPE filterType)
    {
        switch (filterType)
        {
        case D3DDDITEXF_NONE:    // filtering disabled (valid for mip filter only)
        case D3DDDITEXF_POINT:    // nearest
            return D3D12_FILTER_TYPE_POINT;
        case D3DDDITEXF_LINEAR:    // linear interpolation
        case D3DDDITEXF_ANISOTROPIC:    // anisotropic
            return D3D12_FILTER_TYPE_LINEAR;
            break;
        case D3DDDITEXF_PYRAMIDALQUAD:    // 4-sample tent
        case D3DDDITEXF_GAUSSIANQUAD:    // 4-sample gaussian
        default:
            Check9on12(false); //TODO: will we need a custom sample pattern?
            return (D3D12_FILTER_TYPE)-1;
        }
    }

    static D3D12_FILTER ConvertD3D9FilterType(D3DDDITEXTUREFILTERTYPE filterType)
    {
        D3D12_FILTER filterD3D12 = D3D12_FILTER_MIN_MAG_MIP_POINT;

        switch (filterType)
        {
        case D3DDDITEXF_NONE:    // filtering disabled (valid for mip filter only)
        case D3DDDITEXF_POINT:    // nearest
            filterD3D12 = D3D12_FILTER_MIN_MAG_MIP_POINT;
            break;
        case D3DDDITEXF_LINEAR:    // linear interpolation
            filterD3D12 = D3D12_FILTER_MIN_MAG_MIP_LINEAR;
            break;
        case D3DDDITEXF_ANISOTROPIC:    // anisotropic
            filterD3D12 = D3D12_FILTER_ANISOTROPIC;
            break;
        case D3DDDITEXF_PYRAMIDALQUAD:    // 4-sample tent
        case D3DDDITEXF_GAUSSIANQUAD:    // 4-sample gaussian
        default:
            Check9on12(false); //TODO: will we need a custom sample pattern?
        }

        return filterD3D12;
    }

    template<typename DataType>
    static bool IsLockingSubrange(const DataType &LockFlags)
    {
        return LockFlags.AreaValid || LockFlags.BoxValid || LockFlags.RangeValid;
    }

    static D3DDDI_LOCKFLAGS convertAsyncFlags(D3DDDI_LOCKASYNCFLAGS asyncFlags)
    {
        D3DDDI_LOCKFLAGS flags;

        flags.NoOverwrite = asyncFlags.NoOverwrite;
        flags.Discard = asyncFlags.Discard;
        flags.RangeValid = asyncFlags.RangeValid;
        flags.AreaValid = asyncFlags.AreaValid;
        flags.BoxValid = asyncFlags.BoxValid;
        flags.NotifyOnly = asyncFlags.NotifyOnly;

        //TODO: the following flags is not being taken in consideration in this conversion.
        //asyncFlags.NoExistingReferences

        return flags;
    }


    static D3D12TranslationLayer::MAP_TYPE GetMapTypeFlag(bool lockReadOnly, bool lockWriteOnly, bool lockDiscard, bool lockNoOverwrite, bool videoCompressedBuffer, D3D12TranslationLayer::RESOURCE_CPU_ACCESS CPUAccessFlag)
    {
        UNREFERENCED_PARAMETER(lockWriteOnly);

        if (lockDiscard &&  videoCompressedBuffer)
        {
            return D3D12TranslationLayer::MAP_TYPE_WRITE_DISCARD;
        }

        bool bIsWrite = !lockReadOnly && (CPUAccessFlag & D3D12TranslationLayer::RESOURCE_CPU_ACCESS_WRITE);
        // TODO: (11369816) Any map involving a read resource is demoted to READWRITE map. If we find apps that 
        // frequently hit this path, we'll need to support the odd semantics of nooverwrite/discard
        // on a cpu readable resource
        bool bIsRead = (CPUAccessFlag & D3D12TranslationLayer::RESOURCE_CPU_ACCESS_READ);

        if (bIsWrite)
        {
            if (bIsRead)
            {
                return D3D12TranslationLayer::MAP_TYPE_READWRITE;
            }
            else
            {
                if (lockDiscard)
                {
                    return D3D12TranslationLayer::MAP_TYPE_WRITE_DISCARD;
                }
                else if (lockNoOverwrite)
                {
                    return D3D12TranslationLayer::MAP_TYPE_WRITE_NOOVERWRITE;
                }
                else
                {
                    return D3D12TranslationLayer::MAP_TYPE_WRITE;
                }
            }
        }
        else if (bIsRead)
        {
            return D3D12TranslationLayer::MAP_TYPE_READ;
        }
        else
        {
            // If an app requests to read from a vertex or index buffer,
            // they can just go ahead and read. However, there are some apps that
            // write to buffers that they locked read-only anyway, so we'll make this
            // a synchronizing map for write.
            return D3D12TranslationLayer::MAP_TYPE_WRITE;
        }
    }

    typedef std::bitset<MAX_RENDER_TARGETS> RTVBitMask;

    struct WeakHash
    {
        WeakHash(UINT32 value) :m_data(value){}

        WeakHash() :m_data(0){}

        bool operator==(const WeakHash& other) const { return other.m_data == m_data; }

        WeakHash& operator=(const UINT32 value)
        {
            m_data = value;
            return *this;
        }

        //Required for stl map
        struct Hasher{
            size_t operator()(WeakHash const& other) const { return size_t(other.m_data); }
        };

        static WeakHash GetHashForEmptyObject() { return WeakHash(1); }

        bool Initialized() { return m_data != 0; }

        UINT32 m_data;
    };

    //+---------------------------------------------------------------------------
    //
    //  Copyright (c) Microsoft, 2011. All rights reserved.
    //
    //  Contents:   Implementation of 32 bit Cyclic Redundancy Check.  This is the same
    //              as implementation as in Base\ntos\rtl\checksum.c
    //
    //  Author:     Niklas Borson (niklasb@microsoft.com)
    //
    //  History:    05-19-2011   niklasb    Created
    //
    //----------------------------------------------------------------------------


    //
    // This is the precomputed data table for the CRC32 algorithm as specified
    // in IS0 3309. See RFC-1662 and RFC-1952 for implementation details and
    // references.
    namespace
    {
        static const UINT32 g_crcLookupTable[] = {
            0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
            0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
            0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
            0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
            0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
            0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
            0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
            0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
            0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
            0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
            0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
            0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
            0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
            0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
            0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
            0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
            0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
            0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
            0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
            0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
            0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
            0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
            0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
            0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
            0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
            0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
            0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
            0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
            0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
            0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
            0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
            0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
            0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
            0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
            0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
            0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
            0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
            0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
            0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
            0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
            0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
            0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
            0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
        };

    } // end anonymous namespace

    // ComputeCrc32 - Compute the CRC32 as specified in in IS0 3309.
    //      See RFC-1662 and RFC-1952 for implementation details and references.
    //
    // The partialCrc is the result from a previous call, if computing the CRC
    // for non-contiguous data. On the first call, this parameter should be zero.
    //
    static UINT32 ComputeCrc32(_In_reads_bytes_(length) const void* buffer, _In_ size_t length, _In_ UINT32 partialCrc = 0)
    {
        auto pfnCalcCrcForUINT32 = [](UINT32 crc, UINT32 data) { return g_crcLookupTable[(crc ^ data) & 0xff] ^ (crc >> 8); };
        UINT32 crc = ~partialCrc;

        UINT32* data = (UINT32*)buffer;
        const size_t iterations = length / sizeof(UINT32);
        for (size_t i = 0; i < iterations; i++)
        {
            crc = pfnCalcCrcForUINT32(crc, data[i]);
        }

        const size_t uint8Iterations = length % sizeof(UINT32);
        if (uint8Iterations)
        {
            UINT8* remainderData = (UINT8 *)(&data[iterations]);
            UINT32 combinedRemainderData = 0;
            for (size_t i = 0; i < uint8Iterations; i++)
            {
                combinedRemainderData |= remainderData[i] << (i * 8);
            }
            crc = pfnCalcCrcForUINT32(crc, combinedRemainderData);
        }

        return ~crc;
    }

    // Note that cpuid instruction is not support on some older CPUs. This
    // is fine given that this test will not produce results in any reasonable
    // amount of time on such processors.
    static bool CanUseSSE4_2()
    {
#if (_M_IX86 || _M_AMD64 )
        int cpu_info[4] = {};

        __cpuid(cpu_info, 1);

        return (cpu_info[2] >> 20) & 1;
#else
        return false;
#endif /* (_M_IX86 || _M_AMD64 ) */
    }

    static const bool g_cUseSSE4_2 = CanUseSSE4_2();

    static WeakHash HashData(_In_reads_bytes_(numBytes) const void* data, _In_ size_t numBytes, _In_ WeakHash hash = 0)
    {
#if (_M_IX86 || _M_AMD64) && !defined(_M_HYBRID_X86_ARM64)
        const size_t SSE4_CRC_ALIGNEMENT = sizeof(SSE4_CRC_INPUT_TYPE);
        if (g_cUseSSE4_2)
        {
            const size_t roundingIterations = (numBytes & (SSE4_CRC_ALIGNEMENT - 1));
            UINT8* unalignedData = (UINT8*)data;
            for (size_t i = 0; i < roundingIterations; i++)
            {
                hash = _mm_crc32_u8(hash.m_data, unalignedData[i]);
            }
            unalignedData += roundingIterations;
            numBytes -= roundingIterations;

            SSE4_CRC_INPUT_TYPE* alignedData = (SSE4_CRC_INPUT_TYPE*)unalignedData;
            Check9on12((numBytes % SSE4_CRC_ALIGNEMENT) == 0);
            const size_t numIterations = (numBytes / SSE4_CRC_ALIGNEMENT);
            for (size_t i = 0; i < numIterations; i++)
            {
                hash = (UINT32)SSE4_CRC_FUNCTION((SSE4_CRC_INPUT_TYPE)hash.m_data, alignedData[i]);
            }

            return WeakHash(hash);
        }
        else
        {
            return WeakHash(ComputeCrc32(data, numBytes, hash.m_data));
        }
#else
        return WeakHash(ComputeCrc32(data, numBytes, hash.m_data));
#endif
    }

    enum OffsetType {OFFSET_IN_BYTES, OFFSET_IN_VERTICES, OFFSET_IN_INDICES};
    class OffsetArg
    {
    public:
        OffsetType m_type;

        static OffsetArg AsOffsetInVertices(INT offsetInVertices)
        {
            OffsetArg offset;
            offset.m_type = OFFSET_IN_VERTICES;
            offset.m_offsetInVertices = offsetInVertices;
            return offset;
        }

        static OffsetArg AsOffsetInBytes(INT offsetInBytes)
        {
            OffsetArg offset;
            offset.m_type = OFFSET_IN_BYTES;
            offset.m_offsetInBytes = offsetInBytes;
            return offset;
        }

        static OffsetArg AsOffsetInIndices(UINT offsetInIndicies)
        {
            OffsetArg offset;
            offset.m_type = OFFSET_IN_INDICES;
            offset.m_offsetInIndices = offsetInIndicies;
            return offset;
        }

        INT GetOffsetInBytes() { Check9on12(m_type == OffsetType::OFFSET_IN_BYTES); return m_offsetInBytes; };
        INT GetOffsetInVertices() { Check9on12(m_type == OffsetType::OFFSET_IN_VERTICES); return m_offsetInVertices; };
        UINT GetOffsetInIndices() { Check9on12(m_type == OffsetType::OFFSET_IN_INDICES); return m_offsetInIndices; };
    private:
        union
        {
            INT m_offsetInBytes;
            INT m_offsetInVertices;
            UINT m_offsetInIndices;
        };

    };
};

```

`include/9on12VertexStage.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#pragma once

namespace D3D9on12
{
    class Device;
    class VertexShader;
    struct D3D12VertexShader;

    class VertexStage
    {
    public:
        VertexStage(Device& device, PipelineStateDirtyFlags& pipelineStateDirtyFlags, RasterStatesWrapper& rasterStates);

        void SetVertexShader(VertexShader* pShader);

        void SetClipPlane(_In_ CONST D3DDDIARG_SETCLIPPLANE& setClipPlane);

        HRESULT ResolveDeferredState(Device &device, D3D12_GRAPHICS_PIPELINE_STATE_DESC& psoDesc);

        void SetPointSize(DWORD dwState, DWORD dwValue);

        void SetScissorRect(Device& device, _In_ RECT scissorRect);
        void ApplyScissorRect(Device& device);
        void SetScissorTestEnabled(Device& device, bool scissorTestEnabled);
        void SetViewPort(Device& device, _In_ CONST D3DDDIARG_VIEWPORTINFO& viewPortInfo);
        void SetZRange(_In_ CONST D3DDDIARG_ZRANGE& zRange);

        void ResolveViewPort(Device& device);

        D3D12VertexShader* GetCurrentD3D12VertexShader() { return m_pCurrentD3D12VS; }
        D3D12GeometryShader* GetCurrentD3D12GeometryShader() { return m_pCurrentD3D12GS; }

        VertexShader *GetCurrentD3D9VertexShader() { return m_pCurrentVS; }
    private:
        bool NeedsGeometryShader(const ShaderConv::VSOutputDecls &vsOutputDecls);

        bool m_scissorTestEnabled;
        RECT m_scissorRect;

        VertexShader* m_pCurrentVS;
        D3D12VertexShader* m_pCurrentD3D12VS;
        D3D12GeometryShader* m_pCurrentD3D12GS;

        VertexShader m_tlShaderCache;
        GeometryShader m_geometryShaderCache;

        D3D12_VIEWPORT m_currentViewPort;

        /* Extensions to handle 9 APIs */
        VSCBExntensionWrapper   m_VSExtension;

        PipelineStateDirtyFlags& m_dirtyFlags;
        RasterStatesWrapper& m_rasterStates;
    };
};
```

`include/9on12VideoDevice.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#pragma once

namespace D3D9on12
{
    class Device; // Forward declaration

    class VideoDevice
    {
    public:
        VideoDevice(Device *pParent);
        ~VideoDevice();

        void GetCaps(_Inout_ CONST D3DDDIARG_GETCAPS* pGetCaps);

        static D3D12TranslationLayer::VideoDevice* UnderlyingVideoDevice(VideoDevice *pVideoDevice)
        {
            assert(pVideoDevice);
            return pVideoDevice->m_pUnderlyingVideoDevice;
        }

        UINT GetMaxInputStreams() { return m_vpMaxInputStreams; }

        FLOAT GetFilterRangeMultiplier(D3D12_VIDEO_PROCESS_FILTER filter) { return m_filterRanges[filter].Multiplier; }

        bool IsAutoProcessingSupported() { return m_pUnderlyingVideoProcessEnum->IsAutoProcessingSupported(); }

        bool IsAlphaBlendProcessingSupported() { return m_fAlphaBlending; }

    protected:
        template<typename T>
        void Preamble(_In_ CONST D3DDDIARG_GETCAPS* pGetCaps, bool expression);
        void CacheVideoProcessInfo(_In_ D3D12TranslationLayer::VIDEO_PROCESS_ENUM_ARGS &args);

        UINT GetFilteredFormatsCount(_In_ const std::vector<DXGI_FORMAT> &vpFormats);

        BYTE m_pUnderlyingSpace[sizeof(D3D12TranslationLayer::VideoDevice)];
        D3D12TranslationLayer::VideoDevice *m_pUnderlyingVideoDevice = nullptr;
        BYTE m_pUnderlyingSpaceVPEnum[sizeof(D3D12TranslationLayer::VideoProcessEnum)];
        D3D12TranslationLayer::VideoProcessEnum *m_pUnderlyingVideoProcessEnum = nullptr;
        Device *m_pParentDevice = nullptr;
        DXVAHDDDI_VPDEVCAPS m_vpDXVAHDDevCaps;
        std::vector<DXVAHDDDI_VPCAPS> m_vpDXVAHDCaps;
        const UINT m_maxVideoProcessors = 3;  // Progressive, Bob, and Adaptive
        D3D12TranslationLayer::VIDEO_PROCESS_ENUM_ARGS m_currentVideoProcessArgs = {};
        static const UINT MAX_VIDEO_PROCESSOR_FILTERS = D3D12_VIDEO_PROCESS_MAX_FILTERS;
        DXVAHDDDI_FILTER_RANGE_DATA m_filterRanges[MAX_VIDEO_PROCESSOR_FILTERS] = {};
        UINT m_vpMaxInputStreams = 0;
        bool m_fAlphaBlending = false;
    };
};

```

`include/9on12VideoProcessDevice.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#pragma once

namespace D3D9on12
{
    class Device; // Forward declaration

    typedef std::map<DXVAHDDDI_STREAM_STATE, std::vector<BYTE>> DXVAHDStreamState;

    class VideoProcessDevice
    {
    public:
        VideoProcessDevice(HANDLE runtimeHandle, _In_ Device *pParent, _In_ const D3DDDIARG_CREATEVIDEOPROCESSDEVICE *pCreateVideoProcessDevice);
        VideoProcessDevice(Device *pParent, _In_ const D3DDDIARG_DXVAHD_CREATEVIDEOPROCESSOR  *pCreateVideoProcessDevice);
        ~VideoProcessDevice();

        Device* GetParent() { return m_pParentDevice; }

        static FORCEINLINE HANDLE GetHandleFromVideoProcessDevice(VideoProcessDevice* pVideoProcessDevice) { return (pVideoProcessDevice) ? static_cast<HANDLE>(pVideoProcessDevice) : NULL_HANDLE; }
        static FORCEINLINE VideoProcessDevice* GetVideoProcessDeviceFromHandle(HANDLE hVideoProcessDevice) { return (hVideoProcessDevice != NULL_HANDLE) ? static_cast<VideoProcessDevice*>(hVideoProcessDevice) : nullptr; }

        void SetRenderTarget(_In_ CONST D3DDDIARG_SETVIDEOPROCESSRENDERTARGET *pRenderTarget);
        void Blit(_In_ CONST D3DDDIARG_VIDEOPROCESSBLT *pVideoProcessBlt);
        void SetBlitState(_In_ CONST D3DDDIARG_DXVAHD_SETVIDEOPROCESSBLTSTATE *pBltState);
        void SetStreamState(_In_ CONST D3DDDIARG_DXVAHD_SETVIDEOPROCESSSTREAMSTATE *pStreamState);
        void BlitHD(_In_ CONST D3DDDIARG_DXVAHD_VIDEOPROCESSBLTHD *pBlitHD);

    protected:
        void SetFilter(D3D12_VIDEO_PROCESS_FILTER filter, _In_ D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC *pStreamDesc, _In_ D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1 *pStreamArguments, INT level);
        void SetViewInfo(HANDLE hResource, UINT subresourceIndex, _Out_ D3D12TranslationLayer::VideoProcessView *pView);
        void FillReferenceSet(_In_ D3D12TranslationLayer::VIDEO_PROCESS_STREAM_INFO *pStreamInfo, UINT view, _In_ const DXVAHDDDI_SURFACE &InputSurface, UINT numPastFrames, _In_ const DXVAHDDDI_SURFACE *pPastSurfaces, UINT numFutureFrames, _In_ const DXVAHDDDI_SURFACE* pFutureSurfaces);
        void SetStreamState(UINT streamIndex, D3D12TranslationLayer::VideoProcessView *pStreamView, DXVAHDDDI_STREAM_STATE state, _In_ const std::vector<BYTE> &streamStateData);

        BYTE m_pUnderlyingSpace[sizeof(D3D12TranslationLayer::VideoProcess)];
        Device *m_pParentDevice = nullptr;
        D3D12TranslationLayer::VideoProcess *m_pUnderlyingVideoProcess = nullptr;
        UINT m_MaxInputStreams = 0;
        D3D12TranslationLayer::VIDEO_PROCESS_INPUT_ARGUMENTS m_inputArguments = {};
        D3D12TranslationLayer::VIDEO_PROCESS_OUTPUT_ARGUMENTS m_outputArguments = {};
        D3D12TranslationLayer::VideoProcessView m_targetView;
        bool m_colorSpaceNeverSet = true;
        std::vector<bool> m_IsStreamPlanarAlphaBlendInitialized;
        struct {
            unique_comptr<D3D12TranslationLayer::Resource> target;
        } m_inUseResources;

        DXVAHDDDI_BLT_STATE_OUTPUT_COLOR_SPACE_DATA m_dxvaHDColorSpaceData = {};
        std::vector<DXVAHDStreamState> m_dxvaHDStreamStates;
    };
};

```

`include/9on12VideoTranslate.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#pragma once

namespace D3D9on12
{
    class VideoTranslate
    {
    public:
        static inline D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE GetInterlaceType(DXVADDI_SAMPLEFORMAT format)
        {
            if (format == DXVADDI_SampleFieldInterleavedEvenFirst ||
                format == DXVADDI_SampleFieldInterleavedOddFirst ||
                format == DXVADDI_SampleFieldSingleEven ||
                format == DXVADDI_SampleFieldSingleOdd)
            {
                return D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE_FIELD_BASED;
            }
            else
            {
                return D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE_NONE;
            }
        }

        static inline UINT GetBitstreamRawType(REFGUID Profile)
        {
            struct BitstreamTypePair {
                const GUID* DecodeProfile;
                UINT BitstreamRawType;
            };

            static const BitstreamTypePair map[] =
            {
                // H264 VLD SHORT slice = 2. (H264 DXVA Spec: 2.2 Semantics)
                &DXVA_ModeH264_F,                            2,
                &DXVA_ModeH264_E,                            2,
                &DXVA_ModeH264_VLD_WithFMOASO_NoFGT,         2,
                &DXVA_ModeH264_VLD_Stereo_Progressive_NoFGT, 2,
                &DXVA_ModeH264_VLD_Stereo_NoFGT,             2,
                &DXVA_ModeH264_VLD_Multiview_NoFGT,          2,
            };

            for (UINT Index = 0; Index < ARRAYSIZE(map); Index++)
            {
                if (IsEqualGUID(*map[Index].DecodeProfile, Profile))
                {
                    return map[Index].BitstreamRawType;
                }
            }

            return 1; // All other decode profiles should use bitstream type 1.
        }

        static inline void VideoDecodeConfig(_In_ const D3D12TranslationLayer::VIDEO_DECODE_DESC *pDesc, _In_ const D3D12TranslationLayer::VIDEO_DECODE_CONFIG *pConfig, _Out_ DXVADDI_CONFIGPICTUREDECODE *pDXVAConfig)
        {
            ZeroMemory(pDXVAConfig, sizeof(*pDXVAConfig));
            pDXVAConfig->guidConfigMBcontrolEncryption = DXVA_NoEncrypt;
            pDXVAConfig->guidConfigResidDiffEncryption = DXVA_NoEncrypt;
            pDXVAConfig->guidConfigBitstreamEncryption = DXVA_NoEncrypt;
            pDXVAConfig->ConfigBitstreamRaw = GetBitstreamRawType(pDesc->DecodeProfile);                      // always VLD, always SHORT slice
            pDXVAConfig->ConfigDecoderSpecific = (pConfig->ConfigDecoderSpecific & ~D3D12TranslationLayer::VIDEO_DECODE_CONFIG_SPECIFIC_ARRAY_OF_TEXTURES);
            pDXVAConfig->ConfigMinRenderTargetBuffCount = 0;
        }

        static inline void VideoDecodeDesc(_In_ const DXVADDI_DECODEINPUT *pDXVADesc, _Out_ D3D12TranslationLayer::VIDEO_DECODE_DESC *pDesc)
        {
            pDesc->DecodeProfile = *pDXVADesc->pGuid;
            pDesc->Width = pDXVADesc->VideoDesc.SampleWidth;
            pDesc->Height = pDXVADesc->VideoDesc.SampleHeight;
            pDesc->DecodeFormat = ConvertFromDDIToDXGIFORMAT(pDXVADesc->VideoDesc.Format);
        }

        static inline D3DDDIFORMAT VideoDecodeBufferType(D3D12TranslationLayer::VIDEO_DECODE_BUFFER_TYPE Type)
        {
            static const D3DDDIFORMAT map[] =
            {
                D3DDDIFMT_PICTUREPARAMSDATA,
                D3DDDIFMT_INVERSEQUANTIZATIONDATA,
                D3DDDIFMT_SLICECONTROLDATA,
                D3DDDIFMT_BITSTREAMDATA,
                D3DDDIFMT_DXVACOMPBUFFER_BASE                     // TODO: what to do for VP9 probability buffer???
            };
            return map[Type];
        }

        static inline void VideoDecodeBufferInfo(D3D12TranslationLayer::VIDEO_DECODE_BUFFER_TYPE type, UINT size, _Out_ DXVADDI_DECODEBUFFERINFO *pDXVABufferInfo)
        {
            pDXVABufferInfo->CompressedBufferType = VideoDecodeBufferType(type);
            // D3D9 uses width & height instead of a direct size for the linear buffers.
            pDXVABufferInfo->CreationWidth = size;
            pDXVABufferInfo->CreationHeight = 1;
            pDXVABufferInfo->CreationPool = D3DDDIPOOL_NONLOCALVIDMEM;
        }

        static inline D3D12_VIDEO_DECODE_ARGUMENT_TYPE VideoDecodeArgumentType(D3DDDIFORMAT Type9)
        {
            switch (Type9)
            {
            case D3DDDIFMT_PICTUREPARAMSDATA:
                return D3D12_VIDEO_DECODE_ARGUMENT_TYPE_PICTURE_PARAMETERS;
            case D3DDDIFMT_INVERSEQUANTIZATIONDATA:
                return D3D12_VIDEO_DECODE_ARGUMENT_TYPE_INVERSE_QUANTIZATION_MATRIX;
            case D3DDDIFMT_SLICECONTROLDATA:
                return D3D12_VIDEO_DECODE_ARGUMENT_TYPE_SLICE_CONTROL;
            default:
                assert(false);
                return (D3D12_VIDEO_DECODE_ARGUMENT_TYPE)-1;
            }
        }

        static inline void VideoColor(_In_ const DXVADDI_AYUVSAMPLE16 *pInput, _Out_writes_all_(4) float Output[4])
        {
            Output[0] = ((float)pInput->Y) / 0xffff;;
            Output[1] = ((float)pInput->Cb) / 0xffff;
            Output[2] = ((float)pInput->Cr) / 0xffff;
            Output[3] = ((float)pInput->Alpha) / 0xffff;
        }

        static inline void VideoColor(_In_ const DXVAHDDDI_COLOR *pInput, _Out_writes_all_(4) float Output[4])
        {
            Output[0] = pInput->YCbCr.Y;
            Output[1] = pInput->YCbCr.Cb;
            Output[2] = pInput->YCbCr.Cr;
            Output[3] = pInput->YCbCr.A;
        }

        static inline DXGI_COLOR_SPACE_TYPE ColorSpaceType(_In_ DXGI_FORMAT format, _In_ UINT height, _In_ DXVADDI_EXTENDEDFORMAT extendedFormat)
        {
            DXGI_COLOR_SPACE_TYPE dxgiColorSpace = (DXGI_COLOR_SPACE_TYPE)0;
            DXVADDI_VIDEOTRANSFERMATRIX videoTransferMatrix = (DXVADDI_VIDEOTRANSFERMATRIX)extendedFormat.VideoTransferMatrix;

            if (extendedFormat.VideoTransferMatrix == DXVADDI_VideoTransferMatrix_Unknown)
            {
                // according to MSDN: https://msdn.microsoft.com/en-us/library/windows/desktop/ms698715(v=vs.85).aspx
                // DXVA2_VideoTransferMatrix_Unknown For standard - definition content, treat as DXVA2_VideoTransferMatrix_BT601.
                // For high - definition content, treat as DXVA2_VideoTransferMatrix_BT709. (High - definition content is defined for this purpose 
                // as anything with a source height greater than 576 lines.)
                if (height > 576)
                {
                    videoTransferMatrix = DXVADDI_VideoTransferMatrix_BT709;
                }
                else
                {
                    videoTransferMatrix = DXVADDI_VideoTransferMatrix_BT601;
                }
            }

            // if VideoTransferMatrix not equal to 709, we assume it is 601.

            if (CD3D11FormatHelper::YUV(format))
            {
                if (extendedFormat.NominalRange == DXVADDI_NominalRange_16_235)    // studio
                {
                    dxgiColorSpace = (videoTransferMatrix == DXVADDI_VideoTransferMatrix_BT709) ?
                        DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P709 :
                        DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P601;
                }
                else                                                               // assume full
                {
                    dxgiColorSpace = (videoTransferMatrix == DXVADDI_VideoTransferMatrix_BT709) ?
                        DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P709 :
                        DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P601;
                }
            }
            else
            {
                // RGB format

                // Note that there are no RGB P601 color spaces, so we will map to P709.
                if (extendedFormat.NominalRange == DXVADDI_NominalRange_16_235)    // studio
                {
                    // assume G22 as there is no G10 studio color space
                    dxgiColorSpace = DXGI_COLOR_SPACE_RGB_STUDIO_G22_NONE_P709;
                }
                else                                                               // assume full
                {
                    if (extendedFormat.VideoTransferFunction == DXVADDI_VideoTransFunc_10)
                    {
                        dxgiColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G10_NONE_P709;
                    }
                    else                                                           // assume G22
                    {
                        dxgiColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709;
                    }
                }
            }

            return dxgiColorSpace;
        }

        static inline DXGI_COLOR_SPACE_TYPE ColorSpaceType(_In_ DXGI_FORMAT format, bool RGBStudio, bool YUVStudio, bool BT709)
        {
            DXGI_COLOR_SPACE_TYPE dxgiColorSpace = (DXGI_COLOR_SPACE_TYPE)0;

            // if VideoTransferMatrix not equal to 709, we assume it is 601.
            if (CD3D11FormatHelper::YUV(format))
            {
                if (YUVStudio)
                {
                    dxgiColorSpace = (BT709) ?
                        DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P709 :
                        DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P601;
                }
                else
                {
                    dxgiColorSpace = (BT709) ?
                        DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P709 :
                        DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P601;
                }
            }
            else
            {
                // RGB format, assume G22
                if (RGBStudio)
                {
                    dxgiColorSpace = DXGI_COLOR_SPACE_RGB_STUDIO_G22_NONE_P709;
                }
                else
                {
                    dxgiColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709;
                }
            }

            return dxgiColorSpace;
        }


        template <typename T>
        static inline DXGI_COLOR_SPACE_TYPE ColorSpaceType(_In_ DXGI_FORMAT format, _In_ const T &colorSpaceData)
        {
            bool RGBStudio = colorSpaceData.RGB_Range == 1 ? true : false;
            bool YUVStudio = colorSpaceData.Nominal_Range == DXVAHDDDI_NOMINAL_RANGE_16_235 ? true : (colorSpaceData.YCbCr_xvYCC == 0 ? true : false);
            bool BT709 = colorSpaceData.YCbCr_Matrix == 1 ? true : false;
            return ColorSpaceType(format, RGBStudio, YUVStudio, BT709);
        }

        template <typename T>
        static inline T FromFixed32(_In_ const DXVADDI_FIXED32 &fixed)
        {
            DXVA2_Fixed32 intermediate = *(DXVA2_Fixed32 *)&fixed;
            return (T)DXVA2FixedToFloat(intermediate);
        }

        template <typename T>
        static inline DXVADDI_FIXED32 ToFixed32(_In_ T input)
        {
            DXVA2_Fixed32 intermediate = DXVA2FloatToFixed((float)input);
            return *(DXVADDI_FIXED32 *)&intermediate;
        }

        static inline D3D12_VIDEO_FIELD_TYPE VideoFieldType(DXVAHDDDI_FRAME_FORMAT frameFormat)
        {
            static const D3D12_VIDEO_FIELD_TYPE map[] =
            {
                D3D12_VIDEO_FIELD_TYPE_NONE,                           // DXVAHDDDI_FRAME_FORMAT_PROGRESSIVE
                D3D12_VIDEO_FIELD_TYPE_INTERLACED_TOP_FIELD_FIRST,     // DXVAHDDDI_FRAME_FORMAT_INTERLACED_TOP_FIELD_FIRST
                D3D12_VIDEO_FIELD_TYPE_INTERLACED_BOTTOM_FIELD_FIRST,  // DXVAHDDDI_FRAME_FORMAT_INTERLACED_BOTTOM_FIELD_FIRST
            };
            return map[frameFormat];
        }

        static inline D3D12_VIDEO_FIELD_TYPE VideoFieldType(UINT frameFormat)
        {
            static const D3D12_VIDEO_FIELD_TYPE map[] =
            {
                D3D12_VIDEO_FIELD_TYPE_NONE,                            // DXVADDI_SampleUnknown = 0,
                D3D12_VIDEO_FIELD_TYPE_NONE,                            // 1
                D3D12_VIDEO_FIELD_TYPE_NONE,                            // DXVADDI_SampleProgressiveFrame = 2,
                D3D12_VIDEO_FIELD_TYPE_INTERLACED_TOP_FIELD_FIRST,      // DXVADDI_SampleFieldInterleavedEvenFirst = 3,
                D3D12_VIDEO_FIELD_TYPE_INTERLACED_BOTTOM_FIELD_FIRST,   // DXVADDI_SampleFieldInterleavedOddFirst = 4,
                D3D12_VIDEO_FIELD_TYPE_NONE,                            // DXVADDI_SampleFieldSingleEven = 5,
                D3D12_VIDEO_FIELD_TYPE_NONE,                            // DXVADDI_SampleFieldSingleOdd = 6,
                D3D12_VIDEO_FIELD_TYPE_NONE,                            // DXVADDI_SampleSubStream = 7
            };
            return map[frameFormat];
        }

        static inline DXGI_RATIONAL FrameRate(DXVAHDDDI_RATIONAL frameRate)
        {
            static_assert(sizeof(DXVAHDDDI_RATIONAL) == sizeof(DXGI_RATIONAL), "sizes must match");
            return *(DXGI_RATIONAL *)&frameRate;
        }

        static inline DXGI_RATIONAL FrameRate(DXVADDI_FREQUENCY frameRate)
        {
            static_assert(sizeof(DXVADDI_FREQUENCY) == sizeof(DXGI_RATIONAL), "sizes must match");
            return *(DXGI_RATIONAL *)&frameRate;
        }

        static inline D3D12_VIDEO_PROCESS_FILTER_FLAGS VideoProcessFilterFlag(_In_ DXVAHDDDI_STREAM_STATE StreamState)
        {
            D3D12_VIDEO_PROCESS_FILTER_FLAGS flag = (D3D12_VIDEO_PROCESS_FILTER_FLAGS)0;
            switch (StreamState)
            {
                case  DXVAHDDDI_STREAM_STATE_FILTER_BRIGHTNESS:
                    flag = D3D12_VIDEO_PROCESS_FILTER_FLAG_BRIGHTNESS;
                    break;

                case  DXVAHDDDI_STREAM_STATE_FILTER_CONTRAST:
                    flag = D3D12_VIDEO_PROCESS_FILTER_FLAG_CONTRAST;
                    break;

                case  DXVAHDDDI_STREAM_STATE_FILTER_HUE:
                    flag = D3D12_VIDEO_PROCESS_FILTER_FLAG_HUE;
                    break;

                case  DXVAHDDDI_STREAM_STATE_FILTER_SATURATION:
                    flag = D3D12_VIDEO_PROCESS_FILTER_FLAG_SATURATION;
                    break;

                case  DXVAHDDDI_STREAM_STATE_FILTER_NOISE_REDUCTION:
                    flag = D3D12_VIDEO_PROCESS_FILTER_FLAG_NOISE_REDUCTION;
                    break;

                case  DXVAHDDDI_STREAM_STATE_FILTER_EDGE_ENHANCEMENT:
                    flag = D3D12_VIDEO_PROCESS_FILTER_FLAG_EDGE_ENHANCEMENT;
                    break;

                case  DXVAHDDDI_STREAM_STATE_FILTER_ANAMORPHIC_SCALING:
                    flag = D3D12_VIDEO_PROCESS_FILTER_FLAG_ANAMORPHIC_SCALING;
                    break;

                default:
                    ThrowFailure(E_INVALIDARG);
                    break;
            }
            return flag;
        }

        static inline D3D12_VIDEO_PROCESS_FILTER VideoProcessFilter(_In_ DXVAHDDDI_STREAM_STATE StreamState)
        {
            D3D12_VIDEO_PROCESS_FILTER filter = (D3D12_VIDEO_PROCESS_FILTER)0;
            switch (StreamState)
            {
            case  DXVAHDDDI_STREAM_STATE_FILTER_BRIGHTNESS:
                filter = D3D12_VIDEO_PROCESS_FILTER_BRIGHTNESS;
                break;

            case  DXVAHDDDI_STREAM_STATE_FILTER_CONTRAST:
                filter = D3D12_VIDEO_PROCESS_FILTER_CONTRAST;
                break;

            case  DXVAHDDDI_STREAM_STATE_FILTER_HUE:
                filter = D3D12_VIDEO_PROCESS_FILTER_HUE;
                break;

            case  DXVAHDDDI_STREAM_STATE_FILTER_SATURATION:
                filter = D3D12_VIDEO_PROCESS_FILTER_SATURATION;
                break;

            case  DXVAHDDDI_STREAM_STATE_FILTER_NOISE_REDUCTION:
                filter = D3D12_VIDEO_PROCESS_FILTER_NOISE_REDUCTION;
                break;

            case  DXVAHDDDI_STREAM_STATE_FILTER_EDGE_ENHANCEMENT:
                filter = D3D12_VIDEO_PROCESS_FILTER_EDGE_ENHANCEMENT;
                break;

            case  DXVAHDDDI_STREAM_STATE_FILTER_ANAMORPHIC_SCALING:
                filter = D3D12_VIDEO_PROCESS_FILTER_ANAMORPHIC_SCALING;
                break;

            default:
                ThrowFailure(E_INVALIDARG);
                break;
            }
            return filter;
        }

        static inline void VideoProcessDesc(_In_ const DXVADDI_VIDEOPROCESSORINPUT *pVideoProcessorInput, UINT maxInputStreams, _Out_ D3D12TranslationLayer::VIDEO_PROCESS_ENUM_ARGS &args, _Out_ D3DDDIFORMAT &rtFormat)
        {
            VideoProcessDesc(&pVideoProcessorInput->VideoDesc, maxInputStreams, args, rtFormat);
            rtFormat = pVideoProcessorInput->RenderTargetFormat;
        }

        static inline void VideoProcessDesc(_In_ const DXVADDI_QUERYPROCAMPINPUT *pQueryProcAmpInput, UINT maxInputStreams, _Out_ D3D12TranslationLayer::VIDEO_PROCESS_ENUM_ARGS &args, _Out_ D3DDDIFORMAT &rtFormat)
        {
            VideoProcessDesc(&pQueryProcAmpInput->VideoDesc, maxInputStreams, args, rtFormat);
            rtFormat = pQueryProcAmpInput->RenderTargetFormat;
        }

        static inline void VideoProcessDesc(_In_ const DXVADDI_VIDEODESC *pVideoDesc, UINT maxInputStreams, _Out_ D3D12TranslationLayer::VIDEO_PROCESS_ENUM_ARGS &args, _Out_ D3DDDIFORMAT &rtFormat)
        {
            args.InputFieldType = VideoFieldType(pVideoDesc->SampleFormat.SampleFormat);
            args.InputFrameRate = FrameRate(pVideoDesc->InputSampleFreq);
            args.InputWidth = pVideoDesc->SampleWidth;
            args.InputHeight = pVideoDesc->SampleHeight;
            args.OutputFrameRate = FrameRate(pVideoDesc->OutputFrameFreq);
            args.OutputWidth = pVideoDesc->SampleWidth;
            args.OutputHeight = pVideoDesc->SampleHeight;
            args.MaxInputStreams = maxInputStreams;
            rtFormat = pVideoDesc->Format;
        }

        static inline void VideoProcessDesc(_In_ const DXVAHDDDI_CONTENT_DESC *pVideoDesc, UINT maxInputStreams, _Out_ D3D12TranslationLayer::VIDEO_PROCESS_ENUM_ARGS &args, _Out_ D3DDDIFORMAT &rtFormat)
        {
            args.InputFieldType = VideoFieldType(pVideoDesc->InputFrameFormat);
            args.InputFrameRate = FrameRate(pVideoDesc->InputFrameRate);
            args.InputWidth = pVideoDesc->InputWidth;
            args.InputHeight = pVideoDesc->InputHeight;
            args.OutputFrameRate = FrameRate(pVideoDesc->OutputFrameRate);
            args.OutputWidth = pVideoDesc->OutputWidth;
            args.OutputHeight = pVideoDesc->OutputHeight;
            args.MaxInputStreams = maxInputStreams;
            rtFormat = D3DDDIFMT_UNKNOWN;
        }


        static inline void VideoProcessDesc(_In_ const DXVAHDDDI_DEVICE_DESC *pDesc, UINT maxInputStreams, _Out_ D3D12TranslationLayer::VIDEO_PROCESS_ENUM_ARGS &args, _Out_ D3DDDIFORMAT &rtFormat)
        {
            VideoProcessDesc(pDesc->pContentDesc, maxInputStreams, args, rtFormat);
        }

        static inline UINT MapFlags(const UINT *pMap, UINT inputFlags)
        {
            UINT index = 0;
            UINT outputFlags = 0;
            while (inputFlags)
            {
                if (inputFlags & 0x1)
                {
                    outputFlags |= pMap[index];
                }
                inputFlags >>= 1;
                ++index;
            }
            return outputFlags;
        }


        static inline UINT ToDXVAHDVPDevCaps(UINT colorConversionCaps)
        {
            static_assert(DXVAHDDDI_DEVICE_CAPS_LINEAR_SPACE            == D3D12TranslationLayer::VIDEO_PROCESS_CONVERSION_CAPS_LINEAR_SPACE &&
                          DXVAHDDDI_DEVICE_CAPS_xvYCC                   == D3D12TranslationLayer::VIDEO_PROCESS_CONVERSION_CAPS_xvYCC &&
                          DXVAHDDDI_DEVICE_CAPS_RGB_RANGE_CONVERSION    == D3D12TranslationLayer::VIDEO_PROCESS_CONVERSION_CAPS_RGB_RANGE_CONVERSION &&
                          DXVAHDDDI_DEVICE_CAPS_YCbCr_MATRIX_CONVERSION == D3D12TranslationLayer::VIDEO_PROCESS_CONVERSION_CAPS_YCbCr_MATRIX_CONVERSION,
                          "DeviceCaps must match");
            colorConversionCaps &= ~D3D12TranslationLayer::VIDEO_PROCESS_CONVERSION_CAPS_NOMINAL_RANGE;

            return colorConversionCaps;
        }

        static inline void AddVideoProcessCaps(_In_ D3D12_FEATURE_DATA_VIDEO_PROCESS_SUPPORT &dx12Support, _Out_ DXVAHDDDI_VPDEVCAPS &dxvaHDVPDevCaps, _Out_ DXVAHDDDI_FILTER_RANGE_DATA *pFilterRanges, _In_ UINT cFilterRanges, _In_ D3D12TranslationLayer::VIDEO_PROCESS_CONVERSION_CAPS colorConversionCap, _Out_ bool& fAlphaBlending)
        {
            UNREFERENCED_PARAMETER(cFilterRanges);

            //
            // FeatureCaps: DXVAHDDDI_FEATURE_CAPS & 
            //
            static const UINT mapDXVAHDFeatureCaps[] =
            {
                DXVAHDDDI_FEATURE_CAPS_ALPHA_FILL,          // D3D12_VIDEO_PROCESS_FEATURE_FLAG_ALPHA_FILL
                DXVAHDDDI_FEATURE_CAPS_LUMA_KEY,            // D3D12_VIDEO_PROCESS_FEATURE_FLAG_LUMA_KEY
                0,                                          // D3D12_VIDEO_PROCESS_FEATURE_FLAG_STEREO
                DXVAHDDDI_FEATURE_CAPS_ROTATION,            // D3D12_VIDEO_PROCESS_FEATURE_FLAG_ROTATION
                0,                                          // D3D12_VIDEO_PROCESS_FEATURE_FLAG_FLIP
                0,                                          // D3D12_VIDEO_PROCESS_FEATURE_FLAG_ALPHA_BLENDING
                0,                                          // D3D12_VIDEO_PROCESS_FEATURE_FLAG_PIXEL_ASPECT_RATIO
                0,                                          // D3D12_VIDEO_PROCESS_FEATURE_FLAG_AUTO_PROCESSING
            };
            static const UINT mapDXVAFeatureCaps[] =
            {
                DXVADDI_VIDEOPROCESS_PLANARALPHA,           // D3D12_VIDEO_PROCESS_FEATURE_FLAG_ALPHA_FILL
                0,                                          // D3D12_VIDEO_PROCESS_FEATURE_FLAG_LUMA_KEY
                0,                                          // D3D12_VIDEO_PROCESS_FEATURE_FLAG_STEREO
                0,                                          // D3D12_VIDEO_PROCESS_FEATURE_FLAG_ROTATION
                0,                                          // D3D12_VIDEO_PROCESS_FEATURE_FLAG_FLIP
                DXVADDI_VIDEOPROCESS_ALPHABLEND,            // D3D12_VIDEO_PROCESS_FEATURE_FLAG_ALPHA_BLENDING
                0,                                          // D3D12_VIDEO_PROCESS_FEATURE_FLAG_PIXEL_ASPECT_RATIO
                0,                                          // D3D12_VIDEO_PROCESS_FEATURE_FLAG_AUTO_PROCESSING
            };
            dxvaHDVPDevCaps.FeatureCaps |= MapFlags(mapDXVAHDFeatureCaps, (UINT)dx12Support.FeatureSupport);
            fAlphaBlending = (dx12Support.FeatureSupport & D3D12_VIDEO_PROCESS_FEATURE_FLAG_ALPHA_BLENDING) ? true : fAlphaBlending;

            //
            // Filter support: DXVAHDDDI_FILTER_CAPS & DXVADDI_VIDEOPROCESSORCAPS.ProcAmpControlCaps
            //
            // we assume identical filters for DXVA / DX12
            static_assert(DXVAHDDDI_FILTER_CAPS_BRIGHTNESS         == D3D12_VIDEO_PROCESS_FILTER_FLAG_BRIGHTNESS, "DXVAHD and 12 filter flags should match");
            static_assert(DXVAHDDDI_FILTER_CAPS_CONTRAST           == D3D12_VIDEO_PROCESS_FILTER_FLAG_CONTRAST, "DXVAHD and 12 filter flags should match");
            static_assert(DXVAHDDDI_FILTER_CAPS_HUE                == D3D12_VIDEO_PROCESS_FILTER_FLAG_HUE, "DXVAHD and 12 filter flags should match");
            static_assert(DXVAHDDDI_FILTER_CAPS_SATURATION         == D3D12_VIDEO_PROCESS_FILTER_FLAG_SATURATION, "DXVAHD and 12 filter flags should match");
            static_assert(DXVAHDDDI_FILTER_CAPS_NOISE_REDUCTION    == D3D12_VIDEO_PROCESS_FILTER_FLAG_NOISE_REDUCTION, "DXVAHD and 12 filter flags should match");
            static_assert(DXVAHDDDI_FILTER_CAPS_EDGE_ENHANCEMENT   == D3D12_VIDEO_PROCESS_FILTER_FLAG_EDGE_ENHANCEMENT, "DXVAHD and 12 filter flags should match");
            static_assert(DXVAHDDDI_FILTER_CAPS_ANAMORPHIC_SCALING == D3D12_VIDEO_PROCESS_FILTER_FLAG_ANAMORPHIC_SCALING, "DXVAHD and 12 filter flags should match");

            static_assert(DXVADDI_PROCAMP_BRIGHTNESS == D3D12_VIDEO_PROCESS_FILTER_FLAG_BRIGHTNESS, "DXVA and 12 filter flags should match");
            static_assert(DXVADDI_PROCAMP_CONTRAST   == D3D12_VIDEO_PROCESS_FILTER_FLAG_CONTRAST, "DXVA and 12 filter flags should match");
            static_assert(DXVADDI_PROCAMP_HUE        == D3D12_VIDEO_PROCESS_FILTER_FLAG_HUE, "DXVA and 12 filter flags should match");
            static_assert(DXVADDI_PROCAMP_SATURATION == D3D12_VIDEO_PROCESS_FILTER_FLAG_SATURATION, "DXVA and 12 filter flags should match");

            UINT origFilterCaps = dxvaHDVPDevCaps.FilterCaps;
            dxvaHDVPDevCaps.FilterCaps |= (UINT)dx12Support.FilterSupport;

            // turn off flags not present in DXVA / DXVAHD
            dxvaHDVPDevCaps.FilterCaps &= ~D3D12_VIDEO_PROCESS_FILTER_FLAG_STEREO_ADJUSTMENT;

            UINT newMask = dxvaHDVPDevCaps.FilterCaps & (~origFilterCaps);
            UINT filter = 0;
            while (newMask)
            {
                assert(filter < cFilterRanges);
                if (newMask & 0x1)
                {
                    pFilterRanges[filter].Minimum = dx12Support.FilterRangeSupport[filter].Minimum;
                    pFilterRanges[filter].Maximum = dx12Support.FilterRangeSupport[filter].Maximum;
                    pFilterRanges[filter].Default = dx12Support.FilterRangeSupport[filter].Default;
                    pFilterRanges[filter].Multiplier = dx12Support.FilterRangeSupport[filter].Multiplier;
                }
                newMask >>= 1;
                ++filter;
            }

            //
            // InputFormatCaps: DXVAHDDDI_INPUT_FORMAT_CAPS
            // 
            if (!CD3D11FormatHelper::YUV(dx12Support.InputSample.Format.Format))
            {
                if (dx12Support.FeatureSupport & D3D12_VIDEO_PROCESS_FEATURE_FLAG_LUMA_KEY)
                {
                    dxvaHDVPDevCaps.InputFormatCaps |= DXVAHDDDI_INPUT_FORMAT_CAPS_RGB_LUMA_KEY;
                }
                if (dx12Support.FilterSupport & (D3D12_VIDEO_PROCESS_FILTER_FLAG_BRIGHTNESS | D3D12_VIDEO_PROCESS_FILTER_FLAG_CONTRAST | D3D12_VIDEO_PROCESS_FILTER_FLAG_HUE | D3D12_VIDEO_PROCESS_FILTER_FLAG_SATURATION))
                {
                    // Note: the below should be true, but we have several outputs indicating no RGB_PROCAMP even if the condition above is true. So, ignoring RGB_PROCAMP.
                    // dxvaHDVPDevCaps.InputFormatCaps |= DXVAHDDDI_INPUT_FORMAT_CAPS_RGB_PROCAMP;
                }
                if (dx12Support.InputFieldType != D3D12_VIDEO_FIELD_TYPE_NONE)
                {
                    dxvaHDVPDevCaps.InputFormatCaps |= DXVAHDDDI_INPUT_FORMAT_CAPS_RGB_INTERLACED;
                }
            }

            //
            // color conversion caps
            //
            dxvaHDVPDevCaps.DeviceCaps |= ToDXVAHDVPDevCaps(colorConversionCap);
        }

        static inline void AddVideoProcessCaps(UINT MaxInputStreams, _Out_ DXVAHDDDI_VPDEVCAPS &dxvaHDVPDevCaps)
        {
            dxvaHDVPDevCaps.MaxInputStreams = MaxInputStreams;
            dxvaHDVPDevCaps.MaxStreamStates = MaxInputStreams;       // Assuming identical values for stream states & input streams.
        }
   };
}
```

`include/9on12Warning.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#pragma once

namespace D3D9on12
{
    namespace WarningStrings
    {
        static const std::string g_cDXGIWarningHeader = "D3D9on12 Warning: Forcing DXGI format conversion: ";
        static const std::string g_cPerformanceWarningHeader = "D3D9on12 Performance Warning: ";
        static const std::string g_cDDIEntryHeader = "D3D9on12 DDI Entrypoint: ";

        static const std::string g_cSystemMemoryBoundWarning = "Binding system memory resource directly to pipeline.";
        static const std::string g_cSystemMemoryBoundAsShaderResourceWarning = "Binding system memory resource as a shader resource. This path is a serious perf concern and should be reviewed if this gets hit outside of the HLK.";
        static const std::string g_cCopyToSystemMemoryWarning = "Copy is being called with system memory as the destination";
        static const std::string g_cIgnoringMultipleDirtyRectsWarning = "Suboptimally ignoring presents with multiple dirty rects";
        static const std::string g_cInefficientUnbindingArrayDeletion = "A resource has a large amount of bindings causing inefficient O(N) deletions when being unbound";
    };

    static void PrintDebugMessage(std::string message)
    {
        OutputDebugStringA(message.c_str());
        OutputDebugStringA("\n");
    }

#define DXGI_FORMAT_WARNING(message) \
        { \
            if (RegistryConstants::g_cSpewDXGIFormatWarnings) \
            { \
                PrintDebugMessage(WarningStrings::g_cDXGIWarningHeader); \
                PrintDebugMessage(std::string(message)); \
            } \
            if (RegistryConstants::g_cAssertDXGIFormatWarnings) \
            { \
                Check9on12(false); \
            } \
        }

#define PERFORMANCE_WARNING(message) \
        { \
            if (RegistryConstants::g_cSpewPerformanceWarnings) \
            { \
                PrintDebugMessage(WarningStrings::g_cPerformanceWarningHeader + std::string(message)); \
            } \
        }

#define SYSTEM_MEMORY_RESOURCE_BOUND_WARNING() PERFORMANCE_WARNING(WarningStrings::g_cSystemMemoryBoundWarning)
#define SYSTEM_MEMORY_RESOURCE_BOUND_AS_SHADER_RESOURCE_WARNING() PERFORMANCE_WARNING(WarningStrings::g_cSystemMemoryBoundAsShaderResourceWarning)
#define COPY_TO_SYSTEM_MEMORY_WARNING() PERFORMANCE_WARNING(WarningStrings::g_cCopyToSystemMemoryWarning)
#define IGNORING_MULTIPLE_DIRTY_RECTS() PERFORMANCE_WARNING(WarningStrings::g_cIgnoringMultipleDirtyRectsWarning)
#define INEFFICIENT_UNBINDING_ARRAY_DELETION() PERFORMANCE_WARNING(WarningStrings::g_cInefficientUnbindingArrayDeletion)

};
```

`include/9on12draw.inl`:

```inl
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// D3D9On12 draw inlines
//
// Copyright (C) Microsoft Corporation
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
namespace D3D9on12
{
    static HRESULT DrawProlog(Device& device, OffsetArg BaseVertexStart, UINT vertexCount, OffsetArg baseIndexLocation, UINT indexCount, D3DPRIMITIVETYPE primitiveType, UINT& instancesToDraw, bool &skipDraw)
    {

        if ((device.GetPipelineState().GetPixelStage().GetNumBoundRenderTargets() == 0 && device.GetPipelineState().GetPixelStage().GetDepthStencil() == nullptr) ||
            ConvertToD3D12Topology(primitiveType) == (D3D_PRIMITIVE_TOPOLOGY)-1 ||
            vertexCount == 0)
        {
            skipDraw = true;
            return S_OK;
        }
        skipDraw = false;

        InputAssembly& ia = device.GetPipelineState().GetInputAssembly();
        HRESULT hr = ia.UploadDeferredInputBufferData(device, BaseVertexStart, vertexCount, baseIndexLocation, indexCount);

        CHECK_HR(hr);
        if (SUCCEEDED(hr))
        {
            ia.SetPrimitiveTopology(device, primitiveType);
            device.GetPipelineState().MarkPipelineStateNeeded();

            hr = device.ResolveDeferredState(BaseVertexStart, baseIndexLocation);
            CHECK_HR(hr);
        }

        // The instance count is always in stream 0
        UINT streamFrequence = device.GetStreamFrequency(0);

        //This is how D3D9 conveyed instance count
        instancesToDraw = (streamFrequence & D3DSTREAMSOURCE_INDEXEDDATA) ? streamFrequence &~D3DSTREAMSOURCE_INDEXEDDATA : 1;

        return hr;
    }

    static HRESULT DrawEpilogue(Device& device)
    {
        // Data uploaded for a draw is only valid for that draw, and should be cleaned up immediately after to prevent
        // successive draws from reading stale/deleted data
        if (!g_AppCompatInfo.DisableIntzDSVFix && device.GetPipelineState().GetIntzRestoreZWrite())
        {
            device.GetPipelineState().GetPixelStage().SetDepthStencilState(device, D3DRS_ZWRITEENABLE, 1);
            device.GetPipelineState().SetIntzRestoreZWrite(false);
        }
        device.GetSystemMemoryAllocator().ClearDeferredDestroyedResource();
        device.GetPipelineState().GetInputAssembly().ResetUploadBufferData();
        return S_OK;
    }


    inline _Check_return_ HRESULT APIENTRY DrawPrimitive(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_DRAWPRIMITIVE* pDrawPrimitiveArg, _In_opt_ CONST UINT* pFlagBuffer)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);

        Device* pDevice = Device::GetDeviceFromHandle(hDevice);

        if (pDevice == nullptr || pDrawPrimitiveArg == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        OffsetArg baseVertexOffset = OffsetArg::AsOffsetInVertices(pDrawPrimitiveArg->VStart);
        OffsetArg baseIndexOffset = OffsetArg::AsOffsetInIndices(0);

        if (IsTriangleFan(pDrawPrimitiveArg->PrimitiveType))
        {
            if (pFlagBuffer)
            {
                return pDevice->DrawWireframeTriangleFanWithEdgeFlags(baseVertexOffset, pDrawPrimitiveArg->PrimitiveCount, *pFlagBuffer);
            }
            return pDevice->DrawTriangleFan(baseVertexOffset, pDrawPrimitiveArg->PrimitiveCount);
        }

        UINT instanceCount = 1;
        const UINT verticesToDraw = CalcVertexCount(pDrawPrimitiveArg->PrimitiveType, pDrawPrimitiveArg->PrimitiveCount);
        const UINT vertexCount = verticesToDraw;
        const UINT indexCount = 0;    

        bool skipDraw = false;
        HRESULT hr = D3D9on12::DrawProlog(*pDevice, baseVertexOffset, vertexCount, baseIndexOffset, indexCount, pDrawPrimitiveArg->PrimitiveType, instanceCount, skipDraw);
        CHECK_HR(hr);

        if (skipDraw)
        {
            return hr;
        }

        if (SUCCEEDED(hr))
        {
            pDevice->GetContext().DrawInstanced(
                CalcVertexCount(pDrawPrimitiveArg->PrimitiveType, pDrawPrimitiveArg->PrimitiveCount),
                instanceCount,
                baseVertexOffset.GetOffsetInVertices(),
                0);

        }

        hr = DrawEpilogue(*pDevice);

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr);
    }

    inline _Check_return_ HRESULT APIENTRY DrawPrimitive2(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_DRAWPRIMITIVE2* pDrawPrimitiveArg)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pDrawPrimitiveArg == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        UINT const stream0Stride = pDevice->GetPipelineState().GetInputAssembly().GetStream0Stride();
        Check9on12(stream0Stride > 0);

        OffsetArg baseVertexOffset = OffsetArg::AsOffsetInBytes(pDrawPrimitiveArg->FirstVertexOffset);
        OffsetArg baseIndexOffset = OffsetArg::AsOffsetInIndices(0);

        if (IsTriangleFan(pDrawPrimitiveArg->PrimitiveType))
        {
            return pDevice->DrawTriangleFan(baseVertexOffset, pDrawPrimitiveArg->PrimitiveCount);
        }

        UINT instanceCount = 1;
        const UINT vertexCount = CalcVertexCount(pDrawPrimitiveArg->PrimitiveType, pDrawPrimitiveArg->PrimitiveCount);

        bool skipDraw;
        HRESULT hr = DrawProlog(*pDevice, baseVertexOffset, vertexCount, baseIndexOffset, 0, pDrawPrimitiveArg->PrimitiveType, instanceCount, skipDraw);
        CHECK_HR(hr);
        if (skipDraw)
        {
            return hr;
        }

        if (SUCCEEDED(hr))
        {
            pDevice->GetContext().DrawInstanced(vertexCount,
                instanceCount,
                0,// offset will be added in the vertex buffer resolve
                0);
        }

        hr = DrawEpilogue(*pDevice);
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr);
    }

    inline _Check_return_ HRESULT APIENTRY DrawIndexedPrimitive2(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_DRAWINDEXEDPRIMITIVE2* pData, _In_ UINT dwIndicesSize, _In_ CONST VOID* pIndexBuffer, _In_opt_ CONST UINT* pFlagBuffer)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        if (pFlagBuffer != nullptr)
        {
            Check9on12(false);
            return E_NOTIMPL;
        }
        
        UINT const stream0Stride = pDevice->GetPipelineState().GetInputAssembly().GetStream0Stride();
        Check9on12(stream0Stride > 0);

        bool bNegativeVertexOffset = pData->BaseVertexOffset < 0;
        OffsetArg baseVertexOffset = OffsetArg::AsOffsetInBytes(pData->BaseVertexOffset);
        OffsetArg drawOffset = OffsetArg::AsOffsetInVertices(0);

        // This is a corner case that gets hit when an app opts into software vertex processing. In these cases, the runtime
        // is always generating a new vertex buffer on-the-fly. As an optimization, if a MinIndex is passed into the API, the 
        // D3D9 runtime generates a smaller vertex buffer that skips over the vertices below the MinIndex. This 
        // leads to the current index buffer indices being incorrectly offset. Rather than generate a new index buffer, the runtime 
        // passes a negative vertex offset to make sure indices are correctly offset to the right vertices.
        if (bNegativeVertexOffset)
        {
            Check9on12((pData->BaseVertexOffset % (INT)stream0Stride == 0));
            Check9on12(pDevice->GetPipelineState().GetInputAssembly().GetNumBoundStreams() == 1);
            baseVertexOffset = OffsetArg::AsOffsetInBytes(0);
            drawOffset = OffsetArg::AsOffsetInVertices(pData->BaseVertexOffset / (INT)stream0Stride);
        }
        OffsetArg baseIndexOffset = OffsetArg::AsOffsetInBytes(pData->StartIndexOffset);

        HRESULT hr = pDevice->GetPipelineState().GetInputAssembly().SetIndexBufferUM(*pDevice, dwIndicesSize, pIndexBuffer);
        CHECK_HR(hr);
        
        if (SUCCEEDED(hr))
        {
            if (pData->PrimitiveType == D3DPT_TRIANGLEFAN)
            {
                return pDevice->DrawTriangleFanIndexed(baseVertexOffset, pData->NumVertices, baseIndexOffset, pData->PrimitiveCount);
            }

            UINT instanceCount = 1;
            const UINT indexCount = CalcVertexCount(pData->PrimitiveType, pData->PrimitiveCount);
            bool skipDraw;
            hr = DrawProlog(*pDevice, baseVertexOffset, pData->NumVertices, baseIndexOffset, indexCount, pData->PrimitiveType, instanceCount, skipDraw);
            CHECK_HR(hr);
            if (skipDraw)
            {
                return hr;
            }

            if (SUCCEEDED(hr))
            {
                pDevice->GetContext().DrawIndexedInstanced(indexCount,
                    instanceCount,
                    0,// offset will be added in the index buffer resolve,
                    drawOffset.GetOffsetInVertices(),
                    0);
            }
        }

        hr = DrawEpilogue(*pDevice);
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr);
    }

    inline HRESULT Device::DrawTriangleFan(_In_ OffsetArg baseVertex, _In_ UINT primitiveCount)
    {
        // Update index count
        UINT indexCount = CalcVertexCount(D3DPT_TRIANGLELIST, primitiveCount);

        if (m_triangleFanIndexBufferCache.isTriFanCacheInitialized)
        {
            if (primitiveCount > m_triangleFanIndexBufferCache.highestPrimitiveCountTriFan)
            {
                // We have to reallocate a new m_highestPCIndexBufferTriFan for the new primitiveCount, 
                // release the old one and update the cache variables

                GetContext().ClearInputBindings(m_triangleFanIndexBufferCache.highestPCIndexBufferTriFan.GetUnderlyingResource());

                m_triangleFanIndexBufferCache.highestPrimitiveCountTriFan = primitiveCount;

                D3D9on12::InputAssembly::CreateTriangleFanIndexBuffer(*this, m_triangleFanIndexBufferCache.highestPCIndexBufferTriFan, //InputBuffer& targetBuffer
                    indexCount // _In_ UINT& indexCount
                    );
            }
            // Otherwise it has to be primitiveCount <= m_highestPrimitiveCountTriFan
            // If current primitiveCount is less or equal than m_highestPrimitiveCountTriFan 
            // then we can use the IB stored in m_highestPCIndexBufferTriFan and the indexCount will autoadjust from primitiveCount
            // Do nothing, by default we'll load m_highestPCIndexBufferTriFan into the index buffers stack
            // The indexCount will autoadjust with the primitiveCount received and we can use a subset of the currently stored indexbuffer                  
        }
        else
        {
            // Initialization logic

            m_triangleFanIndexBufferCache.highestPrimitiveCountTriFan = primitiveCount;

            D3D9on12::InputAssembly::CreateTriangleFanIndexBuffer(*this, m_triangleFanIndexBufferCache.highestPCIndexBufferTriFan, //InputBuffer& targetBuffer
                indexCount // _In_ UINT& indexCount
                );

            m_triangleFanIndexBufferCache.isTriFanCacheInitialized = true;
        }

        GetPipelineState().GetInputAssembly().PushNewIndexBuffer(m_triangleFanIndexBufferCache.highestPCIndexBufferTriFan);

        //Draw logic

        UINT instanceCount = 1;

        bool skipDraw;
        OffsetArg baseIndexOffset = OffsetArg::AsOffsetInIndices(0);
        HRESULT hr = DrawProlog(*this, baseVertex, CalcVertexCount(D3DPT_TRIANGLEFAN, primitiveCount), baseIndexOffset, indexCount, D3DPT_TRIANGLEFAN, instanceCount, skipDraw);
        CHECK_HR(hr);

        if (!skipDraw && SUCCEEDED(hr))
        {
            INT baseVertexVal = 0;
            switch (baseVertex.m_type)
            {
            case OffsetType::OFFSET_IN_BYTES:
                baseVertexVal = 0;// offset will be added in the vertex buffer resolve
                break;
            case OffsetType::OFFSET_IN_VERTICES:
                baseVertexVal = baseVertex.GetOffsetInVertices();
                break;
            default:
                Check9on12(false);
                break;
            }

            GetContext().DrawIndexedInstanced(indexCount,
                instanceCount,
                baseIndexOffset.GetOffsetInIndices(),
                baseVertexVal,
                0);
        }

        if (SUCCEEDED(hr))
        {
            GetPipelineState().GetInputAssembly().RestorePreviousIB(*this);
            hr = DrawEpilogue(*this);
        }

        return hr;
    }

    inline HRESULT Device::DrawWireframeTriangleFanWithEdgeFlags(_In_ OffsetArg baseVertex, _In_ UINT primitiveCount, _In_ UINT edgeFlags)
    {
        UINT maxIndexCount = primitiveCount * 6; // 3 edges per triangle, 2 indices per edge
        InputBuffer indexBuffer;
        indexBuffer.InitAsPersistentTriangleFan(*this, maxIndexCount * sizeof(UINT), sizeof(UINT));
        auto pIndices = reinterpret_cast<UINT*>(indexBuffer.GetTriangleFanMemory());

        UINT indexCount = 0;
        for (UINT primitive = 0; primitive < primitiveCount; ++primitive)
        {
            UINT primitiveEdgeFlags = edgeFlags >> primitive;
            if (primitive == 0 && (primitiveEdgeFlags & 1))
            {
                pIndices[indexCount++] = 0;
                pIndices[indexCount++] = 1;
            }
            if (primitiveEdgeFlags & 2)
            {
                pIndices[indexCount++] = primitive + 1;
                pIndices[indexCount++] = primitive + 2;
            }
            if (primitive == primitiveCount - 1 && (primitiveEdgeFlags & 4))
            {
                pIndices[indexCount++] = primitive + 2;
                pIndices[indexCount++] = 0;
            }
        }

        GetPipelineState().GetInputAssembly().PushNewIndexBuffer(indexBuffer);

        //Draw logic

        UINT instanceCount = 1;

        bool skipDraw;
        OffsetArg baseIndexOffset = OffsetArg::AsOffsetInIndices(0);
        HRESULT hr = DrawProlog(*this, baseVertex, maxIndexCount, baseIndexOffset, indexCount, D3DPT_LINELIST, instanceCount, skipDraw);
        CHECK_HR(hr);

        if (!skipDraw && SUCCEEDED(hr))
        {
            INT baseVertexVal = 0;
            switch (baseVertex.m_type)
            {
            case OffsetType::OFFSET_IN_BYTES:
                baseVertexVal = 0;// offset will be added in the vertex buffer resolve
                break;
            case OffsetType::OFFSET_IN_VERTICES:
                baseVertexVal = baseVertex.GetOffsetInVertices();
                break;
            default:
                Check9on12(false);
                break;
            }

            GetContext().DrawIndexedInstanced(indexCount,
                instanceCount,
                baseIndexOffset.GetOffsetInIndices(),
                baseVertexVal,
                0);
        }

        if (SUCCEEDED(hr))
        {
            GetPipelineState().GetInputAssembly().RestorePreviousIB(*this);
            hr = DrawEpilogue(*this);
        }

        return hr;
    }

    inline HRESULT Device::DrawTriangleFanIndexed(_In_ OffsetArg baseVertex, _In_ UINT vertexCount, _In_ OffsetArg baseIndexLocation, _In_ UINT primitiveCount)
    {
        //Update index count
        UINT indexCount = CalcVertexCount(D3DPT_TRIANGLELIST, primitiveCount);

        D3D9on12::InputAssembly& inputAssembly = GetPipelineState().GetInputAssembly();
        InputBuffer &currentIndexBuffer = inputAssembly.CurrentIndexBuffer();
        void *pSrcIndexBuffer = nullptr;
        UINT stride = currentIndexBuffer.GetStrideInBytes();
        InputBuffer convertedIB;

        UINT indexOffsetInBytes;
        if (baseIndexLocation.m_type == OffsetType::OFFSET_IN_INDICES)
        {
            indexOffsetInBytes = baseIndexLocation.GetOffsetInIndices() * stride;
        }
        else
        {
            indexOffsetInBytes = baseIndexLocation.GetOffsetInBytes();
        }

        if (currentIndexBuffer.IsSystemMemory())
        {
            pSrcIndexBuffer = currentIndexBuffer.GetSystemMemoryBase();
            stride = currentIndexBuffer.GetStrideInBytes();

            D3D9on12::InputAssembly::CreateTriangleListIBFromTriangleFanIB(*this, pSrcIndexBuffer, stride, indexOffsetInBytes, indexCount, convertedIB);
        }
        else
        {
            // We would like to avoid accessing the GPU index buffer whenever possible because doing so causes a WaitOnCompletion(true) to be called.
            // There's a cached version of the last converted to triangle list index buffer read from this resource stored in the resource
            D3D9on12::Resource* appRes = currentIndexBuffer.GetAppResource();
            Check9on12(appRes);

            appRes->GetTriFanIB(convertedIB, indexOffsetInBytes, indexCount, currentIndexBuffer.GetStrideInBytes());
        }

        // Set the converted or cached index buffer in the stack
        inputAssembly.PushNewIndexBuffer(convertedIB);

        // Draw logic
        UINT instanceCount = 1;
        bool skipDraw;
        HRESULT hr = DrawProlog(*this, baseVertex, vertexCount, baseIndexLocation, indexCount, D3DPT_TRIANGLEFAN, instanceCount, skipDraw);
        CHECK_HR(hr);

        if (!skipDraw && SUCCEEDED(hr))
        {
            UINT const stream0Stride = GetPipelineState().GetInputAssembly().GetStream0Stride();
            Check9on12(stream0Stride > 0);

            UINT baseVertexVal = 0;
            switch (baseVertex.m_type)
            {
            case OffsetType::OFFSET_IN_BYTES:
                baseVertexVal = 0;// offset will be added in the vertex buffer resolve
                break;
            case OffsetType::OFFSET_IN_VERTICES:
                baseVertexVal = baseVertex.GetOffsetInVertices();
                break;
            default:
                Check9on12(false);
                break;
            }

            GetContext().DrawIndexedInstanced(indexCount,
                instanceCount,
                0,
                baseVertexVal,
                0);
        }

        if (SUCCEEDED(hr))
        {
            GetPipelineState().GetInputAssembly().RestorePreviousIB(*this);

            hr = DrawEpilogue(*this);
        }

        return hr;
    }

    inline _Check_return_ HRESULT APIENTRY DrawIndexedPrimitive(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_DRAWINDEXEDPRIMITIVE* pDrawPrimitiveArg)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pDrawPrimitiveArg == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }
        UINT instanceCount = 1;

        UINT IndexCountPerInstance = CalcVertexCount(pDrawPrimitiveArg->PrimitiveType, pDrawPrimitiveArg->PrimitiveCount);
        UINT StartInstanceLocation = 0;
        const UINT vertexCount = pDrawPrimitiveArg->MinIndex + pDrawPrimitiveArg->NumVertices;

        OffsetArg baseIndexOffset = OffsetArg::AsOffsetInIndices(pDrawPrimitiveArg->StartIndex);
        OffsetArg baseVertexOffset = OffsetArg::AsOffsetInVertices(pDrawPrimitiveArg->BaseVertexIndex);

        HRESULT hr = S_OK;
        if (pDrawPrimitiveArg->PrimitiveType == D3DPT_TRIANGLEFAN)
        {
            hr = pDevice->DrawTriangleFanIndexed(baseVertexOffset, vertexCount, baseIndexOffset, pDrawPrimitiveArg->PrimitiveCount);
        }
        else
        {
            bool skipDraw;
            hr = DrawProlog(*pDevice, baseVertexOffset, vertexCount, baseIndexOffset, IndexCountPerInstance, pDrawPrimitiveArg->PrimitiveType, instanceCount, skipDraw);
            CHECK_HR(hr);

            if (skipDraw)
            {
                return hr;
            }

            if (SUCCEEDED(hr))
            {
                pDevice->GetContext().DrawIndexedInstanced(
                    IndexCountPerInstance,
                    instanceCount,
                    baseIndexOffset.GetOffsetInIndices(),
                    baseVertexOffset.GetOffsetInVertices(),
                    StartInstanceLocation);
            }
        }

        hr = DrawEpilogue(*pDevice);
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr);
    }
};

```

`include/pch.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#pragma once
#define DIRECT3D_VERSION 0x0900

#undef WIN32_LEAN_AND_MEAN
#include <windows.h> // Yes, with MINMAX
#include <D3D12TranslationLayerDependencyIncludes.h>
#include <D3D12TranslationLayerIncludes.h>

#include <d3d12tokenizedprogramformat.hpp>
#include <d3d9types.h>
#include <d3d9.h>
#include <dxva.h>
#include <dxva2api.h>

#include <d3dhal.h>
#include <d3dumddi.h>

#include <ShaderConv.h>
#include <d3dcompiler.h>
#include <BlobContainer.h>

#include <d3dkmthk.h>
#include <DirectXMath.h>
#include <d3d9on12DDI.h>

//SDK Headers
#include <atlstr.h>

//STL
#include <utility>
#include <vector>
#include <queue>
#include <map>
#include <set>
#include <unordered_map>
#include <memory>
#include <cstddef>
#include <functional>
#include <new>
#include <bitset>
#include <algorithm>
#include <tuple>
#include <string>
#include <stack>
#include <deque>


#define BIT( x ) ( 1 << (x) )
#if DBG

#define Check9on12( a ) \
    __pragma(warning(suppress:4127)) /* conditional is constant due to constant macro parameter(s) */ \
    if((a) == FALSE) {DebugBreak();} \

#define CHECK_HR( hr ) Check9on12(SUCCEEDED(hr));
#else
#define Check9on12( a ) (void)(UNREFERENCED_PARAMETER(a))
#define CHECK_HR( hr ) (UNREFERENCED_PARAMETER(hr))
#endif

#define SAFE_DELETE( a ) if( (a) != nullptr ) { delete(a); }
#define D3DFMT_AYUV         ((D3DFORMAT)MAKEFOURCC('A', 'Y', 'U', 'V'))  

//TODO: Find out why WARP uses this
// Dx7- texture stage state
#define  D3DTSS_ADDRESS 12

namespace D3D9on12
{
    enum
    {
        MAX_ACTIVE_LIGHTS = 8,
        MAX_USER_CLIPPLANES = 8,
        MAX_VERTEX_BLEND_MATRICES = 4,
        MAX_WORLD_MATRICES = 12,
        MAX_VERTEX_BLEND_MATRIX_INDEX = 0,
        MAX_VERTEX_STREAMS = 16,
        VERTEX_STREAMS_MASK = ((1 << MAX_VERTEX_STREAMS) - 1),
        INDEX_STREAM_MASK = (1 << MAX_VERTEX_STREAMS),
        MAX_TEXTURE_STAGES = D3DHAL_SAMPLER_MAXSAMP,
        MAX_RENDER_TARGETS = D3D_MAX_SIMULTANEOUS_RENDERTARGETS,
        MAX_TEXTURE_WIDTH_SIZE = (1 << 14),
        MAX_TEXTURE_HEIGHT_SIZE = (1 << 14),
        MAX_VOLUME_EXTENT = (1 << 14),
        MAX_POINT_SIZE = (1 << 13),
        MIN_POINT_SIZE = 1,
        MAX_TEXTURE_REPEAT = (1 << 13),
        MAX_TEXTURE_ASPECT_RATIO = (1 << 13),
        MAX_VS_CONSTANTSF = 256,
        MAX_VS_CONSTANTSI = 16,
        MAX_VS_CONSTANTSB = 16,
        MAX_PS_CONSTANTSF = 224,
        MAX_PS_CONSTANTSI = 16,
        MAX_PS_CONSTANTSB = 16,
        PIXEL_SAMPLER0 = 0,
        MAX_PIXEL_SAMPLERS = D3DHAL_SAMPLER_MAXSAMP,
        DMAP_SAMPLER = MAX_PIXEL_SAMPLERS,
        VERTEX_SAMPLER0 = DMAP_SAMPLER + 1,
        MAX_VERTEX_SAMPLERS = D3DHAL_SAMPLER_MAXVERTEXSAMP,
        MAX_SAMPLERS_STAGES = VERTEX_SAMPLER0 + MAX_VERTEX_SAMPLERS,
        MAX_D3DTSS = 35,
        PIXEL_SAMPLERS_MASK = ((1 << MAX_PIXEL_SAMPLERS) - 1),
        VERTEX_SAMPLERS_MASK = (((1 << MAX_VERTEX_SAMPLERS) - 1) << VERTEX_SAMPLER0),

        MAX_INPUT_ELEMENTS = 32,

        // Used to denote that an Index buffer is bound and it's not immediately clear 
        // how many vertices will be needed in the VB
        UNKNOWN_VERTEX_COUNT = UINT_MAX,

        // First 4 least significant bits set representing the 4 color channels
        COLOR_CHANNEL_MASK = 0xf,

        MAX_MIPS = 14,
        NUM_DXGI_FORMATS = 132,

        MAX_PLANES = 3
    };

    enum ShaderType
    {
        VERTEX_SHADER = 0,
        GEOMETRY_SHADER,
        PIXEL_SHADER,
        NUM_SHADER_TYPES
    };

    const UINT NUM_VS_ROOT_CBVS = 4;
    const UINT NUM_PS_ROOT_CBVS = 6;

    enum RootSignature
    {
        VS_ROOT_CBV0 = 0,
        PS_ROOT_CBV0 = VS_ROOT_CBV0 + NUM_VS_ROOT_CBVS,
        PS_SRVS = PS_ROOT_CBV0 + NUM_PS_ROOT_CBVS,
        VS_SRVS,
        PS_SAMPLERS,
        VS_SAMPLERS,
        NUM_SLOTS,
        FLOAT_CB_ROOT_INDEX = 0,
        INTEGER_CB_ROOT_INDEX = 1,
        BOOLEAN_CB_ROOT_INDEX = 2,
    };

    enum ShaderMasks
    {
        R_MASK = D3D10_SB_COMPONENT_MASK_R,
        RG_MASK = R_MASK | D3D10_SB_COMPONENT_MASK_G,
        RGB_MASK = RG_MASK | D3D10_SB_COMPONENT_MASK_B,
        RGBA_MASK = RGB_MASK | D3D10_SB_COMPONENT_MASK_A
    };

    const D3DFORMAT D3DFMT_INTZ = D3DFORMAT(MAKEFOURCC('I', 'N', 'T', 'Z'));
    const D3DFORMAT D3DFMT_RAWZ = D3DFORMAT(MAKEFOURCC('R', 'A', 'W', 'Z'));
    const D3DFORMAT D3DFMT_DF16 = D3DFORMAT(MAKEFOURCC('D', 'F', '1', '6'));
    const D3DFORMAT D3DFMT_DF24 = D3DFORMAT(MAKEFOURCC('D', 'F', '2', '4'));
    const D3DFORMAT D3DFMT_NULL = D3DFORMAT(MAKEFOURCC('N', 'U', 'L', 'L'));
    const D3DFORMAT D3DFMT_ATI1 = D3DFORMAT(MAKEFOURCC('A', 'T', 'I', '1'));
    const D3DFORMAT D3DFMT_ATI2 = D3DFORMAT(MAKEFOURCC('A', 'T', 'I', '2'));
    const D3DFORMAT D3DFMT_ATOC = D3DFORMAT(MAKEFOURCC('A', 'T', 'O', 'C')); //Nvidia alpha to coverage (ADAPTIVETESS_Y)
    const D3DFORMAT D3DFMT_A2M0 = D3DFORMAT(MAKEFOURCC('A', '2', 'M', '0')); //ATI disable Alpha to coverage (D3DRS_POINTSIZE)
    const D3DFORMAT D3DFMT_A2M1 = D3DFORMAT(MAKEFOURCC('A', '2', 'M', '1')); //ATI enable Alpha to coverage (D3DRS_POINTSIZE)
    const D3DFORMAT D3DFMT_NV12 = D3DFORMAT(MAKEFOURCC('N', 'V', '1', '2'));
    const D3DFORMAT D3DFMT_420O = D3DFORMAT(MAKEFOURCC('4', '2', '0', 'O'));
    const D3DFORMAT D3DFMT_NV11 = D3DFORMAT(MAKEFOURCC('N', 'V', '1', '1'));
    const D3DFORMAT D3DFMT_AI44 = D3DFORMAT(MAKEFOURCC('A', 'I', '4', '4'));
    const D3DFORMAT D3DFMT_IA44 = D3DFORMAT(MAKEFOURCC('I', 'A', '4', '4'));
    const D3DFORMAT D3DFMT_Y410 = D3DFORMAT(MAKEFOURCC('Y', '4', '1', '0'));
    const D3DFORMAT D3DFMT_Y416 = D3DFORMAT(MAKEFOURCC('Y', '4', '1', '6'));
    const D3DFORMAT D3DFMT_P010 = D3DFORMAT(MAKEFOURCC('P', '0', '1', '0'));
    const D3DFORMAT D3DFMT_P016 = D3DFORMAT(MAKEFOURCC('P', '0', '1', '6'));
    const D3DFORMAT D3DFMT_Y210 = D3DFORMAT(MAKEFOURCC('Y', '2', '1', '0'));
    const D3DFORMAT D3DFMT_Y216 = D3DFORMAT(MAKEFOURCC('Y', '2', '1', '6'));
    const D3DFORMAT D3DFMT_YV12 = D3DFORMAT(MAKEFOURCC('Y', 'V', '1', '2'));
    const D3DFORMAT D3DFMT_RESZ = D3DFORMAT(MAKEFOURCC('R', 'E', 'S', 'Z'));

    // This appears to be the value agreed on by IHVs, though this is mostly arbitrary
    const UINT BPP_FOR_IHV_BLOCK_COMPRESSED_FORMATS = 8;

    const D3D_FEATURE_LEVEL MinSupportedFeatureLevel = D3D_FEATURE_LEVEL_11_0;
    const bool cSupportsPlanarSRVs = false;

    const UINT RESZ_CODE = 0x7fa05000;
}

DEFINE_GUID(DXVADDI_VideoProcD3D9On12CustomDeinterlaceDevice, 0xe064b480, 0xa8bb, 0x4d81, 0x81, 0x81, 0x59, 0xdc, 0x0b, 0xe5, 0x1d, 0x02);

#include <9on12Registry.h>
#include <9on12Warning.h>
#include <9on12.h>
#include <9on12Util.h>
#include <9on12DDI.h>
#include <9on12AppCompat.h>
#include <9on12FastUploadAllocator.h>
#include <9on12PipelineStateStructures.h>
#include <9on12InputLayout.h>
#include <9on12InputAssembly.h>
#include <9on12PixelStage.h>
#include <9on12PipelineStateCache.h>
#include <9on12Shader.h>
#include <9on12VertexStage.h>
#include <9on12PipelineState.h>
#include <9on12Resource.h>
#include <9on12SwapChain.h>
#include <9on12Constants.h>
#include <9on12Adapter.h>
#include <9on12DataLogger.h>
#include <9on12Fence.h>
#include <9on12VideoDevice.h>
#include <9on12Device.h>
#include <9on12Query.h>
#include <d3d9caps.h>
#include <9on12Caps.h>
#include <9on12VideoTranslate.h>
#include <9on12DecodeDevice.h>
#include <9on12VideoProcessDevice.h>

//INLs
#include <9on12Draw.inl>

```

`interface/d3d9on12ddi.h`:

```h
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/*==========================================================================;
*
*  Copyright (C) Microsoft Corporation.  All Rights Reserved.
*
*  File:   d3d9on12DDI.h
*  Content:    Private DDI specific for 9on12
*
****************************************************************************/

#ifndef _D3D9ON12DDI_H_
#define _D3D9ON12DDI_H_

#define D3D9ON12_CURRENT_INTERFACE_VERSION 2

typedef struct _D3D9ON12_CREATE_DEVICE_ARGS
{
    IUnknown* pD3D12Device;
    IUnknown** ppD3D12Queues;
    UINT NumQueues;
    UINT NodeMask;

} D3D9ON12_CREATE_DEVICE_ARGS;

typedef _Check_return_ HRESULT(APIENTRY* PFND3D9ON12_OPENADAPTER)(
    _Inout_ D3DDDIARG_OPENADAPTER* pOpenAdapter, _In_ LUID* pLUID, _In_opt_ D3D9ON12_CREATE_DEVICE_ARGS* pArgs);

typedef struct _D3D9ON12_PRESENTCB_ARGS
{
    _In_ ID3D12CommandQueue* pGraphicsCommandQueue;
    _In_ ID3D12CommandList* pGraphicsCommandList;
    _In_reads_(numSrcSurfaces) const D3DDDIARG_PRESENTSURFACE* pSrcSurfaces;
    UINT numSrcSurfaces;
    _In_opt_ HANDLE hDestResource;
    UINT flipInterval;
    UINT vidPnSourceId;
    _In_ D3DKMT_PRESENT* pKMTPresent;
} D3D9ON12_PRESENTCB_ARGS;


typedef HRESULT(CALLBACK* PFND3D9ON12_PRESENTCB)(_In_ HANDLE, _In_ D3D9ON12_PRESENTCB_ARGS*);
typedef HRESULT(CALLBACK* PFND3D9ON12_SIGNDXBCCB)(_Inout_ BYTE* pData, _In_ UINT32 byteCount);

typedef struct _D3D9ON12_PRIVATE_CALLBACKS
{
    PFND3D9ON12_PRESENTCB pfnPresentCB;
    PFND3D9ON12_SIGNDXBCCB pfnSignDxbcCB;
} D3D9ON12_PRIVATE_CALLBACKS;

typedef struct _D3D9ON12_CREATE_DEVICE_ARGS2
{
    IUnknown *pD3D12Device;
    IUnknown **ppD3D12Queues;
    UINT NumQueues;
    UINT NodeMask;
    UINT D3D9On12InterfaceVersion;
    D3D9ON12_PRIVATE_CALLBACKS* pPrivateCallbacks;

} D3D9ON12_CREATE_DEVICE_ARGS2;

typedef _Check_return_ HRESULT(APIENTRY *PFND3D9ON12_OPENADAPTER2)(
    _Inout_ D3DDDIARG_OPENADAPTER* pOpenAdapter, _In_ LUID *pLUID, _In_opt_ D3D9ON12_CREATE_DEVICE_ARGS2 *pArgs);

typedef _Check_return_ HRESULT(APIENTRY *PFND3D9ON12_GETSHAREDGDIHANDLE)(
    _In_ HANDLE hDevice, HANDLE DriverResource, HANDLE *pSharedHandle);

typedef _Check_return_ HRESULT(APIENTRY *PFND3D9ON12_CREATESHAREDNTHANDLE)(
    _In_ HANDLE hDevice, HANDLE DriverResource, __in_opt SECURITY_DESCRIPTOR* pSD, HANDLE *pSharedHandle);

typedef _Check_return_ HRESULT(APIENTRY *PFND3D9ON12_GETDEVICESTATE)(
    _In_ HANDLE hDevice);

typedef _Check_return_ HRESULT(APIENTRY *PFND3D9ON12_KMTPRESENT)(
    _In_ HANDLE hDevice, D3DKMT_PRESENT *pKMTArgs);
    
#define D3D9ON12USAGE_CROSSADAPTER 0x1
#define D3D9ON12USAGE_DEFERREDFENCEWAITS 0x2
#define D3D9ON12USAGE_MONITOREDFENCE 0x8

// The first four members of all the _DESC structs are 
// always the same (even for buffers). 
// We use that fact to create a common _DESC in order
// to differentiate the kind of resource
typedef struct {
    D3DMULTISAMPLE_TYPE MultiSampleType;
    DWORD               MultiSampleQuality;
    UINT Levels;
    UINT Depth;
} D3D9ON12_TEXTURE_DESC;

typedef struct {
    DWORD FVF;
    UINT  Size;
} D3D9ON12_BUFFER_DESC;

typedef struct _D3D9ON12_RESOURCE_INFO
{
    UINT                Width;
    UINT                Height;
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;
    DWORD               Usage;
    D3DPOOL             Pool;
    BOOL bNtHandle;
    BOOL bAllocatedBy9on12;

    union
    {
        // D3DRTYPE_SURFACE, D3DRTYPE_VOLUME, D3DRTYPE_TEXTURE, D3DRTYPE_VOLUMETEXTURE, D3DRTYPE_CUBETEXTURE
        D3D9ON12_TEXTURE_DESC TextureDesc;

        // D3DRTYPE_INDEXBUFFER, D3DRTYPE_VERTEXBUFFER
        D3D9ON12_BUFFER_DESC BufferDesc;
    };
} D3D9ON12_RESOURCE_INFO;

typedef struct _D3D9ON12_OPEN_RESOURCE_ARGS
{
    D3DFORMAT           Format;
} D3D9ON12_OPEN_RESOURCE_ARGS;

typedef enum D3D9ON12_COMMANDLIST_TYPE
{
    D3D9ON12_COMMANDLIST_TYPE_GRAPHICS = 0,
    D3D9ON12_COMMANDLIST_TYPE_VIDEO_DECODE = 1,
    D3D9ON12_COMMANDLIST_TYPE_VIDEO_PROCESS = 2,
    D3D9ON12_COMMANDLIST_TYPE_MAX_VALID = 3,
    D3D9ON12_COMMANDLIST_TYPE_UNKNOWN = D3D9ON12_COMMANDLIST_TYPE_MAX_VALID,
} D3D9ON12_COMMANDLIST_TYPE;

typedef _Check_return_ HRESULT(APIENTRY *PFND3D9ON12_CREATEFENCE)(
    HANDLE hDD, UINT64 InitialValue, UINT Flags, __out HANDLE* phFence);

typedef _Check_return_ HRESULT(APIENTRY *PFND3D9ON12_OPENFENCE)(
    HANDLE hDD, HANDLE hSharedHandle, __out BOOL* pbMonitored, __out HANDLE* phFence);

typedef _Check_return_ HRESULT(APIENTRY *PFND3D9ON12_SHAREFENCE)(
    HANDLE hFence, __in_opt SECURITY_DESCRIPTOR*, __out HANDLE*);

typedef _Check_return_ HRESULT(APIENTRY *PFND3D9ON12_WAITFORFENCE)(
    HANDLE hFence, UINT64 NewFenceValue);

typedef _Check_return_ HRESULT(APIENTRY *PFND3D9ON12_SIGNALFENCE)(
    HANDLE hFence, UINT64 NewFenceValue);

typedef UINT64(APIENTRY *PFND3D9ON12_GETCOMPLETEDFENCEVALUE)(
    HANDLE hFence);

typedef void(APIENTRY *PFND3D9ON12_DESTROYTRACKEDFENCE)(
    HANDLE hFence);

typedef UINT (APIENTRY *PFND3D9ON12_QUERYRESOURCEPRIVATEDRIVERDATASIZE)(HANDLE hDD);

typedef _Check_return_ HRESULT (APIENTRY *PFND3D9ON12_QUERYRESOURCEINFOFROMKMTHANDLE)(
    HANDLE hDD, D3DKMT_HANDLE hKMResource, _Out_ D3D9ON12_RESOURCE_INFO *pResourceInfo);

typedef _Check_return_ HRESULT(APIENTRY *PFND3D9ON12_CREATEKMTHANDLE)(
    HANDLE hDD, _In_ HANDLE resourceHandle, _Out_ D3DKMT_HANDLE *pHKMResource, _Out_writes_bytes_(dataSize) void* pResourcePrivateDriverData, UINT dataSize);

typedef _Check_return_ HRESULT(APIENTRY *PFND3D9ON12_DESTROYKMTHANDLE)(
    HANDLE hDD, D3DKMT_HANDLE hKMResource);

typedef _Check_return_ HRESULT(APIENTRY *PFND3D9ON12_OPENRESOURCE)(
    HANDLE hDD, _Inout_ D3DDDIARG_OPENRESOURCE* hOpenResource, _In_ D3D9ON12_OPEN_RESOURCE_ARGS *pOpenResourceArgs);

typedef _Check_return_ HRESULT(APIENTRY *PFND3D9ON12_CREATERESOURCEWRAPPINGHANDLE)(
    HANDLE hDD, _In_ IUnknown* pD3D12Resource, _Out_ HANDLE* phWrappingHandle);

typedef void(APIENTRY *PFND3D9ON12_DESTROYRESOURCEWRAPPINGHANDLE)(HANDLE hDD, HANDLE hWrappingHandle);

typedef _Check_return_ HRESULT(APIENTRY *PFND3D9ON12_GETD3D12DEVICE)(HANDLE hDD, REFIID riid, void** ppv);

typedef void(APIENTRY *PFND3D9ON12_RESOURCECHANGESTATE)(HANDLE hDD, HANDLE hResource, UINT State);

typedef void(APIENTRY *PFND3D9ON12_SETMAXIMUMFRAMELATENCY)(HANDLE hDD, UINT MaxFrameLatency);
typedef BOOL(APIENTRY *PFND3D9ON12_ISMAXIMUMFRAMELATENCYREACHED)(HANDLE hDD);

typedef _Check_return_ HRESULT(APIENTRY *PFND3D9ON12_GETD3D12RESOURCE)(HANDLE hResource, REFIID riid, void** ppv);
typedef _Check_return_ HRESULT(APIENTRY *PFND3D9ON12_ADDRESOURCEWAITSTOQUEUE)(HANDLE hResource, ID3D12CommandQueue* pCommmandQueue);
typedef _Check_return_ HRESULT(APIENTRY *PFND3D9ON12_ADDDEFERREDWAITSTORESOURCE)(HANDLE hResource, UINT NumSync, UINT64* pSignalValues, ID3D12Fence** ppFences);

typedef _Check_return_ HRESULT(APIENTRY *PFND3D9ON12_CLOSEANDSUBMITGRAPHICSCOMMANDLISTFORPRESENT)(
    _In_ HANDLE hDevice, BOOL commandsAdded, _In_reads_(numSrcSurfaces) const D3DDDIARG_PRESENTSURFACE* pSrcSurfaces, UINT numSrcSurfaces, _In_opt_ HANDLE hDestResource, _In_ D3DKMT_PRESENT* pKMTPresent);
typedef _Check_return_ HRESULT(APIENTRY *PFND3D9ON12_PREEXECUTECOMMANDQUEUECOMMAND)(_In_ HANDLE hDevice, D3D9ON12_COMMANDLIST_TYPE commandListType);
typedef _Check_return_ HRESULT(APIENTRY *PFND3D9ON12_POSTEXECUTECOMMANDQUEUECOMMAND)(_In_ HANDLE hDevice, D3D9ON12_COMMANDLIST_TYPE commandListType);

typedef struct _D3D9ON12_PRIVATE_DDI_TABLE
{
    PFND3D9ON12_OPENADAPTER pfnOpenAdapter;

    PFND3D9ON12_GETSHAREDGDIHANDLE pfnGetSharedGDIHandle;
    PFND3D9ON12_CREATESHAREDNTHANDLE pfnCreateSharedNTHandle;
    PFND3D9ON12_GETDEVICESTATE pfnGetDeviceState;
    PFND3D9ON12_KMTPRESENT pfnKMTPresent;

    PFND3D9ON12_CREATEFENCE pfnCreateFence;
    PFND3D9ON12_OPENFENCE pfnOpenFence;
    PFND3D9ON12_SHAREFENCE pfnShareFence;
    PFND3D9ON12_WAITFORFENCE pfnWaitForFence;
    PFND3D9ON12_SIGNALFENCE pfnSignalFence;

    PFND3D9ON12_GETCOMPLETEDFENCEVALUE pfnGetCompletedFenceValue;
    PFND3D9ON12_DESTROYTRACKEDFENCE pfnDestroyTrackedFence;

    PFND3D9ON12_QUERYRESOURCEPRIVATEDRIVERDATASIZE pfnQueryResourcePrivateDriverDataSize;
    PFND3D9ON12_OPENRESOURCE pfnOpenResource;

    PFND3D9ON12_CREATEKMTHANDLE pfnCreateKMTHandle;
    PFND3D9ON12_QUERYRESOURCEINFOFROMKMTHANDLE pfnQueryResourceInfoFromKMTHandle;
    PFND3D9ON12_DESTROYKMTHANDLE pfnDestroyKMTHandle;

    PFND3D9ON12_CREATERESOURCEWRAPPINGHANDLE pfnCreateResourceWrappingHandle;
    PFND3D9ON12_DESTROYRESOURCEWRAPPINGHANDLE pfnDestroyResourceWrappingHandle;

    PFND3D9ON12_GETD3D12DEVICE pfnGetD3D12Device;
    PFND3D9ON12_RESOURCECHANGESTATE pfnTransitionResource;
    PFND3D9ON12_RESOURCECHANGESTATE pfnSetCurrentResourceState;

    PFND3D9ON12_SETMAXIMUMFRAMELATENCY pfnSetMaximumFrameLatency;
    PFND3D9ON12_ISMAXIMUMFRAMELATENCYREACHED pfnIsMaxmimumFrameLatencyReached;
    PFND3D9ON12_GETD3D12RESOURCE pfnGetD3D12Resource;
    PFND3D9ON12_ADDRESOURCEWAITSTOQUEUE pfnAddResourceWaitsToQueue;
    PFND3D9ON12_ADDDEFERREDWAITSTORESOURCE pfnAddDeferredWaitsToResource;

    //New DDIs should be added to D3D9ON12_PRIVATE_DDI_TABLE2 only
} D3D9ON12_PRIVATE_DDI_TABLE;

typedef struct _D3D9ON12_PRIVATE_DDI_TABLE_VERSIONED
{
    PFND3D9ON12_OPENADAPTER pfnOpenAdapter;

    PFND3D9ON12_GETSHAREDGDIHANDLE pfnGetSharedGDIHandle;
    PFND3D9ON12_CREATESHAREDNTHANDLE pfnCreateSharedNTHandle;
    PFND3D9ON12_GETDEVICESTATE pfnGetDeviceState;
    PFND3D9ON12_KMTPRESENT pfnKMTPresent;

    PFND3D9ON12_CREATEFENCE pfnCreateFence;
    PFND3D9ON12_OPENFENCE pfnOpenFence;
    PFND3D9ON12_SHAREFENCE pfnShareFence;
    PFND3D9ON12_WAITFORFENCE pfnWaitForFence;
    PFND3D9ON12_SIGNALFENCE pfnSignalFence;

    PFND3D9ON12_GETCOMPLETEDFENCEVALUE pfnGetCompletedFenceValue;
    PFND3D9ON12_DESTROYTRACKEDFENCE pfnDestroyTrackedFence;

    PFND3D9ON12_QUERYRESOURCEPRIVATEDRIVERDATASIZE pfnQueryResourcePrivateDriverDataSize;
    PFND3D9ON12_OPENRESOURCE pfnOpenResource;

    PFND3D9ON12_CREATEKMTHANDLE pfnCreateKMTHandle;
    PFND3D9ON12_QUERYRESOURCEINFOFROMKMTHANDLE pfnQueryResourceInfoFromKMTHandle;
    PFND3D9ON12_DESTROYKMTHANDLE pfnDestroyKMTHandle;

    PFND3D9ON12_CREATERESOURCEWRAPPINGHANDLE pfnCreateResourceWrappingHandle;
    PFND3D9ON12_DESTROYRESOURCEWRAPPINGHANDLE pfnDestroyResourceWrappingHandle;

    PFND3D9ON12_GETD3D12DEVICE pfnGetD3D12Device;
    PFND3D9ON12_RESOURCECHANGESTATE pfnTransitionResource;
    PFND3D9ON12_RESOURCECHANGESTATE pfnSetCurrentResourceState;

    PFND3D9ON12_SETMAXIMUMFRAMELATENCY pfnSetMaximumFrameLatency;
    PFND3D9ON12_ISMAXIMUMFRAMELATENCYREACHED pfnIsMaxmimumFrameLatencyReached;
    PFND3D9ON12_GETD3D12RESOURCE pfnGetD3D12Resource;
    PFND3D9ON12_ADDRESOURCEWAITSTOQUEUE pfnAddResourceWaitsToQueue;
    PFND3D9ON12_ADDDEFERREDWAITSTORESOURCE pfnAddDeferredWaitsToResource;

    // Entries beyond this point only valid when D3D9On12InterfaceVersion >= 2
    PFND3D9ON12_OPENADAPTER2 pfnOpenAdapter2;
    PFND3D9ON12_CLOSEANDSUBMITGRAPHICSCOMMANDLISTFORPRESENT pfnCloseAndSubmitGraphicsCommandListForPresent;
    PFND3D9ON12_PREEXECUTECOMMANDQUEUECOMMAND pfnPreExecuteCommandQueueCommand;
    PFND3D9ON12_POSTEXECUTECOMMANDQUEUECOMMAND pfnPostExecuteCommandQueueCommand;
} D3D9ON12_PRIVATE_DDI_TABLE_VERSIONED;

typedef void (APIENTRY *PFND3D9ON12_GETPRIVATEDDITABLE)(
    D3D9ON12_PRIVATE_DDI_TABLE *pPrivateDDITable);
typedef HRESULT (APIENTRY* PFND3D9ON12_GETPRIVATEDDITABLEVERSIONED)(
    _Inout_updates_bytes_(ddiTableSize) void* pPrivateDDITableVersioned, UINT ddiTableSize);

#define D3D9ON12_PIXEL_SHADER_MASK 0x1
#define D3D9ON12_VERTEX_SHADER_MASK 0x2

typedef struct _D3D9ON12_APP_COMPAT_INFO
{
    DWORD AnythingTimes0Equals0ShaderMask;
    DWORD PSOCacheTrimLimitSize;  // PSO cache will be trimmed if its size is greater then this limit
    DWORD PSOCacheTrimLimitAge;   // We will only trim PSOs that are older then this age (age in command list age)
    DWORD MaxAllocatedUploadHeapSpacePerCommandList; // Maximum amount of storage allocated for upload operations per command list before flush
    DWORD MaxSRVHeapSize; // Maximum number of entries in the sharer resource view decriptor heap
    DWORD BufferPoolTrimThreshold; // How many fences (roughly translates to frames) a buffer in the buffer pool is allowed to exist before it is eleigible for being reclaimed. Must be in the range 5-100 to have an effect
	DWORD DisableIntzDSVFix; // Disables the fix for INTZ DSV also bound as SRV that disables ZWrite instead of hiding SRV. Some apps (ex: GTAIV) actually require the opposite behavior. This is a workaround until "feedback loop" surfaces are possible in d3d12
} D3D9ON12_APP_COMPAT_INFO;

typedef void (APIENTRY *PFND3D9ON12_SETAPPCOMPATDATA)(
    const D3D9ON12_APP_COMPAT_INFO *pAppCompatData);
#endif /* _D3D9ON12DDI_H_ */


```

`packages.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="Microsoft.Direct3D.DxbcSigner" version="1.0.0" targetFramework="native" />
</packages>
```

`src/9on12.cpp`:

```cpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#include "pch.h"

extern "C" PFND3DDDI_OPENADAPTER Get9on12OpenAdapter()
{
    return D3D9on12::OpenAdapter;
}

const IID GUID_NULL = {};

```

`src/9on12Adapter.cpp`:

```cpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#include "pch.h"

namespace D3D9on12
{
    _Check_return_ HRESULT APIENTRY GetCaps(_In_ HANDLE hAdapter, _Inout_ CONST D3DDDIARG_GETCAPS* pGetCaps)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Adapter* pAdapter = Adapter::GetAdapterFromHandle(hAdapter);
        if (pAdapter == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        switch (pGetCaps->Type)
        {
        case D3DDDICAPS_GETFORMATCOUNT:
            *reinterpret_cast<UINT*>(pGetCaps->pData) = pAdapter->GetFormatData(NULL);
            break;
        case D3DDDICAPS_GETFORMATDATA:
            pAdapter->GetFormatData(reinterpret_cast<FORMATOP*>(pGetCaps->pData), pGetCaps->DataSize / sizeof(FORMATOP));
            break;
        case D3DDDICAPS_GETD3D9CAPS:
            GetD3D9Caps(reinterpret_cast<D3DCAPS9*>(pGetCaps->pData));
            break;
        case D3DDDICAPS_GETMULTISAMPLEQUALITYLEVELS:
        {
            DDIMULTISAMPLEQUALITYLEVELSDATA* const pMSQL = reinterpret_cast<DDIMULTISAMPLEQUALITYLEVELSDATA*>(pGetCaps->pData);
            switch (pMSQL->MsType)
            {
            case D3DDDIMULTISAMPLE_NONE:
                pMSQL->QualityLevels = 0;
                break;
            case D3DDDIMULTISAMPLE_NONMASKABLE:
                pMSQL->QualityLevels = 3;
                break;
            default:
                D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS MSQL =
                {
                    ConvertFromDDIToDXGIFORMAT(pMSQL->Format),
                    (UINT)pMSQL->MsType,
                    D3D12_MULTISAMPLE_QUALITY_LEVELS_FLAG_NONE,
                    1 // Default num quality levels of 1
                };
                (void)pAdapter->GetDevice()->CheckFeatureSupport(D3D12_FEATURE_MULTISAMPLE_QUALITY_LEVELS, &MSQL, sizeof(MSQL));
                pMSQL->QualityLevels = MSQL.NumQualityLevels;
                break;
            }
            break;
        }
        case D3DDDICAPS_GETD3DQUERYCOUNT:
            *reinterpret_cast<UINT*>(pGetCaps->pData) = GetD3DQueryTypes(NULL, 0);
            break;
        case D3DDDICAPS_GETD3DQUERYDATA:
            GetD3DQueryTypes(reinterpret_cast<D3DQUERYTYPE*>(pGetCaps->pData), pGetCaps->DataSize / sizeof(D3DDDIQUERYTYPE));
            break;

        case D3DDDICAPS_GETDECODEGUIDCOUNT:
        case D3DDDICAPS_GETDECODEGUIDS:
        case D3DDDICAPS_GETDECODERTFORMATCOUNT:
        case D3DDDICAPS_GETDECODERTFORMATS:
        case D3DDDICAPS_GETDECODECOMPRESSEDBUFFERINFOCOUNT:
        case D3DDDICAPS_GETDECODECOMPRESSEDBUFFERINFO:
        case D3DDDICAPS_GETDECODECONFIGURATIONCOUNT:
        case D3DDDICAPS_GETDECODECONFIGURATIONS:
        case D3DDDICAPS_GETVIDEOPROCESSORRTFORMATCOUNT:
        case D3DDDICAPS_GETVIDEOPROCESSORDEVICEGUIDCOUNT:
        case D3DDDICAPS_GETEXTENSIONGUIDCOUNT:
        case D3DDDICAPS_GETVIDEOPROCESSORDEVICEGUIDS:
        case D3DDDICAPS_GETVIDEOPROCESSORRTFORMATS:
        case D3DDDICAPS_GETVIDEOPROCESSORRTSUBSTREAMFORMATCOUNT:
        case D3DDDICAPS_GETVIDEOPROCESSORRTSUBSTREAMFORMATS:
        case D3DDDICAPS_DXVAHD_GETVPOUTPUTFORMATS:
        case D3DDDICAPS_DXVAHD_GETVPINPUTFORMATS:
        case D3DDDICAPS_GETVIDEOPROCESSORCAPS:
        case D3DDDICAPS_GETPROCAMPRANGE:
        case D3DDDICAPS_FILTERPROPERTYRANGE:
        case D3DDDICAPS_GETEXTENSIONGUIDS:
        case D3DDDICAPS_GETEXTENSIONCAPS:
        case D3DDDICAPS_DXVAHD_GETVPDEVCAPS:
        case D3DDDICAPS_DXVAHD_GETVPCAPS:
        case D3DDDICAPS_DXVAHD_GETVPCUSTOMRATES:
        case D3DDDICAPS_DXVAHD_GETVPFILTERRANGE:
            pAdapter->GetVideoCaps(pGetCaps);
            break;

        case D3DDDICAPS_GETGAMMARAMPCAPS:
            reinterpret_cast<DDIGAMMACAPS*>(pGetCaps->pData)->GammaCaps = GAMMA_CAP_RGB256x3x16;
            break;
        case D3DDDICAPS_GET_ARCHITECTURE_INFO:
            reinterpret_cast<D3DDDICAPS_ARCHITECTURE_INFO*>(pGetCaps->pData)->TileBasedDeferredRenderer = FALSE;
            break;
        case D3DDDICAPS_GETCONTENTPROTECTIONCAPS:
            reinterpret_cast<D3DCONTENTPROTECTIONCAPS*>(pGetCaps->pData)->Caps = 0;
            break;
        case D3DDDICAPS_DDRAW:
            GetDDrawCaps(reinterpret_cast<DDRAW_CAPS*>(pGetCaps->pData));
            break;
        case D3DDDICAPS_DDRAW_MODE_SPECIFIC:
            ZeroMemory(pGetCaps->pData, sizeof(DDRAW_MODE_SPECIFIC_CAPS));
            break;
        case D3DDDICAPS_GETD3D7CAPS:
            GetD3D7Caps(reinterpret_cast<D3DHAL_D3DEXTENDEDCAPS*>(pGetCaps->pData));
            break;
        case D3DDDICAPS_GETD3D3CAPS:
            GetD3D3Caps(reinterpret_cast<D3DHAL_GLOBALDRIVERDATA*>(pGetCaps->pData));
            break;
        case D3DDDICAPS_GETD3D8CAPS:
            GetD3D8Caps(reinterpret_cast<D3DCAPS8*>(pGetCaps->pData));
            break;
        default:
            DebugBreak();
            return E_FAIL;
        }
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY CreateDevice(_In_ HANDLE hAdapter, _Inout_ D3DDDIARG_CREATEDEVICE* pCreateDevice)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);

        HRESULT hr = S_OK;
        Adapter* pNewAdapter = Adapter::GetAdapterFromHandle(hAdapter);

        if (pCreateDevice->pCallbacks == nullptr || pNewAdapter == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK()
        }

        Device* pNewDevice = new Device(*pNewAdapter, *pCreateDevice );
        if (pNewDevice == nullptr)
        {
            hr = E_OUTOFMEMORY;
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr);
    }

    _Check_return_ HRESULT APIENTRY CloseAdapter(_In_ HANDLE hAdapter)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Adapter* pAdapter = Adapter::GetAdapterFromHandle(hAdapter);
        if (pAdapter == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        HRESULT hr = pAdapter->Destroy();
        CHECK_HR(hr);

        SAFE_DELETE(pAdapter);

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr);
    }

    _Check_return_ HRESULT APIENTRY OpenAdapter(_Inout_ D3DDDIARG_OPENADAPTER*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        // This should never be called, 
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY OpenAdapter_Private(_Inout_ D3DDDIARG_OPENADAPTER* pOpenAdapter, _In_ LUID *pLUID, _In_opt_ D3D9ON12_CREATE_DEVICE_ARGS *pArgs)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        if (pOpenAdapter == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK()
        }

        D3D9ON12_CREATE_DEVICE_ARGS2 args2;
        args2.NodeMask = pArgs->NodeMask;
        args2.NumQueues = pArgs->NumQueues;
        args2.pD3D12Device = pArgs->pD3D12Device;
        args2.ppD3D12Queues = pArgs->ppD3D12Queues;
        args2.D3D9On12InterfaceVersion = 1;
        args2.pPrivateCallbacks = {};

        Adapter* pNewAdapter = new Adapter(*pOpenAdapter, pLUID, &args2);
        if (pNewAdapter == nullptr)
        {
            return E_OUTOFMEMORY;
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY OpenAdapter2_Private(_Inout_ D3DDDIARG_OPENADAPTER* pOpenAdapter, _In_ LUID* pLUID, _In_opt_ D3D9ON12_CREATE_DEVICE_ARGS2* pArgs)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        if (pOpenAdapter == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK()
        }

        Adapter* pNewAdapter = new Adapter(*pOpenAdapter, pLUID, pArgs);
        if (pNewAdapter == nullptr)
        {
            return E_OUTOFMEMORY;
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    Adapter::Adapter( _Inout_ D3DDDIARG_OPENADAPTER& OpenAdapter, LUID* pAdapterLUID, D3D9ON12_CREATE_DEVICE_ARGS2* pArgs ) :
        m_AdapterCallbacks( *OpenAdapter.pAdapterCallbacks ),
        m_pDevice(nullptr),
        m_privateCallbacks(pArgs->D3D9On12InterfaceVersion >= 2 ? *pArgs->pPrivateCallbacks : D3D9ON12_PRIVATE_CALLBACKS()),
        m_bSupportsNewPresent(pArgs->D3D9On12InterfaceVersion >= 2 ? m_privateCallbacks.pfnPresentCB != nullptr : false),
        m_bSupportsShaderSigning(pArgs->D3D9On12InterfaceVersion >= 2 ? m_privateCallbacks.pfnSignDxbcCB != nullptr : false)
    {
        if (RegistryConstants::g_cBreakOnLoad)
        {
            DebugBreak();
        }

        HRESULT hr = S_OK;
        try
        {
            if (pAdapterLUID == nullptr) ThrowFailure(E_FAIL);
            {
                CComPtr<IUnknown> pAdapter;

                {
                    CComPtr<IDXCoreAdapterFactory> pFactory;
                    if (SUCCEEDED(DXCoreCreateAdapterFactory(IID_PPV_ARGS(&pFactory))))
                    {
                        (void)pFactory->GetAdapterByLuid(*pAdapterLUID, IID_PPV_ARGS(&pAdapter));
                    }

                    if (pAdapter)
                    {
                        CComQIPtr<IDXCoreAdapter> pDXCoreAdapter = pAdapter;
                        ThrowFailure(pDXCoreAdapter->GetProperty(DXCoreAdapterProperty::HardwareID, &m_HWIDs));
                        ThrowFailure(pDXCoreAdapter->GetProperty(DXCoreAdapterProperty::DriverVersion, &m_DriverVersion));
                    }
                }
                if (!pAdapter)
                {
                    CComPtr<IDXGIFactory4> pFactory;
                    ThrowFailure(CreateDXGIFactory2(0, IID_PPV_ARGS(&pFactory)));
                    ThrowFailure(pFactory->EnumAdapterByLuid(*pAdapterLUID, IID_PPV_ARGS(&pAdapter)));

                    CComQIPtr<IDXGIAdapter> pDXGIAdapter = pAdapter;
                    DXGI_ADAPTER_DESC AdapterDesc;
                    ThrowFailure(pDXGIAdapter->GetDesc(&AdapterDesc));
                    m_HWIDs = { AdapterDesc.VendorId, AdapterDesc.DeviceId, AdapterDesc.SubSysId, AdapterDesc.Revision };

                    LARGE_INTEGER DriverVersion;
                    ThrowFailure(pDXGIAdapter->CheckInterfaceSupport(__uuidof(IDXGIDevice), &DriverVersion));
                    m_DriverVersion = DriverVersion.QuadPart;
                }


                if (pArgs && pArgs->pD3D12Device)
                {
                    ThrowFailure(pArgs->pD3D12Device->QueryInterface(&m_pD3D12Device));

                    // Ensure the app provided D3D12 runtime matches up with the adapter the 9on12 device is being created ondapterLuid));
                    ThrowFailure((memcmp(&m_pD3D12Device->GetAdapterLuid(), pAdapterLUID, sizeof(*pAdapterLUID)) == 0) ?
                        S_OK : E_FAIL);
                }
                else
                {
                    if (RegistryConstants::g_cUseDebugLayer)
                    {
                        InitDebugLayer();
                    }

                    hr = D3D12CreateDevice(pAdapter, MinSupportedFeatureLevel, IID_PPV_ARGS(&m_pD3D12Device));
                    ThrowFailure(hr);
                }

                D3D12_FEATURE_DATA_D3D12_OPTIONS3 d3d12Options3;
                hr = m_pD3D12Device->CheckFeatureSupport(D3D12_FEATURE_D3D12_OPTIONS3, &d3d12Options3, sizeof(d3d12Options3));
                ThrowFailure(hr);

                // TODO: 12281030 Once QC updates the BSP to have this on by default, just throw when
                // CastingFullyTypedFormatSupported is not supported. Allows for major improvement in 
                // simplicity/efficiency in 9on12's present path
                m_bSupportsCastingTypelessResources = d3d12Options3.CastingFullyTypedFormatSupported;

                if (pArgs && pArgs->NumQueues > 0)
                {
                    // If a queue is provided, they better have provided the device they created it with
                    Check9on12(pArgs->pD3D12Device);
                    Check9on12(pArgs->NumQueues == 1);


                    ThrowFailure(pArgs->ppD3D12Queues[0]->QueryInterface(&m_pD3D12CommandQueue));
                    ThrowFailure(m_pD3D12CommandQueue->GetDesc().Type != D3D12_COMMAND_LIST_TYPE_DIRECT ? E_FAIL : S_OK);
                }
                else
                {
                    D3D12_COMMAND_QUEUE_DESC commandQueueDesc;
                    commandQueueDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;
                    commandQueueDesc.NodeMask = 0;
                    commandQueueDesc.Priority = 0;
                    commandQueueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;
                    ThrowFailure(m_pD3D12Device->CreateCommandQueue(&commandQueueDesc, IID_PPV_ARGS(&m_pD3D12CommandQueue)));
                }
            }
        }
        catch (_com_error& hrEx)
        {
            hr = hrEx.Error();
        }
        catch (std::bad_alloc&)
        {
            hr = E_OUTOFMEMORY;
        }
        LogAdapterCreated( pAdapterLUID, hr );
        ThrowFailure(hr);

        OpenAdapter.hAdapter = Adapter::GetHandleFromAdapter( this );
        memcpy( OpenAdapter.pAdapterFuncs, &g_9on12AdapterFunctions, sizeof( *OpenAdapter.pAdapterFuncs ) );// out: Driver function table
        OpenAdapter.DriverVersion = min<UINT>( OpenAdapter.Version, D3D_UMD_INTERFACE_VERSION );            // out: D3D UMD interface version

        pArgs->D3D9On12InterfaceVersion = max(pArgs->D3D9On12InterfaceVersion, (UINT)D3D9ON12_CURRENT_INTERFACE_VERSION);
    }

    Adapter::~Adapter()
    {

    }

    HRESULT Adapter::Destroy()
    {
        return S_OK;
    }

    void Adapter::InitDebugLayer()
    {
        Check9on12(GetDevice());

        CComPtr<ID3D12Debug> pDebug;
        if (SUCCEEDED(D3D12GetDebugInterface(IID_PPV_ARGS(&pDebug))))
        {
            pDebug->EnableDebugLayer();
        }

        {
            CComPtr<ID3D12InfoQueue> pIQ;
            if (SUCCEEDED(GetDevice()->QueryInterface(&pIQ)))
            {
                ThrowFailure(pIQ->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_CORRUPTION, true));
                ThrowFailure(pIQ->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_ERROR, true));
                ThrowFailure(pIQ->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_WARNING, true));
                ThrowFailure(pIQ->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_INFO, true));
                ThrowFailure(pIQ->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_MESSAGE, true));

                pIQ->ClearStoredMessages();

                D3D12_MESSAGE_ID ignore[] = {
                    D3D12_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_MISMATCHINGCLEARVALUE,
                    D3D12_MESSAGE_ID_CLEARRENDERTARGETVIEW_MISMATCHINGCLEARVALUE,
                    D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_DEPTHSTENCILVIEW_NOT_SET,
                    D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_RENDERTARGETVIEW_NOT_SET,
                    D3D12_MESSAGE_ID_MAP_INVALID_NULLRANGE, D3D12_MESSAGE_ID_UNMAP_INVALID_NULLRANGE,
                    D3D12_MESSAGE_ID_REFLECTSHAREDPROPERTIES_INVALIDOBJECT,
                    D3D12_MESSAGE_ID_DRAW_EMPTY_SCISSOR_RECTANGLE
                };

                D3D12_INFO_QUEUE_FILTER filter = {};

                D3D12_MESSAGE_SEVERITY Severity = D3D12_MESSAGE_SEVERITY_INFO;
                filter.DenyList.NumSeverities = 1;
                filter.DenyList.pSeverityList = &Severity;
                filter.DenyList.NumIDs = _countof(ignore);
                filter.DenyList.pIDList = ignore;

                ThrowFailure(pIQ->PushStorageFilter(&filter));
            }
        }
    }

    _Use_decl_annotations_
    void Adapter::GetVideoCaps(CONST D3DDDIARG_GETCAPS* pGetCaps)
    {
        assert(m_pDevice);
        m_pDevice->EnsureVideoDevice();
        VideoDevice *pVideoDevice = m_pDevice->GetVideoDevice();
        pVideoDevice->GetCaps(pGetCaps);
    }

#define DDI_MULTISAMPLE_TYPE(x) (1 << ((x) - 1))  

    const int __DDI_MULTISAMPLE = DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_NONMASKABLE) |
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_2_SAMPLES) |
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_4_SAMPLES) |
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_8_SAMPLES);
    const int __D3DFMTOP_TEXTURE =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VERTEXTEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE |
        D3DFORMAT_OP_DMAP;
    const int __D3DFMTOP_STRECTTOFROM = D3DFORMAT_OP_CONVERT_TO_ARGB | D3DFORMAT_MEMBEROFGROUP_ARGB;
    const int __D3DFMTOP_TEXTURE2D =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VERTEXTEXTURE |
        D3DFORMAT_OP_DMAP;
    const int __D3DFMTOP_RENDERTARGET =
        D3DFORMAT_OP_OFFSCREENPLAIN |
        D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET |
        D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
    const int  __D3DFMTOP_DEPTHSTENCIL =
        D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH |
        D3DFORMAT_OP_ZSTENCIL;
    const int __D3DFMTOP_DISPLAY =
        D3DFORMAT_OP_DISPLAYMODE |
        D3DFORMAT_OP_3DACCELERATION;

    static DWORD GetSRVSupportFlags(D3D12_FEATURE_DATA_FORMAT_SUPPORT &formatSupport)
    {
        DWORD formatOperations = 0;
        if (formatSupport.Support1 & D3D12_FORMAT_SUPPORT1_TEXTURE2D)
        {
            formatOperations |= __D3DFMTOP_TEXTURE2D;
        }

        if (formatSupport.Support1 & D3D12_FORMAT_SUPPORT1_TEXTURE3D)
        {
            formatOperations |= D3DFORMAT_OP_VOLUMETEXTURE;
        }

        if (formatSupport.Support1 & D3D12_FORMAT_SUPPORT1_TEXTURECUBE)
        {
            formatOperations |= D3DFORMAT_OP_CUBETEXTURE;
        }
        return formatOperations;
    }

    UINT Adapter::GetFormatData(FORMATOP* pFormatOPs, UINT uiNumFormats)
    {
        typedef struct
        {
            D3DFORMAT dwFourCC;
            DWORD     dwExplicitOperations;
            WORD      wBltMSTypes;
            WORD      wPrivateFormatBitCount;
        } t_format_desc;
        static const t_format_desc s_surfFormats[] =
        {
            // Display Formats  
            { D3DFMT_X8R8G8B8, __D3DFMTOP_DISPLAY | D3DFORMAT_OP_SRGBREAD | D3DFORMAT_OP_SRGBWRITE | __D3DFMTOP_STRECTTOFROM, __DDI_MULTISAMPLE, 0 },
            { D3DFMT_R5G6B5, __D3DFMTOP_DISPLAY | __D3DFMTOP_STRECTTOFROM, __DDI_MULTISAMPLE, 0 },
            // Render Target __D3DFMTOP_STRECTTOFROMFormats  
            { D3DFMT_A8R8G8B8, D3DFORMAT_OP_SRGBREAD | D3DFORMAT_OP_SRGBWRITE | __D3DFMTOP_STRECTTOFROM, __DDI_MULTISAMPLE, 0 },
            { D3DFMT_A8B8G8R8, D3DFORMAT_OP_SRGBREAD | D3DFORMAT_OP_SRGBWRITE | __D3DFMTOP_STRECTTOFROM, __DDI_MULTISAMPLE, 0 },
            { D3DFMT_A1R5G5B5, __D3DFMTOP_STRECTTOFROM, __DDI_MULTISAMPLE, 0 },
            { D3DFMT_X1R5G5B5, __D3DFMTOP_STRECTTOFROM, __DDI_MULTISAMPLE, 0 },
            { D3DFMT_A4R4G4B4, 0, __DDI_MULTISAMPLE, 0 },
            { D3DFMT_X4R4G4B4, 0, __DDI_MULTISAMPLE, 0 },
            { D3DFMT_A16B16G16R16, __D3DFMTOP_STRECTTOFROM, __DDI_MULTISAMPLE, 0 },
            { D3DFMT_G16R16, 0, __DDI_MULTISAMPLE, 0 },
            { D3DFMT_A2B10G10R10,   __D3DFMTOP_STRECTTOFROM, __DDI_MULTISAMPLE, 0 },
            { D3DFMT_A2R10G10B10,   __D3DFMTOP_STRECTTOFROM, __DDI_MULTISAMPLE, 0 },
            { D3DFMT_A16B16G16R16F, __D3DFMTOP_STRECTTOFROM, __DDI_MULTISAMPLE, 0 },
            { D3DFMT_R16F, 0, __DDI_MULTISAMPLE, 0 },
            { D3DFMT_G16R16F, D3DFORMAT_OP_NOALPHABLEND, __DDI_MULTISAMPLE, 0 },
            { D3DFMT_R32F, D3DFORMAT_OP_NOALPHABLEND, 0, 0 },
            { D3DFMT_G32R32F, D3DFORMAT_OP_NOALPHABLEND, 0, 0 },
            { D3DFMT_A32B32G32R32F, D3DFORMAT_OP_NOALPHABLEND, 0, 0 },
            { D3DFMT_V8U8, D3DFORMAT_OP_BUMPMAP, __DDI_MULTISAMPLE, 0 },
            { D3DFMT_Q8W8V8U8, D3DFORMAT_OP_BUMPMAP, __DDI_MULTISAMPLE, 0 },
            { D3DFMT_V16U16, D3DFORMAT_OP_BUMPMAP, __DDI_MULTISAMPLE, 0 },
            { D3DFMT_Q16W16V16U16,  D3DFORMAT_OP_BUMPMAP, __DDI_MULTISAMPLE, 0 },
            // No equivalent in 11 DDI (only WARP can do)  
            // Possible to emulate 9_x behavior using R8/R16 format and distribute red channel to blue/green.  
            { D3DFMT_L8, 0, __DDI_MULTISAMPLE, 0 },
            { D3DFMT_L16, 0, __DDI_MULTISAMPLE, 0 },
            { D3DFMT_A8, 0, __DDI_MULTISAMPLE, 0 },
            // Not required for 9_x feature levels.  
            { D3DFMT_A8L8, 0, __DDI_MULTISAMPLE, 0 },
            // Texture Formats                          
            { D3DFMT_DXT1, D3DFORMAT_OP_SRGBREAD, 0, 0 },
            { D3DFMT_DXT2, D3DFORMAT_OP_SRGBREAD, 0, 0 },
            { D3DFMT_DXT3, D3DFORMAT_OP_SRGBREAD, 0, 0 },
            { D3DFMT_DXT4, D3DFORMAT_OP_SRGBREAD, 0, 0 },
            { D3DFMT_DXT5, D3DFORMAT_OP_SRGBREAD, 0, 0 },

            // IHVs didn't report the "true" BPP for IHV block compressed formats and instead
            // seemed to always report 8. Reporting less than 8BPP (which is true for ATI1) causes issues 
            // in the DX9 runtime which assumes that the BPP is always at least 8 BPP. The root of this issue
            // comes from the fact that the DX9 runtime doesn't account for FOURCC formats that are compressed
            // and IHVs chose to establish a pattern of working around this quirk in the runtime. As a result, 
            // this causes the runtime to report incorrect pitch values to both the driver and the app at 
            // Lock()/LockRect. Drivers work around this by understanding that the pitch won't account for the 
            // fact that BPP is based on 4x4 compressed blocks and multiply the pitch accordingly. 
            //
            // Presumably ISVs must have been informed of this as well and are aware that the pitch they get from 
            // the runtime must be multiplied or ignored and calculated by the app.
            { D3DFMT_ATI1, D3DFORMAT_OP_SRGBREAD | D3DFORMAT_OP_PIXELSIZE, 0, BPP_FOR_IHV_BLOCK_COMPRESSED_FORMATS }, // A.K.A BC4
            { D3DFMT_ATI2, D3DFORMAT_OP_SRGBREAD | D3DFORMAT_OP_PIXELSIZE, 0, BPP_FOR_IHV_BLOCK_COMPRESSED_FORMATS }, // A.K.A BC5

                                                                                                                      // Not required for 9_x feature levels.  
                                                                                                                      // { D3DFMT_P8,            __D3DFMTOP_TEXTURE | D3DFORMAT_OP_OFFSCREENPLAIN, 0, 0 },  
                                                                                                                      // { D3DFMT_A8P8,          __D3DFMTOP_TEXTURE, 0, 0 },  
                                                                                                                      // DepthStencil Formats  
            { D3DFMT_D24S8, 0, __DDI_MULTISAMPLE, 0 },
            { D3DFMT_D24FS8, 0, __DDI_MULTISAMPLE, 0 },
            { D3DFMT_D24X8, 0, __DDI_MULTISAMPLE, 0 },
            { D3DFMT_D16,   0, __DDI_MULTISAMPLE, 0 },
            // Not required for 9_x feature levels.  
            // { D3DFMT_D16_LOCKABLE,  __D3DFMTOP_DEPTHSTENCIL, 0, 0 },  
            // { D3DFMT_D32F_LOCKABLE, __D3DFMTOP_DEPTHSTENCIL, 0, 0 },  
            // YUV Formats  
            { D3DFMT_AYUV, D3DFORMAT_OP_OFFSCREENPLAIN | D3DFORMAT_OP_PIXELSIZE | D3DFORMAT_OP_CONVERT_TO_ARGB, 0, 32 },
            { D3DFMT_YUY2, D3DFORMAT_OP_OFFSCREENPLAIN | D3DFORMAT_OP_PIXELSIZE | D3DFORMAT_OP_CONVERT_TO_ARGB, 0, 16 },
            { D3DFMT_NV12, D3DFORMAT_OP_OFFSCREENPLAIN | D3DFORMAT_OP_PIXELSIZE | D3DFORMAT_OP_CONVERT_TO_ARGB, 0, 16 },
            { D3DFMT_YV12, D3DFORMAT_OP_OFFSCREENPLAIN | D3DFORMAT_OP_PIXELSIZE | D3DFORMAT_OP_CONVERT_TO_ARGB, 0, 16 }, // Via emulation as NV12
            { D3DFMT_P010, D3DFORMAT_OP_OFFSCREENPLAIN | D3DFORMAT_OP_PIXELSIZE | D3DFORMAT_OP_CONVERT_TO_ARGB, 0, 32 },
            //FourCC formats
            { D3DFMT_INTZ, 0, __DDI_MULTISAMPLE, 0 },
            // RAWZ requires special handling that we don't really understand. Cutting until we need it, then we can understand it.
            //{ D3DFMT_RAWZ, 0, __DDI_MULTISAMPLE, 0 },
            { D3DFMT_DF16, 0, __DDI_MULTISAMPLE, 0 },
            { D3DFMT_DF24, 0, __DDI_MULTISAMPLE, 0 },
            { D3DFMT_NULL, __D3DFMTOP_TEXTURE | __D3DFMTOP_RENDERTARGET | D3DFORMAT_OP_BUMPMAP, __DDI_MULTISAMPLE, 0 },
            // RESZ is not a format that you can actually create a resource with, but reporting it lets apps know they can use the feature
            { D3DFMT_RESZ, 0, 0, 0 },
            // ATOC is not a format that you can actually create a resource with, but reporting it lets apps know they can use the feature
            { D3DFMT_ATOC, D3DFORMAT_OP_OFFSCREENPLAIN, 0, 0 },
        };

        static_assert(_countof(s_surfFormats) == MAX_SURFACE_FORMATS, "Size constant must be kept in sync for internal query of GetFormatData.");


        UINT numSupportedFormats = 0;
        for (auto &formatEntry : s_surfFormats)
        {
            bool bFormatUsesSpecialHandling = (formatEntry.dwFourCC == D3DFMT_NULL ||
                formatEntry.dwFourCC == D3DFMT_RESZ || formatEntry.dwFourCC == D3DFMT_ATOC);

            bool bD3D12SupportsFormat = false;
            D3D12_FEATURE_DATA_FORMAT_SUPPORT dxgiFormatSupport;
            DWORD formatOperations = formatEntry.dwExplicitOperations;
            if (!bFormatUsesSpecialHandling)
            {
                dxgiFormatSupport.Format = ConvertToDXGIFORMAT(formatEntry.dwFourCC);
                bD3D12SupportsFormat = SUCCEEDED(m_pD3D12Device->CheckFeatureSupport(D3D12_FEATURE_FORMAT_SUPPORT, &dxgiFormatSupport, sizeof(dxgiFormatSupport)));

                if (bD3D12SupportsFormat)
                {
                    if (formatOperations & __D3DFMTOP_DISPLAY) Check9on12(dxgiFormatSupport.Support1 & D3D12_FORMAT_SUPPORT1_RENDER_TARGET);

                    // Avoid reporting RTV support for bump maps since the ref driver doesn't support this, otherwise this lights up
                    // unexpected behavior in tests when the cap is lit due to ref driver comparison. IHVs appear to follow this pattern as well
                    const bool bIsBumpFormat = (formatEntry.dwExplicitOperations & D3DFORMAT_OP_BUMPMAP) != 0;
                    if (!CD3D11FormatHelper::YUV(dxgiFormatSupport.Format)  && dxgiFormatSupport.Support1 & D3D12_FORMAT_SUPPORT1_RENDER_TARGET && !bIsBumpFormat)
                    {
                        formatOperations |= __D3DFMTOP_RENDERTARGET;
                    }

                    if (dxgiFormatSupport.Support1 & D3D12_FORMAT_SUPPORT1_DEPTH_STENCIL)
                    {
                        formatOperations |= __D3DFMTOP_DEPTHSTENCIL;
                    }

                    if (IsDepthStencilFormat(dxgiFormatSupport.Format))
                    {
                        D3D12_FEATURE_DATA_FORMAT_SUPPORT srvFormatSupport;
                        srvFormatSupport.Format = ConvertDepthFormatToCompanionSRVFormat(dxgiFormatSupport.Format);
                        ThrowFailure(m_pD3D12Device->CheckFeatureSupport(D3D12_FEATURE_FORMAT_SUPPORT, &srvFormatSupport, sizeof(srvFormatSupport)));

                        formatOperations |= GetSRVSupportFlags(srvFormatSupport);
                    }
                    // Not currently supporting SRV operations on YUV surfaces
                    else if (!CD3D11FormatHelper::YUV(dxgiFormatSupport.Format) || cSupportsPlanarSRVs)
                    {
                        formatOperations |= GetSRVSupportFlags(dxgiFormatSupport);
                    }

                    if ((formatOperations & __D3DFMTOP_RENDERTARGET) == __D3DFMTOP_RENDERTARGET &&
                       (dxgiFormatSupport.Support1 & D3D12_FORMAT_SUPPORT1_MULTISAMPLE_RENDERTARGET) != 0 &&
                       (dxgiFormatSupport.Support1 & D3D12_FORMAT_SUPPORT1_MULTISAMPLE_RESOLVE) != 0)
                    {
                        formatOperations |= __DDI_MULTISAMPLE;
                    }

                    // Gen mips operations use a draw that requires the source to be an SRV and the dest to be an RTV
                    if ((dxgiFormatSupport.Support1 & D3D12_FORMAT_SUPPORT1_RENDER_TARGET) != 0 &&
                        (dxgiFormatSupport.Support1 & D3D12_FORMAT_SUPPORT1_TEXTURE2D) != 0 &&
                        (dxgiFormatSupport.Support1 & D3D12_FORMAT_SUPPORT1_MIP) &&
                        formatEntry.dwFourCC != D3DFMT_A2R10G10B10)
                    {
                        formatOperations |= D3DFORMAT_OP_AUTOGENMIPMAP;
                    }
                }
            }

            if (bFormatUsesSpecialHandling || bD3D12SupportsFormat)
            {
                if (pFormatOPs)
                {
                    pFormatOPs[numSupportedFormats].Format = (D3DDDIFORMAT)formatEntry.dwFourCC;
                    pFormatOPs[numSupportedFormats].Operations = formatOperations;
                    pFormatOPs[numSupportedFormats].FlipMsTypes = formatEntry.wBltMSTypes;
                    pFormatOPs[numSupportedFormats].BltMsTypes = formatEntry.wBltMSTypes;
                    pFormatOPs[numSupportedFormats].PrivateFormatBitCount = formatEntry.wPrivateFormatBitCount;

                    if (numSupportedFormats == uiNumFormats) break;
                }

                numSupportedFormats++;
            }
        }

        return numSupportedFormats;
    }

    bool Adapter::RequiresYUY2BlitWorkaround() const
    {
        LARGE_INTEGER driverVersion;
        driverVersion.QuadPart = m_DriverVersion;
        // work around only needed when vendor is QCOM and driver version is less than 31.0.0.0.
        return m_HWIDs.vendorID == MAKEFOURCC('Q', 'C', 'O', 'M')
            && driverVersion.HighPart < (31 << 16); //Major version is the 16 MSB of the HighPart
    }

    void Adapter::LogAdapterCreated( LUID *pluid, HRESULT hr )
    {
        //do nothing
        UNREFERENCED_PARAMETER( pluid );
        UNREFERENCED_PARAMETER( hr );
    }
};


```

`src/9on12AppCompat.cpp`:

```cpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#include "pch.h"

namespace D3D9on12
{
    D3D9ON12_APP_COMPAT_INFO g_AppCompatInfo =
    {
        0, // AnythingTimes0Equals0ShaderMask
        MAXDWORD, // PSOCacheTrimLimitSize
        MAXDWORD, // PSOCacheTrimLimitAge
        MAXDWORD, // MaxAllocatedUploadHeapSpacePerCommandList
        MAXDWORD, // MaxSRVHeapSize
        MAXDWORD, // BufferPoolTrimThreshold
        0,        // DisableIntzDSVFix
    };

    void APIENTRY SetAppCompatData(const D3D9ON12_APP_COMPAT_INFO *pAppCompatData)
    {
        g_AppCompatInfo = *pAppCompatData;
    }

};

```

`src/9on12Blit.cpp`:

```cpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#include "pch.h"

namespace D3D9on12
{    

    ResourceCopyArgs::ResourceCopyArgs(Resource& destination, Resource& source) :
        m_source(source),
        m_sourceSubresourceIndex(0),
        m_destinationSubresourceIndex(0),
        m_cubeFace(0),
        m_numSubresources(0),
        m_allSubresources(false),
        m_mipsAlreadyExpanded(false),
        m_dimensionsCoverEntireResource(false),
        m_isStretchCopy(false),
        m_destination(destination),
        m_stretchSource{},
        m_stretchDestination{},
        m_destinationX(0), m_destinationY(0), m_destinationZ(0),
        m_sourceBox{},
        m_EnableAlpha(FALSE){}

    void ResourceCopyArgs::AlignCopyDimensions()
    {
        //Adjust the rectScaled coordinates for DXTn (4x4) alignment.
        if (IsBlockCompressedFormat(m_source.GetLogicalDesc().Format))
        {
            m_destinationX &= ~3;
            m_destinationY &= ~3;

            m_sourceBox.left &= ~3;
            m_sourceBox.top &= ~3;
            m_sourceBox.right = (m_sourceBox.right + 3) & (~3);
            m_sourceBox.bottom = (m_sourceBox.bottom + 3) & (~3);
        }
        else if (IsYUVFormat(m_source.GetLogicalDesc().Format))  // Adjust the rectScaled coordinates for YUV (2x1) alignment.
        {
            m_destinationX &= ~1;

            m_sourceBox.left &= ~1;
            m_sourceBox.right = (m_sourceBox.right + 1) & ~1;
        }
    }

    void ResourceCopyArgs::ClipSourceBox(UINT sourceMipLevel, UINT destinationMipLevel)
    {
        ClipBox(m_sourceBox, m_source.GetSubresourceFootprint(sourceMipLevel));
        ClipBox(m_sourceBox, m_destination.GetSubresourceFootprint(destinationMipLevel));
        
        const D3D12_SUBRESOURCE_FOOTPRINT &srcFootprint = m_source.GetSubresourceFootprint(sourceMipLevel).Footprint;
        m_sourceBox.back = min(m_sourceBox.back, srcFootprint.Depth);
        m_sourceBox.right = min(m_sourceBox.right, srcFootprint.Width);
        m_sourceBox.bottom = min(m_sourceBox.bottom, srcFootprint.Height);

        if (m_sourceBox.left >= m_sourceBox.right)
        {
            m_sourceBox.left = m_sourceBox.right - 1;
            Check9on12(m_sourceBox.left <= m_sourceBox.right); // Check for overflow
        }

        if (m_sourceBox.top >= m_sourceBox.bottom)
        {
            m_sourceBox.top = m_sourceBox.bottom - 1;
            Check9on12(m_sourceBox.top <= m_sourceBox.bottom); // Check for overflow
        }

        if (m_sourceBox.front >= m_sourceBox.back)
        {
            m_sourceBox.front = m_sourceBox.back - 1;
            Check9on12(m_sourceBox.front <= m_sourceBox.back); // Check for overflow
        }

        // Corner case that gets hit when the depth slice has been cut down
        // to the last depth slice, need to make sure the destinationZ is clamped
        // to boundaries also
        const UINT dstDepth = m_destination.GetSubresourceFootprint(destinationMipLevel).Footprint.Depth;
        Check9on12(m_destinationZ <= dstDepth);
        if (m_destinationZ == dstDepth)
        {
            m_destinationZ = dstDepth - 1;
        }

        Check9on12(BoxDepth(m_sourceBox) <= m_source.GetSubresourceFootprint(sourceMipLevel).Footprint.Depth);
        Check9on12(BoxHeight(m_sourceBox) <= m_source.GetSubresourceFootprint(sourceMipLevel).Footprint.Height);
        Check9on12(BoxWidth(m_sourceBox) <= m_source.GetSubresourceFootprint(sourceMipLevel).Footprint.Width);

        Check9on12(m_destinationZ + BoxDepth(m_sourceBox) <= m_destination.GetSubresourceFootprint(destinationMipLevel).Footprint.Depth);
        Check9on12(m_destinationY + BoxHeight(m_sourceBox) <= m_destination.GetSubresourceFootprint(destinationMipLevel).Footprint.Height);
        Check9on12(m_destinationX + BoxWidth(m_sourceBox) <= m_destination.GetSubresourceFootprint(destinationMipLevel).Footprint.Width);
    }

    bool ResourceCopyArgs::IsBufferBlit() const
    { 
        return m_destination.GetDesc().Dimension == D3D12_RESOURCE_DIMENSION_BUFFER && 
            m_source.GetDesc().Dimension == D3D12_RESOURCE_DIMENSION_BUFFER;
    }

    void ResourceCopyArgs::AsBufferBlit(UINT dstOffset, D3DDDIRANGE srcRange)
    {
        Check9on12(srcRange.Size > 0);
        m_allSubresources = true;
        m_numSubresources = 1;
        m_destinationX = dstOffset;
        m_sourceBox.left = srcRange.Offset;
        m_sourceBox.right = srcRange.Offset + srcRange.Size;
        m_sourceBox.top = 0;
        m_sourceBox.bottom = 1;
        m_sourceBox.front = 0;
        m_sourceBox.back = 1;

        if (m_destination.GetDesc().Width == m_source.GetDesc().Width &&
            (m_sourceBox.right - m_sourceBox.left) == m_destination.GetDesc().Width)
        {
            m_dimensionsCoverEntireResource = true;
        }
    }

    void ResourceCopyArgs::AsTextureBlit(const POINT &dstPoint, const RECT &srcRect, UINT cubeFace)
    {
        m_allSubresources = true;
        m_destinationSubresourceIndex = 0;
        m_sourceSubresourceIndex = 0;
        m_cubeFace = cubeFace;
        m_numSubresources = max(m_destination.GetNumSubresources(), m_source.GetNumSubresources());

        m_destinationX = dstPoint.x;
        m_destinationY = dstPoint.y;
        m_sourceBox.left = srcRect.left;
        m_sourceBox.right = srcRect.right;
        m_sourceBox.top = srcRect.top;
        m_sourceBox.bottom = srcRect.bottom;
        m_sourceBox.front = 0;
        m_sourceBox.back = 1;

        if ((m_sourceBox.right - m_sourceBox.left) == m_destination.GetLogicalDesc().Width &&
            (m_sourceBox.bottom - m_sourceBox.top) == m_destination.GetLogicalDesc().Height)
        {
            m_dimensionsCoverEntireResource = true;
        }
        else
        {
            AlignCopyDimensions();
        }
    }

    void ResourceCopyArgs::AsVolumeBlit(UINT dstX, UINT dstY, UINT dstZ, const D3D12_BOX &srcBox)
    {
        m_allSubresources = true;
        m_destinationSubresourceIndex = 0;
        m_sourceSubresourceIndex = 0;
        m_numSubresources = max(m_destination.GetNumSubresources(), m_source.GetNumSubresources());

        m_destinationX = dstX;
        m_destinationY = dstY;
        m_destinationZ = dstZ;
        m_sourceBox = srcBox;

        if ((m_sourceBox.right - m_sourceBox.left) == m_destination.GetLogicalDesc().Width &&
            (m_sourceBox.bottom - m_sourceBox.top) == m_destination.GetLogicalDesc().Height &&
            (m_sourceBox.back - m_sourceBox.front) == m_destination.GetLogicalDesc().DepthOrArraySize)
        {
            m_dimensionsCoverEntireResource = true;
        }
        else
        {
            AlignCopyDimensions();
        }
    }

    void ResourceCopyArgs::AsSubresourceBlit(UINT dstSubresourceIndex, UINT srcSubresourceIndex, CONST RECT* pDstRect, CONST RECT* pSrcRect)
    {
        m_allSubresources = false;

        m_destinationSubresourceIndex = dstSubresourceIndex;
        m_sourceSubresourceIndex = srcSubresourceIndex;
        m_numSubresources = 1;

        if (pDstRect)
        {
            Check9on12(pSrcRect);
        }
        if (pSrcRect)
        {
            Check9on12(pDstRect);
        }

        if (pDstRect == nullptr || pSrcRect == nullptr)
        {
            m_dimensionsCoverEntireResource = true;
        }
        else
        {
            const D3D12_RESOURCE_DESC& srcDesc = m_source.GetLogicalDesc();
            const D3D12_RESOURCE_DESC& dstDesc = m_destination.GetLogicalDesc();

            POINT dstRectSize = { (pDstRect->right - pDstRect->left), (pDstRect->bottom - pDstRect->top) };
            POINT srcRectSize = { (pSrcRect->right - pSrcRect->left), (pSrcRect->bottom - pSrcRect->top) };

            if (dstRectSize.x != srcRectSize.x || dstRectSize.y != srcRectSize.y)
            {
                // Stretch blit
                AsStretchBlit(dstSubresourceIndex, srcSubresourceIndex, pDstRect, pSrcRect);
            }
            else
            {
                if (srcDesc.Width == RectWidth(*pSrcRect) && srcDesc.Height == RectHeight(*pSrcRect) &&
                    dstDesc.Width == RectWidth(*pDstRect) && dstDesc.Height == RectHeight(*pDstRect))
                {
                    m_dimensionsCoverEntireResource = true;
                }
                else
                {
                    m_destinationX = pDstRect->left;
                    m_destinationY = pDstRect->top;

                    m_sourceBox.left = pSrcRect->left;
                    m_sourceBox.right = pSrcRect->right;
                    m_sourceBox.top = pSrcRect->top;
                    m_sourceBox.bottom = pSrcRect->bottom;
                    m_sourceBox.back = 1;
                }

                AlignCopyDimensions();
            }
        }
    }

    void ResourceCopyArgs::AsStretchBlit(UINT dstSubresourceIndex, UINT srcSubresourceIndex, CONST RECT* pDstRect, CONST RECT* pSrcRect)
    {
        m_allSubresources = false;

        m_destinationSubresourceIndex = dstSubresourceIndex;
        m_sourceSubresourceIndex = srcSubresourceIndex;
        m_numSubresources = 1;

        m_isStretchCopy = true;

        if (pDstRect)
        {
            m_stretchDestination = *pDstRect;
        }
        else
        {
            m_stretchDestination = RectThatCoversEntireResource(m_destination.GetLogicalDesc());
        }

        if (pSrcRect)
        {
            m_stretchSource = *pSrcRect;
        }
        else
        {
            m_stretchSource = RectThatCoversEntireResource(m_source.GetLogicalDesc());
        }
    }

    ResourceCopyArgs ResourceCopyArgs::GetSubArgs(UINT arrayLevel, UINT sourceMipLevel, UINT destinationMipLevel) const
    {
        ResourceCopyArgs subArgs = ResourceCopyArgs(m_destination, m_source);
        subArgs.m_sourceBox = m_sourceBox;
        subArgs.m_dimensionsCoverEntireResource = m_dimensionsCoverEntireResource;

        if (m_dimensionsCoverEntireResource == false)
        {
            subArgs.m_destinationX = m_destinationX >> destinationMipLevel;
            subArgs.m_destinationY = m_destinationY >> destinationMipLevel;
            subArgs.m_destinationZ = m_destinationZ >> destinationMipLevel;

            if (sourceMipLevel > 0)
            {
                ScaleBoxDown(subArgs.m_sourceBox, sourceMipLevel);
                subArgs.ClipSourceBox(sourceMipLevel, destinationMipLevel);
                // Mip levels dimensions are rounded down for each mip level division, but the copy rects right/bottom points 
                // are rounded up each time they are divided. We need to clamp to handle when the copy rects
                // go out of bounds.
            }

            subArgs.AlignCopyDimensions();
        }

        //TODO: depth planes?
        subArgs.m_numSubresources = 1;
        subArgs.m_destinationSubresourceIndex = D3D12CalcSubresource(destinationMipLevel, arrayLevel, 0, m_destination.GetLogicalDesc().MipLevels, m_destination.GetArraySize());
        subArgs.m_sourceSubresourceIndex = D3D12CalcSubresource(sourceMipLevel, arrayLevel, 0, m_source.GetLogicalDesc().MipLevels, m_source.GetArraySize());
        subArgs.m_mipsAlreadyExpanded = true;

        return subArgs;
    }

    void Resource::CopyPrologue(Device& /*device*/, ResourceCopyArgs& /*args*/)
    {
    }

    void Resource::CopyToSystemMemoryResource(Device& device, ResourceCopyArgs& args)
    {
        D3D12TranslationLayer::ImmediateContext& context = device.GetContext();
        Resource& source = args.m_source;
        Resource& destination = args.m_destination;

        COPY_TO_SYSTEM_MEMORY_WARNING();

        Check9on12(destination.IsSystemMemory());

        UINT sourceSubresourceIndex = args.m_sourceSubresourceIndex;
        UINT destinationSubresourceIndex = args.m_destinationSubresourceIndex;

        unique_comptr<D3D12TranslationLayer::Resource> scopedMappableResource;
        D3D12TranslationLayer::Resource *pMappableResource = source.GetUnderlyingResource();
        if ((pMappableResource->AppDesc()->CPUAccessFlags() & D3D12TranslationLayer::RESOURCE_CPU_ACCESS_READ) == 0)
        {
            scopedMappableResource = std::move(source.GetStagingCopy());
            pMappableResource = scopedMappableResource.get();
        }

        // Can't do a GPU copy to an upload heap so we have to memcpy it all over
        for (UINT i = 0; i < args.m_numSubresources; i++)
        {
            D3D12_MEMCPY_DEST appDstData = destination.m_appLinearRepresentation.m_systemData[destinationSubresourceIndex];

            D3D12TranslationLayer::MappedSubresource srcData = {};
            context.Map(pMappableResource, sourceSubresourceIndex, D3D12TranslationLayer::MAP_TYPE_READ, false , nullptr, &srcData);

            D3D12_SUBRESOURCE_DATA srcSubresourceData = {};
            srcSubresourceData.pData = srcData.pData;
            srcSubresourceData.RowPitch = srcData.RowPitch;
            srcSubresourceData.SlicePitch = srcData.DepthPitch;

            SIZE_T BytesPerRow = appDstData.RowPitch;
            UINT NumRows = source.m_physicalLinearRepresentation.m_numRows[sourceSubresourceIndex];
            if (!args.m_dimensionsCoverEntireResource)
            {
                const DXGI_FORMAT SrcFormat = args.m_source.GetLogicalDesc().Format;
                UINT8 BytesPerPixel = (SrcFormat == DXGI_FORMAT_UNKNOWN) ? 1 : GetBytesPerUnit(SrcFormat);

                // Offset destination
                reinterpret_cast<BYTE*&>(appDstData.pData) +=
                    (args.m_destinationZ * appDstData.SlicePitch) +
                    (args.m_destinationY * appDstData.RowPitch) +
                    (args.m_destinationX * BytesPerPixel);

                // Offset source
                reinterpret_cast<BYTE*&>(srcData.pData) +=
                    (args.m_sourceBox.front * srcData.DepthPitch) +
                    (args.m_sourceBox.top * srcData.RowPitch) +
                    (args.m_sourceBox.left * BytesPerPixel);

                // Adjust how much data is copied
                BytesPerRow = BytesPerPixel * (args.m_sourceBox.right - args.m_sourceBox.left);
                NumRows = args.m_sourceBox.bottom - args.m_sourceBox.top;
            }

            MemcpySubresource(&appDstData, &srcSubresourceData, BytesPerRow, NumRows, 1);

            context.Unmap(pMappableResource, sourceSubresourceIndex, D3D12TranslationLayer::MAP_TYPE_READ, nullptr);

            sourceSubresourceIndex++;
            destinationSubresourceIndex++;
        }
    }  

    void Resource::CopyResource(Device& device, ResourceCopyArgs& args)
    {
        // DX9 allows for uploading from a src resource with different mip levels than the dst resource.
        // In this case, only the matching mip levels from the src are copied over
        if (args.m_allSubresources && args.m_source.m_numSubresources != args.m_destination.m_numSubresources)
        {
            Resource::CopyMatchingMipLevels(device, args);
        }
        else
        {
            D3D12TranslationLayer::ImmediateContext& context = device.GetContext();
            Resource& source = args.m_source;
            Resource& destination = args.m_destination;

            // We generally shouldn't expect to be copying to a system memory resource but this gets hit in the UpdateSurface HLK test
            if (args.m_destination.m_isD3D9SystemMemoryPool)
            {
                Resource::CopyPrologue(device, args);
                Check9on12(args.m_source.m_isD3D9SystemMemoryPool == false);
                CopyToSystemMemoryResource(device, args);
            }
            else
            {
                const bool mismatchedFormats = source.GetD3DFormat() != destination.GetD3DFormat();
                if (args.m_dimensionsCoverEntireResource && args.m_source.IsSystemMemory() == false && !mismatchedFormats)
                {
                    Resource::CopyPrologue(device, args);

                    const bool needsMSAAResolve = args.m_source.GetDesc().SampleDesc.Count > 1 && args.m_destination.GetDesc().SampleDesc.Count == 1;
                    if (needsMSAAResolve)
                    {
                        Check9on12(args.m_numSubresources == 1);
                        context.ResourceResolveSubresource(args.m_destination.GetUnderlyingResource(),
                            args.m_destinationSubresourceIndex,
                            args.m_source.GetUnderlyingResource(),
                            args.m_sourceSubresourceIndex,
                            args.m_destination.GetViewFormat(false));
                    }
                    else
                    {
                        context.ResourceCopy(destination.GetUnderlyingResource(), source.GetUnderlyingResource());
                    }
                }
                else
                {
                    if (args.IsBufferBlit() && args.m_source.IsSystemMemory() == false)
                    {
                        Resource::CopyPrologue(device, args);
                        context.ResourceCopyRegion(destination.GetUnderlyingResource(), //Dest
                            0, // Dest Subresource
                            args.m_destinationX, // Dest X
                            0, // Dest Y
                            0, // Dest Z
                            source.GetUnderlyingResource(), // Source
                            0, // Source Subresource
                            &args.m_sourceBox); //SourceBox

                    }
                    else
                    {
                        UINT arrayStart = args.m_cubeFace == UINT_MAX ? 0 : args.m_cubeFace;
                        UINT arrayEnd = args.m_cubeFace == UINT_MAX ? destination.GetArraySize() : args.m_cubeFace + 1;
                        for (UINT arraySlice = arrayStart; arraySlice < arrayEnd; arraySlice++)
                        {
                            for (UINT mipSlice = 0; mipSlice < args.m_destination.GetLogicalDesc().MipLevels; mipSlice++)
                            {
                                //If they give us a copy rect/box we need to calculate
                                //that box for every mip sublevel.
                                ResourceCopyArgs arg = args.GetSubArgs(arraySlice, mipSlice, mipSlice);
                                CopySubResource(device, arg);
                            }
                        }
                    }
                }
            }
        }
        args.m_destination.NotifyResourceChanged();
    }

    static inline D3D12_RECT ConvertBoxToRect(const D3D12_BOX& box)
    {
        Check9on12(box.front == 0 && box.back == 1);

        D3D12_RECT rect =
        {
            static_cast<LONG>(box.left), 
            static_cast<LONG>(box.top), 
            static_cast<LONG>(box.right), 
            static_cast<LONG>(box.bottom)
        };

        return rect;
    }

    void Resource::CopySubResource(Device& device, ResourceCopyArgs& args)
    {
        D3D12TranslationLayer::ImmediateContext& context = device.GetContext();
        Resource& source = args.m_source;
        Resource& destination = args.m_destination;


        // This method expects D3D9's understanding of subresource indices in its input arguments, where all the 
        // planes of a of a texture are a single subresource.
        // It handles mapping that understanding to D3D12's where each plane is it's own subresource.
        // This method only handles cases where we are converting from a multi-plane source resource to a single 
        // plane destination resource (e.g. NV12->BGRA) or a source and destination with the same number of planes 
        // (same format, e.g. NV12->NV12, BGRA->BGRA etc.)

        UINT srcSubresources[MAX_PLANES];
        UINT dstSubresources[MAX_PLANES];
        UINT numDstPlanes, numSrcPlanes;

        source.ConvertAppSubresourceToDX12SubresourceIndices(args.m_sourceSubresourceIndex, srcSubresources, numSrcPlanes, args.m_mipsAlreadyExpanded);
        destination.ConvertAppSubresourceToDX12SubresourceIndices(args.m_destinationSubresourceIndex, dstSubresources, numDstPlanes, args.m_mipsAlreadyExpanded);

        for (UINT planeIndex = 0; planeIndex < numSrcPlanes; planeIndex++)
        {
            UINT sourceSubresourceIndex = srcSubresources[planeIndex];
            UINT destinationSubresourceIndex = dstSubresources[0];

            UINT destinationX = args.m_destinationX;
            UINT destinationY = args.m_destinationY;
            UINT destinationZ = args.m_destinationZ;

            D3D12_BOX sourceBox = args.m_sourceBox;

            if (IsChromaPlane(planeIndex))
            {
                UINT subsampleX, subsampleY;
                CD3D11FormatHelper::GetYCbCrChromaSubsampling(source.GetViewFormat(false), subsampleX, subsampleY);

                // YUV is 2D.
                D3D12_RECT sourceRect = ConvertBoxToRect(args.m_sourceBox);

                sourceRect = ConvertLumaRectToChromaRect(sourceRect, subsampleX, subsampleY);

                sourceBox.left = sourceRect.left;
                sourceBox.top = sourceRect.top;
                sourceBox.right = sourceRect.right;
                sourceBox.bottom = sourceRect.bottom;

                if (numDstPlanes == numSrcPlanes)
                {
                    destinationSubresourceIndex = dstSubresources[planeIndex];

                    RECT destinationRect;
                    destinationRect.left = destinationX;
                    destinationRect.top = destinationY;
                    destinationRect.right = destinationX + (args.m_sourceBox.right - args.m_sourceBox.left);
                    destinationRect.bottom = destinationY + (args.m_sourceBox.bottom - args.m_sourceBox.top);

                    destinationRect = ConvertLumaRectToChromaRect(destinationRect, subsampleX, subsampleY);

                    destinationX = destinationRect.left;
                    destinationY = destinationRect.top;
                }
            }

            Resource::CopyPrologue(device, args);

            // We generally shouldn't expect to be copying to a system memory resource but this gets hit in the UpdateSurface HLK test
            if (destination.m_isD3D9SystemMemoryPool)
            {
                Check9on12(args.m_isStretchCopy == false);
                Check9on12(source.m_isD3D9SystemMemoryPool == false);
                auto SysmemCopyArgs = args;
                SysmemCopyArgs.m_sourceSubresourceIndex = sourceSubresourceIndex;
                SysmemCopyArgs.m_destinationSubresourceIndex = destinationSubresourceIndex;
                CopyToSystemMemoryResource(device, SysmemCopyArgs);
            }
            else if (source.IsSystemMemory())
            {
                Check9on12(args.m_isStretchCopy == false);
                D3D12_BOX destBox = CD3DX12_BOX(destinationX, destinationY, destinationZ,
                    destinationX + BoxWidth(sourceBox),
                    destinationY + BoxHeight(sourceBox),
                    destinationZ + BoxDepth(sourceBox));

                const DXGI_FORMAT SrcFormat = source.GetLogicalDesc().Format;
                UINT8 BytesPerPixel = (SrcFormat == DXGI_FORMAT_UNKNOWN) ? 1 : GetBytesPerUnit(SrcFormat);
                UINT SrcX = sourceBox.left;
                UINT SrcY = sourceBox.top;
                UINT SrcZ = sourceBox.front;
                if (IsBlockCompressedFormat(SrcFormat))
                {
                    const UINT COMPRESSED_BLOCK_SIZE = 4;
                    Check9on12(IsAligned(SrcX, COMPRESSED_BLOCK_SIZE) && IsAligned(SrcY, COMPRESSED_BLOCK_SIZE));
                        SrcX /= COMPRESSED_BLOCK_SIZE;
                    SrcY /= COMPRESSED_BLOCK_SIZE;
                }

                const D3D12_MEMCPY_DEST &SrcDataInfo = source.m_appLinearRepresentation.m_systemData[sourceSubresourceIndex];

                // ResourceUpdateSubresourceUP doesn't take in a src box so we need to do the pointer offset math here
                void *pSrcData = (BYTE *)SrcDataInfo.pData
                    + BytesPerPixel * SrcX
                    + SrcDataInfo.RowPitch * SrcY
                    + SrcDataInfo.SlicePitch * SrcZ;

                D3D11_SUBRESOURCE_DATA SubresourceDesc =
                {
                    pSrcData,
                    static_cast<UINT>(source.m_appLinearRepresentation.m_systemData[sourceSubresourceIndex].RowPitch),
                    static_cast<UINT>(source.m_appLinearRepresentation.m_systemData[sourceSubresourceIndex].SlicePitch)
                };
                UINT8 MipLevel, PlaneSlice;
                UINT16 ArraySlice;
                D3D12TranslationLayer::DecomposeSubresourceIdxExtended(destinationSubresourceIndex,
                    destination.GetUnderlyingResource()->AppDesc()->MipLevels(),
                    destination.GetUnderlyingResource()->AppDesc()->ArraySize(), MipLevel, ArraySlice, PlaneSlice);

                D3D12TranslationLayer::ImmediateContext::UpdateSubresourcesFlags Flags = D3D12TranslationLayer::ImmediateContext::UpdateSubresourcesFlags::ScenarioImmediateContext;
                if (source.NeedsSwapRBOutputChannels() != destination.NeedsSwapRBOutputChannels())
                {
                    assert(ConvertToTypeless(source.GetViewFormat(false)) == DXGI_FORMAT_R10G10B10A2_TYPELESS);
                    Flags |= D3D12TranslationLayer::ImmediateContext::UpdateSubresourcesFlags::ChannelSwapR10G10B10A2;
                }

                context.UpdateSubresources(destination.GetUnderlyingResource(),
                    D3D12TranslationLayer::CSubresourceSubset(1, 1, destination.GetUnderlyingResource()->SubresourceMultiplier(), MipLevel, ArraySlice, PlaneSlice),
                    &SubresourceDesc,
                    (args.m_dimensionsCoverEntireResource) ? nullptr : &destBox,
                    Flags);
            }
            else
            {
                const DXGI_FORMAT srcFormat = source.GetViewFormat(false);
                const DXGI_FORMAT dstFormat = destination.GetViewFormat(false);
                const bool mismatchingSampleCount = source.GetDesc().SampleDesc.Count != destination.GetDesc().SampleDesc.Count;
                const bool needsMSAAResolve = source.GetDesc().SampleDesc.Count > 1 && destination.GetDesc().SampleDesc.Count == 1;
                // ResolveSubresource can't handle stretching or sub rects, use a draw to copy instead in these cases
                const bool mismatchedFormats = srcFormat != DXGI_FORMAT_UNKNOWN && dstFormat != DXGI_FORMAT_UNKNOWN && (ConvertToTypeless(srcFormat) != ConvertToTypeless(dstFormat));
                const bool channelSwap = source.NeedsSwapRBOutputChannels() != destination.NeedsSwapRBOutputChannels();
                const bool canUseResolveSubresource = needsMSAAResolve && !mismatchedFormats && !args.m_isStretchCopy && args.m_dimensionsCoverEntireResource;
                const bool needsStretchCopy = mismatchedFormats || args.m_isStretchCopy || (mismatchingSampleCount && !canUseResolveSubresource) || channelSwap;

                if (canUseResolveSubresource)
                {
                    context.ResourceResolveSubresource(destination.GetUnderlyingResource(),
                        destinationSubresourceIndex,
                        source.GetUnderlyingResource(),
                        sourceSubresourceIndex,
                        destination.GetViewFormat(false));
                }
                else if (needsStretchCopy)
                {
                    auto SetupRects = [&source, &destination, sourceSubresourceIndex, destinationSubresourceIndex](RECT& stretchSource, RECT& stretchDestination)
                    {
                        if (IsRectEmpty(stretchSource))
                        {
                            stretchSource = RectThatCoversEntireResource(source.GetSubresourceFootprint(sourceSubresourceIndex));
                        }

                        if (IsRectEmpty(stretchDestination))
                        {
                            stretchDestination = RectThatCoversEntireResource(destination.GetSubresourceFootprint(destinationSubresourceIndex));
                        }

                        ClipCopyRect(stretchDestination, stretchSource, static_cast<INT>(destination.GetDesc().Width), static_cast<INT>(destination.GetDesc().Height));
                        ClipCopyRect(stretchSource, stretchDestination, static_cast<INT>(source.GetDesc().Width), static_cast<INT>(source.GetDesc().Height));
                    };

                    if (!args.m_isStretchCopy)
                    {
                        RECT dstRect = RectThatCoversEntireResource(destination.GetSubresourceFootprint(destinationSubresourceIndex));
                        dstRect.left = destinationX;
                        dstRect.top = destinationY;
                        dstRect.right = dstRect.left + BoxWidth(sourceBox);
                        dstRect.bottom = dstRect.top + BoxHeight(sourceBox);

                        RECT srcRect = {};
                        srcRect.left = sourceBox.left;
                        srcRect.right = sourceBox.right;
                        srcRect.top = sourceBox.top;
                        srcRect.bottom = sourceBox.bottom;

                        SetupRects(srcRect, dstRect);
                        device.GetBlitHelper().Blit(
                            source.GetUnderlyingResource(),
                            srcSubresources, numSrcPlanes,
                            srcRect,
                            destination.GetUnderlyingResource(),
                            dstSubresources, numDstPlanes,
                            dstRect,
                            false,
                            channelSwap);
                    }
                    else
                    {
                        SetupRects(args.m_stretchSource, args.m_stretchDestination);
                        device.GetBlitHelper().Blit(
                            source.GetUnderlyingResource(),
                            srcSubresources, numSrcPlanes,
                            args.m_stretchSource,
                            destination.GetUnderlyingResource(),
                            dstSubresources, numDstPlanes,
                            args.m_stretchDestination,
                            args.m_EnableAlpha,
                            channelSwap);
                    }

                    break; // BlitHelper handles planer blits in a single calls.
                }
                else
                {
                    const D3D12_BOX* pBox = nullptr;
                    if (args.m_dimensionsCoverEntireResource == false)
                    {
                        pBox = &sourceBox;
                    }

                    context.ResourceCopyRegion(destination.GetUnderlyingResource(),
                        destinationSubresourceIndex,
                        destinationX, destinationY, destinationZ,
                        source.GetUnderlyingResource(),
                        sourceSubresourceIndex,
                        pBox);
                }
            }
        }
    }

    HRESULT Device::DoBlit(_In_ CONST D3DDDIARG_BLT* pBltArgs, BOOL EnableAlpha)
    {
        Resource* pSource = Resource::GetResourceFromHandle(pBltArgs->hSrcResource);
        Resource* pDestination = Resource::GetResourceFromHandle(pBltArgs->hDstResource);

        if (pSource == nullptr || pDestination == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        //TODO: Fully implement blit
        Check9on12(pBltArgs->ColorKey == 0);

        // Copy within the same resource
        if (pSource == pDestination)
        {
            Check9on12(pBltArgs->DstSubResourceIndex != pBltArgs->SrcSubResourceIndex);
        }

        {
            DXGI_FORMAT srcFormat = pSource->GetViewFormat(false);
            DXGI_FORMAT dstFormat = pDestination->GetViewFormat(false);

            // Stretch copy pipeline path does not support color space conversion
            if (IsYUVFormat(srcFormat) != IsYUVFormat(dstFormat))
            {
                if (IsYUVFormat(dstFormat))
                {
                    RETURN_E_INVALIDARG_AND_CHECK();
                }
            }
        }

        {
            ResourceCopyArgs resourceCopyArg = ResourceCopyArgs(*pDestination, *pSource);

            resourceCopyArg.m_EnableAlpha = EnableAlpha;
            resourceCopyArg.AsSubresourceBlit(pBltArgs->DstSubResourceIndex, pBltArgs->SrcSubResourceIndex, &pBltArgs->DstRect, &pBltArgs->SrcRect);

            Resource::CopySubResource(*this, resourceCopyArg);
        }
        return S_OK;
    }

    _Check_return_ HRESULT APIENTRY Blit(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_BLT* pBltArgs)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pBltArgs == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        HRESULT hr = pDevice->DoBlit(pBltArgs, false);

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr);
    }

    // In D3D9 the app can copy between two textures that have the same dimensions, but different mip
    // counts. When this happens we copy over all of the mip levels that match (missing the larger ones
    // which exist in one texture).
    void Resource::CopyMatchingMipLevels(Device& device, ResourceCopyArgs& args)
    {
        Resource& destination = args.m_destination;
        Resource& source = args.m_source;

        Check9on12(destination.GetArraySize() == source.GetArraySize());

        UINT srcStartMip = 0;
        UINT dstStartMip = 0;

        auto SkipLargerMips = [](UINT& leftMip, Resource& leftResource, Resource& rightResource)
        {
            UINT numLeftMips = leftResource.GetNumAppVisibleMips();
            for (; leftMip < numLeftMips; ++leftMip)
            {
                if (leftResource.GetLogicalDesc().Width >> leftMip <= rightResource.GetLogicalDesc().Width ||
                    leftResource.GetLogicalDesc().Height >> leftMip <= rightResource.GetLogicalDesc().Height)
                {
                    break;
                }
            }
        };
        SkipLargerMips(srcStartMip, source, destination);
        SkipLargerMips(dstStartMip, destination, source);
        Check9on12(max(source.m_logicalDesc.Width >> srcStartMip, 1ull) == max(destination.m_logicalDesc.Width >> dstStartMip, 1ull));
        Check9on12(max(source.m_logicalDesc.Height >> srcStartMip, 1u) == max(destination.m_logicalDesc.Height >> dstStartMip, 1u));

        UINT mipLevels = min(source.m_logicalDesc.MipLevels - srcStartMip, destination.m_logicalDesc.MipLevels - dstStartMip);

        UINT arrayStart = args.m_cubeFace == UINT_MAX ? 0 : args.m_cubeFace;
        UINT arrayEnd = args.m_cubeFace == UINT_MAX ? destination.GetArraySize() : args.m_cubeFace + 1;
        for (UINT arraySlice = arrayStart; arraySlice < arrayEnd; arraySlice++)
        {
            for (UINT mipSlice = 0; mipSlice < mipLevels; mipSlice++)
            {
                UINT srcMip = srcStartMip + mipSlice;
                UINT dstMip = dstStartMip + mipSlice;

                ResourceCopyArgs arg = args.GetSubArgs(arraySlice, srcMip, dstMip);
                Resource::CopySubResource(device, arg);
            }
        }
    }

    _Check_return_ HRESULT APIENTRY VolumeBlit1(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_VOLUMEBLT1* pBltArgs)
    {
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pBltArgs == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        Resource* pSource = Resource::GetResourceFromHandle(pBltArgs->hSrcResource);
        Resource* pDestination = Resource::GetResourceFromHandle(pBltArgs->hDstResource);

        ResourceCopyArgs args = ResourceCopyArgs(*pDestination, *pSource);
        D3D12_BOX box = {};
        box.left = pBltArgs->SrcBox.Left;
        box.top = pBltArgs->SrcBox.Top;
        box.front = pBltArgs->SrcBox.Front;
        box.right = pBltArgs->SrcBox.Right;
        box.bottom = pBltArgs->SrcBox.Bottom;
        box.back = pBltArgs->SrcBox.Back;

        args.AsVolumeBlit(pBltArgs->DstX, pBltArgs->DstY, pBltArgs->DstZ, box);

        Resource::CopyResource(*pDevice, args);
        return S_OK;
    }

     _Check_return_ HRESULT APIENTRY BufferBlit1(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_BUFFERBLT1* pBltArgs)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);

        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pBltArgs == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        Resource* pSource = Resource::GetResourceFromHandle(pBltArgs->hSrcResource);
        Resource* pDestination = Resource::GetResourceFromHandle(pBltArgs->hDstResource);

        if (pSource == nullptr || pDestination == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        HRESULT hr = S_OK;

        ResourceCopyArgs args = ResourceCopyArgs(*pDestination, *pSource);
        args.AsBufferBlit(pBltArgs->Offset, pBltArgs->SrcRange);

        Resource::CopyResource(*pDevice, args);
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr);
    }

    _Check_return_ HRESULT APIENTRY TextureBlit1(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_TEXBLT1* pBltArgs)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);

        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pBltArgs == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        Resource* pSource = Resource::GetResourceFromHandle(pBltArgs->hSrcResource);
        Resource* pDestination = Resource::GetResourceFromHandle(pBltArgs->hDstResource);

        if (pSource == nullptr || pDestination == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        HRESULT hr = S_OK;
        // Copy within the same resource
        if (pSource == pDestination)
        {
            Check9on12(false);

            hr = E_NOTIMPL;
        }

        ResourceCopyArgs args = ResourceCopyArgs(*pDestination, *pSource);
        args.AsTextureBlit(pBltArgs->DstPoint, pBltArgs->SrcRect, pBltArgs->CubeMapFace);

        Resource::CopyResource(*pDevice, args);

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr);
    }
};

```

`src/9on12Constants.cpp`:

```cpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#include "pch.h"

namespace D3D9on12
{
    _Check_return_ HRESULT APIENTRY SetVertexShaderConstF(_In_ HANDLE hDevice, _In_ const D3DDDIARG_SETVERTEXSHADERCONST* pRegisters, _In_ const VOID* pData)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);

        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pRegisters == nullptr || (pRegisters->Count > 0 && pData == nullptr))
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        pDevice->GetConstantsManager().GetVertexShaderConstants().GetConstantBufferData(ShaderConv::CB_FLOAT).SetData(pData, pRegisters->Register, pRegisters->Count);

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY SetVertexShaderConstI(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETVERTEXSHADERCONSTI* pRegisters, _In_ CONST INT* pData)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pRegisters == nullptr || (pRegisters->Count > 0 && pData == nullptr))
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        pDevice->GetConstantsManager().GetVertexShaderConstants().GetConstantBufferData(ShaderConv::CB_INT).SetData(pData, pRegisters->Register, pRegisters->Count);

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY SetVertexShaderConstB(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETVERTEXSHADERCONSTB* pRegisters, _In_ CONST BOOL* pData)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pRegisters == nullptr || (pRegisters->Count > 0 && pData == nullptr))
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        pDevice->GetConstantsManager().GetVertexShaderConstants().GetConstantBufferData(ShaderConv::CB_BOOL).SetData(pData, pRegisters->Register, pRegisters->Count);
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY SetPixelShaderConstF(_In_ HANDLE hDevice, _In_ const D3DDDIARG_SETPIXELSHADERCONST* pRegisters, _In_ const FLOAT* pData)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);

        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pRegisters == nullptr || (pRegisters->Count > 0 && pData == nullptr))
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        pDevice->GetConstantsManager().GetPixelShaderConstants().GetConstantBufferData(ShaderConv::CB_FLOAT).SetData(pData, pRegisters->Register, pRegisters->Count);

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY SetPixelShaderConstI(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETPIXELSHADERCONSTI* pRegisters, _In_ CONST INT* pData)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pRegisters == nullptr || (pRegisters->Count > 0 && pData == nullptr))
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        pDevice->GetConstantsManager().GetPixelShaderConstants().GetConstantBufferData(ShaderConv::CB_INT).SetData(pData, pRegisters->Register, pRegisters->Count);

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY SetPixelShaderConstB(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETPIXELSHADERCONSTB* pRegisters, _In_ CONST BOOL* pData)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pRegisters == nullptr || (pRegisters->Count > 0 && pData == nullptr))
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        pDevice->GetConstantsManager().GetPixelShaderConstants().GetConstantBufferData(ShaderConv::CB_BOOL).SetData(pData, pRegisters->Register, pRegisters->Count);
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    HRESULT ConstantsManager::Init()
    {
        m_nullCB.m_buffer = m_nullCB.m_allocator.Allocate(g_cMaxConstantBufferSize);

        memset(m_nullCB.m_buffer.m_pMappedAddress, 0, g_cMaxConstantBufferSize);

        //We should never be writing to the null CB
        m_nullCB.m_buffer.m_pMappedAddress = nullptr;

        // There must be a resource bound to each root constant slot
        m_vertexShaderData.NullOutBindings(m_device, m_nullCB);
        m_pixelShaderData.NullOutBindings(m_device, m_nullCB);

        return S_OK;
    }

    void ConstantsManager::Destroy()
    {
        m_vertexShaderData.Destroy();
        m_geometryShaderData.Destroy();
        m_pixelShaderData.Destroy();
    }

    void ConstantBufferBinding::Destroy()
    {
        m_allocator.Destroy();
    }

    void ConstantBufferBinding::Version(const void* pData, UINT dataSize)
    {
        m_buffer = m_allocator.Allocate(dataSize);

        if (pData)
        {
            memcpy(m_buffer.m_pMappedAddress, pData, dataSize);
        }
    }

    void ConstantsManager::BindToPipeline(Device& device, ConstantBufferBinding& buffer, D3D12TranslationLayer::EShaderStage shaderStage)
    {
        switch (shaderStage)
        {
        case D3D12TranslationLayer::e_VS:
            device.SetConstantBuffer<D3D12TranslationLayer::e_VS>(buffer.m_shaderRegister, buffer.m_buffer.m_pResource, buffer.m_buffer.m_offsetFromBase);
            break;
        case D3D12TranslationLayer::e_GS:
            device.SetConstantBuffer<D3D12TranslationLayer::e_GS>(buffer.m_shaderRegister, buffer.m_buffer.m_pResource, buffer.m_buffer.m_offsetFromBase);
            break;
        case D3D12TranslationLayer::e_PS:
            device.SetConstantBuffer<D3D12TranslationLayer::e_PS>(buffer.m_shaderRegister, buffer.m_buffer.m_pResource, buffer.m_buffer.m_offsetFromBase);
            break;
        default:
            assert(false);
        }
    }

    void ConstantsManager::StageConstants::Destroy()
    {
        m_floats.Destroy();
        m_integers.Destroy();
        m_booleans.Destroy();
    }

    void ConstantsManager::PixelShaderConstants::Destroy()
    {
        StageConstants::Destroy();
        m_extension1.Destroy();
        m_extension2.Destroy();
        m_extension3.Destroy();
    }

    void ConstantsManager::VertexShaderConstants::Destroy()
    {
        StageConstants::Destroy();
        m_extension.Destroy();
    }

    void ConstantsManager::GeometryShaderConstants::Destroy()
    {
        m_extension.Destroy();
    }

    void ConstantsManager::StageConstants::UpdateAppVisibleAndBindToPipeline(Device& device, UINT maxFloats, UINT maxInts, UINT maxBools)
    {
        Check9on12(maxFloats % 4 == 0);
        Result result = m_floats.UpdateData(device, maxFloats / 4);
        if (maxFloats && result == Result::S_CHANGE)
        {
            BindToPipeline(device, m_floats.m_binding, m_shaderType);
        }

        Check9on12(maxInts % 4 == 0);
        result = m_integers.UpdateData(device, maxInts / 4);
        if (maxInts && result == Result::S_CHANGE)
        {
            BindToPipeline(device, m_integers.m_binding, m_shaderType);
        }

        result = m_booleans.UpdateData(device, maxBools);
        if (maxBools && result == Result::S_CHANGE)
        {
            BindToPipeline(device, m_booleans.m_binding, m_shaderType);
        }
    }

    void ConstantsManager::StageConstants::NullOutBindings(Device& /*device*/, ConstantBufferBinding& nullCB)
    {
        m_floats.ReplaceResource(nullCB);
        m_integers.ReplaceResource(nullCB);
        m_booleans.ReplaceResource(nullCB);
    }

    void ConstantsManager::BindShaderConstants()
    {
        D3D12VertexShader* pVs = m_device.GetPipelineState().GetVertexStage().GetCurrentD3D12VertexShader();
        D3D12PixelShader* pPs = m_device.GetPipelineState().GetPixelStage().GetCurrentD3D12PixelShader();

        m_vertexShaderData.UpdateAppVisibleAndBindToPipeline(m_device, pVs->m_floatConstsUsed, pVs->m_intConstsUsed, pVs->m_boolConstsUsed);
        m_pixelShaderData.UpdateAppVisibleAndBindToPipeline(m_device, pPs->m_floatConstsUsed, pPs->m_intConstsUsed, pPs->m_boolConstsUsed);

        //Bind Internal Extension Constants (used by the Shader Converter)
        {
            if (m_vertexShaderData.m_dirty)
            {
                BindToPipeline(m_device, m_vertexShaderData.m_extension, D3D12TranslationLayer::EShaderStage::e_VS);
                m_vertexShaderData.m_dirty = false;
            }

            if (m_geometryShaderData.m_dirty)
            {
                BindToPipeline(m_device, m_geometryShaderData.m_extension, D3D12TranslationLayer::EShaderStage::e_GS);
                m_geometryShaderData.m_dirty = false;
            }

            if (m_pixelShaderData.m_dirty)
            {
                BindToPipeline(m_device, m_pixelShaderData.m_extension1, D3D12TranslationLayer::EShaderStage::e_PS);
                BindToPipeline(m_device, m_pixelShaderData.m_extension2, D3D12TranslationLayer::EShaderStage::e_PS);
                BindToPipeline(m_device, m_pixelShaderData.m_extension3, D3D12TranslationLayer::EShaderStage::e_PS);
                m_pixelShaderData.m_dirty = false;
            }
        }
    }

    void ConstantsManager::UpdateVertexShaderExtension(const ShaderConv::VSCBExtension& data)
    {
        m_vertexShaderData.m_extension.Version(&data, sizeof(data));
        m_vertexShaderData.m_dirty = true;
    }

    void ConstantsManager::UpdateGeometryShaderExtension(const ShaderConv::VSCBExtension& data)
    {
        m_geometryShaderData.m_extension.Version(&data, sizeof(data));
        m_geometryShaderData.m_dirty = true;
    }

    Result ConstantsManager::UpdatePixelShaderExtension(const ShaderConv::eConstantBuffers extension, const void* pData, size_t dataSize)
    {
        ConstantBufferBinding* pBinding;
        switch (extension)
        {
        case ShaderConv::CB_PS_EXT:
            pBinding = &m_pixelShaderData.m_extension1;
            break;
        case ShaderConv::CB_PS_EXT2:
            pBinding = &m_pixelShaderData.m_extension2;
            break;
        case ShaderConv::CB_PS_EXT3:
            pBinding = &m_pixelShaderData.m_extension3;
            break;
        default:
            Check9on12(false);
            pBinding = nullptr;
            return Result::E_INVALID_ARG;
        }
        assert(dataSize <= UINT_MAX);
        pBinding->Version(pData, static_cast<UINT>(dataSize));

        m_pixelShaderData.m_dirty = true;

        return Result::S_SUCCESS;
    }
}
```

`src/9on12DDIStub.cpp`:

```cpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#include "pch.h"

namespace D3D9on12
{

    /* Depricated DDI which will probably never have to be fully implemented */
    _Check_return_ HRESULT APIENTRY DrawRectPatch(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_DRAWRECTPATCH*, _In_ CONST D3DDDIRECTPATCH_INFO*, _In_ CONST FLOAT*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY DrawTriPatch(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_DRAWTRIPATCH*, _In_ CONST D3DDDITRIPATCH_INFO*, _In_ CONST FLOAT*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY SetState(_In_ HANDLE hDevice, _In_ D3DDDIARG_STATESET*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY MultiplyTransform(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_MULTIPLYTRANSFORM*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY SetTransform(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETTRANSFORM*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY SetMaterial(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETMATERIAL*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY SetLight(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETLIGHT*, _In_ CONST D3DDDI_LIGHT*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY CreateLight(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_CREATELIGHT*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY DestroyLight(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_DESTROYLIGHT*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }
    
    _Check_return_ HRESULT APIENTRY GetInfo(_In_ HANDLE hDevice, _In_ UINT, _Out_writes_bytes_(DevInfoSize)VOID*, _In_ UINT DevInfoSize)
    {
        UNREFERENCED_PARAMETER(DevInfoSize);

        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY ResolveSharedResource(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_RESOLVESHAREDRESOURCE*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }


    /* DDI which still need to be implemented */
    _Check_return_ HRESULT APIENTRY SetPriority(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETPRIORITY*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY UpdatePalette(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_UPDATEPALETTE*, _In_ CONST PALETTEENTRY*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY SetPalette(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETPALETTE*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY SetConvolutionKernelMono(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETCONVOLUTIONKERNELMONO*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY ComposeRects(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_COMPOSERECTS*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY CreateExtensionDevice(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_CREATEEXTENSIONDEVICE*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY DestroyExtensionDevice(_In_ HANDLE hDevice, _In_ HANDLE /*hExtension*/)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY ExtensionExecute(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_EXTENSIONEXECUTE*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY CreateOverlay(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_CREATEOVERLAY*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY UpdateOverlay(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_UPDATEOVERLAY*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY FlipOverlay(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_FLIPOVERLAY*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY GetOverlayColorControls(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_GETOVERLAYCOLORCONTROLS*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY SetOverlayColorControls(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETOVERLAYCOLORCONTROLS*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY DestroyOverlay(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_DESTROYOVERLAY*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY GetCaptureAllocationHandle(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_GETCAPTUREALLOCATIONHANDLE*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY CaptureToSystem(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_CAPTURETOSYSMEM*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

     _Check_return_ HRESULT APIENTRY CreateAuthenticatedChannel(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_CREATEAUTHENTICATEDCHANNEL*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY AuthenticatedChannelKeyExchange(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_AUTHENTICATEDCHANNELKEYEXCHANGE*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY QueryAuthenticatedChannel(_In_ HANDLE hDevice, _Inout_ CONST D3DDDIARG_QUERYAUTHENTICATEDCHANNEL*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY ConfigureAuthenticatedChannel(_In_ HANDLE hDevice, _Inout_ CONST D3DDDIARG_CONFIGUREAUTHENTICATEDCHANNEL*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY DestroyAuthenticatedChannel(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_DESTROYAUTHENTICATEDCHANNEL*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY CreateCrytoSession(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_CREATECRYPTOSESSION*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY CrytoSessionKeyExchange(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_CRYPTOSESSIONKEYEXCHANGE*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY DestroyCryptoSession(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_DESTROYCRYPTOSESSION*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY EncryptionBlit(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_ENCRYPTIONBLT*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY GetPitch(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_GETPITCH*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY StartSessionKeyReresh(_In_ HANDLE hDevice, _Inout_ CONST D3DDDIARG_STARTSESSIONKEYREFRESH*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY FinishSessionKeyRefresh(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_FINISHSESSIONKEYREFRESH*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY GetEncryptionBlitKey(_In_ HANDLE hDevice, _Inout_ CONST D3DDDIARG_GETENCRYPTIONBLTKEY*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY DecryptionBlit(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_DECRYPTIONBLT*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY Discard(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_DISCARD*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY OfferResources(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_OFFERRESOURCES*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY ReclaimResources(_In_ HANDLE hDevice, _Inout_ CONST D3DDDIARG_RECLAIMRESOURCES*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY CheckDirectFlipSupport(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_CHECKDIRECTFLIPSUPPORT*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY CheckMultiplaneOverlaySupport(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_CHECKMULTIPLANEOVERLAYSUPPORT*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY PresentMultiplaneOverlay(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_PRESENTMULTIPLANEOVERLAY*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY CheckPresentDurationSupport(_In_ HANDLE hDevice, _In_ D3DDDIARG_CHECKPRESENTDURATIONSUPPORT*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice); 
        if (pDevice == nullptr)
        { 
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }
};
```

`src/9on12DecodeDevice.cpp`:

```cpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#include "pch.h"

namespace D3D9on12
{
    _Check_return_ HRESULT APIENTRY CreateDecodeDevice(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_CREATEDECODEDEVICE *pCreateDecodeDevice)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr  || pCreateDecodeDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        DecodeDevice *pDecodeDevice = new DecodeDevice(pCreateDecodeDevice->hDecode, pDevice, pCreateDecodeDevice);
        if (pDecodeDevice == nullptr)
        {
            return E_OUTOFMEMORY;
        }

        pCreateDecodeDevice->hDecode = DecodeDevice::GetHandleFromDecodeDevice(pDecodeDevice);

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY DestroyDecodeDevice(_In_ HANDLE /*hDevice*/, _In_ HANDLE hDecodeDevice)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        DecodeDevice *pDecodeDevice = DecodeDevice::GetDecodeDeviceFromHandle(hDecodeDevice);

        if (pDecodeDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        delete pDecodeDevice;

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY DecodeBeginFrame(_In_ HANDLE /*hDevice*/, _In_ D3DDDIARG_DECODEBEGINFRAME *pBeginFrame)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        DecodeDevice *pDecodeDevice = DecodeDevice::GetDecodeDeviceFromHandle(pBeginFrame->hDecode);
        if (pDecodeDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }
        pDecodeDevice->BeginFrame(pBeginFrame);
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY DecodeEndFrame(_In_ HANDLE /*hDevice*/, _Inout_ D3DDDIARG_DECODEENDFRAME *pEndFrame)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        DecodeDevice *pDecodeDevice = DecodeDevice::GetDecodeDeviceFromHandle(pEndFrame->hDecode);
        if (pDecodeDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }
        pDecodeDevice->EndFrame(pEndFrame);
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY DecodeExecute(_In_ HANDLE /*hDevice*/, _In_ CONST D3DDDIARG_DECODEEXECUTE *pExecute)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        DecodeDevice *pDecodeDevice = DecodeDevice::GetDecodeDeviceFromHandle(pExecute->hDecode);
        if (pDecodeDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }
        pDecodeDevice->Execute(pExecute);
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY DecodeExtensionExecuter(_In_ HANDLE hDevice, _Inout_ CONST D3DDDIARG_DECODEEXTENSIONEXECUTE* pExtensionExecute)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        HRESULT hr = E_NOTIMPL;
        if (pExtensionExecute->Function == DXVA_STATUS_REPORTING_FUNCTION)
        {
            DecodeDevice *pDecodeDevice = DecodeDevice::GetDecodeDeviceFromHandle(pExtensionExecute->hDecode);
            if (pDecodeDevice == nullptr)
            {
                RETURN_E_INVALIDARG_AND_CHECK();
            }
            hr = pDecodeDevice->ExecuteExtension(pExtensionExecute);
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr);
    }

    _Check_return_ HRESULT APIENTRY SetDecodeRenderTarget(_In_ HANDLE /* hDevice */, _In_ CONST D3DDDIARG_SETDECODERENDERTARGET *pRenderTarget)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        DecodeDevice *pDecodeDevice = DecodeDevice::GetDecodeDeviceFromHandle(pRenderTarget->hDecode);
        if (pDecodeDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }
        pDecodeDevice->SetDecodeRenderTarget(pRenderTarget);
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Use_decl_annotations_
    DecodeDevice::DecodeDevice(HANDLE runtimeHandle, Device *pParent, const D3DDDIARG_CREATEDECODEDEVICE *pCreateDecodeDevice) :
        m_runtimeHandle(runtimeHandle),
        m_pParentDevice(pParent)
    {
        D3D12TranslationLayer::VideoDecodeCreationArgs createArgs = {};

        if (pCreateDecodeDevice->pConfig->guidConfigMBcontrolEncryption != DXVA_NoEncrypt ||
            pCreateDecodeDevice->pConfig->guidConfigResidDiffEncryption != DXVA_NoEncrypt ||
            pCreateDecodeDevice->pConfig->ConfigBitstreamRaw == 0 ||
            pCreateDecodeDevice->pConfig->ConfigResidDiffHost != 0 ||
            pCreateDecodeDevice->pConfig->ConfigSpatialResid8 != 0 ||
            pCreateDecodeDevice->pConfig->ConfigResid8Subtraction != 0 ||
            pCreateDecodeDevice->pConfig->ConfigSpatialHost8or9Clipping != 0 ||
            pCreateDecodeDevice->pConfig->ConfigSpatialResidInterleaved != 0 ||
            pCreateDecodeDevice->pConfig->ConfigIntraResidUnsigned != 0 ||
            pCreateDecodeDevice->pConfig->Config4GroupedCoefs != 0)
        {
            ThrowFailure(E_INVALIDARG);
        }

        createArgs.Desc.DecodeProfile = *pCreateDecodeDevice->pGuid;
        createArgs.Desc.Width = pCreateDecodeDevice->VideoDesc.SampleWidth;
        createArgs.Desc.Height = pCreateDecodeDevice->VideoDesc.SampleHeight;
        createArgs.Desc.DecodeFormat = ConvertFromDDIToDXGIFORMAT(pCreateDecodeDevice->VideoDesc.Format);
        createArgs.Config.ConfigDecoderSpecific = pCreateDecodeDevice->pConfig->ConfigDecoderSpecific;
        createArgs.Config.InterlaceType = VideoTranslate::GetInterlaceType((DXVADDI_SAMPLEFORMAT)pCreateDecodeDevice->VideoDesc.SampleFormat.SampleFormat);

        m_pParentDevice->EnsureVideoDevice();

        m_pUnderlyingVideoDecode = new (m_pUnderlyingSpace) D3D12TranslationLayer::VideoDecode(&m_pParentDevice->GetContext(), createArgs);

        m_decodeProfile = createArgs.Desc.DecodeProfile;
    }

    DecodeDevice::~DecodeDevice()
    {
        if (m_pUnderlyingVideoDecode)
        {
            m_pUnderlyingVideoDecode->~VideoDecode();
        }
    }

    _Use_decl_annotations_
    void DecodeDevice::SetDecodeRenderTarget(CONST D3DDDIARG_SETDECODERENDERTARGET *pRenderTarget)
    {
        Resource *pResource = Resource::GetResourceFromHandle(pRenderTarget->hRenderTarget);

        D3D12TranslationLayer::AppResourceDesc* pAppDesc = pResource->GetUnderlyingResource()->AppDesc();
        D3D12TranslationLayer::VIDEO_DECODER_OUTPUT_VIEW_DESC_INTERNAL viewDesc = { pAppDesc->Format(), pRenderTarget->SubResourceIndex };

        const UINT8 MipLevels = pAppDesc->MipLevels();
        const UINT16 ArraySize = pAppDesc->ArraySize();
        const UINT8 PlaneCount = (pResource->GetUnderlyingResource()->SubresourceMultiplier() * pAppDesc->NonOpaquePlaneCount());

        m_outputArguments.SubresourceSubset = D3D12TranslationLayer::CViewSubresourceSubset(viewDesc, MipLevels, ArraySize, PlaneCount);
        m_outputArguments.pOutputTexture2D = pResource->GetUnderlyingResource();
        m_inUseResources.output = pResource->GetUnderlyingResource();
    }

    _Use_decl_annotations_
    HRESULT DecodeDevice::ExecuteExtension(CONST D3DDDIARG_DECODEEXTENSIONEXECUTE* pExtensionExecute)
    {
        if (pExtensionExecute->Function == DXVA_STATUS_REPORTING_FUNCTION)
        {
            return m_pUnderlyingVideoDecode->GetDecodingStatus(pExtensionExecute->pPrivateOutput->pData, pExtensionExecute->pPrivateOutput->DataSize);
        }

        return E_NOTIMPL;
    }

    _Use_decl_annotations_
    void DecodeDevice::BeginFrame(D3DDDIARG_DECODEBEGINFRAME * /*pBeginFrame*/)
    {
        if (m_frameNestCount != 0)
        {
            // we do not allow nested BeginFrames in 9on12. The post processing flag for VC1 is always off.
            ThrowFailure(E_INVALIDARG);
        }
        ++m_frameNestCount;
    }

    _Use_decl_annotations_
    void DecodeDevice::Execute(CONST D3DDDIARG_DECODEEXECUTE *pExecute)
    {
        for (DWORD i = 0; i < pExecute->NumCompBuffers; i++)
        {
            DXVADDI_DECODEBUFFERDESC *pBufferDesc = &pExecute->pCompressedBuffers[i];

            if (m_inputArguments.FrameArgumentsCount >= D3D12_VIDEO_DECODE_MAX_ARGUMENTS)
            {
                ThrowFailure(E_INVALIDARG);
            }
            __analysis_assume(m_inputArguments.FrameArgumentsCount < D3D12_VIDEO_DECODE_MAX_ARGUMENTS);

            switch (pBufferDesc->CompressedBufferType)
            {
                case D3DDDIFMT_PICTUREPARAMSDATA:
                case D3DDDIFMT_SLICECONTROLDATA:
                case D3DDDIFMT_INVERSEQUANTIZATIONDATA:
                {
                    Resource* pResource = Resource::GetResourceFromHandle(pBufferDesc->hBuffer);
                    D3D12TranslationLayer::MappedSubresource mappedSubresource;

                    m_pParentDevice->GetContext().Map(pResource->GetUnderlyingResource(), 0, D3D12TranslationLayer::MAP_TYPE::MAP_TYPE_READ, false, nullptr, &mappedSubresource);
                    m_inputArguments.FrameArguments[m_inputArguments.FrameArgumentsCount].Type = VideoTranslate::VideoDecodeArgumentType(pBufferDesc->CompressedBufferType);
                    m_inputArguments.FrameArguments[m_inputArguments.FrameArgumentsCount].pData = mappedSubresource.pData;
                    m_inputArguments.FrameArguments[m_inputArguments.FrameArgumentsCount].Size = pBufferDesc->DataSize;
                    m_inUseResources.frameArguments[m_inputArguments.FrameArgumentsCount] = pResource->GetUnderlyingResource();
                    ++m_inputArguments.FrameArgumentsCount;
                }
                break;

                case D3DDDIFMT_BITSTREAMDATA:
                {
                    // TODO: assume it all fits for now, no bad slice chopping (see work items 5743248/5743254)
                    Resource* pResource = Resource::GetResourceFromHandle(pBufferDesc->hBuffer);
                    D3D12TranslationLayer::Resource *pTranslationResource = pResource->GetUnderlyingResource();
                    m_inputArguments.CompressedBitstream.pBuffer = pTranslationResource;
                    m_inputArguments.CompressedBitstream.Offset = pBufferDesc->DataOffset;
                    m_inputArguments.CompressedBitstream.Size = pBufferDesc->DataSize;
                    m_inUseResources.compressedBitstream = pResource->GetUnderlyingResource();
                }
                break;

            default:
                ThrowFailure(E_INVALIDARG);
                break;
            }
        }

    }

    _Use_decl_annotations_
        void DecodeDevice::EndFrame(D3DDDIARG_DECODEENDFRAME * /*pEndFrame*/)
    {
        --m_frameNestCount;

        m_pUnderlyingVideoDecode->DecodeFrame(&m_inputArguments, &m_outputArguments);

        // now unmap frame arguments
        for (UINT i = 0; i < m_inputArguments.FrameArgumentsCount; i++)
        {
            m_pParentDevice->GetContext().Unmap(m_inUseResources.frameArguments[i].get(), 0, D3D12TranslationLayer::MAP_TYPE::MAP_TYPE_READ, nullptr);
        }
        m_inUseResources = decltype(m_inUseResources){};
        ZeroMemory(&m_inputArguments, sizeof(m_inputArguments));
        ZeroMemory(&m_outputArguments, sizeof(m_outputArguments));
    }
};

```

`src/9on12Device.cpp`:

```cpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#include "pch.h"

namespace D3D9on12
{
    void APIENTRY GetPrivateDDITable(D3D9ON12_PRIVATE_DDI_TABLE *pPrivateDDITable)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        static const D3D9ON12_PRIVATE_DDI_TABLE cPrivateDDITable =
        {
            OpenAdapter_Private,

            GetSharedGDIHandle_Private,
            CreateSharedNTHandle_Private,
            GetDeviceExecutionState_Private,
            KmdPresent,

            CreateFence,
            OpenFence,
            ShareFence,
            WaitForFence,
            SignalFence,

            GetCompletedFenceValue,
            DestroyTrackedFence,

            QueryResourcePrivateDriverDataSize,
            OpenResource_Private,

            CreateKMTHandle,
            QueryResourceInfoFromKMTHandle,
            DestroyKMTHandle,

            CreateResourceWrappingHandle,
            DestroyResourceWrappingHandle,

            GetD3D12Device,
            TransitionResource,
            SetCurrentResourceState,

            SetMaximumFrameLatency,
            IsMaximumFrameLatencyReached,
            GetD3D12Resource,
            AddResourceWaitsToQueue,
            AddDeferredWaitsToResource
        };

        memcpy(pPrivateDDITable, &cPrivateDDITable, sizeof(D3D9ON12_PRIVATE_DDI_TABLE));
        D3D9on12_DDI_ENTRYPOINT_END_AND_REPORT_HR((HANDLE)0, S_OK);
    }

    HRESULT APIENTRY GetPrivateDDITableVersioned(_Inout_updates_bytes_(ddiTableSize) void* pPrivateDDITableVersioned, UINT ddiTableSize)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        if (ddiTableSize > sizeof(D3D9ON12_PRIVATE_DDI_TABLE_VERSIONED))
        {
            return E_INVALIDARG;
        }

        static const D3D9ON12_PRIVATE_DDI_TABLE_VERSIONED cPrivateDDITable =
        {
            OpenAdapter_Private,

            GetSharedGDIHandle_Private,
            CreateSharedNTHandle_Private,
            GetDeviceExecutionState_Private,
            KmdPresent,

            CreateFence,
            OpenFence,
            ShareFence,
            WaitForFence,
            SignalFence,

            GetCompletedFenceValue,
            DestroyTrackedFence,

            QueryResourcePrivateDriverDataSize,
            OpenResource_Private,

            CreateKMTHandle,
            QueryResourceInfoFromKMTHandle,
            DestroyKMTHandle,

            CreateResourceWrappingHandle,
            DestroyResourceWrappingHandle,

            GetD3D12Device,
            TransitionResource,
            SetCurrentResourceState,

            SetMaximumFrameLatency,
            IsMaximumFrameLatencyReached,
            GetD3D12Resource,
            AddResourceWaitsToQueue,
            AddDeferredWaitsToResource,

            // interface version 2
            OpenAdapter2_Private,
            CloseAndSubmitGraphicsCommandListForPresent,
            PreExecuteCommandList,
            PostExecuteCommandList
        };
        memcpy(pPrivateDDITableVersioned, &cPrivateDDITable, ddiTableSize);
        
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY GetDeviceExecutionState_Private(_In_ HANDLE hDevice)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }
        HRESULT hr = pDevice->GetContext().GetDeviceState();
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr);
    }

    _Check_return_ HRESULT APIENTRY CreateFence(HANDLE hDevice, UINT64 InitialValue, UINT Flags, _Out_ HANDLE* phFence)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        *phFence = Fence::GetHandleFromFence(new Fence(pDevice, InitialValue, Flags));
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY OpenFence(HANDLE hDevice, HANDLE hSharedFence, _Out_ BOOL* pbMonitored, _Out_ HANDLE* phFence)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        Fence* pOpenedFence = new Fence(pDevice, hSharedFence);
        *phFence = Fence::GetHandleFromFence(pOpenedFence);
        *pbMonitored = pOpenedFence->IsMonitored();
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY SetDisplayMode(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETDISPLAYMODE*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }
        // Unsure if we need to do anything here, DXGI already seems to do the right thing

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY ValidateDevice(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_VALIDATETEXTURESTAGESTATE* pValidateTextureStageState)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pValidateTextureStageState == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        // TODO: Verify that DX12 hardware is good enough for this assumption
        pValidateTextureStageState->NumPasses = 1;

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY Flush1(_In_ HANDLE hDevice, UINT FlushFlags)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        HRESULT hr = pDevice->FlushWork(false, FlushFlags);
        CHECK_HR(hr);

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr);
    }

    _Check_return_ HRESULT APIENTRY DestroyDevice(_In_ HANDLE hDevice)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        HRESULT hr = pDevice->Destroy();
        CHECK_HR(hr);

        SAFE_DELETE(pDevice);

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr);
    }


    void APIENTRY AcquireResource(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SYNCTOKEN* pToken)
    {
        HRESULT hr = S_OK;

        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);

        pDevice->FlushWork(false);

        D3DDDICB_SYNCTOKEN syncTokenCB = {};
        syncTokenCB.BroadcastContextCount = 0;
        syncTokenCB.hSyncToken = pToken->hSyncToken;
        hr = pDevice->GetRuntimeCallbacks().pfnAcquireResourceCb(pDevice->GetRuntimeHandle(), &syncTokenCB);

        D3D9on12_DDI_ENTRYPOINT_END_AND_REPORT_HR(hDevice, hr);
    }

    void APIENTRY ReleaseResource(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SYNCTOKEN *pToken)
    {
        HRESULT hr = S_OK;

        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);

        pDevice->FlushWork(false);

        D3DDDICB_SYNCTOKEN syncTokenCB = {};
        syncTokenCB.BroadcastContextCount = 0;
        syncTokenCB.hSyncToken = pToken->hSyncToken;
        hr = pDevice->GetRuntimeCallbacks().pfnReleaseResourceCb(pDevice->GetRuntimeHandle(), &syncTokenCB);

        D3D9on12_DDI_ENTRYPOINT_END_AND_REPORT_HR(hDevice, hr);
    }

    HRESULT APIENTRY GetD3D12Device(HANDLE hDevice, REFIID riid, void** ppv)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (hDevice == nullptr || ppv == nullptr)
        {
            return E_INVALIDARG;
        }

        HRESULT hr = pDevice->m_pDevice->QueryInterface(riid, ppv);

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr);
    }

    HRESULT APIENTRY GetD3D12Resource(HANDLE hResource, REFIID riid, void** ppv)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);

        HRESULT hr = S_OK;

        Resource* pResource = Resource::GetResourceFromHandle(hResource);
        if (pResource == nullptr || ppv == nullptr)
        {
            hr = E_INVALIDARG;
        }

        if (SUCCEEDED(hr))
        {
            auto* pTranslationLayerResource = pResource->GetUnderlyingResource();

            if (   pTranslationLayerResource != nullptr
                && pTranslationLayerResource->GetUnderlyingResource() != nullptr)
            {
                hr = pTranslationLayerResource->GetUnderlyingResource()->QueryInterface(riid, ppv);
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr);
    }

    HRESULT APIENTRY AddResourceWaitsToQueue(HANDLE hResource, ID3D12CommandQueue* pCommmandQueue)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);

        Resource* p9on12Resource = Resource::GetResourceFromHandle(hResource);
        auto* pTranslationLayerResource = p9on12Resource->GetUnderlyingResource();
        D3D12TranslationLayer::ManagedObject* pResidencyHandle = pTranslationLayerResource->GetResidencyHandle();

        Device* pDevice = p9on12Resource->GetParent();
        auto& ImmCtx = pDevice->GetContext();

        if (pResidencyHandle)
        {
            // Pin the resource while it is checked out to the caller.
            pResidencyHandle->Pin();

            // Ensure that the resource is resident after the waits on the callers queue are satisfied.
            auto pResidencySet = std::make_unique<D3D12TranslationLayer::ResidencySet>();

            pResidencySet->Open((UINT)D3D12TranslationLayer::COMMAND_LIST_TYPE::MAX_VALID);
            pResidencySet->Insert(pResidencyHandle);
            pResidencySet->Close();

            ImmCtx.GetResidencyManager().SubmitCommandQueueCommand(pCommmandQueue, UINT_MAX, pResidencySet.get(), []() {});
            
            // Add a deferred wait for the residency operation.  This operation is signaled on the callers queue.
            // This handles the case where caller decides to return the resource without scheduling dependent work
            // that they provide fence/value pair for.
            pTranslationLayerResource->AddFenceForUnwrapResidency(pCommmandQueue);
        }

        for (UINT i = 0; i < (UINT)D3D12TranslationLayer::COMMAND_LIST_TYPE::MAX_VALID; ++i)
        {
            auto* pCommandListManager = ImmCtx.GetCommandListManager(static_cast<D3D12TranslationLayer::COMMAND_LIST_TYPE>(i));
            if (pCommandListManager)
            {
                UINT64 WaitValue = pTranslationLayerResource->m_LastUsedCommandListID[i];

                if (WaitValue > pCommandListManager->GetCompletedFenceValue())
                {
                    auto* pFence = pCommandListManager->GetFence();
                    pCommmandQueue->Wait(pFence->Get(), WaitValue);
                    pCommandListManager->SetNeedSubmitFence();
                }
            }
        }

        
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    HRESULT APIENTRY AddDeferredWaitsToResource(HANDLE hResource, UINT NumSync, UINT64* pSignalValues, ID3D12Fence** ppFences)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);

        Resource* p9on12Resource = Resource::GetResourceFromHandle(hResource);
        auto* pTranslationLayerResource = p9on12Resource->GetUnderlyingResource();
        D3D12TranslationLayer::ManagedObject* pResidencyHandle = pTranslationLayerResource->GetResidencyHandle();

        Device* pDevice = p9on12Resource->GetParent();
        auto& ImmCtx = pDevice->GetContext();

        std::vector<D3D12TranslationLayer::DeferredWait> DeferredWaits;
        DeferredWaits.reserve(NumSync); // throw( bad_alloc )

        for (UINT i = 0; i < NumSync; i++)
        {
            const D3D12TranslationLayer::DeferredWait deferredWait = 
            {
                std::make_shared<D3D12TranslationLayer::Fence>(&ImmCtx, ppFences[i]),
                pSignalValues[i]
            };
            DeferredWaits.push_back(deferredWait);
        }

        pTranslationLayerResource->AddDeferredWaits(DeferredWaits);

        if (pResidencyHandle)
        {
            // Transition from an explicit pin to a pin until these waits are satisfied.
            pResidencyHandle->AddPinWaits(NumSync, pSignalValues, ppFences);
            pResidencyHandle->UnPin();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY SetTexture(_In_ HANDLE hDevice, _In_ UINT stage, _In_ HANDLE hTexture)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        Resource* pResource = Resource::GetResourceFromHandle(hTexture);


        if (stage == DMAP_SAMPLER || stage == D3DDMAPSAMPLER)
        {
            if (pResource)
            {
                PrintDebugMessage("Skipping SetTexture for a DMAP_SAMPLER or D3DDMAPSAMPLER");
            }
            return S_OK;
        }


        if (pDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        stage = MapSamplerStage9on12(stage);
        HRESULT hr = pDevice->GetPipelineState().GetPixelStage().SetSRV(*pDevice, pResource, stage);
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr);
    }

    void APIENTRY SetMaximumFrameLatency(HANDLE hDevice, UINT MaxFrameLatency)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        pDevice->GetContext().m_MaxFrameLatencyHelper.SetMaximumFrameLatency(MaxFrameLatency);
        D3D9on12_DDI_ENTRYPOINT_END_AND_REPORT_HR(hDevice, S_OK);
    }

    BOOL APIENTRY IsMaximumFrameLatencyReached(HANDLE hDevice)
    {
        BOOL result = FALSE;
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        result = pDevice->GetContext().m_MaxFrameLatencyHelper.IsMaximumFrameLatencyReached();
        D3D9on12_DDI_ENTRYPOINT_END_AND_REPORT_HR(hDevice, S_OK);
        return result;
    }

    _Check_return_ HRESULT APIENTRY PreExecuteCommandList(_In_ HANDLE hDevice, D3D9ON12_COMMANDLIST_TYPE commandListType)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        auto clt = static_cast<D3D12TranslationLayer::COMMAND_LIST_TYPE>(commandListType);
        HRESULT hr = pDevice->GetContext().GetCommandListManager(clt)->PreExecuteCommandQueueCommand();
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR((hr));
    }

    _Check_return_ HRESULT APIENTRY PostExecuteCommandList(_In_ HANDLE hDevice, D3D9ON12_COMMANDLIST_TYPE commandListType)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        auto clt = static_cast<D3D12TranslationLayer::COMMAND_LIST_TYPE>(commandListType);
        HRESULT hr = pDevice->GetContext().GetCommandListManager(clt)->PostExecuteCommandQueueCommand();
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr);
    }

    HRESULT Device::FlushWork(bool WaitOnCompletion, UINT /*FlushFlags*/)
    {
        if (WaitOnCompletion)
        {
            GetContext().WaitForCompletion(D3D12TranslationLayer::COMMAND_LIST_TYPE_ALL_MASK);
        }
        else
        {
            GetContext().Flush(D3D12TranslationLayer::COMMAND_LIST_TYPE_ALL_MASK);
        }
        return S_OK;
    }

    HRESULT Device::Init(ID3D12Device *pDevice, ID3D12CommandQueue *pCommandQueue)
    {
        HRESULT hr = S_OK;
        
        m_pDevice = pDevice;
        m_pCommandQueue = pCommandQueue;

        D3D12_FEATURE_DATA_D3D12_OPTIONS FeatureDataD3D12 = {};
        D3D12TranslationLayer::TranslationLayerCallbacks Callbacks{};

        if (SUCCEEDED(hr))
        {
            hr = GetDevice().CheckFeatureSupport(D3D12_FEATURE_D3D12_OPTIONS, &FeatureDataD3D12, sizeof(D3D12_FEATURE_DATA_D3D12_OPTIONS));
            CHECK_HR(hr);
        }

        if (SUCCEEDED(hr))
        {
            D3D12TranslationLayer::ImmediateContext::CreationArgs args = {};
            args.RequiresBufferOutOfBoundsHandling = false;
            args.CreatesAndDestroysAreMultithreaded = !RegistryConstants::g_cSingleThread;
            args.RenamingIsMultithreaded = args.CreatesAndDestroysAreMultithreaded;
            args.UseThreadpoolForPSOCreates = false;
            args.UseRoundTripPSOs = false;
            args.UseResidencyManagement = true;
            args.DisableGPUTimeout = false;
            args.AdjustYUY2BlitCoords = m_Adapter.RequiresYUY2BlitWorkaround();
#ifdef __D3D9On12CreatorID_INTERFACE_DEFINED__
            args.CreatorID = __uuidof(D3D9On12CreatorID);
#endif
            args.MaxAllocatedUploadHeapSpacePerCommandList =
                min(RegistryConstants::g_cMaxAllocatedUploadHeapSpacePerCommandList,
                    g_AppCompatInfo.MaxAllocatedUploadHeapSpacePerCommandList);

            args.MaxSRVHeapSize = min(RegistryConstants::g_cMaxSRVHeapSize, g_AppCompatInfo.MaxSRVHeapSize);
            args.BufferPoolTrimThreshold = min(RegistryConstants::g_cBufferPoolTrimThreshold, g_AppCompatInfo.BufferPoolTrimThreshold);

            if (!RegistryConstants::g_cSingleThread)
            {
                m_lockedResourceRanges.InitLock();
            }
            
            m_pImmediateContext.emplace(
                0,
                FeatureDataD3D12,
                &GetDevice(),
                &GetCommandQueue(),
                Callbacks,
                0,
                args);

            D3D12TranslationLayer::SharedResourceHelpers::CreationFlags sharingFlags = {};
            m_pSharedResourceHelpers.emplace(*m_pImmediateContext, sharingFlags);

            m_pImmediateContext->SetNumScissorRects(1);
            m_pImmediateContext->SetNumViewports(1);

            hr = m_constantsManager.Init();
            CHECK_HR(hr);
        }

        if (SUCCEEDED(hr))
        {
            hr = m_pipelineState.Init(*this);
            CHECK_HR(hr);
        }

        if (SUCCEEDED(hr))
        {
            m_Adapter.DeviceCreated(this);
        }

        (void)GetDevice().CheckFeatureSupport(D3D12_FEATURE_D3D12_OPTIONS19, &m_Options19, sizeof(m_Options19));
        return hr;
    }

    Device::Device( Adapter& Adapter, _Inout_ D3DDDIARG_CREATEDEVICE& CreateDeviceArgs ) :
        m_Adapter( Adapter ),
        m_runtimeHandle( CreateDeviceArgs.hDevice ),
        m_pUMDPresentArgs( nullptr ),
        m_pipelineStateCache( *this ),
        m_pipelineState( *this ),
        m_NodeMask( 0 ),
        m_d3d9APIVersion( CreateDeviceArgs.Version ),
        m_constantsManager( *this ),
        m_systemMemoryAllocator( *this, 32 * 1024 * 1024, 4, /*bDeferDestroyDuringRealloc*/ true ),
        m_pVideoDevice( nullptr )
    {
        memcpy( (void*)&m_Callbacks, CreateDeviceArgs.pCallbacks, sizeof( m_Callbacks ) );
        memset( m_streamFrequency, 0, sizeof( m_streamFrequency ) );

        HRESULT hr = Init( m_Adapter.GetDevice(), m_Adapter.GetCommandQueue() );

        ThrowFailure( hr );

        CreateDeviceArgs.hDevice = Device::GetHandleFromDevice( this );// in:  Runtime handle/out: Driver handle
        CreateDeviceArgs.pAllocationList = NULL;
        CreateDeviceArgs.pPatchLocationList = NULL;
        CreateDeviceArgs.CommandBuffer = 0;

        memcpy( CreateDeviceArgs.pDeviceFuncs, &g_9on12DeviceFuntions, sizeof( *CreateDeviceArgs.pDeviceFuncs ) );  // out: Driver function table

        // Marking these null informs the runtime that we don't want to participate in driver threading
        if (RegistryConstants::g_cSingleThread)
        {
            CreateDeviceArgs.pDeviceFuncs->pfnLockAsync = nullptr;
            CreateDeviceArgs.pDeviceFuncs->pfnUnlockAsync = nullptr;
            CreateDeviceArgs.pDeviceFuncs->pfnRename = nullptr;
        }
    }

    Device::~Device()
    {
        if (m_pVideoDevice)
        {
            m_pVideoDevice->~VideoDevice();
        }
    }

    HRESULT Device::Destroy()
    {
        m_constantsManager.Destroy();
        m_systemMemoryAllocator.Destroy();
        m_Adapter.DeviceDestroyed(this);

        return S_OK;
    }

    HRESULT Device::ResolveDeferredState(OffsetArg BaseVertexStart, OffsetArg BaseIndexStart)
    {
        //First resolve the pipeline state
        HRESULT hr = m_pipelineState.ResolveDeferredState(*this, BaseVertexStart, BaseIndexStart);

        return hr;
    }

    WeakHash Device::HashStreamFrequencyData(WeakHash inputHash)
    {
        return HashData(m_streamFrequency, sizeof(m_streamFrequency), inputHash);
    }

    void Device::EnsureVideoDevice()
    {
        HRESULT hr = S_OK;
        if (!m_pVideoDevice)
        {
            try
            {
                m_pVideoDevice = new (m_pVideoDeviceSpace)VideoDevice(this);
            }
            catch (_com_error& hrEx)
            {
                hr = hrEx.Error();
            }
            catch (std::bad_alloc&)
            {
                hr = E_OUTOFMEMORY;
            }
            ThrowFailure(hr);
        }
    }

    VideoDevice* Device::GetVideoDevice()
    {
        return m_pVideoDevice;
    }

    void Device::LogCreateVideoDevice( HRESULT hr )
    {
        //Do nothing
        UNREFERENCED_PARAMETER( hr );
    }

    void Device::SetDrawingPreTransformedVerts(bool preTransformedVerts)
    {
        GetPipelineState().GetPixelStage().SetPreTransformedVertexMode(preTransformedVerts);
    }
};
```

`src/9on12Draw.cpp`:

```cpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#include "pch.h"

namespace D3D9on12
{

};
```

`src/9on12FastUploadAllocator.cpp`:

```cpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#include "pch.h"

namespace D3D9on12
{
    FastUploadAllocator::FastUploadAllocator(Device& device, UINT size, UINT alignment, bool bDeferDestroyDuringRealloc) :
        m_parentDevice(device),
        m_bDeferDestroyDuringRealloc(bDeferDestroyDuringRealloc),
        m_size(size),
        m_alignmentRequired(alignment),
        m_spaceUsed(size),
        m_pMappedAddress(nullptr)
    {
    }

    void FastUploadAllocator::ClearDeferredDestroyedResource()
    {
        m_pDeferredDestroyedResource.reset(nullptr);
    }

    void FastUploadAllocator::Destroy()
    {
        m_pResource.reset(nullptr);
    }

    auto FastUploadAllocator::Allocate(UINT size) -> SubBuffer
    {
        SubBuffer bufferOut = {};
        const UINT alignedSize = Align(size, m_alignmentRequired);
        const ULONG64 totalSize = alignedSize + static_cast<ULONG64>(m_spaceUsed);

        if (totalSize > static_cast<ULONG64>(m_size))
        {
            if (size > m_size)
            {
                assert(size < MAXUINT32);
                m_size = CeilToClosestPowerOfTwo((UINT32)size);
            }

            Realloc();
        }

        bufferOut.m_pResource = m_pResource.get();
        bufferOut.m_pMappedAddress = (byte*)m_pMappedAddress + m_spaceUsed;

        auto offsetFromBase = (byte*)bufferOut.m_pMappedAddress - (byte*)m_pMappedAddress;
        assert(offsetFromBase >= 0 && offsetFromBase <= UINT_MAX);
        bufferOut.m_offsetFromBase = static_cast<UINT>(offsetFromBase);

        m_spaceUsed += alignedSize;

        assert(IsAligned(bufferOut.m_offsetFromBase, m_alignmentRequired));
        return bufferOut;
    }

    void FastUploadAllocator::Realloc()
    {
        if (m_bDeferDestroyDuringRealloc)
        {
            m_pDeferredDestroyedResource = std::move(m_pResource);
        }

        D3D12TranslationLayer::ResourceCreationArgs args = GetCreateUploadBufferArgs(&m_parentDevice.GetDevice(), m_size, m_alignmentRequired);
        m_pResource = D3D12TranslationLayer::Resource::CreateResource(&m_parentDevice.GetContext(), args, D3D12TranslationLayer::ResourceAllocationContext::ImmediateContextThreadTemporary);

        D3D12TranslationLayer::MappedSubresource MappedResult;
        m_parentDevice.GetContext().Map(m_pResource.get(), 0, D3D12TranslationLayer::MAP_TYPE_WRITE_DISCARD, false, nullptr, &MappedResult);
        m_pMappedAddress = MappedResult.pData;
        m_spaceUsed = 0;
    }

};
```

`src/9on12Fence.cpp`:

```cpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#include "pch.h"

namespace D3D9on12
{
    _Check_return_ HRESULT APIENTRY ShareFence(HANDLE hFence, _In_opt_ SECURITY_DESCRIPTOR* pSD, _Out_ HANDLE* phSharedHandle)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Fence* pFence = Fence::GetFenceFromHandle(hFence);
        if (pFence == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        *phSharedHandle = pFence->Share(pSD);
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY WaitForFence(HANDLE hFence, UINT64 NewFenceValue)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Fence* pFence = Fence::GetFenceFromHandle(hFence);
        if (pFence == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        pFence->Wait(NewFenceValue);
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY SignalFence(HANDLE hFence, UINT64 NewFenceValue)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Fence* pFence = Fence::GetFenceFromHandle(hFence);
        if (pFence == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        pFence->Signal(NewFenceValue);
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    void APIENTRY DestroyTrackedFence(HANDLE hFence)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Fence* pFence = Fence::GetFenceFromHandle(hFence);
        if (pFence == nullptr)
        {
            return;
        }
        
        delete pFence;
        CLOSE_TRYCATCH_AND_STORE_HRESULT(S_OK);
    }

    UINT64 APIENTRY GetCompletedFenceValue(HANDLE hFence)
    {
        UINT64 result = 0;
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Fence* pFence = Fence::GetFenceFromHandle(hFence);
        if (pFence != nullptr)
        {
            result = pFence->GetFenceValue();
        }
        CLOSE_TRYCATCH_AND_STORE_HRESULT(S_OK);
        return result;
    }

    Fence::Fence(Device* pDevice, UINT64 InitialValue, UINT Flags)
        : m_pDevice(pDevice)
    {
        D3D12TranslationLayer::FENCE_FLAGS TranslationFlags = D3D12TranslationLayer::FENCE_FLAG_SHARED;
        if (Flags & D3D9ON12USAGE_CROSSADAPTER)
        {
            TranslationFlags |= D3D12TranslationLayer::FENCE_FLAG_SHARED_CROSS_ADAPTER;
        }
        if (Flags & D3D9ON12USAGE_DEFERREDFENCEWAITS)
        {
            TranslationFlags |= D3D12TranslationLayer::FENCE_FLAG_DEFERRED_WAITS;
        }
        if ((Flags & D3D9ON12USAGE_MONITOREDFENCE) == 0)
        {
            TranslationFlags |= D3D12TranslationLayer::FENCE_FLAG_NON_MONITORED;
        }

        m_spUnderlyingFence = std::make_shared<D3D12TranslationLayer::Fence>(&m_pDevice->GetContext(), TranslationFlags, InitialValue);
    }

    Fence::Fence(Device* pDevice, HANDLE hSharedHandle)
        : m_pDevice(pDevice)
    {
        m_spUnderlyingFence = std::make_shared<D3D12TranslationLayer::Fence>(&m_pDevice->GetContext(), hSharedHandle);
    }

    UINT64 Fence::GetFenceValue()
    {
        return m_spUnderlyingFence->GetCompletedValue();
    }


    void Fence::Signal(UINT64 Value)
    {
        m_pDevice->GetContext().Signal(m_spUnderlyingFence.get(), Value);
    }

    void Fence::Wait(UINT64 Value)
    {
        m_pDevice->GetContext().Wait(m_spUnderlyingFence, Value);
    }

    HANDLE Fence::Share(_In_opt_ SECURITY_DESCRIPTOR* pSD)
    {
        DWORD dwAccess = GENERIC_ALL;
        SECURITY_ATTRIBUTES securityAttributes = ConvertSecurityDescriptorToSecurityAttributes(pSD);

        HANDLE hSharedHandle = nullptr;
        ThrowFailure(m_spUnderlyingFence->CreateSharedHandle(&securityAttributes, dwAccess, nullptr, &hSharedHandle));
        return hSharedHandle;
    }

    bool Fence::IsMonitored() const
    {
        return m_spUnderlyingFence->IsMonitored();
    }
}
```

`src/9on12InputAssembly.cpp`:

```cpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#include "pch.h"

namespace D3D9on12
{
    _Check_return_ HRESULT APIENTRY SetStreamSource(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETSTREAMSOURCE *pStreamSourceArg)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pStreamSourceArg == nullptr || pStreamSourceArg->Stream >= MAX_VERTEX_STREAMS)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        Resource *pResource = Resource::GetResourceFromHandle(pStreamSourceArg->hVertexBuffer);
        InputAssembly& ia = pDevice->GetPipelineState().GetInputAssembly();
        HRESULT hr = ia.SetVertexBuffer(*pDevice, pResource, pStreamSourceArg->Stream, pStreamSourceArg->Offset, pStreamSourceArg->Stride);

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr);
    }

    _Check_return_ HRESULT APIENTRY SetStreamSourceUM(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETSTREAMSOURCEUM* pStreamSourceArg, _In_ CONST VOID* pData)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pStreamSourceArg == nullptr || pData == nullptr || pStreamSourceArg->Stream >= MAX_VERTEX_STREAMS)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        InputAssembly& ia = pDevice->GetPipelineState().GetInputAssembly();
        ia.SetVertexBufferUM(*pDevice, pStreamSourceArg->Stream, pStreamSourceArg->Stride, pData);

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY SetIndices(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETINDICES* pSetIndicesArg)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pSetIndicesArg == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        Resource *pResource = Resource::GetResourceFromHandle(pSetIndicesArg->hIndexBuffer);
        HRESULT hr = pDevice->GetPipelineState().GetInputAssembly().SetIndexBuffer(*pDevice, pResource, pSetIndicesArg->Stride);
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr);
    }

    _Check_return_ HRESULT APIENTRY SetIndicesUM(_In_ HANDLE hDevice, _In_ UINT indexBufferStride, _In_ CONST VOID*pIndices)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        HRESULT hr = pDevice->GetPipelineState().GetInputAssembly().SetIndexBufferUM(*pDevice, indexBufferStride, pIndices);
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr);
    }

    InputAssembly::InputAssembly(PipelineStateDirtyFlags& pipelineStateDirtyFlags, RasterStatesWrapper& rasterStates) :
        m_dirtyFlags(pipelineStateDirtyFlags),
        m_rasterStates(rasterStates),
        m_hasTLVertices(false),
        m_numBoundVBs(0),
        m_topology(D3D_PRIMITIVE_TOPOLOGY_UNDEFINED),
        m_pInputLayout(nullptr)
    {
        m_IndexBufferStack.push(InputBuffer());
    };

    void InputBuffer::InitWithUploadData(Device& /*device*/, UINT strideInBytes, CONST VOID* pDataToUpload)
    {
        *this = InputBuffer(); // Initialize defaults
        m_isSystemMemory = (pDataToUpload != nullptr);
        m_pDeferredSystemMemoryData = pDataToUpload;
        m_bufferStride = strideInBytes;
    }

    void InputBuffer::InitWithResource(Device& /*device*/, Resource* pAppResource, UINT64 bufferSize, UINT64 offset, UINT strideInBytes)
    {
        *this = InputBuffer(); // Initialize defaults
        m_sizeInBytes = static_cast<UINT>(bufferSize);
        m_bufferStride = strideInBytes;
        m_bufferOffset = (UINT)offset;
        m_pAppProvidedResource = pAppResource;

        if (pAppResource && pAppResource->IsSystemMemory())
        {
            // System memory resources must be versioned and uploaded before each draw
            m_isSystemMemory = true;
            m_pDeferredSystemMemoryData = pAppResource->GetSystemMemoryBase();
        }
        else
        {
            m_isSystemMemory = false;
        }
    }

    void InputBuffer::InitAsPersistentTriangleFan(Device & device, UINT64 bufferSize, UINT strideInBytes)
    {
        *this = InputBuffer(); // Initialize defaults

        //Check for overflow
        assert(bufferSize <= UINT_MAX);

        D3D12TranslationLayer::ResourceCreationArgs args = GetCreateUploadBufferArgs(&device.GetDevice(), (size_t)bufferSize, 0);
        m_pInternallyProvidedResource.reset(
            D3D12TranslationLayer::Resource::CreateResource(&device.GetContext(), args, D3D12TranslationLayer::ResourceAllocationContext::ImmediateContextThreadLongLived).release(),
            CleanupResourceBindingsAndRelease{});
        m_tempGPUBuffer.m_pResource = m_pInternallyProvidedResource.get();

        D3D12TranslationLayer::MappedSubresource MappedResult;
        device.GetContext().Map(m_tempGPUBuffer.m_pResource, 0, D3D12TranslationLayer::MAP_TYPE_WRITE, false, nullptr, &MappedResult);

        m_tempGPUBuffer.m_pMappedAddress = (byte*)MappedResult.pData;
        m_tempGPUBuffer.m_offsetFromBase = 0;

        m_pDeferredSystemMemoryData = m_tempGPUBuffer.m_pMappedAddress;
        m_isTriangleFanIndexBuffer = true;
        m_isSystemMemory = true;
        m_bufferStride = strideInBytes;
        m_sizeInBytes = (UINT)bufferSize;
        m_bufferOffset = 0;
    }

    D3D12TranslationLayer::Resource * InputBuffer::GetUnderlyingResource() 
    {
        if (m_isSystemMemory)
        {
            // Can be null if this VB is not referenced by the input layout and we choose
            // not to upload
            return m_tempGPUBuffer.m_pResource;
        }
        else if (m_pAppProvidedResource)
        {
            Check9on12(m_pInternallyProvidedResource == nullptr);
            return m_pAppProvidedResource->GetUnderlyingResource();
        }
        else
        {
            Check9on12(m_pInternallyProvidedResource == nullptr &&
                       m_pAppProvidedResource == nullptr &&
                       m_tempGPUBuffer.m_pResource == nullptr);
            return nullptr;
        }
    }

    UINT InputBuffer::GetOffsetInBytesD3D12()
    {         
        if (m_isSystemMemory)
        {
            return static_cast<UINT>(m_tempGPUBuffer.m_offsetFromBase);
        }
        else
        {
            return m_bufferOffset;
        }
    }

    HRESULT InputBuffer::Upload(Device& device, OffsetArg baseVertexIndex, UINT vertexCount)
    {
        Check9on12(m_isTriangleFanIndexBuffer == false);
        Check9on12(m_isSystemMemory);
        
        UINT32 drawOffset = 0;

        switch (baseVertexIndex.m_type)
        {
            case OffsetType::OFFSET_IN_BYTES:
                drawOffset = baseVertexIndex.GetOffsetInBytes();
                break;
            case OffsetType::OFFSET_IN_VERTICES:
                drawOffset = baseVertexIndex.GetOffsetInVertices() * m_bufferStride;
                break;
            case OffsetType::OFFSET_IN_INDICES:
                drawOffset = baseVertexIndex.GetOffsetInIndices() * m_bufferStride;
                break;
            default:
                Check9on12(false);
                break;
        }

        if (drawOffset >= m_sizeInBytes)
        {
            return E_INVALIDARG;
        }


        const UINT32 drawSize = vertexCount * m_bufferStride;

        m_tempGPUBuffer = device.GetSystemMemoryAllocator().Allocate(drawOffset + drawSize);

        UINT32 maxCopySize = m_sizeInBytes - drawOffset;
        memcpy((byte*)m_tempGPUBuffer.m_pMappedAddress + drawOffset, (byte*)GetSystemMemoryBase() + drawOffset, min(drawSize, maxCopySize));

        return S_OK;
    }

    HRESULT InputAssembly::SetIndexBuffer(Device &device, Resource *pResource, UINT stride)
    {
        Resource *pPrevResource = CurrentIndexBuffer().GetAppResource();
        if (pPrevResource != pResource || stride != CurrentIndexBuffer().GetStrideInBytes())
        {
            if (pPrevResource)
            {
                pPrevResource->GetIBBindingTracker().Unbind(0);
            }
            if (pResource)
            {
                pResource->GetIBBindingTracker().Bind(0);
            }

            UINT64 bufferSize = pResource ? pResource->GetDesc().Width : 0;
            CurrentIndexBuffer().InitWithResource(device, pResource, bufferSize, 0, stride);
            m_dirtyFlags.IndexBuffer = true;
        }

        return S_OK;
    }

    HRESULT InputAssembly::SetIndexBufferUM(Device &device, UINT indexBufferStride, CONST VOID*pIndices)
    {
        Resource *pPrevResource = CurrentIndexBuffer().GetAppResource();
        if (pPrevResource)
        {
            pPrevResource->GetIBBindingTracker().Unbind(0);
        }

        CurrentIndexBuffer().InitWithUploadData(device, indexBufferStride, pIndices);
        m_dirtyFlags.IndexBuffer = true;

        return S_OK;
    }

    void InputAssembly::CreateTriangleFanIndexBuffer(_In_ Device &device, _Out_ InputBuffer& targetBuffer, _In_ UINT& indexCount)
    {
        typedef UINT32 TriFanUINT;        
        const TriFanUINT bufferSize = indexCount * sizeof(TriFanUINT);

        targetBuffer.InitAsPersistentTriangleFan(device, bufferSize, sizeof(TriFanUINT));

        // TODO: Using a UINT32 to handle all cases, but if primitive count is smaller, we can use UINT16s as an optimization
        typedef UINT32 TriFanUINT;
        TriFanUINT *pFanIndexBuffer = (TriFanUINT *)targetBuffer.GetTriangleFanMemory();

        for (UINT i = 0; i < indexCount; i += 3)
        {
            pFanIndexBuffer[i + 0] = i / 3 + 1;
            pFanIndexBuffer[i + 1] = i / 3 + 2;
            pFanIndexBuffer[i + 2] = 0;
        }
    }

    void InputAssembly::PushNewIndexBuffer(_In_ InputBuffer& targetBuffer)
    {
        m_IndexBufferStack.push(targetBuffer);
        m_dirtyFlags.IndexBuffer = true;
    }
    
    // The output variable (convertedBuffer) is initialized from scratch using the bufferSize argument(persistent allocation, deleted in resource).    
    void InputAssembly::CreateTriangleListIBFromTriangleFanIB(_In_ Device &device, _In_ CONST void* pTriFanIndexBuffer, _In_ UINT indexBufferStride, _In_ UINT indexOffsetInBytes, _In_ UINT indexCount, _Out_ InputBuffer& convertedBuffer)
    {
        void * pInputBuffer = (void*)(((BYTE*)pTriFanIndexBuffer) + indexOffsetInBytes);

        assert(pInputBuffer != nullptr);

        // TODO: Using a UINT32 to handle all cases, but if primitive count is smaller, we can use UINT16s as an optimization
        typedef UINT32 TriFanUINT;

        const TriFanUINT bufferSize = indexCount * sizeof(TriFanUINT);
        
        convertedBuffer.InitAsPersistentTriangleFan(device, bufferSize, sizeof(TriFanUINT));

        TriFanUINT *pFanIndexBuffer = (TriFanUINT *)convertedBuffer.GetTriangleFanMemory();

        for (UINT i = 0; i < indexCount; i += 3)
        {
            if (indexBufferStride == 2)
            {
                const UINT16 *pIndexBuffer16 = static_cast<const UINT16 *>(pInputBuffer);
                pFanIndexBuffer[i + 0] = static_cast<TriFanUINT>(pIndexBuffer16[i / 3 + 1]);
                pFanIndexBuffer[i + 1] = static_cast<TriFanUINT>(pIndexBuffer16[i / 3 + 2]);
                pFanIndexBuffer[i + 2] = static_cast<TriFanUINT>(pIndexBuffer16[0]);
            }
            else
            {
                Check9on12(indexBufferStride == 4);
                const UINT32 *pIndexBuffer32 = static_cast<const UINT32 *>(pInputBuffer);
                pFanIndexBuffer[i + 0] = static_cast<TriFanUINT>(pIndexBuffer32[i / 3 + 1]);
                pFanIndexBuffer[i + 1] = static_cast<TriFanUINT>(pIndexBuffer32[i / 3 + 2]);
                pFanIndexBuffer[i + 2] = static_cast<TriFanUINT>(pIndexBuffer32[0]);
            }
        }
    }    

    void InputAssembly::RestorePreviousIB(Device& /*device*/)
    {
        m_IndexBufferStack.pop();

        Check9on12(m_IndexBufferStack.size() >= 1);
        m_dirtyFlags.IndexBuffer = true;
    }

    HRESULT InputAssembly::ResolveDeferredState(Device &device, const D3D12_GRAPHICS_PIPELINE_STATE_DESC& /*psoDesc*/, OffsetArg BaseVertexStart, OffsetArg BaseIndexStart)
    {
        // The vb/ib must be re-emitted if we need to bake in the draw's byte offset into the vb/ib due to DrawPrimitive2/DrawPrimitiveIndexed2
        if (BaseVertexStart.m_type == OffsetType::OFFSET_IN_BYTES)
        {
            m_dirtyFlags.VertexBuffers |= BIT(0);
        }

        if (BaseIndexStart.m_type == OffsetType::OFFSET_IN_BYTES)
        {
            m_dirtyFlags.IndexBuffer = true;
        }

        HRESULT hr = S_OK;
        if (m_dirtyFlags.Topology)
        {
            device.GetContext().IaSetTopology(m_topology);
        }
        if (m_dirtyFlags.VertexBuffers)
        {
            ResolveVertexBuffers(device, BaseVertexStart);
        }
        if (m_dirtyFlags.IndexBuffer)
        {
            InputBuffer& ib = CurrentIndexBuffer();
            DXGI_FORMAT ibFormat = ib.GetStrideInBytes() == 0 ? DXGI_FORMAT_UNKNOWN : ConvertStrideToIndexBufferFormat(ib.GetStrideInBytes());


            // To support multithreading we must support the case when the offset passed by argument is in bytes instead of indices. Since Dx12 does not support draw offsets in bytes
            // we add the aditional offset here, and then call draw* with zero offset.
            
            // Please note that if the offset is not expressed in bytes, then aditionalOffset is zero.

            INT aditionalOffset = (BaseIndexStart.m_type == OffsetType::OFFSET_IN_BYTES) ? BaseIndexStart.GetOffsetInBytes() : 0;
            device.GetContext().IaSetIndexBuffer(ib.GetUnderlyingResource(), ibFormat, ib.GetOffsetInBytesD3D12() + aditionalOffset);
        }
        return hr;
    }

    void InputAssembly::SetVertexDeclaration(InputLayout *pInputLayout)
    { 
        if (m_pInputLayout != pInputLayout)
        {
            m_pInputLayout = pInputLayout;
            m_dirtyFlags.InputLayout = true;
            if (pInputLayout)
            {
                if (m_hasTLVertices != pInputLayout->VerticesArePreTransformed())
                {
                    m_hasTLVertices = pInputLayout->VerticesArePreTransformed();
                    m_dirtyFlags.VertexShader = true;
                }
            }

        }
    }

    void InputAssembly::ResolveVertexBuffers(Device& device, OffsetArg BaseVertexStart)
    {
        D3D12TranslationLayer::Resource * vbs[MAX_VERTEX_STREAMS] = {};
        UINT offsets[MAX_VERTEX_STREAMS] = {};
        UINT strides[MAX_VERTEX_STREAMS] = {};
        
        // To support multithreading we must support the case when the offset passed by argument is in bytes instead of vertices. Since Dx12 does not support draw offsets in bytes
        // we add the aditional offset here, and then call draw* with zero offset.
        // ie. The functions DrawIndexedPrimitive2 and DrawPrimitive2 have its offset argument expressed in bytes and it only applies to the stream# 0.
        // This means that in order to support that behaviour when we receive the offset in bytes, we'll assume that it only applies to the first stream
        // and all the other streams have zero aditional offset.

        // Please note that if the offset is not expressed in bytes, then aditionalOffset is zero and the following code is equivalent to a simple loop over the streams.

        INT aditionalOffset = (BaseVertexStart.m_type == OffsetType::OFFSET_IN_BYTES) ? BaseVertexStart.GetOffsetInBytes() : 0;
        
        size_t vbIndex = 0;
        
        vbs[vbIndex] = m_inputStreams[vbIndex].GetUnderlyingResource();
        strides[vbIndex] = m_inputStreams[vbIndex].GetStrideInBytes();
        offsets[vbIndex] = m_inputStreams[vbIndex].GetOffsetInBytesD3D12() + aditionalOffset;

        for (vbIndex = 1; vbIndex < MAX_VERTEX_STREAMS; vbIndex++)
        {
            vbs[vbIndex] = m_inputStreams[vbIndex].GetUnderlyingResource();
            strides[vbIndex] = m_inputStreams[vbIndex].GetStrideInBytes();
            offsets[vbIndex] = m_inputStreams[vbIndex].GetOffsetInBytesD3D12();
        }

        if (m_numBoundVBs == 0)
        {
            // clear out all streams
            m_numBoundVBs = MAX_VERTEX_STREAMS;
        }

        device.GetContext().IaSetVertexBuffers(0, m_numBoundVBs, vbs, strides, offsets);
    }

    bool InputAssembly::InputBufferNeedsUpload(UINT streamIndex)
    {
        Check9on12(streamIndex < MAX_VERTEX_STREAMS);
        return m_inputStreams[streamIndex].IsSystemMemory() && (m_pInputLayout->GetStreamMask() & BIT(streamIndex)) != 0;
    }

    void InputBuffer::ResetUploadedData()
    {
        if (IsSystemMemory())
        {
            m_tempGPUBuffer = {};
        }
    }


    void InputAssembly::ResetUploadBufferData()
    {
        for (UINT index = 0; index < MAX_VERTEX_STREAMS; index++)
        {
            m_inputStreams[index].ResetUploadedData();
        }
        CurrentIndexBuffer().ResetUploadedData();
    }


    HRESULT InputAssembly::UploadDeferredInputBufferData(Device& device, OffsetArg baseVertexIndex, UINT vertexCount, OffsetArg baseIndexLocation, UINT indexCount)
    {
        HRESULT hr = S_OK;

        auto& inputStream = m_inputStreams[0];

        if (InputBufferNeedsUpload(0))
        {
            hr = inputStream.Upload(device, baseVertexIndex, vertexCount);

            m_dirtyFlags.VertexBuffers |= BIT(0);
        }
        
        // If the offset was set in bytes, it only referenced the stream number zero. We can assume the other streams have zero offset.
        const OffsetArg zeroOffset = OffsetArg::AsOffsetInBytes(0);
        const OffsetArg &realOffset = (baseVertexIndex.m_type == OffsetType::OFFSET_IN_BYTES) ? zeroOffset : baseVertexIndex;

        if (SUCCEEDED(hr))
        {
            for (UINT index = 1; index < MAX_VERTEX_STREAMS; index++)
            {
                if (InputBufferNeedsUpload(index))
                {
                    hr = m_inputStreams[index].Upload(device, realOffset, vertexCount);

                    m_dirtyFlags.VertexBuffers |= BIT(index);
                }

                if (FAILED(hr))
                {
                    break;
                }

                index++;
            }
        }

        if (SUCCEEDED(hr) && indexCount > 0)
        {
            auto& currentIB = CurrentIndexBuffer();

            if (currentIB.IsSystemMemory())
            {
                // Triangle fans are uploaded on creation
                if (currentIB.IsTriangleFan() == false)
                {
                    hr = currentIB.Upload(device, baseIndexLocation, indexCount);
                }

                m_dirtyFlags.IndexBuffer = true;
            }
        }
        
        CHECK_HR(hr);
        return hr;
    }

    void InputAssembly::SetPrimitiveTopology(Device &device, D3DPRIMITIVETYPE primitiveType)
    {
        D3D12_PRIMITIVE_TOPOLOGY newTopology = ConvertToD3D12Topology(primitiveType);

        RasterizerStateID& rasterizerStateID = device.GetPipelineState().GetPixelStage().GetRasterizerStateID();

        const UINT uiTriangleMode = (primitiveType >= D3DPT_TRIANGLELIST) ? 1 : 0;
        if (rasterizerStateID.TriangleMode != uiTriangleMode)
        {
            // Update rasterizer state ID
            rasterizerStateID.TriangleMode = uiTriangleMode;
            m_dirtyFlags.RasterizerState = 1;
        }

        if (m_topology != newTopology)
        {
            m_topology = newTopology;
            device.GetPipelineState().CurrentPSODesc().PrimitiveTopologyType = ConvertToD3D12TopologyType(m_topology);
            device.GetContext().IaSetTopology(m_topology);
        }
        m_rasterStates.SetPrimitiveType(primitiveType);
    }

    void InputAssembly::SetVertexBufferUM(Device& device, UINT vbSlot, UINT stride, _In_ CONST VOID* pData)
    {
        Resource* pPrevResource = m_inputStreams[vbSlot].GetAppResource();
        if (pPrevResource)
        {
            pPrevResource->GetVBBindingTracker().Unbind(vbSlot);
        }

        m_inputStreams[vbSlot].InitWithUploadData(device, stride, pData);

        m_numBoundVBs = max(m_numBoundVBs, vbSlot + 1);

        m_dirtyFlags.VertexBuffers = true;
    }

    HRESULT InputAssembly::SetVertexBuffer(Device &device, Resource *pResource, UINT vbSlot, UINT offset, UINT stride)
    {
        HRESULT hr = S_OK;
        const UINT64 bufferSize = pResource ? pResource->GetDesc().Width : 0;

        InputBuffer &inputBuffer = m_inputStreams[vbSlot];
        Resource* pPrevResource = m_inputStreams[vbSlot].GetAppResource();
        if (pPrevResource != pResource || m_inputStreams[vbSlot].GetStrideInBytes() != stride || inputBuffer.GetOffsetInBytesAPI() != offset)
        {
            if (pPrevResource)
            {
                pPrevResource->GetVBBindingTracker().Unbind(vbSlot);
            }

            if (pResource)
            {
                pResource->GetVBBindingTracker().Bind(vbSlot);
                m_numBoundVBs = max(m_numBoundVBs, vbSlot + 1);
            }
            // If they're unbinding this VB
            else
            {
                // If they're removing the last VB, 
                if (m_numBoundVBs - 1 == vbSlot)
                {
                    do
                    {
                        m_numBoundVBs--;

                    } while (m_numBoundVBs > 0 && m_inputStreams[m_numBoundVBs - 1].GetUnderlyingResource() == nullptr);
                }
            }

            m_inputStreams[vbSlot].InitWithResource(device, pResource, bufferSize, offset, stride);
            m_dirtyFlags.VertexBuffers = true;
        }

        CHECK_HR(hr);
        return hr;
    }
};
```

`src/9on12InputLayout.cpp`:

```cpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#include "pch.h"

namespace D3D9on12
{
    _Check_return_ HRESULT APIENTRY CreateVertexShaderDecl(
        _In_ HANDLE hDevice,
        _Inout_ D3DDDIARG_CREATEVERTEXSHADERDECL*pCreateVertexShaderDeclArg,
        _In_ CONST D3DDDIVERTEXELEMENT* pVertexElements)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pCreateVertexShaderDeclArg == nullptr)
        {
            return E_INVALIDARG;
        }

        if (pCreateVertexShaderDeclArg->NumVertexElements > 0 && pVertexElements == nullptr)
        {
            return E_INVALIDARG;
        }

        HRESULT hr = S_OK;
        InputLayout *pInputLayout = new InputLayout(*pDevice);
        if (pInputLayout == nullptr)
        {
            return E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hr))
        {
            hr = pInputLayout->Init(pVertexElements, pCreateVertexShaderDeclArg->NumVertexElements);
        }

        if (SUCCEEDED(hr))
        {
            pCreateVertexShaderDeclArg->ShaderHandle = InputLayout::GetHandleFromInputLayout(pInputLayout);
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr);
    }

    _Check_return_ HRESULT APIENTRY DeleteVertexShaderDecl(_In_ HANDLE hDevice, _In_ HANDLE hShader)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        InputLayout *pInputLayout = InputLayout::GetInputLayoutFromHandle(hShader);

        if (pDevice == nullptr || pInputLayout == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        delete(pInputLayout);

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY SetStreamSourceFreq(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETSTREAMSOURCEFREQ *pStreamSourceFreqArg)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pStreamSourceFreqArg == nullptr || pStreamSourceFreqArg->Stream >= MAX_VERTEX_STREAMS)
        {
            return E_INVALIDARG;
        }

        pDevice->SetStreamFrequency(pStreamSourceFreqArg->Stream, pStreamSourceFreqArg->Divider);
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY SetVertexShaderDecl(_In_ HANDLE hDevice, _In_ HANDLE hInputLayout)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        InputLayout *pInputLayout = InputLayout::GetInputLayoutFromHandle(hInputLayout);
        if (pDevice == nullptr)
        {
            return E_INVALIDARG;
        }

        pDevice->GetPipelineState().GetInputAssembly().SetVertexDeclaration(pInputLayout);

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    InputLayout::InputLayout(Device &device) :
        m_hasPreTransformedVertices(false),
        m_hasPerVertexPointSize(false),
        m_hash(0),
        m_numVertexElements(0),
        m_streamMask(0),
        m_vsInputDecls(MAXD3DDECLLENGTH),
        m_device(device)
    {
        memset(m_pVertexElements, 0, sizeof(m_pVertexElements));
    }

    InputLayout::~InputLayout()
    {
        auto &InputAssembly = m_device.GetPipelineState().GetInputAssembly();
        if (&InputAssembly.GetInputLayout() == this)
        {
            InputAssembly.SetVertexDeclaration(nullptr);
        }
    }

    HRESULT InputLayout::Init(_In_ CONST D3DDDIVERTEXELEMENT* pVertexElements, UINT numElements)
    {
        Check9on12(numElements < MAX_INPUT_ELEMENTS);
        m_numVertexElements = numElements;

        for (UINT i = 0; i < numElements; i++)
        {
            UINT isTransformedPosition = 0;
            m_pVertexElements[i] = pVertexElements[i];

            if (m_pVertexElements[i].Usage == D3DDECLUSAGE_POSITIONT && m_pVertexElements[i].UsageIndex == 0)
            {
                m_pVertexElements[i].Usage = D3DDECLUSAGE_POSITION;
                m_hasPreTransformedVertices = true;
                isTransformedPosition = 1;
            }
            if (m_pVertexElements[i].Usage == D3DDECLUSAGE_PSIZE)
            {
                m_hasPerVertexPointSize = true;
            }

            UINT conversions = [](D3DDECLTYPE type)
            {
                switch (type)
                {
                case D3DDECLTYPE_UDEC3:
                    return ShaderConv::VSInputDecl::UDEC3;
                case D3DDECLTYPE_DEC3N:
                    return ShaderConv::VSInputDecl::DEC3N;
                default:
                    return IsIntType(type) ?
                        ShaderConv::VSInputDecl::NeedsIntToFloatConversion :
                        ShaderConv::VSInputDecl::None;
                }
            }((D3DDECLTYPE)m_pVertexElements[i].Type);
            m_vsInputDecls.AddDecl(m_pVertexElements[i].Usage, m_pVertexElements[i].UsageIndex, i, isTransformedPosition, conversions);

            m_streamMask |= BIT(m_pVertexElements[i].Stream);
        }

        GetHash();
        return S_OK;
    }


    WeakHash InputLayout::GetHash()
    {
        if (m_hash.Initialized() == false)
        {
            if (m_numVertexElements != 0)
            {
                m_hash = HashData(m_pVertexElements, m_numVertexElements * sizeof(m_pVertexElements[0]), m_hash);
                m_hash = HashData(&m_vsInputDecls[0], sizeof(m_vsInputDecls[0]) * m_vsInputDecls.GetSize(), m_hash);
            }
            else
            {
                m_hash = WeakHash::GetHashForEmptyObject();
            }
        }

        return m_hash;
    }
};
```

`src/9on12PipelineState.cpp`:

```cpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#include "pch.h"

namespace D3D9on12
{
    _Check_return_ HRESULT APIENTRY SetRenderState(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_RENDERSTATE* pRenderStateArg)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pRenderStateArg == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        pDevice->GetPipelineState().SetRenderState(*pDevice, (DWORD)pRenderStateArg->State, (DWORD)pRenderStateArg->Value);

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY SetTextureStageState(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_TEXTURESTAGESTATE* pTextureStageState)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pTextureStageState == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        PipelineState& pipelineState = pDevice->GetPipelineState();
        DWORD dwStage = (DWORD)pTextureStageState->Stage;
        DWORD dwState = (DWORD)pTextureStageState->State;
        DWORD dwValue = (DWORD)pTextureStageState->Value;

        // Resolve sampler stage
        dwStage = MapSamplerStage9on12(dwStage);

        if (dwStage >= MAX_SAMPLERS_STAGES || dwState >= MAX_D3DTSS)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        if (D3DTSS_ADDRESS == dwState)
        {
            pipelineState.SetTextureStageState(dwStage, D3DDDITSS_ADDRESSU, dwValue);
            pipelineState.SetTextureStageState(dwStage, D3DDDITSS_ADDRESSV, dwValue);
        }
        else
        {
            pipelineState.SetTextureStageState(dwStage, dwState, dwValue);
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    void PipelineState::SetRenderState(Device& device, DWORD dwState, DWORD dwValue)
    {
        //TODO: early out for redundant state sets

        // Set the render state value  
        m_dwRenderStates[dwState] = dwValue;
        switch (dwState)
        {
            // Rasterizer states  
        case D3DRS_FILLMODE:
        case D3DRS_CULLMODE:
        case D3DRS_DEPTHBIAS:
        case D3DRS_SLOPESCALEDEPTHBIAS:
        case D3DRS_MULTISAMPLEANTIALIAS:
        case D3DRS_ANTIALIASEDLINEENABLE:
        case D3DRS_CLIPPING:
            m_pixelStage.SetRasterState(dwState, dwValue);
            break;
            // DepthStencil states  
        case D3DRS_ZENABLE:
        case D3DRS_ZWRITEENABLE:
        case D3DRS_ZFUNC:
        case D3DRS_STENCILENABLE:
        case D3DRS_STENCILFAIL:
        case D3DRS_STENCILZFAIL:
        case D3DRS_STENCILPASS:
        case D3DRS_STENCILFUNC:
        case D3DRS_STENCILREF:
        case D3DRS_STENCILMASK:
        case D3DRS_STENCILWRITEMASK:
        case D3DRS_TWOSIDEDSTENCILMODE:
        case D3DRS_CCW_STENCILFAIL:
        case D3DRS_CCW_STENCILZFAIL:
        case D3DRS_CCW_STENCILPASS:
        case D3DRS_CCW_STENCILFUNC:
            m_pixelStage.SetDepthStencilState(device, dwState, dwValue);
            break;
            // Blend states  
        case D3DRS_ALPHABLENDENABLE:
        case D3DRS_SRCBLEND:
        case D3DRS_DESTBLEND:
        case D3DRS_BLENDOP:
        case D3DRS_BLENDFACTOR:
        case D3DRS_SEPARATEALPHABLENDENABLE:
        case D3DRS_SRCBLENDALPHA:
        case D3DRS_DESTBLENDALPHA:
        case D3DRS_BLENDOPALPHA:
        case D3DRS_COLORWRITEENABLE:
        case D3DRS_COLORWRITEENABLE1:
        case D3DRS_COLORWRITEENABLE2:
        case D3DRS_COLORWRITEENABLE3:
            m_pixelStage.SetBlendState(device, dwState, dwValue);
            break;
        case D3DRS_MULTISAMPLEMASK:
            m_pixelStage.SetMultiSampleMask(dwValue);
            m_dirtyFlags.BlendState = true;
            break;
        case D3DRS_ALPHATESTENABLE:
        case D3DRS_ALPHAFUNC:
        case D3DRS_ALPHAREF:
        case D3DRS_FOGENABLE:
        case D3DRS_FOGCOLOR:
        case D3DRS_FOGTABLEMODE:
        case D3DRS_FOGSTART:
        case D3DRS_FOGEND:
        case D3DRS_FOGDENSITY:
        case D3DRS_SHADEMODE:
            m_pixelStage.SetPSExtensionState(dwState, dwValue);
            break;
        case D3DRS_WRAP0:
        case D3DRS_WRAP1:
        case D3DRS_WRAP2:
        case D3DRS_WRAP3:
        case D3DRS_WRAP4:
        case D3DRS_WRAP5:
        case D3DRS_WRAP6:
        case D3DRS_WRAP7:
            m_rasterStates.SetPSSamplerTexCoordWrap(dwState - D3DRS_WRAP0 + 0, static_cast<BYTE>(dwValue));
            break;
        case D3DRS_WRAP8:
        case D3DRS_WRAP9:
        case D3DRS_WRAP10:
        case D3DRS_WRAP11:
        case D3DRS_WRAP12:
        case D3DRS_WRAP13:
        case D3DRS_WRAP14:
        case D3DRS_WRAP15:
            m_rasterStates.SetPSSamplerTexCoordWrap(dwState - D3DRS_WRAP8 + 8, static_cast<BYTE>(dwValue));
            break;
        case D3DRS_POINTSIZE:
            if (dwValue == RESZ_CODE)
            {
                auto pSRVZero = m_pixelStage.GetSRV(0);
                auto pDSV = m_pixelStage.GetDepthStencil();
                if (pSRVZero && pDSV &&
                    pSRVZero->GetLogicalDesc().Format == pDSV->GetLogicalDesc().Format)
                {
                    if (pDSV->GetLogicalDesc().SampleDesc.Count > 1)
                    {
                        device.GetContext().ResourceResolveSubresource(
                            pSRVZero->GetUnderlyingResource(), 0,
                            pDSV->GetUnderlyingResource(), 0,
                            pSRVZero->GetLogicalDesc().Format);
                    }
                    else
                    {
                        device.GetContext().ResourceCopyRegion(
                            pSRVZero->GetUnderlyingResource(), 0, 0, 0, 0,
                            pDSV->GetUnderlyingResource(), 0, nullptr);
                    }
                }
                break;
            }
            else if (dwValue == D3DFMT_A2M1 || dwValue == D3DFMT_A2M0)
            {
                //Special values for Alpha To Coverage
                m_pixelStage.SetBlendState( device, dwState, dwValue );
            }
            // Fallthrough
        case D3DRS_POINTSIZE_MIN:
        case D3DRS_POINTSIZE_MAX:
            m_vertexStage.SetPointSize(dwState, dwValue);
            break;
        case D3DRS_POINTSPRITEENABLE:
            m_rasterStates.SetPointSpriteEnable(dwValue != FALSE);
            break;
        case D3DRS_CLIPPLANEENABLE:
            m_rasterStates.SetUserClipplanes(dwValue);
            break;
        case D3DRS_SRGBWRITEENABLE:
            m_pixelStage.SetSRGBWriteEnable(dwValue > 0);
            break;
        case D3DRS_SCISSORTESTENABLE:
            m_vertexStage.SetScissorTestEnabled(device, dwValue > 0);
            break;
        case D3DRS_ADAPTIVETESS_Y:
            m_pixelStage.SetBlendState( device, dwState, dwValue );
            break;
            //  
            // map legacy modes with one-to-one mappings to texture stage 0  
            //  
        case D3DRENDERSTATE_TEXTUREMAPBLEND:
            if (RegistryConstants::g_cBreakOnMissingDDI)
            {
                Check9on12(false);
            }
#if 0
            this->MapLegacyTextureBlend(dwValue); // Map legacy texture blend modes  
#endif
            break;
        case D3DRENDERSTATE_TEXTUREADDRESS:
            this->SetTextureStageState(0, D3DTSS_ADDRESSU, dwValue);
            this->SetTextureStageState(0, D3DTSS_ADDRESSV, dwValue);
            break;
        case D3DRENDERSTATE_TEXTUREADDRESSU:
            this->SetTextureStageState(0, D3DTSS_ADDRESSU, dwValue);
            break;
        case D3DRENDERSTATE_TEXTUREADDRESSV:
            this->SetTextureStageState(0, D3DTSS_ADDRESSV, dwValue);
            break;
        case D3DRENDERSTATE_MIPMAPLODBIAS:
            this->SetTextureStageState(0, D3DTSS_MIPMAPLODBIAS, dwValue);
            break;
        case D3DRENDERSTATE_BORDERCOLOR:
            this->SetTextureStageState(0, D3DTSS_BORDERCOLOR, dwValue);
            break;
        case D3DRENDERSTATE_ANISOTROPY:
            this->SetTextureStageState(0, D3DTSS_MAXANISOTROPY, dwValue);
            break;
        case D3DRENDERSTATE_TEXTUREMAG:
        case D3DRENDERSTATE_TEXTUREMIN:
            if (RegistryConstants::g_cBreakOnMissingDDI)
            {
                Check9on12(false);
            }
#if 0
            this->MapLegacyTextureFilter(dwState, dwValue);
#endif
            break;
        case D3DRENDERSTATE_TEXTUREHANDLE:
            this->SetTextureStageState(0, D3DTSS_TEXTUREMAP, dwValue);
            break;
        case D3DRENDERSTATE_WRAPU:
            this->SetRenderState(device, D3DRENDERSTATE_WRAP0, (m_dwRenderStates[D3DRENDERSTATE_WRAP0] & ~D3DWRAP_U) | (dwValue ? D3DWRAP_U : 0));
            break;
        case D3DRENDERSTATE_WRAPV:
            this->SetRenderState(device, D3DRENDERSTATE_WRAP0, (m_dwRenderStates[D3DRENDERSTATE_WRAP0] & ~D3DWRAP_V) | (dwValue ? D3DWRAP_V : 0));
            break;
        case D3DRENDERSTATE_COLORKEYENABLE:
            m_rasterStates.SetColorKeyEnable(dwValue != FALSE);
            Check9on12(dwValue == FALSE);
            break;
        case D3DRENDERSTATE_COLORKEYBLENDENABLE:
            m_rasterStates.SetColorKeyBlendEnable(dwValue != FALSE);
            break;
        case D3DRENDERSTATE_SCENECAPTURE:
            break;
        }
    }

    void PipelineState::SetTextureStageState(DWORD dwStage, DWORD dwState, DWORD dwValue)
    {
        // Set the texture stage state
        if (dwStage >= _countof(m_dwTextureStageStates))
        {
            Check9on12(false);
            return;
        }
        if (dwState >= _countof(m_dwTextureStageStates[dwStage]))
        {
            Check9on12(false);
            return;
        }
        if (dwStage >= MAX_SAMPLERS_STAGES)
        {
            Check9on12(false);
            return;
        }

        if (dwStage == DMAP_SAMPLER)
        {
            // DMAP_SAMPLER should be handled by the FF converter, the runtime still calls 
            // functions to modify this sampler on device creation, but we can safely ignore it
            return;
        }

        // check for integer bitfield overflow causing issues with some apps submitting invalid
        // sampler state values. (handling for ADDRESSU/V/W and MAXANISOTROPY is in the switch 
        // statements below with appropriate defaulting)
        if ((dwState == D3DTSS_MAGFILTER && dwValue >= 16u) ||
            (dwState == D3DTSS_MINFILTER && dwValue >= 16u) ||
            (dwState == D3DTSS_MIPFILTER && dwValue >= 16u))
        {
            Check9on12(false);
            return;
        }

        m_dwTextureStageStates[dwStage][dwState] = dwValue;

        SamplerStateID& samplerID = m_pixelStage.GetSamplerID(dwStage);

        const UINT dirtyMask = BIT(dwStage);

        switch (dwState)
        {
        case D3DTSS_SRGBTEXTURE:
            m_pixelStage.SetSRGBTexture(dwStage, dwValue > 0);
            break;

        case D3DTSS_MAGFILTER:
            samplerID.MagFilter = dwValue;
            m_dirtyFlags.Samplers |= dirtyMask;
            break;

        case D3DTSS_MINFILTER:
            samplerID.MinFilter = dwValue;
            m_dirtyFlags.Samplers |= dirtyMask;
            break;

        case D3DTSS_MIPFILTER:
            // We disable mips using SRV fields, re-emit the SRV if this setting changes
            if (samplerID.MipFilter == D3DDDITEXF_NONE || dwValue == D3DDDITEXF_NONE)
            {
                m_dirtyFlags.Textures |= dirtyMask;
            }

            samplerID.MipFilter = dwValue;
            m_dirtyFlags.Samplers |= dirtyMask;
            break;

        case D3DTSS_ADDRESSU:
            if (dwValue > D3DTADDRESS_MIRRORONCE)
            {
                // some apps pass bad data here that results in device removed. Assume the default value.
                dwValue = D3DTADDRESS_WRAP;
            }
            samplerID.AddressU = dwValue;
            m_dirtyFlags.Samplers |= dirtyMask;
            break;

        case D3DTSS_ADDRESSV:
            if (dwValue > D3DTADDRESS_MIRRORONCE)
            {
                // some apps pass bad data here that results in device removed. Assume the default value.
                dwValue = D3DTADDRESS_WRAP;
            }
            samplerID.AddressV = dwValue;
            m_dirtyFlags.Samplers |= dirtyMask;
            break;

        case D3DTSS_ADDRESSW:
            if (dwValue > D3DTADDRESS_MIRRORONCE)
            {
                // some apps pass bad data here that results in device removed. Assume the default value.
                dwValue = D3DTADDRESS_WRAP;
            }
            samplerID.AddressW = dwValue;
            m_dirtyFlags.Samplers |= dirtyMask;
            break;

        case D3DTSS_MAXANISOTROPY:
            if (dwValue > cD3D9Caps.MaxAnisotropy)
            {
                // some apps pass bad data here that results in device removed. Assume default value
                dwValue = 1;
            }
            samplerID.MaxAnisotropy = dwValue;
            m_dirtyFlags.Samplers |= dirtyMask;
            break;

        case D3DTSS_BORDERCOLOR:
            samplerID.BorderColor = dwValue;
            m_dirtyFlags.Samplers |= dirtyMask;
            break;

        case D3DTSS_MIPMAPLODBIAS:
            samplerID.MipLODBias = *(FLOAT*)(&dwValue);
            // Some apps pass garbage floating points
            if (isnan(samplerID.MipLODBias))
            {
                samplerID.MipLODBias = 0;
                m_dwTextureStageStates[dwStage][dwState] = *(DWORD*)(&samplerID.MipLODBias);
            }
            m_dirtyFlags.Samplers |= dirtyMask;
            break;

        case D3DTSS_MAXMIPLEVEL:
            samplerID.MaxMipLevel = dwValue;
            m_dirtyFlags.Samplers |= dirtyMask;
            break;

        case D3DDDITSS_TEXTURECOLORKEYVAL:
            m_dirtyFlags.PSExtension3 = 1;
            break;
        }

        if (dwStage < D3DHAL_TSS_MAXSTAGES)
        {
            switch (dwState)
            {
            case D3DTSS_TEXCOORDINDEX:
                m_rasterStates.ClearTCIMappingFlags(0xf << (dwStage * 4));
                m_rasterStates.SetTCIMappingFlags((dwValue & 0xf) << (dwStage * 4));
                break;

            case D3DTSS_BUMPENVMAT00:
            case D3DTSS_BUMPENVMAT01:
            case D3DTSS_BUMPENVMAT10:
            case D3DTSS_BUMPENVMAT11:
            case D3DTSS_BUMPENVLSCALE:
            case D3DTSS_BUMPENVLOFFSET:
                m_pixelStage.SetPSExtension2State(dwStage, dwState, dwValue);
                break;
            case D3DTSS_TEXTURETRANSFORMFLAGS:
                if (dwValue & D3DTTFF_PROJECTED)
                {
                    m_rasterStates.SetProjectedTCsMask(dirtyMask);
                }
                else
                {
                    m_rasterStates.ClearProjectedTCsMask(dirtyMask);
                }
                break;

            case D3DDDITSS_DISABLETEXTURECOLORKEY:
                if (dwValue)
                {
                    m_rasterStates.SetColorKeyTSSDisable(dirtyMask);
                }
                else
                {
                    m_rasterStates.ClearColorKeyTSSDisable(dirtyMask);
                }
                break;
            }
        }
    }

    PipelineState::PipelineState(Device& device) :
        m_rasterStates(m_dirtyFlags),
        m_inputAssembly(m_dirtyFlags, m_rasterStates),
        m_vertexStage(device, m_dirtyFlags, m_rasterStates),
        m_pixelStage(m_dirtyFlags, m_rasterStates),
        m_bNeedsPipelineState(false),
        m_intzRestoreZWrite(false)
    {
        memset(&m_PSODesc, 0, sizeof(m_PSODesc));

        // Set all the PSO desc fields that should never change
        m_PSODesc.IBStripCutValue = D3D12_INDEX_BUFFER_STRIP_CUT_VALUE_DISABLED;
        m_PSODesc.NodeMask = 0;
        m_PSODesc.Flags = D3D12_PIPELINE_STATE_FLAG_NONE;

    }

    HRESULT PipelineState::Init(Device& device)
    {
        HRESULT hr = S_OK;
        hr = m_pixelStage.Init(device);
        
        CHECK_HR(hr);
        return hr;
    }

    HRESULT PipelineState::ResolveDeferredState(Device &device, OffsetArg BaseVertexStart, OffsetArg BaseIndexStart)
    {
        HRESULT hr = S_OK;
        if (!m_bNeedsPipelineState) return S_OK;

        hr = m_inputAssembly.ResolveDeferredState(device, m_PSODesc, BaseVertexStart, BaseIndexStart);
        CHECK_HR(hr);

        if (SUCCEEDED(hr))
        {
            hr = m_vertexStage.ResolveDeferredState(device, m_PSODesc);
            CHECK_HR(hr);
        }

        // PS must come after VS since it may need to be recompiled based on the VS output
        UINT textureDirtyMaskToKeep = 0;
        if (SUCCEEDED(hr))
        {
            hr = m_pixelStage.ResolveDeferredState(device, m_PSODesc, textureDirtyMaskToKeep);
            CHECK_HR(hr);
        }

        if (m_dirtyFlags.IsPSOChangeRequired())
        {
            D3D12TranslationLayer::PipelineState * pPipelineState = device.GetPipelineStateCache().GetPipelineState(m_PSODesc,
                GetVertexStage().GetCurrentD3D12VertexShader(),
                GetPixelStage().GetCurrentD3D12PixelShader(),
                GetVertexStage().GetCurrentD3D12GeometryShader());

            if (pPipelineState)
            {
                device.GetContext().SetPipelineState(pPipelineState);
            }
        }

        m_dirtyFlags.Clear();

        // If this draw call was made with byte offsetting, we bake this offset in to the bounded VB/IB.
        // We must clean this up for draws that won't expect this additional offset in the VB/IB
        
        if (BaseVertexStart.m_type == OffsetType::OFFSET_IN_BYTES)            
        {
            m_dirtyFlags.VertexBuffers |= BIT(0);
        }

        if (BaseIndexStart.m_type == OffsetType::OFFSET_IN_BYTES)
        {
            m_dirtyFlags.IndexBuffer = true;
        }

        m_dirtyFlags.Textures |= textureDirtyMaskToKeep;

        device.GetConstantsManager().BindShaderConstants();
        CHECK_HR(hr);

        return hr;
    }
};

```

`src/9on12PipelineStateCache.cpp`:

```cpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#include "pch.h"

namespace D3D9on12
{
    void VerifyPipelineState(const D3D12TranslationLayer::GRAPHICS_PIPELINE_STATE_DESC &desc)
    {
        if (desc.RasterizerState.ForcedSampleCount > 0)
        {
            Check9on12(desc.DSVFormat == DXGI_FORMAT_UNKNOWN);
        }
    }

    D3D12TranslationLayer::PipelineState * PipelineStateCache::GetPipelineState(D3D12_GRAPHICS_PIPELINE_STATE_DESC &psoDesc, D3D12VertexShader* pVS, D3D12PixelShader* pPS, D3D12GeometryShader* pGS)
    {
        Trim();

        PipelineStateKey key(psoDesc, pVS, pPS, pGS);

        UINT64 timestamp = m_device.GetContext().GetCommandListID(D3D12TranslationLayer::COMMAND_LIST_TYPE::GRAPHICS);

        auto it = m_cache.m_map.find(key);

        if (it != m_cache.m_map.end())
        {
            std::shared_ptr<PipelineStateCacheEntry>& cacheEntry = it->second;
            assert(cacheEntry.get() == cacheEntry->m_accessOrderPos->get());
            m_cache.m_accessOrder.splice(m_cache.m_accessOrder.begin(), m_cache.m_accessOrder, cacheEntry->m_accessOrderPos);
            cacheEntry->m_accessOrderPos = m_cache.m_accessOrder.begin();
            cacheEntry->m_timestamp = timestamp;
            return cacheEntry->m_pPipelineState.get();
        }

        std::shared_ptr<PipelineStateCacheEntry> cacheEntry = std::make_shared<PipelineStateCacheEntry>(key);
        m_cache.m_accessOrder.emplace_front(cacheEntry);
        cacheEntry->m_accessOrderPos = m_cache.m_accessOrder.begin();
        cacheEntry->m_timestamp = timestamp;

        m_cache.m_map[key] = cacheEntry;
        assert(m_cache.m_map.size() == m_cache.m_accessOrder.size());

        D3D12TranslationLayer::GRAPHICS_PIPELINE_STATE_DESC desc = {};
        desc.pVertexShader = pVS->GetUnderlying();
        desc.pGeometryShader = (pGS) ? pGS->GetUnderlying() : nullptr;
        desc.pPixelShader = pPS->GetUnderlying();
        desc.BlendState = psoDesc.BlendState;
        desc.SampleMask = psoDesc.SampleMask;
        desc.RasterizerState = psoDesc.RasterizerState;
        desc.DepthStencilState = psoDesc.DepthStencilState;
        desc.InputLayout = psoDesc.InputLayout;
        desc.IBStripCutValue = psoDesc.IBStripCutValue;
        desc.PrimitiveTopologyType = psoDesc.PrimitiveTopologyType;
        desc.NumRenderTargets = psoDesc.NumRenderTargets;
        desc.DSVFormat = psoDesc.DSVFormat;
        desc.SampleDesc = psoDesc.SampleDesc;
        desc.NodeMask = psoDesc.NodeMask;
        memcpy(desc.RTVFormats, psoDesc.RTVFormats, sizeof(DXGI_FORMAT) * desc.NumRenderTargets);

        VerifyPipelineState(desc);

        // No cached PSO exists, time to create one
        cacheEntry->m_pPipelineState.reset(new D3D12TranslationLayer::PipelineState(&m_device.GetContext(), desc)); // throw( bad_alloc, _com_error )

        Check9on12(pPS->GetD3D9ParentShader());
        Check9on12(pVS->GetD3D9ParentShader());
        AddUses(*pPS->GetD3D9ParentShader(), *pVS->GetD3D9ParentShader(), key);

        return cacheEntry->m_pPipelineState.get();
    }

    void PipelineStateCache::AddUses(Shader &ps, Shader &vs, PipelineStateKey key)
    {
        vs.AddPSO(key);
        ps.AddPSO(key);
    }

    void PipelineStateCache::Trim()
    {
        DWORD psoCacheTrimLimitSize = min(RegistryConstants::g_cPSOCacheTrimLimitSize, g_AppCompatInfo.PSOCacheTrimLimitSize);

        if (psoCacheTrimLimitSize == MAXDWORD)
            return;

        DWORD psoCacheTrimLimitAge = min(RegistryConstants::g_cPSOCacheTrimLimitAge, g_AppCompatInfo.PSOCacheTrimLimitAge);

        if (psoCacheTrimLimitAge == MAXDWORD)
            return;

        UINT64 timestamp = m_device.GetContext().GetCommandListID(D3D12TranslationLayer::COMMAND_LIST_TYPE::GRAPHICS);

        while (m_cache.m_map.size() > (size_t)psoCacheTrimLimitSize)
        {
            if (m_cache.m_accessOrder.empty())
                break;

            UINT64 age = timestamp - m_cache.m_accessOrder.back()->m_timestamp;

            if (age > (UINT64)psoCacheTrimLimitAge)
            {
                std::shared_ptr<PipelineStateCacheEntry> cacheEntry = m_cache.m_accessOrder.back();
                m_cache.m_accessOrder.pop_back();

                cacheEntry->m_key.m_desc.m_pPS->GetD3D9ParentShader()->RemovePSO(cacheEntry->m_key);
                cacheEntry->m_key.m_desc.m_pVS->GetD3D9ParentShader()->RemovePSO(cacheEntry->m_key);
                m_cache.m_map.erase(cacheEntry->m_key);
            }
            else
            {
                break;
            }
        }
    }

    UINT8 PipelineStateKey::D3D9on12PipelineStateDesc::CompressedData::CompressDepthFormat(DXGI_FORMAT format)
    {
        switch (format)
        {
        case DXGI_FORMAT_UNKNOWN:
            return 0;
        case DXGI_FORMAT_D32_FLOAT_S8X24_UINT:
            return 1;
        case DXGI_FORMAT_D32_FLOAT:
            return 2;
        case DXGI_FORMAT_D24_UNORM_S8_UINT:
            return 3;
        case DXGI_FORMAT_D16_UNORM:
            return 4;
        }

        Check9on12(false);
        return 0;
    }

    UINT8 PipelineStateKey::D3D9on12PipelineStateDesc::CompressedData::CompressRenderTargetFormat(DXGI_FORMAT format)
    {
        switch (format)
        {
        case DXGI_FORMAT_UNKNOWN :
            return 0;
        case DXGI_FORMAT_B8G8R8A8_UNORM:
            return 1;
        case DXGI_FORMAT_R8G8B8A8_UNORM:
            return 2;
        case DXGI_FORMAT_B5G5R5A1_UNORM:
            return 3;
        case DXGI_FORMAT_B4G4R4A4_UNORM:
            return 4;
        case DXGI_FORMAT_R16G16B16A16_UNORM:
            return 5;
        case DXGI_FORMAT_R16G16B16A16_FLOAT:
            return 6;
        case DXGI_FORMAT_R16G16_UNORM:
            return 7;
        case DXGI_FORMAT_R16G16_FLOAT:
            return 8;
        case DXGI_FORMAT_R10G10B10A2_UNORM:
            return 9;
        case DXGI_FORMAT_R16_FLOAT:
            return 10;
        case DXGI_FORMAT_R32_FLOAT:
            return 11;
        case DXGI_FORMAT_R32G32_FLOAT:
            return 12;
        case DXGI_FORMAT_R32G32B32A32_FLOAT:
            return 13;
        case DXGI_FORMAT_R8G8_SNORM:
            return 14;
        case DXGI_FORMAT_R8G8B8A8_SNORM:
            return 15;
        case DXGI_FORMAT_R16G16_SNORM:
            return 16;
        case DXGI_FORMAT_R16G16B16A16_SNORM:
            return 17;
        case DXGI_FORMAT_R8_UNORM:
            return 18;
        case DXGI_FORMAT_R16_UNORM:
            return 19;
        case DXGI_FORMAT_A8_UNORM:
            return 20;
        case DXGI_FORMAT_R8G8_UNORM:
            return 21;
        case DXGI_FORMAT_B8G8R8X8_UNORM:
            return 22;
        case DXGI_FORMAT_B8G8R8X8_UNORM_SRGB:
            return 23;
        case DXGI_FORMAT_B5G6R5_UNORM:
            return 24;
        case DXGI_FORMAT_B8G8R8A8_UNORM_SRGB:
            return 25;
        }

        Check9on12(false);
        return 0;
    }

    PipelineStateKey::D3D9on12PipelineStateDesc::CompressedData::CompressedData(D3D12_GRAPHICS_PIPELINE_STATE_DESC& desc)
    {
        memset(this, 0, sizeof(*this));
         
        Check9on12(desc.SampleDesc.Count <= std::pow(2.0, (double)m_SampleCountBits)); 
        Check9on12(desc.SampleDesc.Quality <= std::pow(2.0, (double)m_SampleCountBits));
        Check9on12(desc.RasterizerState.ForcedSampleCount <= std::pow(2.0, (double)m_SampleCountBits));

        //Note: the subtraction from some variables is due to the fact that their enums start a 1 not 0..
        PrimitiveTopologyType   = desc.PrimitiveTopologyType;
        NumRenderTargets        = desc.NumRenderTargets;
        RenderTargetFormat0     = CompressRenderTargetFormat(desc.RTVFormats[0]);
        RenderTargetFormat1     = CompressRenderTargetFormat(desc.RTVFormats[1]);
        RenderTargetFormat2     = CompressRenderTargetFormat(desc.RTVFormats[2]);
        RenderTargetFormat3     = CompressRenderTargetFormat(desc.RTVFormats[3]);
        DepthStencilFormat      = CompressDepthFormat(desc.DSVFormat);
        SampleCount             = desc.SampleDesc.Count;
        SampleQuality           = desc.SampleDesc.Quality;
        FillMode                = (desc.RasterizerState.FillMode - D3D12_FILL_MODE_WIREFRAME);
        CullMode                = (desc.RasterizerState.CullMode - D3D12_CULL_MODE_NONE);
        FrontCounterClockwise   = desc.RasterizerState.FrontCounterClockwise;
        DepthClipEnable         = desc.RasterizerState.DepthClipEnable;
        MultisampleEnable       = desc.RasterizerState.MultisampleEnable;
        AntialiasedLineEnable   = desc.RasterizerState.AntialiasedLineEnable;
        ForcedSampleCount       = desc.RasterizerState.ForcedSampleCount;
        DepthEnable             = desc.DepthStencilState.DepthEnable;
        DepthWriteMask          = desc.DepthStencilState.DepthWriteMask;
        DepthFunc               = (desc.DepthStencilState.DepthFunc - D3D12_COMPARISON_FUNC_NEVER);
        StencilEnable           = desc.DepthStencilState.StencilEnable;
        FrontStencilFailOp      = desc.DepthStencilState.FrontFace.StencilFailOp - D3D12_STENCIL_OP_KEEP;
        FrontStencilDepthFailOp = desc.DepthStencilState.FrontFace.StencilDepthFailOp - D3D12_STENCIL_OP_KEEP;
        FrontStencilPassOp      = desc.DepthStencilState.FrontFace.StencilPassOp - D3D12_STENCIL_OP_KEEP;
        FrontStencilFunc        = desc.DepthStencilState.FrontFace.StencilFunc - D3D12_COMPARISON_FUNC_NEVER;
        BackStencilFailOp       = desc.DepthStencilState.BackFace.StencilFailOp - D3D12_STENCIL_OP_KEEP;
        BackStencilDepthFailOp  = desc.DepthStencilState.BackFace.StencilDepthFailOp - D3D12_STENCIL_OP_KEEP;
        BackStencilPassOp       = desc.DepthStencilState.BackFace.StencilPassOp - D3D12_STENCIL_OP_KEEP;
        BackStencilFunc         = desc.DepthStencilState.BackFace.StencilFunc - D3D12_COMPARISON_FUNC_NEVER;

#define InitBlendDesc(index) \
        BlendDescBlendEnable##index             = desc.BlendState.RenderTarget[index].BlendEnable; \
        BlendDescLogicOpEnable##index           = desc.BlendState.RenderTarget[index].LogicOpEnable; \
        BlendDescSrcBlend##index                = desc.BlendState.RenderTarget[index].SrcBlend - D3D12_BLEND_ZERO; \
        BlendDescDestBlend##index               = desc.BlendState.RenderTarget[index].DestBlend - D3D12_BLEND_ZERO; \
        BlendDescBlendOp##index                 = desc.BlendState.RenderTarget[index].BlendOp - D3D12_BLEND_OP_ADD; \
        BlendDescSrcBlendAlpha##index           = desc.BlendState.RenderTarget[index].SrcBlendAlpha - D3D12_BLEND_ZERO; \
        BlendDescDestBlendAlpha##index          = desc.BlendState.RenderTarget[index].DestBlendAlpha - D3D12_BLEND_ZERO; \
        BlendDescBlendOpAlpha##index            = desc.BlendState.RenderTarget[index].BlendOpAlpha - D3D12_BLEND_OP_ADD; \
        BlendDescLogicOp##index                 = desc.BlendState.RenderTarget[index].LogicOp; \
        BlendDescRenderTargetWriteMask##index   = desc.BlendState.RenderTarget[index].RenderTargetWriteMask;

        InitBlendDesc(0);
        InitBlendDesc(1);
        InitBlendDesc(2);
        InitBlendDesc(3);

    }

};
```

`src/9on12PixelStage.cpp`:

```cpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#include "pch.h"

namespace D3D9on12
{
    _Check_return_ HRESULT APIENTRY UpdateWindowInfo(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_WINFO* pWInfo)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pWInfo == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        pDevice->GetPipelineState().GetPixelStage().UpdateWInfo(*pWInfo);

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY SetPixelShader(_In_ HANDLE hDevice, _In_ HANDLE hShader)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        PixelShader* pShader = (PixelShader*)Shader::GetShaderFromHandle(hShader);

        if (pShader)
        {
            pDevice->GetPipelineState().GetPixelStage().SetPixelShader(pShader);
        }
        else
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY SetRenderTarget(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETRENDERTARGET* pSetRenderTargetArg)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);

        if (pDevice == nullptr || pSetRenderTargetArg == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        Resource *pResource = Resource::GetResourceFromHandle(pSetRenderTargetArg->hRenderTarget);

        const UINT subresource = pResource ? pResource->ConvertAppSubresourceToDX12Subresource(pSetRenderTargetArg->SubResourceIndex) : 0;

        pDevice->GetPipelineState().GetPixelStage().SetRenderTarget(pSetRenderTargetArg->RenderTargetIndex, BoundRenderTarget(pResource, subresource));
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY SetDepthStencil(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETDEPTHSTENCIL* pSetDepthStencilArg)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);

        if (pDevice == nullptr || pSetDepthStencilArg == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        Resource *pResource = Resource::GetResourceFromHandle(pSetDepthStencilArg->hZBuffer);
        pDevice->GetPipelineState().GetPixelStage().SetDepthStencil(pResource);
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    HRESULT PixelStage::SetSRV(Device& device, Resource* pResource, UINT dx9TextureIndex)
    {
        UNREFERENCED_PARAMETER(device);

        DWORD shaderRegister;
        D3D12TranslationLayer::EShaderStage shaderType;
        ConvertDX9TextureIndexToShaderStageAndRegisterIndex(dx9TextureIndex, shaderType, shaderRegister);

        HRESULT hr = S_OK;
        if (pResource)
        {
            const bool bResourceUsesHardwareShadowMapping = pResource->IsEligibleForHardwareShadowMapping();
            if (bResourceUsesHardwareShadowMapping && pResource->GetLogicalDesc().MipLevels > 1)
            {
                // 9on12 can't handle hardware shadow map cases where a Depth Buffer with multiple mips is passed in.
                // This is because hardware shadow mapping requires the sample_c command. However the sample_c command 
                // does not allow for the shader to specify an explicit LOD to read from if the shader uses the TEXLDL 
                // DXBC instruction
                ThrowFailure(E_FAIL);
            }

            if ((bool)m_samplerStateIDs[dx9TextureIndex].UseHardwareShadowMapping != bResourceUsesHardwareShadowMapping)
            {
                // The app is binding a special depth resource as a Texture this means that they will probably want to use
                // 'Hardware Shadow Mapping'. this means that we will need to edit the shader code so that it changes samples
                // of this texture to 'SampleCmp'
                m_rasterStates.SetHardwareShadowMappingFlag(shaderType, shaderRegister, bResourceUsesHardwareShadowMapping);
                m_samplerStateIDs[dx9TextureIndex].UseHardwareShadowMapping = bResourceUsesHardwareShadowMapping;

                m_dirtyFlags.Samplers |= BIT(dx9TextureIndex);
            }

            if ((bool)m_samplerStateIDs[dx9TextureIndex].SwapRBBorderColors != pResource->NeedsSwapRBOutputChannels())
            {
                m_samplerStateIDs[dx9TextureIndex].SwapRBBorderColors = pResource->NeedsSwapRBOutputChannels();
                m_dirtyFlags.Samplers |= BIT(dx9TextureIndex);
            }

            if (pResource->IsSystemMemory())
            {
                SYSTEM_MEMORY_RESOURCE_BOUND_AS_SHADER_RESOURCE_WARNING();
                pResource = pResource->GetBackingPlainResource();
            }

            hr = pResource->PreBind();
        }

        if(m_shaderResources[dx9TextureIndex] != pResource)
        {
            if (m_shaderResources[dx9TextureIndex])
            {
                m_shaderResources[dx9TextureIndex]->GetSRVBindingTracker().Unbind(dx9TextureIndex);
            }
            if (pResource)
            {
                pResource->GetSRVBindingTracker().Bind(dx9TextureIndex);
            }

            m_shaderResources[dx9TextureIndex] = pResource;
            // If a null resource is bound, arbitrarily call it a texture2D. We can't go with TEXTURETYPE_UNKNOWN
            // because the shader converter needs a valid texture type for the shader declaration even if the resource is null
            const ShaderConv::TEXTURETYPE srvTextureType = pResource ? pResource->GetShaderResourceTextureType() : ShaderConv::TEXTURETYPE_2D;
            if (shaderType == D3D12TranslationLayer::e_PS)
            {
                m_rasterStates.SetPSSamplerTextureType(shaderRegister, srvTextureType);
            }
            m_dirtyFlags.Textures |= BIT(dx9TextureIndex);
        }

        return hr;
    }

    void PixelStage::SetSRGBTexture(UINT index, bool srgbEnabled)
    {
        if (m_SRGBTexture[index] != srgbEnabled)
        {
            m_SRGBTexture[index] = srgbEnabled;
            m_dirtyFlags.Textures |= BIT(index);
        }
    }

    void PixelStage::SetSRGBWriteEnable(bool srgbEnabled)
    {
        if (m_SRGBWriteEnabled != srgbEnabled)
        {
            m_SRGBWriteEnabled = srgbEnabled;
            m_dirtyFlags.RenderTargets = true;
        }
    }

    PixelStage::PixelStage(PipelineStateDirtyFlags& pipelineStateDirtyFlags, RasterStatesWrapper& rasterStates) :
        m_dirtyFlags(pipelineStateDirtyFlags),
        m_rasterStates(rasterStates),
        m_pCurrentPS(nullptr),
        m_pCurrentD3D12PixelShader(nullptr),
        m_blendFactor(0),
        m_multiSampleMask(MAXUINT),
        m_SRGBWriteEnabled(false),
        m_dsvRWType(D3D12_DSV_FLAG_NONE),
        m_numBoundRenderTargets(0),
        m_rtSetMask(0),
        m_pDepthStencil(nullptr),
        m_hideDepthStencil(false)
    {
        memset(m_pRenderTargets, 0, sizeof(m_pRenderTargets));
        memset(m_shaderResources, 0, sizeof(m_shaderResources));
        memset(m_SRGBTexture, 0, sizeof(m_SRGBTexture));
        for (auto &componentMapping : m_rtvShaderComponentMapping)
        {
            componentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
        }
    }

    HRESULT PixelStage::Init(Device& /*device*/)
    {
        SetRasterState(D3DRS_CLIPPING, 1); //d3d9 defaults this raster state to 1
        return S_OK;
    }

    void PixelStage::MarkSRVIndicesDirty(const std::vector<UINT> &indices)
    {
        for (UINT index : indices)
        {
            m_dirtyFlags.Textures |= BIT(index);
        }
    }


    void PixelStage::SetDepthStencil(Resource *pDepthStencil)
    { 
        const bool oldDepthStencilIsNull = m_pDepthStencil == nullptr;
        const bool newDepthStencilIsNull = pDepthStencil == nullptr;
        // Depth stencil state sets DepthEnable based on whether a depth stencil is valid or 
        // not, so update it if the DSV is changing to or from a null DSV
        if (oldDepthStencilIsNull != newDepthStencilIsNull)
        {
            m_dirtyFlags.DepthStencilState = true;
        }

        if (m_pDepthStencil != pDepthStencil)
        {
            // If binding a depth stencil that's already bound as an SRV, we need to make sure
            // we mark the SRV dirty flag so that appropriate logic is done later to determine if
            // we should hide the SRV binding (simultaneous DSV & SRV bindings are allowed in DX9 
            // but restricted in DX12 to only when depth write is off). We also need to do the same
            // if we're unbinding a depth stencil that may have caused an SRV to be hidden.
            if (m_pDepthStencil)
            {
                m_pDepthStencil->GetDSVBindingTracker().Unbind(0);
                MarkSRVIndicesDirty(m_pDepthStencil->GetSRVBindingTracker().GetBindingIndices());
            }

            if (pDepthStencil)
            {
                pDepthStencil->GetDSVBindingTracker().Bind(0);
                MarkSRVIndicesDirty(pDepthStencil->GetSRVBindingTracker().GetBindingIndices());
            }

            m_pDepthStencil = pDepthStencil;
            m_dirtyFlags.DepthStencil = true;
            m_dirtyFlags.RenderTargets = true;
        }
    }

    void PixelStage::UpdateWInfo(_In_ CONST D3DDDIARG_WINFO& winInfo)
    {
        m_rasterStates.SetWFogEnable(
            ((1.0f != winInfo.WNear) || (1.0f != winInfo.WFar)) ? 1 : 0);

        m_dirtyFlags.RasterizerState = true;
    }

    void PixelStage::SetPixelShader(PixelShader* pShader)
    {
        if (m_pCurrentPS != pShader)
        {
            m_pCurrentPS = pShader;
            m_dirtyFlags.PixelShader = true;
        }
    }

    void PixelStage::SetRenderTarget(UINT renderTargetIndex, BoundRenderTarget boundRenderTarget)
    {
        (boundRenderTarget.m_pResource == nullptr) ? m_rtSetMask &= ~BIT(renderTargetIndex) :
            m_rtSetMask |= BIT(renderTargetIndex);

        Resource *pPrevResource = m_pRenderTargets[renderTargetIndex].m_pResource;
        Resource *pNewResource = boundRenderTarget.m_pResource;

        if (pPrevResource != pNewResource)
        {
            // DX9 allows Render Targets and SRVs to be bound simultaneously as long as the app
            // doesn't read from the SRV. RTV/SRV simultaneous binding is not allowed in 12 
            // and so we need to mark the SRV dirty flags when this happens so that we can 
            // later choose to "hide" the SRV bindings in this case
            if (pPrevResource)
            {
                pPrevResource->GetRTVBindingTracker().Unbind(renderTargetIndex);
                MarkSRVIndicesDirty(pPrevResource->GetSRVBindingTracker().GetBindingIndices());
            }

            if (pNewResource)
            {
                pNewResource->GetRTVBindingTracker().Bind(renderTargetIndex);
                MarkSRVIndicesDirty(pNewResource->GetSRVBindingTracker().GetBindingIndices());

                bool bDisableAlpha = pNewResource->IsAlphaChannelDisabled();
                UINT rtvShaderComponentMapping = ConvertFormatToShaderResourceViewComponentMapping(pNewResource->GetD3DFormat());
                if (m_rtvShaderComponentMapping[renderTargetIndex] != rtvShaderComponentMapping)
                {
                    m_rtvShaderComponentMapping[renderTargetIndex] = rtvShaderComponentMapping;
                    m_dirtyFlags.BlendState = true;
                }

                if (bDisableAlpha != m_alphaDisabledMask[renderTargetIndex])
                {
                    m_alphaDisabledMask[renderTargetIndex] = bDisableAlpha;
                    m_dirtyFlags.BlendState = true;
                }

                m_rasterStates.SetSwapRBOutputChannelsFlag(renderTargetIndex, pNewResource->NeedsSwapRBOutputChannels());
            }
        }

        m_pRenderTargets[renderTargetIndex] = boundRenderTarget;

        m_numBoundRenderTargets = 0;
        if (m_rtSetMask)
        {
            BitScanReverse(&m_numBoundRenderTargets, m_rtSetMask);
            m_numBoundRenderTargets += 1; // + 1 because of zero index
        }

        m_dirtyFlags.RenderTargets = true;
    }

    void PixelStage::SetRasterState(DWORD dwState, DWORD dwValue)
    {
        switch (dwState)
        {
            // Rasterizer states  
        case D3DRS_FILLMODE:
            if (dwValue < 1 || dwValue > 3) dwValue = D3DFILL_SOLID;
            m_rasterStates.SetFillMode(static_cast<D3DFILLMODE>(dwValue));
            m_rasterizerStateID.FillMode = dwValue;
            m_dirtyFlags.RasterizerState = true;
            break;
        case D3DRS_CULLMODE:
            if (dwValue < 1 || dwValue > 3) dwValue = D3DCULL_NONE;
            m_rasterizerStateID.CullMode = dwValue;
            m_dirtyFlags.RasterizerState = true;
            break;
        case D3DRS_DEPTHBIAS:
            m_rasterizerStateID.DepthBias = *(FLOAT*)(&dwValue);
            m_dirtyFlags.RasterizerState = true;
            break;
        case D3DRS_SLOPESCALEDEPTHBIAS:
            m_rasterizerStateID.SlopeScaleDepthBias = *(FLOAT*)(&dwValue);
            m_dirtyFlags.RasterizerState = true;
            break;
        case D3DRS_MULTISAMPLEANTIALIAS:
            if (dwValue >= 2u) dwValue = TRUE;
            m_rasterizerStateID.MultiSampleAntiAlias = dwValue;
            m_dirtyFlags.RasterizerState = true;
            break;
        case D3DRS_ANTIALIASEDLINEENABLE:
            if (dwValue >= 2u) dwValue = TRUE;
            m_rasterizerStateID.AntialiasedLineEnable = dwValue;
            m_dirtyFlags.RasterizerState = true;
            break;
        case D3DRS_CLIPPING:
            if (dwValue >= 2u) dwValue = TRUE;
            m_rasterizerStateID.DepthClipEnable = dwValue;
            m_dirtyFlags.RasterizerState = true;
            break;
        default:
            Check9on12(false);
        }
    }

    void PixelStage::SetDepthStencilState(Device& device, DWORD dwState, DWORD dwValue)
    {
        auto& context = device.GetContext();

        switch (dwState)
        {
            // DepthStencil states  
        case D3DRS_ZENABLE:
            m_depthStencilStateID.ZEnable = dwValue;
            m_dirtyFlags.DepthStencilState = true;
            m_dirtyFlags.RasterizerState = true;
            break;
        case D3DRS_ZWRITEENABLE:
        {
            m_depthStencilStateID.ZWriteEnable = dwValue;
            D3D12_DSV_FLAGS oldState = m_dsvRWType;
            if (m_depthStencilStateID.ZWriteEnable)
            {
                m_dsvRWType &= ~D3D12_DSV_FLAG_READ_ONLY_DEPTH;
            }
            else
            {
                m_dsvRWType |= D3D12_DSV_FLAG_READ_ONLY_DEPTH;
            }
            if (m_dsvRWType != oldState)
            {
                m_dirtyFlags.RenderTargets = true;

                // Hide or unhide the SRVs of the current depth stencil as appropriate
                if (m_pDepthStencil)
                {
                    MarkSRVIndicesDirty(m_pDepthStencil->GetSRVBindingTracker().GetBindingIndices());
                }
            }

            m_dirtyFlags.DepthStencilState = true;
            break;
        }
        case D3DRS_ZFUNC:
            m_depthStencilStateID.ZFunc = (dwValue - 1);
            m_dirtyFlags.DepthStencilState = true;
            break;
        case D3DRS_STENCILENABLE:
            m_depthStencilStateID.StencilEnable = dwValue;
            m_dirtyFlags.DepthStencilState = true;
            break;
        case D3DRS_STENCILFAIL:
            m_depthStencilStateID.StencilFail = (dwValue - 1);
            m_dirtyFlags.DepthStencilState = true;
            break;
        case D3DRS_STENCILZFAIL:
            m_depthStencilStateID.StencilZFail = (dwValue - 1);
            m_dirtyFlags.DepthStencilState = true;
            break;
        case D3DRS_STENCILPASS:
            m_depthStencilStateID.StencilPass = (dwValue - 1);
            m_dirtyFlags.DepthStencilState = true;
            break;
        case D3DRS_STENCILFUNC:
            m_depthStencilStateID.StencilFunc = (dwValue - 1);
            m_dirtyFlags.DepthStencilState = true;
            break;
        case D3DRS_STENCILREF:
            m_depthStencilStateID.StencilRef = static_cast<UINT8>(dwValue);
            m_dirtyFlags.DepthStencilState = true;
            context.OMSetStencilRef(m_depthStencilStateID.StencilRef);
            break;
        case D3DRS_STENCILMASK:
            m_depthStencilStateID.StencilMask = static_cast<UINT8>(dwValue);
            m_dirtyFlags.DepthStencilState = true;
            break;
        case D3DRS_STENCILWRITEMASK:
            {
                m_depthStencilStateID.StencilWriteMask = static_cast<UINT8>(dwValue);
                D3D12_DSV_FLAGS oldState = m_dsvRWType;
                if (m_depthStencilStateID.StencilWriteMask == 0)
                {
                    m_dsvRWType |= D3D12_DSV_FLAG_READ_ONLY_STENCIL;
                }
                else
                {
                    m_dsvRWType &= ~D3D12_DSV_FLAG_READ_ONLY_STENCIL;
                }
                if (m_dsvRWType != oldState)
                {
                    m_dirtyFlags.RenderTargets = true;
                }
                m_dirtyFlags.DepthStencilState = true;
                break;
            }
        case D3DRS_TWOSIDEDSTENCILMODE:
            m_depthStencilStateID.TwoSidedStencil = dwValue;
            m_dirtyFlags.DepthStencilState = true;
            break;
        case D3DRS_CCW_STENCILFAIL:
            m_depthStencilStateID.CCWStencilFail = (dwValue - 1);
            m_dirtyFlags.DepthStencilState = true;
            break;
        case D3DRS_CCW_STENCILZFAIL:
            m_depthStencilStateID.CCWStencilZFail = (dwValue - 1);
            m_dirtyFlags.DepthStencilState = true;
            break;
        case D3DRS_CCW_STENCILPASS:
            m_depthStencilStateID.CCWStencilPass = (dwValue - 1);
            m_dirtyFlags.DepthStencilState = true;
            break;
        case D3DRS_CCW_STENCILFUNC:
            m_depthStencilStateID.CCWStencilFunc = (dwValue - 1);
            m_dirtyFlags.DepthStencilState = true;
            break;
        default:
            Check9on12(false);
        }
    }

    void PixelStage::SetBlendState(Device& device, DWORD dwState, DWORD dwValue)
    {
        auto& context = device.GetContext();

        switch (dwState)
        {
            // Blend states  
        case D3DRS_ALPHABLENDENABLE:
            if (dwValue >= 2) dwValue = TRUE;
            m_blendStateID.AlphaBlendEnable = dwValue;
            m_dirtyFlags.BlendState = true;
            break;
        case D3DRS_SRCBLEND:
            if (dwValue >= 32) dwValue = D3DBLEND_ONE;
            m_blendStateID.SrcBlend = dwValue;
            m_dirtyFlags.BlendState = true;
            break;
        case D3DRS_DESTBLEND:
            if (dwValue >= 32) dwValue = D3DBLEND_ZERO;
            m_blendStateID.DstBlend = dwValue;
            m_dirtyFlags.BlendState = true;
            break;
        case D3DRS_BLENDOP:
            if (dwValue >= 8) dwValue = D3DBLENDOP_ADD;
            m_blendStateID.BlendOp = dwValue;
            m_dirtyFlags.BlendState = true;
            break;
        case D3DRS_BLENDFACTOR:
            m_blendFactor = dwValue;
            m_dirtyFlags.BlendState = true;
            {
                DirectX::XMFLOAT4 factor = ARGBToUNORMFloat(m_blendFactor);
                context.OMSetBlendFactor((float*)&factor);
            }
            break;
        case D3DRS_SEPARATEALPHABLENDENABLE:
            if (dwValue >= 2) dwValue = TRUE;
            m_blendStateID.SeparateAlphaBlend = dwValue;
            m_dirtyFlags.BlendState = true;
            break;
        case D3DRS_SRCBLENDALPHA:
            if (dwValue >= 32) dwValue = D3DBLEND_ONE;
            m_blendStateID.SrcBlendAlpha = dwValue;
            m_dirtyFlags.BlendState = true;
            break;
        case D3DRS_DESTBLENDALPHA:
            if (dwValue >= 32) dwValue = D3DBLEND_ZERO;
            m_blendStateID.DstBlendAlpha = dwValue;
            m_dirtyFlags.BlendState = true;
            break;
        case D3DRS_BLENDOPALPHA:
            assert(dwValue <= D3DBLENDOP_MAX);
            // Assuming the app is asking for "default" behavior
            if (dwValue == 0 || dwValue > D3DBLENDOP_MAX)
            {
                dwValue = D3DBLENDOP_ADD;
            }

            m_blendStateID.BlendOpAlpha = dwValue;
            m_dirtyFlags.BlendState = true;
            break;
        case D3DRS_COLORWRITEENABLE:
            m_blendStateID.ColorWriteMask0 = static_cast<BYTE>(dwValue);
            m_dirtyFlags.BlendState = true;
            break;
        case D3DRS_COLORWRITEENABLE1:
            m_blendStateID.ColorWriteMask1 = static_cast<BYTE>(dwValue);
            m_dirtyFlags.BlendState = true;
            break;
        case D3DRS_COLORWRITEENABLE2:
            m_blendStateID.ColorWriteMask2 = static_cast<BYTE>(dwValue);
            m_dirtyFlags.BlendState = true;
            break;
        case D3DRS_COLORWRITEENABLE3:
            m_blendStateID.ColorWriteMask3 = static_cast<BYTE>(dwValue);
            m_dirtyFlags.BlendState = true;
            break;
            //Special flags for Alpha To Coverage
        case D3DRS_POINTSIZE:
            if (dwValue == D3DFMT_A2M0)
            {
                SetAlphaToCoverageEnabled( false );
            }
            else if (dwValue == D3DFMT_A2M1)
            {
                SetAlphaToCoverageEnabled( true );
            }
            break;
        case D3DRS_ADAPTIVETESS_Y:
            if (dwValue == 0)
            {
                SetAlphaToCoverageEnabled( false );
            }
            else if (dwValue == D3DFMT_ATOC)
            {
                SetAlphaToCoverageEnabled( true );
            }
            break;
        default:
            Check9on12(false);
        }
    }

    void PixelStage::SetPSExtensionState(DWORD dwState, DWORD dwValue)
    {
        switch (dwState)
        {
        case D3DRS_ALPHATESTENABLE:
            m_rasterStates.SetAlphaTestEnable(dwValue != FALSE);
            break;
        case D3DRS_ALPHAFUNC:
            m_rasterStates.SetAlphaFunc(static_cast<D3DCMPFUNC>(dwValue));
            break;
        case D3DRS_ALPHAREF:
            m_PSExtension.fAlphaRef = ConvertToFloat(dwValue);
            m_dirtyFlags.PSExtension = true;
            break;
        case D3DRS_FOGENABLE:
            m_rasterStates.SetFogEnable(dwValue != FALSE);
            break;
        case D3DRS_FOGCOLOR:
            ConvertToRGB(dwValue, m_PSExtension.vFogColor);
            m_dirtyFlags.PSExtension = true;
            break;
        case D3DRS_FOGTABLEMODE:
            m_rasterStates.SetFogTableMode(dwValue);
            m_dirtyFlags.PSExtension = true; // Needed to compute m_PSExtension.fFogDistInv  
            break;
        case D3DRS_FOGSTART:
            m_PSExtension.fFogStart = *(FLOAT*)(&dwValue);
            AssertFloatNotInfOrNan(m_PSExtension.fFogStart);
            m_dirtyFlags.PSExtension = true;
            break;
        case D3DRS_FOGEND:
            m_PSExtension.fFogEnd = *(FLOAT*)(&dwValue);
            AssertFloatNotInfOrNan(m_PSExtension.fFogEnd);
            m_dirtyFlags.PSExtension = true;
            break;
        case D3DRS_FOGDENSITY:
            m_PSExtension.fFogDensity = *(FLOAT*)(&dwValue);
            AssertFloatNotInfOrNan(m_PSExtension.fFogDensity);
            m_dirtyFlags.PSExtension = true;
            break;
        case D3DRS_SHADEMODE:
            m_rasterStates.SetShadeMode(static_cast<D3DSHADEMODE>(dwValue));
            break;
        default:
            Check9on12(false);
        }
    }

    void PixelStage::SetPSExtension2State(DWORD dwStage, DWORD dwState, DWORD dwValue)
    {
        switch (dwState)
        {
        case D3DTSS_BUMPENVMAT00:
        case D3DTSS_BUMPENVMAT01:
        case D3DTSS_BUMPENVMAT10:
        case D3DTSS_BUMPENVMAT11:
            m_PSExtension2.vBumpEnvMat[dwStage][dwState - D3DTSS_BUMPENVMAT00] = *(FLOAT*)(&dwValue);
            AssertFloatNotInfOrNan(m_PSExtension2.vBumpEnvMat[dwStage][dwState - D3DTSS_BUMPENVMAT00]);
            m_dirtyFlags.PSExtension2 = 1;
            break;

        case D3DTSS_BUMPENVLSCALE:
        case D3DTSS_BUMPENVLOFFSET:
            m_PSExtension2.vBumpEnvL[dwStage][dwState - D3DTSS_BUMPENVLSCALE] = *(FLOAT*)(&dwValue);
            AssertFloatNotInfOrNan(m_PSExtension2.vBumpEnvL[dwStage][dwState - D3DTSS_BUMPENVLSCALE]);
            m_dirtyFlags.PSExtension2 = 1;
            break;
        default:
            Check9on12(false);
        }
    }

    void PixelStage::SetPreTransformedVertexMode(bool drawingPretransformedVerts)
    {
        if (static_cast<UINT>(drawingPretransformedVerts) != m_rasterizerStateID.DrawingPreTransformedVertices)
        {
            m_rasterizerStateID.DrawingPreTransformedVertices = drawingPretransformedVerts;
            m_dirtyFlags.RasterizerState = true;
        }
    }

    void PixelStage::ResolveRenderTargets(Device &device, D3D12_GRAPHICS_PIPELINE_STATE_DESC& psoDesc, bool bDSVBound)
    {
        psoDesc.NumRenderTargets = m_numBoundRenderTargets;

        D3D12TranslationLayer::RTV* ppRTVs[D3D12_SIMULTANEOUS_RENDER_TARGET_COUNT] = {};
        D3D12TranslationLayer::DSV* pDSV = nullptr;

        if (bDSVBound)
        {
            pDSV = m_pDepthStencil->GetDepthStencilView(m_dsvRWType);
            Check9on12(pDSV != nullptr);
        }

        Check9on12(psoDesc.NumRenderTargets <= D3D12_SIMULTANEOUS_RENDER_TARGET_COUNT);
        for (UINT i = 0; i < psoDesc.NumRenderTargets && i < D3D12_SIMULTANEOUS_RENDER_TARGET_COUNT; i++)
        {
            if (m_pRenderTargets[i].m_pResource)
            {
                ppRTVs[i] = m_pRenderTargets[i].m_pResource->GetRenderTargetView(m_pRenderTargets[i].m_subresource, m_SRGBWriteEnabled);
                psoDesc.RTVFormats[i] = m_pRenderTargets[i].m_pResource ? m_pRenderTargets[i].m_pResource->GetViewFormat(m_SRGBWriteEnabled) :
                    DXGI_FORMAT_UNKNOWN;
            }
        }

        for (UINT i = psoDesc.NumRenderTargets; i <D3D12_SIMULTANEOUS_RENDER_TARGET_COUNT; i++)
        {
            psoDesc.RTVFormats[i] = DXGI_FORMAT_UNKNOWN;
        }

        UINT renderTargetsToSet = m_numBoundRenderTargets;
        if (m_numBoundRenderTargets == 0)
        {
            // Unbind all
            renderTargetsToSet = D3D12_SIMULTANEOUS_RENDER_TARGET_COUNT;
        }

        device.GetContext().OMSetRenderTargets(ppRTVs, renderTargetsToSet, pDSV);
    }

    Resource* PixelStage::FindFirstValidBoundWritableResource()
    {
        // Find the first valid writable resource to determine the sample count/quality
        Resource *pValidWritableResource = nullptr;
        if (m_rtSetMask)
        {
            DWORD index = 0;
            BitScanReverse(&index, m_rtSetMask);
            pValidWritableResource = m_pRenderTargets[index].m_pResource;
        }
        else
        {
            pValidWritableResource = m_pDepthStencil;
        }
        return pValidWritableResource;
    }

    void PixelStage::SetAlphaToCoverageEnabled( const bool enabled )
    {
        m_blendStateID.AlphaToCoverageEnable = enabled ? 1 : 0;
        m_dirtyFlags.BlendState = true;
    }

    HRESULT PixelStage::ResolveDeferredState(Device &device, D3D12_GRAPHICS_PIPELINE_STATE_DESC& psoDesc, UINT& textureDirtyMaskToKeep)
    {
        HRESULT hr = S_OK;

        auto& context = device.GetContext();

        // Need to check if multisampling is enabled first for the logic that determines if 
        // the depth stencil should be hid
        if (m_dirtyFlags.RenderTargets)
        {
            Resource *pValidWritableResource = FindFirstValidBoundWritableResource();
            Check9on12(pValidWritableResource != nullptr);

            psoDesc.SampleDesc = pValidWritableResource->GetDesc().SampleDesc;
            bool multisampleEnabled = psoDesc.SampleDesc.Count > 1;
            if (multisampleEnabled != (m_rasterizerStateID.MultiSampleRenderTarget != 0))
            {
                m_rasterizerStateID.MultiSampleRenderTarget = multisampleEnabled;
                m_dirtyFlags.RasterizerState = true;
            }
        }

        // ForcedSampleCount requires that there cannot be a bound depth stencil view. CS:GO causes a case
        // where a ForcedSampleCount is required AND a depth buffer is bound BUT because depth and stencil 
        // are disabled, we can work around this by temporarily hiding the depth stencil and rebinding it
        // once ForcedSampleCount is off
        // However, Tree of Savior binds a render target which is a different dimension from their still-bound
        // depth buffer. So, for simplicity, we'll just hide the depth buffer any time it's not needed.
        const bool needToHideDepthStencil = GetDepthStencilStateID().DepthStencilViewBindingOptional();
        if (needToHideDepthStencil != m_hideDepthStencil)
        {
            m_hideDepthStencil = needToHideDepthStencil;
            m_dirtyFlags.DepthStencil = true;
            m_dirtyFlags.RenderTargets = true;
        }

        bool bDSVBound = (m_pDepthStencil != nullptr) && !m_hideDepthStencil;

        if (m_dirtyFlags.PSExtension)
        {
            if (m_PSExtension.fFogEnd - m_PSExtension.fFogStart != 0.0f)
            {
                m_PSExtension.fFogDistInv = 1.0f / (m_PSExtension.fFogEnd - m_PSExtension.fFogStart);
            }
            else
            {
                m_PSExtension.fFogDistInv = 0.0f;
            }
            AssertFloatNotInfOrNan(m_PSExtension.fFogDistInv);

            device.GetConstantsManager().UpdatePixelShaderExtension(
                ShaderConv::CB_PS_EXT,
                &m_PSExtension,
                sizeof(m_PSExtension));
        }

        if (m_dirtyFlags.PSExtension2)
        {
            device.GetConstantsManager().UpdatePixelShaderExtension(
                ShaderConv::CB_PS_EXT2,
                &m_PSExtension2,
                sizeof(m_PSExtension2));
        }

        if (m_dirtyFlags.Samplers)
        {
            for (UINT i = 0; i < MAX_SAMPLERS_STAGES; i++)
            {
                if (m_dirtyFlags.Samplers & BIT(i))
                {
                    DWORD shaderRegister;
                    D3D12TranslationLayer::EShaderStage shaderStage;

                    D3D12TranslationLayer::Sampler* sampler = m_samplerCache.GetSampler(device, m_samplerStateIDs[i]);
                    ConvertDX9TextureIndexToShaderStageAndRegisterIndex(i, shaderStage, shaderRegister);

                    if (shaderStage == D3D12TranslationLayer::e_PS)
                    {
                        context.SetSamplers<D3D12TranslationLayer::e_PS>(shaderRegister, 1, &sampler);
                    }
                    else
                    {
                        context.SetSamplers<D3D12TranslationLayer::e_VS>(shaderRegister, 1, &sampler);
                    }

                }
            }
        }

        if (m_dirtyFlags.DepthStencil)
        {
            if (bDSVBound)
            {
                psoDesc.DSVFormat = m_pDepthStencil->DepthStencilViewFormat();
            }
            else
            {
                psoDesc.DSVFormat = DXGI_FORMAT_UNKNOWN;
            }
        }

        // If Alpha to coverage is enabled, we must disable Alpha Testing and set AlphaFunc to D3DCMP_ALWAYS.
        // If it is disabled, we need to make sure that we revert the computed raster states to the values requested by the app.
        // Setting AlphaTestEnable or AlphaFunc states should disable the PixelShader flag, so we need to do this before the
        // PixelShader block below.
        if (m_dirtyFlags.BlendState || m_dirtyFlags.PixelShader)
        {
            const auto& rasterStates = m_rasterStates.GetRasterState();
            if (rasterStates.AlphaTestEnable && m_blendStateID.AlphaToCoverageEnable)
            {
                m_computedRasterStates.m_alphaTestEnable = false;
                m_computedRasterStates.m_alphaFunc = D3DCMP_ALWAYS;

                m_dirtyFlags.PixelShader = true;
            }
            else if(m_computedRasterStates.m_alphaTestEnable != rasterStates.AlphaTestEnable
                     || m_computedRasterStates.m_alphaFunc != rasterStates.AlphaFunc )
            {
                // Restore the values requested by the app
                m_computedRasterStates.m_alphaTestEnable = rasterStates.AlphaTestEnable;
                m_computedRasterStates.m_alphaFunc = rasterStates.AlphaFunc;

                m_dirtyFlags.PixelShader = true;
            }
        }

        if (m_dirtyFlags.PixelShader)
        {
            Check9on12(m_pCurrentPS);
            D3D12VertexShader* pVS = device.GetPipelineState().GetVertexStage().GetCurrentD3D12VertexShader();
            D3D12GeometryShader* pGS = device.GetPipelineState().GetVertexStage().GetCurrentD3D12GeometryShader();

            if (pVS != nullptr)
            {
                ShaderConv::RasterStates mergedRasterStates = m_rasterStates.GetRasterState();  // copy by value
                mergedRasterStates.AlphaTestEnable = m_computedRasterStates.m_alphaTestEnable;
                mergedRasterStates.AlphaFunc = m_computedRasterStates.m_alphaFunc;

                m_pCurrentD3D12PixelShader = &m_pCurrentPS->GetD3D12Shader(
                    mergedRasterStates,
                    pGS ? pGS->m_gsOutputDecls : pVS->m_vsOutputDecls,
                    pGS ? (D3D12Shader &)*pGS  : (D3D12Shader &)*pVS);

                psoDesc.PS = m_pCurrentD3D12PixelShader->GetUnderlying()->GetByteCode();
                if (psoDesc.PS.pShaderBytecode == nullptr)
                {
                    hr = E_FAIL;
                    CHECK_HR(hr);
                }

                for (UINT i = 0; i < ARRAYSIZE(m_pCurrentD3D12PixelShader->m_inlineConsts); i++)
                {
                    for (auto &data : m_pCurrentD3D12PixelShader->m_inlineConsts[i])
                    {
                        device.GetConstantsManager().GetPixelShaderConstants().GetConstantBufferData((ShaderConv::eConstantBuffers)i).SetData((Float4*)&data.Value, data.RegIndex / 4, 1);
                    }
                }
            }
            else
            {
                hr = E_FAIL;
                CHECK_HR(hr);
            }
        }

        textureDirtyMaskToKeep = 0;
        if (m_dirtyFlags.Textures)
        {
            UINT textureMask = m_dirtyFlags.Textures;
            for (UINT i = 0; textureMask > 0; textureMask = textureMask >> 1, ++i)
            {
                if (textureMask & BIT(0))
                {
                    DWORD shaderRegister;
                    D3D12TranslationLayer::EShaderStage shaderStage;
                    ConvertDX9TextureIndexToShaderStageAndRegisterIndex(i, shaderStage, shaderRegister);

                    D3D12TranslationLayer::SRV* pSRV = nullptr;
                    Resource* pResource = m_shaderResources[i];
                    if (pResource)
                    {   
                        // Certain apps expect the driver to automatically unbind resources as SRVs when they are bound as RTVs
                        // Examples inclue Alan Wake and Valkyrie Chronicles
                        bool HideSRV = pResource->GetDSVBindingTracker().IsBound() && GetDepthStencilStateID().ZWriteEnable;

                        // resources with INTZ surface format, set ZWriteEnable to false instead of hiding SRV
                        if (!g_AppCompatInfo.DisableIntzDSVFix && HideSRV && (pResource->GetD3DFormat() == D3DFMT_INTZ))
                        {
                            HideSRV = false;
                            SetDepthStencilState(device, D3DRS_ZWRITEENABLE, 0);
                            device.GetPipelineState().SetIntzRestoreZWrite(true);
                        }

                        if (!HideSRV && pResource->GetRTVBindingTracker().IsBound())
                        {
                            HideSRV = true;

                            // Some apps want to be able to read from the currently bound render target.
                            // Examples include Tree of Savior
                            D3D12TranslationLayer::TDeclVector* pDecls = nullptr;
                            if (shaderStage == D3D12TranslationLayer::e_PS && m_pCurrentD3D12PixelShader)
                            {
                                pDecls = &m_pCurrentD3D12PixelShader->GetUnderlying()->m_ResourceDecls;
                            }
                            else if (shaderStage == D3D12TranslationLayer::e_VS)
                            {
                                auto pVS = device.GetPipelineState().GetVertexStage().GetCurrentD3D12VertexShader();
                                if (pVS)
                                {
                                    pDecls = &pVS->GetUnderlying()->m_ResourceDecls;
                                }
                            }
                            if (pDecls)
                            {
                                if (shaderRegister < pDecls->size() && (*pDecls)[shaderRegister] != D3D12TranslationLayer::RESOURCE_DIMENSION::UNKNOWN)
                                {
                                    pResource = pResource->GetBackingPlainResource();
                                    HideSRV = false;
                                }
                            }
                            textureDirtyMaskToKeep |= BIT(i); // Set this dirty bit again to check if we should do this copy next time
                        }

                        if (HideSRV)
                        {
                            pSRV = nullptr;
                        }
                        else
                        {
                            DWORD flags = Resource::ShaderResourceViewFlags::None;
                            if (GetSamplerID(i).MipFilter == D3DDDITEXF_NONE)
                            {
                                flags |= Resource::ShaderResourceViewFlags::DisableMips;
                            }
                            if (m_SRGBTexture[i])
                            {
                                flags |= Resource::ShaderResourceViewFlags::SRGBEnabled;
                            }
                            pSRV = pResource->GetShaderResourceView(flags);
                        }
                    }

                    if (shaderStage == D3D12TranslationLayer::e_PS)
                    {
                        context.SetShaderResources<D3D12TranslationLayer::e_PS>(shaderRegister, 1, &pSRV);
                    }
                    else
                    {
                        context.SetShaderResources<D3D12TranslationLayer::e_VS>(shaderRegister, 1, &pSRV);
                    }
                }
            }
        }

        if (m_dirtyFlags.DepthStencilState)
        {
            psoDesc.DepthStencilState = ConvertDepthStencilState(m_depthStencilStateID, bDSVBound);
        }

        if (m_dirtyFlags.RenderTargets)
        {
            ResolveRenderTargets(device, psoDesc, bDSVBound);
        }

        if (m_dirtyFlags.BlendState)
        {
            psoDesc.BlendState = ConvertBlendState(m_blendStateID, m_alphaDisabledMask, m_rtvShaderComponentMapping);

            UINT sampleMask = m_multiSampleMask;
            // Some apps such as Halo set a sample mask of 0. Ignore the app setting unless
            // MSAA is actaully enabled.
            if (psoDesc.SampleDesc.Count == 1 && m_multiSampleMask == 0)
            {
                sampleMask = MAXUINT;
            }
            psoDesc.SampleMask = sampleMask;
        }

        if (m_dirtyFlags.RasterizerState)
        {
            psoDesc.RasterizerState = ConvertRasterizerState(m_rasterizerStateID,  bDSVBound && psoDesc.DepthStencilState.DepthEnable, psoDesc.DSVFormat);
        }

        return hr;
    }

    D3D12TranslationLayer::Sampler* PixelStage::SamplerCache::GetSampler(Device& device, SamplerStateID& id)
    {
        auto result = m_map.find(id);
        if (result == m_map.end())
        {
            D3D12_SAMPLER_DESC createSamplerDesc = ConvertSampler(id, device.m_Options19.AnisoFilterWithPointMipSupported);

            m_map[id] = std::unique_ptr<D3D12TranslationLayer::Sampler>(new D3D12TranslationLayer::Sampler(&device.GetContext(), createSamplerDesc));

            return m_map[id].get();
        }
        else
        {
            return result->second.get();
        }
    }

};
```

`src/9on12Query.cpp`:

```cpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#include "pch.h"

namespace D3D9on12
{
    _Check_return_ HRESULT APIENTRY CheckCounter(_In_ HANDLE hDevice, _In_ D3DDDIQUERYTYPE, _Out_ D3DDDI_COUNTER_TYPE*, _Out_ UINT*,
        _Out_writes_to_opt_(*pNameLength, *pNameLength) LPSTR,
        _Inout_opt_ UINT* pNameLength,
        _Out_writes_to_opt_(*pUnitsLength, *pUnitsLength) LPSTR,
        _Inout_opt_ UINT* pUnitsLength,
        _Out_writes_to_opt_(*pDescriptionLength, *pDescriptionLength) LPSTR,
        _Inout_opt_ UINT* pDescriptionLength)
    {
        UNREFERENCED_PARAMETER(hDevice);
        UNREFERENCED_PARAMETER(pNameLength);
        UNREFERENCED_PARAMETER(pUnitsLength);
        UNREFERENCED_PARAMETER(pDescriptionLength);

        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    VOID APIENTRY CheckCounterInfo(_In_ HANDLE hDevice, _Out_ D3DDDIARG_COUNTER_INFO* /*pCounterInfo*/)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        D3D9on12_DDI_ENTRYPOINT_END_AND_REPORT_HR(hDevice, S_OK);
    }

    _Check_return_ HRESULT APIENTRY SetMarker(_In_ HANDLE /*hDevice*/)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY SetMarkerMode(_In_ HANDLE /*hDevice*/, _In_ D3DDDI_MARKERTYPE /*Type*/, /*D3DDDI_SETMARKERMODE*/ UINT /*Flags*/)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY CreateQuery(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_CREATEQUERY* pCreateQuery)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pCreateQuery == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }
        HRESULT hr = S_OK;

        Query* pQuery = new Query(pCreateQuery->QueryType);
        if (pQuery != nullptr)
        {
            hr = pQuery->Init(*pDevice);

            if (SUCCEEDED(hr))
            {
                pCreateQuery->hQuery = Query::GetHandleFromQuery(pQuery);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        CHECK_HR(hr);
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr);
    }

    _Check_return_ HRESULT APIENTRY DestroyQuery(_In_ HANDLE hDevice, _In_ CONST HANDLE handle)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        Query* pQuery = Query::GetQueryFromHandle(handle);
        if (pDevice == nullptr || pQuery == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        delete(pQuery);

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY IssueQuery(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_ISSUEQUERY* pIssueQuery)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pIssueQuery == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        Query* pQuery = Query::GetQueryFromHandle(pIssueQuery->hQuery);
        if (pQuery == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        HRESULT hr = pQuery->Issue(*pDevice, pIssueQuery->Flags);

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr);
    }

    _Check_return_ HRESULT APIENTRY GetQueryData(_In_ HANDLE hDevice, _Inout_ CONST D3DDDIARG_GETQUERYDATA* pGetQueryData)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pGetQueryData == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        Query* pQuery = Query::GetQueryFromHandle(pGetQueryData->hQuery);
        if (pQuery == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        HRESULT hr = pQuery->GetData(*pDevice, pGetQueryData->pData);
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr);
    }

    Query::Query(D3DDDIQUERYTYPE queryType) : 
        m_type(queryType),
        m_eventFenceValue(m_cUnitializedFenceValue),
        m_pUnderlyingQuery(nullptr)
    {};


    HRESULT Query::Init(Device& device)
    {
        HRESULT hr = S_OK;

        switch (m_type)
        {
        case D3DDDIQUERYTYPE_EVENT:
            m_pUnderlyingQuery.reset(new D3D12TranslationLayer::EventQuery(&device.GetContext(), D3D12TranslationLayer::COMMAND_LIST_TYPE_GRAPHICS_MASK));
            break;
        case D3DDDIQUERYTYPE_OCCLUSION:
            m_pUnderlyingQuery.reset(new D3D12TranslationLayer::Query(&device.GetContext(), D3D12TranslationLayer::e_QUERY_OCCLUSION, D3D12TranslationLayer::COMMAND_LIST_TYPE_GRAPHICS_MASK));
            break;
        case D3DDDIQUERYTYPE_TIMESTAMP:
            m_pUnderlyingQuery.reset(new D3D12TranslationLayer::Query(&device.GetContext(), D3D12TranslationLayer::e_QUERY_TIMESTAMP, D3D12TranslationLayer::COMMAND_LIST_TYPE_GRAPHICS_MASK));
            break;
        case D3DDDIQUERYTYPE_TIMESTAMPFREQ:
        case D3DDDIQUERYTYPE_TIMESTAMPDISJOINT:
            m_pUnderlyingQuery.reset(new D3D12TranslationLayer::TimestampDisjointQuery(&device.GetContext(), D3D12TranslationLayer::COMMAND_LIST_TYPE_GRAPHICS_MASK));
            break;
        default:
            break;
        }

        if (m_pUnderlyingQuery)
        {
            m_pUnderlyingQuery->Initialize();
        }

        return hr;
    }

    HRESULT Query::Issue(Device& /*device*/, D3DDDI_ISSUEQUERYFLAGS flags)
    {
        HRESULT hr = S_OK;

        switch (m_type)
        {
        case D3DDDIQUERYTYPE_EVENT:
        case D3DDDIQUERYTYPE_OCCLUSION:
        case D3DDDIQUERYTYPE_TIMESTAMP:
        case D3DDDIQUERYTYPE_TIMESTAMPDISJOINT:
        case D3DDDIQUERYTYPE_TIMESTAMPFREQ:
        {
            if (flags.Begin)
            {
                m_pUnderlyingQuery->Begin();
            }
            else if (flags.End)
            {
                m_pUnderlyingQuery->End();
            }
            else
            {
                Check9on12(false);
            }
            return S_OK;
        }
        case D3DDDIQUERYTYPE_VCACHE:
            return S_OK;

        case D3DDDIQUERYTYPE_RESOURCEMANAGER:
        case D3DDDIQUERYTYPE_VERTEXSTATS:
        case D3DDDIQUERYTYPE_DDISTATS:
        case D3DDDIQUERYTYPE_PIPELINETIMINGS:
        case D3DDDIQUERYTYPE_INTERFACETIMINGS:
        case D3DDDIQUERYTYPE_VERTEXTIMINGS:
        case D3DDDIQUERYTYPE_PIXELTIMINGS:
        case D3DDDIQUERYTYPE_BANDWIDTHTIMINGS:
        case D3DDDIQUERYTYPE_CACHEUTILIZATION:
        case D3DDDIQUERYTYPE_COUNTER_DEVICE_DEPENDENT:
        default:
            Check9on12(false);
            hr = E_NOTIMPL;
        }

        return hr;
    }

    HRESULT Query::GetData(Device& /*device*/, VOID* pData)
    {
        HRESULT hr = S_FALSE;

        switch (m_type)
        {
        case D3DDDIQUERYTYPE_EVENT:
        {
            BOOL finished = false;

            if (m_pUnderlyingQuery->GetData(&finished, sizeof(finished), true, false))
            {
                *reinterpret_cast<BOOL*>(pData) = finished;
                return S_OK;
            }
            else
            {
                return S_FALSE;
            }
        }        
        case D3DDDIQUERYTYPE_OCCLUSION:
        {
            UINT64 occluded = 0;
            if (m_pUnderlyingQuery->GetData(&occluded, sizeof(occluded), true, false))
            {
                *reinterpret_cast<DWORD*>(pData) = DWORD(occluded);
                return S_OK;
            }
            else
            {
                return S_FALSE;
            }
        }
        case D3DDDIQUERYTYPE_TIMESTAMP:
        {
            UINT64 timestamp = 0;
            if (m_pUnderlyingQuery->GetData(&timestamp, sizeof(timestamp), true, false))
            {
                *reinterpret_cast<DWORD*>(pData) = DWORD(timestamp);
                return S_OK;
            }
            else
            {
                return S_FALSE;
            }
        }
        case D3DDDIQUERYTYPE_TIMESTAMPFREQ:
        case D3DDDIQUERYTYPE_TIMESTAMPDISJOINT:
        {
            D3D12TranslationLayer::QUERY_DATA_TIMESTAMP_DISJOINT disjointResult = {};
            if (m_pUnderlyingQuery->GetData(&disjointResult, sizeof(disjointResult), true, false))
            {
                BOOL isDisjoint = disjointResult.Disjoint;
                if (m_type == D3DDDIQUERYTYPE_TIMESTAMPDISJOINT)
                {
                    *reinterpret_cast<DWORD*>(pData) = DWORD(isDisjoint);
                    return S_OK;
                }
                else
                {
                    Check9on12(m_type == D3DDDIQUERYTYPE_TIMESTAMPFREQ);
                    *reinterpret_cast<UINT64*>(pData) = isDisjoint ? 0 : disjointResult.Frequency;
                    return S_OK;
                }
            }
            else
            {
                return S_FALSE;
            }
        }
        case D3DDDIQUERYTYPE_VCACHE:
        {
            D3DDEVINFO_VCACHE Data;
            Data.Pattern = MAKEFOURCC('C', 'A', 'C', 'H');
            Data.OptMethod = 0;
            Data.CacheSize = 0;
            Data.MagicNumber = 0;
            *reinterpret_cast<D3DDEVINFO_VCACHE*>(pData) = Data;
            return S_OK;
        }
        case D3DDDIQUERYTYPE_RESOURCEMANAGER:
        case D3DDDIQUERYTYPE_VERTEXSTATS:
        case D3DDDIQUERYTYPE_DDISTATS:
        case D3DDDIQUERYTYPE_PIPELINETIMINGS:
        case D3DDDIQUERYTYPE_INTERFACETIMINGS:
        case D3DDDIQUERYTYPE_VERTEXTIMINGS:
        case D3DDDIQUERYTYPE_PIXELTIMINGS:
        case D3DDDIQUERYTYPE_BANDWIDTHTIMINGS:
        case D3DDDIQUERYTYPE_CACHEUTILIZATION:
        case D3DDDIQUERYTYPE_COUNTER_DEVICE_DEPENDENT:
        default:
            Check9on12(false);
            hr = E_NOTIMPL;
        }

        return hr;
    }
};
```

`src/9on12Resource.cpp`:

```cpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#include "pch.h"
#include <formatdesc.hpp>
#undef min
#undef max
using std::min;
using std::max;

namespace D3D9on12
{
    _Check_return_ UINT APIENTRY QueryResourcePrivateDriverDataSize(HANDLE hDD)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDD);
        if (pDevice == nullptr)
        {
            return 0;
        }

        D3D9on12_DDI_ENTRYPOINT_END_REPORT_HR_AND_RETURN(hDD, S_OK, D3D12TranslationLayer::SharedResourceHelpers::cPrivateResourceDriverDataSize);
    }

    _Check_return_ HRESULT APIENTRY QueryResourceInfoFromKMTHandle(HANDLE hDD, D3DKMT_HANDLE hKMResource, _Out_ D3D9ON12_RESOURCE_INFO *pResourceInfo)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDD);
        if (pDevice == nullptr || pResourceInfo == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D12TranslationLayer::ResourceInfo resourceInfo;;
        pDevice->GetSharedResourceHelper().QueryResourceInfoFromKMTHandle(hKMResource, nullptr, &resourceInfo);

#define D3DUSAGE_HEAVYWEIGHT              (0x08000000L)
        // Pulled from d3d8typesp.h. Every resource from an LH driver is expected by the 
        // DX9 runtime to have this usage

        assert(!resourceInfo.m_bSynchronized); // 9on12 doesn't understand the keyed mutex
        if (resourceInfo.m_Type == D3D12TranslationLayer::ResourceInfoType::ResourceType)
        {
            // convert dx12 info to dx9 info
            ZeroMemory(pResourceInfo, sizeof(*pResourceInfo));
            pResourceInfo->bNtHandle = resourceInfo.m_bNTHandle;
            pResourceInfo->bAllocatedBy9on12 = resourceInfo.m_bAllocatedBy9on12;
            pResourceInfo->Format = ConvertToD3DFORMAT(resourceInfo.Resource.m_ResourceDesc.Format);
            pResourceInfo->Pool = D3DPOOL_DEFAULT; // TODO is this safe to assume?
            pResourceInfo->Usage = D3DUSAGE_HEAVYWEIGHT;

            if (resourceInfo.Resource.m_ResourceDesc.Dimension == D3D12_RESOURCE_DIMENSION_BUFFER)
            {
                pResourceInfo->BufferDesc.FVF = 0;
                pResourceInfo->BufferDesc.Size = (UINT)resourceInfo.Resource.m_ResourceDesc.Width;

                if (resourceInfo.Resource.m_ResourceDesc.Format == DXGI_FORMAT_R16_UINT || resourceInfo.Resource.m_ResourceDesc.Format == DXGI_FORMAT_R8_UINT)
                {
                    pResourceInfo->Type = D3DRTYPE_INDEXBUFFER;
                }
                else
                {
                    assert(resourceInfo.Resource.m_ResourceDesc.Format == DXGI_FORMAT_UNKNOWN);
                    pResourceInfo->Type = D3DRTYPE_VERTEXBUFFER;
                }
            }
            else
            {
                const bool bIs3DTexture = resourceInfo.Resource.m_ResourceDesc.Dimension == D3D12_RESOURCE_DIMENSION_TEXTURE3D;
                pResourceInfo->TextureDesc.Depth = bIs3DTexture ? resourceInfo.Resource.m_ResourceDesc.DepthOrArraySize : 1;
                pResourceInfo->TextureDesc.Levels = resourceInfo.Resource.m_ResourceDesc.MipLevels;
                pResourceInfo->Width = (UINT)resourceInfo.Resource.m_ResourceDesc.Width;
                pResourceInfo->Height = resourceInfo.Resource.m_ResourceDesc.Height;
                pResourceInfo->TextureDesc.MultiSampleQuality = resourceInfo.Resource.m_ResourceDesc.SampleDesc.Quality;

                if (resourceInfo.Resource.m_ResourceDesc.SampleDesc.Count == 1)
                {
                    pResourceInfo->TextureDesc.MultiSampleType = D3DMULTISAMPLE_NONE;
                }
                else
                {
                    pResourceInfo->TextureDesc.MultiSampleType = (D3DMULTISAMPLE_TYPE)resourceInfo.Resource.m_ResourceDesc.SampleDesc.Count;
                }

                if (resourceInfo.Resource.m_ResourceDesc.Flags & D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET)
                {
                    pResourceInfo->Usage |= D3DUSAGE_RENDERTARGET;
                }
                if (resourceInfo.Resource.m_ResourceDesc.Flags & D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL)
                {
                    pResourceInfo->Usage |= D3DUSAGE_DEPTHSTENCIL;
                }

                switch (resourceInfo.Resource.m_ResourceDesc.Dimension)
                {
                case D3D12_RESOURCE_DIMENSION_TEXTURE1D:
                    assert(false);
                    break;
                case D3D12_RESOURCE_DIMENSION_TEXTURE2D:
                    if (resourceInfo.Resource.m_ResourceDesc.DepthOrArraySize == 6)
                    {
                        pResourceInfo->Type = D3DRTYPE_CUBETEXTURE;
                    }
                    // We don't have enough information to 100% determine whether
                    // this resource is a "texture" or a "surface", but this distinction
                    // turns out not to be too meaningful, so we just take a guess
                    else if (resourceInfo.Resource.m_ResourceDesc.SampleDesc.Count > 1)
                    {
                        pResourceInfo->Type = D3DRTYPE_SURFACE;
                    }
                    else
                    {
                        pResourceInfo->Type = D3DRTYPE_TEXTURE;
                    }
                    break;
                case D3D12_RESOURCE_DIMENSION_TEXTURE3D:
                    pResourceInfo->Type = D3DRTYPE_VOLUMETEXTURE;
                    break;
                }
            }
        }
        else
        {
            ThrowFailure(E_UNEXPECTED);
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY DestroyKMTHandle(
        HANDLE hDD, D3DKMT_HANDLE hKMResource)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDD);
        if (pDevice == nullptr)
        {
            return E_INVALIDARG;
        }

        pDevice->GetSharedResourceHelper().DestroyKMTHandle(hKMResource);
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY CreateKMTHandle(
        HANDLE hDD, _In_ HANDLE resourceHandle, _Out_ D3DKMT_HANDLE *pHKMResource,
        _Out_writes_bytes_(dataSize) void *pResourcePrivateDriverData, _In_ UINT dataSize)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDD);
        if (pDevice == nullptr || pHKMResource == nullptr)
        {
            return E_INVALIDARG;
        }

        CComPtr<IUnknown> pResourceUnk = nullptr;
        {
            std::lock_guard WrappingLock(pDevice->m_WrappingResourceSetLock);
            if (pDevice->m_WrappingResourceSet.find(reinterpret_cast<IUnknown*>(resourceHandle)) != pDevice->m_WrappingResourceSet.end())
            {
                pResourceUnk = reinterpret_cast<IUnknown*>(resourceHandle);
            }
        }
        if (pResourceUnk)
        {
            *pHKMResource = pDevice->GetSharedResourceHelper().CreateKMTHandle(pResourceUnk);
            pDevice->GetSharedResourceHelper().InitializePrivateDriverData(D3D12TranslationLayer::DeferredDestructionType::Submission, pResourcePrivateDriverData, dataSize);
        }
        else
        {
            *pHKMResource = pDevice->GetSharedResourceHelper().CreateKMTHandle(resourceHandle);
            pDevice->GetSharedResourceHelper().InitializePrivateDriverData(D3D12TranslationLayer::DeferredDestructionType::Completion, pResourcePrivateDriverData, dataSize);
        }
        pResourceUnk.Detach();
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY CreateResourceWrappingHandle(
        HANDLE hDD, _In_ IUnknown* pD3D12Resource, _Out_ HANDLE* phWrappingHandle)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDD);
        if (pDevice == nullptr || pD3D12Resource == nullptr || phWrappingHandle == nullptr)
        {
            return E_INVALIDARG;
        }

        std::lock_guard WrappingLock(pDevice->m_WrappingResourceSetLock);
        pDevice->m_WrappingResourceSet.insert(pD3D12Resource);
        *phWrappingHandle = pD3D12Resource;
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    void APIENTRY DestroyResourceWrappingHandle(HANDLE hDD, HANDLE hWrappingHandle)
    {
        Device* pDevice = Device::GetDeviceFromHandle(hDD);
        if (pDevice == nullptr || hWrappingHandle == nullptr)
        {
            return;
        }

        std::lock_guard WrappingLock(pDevice->m_WrappingResourceSetLock);
        pDevice->m_WrappingResourceSet.erase(reinterpret_cast<IUnknown*>(hWrappingHandle));
    }

    void CleanupTranslationLayerResourceBindings(D3D12TranslationLayer::ImmediateContext &context, D3D12TranslationLayer::Resource &resource)
    {
        context.ClearInputBindings(&resource);
        context.ClearOutputBindings(&resource);
    }

    _Check_return_ HRESULT APIENTRY GetSharedGDIHandle_Private(_In_ HANDLE hDevice, HANDLE DriverResource, HANDLE *pSharedGDIHandle)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device *pDevice = Device::GetDeviceFromHandle(hDevice);
        Resource *pResource = Resource::GetResourceFromHandle(DriverResource);
        if (pDevice == nullptr || pResource == nullptr)
        {
            return E_INVALIDARG;
        }

        *pSharedGDIHandle = 0;
        *pSharedGDIHandle = pResource->GetSharedGDIHandle();
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY CreateSharedNTHandle_Private(_In_ HANDLE hDevice, HANDLE DriverResource, _In_opt_ SECURITY_DESCRIPTOR* pSD, HANDLE *pSharedNTHandle)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device *pDevice = Device::GetDeviceFromHandle(hDevice);
        Resource *pResource = Resource::GetResourceFromHandle(DriverResource);
        if (pDevice == nullptr || pResource == nullptr)
        {
            return E_INVALIDARG;
        }

        *pSharedNTHandle = 0;
        *pSharedNTHandle = pResource->CreateSharedNTHandle(pSD);
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY DepthFill(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_DEPTHFILL* pDepthFill)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pDepthFill == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        Resource* pResource = Resource::GetResourceFromHandle(pDepthFill->hResource);
        if (pResource == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        Check9on12(pDepthFill->SubResourceIndex == 0);
        HRESULT hr =pResource->ClearDepthStencil(D3DCLEAR_ZBUFFER, &pDepthFill->DstRect, 1, (float)pDepthFill->Depth, 0);
        CHECK_HR(hr);

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr);
    }

    _Check_return_ HRESULT APIENTRY CreateResource2(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_CREATERESOURCE2* pCreateArgs)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device *pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pCreateArgs == nullptr)
        {
            return E_INVALIDARG;
        }

        if (pCreateArgs->Format == D3DFMT_NULL)
        {
            pCreateArgs->hResource = Resource::GetHandleFromResource(nullptr);
            return S_OK;
        }

        Resource *pResource = new Resource(pCreateArgs->hResource, pDevice);
        if (pResource == nullptr)
        {
            return E_OUTOFMEMORY;
        }

        HRESULT hr = S_OK;

        hr = pResource->Init(*pCreateArgs);

        if (SUCCEEDED(hr))
        {
            pCreateArgs->hResource = Resource::GetHandleFromResource(pResource);
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr);
    }

    _Check_return_ HRESULT APIENTRY OpenResource_Private(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_OPENRESOURCE* hOpenResource, _In_ _D3D9ON12_OPEN_RESOURCE_ARGS *pD3D9on12OpenResource)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        HRESULT hr = S_OK;
        if (pDevice == nullptr || hOpenResource == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        if (hOpenResource->PrivateDriverDataSize != D3D12TranslationLayer::SharedResourceHelpers::cPrivateResourceDriverDataSize || hOpenResource->pPrivateDriverData == nullptr || pD3D9on12OpenResource == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        Resource* pResource = new Resource(hOpenResource->hResource, pDevice);
        if (pResource == nullptr)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = pResource->OpenResource(hOpenResource->hKMResource, hOpenResource->pPrivateDriverData, hOpenResource->PrivateDriverDataSize, pD3D9on12OpenResource);

            if (SUCCEEDED(hr))
            {
                hOpenResource->hResource = Resource::GetHandleFromResource(pResource);
            }
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr);
    }

    _Check_return_ HRESULT APIENTRY OpenResource(_In_ HANDLE, _Inout_ D3DDDIARG_OPENRESOURCE*)
    {
        // Expecting OpenResource_Private to get called instead
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY DestroyResource(_In_ HANDLE hDevice, _In_ HANDLE hResource)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        Resource* pResource = Resource::GetResourceFromHandle(hResource);
        // Destroying a null resource is valid if a resource is created with D3DFMT_NULL
        if (pResource == nullptr)
        {
            return S_OK;
        }

        if (pDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        HRESULT hr = S_OK;
        delete pResource;
        
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr);
    }

    _Check_return_ HRESULT APIENTRY UpdateSubresourceUP(_In_ HANDLE /*hDevice*/, _In_ CONST D3DDDIARG_UPDATESUBRESOURCEUP* /*pUpdateArgs*/)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_NOTIMPL);
    }

    _Check_return_ HRESULT APIENTRY ColorFill(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_COLORFILL* pColorFill)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);

        if (pDevice == nullptr || pColorFill == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        Resource* pResource = Resource::GetResourceFromHandle(pColorFill->hResource);

        if (pResource == nullptr)
        {
            // ColorFill on a null resource is okay (does nothing).
            return S_OK;
        }

        UINT subresourceIndices[MAX_PLANES];
        UINT numPlanes;
        pResource->ConvertAppSubresourceToDX12SubresourceIndices(pColorFill->SubResourceIndex, subresourceIndices, numPlanes);

        if (numPlanes == 1)
        {
            pResource->Clear(subresourceIndices[0], &pColorFill->DstRect, 1, pColorFill->Color);
        }
        else
        {
            UINT arrayIndex = pResource->GetArraySliceFromSubresourceIndex(subresourceIndices[0]);
#if DBG
            for (UINT planeIndex = 1; planeIndex < numPlanes; planeIndex++) assert(arrayIndex == pResource->GetArraySliceFromSubresourceIndex(subresourceIndices[planeIndex]));
#endif

            pResource->ClearAllPlanesInArraySlice(arrayIndex, &pColorFill->DstRect, 1, pColorFill->Color);
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY Clear(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_CLEAR *pClearArg, _In_ UINT numRects, _In_ CONST RECT*pDstRect)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pClearArg == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        if (pClearArg->Flags & D3DCLEAR_TARGET)
        {
            for (UINT i = 0; i < MAX_RENDER_TARGETS; i++)
            {
                const BoundRenderTarget &boundRenderTarget = pDevice->GetPipelineState().GetPixelStage().GetRenderTarget(i);
                if (boundRenderTarget.m_pResource)
                {
                    if (pDevice != boundRenderTarget.m_pResource->GetParent())
                    {
                        RETURN_E_INVALIDARG_AND_CHECK();
                    }

                    boundRenderTarget.m_pResource->Clear(boundRenderTarget.m_subresource, pDstRect, numRects, static_cast<D3DCOLOR>(pClearArg->FillColor));
                }
            }
        }
        if (pClearArg->Flags & (D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL))
        {
            Resource *pDepthStencil = pDevice->GetPipelineState().GetPixelStage().GetDepthStencil();
            Check9on12(pDepthStencil);
            if (pDevice != pDepthStencil->GetParent())
            {
                RETURN_E_INVALIDARG_AND_CHECK();
            }

            pDepthStencil->ClearDepthStencil(pClearArg->Flags, pDstRect, numRects, pClearArg->FillDepth, pClearArg->FillStencil);
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY Lock(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_LOCK *pLockArg)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device *pDevice = Device::GetDeviceFromHandle(hDevice);
        Resource *pResource = Resource::GetResourceFromHandle(pLockArg->hResource);
        if (pDevice == nullptr || pLockArg == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        if (pResource == nullptr)
        {
            return S_OK;
        }

        UINT subresourceIndicies[MAX_PLANES];

        struct {
            void *pSurfData;
            UINT Pitch;
            UINT SlicePitch;
        } lockOutput[MAX_PLANES] = {};
        UINT numPlanes = 0;
        pResource->ConvertAppSubresourceToDX12SubresourceIndices(pLockArg->SubResourceIndex, subresourceIndicies, numPlanes);
        Check9on12(numPlanes > 0);

        HRESULT hr = S_OK;
        for (UINT planeIndex = 0; planeIndex < numPlanes && SUCCEEDED(hr); planeIndex++)
        {
            hr = pResource->Lock(
                *pDevice, 
                subresourceIndicies[planeIndex], 
                pLockArg->Flags, 
                LockRange(*pLockArg), 
                false, 
                lockOutput[planeIndex].pSurfData, 
                lockOutput[planeIndex].Pitch, 
                lockOutput[planeIndex].SlicePitch);
        }

        // Set the output data to the first subresource mapped.  The driver is required to 
        // place multiple planes adjacently for dynamic and staging textures, which is the
        // only case that emulation happens for.
        pLockArg->pSurfData = lockOutput[0].pSurfData;
        pLockArg->Pitch = lockOutput[0].Pitch;
        pLockArg->SlicePitch = lockOutput[0].SlicePitch;

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr);
    }

    _Check_return_ HRESULT APIENTRY Unlock(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_UNLOCK* pUnlockArg)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device *pDevice = Device::GetDeviceFromHandle(hDevice);
        Resource *pResource = Resource::GetResourceFromHandle(pUnlockArg->hResource);
        if (pDevice == nullptr || pUnlockArg == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        if (pResource == nullptr)
        {
            return S_OK;
        }

        if (pDevice != pResource->GetParent())
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        UINT subresourceIndicies[MAX_PLANES];
        UINT numPlanes = 0;
        pResource->ConvertAppSubresourceToDX12SubresourceIndices(pUnlockArg->SubResourceIndex, subresourceIndicies, numPlanes);
        for (UINT planeIndex = 0; planeIndex < numPlanes; planeIndex++)
        {
            pResource->Unlock(*pDevice, subresourceIndicies[planeIndex], pUnlockArg->Flags, false);
        }
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY GenerateMipSubLevels(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_GENERATEMIPSUBLEVELS* pArgs)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        Resource* pResource = Resource::GetResourceFromHandle(pArgs->hResource);
        if (pDevice == nullptr || pArgs == nullptr || pDevice != pResource->GetParent())
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        HRESULT hr = S_OK;
        if (pResource != nullptr)
        {
            hr = pResource->GenerateMips(pArgs->Filter);
        }
        else
        {
            hr = E_INVALIDARG;
        }

        CHECK_HR(hr);
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr);
    }

    _Check_return_ HRESULT APIENTRY LockAsync(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_LOCKASYNC* pArg)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pArg == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        Resource *pResource = Resource::GetResourceFromHandle(pArg->hResource);

        HANDLE hCookie = nullptr;
        UINT subresourceIndicies[MAX_PLANES];
        UINT numPlanes;
        pResource->ConvertAppSubresourceToDX12SubresourceIndices(pArg->SubResourceIndex, subresourceIndicies, numPlanes);

        // Planar resources don't support dynamic usage so we should never be using Lock-Discard/Rename with a planar resource 
        // unless it's just a system memory resource
        bool bIsPlanar = numPlanes > 1;
        HRESULT hr = S_OK;
        for (UINT i = 0; i < numPlanes && SUCCEEDED(hr); i++)
        {
            hr = pResource->Lock(*pDevice,
                subresourceIndicies[i],
                ConvertLockAsyncFlags(pArg->Flags),
                LockRange(*pArg),
                true,
                pArg->pSurfData,
                pArg->Pitch,
                pArg->SlicePitch,
                bIsPlanar ? nullptr : &hCookie);
        }

        // Pass a pointer to the resource out to 9, it's kept alive by the immediate context and we can release that ref later.
        pArg->hCookie = hCookie;
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr);
    }

    _Check_return_ HRESULT APIENTRY UnlockAsync(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_UNLOCKASYNC* pArg)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pArg == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        Resource *pResource = Resource::GetResourceFromHandle(pArg->hResource);

        UINT subresourceIndicies[MAX_PLANES];
        UINT numPlanes;
        pResource->ConvertAppSubresourceToDX12SubresourceIndices(pArg->SubResourceIndex, subresourceIndicies, numPlanes);
        for (UINT i = 0; i < numPlanes; i++)
        {
            pResource->Unlock(*pDevice, subresourceIndicies[i], ConvertUnlockAsyncFlag(pArg->Flags), true);
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY Rename(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_RENAME* pArg)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pArg == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        Resource *pResource = Resource::GetResourceFromHandle(pArg->hResource);

        HRESULT hr = pResource->Rename(*pDevice, *pArg);
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr);
    }

    Resource::Resource() : Resource(NULL, nullptr) {}

    Resource::Resource(HANDLE runtimeHandle, Device* parent) :
        m_runtimeHandle(runtimeHandle),
        m_numSubresources(0),
        m_numArrayLevels(0),
        m_renderTargetViews(),
        m_isD3D9SystemMemoryPool(false),
        m_ID(InterlockedIncrement(&g_globalResourceID)),
        m_pBackingShaderResource(nullptr),
        m_dx9Format(D3DFMT_UNKNOWN),
        m_ViewFormat(DXGI_FORMAT_UNKNOWN),
        m_dsvFormat(DXGI_FORMAT_UNKNOWN),
        m_pParentDevice(parent),
        m_CpuAccessFlags(0),
        m_isDecodeCompressedBuffer(false)
    {
        memset(m_pDepthStencilViews, 0, sizeof(m_pDepthStencilViews));
        memset(&m_TranslationLayerCreateArgs, 0, sizeof(m_TranslationLayerCreateArgs));
    }

    Resource::~Resource()
    {
        if (m_pBackingShaderResource)
        {
            delete m_pBackingShaderResource;
        }

        // This must be called before the views are destroyed
        m_pParentDevice->GetContext().ClearInputBindings(m_pResource.get());
        m_pParentDevice->GetContext().ClearOutputBindings(m_pResource.get());

        while (GetSRVBindingTracker().GetBindingIndices().size())
        {
            ThrowFailure(m_pParentDevice->GetPipelineState().GetPixelStage().SetSRV(*m_pParentDevice, nullptr, GetSRVBindingTracker().GetBindingIndices()[0]));
        }

        const BoundRenderTarget nullRenderTarget(nullptr, 0);
        while (GetRTVBindingTracker().GetBindingIndices().size())
        {
            m_pParentDevice->GetPipelineState().GetPixelStage().SetRenderTarget(GetRTVBindingTracker().GetBindingIndices()[0], nullRenderTarget);
        }

        while (GetVBBindingTracker().GetBindingIndices().size())
        {
            m_pParentDevice->GetPipelineState().GetInputAssembly().SetVertexBuffer(
                *m_pParentDevice, 
                nullptr, 
                GetVBBindingTracker().GetBindingIndices()[0], 
                0, 
                0);
        }

        if (GetDSVBindingTracker().IsBound())
        {
            assert(GetDSVBindingTracker().GetBindingIndices().size() == 1);
            m_pParentDevice->GetPipelineState().GetPixelStage().SetDepthStencil(nullptr);
        }

        if (GetIBBindingTracker().IsBound())
        {
            assert(GetIBBindingTracker().GetBindingIndices().size() == 1);
            m_pParentDevice->GetPipelineState().GetInputAssembly().SetIndexBuffer(*m_pParentDevice, nullptr, 0);
        }

        for (UINT i = 0; i < _countof(g_cPossibleDepthStencilStates); i++)
        {
            if (m_pDepthStencilViews[i])
            {
                m_pDepthStencilViews[i]->~View();
            }
        }

        m_pParentDevice->m_lockedResourceRanges.GetLocked()->erase(this);

        m_pResource.reset(nullptr);
    }

    void Resource::CreateUnderlyingResource( D3D12TranslationLayer::ResourceCreationArgs& underlyingResourceCreateArgs, _Inout_ D3DDDIARG_CREATERESOURCE2& createArgs )
    {
        UNREFERENCED_PARAMETER( createArgs );
        CreateUnderlyingResource( underlyingResourceCreateArgs );
    }

    void Resource::CreateUnderlyingResource(D3D12TranslationLayer::ResourceCreationArgs& createArgs)
    {
        m_pResource = D3D12TranslationLayer::Resource::CreateResource(&m_pParentDevice->GetContext(), createArgs, D3D12TranslationLayer::ResourceAllocationContext::ImmediateContextThreadLongLived); // throw( bad_alloc, _com_error )
    }

    ID3D12Resource& Resource::GetResource()
    {
        return *m_pResource->GetUnderlyingResource();
    }

    DXGI_FORMAT Resource::GetViewFormat(bool sRGBEnabled) 
    { 
        return sRGBEnabled ? ConvertToSRGB(m_ViewFormat) : m_ViewFormat; 
    }

    HRESULT Resource::Init(UINT width, UINT height, D3DFORMAT format, D3DDDI_RESOURCEFLAGS resourceFlags, UINT mipLevels, UINT depth, UINT arraySize, bool DoNotCreateAsTypelessResource)
    {
        CreateTextureArgHelper createArg(width, height, ConvertD3DFormatToDDIFormat(format), resourceFlags, mipLevels, depth, arraySize);
        return InitInternal(createArg.GetCreateArgs(), true, {}, DoNotCreateAsTypelessResource);
    }

    HRESULT Resource::Init(_In_ D3DDDIARG_CREATERESOURCE2 &createArgs)
    {
        return InitInternal(createArgs, false);
    }

    UINT16 MaxMipLevels(UINT64 uiMaxDimension)
    {
        UINT16 uiRet = 0;
        while (uiMaxDimension > 0)
        {
            uiRet++;
            uiMaxDimension >>= 1;
        }
        return uiRet;
    }

    HRESULT Resource::Init(unique_comptr<D3D12TranslationLayer::Resource> pResource, D3D9ON12_OPEN_RESOURCE_ARGS *pD3d9on12Args, bool DoNotCreateAsTypelessResource)
    {
        const D3D12_RESOURCE_DESC &desc = pResource->Parent()->m_desc12;
        _D3DDDI_RESOURCEFLAGS resourceFlags = {};

        const bool isBuffer = desc.Dimension == D3D12_RESOURCE_DIMENSION_BUFFER;
        const bool is3DTexture = desc.Dimension == D3D12_RESOURCE_DIMENSION_TEXTURE3D;
        resourceFlags.IndexBuffer = isBuffer;
        resourceFlags.RenderTarget = desc.Flags & D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET;
        resourceFlags.Texture = !isBuffer && (cSupportsPlanarSRVs || !CD3D11FormatHelper::YUV(desc.Format));
        resourceFlags.ZBuffer = desc.Flags & D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;
        resourceFlags.IndexBuffer = isBuffer;

        CreateTextureArgHelper createArgs(
            (UINT)desc.Width, 
            desc.Height, 
            ConvertD3DFormatToDDIFormat(pD3d9on12Args->Format),
            resourceFlags,
            desc.MipLevels,
            (UINT)(is3DTexture ? desc.DepthOrArraySize : 1),
            (UINT)(is3DTexture ? 1 : desc.DepthOrArraySize));

        return InitInternal(createArgs.GetCreateArgs(), true, std::move(pResource), DoNotCreateAsTypelessResource);
    }

    HRESULT Resource::InitInternal(_In_ D3DDDIARG_CREATERESOURCE2 &createArgs, bool onlyFirstSurfInitialized, unique_comptr<D3D12TranslationLayer::Resource> pAlreadyCreatedResource, bool DoNotCreateAsTypelessResource)
    {
#if DBG
        m_d3d9Desc = createArgs;
#endif

        if (createArgs.pSurfList == nullptr) return E_INVALIDARG;

        m_compatOptions.Init((D3DFORMAT)createArgs.Format);

        m_isD3D9SystemMemoryPool = createArgs.Pool == D3DDDIPOOL_SYSTEMMEM;

        ID3D12Device& d3dDevice = m_pParentDevice->GetDevice();

        const D3DDDI_SURFACEINFO &SurfList = *createArgs.pSurfList;
        D3D12_RESOURCE_DIMENSION dimension = ConvertToD3D12Dimension(createArgs.Flags, SurfList.Width, SurfList.Height, SurfList.Depth);

        if (dimension == D3D12_RESOURCE_DIMENSION_TEXTURE2D &&
            (createArgs.pSurfList[0].Width > MAX_TEXTURE_WIDTH_SIZE ||
            createArgs.pSurfList[0].Height > MAX_TEXTURE_HEIGHT_SIZE))
        {
            return E_INVALIDARG;
        }

        const bool bIsDisplayable = createArgs.Flags.Primary;
        m_dx9Format = createArgs.Format == D3DDDIFMT_UNKNOWN ? GetDefaultFormat(createArgs.Flags) : ConvertDDIFormatToAPI(createArgs.Format);
        // X8R8G8B8 is not a DISPLAYABLE format in DX12, but we can emulate it with the compatible D3DFMT_A8R8G8B8
        if (bIsDisplayable && m_dx9Format == D3DFMT_X8R8G8B8)
        {
            m_dx9Format = D3DFMT_A8R8G8B8;
            m_DisableAlphaChannel = true;
        }
        m_VidPnSourceId = bIsDisplayable ? createArgs.VidPnSourceId : D3DDDI_ID_UNINITIALIZED;

        m_ViewFormat = ConvertToDXGIFORMAT(m_dx9Format);
        m_IsLockable = IsLockable(m_dx9Format) && !createArgs.Flags.NotLockable;
        m_NonOpaquePlaneCount = (UINT8)CD3D11FormatHelper::NonOpaquePlaneCount(m_ViewFormat);
        m_cubeMap = createArgs.Flags.CubeMap;

        UINT mssSampleCount, mssQualityLevel = 0;
        if (D3DDDIMULTISAMPLE_NONE == createArgs.MultisampleType)
        {
            mssSampleCount = 1;
        }
        else if (D3DDDIMULTISAMPLE_NONMASKABLE == createArgs.MultisampleType)
        {
            mssSampleCount = 2 << createArgs.MultisampleQuality;
        }
        else
        {
            mssSampleCount = createArgs.MultisampleType;
            mssQualityLevel = createArgs.MultisampleQuality;
        }

        UINT16 numMips = static_cast<UINT16>(max(createArgs.MipLevels, 1u));
        assert(createArgs.SurfCount % numMips == 0);
        m_numArrayLevels = static_cast<UINT8>(createArgs.SurfCount / numMips);
        
        // From MSDN: To generate a mipmap automatically, set a new usage D3DUSAGE_AUTOGENMIPMAP 
        // before calling CreateTexture.Sublevel generation from this point on is completely 
        // transparent to the application.Only the top texture level is accessible to the application;
        // https://msdn.microsoft.com/en-us/library/windows/desktop/bb172340(v=vs.85).aspx

        // If autogenmipmaps is set, we're expected to allocate a full mipchain
        // but the app gets to pretend like the mip levels don't exist. This requires
        // us to convert any subresource indexes we get from the app to account for the
        // "hidden" mip levels
        m_mipMapsHiddenFromApp = createArgs.Flags.AutogenMipmap;
        if (m_mipMapsHiddenFromApp)
        {
            assert(createArgs.MipLevels == 0 || createArgs.MipLevels == 1);
            assert(NeedsShaderResourceView(createArgs.Flags, createArgs.Pool));
            numMips = MaxMipLevels(max(max(SurfList.Width, SurfList.Height), SurfList.Depth));
        }

        UINT16 depth = static_cast<UINT16>(max(SurfList.Depth, 1u));
        const UINT64 width = max(SurfList.Width, 1u);
        const UINT height = max(SurfList.Height, 1u);

        m_desc = CD3DX12_RESOURCE_DESC(
            dimension,
            0,
            width,
            height,
            dimension == D3D12_RESOURCE_DIMENSION_TEXTURE3D ? depth : m_numArrayLevels,
            numMips,
            m_ViewFormat,
            mssSampleCount,
            mssQualityLevel,
            ConvertToD3D12TextureLayout(dimension, createArgs.Flags2),
            ConvertToD3D12ResourceFlags(createArgs.Flags, createArgs.Flags2, createArgs.Pool));

        m_numSubresources = D3D12CalcSubresource(
            numMips - 1, 
            m_numArrayLevels - 1, 
            m_NonOpaquePlaneCount - 1, 
            numMips, 
            m_numArrayLevels) 
                + 1;

        m_lockData.resize(m_numSubresources);
        m_appLinearRepresentation.m_systemData.resize(m_numSubresources);
        m_physicalLinearRepresentation.m_footprints.resize(m_numSubresources);
        m_physicalLinearRepresentation.m_rowPitces.resize(m_numSubresources);
        m_physicalLinearRepresentation.m_numRows.resize(m_numSubresources);

        m_totalSize = 0;

        m_logicalDesc = m_desc;

        // If the format has an SRGB equivalent, make the format typeless so that we can make SRVs with both the 
        // normal format and it's SRGB variant for gamma correction
        // Note: We avoid making everything typeless because it makes it difficult to derive the original API format
        // when sharing this resource across processes. We could work around this by storing extra data in the 
        // kernel handle but for now this is the simplest approach
        const bool GenerateSRGBViews = IsSRGBCompatible(m_ViewFormat) && !DoNotCreateAsTypelessResource;
        const bool IsBothDepthStencilAndSRV = NeedsDepthStencil(createArgs.Flags, createArgs.Pool) && NeedsShaderResourceView(createArgs.Flags, createArgs.Pool);
        const bool bNeedsToBeTypeless = !GetParent()->GetAdapter().SupportsCastingTypelessResources() && (GenerateSRGBViews || IsBothDepthStencilAndSRV);

        // API requires this resource to be typeless so we better not request this to avoid typeless
        Check9on12(!IsBothDepthStencilAndSRV || !DoNotCreateAsTypelessResource);

        DXGI_FORMAT resourceFormat = bNeedsToBeTypeless ? ConvertToTypeless(m_ViewFormat) : m_ViewFormat;

        m_desc.Format = resourceFormat;

        d3dDevice.GetCopyableFootprints(
            &m_desc,
            0,
            m_numSubresources,
            0,
            &m_physicalLinearRepresentation.m_footprints[0],
            &m_physicalLinearRepresentation.m_numRows[0],
            &m_physicalLinearRepresentation.m_rowPitces[0],
            &m_totalSize);

        // We can safely skip initializing app memory information if only the first surf is 
        // initialized because this only happens as when we internally create this resource 
        // and won't be working with any app initial memory
        if (!onlyFirstSurfInitialized)
        {
            for (UINT planeIndex = 0; planeIndex < m_NonOpaquePlaneCount; planeIndex++)
            {
                for (UINT appSubresourceIndex = 0; appSubresourceIndex < createArgs.SurfCount; appSubresourceIndex++)
                {
                    UINT physicalSubresourceIndex = createArgs.SurfCount * planeIndex + appSubresourceIndex;

                    UINT pitch = createArgs.pSurfList[appSubresourceIndex].SysMemPitch;
                    UINT subresourceStartOffset = 0;

                    if (IsChromaPlane(planeIndex))
                    {
                        UINT subsampleX, subsampleY = 0;
                        CD3D11FormatHelper::GetYCbCrChromaSubsampling(m_ViewFormat, subsampleX, subsampleY);

                        UINT lumaPlaneHeight = createArgs.pSurfList[appSubresourceIndex].Height;
                        UINT chromaPlaneHeight = lumaPlaneHeight / subsampleY;
                        UINT numChromaPlanes = planeIndex - 1;

                        subresourceStartOffset = lumaPlaneHeight * pitch + numChromaPlanes * chromaPlaneHeight;
                    }

                    m_appLinearRepresentation.m_systemData[physicalSubresourceIndex].pData = (BYTE *)createArgs.pSurfList[appSubresourceIndex].pSysMem + subresourceStartOffset;
                    m_appLinearRepresentation.m_systemData[physicalSubresourceIndex].RowPitch = pitch;
                    m_appLinearRepresentation.m_systemData[physicalSubresourceIndex].SlicePitch = createArgs.pSurfList[appSubresourceIndex].SysMemSlicePitch;

                    // Because the DX9 runtime has no insight on IHV formats, it isn't aware that the 
                    // resource is block compressed and will treat this as a regular texture without correctly
                    // dividing the total number of rows by 4 like it would for the officially supported DXT formats.
                    // To work around this, IHVs pass in an arbitrary BPP for these formats (this seems to always be 8) 
                    // and internally correct the pitch reported by the runtime with a multiplier.
                    // More details in 9on12Caps.h with the caps inclusion of D3DFMT_ATI1/D3DFMT_ATI2
                    if (IsIHVFormat(createArgs.Format) && IsBlockCompressedFormat(resourceFormat))
                    {
                        C_ASSERT(BPP_FOR_IHV_BLOCK_COMPRESSED_FORMATS % 8 == 0);
                        const UINT runtimeCalculatedPitch = GetBlockWidth(resourceFormat) * BPP_FOR_IHV_BLOCK_COMPRESSED_FORMATS / 8;
                        const UINT actualPitch = GetBytesPerUnit(resourceFormat);

                        assert(actualPitch % runtimeCalculatedPitch == 0);
                        const UINT pitchMultiplier = actualPitch / runtimeCalculatedPitch;

                        m_appLinearRepresentation.m_systemData[physicalSubresourceIndex].RowPitch *= pitchMultiplier;
                    }
                }
            }
        }


        // Store information about how we represent the resource as a linear buffer
        if (IsSystemMemory())
        {
            if (dimension != D3D12_RESOURCE_DIMENSION_BUFFER)
            {
                // What they really want is a buffer
                m_desc = CD3DX12_RESOURCE_DESC::Buffer(m_totalSize);
            }
        }

        if (createArgs.Flags.MightDrawFromLocked)
        {
            // Do nothing, resources that are both lockable and buffers will automatically
            // become upload buffers. It's perfectly valid to read an locked vertex buffer
        }

        if (createArgs.Flags.DecodeCompressedBuffer)
        {
            m_isDecodeCompressedBuffer = true;
        }

        HRESULT hr = S_OK;
        if (m_isD3D9SystemMemoryPool == false)
        {
            UINT bindFlags = {};

            if (IsDecoderSurface(createArgs.Flags))
            {
                bindFlags |= D3D12TranslationLayer::RESOURCE_BIND_DECODER;
            }

            if (NeedsRenderTarget(createArgs.Flags, createArgs.Pool))
            {
                bindFlags |= D3D12TranslationLayer::RESOURCE_BIND_RENDER_TARGET;
            }

            if (NeedsDepthStencil(createArgs.Flags, createArgs.Pool))
            {
                bindFlags |= D3D12TranslationLayer::RESOURCE_BIND_DEPTH_STENCIL;
            }

            // Even if it doesn't need an SRV, mark this as an SRV so we have the option of making an SRV in case this resource is used as the 
            // source of a StretchRect
            if (NeedsShaderResourceView(createArgs.Flags, createArgs.Pool) || m_desc.Dimension == D3D12_RESOURCE_DIMENSION_TEXTURE2D)
            {
                bindFlags |= D3D12TranslationLayer::RESOURCE_BIND_SHADER_RESOURCE;
            }

            if (createArgs.Flags.IndexBuffer)
            {
                bindFlags |= D3D12TranslationLayer::RESOURCE_BIND_INDEX_BUFFER;
            }

            if (createArgs.Flags.VertexBuffer)
            {
                bindFlags |= D3D12TranslationLayer::RESOURCE_BIND_VERTEX_BUFFER;
            }

            if (m_IsLockable)
            {
                m_CpuAccessFlags |= D3D12TranslationLayer::RESOURCE_CPU_ACCESS_WRITE;
                // Note: without supporting the R2VB extension, there is no way to write
                // to D3D9 vertex or index buffers.
                if (!createArgs.Flags.WriteOnly &&
                    !createArgs.Flags.VertexBuffer &&
                    !createArgs.Flags.IndexBuffer)
                {
                    m_CpuAccessFlags |= D3D12TranslationLayer::RESOURCE_CPU_ACCESS_READ;
                }
            }

            const D3D12TranslationLayer::RESOURCE_USAGE UsageFlag = GetResourceUsage(createArgs.Flags, m_CpuAccessFlags);
            D3D12_HEAP_TYPE HeapType = D3D12TranslationLayer::Resource::GetD3D12HeapType(UsageFlag, m_CpuAccessFlags);
            // We've seen some apps such as Unigine Valley experience corruption on systems with UMA when switching to HeapTypeDefault here, so skipping this optimization in that case for now
            bool isUMA = m_pParentDevice->GetContext().m_architecture.isUMA;
            if (!isUMA && 
                HeapType == D3D12_HEAP_TYPE_UPLOAD &&
                (createArgs.Flags.VertexBuffer || createArgs.Flags.IndexBuffer) &&
                createArgs.Flags.HintStatic)
            {
                HeapType = D3D12_HEAP_TYPE_DEFAULT;
            }

            m_TranslationLayerCreateArgs.m_desc12 = m_desc;
            m_TranslationLayerCreateArgs.m_appDesc = ConvertToAppResourceDesc(m_desc,
                UsageFlag,
                (D3D12TranslationLayer::RESOURCE_CPU_ACCESS)m_CpuAccessFlags,
                (D3D12TranslationLayer::RESOURCE_BIND_FLAGS)bindFlags);
            m_TranslationLayerCreateArgs.m_heapDesc = CD3DX12_HEAP_DESC(m_pParentDevice->GetDevice().GetResourceAllocationInfo(0, 1, &m_desc),
                CD3DX12_HEAP_PROPERTIES(HeapType),
                createArgs.Flags.SharedResource ? D3D12_HEAP_FLAG_SHARED : D3D12_HEAP_FLAG_CREATE_NOT_RESIDENT);
            m_TranslationLayerCreateArgs.m_bBoundForStreamOut = false;
            m_TranslationLayerCreateArgs.m_isPlacedTexture = 0;
            m_TranslationLayerCreateArgs.m_OffsetToStreamOutputSuffix = 0;
            m_TranslationLayerCreateArgs.m_bManageResidency = true;
            m_TranslationLayerCreateArgs.m_bIsD3D9on12Resource = true;
            if (bIsDisplayable)
            {
                m_TranslationLayerCreateArgs.m_heapDesc.Flags |= D3D12_HEAP_FLAG_ALLOW_DISPLAY;
                m_TranslationLayerCreateArgs.m_bManageResidency = false;
            }
            if (createArgs.Flags2.CrossAdapter)
            {
                assert(createArgs.Flags.SharedResource);
                m_TranslationLayerCreateArgs.m_heapDesc.Properties = CD3DX12_HEAP_PROPERTIES(D3D12_CPU_PAGE_PROPERTY_NOT_AVAILABLE, D3D12_MEMORY_POOL_L0);
                m_TranslationLayerCreateArgs.m_heapDesc.Flags |= D3D12_HEAP_FLAG_SHARED_CROSS_ADAPTER;
                m_TranslationLayerCreateArgs.m_desc12.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;
                m_TranslationLayerCreateArgs.m_desc12.Flags |= D3D12_RESOURCE_FLAG_ALLOW_CROSS_ADAPTER;
            }

            m_TranslationLayerCreateArgs.m_flags11.BindFlags = ConvertTranslationLayerBindFlagsToD3D11BindFlags(bindFlags);
            if (createArgs.Flags.SharedResource)
            {
                // The DX9 runtime only works with GDI handles but DX12 defaults to returning NT handles,
                // therefore we need to mark this flag so that 9on12 can open handles from other 9on12 devices
                m_TranslationLayerCreateArgs.m_flags11.MiscFlags = D3D11_RESOURCE_MISC_SHARED;
                if (createArgs.Flags2.IsDisplayable || createArgs.Flags2.CrossAdapter)
                {
                    // TODO: This info really needs to be passed to 9on12 via side-channel rather than us guessing it
                    m_TranslationLayerCreateArgs.m_flags11.MiscFlags |= D3D11_RESOURCE_MISC_SHARED_NTHANDLE;
                }
                if (createArgs.Flags2.IsDisplayable)
                {
                    m_TranslationLayerCreateArgs.m_bTriggerDeferredWaits = true;
                }
            }

            if (createArgs.Flags.DecodeRenderTarget)
            {
                m_TranslationLayerCreateArgs.m_desc12.Flags |= D3D12_RESOURCE_FLAG_ALLOW_SIMULTANEOUS_ACCESS;
            }

            if (m_dx9Format == D3DFMT_YV12)
            {
                m_TranslationLayerCreateArgs.m_FormatEmulation = D3D12TranslationLayer::FormatEmulation::YV12;
            }

            if (pAlreadyCreatedResource)
            {
                m_pResource = std::move(pAlreadyCreatedResource);
            }
            else
            {
                CreateUnderlyingResource(m_TranslationLayerCreateArgs, createArgs);
            }

            if (SUCCEEDED(hr))
            {
                // DXGI swapchain resources aren't created as typeless resources so we can't
                // make a view with the SRGB variant of the resource format
                if (NeedsRenderTarget(createArgs.Flags, createArgs.Pool))
                {
                    CreateRenderTargetViews(m_ViewFormat, GenerateSRGBViews);
                }

                if (NeedsDepthStencil(createArgs.Flags, createArgs.Pool))
                {
                    CreateDepthStencilViews();
                }

                if (NeedsShaderResourceView(createArgs.Flags, createArgs.Pool))
                {
                    m_shaderResourceViews[ShaderResourceViewFlags::None] = std::unique_ptr<D3D12TranslationLayer::SRV>(
                        CreateShaderResourceView(ShaderResourceViewFlags::None));
                    m_srvTextureType = ConvertShaderResourceDimensionToTextureType(m_shaderResourceViews[ShaderResourceViewFlags::None]->GetDesc12().ViewDimension);

                    if (GenerateSRGBViews)
                    {
                        m_shaderResourceViews[ShaderResourceViewFlags::SRGBEnabled] = std::unique_ptr<D3D12TranslationLayer::SRV>(
                            CreateShaderResourceView(ShaderResourceViewFlags::SRGBEnabled));
                    }
                }

                if (NeedsVideoDecoderOutputView(createArgs.Flags, createArgs.Pool))
                {
                    CreateVideoDecoderOutputViews();
                }

                if (NeedsVideoProcessorOutputView(createArgs.Flags, createArgs.Pool))
                {
                    CreateVideoProcessorOutputViews();
                }
            }
        }
        else
        {
            m_pResource = nullptr;
        }

        return hr;
    }

    HRESULT Resource::OpenResource(D3DKMT_HANDLE kmtHandle, void *pPrivateResourceDriverData, UINT privateResourceDriverDataSize, D3D9ON12_OPEN_RESOURCE_ARGS *pD3d9on12Args)
    {
        HRESULT hr = S_OK;

        D3D12TranslationLayer::ResourceInfo resourceInfo;
        GetParent()->GetSharedResourceHelper().QueryResourceInfoFromKMTHandle(kmtHandle, nullptr, &resourceInfo);

        Check9on12(resourceInfo.m_Type == D3D12TranslationLayer::ResourceInfoType::ResourceType);
        D3D12TranslationLayer::ResourceCreationArgs CreateArgs = GetCreateArgsFromExistingResource(&GetParent()->GetDevice(), resourceInfo.Resource.m_ResourceDesc);

        auto spResource = GetParent()->GetSharedResourceHelper().OpenResourceFromKmtHandle(
            CreateArgs,
            kmtHandle,
            pPrivateResourceDriverData,
            privateResourceDriverDataSize,
            D3D12_RESOURCE_STATE_COMMON);
        Init(std::move(spResource), pD3d9on12Args, true);

        return hr;
    }

    void Resource::ClearAllPlanesInArraySlice(_In_ UINT arrayIndex, _In_ const RECT* dstRects, _In_ UINT numRects, _In_ D3DCOLOR  Color)
    {
        if (m_videoDecoderOutputViews.size() > 0)
        {
            Check9on12(m_videoDecoderOutputViews[arrayIndex] != nullptr);
            DirectX::XMFLOAT4 col = ARGBToUNORMFloat(Color);

            m_pParentDevice->GetContext().ClearVideoDecoderOutputView(m_videoDecoderOutputViews[arrayIndex].get(), (float*)&col, numRects, dstRects);
        }
        else if (m_videoProcessorOutputViews.size() > 0)
        {
            Check9on12(m_videoProcessorOutputViews[arrayIndex] != nullptr);
            DirectX::XMFLOAT4 col = ARGBToUNORMFloat(Color);

            m_pParentDevice->GetContext().ClearVideoProcessorOutputView(m_videoProcessorOutputViews[arrayIndex].get(), (float*)&col, numRects, dstRects);
        }
        else
        {
            // Not supporting clears used on planar resources that aren't marked for video yet
            Check9on12(m_renderTargetViews.size() == 0);
        }
    }

    HRESULT Resource::Clear(_In_ UINT SubResourceIndex, _In_ const RECT *dstRects, _In_ UINT numRects, _In_ D3DCOLOR  Color)
    {
        DirectX::XMFLOAT4 col = ARGBToUNORMFloat(Color);
        if (NeedsSwapRBOutputChannels())
        {
            std::swap(col.x, col.z);
        }
        if (m_renderTargetViews.size() > 0)
        {
            Check9on12(m_renderTargetViews[SubResourceIndex] != nullptr);

            // From MSDN: D3DRS_SRGBWRITEENABLE is honored while performing a clear of the render target
            bool srgbEnabled = m_pParentDevice->GetPipelineState().GetPixelStage().GetSRGBWriteEnable();
            m_pParentDevice->GetContext().ClearRenderTargetView(GetRenderTargetView(SubResourceIndex, srgbEnabled), (float*)&col, numRects, dstRects);
        }
        
        else
        {
            m_pParentDevice->GetContext().ClearResourceWithNoRenderTarget(GetUnderlyingResource(), (float*)&col, numRects, dstRects, SubResourceIndex, SubResourceIndex, m_ViewFormat);
        }

        return S_OK;
    }

    HRESULT Resource::ClearDepthStencil(UINT flag, _In_ const RECT *dstRects, _In_ UINT numRects, float depthValue, UINT stencilValue)
    {
        Check9on12(flag & (D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL));
        Check9on12(m_pDepthStencilViews[D3D12_DSV_FLAG_NONE] != nullptr);

        D3D12_CLEAR_FLAGS clearFlag = {};
        if (flag & D3DCLEAR_ZBUFFER)
        {
            clearFlag |= D3D12_CLEAR_FLAG_DEPTH;
        }

        if (flag & D3DCLEAR_STENCIL)
        {
            clearFlag |= D3D12_CLEAR_FLAG_STENCIL;
        }

        m_pParentDevice->GetContext().ClearDepthStencilView(m_pDepthStencilViews[D3D12_DSV_FLAG_NONE], clearFlag, depthValue, static_cast<UINT8>(stencilValue), numRects, dstRects);

        return S_OK;
    }

    UINT Resource::ConvertAppSubresourceToDX12Subresource(UINT appIndex)
    {
        if (m_NonOpaquePlaneCount > 1)
        {
            // This should never get called in cases where the resource could be planar.
            // ConvertAppSubresourceToDX12SubresourceIndices should be used instead and the 
            // caller should be modified to handle planar subresources
            Check9on12(false);
            return (UINT)-1;
        }

        return ConvertAppSubresourceToDX12SubresourceInternal(appIndex, 0, false);
    }

    void Resource::ConvertAppSubresourceToDX12SubresourceIndices(
        _In_ UINT appIndex,
        _Out_writes_(MAX_PLANES) UINT *pSubresourceIndices,
        _Out_range_(0, MAX_PLANES) UINT &planeCountToMap,
        bool bMipAlreadyExpanded)
    {
        planeCountToMap = m_NonOpaquePlaneCount;
        Check9on12(planeCountToMap <= MAX_PLANES);
        ASSUME(planeCountToMap <= MAX_PLANES);

        for (UINT i = 0; i < planeCountToMap; i++)
        {
            pSubresourceIndices[i] = ConvertAppSubresourceToDX12SubresourceInternal(appIndex, i, bMipAlreadyExpanded);
        }
    }

    UINT Resource::ConvertAppSubresourceToDX12SubresourceInternal(UINT appIndex, UINT planeIndex, bool bMipAlreadyExpanded)
    {
        // Calculate subresource for plane 0, then use D3D12CalcSubresource to account for plane Index
        UINT subresource = appIndex;
        if (m_mipMapsHiddenFromApp && !bMipAlreadyExpanded)
        {
            subresource *= m_logicalDesc.MipLevels;
        }

        return D3D12CalcSubresource(
            GetMipLevelFromSubresourceIndex(subresource), 
            GetArraySliceFromSubresourceIndex(subresource), 
            planeIndex, 
            m_logicalDesc.MipLevels, 
            GetArraySize());
    }


    HRESULT Resource::Lock(Device &device,
        _In_ UINT subresourceIndex,
        _In_ D3DDDI_LOCKFLAGS flags,
        _In_ LockRange lockRange,
        _In_ bool bAsyncLock,
        _Out_ VOID* &pSurfData,
        _Out_ UINT &pitch,
        _Out_ UINT &slicePitch,
        _Out_opt_ HANDLE *phCookie)
    {
        Check9on12(m_IsLockable);
        //TODO: When they do a lock discard combined with a 'MightDrawFromLocked' flag
        //      we might have to version the buffer.
        if (flags.MightDrawFromLocked && flags.Discard)
        {
            PrintDebugMessage("Warning: Lock with flags 'MightDrawFromLocked' and 'Discard'. This is not implemented properly");
        }

        if (flags.NotifyOnly)
        {
            Check9on12(IsSystemMemory());
            return S_OK;
        }

        if (m_lockData[subresourceIndex].m_LockCount == 0)
        {
            m_lockData[subresourceIndex].m_Flags = flags;
        }
        else
        {
            // DX9 has a strange pattern where it allows recursive locks, but
            // recursive locks are expected to ignore what the runtime passed
            // in and stick with the properties set by the first lock call
            flags = m_lockData[subresourceIndex].m_Flags;
        }

        Check9on12(!IsSystemMemory()); // System memory should only use notify only

        D3D12TranslationLayer::MAP_TYPE mapType = D3D12TranslationLayer::MAP_TYPE_READ;

        // In the async case, we need to make sure that we don't touch m_pResource's identity,
        // as this could be changing out from under us. However, m_pResource is safe to query
        // information from. Instead of using m_pResource's identity, use m_LastRenamedResource.
        D3D12TranslationLayer::SafeRenameResourceCookie pCookieProtector;
        if (bAsyncLock)
        {
            // TODO: (11369816) Not supporting lock async with non-buffers or CPU readable resources
            if ((!flags.Discard && !flags.NoOverwrite) ||
                (m_CpuAccessFlags & D3D12TranslationLayer::RESOURCE_CPU_ACCESS_READ) ||
                m_logicalDesc.Dimension != D3D12_RESOURCE_DIMENSION_BUFFER)
            {
                // Not supporting LockAsync operations that would require synchronization
                return E_NOTIMPL;
            }

            // Taken from the dx9 runtime:
            // D3DLOCK_DISCARD is allowed only on level 0 (the top mip level). DISCARD in this case will discard the entire mipmap.
            // Additionally, since we're only supporting buffers at the moment, only subresource 0 should make it this far.
            Check9on12(subresourceIndex == 0);
            if (flags.Discard)
            {
                Check9on12(phCookie != nullptr);

                // Only rename on the first lock, recursive locks should just use the last renamed resource
                if (m_lockData[subresourceIndex].m_LockCount == 0)
                {
                    pCookieProtector.Reset(device.GetContext().CreateRenameCookie(m_pResource.get(), D3D12TranslationLayer::ResourceAllocationContext::FreeThread));
                    *phCookie = pCookieProtector.Get();

                    m_LastRenamedResource = pCookieProtector.Get()->GetIdentity()->m_suballocation;
                }
            }
            else if (m_LastRenamedResource.GetResource() == nullptr)
            {
                return E_NOTIMPL; // Don't fall through to reading m_pResource
            }
            else
            {
                Check9on12(flags.NoOverwrite == true);
            }
        }

        bool bSubrangeLocked = IsLockingSubrange<D3DDDI_LOCKFLAGS>(flags);
        D3D12_BOX *pBox = nullptr;
        if (bSubrangeLocked)
        {
            pBox = &m_lockData[subresourceIndex].m_Box;
            if (flags.RangeValid)
            {
                *pBox = CD3DX12_BOX(lockRange.Range.Offset, lockRange.Range.Size + lockRange.Range.Offset);
            }
            else if (flags.AreaValid)
            {
                *pBox = CD3DX12_BOX(lockRange.Area.left, lockRange.Area.top, lockRange.Area.right, lockRange.Area.bottom);
            }
            else if (flags.BoxValid)
            {
                *pBox = CD3DX12_BOX(lockRange.Box.Left, lockRange.Box.Top, lockRange.Box.Front, lockRange.Box.Right, lockRange.Box.Bottom, lockRange.Box.Back);
            }
            // Validation of ranges/rects/boxes is debug-only in 9, so apps can pass whatever they want and get away with it.
            // Sanitize it here.
            pBox->left = min(pBox->left, (UINT)m_logicalDesc.Width);
            pBox->right = min(pBox->right, (UINT)m_logicalDesc.Width);
            pBox->top = min(pBox->top, m_logicalDesc.Height);
            pBox->bottom = min(pBox->bottom, m_logicalDesc.Height);
            // The front/back should be 0/1 for non-volumes anyway, which is in the range of 0->ArraySize.
            pBox->front = min(pBox->front, (UINT)m_logicalDesc.DepthOrArraySize);
            pBox->back = min(pBox->back, (UINT)m_logicalDesc.DepthOrArraySize);
        }

        mapType = GetMapTypeFlag(flags.ReadOnly, flags.WriteOnly, flags.Discard, flags.NoOverwrite, m_isDecodeCompressedBuffer, m_pResource->AppDesc()->CPUAccessFlags());

        if (RegistryConstants::g_cLockDiscardOptimization)
        {
            if (mapType == D3D12TranslationLayer::MAP_TYPE_WRITE_DISCARD)
            {
                // Range not valid means the whole resource is mapped
                if(!flags.RangeValid)
                {
                    lockRange.Range.Offset = 0;
                    assert(this->m_totalSize <= UINT_MAX); // For casting below
                    lockRange.Range.Size = (UINT) this->m_totalSize;
                }

                // Check if buffer is in the map
                // If it is, get a list of previously mapped ranges

                auto lockedResourceRanges = device.m_lockedResourceRanges.GetLocked();
                auto it = lockedResourceRanges->find(this);
                if (it != lockedResourceRanges->end()) {

                    // it->second has the mapped ranges vector corresponding to it->first == this

                    bool overlapsWithPreviouslyMappedRanges = false;
                    bool mergedWithExistingMappedRange = false;

                    UINT currentRangeStart = lockRange.Range.Offset;
                    UINT currentRangeEnd = lockRange.Range.Offset + lockRange.Range.Size;

                    // Compare current range with previously mapped ranges
                    for (auto& mappedRange : it->second)
                    {
                        UINT mappedRangeStart = mappedRange.Range.Offset;
                        UINT mappedRangeEnd = mappedRange.Range.Offset + mappedRange.Range.Size;

                        if (((currentRangeStart >= mappedRangeStart) && (currentRangeStart < mappedRangeEnd)) ||
                            ((currentRangeEnd >= mappedRangeStart) && (currentRangeEnd < mappedRangeEnd)))
                        {
                            overlapsWithPreviouslyMappedRanges = true;
                            break;
                        }

                        // If the current range is a neighbor of an existing mapped range, merge it with the neighbor
                        if (currentRangeStart == mappedRangeEnd)
                        {
                            mappedRange.Range.Size += lockRange.Range.Size;

                            mergedWithExistingMappedRange = true;
                            break;
                        }
                        if (currentRangeEnd == mappedRangeStart)
                        {
                            mappedRange.Range.Offset = lockRange.Range.Offset;
                            mappedRange.Range.Size += lockRange.Range.Size;

                            mergedWithExistingMappedRange = true;
                            break;
                        }
                    }

                    // If the newly mapped range doesn't intersect previously mapped ranges - add it to the list and change flag to NO_OVERWRITE
                    if (!overlapsWithPreviouslyMappedRanges)
                    {
                        mapType = D3D12TranslationLayer::MAP_TYPE_WRITE_NOOVERWRITE;
                    }
                    else // Else clear the list of ranges, add the current range, and keep the DISCARD flag
                    {
                        it->second.clear();
                    }

                    if (!mergedWithExistingMappedRange)
                    {
                        it->second.push_back(lockRange);
                    }
                }
                else
                {
                    std::vector<LockRange> lockedRange = { lockRange };
                    lockedResourceRanges->insert({ this, lockedRange });
                }
            }
        }

        if (bAsyncLock)
        {
            CD3DX12_RANGE ReadRange(0, 0);
            void* pMappedData;
            m_LastRenamedResource.Map(0, &ReadRange, &pMappedData);

            assert(subresourceIndex == 0); // Means pointer doesn't need to be offset beyond suballocation.
            assert(m_logicalDesc.Dimension == D3D12_RESOURCE_DIMENSION_BUFFER);
            pSurfData = (byte*)pMappedData + (pBox ? pBox->left : 0u);
            pitch = m_pResource->GetSubresourcePlacement(subresourceIndex).Footprint.RowPitch;
            slicePitch = static_cast<UINT>(m_pResource->DepthPitch(subresourceIndex));
        }
        else
        {
            D3D12TranslationLayer::MappedSubresource mappedData = {};
            bool bResourceMapped = device.GetContext().Map(m_pResource.get(), subresourceIndex, mapType, flags.DoNotWait, pBox, &mappedData);
            if (!bResourceMapped)
            {
                return D3DERR_WASSTILLDRAWING;
            }
            pSurfData = (byte*)mappedData.pData;
            pitch = static_cast<UINT>(mappedData.RowPitch);
            slicePitch = static_cast<UINT>(mappedData.DepthPitch);
        }

        //We had better of got some data to return
        Check9on12(pSurfData);
         
        if (mapType != D3D12TranslationLayer::MAP_TYPE::MAP_TYPE_READ)
        {
            NotifyResourceChanged();
        }

        // No more exceptions
        m_lockData[subresourceIndex].m_LockCount++;
        pCookieProtector.Detach();
        return S_OK;
    }

    void Resource::Unlock(Device &device, UINT subresourceIndex, D3DDDI_UNLOCKFLAGS flags, bool bAsyncUnlock)
    { 
        if (flags.NotifyOnly)
        {
            Check9on12(IsSystemMemory());
            return;
        }
        Check9on12(m_lockData[subresourceIndex].m_LockCount > 0);
        m_lockData[subresourceIndex].m_LockCount--;

        const D3DDDI_LOCKFLAGS &lockFlags = m_lockData[subresourceIndex].m_Flags;
        bool bLockingSubrange = IsLockingSubrange<D3DDDI_LOCKFLAGS>(lockFlags);
        const D3D12_BOX *pReadWriteBox = (bLockingSubrange) ? &m_lockData[subresourceIndex].m_Box : nullptr;
        
        // In the async case, we need to make sure that we don't touch m_pResource's identity,
        // as this could be changing out from under us. However, m_pResource is safe to query
        // information from. Instead of using m_pResource's identity, use m_LastRenamedResource.
        D3D12TranslationLayer::Resource *pResourceToUnmap = m_pResource.get();
        if (bAsyncUnlock && m_LastRenamedResource.GetResource())
        {
            D3D12_RANGE WrittenRange = CD3DX12_RANGE(0u, static_cast<SIZE_T>(m_desc.Width));
            m_LastRenamedResource.Unmap(0, &WrittenRange);
        }
        else
        {
            D3D12TranslationLayer::MAP_TYPE mapType = GetMapTypeFlag(lockFlags.ReadOnly, lockFlags.WriteOnly, lockFlags.Discard, lockFlags.NoOverwrite, m_isDecodeCompressedBuffer, pResourceToUnmap->AppDesc()->CPUAccessFlags());
            device.GetContext().Unmap(pResourceToUnmap, subresourceIndex, mapType, pReadWriteBox);
        }
    }

    HRESULT Resource::PreBind()
    {
        return S_OK;
    }

    void Resource::GetTriFanIB(_Out_ InputBuffer& convertedIB, _In_ UINT indexOffsetInBytes, _In_ UINT indexCount, _In_ UINT ibStride)
    {
        if (IsTriangleFanIBCacheDirty(indexOffsetInBytes))
        {
            D3D12TranslationLayer::Resource *pMappableIndexBuffer = GetUnderlyingResource();

            // If the index buffer doesn't have CPU read access, allocate a staging resource and copy the index buffer
            // to the staging resource
            unique_comptr<D3D12TranslationLayer::Resource> pReadbackBuffer;
            if ((GetUnderlyingResource()->AppDesc()->CPUAccessFlags() & D3D12TranslationLayer::RESOURCE_CPU_ACCESS_READ) == 0)
            {
                pReadbackBuffer = std::move(GetStagingCopy());
                pMappableIndexBuffer = pReadbackBuffer.get();
            }

            // Read from GPU and set a flag to unmap this after the draw operations
            D3D12TranslationLayer::MappedSubresource MappedResult;
            m_pParentDevice->GetContext().Map(pMappableIndexBuffer, 0, D3D12TranslationLayer::MAP_TYPE_READ, false, nullptr, &MappedResult);
            const void* pSrcIndexBuffer = (void *)MappedResult.pData;

            D3D9on12::InputAssembly::CreateTriangleListIBFromTriangleFanIB(*m_pParentDevice, pSrcIndexBuffer, ibStride, indexOffsetInBytes, indexCount, convertedIB);
            UpdateTriangleFanIBCache(convertedIB, indexOffsetInBytes);

            m_pParentDevice->GetContext().Unmap(pMappableIndexBuffer, 0, D3D12TranslationLayer::MAP_TYPE_READ, nullptr);
        }
        else
        {
            // We can use the previously stored converted index buffer since the resource hasn't changed since the last conversion.
            convertedIB = m_TriFanIBCache.m_TriangleFanConvertedTriangleListIndexBuffer;
        }
    }

    bool Resource::IsTriangleFanIBCacheDirty(UINT baseIndexLocation)
    {
        return  (m_TriFanIBCache.m_dirtyFlag) ||
            (baseIndexLocation != m_TriFanIBCache.m_baseIndexOffsetInBytes);
    }

    void Resource::UpdateTriangleFanIBCache(InputBuffer& newIBToStore, UINT indexOffsetInBytes)
    {
        m_TriFanIBCache.m_TriangleFanConvertedTriangleListIndexBuffer = newIBToStore;
        m_TriFanIBCache.m_baseIndexOffsetInBytes = indexOffsetInBytes;
        m_TriFanIBCache.m_dirtyFlag = false;
    }

    void Resource::NotifyResourceChanged()
    {
        m_TriFanIBCache.m_baseIndexOffsetInBytes = 0;
        m_TriFanIBCache.m_dirtyFlag = true;
    }

    D3D12_PLACED_SUBRESOURCE_FOOTPRINT &Resource::GetSubresourceFootprint(UINT subresource)
    {
        Check9on12(subresource < m_physicalLinearRepresentation.m_footprints.size());
        return m_physicalLinearRepresentation.m_footprints[subresource];
    }

    HRESULT Resource::GenerateMips(D3DDDITEXTUREFILTERTYPE filterType)
    {
        Check9on12(GetShaderResourceView() != nullptr);

        D3D12_FILTER_TYPE filterD3D12 = ConvertD3D9GenMipsFilterType(filterType);
        m_pParentDevice->GetContext().GenMips(GetShaderResourceView(), filterD3D12);

        return S_OK;
    }

    ShaderConv::TEXTURETYPE Resource::GetShaderResourceTextureType() {
        Check9on12(GetShaderResourceView() != nullptr);

        return m_srvTextureType;
    }

    unique_comptr<D3D12TranslationLayer::Resource> Resource::GetStagingCopy()
    {
        D3D12TranslationLayer::ResourceCreationArgs args = *GetUnderlyingResource()->Parent();
        args.m_heapDesc.Properties = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_READBACK);
        D3D12TranslationLayer::AppResourceDesc &origAppDesc = args.m_appDesc;
        args.m_appDesc = D3D12TranslationLayer::AppResourceDesc(
            origAppDesc.SubresourcesPerPlane(),
            origAppDesc.NonOpaquePlaneCount(),
            origAppDesc.Subresources(),
            origAppDesc.MipLevels(),
            origAppDesc.ArraySize(),
            origAppDesc.Depth(),
            origAppDesc.Width(),
            origAppDesc.Height(),
            origAppDesc.Format(),
            origAppDesc.Samples(),
            origAppDesc.Quality(),
            D3D12TranslationLayer::RESOURCE_USAGE_STAGING,
            D3D12TranslationLayer::RESOURCE_CPU_ACCESS_READ,
            (D3D12TranslationLayer::RESOURCE_BIND_FLAGS)0,
            origAppDesc.ResourceDimension());
            

        auto pResource = D3D12TranslationLayer::Resource::CreateResource(
            &m_pParentDevice->GetContext(), args, D3D12TranslationLayer::ResourceAllocationContext::ImmediateContextThreadTemporary);

        m_pParentDevice->GetContext().ResourceCopy(pResource.get(), GetUnderlyingResource());
        return std::move(pResource);
    }

    Resource *Resource::GetBackingPlainResource(bool bDoNotCreateAsTypelessResource)
    {
        const bool isVolumeTexture = (m_logicalDesc.Dimension == D3D12_RESOURCE_DIMENSION_TEXTURE3D);
        if (!m_pBackingShaderResource)
        {
            HANDLE tempHandle = {};
            m_pBackingShaderResource = new Resource(tempHandle, m_pParentDevice);

            UINT depth = isVolumeTexture ? m_logicalDesc.DepthOrArraySize : 1;
            UINT arraySize = isVolumeTexture ? 1 : m_logicalDesc.DepthOrArraySize;

            D3DDDI_RESOURCEFLAGS flags = {};
            flags.Texture = 1;
            D3DFORMAT format = m_dx9Format;
            if (NeedsSwapRBOutputChannels())
            {
                // Make the dest the underlying format so that it'll trigger
                // StretchCopy's logic for correcting channels
                format = GetFormatWithSwappedRBChannels(m_dx9Format);
            }
            m_pBackingShaderResource->Init((UINT)m_logicalDesc.Width, (UINT)m_logicalDesc.Height, format, flags, m_logicalDesc.MipLevels, depth, arraySize, bDoNotCreateAsTypelessResource);
        }

        ResourceCopyArgs copyArgs(*m_pBackingShaderResource, *this);
        if (isVolumeTexture)
        {
            D3D12_BOX srcBox = BoxFromDesc(m_logicalDesc);
            copyArgs.AsVolumeBlit(0, 0, 0, srcBox);
            CopyResource(*m_pParentDevice, copyArgs);
        }
        else
        {
            RECT dstRect = RectThatCoversEntireResource(m_pBackingShaderResource->GetDesc());
            copyArgs.AsTextureBlit({}, dstRect);
            CopyResource(*m_pParentDevice, copyArgs);
        }

        return m_pBackingShaderResource;
    }

    bool Resource::IsSRGBCompatibleTexture()
    {
        DXGI_FORMAT format = GetLogicalDesc().Format;
        return IsTypelessFormat(format) && IsSRGBCompatible(format);
    }

    D3D12TranslationLayer::SRV* Resource::GetShaderResourceView(DWORD flags)
    {
        D3D12TranslationLayer::SRV* pSRV = nullptr;

        // Apps can set SRGB mode on a texture which can't be SRGB so just return the normal view.
        if ((flags & ShaderResourceViewFlags::SRGBEnabled) && IsSRGBCompatibleTexture())
        {
            flags &= ~ShaderResourceViewFlags::SRGBEnabled;
        }

        // If there's only 1 mip, there's no need to create a special SRV for disabling mips
        if ((flags & ShaderResourceViewFlags::DisableMips) && m_logicalDesc.MipLevels == 1)
        {
            flags &= ~ShaderResourceViewFlags::DisableMips;
        }

        pSRV = m_shaderResourceViews[flags].get();
        if (!pSRV && (m_pResource->AppDesc()->BindFlags() & D3D12TranslationLayer::RESOURCE_BIND_SHADER_RESOURCE))
        {
            m_shaderResourceViews[flags] = std::unique_ptr<D3D12TranslationLayer::SRV>(CreateShaderResourceView((ShaderResourceViewFlags)flags));
            pSRV = m_shaderResourceViews[flags].get();
        }

        return pSRV;
    }

    D3D12TranslationLayer::RTV* Resource::GetRenderTargetView(UINT subresourceIndex, bool srgbEnabled)
    {
        if ((m_desc.Flags & D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET) == 0)
        {
            Check9on12(m_renderTargetViews.size() == 0);
            Check9on12(m_SRGBRenderTargetViews.size() == 0);
            return nullptr;
        }
        else
        {
            // Ignore srgbEnabled if the format isn't compatible. From MSDN:
            // "Only the formats that pass the CheckDeviceFormat with the usage flag D3DUSAGE_QUERY_SRGBWRITE 
            // can be linearized. The render state D3DRS_SRGBWRITEENABLE is ignored for the rest."
            // https://msdn.microsoft.com/en-us/library/windows/desktop/bb173460(v=vs.85).aspx
            if (srgbEnabled && IsSRGBCompatible(m_desc.Format))
            {
                Check9on12(subresourceIndex < m_SRGBRenderTargetViews.size());
                return m_SRGBRenderTargetViews[subresourceIndex].get();
            }
            else
            {
                Check9on12(subresourceIndex < m_renderTargetViews.size());
                return m_renderTargetViews[subresourceIndex].get();
            }
        }
    }

    void Resource::CreateRenderTargetViews(DXGI_FORMAT rtvFormat, bool GenerateSRGBRTV)
    {
        Check9on12(m_logicalDesc.Dimension == D3D12_RESOURCE_DIMENSION_TEXTURE2D);
        const bool srgbCompatible = IsSRGBCompatible(rtvFormat);
        GenerateSRGBRTV = GenerateSRGBRTV && srgbCompatible;

        m_renderTargetViews = std::vector<std::unique_ptr<D3D12TranslationLayer::RTV>>(m_numSubresources);
        if (GenerateSRGBRTV)
        {
            m_SRGBRenderTargetViews = std::vector<std::unique_ptr<D3D12TranslationLayer::RTV>>(m_numSubresources);
        }

        D3D12_RENDER_TARGET_VIEW_DESC rtvDesc = {};

        UINT subresourceIndex = 0;
        for (UINT arraySlice = 0; arraySlice < GetArraySize(); arraySlice++)
        {
            for (UINT mipLevel = 0; mipLevel < m_logicalDesc.MipLevels; mipLevel++)
            {
                if (m_logicalDesc.DepthOrArraySize > 1)
                {
                    if (m_logicalDesc.SampleDesc.Count > 1)
                    {
                        rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2DMS;
                        rtvDesc.Texture2DMSArray.ArraySize = 1;
                        rtvDesc.Texture2DMSArray.FirstArraySlice = arraySlice;
                    }
                    else
                    {
                        rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2DARRAY;
                        rtvDesc.Texture2DArray.MipSlice = mipLevel;
                        rtvDesc.Texture2DArray.FirstArraySlice = arraySlice;
                        rtvDesc.Texture2DArray.ArraySize = 1;
                        rtvDesc.Texture2DArray.PlaneSlice = 0;
                    }
                }
                else
                {
                    if (m_logicalDesc.SampleDesc.Count > 1)
                    {
                        assert(m_logicalDesc.MipLevels == 1);
                        rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2DMS;
                    }
                    else
                    {
                        rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2D;
                        rtvDesc.Texture2D.MipSlice = mipLevel;
                        rtvDesc.Texture2D.PlaneSlice = 0;
                    }
                }

                Check9on12(subresourceIndex < m_renderTargetViews.size());

                rtvDesc.Format = rtvFormat;
                m_renderTargetViews[subresourceIndex] = std::unique_ptr<D3D12TranslationLayer::RTV>(
                    new D3D12TranslationLayer::RTV(&m_pParentDevice->GetContext(), rtvDesc, *m_pResource));

                if (GenerateSRGBRTV)
                {
                    rtvDesc.Format = ConvertToSRGB(rtvFormat);
                    m_SRGBRenderTargetViews[subresourceIndex] = std::unique_ptr<D3D12TranslationLayer::RTV>(
                        new D3D12TranslationLayer::RTV(&m_pParentDevice->GetContext(), rtvDesc, *m_pResource));
                }
                subresourceIndex++;
            }
        }
    }

    void Resource::CreateVideoDecoderOutputViews()
    {
        Check9on12(m_logicalDesc.Dimension == D3D12_RESOURCE_DIMENSION_TEXTURE2D);
        Check9on12(m_logicalDesc.MipLevels == 1);

        m_videoDecoderOutputViews = std::vector<std::unique_ptr<D3D12TranslationLayer::VDOV>>(GetArraySize());

        D3D12TranslationLayer::VIDEO_DECODER_OUTPUT_VIEW_DESC_INTERNAL viewDesc = {};
        viewDesc.Format = m_desc.Format;

        for (UINT arraySlice = 0; arraySlice < GetArraySize(); arraySlice++)
        {
            viewDesc.ArraySlice= arraySlice;
            m_videoDecoderOutputViews[arraySlice] = std::unique_ptr<D3D12TranslationLayer::VDOV>(
                new D3D12TranslationLayer::VDOV(&m_pParentDevice->GetContext(), viewDesc, *m_pResource));
        }
    }

    void Resource::CreateVideoProcessorOutputViews()
    {
        Check9on12(m_logicalDesc.Dimension == D3D12_RESOURCE_DIMENSION_TEXTURE2D);
        Check9on12(m_logicalDesc.MipLevels == 1);

        m_videoProcessorOutputViews = std::vector<std::unique_ptr<D3D12TranslationLayer::VPOV>>(GetArraySize());

        D3D12TranslationLayer::VIDEO_PROCESSOR_OUTPUT_VIEW_DESC_INTERNAL viewDesc = {};
        viewDesc.Format = m_desc.Format;
        viewDesc.MipSlice = 0;
        viewDesc.ArraySize = GetArraySize();

        for (UINT arraySlice = 0; arraySlice < GetArraySize(); arraySlice++)
        {
            viewDesc.FirstArraySlice = arraySlice;
            m_videoProcessorOutputViews[arraySlice] = std::unique_ptr<D3D12TranslationLayer::VPOV>(
                new D3D12TranslationLayer::VPOV(&m_pParentDevice->GetContext(), viewDesc, *m_pResource));
        }
    }

    D3D12TranslationLayer::DSV* & Resource::GetDepthStencilView(D3D12_DSV_FLAGS flags)
    {
        Check9on12(flags < _countof(g_cPossibleDepthStencilStates));
        // If we don't have a stencil plane, we can ignore DSV_STENCIL_READ_ONLY
        const UINT DSVIndex = FormatSupportsStencil(m_dsvFormat) ? flags : (flags & D3D12_DSV_FLAG_READ_ONLY_DEPTH);
        return m_pDepthStencilViews[DSVIndex];
    }

    void Resource::CreateDepthStencilViews()
    {
        m_dsvFormat = m_ViewFormat;

        for (size_t i = 0; i < _countof(g_cPossibleDepthStencilStates); i++)
        {
            D3D12_DSV_FLAGS flag = g_cPossibleDepthStencilStates[i];

            if ((flag & D3D12_DSV_FLAG_READ_ONLY_STENCIL) && FormatSupportsStencil(m_ViewFormat) == false)
            {
                continue;
            }
            Check9on12(m_numArrayLevels == 1); // Not supporting DSV cubemaps yet
            D3D12_DEPTH_STENCIL_VIEW_DESC dsvDesc = {};
            dsvDesc.Format = m_ViewFormat;
            dsvDesc.Flags = flag;
            switch (m_logicalDesc.Dimension)
            {
                case D3D12_RESOURCE_DIMENSION_TEXTURE2D:
                {
                    if (m_logicalDesc.SampleDesc.Count > 1)
                    {
                        dsvDesc.ViewDimension = D3D12_DSV_DIMENSION_TEXTURE2DMS;
                    }
                    else
                    {
                        dsvDesc.ViewDimension = D3D12_DSV_DIMENSION_TEXTURE2D;
                        dsvDesc.Texture2D.MipSlice = 0;
                    }
                    break;
                }
                case D3D12_RESOURCE_DIMENSION_TEXTURE1D:
                case D3D12_RESOURCE_DIMENSION_TEXTURE3D:
                case D3D12_RESOURCE_DIMENSION_UNKNOWN:
                case D3D12_RESOURCE_DIMENSION_BUFFER:
                default:
                {
                    Check9on12(FALSE);
                    break;
                }
            }

            m_pDepthStencilViews[i] = new (m_depthStencilViewSpace + i * sizeof(D3D12TranslationLayer::DSV)) D3D12TranslationLayer::DSV(&m_pParentDevice->GetContext(), dsvDesc, *m_pResource);
        }
    }

    void Resource::InitializeSRVDescFormatAndShaderComponentMapping(_In_ D3DFORMAT d3dFormat, _Out_ D3D12_SHADER_RESOURCE_VIEW_DESC &desc, bool DisableAlphaChannel)
    {
        desc.Format = ConvertToDXGIFORMAT(d3dFormat);
        // If they intend to bind the Depth Stencil as a SRV, we need to change the format
        if (IsDepthStencilFormat(desc.Format))
        {
            desc.Format = ConvertDepthFormatToCompanionSRVFormat(desc.Format);
        }

        desc.Shader4ComponentMapping = ConvertFormatToShaderResourceViewComponentMapping(d3dFormat, DisableAlphaChannel);
    }

    D3D12_SHADER_RESOURCE_VIEW_DESC Resource::GetShaderResourceViewDescForArraySlice(UINT8 arraySlice, UINT8 arraySize)
    {
        Check9on12(GetArraySize() >= arraySlice + arraySize);
        D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {};

        InitializeSRVDescFormatAndShaderComponentMapping(m_dx9Format, srvDesc, IsAlphaChannelDisabled());

        srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2DARRAY;
        srvDesc.Texture2DArray.MostDetailedMip = 0;
        srvDesc.Texture2DArray.MipLevels = m_logicalDesc.MipLevels;
        srvDesc.Texture2DArray.FirstArraySlice = arraySlice;
        srvDesc.Texture2DArray.ArraySize = arraySize;
        srvDesc.Texture2DArray.PlaneSlice = 0;
        srvDesc.Texture2DArray.ResourceMinLODClamp = 0.0f;

        return srvDesc;
    }

    D3D12_SHADER_RESOURCE_VIEW_DESC Resource::GetShaderResourceViewDesc()
    {
        D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {};
        InitializeSRVDescFormatAndShaderComponentMapping(m_dx9Format, srvDesc, IsAlphaChannelDisabled());

        switch (m_logicalDesc.Dimension)
        {
        case D3D12_RESOURCE_DIMENSION_TEXTURE2D:
        {
            if (m_numArrayLevels == 6)
            {
                assert(m_logicalDesc.SampleDesc.Count <= 1); // D3D12 doesn't support MSAA TextureCubes
                                                             // We need to explicitly define a descriptor to say that this a texture cube 
                                                             // and not a texture array
                srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURECUBE;
                srvDesc.TextureCube.MostDetailedMip = 0;
                srvDesc.TextureCube.MipLevels = m_logicalDesc.MipLevels;
                srvDesc.TextureCube.ResourceMinLODClamp = 0.0f;
            }
            else
            {
                if (m_logicalDesc.SampleDesc.Count > 1)
                {
                    srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2DMS;
                }
                else
                {
                    srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
                    srvDesc.Texture2D.MipLevels = m_logicalDesc.MipLevels;
                    srvDesc.Texture2D.MostDetailedMip = 0;
                    srvDesc.Texture2D.PlaneSlice = 0;
                    srvDesc.Texture2D.ResourceMinLODClamp = 0.0f;
                }

            }
            break;
        }
        case D3D12_RESOURCE_DIMENSION_TEXTURE3D:
            srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE3D;
            srvDesc.Texture3D.MipLevels = m_logicalDesc.MipLevels;
            srvDesc.Texture3D.MostDetailedMip = 0;
            srvDesc.Texture3D.ResourceMinLODClamp = 0.0f;
            break;
        case D3D12_RESOURCE_DIMENSION_TEXTURE1D:
        case D3D12_RESOURCE_DIMENSION_BUFFER:
        case D3D12_RESOURCE_DIMENSION_UNKNOWN:
        default:
        {
            // DX9 does not support creating SRVs for these resource types
            Check9on12(FALSE);
            break;
        }
        }

        return srvDesc;
    }

    D3D12TranslationLayer::SRV * Resource::CreateShaderResourceView(ShaderResourceViewFlags flag)
    {
        D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = GetShaderResourceViewDesc();
        if ((flag & ShaderResourceViewFlags::SRGBEnabled) && IsSRGBCompatible(srvDesc.Format))
        {
            srvDesc.Format = ConvertToSRGB(srvDesc.Format);
        }

        if ((flag & ShaderResourceViewFlags::DisableMips))
        {
            switch (srvDesc.ViewDimension)
            {
            case D3D12_SRV_DIMENSION_BUFFER:
                // Do nothing
                break;
            case D3D12_SRV_DIMENSION_TEXTURE2D:
                srvDesc.Texture2D.MostDetailedMip = 0;
                srvDesc.Texture2D.MipLevels = 1;
                break;
            case D3D12_SRV_DIMENSION_TEXTURE2DARRAY:
                srvDesc.Texture2DArray.MostDetailedMip = 0;
                srvDesc.Texture2DArray.MipLevels = 1;
                break;
            case D3D12_SRV_DIMENSION_TEXTURE3D:
                srvDesc.Texture3D.MostDetailedMip = 0;
                srvDesc.Texture3D.MipLevels = 1;
                break;
            case D3D12_SRV_DIMENSION_TEXTURECUBE:
                srvDesc.TextureCube.MostDetailedMip = 0;
                srvDesc.TextureCube.MipLevels = 1;
                break;
            default:
                Check9on12(E_FAIL); // Unexpected dimension
            }
        }

        return new D3D12TranslationLayer::SRV(&m_pParentDevice->GetContext(), srvDesc, *m_pResource);
    }

    UINT8 Resource::GetArraySize()
    {
        if (m_logicalDesc.Dimension == D3D12_RESOURCE_DIMENSION_TEXTURE3D)
        {
            return 1;
        }
        else
        {
            return m_numArrayLevels;
        }
    }

    HANDLE Resource::GetSharedGDIHandle()
    {
        HANDLE sharedHandle = 0;
        // Try not to throw exceptions in a common case.
        if ((GetUnderlyingResource()->Parent()->IsGDIStyleHandleShared()))
        {
            m_pParentDevice->GetContext().GetSharedGDIHandle(GetUnderlyingResource(), &sharedHandle);
        }

        return sharedHandle;
    }

    HANDLE Resource::CreateSharedNTHandle(SECURITY_DESCRIPTOR *pSD)
    {
        HANDLE sharedHandle = 0;
        D3D12TranslationLayer::Resource *pUnderlyingResource = GetUnderlyingResource();
        SECURITY_ATTRIBUTES securityAttributes = ConvertSecurityDescriptorToSecurityAttributes(pSD);
        m_pParentDevice->GetContext().CreateSharedNTHandle(pUnderlyingResource, &sharedHandle, &securityAttributes);
        return sharedHandle;
    }


    UINT Resource::GetMipLevelFromSubresourceIndex(UINT subresourceIndex)
    {
        UINT mipSlice, arraySlice, planeSlice;
        D3D12DecomposeSubresource(subresourceIndex, m_logicalDesc.MipLevels, GetArraySize(), mipSlice, arraySlice, planeSlice);

        Check9on12(mipSlice < MAX_MIPS);
        return mipSlice;
    }

    UINT8 Resource::GetArraySliceFromSubresourceIndex(UINT subresourceIndex)
    {
        UINT8 arraySlice;
        UINT mipSlice, planeSlice;
        D3D12DecomposeSubresource(subresourceIndex, m_logicalDesc.MipLevels, GetArraySize(), mipSlice, arraySlice, planeSlice);
        return arraySlice;
    }

    void Resource::ResourceCompatibilityOptions::Init(D3DFORMAT format)
    {
        switch (format)
        {
        case D3DFMT_D16:
        case D3DFMT_D24X8:
        case D3DFMT_D24S8:
            m_isEligibleForHardwareShadowMapping = true;
            break;
        default:
            break;
        }
    }

    HRESULT Resource::Rename(Device& device, CONST D3DDDIARG_RENAME& arg)
    {
        HRESULT hr = S_OK;
        Check9on12(arg.SubResourceIndex == 0);

        device.GetContext().Rename(m_pResource.get(), reinterpret_cast<D3D12TranslationLayer::Resource*>(arg.hCookie));
        device.GetContext().DeleteRenameCookie(reinterpret_cast<D3D12TranslationLayer::Resource*>(arg.hCookie));

        // Discard resources should never be RTVs or DSVs
        Check9on12(GetRTVBindingTracker().GetBindingIndices().size() == 0 && GetDSVBindingTracker().GetBindingIndices().size() == 0);

        // The rotation mechanism used by rename ensures SRVs are updated before they're used, and future draws will reference the new resource.

        NotifyResourceChanged();

        return hr;
    }

    _Check_return_ HRESULT APIENTRY QueryResourceResidency(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_QUERYRESOURCERESIDENCY *pQueryResidencyArgs)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        HRESULT hr = S_OK;
        for (UINT i = 0; i < pQueryResidencyArgs->NumResources; i++)
        {
            Resource *pResource = Resource::GetResourceFromHandle(pQueryResidencyArgs->pHandleList[i]);

            // Runtime validates that system memory resources never get queried by the driver
            Check9on12(!pResource->IsSystemMemory());

            if (!pResource->IsResident())
            {
                // Optimistically assuming it's still in main memory (i.e. not disk, though this is a possiblility)
                // This is okay since this DDI is a guess at best
                hr = S_RESIDENT_IN_SHARED_MEMORY;
                break;
            }
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr);
    }

    void CleanupResourceBindingsAndRelease::operator()(D3D12TranslationLayer::Resource* pResource)
    {
        CleanupTranslationLayerResourceBindings(*pResource->m_pParent, *pResource);
        pResource->Release();
    }

    void APIENTRY TransitionResource(HANDLE hDD, HANDLE hResource, UINT State)
    {
        Device* pDevice = Device::GetDeviceFromHandle(hDD);
        if (pDevice == nullptr || hResource == nullptr)
        {
            return;
        }

        Resource* pResource = Resource::GetResourceFromHandle(hResource);
        pDevice->GetContext().GetResourceStateManager().TransitionResource(
            pResource->GetUnderlyingResource(), (D3D12_RESOURCE_STATES)State,
            D3D12TranslationLayer::COMMAND_LIST_TYPE::GRAPHICS,
            D3D12TranslationLayer::SubresourceTransitionFlags::NoBindingTransitions |
                D3D12TranslationLayer::SubresourceTransitionFlags::StateMatchExact |
                D3D12TranslationLayer::SubresourceTransitionFlags::NotUsedInCommandListIfNoStateChange);
        pDevice->GetContext().GetResourceStateManager().ApplyAllResourceTransitions();
    }

    void APIENTRY SetCurrentResourceState(HANDLE hDD, HANDLE hResource, UINT State)
    {
        Device* pDevice = Device::GetDeviceFromHandle(hDD);
        if (pDevice == nullptr || hResource == nullptr)
        {
            return;
        }

        Resource* pResource = Resource::GetResourceFromHandle(hResource);

        D3D12TranslationLayer::CCurrentResourceState::ExclusiveState ExclusiveState = {};
        ExclusiveState.FenceValue = pDevice->GetContext().GetCommandListID(D3D12TranslationLayer::COMMAND_LIST_TYPE::GRAPHICS);
        ExclusiveState.CommandListType = D3D12TranslationLayer::COMMAND_LIST_TYPE::GRAPHICS;
        ExclusiveState.State = (D3D12_RESOURCE_STATES)State;
        pResource->GetUnderlyingResource()->GetIdentity()->m_currentState.SetExclusiveResourceState(ExclusiveState);
    }
};

```

`src/9on12Shader.cpp`:

```cpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#include "pch.h"
#include <DxbcSigner.hpp>

namespace D3D9on12
{
    _Check_return_ HRESULT APIENTRY CreatePixelShader(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_CREATEPIXELSHADER* pCreatePixelShader, _In_ CONST UINT* pByteCode)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pCreatePixelShader == nullptr || pByteCode == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        const byte* pShaderByteCode = (RegistryConstants::g_cDebugRedPixelShader) ? g_redOutputPS : (byte*)pByteCode;
        const size_t byteCodeSize = (RegistryConstants::g_cDebugRedPixelShader) ? sizeof(g_redOutputPS) : pCreatePixelShader->CodeSize;
        PixelShader* pShader = pDevice->m_PSDedupe.GetOrCreate(*pDevice, pShaderByteCode, byteCodeSize);

        pCreatePixelShader->ShaderHandle = Shader::GetHandleFromShader(pShader);

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY DeletePixelShader(_In_ HANDLE hDevice, _In_ HANDLE hShader)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        Shader* pShader = Shader::GetShaderFromHandle(hShader);
        if (pDevice == nullptr || pShader == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        pDevice->m_PSDedupe.Release(static_cast<PixelShader*>(pShader));

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY CreateVertexShaderFunc(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_CREATEVERTEXSHADERFUNC* pCreateVertexShader, _In_ CONST UINT* pByteCode)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pCreateVertexShader == nullptr || pByteCode == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }
        const byte* pShaderByteCode = (RegistryConstants::g_cDebugPassThroughVertexShader) ? g_passThroughVS : (byte*)pByteCode;
        const size_t byteCodeSize = (RegistryConstants::g_cDebugPassThroughVertexShader) ? sizeof(g_passThroughVS) : pCreateVertexShader->Size;
        VertexShader* pShader = pDevice->m_VSDedupe.GetOrCreate(*pDevice, pShaderByteCode, byteCodeSize);

        pCreateVertexShader->ShaderHandle = Shader::GetHandleFromShader(pShader);

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY DeleteVertexShaderFunc(_In_ HANDLE hDevice, _In_ HANDLE hShader)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        VertexShader* pShader = (VertexShader*)Shader::GetShaderFromHandle(hShader);
        if (pDevice == nullptr || pShader == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        pDevice->m_VSDedupe.Release(pShader);

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    Shader::Shader(Device& device) :
        PipelineStateCacheKeyComponent(device.GetPipelineStateCache().GetCache()),
        m_parentDevice(device),
        m_DXBCBuilder(false),
        m_legacyCodeHash(0)
    {
    }

    Shader::Shader(Device& device, _In_ CONST byte& byteCode, _In_ size_t byteCodeLength, WeakHash hash) :
        PipelineStateCacheKeyComponent(device.GetPipelineStateCache().GetCache()),
        m_parentDevice(device),
        m_DXBCBuilder(false),
        m_legacyCodeHash(hash)
    {
        m_d3d9ByteCode = SizedBuffer(new byte[byteCodeLength], byteCodeLength);
        memcpy(m_d3d9ByteCode.m_ptr, &byteCode, byteCodeLength);
    }

    VertexShader::VertexShader(Device& parentDevice, _In_ CONST byte& byteCode, _In_ size_t byteCodeLength, WeakHash hash) :
        Shader(parentDevice, byteCode, byteCodeLength, hash) {}
    VertexShader::VertexShader(Device& parentDevice) :
        Shader(parentDevice) {}

    PixelShader::PixelShader(Device& parentDevice, _In_ CONST byte& byteCode, _In_ size_t byteCodeLength, WeakHash hash) :
        Shader(parentDevice, byteCode, byteCodeLength, hash) {}

    GeometryShader::GeometryShader(Device& parentDevice, _In_ CONST byte& byteCode, _In_ size_t byteCodeLength, WeakHash hash) :
        Shader(parentDevice, byteCode, byteCodeLength, hash) {}
    GeometryShader::GeometryShader(Device& parentDevice) :
        Shader(parentDevice) {}

    Shader::~Shader()
    {
        if (m_d3d9ByteCode.m_ptr) { delete[] m_d3d9ByteCode.m_ptr; }
    }

    void Shader::GenerateSignatureFromVSOutput(ShaderConv::VSOutputDecls& vsOut, DXBCInputSignatureBuilder& signature)
    {
        typedef std::tuple<_D3D11_INTERNALSHADER_PARAMETER_11_1, const char *> tupleType;

        // DXBC Linkage
        {
            std::vector<_D3D11_INTERNALSHADER_PARAMETER_11_1> parameters = std::vector<_D3D11_INTERNALSHADER_PARAMETER_11_1>(vsOut.GetSize());
            std::vector<std::string> semanticNames = std::vector<std::string>(vsOut.GetSize());

            std::vector<tupleType> pairs = std::vector<tupleType>(vsOut.GetSize());

            for (UINT i = 0; i < vsOut.GetSize(); i++)
            {
                D3DDECLUSAGE usage = static_cast<D3DDECLUSAGE>(vsOut[i].Usage);

                auto& parameter = std::get<0>(pairs[i]);
                parameter = {};
                parameter.SemanticIndex = vsOut[i].UsageIndex;
                parameter.SystemValue = ConvertToName(usage);
                parameter.Register = vsOut[i].RegIndex;
                parameter.Mask = vsOut[i].WriteMask;
                parameter.ComponentType = ConvertToComponentType(usage);

                auto& semantic = std::get<1>(pairs[i]);
                semantic = ConvertToSemanticNameForDXBCLinkage(usage);
            }

            // Signatures need to be sorted by their register value
            std::sort(pairs.begin(), pairs.end(), less_than_key<tupleType>());

            for (size_t i = 0; i < pairs.size(); i++)
            {
                parameters[i] = std::get<0>(pairs[i]);
                semanticNames[i] = std::get<1>(pairs[i]);
            }

            signature.SetParameters(&parameters[0], &semanticNames[0], static_cast<UINT>(parameters.size()));
        }
    }

    template<typename MapType>
    static void ClearMap(MapType& map)
    {
        for (auto derivedShader : map)
        {
            if (derivedShader.second.GetUnderlying())
            {
                derivedShader.second.Destroy();
            }
        }
    }

    VertexShader::~VertexShader()
    {
        if (m_parentDevice.GetPipelineState().GetVertexStage().GetCurrentD3D9VertexShader() == this)
        {
            m_parentDevice.GetPipelineState().GetVertexStage().SetVertexShader(nullptr);
        }

        ClearMap(m_derivedShaders);
    }

    PixelShader::~PixelShader()
    {
        if (m_parentDevice.GetPipelineState().GetPixelStage().GetCurrentD3D9PixelShader() == this)
        {
            m_parentDevice.GetPipelineState().GetPixelStage().SetPixelShader(nullptr);
        }

        ClearMap(m_derivedShaders);
    }

    GeometryShader::~GeometryShader()
    {
        // The GS is linked to the VS, deleting the Vertex Shader handles all the GS clean-up as well
        ClearMap(m_derivedShaders);
    }

    D3D12PixelShader& PixelShader::GetD3D12Shader(ShaderConv::RasterStates rasterStates, const ShaderConv::VSOutputDecls& vsOutputDeclsOrig, D3D12Shader &inputShader)
    {
        HRESULT hr = S_OK;

        // Check for changes to VS outputs that shouldn't lead to a new
        // pixel shader generation
        ShaderConv::VSOutputDecls vsOutputDecls;
        const UINT numVsOutputs = vsOutputDeclsOrig.GetSize();
        bool trimmedAnyOutputs = false;
        for (UINT i = 0; i < numVsOutputs; ++i)
        {
            const auto& decl = vsOutputDeclsOrig[i];
            bool skipOutput = false;
            if (decl.Usage == D3DDECLUSAGE_CLIPDISTANCE && numVsOutputs == i + 1)
            {
                // Remove the ClipDistance SV if it's the last input
                // This is added as an output for the VS stage to implement UserClipPlanes
                // On CS:GO and some other titles, this state changes fairly frequently
                // and causes redundant PS generation
                skipOutput = true;
                trimmedAnyOutputs = true;
                rasterStates.UserClipPlanes = 0x0;
            }
            if (!skipOutput)
            {
                vsOutputDecls.AddDecl(vsOutputDeclsOrig[i]);
            }
        }

        DerivedPixelShaderKey key(rasterStates, vsOutputDecls);

        auto derivedShader = m_derivedShaders.find(key);

        if (derivedShader != m_derivedShaders.end())
        {
            return derivedShader->second;
        }
        else
        {
            hr = ShaderConversionPrologue();
            CHECK_HR(hr);

            m_derivedShaders[key] = D3D12PixelShader(this);
            D3D12PixelShader& newPixelShader = m_derivedShaders[key];

            bool applyAnythingTimes0Equals0 = RegistryConstants::g_cAnythingTimes0Equals0 || (g_AppCompatInfo.AnythingTimes0Equals0ShaderMask & D3D9ON12_PIXEL_SHADER_MASK);
            ShaderConv::VSInputDecls vsInputDecls(ShaderConv::MAX_VS_INPUT_REGS);
            ShaderConv::ConvertShaderArgs convertArgs = ShaderConv::ConvertShaderArgs(
                m_parentDevice.GetD3D9ApiVersion(), 
                applyAnythingTimes0Equals0 ? ShaderConv::AnythingTimes0Equals0 : 0,
                rasterStates);
            convertArgs.type = ShaderConv::ConvertShaderArgs::SHADER_TYPE::SHADER_TYPE_PIXEL;
            convertArgs.pVsInputDecl = &vsInputDecls;
            convertArgs.pPsInputDecl = &vsOutputDecls;
            convertArgs.legacyByteCode.m_pByteCode = m_d3d9ByteCode.m_ptr;
            convertArgs.legacyByteCode.m_byteCodeSize = m_d3d9ByteCode.m_size;
            for (UINT i = 0; i < ARRAYSIZE(newPixelShader.m_inlineConsts); i++)
            {
                newPixelShader.m_inlineConsts[i] = std::move(convertArgs.m_inlineConsts[i]);
            }

            hr = m_parentDevice.m_ShaderConvAPI.ConvertShader(convertArgs);
            CHECK_HR(hr);

            const bool bVSOutputMatchesPSInput = (convertArgs.AddedSystemSemantics.size() == 0 && !trimmedAnyOutputs);
            DXBCInputSignatureBuilder inputSignatureBuilder;
            SizedBuffer inputSignatureBuffer = {};
            if (bVSOutputMatchesPSInput)
            {
                inputSignatureBuffer = inputShader.m_outputSignature;
            }
            else
            {
                ShaderConv::VSOutputDecls patchedVSOutput = vsOutputDecls;
                for (auto &decl : convertArgs.AddedSystemSemantics)
                {
                    patchedVSOutput.AddDecl(decl);
                }
                GenerateSignatureFromVSOutput(patchedVSOutput, inputSignatureBuilder);
                inputSignatureBuffer = inputSignatureBuilder.GetData();
            }

            if (SUCCEEDED(hr) && convertArgs.convertedByteCode.m_pByteCode)
            {
                D3D12_SHADER_BYTECODE newByteCode = {};

                DXBCInputSignatureBuilder outputSignatureBuilder;
                
                //DXBC Output Linkage
                {
                    const int cMaxOutputParameters = ShaderConv::MAX_PS_COLOROUT_REGS + ShaderConv::MAX_PS_DEPTHOUT_REGS;
                    _D3D11_INTERNALSHADER_PARAMETER_11_1 parameters[cMaxOutputParameters] = {};
                    std::string parametersNames[cMaxOutputParameters] = {};
                    UINT numParameters = 0;
                    for (UINT i = 0; i < ShaderConv::MAX_PS_COLOROUT_REGS; i++)
                    {
                        if (convertArgs.outputRegistersMask & (1 << i))
                        {
                            parametersNames[numParameters] = "SV_Target";
                            _D3D11_INTERNALSHADER_PARAMETER_11_1 &parameter = parameters[numParameters];
                            parameter.SemanticIndex = i;
                            parameter.SystemValue = D3D10_NAME_TARGET;
                            parameter.Register = i;
                            parameter.ComponentType = D3D_REGISTER_COMPONENT_FLOAT32;//Can make this assumption because D3D9 can only work in floats
                            parameter.Mask = RGBA_MASK;

                            numParameters++;
                        }
                    }

                    if (convertArgs.outputRegistersMask & ShaderConv::DEPTH_OUTPUT_MASK)
                    {
                        parametersNames[numParameters] = "SV_Depth";
                        _D3D11_INTERNALSHADER_PARAMETER_11_1 &parameter = parameters[numParameters];
                        parameter.SemanticIndex = 0;
                        parameter.SystemValue = D3D10_NAME_DEPTH;
                        parameter.Register = (UINT)-1;
                        parameter.ComponentType = D3D_REGISTER_COMPONENT_FLOAT32;//Can make this assumption because D3D9 can only work in floats
                        parameter.Mask = R_MASK;

                        numParameters++;
                    }

                    assert(numParameters <= cMaxOutputParameters);
                    outputSignatureBuilder.SetParameters(parameters, parametersNames, numParameters);
                }

                SizedBuffer upgradedByteCode = SizedBuffer(convertArgs.convertedByteCode.m_pByteCode,convertArgs.convertedByteCode.m_byteCodeSize);
                SizedBuffer outputSignatureBuilderData = outputSignatureBuilder.GetData();

                hr = GenerateFinalD3D12Shader(upgradedByteCode,
                    newPixelShader, inputSignatureBuffer, outputSignatureBuilderData);

                ShaderConv::ShaderConverterAPI::CleanUpConvertedShader(convertArgs.convertedByteCode);
            }

            newPixelShader.m_floatConstsUsed = convertArgs.maxFloatConstsUsed;
            newPixelShader.m_intConstsUsed = convertArgs.maxIntConstsUsed;
            newPixelShader.m_boolConstsUsed = convertArgs.maxBoolConstsUsed;
            m_parentDevice.GetDataLogger().AddShaderData(D3D10_SB_PIXEL_SHADER, convertArgs.totalInstructionsEmitted, convertArgs.totalExtraInstructionsEmitted);

            return newPixelShader;
        }
    }

    D3D12GeometryShader& GeometryShader::GetD3D12Shader(D3D12VertexShader& currentVS, const ShaderConv::RasterStates& rasterStates)
    {
        DerivedGeometryShaderKey key(rasterStates, currentVS.m_vsOutputDecls);
        auto derivedShader = m_derivedShaders.find(key);

        if (derivedShader != m_derivedShaders.end())
        {
            return derivedShader->second;
        }
        else
        {
            HRESULT hr = ShaderConversionPrologue();
            CHECK_HR(hr);

            m_derivedShaders[key] = D3D12GeometryShader(this);
            D3D12GeometryShader& newGeometryShader = m_derivedShaders[key];

            // We don't pass AnythingTimes0Equals0 flag to the shader converter for 
            // geometry shaders since 9on12 controls the input to the GS and shouldn't
            // generally result in nan or inf results
            ShaderConv::CreateGeometryShaderArgs args = ShaderConv::CreateGeometryShaderArgs(
                m_parentDevice.GetD3D9ApiVersion(), 
                0, 
                currentVS.m_vsOutputDecls,
                &newGeometryShader.m_gsOutputDecls,
                rasterStates);
            hr = m_parentDevice.m_ShaderConvAPI.CreateGeometryShader(args);
            CHECK_HR(hr);

            if (SUCCEEDED(hr))
            {
                SizedBuffer upgradedByteCode = SizedBuffer(args.m_GSByteCode.m_pByteCode, args.m_GSByteCode.m_byteCodeSize);
                
                newGeometryShader.m_inputSignature = currentVS.m_outputSignature;
                newGeometryShader.m_outputSignature = currentVS.m_outputSignature;

                // In most cases, the GS inputs and outputs are the same, but if the GS does add an extra output
                // (i.e. PointSprites), we need to generate a separate output signature
                DXBCInputSignatureBuilder outputSignatureBuilder;
                if (!(args.m_VsOutputDecls == newGeometryShader.m_gsOutputDecls))
                {
                    GenerateSignatureFromVSOutput(newGeometryShader.m_gsOutputDecls, outputSignatureBuilder);
                    newGeometryShader.m_outputSignature = outputSignatureBuilder.GetData();
                }

                hr = GenerateFinalD3D12Shader(upgradedByteCode, newGeometryShader, newGeometryShader.m_inputSignature, newGeometryShader.m_outputSignature);
                CHECK_HR(hr);
            }

            ShaderConv::ShaderConverterAPI::CleanUpConvertedShader(args.m_GSByteCode);

            return newGeometryShader;
        }
    }

    D3D12VertexShader& VertexShader::GetD3D12Shader(const ShaderConv::RasterStates &rasterStates, InputLayout& inputLayout)
    {
        HRESULT hr = S_OK;

        DerivedVertexShaderKey key(rasterStates, inputLayout, m_parentDevice.GetPointerToStreamFrequencies());

        auto derivedShader = m_derivedShaders.find(key);

        if (derivedShader != m_derivedShaders.end())
        {
            return derivedShader->second;
        }
        else
        {
            hr = ShaderConversionPrologue();
            CHECK_HR(hr);

            m_derivedShaders[key] = D3D12VertexShader(this);
            D3D12VertexShader& newVertexShader = m_derivedShaders[key];

            ShaderConv::VSInputDecls vsInputDecls = inputLayout.GetVSInputDecls();

            bool applyAnythingTimes0Equals0 = RegistryConstants::g_cAnythingTimes0Equals0 || (g_AppCompatInfo.AnythingTimes0Equals0ShaderMask & D3D9ON12_VERTEX_SHADER_MASK);
            ShaderConv::ConvertShaderArgs convertArgs = ShaderConv::ConvertShaderArgs(
                m_parentDevice.GetD3D9ApiVersion(),
                applyAnythingTimes0Equals0 ? ShaderConv::AnythingTimes0Equals0 : 0,
                rasterStates);
            convertArgs.type = ShaderConv::ConvertShaderArgs::SHADER_TYPE::SHADER_TYPE_VERTEX;
            convertArgs.pVsOutputDecl = &newVertexShader.m_vsOutputDecls;
            convertArgs.pVsInputDecl = &vsInputDecls;
            convertArgs.pPsInputDecl = nullptr;
            convertArgs.legacyByteCode.m_pByteCode = m_d3d9ByteCode.m_ptr;
            convertArgs.legacyByteCode.m_byteCodeSize = m_d3d9ByteCode.m_size;

            hr = m_parentDevice.m_ShaderConvAPI.ConvertShader(convertArgs);
            CHECK_HR(hr);

            if (SUCCEEDED(hr) && convertArgs.convertedByteCode.m_pByteCode)
            {
                SizedBuffer upgradedByteCode = SizedBuffer(convertArgs.convertedByteCode.m_pByteCode, convertArgs.convertedByteCode.m_byteCodeSize);
                hr = SetupInputSignaturesAndGetFinalCode(upgradedByteCode, vsInputDecls, &inputLayout, newVertexShader);
            }

            newVertexShader.m_floatConstsUsed = convertArgs.maxFloatConstsUsed;
            newVertexShader.m_intConstsUsed = convertArgs.maxIntConstsUsed;
            newVertexShader.m_boolConstsUsed = convertArgs.maxBoolConstsUsed;
            for (UINT i = 0; i < ARRAYSIZE(newVertexShader.m_inlineConsts); i++)
            {
                newVertexShader.m_inlineConsts[i] = std::move(convertArgs.m_inlineConsts[i]);
            }

            m_parentDevice.GetDataLogger().AddShaderData(D3D10_SB_VERTEX_SHADER, convertArgs.totalInstructionsEmitted, convertArgs.totalExtraInstructionsEmitted);
            ShaderConv::ShaderConverterAPI::CleanUpConvertedShader(convertArgs.convertedByteCode);

            return newVertexShader;
        }
    }

    D3D12VertexShader& VertexShader::GetD3D12ShaderForTL(InputLayout& inputLayout, const ShaderConv::RasterStates &rasterStates)
    {
        HRESULT hr = S_OK;

        DerivedVertexShaderKey key(rasterStates, inputLayout, m_parentDevice.GetPointerToStreamFrequencies());

        auto derivedShader = m_derivedShaders.find(key);

        if (derivedShader != m_derivedShaders.end())
        {
            return derivedShader->second;
        }
        else
        {
            hr = ShaderConversionPrologue();

            m_derivedShaders[key] = D3D12VertexShader(this);
            D3D12VertexShader& newVertexShader = m_derivedShaders[key];

            auto vsInputDecls = inputLayout.GetVSInputDecls();
            ShaderConv::VSOutputDecls &vsOutputDecl = newVertexShader.m_vsOutputDecls;

            auto convertArgs = ShaderConv::ConvertTLShaderArgs(
                m_parentDevice.GetD3D9ApiVersion(), 
                0,
                vsInputDecls, 
                vsOutputDecl);

            hr = m_parentDevice.m_ShaderConvAPI.ConvertTLShader(convertArgs);
            CHECK_HR(hr);

            if (SUCCEEDED(hr) && convertArgs.convertedByteCode.m_pByteCode)
            {
                SizedBuffer upgradedByteCode = SizedBuffer(convertArgs.convertedByteCode.m_pByteCode, convertArgs.convertedByteCode.m_byteCodeSize);
                hr = SetupInputSignaturesAndGetFinalCode(upgradedByteCode, vsInputDecls, &inputLayout, newVertexShader);
            }

            m_parentDevice.GetDataLogger().AddShaderData(D3D10_SB_VERTEX_SHADER, convertArgs.totalInstructionsEmitted, convertArgs.totalExtraInstructionsEmitted);
            ShaderConv::ShaderConverterAPI::CleanUpConvertedShader(convertArgs.convertedByteCode);

            return newVertexShader;
        }
    }

    HRESULT VertexShader::SetupInputSignaturesAndGetFinalCode(SizedBuffer& upgradedByteCode , ShaderConv::VSInputDecls& vsInputDecls, InputLayout* pInputLayout, _Out_ D3D12VertexShader& outputVS)
    {
        DXBCInputSignatureBuilder inputSignatureBuilder;
        DXBCInputSignatureBuilder outputSignatureBuilder;

        if (vsInputDecls.GetSize() > 0 && pInputLayout)
        {
            // Converting pInputSignature into the proper DXBC format. It must be prepended with a header 
            // and the strings must be serialized
            std::vector<_D3D11_INTERNALSHADER_PARAMETER_11_1> pParameters;
            outputVS.m_inputElementDescs.clear();
            outputVS.m_inputElementDescs.reserve(pInputLayout->GetVertexElementCount());

            // Generate both the descriptors for the D3D12 input layout (D3D12_INPUT_ELEMENT_DESC) and the 
            // descriptors for the DXBC header (_D3D11_INTERNALSHADER_PARAMETER_11_1)
            std::vector<std::string> semanticNameList;

            // The d3d12 runtime expects input signature items to be ordered by register index.
            // However, this code originally produced signatures with out of order registers
            // because of the way FindRegisterIndex works.
            // To solve this we collect up the Parameters, Elements and Semantic names and
            // sort them based on the parameter register.
            typedef std::tuple<_D3D11_INTERNALSHADER_PARAMETER_11_1, D3D12_INPUT_ELEMENT_DESC, const char *> tupleType;
            std::vector<tupleType> pairs;

            for (UINT i = 0; i < pInputLayout->GetVertexElementCount(); i++)
            {
                D3DDDIVERTEXELEMENT &inputDesc = pInputLayout->GetVertexElement(i);
                UINT regIndex = vsInputDecls.FindRegisterIndex(inputDesc.Usage, inputDesc.UsageIndex);

                if (regIndex != ShaderConv::VSInputDecls::INVALID_INDEX)
                {
                    const char *semanticName = ConvertToSemanticNameForInputLayout((D3DDECLUSAGE)inputDesc.Usage);

                    _D3D11_INTERNALSHADER_PARAMETER_11_1 parameter = {};

                    // This Stream refers to StreamOut, and should always be 0 for 9on12. This is different from the
                    // inputDesc.Stream which refers to the VertexBuffer slot
                    parameter.Stream = 0;
                    
                    parameter.SemanticIndex = inputDesc.UsageIndex;
                    parameter.ComponentType = ConvertToRegisterComponentType(static_cast<D3DDECLTYPE>(inputDesc.Type));
                    parameter.Mask = RGBA_MASK;
                    parameter.Register = regIndex;
                    parameter.AlwaysReads_Mask = parameter.Mask;
                    // VS's input system values must always be undefined, these are only meaningful
                    // when passing data to the PS
                    parameter.SystemValue = D3D10_NAME_UNDEFINED; 

                    D3D12_INPUT_ELEMENT_DESC inputElementDesc = {};
                    inputElementDesc.SemanticName = semanticName;
                    inputElementDesc.SemanticIndex = parameter.SemanticIndex;
                    inputElementDesc.Format = ConvertToDXGIFormat(static_cast<D3DDECLTYPE>(inputDesc.Type));
                    inputElementDesc.InputSlot = inputDesc.Stream;
                    inputElementDesc.AlignedByteOffset = inputDesc.Offset;

                    UINT streamFrequence = m_parentDevice.GetStreamFrequency(inputElementDesc.InputSlot);

                    if (streamFrequence & D3DSTREAMSOURCE_INSTANCEDATA)
                    {
                        inputElementDesc.InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA;
                        inputElementDesc.InstanceDataStepRate = streamFrequence &~D3DSTREAMSOURCE_INSTANCEDATA;
                    }
                    else
                    {
                        inputElementDesc.InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
                        inputElementDesc.InstanceDataStepRate = 0;
                    }

                    tupleType newPair(parameter, inputElementDesc, semanticName);
                    pairs.push_back(newPair);
                }
            }

            // Registers must appear in increasing order.
            std::sort(pairs.begin(), pairs.end(), less_than_key<tupleType>());

            for (auto& pair : pairs)
            {
                pParameters.push_back(std::get<0>(pair));
                outputVS.m_inputElementDescs.push_back(std::get<1>(pair));
                semanticNameList.push_back(std::get<2>(pair));
            }

            Check9on12(pParameters.size() == semanticNameList.size());
            inputSignatureBuilder.SetParameters(&pParameters[0], &semanticNameList[0], static_cast<UINT>(pParameters.size()));
        }
        else
        {
            inputSignatureBuilder.SetParameters(nullptr, nullptr, 0);
        }

        // Setup the DXBC signature for the VS output
        {
            GenerateSignatureFromVSOutput(outputVS.m_vsOutputDecls, outputSignatureBuilder);
        }

        SizedBuffer inputSignatureBuilderData = inputSignatureBuilder.GetData();
        SizedBuffer outputSignatureBuilderData = outputSignatureBuilder.GetData();

        HRESULT hr = GenerateFinalD3D12Shader(upgradedByteCode, outputVS, inputSignatureBuilderData, outputSignatureBuilderData);
        CHECK_HR(hr);
        return hr;
    }

    HRESULT D3D12Shader::Create(Device &device, std::unique_ptr<BYTE[]> byteCode, SIZE_T bytecodeSize)
    {
        HRESULT hr = S_OK;
        m_pUnderlying = new (m_pUnderlyingSpace) D3D12TranslationLayer::Shader(&device.GetContext(), std::move(byteCode), bytecodeSize);
        if (m_pUnderlying)
        {
            hr = E_OUTOFMEMORY;
        }
        return hr;
    }

    void D3D12Shader::Destroy()
    {
        m_pUnderlying->~Shader();
    }

    HRESULT Shader::GenerateFinalD3D12Shader(SizedBuffer& upgradedByteCode, _Out_ D3D12Shader& d3d12ShaderOut, SizedBuffer& inputSignature, SizedBuffer& outputSignature)
    {
        HRESULT hr = S_OK;
        Check9on12(inputSignature.m_size % 4 == 0);
        Check9on12(outputSignature.m_size % 4 == 0);
        Check9on12(upgradedByteCode.m_size % 4 == 0);

        // Input Signature
        {
            hr = m_DXBCBuilder.AppendBlob(DXBC_InputSignature11_1, static_cast<UINT>(inputSignature.m_size), inputSignature.m_ptr);
        }

        // Output Signature
        if (SUCCEEDED(hr))
        {
            hr = m_DXBCBuilder.AppendBlob(DXBC_OutputSignature11_1, static_cast<UINT>(outputSignature.m_size), outputSignature.m_ptr);
        }

        if (SUCCEEDED(hr))
        {
            hr = m_DXBCBuilder.AppendBlob(DXBC_GenericShader, static_cast<UINT>(upgradedByteCode.m_size), upgradedByteCode.m_ptr);
        }

        if (SUCCEEDED(hr))
        {
            UINT32 combinedLength = 0;

            hr = m_DXBCBuilder.GetFinalDXBC(nullptr, &combinedLength);

            if (SUCCEEDED(hr) && combinedLength)
            {
                std::unique_ptr<BYTE[]> combinedCode(new BYTE[combinedLength]); // throw( bad_alloc )
                hr = m_DXBCBuilder.GetFinalDXBC(combinedCode.get(), &combinedLength);

                if (SUCCEEDED( hr ))
                {
                    Adapter adapter = m_parentDevice.GetAdapter();
                    if (adapter.m_bSupportsShaderSigning)
                    {
                        hr = adapter.m_privateCallbacks.pfnSignDxbcCB(combinedCode.get(), combinedLength);
                    }
                    else
                    {
                        //Triggers delayload of dxbcSigner.dll
                        hr = SignDxbc(combinedCode.get(), combinedLength);
                    }
                }

                if (SUCCEEDED(hr))
                {
                    // In order to point to the raw input and output signatures we must first offset past the
                    // DXBC header and then past the individual Blob headers.
                    DXBCHeader* header = (DXBCHeader*)combinedCode.get();
                    byte* firstBlob = (byte*)combinedCode.get() + sizeof(DXBCHeader) + (header->BlobCount * sizeof(UINT));

                    byte* inputSignaturePointer = firstBlob + sizeof(DXBCBlobHeader);
                    d3d12ShaderOut.m_inputSignature = SizedBuffer(inputSignaturePointer, inputSignature.m_size);

                    byte* outputSignaturePointer = inputSignaturePointer + inputSignature.m_size + sizeof(DXBCBlobHeader);
                    d3d12ShaderOut.m_outputSignature = SizedBuffer(outputSignaturePointer, outputSignature.m_size);

                    d3d12ShaderOut.Create(m_parentDevice, std::move(combinedCode), combinedLength);
                }
            }
        }

        // Start up a new contain if they change up the shader via RasterStates
        m_DXBCBuilder.StartNewContainer();

        CHECK_HR(hr);

        if (RegistryConstants::g_cSpewConvertedShaders)
        {   
            CComPtr<ID3DBlob> debugBlob;
            HRESULT result = DisassembleShader(debugBlob, d3d12ShaderOut.GetUnderlying()->GetByteCode());

            if (SUCCEEDED(result))
            {
                PrintDebugMessage(std::string((char *)debugBlob->GetBufferPointer()));
            }
        }

        if (RegistryConstants::g_cValidateShaders)
        {
            ThrowFailure(ValidateShader(d3d12ShaderOut.GetUnderlying()->GetByteCode()));
        }


        return hr;
    }

    HRESULT Shader::DisassembleShader(CComPtr<ID3DBlob> &pBlob, const D3D12_SHADER_BYTECODE &shaderByteCode)
    {
        typedef HRESULT(WINAPI* D3DDisassemble)(_In_reads_bytes_(SrcDataSize) LPCVOID pSrcData,
            _In_ SIZE_T SrcDataSize,
            _In_ UINT Flags,
            _In_opt_ LPCSTR szComments,
            _Out_ ID3DBlob** ppDisassembly);

        HMODULE hCompiler = 0;
        hCompiler = LoadLibraryEx("D3DCompiler_47.dll", NULL, NULL);

        D3DDisassemble disassembleFunction = nullptr;

        if (hCompiler != 0)
        {
            disassembleFunction = (D3DDisassemble)GetProcAddress(hCompiler, "D3DDisassemble");
        }

        if (disassembleFunction == nullptr)
        {
            Check9on12(false);
            return E_FAIL;
        }

        return disassembleFunction(shaderByteCode.pShaderBytecode, shaderByteCode.BytecodeLength, 0, nullptr, &pBlob);
    }


    HRESULT Shader::ShaderConversionPrologue()
    {
        HRESULT result = S_OK;
        if (RegistryConstants::g_cSpewD3D9Shaders && m_d3d9ByteCode.m_size > 0)
        {
            CComPtr<ID3DBlob> debugBlob;
            D3D12_SHADER_BYTECODE d3d9ByteCode;
            d3d9ByteCode.pShaderBytecode = m_d3d9ByteCode.m_ptr;
            d3d9ByteCode.BytecodeLength = m_d3d9ByteCode.m_size;
            result = DisassembleShader(debugBlob, d3d9ByteCode);

            if (SUCCEEDED(result))
            {
                PrintDebugMessage(std::string((char *)debugBlob->GetBufferPointer()));
            }
        }
        return result;
    }

    HRESULT Shader::ValidateShader(const D3D12_SHADER_BYTECODE &shaderByteCode)
    {
        typedef HRESULT(WINAPI* ValidateShader)(CONST BYTE* pShaderCode);

        HMODULE hValidator = 0;
        hValidator = LoadLibraryEx("D3D9on12ShaderValidator.dll", NULL, NULL);

        ValidateShader validateFunction = nullptr;

        if (hValidator != 0)
        {
            validateFunction = (ValidateShader)GetProcAddress(hValidator, "ValidateShader");
        }

        if (validateFunction == nullptr)
        {
            Check9on12(false);
            return E_FAIL;
        }

        return validateFunction((CONST BYTE *)shaderByteCode.pShaderBytecode);
    }

    HRESULT DXBCInputSignatureBuilder::SetParameters(_D3D11_INTERNALSHADER_PARAMETER_11_1 *pInputParameters, std::string *pNameList, UINT numParameters)
    {
        // TODO: doesn't optimize for duplicate strings
        UINT charCacheSize = 0;

        if (pNameList != nullptr)
        {
            for (UINT i = 0; i < numParameters; i++)
            {
                charCacheSize += static_cast<UINT>(pNameList[i].size()) + 1;
            }
        }

        m_dataSize = sizeof(D3D10_INTERNALSHADER_SIGNATURE) + sizeof(_D3D11_INTERNALSHADER_PARAMETER_11_1) * numParameters + charCacheSize;
        UINT padding = 0;
        if (m_dataSize % 4 != 0)
        {
            // DXBC needs to be 4 byte aligned for dxilconv
            padding = 4 - m_dataSize % 4;
        }
        m_pData = std::unique_ptr<byte[]>(new byte[m_dataSize+padding]);
        if (m_pData.get() == nullptr)
        {
            return E_OUTOFMEMORY;
        }

        D3D10_INTERNALSHADER_SIGNATURE *pHeader = (D3D10_INTERNALSHADER_SIGNATURE*)m_pData.get();
        _D3D11_INTERNALSHADER_PARAMETER_11_1 *pParameters = (_D3D11_INTERNALSHADER_PARAMETER_11_1 *)(pHeader + 1);
        char *pCharCache = (char *)(pParameters + numParameters);

        pHeader->Parameters = numParameters;
        pHeader->ParameterInfo = sizeof(D3D10_INTERNALSHADER_SIGNATURE);

        if (pNameList != nullptr)
        {
            for (UINT i = 0; i < numParameters; i++)
            {
                pParameters[i] = pInputParameters[i];

                // Serialize the string in the charCache and save the string offset
                const char *pSemanticName = pNameList[i].c_str();
                const size_t bufferSizeRemaining = (size_t)(m_pData.get() + m_dataSize) - (size_t)pCharCache;

                strcpy_s(pCharCache, bufferSizeRemaining, pSemanticName);
                pParameters[i].SemanticName = (UINT)((BYTE *)pCharCache - (BYTE *)pHeader);
                pCharCache += strlen(pSemanticName) + 1;
            }
        }
        if (padding > 0)
        {
            ZeroMemory(m_pData.get() + m_dataSize, padding);
            m_dataSize += padding;
        }

        return S_OK;
    }
};
```

`src/9on12SwapChain.cpp`:

```cpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#include "pch.h"
#include "SwapChainHelper.hpp"

namespace D3D9on12
{
    _Check_return_ HRESULT APIENTRY Present1(_In_ HANDLE hDevice, _In_ D3DDDIARG_PRESENT1* pPresentArgs)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);

        pDevice->m_pUMDPresentArgs = pPresentArgs;

        // The runtime and 9on12's KmdPresent will handle filling this out with meaningful data,
        // we need to go through the callback because it's the only way to get access to the runtime's
        // D3DKMT_PRESENT data
        D3DDDICB_PRESENT callbackArgs = {};
        pDevice->GetRuntimeCallbacks().pfnPresentCb(pDevice->GetRuntimeHandle(), &callbackArgs);

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY KmdPresent(_In_ HANDLE hDevice, D3DKMT_PRESENT *pKMTArgs)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pDevice->m_pUMDPresentArgs == nullptr || pKMTArgs == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }
        
        HRESULT hr = pDevice->Present(*pDevice->m_pUMDPresentArgs, pKMTArgs);

        // This pointer becomes invalid after present since it's owned by the runtime
        pDevice->m_pUMDPresentArgs = nullptr;
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr);
    }

    _Check_return_ HRESULT APIENTRY CloseAndSubmitGraphicsCommandListForPresent(
        _In_ HANDLE hDevice,
        BOOL commandsAdded,
        _In_reads_(numSrcSurfaces) const D3DDDIARG_PRESENTSURFACE* pSrcSurfaces,
        UINT numSrcSurfaces,
        _In_opt_ HANDLE hDestResource,
        _In_ D3DKMT_PRESENT* pKMTPresent)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        HRESULT hr = pDevice->CloseAndSubmitGraphicsCommandListForPresent(commandsAdded, pSrcSurfaces, numSrcSurfaces, hDestResource, pKMTPresent);

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(hr);
    }

    HRESULT Device::Present(CONST D3DDDIARG_PRESENT1& PresentArgs, D3DKMT_PRESENT* pKMTArgs)
    {
        Check9on12(PresentArgs.SrcResources == 1);

        Resource* pSource = Resource::GetResourceFromHandle(PresentArgs.phSrcResources[0].hResource);
        Resource* pDest = Resource::GetResourceFromHandle(PresentArgs.hDstResource);
        if (pSource)
        {
            const D3DDDIARG_PRESENTSURFACE* presentSurfaces = PresentArgs.phSrcResources;
            bool bPresentWithSystemMemory = pSource->IsSystemMemory();
            bool sourceIsCompatibleWithPresent = !bPresentWithSystemMemory && !pSource->NeedsSwapRBOutputChannels();

            if (pDest)
            {
                // We can't use a typeless or msaa resources when doing a blt-model present.
                // We handle this by copying it over to a backing resource with a 
                // single-count and fully qualified format.
                sourceIsCompatibleWithPresent = sourceIsCompatibleWithPresent && IsCompatibleAsSourceForBltPresent(pSource->GetDesc());
            }
            else
            {
                sourceIsCompatibleWithPresent = sourceIsCompatibleWithPresent && !IsTypelessFormat(pSource->GetDesc().Format);
            }
            
            if (!sourceIsCompatibleWithPresent)
            {
                pSource = pSource->GetBackingPlainResource( true );
                // Need to reference the new resource in present surface 0
                m_d3d9PresentSurfaces.clear();
                for (UINT i = 0; i < PresentArgs.SrcResources; i++)
                {
                    m_d3d9PresentSurfaces.push_back(PresentArgs.phSrcResources[i]);
                }
                m_d3d9PresentSurfaces[0].hResource = Resource::GetHandleFromResource(pSource);
                presentSurfaces = m_d3d9PresentSurfaces.data();
            }

            HRESULT hr = E_FAIL;
            if (GetAdapter().m_bSupportsNewPresent)
            {          
                try
                {
                    auto forwardToPresent9On12CB = [adapter = GetAdapter(), runtimeDeviceHandle = GetRuntimeHandle(), pArgs = PresentArgs, presentSurfaces]
                    (D3D12TranslationLayer::PresentCBArgs& args) {
                        D3D9ON12_PRESENTCB_ARGS cbArgs = {};
                        cbArgs.flipInterval = args.flipInterval;
                        cbArgs.pSrcSurfaces = presentSurfaces;
                        cbArgs.numSrcSurfaces = args.numSrcSurfaces;
                        cbArgs.hDestResource = pArgs.hDstResource;
                        cbArgs.pGraphicsCommandList = args.pGraphicsCommandList;
                        cbArgs.pGraphicsCommandQueue = args.pGraphicsCommandQueue;
                        cbArgs.pKMTPresent = args.pKMTPresent;
                        cbArgs.vidPnSourceId = args.vidPnSourceId;
                        return (*adapter.m_privateCallbacks.pfnPresentCB)(runtimeDeviceHandle, &cbArgs);
                    };

                    // Convert present Surfaces into d3d12TranslationLayer format
                    m_d3d12tlPresentSurfaces.clear();
                    for (UINT i = 0; i < PresentArgs.SrcResources; i++)
                    {
                        auto presentSurface = presentSurfaces[i];
                        auto resource = Resource::GetResourceFromHandle(presentSurface.hResource);
                        D3D12TranslationLayer::PresentSurface surface = D3D12TranslationLayer::PresentSurface(resource->GetUnderlyingResource(), presentSurface.SubResourceIndex);
                        m_d3d12tlPresentSurfaces.push_back(surface);
                    }

                    GetContext().Present(
                        m_d3d12tlPresentSurfaces.data(),
                        PresentArgs.SrcResources,
                        pDest ? pDest->GetUnderlyingResource() : nullptr,
                        PresentArgs.FlipInterval,
                        pSource->GetVidPnSourceId(),
                        pKMTArgs,
                        false,
                        forwardToPresent9On12CB);

                    hr = S_OK;
                }
                catch (_com_error& hrEx)
                {
                    hr = hrEx.Error();
                }
                catch (std::bad_alloc&)
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                // Fallback to old present path
                auto swapChainManager = GetSwapChainManager();
                D3D12TranslationLayer::Resource* pSrcTranslationLayerResource = pSource->GetUnderlyingResource();

                auto pSwapChain = swapChainManager->GetSwapChainForWindow(pKMTArgs->hWindow, *pSrcTranslationLayerResource);
                auto swapChainHelper = D3D12TranslationLayer::SwapChainHelper(pSwapChain);
                GetContext().m_MaxFrameLatencyHelper.WaitForMaximumFrameLatency();

                hr = swapChainHelper.StandardPresent(GetContext(), pKMTArgs, *pSrcTranslationLayerResource);
            }
            
            m_lockedResourceRanges.GetLocked()->clear();

            return hr;
        }
        else
        {
            return E_INVALIDARG;
        }
    }

    std::shared_ptr<D3D12TranslationLayer::SwapChainManager> Device::GetSwapChainManager()
    {
        std::lock_guard lock( m_SwapChainManagerMutex );
        if (!m_SwapChainManager)
        {
            m_SwapChainManager = std::make_shared<D3D12TranslationLayer::SwapChainManager>( GetContext() );
        }
        return m_SwapChainManager;
    }

    HRESULT Device::CloseAndSubmitGraphicsCommandListForPresent(
        BOOL commandsAdded,
        _In_reads_(numSrcSurfaces) const D3DDDIARG_PRESENTSURFACE* pSrcSurfaces,
        UINT numSrcSurfaces,
        _In_opt_ HANDLE hDestResource,
        _In_ D3DKMT_PRESENT* pKMTPresent)
    {
        D3D12TranslationLayer::ImmediateContext& immediateContext = GetContext();
        m_d3d12tlPresentSurfaces.clear();
        for (UINT i = 0; i < numSrcSurfaces; i++)
        {
            auto presentSurface = pSrcSurfaces[i];
            auto resource = Resource::GetResourceFromHandle(presentSurface.hResource);
            D3D12TranslationLayer::PresentSurface surface = D3D12TranslationLayer::PresentSurface(resource->GetUnderlyingResource(), presentSurface.SubResourceIndex);
            m_d3d12tlPresentSurfaces.push_back(surface);
        }

        D3D12TranslationLayer::Resource* pD3d12tlDestResource = nullptr;
        if (hDestResource != NULL)
        {
            pD3d12tlDestResource = Resource::GetResourceFromHandle(hDestResource)->GetUnderlyingResource();
        }
        return immediateContext.CloseAndSubmitGraphicsCommandListForPresent(
            commandsAdded,
            m_d3d12tlPresentSurfaces.data(),
            numSrcSurfaces,
            pD3d12tlDestResource,
            pKMTPresent);
    }
};
```

`src/9on12VertexStage.cpp`:

```cpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#include "pch.h"

namespace D3D9on12
{
    _Check_return_ HRESULT APIENTRY SetScissorRect(_In_ HANDLE hDevice, _In_ CONST RECT* pRect)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pRect == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        pDevice->GetPipelineState().GetVertexStage().SetScissorRect(*pDevice, *pRect);
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY SetClipPlane(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_SETCLIPPLANE* pSetClipPlane)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pSetClipPlane == nullptr || pSetClipPlane->Index >= MAX_USER_CLIPPLANES)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        pDevice->GetPipelineState().GetVertexStage().SetClipPlane(*pSetClipPlane);

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY SetVertexShaderFunc(_In_ HANDLE hDevice, _In_ HANDLE hShader)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        VertexShader* pShader = (VertexShader*)Shader::GetShaderFromHandle(hShader);

        if (pShader)
        {
            pDevice->GetPipelineState().GetVertexStage().SetVertexShader(pShader);
        }
        else
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY SetViewport(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_VIEWPORTINFO* pViewPortInfo)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pViewPortInfo == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        PipelineState& pipeline = pDevice->GetPipelineState();
        pipeline.GetVertexStage().SetViewPort(*pDevice, *pViewPortInfo);

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY SetZRange(_In_ HANDLE hDevice, _In_ CONST D3DDDIARG_ZRANGE* pZRange)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pZRange == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        PipelineState& pipeline = pDevice->GetPipelineState();
        pipeline.GetVertexStage().SetZRange(*pZRange);

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    VertexStage::VertexStage(Device& device, PipelineStateDirtyFlags& pipelineStateDirtyFlags, RasterStatesWrapper& rasterStates) :
        m_dirtyFlags(pipelineStateDirtyFlags),
        m_VSExtension(pipelineStateDirtyFlags),
        m_rasterStates(rasterStates),
        m_pCurrentVS(nullptr),
        m_pCurrentD3D12VS(nullptr),
        m_pCurrentD3D12GS(nullptr),
        m_tlShaderCache(device),
        m_scissorRect{},
        m_currentViewPort{},
        m_geometryShaderCache(device)
    {}

    void VertexStage::SetScissorRect(Device& device, _In_ RECT scissorRect)
    {
        m_scissorRect = scissorRect;
        ApplyScissorRect(device);
    }

    void VertexStage::ApplyScissorRect(Device & device)
    {
        if (m_scissorTestEnabled)
        {
            device.GetContext().SetScissorRect(0, &m_scissorRect);
            device.GetContext().SetScissorRectEnable(true);
        }
        else
        {
            device.GetContext().SetScissorRectEnable(false);
        }
    }

    void VertexStage::SetScissorTestEnabled(Device& device, bool scissorTestEnabled)
    {
        if (m_scissorTestEnabled != scissorTestEnabled)
        {
            m_scissorTestEnabled = scissorTestEnabled;
            ApplyScissorRect(device);
        }
    }

    void VertexStage::SetClipPlane(_In_ CONST D3DDDIARG_SETCLIPPLANE& setClipPlane)
    {
        m_VSExtension.SetClipPlane(setClipPlane.Index, setClipPlane.Plane);
    }

    void VertexStage::SetVertexShader(VertexShader* pShader)
    {
        if (m_pCurrentVS != pShader)
        {
            m_pCurrentVS = pShader;
            m_dirtyFlags.VertexShader = true;
        }
    }

    void VertexStage::SetPointSize(DWORD dwState, DWORD dwValue)
    {
        switch (dwState)
        {
        case D3DRS_POINTSIZE:
            m_VSExtension.SetPointSize(*(FLOAT*)(&dwValue));
            break;
        case D3DRS_POINTSIZE_MIN:
            m_VSExtension.SetMinPointSize(max<float>(*(FLOAT*)(&dwValue), MIN_POINT_SIZE));
            break;
        case D3DRS_POINTSIZE_MAX:
            m_VSExtension.SetMaxPointSize(min<float>(*(FLOAT*)(&dwValue), MAX_POINT_SIZE));
            break;
        default:
            Check9on12(false);
        }
    }

    void VertexStage::SetViewPort(Device& /*device*/, _In_ CONST D3DDDIARG_VIEWPORTINFO& viewPortInfo)
    {
        m_currentViewPort.TopLeftX = (float)viewPortInfo.X;
        m_currentViewPort.TopLeftY = (float)viewPortInfo.Y;
        m_currentViewPort.Width = (float)viewPortInfo.Width;
        m_currentViewPort.Height = (float)viewPortInfo.Height;

        m_dirtyFlags.Viewport = true;
    }

    void VertexStage::SetZRange(_In_ CONST D3DDDIARG_ZRANGE& zRange)
    {
        m_currentViewPort.MaxDepth = zRange.MaxZ;
        m_currentViewPort.MinDepth = zRange.MinZ;

        m_dirtyFlags.Viewport = true;
    }

    // The viewport must be deferred because they can set the z range independently
    void VertexStage::ResolveViewPort(Device &device)
    {
        // Update the VS extension
        m_VSExtension.SetViewportScale(
            1.0f / m_currentViewPort.Width,
            -1.0f / m_currentViewPort.Height);

        m_VSExtension.SetScreenToClipOffset(
            0.5f - (m_currentViewPort.Width / 2.0f + m_currentViewPort.TopLeftX),
            0.5f - (m_currentViewPort.Height / 2.0f + m_currentViewPort.TopLeftY),
            -m_currentViewPort.MinDepth);

        m_VSExtension.SetScreenToClipScale(
            2.0f / m_currentViewPort.Width,
            -2.0f / m_currentViewPort.Height,
            1.0f / (m_currentViewPort.MaxDepth - m_currentViewPort.MinDepth));

        device.GetContext().SetViewport(0, &m_currentViewPort);

        m_dirtyFlags.VSExtension = true;
    }

    bool VertexStage::NeedsGeometryShader(const ShaderConv::VSOutputDecls &vsOutputDecls)
    {
        bool needsGeometryShader = m_rasterStates.IsUsingPointFill() || m_rasterStates.IsUsingPointSpritesOrSizes(vsOutputDecls);

        if (!needsGeometryShader)
        {
            UINT texCoordMask = vsOutputDecls.TexCoords;
            for (UINT i = 0; i < D3DHAL_SAMPLER_MAXSAMP && texCoordMask; i++, texCoordMask = texCoordMask >> 1)
            {
                if (texCoordMask & 1)
                {
                    if (m_rasterStates.GetPSTexCoordWrap(i))
                    {
                        needsGeometryShader = true;
                        break;
                    }
                }
            }
        }

        return needsGeometryShader;
    }

    HRESULT VertexStage::ResolveDeferredState(Device &device, D3D12_GRAPHICS_PIPELINE_STATE_DESC& psoDesc)
    {
        HRESULT hr = S_OK;

        auto& ia = device.GetPipelineState().GetInputAssembly();
        auto& inputLayout = ia.GetInputLayout();

        // Must come before VSExtension
        if (m_dirtyFlags.Viewport)
        {
            // TODO: how to deal with MRT?
            ResolveViewPort(device);
        }

        if (m_dirtyFlags.PointSize)
        {
            m_VSExtension.ResolvePointSize();
            float pointSize = m_VSExtension.GetPointSize();

            // Check if PointSize should be enabled  
            m_rasterStates.SetPointSizeEnable((pointSize > 1.0f) ? 1 : 0);
        }

        if (m_dirtyFlags.VSExtension)
        {
            device.GetConstantsManager().UpdateVertexShaderExtension(m_VSExtension.GetVSCBExtension());
        }

        if (m_dirtyFlags.VertexShader || m_dirtyFlags.InputLayout)
        {
            if (inputLayout.VerticesArePreTransformed())
            {
                device.SetDrawingPreTransformedVerts(true);
                m_pCurrentD3D12VS = &m_tlShaderCache.GetD3D12ShaderForTL(inputLayout, m_rasterStates.GetRasterState());

                psoDesc.VS = m_pCurrentD3D12VS->GetUnderlying()->GetByteCode();
                psoDesc.InputLayout.pInputElementDescs = &m_pCurrentD3D12VS->m_inputElementDescs[0];
                psoDesc.InputLayout.NumElements = static_cast<UINT>(m_pCurrentD3D12VS->m_inputElementDescs.size());
            }
            else
            {
                device.SetDrawingPreTransformedVerts(false);
                m_pCurrentD3D12VS = &m_pCurrentVS->GetD3D12Shader(m_rasterStates.GetRasterState(), inputLayout);

                psoDesc.VS = m_pCurrentD3D12VS->GetUnderlying()->GetByteCode();

                psoDesc.InputLayout.pInputElementDescs = &m_pCurrentD3D12VS->m_inputElementDescs[0];
                psoDesc.InputLayout.NumElements = static_cast<UINT>(m_pCurrentD3D12VS->m_inputElementDescs.size());

                for (UINT i = 0; i < ARRAYSIZE(m_pCurrentD3D12VS->m_inlineConsts); i++)
                {
                    for (auto &data : m_pCurrentD3D12VS->m_inlineConsts[i])
                    {
                        device.GetConstantsManager().GetVertexShaderConstants().GetConstantBufferData((ShaderConv::eConstantBuffers)i).SetData((Float4*)&data.Value, data.RegIndex / 4, 1);
                    }
                }

                if (psoDesc.VS.pShaderBytecode == nullptr)
                {
                    hr = E_FAIL;
                    CHECK_HR(hr);
                }
            }

            m_dirtyFlags.PixelShader = true; // Different VSOutput means the PS may need to be recompiled
        }

        D3D12VertexShader* pShader = GetCurrentD3D12VertexShader();
        if (NeedsGeometryShader(pShader->m_vsOutputDecls))
        {
            D3D12GeometryShader& geo = m_geometryShaderCache.GetD3D12Shader(*m_pCurrentD3D12VS, m_rasterStates.GetRasterState());

            psoDesc.GS = geo.GetUnderlying()->GetByteCode();

            if (psoDesc.GS.pShaderBytecode == nullptr)
            {
                hr = E_FAIL;
                CHECK_HR(hr);
            }
            else
            {
                if (m_pCurrentD3D12GS != &geo)
                {
                    // Changing GS, pixel shader may need to be updated
                    m_dirtyFlags.PixelShader = true;
                }
                m_pCurrentD3D12GS = &geo;

                device.GetConstantsManager().UpdateGeometryShaderExtension(m_VSExtension.GetVSCBExtension());
            }
        }
        else
        {
            if (m_pCurrentD3D12GS != nullptr)
            {
                // Changing GS, pixel shader may need to be updated
                m_dirtyFlags.PixelShader = true;
            }
            psoDesc.GS = {};
            m_pCurrentD3D12GS = nullptr;
        }

        return hr;
    }

};
```

`src/9on12VideoDevice.cpp`:

```cpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#include "pch.h"

namespace D3D9on12
{
    VideoDevice::VideoDevice(Device *pParent) :
        m_pParentDevice(pParent)
    {
        m_pUnderlyingVideoDevice = new (m_pUnderlyingSpace)D3D12TranslationLayer::VideoDevice(&m_pParentDevice->GetContext());

        m_pUnderlyingVideoProcessEnum = new (m_pUnderlyingSpaceVPEnum)D3D12TranslationLayer::VideoProcessEnum(&m_pParentDevice->GetContext());
        m_pUnderlyingVideoProcessEnum->Initialize();

        // Cache max input streams info
        {
            D3D12_FEATURE_DATA_VIDEO_PROCESS_MAX_INPUT_STREAMS vpMaxInputStreams = {};
            m_pUnderlyingVideoProcessEnum->CheckFeatureSupport(D3D12_FEATURE_VIDEO_PROCESS_MAX_INPUT_STREAMS, &vpMaxInputStreams, sizeof(vpMaxInputStreams));
            m_vpMaxInputStreams = vpMaxInputStreams.MaxInputStreams;
        }

        m_vpDXVAHDCaps.reserve(m_maxVideoProcessors);
    }

    VideoDevice::~VideoDevice()
    {
        if (m_pUnderlyingVideoDevice)
        {
            m_pUnderlyingVideoDevice->~VideoDevice();
        }
        if (m_pUnderlyingVideoProcessEnum)
        {
            m_pUnderlyingVideoProcessEnum->~VideoProcessEnum();
        }
    }

    UINT FilterId(UINT ProcAmpCap)
    {
        UINT filter = 0;
        while (ProcAmpCap)
        {
            if (ProcAmpCap & 0x1)
            {
                return filter;
            }
            ++filter;
            ProcAmpCap >>= 1;
        }
        ThrowFailure(E_INVALIDARG);
        return 0;
    }

    _Use_decl_annotations_
    UINT VideoDevice::GetFilteredFormatsCount(const std::vector<DXGI_FORMAT> &vpFormats)
    {
        FORMATOP rgFormatOps[Adapter::MAX_SURFACE_FORMATS];
        UINT NumFormatOps = m_pParentDevice->GetAdapter().GetFormatData(rgFormatOps, _countof(rgFormatOps));

        UINT count = 0;
        for(UINT i = 0; i < (UINT)vpFormats.size(); i++)
        {
            for (UINT j = 0; j < NumFormatOps; j++)
            {
                if (rgFormatOps[j].Format == ConvertFromDXGIFormatToD3DDDIFormat(vpFormats[i]))
                {
                    count++;
                    break;
                }
            }
        }

        return count;
    };

    _Use_decl_annotations_
    void VideoDevice::GetCaps(CONST D3DDDIARG_GETCAPS* pGetCaps)
    {
        // VP output format order communicates preference.  Media pipeline attempts to create a swapchain with the first format
        // in the list, followed by the next, etc.  Move valid swapchain formats to the beginning of the list while preserving
        // the order of the remaining formats.
        auto pfnIsBackBufferSortRank = [](D3DDDIFORMAT fmt) 
        { 
            switch (fmt)
            {
                case D3DDDIFMT_A8R8G8B8:
                    return 0;
                case D3DDDIFMT_X8R8G8B8:
                    return 1;
            }

            return 100; // High default rank to allow more to be added above.
        };

        auto pfnGetFormats = [&](const std::vector<DXGI_FORMAT> &vpFormats, const std::function<UINT (D3DDDIFORMAT)>& fnSortRank = {})
        {
            FORMATOP rgFormatOps[Adapter::MAX_SURFACE_FORMATS];
            UINT NumFormatOps = m_pParentDevice->GetAdapter().GetFormatData(rgFormatOps, _countof(rgFormatOps));

            D3DDDIFORMAT *pD3DFormats = (D3DDDIFORMAT *)pGetCaps->pData;
            UINT count = pGetCaps->DataSize / sizeof(D3DDDIFORMAT);

            for (UINT unFilteredIndex = 0, filteredIndex = 0; unFilteredIndex < (UINT)vpFormats.size() && filteredIndex < count; unFilteredIndex++)
            {
                D3DDDIFORMAT d3dVpFmt = ConvertFromDXGIFormatToD3DDDIFormat(vpFormats[unFilteredIndex]); 

                for (UINT adapterFormatIndex = 0; adapterFormatIndex < NumFormatOps; adapterFormatIndex++)
                {
                    if (rgFormatOps[adapterFormatIndex].Format == d3dVpFmt)
                    {
                        pD3DFormats[filteredIndex++] = d3dVpFmt;
                        break;
                    }
                }
            }

            if (fnSortRank)
            {
                std::stable_sort(pD3DFormats, pD3DFormats + count, [fnSortRank](D3DDDIFORMAT fmt1, D3DDDIFORMAT fmt2){ return fnSortRank(fmt1) < fnSortRank(fmt2);});
            }
        };

        switch (pGetCaps->Type)
        {
            case D3DDDICAPS_GETDECODEGUIDCOUNT:
            {
                Check9on12(pGetCaps->DataSize == sizeof(UINT));
                UINT *pCount = (UINT *)pGetCaps->pData;
                m_pUnderlyingVideoDevice->GetVideoDecoderProfileCount(pCount);
            }
            break;

            case D3DDDICAPS_GETDECODEGUIDS:
            {
                Check9on12(pGetCaps->DataSize % sizeof(GUID) == 0);
                UINT count = pGetCaps->DataSize / sizeof(GUID);
                GUID *pGuids = (GUID *)pGetCaps->pData;
                for (DWORD i = 0; i < count; i++)
                {
                    m_pUnderlyingVideoDevice->GetVideoDecoderProfile(i, &pGuids[i]);
                }
            }
            break;

            case D3DDDICAPS_GETDECODERTFORMATCOUNT:
            {
                Check9on12(pGetCaps->DataSize == sizeof(UINT));
                GUID *pDecodeProfile = (GUID *)pGetCaps->pInfo;
                UINT *pCount = (UINT *)pGetCaps->pData;
                m_pUnderlyingVideoDevice->GetVideoDecoderFormatCount(pDecodeProfile, pCount);
            }
            break;

            case D3DDDICAPS_GETDECODERTFORMATS:
            {
                Check9on12(pGetCaps->DataSize % sizeof(D3DDDIFORMAT) == 0);
                GUID *pDecodeProfile = (GUID *)pGetCaps->pInfo;
                UINT count = pGetCaps->DataSize / sizeof(D3DDDIFORMAT);
                D3DDDIFORMAT *pD3DFormats = (D3DDDIFORMAT *)pGetCaps->pData;
                for (DWORD i = 0; i < count; i++)
                {
                    DXGI_FORMAT dxgiFormat = DXGI_FORMAT_UNKNOWN;
                    m_pUnderlyingVideoDevice->GetVideoDecoderFormat(pDecodeProfile, i, &dxgiFormat);
                    pD3DFormats[i] = ConvertFromDXGIFormatToD3DDDIFormat(dxgiFormat);
                }
            }
            break;

            case D3DDDICAPS_GETDECODECONFIGURATIONCOUNT:
            {
                Check9on12(pGetCaps->DataSize == sizeof(UINT));
                DXVADDI_DECODEINPUT *pDecodeInput = (DXVADDI_DECODEINPUT *)pGetCaps->pInfo;
                UINT *pCount = (UINT *)pGetCaps->pData;
                D3D12TranslationLayer::VIDEO_DECODE_DESC desc = {};
                VideoTranslate::VideoDecodeDesc(pDecodeInput, &desc);
                m_pUnderlyingVideoDevice->GetVideoDecoderConfigCount(&desc, pCount);
            }
            break;

            case D3DDDICAPS_GETDECODECONFIGURATIONS:
            {
                Check9on12(pGetCaps->DataSize % sizeof(DXVADDI_CONFIGPICTUREDECODE) == 0);
                DXVADDI_DECODEINPUT *pDecodeInput = (DXVADDI_DECODEINPUT *)pGetCaps->pInfo;
                UINT count = pGetCaps->DataSize / sizeof(DXVADDI_CONFIGPICTUREDECODE);
                D3D12TranslationLayer::VIDEO_DECODE_DESC desc = {};
                VideoTranslate::VideoDecodeDesc(pDecodeInput, &desc);
                DXVADDI_CONFIGPICTUREDECODE *pDXVAConfigs = (DXVADDI_CONFIGPICTUREDECODE *)pGetCaps->pData;
                for (DWORD i = 0; i < count; i++)
                {
                    D3D12TranslationLayer::VIDEO_DECODE_CONFIG config = {};
                    m_pUnderlyingVideoDevice->GetVideoDecoderConfig(&desc, i, &config);
                    VideoTranslate::VideoDecodeConfig(&desc, &config, &pDXVAConfigs[i]);
                }
            }
            break;

            case D3DDDICAPS_GETDECODECOMPRESSEDBUFFERINFOCOUNT:
            {
                Check9on12(pGetCaps->DataSize == sizeof(UINT));
                DXVADDI_DECODEINPUT *pDecodeInput = (DXVADDI_DECODEINPUT *)pGetCaps->pInfo;
                UINT *pCount = (UINT *)pGetCaps->pData;
                D3D12TranslationLayer::VIDEO_DECODE_DESC desc = {};
                VideoTranslate::VideoDecodeDesc(pDecodeInput, &desc);
                m_pUnderlyingVideoDevice->GetVideoDecoderBufferTypeCount(&desc, pCount);
            }
            break;

            case D3DDDICAPS_GETDECODECOMPRESSEDBUFFERINFO:
            {
                Check9on12(pGetCaps->DataSize % sizeof(DXVADDI_DECODEBUFFERINFO) == 0);
                DXVADDI_DECODEINPUT *pDecodeInput = (DXVADDI_DECODEINPUT *)pGetCaps->pInfo;
                UINT count = pGetCaps->DataSize / sizeof(DXVADDI_DECODEBUFFERINFO);
                D3D12TranslationLayer::VIDEO_DECODE_DESC desc = {};
                VideoTranslate::VideoDecodeDesc(pDecodeInput, &desc);
                DXVADDI_DECODEBUFFERINFO *pDXVABufferInfo = (DXVADDI_DECODEBUFFERINFO *)pGetCaps->pData;
                for (DWORD i = 0; i < count; i++)
                {
                    UINT size;
                    D3D12TranslationLayer::VIDEO_DECODE_BUFFER_TYPE type;
                    m_pUnderlyingVideoDevice->GetVideoDecoderBufferInfo(&desc, i, &type, &size);
                    VideoTranslate::VideoDecodeBufferInfo(type, size, &pDXVABufferInfo[i]);
                }
            }
            break;

            case D3DDDICAPS_GETVIDEOPROCESSORRTFORMATCOUNT:
            case D3DDDICAPS_GETVIDEOPROCESSORRTSUBSTREAMFORMATCOUNT:
            {
                Preamble<DXVADDI_VIDEOPROCESSORINPUT>(pGetCaps, pGetCaps->DataSize == sizeof(UINT));
                *reinterpret_cast<UINT*>(pGetCaps->pData) = GetFilteredFormatsCount(m_pUnderlyingVideoProcessEnum->GetVPOutputFormats());
            }
            break;

            case D3DDDICAPS_GETVIDEOPROCESSORRTFORMATS:
            case D3DDDICAPS_GETVIDEOPROCESSORRTSUBSTREAMFORMATS:
            {
                Preamble<DXVADDI_VIDEOPROCESSORINPUT>(pGetCaps, pGetCaps->DataSize % sizeof(D3DDDIFORMAT) == 0);
                pfnGetFormats(m_pUnderlyingVideoProcessEnum->GetVPOutputFormats(), pfnIsBackBufferSortRank);
            }
            break;

            case D3DDDICAPS_GETVIDEOPROCESSORDEVICEGUIDCOUNT:
            {
                Preamble<DXVADDI_VIDEODESC>(pGetCaps, pGetCaps->DataSize == sizeof(UINT));
                *reinterpret_cast<UINT*>(pGetCaps->pData) = (UINT)m_vpDXVAHDCaps.size();
            }
            break;

            case D3DDDICAPS_GETVIDEOPROCESSORDEVICEGUIDS:
            {
                Preamble<DXVADDI_VIDEODESC>(pGetCaps, pGetCaps->DataSize % sizeof(GUID) == 0);

                UINT count = min(pGetCaps->DataSize / (UINT)sizeof(GUID), (UINT)m_vpDXVAHDCaps.size());
                GUID *pGuid = (GUID *)pGetCaps->pData;
                for (UINT i = 0; i < count; i++)
                {
                    pGuid[i] = m_vpDXVAHDCaps[i].VPGuid;
                }
            }
            break;

            case D3DDDICAPS_GETVIDEOPROCESSORCAPS:
            {
                Preamble<DXVADDI_VIDEOPROCESSORINPUT>(pGetCaps, pGetCaps->DataSize == sizeof(DXVADDI_VIDEOPROCESSORCAPS));

                DXVADDI_VIDEOPROCESSORINPUT *pVideoProcessorInput = static_cast<DXVADDI_VIDEOPROCESSORINPUT *>(pGetCaps->pInfo);
                DXVADDI_VIDEOPROCESSORCAPS *pVPCaps = (DXVADDI_VIDEOPROCESSORCAPS *)pGetCaps->pData;

                size_t dxvaCapsIndex = 0;
                for(;dxvaCapsIndex < m_vpDXVAHDCaps.size(); ++dxvaCapsIndex)
                {
                    if (*pVideoProcessorInput->pVideoProcGuid == m_vpDXVAHDCaps[dxvaCapsIndex].VPGuid)
                    {
                        break;
                    }
                }

                if (dxvaCapsIndex >= m_vpDXVAHDCaps.size())
                {
                    assert(m_vpDXVAHDCaps.size() >= 1);

                    // The requested DXVA guid was not found.  9on12 originally shipped without checking the incomming
                    // guid.  It's not know if failing at this point would introduce an app compat problem as a number of
                    // vendor defined GUIDs exist.
                    dxvaCapsIndex = 0;
                }

                pVPCaps->InputPool = m_vpDXVAHDDevCaps.InputPool;
                pVPCaps->NumForwardRefSamples = m_vpDXVAHDCaps[dxvaCapsIndex].FutureFrames;
                pVPCaps->NumBackwardRefSamples = m_vpDXVAHDCaps[dxvaCapsIndex].PastFrames;
                pVPCaps->OutputFormat = pVideoProcessorInput->RenderTargetFormat;
                pVPCaps->DeinterlaceTechnology |= (m_vpDXVAHDCaps[dxvaCapsIndex].ProcessorCaps & DXVAHDDDI_PROCESSOR_CAPS_DEINTERLACE_BOB) ? DXVADDI_DEINTERLACETECH_BOBLINEREPLICATE : 0;
                pVPCaps->DeinterlaceTechnology |= (m_vpDXVAHDCaps[dxvaCapsIndex].ProcessorCaps & DXVAHDDDI_PROCESSOR_CAPS_DEINTERLACE_ADAPTIVE) ? DXVADDI_DEINTERLACETECH_FIELDADAPTIVE : 0;
                pVPCaps->ProcAmpControlCaps = m_vpDXVAHDDevCaps.FilterCaps & ~(DXVAHDDDI_FILTER_CAPS_NOISE_REDUCTION | DXVAHDDDI_FILTER_CAPS_EDGE_ENHANCEMENT | DXVAHDDDI_FILTER_CAPS_ANAMORPHIC_SCALING);

                // Minimal set of VideoProcessorOperations for dxva Caps
                pVPCaps->VideoProcessorOperations |= DXVADDI_VIDEOPROCESS_YUV2RGB | DXVADDI_VIDEOPROCESS_STRETCHX | DXVADDI_VIDEOPROCESS_STRETCHY | DXVADDI_VIDEOPROCESS_SUBRECTS;

                pVPCaps->VideoProcessorOperations |= (m_vpDXVAHDDevCaps.FeatureCaps & DXVAHDDDI_FEATURE_CAPS_ALPHA_FILL) ? DXVADDI_VIDEOPROCESS_PLANARALPHA : 0;
                pVPCaps->VideoProcessorOperations |= (m_vpDXVAHDDevCaps.DeviceCaps & DXVAHDDDI_DEVICE_CAPS_LINEAR_SPACE) ? DXVADDI_VIDEOPROCESS_LINEARSCALING : 0;
                pVPCaps->VideoProcessorOperations |=  (m_vpDXVAHDDevCaps.MaxInputStreams > 1) ? (DXVADDI_VIDEOPROCESS_SUBSTREAMS | DXVADDI_VIDEOPROCESS_SUBSTREAMSEXTENDED) : 0;
                pVPCaps->VideoProcessorOperations |= m_fAlphaBlending ? DXVADDI_VIDEOPROCESS_ALPHABLEND : 0;

                pVPCaps->NoiseFilterTechnology = 0;
                pVPCaps->DetailFilterTechnology = 0;
            }
            break;

            case D3DDDICAPS_GETPROCAMPRANGE:
            {
                // TODO: should we return E_NOTIMPL? since there's a mismatch between setting the PROCAMP values in input (DX12) x output (DXVA)
                // Should we add instead output control to DX12?
                Preamble<DXVADDI_QUERYPROCAMPINPUT>(pGetCaps, pGetCaps->DataSize == sizeof(DXVADDI_VALUERANGE));
                DXVADDI_QUERYPROCAMPINPUT *pInput = (DXVADDI_QUERYPROCAMPINPUT *)pGetCaps->pInfo;
                DXVADDI_VALUERANGE *pValue = (DXVADDI_VALUERANGE *)pGetCaps->pData;
                UINT filter = FilterId(pInput->ProcAmpCap);

                // Conversion between D3D12 to DXVA Multiplier/StepSize semantics.
                // Need to de-normalize the d3d12 range expressed as an expanded scaled range with unitary integer steps to the DXVA expressed as an absolute range with the fractional step.
                    // D3D12 semantics
                    // https://docs.microsoft.com/zh-cn/windows-hardware/drivers/ddi/d3d12umddi/ns-d3d12umddi-d3d12ddi_video_process_filter_range_0020
                    // The multiplier enables the filter range to have a fractional step value. For example, a hue filter might have an actual range of [–180.0 ... +180.0] with a step size of 0.25. 
                    // The device would report the following range and multiplier:
                    // Minimum: –720
                    // Maximum : +720
                    // Multiplier : 0.25
                    // In this case, a filter value of 2 would be interpreted by the device as 0.50, which is 2 × 0.25.
                    // The device should use a multiplier that can be represented exactly as a base - 2 fraction.
                    //
                    // DXVA semantics
                    // https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/d3dumddi/ns-d3dumddi-_dxvaddi_valuerange
                    // The range is expressed in absolute terms in Minimum, Maximum, Default. The allowed precision step between that range is defined in StepSize.
                    // For example, a hue filter might have an actual range of [–180.0 ... +180.0] with a step size of 0.25. 
                    // The device would report the following range and multiplier:
                    // Minimum: –180
                    // Maximum : +180
                    // StepSize : 0.25

                pValue->MinValue = VideoTranslate::ToFixed32<INT>(static_cast<INT>(floor(m_filterRanges[filter].Minimum * m_filterRanges[filter].Multiplier)));
                pValue->MaxValue = VideoTranslate::ToFixed32<INT>(static_cast<INT>(floor(m_filterRanges[filter].Maximum * m_filterRanges[filter].Multiplier)));
                pValue->DefaultValue = VideoTranslate::ToFixed32<INT>(static_cast<INT>(floor(m_filterRanges[filter].Default * m_filterRanges[filter].Multiplier)));
                pValue->StepSize = VideoTranslate::ToFixed32<FLOAT>(m_filterRanges[filter].Multiplier);
            }
            break;

            case D3DDDICAPS_DXVAHD_GETVPOUTPUTFORMATS:
            {
                Preamble<DXVAHDDDI_DEVICE_DESC>(pGetCaps, pGetCaps->DataSize % sizeof(D3DDDIFORMAT) == 0);
                pfnGetFormats(m_pUnderlyingVideoProcessEnum->GetVPOutputFormats(), pfnIsBackBufferSortRank);
            }
            break;

            case D3DDDICAPS_DXVAHD_GETVPINPUTFORMATS:
            {
                Preamble<DXVAHDDDI_DEVICE_DESC>(pGetCaps, pGetCaps->DataSize % sizeof(D3DDDIFORMAT) == 0);
                pfnGetFormats(m_pUnderlyingVideoProcessEnum->GetVPInputFormats());
            }
            break;

            case D3DDDICAPS_DXVAHD_GETVPDEVCAPS:
            {
                Preamble<DXVAHDDDI_DEVICE_DESC>(pGetCaps, pGetCaps->DataSize == sizeof(DXVAHDDDI_VPDEVCAPS));
                DXVAHDDDI_VPDEVCAPS *pVPDevCaps = (DXVAHDDDI_VPDEVCAPS *)pGetCaps->pData;
                *pVPDevCaps = m_vpDXVAHDDevCaps;
            }
            break;

            case D3DDDICAPS_DXVAHD_GETVPCAPS:
            {
                Preamble<DXVAHDDDI_DEVICE_DESC>(pGetCaps, pGetCaps->DataSize % sizeof(DXVAHDDDI_VPCAPS) == 0);
                DXVAHDDDI_VPCAPS *pVPCaps = (DXVAHDDDI_VPCAPS *)pGetCaps->pData;
                UINT count = pGetCaps->DataSize / sizeof(DXVAHDDDI_VPCAPS);
                for (UINT i = 0; i < count; i++)
                {
                    pVPCaps[i] = m_vpDXVAHDCaps[i];
                }
            }
            break;

            case D3DDDICAPS_DXVAHD_GETVPCUSTOMRATES:
            {
                Check9on12(pGetCaps->DataSize % sizeof(DXVAHDDDI_CUSTOM_RATE_DATA) == 0);
#pragma warning( suppress :22107)  
                // The input structure has no SAL annotation and cannot be fixed easily, so suppress instead  
                ZeroMemory(pGetCaps->pData, pGetCaps->DataSize);
            }
            break;

            case D3DDDICAPS_DXVAHD_GETVPFILTERRANGE:
            {
                Check9on12(pGetCaps->DataSize == sizeof(DXVAHDDDI_FILTER_RANGE_DATA));
#pragma warning( suppress :22107)  
                // The input structure has no SAL annotation and cannot be fixed easily, so suppress instead  
                ZeroMemory(pGetCaps->pData, pGetCaps->DataSize);
                DXVAHDDDI_FILTER_RANGE_DATA *pFilterRange = (DXVAHDDDI_FILTER_RANGE_DATA *)pGetCaps->pData;
                DXVAHDDDI_FILTER filter = *(DXVAHDDDI_FILTER  *)pGetCaps->pInfo;
                if ((UINT)filter > DXVAHDDDI_FILTER_ANAMORPHIC_SCALING || (UINT)filter > MAX_VIDEO_PROCESSOR_FILTERS)
                {
                    ThrowFailure(E_INVALIDARG);
                }
                *pFilterRange = m_filterRanges[filter];
            }
            break;

            case D3DDDICAPS_GETEXTENSIONGUIDCOUNT:
            {
                Check9on12(pGetCaps->DataSize % sizeof(UINT) == 0);
#pragma warning( suppress :22107)  
                // The input structure has no SAL annotation and cannot be fixed easily, so suppress instead  
                ZeroMemory(pGetCaps->pData, pGetCaps->DataSize);
            }
            break;

            case D3DDDICAPS_GETEXTENSIONGUIDS:
            {
                Check9on12(pGetCaps->DataSize % sizeof(GUID) == 0);
#pragma warning( suppress :22107)  
                // The input structure has no SAL annotation and cannot be fixed easily, so suppress instead  
                ZeroMemory(pGetCaps->pData, pGetCaps->DataSize);
            }
            break;

            case D3DDDICAPS_FILTERPROPERTYRANGE:        // invalid filters in DX12
            case D3DDDICAPS_GETEXTENSIONCAPS:           // no extension guids were returned, so invalid to call extension caps.
            default:
                ZeroMemory(pGetCaps->pData, pGetCaps->DataSize);
                ThrowFailure(E_UNEXPECTED);
                break;
        }
    }

    template<typename T>
    _Use_decl_annotations_
    void VideoDevice::Preamble(CONST D3DDDIARG_GETCAPS* pGetCaps, bool expression)
    {
        Check9on12(expression);
#pragma warning( suppress :22107)  
        // The input structure has no SAL annotation and cannot be fixed easily, so suppress instead  
        ZeroMemory(pGetCaps->pData, pGetCaps->DataSize);

        D3DDDIFORMAT rtFormat;
        T *pInfo = (T *)pGetCaps->pInfo;
        D3D12TranslationLayer::VIDEO_PROCESS_ENUM_ARGS args;
        VideoTranslate::VideoProcessDesc(pInfo, m_vpMaxInputStreams, args, rtFormat);
        CacheVideoProcessInfo(args);
    }

    _Use_decl_annotations_
    void VideoDevice::CacheVideoProcessInfo(D3D12TranslationLayer::VIDEO_PROCESS_ENUM_ARGS &args)
    {
        if (m_currentVideoProcessArgs.InputFieldType != args.InputFieldType ||
            m_currentVideoProcessArgs.InputWidth != args.InputWidth ||
            m_currentVideoProcessArgs.InputHeight != args.InputHeight ||
            m_currentVideoProcessArgs.OutputWidth != args.OutputWidth ||
            m_currentVideoProcessArgs.OutputHeight != args.OutputHeight)
        {
            m_pUnderlyingVideoProcessEnum->CacheVideoProcessInfo(args);

            std::vector<D3D12TranslationLayer::VIDEO_PROCESS_SUPPORT> vpSupportTuples = m_pUnderlyingVideoProcessEnum->GetVPCapsSupportTuples();

            DXVAHDDDI_VPCAPS vpDXVAHDCaps = {};
            ZeroMemory(&m_vpDXVAHDDevCaps, sizeof(m_vpDXVAHDDevCaps));
            m_fAlphaBlending = false;

            for (auto& tuple : vpSupportTuples)
            {
                // translate to DXVA & DXVA HD CAPS
                VideoTranslate::AddVideoProcessCaps(tuple.dx12Support, m_vpDXVAHDDevCaps, m_filterRanges, _countof(m_filterRanges), tuple.colorConversionCaps, m_fAlphaBlending);
            }

            D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS deinterlaceFlags = m_pUnderlyingVideoProcessEnum->GetDeinterlaceSupport();

            m_vpDXVAHDCaps.resize(1);
            m_vpDXVAHDCaps[0] = vpDXVAHDCaps;
            m_vpDXVAHDCaps[0].VPGuid = DXVADDI_VideoProcProgressiveDevice;
            
            auto referenceInfo = m_pUnderlyingVideoProcessEnum->UpdateReferenceInfo(D3D12_VIDEO_PROCESS_DEINTERLACE_FLAG_NONE);
            m_vpDXVAHDCaps[0].PastFrames = referenceInfo.pastFrames;
            m_vpDXVAHDCaps[0].FutureFrames = referenceInfo.futureFrames;
            m_vpDXVAHDCaps[0].ProcessorCaps |= referenceInfo.frameRateConversionSupported ? DXVAHDDDI_PROCESSOR_CAPS_FRAME_RATE_CONVERSION : 0;

            if (deinterlaceFlags & D3D12_VIDEO_PROCESS_DEINTERLACE_FLAG_BOB)
            {
                m_vpDXVAHDCaps.resize(2);
                m_vpDXVAHDCaps[1] = vpDXVAHDCaps;
                m_vpDXVAHDCaps[1].VPGuid = DXVADDI_VideoProcBobDevice;

                referenceInfo = m_pUnderlyingVideoProcessEnum->UpdateReferenceInfo(D3D12_VIDEO_PROCESS_DEINTERLACE_FLAG_BOB);
                m_vpDXVAHDCaps[1].PastFrames = referenceInfo.pastFrames;
                m_vpDXVAHDCaps[1].FutureFrames = referenceInfo.futureFrames;
                m_vpDXVAHDCaps[1].ProcessorCaps |= referenceInfo.frameRateConversionSupported ? DXVAHDDDI_PROCESSOR_CAPS_FRAME_RATE_CONVERSION : 0;
                m_vpDXVAHDCaps[1].ProcessorCaps |= DXVAHDDDI_PROCESSOR_CAPS_DEINTERLACE_BOB;

                if (deinterlaceFlags & D3D12_VIDEO_PROCESS_DEINTERLACE_FLAG_CUSTOM)
                {
                    m_vpDXVAHDCaps.resize(3);
                    m_vpDXVAHDCaps[2] = vpDXVAHDCaps;
                    m_vpDXVAHDCaps[2].VPGuid = DXVADDI_VideoProcD3D9On12CustomDeinterlaceDevice;

                    referenceInfo = m_pUnderlyingVideoProcessEnum->UpdateReferenceInfo(deinterlaceFlags);
                    m_vpDXVAHDCaps[2].PastFrames = referenceInfo.pastFrames;
                    m_vpDXVAHDCaps[2].FutureFrames = referenceInfo.futureFrames;
                    m_vpDXVAHDCaps[2].ProcessorCaps |= referenceInfo.frameRateConversionSupported ? DXVAHDDDI_PROCESSOR_CAPS_FRAME_RATE_CONVERSION : 0;
                    m_vpDXVAHDCaps[2].ProcessorCaps |= DXVAHDDDI_PROCESSOR_CAPS_DEINTERLACE_BOB | DXVAHDDDI_PROCESSOR_CAPS_DEINTERLACE_ADAPTIVE;
                }
            }

            m_vpDXVAHDDevCaps.InputPool = D3DDDIPOOL_VIDEOMEMORY;
            m_vpDXVAHDDevCaps.InputFormatCount = GetFilteredFormatsCount(m_pUnderlyingVideoProcessEnum->GetVPInputFormats());
            m_vpDXVAHDDevCaps.OutputFormatCount = GetFilteredFormatsCount(m_pUnderlyingVideoProcessEnum->GetVPOutputFormats());
            m_vpDXVAHDDevCaps.VideoProcessorCount = (UINT)m_vpDXVAHDCaps.size();

            // translate max input streams info
            VideoTranslate::AddVideoProcessCaps(m_vpMaxInputStreams, m_vpDXVAHDDevCaps);

            m_currentVideoProcessArgs = args;
        }
    }

};

```

`src/9on12VideoProcessDevice.cpp`:

```cpp
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
#include "pch.h"


namespace D3D9on12
{

    _Check_return_ HRESULT APIENTRY CreateVideoProcessDevice(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_CREATEVIDEOPROCESSDEVICE *pCreateVideoProcessDevice)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr  ||  pCreateVideoProcessDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }
        VideoProcessDevice *pVideoProcessDevice = new VideoProcessDevice (pCreateVideoProcessDevice->hVideoProcess, pDevice, pCreateVideoProcessDevice);
        if (pVideoProcessDevice == nullptr)
        {
            return E_OUTOFMEMORY;
        }

        pCreateVideoProcessDevice->hVideoProcess = VideoProcessDevice::GetHandleFromVideoProcessDevice(pVideoProcessDevice);

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY DestroyVideoProcessDevice(_In_ HANDLE /* hDevice */, _In_ HANDLE hVideoProcessDevice)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        VideoProcessDevice *pVideoProcessDevice = VideoProcessDevice::GetVideoProcessDeviceFromHandle(hVideoProcessDevice);
        if (pVideoProcessDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        delete pVideoProcessDevice;

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY VideoProcessBeginFrame(_In_ HANDLE /* hDevice */, _In_ HANDLE hVideoProcessDevice)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        VideoProcessDevice *pVideoProcessDevice = VideoProcessDevice::GetVideoProcessDeviceFromHandle(hVideoProcessDevice);
        if (pVideoProcessDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY VideoProcessEndFrame(_In_ HANDLE /* hDevice */, _Inout_ D3DDDIARG_VIDEOPROCESSENDFRAME * pEndFrame)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        VideoProcessDevice *pVideoProcessDevice = VideoProcessDevice::GetVideoProcessDeviceFromHandle(pEndFrame->hVideoProcess);
        if (pVideoProcessDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY SetVideoProcessRenderTarget(_In_ HANDLE /* hDevice */, _In_ CONST D3DDDIARG_SETVIDEOPROCESSRENDERTARGET *pRenderTarget)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        VideoProcessDevice *pVideoProcessDevice = VideoProcessDevice::GetVideoProcessDeviceFromHandle(pRenderTarget->hVideoProcess);
        if (pVideoProcessDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }
        pVideoProcessDevice->SetRenderTarget(pRenderTarget);
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY VideoProcessBlit(_In_ HANDLE /* hDevice */, _In_ CONST D3DDDIARG_VIDEOPROCESSBLT *pBlit)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        VideoProcessDevice *pVideoProcessDevice = VideoProcessDevice::GetVideoProcessDeviceFromHandle(pBlit->hVideoProcess);
        if (pVideoProcessDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }
        pVideoProcessDevice->Blit(pBlit);
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    /////////////////////////////////////////////////////////////////////////////
    // DXVA-HD entry points
    /////////////////////////////////////////////////////////////////////////////

    _Check_return_ HRESULT APIENTRY DXVAHD_CreateVideoProcessor(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_DXVAHD_CREATEVIDEOPROCESSOR *pCreateVideoProcessor)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr || pCreateVideoProcessor == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }

        VideoProcessDevice *pVideoProcessDevice = new VideoProcessDevice(pDevice, pCreateVideoProcessor);
        if (pVideoProcessDevice == nullptr)
        {
            return E_OUTOFMEMORY;
        }

        pCreateVideoProcessor->hVideoProcessor = VideoProcessDevice::GetHandleFromVideoProcessDevice(pVideoProcessDevice);

        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY DXVAHD_SetVideoProcessorBlitState(_In_ HANDLE /*hDevice*/, _In_ CONST D3DDDIARG_DXVAHD_SETVIDEOPROCESSBLTSTATE *pBltState)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        VideoProcessDevice *pVideoProcessDevice = VideoProcessDevice::GetVideoProcessDeviceFromHandle(pBltState->hVideoProcessor);
        if (pVideoProcessDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }
        pVideoProcessDevice->SetBlitState(pBltState);
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY DXVAHD_GetVideoProcessorBlitState(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_DXVAHD_GETVIDEOPROCESSBLTSTATEPRIVATE*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_FAIL);        // no privates in DX12.  E_FAIL is required by DXVAHDVideoProcessing tests
    }

    _Check_return_ HRESULT APIENTRY DXVAHD_SetVideoProcessorStreamState(_In_ HANDLE /*hDevice*/, _In_ CONST D3DDDIARG_DXVAHD_SETVIDEOPROCESSSTREAMSTATE *pStreamState)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        VideoProcessDevice *pVideoProcessDevice = VideoProcessDevice::GetVideoProcessDeviceFromHandle(pStreamState->hVideoProcessor);
        if (pVideoProcessDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }
        pVideoProcessDevice->SetStreamState(pStreamState);
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY DXVAHD_GetVideoProcessorStreamState(_In_ HANDLE hDevice, _Inout_ D3DDDIARG_DXVAHD_GETVIDEOPROCESSSTREAMSTATEPRIVATE*)
    {
        D3D9on12_DDI_ENTRYPOINT_START(FALSE);
        Device* pDevice = Device::GetDeviceFromHandle(hDevice);
        if (pDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(E_UNEXPECTED);        // no privates in DX12
    }

    _Check_return_ HRESULT APIENTRY DXVAHD_VideoProcessBlitHD(_In_ HANDLE /*hDevice*/, _In_ CONST D3DDDIARG_DXVAHD_VIDEOPROCESSBLTHD* pBlitHD)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        VideoProcessDevice *pVideoProcessDevice = VideoProcessDevice::GetVideoProcessDeviceFromHandle(pBlitHD->hVideoProcessor);
        if (pVideoProcessDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }
        pVideoProcessDevice->BlitHD(pBlitHD);
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    _Check_return_ HRESULT APIENTRY DXVAHD_DestroyVideoProcessor(_In_ HANDLE /* hDevice */, _In_ HANDLE hVideoProcessDevice)
    {
        D3D9on12_DDI_ENTRYPOINT_START(TRUE);
        VideoProcessDevice *pVideoProcessDevice = VideoProcessDevice::GetVideoProcessDeviceFromHandle(hVideoProcessDevice);
        if (pVideoProcessDevice == nullptr)
        {
            RETURN_E_INVALIDARG_AND_CHECK();
        }
        delete pVideoProcessDevice;
        D3D9on12_DDI_ENTRYPOINT_END_AND_RETURN_HR(S_OK);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////
    // VideoProcessDevice
    ////////////////////////////////////////////////////////////////////////////////////////////

    _Use_decl_annotations_
    VideoProcessDevice::VideoProcessDevice(HANDLE /*runtimeHandle*/, Device *pParent, const D3DDDIARG_CREATEVIDEOPROCESSDEVICE *pCreateVideoProcessDevice) :
        m_pParentDevice(pParent)
    {
        m_pParentDevice->EnsureVideoDevice();
        m_MaxInputStreams = pCreateVideoProcessDevice->MaxSubStreams + 1;
        m_inputArguments.ResetStreams(m_MaxInputStreams);       // throw(bad_alloc)

        D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS DeinterlaceMode = D3D12_VIDEO_PROCESS_DEINTERLACE_FLAG_BOB;
        if (   pCreateVideoProcessDevice->pVideoProcGuid != nullptr
            && *pCreateVideoProcessDevice->pVideoProcGuid == DXVADDI_VideoProcD3D9On12CustomDeinterlaceDevice)
        {
            DeinterlaceMode |= D3D12_VIDEO_PROCESS_DEINTERLACE_FLAG_CUSTOM;
        }

        m_pUnderlyingVideoProcess = new (m_pUnderlyingSpace) D3D12TranslationLayer::VideoProcess(&m_pParentDevice->GetContext(), DeinterlaceMode);
    }

    _Use_decl_annotations_
    VideoProcessDevice::VideoProcessDevice(Device *pParent, const D3DDDIARG_DXVAHD_CREATEVIDEOPROCESSOR  * pCreateVideoProcessDevice) :
        m_pParentDevice(pParent)
    {
        m_pParentDevice->EnsureVideoDevice();
        VideoDevice *pVideoDevice = m_pParentDevice->GetVideoDevice();
        m_MaxInputStreams = pVideoDevice->GetMaxInputStreams();
        m_inputArguments.ResetStreams(m_MaxInputStreams);       // throw(bad_alloc)
        m_dxvaHDStreamStates.resize(m_MaxInputStreams);

        D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS DeinterlaceMode = D3D12_VIDEO_PROCESS_DEINTERLACE_FLAG_BOB;
        if (   pCreateVideoProcessDevice->pVPGuid != nullptr
            && *pCreateVideoProcessDevice->pVPGuid == DXVADDI_VideoProcD3D9On12CustomDeinterlaceDevice)
        {
            DeinterlaceMode |= D3D12_VIDEO_PROCESS_DEINTERLACE_FLAG_CUSTOM;
        }

        m_pUnderlyingVideoProcess = new (m_pUnderlyingSpace) D3D12TranslationLayer::VideoProcess(&m_pParentDevice->GetContext(), DeinterlaceMode);
    }

    VideoProcessDevice::~VideoProcessDevice()
    {
        if (m_pUnderlyingVideoProcess)
        {
            m_pUnderlyingVideoProcess->~VideoProcess();
        }
    }

    _Use_decl_annotations_
    void VideoProcessDevice::SetRenderTarget(CONST D3DDDIARG_SETVIDEOPROCESSRENDERTARGET *pRenderTarget)
    {
        SetViewInfo(pRenderTarget->hRenderTarget, pRenderTarget->SubResourceIndex, &m_outputArguments.CurrentFrame[0]);
        Resource *pResource = Resource::GetResourceFromHandle(pRenderTarget->hRenderTarget);
        m_inUseResources.target = pResource->GetUnderlyingResource();
    }

    _Use_decl_annotations_
    void VideoProcessDevice::SetViewInfo(HANDLE hResource, UINT subresourceIndex, D3D12TranslationLayer::VideoProcessView *pView)
    {
        Resource *pResource = Resource::GetResourceFromHandle(hResource);
        pView->pResource = pResource->GetUnderlyingResource();

        D3D12TranslationLayer::AppResourceDesc* pAppDesc = pResource->GetUnderlyingResource()->AppDesc();

        // Method used for both input and output views, but VIDEO_PROCESSOR_INPUT_VIEW_DESC_INTERNAL.
        D3D12TranslationLayer::VIDEO_PROCESSOR_INPUT_VIEW_DESC_INTERNAL viewDesc = { pAppDesc->Format(), 0, subresourceIndex }; 

        const UINT8 MipLevels = pAppDesc->MipLevels();
        const UINT16 ArraySize = pAppDesc->ArraySize();
        const UINT8 PlaneCount = (pResource->GetUnderlyingResource()->SubresourceMultiplier() * pAppDesc->NonOpaquePlaneCount());

        pView->SubresourceSubset = D3D12TranslationLayer::CViewSubresourceSubset(viewDesc, MipLevels, ArraySize, PlaneCount);
    }

    _Use_decl_annotations_
    void VideoProcessDevice::SetFilter(D3D12_VIDEO_PROCESS_FILTER filter, D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC *pStreamDesc, D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1 *pStreamArguments, INT level)
    {
        pStreamDesc->FilterFlags |= (D3D12_VIDEO_PROCESS_FILTER_FLAGS)(1 << (UINT)filter);
        
        // Conversion between DXVA and D3D12 Multiplier/StepSize semantics.
        // Need to re-normalize the DXVA range expressed as an absolute range with the fractional step to the D3D12 semantics as an expanded scaled range with unitary integer steps
            // DXVA semantics
            // https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/d3dumddi/ns-d3dumddi-_dxvaddi_valuerange
            // The range is expressed in absolute terms in Minimum, Maximum, Default. The allowed precision step between that range is defined in StepSize.
            // For example, a hue filter might have an actual range of [–180.0 ... +180.0] with a step size of 0.25. 
            // The device would report the following range and multiplier:
            // Minimum: –180
            // Maximum : +180
            // StepSize : 0.25
            // 
            // D3D12 semantics
            // https://docs.microsoft.com/zh-cn/windows-hardware/drivers/ddi/d3d12umddi/ns-d3d12umddi-d3d12ddi_video_process_filter_range_0020
            // The multiplier enables the filter range to have a fractional step value. For example, a hue filter might have an actual range of [–180.0 ... +180.0] with a step size of 0.25. 
            // The device would report the following range and multiplier:
            // Minimum: –720
            // Maximum : +720
            // Multiplier : 0.25
            // In this case, a filter value of 2 would be interpreted by the device as 0.50, which is 2 × 0.25.
            // The device should use a multiplier that can be represented exactly as a base - 2 fraction.

        FLOAT rangesMultiplier = m_pParentDevice->GetVideoDevice()->GetFilterRangeMultiplier(filter);
        pStreamArguments->FilterLevels[filter] = static_cast<INT>(floor(level / rangesMultiplier));
    }

    _Use_decl_annotations_
    void VideoProcessDevice::Blit(CONST D3DDDIARG_VIDEOPROCESSBLT *pBlit)
    {
        assert(m_outputArguments.CurrentFrame[0].pResource);

        // output target rectangle
        static_assert(sizeof(m_outputArguments.D3D12OutputStreamArguments.TargetRectangle) == sizeof(pBlit->TargetRect), "Rects should match");
        if (pBlit->DestFlags.TargetRectChanged)
        {
            m_outputArguments.D3D12OutputStreamArguments.TargetRectangle = *reinterpret_cast<const D3D12_RECT*>(&pBlit->TargetRect);
            m_outputArguments.EnableTargetRect = true;
        }

        // output background color + output alpha fill mode
        if (pBlit->DestFlags.BackgroundChanged)
        {
            VideoTranslate::VideoColor(&pBlit->BackgroundColor, m_outputArguments.D3D12OutputStreamDesc.BackgroundColor);
            m_outputArguments.BackgroundColorYCbCr = true;      // bg color is always specified as YUV color, according to MSDN
            m_outputArguments.BackgroundColorSet = true;
        }

        if (pBlit->DestFlags.AlphaChanged)
        {
            const DXVA2_Fixed32 opaqueAlpha = DXVA2_Fixed32OpaqueAlpha();
            if (pBlit->Alpha.ll == opaqueAlpha.ll)
            {
                m_outputArguments.D3D12OutputStreamDesc.AlphaFillMode = D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE_OPAQUE;
            }
            else
            {
                // unclear what the interaction between the Alpha & the Alpha in the background color are in this case:
                // https://msdn.microsoft.com/en-us/library/windows/desktop/hh447648(v=vs.85).aspx
                // We assume that the explicit alpha overrides whatever was set in the alpha for the BG color above.
                m_outputArguments.D3D12OutputStreamDesc.AlphaFillMode = D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE_BACKGROUND;
                float alpha = VideoTranslate::FromFixed32<float>(pBlit->Alpha);
                m_outputArguments.D3D12OutputStreamDesc.BackgroundColor[3] = alpha;
            }
        }

        // output constriction: can't allow size != target && size != 0
        if (((UINT)pBlit->ConstrictionSize.cx != RectWidth(pBlit->TargetRect) || (UINT)pBlit->ConstrictionSize.cy != RectHeight(pBlit->TargetRect)) && 
             (pBlit->ConstrictionSize.cx != 0 || pBlit->ConstrictionSize.cy != 0))
        {
            ThrowFailure(E_INVALIDARG);        // constriction not allowed in DX12
        }

        // output stereo
        m_outputArguments.D3D12OutputStreamDesc.EnableStereo = FALSE;

        // output color space
        // Note that dxva2 does not set the color data changed if all DestFlags are 0s. Unfortunately, we still need to map the 0s (DXVA2_NominalRange_Unknown,  
        // DXVA2_VideoTransferMatrix_Unknown and DXVA2_VideoTransFunc_Unknown) to a valid DXGI value.
        if (pBlit->DestFlags.ColorDataChanged  ||  m_colorSpaceNeverSet)
        {
            ID3D12Resource *pTexture = m_outputArguments.CurrentFrame[0].pResource->GetUnderlyingResource();
            const D3D12_RESOURCE_DESC &desc = pTexture->GetDesc();
            m_outputArguments.D3D12OutputStreamDesc.ColorSpace = VideoTranslate::ColorSpaceType(desc.Format, desc.Height, pBlit->DestFormat);
            m_outputArguments.ColorSpaceSet = true;
        }

        // The DXVA2 runtime method CVideoProcessorDevice::VideoProcessBlt() method doesn't set DXVA2_SampleFlag_PlanarAlpha_Changed
        // if PlanarAlpha is not != than the previous method call's PlanarAlpha value. Since the initial value of PlanarAlpha is zero
        // and DXVA2_Fixed32TransparentAlpha is also 0, when setting alpha transparent for the first process call,
        // the flag never gets triggered even when we want to blend 
        // m_outputArguments.D3D12OutputStreamDesc.AlphaFillMode = D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE_OPAQUE in the composite rect
        // with transparent for the sample rect in the first video process call.
        // Let's keep track of the first initialization of each stream in std::vector<bool> m_IsStreamPlanarAlphaBlendInitialized
        if (m_IsStreamPlanarAlphaBlendInitialized.size() < pBlit->NumSrcSurfaces)
        {
            m_IsStreamPlanarAlphaBlendInitialized.resize(pBlit->NumSrcSurfaces, false);
        }

        // input streams
        for (UINT streamIndex = 0; streamIndex < pBlit->NumSrcSurfaces; streamIndex++)
        {
            DXVADDI_VIDEOSAMPLE *pSource = &pBlit->pSrcSurfaces[streamIndex];
            auto *pStreamInfo = &m_inputArguments.StreamInfo[streamIndex];
            D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1 *pStreamArguments = &m_inputArguments.D3D12InputStreamArguments[streamIndex];
            D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC *pStreamDesc = &m_inputArguments.D3D12InputStreamDesc[streamIndex];

            // stream resource
            SetViewInfo(pSource->SrcResource, pSource->SrcSubResourceIndex, &pStreamInfo->ResourceSet[0].CurrentFrame);

            // stream src and dst rects
            static_assert(sizeof(D3D12_RECT) == sizeof(RECT), "Rects should match");
            if (pSource->SampleFlags.SrcRectChanged)
            {
                pStreamArguments->Transform.SourceRectangle = *reinterpret_cast<const D3D12_RECT*>(&pSource->SrcRect);
                D3D12_VIDEO_SIZE_RANGE& SourceSizeRange = pStreamDesc->SourceSizeRange;
                SourceSizeRange.MaxWidth = static_cast<UINT>(pSource->SrcRect.right - pSource->SrcRect.left);
                SourceSizeRange.MinWidth = SourceSizeRange.MaxWidth;
                SourceSizeRange.MaxHeight = static_cast<UINT>(pSource->SrcRect.bottom - pSource->SrcRect.top);
                SourceSizeRange.MinHeight = SourceSizeRange.MaxHeight;
                pStreamInfo->EnableSourceRect = TRUE;
            }
            if (pSource->SampleFlags.DstRectChanged)
            {
                pStreamArguments->Transform.DestinationRectangle = *reinterpret_cast<const D3D12_RECT*>(&pSource->DstRect);
                D3D12_VIDEO_SIZE_RANGE& DestinationSizeRange = pStreamDesc->DestinationSizeRange;
                DestinationSizeRange.MaxWidth = static_cast<UINT>(pSource->DstRect.right - pSource->DstRect.left);
                DestinationSizeRange.MinWidth = DestinationSizeRange.MaxWidth;
                DestinationSizeRange.MaxHeight = static_cast<UINT>(pSource->DstRect.bottom - pSource->DstRect.top);
                DestinationSizeRange.MinHeight = DestinationSizeRange.MaxHeight;
                pStreamInfo->EnableDestinationRect = TRUE;
            }

            // stream frame format
            pStreamArguments->FieldType = VideoTranslate::VideoFieldType(pSource->SampleFormat.SampleFormat);

            // stream alpha 
            if ((pSource->SampleFlags.PlanarAlphaChanged || !m_IsStreamPlanarAlphaBlendInitialized[streamIndex]) && m_pParentDevice->GetVideoDevice()->IsAlphaBlendProcessingSupported())
            {
                const DXVA2_Fixed32 opaqueAlpha = DXVA2_Fixed32OpaqueAlpha();
                if (pSource->PlanarAlpha.ll != opaqueAlpha.ll)
                {
                    pStreamArguments->AlphaBlending.Alpha = VideoTranslate::FromFixed32<float>(pSource->PlanarAlpha);
                    pStreamArguments->AlphaBlending.Enable = TRUE;
                    pStreamDesc->EnableAlphaBlending = TRUE;
                }
                m_IsStreamPlanarAlphaBlendInitialized[streamIndex] = true;
            }

            // input color space
            if (pSource->SampleFlags.ColorDataChanged  ||  m_colorSpaceNeverSet)
            {
                ID3D12Resource *pSourceTexture = pStreamInfo->ResourceSet[0].CurrentFrame.pResource->GetUnderlyingResource();
                const D3D12_RESOURCE_DESC &sourceDesc = pSourceTexture->GetDesc();
                pStreamDesc->ColorSpace = VideoTranslate::ColorSpaceType(sourceDesc.Format, sourceDesc.Height, pSource->SampleFormat);
                pStreamInfo->ColorSpaceSet = TRUE;
            }
            m_colorSpaceNeverSet = false;

            // DXVA doesn't have any way to enable/disable autoprocessing. We will enable it automatically in 12 if autoprocessing is supported in the 12 driver.
            pStreamDesc->EnableAutoProcessing = m_pParentDevice->GetVideoDevice()->IsAutoProcessingSupported();

            // stream filters
            // TODO: note that DX12 just has proc amp control on the input streams, and DXVA has on the destination. The
            // workaround here is to set in every input, which is not correct in many cases (it is the same when there is 1 stream covering the whole output). 
            // Should we ignore instead? Should we modify DX12?
            SetFilter(D3D12_VIDEO_PROCESS_FILTER_BRIGHTNESS, pStreamDesc, pStreamArguments, VideoTranslate::FromFixed32<INT>(pBlit->ProcAmpValues.Brightness));
            SetFilter(D3D12_VIDEO_PROCESS_FILTER_CONTRAST, pStreamDesc, pStreamArguments, VideoTranslate::FromFixed32<INT>(pBlit->ProcAmpValues.Contrast));
            SetFilter(D3D12_VIDEO_PROCESS_FILTER_HUE, pStreamDesc, pStreamArguments, VideoTranslate::FromFixed32<INT>(pBlit->ProcAmpValues.Hue));
            SetFilter(D3D12_VIDEO_PROCESS_FILTER_SATURATION, pStreamDesc, pStreamArguments, VideoTranslate::FromFixed32<INT>(pBlit->ProcAmpValues.Saturation));
        }

        m_pUnderlyingVideoProcess->ProcessFrames(&m_inputArguments, pBlit->NumSrcSurfaces, &m_outputArguments);
        m_inUseResources = decltype(m_inUseResources){};
    }

    _Use_decl_annotations_
    void VideoProcessDevice::SetBlitState(CONST D3DDDIARG_DXVAHD_SETVIDEOPROCESSBLTSTATE *pBltState)
    {
        switch (pBltState->State)
        {
        case DXVAHDDDI_BLT_STATE_TARGET_RECT:
        {
            assert(pBltState->DataSize == sizeof(DXVAHDDDI_BLT_STATE_TARGET_RECT_DATA));
            const DXVAHDDDI_BLT_STATE_TARGET_RECT_DATA *pRectData = reinterpret_cast<const DXVAHDDDI_BLT_STATE_TARGET_RECT_DATA *>(pBltState->pData);
            m_outputArguments.D3D12OutputStreamArguments.TargetRectangle = pRectData->TargetRect;
            m_outputArguments.EnableTargetRect = pRectData->Enable;
        }
        break;

        case DXVAHDDDI_BLT_STATE_BACKGROUND_COLOR:
        {
            assert(pBltState->DataSize == sizeof(DXVAHDDDI_BLT_STATE_BACKGROUND_COLOR_DATA));
            const DXVAHDDDI_BLT_STATE_BACKGROUND_COLOR_DATA *pColorData = reinterpret_cast<const DXVAHDDDI_BLT_STATE_BACKGROUND_COLOR_DATA *>(pBltState->pData);
            VideoTranslate::VideoColor(&pColorData->BackgroundColor, m_outputArguments.D3D12OutputStreamDesc.BackgroundColor);
            m_outputArguments.BackgroundColorYCbCr = pColorData->YCbCr;
            m_outputArguments.BackgroundColorSet = true;
        }
        break;

        case DXVAHDDDI_BLT_STATE_OUTPUT_COLOR_SPACE:
        {
            assert(pBltState->DataSize == sizeof(DXVAHDDDI_BLT_STATE_OUTPUT_COLOR_SPACE_DATA));
            const DXVAHDDDI_BLT_STATE_OUTPUT_COLOR_SPACE_DATA *pColorSpaceData = reinterpret_cast<const DXVAHDDDI_BLT_STATE_OUTPUT_COLOR_SPACE_DATA *>(pBltState->pData);
            m_dxvaHDColorSpaceData = *pColorSpaceData;
            m_outputArguments.ColorSpaceSet = true;
        }
        break;

        case DXVAHDDDI_BLT_STATE_ALPHA_FILL:
        {
            assert(pBltState->DataSize == sizeof(DXVAHDDDI_BLT_STATE_ALPHA_FILL_DATA));
            const DXVAHDDDI_BLT_STATE_ALPHA_FILL_DATA *pAlphaFillData = reinterpret_cast<const DXVAHDDDI_BLT_STATE_ALPHA_FILL_DATA *>(pBltState->pData);
            switch (pAlphaFillData->Mode)
            {
            case DXVAHDDDI_ALPHA_FILL_MODE_OPAQUE:
                m_outputArguments.D3D12OutputStreamDesc.AlphaFillMode = D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE_OPAQUE;
                break;
            case DXVAHDDDI_ALPHA_FILL_MODE_BACKGROUND:
                m_outputArguments.D3D12OutputStreamDesc.AlphaFillMode = D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE_BACKGROUND;
                break;
            case DXVAHDDDI_ALPHA_FILL_MODE_DESTINATION:
                m_outputArguments.D3D12OutputStreamDesc.AlphaFillMode = D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE_DESTINATION;
                break;
            case DXVAHDDDI_ALPHA_FILL_MODE_SOURCE_STREAM:
                m_outputArguments.D3D12OutputStreamDesc.AlphaFillMode = D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE_SOURCE_STREAM;
                m_outputArguments.D3D12OutputStreamDesc.AlphaFillModeSourceStreamIndex = pAlphaFillData->StreamNumber;
                break;
            default:
                ThrowFailure(E_UNEXPECTED);
                break;
            }
        }
        break;

        case DXVAHDDDI_BLT_STATE_PRIVATE:
            ThrowFailure(E_UNEXPECTED);            // no privates in DX12.
            break;

        case DXVAHDDDI_BLT_STATE_CONSTRICTION:
        {
            assert(pBltState->DataSize == sizeof(DXVAHDDDI_BLT_STATE_CONSTRICTION_DATA));
            const DXVAHDDDI_BLT_STATE_CONSTRICTION_DATA *pConstrictionData = reinterpret_cast<const DXVAHDDDI_BLT_STATE_CONSTRICTION_DATA *>(pBltState->pData);
            if (pConstrictionData->Enable  &&  (pConstrictionData->Size.cx != 0 || pConstrictionData->Size.cy != 0))
            {
                ThrowFailure(E_INVALIDARG);        // constriction not allowed in DX12
            }
        }
        break;

        default:
            ThrowFailure(E_UNEXPECTED);
            break;
        }
    }

    _Use_decl_annotations_
    void VideoProcessDevice::SetStreamState(CONST D3DDDIARG_DXVAHD_SETVIDEOPROCESSSTREAMSTATE *pStreamState)
    {
        assert(pStreamState->StreamNumber < m_MaxInputStreams);
        if (pStreamState->State == DXVAHDDDI_STREAM_STATE_PRIVATE)
        {
            ThrowFailure(E_FAIL); // no privates in DX12.  E_FAIL is required by DXVAHDVideoProcessing tests
        }

        std::vector<BYTE>& streamStateData = m_dxvaHDStreamStates[pStreamState->StreamNumber][pStreamState->State];
        streamStateData.resize(pStreamState->DataSize);
        memcpy(streamStateData.data(), pStreamState->pData, pStreamState->DataSize);
    }


    _Use_decl_annotations_
    void VideoProcessDevice::SetStreamState(UINT streamIndex, D3D12TranslationLayer::VideoProcessView *pStreamView, DXVAHDDDI_STREAM_STATE state, const std::vector<BYTE> &streamStateData)
    {
        D3D12TranslationLayer::VIDEO_PROCESS_STREAM_INFO *pStreamInfo = &m_inputArguments.StreamInfo[streamIndex];
        D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1 *pStreamArguments = &m_inputArguments.D3D12InputStreamArguments[streamIndex];
        D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC *pStreamDesc = &m_inputArguments.D3D12InputStreamDesc[streamIndex];

        switch (state)
        {
        case DXVAHDDDI_STREAM_STATE_FRAME_FORMAT:
        {
            assert(streamStateData.size() == sizeof(DXVAHDDDI_STREAM_STATE_FRAME_FORMAT_DATA));
            const DXVAHDDDI_STREAM_STATE_FRAME_FORMAT_DATA *pData = reinterpret_cast<const DXVAHDDDI_STREAM_STATE_FRAME_FORMAT_DATA *>(streamStateData.data());
            pStreamArguments->FieldType = VideoTranslate::VideoFieldType(pData->FrameFormat);
        }
        break;

        case DXVAHDDDI_STREAM_STATE_INPUT_COLOR_SPACE:
        {
            assert(streamStateData.size() == sizeof(DXVAHDDDI_STREAM_STATE_INPUT_COLOR_SPACE_DATA));
            const DXVAHDDDI_STREAM_STATE_INPUT_COLOR_SPACE_DATA *pData = reinterpret_cast<const DXVAHDDDI_STREAM_STATE_INPUT_COLOR_SPACE_DATA *>(streamStateData.data());
            const D3D12_RESOURCE_DESC &desc = pStreamView->pResource->GetUnderlyingResource()->GetDesc();
            pStreamDesc->ColorSpace = VideoTranslate::ColorSpaceType<DXVAHDDDI_STREAM_STATE_INPUT_COLOR_SPACE_DATA>(desc.Format, *pData);
            pStreamInfo->ColorSpaceSet = TRUE;
        }
        break;

        case DXVAHDDDI_STREAM_STATE_OUTPUT_RATE:
        {
            assert(streamStateData.size() == sizeof(DXVAHDDDI_STREAM_STATE_OUTPUT_RATE_DATA));
            // ignore OutputIndex/Half/Custom parameters
        }
        break;

        case DXVAHDDDI_STREAM_STATE_SOURCE_RECT:
        {
            assert(streamStateData.size() == sizeof(DXVAHDDDI_STREAM_STATE_SOURCE_RECT_DATA));
            const DXVAHDDDI_STREAM_STATE_SOURCE_RECT_DATA *pData = reinterpret_cast<const DXVAHDDDI_STREAM_STATE_SOURCE_RECT_DATA *>(streamStateData.data());
            D3D12_VIDEO_SIZE_RANGE& SourceSizeRange = pStreamDesc->SourceSizeRange;
            D3D12_RECT& SourceRectangle = pStreamArguments->Transform.SourceRectangle;
            SourceRectangle = *reinterpret_cast<const D3D12_RECT*>(&pData->SourceRect);
            SourceSizeRange.MaxWidth = static_cast<UINT>(SourceRectangle.right - SourceRectangle.left);
            SourceSizeRange.MinWidth = SourceSizeRange.MaxWidth;
            SourceSizeRange.MaxHeight = static_cast<UINT>(SourceRectangle.bottom - SourceRectangle.top);
            SourceSizeRange.MinHeight = SourceSizeRange.MaxHeight;
            pStreamInfo->EnableSourceRect = pData->Enable;
        }
        break;

        case DXVAHDDDI_STREAM_STATE_DESTINATION_RECT:
        {
            assert(streamStateData.size() == sizeof(DXVAHDDDI_STREAM_STATE_DESTINATION_RECT_DATA));
            const DXVAHDDDI_STREAM_STATE_DESTINATION_RECT_DATA *pData = reinterpret_cast<const DXVAHDDDI_STREAM_STATE_DESTINATION_RECT_DATA *>(streamStateData.data());
            D3D12_VIDEO_SIZE_RANGE& DestinationSizeRange = pStreamDesc->DestinationSizeRange;
            D3D12_RECT& DestinationRectangle = pStreamArguments->Transform.DestinationRectangle;
            DestinationRectangle = *reinterpret_cast<const D3D12_RECT*>(&pData->DestinationRect);
            DestinationSizeRange.MaxWidth = static_cast<UINT>(DestinationRectangle.right - DestinationRectangle.left);
            DestinationSizeRange.MinWidth = DestinationSizeRange.MaxWidth;
            DestinationSizeRange.MaxHeight = static_cast<UINT>(DestinationRectangle.bottom - DestinationRectangle.top);
            DestinationSizeRange.MinHeight = DestinationSizeRange.MaxHeight;
            pStreamInfo->EnableDestinationRect = pData->Enable;
        }
        break;

        case DXVAHDDDI_STREAM_STATE_ALPHA:
        {
            assert(streamStateData.size() == sizeof(DXVAHDDDI_STREAM_STATE_ALPHA_DATA));
            const DXVAHDDDI_STREAM_STATE_ALPHA_DATA *pData = reinterpret_cast<const DXVAHDDDI_STREAM_STATE_ALPHA_DATA *>(streamStateData.data());
            pStreamArguments->AlphaBlending.Alpha = pData->Alpha;
            pStreamArguments->AlphaBlending.Enable = pData->Enable;
            pStreamDesc->EnableAlphaBlending = pData->Enable;
        }
        break;

        case DXVAHDDDI_STREAM_STATE_LUMA_KEY:
        {
            assert(streamStateData.size() == sizeof(DXVAHDDDI_STREAM_STATE_LUMA_KEY_DATA));
            const DXVAHDDDI_STREAM_STATE_LUMA_KEY_DATA *pData = reinterpret_cast<const DXVAHDDDI_STREAM_STATE_LUMA_KEY_DATA *>(streamStateData.data());
            pStreamDesc->LumaKey.Lower = pData->Lower;
            pStreamDesc->LumaKey.Upper = pData->Upper;
            pStreamDesc->LumaKey.Enable = pData->Enable;
        }
        break;

        case DXVAHDDDI_STREAM_STATE_ASPECT_RATIO:
        {
            assert(streamStateData.size() == sizeof(DXVAHDDDI_STREAM_STATE_ASPECT_RATIO_DATA));
            const DXVAHDDDI_STREAM_STATE_ASPECT_RATIO_DATA *pData = reinterpret_cast<const DXVAHDDDI_STREAM_STATE_ASPECT_RATIO_DATA *>(streamStateData.data());
            if (pData->Enable)
            {
                pStreamDesc->SourceAspectRatio.Numerator = pData->SourceAspectRatio.Numerator;
                pStreamDesc->SourceAspectRatio.Denominator = pData->SourceAspectRatio.Denominator;
                pStreamDesc->DestinationAspectRatio.Numerator = pData->DestinationAspectRatio.Numerator;
                pStreamDesc->DestinationAspectRatio.Denominator = pData->DestinationAspectRatio.Denominator;
            }
            else
            {
                pStreamDesc->SourceAspectRatio.Numerator = 1;
                pStreamDesc->SourceAspectRatio.Denominator = 1;
                pStreamDesc->DestinationAspectRatio.Numerator = 1;
                pStreamDesc->DestinationAspectRatio.Denominator = 1;
            }
        }
        break;

        case DXVAHDDDI_STREAM_STATE_FILTER_BRIGHTNESS:
        case DXVAHDDDI_STREAM_STATE_FILTER_CONTRAST:
        case DXVAHDDDI_STREAM_STATE_FILTER_HUE:
        case DXVAHDDDI_STREAM_STATE_FILTER_SATURATION:
        case DXVAHDDDI_STREAM_STATE_FILTER_NOISE_REDUCTION:
        case DXVAHDDDI_STREAM_STATE_FILTER_EDGE_ENHANCEMENT:
        case DXVAHDDDI_STREAM_STATE_FILTER_ANAMORPHIC_SCALING:
        {
            assert(streamStateData.size() == sizeof(DXVAHDDDI_STREAM_STATE_FILTER_DATA));
            const DXVAHDDDI_STREAM_STATE_FILTER_DATA *pData = reinterpret_cast<const DXVAHDDDI_STREAM_STATE_FILTER_DATA *>(streamStateData.data());

            D3D12_VIDEO_PROCESS_FILTER_FLAGS Filter12Flag = VideoTranslate::VideoProcessFilterFlag(state);
            if (pData->Enable)
            {
                D3D12_VIDEO_PROCESS_FILTER Filter12 = VideoTranslate::VideoProcessFilter(state);
                pStreamDesc->FilterFlags |= Filter12Flag;
                pStreamArguments->FilterLevels[Filter12] = pData->Level;
            }
            else
            {
                pStreamDesc->FilterFlags &= ~Filter12Flag;
            }
        }
        break;

        case DXVAHDDDI_STREAM_STATE_PALETTE:
            // ignore
            break;

        default:
            ThrowFailure(E_UNEXPECTED);
            break;
        }
    }

    _Use_decl_annotations_
    void VideoProcessDevice::FillReferenceSet(D3D12TranslationLayer::VIDEO_PROCESS_STREAM_INFO *pStreamInfo, UINT view, const DXVAHDDDI_SURFACE &InputSurface, UINT numPastFrames, const DXVAHDDDI_SURFACE *pPastSurfaces, UINT numFutureFrames, const DXVAHDDDI_SURFACE* pFutureSurfaces)
    {
        SetViewInfo(InputSurface.hResource, InputSurface.SubResourceIndex, &pStreamInfo->ResourceSet[view].CurrentFrame);
        if (numPastFrames)
        {
            pStreamInfo->ResourceSet[view].PastFrames.resize(numPastFrames);
            for (DWORD i = 0; i < numPastFrames; i++)
            {
                SetViewInfo(pPastSurfaces[i].hResource, pPastSurfaces[i].SubResourceIndex, &pStreamInfo->ResourceSet[view].PastFrames[i]);
            }
        }

        if (numFutureFrames)
        {
            pStreamInfo->ResourceSet[view].FutureFrames.resize(numFutureFrames);
            for (DWORD i = 0; i < numFutureFrames; i++)
            {
                SetViewInfo(pFutureSurfaces[i].hResource, pFutureSurfaces[i].SubResourceIndex, &pStreamInfo->ResourceSet[view].FutureFrames[i]);
            }
        }
    }

    _Use_decl_annotations_
    void VideoProcessDevice::BlitHD(CONST D3DDDIARG_DXVAHD_VIDEOPROCESSBLTHD *pBlit)
    {
        SetViewInfo(pBlit->OutputSurface.hResource, pBlit->OutputSurface.SubResourceIndex, &m_outputArguments.CurrentFrame[0]);

        if (m_outputArguments.ColorSpaceSet)
        {
            ID3D12Resource *pTexture = m_outputArguments.CurrentFrame[0].pResource->GetUnderlyingResource();
            const D3D12_RESOURCE_DESC &desc = pTexture->GetDesc();
            m_outputArguments.D3D12OutputStreamDesc.ColorSpace = VideoTranslate::ColorSpaceType<DXVAHDDDI_BLT_STATE_OUTPUT_COLOR_SPACE_DATA>(desc.Format, m_dxvaHDColorSpaceData);
        }

        UINT curStream = 0;
        for (UINT streamIndex = 0; streamIndex < pBlit->StreamCount; streamIndex++)
        {
            CONST DXVAHDDDI_STREAM_DATA *pStreamData = &pBlit->pStreams[streamIndex];
            D3D12TranslationLayer::VIDEO_PROCESS_STREAM_INFO *pStreamInfo = &m_inputArguments.StreamInfo[curStream];
            D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC *pStreamDesc = &m_inputArguments.D3D12InputStreamDesc[streamIndex];

            // stream resource
            if (pStreamData->Enable)
            {
                FillReferenceSet(pStreamInfo, 0, pStreamData->InputSurface, pStreamData->PastFrames, pStreamData->pPastSurfaces, pStreamData->FutureFrames, pStreamData->pFutureSurfaces);

                for (const auto &iter : m_dxvaHDStreamStates[streamIndex])
                {
                    SetStreamState(curStream, &pStreamInfo->ResourceSet[0].CurrentFrame, iter.first, iter.second);
                }
                pStreamInfo->OutputIndex = pStreamData->OutputIndex;
                pStreamInfo->InputFrameOrField = pStreamData->InputFrameOrField;
                ++curStream;
            }

            // DXVA-HD doesn't have any way to enable/disable autoprocessing. We will enable it automatically in 12 if autoprocessing is supported in the 12 driver.
            pStreamDesc->EnableAutoProcessing = m_pParentDevice->GetVideoDevice()->IsAutoProcessingSupported();
        }

        if (curStream == 0)
        {
            ThrowFailure(E_INVALIDARG);
        }

        m_pUnderlyingVideoProcess->ProcessFrames(&m_inputArguments, curStream, &m_outputArguments);
    }
};

```

`src/CMakeLists.txt`:

```txt
# Copyright (c) Microsoft Corporation.
# Licensed under the MIT license.
cmake_minimum_required(VERSION 3.14)
include(FetchContent)

file(GLOB SRC CONFIGURE_DEPENDS *.cpp)
file(GLOB INC ../include/*.h ../include/*.hpp ../interface/*.h *.h *.hpp)
file(GLOB INL ../include/*.inl *.inl)

file(GLOB_RECURSE EXTERNAL_INC ../external/*.h ../external/*.hpp)

add_library(d3d9on12 SHARED ${SRC} ${INC} ${INL} ${EXTERNAL_INC} d3d9on12.rc d3d9on12.def)

if (CMAKE_VERSION VERSION_GREATER 3.16)
	target_precompile_headers(d3d9on12 PRIVATE ../include/pch.h)
endif()

FetchContent_Declare(
    d3d12translationlayer
    GIT_REPOSITORY https://github.com/microsoft/D3D12TranslationLayer.git
    GIT_TAG        master
)
FetchContent_MakeAvailable(d3d12translationlayer)

target_link_libraries(d3d9on12 d3d12translationlayer_wdk)
target_link_libraries(d3d9on12 d3d9on12_shaderconv)

if(TARGET dxbcsigner_static)
    target_link_libraries(d3d9on12 dxbcsigner_static)
else()
    message(STATUS "Adding DxbcSigner NuGet package...")
    configure_file(${CMAKE_CURRENT_SOURCE_DIR}/../packages.config ${CMAKE_CURRENT_BINARY_DIR}/packages.config COPYONLY)
    add_library(dxbcsigner INTERFACE IMPORTED GLOBAL)
    set_target_properties(dxbcsigner PROPERTIES INTERFACE_LINK_LIBRARIES "${CMAKE_BINARY_DIR}/packages/Microsoft.Direct3D.DxbcSigner.1.0.0/build/native/Microsoft.Direct3D.DxbcSigner.targets")
    set_target_properties(d3d9on12 PROPERTIES LINK_FLAGS "/DELAYLOAD:dxbcSigner.dll")
    target_link_libraries(d3d9on12 dxbcsigner)
endif()
target_include_directories(d3d9on12
    PRIVATE ../external
    PRIVATE ../include
    PUBLIC ../interface
    PRIVATE ./)

source_group(Inlines FILES ${INL})
source_group("Header Files\\External" FILES ${EXTERNAL_INC})

```

`src/d3d9on12.def`:

```def
EXPORTS
    OpenAdapter
    GetPrivateDDITable
    GetPrivateDDITableVersioned
    SetAppCompatData
```

`src/d3d9on12.rc`:

```rc
//
//    Copyright (C) Microsoft.  All rights reserved.
//
#include <windows.h>

#ifndef DBG
#define DX_RUNTIME_VERSION 1
#endif

#define DX_VER_FILETYPE VFT_DLL
#define DX_VER_FILESUBTYPE VFT2_UNKNOWN
#define DX_VER_FILEDESCRIPTIONSTR "Direct3D9 DDI to Direct3D12 API Mapping Layer"

#ifdef DBG
#define DX_VER_FILEDESCRIPTION_STR DX_VER_FILEDESCRIPTIONSTR " Debug"
#else
#define DX_VER_FILEDESCRIPTION_STR DX_VER_FILEDESCRIPTIONSTR
#endif

#define DX_VER_INTERNALNAME_STR "D3D9on12.dll"
#define DX_VER_ORIGINALFILENAME_STR DX_VER_INTERNALNAME_STR

#include <ntverp.h>

#define VER_FILETYPE                 DX_VER_FILETYPE
#define VER_FILESUBTYPE              DX_VER_FILESUBTYPE
#define VER_FILEDESCRIPTION_STR      DX_VER_FILEDESCRIPTION_STR
#define VER_INTERNALNAME_STR         DX_VER_INTERNALNAME_STR
#define VER_ORIGINALFILENAME_STR     DX_VER_ORIGINALFILENAME_STR

#include <common.ver>
```