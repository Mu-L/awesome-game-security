Project Path: arc_Barracudach_Swap-control-ioctl_vug_cc5r

Source Tree:

```txt
arc_Barracudach_Swap-control-ioctl_vug_cc5r
├── README.md
├── SwapControl
│   ├── DriverEntry.cpp
│   ├── SwapControl.inf
│   ├── SwapControl.user
│   ├── SwapControl.vcxproj
│   ├── SwapControl.vcxproj.filters
│   ├── SwapControl.vcxproj.user
│   ├── common.h
│   ├── ioctl.h
│   ├── ntapi.h
│   ├── ntstructs.h
│   ├── tools.cpp
│   └── tools.h
└── SwapControl.sln

```

`README.md`:

```md
# Swap-control-ioctl
Хук функции DRIVER_DISPATCH(IRP_MJ_DEVICE_CONTROL) отвечающую за ввод-вывод ioctl устройства на примере драйвера SpeedFan.

Суть такова, что мы в сам указатель PDRIVER_DISPATCH пишем адресс trampoline который находится в диапазоне
секции .text ,тем самым я подразумевал что мы можем пройти слепую проверку античита :

if (major_function.address < section.address || 
        major_function.address >= section.address + section_size)
    {
      /*FOUND*/
    }

Но как оказалось, существуют более безопасные методы перехвата DRIVER_DISPATCH, позволяющие не модифицировать страницу .text

```

`SwapControl.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30717.126
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SwapControl", "SwapControl\SwapControl.vcxproj", "{4147CC31-F414-4D1A-A835-0938DEB2DC4F}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{4147CC31-F414-4D1A-A835-0938DEB2DC4F}.Debug|ARM.ActiveCfg = Debug|ARM
		{4147CC31-F414-4D1A-A835-0938DEB2DC4F}.Debug|ARM.Build.0 = Debug|ARM
		{4147CC31-F414-4D1A-A835-0938DEB2DC4F}.Debug|ARM.Deploy.0 = Debug|ARM
		{4147CC31-F414-4D1A-A835-0938DEB2DC4F}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{4147CC31-F414-4D1A-A835-0938DEB2DC4F}.Debug|ARM64.Build.0 = Debug|ARM64
		{4147CC31-F414-4D1A-A835-0938DEB2DC4F}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{4147CC31-F414-4D1A-A835-0938DEB2DC4F}.Debug|x64.ActiveCfg = Debug|x64
		{4147CC31-F414-4D1A-A835-0938DEB2DC4F}.Debug|x64.Build.0 = Debug|x64
		{4147CC31-F414-4D1A-A835-0938DEB2DC4F}.Debug|x64.Deploy.0 = Debug|x64
		{4147CC31-F414-4D1A-A835-0938DEB2DC4F}.Debug|x86.ActiveCfg = Debug|Win32
		{4147CC31-F414-4D1A-A835-0938DEB2DC4F}.Debug|x86.Build.0 = Debug|Win32
		{4147CC31-F414-4D1A-A835-0938DEB2DC4F}.Debug|x86.Deploy.0 = Debug|Win32
		{4147CC31-F414-4D1A-A835-0938DEB2DC4F}.Release|ARM.ActiveCfg = Release|ARM
		{4147CC31-F414-4D1A-A835-0938DEB2DC4F}.Release|ARM.Build.0 = Release|ARM
		{4147CC31-F414-4D1A-A835-0938DEB2DC4F}.Release|ARM.Deploy.0 = Release|ARM
		{4147CC31-F414-4D1A-A835-0938DEB2DC4F}.Release|ARM64.ActiveCfg = Release|ARM64
		{4147CC31-F414-4D1A-A835-0938DEB2DC4F}.Release|ARM64.Build.0 = Release|ARM64
		{4147CC31-F414-4D1A-A835-0938DEB2DC4F}.Release|ARM64.Deploy.0 = Release|ARM64
		{4147CC31-F414-4D1A-A835-0938DEB2DC4F}.Release|x64.ActiveCfg = Release|x64
		{4147CC31-F414-4D1A-A835-0938DEB2DC4F}.Release|x64.Build.0 = Release|x64
		{4147CC31-F414-4D1A-A835-0938DEB2DC4F}.Release|x64.Deploy.0 = Release|x64
		{4147CC31-F414-4D1A-A835-0938DEB2DC4F}.Release|x86.ActiveCfg = Release|Win32
		{4147CC31-F414-4D1A-A835-0938DEB2DC4F}.Release|x86.Build.0 = Release|Win32
		{4147CC31-F414-4D1A-A835-0938DEB2DC4F}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {75C61688-6A50-4B80-BD21-16DBD809B375}
	EndGlobalSection
EndGlobal

```

`SwapControl/DriverEntry.cpp`:

```cpp
#include "ntapi.h"
#include "ioctl.h"
#include <stdarg.h>
#include "Wdf.h"
#include "common.h"
#include <time.h>

#include "tools.h"
NTSTATUS Sleep(LONGLONG ms_duration);


#define complete_request(irp,type,status)\
irp->IoStatus.Status = status;\
irp->IoStatus.Information = sizeof(type);\
IoCompleteRequest(irp, IO_NO_INCREMENT);\
return status;

PDRIVER_DISPATCH SpeedFanControlOriginal = 0;
NTSTATUS SpeedFanControl(PDEVICE_OBJECT device, PIRP irp)
{
	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(irp);

	switch (stack->Parameters.DeviceIoControl.IoControlCode) {

	case ioctl_copy_memory: {
		DBG("ioctl_copy_memory\n");
		pk_rw_request in = (pk_rw_request)irp->AssociatedIrp.SystemBuffer;
		PEPROCESS src_proc;
		PEPROCESS dst_proc;
		NTSTATUS status;
		status = PsLookupProcessByProcessId((HANDLE)in->src_pid, &src_proc);
		status |= PsLookupProcessByProcessId((HANDLE)in->dst_pid, &dst_proc);
		if (NT_SUCCESS(status)) {
			status = copy_memory(src_proc, dst_proc, (PVOID)in->src_addr, (PVOID)in->dst_addr, in->size);
			ObfDereferenceObject(dst_proc);
			ObfDereferenceObject(src_proc);
			//	if (!NT_SUCCESS(status))DbgPrint("[DRIVER] copy_memory error");
		}
		complete_request(irp,k_rw_request, status);
	} break;

	case ioctl_allocate_virtual_memory: {
		DBG("ioctl_allocate_virtual_memory\n");
		//	DbgPrint("[DRIVER] ioctl_allocate_virtual_memory");
		pk_alloc_mem_request in = (pk_alloc_mem_request)irp->AssociatedIrp.SystemBuffer;
		PEPROCESS target_proc;
		NTSTATUS status;
		status = PsLookupProcessByProcessId((HANDLE)in->pid, &target_proc);
		if (NT_SUCCESS(status)) {
			KAPC_STATE apc;
			KeStackAttachProcess(target_proc, &apc);
			status = ZwAllocateVirtualMemory(ZwCurrentProcess(), (PVOID*)&in->addr, 0, &in->size,
				in->allocation_type, in->protect);
			KeUnstackDetachProcess(&apc);
			ObfDereferenceObject(target_proc);
		}
		complete_request(irp, k_alloc_mem_request, status);
	} break;

	case ioctl_protect_virutal_memory: {
		DBG("ioctl_protect_virutal_memory\n");
		pk_protect_mem_request in = (pk_protect_mem_request)irp->AssociatedIrp.SystemBuffer;
		PEPROCESS target_proc;
		NTSTATUS status;
		status = PsLookupProcessByProcessId((HANDLE)in->pid, &target_proc);
		if (NT_SUCCESS(status)) {
			KAPC_STATE apc;
			ULONG old_protection;
			KeStackAttachProcess(target_proc, &apc);
			status = ZwProtectVirtualMemory(ZwCurrentProcess(), (PVOID*)&in->addr, &in->size, in->protect, &old_protection);
			KeUnstackDetachProcess(&apc);
			in->protect = old_protection;
			ObfDereferenceObject(target_proc);
		}
		complete_request(irp, k_protect_mem_request, status);
	} break;
	case ioctl_get_module_base: {
		DBG("ioctl_get_module_base\n");
		pk_get_base_module_request in = (pk_get_base_module_request)irp->AssociatedIrp.SystemBuffer;
		ULONGLONG handle = get_module_handle(in->pid, in->name);
		in->handle = handle;
		complete_request(irp, k_get_base_module_request, STATUS_SUCCESS);
	} break;

	case ioctl_repair: {
		SwapControl_f(RTL_CONSTANT_STRING(L"\\Driver\\SpeedFan"), (PVOID)SpeedFanControlOriginal, (PVOID*)&SpeedFanControlOriginal, FALSE);
	} break;
	}


	return SpeedFanControlOriginal(device, irp);
}


NTSTATUS DriverEntry(PDRIVER_OBJECT driver_object, PUNICODE_STRING registry_path)
{

	UNREFERENCED_PARAMETER(driver_object);
	UNREFERENCED_PARAMETER(registry_path);

	SwapControl_f(RTL_CONSTANT_STRING(L"\\Driver\\SpeedFan"), (PVOID)SpeedFanControl, (PVOID*)&SpeedFanControlOriginal, TRUE);

	return STATUS_SUCCESS;
}



NTSTATUS Sleep(LONGLONG ms_duration)
{
	LARGE_INTEGER delay;
	delay.QuadPart = -1 * (10000 * ms_duration);
	return KeDelayExecutionThread(KernelMode, FALSE, &delay);
}
```

`SwapControl/SwapControl.inf`:

```inf
;
; Driver_cheat.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=Driver_cheat.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages
PnpLockDown=1

[DestinationDirs]
DefaultDestDir = 12
Driver_cheat_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
Driver_cheat.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%Driver_cheat.DeviceDesc%=Driver_cheat_Device, Root\Driver_cheat ; TODO: edit hw-id

[Driver_cheat_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
Driver_cheat.sys

;-------------- Service installation
[Driver_cheat_Device.NT.Services]
AddService = Driver_cheat,%SPSVCINST_ASSOCSERVICE%, Driver_cheat_Service_Inst

; -------------- Driver_cheat driver install sections
[Driver_cheat_Service_Inst]
DisplayName    = %Driver_cheat.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\Driver_cheat.sys

;
;--- Driver_cheat_Device Coinstaller installation ------
;

[Driver_cheat_Device.NT.CoInstallers]
AddReg=Driver_cheat_Device_CoInstaller_AddReg
CopyFiles=Driver_cheat_Device_CoInstaller_CopyFiles

[Driver_cheat_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[Driver_cheat_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[Driver_cheat_Device.NT.Wdf]
KmdfService =  Driver_cheat, Driver_cheat_wdfsect
[Driver_cheat_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "Driver_cheat Installation Disk"
Driver_cheat.DeviceDesc = "Driver_cheat Device"
Driver_cheat.SVCDESC = "Driver_cheat Service"

```

`SwapControl/SwapControl.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
</Project>
```

`SwapControl/SwapControl.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{4147CC31-F414-4D1A-A835-0938DEB2DC4F}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>SwapControl</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
    <ProjectName>SwapControl</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <TreatLinkerWarningAsErrors>false</TreatLinkerWarningAsErrors>
    </Link>
    <ClCompile>
      <DebugInformationFormat>None</DebugInformationFormat>
    </ClCompile>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <LanguageStandard_C>stdc11</LanguageStandard_C>
      <LanguageStandard>Default</LanguageStandard>
      <EnableModules>false</EnableModules>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="SwapControl.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DriverEntry.cpp" />
    <ClCompile Include="tools.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="common.h" />
    <ClInclude Include="ioctl.h" />
    <ClInclude Include="ntapi.h" />
    <ClInclude Include="ntstructs.h" />
    <ClInclude Include="skCrypter.h" />
    <ClInclude Include="tools.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`SwapControl/SwapControl.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
    <Filter Include="Source">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Source\NT">
      <UniqueIdentifier>{cf2adb7a-699a-42f7-a984-aa2bc011e399}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source\tools">
      <UniqueIdentifier>{12f797fd-b200-418a-a66f-4ca4685cf06f}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="SwapControl.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DriverEntry.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="tools.cpp">
      <Filter>Source\tools</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ntstructs.h">
      <Filter>Source\NT</Filter>
    </ClInclude>
    <ClInclude Include="ntapi.h">
      <Filter>Source\NT</Filter>
    </ClInclude>
    <ClInclude Include="common.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="skCrypter.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="ioctl.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="tools.h">
      <Filter>Source\tools</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`SwapControl/SwapControl.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
</Project>
```

`SwapControl/common.h`:

```h
#pragma once

//#define _DBG_

template <typename... Args>
void DBG(const char* format, Args... args)
{
#ifdef _DBG_
	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, format, args...);
#endif 
}

```

`SwapControl/ioctl.h`:

```h
#pragma once

#include "ntstructs.h"
#include "ntapi.h"


#define ioctl_copy_memory CTL_CODE(FILE_DEVICE_UNKNOWN, 0x1001, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define ioctl_allocate_virtual_memory CTL_CODE(FILE_DEVICE_UNKNOWN, 0x1002, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define ioctl_get_module_base CTL_CODE(FILE_DEVICE_UNKNOWN, 0x1003, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define ioctl_protect_virutal_memory CTL_CODE(FILE_DEVICE_UNKNOWN, 0x1004, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define ioctl_repair CTL_CODE(FILE_DEVICE_UNKNOWN, 0x1005, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)



typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;

typedef struct _k_get_base_module_request {
	ULONG pid;
	ULONGLONG handle;
	WCHAR name[260];
} k_get_base_module_request, * pk_get_base_module_request;

typedef struct _k_alloc_mem_request {
	ULONG pid, allocation_type, protect;
	ULONGLONG addr;
	SIZE_T size;
} k_alloc_mem_request, * pk_alloc_mem_request;


typedef struct _k_rw_request {
	uint32_t src_pid;
	uint32_t dst_pid;
	uint64_t src_addr;
	uint64_t dst_addr;
	uint32_t size;
} k_rw_request, * pk_rw_request;

typedef struct _k_protect_mem_request {
	ULONG pid, protect;
	ULONGLONG addr;
	SIZE_T size;
} k_protect_mem_request, * pk_protect_mem_request;
```

`SwapControl/ntapi.h`:

```h
#pragma once

#include "ntstructs.h"

extern "C"
NTKERNELAPI
NTSTATUS 
ObReferenceObjectByName(IN PUNICODE_STRING ObjectName,
	IN ULONG Attributes,
	IN PACCESS_STATE PassedAccessState, 
	IN ACCESS_MASK DesiredAccess, 
	IN POBJECT_TYPE ObjectType, 
	IN KPROCESSOR_MODE AccessMode,
	IN OUT PVOID ParseContext,
	OUT PVOID* Object);

extern "C"
NTKERNELAPI
PVOID
NTAPI
RtlFindExportedRoutineByName(
	PVOID ImageBase,
	PCCH RoutineName
);

extern "C"
NTKERNELAPI
NTSTATUS
ZwQuerySystemInformation(
	ULONG InfoClass,
	PVOID Buffer,
	ULONG Length,
	PULONG ReturnLength
);

extern "C"
NTKERNELAPI
PVOID
NTAPI
PsGetProcessWow64Process(_In_ PEPROCESS Process);

extern "C"
NTKERNELAPI
NTSTATUS
NTAPI
MmCopyVirtualMemory(
	_In_ PEPROCESS FromProcess,
	_In_ PVOID FromAddress,
	_In_ PEPROCESS ToProcess,
	_Out_ PVOID ToAddress,
	_In_ SIZE_T BufferSize,
	_In_ KPROCESSOR_MODE PreviousMode,
	_Out_ PSIZE_T NumberOfBytesCopied
);

extern "C"
NTKERNELAPI
PPEB
PsGetProcessPeb(
	IN PEPROCESS Process
);


extern "C"
NTSYSAPI
NTSTATUS
NTAPI
ZwProtectVirtualMemory(
	__in HANDLE ProcessHandle,
	__inout PVOID* BaseAddress,
	__inout PSIZE_T RegionSize,
	__in ULONG NewProtect,
	__out PULONG OldProtect
);


EXTERN_C NTSYSAPI
PIMAGE_NT_HEADERS
NTAPI
RtlImageNtHeader(IN PVOID   ModuleAddress);

NTKERNELAPI
PVOID
PsGetProcessSectionBaseAddress(
	__in PEPROCESS Process
);
```

`SwapControl/ntstructs.h`:

```h
#pragma once

#include <ntifs.h>
#include <windef.h>
#include <ntddk.h>
#include <windef.h>

//#include <winternl.h>
#include <ntimage.h>
#include <ntstrsafe.h>

typedef struct _SYSTEM_PROCESS_INFORMATION {
	ULONG NextEntryOffset;
	ULONG NumberOfThreads;
	BYTE Reserved1[48];
	UNICODE_STRING ImageName;
	KPRIORITY BasePriority;
	HANDLE UniqueProcessId;
	PVOID Reserved2;
	ULONG HandleCount;
	ULONG SessionId;
	PVOID Reserved3;
	SIZE_T PeakVirtualSize;
	SIZE_T VirtualSize;
	ULONG Reserved4;
	SIZE_T PeakWorkingSetSize;
	SIZE_T WorkingSetSize;
	PVOID Reserved5;
	SIZE_T QuotaPagedPoolUsage;
	PVOID Reserved6;
	SIZE_T QuotaNonPagedPoolUsage;
	SIZE_T PagefileUsage;
	SIZE_T PeakPagefileUsage;
	SIZE_T PrivatePageCount;
	LARGE_INTEGER Reserved7[6];
} SYSTEM_PROCESS_INFORMATION, * PSYSTEM_PROCESS_INFORMATION;

typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation,
	SystemProcessorInformation,
	SystemPerformanceInformation,
	SystemTimeOfDayInformation,
	SystemPathInformation,
	SystemProcessInformation,
	SystemCallCountInformation,
	SystemDeviceInformation,
	SystemProcessorPerformanceInformation,
	SystemFlagsInformation,
	SystemCallTimeInformation,
	SystemModuleInformation,
} SYSTEM_INFORMATION_CLASS, * PSYSTEM_INFORMATION_CLASS;

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

typedef struct _PEB_LDR_DATA32
{
	ULONG Length;
	UCHAR Initialized;
	ULONG SsHandle;
	LIST_ENTRY32 InLoadOrderModuleList;
	LIST_ENTRY32 InMemoryOrderModuleList;
	LIST_ENTRY32 InInitializationOrderModuleList;
} PEB_LDR_DATA32, * PPEB_LDR_DATA32;

typedef struct _LDR_DATA_TABLE_ENTRY32
{
	LIST_ENTRY32 InLoadOrderLinks;
	LIST_ENTRY32 InMemoryOrderLinks;
	LIST_ENTRY32 InInitializationOrderLinks;
	ULONG DllBase;
	ULONG EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING32 FullDllName;
	UNICODE_STRING32 BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	LIST_ENTRY32 HashLinks;
	ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY32, * PLDR_DATA_TABLE_ENTRY32;


typedef struct _PEB_LDR_DATA
{
	ULONG Length;
	UCHAR Initialized;
	PVOID SsHandle;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
	PVOID EntryInProgress;
} PEB_LDR_DATA, * PPEB_LDR_DATA;

typedef struct _RTL_CRITICAL_SECTION
{
	VOID* DebugInfo;
	LONG LockCount;
	LONG RecursionCount;
	PVOID OwningThread;
	PVOID LockSemaphore;
	ULONG SpinCount;
} RTL_CRITICAL_SECTION, * PRTL_CRITICAL_SECTION;

typedef struct _PEB
{
	UCHAR InheritedAddressSpace;
	UCHAR ReadImageFileExecOptions;
	UCHAR BeingDebugged;
	UCHAR BitField;
	ULONG ImageUsesLargePages : 1;
	ULONG IsProtectedProcess : 1;
	ULONG IsLegacyProcess : 1;
	ULONG IsImageDynamicallyRelocated : 1;
	ULONG SpareBits : 4;
	PVOID Mutant;
	PVOID ImageBaseAddress;
	PPEB_LDR_DATA Ldr;
	VOID* ProcessParameters;
	PVOID SubSystemData;
	PVOID ProcessHeap;
	PRTL_CRITICAL_SECTION FastPebLock;
	PVOID AtlThunkSListPtr;
	PVOID IFEOKey;
	ULONG CrossProcessFlags;
	ULONG ProcessInJob : 1;
	ULONG ProcessInitializing : 1;
	ULONG ReservedBits0 : 30;
	union
	{
		PVOID KernelCallbackTable;
		PVOID UserSharedInfoPtr;
	};
	ULONG SystemReserved[1];
	ULONG SpareUlong;
	VOID* FreeList;
	ULONG TlsExpansionCounter;
	PVOID TlsBitmap;
	ULONG TlsBitmapBits[2];
	PVOID ReadOnlySharedMemoryBase;
	PVOID HotpatchInformation;
	VOID** ReadOnlyStaticServerData;
	PVOID AnsiCodePageData;
	PVOID OemCodePageData;
	PVOID UnicodeCaseTableData;
	ULONG NumberOfProcessors;
	ULONG NtGlobalFlag;
	LARGE_INTEGER CriticalSectionTimeout;
	ULONG HeapSegmentReserve;
	ULONG HeapSegmentCommit;
	ULONG HeapDeCommitTotalFreeThreshold;
	ULONG HeapDeCommitFreeBlockThreshold;
	ULONG NumberOfHeaps;
	ULONG MaximumNumberOfHeaps;
	VOID** ProcessHeaps;
	PVOID GdiSharedHandleTable;
	PVOID ProcessStarterHelper;
	ULONG GdiDCAttributeList;
	PRTL_CRITICAL_SECTION LoaderLock;
	ULONG OSMajorVersion;
	ULONG OSMinorVersion;
	WORD OSBuildNumber;
	WORD OSCSDVersion;
	ULONG OSPlatformId;
	ULONG ImageSubsystem;
	ULONG ImageSubsystemMajorVersion;
	ULONG ImageSubsystemMinorVersion;
	ULONG ImageProcessAffinityMask;
	ULONG GdiHandleBuffer[34];
	PVOID PostProcessInitRoutine;
	PVOID TlsExpansionBitmap;
	ULONG TlsExpansionBitmapBits[32];
	ULONG SessionId;
	ULARGE_INTEGER AppCompatFlags;
	ULARGE_INTEGER AppCompatFlagsUser;
	PVOID pShimData;
	PVOID AppCompatInfo;
	UNICODE_STRING CSDVersion;
	VOID* ActivationContextData;
	VOID* ProcessAssemblyStorageMap;
	VOID* SystemDefaultActivationContextData;
	VOID* SystemAssemblyStorageMap;
	ULONG MinimumStackCommit;
	VOID* FlsCallback;
	LIST_ENTRY FlsListHead;
	PVOID FlsBitmap;
	ULONG FlsBitmapBits[4];
	ULONG FlsHighIndex;
	PVOID WerRegistrationData;
	PVOID WerShipAssertPtr;
} PEB, * PPEB;

typedef struct _PEB32
{
	UCHAR InheritedAddressSpace;
	UCHAR ReadImageFileExecOptions;
	UCHAR BeingDebugged;
	UCHAR BitField;
	ULONG Mutant;
	ULONG ImageBaseAddress;
	ULONG Ldr;
	ULONG ProcessParameters;
	ULONG SubSystemData;
	ULONG ProcessHeap;
	ULONG FastPebLock;
	ULONG AtlThunkSListPtr;
	ULONG IFEOKey;
	ULONG CrossProcessFlags;
	ULONG UserSharedInfoPtr;
	ULONG SystemReserved;
	ULONG AtlThunkSListPtr32;
	ULONG ApiSetMap;
} PEB32, * PPEB32;

typedef struct _LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	WORD LoadCount;
	WORD TlsIndex;
	union
	{
		LIST_ENTRY HashLinks;
		struct
		{
			PVOID SectionPointer;
			ULONG CheckSum;
		};
	};
	union
	{
		ULONG TimeDateStamp;
		PVOID LoadedImports;
	};
	VOID* EntryPointActivationContext;
	PVOID PatchInformation;
	LIST_ENTRY ForwarderLinks;
	LIST_ENTRY ServiceTagLinks;
	LIST_ENTRY StaticLinks;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;


struct PiDDBCacheEntry
{
	LIST_ENTRY		List;
	UNICODE_STRING	DriverName;
	ULONG			TimeDateStamp;
	NTSTATUS		LoadStatus;
	char			_0x0028[16]; // data from the shim engine, or uninitialized memory for custom drivers
};

#define MM_UNLOADED_DRIVERS_SIZE 50
typedef struct _MM_UNLOADED_DRIVER
{
	UNICODE_STRING 	Name;
	PVOID 			ModuleStart;
	PVOID 			ModuleEnd;
	ULONG64 		UnloadTime;
} MM_UNLOADED_DRIVER, * PMM_UNLOADED_DRIVER;
```

`SwapControl/tools.cpp`:

```cpp
#pragma once

#include "tools.h"

ULONGLONG get_module_handle(ULONG pid, LPCWSTR module_name) {
	PEPROCESS target_proc;
	ULONGLONG base = 0;
	if (!NT_SUCCESS(PsLookupProcessByProcessId((HANDLE)pid, &target_proc)))
		return 0;

	KeAttachProcess((PKPROCESS)target_proc);

	PPEB peb = PsGetProcessPeb(target_proc);
	if (!peb)goto end;

	if (!peb->Ldr || !peb->Ldr->Initialized)goto end;

	UNICODE_STRING module_name_unicode;
	RtlInitUnicodeString(&module_name_unicode, module_name);
	for (PLIST_ENTRY list = peb->Ldr->InLoadOrderModuleList.Flink;
		list != &peb->Ldr->InLoadOrderModuleList;
		list = list->Flink) {
		PLDR_DATA_TABLE_ENTRY entry = CONTAINING_RECORD(list, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
		if (RtlCompareUnicodeString(&entry->BaseDllName, &module_name_unicode, TRUE) == 0) {
			base = (ULONGLONG)entry->DllBase;
			goto end;
		}
	}

end:
	KeDetachProcess();
	ObDereferenceObject(target_proc);
	return base;
}

NTSTATUS copy_memory(PEPROCESS src_proc, PEPROCESS target_proc, PVOID src, PVOID dst, SIZE_T size) {
	SIZE_T bytes;
	return MmCopyVirtualMemory(src_proc, src, target_proc, dst, size, UserMode, &bytes);
}



const UCHAR HkpDetour[] = {
		0x90, 0x90, 0xff, 0x25, 0x00, 0x00, 0x00, 0x00
};
#define INTERLOCKED_EXCHANGE_SIZE	(16ul)
_IRQL_requires_max_(APC_LEVEL)
static NTSTATUS HkpReplaceCode16Bytes(
	_In_ PVOID	Address,
	_In_ PUCHAR	Replacement
)
{
	//
	// Проверьте правильность выравнивания. cmpxchg16b работает только с 16-байтовыми выровненными адресами.
	//
	if ((ULONG64)Address != ((ULONG64)Address & ~0xf))
	{
		return STATUS_DATATYPE_MISALIGNMENT;
	}

	//
	// Создайте список дескрипторов памяти для отображения памяти только для чтения (или RX) как для чтения-записи.
	//
	PMDL Mdl = IoAllocateMdl(Address, INTERLOCKED_EXCHANGE_SIZE, FALSE, FALSE, NULL);
	if (Mdl == NULL)
	{
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	//
	// Сделайте страницы памяти постоянными в ОЗУ и убедитесь, что они не выгружаются.
	//
	__try
	{
		MmProbeAndLockPages(Mdl, KernelMode, IoReadAccess);
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		IoFreeMdl(Mdl);

		return STATUS_INVALID_ADDRESS;
	}

	//
	// Создайте новое отображение для постоянной памяти.
	//
	PLONG64 RwMapping = (PLONG64)MmMapLockedPagesSpecifyCache(
		Mdl,
		KernelMode,
		MmNonCached,
		NULL,
		FALSE,
		NormalPagePriority
	);

	if (RwMapping == NULL)
	{
		MmUnlockPages(Mdl);
		IoFreeMdl(Mdl);

		return STATUS_INTERNAL_ERROR;
	}

	//
	// Установите новую защиту страницы сопоставления на чтение и запись, чтобы изменить ее.
	//
	NTSTATUS Status = MmProtectMdlSystemAddress(Mdl, PAGE_READWRITE);
	if (!NT_SUCCESS(Status))
	{
		MmUnmapLockedPages(RwMapping, Mdl);
		MmUnlockPages(Mdl);
		IoFreeMdl(Mdl);

		return Status;
	}

	LONG64 PreviousContent[2];
	PreviousContent[0] = RwMapping[0];
	PreviousContent[1] = RwMapping[1];

	//
	// Замените 16 байтов кода, используя созданное отображение чтения-записи.
	// Блокированное сравнение и обмен (cmpxchg16b) используется, чтобы избежать проблем с параллелизмом.
	//
	InterlockedCompareExchange128(
		RwMapping,
		((PLONG64)Replacement)[1],
		((PLONG64)Replacement)[0],
		PreviousContent
	);

	//
	// Unlock and unmap pages, free MDL. 
	//
	MmUnmapLockedPages(RwMapping, Mdl);
	MmUnlockPages(Mdl);
	IoFreeMdl(Mdl);

	return STATUS_SUCCESS;
}


PVOID locate_shellcode(PDRIVER_OBJECT object, PVOID jmp_func)
{ 
	PVOID trampoline = (PVOID)object->MajorFunction[IRP_MJ_DEVICE_CONTROL];
	while (memcmp(trampoline, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 10))
	{
		(*(PBYTE*)&trampoline)++;
	}


    UCHAR DetourBytes[INTERLOCKED_EXCHANGE_SIZE];
	RtlCopyMemory(DetourBytes, HkpDetour, sizeof(HkpDetour));
	RtlCopyMemory(DetourBytes + sizeof(HkpDetour), &jmp_func, sizeof(PVOID));

	if (HkpReplaceCode16Bytes(trampoline, DetourBytes) == STATUS_SUCCESS)
	{
		return trampoline;
	}
	else return NULL;


}

extern "C" POBJECT_TYPE* IoDriverObjectType;
NTSTATUS SwapControl_f(UNICODE_STRING driver_name, PVOID hook_func, PVOID* original, BOOL write_trampoline)
{
	PVOID hook = hook_func;
	PDRIVER_OBJECT object = NULL;
	
	NTSTATUS _status = ObReferenceObjectByName(&driver_name, OBJ_CASE_INSENSITIVE, 0, 0, *IoDriverObjectType, KernelMode, 0, (PVOID*)&object);

	if (NT_SUCCESS(_status))
	{
		if (write_trampoline)
		{
			if (!(hook = locate_shellcode(object, hook)))
			{
				DBG("locate_shellcode error\n");
				return STATUS_UNSUCCESSFUL;
			}
		}
		PVOID old = object->MajorFunction[IRP_MJ_DEVICE_CONTROL];
		if (hook_func != *original)*original = old;


		InterlockedExchangePointer((PVOID*)&object->MajorFunction[IRP_MJ_DEVICE_CONTROL], (PVOID)hook);

		DBG("%wZ swapped(0x%I64x to 0x%I64x)\n", driver_name, old, hook);
		ObDereferenceObject(object);
		return STATUS_SUCCESS;
	}
	else
	{
		DBG("failed to get %wZ: %p !\n", &driver_name, _status);
		return STATUS_UNSUCCESSFUL;
	}
}
```

`SwapControl/tools.h`:

```h
#pragma once


#include "ntstructs.h"
#include "ntapi.h"
#include "common.h"

ULONGLONG get_module_handle(ULONG pid, LPCWSTR module_name);
NTSTATUS copy_memory(PEPROCESS src_proc, PEPROCESS target_proc, PVOID src, PVOID dst, SIZE_T size);
NTSTATUS SwapControl_f(UNICODE_STRING driver_name, PVOID hook_func, PVOID* original, BOOL write_trampoline);
```