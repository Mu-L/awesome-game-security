Project Path: arc_Jaysmito101_cgl_w23m12h5

Source Tree:

```txt
arc_Jaysmito101_cgl_w23m12h5
â”œâ”€â”€ CNAME
â”œâ”€â”€ CODE_OF_CONDUCT.md
â”œâ”€â”€ CONTRIBUTING.md
â”œâ”€â”€ Doxyfile
â”œâ”€â”€ LICENSE
â”œâ”€â”€ README.md
â”œâ”€â”€ cgl.c
â”œâ”€â”€ cgl.h
â”œâ”€â”€ examples
â”‚   â”œâ”€â”€ c
â”‚   â”‚   â”œâ”€â”€ 2d_collision_detection.c
â”‚   â”‚   â”œâ”€â”€ 2d_procedural_trees.c
â”‚   â”‚   â”œâ”€â”€ 3d_maze_game.c
â”‚   â”‚   â”œâ”€â”€ 3d_pipes.c
â”‚   â”‚   â”œâ”€â”€ 3d_raycaster.c
â”‚   â”‚   â”œâ”€â”€ 3d_widgets.c
â”‚   â”‚   â”œâ”€â”€ advanced_widgets.c
â”‚   â”‚   â”œâ”€â”€ approximating_pi.c
â”‚   â”‚   â”œâ”€â”€ audio_visualizer.c
â”‚   â”‚   â”œâ”€â”€ barnsley_fern.c
â”‚   â”‚   â”œâ”€â”€ basic_node_editor.c
â”‚   â”‚   â”œâ”€â”€ basic_plotting.c
â”‚   â”‚   â”œâ”€â”€ basic_raycast_2d_lighting.c
â”‚   â”‚   â”œâ”€â”€ basic_text_rendering.c
â”‚   â”‚   â”œâ”€â”€ basic_tile_render.c
â”‚   â”‚   â”œâ”€â”€ basic_widgets.c
â”‚   â”‚   â”œâ”€â”€ bezier_curve_widget.c
â”‚   â”‚   â”œâ”€â”€ bloom.c
â”‚   â”‚   â”œâ”€â”€ christmas_tree01.c
â”‚   â”‚   â”œâ”€â”€ christmas_tree_02.c
â”‚   â”‚   â”œâ”€â”€ climate_spiral.c
â”‚   â”‚   â”œâ”€â”€ colored_printf.c
â”‚   â”‚   â”œâ”€â”€ creating_threads.c
â”‚   â”‚   â”œâ”€â”€ creating_window.c
â”‚   â”‚   â”œâ”€â”€ csv_api_example.c
â”‚   â”‚   â”œâ”€â”€ double_pendulum.c
â”‚   â”‚   â”œâ”€â”€ embedding_nuklear_gui.c
â”‚   â”‚   â”œâ”€â”€ example_cmakelists.txt
â”‚   â”‚   â”œâ”€â”€ example_cmakelists_wasm.txt
â”‚   â”‚   â”œâ”€â”€ fireworks.c
â”‚   â”‚   â”œâ”€â”€ flappy_bird.c
â”‚   â”‚   â”œâ”€â”€ flappy_bird_ai.c
â”‚   â”‚   â”œâ”€â”€ flow_fields.c
â”‚   â”‚   â”œâ”€â”€ font_text_widgets.c
â”‚   â”‚   â”œâ”€â”€ game_of_life.c
â”‚   â”‚   â”œâ”€â”€ generic_mxn_matrix.c
â”‚   â”‚   â”œâ”€â”€ hashing_data.c
â”‚   â”‚   â”œâ”€â”€ hello_cube.c
â”‚   â”‚   â”œâ”€â”€ identicons.c
â”‚   â”‚   â”œâ”€â”€ interactive_2d_triangulation.c
â”‚   â”‚   â”œâ”€â”€ interactive_a_star_path_finding.c
â”‚   â”‚   â”œâ”€â”€ interactive_content_aware_crop.c
â”‚   â”‚   â”œâ”€â”€ interactive_linear_regression.c
â”‚   â”‚   â”œâ”€â”€ interactive_polynomial_regression.c
â”‚   â”‚   â”œâ”€â”€ julia_set_viewer.c
â”‚   â”‚   â”œâ”€â”€ l_systems_viewer.c
â”‚   â”‚   â”œâ”€â”€ lorenz_system_simulation.c
â”‚   â”‚   â”œâ”€â”€ mandelbrot_set_viewer.c
â”‚   â”‚   â”œâ”€â”€ mandelbrot_set_viewer_high_precesion.c
â”‚   â”‚   â”œâ”€â”€ marching_squares.c
â”‚   â”‚   â”œâ”€â”€ markov_text_generation.c
â”‚   â”‚   â”œâ”€â”€ menger_sponge_fractal.c
â”‚   â”‚   â”œâ”€â”€ neopeed.c
â”‚   â”‚   â”œâ”€â”€ newton_equation_root_appximator.c
â”‚   â”‚   â”œâ”€â”€ noise_generator.c
â”‚   â”‚   â”œâ”€â”€ one_million_particles_01.c
â”‚   â”‚   â”œâ”€â”€ phong_renderer.c
â”‚   â”‚   â”œâ”€â”€ playing_audio.c
â”‚   â”‚   â”œâ”€â”€ pong_game.c
â”‚   â”‚   â”œâ”€â”€ procedural_sky.c
â”‚   â”‚   â”œâ”€â”€ procedural_symmetric_design.c
â”‚   â”‚   â”œâ”€â”€ realtime_volumetric_clouds.c
â”‚   â”‚   â”œâ”€â”€ sierpinski_tirangle.c
â”‚   â”‚   â”œâ”€â”€ simple_quad_tree.c
â”‚   â”‚   â”œâ”€â”€ simple_ssl_tcp_client.c
â”‚   â”‚   â”œâ”€â”€ simple_tcp_client.c
â”‚   â”‚   â”œâ”€â”€ single_pendlum.c
â”‚   â”‚   â”œâ”€â”€ slime_mould_sim.c
â”‚   â”‚   â”œâ”€â”€ sudoku_game.c
â”‚   â”‚   â”œâ”€â”€ text_widgets_example.c
â”‚   â”‚   â”œâ”€â”€ texture_widgets.c
â”‚   â”‚   â”œâ”€â”€ toon_post_processor.c
â”‚   â”‚   â”œâ”€â”€ trail_renderer.c
â”‚   â”‚   â”œâ”€â”€ using_advanced_logger.c
â”‚   â”‚   â”œâ”€â”€ using_hashtable.c
â”‚   â”‚   â”œâ”€â”€ using_hashtable_iterator.c
â”‚   â”‚   â””â”€â”€ vector_field_visualizer.c
â”‚   â”œâ”€â”€ python
â”‚   â”‚   â”œâ”€â”€ 3d_ai_hands.py
â”‚   â”‚   â”œâ”€â”€ ascii_video.py
â”‚   â”‚   â”œâ”€â”€ chrome_dino.py
â”‚   â”‚   â”œâ”€â”€ cube_waves.py
â”‚   â”‚   â”œâ”€â”€ curve_editor.py
â”‚   â”‚   â”œâ”€â”€ snake_game.py
â”‚   â”‚   â””â”€â”€ tesseract.py
â”‚   â””â”€â”€ rust
â”‚       â”œâ”€â”€ curve_editor.rs
â”‚       â”œâ”€â”€ dijkstra_visualizer.rs
â”‚       â””â”€â”€ simple_window.rs
â”œâ”€â”€ images
â”‚   â”œâ”€â”€ CGL_logo_high_res.png
â”‚   â”œâ”€â”€ CGL_logo_low_mid_res.png
â”‚   â”œâ”€â”€ CGL_logo_low_res.png
â”‚   â””â”€â”€ CGL_logo_mid_res.png
â”œâ”€â”€ logo.png
â”œâ”€â”€ python_wrapper
â”‚   â”œâ”€â”€ MANIFEST.in
â”‚   â”œâ”€â”€ cgl_wrapper.pyx
â”‚   â”œâ”€â”€ lib
â”‚   â”‚   â”œâ”€â”€ cgl.lib
â”‚   â”‚   â”œâ”€â”€ freetype.lib
â”‚   â”‚   â”œâ”€â”€ glad.lib
â”‚   â”‚   â”œâ”€â”€ glfw3.lib
â”‚   â”‚   â”œâ”€â”€ libcgl.a
â”‚   â”‚   â”œâ”€â”€ libfreetype.a
â”‚   â”‚   â”œâ”€â”€ libglad.a
â”‚   â”‚   â””â”€â”€ libglfw3.a
â”‚   â”œâ”€â”€ pyproject.toml
â”‚   â””â”€â”€ setup.py
â”œâ”€â”€ rust_wrapper
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â”œâ”€â”€ cgl-rs
â”‚   â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â”‚   â”œâ”€â”€ lib
â”‚   â”‚   â”‚   â”œâ”€â”€ cgl_wrapper.c
â”‚   â”‚   â”‚   â”œâ”€â”€ linux
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ libcgl.a
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ libfreetype.a
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ libglad.a
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ libglfw3.a
â”‚   â”‚   â”‚   â””â”€â”€ windows
â”‚   â”‚   â”‚       â”œâ”€â”€ cgl.lib
â”‚   â”‚   â”‚       â”œâ”€â”€ freetype.lib
â”‚   â”‚   â”‚       â”œâ”€â”€ glad.lib
â”‚   â”‚   â”‚       â””â”€â”€ glfw3.lib
â”‚   â”‚   â””â”€â”€ src
â”‚   â”‚       â”œâ”€â”€ build.rs
â”‚   â”‚       â”œâ”€â”€ graphics
â”‚   â”‚       â”‚   â”œâ”€â”€ bloom.rs
â”‚   â”‚       â”‚   â”œâ”€â”€ framebuffer.rs
â”‚   â”‚       â”‚   â”œâ”€â”€ mesh.rs
â”‚   â”‚       â”‚   â”œâ”€â”€ shader.rs
â”‚   â”‚       â”‚   â”œâ”€â”€ ssbo.rs
â”‚   â”‚       â”‚   â”œâ”€â”€ text.rs
â”‚   â”‚       â”‚   â”œâ”€â”€ texture.rs
â”‚   â”‚       â”‚   â”œâ”€â”€ tilemap.rs
â”‚   â”‚       â”‚   â””â”€â”€ widgets.rs
â”‚   â”‚       â”œâ”€â”€ graphics.rs
â”‚   â”‚       â”œâ”€â”€ lib.rs
â”‚   â”‚       â”œâ”€â”€ logger.rs
â”‚   â”‚       â”œâ”€â”€ macros.rs
â”‚   â”‚       â”œâ”€â”€ math
â”‚   â”‚       â”‚   â”œâ”€â”€ activations.rs
â”‚   â”‚       â”‚   â”œâ”€â”€ constants.rs
â”‚   â”‚       â”‚   â”œâ”€â”€ matrix.rs
â”‚   â”‚       â”‚   â””â”€â”€ vector.rs
â”‚   â”‚       â”œâ”€â”€ math.rs
â”‚   â”‚       â”œâ”€â”€ noise.rs
â”‚   â”‚       â”œâ”€â”€ utils.rs
â”‚   â”‚       â”œâ”€â”€ window.rs
â”‚   â”‚       â””â”€â”€ window_manager.rs
â”‚   â””â”€â”€ sandbox
â”‚       â”œâ”€â”€ Cargo.toml
â”‚       â””â”€â”€ src
â”‚           â””â”€â”€ main.rs
â””â”€â”€ showreel
    â”œâ”€â”€ bezier_curve.mp4
    â”œâ”€â”€ gjk_epa_2d.mp4
    â”œâ”€â”€ maze_3d.mp4
    â”œâ”€â”€ node_editor.mp4
    â”œâ”€â”€ plotting.mp4
    â”œâ”€â”€ ray_caster.mp4
    â”œâ”€â”€ sat_collisions.mp4
    â”œâ”€â”€ sqmar.mp4
    â””â”€â”€ sudoku.mp4

```

`CNAME`:

```
libcgl.tech
```

`CODE_OF_CONDUCT.md`:

```md
# Contributor Covenant Code of Conduct

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, religion, or sexual identity
and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our Standards

Examples of behavior that contributes to a positive environment for our
community include:

* Demonstrating empathy and kindness toward other people
* Being respectful of differing opinions, viewpoints, and experiences
* Giving and gracefully accepting constructive feedback
* Accepting responsibility and apologizing to those affected by our mistakes,
  and learning from the experience
* Focusing on what is best not just for us as individuals, but for the
  overall community

Examples of unacceptable behavior include:

* The use of sexualized language or imagery, and sexual attention or
  advances of any kind
* Trolling, insulting or derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or email
  address, without their explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

## Scope

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
jaysmito101@gmail.com.
All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

## Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction

**Community Impact**: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.

### 2. Warning

**Community Impact**: A violation through a single incident or series
of actions.

**Consequence**: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or
permanent ban.

### 3. Temporary Ban

**Community Impact**: A serious violation of community standards, including
sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.

### 4. Permanent Ban

**Community Impact**: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior,  harassment of an
individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within
the community.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.0, available at
https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.

Community Impact Guidelines were inspired by [Mozilla's code of conduct
enforcement ladder](https://github.com/mozilla/diversity).

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see the FAQ at
https://www.contributor-covenant.org/faq. Translations are available at
https://www.contributor-covenant.org/translations.

```

`CONTRIBUTING.md`:

```md
# Contributing to CGL

First off, thanks for taking the time to contribute! â¤ï¸

All types of contributions are encouraged and valued. See the [Table of Contents](#table-of-contents) for different ways to help and details about how this project handles them. Please make sure to read the relevant section before making your contribution. It will make it a lot easier for us maintainers and smooth out the experience for all involved. The community looks forward to your contributions. ðŸŽ‰

> And if you like the project, but just don't have time to contribute, that's fine. There are other easy ways to support the project and show your appreciation, which we would also be very happy about:
> - Star the project
> - Tweet about it
> - Refer this project in your project's readme
> - Mention the project at local meetups and tell your friends/colleagues

<!-- omit in toc -->
## Table of Contents

- [Code of Conduct](#code-of-conduct)
- [I Have a Question](#i-have-a-question)
- [I Want To Contribute](#i-want-to-contribute)
- [Reporting Bugs](#reporting-bugs)
- [Suggesting Enhancements](#suggesting-enhancements)
- [Your First Code Contribution](#your-first-code-contribution)
- [Improving The Documentation](#improving-the-documentation)
- [Styleguides](#styleguides)
- [Commit Messages](#commit-messages)

## Code of Conduct

This project and everyone participating in it is governed by the
[CGL Code of Conduct](https://github.com/Jaysmito101/cgl/blob/main/CODE_OF_CONDUCT.md).
By participating, you are expected to uphold this code. Please report unacceptable behavior
to jaysmito101@gmail.com.


## I Have a Question

> If you want to ask a question, we assume that you have read the available [Documentation]().

Before you ask a question, it is best to search for existing [Issues](https://github.com/Jaysmito101/cgl/issues) that might help you. In case you have found a suitable issue and still need clarification, you can write your question in this issue. It is also advisable to search the internet for answers first.

If you then still feel the need to ask a question and need clarification, we recommend the following:

- Open an [Issue](https://github.com/Jaysmito101/cgl/issues/new).
- Provide as much context as you can about what you're running into.
- Provide project and platform versions depending on what seems relevant.
- Please also provide the System Specifications ( CPU, GPU, Memory )
- If necessary try to attach a screenshot

We will then take care of the issue as soon as possible.

## I Want To Contribute

When contributing to this project, you must agree that you have authored 100% of the content, that you have the necessary rights to the content and that the content you contribute may be provided under the project license.

<b> Note that any contributions made purely made using AI tools like ChatGPT is <i>not allowed</i>. </b> You are free to take help from such tools but the work should be the result of your own serious effort.

### Reporting Bugs

<!-- omit in toc -->
#### Before Submitting a Bug Report

A good bug report shouldn't leave others needing to chase you up for more information. Therefore, we ask you to investigate carefully, collect information and describe the issue in detail in your report. Please complete the following steps in advance to help us fix any potential bug as fast as possible.

- Make sure that you are using the latest version.
- Determine if your bug is really a bug and not an error on your side e.g. using incompatible environment components/versions (Make sure that you have read the [documentation](). If you are looking for support, you might want to check [this section](#i-have-a-question)).
- To see if other users have experienced (and potentially already solved) the same issue you are having, check if there is not already a bug report existing for your bug or error in the [bug tracker](https://github.com/Jaysmito101/cglissues?q=label%3Abug).
- Also make sure to search the internet (including Stack Overflow) to see if users outside of the GitHub community have discussed the issue.
- Collect information about the bug:
- Stack trace (Traceback)
- OS, Platform and Version (Windows, Linux, macOS, x86, ARM), Also System Specifications (GPU, CPU, Memory)
- Version of the interpreter, compiler, SDK, runtime environment, package manager, depending on what seems relevant.
- Possibly your input and the output
- Can you reliably reproduce the issue? And can you also reproduce it with older versions?

<!-- omit in toc -->
#### How Do I Submit a Good Bug Report?

> You must never report security related issues, vulnerabilities or bugs including sensitive information to the issue tracker, or elsewhere in public. Instead sensitive bugs must be sent by email to .

We use GitHub issues to track bugs and errors. If you run into an issue with the project:

- Open an [Issue](https://github.com/Jaysmito101/cgl/issues/new). (Since we can't be sure at this point whether it is a bug or not, we ask you not to talk about a bug yet and not to label the issue.)
- Explain the behavior you would expect and the actual behavior.
- Please provide as much context as possible and describe the *reproduction steps* that someone else can follow to recreate the issue on their own. This usually includes your code. For good bug reports you should isolate the problem and create a reduced test case.
- Provide the information you collected in the previous section.

Once it's filed:

- The project team will label the issue accordingly.
- A team member will try to reproduce the issue with your provided steps. If there are no reproduction steps or no obvious way to reproduce the issue, the team will ask you for those steps and mark the issue as `needs-repro`. Bugs with the `needs-repro` tag will not be addressed until they are reproduced.
- If the team is able to reproduce the issue, it will be marked `needs-fix`, as well as possibly other tags (such as `critical`), and the issue will be left to be [implemented by someone](#your-first-code-contribution).

### Suggesting Enhancements

This section guides you through submitting an enhancement suggestion for CGL, **including completely new features and minor improvements to existing functionality**. Following these guidelines will help maintainers and the community to understand your suggestion and find related suggestions.

<!-- omit in toc -->
#### Before Submitting an Enhancement

- Make sure that you are using the latest version.
- Read the [documentation]() carefully and find out if the functionality is already covered, maybe by an individual configuration.
- Perform a [search](https://github.com/Jaysmito101/cgl/issues) to see if the enhancement has already been suggested. If it has, add a comment to the existing issue instead of opening a new one.
- Find out whether your idea fits with the scope and aims of the project. It's up to you to make a strong case to convince the project's developers of the merits of this feature. Keep in mind that we want features that will be useful to the majority of our users and not just a small subset. If you're just targeting a minority of users, consider writing an add-on/plugin library.

<!-- omit in toc -->
#### How Do I Submit a Good Enhancement Suggestion?

Enhancement suggestions are tracked as [GitHub issues](https://github.com/Jaysmito101/cgl/issues).

- Use a **clear and descriptive title** for the issue to identify the suggestion. Preferable title should start with "Feature Request: ".
- Provide a **step-by-step description of the suggested enhancement** in as many details as possible.
- **Describe the current behavior** and **explain which behavior you expected to see instead** and why. At this point you can also tell which alternatives do not work for you.
- You may want to **include screenshots and animated GIFs** which help you demonstrate the steps or point out the part which the suggestion is related to. You can use [this tool](https://www.cockos.com/licecap/) to record GIFs on macOS and Windows, and [this tool](https://github.com/colinkeenan/silentcast) or [this tool](https://github.com/GNOME/byzanz) on Linux. <!-- this should only be included if the project has a GUI -->
- **Explain why this enhancement would be useful** to most CGL users. You may also want to point out the other projects that solved it better and which could serve as inspiration.

### Your First Code Contribution

CGL requires the following to get started with development :
 - Git
 - CMake (3.12 +)
 - MSVC/GCC/Clang
 - GLFW (Optional)
 - OpenAL (Optional)
 - Freetype2 (Optional)

You can check the example CMakeLists.txt file for how to setup a project [here](https://github.com/Jaysmito101/cgl/blob/main/examples/c/example_cmakelists.txt).


### Improving The Documentation

The Library is self documenting (documentation is within the source as comments).

## Styleguides
### Commit Messages
They should be short and to the point .

### Code Style
Before contributing please read through a part of `cgl.h` to get an idea of CGL conventions.

- Use snake-case for everything
- Macros and constants should be in CAPS
- Every CGL type or function should start with `CGL_`
- The CGL functions have following names `CGL_` + `module-name_` + `function-name`
- Avoid using char/short/int/long/float/etc but rather use CGL_byte/CGL_int/CGL_float/etc
- Anything that is not meant to be exposed as part of the API should be static and start with `__CGL_`
- Try to compress the code by
  * Avoid braces for single line blocks
  * Try to avoid if/else if possible
  * Try to compress multiple lines to a single line as much as possible
- Use CGL internal types for new modules rather than creating it separately for them
- Avoid Code Repetition
- Try to place simple single line functions as Macros if possible

```

`Doxyfile`:

```
# Doxyfile 1.9.7

# This file describes the settings to be used by the documentation system
# doxygen (www.doxygen.org) for a project.
#
# All text after a double hash (##) is considered a comment and is placed in
# front of the TAG it is preceding.
#
# All text after a single hash (#) is considered a comment and will be ignored.
# The format is:
# TAG = value [value, ...]
# For lists, items can also be appended using:
# TAG += value [value, ...]
# Values that contain spaces should be placed between quotes (\" \").
#
# Note:
#
# Use doxygen to compare the used configuration file with the template
# configuration file:
# doxygen -x [configFile]
# Use doxygen to compare the used configuration file with the template
# configuration file without replacing the environment variables or CMake type
# replacement variables:
# doxygen -x_noenv [configFile]

#---------------------------------------------------------------------------
# Project related configuration options
#---------------------------------------------------------------------------

# This tag specifies the encoding used for all characters in the configuration
# file that follow. The default is UTF-8 which is also the encoding used for all
# text before the first occurrence of this tag. Doxygen uses libiconv (or the
# iconv built into libc) for the transcoding. See
# https://www.gnu.org/software/libiconv/ for the list of possible encodings.
# The default value is: UTF-8.

DOXYFILE_ENCODING      = UTF-8

# The PROJECT_NAME tag is a single word (or a sequence of words surrounded by
# double-quotes, unless you are using Doxywizard) that should identify the
# project for which the documentation is generated. This name is used in the
# title of most generated pages and in a few other places.
# The default value is: My Project.

PROJECT_NAME           = CGL

# The PROJECT_NUMBER tag can be used to enter a project or revision number. This
# could be handy for archiving the generated documentation or if some version
# control system is used.

PROJECT_NUMBER         = 0.5

# Using the PROJECT_BRIEF tag one can provide an optional one line description
# for a project that appears at the top of each page and should give viewer a
# quick idea about the purpose of the project. Keep the description short.

PROJECT_BRIEF          = "CGL (C Game Library) is a multipurpose library mainly for recreational coding / demo scenes / prototyping / small games / experimentation"

# With the PROJECT_LOGO tag one can specify a logo or an icon that is included
# in the documentation. The maximum height of the logo should not exceed 55
# pixels and the maximum width should not exceed 200 pixels. Doxygen will copy
# the logo to the output directory.

PROJECT_LOGO           = CGL_logo_mid_res.png

# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) path
# into which the generated documentation will be written. If a relative path is
# entered, it will be relative to the location where doxygen was started. If
# left blank the current directory will be used.

OUTPUT_DIRECTORY       = docs

# If the CREATE_SUBDIRS tag is set to YES then doxygen will create up to 4096
# sub-directories (in 2 levels) under the output directory of each output format
# and will distribute the generated files over these directories. Enabling this
# option can be useful when feeding doxygen a huge amount of source files, where
# putting all generated files in the same directory would otherwise causes
# performance problems for the file system. Adapt CREATE_SUBDIRS_LEVEL to
# control the number of sub-directories.
# The default value is: NO.

CREATE_SUBDIRS         = YES

# Controls the number of sub-directories that will be created when
# CREATE_SUBDIRS tag is set to YES. Level 0 represents 16 directories, and every
# level increment doubles the number of directories, resulting in 4096
# directories at level 8 which is the default and also the maximum value. The
# sub-directories are organized in 2 levels, the first level always has a fixed
# number of 16 directories.
# Minimum value: 0, maximum value: 8, default value: 8.
# This tag requires that the tag CREATE_SUBDIRS is set to YES.

CREATE_SUBDIRS_LEVEL   = 8

# If the ALLOW_UNICODE_NAMES tag is set to YES, doxygen will allow non-ASCII
# characters to appear in the names of generated files. If set to NO, non-ASCII
# characters will be escaped, for example _xE3_x81_x84 will be used for Unicode
# U+3044.
# The default value is: NO.

ALLOW_UNICODE_NAMES    = NO

# The OUTPUT_LANGUAGE tag is used to specify the language in which all
# documentation generated by doxygen is written. Doxygen will use this
# information to generate all constant output in the proper language.
# Possible values are: Afrikaans, Arabic, Armenian, Brazilian, Bulgarian,
# Catalan, Chinese, Chinese-Traditional, Croatian, Czech, Danish, Dutch, English
# (United States), Esperanto, Farsi (Persian), Finnish, French, German, Greek,
# Hindi, Hungarian, Indonesian, Italian, Japanese, Japanese-en (Japanese with
# English messages), Korean, Korean-en (Korean with English messages), Latvian,
# Lithuanian, Macedonian, Norwegian, Persian (Farsi), Polish, Portuguese,
# Romanian, Russian, Serbian, Serbian-Cyrillic, Slovak, Slovene, Spanish,
# Swedish, Turkish, Ukrainian and Vietnamese.
# The default value is: English.

OUTPUT_LANGUAGE        = English

# If the BRIEF_MEMBER_DESC tag is set to YES, doxygen will include brief member
# descriptions after the members that are listed in the file and class
# documentation (similar to Javadoc). Set to NO to disable this.
# The default value is: YES.

BRIEF_MEMBER_DESC      = YES

# If the REPEAT_BRIEF tag is set to YES, doxygen will prepend the brief
# description of a member or function before the detailed description
#
# Note: If both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the
# brief descriptions will be completely suppressed.
# The default value is: YES.

REPEAT_BRIEF           = YES

# This tag implements a quasi-intelligent brief description abbreviator that is
# used to form the text in various listings. Each string in this list, if found
# as the leading text of the brief description, will be stripped from the text
# and the result, after processing the whole list, is used as the annotated
# text. Otherwise, the brief description is used as-is. If left blank, the
# following values are used ($name is automatically replaced with the name of
# the entity):The $name class, The $name widget, The $name file, is, provides,
# specifies, contains, represents, a, an and the.

ABBREVIATE_BRIEF       = "The $name class" \
                         "The $name widget" \
                         "The $name file" \
                         is \
                         provides \
                         specifies \
                         contains \
                         represents \
                         a \
                         an \
                         the

# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then
# doxygen will generate a detailed section even if there is only a brief
# description.
# The default value is: NO.

ALWAYS_DETAILED_SEC    = NO

# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all
# inherited members of a class in the documentation of that class as if those
# members were ordinary class members. Constructors, destructors and assignment
# operators of the base classes will not be shown.
# The default value is: NO.

INLINE_INHERITED_MEMB  = NO

# If the FULL_PATH_NAMES tag is set to YES, doxygen will prepend the full path
# before files name in the file list and in the header files. If set to NO the
# shortest path that makes the file name unique will be used
# The default value is: YES.

FULL_PATH_NAMES        = YES

# The STRIP_FROM_PATH tag can be used to strip a user-defined part of the path.
# Stripping is only done if one of the specified strings matches the left-hand
# part of the path. The tag can be used to show relative paths in the file list.
# If left blank the directory from which doxygen is run is used as the path to
# strip.
#
# Note that you can specify absolute paths here, but also relative paths, which
# will be relative from the directory where doxygen is started.
# This tag requires that the tag FULL_PATH_NAMES is set to YES.

STRIP_FROM_PATH        =

# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of the
# path mentioned in the documentation of a class, which tells the reader which
# header file to include in order to use a class. If left blank only the name of
# the header file containing the class definition is used. Otherwise one should
# specify the list of include paths that are normally passed to the compiler
# using the -I flag.

STRIP_FROM_INC_PATH    =

# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter (but
# less readable) file names. This can be useful is your file systems doesn't
# support long names like on DOS, Mac, or CD-ROM.
# The default value is: NO.

SHORT_NAMES            = NO

# If the JAVADOC_AUTOBRIEF tag is set to YES then doxygen will interpret the
# first line (until the first dot) of a Javadoc-style comment as the brief
# description. If set to NO, the Javadoc-style will behave just like regular Qt-
# style comments (thus requiring an explicit @brief command for a brief
# description.)
# The default value is: NO.

JAVADOC_AUTOBRIEF      = NO

# If the JAVADOC_BANNER tag is set to YES then doxygen will interpret a line
# such as
# /***************
# as being the beginning of a Javadoc-style comment "banner". If set to NO, the
# Javadoc-style will behave just like regular comments and it will not be
# interpreted by doxygen.
# The default value is: NO.

JAVADOC_BANNER         = NO

# If the QT_AUTOBRIEF tag is set to YES then doxygen will interpret the first
# line (until the first dot) of a Qt-style comment as the brief description. If
# set to NO, the Qt-style will behave just like regular Qt-style comments (thus
# requiring an explicit \brief command for a brief description.)
# The default value is: NO.

QT_AUTOBRIEF           = NO

# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make doxygen treat a
# multi-line C++ special comment block (i.e. a block of //! or /// comments) as
# a brief description. This used to be the default behavior. The new default is
# to treat a multi-line C++ comment block as a detailed description. Set this
# tag to YES if you prefer the old behavior instead.
#
# Note that setting this tag to YES also means that rational rose comments are
# not recognized any more.
# The default value is: NO.

MULTILINE_CPP_IS_BRIEF = NO

# By default Python docstrings are displayed as preformatted text and doxygen's
# special commands cannot be used. By setting PYTHON_DOCSTRING to NO the
# doxygen's special commands can be used and the contents of the docstring
# documentation blocks is shown as doxygen documentation.
# The default value is: YES.

PYTHON_DOCSTRING       = YES

# If the INHERIT_DOCS tag is set to YES then an undocumented member inherits the
# documentation from any documented member that it re-implements.
# The default value is: YES.

INHERIT_DOCS           = YES

# If the SEPARATE_MEMBER_PAGES tag is set to YES then doxygen will produce a new
# page for each member. If set to NO, the documentation of a member will be part
# of the file/class/namespace that contains it.
# The default value is: NO.

SEPARATE_MEMBER_PAGES  = NO

# The TAB_SIZE tag can be used to set the number of spaces in a tab. Doxygen
# uses this value to replace tabs by spaces in code fragments.
# Minimum value: 1, maximum value: 16, default value: 4.

TAB_SIZE               = 4

# This tag can be used to specify a number of aliases that act as commands in
# the documentation. An alias has the form:
# name=value
# For example adding
# "sideeffect=@par Side Effects:^^"
# will allow you to put the command \sideeffect (or @sideeffect) in the
# documentation, which will result in a user-defined paragraph with heading
# "Side Effects:". Note that you cannot put \n's in the value part of an alias
# to insert newlines (in the resulting output). You can put ^^ in the value part
# of an alias to insert a newline as if a physical newline was in the original
# file. When you need a literal { or } or , in the value part of an alias you
# have to escape them by means of a backslash (\), this can lead to conflicts
# with the commands \{ and \} for these it is advised to use the version @{ and
# @} or use a double escape (\\{ and \\})

ALIASES                =

# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C sources
# only. Doxygen will then generate output that is more tailored for C. For
# instance, some of the names that are used will be different. The list of all
# members will be omitted, etc.
# The default value is: NO.

OPTIMIZE_OUTPUT_FOR_C  = YES

# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java or
# Python sources only. Doxygen will then generate output that is more tailored
# for that language. For instance, namespaces will be presented as packages,
# qualified scopes will look different, etc.
# The default value is: NO.

OPTIMIZE_OUTPUT_JAVA   = NO

# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran
# sources. Doxygen will then generate output that is tailored for Fortran.
# The default value is: NO.

OPTIMIZE_FOR_FORTRAN   = NO

# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL
# sources. Doxygen will then generate output that is tailored for VHDL.
# The default value is: NO.

OPTIMIZE_OUTPUT_VHDL   = NO

# Set the OPTIMIZE_OUTPUT_SLICE tag to YES if your project consists of Slice
# sources only. Doxygen will then generate output that is more tailored for that
# language. For instance, namespaces will be presented as modules, types will be
# separated into more groups, etc.
# The default value is: NO.

OPTIMIZE_OUTPUT_SLICE  = NO

# Doxygen selects the parser to use depending on the extension of the files it
# parses. With this tag you can assign which parser to use for a given
# extension. Doxygen has a built-in mapping, but you can override or extend it
# using this tag. The format is ext=language, where ext is a file extension, and
# language is one of the parsers supported by doxygen: IDL, Java, JavaScript,
# Csharp (C#), C, C++, Lex, D, PHP, md (Markdown), Objective-C, Python, Slice,
# VHDL, Fortran (fixed format Fortran: FortranFixed, free formatted Fortran:
# FortranFree, unknown formatted Fortran: Fortran. In the later case the parser
# tries to guess whether the code is fixed or free formatted code, this is the
# default for Fortran type files). For instance to make doxygen treat .inc files
# as Fortran files (default is PHP), and .f files as C (default is Fortran),
# use: inc=Fortran f=C.
#
# Note: For files without extension you can use no_extension as a placeholder.
#
# Note that for custom extensions you also need to set FILE_PATTERNS otherwise
# the files are not read by doxygen. When specifying no_extension you should add
# * to the FILE_PATTERNS.
#
# Note see also the list of default file extension mappings.

EXTENSION_MAPPING      =

# If the MARKDOWN_SUPPORT tag is enabled then doxygen pre-processes all comments
# according to the Markdown format, which allows for more readable
# documentation. See https://daringfireball.net/projects/markdown/ for details.
# The output of markdown processing is further processed by doxygen, so you can
# mix doxygen, HTML, and XML commands with Markdown formatting. Disable only in
# case of backward compatibilities issues.
# The default value is: YES.

MARKDOWN_SUPPORT       = YES

# When the TOC_INCLUDE_HEADINGS tag is set to a non-zero value, all headings up
# to that level are automatically included in the table of contents, even if
# they do not have an id attribute.
# Note: This feature currently applies only to Markdown headings.
# Minimum value: 0, maximum value: 99, default value: 5.
# This tag requires that the tag MARKDOWN_SUPPORT is set to YES.

TOC_INCLUDE_HEADINGS   = 5

# The MARKDOWN_ID_STYLE tag can be used to specify the algorithm used to
# generate identifiers for the Markdown headings. Note: Every identifier is
# unique.
# Possible values are: DOXYGEN Use a fixed 'autotoc_md' string followed by a
# sequence number starting at 0. and GITHUB Use the lower case version of title
# with any whitespace replaced by '-' and punctations characters removed..
# The default value is: DOXYGEN.
# This tag requires that the tag MARKDOWN_SUPPORT is set to YES.

MARKDOWN_ID_STYLE      = DOXYGEN

# When enabled doxygen tries to link words that correspond to documented
# classes, or namespaces to their corresponding documentation. Such a link can
# be prevented in individual cases by putting a % sign in front of the word or
# globally by setting AUTOLINK_SUPPORT to NO.
# The default value is: YES.

AUTOLINK_SUPPORT       = YES

# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want
# to include (a tag file for) the STL sources as input, then you should set this
# tag to YES in order to let doxygen match functions declarations and
# definitions whose arguments contain STL classes (e.g. func(std::string);
# versus func(std::string) {}). This also make the inheritance and collaboration
# diagrams that involve STL classes more complete and accurate.
# The default value is: NO.

BUILTIN_STL_SUPPORT    = NO

# If you use Microsoft's C++/CLI language, you should set this option to YES to
# enable parsing support.
# The default value is: NO.

CPP_CLI_SUPPORT        = NO

# Set the SIP_SUPPORT tag to YES if your project consists of sip (see:
# https://www.riverbankcomputing.com/software/sip/intro) sources only. Doxygen
# will parse them like normal C++ but will assume all classes use public instead
# of private inheritance when no explicit protection keyword is present.
# The default value is: NO.

SIP_SUPPORT            = NO

# For Microsoft's IDL there are propget and propput attributes to indicate
# getter and setter methods for a property. Setting this option to YES will make
# doxygen to replace the get and set methods by a property in the documentation.
# This will only work if the methods are indeed getting or setting a simple
# type. If this is not the case, or you want to show the methods anyway, you
# should set this option to NO.
# The default value is: YES.

IDL_PROPERTY_SUPPORT   = YES

# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC
# tag is set to YES then doxygen will reuse the documentation of the first
# member in the group (if any) for the other members of the group. By default
# all members of a group must be documented explicitly.
# The default value is: NO.

DISTRIBUTE_GROUP_DOC   = NO

# If one adds a struct or class to a group and this option is enabled, then also
# any nested class or struct is added to the same group. By default this option
# is disabled and one has to add nested compounds explicitly via \ingroup.
# The default value is: NO.

GROUP_NESTED_COMPOUNDS = NO

# Set the SUBGROUPING tag to YES to allow class member groups of the same type
# (for instance a group of public functions) to be put as a subgroup of that
# type (e.g. under the Public Functions section). Set it to NO to prevent
# subgrouping. Alternatively, this can be done per class using the
# \nosubgrouping command.
# The default value is: YES.

SUBGROUPING            = YES

# When the INLINE_GROUPED_CLASSES tag is set to YES, classes, structs and unions
# are shown inside the group in which they are included (e.g. using \ingroup)
# instead of on a separate page (for HTML and Man pages) or section (for LaTeX
# and RTF).
#
# Note that this feature does not work in combination with
# SEPARATE_MEMBER_PAGES.
# The default value is: NO.

INLINE_GROUPED_CLASSES = NO

# When the INLINE_SIMPLE_STRUCTS tag is set to YES, structs, classes, and unions
# with only public data fields or simple typedef fields will be shown inline in
# the documentation of the scope in which they are defined (i.e. file,
# namespace, or group documentation), provided this scope is documented. If set
# to NO, structs, classes, and unions are shown on a separate page (for HTML and
# Man pages) or section (for LaTeX and RTF).
# The default value is: NO.

INLINE_SIMPLE_STRUCTS  = NO

# When TYPEDEF_HIDES_STRUCT tag is enabled, a typedef of a struct, union, or
# enum is documented as struct, union, or enum with the name of the typedef. So
# typedef struct TypeS {} TypeT, will appear in the documentation as a struct
# with name TypeT. When disabled the typedef will appear as a member of a file,
# namespace, or class. And the struct will be named TypeS. This can typically be
# useful for C code in case the coding convention dictates that all compound
# types are typedef'ed and only the typedef is referenced, never the tag name.
# The default value is: NO.

TYPEDEF_HIDES_STRUCT   = NO

# The size of the symbol lookup cache can be set using LOOKUP_CACHE_SIZE. This
# cache is used to resolve symbols given their name and scope. Since this can be
# an expensive process and often the same symbol appears multiple times in the
# code, doxygen keeps a cache of pre-resolved symbols. If the cache is too small
# doxygen will become slower. If the cache is too large, memory is wasted. The
# cache size is given by this formula: 2^(16+LOOKUP_CACHE_SIZE). The valid range
# is 0..9, the default is 0, corresponding to a cache size of 2^16=65536
# symbols. At the end of a run doxygen will report the cache usage and suggest
# the optimal cache size from a speed point of view.
# Minimum value: 0, maximum value: 9, default value: 0.

LOOKUP_CACHE_SIZE      = 0

# The NUM_PROC_THREADS specifies the number of threads doxygen is allowed to use
# during processing. When set to 0 doxygen will based this on the number of
# cores available in the system. You can set it explicitly to a value larger
# than 0 to get more control over the balance between CPU load and processing
# speed. At this moment only the input processing can be done using multiple
# threads. Since this is still an experimental feature the default is set to 1,
# which effectively disables parallel processing. Please report any issues you
# encounter. Generating dot graphs in parallel is controlled by the
# DOT_NUM_THREADS setting.
# Minimum value: 0, maximum value: 32, default value: 1.

NUM_PROC_THREADS       = 1

# If the TIMESTAMP tag is set different from NO then each generated page will
# contain the date or date and time when the page was generated. Setting this to
# NO can help when comparing the output of multiple runs.
# Possible values are: YES, NO, DATETIME and DATE.
# The default value is: NO.

TIMESTAMP              = NO

#---------------------------------------------------------------------------
# Build related configuration options
#---------------------------------------------------------------------------

# If the EXTRACT_ALL tag is set to YES, doxygen will assume all entities in
# documentation are documented, even if no documentation was available. Private
# class members and static file members will be hidden unless the
# EXTRACT_PRIVATE respectively EXTRACT_STATIC tags are set to YES.
# Note: This will also disable the warnings about undocumented members that are
# normally produced when WARNINGS is set to YES.
# The default value is: NO.

EXTRACT_ALL            = YES

# If the EXTRACT_PRIVATE tag is set to YES, all private members of a class will
# be included in the documentation.
# The default value is: NO.

EXTRACT_PRIVATE        = YES

# If the EXTRACT_PRIV_VIRTUAL tag is set to YES, documented private virtual
# methods of a class will be included in the documentation.
# The default value is: NO.

EXTRACT_PRIV_VIRTUAL   = YES

# If the EXTRACT_PACKAGE tag is set to YES, all members with package or internal
# scope will be included in the documentation.
# The default value is: NO.

EXTRACT_PACKAGE        = YES

# If the EXTRACT_STATIC tag is set to YES, all static members of a file will be
# included in the documentation.
# The default value is: NO.

EXTRACT_STATIC         = YES

# If the EXTRACT_LOCAL_CLASSES tag is set to YES, classes (and structs) defined
# locally in source files will be included in the documentation. If set to NO,
# only classes defined in header files are included. Does not have any effect
# for Java sources.
# The default value is: YES.

EXTRACT_LOCAL_CLASSES  = YES

# This flag is only useful for Objective-C code. If set to YES, local methods,
# which are defined in the implementation section but not in the interface are
# included in the documentation. If set to NO, only methods in the interface are
# included.
# The default value is: NO.

EXTRACT_LOCAL_METHODS  = YES

# If this flag is set to YES, the members of anonymous namespaces will be
# extracted and appear in the documentation as a namespace called
# 'anonymous_namespace{file}', where file will be replaced with the base name of
# the file that contains the anonymous namespace. By default anonymous namespace
# are hidden.
# The default value is: NO.

EXTRACT_ANON_NSPACES   = YES

# If this flag is set to YES, the name of an unnamed parameter in a declaration
# will be determined by the corresponding definition. By default unnamed
# parameters remain unnamed in the output.
# The default value is: YES.

RESOLVE_UNNAMED_PARAMS = YES

# If the HIDE_UNDOC_MEMBERS tag is set to YES, doxygen will hide all
# undocumented members inside documented classes or files. If set to NO these
# members will be included in the various overviews, but no documentation
# section is generated. This option has no effect if EXTRACT_ALL is enabled.
# The default value is: NO.

HIDE_UNDOC_MEMBERS     = YES

# If the HIDE_UNDOC_CLASSES tag is set to YES, doxygen will hide all
# undocumented classes that are normally visible in the class hierarchy. If set
# to NO, these classes will be included in the various overviews. This option
# will also hide undocumented C++ concepts if enabled. This option has no effect
# if EXTRACT_ALL is enabled.
# The default value is: NO.

HIDE_UNDOC_CLASSES     = YES

# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, doxygen will hide all friend
# declarations. If set to NO, these declarations will be included in the
# documentation.
# The default value is: NO.

HIDE_FRIEND_COMPOUNDS  = YES

# If the HIDE_IN_BODY_DOCS tag is set to YES, doxygen will hide any
# documentation blocks found inside the body of a function. If set to NO, these
# blocks will be appended to the function's detailed documentation block.
# The default value is: NO.

HIDE_IN_BODY_DOCS      = NO

# The INTERNAL_DOCS tag determines if documentation that is typed after a
# \internal command is included. If the tag is set to NO then the documentation
# will be excluded. Set it to YES to include the internal documentation.
# The default value is: NO.

INTERNAL_DOCS          = NO

# With the correct setting of option CASE_SENSE_NAMES doxygen will better be
# able to match the capabilities of the underlying filesystem. In case the
# filesystem is case sensitive (i.e. it supports files in the same directory
# whose names only differ in casing), the option must be set to YES to properly
# deal with such files in case they appear in the input. For filesystems that
# are not case sensitive the option should be set to NO to properly deal with
# output files written for symbols that only differ in casing, such as for two
# classes, one named CLASS and the other named Class, and to also support
# references to files without having to specify the exact matching casing. On
# Windows (including Cygwin) and MacOS, users should typically set this option
# to NO, whereas on Linux or other Unix flavors it should typically be set to
# YES.
# Possible values are: SYSTEM, NO and YES.
# The default value is: SYSTEM.

CASE_SENSE_NAMES       = NO

# If the HIDE_SCOPE_NAMES tag is set to NO then doxygen will show members with
# their full class and namespace scopes in the documentation. If set to YES, the
# scope will be hidden.
# The default value is: NO.

HIDE_SCOPE_NAMES       = NO

# If the HIDE_COMPOUND_REFERENCE tag is set to NO (default) then doxygen will
# append additional text to a page's title, such as Class Reference. If set to
# YES the compound reference will be hidden.
# The default value is: NO.

HIDE_COMPOUND_REFERENCE= NO

# If the SHOW_HEADERFILE tag is set to YES then the documentation for a class
# will show which file needs to be included to use the class.
# The default value is: YES.

SHOW_HEADERFILE        = YES

# If the SHOW_INCLUDE_FILES tag is set to YES then doxygen will put a list of
# the files that are included by a file in the documentation of that file.
# The default value is: YES.

SHOW_INCLUDE_FILES     = YES

# If the SHOW_GROUPED_MEMB_INC tag is set to YES then Doxygen will add for each
# grouped member an include statement to the documentation, telling the reader
# which file to include in order to use the member.
# The default value is: NO.

SHOW_GROUPED_MEMB_INC  = NO

# If the FORCE_LOCAL_INCLUDES tag is set to YES then doxygen will list include
# files with double quotes in the documentation rather than with sharp brackets.
# The default value is: NO.

FORCE_LOCAL_INCLUDES   = NO

# If the INLINE_INFO tag is set to YES then a tag [inline] is inserted in the
# documentation for inline members.
# The default value is: YES.

INLINE_INFO            = YES

# If the SORT_MEMBER_DOCS tag is set to YES then doxygen will sort the
# (detailed) documentation of file and class members alphabetically by member
# name. If set to NO, the members will appear in declaration order.
# The default value is: YES.

SORT_MEMBER_DOCS       = YES

# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the brief
# descriptions of file, namespace and class members alphabetically by member
# name. If set to NO, the members will appear in declaration order. Note that
# this will also influence the order of the classes in the class list.
# The default value is: NO.

SORT_BRIEF_DOCS        = NO

# If the SORT_MEMBERS_CTORS_1ST tag is set to YES then doxygen will sort the
# (brief and detailed) documentation of class members so that constructors and
# destructors are listed first. If set to NO the constructors will appear in the
# respective orders defined by SORT_BRIEF_DOCS and SORT_MEMBER_DOCS.
# Note: If SORT_BRIEF_DOCS is set to NO this option is ignored for sorting brief
# member documentation.
# Note: If SORT_MEMBER_DOCS is set to NO this option is ignored for sorting
# detailed member documentation.
# The default value is: NO.

SORT_MEMBERS_CTORS_1ST = NO

# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the hierarchy
# of group names into alphabetical order. If set to NO the group names will
# appear in their defined order.
# The default value is: NO.

SORT_GROUP_NAMES       = NO

# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be sorted by
# fully-qualified names, including namespaces. If set to NO, the class list will
# be sorted only by class name, not including the namespace part.
# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
# Note: This option applies only to the class list, not to the alphabetical
# list.
# The default value is: NO.

SORT_BY_SCOPE_NAME     = NO

# If the STRICT_PROTO_MATCHING option is enabled and doxygen fails to do proper
# type resolution of all parameters of a function it will reject a match between
# the prototype and the implementation of a member function even if there is
# only one candidate or it is obvious which candidate to choose by doing a
# simple string match. By disabling STRICT_PROTO_MATCHING doxygen will still
# accept a match between prototype and implementation in such cases.
# The default value is: NO.

STRICT_PROTO_MATCHING  = NO

# The GENERATE_TODOLIST tag can be used to enable (YES) or disable (NO) the todo
# list. This list is created by putting \todo commands in the documentation.
# The default value is: YES.

GENERATE_TODOLIST      = YES

# The GENERATE_TESTLIST tag can be used to enable (YES) or disable (NO) the test
# list. This list is created by putting \test commands in the documentation.
# The default value is: YES.

GENERATE_TESTLIST      = YES

# The GENERATE_BUGLIST tag can be used to enable (YES) or disable (NO) the bug
# list. This list is created by putting \bug commands in the documentation.
# The default value is: YES.

GENERATE_BUGLIST       = YES

# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or disable (NO)
# the deprecated list. This list is created by putting \deprecated commands in
# the documentation.
# The default value is: YES.

GENERATE_DEPRECATEDLIST= YES

# The ENABLED_SECTIONS tag can be used to enable conditional documentation
# sections, marked by \if <section_label> ... \endif and \cond <section_label>
# ... \endcond blocks.

ENABLED_SECTIONS       =

# The MAX_INITIALIZER_LINES tag determines the maximum number of lines that the
# initial value of a variable or macro / define can have for it to appear in the
# documentation. If the initializer consists of more lines than specified here
# it will be hidden. Use a value of 0 to hide initializers completely. The
# appearance of the value of individual variables and macros / defines can be
# controlled using \showinitializer or \hideinitializer command in the
# documentation regardless of this setting.
# Minimum value: 0, maximum value: 10000, default value: 30.

MAX_INITIALIZER_LINES  = 30

# Set the SHOW_USED_FILES tag to NO to disable the list of files generated at
# the bottom of the documentation of classes and structs. If set to YES, the
# list will mention the files that were used to generate the documentation.
# The default value is: YES.

SHOW_USED_FILES        = YES

# Set the SHOW_FILES tag to NO to disable the generation of the Files page. This
# will remove the Files entry from the Quick Index and from the Folder Tree View
# (if specified).
# The default value is: YES.

SHOW_FILES             = YES

# Set the SHOW_NAMESPACES tag to NO to disable the generation of the Namespaces
# page. This will remove the Namespaces entry from the Quick Index and from the
# Folder Tree View (if specified).
# The default value is: YES.

SHOW_NAMESPACES        = YES

# The FILE_VERSION_FILTER tag can be used to specify a program or script that
# doxygen should invoke to get the current version for each file (typically from
# the version control system). Doxygen will invoke the program by executing (via
# popen()) the command command input-file, where command is the value of the
# FILE_VERSION_FILTER tag, and input-file is the name of an input file provided
# by doxygen. Whatever the program writes to standard output is used as the file
# version. For an example see the documentation.

FILE_VERSION_FILTER    =

# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed
# by doxygen. The layout file controls the global structure of the generated
# output files in an output format independent way. To create the layout file
# that represents doxygen's defaults, run doxygen with the -l option. You can
# optionally specify a file name after the option, if omitted DoxygenLayout.xml
# will be used as the name of the layout file. See also section "Changing the
# layout of pages" for information.
#
# Note that if you run doxygen from a directory containing a file called
# DoxygenLayout.xml, doxygen will parse it automatically even if the LAYOUT_FILE
# tag is left empty.

LAYOUT_FILE            =

# The CITE_BIB_FILES tag can be used to specify one or more bib files containing
# the reference definitions. This must be a list of .bib files. The .bib
# extension is automatically appended if omitted. This requires the bibtex tool
# to be installed. See also https://en.wikipedia.org/wiki/BibTeX for more info.
# For LaTeX the style of the bibliography can be controlled using
# LATEX_BIB_STYLE. To use this feature you need bibtex and perl available in the
# search path. See also \cite for info how to create references.

CITE_BIB_FILES         =

#---------------------------------------------------------------------------
# Configuration options related to warning and progress messages
#---------------------------------------------------------------------------

# The QUIET tag can be used to turn on/off the messages that are generated to
# standard output by doxygen. If QUIET is set to YES this implies that the
# messages are off.
# The default value is: NO.

QUIET                  = NO

# The WARNINGS tag can be used to turn on/off the warning messages that are
# generated to standard error (stderr) by doxygen. If WARNINGS is set to YES
# this implies that the warnings are on.
#
# Tip: Turn warnings on while writing the documentation.
# The default value is: YES.

WARNINGS               = YES

# If the WARN_IF_UNDOCUMENTED tag is set to YES then doxygen will generate
# warnings for undocumented members. If EXTRACT_ALL is set to YES then this flag
# will automatically be disabled.
# The default value is: YES.

WARN_IF_UNDOCUMENTED   = YES

# If the WARN_IF_DOC_ERROR tag is set to YES, doxygen will generate warnings for
# potential errors in the documentation, such as documenting some parameters in
# a documented function twice, or documenting parameters that don't exist or
# using markup commands wrongly.
# The default value is: YES.

WARN_IF_DOC_ERROR      = YES

# If WARN_IF_INCOMPLETE_DOC is set to YES, doxygen will warn about incomplete
# function parameter documentation. If set to NO, doxygen will accept that some
# parameters have no documentation without warning.
# The default value is: YES.

WARN_IF_INCOMPLETE_DOC = YES

# This WARN_NO_PARAMDOC option can be enabled to get warnings for functions that
# are documented, but have no documentation for their parameters or return
# value. If set to NO, doxygen will only warn about wrong parameter
# documentation, but not about the absence of documentation. If EXTRACT_ALL is
# set to YES then this flag will automatically be disabled. See also
# WARN_IF_INCOMPLETE_DOC
# The default value is: NO.

WARN_NO_PARAMDOC       = NO

# If WARN_IF_UNDOC_ENUM_VAL option is set to YES, doxygen will warn about
# undocumented enumeration values. If set to NO, doxygen will accept
# undocumented enumeration values. If EXTRACT_ALL is set to YES then this flag
# will automatically be disabled.
# The default value is: NO.

WARN_IF_UNDOC_ENUM_VAL = NO

# If the WARN_AS_ERROR tag is set to YES then doxygen will immediately stop when
# a warning is encountered. If the WARN_AS_ERROR tag is set to FAIL_ON_WARNINGS
# then doxygen will continue running as if WARN_AS_ERROR tag is set to NO, but
# at the end of the doxygen process doxygen will return with a non-zero status.
# If the WARN_AS_ERROR tag is set to FAIL_ON_WARNINGS_PRINT then doxygen behaves
# like FAIL_ON_WARNINGS but in case no WARN_LOGFILE is defined doxygen will not
# write the warning messages in between other messages but write them at the end
# of a run, in case a WARN_LOGFILE is defined the warning messages will be
# besides being in the defined file also be shown at the end of a run, unless
# the WARN_LOGFILE is defined as - i.e. standard output (stdout) in that case
# the behavior will remain as with the setting FAIL_ON_WARNINGS.
# Possible values are: NO, YES, FAIL_ON_WARNINGS and FAIL_ON_WARNINGS_PRINT.
# The default value is: NO.

WARN_AS_ERROR          = NO

# The WARN_FORMAT tag determines the format of the warning messages that doxygen
# can produce. The string should contain the $file, $line, and $text tags, which
# will be replaced by the file and line number from which the warning originated
# and the warning text. Optionally the format may contain $version, which will
# be replaced by the version of the file (if it could be obtained via
# FILE_VERSION_FILTER)
# See also: WARN_LINE_FORMAT
# The default value is: $file:$line: $text.

WARN_FORMAT            = "$file:$line: $text"

# In the $text part of the WARN_FORMAT command it is possible that a reference
# to a more specific place is given. To make it easier to jump to this place
# (outside of doxygen) the user can define a custom "cut" / "paste" string.
# Example:
# WARN_LINE_FORMAT = "'vi $file +$line'"
# See also: WARN_FORMAT
# The default value is: at line $line of file $file.

WARN_LINE_FORMAT       = "at line $line of file $file"

# The WARN_LOGFILE tag can be used to specify a file to which warning and error
# messages should be written. If left blank the output is written to standard
# error (stderr). In case the file specified cannot be opened for writing the
# warning and error messages are written to standard error. When as file - is
# specified the warning and error messages are written to standard output
# (stdout).

WARN_LOGFILE           =

#---------------------------------------------------------------------------
# Configuration options related to the input files
#---------------------------------------------------------------------------

# The INPUT tag is used to specify the files and/or directories that contain
# documented source files. You may enter file names like myfile.cpp or
# directories like /usr/src/myproject. Separate the files or directories with
# spaces. See also FILE_PATTERNS and EXTENSION_MAPPING
# Note: If this tag is empty the current directory is searched.

INPUT                  = cgl.c \
                         include/cgl.h

# This tag can be used to specify the character encoding of the source files
# that doxygen parses. Internally doxygen uses the UTF-8 encoding. Doxygen uses
# libiconv (or the iconv built into libc) for the transcoding. See the libiconv
# documentation (see:
# https://www.gnu.org/software/libiconv/) for the list of possible encodings.
# See also: INPUT_FILE_ENCODING
# The default value is: UTF-8.

INPUT_ENCODING         = UTF-8

# This tag can be used to specify the character encoding of the source files
# that doxygen parses The INPUT_FILE_ENCODING tag can be used to specify
# character encoding on a per file pattern basis. Doxygen will compare the file
# name with each pattern and apply the encoding instead of the default
# INPUT_ENCODING) if there is a match. The character encodings are a list of the
# form: pattern=encoding (like *.php=ISO-8859-1). See cfg_input_encoding
# "INPUT_ENCODING" for further information on supported encodings.

INPUT_FILE_ENCODING    =

# If the value of the INPUT tag contains directories, you can use the
# FILE_PATTERNS tag to specify one or more wildcard patterns (like *.cpp and
# *.h) to filter out the source-files in the directories.
#
# Note that for custom extensions or not directly supported extensions you also
# need to set EXTENSION_MAPPING for the extension otherwise the files are not
# read by doxygen.
#
# Note the list of default checked file patterns might differ from the list of
# default file extension mappings.
#
# If left blank the following patterns are tested:*.c, *.cc, *.cxx, *.cpp,
# *.c++, *.java, *.ii, *.ixx, *.ipp, *.i++, *.inl, *.idl, *.ddl, *.odl, *.h,
# *.hh, *.hxx, *.hpp, *.h++, *.l, *.cs, *.d, *.php, *.php4, *.php5, *.phtml,
# *.inc, *.m, *.markdown, *.md, *.mm, *.dox (to be provided as doxygen C
# comment), *.py, *.pyw, *.f90, *.f95, *.f03, *.f08, *.f18, *.f, *.for, *.vhd,
# *.vhdl, *.ucf, *.qsf and *.ice.

FILE_PATTERNS          = *.c \
                         *.cc \
                         *.cxx \
                         *.cpp \
                         *.c++ \
                         *.java \
                         *.ii \
                         *.ixx \
                         *.ipp \
                         *.i++ \
                         *.inl \
                         *.idl \
                         *.ddl \
                         *.odl \
                         *.h \
                         *.hh \
                         *.hxx \
                         *.hpp \
                         *.h++ \
                         *.l \
                         *.cs \
                         *.d \
                         *.php \
                         *.php4 \
                         *.php5 \
                         *.phtml \
                         *.inc \
                         *.m \
                         *.markdown \
                         *.md \
                         *.mm \
                         *.dox \
                         *.py \
                         *.pyw \
                         *.f90 \
                         *.f95 \
                         *.f03 \
                         *.f08 \
                         *.f18 \
                         *.f \
                         *.for \
                         *.vhd \
                         *.vhdl \
                         *.ucf \
                         *.qsf \
                         *.ice

# The RECURSIVE tag can be used to specify whether or not subdirectories should
# be searched for input files as well.
# The default value is: NO.

RECURSIVE              = YES

# The EXCLUDE tag can be used to specify files and/or directories that should be
# excluded from the INPUT source files. This way you can easily exclude a
# subdirectory from a directory tree whose root is specified with the INPUT tag.
#
# Note that relative paths are relative to the directory from which doxygen is
# run.

EXCLUDE                =

# The EXCLUDE_SYMLINKS tag can be used to select whether or not files or
# directories that are symbolic links (a Unix file system feature) are excluded
# from the input.
# The default value is: NO.

EXCLUDE_SYMLINKS       = NO

# If the value of the INPUT tag contains directories, you can use the
# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude
# certain files from those directories.
#
# Note that the wildcards are matched against the file with absolute path, so to
# exclude all test directories for example use the pattern */test/*

EXCLUDE_PATTERNS       =

# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names
# (namespaces, classes, functions, etc.) that should be excluded from the
# output. The symbol name can be a fully qualified name, a word, or if the
# wildcard * is used, a substring. Examples: ANamespace, AClass,
# ANamespace::AClass, ANamespace::*Test

EXCLUDE_SYMBOLS        =

# The EXAMPLE_PATH tag can be used to specify one or more files or directories
# that contain example code fragments that are included (see the \include
# command).

EXAMPLE_PATH           =

# If the value of the EXAMPLE_PATH tag contains directories, you can use the
# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp and
# *.h) to filter out the source-files in the directories. If left blank all
# files are included.

EXAMPLE_PATTERNS       = *

# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be
# searched for input files to be used with the \include or \dontinclude commands
# irrespective of the value of the RECURSIVE tag.
# The default value is: NO.

EXAMPLE_RECURSIVE      = NO

# The IMAGE_PATH tag can be used to specify one or more files or directories
# that contain images that are to be included in the documentation (see the
# \image command).

IMAGE_PATH             =

# The INPUT_FILTER tag can be used to specify a program that doxygen should
# invoke to filter for each input file. Doxygen will invoke the filter program
# by executing (via popen()) the command:
#
# <filter> <input-file>
#
# where <filter> is the value of the INPUT_FILTER tag, and <input-file> is the
# name of an input file. Doxygen will then use the output that the filter
# program writes to standard output. If FILTER_PATTERNS is specified, this tag
# will be ignored.
#
# Note that the filter must not add or remove lines; it is applied before the
# code is scanned, but not when the output code is generated. If lines are added
# or removed, the anchors will not be placed correctly.
#
# Note that doxygen will use the data processed and written to standard output
# for further processing, therefore nothing else, like debug statements or used
# commands (so in case of a Windows batch file always use @echo OFF), should be
# written to standard output.
#
# Note that for custom extensions or not directly supported extensions you also
# need to set EXTENSION_MAPPING for the extension otherwise the files are not
# properly processed by doxygen.

INPUT_FILTER           =

# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern
# basis. Doxygen will compare the file name with each pattern and apply the
# filter if there is a match. The filters are a list of the form: pattern=filter
# (like *.cpp=my_cpp_filter). See INPUT_FILTER for further information on how
# filters are used. If the FILTER_PATTERNS tag is empty or if none of the
# patterns match the file name, INPUT_FILTER is applied.
#
# Note that for custom extensions or not directly supported extensions you also
# need to set EXTENSION_MAPPING for the extension otherwise the files are not
# properly processed by doxygen.

FILTER_PATTERNS        =

# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using
# INPUT_FILTER) will also be used to filter the input files that are used for
# producing the source files to browse (i.e. when SOURCE_BROWSER is set to YES).
# The default value is: NO.

FILTER_SOURCE_FILES    = NO

# The FILTER_SOURCE_PATTERNS tag can be used to specify source filters per file
# pattern. A pattern will override the setting for FILTER_PATTERN (if any) and
# it is also possible to disable source filtering for a specific pattern using
# *.ext= (so without naming a filter).
# This tag requires that the tag FILTER_SOURCE_FILES is set to YES.

FILTER_SOURCE_PATTERNS =

# If the USE_MDFILE_AS_MAINPAGE tag refers to the name of a markdown file that
# is part of the input, its contents will be placed on the main page
# (index.html). This can be useful if you have a project on for instance GitHub
# and want to reuse the introduction page also for the doxygen output.

USE_MDFILE_AS_MAINPAGE =

# The Fortran standard specifies that for fixed formatted Fortran code all
# characters from position 72 are to be considered as comment. A common
# extension is to allow longer lines before the automatic comment starts. The
# setting FORTRAN_COMMENT_AFTER will also make it possible that longer lines can
# be processed before the automatic comment starts.
# Minimum value: 7, maximum value: 10000, default value: 72.

FORTRAN_COMMENT_AFTER  = 72

#---------------------------------------------------------------------------
# Configuration options related to source browsing
#---------------------------------------------------------------------------

# If the SOURCE_BROWSER tag is set to YES then a list of source files will be
# generated. Documented entities will be cross-referenced with these sources.
#
# Note: To get rid of all source code in the generated output, make sure that
# also VERBATIM_HEADERS is set to NO.
# The default value is: NO.

SOURCE_BROWSER         = YES

# Setting the INLINE_SOURCES tag to YES will include the body of functions,
# classes and enums directly into the documentation.
# The default value is: NO.

INLINE_SOURCES         = YES

# Setting the STRIP_CODE_COMMENTS tag to YES will instruct doxygen to hide any
# special comment blocks from generated source code fragments. Normal C, C++ and
# Fortran comments will always remain visible.
# The default value is: YES.

STRIP_CODE_COMMENTS    = YES

# If the REFERENCED_BY_RELATION tag is set to YES then for each documented
# entity all documented functions referencing it will be listed.
# The default value is: NO.

REFERENCED_BY_RELATION = NO

# If the REFERENCES_RELATION tag is set to YES then for each documented function
# all documented entities called/used by that function will be listed.
# The default value is: NO.

REFERENCES_RELATION    = NO

# If the REFERENCES_LINK_SOURCE tag is set to YES and SOURCE_BROWSER tag is set
# to YES then the hyperlinks from functions in REFERENCES_RELATION and
# REFERENCED_BY_RELATION lists will link to the source code. Otherwise they will
# link to the documentation.
# The default value is: YES.

REFERENCES_LINK_SOURCE = YES

# If SOURCE_TOOLTIPS is enabled (the default) then hovering a hyperlink in the
# source code will show a tooltip with additional information such as prototype,
# brief description and links to the definition and documentation. Since this
# will make the HTML file larger and loading of large files a bit slower, you
# can opt to disable this feature.
# The default value is: YES.
# This tag requires that the tag SOURCE_BROWSER is set to YES.

SOURCE_TOOLTIPS        = YES

# If the USE_HTAGS tag is set to YES then the references to source code will
# point to the HTML generated by the htags(1) tool instead of doxygen built-in
# source browser. The htags tool is part of GNU's global source tagging system
# (see https://www.gnu.org/software/global/global.html). You will need version
# 4.8.6 or higher.
#
# To use it do the following:
# - Install the latest version of global
# - Enable SOURCE_BROWSER and USE_HTAGS in the configuration file
# - Make sure the INPUT points to the root of the source tree
# - Run doxygen as normal
#
# Doxygen will invoke htags (and that will in turn invoke gtags), so these
# tools must be available from the command line (i.e. in the search path).
#
# The result: instead of the source browser generated by doxygen, the links to
# source code will now point to the output of htags.
# The default value is: NO.
# This tag requires that the tag SOURCE_BROWSER is set to YES.

USE_HTAGS              = NO

# If the VERBATIM_HEADERS tag is set the YES then doxygen will generate a
# verbatim copy of the header file for each class for which an include is
# specified. Set to NO to disable this.
# See also: Section \class.
# The default value is: YES.

VERBATIM_HEADERS       = YES

# If the CLANG_ASSISTED_PARSING tag is set to YES then doxygen will use the
# clang parser (see:
# http://clang.llvm.org/) for more accurate parsing at the cost of reduced
# performance. This can be particularly helpful with template rich C++ code for
# which doxygen's built-in parser lacks the necessary type information.
# Note: The availability of this option depends on whether or not doxygen was
# generated with the -Duse_libclang=ON option for CMake.
# The default value is: NO.

CLANG_ASSISTED_PARSING = NO

# If the CLANG_ASSISTED_PARSING tag is set to YES and the CLANG_ADD_INC_PATHS
# tag is set to YES then doxygen will add the directory of each input to the
# include path.
# The default value is: YES.
# This tag requires that the tag CLANG_ASSISTED_PARSING is set to YES.

CLANG_ADD_INC_PATHS    = YES

# If clang assisted parsing is enabled you can provide the compiler with command
# line options that you would normally use when invoking the compiler. Note that
# the include paths will already be set by doxygen for the files and directories
# specified with INPUT and INCLUDE_PATH.
# This tag requires that the tag CLANG_ASSISTED_PARSING is set to YES.

CLANG_OPTIONS          =

# If clang assisted parsing is enabled you can provide the clang parser with the
# path to the directory containing a file called compile_commands.json. This
# file is the compilation database (see:
# http://clang.llvm.org/docs/HowToSetupToolingForLLVM.html) containing the
# options used when the source files were built. This is equivalent to
# specifying the -p option to a clang tool, such as clang-check. These options
# will then be passed to the parser. Any options specified with CLANG_OPTIONS
# will be added as well.
# Note: The availability of this option depends on whether or not doxygen was
# generated with the -Duse_libclang=ON option for CMake.

CLANG_DATABASE_PATH    =

#---------------------------------------------------------------------------
# Configuration options related to the alphabetical class index
#---------------------------------------------------------------------------

# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index of all
# compounds will be generated. Enable this if the project contains a lot of
# classes, structs, unions or interfaces.
# The default value is: YES.

ALPHABETICAL_INDEX     = YES

# The IGNORE_PREFIX tag can be used to specify a prefix (or a list of prefixes)
# that should be ignored while generating the index headers. The IGNORE_PREFIX
# tag works for classes, function and member names. The entity will be placed in
# the alphabetical list under the first letter of the entity name that remains
# after removing the prefix.
# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.

IGNORE_PREFIX          =

#---------------------------------------------------------------------------
# Configuration options related to the HTML output
#---------------------------------------------------------------------------

# If the GENERATE_HTML tag is set to YES, doxygen will generate HTML output
# The default value is: YES.

GENERATE_HTML          = YES

# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it.
# The default directory is: html.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_OUTPUT            = html

# The HTML_FILE_EXTENSION tag can be used to specify the file extension for each
# generated HTML page (for example: .htm, .php, .asp).
# The default value is: .html.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_FILE_EXTENSION    = .html

# The HTML_HEADER tag can be used to specify a user-defined HTML header file for
# each generated HTML page. If the tag is left blank doxygen will generate a
# standard header.
#
# To get valid HTML the header file that includes any scripts and style sheets
# that doxygen needs, which is dependent on the configuration options used (e.g.
# the setting GENERATE_TREEVIEW). It is highly recommended to start with a
# default header using
# doxygen -w html new_header.html new_footer.html new_stylesheet.css
# YourConfigFile
# and then modify the file new_header.html. See also section "Doxygen usage"
# for information on how to generate the default header that doxygen normally
# uses.
# Note: The header is subject to change so you typically have to regenerate the
# default header when upgrading to a newer version of doxygen. For a description
# of the possible markers and block names see the documentation.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_HEADER            =

# The HTML_FOOTER tag can be used to specify a user-defined HTML footer for each
# generated HTML page. If the tag is left blank doxygen will generate a standard
# footer. See HTML_HEADER for more information on how to generate a default
# footer and what special commands can be used inside the footer. See also
# section "Doxygen usage" for information on how to generate the default footer
# that doxygen normally uses.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_FOOTER            =

# The HTML_STYLESHEET tag can be used to specify a user-defined cascading style
# sheet that is used by each HTML page. It can be used to fine-tune the look of
# the HTML output. If left blank doxygen will generate a default style sheet.
# See also section "Doxygen usage" for information on how to generate the style
# sheet that doxygen normally uses.
# Note: It is recommended to use HTML_EXTRA_STYLESHEET instead of this tag, as
# it is more robust and this tag (HTML_STYLESHEET) will in the future become
# obsolete.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_STYLESHEET        =

# The HTML_EXTRA_STYLESHEET tag can be used to specify additional user-defined
# cascading style sheets that are included after the standard style sheets
# created by doxygen. Using this option one can overrule certain style aspects.
# This is preferred over using HTML_STYLESHEET since it does not replace the
# standard style sheet and is therefore more robust against future updates.
# Doxygen will copy the style sheet files to the output directory.
# Note: The order of the extra style sheet files is of importance (e.g. the last
# style sheet in the list overrules the setting of the previous ones in the
# list).
# Note: Since the styling of scrollbars can currently not be overruled in
# Webkit/Chromium, the styling will be left out of the default doxygen.css if
# one or more extra stylesheets have been specified. So if scrollbar
# customization is desired it has to be added explicitly. For an example see the
# documentation.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_EXTRA_STYLESHEET  = docs-style/doxygen-awesome.css \
                         docs-style/doxygen-awesome-sidebar-only.css \
                         docs-style/doxygen-awesome-sidebar-only-darkmode-toggle.css

# The HTML_EXTRA_FILES tag can be used to specify one or more extra images or
# other source files which should be copied to the HTML output directory. Note
# that these files will be copied to the base HTML output directory. Use the
# $relpath^ marker in the HTML_HEADER and/or HTML_FOOTER files to load these
# files. In the HTML_STYLESHEET file, use the file name only. Also note that the
# files will be copied as-is; there are no commands or markers available.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_EXTRA_FILES       =

# The HTML_COLORSTYLE tag can be used to specify if the generated HTML output
# should be rendered with a dark or light theme.
# Possible values are: LIGHT always generate light mode output, DARK always
# generate dark mode output, AUTO_LIGHT automatically set the mode according to
# the user preference, use light mode if no preference is set (the default),
# AUTO_DARK automatically set the mode according to the user preference, use
# dark mode if no preference is set and TOGGLE allow to user to switch between
# light and dark mode via a button.
# The default value is: AUTO_LIGHT.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_COLORSTYLE        = AUTO_LIGHT

# The HTML_COLORSTYLE_HUE tag controls the color of the HTML output. Doxygen
# will adjust the colors in the style sheet and background images according to
# this color. Hue is specified as an angle on a color-wheel, see
# https://en.wikipedia.org/wiki/Hue for more information. For instance the value
# 0 represents red, 60 is yellow, 120 is green, 180 is cyan, 240 is blue, 300
# purple, and 360 is red again.
# Minimum value: 0, maximum value: 359, default value: 220.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_COLORSTYLE_HUE    = 220

# The HTML_COLORSTYLE_SAT tag controls the purity (or saturation) of the colors
# in the HTML output. For a value of 0 the output will use gray-scales only. A
# value of 255 will produce the most vivid colors.
# Minimum value: 0, maximum value: 255, default value: 100.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_COLORSTYLE_SAT    = 100

# The HTML_COLORSTYLE_GAMMA tag controls the gamma correction applied to the
# luminance component of the colors in the HTML output. Values below 100
# gradually make the output lighter, whereas values above 100 make the output
# darker. The value divided by 100 is the actual gamma applied, so 80 represents
# a gamma of 0.8, The value 220 represents a gamma of 2.2, and 100 does not
# change the gamma.
# Minimum value: 40, maximum value: 240, default value: 80.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_COLORSTYLE_GAMMA  = 80

# If the HTML_DYNAMIC_MENUS tag is set to YES then the generated HTML
# documentation will contain a main index with vertical navigation menus that
# are dynamically created via JavaScript. If disabled, the navigation index will
# consists of multiple levels of tabs that are statically embedded in every HTML
# page. Disable this option to support browsers that do not have JavaScript,
# like the Qt help browser.
# The default value is: YES.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_DYNAMIC_MENUS     = YES

# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML
# documentation will contain sections that can be hidden and shown after the
# page has loaded.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_DYNAMIC_SECTIONS  = NO

# With HTML_INDEX_NUM_ENTRIES one can control the preferred number of entries
# shown in the various tree structured indices initially; the user can expand
# and collapse entries dynamically later on. Doxygen will expand the tree to
# such a level that at most the specified number of entries are visible (unless
# a fully collapsed tree already exceeds this amount). So setting the number of
# entries 1 will produce a full collapsed tree by default. 0 is a special value
# representing an infinite number of entries and will result in a full expanded
# tree by default.
# Minimum value: 0, maximum value: 9999, default value: 100.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_INDEX_NUM_ENTRIES = 100

# If the GENERATE_DOCSET tag is set to YES, additional index files will be
# generated that can be used as input for Apple's Xcode 3 integrated development
# environment (see:
# https://developer.apple.com/xcode/), introduced with OSX 10.5 (Leopard). To
# create a documentation set, doxygen will generate a Makefile in the HTML
# output directory. Running make will produce the docset in that directory and
# running make install will install the docset in
# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find it at
# startup. See https://developer.apple.com/library/archive/featuredarticles/Doxy
# genXcode/_index.html for more information.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_DOCSET        = NO

# This tag determines the name of the docset feed. A documentation feed provides
# an umbrella under which multiple documentation sets from a single provider
# (such as a company or product suite) can be grouped.
# The default value is: Doxygen generated docs.
# This tag requires that the tag GENERATE_DOCSET is set to YES.

DOCSET_FEEDNAME        = "Doxygen generated docs"

# This tag determines the URL of the docset feed. A documentation feed provides
# an umbrella under which multiple documentation sets from a single provider
# (such as a company or product suite) can be grouped.
# This tag requires that the tag GENERATE_DOCSET is set to YES.

DOCSET_FEEDURL         =

# This tag specifies a string that should uniquely identify the documentation
# set bundle. This should be a reverse domain-name style string, e.g.
# com.mycompany.MyDocSet. Doxygen will append .docset to the name.
# The default value is: org.doxygen.Project.
# This tag requires that the tag GENERATE_DOCSET is set to YES.

DOCSET_BUNDLE_ID       = org.doxygen.Project

# The DOCSET_PUBLISHER_ID tag specifies a string that should uniquely identify
# the documentation publisher. This should be a reverse domain-name style
# string, e.g. com.mycompany.MyDocSet.documentation.
# The default value is: org.doxygen.Publisher.
# This tag requires that the tag GENERATE_DOCSET is set to YES.

DOCSET_PUBLISHER_ID    = org.doxygen.Publisher

# The DOCSET_PUBLISHER_NAME tag identifies the documentation publisher.
# The default value is: Publisher.
# This tag requires that the tag GENERATE_DOCSET is set to YES.

DOCSET_PUBLISHER_NAME  = Publisher

# If the GENERATE_HTMLHELP tag is set to YES then doxygen generates three
# additional HTML index files: index.hhp, index.hhc, and index.hhk. The
# index.hhp is a project file that can be read by Microsoft's HTML Help Workshop
# on Windows. In the beginning of 2021 Microsoft took the original page, with
# a.o. the download links, offline the HTML help workshop was already many years
# in maintenance mode). You can download the HTML help workshop from the web
# archives at Installation executable (see:
# http://web.archive.org/web/20160201063255/http://download.microsoft.com/downlo
# ad/0/A/9/0A939EF6-E31C-430F-A3DF-DFAE7960D564/htmlhelp.exe).
#
# The HTML Help Workshop contains a compiler that can convert all HTML output
# generated by doxygen into a single compiled HTML file (.chm). Compiled HTML
# files are now used as the Windows 98 help format, and will replace the old
# Windows help format (.hlp) on all Windows platforms in the future. Compressed
# HTML files also contain an index, a table of contents, and you can search for
# words in the documentation. The HTML workshop also contains a viewer for
# compressed HTML files.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_HTMLHELP      = NO

# The CHM_FILE tag can be used to specify the file name of the resulting .chm
# file. You can add a path in front of the file if the result should not be
# written to the html output directory.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

CHM_FILE               =

# The HHC_LOCATION tag can be used to specify the location (absolute path
# including file name) of the HTML help compiler (hhc.exe). If non-empty,
# doxygen will try to run the HTML help compiler on the generated index.hhp.
# The file has to be specified with full path.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

HHC_LOCATION           =

# The GENERATE_CHI flag controls if a separate .chi index file is generated
# (YES) or that it should be included in the main .chm file (NO).
# The default value is: NO.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

GENERATE_CHI           = NO

# The CHM_INDEX_ENCODING is used to encode HtmlHelp index (hhk), content (hhc)
# and project file content.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

CHM_INDEX_ENCODING     =

# The BINARY_TOC flag controls whether a binary table of contents is generated
# (YES) or a normal table of contents (NO) in the .chm file. Furthermore it
# enables the Previous and Next buttons.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

BINARY_TOC             = NO

# The TOC_EXPAND flag can be set to YES to add extra items for group members to
# the table of contents of the HTML help documentation and to the tree view.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

TOC_EXPAND             = NO

# The SITEMAP_URL tag is used to specify the full URL of the place where the
# generated documentation will be placed on the server by the user during the
# deployment of the documentation. The generated sitemap is called sitemap.xml
# and placed on the directory specified by HTML_OUTPUT. In case no SITEMAP_URL
# is specified no sitemap is generated. For information about the sitemap
# protocol see https://www.sitemaps.org
# This tag requires that the tag GENERATE_HTML is set to YES.

SITEMAP_URL            =

# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and
# QHP_VIRTUAL_FOLDER are set, an additional index file will be generated that
# can be used as input for Qt's qhelpgenerator to generate a Qt Compressed Help
# (.qch) of the generated HTML documentation.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_QHP           = NO

# If the QHG_LOCATION tag is specified, the QCH_FILE tag can be used to specify
# the file name of the resulting .qch file. The path specified is relative to
# the HTML output folder.
# This tag requires that the tag GENERATE_QHP is set to YES.

QCH_FILE               =

# The QHP_NAMESPACE tag specifies the namespace to use when generating Qt Help
# Project output. For more information please see Qt Help Project / Namespace
# (see:
# https://doc.qt.io/archives/qt-4.8/qthelpproject.html#namespace).
# The default value is: org.doxygen.Project.
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_NAMESPACE          = org.doxygen.Project

# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating Qt
# Help Project output. For more information please see Qt Help Project / Virtual
# Folders (see:
# https://doc.qt.io/archives/qt-4.8/qthelpproject.html#virtual-folders).
# The default value is: doc.
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_VIRTUAL_FOLDER     = doc

# If the QHP_CUST_FILTER_NAME tag is set, it specifies the name of a custom
# filter to add. For more information please see Qt Help Project / Custom
# Filters (see:
# https://doc.qt.io/archives/qt-4.8/qthelpproject.html#custom-filters).
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_CUST_FILTER_NAME   =

# The QHP_CUST_FILTER_ATTRS tag specifies the list of the attributes of the
# custom filter to add. For more information please see Qt Help Project / Custom
# Filters (see:
# https://doc.qt.io/archives/qt-4.8/qthelpproject.html#custom-filters).
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_CUST_FILTER_ATTRS  =

# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this
# project's filter section matches. Qt Help Project / Filter Attributes (see:
# https://doc.qt.io/archives/qt-4.8/qthelpproject.html#filter-attributes).
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_SECT_FILTER_ATTRS  =

# The QHG_LOCATION tag can be used to specify the location (absolute path
# including file name) of Qt's qhelpgenerator. If non-empty doxygen will try to
# run qhelpgenerator on the generated .qhp file.
# This tag requires that the tag GENERATE_QHP is set to YES.

QHG_LOCATION           =

# If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files will be
# generated, together with the HTML files, they form an Eclipse help plugin. To
# install this plugin and make it available under the help contents menu in
# Eclipse, the contents of the directory containing the HTML and XML files needs
# to be copied into the plugins directory of eclipse. The name of the directory
# within the plugins directory should be the same as the ECLIPSE_DOC_ID value.
# After copying Eclipse needs to be restarted before the help appears.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_ECLIPSEHELP   = NO

# A unique identifier for the Eclipse help plugin. When installing the plugin
# the directory name containing the HTML and XML files should also have this
# name. Each documentation set should have its own identifier.
# The default value is: org.doxygen.Project.
# This tag requires that the tag GENERATE_ECLIPSEHELP is set to YES.

ECLIPSE_DOC_ID         = org.doxygen.Project

# If you want full control over the layout of the generated HTML pages it might
# be necessary to disable the index and replace it with your own. The
# DISABLE_INDEX tag can be used to turn on/off the condensed index (tabs) at top
# of each HTML page. A value of NO enables the index and the value YES disables
# it. Since the tabs in the index contain the same information as the navigation
# tree, you can set this option to YES if you also set GENERATE_TREEVIEW to YES.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

DISABLE_INDEX          = NO

# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index
# structure should be generated to display hierarchical information. If the tag
# value is set to YES, a side panel will be generated containing a tree-like
# index structure (just like the one that is generated for HTML Help). For this
# to work a browser that supports JavaScript, DHTML, CSS and frames is required
# (i.e. any modern browser). Windows users are probably better off using the
# HTML help feature. Via custom style sheets (see HTML_EXTRA_STYLESHEET) one can
# further fine tune the look of the index (see "Fine-tuning the output"). As an
# example, the default style sheet generated by doxygen has an example that
# shows how to put an image at the root of the tree instead of the PROJECT_NAME.
# Since the tree basically has the same information as the tab index, you could
# consider setting DISABLE_INDEX to YES when enabling this option.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_TREEVIEW      = YES

# When both GENERATE_TREEVIEW and DISABLE_INDEX are set to YES, then the
# FULL_SIDEBAR option determines if the side bar is limited to only the treeview
# area (value NO) or if it should extend to the full height of the window (value
# YES). Setting this to YES gives a layout similar to
# https://docs.readthedocs.io with more room for contents, but less room for the
# project logo, title, and description. If either GENERATE_TREEVIEW or
# DISABLE_INDEX is set to NO, this option has no effect.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

FULL_SIDEBAR           = NO

# The ENUM_VALUES_PER_LINE tag can be used to set the number of enum values that
# doxygen will group on one line in the generated HTML documentation.
#
# Note that a value of 0 will completely suppress the enum values from appearing
# in the overview section.
# Minimum value: 0, maximum value: 20, default value: 4.
# This tag requires that the tag GENERATE_HTML is set to YES.

ENUM_VALUES_PER_LINE   = 4

# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be used
# to set the initial width (in pixels) of the frame in which the tree is shown.
# Minimum value: 0, maximum value: 1500, default value: 250.
# This tag requires that the tag GENERATE_HTML is set to YES.

TREEVIEW_WIDTH         = 250

# If the EXT_LINKS_IN_WINDOW option is set to YES, doxygen will open links to
# external symbols imported via tag files in a separate window.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

EXT_LINKS_IN_WINDOW    = NO

# If the OBFUSCATE_EMAILS tag is set to YES, doxygen will obfuscate email
# addresses.
# The default value is: YES.
# This tag requires that the tag GENERATE_HTML is set to YES.

OBFUSCATE_EMAILS       = YES

# If the HTML_FORMULA_FORMAT option is set to svg, doxygen will use the pdf2svg
# tool (see https://github.com/dawbarton/pdf2svg) or inkscape (see
# https://inkscape.org) to generate formulas as SVG images instead of PNGs for
# the HTML output. These images will generally look nicer at scaled resolutions.
# Possible values are: png (the default) and svg (looks nicer but requires the
# pdf2svg or inkscape tool).
# The default value is: png.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_FORMULA_FORMAT    = png

# Use this tag to change the font size of LaTeX formulas included as images in
# the HTML documentation. When you change the font size after a successful
# doxygen run you need to manually remove any form_*.png images from the HTML
# output directory to force them to be regenerated.
# Minimum value: 8, maximum value: 50, default value: 10.
# This tag requires that the tag GENERATE_HTML is set to YES.

FORMULA_FONTSIZE       = 10

# The FORMULA_MACROFILE can contain LaTeX \newcommand and \renewcommand commands
# to create new LaTeX commands to be used in formulas as building blocks. See
# the section "Including formulas" for details.

FORMULA_MACROFILE      =

# Enable the USE_MATHJAX option to render LaTeX formulas using MathJax (see
# https://www.mathjax.org) which uses client side JavaScript for the rendering
# instead of using pre-rendered bitmaps. Use this if you do not have LaTeX
# installed or if you want to formulas look prettier in the HTML output. When
# enabled you may also need to install MathJax separately and configure the path
# to it using the MATHJAX_RELPATH option.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

USE_MATHJAX            = NO

# With MATHJAX_VERSION it is possible to specify the MathJax version to be used.
# Note that the different versions of MathJax have different requirements with
# regards to the different settings, so it is possible that also other MathJax
# settings have to be changed when switching between the different MathJax
# versions.
# Possible values are: MathJax_2 and MathJax_3.
# The default value is: MathJax_2.
# This tag requires that the tag USE_MATHJAX is set to YES.

MATHJAX_VERSION        = MathJax_2

# When MathJax is enabled you can set the default output format to be used for
# the MathJax output. For more details about the output format see MathJax
# version 2 (see:
# http://docs.mathjax.org/en/v2.7-latest/output.html) and MathJax version 3
# (see:
# http://docs.mathjax.org/en/latest/web/components/output.html).
# Possible values are: HTML-CSS (which is slower, but has the best
# compatibility. This is the name for Mathjax version 2, for MathJax version 3
# this will be translated into chtml), NativeMML (i.e. MathML. Only supported
# for NathJax 2. For MathJax version 3 chtml will be used instead.), chtml (This
# is the name for Mathjax version 3, for MathJax version 2 this will be
# translated into HTML-CSS) and SVG.
# The default value is: HTML-CSS.
# This tag requires that the tag USE_MATHJAX is set to YES.

MATHJAX_FORMAT         = HTML-CSS

# When MathJax is enabled you need to specify the location relative to the HTML
# output directory using the MATHJAX_RELPATH option. The destination directory
# should contain the MathJax.js script. For instance, if the mathjax directory
# is located at the same level as the HTML output directory, then
# MATHJAX_RELPATH should be ../mathjax. The default value points to the MathJax
# Content Delivery Network so you can quickly see the result without installing
# MathJax. However, it is strongly recommended to install a local copy of
# MathJax from https://www.mathjax.org before deployment. The default value is:
# - in case of MathJax version 2: https://cdn.jsdelivr.net/npm/mathjax@2
# - in case of MathJax version 3: https://cdn.jsdelivr.net/npm/mathjax@3
# This tag requires that the tag USE_MATHJAX is set to YES.

MATHJAX_RELPATH        =

# The MATHJAX_EXTENSIONS tag can be used to specify one or more MathJax
# extension names that should be enabled during MathJax rendering. For example
# for MathJax version 2 (see
# https://docs.mathjax.org/en/v2.7-latest/tex.html#tex-and-latex-extensions):
# MATHJAX_EXTENSIONS = TeX/AMSmath TeX/AMSsymbols
# For example for MathJax version 3 (see
# http://docs.mathjax.org/en/latest/input/tex/extensions/index.html):
# MATHJAX_EXTENSIONS = ams
# This tag requires that the tag USE_MATHJAX is set to YES.

MATHJAX_EXTENSIONS     =

# The MATHJAX_CODEFILE tag can be used to specify a file with javascript pieces
# of code that will be used on startup of the MathJax code. See the MathJax site
# (see:
# http://docs.mathjax.org/en/v2.7-latest/output.html) for more details. For an
# example see the documentation.
# This tag requires that the tag USE_MATHJAX is set to YES.

MATHJAX_CODEFILE       =

# When the SEARCHENGINE tag is enabled doxygen will generate a search box for
# the HTML output. The underlying search engine uses javascript and DHTML and
# should work on any modern browser. Note that when using HTML help
# (GENERATE_HTMLHELP), Qt help (GENERATE_QHP), or docsets (GENERATE_DOCSET)
# there is already a search function so this one should typically be disabled.
# For large projects the javascript based search engine can be slow, then
# enabling SERVER_BASED_SEARCH may provide a better solution. It is possible to
# search using the keyboard; to jump to the search box use <access key> + S
# (what the <access key> is depends on the OS and browser, but it is typically
# <CTRL>, <ALT>/<option>, or both). Inside the search box use the <cursor down
# key> to jump into the search results window, the results can be navigated
# using the <cursor keys>. Press <Enter> to select an item or <escape> to cancel
# the search. The filter options can be selected when the cursor is inside the
# search box by pressing <Shift>+<cursor down>. Also here use the <cursor keys>
# to select a filter and <Enter> or <escape> to activate or cancel the filter
# option.
# The default value is: YES.
# This tag requires that the tag GENERATE_HTML is set to YES.

SEARCHENGINE           = YES

# When the SERVER_BASED_SEARCH tag is enabled the search engine will be
# implemented using a web server instead of a web client using JavaScript. There
# are two flavors of web server based searching depending on the EXTERNAL_SEARCH
# setting. When disabled, doxygen will generate a PHP script for searching and
# an index file used by the script. When EXTERNAL_SEARCH is enabled the indexing
# and searching needs to be provided by external tools. See the section
# "External Indexing and Searching" for details.
# The default value is: NO.
# This tag requires that the tag SEARCHENGINE is set to YES.

SERVER_BASED_SEARCH    = NO

# When EXTERNAL_SEARCH tag is enabled doxygen will no longer generate the PHP
# script for searching. Instead the search results are written to an XML file
# which needs to be processed by an external indexer. Doxygen will invoke an
# external search engine pointed to by the SEARCHENGINE_URL option to obtain the
# search results.
#
# Doxygen ships with an example indexer (doxyindexer) and search engine
# (doxysearch.cgi) which are based on the open source search engine library
# Xapian (see:
# https://xapian.org/).
#
# See the section "External Indexing and Searching" for details.
# The default value is: NO.
# This tag requires that the tag SEARCHENGINE is set to YES.

EXTERNAL_SEARCH        = NO

# The SEARCHENGINE_URL should point to a search engine hosted by a web server
# which will return the search results when EXTERNAL_SEARCH is enabled.
#
# Doxygen ships with an example indexer (doxyindexer) and search engine
# (doxysearch.cgi) which are based on the open source search engine library
# Xapian (see:
# https://xapian.org/). See the section "External Indexing and Searching" for
# details.
# This tag requires that the tag SEARCHENGINE is set to YES.

SEARCHENGINE_URL       =

# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the unindexed
# search data is written to a file for indexing by an external tool. With the
# SEARCHDATA_FILE tag the name of this file can be specified.
# The default file is: searchdata.xml.
# This tag requires that the tag SEARCHENGINE is set to YES.

SEARCHDATA_FILE        = searchdata.xml

# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the
# EXTERNAL_SEARCH_ID tag can be used as an identifier for the project. This is
# useful in combination with EXTRA_SEARCH_MAPPINGS to search through multiple
# projects and redirect the results back to the right project.
# This tag requires that the tag SEARCHENGINE is set to YES.

EXTERNAL_SEARCH_ID     =

# The EXTRA_SEARCH_MAPPINGS tag can be used to enable searching through doxygen
# projects other than the one defined by this configuration file, but that are
# all added to the same external search index. Each project needs to have a
# unique id set via EXTERNAL_SEARCH_ID. The search mapping then maps the id of
# to a relative location where the documentation can be found. The format is:
# EXTRA_SEARCH_MAPPINGS = tagname1=loc1 tagname2=loc2 ...
# This tag requires that the tag SEARCHENGINE is set to YES.

EXTRA_SEARCH_MAPPINGS  =

#---------------------------------------------------------------------------
# Configuration options related to the LaTeX output
#---------------------------------------------------------------------------

# If the GENERATE_LATEX tag is set to YES, doxygen will generate LaTeX output.
# The default value is: YES.

GENERATE_LATEX         = YES

# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it.
# The default directory is: latex.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_OUTPUT           = latex

# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be
# invoked.
#
# Note that when not enabling USE_PDFLATEX the default is latex when enabling
# USE_PDFLATEX the default is pdflatex and when in the later case latex is
# chosen this is overwritten by pdflatex. For specific output languages the
# default can have been set differently, this depends on the implementation of
# the output language.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_CMD_NAME         =

# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to generate
# index for LaTeX.
# Note: This tag is used in the Makefile / make.bat.
# See also: LATEX_MAKEINDEX_CMD for the part in the generated output file
# (.tex).
# The default file is: makeindex.
# This tag requires that the tag GENERATE_LATEX is set to YES.

MAKEINDEX_CMD_NAME     = makeindex

# The LATEX_MAKEINDEX_CMD tag can be used to specify the command name to
# generate index for LaTeX. In case there is no backslash (\) as first character
# it will be automatically added in the LaTeX code.
# Note: This tag is used in the generated output file (.tex).
# See also: MAKEINDEX_CMD_NAME for the part in the Makefile / make.bat.
# The default value is: makeindex.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_MAKEINDEX_CMD    = makeindex

# If the COMPACT_LATEX tag is set to YES, doxygen generates more compact LaTeX
# documents. This may be useful for small projects and may help to save some
# trees in general.
# The default value is: NO.
# This tag requires that the tag GENERATE_LATEX is set to YES.

COMPACT_LATEX          = NO

# The PAPER_TYPE tag can be used to set the paper type that is used by the
# printer.
# Possible values are: a4 (210 x 297 mm), letter (8.5 x 11 inches), legal (8.5 x
# 14 inches) and executive (7.25 x 10.5 inches).
# The default value is: a4.
# This tag requires that the tag GENERATE_LATEX is set to YES.

PAPER_TYPE             = a4

# The EXTRA_PACKAGES tag can be used to specify one or more LaTeX package names
# that should be included in the LaTeX output. The package can be specified just
# by its name or with the correct syntax as to be used with the LaTeX
# \usepackage command. To get the times font for instance you can specify :
# EXTRA_PACKAGES=times or EXTRA_PACKAGES={times}
# To use the option intlimits with the amsmath package you can specify:
# EXTRA_PACKAGES=[intlimits]{amsmath}
# If left blank no extra packages will be included.
# This tag requires that the tag GENERATE_LATEX is set to YES.

EXTRA_PACKAGES         =

# The LATEX_HEADER tag can be used to specify a user-defined LaTeX header for
# the generated LaTeX document. The header should contain everything until the
# first chapter. If it is left blank doxygen will generate a standard header. It
# is highly recommended to start with a default header using
# doxygen -w latex new_header.tex new_footer.tex new_stylesheet.sty
# and then modify the file new_header.tex. See also section "Doxygen usage" for
# information on how to generate the default header that doxygen normally uses.
#
# Note: Only use a user-defined header if you know what you are doing!
# Note: The header is subject to change so you typically have to regenerate the
# default header when upgrading to a newer version of doxygen. The following
# commands have a special meaning inside the header (and footer): For a
# description of the possible markers and block names see the documentation.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_HEADER           =

# The LATEX_FOOTER tag can be used to specify a user-defined LaTeX footer for
# the generated LaTeX document. The footer should contain everything after the
# last chapter. If it is left blank doxygen will generate a standard footer. See
# LATEX_HEADER for more information on how to generate a default footer and what
# special commands can be used inside the footer. See also section "Doxygen
# usage" for information on how to generate the default footer that doxygen
# normally uses. Note: Only use a user-defined footer if you know what you are
# doing!
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_FOOTER           =

# The LATEX_EXTRA_STYLESHEET tag can be used to specify additional user-defined
# LaTeX style sheets that are included after the standard style sheets created
# by doxygen. Using this option one can overrule certain style aspects. Doxygen
# will copy the style sheet files to the output directory.
# Note: The order of the extra style sheet files is of importance (e.g. the last
# style sheet in the list overrules the setting of the previous ones in the
# list).
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_EXTRA_STYLESHEET =

# The LATEX_EXTRA_FILES tag can be used to specify one or more extra images or
# other source files which should be copied to the LATEX_OUTPUT output
# directory. Note that the files will be copied as-is; there are no commands or
# markers available.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_EXTRA_FILES      =

# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated is
# prepared for conversion to PDF (using ps2pdf or pdflatex). The PDF file will
# contain links (just like the HTML output) instead of page references. This
# makes the output suitable for online browsing using a PDF viewer.
# The default value is: YES.
# This tag requires that the tag GENERATE_LATEX is set to YES.

PDF_HYPERLINKS         = YES

# If the USE_PDFLATEX tag is set to YES, doxygen will use the engine as
# specified with LATEX_CMD_NAME to generate the PDF file directly from the LaTeX
# files. Set this option to YES, to get a higher quality PDF documentation.
#
# See also section LATEX_CMD_NAME for selecting the engine.
# The default value is: YES.
# This tag requires that the tag GENERATE_LATEX is set to YES.

USE_PDFLATEX           = YES

# The LATEX_BATCHMODE tag ignals the behavior of LaTeX in case of an error.
# Possible values are: NO same as ERROR_STOP, YES same as BATCH, BATCH In batch
# mode nothing is printed on the terminal, errors are scrolled as if <return> is
# hit at every error; missing files that TeX tries to input or request from
# keyboard input (\read on a not open input stream) cause the job to abort,
# NON_STOP In nonstop mode the diagnostic message will appear on the terminal,
# but there is no possibility of user interaction just like in batch mode,
# SCROLL In scroll mode, TeX will stop only for missing files to input or if
# keyboard input is necessary and ERROR_STOP In errorstop mode, TeX will stop at
# each error, asking for user intervention.
# The default value is: NO.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_BATCHMODE        = NO

# If the LATEX_HIDE_INDICES tag is set to YES then doxygen will not include the
# index chapters (such as File Index, Compound Index, etc.) in the output.
# The default value is: NO.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_HIDE_INDICES     = NO

# The LATEX_BIB_STYLE tag can be used to specify the style to use for the
# bibliography, e.g. plainnat, or ieeetr. See
# https://en.wikipedia.org/wiki/BibTeX and \cite for more info.
# The default value is: plain.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_BIB_STYLE        = plain

# The LATEX_EMOJI_DIRECTORY tag is used to specify the (relative or absolute)
# path from which the emoji images will be read. If a relative path is entered,
# it will be relative to the LATEX_OUTPUT directory. If left blank the
# LATEX_OUTPUT directory will be used.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_EMOJI_DIRECTORY  =

#---------------------------------------------------------------------------
# Configuration options related to the RTF output
#---------------------------------------------------------------------------

# If the GENERATE_RTF tag is set to YES, doxygen will generate RTF output. The
# RTF output is optimized for Word 97 and may not look too pretty with other RTF
# readers/editors.
# The default value is: NO.

GENERATE_RTF           = NO

# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it.
# The default directory is: rtf.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_OUTPUT             = rtf

# If the COMPACT_RTF tag is set to YES, doxygen generates more compact RTF
# documents. This may be useful for small projects and may help to save some
# trees in general.
# The default value is: NO.
# This tag requires that the tag GENERATE_RTF is set to YES.

COMPACT_RTF            = NO

# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated will
# contain hyperlink fields. The RTF file will contain links (just like the HTML
# output) instead of page references. This makes the output suitable for online
# browsing using Word or some other Word compatible readers that support those
# fields.
#
# Note: WordPad (write) and others do not support links.
# The default value is: NO.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_HYPERLINKS         = NO

# Load stylesheet definitions from file. Syntax is similar to doxygen's
# configuration file, i.e. a series of assignments. You only have to provide
# replacements, missing definitions are set to their default value.
#
# See also section "Doxygen usage" for information on how to generate the
# default style sheet that doxygen normally uses.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_STYLESHEET_FILE    =

# Set optional variables used in the generation of an RTF document. Syntax is
# similar to doxygen's configuration file. A template extensions file can be
# generated using doxygen -e rtf extensionFile.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_EXTENSIONS_FILE    =

#---------------------------------------------------------------------------
# Configuration options related to the man page output
#---------------------------------------------------------------------------

# If the GENERATE_MAN tag is set to YES, doxygen will generate man pages for
# classes and files.
# The default value is: NO.

GENERATE_MAN           = YES

# The MAN_OUTPUT tag is used to specify where the man pages will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it. A directory man3 will be created inside the directory specified by
# MAN_OUTPUT.
# The default directory is: man.
# This tag requires that the tag GENERATE_MAN is set to YES.

MAN_OUTPUT             = man

# The MAN_EXTENSION tag determines the extension that is added to the generated
# man pages. In case the manual section does not start with a number, the number
# 3 is prepended. The dot (.) at the beginning of the MAN_EXTENSION tag is
# optional.
# The default value is: .3.
# This tag requires that the tag GENERATE_MAN is set to YES.

MAN_EXTENSION          = .3

# The MAN_SUBDIR tag determines the name of the directory created within
# MAN_OUTPUT in which the man pages are placed. If defaults to man followed by
# MAN_EXTENSION with the initial . removed.
# This tag requires that the tag GENERATE_MAN is set to YES.

MAN_SUBDIR             =

# If the MAN_LINKS tag is set to YES and doxygen generates man output, then it
# will generate one additional man file for each entity documented in the real
# man page(s). These additional files only source the real man page, but without
# them the man command would be unable to find the correct page.
# The default value is: NO.
# This tag requires that the tag GENERATE_MAN is set to YES.

MAN_LINKS              = YES

#---------------------------------------------------------------------------
# Configuration options related to the XML output
#---------------------------------------------------------------------------

# If the GENERATE_XML tag is set to YES, doxygen will generate an XML file that
# captures the structure of the code including all documentation.
# The default value is: NO.

GENERATE_XML           = NO

# The XML_OUTPUT tag is used to specify where the XML pages will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it.
# The default directory is: xml.
# This tag requires that the tag GENERATE_XML is set to YES.

XML_OUTPUT             = xml

# If the XML_PROGRAMLISTING tag is set to YES, doxygen will dump the program
# listings (including syntax highlighting and cross-referencing information) to
# the XML output. Note that enabling this will significantly increase the size
# of the XML output.
# The default value is: YES.
# This tag requires that the tag GENERATE_XML is set to YES.

XML_PROGRAMLISTING     = YES

# If the XML_NS_MEMB_FILE_SCOPE tag is set to YES, doxygen will include
# namespace members in file scope as well, matching the HTML output.
# The default value is: NO.
# This tag requires that the tag GENERATE_XML is set to YES.

XML_NS_MEMB_FILE_SCOPE = NO

#---------------------------------------------------------------------------
# Configuration options related to the DOCBOOK output
#---------------------------------------------------------------------------

# If the GENERATE_DOCBOOK tag is set to YES, doxygen will generate Docbook files
# that can be used to generate PDF.
# The default value is: NO.

GENERATE_DOCBOOK       = NO

# The DOCBOOK_OUTPUT tag is used to specify where the Docbook pages will be put.
# If a relative path is entered the value of OUTPUT_DIRECTORY will be put in
# front of it.
# The default directory is: docbook.
# This tag requires that the tag GENERATE_DOCBOOK is set to YES.

DOCBOOK_OUTPUT         = docbook

#---------------------------------------------------------------------------
# Configuration options for the AutoGen Definitions output
#---------------------------------------------------------------------------

# If the GENERATE_AUTOGEN_DEF tag is set to YES, doxygen will generate an
# AutoGen Definitions (see https://autogen.sourceforge.net/) file that captures
# the structure of the code including all documentation. Note that this feature
# is still experimental and incomplete at the moment.
# The default value is: NO.

GENERATE_AUTOGEN_DEF   = NO

#---------------------------------------------------------------------------
# Configuration options related to Sqlite3 output
#---------------------------------------------------------------------------

#---------------------------------------------------------------------------
# Configuration options related to the Perl module output
#---------------------------------------------------------------------------

# If the GENERATE_PERLMOD tag is set to YES, doxygen will generate a Perl module
# file that captures the structure of the code including all documentation.
#
# Note that this feature is still experimental and incomplete at the moment.
# The default value is: NO.

GENERATE_PERLMOD       = NO

# If the PERLMOD_LATEX tag is set to YES, doxygen will generate the necessary
# Makefile rules, Perl scripts and LaTeX code to be able to generate PDF and DVI
# output from the Perl module output.
# The default value is: NO.
# This tag requires that the tag GENERATE_PERLMOD is set to YES.

PERLMOD_LATEX          = NO

# If the PERLMOD_PRETTY tag is set to YES, the Perl module output will be nicely
# formatted so it can be parsed by a human reader. This is useful if you want to
# understand what is going on. On the other hand, if this tag is set to NO, the
# size of the Perl module output will be much smaller and Perl will parse it
# just the same.
# The default value is: YES.
# This tag requires that the tag GENERATE_PERLMOD is set to YES.

PERLMOD_PRETTY         = YES

# The names of the make variables in the generated doxyrules.make file are
# prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. This is useful
# so different doxyrules.make files included by the same Makefile don't
# overwrite each other's variables.
# This tag requires that the tag GENERATE_PERLMOD is set to YES.

PERLMOD_MAKEVAR_PREFIX =

#---------------------------------------------------------------------------
# Configuration options related to the preprocessor
#---------------------------------------------------------------------------

# If the ENABLE_PREPROCESSING tag is set to YES, doxygen will evaluate all
# C-preprocessor directives found in the sources and include files.
# The default value is: YES.

ENABLE_PREPROCESSING   = YES

# If the MACRO_EXPANSION tag is set to YES, doxygen will expand all macro names
# in the source code. If set to NO, only conditional compilation will be
# performed. Macro expansion can be done in a controlled way by setting
# EXPAND_ONLY_PREDEF to YES.
# The default value is: NO.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

MACRO_EXPANSION        = NO

# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES then
# the macro expansion is limited to the macros specified with the PREDEFINED and
# EXPAND_AS_DEFINED tags.
# The default value is: NO.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

EXPAND_ONLY_PREDEF     = NO

# If the SEARCH_INCLUDES tag is set to YES, the include files in the
# INCLUDE_PATH will be searched if a #include is found.
# The default value is: YES.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

SEARCH_INCLUDES        = YES

# The INCLUDE_PATH tag can be used to specify one or more directories that
# contain include files that are not input files but should be processed by the
# preprocessor. Note that the INCLUDE_PATH is not recursive, so the setting of
# RECURSIVE has no effect here.
# This tag requires that the tag SEARCH_INCLUDES is set to YES.

INCLUDE_PATH           = include

# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard
# patterns (like *.h and *.hpp) to filter out the header-files in the
# directories. If left blank, the patterns specified with FILE_PATTERNS will be
# used.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

INCLUDE_FILE_PATTERNS  =

# The PREDEFINED tag can be used to specify one or more macro names that are
# defined before the preprocessor is started (similar to the -D option of e.g.
# gcc). The argument of the tag is a list of macros of the form: name or
# name=definition (no spaces). If the definition and the "=" are omitted, "=1"
# is assumed. To prevent a macro definition from being undefined via #undef or
# recursively expanded use the := operator instead of the = operator.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

PREDEFINED             =

# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then this
# tag can be used to specify a list of macro names that should be expanded. The
# macro definition that is found in the sources will be used. Use the PREDEFINED
# tag if you want to use a different macro definition that overrules the
# definition found in the source code.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

EXPAND_AS_DEFINED      =

# If the SKIP_FUNCTION_MACROS tag is set to YES then doxygen's preprocessor will
# remove all references to function-like macros that are alone on a line, have
# an all uppercase name, and do not end with a semicolon. Such function macros
# are typically used for boiler-plate code, and will confuse the parser if not
# removed.
# The default value is: YES.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

SKIP_FUNCTION_MACROS   = YES

#---------------------------------------------------------------------------
# Configuration options related to external references
#---------------------------------------------------------------------------

# The TAGFILES tag can be used to specify one or more tag files. For each tag
# file the location of the external documentation should be added. The format of
# a tag file without this location is as follows:
# TAGFILES = file1 file2 ...
# Adding location for the tag files is done as follows:
# TAGFILES = file1=loc1 "file2 = loc2" ...
# where loc1 and loc2 can be relative or absolute paths or URLs. See the
# section "Linking to external documentation" for more information about the use
# of tag files.
# Note: Each tag file must have a unique name (where the name does NOT include
# the path). If a tag file is not located in the directory in which doxygen is
# run, you must also specify the path to the tagfile here.

TAGFILES               =

# When a file name is specified after GENERATE_TAGFILE, doxygen will create a
# tag file that is based on the input files it reads. See section "Linking to
# external documentation" for more information about the usage of tag files.

GENERATE_TAGFILE       =

# If the ALLEXTERNALS tag is set to YES, all external class will be listed in
# the class index. If set to NO, only the inherited external classes will be
# listed.
# The default value is: NO.

ALLEXTERNALS           = NO

# If the EXTERNAL_GROUPS tag is set to YES, all external groups will be listed
# in the modules index. If set to NO, only the current project's groups will be
# listed.
# The default value is: YES.

EXTERNAL_GROUPS        = YES

# If the EXTERNAL_PAGES tag is set to YES, all external pages will be listed in
# the related pages index. If set to NO, only the current project's pages will
# be listed.
# The default value is: YES.

EXTERNAL_PAGES         = YES

#---------------------------------------------------------------------------
# Configuration options related to diagram generator tools
#---------------------------------------------------------------------------

# If set to YES the inheritance and collaboration graphs will hide inheritance
# and usage relations if the target is undocumented or is not a class.
# The default value is: YES.

HIDE_UNDOC_RELATIONS   = YES

# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is
# available from the path. This tool is part of Graphviz (see:
# https://www.graphviz.org/), a graph visualization toolkit from AT&T and Lucent
# Bell Labs. The other options in this section have no effect if this option is
# set to NO
# The default value is: NO.

HAVE_DOT               = NO

# The DOT_NUM_THREADS specifies the number of dot invocations doxygen is allowed
# to run in parallel. When set to 0 doxygen will base this on the number of
# processors available in the system. You can set it explicitly to a value
# larger than 0 to get control over the balance between CPU load and processing
# speed.
# Minimum value: 0, maximum value: 32, default value: 0.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_NUM_THREADS        = 0

# DOT_COMMON_ATTR is common attributes for nodes, edges and labels of
# subgraphs. When you want a differently looking font in the dot files that
# doxygen generates you can specify fontname, fontcolor and fontsize attributes.
# For details please see <a href=https://graphviz.org/doc/info/attrs.html>Node,
# Edge and Graph Attributes specification</a> You need to make sure dot is able
# to find the font, which can be done by putting it in a standard location or by
# setting the DOTFONTPATH environment variable or by setting DOT_FONTPATH to the
# directory containing the font. Default graphviz fontsize is 14.
# The default value is: fontname=Helvetica,fontsize=10.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_COMMON_ATTR        = "fontname=Helvetica,fontsize=10"

# DOT_EDGE_ATTR is concatenated with DOT_COMMON_ATTR. For elegant style you can
# add 'arrowhead=open, arrowtail=open, arrowsize=0.5'. <a
# href=https://graphviz.org/doc/info/arrows.html>Complete documentation about
# arrows shapes.</a>
# The default value is: labelfontname=Helvetica,labelfontsize=10.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_EDGE_ATTR          = "labelfontname=Helvetica,labelfontsize=10"

# DOT_NODE_ATTR is concatenated with DOT_COMMON_ATTR. For view without boxes
# around nodes set 'shape=plain' or 'shape=plaintext' <a
# href=https://www.graphviz.org/doc/info/shapes.html>Shapes specification</a>
# The default value is: shape=box,height=0.2,width=0.4.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_NODE_ATTR          = "shape=box,height=0.2,width=0.4"

# You can set the path where dot can find font specified with fontname in
# DOT_COMMON_ATTR and others dot attributes.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_FONTPATH           =

# If the CLASS_GRAPH tag is set to YES or GRAPH or BUILTIN then doxygen will
# generate a graph for each documented class showing the direct and indirect
# inheritance relations. In case the CLASS_GRAPH tag is set to YES or GRAPH and
# HAVE_DOT is enabled as well, then dot will be used to draw the graph. In case
# the CLASS_GRAPH tag is set to YES and HAVE_DOT is disabled or if the
# CLASS_GRAPH tag is set to BUILTIN, then the built-in generator will be used.
# If the CLASS_GRAPH tag is set to TEXT the direct and indirect inheritance
# relations will be shown as texts / links.
# Possible values are: NO, YES, TEXT, GRAPH and BUILTIN.
# The default value is: YES.

CLASS_GRAPH            = YES

# If the COLLABORATION_GRAPH tag is set to YES then doxygen will generate a
# graph for each documented class showing the direct and indirect implementation
# dependencies (inheritance, containment, and class references variables) of the
# class with other documented classes.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

COLLABORATION_GRAPH    = YES

# If the GROUP_GRAPHS tag is set to YES then doxygen will generate a graph for
# groups, showing the direct groups dependencies. See also the chapter Grouping
# in the manual.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

GROUP_GRAPHS           = YES

# If the UML_LOOK tag is set to YES, doxygen will generate inheritance and
# collaboration diagrams in a style similar to the OMG's Unified Modeling
# Language.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

UML_LOOK               = NO

# If the UML_LOOK tag is enabled, the fields and methods are shown inside the
# class node. If there are many fields or methods and many nodes the graph may
# become too big to be useful. The UML_LIMIT_NUM_FIELDS threshold limits the
# number of items for each type to make the size more manageable. Set this to 0
# for no limit. Note that the threshold may be exceeded by 50% before the limit
# is enforced. So when you set the threshold to 10, up to 15 fields may appear,
# but if the number exceeds 15, the total amount of fields shown is limited to
# 10.
# Minimum value: 0, maximum value: 100, default value: 10.
# This tag requires that the tag UML_LOOK is set to YES.

UML_LIMIT_NUM_FIELDS   = 10

# If the DOT_UML_DETAILS tag is set to NO, doxygen will show attributes and
# methods without types and arguments in the UML graphs. If the DOT_UML_DETAILS
# tag is set to YES, doxygen will add type and arguments for attributes and
# methods in the UML graphs. If the DOT_UML_DETAILS tag is set to NONE, doxygen
# will not generate fields with class member information in the UML graphs. The
# class diagrams will look similar to the default class diagrams but using UML
# notation for the relationships.
# Possible values are: NO, YES and NONE.
# The default value is: NO.
# This tag requires that the tag UML_LOOK is set to YES.

DOT_UML_DETAILS        = NO

# The DOT_WRAP_THRESHOLD tag can be used to set the maximum number of characters
# to display on a single line. If the actual line length exceeds this threshold
# significantly it will wrapped across multiple lines. Some heuristics are apply
# to avoid ugly line breaks.
# Minimum value: 0, maximum value: 1000, default value: 17.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_WRAP_THRESHOLD     = 17

# If the TEMPLATE_RELATIONS tag is set to YES then the inheritance and
# collaboration graphs will show the relations between templates and their
# instances.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

TEMPLATE_RELATIONS     = NO

# If the INCLUDE_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are set to
# YES then doxygen will generate a graph for each documented file showing the
# direct and indirect include dependencies of the file with other documented
# files.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

INCLUDE_GRAPH          = YES

# If the INCLUDED_BY_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are
# set to YES then doxygen will generate a graph for each documented file showing
# the direct and indirect include dependencies of the file with other documented
# files.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

INCLUDED_BY_GRAPH      = YES

# If the CALL_GRAPH tag is set to YES then doxygen will generate a call
# dependency graph for every global function or class method.
#
# Note that enabling this option will significantly increase the time of a run.
# So in most cases it will be better to enable call graphs for selected
# functions only using the \callgraph command. Disabling a call graph can be
# accomplished by means of the command \hidecallgraph.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

CALL_GRAPH             = NO

# If the CALLER_GRAPH tag is set to YES then doxygen will generate a caller
# dependency graph for every global function or class method.
#
# Note that enabling this option will significantly increase the time of a run.
# So in most cases it will be better to enable caller graphs for selected
# functions only using the \callergraph command. Disabling a caller graph can be
# accomplished by means of the command \hidecallergraph.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

CALLER_GRAPH           = NO

# If the GRAPHICAL_HIERARCHY tag is set to YES then doxygen will graphical
# hierarchy of all classes instead of a textual one.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

GRAPHICAL_HIERARCHY    = YES

# If the DIRECTORY_GRAPH tag is set to YES then doxygen will show the
# dependencies a directory has on other directories in a graphical way. The
# dependency relations are determined by the #include relations between the
# files in the directories.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

DIRECTORY_GRAPH        = YES

# The DIR_GRAPH_MAX_DEPTH tag can be used to limit the maximum number of levels
# of child directories generated in directory dependency graphs by dot.
# Minimum value: 1, maximum value: 25, default value: 1.
# This tag requires that the tag DIRECTORY_GRAPH is set to YES.

DIR_GRAPH_MAX_DEPTH    = 1

# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images
# generated by dot. For an explanation of the image formats see the section
# output formats in the documentation of the dot tool (Graphviz (see:
# https://www.graphviz.org/)).
# Note: If you choose svg you need to set HTML_FILE_EXTENSION to xhtml in order
# to make the SVG files visible in IE 9+ (other browsers do not have this
# requirement).
# Possible values are: png, jpg, gif, svg, png:gd, png:gd:gd, png:cairo,
# png:cairo:gd, png:cairo:cairo, png:cairo:gdiplus, png:gdiplus and
# png:gdiplus:gdiplus.
# The default value is: png.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_IMAGE_FORMAT       = png

# If DOT_IMAGE_FORMAT is set to svg, then this option can be set to YES to
# enable generation of interactive SVG images that allow zooming and panning.
#
# Note that this requires a modern browser other than Internet Explorer. Tested
# and working are Firefox, Chrome, Safari, and Opera.
# Note: For IE 9+ you need to set HTML_FILE_EXTENSION to xhtml in order to make
# the SVG files visible. Older versions of IE do not have SVG support.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

INTERACTIVE_SVG        = NO

# The DOT_PATH tag can be used to specify the path where the dot tool can be
# found. If left blank, it is assumed the dot tool can be found in the path.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_PATH               =

# The DOTFILE_DIRS tag can be used to specify one or more directories that
# contain dot files that are included in the documentation (see the \dotfile
# command).
# This tag requires that the tag HAVE_DOT is set to YES.

DOTFILE_DIRS           =

# You can include diagrams made with dia in doxygen documentation. Doxygen will
# then run dia to produce the diagram and insert it in the documentation. The
# DIA_PATH tag allows you to specify the directory where the dia binary resides.
# If left empty dia is assumed to be found in the default search path.

DIA_PATH               =

# The DIAFILE_DIRS tag can be used to specify one or more directories that
# contain dia files that are included in the documentation (see the \diafile
# command).

DIAFILE_DIRS           =

# When using plantuml, the PLANTUML_JAR_PATH tag should be used to specify the
# path where java can find the plantuml.jar file or to the filename of jar file
# to be used. If left blank, it is assumed PlantUML is not used or called during
# a preprocessing step. Doxygen will generate a warning when it encounters a
# \startuml command in this case and will not generate output for the diagram.

PLANTUML_JAR_PATH      =

# When using plantuml, the PLANTUML_CFG_FILE tag can be used to specify a
# configuration file for plantuml.

PLANTUML_CFG_FILE      =

# When using plantuml, the specified paths are searched for files specified by
# the !include statement in a plantuml block.

PLANTUML_INCLUDE_PATH  =

# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of nodes
# that will be shown in the graph. If the number of nodes in a graph becomes
# larger than this value, doxygen will truncate the graph, which is visualized
# by representing a node as a red box. Note that doxygen if the number of direct
# children of the root node in a graph is already larger than
# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note that
# the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.
# Minimum value: 0, maximum value: 10000, default value: 50.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_GRAPH_MAX_NODES    = 50

# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the graphs
# generated by dot. A depth value of 3 means that only nodes reachable from the
# root by following a path via at most 3 edges will be shown. Nodes that lay
# further from the root node will be omitted. Note that setting this option to 1
# or 2 may greatly reduce the computation time needed for large code bases. Also
# note that the size of a graph can be further restricted by
# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.
# Minimum value: 0, maximum value: 1000, default value: 0.
# This tag requires that the tag HAVE_DOT is set to YES.

MAX_DOT_GRAPH_DEPTH    = 0

# Set the DOT_MULTI_TARGETS tag to YES to allow dot to generate multiple output
# files in one run (i.e. multiple -o and -T options on the command line). This
# makes dot run faster, but since only newer versions of dot (>1.8.10) support
# this, this feature is disabled by default.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_MULTI_TARGETS      = NO

# If the GENERATE_LEGEND tag is set to YES doxygen will generate a legend page
# explaining the meaning of the various boxes and arrows in the dot generated
# graphs.
# Note: This tag requires that UML_LOOK isn't set, i.e. the doxygen internal
# graphical representation for inheritance and collaboration diagrams is used.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

GENERATE_LEGEND        = YES

# If the DOT_CLEANUP tag is set to YES, doxygen will remove the intermediate
# files that are used to generate the various graphs.
#
# Note: This setting is not only used for dot files but also for msc temporary
# files.
# The default value is: YES.

DOT_CLEANUP            = YES

# You can define message sequence charts within doxygen comments using the \msc
# command. If the MSCGEN_TOOL tag is left empty (the default), then doxygen will
# use a built-in version of mscgen tool to produce the charts. Alternatively,
# the MSCGEN_TOOL tag can also specify the name an external tool. For instance,
# specifying prog as the value, doxygen will call the tool as prog -T
# <outfile_format> -o <outputfile> <inputfile>. The external tool should support
# output file formats "png", "eps", "svg", and "ismap".

MSCGEN_TOOL            =

# The MSCFILE_DIRS tag can be used to specify one or more directories that
# contain msc files that are included in the documentation (see the \mscfile
# command).

MSCFILE_DIRS           =

```

`LICENSE`:

```
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
<p align="center"><img width="300" src="https://raw.githubusercontent.com/Jaysmito101/cgl/main/images/CGL_logo_low_mid_res.png" border="0">
</p>



<p align="center">

<img src="https://img.shields.io/github/issues-pr/Jaysmito101/cgl?style=for-the-badge" />
<img alt="Lines of code" src="https://img.shields.io/tokei/lines/github/Jaysmito101/cgl?style=for-the-badge" />
<img src="https://img.shields.io/github/repo-size/Jaysmito101/cgl?style=for-the-badge" />
<a href="https://patreon.com/jaysmito101"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fshieldsio-patreon.vercel.app%2Fapi%3Fusername%3Djaysmito101%26type%3Dpledges&style=for-the-badge" alt="Support me on Patreon" /></a>

</p>

<br/>



# Index
* [Intro](#cgl)
* [Platforms](#target-platforms)
* [Features](#what-does-cgl-provide)
* [Showreels](#showreels)

<br>

# CGL
CGL (C Graphics Library) is a multipurpose library mainly for recreational coding /  demo scenes / prototyping / small games / experimentation. This has a **lot of utilities for graphics**. And best of all all of it is inside a single header file `cgl.h`.  Also CGL is made purely in C but is also compatible with C++. 

**NOTE** : Do not think that header only means its going to increase compile time as the implementation needs be enabled only for 1 file using `#define CGL_IMPLEMENTATION`. See [Examples](./examples)

<br>

## Target Platforms

- <b><i>Windows</b></i>
- <b><i>Linux</b></i>
- <b><i>MacOS (untested)</b></i>
- <b><i>WebAssembly (Beta)</b></i>
- <b><i>Android (Coming Soon)</b></i>

<br>

## What does CGL Provide? 

* cgl-rs
  - A Rust wrapper ( https://crates.io/crates/cgl-rs )

* cgl-py
  - A python wrapper ( https://pypi.org/project/cgl-py )

* Windowing library (Optional)
  - You can completely disable it by `#define CGL_EXCLUDE_WINDOW_API`
  - This windowing library is primarily a wrapper GLFW along with a few extra functionalities. **Example** : In case you are using some library like `nuklear` for GUI it will mess up all `glfw` callbacks so with CGL you can restore the CGL callbacks with a call to `CGL_window_resecure_callbacks`

* Utility functionalities
  - Reading/Writing files
  - Random float/int/bool/vec2/vec3/color generation
  - CRC32/CRC64
  - ROT13 encryption
  - General Purpose Hashing Functions [refer here]( http://www.azillionmonkeys.com/qed/hash.html)
  - Colored printf (red, green, blue, gray/yellow)
  - Point/Triangle intersection check
  - 3D transform API (matrix calculation, etc)
  - TODO: [ MD5 / SHA 256 / SHA 128 / AES ]
 
 

* Noise API
  - Multiple faster Alternatives to libc's rand
  - Procedural Coherent Noise Algorithms
    - Perlin's Noise (Improved Version)
    - OpenSimplex2
    - Value Noise
    - Worley Noise (or Cellular Noise)
  - Fractals like FBm, Rigid, Billow, PingPong
  - Parameters for Octaves/Lacunarity/Weighted Strength/Gain
 
* Triangulation
   - Bower Watson Algorithm for Delaunay Triangulator
   
* Artificial Intelligence
  - Neural Networks
  - Backpropagation
  - Serializing/Deserializing networks
  - Multi Variable Linear Regression

* Graph Algorithms
  - A* Path Finding (general purpose)
  - N Dimensional Spatial Partition and Localization (n dimensional version of a quad tree)

* Data structures
  - List(dynamic array) + Stack (implemented together)
  - Hashtable -> This hashtable is general purpose. Key can be string or a n-bit buffer. The value can be anything int, string, float, custom types, ...
     - Hashtable Iterator -> Iterate through the hashtable using a [simple](https://github.com/Jaysmito101/cgl/blob/main/examples/c/using_hashtable_iterator.c) API
  
* Logger
  - Can be enabled/disabled by `#define CGL_DISABLE_LOGGER`
  - Log to multiple log files simultaneously
  - Log to console with colored output for separate log levels
  - Logger with auto timestamps
  
* Cross Platform Networking (Optional)
  - You can disable all networking by `#define CGL_EXCLUDE_NETWORKING`
  - Low-level sockets 
  - SSL sockets (optional) (requires  OpenSSL)
  - HTTP/HTTPS request (beta)
  
* General Purpose Markov Chains (Optional) [Example](./examples/c/markov_text_generation.c)
  - Can work with any type of data ( text / image / etc.  )
  - Train/Generate with 3 - 4 lines of code
  - Trainer implemented for text generation (n-gram based)
  - Custom trainer API for custom scenarios

* Cross Platform Threading
  - Threads
  - Mutex
  - Condition Variables (TODO)
  - NOTE: Implemented using `Win32 Threads` on Windows and `pthread` on Linux. (on Linux you need to link `pthread` to build)

* Bloom
  - Apply bloom to any tuxtures with just 1 line of code
  - Implementation based of Unity's bloom
  - Custom thresholding
  - Custom downsample/upsample passes
  - Entirely done in Compute Shaders
  
* 2D Collision Detection
  - Detect collisions between 2D polygons
  - Generate Separating Axes for polygons
  - Get Overlap distance
  - GJK (Gilbertâ€“Johnsonâ€“Keerthi distance algorithm)
  - EPA (Expanding Polytope Algorithm)
  - SAT (Separate Axis Theorem)

* Marching Square
  - Fully Customizablt Marcher
  - Linear Interpolation supported
  - Generates 2D Mesh (Triangles) for CGL

* Toon Post Processor
  - Outline Effect
  - Toon Shading Effect
  - Hatching Effect
  - All in a single post process call ( no per object calculation)
  - Completely implemented in Compute Shader
  - Customizable

* CGL Ray Cast
  - Fast 2D Ray Cast
  - Custom Walls 
  - Bake to Triangle Mesh
  - Public ray cast functions

* CGL Node Editor
  - Very fast as its powered by CGL Widgets
  - Custom nodes, pins, links
  - Minimal & Powerful
  - Render your own nodes & links type API
  - Zoom In/Out
  - Global Offsets
 
* CGL Audio API
  - Cross Platform (OpenAL backend)
  - Simple API
  - WAV File Loader/Sampler 

* CSV API
  - CSV parser
  - CSV serializer
  - CSV document data structure

* CGL Widgets (Optional)
  - You can disable it by `#define CGL_EXCLUDE_WIDGETS`
  - API Like [p5.js](https://p5js.org/)
  - Text widgets (render high quality crisp text without loading or baking any font)
  - Batch Renderer backend (very fast even for a large number of widgets)
  - draw (filled or stroked) :
    - triangle [`CGL_widgets_add_triangle`]
    - general quad [`CGL_widgets_add_quad`]
    - rectangle [`CGL_widgets_add_rect` `CGL_widgets_add_rect2f`]
    - line [`CGL_widgets_add_line`]
    - circle [`CGL_widgets_add_circle` `CGL_widgets_add_circle2f`]
    - oval [`CGL_widgets_add_oval`, `CGL_widgets_add_oval2f`]
    - arc 
  - Plot 
    - Scatter plot
    - Bar Graph (vertical/horizontal)
    - Pie Chart
    - Plot a function
  - font based text widgets (load custom font for high quality text rendering with widgets api)
  - Surrport for rendering 3D meshes with widgets API
  - Support for Textures to Widgets API (efficient)
  - Advanced Bezier Curve( lines or dotted) widget
  - Add individual vertices
  - Adjust stroke color/thickness
  - Customize Batch renderer max vertices capacity (for low memory systems)

* Math library
  - Advanced Matrix Library (this is separate from matrix lib for graphics)
    - Linear Algebra for matrixx math
  - vec2/vec3/vec4
  - mat3/mat4 (for graphics)
  - add/sub/mul/div/scale/length/normalize/lerp/min/max/equal for vec2/vec3/vec4
  - rotate_x/rotate_y/rotate_z for vec3
  - scale/translate/rotate_x/rotate_y/rotate_z/add/sub/mul for mat4
  - perspective for mat4
  - transpose for mat4/(mat3 TODO)
  - Rotation Matrices using Goldman's Method
  - look_at matrix 
  - Quaternion math
  - Transform vectors
  - **NOTE:** Most of math functions are implemented via macros so will be **totally inclined** and quite fast without any unnecessary function calls

* High Level OpenGL API for (Optional)
  - You can completely disable it by `#define CGL_EXCLUDE_GRAPHICS_API`
  - Texture (2D / 2D Array / Cube map) 
  - Framebuffers
  - SSBO (Shader Storage Buffer Object)
  - UBO (Uniform Buffer Object)
  - Shaders 
    - Vertex & Fragment (Geometry Shader not included as its not very widely used)
    - Compute Shader API 

* CGL Mesh API
  - CGL has a high level API for handling meshes
  - 2 types of meshes are there
    - CPU mesh -> stores the data also used for mesh operations like
      - generate triangle
      - generate quad
      - load OBJ (beta)
      - generate cube
      - generate plane
      - generate  cylinder
      - generate sphere
      - generate mesh out of any parametric surface function [refer here](https://stackoverflow.com/a/31326534/14911094)
      - calculate normals 
      - perform operation on meshes
        - add 2 meshes
        - offset vertices
        - etc .
    - GPU mesh -> the pointer to the data stored on GPU side (internally handles the Vertex buffer, Index buffer, Vertex Array) and can used for
      - render
      - render instanced
      - render wireframe
      - render wireframe instanced
      
* CGL camera
  - CGL provides a proper camera abstraction
  - Perspective & Orthographic
  - It internally handles all matrix calculations (just input the position and rotation)
  - Auto calculates the Up, Right, Front vectors
 
* Text Rendering (Optional) (Requires [FreeType2](http://freetype.org/))
  - You can completely disable it with `#define CGL_EXCLUDE_TEXT_RENDER`
  - Load Fonts from `.ttf` files
  - Bake bitmaps for characters
  - Bake textures from strings

* Trail Renderer
  - Fast 3D Trail Renderer
  - Bake to mesh
  - Custom Shader support
  - Fully customizable
  
 
* Sky Renderer (Optional)
  - You can completely disable it with `#define CGL_EXCLUDE_SKY_RENDERER`
  - Supports both a Sky Box (cube mesh) and Sky Sphere/Dome (sphere mesh)
  - Supports Cube map Textured Sky 
  - Supports Realtime Procedurally Generated Sky ( + procedural clouds)
  - Render a beautiful sky with just 3 - 5 lines of code

* Phong Renderer (Optional) 
  - You can disable it via `#define CGL_EXCLUDE_PHONG_RENDERER`
  - It has:
    - Phone Pipeline -> it is the pipeline holding shader data and global engine data. Options available are
      - enable/disable blinn correction
      - enable/disable depth test
      - enable/disable gamma correction
      - setup ambient lighting
      - add/remove lights
    - Phong Light -> It can be of 3 types:
      - Directional -> it takes (direction, color, intensity)
      - Point -> it takes (position, color, itensity, constant, linear, quadratic)
      - Spot (TODO)
    - Phong Material
      - dissuse texture/color
      - specular texture/color
      - shininess
      - normal maps (TODO)

* Tilemap Renderer (Optional)
   - You can disable it with `#define CGL_EXCLUDE_TILEMAP_RENDERER`
   - Renders a NxN tilemap with a single line of code
   - Each tile can have following states
     - clear (transparent or disabled)
     - solid color
     - texture -> Texture can be supplied via:
       - texture 2d array -> you need to provide depth for each tile
       - tileset or texture atlas -> you have to provide bounds (normalized 0.0-1.0) of the area of the alas to be used on tile
    - NOTE: this tile render renders only 4 vertices and has only 1 draw call  (not a instanced call so its quite fast
    
  
 ## Things that are being worked on:
 
 * PBR renderer (optional)
 * IBL (optional)
 
 ## Showreels
 
 Checkout out: [here](https://www.youtube.com/@jaysmito101/shorts)


**For more see [Examples](./examples)

<br>

```

`cgl.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/


// these are some exaples of how you can configure cgl
#define CGL_EXCLUDE_NETWORKING
#define CGL_LOGGING_ENABLED
#define CGL_EXCLUDE_AUDIO
#define CGL_EXCLUDE_TEXT_RENDER

#define CGL_IMPLEMENTATION
#include "cgl.h"

```

`cgl.h`:

```h
/*

MIT License

Copyright (c) 2023 Jaysmito Mukherjee

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

/** file: cgl.h
 *
 * CGL is a cross platform C library for game development.
 * It is designed to be simple, fast and easy to use.
 * It is also designed to be modular, so that you can use
 * only the parts you need.
 *
 * @author Jaysmito Mukherjee
 */

#ifndef CGL_H
#define CGL_H

#if defined(_WIN32) || defined(_WIN64)
#define CGL_WINDOWS
#else
 // TODO: seperate linux and macos and android
#define CGL_UNIX
#endif

// check if its gcc
#if defined(__GNUC__) || defined(__GNUG__)
#define CGL_GCC
// disable warnings for overlength strings as we have 
// shaders embedded in the code as strings
#pragma GCC diagnostic ignored "-Woverlength-strings"
#endif

// check if its clang
#if defined(__clang__)
#define CGL_CLANG
#endif

// check if its msvc
#if defined(_MSC_VER)
#define CGL_MSVC
#endif


#ifdef CGL_WASM
#define CGL_EXCLUDE_NETWORKING
#define CGL_EXCLUDES_THREADS
#ifdef CGL_EXCLUDE_WINDOW_API
#undef CGL_EXCLUDE_WINDOW_API
#endif
#ifdef __EMSCRIPTEN__
#include <emscripten/emscripten.h>
#endif
#define CGL_wasm_set_loop_func(func, data) emscripten_set_main_loop_arg((em_arg_callback_func)func, data, 0, true);
#endif


// common
#if 1 // Just to use code folding

// std includes
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <time.h>
#include <assert.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <limits.h>
#include <stddef.h>
#include <float.h>
#include <ctype.h>
#include <wchar.h>
#include <wctype.h>
#include <locale.h>
#include <errno.h>
#include <time.h>
#if !(defined(_WIN32) || defined(_WIN64))
#include <unistd.h>
#endif

/*
 *  Detect the current platform
 */
#if defined(_WIN32) || defined(_WIN64)
#define CGL_WINDOWS
#elif defined(__linux__)
#define CGL_LINUX
#elif defined(__APPLE__)
#define CGL_MACOS
#warning "MacOS is not tested yet"
#elif defined(__ANDROID__)
#define CGL_ANDROID
#warning "Android is not tested yet"
#elif defined(__EMSCRIPTEN__)
#define CGL_WASM
#endif

 /*
  *  Detect the current compiler
  */
#if defined(__clang__)
#define CGL_CLANG
#elif defined(__GNUC__) || defined(__GNUG__)
#if defined(__MINGW32__) || defined(__MINGW64__)
#define CGL_MINGW
#endif
#define CGL_GCC
#elif defined(_MSC_VER)
#define CGL_MSVC
#endif


  /*
   * CGL types
   */
typedef unsigned char CGL_ubyte;
typedef unsigned short CGL_ushort;
typedef unsigned int CGL_uint;
typedef unsigned long CGL_ulong;
typedef unsigned long long CGL_ulonglong;
typedef char CGL_byte;
typedef short CGL_short;
typedef int CGL_int;
typedef long CGL_long;
typedef long long CGL_longlong;
typedef float CGL_float;
typedef double CGL_double;
typedef long double CGL_longdouble;
typedef size_t CGL_sizei;
typedef bool CGL_bool;
typedef void CGL_void;

#define CGL_TRUE true
#define CGL_FALSE false

#ifndef CGL_NEWLINE
#ifdef CGL_WINDOWS
#define CGL_NEWLINE "\r\n"
#else
#define CGL_NEWLINE "\n"
#endif
#endif


#ifndef max
#define max(a,b)                                \
    ({ __typeof__ (a) _a = (a);                 \
        __typeof__ (b) _b = (b);                \
     _a > _b ? _a : _b; })
#endif

#ifndef min
#define min(a,b)                                \
    ({ __typeof__ (a) _a = (a);                 \
        __typeof__ (b) _b = (b);                \
     _a < _b ? _a : _b; })
#endif

#ifdef CGL_LOGGING_ENABLED
#define CGL_LOG(...) CGL_log_internal(__VA_ARGS__)
#else
#define CGL_LOG(...)
#endif // CGL_LOG_ENABLED

struct CGL_context;
typedef struct CGL_context CGL_context;

/** @brief Initializes CGL
 *
 * This function initializes CGL. It must be called before
 * any other CGL function.
 *
 * @return true if CGL was initialized successfully
*/
bool CGL_init(); // initialize CGL

/** @brief Shuts down CGL
 *
 * This function shuts down CGL. It must be called after
 * all other CGL functions.
 *
 * @return returns nothing
*/
CGL_void CGL_shutdown(); // shutdown CGL

#endif

#ifndef CGL_EXCLUDE_NETWORKING

/*
 * The error codes for CGL networking
 */
#define CGL_NET_NO_ERROR                    0xAB000
#define CGL_NET_NAME_RESOLUTION_ERROR       0xAB001
#define CGL_NET_INVALID_PARAMATER_ERROR     0xAB002
#define CGL_NET_UNSUPPORTED_ERROR           0xAB003
#define CGL_NET_MEMORY_ERROR                0xAB004
#define CGL_NET_NOT_FOUND_ERROR             0xAB005

struct CGL_net_addrinfo;
typedef struct CGL_net_addrinfo CGL_net_addrinfo;

struct CGL_net_socket;
typedef struct CGL_net_socket CGL_net_socket;

/** @brief Initializes CGL networking system
 *
 * This function initializes CGL networking system.
 * It must be called before any other CGL networking function.
 *
 * @return true if CGL networking was initialized successfully
*/
bool CGL_net_init();

/** @brief Shuts down CGL networking system
 *
 * This function shuts down CGL networking system.
 * Also frees all the resources allocated by CGL
 * networking system.
 *
 * @return returns nothing
 */
CGL_void CGL_net_shutdown();

/** @brief Query system for addrinfo
 *
 * This function queries the system for addrinfo
 * for the given name and port. The addrinfo is
 * stored in the CGL_net_addrinfo struct.
 *
 * @param name the name of the host
 * @param port the port of the host
 * @param count the number of addrinfo returned (output)
 * @return the addrinfo of the host
*/
CGL_net_addrinfo* CGL_net_addrinfo_query(const char* name, const char* port, size_t* count);

/** @brief Destroys the addrinfo
 *
 * This function destroys the addrinfo and frees
 * all the resources allocated by CGL networking
 *
 * @param infos the addrinfo to destroy *
*/
CGL_void CGL_net_addrinfo_destroy(CGL_net_addrinfo* infos);

/** @brief Creates a socket
 *
 * This function creates a socket object and returns
 * it.
 *
 * NOTE: This must be destroyed using CGL_net_socket_destroy
 *
 * @return the socket object
*/
CGL_net_socket* CGL_net_socket_create();

/** @brief Connects a socket to a target addrinfo
 *
 * This function connects the socket to the target
 * specified by the addrinfo.
 *
 * @param socket The socket to connect
 * @param target The target addrinfo
 * @return true if the socket was connected successfully
*/
bool CGL_net_socket_connect(CGL_net_socket* socket, CGL_net_addrinfo* target);

/** @brief Binds a socket to a target addrinfo
 *
 * This function binds the socket to the target
 * specified by the addrinfo.
 *
 * @param socket The socket to bind
 * @param target The target addrinfo
 * @return true if the socket was bound successfully
*/
bool CGL_net_socket_bind(CGL_net_socket* socket, CGL_net_addrinfo* target);

/** @brief Listens for connections on a socket (Server)
 *
 * This function makes the socket listen for connections.
 * This basically sets up the socket as a server.
 *
 * @param socket The socket to listen on
 * @param max_connections The maximum number of connections
 * @return true if the socket was listening successfully
*/
bool CGL_net_socket_listen(CGL_net_socket* socket, size_t max_connections);

/** @brief Accepts a connection on a socket (Server)
 *
 * This function accepts a connection on the socket
 * and returns a new socket object for the connection.
 * The returned object has a connection established
 * with the client and can be used to send and receive
 * data packets over the connection.
 *
 * NOTE: The returned object must be destroyed using CGL_net_socket_close
 *
 * @param socket The socket to accept a connection on
 * @param addrinfo The addrinfo of the socket
 * @return the socket object for the connection if successful, NULL otherwise
*/
CGL_net_socket* CGL_net_socket_accept(CGL_net_socket* socket, CGL_net_addrinfo* addrinfo);

/** @brief Destroys a socket
 *
 * This function destroys the socket and frees
 * all the resources allocated for the socket.
 * It also releases the internal handles of the socket.
 *
 * @param socket The socket to destroy
 * @return returns nothing
*/
CGL_void CGL_net_socket_close(CGL_net_socket* socket);

/** @brief Sends data over a socket
 *
 * This function sends data over the socket.
 *
 * @param socket The socket to send data over
 * @param buffer The buffer to send
 * @param size The size of the buffer
 * @param size_sent The size of the data sent (output)
 * @return true if the data was sent successfully
*/
bool CGL_net_socket_send(CGL_net_socket* socket, void* buffer, size_t size, size_t* size_sent);

/** @brief Receives data over a socket
 *
 * This function receives data over the socket.
 *
 * @param socket The socket to receive data over
 * @param buffer The buffer to receive data into
 * @param size The size of the buffer
 * @param size_recieved The size of the data recieved (output)
 * @return true if the data was recieved successfully
*/
bool CGL_net_socket_recv(CGL_net_socket* socket, void* buffer, size_t size, size_t* size_recieved);

/** @brief Shuts down the send side of a socket
 *
 * This function shuts down the send side of the socket.
 *
 * @param socket The socket to shutdown
 * @return true if the socket was shutdown successfully
*/
bool CGL_net_socket_shutdown_send(CGL_net_socket* socket);

/** @brief Shuts down the receive side of a socket
 *
 * This function shuts down the receive side of the socket.
 *
 * @param socket The socket to shutdown
 * @return true if the socket was shutdown successfully
*/
bool CGL_net_socket_shutdown_recv(CGL_net_socket* socket);

/** @brief Performs a HTTP request
 *
 * This function performs a HTTP request.
 * It internally allocates sockets, establishes
 * connections, sends and receives data.
 * This function is blocking.
 *
 * NOTE: This function is not very stable yet
 *       and should be avoided in production
 *       environments.
 *
 * @param method The HTTP method to use (GET, POST, etc.)
 * @param host The host to connect to (Ex: www.google.com)
 * @param path The path to request (Ex: /search)
 * @param response_buffer The buffer to store the response in (output)
 * @param size The size of the buffer (input) and the size of the response (output)
 * @param accept The accept header to send
 * @param user_agent The user agent header to send
 * @param body The request body to send
 * @return HTTP status code is successful, 0 otherwise
*/
CGL_int CGL_net_http_request(const char* method, const char* host, const char* path, void* response_buffer, size_t* size, const char* accept, const char* user_agent, const char* body);

/** @brief Performs a HTTP GET request
 *
 * This function performs a HTTP GET request.
 *
 * NOTE: This internally calls CGL_net_http_request
 *
 * @param host The host to connect to (Ex: www.google.com)
 * @param path The path to request (Ex: /search)
 * @param buffer The buffer to store the response in (output)
 * @param size The size of the buffer (input) and the size of the response (output)
 * @param accept The accept header to send
 * @param user_agent The user agent header to send
 * @return HTTP status code is successful, 0 otherwise
*/
CGL_int CGL_net_http_get(const char* host, const char* path, void* buffer, size_t* size, const char* accept, const char* user_agent);

/** @brief Performs a HTTP POST request
 *
 * This function performs a HTTP POST request.
 *
 * NOTE: This internally calls CGL_net_http_request
 *
 * @param host The host to connect to (Ex: www.google.com)
 * @param path The path to request (Ex: /search)
 * @param buffer The buffer to store the response in (output)
 * @param size The size of the buffer (input) and the size of the response (output)
 * @param accept The accept header to send
 * @param user_agent The user agent header to send
 * @param body The request body to send
 * @return HTTP status code is successful, 0 otherwise
*/
CGL_int CGL_net_http_post(const char* host, const char* path, void* buffer, size_t* size, const char* accept, const char* user_agent, const char* body);

#ifndef CGL_EXCLUDE_SSL_SOCKET

/** @brief Performs a HTTPS request
 *
 * NOTE: Not implemented yet
 *
 * @param method The HTTP method to use (GET, POST, etc.)
 * @param host The host to connect to (Ex: www.google.com)
 * @param path The path to request (Ex: /search)
 * @param response_buffer The buffer to store the response in (output)
 * @param size The size of the buffer (input) and the size of the response (output)
 * @param accept The accept header to send
 * @param user_agent The user agent header to send
 * @param body The request body to send
 * @return HTTP status code is successful, 0 otherwise
*/
CGL_int CGL_net_https_request(const char* method, const char* host, const char* path, void* response_buffer, size_t* size, const char* accept, const char* user_agent, const char* body);

/** @brief Performs a HTTPS GET request
 *
 * Performs a HTTPS GET request.
 *
 * NOTE: This internally calls CGL_net_https_request
 *
 * @param host The host to connect to (Ex: www.google.com)
 * @param path The path to request (Ex: /search)
 * @param buffer The buffer to store the response in (output)
 * @param size The size of the buffer (input) and the size of the response (output)
 * @param accept The accept header to send
 * @param user_agent The user agent header to send
 * @return HTTP status code is successful, 0 otherwise
*/
CGL_int CGL_net_https_get(const char* host, const char* path, void* buffer, size_t* size, const char* accept, const char* user_agent);

/** @brief Performs a HTTPS POST request
 *
 * Performs a HTTPS POST request.
 *
 * NOTE: This internally calls CGL_net_https_request
 *
 * @param host The host to connect to (Ex: www.google.com)
 * @param path The path to request (Ex: /search)
 * @param buffer The buffer to store the response in (output)
 * @param size The size of the buffer (input) and the size of the response (output)
 * @param accept The accept header to send
 * @param user_agent The user agent header to send
 * @param body The request body to send
 * @return HTTP status code is successful, 0 otherwise
*/
CGL_int CGL_net_https_post(const char* host, const char* path, void* buffer, size_t* size, const char* accept, const char* user_agent, const char* body);


struct CGL_net_ssl_socket;
typedef struct CGL_net_ssl_socket CGL_net_ssl_socket;

/** @brief Creates a new SSL socket
 *
 * This function creates a new SSL socket from
 * the given socket.
 *
 * NOTE: (1) The socket object must be connected before
 *           calling this function.
 *       (2) The socket object will automatically be
 *           destroyed when the SSL socket is destroyed.
 *  *
 * @param socket The socket to create the SSL socket from
 * @return The new SSL socket
*/
CGL_net_ssl_socket* CGL_net_ssl_socket_create(CGL_net_socket* socket);

/** @brief Sends data over the SSL socket
 *
 * This function sends data over the SSL socket.
 *
 * @param socket The SSL socket to send data over
 * @param buffer The buffer to send
 * @param size The size of the buffer
 * @param size_sent The size of the data sent
 * @return CGL_TRUE if successful, CGL_FALSE otherwise
*/
CGL_bool CGL_net_ssl_socket_send(CGL_net_ssl_socket* socket, void* buffer, size_t size, size_t* size_sent);

/** @brief Receives data over the SSL socket
 *
 * This function receives data over the SSL socket.
 *
 * @param socket The SSL socket to receive data over
 * @param buffer The buffer to store the data in
 * @param size The size of the buffer
 * @param size_recieved The size of the data recieved
 * @return CGL_TRUE if successful, CGL_FALSE otherwise
*/

CGL_bool CGL_net_ssl_socket_recv(CGL_net_ssl_socket* socket, void* buffer, size_t size, size_t* size_recieved);

/** @brief Destroys the SSL socket
 *
 * This function destroys the SSL socket.
 * This also destroys the socket object.
 *
 * @param socket The SSL socket to destroy
 * @return returns nothing
*/
CGL_void CGL_net_ssl_socket_destroy(CGL_net_ssl_socket* soc);

/** @brief Logs the SSL errors
 *
 * This function logs the SSL errors if any.
 *
 * @return returns nothing
*/
CGL_void CGL_net_ssl_log_errors();

#endif

#endif

// utils
#if 1
// CGL utils

#ifndef CGL_RAND_GEN_WITH_PROBABILITY_MAX_COUNT
#define CGL_RAND_GEN_WITH_PROBABILITY_MAX_COUNT 100000
#endif

#define CGL_UTILS_FAST_RAND_MAX 32767

CGL_void CGL_utils_sleep(const CGL_sizei milis);
CGL_byte* CGL_utils_read_file(const CGL_byte* path, size_t* size); // read file into memory
const CGL_byte* CGL_utils_get_executable_path();
const CGL_byte* CGL_utils_get_executable_directory();
CGL_sizei CGL_utils_get_file_size(const CGL_byte* path);
CGL_bool CGL_utils_append_file(const CGL_byte* path, const CGL_byte* data, size_t size);
CGL_bool CGL_utils_write_file(const CGL_byte* path, const CGL_byte* data, size_t size); // write data to file
CGL_float CGL_utils_get_time();
CGL_void CGL_utils_get_timestamp(char* buffer);
CGL_bool CGL_utils_is_little_endian();
CGL_sizei CGL_utils_get_random_with_probability(CGL_float* probabilities, CGL_sizei count);
CGL_void CGL_utils_reverse_bytes(void* data, size_t size);
CGL_void CGL_utils_little_endian_to_current(void* data, size_t size);
CGL_void CGL_utils_big_endian_to_current(void* data, size_t size);
CGL_void CGL_utils_fast_srand(CGL_int seed);
CGL_int CGL_utils_fast_rand();
CGL_ulong CGL_utils_xorshf96();
CGL_void CGL_utils_srand31(CGL_uint seed);
CGL_uint CGL_utils_rand31();

#define CGL_utils_is_point_in_rect(px, py, x, y, sx, sy, scx, scy) (bool)((px) >= (x) * (scx) && (px) <= ((x) + (sx)) * (scx) && (py) >= (y) * (scy) && (py) <= ((y) + (sy)) * (scy))
#define CGL_utils_random_float() ((float)rand() / (float)RAND_MAX)
#define CGL_utils_random_float_in_range(min, max) (CGL_utils_random_float() * (max - min) + min)
#define CGL_utils_random_int(min, max) (rand() % (max - min + 1) + min)
#define CGL_utils_random_bool() (rand() % 2)
#define CGL_utils_random_vec2(min, max) (CGL_vec2_init(CGL_utils_random_float() * (max.x - min.x) + min.x, CGL_utils_random_float() * (max.y - min.y) + min.y))
#define CGL_utils_random_vec3(min, max) (CGL_vec3_init(CGL_utils_random_float() * (max.x - min.x) + min.x, CGL_utils_random_float() * (max.y - min.y) + min.y, CGL_utils_random_float() * (max.z - min.z) + min.z))
#define CGL_utils_random_vec4(min, max) (CGL_vec4_init(CGL_utils_random_float() * (max.x - min.x) + min.x, CGL_utils_random_float() * (max.y - min.y) + min.y, CGL_utils_random_float() * (max.z - min.z) + min.z, CGL_utils_random_float() * (max.w - min.w) + min.w))
#define CGL_utils_random_color() (CGL_vec4_init(CGL_utils_random_float(), CGL_utils_random_float(), CGL_utils_random_float(), 1.0f))
#define CGL_utils_clamp(x, minl, maxl) (x < minl ? minl : (x > maxl ? maxl : x))
#define CGL_utils_array_size(array) (sizeof(array) / sizeof(array[0]))
#define CGL_utils_max(a, b) ( ((a) > (b)) ? (a) : (b) )
#define CGL_utils_min(a, b) ( ((a) < (b)) ? (a) : (b) )
#define CGL_utils_mix(x, y, f) (x * f + y * (1.0f - f))
#define CGL_utils_lerp(a, b, t) (a + (b - a) * t)
#define CGL_utils_square(x) ((x) * (x))
#define CGL_utils_cube(x) ((x) * (x) * (x))
#define CGL_utils_map(x, in_min, in_max, out_min, out_max) ( ((x) - (in_min)) * ((out_max) - (out_min)) / ((in_max) - (in_min)) + (out_min) )
CGL_float CGL_utils_sigmoid(CGL_float x);
CGL_float CGL_utils_sigmoid_derivative(CGL_float x);
CGL_float CGL_utils_relu(CGL_float x);
CGL_float CGL_utils_relu_derivative(CGL_float x);
CGL_float CGL_utils_tanh(CGL_float x);
CGL_float CGL_utils_tanh_derivative(CGL_float x);
CGL_float CGL_utils_step(CGL_float x);
CGL_float CGL_utils_step_derivative(CGL_float x);
CGL_float CGL_utils_relu_leaky(CGL_float x);
CGL_float CGL_utils_relu_leaky_derivative(CGL_float x);
CGL_float CGL_utils_relu_smooth(CGL_float x);
CGL_float CGL_utils_relu_smooth_derivative(CGL_float x);
// CGL_vec3 CGL_utils_hsl_to_rgb(CGL_vec3 hsv);

#ifndef CGL_QUICK_SORT_SWAP_BUFFER_SIZE
#define CGL_QUICK_SORT_SWAP_BUFFER_SIZE 1024
#endif
CGL_bool CGL_utils_quick_sort(CGL_void* array, CGL_sizei item_count, CGL_sizei item_size, CGL_int(*comparator)(const CGL_void*, const CGL_void*));

#define CGL_malloc(size) malloc(size)
#define CGL_realloc(ptr, size) realloc(ptr, size)
#define CGL_free(ptr) free(ptr)
#define CGL_exit(code) exit(code)

#define CGL_CONSOLE_COLOR_RESET  0
#define CGL_CONSOLE_COLOR_RED    1
#define CGL_CONSOLE_COLOR_GREEN  2
#define CGL_CONSOLE_COLOR_GRAY   3
#define CGL_CONSOLE_COLOR_BLUE   4

CGL_void CGL_console_set_color(uint8_t color);

CGL_void CGL_printf_red(const char* format, ...);
CGL_void CGL_printf_green(const char* format, ...);
CGL_void CGL_printf_gray(const char* format, ...);
CGL_void CGL_printf_blue(const char* format, ...);
CGL_void CGL_console_progress_bar(CGL_float progress, CGL_int width, CGL_byte* prefix, CGL_byte* suffix, CGL_byte complete_char, CGL_byte incomplete_char);

#endif

#define CGL_LOG_LEVEL_TRACE         0
#define CGL_LOG_LEVEL_INFO          1
#define CGL_LOG_LEVEL_WARN          2
#define CGL_LOG_LEVEL_ERROR         3 
#define CGL_LOG_LEVEL_INTERNAL      4 
#define CGL_LOGGER_MAX_LOG_FILES    32
#define CGL_LOGGER_LOG_BUFFER_SIZE  (1024 * 4)

#ifndef CGL_ENABLE_CONSOLE_LOGGING
#define CGL_ENABLE_CONSOLE_LOGGING true
#endif

#ifndef CGL_DISABLE_LOGGER


struct CGL_logger_context;
typedef struct CGL_logger_context CGL_logger_context;

CGL_void CGL_logger_init(bool enable_console_logging);
CGL_void CGL_logger_shutdown();
CGL_logger_context* CGL_logger_get_context();
CGL_void CGL_logger_set_context(CGL_logger_context* context);
bool CGL_logger_attach_log_file(const char* path);
bool CGL_logger_detach_log_file(const char* path);
CGL_void CGL_logger_flush();
CGL_void CGL_logger_disable_console_logging();
CGL_void CGL_logger_enable_console_logging();
CGL_void CGL_logger_log(CGL_int level, const char* log_format, ...);

#define CGL_trace(...)        CGL_logger_log(CGL_LOG_LEVEL_TRACE, __VA_ARGS__)
#define CGL_info(...)         CGL_logger_log(CGL_LOG_LEVEL_INFO, __VA_ARGS__)
#define CGL_warn(...)         CGL_logger_log(CGL_LOG_LEVEL_WARN, __VA_ARGS__)
#define CGL_error(...)        CGL_logger_log(CGL_LOG_LEVEL_ERROR, __VA_ARGS__)
#ifndef CGL_DISABLE_INTERNAL_LOGGING
#define CGL_log_internal(...) CGL_logger_log(CGL_LOG_LEVEL_INTERNAL, __VA_ARGS__)
#endif

#else
#define CGL_logger_init(...)
#define CGL_logger_shutdown()
#define CGL_logger_get_context() NULL
#define CGL_logger_set_context(...)
#define CGL_logger_attach_log_file(path)
#define CGL_logger_dettach_log_file(path)
#define CGL_logger_flush()
#define CGL_logger_disable_console_logging()
#define CGL_logger_enable_console_logging()
#define CGL_logger_log(...)
#define CGL_info(...)
#define CGL_trace(...)
#define CGL_warn(...)
#define CGL_error(...)
#define CGL_log_internal(...)
#endif

// math and data structures
#if 1 // Just to use code folding

// data structures

struct CGL_list;
typedef struct CGL_list CGL_list;

CGL_list* CGL_list_create(size_t item_size, size_t initial_capacity);
CGL_void CGL_list_destroy(CGL_list* list);
CGL_void CGL_list_set_increase_factor(CGL_list* list, CGL_float increase_factor);
CGL_float CGL_list_get_increase_factor(CGL_list* list);
CGL_sizei CGL_list_get_item_size(CGL_list* list);
CGL_sizei CGL_list_get_size(CGL_list* list);
CGL_sizei CGL_list_get_capacity(CGL_list* list);
CGL_sizei  CGL_list_push(CGL_list* list, void* data);
CGL_sizei CGL_list_pop(CGL_list* list, void* data);
CGL_void* CGL_list_get(CGL_list* list, size_t index, void* data);
CGL_void* CGL_list_get_random(CGL_list* list, void* data);
CGL_void* CGL_list_set(CGL_list* list, size_t index, void* data);
CGL_bool CGL_list_is_empty(CGL_list* list);
CGL_void CGL_list_clear(CGL_list* list);
CGL_sizei CGL_list_find(CGL_list* list, void* data);
CGL_void CGL_list_reserve(CGL_list* list, size_t size);
CGL_void CGL_list_fill(CGL_list* list, size_t size);

#ifndef CGL_HASHTABLE_MAX_KEY_SIZE
#define CGL_HASHTABLE_MAX_KEY_SIZE 256
#endif

#ifndef CGL_HASHTABLE_ENTRY_STATIC_VALUE_SIZE
#define CGL_HASHTABLE_ENTRY_STATIC_VALUE_SIZE sizeof(uint64_t)
#endif

struct CGL_hashtable_entry;
typedef struct CGL_hashtable_entry CGL_hashtable_entry;

struct CGL_hashtable;
typedef struct CGL_hashtable CGL_hashtable;

struct CGL_hashtable_iterator;
typedef struct CGL_hashtable_iterator CGL_hashtable_iterator;

typedef uint32_t(*CGL_hash_function)(const void*, size_t);

// set key size to 0 if it is a string (it will be auto calculated using strlen)
CGL_hashtable* CGL_hashtable_create(size_t table_size, size_t key_size, size_t initial_capacity);
CGL_void CGL_hashtable_set_growth_rate(CGL_hashtable* table, CGL_float rate);
size_t CGL_hashtable_get_size(CGL_hashtable* table);
CGL_void CGL_hashtable_destroy(CGL_hashtable* table);
CGL_void CGL_hashtable_set(CGL_hashtable* table, const void* key, const void* value, size_t value_size);
size_t CGL_hashtable_get(CGL_hashtable* table, const void* key, void* value);
CGL_void* CGL_hashtable_get_ptr(CGL_hashtable* table, const void* key, size_t* value);
bool CGL_hashtable_exists(CGL_hashtable* table, const void* key);
bool CGL_hashtable_remove(CGL_hashtable* table, const void* key);
CGL_void CGL_hashtable_set_hash_function(CGL_hashtable* table, CGL_hash_function hash_function);
CGL_hashtable_iterator* CGL_hashtable_iterator_create(CGL_hashtable* table);
CGL_void CGL_hashtable_iterator_destroy(CGL_hashtable_iterator* iterator);
CGL_void CGL_hashtable_iterator_reset(CGL_hashtable_iterator* iterator);
bool CGL_hashtable_iterator_next(CGL_hashtable_iterator* iterator, void* key, void* data, size_t* size);
bool CGL_hashtable_iterator_curr(CGL_hashtable_iterator* iterator, void* key, void* data, size_t* size);
CGL_void* CGL_hashtable_iterator_curr_key(CGL_hashtable_iterator* iterator);

// getter setters for data types
#define CGL_DECLARE_HASHTABLE_GETTER_SETTER(type) \
    inline type CGL_hashtable_get_##type (CGL_hashtable* table, const void* key)\
    { \
        type value; \
        CGL_hashtable_get(table, key, &value); \
        return value; \
    } \
    \
    inline void CGL_hashtable_set_##type (CGL_hashtable* table, const void* key, type value) \
    { \
        CGL_hashtable_set(table, key, &value, sizeof(value)); \
    }

#ifndef CDL_DONT_DECLARE_HASHTABLE_STD_GETTER_SETTERS

inline void CGL_hashtable_set_string(CGL_hashtable* table, const void* key, const char* value)
{
	CGL_hashtable_set(table, key, value, strlen(value) + 1);
}

CGL_DECLARE_HASHTABLE_GETTER_SETTER(int8_t)
CGL_DECLARE_HASHTABLE_GETTER_SETTER(int16_t)
CGL_DECLARE_HASHTABLE_GETTER_SETTER(int32_t)
CGL_DECLARE_HASHTABLE_GETTER_SETTER(int64_t)
CGL_DECLARE_HASHTABLE_GETTER_SETTER(uint8_t)
CGL_DECLARE_HASHTABLE_GETTER_SETTER(uint16_t)
CGL_DECLARE_HASHTABLE_GETTER_SETTER(uint32_t)
CGL_DECLARE_HASHTABLE_GETTER_SETTER(uint64_t)
CGL_DECLARE_HASHTABLE_GETTER_SETTER(float)
CGL_DECLARE_HASHTABLE_GETTER_SETTER(double)
CGL_DECLARE_HASHTABLE_GETTER_SETTER(bool)
CGL_DECLARE_HASHTABLE_GETTER_SETTER(int)
CGL_DECLARE_HASHTABLE_GETTER_SETTER(long)
CGL_DECLARE_HASHTABLE_GETTER_SETTER(short)
CGL_DECLARE_HASHTABLE_GETTER_SETTER(char)
CGL_DECLARE_HASHTABLE_GETTER_SETTER(intptr_t)
CGL_DECLARE_HASHTABLE_GETTER_SETTER(uintptr_t)

#endif


// algorithms
uint32_t CGL_utils_crc32(const void* data, size_t size);
uint64_t CGL_utils_crc64(const void* data, size_t size);
CGL_void CGL_utils_rot13(const char* data_in, char* data_out);
uint32_t CGL_utils_super_fast_hash(const void* data, size_t size);

// threads
#ifndef CGL_EXCLUDES_THREADS
struct CGL_thread;
typedef struct CGL_thread CGL_thread;

#ifdef CGL_WINDOWS
typedef void (*CGL_thread_function)(void*);
#else
typedef void* (*CGL_thread_function)(void*);
#endif

struct CGL_mutex;
typedef struct CGL_mutex CGL_mutex;

CGL_thread* CGL_thread_create();
bool CGL_thread_start(CGL_thread* thread, CGL_thread_function function, void* argument);
CGL_void CGL_thread_destroy(CGL_thread* thread);
bool CGL_thread_join(CGL_thread* thread);
bool CGL_thread_joinable(CGL_thread* thread);
bool CGL_thread_is_running(CGL_thread* thread);

uintptr_t CGL_thread_get_id(CGL_thread* thread);

CGL_mutex* CGL_mutex_create(bool set);
CGL_void CGL_mutex_destroy(CGL_mutex* mutex);
int CGL_mutex_lock(CGL_mutex* mutex, uint64_t timeout);
CGL_void CGL_mutex_release(CGL_mutex* mutex);
#endif

// math

struct CGL_vec2
{
	CGL_float x;
	CGL_float y;
#ifdef __cplusplus
	CGL_vec2() : x(0), y(0) {}
	CGL_vec2(CGL_float x, CGL_float y) : x(x), y(y) {}
#endif
};
typedef struct CGL_vec2 CGL_vec2;

struct CGL_vec3
{
	CGL_float x;
	CGL_float y;
	CGL_float z;
#ifdef __cplusplus
	CGL_vec3() : x(0), y(0), z(0) {}
	CGL_vec3(CGL_float x, CGL_float y, CGL_float z) : x(x), y(y), z(z) {}
#endif
};
typedef struct CGL_vec3 CGL_vec3;

struct CGL_vec4
{
	CGL_float x;
	CGL_float y;
	CGL_float z;
	CGL_float w;
#ifdef __cplusplus
	CGL_vec4() : x(0), y(0), z(0), w(0) {}
	CGL_vec4(CGL_float x, CGL_float y, CGL_float z, CGL_float w) : x(x), y(y), z(z), w(w) {}
#endif
};
typedef struct CGL_vec4 CGL_vec4;
typedef struct CGL_vec4 CGL_color;

struct CGL_ivec4
{
	CGL_int x;
	CGL_int y;
	CGL_int z;
	CGL_int w;
#ifdef __cplusplus
	CGL_ivec4() : x(0), y(0), z(0), w(0) {}
	CGL_ivec4(CGL_int x, CGL_int y, CGL_int z, CGL_int w) : x(x), y(y), z(z), w(w) {}
#endif
};
typedef struct CGL_ivec4 CGL_ivec4;

struct CGL_mat3
{
	CGL_float m[9];
#ifdef __cplusplus
	CGL_mat3()
	{
		m[0] = 1; m[3] = 0; m[6] = 0;
		m[1] = 0; m[4] = 1; m[7] = 0;
		m[2] = 0; m[5] = 0; m[8] = 1;
	}

	CGL_mat3(CGL_float m0, CGL_float m1, CGL_float m2, CGL_float m3, CGL_float m4, CGL_float m5, CGL_float m6, CGL_float m7, CGL_float m8)
	{
		m[0] = m0; m[3] = m1; m[6] = m2;
		m[1] = m3; m[4] = m4; m[7] = m5;
		m[2] = m6; m[5] = m7; m[8] = m8;
	}
#endif
};
typedef struct CGL_mat3 CGL_mat3;

struct CGL_mat4
{
	CGL_float m[16];
#ifdef __cplusplus
	CGL_mat4()
	{
		m[0] = 1;   m[4] = 0;   m[8] = 0;     m[12] = 0;
		m[1] = 0;   m[5] = 1;   m[9] = 0;     m[13] = 0;
		m[2] = 0;   m[6] = 0;   m[10] = 1;    m[14] = 0;
		m[3] = 0;   m[7] = 0;   m[11] = 0;    m[15] = 1;
	}

	CGL_mat4(CGL_float m0, CGL_float m1, CGL_float m2, CGL_float m3,
		CGL_float m4, CGL_float m5, CGL_float m6, CGL_float m7,
		CGL_float m8, CGL_float m9, CGL_float m10, CGL_float m11,
		CGL_float m12, CGL_float m13, CGL_float m14, CGL_float m15)
	{
		m[0] = m0;   m[4] = m1;   m[8] = m2;     m[12] = m3;
		m[1] = m4;   m[5] = m5;   m[9] = m6;     m[13] = m7;
		m[2] = m8;   m[6] = m9;   m[10] = m10;   m[14] = m11;
		m[3] = m12;  m[7] = m13;  m[11] = m14;   m[15] = m15;
	}
#endif
};
typedef struct CGL_mat4 CGL_mat4;

struct CGL_quat
{
	CGL_vec3 vec;
	CGL_float w;
#ifdef __cplusplus
	CGL_quat() : vec(CGL_vec3(0, 0, 0)), w(0) {}
	CGL_quat(CGL_float x, CGL_float y, CGL_float z, CGL_float w) : vec(CGL_vec3(x, y, z)), w(w) {}
#endif
};
typedef struct CGL_quat CGL_quat;

// math functions with macros

#define CGL_PI (3.14159265358979323846f)
#define CGL_2PI (6.28318530717958647692f)
#define CGL_PI_2 (1.57079632679489661923f)
#define CGL_E (2.71828182845904523536f)
#define CGL_SQRT2 (1.41421356237309504880f)
#define CGL_SQRT3 (1.73205080756887729352f)
#define CGL_SQRT5 (2.23606797749978969640f)
#define CGL_SQRT6 (2.44948974278317809820f)
#define CGL_SQRT7 (2.64575131106459059050f)
#define CGL_SQRT8 (2.82842712474619009760f)
#define CGL_deg_to_rad(deg) ((deg) * (CGL_PI / 180.0f))
#define CGL_rad_to_deg(rad) ((rad) * (180.0f / CGL_PI))

#define CGL_float_lerp(a, b, t) (((a) * (1.0f - (t))) + ((b) * (t)))
CGL_float CGL_float_quadratic_lerp(CGL_float a, CGL_float b, CGL_float c, CGL_float t);
CGL_float CGL_float_cubic_lerp(CGL_float a, CGL_float b, CGL_float c, CGL_float d, CGL_float t);


#ifdef __cplusplus
#define CGL_vec2_init(x, y) CGL_vec2(x, y)
#else
#define CGL_vec2_init(x, y) ((CGL_vec2){(x), (y)})
#endif

#define CGL_vec2_add(a, b) CGL_vec2_init(a.x + b.x, a.y + b.y)
#define CGL_vec2_add_scaled(a, b, scale) CGL_vec2_init((a).x + (b).x * (scale), (a).y + (b).y * (scale))
#define CGL_vec2_sub(a, b) CGL_vec2_init(a.x - b.x, a.y - b.y)
#define CGL_vec2_mul(a, b) CGL_vec2_init(a.x * b.x, a.y * b.y)
#define CGL_vec2_div(a, b) CGL_vec2_init(a.x / b.x, a.y / b.y)
#define CGL_vec2_scale(a, s) CGL_vec2_init(a.x * (s), a.y * (s))
#define CGL_vec2_dot(a, b) (a.x * b.x + a.y * b.y)
#define CGL_vec2_length(a) sqrtf(a.x * a.x + a.y * a.y)
#define CGL_vec2_normalize(a) { CGL_float __CGL_vector_length##__LINE__ = 1.0f / CGL_vec2_length(a); a.x *= __CGL_vector_length##__LINE__; a.y *= __CGL_vector_length##__LINE__; }
#define CGL_vec2_lerp(a, b, t) CGL_vec2_init(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t)
#define CGL_vec2_min(a, b) CGL_vec2_init(a.x < b.x ? a.x : b.x, a.y < b.y ? a.y : b.y)
#define CGL_vec2_max(a, b) CGL_vec2_init(a.x > b.x ? a.x : b.x, a.y > b.y ? a.y : b.y)
#define CGL_vec2_equal(a, b) (a.x == b.x && a.y == b.y)
#define CGL_vec2_rotate_about_point(a, p, theta) CGL_vec2_init(((a.x - p.x) * cosf(theta) - (a.y - p.y) * sinf(theta) ), ((a.x - p.x) * sinf(theta) + (a.y - p.y) * cosf(theta)))
#define CGL_vec2_centroid_of_triangle(a, b, c) CGL_vec2_init((a.x + b.x + c.x) / 3.0f, (a.y + b.y + c.y) / 3.0f)
#define CGL_vec2_from_angle(theta) CGL_vec2_init(cosf(theta), sinf(theta))
#define CGL_vec2_angle_between(a, b) acosf(CGL_vec2_dot(a, b) / (CGL_vec2_length(a) * CGL_vec2_length(b)))
#define CGL_vec2_angle(a) atan2f(a.y, a.x)
#define CGL_vec2_angle_from_to(a, b) atan2f(b.y - a.y, b.x - a.x)
#define CGL_vec2_reflect(a, n) CGL_vec2_sub(a, CGL_vec2_scale(n, 2.0f * CGL_vec2_dot(a, n)))
#define CGL_vec2_perpendicular(a) CGL_vec2_init(-a.y, a.x)
#define CGL_vec2_create_from_higher_dimension(a) CGL_vec2_init(a.x, a.y)
#define CGL_vec2_elem_get(a, i) ((float*)&a)[i]
#define CGL_vec2_elem_set(a, i, v) (((float*)&a)[i] = v)
#define CGL_vec2_distance(a, b) (CGL_float)(sqrtf(((a).x - (b).x) * ((a).x - (b).x) + ((a).y - (b).y) * ((a).y - (b).y)))
CGL_vec2 CGL_vec2_triple_product(CGL_vec2 a, CGL_vec2 b, CGL_vec2 c);

#ifdef __cplusplus
#define CGL_vec3_init(x, y, z) CGL_vec3(x, y, z)
#else
#define CGL_vec3_init(x, y, z) ((CGL_vec3){(x), (y), (z)})
#endif
#define CGL_vec3_add(a, b) CGL_vec3_init(a.x + b.x, a.y + b.y, a.z + b.z)
#define CGL_vec3_add_scaled(a, b, scale) CGL_vec3_init((a).x + (b).x * (scale), (a).y + (b).y * (scale), (a).z + (b).z * (scale))
#define CGL_vec3_sub(a, b) CGL_vec3_init(a.x - b.x, a.y - b.y, a.z - b.z)
#define CGL_vec3_mul(a, b) CGL_vec3_init(a.x * b.x, a.y * b.y, a.z * b.z)
#define CGL_vec3_div(a, b) CGL_vec3_init(a.x / b.x, a.y / b.y, a.z / b.z)
#define CGL_vec3_scale(a, s) CGL_vec3_init(a.x * (s), a.y * (s), a.z * (s))
#define CGL_vec3_dot(a, b) (a.x * b.x + a.y * b.y + a.z * b.z)
#define CGL_vec3_cross(a, b) CGL_vec3_init(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x)
#define CGL_vec3_length(a) sqrtf(a.x * a.x + a.y * a.y + a.z * a.z)
#define CGL_vec3_distance(a, b) (CGL_float)(sqrtf(((a).x - (b).x) * ((a).x - (b).x) + ((a).y - (b).y) * ((a).y - (b).y) + ((a).z - (b).z) * ((a).z - (b).z)))
#define CGL_vec3_normalize(a) { CGL_float __CGL_vector_length##__LINE__ = 1.0f / CGL_vec3_length(a); a.x *= __CGL_vector_length##__LINE__; a.y *= __CGL_vector_length##__LINE__; a.z *= __CGL_vector_length##__LINE__; }
#define CGL_vec3_lerp(a, b, t) CGL_vec3_init(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t)
#define CGL_vec3_min(a, b) CGL_vec3_init(a.x < b.x ? a.x : b.x, a.y < b.y ? a.y : b.y, a.z < b.z ? a.z : b.z)
#define CGL_vec3_max(a, b) CGL_vec3_init(a.x > b.x ? a.x : b.x, a.y > b.y ? a.y : b.y, a.z > b.z ? a.z : b.z)
#define CGL_vec3_equal(a, b) (a.x == b.x && a.y == b.y && a.z == b.z)
#define CGL_vec3_rotate_x(a, theta) CGL_vec3_init(a.x, a.y * cosf(theta) - a.z * sinf(theta), a.y * sinf(theta) + a.z * cosf(theta))
#define CGL_vec3_rotate_y(v, theta) CGL_vec3_init(v.x * cosf(theta) + v.z * sinf(theta), v.y, -v.x * sinf(theta) + v.z * cosf(theta))
#define CGL_vec3_rotate_z(v, theta) CGL_vec3_init(v.x * cosf(theta) - v.y * sinf(theta), v.x * sinf(theta) + v.y * cosf(theta), v.z)
#define CGL_vec3_centroid_of_triangle(a, b, c) CGL_vec3_init((a.x + b.x + c.x) / 3.0f, (a.y + b.y + c.y) / 3.0f, (a.z + b.z + c.z) / 3.0f)
#define CGL_vec3_from_angle(theta) CGL_vec3_init(cosf(theta), sinf(theta), 0.0f)
#define CGL_vec3_angle_between(a, b) acosf(CGL_vec3_dot(a, b) / (CGL_vec3_length(a) * CGL_vec3_length(b)))
#define CGL_vec3_from_spherical_coordinates(r, theta, phi) CGL_vec3_init(r * sinf(theta) * cosf(phi), r * sinf(theta) * sinf(phi), r * cosf(theta))
#define CGL_vec3_to_spherical_coordinates(a) CGL_vec3_init(sqrtf(a.x * a.x + a.y * a.y + a.z * a.z), acosf(a.z / sqrtf(a.x * a.x + a.y * a.y + a.z * a.z)), atan2f(a.y, a.x))
#define CGL_vec3_from_higher_dimension(a) CGL_vec3_init(a.x, a.y, a.z)
#define CGL_vec3_from_vec2(a, z) CGL_vec3_init(a.x, a.y, z)
#define CGL_vec3_elem_get(a, i) ((float*)&a)[i]
#define CGL_vec3_elem_set(a, i, v) (((float*)&a)[i] = v)
CGL_vec3 CGL_vec3_reflect(CGL_vec3 a, CGL_vec3 n);
CGL_vec3 CGL_vec3_rotate_about_axis(CGL_vec3 v, CGL_vec3 axis, CGL_float theta);
CGL_vec3 CGL_vec3_triple_product(CGL_vec3 a, CGL_vec3 b, CGL_vec3 c);
CGL_void CGL_vec3_calculate_orthonormal_basis_from_one_vector(CGL_vec3 a, CGL_vec3* pb, CGL_vec3* pc);

#ifdef __cplusplus
#define CGL_vec4_init(x, y, z, w) CGL_vec4(x, y, z, w)
#else
#define CGL_vec4_init(x, y, z, w) ((CGL_vec4){x, y, z, w})
#endif
#define CGL_vec4_add(a, b) CGL_vec4_init(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w)
#define CGL_vec4_sub(a, b) CGL_vec4_init(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w)
#define CGL_vec4_mul(a, b) CGL_vec4_init(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w)
#define CGL_vec4_div(a, b) CGL_vec4_init(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w)
#define CGL_vec4_scale(a, s) CGL_vec4_init(a.x * s, a.y * s, a.z * s, a.w * s)
#define CGL_vec4_dot(a, b) (a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w)
#define CGL_vec4_lerp(a, b, t) CGL_vec4_init(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t)
#define CGL_vec4_min(a, b) CGL_vec4_init(a.x < b.x ? a.x : b.x, a.y < b.y ? a.y : b.y, a.z < b.z ? a.z : b.z, a.w < b.w ? a.w : b.w)
#define CGL_vec4_max(a, b) CGL_vec4_init(a.x > b.x ? a.x : b.x, a.y > b.y ? a.y : b.y, a.z > b.z ? a.z : b.z, a.w > b.w ? a.w : b.w)
#define CGL_vec4_equal(a, b) (a.x == b.x && a.y == b.y && a.z == b.z && a.w == b.w)
#define CGL_vec4_normalize(a) { CGL_float __CGL_vector_length##__LINE__ = 1.0f / CGL_vec4_length(a); a.x *= __CGL_vector_length##__LINE__; a.y *= __CGL_vector_length##__LINE__; a.z *= __CGL_vector_length##__LINE__; a.w *= __CGL_vector_length##__LINE__; }
#define CGL_vec4_normalize_vec3(a) { CGL_float __CGL_vector_length##__LINE__ = 1.0f / CGL_vec3_length(a); a.x *= __CGL_vector_length##__LINE__; a.y *= __CGL_vector_length##__LINE__; a.z *= __CGL_vector_length##__LINE__; }
#define CGL_vec4_centroid_of_triangle(a, b, c) CGL_vec4_init((a.x + b.x + c.x) / 3.0f, (a.y + b.y + c.y) / 3.0f, (a.z + b.z + c.z) / 3.0f, (a.w + b.w + c.w) / 3.0f)
#define CGL_vec4_from_vec3(a, w) CGL_vec4_init(a.x, a.y, a.z, w)
#define CGL_vec4_from_vec2(a, z, w) CGL_vec4_init(a.x, a.y, z, w)
#define CGL_vec4_elem_get(a, i) ((float*)&a)[i]
#define CGL_vec4_elem_set(a, i, v) (((float*)&a)[i] = v)
CGL_vec4 CGL_vec4_triple_product(CGL_vec4 a, CGL_vec4 b, CGL_vec4 c);

#ifdef __cplusplus
#define CGL_ivec4_init(x, y, z, w) CGL_ivec4(x, y, z, w)
#else
#define CGL_ivec4_init(x, y, z, w) ((CGL_ivec4){x, y, z, w})
#endif

#ifdef __cplusplus
#define CGL_mat3_init(a, b, c, d, e, f, g, h, i) CGL_mat3(a, b, c, d, e, f, g, h, i)
#else
#define CGL_mat3_init(m00, m01, m02, m10, m11, m12, m20, m21, m22) (CGL_mat3) \
{ \
    { \
        m00, m10, m20, \
        m01, m11, m21, \
        m02, m12, m22  \
    } \
}
#endif

#define CGL_mat3_add(a, b) (CGL_mat3){a.m[0] + b.m[0], a.m[1] + b.m[1], a.m[2] + b.m[2], a.m[3] + b.m[3], a.m[4] + b.m[4], a.m[5] + b.m[5], a.m[6] + b.m[6], a.m[7] + b.m[7], a.m[8] + b.m[8]}
#define CGL_mat3_sub(a, b) (CGL_mat3){a.m[0] - b.m[0], a.m[1] - b.m[1], a.m[2] - b.m[2], a.m[3] - b.m[3], a.m[4] - b.m[4], a.m[5] - b.m[5], a.m[6] - b.m[6], a.m[7] - b.m[7], a.m[8] - b.m[8]}
CGL_float CGL_mat3_det(CGL_mat3 a);
CGL_float CGL_mat3_trace(CGL_mat3 a);
CGL_mat3 CGL_mat3_transpose(CGL_mat3 a);

#define CGL_mat3_zero() CGL_mat3_init( \
    0.0f, 0.0f, 0.0f, \
    0.0f, 0.0f, 0.0f, \
    0.0f, 0.0f, 0.0f  \
)

#define CGL_mat3_identity() CGL_mat3_init( \
    1.0f, 0.0f, 0.0f, \
    0.0f, 1.0f, 0.0f, \
    0.0f, 0.0f, 1.0f  \
)

#define CGL_mat3_log(a) CGL_info( \
    "\n{\n" \
    "    {%f, %f, %f}\n" \
    "    {%f, %f, %f}\n" \
    "    {%f, %f, %f}\n" \
    "}\n", \
    a.m[0], a.m[3], a.m[6], \
    a.m[1], a.m[4], a.m[7], \
    a.m[2], a.m[5], a.m[8]  \
)


/*
#define CGL_mat4_init(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) (CGL_mat4) \
{ \
	{ \
		m00, m01, m02, m03, \
		m10, m11, m12, m13, \
		m20, m21, m22, m23, \
		m30, m31, m32, m33 \
	} \
}
*/

#ifdef __cplusplus
#define CGL_mat4_init(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) CGL_mat4(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)
#else
#define CGL_mat4_init(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) (CGL_mat4) \
{ \
    { \
        m00, m10, m20, m30, \
        m01, m11, m21, m31, \
        m02, m12, m22, m32, \
        m03, m13, m23, m33 \
    } \
}
#endif

#define CGL_mat4_add(a, b) CGL_mat_init( \
    CGL_mat4_elem_get(a, 0, 0) + CGL_mat4_elem_get(b, 0, 0), CGL_mat4_elem_get(a, 0, 1) + CGL_mat4_elem_get(b, 0, 1), CGL_mat4_elem_get(a, 0, 2) + CGL_mat4_elem_get(b, 0, 2), CGL_mat4_elem_get(a, 0, 3) + CGL_mat4_elem_get(b, 0, 3), \
    CGL_mat4_elem_get(a, 1, 0) + CGL_mat4_elem_get(b, 1, 0), CGL_mat4_elem_get(a, 1, 1) + CGL_mat4_elem_get(b, 1, 1), CGL_mat4_elem_get(a, 1, 2) + CGL_mat4_elem_get(b, 1, 2), CGL_mat4_elem_get(a, 1, 3) + CGL_mat4_elem_get(b, 1, 3), \
    CGL_mat4_elem_get(a, 2, 0) + CGL_mat4_elem_get(b, 2, 0), CGL_mat4_elem_get(a, 2, 1) + CGL_mat4_elem_get(b, 2, 1), CGL_mat4_elem_get(a, 2, 2) + CGL_mat4_elem_get(b, 2, 2), CGL_mat4_elem_get(a, 2, 3) + CGL_mat4_elem_get(b, 2, 3), \
    CGL_mat4_elem_get(a, 3, 0) + CGL_mat4_elem_get(b, 3, 0), CGL_mat4_elem_get(a, 3, 1) + CGL_mat4_elem_get(b, 3, 1), CGL_mat4_elem_get(a, 3, 2) + CGL_mat4_elem_get(b, 3, 2), CGL_mat4_elem_get(a, 3, 3) + CGL_mat4_elem_get(b, 3, 3)  \
)

#define CGL_mat4_sub(a, b) CGL_mat_init( \
    CGL_mat4_elem_get(a, 0, 0) - CGL_mat4_elem_get(b, 0, 0), CGL_mat4_elem_get(a, 0, 1) - CGL_mat4_elem_get(b, 0, 1), CGL_mat4_elem_get(a, 0, 2) - CGL_mat4_elem_get(b, 0, 2), CGL_mat4_elem_get(a, 0, 3) - CGL_mat4_elem_get(b, 0, 3), \
    CGL_mat4_elem_get(a, 1, 0) - CGL_mat4_elem_get(b, 1, 0), CGL_mat4_elem_get(a, 1, 1) - CGL_mat4_elem_get(b, 1, 1), CGL_mat4_elem_get(a, 1, 2) - CGL_mat4_elem_get(b, 1, 2), CGL_mat4_elem_get(a, 1, 3) - CGL_mat4_elem_get(b, 1, 3), \
    CGL_mat4_elem_get(a, 2, 0) - CGL_mat4_elem_get(b, 2, 0), CGL_mat4_elem_get(a, 2, 1) - CGL_mat4_elem_get(b, 2, 1), CGL_mat4_elem_get(a, 2, 2) - CGL_mat4_elem_get(b, 2, 2), CGL_mat4_elem_get(a, 2, 3) - CGL_mat4_elem_get(b, 2, 3), \
    CGL_mat4_elem_get(a, 3, 0) - CGL_mat4_elem_get(b, 3, 0), CGL_mat4_elem_get(a, 3, 1) - CGL_mat4_elem_get(b, 3, 1), CGL_mat4_elem_get(a, 3, 2) - CGL_mat4_elem_get(b, 3, 2), CGL_mat4_elem_get(a, 3, 3) - CGL_mat4_elem_get(b, 3, 3)  \
)

#define CGL_mat4_mul_scalar(a, s) CGL_mat4_init( \
    CGL_mat4_elem_get(a, 0, 0) * s, CGL_mat4_elem_get(a, 0, 1) * s, CGL_mat4_elem_get(a, 0, 2) * s, CGL_mat4_elem_get(a, 0, 3) * s, \
    CGL_mat4_elem_get(a, 1, 0) * s, CGL_mat4_elem_get(a, 1, 1) * s, CGL_mat4_elem_get(a, 1, 2) * s, CGL_mat4_elem_get(a, 1, 3) * s, \
    CGL_mat4_elem_get(a, 2, 0) * s, CGL_mat4_elem_get(a, 2, 1) * s, CGL_mat4_elem_get(a, 2, 2) * s, CGL_mat4_elem_get(a, 2, 3) * s, \
    CGL_mat4_elem_get(a, 3, 0) * s, CGL_mat4_elem_get(a, 3, 1) * s, CGL_mat4_elem_get(a, 3, 2) * s, CGL_mat4_elem_get(a, 3, 3) * s  \
)

CGL_mat4 CGL_mat4_mul(CGL_mat4 a, CGL_mat4 b);
CGL_float CGL_mat4_det(CGL_mat4 m);
CGL_float CGL_mat4_det_by_lu(CGL_mat4 m);
CGL_float CGL_mat4_det_by_gauss(CGL_mat4 m);
CGL_vec4 CGL_mat4_mul_vec4(CGL_mat4 m, CGL_vec4 v);
CGL_mat4 CGL_mat4_inverse(CGL_mat4 m);
CGL_mat4 CGL_mat4_transpose(CGL_mat4 m);
CGL_mat4 CGL_mat4_adjoint(CGL_mat4 m);
CGL_mat4 CGL_mat4_gauss_elim(CGL_mat4 m);
CGL_int CGL_mat4_rank(CGL_mat4 m);
CGL_float CGL_mat4_trace(CGL_mat4 m);
CGL_mat3 CGL_mat4_to_mat3(CGL_mat4 m);
CGL_mat4 CGL_mat4_from_mat3(CGL_mat3 m);
CGL_mat4 CGL_mat4_rotate_about_axis(CGL_vec3 axis, CGL_float angle);
CGL_mat4 CGL_mat4_look_at(CGL_vec3 eye, CGL_vec3 target, CGL_vec3 up);
CGL_mat4 CGL_mat4_lerp(CGL_mat4 a, CGL_mat4 b, CGL_float t);
CGL_void CGL_mat4_decompose_lu(CGL_mat4 m, CGL_mat4* l, CGL_mat4* u);

#define CGL_mat4_is_invertible(m) (CGL_mat4_det(m) != 0.0f)

//#define CGL_mat4_elem_get(mat, row, col) ((mat).m[row + col * 4])
//#define CGL_mat4_elem_set(mat, row, col, value) ((mat).m[row + col * 4] = value)

#define CGL_mat4_elem_get(mat, row, col) ((mat).m[row * 4 + col])
#define CGL_mat4_elem_set(mat, row, col, value) ((mat).m[row * 4 + col] = value)

#define CGL_mat3_elem_get(mat, row, col) ((mat).m[row + col * 3])
#define CGL_mat3_elem_set(mat, row, col, value) ((mat).m[row + col * 3] = value)

#define CGL_mat4_zero() CGL_mat4_init(\
    0.0f, 0.0f, 0.0f, 0.0f, \
    0.0f, 0.0f, 0.0f, 0.0f, \
    0.0f, 0.0f, 0.0f, 0.0f, \
    0.0f, 0.0f, 0.0f, 0.0f \
)

#define CGL_mat4_identity() CGL_mat4_init(\
    1.0f, 0.0f, 0.0f, 0.0f, \
    0.0f, 1.0f, 0.0f, 0.0f, \
    0.0f, 0.0f, 1.0f, 0.0f, \
    0.0f, 0.0f, 0.0f, 1.0f \
)

#define CGL_mat4_scale(x, y, z) CGL_mat4_init(\
    x, 0.0f, 0.0f, 0.0f, \
    0.0f, y, 0.0f, 0.0f, \
    0.0f, 0.0f, z, 0.0f, \
    0.0f, 0.0f, 0.0f, 1.0f \
)

#define CGL_mat4_translate(x, y, z) CGL_mat4_init(\
    1.0f, 0.0f, 0.0f, x, \
    0.0f, 1.0f, 0.0f, y, \
    0.0f, 0.0f, 1.0f, z, \
    0.0f, 0.0f, 0.0f, 1.0f \
)

#define CGL_mat4_rotate_x(angle) CGL_mat4_init(\
    1.0f, 0.0f, 0.0f, 0.0f, \
    0.0f, cosf(angle), -sinf(angle), 0.0f, \
    0.0f, sinf(angle), cosf(angle), 0.0f, \
    0.0f, 0.0f, 0.0f, 1.0f \
)

#define CGL_mat4_rotate_y(angle) CGL_mat4_init(\
    cosf(angle), 0.0f, sinf(angle), 0.0f, \
    0.0f, 1.0f, 0.0f, 0.0f, \
    -sinf(angle), 0.0f, cosf(angle), 0.0f, \
    0.0f, 0.0f, 0.0f, 1.0f \
)

#define CGL_mat4_rotate_z(angle) CGL_mat4_init(\
    cosf(angle), -sinf(angle), 0.0f, 0.0f, \
    sinf(angle), cosf(angle), 0.0f, 0.0f, \
    0.0f, 0.0f, 1.0f, 0.0f, \
    0.0f, 0.0f, 0.0f, 1.0f \
)

#define CGL_mat4_perspective(fov, aspect, near, far) CGL_mat4_init(\
    1.0f / (aspect * tanf(fov / 2.0f)), 0.0f, 0.0f, 0.0f, \
    0.0f, 1.0f / tanf(fov / 2.0f), 0.0f, 0.0f, \
    0.0f, 0.0f, (far + near) / (near - far), (2.0f * far * near) / (near - far), \
    0.0f, 0.0f, -1.0f, 0.0f \
)


/*
#define CGL_mat4_perspective(fov, aspect, fnear, ffar) CGL_mat4_init(\
	1.0f / (aspect * tanf(fov / 2.0f)), 0.0f, 0.0f, 0.0f, \
	0.0f, 1.0f / tanf(fov / 2.0f), 0.0f, 0.0f, \
	0.0f, 0.0f, (ffar + fnear) / (fnear - ffar), -1.0f, \
	0.0f, 0.0f, (2.0f * ffar * fnear) / (fnear - ffar), 0.0f \
)
*/



#define CGL_mat4_orthographic(left, right, bottom, top, fnear, ffar) CGL_mat4_init( \
    2.0f / (right - left), 0.0f, 0.0f, -(right + left) / (right - left), \
    0.0f, 2.0f / (top - bottom), 0.0f, -(top + bottom) / (top - bottom), \
    0.0f, 0.0f, -2.0f / (ffar - fnear), -(ffar + fnear) / (ffar - fnear), \
    0.0f, 0.0f, 0.0f, 1.0f \
)

#define CGL_mat4_log(m) CGL_info( \
    "\n{\n" \
    "    { %f, %f, %f, %f },\n" \
    "    { %f, %f, %f, %f },\n" \
    "    { %f, %f, %f, %f },\n" \
    "    { %f, %f, %f, %f }\n" \
    "}\n", \
    CGL_mat4_elem_get(m, 0, 0), CGL_mat4_elem_get(m, 0, 1), CGL_mat4_elem_get(m, 0, 2), CGL_mat4_elem_get(m, 0, 3), \
    CGL_mat4_elem_get(m, 1, 0), CGL_mat4_elem_get(m, 1, 1), CGL_mat4_elem_get(m, 1, 2), CGL_mat4_elem_get(m, 1, 3), \
    CGL_mat4_elem_get(m, 2, 0), CGL_mat4_elem_get(m, 2, 1), CGL_mat4_elem_get(m, 2, 2), CGL_mat4_elem_get(m, 2, 3), \
    CGL_mat4_elem_get(m, 3, 0), CGL_mat4_elem_get(m, 3, 1), CGL_mat4_elem_get(m, 3, 2), CGL_mat4_elem_get(m, 3, 3) \
)


typedef CGL_vec3(*CGL_parametric_function)(CGL_float, CGL_float);

#ifdef __cplusplus
#define CGL_quat_init(x, y, z, w) CGL_quat(x, y, z, w)
#else
#define CGL_quat_init(x, y, z, w) (CGL_quat){{x, y, z}, w}
#endif

#define CGL_quat_identity() CGL_quat_init(0.0f, 0.0f, 0.0f, 1.0f)
#define CGL_quat_equal(a, b) (CGL_vec3_equal(a.vec, b.vec) && (a.w == b.w))
#define CGL_quat_from_axis_angle(x, y, z, angle) CGL_quat_init(sinf(angle / 2.0f) * x, sinf(angle / 2.0f) * y, sinf(angle / 2.0f) * z, cosf(angle / 2.0f))
#define CGL_quat_from_x_rotation(angle) CGL_quat_from_axis_angle(1.0f, 0.0f, 0.0f, angle)
#define CGL_quat_from_y_rotation(angle) CGL_quat_from_axis_angle(0.0f, 1.0f, 0.0f, angle)
#define CGL_quat_from_z_rotation(angle) CGL_quat_from_axis_angle(0.0f, 0.0f, 1.0f, angle)
#define CGL_quat_from_euler_zyx(z, y, x) CGL_quat_init(cosf(x * 0.5f) * sinf(z * 0.5f) * cosf(y * 0.5f) - sinf(x * 0.5f) * cosf(z * 0.5f) * sinf(y * 0.5f), cosf(x * 0.5f) * cosf(z * 0.5f) * sinf(y * 0.5f) + sinf(x * 0.5f) * sinf(z * 0.5f) * cosf(y * 0.5f), sinf(x * 0.5f) * cosf(z * 0.5f) * cosf(y * 0.5f) - cosf(x * 0.5f) * sinf(z * 0.5f) * sinf(y * 0.5f), cosf(x * 0.5f) * cosf(z * 0.5f) * cosf(y * 0.5f) + sinf(x * 0.5f) * sinf(z * 0.5f) * sinf(y * 0.5f))
#define CGL_quat_conjuigate(q) CGL_quat_init(-q.vec.x, -q.vec.y, -q.vec.z, q.w)
#define CGL_quat_length(q) sqrtf(q.w * q.w + q.vec.x * q.vec.x + q.vec.y * q.vec.y + q.vec.z * q.vec.z)
#define CGL_quat_norm(q) CGL_quat_length(q)
#define CGL_quat_normalize(q) {CGL_float __CGL_quat_length##__LINE__ = 1.0f / CGL_quat_length(q); q.w *= __CGL_quat_length##__LINE__; q.vec.x *= __CGL_quat_length##__LINE__; q.vec.y *= __CGL_quat_length##__LINE__; q.vec.z *= __CGL_quat_length##__LINE__; }
#define CGL_quat_add(a, b) CGL_quat_init(a.vec.x + b.vec.x, a.vec.y + b.vec.y, a.vec.z + b.vec.z, a.w + b.w)
#define CGL_quat_sub(a, b) CGL_quat_init(a.vec.x - b.vec.x, a.vec.y - b.vec.y, a.vec.z - b.vec.z, a.w - b.w)
#define CGL_quat_conjugate(q) CGL_quat_init(-q.vec.x, -q.vec.y, -q.vec.z, q.w)
#define CGL_quat_mul_scalar(q, s) CGL_quat_init(q.vec.x * (s), q.vec.y * (s), q.vec.z * (s), q.w * (s))
CGL_void CGL_quat_to_euler_zyx(CGL_quat quat, CGL_float* z, CGL_float* y, CGL_float* x);
CGL_quat CGL_quat_slerp(CGL_quat a, CGL_quat b, CGL_float t);
CGL_quat CGL_quat_squad(CGL_quat a, CGL_quat b, CGL_quat c, CGL_quat d, CGL_float t);
CGL_float CGL_quat_to_axis_angle(CGL_quat quat, CGL_float* x, CGL_float* y, CGL_float* z);
CGL_quat CGL_quat_inverse(CGL_quat quat);
CGL_quat CGL_quat_mul(CGL_quat a, CGL_quat b);
CGL_void CGL_quat_rotate(CGL_quat q, CGL_float x, CGL_float y, CGL_float z, CGL_float* ox, CGL_float* oy, CGL_float* oz);
CGL_mat4 CGL_quat_to_mat4(CGL_quat quat);
CGL_vec3 CGL_vec3_apply_transformations(CGL_vec3 original, const CGL_vec3* translation, const CGL_vec3* rotation, const CGL_vec3* scale);
CGL_vec2 CGL_vec2_apply_transformations(CGL_vec2 original, const CGL_vec2* translation, const CGL_float* rotation, const CGL_vec2* scale);
CGL_vec4 CGL_quat_mul_vec4(CGL_quat q, CGL_vec4 v);

#ifndef CGL_EXCLUDE_MATH_FUNCTIONS
// vec2 
CGL_vec2 CGL_vec2_add_(CGL_vec2 a, CGL_vec2 b);
CGL_vec2 CGL_vec2_sub_(CGL_vec2 a, CGL_vec2 b);
CGL_vec2 CGL_vec2_mul_(CGL_vec2 a, CGL_vec2 b);
CGL_vec2 CGL_vec2_div_(CGL_vec2 a, CGL_vec2 b);
CGL_vec2 CGL_vec2_add_scalar_(CGL_vec2 a, CGL_float b);
CGL_vec2 CGL_vec2_sub_scalar_(CGL_vec2 a, CGL_float b);
CGL_vec2 CGL_vec2_scale_(CGL_vec2 a, CGL_float b);
CGL_vec2 CGL_vec2_normalize_(CGL_vec2 a);
CGL_float CGL_vec2_dot_(CGL_vec2 a, CGL_vec2 b);
CGL_float CGL_vec2_length_(CGL_vec2 a);
CGL_float CGL_vec2_cross_(CGL_vec2 a, CGL_vec2 b);
CGL_vec2 CGL_vec2_reflect_(CGL_vec2 a, CGL_vec2 b);
CGL_vec2 CGL_vec2_refract_(CGL_vec2 a, CGL_vec2 b, CGL_float eta);
CGL_vec2 CGL_vec2_rotate_(CGL_vec2 a, CGL_float angle);
CGL_vec2 CGL_vec2_lerp_(CGL_vec2 a, CGL_vec2 b, CGL_float t);

// vec3
CGL_vec3 CGL_vec3_add_(CGL_vec3 a, CGL_vec3 b);
CGL_vec3 CGL_vec3_add3_(CGL_vec3 a, CGL_vec3 b, CGL_vec3 c);
CGL_vec3 CGL_vec3_sub_(CGL_vec3 a, CGL_vec3 b);
CGL_vec3 CGL_vec3_mul_(CGL_vec3 a, CGL_vec3 b);
CGL_vec3 CGL_vec3_div_(CGL_vec3 a, CGL_vec3 b);
CGL_vec3 CGL_vec3_add_scalar_(CGL_vec3 a, CGL_float b);
CGL_vec3 CGL_vec3_sub_scalar_(CGL_vec3 a, CGL_float b);
CGL_vec3 CGL_vec3_scale_(CGL_vec3 a, CGL_float b);
CGL_vec3 CGL_vec3_normalize_(CGL_vec3 a);
CGL_float CGL_vec3_dot_(CGL_vec3 a, CGL_vec3 b);
CGL_float CGL_vec3_length_(CGL_vec3 a);
CGL_vec3 CGL_vec3_cross_(CGL_vec3 a, CGL_vec3 b);
CGL_vec3 CGL_vec3_reflect_(CGL_vec3 a, CGL_vec3 b);
CGL_vec3 CGL_vec3_refract_(CGL_vec3 a, CGL_vec3 b, CGL_float eta);
CGL_vec3 CGL_vec3_lerp_(CGL_vec3 a, CGL_vec3 b, CGL_float t);

// vec4
CGL_vec4 CGL_vec4_add_(CGL_vec4 a, CGL_vec4 b);
CGL_vec4 CGL_vec4_sub_(CGL_vec4 a, CGL_vec4 b);
CGL_vec4 CGL_vec4_mul_(CGL_vec4 a, CGL_vec4 b);
CGL_vec4 CGL_vec4_div_(CGL_vec4 a, CGL_vec4 b);
CGL_vec4 CGL_vec4_add_scalar_(CGL_vec4 a, CGL_float b);
CGL_vec4 CGL_vec4_sub_scalar_(CGL_vec4 a, CGL_float b);
CGL_vec4 CGL_vec4_scale_(CGL_vec4 a, CGL_float b);
CGL_vec4 CGL_vec4_normalize_(CGL_vec4 a);
CGL_float CGL_vec4_dot_(CGL_vec4 a, CGL_vec4 b);
CGL_float CGL_vec4_length_(CGL_vec4 a);
CGL_vec4 CGL_vec4_lerp_(CGL_vec4 a, CGL_vec4 b, CGL_float t);


struct CGL_transform
{
	CGL_vec4 position;
	CGL_vec4 rotation;
	CGL_vec4 scale;
	CGL_mat4 matrix;
	struct CGL_transform* parent;
};
typedef struct CGL_transform CGL_transform;

CGL_transform CGL_transform_create_empty();
CGL_transform CGL_transform_create(CGL_vec3 position, CGL_vec3 rotation, CGL_vec3 scale);
CGL_transform CGL_transform_create_from_matrix(CGL_mat4 matrix);
CGL_transform* CGL_transform_set_position(CGL_transform* transform, CGL_vec3 position);
CGL_transform* CGL_transform_set_rotation(CGL_transform* transform, CGL_vec3 rotation);
CGL_transform* CGL_transform_set_scale(CGL_transform* transform, CGL_vec3 scale);
CGL_transform* CGL_transform_set_parent(CGL_transform* transform, CGL_transform* parent);
CGL_transform* CGL_transform_update(CGL_transform* transform);
CGL_transform* CGL_transform_update_matrix_local(CGL_transform* transform);
CGL_mat4 CGL_transform_get_matrix(CGL_transform* transform);
CGL_mat4* CGL_transform_get_matrix_ptr(CGL_transform* transform);


#endif


#endif

#ifndef CGL_EXCLUDE_MATRIX_API

#ifndef CGL_MATRIX_DATA_TYPE
#define CGL_MATRIX_DATA_TYPE CGL_float
#endif


struct CGL_matrix;
typedef struct CGL_matrix CGL_matrix;


CGL_matrix* CGL_matrix_create(CGL_int m, CGL_int n);
CGL_void CGL_matrix_destroy(CGL_matrix* m);
CGL_matrix* CGL_matrix_create_from_array(CGL_MATRIX_DATA_TYPE* array, CGL_int m, CGL_int n);
CGL_matrix* CGL_matrix_add_to(CGL_matrix* a, CGL_matrix* b, CGL_matrix* out);
CGL_matrix* CGL_matrix_add(CGL_matrix* a, CGL_matrix* b);
CGL_matrix* CGL_matrix_sub_to(CGL_matrix* a, CGL_matrix* b, CGL_matrix* out);
CGL_matrix* CGL_matrix_sub(CGL_matrix* a, CGL_matrix* b);
CGL_matrix* CGL_matrix_elem_mul_to(CGL_matrix* a, CGL_matrix* b, CGL_matrix* out);
CGL_matrix* CGL_matrix_elem_mul(CGL_matrix* a, CGL_matrix* b);
CGL_matrix* CGL_matrix_mul_to(CGL_matrix* a, CGL_matrix* b, CGL_matrix* out);
CGL_matrix* CGL_matrix_mul(CGL_matrix* a, CGL_matrix* b);
CGL_matrix* CGL_matrix_transpose_to(CGL_matrix* m, CGL_matrix* out);
CGL_matrix* CGL_matrix_transpose(CGL_matrix* m);
CGL_matrix* CGL_matrix_identity_to(CGL_int m, CGL_int n, CGL_matrix* out);
CGL_matrix* CGL_matrix_identity(CGL_int m, CGL_int n);
CGL_matrix* CGL_matrix_scale_to(CGL_matrix* m, CGL_MATRIX_DATA_TYPE s);
CGL_matrix* CGL_matrix_scale(CGL_matrix* m, CGL_MATRIX_DATA_TYPE s);
CGL_MATRIX_DATA_TYPE CGL_matrix_get_elem(CGL_matrix* m, CGL_int i, CGL_int j);
CGL_bool CGL_matrix_set_elem(CGL_matrix* m, CGL_int i, CGL_int j, CGL_MATRIX_DATA_TYPE value);
CGL_bool CGL_matrix_set_row(CGL_matrix* m, CGL_int i, CGL_MATRIX_DATA_TYPE* row);
CGL_bool CGL_matrix_set_col(CGL_matrix* m, CGL_int j, CGL_MATRIX_DATA_TYPE* col);
CGL_bool CGL_matrix_get_row(CGL_matrix* m, CGL_int i, CGL_MATRIX_DATA_TYPE* out);
CGL_bool CGL_matrix_get_col(CGL_matrix* m, CGL_int j, CGL_MATRIX_DATA_TYPE* out);
CGL_matrix* CGL_matrix_row_to_matrix_to(CGL_MATRIX_DATA_TYPE* row, CGL_int n, CGL_matrix* out);
CGL_matrix* CGL_matrix_row_to_matrix(CGL_MATRIX_DATA_TYPE* row, CGL_int n);
CGL_matrix* CGL_matrix_col_to_matrix_to(CGL_MATRIX_DATA_TYPE* col, CGL_int n, CGL_matrix* out);
CGL_matrix* CGL_matrix_col_to_matrix(CGL_MATRIX_DATA_TYPE* col, CGL_int n);
CGL_bool CGL_matrix_is_square(CGL_matrix* m);
CGL_bool CGL_matrix_is_symmetric(CGL_matrix* m);
CGL_bool CGL_matrix_is_orthogonal(CGL_matrix* m);
CGL_bool CGL_matrix_is_diagonal(CGL_matrix* m);
CGL_bool CGL_matrix_is_identity(CGL_matrix* m);
CGL_bool CGL_matrix_is_zero(CGL_matrix* m);
CGL_bool CGL_matrix_is_equal(CGL_matrix* a, CGL_matrix* b);
CGL_MATRIX_DATA_TYPE CGL_matrix_trace(CGL_matrix* m);
CGL_MATRIX_DATA_TYPE CGL_matrix_determinant(CGL_matrix* m);
CGL_matrix* CGL_matrix_inverse_to(CGL_matrix* m, CGL_matrix* out);
CGL_matrix* CGL_matrix_inverse(CGL_matrix* m);
CGL_matrix* CGL_matrix_copy_to(CGL_matrix* m, CGL_matrix* out);
CGL_matrix* CGL_matrix_copy(CGL_matrix* m);
CGL_bool CGL_matrix_print(CGL_matrix* m);
CGL_matrix* CGL_matrix_gauss_jordan_to(CGL_matrix* m, CGL_matrix* out);
CGL_matrix* CGL_matrix_gauss_jordan(CGL_matrix* m);
CGL_matrix* CGL_matrix_submatrix_to(CGL_matrix* mat, CGL_int i, CGL_int j, CGL_int m, CGL_int n, CGL_matrix* out);
CGL_matrix* CGL_matrix_submatrix(CGL_matrix* mat, CGL_int i, CGL_int j, CGL_int m, CGL_int n);
CGL_matrix* CGL_matrix_minor_to(CGL_matrix* mat, CGL_int i, CGL_int j, CGL_matrix* out);
CGL_matrix* CGL_matrix_minor(CGL_matrix* mat, CGL_int i, CGL_int j);
CGL_matrix* CGL_matrix_adjugate_to(CGL_matrix* m, CGL_matrix* out);
CGL_matrix* CGL_matrix_adjugate(CGL_matrix* m);
CGL_matrix* CGL_matrix_transpose_inplace(CGL_matrix* m);
CGL_float CGL_matrix_sum_of_row(CGL_matrix* m, CGL_int i);
CGL_float CGL_matrix_sum_of_col(CGL_matrix* m, CGL_int j);
CGL_float CGL_matrix_product_of_row(CGL_matrix* m, CGL_int i);
CGL_float CGL_matrix_product_of_col(CGL_matrix* m, CGL_int j);
CGL_matrix* CGL_matrix_make_zero(CGL_matrix* m);

#endif


struct CGL_shape_triangle
{
	CGL_vec3 a;
	CGL_vec3 b;
	CGL_vec3 c;
};
typedef struct CGL_shape_triangle CGL_shape_triangle;

struct CGL_shape_quad
{
	CGL_vec3 a;
	CGL_vec3 b;
	CGL_vec3 c;
	CGL_vec3 d;
};
typedef struct CGL_shape_quad CGL_shape_quad;

struct CGL_shape
{
	CGL_vec3* vertices;
	CGL_vec3 position;
	CGL_vec3 rotation;
	CGL_vec3 scale;
	size_t vertices_count;
};
typedef struct CGL_shape CGL_shape;

CGL_void CGL_shape_init(CGL_shape* shape, size_t vertices_count);
CGL_void CGL_shape_destroy(CGL_shape* shape);

#ifndef CGL_SAT_COLLISION_MAX_COLLISIONS
#define CGL_SAT_COLLISION_MAX_COLLISIONS 4096
#endif

bool CGL_sat_collision_overlap_on_axis(CGL_shape* a, CGL_shape* b, CGL_vec2 axis, float* overlap_amount);
bool CGL_sat_collision_detect(CGL_shape* a, CGL_shape* b, CGL_vec2* n_vector);
CGL_void CGL_sat_collision_calculate_axes(CGL_shape* shape, CGL_vec2* axes, CGL_int* axes_count);
CGL_bool CGL_utils_is_point_in_triangle(CGL_vec2 p, CGL_vec2 a, CGL_vec2 b, CGL_vec2 c);
CGL_bool CGL_utils_is_point_in_circle(CGL_vec2 p, CGL_float r);
CGL_bool CGL_utils_calculate_circumcircle(CGL_vec2 a, CGL_vec2 b, CGL_vec2 c, CGL_vec2* center, CGL_float* radius);
CGL_bool CGL_utils_calculate_super_triangle(CGL_vec2* points, CGL_int points_count, CGL_vec2* a, CGL_vec2* b, CGL_vec2* c, CGL_float padding);
CGL_bool CGL_utils_calculate_bounding_square(CGL_vec2* points, CGL_int points_count, CGL_vec2* a, CGL_vec2* b, CGL_vec2* c, CGL_vec2* d, CGL_float padding);
CGL_bool CGL_utils_calculate_bounding_box(CGL_vec2* points, CGL_int points_count, CGL_vec2* a, CGL_vec2* b, CGL_vec2* c, CGL_vec2* d, CGL_float padding);
CGL_float CGL_utils_random_gaussian(CGL_float mean, CGL_float std_dev);

// GJK collision detection & EPA collision resolution

#ifndef CGL_GJK_EPA_MAX_POLYTOPE_VERTICES
#define CGL_GJK_EPA_MAX_POLYTOPE_VERTICES 64
#endif

#ifndef CGL_GJK_EPA_TOLERANCE
#define CGL_GJK_EPA_TOLERANCE 0.001f
#endif

CGL_vec3 CGL_gjk_shape_default_support(CGL_shape* a, CGL_vec3 d);
CGL_vec3 CGL_gjk_default_support(CGL_shape* a, CGL_shape* b, CGL_vec3 d);
CGL_bool CGL_gjk_check_collision_2d(CGL_shape* a, CGL_shape* b, CGL_vec3* simplex_out);
CGL_vec3 CGL_gjk_epa_2d(CGL_shape* a, CGL_shape* b, CGL_vec3* simplex);

#ifndef CGL_INCREMENTAL_TRIANGULATOR_MAX_TRIANGLES
#define CGL_INCREMENTAL_TRIANGULATOR_MAX_TRIANGLES 4096
#endif

CGL_bool CGL_aabb_contains_point(CGL_vec2 aabb_min, CGL_vec2 aabb_max, CGL_vec2 point);
CGL_bool CGL_aabb_intersects_aabb(CGL_vec2 aabb_min, CGL_vec2 aabb_max, CGL_vec2 aabb_min2, CGL_vec2 aabb_max2);
CGL_bool CGL_aabb_subdivide_nd(CGL_int n, CGL_float* aabb_min, CGL_float* aabb_max, CGL_float* aabbs_min_out, CGL_float* aabbs_max_out);
CGL_bool CGL_aabb_subdivide_2d(CGL_int n, CGL_float* aabb_min, CGL_float* aabb_max, CGL_float* aabbs_min_out, CGL_float* aabbs_max_out);
CGL_bool CGL_aabb_subdivide_3d(CGL_int n, CGL_float* aabb_min, CGL_float* aabb_max, CGL_float* aabbs_min_out, CGL_float* aabbs_max_out);
CGL_bool CGL_aabb_contains_point_nd(CGL_int n, CGL_float* aabb_min, CGL_float* aabb_max, CGL_float* point);
CGL_bool CGL_aabb_contains_point_2d(CGL_int n, CGL_float* aabb_min, CGL_float* aabb_max, CGL_float* point);
CGL_bool CGL_aabb_contains_point_3d(CGL_int n, CGL_float* aabb_min, CGL_float* aabb_max, CGL_float* point);
CGL_bool CGL_aabb_intersects_aabb_nd(CGL_int n, CGL_float* aabb_min, CGL_float* aabb_max, CGL_float* aabb_min2, CGL_float* aabb_max2);
CGL_bool CGL_aabb_intersects_aabb_2d(CGL_int n, CGL_float* aabb_min, CGL_float* aabb_max, CGL_float* aabb_min2, CGL_float* aabb_max2);
CGL_bool CGL_aabb_intersects_aabb_3d(CGL_int n, CGL_float* aabb_min, CGL_float* aabb_max, CGL_float* aabb_min2, CGL_float* aabb_max2);

CGL_bool CGL_triangulate_points_incremental(CGL_vec2* points, CGL_int points_count, CGL_int* triangles_out, CGL_int* triangles_count_out);

// window
#if 1 // Just to use code folding

#ifndef CGL_EXCLUDE_WINDOW_API

// CGL window management library (usinfg GLFW)

#ifdef CGL_EXPOSE_GLFW_API
#include <GLFW/glfw3.h> // GLFW
#else
// forrward declare GLFW data types
struct GLFWwindow;
// typedef struct GLFWwindow GLFWwindow;
#endif // EXPOSE_GLFW_API

/* The unknown key */
#define GLFW_KEY_UNKNOWN            -1

/* Printable keys */
#define CGL_KEY_SPACE              32
#define CGL_KEY_APOSTROPHE         39  /* ' */
#define CGL_KEY_COMMA              44  /* , */
#define CGL_KEY_MINUS              45  /* - */
#define CGL_KEY_PERIOD             46  /* . */
#define CGL_KEY_SLASH              47  /* / */
#define CGL_KEY_0                  48
#define CGL_KEY_1                  49
#define CGL_KEY_2                  50
#define CGL_KEY_3                  51
#define CGL_KEY_4                  52
#define CGL_KEY_5                  53
#define CGL_KEY_6                  54
#define CGL_KEY_7                  55
#define CGL_KEY_8                  56
#define CGL_KEY_9                  57
#define CGL_KEY_SEMICOLON          59  /* ; */
#define CGL_KEY_EQUAL              61  /* = */
#define CGL_KEY_A                  65
#define CGL_KEY_B                  66
#define CGL_KEY_C                  67
#define CGL_KEY_D                  68
#define CGL_KEY_E                  69
#define CGL_KEY_F                  70
#define CGL_KEY_G                  71
#define CGL_KEY_H                  72
#define CGL_KEY_I                  73
#define CGL_KEY_J                  74
#define CGL_KEY_K                  75
#define CGL_KEY_L                  76
#define CGL_KEY_M                  77
#define CGL_KEY_N                  78
#define CGL_KEY_O                  79
#define CGL_KEY_P                  80
#define CGL_KEY_Q                  81
#define CGL_KEY_R                  82
#define CGL_KEY_S                  83
#define CGL_KEY_T                  84
#define CGL_KEY_U                  85
#define CGL_KEY_V                  86
#define CGL_KEY_W                  87
#define CGL_KEY_X                  88
#define CGL_KEY_Y                  89
#define CGL_KEY_Z                  90
#define CGL_KEY_LEFT_BRACKET       91  /* [ */
#define CGL_KEY_BACKSLASH          92  /* \ */
#define CGL_KEY_RIGHT_BRACKET      93  /* ] */
#define CGL_KEY_GRAVE_ACCENT       96  /* ` */
#define CGL_KEY_WORLD_1            161 /* non-US #1 */
#define CGL_KEY_WORLD_2            162 /* non-US #2 */

/* Function keys */
#define CGL_KEY_ESCAPE             256
#define CGL_KEY_ENTER              257
#define CGL_KEY_TAB                258
#define CGL_KEY_BACKSPACE          259
#define CGL_KEY_INSERT             260
#define CGL_KEY_DELETE             261
#define CGL_KEY_RIGHT              262
#define CGL_KEY_LEFT               263
#define CGL_KEY_DOWN               264
#define CGL_KEY_UP                 265
#define CGL_KEY_PAGE_UP            266
#define CGL_KEY_PAGE_DOWN          267
#define CGL_KEY_HOME               268
#define CGL_KEY_END                269
#define CGL_KEY_CAPS_LOCK          280
#define CGL_KEY_SCROLL_LOCK        281
#define CGL_KEY_NUM_LOCK           282
#define CGL_KEY_PRINT_SCREEN       283
#define CGL_KEY_PAUSE              284
#define CGL_KEY_F1                 290
#define CGL_KEY_F2                 291
#define CGL_KEY_F3                 292
#define CGL_KEY_F4                 293
#define CGL_KEY_F5                 294
#define CGL_KEY_F6                 295
#define CGL_KEY_F7                 296
#define CGL_KEY_F8                 297
#define CGL_KEY_F9                 298
#define CGL_KEY_F10                299
#define CGL_KEY_F11                300
#define CGL_KEY_F12                301
#define CGL_KEY_F13                302
#define CGL_KEY_F14                303
#define CGL_KEY_F15                304
#define CGL_KEY_F16                305
#define CGL_KEY_F17                306
#define CGL_KEY_F18                307
#define CGL_KEY_F19                308
#define CGL_KEY_F20                309
#define CGL_KEY_F21                310
#define CGL_KEY_F22                311
#define CGL_KEY_F23                312
#define CGL_KEY_F24                313
#define CGL_KEY_F25                314
#define CGL_KEY_KP_0               320
#define CGL_KEY_KP_1               321
#define CGL_KEY_KP_2               322
#define CGL_KEY_KP_3               323
#define CGL_KEY_KP_4               324
#define CGL_KEY_KP_5               325
#define CGL_KEY_KP_6               326
#define CGL_KEY_KP_7               327
#define CGL_KEY_KP_8               328
#define CGL_KEY_KP_9               329
#define CGL_KEY_KP_DECIMAL         330
#define CGL_KEY_KP_DIVIDE          331
#define CGL_KEY_KP_MULTIPLY        332
#define CGL_KEY_KP_SUBTRACT        333
#define CGL_KEY_KP_ADD             334
#define CGL_KEY_KP_ENTER           335
#define CGL_KEY_KP_EQUAL           336
#define CGL_KEY_LEFT_SHIFT         340
#define CGL_KEY_LEFT_CONTROL       341
#define CGL_KEY_LEFT_ALT           342
#define CGL_KEY_LEFT_SUPER         343
#define CGL_KEY_RIGHT_SHIFT        344
#define CGL_KEY_RIGHT_CONTROL      345
#define CGL_KEY_RIGHT_ALT          346
#define CGL_KEY_RIGHT_SUPER        347
#define CGL_KEY_MENU               348

#define CGL_MOUSE_BUTTON_1         0
#define CGL_MOUSE_BUTTON_2         1
#define CGL_MOUSE_BUTTON_3         2
#define CGL_MOUSE_BUTTON_4         3
#define CGL_MOUSE_BUTTON_5         4
#define CGL_MOUSE_BUTTON_6         5
#define CGL_MOUSE_BUTTON_7         6
#define CGL_MOUSE_BUTTON_8         7
#define CGL_MOUSE_BUTTON_LAST      CGL_MOUSE_BUTTON_8
#define CGL_MOUSE_BUTTON_LEFT      CGL_MOUSE_BUTTON_1
#define CGL_MOUSE_BUTTON_RIGHT     CGL_MOUSE_BUTTON_2
#define CGL_MOUSE_BUTTON_MIDDLE    CGL_MOUSE_BUTTON_3

#define CGL_RELEASE                0
#define CGL_PRESS                  1
#define CGL_REPEAT                 2

#define CGL_WINDOW_TABLE_SIZE      10000

// structs
struct CGL_window;
typedef struct CGL_window CGL_window;

// struct GLFWwindow;
// typedef struct GLFWwindow GLFWwindow;

typedef void(*CGL_window_key_callback)(CGL_window* window, CGL_int key, CGL_int scancode, CGL_int action, CGL_int mods);
typedef void(*CGL_window_mouse_button_callback)(CGL_window* window, CGL_int button, CGL_int action, CGL_int mods);
typedef void(*CGL_window_mouse_position_callback)(CGL_window* window, double xpos, double ypos);
typedef void(*CGL_window_mouse_scroll_callback)(CGL_window* window, double xoffset, double yoffset);
typedef void(*CGL_window_framebuffer_size_callback)(CGL_window* window, CGL_int width, CGL_int height);
typedef void(*CGL_window_close_callback)(CGL_window* window);
typedef void(*CGL_window_drag_n_drop_callback)(CGL_window* window, const CGL_byte** paths, CGL_int count);

CGL_window* CGL_window_create(CGL_int width, CGL_int height, const char* title); // create window and initialize GLFW
CGL_window* CGL_window_create_undecorated(CGL_int width, CGL_int height, const char* title);
CGL_void CGL_window_destroy(CGL_window* window); // destroy window and terminate GLFW
CGL_void CGL_window_poll_events(CGL_window* window); // poll events from GLFW
CGL_void CGL_window_swap_buffers(CGL_window* window); // swap buffers
bool CGL_window_should_close(CGL_window* window); // check if window should close
CGL_void CGL_window_set_title(CGL_window* window, const char* title); // set window title
CGL_void CGL_window_set_size(CGL_window* window, CGL_int width, CGL_int height); // set window size
CGL_void CGL_window_set_position(CGL_window* window, CGL_int x, CGL_int y); // set window position
CGL_void CGL_window_set_hidden(CGL_window* window, bool hidden); // set window hidden
CGL_void CGL_window_set_user_data(CGL_window* window, void* user_data); // set window user data
CGL_void* CGL_window_get_user_data(CGL_window* window); // get window user data
CGL_void CGL_window_get_size(CGL_window* window, CGL_int* width, CGL_int* height); // get window size
CGL_void CGL_window_get_position(CGL_window* window, CGL_int* x, CGL_int* y); // get window position
CGL_void CGL_window_get_framebuffer_size(CGL_window* window, CGL_int* width, CGL_int* height); // get window framebuffer size
CGL_void CGL_window_set_key_callback(CGL_window* window, CGL_window_key_callback callback); // set key callback
CGL_void CGL_window_set_mouse_button_callback(CGL_window* window, CGL_window_mouse_button_callback callback); // set mouse button callback
CGL_void CGL_window_set_mouse_position_callback(CGL_window* window, CGL_window_mouse_position_callback callback); // set mouse position callback
CGL_void CGL_window_set_mouse_scroll_callback(CGL_window* window, CGL_window_mouse_scroll_callback callback); // set mouse scroll callback
CGL_void CGL_window_set_framebuffer_size_callback(CGL_window* window, CGL_window_framebuffer_size_callback callback); // set framebuffer size callback
CGL_void CGL_window_set_close_callback(CGL_window* window, CGL_window_close_callback callback); // set close callback
CGL_void CGL_window_set_drag_n_drop_callback(CGL_window* window, CGL_window_drag_n_drop_callback callback); // set drag and drop callback
CGL_void CGL_window_resecure_callbacks(CGL_window* window);
CGL_void CGL_window_make_context_current(CGL_window* window); // make opengl context current
struct GLFWwindow* CGL_window_get_glfw_handle(CGL_window* window);

// inputs
CGL_int CGL_window_get_key(CGL_window* window, CGL_int key); // get key state
CGL_bool CGL_window_is_key_pressed(CGL_window* window, CGL_int key); // check if key is pressed
CGL_int CGL_window_get_mouse_button(CGL_window* window, CGL_int button); // get mouse button state
CGL_void CGL_window_get_mouse_position(CGL_window* window, double* xpos, double* ypos); // get mouse position

#endif

#endif

// opengl
#if 1 // Just to use code folding

struct CGL_image
{
	void* data;
	CGL_int height;
	CGL_int width;
	CGL_int bytes_per_channel;
	CGL_int channels;
};
typedef struct CGL_image CGL_image;

#ifndef CGL_EXCLUDE_GRAPHICS_API

//#ifndef  CGL_EXCLUDE_WINDOW_API
#include <glad/glad.h>


#ifdef CGL_WASM
#define CGL_OPENGL_VERSION_MAJOR 2
#define CGL_OPENGL_VERSION_MINOR 0
#define CGL_OPENGL_VERSION_MAJOR_STR "2"
#define CGL_OPENGL_VERSION_MINOR_STR "0"
#else
#define CGL_OPENGL_VERSION_MAJOR 4
#define CGL_OPENGL_VERSION_MINOR 3
#define CGL_OPENGL_VERSION_MAJOR_STR "4"
#define CGL_OPENGL_VERSION_MINOR_STR "3"
#endif


// forward declarations
struct CGL_texture;
typedef struct CGL_texture CGL_texture;

struct CGL_framebuffer;
typedef struct CGL_framebuffer CGL_framebuffer;

struct CGL_shader;
typedef struct CGL_shader CGL_shader;

struct CGL_mesh_gpu;
typedef struct CGL_mesh_gpu CGL_mesh_gpu;

struct CGL_mesh_vertex
{
	CGL_vec4 position;
	CGL_vec4 normal;
	CGL_vec4 texture_coordinates;
	CGL_vec4 bone_wieghts;
	CGL_ivec4 bone_ids;
};
typedef struct CGL_mesh_vertex CGL_mesh_vertex;

struct CGL_mesh_cpu
{
	size_t index_count;
	size_t index_count_used;
	uint32_t* indices;
	size_t vertex_count;
	size_t vertex_count_used;
	CGL_mesh_vertex* vertices;
};
typedef struct CGL_mesh_cpu CGL_mesh_cpu;


struct CGL_ssbo;
typedef struct CGL_ssbo CGL_ssbo;

struct CGL_ubo;
typedef struct CGL_ubo CGL_ubo;

// Taken directly from OpenGL
#define CGL_CUBEMAP_POSITIVE_X 0x8515 
#define CGL_CUBEMAP_NEGATIVE_X 0x8516 
#define CGL_CUBEMAP_POSITIVE_Y 0x8517 
#define CGL_CUBEMAP_NEGATIVE_Y 0x8518 
#define CGL_CUBEMAP_POSITIVE_Z 0x8519 
#define CGL_CUBEMAP_NEGATIVE_Z 0x851A 

// texture
CGL_texture* CGL_texture_create(CGL_image* image);
CGL_texture* CGL_texture_create_blank(CGL_int width, CGL_int height, GLenum format, GLenum internal_format, GLenum type); // create texture
CGL_texture* CGL_texture_create_array(CGL_int width, CGL_int height, CGL_int layers, GLenum format, GLenum internal_format, GLenum type);
CGL_texture* CGL_texture_create_3d(CGL_int width, CGL_int height, CGL_int depth, GLenum format, GLenum internal_format, GLenum type);
CGL_texture* CGL_texture_create_cubemap();
CGL_void CGL_texture_cubemap_set_face(CGL_texture* texture, CGL_int face, CGL_image* image);
CGL_void CGL_texture_array_set_layer_data(CGL_texture* texture, CGL_int layer, void* data);
CGL_void CGL_texture_destroy(CGL_texture* texture); // destroy texture
CGL_int CGL_texture_bind(CGL_texture* texture, CGL_int unit); // bind texture to unit
CGL_void CGL_texture_set_data(CGL_texture* texture, void* data); // set texture data
CGL_void CGL_texture_set_sub_data(CGL_texture* texture, size_t offset_x, size_t offset_y, size_t size_x, size_t size_y, void* data); // set texture data
CGL_void CGL_texture_set_pixel_data(CGL_texture* texture, int x, int y, void* data); // set texture data at pixel
CGL_void CGL_texture_set_user_data(CGL_texture* texture, void* user_data); // set texture user data
CGL_void* CGL_texture_get_user_data(CGL_texture* texture); // get texture user data
CGL_uint CGL_texture_get_internal_handle(CGL_texture* texture); // get texture user data
CGL_void CGL_texture_get_size(CGL_texture* texture, CGL_int* width, CGL_int* height); // get texture size
CGL_void CGL_texture_set_scaling_method(CGL_texture* texture, GLint method);
CGL_void CGL_texture_set_wrapping_method(CGL_texture* texture, GLint method);

// framebuffer
#ifndef CGL_EXCLUDE_WINDOW_API
CGL_framebuffer* CGL_framebuffer_create_from_default(CGL_window* window); // create framebuffer from default framebuffer
#endif
CGL_framebuffer* CGL_framebuffer_create(CGL_int width, CGL_int height); // create framebuffer (32 bit)
CGL_framebuffer* CGL_framebuffer_create_basic(CGL_int width, CGL_int height);
CGL_void CGL_framebuffer_add_color_attachment(CGL_framebuffer* framebuffer, CGL_texture* texture); // add color attachment to framebuffer
CGL_void CGL_framebuffer_destroy(CGL_framebuffer* framebuffer); // destroy framebuffer
CGL_texture* CGL_framebuffer_get_color_attachment(CGL_framebuffer* framebuffer, CGL_int index); // get color attachment from framebuffer
CGL_void CGL_framebuffer_bind(CGL_framebuffer* framebuffer); // bind framebuffer
CGL_void CGL_framebuffer_get_size(CGL_framebuffer* framebuffer, CGL_int* width, CGL_int* height); // get framebuffer size
CGL_void CGL_framebuffer_set_user_data(CGL_framebuffer* framebuffer, void* user_data); // set framebuffer user data
CGL_void* CGL_framebuffer_get_user_data(CGL_framebuffer* framebuffer); // get framebuffer user data
CGL_void CGL_framebuffer_read_pixels(CGL_framebuffer* framebuffer, CGL_int x, CGL_int y, CGL_int width, CGL_int height, void* pixels); // read pixels from framebuffer
CGL_int CGL_framebuffer_get_mouse_pick_id(CGL_framebuffer* framebuffer, CGL_int x, CGL_int y, CGL_int index); // get mouse pick id
CGL_texture* CGL_framebuffer_get_color_texture(CGL_framebuffer* framebuffer); // get color texture
CGL_texture* CGL_framebuffer_get_depth_texture(CGL_framebuffer* framebuffer); // get depth texture

// gl

CGL_void CGL_gl_clear(CGL_float r, CGL_float g, CGL_float b, CGL_float a); // clear framebuffer
bool CGL_gl_init(); // load opengl functions
CGL_void CGL_gl_shutdown(); // clean up
CGL_void CGL_gl_render_screen_quad();

// mesh

CGL_mesh_gpu* CGL_mesh_gpu_create(); // create mesh (gpu)
CGL_void CGL_mesh_gpu_destroy(CGL_mesh_gpu* mesh); // destroy mesh (gpu)
CGL_void CGL_mesh_gpu_render(CGL_mesh_gpu* mesh); // render mesh (gpu)
CGL_void CGL_mesh_gpu_render_instanced(CGL_mesh_gpu* mesh, uint32_t count); // render mesh instanfced (gpu)
CGL_void CGL_mesh_gpu_set_user_data(CGL_mesh_gpu* mesh, void* user_data); // set mesh user data
CGL_void* CGL_mesh_gpu_get_user_data(CGL_mesh_gpu* mesh); // get mesh user data
CGL_void CGL_mesh_gpu_upload(CGL_mesh_gpu* mesh, CGL_mesh_cpu* mesh_cpu, bool static_draw); // upload mesh from (cpu) to (gpu)

// mesh generation


CGL_mesh_cpu* CGL_mesh_cpu_create(size_t vertex_count, size_t index_count);
CGL_mesh_cpu* CGL_mesh_cpu_recalculate_normals(CGL_mesh_cpu* mesh);
CGL_mesh_cpu* CGL_mesh_cpu_flip_normals(CGL_mesh_cpu* mesh);
CGL_mesh_cpu* CGL_mesh_cpu_load_obj(const char* path);
CGL_mesh_cpu* CGL_mesh_cpu_triangle(CGL_vec3 a, CGL_vec3 b, CGL_vec3 c); // generate triangle mesh
CGL_mesh_cpu* CGL_mesh_cpu_plane(CGL_vec3 front, CGL_vec3 right, CGL_int resolution, CGL_float scale); // generate plane mesh
CGL_mesh_cpu* CGL_mesh_cpu_quad(CGL_vec3 a, CGL_vec3 b, CGL_vec3 c, CGL_vec3 d); // generate quad mesh
CGL_mesh_cpu* CGL_mesh_cpu_cube(CGL_bool use_3d_tex_coords);
CGL_mesh_cpu* CGL_mesh_cpu_sphere(CGL_int res_u, CGL_int res_v);
CGL_mesh_cpu* CGL_mesh_cpu_create_from_parametric_function(CGL_int res_u, CGL_int res_v, CGL_float start_u, CGL_float start_v, CGL_float end_u, CGL_float end_v, CGL_parametric_function function);
CGL_mesh_cpu* CGL_mesh_cpu_create_cylinder(CGL_vec3 start, CGL_vec3 end, CGL_float radius0, CGL_float radius1, CGL_int resolution);
CGL_mesh_cpu* CGL_mesh_cpu_create_cylinder2(CGL_vec3 start, CGL_vec3 end, CGL_float radius0, CGL_float radius1, CGL_int resolution_x, CGL_int resolution_y);
CGL_mesh_cpu* CGL_mesh_cpu_create_torus_elbow(CGL_vec3 center, CGL_float radius0, CGL_float radius1, CGL_int resolution0, CGL_int resolution1, CGL_float elbow_angle);

CGL_mesh_cpu* CGL_mesh_cpu_add_mesh(CGL_mesh_cpu* mesh, CGL_mesh_cpu* mesh_other);
CGL_mesh_cpu* CGL_mesh_cpu_add_cube(CGL_mesh_cpu* mesh, CGL_bool use_3d_tex_coords);
CGL_mesh_cpu* CGL_mesh_cpu_add_triangle(CGL_mesh_cpu* mesh, CGL_vec3 a, CGL_vec3 b, CGL_vec3 c); // generate triangle mesh
CGL_mesh_cpu* CGL_mesh_cpu_add_quad(CGL_mesh_cpu* mesh, CGL_vec3 a, CGL_vec3 b, CGL_vec3 c, CGL_vec3 d); // generate quad mesh
CGL_mesh_cpu* CGL_mesh_cpu_add_from_parametric_function(CGL_mesh_cpu* mesh, CGL_int res_u, CGL_int res_v, CGL_float start_u, CGL_float start_v, CGL_float end_u, CGL_float end_v, CGL_parametric_function function);
CGL_mesh_cpu* CGL_mesh_cpu_add_sphere(CGL_mesh_cpu* mesh, CGL_int res_u, CGL_int res_v);
CGL_mesh_cpu* CGL_mesh_cpu_add_cylinder(CGL_mesh_cpu* mesh, CGL_vec3 start, CGL_vec3 end, CGL_float radius0, CGL_float radius1, CGL_int resolution);
CGL_mesh_cpu* CGL_mesh_cpu_add_cylinder2(CGL_mesh_cpu* mesh, CGL_vec3 start, CGL_vec3 end, CGL_float radius0, CGL_float radius1, CGL_int resolution_x, CGL_int resolution_y);
CGL_mesh_cpu* CGL_mesh_cpu_add_torus(CGL_mesh_cpu* mesh, CGL_vec3 center, CGL_float radius0, CGL_float radius1, CGL_int resolution0, CGL_int resolution1, CGL_float elbow_angle);



CGL_mesh_cpu* CGL_mesh_cpu_offset_vertices(CGL_mesh_cpu* mesh, CGL_vec3 offset);
CGL_mesh_cpu* CGL_mesh_cpu_scale_vertices(CGL_mesh_cpu* mesh, CGL_float scale);
CGL_mesh_cpu* CGL_mesh_cpu_rotate_vertices(CGL_mesh_cpu* mesh, CGL_quat rotation);
CGL_mesh_cpu* CGL_mesh_cpu_transform_vertices(CGL_mesh_cpu* mesh, CGL_mat4 transform);



CGL_void CGL_mesh_cpu_generate_c_initialization_code(CGL_mesh_cpu* mesh, char* buffer, const char* function_name);
CGL_void CGL_mesh_cpu_destroy(CGL_mesh_cpu* mesh); // destroy mesh (cpu)

// shader

CGL_shader* CGL_shader_create(const char* vertex_shader_source, const char* fragment_shader_source, char** error); // create shader
CGL_shader* CGL_shader_compute_create(const char* compute_shader_source, char** error); // create compute shader
CGL_shader* CGL_shader_create_from_files(const char* vertex_shader_file, const char* fragment_shader_file, char** error); // create shader from files
CGL_shader* CGL_shader_compute_create_from_files(const char* compute_shader_file, char** error); // create compute shader from files
CGL_void CGL_shader_destroy(CGL_shader* shader); // destroy shader
CGL_void CGL_shader_bind(CGL_shader* shader); // bind shader
int CGL_shader_get_uniform_location(CGL_shader* shader, const char* name); // get uniform location
CGL_void CGL_shader_set_uniform_mat4(CGL_shader* shader, CGL_int location, CGL_mat4* matrix); // set uniform matrix
CGL_void CGL_shader_set_uniform_vec4(CGL_shader* shader, CGL_int location, CGL_vec4* vector); // set uniform vector
CGL_void CGL_shader_set_uniform_vec3(CGL_shader* shader, CGL_int location, CGL_vec3* vector); // set uniform vector
CGL_void CGL_shader_set_uniform_vec2(CGL_shader* shader, CGL_int location, CGL_vec2* vector); // set uniform vector
CGL_void CGL_shader_set_uniform_int(CGL_shader* shader, CGL_int location, CGL_int value); // set uniform int
CGL_void CGL_shader_set_uniform_bool(CGL_shader* shader, CGL_int location, bool value); // set uniform bool
CGL_void CGL_shader_set_uniform_float(CGL_shader* shader, CGL_int location, CGL_float value); // set uniform float
CGL_void CGL_shader_set_uniform_double(CGL_shader* shader, CGL_int location, CGL_double value); // set uniform double
CGL_void CGL_shader_set_uniform_vec2v(CGL_shader* shader, CGL_int location, CGL_float x, CGL_float y); // set uniform vector
CGL_void CGL_shader_set_uniform_vec3v(CGL_shader* shader, CGL_int location, CGL_float x, CGL_float y, CGL_float z); // set uniform vector
CGL_void CGL_shader_set_uniform_vec4v(CGL_shader* shader, CGL_int location, CGL_float x, CGL_float y, CGL_float z, CGL_float w); // set uniform vector
CGL_void CGL_shader_set_uniform_ivec2v(CGL_shader* shader, CGL_int location, CGL_int x, CGL_int y); // set uniform vector
CGL_void CGL_shader_set_uniform_ivec3v(CGL_shader* shader, CGL_int location, CGL_int x, CGL_int y, CGL_int z); // set uniform vector
CGL_void CGL_shader_set_uniform_ivec4v(CGL_shader* shader, CGL_int location, CGL_int x, CGL_int y, CGL_int z, CGL_int w); // set uniform vector
CGL_void CGL_shader_set_user_data(CGL_shader* shader, void* user_data); // set shader user data
CGL_void* CGL_shader_get_user_data(CGL_shader* shader); // get shader user data
CGL_void CGL_shader_compute_dispatch(CGL_shader* shader, CGL_int x, CGL_int y, CGL_int z); // dispatch compute shader

// ssbo
CGL_ssbo* CGL_ssbo_create(uint32_t binding); // create ssbo
CGL_void CGL_ssbo_destroy(CGL_ssbo* ssbo); // destroy ssbo
CGL_void CGL_ssbo_bind(CGL_ssbo* ssbo); // bind ssbo
CGL_void CGL_ssbo_bind2(CGL_ssbo* ssbo, uint32_t binding); // bind ssbo to binding
CGL_void CGL_ssbo_set_data(CGL_ssbo* ssbo, size_t size, void* data, bool static_draw); // set ssbo data
CGL_void CGL_ssbo_set_sub_data(CGL_ssbo* ssbo, size_t offset, size_t size, void* data, bool static_draw); // set ssbo sub data
CGL_void CGL_ssbo_get_data(CGL_ssbo* ssbo, size_t* size, void* data); // get ssbo data
CGL_void CGL_ssbo_get_sub_data(CGL_ssbo* ssbo, size_t offset, size_t size, void* data); // get ssbo sub data
CGL_void CGL_ssbo_set_user_data(CGL_ssbo* ssbo, void* user_data); // set ssbo user data
CGL_void* CGL_ssbo_get_user_data(CGL_ssbo* ssbo); // get ssbo user data
size_t CGL_ssbo_get_size(CGL_ssbo* ssbo); // get ssbo size
CGL_void CGL_ssbo_copy(CGL_ssbo* dst, CGL_ssbo* src, size_t src_offset, size_t dst_offset, size_t size); // copy ssbo

CGL_ubo* CGL_ubo_create(); // create ubo
CGL_void CGL_ubo_destroy(CGL_ubo* ubo); // destroy ubo
CGL_void CGL_ubo_bind(CGL_ubo* ubo, CGL_shader* shader, const CGL_byte* name, uint32_t binding); // bind ubo
CGL_void CGL_ubo_set_data(CGL_ubo* ubo, size_t size, void* data, bool static_draw); // set ubo data
CGL_void CGL_ubo_set_sub_data(CGL_ubo* ubo, size_t offset, size_t size, void* data, bool static_draw); // set ubo sub data
CGL_void CGL_ubo_get_data(CGL_ubo* ubo, size_t* size, void* data); // get ubo data
CGL_void CGL_ubo_get_sub_data(CGL_ubo* ubo, size_t offset, size_t size, void* data); // get ubo sub data
CGL_void CGL_ubo_set_user_data(CGL_ubo* ubo, void* user_data); // set ubo user data
CGL_void* CGL_ubo_get_user_data(CGL_ubo* ubo); // get ubo user data
size_t CGL_ubo_get_size(CGL_ubo* ubo); // get ubo size



#endif
#endif

// BLOOM
#ifndef CGL_EXCLUDE_BLOOM
#ifdef CGL_EXCLUDE_GRAPHICS_API
#error "CGL Bloom requires CGL Graphics API"
#endif

#define CGL_BLOOM_SHADER_MODE_PREFILTER      0
#define CGL_BLOOM_SHADER_MODE_DOWNSAMPLE     1
#define CGL_BLOOM_SHADER_MODE_UPSAMPLE       2
#define CGL_BLOOM_SHADER_MODE_COMPOSITE      3

#define CGL_BLOOM_MAX_ITERATIONS 8

struct CGL_bloom;
typedef struct CGL_bloom CGL_bloom;

CGL_bloom* CGL_bloom_create(CGL_int width, CGL_int height, CGL_int iterations);
CGL_void CGL_bloom_destroy(CGL_bloom* bloom);
CGL_void CGL_bloom_set_threshold(CGL_bloom* bloom, CGL_float val);
float CGL_bloom_get_threshold(CGL_bloom* bloom);
CGL_void CGL_bloom_set_knee(CGL_bloom* bloom, CGL_float val);
float CGL_bloom_get_knee(CGL_bloom* bloom);
CGL_void CGL_bloom_set_offset(CGL_bloom* bloom, CGL_float x, CGL_float y);
CGL_void CGL_bloom_apply(CGL_bloom* bloom, CGL_texture* tex);
CGL_void CGL_bloom_apply2(CGL_bloom* bloom, CGL_texture* tex_src, CGL_texture* tex_dst);
int CGL_bloom_get_iterations(CGL_bloom* bloom);
CGL_texture* CGL_bloom_get_lod_texture(CGL_bloom* bloom, CGL_int index);
CGL_texture* CGL_bloom_get_prefiltered_texture(CGL_bloom* bloom);

#endif


// camera
#if 1

struct CGL_camera;
typedef struct CGL_camera CGL_camera;

CGL_camera* CGL_camera_create();
CGL_void CGL_camera_destroy(CGL_camera* camera);
bool CGL_camera_is_perspective(CGL_camera* camera);
bool CGL_camera_is_orthographic(CGL_camera* camera);
float CGL_camera_get_fov(CGL_camera* camera);
float CGL_camera_get_aspect_ratio(CGL_camera* camera);
float CGL_camera_get_z_near(CGL_camera* camera);
float CGL_camera_get_z_far(CGL_camera* camera);
CGL_vec4 CGL_camera_get_orthographic_limits(CGL_camera* camera);
CGL_void CGL_camera_set_fov(CGL_camera* camera, CGL_float fov);
CGL_void CGL_camera_set_aspect_ratio(CGL_camera* camera, CGL_float aspect_ratio);
CGL_void CGL_camera_set_z_near(CGL_camera* camera, CGL_float z_near);
CGL_void CGL_camera_set_z_far(CGL_camera* camera, CGL_float z_far);
CGL_void CGL_camera_set_orthographic_limits(CGL_camera* camera, CGL_vec4 ortho_limits);
CGL_void CGL_camera_set_perspective(CGL_camera* camera);
CGL_void CGL_camera_set_orthographic(CGL_camera* camera);
CGL_mat4 CGL_camera_get_projection_mat(CGL_camera* camera);
CGL_mat4* CGL_camera_get_projection_mat_ptr(CGL_camera* camera);
CGL_mat4 CGL_camera_get_view_mat(CGL_camera* camera);
CGL_mat4* CGL_camera_get_view_mat_ptr(CGL_camera* camera);
CGL_mat4 CGL_camera_get_pv_mat(CGL_camera* camera);
CGL_mat4* CGL_camera_get_pv_mat_ptr(CGL_camera* camera);
CGL_void CGL_camera_set_position(CGL_camera* camera, CGL_vec3 position);
CGL_void CGL_camera_set_rotation(CGL_camera* camera, CGL_vec3 ratation);
CGL_vec3 CGL_camera_get_position(CGL_camera* camera);
CGL_vec3 CGL_camera_get_rotation(CGL_camera* camera);
CGL_vec3* CGL_camera_get_position_ptr(CGL_camera* camera);
CGL_vec3* CGL_camera_get_rotation_ptr(CGL_camera* camera);
CGL_vec3 CGL_camera_get_front(CGL_camera* camera);
CGL_vec3 CGL_camera_get_right(CGL_camera* camera);
CGL_vec3 CGL_camera_get_up(CGL_camera* camera);
CGL_void CGL_camera_recalculate_mat(CGL_camera* camera);

#endif

// phong renderer
#ifndef CGL_EXCLUDE_GRAPHICS_API
// The phong renderer
#if 1

#ifndef CGL_EXCLUDE_PHONG_RENDERER

#define CGL_PHONG_MAX_LIGHTS            16

#define CGL_PHONG_LIGHT_DIRECTIONAL     0
#define CGL_PHONG_LIGHT_POINT           1
#define CGL_PHONG_LIGHT_SPOT            2

struct CGL_phong_mat;
typedef struct CGL_phong_mat CGL_phong_mat;

struct CGL_phong_pipeline;
typedef struct CGL_phong_pipeline CGL_phong_pipeline;

struct CGL_phong_light;
typedef struct CGL_phong_light CGL_phong_light;

CGL_phong_pipeline* CGL_phong_pipeline_create();
CGL_void CGL_phong_pipeline_destroy(CGL_phong_pipeline* pipeline);
CGL_void CGL_phong_pipeline_set_user_data(CGL_phong_pipeline* pipeline, void* data);
CGL_void* CGL_phong_pipeline_get_user_data(CGL_phong_pipeline* pipeline);
bool CGL_phong_pipeline_is_using_blinn(CGL_phong_pipeline* pipeline);
CGL_void CGL_phong_pipeline_enable_blinn(CGL_phong_pipeline* pipeline);
CGL_void CGL_phong_pipeline_disable_blinn(CGL_phong_pipeline* pipeline);
CGL_void CGL_phong_pipeline_enable_gamma_correction(CGL_phong_pipeline* pipeline);
CGL_void CGL_phong_pipeline_disable_gamma_correction(CGL_phong_pipeline* pipeline);
CGL_void CGL_phong_pipeline_set_ambient_light_color(CGL_phong_pipeline* pipeline, CGL_vec3 color);
CGL_vec3 CGL_phong_pipeline_get_ambient_light_color(CGL_phong_pipeline* pipeline);
CGL_void CGL_phong_pipeline_set_ambient_light_strength(CGL_phong_pipeline* pipeline, CGL_float strength);
float CGL_phong_pipeline_get_ambient_light_strength(CGL_phong_pipeline* pipeline);
uint32_t CGL_phong_pipeline_add_light(CGL_phong_pipeline* pipeline, CGL_phong_light* light);
CGL_phong_light* CGL_phong_pipeline_remove_light(CGL_phong_pipeline* pipeline, uint32_t light_id);

CGL_phong_mat* CGL_phong_mat_create();
CGL_void CGL_phong_mat_destroy(CGL_phong_mat* mat);
CGL_void CGL_phong_mat_set_diffuse_color(CGL_phong_mat* mat, CGL_vec3 color);
CGL_void CGL_phong_mat_set_diffuse_texture(CGL_phong_mat* mat, CGL_image* image);
CGL_void CGL_phong_mat_set_specular_color(CGL_phong_mat* mat, CGL_vec3 color);
CGL_void CGL_phong_mat_set_specular_texture(CGL_phong_mat* mat, CGL_image* image);
CGL_void CGL_phong_mat_set_normal_texture(CGL_phong_mat* mat, CGL_image* image);
CGL_void CGL_phong_mat_set_shininess(CGL_phong_mat* mat, CGL_float shininess);
CGL_void CGL_phong_mat_set_user_data(CGL_phong_mat* mat, void* data);
CGL_void* CGL_phong_mat_get_user_data(CGL_phong_mat* mat);
CGL_void CGL_phong_mat_disable_normal_map(CGL_phong_mat* mat);
CGL_void CGL_phong_mat_enable_wireframe(CGL_phong_mat* mat);
CGL_void CGL_phong_mat_disable_wireframe(CGL_phong_mat* mat);
float CGL_phong_mat_get_shininess(CGL_phong_mat* mat);

CGL_phong_light* CGL_phong_light_directional(CGL_vec3 direction, CGL_vec3 color, CGL_float itensity);
CGL_phong_light* CGL_phong_light_point(CGL_vec3 position, CGL_vec3 color, CGL_float itensity, CGL_float constant, CGL_float linear, CGL_float quadratic);
CGL_void CGL_phong_light_destroy(CGL_phong_light* light);
CGL_void CGL_phong_light_set_intensity(CGL_phong_light* light, CGL_float intensity);
CGL_void CGL_phong_light_set_color(CGL_phong_light* light, CGL_vec3 color);
float CGL_phong_light_get_intensity(CGL_phong_light* light);
CGL_vec3 CGL_phong_light_get_color(CGL_phong_light* light);
uint32_t CGL_phong_light_get_type(CGL_phong_light* light);

CGL_void CGL_phong_render_begin(CGL_phong_pipeline* pipeline, CGL_camera* camera);
CGL_void CGL_phong_render(CGL_mesh_gpu* mesh, CGL_mat4* model_matrix, CGL_phong_mat* material, CGL_phong_pipeline* pipeline, CGL_camera* camera);
CGL_void CGL_phong_render_end(CGL_phong_pipeline* pipeline, CGL_camera* camera);

#endif

#endif

#endif

// tilemap renderer
#ifndef CGL_EXCLUDE_GRAPHICS_API

// tilemap renderer
#if 1

#ifndef CGL_EXCLUDE_TILEMAP_RENDERER

struct CGL_tilemap;
typedef struct CGL_tilemap CGL_tilemap;

struct CGL_tile;
typedef struct CGL_tile CGL_tile;

CGL_tilemap* CGL_tilemap_create(uint32_t tile_count_x, uint32_t tile_count_y, uint32_t tile_size_x, uint32_t tile_size_y, uint32_t ssbo_binding);
CGL_void CGL_tilemap_destroy(CGL_tilemap* tilemap);
CGL_void CGL_tilemap_set_auto_upload(CGL_tilemap* tilemap, bool value);
bool CGL_tilemap_get_auto_upload(CGL_tilemap* tilemap);
bool CGL_tilemap_upload(CGL_tilemap* tilemap);
CGL_void CGL_tilemap_set_tile_color(CGL_tilemap* tilemap, uint32_t tile_x, uint32_t tile_y, CGL_float r, CGL_float g, CGL_float b);
CGL_void CGL_tilemap_set_tile_texture_from_array(CGL_tilemap* tilemap, uint32_t tile_x, uint32_t tile_y, uint32_t texture_index);
CGL_void CGL_tilemap_set_tile_texture_from_tileset(CGL_tilemap* tilemap, uint32_t tile_x, uint32_t tile_y, CGL_float texture_x_min, CGL_float texture_y_min, CGL_float texture_x_max, CGL_float texture_y_max);
CGL_void CGL_tilemap_set_all_tile_color(CGL_tilemap* tilemap, CGL_float r, CGL_float g, CGL_float b);
CGL_void CGL_tilemap_set_all_tile_texture_from_array(CGL_tilemap* tilemap, uint32_t texture_index);
CGL_void CGL_tilemap_set_all_tile_texture_from_tileset(CGL_tilemap* tilemap, CGL_float texture_x_min, CGL_float texture_y_min, CGL_float texture_x_max, CGL_float texture_y_max);
CGL_void CGL_tilemap_clear_tile(CGL_tilemap* tilemap, uint32_t tile_x, uint32_t tile_y);
CGL_void CGL_tilemap_clear_all_tile(CGL_tilemap* tilemap);
CGL_void CGL_tilemap_render(CGL_tilemap* tilemap, CGL_float scale_x, CGL_float scale_y, CGL_float offset_x, CGL_float offset_y, CGL_texture* texture);
CGL_void CGL_tilemap_reset(CGL_tilemap* tilemap);

#endif

#endif

#endif

// sky renderer
#ifndef CGL_EXCLUDE_GRAPHICS_API
#ifndef CGL_EXCLUDE_SKY_RENDERER

struct CGL_sky;
typedef struct CGL_sky CGL_sky;

CGL_sky* CGL_sky_create();
CGL_void CGL_sky_destroy(CGL_sky* sky);
CGL_void CGL_sky_use_skybox(CGL_sky* sky);
CGL_void CGL_sky_use_skysphere(CGL_sky* sky);
CGL_void CGL_sky_use_cubemap(CGL_sky* sky);
CGL_void CGL_sky_use_procedural(CGL_sky* sky);
CGL_void CGL_sky_cubemap_set_face(CGL_sky* sky, CGL_int face, CGL_image* image);
CGL_void CGL_sky_procedural_set_options(CGL_sky* sky, CGL_float cirrus, CGL_float cumulus, CGL_float upf);
CGL_void CGL_sky_procedural_set_time(CGL_sky* sky, CGL_float time);
CGL_void CGL_sky_procedural_set_sun_position(CGL_sky* sky, CGL_vec3 position);
CGL_void CGL_sky_render(CGL_sky* sky, CGL_camera* camera);

#endif // CGL_EXCLUDE_SKY_RENDERER
#endif // CGL_EXCLUDE_GRAPHICS_API

// markov chains
#ifndef CGL_EXCLUDE_MARKOV_API

struct CGL_markov;
typedef struct CGL_markov CGL_markov;

typedef bool(*CGL_markov_token_function)(void*, const void*, const size_t, void*, void*); // (void* context, const void* data, const size_t data_size, void* key, void* value)

struct CGL_markov_token_function_ngram_text_context;
typedef struct CGL_markov_token_function_ngram_text_context CGL_markov_token_function_ngram_text_context;

CGL_markov_token_function_ngram_text_context* CGL_markov_token_function_ngram_text_context_create(size_t n);
CGL_void CGL_markov_token_function_ngram_text_context_destroy(CGL_markov_token_function_ngram_text_context* context);
bool CGL_markov_token_function_ngram_text(void* context, const void* data, const size_t data_size, void* key, void* value);

CGL_markov* CGL_markov_create(const size_t key_size, const size_t value_size);
bool CGL_markov_train(CGL_markov* markov, void* context, const void* data, const size_t data_size, const CGL_markov_token_function function);
bool CGL_markov_generate(const CGL_markov* markov, const void* key, void* value);
CGL_void CGL_markov_destroy(CGL_markov* markov);

#endif

// text rendering
#ifndef CGL_EXCLUDE_TEXT_RENDER

#ifndef CGL_EXCLUDE_GRAPHICS_API

struct CGL_font_character
{
	CGL_vec2 size;
	CGL_vec2 normalized_size;
	CGL_vec2 offset;
	CGL_vec2 normalized_offset;
	CGL_vec2 bearing;
	CGL_vec2 bearing_normalized;
	CGL_vec2 advance;
	CGL_vec2 advance_normalized;
	unsigned char* bitmap;
	char ch;
};
typedef struct CGL_font_character CGL_font_character;

struct CGL_font;
typedef struct CGL_font CGL_font;

CGL_bool CGL_text_init();
CGL_void CGL_text_shutdown();
CGL_font* CGL_font_load(const char* path);
CGL_font* CGL_font_load_from_memory(const char* data, CGL_sizei size);
CGL_void CGL_font_destory(CGL_font* font);
CGL_texture* CGL_font_get_atlas(CGL_font* font);
CGL_bool CGL_font_build_atlas(CGL_font* font, size_t width, size_t height, size_t font_size);
CGL_font_character* CGL_font_get_characters(CGL_font* font);
CGL_texture* CGL_text_bake_to_texture(const char* string, size_t string_length, CGL_font* font, size_t* width, size_t* height);

#endif

#endif

// widgets
#ifndef CGL_EXCLUDE_WIDGETS
#ifndef CGL_GRAPHICS_API

#ifndef CGL_WIDGETS_MAX_VERTICES
#define CGL_WIDGETS_MAX_VERTICES 1024 * 128
#endif

#ifndef CGL_WIDGETS_MAX_INDICES
#define CGL_WIDGETS_MAX_INDICES 1024 * 128
#endif

#ifndef CGL_WIDGETS_MAX_TEXTURES
#define CGL_WIDGETS_MAX_TEXTURES 64
#endif

struct CGL_widgets_context;
typedef struct CGL_widgets_context CGL_widgets_context;

CGL_widgets_context* CGL_widgets_context_create(size_t max_vertices, size_t max_indices);
CGL_void CGL_widgets_context_destroy(CGL_widgets_context* context);
CGL_widgets_context* CGL_window_get_current_context();
CGL_bool CGL_widgets_init();
CGL_void CGL_widgets_shutdown();
CGL_void CGL_window_set_current_context(CGL_widgets_context* context);
CGL_bool CGL_widgets_begin();
CGL_bool CGL_widgets_begin_int(CGL_float scale_x, CGL_float scale_y, CGL_float offset_x, CGL_float offset_y);
CGL_bool CGL_widgets_end();
CGL_bool CGL_widgets_flush();
CGL_bool CGL_widgets_flush_if_required();
// bool CGL_widgets_add_vertices(CGL_mesh_vertex* vertices, size_t vertex_count, uint32_t* indices, size_t index_count); // DEPRECATED
CGL_void CGL_widgets_add_vertex(CGL_mesh_vertex* vertex);
CGL_void CGL_widgets_add_mesh(CGL_mesh_cpu* mesh);
CGL_void CGL_widgets_add_vertex_p(CGL_vec3 position);
CGL_void CGL_widgets_add_vertex_p3f(CGL_float pos_x, CGL_float pos_y, CGL_float pos_z);
CGL_void CGL_widgets_add_vertex_pt(CGL_vec3 position, CGL_vec2 tex_coord);
CGL_void CGL_widgets_add_vertex_p3ft(CGL_float pos_x, CGL_float pos_y, CGL_float pos_z, CGL_vec2 tex_coord);
CGL_void CGL_widgets_add_vertex_pt2f(CGL_vec3 position, CGL_float tex_x, CGL_float tex_y);
CGL_void CGL_widgets_add_vertex_p3ft2f(CGL_float pos_x, CGL_float pos_y, CGL_float pos_z, CGL_float tex_x, CGL_float tex_y);
CGL_void CGL_widgets_set_stroke_color(CGL_color color);
CGL_void CGL_widgets_set_stroke_colorf(CGL_float r, CGL_float g, CGL_float b, CGL_float a);
CGL_void CGL_widgets_set_mask(CGL_vec4 mask);
CGL_void CGL_widgets_set_maskf(CGL_float min_x, CGL_float min_y, CGL_float max_x, CGL_float max_y);
// for backwards compatibility
#define CGL_widgets_set_stroke_thickness CGL_widgets_set_stroke_thicnkess 
CGL_void CGL_widgets_set_stroke_thicnkess(CGL_float thickness);
CGL_void CGL_widgets_set_fill_color(CGL_color color);
CGL_void CGL_widgets_set_fill_colorf(CGL_float r, CGL_float g, CGL_float b, CGL_float a);
CGL_void CGL_widgets_set_fill_mode(CGL_bool is_enabled);
CGL_void CGL_widgets_set_projection_matrix(CGL_mat4* matrix);
CGL_void CGL_widgets_enable_diffuse_shading(CGL_vec3 light_position, CGL_vec3 light_color);
CGL_void CGL_widgets_disable_diffuse_shading();
CGL_void CGL_widgets_set_view_matrix(CGL_mat4* matrix);
CGL_void CGL_widgets_set_model_matrix(CGL_mat4* matrix);
CGL_void CGL_widgets_set_texture(CGL_texture* texture);
CGL_void CGL_widgets_set_font_texture(CGL_texture* texture);
CGL_void CGL_widgets_set_texture_coordinate_so(CGL_float scale_x, CGL_float scale_y, CGL_float offset_x, CGL_float offset_y);
CGL_void CGL_widgets_apply_transformations_on_cpu();
CGL_void CGL_widgets_apply_transformations_on_gpu();
CGL_void CGL_widgets_add_triangle(CGL_vec3 a, CGL_vec3 b, CGL_vec3 c);
CGL_void CGL_widgets_add_quad(CGL_vec3 a, CGL_vec3 b, CGL_vec3 c, CGL_vec3 d);
CGL_void CGL_widgets_add_quad_8f(CGL_float ax, CGL_float ay, CGL_float bx, CGL_float by, CGL_float cx, CGL_float cy, CGL_float dx, CGL_float dy);
CGL_void CGL_widgets_add_line(CGL_vec3 start, CGL_vec3 end);
CGL_void CGL_widgets_add_line2f(CGL_float start_x, CGL_float start_y, CGL_float end_x, CGL_float end_y);
CGL_void CGL_widgets_add_rect(CGL_vec3 start, CGL_vec2 size);
CGL_void CGL_widgets_add_rect2f(CGL_float start_x, CGL_float start_y, CGL_float size_x, CGL_float size_y);
CGL_void CGL_widgets_add_rounded_rect2f(CGL_float start_x, CGL_float start_y, CGL_float size_x, CGL_float size_y, CGL_float radius, CGL_int res);
CGL_void CGL_widgets_add_circle(CGL_vec3 position, CGL_float radius);
CGL_void CGL_widgets_add_circle2f(CGL_float pos_x, CGL_float pos_y, CGL_float radius);
CGL_void CGL_widgets_add_circler(CGL_vec3 position, CGL_float radius, CGL_int res);
CGL_void CGL_widgets_add_circle2fr(CGL_float pos_x, CGL_float pos_y, CGL_float radius, CGL_int res);
CGL_void CGL_widgets_add_oval(CGL_vec3 position, CGL_vec2 radius);
CGL_void CGL_widgets_add_oval2f(CGL_float pos_x, CGL_float pos_y, CGL_float radius_x, CGL_float radius_y);
CGL_void CGL_widgets_add_oval2fr(CGL_float pos_x, CGL_float pos_y, CGL_float radiusx, CGL_float radiusy, CGL_int resolution);
CGL_void CGL_widgets_add_arc2f(CGL_float pos_x, CGL_float pos_y, CGL_float radius, CGL_float start_angle, CGL_float end_angle, CGL_int resolution);
CGL_bool CGL_widgets_add_character(char c, CGL_float x, CGL_float y, CGL_float sx, CGL_float sy);
CGL_bool CGL_widgets_add_string(const char* str, CGL_float x, CGL_float y, CGL_float sx, CGL_float sy);
#ifndef CGL_EXCLUDE_TEXT_RENDER
CGL_float CGL_widgets_add_string_with_font(const char* str, CGL_font* font, CGL_float x, CGL_float y, CGL_float sx, CGL_float scale_y);
#endif
CGL_void CGL_widgets_add_shape_out_line(CGL_shape* shape);
CGL_void CGL_widgets_add_cubic_bazier(CGL_vec3 start, CGL_vec3 end, CGL_vec3 control_1, CGL_vec3 control_2, CGL_int resolution);
CGL_void CGL_widgets_add_cubic_bazier2v(CGL_vec2 start, CGL_vec2 end, CGL_vec2 control_1, CGL_vec2 control_2, CGL_int resolution);
CGL_void CGL_widgets_add_cubic_bazier2f(CGL_float start_x, CGL_float start_y, CGL_float end_x, CGL_float end_y, CGL_float control_1_x, CGL_float control_1_y, CGL_float control_2_x, CGL_float control_2_y, CGL_int resolution);
CGL_void CGL_widgets_add_cubic_bazier_points(CGL_vec3 start, CGL_vec3 end, CGL_vec3 control_1, CGL_vec3 control_2, CGL_int resolution);
CGL_void CGL_widgets_add_cubic_bazier_points2v(CGL_vec2 start, CGL_vec2 end, CGL_vec2 control_1, CGL_vec2 control_2, CGL_int resolution);
CGL_void CGL_widgets_add_cubic_bazier_points2f(CGL_float start_x, CGL_float start_y, CGL_float end_x, CGL_float end_y, CGL_float control_1_x, CGL_float control_1_y, CGL_float control_2_x, CGL_float control_2_y, CGL_int resolution);
CGL_void CGL_widgets_add_plot_function(CGL_float start_x, CGL_float start_y, CGL_float size_x, CGL_float size_y, CGL_float(*func_to_plot)(CGL_float), CGL_int num_samples, CGL_float x_min, CGL_float x_max, CGL_float y_min, CGL_float y_max, CGL_float plot_thickness, CGL_vec3 plot_color, CGL_bool draw_axes, CGL_float axes_thickness, CGL_vec3 axes_color);
CGL_void CGL_widgets_add_plot_array(CGL_float start_x, CGL_float start_y, CGL_float size_x, CGL_float size_y, CGL_vec2* values, CGL_sizei count, CGL_float marker_size, CGL_vec3 marker_color, CGL_bool draw_axes, CGL_float axes_thickness, CGL_vec3 axes_color);
CGL_void CGL_widgets_add_plot_pie_chart(CGL_float start_x, CGL_float start_y, CGL_float radius, CGL_float* values, CGL_vec3* colors, CGL_sizei count, CGL_int resolution);
CGL_void CGL_widgets_add_bar_graph(CGL_float start_x, CGL_float start_y, CGL_float size_x, CGL_float size_y, CGL_float* values, CGL_vec3* colors, CGL_sizei count, CGL_bool draw_axes, CGL_float axes_thickness, CGL_vec3 axes_color, CGL_bool vertical);

#endif
#endif

#ifndef CGL_EXCLUDE_NODE_EDITOR

#ifdef CGL_EXCLUDE_WIDGETS
#error "CGL Widgets are required for CGL Node Editor"
#endif

#define CGL_NODE_EDITOR_NODE_MAX_PINS 8

struct CGL_node_editor;
typedef struct CGL_node_editor CGL_node_editor;

struct CGL_node_editor_node;
typedef struct CGL_node_editor_node CGL_node_editor_node;

struct CGL_node_editor_pin
{
	CGL_color color;
	CGL_node_editor_node* parent;
	void* user_data;
	CGL_float pos_x;
	CGL_float pos_y;
	CGL_int index;
	bool left;
	bool is_set;
};
typedef struct CGL_node_editor_pin CGL_node_editor_pin;

struct CGL_node_editor_node
{
	CGL_node_editor_pin left_pins[CGL_NODE_EDITOR_NODE_MAX_PINS];
	CGL_node_editor_pin right_pins[CGL_NODE_EDITOR_NODE_MAX_PINS];
	char title[256];
	CGL_color color;
	CGL_int pins_count[2];
	CGL_node_editor* editor;
	void* user_data;
	CGL_float pos_x;
	CGL_float pos_y;
	CGL_float size_x;
	CGL_float size_y;
	bool selected;
	bool render_title;
};

struct CGL_node_editor_input
{
	CGL_float mouse_pos_x;
	CGL_float mouse_pos_y;
	CGL_float aspect_ratio;
	CGL_float scale;
	bool mouse_button_left;
	bool mouse_button_right;
	bool mouse_button_middle;
	bool shift;
	bool ctrl;
	bool escape;
};
typedef struct CGL_node_editor_input CGL_node_editor_input;

CGL_node_editor* CGL_node_editor_create();
CGL_void CGL_node_editor_destroy(CGL_node_editor* editor);
CGL_void CGL_node_editor_update(CGL_node_editor* editor, CGL_node_editor_input* input);
CGL_void CGL_node_editor_set_on_connect(CGL_node_editor* editor, void(*onconnect)(CGL_node_editor_pin*, CGL_node_editor_pin*));
CGL_void CGL_node_editor_set_on_drop(CGL_node_editor* editor, void(*ondrop)(CGL_float, CGL_float, CGL_node_editor_pin*));
CGL_void CGL_node_editor_render_begin(CGL_node_editor* editor);
CGL_void CGL_node_editor_clear_focused_pins(CGL_node_editor* editor);
CGL_void CGL_node_editor_render_end(CGL_node_editor* editor);
CGL_void CGL_node_editor_set_offset(CGL_node_editor* editor, CGL_float x, CGL_float y);
CGL_void CGL_node_editor_get_offset(CGL_node_editor* editor, CGL_float* x, CGL_float* y);
CGL_void CGL_node_editor_get_linked_pins(CGL_node_editor* editor, CGL_node_editor_pin** x, CGL_node_editor_pin** y);
CGL_void CGL_node_editor_render_link(CGL_node_editor_pin* left, CGL_node_editor_pin* right, CGL_color color, CGL_float midper);
CGL_void CGL_node_editor_render_linkf(CGL_node_editor_pin* left, CGL_node_editor_pin* right, CGL_float cr, CGL_float cg, CGL_float cb, CGL_float ca, CGL_float midper);
CGL_void CGL_node_editor_render_link_curved(CGL_node_editor_pin* left, CGL_node_editor_pin* right, CGL_color color, CGL_float x_dist, CGL_float y_dist, CGL_int resolution);
CGL_void CGL_node_editor_render_link_curvedf(CGL_node_editor_pin* left, CGL_node_editor_pin* right, CGL_float cr, CGL_float cg, CGL_float cb, CGL_float ca, CGL_float x_dist, CGL_float y_dist, CGL_int resolution);

CGL_void CGL_node_editor_node_init(CGL_node_editor* editor, CGL_node_editor_node* node);
CGL_void CGL_node_editor_node_update(CGL_node_editor_node* node);
CGL_void CGL_node_editor_node_render(CGL_node_editor_node* node);
CGL_void CGL_node_editor_node_set_position(CGL_node_editor_node* node, CGL_float x, CGL_float y);
CGL_void CGL_node_editor_node_set_title(CGL_node_editor_node* node, const CGL_byte* title);
CGL_node_editor_pin* CGL_node_editor_node_get_pin(CGL_node_editor_node* node, bool left, CGL_int index);

#endif


#ifndef CGL_EXCLUDE_RAY_CASTER

#define CGL_RAY_CASTER_MAX_TRIANGLES 4096
#define CGL_RAY_CASTER_MAX_WALLS     4096

struct CGL_ray_caster;
typedef struct CGL_ray_caster CGL_ray_caster;

CGL_ray_caster* CGL_ray_caster_create();
CGL_void CGL_ray_caster_destroy(CGL_ray_caster* caster);
CGL_void CGL_ray_caster_add_walls(CGL_ray_caster* caster, CGL_vec4* walls, CGL_int walls_count);
CGL_void CGL_ray_caster_add_wall(CGL_ray_caster* caster, CGL_vec4 wall);
CGL_void CGL_ray_caster_clear_walls(CGL_ray_caster* caster);
float CGL_ray_caster_get_intersection_point_for_wall(CGL_vec2 pos, CGL_vec2 dir, CGL_vec4 wall, CGL_vec2* intersection_point, float* angle, CGL_float max_dist);
float CGL_ray_caster_get_intersection_point_for_walls(CGL_vec2 pos, CGL_vec2 dir, CGL_vec4* walls, CGL_int wall_count, CGL_vec2* intersection_point, float* angle, CGL_float max_dist);
CGL_void CGL_ray_caster_calculate(CGL_ray_caster* caster, CGL_vec2 pos, CGL_float rotation, bool visualise_rays);
bool CGL_ray_caster_is_in_view(CGL_ray_caster* caster, CGL_vec2 point);
CGL_void CGL_ray_caster_set_angle_limits(CGL_ray_caster* caster, CGL_float min_angle, CGL_float max_angle);
CGL_void CGL_ray_caster_set_max_distance(CGL_ray_caster* caster, CGL_float val);
CGL_shape_triangle* CGL_ray_caster_get_triangles(CGL_ray_caster* caster, CGL_int* count);

#endif


#ifndef CGL_EXCLUDE_SQUARE_MARCHER

struct CGL_square_marcher;
typedef struct CGL_square_marcher CGL_square_marcher;

typedef bool(*CGL_square_marcher_distance_function)(CGL_vec2, float*, void*);

CGL_square_marcher* CGL_square_marcher_create();
CGL_void CGL_square_marcher_destroy(CGL_square_marcher* marcher);
CGL_void CGL_square_marcher_set_user_data(CGL_square_marcher* marcher, void* user_data);
CGL_void* CGL_square_marcher_get_user_data(CGL_square_marcher* marcher);
CGL_void CGL_square_marcher_enable_interpolation(CGL_square_marcher* marcher, CGL_bool enable);
CGL_mesh_cpu* CGL_square_marcher_generate_mesh(CGL_square_marcher* marcher, CGL_square_marcher_distance_function sampler, CGL_vec2 start, CGL_vec2 end, CGL_int resolution_x, CGL_int resolution_y);

#endif


#ifndef CGL_EXCLUDE_POST_PROCESSOR

struct CGL_post_processor;
typedef struct CGL_post_processor CGL_post_processor;

CGL_void CGL_post_processor_init();
CGL_void CGL_post_processor_shutdown();
CGL_void CGL_post_processor_process_shades(CGL_texture* output, CGL_texture* scene, CGL_texture* albedo, CGL_int shades);
CGL_void CGL_post_processor_process_outline(CGL_texture* output, CGL_texture* scene, CGL_texture* normal, CGL_texture* depth, CGL_float outline_width);
CGL_void CGL_post_processor_process_hatching(CGL_texture* output, CGL_texture* scene, CGL_texture* uv, CGL_texture** hatch_tex, CGL_int hatch_tex_count);

// for legacy code
#define  CGL_toon_post_processor_init CGL_post_processor_init
#define  CGL_toon_post_processor_shutdown CGL_post_processor_shutdown
#define  CGL_toon_post_processor_process_shades CGL_post_processor_process_shades
#define  CGL_toon_post_processor_process_outline CGL_post_processor_process_outline

#endif


struct CGL_wav_file
{
	CGL_byte* data;
	CGL_int size;
	CGL_int channel_count;
	CGL_int sample_rate;
	CGL_int bits_per_sample;
	CGL_int data_size;
	CGL_float duration;
};
typedef struct CGL_wav_file CGL_wav_file;

CGL_bool CGL_wav_file_load(CGL_wav_file* file, const char* filename);
CGL_void CGL_wav_file_destroy(CGL_wav_file* file);
CGL_int CGL_wav_file_sample(CGL_wav_file* file, CGL_int channel, CGL_int sample_id);
CGL_int CGL_wav_file_sample_at_time(CGL_wav_file* file, CGL_int channel, CGL_float time);


#ifndef CGL_EXCLUDE_AUDIO

#include <AL/al.h>
#include <AL/alc.h>

struct CGL_audio_context;
typedef struct CGL_audio_context CGL_audio_context;

struct CGL_audio_source;
typedef struct CGL_audio_source CGL_audio_source;

struct CGL_audio_buffer;
typedef struct CGL_audio_buffer CGL_audio_buffer;

struct CGL_audio_listener;
typedef struct CGL_audio_listener CGL_audio_listener;

CGL_int CGL_audio_get_last_error();
const CGL_byte* CGL_audio_get_error_string(CGL_int error);
const CGL_byte* CGL_audio_get_device_list();
const CGL_byte* CGL_audio_get_default_device();
CGL_audio_context* CGL_audio_context_create(const CGL_byte* device_name);
CGL_void CGL_audio_context_destroy(CGL_audio_context* context);
CGL_void CGL_audio_make_context_current(CGL_audio_context* context);
CGL_audio_source* CGL_audio_source_create();
CGL_void CGL_audio_source_destroy(CGL_audio_source* source);
CGL_void CGL_audio_source_reset_to_defaults(CGL_audio_source* source);
CGL_void CGL_audio_source_set_buffer(CGL_audio_source* source, CGL_audio_buffer* buffer);
CGL_void CGL_audio_source_set_looping(CGL_audio_source* source, CGL_bool looping);
CGL_void CGL_audio_source_set_pitch(CGL_audio_source* source, CGL_float pitch);
CGL_void CGL_audio_source_set_gain(CGL_audio_source* source, CGL_float gain);
CGL_void CGL_audio_source_set_position(CGL_audio_source* source, CGL_vec3 position);
CGL_void CGL_audio_source_set_velocity(CGL_audio_source* source, CGL_vec3 velocity);
CGL_void CGL_audio_source_set_direction(CGL_audio_source* source, CGL_vec3 direction);
CGL_float CGL_audio_source_get_seconds_offset(CGL_audio_source* source);
CGL_void CGL_audio_source_set_seconds_offset(CGL_audio_source* source, CGL_sizei seconds);
CGL_sizei CGL_audio_source_get_samples_offset(CGL_audio_source* source);
CGL_void CGL_audio_source_set_samples_offset(CGL_audio_source* source, CGL_sizei samples);
CGL_sizei CGL_audio_source_get_bytes_offset(CGL_audio_source* source);
CGL_void CGL_audio_source_set_bytes_offset(CGL_audio_source* source, CGL_sizei bytes);
CGL_void CGL_audio_source_play(CGL_audio_source* source);
CGL_void CGL_audio_source_pause(CGL_audio_source* source);
CGL_void CGL_audio_source_stop(CGL_audio_source* source);
CGL_bool CGL_audio_source_is_playing(CGL_audio_source* source);
CGL_bool CGL_audio_source_is_paused(CGL_audio_source* source);
CGL_bool CGL_audio_source_is_stopped(CGL_audio_source* source);
CGL_audio_buffer* CGL_audio_buffer_create();
CGL_void CGL_audio_buffer_destroy(CGL_audio_buffer* buffer);
CGL_void CGL_audio_buffer_set_data_from_wav_file(CGL_audio_buffer* buffer, CGL_wav_file* file);
CGL_void CGL_audio_buffer_set_data(CGL_audio_buffer* buffer, void* data, ALenum format, ALsizei size, ALsizei freq);
CGL_void CGL_audio_listener_set_position(CGL_vec3 position);
CGL_void CGL_audio_listener_set_velocity(CGL_vec3 velocity);
CGL_void CGL_audio_listener_set_orientation(CGL_vec3 forward, CGL_vec3 up);


#endif


#ifndef CGL_EXCLUDE_TRAIL_RENDERER

struct CGL_trail_point
{
	CGL_vec3 position;
	struct CGL_trail_point* next;
	void* user_data;
	CGL_int index;
	CGL_float lifespan;
	CGL_float thickness;
	CGL_float distance;
};
typedef struct CGL_trail_point CGL_trail_point;

struct CGL_trail;
typedef struct CGL_trail CGL_trail;

typedef CGL_bool(*CGL_trail_point_update_function)(CGL_trail*, CGL_trail_point*);

CGL_trail* CGL_trail_create();
CGL_void CGL_trail_destroy(CGL_trail* trail);
CGL_void CGL_trail_render(CGL_trail* trail, CGL_mat4* view, CGL_mat4* projection, CGL_shader* shader);
CGL_void CGL_trail_add_point(CGL_trail* trail, CGL_vec3 point, CGL_float lifespan, CGL_float thickness);
CGL_void CGL_trail_set_resolution(CGL_trail* trail, CGL_int resolution);
CGL_void CGL_trail_update(CGL_trail* trail, CGL_float delta_time);
CGL_void CGL_trail_bake_mesh(CGL_trail* trail);
CGL_void CGL_trail_clear(CGL_trail* trail);
CGL_void CGL_trail_calculate_distances(CGL_trail* trail);
CGL_void CGL_trail_set_point_update_function(CGL_trail* trail, CGL_trail_point_update_function function);
CGL_void CGL_trail_set_user_data(CGL_trail* trail, void* user_data);
CGL_void* CGL_trail_get_user_data(CGL_trail* trail);
CGL_mesh_gpu* CGL_trail_get_mesh_gpu(CGL_trail* trail);
CGL_trail_point* CGL_trail_get_first_point(CGL_trail* trail);
CGL_float CGL_trail_get_length(CGL_trail* trail);
CGL_void CGL_trail_set_max_length(CGL_trail* trail, CGL_float length);
CGL_void CGL_trail_set_min_points_distance(CGL_trail* trail, CGL_float min_points_distance);

#endif

#ifdef CGL_INCLUDE_PASCAL_CASE_TYPES
typedef CGL_int Integer;
typedef CGL_float Real;
typedef CGL_byte Byte;
typedef CGL_bool Boolean;
typedef CGL_vec2 Vector2;
typedef CGL_vec3 Vector3;
typedef CGL_vec4 Vector4;
typedef CGL_mat2 Matrix2x2;
typedef CGL_mat3 Matrix3x3;
typedef CGL_mat4 Matrix4x4;
typedef CGL_quat Quaternion;
typedef CGL_color Color;
#endif


#ifndef CGL_EXCLUDE_NOISE_API

#ifndef CGL_NOISE_DATA_TYPE
#define CGL_NOISE_DATA_TYPE CGL_float
#endif

typedef CGL_NOISE_DATA_TYPE CGL_noise_data_type;

#define CGL_NOISE_TYPE_PERLIN           0
#define CGL_NOISE_TYPE_OPENSIMPLEX      1
#define CGL_NOISE_TYPE_OPENSIMPLEX2S    2
#define CGL_NOISE_TYPE_VALUE            3
#define CGL_NOISE_TYPE_VALUECUBIC       4
#define CGL_NOISE_TYPE_WORLEY           5
#define CGL_NOISE_TYPE_COUNT            6

#define CGL_NOISE_FRACTAL_TYPE_NONE     0
#define CGL_NOISE_FRACTAL_TYPE_FBM      1
#define CGL_NOISE_FRACTAL_TYPE_BILLOW   2
#define CGL_NOISE_FRACTAL_TYPE_RIGID    3
#define CGL_NOISE_FRACTAL_TYPE_PINGPONG 4
#define CGL_NOISE_FRACTAL_TYPE_COUNT    5



struct CGL_noise_params
{
	CGL_int type;
	CGL_int fractal_type;
	CGL_int octaves;
	CGL_noise_data_type frequency;
	CGL_noise_data_type lacunarity;
	CGL_noise_data_type gain;
	CGL_noise_data_type weighted_strength;
	CGL_noise_data_type ping_pong_strength;
};
typedef struct CGL_noise_params CGL_noise_params;

CGL_void CGL_noise_init();
CGL_void CGL_noise_shutdown();
CGL_noise_data_type CGL_noise_perlin(CGL_noise_data_type x, CGL_noise_data_type y, CGL_noise_data_type z);
CGL_noise_data_type CGL_noise_opensimplex(CGL_noise_data_type x, CGL_noise_data_type y, CGL_noise_data_type z);
CGL_noise_data_type CGL_noise_opensimplex2s(CGL_noise_data_type x, CGL_noise_data_type y, CGL_noise_data_type z);
CGL_noise_data_type CGL_noise_value(CGL_noise_data_type x, CGL_noise_data_type y, CGL_noise_data_type z);
CGL_noise_data_type CGL_noise_valuecubic(CGL_noise_data_type x, CGL_noise_data_type y, CGL_noise_data_type z);
CGL_noise_data_type CGL_noise_worley(CGL_noise_data_type x, CGL_noise_data_type y, CGL_noise_data_type z);
CGL_void CGL_noise_params_default(CGL_noise_params* params);
CGL_noise_data_type CGL_noise_get(CGL_noise_params* params, CGL_noise_data_type x, CGL_noise_data_type y, CGL_noise_data_type z);


#endif

#ifndef CGL_EXCLUDE_AI_API

// simple neural network

struct CGL_simple_neural_network;
typedef struct CGL_simple_neural_network CGL_simple_neural_network;

struct CGL_simple_neural_network_layer;
typedef struct CGL_simple_neural_network_layer CGL_simple_neural_network_layer;

typedef CGL_float(*CGL_simple_neural_network_activation_function)(CGL_float x);

CGL_simple_neural_network* CGL_simple_neural_network_create(CGL_int* layer_sizes, CGL_int layer_count);
CGL_byte* CGL_simple_neural_network_serialize_weights(CGL_simple_neural_network* network, CGL_sizei* size_out);
CGL_bool CGL_simple_neural_network_deserialize_weights(CGL_simple_neural_network* network, CGL_byte* data);
CGL_void CGL_simple_neural_network_set_layer_activation_function(CGL_simple_neural_network* network, CGL_int layer_index, CGL_simple_neural_network_activation_function activation_function, CGL_simple_neural_network_activation_function activation_function_derivative);
CGL_void CGL_simple_neural_network_destroy(CGL_simple_neural_network* network);
CGL_void CGL_simple_neural_network_evaluate(CGL_simple_neural_network* network, CGL_float* input, CGL_float* output);
CGL_void CGL_simple_neural_network_randomize_weights(CGL_simple_neural_network* network, CGL_float min_v, CGL_float max_v);
CGL_void CGL_simple_neural_network_copy_weights(CGL_simple_neural_network* a, CGL_simple_neural_network* b);
CGL_void CGL_simple_neural_network_mutate(CGL_simple_neural_network* a, CGL_float mutation_ratio);

// multi variable linear regression

struct CGL_linear_regression_context;
typedef struct CGL_linear_regression_context CGL_linear_regression_context;

typedef CGL_float(*CGL_linear_regression_sample_function)(CGL_void* user_data, CGL_float* input, CGL_float* output, CGL_int id);

CGL_linear_regression_context* CGL_linear_regression_context_create(CGL_int input_count);
CGL_void CGL_linear_regression_context_destroy(CGL_linear_regression_context* context);
CGL_void CGL_linear_regression_randomize_coefficents(CGL_linear_regression_context* context, CGL_float min_v, CGL_float max_v);
CGL_float CGL_linear_regression_evaluate(CGL_linear_regression_context* context, CGL_float* input, CGL_float* output);
CGL_bool CGL_linear_regression_train(CGL_linear_regression_context* context, CGL_linear_regression_sample_function sample_function, void* user_data, CGL_int sample_count, CGL_float learning_rate, CGL_int max_iterations);


#endif


#ifndef CGL_EXCLUDE_PATH_FINDING_API

struct CGL_path_finding_node
{
	void* data_ptr;
	CGL_int id;
	CGL_int parent_id;
	CGL_int child_id;
	CGL_float g;
	CGL_float h;
	CGL_float f;
	CGL_bool is_open;
	CGL_bool is_active;
};
typedef struct CGL_path_finding_node CGL_path_finding_node;

#ifndef CGL_PATH_FINDING_A_STAR_MAX_NEIGHBOURS
#define CGL_PATH_FINDING_A_STAR_MAX_NEIGHBOURS 256
#endif

struct CGL_path_finding_a_star_context;
typedef struct CGL_path_finding_a_star_context CGL_path_finding_a_star_context;

typedef CGL_float(*CGL_path_finding_heuristic_function)(void*, CGL_path_finding_node* a);
typedef CGL_float(*CGL_path_finding_cost_function)(void*, CGL_path_finding_node* a, CGL_path_finding_node* b);
typedef CGL_int(*CGL_path_finding_get_neighbors_function)(void*, CGL_path_finding_node* a, CGL_int* neighbors_out);
typedef CGL_bool(*CGL_path_finding_node_equals_function)(void*, CGL_path_finding_node* a, CGL_path_finding_node* b);

CGL_void CGL_path_finding_node_init(CGL_path_finding_node* node, void* data_ptr);

CGL_path_finding_a_star_context* CGL_path_finding_a_star_context_create(CGL_int max_nodes_count, CGL_bool copy_data, CGL_int data_size);
CGL_int CGL_path_finding_a_star_add_node(CGL_path_finding_a_star_context* context, CGL_path_finding_node node, CGL_path_finding_node_equals_function node_equals_function);
CGL_bool CGL_path_finding_a_star_find_path(CGL_path_finding_a_star_context* context, CGL_path_finding_node start_node, CGL_path_finding_node end_node, CGL_path_finding_heuristic_function heuristic_function, CGL_path_finding_cost_function cost_function, CGL_path_finding_get_neighbors_function get_neighbors_function, CGL_path_finding_node_equals_function node_equals_function, void* user_data);
CGL_float CGL_path_finding_a_star_get_path_length(CGL_path_finding_a_star_context* context);
CGL_path_finding_node* CGL_path_finding_a_star_get_path_start_node(CGL_path_finding_a_star_context* context);
CGL_bool CGL_path_finding_a_star_has_path(CGL_path_finding_a_star_context* context);
CGL_void* CGL_path_finding_a_star_next_in_path(CGL_path_finding_a_star_context* context, void* data_out);
CGL_void CGL_path_finding_a_star_reorder_path(CGL_path_finding_a_star_context* context);
CGL_void CGL_path_finding_a_star_clear_path(CGL_path_finding_a_star_context* context);
CGL_void CGL_path_finding_a_star_context_destroy(CGL_path_finding_a_star_context* context);

#endif

#ifndef CGL_EXCLUDE_CSV_API

struct CGL_csv;
typedef struct CGL_csv CGL_csv;

CGL_csv* CGL_csv_create(CGL_sizei item_max_size);
CGL_void CGL_csv_destroy(CGL_csv* csv);
CGL_bool CGL_csv_load(CGL_csv* csv, const CGL_byte* file_path, const CGL_byte* seperator);
CGL_bool CGL_csv_load_from_buffer(CGL_csv* csv, const CGL_byte* buffer, const CGL_byte* seperator);
CGL_bool CGL_csv_save(CGL_csv* csv, const CGL_byte* file_path, const CGL_byte* separator);
CGL_bool CGL_csv_save_to_buffer(CGL_csv* csv, CGL_byte* buffer, const CGL_byte* separator);
CGL_bool CGL_csv_add_column(CGL_csv* csv);
CGL_bool CGL_csv_add_row(CGL_csv* csv);
CGL_byte* CGL_csv_set_item(CGL_csv* csv, CGL_int row, CGL_int column, const CGL_byte* item);
CGL_byte* CGL_csv_get_item(CGL_csv* csv, CGL_int row, CGL_int column, CGL_byte* item_out);
CGL_bool CGL_csv_get_row(CGL_csv* csv, CGL_int row, CGL_byte* row_out);
CGL_bool CGL_csv_get_column(CGL_csv* csv, CGL_int column, CGL_byte* column_out);
CGL_int CGL_csv_get_row_count(CGL_csv* csv);
CGL_int CGL_csv_get_column_count(CGL_csv* csv);
CGL_void CGL_csv_clear(CGL_csv* csv);


#endif

#ifndef CGL_EXCLUDE_IMAGE_FILE_API

#define CGL_IMAGE_FORMAT_UNKNOWN    0x00AB0
#define CGL_IMAGE_FORMAT_PNG        0x00AB1
#define CGL_IMAGE_FORMAT_JPEG       0x00AB2
#define CGL_IMAGE_FORMAT_BMP        0x00AB3
#define CGL_IMAGE_FORMAT_GIF        0x00AB4

CGL_bool CGL_image_file_is_png_f(FILE* file);
CGL_bool CGL_image_file_is_png(const CGL_byte* file_path);
CGL_bool CGL_image_file_is_bmp_f(FILE* file);
CGL_bool CGL_image_file_is_bmp(const CGL_byte* file_path);
CGL_bool CGL_image_file_is_gif_f(FILE* file);
CGL_bool CGL_image_file_is_gif(const CGL_byte* file_path);
CGL_bool CGL_image_file_is_jpeg_f(FILE* file);
CGL_bool CGL_image_file_is_jpeg(const CGL_byte* file_path);
CGL_int CGL_image_file_get_format_f(FILE* file);
CGL_int CGL_image_file_get_format(const CGL_byte* file_path);

#endif

#ifndef CGL_EXCLUDE_ND_TREE_API

#ifndef CGL_ND_TREE_MAX_ITEMS_PER_MEMORY_BANK
#define CGL_ND_TREE_MAX_ITEMS_PER_MEMORY_BANK 8
#endif

#ifndef CGL_ND_TREE_MAX_MEMORY_BANKS_PER_NODE
#define CGL_ND_TREE_MAX_MEMORY_BANKS_PER_NODE 64
#endif

struct CGL_nd_tree;
typedef struct CGL_nd_tree CGL_nd_tree;

struct CGL_nd_tree_node;
typedef struct CGL_nd_tree_node CGL_nd_tree_node;

CGL_nd_tree* CGL_nd_tree_create(CGL_int dimensions, CGL_sizei item_size, CGL_int max_items_per_node, CGL_sizei max_nodes, CGL_sizei max_items, CGL_bool store_positions);
CGL_nd_tree* CGL_quad_tree_create(CGL_sizei item_size, CGL_int max_items_per_node, CGL_sizei max_nodes, CGL_sizei max_items, CGL_bool store_positions);
CGL_nd_tree* CGL_oct_tree_create(CGL_sizei item_size, CGL_int max_items_per_node, CGL_sizei max_nodes, CGL_sizei max_items, CGL_bool store_positions);
CGL_void CGL_nd_tree_destroy(CGL_nd_tree* tree);
CGL_bool CGL_nd_tree_reset(CGL_nd_tree* tree, CGL_float* aabb_min, CGL_float* aabb_max, CGL_int items_per_node, CGL_int max_depth, CGL_bool fast_approx_mode);
CGL_bool CGL_quad_tree_reset(CGL_nd_tree* tree, CGL_float x_min, CGL_float y_min, CGL_float x_max, CGL_float y_max, CGL_int items_per_node, CGL_int max_depth, CGL_bool fast_approx_mode);
CGL_bool CGL_oct_tree_reset(CGL_nd_tree* tree, CGL_float x_min, CGL_float y_min, CGL_float z_min, CGL_float x_max, CGL_float y_max, CGL_float z_max, CGL_int items_per_node, CGL_int max_depth, CGL_bool fast_approx_mode);
CGL_bool CGL_nd_tree_add(CGL_nd_tree* tree, CGL_float* position, CGL_void* item);
CGL_bool CGL_quad_tree_add(CGL_nd_tree* tree, CGL_float px, CGL_float py, CGL_void* item);
CGL_bool CGL_oct_tree_add(CGL_nd_tree* tree, CGL_float px, CGL_float py, CGL_float pz, CGL_void* item);
CGL_int CGL_nd_tree_get_items_in_range(CGL_nd_tree* tree, CGL_float* p_min, CGL_float* p_max, CGL_void* items_out, CGL_int max_items);
CGL_int CGL_quad_tree_get_items_in_range(CGL_nd_tree* tree, CGL_float x_min, CGL_float y_min, CGL_float x_max, CGL_float y_max, CGL_void* items_out, CGL_int max_items);
CGL_int CGL_oct_tree_get_items_in_range(CGL_nd_tree* tree, CGL_float x_min, CGL_float y_min, CGL_float z_min, CGL_float x_max, CGL_float y_max, CGL_float z_max, CGL_void* items_out, CGL_int max_items);

#endif


// ------------------------------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------ Implementation of CGL -------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------------------------------

#ifdef CGL_IMPLEMENTATION

// include windows headers for windows builds
#if defined(_WIN32) || defined(_WIN64)
#pragma warning(push, 0)
#define WIN32_LEAN_AND_MEAN
#ifndef  CGL_WASM

#ifdef APIENTRY
#undef APIENTRY
#endif

#include <Windows.h>
#endif
#pragma warning(pop)
#endif

#ifdef __EMSCRIPTEN__
#include <emscripten/emscripten.h>
#endif

// list
#if 1

// data structures
struct CGL_list
{
	size_t size;
	size_t capacity;
	size_t item_size;
	CGL_float increase_factor;
	void* data;
};

CGL_list* CGL_list_create(size_t item_size, size_t initial_capacity)
{
	CGL_list* list = (CGL_list*)malloc(sizeof(CGL_list));
	if (!list) return NULL;
	list->size = 0;
	list->capacity = initial_capacity;
	list->item_size = item_size;
	list->increase_factor = 1.5f;
	list->data = malloc(list->capacity * item_size);
	return list;
}

CGL_void CGL_list_destroy(CGL_list* list)
{
	CGL_free(list->data);
	CGL_free(list);
}

CGL_void CGL_list_set_increase_factor(CGL_list* list, CGL_float increase_factor)
{
	list->increase_factor = increase_factor;
}

CGL_float CGL_list_get_increase_factor(CGL_list* list)
{
	return list->increase_factor;
}

CGL_sizei CGL_list_get_item_size(CGL_list* list)
{
	return list->item_size;
}

CGL_sizei CGL_list_get_size(CGL_list* list)
{
	return list->size;
}

CGL_sizei CGL_list_get_capacity(CGL_list* list)
{
	return list->capacity;
}

CGL_sizei CGL_list_push(CGL_list* list, void* data)
{
	if (list->size == list->capacity)
	{
		size_t new_capacity = (size_t)(list->capacity * list->increase_factor);
		list->data = realloc(list->data, new_capacity * list->item_size);
		list->capacity = new_capacity;
	}
	memcpy(((char*)list->data + list->size * list->item_size), data, list->item_size);
	list->size += 1;
	return list->size - 1;
}

CGL_sizei CGL_list_pop(CGL_list* list, void* data)
{
	if (list->size == 0) return 0;
	list->size -= 1;
	if (data) memcpy(data, ((char*)list->data + list->size * list->item_size), list->item_size);
	return list->size;
}

CGL_void* CGL_list_get(CGL_list* list, size_t index, void* data)
{
	if (index >= list->size /* || index < 0 */) return NULL;
	if (data) memcpy(data, ((char*)list->data + index * list->item_size), list->item_size);
	return ((char*)list->data + index * list->item_size);
}

CGL_void* CGL_list_get_random(CGL_list* list, void* data)
{
	CGL_int index = CGL_utils_random_int(0, list->size - 1);
	return CGL_list_get(list, index, data);
}

CGL_void* CGL_list_set(CGL_list* list, size_t index, void* data)
{
	if (index >= list->size /* || index < 0 */) return NULL;
	if (data) memcpy(((char*)list->data + index * list->item_size), data, list->item_size);
	return ((char*)list->data + index * list->item_size);
}

CGL_bool CGL_list_is_empty(CGL_list* list)
{
	return list->size == 0;
}

CGL_sizei CGL_list_find(CGL_list* list, void* data)
{
	for (CGL_sizei i = 0; i < list->size; i++)
		if (memcmp(((CGL_byte*)list->data + i * list->item_size), data, list->item_size) == 0)
			return i;
	return (CGL_sizei)UINT64_MAX;
}

CGL_void CGL_list_reserve(CGL_list* list, size_t size)
{
	if (list->capacity > size) return;
	size_t new_capacity = size;
	list->data = realloc(list->data, new_capacity * list->item_size);
	list->capacity = new_capacity;
}

CGL_void CGL_list_fill(CGL_list* list, size_t size)
{
	CGL_list_reserve(list, size);
	list->size = CGL_utils_max(size, list->size);
}

CGL_void CGL_list_clear(CGL_list* list)
{
	list->size = 0;
}



#ifndef CGL_EXCLUDES_THREADS

#ifdef _WIN32

#include <process.h>

struct CGL_thread
{
	uintptr_t id;
	HANDLE handle;
	CGL_thread_function function;
	bool running;
};

struct CGL_mutex
{
	HANDLE handle;
};

CGL_thread* CGL_thread_create()
{
	CGL_thread* thread = (CGL_thread*)malloc(sizeof(CGL_thread));
	if (!thread) return NULL;
	thread->function = NULL;
	thread->handle = NULL;
	thread->id = 0;
	thread->running = false;
	return thread;
}


// The function CGL_thread_start() starts a new thread. The function
// argument is the function that the thread will execute. The argument
// argument is passed to the thread function. The return value is true
// if the thread was successfully started, and false otherwise.
bool CGL_thread_start(CGL_thread* thread, CGL_thread_function function, void* argument)
{
	if (thread->running) CGL_thread_join(thread);
	if (thread->handle) CloseHandle(thread->handle);
	thread->function = function;
	thread->handle = (HANDLE)_beginthread(function, 0, argument);
	thread->id = (uintptr_t)GetThreadId(thread->handle);
	thread->running = true;
	return thread->handle != NULL;
}


// This function is called when the thread is destroyed
// It frees the thread structure from memory
CGL_void CGL_thread_destroy(CGL_thread* thread)
{
	if (thread->running) CGL_thread_join(thread);
	if (thread->handle) CloseHandle(thread->handle);
	CGL_free(thread);
}

uintptr_t CGL_thread_get_id(CGL_thread* thread)
{
	return thread->id;
}

// Description: This function checks to see if the thread is running.
// Parameters:
//  thread: The thread to check
// Return value: true if the thread is running, false otherwise
bool CGL_thread_is_running(CGL_thread* thread)
{
	if (!thread->handle) return false;
	DWORD exit_code;
	if (!GetExitCodeThread(thread->handle, &exit_code)) return false;
	if (exit_code == STILL_ACTIVE)
		thread->running = true;
	else
	{
		thread->running = false;
		CloseHandle(thread->handle);
	}
	return thread->running;
}

/*
 * This function joins the thread, which means that the calling thread
 * will wait until the thread represented by the given thread pointer
 * has finished executing. This function returns true if the thread
 * was joined successfully, or false if an error occurred.
 */
bool CGL_thread_join(CGL_thread* thread)
{
	if (!thread->handle) return true;
	bool result = (WaitForSingleObject(thread->handle, INFINITE) != WAIT_FAILED);
	thread->running = false;
	return result;
}

/*
 * Returns true if the thread is joinable, false otherwise.
 *
 * A thread is joinable if it can be waited upon. A thread is not joinable
 * if it has already been joined or detached.
 *
 * When a thread is created, it is joinable by default. It can be made
 * unjoinable by calling pthread_detach. It can be made joinable again by
 * calling pthread_join.
 */
bool CGL_thread_joinable(CGL_thread* thread)
{
	(void)thread;
	return true; // Temporary
}


/*
 * Create a new mutex. If set is true, the mutex is created set. Otherwise, it
 * is created unset.
 */
CGL_mutex* CGL_mutex_create(bool set)
{
	CGL_mutex* mutex = (CGL_mutex*)malloc(sizeof(CGL_mutex));
	mutex->handle = CreateMutex(NULL, (BOOL)set, NULL);
	return mutex;
}

/* Destroy a mutex. */
CGL_void CGL_mutex_destroy(CGL_mutex* mutex)
{
	if (mutex->handle) CloseHandle(mutex->handle);
	CGL_free(mutex);
}

// This function locks a mutex, and returns 1 if it was successful, and 0 otherwise.
// If timeout is 0, it will wait forever for the lock to be acquired.
// If timeout is non-zero, it will wait for at most timeout microseconds for the lock to be acquired.
// If the lock is acquired within the timeout period, this function returns 1. Otherwise, it returns 0.
int CGL_mutex_lock(CGL_mutex* mutex, uint64_t timeout)
{
	return (int)WaitForSingleObject(mutex->handle, (DWORD)timeout);
}

// CGL_mutex_release: Releases a mutex.
//    mutex: The mutex to release.
CGL_void CGL_mutex_release(CGL_mutex* mutex)
{
	ReleaseMutex(mutex->handle);
}

#else // for posix (using pthread)

#include <pthread.h>
#include <signal.h> 

struct CGL_thread
{
	uintptr_t id;
	pthread_t handle;
	CGL_thread_function function;
	bool running;
};

struct CGL_mutex
{
	pthread_mutex_t handle;
};

CGL_thread* CGL_thread_create()
{
	CGL_thread* thread = (CGL_thread*)malloc(sizeof(CGL_thread));
	thread->function = NULL;
	// thread->handle = NULL;
	thread->id = 0;
	thread->running = false;
	return thread;
}

bool CGL_thread_start(CGL_thread* thread, CGL_thread_function function, void* argument)
{
	if (thread->running) CGL_thread_join(thread);
	thread->function = function;
	bool success = pthread_create(&thread->handle, 0, function, argument);
	thread->id = (uintptr_t)thread->handle; // Temporary
	thread->running = true;
	return success;
}

CGL_void CGL_thread_destroy(CGL_thread* thread)
{
	if (thread->running) CGL_thread_join(thread);
	CGL_free(thread);
}

uintptr_t CGL_thread_get_id(CGL_thread* thread)
{
	return thread->id;
}

bool CGL_thread_is_running(CGL_thread* thread)
{
	if (!thread->handle) return false;

	//  thread->running = (pthread_kill(thread->handle, 0) == 0);
	if (pthread_kill(thread->handle, 0) == 0)
		thread->running = true;
	else
		thread->running = false;
	return thread->running;
}

bool CGL_thread_join(CGL_thread* thread)
{
	if (!thread->handle) return true;
	return pthread_join(thread->handle, NULL);
}

bool CGL_thread_joinable(CGL_thread* thread)
{
	(void)thread;
	return true; // Temporary
}


CGL_mutex* CGL_mutex_create(bool set)
{
	(void)set;
	CGL_mutex* mutex = (CGL_mutex*)malloc(sizeof(CGL_mutex));
	pthread_mutex_init(&mutex->handle, NULL);
	return mutex;
}

CGL_void CGL_mutex_destroy(CGL_mutex* mutex)
{
	pthread_mutex_destroy(&mutex->handle);
	CGL_free(mutex);
}

int CGL_mutex_lock(CGL_mutex* mutex, uint64_t timeout)
{
	(void)timeout;
	return pthread_mutex_lock(&mutex->handle);
}

CGL_void CGL_mutex_release(CGL_mutex* mutex)
{
	pthread_mutex_unlock(&mutex->handle);
}


#endif

#endif

#endif

// hashtable
#if 1


struct CGL_hashtable_entry
{
	uint8_t key[CGL_HASHTABLE_MAX_KEY_SIZE];
	uint8_t value_static[CGL_HASHTABLE_ENTRY_STATIC_VALUE_SIZE]; // if value size is less than CGL_HASHTABLE_ENTRY_VALUE_SIZE then place here in static memory rather than allocating
	size_t value_size;
	size_t next_entry; // next entry in the linked list with same hash
	size_t index;
	void* value;
	bool set;
};

struct CGL_hashtable
{
	CGL_hashtable_entry* storage;
	size_t* table;
	CGL_hash_function hash_function;
	size_t capacity;
	size_t table_size;
	size_t key_size;
	size_t count;
	CGL_float growth_rate;
};

struct CGL_hashtable_iterator
{
	CGL_hashtable* hashtable;
	CGL_hashtable_entry* current_entry;
	size_t index;
};

static void __CGL_hashtable_calculate_hashtable_index_key_size(CGL_hashtable* table, size_t* key_size, size_t* hashtable_index, const void* key)
{
	const size_t key_size_raw = (table->key_size == 0) ? strlen((const char*)key) + 1 : table->key_size;
	size_t key_size_l = CGL_utils_clamp(key_size_raw, 1ul, CGL_HASHTABLE_MAX_KEY_SIZE);
	*key_size = key_size_l;
	size_t hashtable_index_l = table->hash_function(key, key_size_l) % table->table_size;
	*hashtable_index = hashtable_index_l;
}

static CGL_hashtable_entry* __CGL_hashtable_get_entry_ptr(CGL_hashtable* table, const void* key, size_t* table_index)
{
	size_t key_size, hashtable_index;
	__CGL_hashtable_calculate_hashtable_index_key_size(table, &key_size, &hashtable_index, key);
	size_t entry_id = table->table[hashtable_index];
	if (entry_id == 0) return NULL;
	CGL_hashtable_entry* entry = &table->storage[entry_id];
	if (table_index)
	{
		if (memcmp(entry->key, key, key_size) == 0) *table_index = hashtable_index;
		else *table_index = (size_t)UINT64_MAX;
	}

	while (entry->index != 0)
	{
		if (memcmp(entry->key, key, key_size) == 0)
			return entry;
		entry = &table->storage[entry->next_entry];
	}

	return NULL;
}

static bool __CGL_hashtable_expand_storage(CGL_hashtable* table)
{
	table->capacity = (size_t)(table->capacity * table->growth_rate);
	table->storage = (CGL_hashtable_entry*)CGL_malloc(table->capacity * sizeof(CGL_hashtable_entry));
	memset(table->storage, 0, table->capacity * sizeof(CGL_hashtable_entry));
	CGL_free(table->storage);
	return table->storage != NULL;
}

static void __CGL_hashtable_reset_hashtable_entry(CGL_hashtable_entry* entry)
{
	memset(entry->key, 0, CGL_HASHTABLE_MAX_KEY_SIZE);
	memset(entry->value_static, 0, CGL_HASHTABLE_ENTRY_STATIC_VALUE_SIZE);
	entry->value_size = 0;
	entry->next_entry = 0;
	if (entry->value) CGL_free(entry->value);
	entry->value = NULL;
	entry->set = false;
	entry->index = 0;
}

static size_t __CGL_hashtable_get_new_entry(CGL_hashtable* table, bool* expanded)
{
	size_t entry = 1;
	for (; entry < table->capacity; entry++)
		if (!table->storage[entry].set)
			break;
	if (entry >= table->capacity)
	{
		entry = table->capacity;
		if (!__CGL_hashtable_expand_storage(table)) return 0;
		if (expanded) *expanded = true;
	}
	table->storage[entry].index = entry;
	return entry;
}

CGL_hashtable* CGL_hashtable_create(size_t table_size, size_t key_size, size_t initial_capacity)
{
	CGL_hashtable* table = (CGL_hashtable*)CGL_malloc(sizeof(CGL_hashtable));
	if (!table) return NULL;
	table->table_size = table_size;
	table->key_size = key_size;
	table->capacity = initial_capacity;
	table->count = 0;
	table->growth_rate = 1.5f;
	table->hash_function = CGL_utils_super_fast_hash;
	table->storage = (CGL_hashtable_entry*)CGL_malloc(sizeof(CGL_hashtable_entry) * initial_capacity);
	if (!table->storage) { CGL_free(table); return NULL; }
	memset(table->storage, 0, (sizeof(CGL_hashtable_entry) * initial_capacity));
	table->table = (size_t*)CGL_malloc(sizeof(size_t) * table_size);
	if (!table->table) { CGL_free(table->storage); CGL_free(table); return NULL; }
	memset(table->table, 0, (sizeof(size_t) * table_size));
	return table;
}

CGL_void CGL_hashtable_destroy(CGL_hashtable* table)
{
	for (size_t i = 0; i < table->capacity; i++)
		if (table->storage[i].set && table->storage[i].value_size > CGL_HASHTABLE_ENTRY_STATIC_VALUE_SIZE)
			CGL_free(table->storage[i].value);
	CGL_free(table->storage);
	CGL_free(table->table);
	CGL_free(table);
}

CGL_void CGL_hashtable_set(CGL_hashtable* table, const void* key, const void* value, size_t value_size)
{
	size_t key_size, hashtable_index;
	__CGL_hashtable_calculate_hashtable_index_key_size(table, &key_size, &hashtable_index, key);


	size_t new_entry_id = 0;
	CGL_hashtable_entry* existing_entry = __CGL_hashtable_get_entry_ptr(table, key, NULL);
	if (existing_entry)
	{
		if (existing_entry->value_size > CGL_HASHTABLE_ENTRY_STATIC_VALUE_SIZE) CGL_free(existing_entry->value);
		new_entry_id = existing_entry->index;
	}
	else
	{
		new_entry_id = __CGL_hashtable_get_new_entry(table, NULL);
		if (table->table[hashtable_index] == 0)
			table->table[hashtable_index] = new_entry_id;
		else
		{
			CGL_hashtable_entry* target_entry_ptr = &table->storage[table->table[hashtable_index]];
			while (target_entry_ptr->next_entry != 0) target_entry_ptr = &table->storage[target_entry_ptr->next_entry];
			target_entry_ptr->next_entry = new_entry_id;
		}
	}


	table->storage[new_entry_id].set = true;
	memcpy(table->storage[new_entry_id].key, key, key_size);
	table->storage[new_entry_id].value_size = value_size;
	table->storage[new_entry_id].next_entry = 0;
	table->storage[new_entry_id].value = NULL;
	void* target_value_ptr = NULL;
	if (value_size <= CGL_HASHTABLE_ENTRY_STATIC_VALUE_SIZE) target_value_ptr = table->storage[new_entry_id].value_static;
	else target_value_ptr = table->storage[new_entry_id].value = CGL_malloc(value_size);
	memcpy(target_value_ptr, value, value_size);

}

size_t CGL_hashtable_get(CGL_hashtable* table, const void* key, void* value)
{
	CGL_hashtable_entry* entry = __CGL_hashtable_get_entry_ptr(table, key, NULL);
	if (!entry) return 0;
	if (value && entry->value_size > 0) memcpy(value, ((entry->value_size > CGL_HASHTABLE_ENTRY_STATIC_VALUE_SIZE) ? entry->value : entry->value_static), entry->value_size);
	return entry->value_size;
}

CGL_void* CGL_hashtable_get_ptr(CGL_hashtable* table, const void* key, size_t* value)
{
	CGL_hashtable_entry* entry = __CGL_hashtable_get_entry_ptr(table, key, NULL);
	if (!entry) return NULL;
	if (value) *value = entry->value_size;
	return (entry->value_size > CGL_HASHTABLE_ENTRY_STATIC_VALUE_SIZE) ? entry->value : entry->value_static;
}

bool CGL_hashtable_exists(CGL_hashtable* table, const void* key)
{
	return __CGL_hashtable_get_entry_ptr(table, key, NULL) != NULL;
}

bool CGL_hashtable_remove(CGL_hashtable* table, const void* key)
{
	if (!CGL_hashtable_exists(table, key)) return false;

	size_t key_size, hashtable_index;
	__CGL_hashtable_calculate_hashtable_index_key_size(table, &key_size, &hashtable_index, key);

	CGL_hashtable_entry* entry_to_clear = &table->storage[table->table[hashtable_index]];
	if (memcmp(entry_to_clear->key, key, key_size) == 0)
		table->table[hashtable_index] = entry_to_clear->next_entry;
	else
	{
		while (table->storage[table->table[hashtable_index]].next_entry != 0)
		{
			if (memcmp(table->storage[table->storage[table->table[hashtable_index]].next_entry].key, key, key_size) == 0)
			{
				entry_to_clear = &table->storage[table->storage[table->table[hashtable_index]].next_entry];
				table->storage[table->table[hashtable_index]].next_entry = table->storage[table->storage[table->table[hashtable_index]].next_entry].next_entry;
			}
		}
	}
	__CGL_hashtable_reset_hashtable_entry(entry_to_clear);
	return true;
}

CGL_void CGL_hashtable_set_growth_rate(CGL_hashtable* table, CGL_float rate)
{
	table->growth_rate = rate;
}

size_t CGL_hashtable_get_size(CGL_hashtable* table)
{
	return table->count;
}

CGL_void CGL_hashtable_set_hash_function(CGL_hashtable* table, CGL_hash_function hash_function)
{
	table->hash_function = hash_function;
}

CGL_hashtable_iterator* CGL_hashtable_iterator_create(CGL_hashtable* table)
{
	CGL_hashtable_iterator* iterator = (CGL_hashtable_iterator*)CGL_malloc(sizeof(CGL_hashtable_iterator));
	if (!iterator) return NULL;
	iterator->hashtable = table;
	iterator->index = 1;
	return iterator;
}

CGL_void CGL_hashtable_iterator_destroy(CGL_hashtable_iterator* iterator)
{
	CGL_free(iterator);
}

CGL_void CGL_hashtable_iterator_reset(CGL_hashtable_iterator* iterator)
{
	iterator->index = 1;
}

bool CGL_hashtable_iterator_next(CGL_hashtable_iterator* iterator, void* key, void* data, size_t* size)
{
	while (iterator->index < iterator->hashtable->capacity)
	{
		if (iterator->hashtable->storage[iterator->index].set) break;
		else iterator->index++;
	}
	if (iterator->index >= iterator->hashtable->capacity) iterator->current_entry = NULL;
	else iterator->current_entry = &iterator->hashtable->storage[iterator->index];
	iterator->index++;
	return CGL_hashtable_iterator_curr(iterator, key, data, size);
}

bool CGL_hashtable_iterator_curr(CGL_hashtable_iterator* iterator, void* key, void* data, size_t* size)
{
	if (iterator->current_entry)
	{
		size_t key_size, hashtable_index;
		__CGL_hashtable_calculate_hashtable_index_key_size(iterator->hashtable, &key_size, &hashtable_index, iterator->current_entry->key);
		if (key) memcpy(key, iterator->current_entry->key, key_size);
		if (data && iterator->current_entry->value_size <= CGL_HASHTABLE_ENTRY_STATIC_VALUE_SIZE) memcpy(data, iterator->current_entry->value_static, iterator->current_entry->value_size);
		else if (data && iterator->current_entry->value_size > CGL_HASHTABLE_ENTRY_STATIC_VALUE_SIZE) memcpy(data, iterator->current_entry->value, iterator->current_entry->value_size);
		if (size) *size = iterator->current_entry->value_size;
	}
	return iterator->current_entry != NULL;;
}

CGL_void* CGL_hashtable_iterator_curr_key(CGL_hashtable_iterator* iterator)
{
	if (!iterator->current_entry) return NULL;
	return iterator->current_entry->key;
}

#endif

// networking
#if 1

#ifndef CGL_EXCLUDE_NETWORKING

#pragma warning(push, 0)

#ifndef CGL_EXCLUDE_SSL_SOCKET

#include <openssl/ssl.h>
#include <openssl/err.h>
#include <openssl/crypto.h>

#endif

#if defined(_WIN32) || defined(_WIN64)

#include <ws2tcpip.h>
#include <stdlib.h>
#include <stdio.h>

#pragma comment (lib, "Ws2_32.lib")
#pragma comment (lib, "Mswsock.lib")
#pragma comment (lib, "AdvApi32.lib")



struct CGL_net_addrinfo
{
	CGL_int ai_flags;
	CGL_int ai_family;
	CGL_int ai_socktype;
	CGL_int ai_protocol;
	size_t ai_addrlen;
	struct sockaddr ai_addr;
};

struct CGL_net_socket
{
	SOCKET socket;
};

bool CGL_net_init()
{
	WSADATA wsa_data;
	bool result = WSAStartup(MAKEWORD(2, 2), &wsa_data) == 0;
#ifndef CGL_EXCLUDE_SSL_SOCKET
	SSL_library_init();
	SSLeay_add_ssl_algorithms();
	SSL_load_error_strings();
#endif
	return result;
}

CGL_void CGL_net_shutdown()
{
#ifndef CGL_EXCLUDE_SSL_SOCKET
	ERR_free_strings();
	EVP_cleanup();
#endif
	WSACleanup();
}

CGL_net_addrinfo* CGL_net_addrinfo_query(const char* name, const char* port, size_t* count)
{
	struct addrinfo* result = NULL;
	struct addrinfo* ptr = NULL;
	struct addrinfo hints;
	ZeroMemory(&hints, sizeof(hints));
	hints.ai_family = AF_INET; // supports both ipv4
	hints.ai_socktype = SOCK_STREAM; // supports only streaming socketss
	hints.ai_protocol = IPPROTO_TCP; // supports only TCP
	CGL_int iresult = getaddrinfo(name, port, &hints, &result);
	if (iresult != 0) return NULL;
	size_t addr_count = 0;
	for (ptr = result; ptr != NULL; ptr = ptr->ai_next) addr_count++;
	if (count) *count = addr_count;
	CGL_net_addrinfo* infos = (CGL_net_addrinfo*)CGL_malloc(sizeof(CGL_net_addrinfo) * addr_count);
	if (!infos) { freeaddrinfo(result); return NULL; }
	size_t index = 0;
	for (ptr = result; ptr != NULL; ptr = ptr->ai_next, index++)
	{
		infos[index].ai_flags = ptr->ai_flags;
		infos[index].ai_family = ptr->ai_family;
		infos[index].ai_socktype = ptr->ai_socktype;
		infos[index].ai_protocol = ptr->ai_protocol;
		infos[index].ai_addrlen = ptr->ai_addrlen;
		infos[index].ai_addr = *ptr->ai_addr;
	}
	freeaddrinfo(result);
	return infos;
}

CGL_void CGL_net_addrinfo_destroy(CGL_net_addrinfo* infos)
{
	CGL_free(infos);
}

CGL_net_socket* CGL_net_socket_create()
{
	CGL_net_socket* soc = (CGL_net_socket*)CGL_malloc(sizeof(CGL_net_socket));
	if (!soc) return NULL;
	soc->socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (soc->socket == INVALID_SOCKET)
	{
		CGL_free(soc);
		return NULL;
	}
	return soc;
}

bool CGL_net_socket_connect(CGL_net_socket* soc, CGL_net_addrinfo* target)
{
	CGL_int result = connect(soc->socket, &target->ai_addr, (int)target->ai_addrlen);
	return result != SOCKET_ERROR;
}

bool CGL_net_socket_bind(CGL_net_socket* soc, CGL_net_addrinfo* target)
{
	CGL_int result = bind(soc->socket, &target->ai_addr, (int)target->ai_addrlen);
	return result != SOCKET_ERROR;
}

bool CGL_net_socket_listen(CGL_net_socket* soc, size_t max_connections)
{
	CGL_int result = listen(soc->socket, (int_fast16_t)max_connections);
	return result != SOCKET_ERROR;
}

CGL_net_socket* CGL_net_socket_accept(CGL_net_socket* soc, CGL_net_addrinfo* addrinfo)
{
	CGL_net_socket* cli_soc = (CGL_net_socket*)CGL_malloc(sizeof(CGL_net_socket));
	if (!cli_soc) return NULL;
	CGL_int addr_len = 0;
	if (addrinfo)
	{
		cli_soc->socket = accept(soc->socket, &addrinfo->ai_addr, &addr_len);
		addrinfo->ai_addrlen = addr_len;
	}
	else cli_soc->socket = accept(soc->socket, NULL, NULL);
	if (cli_soc->socket == INVALID_SOCKET)
	{
		CGL_free(cli_soc);
		cli_soc = NULL;
	}
	return cli_soc;
}

CGL_void CGL_net_socket_close(CGL_net_socket* soc)
{
	closesocket(soc->socket);
	CGL_free(soc);
}

bool CGL_net_socket_send(CGL_net_socket* soc, void* buffer, size_t size, size_t* size_sent)
{
	CGL_int result = send(soc->socket, (const CGL_byte*)buffer, (int)size, 0);
	if (size_sent) *size_sent = result;
	return result != SOCKET_ERROR;
}

bool CGL_net_socket_recv(CGL_net_socket* soc, void* buffer, size_t size, size_t* size_recieved)
{
	CGL_int result = recv(soc->socket, (CGL_byte*)buffer, (int)size, 0);
	if (result > 0 && size_recieved) *size_recieved = (size_t)result;
	return result > 0;
}

bool CGL_net_socket_shutdown_send(CGL_net_socket* soc)
{
	return shutdown(soc->socket, SD_SEND) == SOCKET_ERROR;
}

bool CGL_net_socket_shutdown_recv(CGL_net_socket* soc)
{
	return shutdown(soc->socket, SD_RECEIVE) == SOCKET_ERROR;
}

#else // for unix based operating systems


#include <netdb.h> 
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <error.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

struct CGL_net_addrinfo
{
	struct sockaddr_in ai_addr;
};

struct CGL_net_socket
{
	CGL_int socket;
};

bool CGL_net_init()
{
#ifndef CGL_EXCLUDE_SSL_SOCKET
	SSL_library_init();
	SSLeay_add_ssl_algorithms();
	SSL_load_error_strings();
#endif
	return true;
}

CGL_void CGL_net_shutdown()
{
#ifndef CGL_EXCLUDE_SSL_SOCKET
	ERR_free_strings();
	EVP_cleanup();
#endif
}

CGL_net_addrinfo* CGL_net_addrinfo_query(const char* name, const char* port, size_t* count)
{
	struct hostent* server = NULL;
	server = gethostbyname(name);
	if (server == NULL) return NULL;
	CGL_net_addrinfo* addr_info = (CGL_net_addrinfo*)CGL_malloc(sizeof(CGL_net_addrinfo));
	if (!addr_info) return NULL;
	memset(&addr_info->ai_addr, 0, sizeof(addr_info->ai_addr));
	addr_info->ai_addr.sin_family = AF_UNSPEC;
	CGL_int iport = atoi(port);
	addr_info->ai_addr.sin_port = htons(iport);
	addr_info->ai_addr.sin_addr = *((struct in_addr*)server->h_addr_list[0]);
	if (count) *count = 1;
	return addr_info;
}

CGL_void CGL_net_addrinfo_destroy(CGL_net_addrinfo* infos)
{
	CGL_free(infos);
}

CGL_net_socket* CGL_net_socket_create()
{
	CGL_net_socket* soc = (CGL_net_socket*)CGL_malloc(sizeof(CGL_net_socket));
	if (!soc) return NULL;
	soc->socket = socket(AF_INET, SOCK_STREAM, 0);
	if (soc->socket < 0)
	{
		CGL_free(soc);
		return NULL;
	}
	return soc;
}

bool CGL_net_socket_connect(CGL_net_socket* soc, CGL_net_addrinfo* target)
{
	CGL_int result = connect(soc->socket, (struct sockaddr*)&target->ai_addr, sizeof(target->ai_addr));
	return result >= 0;
}

bool CGL_net_socket_bind(CGL_net_socket* soc, CGL_net_addrinfo* target)
{
	CGL_int result = bind(soc->socket, (struct sockaddr*)&target->ai_addr, sizeof(target->ai_addr));
	return result > 0;
}

bool CGL_net_socket_listen(CGL_net_socket* soc, size_t max_connections)
{
	listen(soc->socket, (int)max_connections);
	return true;
}

CGL_net_socket* CGL_net_socket_accept(CGL_net_socket* soc, CGL_net_addrinfo* addrinfo)
{
	CGL_net_socket* cli_soc = (CGL_net_socket*)CGL_malloc(sizeof(CGL_net_socket));
	if (!cli_soc) return NULL;
	CGL_int length = 0;
	if (addrinfo) cli_soc->socket = accept(soc->socket, (struct sockaddr*)&addrinfo->ai_addr, &length);
	else cli_soc->socket = accept(soc->socket, NULL, NULL);
	if (cli_soc->socket < 0)
	{
		CGL_free(cli_soc);
		return NULL;
	}
	return cli_soc;
}

CGL_void CGL_net_socket_close(CGL_net_socket* soc)
{
	close(soc->socket);
}

bool CGL_net_socket_send(CGL_net_socket* soc, void* buffer, size_t size, size_t* size_sent)
{
	CGL_int result = send(soc->socket, buffer, size, 0);
	if (result < 0) return false;
	if (size_sent) *size_sent = result;
	return result;
}

bool CGL_net_socket_recv(CGL_net_socket* soc, void* buffer, size_t size, size_t* size_recieved)
{
	CGL_int result = recv(soc->socket, buffer, size, 0);
	if (result < 0) return false;
	if (size_recieved) *size_recieved = result;
	return result;
}

bool CGL_net_socket_shutdown_send(CGL_net_socket* soc)
{
	shutdown(soc->socket, SHUT_WR);
}

bool CGL_net_socket_shutdown_recv(CGL_net_socket* soc)
{
	shutdown(soc->socket, SHUT_RD);
}



#endif // _WIN32

CGL_void __CGL_net_http_prepare_request(char* buffer, const char* method, const char* host, const char* path, const char* accept, const char* user_agent, const char* body)
{
	const char* path_ = path == NULL ? "/" : path;
	const char* accept_ = accept == NULL ? "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9" : accept;
	const char* user_agent_ = user_agent == NULL ? "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36" : user_agent;
	const char* body_ = body == NULL ? "" : body;
	const char* method_ = method == NULL ? "GET" : method;
	sprintf(buffer,
		"%s %s HTTP/1.1\r\n"
		"Accept: %s\r\n"
		"Accept-Language: en-US,en;q=0.9,hi;q=0.8,zh-CN;q=0.7,zh;q=0.6\r\n"
		"Host: %s\r\n"
		"User-Agent: %s\r\n"
		"\r\n"
		"%s",
		method_, path_, accept_, host, user_agent_, body_);
}

int __CGL_net_http_parse_response(const char* response, const size_t recieved_length, size_t* body_size, char* body)
{
	CGL_int response_code = atoi(response + 9);
	const char* start_pt = response + 2;
	while (*start_pt != '\0')
	{
		start_pt++;
		if (*start_pt == '\n' && *(start_pt - 1) == '\r' && *(start_pt - 2) == '\n' && *(start_pt - 3) == '\r') break;
	}
	start_pt++;
	size_t body_size_l = (recieved_length - (size_t)(start_pt - response));
	if (body_size) *body_size = body_size_l;;
	if (body)  memcpy(body, start_pt, body_size_l);
	return response_code;
}

int CGL_net_http_request(const char* method, const char* host, const char* path, void* buffer, size_t* size, const char* accept, const char* user_agent, const char* body)
{
	CGL_net_addrinfo* infos = CGL_net_addrinfo_query(host, "80", NULL);
	CGL_net_socket* sock = CGL_net_socket_create();
	if (!CGL_net_socket_connect(sock, infos))
	{
		CGL_net_socket_close(sock);
		CGL_net_addrinfo_destroy(infos);
		return 0;
	}
	static char temp_buffer[1024 * 1024 * 4]; // 4 MB static buffer
	__CGL_net_http_prepare_request(temp_buffer, method, host, path, accept, user_agent, body);
	if (!CGL_net_socket_send(sock, temp_buffer, strlen(temp_buffer), NULL))
	{
		CGL_net_socket_close(sock);
		CGL_net_addrinfo_destroy(infos);
		return 0;
	}
	memset(temp_buffer, 0, sizeof(temp_buffer));
	size_t recieved_length = 0;
	if (!CGL_net_socket_recv(sock, temp_buffer, sizeof(temp_buffer), &recieved_length))
	{
		CGL_net_socket_close(sock);
		CGL_net_addrinfo_destroy(infos);
		return 0;
	}
	CGL_net_socket_close(sock);
	CGL_net_addrinfo_destroy(infos);
	return __CGL_net_http_parse_response(temp_buffer, recieved_length, size, (CGL_byte*)buffer);
}

int CGL_net_http_get(const char* host, const char* path, void* buffer, size_t* size, const char* accept, const char* user_agent)
{
	return CGL_net_http_request("GET", host, path, buffer, size, accept, user_agent, NULL);
}

int CGL_net_http_post(const char* host, const char* path, void* buffer, size_t* size, const char* accept, const char* user_agent, const char* body)
{
	return CGL_net_http_request("POST", host, path, buffer, size, accept, user_agent, body);
}

#ifndef CGL_EXCLUDE_SSL_SOCKET

int CGL_net_https_request(const char* method, const char* host, const char* path, void* response_buffer, size_t* size, const char* accept, const char* user_agent, const char* body)
{
	CGL_log_internal("TO BE IMPLEMENTED!\n");
	return 0;
}

int CGL_net_https_get(const char* host, const char* path, void* buffer, size_t* size, const char* accept, const char* user_agent)
{
	return CGL_net_https_request("GET", host, path, buffer, size, accept, user_agent, NULL);
}

int CGL_net_https_post(const char* host, const char* path, void* buffer, size_t* size, const char* accept, const char* user_agent, const char* body)
{
	return CGL_net_https_request("POST", host, path, buffer, size, accept, user_agent, body);
}

struct CGL_net_ssl_socket
{
	CGL_net_socket* raw_socket;
	SSL* ssl;
	SSL_CTX* ctx;
	const SSL_METHOD* meth;
	CGL_int sock;
};

CGL_net_ssl_socket* CGL_net_ssl_socket_create(CGL_net_socket* soc)
{
	if (!soc) return NULL;
	CGL_net_ssl_socket* sock = (CGL_net_ssl_socket*)CGL_malloc(sizeof(CGL_net_ssl_socket));
	if (!sock) return NULL;
	sock->raw_socket = soc;
	sock->meth = TLSv1_2_client_method();
	sock->ctx = SSL_CTX_new(sock->meth);
	sock->ssl = SSL_new(sock->ctx);
	if (!sock->ssl)
	{
		CGL_log_internal("Error in creating SSL\n");
		CGL_free(sock);
		return NULL;
	}
	sock->sock = SSL_get_fd(sock->ssl);
	SSL_set_fd(sock->ssl, soc->socket);
	CGL_int err = SSL_connect(sock->ssl);
	if (err <= 0)
	{
		CGL_log_internal("Error in creating SSL connection (%d)\n", err);
		CGL_free(sock);
		return NULL;
	}
	CGL_log_internal("SSL connection established using %s\n", SSL_get_cipher(sock->ssl));
	return sock;
}

bool CGL_net_ssl_socket_send(CGL_net_ssl_socket* soc, void* buffer, size_t size, size_t* size_sent)
{
	CGL_int result = SSL_write(soc->ssl, buffer, (int)size);
	if (result < 0) return false;
	if (size_sent) *size_sent = result;
	return true;
}

bool CGL_net_ssl_socket_recv(CGL_net_ssl_socket* soc, void* buffer, size_t size, size_t* size_recieved)
{
	CGL_int result = SSL_read(soc->ssl, buffer, (int)size);
	if (result < 0) return false;
	if (size_recieved) *size_recieved = result;
	return true;
}

CGL_void CGL_net_ssl_socket_destroy(CGL_net_ssl_socket* soc)
{
	SSL_free(soc->ssl);
	SSL_CTX_free(soc->ctx);
	CGL_net_socket_close(soc->raw_socket);
	CGL_free(soc);
}

CGL_void CGL_net_ssl_log_errors()
{
	CGL_int err = 0;
	while (err = ERR_get_error())
	{
		char* str = ERR_error_string(err, 0);
		if (!str) return;
		printf("%s\n", str);
		fflush(stdout);
	}
}

#endif // CGL_EXCLUDE_SSL_SOCKET

#pragma warning(pop)


#endif //  CGL_EXCLUDE_NETWORKING

#endif

#ifndef CGL_DISABLE_LOGGER


struct CGL_logger_context
{
	char log_file_paths[CGL_LOGGER_MAX_LOG_FILES][4096];
	char log_buffer[CGL_LOGGER_LOG_BUFFER_SIZE];
	CGL_int log_buffer_length;
	bool console_logging_enabled;
	bool flush_on_log;
};

static CGL_logger_context* __CGL_CURRENT_LOGGER_CONTEXT = NULL;

CGL_void CGL_logger_init(bool enable_console_logging)
{
	__CGL_CURRENT_LOGGER_CONTEXT = (CGL_logger_context*)CGL_malloc(sizeof(CGL_logger_context));
	__CGL_CURRENT_LOGGER_CONTEXT->log_buffer_length = 0;
	__CGL_CURRENT_LOGGER_CONTEXT->flush_on_log = false;
	__CGL_CURRENT_LOGGER_CONTEXT->console_logging_enabled = enable_console_logging;
	memset(__CGL_CURRENT_LOGGER_CONTEXT->log_buffer, 0, sizeof(char) * CGL_LOGGER_LOG_BUFFER_SIZE);
	for (CGL_int i = 0; i < CGL_LOGGER_MAX_LOG_FILES; i++) __CGL_CURRENT_LOGGER_CONTEXT->log_file_paths[i][0] = '\0';
	CGL_log_internal("Started Logger Session");
}

CGL_void CGL_logger_shutdown()
{
	CGL_log_internal("Ending Logger Session");
	CGL_logger_flush();
	CGL_free(__CGL_CURRENT_LOGGER_CONTEXT);
}

CGL_logger_context* CGL_logger_get_context()
{
	return __CGL_CURRENT_LOGGER_CONTEXT;
}

CGL_void CGL_logger_set_context(CGL_logger_context* context)
{
	__CGL_CURRENT_LOGGER_CONTEXT = context;
}

bool CGL_logger_attach_log_file(const char* path)
{
	for (CGL_int i = 0; i < CGL_LOGGER_MAX_LOG_FILES; i++) if (__CGL_CURRENT_LOGGER_CONTEXT->log_file_paths[i][0] == '\0')
	{
		strcpy(__CGL_CURRENT_LOGGER_CONTEXT->log_file_paths[i], path);
		CGL_log_internal("Attached Log File : %s", path);
		return true;
	}
	return false;
}

bool CGL_logger_detach_log_file(const char* path)
{
	for (CGL_int i = 0; i < CGL_LOGGER_MAX_LOG_FILES; i++) if (strcmp(__CGL_CURRENT_LOGGER_CONTEXT->log_file_paths[i], path) == 0)
	{
		__CGL_CURRENT_LOGGER_CONTEXT->log_file_paths[i][0] = '\0';
		CGL_log_internal("Detached Log File : %s", path);
		return true;
	}
	return false;
}

CGL_void CGL_logger_flush()
{
	for (CGL_int i = 0; i < CGL_LOGGER_MAX_LOG_FILES; i++)
		if (__CGL_CURRENT_LOGGER_CONTEXT->log_file_paths[i][0] != '\0')
			CGL_utils_append_file(__CGL_CURRENT_LOGGER_CONTEXT->log_file_paths[i], __CGL_CURRENT_LOGGER_CONTEXT->log_buffer, __CGL_CURRENT_LOGGER_CONTEXT->log_buffer_length);
	__CGL_CURRENT_LOGGER_CONTEXT->log_buffer_length = 0;
	__CGL_CURRENT_LOGGER_CONTEXT->log_buffer[0] = '\0';
	if (!__CGL_CURRENT_LOGGER_CONTEXT->flush_on_log) { CGL_log_internal("Flushed Log Buffer"); }
}

CGL_void CGL_logger_disable_console_logging()
{
	__CGL_CURRENT_LOGGER_CONTEXT->console_logging_enabled = false;
}

CGL_void CGL_logger_enable_console_logging()
{
	__CGL_CURRENT_LOGGER_CONTEXT->console_logging_enabled = true;
}

CGL_void CGL_logger_log(CGL_int level, const char* log_format, ...)
{
	static char buffer1[1024 * 16];
	static char buffer2[256];
	static char buffer3[1024 * 20];
	static const char* LOG_LEVEL_STR[] = {
		"TRACE",
		"INFO",
		"WARN",
		"ERROR",
		"INTERNAL"
	};
	buffer1[0] = buffer2[0] = buffer3[0] = '\0';
	va_list args;
	va_start(args, log_format);
	vsprintf(buffer1, log_format, args);
	va_end(args);
	CGL_utils_get_timestamp(buffer2);
	sprintf(buffer3, "[%s] [%s] : %s\n", LOG_LEVEL_STR[level], buffer2, buffer1);
	CGL_int log_length = (int)strlen(buffer3);
	if (log_length + __CGL_CURRENT_LOGGER_CONTEXT->log_buffer_length >= CGL_LOGGER_LOG_BUFFER_SIZE) CGL_logger_flush();
	strcat(__CGL_CURRENT_LOGGER_CONTEXT->log_buffer, buffer3);
	__CGL_CURRENT_LOGGER_CONTEXT->log_buffer_length += log_length;
	switch (level)
	{
	case CGL_LOG_LEVEL_TRACE: printf("%s", buffer3); break;
	case CGL_LOG_LEVEL_INFO: CGL_printf_green(buffer3); break;
	case CGL_LOG_LEVEL_WARN: CGL_printf_gray(buffer3); break;
	case CGL_LOG_LEVEL_ERROR: CGL_printf_red(buffer3); break;
	case CGL_LOG_LEVEL_INTERNAL: CGL_printf_blue(buffer3); break;
	}
	if (__CGL_CURRENT_LOGGER_CONTEXT->flush_on_log) CGL_logger_flush();
}

#endif

// utils
#if 1


CGL_void CGL_console_set_color(uint8_t color)
{
#ifdef CGL_WINDOWS
	static WORD saved_attributes;
	HANDLE console = GetStdHandle(STD_OUTPUT_HANDLE);
	if (color == CGL_CONSOLE_COLOR_RESET) SetConsoleTextAttribute(console, saved_attributes);
	CONSOLE_SCREEN_BUFFER_INFO console_info;
	GetConsoleScreenBufferInfo(console, &console_info);
	saved_attributes = console_info.wAttributes;
	switch (color)
	{
	case 1:  SetConsoleTextAttribute(console, FOREGROUND_RED); break;
	case 2:  SetConsoleTextAttribute(console, FOREGROUND_GREEN); break;
	case 3:  SetConsoleTextAttribute(console, FOREGROUND_INTENSITY); break;
	case 4:  SetConsoleTextAttribute(console, FOREGROUND_BLUE); break;
	default: break;
	}
#else
	if (color == CGL_CONSOLE_COLOR_RESET) printf("\x1B[0m");
	else
	{
		switch (color)
		{
		case 1:  printf("\x1B[31m"); break;
		case 2:  printf("\x1B[32m"); break;
		case 3:  printf("\x1B[33m"); break;
		case 4:  printf("\x1B[34m"); break;
		default: break;
		}
	}
#endif   
}

CGL_void CGL_printf_red(const char* format, ...)
{
	CGL_console_set_color(CGL_CONSOLE_COLOR_RED);
	va_list args;
	va_start(args, format);
	vprintf(format, args);
	va_end(args);
	CGL_console_set_color(CGL_CONSOLE_COLOR_RESET);
}

CGL_void CGL_printf_green(const char* format, ...)
{
	CGL_console_set_color(CGL_CONSOLE_COLOR_GREEN);
	va_list args;
	va_start(args, format);
	vprintf(format, args);
	va_end(args);
	CGL_console_set_color(CGL_CONSOLE_COLOR_RESET);
}

CGL_void CGL_printf_gray(const char* format, ...)
{
	CGL_console_set_color(CGL_CONSOLE_COLOR_GRAY);
	va_list args;
	va_start(args, format);
	vprintf(format, args);
	va_end(args);
	CGL_console_set_color(CGL_CONSOLE_COLOR_RESET);
}

CGL_void CGL_printf_blue(const char* format, ...)
{
	CGL_console_set_color(CGL_CONSOLE_COLOR_BLUE);
	va_list args;
	va_start(args, format);
	vprintf(format, args);
	va_end(args);
	CGL_console_set_color(CGL_CONSOLE_COLOR_RESET);
}

CGL_void CGL_console_progress_bar(CGL_float progress, CGL_int width, CGL_byte* prefix, CGL_byte* suffix, CGL_byte complete_char, CGL_byte incomplete_char)
{
	static CGL_byte buffer[1024], buffer2[1024]; // 1024 is enough for a progress bar
	if (prefix) sprintf(buffer2, "%s", prefix); else buffer2[0] = 0; // prefix
	sprintf(buffer, "%c%d%%%c", 32, (CGL_int)(100 * progress), 32); // fill buffer wwith the progress percentage
	CGL_int pos = (CGL_int)strlen(buffer2), i, buffer_length = (CGL_int)strlen(buffer);
	for (i = 0; i < width; i++)
	{
		if (i < (CGL_int)(progress * width)) buffer2[pos + i] = complete_char; // add the progress bar
		else buffer2[pos + i] = incomplete_char; // add the progress bar
		// add contents of buffer2 at the middle of the progress bar
		if (i == (width - buffer_length) / 2 && i + buffer_length <= width) { for (CGL_int j = 0; j < buffer_length; j++) buffer2[pos + i + j] = buffer[j]; i += buffer_length - 1; }
	}
	buffer2[pos + i] = 0; // end of string
	if (suffix) strcat(buffer2, suffix); // suffix
	printf("%s\r", buffer2); // print the progress bar
}

float CGL_utils_get_time()
{
#if defined(_WIN32) || defined(_WIN64)
	static LARGE_INTEGER starting_time;
	LARGE_INTEGER frequency, time;
	if (starting_time.QuadPart == 0) QueryPerformanceCounter(&starting_time);
	QueryPerformanceFrequency(&frequency);
	QueryPerformanceCounter(&time);
	CGL_float ftime = (CGL_float)(time.QuadPart - starting_time.QuadPart) / (CGL_float)frequency.QuadPart;
	return ftime;
#elif defined(CGL_WASM)
	return (float)emscripten_get_now() / 1000.0f;
#else  // for POSIX
	struct timespec spec;
	if (clock_gettime(1, &spec) == -1)
	{
		/* 1 is CLOCK_MONOTONIC */
		return 0.0f;
	}
	return (float)(spec.tv_sec * 1000 + spec.tv_nsec / 1e6) / 1000.0f;
#endif
}

CGL_float CGL_utils_sigmoid(CGL_float x)
{
	return 1.0f / (1.0f + expf(-x));
}


CGL_float CGL_utils_sigmoid_derivative(CGL_float x)
{
	return x * (1.0f - x);
}

CGL_float CGL_utils_relu(CGL_float x)
{
	return x > 0.0f ? x : 0.0f;
}

CGL_float CGL_utils_relu_derivative(CGL_float x)
{
	return x > 0.0f ? 1.0f : 0.0f;
}

CGL_float CGL_utils_tanh(CGL_float x)
{
	return tanhf(x);
}

CGL_float CGL_utils_tanh_derivative(CGL_float x)
{
	return 1.0f - x * x;
}

CGL_float CGL_utils_step(CGL_float x)
{
	return x > 0.0f ? 1.0f : 0.0f;
}

CGL_float CGL_utils_step_derivative(CGL_float x)
{
	(void)x;
	return 0.0f;
}

CGL_float CGL_utils_relu_leaky(CGL_float x)
{
	return x > 0.0f ? x : 0.01f * x;
}

CGL_float CGL_utils_relu_leaky_derivative(CGL_float x)
{
	return x > 0.0f ? 1.0f : 0.01f;
}

CGL_float CGL_utils_relu_smooth(CGL_float x)
{
	return x > 0.0f ? x : 0.01f * x * x;
}

CGL_float CGL_utils_relu_smooth_derivative(CGL_float x)
{
	return x > 0.0f ? 1.0f : 0.02f * x;
}

CGL_vec3 CGL_utils_hsl_to_rgb(CGL_vec3 hsv)
{
	(void)hsv;
	CGL_log_internal("Not implemented yet");
	return CGL_vec3_init(0.0f, 0.0f, 0.0f);
}

CGL_sizei CGL_utils_get_random_with_probability(CGL_float* probabilities, CGL_sizei count)
{
	static CGL_float prefix[CGL_RAND_GEN_WITH_PROBABILITY_MAX_COUNT];
	prefix[0] = probabilities[0];
	for (CGL_sizei i = 1; i < count; i++) prefix[i] = prefix[i - 1] + probabilities[i];
	CGL_float r = CGL_utils_random_float() * prefix[count - 1];
	for (CGL_sizei i = 0; i < count; i++) if (r < prefix[i]) return i;
	return count - 1;
}

CGL_void CGL_utils_get_timestamp(char* buffer)
{
	time_t ltime = time(NULL);
	sprintf(buffer, "%s", asctime(localtime(&ltime)));
	buffer[strlen(buffer) - 2] = '\0';
}

// From : https://stackoverflow.com/a/12792056/14911094
CGL_bool CGL_utils_is_little_endian()
{
	CGL_int i = 0x01234567;
	return (*((CGL_ubyte*)(&i))) == 0x67;
}

CGL_void CGL_utils_reverse_bytes(void* vdata, size_t size)
{
	CGL_byte* data = (CGL_byte*)vdata;
	for (size_t i = 0; i < size / 2; i++)
	{
		CGL_byte temp = data[i];
		data[i] = data[size - i - 1];
		data[size - i - 1] = temp;
	}
}

CGL_void CGL_utils_little_endian_to_current(void* data, size_t size)
{
	if (CGL_utils_is_little_endian()) return;
	CGL_utils_reverse_bytes(data, size);
}

CGL_void CGL_utils_big_endian_to_current(void* data, size_t size)
{
	if (!CGL_utils_is_little_endian()) return;
	CGL_utils_reverse_bytes(data, size);
}

// From: https://stackoverflow.com/a/3747462/14911094
static CGL_int __CGL_UTILS_FAST_RAND_SEED = 42;

CGL_void CGL_utils_fast_srand(CGL_int seed)
{
	__CGL_UTILS_FAST_RAND_SEED = seed;
}

CGL_int CGL_utils_fast_rand()
{
	__CGL_UTILS_FAST_RAND_SEED = (214013 * __CGL_UTILS_FAST_RAND_SEED + 2531011);
	return ((__CGL_UTILS_FAST_RAND_SEED >> 16) & 0x7FFF);
}

// From: https://stackoverflow.com/a/1640399/14911094
CGL_ulong CGL_utils_xorshf96()
{
	static CGL_ulong x = 123456789, y = 362436069, z = 521288629, t;
	x ^= x << 16; x ^= x >> 5; x ^= x << 1;
	t = x; x = y; y = z;
	z = t ^ x ^ y;
	return z;
}

static CGL_uint __CGL_UTILS_RAND31_SEED = 42;

CGL_void CGL_utils_srand31(CGL_uint seed)
{
	__CGL_UTILS_RAND31_SEED = seed;
}

// From https://www.firstpr.com.au/dsp/rand31/
/*
Park-Miller "minimal standard" 31 bit
pseudo-random number generator, implemented
with David G. Carta's optimization : with
32 bit math and without division
*/
CGL_uint CGL_utils_rand31()
{
	CGL_uint hi, lo;
	lo = 16807 * (__CGL_UTILS_RAND31_SEED & 0xFFFF);
	hi = 16807 * (__CGL_UTILS_RAND31_SEED >> 16);
	lo += (hi & 0x7FFF) << 16;
	lo += hi >> 15;
	if (lo > 0x7FFFFFFF) lo -= 0x7FFFFFFF;
	return (__CGL_UTILS_RAND31_SEED = lo);
}

static CGL_byte __CGL_UTILS_QUICK_SORT_SWAP_BUFFER[CGL_QUICK_SORT_SWAP_BUFFER_SIZE];

#define __CGL_QUICK_SORT_SWAP_DATA(a, b) \
{  \
    memcpy(__CGL_UTILS_QUICK_SORT_SWAP_BUFFER, a, item_size); \
    memcpy(a, b, item_size); \
    memcpy(b, __CGL_UTILS_QUICK_SORT_SWAP_BUFFER, item_size); \
}

#define __CGL_QUICK_SORT_SWAP(a, b) \
{  \
    CGL_void* temp = a; \
    a = b; \
    b = temp; \
}

static CGL_void __CGL_utils_quick_sort(CGL_void* begin_ptr, CGL_void* end_ptr, CGL_sizei item_size, CGL_int(*comparator)(const CGL_void*, const CGL_void*))
{
	CGL_byte* pivot = (CGL_byte*)end_ptr - item_size;
	CGL_byte* left_ptr = (CGL_byte*)begin_ptr - item_size;
	CGL_byte* right_ptr = (CGL_byte*)end_ptr - item_size;
	while (left_ptr < right_ptr)
	{
		while (left_ptr < pivot && comparator(left_ptr = (left_ptr + item_size), pivot) < 0);
		while (right_ptr > left_ptr && comparator(right_ptr = (right_ptr - item_size), pivot) > 0);
		if (left_ptr < right_ptr) __CGL_QUICK_SORT_SWAP_DATA(left_ptr, right_ptr) // swap elements to arrange them
		else __CGL_QUICK_SORT_SWAP_DATA(left_ptr, pivot) // swap pivot to the middle
	}
	if ((CGL_sizei)(left_ptr - (CGL_byte*)begin_ptr) > item_size) __CGL_utils_quick_sort(begin_ptr, left_ptr, item_size, comparator);
	if ((CGL_sizei)((CGL_byte*)end_ptr - left_ptr) > item_size) __CGL_utils_quick_sort(left_ptr + item_size, end_ptr, item_size, comparator);
}

CGL_bool CGL_utils_quick_sort(CGL_void* array, CGL_sizei item_count, CGL_sizei item_size, CGL_int(*comparator)(const CGL_void*, const CGL_void*))
{
	__CGL_utils_quick_sort(array, (CGL_byte*)array + item_count * item_size, item_size, comparator);
	return true;
}

CGL_void CGL_shape_init(CGL_shape* shape, size_t vertices_count)
{
	shape->vertices_count = vertices_count;
	shape->vertices = (CGL_vec3*)CGL_malloc(sizeof(CGL_vec3) * vertices_count);
	shape->position = CGL_vec3_init(0.0f, 0.0f, 0.0f);
	shape->rotation = CGL_vec3_init(0.0f, 0.0f, 0.0f);
	shape->scale = CGL_vec3_init(1.0f, 1.0f, 1.0f);
	if (shape->vertices == NULL) return;
}

CGL_void CGL_shape_destroy(CGL_shape* shape)
{
	CGL_free(shape->vertices);
}


CGL_transform CGL_transform_create_empty()
{
	CGL_transform transform = { 0 };
	transform.position = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	transform.rotation = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	transform.scale = CGL_vec4_init(1.0f, 1.0f, 1.0f, 1.0f);
	transform.matrix = CGL_mat4_identity();
	transform.parent = NULL;
	return transform;
}

CGL_transform CGL_transform_create(CGL_vec3 position, CGL_vec3 rotation, CGL_vec3 scale)
{
	CGL_transform transform = { 0 };
	transform.position = CGL_vec4_init(position.x, position.y, position.z, 0.0f);
	transform.rotation = CGL_vec4_init(rotation.x, rotation.y, rotation.z, 0.0f);
	transform.scale = CGL_vec4_init(scale.x, scale.y, scale.z, 1.0f);
	transform.matrix = CGL_mat4_identity();
	transform.parent = NULL;
	CGL_transform_update(&transform);
	return transform;
}

CGL_transform CGL_transform_create_from_matrix(CGL_mat4 matrix)
{
	CGL_transform transform = { 0 };
	transform.position = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	transform.rotation = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	transform.scale = CGL_vec4_init(1.0f, 1.0f, 1.0f, 1.0f);
	(void)matrix;
	// TODO: Implement
	CGL_warn("CGL_transform_create_from_matrix() is not implemented yet!");
	return transform;
}

CGL_transform* CGL_transform_set_position(CGL_transform* transform, CGL_vec3 position)
{
	transform->position = CGL_vec4_init(position.x, position.y, position.z, 0.0f);
	return transform;
}

CGL_transform* CGL_transform_set_rotation(CGL_transform* transform, CGL_vec3 rotation)
{
	transform->rotation = CGL_vec4_init(rotation.x, rotation.y, rotation.z, 0.0f);
	return transform;
}

CGL_transform* CGL_transform_set_scale(CGL_transform* transform, CGL_vec3 scale)
{
	transform->scale = CGL_vec4_init(scale.x, scale.y, scale.z, 1.0f);
	return transform;
}

CGL_transform* CGL_transform_set_parent(CGL_transform* transform, CGL_transform* parent)
{
	transform->parent = parent;
	return transform;
}

CGL_transform* CGL_transform_update(CGL_transform* transform)
{
	CGL_mat4 parent_transform = CGL_mat4_identity();
	if (transform->parent != NULL)
	{
		CGL_transform_update(transform->parent);
		parent_transform = transform->parent->matrix;
	}
	CGL_transform_update_matrix_local(transform);
	transform->matrix = CGL_mat4_mul(parent_transform, transform->matrix);
	return transform;
}

CGL_transform* CGL_transform_update_matrix_local(CGL_transform* transform)
{
	CGL_mat4 translation = CGL_mat4_translate(transform->position.x, transform->position.y, transform->position.z);
	//CGL_mat4 rotation = CGL_mat4_rotation(transform->rotation.x, transform->rotation.y, transform->rotation.z);
	CGL_mat4 rotation_x = CGL_mat4_rotate_x(transform->rotation.x);
	CGL_mat4 rotation_y = CGL_mat4_rotate_y(transform->rotation.y);
	CGL_mat4 rotation_z = CGL_mat4_rotate_z(transform->rotation.z);
	CGL_mat4 rotation = CGL_mat4_mul(rotation_x, rotation_y); rotation = CGL_mat4_mul(rotation, rotation_z);
	CGL_mat4 scale = CGL_mat4_scale(transform->scale.x, transform->scale.y, transform->scale.z);
	transform->matrix = CGL_mat4_mul(translation, rotation);
	transform->matrix = CGL_mat4_mul(transform->matrix, scale);
	return transform;
}

CGL_mat4 CGL_transform_get_matrix(CGL_transform* transform)
{
	return transform->matrix;
}

CGL_mat4* CGL_transform_get_matrix_ptr(CGL_transform* transform)
{
	return &transform->matrix;
}

bool CGL_sat_collision_overlap_on_axis(CGL_shape* a, CGL_shape* b, CGL_vec2 axis, float* overlap_amount)
{
	CGL_float a_max = -FLT_MAX;
	CGL_float a_min = FLT_MAX;

	CGL_float b_max = -FLT_MAX;
	CGL_float b_min = FLT_MAX;

	CGL_vec2_normalize(axis);

	const CGL_vec2 a_translation = CGL_vec2_init(a->position.x, a->position.y);
	const CGL_vec2 a_scale = CGL_vec2_init(a->scale.x, a->scale.y);
	const CGL_float a_rotation = a->rotation.x;

	const CGL_vec2 b_translation = CGL_vec2_init(b->position.x, b->position.y);
	const CGL_vec2 b_scale = CGL_vec2_init(b->scale.x, b->scale.y);
	const CGL_float b_rotation = b->rotation.x;


	for (size_t i = 0; i < a->vertices_count; i++)
	{
		CGL_vec2 vertex = CGL_vec2_init(a->vertices[i].x, a->vertices[i].y);
		vertex = CGL_vec2_apply_transformations(vertex, &a_translation, &a_rotation, &a_scale);
		CGL_float projection = CGL_vec2_dot(vertex, axis);
		a_max = CGL_utils_max(a_max, projection);
		a_min = CGL_utils_min(a_min, projection);
	}

	for (size_t i = 0; i < b->vertices_count; i++)
	{
		CGL_vec2 vertex = CGL_vec2_init(b->vertices[i].x, b->vertices[i].y);
		vertex = CGL_vec2_apply_transformations(vertex, &b_translation, &b_rotation, &b_scale);
		CGL_float projection = CGL_vec2_dot(vertex, axis);
		b_max = CGL_utils_max(b_max, projection);
		b_min = CGL_utils_min(b_min, projection);
	}

	if
		(
			(a_max >= b_min && a_max <= b_max) ||
			(a_min >= b_min && a_min <= b_max) ||
			(b_max >= a_min && b_max <= a_max) ||
			(b_min >= a_min && b_min <= a_max)

			)
	{
		CGL_float overlap = 0.0f;
		if (a_max > b_max && a_min < b_min) overlap = CGL_utils_min(a_max - b_min, b_max - a_min);
		else if (a_max > b_max) overlap = b_max - a_min;
		else if (a_min < b_min) overlap = a_max - b_min;
		else overlap = CGL_utils_min(a_max - b_min, b_max - a_min);
		if (overlap_amount) *overlap_amount = overlap;
		return true;
	}

	return false;
}

bool CGL_sat_collision_detect(CGL_shape* a, CGL_shape* b, CGL_vec2* n_vector)
{
	static CGL_vec2 sat_axes_a[CGL_SAT_COLLISION_MAX_COLLISIONS];
	static CGL_vec2 sat_axes_b[CGL_SAT_COLLISION_MAX_COLLISIONS];
	CGL_sat_collision_calculate_axes(a, sat_axes_a, NULL);
	CGL_sat_collision_calculate_axes(b, sat_axes_b, NULL);
	CGL_float overlap = FLT_MAX, ov = FLT_MAX;
	CGL_vec2 n = CGL_vec2_init(0.0f, 0.0f);
	for (size_t i = 0; i < a->vertices_count; i++) { if (!CGL_sat_collision_overlap_on_axis(a, b, sat_axes_a[i], &ov)) return false; if (ov < overlap) { overlap = ov; n = sat_axes_a[i]; } }
	for (size_t i = 0; i < b->vertices_count; i++) { if (!CGL_sat_collision_overlap_on_axis(a, b, sat_axes_b[i], &ov)) return false; if (ov < overlap) { overlap = ov; n = sat_axes_b[i]; } }
	//if(overlap_amount) *overlap_amount = overlap;
	n = CGL_vec2_scale(n, overlap);
	if (n_vector) *n_vector = n;
	return true;
}

CGL_void CGL_sat_collision_calculate_axes(CGL_shape* shape, CGL_vec2* axes, CGL_int* axes_count)
{
	for (size_t i = 0; i < shape->vertices_count; i++)
	{
		CGL_vec2 a = CGL_vec2_init(shape->vertices[i].x, shape->vertices[i].y);
		CGL_vec2 b = CGL_vec2_init(shape->vertices[(i + 1) % shape->vertices_count].x, shape->vertices[(i + 1) % shape->vertices_count].y);
		CGL_vec2 edge = CGL_vec2_sub(b, a);
		CGL_vec2 normal = CGL_vec2_init(edge.y, -edge.x);
		axes[i] = normal;
	}
	if (axes_count) *axes_count = (int)shape->vertices_count;
}

// algorithm from https://stackoverflow.com/a/23186198/14911094
CGL_bool CGL_utils_is_point_in_triangle(CGL_vec2 p, CGL_vec2 p0, CGL_vec2 p1, CGL_vec2 p2)
{
	CGL_float s = (p0.y * p2.x - p0.x * p2.y + (p2.y - p0.y) * p.x + (p0.x - p2.x) * p.y);
	CGL_float t = (p0.x * p1.y - p0.y * p1.x + (p0.y - p1.y) * p.x + (p1.x - p0.x) * p.y);
	if (s <= 0 || t <= 0) return false;
	CGL_float A = (-p1.y * p2.x + p0.y * (-p1.x + p2.x) + p0.x * (p1.y - p2.y) + p1.x * p2.y);
	return (s + t) < A;
}

CGL_bool CGL_utils_is_point_in_circle(CGL_vec2 p, CGL_float r)
{
	return CGL_vec2_length(p) <= r;
}

CGL_bool CGL_utils_calculate_circumcircle(CGL_vec2 a, CGL_vec2 b, CGL_vec2 c, CGL_vec2* center, CGL_float* radius)
{
	CGL_float d = 2.0f * (a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y));
	if (d == 0.0f) d = 0.0000000000001f;
	CGL_float x = ((a.x * a.x + a.y * a.y) * (b.y - c.y) + (b.x * b.x + b.y * b.y) * (c.y - a.y) + (c.x * c.x + c.y * c.y) * (a.y - b.y)) / d;
	CGL_float y = ((a.x * a.x + a.y * a.y) * (c.x - b.x) + (b.x * b.x + b.y * b.y) * (a.x - c.x) + (c.x * c.x + c.y * c.y) * (b.x - a.x)) / d;
	if (center) *center = CGL_vec2_init(x, y);
	if (radius) *radius = CGL_vec2_distance(a, CGL_vec2_init(x, y));
	return true;
}

CGL_bool CGL_utils_calculate_bounding_box(CGL_vec2* points, CGL_int points_count, CGL_vec2* a, CGL_vec2* b, CGL_vec2* c, CGL_vec2* d, CGL_float padding)
{
	if (!a || !b || !c || !d) return false;
	CGL_vec4 min_max_val = CGL_vec4_init(FLT_MAX, FLT_MAX, -FLT_MAX, -FLT_MAX);
	for (CGL_int i = 0; i < points_count; i++)
	{
		CGL_vec2 p = points[i];
		if (p.x < min_max_val.x) { min_max_val.x = p.x; }
		if (p.y < min_max_val.y) { min_max_val.y = p.y; }

		if (p.x > min_max_val.z) { min_max_val.z = p.x; }
		if (p.y > min_max_val.w) { min_max_val.w = p.y; }
	}
	min_max_val.x -= 0.1f; min_max_val.y -= 0.1f; min_max_val.z += 0.1f; min_max_val.w += 0.1f;
	*a = CGL_vec2_init(min_max_val.x - padding, min_max_val.y - padding); *b = CGL_vec2_init(min_max_val.z + padding, min_max_val.y - padding);
	*c = CGL_vec2_init(min_max_val.z + padding, min_max_val.w + padding); *d = CGL_vec2_init(min_max_val.x - padding, min_max_val.w + padding);
	return true;
}

CGL_float CGL_utils_random_gaussian(CGL_float mean, CGL_float std_dev)
{
	CGL_float u1 = (CGL_float)rand() / (CGL_float)RAND_MAX;
	CGL_float u2 = (CGL_float)rand() / (CGL_float)RAND_MAX;
	CGL_float rand_std_normal = sqrtf(-2.0f * logf(u1)) * sinf(2.0f * CGL_PI * u2);
	return mean + std_dev * rand_std_normal;
}


CGL_bool CGL_utils_calculate_bounding_square(CGL_vec2* points, CGL_int points_count, CGL_vec2* a, CGL_vec2* b, CGL_vec2* c, CGL_vec2* d, CGL_float padding)
{
	if (!a || !b || !c || !d) return false;
	CGL_vec2 pa, pb, pc, pd;
	if (!CGL_utils_calculate_bounding_box(points, points_count, &pa, &pb, &pc, &pd, padding)) return false;
	CGL_float w = CGL_vec2_distance(pa, pb); CGL_float h = CGL_vec2_distance(pa, pd);
	CGL_float max = w > h ? w : h;
	CGL_vec2 center = CGL_vec2_init((pa.x + pb.x + pc.x + pd.x) / 4.0f, (pa.y + pb.y + pc.y + pd.y) / 4.0f);
	*a = CGL_vec2_init(center.x - max / 2.0f, center.y - max / 2.0f); *b = CGL_vec2_init(center.x + max / 2.0f, center.y - max / 2.0f);
	*c = CGL_vec2_init(center.x + max / 2.0f, center.y + max / 2.0f); *d = CGL_vec2_init(center.x - max / 2.0f, center.y + max / 2.0f);
	return true;
}

/*
*              P
*              *
*             * *
*            *   *
*           *     *
*          *       *
*         *   mcd   *
*      D *###########* C
*       * #         # *
*      *  #         #  *
*     *   #         #   *
*    *    #         #    *
*   *     ###########     *
*  *************************
* Q      A           B       R
*
*
*/
CGL_bool CGL_utils_calculate_super_triangle(CGL_vec2* points, CGL_int points_count, CGL_vec2* a, CGL_vec2* b, CGL_vec2* c, CGL_float padding)
{
	if (!a || !b || !c) return false;
	CGL_vec2 pa, pb, pc, pd; CGL_float edge_size = 0.0f;
	if (!CGL_utils_calculate_bounding_square(points, points_count, &pa, &pb, &pc, &pd, padding)) return false;
	edge_size = CGL_vec2_distance(pa, pb); CGL_vec2 mcd = CGL_vec2_init((pc.x + pd.x) * 0.5f, pc.y);
	*a = CGL_vec2_init(mcd.x, mcd.y + CGL_SQRT3 * 0.5f * edge_size);
	*b = CGL_vec2_init(pa.x - edge_size * 0.5f, pa.y); *c = CGL_vec2_init(pb.x + edge_size * 0.5f, pb.y);
	return true;
}

// GJK & EPA 

CGL_vec3 CGL_gjk_shape_default_support(CGL_shape* a, CGL_vec3 d)
{
	CGL_float max_dp = -FLT_MAX, dp = 0.0f;
	CGL_vec3 support = CGL_vec3_init(0.0f, 0.0f, 0.0f);
	CGL_vec3 vertex_pos = CGL_vec3_init(0.0f, 0.0f, 0.0f);
	for (CGL_sizei i = 0; i < a->vertices_count; i++)
	{
		vertex_pos = CGL_vec3_apply_transformations(a->vertices[i], &a->position, &a->rotation, &a->scale);
		dp = CGL_vec3_dot(vertex_pos, d);
		if (dp > max_dp) { max_dp = dp; support = vertex_pos; }
	}
	return support;
}

// the default support function 
CGL_vec3 CGL_gjk_default_support(CGL_shape* a, CGL_shape* b, CGL_vec3 d)
{
	CGL_vec3 a_support = CGL_gjk_shape_default_support(a, d);
	CGL_vec3 b_support = CGL_gjk_shape_default_support(b, CGL_vec3_scale_(d, -1.0f));
	return CGL_vec3_sub(a_support, b_support);
}

// Implementation inspired from
//
// https://github.com/kroitor/gjk.c/blob/master/gjk.c
// https://observablehq.com/@esperanc/2d-gjk-and-epa-algorithms
CGL_bool CGL_gjk_check_collision_2d(CGL_shape* sa, CGL_shape* sb, CGL_vec3* simplex_out)
{
	CGL_int index = 0;
	CGL_vec3 simplex[3] = { 0 };
	CGL_vec3  a, b, c;
	CGL_vec3 dir, ao, ab, ac, ab_perp, ac_perp;

	// initial direction is from a to b
	dir = CGL_vec3_sub(sa->position, sb->position);

	// if the direction is 0 (which means a and b are at same position), set it to (1, 0, 0) (x-axis)
	if (dir.x == 0 && dir.y == 0) dir = CGL_vec3_init(1.0f, 0.0f, 0.0f);

	// get the first point of the simplex
	a = simplex[0] = CGL_gjk_default_support(sa, sb, dir);

	if (CGL_vec3_dot(a, dir) < 0) return false; // no collision

	// set the direction to the opposite of the first point (towards origin)
	dir = CGL_vec3_scale(dir, -1.0f);

	while (true)
	{
		a = simplex[++index] = CGL_gjk_default_support(sa, sb, dir);

		// origin lies beyond the support point in the direction of the origin
		// thus the minkowski difference does not contain the origin
		if (CGL_vec3_dot(a, dir) < 0) return false; // no collision

		// vector from A to origin
		ao = CGL_vec3_scale(a, -1.0f);

		if (index < 2)
		{
			b = simplex[0];
			ab = CGL_vec3_sub(b, a); // vector from A to B
			dir = CGL_vec3_triple_product(ab, ao, ab); // perpendicular to AB towards origin
			if (CGL_vec3_dot(dir, dir) == 0) dir = CGL_vec3_init(dir.y, -dir.x, 0.0f); // perpendicular to AB
			continue;
		}

		// we reach here when index == 2 (3 points in the simplex)
		b = simplex[1];
		c = simplex[0];
		// a is already the last point added to the simplex
		ab = CGL_vec3_sub(b, a);
		ac = CGL_vec3_sub(c, a);
		ac_perp = CGL_vec3_triple_product(ab, ac, ac);
		if (CGL_vec3_dot(ac_perp, ao) >= 0) dir = ac_perp;
		else
		{
			ab_perp = CGL_vec3_triple_product(ac, ab, ab);
			if (CGL_vec3_dot(ab_perp, ao) < 0)
			{
				if (simplex_out != NULL)
				{
					simplex_out[0] = simplex[0];
					simplex_out[1] = simplex[1];
					simplex_out[2] = simplex[2];
				}
				return true; // collision
			}
			simplex[0] = simplex[1]; // swap
			dir = ab_perp;
		}
		simplex[1] = simplex[2]; // swap
		index -= 1;
	}
	return false; // no collision
}

// TODO: this needs work
// From https://blog.winter.dev/2020/epa-algorithm/
CGL_vec3 CGL_gjk_epa_2d(CGL_shape* a, CGL_shape* b, CGL_vec3* simplex)
{
	CGL_int min_index = -1;
	CGL_float min_dist = FLT_MAX;
	CGL_vec3 min_normal = CGL_vec3_init(0.0f, 0.0f, 0.0f);
	static CGL_vec3 polytope[CGL_GJK_EPA_MAX_POLYTOPE_VERTICES];
	//static CGL_vec3 polytope_copy[CGL_GJK_EPA_MAX_POLYTOPE_VERTICES];
	CGL_int polytope_size = 3;
	CGL_vec3 vti, vtj, vtedge, normal, support;
	CGL_float dist = 0.0f;
	for (CGL_int i = 0; i < 3; i++) polytope[i] = simplex[i];
	while (min_dist >= FLT_MAX)
	{
		for (CGL_int i = 0; i < polytope_size; i++)
		{
			CGL_int j = (i + 1) % polytope_size;
			vti = polytope[i]; vtj = polytope[j];
			vtedge = CGL_vec3_sub(vtj, vti);
			normal = CGL_vec3_init(vtedge.y, -vtedge.x, 0.0f);
			CGL_vec3_normalize(normal);
			dist = CGL_vec3_dot(normal, vti);
			if (dist < 0) { dist *= -1; normal = CGL_vec3_scale(normal, -1.0f); }
			if (dist < min_dist) { min_dist = dist; min_normal = normal; min_index = j; }
		}
		support = CGL_gjk_default_support(a, b, min_normal);
		dist = CGL_vec3_dot(min_normal, support);
		if (polytope_size == CGL_GJK_EPA_MAX_POLYTOPE_VERTICES - 2) break; // max reached
		if (fabsf(dist - min_dist) > CGL_GJK_EPA_TOLERANCE)
		{
			min_dist = FLT_MAX;
			// CGL_int amt_len = polytope_size - min_index;
			// for (CGL_int i = polytope_size - 1; i >= min_index; i--) polytope_copy[i + 1] = polytope[i];
			polytope[min_index] = support; polytope_size += 1;
		}
	}
	min_normal = CGL_vec3_scale(min_normal, min_dist);
	return min_normal;
}

CGL_bool CGL_aabb_contains_point(CGL_vec2 aabb_min, CGL_vec2 aabb_max, CGL_vec2 point)
{
	return point.x >= aabb_min.x && point.x <= aabb_max.x && point.y >= aabb_min.y && point.y <= aabb_max.y;
}

CGL_bool CGL_aabb_intersects_aabb(CGL_vec2 aabb_min, CGL_vec2 aabb_max, CGL_vec2 aabb_min2, CGL_vec2 aabb_max2)
{
	return aabb_min.x <= aabb_max2.x && aabb_max.x >= aabb_min2.x && aabb_min.y <= aabb_max2.y && aabb_max.y >= aabb_min2.y;
}


CGL_bool CGL_aabb_subdivide_nd(CGL_int n, CGL_float* aabb_min, CGL_float* aabb_max, CGL_float* aabbs_min_out, CGL_float* aabbs_max_out)
{
	static CGL_float aabb_mid_pos[1024], aabb_axis_deltas[1024]; // I don't think we'll ever need more than 1024 dimensions
	CGL_float nth_dim_val_holder = 0.0f, * pm_a[2];
	CGL_int result_count = 1 << n, nth_dim_val_holder_index = 0;
	for (CGL_int i = 0; i < n; i++)
	{
		aabb_mid_pos[i] = (aabb_min[i] + aabb_max[i]) * 0.5f;
		aabb_axis_deltas[i] = aabb_mid_pos[i] - aabb_min[i];
	}

	for (CGL_int j = 0; j < n; j++)
	{
		pm_a[0] = &aabb_min[n - j - 1]; pm_a[1] = &aabb_mid_pos[n - j - 1];
		nth_dim_val_holder = *pm_a[nth_dim_val_holder_index = 0];
		for (CGL_int i = 0; i < result_count; i++)
		{
			aabbs_min_out[i * n + (n - j - 1)] = nth_dim_val_holder;
			if ((i - 1) % (1 << j) == 0) nth_dim_val_holder = *pm_a[nth_dim_val_holder_index = (nth_dim_val_holder_index + 1) % 2];
		}
	}

	for (CGL_int i = 0; i < result_count; i++)
	{
		for (CGL_int j = 0; j < n; j++)
		{
			aabbs_max_out[i * n + j] = aabbs_min_out[i * n + j] + aabb_axis_deltas[j];
		}
	}

	return CGL_TRUE;
}


// hard coded for 2d
CGL_bool CGL_aabb_subdivide_2d(CGL_int n, CGL_float* aabb_min, CGL_float* aabb_max, CGL_float* aabbs_min_out, CGL_float* aabbs_max_out)
{
	(void)n;
	CGL_float delta_x = (aabb_max[0] - aabb_min[0]) * 0.5f, delta_y = (aabb_max[1] - aabb_min[1]) * 0.5f;
	aabbs_min_out[0] = aabb_min[0]; aabbs_min_out[1] = aabb_min[1];
	aabbs_max_out[0] = aabb_min[0] + delta_x; aabbs_max_out[1] = aabb_min[1] + delta_y;
	aabbs_min_out[2] = aabb_min[0] + delta_x; aabbs_min_out[3] = aabb_min[1];
	aabbs_max_out[2] = aabb_max[0]; aabbs_max_out[3] = aabb_min[1] + delta_y;
	aabbs_min_out[4] = aabb_min[0]; aabbs_min_out[5] = aabb_min[1] + delta_y;
	aabbs_max_out[4] = aabb_min[0] + delta_x; aabbs_max_out[5] = aabb_max[1];
	aabbs_min_out[6] = aabb_min[0] + delta_x; aabbs_min_out[7] = aabb_min[1] + delta_y;
	aabbs_max_out[6] = aabb_max[0]; aabbs_max_out[7] = aabb_max[1];
	return CGL_TRUE;
}

CGL_bool CGL_aabb_subdivide_3d(CGL_int n, CGL_float* aabb_min, CGL_float* aabb_max, CGL_float* aabbs_min_out, CGL_float* aabbs_max_out)
{
	// CGL_log_internal("CGL_aabb_subdivide_3d Not implemented yet");
	return CGL_aabb_subdivide_nd(n, aabb_min, aabb_max, aabbs_min_out, aabbs_max_out);
}

CGL_bool CGL_aabb_contains_point_nd(CGL_int n, CGL_float* aabb_min, CGL_float* aabb_max, CGL_float* point)
{
	for (CGL_int i = 0; i < n; i++) if (point[i] < aabb_min[i] || point[i] > aabb_max[i]) return CGL_FALSE;
	return CGL_TRUE;
}

CGL_bool CGL_aabb_contains_point_2d(CGL_int n, CGL_float* aabb_min, CGL_float* aabb_max, CGL_float* point)
{
	(void)n;
	return (point[0] >= aabb_min[0] && point[0] <= aabb_max[0] && point[1] >= aabb_min[1] && point[1] <= aabb_max[1]);
}

CGL_bool CGL_aabb_contains_point_3d(CGL_int n, CGL_float* aabb_min, CGL_float* aabb_max, CGL_float* point)
{
	(void)n;
	return (point[0] >= aabb_min[0] && point[0] <= aabb_max[0] && point[1] >= aabb_min[1] && point[1] <= aabb_max[1] && point[2] >= aabb_min[2] && point[2] <= aabb_max[2]);
}

CGL_bool CGL_aabb_intersects_aabb_nd(CGL_int n, CGL_float* aabb_min, CGL_float* aabb_max, CGL_float* aabb_min2, CGL_float* aabb_max2)
{
	for (CGL_int i = 0; i < n; i++) if (aabb_min[i] > aabb_max2[i] || aabb_max[i] < aabb_min2[i]) return CGL_FALSE;
	return CGL_TRUE;
}

CGL_bool CGL_aabb_intersects_aabb_2d(CGL_int n, CGL_float* aabb_min, CGL_float* aabb_max, CGL_float* aabb_min2, CGL_float* aabb_max2)
{
	(void)n;
	return (aabb_min[0] <= aabb_max2[0] && aabb_max[0] >= aabb_min2[0] && aabb_min[1] <= aabb_max2[1] && aabb_max[1] >= aabb_min2[1]);
}

CGL_bool CGL_aabb_intersects_aabb_3d(CGL_int n, CGL_float* aabb_min, CGL_float* aabb_max, CGL_float* aabb_min2, CGL_float* aabb_max2)
{
	(void)n;
	return (aabb_min[0] <= aabb_max2[0] && aabb_max[0] >= aabb_min2[0] && aabb_min[1] <= aabb_max2[1] && aabb_max[1] >= aabb_min2[1] && aabb_min[2] <= aabb_max2[2] && aabb_max[2] >= aabb_min2[2]);
}


#define CGL_INCREMENTAL_TRIANGULATOR_SET_TRIANGLE(triangles, index, a, b, c) \
    triangles[index * 3 + 0] = a; \
    triangles[index * 3 + 1] = b; \
    triangles[index * 3 + 2] = c;

static void __CGL_triangulate_points_incremental_remove_triangle_at_index(CGL_int* triangles, CGL_int index)
{
	CGL_INCREMENTAL_TRIANGULATOR_SET_TRIANGLE(triangles, index, -10, -10, -10);
}

static CGL_int __CGL_triangulate_points_incremental_add_triangle_at_index(CGL_int* triangles, CGL_int a, CGL_int b, CGL_int c, CGL_int count)
{
	for (CGL_int i = 0; i < count; )
	{
		if (triangles[i * 3 + 0] == -10) { CGL_INCREMENTAL_TRIANGULATOR_SET_TRIANGLE(triangles, i, a, b, c); return count + 1; }
		else i++;
	}
	CGL_INCREMENTAL_TRIANGULATOR_SET_TRIANGLE(triangles, count, a, b, c);
	return count + 1;
}

// Source: https://en.wikipedia.org/wiki/Bowyer%E2%80%93Watson_algorithm
/*
* The Bowyerâ€“Watson algorithm is an incremental algorithm.
* It works by adding points, one at a time, to a valid
* Delaunay triangulation of a subset of the desired points.
* After every insertion, any triangles whose circumcircles
* contain the new point are deleted, leaving a star-shaped
* polygonal hole which is then re-triangulated using the
* new point. By using the connectivity of the triangulation
* to efficiently locate triangles to remove, the algorithm
* can take O(N log N) operations to triangulate N points,
* although special degenerate cases exist where this
* goes up to O(N2)
*/
CGL_bool CGL_triangulate_points_incremental(CGL_vec2* points, CGL_int points_count, CGL_int* triangles_out, CGL_int* triangles_count_out)
{
	if (!triangles_count_out || !triangles_out) return false;
	if (points_count < 3) return false;
	static CGL_int triangles[CGL_INCREMENTAL_TRIANGULATOR_MAX_TRIANGLES * 3];
	static CGL_int bad_triangles[CGL_INCREMENTAL_TRIANGULATOR_MAX_TRIANGLES * 3];
	static CGL_int polygon[CGL_INCREMENTAL_TRIANGULATOR_MAX_TRIANGLES * 2];
	CGL_int triangles_count = 0, bad_triangles_count = 0, polygon_count = 0;
	CGL_vec2 a, b, c, p, va, vb, vc, centre; CGL_float rad; CGL_int ta, tb, tc, taa, tbb, tcc;
	if (!CGL_utils_calculate_super_triangle(points, points_count, &a, &b, &c, 0.01f)) return false;
	*triangles_count_out = 0;
	triangles_count = __CGL_triangulate_points_incremental_add_triangle_at_index(triangles, -1, -2, -3, triangles_count);
	for (CGL_int i = 0; i < points_count; i++)
	{
		p = points[i]; bad_triangles_count = 0;
		for (CGL_int j = 0, k = 0; j < triangles_count; j++, k++)
		{
			ta = triangles[k * 3 + 0]; tb = triangles[k * 3 + 1]; tc = triangles[k * 3 + 2];
			if (ta < -10) { j--; continue; } // skip empty triangle
			va = (ta < 0) ? ((ta == -1) ? a : ((ta == -2) ? b : c)) : points[ta];
			vb = (tb < 0) ? ((tb == -1) ? a : ((tb == -2) ? b : c)) : points[tb];
			vc = (tc < 0) ? ((tc == -1) ? a : ((tc == -2) ? b : c)) : points[tc];
			if (!CGL_utils_calculate_circumcircle(va, vb, vc, &centre, &rad)) return false;
			if (CGL_vec2_distance(centre, p) < rad)
			{
				bad_triangles_count = __CGL_triangulate_points_incremental_add_triangle_at_index(bad_triangles, ta, tb, tc, bad_triangles_count);
				__CGL_triangulate_points_incremental_remove_triangle_at_index(triangles, k);
			}
		}
		triangles_count -= bad_triangles_count; polygon_count = 0;
		for (CGL_int j = 0; j < bad_triangles_count; j++)
		{
			ta = bad_triangles[j * 3 + 0]; tb = bad_triangles[j * 3 + 1]; tc = bad_triangles[j * 3 + 2];
			CGL_int bd_edges[] = { ta, tb, tb, tc, tc, ta };
			for (CGL_int u = 0; u < 3; u++)
			{
				CGL_bool is_shared = false;
				for (CGL_int k = 0; k < bad_triangles_count; k++)
				{
					if (j == k) continue;
					taa = bad_triangles[k * 3 + 0]; tbb = bad_triangles[k * 3 + 1]; tcc = bad_triangles[k * 3 + 2];
					CGL_int bd_edges2[] = { taa, tbb, tbb, tcc, tcc, taa };
					for (CGL_int v = 0; v < 3; v++) { if ((bd_edges[u * 2 + 0] == bd_edges2[v * 2 + 0] && bd_edges[u * 2 + 1] == bd_edges2[v * 2 + 1]) || (bd_edges[u * 2 + 0] == bd_edges2[v * 2 + 1] && bd_edges[u * 2 + 1] == bd_edges2[v * 2 + 0])) { is_shared = true; break; } }
					if (is_shared) break;
				}
				if (!is_shared) { polygon[polygon_count * 2 + 0] = bd_edges[u * 2 + 0]; polygon[polygon_count * 2 + 1] = bd_edges[u * 2 + 1]; polygon_count++; }
			}
		}
		for (CGL_int j = 0; j < polygon_count; j++)
		{
			ta = polygon[j * 2 + 0]; tb = polygon[j * 2 + 1]; tc = i;
			triangles_count = __CGL_triangulate_points_incremental_add_triangle_at_index(triangles, ta, tb, tc, triangles_count);
		}
	}
	*triangles_count_out = 0;
	for (CGL_int j = 0, k = 0; j < triangles_count; j++, k++)
	{
		ta = triangles[k * 3 + 0]; tb = triangles[k * 3 + 1]; tc = triangles[k * 3 + 2];
		if (ta < 0 || tb < 0 || tc < 0) continue;
		CGL_INCREMENTAL_TRIANGULATOR_SET_TRIANGLE(triangles_out, *triangles_count_out, ta, tb, tc); *triangles_count_out += 1;
	}
	return true;
}

/*
uint32_t CGL_utils_crc32(const void* dat, size_t size)
{
	const uint8_t* data = (const uint8_t*)dat;
	uint32_t crc=0xFFFFFFFF;
	for(size_t i = 0 ; i < size ; i++)
	{
		char ch = data[i];
		for(size_t j=0;j<8;j++) {
			uint32_t b=(ch^crc)&1;
			crc>>=1;
			if(b) crc=crc^0xEDB88320;
			ch>>=1;
		}
	}
	return ~crc;
}
*/

// From : https://chromium.googlesource.com/chromiumos/platform/punybench/+/refs/heads/stabilize-6909.B/libpuny.b/crc32.c
static const uint32_t __CGL_CRC32_TABLE[256] =
{
	0x00000000, 0x77073096, 0xee0e612c, 0x990951ba,
	0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
	0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
	0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
	0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
	0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
	0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec,
	0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
	0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
	0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
	0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940,
	0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
	0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116,
	0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
	0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
	0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
	0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a,
	0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
	0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818,
	0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
	0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
	0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
	0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c,
	0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
	0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
	0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
	0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
	0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
	0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086,
	0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
	0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4,
	0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
	0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
	0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
	0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
	0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
	0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe,
	0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
	0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
	0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
	0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252,
	0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
	0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60,
	0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
	0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
	0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
	0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04,
	0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
	0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a,
	0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
	0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
	0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
	0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e,
	0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
	0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
	0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
	0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
	0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
	0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0,
	0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
	0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6,
	0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
	0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
	0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};

uint32_t CGL_utils_crc32(const void* dat, size_t size)
{
	const uint8_t* b = (const uint8_t*)dat;
	uint32_t crc = 0xFFFFFFFF;
	for (size_t i = 0; i < size; i++)
		crc = __CGL_CRC32_TABLE[(crc ^ *b++) & 0xff] ^ (crc >> 8);
	return ~crc;
}


// From : https://chromium.googlesource.com/chromiumos/platform/punybench/+/refs/heads/stabilize-6909.B/libpuny.b/crc64.c
#define CGL_CONST64(x) x##ull

static const uint64_t __CGL_CRC64_TABLE[256] = {
	CGL_CONST64(0x0000000000000000), CGL_CONST64(0x42f0e1eba9ea3693),
	CGL_CONST64(0x85e1c3d753d46d26), CGL_CONST64(0xc711223cfa3e5bb5),
	CGL_CONST64(0x493366450e42ecdf), CGL_CONST64(0x0bc387aea7a8da4c),
	CGL_CONST64(0xccd2a5925d9681f9), CGL_CONST64(0x8e224479f47cb76a),
	CGL_CONST64(0x9266cc8a1c85d9be), CGL_CONST64(0xd0962d61b56fef2d),
	CGL_CONST64(0x17870f5d4f51b498), CGL_CONST64(0x5577eeb6e6bb820b),
	CGL_CONST64(0xdb55aacf12c73561), CGL_CONST64(0x99a54b24bb2d03f2),
	CGL_CONST64(0x5eb4691841135847), CGL_CONST64(0x1c4488f3e8f96ed4),
	CGL_CONST64(0x663d78ff90e185ef), CGL_CONST64(0x24cd9914390bb37c),
	CGL_CONST64(0xe3dcbb28c335e8c9), CGL_CONST64(0xa12c5ac36adfde5a),
	CGL_CONST64(0x2f0e1eba9ea36930), CGL_CONST64(0x6dfeff5137495fa3),
	CGL_CONST64(0xaaefdd6dcd770416), CGL_CONST64(0xe81f3c86649d3285),
	CGL_CONST64(0xf45bb4758c645c51), CGL_CONST64(0xb6ab559e258e6ac2),
	CGL_CONST64(0x71ba77a2dfb03177), CGL_CONST64(0x334a9649765a07e4),
	CGL_CONST64(0xbd68d2308226b08e), CGL_CONST64(0xff9833db2bcc861d),
	CGL_CONST64(0x388911e7d1f2dda8), CGL_CONST64(0x7a79f00c7818eb3b),
	CGL_CONST64(0xcc7af1ff21c30bde), CGL_CONST64(0x8e8a101488293d4d),
	CGL_CONST64(0x499b3228721766f8), CGL_CONST64(0x0b6bd3c3dbfd506b),
	CGL_CONST64(0x854997ba2f81e701), CGL_CONST64(0xc7b97651866bd192),
	CGL_CONST64(0x00a8546d7c558a27), CGL_CONST64(0x4258b586d5bfbcb4),
	CGL_CONST64(0x5e1c3d753d46d260), CGL_CONST64(0x1cecdc9e94ace4f3),
	CGL_CONST64(0xdbfdfea26e92bf46), CGL_CONST64(0x990d1f49c77889d5),
	CGL_CONST64(0x172f5b3033043ebf), CGL_CONST64(0x55dfbadb9aee082c),
	CGL_CONST64(0x92ce98e760d05399), CGL_CONST64(0xd03e790cc93a650a),
	CGL_CONST64(0xaa478900b1228e31), CGL_CONST64(0xe8b768eb18c8b8a2),
	CGL_CONST64(0x2fa64ad7e2f6e317), CGL_CONST64(0x6d56ab3c4b1cd584),
	CGL_CONST64(0xe374ef45bf6062ee), CGL_CONST64(0xa1840eae168a547d),
	CGL_CONST64(0x66952c92ecb40fc8), CGL_CONST64(0x2465cd79455e395b),
	CGL_CONST64(0x3821458aada7578f), CGL_CONST64(0x7ad1a461044d611c),
	CGL_CONST64(0xbdc0865dfe733aa9), CGL_CONST64(0xff3067b657990c3a),
	CGL_CONST64(0x711223cfa3e5bb50), CGL_CONST64(0x33e2c2240a0f8dc3),
	CGL_CONST64(0xf4f3e018f031d676), CGL_CONST64(0xb60301f359dbe0e5),
	CGL_CONST64(0xda050215ea6c212f), CGL_CONST64(0x98f5e3fe438617bc),
	CGL_CONST64(0x5fe4c1c2b9b84c09), CGL_CONST64(0x1d14202910527a9a),
	CGL_CONST64(0x93366450e42ecdf0), CGL_CONST64(0xd1c685bb4dc4fb63),
	CGL_CONST64(0x16d7a787b7faa0d6), CGL_CONST64(0x5427466c1e109645),
	CGL_CONST64(0x4863ce9ff6e9f891), CGL_CONST64(0x0a932f745f03ce02),
	CGL_CONST64(0xcd820d48a53d95b7), CGL_CONST64(0x8f72eca30cd7a324),
	CGL_CONST64(0x0150a8daf8ab144e), CGL_CONST64(0x43a04931514122dd),
	CGL_CONST64(0x84b16b0dab7f7968), CGL_CONST64(0xc6418ae602954ffb),
	CGL_CONST64(0xbc387aea7a8da4c0), CGL_CONST64(0xfec89b01d3679253),
	CGL_CONST64(0x39d9b93d2959c9e6), CGL_CONST64(0x7b2958d680b3ff75),
	CGL_CONST64(0xf50b1caf74cf481f), CGL_CONST64(0xb7fbfd44dd257e8c),
	CGL_CONST64(0x70eadf78271b2539), CGL_CONST64(0x321a3e938ef113aa),
	CGL_CONST64(0x2e5eb66066087d7e), CGL_CONST64(0x6cae578bcfe24bed),
	CGL_CONST64(0xabbf75b735dc1058), CGL_CONST64(0xe94f945c9c3626cb),
	CGL_CONST64(0x676dd025684a91a1), CGL_CONST64(0x259d31cec1a0a732),
	CGL_CONST64(0xe28c13f23b9efc87), CGL_CONST64(0xa07cf2199274ca14),
	CGL_CONST64(0x167ff3eacbaf2af1), CGL_CONST64(0x548f120162451c62),
	CGL_CONST64(0x939e303d987b47d7), CGL_CONST64(0xd16ed1d631917144),
	CGL_CONST64(0x5f4c95afc5edc62e), CGL_CONST64(0x1dbc74446c07f0bd),
	CGL_CONST64(0xdaad56789639ab08), CGL_CONST64(0x985db7933fd39d9b),
	CGL_CONST64(0x84193f60d72af34f), CGL_CONST64(0xc6e9de8b7ec0c5dc),
	CGL_CONST64(0x01f8fcb784fe9e69), CGL_CONST64(0x43081d5c2d14a8fa),
	CGL_CONST64(0xcd2a5925d9681f90), CGL_CONST64(0x8fdab8ce70822903),
	CGL_CONST64(0x48cb9af28abc72b6), CGL_CONST64(0x0a3b7b1923564425),
	CGL_CONST64(0x70428b155b4eaf1e), CGL_CONST64(0x32b26afef2a4998d),
	CGL_CONST64(0xf5a348c2089ac238), CGL_CONST64(0xb753a929a170f4ab),
	CGL_CONST64(0x3971ed50550c43c1), CGL_CONST64(0x7b810cbbfce67552),
	CGL_CONST64(0xbc902e8706d82ee7), CGL_CONST64(0xfe60cf6caf321874),
	CGL_CONST64(0xe224479f47cb76a0), CGL_CONST64(0xa0d4a674ee214033),
	CGL_CONST64(0x67c58448141f1b86), CGL_CONST64(0x253565a3bdf52d15),
	CGL_CONST64(0xab1721da49899a7f), CGL_CONST64(0xe9e7c031e063acec),
	CGL_CONST64(0x2ef6e20d1a5df759), CGL_CONST64(0x6c0603e6b3b7c1ca),
	CGL_CONST64(0xf6fae5c07d3274cd), CGL_CONST64(0xb40a042bd4d8425e),
	CGL_CONST64(0x731b26172ee619eb), CGL_CONST64(0x31ebc7fc870c2f78),
	CGL_CONST64(0xbfc9838573709812), CGL_CONST64(0xfd39626eda9aae81),
	CGL_CONST64(0x3a28405220a4f534), CGL_CONST64(0x78d8a1b9894ec3a7),
	CGL_CONST64(0x649c294a61b7ad73), CGL_CONST64(0x266cc8a1c85d9be0),
	CGL_CONST64(0xe17dea9d3263c055), CGL_CONST64(0xa38d0b769b89f6c6),
	CGL_CONST64(0x2daf4f0f6ff541ac), CGL_CONST64(0x6f5faee4c61f773f),
	CGL_CONST64(0xa84e8cd83c212c8a), CGL_CONST64(0xeabe6d3395cb1a19),
	CGL_CONST64(0x90c79d3fedd3f122), CGL_CONST64(0xd2377cd44439c7b1),
	CGL_CONST64(0x15265ee8be079c04), CGL_CONST64(0x57d6bf0317edaa97),
	CGL_CONST64(0xd9f4fb7ae3911dfd), CGL_CONST64(0x9b041a914a7b2b6e),
	CGL_CONST64(0x5c1538adb04570db), CGL_CONST64(0x1ee5d94619af4648),
	CGL_CONST64(0x02a151b5f156289c), CGL_CONST64(0x4051b05e58bc1e0f),
	CGL_CONST64(0x87409262a28245ba), CGL_CONST64(0xc5b073890b687329),
	CGL_CONST64(0x4b9237f0ff14c443), CGL_CONST64(0x0962d61b56fef2d0),
	CGL_CONST64(0xce73f427acc0a965), CGL_CONST64(0x8c8315cc052a9ff6),
	CGL_CONST64(0x3a80143f5cf17f13), CGL_CONST64(0x7870f5d4f51b4980),
	CGL_CONST64(0xbf61d7e80f251235), CGL_CONST64(0xfd913603a6cf24a6),
	CGL_CONST64(0x73b3727a52b393cc), CGL_CONST64(0x31439391fb59a55f),
	CGL_CONST64(0xf652b1ad0167feea), CGL_CONST64(0xb4a25046a88dc879),
	CGL_CONST64(0xa8e6d8b54074a6ad), CGL_CONST64(0xea16395ee99e903e),
	CGL_CONST64(0x2d071b6213a0cb8b), CGL_CONST64(0x6ff7fa89ba4afd18),
	CGL_CONST64(0xe1d5bef04e364a72), CGL_CONST64(0xa3255f1be7dc7ce1),
	CGL_CONST64(0x64347d271de22754), CGL_CONST64(0x26c49cccb40811c7),
	CGL_CONST64(0x5cbd6cc0cc10fafc), CGL_CONST64(0x1e4d8d2b65facc6f),
	CGL_CONST64(0xd95caf179fc497da), CGL_CONST64(0x9bac4efc362ea149),
	CGL_CONST64(0x158e0a85c2521623), CGL_CONST64(0x577eeb6e6bb820b0),
	CGL_CONST64(0x906fc95291867b05), CGL_CONST64(0xd29f28b9386c4d96),
	CGL_CONST64(0xcedba04ad0952342), CGL_CONST64(0x8c2b41a1797f15d1),
	CGL_CONST64(0x4b3a639d83414e64), CGL_CONST64(0x09ca82762aab78f7),
	CGL_CONST64(0x87e8c60fded7cf9d), CGL_CONST64(0xc51827e4773df90e),
	CGL_CONST64(0x020905d88d03a2bb), CGL_CONST64(0x40f9e43324e99428),
	CGL_CONST64(0x2cffe7d5975e55e2), CGL_CONST64(0x6e0f063e3eb46371),
	CGL_CONST64(0xa91e2402c48a38c4), CGL_CONST64(0xebeec5e96d600e57),
	CGL_CONST64(0x65cc8190991cb93d), CGL_CONST64(0x273c607b30f68fae),
	CGL_CONST64(0xe02d4247cac8d41b), CGL_CONST64(0xa2dda3ac6322e288),
	CGL_CONST64(0xbe992b5f8bdb8c5c), CGL_CONST64(0xfc69cab42231bacf),
	CGL_CONST64(0x3b78e888d80fe17a), CGL_CONST64(0x7988096371e5d7e9),
	CGL_CONST64(0xf7aa4d1a85996083), CGL_CONST64(0xb55aacf12c735610),
	CGL_CONST64(0x724b8ecdd64d0da5), CGL_CONST64(0x30bb6f267fa73b36),
	CGL_CONST64(0x4ac29f2a07bfd00d), CGL_CONST64(0x08327ec1ae55e69e),
	CGL_CONST64(0xcf235cfd546bbd2b), CGL_CONST64(0x8dd3bd16fd818bb8),
	CGL_CONST64(0x03f1f96f09fd3cd2), CGL_CONST64(0x41011884a0170a41),
	CGL_CONST64(0x86103ab85a2951f4), CGL_CONST64(0xc4e0db53f3c36767),
	CGL_CONST64(0xd8a453a01b3a09b3), CGL_CONST64(0x9a54b24bb2d03f20),
	CGL_CONST64(0x5d45907748ee6495), CGL_CONST64(0x1fb5719ce1045206),
	CGL_CONST64(0x919735e51578e56c), CGL_CONST64(0xd367d40ebc92d3ff),
	CGL_CONST64(0x1476f63246ac884a), CGL_CONST64(0x568617d9ef46bed9),
	CGL_CONST64(0xe085162ab69d5e3c), CGL_CONST64(0xa275f7c11f7768af),
	CGL_CONST64(0x6564d5fde549331a), CGL_CONST64(0x279434164ca30589),
	CGL_CONST64(0xa9b6706fb8dfb2e3), CGL_CONST64(0xeb46918411358470),
	CGL_CONST64(0x2c57b3b8eb0bdfc5), CGL_CONST64(0x6ea7525342e1e956),
	CGL_CONST64(0x72e3daa0aa188782), CGL_CONST64(0x30133b4b03f2b111),
	CGL_CONST64(0xf7021977f9cceaa4), CGL_CONST64(0xb5f2f89c5026dc37),
	CGL_CONST64(0x3bd0bce5a45a6b5d), CGL_CONST64(0x79205d0e0db05dce),
	CGL_CONST64(0xbe317f32f78e067b), CGL_CONST64(0xfcc19ed95e6430e8),
	CGL_CONST64(0x86b86ed5267cdbd3), CGL_CONST64(0xc4488f3e8f96ed40),
	CGL_CONST64(0x0359ad0275a8b6f5), CGL_CONST64(0x41a94ce9dc428066),
	CGL_CONST64(0xcf8b0890283e370c), CGL_CONST64(0x8d7be97b81d4019f),
	CGL_CONST64(0x4a6acb477bea5a2a), CGL_CONST64(0x089a2aacd2006cb9),
	CGL_CONST64(0x14dea25f3af9026d), CGL_CONST64(0x562e43b4931334fe),
	CGL_CONST64(0x913f6188692d6f4b), CGL_CONST64(0xd3cf8063c0c759d8),
	CGL_CONST64(0x5dedc41a34bbeeb2), CGL_CONST64(0x1f1d25f19d51d821),
	CGL_CONST64(0xd80c07cd676f8394), CGL_CONST64(0x9afce626ce85b507)
};

uint64_t CGL_utils_crc64(const void* data, size_t size)
{
	uint64_t crc = 0xffffffffffffffffULL;
	const uint8_t* b = (const uint8_t*)data;
	for (size_t i = 0; i < size; i++)
		crc = __CGL_CRC64_TABLE[(uint8_t)(crc >> 56) ^ *b++] ^ (crc << 8);
	return ~crc;
}


// From : https://github.com/B-Con/crypto-algorithms/blob/master/rot-13.c
CGL_void CGL_utils_rot13(const char* data_in, char* str)
{
	CGL_int case_type, idx, len;
	len = (int)strlen(data_in);
	strcpy(str, data_in);
	for (idx = 0; idx < len; idx++) {
		// Only process alphabetic characters.
		if (str[idx] < 'A' || (str[idx] > 'Z' && str[idx] < 'a') || str[idx] > 'z')
			continue;
		// Determine if the char is upper or lower case.
		if (str[idx] >= 'a')
			case_type = 'a';
		else
			case_type = 'A';
		// Rotate the char's value, ensuring it doesn't accidentally "fall off" the end.
		str[idx] = (str[idx] + 13) % (case_type + 26);
		if (str[idx] < 26)
			str[idx] += (char)case_type;
	}
}


// From : http://www.azillionmonkeys.com/qed/hash.html

#if (defined(__GNUC__) && defined(__i386__)) || defined(__WATCOMC__) \
  || defined(_MSC_VER) || defined (__BORLANDC__) || defined (__TURBOC__)
#define CGL_get16bits(d) (*((const uint16_t *) (d)))
#endif

#if !defined (CGL_get16bits)
#define CGL_get16bits(d) ((((uint32_t)(((const uint8_t *)(d))[1])) << 8)\
                       +(uint32_t)(((const uint8_t *)(d))[0]) )
#endif

uint32_t CGL_utils_super_fast_hash(const void* dat, size_t len)
{
	const uint8_t* data = (const uint8_t*)dat;
	uint32_t hash = (uint32_t)len;
	uint32_t tmp;
	CGL_int rem;

	if (len <= 0 || data == NULL) return 0;

	rem = len & 3;
	len >>= 2;

	/* Main loop */
	for (; len > 0; len--) {
		hash += CGL_get16bits(data);
		tmp = (CGL_get16bits(data + 2) << 11) ^ hash;
		hash = (hash << 16) ^ tmp;
		data += 2 * sizeof(uint16_t);
		hash += hash >> 11;
	}

	/* Handle end cases */
	switch (rem) {
	case 3: hash += CGL_get16bits(data);
		hash ^= hash << 16;
		hash ^= ((signed char)data[sizeof(uint16_t)]) << 18;
		hash += hash >> 11;
		break;
	case 2: hash += CGL_get16bits(data);
		hash ^= hash << 11;
		hash += hash >> 17;
		break;
	case 1: hash += (signed char)*data;
		hash ^= hash << 10;
		hash += hash >> 1;
	}

	/* Force "avalanching" of final 127 bits */
	hash ^= hash << 3;
	hash += hash >> 5;
	hash ^= hash << 4;
	hash += hash >> 17;
	hash ^= hash << 25;
	hash += hash >> 6;

	return hash;
}

#endif

// common lib and mat
#if 1 // Just to use code folding

CGL_float CGL_float_quadratic_lerp(CGL_float a, CGL_float b, CGL_float c, CGL_float t)
{
	CGL_float t2 = t * t;
	CGL_float a0 = c - a;
	CGL_float a1 = a - b * 2.0f + c;
	CGL_float a2 = b - a;
	return (a0 + a1 * t + a2 * t2);
}

CGL_float CGL_float_cubic_lerp(CGL_float a, CGL_float b, CGL_float c, CGL_float d, CGL_float t)
{
	CGL_float p0 = CGL_float_lerp(a, c, t);
	CGL_float p1 = CGL_float_lerp(c, d, t);
	CGL_float p2 = CGL_float_lerp(d, b, t);
	CGL_float q0 = CGL_float_lerp(p0, p1, t);
	CGL_float q1 = CGL_float_lerp(p1, p2, t);
	return CGL_float_lerp(q0, q1, t);
}

// Uses Rodrigues' rotation formula to rotate a vector about an axis
CGL_vec3 CGL_vec3_rotate_about_axis(CGL_vec3 v, CGL_vec3 axis, CGL_float theta)
{
	CGL_float cos_theta = cosf(theta);
	CGL_float sin_theta = sinf(theta);
	CGL_float dot = CGL_vec3_dot(axis, v);
	CGL_vec3 cross = CGL_vec3_cross(axis, v);
	CGL_vec3 result = CGL_vec3_scale(v, cos_theta);
	CGL_vec3 temp = CGL_vec3_scale(axis, dot * (1 - cos_theta));
	result = CGL_vec3_add(result, temp);
	temp = CGL_vec3_scale(cross, sin_theta);
	result = CGL_vec3_add(result, temp);
	return result;
}

// vector triple product
CGL_vec2 CGL_vec2_triple_product(CGL_vec2 a, CGL_vec2 b, CGL_vec2 c)
{
	CGL_vec2 tmp0 = CGL_vec2_scale_(b, CGL_vec2_dot(a, c));
	CGL_vec2 tmp1 = CGL_vec2_scale_(a, CGL_vec2_dot(b, c));
	return CGL_vec2_sub(tmp0, tmp1);
}

CGL_vec3 CGL_vec3_triple_product(CGL_vec3 a, CGL_vec3 b, CGL_vec3 c)
{
	CGL_vec3 tmp0 = CGL_vec3_scale_(b, CGL_vec3_dot(a, c));
	CGL_vec3 tmp1 = CGL_vec3_scale_(a, CGL_vec3_dot(b, c));
	return CGL_vec3_sub(tmp0, tmp1);
}

CGL_vec4 CGL_vec4_triple_product(CGL_vec4 a, CGL_vec4 b, CGL_vec4 c)
{
	CGL_vec4 tmp0 = CGL_vec4_scale_(b, CGL_vec4_dot(a, c));
	CGL_vec4 tmp1 = CGL_vec4_scale_(a, CGL_vec4_dot(b, c));
	return CGL_vec4_sub(tmp0, tmp1);
}


CGL_void CGL_vec3_calculate_orthonormal_basis_from_one_vector(CGL_vec3 a, CGL_vec3* pb, CGL_vec3* pc)
{
	CGL_vec3_normalize(a);
	CGL_vec3 b = CGL_vec3_init(0.0f, 0.0f, 0.0f);
	CGL_vec3 c = CGL_vec3_init(0.0f, 0.0f, 0.0f);
	if (a.x != 0.0f) b = CGL_vec3_init(-a.y / a.x, 1.0f, 0.0f);
	else if (a.y != 0.0f) b = CGL_vec3_init(0.0f, -a.z / a.y, 1.0f);
	else b = CGL_vec3_init(1.0f, 0.0f, -a.x / a.z);
	CGL_vec3_normalize(b);
	c = CGL_vec3_cross(a, b);
	if (pb) *pb = b;
	if (pc) *pc = c;
}

CGL_vec3 CGL_vec3_reflect(CGL_vec3 a, CGL_vec3 n)
{
	CGL_float dot = CGL_vec3_dot(a, n);
	CGL_vec3 result = CGL_vec3_scale(n, 2.0f * dot);
	result = CGL_vec3_sub(a, result);
	return result;
}


CGL_mat4 CGL_mat4_mul(CGL_mat4 b, CGL_mat4 a)
{
	CGL_mat4 result = CGL_mat4_zero();
	for (CGL_int i = 0; i < 4; i++) for (CGL_int j = 0; j < 4; j++)
	{
		for (CGL_int k = 0; k < 4; k++)
			CGL_mat4_elem_set(result, i, j, CGL_mat4_elem_get(result, i, j) + CGL_mat4_elem_get(a, i, k) * CGL_mat4_elem_get(b, k, j));
	}
	return result;
}

// LU decomposition using Kraut's algorithm
CGL_void CGL_mat4_decompose_lu(CGL_mat4 m, CGL_mat4* l, CGL_mat4* u)
{
	CGL_mat4 L = CGL_mat4_identity();
	CGL_mat4 U = CGL_mat4_identity();
	for (CGL_int j = 0; j < 4; j++)
	{
		for (CGL_int i = 0; i <= j; i++)
		{
			CGL_float sum = CGL_mat4_elem_get(m, i, j);
			for (CGL_int k = 0; k < i; k++)
				sum -= CGL_mat4_elem_get(L, i, k) * CGL_mat4_elem_get(U, k, j);
			CGL_mat4_elem_set(U, i, j, sum);
		}
		for (CGL_int i = j + 1; i < 4; i++)
		{
			CGL_float sum = CGL_mat4_elem_get(m, i, j);
			for (CGL_int k = 0; k < j; k++)
				sum -= CGL_mat4_elem_get(L, i, k) * CGL_mat4_elem_get(U, k, j);
			CGL_mat4_elem_set(L, i, j, sum / CGL_mat4_elem_get(U, j, j));
		}
	}
	if (l) *l = L;
	if (u) *u = U;
}

CGL_float CGL_mat4_det(CGL_mat4 m)
{
	return CGL_mat4_det_by_gauss(m);
}

CGL_float CGL_mat4_det_by_lu(CGL_mat4 m)
{
	CGL_mat4 U = CGL_mat4_identity();
	CGL_mat4_decompose_lu(m, NULL, &U);
	CGL_float det = 1.0f;
	for (CGL_int i = 0; i < 4; i++) det *= CGL_mat4_elem_get(U, i, i);
	return det;
}

CGL_float CGL_mat4_det_by_gauss(CGL_mat4 m)
{
	m = CGL_mat4_gauss_elim(m);
	CGL_float det = 1.0f;
	for (CGL_int i = 0; i < 4; i++) det *= CGL_mat4_elem_get(m, i, i);
	return det;
}

CGL_vec4 CGL_mat4_mul_vec4(CGL_mat4 m, CGL_vec4 v)
{
	CGL_vec4 result = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	result.x = CGL_mat4_elem_get(m, 0, 0) * v.x + CGL_mat4_elem_get(m, 0, 1) * v.y + CGL_mat4_elem_get(m, 0, 2) * v.z + CGL_mat4_elem_get(m, 0, 3) * v.w;
	result.y = CGL_mat4_elem_get(m, 1, 0) * v.x + CGL_mat4_elem_get(m, 1, 1) * v.y + CGL_mat4_elem_get(m, 1, 2) * v.z + CGL_mat4_elem_get(m, 1, 3) * v.w;
	result.z = CGL_mat4_elem_get(m, 2, 0) * v.x + CGL_mat4_elem_get(m, 2, 1) * v.y + CGL_mat4_elem_get(m, 2, 2) * v.z + CGL_mat4_elem_get(m, 2, 3) * v.w;
	result.w = CGL_mat4_elem_get(m, 3, 0) * v.x + CGL_mat4_elem_get(m, 3, 1) * v.y + CGL_mat4_elem_get(m, 3, 2) * v.z + CGL_mat4_elem_get(m, 3, 3) * v.w;
	return result;
}

CGL_mat4 CGL_mat4_adjoint(CGL_mat4 m)
{
	CGL_mat4 result = CGL_mat4_zero();
	for (CGL_int i = 0; i < 4; i++) for (CGL_int j = 0; j < 4; j++)
	{
		CGL_mat4 temp = CGL_mat4_zero();
		for (CGL_int k = 0; k < 4; k++) for (CGL_int l = 0; l < 4; l++)
		{
			if (k != i && l != j)
				CGL_mat4_elem_set(temp, k < i ? k : k - 1, l < j ? l : l - 1, CGL_mat4_elem_get(m, k, l));
		}
		CGL_mat4_elem_set(result, i, j, CGL_mat4_det(temp) * ((i + j) % 2 == 0 ? 1.0f : -1.0f));
	}
	return result;
}

CGL_mat4 CGL_mat4_inverse(CGL_mat4 m)
{
	CGL_mat4 result = CGL_mat4_adjoint(m);
	CGL_float det = CGL_mat4_det(m);
	det = 1.0f / det;
	result = CGL_mat4_mul_scalar(result, det);
	return result;
}

CGL_mat4 CGL_mat4_transpose(CGL_mat4 m)
{
	return CGL_mat4_init(
                         CGL_mat4_elem_get(m, 0, 0), CGL_mat4_elem_get(m, 0, 1), CGL_mat4_elem_get(m, 0, 2), CGL_mat4_elem_get(m, 0, 3),
                         CGL_mat4_elem_get(m, 1, 0), CGL_mat4_elem_get(m, 1, 1), CGL_mat4_elem_get(m, 1, 2), CGL_mat4_elem_get(m, 1, 3),
                         CGL_mat4_elem_get(m, 2, 0), CGL_mat4_elem_get(m, 2, 1), CGL_mat4_elem_get(m, 2, 2), CGL_mat4_elem_get(m, 2, 3),
                         CGL_mat4_elem_get(m, 3, 0), CGL_mat4_elem_get(m, 3, 1), CGL_mat4_elem_get(m, 3, 2), CGL_mat4_elem_get(m, 3, 3)
                         );
}

CGL_mat4 CGL_mat4_gauss_elim(CGL_mat4 m)
{
	CGL_float ratio = 0.0f;
	for (CGL_int i = 0; i < 4; i++) for (CGL_int j = 0; j < 4; j++)
	{
		if (j > i)
		{
			// cannot divide by zero
			if (CGL_mat4_elem_get(m, i, i) == 0.0f) CGL_mat4_elem_set(m, i, i, powf(2.2204f, -16));
			ratio = CGL_mat4_elem_get(m, j, i) / CGL_mat4_elem_get(m, i, i);
			for (CGL_int k = 0; k < 4; k++) CGL_mat4_elem_set(m, j, k, CGL_mat4_elem_get(m, j, k) - ratio * CGL_mat4_elem_get(m, i, k));
		}
	}
	return m;
}

CGL_int CGL_mat4_rank(CGL_mat4 m)
{
	m = CGL_mat4_gauss_elim(m);
	CGL_int rank = 0;
	CGL_float eps = powf(2.2204f, -16);
	CGL_float sum = 0.0f;
	for (CGL_int i = 0; i < 4; i++)
	{
		sum = 0.0f;
		for (CGL_int j = 0; j < 4; j++) sum += CGL_mat4_elem_get(m, i, j);
		if (fabsf(sum) > eps) rank++;
		else break;
	}
	return rank;
}

CGL_float CGL_mat4_trace(CGL_mat4 m)
{
	CGL_float trace = 0.0f;
	for (CGL_int i = 0; i < 4; i++) trace += CGL_mat4_elem_get(m, i, i);
	return trace;
}

CGL_mat3 CGL_mat4_to_mat3(CGL_mat4 m)
{
	return CGL_mat3_init(
		CGL_mat4_elem_get(m, 0, 0), CGL_mat4_elem_get(m, 0, 1), CGL_mat4_elem_get(m, 0, 2),
		CGL_mat4_elem_get(m, 1, 0), CGL_mat4_elem_get(m, 1, 1), CGL_mat4_elem_get(m, 1, 2),
		CGL_mat4_elem_get(m, 2, 0), CGL_mat4_elem_get(m, 2, 1), CGL_mat4_elem_get(m, 2, 2)
	);
}

CGL_mat4 CGL_mat4_from_mat3(CGL_mat3 m)
{
	return CGL_mat4_init(
		CGL_mat3_elem_get(m, 0, 0), CGL_mat3_elem_get(m, 0, 1), CGL_mat3_elem_get(m, 0, 2), 0.0f,
		CGL_mat3_elem_get(m, 1, 0), CGL_mat3_elem_get(m, 1, 1), CGL_mat3_elem_get(m, 1, 2), 0.0f,
		CGL_mat3_elem_get(m, 2, 0), CGL_mat3_elem_get(m, 2, 1), CGL_mat3_elem_get(m, 2, 2), 0.0f,
		0.0f, 0.0f, 0.0f, 1.0f
	);
}

// Golfman's method for matrix rotation
CGL_mat4 CGL_mat4_rotate_about_axis(CGL_vec3 axis, CGL_float angle)
{
	CGL_float cos_theta = cosf(angle);
	CGL_float sin_theta = sinf(angle);
	CGL_float one_minus_cos_theta = 1.0f - cos_theta;
	CGL_float x = axis.x;
	CGL_float y = axis.y;
	CGL_float z = axis.z;
	return CGL_mat4_init(
		cos_theta + x * x * one_minus_cos_theta, x * y * one_minus_cos_theta - z * sin_theta, x * z * one_minus_cos_theta + y * sin_theta, 0.0f,
		y * x * one_minus_cos_theta + z * sin_theta, cos_theta + y * y * one_minus_cos_theta, y * z * one_minus_cos_theta - x * sin_theta, 0.0f,
		z * x * one_minus_cos_theta - y * sin_theta, z * y * one_minus_cos_theta + x * sin_theta, cos_theta + z * z * one_minus_cos_theta, 0.0f,
		0.0f, 0.0f, 0.0f, 1.0f
	);
}

CGL_float CGL_mat3_det(CGL_mat3 a)
{
	CGL_float result = 0.0f;
	result += CGL_mat3_elem_get(a, 0, 0) * (CGL_mat3_elem_get(a, 1, 1) * CGL_mat3_elem_get(a, 2, 2) - CGL_mat3_elem_get(a, 1, 2) * CGL_mat3_elem_get(a, 2, 1));
	result -= CGL_mat3_elem_get(a, 0, 1) * (CGL_mat3_elem_get(a, 1, 0) * CGL_mat3_elem_get(a, 2, 2) - CGL_mat3_elem_get(a, 1, 2) * CGL_mat3_elem_get(a, 2, 0));
	result += CGL_mat3_elem_get(a, 0, 2) * (CGL_mat3_elem_get(a, 1, 0) * CGL_mat3_elem_get(a, 2, 1) - CGL_mat3_elem_get(a, 1, 1) * CGL_mat3_elem_get(a, 2, 0));
	return result;
}

CGL_float CGL_mat3_trace(CGL_mat3 a)
{
	CGL_float result = 0.0f;
	for (CGL_int i = 0; i < 3; i++) result += CGL_mat3_elem_get(a, i, i);
	return result;
}

CGL_mat3 CGL_mat3_transpose(CGL_mat3 a)
{
	return CGL_mat3_init(
		CGL_mat3_elem_get(a, 0, 0), CGL_mat3_elem_get(a, 1, 0), CGL_mat3_elem_get(a, 2, 0),
		CGL_mat3_elem_get(a, 0, 1), CGL_mat3_elem_get(a, 1, 1), CGL_mat3_elem_get(a, 2, 1),
		CGL_mat3_elem_get(a, 0, 2), CGL_mat3_elem_get(a, 1, 2), CGL_mat3_elem_get(a, 2, 2)
	);
}


float CGL_quat_to_axis_angle(CGL_quat quat, float* x, float* y, float* z)
{
	CGL_float angle = 2.0f * acosf(quat.w);
	// CGL_float divider = sqrtf(1.0f - quat.w * quat.w);
	CGL_float divider = sinf(angle / 2.0f);
	if (divider == 0.0f) return angle;
	if (x) *x = quat.vec.x / divider;
	if (y) *y = quat.vec.y / divider;
	if (z) *z = quat.vec.z / divider;
	return angle;
}

CGL_void CGL_quat_to_euler_zyx(CGL_quat q, float* z, float* y, float* x)
{
	// roll (x-axis rotation)
	if (x)
	{
		CGL_float sinr_cosp = 2.0f * (q.w * q.vec.x + q.vec.y * q.vec.z);
		CGL_float cosr_cosp = 1.0f - 2.0f * (q.vec.x * q.vec.x + q.vec.y * q.vec.y);
		*x = atan2f(sinr_cosp, cosr_cosp);
	}
	// pitch (y-axis rotation)
	if (y)
	{
		CGL_float sinp = 2.0f * (q.w * q.vec.y - q.vec.z * q.vec.x);
		if (fabs(sinp) >= 1) *y = copysignf(3.141f / 2.0f, sinp); // use 90 deg if out of range
		else *y = asinf(sinp);
	}
	// yaw (z-axis rotation)
	if (z)
	{
		CGL_float siny_cosp = 2.0f * (q.w * q.vec.z + q.vec.x * q.vec.y);
		CGL_float cosy_cosp = 1.0f - 2.0f * (q.vec.y * q.vec.y - q.vec.z * q.vec.z);
		*z = atan2f(siny_cosp, cosy_cosp);
	}
}

CGL_quat CGL_quat_mul(CGL_quat a, CGL_quat b)
{
	CGL_quat result = { 0 };
	CGL_vec3 temp1, temp2, temp3;
	temp1 = CGL_vec3_scale(a.vec, b.w);
	temp2 = CGL_vec3_scale(b.vec, a.w);
	temp3 = CGL_vec3_cross(a.vec, b.vec);
	result.w = a.w * b.w - CGL_vec3_dot(a.vec, b.vec);
	result.vec = CGL_vec3_add(temp1, temp2);
	result.vec = CGL_vec3_add(result.vec, temp3);
	return result;
}

CGL_void CGL_quat_rotate(CGL_quat q, CGL_float x, CGL_float y, CGL_float z, float* ox, float* oy, float* oz)
{
	CGL_float ww = q.w * q.w;
	CGL_float xx = q.vec.x * q.vec.x;
	CGL_float yy = q.vec.y * q.vec.y;
	CGL_float zz = q.vec.z * q.vec.z;
	CGL_float wx = q.w * q.vec.x;
	CGL_float wy = q.w * q.vec.y;
	CGL_float wz = q.w * q.vec.z;
	CGL_float xy = q.vec.x * q.vec.y;
	CGL_float xz = q.vec.x * q.vec.z;
	CGL_float yz = q.vec.y * q.vec.z;

	if (ox) *ox = ww * x + 2.0f * wy * z - 2.0f * wz * y + xx * x + 2.0f * xy * y + 2.0f * xz * z - zz * x - yy * x;
	if (oy) *oy = 2.0f * xy * x + yy * y + 2.0f * yz * z + 2.0f * wz * x - zz * y + ww * y - 2.0f * wx * z - xx * y;
	if (oz) *oz = 2.0f * xz * x + 2.0f * yz * y + zz * z - 2.0f * wy * x - yy * z + 2.0f * wx * y - xx * z + ww * z;
}

CGL_quat CGL_quat_inverse(CGL_quat quat)
{
	CGL_float normal = CGL_quat_norm(quat);
	normal = 1.0f / normal * normal;
	quat = CGL_quat_conjugate(quat);
	quat = CGL_quat_mul_scalar(quat, normal);
	return quat;
}

CGL_mat4 CGL_quat_to_mat4(CGL_quat quat)
{
	CGL_float s = CGL_quat_norm(quat);
	s = 2.0f / s * s;
	return CGL_mat4_init(
		1.0f - s * (quat.vec.y * quat.vec.y + quat.vec.z * quat.vec.z), s * (quat.vec.x * quat.vec.y - quat.vec.z * quat.w), s * (quat.vec.x * quat.vec.z + quat.vec.y * quat.w), 0.0f,
		s * (quat.vec.x * quat.vec.y + quat.vec.z * quat.w), 1.0f - s * (quat.vec.x * quat.vec.x + quat.vec.z * quat.vec.z), s * (quat.vec.y * quat.vec.z - quat.vec.x * quat.w), 0.0f,
		s * (quat.vec.x * quat.vec.z - quat.vec.y * quat.w), s * (quat.vec.y * quat.vec.z + quat.vec.x * quat.w), 1.0f - s * (quat.vec.x * quat.vec.x + quat.vec.y * quat.vec.y), 0.0f,
		0.0f, 0.0f, 0.0f, 1.0f
	);
}

CGL_quat CGL_quat_slerp(CGL_quat q, CGL_quat r, CGL_float t)
{
	CGL_float cos_theta = q.w * r.w + q.vec.x * r.vec.x + q.vec.y * r.vec.y + q.vec.z * r.vec.z;
	CGL_float theta = acosf(cos_theta);
	CGL_float sin_theta = sinf(theta);
	CGL_float s0 = sinf((1.0f - t) * theta) / sin_theta;
	CGL_float s1 = sinf(t * theta) / sin_theta;
	CGL_quat result = CGL_quat_mul_scalar(q, s0);
	CGL_quat temp = CGL_quat_mul_scalar(r, s1);
	result = CGL_quat_add(result, temp);
	return result;
}

CGL_quat CGL_quat_squad(CGL_quat q0, CGL_quat q1, CGL_quat a0, CGL_quat a1, CGL_float t)
{
	CGL_quat qr0 = CGL_quat_slerp(q0, q1, t);
	CGL_quat qr1 = CGL_quat_slerp(a0, a1, t);
	return CGL_quat_slerp(qr0, qr1, 2.0f * t * (1.0f - t));
}

CGL_mat4 CGL_mat4_look_at(CGL_vec3 eye, CGL_vec3 target, CGL_vec3 up)
{
	CGL_vec3 z = CGL_vec3_sub(eye, target);
	CGL_vec3_normalize(z);
	CGL_vec3 x = CGL_vec3_cross(up, z);
	CGL_vec3_normalize(x);
	CGL_vec3 y = CGL_vec3_cross(z, x);
	CGL_vec3_normalize(y);
	CGL_mat4 mt = CGL_mat4_init(
		x.x, x.y, x.z, -CGL_vec3_dot(x, eye),
		y.x, y.y, y.z, -CGL_vec3_dot(y, eye),
		z.x, z.y, z.z, -CGL_vec3_dot(z, eye),
		0.0f, 0.0f, 0.0f, 1.0f
	);
	return (mt);
}

CGL_mat4 CGL_mat4_lerp(CGL_mat4 a, CGL_mat4 b, CGL_float t)
{
	CGL_mat4 result = CGL_mat4_identity();
	for (int i = 0; i < 16; i++) result.m[i] = a.m[i] * (1.0f - t) + b.m[i] * t;
	return result;
}

CGL_vec3 CGL_vec3_apply_transformations(CGL_vec3 original, const CGL_vec3* translation, const CGL_vec3* rotation, const CGL_vec3* scale)
{
	if (rotation)
	{
		original = CGL_vec3_rotate_x(original, rotation->x);
		original = CGL_vec3_rotate_y(original, rotation->y);
		original = CGL_vec3_rotate_z(original, rotation->z);
	}
	if (scale) original = CGL_vec3_mul(original, (*scale));
	if (translation) original = CGL_vec3_add(original, (*translation));
	return original;
}

CGL_vec2 CGL_vec2_apply_transformations(CGL_vec2 original, const CGL_vec2* translation, const CGL_float* rotation, const CGL_vec2* scale)
{
	CGL_vec2 zero = CGL_vec2_init(0.0f, 0.0f);
	if (rotation) original = CGL_vec2_rotate_about_point(original, zero, (*rotation));
	if (scale) original = CGL_vec2_mul(original, (*scale));
	if (translation) original = CGL_vec2_add(original, (*translation));
	return original;
}


CGL_vec4 CGL_quat_mul_vec4(CGL_quat q, CGL_vec4 v)
{
	(void)q;
	CGL_warn("CGL_quat_mul_vec4 is not implemented yet");
	return v;
}



#ifndef CGL_EXCLUDE_MATRIX_API

struct CGL_matrix
{
	CGL_MATRIX_DATA_TYPE* data;
	CGL_int m;
	CGL_int n;
};

CGL_matrix* CGL_matrix_create(CGL_int m, CGL_int n)
{
	if (m <= 0 || n <= 0) return NULL; // return null if the dimensions are invalid
	CGL_matrix* result = (CGL_matrix*)malloc(sizeof(CGL_matrix)); // allocate memory for the matrix
	if (!result) return NULL; // return null if the memory could not be allocated
	result->data = (CGL_MATRIX_DATA_TYPE*)malloc(sizeof(CGL_MATRIX_DATA_TYPE) * m * n); // allocate memory for the data
	if (!result->data) { CGL_free(result); return NULL; } // free the matrix and return null if the memory could not be allocated
	result->m = m; result->n = n; // set the dimensions
	return result; // return the matrix
}

CGL_void CGL_matrix_destroy(CGL_matrix* m)
{
	if (!m) return; // return if the matrix is null
	CGL_free(m->data); // free the data
	CGL_free(m); // free the matrix
}

CGL_matrix* CGL_matrix_create_from_array(CGL_MATRIX_DATA_TYPE* array, CGL_int m, CGL_int n)
{
	CGL_matrix* result = CGL_matrix_create(m, n); // create the matrix
	if (!result) return NULL; // return null if the matrix could not be created
	memcpy(result->data, array, sizeof(CGL_MATRIX_DATA_TYPE) * m * n); // copy the array into the matrix
	return result; // return the matrix
}

CGL_matrix* CGL_matrix_add_to(CGL_matrix* a, CGL_matrix* b, CGL_matrix* out)
{
	if (!a || !b || !out) return NULL; // return null if any of the matrices are null
	if (a->m != b->m || a->n != b->n || a->m != out->m || a->n != out->n) return NULL; // return null if the matrices are not the same size
	for (int i = 0; i < a->m * a->n; i++) out->data[i] = a->data[i] + b->data[i]; // add the matrices
	return out; // return the result matrix
}

CGL_matrix* CGL_matrix_add(CGL_matrix* a, CGL_matrix* b)
{
	if (!a || !b) return NULL; // return null if any of the matrices are null
	if (a->m != b->m || a->n != b->n) return NULL; // return null if the matrices are not the same size
	CGL_matrix* result = CGL_matrix_create(a->m, a->n); // create the result matrix
	if (!result) return NULL; // return null if the matrix could not be created
	for (int i = 0; i < a->m * a->n; i++) result->data[i] = a->data[i] + b->data[i]; // add the matrices
	// CGL_matrix_add_to(a, b, result); // add the matrices
	return result; // return the result matrix
}

CGL_matrix* CGL_matrix_sub_to(CGL_matrix* a, CGL_matrix* b, CGL_matrix* out)
{
	if (!a || !b || !out) return NULL; // return null if any of the matrices are null
	if (a->m != b->m || a->n != b->n || a->m != out->m || a->n != out->n) return NULL; // return null if the matrices are not the same size
	for (int i = 0; i < a->m * a->n; i++) out->data[i] = a->data[i] - b->data[i]; // subtract the matrices
	return out; // return the result matrix
}

CGL_matrix* CGL_matrix_sub(CGL_matrix* a, CGL_matrix* b)
{
	if (!a || !b) return NULL; // return null if any of the matrices are null
	if (a->m != b->m || a->n != b->n) return NULL; // return null if the matrices are not the same size
	CGL_matrix* result = CGL_matrix_create(a->m, a->n); // create the result matrix
	if (!result) return NULL; // return null if the matrix could not be created
	for (int i = 0; i < a->m * a->n; i++) result->data[i] = a->data[i] - b->data[i]; // subtract the matrices
	// CGL_matrix_sub_to(a, b, result); // subtract the matrices
	return result; // return the result matrix
}

CGL_matrix* CGL_matrix_elem_mul_to(CGL_matrix* a, CGL_matrix* b, CGL_matrix* out)
{
	if (!a || !b || !out) return NULL; // return null if any of the matrices are null
	if (a->m != b->m || a->n != b->n || a->m != out->m || a->n != out->n) return NULL; // return null if the matrices are not the same size
	for (int i = 0; i < a->m * a->n; i++) out->data[i] = a->data[i] * b->data[i]; // multiply the matrices
	return out; // return the result matrix
}

CGL_matrix* CGL_matrix_elem_mul(CGL_matrix* a, CGL_matrix* b)
{
	if (!a || !b) return NULL; // return null if any of the matrices are null
	if (a->m != b->m || a->n != b->n) return NULL; // return null if the matrices are not the same size
	CGL_matrix* result = CGL_matrix_create(a->m, a->n); // create the result matrix
	if (!result) return NULL; // return null if the matrix could not be created
	for (int i = 0; i < a->m * a->n; i++) result->data[i] = a->data[i] * b->data[i]; // multiply the matrices
	// CGL_matrix_elem_mul_to(a, b, result); // multiply the matrices
	return result; // return the result matrix
}

CGL_matrix* CGL_matrix_mul_to(CGL_matrix* a, CGL_matrix* b, CGL_matrix* out)
{
	if (!a || !b || !out) return NULL; // return null if any of the matrices are null
	if (a->n != b->m || a->m != out->m || b->n != out->n) return NULL; // return null if the matrices are not the correct size
	for (int i = 0; i < a->m; i++) // for each row in a
	{
		for (int j = 0; j < b->n; j++) // for each column in b
		{
			CGL_MATRIX_DATA_TYPE sum = 0; // set the sum to 0
			for (int k = 0; k < a->n; k++) // for each element in the row of a and column of b
				sum += a->data[i * a->n + k] * b->data[k * b->n + j]; // add the product of the elements to the sum
			out->data[i * out->n + j] = sum; // set the element in the result matrix to the sum
		}
	}
	return out; // return the result matrix
}

CGL_matrix* CGL_matrix_mul(CGL_matrix* a, CGL_matrix* b)
{
	if (!a || !b) return NULL; // return null if any of the matrices are null
	if (a->n != b->m) return NULL; // return null if the matrices are not the correct size
	CGL_matrix* result = CGL_matrix_create(a->m, b->n); // create the result matrix
	if (!result) return NULL; // return null if the matrix could not be created
	CGL_matrix_mul_to(a, b, result); // multiply the matrices
	return result; // return the result matrix
}

CGL_matrix* CGL_matrix_transpose_to(CGL_matrix* m, CGL_matrix* out)
{
	if (!m || !out) return NULL; // return null if any of the matrices are null
	if (m->m != out->n || m->n != out->m) return NULL; // return null if the matrices are not the correct size
	for (int i = 0; i < m->m; i++) // for each row in m
		for (int j = 0; j < m->n; j++) // for each column in m
			out->data[j * out->n + i] = m->data[i * m->n + j]; // set the element in the result matrix to the element in m transposed
	return out; // return the result matrix
}

CGL_matrix* CGL_matrix_transpose(CGL_matrix* m)
{
	if (!m) return NULL; // return null if the matrix is null
	CGL_matrix* result = CGL_matrix_create(m->n, m->m); // create the result matrix
	if (!result) return NULL; // return null if the matrix could not be created
	CGL_matrix_transpose_to(m, result); // transpose the matrix
	return result; // return the result matrix
}

CGL_matrix* CGL_matrix_identity_to(CGL_int m, CGL_int n, CGL_matrix* out)
{
	if (!out) return NULL; // return null if the matrix is null
	if (m != out->m || n != out->n) return NULL; // return null if the matrix is not the correct size
	for (int i = 0; i < m; i++) // for each row in the matrix
		for (int j = 0; j < n; j++) // for each column in the matrix
			out->data[i * out->n + j] = (i == j) ? 1.0f : 0.0f; // set the element to 1 if it is on the diagonal and 0 otherwise
	return out; // return the result matrix
}

CGL_matrix* CGL_matrix_identity(CGL_int m, CGL_int n)
{
	CGL_matrix* result = CGL_matrix_create(m, n); // create the result matrix
	if (!result) return NULL; // return null if the matrix could not be created
	CGL_matrix_identity_to(m, n, result); // set the matrix to the identity matrix
	return result; // return the result matrix
}

CGL_matrix* CGL_matrix_scale_to(CGL_matrix* m, CGL_MATRIX_DATA_TYPE s)
{
	if (!m) return NULL; // return null if the matrix is null
	for (int i = 0; i < m->m * m->n; i++) m->data[i] *= s; // scale the matrix
	return m; // return the result matrix
}

CGL_matrix* CGL_matrix_scale(CGL_matrix* m, CGL_MATRIX_DATA_TYPE s)
{
	if (!m) return NULL; // return null if the matrix is null
	CGL_matrix* result = CGL_matrix_create(m->m, m->n); // create the result matrix
	if (!result) return NULL; // return null if the matrix could not be created
	for (int i = 0; i < m->m * m->n; i++) result->data[i] = m->data[i] * s; // scale the matrix
	return result; // return the result matrix
}

CGL_MATRIX_DATA_TYPE CGL_matrix_get_elem(CGL_matrix* m, CGL_int i, CGL_int j)
{
	if (!m) return 0; // return 0 if the matrix is null
	if (i < 0 || i >= m->m || j < 0 || j >= m->n) return 0; // return 0 if the indices are out of bounds
	return m->data[i * m->n + j]; // return the element
}

CGL_bool CGL_matrix_set_elem(CGL_matrix* m, CGL_int i, CGL_int j, CGL_MATRIX_DATA_TYPE value)
{
	if (!m) return CGL_FALSE; // return false if the matrix is null
	if (i < 0 || i >= m->m || j < 0 || j >= m->n) return CGL_FALSE; // return false if the indices are out of bounds
	m->data[i * m->n + j] = value; // set the element
	return CGL_TRUE; // return true
}

CGL_bool CGL_matrix_set_row(CGL_matrix* m, CGL_int i, CGL_MATRIX_DATA_TYPE* row)
{
	if (!m || !row) return CGL_FALSE; // return false if any of the matrices are null
	if (i < 0 || i >= m->m) return CGL_FALSE; // return false if the index is out of bounds
	for (int j = 0; j < m->n; j++) m->data[i * m->n + j] = row[j]; // set the row
	return CGL_TRUE; // return true
}

CGL_bool CGL_matrix_set_col(CGL_matrix* m, CGL_int j, CGL_MATRIX_DATA_TYPE* col)
{
	if (!m || !col) return CGL_FALSE; // return false if any of the matrices are null
	if (j < 0 || j >= m->n) return CGL_FALSE; // return false if the index is out of bounds
	for (int i = 0; i < m->m; i++) m->data[i * m->n + j] = col[i]; // set the column
	return CGL_TRUE; // return true
}

CGL_bool CGL_matrix_get_row(CGL_matrix* m, CGL_int i, CGL_MATRIX_DATA_TYPE* out)
{
	if (!m || !out) return CGL_FALSE; // return false if any of the matrices are null
	if (i < 0 || i >= m->m) return CGL_FALSE; // return false if the index is out of bounds
	for (int j = 0; j < m->n; j++) out[j] = m->data[i * m->n + j]; // get the row
	return CGL_TRUE; // return true
}

CGL_bool CGL_matrix_get_col(CGL_matrix* m, CGL_int j, CGL_MATRIX_DATA_TYPE* out)
{
	if (!m || !out) return CGL_FALSE; // return false if any of the matrices are null
	if (j < 0 || j >= m->n) return CGL_FALSE; // return false if the index is out of bounds
	for (int i = 0; i < m->m; i++) out[i] = m->data[i * m->n + j]; // get the column
	return CGL_TRUE; // return true
}

CGL_matrix* CGL_matrix_row_to_matrix_to(CGL_MATRIX_DATA_TYPE* row, CGL_int n, CGL_matrix* out)
{
	if (!row || !out) return NULL; // return null if any of the matrices are null
	if (out->m != 1 || out->n != n) return NULL; // return null if the output matrix is not a row vector
	for (int i = 0; i < n; i++) out->data[i] = row[i]; // set the row
	return out; // return the result matrix
}

CGL_matrix* CGL_matrix_row_to_matrix(CGL_MATRIX_DATA_TYPE* row, CGL_int n)
{
	if (!row) return NULL; // return null if the matrix is null
	CGL_matrix* result = CGL_matrix_create(1, n); // create the result matrix
	if (!result) return NULL; // return null if the matrix could not be created
	for (int i = 0; i < n; i++) result->data[i] = row[i]; // set the row
	return result; // return the result matrix

}

CGL_matrix* CGL_matrix_col_to_matrix_to(CGL_MATRIX_DATA_TYPE* col, CGL_int n, CGL_matrix* out)
{
	if (!col || !out) return NULL; // return null if any of the matrices are null
	if (out->m != n || out->n != 1) return NULL; // return null if the output matrix is not a column vector
	for (int i = 0; i < n; i++) out->data[i] = col[i]; // set the column
	return out; // return the result matrix
}

CGL_matrix* CGL_matrix_col_to_matrix(CGL_MATRIX_DATA_TYPE* col, CGL_int n)
{
	if (!col) return NULL; // return null if the matrix is null
	CGL_matrix* result = CGL_matrix_create(n, 1); // create the result matrix
	if (!result) return NULL; // return null if the matrix could not be created
	for (int i = 0; i < n; i++) result->data[i] = col[i]; // set the column
	return result; // return the result matrix
}

CGL_bool CGL_matrix_is_square(CGL_matrix* m)
{
	if (!m) return CGL_FALSE; // return false if the matrix is null
	return m->m == m->n; // return true if the matrix is square
}

CGL_bool CGL_matrix_is_symmetric(CGL_matrix* m)
{
	if (!m) return CGL_FALSE; // return false if the matrix is null
	if (!CGL_matrix_is_square(m)) return CGL_FALSE; // return false if the matrix is not square
	for (int i = 0; i < m->m; i++) // iterate over the rows
		for (int j = 0; j < m->n; j++) // iterate over the columns
			if (m->data[i * m->n + j] != m->data[j * m->n + i]) return CGL_FALSE; // return false if the element is not symmetric
	return CGL_TRUE; // return true if the matrix is symmetric
}

CGL_bool CGL_matrix_is_orthogonal(CGL_matrix* m)
{
	if (!m) return CGL_FALSE; // return false if the matrix is null
	if (!CGL_matrix_is_square(m)) return CGL_FALSE; // return false if the matrix is not square
	CGL_matrix* mt = CGL_matrix_transpose(m); // get the transpose of the matrix
	if (!mt) return CGL_FALSE; // return false if the transpose could not be computed
	CGL_matrix* mt_m = CGL_matrix_mul(mt, m); // get the product of the transpose and the matrix
	if (!mt_m) return CGL_FALSE; // return false if the product could not be computed
	CGL_matrix* m_mt = CGL_matrix_mul(m, mt); // get the product of the matrix and the transpose
	if (!m_mt) return CGL_FALSE; // return false if the product could not be computed
	CGL_bool result = CGL_matrix_is_identity(mt_m) && CGL_matrix_is_identity(m_mt); // check if the products are the identity matrix
	CGL_matrix_destroy(mt); // destroy the transpose
	CGL_matrix_destroy(mt_m); // destroy the product of the transpose and the matrix
	CGL_matrix_destroy(m_mt); // destroy the product of the matrix and the transpose
	return result; // return the result
}

CGL_bool CGL_matrix_is_diagonal(CGL_matrix* m)
{
	if (!m) return CGL_FALSE; // return false if the matrix is null
	if (!CGL_matrix_is_square(m)) return CGL_FALSE; // return false if the matrix is not square
	for (int i = 0; i < m->m; i++) // iterate over the rows
		for (int j = 0; j < m->n; j++) // iterate over the columns
			if (i != j && m->data[i * m->n + j] != 0) return CGL_FALSE; // return false if the element is not on the diagonal
	return CGL_TRUE; // return true if the matrix is diagonal
}

CGL_bool CGL_matrix_is_identity(CGL_matrix* m)
{
	if (!m) return CGL_FALSE; // return false if the matrix is null
	if (!CGL_matrix_is_square(m)) return CGL_FALSE; // return false if the matrix is not square
	for (int i = 0; i < m->m; i++) // iterate over the rows
		for (int j = 0; j < m->n; j++) // iterate over the columns
			if (i == j && m->data[i * m->n + j] != 1) return CGL_FALSE; // return false if the element is not on the diagonal
			else if (i != j && m->data[i * m->n + j] != 0) return CGL_FALSE; // return false if the element is not on the diagonal
	return CGL_TRUE; // return true if the matrix is the identity matrix
}

CGL_bool CGL_matrix_is_zero(CGL_matrix* m)
{
	if (!m) return CGL_FALSE; // return false if the matrix is null
	for (int i = 0; i < m->m * m->n; i++) // iterate over the elements
		if (m->data[i] != 0) return CGL_FALSE; // return false if the element is not zero
	return CGL_TRUE; // return true if the matrix is zero
}

CGL_bool CGL_matrix_is_equal(CGL_matrix* a, CGL_matrix* b)
{
	if (!a || !b) return CGL_FALSE; // return false if either matrix is null
	if (a->m != b->m || a->n != b->n) return CGL_FALSE; // return false if the matrices are not the same size
	for (int i = 0; i < a->m * a->n; i++) // iterate over the elements
		if (a->data[i] != b->data[i]) return CGL_FALSE; // return false if the elements are not equal
	return CGL_TRUE; // return true if the matrices are equal
}

CGL_MATRIX_DATA_TYPE CGL_matrix_trace(CGL_matrix* m)
{
	if (!m) return 0; // return 0 if the matrix is null
	if (!CGL_matrix_is_square(m)) return 0; // return 0 if the matrix is not square
	CGL_MATRIX_DATA_TYPE trace = 0; // initialize the trace to 0
	for (int i = 0; i < m->m; i++) // iterate over the rows
		trace += m->data[i * m->n + i]; // add the element to the trace
	return trace; // return the trace
}

CGL_MATRIX_DATA_TYPE CGL_matrix_determinant(CGL_matrix* m)
{
	if (!m) return 0; // return 0 if the matrix is null
	if (!CGL_matrix_is_square(m)) return 0; // return 0 if the matrix is not square
	if (m->m == 1) return m->data[0]; // return the element if the matrix is 1x1
	if (m->m == 2) return m->data[0] * m->data[3] - m->data[1] * m->data[2]; // return the determinant if the matrix is 2x2
	CGL_MATRIX_DATA_TYPE det = 0; // initialize the determinant to 0
	for (int i = 0; i < m->n; i++) // iterate over the columns
	{
		CGL_matrix* sub = CGL_matrix_minor(m, 0, i); // get the submatrix
		if (!sub) return 0; // return 0 if the submatrix could not be computed
		det += m->data[i] * CGL_matrix_determinant(sub) * (i % 2 == 0 ? 1 : -1); // add the element to the determinant
		CGL_matrix_destroy(sub); // destroy the submatrix
	}
	return det; // return the determinant
}

CGL_matrix* CGL_matrix_inverse_to(CGL_matrix* m, CGL_matrix* out)
{
	if (!m || !out) return NULL; // return null if either matrix is null
	if (m->m != out->m || m->n != out->n) return NULL; // return null if the matrices are not the same size
	if (!CGL_matrix_is_square(m)) return NULL; // return null if the matrix is not square
	CGL_MATRIX_DATA_TYPE det = CGL_matrix_determinant(m); // get the determinant
	if (det == 0) return NULL; // return null if the determinant is 0
	CGL_matrix* adj = CGL_matrix_adjugate_to(m, out); // get the adjugate
	if (!adj) return NULL; // return null if the adjugate could not be computed
	return CGL_matrix_scale_to(adj, 1.0f / det); // scale the adjugate by the determinant
}

CGL_matrix* CGL_matrix_inverse(CGL_matrix* m)
{
	if (!m) return NULL; // return null if the matrix is null
	if (!CGL_matrix_is_square(m)) return NULL; // return null if the matrix is not square
	CGL_matrix* out = CGL_matrix_create(m->m, m->n); // initialize the output matrix
	if (!out) return NULL; // return null if the output matrix could not be initialized
	return CGL_matrix_inverse_to(m, out); // return the inverse of the matrix
}

CGL_matrix* CGL_matrix_copy_to(CGL_matrix* m, CGL_matrix* out)
{
	if (!m || !out) return CGL_FALSE; // return false if either matrix is null
	if (m->m != out->m || m->n != out->n) return CGL_FALSE; // return false if the matrices are not the same size
	for (int i = 0; i < m->m * m->n; i++) // iterate over the elements
		out->data[i] = m->data[i]; // copy the element
	return out; // return true if the copy was successful
}

CGL_matrix* CGL_matrix_copy(CGL_matrix* m)
{
	if (!m) return NULL; // return null if the matrix is null
	CGL_matrix* out = CGL_matrix_create(m->m, m->n); // initialize the output matrix
	if (!out) return NULL; // return null if the output matrix could not be initialized
	return (CGL_matrix_copy_to(m, out)); // return null if the copy was not successful
}

CGL_bool CGL_matrix_print(CGL_matrix* m)
{
	if (!m) return CGL_FALSE; // return false if the matrix is null
	for (int i = 0; i < m->m; i++) // iterate over the rows
	{
		for (int j = 0; j < m->n; j++) // iterate over the columns
			printf("%f ", m->data[i * m->n + j]); // print the element
		printf("\n"); // print a new line
	}
	return CGL_TRUE; // return true if the print was successful
}

CGL_matrix* CGL_matrix_gauss_jordan_to(CGL_matrix* m, CGL_matrix* out)
{
	if (!m || !out) return NULL; // return null if either matrix is null
	if (m->m != out->m || m->n != out->n) return NULL; // return null if the matrices are not the same size
	if (!CGL_matrix_copy_to(m, out)) return NULL; // return null if the copy was not successful
	for (int i = 0; i < out->m; i++) // iterate over the rows
	{
		CGL_MATRIX_DATA_TYPE pivot = out->data[i * out->n + i]; // get the pivot element
		if (pivot == 0) return NULL; // return null if the pivot element is zero
		for (int j = 0; j < out->n; j++) // iterate over the columns
			out->data[i * out->n + j] /= pivot; // divide the element by the pivot
		for (int j = 0; j < out->m; j++) // iterate over the rows
		{
			if (j == i) continue; // skip the pivot row
			CGL_MATRIX_DATA_TYPE factor = out->data[j * out->n + i]; // get the factor
			for (int k = 0; k < out->n; k++) // iterate over the columns
				out->data[j * out->n + k] -= factor * out->data[i * out->n + k]; // subtract the factor times the pivot row from the row
		}
	}
	return out; // return the output matrix
}

CGL_matrix* CGL_matrix_gauss_jordan(CGL_matrix* m)
{
	if (!m) return NULL; // return null if the matrix is null
	CGL_matrix* out = CGL_matrix_create(m->m, m->n); // initialize the output matrix
	if (!out) return NULL; // return null if the output matrix could not be initialized
	if (!CGL_matrix_gauss_jordan_to(m, out)) return NULL; // return null if the gauss-jordan elimination was not successful
	return out; // return the output matrix
}

CGL_matrix* CGL_matrix_submatrix_to(CGL_matrix* mat, CGL_int i, CGL_int j, CGL_int m, CGL_int n, CGL_matrix* out)
{
	if (!mat || !out) return NULL; // return null if either matrix is null
	if (i < 0 || j < 0 || i + m > mat->m || j + n > mat->n) return NULL; // return null if the submatrix is out of bounds
	if (m != out->m || n != out->n) return NULL; // return null if the matrices are not the same size
	for (int k = 0; k < m; k++) // iterate over the rows
		for (int l = 0; l < n; l++) // iterate over the columns
			out->data[k * out->n + l] = mat->data[(i + k) * mat->n + j + l]; // copy the element
	return out; // return the output matrix
}

CGL_matrix* CGL_matrix_submatrix(CGL_matrix* mat, CGL_int i, CGL_int j, CGL_int m, CGL_int n)
{
	if (!m) return NULL; // return null if the matrix is null
	CGL_matrix* out = CGL_matrix_create(m, n); // initialize the output matrix
	if (!out) return NULL; // return null if the output matrix could not be initialized
	return (CGL_matrix_submatrix_to(mat, i, j, m, n, out)); // return null if the submatrix was not successful
}

CGL_matrix* CGL_matrix_minor_to(CGL_matrix* m, CGL_int a, CGL_int b, CGL_matrix* out)
{
	if (!m || !out) return NULL; // return null if either matrix is null
	// if(m->m != m->n || out->m != out->n) return NULL; // return null if the matrices are not square
	if (a < 0 || b < 0 || a >= m->m || b >= m->n) return NULL; // return null if the minor is out of bounds
	if (m->m != out->m + 1 && m->n != out->n + 1) return NULL; // return null if the matrices are not the correct size
	for (int i = 0, k = 0; i < m->m; i++) // iterate over the rows
	{
		if (i == a) continue; // skip the element
		for (int j = 0, l = 0; j < m->n; j++) // iterate over the columns
		{
			if (j == b) continue; // skip the element
			out->data[k * out->n + l] = m->data[i * m->n + j]; // copy the element
			l++; // increment the column
		}
		k++; // increment the row
	}
	return out; // return the output matrix
}

CGL_matrix* CGL_matrix_minor(CGL_matrix* m, CGL_int i, CGL_int j)
{
	if (!m) return NULL; // return null if the matrix is null
	CGL_matrix* out = CGL_matrix_create(m->m - 1, m->n - 1); // initialize the output matrix
	if (!out) return NULL; // return null if the output matrix could not be initialized
	return (CGL_matrix_minor_to(m, i, j, out)); // return null if the minor was not successful
}

CGL_matrix* CGL_matrix_adjugate_to(CGL_matrix* m, CGL_matrix* out)
{
	if (!m || !out) return NULL; // return null if either matrix is null
	if (m->m != m->n || out->m != out->n) return NULL; // return null if the matrices are not square
	if (m->m != out->m) return NULL; // return null if the matrices are not the same size
	for (int i = 0; i < m->m; i++) // iterate over the rows
		for (int j = 0; j < m->n; j++) // iterate over the columns
		{
			CGL_matrix* minor = CGL_matrix_minor(m, i, j); // get the minor
			if (!minor) return NULL; // return null if the minor could not be created
			CGL_MATRIX_DATA_TYPE det = CGL_matrix_determinant(minor); // get the determinant of the minor
			CGL_matrix_destroy(minor); // free the minor
			out->data[j * out->n + i] = ((i + j) % 2 == 0 ? det : -det); // set the element
		}
	return out; // return the output matrix
}

CGL_matrix* CGL_matrix_adjugate(CGL_matrix* m)
{
	if (!m) return NULL; // return null if the matrix is null
	CGL_matrix* out = CGL_matrix_create(m->m, m->n); // initialize the output matrix
	if (!out) return NULL; // return null if the output matrix could not be initialized
	return (CGL_matrix_adjugate_to(m, out)); // return null if the adjugate was not successful
}

CGL_matrix* CGL_matrix_transpose_inplace(CGL_matrix* m)
{
	if (!m) return NULL; // return null if the matrix is null
	for (int i = 0; i < m->m; i++) // iterate over the rows
		for (int j = 0; j < m->n; j++) // iterate over the columns
		{
			if (i >= j) continue; // skip the element
			CGL_MATRIX_DATA_TYPE temp = m->data[i * m->n + j]; // store the element
			m->data[i * m->n + j] = m->data[j * m->n + i]; // swap the elements
			m->data[j * m->n + i] = temp; // swap the elements
		}
	return m; // return the matrix
}

CGL_float CGL_matrix_sum_of_row(CGL_matrix* m, CGL_int i)
{
	if (!m) return 0; // return 0 if the matrix is null
	if (i < 0 || i >= m->m) return 0; // return 0 if the row is out of bounds
	CGL_float sum = 0; // initialize the sum
	for (int j = 0; j < m->n; j++) // iterate over the columns
		sum += m->data[i * m->n + j]; // add the element
	return sum; // return the sum
}

CGL_float CGL_matrix_sum_of_col(CGL_matrix* m, CGL_int j)
{
	if (!m) return 0; // return 0 if the matrix is null
	if (j < 0 || j >= m->n) return 0; // return 0 if the column is out of bounds
	CGL_float sum = 0; // initialize the sum
	for (int i = 0; i < m->m; i++) // iterate over the rows
		sum += m->data[i * m->n + j]; // add the element
	return sum; // return the sum
}

CGL_float CGL_matrix_product_of_row(CGL_matrix* m, CGL_int i)
{
	if (!m) return 0; // return 0 if the matrix is null
	if (i < 0 || i >= m->m) return 0; // return 0 if the row is out of bounds
	CGL_float product = 1; // initialize the product
	for (int j = 0; j < m->n; j++) // iterate over the columns
		product *= m->data[i * m->n + j]; // multiply the element
	return product; // return the product
}

CGL_float CGL_matrix_product_of_col(CGL_matrix* m, CGL_int j)
{
	if (!m) return 0; // return 0 if the matrix is null
	if (j < 0 || j >= m->n) return 0; // return 0 if the column is out of bounds
	CGL_float product = 1; // initialize the product
	for (int i = 0; i < m->m; i++) // iterate over the rows
		product *= m->data[i * m->n + j]; // multiply the element
	return product; // return the product
}

CGL_matrix* CGL_matrix_make_zero(CGL_matrix* m)
{
	if (!m) return NULL; // return null if the matrix is null
	for (int i = 0; i < m->m * m->n; i++) m->data[i] = 0; // set the element to 0
	return m; // return the matrix
}

#endif


#ifndef CGL_EXCLUDE_MATH_FUNCTIONS
// vec2 
CGL_vec2 CGL_vec2_add_(CGL_vec2 a, CGL_vec2 b)
{
	return CGL_vec2_init(a.x + b.x, a.y + b.y);
}

CGL_vec2 CGL_vec2_sub_(CGL_vec2 a, CGL_vec2 b)
{
	return CGL_vec2_init(a.x - b.x, a.y - b.y);
}

CGL_vec2 CGL_vec2_mul_(CGL_vec2 a, CGL_vec2 b)
{
	return CGL_vec2_init(a.x * b.x, a.y * b.y);
}

CGL_vec2 CGL_vec2_div_(CGL_vec2 a, CGL_vec2 b)
{
	return CGL_vec2_init(a.x / b.x, a.y / b.y);
}

CGL_vec2 CGL_vec2_add_scalar_(CGL_vec2 a, CGL_float b)
{
	return CGL_vec2_init(a.x + b, a.y + b);
}

CGL_vec2 CGL_vec2_sub_scalar_(CGL_vec2 a, CGL_float b)
{
	return CGL_vec2_init(a.x - b, a.y - b);
}

CGL_vec2 CGL_vec2_scale_(CGL_vec2 a, CGL_float b)
{
	return CGL_vec2_init(a.x * b, a.y * b);
}

CGL_vec2 CGL_vec2_normalize_(CGL_vec2 a)
{
	CGL_float length = CGL_vec2_length_(a);
	return CGL_vec2_init(a.x / length, a.y / length);
}

CGL_float CGL_vec2_dot_(CGL_vec2 a, CGL_vec2 b)
{
	return a.x * b.x + a.y * b.y;
}

CGL_float CGL_vec2_length_(CGL_vec2 a)
{
	return sqrtf(CGL_vec2_dot_(a, a));
}

CGL_float CGL_vec2_cross_(CGL_vec2 a, CGL_vec2 b)
{
	return a.x * b.y - a.y * b.x;
}

CGL_vec2 CGL_vec2_reflect_(CGL_vec2 a, CGL_vec2 b)
{
	CGL_float dot = CGL_vec2_dot_(a, b);
	return CGL_vec2_init(a.x - 2.0f * dot * b.x, a.y - 2.0f * dot * b.y);
}

CGL_vec2 CGL_vec2_refract_(CGL_vec2 a, CGL_vec2 b, CGL_float eta)
{
	CGL_float dot = CGL_vec2_dot_(a, b);
	CGL_float k = 1.0f - eta * eta * (1.0f - dot * dot);
	if (k < 0.0f) return CGL_vec2_init(0.0f, 0.0f);
	return CGL_vec2_init(eta * a.x - (eta * dot + sqrtf(k)) * b.x, eta * a.y - (eta * dot + sqrtf(k)) * b.y);
}

CGL_vec2 CGL_vec2_rotate_(CGL_vec2 a, CGL_float angle)
{
	CGL_float s = sinf(angle);
	CGL_float c = cosf(angle);
	return CGL_vec2_init(a.x * c - a.y * s, a.x * s + a.y * c);
}

CGL_vec2 CGL_vec2_lerp_(CGL_vec2 a, CGL_vec2 b, CGL_float t)
{
	return CGL_vec2_init(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y));
}

// vec3
CGL_vec3 CGL_vec3_add_(CGL_vec3 a, CGL_vec3 b)
{
	return CGL_vec3_init(a.x + b.x, a.y + b.y, a.z + b.z);
}

CGL_vec3 CGL_vec3_add3_(CGL_vec3 a, CGL_vec3 b, CGL_vec3 c)
{
	return CGL_vec3_init(a.x + b.x + c.x, a.y + b.y + c.y, a.z + b.z + c.z);
}

CGL_vec3 CGL_vec3_sub_(CGL_vec3 a, CGL_vec3 b)
{
	return CGL_vec3_init(a.x - b.x, a.y - b.y, a.z - b.z);
}

CGL_vec3 CGL_vec3_mul_(CGL_vec3 a, CGL_vec3 b)
{
	return CGL_vec3_init(a.x * b.x, a.y * b.y, a.z * b.z);
}

CGL_vec3 CGL_vec3_div_(CGL_vec3 a, CGL_vec3 b)
{
	return CGL_vec3_init(a.x / b.x, a.y / b.y, a.z / b.z);
}

CGL_vec3 CGL_vec3_add_scalar_(CGL_vec3 a, CGL_float b)
{
	return CGL_vec3_init(a.x + b, a.y + b, a.z + b);
}

CGL_vec3 CGL_vec3_sub_scalar_(CGL_vec3 a, CGL_float b)
{
	return CGL_vec3_init(a.x - b, a.y - b, a.z - b);
}

CGL_vec3 CGL_vec3_scale_(CGL_vec3 a, CGL_float b)
{
	return CGL_vec3_init(a.x * b, a.y * b, a.z * b);
}

CGL_vec3 CGL_vec3_normalize_(CGL_vec3 a)
{
	CGL_float length = CGL_vec3_length_(a);
	return CGL_vec3_init(a.x / length, a.y / length, a.z / length);
}

CGL_float CGL_vec3_dot_(CGL_vec3 a, CGL_vec3 b)
{
	return a.x * b.x + a.y * b.y + a.z * b.z;
}

CGL_float CGL_vec3_length_(CGL_vec3 a)
{
	return sqrtf(CGL_vec3_dot_(a, a));
}

CGL_vec3 CGL_vec3_cross_(CGL_vec3 a, CGL_vec3 b)
{
	return CGL_vec3_init(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
}

CGL_vec3 CGL_vec3_reflect_(CGL_vec3 a, CGL_vec3 b)
{
	CGL_float dot = CGL_vec3_dot_(a, b);
	return CGL_vec3_init(a.x - 2.0f * dot * b.x, a.y - 2.0f * dot * b.y, a.z - 2.0f * dot * b.z);
}

CGL_vec3 CGL_vec3_refract_(CGL_vec3 a, CGL_vec3 b, CGL_float eta)
{
	CGL_float dot = CGL_vec3_dot_(a, b);
	CGL_float k = 1.0f - eta * eta * (1.0f - dot * dot);
	if (k < 0.0f) return CGL_vec3_init(0.0f, 0.0f, 0.0f);
	return CGL_vec3_init(eta * a.x - (eta * dot + sqrtf(k)) * b.x, eta * a.y - (eta * dot + sqrtf(k)) * b.y, eta * a.z - (eta * dot + sqrtf(k)) * b.z);
}

CGL_vec3 CGL_vec3_lerp_(CGL_vec3 a, CGL_vec3 b, CGL_float t)
{
	return CGL_vec3_init(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y), a.z + t * (b.z - a.z));
}

// vec4
CGL_vec4 CGL_vec4_add_(CGL_vec4 a, CGL_vec4 b)
{
	return CGL_vec4_init(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
}

CGL_vec4 CGL_vec4_sub_(CGL_vec4 a, CGL_vec4 b)
{
	return CGL_vec4_init(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
}

CGL_vec4 CGL_vec4_mul_(CGL_vec4 a, CGL_vec4 b)
{
	return CGL_vec4_init(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);
}

CGL_vec4 CGL_vec4_div_(CGL_vec4 a, CGL_vec4 b)
{
	return CGL_vec4_init(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);
}

CGL_vec4 CGL_vec4_add_scalar_(CGL_vec4 a, CGL_float b)
{
	return CGL_vec4_init(a.x + b, a.y + b, a.z + b, a.w + b);
}

CGL_vec4 CGL_vec4_sub_scalar_(CGL_vec4 a, CGL_float b)
{
	return CGL_vec4_init(a.x - b, a.y - b, a.z - b, a.w - b);
}

CGL_vec4 CGL_vec4_scale_(CGL_vec4 a, CGL_float b)
{
	return CGL_vec4_init(a.x * b, a.y * b, a.z * b, a.w * b);
}

CGL_vec4 CGL_vec4_normalize_(CGL_vec4 a)
{
	CGL_float length = CGL_vec4_length_(a);
	return CGL_vec4_init(a.x / length, a.y / length, a.z / length, a.w / length);
}

CGL_float CGL_vec4_dot_(CGL_vec4 a, CGL_vec4 b)
{
	return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
}

CGL_float CGL_vec4_length_(CGL_vec4 a)
{
	return sqrtf(CGL_vec4_dot_(a, a));
}

CGL_vec4 CGL_vec4_lerp_(CGL_vec4 a, CGL_vec4 b, CGL_float t)
{
	return CGL_vec4_init(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y), a.z + t * (b.z - a.z), a.w + t * (b.w - a.w));
}

#endif


struct CGL_context
{
	bool is_initialized;
	CGL_int window_count;
#ifndef CGL_EXCLUDE_WINDOW_API 
	CGL_window* window_table[CGL_WINDOW_TABLE_SIZE];
#endif
};

CGL_context* __CGL_context = NULL;

bool CGL_init()
{
	if (__CGL_context != NULL) return true;
	__CGL_context = (CGL_context*)malloc(sizeof(CGL_context));
	if (__CGL_context == NULL) return false;
	__CGL_context->is_initialized = true;
	__CGL_context->window_count = 0;
	CGL_logger_init(CGL_ENABLE_CONSOLE_LOGGING);
	return true;
}

CGL_void CGL_shutdown()
{
	if (__CGL_context == NULL) return;
	free(__CGL_context);
	__CGL_context = NULL;
	CGL_logger_shutdown();
}

#endif


#if 1 // just to use code folding in ide

#if defined(_WIN32) || defined(_WIN64)
#else
#include <sys/stat.h>
#include <sys/types.h>
#endif


CGL_sizei CGL_utils_get_file_size(const CGL_byte* path)
{
#if defined(_WIN32) || defined(_WIN64)
	HANDLE file = CreateFile(path, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (file == INVALID_HANDLE_VALUE) return 0;
	LARGE_INTEGER size;
	if (GetFileSizeEx(file, &size) == 0) return 0;
	CloseHandle(file);
	return size.QuadPart;
#else
	struct stat st;
	if (stat(path, &st) == 0) return st.st_size;
	return -1;
#endif
}

CGL_void CGL_utils_sleep(const CGL_sizei milis)
{
#if defined(_WIN32) || defined(_WIN64)
	Sleep((DWORD)milis);
#else
	usleep(milis * 1000);
#endif
}

// read file into memory
CGL_byte* CGL_utils_read_file(const CGL_byte* path, size_t* size_ptr)
{
#if defined(_WIN32) || defined(_WIN64)
	HANDLE file = CreateFile(path, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (file == INVALID_HANDLE_VALUE) return NULL;
	LARGE_INTEGER size;
	if (GetFileSizeEx(file, &size) == 0) return NULL;
	CGL_byte* data = (CGL_byte*)malloc(size.QuadPart + 1);
	if (data == NULL) return NULL;
	DWORD read = 0;
	if (ReadFile(file, data, (DWORD)size.QuadPart, &read, NULL) == 0) return NULL;
	CloseHandle(file);
	data[size.QuadPart] = 0;
	if (size_ptr != NULL) *size_ptr = size.QuadPart;
	return data;
#else
	struct stat st;
	if (stat(path, &st) != 0) return NULL;
	if (size_ptr != NULL) *size_ptr = st.st_size;
	CGL_byte* data = (CGL_byte*)malloc(st.st_size + 1);
	data[st.st_size] = 0;
	if (data == NULL) return NULL;
	FILE* file = fopen(path, "r");
	if (file == NULL) return NULL;
	if ((CGL_sizei)fread(data, 1, st.st_size, file) != (CGL_sizei)st.st_size)
	{
		CGL_log_internal("failed to read file: %s", path);
	}
	fclose(file);
	return data;
#endif
}

const CGL_byte* CGL_utils_get_executable_path()
{
	static CGL_byte buffer[2048];
#if defined(_WIN32) || defined(_WIN64)
	GetModuleFileName(NULL, buffer, 2048);
#else
	ssize_t len = readlink("/proc/self/exe", buffer, 2048);
	if (len == -1) return NULL;
	buffer[len] = 0;
#endif
	return buffer;
}

const CGL_byte* CGL_utils_get_executable_directory()
{
	static CGL_byte buffer[2048];

	const CGL_byte* path = CGL_utils_get_executable_path();

	if (path == NULL) return NULL;

	CGL_int i = (CGL_int)(strlen(path) - 1);
	while (i >= 0 && path[i] != '/' && path[i] != '\\') i--;

	if (i < 0) return NULL;

	memcpy(buffer, path, i + 1);
	buffer[i + 1] = 0;

	return buffer;
}



// write data to file
bool CGL_utils_write_file(const char* path, const char* data, size_t size)
{
	FILE* file = fopen(path, "w");
	if (file == NULL)
		return false;
	fwrite(data, 1, size, file);
	fclose(file);
	return true;
}

bool CGL_utils_append_file(const char* path, const char* data, size_t size)
{
	FILE* file = fopen(path, "a");
	if (file == NULL)
		return false;
	fwrite(data, 1, size, file);
	fclose(file);
	return true;
}


#ifndef CGL_EXCLUDE_WINDOW_API

#ifndef CGL_EXPOSE_GLFW_API
#include <GLFW/glfw3.h> // GLFW
#endif

struct CGL_window
{
	GLFWwindow* handle;
	bool is_hidden;
	void* user_data;
	// callbacks
	CGL_window_key_callback key_callback;
	CGL_window_mouse_button_callback mouse_button_callback;
	CGL_window_mouse_position_callback mouse_position_callback;
	CGL_window_mouse_scroll_callback mouse_scroll_callback;
	CGL_window_framebuffer_size_callback framebuffer_size_callback;
	CGL_window_close_callback close_callback;
	CGL_window_drag_n_drop_callback drag_n_drop_callback;

	GLFWkeyfun previous_key_callback;
	GLFWmousebuttonfun previous_mouse_button_callback;
	GLFWcursorposfun previous_mouse_position_callback;
	GLFWscrollfun previous_mouse_scroll_callback;
	GLFWframebuffersizefun previous_framebuffer_size_callback;
	GLFWwindowclosefun previous_close_callback;
	GLFWdropfun previous_drag_n_drop_callback;
};

// callbacks
CGL_void __CGL_window_key_callback(GLFWwindow* window, CGL_int key, CGL_int scancode, CGL_int action, CGL_int mods)
{
	// CGL_window* cgl_window = (CGL_window*)glfwGetWindowUserPointer(window);
	CGL_window* cgl_window = __CGL_context->window_table[(uintptr_t)window % CGL_WINDOW_TABLE_SIZE];
	if (cgl_window->key_callback != NULL)
		cgl_window->key_callback(cgl_window, key, scancode, action, mods);
	if (cgl_window->previous_key_callback)
		cgl_window->previous_key_callback(window, key, scancode, action, mods);
}

CGL_void __CGL_window_mouse_button_callback(GLFWwindow* window, CGL_int button, CGL_int action, CGL_int mods)
{
	// CGL_window* cgl_window = (CGL_window*)glfwGetWindowUserPointer(window);
	CGL_window* cgl_window = __CGL_context->window_table[(uintptr_t)window % CGL_WINDOW_TABLE_SIZE];
	if (cgl_window->mouse_button_callback != NULL)
		cgl_window->mouse_button_callback(cgl_window, button, action, mods);
	if (cgl_window->previous_mouse_button_callback)
		cgl_window->previous_mouse_button_callback(window, button, action, mods);
}

CGL_void __CGL_window_mouse_position_callback(GLFWwindow* window, double xpos, double ypos)
{
	// CGL_window* cgl_window = (CGL_window*)glfwGetWindowUserPointer(window);
	CGL_window* cgl_window = __CGL_context->window_table[(uintptr_t)window % CGL_WINDOW_TABLE_SIZE];
	if (cgl_window->mouse_position_callback != NULL)
		cgl_window->mouse_position_callback(cgl_window, xpos, ypos);
	if (cgl_window->previous_mouse_position_callback)
		cgl_window->previous_mouse_position_callback(window, xpos, ypos);
}

CGL_void __CGL_window_mouse_scroll_callback(GLFWwindow* window, double xoffset, double yoffset)
{
	// CGL_window* cgl_window = (CGL_window*)glfwGetWindowUserPointer(window);
	CGL_window* cgl_window = __CGL_context->window_table[(uintptr_t)window % CGL_WINDOW_TABLE_SIZE];
	if (cgl_window->mouse_scroll_callback != NULL)
		cgl_window->mouse_scroll_callback(cgl_window, xoffset, yoffset);
	if (cgl_window->previous_mouse_scroll_callback)
		cgl_window->previous_mouse_scroll_callback(window, xoffset, yoffset);
}

CGL_void __CGL_window_framebuffer_size_callback(GLFWwindow* window, CGL_int width, CGL_int height)
{
	// CGL_window* cgl_window = (CGL_window*)glfwGetWindowUserPointer(window);
	CGL_window* cgl_window = __CGL_context->window_table[(uintptr_t)window % CGL_WINDOW_TABLE_SIZE];
	if (cgl_window->framebuffer_size_callback != NULL)
		cgl_window->framebuffer_size_callback(cgl_window, width, height);
	if (cgl_window->previous_framebuffer_size_callback)
		cgl_window->previous_framebuffer_size_callback(window, width, height);
}

CGL_void __CGL_window_close_callback(GLFWwindow* window)
{
	// CGL_window* cgl_window = (CGL_window*)glfwGetWindowUserPointer(window);
	CGL_window* cgl_window = __CGL_context->window_table[(uintptr_t)window % CGL_WINDOW_TABLE_SIZE];
	if (cgl_window->close_callback)
		cgl_window->close_callback(cgl_window);
	if (cgl_window->previous_close_callback)
		cgl_window->previous_close_callback(window);
}

CGL_void  __CGL_window_drag_n_drop_callback(GLFWwindow* window, CGL_int count, const char** paths)
{
	CGL_window* cgl_window = __CGL_context->window_table[(uintptr_t)window % CGL_WINDOW_TABLE_SIZE];
	if (cgl_window->drag_n_drop_callback)
		cgl_window->drag_n_drop_callback(cgl_window, paths, count);
	if (cgl_window->previous_drag_n_drop_callback)
		cgl_window->previous_drag_n_drop_callback(window, count, paths);
}

// create window
static CGL_window* __CGL_window_create(CGL_int width, CGL_int height, const char* title, bool undecorated)
{
	if (__CGL_context->window_count == 0)
	{
		if (!glfwInit())
		{
			CGL_log_internal("Failed to initialize GLFW\n");
			return false;
		}
	}
#ifdef CGL_WASM
	glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_ES_API);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);

	//    glfwWindowHint(GLFW_CONTEXT_CREATION_API, GLFW_CONTEXT_API);
#else
	// tell glfw we are going to use opengl api
	glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_API);
	// tell glfw to initialize opengl context for opengl version 4.3 (latest)
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
#endif
	glfwWindowHint(GLFW_DECORATED, undecorated);
	// tell glfw to use the opengl core profile and not the compatibility profile
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
	glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
	// disabling resinfg gets rid of managing things like aspect ration and stuff
	glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE);
	CGL_window* window = (CGL_window*)malloc(sizeof(CGL_window));
	if (window == NULL)
	{
		CGL_log_internal("Failed to allocate memory for window\n");
		return NULL;
	}
	window->handle = glfwCreateWindow(width, height, title, NULL, NULL);
	if (window->handle == NULL)
	{
		CGL_log_internal("Failed to create GLFW window\n");
		return false;
	}
	glfwSwapInterval(1); // vsync
	window->is_hidden = true;
	window->key_callback = NULL;
	window->mouse_button_callback = NULL;
	window->mouse_position_callback = NULL;
	window->mouse_scroll_callback = NULL;
	window->framebuffer_size_callback = NULL;
	window->close_callback = NULL;
	window->drag_n_drop_callback = NULL;
	window->user_data = NULL;
	window->previous_close_callback = NULL;
	window->previous_framebuffer_size_callback = NULL;
	window->previous_key_callback = NULL;
	window->previous_mouse_button_callback = NULL;
	window->previous_mouse_position_callback = NULL;
	window->previous_mouse_scroll_callback = NULL;
	window->previous_drag_n_drop_callback = NULL;
	__CGL_context->window_table[(uintptr_t)window->handle % CGL_WINDOW_TABLE_SIZE] = window; // Temporary
	__CGL_context->window_count++;
	return window;
}

CGL_window* CGL_window_create(CGL_int width, CGL_int height, const char* title)
{
	return __CGL_window_create(width, height, title, true);
}

CGL_window* CGL_window_create_undecorated(CGL_int width, CGL_int height, const char* title)
{
	return __CGL_window_create(width, height, title, false);
}


// destroy window
CGL_void CGL_window_destroy(CGL_window* window)
{
	glfwDestroyWindow(window->handle);
	free(window);
	__CGL_context->window_count--;
	if (__CGL_context->window_count == 0)
	{
		glfwTerminate();
	}
}

// poll events
CGL_void CGL_window_poll_events(CGL_window* window)
{
	(void)window;
	glfwPollEvents();
}

// swap buffers
CGL_void CGL_window_swap_buffers(CGL_window* window)
{
	glfwSwapBuffers(window->handle);
}

// check if window should close
bool CGL_window_should_close(CGL_window* window)
{
	return glfwWindowShouldClose(window->handle);
}

// set window title
CGL_void CGL_window_set_title(CGL_window* window, const char* title)
{
	glfwSetWindowTitle(window->handle, title);
}

// set window size
CGL_void CGL_window_set_size(CGL_window* window, CGL_int width, CGL_int height)
{
	glfwSetWindowSize(window->handle, width, height);
}

// set window position
CGL_void CGL_window_set_position(CGL_window* window, CGL_int x, CGL_int y)
{
	glfwSetWindowPos(window->handle, x, y);
}

// set window hidden
CGL_void CGL_window_set_hidden(CGL_window* window, bool hidden)
{
	if (hidden)
		glfwHideWindow(window->handle);
	else
		glfwShowWindow(window->handle);
	window->is_hidden = hidden;
}

// set window user data
CGL_void CGL_window_set_user_data(CGL_window* window, void* user_data)
{
	window->user_data = user_data;
}

// get window user data
CGL_void* CGL_window_get_user_data(CGL_window* window)
{
	return window->user_data;
}

// get window size
CGL_void CGL_window_get_size(CGL_window* window, CGL_int* width, CGL_int* height)
{
	glfwGetWindowSize(window->handle, width, height);
}

// get window position
CGL_void CGL_window_get_position(CGL_window* window, CGL_int* x, CGL_int* y)
{
	glfwGetWindowPos(window->handle, x, y);
}

// get window framebuffer size
CGL_void CGL_window_get_framebuffer_size(CGL_window* window, CGL_int* width, CGL_int* height)
{
	glfwGetFramebufferSize(window->handle, width, height);
}

// set key callback
CGL_void CGL_window_set_key_callback(CGL_window* window, CGL_window_key_callback callback)
{
	if (window->key_callback == NULL)
		window->previous_key_callback = glfwSetKeyCallback(window->handle, __CGL_window_key_callback);
	window->key_callback = callback;
}

// set mouse button callback
CGL_void CGL_window_set_mouse_button_callback(CGL_window* window, CGL_window_mouse_button_callback callback)
{
	if (window->mouse_button_callback == NULL)
		window->previous_mouse_button_callback = glfwSetMouseButtonCallback(window->handle, __CGL_window_mouse_button_callback);
	window->mouse_button_callback = callback;
}

// set mouse position callback
CGL_void CGL_window_set_mouse_position_callback(CGL_window* window, CGL_window_mouse_position_callback callback)
{
	if (window->mouse_position_callback == NULL)
		window->previous_mouse_position_callback = glfwSetCursorPosCallback(window->handle, __CGL_window_mouse_position_callback);
	window->mouse_position_callback = callback;
}

// set mouse scroll callback
CGL_void CGL_window_set_mouse_scroll_callback(CGL_window* window, CGL_window_mouse_scroll_callback callback)
{
	if (window->mouse_scroll_callback == NULL)
		window->previous_mouse_scroll_callback = glfwSetScrollCallback(window->handle, __CGL_window_mouse_scroll_callback);
	window->mouse_scroll_callback = callback;
}

// set framebuffer size callback
CGL_void CGL_window_set_framebuffer_size_callback(CGL_window* window, CGL_window_framebuffer_size_callback callback)
{
	if (window->framebuffer_size_callback == NULL)
		window->previous_framebuffer_size_callback = glfwSetFramebufferSizeCallback(window->handle, __CGL_window_framebuffer_size_callback);
	window->framebuffer_size_callback = callback;
}

// set close callback
CGL_void CGL_window_set_close_callback(CGL_window* window, CGL_window_close_callback callback)
{
	if (window->close_callback == NULL)
		window->previous_close_callback = glfwSetWindowCloseCallback(window->handle, __CGL_window_close_callback);
	window->close_callback = callback;
}

CGL_void CGL_window_set_drag_n_drop_callback(CGL_window* window, CGL_window_drag_n_drop_callback callback) // set drag and drop callback
{
	if (window->drag_n_drop_callback == NULL)
		window->previous_drag_n_drop_callback = glfwSetDropCallback(window->handle, __CGL_window_drag_n_drop_callback);
	window->drag_n_drop_callback = callback;
}


CGL_void CGL_window_resecure_callbacks(CGL_window* window)
{
	if (window->key_callback != NULL)
	{
		window->previous_key_callback = glfwSetKeyCallback(window->handle, __CGL_window_key_callback);
		if (window->previous_key_callback == __CGL_window_key_callback) window->previous_key_callback = NULL;
	}

	if (window->mouse_button_callback != NULL)
	{
		window->previous_mouse_button_callback = glfwSetMouseButtonCallback(window->handle, __CGL_window_mouse_button_callback);
		if (window->previous_mouse_button_callback == __CGL_window_mouse_button_callback) window->previous_mouse_button_callback = NULL;
	}

	if (window->mouse_position_callback != NULL)
	{
		window->previous_mouse_position_callback = glfwSetCursorPosCallback(window->handle, __CGL_window_mouse_position_callback);
		if (window->previous_mouse_position_callback == __CGL_window_mouse_position_callback) window->previous_mouse_position_callback = NULL;
	}

	if (window->mouse_scroll_callback != NULL)
	{
		window->previous_mouse_scroll_callback = glfwSetScrollCallback(window->handle, __CGL_window_mouse_scroll_callback);
		if (window->previous_mouse_scroll_callback == __CGL_window_mouse_scroll_callback) window->previous_mouse_scroll_callback = NULL;
	}

	if (window->framebuffer_size_callback != NULL)
	{
		window->previous_framebuffer_size_callback = glfwSetFramebufferSizeCallback(window->handle, __CGL_window_framebuffer_size_callback);
		if (window->previous_framebuffer_size_callback == __CGL_window_framebuffer_size_callback) window->previous_framebuffer_size_callback = NULL;
	}

	if (window->close_callback != NULL)
	{
		window->previous_close_callback = glfwSetWindowCloseCallback(window->handle, __CGL_window_close_callback);
		if (window->previous_close_callback == __CGL_window_close_callback) window->previous_close_callback = NULL;
	}

	if (window->drag_n_drop_callback != NULL)
	{
		window->previous_drag_n_drop_callback = glfwSetDropCallback(window->handle, __CGL_window_drag_n_drop_callback);
		if (window->previous_drag_n_drop_callback == __CGL_window_drag_n_drop_callback) window->previous_drag_n_drop_callback = NULL;
	}
}

// get key state
CGL_int CGL_window_get_key(CGL_window* window, CGL_int key)
{
	return glfwGetKey(window->handle, key);
}

// check if key is pressed
CGL_bool CGL_window_is_key_pressed(CGL_window* window, CGL_int key)
{
	return glfwGetKey(window->handle, key) == GLFW_PRESS;
}

// get mouse button state
CGL_int CGL_window_get_mouse_button(CGL_window* window, CGL_int button)
{
	return glfwGetMouseButton(window->handle, button);
}

// get mouse position
CGL_void CGL_window_get_mouse_position(CGL_window* window, double* xpos, double* ypos)
{
	glfwGetCursorPos(window->handle, xpos, ypos);
}

// make opengl context current
CGL_void CGL_window_make_context_current(CGL_window* window)
{
	glfwMakeContextCurrent(window->handle);
}

struct GLFWwindow* CGL_window_get_glfw_handle(CGL_window* window)
{
	return window->handle;
}

#endif

#endif

// opengl 
#if 1 // Just to use code folding

#ifndef CGL_EXCLUDE_GRAPHICS_API

// texture

struct CGL_texture
{
	GLuint handle;
	CGL_int width;
	CGL_int height;
	CGL_int depth;
	GLenum format;
	GLenum internal_format;
	GLenum type;
	GLenum target;
	void* user_data;
};

// create texture
CGL_texture* CGL_texture_create(CGL_image* image)
{
	GLenum format, internal_format, type;
	if (image->channels == 3)
		format = GL_RGB;
	else if (image->channels == 4)
		format = GL_RGBA;
	else
	{
		CGL_error("Invalid channel count for image\n"); return NULL;
	}
	if (image->bytes_per_channel == 8)
		type = GL_UNSIGNED_BYTE;
	else if (image->bytes_per_channel == 16)
		type = GL_UNSIGNED_SHORT;
	else if (image->bytes_per_channel == 32)
		type = GL_FLOAT;
	else
	{
		CGL_error("Invalid bit depth for image\n"); return NULL;
	}
	// determine internal format
	if (format == GL_RGB && type == GL_UNSIGNED_BYTE) internal_format = GL_RGB8;
	else if (format == GL_RGB && type == GL_UNSIGNED_SHORT) internal_format = GL_RGB16;
	else if (format == GL_RGB && type == GL_FLOAT) internal_format = GL_RGB32F;
	else if (format == GL_RGBA && type == GL_UNSIGNED_BYTE) internal_format = GL_RGBA8;
	else if (format == GL_RGBA && type == GL_UNSIGNED_SHORT) internal_format = GL_RGBA16;
	else if (format == GL_RGBA && type == GL_FLOAT) internal_format = GL_RGBA32F;
	else { CGL_error("Invalid format for image\n"); return NULL; }
	CGL_texture* texture = (CGL_texture*)CGL_malloc(sizeof(CGL_texture));
	texture->width = image->width;
	texture->height = image->height;
	texture->depth = 0;
	texture->format = format;
	texture->internal_format = internal_format;
	texture->type = type;
	texture->target = GL_TEXTURE_2D;
	texture->user_data = NULL;
	glGenTextures(1, &texture->handle);
	glBindTexture(texture->target, texture->handle);
	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
	glTexImage2D(texture->target, 0, internal_format, image->width, image->height, 0, format, type, image->data);
	glTexParameteri(texture->target, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(texture->target, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(texture->target, GL_TEXTURE_WRAP_S, GL_REPEAT);
	glTexParameteri(texture->target, GL_TEXTURE_WRAP_T, GL_REPEAT);
	glBindTexture(texture->target, 0);
	return texture;
}

// create texture
CGL_texture* CGL_texture_create_blank(CGL_int width, CGL_int height, GLenum format, GLenum internal_format, GLenum type)
{
	CGL_texture* texture = (CGL_texture*)CGL_malloc(sizeof(CGL_texture));
	texture->width = width;
	texture->height = height;
	texture->depth = 0;
	texture->format = format;
	texture->internal_format = internal_format;
	texture->type = type;
	texture->target = GL_TEXTURE_2D;
	texture->user_data = NULL;
	glGenTextures(1, &texture->handle);
	glBindTexture(texture->target, texture->handle);
	glTexImage2D(texture->target, 0, internal_format, width, height, 0, format, type, NULL);
	glTexParameteri(texture->target, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(texture->target, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(texture->target, GL_TEXTURE_WRAP_S, GL_REPEAT);
	glTexParameteri(texture->target, GL_TEXTURE_WRAP_T, GL_REPEAT);
#ifndef CGL_WASM
	glTexParameteri(texture->target, GL_TEXTURE_WRAP_R, GL_REPEAT);
#endif
	glBindTexture(texture->target, 0);
	return texture;
}

CGL_texture* CGL_texture_create_cubemap()
{
	CGL_texture* texture = (CGL_texture*)CGL_malloc(sizeof(CGL_texture));
	texture->width = 0;
	texture->height = 0;
	texture->depth = 0;
	texture->target = GL_TEXTURE_CUBE_MAP;
	texture->user_data = NULL;
	glGenTextures(1, &texture->handle);
	glBindTexture(texture->target, texture->handle);
	glPixelStorei(GL_PACK_ALIGNMENT, 1);
	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
	glTexParameteri(texture->target, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(texture->target, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(texture->target, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	glTexParameteri(texture->target, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
#ifndef CGL_WASM
	glTexParameteri(texture->target, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
#endif
	glBindTexture(texture->target, 0);
	return texture;
}

CGL_texture* CGL_texture_create_3d(CGL_int width, CGL_int height, CGL_int depth, GLenum format, GLenum internal_format, GLenum type)
{
	CGL_texture* texture = (CGL_texture*)CGL_malloc(sizeof(CGL_texture));
	texture->width = width;
	texture->height = height;
	texture->depth = depth;
	texture->format = format;
	texture->internal_format = internal_format;
	texture->type = type;
	texture->target = GL_TEXTURE_3D;
	texture->user_data = NULL;
	glGenTextures(1, &texture->handle);
	glBindTexture(texture->target, texture->handle);
	glTexImage3D(texture->target, 0, texture->internal_format, width, height, depth, 0, texture->format, texture->type, NULL);
	glTexParameteri(texture->target, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(texture->target, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(texture->target, GL_TEXTURE_WRAP_S, GL_REPEAT);
	glTexParameteri(texture->target, GL_TEXTURE_WRAP_T, GL_REPEAT);
#ifndef CGL_WASM
	glTexParameteri(texture->target, GL_TEXTURE_WRAP_R, GL_REPEAT);
#endif
	glBindTexture(texture->target, 0);
	return texture;
}

CGL_texture* CGL_texture_create_array(CGL_int width, CGL_int height, CGL_int layers, GLenum format, GLenum internal_format, GLenum type)
{
	CGL_texture* texture = (CGL_texture*)CGL_malloc(sizeof(CGL_texture));
	texture->width = width;
	texture->height = height;
	texture->depth = layers;
	texture->format = format;
	texture->internal_format = internal_format;
	texture->type = type;
	texture->target = GL_TEXTURE_2D_ARRAY;
	texture->user_data = NULL;
	glGenTextures(1, &texture->handle);
	glBindTexture(texture->target, texture->handle);
	glTexImage3D(texture->target, 0, texture->internal_format, width, height, layers, 0, texture->format, texture->type, NULL);
	glTexParameteri(texture->target, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(texture->target, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(texture->target, GL_TEXTURE_WRAP_S, GL_REPEAT);
	glTexParameteri(texture->target, GL_TEXTURE_WRAP_T, GL_REPEAT);
	glTexParameteri(texture->target, GL_TEXTURE_WRAP_R, GL_REPEAT);
	glBindTexture(texture->target, 0);
	return texture;
}

CGL_void CGL_texture_cubemap_set_face(CGL_texture* texture, CGL_int face, CGL_image* image)
{
	GLenum format, internal_format, type;
	if (image->channels == 3)
		format = internal_format = GL_RGB;
	else if (image->channels == 4)
		format = internal_format = GL_RGBA;
	else
	{
		printf("Invalid channel count for image\n"); return;
	}
	if (image->bytes_per_channel == 8)
		type = GL_UNSIGNED_BYTE;
	else if (image->bytes_per_channel == 16)
		type = GL_UNSIGNED_SHORT;
	else if (image->bytes_per_channel == 32)
		type = GL_FLOAT;
	else
	{
		printf("Invalid bit depth for image\n"); return;
	}
	glBindTexture(texture->target, texture->handle);
	glPixelStorei(GL_PACK_ALIGNMENT, 1);
	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
	glTexImage2D(face, 0, internal_format, image->width, image->height, 0, format, type, image->data);
	glBindTexture(texture->target, 0);
}

CGL_void CGL_texture_array_set_layer_data(CGL_texture* texture, CGL_int layer, void* data)
{
	glBindTexture(texture->target, texture->handle);
	glPixelStorei(GL_PACK_ALIGNMENT, 1);
	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
	glTexSubImage3D(texture->target, 0, 0, 0, layer, texture->width, texture->height, 1, texture->format, texture->type, data);
	glBindTexture(texture->target, 0);
}

CGL_void CGL_texture_set_scaling_method(CGL_texture* texture, GLint method)
{
	glBindTexture(texture->target, texture->handle);
	glTexParameteri(texture->target, GL_TEXTURE_MIN_FILTER, method);
	glTexParameteri(texture->target, GL_TEXTURE_MAG_FILTER, method);
}

CGL_void CGL_texture_set_wrapping_method(CGL_texture* texture, GLint method)
{
	glBindTexture(texture->target, texture->handle);
	glTexParameteri(texture->target, GL_TEXTURE_WRAP_S, method);
	glTexParameteri(texture->target, GL_TEXTURE_WRAP_T, method);
#ifndef CGL_WASM
	glTexParameteri(texture->target, GL_TEXTURE_WRAP_R, method);
#endif
}

// destroy texture
CGL_void CGL_texture_destroy(CGL_texture* texture)
{
	glDeleteTextures(1, &texture->handle);
	CGL_free(texture);
}

// bind texture to unit
CGL_int CGL_texture_bind(CGL_texture* texture, CGL_int unit)
{
	glActiveTexture(GL_TEXTURE0 + unit);
	glBindTexture(texture->target, texture->handle);
	return unit;
}

// set texture data
CGL_void CGL_texture_set_data(CGL_texture* texture, void* data)
{
	glBindTexture(texture->target, texture->handle);
	glPixelStorei(GL_PACK_ALIGNMENT, 1);
	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
	glTexImage2D(texture->target, 0, texture->internal_format, texture->width, texture->height, 0, texture->format, texture->type, data);
	glBindTexture(texture->target, 0);
}

CGL_void CGL_texture_set_sub_data(CGL_texture* texture, size_t offset_x, size_t offset_y, size_t size_x, size_t size_y, void* data) // set texture sub data
{
	glBindTexture(texture->target, texture->handle);
	glPixelStorei(GL_PACK_ALIGNMENT, 1);
	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
	glTexSubImage2D(texture->target, 0, (GLint)offset_x, (GLint)offset_y, (GLsizei)size_x, (GLsizei)size_y, texture->format, texture->type, data);
	glBindTexture(texture->target, 0);
}

CGL_void CGL_texture_set_pixel_data(CGL_texture* texture, int x, int y, void* data)
{
	glBindTexture(texture->target, texture->handle);
	glPixelStorei(GL_PACK_ALIGNMENT, 1);
	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
	glTexSubImage2D(texture->target, 0, (GLint)x, (GLint)y, (GLsizei)1, (GLsizei)1, texture->format, texture->type, data);
	glBindTexture(texture->target, 0);
}

// set texture user data
CGL_void CGL_texture_set_user_data(CGL_texture* texture, void* user_data)
{
	texture->user_data = user_data;
}

// get texture user data
CGL_void* CGL_texture_get_user_data(CGL_texture* texture)
{
	return texture->user_data;
}

CGL_uint CGL_texture_get_internal_handle(CGL_texture* texture)
{
	return (CGL_uint)texture->handle;
}

// get texture size
CGL_void CGL_texture_get_size(CGL_texture* texture, CGL_int* width, CGL_int* height)
{
	if (width)   *width = texture->width;
	if (height)  *height = texture->height;
}

// framebuffer
struct CGL_framebuffer
{
	CGL_texture* mousepick_texture[3];
	CGL_texture* color_attachments[4];
	CGL_texture* color_texture;
	CGL_texture* depth_texture;
	void* user_data;
	GLuint handle;
	CGL_int width;
	CGL_int height;
	CGL_int color_attachment_count;
	bool is_default;
};

// create framebuffer (32 bit)
CGL_framebuffer* CGL_framebuffer_create(CGL_int width, CGL_int height)
{
	CGL_framebuffer* framebuffer = (CGL_framebuffer*)CGL_malloc(sizeof(CGL_framebuffer));
	if (framebuffer == NULL) return NULL;

	framebuffer->color_attachment_count = 0;

	glGenFramebuffers(1, &framebuffer->handle);
	glBindFramebuffer(GL_FRAMEBUFFER, framebuffer->handle);

	// create the textures
	framebuffer->color_texture = CGL_texture_create_blank(width, height, GL_RGBA, GL_RGBA32F, GL_FLOAT);
	if (!framebuffer->color_texture)
	{
		free(framebuffer);
		return NULL;
	}


#ifdef CGL_WASM
	framebuffer->depth_texture = CGL_texture_create_blank(width, height, GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT24, GL_UNSIGNED_INT);
#else
	framebuffer->depth_texture = CGL_texture_create_blank(width, height, GL_DEPTH_COMPONENT, GL_DEPTH24_STENCIL8, GL_FLOAT);
#endif
	if (!framebuffer->depth_texture)
	{
		CGL_texture_destroy(framebuffer->color_texture);
		free(framebuffer);
		return NULL;
	}

	for (CGL_int i = 0; i < 3; i++)
	{
		framebuffer->mousepick_texture[i] = CGL_texture_create_blank(width, height, GL_RED_INTEGER, GL_R32I, GL_INT);
		if (!framebuffer->mousepick_texture[i])
		{
			CGL_texture_destroy(framebuffer->color_texture);
			CGL_texture_destroy(framebuffer->depth_texture);
			for (CGL_int j = 0; j < i; j++)
				CGL_texture_destroy(framebuffer->mousepick_texture[j]);
			free(framebuffer);
			return NULL;
		}
	}

	// attach the textures
	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, framebuffer->color_texture->handle, 0);
	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, framebuffer->depth_texture->handle, 0);
	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, GL_TEXTURE_2D, framebuffer->mousepick_texture[0]->handle, 0);
	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT2, GL_TEXTURE_2D, framebuffer->mousepick_texture[1]->handle, 0);
	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT3, GL_TEXTURE_2D, framebuffer->mousepick_texture[2]->handle, 0);

	GLenum buffers[4] = { GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1, GL_COLOR_ATTACHMENT2, GL_COLOR_ATTACHMENT3 };
	glDrawBuffers(4, buffers);


	// check if framebuffer is complete
	CGL_int res = 0;
	if ((res = glCheckFramebufferStatus(GL_FRAMEBUFFER)) != GL_FRAMEBUFFER_COMPLETE)
	{
		CGL_texture_destroy(framebuffer->color_texture);
		CGL_texture_destroy(framebuffer->depth_texture);
		for (CGL_int i = 0; i < 3; i++)
			CGL_texture_destroy(framebuffer->mousepick_texture[i]);
		free(framebuffer);
		CGL_log_internal("Framebuffer is not complete: %d\n", res);
		// get and print opengl error
		GLenum error = glGetError();
		if (error != GL_NO_ERROR)
			CGL_log_internal("OpenGL error: %d\n", (error));
		return NULL;
	}

	glBindFramebuffer(GL_FRAMEBUFFER, 0);

	framebuffer->width = width;
	framebuffer->height = height;
	framebuffer->is_default = false;
	framebuffer->user_data = NULL;

	return framebuffer;
}

CGL_framebuffer* CGL_framebuffer_create_basic(CGL_int width, CGL_int height)
{
	CGL_framebuffer* framebuffer = (CGL_framebuffer*)CGL_malloc(sizeof(CGL_framebuffer));
	if (framebuffer == NULL) return NULL;
	framebuffer->color_attachment_count = 1;
	glGenFramebuffers(1, &framebuffer->handle);
	glBindFramebuffer(GL_FRAMEBUFFER, framebuffer->handle);
	// create the textures
	framebuffer->color_texture = CGL_texture_create_blank(width, height, GL_RGBA, GL_RGBA32F, GL_FLOAT);
	if (!framebuffer->color_texture)
	{
		CGL_free(framebuffer);
		return NULL;
	}
	framebuffer->color_attachments[0] = framebuffer->color_texture;

#ifdef CGL_WASM
	framebuffer->depth_texture = CGL_texture_create_blank(width, height, GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT24, GL_UNSIGNED_INT);
#else
	framebuffer->depth_texture = CGL_texture_create_blank(width, height, GL_DEPTH_COMPONENT, GL_DEPTH24_STENCIL8, GL_FLOAT);
#endif
	if (!framebuffer->depth_texture)
	{
		CGL_texture_destroy(framebuffer->color_texture);
		CGL_free(framebuffer);
		return NULL;
	}

	// attach the textures
	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, framebuffer->color_texture->handle, 0);
	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, framebuffer->depth_texture->handle, 0);

	GLenum buffers[1] = { GL_COLOR_ATTACHMENT0 };
	glDrawBuffers(1, buffers);


	// check if framebuffer is complete
	CGL_int res = 0;
	if ((res = glCheckFramebufferStatus(GL_FRAMEBUFFER)) != GL_FRAMEBUFFER_COMPLETE)
	{
		CGL_texture_destroy(framebuffer->color_texture);
		CGL_texture_destroy(framebuffer->depth_texture);
		free(framebuffer);
		CGL_log_internal("Framebuffer is not complete: %d\n", res);
		// get and print opengl error
		GLenum error = glGetError();
		if (error != GL_NO_ERROR) CGL_log_internal("OpenGL error: %d\n", (error));
		return NULL;
	}

	glBindFramebuffer(GL_FRAMEBUFFER, 0);

	framebuffer->width = width;
	framebuffer->height = height;
	framebuffer->is_default = false;
	framebuffer->user_data = NULL;

	return framebuffer;

}

CGL_void CGL_framebuffer_add_color_attachment(CGL_framebuffer* framebuffer, CGL_texture* texture)
{
	if (framebuffer->is_default)
	{
		CGL_log_internal("Cannot add color attachment to default framebuffer\n");
		return;
	}

	if (framebuffer->color_attachment_count >= 8)
	{
		CGL_log_internal("Framebuffer already has 4 color attachments\n");
		return;
	}

	if (framebuffer->color_attachment_count == 0)
	{
		CGL_log_internal("This type of framebuffer cannot have a custom color attachment");
		return;
	}

	framebuffer->color_attachments[framebuffer->color_attachment_count++] = texture;

	glBindFramebuffer(GL_FRAMEBUFFER, framebuffer->handle);
	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + framebuffer->color_attachment_count - 1, GL_TEXTURE_2D, texture->handle, 0);
	glBindFramebuffer(GL_FRAMEBUFFER, 0);

	GLenum buffers[8] = { GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1, GL_COLOR_ATTACHMENT2, GL_COLOR_ATTACHMENT3, GL_COLOR_ATTACHMENT4, GL_COLOR_ATTACHMENT5, GL_COLOR_ATTACHMENT6, GL_COLOR_ATTACHMENT7 };
	glDrawBuffers(framebuffer->color_attachment_count, buffers);

	// check if framebuffer is complete
	if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
	{
		CGL_texture_destroy(framebuffer->color_texture);
		CGL_texture_destroy(framebuffer->depth_texture);
		for (CGL_int i = 0; i < 3; i++)
			CGL_texture_destroy(framebuffer->mousepick_texture[i]);
		free(framebuffer);
		CGL_log_internal("Framebuffer is not complete\n");
		// get and print opengl error
		GLenum error = glGetError();
		if (error != GL_NO_ERROR)
			CGL_log_internal("OpenGL error: %d\n", (error));
		return;
	}
}

CGL_texture* CGL_framebuffer_get_color_attachment(CGL_framebuffer* framebuffer, CGL_int index)
{
	if (index >= framebuffer->color_attachment_count)
	{
		CGL_log_internal("Framebuffer does not have a color attachment at index %d\n", index);
		return NULL;
	}
	return framebuffer->color_attachments[index];
}

#ifndef CGL_EXCLUDE_WINDOW_API
// create framebuffer from default framebuffer
CGL_framebuffer* CGL_framebuffer_create_from_default(CGL_window* window)
{
	CGL_framebuffer* framebuffer = (CGL_framebuffer*)malloc(sizeof(CGL_framebuffer));
	if (framebuffer == NULL) return NULL;
	framebuffer->handle = 0;
	framebuffer->color_attachment_count = 0;
	framebuffer->is_default = true;
	framebuffer->user_data = window;
	return framebuffer;
}
#endif

// destroy framebuffer
CGL_void CGL_framebuffer_destroy(CGL_framebuffer* framebuffer)
{
	if (!framebuffer->is_default)
	{
		if (framebuffer->color_attachment_count == 0)
		{
			CGL_texture_destroy(framebuffer->color_texture);
			for (CGL_int i = 0; i < 3; i++) CGL_texture_destroy(framebuffer->mousepick_texture[i]);
		}
		else for (CGL_int i = 0; i < framebuffer->color_attachment_count; i++) CGL_texture_destroy(framebuffer->color_attachments[i]);
		CGL_texture_destroy(framebuffer->depth_texture);
		glDeleteFramebuffers(1, &framebuffer->handle);
	}
	free(framebuffer);
}

// bind framebuffer
CGL_void CGL_framebuffer_bind(CGL_framebuffer* framebuffer)
{
	if (framebuffer->is_default)
	{
		CGL_int width = 512, height = 512;
		CGL_window_get_size((CGL_window*)framebuffer->user_data, &width, &height);
		glViewport(0, 0, width, height);
		glBindFramebuffer(GL_FRAMEBUFFER, 0);
	}
	else
	{
		glBindFramebuffer(GL_FRAMEBUFFER, framebuffer->handle);
		glViewport(0, 0, framebuffer->width, framebuffer->height);
		if (framebuffer->color_attachment_count > 0)
		{
			GLenum buffers[8] = { GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1, GL_COLOR_ATTACHMENT2, GL_COLOR_ATTACHMENT3, GL_COLOR_ATTACHMENT4, GL_COLOR_ATTACHMENT5, GL_COLOR_ATTACHMENT6, GL_COLOR_ATTACHMENT7 };
			glDrawBuffers(framebuffer->color_attachment_count, buffers);
		}
	}
}

// get framebuffer size
CGL_void CGL_framebuffer_get_size(CGL_framebuffer* framebuffer, CGL_int* width, CGL_int* height)
{
	if (framebuffer->is_default)
	{
		CGL_int w = 0, h = 0;
#ifdef CGL_WASM
		// TODO
#else
		CGL_window_get_framebuffer_size((CGL_window*)framebuffer->user_data, &w, &h);
#endif
		if (width)   *width = w;
		if (height)  *height = h;
	}
	else
	{
		if (width)   *width = framebuffer->width;
		if (height)  *height = framebuffer->height;
	}
}

// set framebuffer user data
CGL_void CGL_framebuffer_set_user_data(CGL_framebuffer* framebuffer, void* user_data)
{
	if (!framebuffer->is_default) framebuffer->user_data = user_data;
}

// get framebuffer user data
CGL_void* CGL_framebuffer_get_user_data(CGL_framebuffer* framebuffer)
{
	if (!framebuffer->is_default) return framebuffer->user_data;
	return NULL;
}

// read pixels from framebuffer
CGL_void CGL_framebuffer_read_pixels(CGL_framebuffer* framebuffer, CGL_int x, CGL_int y, CGL_int width, CGL_int height, void* pixels)
{
	if (framebuffer->color_attachment_count != 0) return;
	if (framebuffer->is_default) return;
	glBindFramebuffer(GL_FRAMEBUFFER, framebuffer->handle);
	glReadPixels(x, y, width, height, framebuffer->color_texture->format, framebuffer->color_texture->type, pixels);
	glBindFramebuffer(GL_FRAMEBUFFER, 0);
}

// get mouse pick id
CGL_int CGL_framebuffer_get_mouse_pick_id(CGL_framebuffer* framebuffer, CGL_int x, CGL_int y, CGL_int index)
{
	if (framebuffer->color_attachment_count != 0) return 0;
	if (index >= 3) return -1;
	if (framebuffer->is_default) return 0;
	CGL_int id = 0;
	glBindFramebuffer(GL_FRAMEBUFFER, framebuffer->handle);
	glReadBuffer(GL_COLOR_ATTACHMENT0 + 1 + index);
	glReadPixels(x, framebuffer->height - y, 1, 1, GL_RED_INTEGER, GL_INT, &id);
	glBindFramebuffer(GL_FRAMEBUFFER, 0);
	return id;
}

// get color texture
CGL_texture* CGL_framebuffer_get_color_texture(CGL_framebuffer* framebuffer)
{
	if (framebuffer->is_default) return NULL;
	return framebuffer->color_texture;
}

// get depth texture
CGL_texture* CGL_framebuffer_get_depth_texture(CGL_framebuffer* framebuffer)
{
	if (framebuffer->is_default)
		return NULL;
	return framebuffer->depth_texture;
}

// ssbo
struct CGL_ssbo
{
	GLuint handle;
	size_t size;
	CGL_int binding;
	void* user_data;
};

// create ssbo
CGL_ssbo* CGL_ssbo_create(uint32_t binding)
{
	CGL_ssbo* ssbo = (CGL_ssbo*)malloc(sizeof(CGL_ssbo));
	if (ssbo == NULL)
		return NULL;
	glGenBuffers(1, &ssbo->handle);
	glBindBuffer(GL_SHADER_STORAGE_BUFFER, ssbo->handle);
	glBindBufferBase(GL_SHADER_STORAGE_BUFFER, binding, ssbo->handle);
	glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);
	ssbo->binding = binding;
	ssbo->user_data = NULL;
	ssbo->size = 0;
	return ssbo;
}

// destroy ssbo
CGL_void CGL_ssbo_destroy(CGL_ssbo* ssbo)
{
	glDeleteBuffers(1, &ssbo->handle);
	free(ssbo);
}

// bind ssbo
CGL_void CGL_ssbo_bind(CGL_ssbo* ssbo)
{
	glBindBuffer(GL_SHADER_STORAGE_BUFFER, ssbo->handle);
}

CGL_void CGL_ssbo_bind2(CGL_ssbo* ssbo, uint32_t binding)
{
	glBindBufferBase(GL_SHADER_STORAGE_BUFFER, binding, ssbo->handle);
	glBindBuffer(GL_SHADER_STORAGE_BUFFER, ssbo->handle);
}

// set ssbo data
CGL_void CGL_ssbo_set_data(CGL_ssbo* ssbo, size_t size, void* data, bool static_draw)
{
	glBindBuffer(GL_SHADER_STORAGE_BUFFER, ssbo->handle);
	glBufferData(GL_SHADER_STORAGE_BUFFER, size, data, static_draw ? GL_STATIC_DRAW : GL_DYNAMIC_DRAW);
	glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);
	ssbo->size = size;
}

// set ssbo sub data
CGL_void CGL_ssbo_set_sub_data(CGL_ssbo* ssbo, size_t offset, size_t size, void* data, bool static_draw)
{
	(void)static_draw;
	if (offset + size > ssbo->size)
	{
		CGL_log_internal("CGL_ssbo_set_sub_data: offset + size > ssbo->size");
		return;
	}
	glBindBuffer(GL_SHADER_STORAGE_BUFFER, ssbo->handle);
	glBufferSubData(GL_SHADER_STORAGE_BUFFER, offset, size, data);
	glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);
}

// get ssbo data
CGL_void CGL_ssbo_get_data(CGL_ssbo* ssbo, size_t* size, void* data)
{
	if (size)
		*size = ssbo->size;
	glBindBuffer(GL_SHADER_STORAGE_BUFFER, ssbo->handle);
	glGetBufferSubData(GL_SHADER_STORAGE_BUFFER, 0, ssbo->size, data);
	glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);
}

// get ssbo sub data
CGL_void CGL_ssbo_get_sub_data(CGL_ssbo* ssbo, size_t offset, size_t size, void* data)
{
	if (offset + size > ssbo->size)
	{
		CGL_log_internal("CGL_ssbo_get_sub_data: offset + size > ssbo->size");
		return;
	}
	glBindBuffer(GL_SHADER_STORAGE_BUFFER, ssbo->handle);
	glGetBufferSubData(GL_SHADER_STORAGE_BUFFER, offset, size, data);
	glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);
}

// set ssbo user data
CGL_void CGL_ssbo_set_user_data(CGL_ssbo* ssbo, void* user_data)
{
	ssbo->user_data = user_data;
}

// get ssbo user data
CGL_void* CGL_ssbo_get_user_data(CGL_ssbo* ssbo)
{
	return ssbo->user_data;
}

// get ssbo size
size_t CGL_ssbo_get_size(CGL_ssbo* ssbo)
{
	return ssbo->size;
}

// copy ssbo
CGL_void CGL_ssbo_copy(CGL_ssbo* dst, CGL_ssbo* src, size_t src_offset, size_t dst_offset, size_t size)
{
	if (dst_offset + size > dst->size)
	{
		CGL_log_internal("CGL_ssbo_copy: dst_offset + size > dst->size");
		return;
	}
	if (src_offset + size > src->size)
	{
		CGL_log_internal("CGL_ssbo_copy: src_offset + size > src->size");
		return;
	}

	// NOT Supported!
	// glBindBuffer(GL_SHADER_STORAGE_BUFFER, dst->handle);
	// glCopyNamedBufferSubData(src->handle, dst->handle, src_offset, dst_offset, size);
	// glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);

	// Copying data via glCopyBufferSubData 
	glBindBuffer(GL_COPY_READ_BUFFER, src->handle);
	glBindBuffer(GL_COPY_WRITE_BUFFER, dst->handle);
	glCopyBufferSubData(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, src_offset, dst_offset, size);
	glBindBuffer(GL_COPY_READ_BUFFER, 0);
	glBindBuffer(GL_COPY_WRITE_BUFFER, 0);

}



struct CGL_shader
{
	GLuint handle;
	void* user_data;
};

struct CGL_ubo
{
	CGL_sizei size;
	CGL_uint handle;
	CGL_uint binding;
	void* user_data;
};

CGL_ubo* CGL_ubo_create()
{
	CGL_ubo* ubo = (CGL_ubo*)CGL_malloc(sizeof(CGL_ubo));
	if (ubo == NULL) return NULL;
	glGenBuffers(1, &ubo->handle);
	ubo->size = 0;
	return ubo;
}

CGL_void CGL_ubo_destroy(CGL_ubo* ubo)
{
	glDeleteBuffers(1, &ubo->handle);
	CGL_free(ubo);
}

CGL_void CGL_ubo_bind(CGL_ubo* ubo, CGL_shader* shader, const CGL_byte* name, uint32_t binding)
{
	CGL_uint index = glGetUniformBlockIndex(shader->handle, name);
	if (index == GL_INVALID_INDEX) { CGL_log_internal("CGL_ubo_bind: glGetUniformBlockIndex failed"); return; }
	glUniformBlockBinding(shader->handle, index, binding);
	glBindBufferBase(GL_UNIFORM_BUFFER, binding, ubo->handle);
	ubo->binding = binding;
}

CGL_void CGL_ubo_set_data(CGL_ubo* ubo, size_t size, void* data, bool static_draw)
{
	glBindBuffer(GL_UNIFORM_BUFFER, ubo->handle);
	glBufferData(GL_UNIFORM_BUFFER, size, data, static_draw ? GL_STATIC_DRAW : GL_DYNAMIC_DRAW);
	glBindBuffer(GL_UNIFORM_BUFFER, 0);
	ubo->size = size;
}

CGL_void CGL_ubo_set_sub_data(CGL_ubo* ubo, size_t offset, size_t size, void* data, bool static_draw)
{
	(void)static_draw;
	if (offset + size > ubo->size) { CGL_log_internal("CGL_ubo_set_sub_data: offset + size > ubo->size"); return; }
	glBindBuffer(GL_UNIFORM_BUFFER, ubo->handle);
	glBufferSubData(GL_UNIFORM_BUFFER, offset, size, data);
	glBindBuffer(GL_UNIFORM_BUFFER, 0);
	ubo->size = CGL_utils_max(ubo->size, offset + size);
}

CGL_void CGL_ubo_get_data(CGL_ubo* ubo, size_t* size, void* data)
{
	if (size) *size = ubo->size;
	glBindBuffer(GL_UNIFORM_BUFFER, ubo->handle);
	glGetBufferSubData(GL_UNIFORM_BUFFER, 0, ubo->size, data);
	glBindBuffer(GL_UNIFORM_BUFFER, 0);
}

CGL_void CGL_ubo_get_sub_data(CGL_ubo* ubo, size_t offset, size_t size, void* data)
{
	if (offset + size > ubo->size) { CGL_log_internal("CGL_ubo_get_sub_data: offset + size > ubo->size"); return; }
	glBindBuffer(GL_UNIFORM_BUFFER, ubo->handle);
	glGetBufferSubData(GL_UNIFORM_BUFFER, offset, size, data);
	glBindBuffer(GL_UNIFORM_BUFFER, 0);
}

CGL_void CGL_ubo_set_user_data(CGL_ubo* ubo, void* user_data)
{
	ubo->user_data = user_data;
}

CGL_void* CGL_ubo_get_user_data(CGL_ubo* ubo)
{
	return ubo->user_data;
}

size_t CGL_ubo_get_size(CGL_ubo* ubo)
{
	return ubo->size;
}


// gl
// clear 
CGL_void CGL_gl_clear(CGL_float r, CGL_float g, CGL_float b, CGL_float a)
{
	glClearColor(r, g, b, a);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
}

static CGL_mesh_gpu* __CGL_GL_SCREEN_QUAD_MESH = NULL;

// load opengl functions
bool CGL_gl_init()
{
#ifdef CGL_WASM
	CGL_int gles_version = gladLoadGLES2Loader((GLADloadproc)glfwGetProcAddress);
	CGL_log_internal("OpenGL ES %d\n", gles_version);
	CGL_bool result = true;
#else
	CGL_bool result = gladLoadGL();
	if (!result) CGL_log_internal("Failed to load OpenGL functions");
#endif
	CGL_mesh_cpu* mesh_cpu = CGL_mesh_cpu_quad(
		CGL_vec3_init(-1.0f, -1.0f, 0.0f),
		CGL_vec3_init(1.0f, -1.0f, 0.0f),
		CGL_vec3_init(1.0f, 1.0f, 0.0f),
		CGL_vec3_init(-1.0f, 1.0f, 0.0f)
	);
	__CGL_GL_SCREEN_QUAD_MESH = CGL_mesh_gpu_create();
	CGL_mesh_gpu_upload(__CGL_GL_SCREEN_QUAD_MESH, mesh_cpu, true);
	CGL_mesh_cpu_destroy(mesh_cpu);
	return result;
}

// clean up
CGL_void CGL_gl_shutdown()
{
	CGL_mesh_gpu_destroy(__CGL_GL_SCREEN_QUAD_MESH);
}

CGL_void CGL_gl_render_screen_quad()
{
	CGL_mesh_gpu_render(__CGL_GL_SCREEN_QUAD_MESH);
}

// mesh
struct CGL_mesh_gpu
{
	GLuint vertex_array;
	GLuint vertex_buffer;
	GLuint index_buffer;
	size_t index_count;
	size_t vertex_count;
	void* user_data;
};

// create mesh (gpu)
CGL_mesh_gpu* CGL_mesh_gpu_create()
{
	CGL_mesh_gpu* mesh = (CGL_mesh_gpu*)malloc(sizeof(CGL_mesh_gpu));
	if (mesh == NULL)
		return NULL;
	glGenVertexArrays(1, &mesh->vertex_array);
	glBindVertexArray(mesh->vertex_array);
	glGenBuffers(1, &mesh->vertex_buffer);
	glBindBuffer(GL_ARRAY_BUFFER, mesh->vertex_buffer);
	glGenBuffers(1, &mesh->index_buffer);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mesh->index_buffer);
	mesh->index_count = 0;
	mesh->vertex_count = 0;
	glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, sizeof(CGL_mesh_vertex), (void*)offsetof(CGL_mesh_vertex, position));
	glEnableVertexAttribArray(0);
	glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, sizeof(CGL_mesh_vertex), (void*)offsetof(CGL_mesh_vertex, normal));
	glEnableVertexAttribArray(1);
	glVertexAttribPointer(2, 4, GL_FLOAT, GL_FALSE, sizeof(CGL_mesh_vertex), (void*)offsetof(CGL_mesh_vertex, texture_coordinates));
	glEnableVertexAttribArray(2);
	glVertexAttribPointer(3, 4, GL_FLOAT, GL_FALSE, sizeof(CGL_mesh_vertex), (void*)offsetof(CGL_mesh_vertex, bone_wieghts));
	glEnableVertexAttribArray(3);
	glVertexAttribIPointer(4, 4, GL_INT, sizeof(CGL_mesh_vertex), (void*)offsetof(CGL_mesh_vertex, bone_ids));
	glEnableVertexAttribArray(4);
	mesh->user_data = NULL;
	return mesh;
}

// destroy mesh (gpu)
CGL_void CGL_mesh_gpu_destroy(CGL_mesh_gpu* mesh)
{
	glDeleteBuffers(1, &mesh->index_buffer);
	glDeleteBuffers(1, &mesh->vertex_buffer);
	glDeleteVertexArrays(1, &mesh->vertex_array);
	free(mesh);
}

// bind mesh (gpu)
CGL_void CGL_mesh_gpu_render(CGL_mesh_gpu* mesh)
{
	if (mesh->index_count <= 0) return;
	glBindVertexArray(mesh->vertex_array);
	glDrawElements(GL_TRIANGLES, (GLsizei)mesh->index_count, GL_UNSIGNED_INT, 0);
	glBindVertexArray(0);
}

// render mesh instanfced (gpu)
CGL_void CGL_mesh_gpu_render_instanced(CGL_mesh_gpu* mesh, uint32_t count)
{
	if (mesh->index_count <= 0) return;
	glBindVertexArray(mesh->vertex_array);
	glDrawElementsInstanced(GL_TRIANGLES, (GLsizei)mesh->index_count, GL_UNSIGNED_INT, 0, count);
	glBindVertexArray(0);
}

// upload mesh from (cpu) to (gpu)
CGL_void CGL_mesh_gpu_upload(CGL_mesh_gpu* mesh, CGL_mesh_cpu* mesh_cpu, bool static_draw)
{
	if (mesh_cpu->index_count <= 0) return;
	mesh->index_count = mesh_cpu->index_count_used;
	mesh->vertex_count = mesh_cpu->vertex_count_used;
	glBindBuffer(GL_ARRAY_BUFFER, mesh->vertex_buffer);
	glBufferData(GL_ARRAY_BUFFER, mesh_cpu->vertex_count_used * sizeof(CGL_mesh_vertex), mesh_cpu->vertices, static_draw ? GL_STATIC_DRAW : GL_DYNAMIC_DRAW);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mesh->index_buffer);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, mesh_cpu->index_count_used * sizeof(unsigned int), mesh_cpu->indices, static_draw ? GL_STATIC_DRAW : GL_DYNAMIC_DRAW);
}

// set mesh user data
CGL_void CGL_mesh_gpu_set_user_data(CGL_mesh_gpu* mesh, void* user_data)
{
	mesh->user_data = user_data;
}

// get mesh user data
CGL_void* CGL_mesh_gpu_get_user_data(CGL_mesh_gpu* mesh)
{
	return mesh->user_data;
}

// destroy mesh (cpu)
CGL_void CGL_mesh_cpu_destroy(CGL_mesh_cpu* mesh)
{
	if (mesh->vertices) CGL_free(mesh->vertices);
	if (mesh->indices) CGL_free(mesh->indices);
	CGL_free(mesh);
}

// create mesh (cpu)
CGL_mesh_cpu* CGL_mesh_cpu_create(size_t vertex_count, size_t index_count)
{
	CGL_mesh_cpu* mesh = (CGL_mesh_cpu*)malloc(sizeof(CGL_mesh_cpu));
	if (mesh == NULL) return NULL;
	mesh->vertex_count = vertex_count;
	mesh->index_count = index_count;
	mesh->vertex_count_used = 0;
	mesh->index_count_used = 0;
	mesh->vertices = (CGL_mesh_vertex*)malloc(mesh->vertex_count * sizeof(CGL_mesh_vertex));
	if (mesh->vertices == NULL)
	{
		CGL_free(mesh);
		return NULL;
	}
	mesh->indices = (uint32_t*)malloc(mesh->index_count * sizeof(uint32_t));
	if (mesh->indices == NULL)
	{
		CGL_free(mesh->vertices);
		CGL_free(mesh);
		return NULL;
	}
	for (CGL_sizei i = 0; i < index_count; i++) mesh->indices[i] = (CGL_uint)i;
	return mesh;
}

CGL_mesh_cpu* CGL_mesh_cpu_recalculate_normals(CGL_mesh_cpu* mesh)
{
	// clear normals
	for (size_t i = 0; i < mesh->vertex_count; i++) mesh->vertices[i].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	// calculate un normalized normals
	for (size_t i = 0; i < mesh->index_count; i += 3)
	{
		CGL_vec4 a = mesh->vertices[mesh->indices[i + 0]].position;
		CGL_vec4 b = mesh->vertices[mesh->indices[i + 1]].position;
		CGL_vec4 c = mesh->vertices[mesh->indices[i + 2]].position;
		CGL_vec3 ab = CGL_vec3_sub(b, a);
		CGL_vec3 ac = CGL_vec3_sub(c, a);
		CGL_vec3 normal_3 = CGL_vec3_cross(ac, ab);
		CGL_vec4 normal = CGL_vec4_init(normal_3.x, normal_3.y, normal_3.z, 0.0f);
		mesh->vertices[mesh->indices[i + 0]].normal = CGL_vec4_add(mesh->vertices[mesh->indices[i + 0]].normal, normal);
		mesh->vertices[mesh->indices[i + 1]].normal = CGL_vec4_add(mesh->vertices[mesh->indices[i + 1]].normal, normal);
		mesh->vertices[mesh->indices[i + 2]].normal = CGL_vec4_add(mesh->vertices[mesh->indices[i + 2]].normal, normal);
	}
	// normalize normals
	for (size_t i = 0; i < mesh->vertex_count; i++)
	{
		CGL_vec4_normalize_vec3(mesh->vertices[i].normal);
	}
    
	return mesh;
}

CGL_mesh_cpu* CGL_mesh_cpu_flip_normals(CGL_mesh_cpu* mesh)
{
    for (size_t i = 0; i < mesh->vertex_count; i++)
	{
		mesh->vertices[i].normal = CGL_vec4_init(- mesh->vertices[i].normal.x, -mesh->vertices[i].normal.y, -mesh->vertices[i].normal.z, 0.0f);
	}
    
	return mesh;
}


CGL_void __CGL_mesh_cpu_load_obj_helper_parse_obj_line(char* line, float* items, CGL_int count)
{
	char* begin = line;
	char* end = line + strlen(line);
	CGL_int i = 0, j = 0;
	while ((begin < end) && (i < count))
	{
		if (line[j++] == ' ')
		{
			line[j - 1] = '\0';
			items[i++] = (float)atof(begin);
			begin = line + j;
		}
	}
}

CGL_mesh_cpu* CGL_mesh_cpu_load_obj(const char* path)
{
	char temp_buffer[1024];
	CGL_list* vertex_positions = CGL_list_create(sizeof(float) * 4, 1000);
	CGL_list* vertex_normals = CGL_list_create(sizeof(float) * 4, 1000);
	CGL_list* vertex_texture_coordinates = CGL_list_create(sizeof(float) * 4, 1000);
	CGL_list* vertices = CGL_list_create(sizeof(CGL_mesh_vertex), 1000);
	CGL_list* indices = CGL_list_create(sizeof(uint32_t), 1000);
	size_t file_size = 0;
	char* file_data = CGL_utils_read_file(path, &file_size);
	if (file_size == 0) return NULL;
	char* line = strtok(file_data, "\n");
	CGL_int object_count = 0;
	CGL_float item_data[4] = { 0.0f, 0.0f, 0.0f, 1.0f };
	uint32_t index = 0;
	while (line != NULL)
	{
		if (line[0] == 'v' && line[1] == ' ')
		{
			sprintf(temp_buffer, "%s ", (line + 2));
			__CGL_mesh_cpu_load_obj_helper_parse_obj_line(temp_buffer, item_data, 3);
			CGL_list_push(vertex_positions, item_data);
		}
		else if (line[0] == 'v' && line[1] == 'n')
		{
			sprintf(temp_buffer, "%s ", (line + 3));
			__CGL_mesh_cpu_load_obj_helper_parse_obj_line(temp_buffer, item_data, 3);
			CGL_list_push(vertex_normals, item_data);
		}
		else if (line[0] == 'v' && line[1] == 't')
		{
			sprintf(temp_buffer, "%s ", (line + 3));
			__CGL_mesh_cpu_load_obj_helper_parse_obj_line(temp_buffer, item_data, 2);
			CGL_list_push(vertex_texture_coordinates, item_data);
		}
		else if (line[0] == 'f' && line[1] == ' ')
		{
			sprintf(temp_buffer, "%s ", (line + 2));
			uint32_t index_v_vt_vn[4][3];
			memset(index_v_vt_vn, 0, sizeof(index_v_vt_vn));
			char* begin = temp_buffer;
			char* end = temp_buffer + strlen(temp_buffer);
			CGL_int i = 0, j = 0, k = 0;
			while ((begin < end) && (i < 3))
			{
				if (temp_buffer[j] == '/' || temp_buffer[j] == ' ')
				{
					char c = temp_buffer[j];
					temp_buffer[j] = '\0';
					index_v_vt_vn[i][k++] = (uint32_t)atoll(begin);
					begin = temp_buffer + j + 1;
					if (c == ' ') { k = 0; i++; }
				}
				j++;
			}
			CGL_mesh_vertex current_vertex = { 0 };
			for (i = 0; i < 3; i++)
			{
				if (!CGL_list_get(vertex_positions, index_v_vt_vn[i][0] - 1, &current_vertex.position))
					current_vertex.position = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
				if (!CGL_list_get(vertex_texture_coordinates, index_v_vt_vn[i][1] - 1, &current_vertex.texture_coordinates))
					current_vertex.texture_coordinates = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
				if (!CGL_list_get(vertex_normals, index_v_vt_vn[i][2] - 1, &current_vertex.normal))
					current_vertex.normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
				CGL_list_push(vertices, &current_vertex);
			}

			CGL_list_push(indices, &index); index++;
			CGL_list_push(indices, &index); index++;
			CGL_list_push(indices, &index); index++;
		}
		else if (line[0] == 'o' && line[1] == ' ')
			object_count++;
		line = strtok(NULL, "\n");
		if (object_count == 2) break; // only one object is parsed as of now
	}

	size_t index_count = CGL_list_get_size(indices);
	size_t vertex_count = CGL_list_get_size(vertices);
	CGL_mesh_cpu* mesh = CGL_mesh_cpu_create(vertex_count, index_count);
	memcpy(mesh->indices, CGL_list_get(indices, 0, NULL), sizeof(uint32_t) * index_count);
	memcpy(mesh->vertices, CGL_list_get(vertices, 0, NULL), sizeof(CGL_mesh_vertex) * vertex_count);
	CGL_free(file_data);
	CGL_list_destroy(vertices);
	CGL_list_destroy(indices);
	CGL_list_destroy(vertex_positions);
	CGL_list_destroy(vertex_normals);
	CGL_list_destroy(vertex_texture_coordinates);
	mesh->vertex_count_used = mesh->vertex_count;
	mesh->index_count_used = mesh->index_count;
	return mesh;
}

// generate plane mesh
CGL_mesh_cpu* CGL_mesh_cpu_plane(CGL_vec3 front, CGL_vec3 right, CGL_int resolution, CGL_float scale)
{
	CGL_vec3_normalize(front);
	CGL_vec3_normalize(right);
	CGL_vec3 up = CGL_vec3_cross(front, right); // up is perpendicular to front and right
	CGL_mesh_cpu* mesh = CGL_mesh_cpu_create(resolution * resolution, (resolution - 1) * (resolution - 1) * 6);
	CGL_int index = 0, tri_index = 0;
	CGL_float temp0 = 0.0f, temp1 = 0.0f;
	CGL_vec3 tempv0, tempv1, point_on_plane;
	for (CGL_int y = 0; y < resolution; y++)
	{
		for (CGL_int x = 0; x < resolution; x++)
		{
			index = x + y * resolution;
			CGL_vec2 percent = CGL_vec2_init((float)x / ((float)resolution - 1), (float)y / ((float)resolution - 1));
			temp0 = (percent.x - 0.5f) * 2.0f;
			temp1 = (percent.y - 0.5f) * 2.0f;
			tempv0 = CGL_vec3_scale(right, temp0);
			tempv1 = CGL_vec3_scale(front, temp1);
			point_on_plane = CGL_vec3_add(tempv0, tempv1);
			point_on_plane = CGL_vec3_scale(point_on_plane, scale);
			mesh->vertices[index].position = CGL_vec4_init(point_on_plane.x, point_on_plane.y, point_on_plane.z, 1.0f);
			mesh->vertices[index].texture_coordinates = CGL_vec4_init(percent.x, percent.y, 0.0f, 0.0f);
			mesh->vertices[index].normal = CGL_vec4_init(up.x, up.y, up.z, 0.0f);
			if (x != resolution - 1 && y != resolution - 1)
			{
				mesh->indices[tri_index + 0] = index;
				mesh->indices[tri_index + 1] = index + resolution + 1;
				mesh->indices[tri_index + 2] = index + resolution;
				mesh->indices[tri_index + 3] = index;
				mesh->indices[tri_index + 4] = index + 1;
				mesh->indices[tri_index + 5] = index + resolution + 1;
				tri_index += 6;
			}
		}
	}
	mesh->vertex_count_used = mesh->vertex_count;
	mesh->index_count_used = mesh->index_count;
	return mesh;
}

// generate triangle mesh
CGL_mesh_cpu* CGL_mesh_cpu_triangle(CGL_vec3 a, CGL_vec3 b, CGL_vec3 c)
{
	CGL_mesh_cpu* mesh = CGL_mesh_cpu_create(3, 3);
	return CGL_mesh_cpu_add_triangle(mesh, a, b, c);
}

// generate quad mesh
CGL_mesh_cpu* CGL_mesh_cpu_quad(CGL_vec3 a, CGL_vec3 b, CGL_vec3 c, CGL_vec3 d)
{
	CGL_mesh_cpu* mesh = CGL_mesh_cpu_create(6, 6);
	return CGL_mesh_cpu_add_quad(mesh, a, b, c, d);
}

// Algorithm from https://stackoverflow.com/a/31326534/14911094
CGL_mesh_cpu* CGL_mesh_cpu_create_from_parametric_function(CGL_int res_u, CGL_int res_v, CGL_float start_u, CGL_float start_v, CGL_float end_u, CGL_float end_v, CGL_parametric_function function)
{
	CGL_mesh_cpu* mesh = CGL_mesh_cpu_create(res_u * res_v * 4, res_u * res_v * 6);
	return CGL_mesh_cpu_add_from_parametric_function(mesh, res_u, res_v, start_u, start_v, end_u, end_v, function);
}

CGL_mesh_cpu* CGL_mesh_cpu_add_triangle(CGL_mesh_cpu* mesh, CGL_vec3 a, CGL_vec3 b, CGL_vec3 c)
{
	if (mesh == NULL) return NULL;
	CGL_vec3 ab = CGL_vec3_sub(b, a);
	CGL_vec3 ac = CGL_vec3_sub(c, a);
	CGL_vec3 normal = CGL_vec3_cross(ab, ac);
	CGL_vec4 normal_4 = CGL_vec4_init(normal.x, normal.y, normal.z, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 0].position = CGL_vec4_init(a.x, a.y, a.z, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 0].normal = normal_4;
	mesh->vertices[mesh->vertex_count_used + 0].texture_coordinates = CGL_vec4_init(0.0f, 0.0f, 0.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 1].position = CGL_vec4_init(b.x, b.y, b.z, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 1].normal = normal_4;
	mesh->vertices[mesh->vertex_count_used + 1].texture_coordinates = CGL_vec4_init(0.0f, 0.0f, 0.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 2].position = CGL_vec4_init(c.x, c.y, c.z, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 2].normal = normal_4;
	mesh->vertices[mesh->vertex_count_used + 2].texture_coordinates = CGL_vec4_init(0.0f, 0.0f, 0.0f, 1.0f);
	mesh->vertex_count_used += 3;
	mesh->indices[mesh->index_count_used + 0] = 0;
	mesh->indices[mesh->index_count_used + 1] = 1;
	mesh->indices[mesh->index_count_used + 2] = 2;
	mesh->index_count_used += 3;
	return mesh;
}

CGL_mesh_cpu* CGL_mesh_cpu_add_quad(CGL_mesh_cpu* mesh, CGL_vec3 a, CGL_vec3 b, CGL_vec3 c, CGL_vec3 d)
{
	if (mesh == NULL) return NULL;
	CGL_vec3 ab = CGL_vec3_sub(b, a);
	CGL_vec3 ac = CGL_vec3_sub(c, a);
	// CGL_vec3 ad = CGL_vec3_sub(d, a);
	CGL_vec3 normal_abc = CGL_vec3_cross(ab, ac);
	CGL_vec4 normal_abc_4 = CGL_vec4_init(normal_abc.x, normal_abc.y, normal_abc.z, 0.0f);

	mesh->vertices[mesh->vertex_count_used + 0].position = CGL_vec4_init(a.x, a.y, a.z, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 0].normal = normal_abc_4;
	mesh->vertices[mesh->vertex_count_used + 0].texture_coordinates = CGL_vec4_init(1.0f, 1.0f, 0.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 1].position = CGL_vec4_init(b.x, b.y, b.z, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 1].normal = normal_abc_4;
	mesh->vertices[mesh->vertex_count_used + 1].texture_coordinates = CGL_vec4_init(1.0f, 0.0f, 0.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 2].position = CGL_vec4_init(c.x, c.y, c.z, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 2].normal = normal_abc_4;
	mesh->vertices[mesh->vertex_count_used + 2].texture_coordinates = CGL_vec4_init(0.0f, 0.0f, 0.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 3].position = CGL_vec4_init(a.x, a.y, a.z, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 3].normal = normal_abc_4;
	mesh->vertices[mesh->vertex_count_used + 3].texture_coordinates = CGL_vec4_init(1.0f, 1.0f, 0.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 4].position = CGL_vec4_init(c.x, c.y, c.z, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 4].normal = normal_abc_4;
	mesh->vertices[mesh->vertex_count_used + 4].texture_coordinates = CGL_vec4_init(0.0f, 0.0f, 0.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 5].position = CGL_vec4_init(d.x, d.y, d.z, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 5].normal = normal_abc_4;
	mesh->vertices[mesh->vertex_count_used + 5].texture_coordinates = CGL_vec4_init(0.0f, 1.0f, 0.0f, 1.0f);
	mesh->vertex_count_used += 6;
	for (CGL_int i = 0; i < 6; i++) mesh->indices[mesh->index_count_used + i] = (CGL_uint)mesh->index_count_used + (CGL_uint)i;
	mesh->index_count_used += 6;
	return mesh;
}

CGL_mesh_cpu* CGL_mesh_cpu_add_from_parametric_function(CGL_mesh_cpu* mesh, CGL_int res_u, CGL_int res_v, CGL_float start_u, CGL_float start_v, CGL_float end_u, CGL_float end_v, CGL_parametric_function function)
{
	if (mesh == NULL) return NULL;
	CGL_float step_u = (end_u - start_u) / res_u;
	CGL_float step_v = (end_v - start_v) / res_v;
	size_t vertex_index = 0;
	size_t index_index = 0;
	for (CGL_int i = 0; i < res_u; i++)
	{
		for (CGL_int j = 0; j < res_v; j++)
		{
			CGL_float u = i * step_u + start_u;
			CGL_float v = j * step_v + start_v;
			CGL_float un = ((i + 1) == res_u) ? end_u : ((i + 1) * step_u + start_u);
			CGL_float vn = ((j + 1) == res_v) ? end_v : ((j + 1) * step_v + start_v);
			// find the four points of the grid square
			// by evaluating the paramatric surface function
			CGL_vec3 p0 = function(u, v);
			CGL_vec3 p1 = function(u, vn);
			CGL_vec3 p2 = function(un, v);
			CGL_vec3 p3 = function(un, vn);
			mesh->vertices[mesh->vertex_count_used + vertex_index].position = CGL_vec4_init(p0.x, p0.y, p0.z, 1.0f);
			mesh->vertices[mesh->vertex_count_used + vertex_index].texture_coordinates = CGL_vec4_init(u, v, 0.0f, 0.0f);
			vertex_index += 1;
			mesh->vertices[mesh->vertex_count_used + vertex_index].position = CGL_vec4_init(p1.x, p1.y, p1.z, 1.0f);
			mesh->vertices[mesh->vertex_count_used + vertex_index].texture_coordinates = CGL_vec4_init(u, vn, 0.0f, 0.0f);
			vertex_index += 1;
			mesh->vertices[mesh->vertex_count_used + vertex_index].position = CGL_vec4_init(p2.x, p2.y, p2.z, 1.0f);
			mesh->vertices[mesh->vertex_count_used + vertex_index].texture_coordinates = CGL_vec4_init(un, v, 0.0f, 0.0f);
			vertex_index += 1;
			mesh->vertices[mesh->vertex_count_used + vertex_index].position = CGL_vec4_init(p3.x, p3.y, p3.z, 1.0f);
			mesh->vertices[mesh->vertex_count_used + vertex_index].texture_coordinates = CGL_vec4_init(un, vn, 0.0f, 0.0f);
			vertex_index += 1;
			// Output the first triangle of this grid square
			// triangle(p0, p2, p1)
			mesh->indices[mesh->index_count_used + index_index++] = (uint32_t)(mesh->vertex_count_used + vertex_index) - 4; // p0
			mesh->indices[mesh->index_count_used + index_index++] = (uint32_t)(mesh->vertex_count_used + vertex_index) - 2; // p2
			mesh->indices[mesh->index_count_used + index_index++] = (uint32_t)(mesh->vertex_count_used + vertex_index) - 3; // p1
			// Output the other triangle of this grid square
			// triangle(p3, p1, p2) 
			mesh->indices[mesh->index_count_used + index_index++] = (uint32_t)(mesh->vertex_count_used + vertex_index) - 1; // p3
			mesh->indices[mesh->index_count_used + index_index++] = (uint32_t)(mesh->vertex_count_used + vertex_index) - 3; // p1
			mesh->indices[mesh->index_count_used + index_index++] = (uint32_t)(mesh->vertex_count_used + vertex_index) - 2; // p2
		}
	}
	mesh->vertex_count_used += res_u * res_v * 4;
	mesh->index_count_used += res_u * res_v * 6;
	return mesh;
}


static CGL_vec3 __CGL_mesh_cpu_sphere_parametric_function(CGL_float u, CGL_float v)
{
	return CGL_vec3_init(cosf(u) * sinf(v), cosf(v), sinf(u) * sinf(v));
}

CGL_mesh_cpu* CGL_mesh_cpu_add_sphere(CGL_mesh_cpu* mesh, CGL_int res_u, CGL_int res_v)
{
	return CGL_mesh_cpu_add_from_parametric_function(mesh, res_u, res_v, 0.0f, 0.0f, 3.14f * 2.0f, 3.14f, __CGL_mesh_cpu_sphere_parametric_function);
}

CGL_mesh_cpu* CGL_mesh_cpu_create_cylinder(CGL_vec3 start, CGL_vec3 end, CGL_float radius0, CGL_float radius1, CGL_int resolution)
{
	CGL_mesh_cpu* mesh = CGL_mesh_cpu_create(resolution * 2 * 3, resolution * 2 * 3);
	CGL_mesh_cpu_add_cylinder2(mesh, start, end, radius0, radius1, resolution, 1);
	CGL_mesh_cpu_recalculate_normals(mesh);
	return mesh;
}

CGL_mesh_cpu* CGL_mesh_cpu_create_cylinder2(CGL_vec3 start, CGL_vec3 end, CGL_float radius0, CGL_float radius1, CGL_int resolution_x, CGL_int resolution_y)
{
	CGL_int resolution = resolution_x * resolution_y;	
	CGL_mesh_cpu* mesh = CGL_mesh_cpu_create(resolution * 2 * 3, resolution * 2 * 3);
	CGL_mesh_cpu_add_cylinder2(mesh, start, end, radius0, radius1, resolution_x, resolution_y);
	CGL_mesh_cpu_recalculate_normals(mesh);
	return mesh;
}

CGL_mesh_cpu* CGL_mesh_cpu_add_cylinder(CGL_mesh_cpu* mesh, CGL_vec3 start, CGL_vec3 end, CGL_float radius0, CGL_float radius1, CGL_int resolution)
{
	if (mesh == NULL) return NULL;
	if (resolution < 3) return NULL;

	CGL_vec3 direction = CGL_vec3_sub(end, start);
	CGL_vec3_normalize(direction);
	CGL_vec3 right = CGL_vec3_init(0.0f, 0.0f, 0.0f);
	CGL_vec3 top = CGL_vec3_init(0.0f, 0.0f, 0.0f);
	CGL_vec3_calculate_orthonormal_basis_from_one_vector(direction, &right, &top);
	CGL_float angle = 0.0f;
	CGL_float angle_step = 3.14f * 2.0f / (CGL_float)resolution;
	CGL_int vertex_index = 0;
	CGL_int index_index = 0;
	for (CGL_int i = 0; i < resolution; i++)
	{
        // prevent lerp interpolation floating-point inaccuracy on last step
        CGL_float angle_plus_step = angle + angle_step;
        
        if(i +1 == resolution)
            angle_plus_step = 0.0f;
        
		CGL_vec3 p0 = CGL_vec3_add3_(start, CGL_vec3_scale_(right, cosf(angle) * radius0), CGL_vec3_scale_(top, sinf(angle) * radius0));
		CGL_vec3 p1 = CGL_vec3_add3_(start, CGL_vec3_scale_(right, cosf(angle_plus_step) * radius0), CGL_vec3_scale_(top, sinf(angle_plus_step) * radius0));
		CGL_vec3 p2 = CGL_vec3_add3_(end, CGL_vec3_scale_(right, cosf(angle) * radius1), CGL_vec3_scale_(top, sinf(angle) * radius1));
		CGL_vec3 p3 = CGL_vec3_add3_(end, CGL_vec3_scale_(right, cosf(angle_plus_step) * radius1), CGL_vec3_scale_(top, sinf(angle_plus_step) * radius1));
		angle += angle_step;
        
		// Output the first triangle of this grid square
		// triangle(p0, p2, p1)
		mesh->vertices[mesh->vertex_count_used + vertex_index].position = CGL_vec4_init(p0.x, p0.y, p0.z, 1.0f);
		mesh->vertices[mesh->vertex_count_used + vertex_index].texture_coordinates = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
		vertex_index += 1;
		mesh->vertices[mesh->vertex_count_used + vertex_index].position = CGL_vec4_init(p2.x, p2.y, p2.z, 1.0f);
		mesh->vertices[mesh->vertex_count_used + vertex_index].texture_coordinates = CGL_vec4_init(0.0f, 1.0f, 0.0f, 0.0f);
		vertex_index += 1;
		mesh->vertices[mesh->vertex_count_used + vertex_index].position = CGL_vec4_init(p1.x, p1.y, p1.z, 1.0f);
		mesh->vertices[mesh->vertex_count_used + vertex_index].texture_coordinates = CGL_vec4_init(1.0f, 0.0f, 0.0f, 0.0f);
		vertex_index += 1;
		// Output the second triangle of this grid square
		// triangle(p1, p2, p3)
		mesh->vertices[mesh->vertex_count_used + vertex_index].position = CGL_vec4_init(p1.x, p1.y, p1.z, 1.0f);
		mesh->vertices[mesh->vertex_count_used + vertex_index].texture_coordinates = CGL_vec4_init(1.0f, 0.0f, 0.0f, 0.0f);
		vertex_index += 1;
		mesh->vertices[mesh->vertex_count_used + vertex_index].position = CGL_vec4_init(p2.x, p2.y, p2.z, 1.0f);
		mesh->vertices[mesh->vertex_count_used + vertex_index].texture_coordinates = CGL_vec4_init(0.0f, 1.0f, 0.0f, 0.0f);
		vertex_index += 1;
		mesh->vertices[mesh->vertex_count_used + vertex_index].position = CGL_vec4_init(p3.x, p3.y, p3.z, 1.0f);
		mesh->vertices[mesh->vertex_count_used + vertex_index].texture_coordinates = CGL_vec4_init(1.0f, 1.0f, 0.0f, 0.0f);
		vertex_index += 1;
		// Output the indices for this grid square
		mesh->indices[mesh->index_count_used + index_index] = (CGL_uint)mesh->vertex_count_used + vertex_index - 6; index_index += 1;
		mesh->indices[mesh->index_count_used + index_index] = (CGL_uint)mesh->vertex_count_used + vertex_index - 5; index_index += 1;
		mesh->indices[mesh->index_count_used + index_index] = (CGL_uint)mesh->vertex_count_used + vertex_index - 4; index_index += 1;
		mesh->indices[mesh->index_count_used + index_index] = (CGL_uint)mesh->vertex_count_used + vertex_index - 3; index_index += 1;
		mesh->indices[mesh->index_count_used + index_index] = (CGL_uint)mesh->vertex_count_used + vertex_index - 2; index_index += 1;
		mesh->indices[mesh->index_count_used + index_index] = (CGL_uint)mesh->vertex_count_used + vertex_index - 1; index_index += 1;
	}
	mesh->vertex_count_used += vertex_index;
	mesh->index_count_used += index_index;
	return mesh;
}

CGL_mesh_cpu* CGL_mesh_cpu_add_cylinder2(CGL_mesh_cpu* mesh, CGL_vec3 start, CGL_vec3 end, CGL_float radius0, CGL_float radius1, CGL_int resolution_x, CGL_int resolution_y)
{
	if (mesh == NULL) return NULL;
	if (resolution_x < 3 || resolution_y < 1) return NULL;

	CGL_vec3 prev = start;
	CGL_vec3 curr = start;
	CGL_float rad_prev = radius0;
	CGL_float rad_curr = 0.0f;

	for (CGL_int i = 1; i <= resolution_y; i++) 
	{
		CGL_float u0 = (CGL_float)i / (CGL_float)resolution_y;
		curr = CGL_vec3_add(start, CGL_vec3_scale(CGL_vec3_sub(end, start), u0));
		rad_curr = radius0 + (radius1 - radius0) * u0;
		CGL_mesh_cpu_add_cylinder(mesh, prev, curr, rad_prev, rad_curr, resolution_x);

		prev = curr;
		rad_prev = rad_curr;
	}

	return mesh;
}

CGL_mesh_cpu* CGL_mesh_cpu_create_torus_elbow(CGL_vec3 center, CGL_float radius0, CGL_float radius1, CGL_int resolution0, CGL_int resolution1, CGL_float elbow_angle)
{
	CGL_mesh_cpu* mesh = CGL_mesh_cpu_create(resolution0*resolution1 * 2 * 3, resolution0*resolution1 * 2 * 3);
	CGL_mesh_cpu_add_torus(mesh, center, radius0, radius1, resolution0, resolution1, elbow_angle);
    
    CGL_mesh_cpu_offset_vertices(mesh, center);
	CGL_mesh_cpu_recalculate_normals(mesh);
	return mesh;
}


// placeholder
static float m_r = 1.0f;
static float M_r = 2.0f;

static CGL_vec3 __CGL_mesh_cpu_torus_parametric_function(CGL_float u, CGL_float v)
{
	return CGL_vec3_init(cosf(u)* (M_r +  m_r * cosf(v)), m_r * sinf(v), sinf(u) * (M_r + m_r * cosf(v)));
}

CGL_mesh_cpu* CGL_mesh_cpu_add_torus(CGL_mesh_cpu* mesh, CGL_vec3 center, CGL_float radius0, CGL_float radius1, CGL_int resolution0, CGL_int resolution1, CGL_float elbow_angle)
{
	(void)center;

    m_r = radius1;
    M_r = radius0;
    
	CGL_mesh_cpu* res = CGL_mesh_cpu_add_from_parametric_function(mesh, resolution0, resolution1, 0.0f, 0.0f, elbow_angle, CGL_2PI, __CGL_mesh_cpu_torus_parametric_function); 
    m_r = 1.0f; M_r = 2.0f;
	return res;
}


CGL_mesh_cpu* CGL_mesh_cpu_offset_vertices(CGL_mesh_cpu* mesh, CGL_vec3 offset)
{
	for (CGL_sizei i = 0; i < mesh->vertex_count_used; i++)
	{
		mesh->vertices[i].position.x += offset.x;
		mesh->vertices[i].position.y += offset.y;
		mesh->vertices[i].position.z += offset.z;
		mesh->vertices[i].position.w = 1.0f;
	}
	return mesh;
}

CGL_mesh_cpu* CGL_mesh_cpu_scale_vertices(CGL_mesh_cpu* mesh, CGL_float scale)
{
	for (CGL_sizei i = 0; i < mesh->vertex_count_used; i++)
	{
		mesh->vertices[i].position.x *= scale;
		mesh->vertices[i].position.y *= scale;
		mesh->vertices[i].position.z *= scale;
		mesh->vertices[i].position.w = 1.0f;
	}
	return mesh;
}

CGL_mesh_cpu* CGL_mesh_cpu_rotate_vertices(CGL_mesh_cpu* mesh, CGL_quat rotation)
{
	for (CGL_sizei i = 0; i < mesh->vertex_count_used; i++)
	{
		mesh->vertices[i].position.w = 1.0f;
		mesh->vertices[i].position = CGL_quat_mul_vec4(rotation, mesh->vertices[i].position);
	}
	return mesh;
}

CGL_mesh_cpu* CGL_mesh_cpu_transform_vertices(CGL_mesh_cpu* mesh, CGL_mat4 transform)
{
	for (CGL_sizei i = 0; i < mesh->vertex_count_used; i++)
	{
		mesh->vertices[i].position.w = 1.0f;
		mesh->vertices[i].position = CGL_mat4_mul_vec4(transform, mesh->vertices[i].position);
	}
	return mesh;
}

CGL_mesh_cpu* CGL_mesh_cpu_sphere(CGL_int res_u, CGL_int res_v)
{
	return CGL_mesh_cpu_create_from_parametric_function(res_u, res_v, 0.0f, 0.0f, CGL_2PI, CGL_PI, __CGL_mesh_cpu_sphere_parametric_function);
}

CGL_mesh_cpu* CGL_mesh_cpu_add_mesh(CGL_mesh_cpu* mesh, CGL_mesh_cpu* mesh_other)
{
	for (CGL_sizei i = 0; i < mesh_other->vertex_count_used; i++) mesh->vertices[mesh->vertex_count_used + i] = mesh_other->vertices[i];
	for (CGL_sizei i = 0; i < mesh_other->index_count_used; i++) mesh->indices[mesh->index_count_used + i] = mesh_other->indices[i] + (CGL_uint)mesh->vertex_count_used;
	mesh->vertex_count_used += mesh_other->vertex_count_used; mesh->index_count_used += mesh_other->index_count_used;
	return mesh;
}

CGL_mesh_cpu* CGL_mesh_cpu_add_cube(CGL_mesh_cpu* mesh, CGL_bool use_3d_tex_coords)
{
	mesh->vertices[mesh->vertex_count_used + 0].position = CGL_vec4_init(-1.0f, 1.0f, -1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 0].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(-1.0f, 1.0f, -1.0f, 0.0f) : CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 0].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 1].position = CGL_vec4_init(-1.0f, -1.0f, -1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 1].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(-1.0f, -1.0f, -1.0f, 0.0f) : CGL_vec4_init(1.0f, 0.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 1].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 2].position = CGL_vec4_init(1.0f, -1.0f, -1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 2].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(1.0f, -1.0f, -1.0f, 0.0f) : CGL_vec4_init(1.0f, 1.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 2].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 3].position = CGL_vec4_init(1.0f, -1.0f, -1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 3].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(1.0f, -1.0f, -1.0f, 0.0f) : CGL_vec4_init(1.0f, 1.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 3].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 4].position = CGL_vec4_init(1.0f, 1.0f, -1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 4].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(1.0f, 1.0f, -1.0f, 0.0f) : CGL_vec4_init(0.0f, 1.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 4].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 5].position = CGL_vec4_init(-1.0f, 1.0f, -1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 5].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(-1.0f, 1.0f, -1.0f, 0.0f) : CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 5].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 6].position = CGL_vec4_init(-1.0f, -1.0f, 1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 6].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(-1.0f, -1.0f, 1.0f, 0.0f) : CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 6].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 7].position = CGL_vec4_init(-1.0f, -1.0f, -1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 7].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(-1.0f, -1.0f, -1.0f, 0.0f) : CGL_vec4_init(1.0f, 0.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 7].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 8].position = CGL_vec4_init(-1.0f, 1.0f, -1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 8].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(-1.0f, 1.0f, -1.0f, 0.0f) : CGL_vec4_init(1.0f, 1.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 8].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 9].position = CGL_vec4_init(-1.0f, 1.0f, -1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 9].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(-1.0f, 1.0f, -1.0f, 0.0f) : CGL_vec4_init(1.0f, 1.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 9].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 10].position = CGL_vec4_init(-1.0f, 1.0f, 1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 10].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(-1.0f, 1.0f, 1.0f, 0.0f) : CGL_vec4_init(0.0f, 1.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 10].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 11].position = CGL_vec4_init(-1.0f, -1.0f, 1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 11].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(-1.0f, -1.0f, 1.0f, 0.0f) : CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 11].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 12].position = CGL_vec4_init(1.0f, -1.0f, -1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 12].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(1.0f, -1.0f, -1.0f, 0.0f) : CGL_vec4_init(1.0f, 0.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 12].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 13].position = CGL_vec4_init(1.0f, -1.0f, 1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 13].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(1.0f, -1.0f, 1.0f, 0.0f) : CGL_vec4_init(1.0f, 1.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 13].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 14].position = CGL_vec4_init(1.0f, 1.0f, 1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 14].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(1.0f, 1.0f, 1.0f, 0.0f) : CGL_vec4_init(0.0f, 1.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 14].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 15].position = CGL_vec4_init(1.0f, 1.0f, 1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 15].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(1.0f, 1.0f, 1.0f, 0.0f) : CGL_vec4_init(0.0f, 1.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 15].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 16].position = CGL_vec4_init(1.0f, 1.0f, -1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 16].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(1.0f, 1.0f, -1.0f, 0.0f) : CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 16].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 17].position = CGL_vec4_init(1.0f, -1.0f, -1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 17].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(1.0f, -1.0f, -1.0f, 0.0f) : CGL_vec4_init(1.0f, 0.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 17].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 18].position = CGL_vec4_init(-1.0f, -1.0f, 1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 18].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(-1.0f, -1.0f, 1.0f, 0.0f) : CGL_vec4_init(1.0f, 0.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 18].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 19].position = CGL_vec4_init(-1.0f, 1.0f, 1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 19].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(-1.0f, 1.0f, 1.0f, 0.0f) : CGL_vec4_init(1.0f, 1.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 19].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 20].position = CGL_vec4_init(1.0f, 1.0f, 1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 20].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(1.0f, 1.0f, 1.0f, 0.0f) : CGL_vec4_init(0.0f, 1.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 20].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 21].position = CGL_vec4_init(1.0f, 1.0f, 1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 21].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(1.0f, 1.0f, 1.0f, 0.0f) : CGL_vec4_init(0.0f, 1.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 21].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 22].position = CGL_vec4_init(1.0f, -1.0f, 1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 22].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(1.0f, -1.0f, 1.0f, 0.0f) : CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 22].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 23].position = CGL_vec4_init(-1.0f, -1.0f, 1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 23].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(-1.0f, -1.0f, 1.0f, 0.0f) : CGL_vec4_init(1.0f, 0.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 23].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 24].position = CGL_vec4_init(-1.0f, 1.0f, -1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 24].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(-1.0f, 1.0f, -1.0f, 0.0f) : CGL_vec4_init(0.0f, 1.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 24].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 25].position = CGL_vec4_init(1.0f, 1.0f, -1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 25].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(1.0f, 1.0f, -1.0f, 0.0f) : CGL_vec4_init(1.0f, 1.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 25].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 26].position = CGL_vec4_init(1.0f, 1.0f, 1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 26].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(1.0f, 1.0f, 1.0f, 0.0f) : CGL_vec4_init(1.0f, 0.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 26].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 27].position = CGL_vec4_init(1.0f, 1.0f, 1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 27].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(1.0f, 1.0f, 1.0f, 0.0f) : CGL_vec4_init(1.0f, 0.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 27].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 28].position = CGL_vec4_init(-1.0f, 1.0f, 1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 28].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(-1.0f, 1.0f, 1.0f, 0.0f) : CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 28].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 29].position = CGL_vec4_init(-1.0f, 1.0f, -1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 29].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(-1.0f, 1.0f, -1.0f, 0.0f) : CGL_vec4_init(0.0f, 1.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 29].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 30].position = CGL_vec4_init(-1.0f, -1.0f, -1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 30].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(-1.0f, -1.0f, -1.0f, 0.0f) : CGL_vec4_init(0.0f, 1.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 30].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 31].position = CGL_vec4_init(-1.0f, -1.0f, 1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 31].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(-1.0f, -1.0f, 1.0f, 0.0f) : CGL_vec4_init(1.0f, 1.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 31].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 32].position = CGL_vec4_init(1.0f, -1.0f, -1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 32].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(1.0f, -1.0f, -1.0f, 0.0f) : CGL_vec4_init(1.0f, 0.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 32].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 33].position = CGL_vec4_init(1.0f, -1.0f, -1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 33].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(1.0f, -1.0f, -1.0f, 0.0f) : CGL_vec4_init(1.0f, 0.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 33].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 34].position = CGL_vec4_init(-1.0f, -1.0f, 1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 34].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(-1.0f, -1.0f, 1.0f, 0.0f) : CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 34].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	mesh->vertices[mesh->vertex_count_used + 35].position = CGL_vec4_init(1.0f, -1.0f, 1.0f, 1.0f);
	mesh->vertices[mesh->vertex_count_used + 35].texture_coordinates = (use_3d_tex_coords ? CGL_vec4_init(1.0f, -1.0f, 1.0f, 0.0f) : CGL_vec4_init(0.0f, 1.0f, 0.0f, 0.0f));
	mesh->vertices[mesh->vertex_count_used + 35].normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	for (CGL_sizei i = mesh->index_count_used; i < mesh->index_count_used + 36; i++) mesh->indices[i] = (CGL_int)i;
	mesh->vertex_count_used += 36;
	mesh->index_count_used += 36;
	return mesh;
}

CGL_mesh_cpu* CGL_mesh_cpu_cube(bool use_3d_tex_coords)
{
	CGL_mesh_cpu* mesh = CGL_mesh_cpu_create(36, 36);
	if (mesh == NULL) return NULL;
	return CGL_mesh_cpu_add_cube(mesh, use_3d_tex_coords);
}

CGL_void CGL_mesh_cpu_generate_c_initialization_code(CGL_mesh_cpu* mesh, char* buffer, const char* function_name)
{
	static char temp_buffer[1024];
	buffer[0] = '\0';
	if (!function_name) function_name = "generate_mesh";
	sprintf(temp_buffer,
		"CGL_mesh_cpu* %s()\n{\n"
		"\tCGL_mesh_cpu* mesh = CGL_mesh_cpu_create(%zu, %zu);\n"
		"\tif(mesh == NULL)\n"
		"\t\treturn NULL;\n\n",
		function_name,
		mesh->vertex_count, mesh->index_count);
	strcat(buffer, temp_buffer);
	for (CGL_sizei i = 0; i < mesh->vertex_count; i++)
	{
		sprintf(temp_buffer,
			"\tmesh->vertices[%d].position = CGL_vec4_init(%f, %f, %f, %f);\n"
			"\tmesh->vertices[%d].normal =  CGL_vec4_init(%f, %f, %f, %f);\n"
			"\tmesh->vertices[%d].texture_coordinates = CGL_vec4_init(%f, %f, %f, %f);\n"
			"\tmesh->vertices[%d].bone_wieghts = CGL_vec4_init(%f, %f, %f, %f);\n"
			"\tmesh->vertices[%d].bone_ids = CGL_ivec4_init(%d, %d, %d, %d);\n",
			(CGL_int)i, mesh->vertices[i].position.x, mesh->vertices[i].position.y, mesh->vertices[i].position.z, mesh->vertices[i].position.w,
			(CGL_int)i, mesh->vertices[i].normal.x, mesh->vertices[i].normal.y, mesh->vertices[i].normal.z, mesh->vertices[i].normal.w,
			(CGL_int)i, mesh->vertices[i].texture_coordinates.x, mesh->vertices[i].texture_coordinates.y, mesh->vertices[i].texture_coordinates.z, mesh->vertices[i].texture_coordinates.w,
			(CGL_int)i, mesh->vertices[i].bone_wieghts.x, mesh->vertices[i].bone_wieghts.y, mesh->vertices[i].bone_wieghts.z, mesh->vertices[i].bone_wieghts.w,
			(CGL_int)i, mesh->vertices[i].bone_ids.x, mesh->vertices[i].bone_ids.y, mesh->vertices[i].bone_ids.z, mesh->vertices[i].bone_ids.w
		);
		strcat(buffer, temp_buffer);
	}
	strcat(buffer, "\n\tmesh->indices = (CGL_int []){ ");
	for (CGL_sizei i = 0; i < mesh->index_count; i++)
	{
		sprintf(temp_buffer, ((i == mesh->index_count - 1) ? "%d " : "%d, "), mesh->indices[i]);
		strcat(buffer, temp_buffer);
	}
	strcat(buffer, "};\n\n\treturn mesh;");
}

// shader

bool __CGL_shader_compile(const char* source, GLenum type, GLuint* handle, char** error)
{
	GLuint shader = glCreateShader(type);
	glShaderSource(shader, 1, (const GLchar**)(&source), NULL);
	glCompileShader(shader);
	GLint status = 0;
	glGetShaderiv(shader, GL_COMPILE_STATUS, &status);
	if (status == GL_FALSE)
	{
		GLint log_length = 0;
		glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &log_length);
		char* log = (char*)malloc(log_length);
		glGetShaderInfoLog(shader, log_length, NULL, log);
		CGL_log_internal("%s\n", log);
		if (error) *error = log;
		else CGL_free(log);
		glDeleteShader(shader);
		return false;
	}
	*handle = shader;
	return true;
}

// create compute shader
CGL_shader* CGL_shader_compute_create(const char* compute_shader_source, char** error)
{
	if (error)
		*error = NULL;

	CGL_shader* shader = (CGL_shader*)malloc(sizeof(CGL_shader));
	if (shader == NULL)
		return NULL;
	shader->user_data = NULL;
	GLuint compute_shader = 0;
	if (!__CGL_shader_compile(compute_shader_source, GL_COMPUTE_SHADER, &compute_shader, error))
	{
		CGL_free(shader);
		return NULL;
	}

	GLuint program = glCreateProgram();
	glAttachShader(program, compute_shader);
	glLinkProgram(program);
	GLint status = 0;
	glGetProgramiv(program, GL_LINK_STATUS, &status);
	if (status == GL_FALSE)
	{
		GLint log_length = 0;
		glGetProgramiv(program, GL_INFO_LOG_LENGTH, &log_length);
		char* log = (char*)malloc(log_length);
		glGetProgramInfoLog(program, log_length, NULL, log);
		CGL_log_internal("%s\n", log);
		if (error) *error = log;
		else CGL_free(log);
		glDeleteProgram(program);
		glDeleteShader(compute_shader);
		CGL_free(shader);
		return NULL;
	}
	glDetachShader(program, compute_shader);
	glDeleteShader(compute_shader);
	shader->handle = program;
	return shader;
}

// create compute shader from files
CGL_shader* CGL_shader_compute_create_from_files(const char* compute_shader_file, char** error)
{
	char* compute_shader_source = CGL_utils_read_file(compute_shader_file, NULL);
	if (compute_shader_source == NULL)
	{
		CGL_log_internal("Failed to read compute shader file %s\n", compute_shader_file);
		return NULL;
	}
	CGL_shader* shader = CGL_shader_compute_create(compute_shader_source, error);
	CGL_free(compute_shader_source);
	return shader;
}

// create shader
CGL_shader* CGL_shader_create(const char* vertex_shader_source, const char* fragment_shader_source, char** error)
{
	if (error)
		*error = NULL;
	CGL_shader* shader = (CGL_shader*)malloc(sizeof(CGL_shader));
	if (shader == NULL)
		return NULL;
	shader->user_data = NULL;

	GLuint vertex_shader = 0;
	GLuint fragment_shader = 0;
	if (!__CGL_shader_compile(vertex_shader_source, GL_VERTEX_SHADER, &vertex_shader, error))
	{
		CGL_free(shader);
		return NULL;
	}

	if (!__CGL_shader_compile(fragment_shader_source, GL_FRAGMENT_SHADER, &fragment_shader, error))
	{
		glDeleteShader(vertex_shader);
		CGL_free(shader);
		return NULL;
	}

	GLuint program = glCreateProgram();
	glAttachShader(program, vertex_shader);
	glAttachShader(program, fragment_shader);
	glLinkProgram(program);
	GLint status = 0;
	glGetProgramiv(program, GL_LINK_STATUS, &status);
	if (status == GL_FALSE)
	{
		GLint log_length = 0;
		glGetProgramiv(program, GL_INFO_LOG_LENGTH, &log_length);
		char* log = (char*)malloc(log_length);
		glGetProgramInfoLog(program, log_length, NULL, log);
		CGL_log_internal("%s\n", log);
		if (error)  *error = log;
		else CGL_free(log);
		glDeleteProgram(program);
		glDeleteShader(vertex_shader);
		glDeleteShader(fragment_shader);
		CGL_free(shader);
		return NULL;
	}

	glDetachShader(program, vertex_shader);
	glDetachShader(program, fragment_shader);
	glDeleteShader(vertex_shader);
	glDeleteShader(fragment_shader);

	shader->handle = program;

	if (error)
		*error = NULL;
	return shader;
}

// create shader from files
CGL_shader* CGL_shader_create_from_files(const char* vertex_shader_file, const char* fragment_shader_file, char** error)
{
	char* vertex_shader_source = CGL_utils_read_file(vertex_shader_file, NULL);
	if (vertex_shader_source == NULL)
	{
		CGL_log_internal("Failed to read vertex shader file %s\n", vertex_shader_file);
		return NULL;
	}
	char* fragment_shader_source = CGL_utils_read_file(fragment_shader_file, NULL);
	if (fragment_shader_source == NULL)
	{
		CGL_log_internal("Failed to read fragment shader file %s\n", fragment_shader_file);
		CGL_free(vertex_shader_source);
		return NULL;
	}
	CGL_shader* shader = CGL_shader_create(vertex_shader_source, fragment_shader_source, error);
	CGL_free(vertex_shader_source);
	CGL_free(fragment_shader_source);
	return shader;
}

// destroy shader
CGL_void CGL_shader_destroy(CGL_shader* shader)
{
	glDeleteProgram(shader->handle);
	CGL_free(shader);
}

// dispatch compute shader
CGL_void CGL_shader_compute_dispatch(CGL_shader* shader, CGL_int x, CGL_int y, CGL_int z)
{
	glUseProgram(shader->handle);
	glDispatchCompute(x, y, z);
	glMemoryBarrier(GL_SHADER_STORAGE_BARRIER_BIT);
}

// bind shader
CGL_void CGL_shader_bind(CGL_shader* shader)
{
	glUseProgram(shader->handle);
}

// get uniform location
int CGL_shader_get_uniform_location(CGL_shader* shader, const char* name)
{
	(void)shader;
	return glGetUniformLocation(shader->handle, name);
}

// set uniform bool
CGL_void CGL_shader_set_uniform_bool(CGL_shader* shader, CGL_int location, bool value)
{
	(void)shader;
	glUniform1i(location, value);
}

// set uniform matrix
CGL_void CGL_shader_set_uniform_mat4(CGL_shader* shader, CGL_int location, CGL_mat4* matrix)
{
	(void)shader;
	glUniformMatrix4fv(location, 1, GL_FALSE, (GLfloat*)matrix->m);
	//glUniformMatrix4fv(location, 1, GL_TRUE, (GLfloat*)matrix);
}

// set uniform vector
CGL_void CGL_shader_set_uniform_vec4(CGL_shader* shader, CGL_int location, CGL_vec4* vector)
{
	(void)shader;
	glUniform4fv(location, 1, (GLfloat*)vector);
}

// set uniform vector
CGL_void CGL_shader_set_uniform_vec3(CGL_shader* shader, CGL_int location, CGL_vec3* vector)
{
	(void)shader;
	glUniform3fv(location, 1, (GLfloat*)vector);
}

// set uniform vector
CGL_void CGL_shader_set_uniform_vec2(CGL_shader* shader, CGL_int location, CGL_vec2* vector)
{
	(void)shader;
	glUniform2fv(location, 1, (GLfloat*)vector);
}

// set uniform int
CGL_void CGL_shader_set_uniform_int(CGL_shader* shader, CGL_int location, CGL_int value)
{
	(void)shader;
	glUniform1i(location, value);
}

// set uniform float
CGL_void CGL_shader_set_uniform_float(CGL_shader* shader, CGL_int location, CGL_float value)
{
	(void)shader;
	glUniform1f(location, value);
}

// set uniform double
CGL_void CGL_shader_set_uniform_double(CGL_shader* shader, CGL_int location, CGL_double value)
{
	(void)shader;
	glUniform1d(location, value);
}

// set uniform vector
CGL_void CGL_shader_set_uniform_vec2v(CGL_shader* shader, CGL_int location, CGL_float x, CGL_float y)
{
	(void)shader;
	glUniform2f(location, x, y);
}

// set uniform vector
CGL_void CGL_shader_set_uniform_vec3v(CGL_shader* shader, CGL_int location, CGL_float x, CGL_float y, CGL_float z)
{
	(void)shader;
	glUniform3f(location, x, y, z);
}

// set uniform vector
CGL_void CGL_shader_set_uniform_vec4v(CGL_shader* shader, CGL_int location, CGL_float x, CGL_float y, CGL_float z, CGL_float w)
{
	(void)shader;
	glUniform4f(location, x, y, z, w);
}

CGL_void CGL_shader_set_uniform_ivec2v(CGL_shader* shader, CGL_int location, CGL_int x, CGL_int y)
{
	(void)shader;
	glUniform2i(location, x, y);
}

// set uniform vector
CGL_void CGL_shader_set_uniform_ivec3v(CGL_shader* shader, CGL_int location, CGL_int x, CGL_int y, CGL_int z)
{
	(void)shader;
	glUniform3i(location, x, y, z);
}

// set uniform vector
CGL_void CGL_shader_set_uniform_ivec4v(CGL_shader* shader, CGL_int location, CGL_int x, CGL_int y, CGL_int z, CGL_int w)
{
	(void)shader;
	glUniform4i(location, x, y, z, w);
}

// set shader user data
CGL_void CGL_shader_set_user_data(CGL_shader* shader, void* user_data)
{
	shader->user_data = user_data;
}

// get shader user data
CGL_void* CGL_shader_get_user_data(CGL_shader* shader)
{
	return shader->user_data;
}


// BLOOM
#ifndef CGL_EXCLUDE_BLOOM

struct CGL_bloom
{
	CGL_texture* tex_lod[CGL_BLOOM_MAX_ITERATIONS * 2];
	CGL_texture* prefiltered;
	CGL_shader* compute;
	CGL_float offset_x;
	CGL_float offset_y;
	CGL_int width;
	CGL_int height;
	CGL_int iterations;
	CGL_float threshold;
	CGL_float knee;
	CGL_int cs_u_mode;
	CGL_int cs_u_src_size;
	CGL_int cs_u_dst_size;
	CGL_int cs_u_prefilter_threshold;
	CGL_int cs_u_offset;
};

const char* __CGL_BLOOM_SHADER_SOURCE = "#version 430 core\n"
"layout(local_size_x = 16, local_size_y = 16) in;\n"
"layout(rgba32f, binding = 0) uniform image2D tex_src;\n"
"layout(rgba32f, binding = 1) uniform image2D tex_dst;\n"
"\n"
"#define MODE_PREFILTER      0\n"
"#define MODE_DOWNSAMPLE     1\n"
"#define MODE_UPSAMPLE       2\n"
"#define MODE_COMPOSITE      3\n"
"\n"
"uniform int u_mode;\n"
"uniform vec2 u_src_size;\n"
"uniform ivec2 u_offset;\n"
"uniform vec2 u_dst_size;\n"
"uniform vec4 u_prefilter_threshold;\n"
"\n"
"vec4 prefilter(vec4 color)\n"
"{\n"
"    // pixel brightness\n"
"    float br = max(color.x, max(color.y, color.z));\n"
"\n"
"    // under-threshold part : quadratic curve\n"
"    vec3 curve = u_prefilter_threshold.yzw; // curve = (threshold - knee, knee * 2, 0.25 / knee)\n"
"    float rq = clamp(br - curve.x, 0.0f, curve.y);\n"
"    rq = curve.z * rq * rq;\n"
"\n"
"    //  combine and apply the brightness response curve\n"
"    float threshold = u_prefilter_threshold.x;\n"
"    color *= max(rq, br - threshold) / max(br, 0.00001f);\n"
"    //color *= (br - threshold) / max(br, 0.00001f);\n"
"\n"
"    return color;\n"
"}\n"
"\n"
"vec4 downsample_box_13_tap(ivec2 src_coord)\n"
"{\n"
"    vec4 A = imageLoad(tex_src, src_coord + ivec2(-2, -2));\n"
"    vec4 B = imageLoad(tex_src, src_coord + ivec2( 0, -2));\n"
"    vec4 C = imageLoad(tex_src, src_coord + ivec2( 2, -2));\n"
"    vec4 D = imageLoad(tex_src, src_coord + ivec2(-1, -1));\n"
"    vec4 E = imageLoad(tex_src, src_coord + ivec2( 1, -1));\n"
"    vec4 F = imageLoad(tex_src, src_coord + ivec2(-2,  0));\n"
"    vec4 G = imageLoad(tex_src, src_coord                );\n"
"    vec4 H = imageLoad(tex_src, src_coord + ivec2( 2,  0));\n"
"    vec4 I = imageLoad(tex_src, src_coord + ivec2(-1,  1));\n"
"    vec4 J = imageLoad(tex_src, src_coord + ivec2( 1,  1));\n"
"    vec4 K = imageLoad(tex_src, src_coord + ivec2(-2,  2));\n"
"    vec4 L = imageLoad(tex_src, src_coord + ivec2( 0,  2));\n"
"    vec4 M = imageLoad(tex_src, src_coord + ivec2( 2,  2));\n"
"\n"
"    vec2 div = (1.0f / 4.0f) * vec2(0.5f, 0.125f);\n"
"\n"
"    vec4 o = (D + E + I + J) * div.x;\n"
"    o += (A + B + G + F) * div.y;\n"
"    o += (B + C + H + G) * div.y;\n"
"    o += (F + G + L + K) * div.y;\n"
"    o += (G + H + M + L) * div.y;\n"
"\n"
"        //pixel = imageLoad(tex_src, pixel_coords);\n"
"    return o;\n"
"}\n"
"\n"
"vec4 upsample_tent(ivec2 src_coord)\n"
"{\n"
"    ivec4 d = ivec4(1, 1, -1, 0);\n"
"\n"
"    vec4 s;\n"
"    s =  imageLoad(tex_src, src_coord - d.xy);\n"
"    s += imageLoad(tex_src, src_coord - d.wy) * 2.0f;\n"
"    s += imageLoad(tex_src, src_coord - d.zy);\n"
"    s += imageLoad(tex_src, src_coord + d.zw) * 2.0f;\n"
"    s += imageLoad(tex_src, src_coord       ) * 4.0f;\n"
"    s += imageLoad(tex_src, src_coord + d.xw) * 2.0f;\n"
"    s += imageLoad(tex_src, src_coord + d.zy);\n"
"    s += imageLoad(tex_src, src_coord + d.wy) * 2.0f;\n"
"    s += imageLoad(tex_src, src_coord + d.xy);\n"
"\n"
"    return s * (1.0f / 16.0f);\n"
"}\n"
"\n"
"vec3 aces_tonemap(vec3 x){	\n"
"	const float a = 2.51f;\n"
"    const float b = 0.03f;\n"
"    const float c = 2.43f;\n"
"    const float d = 0.59f;\n"
"    const float e = 0.14f;\n"
"    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0f, 1.0f);\n"
"}\n"
"\n"
"void main() {\n"
"    if(u_mode == MODE_PREFILTER)\n"
"    {\n"
"        vec4 pixel = vec4(1.0f, 1.0f, 0.0f, 1.0f);    \n"
"        ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);    \n"
"        pixel = imageLoad(tex_src, pixel_coords);\n"
"        imageStore(tex_dst, pixel_coords, prefilter(pixel));\n"
"    }\n"
"    else if(u_mode == MODE_DOWNSAMPLE)\n"
"    {\n"
"        vec4 pixel = vec4(1.0f, 0.0f, 1.0f, 1.0f);    \n"
"        ivec2 dst_pixel_coords = ivec2(gl_GlobalInvocationID.xy);    \n"
"        vec2 uv = vec2(dst_pixel_coords) / u_dst_size;\n"
"        ivec2 src_pixel_coords = ivec2(uv * u_src_size);\n"
"        imageStore(tex_dst, dst_pixel_coords, downsample_box_13_tap(src_pixel_coords));\n"
"    }\n"
"    else if(u_mode == MODE_UPSAMPLE)\n"
"    {\n"
"        vec4 pixel = vec4(1.0f, 0.0f, 1.0f, 1.0f);    \n"
"        ivec2 dst_pixel_coords = ivec2(gl_GlobalInvocationID.xy);    \n"
"        vec2 uv = vec2(dst_pixel_coords) / u_dst_size;\n"
"        ivec2 src_pixel_coords = ivec2(uv * u_src_size);\n"
"        imageStore(tex_dst, dst_pixel_coords, upsample_tent(src_pixel_coords));\n"
"    }\n"
"    else if(u_mode == MODE_COMPOSITE)\n"
"    {\n"
"        vec4 pixel = vec4(0.0f, 0.0f, 0.0f, 0.0f);    \n"
"        ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);\n"
"        ivec2 pixel_coords2 = ivec2(gl_GlobalInvocationID.xy) + u_offset;\n"
"        pixel += imageLoad(tex_dst, pixel_coords); \n"
"        pixel += imageLoad(tex_src, pixel_coords2); \n"
"        pixel = vec4(pixel.xyz, clamp(pixel.w, 0.0f, 1.0f));\n"
"        imageStore(tex_dst, pixel_coords, pixel); \n"
"    }\n"
"    else\n"
"    {\n"
"        vec4 pixel = vec4(1.0f, 0.0f, 0.0f, 1.0f);    \n"
"        ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);\n"
"        imageStore(tex_dst, pixel_coords, pixel);\n"
"    }\n"
"}";

CGL_bloom* CGL_bloom_create(CGL_int width, CGL_int height, CGL_int iterations)
{
	CGL_bloom* bloom = (CGL_bloom*)CGL_malloc(sizeof(CGL_bloom));
	if (bloom == NULL) return NULL;
	bloom->threshold = 0.5f;
	bloom->knee = 0.5f;
	bloom->iterations = 0;
	bloom->width = width;
	bloom->height = height;
	bloom->offset_x = 0.0f;
	bloom->offset_y = 0.0f;
	iterations = CGL_utils_min(CGL_utils_max(1, iterations), CGL_BLOOM_MAX_ITERATIONS);
	bloom->prefiltered = CGL_texture_create_blank(width, height, GL_RGBA, GL_RGBA32F, GL_FLOAT);
	CGL_int i = 0;
	for (i = 0; i < iterations; i++)
	{
		width /= 2; height /= 2;
		if (width < 10 || height < 10)
		{
			width *= 2; height *= 2;
			iterations = i;
			break;
		}
		bloom->tex_lod[i] = CGL_texture_create_blank(width, height, GL_RGBA, GL_RGBA32F, GL_FLOAT);
	}
	for (; i < 2 * iterations; i++)
	{
		width *= 2; height *= 2;
		if (i == 2 * iterations - 1) { width = bloom->width; height = bloom->height; }
		bloom->tex_lod[i] = CGL_texture_create_blank(width, height, GL_RGBA, GL_RGBA32F, GL_FLOAT);
	}
	bloom->iterations = iterations;
	bloom->compute = CGL_shader_compute_create(__CGL_BLOOM_SHADER_SOURCE, NULL);
	bloom->cs_u_mode = CGL_shader_get_uniform_location(bloom->compute, "u_mode");
	bloom->cs_u_src_size = CGL_shader_get_uniform_location(bloom->compute, "u_src_size");
	bloom->cs_u_dst_size = CGL_shader_get_uniform_location(bloom->compute, "u_dst_size");
	bloom->cs_u_prefilter_threshold = CGL_shader_get_uniform_location(bloom->compute, "u_prefilter_threshold");
	bloom->cs_u_offset = CGL_shader_get_uniform_location(bloom->compute, "u_offset");
	return bloom;
}

CGL_void CGL_bloom_destroy(CGL_bloom* bloom)
{
	CGL_texture_destroy(bloom->prefiltered);
	for (CGL_int i = 0; i < bloom->iterations * 2; i++)
		CGL_texture_destroy(bloom->tex_lod[i]);
	CGL_shader_destroy(bloom->compute);
	CGL_free(bloom);
}

CGL_void CGL_bloom_apply2(CGL_bloom* bloom, CGL_texture* tex_src, CGL_texture* tex_dst)
{
	CGL_shader_bind(bloom->compute);

	// prefilter
	glBindImageTexture(0, tex_src->handle, 0, GL_FALSE, 0, GL_READ_ONLY, GL_RGBA32F);
	glBindImageTexture(1, bloom->prefiltered->handle, 0, GL_FALSE, 0, GL_WRITE_ONLY, GL_RGBA32F);
	CGL_shader_set_uniform_int(bloom->compute, bloom->cs_u_mode, CGL_BLOOM_SHADER_MODE_PREFILTER);
	CGL_shader_set_uniform_vec2v(bloom->compute, bloom->cs_u_src_size, (float)bloom->width, (float)bloom->height);
	CGL_shader_set_uniform_vec2v(bloom->compute, bloom->cs_u_dst_size, (float)bloom->width, (float)bloom->height);
	CGL_shader_set_uniform_vec4v(bloom->compute, bloom->cs_u_prefilter_threshold, bloom->threshold, bloom->threshold - bloom->knee, bloom->knee * 2.0f, 0.25f / bloom->knee);
	CGL_shader_compute_dispatch(bloom->compute, bloom->width / 16 + 1, bloom->height / 16 + 1, 1);
	glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);

	// downsample
	glBindImageTexture(0, bloom->prefiltered->handle, 0, GL_FALSE, 0, GL_READ_ONLY, GL_RGBA32F);
	glBindImageTexture(1, bloom->tex_lod[0]->handle, 0, GL_FALSE, 0, GL_WRITE_ONLY, GL_RGBA32F);
	CGL_shader_set_uniform_int(bloom->compute, bloom->cs_u_mode, CGL_BLOOM_SHADER_MODE_DOWNSAMPLE);
	CGL_shader_set_uniform_vec2v(bloom->compute, bloom->cs_u_src_size, (float)bloom->width, (float)bloom->height);
	CGL_shader_set_uniform_vec2v(bloom->compute, bloom->cs_u_dst_size, (float)bloom->tex_lod[0]->width, (float)bloom->tex_lod[0]->height);
	CGL_shader_compute_dispatch(bloom->compute, bloom->tex_lod[0]->width / 16 + 1, bloom->tex_lod[0]->height / 16 + 1, 1);
	glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);

	CGL_int i = 0;
	for (i = 0; i < bloom->iterations - 1; i++)
	{
		glBindImageTexture(0, bloom->tex_lod[i]->handle, 0, GL_FALSE, 0, GL_READ_ONLY, GL_RGBA32F);
		glBindImageTexture(1, bloom->tex_lod[i + 1]->handle, 0, GL_FALSE, 0, GL_WRITE_ONLY, GL_RGBA32F);
		CGL_shader_set_uniform_int(bloom->compute, bloom->cs_u_mode, CGL_BLOOM_SHADER_MODE_DOWNSAMPLE);
		CGL_shader_set_uniform_vec2v(bloom->compute, bloom->cs_u_src_size, (float)bloom->tex_lod[i]->width, (float)bloom->tex_lod[i]->height);
		CGL_shader_set_uniform_vec2v(bloom->compute, bloom->cs_u_dst_size, (float)bloom->tex_lod[i + 1]->width, (float)bloom->tex_lod[i + 1]->height);
		CGL_shader_compute_dispatch(bloom->compute, bloom->tex_lod[i + 1]->width / 16 + 1, bloom->tex_lod[i + 1]->height / 16 + 1, 1);
		glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);
	}

	// upsample
	for (; i < 2 * bloom->iterations - 1; i++)
	{
		glBindImageTexture(0, bloom->tex_lod[i]->handle, 0, GL_FALSE, 0, GL_READ_ONLY, GL_RGBA32F);
		glBindImageTexture(1, bloom->tex_lod[i + 1]->handle, 0, GL_FALSE, 0, GL_WRITE_ONLY, GL_RGBA32F);
		CGL_shader_set_uniform_int(bloom->compute, bloom->cs_u_mode, CGL_BLOOM_SHADER_MODE_UPSAMPLE);
		CGL_shader_set_uniform_vec2v(bloom->compute, bloom->cs_u_src_size, (float)bloom->tex_lod[i]->width, (float)bloom->tex_lod[i]->height);
		CGL_shader_set_uniform_vec2v(bloom->compute, bloom->cs_u_dst_size, (float)bloom->tex_lod[i + 1]->width, (float)bloom->tex_lod[i + 1]->height);
		CGL_shader_compute_dispatch(bloom->compute, bloom->tex_lod[i + 1]->width / 16 + 1, bloom->tex_lod[i + 1]->height / 16 + 1, 1);
		glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);
	}

	// composite
	glBindImageTexture(0, bloom->tex_lod[bloom->iterations * 2 - 1]->handle, 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
	glBindImageTexture(1, tex_dst->handle, 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
	CGL_shader_set_uniform_int(bloom->compute, bloom->cs_u_mode, CGL_BLOOM_SHADER_MODE_COMPOSITE);
	CGL_shader_set_uniform_vec2v(bloom->compute, bloom->cs_u_src_size, (float)bloom->width, (float)bloom->height);
	CGL_shader_set_uniform_vec2v(bloom->compute, bloom->cs_u_dst_size, (float)bloom->width, (float)bloom->height);
	CGL_shader_set_uniform_ivec2v(bloom->compute, bloom->cs_u_offset, (int)bloom->offset_x, (int)bloom->offset_y);
	CGL_shader_compute_dispatch(bloom->compute, bloom->width / 16 + 1, bloom->height / 16 + 1, 1);
	glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);
}

CGL_void CGL_bloom_apply(CGL_bloom* bloom, CGL_texture* tex)
{
	CGL_bloom_apply2(bloom, tex, tex);
}

CGL_texture* CGL_bloom_get_lod_texture(CGL_bloom* bloom, CGL_int index)
{
	return bloom->tex_lod[index];
}

CGL_texture* CGL_bloom_get_prefiltered_texture(CGL_bloom* bloom)
{
	return bloom->prefiltered;
}

CGL_void CGL_bloom_set_knee(CGL_bloom* bloom, CGL_float val)
{
	bloom->knee = val;
}

float CGL_bloom_get_knee(CGL_bloom* bloom)
{
	return bloom->knee;
}

CGL_void CGL_bloom_set_threshold(CGL_bloom* bloom, CGL_float val)
{
	bloom->threshold = val;
}

float CGL_bloom_get_threshold(CGL_bloom* bloom)
{
	return bloom->threshold;
}

int CGL_bloom_get_iterations(CGL_bloom* bloom)
{
	return bloom->iterations;
}

CGL_void CGL_bloom_set_offset(CGL_bloom* bloom, CGL_float x, CGL_float y)
{
	bloom->offset_x = x;
	bloom->offset_y = y;
}

#endif

#endif

#endif

// camera
#if 1

struct CGL_camera
{
	bool is_perspective;
	CGL_vec4 ortho_limits;
	CGL_vec3 position;
	CGL_vec3 rotation;
	CGL_vec3 front;
	CGL_vec3 right;
	CGL_vec3 up;
	CGL_float fov;
	CGL_float aspect;
	CGL_float z_near;
	CGL_float z_far;
	CGL_mat4 projection;
	CGL_mat4 view;
	CGL_mat4 pv;
};

CGL_camera* CGL_camera_create()
{
	CGL_camera* camera = (CGL_camera*)malloc(sizeof(CGL_camera));
	if (!camera) return NULL;
	camera->is_perspective = true;
	camera->ortho_limits = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	camera->position = CGL_vec3_init(0.0f, 0.0f, -1.0f);
	camera->rotation = CGL_vec3_init(0.0f, 0.0f, 0.0f);
	camera->fov = 45.0f;
	camera->aspect = 1.0f;
	camera->z_near = 0.001f;
	camera->z_far = 1000.0f;
	return camera;
}

CGL_void CGL_camera_destroy(CGL_camera* camera)
{
	CGL_free(camera);
}

bool CGL_camera_is_perspective(CGL_camera* camera)
{
	return camera->is_perspective;
}

bool CGL_camera_is_orthographic(CGL_camera* camera)
{
	return !camera->is_perspective;
}

float CGL_camera_get_fov(CGL_camera* camera)
{
	return camera->fov;
}

float CGL_camera_get_aspect_ratio(CGL_camera* camera)
{
	return camera->aspect;
}

float CGL_camera_get_z_near(CGL_camera* camera)
{
	return camera->z_near;
}

float CGL_camera_get_z_far(CGL_camera* camera)
{
	return camera->z_far;
}

CGL_vec4 CGL_camera_get_orthographic_limits(CGL_camera* camera)
{
	return camera->ortho_limits;
}

CGL_void CGL_camera_set_fov(CGL_camera* camera, CGL_float fov)
{
	camera->fov = fov;
}

CGL_void CGL_camera_set_aspect_ratio(CGL_camera* camera, CGL_float aspect_ratio)
{
	if (fabs(aspect_ratio) < 0.001f || fabs(aspect_ratio) > 100.0f)aspect_ratio = 1.0f;
	camera->aspect = aspect_ratio;
}

CGL_void CGL_camera_set_z_near(CGL_camera* camera, CGL_float z_near)
{
	camera->z_near = z_near;
}

CGL_void CGL_camera_set_z_far(CGL_camera* camera, CGL_float z_far)
{
	camera->z_far = z_far;
}

CGL_void CGL_camera_set_orthographic_limits(CGL_camera* camera, CGL_vec4 ortho_limits)
{
	camera->ortho_limits = ortho_limits;
}

CGL_void CGL_camera_set_perspective(CGL_camera* camera)
{
	camera->is_perspective = true;
}

CGL_void CGL_camera_set_orthographic(CGL_camera* camera)
{
	camera->is_perspective = false;
}

CGL_mat4 CGL_camera_get_projection_mat(CGL_camera* camera)
{
	return camera->projection;
}

CGL_mat4* CGL_camera_get_projection_mat_ptr(CGL_camera* camera)
{
	return &camera->projection;
}

CGL_mat4 CGL_camera_get_view_mat(CGL_camera* camera)
{
	return camera->view;
}

CGL_mat4* CGL_camera_get_view_mat_ptr(CGL_camera* camera)
{
	return &camera->view;
}

CGL_mat4 CGL_camera_get_pv_mat(CGL_camera* camera)
{
	return camera->pv;
}

CGL_mat4* CGL_camera_get_pv_mat_ptr(CGL_camera* camera)
{
	return &camera->pv;
}

CGL_void CGL_camera_set_position(CGL_camera* camera, CGL_vec3 position)
{
	camera->position = position;
}

CGL_void CGL_camera_set_rotation(CGL_camera* camera, CGL_vec3 rotation)
{
	camera->rotation = rotation;
}

CGL_vec3 CGL_camera_get_position(CGL_camera* camera)
{
	return camera->position;
}

CGL_vec3 CGL_camera_get_rotation(CGL_camera* camera)
{
	return camera->rotation;
}

CGL_vec3* CGL_camera_get_position_ptr(CGL_camera* camera)
{
	return &camera->position;
}

CGL_vec3* CGL_camera_get_rotation_ptr(CGL_camera* camera)
{
	return &camera->rotation;
}

CGL_vec3 CGL_camera_get_front(CGL_camera* camera)
{
	return camera->front;
}

CGL_vec3 CGL_camera_get_right(CGL_camera* camera)
{
	return camera->right;
}

CGL_vec3 CGL_camera_get_up(CGL_camera* camera)
{
	return camera->up;
}

CGL_void CGL_camera_recalculate_mat(CGL_camera* camera)
{
	if (camera->is_perspective)
		camera->projection = CGL_mat4_perspective(camera->aspect, camera->fov, camera->z_near, camera->z_far);
	else
	{
		printf("Ortho graphic projections not yet supported!\n"); CGL_exit(EXIT_FAILURE);
	}

	CGL_vec3 z_axis = CGL_vec3_init(0.0f, 0.0f, 1.0f);
	z_axis = CGL_vec3_rotate_x(z_axis, camera->rotation.x);
	z_axis = CGL_vec3_rotate_y(z_axis, camera->rotation.y);
	z_axis = CGL_vec3_rotate_z(z_axis, camera->rotation.z);
	camera->front = z_axis;

	CGL_vec3 x_axis = CGL_vec3_init(1.0f, 0.0f, 0.0f);
	x_axis = CGL_vec3_rotate_x(x_axis, camera->rotation.x);
	x_axis = CGL_vec3_rotate_y(x_axis, camera->rotation.y);
	x_axis = CGL_vec3_rotate_z(x_axis, camera->rotation.z);
	camera->right = x_axis;

	CGL_vec3 y_axis = CGL_vec3_cross(z_axis, x_axis);
	camera->up = y_axis;

	camera->view.m[0] = x_axis.x;
	camera->view.m[1] = x_axis.y;
	camera->view.m[2] = x_axis.z;
	camera->view.m[3] = -1.0f * CGL_vec3_dot(camera->position, x_axis);
	camera->view.m[4] = y_axis.x;
	camera->view.m[5] = y_axis.y;
	camera->view.m[6] = y_axis.z;
	camera->view.m[7] = -1.0f * CGL_vec3_dot(camera->position, y_axis);
	camera->view.m[8] = z_axis.x;
	camera->view.m[9] = z_axis.y;
	camera->view.m[10] = z_axis.z;
	camera->view.m[11] = -1.0f * CGL_vec3_dot(camera->position, z_axis);
	camera->view.m[12] = 0.0f;
	camera->view.m[13] = 0.0f;
	camera->view.m[14] = 0.0f;
	camera->view.m[15] = 1.0f;

	camera->pv = CGL_mat4_mul(camera->projection, camera->view);
}

#endif

// phong renderer
#ifndef CGL_EXCLUDE_GRAPHICS_API // cannot have PHONG RENDERER without Graphics API

// The phong renderer
#if 1
#ifndef CGL_EXCLUDE_PHONG_RENDERER


struct CGL_phong_mat
{
	bool use_diffuse_texture;
	CGL_vec3 diffuse_color;
	CGL_texture* diffuse_texture;
	CGL_image* diffuse_image;
	bool use_specular_texture;
	CGL_vec3 specular_color;
	CGL_texture* specular_texture;
	CGL_image* specular_image;
	bool use_normal_map;
	CGL_texture* normal_map_texture;
	CGL_image* normal_map_image;
	CGL_float shininess;
	bool wireframe;
	void* user_data;
};

struct CGL_phong_pipeline
{
	bool use_blinn;
	CGL_shader* shader;
	CGL_phong_light* lights[CGL_PHONG_MAX_LIGHTS];
	CGL_vec3 ambient_light_color;
	CGL_float ambient_light_strength;
	uint32_t light_count;
	bool use_gamma_correction;
	bool depth_testing;
	void* user_data;
	// uniform locations
	CGL_int u_lights_v4[4][CGL_PHONG_MAX_LIGHTS];
	CGL_int u_projection;
	CGL_int u_view;
	CGL_int u_pv;
	CGL_int u_model_matrix;
	CGL_int u_light_count;
	CGL_int u_use_diffuse_texture;
	CGL_int u_diffuse_color;
	CGL_int u_diffuse_texture;
	CGL_int u_use_specular_texture;
	CGL_int u_specular_color;
	CGL_int u_specular_texture;
	CGL_int u_use_normal_map;
	CGL_int u_normal_map_texture;
	CGL_int u_shininess;
	CGL_int u_camera_position;
	CGL_int u_use_blinn;
	CGL_int u_ambient_light_color;
	CGL_int u_ambient_light_strength;
	CGL_int u_use_gamma_correction;
};

struct CGL_phong_light
{
	uint32_t light_type;
	CGL_vec3 vector;
	CGL_vec3 color;
	CGL_float intensity;
	CGL_float constant;
	CGL_float linear;
	CGL_float quadratic;
	void* user_data;
};

static const char* __CGL_PHONG_VERTEX_SHADER =
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
"\n"
"in vec4 position;\n"
"in vec4 normal;\n"
"in vec4 texcoord;\n"
#else
"#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 normal;\n"
"layout (location = 2) in vec4 texcoord;\n"
#endif
"\n"
"out vec3 Position;\n"
"out vec3 Normal;\n"
"out vec2 TexCoord; \n"
"\n"
"uniform mat4 u_projection;\n"
"uniform mat4 u_view;\n"
"uniform mat4 u_pv;\n"
"uniform mat4 u_model_matrix;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = u_projection * u_view * transpose(u_model_matrix) * vec4(position.xyz, 1.0f);\n"
"	Position = (transpose(u_model_matrix) * position).xyz;\n"
"	Normal = normal.xyz;\n"
"	TexCoord = texcoord.xy;		\n"
"}";


static const char* __CGL_PHONG_FRAGMENT_SHADER =
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
#else
"#version 430 core\n"
#endif
"\n"
"#define MAX_LIGHTS             16\n"
"\n"
"#define LIGHT_TYPE_DIRECTIONAL      0.5f\n"
"#define LIGHT_TYPE_POINT            1.5f\n"
"#define LIGHT_TYPE_SPOT             2.5f\n"
"#define LIGHT_TYPE(index)      u_lights_data_1[index].x\n"
"#define LIGHT_CONSTANT(index ) u_lights_data_1[index].y\n"
"#define LIGHT_LINEAR(index)    u_lights_data_1[index].z\n"
"#define LIGHT_QUADRATIC(index) u_lights_data_1[index].w\n"
"#define LIGHT_COLOR(index)     vec4(u_lights_data_0[index].xyz, 1.0f)\n"
"#define LIGHT_INTENSITY(index) u_lights_data_0[index].w\n"
"#define LIGHT_VECTOR(index)    u_lights_data_2[index].xyz\n"
"\n"
"out vec4 FragColor;\n"
"//out CGL_int MousePick0;\n"
"//out CGL_int MousePick1;\n"
"//out CGL_int MousePick2;\n"
"in vec3 Position;\n"
"in vec3 Normal;\n"
"in vec2 TexCoord;\n"
"\n"
"\n"
"// unifroms\n"
"uniform vec4 u_lights_data_0[MAX_LIGHTS];\n"
"uniform vec4 u_lights_data_1[MAX_LIGHTS];\n"
"uniform vec4 u_lights_data_2[MAX_LIGHTS];\n"
"uniform vec4 u_lights_data_3[MAX_LIGHTS];\n"
"\n"
"uniform mat4 u_projection;\n"
"uniform mat4 u_view;\n"
"uniform mat4 u_pv;\n"
"uniform mat4 u_model_matrix;\n"
"uniform int u_light_count;\n"
"uniform bool u_use_diffuse_texture;\n"
"uniform vec3 u_diffuse_color;\n"
"uniform sampler2D u_diffuse_texture;\n"
"uniform bool u_use_specular_texture;\n"
"uniform vec3 u_specular_color;\n"
"uniform sampler2D u_specular_texture;\n"
"uniform bool u_use_normal_map;\n"
"uniform sampler2D u_normal_map_texture;\n"
"uniform float u_shininess;\n"
"uniform vec3 u_camera_position;\n"
"uniform bool u_use_blinn;\n"
"uniform vec3 u_ambient_light_color;\n"
"uniform float u_ambient_light_strength;\n"
"uniform bool u_use_gamma_correction;\n"
"\n"
"vec4 get_material_diffuse_color()\n"
"{\n"
"    if(u_use_diffuse_texture)\n"
"        return vec4(pow(texture(u_diffuse_texture, TexCoord).xyz, vec3(2.2f)), 1.0f);\n"
"    return vec4(u_diffuse_color, 1.0f);\n"
"}\n"
"\n"
"vec4 get_material_specular_color()\n"
"{\n"
"    if(u_use_specular_texture)\n"
"        return vec4(pow(texture(u_specular_texture, TexCoord).xyz, vec3(2.2f)), 1.0f);\n"
"    return vec4(u_specular_color, 1.0f);\n"
"}\n"
"\n"
"\n"
"vec3 aces_tonemap(vec3 x){	\n"
"	const float a = 2.51f;\n"
"    const float b = 0.03f;\n"
"    const float c = 2.43f;\n"
"    const float d = 0.59f;\n"
"    const float e = 0.14f;\n"
"    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0f, 1.0f);\n"
"}\n"
"\n"
"vec4 calculate_directional_light(int index)\n"
"{\n"
"    vec3 light_direcion = normalize(-LIGHT_VECTOR(index));\n"
"    // diffuse shading\n"
"    float diff = max(dot(Normal, light_direcion), 0.0f);\n"
"    // specular shading\n"
"    vec3 view_dir = normalize(u_camera_position - Position);\n"
"    float spec = 0.0f;\n"
"    if(u_use_blinn)\n"
"    {\n"
"        vec3 halfway_direction = normalize(light_direcion + view_dir);\n"
"        spec = pow(max(dot(view_dir, halfway_direction), 0.0f), u_shininess);\n"
"    }\n"
"    else\n"
"    {\n"
"        vec3 reflect_direction = reflect(-light_direcion, Normal);\n"
"        spec = pow(max(dot(view_dir, reflect_direction), 0.0f), u_shininess);\n"
"    }\n"
"    vec4 material_diffuse = get_material_diffuse_color();\n"
"    vec4 material_specular = get_material_specular_color();\n"
"    vec4 ambient_lighting = vec4(u_ambient_light_color * u_ambient_light_strength, 1.0f);\n"
"    vec4 diffuse_lighting = LIGHT_COLOR(index) * diff * material_diffuse;\n"
"    vec4 specular_lighting = LIGHT_COLOR(index) * spec * material_specular;\n"
"    return (ambient_lighting + diffuse_lighting + specular_lighting) * LIGHT_INTENSITY(index);\n"
"}\n"
"\n"
"vec4 calculate_point_light(int index)\n"
"{\n"
"    vec3 light_direcion = normalize(LIGHT_VECTOR(index) - Position);\n"
"    // diffuse shading\n"
"    float diff = max(dot(Normal, light_direcion), 0.0f);\n"
"    // specular shading\n"
"    vec3 view_dir = normalize(u_camera_position - Position);\n"
"    float spec = 0.0f;\n"
"    if(u_use_blinn)\n"
"    {\n"
"        vec3 halfway_direction = normalize(light_direcion + view_dir);\n"
"        spec = pow(max(dot(view_dir, halfway_direction), 0.0f), u_shininess);\n"
"    }\n"
"    else\n"
"    {\n"
"        vec3 reflect_direction = reflect(-light_direcion, Normal);\n"
"        spec = pow(max(dot(view_dir, reflect_direction), 0.0f), u_shininess);\n"
"    }\n"
"\n"
"    vec4 material_diffuse = get_material_diffuse_color();\n"
"    vec4 material_specular = get_material_specular_color();\n"
"    // attrnuation\n"
"    float distance = length(LIGHT_VECTOR(index) - Position);\n"
"    float attenuation = 1.0f / ( LIGHT_CONSTANT(index) + LIGHT_LINEAR(index) * distance + LIGHT_QUADRATIC(index) * (distance * distance));\n"
"    vec4 ambient_lighting = vec4(u_ambient_light_color * u_ambient_light_strength, 1.0f);\n"
"    vec4 diffuse_lighting = LIGHT_COLOR(index) * diff * material_diffuse;\n"
"    vec4 specular_lighting = LIGHT_COLOR(index) * spec * material_specular;\n"
"    return (ambient_lighting + diffuse_lighting + specular_lighting) * attenuation * LIGHT_INTENSITY(index);\n"
"}\n"
"\n"
"vec4 calculate_spot_light(int index)\n"
"{\n"
"    return vec4(0.0f);\n"
"}\n"
"\n"
"\n"
"void main()\n"
"{\n"
"    vec4 color = vec4(0.0f, 1.0f, 0.0f, 1.0f);\n"
"    vec4 light_output = vec4(0.0f);\n"
"    for ( int i = 0 ; i < u_light_count ; i++)\n"
"    {\n"
"        if(LIGHT_TYPE(i) < LIGHT_TYPE_DIRECTIONAL)\n"
"            light_output += calculate_directional_light(i);\n"
"        else if(LIGHT_TYPE(i) < LIGHT_TYPE_POINT)\n"
"            light_output += calculate_point_light(i);\n"
"        else if(LIGHT_TYPE(i) < LIGHT_TYPE_SPOT)        \n"
"            light_output += calculate_spot_light(i);\n"
"    }\n"
"\n"
"    light_output.xyz = aces_tonemap(light_output.xyz);\n"
"    if(u_use_gamma_correction)\n"
"        color = vec4(pow(light_output.xyz, vec3(0.4545f)), light_output.w);\n"
"    else\n"
"        color = light_output;\n"
"\n"
"    FragColor = color;\n"
"    //MousePick0 = InstanceID;\n"
"    //MousePick1 = 0;\n"
"    //MousePick2 = 1;\n"
"}";

// pipeline_create
CGL_phong_pipeline* CGL_phong_pipeline_create()
{
	CGL_phong_pipeline* pipeline = (CGL_phong_pipeline*)malloc(sizeof(CGL_phong_pipeline));
	pipeline->use_blinn = false;
	memset(pipeline->lights, 0, sizeof(pipeline->lights));
	pipeline->light_count = 0;
	pipeline->ambient_light_color = CGL_vec3_init(0.18f, 0.18f, 0.18f);
	pipeline->ambient_light_strength = 1.0f;
	pipeline->use_gamma_correction = true;
	pipeline->depth_testing = true;
	pipeline->user_data = NULL;
	pipeline->shader = CGL_shader_create(__CGL_PHONG_VERTEX_SHADER, __CGL_PHONG_FRAGMENT_SHADER, NULL);
	// Load uniforms
	pipeline->u_projection = CGL_shader_get_uniform_location(pipeline->shader, "u_projection");
	pipeline->u_view = CGL_shader_get_uniform_location(pipeline->shader, "u_view");
	pipeline->u_pv = CGL_shader_get_uniform_location(pipeline->shader, "u_pv");
	pipeline->u_light_count = CGL_shader_get_uniform_location(pipeline->shader, "u_light_count");
	pipeline->u_use_diffuse_texture = CGL_shader_get_uniform_location(pipeline->shader, "u_use_diffuse_texture");
	pipeline->u_diffuse_color = CGL_shader_get_uniform_location(pipeline->shader, "u_diffuse_color");
	pipeline->u_diffuse_texture = CGL_shader_get_uniform_location(pipeline->shader, "u_diffuse_texture");
	pipeline->u_use_specular_texture = CGL_shader_get_uniform_location(pipeline->shader, "u_use_specular_texture");
	pipeline->u_specular_color = CGL_shader_get_uniform_location(pipeline->shader, "u_specular_color");
	pipeline->u_specular_texture = CGL_shader_get_uniform_location(pipeline->shader, "u_specular_texture");
	pipeline->u_use_normal_map = CGL_shader_get_uniform_location(pipeline->shader, "u_use_normal_map");
	pipeline->u_normal_map_texture = CGL_shader_get_uniform_location(pipeline->shader, "u_normal_map_texture");
	pipeline->u_shininess = CGL_shader_get_uniform_location(pipeline->shader, "u_shininess");
	pipeline->u_camera_position = CGL_shader_get_uniform_location(pipeline->shader, "u_camera_position");
	pipeline->u_use_blinn = CGL_shader_get_uniform_location(pipeline->shader, "u_use_blinn");
	pipeline->u_model_matrix = CGL_shader_get_uniform_location(pipeline->shader, "u_model_matrix");
	pipeline->u_ambient_light_color = CGL_shader_get_uniform_location(pipeline->shader, "u_ambient_light_color");
	pipeline->u_ambient_light_strength = CGL_shader_get_uniform_location(pipeline->shader, "u_ambient_light_strength");
	pipeline->u_use_gamma_correction = CGL_shader_get_uniform_location(pipeline->shader, "u_use_gamma_correction");
	static char temp_buffer[256];
	for (CGL_int i = 0; i < 4; i++)
	{
		for (CGL_int j = 0; j < CGL_PHONG_MAX_LIGHTS; j++)
		{
			sprintf(temp_buffer, "u_lights_data_%d[%d]", i, j);
			pipeline->u_lights_v4[i][j] = CGL_shader_get_uniform_location(pipeline->shader, temp_buffer);
		}
	}
	return pipeline;
}

// pipeline_destroy
CGL_void CGL_phong_pipeline_destroy(CGL_phong_pipeline* pipeline)
{
	CGL_shader_destroy(pipeline->shader);
	for (CGL_sizei i = 0; i < CGL_utils_array_size(pipeline->lights); i++)
		if (pipeline->lights[i])
			CGL_phong_light_destroy(pipeline->lights[i]);
	CGL_free(pipeline);
}

CGL_void CGL_phong_pipeline_set_ambient_light_color(CGL_phong_pipeline* pipeline, CGL_vec3 color)
{
	pipeline->ambient_light_color = color;
}

CGL_vec3 CGL_phong_pipeline_get_ambient_light_color(CGL_phong_pipeline* pipeline)
{
	return pipeline->ambient_light_color;
}

CGL_void CGL_phong_pipeline_enable_gamma_correction(CGL_phong_pipeline* pipeline)
{
	pipeline->use_gamma_correction = true;
}

CGL_void CGL_phong_pipeline_disable_gamma_correction(CGL_phong_pipeline* pipeline)
{
	pipeline->use_gamma_correction = false;
}

CGL_void CGL_phong_pipeline_set_ambient_light_strength(CGL_phong_pipeline* pipeline, CGL_float strength)
{
	pipeline->ambient_light_strength = CGL_utils_clamp(strength, 0.0f, 1000.0f);
}

float CGL_phong_pipeline_get_ambient_light_strength(CGL_phong_pipeline* pipeline)
{
	return pipeline->ambient_light_strength;
}

// pipeline_set_user_data
CGL_void CGL_phong_pipeline_set_user_data(CGL_phong_pipeline* pipeline, void* data)
{
	pipeline->user_data = data;
}

// pipeline_get_user_data
CGL_void* CGL_phong_pipeline_get_user_data(CGL_phong_pipeline* pipeline)
{
	return pipeline->user_data;
}

// pipeline_is_using_blinn
bool CGL_phong_pipeline_is_using_blinn(CGL_phong_pipeline* pipeline)
{
	return pipeline->use_blinn;
}

// pipeline_enable_blinn
CGL_void CGL_phong_pipeline_enable_blinn(CGL_phong_pipeline* pipeline)
{
	pipeline->use_blinn = true;
}

// pipeline_disable_blinn
CGL_void CGL_phong_pipeline_disable_blinn(CGL_phong_pipeline* pipeline)
{
	pipeline->use_blinn = false;
}

// pipeline_add_light
uint32_t CGL_phong_pipeline_add_light(CGL_phong_pipeline* pipeline, CGL_phong_light* light)
{
	for (CGL_sizei i = 0; i < CGL_utils_array_size(pipeline->lights); i++)
	{
		if (pipeline->lights[i] == NULL)
		{
			pipeline->light_count += 1;
			pipeline->lights[i] = light;
			return (uint32_t)i;
		}
	}
	return UINT32_MAX;
}

// pipeline_remove_light
CGL_phong_light* CGL_phong_pipeline_remove_light(CGL_phong_pipeline* pipeline, uint32_t light_id)
{
	if (/* light_id < 0 || */ light_id >= CGL_utils_array_size(pipeline->lights))
		return NULL;
	pipeline->light_count -= 1;
	CGL_phong_light* light = pipeline->lights[light_id];
	pipeline->lights[light_id] = NULL;
	return light;
}

// mat_create
CGL_phong_mat* CGL_phong_mat_create()
{
	CGL_phong_mat* mat = (CGL_phong_mat*)malloc(sizeof(CGL_phong_mat));
	mat->use_diffuse_texture = false;
	mat->diffuse_color = CGL_vec3_init(0.8f, 0.8f, 0.8f);
	mat->diffuse_image = NULL;
	mat->diffuse_texture = NULL;
	mat->use_specular_texture = false;
	mat->specular_color = CGL_vec3_init(0.8f, 0.8f, 0.8f);
	mat->specular_image = NULL;
	mat->specular_texture = NULL;
	mat->use_normal_map = false;
	mat->normal_map_image = NULL;
	mat->normal_map_texture = NULL;
	mat->shininess = 64.0f;
	mat->wireframe = false;
	mat->user_data = NULL;
	return mat;
}

// mat_destroy
CGL_void CGL_phong_mat_destroy(CGL_phong_mat* mat)
{
	if (mat->use_diffuse_texture)
		CGL_texture_destroy(mat->diffuse_texture);
	if (mat->use_specular_texture)
		CGL_texture_destroy(mat->specular_texture);
	if (mat->use_normal_map)
		CGL_texture_destroy(mat->normal_map_texture);
	CGL_free(mat);
}

// mat_set_diffuse_color
CGL_void CGL_phong_mat_set_diffuse_color(CGL_phong_mat* mat, CGL_vec3 color)
{
	if (mat->use_diffuse_texture)
		CGL_texture_destroy(mat->diffuse_texture);
	mat->diffuse_image = NULL;
	mat->diffuse_texture = NULL;
	mat->use_diffuse_texture = false;
	mat->diffuse_color = color;
}

// mat_set_diffuse_texture
CGL_void CGL_phong_mat_set_diffuse_texture(CGL_phong_mat* mat, CGL_image* image)
{
	if (mat->use_diffuse_texture)
		CGL_texture_destroy(mat->diffuse_texture);
	mat->use_diffuse_texture = true;
	mat->diffuse_image = image;
	mat->diffuse_texture = CGL_texture_create(image);
}

// mat_set_specular_color
CGL_void CGL_phong_mat_set_specular_color(CGL_phong_mat* mat, CGL_vec3 color)
{
	if (mat->use_specular_texture)
		CGL_texture_destroy(mat->specular_texture);
	mat->specular_image = NULL;
	mat->specular_texture = NULL;
	mat->use_specular_texture = false;
	mat->specular_color = color;
}

// mat_set_specular_texture
CGL_void CGL_phong_mat_set_specular_texture(CGL_phong_mat* mat, CGL_image* image)
{
	if (mat->use_specular_texture)
		CGL_texture_destroy(mat->specular_texture);
	mat->use_specular_texture = true;
	mat->specular_image = image;
	mat->specular_texture = CGL_texture_create(image);
}

// mat_set_normal_texture
CGL_void CGL_phong_mat_set_normal_texture(CGL_phong_mat* mat, CGL_image* image)
{
	if (mat->use_normal_map)
		CGL_texture_destroy(mat->normal_map_texture);
	mat->use_normal_map = true;
	mat->normal_map_image = image;
	mat->normal_map_texture = CGL_texture_create(image);
}

// mat_set_shininess
CGL_void CGL_phong_mat_set_shininess(CGL_phong_mat* mat, CGL_float shininess)
{
	mat->shininess = shininess;
}

// mat_set_user_data
CGL_void CGL_phong_mat_set_user_data(CGL_phong_mat* mat, void* data)
{
	mat->user_data = data;
}

// mat_get_user_data
CGL_void* CGL_phong_mat_get_user_data(CGL_phong_mat* mat)
{
	return mat->user_data;
}

// mat_disable_normal_map
CGL_void CGL_phong_mat_disable_normal_map(CGL_phong_mat* mat)
{
	if (mat->use_normal_map)
		CGL_texture_destroy(mat->normal_map_texture);
	mat->normal_map_image = NULL;
	mat->normal_map_texture = NULL;
	mat->use_normal_map = false;
}

// mat_enable_wireframe
CGL_void CGL_phong_mat_enable_wireframe(CGL_phong_mat* mat)
{
	mat->wireframe = true;
}

// mat_disable_wireframe
CGL_void CGL_phong_mat_disable_wireframe(CGL_phong_mat* mat)
{
	mat->wireframe = false;
}

// mat_get_shininess
float CGL_phong_mat_get_shininess(CGL_phong_mat* mat)
{
	return mat->shininess;
}

// light_directional
CGL_phong_light* CGL_phong_light_directional(CGL_vec3 direction, CGL_vec3 color, CGL_float intensity)
{
	CGL_phong_light* light = (CGL_phong_light*)malloc(sizeof(CGL_phong_light));
	light->light_type = CGL_PHONG_LIGHT_DIRECTIONAL;
	light->color = color;
	light->intensity = intensity;
	light->vector = direction;
	return light;
}

// light_point
CGL_phong_light* CGL_phong_light_point(CGL_vec3 position, CGL_vec3 color, CGL_float intensity, CGL_float constant, CGL_float linear, CGL_float quadratic)
{
	CGL_phong_light* light = (CGL_phong_light*)malloc(sizeof(CGL_phong_light));
	light->light_type = CGL_PHONG_LIGHT_POINT;
	light->color = color;
	light->intensity = intensity;
	light->vector = position;
	light->constant = constant;
	light->linear = linear;
	light->quadratic = quadratic;
	return light;
}

// light_destroy
CGL_void CGL_phong_light_destroy(CGL_phong_light* light)
{
	CGL_free(light);
}

// light_set_intensity
CGL_void CGL_phong_light_set_intensity(CGL_phong_light* light, CGL_float intensity)
{
	light->intensity = intensity;
}

// light_set_color
CGL_void CGL_phong_light_set_color(CGL_phong_light* light, CGL_vec3 color)
{
	light->color = color;
}

// light_get_intensity
float CGL_phong_light_get_intensity(CGL_phong_light* light)
{
	return light->intensity;
}

// light_get_color
CGL_vec3 CGL_phong_light_get_color(CGL_phong_light* light)
{
	return light->color;
}

// light_get_type
uint32_t CGL_phong_light_get_type(CGL_phong_light* light)
{
	return light->light_type;
}


CGL_void CGL_phong_render_begin(CGL_phong_pipeline* pipeline, CGL_camera* camera)
{
	if (pipeline->depth_testing) glEnable(GL_DEPTH_TEST);
	else glDisable(GL_DEPTH_TEST);

	CGL_shader_bind(pipeline->shader);
	// set uniforms
	CGL_shader_set_uniform_mat4(pipeline->shader, pipeline->u_projection, CGL_camera_get_projection_mat_ptr(camera));// camera
	CGL_shader_set_uniform_mat4(pipeline->shader, pipeline->u_view, CGL_camera_get_view_mat_ptr(camera));// camera
	CGL_shader_set_uniform_mat4(pipeline->shader, pipeline->u_pv, CGL_camera_get_pv_mat_ptr(camera));// camera
	CGL_vec3 camera_position = CGL_camera_get_position(camera);
	CGL_shader_set_uniform_vec3v(pipeline->shader, pipeline->u_camera_position, camera_position.x, camera_position.y, camera_position.z);
	CGL_shader_set_uniform_bool(pipeline->shader, pipeline->u_use_blinn, pipeline->use_blinn);
	CGL_shader_set_uniform_float(pipeline->shader, pipeline->u_ambient_light_strength, pipeline->ambient_light_strength);
	CGL_shader_set_uniform_vec3v(pipeline->shader, pipeline->u_ambient_light_color, pipeline->ambient_light_color.x, pipeline->ambient_light_color.y, pipeline->ambient_light_color.z);
	CGL_shader_set_uniform_bool(pipeline->shader, pipeline->u_use_gamma_correction, pipeline->use_gamma_correction);
	// set lights
	CGL_shader_set_uniform_int(pipeline->shader, pipeline->u_light_count, pipeline->light_count);
	for (uint32_t i = 0, j = 0; i < pipeline->light_count; i++)
	{
		CGL_phong_light* light = pipeline->lights[i];
		if (light == NULL) continue;
		// data_0 is color and strength
		CGL_shader_set_uniform_vec4v(pipeline->shader, pipeline->u_lights_v4[0][j], light->color.x, light->color.y, light->color.z, light->intensity);
		// data_1 is type, constant, linear, quadratic
		CGL_shader_set_uniform_vec4v(pipeline->shader, pipeline->u_lights_v4[1][j], (float)light->light_type, light->constant, light->linear, light->quadratic);
		// data_2 is vector
		CGL_shader_set_uniform_vec4v(pipeline->shader, pipeline->u_lights_v4[2][j], light->vector.x, light->vector.y, light->vector.z, 0.0f);
		// data_3 is reserved for future use
		j++;
	}
}

CGL_void CGL_phong_render(CGL_mesh_gpu* mesh, CGL_mat4* model_matrix, CGL_phong_mat* material, CGL_phong_pipeline* pipeline, CGL_camera* camera)
{
	(void)camera;
	CGL_shader_set_uniform_mat4(pipeline->shader, pipeline->u_model_matrix, model_matrix);
	CGL_shader_set_uniform_bool(pipeline->shader, pipeline->u_use_diffuse_texture, material->use_diffuse_texture);
	CGL_shader_set_uniform_vec3v(pipeline->shader, pipeline->u_diffuse_color, material->diffuse_color.x, material->diffuse_color.y, material->diffuse_color.z);
	if (material->use_diffuse_texture)
	{
		CGL_texture_bind(material->diffuse_texture, 4);
		CGL_shader_set_uniform_int(pipeline->shader, pipeline->u_diffuse_texture, 4);
	}
	CGL_shader_set_uniform_bool(pipeline->shader, pipeline->u_use_specular_texture, material->use_specular_texture);
	CGL_shader_set_uniform_vec3v(pipeline->shader, pipeline->u_specular_color, material->specular_color.x, material->specular_color.y, material->specular_color.z);
	if (material->use_specular_texture)
	{
		CGL_texture_bind(material->specular_texture, 1);
		CGL_shader_set_uniform_int(pipeline->shader, pipeline->u_specular_texture, 1);
	}
	CGL_shader_set_uniform_bool(pipeline->shader, pipeline->u_use_normal_map, material->use_normal_map);
	if (material->use_normal_map)
	{
		CGL_texture_bind(material->normal_map_texture, 3);
		CGL_shader_set_uniform_int(pipeline->shader, pipeline->u_use_normal_map, 3);
	}
	CGL_shader_set_uniform_float(pipeline->shader, pipeline->u_shininess, material->shininess);
	if (material->wireframe)
		glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
	CGL_mesh_gpu_render(mesh);
	if (material->wireframe)
		glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
}

CGL_void CGL_phong_render_end(CGL_phong_pipeline* pipeline, CGL_camera* camera)
{
	(void)pipeline;
	(void)camera;
}


#endif

#endif

#endif

// tilemap renderer
#ifndef CGL_EXCLUDE_GRAPHICS_API // cannot have TILE RENDERER without Graphics API

// tilemap renderer
#if 1

#ifndef CGL_EXCLUDE_TILEMAP_RENDERER

static const char* __CGL_TILEMAP_VERTEX_SHADER =
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
"in vec4 position;\n"
"in vec4 normal;\n"
"in vec4 texcoord;\n"
#else
"#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 normal;\n"
"layout (location = 2) in vec4 texcoord;\n"
#endif
"\n"
"void main()\n"
"{\n"
"	gl_Position = vec4(position.xyz, 1.0f);\n"
"}";

static const char* __CGL_TILEMAP_FRAGENT_SHADER =
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
#else
"#version 430 core\n"
#endif
"\n"
"out vec4 FragColor;\n"
"//out CGL_int MousePick0;\n"
"//out CGL_int MousePick1;\n"
"//out CGL_int MousePick2;\n"
"in vec3 Position;\n"
"in vec3 Normal;\n"
"in vec2 TexCoord;\n"
"\n"
"\n"
"// unifroms\n"
"uniform vec2 u_offset;\n"
"uniform vec2 u_scale;\n"
"uniform vec2 u_tile_count;\n"
"uniform vec2 u_tile_size;\n"
"\n"
"uniform sampler2D u_texture_tileset;\n"
"uniform sampler2DArray u_texture_array;\n"
"\n"
"struct cglTile\n"
"{\n"
"    vec4 color;\n"
"};\n"
"\n"
"layout (std430, binding = %d)  buffer tiles_buffer\n"
"{\n"
"    cglTile tiles[];\n"
"};\n"
"\n"
"void main()\n"
"{\n"
"    vec4 color = vec4(0.0f, 1.0f, 0.0f, 1.0f);\n"
"    vec2 frag_coord = gl_FragCoord.xy;\n"
"    vec2 coord = vec2(\n"
"        (frag_coord.x + u_offset.x) * u_scale.x,\n"
"        (frag_coord.y + u_offset.y) * u_scale.y\n"
"    );\n"
"    \n"
"    vec2 tile_index_f = vec2(\n"
"        coord.x / u_tile_size.x,\n"
"        coord.y / u_tile_size.y\n"
"    );\n"
"    ivec2 tile_index = ivec2(tile_index_f);\n"
"\n"
"    vec2 tile_tex_coord = vec2(\n"
"        mod(coord.x, u_tile_size.x) / u_tile_size.x,\n"
"        mod(coord.y, u_tile_size.y) / u_tile_size.y\n"
"    );\n"
"\n"
"\n"
"    if(tile_index_f.x < 0 || tile_index_f.x >= u_tile_count.x\n"
"    || tile_index_f.y < 0 || tile_index_f.y >= u_tile_count.y)\n"
"    {\n"
"        // discard; // Using discard might not be the best idea\n"
"        FragColor = vec4(0.0f);\n"
"        return;\n"
"    }\n"
"\n"
"    cglTile current_tile = tiles[tile_index.y * int(u_tile_count.x) + tile_index.x];\n"
"\n"
"    if (current_tile.color.w > 3.0f)  // case where tile is empty\n"
"    {\n"
"        // discard; // Using discard might not be the best idea\n"
"        FragColor = vec4(0.0f);\n"
"        return;\n"
"    }\n"
"    else if(current_tile.color.w > 2.0f ) // case where tile is a solid color\n"
"    {\n"
"        FragColor = vec4(current_tile.color.xyz, 1.0f);\n"
"        return;\n"
"    }\n"
"    else if(current_tile.color.w > 1.0f ) // case where tile is a texture from texture array\n"
"    {\n"
"        FragColor = texture(u_texture_array, vec3(tile_tex_coord, current_tile.color.x));\n"
"        return;\n"
"    }\n"
"    else // case where tile is a texture from tileset \n"
"    {\n"
"        vec2 final_tex_scale = current_tile.color.zw;\n"
"        vec2 final_tex_coord = vec2(\n"
"            (tile_tex_coord.x) * final_tex_scale.x + current_tile.color.x,\n"
"            (tile_tex_coord.y) * final_tex_scale.y + current_tile.color.y\n"
"        );\n"
"        FragColor = texture(u_texture_tileset, final_tex_coord);\n"
"        return;\n"
"    }\n"
"\n"
"    FragColor = vec4(tile_tex_coord, 0.0f, 1.0f);\n"
"    //MousePick0 = InstanceID;\n"
"    //MousePick1 = 0;\n"
"    //MousePick2 = 1;\n"
"}";

struct CGL_tile
{
	CGL_vec4 color;
};

struct CGL_tilemap
{
	// tiles data
	CGL_tile* tile_data;
	uint32_t tile_count_x;
	uint32_t tile_count_y;
	uint32_t tile_size_x;
	uint32_t tile_size_y;
	bool auto_update;
	// renderer data
	CGL_mesh_gpu* mesh;
	CGL_shader* shader;
	CGL_ssbo* ssbo;
	// unifrom locations
	CGL_int u_tile_count;
	CGL_int u_tile_size;
	CGL_int u_offset;
	CGL_int u_scale;
	CGL_int u_texture_tileset;
	CGL_int u_texture_array;
};


CGL_tilemap* CGL_tilemap_create(uint32_t tile_count_x, uint32_t tile_count_y, uint32_t tile_size_x, uint32_t tile_size_y, uint32_t ssbo_binding)
{
	/*
	assert(tile_count_x > 0);
	assert(tile_count_y > 0);
	assert(tile_size_x > 0);
	assert(tile_size_y > 0);
	*/
	CGL_tilemap* tilemap = (CGL_tilemap*)malloc(sizeof(CGL_tilemap));
	tilemap->tile_data = (CGL_tile*)malloc(sizeof(CGL_tile) * tile_count_x * tile_count_y);
	memset(tilemap->tile_data, 0, (sizeof(CGL_tile) * tile_count_x * tile_count_y));
	tilemap->tile_count_x = tile_count_x;
	tilemap->tile_count_y = tile_count_y;
	tilemap->tile_size_x = tile_size_x;
	tilemap->tile_size_y = tile_size_y;

	tilemap->ssbo = CGL_ssbo_create(ssbo_binding);

	CGL_mesh_cpu* screen_quad_mesh_cpu = CGL_mesh_cpu_quad(CGL_vec3_init(1.0, 1.0, 0.0),
		CGL_vec3_init(1.0, -1.0, 0.0),
		CGL_vec3_init(-1.0, -1.0, 0.0),
		CGL_vec3_init(-1.0, 1.0, 0.0));
	CGL_mesh_gpu* screen_quad_mesh_gpu = CGL_mesh_gpu_create();
	CGL_mesh_gpu_upload(screen_quad_mesh_gpu, screen_quad_mesh_cpu, true);
	CGL_mesh_cpu_destroy(screen_quad_mesh_cpu);
	tilemap->mesh = screen_quad_mesh_gpu;
	static char shader_source_buffer[1024 * 64];
	sprintf(shader_source_buffer, __CGL_TILEMAP_FRAGENT_SHADER, ssbo_binding);
	tilemap->shader = CGL_shader_create(__CGL_TILEMAP_VERTEX_SHADER, shader_source_buffer, NULL);
	tilemap->u_offset = CGL_shader_get_uniform_location(tilemap->shader, "u_offset");
	tilemap->u_scale = CGL_shader_get_uniform_location(tilemap->shader, "u_scale");
	tilemap->u_tile_count = CGL_shader_get_uniform_location(tilemap->shader, "u_tile_count");
	tilemap->u_tile_size = CGL_shader_get_uniform_location(tilemap->shader, "u_tile_size");
	tilemap->u_texture_tileset = CGL_shader_get_uniform_location(tilemap->shader, "u_texture_tileset");
	tilemap->u_texture_array = CGL_shader_get_uniform_location(tilemap->shader, "u_texture_array");
	tilemap->auto_update = true;
	CGL_tilemap_reset(tilemap);
	return tilemap;
}

CGL_void CGL_tilemap_destroy(CGL_tilemap* tilemap)
{
	CGL_ssbo_destroy(tilemap->ssbo);
	CGL_shader_destroy(tilemap->shader);
	CGL_mesh_gpu_destroy(tilemap->mesh);
	CGL_free(tilemap->tile_data);
	CGL_free(tilemap);
}

CGL_void CGL_tilemap_set_auto_upload(CGL_tilemap* tilemap, bool value)
{
	tilemap->auto_update = value;
}

bool CGL_tilemap_get_auto_upload(CGL_tilemap* tilemap)
{
	return tilemap->auto_update;
}

bool CGL_tilemap_upload(CGL_tilemap* tilemap)
{
	CGL_ssbo_set_data(tilemap->ssbo, (sizeof(CGL_tile) * tilemap->tile_count_x * tilemap->tile_count_y), tilemap->tile_data, false);
	return true;
}

CGL_void CGL_tilemap_set_tile_color(CGL_tilemap* tilemap, uint32_t tile_x, uint32_t tile_y, CGL_float r, CGL_float g, CGL_float b)
{
	CGL_tile* tile = &tilemap->tile_data[tile_y * tilemap->tile_count_x + tile_x];
	tile->color = CGL_vec4_init(r, g, b, 2.5f);
	if (tilemap->auto_update) CGL_ssbo_set_sub_data(tilemap->ssbo, (tile_y * tilemap->tile_count_x + tile_x) * sizeof(CGL_tile), sizeof(CGL_tile), tile, false);
}

CGL_void CGL_tilemap_set_tile_texture_from_array(CGL_tilemap* tilemap, uint32_t tile_x, uint32_t tile_y, uint32_t texture_index)
{
	CGL_tile* tile = &tilemap->tile_data[tile_y * tilemap->tile_count_x + tile_x];
	tile->color = CGL_vec4_init((float)texture_index, 0.0f, 0.0f, 1.5f);
	if (tilemap->auto_update) CGL_ssbo_set_sub_data(tilemap->ssbo, (tile_y * tilemap->tile_count_x + tile_x) * sizeof(CGL_tile), sizeof(CGL_tile), tile, false);
}

CGL_void CGL_tilemap_set_tile_texture_from_tileset(CGL_tilemap* tilemap, uint32_t tile_x, uint32_t tile_y, CGL_float texture_x_min, CGL_float texture_y_min, CGL_float texture_x_max, CGL_float texture_y_max)
{
	CGL_tile* tile = &tilemap->tile_data[tile_y * tilemap->tile_count_x + tile_x];
	tile->color = CGL_vec4_init(texture_x_min, texture_y_min, texture_x_max, texture_y_max);
	if (tilemap->auto_update) CGL_ssbo_set_sub_data(tilemap->ssbo, (tile_y * tilemap->tile_count_x + tile_x) * sizeof(CGL_tile), sizeof(CGL_tile), tile, false);
}

CGL_void CGL_tilemap_set_all_tile_color(CGL_tilemap* tilemap, CGL_float r, CGL_float g, CGL_float b)
{
	CGL_bool auto_update = tilemap->auto_update;
	tilemap->auto_update = false;
	for (uint32_t y = 0; y < tilemap->tile_count_y; y++)
		for (uint32_t x = 0; x < tilemap->tile_count_x; x++)
			CGL_tilemap_set_tile_color(tilemap, x, y, r, g, b);
	tilemap->auto_update = auto_update;
	CGL_tilemap_upload(tilemap);
}

CGL_void CGL_tilemap_set_all_tile_texture_from_array(CGL_tilemap* tilemap, uint32_t texture_index)
{
	CGL_bool auto_update = tilemap->auto_update;
	tilemap->auto_update = false;
	for (uint32_t y = 0; y < tilemap->tile_count_y; y++)
		for (uint32_t x = 0; x < tilemap->tile_count_x; x++)
			CGL_tilemap_set_tile_texture_from_array(tilemap, x, y, texture_index);
	tilemap->auto_update = auto_update;
	CGL_tilemap_upload(tilemap);
}

CGL_void CGL_tilemap_set_all_tile_texture_from_tileset(CGL_tilemap* tilemap, CGL_float texture_x_min, CGL_float texture_y_min, CGL_float texture_x_max, CGL_float texture_y_max)
{
	CGL_bool auto_update = tilemap->auto_update;
	tilemap->auto_update = false;
	for (uint32_t y = 0; y < tilemap->tile_count_y; y++)
		for (uint32_t x = 0; x < tilemap->tile_count_x; x++)
			CGL_tilemap_set_tile_texture_from_tileset(tilemap, x, y, texture_x_min, texture_y_min, texture_x_max, texture_y_max);
	tilemap->auto_update = auto_update;
	CGL_tilemap_upload(tilemap);
}

CGL_void CGL_tilemap_clear_all_tile(CGL_tilemap* tilemap)
{
	CGL_bool auto_update = tilemap->auto_update;
	tilemap->auto_update = false;
	for (uint32_t y = 0; y < tilemap->tile_count_y; y++)
		for (uint32_t x = 0; x < tilemap->tile_count_x; x++)
			CGL_tilemap_clear_tile(tilemap, x, y);
	tilemap->auto_update = auto_update;
	CGL_tilemap_upload(tilemap);
}

CGL_void CGL_tilemap_clear_tile(CGL_tilemap* tilemap, uint32_t tile_x, uint32_t tile_y)
{
	CGL_tile* tile = &tilemap->tile_data[tile_y * tilemap->tile_count_x + tile_x];
	tile->color = CGL_vec4_init(0.0f, 0.0f, 0.0f, 3.5f);
	if (tilemap->auto_update) CGL_ssbo_set_sub_data(tilemap->ssbo, (tile_y * tilemap->tile_count_x + tile_x) * sizeof(CGL_tile), sizeof(CGL_tile), tile, false);
}

CGL_void CGL_tilemap_reset(CGL_tilemap* tilemap)
{
	for (uint32_t tile_x = 0; tile_x < tilemap->tile_count_x; tile_x++)
	{
		for (uint32_t tile_y = 0; tile_y < tilemap->tile_count_y; tile_y++)
		{
			CGL_tile* tile = &tilemap->tile_data[tile_y * tilemap->tile_count_x + tile_x];
			tile->color = CGL_vec4_init(0.0f, 0.0f, 0.0f, 3.5f);
		}
	}
	CGL_ssbo_set_data(tilemap->ssbo, (sizeof(CGL_tile) * tilemap->tile_count_x * tilemap->tile_count_y), tilemap->tile_data, false);
}

CGL_void CGL_tilemap_render(CGL_tilemap* tilemap, CGL_float scale_x, CGL_float scale_y, CGL_float offset_x, CGL_float offset_y, CGL_texture* texture)
{
	CGL_shader_bind(tilemap->shader);
	if (texture) CGL_texture_bind(texture, 0);
	CGL_shader_set_uniform_vec2v(tilemap->shader, tilemap->u_offset, -offset_x, -offset_y);
	CGL_shader_set_uniform_vec2v(tilemap->shader, tilemap->u_scale, 1.0f / scale_x, 1.0f / scale_y);
	CGL_shader_set_uniform_vec2v(tilemap->shader, tilemap->u_tile_count, (float)tilemap->tile_count_x, (float)tilemap->tile_count_y);
	CGL_shader_set_uniform_vec2v(tilemap->shader, tilemap->u_tile_size, (float)tilemap->tile_size_x, (float)tilemap->tile_size_y);
	CGL_shader_set_uniform_int(tilemap->shader, tilemap->u_texture_tileset, 0);
	CGL_shader_set_uniform_int(tilemap->shader, tilemap->u_texture_array, 0);
	CGL_mesh_gpu_render(tilemap->mesh);
}

#endif

#endif


#endif

// sky renderer
#ifndef CGL_EXCLUDE_GRAPHICS_API
#ifndef CGL_EXCLUDE_SKY_RENDERER

struct CGL_sky
{
	CGL_vec3 sun_pos;
	CGL_texture* cubemap;
	CGL_shader* cubemap_shader;
	CGL_shader* procedural_shader;
	CGL_mesh_gpu* skybox_mesh;
	CGL_mesh_gpu* skysphere_mesh;
	CGL_mesh_gpu* active_mesh;
	CGL_float cirrus;
	CGL_float cumulus;
	CGL_float upf;
	CGL_float time;
	bool is_procedural;
	// unifroms
	CGL_int cs_u_projection;
	CGL_int cs_u_view;
	CGL_int cs_u_texture;
	CGL_int ps_u_projection;
	CGL_int ps_u_view;
	CGL_int ps_u_cirrus;
	CGL_int ps_u_cumulus;
	CGL_int ps_u_upf;
	CGL_int ps_u_time;
	CGL_int ps_u_fsun;

};

static const char* __CGL_SKY_VERTEX_SHADER =
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
"in vec4 position;\n"
"in vec4 normal;\n"
"in vec4 texcoord;\n"
#else
"#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 normal;\n"
"layout (location = 2) in vec4 texcoord;\n"
#endif
"\n"
"out vec3 Position;\n"
"\n"
"\n"
"uniform mat4 u_projection;\n"
"uniform mat4 u_view;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = u_projection * transpose(u_view) * vec4(position.xyz, 1.0f);\n"
"	Position = position.xyz;\n"
"}";

static const char* __CGL_SKY_CUBEMAP_FRAGMENT_SHADER =
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
#else
"#version 430 core\n"
#endif
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Position;\n"
"\n"
"uniform samplerCube u_texture;\n"
"\n"
"void main()\n"
"{\n"
"	vec4 color = texture(u_texture, Position);\n"
"	FragColor = color;\n"
"}";

static const char* __CGL_SKY_PROCEDURAL_FRAGMENT_SHADER =
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
#else
"#version 430 core\n"
#endif
"uniform vec3 fsun;\n"
"uniform float time;\n"
"uniform float cirrus;\n"
"uniform float cumulus;\n"
"uniform float upf;\n"
"\n"
"in vec3 Position;"
"\n"
"out vec4 FragColor;\n"
"\n"
"const float Br = 0.0025;\n"
"const float Bm = 0.0003;\n"
"const float g = 0.9800;\n"
"const vec3 nitrogen = vec3(0.650, 0.570, 0.475);\n"
"const vec3 Kr = Br / pow(nitrogen, vec3(4.0));\n"
"const vec3 Km = Bm / pow(nitrogen, vec3(0.84));\n"
"\n"
"float hash(float n) {\n"
"  return fract(sin(n) * 43758.5453123);\n"
"}\n"
"\n"
"float noise(vec3 x) {\n"
"  vec3 f = fract(x);\n"
"  float n = dot(floor(x), vec3(1.0, 157.0, 113.0));\n"
"  return mix(mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n"
"      mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n"
"    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n"
"      mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n"
"}\n"
"\n"
"const mat3 m = mat3(0.0, 1.60, 1.20, -1.6, 0.72, -0.96, -1.2, -0.96, 1.28);\n"
"float fbm(vec3 p) {\n"
"  float f = 0.0;\n"
"  f += noise(p) / 2;\n"
"  p = m * p * 1.1;\n"
"  f += noise(p) / 4;\n"
"  p = m * p * 1.2;\n"
"  f += noise(p) / 6;\n"
"  p = m * p * 1.3;\n"
"  f += noise(p) / 12;\n"
"  p = m * p * 1.4;\n"
"  f += noise(p) / 24;\n"
"  return f;\n"
"}\n"
"\n"
"void main() {\n"
"  vec3 pos = vec3(Position.x, Position.y+upf, Position.z);\n"
"\n"
"  // Atmosphere Scattering\n"
"  float mu = dot(normalize(pos), normalize(fsun));\n"
"  float rayleigh = 3.0 / (8.0 * 3.14) * (1.0 + mu * mu);\n"
"  vec3 mie = (Kr + Km * (1.0 - g * g) / (2.0 + g * g) / pow(1.0 + g * g - 2.0 * g * mu, 1.5)) / (Br + Bm);\n"
"\n"
"  vec3 day_extinction = exp(-exp(-((pos.y + fsun.y * 4.0) * (exp(-pos.y * 16.0) + 0.1) / 80.0) / Br) * (exp(-pos.y * 16.0) + 0.1) * Kr / Br) * exp(-pos.y * exp(-pos.y * 8.0) * 4.0) * exp(-pos.y * 2.0) * 4.0;\n"
"  vec3 night_extinction = vec3(1.0 - exp(fsun.y)) * 0.2;\n"
"  vec3 extinction = mix(day_extinction, night_extinction, -fsun.y * 0.2 + 0.5);\n"
"  FragColor.rgb = rayleigh * mie * extinction;\n"
"\n"
"  // Cirrus Clouds\n"
"  float density = smoothstep(1.0 - cirrus, 1.0, fbm(pos.xyz / pos.y * 2.0 + time * 0.05)) * 0.3;\n"
"  FragColor.rgb = mix(FragColor.rgb, extinction * 4.0, density * max(pos.y, 0.0));\n"
"\n"
"  // Cumulus Clouds\n"
"  for (int i = 0; i < 3; i++) {\n"
"    float density = smoothstep(1.0 - cumulus, 1.0, fbm((0.7 + float(i) * 0.01) * pos.xyz / pos.y + time * 0.3));\n"
"    FragColor.rgb = mix(FragColor.rgb, extinction * density * 5.0, min(density, 1.0) * max(pos.y, 0.0));\n"
"  }\n"
"\n"
"  // Dithering Noise\n"
"  FragColor.rgb += noise(pos * 1000) * 0.01;\n"
"}";

CGL_sky* CGL_sky_create()
{
	CGL_sky* sky = (CGL_sky*)CGL_malloc(sizeof(CGL_sky));
	if (!sky) return NULL;
	sky->sun_pos = CGL_vec3_init(0.0f, 0.2f, 0.1f);
	sky->time = 0.0f;
	sky->cirrus = 0.4f;
	sky->cumulus = 0.8f;
	sky->upf = 0.35f;
	sky->is_procedural = true;
	sky->cubemap = CGL_texture_create_cubemap();

	CGL_mesh_cpu* skybox_cpu = CGL_mesh_cpu_cube(true);
	sky->skybox_mesh = CGL_mesh_gpu_create();
	CGL_mesh_gpu_upload(sky->skybox_mesh, skybox_cpu, true);
	CGL_free(skybox_cpu);

	CGL_mesh_cpu* skysphere_cpu = CGL_mesh_cpu_sphere(16, 16);
	sky->skysphere_mesh = CGL_mesh_gpu_create();
	CGL_mesh_gpu_upload(sky->skysphere_mesh, skysphere_cpu, true);
	CGL_free(skysphere_cpu);

	sky->active_mesh = sky->skybox_mesh;

	sky->cubemap_shader = CGL_shader_create(__CGL_SKY_VERTEX_SHADER, __CGL_SKY_CUBEMAP_FRAGMENT_SHADER, NULL);
	sky->cs_u_projection = CGL_shader_get_uniform_location(sky->cubemap_shader, "u_projection");
	sky->cs_u_view = CGL_shader_get_uniform_location(sky->cubemap_shader, "u_view");
	sky->cs_u_texture = CGL_shader_get_uniform_location(sky->cubemap_shader, "u_texture");

	sky->procedural_shader = CGL_shader_create(__CGL_SKY_VERTEX_SHADER, __CGL_SKY_PROCEDURAL_FRAGMENT_SHADER, NULL);
	sky->ps_u_projection = CGL_shader_get_uniform_location(sky->procedural_shader, "u_projection");
	sky->ps_u_view = CGL_shader_get_uniform_location(sky->procedural_shader, "u_view");
	sky->ps_u_cirrus = CGL_shader_get_uniform_location(sky->procedural_shader, "cirrus");
	sky->ps_u_cumulus = CGL_shader_get_uniform_location(sky->procedural_shader, "cumulus");
	sky->ps_u_upf = CGL_shader_get_uniform_location(sky->procedural_shader, "upf");
	sky->ps_u_time = CGL_shader_get_uniform_location(sky->procedural_shader, "time");
	sky->ps_u_fsun = CGL_shader_get_uniform_location(sky->procedural_shader, "fsun");

	return sky;
}

CGL_void CGL_sky_destroy(CGL_sky* sky)
{
	CGL_texture_destroy(sky->cubemap);
	CGL_mesh_gpu_destroy(sky->skybox_mesh);
	CGL_mesh_gpu_destroy(sky->skysphere_mesh);
	CGL_shader_destroy(sky->cubemap_shader);
	CGL_shader_destroy(sky->procedural_shader);
	CGL_free(sky);
}

CGL_void CGL_sky_use_skybox(CGL_sky* sky)
{
	sky->active_mesh = sky->skybox_mesh;
}

CGL_void CGL_sky_use_skysphere(CGL_sky* sky)
{
	sky->active_mesh = sky->skysphere_mesh;
}

CGL_void CGL_sky_use_cubemap(CGL_sky* sky)
{
	sky->is_procedural = false;
}

CGL_void CGL_sky_use_procedural(CGL_sky* sky)
{
	sky->is_procedural = true;
}

CGL_void CGL_sky_cubemap_set_face(CGL_sky* sky, CGL_int face, CGL_image* image)
{
	CGL_texture_cubemap_set_face(sky->cubemap, face, image);
}

CGL_void CGL_sky_procedural_set_options(CGL_sky* sky, CGL_float cirrus, CGL_float cumulus, CGL_float upf)
{
	sky->cirrus = cirrus;
	sky->cumulus = cumulus;
	sky->upf = upf;
}

CGL_void CGL_sky_procedural_set_time(CGL_sky* sky, CGL_float time)
{
	sky->time = time;
}

CGL_void CGL_sky_procedural_set_sun_position(CGL_sky* sky, CGL_vec3 position)
{
	sky->sun_pos = position;
}

CGL_void CGL_sky_render(CGL_sky* sky, CGL_camera* camera)
{
	glDisable(GL_DEPTH_TEST);
	glDepthMask(GL_FALSE);
	if (sky->is_procedural)
	{
		CGL_shader_bind(sky->procedural_shader);
		CGL_shader_set_uniform_mat4(sky->procedural_shader, sky->ps_u_projection, &camera->projection);
		CGL_mat4 view_matrix = camera->view;
		view_matrix.m[3] = view_matrix.m[7] = view_matrix.m[11] = 0.0f; // removing the translation
		CGL_shader_set_uniform_mat4(sky->procedural_shader, sky->ps_u_view, &view_matrix);
		CGL_shader_set_uniform_float(sky->procedural_shader, sky->ps_u_cirrus, sky->cirrus);
		CGL_shader_set_uniform_float(sky->procedural_shader, sky->ps_u_cumulus, sky->cumulus);
		CGL_shader_set_uniform_float(sky->procedural_shader, sky->ps_u_upf, sky->upf);
		CGL_shader_set_uniform_float(sky->procedural_shader, sky->ps_u_time, sky->time);
		CGL_shader_set_uniform_vec3v(sky->procedural_shader, sky->ps_u_fsun, sky->sun_pos.x, sky->sun_pos.y, sky->sun_pos.z);
	}
	else
	{
		CGL_shader_bind(sky->cubemap_shader);
		CGL_shader_set_uniform_mat4(sky->cubemap_shader, sky->cs_u_projection, &camera->projection);
		CGL_mat4 view_matrix = camera->view;
		view_matrix.m[3] = view_matrix.m[7] = view_matrix.m[11] = 0.0f; // removing the translation
		CGL_shader_set_uniform_mat4(sky->cubemap_shader, sky->cs_u_view, &view_matrix);
		CGL_texture_bind(sky->cubemap, 0);
		CGL_shader_set_uniform_int(sky->cubemap_shader, sky->cs_u_texture, 0);
	}
	CGL_mesh_gpu_render(sky->active_mesh);
	glDepthMask(GL_TRUE);
	glEnable(GL_DEPTH_TEST);
}

#endif // CGL_EXCLUDE_SKY_RENDERER
#endif // CGL_EXCLUDE_GRAPHICS_API

// markov chains
#ifndef CGL_EXCLUDE_MARKOV_API

struct CGL_markov
{
	CGL_hashtable* hashtable;
	size_t key_size;
	size_t value_size;
	void* temp_key;
	void* temp_value;
};

struct CGL_markov_token_function_ngram_text_context
{
	size_t index;
	size_t n;
};

CGL_markov_token_function_ngram_text_context* CGL_markov_token_function_ngram_text_context_create(size_t n)
{
	CGL_markov_token_function_ngram_text_context* ctx = (CGL_markov_token_function_ngram_text_context*)CGL_malloc(sizeof(CGL_markov_token_function_ngram_text_context));
	if (!ctx) return NULL;
	ctx->index = 0;
	ctx->n = n;
	return ctx;
}

CGL_void CGL_markov_token_function_ngram_text_context_destroy(CGL_markov_token_function_ngram_text_context* context)
{
	CGL_free(context);
}


bool CGL_markov_token_function_ngram_text(void* context, const void* dat, const size_t data_size, void* key, void* value)
{
	CGL_markov_token_function_ngram_text_context* ctx = (CGL_markov_token_function_ngram_text_context*)context;
	const char* data = (const char*)dat;
	if (ctx->index >= data_size - ctx->n - 1) return false;
	if (key) memcpy(key, data + ctx->index, ctx->n);
	if (value) *((char*)value) = *(data + ctx->index + ctx->n);
	ctx->index++;
	return true;
}

CGL_markov* CGL_markov_create(const size_t key_size, const size_t value_size)
{
	CGL_markov* mk = (CGL_markov*)CGL_malloc(sizeof(CGL_markov));
	if (!mk) return NULL;
	mk->key_size = key_size;
	mk->value_size = value_size;
	mk->hashtable = CGL_hashtable_create(10000, key_size, 100000);
	mk->temp_key = CGL_malloc(key_size);
	mk->temp_value = CGL_malloc(value_size);
	return mk;
}

bool CGL_markov_train(CGL_markov* markov, void* context, const void* data, const size_t data_size, const CGL_markov_token_function function)
{
	memset(markov->temp_key, 0, markov->key_size);
	memset(markov->temp_value, 0, markov->value_size);
	while (function(context, data, data_size, markov->temp_key, markov->temp_value))
	{
		if (!CGL_hashtable_exists(markov->hashtable, markov->temp_key))
		{
			CGL_list* list = CGL_list_create(markov->value_size, 10);

			CGL_hashtable_set(markov->hashtable, markov->temp_key, &list, sizeof(CGL_list*));
		}
		CGL_list* list = NULL;
		CGL_hashtable_get(markov->hashtable, markov->temp_key, &list);
		CGL_list_push(list, markov->temp_value);
		memset(markov->temp_key, 0, markov->key_size);
		memset(markov->temp_value, 0, markov->value_size);
	}
	return true;
}


bool CGL_markov_generate(const CGL_markov* markov, const void* key, void* value)
{
	if (!CGL_hashtable_exists(markov->hashtable, key)) return false;
	CGL_list* list = NULL;
	CGL_hashtable_get(markov->hashtable, key, &list);
	CGL_list_get_random(list, value);
	return true;
}

CGL_void CGL_markov_destroy(CGL_markov* markov)
{
	CGL_hashtable_iterator* iterator = CGL_hashtable_iterator_create(markov->hashtable);
	CGL_list* lst = NULL;
	while (CGL_hashtable_iterator_next(iterator, NULL, &lst, NULL)) CGL_list_destroy(lst);
	CGL_hashtable_iterator_destroy(iterator);
	CGL_hashtable_destroy(markov->hashtable);
	CGL_free(markov->temp_key);
	CGL_free(markov->temp_value);
	CGL_free(markov);
}

#endif

// text rendering
#ifndef CGL_EXCLUDE_TEXT_RENDER

#ifndef CGL_EXCLUDE_GRAPHICS_API

#include <ft2build.h>
#include FT_FREETYPE_H  

struct CGL_font
{
	CGL_font_character characters[128];
	CGL_texture* atlas;
	size_t atlas_width;
	size_t atlas_height;
	FT_Face face;
};

static FT_Library __CGL_free_type_library;

CGL_bool CGL_text_init()
{
	bool result = FT_Init_FreeType(&__CGL_free_type_library);
	if (result) { CGL_log_internal("Could not Initialize FreeType\n"); }
	return !result;
}

CGL_void CGL_text_shutdown()
{
	FT_Done_FreeType(__CGL_free_type_library);
}

static CGL_font* __CGL_font_create()
{
	CGL_font* font = (CGL_font*)CGL_malloc(sizeof(CGL_font));
	if (!font) return NULL;
	memset(font->characters, 0, sizeof(CGL_font_character) * 128);
	font->atlas_width = 0;
	font->atlas_height = 0;
	font->atlas = NULL;
	return font;
}

CGL_font* CGL_font_load_from_memory(const char* data, CGL_sizei size)
{
	CGL_font* font = __CGL_font_create();
	if (!font) return NULL;
	if (FT_New_Memory_Face(__CGL_free_type_library, (const FT_Byte*)data, (FT_Long)size, 0, &font->face)) { CGL_log_internal("Could not Load Font\n"); }
	return font;
}

CGL_font* CGL_font_load(const char* path)
{
	CGL_font* font = __CGL_font_create();
	if (!font) return NULL;
	if (FT_New_Face(__CGL_free_type_library, path, 0, &font->face)) { CGL_log_internal("Could not Load Font\n"); }
	return font;
}

CGL_void CGL_font_destory(CGL_font* font)
{
	FT_Done_Face(font->face);
	if (font->atlas) CGL_texture_destroy(font->atlas);
	for (size_t i = 0; i < 127; i++)
		if (font->characters[i].bitmap)
			CGL_free(font->characters[i].bitmap);
	CGL_free(font);
}

CGL_texture* CGL_font_get_atlas(CGL_font* font)
{
	return font->atlas;
}

CGL_bool CGL_font_build_atlas(CGL_font* font, size_t width, size_t height, size_t font_size)
{
	if (font->atlas) CGL_texture_destroy(font->atlas);
	FT_Set_Pixel_Sizes(font->face, 0, (FT_UInt)font_size);
	int64_t offset_x = 0;
	int64_t offset_y = 0;
	int64_t max_size_y = 0;
	font->atlas_width = width;
	font->atlas_height = height;
	font->atlas = CGL_texture_create_blank((int)width, (int)height, GL_RED, GL_RED, GL_UNSIGNED_BYTE);
	for (char ch = 0; ch < 127; ch++)
	{
		if (FT_Load_Char(font->face, (FT_ULong)ch, FT_LOAD_RENDER))
		{
			CGL_log_internal("Could not Font Load Character %c\n", ch);
			return false;
		}
		int64_t size_x = font->face->glyph->bitmap.width;
		int64_t size_y = font->face->glyph->bitmap.rows;

		if (font->characters[ch].bitmap) CGL_free(font->characters[ch].bitmap);
		font->characters[ch].size = CGL_vec2_init((float)size_x, (float)size_y);
		font->characters[ch].normalized_size = CGL_vec2_init((float)size_x / font->atlas_width, (float)size_y / font->atlas_height);
		font->characters[ch].offset = CGL_vec2_init((float)offset_x, (float)offset_y);
		font->characters[ch].normalized_offset = CGL_vec2_init((float)offset_x / font->atlas_width, (float)offset_y / font->atlas_height);
		font->characters[ch].bearing = CGL_vec2_init((float)font->face->glyph->bitmap_left, (float)font->face->glyph->bitmap_top);
		font->characters[ch].bearing_normalized = CGL_vec2_init((CGL_float)font->characters[ch].bearing.x / font->atlas_width, (CGL_float)font->characters[ch].bearing.y / font->atlas_height);
		font->characters[ch].advance = CGL_vec2_init((float)(font->face->glyph->advance.x >> 6), (float)0.0f);
		font->characters[ch].advance_normalized = CGL_vec2_init((CGL_float)font->characters[ch].advance.x / font->atlas_width, (CGL_float)font->characters[ch].advance.y / font->atlas_height);
		font->characters[ch].ch = ch;
		font->characters[ch].bitmap = (unsigned char*)CGL_malloc(sizeof(unsigned char) * size_x * size_y);
		if (!font->characters[ch].bitmap) return false;
		memcpy(font->characters[ch].bitmap, font->face->glyph->bitmap.buffer, (sizeof(unsigned char) * size_x * size_y));

		CGL_texture_set_sub_data(font->atlas, offset_x, offset_y, size_x, size_y, font->characters[ch].bitmap);

		offset_x += size_x + 5;
		max_size_y = max(max_size_y, size_y);
		if (((int64_t)width - offset_x) <= 10)
		{
			offset_x = 0;
			offset_y += max_size_y + 10;
			max_size_y = 0;
		}
	}
	return true;
}

CGL_font_character* CGL_font_get_characters(CGL_font* font)
{
	return font->characters;
}

CGL_texture* CGL_text_bake_to_texture(const char* string, size_t string_length, CGL_font* font, size_t* width, size_t* height)
{
	size_t tex_width = 0;
	size_t tex_height = 0;
	size_t max_bottom_pad = 0;
	for (CGL_int i = 0; i < string_length; i++)
	{
		char ch = string[i];
		tex_width += (((int)font->characters[ch].advance.x) >> 6);
		max_bottom_pad = max(max_bottom_pad, (size_t)(font->characters[ch].size.y - font->characters[ch].bearing.y));
		tex_height = max(tex_height, (size_t)font->characters[ch].size.y + max_bottom_pad);
	}
	if (width) *width = tex_width;
	if (height) *height = tex_height;
	CGL_texture* tex = CGL_texture_create_blank((int)tex_width, (int)tex_height, GL_RED, GL_RED, GL_UNSIGNED_BYTE);
	if (!tex) return NULL;
	size_t offset_x = 0;
	size_t offset_y = 0;
	for (CGL_int i = 0; i < string_length; i++)
	{
		char ch = string[i];
		size_t offset_x_local = offset_x + (size_t)font->characters[ch].bearing.x;
		size_t offset_y_local = offset_y + (size_t)(font->characters[ch].size.y - font->characters[ch].bearing.y) - max_bottom_pad;
		offset_y_local += ((tex_height)-(size_t)font->characters[ch].size.y);
		CGL_texture_set_sub_data(tex, offset_x_local, offset_y_local, (int)font->characters[ch].size.x, (int)font->characters[ch].size.y, font->characters[ch].bitmap);
		offset_x += (((int)font->characters[ch].advance.x) >> 6);
	}
	return tex;
}

#endif

#endif


// widgets
#ifndef CGL_EXCLUDE_WIDGETS
#ifndef CGL_GRAPHICS_API

struct CGL_widgets_context
{
	CGL_texture* active_textures[CGL_WIDGETS_MAX_TEXTURES];
	CGL_mat4 projection_matrix;
	CGL_mat4 view_matrix;
	CGL_mat4 model_matrix;
	CGL_mat4 view_proj_matrix;
	CGL_vec4 stroke_color;
	CGL_vec4 fill_color;
	CGL_vec4 mask;
	CGL_vec4 scale;
	CGL_vec4 offset;
	CGL_vec4 tex_coord_scale_offset;
	CGL_vec3 light_color;
	CGL_vec3 light_position;
	CGL_mesh_vertex* vertices;
	CGL_shader* shader;
	CGL_texture* texture;
	uint32_t* indices;
	size_t max_vertices;
	size_t vertices_count;
	size_t max_indices;
	size_t indices_count;
	CGL_float stroke_thickness;
	CGL_float aspect_ratio;
	GLuint vertex_array;
	GLuint vertex_buffer;
	GLuint index_buffer;
	CGL_int max_active_textures_supported;
	CGL_int active_texture_count;
	CGL_int active_texture_id;
	CGL_bool flushed;
	CGL_bool is_fill;
	CGL_bool adjust_for_aspect_ratio;
	CGL_bool transform_points_on_cpu;
	CGL_bool diffuse_shading_enabled;
	CGL_bool is_font_texture;
};

static const char* __CGL_WIDGETS_VERTEX_SHADER_SOURCE = 
#ifdef CGL_WASM	
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
"in vec4 position;\n"
"in vec4 normal;\n"
"in vec4 texcoord;\n"
"in vec4 texcoordscaleoffset;\n"
"in ivec4 texids;\n"
#else
"#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 normal;\n"
"layout (location = 2) in vec4 texcoord;\n"
"layout (location = 3) in vec4 texcoordscaleoffset;\n"
"layout (location = 4) in ivec4 texids;\n"
#endif
"\n"
"out vec3 Position;\n"
"out vec3 Normal;\n"
"out vec2 TexCoord; \n"
"out vec4 Color;\n"
"out vec4 TexCoordScaleOffset;\n"
"flat out int TexID;\n"
"flat out int UsingFontTexture;\n"
"\n"
"uniform bool u_TransformPointsOnCPU;\n"
"uniform mat4 u_ViewProjMatrix;\n"
"uniform mat4 u_ModelMatrix;\n"
"\n"
"void main()\n"
"{\n"
"   if(u_TransformPointsOnCPU)\n"
"   {\n"
"       gl_Position = vec4(position.xyz, 1.0f);\n"
"       Position = position.xyz;\n"
"       Normal = normal.xyz;\n"
"   }\n"
"	else\n"
"   {\n"
"       gl_Position = u_ViewProjMatrix * u_ModelMatrix * vec4(position.xyz, 1.0f);\n"
"	    Position = (u_ModelMatrix * vec4(position.xyz, 1.0f)).xyz;\n"
"       mat3 normal_matrix = transpose(inverse(mat3(u_ModelMatrix)));\n"
"	    Normal = normal_matrix * normal.xyz;\n"
"   }\n"
"	TexCoord = texcoord.xy;\n"
"	TexID = texids.x;\n"
"	UsingFontTexture = texids.y;\n"
"	TexCoordScaleOffset = texcoordscaleoffset;\n"
"	Color = vec4(position.w, texcoord.zw, 1.0);\n"
"}";

static const char* __CGL_WIDGETS_FRAGMENT_SHADER_SOURCE = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
#else
"#version 430 core\n"
#endif
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Position;\n"
"in vec3 Normal;\n"
"in vec2 TexCoord;\n"
"in vec4 Color;\n"
"in vec4 TexCoordScaleOffset;\n"
"flat in int TexID;\n"
"flat in int UsingFontTexture;\n"
"\n"
"uniform bool u_DiffuseShadingEnabled;\n"
"uniform vec3 u_LightColor;\n"
"uniform vec3 u_LightPosition;\n"
"uniform sampler2D u_Texture[16];\n"
"uniform vec4 u_Mask;\n"
"\n"
"// It has to be done this way as some WebGL implementations do not support indexing into u_Textures with TexID\n"
"vec4 sampleTexture()\n"
"{\n"
"    vec2 adjustedTexCoord = TexCoord * TexCoordScaleOffset.xy + TexCoordScaleOffset.zw;\n"
"\n"
"    switch (TexID)\n"
"    {\n"
"        case 0: return texture(u_Texture[0], adjustedTexCoord);\n"
"        case 1: return texture(u_Texture[1], adjustedTexCoord);\n"
"        case 2: return texture(u_Texture[2], adjustedTexCoord);\n"
"        case 3: return texture(u_Texture[3], adjustedTexCoord);\n"
"        case 4: return texture(u_Texture[4], adjustedTexCoord);\n"
"        case 5: return texture(u_Texture[5], adjustedTexCoord);\n"
"        case 6: return texture(u_Texture[6], adjustedTexCoord);\n"
"        case 7: return texture(u_Texture[7], adjustedTexCoord);\n"
"        case 8: return texture(u_Texture[8], adjustedTexCoord);\n"
"        case 9: return texture(u_Texture[9], adjustedTexCoord);\n"
"        case 10: return texture(u_Texture[10], adjustedTexCoord);\n"
"        case 11: return texture(u_Texture[11], adjustedTexCoord);\n"
"        case 12: return texture(u_Texture[12], adjustedTexCoord);\n"
"        case 13: return texture(u_Texture[13], adjustedTexCoord);\n"
"        case 14: return texture(u_Texture[14], adjustedTexCoord);\n"
"        case 15: return texture(u_Texture[15], adjustedTexCoord);\n"
"        default: return vec4(1.0); // Return white color if TexID is invalid\n"
"    }\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	vec4 color = Color;\n"
"	if(TexID > -1)\n"
"	{\n"
"		color = sampleTexture();\n"
"       if(UsingFontTexture == 1)\n"
"       {\n"
"           color = color.r * Color;\n"
"           if(color.r < 0.1f) discard;\n"
"       }\n"
"	}\n"
"	if(u_DiffuseShadingEnabled)\n"
"	{\n"
"		float ambient_strength = 0.1f;\n"
"		vec3 ambient = ambient_strength * u_LightColor;\n"
"		vec3 norm = normalize(Normal);\n"
"		vec3 light_dir = normalize(u_LightPosition - Position);\n"
"		float diff = max(dot(norm, light_dir), 0.0);\n"
"		vec3 diffuse = diff * u_LightColor;\n"
"		color.rgb = (diffuse + ambient) * color.rgb;\n"
"	}\n"
"   else\n"
"   {\n"
"       if (Position.x < u_Mask.x || Position.y < u_Mask.y || Position.x > u_Mask.z || Position.y > u_Mask.w)\n"
"           discard;\n"
"   }\n"
"	FragColor = color;\n"
"}";

static CGL_widgets_context* __CGL_WIDGETS_CURRENT_CONTEXT = NULL;

CGL_widgets_context* CGL_widgets_context_create(size_t max_vertices, size_t max_indices)
{
	CGL_widgets_context* context = (CGL_widgets_context*)CGL_malloc(sizeof(CGL_widgets_context));
	if (!context) return NULL;
	context->max_indices = max_indices;
	context->max_vertices = max_vertices;
	context->vertices = (CGL_mesh_vertex*)CGL_malloc(sizeof(CGL_mesh_vertex) * max_vertices);
	context->indices = (uint32_t*)CGL_malloc(sizeof(uint32_t) * max_indices);
	context->vertices_count = 0;
	context->indices_count = 0;
	context->flushed = true;
	context->adjust_for_aspect_ratio = false;
	context->transform_points_on_cpu = false;
	context->aspect_ratio = 1.0f;
	context->texture = NULL;
	context->is_font_texture = false;
	context->tex_coord_scale_offset = CGL_vec4_init(1.0f, 1.0f, 0.0f, 0.0f);
	context->offset = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	context->scale = CGL_vec4_init(1.0f, 1.0f, 1.0f, 1.0f);
	context->projection_matrix = CGL_mat4_identity();
	context->view_matrix = CGL_mat4_identity();
	context->model_matrix = CGL_mat4_identity();
	context->view_proj_matrix = CGL_mat4_identity();
	context->diffuse_shading_enabled = false;
	context->light_color = CGL_vec3_init(1.0f, 1.0f, 1.0f);
	context->light_position = CGL_vec3_init(100.0f, 100.0f, 100.0f);
	context->active_texture_count = 0;
	glGetIntegerv(GL_MAX_TEXTURE_IMAGE_UNITS, &context->max_active_textures_supported);
	context->max_active_textures_supported = CGL_utils_max(context->max_active_textures_supported, 1);
	context->max_active_textures_supported = CGL_utils_min(context->max_active_textures_supported, CGL_WIDGETS_MAX_TEXTURES);
	glGenVertexArrays(1, &context->vertex_array);
	glBindVertexArray(context->vertex_array);
	glGenBuffers(1, &context->vertex_buffer);
	glBindBuffer(GL_ARRAY_BUFFER, context->vertex_buffer);
	glGenBuffers(1, &context->index_buffer);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, context->index_buffer);
	glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, sizeof(CGL_mesh_vertex), (void*)offsetof(CGL_mesh_vertex, position));
	glEnableVertexAttribArray(0);
	glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, sizeof(CGL_mesh_vertex), (void*)offsetof(CGL_mesh_vertex, normal));
	glEnableVertexAttribArray(1);
	glVertexAttribPointer(2, 4, GL_FLOAT, GL_FALSE, sizeof(CGL_mesh_vertex), (void*)offsetof(CGL_mesh_vertex, texture_coordinates));
	glEnableVertexAttribArray(2);
	glVertexAttribPointer(3, 4, GL_FLOAT, GL_FALSE, sizeof(CGL_mesh_vertex), (void*)offsetof(CGL_mesh_vertex, bone_wieghts));
	glEnableVertexAttribArray(3);
	glVertexAttribIPointer(4, 4, GL_INT, sizeof(CGL_mesh_vertex), (void*)offsetof(CGL_mesh_vertex, bone_ids));
	glEnableVertexAttribArray(4);
	context->shader = CGL_shader_create(__CGL_WIDGETS_VERTEX_SHADER_SOURCE, __CGL_WIDGETS_FRAGMENT_SHADER_SOURCE, NULL);
	return context;
}

CGL_void CGL_widgets_context_destory(CGL_widgets_context* context)
{
	glDeleteBuffers(1, &context->index_buffer);
	glDeleteBuffers(1, &context->vertex_buffer);
	glDeleteVertexArrays(1, &context->vertex_array);
	CGL_shader_destroy(context->shader);
	if (context->indices) CGL_free(context->indices);
	if (context->vertices) CGL_free(context->vertices);
	CGL_free(context);
}

CGL_void CGL_widgets_adjust_for_aspect_ratio(CGL_float aspect_ratio)
{
	__CGL_WIDGETS_CURRENT_CONTEXT->aspect_ratio = aspect_ratio;
	__CGL_WIDGETS_CURRENT_CONTEXT->adjust_for_aspect_ratio = true;
}

CGL_void CGL_widgets_do_not_adjust_for_aspect_ratio()
{
	__CGL_WIDGETS_CURRENT_CONTEXT->adjust_for_aspect_ratio = false;
}

CGL_widgets_context* CGL_window_get_current_context()
{
	return __CGL_WIDGETS_CURRENT_CONTEXT;
}

CGL_bool CGL_widgets_init()
{
	__CGL_WIDGETS_CURRENT_CONTEXT = CGL_widgets_context_create(CGL_WIDGETS_MAX_VERTICES, CGL_WIDGETS_MAX_INDICES);
	return __CGL_WIDGETS_CURRENT_CONTEXT != NULL;
}

CGL_void CGL_widgets_shutdown()
{
	if (__CGL_WIDGETS_CURRENT_CONTEXT) CGL_widgets_context_destory(__CGL_WIDGETS_CURRENT_CONTEXT);
}

CGL_void CGL_window_set_current_context(CGL_widgets_context* context)
{
	if (context) __CGL_WIDGETS_CURRENT_CONTEXT = context;
}

CGL_bool CGL_widgets_begin_int(CGL_float scale_x, CGL_float scale_y, CGL_float offset_x, CGL_float offset_y)
{
	__CGL_WIDGETS_CURRENT_CONTEXT->flushed = false;
	__CGL_WIDGETS_CURRENT_CONTEXT->is_fill = true;
	__CGL_WIDGETS_CURRENT_CONTEXT->transform_points_on_cpu = false;
	__CGL_WIDGETS_CURRENT_CONTEXT->stroke_color = CGL_vec4_init(0.0f, 0.0f, 0.0f, 1.0f);
	__CGL_WIDGETS_CURRENT_CONTEXT->fill_color = CGL_vec4_init(1.0f, 1.0f, 1.0f, 1.0f);
	__CGL_WIDGETS_CURRENT_CONTEXT->model_matrix = CGL_mat4_identity();
	__CGL_WIDGETS_CURRENT_CONTEXT->view_matrix = CGL_mat4_identity();
	__CGL_WIDGETS_CURRENT_CONTEXT->projection_matrix = CGL_mat4_identity();
	__CGL_WIDGETS_CURRENT_CONTEXT->view_proj_matrix = CGL_mat4_identity();
	__CGL_WIDGETS_CURRENT_CONTEXT->diffuse_shading_enabled = false;
	__CGL_WIDGETS_CURRENT_CONTEXT->light_color = CGL_vec3_init(1.0f, 1.0f, 1.0f);
	__CGL_WIDGETS_CURRENT_CONTEXT->light_position = CGL_vec3_init(100.0f, 100.0f, 100.0f);
	__CGL_WIDGETS_CURRENT_CONTEXT->stroke_thickness = 0.05f;
	__CGL_WIDGETS_CURRENT_CONTEXT->scale = CGL_vec4_init(scale_x, scale_y, 1.0f, 1.0f);
	__CGL_WIDGETS_CURRENT_CONTEXT->offset = CGL_vec4_init(offset_x, offset_y, 0.0f, 0.0f);
	__CGL_WIDGETS_CURRENT_CONTEXT->mask = CGL_vec4_init(-1.0f, -1.0f, 1.0f, 1.0f);
	__CGL_WIDGETS_CURRENT_CONTEXT->tex_coord_scale_offset = CGL_vec4_init(1.0f, 1.0f, 0.0f, 0.0f);
	__CGL_WIDGETS_CURRENT_CONTEXT->active_texture_count = 0;
	__CGL_WIDGETS_CURRENT_CONTEXT->active_texture_id = -1;
	__CGL_WIDGETS_CURRENT_CONTEXT->is_font_texture = false;
	return true;
}

CGL_bool CGL_widgets_begin()
{
	return CGL_widgets_begin_int(1.0f, 1.0f, 0.0f, 0.0f);
}

CGL_bool CGL_widgets_end()
{
	return CGL_widgets_flush();
}

CGL_bool CGL_widgets_flush()
{
	//if(__CGL_WIDGETS_CURRENT_CONTEXT->flushed) return false;
	if (__CGL_WIDGETS_CURRENT_CONTEXT->vertices_count == 0 || __CGL_WIDGETS_CURRENT_CONTEXT->indices_count == 0) return false;
	// first upload the data
	glBindVertexArray(__CGL_WIDGETS_CURRENT_CONTEXT->vertex_array);
	glBindBuffer(GL_ARRAY_BUFFER, __CGL_WIDGETS_CURRENT_CONTEXT->vertex_buffer);
	glBufferData(GL_ARRAY_BUFFER, __CGL_WIDGETS_CURRENT_CONTEXT->vertices_count * sizeof(CGL_mesh_vertex), __CGL_WIDGETS_CURRENT_CONTEXT->vertices, GL_DYNAMIC_DRAW);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, __CGL_WIDGETS_CURRENT_CONTEXT->index_buffer);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, __CGL_WIDGETS_CURRENT_CONTEXT->indices_count * sizeof(uint32_t), __CGL_WIDGETS_CURRENT_CONTEXT->indices, GL_DYNAMIC_DRAW);
	// render
	CGL_shader_bind(__CGL_WIDGETS_CURRENT_CONTEXT->shader);
	CGL_shader_set_uniform_bool(__CGL_WIDGETS_CURRENT_CONTEXT->shader, CGL_shader_get_uniform_location(__CGL_WIDGETS_CURRENT_CONTEXT->shader, "u_TransformPointsOnCPU"), __CGL_WIDGETS_CURRENT_CONTEXT->transform_points_on_cpu);
	if (!__CGL_WIDGETS_CURRENT_CONTEXT->transform_points_on_cpu)
	{
		CGL_shader_set_uniform_mat4(__CGL_WIDGETS_CURRENT_CONTEXT->shader, CGL_shader_get_uniform_location(__CGL_WIDGETS_CURRENT_CONTEXT->shader, "u_ViewProjMatrix"), &__CGL_WIDGETS_CURRENT_CONTEXT->view_proj_matrix);
		CGL_shader_set_uniform_mat4(__CGL_WIDGETS_CURRENT_CONTEXT->shader, CGL_shader_get_uniform_location(__CGL_WIDGETS_CURRENT_CONTEXT->shader, "u_ModelMatrix"), &__CGL_WIDGETS_CURRENT_CONTEXT->model_matrix);
	}
	CGL_shader_set_uniform_bool(__CGL_WIDGETS_CURRENT_CONTEXT->shader, CGL_shader_get_uniform_location(__CGL_WIDGETS_CURRENT_CONTEXT->shader, "u_DiffuseShadingEnabled"), __CGL_WIDGETS_CURRENT_CONTEXT->diffuse_shading_enabled);
	if (__CGL_WIDGETS_CURRENT_CONTEXT->diffuse_shading_enabled)
	{
		CGL_shader_set_uniform_vec3v(__CGL_WIDGETS_CURRENT_CONTEXT->shader, CGL_shader_get_uniform_location(__CGL_WIDGETS_CURRENT_CONTEXT->shader, "u_LightPosition"), __CGL_WIDGETS_CURRENT_CONTEXT->light_position.x, __CGL_WIDGETS_CURRENT_CONTEXT->light_position.y, __CGL_WIDGETS_CURRENT_CONTEXT->light_position.z);
		CGL_shader_set_uniform_vec3v(__CGL_WIDGETS_CURRENT_CONTEXT->shader, CGL_shader_get_uniform_location(__CGL_WIDGETS_CURRENT_CONTEXT->shader, "u_LightColor"), __CGL_WIDGETS_CURRENT_CONTEXT->light_color.x, __CGL_WIDGETS_CURRENT_CONTEXT->light_color.y, __CGL_WIDGETS_CURRENT_CONTEXT->light_color.z);
	}
	//CGL_shader_set_uniform_bool(__CGL_WIDGETS_CURRENT_CONTEXT->shader, CGL_shader_get_uniform_location(__CGL_WIDGETS_CURRENT_CONTEXT->shader, "u_TextureEnabled"), __CGL_WIDGETS_CURRENT_CONTEXT->texture != NULL);
	//if(__CGL_WIDGETS_CURRENT_CONTEXT->texture != NULL)
	//{
		//CGL_texture_bind(__CGL_WIDGETS_CURRENT_CONTEXT->texture, 5);
		//CGL_shader_set_uniform_int(__CGL_WIDGETS_CURRENT_CONTEXT->shader, CGL_shader_get_uniform_location(__CGL_WIDGETS_CURRENT_CONTEXT->shader, "u_Texture"), 5);
	//}
	CGL_shader_set_uniform_vec4v(__CGL_WIDGETS_CURRENT_CONTEXT->shader, CGL_shader_get_uniform_location(__CGL_WIDGETS_CURRENT_CONTEXT->shader, "u_Mask"), __CGL_WIDGETS_CURRENT_CONTEXT->mask.x, __CGL_WIDGETS_CURRENT_CONTEXT->mask.y, __CGL_WIDGETS_CURRENT_CONTEXT->mask.z, __CGL_WIDGETS_CURRENT_CONTEXT->mask.w);
	for (CGL_int i = 0; i < __CGL_WIDGETS_CURRENT_CONTEXT->active_texture_count; i++)
	{
		static CGL_byte texture_uniform_name_buffer[64];
		sprintf(texture_uniform_name_buffer, "u_Texture[%d]", i);
		if (__CGL_WIDGETS_CURRENT_CONTEXT->active_textures[i] != NULL) CGL_texture_bind(__CGL_WIDGETS_CURRENT_CONTEXT->active_textures[i], i);
		CGL_shader_set_uniform_int(__CGL_WIDGETS_CURRENT_CONTEXT->shader, CGL_shader_get_uniform_location(__CGL_WIDGETS_CURRENT_CONTEXT->shader, texture_uniform_name_buffer), i);
	}
	glBindVertexArray(__CGL_WIDGETS_CURRENT_CONTEXT->vertex_array);
	glDrawElements(GL_TRIANGLES, (GLsizei)__CGL_WIDGETS_CURRENT_CONTEXT->indices_count, GL_UNSIGNED_INT, NULL);
	glBindVertexArray(0);
	glUseProgram(0);
	__CGL_WIDGETS_CURRENT_CONTEXT->vertices_count = 0;
	__CGL_WIDGETS_CURRENT_CONTEXT->indices_count = 0;
	__CGL_WIDGETS_CURRENT_CONTEXT->flushed = true;
	return true;
}

bool CGL_widgets_flush_if_required()
{
	//if(__CGL_WIDGETS_CURRENT_CONTEXT->flushed) return false;
	if (__CGL_WIDGETS_CURRENT_CONTEXT->vertices_count >= (__CGL_WIDGETS_CURRENT_CONTEXT->max_vertices - 10) && __CGL_WIDGETS_CURRENT_CONTEXT->indices_count % 3 == 0) return CGL_widgets_flush();
	return false;
}


// NOTE: Deprecated
/*
bool CGL_widgets_add_vertices(CGL_mesh_vertex* vertices, size_t vertex_count, uint32_t* indices, size_t index_count)
{
	if(__CGL_WIDGETS_CURRENT_CONTEXT->vertices_count + vertex_count >= (__CGL_WIDGETS_CURRENT_CONTEXT->max_vertices - 10)) return false;
	if(__CGL_WIDGETS_CURRENT_CONTEXT->indices_count + index_count >= (__CGL_WIDGETS_CURRENT_CONTEXT->max_indices - 10)) return false;
	memcpy(&__CGL_WIDGETS_CURRENT_CONTEXT->vertices[__CGL_WIDGETS_CURRENT_CONTEXT->vertices_count], vertices, sizeof(CGL_mesh_vertex) * vertex_count);
	memcpy(&__CGL_WIDGETS_CURRENT_CONTEXT->indices[__CGL_WIDGETS_CURRENT_CONTEXT->indices_count], indices, sizeof(uint32_t) * index_count);
	for(size_t i = __CGL_WIDGETS_CURRENT_CONTEXT->indices_count ; i < __CGL_WIDGETS_CURRENT_CONTEXT->indices_count + index_count ; i++) __CGL_WIDGETS_CURRENT_CONTEXT->indices[i] += (uint32_t)__CGL_WIDGETS_CURRENT_CONTEXT->vertices_count;
	__CGL_WIDGETS_CURRENT_CONTEXT->vertices_count += vertex_count;
	__CGL_WIDGETS_CURRENT_CONTEXT->indices_count += index_count;
	CGL_widgets_flush_if_required();
	return true;
}
*/

CGL_void CGL_widgets_add_vertex(CGL_mesh_vertex* vertex)
{
	CGL_widgets_flush_if_required();
	CGL_vec4 scale = __CGL_WIDGETS_CURRENT_CONTEXT->scale;
	if (__CGL_WIDGETS_CURRENT_CONTEXT->adjust_for_aspect_ratio)
	{
		// for now only works for 2D
		if (scale.x > scale.y) scale.x = scale.y / __CGL_WIDGETS_CURRENT_CONTEXT->aspect_ratio;
		else scale.y = scale.x * __CGL_WIDGETS_CURRENT_CONTEXT->aspect_ratio;
	}


	vertex->position.x = vertex->position.x * scale.x + __CGL_WIDGETS_CURRENT_CONTEXT->offset.x;
	vertex->position.y = vertex->position.y * scale.y + __CGL_WIDGETS_CURRENT_CONTEXT->offset.y;
	vertex->position.z = vertex->position.z * scale.z + __CGL_WIDGETS_CURRENT_CONTEXT->offset.z; // for future

	if (__CGL_WIDGETS_CURRENT_CONTEXT->transform_points_on_cpu)
	{
		// BUG: This is not working properly
		CGL_mat4 transform_matrix = CGL_mat4_mul(__CGL_WIDGETS_CURRENT_CONTEXT->view_proj_matrix, __CGL_WIDGETS_CURRENT_CONTEXT->model_matrix);
		vertex->position.w = 1.0f; vertex->position = CGL_mat4_mul_vec4(transform_matrix, vertex->position);
		vertex->normal.w = 0.0f; vertex->normal = CGL_mat4_mul_vec4(transform_matrix, vertex->normal);
	}


	__CGL_WIDGETS_CURRENT_CONTEXT->vertices[__CGL_WIDGETS_CURRENT_CONTEXT->vertices_count++] = *vertex;
	__CGL_WIDGETS_CURRENT_CONTEXT->indices[__CGL_WIDGETS_CURRENT_CONTEXT->indices_count++] = (uint32_t)(__CGL_WIDGETS_CURRENT_CONTEXT->vertices_count - 1);
	CGL_vec4 vt_color = __CGL_WIDGETS_CURRENT_CONTEXT->stroke_color;
	if (__CGL_WIDGETS_CURRENT_CONTEXT->is_fill) vt_color = __CGL_WIDGETS_CURRENT_CONTEXT->fill_color;
	__CGL_WIDGETS_CURRENT_CONTEXT->vertices[__CGL_WIDGETS_CURRENT_CONTEXT->vertices_count - 1].bone_wieghts = __CGL_WIDGETS_CURRENT_CONTEXT->tex_coord_scale_offset;
	if (__CGL_WIDGETS_CURRENT_CONTEXT->active_texture_id == -1 || __CGL_WIDGETS_CURRENT_CONTEXT->active_textures[__CGL_WIDGETS_CURRENT_CONTEXT->active_texture_id] == NULL) __CGL_WIDGETS_CURRENT_CONTEXT->vertices[__CGL_WIDGETS_CURRENT_CONTEXT->vertices_count - 1].bone_ids = CGL_ivec4_init(-1, 0, 0, 0);
	else   __CGL_WIDGETS_CURRENT_CONTEXT->vertices[__CGL_WIDGETS_CURRENT_CONTEXT->vertices_count - 1].bone_ids = CGL_ivec4_init(__CGL_WIDGETS_CURRENT_CONTEXT->active_texture_id, __CGL_WIDGETS_CURRENT_CONTEXT->is_font_texture ? 1 : 0, 0, 0);
	__CGL_WIDGETS_CURRENT_CONTEXT->vertices[__CGL_WIDGETS_CURRENT_CONTEXT->vertices_count - 1].position.w = vt_color.x;
	__CGL_WIDGETS_CURRENT_CONTEXT->vertices[__CGL_WIDGETS_CURRENT_CONTEXT->vertices_count - 1].texture_coordinates.z = vt_color.y;
	__CGL_WIDGETS_CURRENT_CONTEXT->vertices[__CGL_WIDGETS_CURRENT_CONTEXT->vertices_count - 1].texture_coordinates.w = vt_color.z;
	__CGL_WIDGETS_CURRENT_CONTEXT->vertices[__CGL_WIDGETS_CURRENT_CONTEXT->vertices_count - 1].normal.w = vt_color.w;
}

CGL_void CGL_widgets_add_mesh(CGL_mesh_cpu* mesh)
{
	for (size_t i = 0; i < mesh->index_count_used / 3; i++)
	{
		CGL_int fa = mesh->indices[i * 3], fb = mesh->indices[i * 3 + 1], fc = mesh->indices[i * 3 + 2];
		CGL_widgets_add_vertex(&mesh->vertices[fa]);
		CGL_widgets_add_vertex(&mesh->vertices[fb]);
		CGL_widgets_add_vertex(&mesh->vertices[fc]);
	}
}

CGL_void CGL_widgets_add_vertex_pt(CGL_vec3 position, CGL_vec2 tex_coord)
{
	CGL_mesh_vertex vertex = { 0 };
	vertex.position = CGL_vec4_init(position.x, position.y, position.z, 1.0f);
	vertex.texture_coordinates = CGL_vec4_init(tex_coord.x, tex_coord.y, 0.0f, 0.0f);
	vertex.normal = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
	if ((__CGL_WIDGETS_CURRENT_CONTEXT->vertices_count + 1) % 3 == 0)
	{
		CGL_vec4 a = __CGL_WIDGETS_CURRENT_CONTEXT->vertices[__CGL_WIDGETS_CURRENT_CONTEXT->vertices_count - 2].position;
		CGL_vec4 b = __CGL_WIDGETS_CURRENT_CONTEXT->vertices[__CGL_WIDGETS_CURRENT_CONTEXT->vertices_count - 1].position;
		CGL_vec4 c = vertex.position;
		CGL_vec3 ab = CGL_vec3_sub(b, a);
		CGL_vec3 bc = CGL_vec3_sub(c, b);
		CGL_vec3 normal = CGL_vec3_cross(ab, bc);
		__CGL_WIDGETS_CURRENT_CONTEXT->vertices[__CGL_WIDGETS_CURRENT_CONTEXT->vertices_count - 2].normal = CGL_vec4_init(normal.x, normal.y, normal.z, 0.0f);
		__CGL_WIDGETS_CURRENT_CONTEXT->vertices[__CGL_WIDGETS_CURRENT_CONTEXT->vertices_count - 1].normal = CGL_vec4_init(normal.x, normal.y, normal.z, 0.0f);
		vertex.normal = CGL_vec4_init(normal.x, normal.y, normal.z, 0.0f);
	}
	CGL_widgets_add_vertex(&vertex);
}

CGL_void CGL_widgets_add_vertex_p3ft2f(CGL_float pos_x, CGL_float pos_y, CGL_float pos_z, CGL_float tex_x, CGL_float tex_y)
{
	CGL_widgets_add_vertex_pt(CGL_vec3_init(pos_x, pos_y, pos_z), CGL_vec2_init(tex_x, tex_y));
}

CGL_void CGL_widgets_add_vertex_p(CGL_vec3 position)
{
	CGL_widgets_add_vertex_pt(position, CGL_vec2_init(0.0f, 0.0f));
}

CGL_void CGL_widgets_add_vertex_p3f(CGL_float pos_x, CGL_float pos_y, CGL_float pos_z)
{
	CGL_widgets_add_vertex_pt(CGL_vec3_init(pos_x, pos_y, pos_z), CGL_vec2_init(0.0f, 0.0f));
}

CGL_void CGL_widgets_add_vertex_p3ft(CGL_float pos_x, CGL_float pos_y, CGL_float pos_z, CGL_vec2 tex_coord)
{
	CGL_widgets_add_vertex_pt(CGL_vec3_init(pos_x, pos_y, pos_z), tex_coord);
}

CGL_void CGL_widgets_add_vertex_pt2f(CGL_vec3 position, CGL_float tex_x, CGL_float tex_y)
{
	CGL_widgets_add_vertex_pt(position, CGL_vec2_init(tex_x, tex_y));
}

CGL_void CGL_widgets_set_stroke_color(CGL_color color)
{
	__CGL_WIDGETS_CURRENT_CONTEXT->active_texture_id = -1;
	__CGL_WIDGETS_CURRENT_CONTEXT->stroke_color = CGL_vec4_init(color.x, color.y, color.z, color.w);
}

CGL_void CGL_widgets_set_stroke_colorf(CGL_float r, CGL_float g, CGL_float b, CGL_float a)
{
	__CGL_WIDGETS_CURRENT_CONTEXT->active_texture_id = -1;
	__CGL_WIDGETS_CURRENT_CONTEXT->stroke_color = CGL_vec4_init(r, g, b, a);
}

CGL_void CGL_widgets_set_mask(CGL_vec4 mask)
{
	__CGL_WIDGETS_CURRENT_CONTEXT->mask = mask;
}

CGL_void CGL_widgets_set_maskf(CGL_float min_x, CGL_float min_y, CGL_float max_x, CGL_float max_y)
{
	__CGL_WIDGETS_CURRENT_CONTEXT->mask = CGL_vec4_init(min_x, min_y, max_x, max_y);
}

CGL_void CGL_widgets_set_stroke_thicnkess(CGL_float thickness)
{
	__CGL_WIDGETS_CURRENT_CONTEXT->stroke_thickness = thickness;
}

CGL_void CGL_widgets_set_fill_color(CGL_color color)
{
	__CGL_WIDGETS_CURRENT_CONTEXT->active_texture_id = -1;
	__CGL_WIDGETS_CURRENT_CONTEXT->fill_color = CGL_vec4_init(color.x, color.y, color.z, color.w);
}

CGL_void CGL_widgets_set_fill_colorf(CGL_float r, CGL_float g, CGL_float b, CGL_float a)
{
	__CGL_WIDGETS_CURRENT_CONTEXT->active_texture_id = -1;
	__CGL_WIDGETS_CURRENT_CONTEXT->fill_color = CGL_vec4_init(r, g, b, a);
}

CGL_void CGL_widgets_set_fill_mode(bool is_enabled)
{
	__CGL_WIDGETS_CURRENT_CONTEXT->is_fill = is_enabled;
}

CGL_void CGL_widgets_set_projection_matrix(CGL_mat4* matrix)
{
	if (!__CGL_WIDGETS_CURRENT_CONTEXT->transform_points_on_cpu) CGL_widgets_flush();
	if (matrix == NULL)
	{
		__CGL_WIDGETS_CURRENT_CONTEXT->projection_matrix = CGL_mat4_identity();
		__CGL_WIDGETS_CURRENT_CONTEXT->view_proj_matrix = CGL_mat4_mul(__CGL_WIDGETS_CURRENT_CONTEXT->projection_matrix, __CGL_WIDGETS_CURRENT_CONTEXT->view_matrix);
		return;
	}
	__CGL_WIDGETS_CURRENT_CONTEXT->projection_matrix = *matrix;
	__CGL_WIDGETS_CURRENT_CONTEXT->view_proj_matrix = CGL_mat4_mul(__CGL_WIDGETS_CURRENT_CONTEXT->projection_matrix, __CGL_WIDGETS_CURRENT_CONTEXT->view_matrix);
}

CGL_void CGL_widgets_set_view_matrix(CGL_mat4* matrix)
{
	if (!__CGL_WIDGETS_CURRENT_CONTEXT->transform_points_on_cpu) CGL_widgets_flush();
	if (matrix == NULL)
	{
		__CGL_WIDGETS_CURRENT_CONTEXT->view_matrix = CGL_mat4_identity();
		__CGL_WIDGETS_CURRENT_CONTEXT->view_proj_matrix = CGL_mat4_mul(__CGL_WIDGETS_CURRENT_CONTEXT->projection_matrix, __CGL_WIDGETS_CURRENT_CONTEXT->view_matrix);
		return;
	}
	__CGL_WIDGETS_CURRENT_CONTEXT->view_matrix = *matrix;
	__CGL_WIDGETS_CURRENT_CONTEXT->view_proj_matrix = CGL_mat4_mul(__CGL_WIDGETS_CURRENT_CONTEXT->projection_matrix, __CGL_WIDGETS_CURRENT_CONTEXT->view_matrix);
}

CGL_void CGL_widgets_set_model_matrix(CGL_mat4* matrix)
{
	if (!__CGL_WIDGETS_CURRENT_CONTEXT->transform_points_on_cpu) CGL_widgets_flush();
	if (matrix == NULL) { __CGL_WIDGETS_CURRENT_CONTEXT->model_matrix = CGL_mat4_identity(); return; }
	__CGL_WIDGETS_CURRENT_CONTEXT->model_matrix = *matrix;
}



static CGL_void __CGL_widgets_set_texture(CGL_texture* texture, CGL_bool is_font_texture)
{
	__CGL_WIDGETS_CURRENT_CONTEXT->is_font_texture = is_font_texture;
	for (CGL_int i = 0; i < __CGL_WIDGETS_CURRENT_CONTEXT->active_texture_count; i++)
	{
		if (__CGL_WIDGETS_CURRENT_CONTEXT->active_textures[i] == texture)
		{
			__CGL_WIDGETS_CURRENT_CONTEXT->active_texture_id = i;
			return;
		}
	}
	if (__CGL_WIDGETS_CURRENT_CONTEXT->active_texture_count >= CGL_WIDGETS_MAX_TEXTURES)
	{
		CGL_widgets_flush();
		__CGL_WIDGETS_CURRENT_CONTEXT->active_texture_count = 0;
	}
	__CGL_WIDGETS_CURRENT_CONTEXT->active_texture_id = __CGL_WIDGETS_CURRENT_CONTEXT->active_texture_count;
	__CGL_WIDGETS_CURRENT_CONTEXT->active_textures[__CGL_WIDGETS_CURRENT_CONTEXT->active_texture_count++] = texture;
	__CGL_WIDGETS_CURRENT_CONTEXT->tex_coord_scale_offset = CGL_vec4_init(1.0f, 1.0f, 0.0f, 0.0f);

}

CGL_void CGL_widgets_set_texture(CGL_texture* texture)
{
	__CGL_widgets_set_texture(texture, false);
}

CGL_void CGL_widgets_set_font_texture(CGL_texture* texture)
{
	__CGL_widgets_set_texture(texture, true);
}

CGL_void CGL_widgets_set_texture_coordinate_so(CGL_float scale_x, CGL_float scale_y, CGL_float offset_x, CGL_float offset_y)
{
	__CGL_WIDGETS_CURRENT_CONTEXT->tex_coord_scale_offset = CGL_vec4_init(scale_x, scale_y, offset_x, offset_y);
}

CGL_void CGL_widgets_enable_diffuse_shading(CGL_vec3 light_position, CGL_vec3 light_color)
{
	CGL_widgets_flush();
	__CGL_WIDGETS_CURRENT_CONTEXT->diffuse_shading_enabled = true;
	__CGL_WIDGETS_CURRENT_CONTEXT->light_position = light_position;
	__CGL_WIDGETS_CURRENT_CONTEXT->light_color = light_color;
}

CGL_void CGL_widgets_disable_diffuse_shading()
{
	CGL_widgets_flush();
	__CGL_WIDGETS_CURRENT_CONTEXT->diffuse_shading_enabled = false;
}

CGL_void CGL_widgets_apply_transformations_on_cpu()
{
	CGL_widgets_flush();
	__CGL_WIDGETS_CURRENT_CONTEXT->transform_points_on_cpu = true;
}
CGL_void CGL_widgets_apply_transformations_on_gpu()
{
	CGL_widgets_flush();
	__CGL_WIDGETS_CURRENT_CONTEXT->transform_points_on_cpu = false;
}

CGL_void __CGL_widgets_add_triangle_filled(CGL_vec3 a, CGL_vec3 b, CGL_vec3 c)
{
	CGL_widgets_add_vertex_p(a);
	CGL_widgets_add_vertex_p(b);
	CGL_widgets_add_vertex_p(c);
}

static CGL_void __CGL_widgets_add_triangle_stroked(CGL_vec3 a, CGL_vec3 b, CGL_vec3 c)
{
	CGL_widgets_add_line(a, b);
	CGL_widgets_add_line(b, c);
	CGL_widgets_add_line(a, c);
}

CGL_void CGL_widgets_add_triangle(CGL_vec3 a, CGL_vec3 b, CGL_vec3 c)
{
	if (__CGL_WIDGETS_CURRENT_CONTEXT->is_fill) __CGL_widgets_add_triangle_filled(a, b, c);
	else __CGL_widgets_add_triangle_stroked(a, b, c);
}

static CGL_void __CGL_widgets_add_quad_filled(CGL_vec3 a, CGL_vec3 b, CGL_vec3 c, CGL_vec3 d)
{
	CGL_widgets_add_vertex_pt2f(a, 0.0f, 0.0f);
	CGL_widgets_add_vertex_pt2f(c, 1.0f, 1.0f);
	CGL_widgets_add_vertex_pt2f(d, 0.0f, 1.0f);
	CGL_widgets_add_vertex_pt2f(a, 0.0f, 0.0f);
	CGL_widgets_add_vertex_pt2f(b, 1.0f, 0.0f);
	CGL_widgets_add_vertex_pt2f(c, 1.0f, 1.0f);
}

static CGL_void __CGL_widgets_add_quad_stroked(CGL_vec3 a, CGL_vec3 b, CGL_vec3 c, CGL_vec3 d)
{
	CGL_widgets_add_line(a, b);
	CGL_widgets_add_line(b, c);
	CGL_widgets_add_line(c, d);
	CGL_widgets_add_line(a, d);
}

CGL_void CGL_widgets_add_quad(CGL_vec3 a, CGL_vec3 b, CGL_vec3 c, CGL_vec3 d)
{
	if (__CGL_WIDGETS_CURRENT_CONTEXT->is_fill) __CGL_widgets_add_quad_filled(a, b, c, d);
	else __CGL_widgets_add_quad_stroked(a, b, c, d);
}

CGL_void CGL_widgets_add_quad_8f(CGL_float ax, CGL_float ay, CGL_float bx, CGL_float by, CGL_float cx, CGL_float cy, CGL_float dx, CGL_float dy)
{
	CGL_widgets_add_quad(
		CGL_vec3_init(ax, ay, 0.0f),
		CGL_vec3_init(bx, by, 0.0f),
		CGL_vec3_init(cx, cy, 0.0f),
		CGL_vec3_init(dx, dy, 0.0f)
	);
}

CGL_void CGL_widgets_add_line(CGL_vec3 start, CGL_vec3 end)
{
	CGL_vec3 a, b, c, d;

	CGL_float original_slope = (end.y - start.y) / (end.x - start.x);
	CGL_float perp_slope = -1.0f / original_slope;
	CGL_float angle = atanf(perp_slope);
	CGL_float thickness = __CGL_WIDGETS_CURRENT_CONTEXT->stroke_thickness;
	CGL_float r = thickness / 2.0f;

	a = CGL_vec3_init(start.x + r * cosf(angle), start.y + r * sinf(angle), start.z);
	b = CGL_vec3_init(start.x - r * cosf(angle), start.y - r * sinf(angle), start.z);

	c = CGL_vec3_init(end.x - r * cosf(angle), end.y - r * sinf(angle), end.z);
	d = CGL_vec3_init(end.x + r * cosf(angle), end.y + r * sinf(angle), end.z);

	bool was_fill = __CGL_WIDGETS_CURRENT_CONTEXT->is_fill;
	__CGL_WIDGETS_CURRENT_CONTEXT->is_fill = false;
	__CGL_widgets_add_quad_filled(a, b, c, d);
	__CGL_WIDGETS_CURRENT_CONTEXT->is_fill = was_fill;
}

CGL_void CGL_widgets_add_line2f(CGL_float start_x, CGL_float start_y, CGL_float end_x, CGL_float end_y)
{
	CGL_widgets_add_line(
		CGL_vec3_init(start_x, start_y, 0.0f),
		CGL_vec3_init(end_x, end_y, 0.0f)
	);
}

CGL_void CGL_widgets_add_rect(CGL_vec3 start, CGL_vec2 size)
{
	CGL_widgets_add_quad(
		CGL_vec3_init(start.x, start.y, start.z),
		CGL_vec3_init(start.x + size.x, start.y, start.z),
		CGL_vec3_init(start.x + size.x, start.y + size.y, start.z),
		CGL_vec3_init(start.x, start.y + size.y, start.z)
	);
}

CGL_void CGL_widgets_add_rect2f(CGL_float start_x, CGL_float start_y, CGL_float size_x, CGL_float size_y)
{
	CGL_widgets_add_quad(
		CGL_vec3_init(start_x, start_y, 0.0f),
		CGL_vec3_init(start_x + size_x, start_y, 0.0f),
		CGL_vec3_init(start_x + size_x, start_y + size_y, 0.0f),
		CGL_vec3_init(start_x, start_y + size_y, 0.0f)
	);
}

CGL_void CGL_widgets_add_rounded_rect2f(CGL_float start_x, CGL_float start_y, CGL_float size_x, CGL_float size_y, CGL_float radius, CGL_int res)
{
	radius = CGL_utils_clamp(radius, 0.0f, 1.0f);
	CGL_float r = radius * CGL_utils_min(size_x, size_y) * 0.5f;

	CGL_widgets_add_arc2f(start_x + r, start_y + r, r, CGL_deg_to_rad(180.0f), CGL_deg_to_rad(270.0f), res);
	CGL_widgets_add_arc2f(start_x + size_x - r, start_y + r, r, CGL_deg_to_rad(270.0f), CGL_deg_to_rad(360.0f), res);
	CGL_widgets_add_arc2f(start_x + size_x - r, start_y + size_y - r, r, CGL_deg_to_rad(0.0f), CGL_deg_to_rad(90.0f), res);
	CGL_widgets_add_arc2f(start_x + r, start_y + size_y - r, r, CGL_deg_to_rad(90.0f), CGL_deg_to_rad(180.0f), res);

	if (__CGL_WIDGETS_CURRENT_CONTEXT->is_fill)
	{
		CGL_widgets_add_rect2f(start_x + r, start_y + r, size_x - 2.0f * r, size_y - 2.0f * r);
		CGL_widgets_add_rect2f(start_x, start_y + r, r, size_y - 2.0f * r);
		CGL_widgets_add_rect2f(start_x + size_x - r, start_y + r, r, size_y - 2.0f * r);
		CGL_widgets_add_rect2f(start_x + r, start_y, size_x - 2.0f * r, r);
		CGL_widgets_add_rect2f(start_x + r, start_y + size_y - r, size_x - 2.0f * r, r);
	}
	else
	{
		CGL_widgets_add_line2f(start_x + r, start_y, start_x + size_x - r, start_y);
		CGL_widgets_add_line2f(start_x + r, start_y + size_y, start_x + size_x - r, start_y + size_y);
		CGL_widgets_add_line2f(start_x, start_y + r, start_x, start_y + size_y - r);
		CGL_widgets_add_line2f(start_x + size_x, start_y + r, start_x + size_x, start_y + size_y - r);
	}
}

CGL_void __CGL_widgets_add_oval_filled(CGL_vec3 position, CGL_vec2 radius)
{
	CGL_float x = 0.0f, y = 0.0f;
	for (CGL_float i = 0; i <= 360;)
	{
		x = radius.x * cosf(i); y = radius.y * sinf(i);
		CGL_widgets_add_vertex_p3f(x + position.x, y + position.y, position.z);
		i = i + 0.5f; x = radius.x * cosf(i); y = radius.y * sinf(i);
		CGL_widgets_add_vertex_p3f(x + position.x, y + position.y, position.z);
		CGL_widgets_add_vertex_p3f(position.x, position.y, position.z);
		i = i + 0.5f;
	}
}

CGL_void __CGL_widgets_add_oval_stroked(CGL_vec3 position, CGL_vec2 radius)
{
	(void)position;
	(void)radius;
	CGL_LOG("void __CGL_widgets_add_oval_stroked(CGL_vec3 position, CGL_vec2 radius) not implemented\n");
}

CGL_void CGL_widgets_add_circle2f(CGL_float pos_x, CGL_float pos_y, CGL_float radius)
{
	if (__CGL_WIDGETS_CURRENT_CONTEXT->is_fill) __CGL_widgets_add_oval_filled(CGL_vec3_init(pos_x, pos_y, 0.0f), CGL_vec2_init(radius, radius));
	else __CGL_widgets_add_oval_stroked(CGL_vec3_init(pos_x, pos_y, 0.0f), CGL_vec2_init(radius, radius));
}

CGL_void CGL_widgets_add_circler(CGL_vec3 position, CGL_float radius, CGL_int res)
{
	// CGL_widgets_add_arc2f(position.x, position.y, radius, 0.0f, CGL_2PI, res);
	CGL_widgets_add_oval2fr(position.x, position.y, radius, radius, res);
}

CGL_void CGL_widgets_add_circle2fr(CGL_float pos_x, CGL_float pos_y, CGL_float radius, CGL_int res)
{
	CGL_widgets_add_circler(CGL_vec3_init(pos_x, pos_y, 0.0f), radius, res);
}

CGL_void CGL_widgets_add_oval(CGL_vec3 position, CGL_vec2 radius)
{
	if (__CGL_WIDGETS_CURRENT_CONTEXT->is_fill) __CGL_widgets_add_oval_filled(position, radius);
	else __CGL_widgets_add_oval_stroked(position, radius);
}

CGL_void CGL_widgets_add_oval2f(CGL_float pos_x, CGL_float pos_y, CGL_float radius_x, CGL_float radius_y)
{
	if (__CGL_WIDGETS_CURRENT_CONTEXT->is_fill) __CGL_widgets_add_oval_filled(CGL_vec3_init(pos_x, pos_y, 0.0f), CGL_vec2_init(radius_x, radius_y));
	else __CGL_widgets_add_oval_stroked(CGL_vec3_init(pos_x, pos_y, 0.0f), CGL_vec2_init(radius_x, radius_y));
}

static CGL_void __CGL_widgets_add_arc_filled2f(CGL_float pos_x, CGL_float pos_y, CGL_float radius, CGL_float start_angle, CGL_float end_angle, CGL_int resolution)
{
	CGL_float x = 0.0f, y = 0.0f;
	CGL_float angle = start_angle;
	CGL_float angle_step = (end_angle - start_angle) / resolution;
	for (CGL_int i = 0; i < resolution; i++)
	{
		x = radius * cosf(angle); y = radius * sinf(angle);
		CGL_widgets_add_vertex_p3f(x + pos_x, y + pos_y, 0.0f);
		angle += angle_step;
		x = radius * cosf(angle); y = radius * sinf(angle);
		CGL_widgets_add_vertex_p3f(x + pos_x, y + pos_y, 0.0f);
		CGL_widgets_add_vertex_p3f(pos_x, pos_y, 0.0f);
	}
}

static CGL_void __CGL_widgets_add_arc_stroked2f(CGL_float pos_x, CGL_float pos_y, CGL_float radius, CGL_float start_angle, CGL_float end_angle, CGL_int resolution)
{
	CGL_float x0 = 0.0f, y0 = 0.0f, x1 = 0.0f, y1 = 0.0f;
	CGL_float angle = start_angle;
	CGL_float angle_step = (end_angle - start_angle) / resolution;

#ifdef CGL_WIDGETS_DRAW_ARC_WITH_LINES
	CGL_widgets_add_line2f(pos_x, pos_y, pos_x + radius * cosf(start_angle), pos_y + radius * sinf(start_angle));
	CGL_widgets_add_line2f(pos_x, pos_y, pos_x + radius * cosf(end_angle), pos_y + radius * sinf(end_angle));
#endif

	for (CGL_int i = 0; i < resolution; i++)
	{
		x0 = radius * cosf(angle); y0 = radius * sinf(angle);
		angle += angle_step;
		x1 = radius * cosf(angle); y1 = radius * sinf(angle);
		CGL_widgets_add_line2f(pos_x + x0, pos_y + y0, pos_x + x1, pos_y + y1);
	}
}

static CGL_void __CGL_widgets_add_oval_filled2f(CGL_float pos_x, CGL_float pos_y, CGL_float radiusx, CGL_float radiusy, CGL_int resolution)
{
	CGL_float x = 0.0f, y = 0.0f;
	CGL_float angle = 0.0f;
	CGL_float angle_step = (CGL_2PI - 0.0f) / resolution;
	for (CGL_int i = 0; i < resolution; i++)
	{
		x = radiusx * cosf(angle); y = radiusy * sinf(angle);
		CGL_widgets_add_vertex_p3f(x + pos_x, y + pos_y, 0.0f);
		angle += angle_step;
		x = radiusx * cosf(angle); y = radiusy * sinf(angle);
		CGL_widgets_add_vertex_p3f(x + pos_x, y + pos_y, 0.0f);
		CGL_widgets_add_vertex_p3f(pos_x, pos_y, 0.0f);
	}
}

static CGL_void __CGL_widgets_add_oval_stroked2f(CGL_float pos_x, CGL_float pos_y, CGL_float radiusx, CGL_float radiusy, CGL_int resolution)
{
	CGL_float x0 = 0.0f, y0 = 0.0f, x1 = 0.0f, y1 = 0.0f;
	CGL_float angle = 0.0f;
	CGL_float angle_step = (CGL_2PI - 0.0f) / resolution;
	for (CGL_int i = 0; i < resolution; i++)
	{
		x0 = radiusx * cosf(angle); y0 = radiusy * sinf(angle);
		angle += angle_step;
		x1 = radiusx * cosf(angle); y1 = radiusy * sinf(angle);
		CGL_widgets_add_line2f(pos_x + x0, pos_y + y0, pos_x + x1, pos_y + y1);
	}
}

CGL_void CGL_widgets_add_arc2f(CGL_float pos_x, CGL_float pos_y, CGL_float radius, CGL_float start_angle, CGL_float end_angle, CGL_int resolution)
{
	if (__CGL_WIDGETS_CURRENT_CONTEXT->is_fill) __CGL_widgets_add_arc_filled2f(pos_x, pos_y, radius, start_angle, end_angle, resolution);
	else __CGL_widgets_add_arc_stroked2f(pos_x, pos_y, radius, start_angle, end_angle, resolution);
}

CGL_void CGL_widgets_add_oval2fr(CGL_float pos_x, CGL_float pos_y, CGL_float radiusx, CGL_float radiusy, CGL_int resolution)
{
	if (__CGL_WIDGETS_CURRENT_CONTEXT->is_fill) __CGL_widgets_add_oval_filled2f(pos_x, pos_y, radiusx, radiusy, resolution);
	else __CGL_widgets_add_oval_stroked2f(pos_x, pos_y, radiusx, radiusy, resolution);
}

CGL_void CGL_widgets_add_circle(CGL_vec3 position, CGL_float radius)
{
	if (__CGL_WIDGETS_CURRENT_CONTEXT->is_fill) __CGL_widgets_add_oval_filled(position, CGL_vec2_init(radius, radius));
	else __CGL_widgets_add_oval_stroked(position, CGL_vec2_init(radius, radius));
}



bool CGL_widgets_add_character(char c, CGL_float x, CGL_float y, CGL_float sx, CGL_float sy)
{
	bool was_fill = __CGL_WIDGETS_CURRENT_CONTEXT->is_fill;
	__CGL_WIDGETS_CURRENT_CONTEXT->is_fill = true;
	switch (c)
	{
	case '0':
	{
		CGL_widgets_add_rect2f(x, y + sy * 0.75f, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x, y, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x + sx * 0.75f, y, sx * 0.25f, sy);
		CGL_widgets_add_rect2f(x, y, sx * 0.25f, sy);
		return true;
	}
	case '1':
	{
		CGL_widgets_add_rect2f(x + sx * 0.75f, y, sx * 0.25f, sy);
		return true;
	}
	case '2':
	{
		CGL_widgets_add_rect2f(x, y + sy * 0.75f, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x + sx * 0.75f, y + 0.5f * sy, sx * 0.25f, sy * 0.5f);
		CGL_widgets_add_rect2f(x, y + (0.5f - 0.125f) * sy, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x, y, sx * 0.25f, sy * 0.5f);
		CGL_widgets_add_rect2f(x, y, sx, sy * 0.25f);
		return true;
	}
	case '3':
	{
		CGL_widgets_add_rect2f(x + sx * 0.75f, y, sx * 0.25f, sy);
		CGL_widgets_add_rect2f(x, y + sy * 0.75f, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x, y + (0.5f - 0.125f) * sy, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x, y, sx, sy * 0.25f);
		return true;
	}
	case '4':
	{
		CGL_widgets_add_rect2f(x + sx * 0.75f, y, sx * 0.25f, sy);
		CGL_widgets_add_rect2f(x, y + 0.5f * sy, sx * 0.25f, sy * 0.5f);
		CGL_widgets_add_rect2f(x, y + (0.5f - 0.125f) * sy, sx, sy * 0.25f);
		return true;
	}
	case '5':
	{
		CGL_widgets_add_rect2f(x, y + sy * 0.75f, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x, y + 0.5f * sy, sx * 0.25f, sy * 0.5f);
		CGL_widgets_add_rect2f(x, y + (0.5f - 0.125f) * sy, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x + sx * 0.75f, y, sx * 0.25f, sy * 0.5f);
		CGL_widgets_add_rect2f(x, y, sx, sy * 0.25f);
		return true;
	}
	case '6':
	{
		CGL_widgets_add_rect2f(x, y + sy * 0.75f, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x, y, sx * 0.25f, sy);
		CGL_widgets_add_rect2f(x, y + (0.5f - 0.125f) * sy, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x + sx * 0.75f, y, sx * 0.25f, sy * 0.5f);
		CGL_widgets_add_rect2f(x, y, sx, sy * 0.25f);
		return true;
	}
	case '7':
	{
		CGL_widgets_add_rect2f(x, y + sy * 0.75f, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x + sx * 0.75f, y, sx * 0.25f, sy);
		return true;
	}
	case '8':
	{
		CGL_widgets_add_rect2f(x, y + sy * 0.75f, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x, y + (0.5f - 0.125f) * sy, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x, y, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x + sx * 0.75f, y, sx * 0.25f, sy);
		CGL_widgets_add_rect2f(x, y, sx * 0.25f, sy);
		return true;
	}
	case '9':
	{
		CGL_widgets_add_rect2f(x, y + sy * 0.75f, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x + sx * 0.75f, y, sx * 0.25f, sy);
		CGL_widgets_add_rect2f(x, y + 0.5f * sy, sx * 0.25f, sy * 0.5f);
		CGL_widgets_add_rect2f(x, y + (0.5f - 0.125f) * sy, sx, sy * 0.25f);
		return true;
	}
	case 'a':
	case 'A':
	{
		CGL_widgets_add_rect2f(x, y + sy * 0.75f, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x + sx * 0.75f, y, sx * 0.25f, sy);
		CGL_widgets_add_rect2f(x, y, sx * 0.25f, sy);
		CGL_widgets_add_rect2f(x, y + (0.5f - 0.125f) * sy, sx, sy * 0.25f);
		return true;
	}
	case 'b':
	case 'B':
	{
		CGL_widgets_add_rect2f(x, y + sy * 0.75f, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x + sx * 0.75f, y, sx * 0.25f, sy);
		CGL_widgets_add_rect2f(x, y, sx * 0.25f, sy);
		CGL_widgets_add_rect2f(x, y + (0.5f - 0.125f) * sy, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x, y, sx, sy * 0.25f);
		return true;
	}
	case 'c':
	case 'C':
	{
		CGL_widgets_add_rect2f(x, y + sy * 0.75f, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x, y, sx * 0.25f, sy);
		CGL_widgets_add_rect2f(x, y, sx, sy * 0.25f);
		return true;
	}
	case 'd':
	case 'D':
	{
		CGL_widgets_add_rect2f(x, y + sy * 0.75f, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x, y, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x + sx * 0.75f, y, sx * 0.25f, sy);
		CGL_widgets_add_rect2f(x, y, sx * 0.25f, sy);
		return true;
	}
	case 'e':
	case 'E':
	{
		CGL_widgets_add_rect2f(x, y + sy * 0.75f, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x, y + (0.5f - 0.125f) * sy, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x, y, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x, y, sx * 0.25f, sy);
		return true;
	}
	case 'f':
	case 'F':
	{
		CGL_widgets_add_rect2f(x, y + sy * 0.75f, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x, y + (0.5f - 0.125f) * sy, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x, y, sx * 0.25f, sy);
		return true;
	}
	case 'g':
	case 'G':
	{
		CGL_widgets_add_rect2f(x, y + sy * 0.75f, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x, y, sx * 0.25f, sy);
		CGL_widgets_add_rect2f(x, y, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x + sx * 0.75f, y, sx * 0.25f, sy * 0.5f);
		CGL_widgets_add_rect2f(x + 0.5f * sx, y + (0.5f - 0.125f) * sy, sx * 0.5f, sy * 0.25f);
		return true;
	}
	case 'h':
	case 'H':
	{
		CGL_widgets_add_rect2f(x + sx * 0.75f, y, sx * 0.25f, sy);
		CGL_widgets_add_rect2f(x, y, sx * 0.25f, sy);
		CGL_widgets_add_rect2f(x, y + (0.5f - 0.125f) * sy, sx, sy * 0.25f);
		return true;
	}
	case 'i':
	case 'I':
	{
		CGL_widgets_add_rect2f(x + sx * 0.75f, y, sx * 0.25f, sy);
		return true;
	}
	case 'j':
	case 'J':
	{
		CGL_widgets_add_rect2f(x + sx * 0.75f, y, sx * 0.25f, sy);
		CGL_widgets_add_rect2f(x, y, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x, y, sx * 0.25f, sy * 0.5f);
		return true;
	}
	case 'k':
	case 'K':
	{
		CGL_widgets_add_rect2f(x, y, sx * 0.25f, sy);
		CGL_widgets_add_quad_8f(
			x, y + (0.5f + 0.15f) * sy,
			x, y + (0.5f - 0.15f) * sy,
			x + sx, y + 0.85f * sy,
			x + 0.85f * sx, y + sy
		);
		CGL_widgets_add_quad_8f(
			x, y + (0.5f + 0.15f) * sy,
			x, y + (0.5f - 0.15f) * sy,
			x + 0.85f * sx, y,
			x + sx, y + 0.15f * sy
		);
		return true;
	}
	case 'l':
	case 'L':
	{
		CGL_widgets_add_rect2f(x, y, sx * 0.25f, sy);
		CGL_widgets_add_rect2f(x, y, sx, sy * 0.25f);
		return true;
	}
	case 'm':
	case 'M':
	{
		CGL_widgets_add_rect2f(x + sx * 0.75f, y, sx * 0.25f, sy);
		CGL_widgets_add_rect2f(x, y, sx * 0.25f, sy);
		CGL_widgets_add_rect2f(x + (0.5f - 0.125f) * sx, y + 0.5f * sy, sx * 0.25f, sy * 0.5f);
		return true;
	}
	case 'n':
	case 'N':
	{
		CGL_widgets_add_rect2f(x + sx * 0.75f, y, sx * 0.25f, sy);
		CGL_widgets_add_rect2f(x, y, sx * 0.25f, sy);
		CGL_widgets_add_quad_8f(
			x + 0.15f * sx, y + sy,
			x, y + 0.85f * sy,
			x + 0.85f * sx, y,
			x + sx, y + 0.15f * sy
		);
		return true;
	}
	case 'o':
	case 'O':
	{
		CGL_widgets_add_rect2f(x, y + sy * 0.75f, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x, y, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x + sx * 0.75f, y, sx * 0.25f, sy);
		CGL_widgets_add_rect2f(x, y, sx * 0.25f, sy);
		return true;
	}
	case 'p':
	case 'P':
	{
		CGL_widgets_add_rect2f(x, y + sy * 0.75f, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x, y, sx * 0.25f, sy);
		CGL_widgets_add_rect2f(x, y + (0.5f - 0.125f) * sy, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x + sx * 0.75f, y + 0.5f * sy, sx * 0.25f, sy * 0.5f);
		return true;
	}
	case 'q':
	case 'Q':
	{
		CGL_widgets_add_rect2f(x, y + sy * 0.75f, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x, y, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x + sx * 0.75f, y, sx * 0.25f, sy);
		CGL_widgets_add_rect2f(x, y, sx * 0.25f, sy);
		CGL_widgets_add_rect2f(x + (0.5f - 0.125f) * sx, y, sx * 0.25f, sy * 0.5f);
		return true;
	}
	case 'r':
	case 'R':
	{
		CGL_widgets_add_rect2f(x, y + sy * 0.75f, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x, y, sx * 0.25f, sy);
		CGL_widgets_add_rect2f(x, y + (0.5f - 0.125f) * sy, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x + sx * 0.75f, y + 0.5f * sy, sx * 0.25f, sy * 0.5f);
		CGL_widgets_add_quad_8f(
			x, y + (0.5f + 0.15f) * sy,
			x, y + (0.5f - 0.15f) * sy,
			x + 0.85f * sx, y,
			x + sx, y + 0.15f * sy
		);
		return true;
	}
	case 's':
	case 'S':
	{
		CGL_widgets_add_rect2f(x, y + sy * 0.75f, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x, y + (0.5f - 0.125f) * sy, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x, y, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x + sx * 0.75f, y, sx * 0.25f, sy * 0.5f);
		CGL_widgets_add_rect2f(x, y + 0.5f * sy, sx * 0.25f, sy * 0.5f);
		return true;
	}
	case 't':
	case 'T':
	{
		CGL_widgets_add_rect2f(x, y + sy * 0.75f, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x + (0.5f - 0.125f) * sx, y, sx * 0.25f, sy);
		return true;
	}
	case 'u':
	case 'U':
	{
		CGL_widgets_add_rect2f(x + sx * 0.75f, y, sx * 0.25f, sy);
		CGL_widgets_add_rect2f(x, y, sx * 0.25f, sy);
		CGL_widgets_add_rect2f(x, y, sx, sy * 0.25f);
		return true;
	}
	case 'v':
	case 'V':
	{
		CGL_widgets_add_quad_8f(
			x + sx, y + 0.85f * sy,
			x + 0.85f * sx, y + sy,
			x + (0.5f - 0.125f) * sx, y,
			x + (0.5f + 0.125f) * sx, y
		);
		CGL_widgets_add_quad_8f(
			x + 0.15f * sx, y + sy,
			x, y + 0.85f * sy,
			x + (0.5f - 0.125f) * sx, y,
			x + (0.5f + 0.125f) * sx, y
		);
		return true;
	}
	case 'w':
	case 'W':
	{
		CGL_widgets_add_rect2f(x + sx * 0.75f, y, sx * 0.25f, sy);
		CGL_widgets_add_rect2f(x, y, sx * 0.25f, sy);
		CGL_widgets_add_rect2f(x + (0.5f - 0.125f) * sx, y, sx * 0.25f, sy * 0.5f);
		return true;
	}
	case 'x':
	case 'X':
	{
		CGL_widgets_add_quad_8f(
			x + 0.15f * sx, y + sy,
			x, y + 0.85f * sy,
			x + 0.85f * sx, y,
			x + sx, y + 0.15f * sy
		);
		CGL_widgets_add_quad_8f(
			x + 0.85f * sx, y + sy,
			x + sx, y + 0.85f * sy,
			x + 0.15f * sx, y,
			x, y + 0.15f * sy
		);
		return true;
	}
	case 'y':
	case 'Y':
	{
		CGL_widgets_add_rect2f(x, y + 0.5f * sy, sx * 0.25f, sy * 0.5f);
		CGL_widgets_add_rect2f(x + sx * 0.75f, y, sx * 0.25f, sy);
		CGL_widgets_add_rect2f(x, y + (0.5f - 0.125f) * sy, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x, y, sx, sy * 0.25f);
		return true;
	}
	case 'z':
	case 'Z':
	{
		CGL_widgets_add_rect2f(x, y + sy * 0.75f, sx, sy * 0.25f);
		CGL_widgets_add_rect2f(x, y, sx, sy * 0.25f);
		CGL_widgets_add_quad_8f(
			x + 0.85f * sx, y + sy,
			x + sx, y + 0.85f * sy,
			x + 0.15f * sx, y,
			x, y + 0.15f * sy
		);
		return true;
	}
	case '-':
	{
		CGL_widgets_add_rect2f(x, y + (0.5f - 0.125f) * sy, sx, sy * 0.25f);
		return true;
	}
	case '\'':
	{
		CGL_widgets_add_rect2f(x + (0.5f - 0.125f) * sx, y + sy * 0.75f, sx * 0.25f, sy * 0.25f);
		return true;
	}
	case '.':
	{
		CGL_widgets_add_rect2f(x + (0.5f - 0.125f) * sx, y, sx * 0.25f, sy * 0.25f);
		return true;
	}
	case ':':
	{
		CGL_widgets_add_rect2f(x + (0.5f - 0.125f) * sx, y + 0.1f * sy, sx * 0.25f, sy * 0.25f);
		CGL_widgets_add_rect2f(x + (0.5f - 0.125f) * sx, y + (0.1f + 0.25f + 0.1f) * sy, sx * 0.25f, sy * 0.25f);
		return true;
	}
	case ' ':
	{
		return true;
	}
	}
	__CGL_WIDGETS_CURRENT_CONTEXT->is_fill = was_fill;
	// return false;
	return true;
}

CGL_bool CGL_widgets_add_string(const char* str, CGL_float x, CGL_float y, CGL_float sx, CGL_float sy)
{
	const CGL_float line_gap = 0.01f;
	const CGL_float char_gap = 0.01f;
	CGL_int length = (int)strlen(str);
	CGL_int line_length = 0;
	CGL_int line_length_max = 0;
	CGL_int num_lines = 1;
	CGL_float ix = x;
	for (CGL_int i = 0; i < length; i++)
	{
		line_length++;
		if (str[i] == '\n')
		{
			line_length_max = CGL_utils_max(line_length, line_length_max);
			line_length = 0;
			num_lines++;
		}
	}
	line_length_max = CGL_utils_max(line_length, line_length_max);
	CGL_float character_sx = sx / line_length - char_gap;
	CGL_float character_sy = (sy - line_gap * num_lines) / (num_lines);
	y += sy - character_sy;
	for (CGL_int i = 0; i < length; i++)
	{
		if (str[i] == '\n')
		{
			y = y - line_gap - character_sy;
			x = ix;
			continue;
		}
		if (!CGL_widgets_add_character(str[i], x, y, character_sx, character_sy)) return false;
		x = x + character_sx + char_gap;
	}
	return true;
}

#ifndef CGL_EXCLUDE_TEXT_RENDER
CGL_float CGL_widgets_add_string_with_font(const char* str, CGL_font* font, CGL_float x, CGL_float y, CGL_float sx, CGL_float scale_y)
{
	CGL_int string_length = (CGL_int)strlen(str);
	CGL_float max_char_width = 0.0f, average_char_width = 0.0f;
	CGL_font_character* characters = CGL_font_get_characters(font);
	for (CGL_int i = 0; i < string_length; i++) { max_char_width = CGL_utils_max(max_char_width, characters[str[i]].advance_normalized.x); average_char_width += characters[str[i]].advance_normalized.x; }
	average_char_width /= (CGL_float)string_length;
	CGL_float approx_each_char_width = sx / (CGL_float)string_length;
	// NOTE: Its a question whether to use max character width or average character width here!
	CGL_float character_scale = approx_each_char_width / average_char_width;
	CGL_float initial_x = x;
	CGL_widgets_set_font_texture(CGL_font_get_atlas(font));
	for (CGL_int i = 0; i < string_length; i++)
	{
		CGL_byte c = str[i];
		CGL_widgets_set_texture_coordinate_so(characters[c].normalized_size.x, -characters[c].normalized_size.y, characters[c].normalized_offset.x, characters[c].normalized_offset.y + characters[c].normalized_size.y);
		CGL_widgets_add_rect2f(x + character_scale * characters[c].bearing_normalized.x, y - character_scale * (characters[c].normalized_size.y - characters[c].bearing_normalized.y), characters[c].normalized_size.x * character_scale, characters[c].normalized_size.y * character_scale * scale_y);
		x += characters[c].advance_normalized.x * character_scale;
	}
	CGL_widgets_set_texture(NULL);
	return x - initial_x;
}
#endif

CGL_void CGL_widgets_add_shape_out_line(CGL_shape* shape)
{
	for (CGL_sizei i = 0; i < shape->vertices_count; i++)
	{
		CGL_vec3 p0 = CGL_vec3_apply_transformations(shape->vertices[i], &shape->position, &shape->rotation, &shape->scale);
		CGL_vec3 p1 = CGL_vec3_apply_transformations(shape->vertices[(i + 1) % shape->vertices_count], &shape->position, &shape->rotation, &shape->scale);
		CGL_widgets_add_line(p0, p1);
	}
}

CGL_void CGL_widgets_add_cubic_bazier(CGL_vec3 start, CGL_vec3 end, CGL_vec3 control_1, CGL_vec3 control_2, CGL_int resolution)
{
	CGL_float step_size = 1.0f / (CGL_float)resolution;
	CGL_float t = 0.0f;
	CGL_vec2 p = CGL_vec2_init(0.0f, 0.0f);
	CGL_vec2 p_old = CGL_vec2_init(0.0f, 0.0f);
	for (CGL_int i = 0; i <= resolution; i++)
	{
		p.x = CGL_float_cubic_lerp(start.x, end.x, control_1.x, control_2.x, t);
		p.y = CGL_float_cubic_lerp(start.y, end.y, control_1.y, control_2.y, t);
		if (i > 0) CGL_widgets_add_line2f(p_old.x, p_old.y, p.x, p.y);
		p_old = p;
		t += step_size;
	}
}

CGL_void CGL_widgets_add_cubic_bazier2v(CGL_vec2 start, CGL_vec2 end, CGL_vec2 control_1, CGL_vec2 control_2, CGL_int resolution)
{
	CGL_widgets_add_cubic_bazier(
		CGL_vec3_init(start.x, start.y, 0.0f),
		CGL_vec3_init(end.x, end.y, 0.0f),
		CGL_vec3_init(control_1.x, control_1.y, 0.0f),
		CGL_vec3_init(control_2.x, control_2.y, 0.0f),
		resolution
	);
}

CGL_void CGL_widgets_add_cubic_bazier2f(CGL_float start_x, CGL_float start_y, CGL_float end_x, CGL_float end_y, CGL_float control_1_x, CGL_float control_1_y, CGL_float control_2_x, CGL_float control_2_y, CGL_int resolution)
{
	CGL_widgets_add_cubic_bazier(
		CGL_vec3_init(start_x, start_y, 0.0f),
		CGL_vec3_init(end_x, end_y, 0.0f),
		CGL_vec3_init(control_1_x, control_1_y, 0.0f),
		CGL_vec3_init(control_2_x, control_2_y, 0.0f),
		resolution
	);
}

CGL_void CGL_widgets_add_cubic_bazier_points(CGL_vec3 start, CGL_vec3 end, CGL_vec3 control_1, CGL_vec3 control_2, CGL_int resolution)
{
	CGL_float step_size = 1.0f / (CGL_float)resolution;
	CGL_float t = 0.0f;
	CGL_vec2 p = CGL_vec2_init(0.0f, 0.0f);
	for (CGL_int i = 0; i <= resolution; i++)
	{
		p.x = CGL_float_cubic_lerp(start.x, end.x, control_1.x, control_2.x, t);
		p.y = CGL_float_cubic_lerp(start.y, end.y, control_1.y, control_2.y, t);
		CGL_widgets_add_circle2f(p.x, p.y, 0.02f);
		t += step_size;
	}
}

CGL_void CGL_widgets_add_cubic_bazier_points2v(CGL_vec2 start, CGL_vec2 end, CGL_vec2 control_1, CGL_vec2 control_2, CGL_int resolution)
{
	CGL_widgets_add_cubic_bazier_points(
		CGL_vec3_init(start.x, start.y, 0.0f),
		CGL_vec3_init(end.x, end.y, 0.0f),
		CGL_vec3_init(control_1.x, control_1.y, 0.0f),
		CGL_vec3_init(control_2.x, control_2.y, 0.0f),
		resolution
	);
}

CGL_void CGL_widgets_add_cubic_bazier_points2f(CGL_float start_x, CGL_float start_y, CGL_float end_x, CGL_float end_y, CGL_float control_1_x, CGL_float control_1_y, CGL_float control_2_x, CGL_float control_2_y, CGL_int resolution)
{
	CGL_widgets_add_cubic_bazier_points(
		CGL_vec3_init(start_x, start_y, 0.0f),
		CGL_vec3_init(end_x, end_y, 0.0f),
		CGL_vec3_init(control_1_x, control_1_y, 0.0f),
		CGL_vec3_init(control_2_x, control_2_y, 0.0f),
		resolution
	);
}

CGL_void CGL_widgets_add_plot_function(CGL_float start_x, CGL_float start_y, CGL_float size_x, CGL_float size_y, CGL_float(*func_to_plot)(CGL_float), CGL_int num_samples, CGL_float x_min, CGL_float x_max, CGL_float y_min, CGL_float y_max, CGL_float plot_thickness, CGL_vec3 plot_color, CGL_bool draw_axes, CGL_float axes_thickness, CGL_vec3 axes_color)
{
	CGL_float step_size = (x_max - x_min) / (CGL_float)num_samples;
	CGL_float step_size_plot = size_x / (CGL_float)num_samples;

	CGL_vec2 prev_point = CGL_vec2_init(0.0f, 0.0f);
	CGL_vec2 curr_point = CGL_vec2_init(0.0f, 0.0f);

	prev_point.x = x_min;
	prev_point.y = func_to_plot(x_min);

	CGL_widgets_set_stroke_colorf(plot_color.x, plot_color.y, plot_color.z, 1.0f);
	CGL_widgets_set_stroke_thicnkess(plot_thickness);
	for (CGL_int i = 1; i < num_samples; i++)
	{
		curr_point.x = x_min + (step_size * (CGL_float)i);
		curr_point.y = CGL_utils_clamp(func_to_plot(curr_point.x), y_min, y_max);

		CGL_widgets_add_line2f(
			start_x + (step_size_plot * (CGL_float)i),
			start_y + (size_y * (prev_point.y - y_min) / (y_max - y_min)),
			start_x + (step_size_plot * (CGL_float)(i + 1)),
			start_y + (size_y * (curr_point.y - y_min) / (y_max - y_min))
		);

		prev_point = curr_point;
	}


	if (draw_axes)
	{
		CGL_widgets_set_stroke_colorf(axes_color.x, axes_color.y, axes_color.z, 1.0f);
		CGL_widgets_set_stroke_thicnkess(axes_thickness);
		if (y_min < 0.0f && y_max > 0.0f)
		{
			CGL_widgets_add_line2f(
				start_x,
				start_y + (size_y * fabsf(y_min) / (y_max - y_min)),
				start_x + size_x,
				start_y + (size_y * fabsf(y_min) / (y_max - y_min))
			);
		}
		if (x_min < 0.0f && x_max > 0.0f)
		{
			CGL_widgets_add_line2f(
				start_x + (size_x * fabsf(x_min) / (x_max - x_min)),
				start_y,
				start_x + (size_x * fabsf(x_min) / (x_max - x_min)),
				start_y + size_y
			);
		}
	}
}

CGL_void CGL_widgets_add_plot_array(CGL_float start_x, CGL_float start_y, CGL_float size_x, CGL_float size_y, CGL_vec2* values, CGL_sizei count, CGL_float marker_size, CGL_vec3 marker_color, CGL_bool draw_axes, CGL_float axes_thickness, CGL_vec3 axes_color)
{
	CGL_vec2 x_min_max = CGL_vec2_init(values[0].x, values[0].x);
	CGL_vec2 y_min_max = CGL_vec2_init(values[0].y, values[0].y);
	for (CGL_sizei i = 1; i < count; i++)
	{
		x_min_max.x = CGL_utils_min(x_min_max.x, values[i].x);
		x_min_max.y = CGL_utils_max(x_min_max.y, values[i].x);
		y_min_max.x = CGL_utils_min(y_min_max.x, values[i].y);
		y_min_max.y = CGL_utils_max(y_min_max.y, values[i].y);
	}

	CGL_widgets_set_fill_colorf(marker_color.x, marker_color.y, marker_color.z, 1.0f);
	for (CGL_sizei i = 0; i < count; i++)
	{
		CGL_widgets_add_rect2f(
			start_x + (size_x * (values[i].x - x_min_max.x) / (x_min_max.y - x_min_max.x)),
			start_y + (size_y * (values[i].y - y_min_max.x) / (y_min_max.y - y_min_max.x)),
			marker_size, marker_size
		);
	}

	if (draw_axes)
	{
		CGL_widgets_set_stroke_colorf(axes_color.x, axes_color.y, axes_color.z, 1.0f);
		CGL_widgets_set_stroke_thicnkess(axes_thickness);
		if (y_min_max.x < 0.0f && y_min_max.y > 0.0f)
		{
			CGL_widgets_add_line2f(
				start_x,
				start_y + (size_y * fabsf(y_min_max.x) / (y_min_max.y - y_min_max.x)),
				start_x + size_x,
				start_y + (size_y * fabsf(y_min_max.x) / (y_min_max.y - y_min_max.x))
			);
		}
		if (x_min_max.x < 0.0f && x_min_max.y > 0.0f)
		{
			CGL_widgets_add_line2f(
				start_x + (size_x * fabsf(x_min_max.x) / (x_min_max.y - x_min_max.x)),
				start_y,
				start_x + (size_x * fabsf(x_min_max.x) / (x_min_max.y - x_min_max.x)),
				start_y + size_y
			);
		}
	}

}

CGL_void CGL_widgets_add_plot_pie_chart(CGL_float start_x, CGL_float start_y, CGL_float radius, CGL_float* values, CGL_vec3* colors, CGL_sizei count, CGL_int resolution)
{
	CGL_float total = 0.0f;
	for (CGL_sizei i = 0; i < count; i++)
	{
		total += values[i];
	}

	CGL_float curr_angle = 0.0f;
	for (CGL_sizei i = 0; i < count; i++)
	{
		CGL_widgets_set_fill_colorf(colors[i].x, colors[i].y, colors[i].z, 1.0f);
		CGL_widgets_add_arc2f(
			start_x, start_y, radius, curr_angle, curr_angle + (values[i] / total) * CGL_2PI, (CGL_int)(resolution * (values[i] / total) + 1.0f)
		);
		curr_angle += (values[i] / total) * CGL_2PI;
	}
}

CGL_void CGL_widgets_add_bar_graph(CGL_float start_x, CGL_float start_y, CGL_float size_x, CGL_float size_y, CGL_float* values, CGL_vec3* colors, CGL_sizei count, CGL_bool draw_axes, CGL_float axes_thickness, CGL_vec3 axes_color, CGL_bool vertical)
{
	CGL_float max_value = values[0];
	for (CGL_sizei i = 1; i < count; i++) max_value = CGL_utils_max(max_value, values[i]);

	CGL_float bar_width = ((vertical ? size_x : size_y) / (CGL_float)(count + 2)) * 0.8f;
	CGL_float bar_spacing = ((vertical ? size_x : size_y) / (CGL_float)(count + 2)) * 0.2f;

	CGL_float curr_x = start_x + bar_spacing;
	CGL_float curr_y = start_y + bar_spacing;

	for (CGL_sizei i = 0; i < count; i++)
	{
		CGL_widgets_set_fill_colorf(colors[i].x, colors[i].y, colors[i].z, 1.0f);
		if (vertical)
		{
			CGL_widgets_add_rect2f(curr_x, start_y + bar_spacing, bar_width, (size_y - bar_spacing * 2.0f) * (values[i] / max_value));
			curr_x += bar_width + bar_spacing;
		}
		else
		{
			CGL_widgets_add_rect2f(start_x + bar_spacing, curr_y, (size_x - bar_spacing * 2.0f) * (values[i] / max_value), bar_width);
			curr_y += bar_width + bar_spacing;
		}
	}

	if (draw_axes)
	{
		CGL_widgets_set_stroke_colorf(axes_color.x, axes_color.y, axes_color.z, 1.0f);
		CGL_widgets_set_stroke_thicnkess(axes_thickness);
		CGL_widgets_add_line2f(start_x + bar_spacing, start_y, start_x + bar_spacing, start_y + size_y);
		CGL_widgets_add_line2f(start_x, start_y + bar_spacing, start_x + size_x, start_y + bar_spacing);
	}
}

#endif
#endif

#ifndef CGL_EXCLUDE_NODE_EDITOR

struct CGL_node_editor
{
	CGL_node_editor_input* input;
	CGL_node_editor_pin* start_pin;
	CGL_node_editor_pin* end_pin;
	void(*ondrop)(float, float, CGL_node_editor_pin*);
	void(*onconnect)(CGL_node_editor_pin*, CGL_node_editor_pin*);
	CGL_float mouse_pos_x;
	CGL_float mouse_pos_y;
	CGL_float mouse_delta_x;
	CGL_float mouse_delta_y;
	CGL_float offset_x;
	CGL_float offset_y;
	CGL_float aspect_ratio;
	CGL_float scale;
	CGL_int num_selected;
	bool has_lifted;
};

CGL_node_editor* CGL_node_editor_create()
{
	CGL_node_editor* editor = (CGL_node_editor*)CGL_malloc(sizeof(CGL_node_editor));
	if (!editor) return NULL;
	editor->mouse_pos_x = 0.0f;
	editor->mouse_pos_y = 0.0f;
	editor->mouse_delta_x = 0.0f;
	editor->mouse_delta_y = 0.0f;
	editor->offset_x = 0.0f;
	editor->offset_y = 0.0f;
	editor->input = NULL;
	editor->aspect_ratio = 1.0f;
	editor->scale = 1.0f;
	editor->start_pin = editor->end_pin = NULL;
	editor->ondrop = NULL;
	editor->onconnect = NULL;
	editor->has_lifted = true;
	return editor;
}

CGL_void CGL_node_editor_destroy(CGL_node_editor* editor)
{
	CGL_free(editor);
}

CGL_void CGL_node_editor_set_on_connect(CGL_node_editor* editor, void(*onconnect)(CGL_node_editor_pin*, CGL_node_editor_pin*))
{
	editor->onconnect = onconnect;
}

CGL_void CGL_node_editor_set_on_drop(CGL_node_editor* editor, void(*ondrop)(float, float, CGL_node_editor_pin*))
{
	editor->ondrop = ondrop;
}

CGL_void CGL_node_editor_update(CGL_node_editor* editor, CGL_node_editor_input* input)
{
	editor->input = input;
	editor->mouse_delta_x = CGL_utils_clamp(input->mouse_pos_x - editor->mouse_pos_x, -0.2f, 0.2f);
	editor->mouse_delta_y = CGL_utils_clamp(input->mouse_pos_y - editor->mouse_pos_y, -0.2f, 0.2f);
	editor->mouse_pos_x = input->mouse_pos_x;
	editor->mouse_pos_y = input->mouse_pos_y;
	editor->aspect_ratio = input->aspect_ratio;
	editor->scale = CGL_utils_max(input->scale, 0.01f);
	if (editor->start_pin && editor->end_pin) { if (editor->onconnect) editor->onconnect(editor->start_pin, editor->end_pin); editor->start_pin = editor->end_pin = NULL; editor->has_lifted = false; }
	if (editor->start_pin && !input->mouse_button_left) { if (editor->ondrop) editor->ondrop(editor->mouse_pos_x / editor->scale, editor->mouse_pos_y / editor->scale, editor->start_pin); editor->start_pin = NULL; }
	if (!input->mouse_button_left) editor->has_lifted = true;
	if (input->mouse_button_middle)
	{
		editor->offset_x += editor->mouse_delta_x * editor->scale;
		editor->offset_y += editor->mouse_delta_y * editor->scale;
	}
	editor->num_selected = 0;
}

CGL_void CGL_node_editor_render_begin(CGL_node_editor* editor)
{
	CGL_widgets_begin_int(editor->scale, editor->scale, 0.0f, 0.0f);
	CGL_widgets_set_stroke_thicnkess(0.03f);
}

CGL_void CGL_node_editor_clear_focused_pins(CGL_node_editor* editor)
{
	editor->start_pin = editor->end_pin = NULL;
}

CGL_void CGL_node_editor_render_end(CGL_node_editor* editor)
{
	if (editor->start_pin && !editor->end_pin)
	{
		CGL_widgets_set_stroke_colorf(1.0f, 1.0f, 0.0f, 1.0f);
		CGL_widgets_add_line(
			CGL_vec3_init(editor->offset_x + editor->start_pin->pos_x, editor->offset_y + editor->start_pin->pos_y, 0.0f),
			CGL_vec3_init(editor->mouse_pos_x / editor->scale, editor->mouse_pos_y / editor->scale, 0.0f)
		);
	}
	CGL_widgets_end();
}

CGL_void CGL_node_editor_set_offset(CGL_node_editor* editor, CGL_float x, CGL_float y)
{
	editor->offset_x = x;
	editor->offset_y = y;
}

CGL_void CGL_node_editor_get_offset(CGL_node_editor* editor, CGL_float* x, CGL_float* y)
{
	if (x) *x = editor->offset_x;
	if (y) *y = editor->offset_y;
}

CGL_void CGL_node_editor_get_linked_pins(CGL_node_editor* editor, CGL_node_editor_pin** x, CGL_node_editor_pin** y)
{
	if (x) *x = editor->start_pin;
	if (y) *y = editor->end_pin;
}

CGL_void CGL_node_editor_render_link(CGL_node_editor_pin* left, CGL_node_editor_pin* right, CGL_color color, CGL_float midper)
{
	if (!left || !right) return;
	CGL_widgets_set_stroke_color(color);

	CGL_float mx = CGL_utils_mix(left->pos_x, right->pos_x, midper);

	CGL_float ofx = right->parent->editor->offset_x;
	CGL_float ofy = right->parent->editor->offset_y;

	CGL_widgets_add_line(
		CGL_vec3_init(ofx + left->pos_x, ofy + left->pos_y, 0.0f),
		CGL_vec3_init(ofx + mx, ofy + left->pos_y, 0.0f)
	);

	CGL_widgets_add_line(
		CGL_vec3_init(ofx + mx, ofy + left->pos_y, 0.0f),
		CGL_vec3_init(ofx + mx, ofy + right->pos_y, 0.0f)
	);

	CGL_widgets_add_line(
		CGL_vec3_init(ofx + mx, ofy + right->pos_y, 0.0f),
		CGL_vec3_init(ofx + right->pos_x, ofy + right->pos_y, 0.0f)
	);
}

CGL_void CGL_node_editor_render_linkf(CGL_node_editor_pin* left, CGL_node_editor_pin* right, CGL_float cr, CGL_float cg, CGL_float cb, CGL_float ca, CGL_float midper)
{
	CGL_node_editor_render_link(left, right, CGL_vec4_init(cr, cg, cb, ca), midper);
}

CGL_void CGL_node_editor_render_link_curved(CGL_node_editor_pin* left, CGL_node_editor_pin* right, CGL_color color, CGL_float x_dist, CGL_float y_dist, CGL_int resolution)
{
	if (!left || !right) return;


	CGL_float y_length = fabsf(right->pos_y - left->pos_y);

	CGL_float ofx = right->parent->editor->offset_x;
	CGL_float ofy = right->parent->editor->offset_y;

	CGL_float mx0 = CGL_utils_mix(left->pos_x, right->pos_x, x_dist);
	CGL_float my0 = CGL_utils_clamp(y_length * y_dist, 0.0f, 0.1f);

	CGL_float mx1 = CGL_utils_mix(left->pos_x, right->pos_x, (1.0f - x_dist));
	CGL_float my1 = CGL_utils_clamp(y_length * (1.0f - y_dist), 0.0f, 0.1f);



	CGL_vec2 end = CGL_vec2_init(ofx + right->pos_x, ofy + right->pos_y);
	CGL_vec2 start = CGL_vec2_init(ofx + left->pos_x, ofy + left->pos_y);
	CGL_vec2 control0 = CGL_vec2_init(ofx + mx0, ofy + left->pos_y + my0);
	CGL_vec2 control1 = CGL_vec2_init(ofx + mx1, ofy + right->pos_y - my1);

	CGL_widgets_set_stroke_color(color);
	CGL_widgets_add_cubic_bazier2v(start, end, control0, control1, resolution);
}

CGL_void CGL_node_editor_render_link_curvedf(CGL_node_editor_pin* left, CGL_node_editor_pin* right, CGL_float cr, CGL_float cg, CGL_float cb, CGL_float ca, CGL_float x_dist, CGL_float y_dist, CGL_int resolution)
{
	CGL_node_editor_render_link_curved(left, right, CGL_vec4_init(cr, cg, cb, ca), x_dist, y_dist, resolution);
}

CGL_void CGL_node_editor_node_init(CGL_node_editor* editor, CGL_node_editor_node* node)
{
	node->editor = editor;
	node->color = CGL_utils_random_color();
	strcpy(node->title, "Node");
	node->render_title = true;
	node->pins_count[0] = node->pins_count[1] = 0;
	node->pos_y = node->pos_x = 0.0f;
	node->size_y = node->size_x = 0.3f;
	node->selected = false;
	memset(node->left_pins, 0, sizeof(CGL_node_editor_pin) * CGL_NODE_EDITOR_NODE_MAX_PINS);
	memset(node->right_pins, 0, sizeof(CGL_node_editor_pin) * CGL_NODE_EDITOR_NODE_MAX_PINS);
}

static bool __CGL_node_editor_pin_update(CGL_node_editor_pin* pin)
{
	CGL_node_editor_node* node = pin->parent;
	CGL_node_editor* editor = node->editor;
	CGL_float sx = 0.05f / pin->parent->editor->input->aspect_ratio;
	CGL_float sy = 0.05f;

	bool focused = false;
	CGL_float ofx = node->editor->offset_x;
	CGL_float ofy = node->editor->offset_y;

	if (editor->input->mouse_button_left
		&& CGL_utils_is_point_in_rect(
			editor->input->mouse_pos_x, editor->input->mouse_pos_y,
			ofx + pin->pos_x, ofy + pin->pos_y,
			sx, sy,
			editor->scale, editor->scale
		)) focused = true;

	if (focused && editor->has_lifted)
	{
		if (editor->start_pin && pin != editor->start_pin) editor->end_pin = pin;
		else if (editor->start_pin == NULL) { editor->start_pin = pin; editor->end_pin = NULL; }
	}

	return focused;
}

CGL_void CGL_node_editor_node_update(CGL_node_editor_node* node)
{
	const CGL_node_editor* editor = node->editor;
	node->pins_count[0] = node->pins_count[1] = 0;
	for (CGL_int i = 0; i < CGL_NODE_EDITOR_NODE_MAX_PINS; i++)
	{
		if (node->left_pins[i].is_set) node->pins_count[0]++;
		if (node->right_pins[i].is_set) node->pins_count[1]++;
	}
	CGL_float ofx = node->editor->offset_x;
	CGL_float ofy = node->editor->offset_y;
	CGL_float sx = node->size_x;
	CGL_float sy = node->size_y = (0.1f + (float)CGL_utils_max(node->pins_count[0], node->pins_count[1]) * (0.05f + 0.1f));
	if (node->render_title) sy += 0.1f;
	bool require_movement = false;
	if (editor->input->mouse_button_left && !editor->input->shift) node->selected = false;
	require_movement = node->selected && editor->input->ctrl;
	if (editor->input->mouse_button_left && !editor->start_pin
		&& CGL_utils_is_point_in_rect(
			editor->input->mouse_pos_x, editor->input->mouse_pos_y,
			ofx + node->pos_x, ofy + node->pos_y,
			sx, sy,
			editor->scale, editor->scale
		))  require_movement = node->selected = true;
	if (node->selected) node->editor->num_selected++;

	// TODO: try to do it in the loop above
	for (CGL_int i = 0; i < CGL_NODE_EDITOR_NODE_MAX_PINS; i++)
	{
		if (node->left_pins[i].is_set)
			require_movement &= !__CGL_node_editor_pin_update(&node->left_pins[i]);
		if (node->right_pins[i].is_set)
			require_movement &= !__CGL_node_editor_pin_update(&node->right_pins[i]);
	}

	if (require_movement)
	{
		node->pos_x += editor->mouse_delta_x;
		node->pos_y += editor->mouse_delta_y;
	}
}

CGL_void CGL_node_editor_node_render(CGL_node_editor_node* node)
{
	const CGL_node_editor* editor = node->editor;
	CGL_float sx = node->size_x;
	CGL_float sy = node->size_y;
	if (node->render_title) sy += 0.1f;
	//if(sx > sy) sy = sx * node->editor->input->aspect_ratio;
	//else sx = sy / node->editor->input->aspect_ratio;    
	CGL_float ofx = editor->offset_x;
	CGL_float ofy = editor->offset_y;
	// render selection
	if (node->selected)
	{
		CGL_widgets_set_fill_colorf(0.8f, 0.8f, 0.1f, 1.0f);
		CGL_widgets_add_rect2f(ofx + node->pos_x - 0.01f, ofy + node->pos_y - 0.01f, sx + 0.02f, sy + 0.02f);
	}
	// render body
	CGL_widgets_set_fill_color(node->color);
	CGL_widgets_add_rect2f(ofx + node->pos_x, ofy + node->pos_y, sx, sy);
	//render title
	if (node->render_title)
	{
		CGL_widgets_set_fill_colorf(node->color.x * 0.7f, node->color.y * 0.7f, node->color.z * 0.7f, 1.0f);
		CGL_widgets_add_rect2f(ofx + node->pos_x, ofy + node->pos_y + sy - 0.1f - 0.01f, sx, 0.1f);
		CGL_widgets_set_fill_colorf(0.0f, 0.0f, 0.0f, 1.0f);
		CGL_widgets_add_string(node->title, ofx + node->pos_x + 0.01f, ofy + node->pos_y + sy - 0.1f - 0.01f, sx - 0.02f, (0.1f - 0.02f));
	}
	// render pins

	// left pins
	CGL_float ty1 = ofy + node->pos_y + 0.1f;
	CGL_float ty2 = ofy + node->pos_y + 0.1f;
	for (CGL_int i = CGL_NODE_EDITOR_NODE_MAX_PINS - 1; i >= 0; i--)
	{
		if (node->left_pins[i].is_set)
		{
			CGL_widgets_set_fill_color(node->left_pins[i].color);
			CGL_widgets_add_rect2f(ofx + node->pos_x - 0.02f, ty1, 0.05f / node->editor->input->aspect_ratio, 0.05f);
			node->left_pins[i].pos_x = node->pos_x - 0.02f;
			node->left_pins[i].pos_y = ty1 - ofy;
			ty1 += 0.1f + 0.05f;
		}

		if (node->right_pins[i].is_set)
		{
			CGL_widgets_set_fill_color(node->right_pins[i].color);
			CGL_widgets_add_rect2f(ofx + node->pos_x + sx - 0.05f / node->editor->input->aspect_ratio + 0.02f, ty2, 0.05f / node->editor->input->aspect_ratio, 0.05f);
			node->right_pins[i].pos_x = node->pos_x + sx - 0.05f / node->editor->input->aspect_ratio + 0.02f;
			node->right_pins[i].pos_y = ty2 - ofy;
			ty2 += 0.1f + 0.05f;
		}
	}

}

CGL_void CGL_node_editor_node_set_position(CGL_node_editor_node* node, CGL_float x, CGL_float y)
{
	node->pos_x = x;
	node->pos_y = y;
}

CGL_void CGL_node_editor_node_set_title(CGL_node_editor_node* node, const char* title)
{
	if (title == NULL) { node->render_title = false; return; }
	node->render_title = true;
	strcpy(node->title, title);
}

CGL_node_editor_pin* CGL_node_editor_node_get_pin(CGL_node_editor_node* node, bool left, CGL_int index)
{
	CGL_node_editor_pin* pin = NULL;
	if (left) pin = &node->left_pins[index];
	else pin = &node->right_pins[index];
	pin->index = index;
	pin->left = left;
	pin->parent = node;
	pin->color = CGL_vec4_init(0.0f, 0.0f, 0.0f, 1.0f);
	return pin;
}

#endif


#ifndef CGL_EXCLUDE_RAY_CASTER

struct CGL_ray_caster
{
	CGL_shape_triangle triangles[CGL_RAY_CASTER_MAX_TRIANGLES];
	CGL_vec4 walls[CGL_RAY_CASTER_MAX_WALLS];
	CGL_int wall_count;
	CGL_int triangle_count;
	CGL_float theta_min;
	CGL_float theta_max;
	CGL_float max_dist;
#ifndef CGL_EXCLUDE_GRAPHICS_API
	CGL_mesh_gpu* mesh;
#endif
};

CGL_ray_caster* CGL_ray_caster_create()
{
	CGL_ray_caster* caster = (CGL_ray_caster*)CGL_malloc(sizeof(CGL_ray_caster));
	if (!caster) return NULL;
	caster->theta_max = 3.141f;
	caster->theta_min = 0.0f;
	caster->max_dist = 1.0f;
	caster->triangle_count = 0;
	caster->wall_count = 0;
#ifndef CGL_EXCLUDE_GRAPHICS_API
	caster->mesh = CGL_mesh_gpu_create();
#endif
	return caster;
}

CGL_void CGL_ray_caster_destroy(CGL_ray_caster* caster)
{
#ifndef CGL_EXCLUDE_GRAPHICS_API
	if (caster->mesh) CGL_mesh_gpu_destroy(caster->mesh);
#endif
	CGL_free(caster);
}

CGL_void CGL_ray_caster_add_walls(CGL_ray_caster* caster, CGL_vec4* walls, CGL_int walls_count)
{
	if ((caster->wall_count + walls_count) >= CGL_RAY_CASTER_MAX_WALLS) CGL_warn("Max Ray Caster walls exceeded");
	walls_count = CGL_utils_min(walls_count, CGL_RAY_CASTER_MAX_WALLS - caster->wall_count - 1);
	memcpy(caster->walls + caster->wall_count, walls, sizeof(CGL_vec4) * walls_count);
	caster->wall_count += walls_count;
}

CGL_void CGL_ray_caster_add_wall(CGL_ray_caster* caster, CGL_vec4 wall)
{
	CGL_ray_caster_add_walls(caster, &wall, 1);
}

CGL_void CGL_ray_caster_clear_walls(CGL_ray_caster* caster)
{
	caster->wall_count = 0;
}

// algorithm from http://www.gamers.org/dEngine/rsc/usenet/comp.graphics.algorithms.faq
float CGL_ray_caster_get_intersection_point_for_wall(CGL_vec2 pos, CGL_vec2 dir, CGL_vec4 wall, CGL_vec2* intersection_point, float* angle, CGL_float max_dist)
{
	const CGL_float infinity = max_dist;
	CGL_vec2 A = pos;
	CGL_vec2 B = CGL_vec2_init(pos.x + infinity * dir.x, pos.y + infinity * dir.y);
	CGL_vec2 C = CGL_vec2_init(wall.x, wall.y);
	CGL_vec2 D = CGL_vec2_init(wall.z, wall.w);
	CGL_float n = 0.0f, d = 0.0f;
	// calculate r
	n = (A.y - C.y) * (D.x - C.x) - (A.x - C.x) * (D.y - C.y);
	d = (B.x - A.x) * (D.y - C.y) - (B.y - A.y) * (D.x - C.x);
	if (d == 0.0f) return -1.0f; // they are parallel
	CGL_float r = n / d;
	// calculate s
	n = (A.y - C.y) * (B.x - A.x) - (A.x - C.x) * (B.y - A.y);
	d = (B.x - A.x) * (D.y - C.y) - (B.y - A.y) * (D.x - C.x);
	if (d == 0.0f) return -1.0f; // they are parallel
	CGL_float s = n / d;
	// check if they intersect
	if (r < 0.0f || r > 1.0f || s < 0.0f || s > 1.0f) return -1.0f;
	// calculate intersection point
	if (intersection_point)
	{
		intersection_point->x = A.x + r * (B.x - A.x);
		intersection_point->y = A.y + r * (B.y - A.y);
	}
	if (angle) *angle = atan2f(dir.y, dir.x);
	return r * infinity;
}

float CGL_ray_caster_get_intersection_point_for_walls(CGL_vec2 pos, CGL_vec2 dir, CGL_vec4* walls, CGL_int wall_count, CGL_vec2* intersection_point, float* angle, CGL_float max_dist)
{
	CGL_float t = max_dist;
	CGL_float tmp = 0.0f;
	for (CGL_int i = 0; i < wall_count; i++)
	{
		tmp = CGL_ray_caster_get_intersection_point_for_wall(pos, dir, walls[i], NULL, NULL, max_dist);
		if (tmp > 0.0001f) t = CGL_utils_min(t, tmp);
	}
	CGL_float a = pos.x;
	CGL_float b = pos.y;
	CGL_float d = dir.x;
	CGL_float e = dir.y;
	if (intersection_point) *intersection_point = CGL_vec2_init(a + t * d, b + t * e);
	if (angle) *angle = atan2f(dir.y, dir.x);
	return t;
}

struct __CGL_ray_caster_ray
{
	CGL_vec2 target;
	CGL_vec2 dir;
	CGL_float angle;
	CGL_float dist;
};
typedef struct __CGL_ray_caster_ray __CGL_ray_caster_ray;

static void __CGL_ray_caster_calc_ray(CGL_ray_caster* caster, CGL_vec2* pos, CGL_float theta, __CGL_ray_caster_ray* ray)
{
	ray->dir = CGL_vec2_init(cosf(theta), sinf(theta));
	CGL_float t = CGL_ray_caster_get_intersection_point_for_walls(*pos, ray->dir, caster->walls, caster->wall_count, &ray->target, &ray->angle, caster->max_dist);
	ray->dist = t;
}

static CGL_int __CGL_ray_caster_ray_compare(const void* a, const void* b) {
	CGL_float c = ((__CGL_ray_caster_ray*)a)->angle;
	CGL_float d = ((__CGL_ray_caster_ray*)b)->angle;
	if (c > d) return -1;
	if (c < d) return 1;
	return 0;
}

float __CGL_ray_caster_calculate_angle_in_range(CGL_float ang)
{
	CGL_int n = (int)(fabsf(ang) / 3.141f);
	CGL_float th = fmodf(fabsf(ang), 3.141f);
	if (ang > 3.141f) ang = th - ((n % 2 == 0) ? 0.0f : 3.141f);
	else if (ang < -3.141f) ang = ((n % 2 == 0) ? 0.0f : 3.141f) - th;
	return ang;
}

CGL_void CGL_ray_caster_calculate(CGL_ray_caster* caster, CGL_vec2 pos, CGL_float rotation, bool visualise_rays)
{
	static __CGL_ray_caster_ray rays[CGL_RAY_CASTER_MAX_WALLS * 2];
	CGL_int ray_count = 0;

	CGL_float angmn = __CGL_ray_caster_calculate_angle_in_range(caster->theta_min + rotation);
	CGL_float angmx = __CGL_ray_caster_calculate_angle_in_range(caster->theta_max + rotation);
	CGL_vec2 min_border = CGL_vec2_init(cosf(angmn), sinf(angmn));
	CGL_vec2 max_border = CGL_vec2_init(cosf(angmx), sinf(angmx));
	CGL_vec2 dir = CGL_vec2_add(min_border, max_border);
	CGL_vec2_normalize(dir);


	//__CGL_ray_caster_calc_ray(caster, &pos, caster->theta_min + rotation, &rays[ray_count++]);
	//__CGL_ray_caster_calc_ray(caster, &pos, caster->theta_max + rotation, &rays[ray_count++]);
	for (CGL_float st = -3.141f; st < 3.141f; st += 0.5f)
		__CGL_ray_caster_calc_ray(caster, &pos, st, &rays[ray_count++]);
	const CGL_float epsilon = 0.0001f;
	for (CGL_int i = 0; i < caster->wall_count; i++)
	{
		CGL_vec4 wall = caster->walls[i];
		CGL_float theta = 0.0f;

		// calculate theta for wall start
		theta = atan2f(wall.y - pos.y, wall.x - pos.x);
		__CGL_ray_caster_calc_ray(caster, &pos, theta, &rays[ray_count++]);
		// calculate theta for wall start +- 0.0001f theta
		__CGL_ray_caster_calc_ray(caster, &pos, theta + epsilon, &rays[ray_count++]);
		__CGL_ray_caster_calc_ray(caster, &pos, theta - epsilon, &rays[ray_count++]);

		// calculate theta for wall end
		theta = atan2f(wall.w - pos.y, wall.z - pos.x);
		__CGL_ray_caster_calc_ray(caster, &pos, theta, &rays[ray_count++]);
		// calculate theta for wall end +- 0.0001f theta
		__CGL_ray_caster_calc_ray(caster, &pos, theta + epsilon, &rays[ray_count++]);
		__CGL_ray_caster_calc_ray(caster, &pos, theta - epsilon, &rays[ray_count++]);
	}

	// sort rays by angle using quicksort
	qsort(rays, ray_count, sizeof(__CGL_ray_caster_ray), __CGL_ray_caster_ray_compare);

	// create tiangle fans
	caster->triangle_count = 0;
	for (CGL_int i = 0; i < ray_count; i++)
	{
		//CGL_widgets_set_fill_color(CGL_utils_random_color());
		caster->triangles[caster->triangle_count].a = CGL_vec3_init(pos.x, pos.y, 0.0f);
		caster->triangles[caster->triangle_count].b = CGL_vec3_init(rays[(i + 1) % ray_count].target.x, rays[(i + 1) % ray_count].target.y, 0.0f);
		caster->triangles[caster->triangle_count].c = CGL_vec3_init(rays[i].target.x, rays[i].target.y, 0.0f);
#ifndef CGL_EXCLUDE_WIDGETS
		if (visualise_rays) CGL_widgets_add_triangle(caster->triangles[caster->triangle_count].a, caster->triangles[caster->triangle_count].b, caster->triangles[caster->triangle_count].c);
#endif
		caster->triangle_count++;
	}
	/*
	if(ray_count > 1)
	{
		caster->triangles[caster->triangle_count].a = CGL_vec3_init(pos.x, pos.y, 0.0f);
		caster->triangles[caster->triangle_count].b = CGL_vec3_init(rays[0].target.x, rays[0].target.y, 0.0f);
		caster->triangles[caster->triangle_count].c = CGL_vec3_init(rays[ray_count - 1].target.x, rays[ray_count - 1].target.y, 0.0f);
#ifndef CGL_EXCLUDE_WIDGETS
		if(visualise_rays) CGL_widgets_add_triangle(caster->triangles[caster->triangle_count].a, caster->triangles[caster->triangle_count].b, caster->triangles[caster->triangle_count].c);
#endif
		caster->triangle_count++;
	}
	*/


#ifndef CGL_EXCLUDE_WIDGETS
	// visualize rays
	if (visualise_rays)
	{
		CGL_widgets_set_stroke_colorf(0.2f, 0.3f, 0.7f, 1.0f);
		CGL_widgets_set_stroke_thicnkess(0.01f);
		for (CGL_int i = 0; i < ray_count; i++)
		{
			//if( ((rays[i].angle) >= (angmn - 0.1f) && (rays[i].angle) <= (angmx + 0.1f)) || ( (angmn >= 3.141f / 2 && angmx <= -3.141f/2) && (rays[i].angle >= (angmx - 0.1f) || (rays[i].angle) <= (angmn + 0.1f)) ) )
			// if( CGL_vec2_dot(dir, rays[i].dir) >= cdelta_half - 0.01f) // for future
			CGL_widgets_add_line(
				CGL_vec3_init(pos.x, pos.y, 0.0f),
				CGL_vec3_init(rays[i].target.x, rays[i].target.y, 0.0f)
			);
		}
	}
#endif
}

bool CGL_ray_caster_is_in_view(CGL_ray_caster* caster, CGL_vec2 point)
{
	for (CGL_int i = 0; i < caster->triangle_count; i++)
		if (CGL_utils_is_point_in_triangle(point, CGL_vec2_init(caster->triangles[i].a.x, caster->triangles[i].a.y), CGL_vec2_init(caster->triangles[i].b.x, caster->triangles[i].b.y), CGL_vec2_init(caster->triangles[i].c.x, caster->triangles[i].c.y))) return true;
	return false;
}

CGL_void CGL_ray_caster_set_angle_limits(CGL_ray_caster* caster, CGL_float min_angle, CGL_float max_angle)
{
	caster->theta_min = min_angle;
	caster->theta_max = max_angle;
}

CGL_void CGL_ray_caster_set_max_distance(CGL_ray_caster* caster, CGL_float val)
{
	caster->max_dist = val;
}

CGL_shape_triangle* CGL_ray_caster_get_triangles(CGL_ray_caster* caster, CGL_int* count)
{
	if (count) *count = caster->triangle_count;
	return caster->triangles;
}


#endif

#ifndef CGL_EXCLUDE_SQUARE_MARCHER

struct CGL_square_marcher
{
	void* user_data;
	bool interpolate;
};

CGL_square_marcher* CGL_square_marcher_create()
{
	CGL_square_marcher* marcher = (CGL_square_marcher*)CGL_malloc(sizeof(CGL_square_marcher));
	if (!marcher) return NULL;
	marcher->user_data = NULL;
	marcher->interpolate = false;
	return marcher;
}

CGL_void CGL_square_marcher_destroy(CGL_square_marcher* marcher)
{
	CGL_free(marcher);
}

CGL_void CGL_square_marcher_set_user_data(CGL_square_marcher* marcher, void* user_data)
{
	marcher->user_data = user_data;
}

CGL_void* CGL_square_marcher_get_user_data(CGL_square_marcher* marcher)
{
	return marcher->user_data;
}

CGL_void CGL_square_marcher_enable_interpolation(CGL_square_marcher* marcher, bool enable)
{
	marcher->interpolate = enable;
}


CGL_void __CGL_square_marcher_generate_mesh_add_triangle(CGL_list* list, CGL_vec2 a, CGL_vec2 b, CGL_vec2 c)
{
	CGL_mesh_vertex v = { 0 };
	v.normal = CGL_vec4_init(0.0f, 0.0f, 1.0f, 1.0f);
	v.position = CGL_vec4_init(a.x, a.y, 0.0f, 0.0f);
	CGL_list_push(list, &v);
	v.position = CGL_vec4_init(b.x, b.y, 0.0f, 0.0f);
	CGL_list_push(list, &v);
	v.position = CGL_vec4_init(c.x, c.y, 0.0f, 0.0f);
	CGL_list_push(list, &v);
}


CGL_mesh_cpu* CGL_square_marcher_generate_mesh(CGL_square_marcher* marcher, CGL_square_marcher_distance_function sampler, CGL_vec2 start, CGL_vec2 end, CGL_int resolution_x, CGL_int resolution_y)
{
	CGL_vec2 step_size = CGL_vec2_init((end.x - start.x) / (float)resolution_x, (end.y - start.y) / (float)resolution_y);
	CGL_vec2 pos[4] = { 0 }, mpts[4] = { 0 };
	CGL_bool smpb[4];
	CGL_float smpv[4] = { 0 }, intr[4] = { 0 };
	CGL_list* mesh_list = CGL_list_create(sizeof(CGL_mesh_vertex), 1000);

	for (CGL_int xi = -1; xi < resolution_x; xi++)
	{
		for (CGL_int yi = -1; yi < resolution_y; yi++)
		{
			pos[0] = CGL_vec2_init(start.x + xi * step_size.x, start.y + (yi + 1) * step_size.y);
			pos[1] = CGL_vec2_init(start.x + (xi + 1) * step_size.x, start.y + (yi + 1) * step_size.y);
			pos[2] = CGL_vec2_init(start.x + (xi + 1) * step_size.x, start.y + yi * step_size.y);
			pos[3] = CGL_vec2_init(start.x + xi * step_size.x, start.y + yi * step_size.y);

			for (CGL_int i = 0; i < 4; i++) intr[i] = 0.5f;

			/*
			*  A Possible Optimization
			*
			* We could have a cache of say CGL_float cache[10 * 10];
			* Now we loop from x = 0 to x = resolution_x / 10 and y = 0 to y = resolution_y / 10 in the outer loops
			* And have 2 inner loops from 1 - 10 each there e could cache the vlaue of the distance function
			* And then use the cached values in the inner loop saving a lot of calls to the distance function
			*/

			for (CGL_int i = 0; i < 4; i++) smpb[i] = sampler(pos[i], &smpv[i], marcher->user_data);

			if (marcher->interpolate) for (CGL_int i = 0; i < 4; i++) intr[i] = smpv[i] / (smpv[i] + smpv[(i + 1) % 4]);

			for (CGL_int i = 0; i < 4; i++) mpts[i] = CGL_vec2_init(CGL_utils_mix(pos[i].x, pos[(i + 1) % 4].x, intr[i]), CGL_utils_mix(pos[i].y, pos[(i + 1) % 4].y, intr[i]));

			if (!smpb[0] && !smpb[1] && !smpb[2] && !smpb[3]) // 0000
			{

			}
			else if (!smpb[0] && !smpb[1] && !smpb[2] && smpb[3]) // 0001
			{
				//CGL_widgets_add_line2f(mpts[2].x, mpts[2].y, mpts[3].x, mpts[3].y);
				__CGL_square_marcher_generate_mesh_add_triangle(mesh_list, pos[3], mpts[2], mpts[3]);
			}
			else if (!smpb[0] && !smpb[1] && smpb[2] && !smpb[3]) // 0010
			{
				//CGL_widgets_add_line2f(mpts[1].x, mpts[1].y, mpts[2].x, mpts[2].y); 
				__CGL_square_marcher_generate_mesh_add_triangle(mesh_list, pos[2], mpts[1], mpts[2]);
			}
			else if (!smpb[0] && !smpb[1] && smpb[2] && smpb[3]) // 0011
			{
				//CGL_widgets_add_line2f(mpts[3].x, mpts[3].y, mpts[1].x, mpts[1].y);
				__CGL_square_marcher_generate_mesh_add_triangle(mesh_list, pos[3], pos[2], mpts[1]);
				__CGL_square_marcher_generate_mesh_add_triangle(mesh_list, pos[3], mpts[1], mpts[3]);
			}
			else if (!smpb[0] && smpb[1] && smpb[2] && smpb[3]) // 0111
			{
				//CGL_widgets_add_line2f(mpts[0].x, mpts[0].y, mpts[3].x, mpts[3].y);
				__CGL_square_marcher_generate_mesh_add_triangle(mesh_list, pos[3], pos[2], pos[1]);
				__CGL_square_marcher_generate_mesh_add_triangle(mesh_list, pos[3], pos[1], mpts[0]);
				__CGL_square_marcher_generate_mesh_add_triangle(mesh_list, pos[3], mpts[0], mpts[3]);
			}
			else if (!smpb[0] && smpb[1] && smpb[2] && !smpb[3]) // 0110
			{
				//CGL_widgets_add_line2f(mpts[0].x, mpts[0].y, mpts[2].x, mpts[2].y);
				__CGL_square_marcher_generate_mesh_add_triangle(mesh_list, pos[2], pos[1], mpts[0]);
				__CGL_square_marcher_generate_mesh_add_triangle(mesh_list, pos[2], mpts[0], mpts[2]);
			}
			else if (!smpb[0] && smpb[1] && !smpb[2] && smpb[3]) // 0101
			{
				//CGL_widgets_add_line2f(mpts[0].x, mpts[0].y, mpts[1].x, mpts[1].y);
				//CGL_widgets_add_line2f(mpts[2].x, mpts[2].y, mpts[3].x, mpts[3].y);
				__CGL_square_marcher_generate_mesh_add_triangle(mesh_list, pos[3], mpts[2], mpts[3]);
				__CGL_square_marcher_generate_mesh_add_triangle(mesh_list, pos[1], mpts[1], mpts[0]);
			}
			else if (!smpb[0] && smpb[1] && !smpb[2] && !smpb[3]) // 0100
			{
				//CGL_widgets_add_line2f(mpts[0].x, mpts[0].y, mpts[1].x, mpts[1].y);
				__CGL_square_marcher_generate_mesh_add_triangle(mesh_list, pos[1], mpts[1], mpts[0]);
			}
			else if (smpb[0] && !smpb[1] && !smpb[2] && !smpb[3]) // 1000
			{
				//CGL_widgets_add_line2f(mpts[0].x, mpts[0].y, mpts[3].x, mpts[3].y);
				__CGL_square_marcher_generate_mesh_add_triangle(mesh_list, pos[0], mpts[0], mpts[3]);
			}
			else if (smpb[0] && !smpb[1] && smpb[2] && !smpb[3]) // 1010
			{
				//CGL_widgets_add_line2f(mpts[0].x, mpts[0].y, mpts[3].x, mpts[3].y);
				//CGL_widgets_add_line2f(mpts[1].x, mpts[1].y, mpts[2].x, mpts[2].y);
				__CGL_square_marcher_generate_mesh_add_triangle(mesh_list, pos[0], mpts[0], mpts[3]);
				__CGL_square_marcher_generate_mesh_add_triangle(mesh_list, pos[2], mpts[1], mpts[2]);
			}
			else if (smpb[0] && !smpb[1] && smpb[2] && smpb[3]) // 1011
			{
				//CGL_widgets_add_line2f(mpts[0].x, mpts[0].y, mpts[1].x, mpts[1].y);
				__CGL_square_marcher_generate_mesh_add_triangle(mesh_list, pos[0], pos[3], pos[2]);
				__CGL_square_marcher_generate_mesh_add_triangle(mesh_list, pos[0], pos[2], mpts[1]);
				__CGL_square_marcher_generate_mesh_add_triangle(mesh_list, pos[0], mpts[1], mpts[0]);
			}
			else if (smpb[0] && smpb[1] && !smpb[2] && smpb[3]) // 1101
			{
				//CGL_widgets_add_line2f(mpts[1].x, mpts[1].y, mpts[2].x, mpts[2].y);
				__CGL_square_marcher_generate_mesh_add_triangle(mesh_list, pos[0], pos[1], pos[3]);
				__CGL_square_marcher_generate_mesh_add_triangle(mesh_list, pos[1], mpts[2], pos[3]);
				__CGL_square_marcher_generate_mesh_add_triangle(mesh_list, pos[1], mpts[1], mpts[2]);
			}
			else if (smpb[0] && smpb[1] && smpb[2] && !smpb[3]) // 1110
			{
				//CGL_widgets_add_line2f(mpts[2].x, mpts[2].y, mpts[3].x, mpts[3].y);
				__CGL_square_marcher_generate_mesh_add_triangle(mesh_list, pos[0], pos[1], pos[2]);
				__CGL_square_marcher_generate_mesh_add_triangle(mesh_list, pos[0], pos[2], mpts[2]);
				__CGL_square_marcher_generate_mesh_add_triangle(mesh_list, pos[0], mpts[2], mpts[3]);
			}
			else if (smpb[0] && smpb[1] && !smpb[2] && !smpb[3]) // 1100
			{
				//CGL_widgets_add_line2f(mpts[3].x, mpts[3].y, mpts[1].x, mpts[1].y);
				__CGL_square_marcher_generate_mesh_add_triangle(mesh_list, pos[0], pos[1], mpts[1]);
				__CGL_square_marcher_generate_mesh_add_triangle(mesh_list, pos[0], mpts[1], mpts[3]);
			}
			else if (smpb[0] && !smpb[1] && !smpb[2] && smpb[3]) // 1001
			{
				//CGL_widgets_add_line2f(mpts[0].x, mpts[0].y, mpts[2].x, mpts[2].y);
				__CGL_square_marcher_generate_mesh_add_triangle(mesh_list, pos[3], mpts[2], pos[0]);
				__CGL_square_marcher_generate_mesh_add_triangle(mesh_list, mpts[2], mpts[0], pos[0]);
			}
			else if (smpb[0] && smpb[1] && smpb[2] && smpb[3]) // 1111
			{
				__CGL_square_marcher_generate_mesh_add_triangle(mesh_list, pos[0], pos[2], pos[1]);
				__CGL_square_marcher_generate_mesh_add_triangle(mesh_list, pos[0], pos[3], pos[2]);
			}

		}

	}
	size_t vt_ct = CGL_list_get_size(mesh_list);
	CGL_mesh_cpu* mesh = CGL_mesh_cpu_create(vt_ct, vt_ct);
	memcpy(mesh->vertices, mesh_list->data, sizeof(CGL_mesh_vertex) * vt_ct);
	for (size_t i = 0; i < vt_ct; i++) mesh->indices[i] = (CGL_uint)i;
	CGL_list_destroy(mesh_list);
	return mesh;
}



#endif



#ifndef CGL_EXCLUDE_POST_PROCESSOR



struct CGL_post_processor
{
	CGL_shader* shades_shader;
	CGL_shader* outlines_shader;
	CGL_shader* hatching_shader;
};



static CGL_post_processor* __CGL_POST_PROCESSOR_CONTEXT = NULL;



static const CGL_byte* __CGL_TOON_SHADES_SHADER_SOURCE =
"#version 430 core\n"
"\n"
"layout (local_size_x = 16, local_size_y = 16) in;\n"
"\n"
"layout (rgba32f, binding = 0) uniform image2D output_tex;\n"
"layout (rgba32f, binding = 1) uniform image2D input_tex;\n"
"\n"
"uniform int shades = 1;\n"
"uniform sampler2D albedo_tex;\n"
"uniform ivec2 resolution;\n"
"\n"
"void main()\n"
"{\n"
"    ivec2 pixel_coord = ivec2(gl_GlobalInvocationID.xy);\n"
"    vec2 uv = vec2(pixel_coord) / vec2(resolution);\n"
"    vec3 scene_pixel = imageLoad(input_tex, pixel_coord).rgb;\n"
"    scene_pixel = floor(scene_pixel * float(shades)) / float(shades);\n"
"    vec3 albedo_pixel = texture(albedo_tex, uv).rgb;\n"
"    vec3 output_pixel = scene_pixel + albedo_pixel;\n"
"    imageStore(output_tex, pixel_coord, vec4(output_pixel, 1.0));\n"
"}\n"
"\n";



static const CGL_byte* __CGL_TOON_OUTLINES_SHADER_SOURCE =
"#version 430 core\n"

"layout (local_size_x = 16, local_size_y = 16) in;\n"

"layout (rgba32f, binding = 0) uniform image2D output_tex;\n"
"layout (rgba32f, binding = 1) uniform image2D scene;\n"

"uniform float outline_width = 1.0f;\n"
"uniform ivec2 resolution;\n"
"uniform sampler2D normal_tex;\n"
"uniform sampler2D depth_tex;\n"

"float max_vec3(vec3 v)\n"
"{\n"
"    return max(max(v.x, v.y), v.z);\n"
"}\n"

// TODO: Take zFar and zNear as uniforms 
"float linearize_depth(float depth)\n"
"{\n"
"    float zFar = 100.0f;\n"
"    float zNear = 0.01f;\n"
"    return (2.0f * zNear) / (zFar + zNear - depth * (zFar - zNear));\n"
"}\n"


"float get_n_factor(vec2 uv)\n"
"{\n"
"    float current_normal = max_vec3(texture(normal_tex, uv).rgb);\n"
"    float left_normal = max_vec3(texture(normal_tex, uv + vec2(-outline_width / float(resolution.x), 0.0)).rgb);\n"
"    float right_normal = max_vec3(texture(normal_tex, uv + vec2(outline_width / float(resolution.x), 0.0)).rgb);\n"
"    float top_normal = max_vec3(texture(normal_tex, uv + vec2(0.0, outline_width / float(resolution.y))).rgb);\n"
"    float bottom_normal = max_vec3(texture(normal_tex, uv + vec2(0.0, -outline_width / float(resolution.y))).rgb);\n"
"    float n_factor = 0.0;\n"
"    n_factor = abs(current_normal - left_normal) + abs(current_normal - right_normal) + abs(current_normal - top_normal) + abs(current_normal - bottom_normal);\n"
//"    return clamp(n_factor, 0.0f, 1.0f);\n" // another special effect
"    return 1.0f - clamp(smoothstep(n_factor, 0.2f, 0.85f), 0.0f, 1.0f);\n"
"}\n"

"float get_d_factor(vec2 uv)\n"
"{\n"
"    float current_depth = linearize_depth(texture(depth_tex, uv).r);\n"
"    float left_depth = linearize_depth(texture(depth_tex, uv + vec2(-outline_width / float(resolution.x), 0.0)).r);\n"
"    float right_depth = linearize_depth(texture(depth_tex, uv + vec2(outline_width / float(resolution.x), 0.0)).r);\n"
"    float top_depth = linearize_depth(texture(depth_tex, uv + vec2(0.0, outline_width / float(resolution.y))).r);\n"
"    float bottom_depth = linearize_depth(texture(depth_tex, uv + vec2(0.0, -outline_width / float(resolution.y))).r);\n"
"    float d_factor = 0.0;\n"
"    d_factor = abs(current_depth - left_depth) + abs(current_depth - right_depth) + abs(current_depth - top_depth) + abs(current_depth - bottom_depth);\n"
"    return clamp(d_factor, 0.0f, 1.0f);\n"
"}\n"

"void main()\n"
"{\n"
"    ivec2 pixel_coord = ivec2(gl_GlobalInvocationID.xy);\n"
"    vec2 uv = vec2(pixel_coord) / vec2(resolution);\n"
"    float n_factor = get_n_factor(uv);\n"
"    float d_factor = get_d_factor(uv);\n"
"    float factor = max(n_factor, d_factor);\n"
"    vec3 scene_pixel = imageLoad(scene, pixel_coord).rgb;\n"
"    vec3 output_pixel = scene_pixel * (1.0f - factor);\n"
"    imageStore(output_tex, pixel_coord, vec4(output_pixel, 1.0));\n"
"}\n";



static const CGL_byte* __CGL_TOON_HATCHING_SHADER_SOURCE =
"#version 430 core\n"
"\n"
"layout (local_size_x = 16, local_size_y = 16) in;\n"
"\n"
"layout (rgba32f, binding = 0) uniform image2D output_tex;\n"
"\n"
"uniform sampler2D input_tex;\n"
"uniform sampler2D uv_tex;\n"
"uniform sampler2D hatch_tex[8];\n"
"uniform int hatch_tex_count;\n"
"uniform ivec2 resolution;\n"
"\n"
"vec3 hatching(vec2 uv, float intensity)\n"
"{\n"
"   vec3 overbright = vec3(max(0.0f, intensity - 1.0f));\n"
"   vec3 opt = overbright;\n"
"   float tot_weight = 0.0f;\n"
"   for(int i = 0 ; i < hatch_tex_count; i++)\n"
"   {\n"
"       float a0 = clamp(intensity * float(hatch_tex_count) - float(i), 0.0f, 1.0f);\n"
"       float a1 = clamp(intensity * float(hatch_tex_count) - float(i + 1), 0.0f, 1.0f);\n"
"       float weight = a0 - a1;\n"
"       tot_weight += weight;"
"       opt += texture(hatch_tex[i], uv * 8.0f).rgb * weight;\n"
"   }\n"
"   return opt / tot_weight;\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"    ivec2 pixel_coord = ivec2(gl_GlobalInvocationID.xy);\n"
"    vec2 uv = vec2(pixel_coord) / vec2(resolution);\n"
"    vec2 sc_uv = texture(uv_tex, uv).rg;\n"
"    float filter_f = length(sc_uv);\n"
"    vec3 input_color = texture(input_tex, uv).rgb;\n"
"    vec3 output_pixel = vec3(0.0f);\n"
"    output_pixel = hatching(uv, dot(input_color, vec3(0.2326f, 0.7152f, 0.0722f)));\n"
"    if(filter_f > 1.0f) {output_pixel = vec3(1.0f); }\n"
"    imageStore(output_tex, pixel_coord, vec4(output_pixel, 1.0));\n"
"}\n"
"\n";


CGL_void CGL_post_processor_init()
{
	__CGL_POST_PROCESSOR_CONTEXT = (CGL_post_processor*)CGL_malloc(sizeof(CGL_post_processor));
	__CGL_POST_PROCESSOR_CONTEXT->shades_shader = CGL_shader_compute_create(__CGL_TOON_SHADES_SHADER_SOURCE, NULL);
	__CGL_POST_PROCESSOR_CONTEXT->outlines_shader = CGL_shader_compute_create(__CGL_TOON_OUTLINES_SHADER_SOURCE, NULL);
	__CGL_POST_PROCESSOR_CONTEXT->hatching_shader = CGL_shader_compute_create(__CGL_TOON_HATCHING_SHADER_SOURCE, NULL);
}


CGL_void CGL_post_processor_shutdown()
{
	CGL_shader_destroy(__CGL_POST_PROCESSOR_CONTEXT->shades_shader);
	CGL_shader_destroy(__CGL_POST_PROCESSOR_CONTEXT->outlines_shader);
	CGL_shader_destroy(__CGL_POST_PROCESSOR_CONTEXT->hatching_shader);
	CGL_free(__CGL_POST_PROCESSOR_CONTEXT);
}


CGL_void CGL_post_processor_process_shades(CGL_texture* output, CGL_texture* scene, CGL_texture* albedo, CGL_int shades)
{
	CGL_shader_bind(__CGL_POST_PROCESSOR_CONTEXT->shades_shader);
	glBindImageTexture(0, output->handle, 0, GL_FALSE, 0, GL_WRITE_ONLY, GL_RGBA32F);
	glBindImageTexture(1, scene->handle, 0, GL_FALSE, 0, GL_READ_ONLY, GL_RGBA32F);
	CGL_shader_set_uniform_int(__CGL_POST_PROCESSOR_CONTEXT->shades_shader, CGL_shader_get_uniform_location(__CGL_POST_PROCESSOR_CONTEXT->shades_shader, "shades"), shades);
	CGL_texture_bind(albedo, 2);
	CGL_shader_set_uniform_int(__CGL_POST_PROCESSOR_CONTEXT->shades_shader, CGL_shader_get_uniform_location(__CGL_POST_PROCESSOR_CONTEXT->shades_shader, "albedo_tex"), 2);
	CGL_shader_set_uniform_ivec2v(__CGL_POST_PROCESSOR_CONTEXT->shades_shader, CGL_shader_get_uniform_location(__CGL_POST_PROCESSOR_CONTEXT->shades_shader, "resolution"), output->width, output->height);
	CGL_shader_compute_dispatch(__CGL_POST_PROCESSOR_CONTEXT->shades_shader, output->width / 16 + 1, output->height / 16 + 1, 1);
	glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);
}


CGL_void CGL_post_processor_process_outline(CGL_texture* output, CGL_texture* scene, CGL_texture* normal, CGL_texture* depth, CGL_float outline_width)
{
	CGL_shader_bind(__CGL_POST_PROCESSOR_CONTEXT->outlines_shader);
	glBindImageTexture(0, output->handle, 0, GL_FALSE, 0, GL_WRITE_ONLY, GL_RGBA32F);
	glBindImageTexture(1, scene->handle, 0, GL_FALSE, 0, GL_READ_ONLY, GL_RGBA32F);
	CGL_texture_bind(normal, 2);
	CGL_shader_set_uniform_int(__CGL_POST_PROCESSOR_CONTEXT->outlines_shader, CGL_shader_get_uniform_location(__CGL_POST_PROCESSOR_CONTEXT->outlines_shader, "normal_tex"), 2);
	CGL_texture_bind(depth, 3);
	CGL_shader_set_uniform_int(__CGL_POST_PROCESSOR_CONTEXT->outlines_shader, CGL_shader_get_uniform_location(__CGL_POST_PROCESSOR_CONTEXT->outlines_shader, "depth_tex"), 3);
	CGL_shader_set_uniform_ivec2v(__CGL_POST_PROCESSOR_CONTEXT->outlines_shader, CGL_shader_get_uniform_location(__CGL_POST_PROCESSOR_CONTEXT->outlines_shader, "resolution"), output->width, output->height);
	CGL_shader_set_uniform_float(__CGL_POST_PROCESSOR_CONTEXT->outlines_shader, CGL_shader_get_uniform_location(__CGL_POST_PROCESSOR_CONTEXT->outlines_shader, "outline_width"), outline_width);
	CGL_shader_compute_dispatch(__CGL_POST_PROCESSOR_CONTEXT->outlines_shader, output->width / 16 + 1, output->height / 16 + 1, 1);
	glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);
}



CGL_void CGL_post_processor_process_hatching(CGL_texture* output, CGL_texture* scene, CGL_texture* uv_tex, CGL_texture** hatch_tex, CGL_int hatch_tex_count)
{
	static char buffer[256];
	CGL_shader_bind(__CGL_POST_PROCESSOR_CONTEXT->hatching_shader);
	glBindImageTexture(0, output->handle, 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
	CGL_texture_bind(uv_tex, 2);
	CGL_shader_set_uniform_int(__CGL_POST_PROCESSOR_CONTEXT->hatching_shader, CGL_shader_get_uniform_location(__CGL_POST_PROCESSOR_CONTEXT->hatching_shader, "uv_tex"), 2);
	CGL_texture_bind(scene, 3);
	CGL_shader_set_uniform_int(__CGL_POST_PROCESSOR_CONTEXT->hatching_shader, CGL_shader_get_uniform_location(__CGL_POST_PROCESSOR_CONTEXT->hatching_shader, "input_tex"), 3);
	for (CGL_int i = 0; i < hatch_tex_count; i++)
	{
		sprintf(buffer, "hatch_tex[%d]", i);
		CGL_texture_bind(hatch_tex[i], 4 + i);
		CGL_shader_set_uniform_int(__CGL_POST_PROCESSOR_CONTEXT->hatching_shader, CGL_shader_get_uniform_location(__CGL_POST_PROCESSOR_CONTEXT->hatching_shader, buffer), 4 + i);
	}
	CGL_shader_set_uniform_int(__CGL_POST_PROCESSOR_CONTEXT->hatching_shader, CGL_shader_get_uniform_location(__CGL_POST_PROCESSOR_CONTEXT->hatching_shader, "hatch_tex_count"), hatch_tex_count);
	CGL_shader_set_uniform_ivec2v(__CGL_POST_PROCESSOR_CONTEXT->hatching_shader, CGL_shader_get_uniform_location(__CGL_POST_PROCESSOR_CONTEXT->hatching_shader, "resolution"), output->width, output->height);
	CGL_shader_compute_dispatch(__CGL_POST_PROCESSOR_CONTEXT->hatching_shader, output->width / 16 + 1, output->height / 16 + 1, 1);
	glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);
}

#endif

#define __CGL_WAV_LOADER_FAIL_AND_RETURN { CGL_log_internal("WAV Loader (%s): Invalid file", filename); fclose(fd); return false; }
#define __CGL_WAV_LOADER_SAFE_READ(varname, sze, cnt) if (fread(&varname, sze, cnt, fd) != cnt) __CGL_WAV_LOADER_FAIL_AND_RETURN

// Referred from https://www.mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/WAVE.html
CGL_bool CGL_wav_file_load(CGL_wav_file* file, const char* filename)
{
	FILE* fd = fopen(filename, "rb");
	if (!fd) return false;
	CGL_int tmp = 0, ck_size = 0, fmt_ck_size = 0, sample_rate = 0, byte_rate = 0, data_ck_size = 0;
	CGL_short audio_format = 0, block_align = 0, bits_per_sample = 0, channel_count = 0;

	// check RIFF signature
	__CGL_WAV_LOADER_SAFE_READ(tmp, 4, 1)
		if (memcmp((CGL_byte*)&tmp, "RIFF", 4) != 0) { CGL_log_internal("WAV Loader (%s): Invalid RIFF signature", filename); fclose(fd); return false; }

	// read chunk size
	__CGL_WAV_LOADER_SAFE_READ(ck_size, 4, 1)
		CGL_utils_little_endian_to_current(&ck_size, 4);

	// check WAVE signature
	__CGL_WAV_LOADER_SAFE_READ(tmp, 4, 1)
		if (memcmp((CGL_byte*)&tmp, "WAVE", 4) != 0) { CGL_log_internal("WAV Loader (%s): Invalid WAVE signature", filename); fclose(fd); return false; }

	// check fmt signature
	__CGL_WAV_LOADER_SAFE_READ(tmp, 4, 1)
		if (memcmp((CGL_byte*)&tmp, "fmt ", 4) != 0) { CGL_log_internal("WAV Loader (%s): Invalid fmt signature", filename); fclose(fd); return false; }

	// read fmt chunk size
	__CGL_WAV_LOADER_SAFE_READ(fmt_ck_size, 4, 1)
		CGL_utils_little_endian_to_current(&fmt_ck_size, 4);

	// read audio format
	__CGL_WAV_LOADER_SAFE_READ(audio_format, 2, 1)
		CGL_utils_little_endian_to_current(&audio_format, 2);
	//audio_format = (CGL_int)(*((CGL_short*)&audio_format));
	if (audio_format != 1) { CGL_log_internal("WAV Loader (%s): Unsupported audio format", filename); fclose(fd); return false; }

	// read channel count
	__CGL_WAV_LOADER_SAFE_READ(channel_count, 2, 1)
		CGL_utils_little_endian_to_current(&channel_count, 2);
	//channel_count = (CGL_int)(*((CGL_short*)&channel_count));

	// read sample rate
	__CGL_WAV_LOADER_SAFE_READ(sample_rate, 4, 1)
		CGL_utils_little_endian_to_current(&sample_rate, 4);

	// read byte rate = sample rate * block align(= channel count * bits per sample / 8)
	__CGL_WAV_LOADER_SAFE_READ(byte_rate, 4, 1)
		CGL_utils_little_endian_to_current(&byte_rate, 4);

	// read block align = channel count * bits per sample / 8
	__CGL_WAV_LOADER_SAFE_READ(block_align, 2, 1)
		CGL_utils_little_endian_to_current(&block_align, 2);
	// block_align = (CGL_int)(*((CGL_short*)&block_align));

	// read bits per sample
	__CGL_WAV_LOADER_SAFE_READ(bits_per_sample, 2, 1)
		CGL_utils_little_endian_to_current(&bits_per_sample, 2);
	// bits_per_sample = (CGL_int)(*((CGL_short*)&bits_per_sample));

	// skip to data chunk
	__CGL_WAV_LOADER_SAFE_READ(tmp, 4, 1)
		while (memcmp((CGL_byte*)&tmp, "data", 4) != 0)
		{
			__CGL_WAV_LOADER_SAFE_READ(tmp, 4, 1)
				fseek(fd, tmp, SEEK_CUR);
			if (fread(&tmp, 4, 1, fd) < 1) { CGL_log_internal("WAV Loader (%s): Failed to read data chunk", filename); fclose(fd); return false; }
		}
	if (memcmp((CGL_byte*)&tmp, "data", 4) != 0) { CGL_log_internal("WAV Loader (%s): Invalid data signature", filename); fclose(fd); return false; }

	// read data chunk size
	__CGL_WAV_LOADER_SAFE_READ(data_ck_size, 4, 1)
		CGL_utils_little_endian_to_current(&data_ck_size, 4);

	// read data
	file->data = (CGL_byte*)CGL_malloc(data_ck_size);
	if (!file->data) { CGL_log_internal("WAV Loader (%s): Failed to allocate memory", filename); fclose(fd); return false; }

	if (fread(file->data, data_ck_size, 1, fd) < 1) { CGL_log_internal("WAV Loader (%s): Failed to read data", filename); fclose(fd); return false; }

	file->channel_count = channel_count;
	file->sample_rate = sample_rate;
	file->bits_per_sample = bits_per_sample;
	file->data_size = data_ck_size;
	file->duration = (CGL_float)data_ck_size / (CGL_float)(sample_rate * channel_count * bits_per_sample / 8);


	fclose(fd);
	return true;
}

CGL_void CGL_wav_file_destroy(CGL_wav_file* file)
{
	CGL_free(file->data);
}

CGL_int CGL_wav_file_sample(CGL_wav_file* file, CGL_int channel, CGL_int sample_offset)
{
	if (channel >= file->channel_count) return 0;
	if (sample_offset >= file->data_size) return 0;
	CGL_short sample = 0;
	sample_offset += channel * file->bits_per_sample / 8;
	memcpy(&sample, file->data + sample_offset, file->bits_per_sample / 8);
	//CGL_utils_little_endian_to_current(&sample, file->bits_per_sample / 8);
	return (CGL_int)sample;
}

CGL_int CGL_wav_file_sample_at_time(CGL_wav_file* file, CGL_int channel, CGL_float time)
{
	if (channel >= file->channel_count) return 0;
	if (time >= file->duration) return 0;
	CGL_int sample_offset = (CGL_int)((CGL_int)(time * file->sample_rate) * file->channel_count * file->bits_per_sample / 8);
	return CGL_wav_file_sample(file, channel, sample_offset);
}

#ifndef CGL_EXCLUDE_AUDIO

#include <AL/al.h>
#include <AL/alc.h>

struct CGL_audio_context
{
	ALCdevice* device;
	ALCcontext* context;
};

struct CGL_audio_source
{
	CGL_vec3 position;
	CGL_vec3 velocity;
	CGL_vec3 direction;
	ALuint source;
	float pitch;
	float gain;
	CGL_bool loop;
};

struct CGL_audio_buffer
{
	ALuint buffer;
	size_t size;
};



CGL_int CGL_audio_get_last_error()
{
	return alGetError();
}

const CGL_byte* CGL_audio_get_error_string(CGL_int error)
{
	return alGetString(error);
}

const CGL_byte* CGL_audio_get_device_list()
{
	return alcGetString(NULL, ALC_DEVICE_SPECIFIER);
}

const CGL_byte* CGL_audio_get_default_device()
{
	return alcGetString(NULL, ALC_DEFAULT_DEVICE_SPECIFIER);
}

CGL_audio_context* CGL_audio_context_create(const CGL_byte* device_name)
{
	ALCdevice* device = alcOpenDevice(device_name);
	if (!device) { CGL_log_internal("Audio: Failed to open device %s", device_name); return NULL; }
	CGL_log_internal("Audio: Opened device %s", device_name);
	ALCcontext* context = alcCreateContext(device, NULL);
	if (!context) { CGL_log_internal("Audio: Failed to create context"); alcCloseDevice(device); return NULL; }
	CGL_log_internal("Audio: Created context");
	alcMakeContextCurrent(context);
	CGL_audio_context* cgl_context = (CGL_audio_context*)CGL_malloc(sizeof(CGL_audio_context));
	if (!cgl_context) { CGL_log_internal("Audio: Failed to allocate memory"); alcDestroyContext(context); alcCloseDevice(device); return NULL; }
	cgl_context->device = device;
	cgl_context->context = context;
	return cgl_context;
}

CGL_void CGL_audio_context_destroy(CGL_audio_context* context)
{
	alcMakeContextCurrent(NULL);
	alcDestroyContext(context->context);
	alcCloseDevice(context->device);
	CGL_free(context);
}

CGL_void CGL_audio_make_context_current(CGL_audio_context* context)
{
	if (context) alcMakeContextCurrent(context->context);
	else alcMakeContextCurrent(NULL);
}



CGL_audio_source* CGL_audio_source_create()
{
	CGL_audio_source* source = (CGL_audio_source*)CGL_malloc(sizeof(CGL_audio_source));
	if (!source) { CGL_log_internal("Audio: Failed to allocate memory"); return NULL; }
	alGenSources(1, &source->source);
	source->position = CGL_vec3_init(0.0f, 0.0f, 0.0f);
	source->velocity = CGL_vec3_init(0.0f, 0.0f, 0.0f);
	source->pitch = 1.0f;
	source->gain = 1.0f;
	source->loop = false;
	return source;
}

CGL_void CGL_audio_source_destroy(CGL_audio_source* source)
{
	alDeleteSources(1, &source->source);
	CGL_free(source);
}

CGL_void CGL_audio_source_reset_to_defaults(CGL_audio_source* source)
{
	CGL_audio_source_set_position(source, CGL_vec3_init(0.0f, 0.0f, 0.0f));
	CGL_audio_source_set_velocity(source, CGL_vec3_init(0.0f, 0.0f, 0.0f));
	CGL_audio_source_set_direction(source, CGL_vec3_init(0.0f, 0.0f, -1.0f));
	CGL_audio_source_set_pitch(source, 1.0f);
	CGL_audio_source_set_gain(source, 1.0f);
	CGL_audio_source_set_looping(source, false);
}

CGL_void CGL_audio_source_set_buffer(CGL_audio_source* source, CGL_audio_buffer* buffer)
{
	alSourcei(source->source, AL_BUFFER, buffer->buffer);
}

CGL_void CGL_audio_source_set_looping(CGL_audio_source* source, CGL_bool looping)
{
	source->loop = looping;
	alSourcei(source->source, AL_LOOPING, looping);
}

CGL_void CGL_audio_source_set_pitch(CGL_audio_source* source, CGL_float pitch)
{
	source->pitch = pitch;
	alSourcef(source->source, AL_PITCH, pitch);
}

CGL_void CGL_audio_source_set_gain(CGL_audio_source* source, CGL_float gain)
{
	source->gain = gain;
	alSourcef(source->source, AL_GAIN, gain);
}

CGL_void CGL_audio_source_set_position(CGL_audio_source* source, CGL_vec3 position)
{
	source->position = position;
	alSource3f(source->source, AL_POSITION, position.x, position.y, position.z);
}

CGL_void CGL_audio_source_set_velocity(CGL_audio_source* source, CGL_vec3 velocity)
{
	source->velocity = velocity;
	alSource3f(source->source, AL_VELOCITY, velocity.x, velocity.y, velocity.z);
}

CGL_void CGL_audio_source_set_direction(CGL_audio_source* source, CGL_vec3 direction)
{
	source->direction = direction;
	alSource3f(source->source, AL_DIRECTION, direction.x, direction.y, direction.z);
}

CGL_float CGL_audio_source_get_seconds_offset(CGL_audio_source* source)
{
	ALfloat offset = 0;
	alGetSourcef(source->source, AL_SEC_OFFSET, &offset);
	return (CGL_float)offset;
}

CGL_void CGL_audio_source_set_seconds_offset(CGL_audio_source* source, CGL_sizei seconds)
{
	alSourcei(source->source, AL_SEC_OFFSET, (ALint)seconds);
}

CGL_sizei CGL_audio_source_get_samples_offset(CGL_audio_source* source)
{
	ALint offset = 0;
	alGetSourcei(source->source, AL_SAMPLE_OFFSET, &offset);
	return (CGL_sizei)offset;
}

CGL_void CGL_audio_source_set_samples_offset(CGL_audio_source* source, CGL_sizei samples)
{
	alSourcei(source->source, AL_SAMPLE_OFFSET, (ALint)samples);
}

CGL_sizei CGL_audio_source_get_bytes_offset(CGL_audio_source* source)
{
	ALint offset = 0;
	alGetSourcei(source->source, AL_BYTE_OFFSET, &offset);
	return (CGL_sizei)offset;
}

CGL_void CGL_audio_source_set_bytes_offset(CGL_audio_source* source, CGL_sizei bytes)
{
	alSourcei(source->source, AL_BYTE_OFFSET, (ALint)bytes);
}

CGL_void CGL_audio_source_play(CGL_audio_source* source)
{
	alSourcePlay(source->source);
}

CGL_void CGL_audio_source_pause(CGL_audio_source* source)
{
	alSourcePause(source->source);
}

CGL_void CGL_audio_source_stop(CGL_audio_source* source)
{
	alSourceStop(source->source);
}

CGL_bool CGL_audio_source_is_playing(CGL_audio_source* source)
{
	CGL_int state = 0;
	alGetSourcei(source->source, AL_SOURCE_STATE, &state);
	return state == AL_PLAYING;
}

CGL_bool CGL_audio_source_is_paused(CGL_audio_source* source)
{
	CGL_int state = 0;
	alGetSourcei(source->source, AL_SOURCE_STATE, &state);
	return state == AL_PAUSED;
}

CGL_bool CGL_audio_source_is_stopped(CGL_audio_source* source)
{
	CGL_int state = 0;
	alGetSourcei(source->source, AL_SOURCE_STATE, &state);
	return state == AL_STOPPED;
}

CGL_audio_buffer* CGL_audio_buffer_create()
{
	CGL_audio_buffer* buffer = (CGL_audio_buffer*)CGL_malloc(sizeof(CGL_audio_buffer));
	if (!buffer) { CGL_log_internal("Audio: Failed to allocate memory"); return NULL; }
	buffer->size = 0;
	alGenBuffers(1, &buffer->buffer);
	return buffer;
}

CGL_void CGL_audio_buffer_destroy(CGL_audio_buffer* buffer)
{
	alDeleteBuffers(1, &buffer->buffer);
	CGL_free(buffer);
}

CGL_void CGL_audio_buffer_set_data_from_wav_file(CGL_audio_buffer* buffer, CGL_wav_file* file)
{
	ALenum format = AL_FORMAT_MONO16;
	ALsizei size = 0;
	ALsizei freq = 0;
	if (file->channel_count == 1 && file->bits_per_sample == 8)
		format = AL_FORMAT_MONO8;
	else if (file->channel_count == 1 && file->bits_per_sample == 16)
		format = AL_FORMAT_MONO16;
	else if (file->channel_count == 2 && file->bits_per_sample == 8)
		format = AL_FORMAT_STEREO8;
	else if (file->channel_count == 2 && file->bits_per_sample == 16)
		format = AL_FORMAT_STEREO16;
	else
	{
		CGL_log_internal("Audio: Unsupported WAV file format");
		return;
	}
	size = file->data_size;
	freq = file->sample_rate;
	alBufferData(buffer->buffer, format, file->data, size, freq);
}

CGL_void CGL_audio_buffer_set_data(CGL_audio_buffer* buffer, void* data, ALenum format, ALsizei size, ALsizei freq)
{
	alBufferData(buffer->buffer, format, data, size, freq);
}

CGL_void CGL_audio_listener_set_position(CGL_vec3 position)
{
	alListener3f(AL_POSITION, position.x, position.y, position.z);
}

CGL_void CGL_audio_listener_set_velocity(CGL_vec3 velocity)
{
	alListener3f(AL_VELOCITY, velocity.x, velocity.y, velocity.z);
}

CGL_void CGL_audio_listener_set_orientation(CGL_vec3 forward, CGL_vec3 up)
{
	CGL_float orientation[6] = { forward.x, forward.y, forward.z, up.x, up.y, up.z };
	alListenerfv(AL_ORIENTATION, orientation);
}


#endif



#ifndef CGL_EXCLUDE_TRAIL_RENDERER

#ifndef CGL_TRAIL_MAX_POINTS
#define CGL_TRAIL_MAX_POINTS 1024
#endif

/*
struct CGL_trail_point
{
	CGL_vec3 position;
	CGL_trail_point* next;
	void* user_data;
	CGL_int index;
	CGL_float lifespan;
	CGL_float thickness;
	CGL_float distance;
};
*/

static const char* __CGL_TRAIL_DEFAULT_VERTEX_SHADER =
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
"\n"
"in vec4 position;\n" // w is lifespan
"in vec4 normal;\n" // w is distance
"in vec4 texcoord;\n" // zw is reserved for future use
#else
"#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n" // w is lifespan
"layout (location = 1) in vec4 normal;\n" // w is distance
"layout (location = 2) in vec4 texcoord;\n" // zw is reserved for future use
#endif
"\n"
"out vec3 Position;\n"
"out vec2 TexCoord;\n"
"out float Distance;\n"
"\n"
"uniform mat4 projection;\n"
"uniform mat4 view;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = projection * view * vec4(position.xyz, 1.0f);\n"
"	Position = position.xyz;\n"
"	TexCoord = texcoord.xy;\n"
"   Distance = normal.w;\n"
"}\n";

static const char* __CGL_TRAIL_DEFAULT_FRAGMENT_SHADER = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
#else
"#version 430 core\n"
#endif
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Position;\n"
"in vec2 TexCoord;\n"
"in float Distance;\n"
"\n"
"void main()\n"
"{\n"
"	FragColor = vec4(vec3(1.0f - 0.0f), 1.0f);\n"
"}\n";


struct CGL_trail
{
	CGL_trail_point points[CGL_TRAIL_MAX_POINTS];
	CGL_trail_point* first;
	CGL_trail_point* last;
	CGL_shader* shader;
	CGL_mesh_gpu* mesh;
	CGL_mesh_cpu* mesh_cpu;
	void* user_data;
	CGL_trail_point_update_function trail_point_func;
	CGL_int point_count;
	CGL_int resolution;
	CGL_float min_points_distance;
	CGL_float max_length;
	CGL_float length;
};

CGL_int __CGL_trail_get_next_index(CGL_trail* trail)
{
	CGL_int index = -1;
	for (CGL_int i = 0; i < CGL_TRAIL_MAX_POINTS; i++)
	{
		if (trail->points[i].index == -1)
		{
			trail->points[i].distance = 0.0f;
			trail->points[i].next = NULL;
			trail->points[i].lifespan = 0.0f;
			index = i;
			break;
		}
	}
	return index;
}

CGL_trail* CGL_trail_create()
{
	CGL_trail* trail = (CGL_trail*)CGL_malloc(sizeof(CGL_trail));
	if (!trail) { CGL_log_internal("Trail: Failed to allocate memory"); return NULL; }
	for (CGL_int i = 0; i < CGL_TRAIL_MAX_POINTS; i++) trail->points[i].index = -1;
	trail->first = NULL;
	trail->last = NULL;
	trail->user_data = NULL;
	trail->trail_point_func = NULL;
	trail->point_count = 0;
	trail->min_points_distance = 0.0f;
	trail->max_length = 1000000000.0f;
	trail->length = 0.0f;
	trail->resolution = 3;
	trail->mesh = CGL_mesh_gpu_create();
	trail->mesh_cpu = CGL_mesh_cpu_create(1024, 1024);
	trail->shader = CGL_shader_create(__CGL_TRAIL_DEFAULT_VERTEX_SHADER, __CGL_TRAIL_DEFAULT_FRAGMENT_SHADER, NULL);
	return trail;
}

CGL_void CGL_trail_destroy(CGL_trail* trail)
{
	CGL_mesh_cpu_destroy(trail->mesh_cpu);
	CGL_mesh_gpu_destroy(trail->mesh);
	CGL_shader_destroy(trail->shader);
	CGL_free(trail);
}

CGL_void CGL_trail_render(CGL_trail* trail, CGL_mat4* view, CGL_mat4* projection, CGL_shader* shader)
{
	if (!trail->mesh) return;
	if (!shader) { shader = trail->shader; CGL_shader_bind(shader); }
	CGL_shader_set_uniform_mat4(shader, CGL_shader_get_uniform_location(shader, "projection"), projection);
	CGL_shader_set_uniform_mat4(shader, CGL_shader_get_uniform_location(shader, "view"), view);
	CGL_shader_set_uniform_float(shader, CGL_shader_get_uniform_location(shader, "total_length"), trail->length);
	CGL_mesh_gpu_render(trail->mesh);
}

CGL_void CGL_trail_add_point(CGL_trail* trail, CGL_vec3 point, CGL_float lifespan, CGL_float thickness)
{
	if (trail->last)
	{
		CGL_float dist = sqrtf(powf(point.x - trail->last->position.x, 2) + powf(point.y - trail->last->position.y, 2) + powf(point.z - trail->last->position.z, 2));
		if (dist < trail->min_points_distance) return;
	}
	CGL_int index = __CGL_trail_get_next_index(trail);
	if (index == -1) { CGL_log_internal("Trail: Failed to add point, trail is full"); return; }
	CGL_trail_point* new_point = &trail->points[index];
	new_point->position = point;
	new_point->lifespan = lifespan;
	new_point->thickness = thickness;
	new_point->distance = 0.0f;
	new_point->user_data = NULL;
	new_point->index = index;
	new_point->next = trail->first;
	trail->first = new_point;
	trail->last = new_point;
	trail->point_count++;
	CGL_trail_calculate_distances(trail);
}

CGL_void CGL_trail_calculate_distances(CGL_trail* trail)
{
	CGL_trail_point* point = trail->first;
	CGL_trail_point* previous = NULL;
	CGL_float distance = 0.0f;
	while (point)
	{
		if (previous) { distance += sqrtf(powf(point->position.x - previous->position.x, 2) + powf(point->position.y - previous->position.y, 2) + powf(point->position.z - previous->position.z, 2)); }
		point->distance = distance;
		previous = point;
		point = point->next;
	}
	trail->length = distance;
}

CGL_void CGL_trail_set_resolution(CGL_trail* trail, CGL_int resolution)
{
	trail->resolution = resolution; // to be implemented in the future
}

CGL_void CGL_trail_update(CGL_trail* trail, CGL_float delta_time)
{
	CGL_trail_point* point = trail->first;
	CGL_trail_point* previous = NULL;
	CGL_bool remove = false;
	while (point)
	{
		remove = false;
		point->lifespan -= delta_time;
		if (trail->trail_point_func) remove = trail->trail_point_func(trail, point);
		if (point->lifespan <= 0.0f || remove || point->distance > trail->max_length)
		{
			if (previous) previous->next = point->next;
			else trail->first = point->next;
			point->index = -1;
			trail->point_count--;
			point = point->next;
		}
		if (!point) break;
		previous = point;
		point = point->next;
	}
}

CGL_void CGL_trail_bake_mesh(CGL_trail* trail)
{
	if (trail->point_count < 2) return;
	CGL_mesh_cpu* mesh = trail->mesh_cpu;

	if ((CGL_int)mesh->index_count < trail->point_count * trail->resolution * 6 || (CGL_int)mesh->vertex_count < trail->point_count * trail->resolution * 6)
	{
		CGL_sizei vct = mesh->vertex_count;
		CGL_sizei ict = mesh->index_count;
		CGL_mesh_cpu_destroy(mesh);
		mesh = CGL_mesh_cpu_create(
			CGL_utils_max(trail->point_count * trail->resolution * 6, (CGL_int)vct),
			CGL_utils_max(trail->point_count * trail->resolution * 6, (CGL_int)ict));
		trail->mesh_cpu = mesh;
	}
	mesh->vertex_count_used = mesh->index_count_used = 0;

	CGL_vec3 rt, tp, front, a0, a1, b0, b1, tmp0, tmp1;
	CGL_float angle0, angle1, angle_step = 360.0f / trail->resolution;
	CGL_trail_point* point = trail->first;
	while (point->next)
	{
		front = CGL_vec3_sub(point->next->position, point->position);
		CGL_vec3_normalize(front);
		if (front.x != 0.0f) rt = CGL_vec3_init(-front.y / front.x, 1.0f, 0.0f);
		else if (front.y != 0.0f) rt = CGL_vec3_init(0.0f, -front.z / front.y, 1.0f);
		else rt = CGL_vec3_init(1.0f, 0.0f, -front.x / front.z);
		tp = CGL_vec3_cross(front, rt);
		CGL_vec3_normalize(rt);
		CGL_vec3_normalize(tp);
		for (CGL_int i = 0; i < trail->resolution; i++)
		{
			angle0 = angle_step * i;
			CGL_float c0 = cosf(angle0) * point->thickness; CGL_float s0 = sinf(angle0) * point->thickness;
			a0 = CGL_vec3_scale(rt, s0);
			tmp0 = CGL_vec3_scale(tp, c0);
			a0 = CGL_vec3_add(a0, tmp0);
			a1 = CGL_vec3_add(a0, point->next->position);
			a0 = CGL_vec3_add(a0, point->position);


			angle1 = angle_step * ((i + 1) % trail->resolution);
			CGL_float c1 = cosf(angle1) * point->thickness; CGL_float s1 = sinf(angle1) * point->thickness;
			b0 = CGL_vec3_scale(rt, s1);
			tmp1 = CGL_vec3_scale(tp, c1);
			b0 = CGL_vec3_add(b0, tmp1);
			b1 = CGL_vec3_add(b0, point->next->position);
			b0 = CGL_vec3_add(b0, point->position);

			//CGL_mesh_cpu_add_quad(mesh, a0, b0, b1, a1);

			// triangle 1
			mesh->vertices[mesh->vertex_count_used + 0].position = CGL_vec4_init(a0.x, a0.y, a0.z, point->lifespan);
			mesh->vertices[mesh->vertex_count_used + 0].normal = CGL_vec4_init(a0.x, a0.y, a0.z, point->distance);

			mesh->vertices[mesh->vertex_count_used + 1].position = CGL_vec4_init(b0.x, b0.y, b0.z, point->lifespan);
			mesh->vertices[mesh->vertex_count_used + 1].normal = CGL_vec4_init(b0.x, b0.y, b0.z, point->distance);

			mesh->vertices[mesh->vertex_count_used + 2].position = CGL_vec4_init(b1.x, b1.y, b1.z, point->lifespan);
			mesh->vertices[mesh->vertex_count_used + 2].normal = CGL_vec4_init(b1.x, b1.y, b1.z, point->distance);

			// triangle 2
			mesh->vertices[mesh->vertex_count_used + 3].position = CGL_vec4_init(a0.x, a0.y, a0.z, point->lifespan);
			mesh->vertices[mesh->vertex_count_used + 3].normal = CGL_vec4_init(a0.x, a0.y, a0.z, point->distance);

			mesh->vertices[mesh->vertex_count_used + 4].position = CGL_vec4_init(b1.x, b1.y, b1.z, point->lifespan);
			mesh->vertices[mesh->vertex_count_used + 4].normal = CGL_vec4_init(b1.x, b1.y, b1.z, point->distance);

			mesh->vertices[mesh->vertex_count_used + 5].position = CGL_vec4_init(a1.x, a1.y, a1.z, point->lifespan);
			mesh->vertices[mesh->vertex_count_used + 5].normal = CGL_vec4_init(a1.x, a1.y, a1.z, point->distance);

			mesh->vertex_count_used += 6;
			mesh->index_count_used += 6;
		}

		point = point->next;
	}


	CGL_mesh_gpu_upload(trail->mesh, mesh, false);
}

CGL_void CGL_trail_clear(CGL_trail* trail)
{
	for (CGL_int i = 0; i < CGL_TRAIL_MAX_POINTS; i++) trail->points[i].index = -1;
	trail->first = NULL;
	trail->last = NULL;
	trail->point_count = 0;
}

CGL_void CGL_trail_set_point_update_function(CGL_trail* trail, CGL_trail_point_update_function function)
{
	trail->trail_point_func = function;
}

CGL_mesh_gpu* CGL_trail_get_mesh_gpu(CGL_trail* trail)
{
	return trail->mesh;
}

CGL_trail_point* CGL_trail_get_first_point(CGL_trail* trail)
{
	return trail->first;
}

CGL_void CGL_trail_set_user_data(CGL_trail* trail, void* user_data)
{
	trail->user_data = user_data;
}

CGL_void* CGL_trail_get_user_data(CGL_trail* trail)
{
	return trail->user_data;
}

CGL_float CGL_trail_get_length(CGL_trail* trail)
{
	return trail->length;
}

CGL_void CGL_trail_set_max_length(CGL_trail* trail, CGL_float length)
{
	trail->max_length = length;
}

CGL_void CGL_trail_set_min_points_distance(CGL_trail* trail, CGL_float min_points_distance)
{
	trail->min_points_distance = min_points_distance;
}

#endif



#ifndef CGL_EXCLUDE_NOISE_API


// ---------------- PERLIN ----------------
// From: https://mrl.cs.nyu.edu/~perlin/noise/



static CGL_int __CGL_NOISE_PERLIN_PERMUTATION_TABLE[512] = {
	151,160,137,91,90,15, 131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
	190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,
	20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,
	230,220,105,92,41,55,46,245,40,244,102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,
	18,169,200,196, 135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,5,
	202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,
	248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9, 129,22,39,253, 19,98,108,110,79,113,
	224,232,178,185, 112,104,218,246,97,228, 251,34,242,193,238,210,144,12,191,179,162,241, 81,51,
	145,235,249,14,239,107,49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
	138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,
	// Repeat
		151,160,137,91,90,15, 131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
		190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,
		20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,
		230,220,105,92,41,55,46,245,40,244,102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,
		18,169,200,196, 135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,5,
		202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,
		248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9, 129,22,39,253, 19,98,108,110,79,113,
		224,232,178,185, 112,104,218,246,97,228, 251,34,242,193,238,210,144,12,191,179,162,241, 81,51,
		145,235,249,14,239,107,49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
		138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,
};

static CGL_noise_data_type __CGL_noise_perlin_fade(CGL_noise_data_type t) { return t * t * t * (t * (t * 6 - 15) + 10); }
static CGL_noise_data_type __CGL_noise_perlin_lerp(CGL_noise_data_type t, CGL_noise_data_type a, CGL_noise_data_type b) { return a + t * (b - a); }
static CGL_noise_data_type __CGL_noise_perlin_grad(CGL_int hash, CGL_noise_data_type x, CGL_noise_data_type y, CGL_noise_data_type z)
{
	// convert lo 4 bits of hash code into 12 gradient directions
	CGL_int h = hash % 15;
	CGL_noise_data_type u = (h < 8 ? x : y), v = (h < 4 ? y : h == 12 || h == 14 ? x : z);
	return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);
}

CGL_noise_data_type CGL_noise_perlin(CGL_noise_data_type x, CGL_noise_data_type y, CGL_noise_data_type z)
{
	// find unit cube that contains the point
	CGL_int X = (CGL_int)floor(x) & 255, Y = (CGL_int)floor(y) & 255, Z = (CGL_int)floor(z) & 255;
	// find the relative x, y, z cordinates of the point in the cube
	x -= (CGL_noise_data_type)floor(x); y -= (CGL_noise_data_type)floor(y); z -= (CGL_noise_data_type)floor(z);
	// compute the fade curves for each of x, y, z
	CGL_noise_data_type u = __CGL_noise_perlin_fade(x), v = __CGL_noise_perlin_fade(y), w = __CGL_noise_perlin_fade(z);
	// hash coordinates of the 8 cube corners
	CGL_int A = __CGL_NOISE_PERLIN_PERMUTATION_TABLE[X] + Y, B = __CGL_NOISE_PERLIN_PERMUTATION_TABLE[X + 1] + Y, AA = __CGL_NOISE_PERLIN_PERMUTATION_TABLE[A] + Z,
		BA = __CGL_NOISE_PERLIN_PERMUTATION_TABLE[B] + Z, AB = __CGL_NOISE_PERLIN_PERMUTATION_TABLE[A + 1] + Z, BB = __CGL_NOISE_PERLIN_PERMUTATION_TABLE[B + 1] + Z;
	static CGL_noise_data_type tmp0, tmp1, tmp2, tmp3;
	tmp0 = __CGL_noise_perlin_lerp(u, __CGL_noise_perlin_grad(__CGL_NOISE_PERLIN_PERMUTATION_TABLE[AA], x, y, z), __CGL_noise_perlin_grad(__CGL_NOISE_PERLIN_PERMUTATION_TABLE[BA], x - 1, y, z));
	tmp1 = __CGL_noise_perlin_lerp(u, __CGL_noise_perlin_grad(__CGL_NOISE_PERLIN_PERMUTATION_TABLE[AB], x, y - 1, z), __CGL_noise_perlin_grad(__CGL_NOISE_PERLIN_PERMUTATION_TABLE[BB], x - 1, y - 1, z));
	tmp2 = __CGL_noise_perlin_lerp(u, __CGL_noise_perlin_grad(__CGL_NOISE_PERLIN_PERMUTATION_TABLE[AA + 1], x, y, z - 1), __CGL_noise_perlin_grad(__CGL_NOISE_PERLIN_PERMUTATION_TABLE[BA + 1], x - 1, y, z - 1));
	tmp3 = __CGL_noise_perlin_lerp(u, __CGL_noise_perlin_grad(__CGL_NOISE_PERLIN_PERMUTATION_TABLE[AB + 1], x, y - 1, z - 1), __CGL_noise_perlin_grad(__CGL_NOISE_PERLIN_PERMUTATION_TABLE[BB + 1], x - 1, y - 1, z - 1));
	return __CGL_noise_perlin_lerp(w, __CGL_noise_perlin_lerp(v, tmp0, tmp1), __CGL_noise_perlin_lerp(v, tmp2, tmp3));
}

// ---------------- PERLIN ----------------

// ---------------- OPENSIMPLEX ----------------
CGL_noise_data_type CGL_noise_opensimplex(CGL_noise_data_type x, CGL_noise_data_type y, CGL_noise_data_type z)
{
	// This is redirected to CGL_noise_opensimplex2s
	return CGL_noise_opensimplex2s(x, y, z);
}

// ---------------- OPENSIMPLEX ----------------

// ---------------- OPENSIMPLEX2S ----------------
// I have not implemented this
// This implementation is taken from : https://github.com/Auburn/FastNoiseLite/blob/master/C/FastNoiseLite.h
// Liscence to the above linked file : https://github.com/Auburn/FastNoiseLite/blob/master/LICENSE  (MIT)

#define CGL_NOISE_OPENSIMPLEX2_PRIME_X 501125321
#define CGL_NOISE_OPENSIMPLEX2_PRIME_Y 1136930381
#define CGL_NOISE_OPENSIMPLEX2_PRIME_Z 1720413743

static const CGL_float __CGL_NOISE_OPENSIMPLEX2_GRADIENTS_3D[] =
{
	0, 1, 1, 0,  0,-1, 1, 0,  0, 1,-1, 0,  0,-1,-1, 0,
	1, 0, 1, 0, -1, 0, 1, 0,  1, 0,-1, 0, -1, 0,-1, 0,
	1, 1, 0, 0, -1, 1, 0, 0,  1,-1, 0, 0, -1,-1, 0, 0,
	0, 1, 1, 0,  0,-1, 1, 0,  0, 1,-1, 0,  0,-1,-1, 0,
	1, 0, 1, 0, -1, 0, 1, 0,  1, 0,-1, 0, -1, 0,-1, 0,
	1, 1, 0, 0, -1, 1, 0, 0,  1,-1, 0, 0, -1,-1, 0, 0,
	0, 1, 1, 0,  0,-1, 1, 0,  0, 1,-1, 0,  0,-1,-1, 0,
	1, 0, 1, 0, -1, 0, 1, 0,  1, 0,-1, 0, -1, 0,-1, 0,
	1, 1, 0, 0, -1, 1, 0, 0,  1,-1, 0, 0, -1,-1, 0, 0,
	0, 1, 1, 0,  0,-1, 1, 0,  0, 1,-1, 0,  0,-1,-1, 0,
	1, 0, 1, 0, -1, 0, 1, 0,  1, 0,-1, 0, -1, 0,-1, 0,
	1, 1, 0, 0, -1, 1, 0, 0,  1,-1, 0, 0, -1,-1, 0, 0,
	0, 1, 1, 0,  0,-1, 1, 0,  0, 1,-1, 0,  0,-1,-1, 0,
	1, 0, 1, 0, -1, 0, 1, 0,  1, 0,-1, 0, -1, 0,-1, 0,
	1, 1, 0, 0, -1, 1, 0, 0,  1,-1, 0, 0, -1,-1, 0, 0,
	1, 1, 0, 0,  0,-1, 1, 0, -1, 1, 0, 0,  0,-1,-1, 0
};

static CGL_int __CGL_noise_opensimplex2_hash3d(CGL_int seed, CGL_int xPrimed, CGL_int yPrimed, CGL_int zPrimed)
{
	CGL_int hash = seed ^ xPrimed ^ yPrimed ^ zPrimed;
	hash *= 0x27d4eb2d;
	return hash;
}

static CGL_float __CGL_noise_opensimplex2_grad_coor3d(CGL_int seed, CGL_int xPrimed, CGL_int yPrimed, CGL_int zPrimed, CGL_float xd, CGL_float yd, CGL_float zd)
{
	CGL_int hash = __CGL_noise_opensimplex2_hash3d(seed, xPrimed, yPrimed, zPrimed);
	hash ^= hash >> 15; hash &= 63 << 2;
	return xd * __CGL_NOISE_OPENSIMPLEX2_GRADIENTS_3D[hash] + yd * __CGL_NOISE_OPENSIMPLEX2_GRADIENTS_3D[hash | 1] + zd * __CGL_NOISE_OPENSIMPLEX2_GRADIENTS_3D[hash | 2];
}



CGL_noise_data_type CGL_noise_opensimplex2s(CGL_noise_data_type x, CGL_noise_data_type y, CGL_noise_data_type z)
{
	CGL_int i = (CGL_int)floor(x), j = (CGL_int)floor(y), k = (CGL_int)floor(z);
	static CGL_int PRIME_X = CGL_NOISE_OPENSIMPLEX2_PRIME_X, PRIME_Y = CGL_NOISE_OPENSIMPLEX2_PRIME_Y, PRIME_Z = CGL_NOISE_OPENSIMPLEX2_PRIME_Z, seed = 42;

	CGL_noise_data_type xi = (CGL_noise_data_type)(x - i), yi = (CGL_noise_data_type)(y - j), zi = (CGL_noise_data_type)(z - k);

	i *= PRIME_X; j *= PRIME_Y; k *= PRIME_Z;
	CGL_int seed2 = seed + 1293373;

	CGL_int xNMask = (CGL_int)(-0.5 - xi);
	CGL_int yNMask = (CGL_int)(-0.5 - yi);
	CGL_int zNMask = (CGL_int)(-0.5 - zi);

	CGL_noise_data_type x0 = xi + xNMask, y0 = yi + yNMask, z0 = zi + zNMask;
	CGL_noise_data_type a0 = 0.75f - x0 * x0 - y0 * y0 - z0 * z0;
	CGL_noise_data_type value = (a0 * a0) * (a0 * a0) * __CGL_noise_opensimplex2_grad_coor3d(seed, i + (xNMask & PRIME_X), j + (yNMask & PRIME_Y), k + (zNMask & PRIME_Z), x0, y0, z0);

	CGL_noise_data_type x1 = xi - 0.5f, y1 = yi - 0.5f, z1 = zi - 0.5f;
	CGL_noise_data_type a1 = 0.75f - x1 * x1 - y1 * y1 - z1 * z1;
	value += (a1 * a1) * (a1 * a1) * __CGL_noise_opensimplex2_grad_coor3d(seed2, i + PRIME_X, j + PRIME_Y, k + PRIME_Z, x1, y1, z1);

	CGL_noise_data_type xAFlipMask0 = ((xNMask | 1) << 1) * x1;
	CGL_noise_data_type yAFlipMask0 = ((yNMask | 1) << 1) * y1;
	CGL_noise_data_type zAFlipMask0 = ((zNMask | 1) << 1) * z1;
	CGL_noise_data_type xAFlipMask1 = (-2 - (xNMask << 2)) * x1 - 1.0f;
	CGL_noise_data_type yAFlipMask1 = (-2 - (yNMask << 2)) * y1 - 1.0f;
	CGL_noise_data_type zAFlipMask1 = (-2 - (zNMask << 2)) * z1 - 1.0f;

	bool skip5 = false;
	CGL_noise_data_type a2 = xAFlipMask0 + a0;
	if (a2 > 0)
	{
		CGL_noise_data_type x2 = x0 - (xNMask | 1), y2 = y0, z2 = z0;
		value += (a2 * a2) * (a2 * a2) * __CGL_noise_opensimplex2_grad_coor3d(seed, i + (~xNMask & PRIME_X), j + (yNMask & PRIME_Y), k + (zNMask & PRIME_Z), x2, y2, z2);
	}
	else
	{
		CGL_noise_data_type a3 = yAFlipMask0 + zAFlipMask0 + a0;
		if (a3 > 0)
		{
			CGL_noise_data_type x3 = x0, y3 = y0 - (yNMask | 1), z3 = z0 - (zNMask | 1);
			value += (a3 * a3) * (a3 * a3) * __CGL_noise_opensimplex2_grad_coor3d(seed, i + (xNMask & PRIME_X), j + (~yNMask & PRIME_Y), k + (~zNMask & PRIME_Z), x3, y3, z3);
		}

		CGL_noise_data_type a4 = xAFlipMask1 + a1;
		if (a4 > 0)
		{
			CGL_noise_data_type x4 = (xNMask | 1) + x1, y4 = y1, z4 = z1;
			value += (a4 * a4) * (a4 * a4) * __CGL_noise_opensimplex2_grad_coor3d(seed2, i + (xNMask & (PRIME_X * 2)), j + PRIME_Y, k + PRIME_Z, x4, y4, z4);
			skip5 = true;
		}
	}

	bool skip9 = false;
	CGL_noise_data_type a6 = yAFlipMask0 + a0;
	if (a6 > 0)
	{
		CGL_noise_data_type x6 = x0, y6 = y0 - (yNMask | 1), z6 = z0;
		value += (a6 * a6) * (a6 * a6) * __CGL_noise_opensimplex2_grad_coor3d(seed, i + (xNMask & PRIME_X), j + (~yNMask & PRIME_Y), k + (zNMask & PRIME_Z), x6, y6, z6);
	}
	else
	{
		CGL_noise_data_type a7 = xAFlipMask0 + zAFlipMask0 + a0;
		if (a7 > 0)
		{
			CGL_noise_data_type x7 = x0 - (xNMask | 1), y7 = y0, z7 = z0 - (zNMask | 1);
			value += (a7 * a7) * (a7 * a7) * __CGL_noise_opensimplex2_grad_coor3d(seed, i + (~xNMask & PRIME_X), j + (yNMask & PRIME_Y), k + (~zNMask & PRIME_Z), x7, y7, z7);
		}

		CGL_noise_data_type a8 = yAFlipMask1 + a1;
		if (a8 > 0)
		{
			CGL_noise_data_type x8 = x1, y8 = (yNMask | 1) + y1, z8 = z1;
			value += (a8 * a8) * (a8 * a8) * __CGL_noise_opensimplex2_grad_coor3d(seed2, i + PRIME_X, j + (yNMask & (PRIME_Y << 1)), k + PRIME_Z, x8, y8, z8);
			skip9 = true;
		}
	}

	bool skipD = false;
	CGL_noise_data_type aA = zAFlipMask0 + a0;
	if (aA > 0)
	{
		CGL_noise_data_type xA = x0, yA = y0, zA = z0 - (zNMask | 1);
		value += (aA * aA) * (aA * aA) * __CGL_noise_opensimplex2_grad_coor3d(seed, i + (xNMask & PRIME_X), j + (yNMask & PRIME_Y), k + (~zNMask & PRIME_Z), xA, yA, zA);
	}
	else
	{
		CGL_noise_data_type aB = xAFlipMask0 + yAFlipMask0 + a0;
		if (aB > 0)
		{
			CGL_noise_data_type xB = x0 - (xNMask | 1), yB = y0 - (yNMask | 1), zB = z0;
			value += (aB * aB) * (aB * aB) * __CGL_noise_opensimplex2_grad_coor3d(seed, i + (~xNMask & PRIME_X), j + (~yNMask & PRIME_Y), k + (zNMask & PRIME_Z), xB, yB, zB);
		}

		CGL_noise_data_type aC = zAFlipMask1 + a1;
		if (aC > 0)
		{
			CGL_noise_data_type xC = x1, yC = y1, zC = (zNMask | 1) + z1;
			value += (aC * aC) * (aC * aC) * __CGL_noise_opensimplex2_grad_coor3d(seed2, i + PRIME_X, j + PRIME_Y, k + (zNMask & (PRIME_Z << 1)), xC, yC, zC);
			skipD = true;
		}
	}

	if (!skip5)
	{
		CGL_noise_data_type a5 = yAFlipMask1 + zAFlipMask1 + a1;
		if (a5 > 0)
		{
			CGL_noise_data_type x5 = x1, y5 = (yNMask | 1) + y1, z5 = (zNMask | 1) + z1;
			value += (a5 * a5) * (a5 * a5) * __CGL_noise_opensimplex2_grad_coor3d(seed2, i + PRIME_X, j + (yNMask & (PRIME_Y << 1)), k + (zNMask & (PRIME_Z << 1)), x5, y5, z5);
		}
	}

	if (!skip9)
	{
		CGL_noise_data_type a9 = xAFlipMask1 + zAFlipMask1 + a1;
		if (a9 > 0)
		{
			CGL_noise_data_type x9 = (xNMask | 1) + x1, y9 = y1, z9 = (zNMask | 1) + z1;
			value += (a9 * a9) * (a9 * a9) * __CGL_noise_opensimplex2_grad_coor3d(seed2, i + (xNMask & (PRIME_X * 2)), j + PRIME_Y, k + (zNMask & (PRIME_Z << 1)), x9, y9, z9);
		}
	}

	if (!skipD)
	{
		CGL_noise_data_type aD = xAFlipMask1 + yAFlipMask1 + a1;
		if (aD > 0)
		{
			CGL_noise_data_type xD = (xNMask | 1) + x1, yD = (yNMask | 1) + y1, zD = z1;
			value += (aD * aD) * (aD * aD) * __CGL_noise_opensimplex2_grad_coor3d(seed2, i + (xNMask & (PRIME_X << 1)), j + (yNMask & (PRIME_Y << 1)), k + PRIME_Z, xD, yD, zD);
		}
	}

	return value * 9.046026385208288f;
}

// ---------------- OPENSIMPLEX2S ----------------

// ---------------- VALUE  ----------------


#define CGL_NOISE_VALUE_LERP(t, a, b)  (a + t * (b - a))
#define CGL_NOISE_VALUE_SMOOTHSTEP(t)  (t * t * (3 - 2 * t))
#define CGL_NOISE_VALUE_SAMPLE_NOISE_VALUE(i, x, y, z)  { \
    __CGL_NOISE_VALUE_RAND_SEED = (x) * 73856093 ^ (y) * 19349663 ^ (z) * 83492791; \
    ns[i] = __CGL_noise_value_rand(); \
}

static CGL_int __CGL_NOISE_VALUE_RAND_SEED = 45;

static CGL_noise_data_type __CGL_noise_value_rand()
{
	__CGL_NOISE_VALUE_RAND_SEED = (214013 * __CGL_NOISE_VALUE_RAND_SEED + 2531011);
	return (CGL_noise_data_type)(((__CGL_NOISE_VALUE_RAND_SEED >> 16) & 0x7FFF) / 32767.0);
}

CGL_noise_data_type CGL_noise_value(CGL_noise_data_type x, CGL_noise_data_type y, CGL_noise_data_type z)
{
	static CGL_int X, Y, Z;
	static CGL_noise_data_type u, v, w, ns[8], tmp0, tmp1, tmp2, tmp3;
	X = (CGL_int)floor(x), Y = (CGL_int)floor(y), Z = (CGL_int)floor(z);
	u = x - (CGL_noise_data_type)X, v = y - (CGL_noise_data_type)Y, w = z - (CGL_noise_data_type)Z;
	u = CGL_NOISE_VALUE_SMOOTHSTEP(u), v = CGL_NOISE_VALUE_SMOOTHSTEP(v), w = CGL_NOISE_VALUE_SMOOTHSTEP(w);
	CGL_NOISE_VALUE_SAMPLE_NOISE_VALUE(0, X, Y, Z);
	CGL_NOISE_VALUE_SAMPLE_NOISE_VALUE(1, X + 1, Y, Z);
	CGL_NOISE_VALUE_SAMPLE_NOISE_VALUE(2, X, Y + 1, Z);
	CGL_NOISE_VALUE_SAMPLE_NOISE_VALUE(3, X + 1, Y + 1, Z);
	CGL_NOISE_VALUE_SAMPLE_NOISE_VALUE(4, X, Y, Z + 1);
	CGL_NOISE_VALUE_SAMPLE_NOISE_VALUE(5, X + 1, Y, Z + 1);
	CGL_NOISE_VALUE_SAMPLE_NOISE_VALUE(6, X, Y + 1, Z + 1);
	CGL_NOISE_VALUE_SAMPLE_NOISE_VALUE(7, X + 1, Y + 1, Z + 1);
	tmp0 = CGL_NOISE_VALUE_LERP(w, ns[0], ns[4]);
	tmp1 = CGL_NOISE_VALUE_LERP(w, ns[1], ns[5]);
	tmp2 = CGL_NOISE_VALUE_LERP(w, ns[2], ns[6]);
	tmp3 = CGL_NOISE_VALUE_LERP(w, ns[3], ns[7]);
	tmp0 = CGL_NOISE_VALUE_LERP(u, tmp0, tmp1);
	tmp1 = CGL_NOISE_VALUE_LERP(u, tmp2, tmp3);
	tmp0 = CGL_NOISE_VALUE_LERP(v, tmp0, tmp1);
	return tmp0;
}

// ---------------- VALUE  ----------------

// ---------------- VALUE CUBIC  ----------------

CGL_noise_data_type CGL_noise_valuecubic(CGL_noise_data_type x, CGL_noise_data_type y, CGL_noise_data_type z)
{
	// TODO: implement this
	//CGL_warn("CGL_noise_data_type CGL_noise_valuecubic(CGL_noise_data_type x, CGL_noise_data_type y, CGL_noise_data_type z) is not yet implemented! This call is being redirected to CGL_noise_data_type CGL_noise_value(CGL_noise_data_type x, CGL_noise_data_type y, CGL_noise_data_type z)");
	return CGL_noise_value(x, y, z);
}

// ---------------- VALUE CUBIC  ----------------

// ---------------- WORLEY  ----------------

static CGL_int __CGL_NOISE_WORLEY_RAND_SEED = 45;

static CGL_noise_data_type __CGL_noise_worley_rand()
{
	__CGL_NOISE_WORLEY_RAND_SEED = (214013 * __CGL_NOISE_WORLEY_RAND_SEED + 2531011);
	return (CGL_noise_data_type)(((__CGL_NOISE_WORLEY_RAND_SEED >> 16) & 0x7FFF) / 32767.0);
}

CGL_noise_data_type CGL_noise_worley(CGL_noise_data_type x, CGL_noise_data_type y, CGL_noise_data_type z)
{
	CGL_int X = (CGL_int)floor(x), Y = (CGL_int)floor(y), Z = (CGL_int)floor(z);
	//x -= (CGL_noise_data_type)floor(x); y -= (CGL_noise_data_type)floor(y); z -= (CGL_noise_data_type)floor(z);
	static CGL_noise_data_type vec[3], dist, /* max_dist = (CGL_noise_data_type)-1.0,*/ min_dist = (CGL_noise_data_type)10000000.0;
	/* max_dist = (CGL_noise_data_type)-1.0; */ min_dist = (CGL_noise_data_type)10000000.0;
	for (CGL_int i = -1; i <= 1; i++) for (CGL_int j = -1; j <= 1; j++) for (CGL_int k = -1; k <= 1; k++)
	{
		CGL_int sx = X + i, sy = Y + j, sz = Z + k;
		__CGL_NOISE_WORLEY_RAND_SEED = (sx * 73856093 ^ sy * 19349663 ^ sz * 83492791);
		vec[0] = __CGL_noise_worley_rand() + sx; vec[1] = __CGL_noise_worley_rand() + sy; vec[2] = __CGL_noise_worley_rand() + sz;
		dist = (CGL_noise_data_type)((vec[0] - x) * (vec[0] - x) + (vec[1] - y) * (vec[1] - y) + (vec[2] - z) * (vec[2] - z));
		/*if(dist > max_dist) max_dist = dist; */ if (dist < min_dist) min_dist = dist;
	}
	return (CGL_noise_data_type)sqrt(min_dist);
}
// ---------------- WORLEY  ----------------

CGL_void CGL_noise_params_default(CGL_noise_params* params)
{
	params->octaves = 3;
	params->fractal_type = CGL_NOISE_FRACTAL_TYPE_NONE;
	params->type = CGL_NOISE_TYPE_PERLIN;
	params->lacunarity = 2.0f;
	params->gain = 0.5f;
	params->frequency = 1.0f;
	params->weighted_strength = 0.0f;
	params->ping_pong_strength = 2.0f;
}

static void __CGL_noise_transform_coordinates(CGL_noise_params* params, CGL_noise_data_type* x, CGL_noise_data_type* y, CGL_noise_data_type* z)
{
	*x *= params->frequency; *y *= params->frequency; *z *= params->frequency;
	if (params->type == CGL_NOISE_TYPE_OPENSIMPLEX2S || params->type == CGL_NOISE_TYPE_OPENSIMPLEX)
	{
		const CGL_noise_data_type R3 = (CGL_noise_data_type)(2.0 / 3.0);
		CGL_noise_data_type r = (*x + *y + *z) * R3; // Rotation, not skew
		*x = r - *x; *y = r - *y; *z = r - *z;
	}
}

/*
static CGL_noise_data_type __CGL_pingpong(CGL_noise_data_type t)
{
	t -= (CGL_int)(t * 0.5) * 2;
	return t < 1 ? t : 2 - t;
}
*/

static CGL_noise_data_type __CGL_noise_calculate_fractal_bounding(CGL_noise_params* params)
{
	CGL_noise_data_type gain = (CGL_noise_data_type)fabs(params->gain);
	CGL_noise_data_type amp = gain, amp_fractal = (CGL_noise_data_type)1.0;
	for (CGL_int i = 1; i < params->octaves; i++)
	{
		amp_fractal += amp;
		amp *= gain;
	}
	return (CGL_noise_data_type)1.0 / amp_fractal;
}

static CGL_noise_data_type __CGL_noise_get_plain(CGL_noise_params* params, CGL_noise_data_type x, CGL_noise_data_type y, CGL_noise_data_type z)
{
	switch (params->type)
	{
	case CGL_NOISE_TYPE_PERLIN:
		return CGL_noise_perlin(x, y, z);
	case CGL_NOISE_TYPE_OPENSIMPLEX:
		return CGL_noise_opensimplex(x, y, z);
	case CGL_NOISE_TYPE_OPENSIMPLEX2S:
		return CGL_noise_opensimplex2s(x, y, z);
	case CGL_NOISE_TYPE_VALUE:
		return CGL_noise_value(x, y, z);
	case CGL_NOISE_TYPE_VALUECUBIC:
		return CGL_noise_valuecubic(x, y, z);
	case CGL_NOISE_TYPE_WORLEY:
		return CGL_noise_worley(x, y, z);
	default:
		return 0.0f;
	};
	//    return (CGL_noise_data_type)0.0;
}


static CGL_noise_data_type __CGL_noise_get_fbm(CGL_noise_params* params, CGL_noise_data_type x, CGL_noise_data_type y, CGL_noise_data_type z)
{
	CGL_noise_data_type sum = 0.0f, amp = __CGL_noise_calculate_fractal_bounding(params), noise_val;
	for (CGL_int i = 0; i < params->octaves; i++)
	{
		noise_val = __CGL_noise_get_plain(params, x, y, z);
		sum += noise_val * amp;
		amp *= (CGL_noise_data_type)CGL_utils_lerp(1.0, (CGL_noise_data_type)(CGL_utils_min(noise_val + 1.0, 2.0) * 0.5), params->weighted_strength);
		x *= params->lacunarity; y *= params->lacunarity; z *= params->lacunarity;
		amp *= params->gain;
	}
	return sum;
}

static CGL_noise_data_type __CGL_noise_get_billow(CGL_noise_params* params, CGL_noise_data_type x, CGL_noise_data_type y, CGL_noise_data_type z)
{
	CGL_noise_data_type sum = 0.0f, amp = __CGL_noise_calculate_fractal_bounding(params), noise_val;
	for (CGL_int i = 0; i < params->octaves; i++)
	{
		noise_val = __CGL_noise_get_plain(params, x, y, z);
		sum += (CGL_noise_data_type)(fabs(noise_val) * 2.0 - 1.0) * amp;
		amp *= (CGL_noise_data_type)CGL_utils_lerp(1.0, (CGL_noise_data_type)(CGL_utils_min(noise_val + 1.0, 2.0) * 0.5), params->weighted_strength);
		x *= params->lacunarity; y *= params->lacunarity; z *= params->lacunarity;
		amp *= params->gain;
	}
	return sum;
}

static CGL_noise_data_type __CGL_noise_get_riged(CGL_noise_params* params, CGL_noise_data_type x, CGL_noise_data_type y, CGL_noise_data_type z)
{
	CGL_noise_data_type sum = 0.0f, amp = __CGL_noise_calculate_fractal_bounding(params), noise_val;
	for (CGL_int i = 0; i < params->octaves; i++)
	{
		noise_val = (CGL_noise_data_type)fabs(__CGL_noise_get_plain(params, x, y, z));
		sum += (CGL_noise_data_type)(noise_val * -2.0 + 1.0) * amp;
		amp *= (CGL_noise_data_type)CGL_utils_lerp(1.0, 1.0 - noise_val, params->weighted_strength);
		x *= params->lacunarity; y *= params->lacunarity; z *= params->lacunarity;
		amp *= params->gain;
	}
	return sum;
}

static CGL_noise_data_type __CGL_noise_get_pingpong(CGL_noise_params* params, CGL_noise_data_type x, CGL_noise_data_type y, CGL_noise_data_type z)
{
	CGL_noise_data_type sum = 0.0f, amp = __CGL_noise_calculate_fractal_bounding(params), noise_val;
	for (CGL_int i = 0; i < params->octaves; i++)
	{
		noise_val = (CGL_noise_data_type)fabs(__CGL_noise_get_plain(params, x, y, z));
		sum += (CGL_noise_data_type)((noise_val - 0.5) * 2.0) * amp;
		amp *= (CGL_noise_data_type)CGL_utils_lerp(1.0, noise_val, params->weighted_strength);
		x *= params->lacunarity; y *= params->lacunarity; z *= params->lacunarity;
		amp *= params->gain;
	}
	return sum;
}

CGL_noise_data_type CGL_noise_get(CGL_noise_params* params, CGL_noise_data_type x, CGL_noise_data_type y, CGL_noise_data_type z)
{
	__CGL_noise_transform_coordinates(params, &x, &y, &z);
	switch (params->fractal_type)
	{
	case CGL_NOISE_FRACTAL_TYPE_NONE: return __CGL_noise_get_plain(params, x, y, z);
	case CGL_NOISE_FRACTAL_TYPE_FBM: return __CGL_noise_get_fbm(params, x, y, z);
	case CGL_NOISE_FRACTAL_TYPE_BILLOW: return __CGL_noise_get_billow(params, x, y, z);
	case CGL_NOISE_FRACTAL_TYPE_RIGID: return __CGL_noise_get_riged(params, x, y, z);
	case CGL_NOISE_FRACTAL_TYPE_PINGPONG: return __CGL_noise_get_pingpong(params, x, y, z);
	default: return 0.0f;
	}
}


CGL_void CGL_noise_init()
{
}

CGL_void CGL_noise_shutdown()
{

}


#endif


#ifndef CGL_EXCLUDE_AI_API

struct CGL_simple_neural_network_layer
{
	CGL_float* weights;
	CGL_float* activations;
	CGL_float* errors;
	CGL_simple_neural_network_activation_function activation_function;
	CGL_simple_neural_network_activation_function activation_function_derivative;
	CGL_int input_count;
	CGL_int output_count;
	CGL_int weight_count;
};

struct CGL_simple_neural_network
{
	CGL_simple_neural_network_layer* layers;
	CGL_int layer_count;
};


CGL_simple_neural_network* CGL_simple_neural_network_create(CGL_int* layer_sizes, CGL_int layer_count)
{
	CGL_simple_neural_network* network = (CGL_simple_neural_network*)CGL_malloc(sizeof(CGL_simple_neural_network));
	network->layer_count = layer_count;
	network->layers = (CGL_simple_neural_network_layer*)CGL_malloc(sizeof(CGL_simple_neural_network_layer) * layer_count);
	for (CGL_int i = 0; i < layer_count; i++)
	{
		CGL_simple_neural_network_layer* layer = network->layers + i;
		layer->activation_function = CGL_utils_sigmoid;
		layer->activation_function_derivative = CGL_utils_sigmoid_derivative;
		layer->input_count = i > 0 ? layer_sizes[i - 1] : 0;
		layer->output_count = layer_sizes[i];
		layer->weight_count = (layer->input_count + 1) * layer->output_count;
		layer->weights = (CGL_float*)CGL_malloc(sizeof(CGL_float) * layer->weight_count);
		layer->activations = (CGL_float*)CGL_malloc(sizeof(CGL_float) * (layer->output_count + 1));
		layer->errors = (CGL_float*)CGL_malloc(sizeof(CGL_float) * (layer->output_count + 1));
	}
	return network;
}

static CGL_sizei __CGL_simple_neural_network_calculate_serialized_size(CGL_simple_neural_network* network)
{
	CGL_sizei size = 0;
	for (CGL_int i = 0; i < network->layer_count; i++)
		size += sizeof(CGL_int) + sizeof(CGL_float) * network->layers[i].weight_count;
	return size;
}

CGL_byte* CGL_simple_neural_network_serialize_weights(CGL_simple_neural_network* network, CGL_sizei* size_out)
{
	CGL_sizei size = __CGL_simple_neural_network_calculate_serialized_size(network); // calculate size of serialized data
	CGL_byte* data = (CGL_byte*)CGL_malloc(size); // allocate memory for serialized data
	if (!data) return NULL; // if allocation failed, return NULL
	CGL_byte* ptr = data; // pointer to current position in serialized data
	for (CGL_int i = 0; i < network->layer_count; i++) // for each layer
	{
		CGL_simple_neural_network_layer* layer = network->layers + i; // get layer
		memcpy(ptr, &layer->weight_count, sizeof(CGL_int)); // copy weight count
		ptr += sizeof(CGL_int); // move pointer
		memcpy(ptr, layer->weights, sizeof(CGL_float) * layer->weight_count); // copy weights
		ptr += sizeof(CGL_float) * layer->weight_count; // move pointer
	}
	if (size_out) *size_out = size; // if size_out is not NULL, set it to size of serialized data
	return data; // return serialized data
}

CGL_bool CGL_simple_neural_network_deserialize_weights(CGL_simple_neural_network* network, CGL_byte* data)
{
	if (!data) return false; // if data is NULL, return false
	CGL_byte* ptr = data; // pointer to current position in serialized data
	for (CGL_int i = 0; i < network->layer_count; i++) // for each layer
	{
		CGL_simple_neural_network_layer* layer = network->layers + i; // get layer
		CGL_int weight_count; // weight count
		memcpy(&weight_count, ptr, sizeof(CGL_int)); // copy weight count
		ptr += sizeof(CGL_int); // move pointer
		if (weight_count != layer->weight_count) return false; // if weight count does not match, return false
		memcpy(layer->weights, ptr, sizeof(CGL_float) * layer->weight_count); // copy weights
		ptr += sizeof(CGL_float) * layer->weight_count; // move pointer
	}
	return true; // return true
}

CGL_void CGL_simple_neural_network_set_layer_activation_function(CGL_simple_neural_network* network, CGL_int layer_index, CGL_simple_neural_network_activation_function activation_function, CGL_simple_neural_network_activation_function activation_function_derivative)
{
	network->layers[layer_index].activation_function = activation_function; // set activation function
	network->layers[layer_index].activation_function_derivative = activation_function_derivative; // set activation function derivative
}

CGL_void CGL_simple_neural_network_randomize_weights(CGL_simple_neural_network* network, CGL_float min_v, CGL_float max_v)
{
	for (CGL_int i = 0; i < network->layer_count; i++)
		for (CGL_int j = 0; j < network->layers[i].weight_count; j++)
			network->layers[i].weights[j] = CGL_utils_random_float_in_range(min_v, max_v);
}

CGL_void CGL_simple_neural_network_destroy(CGL_simple_neural_network* network)
{
	for (CGL_int i = 0; i < network->layer_count; i++)
	{
		CGL_simple_neural_network_layer* layer = network->layers + i;
		CGL_free(layer->weights);
		CGL_free(layer->activations);
		CGL_free(layer->errors);
	}
	CGL_free(network->layers);
	CGL_free(network);
}

CGL_void CGL_simple_neural_network_evaluate(CGL_simple_neural_network* network, CGL_float* input, CGL_float* output)
{
	CGL_simple_neural_network_layer* layer_pr = network->layers; // layer 0
	CGL_simple_neural_network_layer* layer_cr = layer_pr + 1; // layer 1
	memcpy(layer_pr->activations, input, sizeof(CGL_float) * layer_pr->output_count); // copy input to layer 0
	layer_pr->activations[layer_pr->output_count] = 1.0f; // bias
	for (CGL_int i = 1; i < network->layer_count; i++)
	{
		for (CGL_int j = 0; j < layer_cr->output_count; j++)
		{
			CGL_float sum = 0.0f;
			for (CGL_int k = 0; k < layer_pr->output_count + 1; k++)
				sum += layer_pr->activations[k] * layer_cr->weights[k * layer_cr->output_count + j];
			layer_cr->activations[j] = layer_cr->activation_function(sum);
		}
		layer_cr->activations[layer_cr->output_count] = 1.0f; // bias
		layer_pr = layer_cr; layer_cr++;
	}
	if (output) memcpy(output, layer_pr->activations, sizeof(CGL_float) * layer_pr->output_count);
}

CGL_void CGL_simple_neural_network_train(CGL_simple_neural_network* a, CGL_float* input, CGL_float* output, CGL_float learning_rate)
{
	CGL_simple_neural_network_evaluate(a, input, NULL); // evaluate network for prediced output
	CGL_simple_neural_network_layer* layer_pr = a->layers + a->layer_count - 1; // layer 0
	CGL_simple_neural_network_layer* layer_cr = layer_pr - 1; // layer 1
	// calculate errors for the last layer
	for (CGL_int i = 0; i < layer_pr->output_count; i++) 
		layer_pr->errors[i] = (output[i] - layer_pr->activations[i]) * layer_pr->activation_function_derivative(layer_pr->activations[i]);
	// calculate (propagate) errors for the rest of the layers
	for (CGL_int i = a->layer_count - 2; i >= 0; i--) // loop through layers n-1 to 0
	{
		for (CGL_int j = 0; j < layer_cr->output_count; j++) // loop through neurons in current layer
		{
			// error[j] = sum(error[k] * weight[j][k]) * derivative(activation[j])
			CGL_float sum = 0.0f; // accumulator for sum
			for (CGL_int k = 0; k < layer_pr->output_count; k++)
				sum += layer_pr->errors[k] * layer_pr->weights[j * layer_pr->output_count + k];  // accumulate sum
			layer_cr->errors[j] = sum * layer_cr->activation_function_derivative(layer_cr->activations[j]); // calculte error for the neuron
		}
		layer_pr = layer_cr; layer_cr--; // update layer pointers
	}
	layer_pr = a->layers; // layer 0
	layer_cr = layer_pr + 1; // layer 1
	// update weights with respect to respective errors of neurons and layers
	for (CGL_int i = 1; i < a->layer_count; i++)
	{
		for (CGL_int j = 0; j < layer_cr->output_count; j++)
		{
			for (CGL_int k = 0; k < layer_pr->output_count + 1; k++)
				layer_cr->weights[k * layer_cr->output_count + j] += learning_rate * layer_pr->activations[k] * layer_cr->errors[j];
		}
		layer_pr = layer_cr; layer_cr++;
	}
}

CGL_void CGL_simple_neural_network_copy_weights(CGL_simple_neural_network* a, CGL_simple_neural_network* b)
{
	for (CGL_int i = 0; i < a->layer_count; i++) memcpy(a->layers[i].weights, b->layers[i].weights, sizeof(CGL_float) * a->layers[i].weight_count);
}

CGL_void CGL_simple_neural_network_mutate(CGL_simple_neural_network* a, CGL_float mutation_ratio)
{
	for (CGL_int i = 0; i < a->layer_count; i++) for (CGL_int j = 0; j < a->layers[i].weight_count; j++) if (CGL_utils_random_float_in_range(0.0f, 1.0f) < mutation_ratio) a->layers[i].weights[j] += CGL_utils_random_gaussian(0.0f, 0.1f);
}


struct CGL_linear_regression_context
{
	CGL_matrix* coefficents;
	CGL_matrix* input;
	CGL_float* input_data;
	CGL_matrix* evaluate_temp0;
	CGL_matrix* train_temp0;
	CGL_int input_count;
};

CGL_linear_regression_context* CGL_linear_regression_context_create(CGL_int input_count_)
{
	CGL_linear_regression_context* context = (CGL_linear_regression_context*)CGL_malloc(sizeof(CGL_linear_regression_context));
	context->input_count = input_count_;
	context->coefficents = CGL_matrix_create(1, input_count_ + 1);
	context->input = CGL_matrix_create(input_count_ + 1, 1);
	context->evaluate_temp0 = CGL_matrix_create(1, 1);
	context->train_temp0 = CGL_matrix_create(1, input_count_ + 1);
	context->input_data = (CGL_float*)CGL_malloc(sizeof(CGL_float) * (input_count_ + 1));
	return context;
}

CGL_void CGL_linear_regression_context_destroy(CGL_linear_regression_context* context)
{
	CGL_matrix_destroy(context->coefficents);
	CGL_matrix_destroy(context->input);
	CGL_matrix_destroy(context->evaluate_temp0);
	CGL_matrix_destroy(context->train_temp0);
	CGL_free(context->input_data);
	CGL_free(context);
}

CGL_void CGL_linear_regression_randomize_coefficents(CGL_linear_regression_context* context, CGL_float min_v, CGL_float max_v)
{
	for (CGL_int i = 0; i < context->input_count + 1; i++) CGL_matrix_set_elem(context->coefficents, 0, i, CGL_utils_random_float_in_range(min_v, max_v));
}

CGL_float CGL_linear_regression_evaluate(CGL_linear_regression_context* context, CGL_float* input, CGL_float* output)
{
	memcpy(context->input_data, input, sizeof(CGL_float) * context->input_count);
	context->input_data[context->input_count] = 1.0f;
	CGL_matrix_set_col(context->input, 0, context->input_data);
	CGL_matrix_mul_to(context->coefficents, context->input, context->evaluate_temp0);
	if (output) *output = CGL_matrix_get_elem(context->evaluate_temp0, 0, 0);
	return CGL_matrix_get_elem(context->evaluate_temp0, 0, 0);
}

CGL_bool CGL_linear_regression_train(CGL_linear_regression_context* context, CGL_linear_regression_sample_function sample_function, void* user_data, CGL_int sample_count, CGL_float learning_rate, CGL_int max_iterations)
{
	CGL_float y_hat = 0.0f, error = 0.0f, factor = 0.0f;
	for (CGL_int i = 0; i < max_iterations; i++)
	{
		context->train_temp0 = CGL_matrix_make_zero(context->train_temp0);
		for (CGL_int k = 0; k < sample_count; k++)
		{
			y_hat = sample_function(user_data, context->input_data, &y_hat, k);
			CGL_matrix_set_col(context->input, 0, context->input_data);
			CGL_matrix_mul_to(context->coefficents, context->input, context->evaluate_temp0);
			error = CGL_matrix_get_elem(context->evaluate_temp0, 0, 0) - y_hat;
			for (CGL_int j = 0; j < context->input_count + 1; j++)
				CGL_matrix_set_elem(context->train_temp0, 0, j, CGL_matrix_get_elem(context->train_temp0, 0, j) + error * CGL_matrix_get_elem(context->input, j, 0));
		}
		factor = -learning_rate / (CGL_float)sample_count;
		CGL_matrix_scale_to(context->train_temp0, factor);
		CGL_matrix_add_to(context->coefficents, context->train_temp0, context->coefficents);
	}
	return CGL_TRUE;
}


#endif


#ifndef CGL_EXCLUDE_PATH_FINDING_API

struct CGL_path_finding_a_star_context
{
	CGL_path_finding_node* nodes;
	CGL_path_finding_node* start_node;
	CGL_path_finding_node* current_node;
	void* user_data;
	CGL_byte* nodes_data;
	CGL_int max_nodes_count;
	CGL_int nodes_count;
	CGL_int nodes_data_size;
	CGL_bool copy_data;
};

CGL_void CGL_path_finding_node_init(CGL_path_finding_node* node, void* data_ptr)
{
	node->data_ptr = data_ptr;
	node->id = node->parent_id = node->child_id = -1;
	node->is_open = CGL_FALSE;
	node->is_active = CGL_FALSE;
	node->g = node->h = node->f = 0.0f;
}

CGL_path_finding_a_star_context* CGL_path_finding_a_star_context_create(CGL_int max_nodes_count, CGL_bool copy_data, CGL_int data_size)
{
	CGL_path_finding_a_star_context* context = (CGL_path_finding_a_star_context*)CGL_malloc(sizeof(CGL_path_finding_a_star_context));
	context->nodes = (CGL_path_finding_node*)CGL_malloc(sizeof(CGL_path_finding_node) * max_nodes_count);
	if (copy_data) context->nodes_data = (CGL_byte*)CGL_malloc(CGL_utils_max(data_size, 1) * max_nodes_count); else context->nodes_data = NULL;
	context->max_nodes_count = max_nodes_count;
	context->nodes_count = 0;
	context->nodes_data_size = data_size;
	context->copy_data = copy_data;
	context->start_node = NULL;
	context->user_data = NULL;
	for (CGL_int i = 0; i < max_nodes_count; i++) context->nodes[i].data_ptr = context->nodes_data + i * context->nodes_data_size;
	return context;
}

static CGL_int __CGL_path_finding_a_star_find_node(CGL_path_finding_a_star_context* context, CGL_path_finding_node* node, CGL_path_finding_node_equals_function node_equals_function)
{
	CGL_path_finding_node* nodes = context->nodes;
	for (CGL_int i = 0; i < context->max_nodes_count; i++) if (nodes[i].is_active) if (node_equals_function(context->user_data, &nodes[i], node)) return i;
	return -1;
}

static CGL_int __CGL_path_finding_a_star_add_node(CGL_path_finding_a_star_context* context, CGL_path_finding_node* node, CGL_path_finding_node_equals_function node_equals_function)
{
	node->id = __CGL_path_finding_a_star_find_node(context, node, node_equals_function); if (node->id != -1) return node->id;
	CGL_path_finding_node* nodes = context->nodes;
	if (context->nodes_count >= context->max_nodes_count) return -1;
	//for(CGL_int i = 0 ; i < context->max_nodes_count ; i++) if(!nodes[i].is_active) // find inactive node
	CGL_int i = context->nodes_count;
	{
		node->id = i; nodes[i] = *node;
		if (context->copy_data) nodes[i].data_ptr = context->nodes_data + i * context->nodes_data_size;
		nodes[i].is_active = true;
		if (context->copy_data) memcpy(context->nodes_data + i * context->nodes_data_size, node->data_ptr, context->nodes_data_size);
		//CGL_int *data = (CGL_int*)(context->nodes_data + i * context->nodes_data_size);
		context->nodes_count++;
		return node->id;
	}
	// return -1;
}

static CGL_int __CGL_path_finding_a_star_find_node_with_lowest_f(CGL_path_finding_a_star_context* context)
{
	CGL_path_finding_node* nodes = context->nodes;
	CGL_int lowest_f_node = -1;
	CGL_float lowest_f_v = 0.0f;
	for (CGL_int i = 0; i < context->max_nodes_count; i++) if (nodes[i].is_active && nodes[i].is_open && (lowest_f_node == -1 || nodes[i].f <= lowest_f_v)) { lowest_f_node = i; lowest_f_v = nodes[i].f; }
	// CGL_int *data = (CGL_int*)nodes[lowest_f_node].data_ptr;
	nodes[lowest_f_node].is_open = false;
	return lowest_f_node;
}

/*
// for debug
static void __CGL_path_finding_a_star_print_nodes(CGL_path_finding_a_star_context* context)
{
	CGL_path_finding_node* nodes = context->nodes;
	printf("Nodes [ ");
	for (CGL_int i = 0; i < context->nodes_count; i++)
	{
		CGL_int* dat = (CGL_int*)nodes[i].data_ptr;
		printf("{ (%d -> %d %d) (%d %d) -> %f %s} ", i, nodes[i].parent_id, nodes[i].child_id, *dat % 10, *dat / 10, nodes[i].f, nodes[i].is_open ? "open" : "closed");
	}
	printf("]\n");
}
*/

static void __CGL_path_finding_a_star_calculate_gfh(CGL_path_finding_a_star_context* context, CGL_int node, CGL_int parent_node, CGL_path_finding_heuristic_function heuristic_function, CGL_path_finding_cost_function cost_function, CGL_int node_count_old)
{
	//context->nodes[node].h = heuristic_function(context->user_data, &context->nodes[node]);
	CGL_float total_cost = context->nodes[parent_node].g + cost_function(context->user_data, &context->nodes[parent_node], &context->nodes[node]);
	if (node_count_old <= node)
	{
		context->nodes[node].g = total_cost;
		context->nodes[node].h = heuristic_function(context->user_data, &context->nodes[node]);
		context->nodes[node].is_open = true;
		context->nodes[node].parent_id = parent_node;
	}
	else if (total_cost <= context->nodes[node].g)
	{
		context->nodes[node].g = total_cost;
		context->nodes[node].parent_id = parent_node;
		context->nodes[node].is_open = true;
	}
	context->nodes[node].f = context->nodes[node].g + context->nodes[node].h;
}

CGL_int __CGL_path_finding_a_star_get_open_node_count(CGL_path_finding_a_star_context* context)
{
	CGL_int count = 0;
	for (CGL_int i = 0; i < context->max_nodes_count; i++) if (context->nodes[i].is_active && context->nodes[i].is_open) count++;
	return count;
}

CGL_int CGL_path_finding_a_star_add_node(CGL_path_finding_a_star_context* context, CGL_path_finding_node node, CGL_path_finding_node_equals_function node_equals_function)
{
	return __CGL_path_finding_a_star_add_node(context, &node, node_equals_function);
}


// the actual a* algorithm
CGL_bool CGL_path_finding_a_star_find_path(CGL_path_finding_a_star_context* context, CGL_path_finding_node start_node_n, CGL_path_finding_node end_node_n, CGL_path_finding_heuristic_function heuristic_function, CGL_path_finding_cost_function cost_function, CGL_path_finding_get_neighbors_function get_neighbors_function, CGL_path_finding_node_equals_function node_equals_function, void* user_data)
{
	CGL_path_finding_a_star_clear_path(context); // clear previous path
	CGL_path_finding_node* nodes = context->nodes; // shorthand
	CGL_int start_node = __CGL_path_finding_a_star_add_node(context, &start_node_n, node_equals_function); // add start node
	context->start_node = &context->nodes[start_node]; // update context variable
	context->user_data = user_data; // update context variable
	if (start_node == -1) return CGL_FALSE; // if initial couldn't be added, return
	CGL_int current_node = start_node;  // current node is start node
	CGL_int neighbors[CGL_PATH_FINDING_A_STAR_MAX_NEIGHBOURS], neighbour_count = 0; // array of storing neighbors
	CGL_int epochs = 0, node_count_old = 0; // epochs is used to prevent infinite loops
	while (__CGL_path_finding_a_star_get_open_node_count(context) > 0 && epochs <= 100 * context->max_nodes_count) // while there are open nodes
	{
		epochs++; current_node = __CGL_path_finding_a_star_find_node_with_lowest_f(context); // find node with lowest f
		if (node_equals_function(context->user_data, &nodes[current_node], &end_node_n)) // if current node is end node
		{
			// reorder path
			while (current_node != start_node)
			{
				CGL_int tmp = current_node;
				current_node = nodes[current_node].parent_id;
				nodes[current_node].child_id = tmp;
			}
			CGL_path_finding_a_star_reorder_path(context); // set transversal cursor to start node
			return true; // path found successfully
		}
		nodes[current_node].is_open = false; node_count_old = context->nodes_count; // close current node
		neighbour_count = get_neighbors_function(context->user_data, &nodes[current_node], neighbors); // get neighbors
		for (CGL_int j = 0; j < neighbour_count; j++) if (neighbors[j] != -1) // for each valid neighbor
		{
			context->nodes[neighbors[j]].is_open = false; // close neighbor (will be opened if needed)
			__CGL_path_finding_a_star_calculate_gfh(context, neighbors[j], current_node, heuristic_function, cost_function, node_count_old); // calculate g, h and f for neighbor
		}
	}
	return false; // path not found
}

CGL_float CGL_path_finding_a_star_get_path_length(CGL_path_finding_a_star_context* context)
{
	if (context->start_node == NULL) return 0.0f;
	CGL_path_finding_node* node = context->start_node;
	CGL_float length_v = 0.0f;
	while (node->child_id != -1)
	{
		length_v += node->g;
		node = &context->nodes[node->child_id];
	}
	return length_v;
}

CGL_path_finding_node* CGL_path_finding_a_star_get_path_start_node(CGL_path_finding_a_star_context* context)
{
	return context->start_node;
}

CGL_bool CGL_path_finding_a_star_has_path(CGL_path_finding_a_star_context* context)
{
	return context->start_node != NULL;
}

CGL_void CGL_path_finding_a_star_reorder_path(CGL_path_finding_a_star_context* context)
{
	context->current_node = context->start_node;
}

CGL_void* CGL_path_finding_a_star_next_in_path(CGL_path_finding_a_star_context* context, void* data_out)
{
	if (context->current_node == NULL) return NULL;
	CGL_path_finding_node* cn_copy = context->current_node;
	if (context->current_node->child_id == -1) context->current_node = NULL;
	else context->current_node = &context->nodes[context->current_node->child_id];
	if (cn_copy && data_out) memcpy(data_out, cn_copy->data_ptr, context->nodes_data_size);
	return cn_copy;
}
CGL_void CGL_path_finding_a_star_clear_path(CGL_path_finding_a_star_context* context)
{
	context->start_node = NULL;
	context->current_node = NULL;
	for (CGL_int i = 0; i < context->max_nodes_count; i++)
	{
		context->nodes[i].is_open = CGL_FALSE;
		context->nodes[i].is_active = CGL_FALSE;
		context->nodes[i].parent_id = context->nodes[i].child_id = -1;
		context->nodes[i].g = context->nodes[i].h = context->nodes[i].f = 0.0f;
	}
	if (context->copy_data) memset(context->nodes_data, 0, context->nodes_data_size * context->max_nodes_count);
	context->nodes_count = 0;
}

CGL_void CGL_path_finding_a_star_context_destroy(CGL_path_finding_a_star_context* context)
{
	CGL_free(context->nodes);
	if (context->copy_data) CGL_free(context->nodes_data);
	CGL_free(context);
}

#endif


#ifndef CGL_EXCLUDE_CSV_API

struct CGL_csv
{
	CGL_sizei item_max_size;
	CGL_sizei column_count;
	CGL_sizei row_count;
	CGL_list* parser_list;
	CGL_byte* item_buffer;
	CGL_list* columns;
};

CGL_csv* CGL_csv_create(CGL_sizei item_max_size)
{
	CGL_csv* csv = CGL_malloc(sizeof(CGL_csv));
	if (csv == NULL) return NULL;
	csv->item_buffer = CGL_malloc(item_max_size + 100);
	if (csv->item_buffer == NULL)
	{
		CGL_free(csv);
		return NULL;
	}
	csv->columns = CGL_list_create(sizeof(CGL_list*), 100);
	if (csv->columns == NULL)
	{
		CGL_free(csv->item_buffer);
		CGL_free(csv);
		return NULL;
	}
	csv->parser_list = CGL_list_create(item_max_size, 100);
	if (csv->parser_list == NULL)
	{
		CGL_list_destroy(csv->columns);
		CGL_free(csv->item_buffer);
		CGL_free(csv);
		return NULL;
	}
	csv->item_max_size = item_max_size;
	csv->column_count = 0;
	csv->row_count = 0;
	return csv;
}

CGL_void CGL_csv_destroy(CGL_csv* csv)
{
	CGL_sizei column_count = CGL_list_get_size(csv->columns);
	for (CGL_sizei i = 0; i < column_count; i++)
	{
		CGL_list* column = *(CGL_list**)CGL_list_get(csv->columns, i, NULL);
		CGL_list_destroy(column);
	}
	CGL_list_destroy(csv->columns);
	CGL_list_destroy(csv->parser_list);
	CGL_free(csv->item_buffer);
	CGL_free(csv);
}

#define __CGL_CSV_ERROR_AND_RETURN(...) \
{\
    CGL_log_internal(__VA_ARGS__); \
    return CGL_FALSE; \
}

CGL_bool CGL_csv_load_from_buffer(CGL_csv* csv, const CGL_byte* buffer, const CGL_byte* seperator)
{
	CGL_sizei seperator_length = strlen(seperator);
	CGL_sizei line_start_index = 0, current_index = 0, line_end_index = 0, line_number = 0, column_count = 0, prev_column_start = 0, seperator_count = 0, line_iterator = 0;
	while (buffer[current_index])
	{
		line_start_index = current_index;
		while (buffer[current_index] && (buffer[current_index] != '\n' && !(buffer[current_index] == '\r' && buffer[current_index + 1] == '\n'))) current_index++;
		line_end_index = current_index;
		if (buffer[current_index] == '\r' && buffer[current_index + 1] == '\n') current_index += 2; else current_index++;
		// fwrite(buffer + line_start_index, (line_end_index - line_start_index), 1, stdout);
		if (column_count != 0) if (line_end_index - line_start_index <= seperator_length * (column_count - 1))  __CGL_CSV_ERROR_AND_RETURN("CGL_csv_load_from_buffer: line %d is too short", line_number);
		if (line_end_index - line_start_index == 0) __CGL_CSV_ERROR_AND_RETURN("CGL_csv_load_from_buffer: line %d is empty", line_number);
		prev_column_start = line_start_index; seperator_count = 0;
		CGL_list_clear(csv->parser_list);
		for (line_iterator = line_start_index; line_iterator <= line_end_index - seperator_length; line_iterator++)
		{
			if (strncmp(buffer + line_iterator, seperator, seperator_length) == 0)
			{
				if (line_iterator - prev_column_start > csv->item_max_size) __CGL_CSV_ERROR_AND_RETURN("CGL_csv_load_from_buffer: item %d in line %d is too long", seperator_count, line_number);
				sprintf(csv->item_buffer, "%.*s ", (CGL_int)(line_iterator - prev_column_start), buffer + prev_column_start);
				CGL_list_push(csv->parser_list, csv->item_buffer);
				seperator_count++; line_iterator += seperator_length - 1; prev_column_start = line_iterator + 1;
			}
		}
		if (prev_column_start < line_end_index)
		{
			if (line_end_index - prev_column_start > csv->item_max_size) __CGL_CSV_ERROR_AND_RETURN("CGL_csv_load_from_buffer: item %d in line %d is too long", seperator_count, line_number);
			sprintf(csv->item_buffer, "%.*s ", (CGL_int)(line_end_index - prev_column_start), buffer + prev_column_start);
			CGL_list_push(csv->parser_list, csv->item_buffer);
		}
		if (line_number == 0) column_count = CGL_list_get_size(csv->parser_list);
		else if (CGL_list_get_size(csv->parser_list) != column_count) __CGL_CSV_ERROR_AND_RETURN("CGL_csv_load_from_buffer: line %d has %d columns, but %d columns are expected", line_number, CGL_list_get_size(csv->parser_list), column_count);
		if (line_number == 0) for (CGL_sizei i = 0; i < column_count; i++) CGL_csv_add_column(csv);
		CGL_csv_add_row(csv);
		for (CGL_sizei i = 0; i < column_count; i++)
		{
			CGL_list* column = *(CGL_list**)CGL_list_get(csv->columns, i, NULL);
			CGL_list_set(column, line_number, CGL_list_get(csv->parser_list, i, NULL));
		}
		line_number++;
	}
	return CGL_TRUE;
}

CGL_bool CGL_csv_load(CGL_csv* csv, const CGL_byte* file_path, const CGL_byte* seperator)
{
	CGL_byte* data = CGL_utils_read_file(file_path, NULL);
	if (data == NULL) return CGL_FALSE;
	CGL_bool result = CGL_csv_load_from_buffer(csv, data, seperator);
	CGL_free(data);
	return result;
}

CGL_bool CGL_csv_save_to_buffer(CGL_csv* csv, CGL_byte* buffer, const CGL_byte* seperator)
{
	buffer[0] = '\0';
	CGL_sizei column_count = CGL_list_get_size(csv->columns);
	// NOTE: I am not sure wether to return false here
	//       as this is technically not an error
	if (column_count == 0) return CGL_TRUE;
	CGL_list* first_column = *(CGL_list**)CGL_list_get(csv->columns, 0, NULL);
	CGL_sizei row_count = CGL_list_get_size(first_column);
	for (CGL_sizei i = 0; i < row_count; i++)
	{
		for (CGL_sizei j = 0; j < column_count; j++)
		{
			CGL_list* column = *(CGL_list**)CGL_list_get(csv->columns, j, NULL);
			if (j == column_count - 1) sprintf(csv->item_buffer, "%s%s", (CGL_byte*)CGL_list_get(column, i, NULL), CGL_NEWLINE);
			else sprintf(csv->item_buffer, "%s%s", (CGL_byte*)CGL_list_get(column, i, NULL), seperator);
			strcat(buffer, csv->item_buffer);
		}
	}
	return CGL_TRUE;
}

CGL_bool CGL_csv_save(CGL_csv* csv, const CGL_byte* file_path, const CGL_byte* separator)
{
	static CGL_byte save_buffer[1024 * 1024 * 16];
	CGL_bool result = CGL_csv_save_to_buffer(csv, save_buffer, separator);
	if (!result) return CGL_FALSE;
	CGL_utils_write_file(file_path, save_buffer, strlen(save_buffer));
	return CGL_TRUE;
}

CGL_bool CGL_csv_add_column(CGL_csv* csv)
{
	CGL_sizei prev_column_count = CGL_list_get_size(csv->columns);
	CGL_sizei row_count = 0;
	if (prev_column_count > 0)
	{
		CGL_list* column0 = *(CGL_list**)CGL_list_get(csv->columns, 0, NULL);
		row_count = CGL_list_get_size(column0);
	}
	CGL_list* column = CGL_list_create(csv->item_max_size, 100);
	if (column == NULL) return CGL_FALSE;
	csv->item_buffer[0] = '\0';
	for (CGL_sizei i = 0; i < row_count; i++) CGL_list_push(column, csv->item_buffer);
	CGL_list_push(csv->columns, &column);
	csv->column_count++;
	return CGL_TRUE;
}

CGL_bool CGL_csv_add_row(CGL_csv* csv)
{
	CGL_sizei column_count = CGL_list_get_size(csv->columns);
	csv->item_buffer[0] = '\0';
	for (CGL_sizei i = 0; i < column_count; i++)
	{
		CGL_list* column = *(CGL_list**)CGL_list_get(csv->columns, i, NULL);
		CGL_list_push(column, csv->item_buffer);
	}
	return CGL_TRUE;
}

CGL_byte* CGL_csv_set_item(CGL_csv* csv, CGL_int row, CGL_int column, const CGL_byte* item)
{
	CGL_list* column_ptr = *(CGL_list**)CGL_list_get(csv->columns, column, NULL);
	if (column_ptr == NULL) return NULL;
	sprintf(csv->item_buffer, "%s", item);
	CGL_list_set(column_ptr, row, csv->item_buffer);
	return CGL_list_get(column_ptr, row, NULL);
}

CGL_byte* CGL_csv_get_item(CGL_csv* csv, CGL_int row, CGL_int column, CGL_byte* item_out)
{
	CGL_list* column_ptr = *(CGL_list**)CGL_list_get(csv->columns, column, NULL);
	if (column_ptr == NULL) return CGL_FALSE;
	CGL_byte* item = (CGL_byte*)CGL_list_get(column_ptr, row, NULL);
	if (item == NULL) return CGL_FALSE;
	if (item_out) sprintf(item_out, "%s", item);
	return item;
}

CGL_bool CGL_csv_get_row(CGL_csv* csv, CGL_int row, CGL_byte* row_out)
{
	CGL_sizei column_count = CGL_list_get_size(csv->columns);
	for (CGL_sizei i = 0; i < column_count; i++)
	{
		CGL_list* column = *(CGL_list**)CGL_list_get(csv->columns, i, NULL);
		CGL_byte* item = (CGL_byte*)CGL_list_get(column, row, NULL);
		if (item == NULL) return CGL_FALSE;
		sprintf(row_out + (csv->item_max_size * i), "%s", item);
	}
	return CGL_TRUE;
}


CGL_bool CGL_csv_get_column(CGL_csv* csv, CGL_int column, CGL_byte* column_out)
{
	CGL_list* column_ptr = *(CGL_list**)CGL_list_get(csv->columns, column, NULL);
	if (column_ptr == NULL) return CGL_FALSE;
	CGL_sizei row_count = CGL_list_get_size(column_ptr);
	memcpy(column_out, column_ptr->data, row_count * csv->item_max_size);
	return CGL_TRUE;
}

CGL_int CGL_csv_get_row_count(CGL_csv* csv)
{
	CGL_sizei column_count = CGL_list_get_size(csv->columns);
	if (column_count == 0) return 0;
	CGL_list* column = *(CGL_list**)CGL_list_get(csv->columns, 0, NULL);
	CGL_sizei row_count = CGL_list_get_size(column);
	return (CGL_int)row_count;
}

CGL_int CGL_csv_get_column_count(CGL_csv* csv)
{
	return (CGL_int)CGL_list_get_size(csv->columns);
}

CGL_void CGL_csv_clear(CGL_csv* csv)
{
	CGL_sizei column_count = CGL_list_get_size(csv->columns);
	for (CGL_sizei i = 0; i < column_count; i++)
	{
		CGL_list* column = *(CGL_list**)CGL_list_get(csv->columns, i, NULL);
		CGL_list_destroy(column);
	}
	// while (CGL_list_get_size(csv->columns) > 0) CGL_list_pop(csv->columns, NULL);
	CGL_list_clear(csv->columns);
}


#endif

#ifndef CGL_EXCLUDE_IMAGE_FILE_API

CGL_bool CGL_image_file_is_png_f(FILE* file)
{
	static const CGL_ubyte png_signature[8] = { 137, 80, 78, 71, 13, 10, 26, 10 };
	for (CGL_int i = 0; i < 8; ++i)
	{
		CGL_ubyte byte = 0;
		if (fread(&byte, sizeof(CGL_ubyte), 1, file) != 1) return CGL_FALSE;
		if (byte != png_signature[i]) return CGL_FALSE;
	}
	fseek(file, 0, SEEK_SET);
	return CGL_TRUE;
}

CGL_bool CGL_image_file_is_png(const CGL_byte* file_path)
{
	FILE* file = fopen(file_path, "rb");
	if (file == NULL) return CGL_FALSE;
	CGL_bool result = CGL_image_file_is_png_f(file);
	fclose(file);
	return result;
}

CGL_bool CGL_image_file_is_bmp_f(FILE* file)
{
	CGL_byte d_i8 = 0;
	CGL_uint d_u32 = 0;
	if (fread(&d_i8, sizeof(CGL_byte), 1, file) != 1) return CGL_FALSE;
	if (d_i8 != 'B') return CGL_FALSE;
	if (fread(&d_i8, sizeof(CGL_byte), 1, file) != 1) return CGL_FALSE;
	if (d_i8 != 'M') return CGL_FALSE;
	if (fread(&d_u32, sizeof(CGL_uint), 1, file) != 1) return CGL_FALSE;  // file size
	if (fread(&d_u32, sizeof(CGL_uint), 1, file) != 1) return CGL_FALSE; // reserved
	if (fread(&d_u32, sizeof(CGL_uint), 1, file) != 1) return CGL_FALSE; // data offset
	if (fread(&d_u32, sizeof(CGL_uint), 1, file) != 1) return CGL_FALSE; // header size
	fseek(file, 0, SEEK_SET);
	return (d_u32 == 12 || d_u32 == 40 || d_u32 == 56 || d_u32 == 108 || d_u32 == 124);
}

CGL_bool CGL_image_file_is_bmp(const CGL_byte* file_path)
{
	FILE* file = fopen(file_path, "rb");
	if (file == NULL) return CGL_FALSE;
	CGL_bool result = CGL_image_file_is_bmp_f(file);
	fclose(file);
	return result;
}

CGL_bool CGL_image_file_is_gif_f(FILE* file)
{
	CGL_byte d_i8 = 0;
	if (fread(&d_i8, sizeof(CGL_byte), 1, file) != 1) return CGL_FALSE;
	if (d_i8 != 'G') return CGL_FALSE;
	if (fread(&d_i8, sizeof(CGL_byte), 1, file) != 1) return CGL_FALSE;
	if (d_i8 != 'I') return CGL_FALSE;
	if (fread(&d_i8, sizeof(CGL_byte), 1, file) != 1) return CGL_FALSE;
	if (d_i8 != 'F') return CGL_FALSE;
	if (fread(&d_i8, sizeof(CGL_byte), 1, file) != 1) return CGL_FALSE;
	if (d_i8 != '8') return CGL_FALSE;
	if (fread(&d_i8, sizeof(CGL_byte), 1, file) != 1) return CGL_FALSE;
	if (d_i8 != '7' && d_i8 != '9') return CGL_FALSE;
	if (fread(&d_i8, sizeof(CGL_byte), 1, file) != 1) return CGL_FALSE;
	if (d_i8 != 'a') return CGL_FALSE;
	fseek(file, 0, SEEK_SET);
	return CGL_TRUE;
}

CGL_bool CGL_image_file_is_gif(const CGL_byte* file_path)
{
	FILE* file = fopen(file_path, "rb");
	if (file == NULL) return CGL_FALSE;
	CGL_bool result = CGL_image_file_is_gif_f(file);
	fclose(file);
	return result;
}

CGL_bool CGL_image_file_is_jpeg_f(FILE* file)
{
	CGL_ubyte d_i8 = 0;
	if (fread(&d_i8, sizeof(CGL_byte), 1, file) != 1) return CGL_FALSE;
	if (d_i8 != 0xFF) return CGL_FALSE;
	if (fread(&d_i8, sizeof(CGL_byte), 1, file) != 1) return CGL_FALSE;
	if (d_i8 != 0xD8) return CGL_FALSE;
	fseek(file, 0, SEEK_SET);
	return CGL_TRUE;
}

CGL_bool CGL_image_file_is_jpeg(const CGL_byte* file_path)
{

	FILE* file = fopen(file_path, "rb");
	if (file == NULL) return CGL_FALSE;
	CGL_bool result = CGL_image_file_is_jpeg_f(file);
	fclose(file);
	return result;
}

CGL_int CGL_image_file_get_format_f(FILE* file)
{
	if (CGL_image_file_is_png_f(file)) return CGL_IMAGE_FORMAT_PNG;
	if (CGL_image_file_is_bmp_f(file)) return CGL_IMAGE_FORMAT_BMP;
	if (CGL_image_file_is_gif_f(file)) return CGL_IMAGE_FORMAT_GIF;
	if (CGL_image_file_is_jpeg_f(file)) return CGL_IMAGE_FORMAT_JPEG;
	return CGL_IMAGE_FORMAT_UNKNOWN;
}

CGL_int CGL_image_file_get_format(const CGL_byte* file_path)
{
	FILE* file = fopen(file_path, "rb");
	if (file == NULL) return CGL_FALSE;
	CGL_int result = CGL_image_file_get_format_f(file);
	fclose(file);
	return result;
}

#endif


#ifndef CGL_EXCLUDE_ND_TREE_API

struct CGL_nd_tree
{
	CGL_bool(*aabb_subdivide_function)(CGL_int, CGL_float*, CGL_float*, CGL_float*, CGL_float*);
	CGL_bool(*aabb_contains_point_function)(CGL_int, CGL_float*, CGL_float*, CGL_float*);
	CGL_bool(*aabb_intersects_aabb_function)(CGL_int, CGL_float*, CGL_float*, CGL_float*, CGL_float*);

	CGL_sizei* children_node_pointers;
	CGL_float* children_node_aabbs;
	CGL_nd_tree_node* nodes_bank;
	CGL_int nodes_bank_size;

	CGL_float* positions_bank;
	CGL_sizei positions_bank_size;

	CGL_void* memory_bank;
	CGL_sizei mem_bank_allocation_count;
	CGL_sizei max_mem_banks;
	CGL_sizei max_items_total;

	CGL_float* aabb_out_min_tmp;
	CGL_float* aabb_out_max_tmp;

	CGL_int max_items_per_node;
	CGL_int items_per_node;
	CGL_int bank_size_per_node;
	CGL_int dimension;
	CGL_bool fast_approx_check;
	CGL_sizei item_size;
	CGL_int max_depth;
};

struct CGL_nd_tree_node
{
	CGL_sizei banks[CGL_ND_TREE_MAX_MEMORY_BANKS_PER_NODE];
	CGL_int items_count;
	CGL_int max_capacity;
	CGL_int depth;
	CGL_float* aabb_min;
	CGL_float* aabb_max;
	CGL_sizei* children_nodes;
	CGL_bool has_been_subdivided;
};

CGL_nd_tree* CGL_nd_tree_create(CGL_int dimensions, CGL_sizei item_size, CGL_int max_items_per_node, CGL_sizei max_nodes, CGL_sizei max_items, CGL_bool store_positions)
{
	// the main tree object
	CGL_nd_tree* tree = (CGL_nd_tree*)CGL_malloc(sizeof(CGL_nd_tree));
	if (tree == NULL) return NULL;

	// copy the simple values
	tree->dimension = dimensions;
	tree->item_size = item_size;
	tree->max_items_total = max_items;

	tree->aabb_out_max_tmp = (CGL_float*)CGL_malloc(sizeof(CGL_float) * (CGL_long)(1 << dimensions) * dimensions);
	if (tree->aabb_out_max_tmp == NULL)
	{
		CGL_free(tree);
		return NULL;
	}

	tree->aabb_out_min_tmp = (CGL_float*)CGL_malloc(sizeof(CGL_float) * (CGL_long)(1 << dimensions) * dimensions);
	if (tree->aabb_out_min_tmp == NULL)
	{
		CGL_free(tree->aabb_out_max_tmp);
		CGL_free(tree);
		return NULL;
	}
	// the position bank stores the positions of the items
	// this is allocated and used only if the user wants to store the positions
	// NOTE: if this is not allocated, the tree will always use fast approximations
	tree->positions_bank = NULL;
	tree->positions_bank_size = 0;
	if (store_positions)
	{
		// preallocate the position bank with all possible particles
		tree->positions_bank = (CGL_float*)CGL_malloc(sizeof(CGL_float) * dimensions * max_items);
		if (tree->positions_bank == NULL)
		{
			CGL_free(tree->aabb_out_max_tmp);
			CGL_free(tree->aabb_out_min_tmp);
			CGL_free(tree);
			return NULL;
		}
	}

	// we choose the aabb subdivide function based on the dimensions
	// for 2d and 3d we use hard coded functions rather than special
	// algorithm as they are relatively simple to code and way faster
	if (dimensions == 2) tree->aabb_subdivide_function = CGL_aabb_subdivide_2d;
	else if (dimensions == 3) tree->aabb_subdivide_function = CGL_aabb_subdivide_3d; // 3d is not implemented yet
	else tree->aabb_subdivide_function = CGL_aabb_subdivide_nd;


	if (dimensions == 2) tree->aabb_contains_point_function = CGL_aabb_contains_point_2d;
	else if (dimensions == 3) tree->aabb_contains_point_function = CGL_aabb_contains_point_3d;
	else tree->aabb_contains_point_function = CGL_aabb_contains_point_nd;


	if (dimensions == 2) tree->aabb_intersects_aabb_function = CGL_aabb_intersects_aabb_2d;
	else if (dimensions == 3) tree->aabb_intersects_aabb_function = CGL_aabb_intersects_aabb_3d;
	else tree->aabb_intersects_aabb_function = CGL_aabb_intersects_aabb_nd;

	// allocate the nodes bank
	tree->nodes_bank = (CGL_nd_tree_node*)CGL_malloc(sizeof(CGL_nd_tree_node) * max_nodes);
	tree->nodes_bank_size = 0;
	if (tree->nodes_bank == NULL)
	{
		if (tree->positions_bank) CGL_free(tree->positions_bank);
		CGL_free(tree->aabb_out_max_tmp);
		CGL_free(tree->aabb_out_min_tmp);
		CGL_free(tree);
		return NULL;
	}

	tree->children_node_pointers = (CGL_sizei*)CGL_malloc(sizeof(CGL_sizei) * (CGL_long)(1 << dimensions) * max_nodes);
	if (tree->children_node_pointers == NULL)
	{
		if (tree->positions_bank) CGL_free(tree->positions_bank);
		CGL_free(tree->aabb_out_max_tmp);
		CGL_free(tree->aabb_out_min_tmp);
		CGL_free(tree->nodes_bank);
		CGL_free(tree);
	}

	tree->children_node_aabbs = (CGL_float*)CGL_malloc(sizeof(CGL_float) * dimensions * 2 * (CGL_long)(1 << dimensions) * max_nodes);
	if (tree->children_node_aabbs == NULL)
	{
		if (tree->positions_bank) CGL_free(tree->positions_bank);
		CGL_free(tree->aabb_out_max_tmp);
		CGL_free(tree->aabb_out_min_tmp);
		CGL_free(tree->nodes_bank);
		CGL_free(tree->children_node_pointers);
		CGL_free(tree);
	}

	// set the children node pointers
	for (CGL_sizei i = 0; i < max_nodes; i++)
	{
		tree->nodes_bank[i].children_nodes = tree->children_node_pointers + (1 << dimensions) * (CGL_int)i;
		tree->nodes_bank[i].aabb_min = tree->children_node_aabbs + dimensions * 2 * (1 << dimensions) * i;
		tree->nodes_bank[i].aabb_max = tree->nodes_bank[i].aabb_min + dimensions;
	}


	// allocate the memory bank
	// the memory bank will store the item banks
	// an item bank is a solid collection of min(10, max_items_per_node) items 
	tree->memory_bank = (CGL_void*)CGL_malloc((sizeof(CGL_sizei) + item_size) * max_items);
	tree->mem_bank_allocation_count = 0;
	if (tree->memory_bank == NULL)
	{
		if (tree->positions_bank) CGL_free(tree->positions_bank);
		CGL_free(tree->aabb_out_max_tmp);
		CGL_free(tree->aabb_out_min_tmp);
		CGL_free(tree->nodes_bank);
		CGL_free(tree->children_node_pointers);
		CGL_free(tree->children_node_aabbs);
		CGL_free(tree);
	}

	// calculate the size of the banks
	tree->bank_size_per_node = CGL_utils_min(CGL_ND_TREE_MAX_ITEMS_PER_MEMORY_BANK, max_items_per_node);
	tree->max_items_per_node = max_items_per_node;


	return tree;
}

CGL_nd_tree* CGL_quad_tree_create(CGL_sizei item_size, CGL_int max_items_per_node, CGL_sizei max_nodes, CGL_sizei max_items, CGL_bool store_positions)
{
	return CGL_nd_tree_create(2, item_size, max_items_per_node, max_nodes, max_items, store_positions);
}

CGL_nd_tree* CGL_oct_tree_create(CGL_sizei item_size, CGL_int max_items_per_node, CGL_sizei max_nodes, CGL_sizei max_items, CGL_bool store_positions)
{
	return CGL_nd_tree_create(3, item_size, max_items_per_node, max_nodes, max_items, store_positions);
}

CGL_void CGL_nd_tree_destroy(CGL_nd_tree* tree)
{
	if (tree == NULL) return;
	// free the positions bank
	if (tree->positions_bank) CGL_free(tree->positions_bank);
	// free tmp aabb_min and aabb_max 
	CGL_free(tree->aabb_out_min_tmp);
	CGL_free(tree->aabb_out_max_tmp);
	// free the nodes bank
	CGL_free(tree->nodes_bank);
	// free the children node pointers
	CGL_free(tree->children_node_pointers);
	// free the children node aabbs
	CGL_free(tree->children_node_aabbs);
	// free the memory bank
	CGL_free(tree->memory_bank);
	// free the tree
	CGL_free(tree);
}

CGL_sizei __CGL_nd_tree_add_node(CGL_nd_tree* tree, CGL_int parent_depth, CGL_float* aabb_min, CGL_float* aabb_max)
{
	// NOTE: we do not check here if the nodes bank is full
	//       as we assume that the user will do this sanely
	//       thus by that we can avoid a lot of checks per frame
	//       and make the code faster   
	CGL_nd_tree_node* node = &tree->nodes_bank[tree->nodes_bank_size++];
	node->max_capacity = 0;
	node->items_count = 0;
	node->depth = parent_depth + 1;
	node->has_been_subdivided = CGL_FALSE;

	if (aabb_min && aabb_max)
	{
		// copy the aabbs
		for (CGL_int i = 0; i < tree->dimension; i++)
		{
			node->aabb_min[i] = aabb_min[i];
			node->aabb_max[i] = aabb_max[i];
		}
	}

	return tree->nodes_bank_size - 1;
}

CGL_bool CGL_nd_tree_reset(CGL_nd_tree* tree, CGL_float* aabb_min, CGL_float* aabb_max, CGL_int items_per_node, CGL_int max_depth, CGL_bool fast_approx_mode)
{
	// reset the tree
	tree->positions_bank_size = 0;
	tree->nodes_bank_size = 0;
	tree->mem_bank_allocation_count = 0;
	tree->fast_approx_check = fast_approx_mode;
	tree->max_depth = max_depth;
	tree->items_per_node = items_per_node;
	tree->bank_size_per_node = CGL_utils_min(CGL_ND_TREE_MAX_ITEMS_PER_MEMORY_BANK, tree->max_items_per_node);
	tree->max_mem_banks = tree->max_items_total / tree->bank_size_per_node;

	// add the root node
	// parent depth is -1 as the root node has no parent
	__CGL_nd_tree_add_node(tree, -1, aabb_min, aabb_max);

	return CGL_TRUE;
}

CGL_bool CGL_quad_tree_reset(CGL_nd_tree* tree, CGL_float x_min, CGL_float y_min, CGL_float x_max, CGL_float y_max, CGL_int items_per_node, CGL_int max_depth, CGL_bool fast_approx_mode)
{
	CGL_float aabb_min[2] = { x_min, y_min };
	CGL_float aabb_max[2] = { x_max, y_max };
	return CGL_nd_tree_reset(tree, aabb_min, aabb_max, items_per_node, max_depth, fast_approx_mode);
}

CGL_bool CGL_oct_tree_reset(CGL_nd_tree* tree, CGL_float x_min, CGL_float y_min, CGL_float z_min, CGL_float x_max, CGL_float y_max, CGL_float z_max, CGL_int items_per_node, CGL_int max_depth, CGL_bool fast_approx_mode)
{
	CGL_float aabb_min[3] = { x_min, y_min, z_min };
	CGL_float aabb_max[3] = { x_max, y_max, z_max };
	return CGL_nd_tree_reset(tree, aabb_min, aabb_max, items_per_node, max_depth, fast_approx_mode);
}

CGL_bool __CGL_nd_tree_node_add_item(CGL_nd_tree* tree, CGL_nd_tree_node* node, CGL_sizei position_bank_index, CGL_void* item)
{
	// calculate some common values
	CGL_sizei current_bank_index = (node->items_count) / tree->bank_size_per_node;
	CGL_sizei current_bank_item_index = (node->items_count) % tree->bank_size_per_node;

	// check if the node has enough capacity
	if (node->items_count >= node->max_capacity)
	{
		// if new memory bank is not allowed then return false
		if (current_bank_index >= CGL_ND_TREE_MAX_MEMORY_BANKS_PER_NODE) return CGL_FALSE;
		// we need to allocate another memory bank for this node
		if (tree->mem_bank_allocation_count > tree->max_mem_banks) return CGL_FALSE;
		node->banks[current_bank_index] = (tree->mem_bank_allocation_count++) * (sizeof(CGL_sizei) + tree->item_size) * tree->bank_size_per_node;
		node->max_capacity += tree->bank_size_per_node;
	}

	if (current_bank_index >= CGL_ND_TREE_MAX_MEMORY_BANKS_PER_NODE) return CGL_FALSE;

	// get the memory pointers
	CGL_ubyte* memory_bank = (CGL_ubyte*)tree->memory_bank + node->banks[current_bank_index];
	CGL_ubyte* item_memory = memory_bank + current_bank_item_index * (sizeof(CGL_sizei) + tree->item_size);


	//  copy the values
	//((CGL_sizei*)item_memory)[0] = position_bank_index;
	*(CGL_sizei*)item_memory = position_bank_index;
	if (tree->item_size == 4) *(CGL_int*)((CGL_ubyte*)item_memory + sizeof(CGL_sizei)) = *(CGL_int*)item;
	else if (tree->item_size == 8) ((CGL_sizei*)item_memory)[1] = *(CGL_sizei*)item;
	else memcpy((CGL_ubyte*)item_memory + sizeof(CGL_sizei), item, tree->item_size);

	// update count
	node->items_count += 1;

	return CGL_TRUE;
}

CGL_bool __CGL_nd_tree_node_add(CGL_nd_tree* tree, CGL_sizei node_id, CGL_float* position, CGL_void* item, CGL_sizei position_bank_index, CGL_int depth)
{
	CGL_nd_tree_node* node = &tree->nodes_bank[node_id];
	// check if the item is inside the node or not
	// if (!tree->aabb_contains_point_function(tree->dimension, node->aabb_min, node->aabb_max, position)) return CGL_FALSE;

	// check if we are at the max depth
	if (depth == tree->max_depth)
	{
		// if we are at the max depth then we add the item to the node
		// no matter the node is full or not
		__CGL_nd_tree_node_add_item(tree, node, position_bank_index, item);
		return CGL_TRUE;
	}

	// check if the node is already full
	if (node->items_count >= tree->items_per_node)
	{
		// here we need to subdivide current node creating children nodes if it has not already been divided
		if (!node->has_been_subdivided)
		{
			// first calculate the aabb of children nodes of this node
			if (!tree->aabb_subdivide_function(tree->dimension, node->aabb_min, node->aabb_max, tree->aabb_out_min_tmp, tree->aabb_out_max_tmp)) return CGL_FALSE;

			// initialize the appropiate nodes
			for (CGL_int i = 0; i < (1 << tree->dimension); i++)
			{
				CGL_float* nd_aabb_min = tree->aabb_out_min_tmp + i * tree->dimension;
				CGL_float* nd_aabb_max = tree->aabb_out_max_tmp + i * tree->dimension;
				node->children_nodes[i] = __CGL_nd_tree_add_node(tree, node->depth, nd_aabb_min, nd_aabb_max);
			}

			node->has_been_subdivided = CGL_TRUE;
		}
		// add the point to the appropiate child node
		for (CGL_int i = 0; i < (1 << tree->dimension); i++)
		{
			CGL_nd_tree_node* child_node = &tree->nodes_bank[node->children_nodes[i]];
			if (tree->aabb_contains_point_function(tree->dimension, child_node->aabb_min, child_node->aabb_max, position))
				if (__CGL_nd_tree_node_add(tree, node->children_nodes[i], position, item, position_bank_index, depth + 1))
					return CGL_TRUE;
		}
	}
	else
	{
		// the node is not full so we add the item to the node
		return __CGL_nd_tree_node_add_item(tree, node, position_bank_index, item);
	}

	// this should never happen
	return CGL_FALSE;
}

CGL_bool CGL_nd_tree_add(CGL_nd_tree* tree, CGL_float* position, CGL_void* item)
{
	// this is allocated only if positions are to be stored
	if (tree->positions_bank)
	{
		if (tree->positions_bank_size >= tree->max_items_total) return CGL_FALSE;
		memcpy(tree->positions_bank + tree->positions_bank_size, position, sizeof(CGL_float) * tree->dimension);
		tree->positions_bank_size += tree->dimension;
	}
	if (tree->aabb_contains_point_function(tree->dimension, tree->nodes_bank[0].aabb_min, tree->nodes_bank[0].aabb_max, position))
		return __CGL_nd_tree_node_add(tree, 0, position, item, tree->positions_bank_size - tree->dimension, 0);
	return CGL_FALSE;
}

CGL_bool CGL_quad_tree_add(CGL_nd_tree* tree, CGL_float px, CGL_float py, CGL_void* item)
{
	CGL_float position[2] = { px, py };
	return CGL_nd_tree_add(tree, position, item);
}

CGL_bool CGL_oct_tree_add(CGL_nd_tree* tree, CGL_float px, CGL_float py, CGL_float pz, CGL_void* item)
{
	CGL_float position[3] = { px, py, pz };
	return CGL_nd_tree_add(tree, position, item);
}



CGL_int __CGL_nd_tree_node_get_items_in_range(CGL_nd_tree* tree, CGL_nd_tree_node* node, CGL_float* p_min, CGL_float* p_max, CGL_void* items_out, CGL_int max_items, CGL_int items_size)
{
	if (items_size >= max_items) return items_size;

	// if (!tree->aabb_intersects_aabb_function(tree->dimension, node->aabb_min, node->aabb_max, p_min, p_max)) return items_size;

	static CGL_sizei current_bank_index = 0;
	static CGL_sizei current_bank_item_index = 0;
	static CGL_sizei position_index = 0;
	static CGL_bool point_include_condition = 0;
	static CGL_ubyte* item = NULL;


	// first iterate through over the items in this node
	for (CGL_int i = 0; i < node->items_count; i++)
	{
		current_bank_index = i / tree->bank_size_per_node;
		current_bank_item_index = i % tree->bank_size_per_node;
		item = (CGL_ubyte*)tree->memory_bank + node->banks[current_bank_index] + current_bank_item_index * (sizeof(CGL_sizei) + tree->item_size);
		position_index = *(CGL_sizei*)item;
		point_include_condition = CGL_TRUE;
		if (tree->positions_bank != NULL && !tree->fast_approx_check) point_include_condition = tree->aabb_contains_point_function(tree->dimension, p_min, p_max, tree->positions_bank + position_index);
		if (point_include_condition) memcpy((CGL_ubyte*)items_out + (items_size++) * tree->item_size, item + sizeof(CGL_sizei), tree->item_size);
	}


	// if the node is not a leaf we iterate over its children
	if (node->has_been_subdivided)
	{
		for (CGL_int i = 0; i < (1 << tree->dimension); i++)
		{
			if (tree->aabb_intersects_aabb_function(tree->dimension, tree->nodes_bank[node->children_nodes[i]].aabb_min, tree->nodes_bank[node->children_nodes[i]].aabb_max, p_min, p_max))
				items_size = __CGL_nd_tree_node_get_items_in_range(tree, &tree->nodes_bank[node->children_nodes[i]], p_min, p_max, items_out, max_items, items_size);
		}
	}

	return items_size;
}

CGL_int CGL_nd_tree_get_items_in_range(CGL_nd_tree* tree, CGL_float* p_min, CGL_float* p_max, CGL_void* items_out, CGL_int max_items)
{
	if (tree->aabb_intersects_aabb_function(tree->dimension, tree->nodes_bank[0].aabb_min, tree->nodes_bank[0].aabb_max, p_min, p_max))
		return __CGL_nd_tree_node_get_items_in_range(tree, &tree->nodes_bank[0], p_min, p_max, items_out, max_items, 0);
	return 0;
}

CGL_int CGL_quad_tree_get_items_in_range(CGL_nd_tree* tree, CGL_float x_min, CGL_float y_min, CGL_float x_max, CGL_float y_max, CGL_void* items_out, CGL_int max_items)
{
	CGL_float p_min[2] = { x_min, y_min };
	CGL_float p_max[2] = { x_max, y_max };
	return CGL_nd_tree_get_items_in_range(tree, p_min, p_max, items_out, max_items);
}

CGL_int CGL_oct_tree_get_items_in_range(CGL_nd_tree* tree, CGL_float x_min, CGL_float y_min, CGL_float z_min, CGL_float x_max, CGL_float y_max, CGL_float z_max, CGL_void* items_out, CGL_int max_items)
{
	CGL_float p_min[3] = { x_min, y_min, z_min };
	CGL_float p_max[3] = { x_max, y_max, z_max };
	return CGL_nd_tree_get_items_in_range(tree, p_min, p_max, items_out, max_items);
}



#endif


#endif // CGL_IMPLEMENTATION

#endif // CGL_H 

```

`examples/c/2d_collision_detection.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_EXCLUDE_AUDIO
#define CGL_EXCLUDE_NETWORKING
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_IMPLEMENTATION
#include "cgl.h"

#ifdef CGL_WASM
#include <emscripten/emscripten.h>
#include <emscripten/html5.h>
#else 
#define EM_BOOL int
#endif

#define CGL_MAX_SHAPES 1000

struct {
    CGL_window* window;
    CGL_shape shapes[CGL_MAX_SHAPES];
    CGL_sizei shape_count;
    CGL_framebuffer* framebuffer;

    CGL_bool use_gjk;
    CGL_float last_time;
    CGL_float curr_time;
    CGL_float delta_time;
} g_State;

CGL_bool init() {
    srand((uint32_t)time(NULL));
    if(!CGL_init()) return CGL_FALSE;

    g_State.window = CGL_window_create(700, 700, "CGL 2D Collision Detection - Jaysmito Mukherjee");
    if(g_State.window == NULL) return CGL_FALSE;
    CGL_window_make_context_current(g_State.window);
    if(!CGL_gl_init()) return CGL_FALSE;
    CGL_widgets_init();

    g_State.framebuffer = CGL_framebuffer_create_from_default(g_State.window);

    CGL_window_swap_buffers(g_State.window);
    CGL_window_poll_events(g_State.window);

    g_State.shape_count = CGL_utils_random_int(20, 35);
    float xo = -0.8f, yo = -0.8f;
    for(CGL_sizei i = 0, j = 3 ; i < g_State.shape_count + 1 ; i++)
    {
        CGL_sizei vertex_count = j;
        if(i == g_State.shape_count) vertex_count = 5;
        CGL_shape_init(&g_State.shapes[i], vertex_count);
        g_State.shapes[i].position.z = 0.0f;
        g_State.shapes[i].position.x = xo;
        g_State.shapes[i].position.y = yo;
        g_State.shapes[i].rotation.z = CGL_utils_random_float() * CGL_2PI;
        for(CGL_sizei k = 0 ; k < vertex_count ; k++) g_State.shapes[i].vertices[k] = CGL_vec3_init(cosf((CGL_2PI / vertex_count * k)) * 0.15f, sinf((CGL_2PI / vertex_count * k)) * 0.15f, 0.0f);
        xo += 0.4f; if(xo > 0.8f) {xo = -0.8f; yo += 0.5f;} if(i % 4 != 0) j++;
    }
    g_State.shapes[g_State.shape_count].scale = CGL_vec3_init(0.5f, 0.5f, 0.5f);
    g_State.shapes[g_State.shape_count].position = CGL_vec3_init(0.0f, 0.0f, 0.0f);

    g_State.use_gjk = true;
    g_State.last_time = CGL_utils_get_time();
    g_State.curr_time = CGL_utils_get_time();
    g_State.delta_time = 0.0f;

    return CGL_TRUE;
}

void cleanup() {
    for(CGL_sizei i = 0; i <= g_State.shape_count; i++) CGL_shape_destroy(&g_State.shapes[i]);

    CGL_framebuffer_destroy(g_State.framebuffer);
    CGL_widgets_shutdown();
    CGL_gl_shutdown();
    CGL_window_destroy(g_State.window);
    CGL_shutdown();   
}



EM_BOOL loop(double time, void* userData) {
    (void)time;
    (void)userData;
    g_State.curr_time = CGL_utils_get_time();
    g_State.delta_time = g_State.curr_time - g_State.last_time;
    g_State.last_time = g_State.curr_time;

    CGL_framebuffer_bind(g_State.framebuffer);
    CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);
    CGL_shape* cursor = &g_State.shapes[g_State.shape_count];
    CGL_widgets_begin();
    CGL_vec2 normal_vector = CGL_vec2_init(0.0f, 0.0f);
    CGL_vec2 normal_vector2 = CGL_vec2_init(0.0f, 0.0f);
    // draw shapes
    for(CGL_sizei i = 0 ; i < g_State.shape_count ; i++)
    {
        /*
        // For simple casses where the axes are known
        if(CGL_sat_collision_overlap_on_axis(cursor, &shapes[i], CGL_vec2_init(1.0f, 1.0f), NULL) && CGL_sat_collision_overlap_on_axis(cursor, &shapes[i], CGL_vec2_init(1.0f, -1.0f), NULL))
            CGL_widgets_set_stroke_colorf(0.8f, 0.1f, 0.1f, 1.0f);
        else
            CGL_widgets_set_stroke_colorf(0.1f, 0.1f, 0.1f, 1.0f);
        // you can also get sat axes by using
        CGL_vec2 axes[10000];
        int axis_count = 0;
        CGL_sat_collision_calculate_axes(&shape, axes, &axes_count);
        */
        CGL_bool result = false;
        if(g_State.use_gjk)
        {
            static CGL_vec3 simplex[3];
            result = CGL_gjk_check_collision_2d(cursor, &g_State.shapes[i], simplex);
            if(result)
            {
                CGL_vec3 tmp = CGL_gjk_epa_2d(cursor, &g_State.shapes[i], simplex);
                normal_vector = CGL_vec2_init(tmp.x, tmp.y);
            }
        }
        else
        {
            result = CGL_sat_collision_detect(cursor, &g_State.shapes[i], &normal_vector);
        }
        if(result) normal_vector2 = CGL_vec2_add(normal_vector2, normal_vector);
        if(result) CGL_widgets_set_stroke_colorf(0.8f, 0.1f, 0.1f, 1.0f);
        else CGL_widgets_set_stroke_colorf(0.7f, 0.7f, 0.7f, 1.0f);
        CGL_widgets_set_stroke_thicnkess(0.005f);
        CGL_widgets_add_shape_out_line(&g_State.shapes[i]);
        if(result)
        {
            CGL_widgets_set_stroke_thicnkess(0.002f);
            CGL_widgets_set_stroke_colorf(0.5f, 1.0f, 0.5f, 1.0f);
            CGL_widgets_add_line2f(cursor->position.x, cursor->position.y, g_State.shapes[i].position.x, g_State.shapes[i].position.y);
            CGL_widgets_set_stroke_thicnkess(0.02f);
            CGL_widgets_set_stroke_colorf(1.0f, 0.5f, 0.5f, 1.0f);
            CGL_widgets_add_line2f(cursor->position.x, cursor->position.y, cursor->position.x + normal_vector.x, cursor->position.y + normal_vector.y);
        }
    }
    if(CGL_window_get_key(g_State.window, CGL_KEY_R) == CGL_PRESS) 
    {
        cursor->position.x -= normal_vector2.x;
        cursor->position.y -= normal_vector2.y;
        CGL_utils_sleep(100); // to prevent spamming
    }

    CGL_widgets_set_stroke_thicnkess(0.005f);
    CGL_widgets_set_stroke_colorf(0.5f, 0.8f, 0.5f, 1.0f);
    CGL_widgets_add_shape_out_line(cursor);
    

    static CGL_byte buffer[1000];
    CGL_widgets_set_stroke_colorf(0.8f, 0.8f, 0.8f, 1.0f);
    sprintf(buffer, "Mode: %s", g_State.use_gjk ? "GJK" : "SAT");
    CGL_widgets_add_string(buffer, -1.0f, 0.9f, 0.5f, 0.1f);
    sprintf(buffer, "Frame Time: %f", g_State.delta_time);
    CGL_widgets_add_string(buffer, -1.0f, 0.8f, 1.0f, 0.1f);

    CGL_widgets_set_fill_colorf(0.4f, 0.8f, 0.4f, 1.0f);
    CGL_widgets_add_string("G or T for algorithm", -1.0f, -0.7f, 0.8f, 0.05f);
    CGL_widgets_add_string("W or S for changing scale", -1.0f, -0.8f, 1.0f, 0.05f);
    CGL_widgets_add_string("Z for roatation", -1.0f, -0.9f, 0.8f, 0.05f);
    CGL_widgets_add_string("Arrow keys to move", -1.0f, -1.0f, 1.0f, 0.05f);
    CGL_widgets_end();

    const CGL_float speed = 50.0;    
    if(CGL_window_get_key(g_State.window, CGL_KEY_UP) == CGL_PRESS) cursor->position.y += 0.01f * speed * g_State.delta_time;
    if(CGL_window_get_key(g_State.window, CGL_KEY_DOWN) == CGL_PRESS) cursor->position.y -= 0.01f * speed * g_State.delta_time;
    if(CGL_window_get_key(g_State.window, CGL_KEY_LEFT) == CGL_PRESS) cursor->position.x -= 0.01f * speed * g_State.delta_time;
    if(CGL_window_get_key(g_State.window, CGL_KEY_RIGHT) == CGL_PRESS) cursor->position.x += 0.01f * speed * g_State.delta_time;
    if(CGL_window_get_key(g_State.window, CGL_KEY_Z) == CGL_PRESS) cursor->rotation.z -= 0.025f * speed * g_State.delta_time;
    if(CGL_window_get_key(g_State.window, CGL_KEY_W) == CGL_PRESS) {cursor->scale.x += 0.025f * speed * g_State.delta_time; cursor->scale.y += 0.025f * speed * g_State.delta_time;}
    if(CGL_window_get_key(g_State.window, CGL_KEY_S) == CGL_PRESS) {cursor->scale.x -= 0.025f * speed * g_State.delta_time;cursor->scale.y -= 0.025f * speed * g_State.delta_time;}
    if(CGL_window_get_key(g_State.window, CGL_KEY_G) == CGL_PRESS) g_State.use_gjk = true;
    if(CGL_window_get_key(g_State.window, CGL_KEY_T) == CGL_PRESS) g_State.use_gjk = false;
    if(CGL_window_get_key(g_State.window, CGL_KEY_ESCAPE) == CGL_PRESS) return CGL_FALSE;
    
    CGL_window_swap_buffers(g_State.window);
    CGL_window_poll_events(g_State.window);

    return CGL_TRUE;
}

int main()
{
    if(!init()) return EXIT_FAILURE;

#ifdef CGL_WASM
    CGL_info("Running in WASM mode");
    emscripten_request_animation_frame_loop(loop, NULL);
#else    
    while(!CGL_window_should_close(g_State.window)) 
    {
        if(!loop(0.0, NULL)) break;       
    }
    cleanup();
#endif

    return EXIT_SUCCESS;
}

```

`examples/c/2d_procedural_trees.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/


#define CGL_LOGGING_ENABLED
#define CGL_EXCLUDE_AUDIO
#define CGL_EXCLUDE_NETWORKING
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_IMPLEMENTATION
#include "cgl.h"



#ifdef CGL_WASM
#include <emscripten/emscripten.h>
#include <emscripten/html5.h>
#else 
#define EM_BOOL int
#endif


#define MAX_BRANCHES 100000
#define MAX_GENERATE_TREE_RECURSIVE_CALLS 1000000
#define ADD_INPUT(var_name, mask_key, step_val, min_val, max_val) \
    if(CGL_window_is_key_pressed(g_context.window, mask_key)) { \
        if(CGL_window_is_key_pressed(g_context.window, CGL_KEY_UP)) var_name += step_val; \
        if(CGL_window_is_key_pressed(g_context.window, CGL_KEY_DOWN)) var_name -= step_val; \
        var_name = CGL_utils_clamp(var_name, min_val, max_val); \
    } \

typedef struct
{
    CGL_vec2 start;
    CGL_float angle;
    CGL_float length;
    CGL_float thickness;
    CGL_vec4 color;
} tree_branch;

static struct
{
    CGL_window* window; // the main window
    CGL_int window_height;
    CGL_int window_width;
    CGL_framebuffer* framebuffer;
} g_context;

static struct
{
    tree_branch branches[MAX_BRANCHES];
    CGL_int branch_count;
    CGL_int seed;
    CGL_float angle_right;
    CGL_float angle_left;
    CGL_float thickness_factor;
    CGL_float length_factor;
    CGL_float branch_chance;
    CGL_float min_branch_length;
    CGL_float min_branch_thickness;
} g_tree;

static void draw_tree()
{
    CGL_int branch_count = g_tree.branch_count;
    for(CGL_int i = 0; i < branch_count; i++)
    {
        tree_branch* branch = &g_tree.branches[i];
        CGL_vec2 end = CGL_vec2_add_(branch->start, CGL_vec2_scale_(CGL_vec2_from_angle(branch->angle + CGL_PI_2), branch->length));
        CGL_widgets_set_stroke_color(branch->color);
        CGL_widgets_set_stroke_thicnkess(branch->thickness);
        CGL_widgets_add_line2f(branch->start.x, branch->start.y, end.x, end.y);
    }
}

static tree_branch create_branch(CGL_vec2 start, CGL_float angle, CGL_float length, CGL_float thickness)
{
    tree_branch branch;
    branch.start = start;
    branch.angle = angle;
    branch.length = length;
    branch.thickness = thickness;
    branch.color =CGL_vec4_scale_(CGL_vec4_init(0.179f, 0.097f, 0.066f, 1.0f), 0.5f);
    return branch;
}

static void add_branch(tree_branch branch)
{
    if(g_tree.branch_count >= MAX_BRANCHES)
    {
        CGL_warn("Max branches reached!");
        return;
    }
    g_tree.branches[g_tree.branch_count++] = branch;
}

static int generate_tree_recursive_calls = 0;

static CGL_float generate_random_float(CGL_float center, CGL_float percent)
{
    CGL_float range = center * percent;
    CGL_float min = center - range;
    CGL_float max = center + range;
    return CGL_utils_random_float() * (max - min) + min;
}

static void generate_tree_recursive(CGL_int prev_branch)
{
    generate_tree_recursive_calls++;
    if(generate_tree_recursive_calls > MAX_GENERATE_TREE_RECURSIVE_CALLS)
    {
        CGL_warn("Max generate tree recursive calls reached!");
        return;
    }

    tree_branch* p_branch = &g_tree.branches[prev_branch];

    CGL_float c_length_factor[2] = {g_tree.length_factor, g_tree.length_factor};
    CGL_float c_branch_chance[2] = {g_tree.branch_chance, g_tree.branch_chance};
    CGL_float c_angle_nudge[2] = {g_tree.angle_left, g_tree.angle_right};
    CGL_float c_thickness_factor = g_tree.thickness_factor;
    
    CGL_float l_length = p_branch->length * generate_random_float(c_length_factor[0], 0.1f);
    CGL_float l_thickness = p_branch->thickness * generate_random_float(c_thickness_factor, 0.1f);
    CGL_float l_angle_nudge = generate_random_float(c_angle_nudge[0], 0.1f) + p_branch->angle;
    CGL_bool l_branch = CGL_utils_random_float() < c_branch_chance[0];
    if(l_branch)
    {
        CGL_vec2 start = CGL_vec2_add_(p_branch->start, CGL_vec2_scale_(CGL_vec2_from_angle(p_branch->angle + CGL_PI_2), p_branch->length*0.98f));
        tree_branch branch = create_branch(start, l_angle_nudge, l_length, l_thickness);
        add_branch(branch);
        if(l_length > g_tree.min_branch_length && l_thickness > g_tree.min_branch_thickness) generate_tree_recursive(g_tree.branch_count - 1);
    }
    
    CGL_float r_length = p_branch->length * generate_random_float(c_length_factor[1], 0.1f);
    CGL_float r_thickness = p_branch->thickness * generate_random_float(c_thickness_factor, 0.1f);
    CGL_float r_angle_nudge = generate_random_float(-c_angle_nudge[1], 0.1f) + p_branch->angle;
    CGL_bool r_branch = CGL_utils_random_float() < c_branch_chance[1];
    if(r_branch)
    {
        CGL_vec2 start = CGL_vec2_add_(p_branch->start, CGL_vec2_scale_(CGL_vec2_from_angle(p_branch->angle + CGL_PI_2), p_branch->length*0.98f));
        tree_branch branch = create_branch(start, r_angle_nudge, r_length, r_thickness);
        add_branch(branch);
        if(r_length > g_tree.min_branch_length && r_thickness > g_tree.min_branch_thickness) generate_tree_recursive(g_tree.branch_count - 1);
    }

    
}

static void generate_tree()
{
    generate_tree_recursive_calls = 0;
    g_tree.branch_count = 0;
    g_tree.branches[g_tree.branch_count++] = create_branch(CGL_vec2_init(0.0f, -1.0f), 0.0f, 0.5f, 0.1f);
    srand((CGL_uint)g_tree.seed);
    generate_tree_recursive(0);
}

CGL_float prev_time = 0.0, curr_time = 0.0f, delta_time = 0.0f, frame_time = 0.0f;
CGL_int frame_count = 0, frame_rate = 60;

CGL_bool init() {
    srand((uint32_t)time(NULL));
    if(!CGL_init()) return CGL_FALSE; // initialize CGL (required for setting up internals of CGL)
    g_context.window_height = g_context.window_width = 700;
    g_context.window = CGL_window_create(g_context.window_width, g_context.window_height, "Procedural Trees - Jaysmito Mukherjee"); // create the window
    CGL_window_make_context_current(g_context.window); // make the opengl context for the window current
    if(!CGL_gl_init()) return CGL_FALSE; // initialize cgl opengl module    
    g_context.framebuffer = CGL_framebuffer_create_from_default(g_context.window); // load the default framebuffer (0) into CGL_framebuffer object
    if(!CGL_widgets_init()) return CGL_FALSE; 


    g_tree.angle_left = CGL_deg_to_rad(30.0f);
    g_tree.angle_right = CGL_deg_to_rad(30.0f);
    g_tree.thickness_factor = 0.7f;
    g_tree.length_factor = 0.7f;
    g_tree.branch_chance = 1.0f;
    g_tree.min_branch_thickness = 0.0001f;
    g_tree.min_branch_length = 0.01f;

    prev_time = CGL_utils_get_time();

    return CGL_TRUE;
}

void cleanup() {
    CGL_widgets_shutdown();
    CGL_framebuffer_destroy(g_context.framebuffer); // destory framebuffer object
    CGL_gl_shutdown(); // shutdown cgl opengl module
    CGL_window_destroy(g_context.window); // destroy window
    CGL_shutdown(); // shutdown cgl and clean up resources allocated by CGL internally (if any)
}

EM_BOOL loop(double time, void* userData) {
    (void)time;
    (void)userData;

    curr_time = CGL_utils_get_time();
    delta_time = curr_time - prev_time; prev_time = curr_time; frame_time += delta_time; frame_count++;
    if(frame_time >= 1.0f) { frame_rate = frame_count; frame_time = 0.0f; frame_count = 0; }
    
    CGL_window_set_size(g_context.window, g_context.window_width, g_context.window_height); // set the window size
    
    // rendering
    CGL_framebuffer_bind(g_context.framebuffer); // bind default framebuffer and also adjust viewport size and offset
    CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f); // clear screen with a dark gray color
    generate_tree();
    CGL_widgets_begin();
    draw_tree();
    CGL_widgets_set_fill_colorf(1.0f, 1.0f, 1.0f, 1.0f);
    static CGL_byte text_buffer[256];
    sprintf(text_buffer, "Delta Time: %f", delta_time);
    CGL_widgets_add_string(text_buffer, -1.0f, 0.95f, 0.8f, 0.05f);
    sprintf(text_buffer, "Frame Rate: %d", frame_rate);
    CGL_widgets_add_string(text_buffer, 0.0f, 0.95f, 0.8f, 0.05f);
    sprintf(text_buffer, "Branch Count: %d", g_tree.branch_count);
    CGL_widgets_add_string(text_buffer, -1.0f, 0.90f, 0.8f, 0.05f);
    sprintf(text_buffer, "Angles: (%d, %d)", (CGL_int)CGL_rad_to_deg(g_tree.angle_left), (CGL_int)CGL_rad_to_deg(g_tree.angle_right));
    CGL_widgets_add_string(text_buffer, 0.0f, 0.90f, 0.8f, 0.05f);
    sprintf(text_buffer, "Length Factor: %f", g_tree.length_factor);
    CGL_widgets_add_string(text_buffer, -1.0f, 0.85f, 0.8f, 0.05f);
    sprintf(text_buffer, "Thickness Factor: %f", g_tree.thickness_factor);
    CGL_widgets_add_string(text_buffer, 0.0f, 0.85f, 0.8f, 0.05f);
    sprintf(text_buffer, "Branch Chance: %f", g_tree.branch_chance);
    CGL_widgets_add_string(text_buffer, -1.0f, 0.80f, 0.8f, 0.05f);
    sprintf(text_buffer, "Recursive Calls: %d", generate_tree_recursive_calls);
    CGL_widgets_add_string(text_buffer, 0.0f, 0.80f, 0.8f, 0.05f);

    // tell the controls
    CGL_widgets_add_string("W or S: Length Factor", -1.0f, -0.95f, 0.8f, 0.05f);
    CGL_widgets_add_string("A or D: Angle", -1.0f, -0.90f, 0.8f, 0.05f);
    CGL_widgets_add_string("Q: Branch Chance", -1.0f, -0.85f, 0.8f, 0.05f);
    CGL_widgets_add_string("R: Randomize Seed", -1.0f, -0.80f, 0.8f, 0.05f);
    CGL_widgets_add_string("Press any key below and Up or Down:", -1.0f, -0.75f, 1.0f, 0.05f);


    CGL_widgets_end();
    
    CGL_window_swap_buffers(g_context.window); // swap framebuffers
    CGL_window_poll_events(g_context.window); // poll events (if this is not called every frame window will stop responding)
    
    ADD_INPUT(g_tree.angle_left, CGL_KEY_A, 0.005f, 0.0f, CGL_PI);
    ADD_INPUT(g_tree.angle_right, CGL_KEY_D, 0.005f, 0.0f, CGL_PI);
    ADD_INPUT(g_tree.length_factor, CGL_KEY_W, 0.001f, 0.0f, 0.8f);
    ADD_INPUT(g_tree.thickness_factor, CGL_KEY_S, 0.001f, 0.0f, 1.0f);
    ADD_INPUT(g_tree.branch_chance, CGL_KEY_Q, 0.001f, 0.0f, 1.0f);


    
    if(CGL_window_get_key(g_context.window, CGL_KEY_R) == CGL_PRESS) g_tree.seed = (CGL_int)(CGL_utils_get_time() * 10000.0f);
    if(CGL_window_get_key(g_context.window, CGL_KEY_ESCAPE) == CGL_PRESS) return CGL_FALSE; // quit on pressing escape key
    
    return CGL_TRUE;
}

int main()
{
if(!init()) return EXIT_FAILURE; // initialize the application

#ifdef CGL_WASM
    emscripten_request_animation_frame_loop(loop, NULL); // start the main loop
#else
    while(!CGL_window_should_close(g_context.window)) {
        if(!loop(0.0, NULL)) break; // run the loop and break if loop returns false
    }
    cleanup();
#endif
    return EXIT_SUCCESS;
}

```

`examples/c/3d_maze_game.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#define CGL_EXCLUDE_NETWORKING
#define CGL_EXCLUDE_RAY_CASTER
#define CGL_EXCLUDE_NODE_EDITOR
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_EXCLUDE_AUDIO
#include "cgl.h"

#define MAX_LIGHTS 64
#define BOARD_SIZE 16

#ifdef CGL_WASM
#include <emscripten/emscripten.h>
#include <emscripten/html5.h>
#else 
#define EM_BOOL int
#endif


static const char* PASS_THROUGH_VERTEX_SHADER_SOURCE =
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"\n"
"in vec4 position;\n"
"in vec4 normal;\n"
"in vec4 texcoord;\n"
#else
"#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 normal;\n"
"layout (location = 2) in vec4 texcoord;\n"
#endif
"\n"
"out vec3 Position;\n"
"out vec2 TexCoord;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = vec4(position.xyz, 1.0f);\n"
"	Position = position.xyz;\n"
"	TexCoord = texcoord.xy;\n"
"}";

static const char* PASS_THROUGH_FRAGMENT_SHADER_SOURCE = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
#else
"#version 430 core\n"
#endif
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Position;\n"
"in vec2 TexCoord;\n"
"\n"
"uniform sampler2D u_tex;\n"
"\n"
"// Black Box From https://github.com/armory3d/armory/blob/master/Shaders/std/tonemap.glsl\n"
"vec3 acesFilm(const vec3 x) {\n"
"    const float a = 2.51;\n"
"    const float b = 0.03;\n"
"    const float c = 2.43;\n"
"    const float d = 0.59;\n"
"    const float e = 0.14;\n"
"    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	vec3 color = texture(u_tex, vec2(TexCoord.y, 1.0f - TexCoord.x)).rgb;\n"
"	color = acesFilm(color);\n"
"   color = pow(color, vec3(1.0f / 2.2f));\n"
"	FragColor = vec4(color, 1.0f);\n"
"}";

static const char* PRIMARY_VERTEX_SHADER_SOURCE = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"\n"
"in vec4 position;\n"
"in vec4 normal;\n"
"in vec4 texcoord;\n"
#else
"#version 430 core\n"
"\n"
"in layout(location = 0) vec4 position;\n"
"in layout(location = 1) vec4 normal;\n"
"in layout(location = 2) vec4 texcoord;\n"
#endif
"\n"
"void main()\n"
"{\n"
"    gl_Position = vec4(position.xyz, 1.0);\n"
"}\n"
"";

static const char* PRIMARY_FRAGMENT_SHADER_SOURCE = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
#else
"#version 430 core\n"
#endif
"\n"
"out vec4 FragColor;\n"
"\n"
"#define MAX_LIGHTS 64\n"
"#define BOARD_RESOLUTION 16\n"
"\n"
"// uniforms\n"
"uniform vec4 light_positions[MAX_LIGHTS]; // w is intensity\n"
"uniform vec4 light_colors[MAX_LIGHTS]; // w is reserved\n"
"uniform int light_count;\n"
"uniform int board_piece_pos[BOARD_RESOLUTION * BOARD_RESOLUTION];\n"
"uniform float time;\n"
"uniform vec2 player_pos;\n"
"\n"
"// constants\n"
"const float PI = 3.14159265359f;\n"
"const int MAX_RAYMARCH_STEPS = 128;\n"
"const float MIN_DIST = 0.00001f;\n"
"const float MAX_DIST = 100.0f;\n"
"const float EPSILON = 0.00001f;\n"
"const vec2 RESOLUTION = vec2(600, 600);\n"
"\n"
"// colors\n"
"const vec3 COLOR_WOOD = vec3(133.0/256.0f, 94.0/256.0f, 66.0/256.0f);\n"
"const vec3 COLOR_WOOD_DARK = vec3(75.0/256.0f, 57.0/256.0f, 35.0/256.0f) * 0.5f;\n"
"\n"
"// sdf functions\n"
"float sphereSDF(vec3 p, float r)\n"
"{\n"
"    return length(p) - r;\n"
"}\n"
"\n"
"float boxSDF(vec3 p, vec3 b)\n"
"{\n"
"    vec3 d = abs(p) - b;\n"
"    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n"
"}\n"
"\n"
"vec3 ray_direction(float fov, vec2 uv)\n"
"{\n"
"    vec2 xy = 2.0f * uv - 1.0f;\n"
"    vec3 dir = vec3(xy, -1.0f / tan(fov / 2.0f));\n"
"    return normalize(dir);\n"
"}\n"
"\n"
"mat3 set_camera( in vec3 ro, in vec3 ta, float cr )\n"
"{\n"
"	vec3 cw = normalize(ta-ro);\n"
"	vec3 cp = vec3(sin(cr), cos(cr),0.0);\n"
"	vec3 cu = normalize( cross(cw,cp) );\n"
"	vec3 cv =          ( cross(cu,cw) );\n"
"    return mat3( cu, cv, cw );\n"
"}\n"
"\n"
"vec3 color_select_mn(float d1, float d2, vec3 c1, vec3 c2)\n"
"{\n"
"    return d1 < d2 ? c1 : c2;\n"
"}\n"
"\n"
"vec3 color_select_mx(float d1, float d2, vec3 c1, vec3 c2)\n"
"{\n"
"    return d1 > d2 ? c1 : c2;\n"
"}\n"
"\n"
"vec4 map(vec3 p)\n"
"{\n"
"    vec3 color = vec3(0.0f);\n"
"    float d = 0.0f, tmp = 0.0f;\n"
"\n"
"    // floor\n"
"    d = boxSDF(p, vec3(3.0f, 0.1f, 3.0f)); \n"
"    color = vec3(0.1f, 0.1f, 0.1f);\n"
"\n"
"    // game board\n"
"    vec3 color_board = vec3(0.0f);\n"
"    float d_board = 0.0f;\n"
"    // base\n"
"    float board_size = 2.0f;\n"
"    {\n"
"        d_board = boxSDF(p, vec3(board_size, 0.45f, board_size));\n"
"        color_board = COLOR_WOOD;\n"
"    }\n"
"\n"
"    // pieces\n"
"    float cell_size = 2.0f * board_size / float(BOARD_RESOLUTION);\n"
"    {\n"
"        vec2 tmp_v2 = clamp(p.xz, -board_size, board_size);\n"
"        ivec2 tmp2_v2 = ivec2( ( (tmp_v2 + board_size)*0.5f/board_size) * float(BOARD_RESOLUTION) );\n"
"        tmp_v2 = mod(tmp_v2, cell_size) - cell_size * 0.5f;\n"
"\n"
"        \n"
"\n"
"        \n"
"        vec3 p_pcs = vec3(tmp_v2.x, p.y - 0.5f, tmp_v2.y);\n"
"        //float d_pcs = sphereSDF(p_pcs, cell_size * 0.75f);\n"
"        float d_pcs = boxSDF(p_pcs, vec3(cell_size, 0.3f, cell_size));\n"
"        float mask = float(board_piece_pos[tmp2_v2.x * BOARD_RESOLUTION + tmp2_v2.y]);\n"
"        mask = clamp(mask, 0.0f, 1.0f);\n"
"        d_board = max(d_board, mix(d_board, -d_pcs, mask));\n"
"    }\n"
"    color = color_select_mn(d, d_board, color, color_board);\n"
"    \n"
"    // board borders\n"
"    {\n"
"        float d_border = boxSDF(p - vec3(0.0f, 0.0f, board_size+0.1f), vec3(board_size+0.1f, 0.6f, 0.01f));\n"
"        d_border = min(d_border, boxSDF(p - vec3(0.0f, 0.0f, -board_size-0.1f), vec3(board_size+0.1f, 0.6f, 0.01f)));\n"
"        d_border = min(d_border, boxSDF(p - vec3(board_size+0.1f, 0.0f, 0.0f), vec3(0.01f, 0.6f, board_size+0.1f)));\n"
"        d_border = min(d_border, boxSDF(p - vec3(-board_size-0.1f, 0.0f, 0.0f), vec3(0.01f, 0.6f, board_size+0.1f)));\n"
"        color_board = color_select_mn(d_board, d_border, color_board, COLOR_WOOD_DARK);\n"
"        d_board = min(d_board, d_border);\n"
"    }\n"
"    \n"
"    color = color_select_mn(d, d_board, color, color_board);\n"
"    d = min(d, d_board - 0.1f);\n"
"\n"
"    // balls\n"
"    for(int i = 4 ; i < light_count ; i++)\n"
"    {\n"
"        float dt = sphereSDF(p - light_positions[i].xyz, light_colors[i].w);\n"
"        color = color_select_mn(d, dt, color, light_colors[i].xyz);\n"
"        d = min(d, dt);\n"
"    }\n"
"\n"
"    // player\n"
"    {\n"
"        float dt = sphereSDF(p - vec3(player_pos.x, 0.5f, player_pos.y), 0.05f);\n"
"        color = color_select_mn(d, dt, color, vec3(0.2f, 1.0f, 0.3f));\n"
"        d = min(d, dt);\n"
"    }\n"
"\n"
"\n"
"    return vec4(color, d);\n"
"}\n"
"\n"
"vec3 estimate_normal(vec3 p)\n"
"{\n"
"    vec2 e = vec2(0.005f, 0.0f);\n"
"    vec3 n = vec3(\n"
"        map(p + e.xyy).w - map(p - e.xyy).w,\n"
"        map(p + e.yxy).w - map(p - e.yxy).w,\n"
"        map(p + e.yyx).w - map(p - e.yyx).w\n"
"    );\n"
"    return normalize(n);\n"
"}\n"
"\n"
"vec3 ray_march(vec3 ray_origin, vec3 ray_dir)\n"
"{\n"
"    float dist = 0.0f;\n"
"    int i = 0;\n"
"    vec4 tmp = vec4(0.0f);\n"
"    for (i = 0; i < MAX_RAYMARCH_STEPS; i++)\n"
"    {\n"
"        vec3 p = ray_origin + ray_dir * dist;\n"
"        tmp = map(p);\n"
"        float d = tmp.w;\n"
"        if (d <= EPSILON) break;\n"
"        if (dist >= MAX_DIST) break;\n"
"        dist += d;\n"
"    }\n"
"    if(dist >= MAX_DIST) return vec3(0.0f);\n"
"\n"
"    // calculate lighting\n"
"    vec3 p = ray_origin + ray_dir * dist;\n"
"    vec3 n = estimate_normal(p);\n"
"    vec3 color = vec3(0.0f);\n"
"    for (int i = 0; i < light_count; i++)\n"
"    {\n"
"        vec3 light_dir = normalize(light_positions[i].xyz - p);\n"
"        float diffuse = max(dot(n, light_dir), 0.0f);\n"
"        float l_distance = length(light_positions[i].xyz - p);\n"
"        float l_intensity = light_positions[i].w / (l_distance * l_distance);\n"
"        color += diffuse * light_colors[i].xyz * l_intensity;\n"
"    }\n"
"    return color * tmp.xyz;\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"    vec2 uv = gl_FragCoord.xy / RESOLUTION.xy;\n"
"    uv = uv * 2.0f - 1.0f;\n"
"\n"
"    vec3 camera_pos = vec3(3.0f*cos(time*0.2f), 5.0f, 3.0f*sin(time*0.2f));\n"
"    vec3 camera_target = vec3(0.0f, 0.0f, 0.0f);\n"
"\n"
"    vec3 ww = normalize(camera_target - camera_pos);\n"
"    vec3 uu = normalize(cross(ww, vec3(0.0f, 1.0f, 0.0f)));\n"
"    vec3 vv = cross(uu, ww);\n"
"\n"
"    vec3 ray_origin = camera_pos;\n"
"    vec3 ray_dir = normalize(uv.x * uu + uv.y * vv + 1.5f * ww);\n"
"\n"
"    vec3 color = ray_march(ray_origin, ray_dir);\n"
"\n"
"    FragColor = vec4(color, 1.0);\n"
"}";

typedef struct
{
    CGL_vec3 position;
    CGL_vec3 color;
    CGL_float radius;
    CGL_float intensity;
    CGL_bool claimed;
} light;

static light lights[MAX_LIGHTS];
static CGL_int num_lights = 0;

light create_light(CGL_vec3 position, CGL_vec3 color, CGL_float radius, CGL_float intensity)
{
    light l;
    l.position = position;
    l.color = color;
    l.radius = radius;
    l.intensity = intensity;
    l.claimed = false;
    return l;
}

static CGL_byte board[BOARD_SIZE][BOARD_SIZE] = { 0 };
static CGL_byte ke_sets[BOARD_SIZE][BOARD_SIZE] = { 0 };
static CGL_int walls[BOARD_SIZE * BOARD_SIZE] = { 0 };
static CGL_int num_walls = 0;
static CGL_vec2 player_pos;
static CGL_ivec4 player_cell;

static void shuffle(void* array, size_t n, size_t size)
{
    char tmp[256];
    char* arr = array;
    size_t stride = size * sizeof(char);

    if (n > 1) {
        size_t i;
        for (i = 0; i < n - 1; ++i) {
            size_t rnd = (size_t)rand();
            size_t j = i + rnd / (RAND_MAX / (n - i) + 1);

            memcpy(tmp, arr + j * stride, size);
            memcpy(arr + j * stride, arr + i * stride, size);
            memcpy(arr + i * stride, tmp, size);
        }
    }
}

void propagate_set(CGL_int src, CGL_int dst)
{
    for (CGL_int i = 0; i < 16; i++)
        for (CGL_int j = 0; j < 16; j++)
            if (ke_sets[i][j] == src) ke_sets[i][j] = (CGL_byte)dst;
}

void get_partitioning_sets(CGL_int index, CGL_int* a, CGL_int* b)
{
    CGL_int i = index / BOARD_SIZE;
    CGL_int j = index % BOARD_SIZE;
    if (i % 2 != 0)
    {

        *a = ke_sets[i - 1][j];
        *b = ke_sets[i + 1][j];
    }
    else if (j % 2 != 0)
    {
        *a = ke_sets[i][j - 1];
        *b = ke_sets[i][j + 1];
    }
    else
    {
        *a = -1;
        *b = -1;
    }
}

void generate_maze()
{
    num_walls = 0;
    CGL_int counter = 1;
    for (CGL_int i = 0; i < 16; i++)
    {
        for (CGL_int j = 0; j < 16; j++)
        {
            ke_sets[i][j] = 0;
            if (i % 2 == 0 && j % 2 == 0) { board[i][j] = 1; ke_sets[i][j] = (CGL_byte)(counter++); }
            else { board[i][j] = 0; walls[num_walls++] = i * 16 + j; }
        }
    }
    shuffle(walls, num_walls, sizeof(CGL_int));
    for (CGL_int i = 0; i < num_walls; i++)
    {
        CGL_int a = 0, b = 0;
        get_partitioning_sets(walls[i], &a, &b);
        if (a != b)
        {
            propagate_set(a, b);
            CGL_int i1 = walls[i] / BOARD_SIZE;
            CGL_int j1 = walls[i] % BOARD_SIZE;
            board[i1][j1] = 1;
            walls[i] = -1;
        }
    }
    // place the balls
    CGL_int lamps_left = 5;
    while (lamps_left > 0)
    {
        CGL_int i = rand() % 16;
        CGL_int j = rand() % 16;
        if (board[i][j] == 1)
        {
            CGL_float tmpi = (CGL_float)i / BOARD_SIZE * 2.0f - 1.0f;
            tmpi = (tmpi + 1.0f / BOARD_SIZE) * 2.0f;

            CGL_float tmpj = (CGL_float)j / BOARD_SIZE * 2.0f - 1.0f;
            tmpj = (tmpj + 1.0f / BOARD_SIZE) * 2.0f;
            lights[3 + lamps_left] = create_light(
                CGL_vec3_init(tmpi, 0.5f, tmpj),
                CGL_vec3_init(1.5f, 1.5f, 1.5f),
                0.05f,
                0.1f
            );
            board[i][j] = 3 + (CGL_byte)lamps_left;
            lamps_left--;
        }
    }
    num_lights = 9;

    player_pos = CGL_vec2_init(1.0f, 1.0f);
    for (int i = 0; i < 16; i++)
        for (int j = 0; j < 16; j++)
            if (board[i][j] == 1)
            {
                player_pos.x = (CGL_float)i / BOARD_SIZE * 2.0f - 1.0f;
                player_pos.x = (player_pos.x + 1.0f / BOARD_SIZE) * 2.0f;
                player_pos.y = (CGL_float)j / BOARD_SIZE * 2.0f - 1.0f;
                player_pos.y = (player_pos.y + 1.0f / BOARD_SIZE) * 2.0f;
                return;
            }
}


struct {
    CGL_window* window;
    CGL_framebuffer* framebuffer;
    CGL_framebuffer* default_framebuffer;
    CGL_framebuffer* bloom_framebuffer;

    CGL_shader* present_shader;
    CGL_shader* primary_shader;

    CGL_float curr_time;
    CGL_float prev_time;
    CGL_float time;
    CGL_float angle;

#ifndef CGL_WASM
    // Bloom is not supported on WASM
    // as bloom uses compute shaders, and
    // thats not supported by webgl
    // later we might add support for it
    // if we switch to WebGPU
    CGL_bloom* bloom;
#endif
} g_State;

CGL_bool init() {
    srand((uint32_t)time(NULL));
    if(!CGL_init()) return CGL_FALSE;
    
    g_State.window = CGL_window_create(600, 600, "3D Maze - Jaysmito Mukherjee");
    if (!g_State.window) return 1;

    CGL_window_make_context_current(g_State.window);
    if(!CGL_gl_init()) return CGL_FALSE;

    if(!CGL_widgets_init()) return CGL_FALSE;

    g_State.default_framebuffer = CGL_framebuffer_create_from_default(g_State.window);
    g_State.bloom_framebuffer = CGL_framebuffer_create_basic(600, 600);

    lights[num_lights++] = create_light(
        CGL_vec3_init(-3.0f, 1.0f, 3.0f),
        CGL_vec3_init(1.0f, 1.0f, 1.0f),
        1.0f,
        2.0f
    );
    lights[num_lights++] = create_light(
        CGL_vec3_init(3.0f, 1.0f, 3.0f),
        CGL_vec3_init(1.0f, 1.0f, 1.0f),
        1.0f,
        2.0f
    );
    lights[num_lights++] = create_light(
        CGL_vec3_init(3.0f, 1.0f, -3.0f),
        CGL_vec3_init(1.0f, 1.0f, 1.0f),
        1.0f,
        2.0f
    );
    lights[num_lights++] = create_light(
        CGL_vec3_init(-3.0f, 1.0f, -3.0f),
        CGL_vec3_init(1.0f, 1.0f, 1.0f),
        1.0f,
        2.0f
    );

    generate_maze();

    g_State.present_shader = CGL_shader_create(PASS_THROUGH_VERTEX_SHADER_SOURCE, PASS_THROUGH_FRAGMENT_SHADER_SOURCE, NULL);
    g_State.primary_shader = CGL_shader_create(PRIMARY_VERTEX_SHADER_SOURCE, PRIMARY_FRAGMENT_SHADER_SOURCE, NULL);

#ifndef CGL_WASM
    g_State.bloom = CGL_bloom_create(600, 600, 3);
#endif

    g_State.curr_time = CGL_utils_get_time();
    g_State.prev_time = CGL_utils_get_time();
    g_State.time = 0.0f;
    g_State.angle = 0.0f;

    return CGL_TRUE;
}

void cleanup() {
    CGL_shader_destroy(g_State.primary_shader);
    CGL_shader_destroy(g_State.present_shader);
    CGL_framebuffer_destroy(g_State.default_framebuffer);
    CGL_framebuffer_destroy(g_State.bloom_framebuffer);
#ifndef CGL_WASM
    CGL_bloom_destroy(g_State.bloom);
#endif
    CGL_widgets_shutdown();
    CGL_gl_shutdown();
    CGL_window_destroy(g_State.window);
    CGL_shutdown();
}

EM_BOOL loop(double time, void* userData) {
    (void)time;
    (void)userData;

    g_State.curr_time = CGL_utils_get_time();
    CGL_float delta_time = g_State.curr_time - g_State.prev_time;
    g_State.prev_time = g_State.curr_time;

    g_State.time += CGL_utils_clamp(delta_time, 0.0f, 0.05f); // to avoid sudden jumps in time due to lag or things like window resizing


#ifndef CGL_WASM
    CGL_window_set_size(g_State.window, 600, 600); // force window size to be 600x600
#endif

    CGL_vec2 player_pos_c = player_pos;

    if (CGL_window_get_key(g_State.window, CGL_KEY_RIGHT) == CGL_PRESS) player_pos_c.y += 0.05f;
    if (CGL_window_get_key(g_State.window, CGL_KEY_LEFT) == CGL_PRESS) player_pos_c.y -= 0.05f;
    if (CGL_window_get_key(g_State.window, CGL_KEY_UP) == CGL_PRESS) player_pos_c.x -= 0.05f;
    if (CGL_window_get_key(g_State.window, CGL_KEY_DOWN) == CGL_PRESS) player_pos_c.x += 0.05f;
    if (CGL_window_get_key(g_State.window, CGL_KEY_Q) == CGL_PRESS) g_State.angle -= 0.1f;
    if (CGL_window_get_key(g_State.window, CGL_KEY_E) == CGL_PRESS) g_State.angle += 0.1f;

    CGL_ivec4 player_cell_c;
    player_cell_c.x = (CGL_int)(((player_pos_c.x + 2.0f) * 0.5f / 2.0f) * BOARD_SIZE);
    player_cell_c.y = (CGL_int)(((player_pos_c.y + 2.0f) * 0.5f / 2.0f) * BOARD_SIZE);

    if (player_cell_c.x >= 0 && player_cell_c.x < BOARD_SIZE && player_cell_c.y >= 0 && player_cell_c.y < BOARD_SIZE)
    {
        if (board[player_cell_c.x][player_cell_c.y] != 0)
        {
            player_pos = player_pos_c;
            player_cell = player_cell_c;
        }
    }
    CGL_byte vl = board[player_cell.x][player_cell.y];
    if (vl > 3)
    {
        lights[(CGL_sizei)vl].claimed = true;
        lights[(CGL_sizei)vl].color = CGL_vec3_init(0.0f, 1.0f, 0.0f);
    }

    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LESS);
    CGL_framebuffer_bind(g_State.bloom_framebuffer);
    CGL_gl_clear(0.0f, 0.0f, 0.0f, 1.0f);
    CGL_shader_bind(g_State.primary_shader);
    // bind lights
    CGL_shader_set_uniform_int(g_State.primary_shader, CGL_shader_get_uniform_location(g_State.primary_shader, "light_count"), num_lights);
    for (CGL_int i = 0; i < num_lights; i++)
    {
        static CGL_byte uniform_name[64];
        sprintf(uniform_name, "light_positions[%d]", i);
        CGL_shader_set_uniform_vec4v(g_State.primary_shader, CGL_shader_get_uniform_location(g_State.primary_shader, uniform_name), lights[i].position.x, lights[i].position.y, lights[i].position.z, lights[i].intensity);
        sprintf(uniform_name, "light_colors[%d]", i);
        CGL_shader_set_uniform_vec4v(g_State.primary_shader, CGL_shader_get_uniform_location(g_State.primary_shader, uniform_name), lights[i].color.x, lights[i].color.y, lights[i].color.z, lights[i].radius);
    }
    for (int i = 0; i < BOARD_SIZE; i++) for (int j = 0; j < BOARD_SIZE; j++)
    {
        static char uniform_name[64];
        sprintf(uniform_name, "board_piece_pos[%d]", (i * BOARD_SIZE + j));
        CGL_int out = board[i][j];
        CGL_shader_set_uniform_int(g_State.primary_shader, CGL_shader_get_uniform_location(g_State.primary_shader, uniform_name), out);
    }
    CGL_shader_set_uniform_float(g_State.primary_shader, CGL_shader_get_uniform_location(g_State.primary_shader, "time"), g_State.angle);
    CGL_shader_set_uniform_vec2v(g_State.primary_shader, CGL_shader_get_uniform_location(g_State.primary_shader, "player_pos"), player_pos.x, player_pos.y);
    CGL_gl_render_screen_quad();

#ifndef CGL_WASM
    CGL_bloom_apply(g_State.bloom, CGL_framebuffer_get_color_texture(g_State.bloom_framebuffer));
#endif

    CGL_framebuffer_bind(g_State.default_framebuffer);
    CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);
    CGL_shader_bind(g_State.present_shader);
    CGL_texture_bind(CGL_framebuffer_get_color_texture(g_State.bloom_framebuffer), 0);
    CGL_shader_set_uniform_int(g_State.present_shader, CGL_shader_get_uniform_location(g_State.present_shader, "u_tex"), 0);
    CGL_gl_render_screen_quad();

    glDisable(GL_DEPTH_TEST);
    CGL_widgets_begin();
    CGL_widgets_add_string("Q or E to rotate", -1.0f, 0.9f, 1.0f, 0.1f);
    CGL_widgets_add_string("Arrow keys to move", -1.0f, 0.8f, 1.0f, 0.1f);
    CGL_widgets_end();

    CGL_window_poll_events(g_State.window);
    CGL_window_swap_buffers(g_State.window);

    if (CGL_window_get_key(g_State.window, CGL_KEY_R) == CGL_PRESS)
    {
        generate_maze();
        CGL_utils_sleep(200);
    }

    return CGL_TRUE;
}

int main()
{
    if (!init()) return EXIT_FAILURE;

#ifdef CGL_WASM
    emscripten_request_animation_frame_loop(loop, NULL);
#else 
    while (!CGL_window_should_close(g_State.window))
    {
        if(!loop(0.0, NULL)) break;
    }
    cleanup();
#endif
    return 0;
}

```

`examples/c/3d_pipes.c`:

```c
/*
MIT License

Copyright (c) 2024 s-mackeo (https://github.com/s-mackeo)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/


// ignore -Wswitch
#ifdef __GNUC__
#pragma GCC diagnostic ignored "-Wswitch"
#endif

#define CGL_LOGGING_ENABLED
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_EXCLUDE_NETWORKING
#define CGL_EXCLUDE_AUDIO
#define CGL_IMPLEMENTATION
#include "cgl.h"


#ifdef CGL_WASM
#include <emscripten/emscripten.h>
#include <emscripten/html5.h>
#else 
#define EM_BOOL int
#endif


#define WINDOW_WIDTH 800
#define WINDOW_HEIGHT 600

#define PIPE_BOX_LENGTH 15
#define PIPE_MAX_LENGTH 100

#define PIPE_3D_RADIUS 0.3f
#define PIPE_3D_CIRCULAR_RESOLUTION 50

#define PIPE_ELBOW_PROBABILITY 0.2f
#define PIPE_MAX_COUNT 5 

// Potential improvements : easter eggs : Utah teapot and candy cane texture
// Non-square grid to conform with window aspect ratio
// fisheye camera and better camera positioning (+ random offset on every restart) 
// Change grid system and elbow/cylinder length + sphere size to get more closely-resembling pipes
// Increase pixel mask block size for the fade effect
// Edit out the hard-coded things

const CGL_byte* DIFFUSE_VERTEX_SHADER_SOURCE = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
"in vec4 position;\n"
"in vec4 normal;\n"
"in vec4 texcoord;\n"
#else 
"#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 normal;\n"
"layout (location = 2) in vec4 texcoord;\n"
#endif
"\n"
"out vec3 Position;\n"
"out vec3 Normal;\n"
"out vec3 Color;\n"
"out vec2 TexCoord;\n"
"\n"
"uniform mat4 view_proj;\n"
"uniform vec4 pipe_color;\n"

"\n"
"void main()\n"
"{\n"
"   vec3 pos = position.xyz;\n"
"	gl_Position = view_proj * vec4(pos, 1.0f);\n"
"	Position = position.xyz;\n"
"	Normal = normal.xyz;\n"
"	TexCoord = texcoord.xy;\n"
"   Color = pipe_color.xyz;"
"}";

const CGL_byte* DIFFUSE_FRAGMENT_SHADER_SOURCE = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
#else
"#version 430 core\n"
#endif
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Position;\n"
"in vec3 Normal;\n"
"in vec3 Color;\n"
"in vec2 TexCoord;\n"
"\n"
"uniform vec3 u_light_pos;\n"
"uniform vec3 u_eye_pos;\n"
"uniform sampler2D u_TexFade;\n"
"uniform float u_fade_stage;\n"
"uniform float u_WindowWidth;\n"
"uniform float u_WindowHeight;\n"
"\n"
"void main()\n"
"{\n"
"	vec3 object_color = Color;\n"
"	vec3 light_color = vec3(0.5f, 1.0f, 0.5f);\n"
"	vec3 light_dir = normalize(u_light_pos - Position);\n"
"	float diffuse = max(dot(Normal, light_dir), 0.0f);\n"
"    float ambient = 0.1f;\n"
"    float specular_max = 1.0f;\n"
"    float specular = pow(max(dot(reflect(-light_dir, Normal), normalize(u_eye_pos-Position)), 0.0f), 32.0);\n"
"	vec3 result = (specular_max*specular*light_color + diffuse * light_color + ambient) * object_color;\n"
"    float fade_factor = 1.0f;\n"
"    if(u_fade_stage > 0.0f)\n"
"    {\n"
"    vec2 tex_coord = vec2((gl_FragCoord.x)/u_WindowWidth,(gl_FragCoord.y)/u_WindowHeight) ;\n"
"    fade_factor =  min(max(texture(u_TexFade, tex_coord.xy).x ,0.0f),1.0f);\n"
"    if(fade_factor < u_fade_stage)\n"
"    FragColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);\n"
"	else FragColor = vec4(result, 1.0f);\n"
"    }\n"
"	else FragColor = vec4(result, 1.0f);\n"
"}";

// Colors taken from https://github.com/fogleman/pg/blob/master/examples/pipes.py
CGL_int pipe_colors[18] = {
    0x1f77b4, 0xaec7e8, 0xff7f0e, 0xffbb78, 0x2ca02c, 0x98df8a,
    0xd62728, 0xff9896, 0x9467bd, 0xc5b0d5, 0x8c564b, 0xc49c94,
    0xe377c2, 0xf7b6d2, 0x7f7f7f, 0xc7c7c7, 0x17becf, 0x9edae5
};

typedef enum 
{
    PIPE_NONE,
    PIPE_LEFT,
    PIPE_RIGHT,
    PIPE_DOWN,
    PIPE_UP,
    PIPE_BACK,
    PIPE_FRONT
}Pipe_Direction;

typedef struct 
{
    CGL_int x;
    CGL_int y;
    CGL_int z;
} CGL_coord;

typedef struct
{
    CGL_coord coord_end;
    CGL_int length;
    
    CGL_color color;
    Pipe_Direction direction_current;

    CGL_mesh_gpu* mesh_gpu;    
    CGL_mesh_cpu* mesh_cpu;
} Pipe;

void log_direction(Pipe_Direction dir)
{
    switch(dir)
    {
        case PIPE_NONE:CGL_info("NONE\n");break;
        case PIPE_UP:CGL_info("UP\n");break;
        case PIPE_DOWN:CGL_info("DOWN\n");break;
        case PIPE_LEFT:CGL_info("LEFT\n");break;
        case PIPE_RIGHT:CGL_info("RIGHT\n");break;
        case PIPE_FRONT:CGL_info("FRONT\n");break;
        case PIPE_BACK:CGL_info("BACK\n");break;
    }
}


CGL_mesh_cpu* cylinder;
CGL_mesh_cpu* torus;
CGL_mesh_cpu* sphere;

static Pipe pipes[PIPE_MAX_COUNT];
static CGL_int pipe_current_active;
static CGL_float fade_stage;
static CGL_bool grid[PIPE_BOX_LENGTH][PIPE_BOX_LENGTH][PIPE_BOX_LENGTH];

void grid_init()
{
    memset(grid, false, sizeof(CGL_bool)*PIPE_BOX_LENGTH*PIPE_BOX_LENGTH*PIPE_BOX_LENGTH);
    pipe_current_active = 0;
}

void grid_reset()
{
    grid_init();
}

void pipes_init()
{
    for(CGL_int i = 0; i < PIPE_MAX_COUNT; i++)
    {
        pipes[i].length = 0;
        pipes[i].direction_current = PIPE_NONE;
        
        pipes[i].mesh_cpu =  CGL_mesh_cpu_create(1000000, 1000000);
        pipes[i].mesh_gpu = CGL_mesh_gpu_create();
    }
}

void pipes_reset()
{
    for(CGL_int i = 0; i < PIPE_MAX_COUNT; i++)
    {
        CGL_mesh_cpu_destroy(pipes[i].mesh_cpu);
        CGL_mesh_gpu_destroy(pipes[i].mesh_gpu);
    }
    
    pipes_init();
}

CGL_texture* fade_effect_init(CGL_int width, CGL_int height)
{
    CGL_image image;
    image.width = width;
    image.height = height;
    image.bytes_per_channel = 32;
    image.channels = 4; 
    
    image.data = CGL_malloc(width*height*image.bytes_per_channel);
    
    //assert(fade_duration > 1);
    
    for(CGL_int i = 0; i < image.height*image.width*image.channels; i+= image.channels)
    {
        CGL_float* next = ((CGL_float*)(image.data)) + i;
        
        for(CGL_int j = i; j < i+image.channels; j++)
        {
            next[j] = CGL_utils_random_float();
        }
    }
    
    CGL_texture* fade_effect = CGL_texture_create(&image);
    
    CGL_free(image.data);
    
    return fade_effect;
}

void fade_effect_reset(CGL_shader* diffuse_shader)
{
    fade_stage = 0.0f;
    CGL_shader_set_uniform_float(diffuse_shader, CGL_shader_get_uniform_location(diffuse_shader, "u_fade_stage"), fade_stage);
}

bool fade_out_completed()
{
    return fade_stage > 1.0f;
}

void fade_out(CGL_shader* diffuse_shader)
{
    // Increment the threshold used as a mask with the fade texture colour values
    fade_stage += 0.03f;
    CGL_shader_set_uniform_float(diffuse_shader, CGL_shader_get_uniform_location(diffuse_shader, "u_fade_stage"), fade_stage);
    if(fade_out_completed())
    {
        grid_reset(); pipes_reset();fade_effect_reset(diffuse_shader);
    }
}

CGL_coord coord_next_from_direction(CGL_coord coord_current, Pipe_Direction direction_current)
{
    switch(direction_current)
    {
        case PIPE_LEFT:
        return (CGL_coord){coord_current.x - 1, coord_current.y, coord_current.z};
        break;
        case PIPE_RIGHT:
        return (CGL_coord){coord_current.x + 1, coord_current.y, coord_current.z};
        break;
        case PIPE_DOWN:
        return (CGL_coord){coord_current.x, coord_current.y - 1, coord_current.z};
        break;
        case PIPE_UP:
        return (CGL_coord){coord_current.x, coord_current.y + 1, coord_current.z};
        break;
        case PIPE_BACK:
        return (CGL_coord){coord_current.x, coord_current.y, coord_current.z - 1};
        break;
        case PIPE_FRONT:
        return (CGL_coord){coord_current.x, coord_current.y, coord_current.z + 1};
        break;
        default:
        assert(1==0);
        return (CGL_coord){0, 0, 0};
        break;
    }
}

CGL_bool coord_is_valid(CGL_coord coord)
{
    return (coord.x >= 0 && coord.x < PIPE_BOX_LENGTH) &&
        (coord.y >= 0 && coord.y < PIPE_BOX_LENGTH) &&
        (coord.z >= 0 && coord.z < PIPE_BOX_LENGTH);
}

Pipe_Direction pipe_extend_direction(Pipe* pipe)
{
    if(pipe->length == PIPE_MAX_LENGTH)
        return PIPE_NONE;
    
    // if the pipe is starting, we only need a random direction, 
    // as the starting point is set to be extensible in any direction (eg, not on the border)
    if(pipe->length == 1)
    {
        return (Pipe_Direction)(CGL_utils_random_int(1,6));
    }
    
    CGL_coord coord_current = pipe->coord_end;
    Pipe_Direction direction_current = pipe->direction_current;
    
    // the next insertion position was already implicitely determined valid last iteration
    // ie an extension is valid only if its next grid coord is available
    // so check if we can go further
    CGL_coord coord_next = coord_next_from_direction(coord_current, direction_current);
    
    CGL_int available_directions_count = 6;
    Pipe_Direction pipe_available_directions[7];
    
    for(CGL_int i = 1; i < 7; i ++)
    {
        pipe_available_directions[i] = true;
    }
    
    // Check for neighbour collisions
    for(CGL_int i = 1; i < 7; i ++)
    {
        CGL_coord extension_candidate = coord_next_from_direction(coord_next, (Pipe_Direction)i);
        
        if(!coord_is_valid(extension_candidate) || grid[extension_candidate.x][extension_candidate.y][extension_candidate.z])
        {
            available_directions_count--; pipe_available_directions[i] = false;
        }
    }
    
    if(available_directions_count == 0)
        return PIPE_NONE;
    
    // if we can keep going forward, do so with probability 1-PIPE_ELBOW_PROBABILITY
    if(pipe_available_directions[direction_current])
    {
        CGL_float f = CGL_utils_random_float();
        
        if(f > PIPE_ELBOW_PROBABILITY)
        {
            return direction_current;
        }
        
        // otherwise, only go for elbows
        pipe_available_directions[direction_current] = false;
        available_directions_count--;
    }
    
    // if we could have kept going forward but decided to turn and no turn direction is valid, end the pipe
    if(available_directions_count == 0)
        return PIPE_NONE;
    
    // Select a random direction from the available ones
    CGL_int selected_neighbour = CGL_utils_random_int(1, available_directions_count);
    
    for(CGL_int i = 1 ; i < 7; i ++)
    {
        if(pipe_available_directions[i])
            selected_neighbour--;
        
        if(selected_neighbour == 0)
        {
            return (Pipe_Direction)i;
        }
    }
    
    assert(1==0);
    return PIPE_NONE;
}

CGL_mat4 rotation_from_direction(Pipe_Direction direction_current, Pipe_Direction direction_next)
{
    //CGL_info("Directions : \n");
    //log_direction(direction_current);
    //log_direction(direction_next);
    
    CGL_mat4 rotate = CGL_mat4_identity();
    CGL_mat4 rotate2 = CGL_mat4_identity();
    
    if(direction_current == PIPE_NONE || direction_current == direction_next)
    {
        // Cylinder : default is up/down
        if(direction_next == PIPE_LEFT || direction_next == PIPE_RIGHT)
            rotate = CGL_mat4_rotate_z(CGL_PI_2);
        if(direction_next == PIPE_FRONT || direction_next == PIPE_BACK)
            rotate = CGL_mat4_rotate_x(-CGL_PI_2);
    }
    else
    {
        // Torus : default is front to left (also equivalent to : right to back)
        switch(direction_current)
        {
            case PIPE_LEFT:
            {
                rotate = CGL_mat4_rotate_y(CGL_PI);
                switch(direction_next)
                {
                    case PIPE_BACK:rotate2 = CGL_mat4_rotate_x(CGL_PI);break;
                    case PIPE_DOWN:rotate2 = CGL_mat4_rotate_x(-CGL_PI_2);break;
                    case PIPE_UP:rotate2 = CGL_mat4_rotate_x(CGL_PI_2);break;
                }
            }break;
            case PIPE_RIGHT:
            {
                switch(direction_next)
                {
                    case PIPE_FRONT:rotate2 = CGL_mat4_rotate_x(CGL_PI);break;
                    case PIPE_DOWN:rotate2 = CGL_mat4_rotate_x(CGL_PI_2);break;
                    case PIPE_UP:rotate2 = CGL_mat4_rotate_x(-CGL_PI_2);break;
                }
            }break;
            case PIPE_UP:
            {
                rotate = CGL_mat4_rotate_z(-CGL_PI_2);
                switch(direction_next)
                {
                    case PIPE_FRONT:rotate2 = CGL_mat4_rotate_y(CGL_PI);break;
                    case PIPE_LEFT:rotate2 = CGL_mat4_rotate_y(-CGL_PI_2);break;
                    case PIPE_RIGHT:rotate2 = CGL_mat4_rotate_y(CGL_PI_2);break;
                }
            }break;
            case PIPE_DOWN:
            {
                rotate = CGL_mat4_rotate_z(CGL_PI_2);
                switch(direction_next)
                {
                    case PIPE_FRONT:rotate2 = CGL_mat4_rotate_y(CGL_PI);break;
                    case PIPE_LEFT:rotate2 = CGL_mat4_rotate_y(-CGL_PI_2);break;
                    case PIPE_RIGHT:rotate2 = CGL_mat4_rotate_y(CGL_PI_2);break;
                }
            }break;
            case PIPE_BACK:
            {
                rotate = CGL_mat4_rotate_x(CGL_PI);
                switch(direction_next)
                {
                    case PIPE_RIGHT:rotate2 = CGL_mat4_rotate_z(CGL_PI);break;
                    case PIPE_DOWN:rotate2 = CGL_mat4_rotate_z(-CGL_PI_2);break;
                    case PIPE_UP:rotate2 = CGL_mat4_rotate_z(CGL_PI_2);break;
                }
            }break;
            case PIPE_FRONT:
            {
                switch(direction_next)
                {
                    case PIPE_RIGHT:rotate2 = CGL_mat4_rotate_z(CGL_PI);break;
                    case PIPE_DOWN:rotate2 = CGL_mat4_rotate_z(-CGL_PI_2);break;
                    case PIPE_UP:rotate2 = CGL_mat4_rotate_z(CGL_PI_2);break;
                }
            }break;
        }
    }
    
    rotate = CGL_mat4_mul(rotate, rotate2);
    return rotate;
}


void pipe_append_extension(Pipe* pipe, CGL_mesh_cpu* pipe_extension, CGL_coord coord_next, Pipe_Direction direction_next)
{
    assert(pipe->mesh_cpu->vertex_count_used + pipe_extension->vertex_count_used < pipe->mesh_cpu->vertex_count);
    assert(pipe->mesh_cpu->index_count_used + pipe_extension->index_count_used < pipe->mesh_cpu->index_count);
    //CGL_info("%d, %d, %d\n", pipe->coord_end.x, pipe->coord_end.y, pipe->coord_end.z);
    //CGL_info("%d, %d, %d\n", coord_next.x, coord_next.y, coord_next.z);
    
    // Set the primitive transform to the new position and add it to the current pipe
    CGL_vec3 offset = (CGL_vec3){(CGL_float)coord_next.x, (CGL_float)coord_next.y, (CGL_float)coord_next.z};
    CGL_mat4 rotate = rotation_from_direction(pipe->direction_current, direction_next);
    
    CGL_mesh_cpu_transform_vertices(pipe_extension, rotate);
    CGL_mesh_cpu_offset_vertices(pipe_extension, offset);
    CGL_mesh_cpu_recalculate_normals(pipe_extension);
    //CGL_mesh_cpu_flip_normals(pipe_extension);
    CGL_mesh_cpu_add_mesh(pipe->mesh_cpu, pipe_extension);
    
    // revert the primitive back, we're keeping it for later
    CGL_mesh_cpu_offset_vertices(pipe_extension, (CGL_vec3){-offset.x, -offset.y, -offset.z});
    CGL_mat4 rotate_back = CGL_mat4_transpose(rotate);
    CGL_mesh_cpu_transform_vertices(pipe_extension, rotate_back);
    
    pipe->coord_end = coord_next;
    pipe->direction_current = direction_next;
    pipe->length++;
    grid[coord_next.x][coord_next.y][coord_next.z] = true;
}

CGL_bool pipe_3d_update()
{
    // if pipes are done, do the pixel fade out effect
    if(pipe_current_active == PIPE_MAX_COUNT)
        return CGL_FALSE;
    
    Pipe* pipe = &pipes[pipe_current_active];
    
    // if we're starting a new pipe, draw a sphere at a random location
    if(pipe->length == 0)
    {
        //  set random starting color and valid starting coordinate
        
        CGL_int color = pipe_colors[CGL_utils_random_int(0,17)];
        
        pipe->color = (CGL_vec4){(color & 0xFF)/255.0f, ((color & 0xFF00)>> 8)/255.0f, ((color & 0x00FF0000)>> 16)/255.0f, ((color & 0xFF000000)>> 24 )/255.0f};
        
        assert(PIPE_BOX_LENGTH - 3 >= 2);
        
        CGL_coord pipe_start_coord = {
            CGL_utils_random_int(2, PIPE_BOX_LENGTH - 3),
            CGL_utils_random_int(2, PIPE_BOX_LENGTH - 3),
            CGL_utils_random_int(2, PIPE_BOX_LENGTH - 3)};
        
        // NOTE : if pipe max length were unbounded, this would need to be changed as it could cause performance issues
        while(grid[pipe_start_coord.x][pipe_start_coord.y][pipe_start_coord.z])
        {
            pipe_start_coord = (CGL_coord){
                .x=CGL_utils_random_int(2, PIPE_BOX_LENGTH - 3),
                .y=CGL_utils_random_int(2, PIPE_BOX_LENGTH - 3),
                .z=CGL_utils_random_int(2, PIPE_BOX_LENGTH - 3)};
            
        }
        
        pipe->coord_end = pipe_start_coord;
        
        // draw sphere
        pipe_append_extension(pipe, sphere, pipe_start_coord, PIPE_NONE);
        CGL_mesh_gpu_upload(pipe->mesh_gpu, pipe->mesh_cpu, false);
        return CGL_TRUE;
    }
    
    Pipe_Direction direction_next = pipe_extend_direction(pipe);
    
    CGL_coord coord_next = (CGL_coord){0,0,0};
    
    // Only a sphere is present, no initial direction given, so set it
    if(pipes[pipe_current_active].length == 1)
    {
        pipe->direction_current = direction_next;
    }
    
    coord_next =  coord_next_from_direction(pipe->coord_end, pipe->direction_current);
    
    // if the pipe can't extend, complete it and move to the next one
    if(direction_next == PIPE_NONE)
    {
        // draw sphere
        pipe_append_extension(pipe, sphere, coord_next, PIPE_NONE);
        pipe_current_active++;
        return CGL_TRUE;
    }
    
    // the pipe can extend, so extend the pipe
    if (direction_next == pipe->direction_current)
    {
        // keep going forward, add a cylinder
        pipe_append_extension(pipe, cylinder, coord_next, direction_next);
    }
    else
    {
        // time to turn, add an elbow, update to new direction
        pipe_append_extension(pipe, torus, coord_next, direction_next);
        pipe->direction_current = direction_next;
    }
    CGL_mesh_gpu_upload(pipe->mesh_gpu, pipe->mesh_cpu, false);
    return CGL_TRUE;
}

/*#define DEBUG_MESH_COUNT 125
static CGL_mesh_cpu* debug_meshes[DEBUG_MESH_COUNT];
static CGL_mesh_gpu* debug_meshes_gpu[DEBUG_MESH_COUNT];

void debug_mesh()
{
    for(CGL_int i = 0; i < DEBUG_MESH_COUNT; i++)
    {
        debug_meshes[i] = CGL_mesh_cpu_sphere(5, 5);
        debug_meshes[i] = CGL_mesh_cpu_scale_vertices(debug_meshes[i], 0.02f);
        
        CGL_mesh_cpu_recalculate_normals(debug_meshes[i]);
    }
    
    for(CGL_int x = -2; x < 3; x++)
    {
        for(CGL_int y = -2; y < 3; y++)
        {
            for(CGL_int z = -2; z < 3; z++)
            {
                CGL_mesh_cpu_offset_vertices(debug_meshes[(x+2)+5*(y+2)+25*(z+2)], CGL_vec3_init(x/2.0f, y/2.0f,  z/2.0f));
            }
        }
    }
    for(CGL_int i = 0; i < DEBUG_MESH_COUNT; i++)
    {
        debug_meshes_gpu[i] = CGL_mesh_gpu_create();
        CGL_mesh_gpu_upload(debug_meshes_gpu[i], debug_meshes[i], false);
    }
}*/
struct {
    CGL_window* window;
    CGL_framebuffer* framebuffer;
    CGL_shader* diffuse_shader;
    CGL_texture* texture;

    CGL_mat4 perspective;
    CGL_vec3 eye;
    CGL_mat4 view;
} g_State;

void pipes_render(CGL_shader* diffuse_shader)
{
    // TODO fade out
    
    for(CGL_int i = 0; i < PIPE_MAX_COUNT; i++)
    {
        CGL_shader_set_uniform_vec4(diffuse_shader, CGL_shader_get_uniform_location(diffuse_shader, "pipe_color"), (CGL_vec4*)&(pipes[i].color));
        CGL_mesh_gpu_render(pipes[i].mesh_gpu);
    }
    /*for(CGL_int i = 0; i < DEBUG_MESH_COUNT; i++)
    {
        CGL_mesh_gpu_render(debug_meshes_gpu[i]);
    }*/
}



CGL_bool init() {
    if(!CGL_init()) return CGL_FALSE;
    
    g_State.window = CGL_window_create(WINDOW_WIDTH, WINDOW_HEIGHT, "CGL 3D Pipes - Jaysmito Mukherjee");
    
    CGL_window_make_context_current(g_State.window);
    CGL_gl_init();
    CGL_widgets_init();
    g_State.framebuffer = CGL_framebuffer_create_from_default(g_State.window);
    
    //debug_mesh();
    
    g_State.diffuse_shader = CGL_shader_create(DIFFUSE_VERTEX_SHADER_SOURCE, DIFFUSE_FRAGMENT_SHADER_SOURCE, NULL);
    CGL_shader_bind(g_State.diffuse_shader);
    
    pipes_init();
    grid_init();
    g_State.texture = fade_effect_init(WINDOW_WIDTH, WINDOW_HEIGHT);
    CGL_shader_set_uniform_int(g_State.diffuse_shader, CGL_shader_get_uniform_location(g_State.diffuse_shader, "u_TexFade"), CGL_texture_bind(g_State.texture, 0));
    
    
    CGL_shader_set_uniform_float(g_State.diffuse_shader, CGL_shader_get_uniform_location(g_State.diffuse_shader, "u_WindowWidth"), (float)(WINDOW_WIDTH));
    CGL_shader_set_uniform_float(g_State.diffuse_shader, CGL_shader_get_uniform_location(g_State.diffuse_shader, "u_WindowHeight"), (float)(WINDOW_HEIGHT));
    
    
    // Primitive creation
    CGL_vec3 start = CGL_vec3_init(0.0f, -0.5f, 0.0f);
    CGL_vec3 end = CGL_vec3_init(0.0f, 0.5f, 0.0f);
    cylinder = CGL_mesh_cpu_create_cylinder(start, end, PIPE_3D_RADIUS, PIPE_3D_RADIUS, PIPE_3D_CIRCULAR_RESOLUTION);
    
    sphere = CGL_mesh_cpu_sphere(PIPE_3D_CIRCULAR_RESOLUTION, PIPE_3D_CIRCULAR_RESOLUTION);
    sphere = CGL_mesh_cpu_scale_vertices(sphere, PIPE_3D_RADIUS*2);
    
    CGL_float radius0 = 0.5f;
    CGL_float radius1 = PIPE_3D_RADIUS;
    CGL_vec3 center = CGL_vec3_init(0.0f, 0.0f, 0.0f);
    torus = CGL_mesh_cpu_create_torus_elbow(center, radius0, radius1, PIPE_3D_CIRCULAR_RESOLUTION, PIPE_3D_CIRCULAR_RESOLUTION, CGL_PI_2);
    CGL_float offset = CGL_SQRT2*sqrtf(radius0)/2.0f;
    torus = CGL_mesh_cpu_offset_vertices(torus, CGL_vec3_init(-offset, 0.0f,  -offset));
    // 3D scene setup
    g_State.perspective = CGL_mat4_perspective(CGL_PI_2 * 0.5f, 1.0f, 0.01f, 100.0f);
    g_State.eye = CGL_vec3_init(PIPE_BOX_LENGTH/2.0f, 2.0f+PIPE_BOX_LENGTH/2.0f, 2.5f*PIPE_BOX_LENGTH);
    g_State.view = CGL_mat4_look_at(g_State.eye, CGL_vec3_init(PIPE_BOX_LENGTH/2.0f, PIPE_BOX_LENGTH/2.0f, PIPE_BOX_LENGTH/2.0f), CGL_vec3_init(0.0f, 1.0f, 0.0f));
    
    glEnable(GL_DEPTH_TEST);

    return CGL_TRUE;
}


void cleanup() {
    CGL_texture_destroy(g_State.texture);
    CGL_shader_destroy(g_State.diffuse_shader);
    CGL_framebuffer_destroy(g_State.framebuffer);
    CGL_widgets_shutdown();
    CGL_gl_shutdown();
    CGL_window_destroy(g_State.window);
    CGL_shutdown();
}

EM_BOOL loop(double time, void* userData) {
    (void)time;
    (void)userData;

    if(CGL_window_get_key(g_State.window, CGL_KEY_UP) == CGL_PRESS)
        g_State.eye.y += 1.0f;
        
    if(CGL_window_get_key(g_State.window, CGL_KEY_DOWN) == CGL_PRESS)
        g_State.eye.y -= 1.0f;
        
    if(CGL_window_get_key(g_State.window, CGL_KEY_LEFT) == CGL_PRESS)
        g_State.eye.x -= 1.0f;
        
    if(CGL_window_get_key(g_State.window, CGL_KEY_RIGHT) == CGL_PRESS)
        g_State.eye.x += 1.0f;
        
    if(CGL_window_get_key(g_State.window, CGL_KEY_O) == CGL_PRESS)
        g_State.eye.z -= 1.0f;
        
    if(CGL_window_get_key(g_State.window, CGL_KEY_P) == CGL_PRESS)
        g_State.eye.z += 1.0f;
        
        
    CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);
        
    CGL_mat4 view_proj = CGL_mat4_mul(g_State.perspective, g_State.view);
    g_State.view = CGL_mat4_look_at(g_State.eye, CGL_vec3_init(2.0f, 2.0f, 2.0f), CGL_vec3_init(0.0f, 1.0f, 0.0f));
        
        
        
    CGL_framebuffer_bind(g_State.framebuffer);
        
    CGL_gl_clear(0.0f, 0.0f, 0.0f, 1.0f);
        
    int rx = 0; int ry = 0;
    CGL_framebuffer_get_size(g_State.framebuffer, &rx, &ry);
        
    CGL_shader_bind(g_State.diffuse_shader);
    CGL_shader_set_uniform_mat4(g_State.diffuse_shader, CGL_shader_get_uniform_location(g_State.diffuse_shader, "view_proj"), &view_proj);
    CGL_shader_set_uniform_vec3v(g_State.diffuse_shader, CGL_shader_get_uniform_location(g_State.diffuse_shader, "u_light_pos"), PIPE_BOX_LENGTH/2.0f, PIPE_BOX_LENGTH/2.0f, 2*PIPE_BOX_LENGTH);
    CGL_shader_set_uniform_vec3v(g_State.diffuse_shader, CGL_shader_get_uniform_location(g_State.diffuse_shader, "u_eye_pos"), g_State.eye.x, g_State.eye.y, g_State.eye.z);
        
        
    if(CGL_window_get_key(g_State.window, CGL_KEY_L) == CGL_PRESS)
    {
        if(!pipe_3d_update())
        {
            fade_out(g_State.diffuse_shader);
        }
    }
        
    pipes_render(g_State.diffuse_shader);
        
    CGL_widgets_begin();
    CGL_widgets_add_string("Press L", -0.9f, 0.8f, 0.5f, 0.1f);
    CGL_widgets_end();
        
        
    CGL_window_swap_buffers(g_State.window);
    glfwWaitEvents();
    //CGL_window_poll_events(window);
    if(CGL_window_get_key(g_State.window, CGL_KEY_ESCAPE) == CGL_PRESS) return CGL_FALSE;

    return CGL_TRUE;
}

int main()
{   
    if (!init()) return EXIT_FAILURE;

#ifdef CGL_WASM
    CGL_info("Running in WASM mode");
    emscripten_request_animation_frame_loop(loop, NULL);
#else
    while(!CGL_window_should_close(g_State.window))
    { 
        if(!loop(0.0, NULL)) break;
    }
    cleanup();    
#endif

    return EXIT_SUCCESS;
}

```

`examples/c/3d_raycaster.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_EXCLUDE_AUDIO
#define CGL_EXCLUDE_NETWORKING
#define CGL_IMPLEMENTATION
#include "cgl.h"

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

#ifdef CGL_WASM
#include <emscripten/emscripten.h>
#include <emscripten/html5.h>
#else 
#define EM_BOOL int
#endif


static const char* PASS_THROUGH_VERTEX_SHADER_SOURCE = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
"in vec4 position;\n"
"in vec4 normal;\n"
"in vec4 texcoord;\n"
#else
"#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 normal;\n"
"layout (location = 2) in vec4 texcoord;\n"
#endif
"\n"
"out vec3 Position;\n"
"out vec2 TexCoord;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = vec4(position.xyz, 1.0f);\n"
"	Position = position.xyz;\n"
"	TexCoord = texcoord.xy;\n"
"}";

static const char* PASS_THROUGH_FRAGMENT_SHADER_SOURCE = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
#else
"#version 430 core\n"
#endif
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Position;\n"
"in vec2 TexCoord;\n"
"\n"
"uniform sampler2D u_texMap;\n"
"uniform sampler2D u_tex;\n"
"uniform sampler2D u_texSky;\n"
"uniform float u_fov;\n"
"uniform vec2 u_ppos;\n"
"uniform float u_dir;\n"
"uniform float u_map_size;\n"
"uniform int u_rays;\n"
"\n"
"float get_angle(vec2 uv)\n"
"{\n"
"   float angle = u_dir - u_fov * 0.5f + u_fov * uv.x;\n"
"   return angle;\n"
"}\n"
"\n"
"float get_wall_uvx(vec2 uv, vec4 data)\n"
"{\n"
"	float ray_angle = get_angle(uv);\n"
"   float ray_hit_x = u_ppos.x + data.x * cos(ray_angle);\n"
"   float ray_hit_y = u_ppos.y + data.x * sin(ray_angle);\n"
"   if (data.y > 0.5f) {\n"
"       return ray_hit_x - ( floor(ray_hit_x * u_map_size) / u_map_size );\n"
"   } else {\n"
"       return ray_hit_y - ( floor(ray_hit_y * u_map_size) / u_map_size );\n"
"   }\n"
"}\n"
"\n"
"vec3 wall_color(vec4 data, vec2 uv, float lineHeight)\n"
"{\n"
"   vec3 color = vec3(0.0f);\n"
"   float yOffset = (1.0f - lineHeight) * 0.5f;\n"
"   vec2 texCoord = vec2(0.0f);\n"
"   texCoord.y = (uv.y - yOffset) / lineHeight;\n"
"   texCoord.y = texCoord.y * 0.2 + data.w;\n"
"   texCoord.x = get_wall_uvx(uv, data) * u_map_size * 0.2 + data.z;\n"
"   color = texture(u_texMap, texCoord).xyz;\n"
"   color *= (0.8 + data.y); \n // wall\n"
"   return color;\n"
"}\n"
"\n"
"vec3 floor_color(vec4 data, vec2 uv, float lineHeight)\n"
"{\n"
"   vec3 color = vec3(0.0f);\n"
"   float yOffset = (1.0f - lineHeight) * 0.5f;\n"
"   vec2 texCoord = vec2(0.0f);\n"
"   texCoord.y = (uv.y * yOffset);\n"
"   texCoord.y = texCoord.y;\n"
"   texCoord.x = get_wall_uvx(uv, data) * u_map_size * 0.2 + 0.6;\n"
"   color = texture(u_texMap, texCoord).xyz;\n"
"   color *= (0.8 + data.y); \n // wall\n"
"   return mix ( vec3(0.1f, texCoord.y + 0.2, 0.1f), color, pow(texCoord.y, 2.0f));\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"   vec2 uv = vec2(TexCoord.y, 1.0f - TexCoord.x);\n"
"	vec4 data= texture(u_tex, uv);\n"
"	vec3 color = vec3(0.0f);\n"
"   float lineHeight = data.r * cos(get_angle(uv) - u_dir);\n"
"   lineHeight = 0.01 / (lineHeight  * lineHeight + 0.000001f);\n"
"   if (uv.y < 0.5f - lineHeight * 0.5f) {\n"
"       color = floor_color(data, uv, lineHeight);\n"
"   } else if (uv.y > 0.5f + lineHeight * 0.5f) {\n"
"       color = texture(u_texSky, vec2(uv.x + u_dir, uv.y)).xyz;\n"
"   } else {\n"
"       color = wall_color(data, uv, lineHeight);\n"
"   }\n"
"	FragColor = vec4(color, 1.0f);\n"
"}";


#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))

#define WINDOW_WIDTH         1600
#define WINDOW_HEIGHT        800
#define GAME_WIDTH           800
#define GAME_HEIGHT          600
#define MAP_SIZE             30
#define MAP_EDITOR_SIZE      600
#define MAP_EDITOR_TILE_SIZE ( MAP_EDITOR_SIZE / MAP_SIZE )
#define NUM_TILE_TEXTURES    20
#define TEXTURE_TILE_WIDTH   0.2f
#define TEXTURE_TILE_HEIGHT  0.25f
#define PLAYER_FOV			 CGL_deg_to_rad( 45.0f )

#define SAMPLE_MAP(x, y)	 ( MAP[ ( ( y ) * MAP_SIZE ) + ( x ) ] )

static CGL_byte MAP[] = {
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1,
	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1,
	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1,
	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1,
	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1,
	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1,
	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1,
	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1,
	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
};

static CGL_texture* g_TilemapTexture = NULL;
static CGL_texture* g_SkyTexture = NULL;
static CGL_float g_TilemapOffset[NUM_TILE_TEXTURES][2] = {
	{ TEXTURE_TILE_WIDTH * 0.0f, TEXTURE_TILE_HEIGHT * 1.2f * 0.0f},
	{ TEXTURE_TILE_WIDTH * 1.0f, TEXTURE_TILE_HEIGHT * 0.0f},
	{ TEXTURE_TILE_WIDTH * 2.0f, TEXTURE_TILE_HEIGHT * 0.0f},
	{ TEXTURE_TILE_WIDTH * 3.0f, TEXTURE_TILE_HEIGHT * 0.0f},
	{ TEXTURE_TILE_WIDTH * 4.0f, TEXTURE_TILE_HEIGHT * 0.0f},
	{ TEXTURE_TILE_WIDTH * 0.0f, TEXTURE_TILE_HEIGHT * 1.0f},
	{ TEXTURE_TILE_WIDTH * 1.0f, TEXTURE_TILE_HEIGHT * 1.0f},
	{ TEXTURE_TILE_WIDTH * 2.0f, TEXTURE_TILE_HEIGHT * 1.0f},
	{ TEXTURE_TILE_WIDTH * 3.0f, TEXTURE_TILE_HEIGHT * 1.0f},
	{ TEXTURE_TILE_WIDTH * 4.0f, TEXTURE_TILE_HEIGHT * 1.0f},
	{ TEXTURE_TILE_WIDTH * 0.0f, TEXTURE_TILE_HEIGHT * 2.0f},
	{ TEXTURE_TILE_WIDTH * 1.0f, TEXTURE_TILE_HEIGHT * 2.0f},
	{ TEXTURE_TILE_WIDTH * 2.0f, TEXTURE_TILE_HEIGHT * 2.0f},
	{ TEXTURE_TILE_WIDTH * 3.0f, TEXTURE_TILE_HEIGHT * 2.0f},
	{ TEXTURE_TILE_WIDTH * 4.0f, TEXTURE_TILE_HEIGHT * 2.0f},
	{ TEXTURE_TILE_WIDTH * 0.0f, TEXTURE_TILE_HEIGHT * 3.0f},
	{ TEXTURE_TILE_WIDTH * 1.0f, TEXTURE_TILE_HEIGHT * 3.0f},
	{ TEXTURE_TILE_WIDTH * 2.0f, TEXTURE_TILE_HEIGHT * 3.0f},
	{ TEXTURE_TILE_WIDTH * 3.0f, TEXTURE_TILE_HEIGHT * 3.0f},
	{ TEXTURE_TILE_WIDTH * 4.0f, TEXTURE_TILE_HEIGHT * 3.0f}
};

static CGL_window* g_Window = NULL;
static CGL_framebuffer* g_Framebuffer = NULL;
static CGL_float g_RayCastResult[GAME_WIDTH * 4] = {0.0f};

static struct {
	CGL_int selectedTile;
	CGL_tilemap* tilemap;
} g_MapEditor;

static struct {
	CGL_vec2 position;
	CGL_float direction;
	CGL_bool mouseLocked;
	CGL_vec2 prevMousePos;

	CGL_shader* raycastShader;
	CGL_texture* raycastData;
	CGL_framebuffer* gameView;
} g_Game;


// ---------------------------------------------------------------
// ---------------------- UTILS ----------------------------------
// ---------------------------------------------------------------

CGL_texture* load_texture(const char* path)
{
	int width, height, channels;
	unsigned char* data = stbi_load(path, &width, &height, &channels, 0);
	if (data == NULL) return NULL;

	CGL_image img = {
		.bytes_per_channel = 8,
		.channels = channels,
		.height = height,
		.width = width,
		.data = data
	};

	CGL_texture* texture = CGL_texture_create(&img);

	stbi_image_free(data);

	return texture;
}



CGL_bool raycast_single(CGL_float px, CGL_float py, CGL_float dir, CGL_int* wx, CGL_int* wy, CGL_float* dst, CGL_bool* hOv)
{
	// make 

	if (dir > CGL_PI) dir -= 2.0f * CGL_PI;
	else if (dir < -CGL_PI) dir += 2.0f * CGL_PI;

	// for horizontal lines
	CGL_int wx_h = -1, wy_h = -1;
	CGL_float dst_h = 1.0f;
	// if (fasle)
	{

		CGL_float tDir = tanf(CGL_PI_2 - dir);
		CGL_bool up = dir > 0.0f;


		CGL_float nextY = floorf(py * MAP_SIZE + (up ? 1.0f : 0.0f)) / MAP_SIZE + (up ? 0.00001f : -0.0001f);
		CGL_float nextX = px + (nextY - py) * tDir;
		
		CGL_float yStep = (up ? 1.0f : -1.0f) / MAP_SIZE;
		CGL_float xStep = yStep * tDir;


		while (nextX >= 0.0f && nextX <= 1.0f && nextY >= 0.0f && nextY <= 1.0f) {
			CGL_int x = (CGL_int)(nextX * MAP_SIZE);
			CGL_int y = (CGL_int)(nextY * MAP_SIZE);

			// CGL_widgets_add_circle2fr(nextX, nextY, 0.002f, 8);

			if (SAMPLE_MAP(x, y) > 0) {
				wx_h = x;
				wy_h = y;
				dst_h = sqrtf((nextX - px) * (nextX - px) + (nextY - py) * (nextY - py));
				break;
			}

			nextX += xStep;
			nextY += yStep;
		}

	}

	// for vertical lines
	CGL_int wx_v = -1, wy_v = -1;
	CGL_float dst_v = 100000.0f;
	//if(false)
	{

        CGL_float tDir = tanf(dir);
		CGL_bool right = (dir <= CGL_PI_2 && dir >= -CGL_PI_2);

		CGL_float nextX = floorf(px * MAP_SIZE + (right ? 1.0f : 0.0f)) / MAP_SIZE + (right ? 0.00001f : -0.0001f);
		CGL_float nextY = py + (nextX - px) * tDir;
		
		CGL_float xStep = (right ? 1.0f : -1.0f) / MAP_SIZE;
		CGL_float yStep = xStep * tDir;
		
		while (nextX >= 0.0f && nextX <= 1.0f && nextY >= 0.0f && nextY <= 1.0f) {
			CGL_int x = (CGL_int)(nextX * MAP_SIZE);
			CGL_int y = (CGL_int)(nextY * MAP_SIZE);
		
			//CGL_widgets_add_circle2fr(nextX, nextY, 0.002f, 8);

			if (SAMPLE_MAP(x, y) > 0) {
				wx_v = x;
				wy_v = y;
				dst_v = sqrtf((nextX - px) * (nextX - px) + (nextY - py) * (nextY - py));
				break;
			}
			
			nextX += xStep;
			nextY += yStep;
		}

		if (wx_v == -1) {
			dst_v = sqrtf((nextX - px) * (nextX - px) + (nextY - py) * (nextY - py));
		}
	}

	if (dst_h < dst_v) {
		*wx = wx_h;
		*wy = wy_h;
		*dst = dst_h;
		if (hOv) *hOv = true;
	}
	else {
		*wx = wx_v;
		*wy = wy_v;
		*dst = dst_v;
		if (hOv) *hOv = false;
	}

	return (*wx != -1 && *wy != -1);
}

// ---------------------------------------------------------------
// ---------------------- MAP EDITOR -----------------------------
// ---------------------------------------------------------------

static CGL_void upload_tilemap_data()
{
	static CGL_vec3 s_TileColor;
	for (CGL_int y = 0; y < MAP_SIZE; y++)
	{
		for (CGL_int x = 0; x < MAP_SIZE; x++)
		{
			CGL_int tileID = SAMPLE_MAP(x, y);
			if (tileID != 0)
			{
				CGL_float* tile = g_TilemapOffset[tileID - 1];
				CGL_tilemap_set_tile_color(g_MapEditor.tilemap, x, y, s_TileColor.x, s_TileColor.y, s_TileColor.z);
				CGL_tilemap_set_tile_texture_from_tileset(g_MapEditor.tilemap, x, y, tile[0], tile[1], TEXTURE_TILE_WIDTH, TEXTURE_TILE_HEIGHT);
			}
			else {
				CGL_tilemap_set_tile_color(g_MapEditor.tilemap, x, y, 0.1f, 0.1f, 0.1f);
			}
		}
	}
	CGL_tilemap_upload(g_MapEditor.tilemap);
}

static CGL_bool setup_map()
{
	// Create tilemap
    CGL_info("Setting up map");
	g_TilemapTexture = load_texture("assets/doomtilemap.png"); // https://i.ibb.co/jDvNj9f/doomtilemap.png
    CGL_info("Loaded tilemap texture");
	g_SkyTexture = load_texture("assets/skylowres.png"); // https://i.ibb.co/ZWBghVy/skylowres.png
    CGL_info("Loaded sky texture");
	g_MapEditor.tilemap = CGL_tilemap_create(MAP_SIZE, MAP_SIZE, MAP_EDITOR_TILE_SIZE, MAP_EDITOR_TILE_SIZE, 1);
    CGL_info("Created tilemap...");
	CGL_tilemap_set_auto_upload(g_MapEditor.tilemap, CGL_FALSE);
	upload_tilemap_data();
    CGL_info("Uploaded initial tilemap data");
	return true;
}

static void update_map_editor(CGL_float mx, CGL_float my)
{
	mx *= (CGL_float)WINDOW_WIDTH / WINDOW_HEIGHT;
	my = 1.0f - my;

	CGL_float xTM = 200.0f / WINDOW_WIDTH;
	CGL_float yTM = 200.0f / WINDOW_HEIGHT;
	CGL_float sTM = (CGL_float)MAP_EDITOR_SIZE / WINDOW_HEIGHT;

	CGL_float tileMapPosX = (mx - xTM);
	CGL_float tileMapPosY = (my - yTM);

	CGL_float tilePosX = tileMapPosX / sTM;
	CGL_float tilePosY = tileMapPosY / sTM;


	if (CGL_aabb_contains_point(CGL_vec2_init(xTM, yTM), CGL_vec2_init(xTM + sTM, yTM + sTM), CGL_vec2_init(mx, my)))
	{
		CGL_int tileX = (CGL_int)(tilePosX * MAP_SIZE);
		CGL_int tileY = (CGL_int)(tilePosY * MAP_SIZE);

		if (CGL_window_get_mouse_button(g_Window, CGL_MOUSE_BUTTON_LEFT) == CGL_PRESS)
		{
			SAMPLE_MAP(tileX, tileY) = (CGL_byte)g_MapEditor.selectedTile;
		}
		else if (CGL_window_get_mouse_button(g_Window, CGL_MOUSE_BUTTON_RIGHT) == CGL_PRESS)
		{
			SAMPLE_MAP(tileX, tileY) = 0;
		}

		if (CGL_window_get_mouse_button(g_Window, CGL_MOUSE_BUTTON_MIDDLE) == CGL_PRESS)
		{
			g_MapEditor.selectedTile = SAMPLE_MAP(tileX, tileY);
		}
	}

	CGL_float scalingFactor = ((CGL_float)MAP_EDITOR_SIZE / WINDOW_HEIGHT) * 2.0f;
	// CGL_widgets_begin_int((CGL_float)WINDOW_HEIGHT / WINDOW_WIDTH * scalingFactor, 1.0f * scalingFactor, -0.5f, 0.25f); // for [-1, -1] to [1, 1]
	CGL_widgets_begin_int((CGL_float)WINDOW_HEIGHT / WINDOW_WIDTH * scalingFactor, 1.0f * scalingFactor, -0.875f, -0.5f); // for [0, 0] to [1, 1]

	CGL_vec2 startPos = g_Game.position;
	CGL_vec2 direction = CGL_vec2_from_angle(g_Game.direction);

	CGL_int wx = -1, wy = -1;
	CGL_float dst = 1.0f;
	// add 2 more rays at +- FOV/2
	CGL_widgets_set_stroke_thickness(0.002f);
	CGL_widgets_set_fill_colorf(0.8f, 0.3f, 0.3f, 1.0f);

	CGL_float startAngle = g_Game.direction - PLAYER_FOV * 0.5f;
	CGL_int numRays = 8;
	CGL_widgets_set_stroke_colorf(0.3f, 0.3f, 0.3f, 1.0f);
	for ( CGL_int i = 0; i < numRays; i++ )
	{
		CGL_float angle = startAngle + (CGL_float)i / (CGL_float)(numRays - 1) * PLAYER_FOV;
		CGL_bool hit = raycast_single(startPos.x, startPos.y, angle, &wx, &wy, &dst, NULL);
        (void)hit;
		direction = CGL_vec2_from_angle(angle);
		CGL_vec2 endPos = CGL_vec2_add_(startPos, CGL_vec2_scale_(direction, dst));
		CGL_widgets_set_stroke_colorf(0.3f, 0.3f, 0.3f, 1.0f);
		CGL_widgets_add_line2f(startPos.x, startPos.y, endPos.x, endPos.y);
		CGL_widgets_add_circle2fr(startPos.x, startPos.y, 0.01f, 8);
	}
	
	direction = CGL_vec2_from_angle(g_Game.direction);
	CGL_bool hit = raycast_single(startPos.x, startPos.y, g_Game.direction, &wx, &wy, &dst, NULL);
    (void)hit;
	CGL_vec2 endPos = CGL_vec2_add_(startPos, CGL_vec2_scale_(direction, dst));
	CGL_widgets_set_stroke_colorf(0.8f, 0.3f, 0.3f, 1.0f);
	CGL_widgets_add_line2f(startPos.x, startPos.y, endPos.x, endPos.y);
	CGL_widgets_add_circle2fr(startPos.x, startPos.y, 0.01f, 8);


	CGL_widgets_end();
}

static void render_map_editor(CGL_float mx, CGL_float my)
{

	CGL_tilemap_render(
		g_MapEditor.tilemap,
		1.0f, 1.0f,
		100.0, 200.f,
		g_TilemapTexture);

	update_map_editor(mx, my);
	upload_tilemap_data();


	// ui for selecting texture

	CGL_widgets_begin_int((CGL_float)WINDOW_HEIGHT / WINDOW_WIDTH, 1.0f, 0.0f, 0.0f);

	mx = (mx - 0.5f) * 2.0f;
	my = (0.5f - my) * 2.0f;

	mx *= (CGL_float)WINDOW_WIDTH / WINDOW_HEIGHT;
	CGL_float xStart = -(CGL_float)WINDOW_WIDTH / WINDOW_HEIGHT + 0.05f;
	CGL_float yStart = -0.7f;

	for (int i = 0; i < 20; i++)
	{

		if (CGL_aabb_contains_point(CGL_vec2_init(xStart, yStart), CGL_vec2_init(xStart + 0.10f, yStart + 0.10f), CGL_vec2_init(mx, my))) {
			if (CGL_window_get_mouse_button(g_Window, CGL_MOUSE_BUTTON_LEFT) == CGL_PRESS) {
				g_MapEditor.selectedTile = i;
			}
			CGL_widgets_set_fill_colorf(0.9f, 0.5f, 0.9f, 1.0f);
			CGL_widgets_add_rect2f(xStart - 0.005f, yStart - 0.005f, 0.11f, 0.11f);
		}

		if (i == g_MapEditor.selectedTile) {
			CGL_widgets_set_fill_colorf(0.9f, 0.9f, 0.9f, 1.0f);
			CGL_widgets_add_rect2f(xStart - 0.005f, yStart - 0.005f, 0.11f, 0.11f);
		}

		if (i == 0) CGL_widgets_set_fill_colorf(0.6f, 0.6f, 0.6f, 1.0f);
		else {
			CGL_widgets_set_texture(g_TilemapTexture);
			CGL_float* offset = g_TilemapOffset[i - 1];
			CGL_widgets_set_texture_coordinate_so(0.2f, 0.25f, offset[0], offset[1]);
		}
		CGL_widgets_add_rect2f(xStart, yStart, 0.10f, 0.10f);


		xStart += 0.12f;

		if (xStart >= (0.0f - 0.3f)) {
			xStart = -(CGL_float)WINDOW_WIDTH / WINDOW_HEIGHT + 0.05f;
			yStart -= 0.12f;
		}
	}

	CGL_widgets_end();
}


// ---------------------------------------------------------------
// ---------------------- GAME -----------------------------------
// ---------------------------------------------------------------

CGL_bool setup_game()
{
	g_Game.position = CGL_vec2_init(0.5f, 0.5f);
	g_Game.direction = 0.0f;

	g_Game.raycastShader = CGL_shader_create(PASS_THROUGH_VERTEX_SHADER_SOURCE, PASS_THROUGH_FRAGMENT_SHADER_SOURCE, NULL);
	g_Game.gameView = CGL_framebuffer_create(GAME_WIDTH, GAME_HEIGHT);

	g_Game.raycastData = CGL_texture_create_blank(GAME_WIDTH, 1, GL_RGBA, GL_RGBA32F, GL_FLOAT);



	return true;
}

CGL_void calculate_raycast_map()
{
	CGL_float stepSize = PLAYER_FOV / (CGL_float)GAME_WIDTH;
	CGL_float angle = g_Game.direction - PLAYER_FOV * 0.5f;

	CGL_int wx = 0, wy = 0;
	CGL_float dst = 10000.0f;
	CGL_bool hOv = false;

	for (int i = 0; i < GAME_WIDTH; i++, angle += stepSize)
	{
		if (raycast_single(g_Game.position.x, g_Game.position.y, angle, &wx, &wy, &dst, &hOv))
		{
			CGL_int tileID = SAMPLE_MAP(wx, wy) - 1;
			CGL_float* offset = g_TilemapOffset[tileID];
			CGL_float* result = &g_RayCastResult[i * 4];

			// CGL_float angDiff = angle - g_Game.direction; if (angDiff < 0.0f) angDiff += 2.0f * CGL_PI; if (angDiff > CGL_PI) angDiff = angDiff - 2.0f * CGL_PI;
			//CGL_float  dstToWall = dst * cosf (angDiff);
			result[0] = dst, result[1] = hOv ? 1.0f: 0.0f, result[2] = offset[0], result[3] = offset[1];
		}
		else
		{
			g_RayCastResult[i * 4] = -1.0f;
		}
	}

	CGL_texture_set_data(g_Game.raycastData, g_RayCastResult);
}

CGL_int get_player_pos_map(CGL_float x, CGL_float y)
{
	CGL_int wx = (CGL_int)(x * (CGL_float)MAP_SIZE);
	CGL_int wy = (CGL_int)(y * (CGL_float)MAP_SIZE);

	return SAMPLE_MAP(wx, wy);
}

CGL_void update_player_pos(CGL_float sideWays, CGL_float forward)
{
	// forward
	CGL_float dx = cosf(g_Game.direction) * forward;
	CGL_float dy = sinf(g_Game.direction) * forward;
	CGL_float currX = g_Game.position.x;
	CGL_float currY = g_Game.position.y;

	const CGL_float PADDING = 50.0f;

	if (get_player_pos_map(currX + dx * PADDING, currY + dy * PADDING) == 0) {
		g_Game.position.x += dx;
		g_Game.position.y += dy;
	}
	else if (get_player_pos_map(currX + dx * PADDING, currY) == 0) {
		g_Game.position.x += dx;
	}
	else if (get_player_pos_map(currX, currY + dy * PADDING) == 0) {
		g_Game.position.y += dy;
	}

	// sideways
	dx = cosf(g_Game.direction + CGL_PI * 0.5f) * sideWays;
	dy = sinf(g_Game.direction + CGL_PI * 0.5f) * sideWays;

	if (get_player_pos_map(currX + dx * PADDING, currY + dy * PADDING) == 0) {
		g_Game.position.x += dx;
		g_Game.position.y += dy;
	}
	else if (get_player_pos_map(currX + dx * PADDING, currY) == 0) {
		g_Game.position.x += dx;
	}
	else if (get_player_pos_map(currX, currY + dy * PADDING) == 0) {
		g_Game.position.y += dy;
	}
}

CGL_void update_game()
{
	if (CGL_window_is_key_pressed(g_Window, CGL_KEY_L)) {
		CGL_double mx, my;
		CGL_window_get_mouse_position(g_Window, &mx, &my);
		g_Game.prevMousePos = CGL_vec2_init((CGL_float)mx, (CGL_float)my);
		g_Game.mouseLocked = true;
		glfwSetInputMode(CGL_window_get_glfw_handle(g_Window), GLFW_CURSOR, GLFW_CURSOR_HIDDEN);
	}
	else if (CGL_window_is_key_pressed(g_Window, CGL_KEY_U)) {
		g_Game.mouseLocked = false;
		glfwSetInputMode(CGL_window_get_glfw_handle(g_Window), GLFW_CURSOR, GLFW_CURSOR_NORMAL);
	}

	if (g_Game.mouseLocked) {
		CGL_double mx = 0.0, my = 0.0;
		CGL_window_get_mouse_position(g_Window, &mx, &my);
		CGL_vec2 mousePos = CGL_vec2_init((CGL_float)mx, (CGL_float)my);
		CGL_vec2 delta = CGL_vec2_sub(mousePos, g_Game.prevMousePos);
		// g_Game.prevMousePos = mousePos;
		glfwSetCursorPos(CGL_window_get_glfw_handle(g_Window), g_Game.prevMousePos.x, g_Game.prevMousePos.y);

		g_Game.direction -= delta.x * 0.003f;
		// make sure g_Game.direction  stays within -PI and PI
		if (g_Game.direction > CGL_PI) g_Game.direction -= 2.0f * CGL_PI;
		else if (g_Game.direction < -CGL_PI) g_Game.direction += 2.0f * CGL_PI;

		if (CGL_window_is_key_pressed(g_Window, CGL_KEY_W)) {
			update_player_pos(0.0f, 0.0008f);
		}
		else if (CGL_window_is_key_pressed(g_Window, CGL_KEY_S)) {
			update_player_pos(0.0f, -0.0008f);
		}
		if (CGL_window_is_key_pressed(g_Window, CGL_KEY_A)) {
			update_player_pos(0.0008f, 0.0f);
		}
		else if (CGL_window_is_key_pressed(g_Window, CGL_KEY_D)) {
			update_player_pos(-0.0008f, 0.0f);
		}

	}

	calculate_raycast_map();


}

CGL_void render_game()
{
	update_game();

	CGL_widgets_begin();

	CGL_float height = (CGL_float)GAME_HEIGHT / (CGL_float)GAME_WIDTH;
	height *=  (CGL_float)WINDOW_WIDTH / (CGL_float)WINDOW_HEIGHT;

	CGL_widgets_set_texture(CGL_framebuffer_get_color_texture(g_Game.gameView));
	CGL_widgets_add_rect2f(-0.05f, -1.0f + height * 0.25f, 1.0f, height);

	CGL_widgets_end();


	CGL_framebuffer_bind (g_Game.gameView);
	CGL_gl_clear(0.0f, 0.0f, 0.1f, 1.0f);
	CGL_shader_bind(g_Game.raycastShader);
	CGL_shader_set_uniform_int(g_Game.raycastShader, CGL_shader_get_uniform_location(g_Game.raycastShader, "u_tex"), CGL_texture_bind(g_Game.raycastData, 5));
	CGL_shader_set_uniform_int(g_Game.raycastShader, CGL_shader_get_uniform_location(g_Game.raycastShader, "u_texMap"), CGL_texture_bind(g_TilemapTexture, 6));
	CGL_shader_set_uniform_int(g_Game.raycastShader, CGL_shader_get_uniform_location(g_Game.raycastShader, "u_texSky"), CGL_texture_bind(g_SkyTexture, 4));
	CGL_shader_set_uniform_int(g_Game.raycastShader, CGL_shader_get_uniform_location(g_Game.raycastShader, "u_rays"), GAME_WIDTH);
	CGL_shader_set_uniform_float(g_Game.raycastShader, CGL_shader_get_uniform_location(g_Game.raycastShader, "u_fov"), PLAYER_FOV);
	CGL_shader_set_uniform_float(g_Game.raycastShader, CGL_shader_get_uniform_location(g_Game.raycastShader, "u_dir"), g_Game.direction);
	CGL_shader_set_uniform_float ( g_Game.raycastShader, CGL_shader_get_uniform_location(g_Game.raycastShader, "u_map_size"), (CGL_float)MAP_SIZE);
	CGL_shader_set_uniform_vec2v ( g_Game.raycastShader, CGL_shader_get_uniform_location(g_Game.raycastShader, "u_ppos"), g_Game.position.x, g_Game.position.y);
	CGL_gl_render_screen_quad();

}

// ---------------------------------------------------------------
// ---------------------- MAIN -----------------------------------
// ---------------------------------------------------------------



CGL_bool init() {
    srand((uint32_t)time(NULL));
	if(!CGL_init()) return CGL_FALSE;
	g_Window = CGL_window_create(WINDOW_WIDTH, WINDOW_HEIGHT, "CGL Raycaster 3D - Jaysmito Mukherjee");
	if (g_Window == NULL) return CGL_FALSE;
	CGL_window_make_context_current(g_Window);
	if(!CGL_gl_init()) return CGL_FALSE;
	if(!CGL_widgets_init()) return CGL_FALSE;
	g_Framebuffer = CGL_framebuffer_create_from_default(g_Window);
	if (!setup_map()) return CGL_FALSE;
	if (!setup_game()) return CGL_FALSE;

    return CGL_TRUE;
}

void cleanup() {
	CGL_shader_destroy(g_Game.raycastShader);
	CGL_framebuffer_destroy(g_Game.gameView);
	CGL_texture_destroy(g_Game.raycastData);
	CGL_texture_destroy(g_TilemapTexture);
	CGL_texture_destroy(g_SkyTexture);	
	CGL_framebuffer_destroy(g_Framebuffer);
	CGL_widgets_shutdown();
	CGL_gl_shutdown();
	CGL_window_destroy(g_Window);
	CGL_shutdown();
}


EM_BOOL loop(double time, void* userData)
{
    (void)time;
    (void)userData;


#ifndef CGL_WASM
    CGL_window_set_size(g_Window, WINDOW_WIDTH, WINDOW_HEIGHT);
#endif

	static int frame_count = 0;
	frame_count++;
	int wx, wy;
	double mxp, myp;
	CGL_window_get_framebuffer_size(g_Window, &wx, &wy);
	CGL_window_get_mouse_position(g_Window, &mxp, &myp);
	mxp = (mxp / wx);
	myp = (myp / wy);

	CGL_framebuffer_bind(g_Framebuffer);
	CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);

	render_map_editor((CGL_float)mxp, (CGL_float)myp);
	render_game();

	if (CGL_window_is_key_pressed(g_Window, CGL_KEY_ESCAPE)) return CGL_FALSE;

	CGL_window_swap_buffers(g_Window);
	CGL_window_poll_events(g_Window);
    
    return CGL_TRUE;
}


// NOTE: This will not work with WASM for now as SSBOs are not supported in WebGL
int main()
{
    if (!init()) return EXIT_FAILURE;

#ifdef CGL_WASM
    CGL_info("Running in WASM mode");
    emscripten_request_animation_frame_loop(loop, NULL);
#else
	while (!CGL_window_should_close(g_Window))
	{
        if (!loop(0.0, NULL)) break;		
	}
    cleanup();
#endif
	return EXIT_SUCCESS;
}


```

`examples/c/3d_widgets.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/


#define CGL_EXCLUDE_NETWORKING
#define CGL_EXCLUDE_AUDIO
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#include "cgl.h"


#ifdef CGL_WASM
#include <emscripten/emscripten.h>
#include <emscripten/html5.h>
#else 
#define EM_BOOL int
#endif

static struct
{
    CGL_window* window; // the main window
    int window_height;
    int window_width;
    CGL_framebuffer* framebuffer;
    CGL_float curr_time;
    CGL_mesh_cpu* mesh;
} g_State;

CGL_bool init() {
    srand((uint32_t)time(NULL));
    g_State.window_height = 600;
    g_State.window_width = 600;

    if(!CGL_init()) return CGL_FALSE;
    g_State.window = CGL_window_create(g_State.window_width, g_State.window_height, "Tests - Jaysmito Mukherjee"); // create the window
    if(g_State.window == NULL) return CGL_FALSE; // failed to create window
    CGL_window_make_context_current(g_State.window); // make the opengl context for the window current
    if(!CGL_gl_init()) return CGL_FALSE; // initialize opengl
    g_State.framebuffer = CGL_framebuffer_create_from_default(g_State.window); // load the default framebuffer (0) into CGL_framebuffer object
    if(g_State.framebuffer == NULL) return CGL_FALSE; // failed
    if(!CGL_widgets_init()) return CGL_FALSE;
    g_State.curr_time = 0.0f;
    g_State.mesh = CGL_mesh_cpu_cube(false);
    CGL_mesh_cpu_recalculate_normals(g_State.mesh);
    return CGL_TRUE;
}

CGL_void cleanup() {
    // cleanup
    CGL_mesh_cpu_destroy(g_State.mesh);
    CGL_widgets_shutdown();
    CGL_framebuffer_destroy(g_State.framebuffer); // destory framebuffer object
    CGL_gl_shutdown(); // shutdown cgl opengl module
    CGL_window_destroy(g_State.window); // destroy window
    CGL_shutdown(); // shutdown cgl and clean up resources allocated by CGL internally (if any)
}

EM_BOOL loop(double _time, void* userData) {
    (void)_time;
    (void)userData;

    g_State.curr_time = CGL_utils_get_time();
    CGL_window_set_size(g_State.window, g_State.window_width, g_State.window_height); // set window size
    // rendering
    CGL_framebuffer_bind(g_State.framebuffer); // bind default framebuffer and also adjust viewport size and offset
    CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f); // clear screen with a dark gray color

    CGL_widgets_begin();
    srand((CGL_uint)time(NULL));

    CGL_mat4 proj = CGL_mat4_perspective(CGL_deg_to_rad(45.0f), 1.0f, 0.01f, 100.0f);
    CGL_mat4 view = CGL_mat4_look_at(CGL_vec3_init(sinf(g_State.curr_time) * 5.0f, 2.0f, cosf(g_State.curr_time) * 5.0f), CGL_vec3_init(0.0f, 0.0f, 0.0f), CGL_vec3_init(0.0f, 1.0f, 0.0f));
    CGL_mat4 model = CGL_mat4_scale(0.5f, 0.5f, 0.5f);

        
    CGL_widgets_set_projection_matrix(&proj); CGL_widgets_set_view_matrix(&view); CGL_widgets_set_model_matrix(&model);
        
    CGL_widgets_enable_diffuse_shading(CGL_vec3_init(10.0f, 10.0f, 0.0f), CGL_vec3_init(1.0f, 1.0f, 1.0f));
    glEnable(GL_DEPTH_TEST);
    CGL_color color = CGL_utils_random_color();
    CGL_widgets_set_fill_colorf(color.x, color.y, color.z, 1.0f);
    CGL_widgets_add_mesh(g_State.mesh);

    CGL_widgets_set_projection_matrix(NULL); CGL_widgets_set_view_matrix(NULL); CGL_widgets_set_model_matrix(NULL);
    CGL_widgets_disable_diffuse_shading();

    CGL_widgets_add_rect2f(-1.0f, 0.0f, 0.1f, 0.1f);
        
    CGL_widgets_end();

    CGL_window_swap_buffers(g_State.window); // swap framebuffers
    CGL_window_poll_events(g_State.window); // poll events (if this is not called every frame window will stop responding)

    if(CGL_window_get_key(g_State.window, CGL_KEY_ESCAPE) == CGL_PRESS) return CGL_FALSE; // exit if escape key is pressed

    return CGL_TRUE;
}

int main()
{
    if (!init()) return EXIT_FAILURE; // initialize the application
#ifdef CGL_WASM
    CGL_info("Running in WASM mode");   
    emscripten_request_animation_frame_loop(loop, NULL);
#else
    // the main loop
    while(!CGL_window_should_close(g_State.window)) // run till the close button is clicked
    {
        if (!loop(0.0, NULL)) break;
    }
    cleanup();
#endif
    
    return EXIT_SUCCESS;
}

```

`examples/c/advanced_widgets.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/


#define CGL_EXCLUDE_NETWORKING
#define CGL_EXCLUDE_AUDIO
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#include "cgl.h"


#ifdef CGL_WASM
#include <emscripten/emscripten.h>
#include <emscripten/html5.h>
#else 
#define EM_BOOL int
#endif

static struct
{
    CGL_window* window; // the main window
    int window_height;
    int window_width;
    CGL_framebuffer* framebuffer;
    CGL_float curr_time;
} g_State;

CGL_void draw_widgets() {
    CGL_widgets_begin();

    srand((uint32_t)time(NULL));
        
    CGL_widgets_set_fill_color(CGL_utils_random_color());
    CGL_widgets_set_stroke_color(CGL_utils_random_color());
    CGL_widgets_add_quad(
        CGL_vec3_init(-0.5f, -0.5f,  0.0f),    
        CGL_vec3_init( 0.5f, -0.5f,  0.0f),    
        CGL_vec3_init( 0.5f,  0.5f,  0.0f),    
        CGL_vec3_init(-0.5f,  0.5f,  0.0f)
    );
        
    CGL_widgets_set_fill_color(CGL_utils_random_color());
    CGL_widgets_set_stroke_color(CGL_utils_random_color());
    CGL_widgets_add_line(
        CGL_vec3_init(0.1f, 0.1f, 0.0f),
        CGL_vec3_init(0.8f, 0.8f, 0.0f)
    );

    CGL_widgets_set_fill_color(CGL_utils_random_color());
    CGL_widgets_set_stroke_color(CGL_utils_random_color());
    CGL_widgets_add_quad(
        CGL_vec3_init(-0.1f, -0.2f,  0.0f),    
        CGL_vec3_init( 0.2f, -0.3f,  0.0f),    
        CGL_vec3_init( 0.4f,  0.2f,  0.0f),    
        CGL_vec3_init(-0.3f,  0.8f,  0.0f)
    );
        
    CGL_widgets_set_fill_mode(false);
    CGL_widgets_set_fill_color(CGL_utils_random_color());
    CGL_widgets_set_stroke_color(CGL_utils_random_color());
    CGL_widgets_add_quad(
        CGL_vec3_init(-0.1f, -0.2f,  0.0f),    
        CGL_vec3_init( 0.2f, -0.3f,  0.0f),    
        CGL_vec3_init( 0.4f,  0.2f,  0.0f),    
        CGL_vec3_init(-0.3f,  0.8f,  0.0f)
    );


    CGL_widgets_add_triangle(
        CGL_vec3_init(-0.8f, -0.9f, 0.0f),
        CGL_vec3_init(-0.6f, 0.6f, 0.0f),
        CGL_vec3_init(-0.9f, 0.5f, 0.0f)
    );

    CGL_widgets_set_fill_mode(true);
    CGL_widgets_add_circle(CGL_vec3_init(0.0f, 0.0f, 0.0f), 0.2f);

    CGL_widgets_end();
}

CGL_bool init() {
    srand((uint32_t)time(NULL));
    g_State.window_height = 600;
    g_State.window_width = 600;

    if(!CGL_init()) return CGL_FALSE;
    g_State.window = CGL_window_create(g_State.window_width, g_State.window_height, "Advanced Widgets - Jaysmito Mukherjee"); // create the window
    if(g_State.window == NULL) return CGL_FALSE; // failed to create window
    CGL_window_make_context_current(g_State.window); // make the opengl context for the window current
    if(!CGL_gl_init()) return CGL_FALSE; // initialize opengl
    g_State.framebuffer = CGL_framebuffer_create_from_default(g_State.window); // load the default framebuffer (0) into CGL_framebuffer object
    if(g_State.framebuffer == NULL) return CGL_FALSE; // failed
    if(!CGL_widgets_init()) return CGL_FALSE;
    g_State.curr_time = 0.0f;
    return CGL_TRUE;
}

CGL_void cleanup() {
    // cleanup
    CGL_widgets_shutdown();
    CGL_framebuffer_destroy(g_State.framebuffer); // destory framebuffer object
    CGL_gl_shutdown(); // shutdown cgl opengl module
    CGL_window_destroy(g_State.window); // destroy window
    CGL_shutdown(); // shutdown cgl and clean up resources allocated by CGL internally (if any)
}

EM_BOOL loop(double _time, void* userData) {
    (void)_time;
    (void)userData;

    g_State.curr_time = CGL_utils_get_time();
    CGL_window_set_size(g_State.window, g_State.window_width, g_State.window_height); // set window size
    // rendering
    CGL_framebuffer_bind(g_State.framebuffer); // bind default framebuffer and also adjust viewport size and offset
    CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f); // clear screen with a dark gray color


    draw_widgets();
    

    CGL_window_swap_buffers(g_State.window); // swap framebuffers
    CGL_window_poll_events(g_State.window); // poll events (if this is not called every frame window will stop responding)

    if(CGL_window_get_key(g_State.window, CGL_KEY_ESCAPE) == CGL_PRESS) return CGL_FALSE; // exit if escape key is pressed

    return CGL_TRUE;
}

int main()
{
    if (!init()) return EXIT_FAILURE; // initialize the application
#ifdef CGL_WASM
    CGL_info("Running in WASM mode");   
    emscripten_request_animation_frame_loop(loop, NULL);
#else
    // the main loop
    while(!CGL_window_should_close(g_State.window)) // run till the close button is clicked
    {
        if (!loop(0.0, NULL)) break;
    }
    cleanup();
#endif
    
    return EXIT_SUCCESS;
}

```

`examples/c/approximating_pi.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/


#define CGL_EXCLUDE_NETWORKING
#define CGL_LOGGING_ENABLED
#define CGL_EXCLUDE_AUDIO
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_IMPLEMENTATION
#include "cgl.h"


#ifdef CGL_WASM
#include <emscripten/emscripten.h>
#include <emscripten/html5.h>
#else 
#define EM_BOOL int
#endif

#define MAX_POINTS 1000000

static struct
{
    CGL_window* window; // the main window
    CGL_int window_height;
    CGL_int window_width;
    CGL_framebuffer* framebuffer;


    CGL_float prev_time, curr_time, delta_time, frame_time;
    CGL_int frame_count, frame_rate;
    CGL_float point_size;
    CGL_double points_in_square, points_in_circle, pi_value;
    CGL_vec2 min_val, max_val;

    CGL_vec2 points[MAX_POINTS];
    CGL_sizei num_points;
} g_State;

CGL_bool init() {
    srand((uint32_t)time(NULL));
    if(!CGL_init()) return EXIT_FAILURE; // initialize CGL (required for setting up internals of CGL)
    g_State.window_height = g_State.window_width = 700;
    g_State.window = CGL_window_create(g_State.window_width, g_State.window_height, "Approximating PI - Jaysmito Mukherjee"); // create the window
    CGL_window_make_context_current(g_State.window); // make the opengl context for the window current
    if(!CGL_gl_init()) return EXIT_FAILURE; // initialize cgl opengl module    
    g_State.framebuffer = CGL_framebuffer_create_from_default(g_State.window); // load the default framebuffer (0) into CGL_framebuffer object
    if(!CGL_widgets_init()) return EXIT_FAILURE; 
    g_State.prev_time = CGL_utils_get_time();
    g_State.curr_time = g_State.delta_time = g_State.frame_time = 0.0f;
    g_State.frame_count = 0, g_State.frame_rate = 60;
    g_State.point_size = 0.01f;
    g_State.points_in_square = g_State.points_in_circle = 1.0;
    g_State.pi_value = 0.0;

    g_State.min_val = CGL_vec2_init(-1.0f, -1.0f);
    g_State.max_val = CGL_vec2_init(1.0f, 1.0f);

    g_State.num_points = 0;

    return CGL_TRUE;
}

CGL_void cleanup() {
    // cleanup
    CGL_widgets_shutdown();
    CGL_framebuffer_destroy(g_State.framebuffer); // destory framebuffer object
    CGL_gl_shutdown(); // shutdown cgl opengl module
    CGL_window_destroy(g_State.window); // destroy window
    CGL_shutdown(); // shutdown cgl and clean up resources allocated by CGL internally (if any)
}

EM_BOOL loop(double time, void* userData) {
    (void)time;
    (void)userData;

    g_State.curr_time = CGL_utils_get_time();
    g_State.delta_time = g_State.curr_time - g_State.prev_time; g_State.prev_time = g_State.curr_time; g_State.frame_time += g_State.delta_time; g_State.frame_count++;
    if(g_State.frame_time >= 1.0f) {
        g_State.frame_rate = g_State.frame_count;
        g_State.frame_time = 0.0f;
        g_State.frame_count = 0; 
    }

    CGL_vec2 curr_val = CGL_utils_random_vec2(g_State.min_val, g_State.max_val);

    CGL_window_set_size(g_State.window, g_State.window_width, g_State.window_height); // set the window size
    CGL_framebuffer_bind(g_State.framebuffer); // bind default framebuffer and also adjust viewport size and offset
    CGL_gl_clear(0.0f, 0.0f, 0.0f, 1.0f);
    
    
    CGL_widgets_begin();
    
    g_State.points_in_square += 1.0;
    g_State.pi_value = 4.0 * (g_State.points_in_circle / g_State.points_in_square);    
    if(CGL_vec2_length(curr_val) <= 1.0) {
        g_State.points_in_circle += 1.0;
    }

    if(g_State.num_points < MAX_POINTS) {
        g_State.points[g_State.num_points++] = curr_val;
    } else {
        // reset if we reach the max points
        g_State.num_points = 0;
    }

    for (CGL_sizei i = 0; i < g_State.num_points; i++) {
        if(CGL_vec2_length(g_State.points[i]) <= 1.0) {
            CGL_widgets_set_fill_colorf(0.0f, 0.8f, 0.0f, 1.0f);
        } else {
            CGL_widgets_set_fill_colorf(0.0f, 0.0f, 0.8f, 1.0f);
        }
        CGL_widgets_add_rect2f(g_State.points[i].x, g_State.points[i].y, g_State.point_size, g_State.point_size);
    }


    CGL_widgets_set_fill_colorf(0.0f, 0.0f, 0.0f, 1.0f);
    CGL_widgets_add_rect2f(-0.3f, -0.1f, 0.6f, 0.2f);
    
    static CGL_byte buffer[256]; sprintf(buffer, "%lf", g_State.pi_value);
    CGL_widgets_set_fill_colorf(0.7f, 0.7f, 0.7f, 1.0f);
    CGL_widgets_add_string(buffer, -0.3f, -0.1f, 0.6f, 0.2f);

    CGL_widgets_end();
    
    if(CGL_window_is_key_pressed(g_State.window, CGL_KEY_SPACE)) {
        g_State.points_in_circle = 1.0;
        g_State.points_in_square = 1.0;
        g_State.pi_value = 0.0;
        g_State.num_points = 0;
    }

    CGL_window_swap_buffers(g_State.window); // swap framebuffers
    CGL_window_poll_events(g_State.window); // poll events (if this is not called every frame window will stop responding)
    
    // quit on pressing escape
    if(CGL_window_get_key(g_State.window, CGL_KEY_ESCAPE) == CGL_PRESS) return CGL_FALSE;

    static CGL_byte title_buffer[256]; 
    sprintf(title_buffer, "Approximating PI - Jaysmito Mukherjee | FPS: %d", g_State.frame_rate);
    CGL_window_set_title(g_State.window, title_buffer);

    return CGL_TRUE;
}

int main()
{
    if(!init()) return EXIT_FAILURE;
#ifdef CGL_WASM
    CGL_info("Running in WASM mode");
    emscripten_request_animation_frame_loop(loop, NULL);
#else
     // run till the close button is clicked
    while(!CGL_window_should_close(g_State.window))  {
        if(!loop(0, NULL)) break;
    }
    cleanup();
#endif
    return EXIT_SUCCESS;
}

```

`examples/c/audio_visualizer.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/


#define CGL_LOGGING_ENABLED
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_EXCLUDE_NETWORKING
#define CGL_IMPLEMENTATION
#include "cgl.h"


#ifdef CGL_WASM
#include <emscripten/emscripten.h>
#include <emscripten/html5.h>
#else 
#define EM_BOOL int
#endif


static const char* VS_main_source = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"\n"
"in vec4 position;\n"
"in vec4 normal;\n"
"in vec4 texcoord;\n"
#else
"#version 430 core\n"
"\n"
"in layout(location = 0) vec4 position;\n"
"in layout(location = 1) vec4 normal;\n"
"in layout(location = 2) vec4 texcoord;\n"
#endif
"\n"
"\n"
"uniform mat4 projection;\n"
"uniform mat4 view;\n"
"uniform float time;\n"
"uniform float sound_level;\n"
"\n"
"\n"
"out vec3 Position;\n"
"out float Disto;\n"
"\n"
"mat4 translate(vec3 v)\n"
"{\n"
"    mat4 m = mat4(1.0f);\n"
"    m[3] = vec4(v, 1.0f);\n"
"    return m;\n"
"}\n"
"\n"
"mat4 scale(float scale)\n"
"{\n"
"    scale = clamp(scale, 0.0f, 1.0f);\n"
"    mat4 m = mat4(1.0f);\n"
"    m[0][0] = scale;\n"
"    m[1][1] = scale;\n"
"    m[2][2] = scale;\n"
"    return m;\n"
"}\n"
"\n"
"vec2 hash( vec2 p ) // replace this by something better\n"
"{\n"
"	p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n"
"	return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n"
"}\n"
"\n"
"float noise( in vec2 p )\n"
"{\n"
"    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n"
"    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n"
"\n"
"	vec2  i = floor( p + (p.x+p.y)*K1 );\n"
"    vec2  a = p - i + (i.x+i.y)*K2;\n"
"    float m = step(a.y,a.x); \n"
"    vec2  o = vec2(m,1.0-m);\n"
"    vec2  b = a - o + K2;\n"
"	vec2  c = a - 1.0 + 2.0*K2;\n"
"    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n"
"	vec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n"
"    return dot( n, vec3(70.0) );\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"    int x_id = gl_InstanceID % 100;\n"
"    int y_id = gl_InstanceID / 100;\n"
"    float x_o = float(x_id - 50) / 50.0f;\n"
"    float y_o = float(y_id - 50) / 50.0f;\n"
"    vec3 offset = vec3(x_o, 0.0f, y_o);\n"
"    float disto = (x_o * x_o + y_o * y_o);\n"
"    float dist = pow((1.0f - disto) * 0.6f, 5.0f);\n"
"    if(dist > 0.001f) dist += 0.01f;\n"
"    Disto = dist * 100.0f;\n"
"    offset *=  5.0f;\n"
"    offset.y = pow(sin(disto * 16.0f + time * 2.0f), 2.0f) * 8.0f * dist;\n"
"    offset.y += offset.y * sound_level * 4.0f;\n"
"    offset.y += noise(vec2(x_o, y_o) * 10.0f) * sound_level;\n"
"    mat4 model = translate(offset) * scale(dist);\n"
"    vec4 pos = projection * view * model * vec4(position.xyz, 1.0f);\n"
"    gl_Position = pos;\n"
"    Position = offset;\n"
"}";

static const char* FS_main_source = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
#else
"#version 430 core\n"
#endif
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Position;\n"
"in float Disto;\n"
"\n"
"uniform float time;\n"
"\n"
"void main()\n"
"{\n"
"    vec3 top_color = vec3(0.8, 0.8, 0.0);\n"
"    vec3 bottom_color = vec3(0.8, 0.1, 0.0);\n"
"    vec3 color = mix(bottom_color, top_color, pow(Position.y, 5.0f));\n"
"    vec3 back_color = vec3(0.2, 0.2, 0.2);\n"
"    FragColor = vec4(color * 1.5f, Disto);\n"
"}";

static const char* PASS_THROUGH_VERTEX_SHADER_SOURCE = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"\n"
"in vec4 position;\n"
"in vec4 normal;\n"
"in vec4 texcoord;\n"
#else
"#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 normal;\n"
"layout (location = 2) in vec4 texcoord;\n"
#endif
"\n"
"out vec3 Position;\n"
"out vec2 TexCoord;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = vec4(position.xyz, 1.0f);\n"
"	Position = position.xyz;\n"
"	TexCoord = texcoord.xy;\n"
"}";

static const char* PASS_THROUGH_FRAGMENT_SHADER_SOURCE =
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
#else
"#version 430 core\n"
#endif
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Position;\n"
"in vec2 TexCoord;\n"
"\n"
"uniform sampler2D u_tex;\n"
"\n"
"// Black Box From https://github.com/armory3d/armory/blob/master/Shaders/std/tonemap.glsl\n"
"vec3 acesFilm(const vec3 x) {\n"
"    const float a = 2.51;\n"
"    const float b = 0.03;\n"
"    const float c = 2.43;\n"
"    const float d = 0.59;\n"
"    const float e = 0.14;\n"
"    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	vec3 color = texture(u_tex, vec2(TexCoord.y, 1.0f - TexCoord.x)).rgb;\n"
"	color = acesFilm(color);\n"
"   color = pow(color, vec3(1.0f / 2.2f));\n"
"	FragColor = vec4(color, 1.0f);\n"
"}";

struct {
    CGL_wav_file current_wav_file;
    CGL_bool is_playing;
    CGL_bool is_loaded;

    CGL_window* window;

    CGL_framebuffer* default_framebuffer;
    CGL_framebuffer* bloom_framebuffer;

    CGL_audio_context* audio_context;
    CGL_audio_source* audio_source;
    CGL_audio_buffer* audio_buffer;

    CGL_mesh_gpu* mesh_gpu;

    CGL_shader* shader;
    CGL_shader* present_shader;

    CGL_mat4 projection;
    CGL_mat4 view;

    CGL_float start_time;
    CGL_float current_sound_level;

#ifndef CGL_WASM
    CGL_bloom* bloom;
#endif
} g_State;

#ifdef CGL_WASM
EMSCRIPTEN_KEEPALIVE
#endif
CGL_bool load_file(const CGL_byte* path) {
    if(g_State.is_loaded) {
        CGL_wav_file_destroy(&g_State.current_wav_file);
    }
    g_State.is_loaded = false;

    if(!CGL_wav_file_load(&g_State.current_wav_file, path)) {
        CGL_error("Failed to load wav file: %s", path);
        return CGL_FALSE;
    } else {
        CGL_info("Loaded wav file: %s", path);
    }
    g_State.is_loaded = true;
    g_State.is_playing = false;
    return CGL_TRUE;
}


void on_drop_file(CGL_window* window, const CGL_byte** paths, CGL_int count)
{
    (void)window;
    (void)count;

    if(!load_file(paths[0])) {
        CGL_error("Failed to load file: %s", paths[0]);
    }
}

CGL_bool init() {
    srand((uint32_t)time(NULL));
    if(!CGL_init()) return CGL_FALSE;
    g_State.window = CGL_window_create(600, 600, "Audio Visualizer - Jaysmito Mukherjee");
    if(!g_State.window) return 1;
    CGL_window_make_context_current(g_State.window);
    if(!CGL_gl_init()) return CGL_FALSE;
    CGL_window_set_drag_n_drop_callback(g_State.window, on_drop_file);

    g_State.default_framebuffer = CGL_framebuffer_create_from_default(g_State.window);
    g_State.bloom_framebuffer = CGL_framebuffer_create_basic(600, 600);
 
    g_State.audio_context = CGL_audio_context_create(NULL);
    CGL_audio_make_context_current(g_State.audio_context);
 
    g_State.audio_source = CGL_audio_source_create();
    g_State.audio_buffer = CGL_audio_buffer_create();

    CGL_mesh_cpu* mesh = CGL_mesh_cpu_sphere(8, 8);
    g_State.mesh_gpu = CGL_mesh_gpu_create();
    CGL_mesh_gpu_upload(g_State.mesh_gpu, mesh, false);
    CGL_mesh_cpu_destroy(mesh);

    g_State.shader = CGL_shader_create(VS_main_source, FS_main_source, NULL);
    g_State.present_shader = CGL_shader_create(PASS_THROUGH_VERTEX_SHADER_SOURCE, PASS_THROUGH_FRAGMENT_SHADER_SOURCE, NULL);

    g_State.projection = CGL_mat4_perspective(CGL_deg_to_rad(45.0f), 1.0f, 0.01f, 100.0f);
    g_State.view = CGL_mat4_identity();

#ifndef CGL_WASM
    g_State.bloom = CGL_bloom_create(600, 600, 3);
#endif

    g_State.start_time = CGL_utils_get_time();
    g_State.current_sound_level = 0.0f;

    return CGL_TRUE;
}

CGL_void cleanup() {
    if(g_State.is_loaded) {
        CGL_wav_file_destroy(&g_State.current_wav_file);
    }
    CGL_shader_destroy(g_State.shader);
    CGL_shader_destroy(g_State.present_shader);
    CGL_mesh_gpu_destroy(g_State.mesh_gpu);
    CGL_audio_buffer_destroy(g_State.audio_buffer);
    CGL_audio_source_destroy(g_State.audio_source);
    CGL_audio_make_context_current(NULL);
    CGL_audio_context_destroy(g_State.audio_context);
    CGL_framebuffer_destroy(g_State.default_framebuffer);
    CGL_framebuffer_destroy(g_State.bloom_framebuffer);
#ifndef CGL_WASM
    CGL_bloom_destroy(g_State.bloom);
#endif
    CGL_gl_shutdown();
    CGL_window_destroy(g_State.window);    
    CGL_shutdown();
}

EM_BOOL loop(double time, void* userData) {
    (void)time;
    (void)userData;


    CGL_float curr_time = CGL_utils_get_time() - g_State.start_time;
    CGL_window_set_size(g_State.window, 600, 600); // force window size to be 600x600

    g_State.view = CGL_mat4_look_at(CGL_vec3_init(0.0f, 8.0f, 8.0f), CGL_vec3_init(0.0f, 0.0f, 0.0f), CGL_vec3_init(0.0f, 1.0f, 0.0f));

    CGL_framebuffer_bind(g_State.bloom_framebuffer);
    CGL_gl_clear(0.0f, 0.0f, 0.0f, 1.0f);
    CGL_shader_bind(g_State.shader);
    CGL_shader_set_uniform_mat4(g_State.shader, CGL_shader_get_uniform_location(g_State.shader, "projection"), &g_State.projection);
    CGL_shader_set_uniform_mat4(g_State.shader, CGL_shader_get_uniform_location(g_State.shader, "view"), &g_State.view);
    CGL_shader_set_uniform_float(g_State.shader, CGL_shader_get_uniform_location(g_State.shader, "time"), curr_time);
    CGL_shader_set_uniform_float(g_State.shader, CGL_shader_get_uniform_location(g_State.shader, "sound_level"), g_State.current_sound_level);
    CGL_mesh_gpu_render_instanced(g_State.mesh_gpu, 10000);
#ifndef CGL_WASM
    CGL_bloom_apply(g_State.bloom, CGL_framebuffer_get_color_texture(g_State.bloom_framebuffer));
#endif

    CGL_framebuffer_bind(g_State.default_framebuffer);
    CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);
    CGL_shader_bind(g_State.present_shader);
    CGL_texture_bind(CGL_framebuffer_get_color_texture(g_State.bloom_framebuffer), 0);
    CGL_shader_set_uniform_int(g_State.present_shader, CGL_shader_get_uniform_location(g_State.present_shader, "u_tex"), 0);
    CGL_gl_render_screen_quad();


    g_State.current_sound_level = 0.0f;
    if(g_State.is_loaded && !g_State.is_playing) {
        if(CGL_audio_source_is_playing(g_State.audio_source)) CGL_audio_source_stop(g_State.audio_source);
        CGL_audio_buffer_destroy(g_State.audio_buffer);
        g_State.audio_buffer = CGL_audio_buffer_create();
        CGL_audio_buffer_set_data_from_wav_file(g_State.audio_buffer, &g_State.current_wav_file);
        CGL_audio_source_set_buffer(g_State.audio_source, g_State.audio_buffer);
        CGL_audio_source_play(g_State.audio_source);
        g_State.is_playing = true;
        CGL_info("Started Playing");
    }

    if(g_State.is_loaded && g_State.is_playing) {
        if(!CGL_audio_source_is_playing(g_State.audio_source)) {
            CGL_info("Finished playing");
            CGL_wav_file_destroy(&g_State.current_wav_file);
            g_State.is_loaded = false;
            g_State.is_playing = false;
        } else {
            CGL_float time_offset = CGL_audio_source_get_seconds_offset(g_State.audio_source);
            CGL_int sd = CGL_wav_file_sample_at_time(&g_State.current_wav_file, 0, time_offset);
            float volume = (float)sd / SHRT_MAX;
            g_State.current_sound_level = fabsf(volume * 2.0f);
        }
    }

    CGL_window_poll_events(g_State.window);
    CGL_window_swap_buffers(g_State.window);

    return CGL_TRUE;
}


CGL_int main()
{
    if(!init()) return EXIT_FAILURE;
#ifdef CGL_WASM
    CGL_info("Running in WASM mode");
    emscripten_request_animation_frame_loop(loop, NULL);
#else
    while(!CGL_window_should_close(g_State.window))
    {
        if(!loop(0.0, NULL)) break;
    }
    cleanup();
#endif
    return EXIT_SUCCESS;
}

```

`examples/c/barnsley_fern.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/


#define CGL_EXCLUDE_NETWORKING
#define CGL_LOGGING_ENABLED
#define CGL_EXCLUDE_AUDIO
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_IMPLEMENTATION
#include "cgl.h"

#ifdef CGL_WASM
#include <emscripten/emscripten.h>
#include <emscripten/html5.h>
#else 
#define EM_BOOL int
#endif


typedef struct
{
    CGL_double x;
    CGL_double y;
} CGL_dvec2;

#define CGL_dvec2_init(x, y) (CGL_dvec2){x, y}

static struct
{
    CGL_window* window; // the main window
    CGL_int window_height;
    CGL_int window_width;
    CGL_framebuffer* framebuffer;
    CGL_double scale_xy, offset_x, offset_y;
} g_State;

CGL_double rotation_matrices[4][4] = {
    {0.0, 0.0, 0.0, 0.16},
    {0.85, 0.04, -0.04, 0.85},
    {0.2, -0.26, 0.23, 0.22},
    {-0.15, 0.28, 0.26, 0.24}
};

CGL_double translation_vectors[4][2] = {
    {0.0, 0.0},
    {0.0, 1.6},
    {0.0, 1.6},
    {0.0, 0.44}
};

CGL_float probabilities[4] = {0.01f, 0.85f, 0.07f, 0.07f};

CGL_dvec2 next_point_barnsley(CGL_dvec2 prev_point)
{
    CGL_dvec2 next_point = CGL_dvec2_init(0.0, 0.0);
    CGL_sizei index = CGL_utils_get_random_with_probability(probabilities, 4);
    next_point.x = rotation_matrices[index][0] * prev_point.x + rotation_matrices[index][1] * prev_point.y + translation_vectors[index][0];
    next_point.y = rotation_matrices[index][2] * prev_point.x + rotation_matrices[index][3] * prev_point.y + translation_vectors[index][1];
    return next_point;    
}

CGL_bool init() {
    srand((uint32_t)time(NULL));
    if(!CGL_init()) return CGL_FALSE;
    g_State.window_height = g_State.window_width = 700;
    g_State.window = CGL_window_create(g_State.window_width, g_State.window_height, "Barnsley Fern - Jaysmito Mukherjee"); // create the window
    CGL_window_make_context_current(g_State.window); // make the opengl context for the window current
    if(!CGL_gl_init()) return CGL_FALSE; // initialize the opengl functions
    g_State.framebuffer = CGL_framebuffer_create_from_default(g_State.window); // load the default framebuffer (0) into CGL_framebuffer object
    if(!CGL_widgets_init()) return CGL_FALSE;



    // These values are for the best view of the fern
    g_State.scale_xy = 0.179262f;
    g_State.offset_x = 0.0f;
    g_State.offset_y = -0.947767;

    return CGL_TRUE;
}

CGL_void cleanup() {
    CGL_widgets_shutdown();
    CGL_framebuffer_destroy(g_State.framebuffer); // destory framebuffer object
    CGL_gl_shutdown(); // shutdown cgl opengl module
    CGL_window_destroy(g_State.window); // destroy window
    CGL_shutdown(); // shutdown cgl and clean up resources allocated by CGL internally (if any)
}

EM_BOOL loop(double time, void* userData) {
    (void)time;
    (void)userData;

    const CGL_float point_size = 0.01f;
    static CGL_float prev_time = 0.0f, curr_time = 0.0f, delta_time = 0.0f, frame_time = 0.0f;
    static CGL_int frame_count = 0, frame_rate = 60;
    static CGL_dvec2 turtle_position = {0.0f, 0.0f};


    curr_time = CGL_utils_get_time();
    delta_time = curr_time - prev_time; prev_time = curr_time; frame_time += delta_time; frame_count++;
    if(frame_time >= 1.0f) { frame_rate = frame_count; frame_time = 0.0f; frame_count = 0; }

    CGL_window_set_size(g_State.window, g_State.window_width, g_State.window_height); // set the window size
    // rendering
    CGL_framebuffer_bind(g_State.framebuffer); // bind default framebuffer and also adjust viewport size and offset
    //CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f); // clear screen with a dark gray color
    CGL_gl_clear(0.0f, 0.0f, 0.0f, 1.0f);

    CGL_widgets_begin_int((CGL_float)g_State.scale_xy, (CGL_float)g_State.scale_xy, (CGL_float)g_State.offset_x, (CGL_float)g_State.offset_y);

    CGL_widgets_set_fill_colorf(0.0f, 0.8f, 0.0f, 1.0f);

    for(CGL_sizei i = 0; i < 50000; i++)
    {
        turtle_position = next_point_barnsley(turtle_position);        
        CGL_widgets_add_rect2f((CGL_float)turtle_position.x, (CGL_float)turtle_position.y, point_size, point_size);
    }
        
    CGL_widgets_end();       

    CGL_widgets_begin();
    CGL_widgets_add_string("Arrow keys to move", -0.9f, 0.9f, 0.8f, 0.05f);
    CGL_widgets_add_string("W/S to zoom in/out", -0.9f, 0.85f, 0.8f, 0.05f);
    CGL_widgets_end();       

    if(CGL_window_is_key_pressed(g_State.window, CGL_KEY_W)) { g_State.scale_xy *= 1.01f; }
    if(CGL_window_is_key_pressed(g_State.window, CGL_KEY_S)) { g_State.scale_xy *= 0.99f; } 
    if(CGL_window_is_key_pressed(g_State.window, CGL_KEY_LEFT)) { g_State.offset_x -= 2.0f * delta_time; }
    if(CGL_window_is_key_pressed(g_State.window, CGL_KEY_RIGHT)) { g_State.offset_x += 2.0f * delta_time; }
    if(CGL_window_is_key_pressed(g_State.window, CGL_KEY_UP)) { g_State.offset_y += 2.0f * delta_time; } 
    if(CGL_window_is_key_pressed(g_State.window, CGL_KEY_DOWN)) { g_State.offset_y -= 2.0f * delta_time; }

    CGL_window_swap_buffers(g_State.window); // swap framebuffers
    CGL_window_poll_events(g_State.window); // poll events (if this is not called every frame window will stop responding)

    if(CGL_window_get_key(g_State.window, CGL_KEY_ESCAPE) == CGL_PRESS) return CGL_FALSE;

    static CGL_byte title[256];
    sprintf(title, "Barnsley Fern - Jaysmito Mukherjee | FPS: %d", frame_rate);
    CGL_window_set_title(g_State.window, title);

    return CGL_TRUE;
}

int main()
{
    if(!init()) return EXIT_FAILURE;
#ifdef CGL_WASM
    CGL_info("Running in WASM mode");
    emscripten_request_animation_frame_loop(loop, NULL);
#else
    while(!CGL_window_should_close(g_State.window)) // run till the close button is clicked
    {
        if(!loop(0.0, NULL)) break; 
    }
    cleanup();
#endif
    return EXIT_SUCCESS;
}

```

`examples/c/basic_node_editor.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/


#define CGL_LOGGING_ENABLED
#define CGL_EXCLUDE_NETWORKING
#define CGL_EXCLUDE_AUDIO
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_IMPLEMENTATION
#include "cgl.h"

#ifdef CGL_WASM
#include <emscripten/emscripten.h>
#include <emscripten/html5.h>
#else 
#define EM_BOOL int
#endif


/*
WARNING: There are several ways to use CGL_node_editor this is just a very basic example and not by any means the proper way to do it.
*/

static CGL_node_editor_input inpt;
static CGL_node_editor_node nodes[1000];
static CGL_node_editor_pin* links[10000][2];
static CGL_node_editor* editor = NULL;
static CGL_window* main_window = NULL;
static CGL_framebuffer* default_framebuffer = NULL;
static int node_count = 1;
static int link_count = 1;

void scroll_callback(CGL_window* window, double x, double y)
{
    (void)window;
    (void)x;

    inpt.scale += (float)y * 0.01f;
}

void on_connect(CGL_node_editor_pin* a, CGL_node_editor_pin* b)
{
    a->user_data = (void*)(intptr_t)link_count;
    b->user_data = (void*)(intptr_t)link_count;
    links[link_count][0] = a;
    links[link_count][1] = b;
    link_count++;
}

void on_drop(float px, float py, CGL_node_editor_pin* a)
{
    (void)px;
    (void)py;

    if (a->user_data != NULL)
    {
        CGL_node_editor_clear_focused_pins(editor);
        int ind = (int)(intptr_t)a->user_data;
        links[ind][0] = links[ind][1] = NULL;
    }
}


CGL_bool init() {

    srand((uint32_t)time(NULL));
    CGL_init();
    main_window = CGL_window_create(640, 360, "CGL Text Widgets - Jaysmito Mukherjee");
    if(main_window == NULL) return CGL_FALSE;
    CGL_window_make_context_current(main_window); 
    CGL_window_set_mouse_scroll_callback(main_window, scroll_callback);
    CGL_gl_init();
    CGL_widgets_init();
    default_framebuffer = CGL_framebuffer_create_from_default(main_window);

    inpt.scale = 1.0f;
    editor = CGL_node_editor_create();
    CGL_node_editor_set_on_connect(editor, on_connect);
    CGL_node_editor_set_on_drop(editor, on_drop);

    memset(nodes, 0, sizeof(nodes));
    memset(links, 0, sizeof(links));
    
    CGL_window_swap_buffers(main_window);
    CGL_window_poll_events(main_window);

    return CGL_TRUE;
}

CGL_void cleanup() {
    CGL_node_editor_destroy(editor);
    CGL_framebuffer_destroy(default_framebuffer);
    CGL_widgets_shutdown();
    CGL_gl_shutdown();
    CGL_window_destroy(main_window);
    CGL_shutdown();
}

EM_BOOL loop(double time, void* userData) {
    (void)time;
    (void)userData;

    int wx, wy;
    double mxp, myp;
    CGL_window_get_framebuffer_size(main_window, &wx, &wy);
    CGL_window_get_mouse_position(main_window, &mxp, &myp);
    inpt.aspect_ratio = (float)wx / wy;
    inpt.mouse_pos_x = (float)mxp / wx;
    inpt.mouse_pos_y = 1.0f - (float)myp / wy;
    inpt.mouse_pos_x = inpt.mouse_pos_x * 2.0f - 1.0f;
    inpt.mouse_pos_y = inpt.mouse_pos_y * 2.0f - 1.0f;    
    inpt.mouse_button_left = CGL_window_get_mouse_button(main_window, CGL_MOUSE_BUTTON_LEFT) == CGL_PRESS;
    inpt.mouse_button_middle = CGL_window_get_mouse_button(main_window, CGL_MOUSE_BUTTON_MIDDLE) == CGL_PRESS;
    inpt.mouse_button_right = CGL_window_get_mouse_button(main_window, CGL_MOUSE_BUTTON_RIGHT) == CGL_PRESS;
    inpt.shift = (CGL_window_get_key(main_window, CGL_KEY_LEFT_SHIFT) == CGL_PRESS) || (CGL_window_get_key(main_window, CGL_KEY_RIGHT_SHIFT) == CGL_PRESS);
    inpt.ctrl = (CGL_window_get_key(main_window, CGL_KEY_LEFT_CONTROL) == CGL_PRESS) || (CGL_window_get_key(main_window, CGL_KEY_RIGHT_CONTROL) == CGL_PRESS);
    inpt.escape = (CGL_window_get_key(main_window, CGL_KEY_ESCAPE) == CGL_PRESS);

    CGL_node_editor_update(editor, &inpt);
    for (int i = 1; i < node_count; i++)
        {
        if (nodes[i].user_data == NULL) CGL_node_editor_node_update(&nodes[i]);
        if (nodes[i].selected && CGL_window_get_key(main_window, CGL_KEY_DELETE) == CGL_PRESS) nodes[i].user_data = (void*)42;
        }
        

    CGL_framebuffer_bind(default_framebuffer);
    CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);
        

    CGL_node_editor_render_begin(editor);

    // render links
    for(CGL_sizei i = 1 , j = 1; i < sizeof(links) / sizeof(links[0]) && j < (CGL_sizei)link_count ; i++ )
        {
        if(links[i][0] && links[i][1])
            {
            if (links[i][0]->parent->user_data != NULL || links[i][1]->parent->user_data != NULL)
            {
                links[i][0]->user_data = links[i][1]->user_data = NULL;
                links[i][0] = links[i][1] = NULL;
            }
            // CGL_node_editor_render_linkf(links[i][0], links[i][1], 0.8f, 0.6f, 0.2f, 1.0f, 0.1f); // for rendering straight line links
            CGL_node_editor_render_link_curvedf(links[i][0], links[i][1], 0.8f, 0.6f, 0.2f, 1.0f, 0.4f, 0.1f, 8); // for rendering links based on bazier curves
            j++;
            }
        }

    // render nodes
    for (CGL_int i = 1 ; i < node_count ; i++) if(nodes[i].user_data == NULL) CGL_node_editor_node_render(&nodes[i]);

    CGL_node_editor_render_end(editor);

    if(CGL_window_get_key(main_window, CGL_KEY_A) == CGL_PRESS && (CGL_sizei)node_count < sizeof(nodes) / sizeof(nodes[0]))
        {
        static CGL_float last_add_time = 0.0f;
        if(CGL_utils_get_time() - last_add_time > 0.3)
            {
            last_add_time = CGL_utils_get_time();

            CGL_info("Created a new node");
            CGL_node_editor_node_init(editor, &nodes[node_count++]);
            CGL_node_editor_node_set_position(&nodes[node_count - 1], inpt.mouse_pos_x, inpt.mouse_pos_y);
            char buffer[256];
            static int count = 0;
            sprintf(buffer, "Node :%d", count++);
            CGL_node_editor_node_set_title(&nodes[node_count - 1], buffer);
            int r = CGL_utils_random_int(2, 5);
            for(int i = 0 ; i < r ; i++) CGL_node_editor_node_get_pin(&nodes[node_count - 1], true, i)->is_set = true;
            r = CGL_utils_random_int(2, 5);
            for (int i = 0; i < r; i++) CGL_node_editor_node_get_pin(&nodes[node_count - 1], false, i)->is_set = true;
            }
        }

        
    CGL_window_swap_buffers(main_window);
    CGL_window_poll_events(main_window);


    return CGL_TRUE;
}


int main()
{
    if(!init()) return EXIT_FAILURE;
#ifdef CGL_WASM
    CGL_info("Running in WASM mode");
    emscripten_request_animation_frame_loop(loop, NULL);
#else
    while(!CGL_window_should_close(main_window)) {
        if(!loop(0.0, NULL)) return EXIT_FAILURE;
    }
    cleanup();
#endif
    return EXIT_SUCCESS;
}

```

`examples/c/basic_plotting.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_EXCLUDE_NETWORKING
#define CGL_EXCLUDE_AUDIO
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#include "cgl.h"


#ifdef CGL_WASM
#include <emscripten/emscripten.h>
#include <emscripten/html5.h>
#else 
#define EM_BOOL int
#endif


static struct
{
    CGL_window* window; // the main window
    int window_height;
    int window_width;

    CGL_framebuffer* framebuffer;
} g_context;

CGL_float function_to_plot_0(CGL_float x)
{
    x += CGL_utils_get_time();
    return sinf(x) + sinf(x * 2) * 0.5f + sinf(x * 4) * 0.25f + sinf(x * 8) * 0.125f;
}

CGL_float function_to_plot_1(CGL_float x)
{
    return fabsf(sinf(powf(x, x) / powf(2.0f, powf(x, x) - CGL_PI_2)/CGL_PI));
}

CGL_float function_to_plot_2(CGL_float x)
{
    return x - floorf(x);
}

CGL_float function_to_plot_3(CGL_float x)
{
    x += CGL_utils_get_time();
    return (sinf(x) + cosf(x * 3.0f)) / 2.0f;
}

void draw_function_plot_widgets()
{
    CGL_widgets_add_plot_function(
        -1.0f, 0.0f, 0.9f, 0.9f, // position and size
        function_to_plot_0, // function to plot
        256, // number of points to plot (more points = more accurate/smooth plot)
        -5.0f, 5.0f, // x range
        -1.5f, 1.5f, // y range
        0.005f, CGL_vec3_init(1.0f, 0.0f, 0.0f), // plot line width and color
        true, 0.05f, CGL_vec3_init(0.0f, 1.0f, 0.0f) // axes line width and color
    );

    CGL_widgets_add_plot_function(
        0.0f, 0.0f, 0.9f, 0.9f, // position and size
        function_to_plot_1, // function to plot
        256, // number of points to plot (more points = more accurate/smooth plot)
        -0.5f, 4.0f, // x range
        -0.5f, 1.0f, // y range
        0.005f, CGL_vec3_init(1.0f, 0.0f, 0.0f), // plot line width and color
        true, 0.05f, CGL_vec3_init(0.0f, 1.0f, 0.0f) // axes line width and color
    );

    CGL_widgets_add_plot_function(
        -1.0f, -1.0f, 0.9f, 0.9f, // position and size
        function_to_plot_2, // function to plot
        256, // number of points to plot (more points = more accurate/smooth plot)
        -5.0f, 5.0f, // x range
        -2.0f, 2.0f, // y range
        0.005f, CGL_vec3_init(1.0f, 0.0f, 0.0f), // plot line width and color
        true, 0.05f, CGL_vec3_init(0.0f, 1.0f, 0.0f) // axes line width and color
    );

    CGL_widgets_add_plot_function(
        0.0f, -1.0f, 0.9f, 0.9f, // position and size
        function_to_plot_3, // function to plot
        256, // number of points to plot (more points = more accurate/smooth plot)
        -5.0f, 5.0f, // x range
        -1.5f, 1.5f, // y range
        0.005f, CGL_vec3_init(1.0f, 0.0f, 0.0f), // plot line width and color
        true, 0.05f, CGL_vec3_init(0.0f, 1.0f, 0.0f) // axes line width and color
    );
}

void draw_array_plot_widgets()
{
    srand(0);
    CGL_vec2 points[64];
    for(int i = 0; i < 64; i++)
    {
        points[i] = CGL_vec2_init(
            i / 64.0f * 10.0f - 2.5f,
            CGL_utils_random_float() * 4.0f - 1.0f
        );
    }

    CGL_widgets_add_plot_array(
        -1.0f, -1.0f, 2.0f, 2.0f, // position and size
        points, 64, // points
        0.03f, CGL_vec3_init(1.0f, 0.0f, 0.0f), // marker size and color
        true, 0.01f, CGL_vec3_init(0.0f, 1.0f, 0.0f) // axes line width and color
    );
}

void draw_pie_chart_plot_widgets()
{
    srand(0);
    CGL_float values[8];
    CGL_vec3 colors[8];
    for(CGL_int i = 0; i < 8; i++)
    {
        values[i] = CGL_utils_random_float() * 100.0f / (i + 1);
        colors[i] = CGL_vec3_init(
            CGL_utils_random_float(),
            CGL_utils_random_float(),
            CGL_utils_random_float()
        );
    }

    CGL_widgets_add_plot_pie_chart(
        0.0f, 0.0f, 1.0f, // position and size
        values, colors, 8, // values and colors
        64
    );
}

void draw_bar_plot_widgets()
{
    srand(1);
    CGL_float values[8];
    CGL_vec3 colors[8];
    for(CGL_int i = 0; i < 8; i++)
    {
        values[i] = CGL_utils_random_float() * 100.0f / (i + 1) + 10.0f;
        colors[i] = CGL_vec3_init(CGL_utils_random_float(), CGL_utils_random_float(), CGL_utils_random_float());
    }

    CGL_widgets_add_bar_graph(
        -1.0f, 0.0f, 0.9f, 0.9f, 
        values, colors, 8,
        true, 0.01f, CGL_vec3_init(0.0f, 1.0f, 0.0f),
        true
    );

    CGL_widgets_add_bar_graph(
        0.0f, 0.0f, 0.9f, 0.9f, 
        values, colors, 8,
        true, 0.01f, CGL_vec3_init(0.0f, 1.0f, 0.0f),
        false
    );

    for(CGL_int i = 0; i < 8; i++)
    {
        values[i] = CGL_utils_random_float() * 100.0f / (i + 1) + 10.0f;
        colors[i] = CGL_vec3_init(CGL_utils_random_float(), CGL_utils_random_float(), CGL_utils_random_float());
    }

    CGL_widgets_add_bar_graph(
        -1.0f, -1.0f, 0.9f, 0.9f, 
        values, colors, 8,
        true, 0.01f, CGL_vec3_init(0.0f, 1.0f, 0.0f),
        true
    );

    CGL_widgets_add_bar_graph(
        0.0f, -1.0f, 0.9f, 0.9f, 
        values, colors, 8,
        true, 0.01f, CGL_vec3_init(0.0f, 1.0f, 0.0f),
        false
    );

}

CGL_bool init() {
    
    srand((uint32_t)time(NULL));
    if(!CGL_init()) return CGL_FALSE;
    g_context.window_height = 600;
    g_context.window_width = 600;
    g_context.window = CGL_window_create(g_context.window_width, g_context.window_height, "Plotting - Jaysmito Mukherjee"); // create the window
    if(g_context.window == NULL) return CGL_FALSE; // window creation failed
    CGL_window_make_context_current(g_context.window); // make the opengl context for the window current
    if(!CGL_gl_init()) return CGL_FALSE; // initialize cgl opengl module    
    g_context.framebuffer = CGL_framebuffer_create_from_default(g_context.window); // load the default framebuffer (0) into CGL_framebuffer object
    if(g_context.framebuffer == NULL) return CGL_FALSE; // failed
    if(!CGL_widgets_init()) return CGL_FALSE; 

    return CGL_TRUE;
}

CGL_void cleanup() {
    CGL_widgets_shutdown();
    CGL_framebuffer_destroy(g_context.framebuffer); // destory framebuffer object
    CGL_gl_shutdown(); // shutdown cgl opengl module
    CGL_window_destroy(g_context.window); // destroy window
    CGL_shutdown(); // shutdown cgl and clean up resources allocated by CGL internally (if any)
}

EM_BOOL loop(double time, void* userData) {
    (void)time;
    (void)userData;

    static CGL_int mode = 1;

    CGL_window_set_size(g_context.window, g_context.window_width, g_context.window_height); // set window size
        // rendering
    CGL_framebuffer_bind(g_context.framebuffer); // bind default framebuffer and also adjust viewport size and offset
    CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f); // clear screen with a dark gray color

    CGL_widgets_begin();

        
    if(mode == 1) draw_function_plot_widgets();
    else if(mode == 2) draw_array_plot_widgets();
    else if(mode == 3) draw_pie_chart_plot_widgets();
    else if(mode == 4) draw_bar_plot_widgets();

    CGL_widgets_end();

    CGL_window_swap_buffers(g_context.window); // swap framebuffers
    CGL_window_poll_events(g_context.window); // poll events (if this is not called every frame window will stop responding)



    if(CGL_window_get_key(g_context.window, CGL_KEY_ESCAPE) == CGL_PRESS) return CGL_FALSE;
    for(CGL_int i = 1 ; i < 9 ; i++) if(CGL_window_get_key(g_context.window, CGL_KEY_0 + i) == CGL_PRESS) mode = i;

    return CGL_TRUE;
}

int main()
{
    if (!init()) return EXIT_FAILURE;
#ifdef CGL_WASM
    CGL_info("Running in WASM mode");
    emscripten_request_animation_frame_loop(loop, NULL);
#else
    // run till the close button is clicked
    while(!CGL_window_should_close(g_context.window)) {
        if(!loop(0, NULL)) break; // run the loop function
    }
    cleanup();
#endif    
    return EXIT_SUCCESS;
}

```

`examples/c/basic_raycast_2d_lighting.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_EXCLUDE_AUDIO
#define CGL_EXCLUDE_NETWORKING
#define CGL_IMPLEMENTATION
#include "cgl.h"


#ifdef CGL_WASM
#include <emscripten/emscripten.h>
#include <emscripten/html5.h>
#else 
#define EM_BOOL int
#endif

const char* __VS_S = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision mediump float;\n"
"\n"
"in vec4 position;\n"
"in vec4 normal;\n"
"in vec4 texcoord;\n"
#else
"#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 normal;\n"
"layout (location = 2) in vec4 texcoord;\n"
#endif
"\n"
"uniform vec2 tri_pos[3];\n"
"\n"
"out vec2 Position;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = vec4(tri_pos[gl_VertexID], 0.0f, 1.0f);\n"
"	Position = tri_pos[gl_VertexID];\n"
"}";

const char* __FS_S =
#ifdef CGL_WASM
"#version 300 es\n"
"precision mediump float;\n"
#else
"#version 430 core\n"
#endif
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec2 Position;\n"
"\n"
"uniform vec2 c_pos;\n"
"\n"
"void main()\n"
"{\n"
"   float alpha = 1.0f - pow((Position.x - c_pos.x)*1.2f, 2.0f) - pow((Position.y - c_pos.y)*1.2f, 2.0f);\n"
"   alpha *= exp(-2.0f * (pow(Position.x - c_pos.x, 2.0f) + pow(Position.y - c_pos.y, 2.0f)));\n"
"	vec4 color = vec4(1.0f, 1.0f, 1.0f , clamp(alpha, 0.0f, 0.7f));\n"
"	FragColor = color;\n"
"}";

static struct {
    CGL_vec2 a;
    CGL_vec2 b;
    CGL_vec2 c;
    CGL_vec2 position;
    float rotation;
    float total_rotation;
} triangle;

static CGL_vec4 walls[1024];
static int wall_count = 0;
static CGL_window* window = NULL;
static CGL_framebuffer* default_framebuffer = NULL;
static CGL_ray_caster* caster = NULL;
static CGL_shader* shd = NULL;

static struct 
{
    bool started;
    bool released;
    CGL_vec2 start;
    CGL_vec2 end;
} current_line;


CGL_bool init() {
    srand((uint32_t)time(NULL));
    if(!CGL_init()) return CGL_FALSE;
    window = CGL_window_create(700, 700, "CGL Ray Caster - Jaysmito Mukherjee");
    if(window == NULL) return CGL_FALSE;
    CGL_window_make_context_current(window); 
    if(!CGL_gl_init()) return CGL_FALSE;
    if(!CGL_widgets_init()) return CGL_FALSE;
    default_framebuffer = CGL_framebuffer_create_from_default(window);

    CGL_window_swap_buffers(window);
    CGL_window_poll_events(window);

    triangle.a = CGL_vec2_init(-0.025f, 0.0f);
    triangle.b = CGL_vec2_init(0.025f, 0.0f);
    triangle.c = CGL_vec2_init(0.0f, 0.08f);
    triangle.position = CGL_vec2_init(0.0f, 0.0f);
    triangle.rotation = 0.0f;
    triangle.total_rotation = 0.0f;

    current_line.started = false;
    current_line.released = true;

    caster = CGL_ray_caster_create();
    
    shd = CGL_shader_create(__VS_S, __FS_S, NULL);

    return CGL_TRUE;
}

CGL_void cleanup() {
    CGL_ray_caster_destroy(caster);
    CGL_shader_destroy(shd);
    CGL_framebuffer_destroy(default_framebuffer);
    CGL_widgets_shutdown();
    CGL_gl_shutdown();
    CGL_window_destroy(window);
    CGL_shutdown();
}


EM_BOOL loop(double time, void* userData) {
    (void)time;
    (void)userData;

    float fov = 3.14159265358979323846f / 4.0f;

    static int frame_count = 0;
    frame_count ++;

    static CGL_float prev_time = 0.0f;
    CGL_float current_time = CGL_utils_get_time();
    CGL_float delta_time = current_time - prev_time;
    prev_time = current_time;

    int wx, wy;
    double mxp, myp;
    CGL_window_get_framebuffer_size(window, &wx, &wy);
    CGL_window_get_mouse_position(window, &mxp, &myp);
    float mouse_pos_x = (float)mxp / wx;
    float mouse_pos_y = 1.0f - (float)myp / wy;
    mouse_pos_x = mouse_pos_x * 2.0f - 1.0f;
    mouse_pos_y = mouse_pos_y * 2.0f - 1.0f;    

    CGL_framebuffer_bind(default_framebuffer);
    CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);

        
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glBlendEquation(GL_FUNC_ADD);
    CGL_shader_bind(shd);
    int tri_count = 0;
    CGL_shape_triangle* triangles = CGL_ray_caster_get_triangles(caster, &tri_count);
    CGL_vec2 c_pos = CGL_vec2_sub(triangle.c, triangle.position);
    CGL_shader_set_uniform_vec2v(shd, CGL_shader_get_uniform_location(shd, "c_pos"), c_pos.x, c_pos.y);
    for(int i = 0 ; i < tri_count ; i++) {
        CGL_shader_set_uniform_vec2v(shd, CGL_shader_get_uniform_location(shd, "tri_pos[0]"), triangles[i].a.x, triangles[i].a.y);
        CGL_shader_set_uniform_vec2v(shd, CGL_shader_get_uniform_location(shd, "tri_pos[1]"), triangles[i].b.x, triangles[i].b.y);
        CGL_shader_set_uniform_vec2v(shd, CGL_shader_get_uniform_location(shd, "tri_pos[2]"), triangles[i].c.x, triangles[i].c.y);
        glDrawArrays(GL_TRIANGLES, 0, 3);
    }

    CGL_widgets_begin();

    CGL_widgets_set_fill_colorf(0.3f, 0.7f, 0.4f, 1.0f);
    CGL_widgets_add_triangle(
        CGL_vec3_init(triangle.a.x - triangle.position.x, triangle.a.y - triangle.position.y, 0.0f),
        CGL_vec3_init(triangle.b.x - triangle.position.x, triangle.b.y - triangle.position.y, 0.0f),
        CGL_vec3_init(triangle.c.x - triangle.position.x, triangle.c.y - triangle.position.y, 0.0f));
        
    CGL_widgets_set_stroke_thicnkess(0.02f);
    CGL_widgets_set_stroke_colorf(0.1f, 0.1f, 0.1f, 1.0f);
    for(int i = 0; i < wall_count; i++){
        CGL_widgets_add_line(
            CGL_vec3_init(walls[i].x, walls[i].y, 0.0f),
            CGL_vec3_init(walls[i].z, walls[i].w, 0.0f));
    }

    if(current_line.started) {
        CGL_widgets_set_stroke_colorf(0.7f, 0.7f, 0.3f, 1.0f);
        CGL_widgets_add_line(
            CGL_vec3_init(current_line.start.x, current_line.start.y, 0.0f),
            CGL_vec3_init(mouse_pos_x, mouse_pos_y, 0.0f));
    }        

    if(CGL_window_get_key(window, CGL_KEY_R) == CGL_PRESS) {
        CGL_vec2 centroid = CGL_vec2_centroid_of_triangle(triangle.a, triangle.b, triangle.c);
        CGL_vec2 dir = CGL_vec2_sub(triangle.c, centroid);
        CGL_vec2_normalize(dir);
        CGL_vec2 inter_pt;
        CGL_widgets_set_stroke_thicnkess(0.01f);
        CGL_widgets_set_stroke_colorf(0.7f, 0.3f, 0.3f, 1.0f);
        if(CGL_ray_caster_get_intersection_point_for_walls(CGL_vec2_sub(triangle.c, triangle.position), dir, walls, wall_count, &inter_pt, NULL, 1.0f) > 0.0f)
        {
            CGL_widgets_add_line(
                CGL_vec3_init(triangle.c.x - triangle.position.x, triangle.c.y - triangle.position.y, 0.0f),
                CGL_vec3_init(inter_pt.x, inter_pt.y, 0.0f));
        }
    }

    CGL_ray_caster_set_angle_limits(caster, 3.14f / 2.0f - fov / 2.0f, 3.14f / 2.0f + fov / 2.0f); // for future
    CGL_ray_caster_calculate(caster, CGL_vec2_sub(triangle.c, triangle.position), -triangle.total_rotation, (CGL_window_get_key(window, CGL_KEY_T) == CGL_PRESS));
        
    glDisable(GL_BLEND);        
    CGL_widgets_end();    

        
    CGL_window_swap_buffers(window);
    CGL_window_poll_events(window);

    const CGL_float speed = 500.0f * delta_time;

    bool rotChanged = false;
    if(CGL_window_get_key(window, CGL_KEY_E) == CGL_PRESS) { triangle.rotation = -0.003f * speed; rotChanged = true; }
    if(CGL_window_get_key(window, CGL_KEY_Q) == CGL_PRESS) { triangle.rotation = 0.003f * speed; rotChanged = true; }
    if(CGL_window_get_key(window, CGL_KEY_A) == CGL_PRESS) { fov += 0.003f * speed; }
    if(CGL_window_get_key(window, CGL_KEY_D) == CGL_PRESS) { fov -= 0.003f * speed;  }
    if(CGL_window_get_key(window, CGL_KEY_W) == CGL_PRESS) { CGL_vec2 centroid = CGL_vec2_centroid_of_triangle(triangle.a, triangle.b, triangle.c); centroid = CGL_vec2_sub(triangle.c, centroid); centroid = CGL_vec2_scale(centroid, 0.009f * speed); triangle.position = CGL_vec2_sub(triangle.position, centroid); }
    if(CGL_window_get_key(window, CGL_KEY_S) == CGL_PRESS) { CGL_vec2 centroid = CGL_vec2_centroid_of_triangle(triangle.a, triangle.b, triangle.c); centroid = CGL_vec2_sub(triangle.c, centroid); centroid = CGL_vec2_scale(centroid, 0.009f * speed); triangle.position = CGL_vec2_add(triangle.position, centroid); }
    if(rotChanged) {
        triangle.total_rotation -= triangle.rotation;
        CGL_vec2 centroid = CGL_vec2_centroid_of_triangle(triangle.a, triangle.b, triangle.c);
        triangle.a = CGL_vec2_rotate_about_point(triangle.a, centroid, triangle.rotation);
        triangle.b = CGL_vec2_rotate_about_point(triangle.b, centroid, triangle.rotation);
        triangle.c = CGL_vec2_rotate_about_point(triangle.c, centroid, triangle.rotation);
    }
    if(CGL_window_get_mouse_button(window, CGL_MOUSE_BUTTON_LEFT) == CGL_PRESS)  {
        if(!current_line.started) {
            current_line.started = true;
            current_line.start = CGL_vec2_init(mouse_pos_x, mouse_pos_y);
        }
    } else if(CGL_window_get_mouse_button(window, CGL_MOUSE_BUTTON_LEFT) == CGL_RELEASE)  {
        if(current_line.started) {
            current_line.started = false;
            current_line.end = CGL_vec2_init(mouse_pos_x, mouse_pos_y);
            walls[wall_count++] = CGL_vec4_init(current_line.start.x, current_line.start.y, current_line.end.x, current_line.end.y);
            CGL_ray_caster_add_wall(caster, walls[wall_count - 1]);
        }
    }
    if(CGL_window_get_key(window, CGL_KEY_C) == CGL_PRESS) { 
        wall_count = 0;
        CGL_ray_caster_clear_walls(caster); 
    }

    return CGL_TRUE;
}


int main()
{
    if(!init()) return EXIT_FAILURE;
#ifdef CGL_WASM
    CGL_info("Running in WASM mode");
    emscripten_request_animation_frame_loop(loop, NULL);
#else
    while(!CGL_window_should_close(window))  {
        if(!loop(0.0, NULL)) break;
    }
    cleanup();
#endif
    return EXIT_SUCCESS;
}

```

`examples/c/basic_text_rendering.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_EXCLUDE_NETWORKING
#define CGL_EXCLUDE_SKY_RENDERER
#define CGL_EXCLUDE_PHONG_RENDERER
#define CGL_EXCLUDE_TILEMAP_RENDERER
#define CGL_IMPLEMENTATION
#include "cgl.h"

// NOTE: Shaders source for shaders/vertex.glsl shaders/fragment.glsl give at the bottom of this file

int main()
{
     srand((uint32_t)time(NULL));
    if(!CGL_init()) return -1;
    CGL_window* main_window = CGL_window_create(640, 480, "Hello World");
    if(!main_window) return -1;
    CGL_window_make_context_current(main_window);
    if(!CGL_gl_init()) return -1;
    CGL_framebuffer* default_framebuffer = CGL_framebuffer_create_from_default(main_window);   
    CGL_mesh_cpu* screen_quad_mesh_cpu = CGL_mesh_cpu_quad((CGL_vec3){ 1.0,  1.0, 0.0},
                                                           (CGL_vec3){ 1.0, -1.0, 0.0},
                                                           (CGL_vec3){-1.0, -1.0, 0.0},
                                                           (CGL_vec3){-1.0,  1.0, 0.0});
    CGL_mesh_gpu* screen_quad_mesh_gpu = CGL_mesh_gpu_create();
    CGL_mesh_gpu_upload(screen_quad_mesh_gpu, screen_quad_mesh_cpu, true);
    CGL_mesh_cpu_destroy(screen_quad_mesh_cpu);
    CGL_shader* shd = CGL_shader_create_from_files("shaders/vertex.glsl", "shaders/fragment.glsl", NULL);
    int u_tex = CGL_shader_get_uniform_location(shd, "u_tex");
    // Initialize Text Engine
    if(!CGL_text_init()) return EXIT_FAILURE;
    // Load Font file
    CGL_font* font = CGL_font_load("font.ttf");
    // Build the font atlas and bake font bitmaps
    if(!CGL_font_build_atlas(font, 1024, 1024, 72)) {CGL_LOG("Error in building font atlas\n"); return EXIT_FAILURE;}

    //CGL_texture* tex = CGL_font_get_atlas(font);
    const char* text = "Hello World!";
    // bake a string into a texture
    CGL_texture* tex = CGL_text_bake_to_texture(text, strlen(text), font, NULL, NULL);

    while(!CGL_window_should_close(main_window))
    { 
        {
            CGL_framebuffer_bind(default_framebuffer);
            CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);
            int rx = 0, ry = 0;
            CGL_framebuffer_get_size(default_framebuffer, &rx, &ry);
            // Render Here
            CGL_shader_bind(shd);
            CGL_texture_bind(tex, 0);
            CGL_shader_set_uniform_int(shd, u_tex, 0);
            CGL_mesh_gpu_render(screen_quad_mesh_gpu);
        }

        CGL_window_poll_events(main_window);
        CGL_window_swap_buffers(main_window);
        if(CGL_window_get_key(main_window, CGL_KEY_ESCAPE) == CGL_PRESS) break;
    }

    CGL_mesh_gpu_destroy(screen_quad_mesh_gpu);
    CGL_shader_destroy(shd);
    CGL_texture_destroy(tex);

    CGL_framebuffer_destroy(default_framebuffer);
    CGL_gl_shutdown();
    CGL_window_destroy(main_window);
    CGL_text_shutdown();
    CGL_shutdown();
    return 0;
}

/*
shaders/vertex.glsl
-------------------
#version 430 core

layout (location = 0) in vec4 position;
layout (location = 1) in vec4 normal;
layout (location = 2) in vec4 texcoord;

out vec2 TexCoord; 

void main()
{
	gl_Position = vec4(position.xyz, 1.0f);
	TexCoord = texcoord.xy;		
}
*/

/*
shaders/fragment.glsl
---------------------
#version 430 core

out vec4 FragColor;

in vec2 TexCoord;

uniform sampler2D u_tex;

void main()
{
	vec4 color = texture(u_tex, vec2(TexCoord.x, 1-TexCoord.y));
	FragColor = color;
}
*/

```

`examples/c/basic_tile_render.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#include "cgl.h"

#define MAIN_FRAME_BUFFER_WIDTH  800
#define MAIN_FRAME_BUFFER_HEIGHT (int)(MAIN_FRAME_BUFFER_WIDTH * (9.0f / 16.0f))

static struct {
    float delta_x;
    float delta_y;
    float prev_x;
    float prev_y;
} mouse_input;

static struct
{
    float scale_x;
    float scale_y;
    float offset_x;
    float offset_y;
    CGL_tilemap* tilemap;
} tilemap_data;

#define TILE_COUNT_X 16
#define TILE_COUNT_Y 16

void input_scroll_callback(CGL_window* window, double x, double y)
{
}

void input_mouse_pos_callback(CGL_window* window, double x, double y)
{
    mouse_input.delta_x = ((float)x - mouse_input.prev_x);
    mouse_input.delta_y = ((float)y - mouse_input.prev_y);
    mouse_input.prev_x = (float)x;
    mouse_input.prev_y = (float)y;
}

void randomize_tilemap()
{
    for(int i = 0 ; i < TILE_COUNT_X; i++)
        for(int j = 0 ; j < TILE_COUNT_Y; j++)
            if(CGL_utils_random_float() > 0.5f)
                CGL_tilemap_set_tile_color(tilemap_data.tilemap, i, j, CGL_utils_random_float(), CGL_utils_random_float(), CGL_utils_random_float());
}

int main()
{
    srand((uint32_t)time(NULL));
    if(!CGL_init()) return -1;
    CGL_window* main_window = CGL_window_create(640, 480, "Hello World");
    if(!main_window) return -1;
    CGL_window_make_context_current(main_window);
    if(!CGL_gl_init()) return -1;
    CGL_framebuffer* default_framebuffer = CGL_framebuffer_create_from_default(main_window);   
    mouse_input.delta_x = 0.0f;
    mouse_input.delta_y = 0.0f;
    mouse_input.prev_x = 0.0f;
    mouse_input.prev_y = 0.0f;
    tilemap_data.offset_x = 0.0f;
    tilemap_data.offset_y = 0.0f;
    tilemap_data.scale_x = 1.0f;
    tilemap_data.scale_y = 1.0f;
    CGL_window_set_mouse_scroll_callback(main_window, input_scroll_callback);
    CGL_window_set_mouse_position_callback(main_window, input_mouse_pos_callback);
    CGL_window_resecure_callbacks(main_window);
    tilemap_data.tilemap = CGL_tilemap_create(TILE_COUNT_X, TILE_COUNT_Y, 32, 32, 0);
    randomize_tilemap();            
    while(!CGL_window_should_close(main_window))
    { 
        {
            CGL_framebuffer_bind(default_framebuffer);
            CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);
            int rx = 0, ry = 0;
            CGL_framebuffer_get_size(default_framebuffer, &rx, &ry);
            CGL_tilemap_render(tilemap_data.tilemap, tilemap_data.scale_x, tilemap_data.scale_y, tilemap_data.offset_x, tilemap_data.offset_y, NULL);
        }

        CGL_window_poll_events(main_window);

        CGL_window_swap_buffers(main_window);
        if(CGL_window_get_mouse_button(main_window, CGL_MOUSE_BUTTON_LEFT) == CGL_PRESS || CGL_window_get_mouse_button(main_window, CGL_MOUSE_BUTTON_RIGHT) == CGL_PRESS || CGL_window_get_mouse_button(main_window, CGL_MOUSE_BUTTON_MIDDLE) == CGL_PRESS)
            randomize_tilemap();            
        mouse_input.delta_x = mouse_input.delta_y = 0.0f;
        if(CGL_window_get_key(main_window, CGL_KEY_ESCAPE) == CGL_PRESS) break;
    }

    CGL_tilemap_destroy(tilemap_data.tilemap);

    CGL_framebuffer_destroy(default_framebuffer);
    CGL_gl_shutdown();
    CGL_window_destroy(main_window);
    CGL_shutdown();
    return 0;
}

```

`examples/c/basic_widgets.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_EXCLUDE_NETWORKING
#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#include "cgl.h"

static struct
{
    CGL_window* window; // the main window
    int window_height;
    int window_width;

    CGL_framebuffer* framebuffer;
} g_context;

int main()
{
    srand((uint32_t)time(NULL));
    if(!CGL_init()) return EXIT_FAILURE; // initialize CGL (required for setting up internals of CGL)
    g_context.window_height = 600;
    g_context.window_width = 600;
    g_context.window = CGL_window_create(g_context.window_width, g_context.window_height, "Tests - Jaysmito Mukherjee"); // create the window
    if(g_context.window == NULL) return false; // window creation failed
    CGL_window_make_context_current(g_context.window); // make the opengl context for the window current
    if(!CGL_gl_init()) return EXIT_FAILURE; // initialize cgl opengl module    
    g_context.framebuffer = CGL_framebuffer_create_from_default(g_context.window); // load the default framebuffer (0) into CGL_framebuffer object
    if(g_context.framebuffer == NULL) return false; // failed
    if(!CGL_widgets_init()) return EXIT_FAILURE; 

    // the main loop
    while(!CGL_window_should_close(g_context.window)) // run till the close button is clicked
    {
        CGL_window_set_size(g_context.window, g_context.window_width, g_context.window_height); // set window size
        // rendering
        CGL_framebuffer_bind(g_context.framebuffer); // bind default framebuffer and also adjust viewport size and offset
        CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f); // clear screen with a dark gray color

        CGL_widgets_begin();
        
        float offx = -0.4f;
        float offy = -0.4f;
        srand(42);
        
        for(;offx <= 0.4 ; offx += 0.1f, offy += 0.1f)
        {
            CGL_color color = CGL_utils_random_color();
            CGL_widgets_set_fill_colorf(color.x, color.y, color.z, 1.0f);
            CGL_widgets_add_triangle(   
                CGL_vec3_init(-0.5f + offx, -0.5f + offy, 0.0f),
                CGL_vec3_init( 0.5f + offx, -0.5f + offy, 0.0f),
                CGL_vec3_init( 0.0f + offx,  0.5f + offy, 0.0f)
                );
        }
        
        
        CGL_widgets_end();

        CGL_window_swap_buffers(g_context.window); // swap framebuffers
        CGL_window_poll_events(g_context.window); // poll events (if this is not called every frame window will stop responding)

        if(CGL_window_get_key(g_context.window, CGL_KEY_ESCAPE) == CGL_PRESS) break; // quit on pressing escape
    }

    // cleanup
    CGL_widgets_shutdown();
    CGL_framebuffer_destroy(g_context.framebuffer); // destory framebuffer object
    CGL_gl_shutdown(); // shutdown cgl opengl module
    CGL_window_destroy(g_context.window); // destroy window
    CGL_shutdown(); // shutdown cgl and clean up resources allocated by CGL internally (if any)
    return EXIT_SUCCESS;
}

```

`examples/c/bezier_curve_widget.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_EXCLUDE_NETWORKING
#define CGL_EXCLUDE_AUDIO
#define CGL_IMPLEMENTATION
#include "cgl.h"

#ifdef CGL_WASM
#include <emscripten/emscripten.h>
#include <emscripten/html5.h>
#else 
#define EM_BOOL int
#endif

struct {
    CGL_window* window;
    CGL_framebuffer* default_framebuffer;
    CGL_int selected_point;
    CGL_int line_resolution;
    CGL_vec2 points[4];
    CGL_float aspect_ratio;
} g_State;

CGL_bool init() {
    srand((CGL_uint)time(NULL));
    if(!CGL_init()) return CGL_FALSE;
    g_State.window = CGL_window_create(512, 512, "CGL Text Widgets - Jaysmito Mukherjee");
    CGL_window_make_context_current(g_State.window); 
    CGL_gl_init();
    CGL_widgets_init();
    if(g_State.window == NULL) return false; 
    g_State.default_framebuffer = CGL_framebuffer_create_from_default(g_State.window);

    g_State.selected_point = 0;
    g_State.line_resolution = 3;
    g_State.points[0] = CGL_vec2_init(-0.8f, 0.0f);
    g_State.points[1] = CGL_vec2_init(0.8f, 0.0f);
    g_State.points[2] = CGL_vec2_init(0.0f, 0.5f);
    g_State.points[3] = CGL_vec2_init(0.0f, -0.5f);

    g_State.aspect_ratio = 16.0f / 9.0f;
    
    return CGL_TRUE;
}

CGL_void cleanup() {
    CGL_framebuffer_destroy(g_State.default_framebuffer);
    CGL_widgets_shutdown();
    CGL_gl_shutdown();
    CGL_window_destroy(g_State.window);
    CGL_shutdown();
}

EM_BOOL loop(double time, void* userData) {
    (void)time;
    (void)userData;
    
    static CGL_int wx = 0, wy = 0;
    static CGL_byte buffer[25];
    static CGL_int frame_number = 0;

    frame_number++;
    CGL_window_set_size(g_State.window, 512, 512);
    CGL_window_get_framebuffer_size(g_State.window, &wx, &wy);
    g_State.aspect_ratio = (CGL_float)wx / (CGL_float)wy;

    CGL_framebuffer_bind(g_State.default_framebuffer);
    CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);

    CGL_widgets_begin();

    for(CGL_int i = 0; i < 4; i++) {
        CGL_widgets_set_fill_colorf(0.9f, 0.8f, 0.2f, 1.0f);
        if(i == g_State.selected_point) CGL_widgets_add_circle2f(g_State.points[i].x, g_State.points[i].y, 0.06f);
        if(i < 2) CGL_widgets_set_fill_colorf(0.2f, 0.8f, 0.2f, 1.0f);
        else CGL_widgets_set_fill_colorf(0.8f, 0.2f, 0.2f, 1.0f);
        CGL_widgets_add_circle2f(g_State.points[i].x, g_State.points[i].y, 0.05f);
    }

    CGL_widgets_set_stroke_colorf(0.8f, 0.7f, 0.3f, 1.0f);
    CGL_widgets_set_stroke_thicnkess(0.01f);
    CGL_widgets_add_cubic_bazier2v(g_State.points[0], g_State.points[1], g_State.points[2], g_State.points[3], g_State.line_resolution);
    CGL_widgets_add_cubic_bazier_points2v(g_State.points[0], g_State.points[1], g_State.points[2], g_State.points[3], g_State.line_resolution);

    CGL_widgets_set_fill_colorf(0.8f, 0.8f, 0.8f, 1.0f);
    sprintf(buffer, "Line Resolution: %d", g_State.line_resolution);
    CGL_widgets_add_string(buffer, -1.0f, 0.9f, 1.0f, 0.1f);

    static CGL_int old_frame_number = 0;
    static CGL_int delta = 0;
    delta = 0;
    if(CGL_window_get_key(g_State.window, CGL_KEY_UP) == CGL_PRESS) delta = 1;
    if(CGL_window_get_key(g_State.window, CGL_KEY_DOWN) == CGL_PRESS) delta = -1;
    if(delta != 0 && (frame_number - old_frame_number) > 30) {
        old_frame_number = frame_number;
        g_State.line_resolution += delta;
        g_State.line_resolution = CGL_utils_clamp(g_State.line_resolution, 3, 100);
    }

    double mpx, mpy;
    CGL_window_get_mouse_position(g_State.window, &mpx, &mpy);
    mpx = mpx / (double)wx * 2.0 - 1.0;
    mpy = 2.0f - mpy / (double)wy * 2.0 - 1.0;
    g_State.selected_point = -1;
    for(CGL_int i = 0 ; i < 4 ; i++) {
        if(sqrt(pow(mpx - g_State.points[i].x, 2) + pow(mpy - g_State.points[i].y, 2)) < 0.05f) {
            g_State.selected_point = i;            
        }
    }

    if(g_State.selected_point != -1) {
        if(CGL_window_get_mouse_button(g_State.window, CGL_MOUSE_BUTTON_LEFT) == CGL_PRESS) {
            g_State.points[g_State.selected_point].x = (CGL_float)mpx;
            g_State.points[g_State.selected_point].y = (CGL_float)mpy;
        }
    }


    CGL_widgets_end();

    CGL_window_swap_buffers(g_State.window);
    CGL_window_poll_events(g_State.window);    

    return CGL_TRUE;
}

int main()
{
    if(!init()) return EXIT_FAILURE;
#ifdef CGL_WASM
    CGL_info("Running in WASM mode");
    emscripten_request_animation_frame_loop(loop, NULL);
#else
    while(!CGL_window_should_close(g_State.window)) {
        if (!loop(0.0, NULL)) break;
    }
    cleanup();
#endif
    return EXIT_SUCCESS;
}

```

`examples/c/bloom.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_IMPLEMENTATION
#include "cgl.h"

static const char* PASS_THROUGH_VERTEX_SHADER_SOURCE = "#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 normal;\n"
"layout (location = 2) in vec4 texcoord;\n"
"\n"
"out vec3 Position;\n"
"out vec2 TexCoord;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = vec4(position.xyz, 1.0f);\n"
"	Position = position.xyz;\n"
"	TexCoord = texcoord.xy;\n"
"}";

static const char* PASS_THROUGH_FRAGMENT_SHADER_SOURCE = "#version 430 core\n"
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Position;\n"
"in vec2 TexCoord;\n"
"\n"
"uniform sampler2D u_tex;\n"
"\n"
"void main()\n"
"{\n"
"	vec4 color = texture(u_tex, TexCoord);\n"
"	FragColor = color;\n"
"}";


int main()
{
    srand((uint32_t)time(NULL));
    CGL_init();
    CGL_window* window = CGL_window_create(640, 360, "CGL Text Widgets - Jaysmito Mukherjee");
    CGL_window_make_context_current(window); 
    CGL_gl_init();
    CGL_widgets_init();
    if(window == NULL) return false; 
    CGL_framebuffer* framebuffer = CGL_framebuffer_create(640, 360);
    CGL_framebuffer* default_framebuffer = CGL_framebuffer_create_from_default(window);

    CGL_mesh_cpu* quad_mesh_cpu = CGL_mesh_cpu_quad(
        CGL_vec3_init(1.0f, 1.0f, 0.0f),
        CGL_vec3_init(1.0f, -1.0f, 0.0f),
        CGL_vec3_init(-1.0f, -1.0f, 0.0f),
        CGL_vec3_init(-1.0f, 1.0f, 0.0f)
    );

    CGL_mesh_gpu* quad_mesh = CGL_mesh_gpu_create();
    CGL_mesh_gpu_upload(quad_mesh, quad_mesh_cpu, true);
    CGL_mesh_cpu_destroy(quad_mesh_cpu);
    CGL_shader* shader = CGL_shader_create(PASS_THROUGH_VERTEX_SHADER_SOURCE, PASS_THROUGH_FRAGMENT_SHADER_SOURCE, NULL);

    CGL_bloom* bloom = CGL_bloom_create(640, 360, 3);
    CGL_bloom_set_offset(bloom, 3, 3);

    bool bloom_enabled = true;
    float intensity = 4.0f;
    float aspect_ratio = 16.0f / 9.0f;
    int wx = 0, wy = 0;

    while(!CGL_window_should_close(window)) 
    {
        CGL_window_get_framebuffer_size(window, &wx, &wy);
        aspect_ratio = (float)wx / (float)wy;

        CGL_framebuffer_bind(framebuffer);
        CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);
        CGL_widgets_begin();
        CGL_widgets_add_string("CGL", -0.5f, -0.5f, 1.0f, 1.0f);

        CGL_widgets_set_fill_colorf(0.78f * intensity, 0.44f * intensity, 0.89f * intensity, 1.0f * intensity);

        CGL_widgets_add_rect2f(-0.75f, -0.75f, 1.5f, 0.05f * aspect_ratio);
        CGL_widgets_add_rect2f(-0.75f,  0.70f, 1.5f, 0.05f * aspect_ratio);
        CGL_widgets_add_rect2f(-0.75f, -0.75f, 0.05f, 1.5f);
        CGL_widgets_add_rect2f(0.7f, -0.75f, 0.05f, 1.5f);
        
        CGL_widgets_end();

        if(bloom_enabled) CGL_bloom_apply(bloom, CGL_framebuffer_get_color_texture(framebuffer));

        CGL_framebuffer_bind(default_framebuffer);
        CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);
        CGL_shader_bind(shader);
        CGL_texture_bind(CGL_framebuffer_get_color_texture(framebuffer), 0);
        CGL_shader_set_uniform_int(shader, CGL_shader_get_uniform_location(shader, "u_tex"), 0);
        CGL_mesh_gpu_render(quad_mesh);

        CGL_window_swap_buffers(window);
        CGL_window_poll_events(window);

        if(CGL_window_get_key(window, CGL_KEY_A) == CGL_PRESS) bloom_enabled = true;
        if(CGL_window_get_key(window, CGL_KEY_S) == CGL_PRESS) bloom_enabled = false;
    }


    CGL_bloom_destroy(bloom);    
    CGL_shader_destroy(shader);
    CGL_framebuffer_destroy(framebuffer);
    CGL_framebuffer_destroy(default_framebuffer);
    CGL_mesh_gpu_destroy(quad_mesh);
    CGL_widgets_shutdown();
    CGL_gl_shutdown();
    CGL_window_destroy(window);
    CGL_shutdown();
    return EXIT_SUCCESS;
}

```

`examples/c/christmas_tree01.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/


#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_EXCLUDE_NETWORKING
#define CGL_EXCLUDE_RAY_CASTER
#define CGL_EXCLUDE_NODE_EDITOR
#define CGL_EXCLUDE_WIDGETS
#include "cgl.h"

#ifdef CGL_WASM
#include <emscripten/emscripten.h>
#include <emscripten/html5.h>
#else 
#define EM_BOOL int
#endif

#define TRAIL_COUNT 5
#define DECORATION_COUNT 64

static const char* PASS_THROUGH_VERTEX_SHADER_SOURCE = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
"\n"
"in vec4 position;\n"
"in vec4 normal;\n"
"in vec4 texcoord;\n"
#else
"#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 normal;\n"
"layout (location = 2) in vec4 texcoord;\n"
#endif
"\n"
"out vec3 Position;\n"
"out vec2 TexCoord;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = vec4(position.xyz, 1.0f);\n"
"	Position = position.xyz;\n"
"	TexCoord = texcoord.xy;\n"
"}";

static const char* PASS_THROUGH_FRAGMENT_SHADER_SOURCE = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
#else
"#version 430 core\n"
#endif
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Position;\n"
"in vec2 TexCoord;\n"
"\n"
"uniform sampler2D u_tex;\n"
"\n"
"// Black Box From https://github.com/armory3d/armory/blob/master/Shaders/std/tonemap.glsl\n"
"vec3 acesFilm(const vec3 x) {\n"
"    const float a = 2.51;\n"
"    const float b = 0.03;\n"
"    const float c = 2.43;\n"
"    const float d = 0.59;\n"
"    const float e = 0.14;\n"
"    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	vec3 color = texture(u_tex, vec2(TexCoord.y, 1.0f - TexCoord.x)).rgb;\n"
"	color = acesFilm(color);\n"
"   color = pow(color, vec3(1.0f / 2.2f));\n"
"	FragColor = vec4(color, 1.0f);\n"
"}";


static const char* TRAIL_VERTEX_SHADER = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
"\n"
"in vec4 position;\n"
"in vec4 normal;\n"
"in vec4 texcoord;\n"
#else
"#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n" // w is lifespan
"layout (location = 1) in vec4 normal;\n" // w is distance
"layout (location = 2) in vec4 texcoord;\n" // zw is reserved for future use
#endif
"\n"
"out vec3 Position;\n"
"out vec2 TexCoord;\n"
"out vec3 Normal;\n"
"out float Distance;\n"
"out float Life;\n"
"\n"
"uniform mat4 projection;\n"
"uniform mat4 view;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = projection * view * vec4(position.xyz, 1.0f);\n"
"	Position = position.xyz;\n"
"	TexCoord = texcoord.xy;\n"
"	Distance = normal.w;\n"
"	Life = position.w;\n"
"	Normal = normal.xyz;\n"
"}\n";

static const char* TRAIL_FRAGMENT_SHADER = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
#else
"#version 430 core\n"
#endif
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Position;\n"
"in vec2 TexCoord;\n"
"in vec3 Normal;\n"
"in float Distance;\n"
"in float Life;\n"
"\n"
"uniform vec3 color;\n"
"uniform float total_length;\n"
"\n"
"void main()\n"
"{\n"
"	FragColor = vec4(mix(color * 0.5f, vec3(0.0f), (10.0f - Life) / 300.0f), 1.0f);\n"
"}\n";

static const char* DECORATIONS_VERTEX_SHADER = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
"\n"
"in vec4 position;\n"
"in vec4 normal;\n"
"in vec4 texcoord;\n"
#else
"#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 normal;\n"
"layout (location = 2) in vec4 texcoord;\n"
#endif
"\n"
"out vec3 Position;\n"
"out vec2 TexCoord;\n"
"out vec3 Normal;\n"
"\n"
"uniform mat4 projection;\n"
"uniform mat4 view;\n"
"uniform mat4 model;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = projection * view * model * vec4(position.xyz, 1.0f);\n"
"	Position = position.xyz;\n"
"	TexCoord = texcoord.xy;\n"
"	Normal = normal.xyz;\n"
"}\n";

static const char* DECORATIONS_FRAGMENT_SHADER = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
#else
"#version 430 core\n"
#endif
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Position;\n"
"in vec2 TexCoord;\n"
"in vec3 Normal;\n"
"\n"
"uniform vec3 color;\n"
"\n"
"void main()\n"
"{\n"
"   vec3 lightPos = vec3(12.0f, 12.0f, 12.0f);\n"
"   vec3 lightDir = normalize(lightPos - Position);\n"
"   float diffuse = clamp(max(dot(Normal, lightDir), 0.0f), 0.0f, 1.0f);\n"
"	FragColor = vec4(color * 1.5f * (diffuse * 0.5f + 0.5f), 1.0f);\n"
"}\n";


typedef struct
{
    CGL_mat4 transform;
    CGL_vec3 color;
    CGL_mesh_gpu* mesh;
} Decoration;

struct {
    CGL_window* window;
    CGL_framebuffer* default_framebuffer;
    CGL_framebuffer* bloom_framebuffer;

    CGL_shader* present_shader;
    CGL_shader* trail_shader;
    CGL_shader* decoration_shader;

    CGL_mat4 projection;
    CGL_mat4 view;

    CGL_mesh_gpu* sphere_mesh_gpu;
    CGL_mesh_gpu* cube_mesh_gpu;
    CGL_mesh_gpu* star_mesh_gpu;

    CGL_trail* trail[TRAIL_COUNT];
    CGL_vec3 trail_color[TRAIL_COUNT];
    Decoration decorations[DECORATION_COUNT];

    CGL_bool started;

    CGL_audio_context* audio_context;
    CGL_audio_source* audio_source;
    CGL_audio_buffer* audio_buffer;

    
    CGL_vec3 trail_tip_pos;
    CGL_vec3 trail_tip_pos_prev;
    CGL_float time_taken_to_reach_top;
    CGL_float max_height;

#ifndef CGL_WASM
    CGL_bloom* bloom;
#endif
} g_State;

bool point_function(CGL_trail* trail, CGL_trail_point* point)
{
    point->thickness = 0.02f *  powf((trail->length - point->distance) / trail->length, 1.5f);
    return false;
}

CGL_bool init() {
    srand((uint32_t)time(NULL));
    if(!CGL_init()) return CGL_FALSE;
    g_State.window = CGL_window_create(600, 600, "Christmas Tree 01 - Jaysmito Mukherjee");
    if(!g_State.window) return 1;
    CGL_window_make_context_current(g_State.window);
    CGL_gl_init();
    g_State.default_framebuffer = CGL_framebuffer_create_from_default(g_State.window);
    g_State.bloom_framebuffer = CGL_framebuffer_create_basic(600, 600);

 
    g_State.present_shader = CGL_shader_create(PASS_THROUGH_VERTEX_SHADER_SOURCE, PASS_THROUGH_FRAGMENT_SHADER_SOURCE, NULL);
    g_State.trail_shader = CGL_shader_create(TRAIL_VERTEX_SHADER, TRAIL_FRAGMENT_SHADER, NULL);
    g_State.decoration_shader = CGL_shader_create(DECORATIONS_VERTEX_SHADER, DECORATIONS_FRAGMENT_SHADER, NULL);

    g_State.projection = CGL_mat4_perspective(CGL_deg_to_rad(45.0f), 1.0f, 0.01f, 100.0f);
    g_State.view = CGL_mat4_identity();

#ifndef CGL_WASM
    g_State.bloom = CGL_bloom_create(600, 600, 3);
#endif

    CGL_mesh_cpu* sphere_mesh_cpu = CGL_mesh_cpu_sphere(16, 16);
    g_State.sphere_mesh_gpu = CGL_mesh_gpu_create();
    CGL_mesh_gpu_upload(g_State.sphere_mesh_gpu, sphere_mesh_cpu, true);
    CGL_mesh_cpu_destroy(sphere_mesh_cpu);

    CGL_mesh_cpu* cube_mesh_cpu = CGL_mesh_cpu_cube(false);
    CGL_mesh_cpu_recalculate_normals(cube_mesh_cpu);
    g_State.cube_mesh_gpu = CGL_mesh_gpu_create();
    CGL_mesh_gpu_upload(g_State.cube_mesh_gpu, cube_mesh_cpu, true);
    CGL_mesh_cpu_destroy(cube_mesh_cpu);

    // mesh from https://sketchfab.com/3d-models/star-f7a96ca9ce3c4a0ba622088fffffa51c
    CGL_mesh_cpu* star_mesh_cpu = CGL_mesh_cpu_load_obj("assets/star.obj");
    CGL_mesh_cpu_recalculate_normals(star_mesh_cpu);
    g_State.star_mesh_gpu = CGL_mesh_gpu_create();
    CGL_mesh_gpu_upload(g_State.star_mesh_gpu, star_mesh_cpu, true);
    CGL_mesh_cpu_destroy(star_mesh_cpu);


    for(int i = 0; i < TRAIL_COUNT; i++)
    {
        g_State.trail[i] = CGL_trail_create();
        CGL_trail_set_min_points_distance(g_State.trail[i], 0.005f);
        CGL_trail_set_resolution(g_State.trail[i], 32);
        CGL_trail_set_point_update_function(g_State.trail[i], point_function);
    }

    g_State.trail_tip_pos = CGL_vec3_init(0.0f, 0.0f, 0.0f);
    g_State.trail_tip_pos_prev = CGL_vec3_init(0.0f, 0.0f, 0.0f);
    g_State.time_taken_to_reach_top = 8.0f;
    g_State.max_height = 8.0f;

    g_State.started = false;

    for(CGL_int i = 0; i < TRAIL_COUNT; i++) {
        g_State.trail_color[i] = CGL_vec3_init(
            CGL_utils_random_float() * 0.3f,
            CGL_utils_random_float() * 0.5f + 0.5f,
            CGL_utils_random_float() * 0.3f
        );
    }

    for(CGL_int i = 0; i < DECORATION_COUNT ; i++)
    {
        CGL_float height_f = 0.0f;
        // this is a very bad way to do this, but it works for now so .....
        while(!(height_f >= 0.15f && height_f <= 0.85f)) height_f = powf(CGL_E, -6.0f * (CGL_utils_random_float() * 0.7f));
        CGL_float angle = CGL_utils_random_float() * 2.0f * CGL_PI;
        CGL_vec3 pos = CGL_vec3_init(cosf(angle) * 3.0f * (1.0f - height_f), height_f * g_State.max_height, sinf(angle) * 3.0f * (1.0f - height_f));
        CGL_float scalef = CGL_utils_random_float() * 0.3f + 0.85f;
        CGL_vec3 scale = CGL_vec3_init(0.1f * scalef, 0.1f * scalef, 0.1f * scalef);
        g_State.decorations[i].transform = CGL_mat4_translate(pos.x, pos.y, pos.z);
        CGL_mat4 tmp = CGL_mat4_scale(scale.x, scale.y, scale.z);
        g_State.decorations[i].transform = CGL_mat4_mul(g_State.decorations[i].transform, tmp);
        g_State.decorations[i].mesh = rand() % 2 == 0 ? g_State.sphere_mesh_gpu : g_State.cube_mesh_gpu;
        g_State.decorations[i].color = CGL_vec3_init(CGL_utils_random_float(), CGL_utils_random_float(), CGL_utils_random_float());
    }

    g_State.audio_context = CGL_audio_context_create(NULL);
    CGL_audio_make_context_current(g_State.audio_context);
    g_State.audio_source = CGL_audio_source_create();
    g_State.audio_buffer = CGL_audio_buffer_create();
    CGL_wav_file wav_file;

    // i do not own the audio file so i cannot share
    CGL_wav_file_load(&wav_file, "assets/cristmas_wish.wav");
    CGL_audio_buffer_set_data_from_wav_file(g_State.audio_buffer, &wav_file);
    CGL_audio_source_set_buffer(g_State.audio_source, g_State.audio_buffer);
    CGL_wav_file_destroy(&wav_file);

    return CGL_TRUE;
}

CGL_void cleanup() {
    CGL_audio_make_context_current(NULL);
    for(int i = 0; i < TRAIL_COUNT; i++) CGL_trail_destroy(g_State.trail[i]);
    CGL_audio_context_destroy(g_State.audio_context);
    CGL_audio_source_destroy(g_State.audio_source);
    CGL_audio_buffer_destroy(g_State.audio_buffer);
    CGL_mesh_gpu_destroy(g_State.sphere_mesh_gpu);
    CGL_mesh_gpu_destroy(g_State.cube_mesh_gpu);
    CGL_mesh_gpu_destroy(g_State.star_mesh_gpu);
    CGL_shader_destroy(g_State.trail_shader);
    CGL_shader_destroy(g_State.decoration_shader);
    CGL_shader_destroy(g_State.present_shader);
    CGL_framebuffer_destroy(g_State.default_framebuffer);
    CGL_framebuffer_destroy(g_State.bloom_framebuffer);
#ifndef CGL_WASM
    CGL_bloom_destroy(g_State.bloom);
#endif
    CGL_gl_shutdown();
    CGL_window_destroy(g_State.window);    
    CGL_shutdown();
}

EM_BOOL loop(double _time, void* userData) {
    (void)userData;
    (void)_time;


    static CGL_float curr_time = 0.0f;
    static CGL_float prev_time = 0.0f;
    static CGL_float time = 0.0f;

    curr_time = CGL_utils_get_time();
    CGL_float delta_time = curr_time - prev_time;
    prev_time = curr_time;
     
    if(g_State.started) time += CGL_utils_clamp(delta_time, 0.0f, 0.05f); // to avoid sudden jumps in time due to lag or things like window resizing
     
    CGL_window_set_size(g_State.window, 600, 600); // force window size to be 600x600

    g_State.view = CGL_mat4_look_at(CGL_vec3_init(8.0f * cosf(time), 12.0f, 8.0f * sinf(time)), CGL_vec3_init(0.0f, 4.5f, 0.0f), CGL_vec3_init(0.0f, 1.0f, 0.0f));

    CGL_float factor = time / g_State.time_taken_to_reach_top;
    if(factor < 1.0f && g_State.started)
        {
        CGL_float ifactor = 1.0f - factor;
        CGL_float rot_speed = 18.0f;
        g_State.trail_tip_pos = CGL_vec3_init(cosf(time*rot_speed) * 3.0f * ifactor, g_State.max_height * factor, sinf(time*rot_speed) * 3.0f * ifactor);
        CGL_vec3 trail_tip_vec = CGL_vec3_sub(g_State.trail_tip_pos, g_State.trail_tip_pos_prev);
        g_State.trail_tip_pos_prev = g_State.trail_tip_pos;
        CGL_vec3 front = CGL_vec3_init(0.0f, 0.0f, 1.0f);
        CGL_vec3 top = CGL_vec3_init(1.0f, 0.0f, 0.0f);
        CGL_vec3_calculate_orthonormal_basis_from_one_vector(trail_tip_vec, &front, &top);
        CGL_float angle_step = CGL_deg_to_rad(360.0f / TRAIL_COUNT);
        for(int i = 0; i < TRAIL_COUNT; i++)            {
            CGL_float thickness = 0.15f + sinf(time) * 0.05f;
            thickness *= powf(ifactor, 1.0f / 3.0f);
            CGL_float phase = time * 8.0f;
            CGL_float ct = cosf(angle_step * i + phase) * thickness; CGL_float st = sinf(angle_step * i + phase) * thickness;
            CGL_vec3 v = CGL_vec3_add_(g_State.trail_tip_pos, CGL_vec3_add_(CGL_vec3_scale_(front, ct), CGL_vec3_scale_(top, st)));

            CGL_trail_add_point(g_State.trail[i], v, 300.0f, 0.1f);
            CGL_trail_update(g_State.trail[i], 0.1f);
            CGL_trail_bake_mesh(g_State.trail[i]);
        }
    }
        
        
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LESS);
    CGL_framebuffer_bind(g_State.bloom_framebuffer);
    CGL_gl_clear(0.0f, 0.0f, 0.0f, 1.0f);
    CGL_shader_bind(g_State.trail_shader);
    for(CGL_int i = 0; i < TRAIL_COUNT; i++) {
        CGL_shader_set_uniform_vec3v(g_State.trail_shader, CGL_shader_get_uniform_location(g_State.trail_shader, "color"), g_State.trail_color[i].x, g_State.trail_color[i].y, g_State.trail_color[i].z);
        CGL_trail_render(g_State.trail[i], &g_State.view, &g_State.projection, g_State.trail_shader);
    }
    if(factor >= 1.0f) {
        factor = (factor - 1.0f) / 0.2f;
        factor = CGL_utils_clamp(factor, 0.0f, 1.0f);
        CGL_shader_bind(g_State.decoration_shader);
        CGL_shader_set_uniform_mat4(g_State.decoration_shader, CGL_shader_get_uniform_location(g_State.decoration_shader, "view"), &g_State.view);
        CGL_shader_set_uniform_mat4(g_State.decoration_shader, CGL_shader_get_uniform_location(g_State.decoration_shader, "projection"), &g_State.projection);
        CGL_mat4 temp = CGL_mat4_scale(factor, factor, factor);
        CGL_mat4 temp2 = CGL_mat4_identity();
        for(CGL_int i = 0; i < DECORATION_COUNT; i++) {
            temp2 = CGL_mat4_mul(g_State.decorations[i].transform, temp);
            CGL_shader_set_uniform_mat4(g_State.decoration_shader, CGL_shader_get_uniform_location(g_State.decoration_shader, "model"), &temp2);
            CGL_shader_set_uniform_vec3v(g_State.decoration_shader, CGL_shader_get_uniform_location(g_State.decoration_shader, "color"), g_State.decorations[i].color.x, g_State.decorations[i].color.y, g_State.decorations[i].color.z);
            CGL_mesh_gpu_render(g_State.decorations[i].mesh);
        }
        CGL_shader_set_uniform_vec3v(g_State.decoration_shader, CGL_shader_get_uniform_location(g_State.decoration_shader, "color"), 1.0f, 1.0f, 0.0f);
        factor *= 0.3f;

        temp = CGL_mat4_translate(0.0f, g_State.max_height + 0.1f, 0.09f);
        temp2 = CGL_mat4_scale(factor, factor, -factor);
        temp = CGL_mat4_mul(temp, temp2);
        CGL_shader_set_uniform_mat4(g_State.decoration_shader, CGL_shader_get_uniform_location(g_State.decoration_shader, "model"), &temp);
        CGL_mesh_gpu_render(g_State.star_mesh_gpu);

        temp = CGL_mat4_translate(0.0f, g_State.max_height + 0.1f, -0.09f);
        temp2 = CGL_mat4_scale(factor, factor, factor);
        temp = CGL_mat4_mul(temp, temp2);
        CGL_shader_set_uniform_mat4(g_State.decoration_shader, CGL_shader_get_uniform_location(g_State.decoration_shader, "model"), &temp);
        CGL_mesh_gpu_render(g_State.star_mesh_gpu);
    }

#ifndef CGL_WASM
    CGL_bloom_apply(g_State.bloom, CGL_framebuffer_get_color_texture(g_State.bloom_framebuffer));
#endif

    CGL_framebuffer_bind(g_State.default_framebuffer);
    CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);
    CGL_shader_bind(g_State.present_shader);
    CGL_texture_bind(CGL_framebuffer_get_color_texture(g_State.bloom_framebuffer), 0);
    CGL_shader_set_uniform_int(g_State.present_shader, CGL_shader_get_uniform_location(g_State.present_shader, "u_tex"), 0);
    CGL_gl_render_screen_quad();

    CGL_window_poll_events(g_State.window);
    CGL_window_swap_buffers(g_State.window);

    if(!g_State.started && CGL_window_get_key(g_State.window, CGL_KEY_SPACE) == CGL_PRESS) { g_State.started = true; CGL_audio_source_play(g_State.audio_source);}

    return CGL_TRUE;
}

int main()
{
    if(!init()) return EXIT_FAILURE;
#ifdef CGL_WASM
    CGL_info("Running in WASM mode");
    emscripten_request_animation_frame_loop(loop, NULL);
#else
    while(!CGL_window_should_close(g_State.window)) {
        if(!loop(0.0, NULL)) break;
    }
    cleanup();
#endif
    return EXIT_SUCCESS;
}

```

`examples/c/christmas_tree_02.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#define CGL_EXCLUDE_NETWORKING
#define CGL_EXCLUDE_RAY_CASTER
#define CGL_EXCLUDE_NODE_EDITOR
#include "cgl.h"

static const char* PASS_THROUGH_VERTEX_SHADER_SOURCE = "#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 normal;\n"
"layout (location = 2) in vec4 texcoord;\n"
"\n"
"out vec3 Position;\n"
"out vec2 TexCoord;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = vec4(position.xyz, 1.0f);\n"
"	Position = position.xyz;\n"
"	TexCoord = texcoord.xy;\n"
"}";

static const char* PASS_THROUGH_FRAGMENT_SHADER_SOURCE = "#version 430 core\n"
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Position;\n"
"in vec2 TexCoord;\n"
"\n"
"uniform sampler2D u_tex;\n"
"\n"
"// Black Box From https://github.com/armory3d/armory/blob/master/Shaders/std/tonemap.glsl\n"
"vec3 acesFilm(const vec3 x) {\n"
"    const float a = 2.51;\n"
"    const float b = 0.03;\n"
"    const float c = 2.43;\n"
"    const float d = 0.59;\n"
"    const float e = 0.14;\n"
"    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	vec3 color = texture(u_tex, vec2(TexCoord.y, 1.0f - TexCoord.x)).rgb;\n"
"	color = acesFilm(color);\n"
"   color = pow(color, vec3(1.0f / 2.2f));\n"
"	FragColor = vec4(color, 1.0f);\n"
"}";

static const char* PARTICLE_VERTEX_SHADER_SOURCE = "#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 normal;\n"
"layout (location = 2) in vec4 texcoord;\n"
"\n"
"struct Particle\n"
"{\n"
"   vec4 position; // w has mass\n"
"   vec4 velocity; // w has velocity factor\n"
"   vec4 color; // w is reserved\n"
"};\n"
"\n"
"uniform mat4 view_proj;\n"
"\n"
"// vertices for a pyramid \n"
"const vec3 VERTICES[4] = vec3[4](\n"
"   vec3(0.5f, -0.5f, -1.732f * 0.5f),\n"
"   vec3(0.0f, 0.5f, 0.0f),\n"
"   vec3( 0.5f, -0.5f, 1.732f * 0.5f),\n"
"   vec3(-1.0f, -0.5f, 0.0f)\n"
");\n"
"\n"
"const int INDICES[12] = int[12](\n"
"   0, 1, 2,\n"
"   0, 1, 3,\n"
"   0, 2, 3,\n"
"   1, 2, 3\n"
");\n"
"\n"
"\n"
"layout(std430, binding = 0) buffer Particles\n"
"{\n"
"    Particle particles[];\n"
"};\n"
"\n"
"out vec3 Color;\n"
"\n"
"float atan2(in float y, in float x)\n"
"{\n"
"    bool s = (abs(x) > abs(y));\n"
"    return mix(3.141f/2.0 - atan(x,y), atan(y,x), s);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"   int index = gl_VertexID / 12;\n"
"   int vt_index = gl_VertexID % 12;\n"
"   vec3 position = particles[index].position.xyz * 4.0f + VERTICES[INDICES[vt_index]] * 0.04f * particles[index].color.w;\n"
"   float xz_l = length(position.xz);\n"
"   float part_phase = atan2(position.x, position.z);\n"
"   position.xz = vec2(cos(position.y + part_phase), sin(position.y + part_phase)) * xz_l;\n"
"	gl_Position = view_proj * vec4(position.xyz, 1.0f);\n"
"   float dfc = length(particles[index].velocity.xyz) / 10.0f;\n"
"   Color = particles[index].color.rgb * (pow(log(position.y + 1), 4.0f) * 0.1f + 0.05f) ;\n"
"}\n";

static const char* PARTICLE_FRAGMENT_SHADER_SOURCE = "#version 430 core\n"
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Color;\n"
"\n"
"void main()\n"
"{\n"
"	FragColor = vec4(Color, 1.0f);\n"
"}";

static const char* COMPUTE_SHADER_SOURCE = "#version 430 core\n"
"\n"
"layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;\n"
"\n"
"uniform int mode;\n"
"uniform float dt;\n"
"uniform float r_seed;\n"
"\n"
"struct Particle\n"
"{\n"
"   vec4 position; // w has mass\n"
"   vec4 velocity; // w has velocity factor\n"
"   vec4 color; // w is reserved\n"
"};\n"
"\n"
"layout(std430, binding = 0) buffer Particles\n"
"{\n"
"    Particle particles[];\n"
"};\n"
"\n"
"// Hash function www.cs.ubc.ca/~rbridson/docs/schechter-sca08-turbulence.pdf\n"
"int hash(int state)\n"
"{\n"
"    state ^= 2747636419;\n"
"    state *= 2654435769;\n"
"    state ^= state >> 16;\n"
"    state *= 2654435769;\n"
"    state ^= state >> 16;\n"
"    state *= 2654435769;\n"
"    return state;\n"
"}\n"
"\n"
"// From https://www.shadertoy.com/view/Xt23Ry\n"
"float rand(int co) { return fract(sin(float(co)*(91.3458) + r_seed) * 47453.5453); }\n"
"\n"
"float rand2(int co) { return rand(co) * 2.0f - 1.0f; }\n"
"\n"
"void initialize()\n"
"{\n"
"    int index = int(gl_GlobalInvocationID.x);\n"
"    int sqrt_pt_ct = 300;\n"
"    int x = index % sqrt_pt_ct;\n"
"    int y = index / sqrt_pt_ct;\n"
"    vec2 pos_xy = vec2(x, y) / float(sqrt_pt_ct) * 2.0f - vec2(1.0f);\n"
"    pos_xy *= 2.0f;\n"
"    particles[index].position = vec4(pos_xy.x, rand(index + 6) * 0.1f, pos_xy.y, 0.0f);\n"
"    float mass = rand(hash(index + 485) + 458) * 2.0f + 2.0f;\n"
"    float lent = length(particles[index].position.xz) + 0.05f;\n"
"    mass /= 1.0f - pow(exp(-lent), 8);\n"
"    particles[index].position.w = mass;\n"
"    particles[index].velocity = vec4(0.0f, 0.0f, 0.0f, 1.0f);\n"
"    particles[index].color = vec4(rand(hash(index + 15)) * 0.2, rand(hash(index + 150))*0.2+0.5, rand(hash(index + 250)) * 0.2, 1.0f);\n"
"    particles[index].color.w = 1.0f + rand2(hash(index)) * 0.2f;\n"
"}\n"
"\n"
"void update()\n"
"{\n"
"   int index = int(gl_GlobalInvocationID.x);\n"
"   vec3 pos = particles[index].position.xyz;\n"
"   vec3 vel = particles[index].velocity.xyz;\n"
"   vec3 acc = vec3(0.0f);\n"
"   float mass = particles[index].position.w;\n"
"   float vel_factor = particles[index].velocity.w;\n"
"   float lent = length(pos.xz);\n"
"   acc += vec3(0.0f, 2.0f / (lent * lent) , 0.0f) / mass;\n"
"   acc += 0.8f * -(vec3(pos.x, 0.0f, pos.z)) / (lent * lent) / mass;\n"
"   vec3 cfgpr_ax = normalize(cross(vec3(0.0f, 1.0f, 0.0f), vec3(pos.x, 0.0f, pos.z)));\n"
"   vel += acc * dt * vel_factor;\n"
"   pos += vel * dt;\n"
"   if(pos.y > 4.8)\n"
"   {\n"
"       if(rand(index + int(dt * 1000)) > 0.90f) initialize();\n"
"       else { particles[index].position.xyz = normalize(vec3(pos.x, rand(index), pos.z)) * 0.2f + vec3(0.0f, 4.8f, 0.0f); particles[index].color.xyz = vec3(1.2f, 1.2f, 0.0f); }\n"
"   }\n"
"   else if(length(pos.xz) > ((0.7f + sin(pos.y * 5.0f)*0.3f) * exp(-pos.y/1.0f)) && pos.y > -0.05f)\n"
"   {\n"
"       particles[index].position.xyz = pos;\n"
"       particles[index].velocity.xyz = vel;\n"
"   }\n"
"   else\n"
"   {\n"
"       initialize();\n"
"   }\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"    if(mode == 0) initialize();\n"
"    else if(mode == 1) update();\n"
"}";

#define PARTICLES_COUNT 90000


static CGL_int resolution = 256;
static CGL_framebuffer* default_framebuffer = NULL, *bloom_framebuffer = NULL;
static CGL_shader *particles_shader = NULL, *present_shader = NULL, *compute_shader = NULL;
static CGL_float delta_time = 0.0f;
static CGL_ssbo* particles_ssbo = NULL;

void reset_sim()
{
    CGL_shader_bind(compute_shader);
    CGL_shader_set_uniform_int(compute_shader, CGL_shader_get_uniform_location(compute_shader, "mode"), 0);
    CGL_shader_set_uniform_float(compute_shader, CGL_shader_get_uniform_location(compute_shader, "dt"), delta_time);
    CGL_shader_set_uniform_float(compute_shader, CGL_shader_get_uniform_location(compute_shader, "r_seed"), (float)rand());
    CGL_shader_compute_dispatch(compute_shader, PARTICLES_COUNT / 256 + 1, 1, 1);
}

void update_sim()
{
    CGL_shader_bind(compute_shader);
    CGL_shader_set_uniform_int(compute_shader, CGL_shader_get_uniform_location(compute_shader, "mode"), 1);
    CGL_shader_set_uniform_float(compute_shader, CGL_shader_get_uniform_location(compute_shader, "dt"), delta_time);
    CGL_shader_set_uniform_float(compute_shader, CGL_shader_get_uniform_location(compute_shader, "r_seed"), (float)rand());
    CGL_shader_compute_dispatch(compute_shader, PARTICLES_COUNT / 256 + 1, 1, 1);
}

int main()
{
    srand((uint32_t)time(NULL));
    CGL_init();
    CGL_window* window = CGL_window_create(700, 700, "Particle Physics Dance - Jaysmito Mukherjee");
    if(!window) return 1;
    CGL_window_make_context_current(window);
    CGL_gl_init();
    CGL_widgets_init();

    default_framebuffer = CGL_framebuffer_create_from_default(window);
    bloom_framebuffer = CGL_framebuffer_create(700, 700);

    present_shader = CGL_shader_create(PASS_THROUGH_VERTEX_SHADER_SOURCE, PASS_THROUGH_FRAGMENT_SHADER_SOURCE, NULL);
    particles_shader = CGL_shader_create(PARTICLE_VERTEX_SHADER_SOURCE, PARTICLE_FRAGMENT_SHADER_SOURCE, NULL);
    compute_shader = CGL_shader_compute_create(COMPUTE_SHADER_SOURCE, NULL);

    particles_ssbo = CGL_ssbo_create(0);
    CGL_ssbo_set_data(particles_ssbo, PARTICLES_COUNT * 12 * sizeof(CGL_float), NULL, GL_DYNAMIC_DRAW);


    CGL_float curr_time = CGL_utils_get_time();
    CGL_float prev_time = CGL_utils_get_time();
    CGL_float time = 0.0f, frame_time = 0.0f;
    CGL_int frames = 0, fps = 0;
    
    CGL_mat4 projection = CGL_mat4_perspective(CGL_deg_to_rad(45.0f), 1.0f, 0.01f, 100.0f);
    CGL_mat4 view = CGL_mat4_identity();

    CGL_bloom* bloom = CGL_bloom_create(700, 700, 3);
    CGL_bloom_set_threshold(bloom, 1.0f);
    CGL_bloom_set_offset(bloom, 3.0f, 3.0f);

    reset_sim();

    while(!CGL_window_should_close(window))
    {
        CGL_window_set_size(window, 700, 700); // force window size to be 600x600

        view = CGL_mat4_look_at(CGL_vec3_init(20.0f, 20.0f, 20.0f), CGL_vec3_init(0.0f, 10.0f, 0.0f), CGL_vec3_init(0.0f, 1.0f, 0.0f));
        view = CGL_mat4_mul(projection, view);

        curr_time = CGL_utils_get_time();
        delta_time = curr_time - prev_time;
        prev_time = curr_time;
        time += delta_time; frame_time += delta_time;
        frames++;
        if(frame_time >= 1.0f) { fps = frames; frames = 0; frame_time = 0.0f; }

        update_sim();

        glEnable(GL_DEPTH_TEST);
        glDepthFunc(GL_LESS);

        CGL_framebuffer_bind(bloom_framebuffer);
        CGL_gl_clear(0.0f, 0.0f, 0.0f, 1.0f);
        CGL_shader_bind(particles_shader);
        CGL_shader_set_uniform_mat4(particles_shader, CGL_shader_get_uniform_location(particles_shader, "view_proj"), &view);
        CGL_shader_set_uniform_float(particles_shader, CGL_shader_get_uniform_location(particles_shader, "dt"), delta_time);
        glDrawArrays(GL_TRIANGLES, 0, PARTICLES_COUNT * 12);

        CGL_bloom_apply(bloom, CGL_framebuffer_get_color_texture(bloom_framebuffer));

        CGL_framebuffer_bind(default_framebuffer);
        CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);
        CGL_shader_bind(present_shader);
        CGL_texture_bind(CGL_framebuffer_get_color_texture(bloom_framebuffer), 0);
        CGL_shader_set_uniform_int(present_shader, CGL_shader_get_uniform_location(present_shader, "u_tex"), 0);
        CGL_gl_render_screen_quad();

        glDisable(GL_DEPTH_TEST);

        CGL_widgets_begin();

        static CGL_byte buffer[1024];
        sprintf(buffer, "Framerate: %d", fps);
        CGL_widgets_add_string(buffer, -1.0f, 0.95f, 1.0f, 0.05f);
        sprintf(buffer, "Frametime: %f", delta_time);
        CGL_widgets_add_string(buffer, -1.0f, 0.9f, 1.0f, 0.05f);



        CGL_widgets_end();

        CGL_window_poll_events(window);
        CGL_window_swap_buffers(window);

        if(CGL_window_is_key_pressed(window, CGL_KEY_SPACE)) reset_sim();


    }

    CGL_bloom_destroy(bloom);

    CGL_ssbo_destroy(particles_ssbo);

    CGL_shader_destroy(present_shader);
    CGL_shader_destroy(particles_shader);
    CGL_shader_destroy(compute_shader); 

    CGL_framebuffer_destroy(bloom_framebuffer);
    CGL_framebuffer_destroy(default_framebuffer);
    CGL_widgets_shutdown();
    CGL_gl_shutdown();
    CGL_window_destroy(window);    
    CGL_shutdown();
    return 0;
}

```

`examples/c/climate_spiral.c`:

```c
/*
MIT License
Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_TRAIL_MAX_POINTS 1024 * 1024
#define CGL_EXCLUDE_NETWORKING
#define CGL_LOGGING_ENABLED
#define CGL_EXCLUDE_AUDIO
#define CGL_EXCLUDE_TEXT_RENDER 
#define CGL_IMPLEMENTATION
#include "cgl.h"

static const char* TRAIL_VERTEX_SHADER =
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
"\n"
"in vec4 position;\n" // w is lifespan
"in vec4 normal;\n" // w is distance
"in vec4 texcoord;\n" // zw is reserved for future use
#else
"#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n" // w is lifespan
"layout (location = 1) in vec4 normal;\n" // w is distance
"layout (location = 2) in vec4 texcoord;\n" // zw is reserved for future use
#endif
"\n"
"out vec3 Position;\n"
"out vec2 TexCoord;\n"
"out float Disturbance;\n"
"\n"
"uniform mat4 projection;\n"
"uniform mat4 view;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = projection * view * vec4(position.xyz, 1.0f);\n"
"	Position = position.xyz;\n"
"	TexCoord = texcoord.xy;\n"
"   Disturbance = length(position.xz);\n"
"}\n";

static const char* TRAIL_FRAGMENT_SHADER = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
#else  
"#version 430 core\n"
#endif
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Position;\n"
"in vec2 TexCoord;\n"
"in float Disturbance;\n"
"\n"
"void main()\n"
"{\n"
"   vec3 color = vec3(0.0f);\n"
"   float d = Disturbance - 2.0f;\n"
"   // disturnabce is in range [-1, 1] -> map it to colour blue to red\n" 
"   if (d < 0.0f) color = mix(vec3(1.0f, 1.0f, 1.0f), vec3(0.0f, 0.0f, 1.0f), -d);\n"
"   else color = mix(vec3(1.0f, 1.0f, 1.0f), vec3(1.0f, 0.0f, 0.0f), d);\n"
"	FragColor = vec4(color, 1.0f);\n"
"}\n";

#ifdef CGL_WASM
#include <emscripten/emscripten.h>
#include <emscripten/html5.h>
#else 
#define EM_BOOL int
#endif

struct {
    CGL_window* window;
    CGL_framebuffer* framebuffer;
    CGL_shader* trail_shader;
    CGL_trail* trail;
    CGL_csv* weather_data;
    CGL_mat4 projection;
    CGL_mat4 view;
    CGL_mat4 rotate_y_pi_4;
    CGL_vec3 trail_tip;
    CGL_vec3 trail_color;
    CGL_bool is_playing;
    CGL_int frame_number;
    CGL_int current_year;
    CGL_int current_month;
    CGL_int next_month;
    CGL_int next_month_year;
    CGL_float current_theta;
    CGL_float delta_time;
    CGL_float base_radius;
    CGL_float actual_radius;
    CGL_float tip_height;
    CGL_float temp_f;
    CGL_float current_month_temp;
    CGL_float next_month_temp;
    CGL_float current_temp;
    CGL_float last_frame_time;   // Add this new field
} g_State;

CGL_bool init() {
    srand((uint32_t)time(NULL));
    if(!CGL_init()) return CGL_FALSE;

    // Initialize window and OpenGL context
    g_State.window = CGL_window_create(700, 700, "Climate Spiral - Jaysmito Mukherjee");
    CGL_window_make_context_current(g_State.window);
    if(!CGL_gl_init()) return CGL_FALSE;
    CGL_widgets_init();
    
    // Create framebuffer and resources
    g_State.framebuffer = CGL_framebuffer_create_from_default(g_State.window);
    g_State.trail_shader = CGL_shader_create(TRAIL_VERTEX_SHADER, TRAIL_FRAGMENT_SHADER, NULL);
    g_State.trail = CGL_trail_create();
    CGL_trail_set_min_points_distance(g_State.trail, 0.01f);
    CGL_trail_set_resolution(g_State.trail, 32);

    // Load weather data
    g_State.weather_data = CGL_csv_create(8);
    if (!CGL_csv_load(g_State.weather_data, "./assets/GLB.Ts+dSST.csv", ",")) {
        CGL_error("Failed to load weather data");
        return CGL_FALSE;
    }

    // Initialize matrices and other state variables
    g_State.projection = CGL_mat4_perspective(CGL_deg_to_rad(45.0f), 1.0f, 0.01f, 100.0f);
    g_State.view = CGL_mat4_identity();
    g_State.rotate_y_pi_4 = CGL_mat4_rotate_y(CGL_PI_2);
    g_State.trail_tip = CGL_vec3_init(0.0f, 0.0f, 0.0f);
    g_State.trail_color = CGL_vec3_init(1.0f, 0.0f, 0.0f);
    g_State.is_playing = CGL_FALSE;
    g_State.frame_number = 0;
    g_State.current_year = 0;
    g_State.current_month = 0;
    g_State.next_month = 1;
    g_State.current_theta = 0.0f;
    g_State.delta_time = 0.15f;
    g_State.base_radius = 2.0f;
    g_State.actual_radius = 1.0f;
    g_State.last_frame_time = CGL_utils_get_time();
    g_State.delta_time = 0.0f;

    return CGL_TRUE;
}

void cleanup() {
    CGL_csv_destroy(g_State.weather_data);
    CGL_trail_destroy(g_State.trail);
    CGL_shader_destroy(g_State.trail_shader);
    CGL_framebuffer_destroy(g_State.framebuffer);
    CGL_widgets_shutdown();
    CGL_gl_shutdown();
    CGL_window_destroy(g_State.window);
    CGL_shutdown();
}

EM_BOOL loop(double time, void* userData) {
    (void)time;
    (void)userData;

    // Calculate delta time
    CGL_float current_time = CGL_utils_get_time();
    g_State.delta_time = current_time - g_State.last_frame_time;
    g_State.last_frame_time = current_time;

    g_State.frame_number++;
    CGL_window_set_size(g_State.window, 700, 700);

    CGL_framebuffer_bind(g_State.framebuffer);
    CGL_gl_clear(0.002f, 0.002f, 0.002f, 1.0f);

    glDisable(GL_DEPTH_TEST);
    CGL_widgets_begin();
    static CGL_byte tmp_buffer[256];

    CGL_widgets_set_fill_mode(false); 
    CGL_widgets_set_stroke_colorf(1.0f, 0.7f, 0.0f, 1.0f); 
    CGL_widgets_set_stroke_thickness(0.01f);

    // the 0 degree circle
    CGL_widgets_add_circle2fr(0, 0, 0.485f, 64);

    // the +1 degree circle
    CGL_widgets_add_circle2fr(0, 0, 0.485f + 0.245f, 64);

    // the -1 degree circle
    CGL_widgets_add_circle2fr(0, 0, 0.485f - 0.245f, 64);
    
    CGL_widgets_set_fill_mode(true); 
    CGL_widgets_set_fill_colorf(1.0f, 0.7f, 0.0f, 1.0f); 
    CGL_widgets_set_stroke_thickness(0.01f);
    CGL_widgets_add_string("0\'C", -0.1f, 0.5f, 0.2f, 0.05f);
    CGL_widgets_add_string("+1\'C", -0.1f, 0.5f + 0.245f, 0.2f, 0.05f);
    CGL_widgets_add_string("-1\'C", -0.1f, 0.5f - 0.245f, 0.2f, 0.05f);

    // the months
    CGL_float delta_out = 0.15f;
    for (CGL_int i = 0 ; i < 12 ; i++)
    {
        sprintf(tmp_buffer, "%s", CGL_csv_get_item(g_State.weather_data, 0, i + 1, NULL));
        CGL_widgets_add_string(tmp_buffer, cosf(CGL_deg_to_rad(90.0f - i * 30.0f)) * (0.485f + 0.245f + delta_out) - 0.05f, sinf(CGL_deg_to_rad(90.0f - i * 30.0f)) * (0.485f + 0.245f + delta_out) - 0.025f, 0.2f, 0.1f);
    }

    // the current year
    if (g_State.current_temp < 0.0f) g_State.trail_color = CGL_vec3_lerp(CGL_vec3_init(1.0f, 1.0f, 1.0f), CGL_vec3_init(0.0f, 0.0f, 1.0f), -g_State.current_temp);
    else g_State.trail_color = CGL_vec3_lerp(CGL_vec3_init(1.0f, 1.0f, 1.0f), CGL_vec3_init(1.0f, 0.0f, 0.0f), g_State.current_temp);
    CGL_widgets_set_fill_colorf(g_State.trail_color.x, g_State.trail_color.y, g_State.trail_color.z, 1.0f);
    CGL_widgets_add_string(CGL_csv_get_item(g_State.weather_data, g_State.current_year + 1, 0, NULL), -0.185f, -0.08f, 0.4f, 0.16f);

    CGL_widgets_end();

    // NOTE: here the 0.01f is there to aboud the angle between camera front and up being 0.0f and causing a division by zero
    g_State.view = CGL_mat4_look_at(CGL_vec3_init(0.0f, 10.0f, 0.001f), CGL_vec3_init(0.0f, 0.0f, 0.0f), CGL_vec3_init(0.0f, 1.0f, 0.0f));
    g_State.view = CGL_mat4_mul(g_State.view, g_State.rotate_y_pi_4); // rotate the camera by 45 degrees around the y axis
    
    // get the ccurrent month index that is the current month index is the floor of the current theta
    // divided by 2PI multiplied by 12 as there are 12 months mapped to 2PI 
    g_State.current_month = (CGL_int)(floorf((g_State.current_theta / CGL_2PI) * 12.0f)) % 12;

    // get next month index
    g_State.next_month = (g_State.current_month + 1); 
    
    // if the next month is greater than 11 then the next month is in the next year 
    // so choose the next year as the current year + 1 else the next year is the current year
    if (g_State.next_month > 11) g_State.next_month_year = g_State.current_year + 1; else g_State.next_month_year = g_State.current_year; 

    // map the next month index to the range 0 to 11
    g_State.next_month = g_State.next_month % 12;

    // the data is from January 1880 to March 2023 so if the next month is April 2023 then stop playing
    if (g_State.next_month == 3 && g_State.next_month_year == 2023 - 1880) g_State.is_playing = false;

    // get the current month and next month temperature
    if(g_State.is_playing)
    {
        g_State.current_month_temp = (CGL_float)atof(CGL_csv_get_item(g_State.weather_data, g_State.current_year + 1, g_State.current_month + 1, NULL));
        g_State.next_month_temp = (CGL_float)atof(CGL_csv_get_item(g_State.weather_data, g_State.next_month_year + 1, g_State.next_month + 1, NULL));
    }
    
    // get the current temperature by lerping between the current month and next month temperature
    g_State.current_temp = CGL_utils_lerp(g_State.current_month_temp, g_State.next_month_temp, modff((g_State.current_theta / CGL_2PI) * 12.0f, &g_State.temp_f));

    // calculate the actual radius of the trail tip by adding the base radius to the current temperature
    g_State.actual_radius = g_State.base_radius + CGL_utils_map(g_State.current_temp, -1.0f, 1.0f, -1.0f, 1.0f);
    
    // calculate the trail tip position
    g_State.trail_tip = CGL_vec3_init(g_State.actual_radius * cosf(g_State.current_theta), g_State.tip_height, g_State.actual_radius * sinf(g_State.current_theta));
    
    // update the current theta and tip height
    // Adjust the speed multiplier (0.5f) to control animation speed
    if(g_State.is_playing) {
        g_State.current_theta += 5.0f * g_State.delta_time;
    }
    if (g_State.current_theta > CGL_2PI) { g_State.current_theta = 0.0f;  g_State.current_year++; }

    // add the trail tip to the trail and update the trail and bake the trail mesh        
    if(g_State.is_playing)
    {
        CGL_trail_add_point(g_State.trail, g_State.trail_tip, 6000.0f, 0.02f);
        CGL_trail_update(g_State.trail, g_State.delta_time);
        CGL_trail_bake_mesh(g_State.trail);
    }

    if (CGL_window_is_key_pressed(g_State.window, CGL_KEY_SPACE)) 
    {
        g_State.current_theta = 0.0f;
        g_State.current_year = 0;
        CGL_trail_clear(g_State.trail);
        g_State.is_playing = CGL_TRUE;
    }

    glEnable(GL_DEPTH_TEST); glDepthFunc(GL_LESS);
    CGL_shader_bind(g_State.trail_shader);
    CGL_trail_render(g_State.trail, &g_State.view, &g_State.projection, g_State.trail_shader);

    CGL_window_swap_buffers(g_State.window);
    CGL_window_poll_events(g_State.window);

    return !CGL_window_should_close(g_State.window);
}

int main() {
    if(!init()) return 1;

#ifdef CGL_WASM
    CGL_info("Running in WASM mode");
    emscripten_request_animation_frame_loop(loop, NULL);
#else
    while (!CGL_window_should_close(g_State.window)) {
        loop(0, NULL);
    }
    cleanup();
#endif
    return 0;
}

```

`examples/c/colored_printf.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_IMPLEMENTATION
#include "cgl.h"


int main()
{
    srand((uint32_t)time(NULL));
    printf("Hello!\n");
    CGL_printf_green("Gello!\n");
    printf("Hello!\n");
    CGL_printf_red("Rello!\n");
    printf("Hello!\n");
    CGL_printf_gray("Yello!\n");
    printf("Hello!\n");

    // custom
    CGL_console_set_color(CGL_CONSOLE_COLOR_GRAY);
    printf("Something !\n");
    printf("Another thing !\n");
    CGL_console_set_color(CGL_CONSOLE_COLOR_RESET);
    printf("Hello!\n");

    return EXIT_SUCCESS;
}

```

`examples/c/creating_threads.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#include "cgl.h"

static struct {
    float delta_x;
    float delta_y;
    float prev_x;
    float prev_y;
} mouse_input;


void input_scroll_callback(CGL_window* window, double x, double y)
{
}

void input_mouse_pos_callback(CGL_window* window, double x, double y)
{
    mouse_input.delta_x = ((float)x - mouse_input.prev_x);
    mouse_input.delta_y = ((float)y - mouse_input.prev_y);
    mouse_input.prev_x = (float)x;
    mouse_input.prev_y = (float)y;
}

void dummy_payload_function(void* argument)
{
    static int invocation_id = 0;
    printf("Invocation %d :", invocation_id++);
    for(int i = 0 ; i < 10;i++)
    {
        Sleep(500);
        printf(" %d ", i);
    }
    printf("\n");
}

void spawn_the_thread(CGL_thread* thread)
{
    if(CGL_thread_is_running(thread))
        fprintf(stdout, "Backgound thread is working\n");
    else
        CGL_thread_start(thread, dummy_payload_function, NULL);
}


int main()
{
    srand((uint32_t)time(NULL));
    if(!CGL_init()) return -1;
    CGL_window* main_window = CGL_window_create(640, 480, "Hello World");
    if(!main_window) return -1;
    CGL_window_make_context_current(main_window);
    if(!CGL_gl_init()) return -1;
    CGL_framebuffer* default_framebuffer = CGL_framebuffer_create_from_default(main_window);   
    mouse_input.delta_x = 0.0f;
    mouse_input.delta_y = 0.0f;
    mouse_input.prev_x = 0.0f;
    mouse_input.prev_y = 0.0f;
    CGL_window_set_mouse_scroll_callback(main_window, input_scroll_callback);
    CGL_window_set_mouse_position_callback(main_window, input_mouse_pos_callback);
    CGL_window_resecure_callbacks(main_window);

    CGL_thread* thread = CGL_thread_create();


    while(!CGL_window_should_close(main_window))
    { 
        {
            CGL_framebuffer_bind(default_framebuffer);
            CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);
            int rx = 0, ry = 0;
            CGL_framebuffer_get_size(default_framebuffer, &rx, &ry);
            // render here
        }

        CGL_window_poll_events(main_window);

        CGL_window_swap_buffers(main_window);
        if(CGL_window_get_mouse_button(main_window, CGL_MOUSE_BUTTON_LEFT) == CGL_PRESS)
            spawn_the_thread(thread);
        mouse_input.delta_x = mouse_input.delta_y = 0.0f;
        if(CGL_window_get_key(main_window, CGL_KEY_ESCAPE) == CGL_PRESS) break;
    }
    CGL_thread_destroy(thread);

    CGL_framebuffer_destroy(default_framebuffer);
    CGL_gl_shutdown();
    CGL_window_destroy(main_window);
    CGL_shutdown();
    return 0;
}

```

`examples/c/creating_window.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/


#ifdef __EMSCRIPTEN__
#include <emscripten/emscripten.h>
#else
#define EMSCRIPTEN_KEEPALIVE
#endif

#include <stdio.h>

#define CGL_EXCLUDE_AUDIO
#define CGL_EXCLUDE_NETWORKING
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_IMPLEMENTATION
#include "cgl.h"


#ifdef CGL_WASM
#include <emscripten/emscripten.h>
#include <emscripten/html5.h>
#else 
#define EM_BOOL int
#endif

struct {
    CGL_window* window;
    CGL_framebuffer* framebuffer;
} g_State;

void input_mouse_pos_callback(CGL_window* window, double x, double y)
{
    (void)window;    
    CGL_info("Mouse pos: %f, %f", x, y);
}

void input_mouse_button_callback(CGL_window* window, CGL_int button, CGL_int action, CGL_int mods)
{
    (void)window;
    CGL_info("Mouse button: %d, %d, %d", button, action, mods);
}


CGL_bool init() {
    srand((CGL_uint)time(NULL));
    if(!CGL_init()) return CGL_FALSE;

    g_State.window = CGL_window_create(640, 480, "Hello, World!");
    CGL_window_make_context_current(g_State.window);  
    if(!CGL_gl_init()) return CGL_FALSE;

    CGL_window_set_mouse_position_callback(g_State.window, input_mouse_pos_callback);
    CGL_window_set_mouse_button_callback(g_State.window, input_mouse_button_callback);  


    g_State.framebuffer = CGL_framebuffer_create_from_default(g_State.window);
    return true;
}

void cleanup() {
    CGL_framebuffer_destroy(g_State.framebuffer);
    CGL_gl_shutdown();
    CGL_window_destroy(g_State.window);
    CGL_shutdown();
}

EM_BOOL loop(double time, void* userData) {
    (void)time;
    (void)userData;

    CGL_window_poll_events(g_State.window);

    CGL_framebuffer_bind(g_State.framebuffer);
    CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);

    CGL_window_swap_buffers(g_State.window);    
    return true;
}

EMSCRIPTEN_KEEPALIVE
int main() {    
    if(!init()) return 1;

#ifdef CGL_WASM        
    CGL_info("Running in WASM mode");
    emscripten_request_animation_frame_loop(loop, NULL);
#else
    while (!CGL_window_should_close(g_State.window)) {
        loop(0, NULL);
    }
    cleanup();
#endif
    return 0;
}

```

`examples/c/csv_api_example.c`:

```c
/*
MIT License
Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_EXCLUDE_NETWORKING
#define CGL_LOGGING_ENABLED
#define CGL_EXCLUDE_AUDIO
#define CGL_IMPLEMENTATION
#include "cgl.h"


static const CGL_byte* s_test_csv = 
"UID,Full Name,Age,Gender,Played For\n"
"1,John Doe,32,Male,3 hrs\n"
"2,Jane Smith,25,Female,1.8 hrs\n"
"3,Rory Johnson,41,Male,2.5 hrs\n"
"4,Amy Lee,19,Female,3.6 hrs\n"
"5,David Brown,27,Male,6.4 hrs\n";

int main()
{
    CGL_init();
    static CGL_byte buffer[1024 * 1024 * 16];
    CGL_info("Hello world!");

    CGL_csv* doc = CGL_csv_create(64);


    CGL_csv_add_column(doc); 
    CGL_csv_add_column(doc);
    CGL_csv_add_column(doc);
    CGL_csv_add_row(doc);
    CGL_info("Added Columns & Rows");

    CGL_csv_set_item(doc, 0, 0, "Year");
    CGL_csv_set_item(doc, 0, 1, "Jan");
    CGL_csv_set_item(doc, 0, 2, "Feb");
    CGL_info("Updated header values");

    CGL_int data_count = 5;

    for (CGL_int i = 0 ; i < data_count ; i++)
    {
        CGL_csv_add_row(doc);
        sprintf(buffer, "%d", 2000 + i); CGL_csv_set_item(doc, i + 1, 0, buffer);
        sprintf(buffer, "%d", CGL_utils_random_int(0, 100)); CGL_csv_set_item(doc, i + 1, 1, buffer);
        sprintf(buffer, "%d", CGL_utils_random_int(0, 100)); CGL_csv_set_item(doc, i + 1, 2, buffer);
    }
    CGL_info("Added data");
    
    CGL_csv_save_to_buffer(doc, buffer, ",");
    CGL_info("Saved");
    CGL_printf_green(buffer);

    CGL_info("Loading CSV");

    CGL_csv_load_from_buffer(doc, s_test_csv, ",");

    CGL_info("Loaded");

    CGL_info("Meta: (%d Columns, %d Rows)", CGL_csv_get_column_count(doc), CGL_csv_get_row_count(doc));
    CGL_info("Headers : ");
    
    for (CGL_int i = 0 ; i < CGL_csv_get_column_count(doc) ; i++)
    {
        CGL_printf_green("%s ", CGL_csv_get_item(doc, 0, i, NULL));
    }
    CGL_printf_green("\n");
    
    CGL_info("Raw CSV (Reformatted): ");
    CGL_csv_save_to_buffer(doc, buffer, "\t");
    CGL_printf_green("%s\n", buffer);

    CGL_shutdown();
}

/*
Sample Output: 

[INTERNAL] [Sat May  6 20:53:50 202] : Started Logger Session
[INFO] [Sat May  6 20:53:50 202] : Hello world!
[INFO] [Sat May  6 20:53:50 202] : Added Columns & Rows
[INFO] [Sat May  6 20:53:50 202] : Updated header values
[INFO] [Sat May  6 20:53:50 202] : Added data
[INFO] [Sat May  6 20:53:50 202] : Saved
Year,Jan,Feb
2000,41,85
2001,72,38
2002,80,69
2003,65,68
2004,96,22
[INFO] [Sat May  6 20:53:50 202] : Loading CSV
[INFO] [Sat May  6 20:53:50 202] : Loaded
[INFO] [Sat May  6 20:53:50 202] : Meta: (5 Columns, 6 Rows)
[INFO] [Sat May  6 20:53:50 202] : Headers :
UID  Full Name  Age  Gender  Played For
[INFO] [Sat May  6 20:53:50 202] : Raw CSV (Reformatted):
UID     Full Name       Age     Gender  Played For
1       John Doe        32      Male    3 hrs
2       Jane Smith      25      Female  1.8 hrs
3       Rory Johnson    41      Male    2.5 hrs
4       Amy Lee         19      Female  3.6 hrs
5       David Brown     27      Male    6.4 hrs

[INTERNAL] [Sat May  6 20:53:50 202] : Ending Logger Session
[INTERNAL] [Sat May  6 20:53:50 202] : Flushed Log Buffer
*/

```

`examples/c/double_pendulum.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_EXCLUDE_NETWORKING
#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#include "cgl.h"


static const char* PASS_THROUGH_VERTEX_SHADER_SOURCE = "#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 normal;\n"
"layout (location = 2) in vec4 texcoord;\n"
"\n"
"out vec3 Position;\n"
"out vec2 TexCoord;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = vec4(position.xyz, 1.0f);\n"
"	Position = position.xyz;\n"
"	TexCoord = texcoord.xy;\n"
"}";

static const char* PASS_THROUGH_FRAGMENT_SHADER_SOURCE = "#version 430 core\n"
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Position;\n"
"in vec2 TexCoord;\n"
"\n"
"uniform sampler2D u_tex;\n"
"\n"
"// Black Box From https://github.com/armory3d/armory/blob/master/Shaders/std/tonemap.glsl\n"
"vec3 acesFilm(const vec3 x) {\n"
"    const float a = 2.51;\n"
"    const float b = 0.03;\n"
"    const float c = 2.43;\n"
"    const float d = 0.59;\n"
"    const float e = 0.14;\n"
"    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	vec3 color = texture(u_tex, vec2(TexCoord.y, 1.0f - TexCoord.x)).rgb;\n"
"	color = acesFilm(color);\n"
"   color = pow(color, vec3(1.0f / 2.2f));\n"
"	FragColor = vec4(color, 1.0f);\n"
"}";

static const char* COMPUTE_SHADER_SOURCE = "#version 430 core\n"
"\n"
"layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;\n"
"\n"
"layout(rgba32f, binding = 0) uniform image2D output_tex;\n"
"\n"
"uniform int mode;"
"uniform vec2 mass_pos;"
"uniform vec2 fixed_pos;"
"uniform vec4 pre_color;"
"\n"
"void initialize()\n"
"{\n"
"   ivec2 coord = ivec2(gl_GlobalInvocationID.xy);\n"
"   imageStore(output_tex, coord, vec4(0.0f, 0.0f, 0.0f, 1.0f));\n"
"}\n"
"\n"
"void update()\n"
"{\n"
"   ivec2 coord = ivec2(gl_GlobalInvocationID.xy);\n"
"   vec4 color = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n"
"   vec2 nuv = vec2(imageSize(output_tex).x - coord.x, coord.y) / vec2(imageSize(output_tex)) * 2.0f - vec2(1.0f);\n"
"   nuv.x = nuv.x;\n"
"   // set color to pre_color with a radius of 0.01 exponentially decaying\n"
"   color = mix(imageLoad(output_tex, coord), vec4(vec3(0.0f), 1.0f), 0.005f);\n"
"   float factor = exp(-0.5f * length(nuv - mass_pos) / 0.001f);\n"
"   color = mix(color, 16.0f * pre_color, factor);\n"
"   imageStore(output_tex, coord, color);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"   if(mode == 0) initialize();\n"
"   if(mode == 1) update();\n"
"}\n";


static struct
{
    CGL_window* window; // the main window
    int window_height;
    int window_width;
    CGL_framebuffer* framebuffer;
} g_context;

int main()
{
    srand((uint32_t)time(NULL));
    if(!CGL_init()) return EXIT_FAILURE; // initialize CGL (required for setting up internals of CGL)
    g_context.window_width = g_context.window_height = 700;    
    g_context.window = CGL_window_create(g_context.window_width, g_context.window_height, "Double Pendulum - Jaysmito Mukherjee"); // create the window
    CGL_window_make_context_current(g_context.window); // make the opengl context for the window current
    if(!CGL_gl_init()) return EXIT_FAILURE; // initialize cgl opengl module    
    g_context.framebuffer = CGL_framebuffer_create_from_default(g_context.window); // load the default framebuffer (0) into CGL_framebuffer object
    CGL_widgets_init();
    CGL_noise_init();
    CGL_bool is_physics_on = true;
    CGL_vec2 fixed_pos = CGL_vec2_init(0.0f, 0.5f), mass_vel = CGL_vec2_init(0.0f, 0.0f), mass_acc = CGL_vec2_init(0.0f, 0.0f);
    CGL_vec2 mass_angle = CGL_vec2_init(0.0f, 0.0f), mass_length = CGL_vec2_init(0.5f, 0.5f), mass = CGL_vec2_init(1.0f, 1.0f), mass_pos = CGL_vec2_init(0.0f, 0.0f);
    CGL_float mass_val = 1.0f, acc_due_to_gravity = 5.0f, spring_constant = 1.0f, damping_constant = 0.1f, time_step = 0.005f, curr_time;
    CGL_texture* out_tex = CGL_texture_create_blank(700, 700, GL_RGBA, GL_RGBA32F, GL_FLOAT);
    CGL_shader* present_shader = CGL_shader_create(PASS_THROUGH_VERTEX_SHADER_SOURCE, PASS_THROUGH_FRAGMENT_SHADER_SOURCE, NULL);
    CGL_shader* draw_shader = CGL_shader_compute_create(COMPUTE_SHADER_SOURCE, NULL);
    CGL_vec3 color = CGL_vec3_init(0.0f, 1.0f, 1.0f);
    glBindImageTexture(0, out_tex->handle, 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
    CGL_shader_bind(draw_shader); CGL_shader_set_uniform_int(draw_shader, CGL_shader_get_uniform_location(draw_shader, "mode"), 0);
    CGL_shader_compute_dispatch(draw_shader, 700 / 16 + 1, 700 / 16 + 1, 1);
    while(!CGL_window_should_close(g_context.window)) // run till the close button is clicked
    {
        curr_time = CGL_utils_get_time();
        CGL_window_set_size(g_context.window, g_context.window_width, g_context.window_height); // set window size
        CGL_framebuffer_bind(g_context.framebuffer); // bind default framebuffer and also adjust viewport size and offset
        CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f); // clear screen with a dark gray color
        if(is_physics_on)
        {
            CGL_double mx = 0.0, my = 0.0; CGL_float weight = mass_val * acc_due_to_gravity * -1.0f;
            // Formula from : https://www.myphysicslab.com/pendulum/double-pendulum-en.html
            mass_acc.x = (-acc_due_to_gravity * (2.0f * mass.x + mass.y) * sinf(mass_angle.x) - mass.y * acc_due_to_gravity * sinf(mass_angle.x - 2.0f * mass_angle.y) - 2.0f * sinf(mass_angle.x - mass_angle.y) * mass.y * (mass_vel.y * mass_vel.y * mass_length.y + mass_vel.x * mass_vel.x * mass_length.x * cosf(mass_angle.x - mass_angle.y))) / (mass_length.x * (2.0f * mass.x + mass.y - mass.y * cosf(2.0f * mass_angle.x - 2.0f * mass_angle.y)));
            mass_acc.y = (2.0f * sinf(mass_angle.x - mass_angle.y) * (mass_vel.x * mass_vel.x * mass_length.x * (mass.x + mass.y) + acc_due_to_gravity * (mass.x + mass.y) * cosf(mass_angle.x) + mass_vel.y * mass_vel.y * mass_length.y * mass.y * cosf(mass_angle.x - mass_angle.y))) / (mass_length.y * (2.0f * mass.x + mass.y - mass.y * cosf(2.0f * mass_angle.x - 2.0f * mass_angle.y)));
            mass_vel.x += mass_acc.x * time_step; mass_vel.y += mass_acc.y * time_step;
            mass_angle.x += mass_vel.x * time_step; mass_angle.y += mass_vel.y * time_step;
            color.x = CGL_noise_opensimplex2s(mass_pos.x, mass_pos.y, 0.0f + curr_time) * 0.5f + 0.5f;
            color.y = CGL_noise_opensimplex2s(mass_pos.x, mass_pos.y, 1.0f + curr_time) * 0.5f + 0.5f;
            color.z = CGL_noise_opensimplex2s(mass_pos.x, mass_pos.y, 2.0f + curr_time) * 0.5f + 0.5f;
        }
        glBindImageTexture(0, out_tex->handle, 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
        CGL_shader_bind(draw_shader);
        CGL_shader_set_uniform_int(draw_shader, CGL_shader_get_uniform_location(draw_shader, "mode"), 1);
        CGL_shader_set_uniform_vec2v(draw_shader, CGL_shader_get_uniform_location(draw_shader, "fixed_pos"), fixed_pos.x, fixed_pos.y);
        CGL_shader_set_uniform_vec2v(draw_shader, CGL_shader_get_uniform_location(draw_shader, "mass_pos"), mass_pos.x, mass_pos.y);
        CGL_shader_set_uniform_vec4v(draw_shader, CGL_shader_get_uniform_location(draw_shader, "pre_color"), color.x, color.y, color.z, 1.0f);
        CGL_shader_compute_dispatch(draw_shader, 700 / 16 + 1, 700 / 16 + 1, 1);
        CGL_shader_bind(present_shader);
        CGL_texture_bind(out_tex, 5);
        CGL_shader_set_uniform_int(present_shader, CGL_shader_get_uniform_location(present_shader, "u_tex"), 5);
        CGL_gl_render_screen_quad();
        CGL_widgets_begin();
        CGL_widgets_set_stroke_thicnkess(0.01f); CGL_widgets_set_stroke_colorf(0.8f, 1.0f, 0.8f, 1.0f); CGL_widgets_set_fill_colorf(0.8f, 0.8f, 0.8f, 1.0f);
        CGL_vec2 m_pos0 = CGL_vec2_scale_(CGL_vec2_normalize_(CGL_vec2_rotate_about_point(CGL_vec2_init(0.0f, -1.0f), CGL_vec2_init(0.0f, 0.0f), mass_angle.x)), mass_length.x); m_pos0 = CGL_vec2_add_(m_pos0, fixed_pos);
        CGL_widgets_add_line2f(fixed_pos.x, fixed_pos.y, m_pos0.x, m_pos0.y); CGL_widgets_add_circle2f(m_pos0.x, m_pos0.y, 0.05f);
        CGL_vec2 m_pos1 = CGL_vec2_scale_(CGL_vec2_normalize_(CGL_vec2_rotate_about_point(CGL_vec2_init(0.0f, -1.0f), CGL_vec2_init(0.0f, 0.0f), mass_angle.y)), mass_length.y); m_pos1 = CGL_vec2_add_(m_pos1, m_pos0);
        CGL_widgets_add_line2f(m_pos0.x, m_pos0.y, m_pos1.x, m_pos1.y); CGL_widgets_add_circle2f(m_pos1.x, m_pos1.y, 0.05f);
        mass_pos = m_pos1;
        CGL_widgets_end();
        CGL_window_swap_buffers(g_context.window); // swap framebuffers
        CGL_window_poll_events(g_context.window); // poll events (if this is not called every frame window will stop responding)
        if(CGL_window_get_key(g_context.window, CGL_KEY_ESCAPE) == CGL_PRESS) break; // quit on pressing escape
        if(CGL_window_get_key(g_context.window, CGL_KEY_SPACE) == CGL_PRESS) is_physics_on = true;
        if(CGL_window_get_key(g_context.window, CGL_KEY_ENTER) == CGL_PRESS) is_physics_on = false;
        if(CGL_window_get_key(g_context.window, CGL_KEY_R) == CGL_PRESS) 
        {
            mass_angle.x = CGL_PI_2; mass_angle.y = CGL_PI_2; mass_vel.x = mass_vel.y = 0.0f;
            glBindImageTexture(0, out_tex->handle, 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
            CGL_shader_bind(draw_shader); CGL_shader_set_uniform_int(draw_shader, CGL_shader_get_uniform_location(draw_shader, "mode"), 0);
            CGL_shader_compute_dispatch(draw_shader, 700 / 16 + 1, 700 / 16 + 1, 1);
        }
    }
    // cleanup
    CGL_noise_shutdown();
    CGL_widgets_shutdown();
    CGL_shader_destroy(present_shader);
    CGL_shader_destroy(draw_shader);
    CGL_texture_destroy(out_tex);
    CGL_framebuffer_destroy(g_context.framebuffer); // destory framebuffer object
    CGL_gl_shutdown(); // shutdown cgl opengl module
    CGL_window_destroy(g_context.window); // destroy window
    CGL_shutdown(); // shutdown cgl and clean up resources allocated by CGL internally (if any)
    return EXIT_SUCCESS;
}

```

`examples/c/embedding_nuklear_gui.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#include "cgl.h"


#pragma warning(push, 0)
#define NK_INCLUDE_FIXED_TYPES
#define NK_INCLUDE_STANDARD_IO
#define NK_INCLUDE_STANDARD_VARARGS
#define NK_INCLUDE_DEFAULT_ALLOCATOR
#define NK_INCLUDE_VERTEX_BUFFER_OUTPUT
#define NK_INCLUDE_FONT_BAKING
#define NK_INCLUDE_DEFAULT_FONT
#define NK_IMPLEMENTATION
#define NK_GLFW_GL3_IMPLEMENTATION
#define NK_KEYSTATE_BASED_INPUT
#include "nuklear.h"
#include "nuklear_glfw_gl4.h"
#pragma warning(pop)


static struct {
    float delta_x;
    float delta_y;
    float prev_x;
    float prev_y;
} mouse_input;


static struct {
    struct nk_context* ctx;
    struct nk_colorf bg;
    struct nk_glfw glfw;
} nuklear_data;


void input_scroll_callback(CGL_window* window, double x, double y)
{
}

void input_mouse_pos_callback(CGL_window* window, double x, double y)
{
    mouse_input.delta_x = ((float)x - mouse_input.prev_x);
    mouse_input.delta_y = ((float)y - mouse_input.prev_y);
    mouse_input.prev_x = (float)x;
    mouse_input.prev_y = (float)y;
}


int main()
{
    srand((uint32_t)time(NULL));
    if(!CGL_init()) return -1;
    CGL_window* main_window = CGL_window_create(640, 480, "Hello World");
    if(!main_window) return -1;
    CGL_window_make_context_current(main_window);
    if(!CGL_gl_init()) return -1;
    CGL_framebuffer* default_framebuffer = CGL_framebuffer_create_from_default(main_window);   
    mouse_input.delta_x = 0.0f;
    mouse_input.delta_y = 0.0f;
    mouse_input.prev_x = 0.0f;
    mouse_input.prev_y = 0.0f;
    CGL_window_set_mouse_scroll_callback(main_window, input_scroll_callback);
    CGL_window_set_mouse_position_callback(main_window, input_mouse_pos_callback);
    CGL_window_resecure_callbacks(main_window);

    // setup nuklear
    nuklear_data.ctx = nk_glfw3_init(&nuklear_data.glfw, CGL_window_get_glfw_handle(main_window), NK_GLFW3_INSTALL_CALLBACKS);

    {
        struct nk_font_atlas* atlas;
        nk_glfw3_font_stash_begin(&nuklear_data.glfw, &atlas);
        nk_glfw3_font_stash_end(&nuklear_data.glfw);
    }

    while(!CGL_window_should_close(main_window))
    { 
        {
            CGL_framebuffer_bind(default_framebuffer);
            CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);
            int rx = 0, ry = 0;
            CGL_framebuffer_get_size(default_framebuffer, &rx, &ry);
            // render here
        }

        CGL_window_poll_events(main_window);

        nk_glfw3_new_frame(&nuklear_data.glfw);

         if (nk_begin(nuklear_data.ctx, "Demo", nk_rect(50, 50, 230, 250),
            NK_WINDOW_BORDER|NK_WINDOW_MOVABLE|NK_WINDOW_SCALABLE|
            NK_WINDOW_MINIMIZABLE|NK_WINDOW_TITLE))
        {
            nk_layout_row_static(nuklear_data.ctx, 30, 80, 1);
            if (nk_button_label(nuklear_data.ctx, "button"))
            {
                CGL_LOG("Hello World!\n");
            }


        }
        nk_end(nuklear_data.ctx);
        nk_glfw3_render(&nuklear_data.glfw, NK_ANTI_ALIASING_ON, 1024 * 512, 1024 * 128);


        CGL_window_swap_buffers(main_window);
        if(CGL_window_get_mouse_button(main_window, CGL_MOUSE_BUTTON_MIDDLE) == CGL_PRESS)
        {            
        }
        else if(CGL_window_get_mouse_button(main_window, CGL_MOUSE_BUTTON_RIGHT) == CGL_PRESS)
        {

        }
        mouse_input.delta_x = mouse_input.delta_y = 0.0f;
        if(CGL_window_get_key(main_window, CGL_KEY_ESCAPE) == CGL_PRESS) break;
    }

    nk_glfw3_shutdown(&nuklear_data.glfw);
    CGL_framebuffer_destroy(default_framebuffer);
    CGL_gl_shutdown();
    CGL_window_destroy(main_window);
    CGL_shutdown();
    return 0;
}

```

`examples/c/example_cmakelists.txt`:

```txt
cmake_minimum_required(VERSION 3.12)

set_property(GLOBAL PROPERTY USE_FOLDERS ON)

project(sand-box LANGUAGES C)

set(CMAKE_C_STANDARD 17)
set(CMAKE_C_STANDARD_REUIRED True)

find_package( OpenGL REQUIRED )

include_directories( 
	./lib/glfw/include
	./lib/glad/include
	./include
 )

set( GLFW_BUILD_DOCS OFF CACHE BOOL  "GLFW lib only" )
set( GLFW_INSTALL OFF CACHE BOOL  "GLFW lib only" )

add_subdirectory(lib/glfw)
add_subdirectory(lib/glad)

if( MSVC )
    SET( CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} /ENTRY:mainCRTStartup" )
endif()


file(GLOB SOURCES
     "./include/*.h"
     "./source/*.c"
)


add_executable(sandbox ${SOURCES})


target_link_libraries(sandbox
	glfw
	${GLFW_LIBRARIES}
	opengl32
	glad
	)

if(MSVC)
    add_definitions(-D_CRT_SECURE_NO_WARNINGS)
endif()

if( MSVC )
    if(${CMAKE_VERSION} VERSION_LESS "3.6.0") 
        message( "\n\t[ WARNING ]\n\n\tCMake version lower than 3.6.\n\n\t - Please update CMake and rerun; OR\n\t - Manually set 'GLFW-CMake-starter' as StartUp Project in Visual Studio.\n" )
    else()
        set_property( DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT sandbox)
    endif()
endif()
```

`examples/c/example_cmakelists_wasm.txt`:

```txt
cmake_minimum_required(VERSION 3.0)

set_property(GLOBAL PROPERTY USE_FOLDERS ON) # Use folders for IDE

project(cglweb)

set(CMAKE_C_STANDARD 99)
set(CMAKE_C_STANDARD_REUIRED True)

include_directories(
    ./include
    ./lib/glad/include
    ./lib/glfw/include
)

set( GLFW_BUILD_DOCS OFF CACHE BOOL  "GLFW lib only" )
set( GLFW_INSTALL OFF CACHE BOOL  "GLFW lib only" )

add_subdirectory(lib/glad)

if (NOT DEFINED EMSCRIPTEN)
    add_subdirectory(lib/glfw)
endif()

if (MSVC)
    SET( CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} /ENTRY:mainCRTStartup" )
endif()

if(MSVC)
    add_definitions(-D_CRT_SECURE_NO_WARNINGS)
endif()

if( MSVC )
    if(${CMAKE_VERSION} VERSION_LESS "3.6.0") 
        message( "\n\t[ WARNING ]\n\n\tCMake version lower than 3.6.\n\n\t - Please update CMake and rerun; OR\n\t - Manually set 'GLFW-CMake-starter' as StartUp Project in Visual Studio.\n" )
    else()
        set_property( DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT sandbox)
    endif()
endif()

file(GLOB SOURCES
    "./include/*.hpp" # Mainly for IDEs to include the header files
    "./src/main.c"
)

add_executable(cglweb ${SOURCES})



if (DEFINED EMSCRIPTEN) 
    set(CMAKE_EXECUTABLE_SUFFIX ".js")
    set_target_properties(cglweb PROPERTIES COMPILE_FLAGS "-O2 -g2")
    set_target_properties(cglweb PROPERTIES LINK_FLAGS "-O2 -g2 -s USE_GLFW=3 -s FULL_ES3  -sALLOW_MEMORY_GROWTH=1 -sEXPORTED_RUNTIME_METHODS=ccall,cwrap -sEXPORTED_FUNCTIONS=_main")
endif()

target_link_libraries(cglweb
    glfw
    ${GLFW_LIBRARIES}
    glad
)

if (MSVC) 
    target_compile_options(cglweb PRIVATE /W4 /WX)
else()
    target_compile_options(cglweb PRIVATE -Wall -Wextra -pedantic -Werror -Woverlength-strings)
endif()


```

`examples/c/fireworks.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/


#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#define CGL_EXCLUDE_NETWORKING
#define CGL_EXCLUDE_RAY_CASTER
#define CGL_EXCLUDE_NODE_EDITOR
#define CGL_EXCLUDE_AUDIO
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_EXCLUDE_WIDGETS
#include "cgl.h"

#ifdef CGL_WASM
#include <emscripten/emscripten.h>
#include <emscripten/html5.h>
#else 
#define EM_BOOL int
#endif

// Update shaders for WebGL compatibility
static const char* PASS_THROUGH_VERTEX_SHADER_SOURCE =
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
"\n"
"in vec4 position;\n"
"in vec4 normal;\n"
"in vec4 texcoord;\n"
#else
"#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 normal;\n"
"layout (location = 2) in vec4 texcoord;\n"
#endif
"\n"
"out vec3 Position;\n"
"out vec2 TexCoord;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = vec4(position.xyz, 1.0f);\n"
"	Position = position.xyz;\n"
"	TexCoord = texcoord.xy;\n"
"}";

static const char* PASS_THROUGH_FRAGMENT_SHADER_SOURCE = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
#else
"#version 430 core\n"
#endif
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Position;\n"
"in vec2 TexCoord;\n"
"\n"
"uniform sampler2D u_tex;\n"
"\n"
"// Black Box From https://github.com/armory3d/armory/blob/master/Shaders/std/tonemap.glsl\n"
"vec3 acesFilm(const vec3 x) {\n"
"    const float a = 2.51;\n"
"    const float b = 0.03;\n"
"    const float c = 2.43;\n"
"    const float d = 0.59;\n"
"    const float e = 0.14;\n"
"    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	vec3 color = texture(u_tex, vec2(TexCoord.y, 1.0f - TexCoord.x)).rgb;\n"
"	color = acesFilm(color);\n"
"   color = pow(color, vec3(1.0f / 2.2f));\n"
"	FragColor = vec4(color, 1.0f);\n"
"}";


static const char* TRAIL_VERTEX_SHADER =
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
"\n"
"in vec4 position;\n" // w is lifespan
"in vec4 normal;\n" // w is distance
"in vec4 texcoord;\n" // zw is reserved for future use
#else
"#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n" // w is lifespan
"layout (location = 1) in vec4 normal;\n" // w is distance
"layout (location = 2) in vec4 texcoord;\n" // zw is reserved for future use
#endif
"\n"
"out vec3 Position;\n"
"out vec2 TexCoord;\n"
"out float Distance;\n"
"out float Life;\n"
"\n"
"uniform mat4 projection;\n"
"uniform mat4 view;\n"
"uniform mat4 model;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = projection * view * model * vec4(position.xyz, 1.0f);\n"
"	Position = position.xyz;\n"
"	TexCoord = texcoord.xy;\n"
"   Distance = normal.w;\n"
"   Life = position.w;\n"
"}\n";

static const char* TRAIL_FRAGMENT_SHADER =
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
#else
"#version 430 core\n"
#endif
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Position;\n"
"in vec2 TexCoord;\n"
"in float Distance;\n"
"in float Life;\n"
"\n"
"uniform vec3 color;\n"
"uniform float total_length;\n"
"uniform float total_life;\n"
"uniform float LifeFactor;\n"
"\n"
"void main()\n"
"{\n"
"   float factor = (total_life - (Life+LifeFactor)) / total_life;\n"
"   factor = pow(factor, 4.0f);\n"
"	FragColor = vec4(mix(color, vec3(0.0f), factor), 1.0f);\n"
"}\n";

typedef struct
{
    CGL_trail* particle_trails[64];
    CGL_vec3 particle_positions[64];
    CGL_vec3 particle_velocities[64];
    CGL_vec3 particle_colors[64];
    CGL_float particle_timers[64];
    CGL_trail* trail[5];
    CGL_vec3 velocity;
    CGL_vec3 color;
    CGL_vec3 position;
    CGL_int particle_trails_count;
    CGL_float timer;
    CGL_float wtimer;
    CGL_int busted_smallones;
} Firework;

#define SMALL_FIRE_WORKS_COUNT 32

Firework smaller_fireworks[SMALL_FIRE_WORKS_COUNT];

static bool point_function(CGL_trail* trail, CGL_trail_point* point)
{
    point->thickness = 0.1f * (trail->length - point->distance) / trail->length;
    return false;
}

void allocate_small_firework(Firework* firework)
{
    for(CGL_int i = 0 ; i < 5 ; i ++) firework->trail[i] = CGL_trail_create();
    firework->particle_trails_count = CGL_utils_random_int(16, 32);
    for(CGL_int i = 0 ; i < firework->particle_trails_count ; i ++) firework->particle_trails[i] = CGL_trail_create();  
}

void setup_small_firework(Firework* firework, CGL_float xd)
{
    firework->wtimer = CGL_utils_random_float() * 20.0f;
    firework->position = CGL_vec3_init(xd, 0.0f, CGL_utils_random_float() * 10.0f - 5.0f);
    firework->velocity = CGL_vec3_init(CGL_utils_random_float() * 4.0f - 2.0f, CGL_utils_random_float() * 5.0f + 20.0f, CGL_utils_random_float() * 4.0f - 2.0f);
    firework->timer = firework->velocity.y / 9.81f;
    firework->color = CGL_vec3_init(CGL_utils_random_float(), CGL_utils_random_float(), CGL_utils_random_float());
    firework->busted_smallones = 0;
    for(CGL_int i = 0 ; i < 5 ; i ++)
    {
        CGL_trail_set_min_points_distance(firework->trail[i], 0.07f);
        CGL_trail_set_resolution(firework->trail[i], 3);
        CGL_trail_set_point_update_function(firework->trail[i], point_function);
    }
    for(CGL_int i = 0 ; i < firework->particle_trails_count ; i ++)
    {
        CGL_trail_clear(firework->particle_trails[i]);
        CGL_trail_set_min_points_distance(firework->particle_trails[i], 0.07f);
        CGL_trail_set_resolution(firework->particle_trails[i], 3);
        CGL_trail_set_point_update_function(firework->particle_trails[i], point_function);
        firework->particle_positions[i] = CGL_vec3_init(xd, 0.0f, 5.0f + CGL_utils_random_float() * 2.0f - 1.0f);
        CGL_float smx = 5.0f;
        CGL_float smn = -5.0f;
        firework->particle_velocities[i] = CGL_vec3_init(CGL_utils_random_float() * (smx - smn) + smn, CGL_utils_random_float() * (smx - smn) + smn, CGL_utils_random_float() * (smx - smn) + smn);
        firework->particle_timers[i] = CGL_utils_random_float() * 1.0f + 1.0f;
        firework->particle_colors[i] = CGL_vec3_add_(firework->color, CGL_vec3_init(CGL_utils_random_float() * 0.2f - 0.1f, CGL_utils_random_float() * 0.2f - 0.1f, CGL_utils_random_float() * 0.2f - 0.1f));
    }
}

void destroy_small_firework(Firework* firework);
void update_small_firework(Firework* firework, CGL_float delta_time)
{
    firework->wtimer -= delta_time;
    if(firework->wtimer >= 0.0f) return;
    if(firework->busted_smallones >= firework->particle_trails_count) setup_small_firework(firework, CGL_utils_random_float() * 32.0f - 16.0f);
    firework->timer -= delta_time;
    if(fabsf(firework->timer) < 0.05f) for(CGL_int i = 0 ; i < firework->particle_trails_count ; i ++) firework->particle_positions[i] = firework->position;
    static CGL_float tot_time = 0.0f;
    tot_time += delta_time;
    if(firework->timer >= 0.0f)
    {
        firework->position = CGL_vec3_add_(firework->position, CGL_vec3_scale_(firework->velocity, delta_time));
        firework->velocity = CGL_vec3_add_(firework->velocity, CGL_vec3_scale_(CGL_vec3_init(0.0f, -9.8f, 0.0f), delta_time));
        firework->velocity.y = CGL_utils_clamp(firework->velocity.y, 0.0f, 100.0f);
        for(CGL_int i = 0 ; i < 5 ; i ++)
        {
            CGL_float angle = (CGL_float)i * 2.0f * CGL_PI / 5.0f + tot_time * 10.0f;
            CGL_vec3 direction = CGL_vec3_init(cosf(angle), 0.0f, sinf(angle));
            CGL_vec3 position = CGL_vec3_add_(firework->position, CGL_vec3_scale_(direction, 0.08f));
            CGL_trail_add_point(firework->trail[i], position, 0.15f, 0.07f);
            CGL_trail_update(firework->trail[i], delta_time);
            CGL_trail_bake_mesh(firework->trail[i]);
        }
    }
    else
    {
        for(CGL_int i = 0 ; i < firework->particle_trails_count ; i ++)
        {
            firework->particle_timers[i] -= delta_time;
            if(fabsf(firework->particle_timers[i]) < 0.03f) firework->busted_smallones ++;
            if(firework->particle_timers[i] <= 0.0f) continue;
            firework->particle_positions[i] = CGL_vec3_add_(firework->particle_positions[i], CGL_vec3_scale_(firework->particle_velocities[i], delta_time));
            firework->particle_velocities[i] = CGL_vec3_add_(firework->particle_velocities[i], CGL_vec3_scale_(CGL_vec3_init(0.0f, -4.8f, 0.0f), delta_time));
            CGL_trail_add_point(firework->particle_trails[i], firework->particle_positions[i], 0.7f, 0.01f);
            CGL_trail_update(firework->particle_trails[i], delta_time);
            CGL_trail_bake_mesh(firework->particle_trails[i]);
        }
    }
}

void render_small_firework(Firework* firework, CGL_shader* shader, CGL_mat4* view, CGL_mat4* projection)
{
    if(firework->wtimer >= 0.0f) return;
    CGL_vec3 orange_red_shades[5] = {
        CGL_vec3_init(1.5f, 0.5f+ 0.3f, 0.0f),
        CGL_vec3_init(1.5f, 0.4f+ 0.3f, 0.0f),
        CGL_vec3_init(1.5f, 0.3f+ 0.3f, 0.0f),
        CGL_vec3_init(1.5f, 0.2f+ 0.3f, 0.0f),
        CGL_vec3_init(1.5f, 0.1f+ 0.3f, 0.0f)
    };
    CGL_mat4 model = CGL_mat4_identity();
    CGL_shader_set_uniform_float(shader, CGL_shader_get_uniform_location(shader, "LifeFactor"), 0.0f);
    CGL_shader_set_uniform_mat4(shader, CGL_shader_get_uniform_location(shader, "model"), &model);

    if(firework->timer >= 0)
    {
        for(CGL_int i = 0 ; i < 5 ; i ++)
        {
            CGL_shader_set_uniform_vec3v(shader, CGL_shader_get_uniform_location(shader, "color"), orange_red_shades[i].x, orange_red_shades[i].y, orange_red_shades[i].z);
            CGL_shader_set_uniform_float(shader, CGL_shader_get_uniform_location(shader, "total_life"), 0.15f);
            CGL_trail_render(firework->trail[i], view, projection, shader);
        }
    }
    else
    {
        for(CGL_int i = 0 ; i < firework->particle_trails_count ; i ++)
        {
            if(firework->particle_timers[i] <= 0.0f) continue;
            CGL_shader_set_uniform_vec3v(shader, CGL_shader_get_uniform_location(shader, "color"), firework->particle_colors[i].x, firework->particle_colors[i].y, firework->particle_colors[i].z);
            CGL_shader_set_uniform_float(shader, CGL_shader_get_uniform_location(shader, "total_life"), 0.7f);
            CGL_trail_render(firework->particle_trails[i], view, projection, shader);
        }
    }
}

void destroy_small_firework(Firework* firework)
{
    for(CGL_int i = 0 ; i < 5 ; i ++) CGL_trail_destroy(firework->trail[i]);
    for(CGL_int i = 0 ; i < firework->particle_trails_count ; i ++) CGL_trail_destroy(firework->particle_trails[i]);
}

// Global state structure
struct {
    CGL_window* window;
    CGL_framebuffer* default_framebuffer;
    CGL_framebuffer* bloom_framebuffer;
    CGL_shader* present_shader;
    CGL_shader* trail_shader;
    CGL_mat4 view;
    CGL_mat4 projection;
    CGL_float curr_time;
    CGL_float prev_time;
    CGL_float time;
    CGL_bool started;
    Firework smaller_fireworks[SMALL_FIRE_WORKS_COUNT];

#ifndef CGL_WASM
    CGL_bloom* bloom;
#endif
} g_state;

CGL_bool init()
{
    srand((uint32_t)time(NULL));
    if(!CGL_init()) return false;
    
    g_state.window = CGL_window_create(600, 600, "Fireworks - Jaysmito Mukherjee");
    if(!g_state.window) return false;
    
    CGL_window_make_context_current(g_state.window);
    if(!CGL_gl_init()) return false;

    g_state.default_framebuffer = CGL_framebuffer_create_from_default(g_state.window);
    g_state.bloom_framebuffer = CGL_framebuffer_create_basic(600, 600);
    g_state.present_shader = CGL_shader_create(PASS_THROUGH_VERTEX_SHADER_SOURCE, PASS_THROUGH_FRAGMENT_SHADER_SOURCE, NULL);
    g_state.trail_shader = CGL_shader_create(TRAIL_VERTEX_SHADER, TRAIL_FRAGMENT_SHADER, NULL);

#ifndef CGL_WASM
    g_state.bloom = CGL_bloom_create(600, 600, 3);
#endif

    g_state.curr_time = CGL_utils_get_time();
    g_state.prev_time = CGL_utils_get_time();
    g_state.time = 0.0f;
    g_state.started = false;

    for(CGL_int i = 0; i < SMALL_FIRE_WORKS_COUNT; i++) allocate_small_firework(&g_state.smaller_fireworks[i]);
    for(CGL_int i = 0; i < SMALL_FIRE_WORKS_COUNT; i++) setup_small_firework(&g_state.smaller_fireworks[i], 32 * (float)i / SMALL_FIRE_WORKS_COUNT - 32*0.5f);

    g_state.projection = CGL_mat4_perspective(CGL_deg_to_rad(45.0f), 1.0f, 0.01f, 100.0f);
    g_state.view = CGL_mat4_identity();

    return true;
}

void cleanup()
{
    for(int i = 0; i < SMALL_FIRE_WORKS_COUNT; i++) destroy_small_firework(&g_state.smaller_fireworks[i]);
    CGL_shader_destroy(g_state.trail_shader);
    CGL_shader_destroy(g_state.present_shader);
    CGL_framebuffer_destroy(g_state.default_framebuffer);
    CGL_framebuffer_destroy(g_state.bloom_framebuffer);
#ifndef CGL_WASM    
    CGL_bloom_destroy(g_state.bloom);
#endif
    CGL_gl_shutdown();
    CGL_window_destroy(g_state.window);    
    CGL_shutdown();
}

EM_BOOL loop(double time, void* userData)
{
    (void)time;
    (void)userData;

    g_state.curr_time = CGL_utils_get_time();
    CGL_float delta_time = g_state.curr_time - g_state.prev_time;
    delta_time = CGL_utils_clamp(delta_time, 0.0f, 0.03f);
    g_state.prev_time = g_state.curr_time;
    g_state.time += delta_time;

    CGL_window_set_size(g_state.window, 600, 600);
    g_state.view = CGL_mat4_look_at(
        CGL_vec3_init(60.0f * cosf(g_state.time*0.3f), 15.0f, 60.0f * sinf(g_state.time*0.3f)), 
        CGL_vec3_init(0.0f, 16.0f, 0.0f), 
        CGL_vec3_init(0.0f, 1.0f, 0.0f)
    );

    if(g_state.started) {
        for(CGL_int i = 0; i < SMALL_FIRE_WORKS_COUNT; i++) 
            update_small_firework(&g_state.smaller_fireworks[i], delta_time);
    }

    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LESS);

    // Render to bloom framebuffer
    CGL_framebuffer_bind(g_state.bloom_framebuffer);
    CGL_gl_clear(0.0f, 0.0f, 0.0f, 1.0f);
    CGL_shader_bind(g_state.trail_shader);
    for(CGL_int i = 0; i < SMALL_FIRE_WORKS_COUNT; i++) 
        render_small_firework(&g_state.smaller_fireworks[i], g_state.trail_shader, &g_state.view, &g_state.projection);
#ifndef CGL_WASM
    // Apply bloom and render to screen
    CGL_bloom_apply(g_state.bloom, CGL_framebuffer_get_color_texture(g_state.bloom_framebuffer));
#endif
    
    CGL_framebuffer_bind(g_state.default_framebuffer);
    CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);
    CGL_shader_bind(g_state.present_shader);
    CGL_texture_bind(CGL_framebuffer_get_color_texture(g_state.bloom_framebuffer), 0);
    CGL_shader_set_uniform_int(g_state.present_shader, CGL_shader_get_uniform_location(g_state.present_shader, "u_tex"), 0);
    CGL_gl_render_screen_quad();

    CGL_window_poll_events(g_state.window);
    CGL_window_swap_buffers(g_state.window);

    if(!g_state.started && CGL_window_get_key(g_state.window, CGL_KEY_SPACE) == CGL_PRESS) 
        g_state.started = true;

    return !CGL_window_should_close(g_state.window);
}

int main()
{
    if(!init()) return 1;

#ifdef CGL_WASM
    CGL_info("Running in WASM mode");
    emscripten_request_animation_frame_loop(loop, NULL);
#else
    while (!CGL_window_should_close(g_state.window)) {
        loop(0, NULL);
    }
    cleanup();
#endif

    return 0;
}

```

`examples/c/flappy_bird.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



#define CGL_EXCLUDE_AUDIO
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_EXCLUDE_NETWORKING
#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#include "cgl.h"

#ifdef CGL_WASM
#include <emscripten/emscripten.h>
#include <emscripten/html5.h>
#else 
#define EM_BOOL int
#endif

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

// Update shader versions for WASM compatibility
static const char* PASS_THROUGH_VERTEX_SHADER_SOURCE = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
"in vec4 position;\n"
"in vec4 normal;\n"
"in vec4 texcoord;\n"
#else
"#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 normal;\n"
"layout (location = 2) in vec4 texcoord;\n"
#endif
"\n"
"out vec3 Position;\n"
"out vec2 TexCoord;\n"
"\n"
"uniform vec4 po;\n"
"\n"
"void main()\n"
"{\n"
"   vec2 pos = position.xy;\n"
"   pos = pos * po.zw * 0.5f;\n"
"   vec2 off = po.xy + po.zw * 0.5f;\n"
"   pos = pos + off;\n"
"	gl_Position = vec4(pos, 0.0f, 1.0f);\n"
"	Position = position.xyz;\n"
"	TexCoord = texcoord.xy;\n"
"}";

static const char* PASS_THROUGH_FRAGMENT_SHADER_SOURCE = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
#else
"#version 430 core\n"
#endif
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Position;\n"
"in vec2 TexCoord;\n"
"\n"
"uniform sampler2D u_tex;\n"
"uniform vec4 potx;"
"\n"
"void main()\n"
"{\n"
"   vec2 tx = vec2(1.0f - TexCoord.y, 1.0f - TexCoord.x);\n"
"   tx = tx * potx.zw;\n"
"   tx = tx + potx.xy;\n"
"	FragColor = texture(u_tex, tx);\n"
"}";

#define DRAW_QUAD(tex, ind, stx, sty, szx, szy) { \
    CGL_texture_bind(tex, ind); \
    CGL_shader_set_uniform_int(g_State.present_shader, CGL_shader_get_uniform_location(g_State.present_shader, "u_tex"), (CGL_int)ind); \
    CGL_shader_set_uniform_vec4v(g_State.present_shader, CGL_shader_get_uniform_location(g_State.present_shader, "po"), (CGL_float)(stx), (CGL_float)(sty), (CGL_float)(szx), (CGL_float)(szy)); \
    CGL_gl_render_screen_quad(); \
} 

#define PO_TX(stx, sty, szx, szy) CGL_shader_set_uniform_vec4v(g_State.present_shader, CGL_shader_get_uniform_location(g_State.present_shader, "potx"), (CGL_float)(stx), (CGL_float)(sty), (CGL_float)(szx), (CGL_float)(szy));


// Game state structure
struct {
    CGL_window* window;
    CGL_framebuffer* framebuffer;
    CGL_shader* present_shader;
    CGL_texture* bird_tex[3];
    CGL_texture* background_tex;
    CGL_texture* platform_tex;
    CGL_texture* pipe_tex;
    CGL_texture* game_over_tex;
    CGL_texture* messages;
    CGL_vec3 pipes[10];
    CGL_int window_height;
    CGL_int window_width;
    CGL_float player_pos;
    CGL_float player_velocity; 
    CGL_int frame_count;
    CGL_int current_player_sprite;
    CGL_int closest_pipe_index;
    CGL_int score;
    CGL_int last_scored_pipe;
    CGL_int state;
    CGL_float prev_time;
    CGL_float curr_time;
    CGL_float delta_time;
} g_State;

// Constants
static const CGL_float GRAVITY = -5.8f;
static const CGL_float JUMP_VELOCITY = 1.2f;
static const CGL_float PLATFORM_SCROLL_SPEED = 0.2f;
static const CGL_float PIPE_SPEED = 0.3f;

// Helper functions
CGL_texture* load_texture(const char* filename)
{
    CGL_image img = {0}; img.bytes_per_channel = 8;
    stbi_set_flip_vertically_on_load(true);
    img.data = stbi_load(filename, &img.width, &img.height, &img.channels, 0);
    if (!img.data) { CGL_error("Failed to load image: %s", filename); return NULL; }
    CGL_texture* tex = CGL_texture_create(&img); stbi_image_free(img.data);
    return tex;
}

CGL_int update_pipes(CGL_float player_x, CGL_float player_y)
{
    (void)player_y;

    CGL_float max_x = 0.0, min_dst = 100000.0f; 
    CGL_int min_dst_index = -1;
    
    for(CGL_int i = 0; i < 10; i++) { 
        max_x = CGL_utils_max(max_x, g_State.pipes[i].x);
    }
    max_x = CGL_utils_max(max_x, 1.0f);
    
    for(CGL_int i = 0; i < 10; i++)
    {
        g_State.pipes[i].x -= PIPE_SPEED * g_State.delta_time; // Scale with delta time
        
        if(g_State.pipes[i].x < -2.0f) 
        {
            CGL_float mid = CGL_utils_random_float_in_range(0.5f, 1.5f);
            g_State.pipes[i].x = max_x + 0.75f; 
            g_State.pipes[i].y = mid; 
            max_x = g_State.pipes[i].x;
        }
        
        CGL_float dst = fabsf(g_State.pipes[i].x - player_x);
        if(dst < min_dst) { min_dst = dst; min_dst_index = i; }
    }
    return min_dst_index;
}

CGL_bool init()
{
    srand((uint32_t)time(NULL));
    if(!CGL_init()) return CGL_FALSE;

    g_State.window_width = g_State.window_height = 700;
    g_State.window = CGL_window_create(g_State.window_width, g_State.window_height, "Flappy Bird - Jaysmito Mukherjee");
    if(!g_State.window) return CGL_FALSE;
    
    CGL_window_make_context_current(g_State.window);
    if(!CGL_gl_init()) return CGL_FALSE;

    g_State.framebuffer = CGL_framebuffer_create_from_default(g_State.window);
    CGL_widgets_init();
    
    g_State.present_shader = CGL_shader_create(PASS_THROUGH_VERTEX_SHADER_SOURCE, PASS_THROUGH_FRAGMENT_SHADER_SOURCE, NULL);
    
    // Load textures
    g_State.bird_tex[0] = load_texture("assets/flappy_bird/bluebird-upflap.png");
    g_State.bird_tex[1] = load_texture("assets/flappy_bird/bluebird-midflap.png");
    g_State.bird_tex[2] = load_texture("assets/flappy_bird/bluebird-downflap.png");
    g_State.background_tex = load_texture("assets/flappy_bird/background-day.png");
    g_State.platform_tex = load_texture("assets/flappy_bird/base.png");
    g_State.pipe_tex = load_texture("assets/flappy_bird/pipe-green.png");
    g_State.game_over_tex = load_texture("assets/flappy_bird/gameover.png");
    g_State.messages = load_texture("assets/flappy_bird/message.png");

    // Initialize game state
    g_State.prev_time = CGL_utils_get_time();
    g_State.player_pos = 0.0f;
    g_State.player_velocity = 0.0f;
    g_State.frame_count = 0;
    g_State.score = 0;
    g_State.state = 0;

    for (int i = 0; i < 10; i++) g_State.pipes[i].x = -100.0f;

    return CGL_TRUE;
}

void cleanup()
{
    // Destroy textures
    for(int i = 0; i < 3; i++) CGL_texture_destroy(g_State.bird_tex[i]);
    CGL_texture_destroy(g_State.background_tex);
    CGL_texture_destroy(g_State.platform_tex);
    CGL_texture_destroy(g_State.pipe_tex);
    CGL_texture_destroy(g_State.game_over_tex);
    CGL_texture_destroy(g_State.messages);
    
    CGL_widgets_shutdown();
    CGL_shader_destroy(g_State.present_shader);
    CGL_framebuffer_destroy(g_State.framebuffer);
    CGL_gl_shutdown();
    CGL_window_destroy(g_State.window);
    CGL_shutdown();
}

EM_BOOL loop(double time, void* userData)
{
    (void)time;
    (void)userData;

    // Update delta time
    g_State.curr_time = CGL_utils_get_time();
    g_State.delta_time = g_State.curr_time - g_State.prev_time;
    g_State.prev_time = g_State.curr_time;
    g_State.delta_time = CGL_utils_clamp(g_State.delta_time, 0.0f, 0.1f);

    // Update game state
    g_State.frame_count++;
    CGL_window_set_size(g_State.window, g_State.window_width, g_State.window_height);

    // Game logic
    if(g_State.state == 1) {
        // Update physics
        g_State.player_velocity += GRAVITY * g_State.delta_time;
        g_State.player_pos += g_State.player_velocity * g_State.delta_time;
        
        // Update bird animation
        if (g_State.frame_count % 12 == 0) 
            g_State.current_player_sprite = (g_State.current_player_sprite + 1) % 3;

        if(CGL_window_get_key(g_State.window, CGL_KEY_SPACE) == CGL_PRESS) 
            g_State.player_velocity = JUMP_VELOCITY;

        g_State.closest_pipe_index = update_pipes(-0.2f, g_State.player_pos);
        CGL_float top_ht = g_State.pipes[g_State.closest_pipe_index].y - 0.3f, bottom_ht = 2.0f - g_State.pipes[g_State.closest_pipe_index].y - 0.3f;
        CGL_float dist = (g_State.pipes[g_State.closest_pipe_index].x - (-0.2f)); CGL_float dista = fabsf(dist);
        if(g_State.player_pos < -0.65f) g_State.state = 2;
        else if((dista < 0.1f) && (g_State.player_pos > (1.0f - top_ht) || g_State.player_pos < (-1.0f + bottom_ht))) g_State.state = 2;
        else if(dist < -0.095f && g_State.closest_pipe_index != g_State.last_scored_pipe) { g_State.score++; g_State.last_scored_pipe = g_State.closest_pipe_index; }
    }        
    CGL_framebuffer_bind(g_State.framebuffer); // bind default framebuffer and also adjust viewport size and offset
    CGL_gl_clear(0.0f, 0.0f, 0.0f, 1.0f); // clear screen with a dark gray color        
    glEnable(GL_BLEND); glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); glBlendEquation(GL_FUNC_ADD);
    CGL_shader_bind(g_State.present_shader);
    PO_TX(0.0f, 0.0f, 1.0f, 1.0f); DRAW_QUAD(g_State.background_tex, 1, -0.5625f, -1.0f, 2.0f * 0.5625f, 2.0f);        
    // Update platform scroll with delta time
    PO_TX(g_State.curr_time * PLATFORM_SCROLL_SPEED * (g_State.state == 1), 0.0f, 1.0f, 1.0f); 
    DRAW_QUAD(g_State.platform_tex, 2, -0.5625f, -1.0f, 2.0f * 0.5625f, 2.0f * 0.1422f);
    PO_TX(0.0f, 0.0f, 1.0f, 1.0f); DRAW_QUAD(g_State.bird_tex[g_State.current_player_sprite], 3, -0.2f + -0.17f * 0.5f, g_State.player_pos - 0.06f, 0.17f, 0.12f);
    for(CGL_int i = 0;i < 10 ; i++)
    {
        PO_TX(0.0f, 0.0f, 1.0f, -1.0f); DRAW_QUAD(g_State.pipe_tex, 4, g_State.pipes[i].x - 0.1f, 1.0f - g_State.pipes[i].y + 0.3f, 0.2f, g_State.pipes[i].y - 0.3f);
        PO_TX(0.0f, 0.0f, 1.0f, 1.0f); DRAW_QUAD(g_State.pipe_tex, 5, g_State.pipes[i].x - 0.1f, -1.0f, 0.2f, 2.0f - g_State.pipes[i].y - 0.3f);
    }
    if(g_State.state == 0)
    {
        PO_TX(0.0f, 0.75f, 1.0f, 0.28f); DRAW_QUAD(g_State.messages, 6, -0.5625f, 0.2f, 2.0f * 0.5625f, 0.2f);
        if(CGL_window_get_key(g_State.window, CGL_KEY_SPACE) == CGL_PRESS) { g_State.player_pos = 0.0f; g_State.player_velocity = 0.0f; g_State.state = 1; g_State.score = 0; for (int i = 0; i < 10; i++) g_State.pipes[i].x = -100.0f; }
    }
    if(g_State.state == 2)
    {
        PO_TX(0.0f, 0.0f, 1.0f, 1.0f); DRAW_QUAD(g_State.game_over_tex, 7, -0.5625f, 0.2f, 2.0f * 0.5625f, 0.2f);
        if(CGL_window_get_key(g_State.window, CGL_KEY_R) == CGL_PRESS) { g_State.player_pos = 0.0f; g_State.player_velocity = 0.0f; g_State.state = 1; g_State.score = 0; for (int i = 0; i < 10; i++) g_State.pipes[i].x = -100.0f; }
    }
    glDisable(GL_BLEND);
    CGL_widgets_begin();
    CGL_widgets_set_fill_colorf(0.0f, 0.0f, 0.0f, 1.0f); CGL_widgets_add_rect2f(-1.0f, -1.0f, 1.0f - 0.5625f, 2.0f);CGL_widgets_add_rect2f(0.5625f, -1.0f, 1.0f - 0.5625f, 2.0f);
    CGL_widgets_set_fill_colorf(1.7f, 1.7f, 1.7f, 1.0f); static CGL_byte score_str[32]; sprintf(score_str, "%d", g_State.score); CGL_widgets_add_string(score_str, -0.1f, 0.75f, 0.2f, 0.2f);
    CGL_widgets_end();        
    CGL_window_swap_buffers(g_State.window); // swap framebuffers
    CGL_window_poll_events(g_State.window); // poll events (if this is not called every frame window will stop responding)

    return !CGL_window_should_close(g_State.window);
}

int main()
{
    if(!init()) return 1;

#ifdef CGL_WASM
    CGL_info("Running in WASM mode");
    emscripten_request_animation_frame_loop(loop, NULL);
#else
    while (!CGL_window_should_close(g_State.window)) {
        loop(0, NULL);
    }
    cleanup();
#endif

    return 0;
}

```

`examples/c/flappy_bird_ai.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/


#define CGL_EXCLUDE_AUDIO
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_EXCLUDE_NETWORKING
#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#include "cgl.h"

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

#ifdef CGL_WASM
#include <emscripten/emscripten.h>
#include <emscripten/html5.h>
#else 
#define EM_BOOL int
#endif

static const char* PASS_THROUGH_VERTEX_SHADER_SOURCE = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
"in vec4 position;\n"
"in vec4 normal;\n"
"in vec4 texcoord;\n"
#else
"#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 normal;\n"
"layout (location = 2) in vec4 texcoord;\n"
#endif
"\n"
"out vec3 Position;\n"
"out vec2 TexCoord;\n"
"\n"
"uniform vec4 po;\n"
"\n"
"void main()\n"
"{\n"
"   vec2 pos = position.xy;\n"
"   pos = pos * po.zw * 0.5f;\n"
"   vec2 off = po.xy + po.zw * 0.5f;\n"
"   pos = pos + off;\n"
"	gl_Position = vec4(pos, 0.0f, 1.0f);\n"
"	Position = position.xyz;\n"
"	TexCoord = texcoord.xy;\n"
"}";

static const char* PASS_THROUGH_FRAGMENT_SHADER_SOURCE = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
#else
"#version 430 core\n"
#endif
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Position;\n"
"in vec2 TexCoord;\n"
"\n"
"uniform sampler2D u_tex;\n"
"uniform vec4 potx;"
"\n"
"void main()\n"
"{\n"
"   vec2 tx = vec2(1.0f - TexCoord.y, 1.0f - TexCoord.x);\n"
"   tx = tx * potx.zw;\n"
"   tx = tx + potx.xy;\n"
"	FragColor = texture(u_tex, tx);\n"
"}";

#define DRAW_QUAD(tex, ind, stx, sty, szx, szy) { \
    CGL_texture_bind(tex, ind); \
    CGL_shader_set_uniform_int(g_State.present_shader, CGL_shader_get_uniform_location(g_State.present_shader, "u_tex"), ind); \
    CGL_shader_set_uniform_vec4v(g_State.present_shader, CGL_shader_get_uniform_location(g_State.present_shader, "po"), (stx), (sty), (szx), (szy)); \
    CGL_gl_render_screen_quad(); \
} 

#define PO_TX(stx, sty, szx, szy) CGL_shader_set_uniform_vec4v(g_State.present_shader, CGL_shader_get_uniform_location(g_State.present_shader, "potx"), (stx), (sty), (szx), (szy));

#define PLAYER_COUNT 10000
#define INPUT_LAYER_SIZE 5
#define HIDDEN_LAYER_SIZE 10
#define OUTPUT_LAYER_SIZE 1
#define GAP_SIZE 0.4f
#define GAP_SIZE_HALF (GAP_SIZE * 0.5f)

typedef struct
{
	CGL_int state;
	CGL_int score;
	CGL_int sprite;
	CGL_float pos;
	CGL_float vel;
	CGL_float acc;
	CGL_float time;
	CGL_simple_neural_network* brain;
} player;

struct
{
	CGL_window* window;
	int window_height;
	int window_width;
	CGL_framebuffer* framebuffer;
	CGL_shader* present_shader;
	CGL_texture* bird_tex[3], * background_tex, * platform_tex, * pipe_tex, * game_over_tex, * messages;
	CGL_vec3 pipes[10];
	CGL_simple_neural_network* best_brain;
	player players[PLAYER_COUNT];

	// Game state variables
	CGL_float curr_time;
	CGL_float time_step;
	CGL_float tot_time;
	CGL_float best_fitness;
	CGL_int frame_count;
	CGL_int closest_pipe_index;
	CGL_int score;
	CGL_int last_scored_pipe;
	CGL_int state;
	CGL_int generation;
} g_State;

CGL_texture* load_texture(const char* filename)
{
	CGL_image img = { 0 }; img.bytes_per_channel = 8;
	stbi_set_flip_vertically_on_load(true);
	img.data = stbi_load(filename, &img.width, &img.height, &img.channels, 0);
	if (!img.data) { CGL_error("Failed to load image: %s", filename); return NULL; }
	CGL_texture* tex = CGL_texture_create(&img); stbi_image_free(img.data);
	return tex;
}

CGL_int update_pipes(CGL_float player_x)
{
	CGL_float max_x = 0.0, min_dst = 100000.0f; CGL_int min_dst_index = -1;
	for (CGL_int i = 0; i < 10; i++) {
		max_x = CGL_utils_max(max_x, g_State.pipes[i].x);
	}
	max_x = CGL_utils_max(max_x, 1.0f);

	for (CGL_int i = 0; i < 10; i++) {
		g_State.pipes[i].x -= 0.005f;
		if (g_State.pipes[i].x < -2.0f)
		{
			CGL_float mid = CGL_utils_random_float_in_range(0.5f, 1.5f);
			g_State.pipes[i].x = max_x + 0.75f;
			g_State.pipes[i].y = mid;
			max_x = g_State.pipes[i].x;
		}
		CGL_float dst = fabsf(g_State.pipes[i].x - player_x);
		if (dst < min_dst) { min_dst = dst; min_dst_index = i; }
	}
	return min_dst_index;
}

void reset_player(player* pl, player* fittest)
{
	pl->acc = -5.8f; pl->vel = 0.0f; pl->pos = 0.0f;
	pl->score = 0; pl->state = 0; pl->sprite = 0;
	pl->time = 0.0f; if (!fittest) CGL_simple_neural_network_randomize_weights(pl->brain, -2.0f, 2.0f);
	else { CGL_simple_neural_network_copy_weights(pl->brain, fittest->brain); CGL_simple_neural_network_mutate(pl->brain, 0.03f); }
}

void init_player(player* pl)
{
	pl->brain = CGL_simple_neural_network_create((CGL_int[]) { INPUT_LAYER_SIZE, HIDDEN_LAYER_SIZE, OUTPUT_LAYER_SIZE }, 3);
	reset_player(pl, NULL);
}

void destroy_player(player* pl) { CGL_simple_neural_network_destroy(pl->brain); }

CGL_bool evaluate_player(CGL_int player, CGL_int closest_pipe)
{
	CGL_float inputs[5] = {
		g_State.players[player].pos,
		g_State.players[player].vel,
		g_State.pipes[closest_pipe].x,
		g_State.pipes[closest_pipe].y - GAP_SIZE_HALF,
		g_State.pipes[closest_pipe].y + GAP_SIZE_HALF
	};
	inputs[0] = (inputs[0] + 1.0f) / 2.0f; inputs[1] = (inputs[1] + 10.0f) / 20.0f;
	inputs[2] = (inputs[2] + 2.0f) / 4.0f; inputs[3] = (inputs[3] + 1.0f) / 2.0f;
	inputs[4] = (inputs[4] + 1.0f) / 2.0f; CGL_float outputs[1] = { 0.0f };
	CGL_simple_neural_network_evaluate(g_State.players[player].brain, inputs, outputs);
	return outputs[0] > 0.5f;
}


CGL_bool init() {
	srand((uint32_t)time(NULL));

	g_State.window_height = g_State.window_width = 700;
	g_State.time_step = 1.0f / 60.0f;
	g_State.state = -1;
	g_State.generation = 1;

	if (!CGL_init()) {
		return CGL_FALSE;
	}

	// Initialize window and OpenGL context
	g_State.window = CGL_window_create(g_State.window_width, g_State.window_height, "Flappy Bird AI - Jaysmito Mukherjee");
	if (!g_State.window) {
		return CGL_FALSE;
	}

	CGL_window_make_context_current(g_State.window); // make the opengl context for the window current
	if (!CGL_gl_init()) return CGL_FALSE; // initialize cgl opengl module    
	g_State.framebuffer = CGL_framebuffer_create_from_default(g_State.window); // load the default framebuffer (0) into CGL_framebuffer object
	CGL_widgets_init();
	g_State.present_shader = CGL_shader_create(PASS_THROUGH_VERTEX_SHADER_SOURCE, PASS_THROUGH_FRAGMENT_SHADER_SOURCE, NULL);
	// These are from : https://github.com/samuelcust/flappy-bird-assets
	// Liscence (MIT) : https://github.com/samuelcust/flappy-bird-assets/blob/master/LICENSE 
	g_State.bird_tex[0] = load_texture("assets/flappy_bird/bluebird-upflap.png");
	g_State.bird_tex[1] = load_texture("assets/flappy_bird/bluebird-midflap.png");
	g_State.bird_tex[2] = load_texture("assets/flappy_bird/bluebird-downflap.png");
	g_State.background_tex = load_texture("assets/flappy_bird/background-day.png");
	g_State.platform_tex = load_texture("assets/flappy_bird/base.png");
	g_State.pipe_tex = load_texture("assets/flappy_bird/pipe-green.png");
	g_State.game_over_tex = load_texture("assets/flappy_bird/gameover.png");
	g_State.messages = load_texture("assets/flappy_bird/message.png");
	for (int i = 0; i < 10; i++) {
        g_State.pipes[i].x = -100.0f;
    }
    for (CGL_int i = 0; i < PLAYER_COUNT; i++) {
        init_player(&g_State.players[i]);
    }
	g_State.curr_time = CGL_utils_get_time();
	g_State.tot_time = 0.0f;
	g_State.frame_count = 0;
	g_State.closest_pipe_index = 0;
	g_State.score = 0;
	g_State.last_scored_pipe = -1;
	g_State.state = -1;
	g_State.generation = 1;
	glfwSwapInterval(1);
	g_State.best_brain = CGL_simple_neural_network_create((CGL_int[]) { INPUT_LAYER_SIZE, HIDDEN_LAYER_SIZE, OUTPUT_LAYER_SIZE }, 3);
	g_State.best_fitness = 0.0f;

	return CGL_TRUE;
}

CGL_void cleanup() {
	for (CGL_int i = 0; i < PLAYER_COUNT; i++) destroy_player(&g_State.players[i]);
	CGL_texture_destroy(g_State.bird_tex[0]); CGL_texture_destroy(g_State.bird_tex[1]); CGL_texture_destroy(g_State.bird_tex[2]);
	CGL_texture_destroy(g_State.background_tex); CGL_texture_destroy(g_State.platform_tex); CGL_texture_destroy(g_State.pipe_tex);
	CGL_texture_destroy(g_State.game_over_tex); CGL_texture_destroy(g_State.messages);
	CGL_widgets_shutdown();
	CGL_shader_destroy(g_State.present_shader);
	CGL_framebuffer_destroy(g_State.framebuffer); // destory framebuffer object
	CGL_gl_shutdown(); // shutdown cgl opengl module
	CGL_window_destroy(g_State.window); // destroy window
	CGL_shutdown(); // shutdown cgl and clean up resources allocated by CGL internally (if any)
}

EM_BOOL loop(double _time, void* userData) {
	(void)_time;
	(void)userData;

	g_State.frame_count++;
	g_State.curr_time = CGL_utils_get_time();
	CGL_window_set_size(g_State.window, g_State.window_width, g_State.window_height); // set window size
	if (g_State.state > -1 && g_State.state < PLAYER_COUNT)
	{
		g_State.closest_pipe_index = update_pipes(-0.2f);
		CGL_float top_ht = g_State.pipes[g_State.closest_pipe_index].y - GAP_SIZE_HALF, bottom_ht = 2.0f - g_State.pipes[g_State.closest_pipe_index].y - GAP_SIZE_HALF;
		CGL_float dist = (g_State.pipes[g_State.closest_pipe_index].x - (-0.2f)); CGL_float dista = fabsf(dist);
		for (CGL_int i = 0; i < PLAYER_COUNT; i++)
		{
			if (g_State.players[i].state == 1) continue; // 1 means dead
			g_State.players[i].vel += g_State.players[i].acc * g_State.time_step;
			g_State.players[i].pos += g_State.players[i].vel * g_State.time_step;
			if ((g_State.frame_count + i * 2) % 12 == 0) g_State.players[i].sprite = (g_State.players[i].sprite + 1) % 3;
			if (CGL_window_get_key(g_State.window, CGL_KEY_SPACE) == CGL_PRESS) g_State.players[i].vel = 1.2f;
			if (evaluate_player(i, g_State.closest_pipe_index)) g_State.players[i].vel = 1.2f;
			if (g_State.players[i].pos < -0.65f || g_State.players[i].pos > 1.0f) g_State.players[i].state = 1;
			else if ((dista < 0.1f) && (g_State.players[i].pos > (1.0f - top_ht) || g_State.players[i].pos < (-1.0f + bottom_ht))) g_State.players[i].state = 1;
			else if (dist < -0.095f && g_State.closest_pipe_index != g_State.last_scored_pipe) { g_State.score++; g_State.last_scored_pipe = g_State.closest_pipe_index; }
			g_State.players[i].time += g_State.time_step;
		}
		g_State.tot_time += g_State.time_step; g_State.state = 0; for (CGL_int i = 0; i < PLAYER_COUNT; i++) if (g_State.players[i].state == 1) g_State.state++;
	}
	if (CGL_window_get_key(g_State.window, CGL_KEY_ESCAPE) == CGL_PRESS) return CGL_FALSE;
	CGL_framebuffer_bind(g_State.framebuffer); // bind default framebuffer and also adjust viewport size and offset
	CGL_gl_clear(0.0f, 0.0f, 0.0f, 1.0f); // clear screen with a dark gray color        
	glEnable(GL_BLEND); glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); glBlendEquation(GL_FUNC_ADD);
	CGL_shader_bind(g_State.present_shader);
	PO_TX(0.0f, 0.0f, 1.0f, 1.0f); DRAW_QUAD(g_State.background_tex, 1, -0.5625f, -1.0f, 2.0f * 0.5625f, 2.0f);
	PO_TX(g_State.curr_time * 0.2f * (g_State.state > -1 && g_State.state < PLAYER_COUNT), 0.0f, 1.0f, 1.0f); DRAW_QUAD(g_State.platform_tex, 2, -0.5625f, -1.0f, 2.0f * 0.5625f, 2.0f * 0.1422f);
	PO_TX(0.0f, 0.0f, 1.0f, 1.0f);
	for (CGL_int i = 0; i < PLAYER_COUNT; i++) if (g_State.players[i].state == 0) DRAW_QUAD(g_State.bird_tex[g_State.players[i].sprite], 3, -0.2f + -0.17f * 0.5f, g_State.players[i].pos - 0.06f, 0.17f, 0.12f);
	for (CGL_int i = 0; i < 10; i++)
	{
		PO_TX(0.0f, 0.0f, 1.0f, -1.0f); DRAW_QUAD(g_State.pipe_tex, 4, g_State.pipes[i].x - 0.1f, 1.0f - g_State.pipes[i].y + GAP_SIZE_HALF, 0.2f, g_State.pipes[i].y - GAP_SIZE_HALF);
		PO_TX(0.0f, 0.0f, 1.0f, 1.0f); DRAW_QUAD(g_State.pipe_tex, 5, g_State.pipes[i].x - 0.1f, -1.0f, 0.2f, 2.0f - g_State.pipes[i].y - GAP_SIZE_HALF);
	}
	if (g_State.state == -1)
	{
		PO_TX(0.0f, 0.75f, 1.0f, 0.28f); DRAW_QUAD(g_State.messages, 6, -0.5625f, 0.2f, 2.0f * 0.5625f, 0.2f);
		if (CGL_window_get_key(g_State.window, CGL_KEY_SPACE) == CGL_PRESS)
		{
			g_State.state = 0; g_State.tot_time = 0.0f; g_State.last_scored_pipe = -1; g_State.score = 0;
			for (CGL_int i = 0; i < PLAYER_COUNT; i++) reset_player(&g_State.players[i], NULL);
			for (int i = 0; i < 10; i++) g_State.pipes[i].x = -100.0f;
		}
	}
	if (g_State.state == PLAYER_COUNT)
	{
		PO_TX(0.0f, 0.0f, 1.0f, 1.0f); DRAW_QUAD(g_State.game_over_tex, 7, -0.5625f, 0.2f, 2.0f * 0.5625f, 0.2f);
		CGL_int max_time_index = 0; CGL_float max_time = 0.0f;
		for (CGL_int i = 0; i < PLAYER_COUNT; i++) if (g_State.players[i].time > max_time) { max_time = g_State.players[i].time; max_time_index = i; }
		player temp = g_State.players[0]; g_State.players[0] = g_State.players[max_time_index]; g_State.players[max_time_index] = temp;
		if (g_State.players[0].time > g_State.best_fitness) { g_State.best_fitness = g_State.players[0].time;  CGL_simple_neural_network_copy_weights(g_State.best_brain, g_State.players[0].brain); }
		else if (g_State.players[0].time < g_State.best_fitness * 0.6f) CGL_simple_neural_network_copy_weights(g_State.players[0].brain, g_State.best_brain);
		{
			g_State.state = 0; g_State.tot_time = 0.0f; g_State.last_scored_pipe = -1; g_State.score = 0;
			for (CGL_int i = 1; i < PLAYER_COUNT; i++) {
                reset_player(&g_State.players[i], &g_State.players[0]);
            }
			for (int i = 0; i < 10; i++) {
                g_State.pipes[i].x = -100.0f;
            }
            g_State.generation++;
		}
	}
	glDisable(GL_BLEND); CGL_widgets_begin();
	CGL_widgets_set_fill_colorf(0.0f, 0.0f, 0.0f, 1.0f); CGL_widgets_add_rect2f(-1.0f, -1.0f, 1.0f - 0.5625f, 2.0f); CGL_widgets_add_rect2f(0.5625f, -1.0f, 1.0f - 0.5625f, 2.0f);
	static CGL_byte score_str[32];
	CGL_widgets_set_fill_colorf(1.7f, 1.7f, 1.7f, 1.0f); sprintf(score_str, "%d", g_State.score); CGL_widgets_add_string(score_str, -0.1f, 0.75f, 0.2f, 0.2f);
	CGL_widgets_set_fill_colorf(0.0f, 0.0f, 0.0f, 1.0f);
	sprintf(score_str, "%f", g_State.best_fitness); CGL_widgets_add_string(score_str, -0.2f, 0.55f, 0.4f, 0.05f);
	sprintf(score_str, "%f", g_State.tot_time); CGL_widgets_add_string(score_str, -0.2f, 0.50f, 0.4f, 0.05f);
	sprintf(score_str, "%d", g_State.generation); CGL_widgets_add_string(score_str, -0.05f, 0.45f, 0.1f, 0.05f);
	sprintf(score_str, "%d", (PLAYER_COUNT - g_State.state)); CGL_widgets_add_string(score_str, -0.05f, 0.40f, 0.1f, 0.05f);
	CGL_widgets_end();
	CGL_window_swap_buffers(g_State.window); // swap framebuffers
	CGL_window_poll_events(g_State.window); // poll events (if this is not called every frame window will stop responding)

	return CGL_TRUE;
}

int main()
{
	if (!init()) return EXIT_FAILURE;
#ifdef CGL_WASM
	CGL_info("Running in WASM mode");
	emscripten_request_animation_frame_loop(loop, NULL);
#else
	// run till the close button is clicked
	while (!CGL_window_should_close(g_State.window)) {
		if (!loop(0.0, NULL)) break;
	}
	cleanup();
#endif
	return EXIT_SUCCESS;
}

```

`examples/c/flow_fields.c`:

```c
/*
MIT License
Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_EXCLUDE_NETWORKING
#define CGL_EXCLUDE_SKY_RENDERER
#define CGL_EXCLUDE_PHONG_RENDERER
#define CGL_EXCLUDE_TILEMAP_RENDERER
#define CGL_IMPLEMENTATION
#include "cgl.h"

#define NUM_PARTICLES 8912
#define NUM_STEPS     16
#define SIZE          1024

static const char* VERTEX_SHADER_SOURCE = 
  "#version 430 core\n"
  "layout (location = 0) in vec4 position;\n"
  "layout (location = 1) in vec4 normal;\n"
  "layout (location = 2) in vec4 texcoord;\n"
  "out vec2 v_texcoord;\n"
  "void main() {\n"
  "  gl_Position = vec4(position.xyz, 1.0);\n"
  "  v_texcoord = texcoord.xy;\n"
  "}\n";

static const char* FRAGMENT_SHADER_SOURCE = 
  "#version 430 core\n"
  "in vec2 v_texcoord;\n"
  "out vec4 frag_color;\n"
  "uniform sampler2D u_tex;\n"
  "\n"
  "vec3 aces(vec3 x) {\n"
  "  const float a = 2.51;\n"
  "  const float b = 0.03;\n"
  "  const float c = 2.43;\n"
  "  const float d = 0.59;\n"
  "  const float e = 0.14;\n"
  "  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n"
  "}\n"
  "\n"
  "void main() {\n"
  " vec2 uv = vec2(1.0f - v_texcoord.y, 1.0f - v_texcoord.x);\n"
  " vec3 col = texture(u_tex, uv).rgb;\n"
  " col = aces(col);\n"
  " col = pow(col, vec3(1.0f / 2.2f));\n"
  " frag_color = vec4(col, 1.0);\n"
  "}\n";


static const char* COMPUTE_SHADER_SOURCE = 
  "#version 430 core\n"
  "layout (local_size_x = 16, local_size_y = 16) in;\n"
  "\n"
  "#define NUM_PARTICLES 4096\n"
  "\n"
  "struct Particle {\n"
  "  vec4 position;\n"
  "  vec4 velocity;\n"
  "  vec4 color;\n"
  "};\n"
  "\n"
  "layout (std430, binding = 2) buffer particle_ssbo {\n"
  "  Particle particles[];\n"
  "};\n"
  "\n"
  "layout (rgba32f, binding = 0) uniform image2D tex0;\n"
  "layout (rgba32f, binding = 1) uniform image2D tex1;\n"
  "\n"
  "vec3 palette( in float t )\n"
  "{\n"
    "vec3 a = vec3(0.7, 0.7, 0.7); // Light gray\n"
    "vec3 b = vec3(0.7, 0.7, 0.7); // Light gray\n"
    "vec3 c = vec3(0.1, 0.2, 0.3); // Blueish-gray\n"
    "vec3 d = vec3(0.6, 0.5, 0.4); // Brownish-gray\n"

  "    return a + b * cos(6.28318 * (c * t + d));\n"
  "}\n"
  "\n"
  "uniform int u_mode;\n"
  "uniform float u_dt;\n"
  "uniform float u_time;\n"
  "uniform int u_field_blocks;\n"
  "\n"
  "uint get_particle_index() {\n"
  "  return gl_GlobalInvocationID.y * gl_NumWorkGroups.x * gl_WorkGroupSize.x + gl_GlobalInvocationID.x;\n"
  "}\n"
  "\n"
  "float rand(uint index) {\n"
  "  return fract(sin(float(index) * 12.9898f) * 43758.5453f);\n"
  "}\n"
  "\n"
  "vec2 hash( vec2 p ) // replace this by something better\n"
  "{\n"
  "	p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n"
	" return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n"
  "}\n"

  "float noise2( in vec2 p)\n"
  "{\n"
  "    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n"
  "    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n"
  "\n"
	"    vec2  i = floor( p + (p.x+p.y)*K1 ); \n"
  "    vec2  a = p - i + (i.x+i.y)*K2;\n"
  "    float m = step(a.y,a.x); \n"
  "    vec2  o = vec2(m,1.0-m);\n"
  "    vec2  b = a - o + K2;\n"
	"    vec2  c = a - 1.0 + 2.0*K2;\n"
  "    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n"
	"    vec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0))); \n"
  "    return dot( n, vec3(70.0) );\n"
  "}\n"
  "\n"
  "float noise(in vec2 a , in float b) \n"
  "{\n"
  "    vec2 delta = vec2(sin(u_time), cos(u_time));\n"
  "    return noise2( vec2( noise2(vec2(a.x,a.y)), noise2(vec2(a.y,b)) ) + delta );\n"
  "}\n"
  "\n"
  "// field force\n"
  "vec2 f_field(vec2 uv) {\n"
  "  float f_x = floor(uv.x * float(u_field_blocks));\n"
  "  float f_y = floor(uv.y * float(u_field_blocks));\n"
  "\n"
  "  float tm = u_time * 0.1f;\n"
  "  float sc = 1.0 / 8.0f;\n"
  "  float ss = sin(u_time);\n"
  "  float angle = (noise(vec2(f_x, f_y) * 0.1 * sc + sin(tm), ss) * 2.0 - 1.0);\n"
  "  angle += (noise(vec2(f_x, f_y) * 0.2 * sc + cos(tm), ss) * 2.0 - 1.0) * 0.5f;\n"
  "  angle += (noise(vec2(f_x, f_y) * 0.4 * sc + sin(tm * 0.5f), ss) * 2.0 - 1.0) * 0.25f;\n"
  "  vec2 field = vec2(0.0); \n"
  "  field += vec2(cos(angle), sin(angle));\n"
  // add a force towards the center
  "  field += vec2(sin(u_time * 0.5f), cos(u_time * 0.5f)) * 0.3;\n"

  "  return normalize(field) * 0.8f;\n"
  "}\n"
  "\n"
  "// reset the image buffers\n"
  "void mode_0() {\n"
  "  ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);\n"
  "  vec2 uv = vec2(pixel_coords) / vec2(imageSize(tex0));\n"
  "  vec4 pixel = vec4(0.0f);\n"
  "  imageStore(tex0, pixel_coords, pixel);\n"
  "  imageStore(tex1, pixel_coords, pixel);\n"
  "}\n"
  "\n"
  "// reset the particles\n"
  "void mode_1() {\n"
  "  uint index = get_particle_index();\n"
  "  if (index >= NUM_PARTICLES) return;\n"
  "  Particle p;\n"
  "  p.position = vec4((index % int(sqrt(float(NUM_PARTICLES)))) / sqrt(float(NUM_PARTICLES)), (index / sqrt(float(NUM_PARTICLES))) / sqrt(float(NUM_PARTICLES)), 0.0f, 1.0f);\n"
  // "  p.velocity = vec4(normalize(p.position.xy - vec2(0.5f)) * 0.3f, 0.0f, 0.0f);\n"
  "  p.velocity = vec4(0.0f);\n"
  "  p.color = vec4(1.0f, 1.0f, 1.0f, 1.0f);\n"
  //"  p.color = vec4(rand(index), rand(index + 1), rand(index + 2), 1.0f);\n"
  "  particles[index] = p;\n"
  "}\n"
  "\n"
  "// update the particles\n"
  "void mode_2() {\n"
  "  uint index = get_particle_index();\n"
  "  if (index >= NUM_PARTICLES) return;\n"
  "  Particle p = particles[index];\n"
  "  p.position.xy += p.velocity.xy * u_dt;\n"
  "\n"
  "  if (p.position.x < 0.0f) p.position.x += 1.0f;\n"
  "  if (p.position.x > 1.0f) p.position.x -= 1.0f;\n"
  "  if (p.position.y < 0.0f) p.position.y += 1.0f;\n"
  "  if (p.position.y > 1.0f) p.position.y -= 1.0f;\n"
  "\n"
  "  p.velocity.xy *= 0.997f;\n"
  "  p.velocity.xy += f_field(p.position.xy) * u_dt;\n"
  "  particles[index] = p;\n"
  "\n"
  "  ivec2 pixel_coords = ivec2(p.position.xy * vec2(imageSize(tex0)));\n"
  "  vec4 pixel = vec4(palette(sin(p.velocity.x) * 0.5 - 0.25 * cos(p.velocity.y)), 1.0f);\n"
  "  float r = 2.0f;\n"
  "  int ri = 4;\n"
  "  vec4 prev_pixel, new_pixel;\n"
  "  for (int i = -ri; i <= ri; i++) {\n"
  "    for (int j = -ri; j <= ri; j++) {\n"
  "      prev_pixel = imageLoad(tex0, pixel_coords + ivec2(i, j));\n"
  "      new_pixel = 2.0f * pixel * exp(-float(i * i + j * j) * r) + prev_pixel;\n"
  "      imageStore(tex0, pixel_coords + ivec2(i, j), new_pixel);\n"
  "    }\n"
  "  }\n"
  "}\n"
  "\n"
  "// blur the image\n"
  "void mode_3() {\n"
  "  ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);\n"
  "  vec4 pixel = vec4(0.0f);\n"
  "  for (int i = -1; i <= 1; i++) {\n"
  "    for (int j = -1; j <= 1; j++) {\n"
  "      pixel += imageLoad(tex0, pixel_coords + ivec2(i, j));\n"
  "    }\n"
  "  }\n"
  "  pixel /= 9.0f;\n"
  "  pixel = mix(imageLoad(tex0, pixel_coords), pixel, 0.003f);\n"
  "  pixel = pixel * 0.995f;\n"
  "  vec2 uv = vec2(pixel_coords) / vec2(imageSize(tex0));\n"
  "  vec2 field = f_field(uv) * 0.5f + 0.5f;\n"
  "  imageStore(tex1, pixel_coords, vec4(field, 0.0, 1.0));\n"
  "  imageStore(tex0, pixel_coords, pixel);\n"
  "}\n"
  "\n"
  "void main() {\n"
  " if (u_mode == 0) {\n"
  "   mode_0();\n"
  " }\n"
  " else if (u_mode == 1) {\n"
  "   mode_1();\n"
  " }\n"
  " else if (u_mode == 2) {\n"
  "   mode_2();\n"
  " }\n"
  " else if (u_mode == 3) {\n"
  "   mode_3();\n"
  " }\n"
  "}\n";
    

int main() 
{
  // NOTE: I am not checking the return value of various functions here
  //       for brevity.
  CGL_init();
  CGL_window* window = CGL_window_create(SIZE, SIZE, "Flow Fields - Jaysmito Mukherjee");
  CGL_window_make_context_current(window);
  CGL_gl_init();
  CGL_widgets_init();


  CGL_framebuffer* main_framebuffer = CGL_framebuffer_create_from_default(window);
  CGL_shader* present_shader = CGL_shader_create(VERTEX_SHADER_SOURCE, FRAGMENT_SHADER_SOURCE, NULL);
  CGL_shader* compute_shader = CGL_shader_compute_create(COMPUTE_SHADER_SOURCE, NULL);
  CGL_ssbo* particle_ssbo = CGL_ssbo_create(2);
  CGL_texture* tex0 = CGL_texture_create_blank(SIZE, SIZE, GL_RGBA, GL_RGBA32F, GL_FLOAT);
  CGL_texture* tex1 = CGL_texture_create_blank(SIZE, SIZE, GL_RGBA, GL_RGBA32F, GL_FLOAT);

  CGL_ssbo_set_data(particle_ssbo, sizeof(float) * 4 * 3 * NUM_PARTICLES, NULL, false);

  CGL_shader_bind(compute_shader);
  CGL_ssbo_bind2(particle_ssbo, 2);
  glBindImageTexture(0, CGL_texture_get_internal_handle(tex0), 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
  glBindImageTexture(1, CGL_texture_get_internal_handle(tex1), 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
  CGL_shader_set_uniform_int(compute_shader, CGL_shader_get_uniform_location(compute_shader, "u_mode"), 0);
  CGL_shader_compute_dispatch(compute_shader, SIZE / 16, SIZE / 16, 1);
  CGL_shader_set_uniform_int(compute_shader, CGL_shader_get_uniform_location(compute_shader, "u_mode"), 1);
  CGL_shader_compute_dispatch(compute_shader, NUM_PARTICLES / (16 * 16), 1, 1);
  glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT | GL_SHADER_STORAGE_BARRIER_BIT);


  CGL_float prev_time = CGL_utils_get_time(), curr_time = 0.0f, dt = 0.0f, speed = 1.5f;

  while(!CGL_window_should_close(window)) 
  {
    curr_time = CGL_utils_get_time();
    dt = curr_time - prev_time;
    prev_time = curr_time;
    
    CGL_window_set_size(window, SIZE, SIZE);
    CGL_window_poll_events(window);

    
    CGL_shader_bind(compute_shader);
    CGL_ssbo_bind2(particle_ssbo, 2);
    
    CGL_shader_set_uniform_int(compute_shader, CGL_shader_get_uniform_location(compute_shader, "u_field_blocks"), 256);

    for (int i = 0 ; i < NUM_STEPS ; i++ )
    {
      glBindImageTexture(0, CGL_texture_get_internal_handle(tex0), 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
      glBindImageTexture(1, CGL_texture_get_internal_handle(tex1), 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
      CGL_shader_set_uniform_float(compute_shader, CGL_shader_get_uniform_location(compute_shader, "u_dt"), dt * speed / (float)(NUM_STEPS));
      CGL_shader_set_uniform_float(compute_shader, CGL_shader_get_uniform_location(compute_shader, "u_time"), curr_time);
    
      CGL_shader_set_uniform_int(compute_shader, CGL_shader_get_uniform_location(compute_shader, "u_mode"), 2);
      CGL_shader_compute_dispatch(compute_shader, NUM_PARTICLES / (16 * 16), 1, 1);
      glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT | GL_SHADER_STORAGE_BARRIER_BIT);
    
      CGL_shader_set_uniform_int(compute_shader, CGL_shader_get_uniform_location(compute_shader, "u_mode"), 3);
      CGL_shader_compute_dispatch(compute_shader, SIZE / 16, SIZE / 16, 1);
      glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT | GL_SHADER_STORAGE_BARRIER_BIT);
    }

    CGL_framebuffer_bind(main_framebuffer);
    CGL_gl_clear(0.0f, 0.0f, 0.0f, 1.0f);

    CGL_shader_bind(present_shader);
    CGL_texture_bind(tex0, 1); CGL_shader_set_uniform_int(present_shader, CGL_shader_get_uniform_location(present_shader, "u_tex"), 1);
    if (CGL_window_is_key_pressed(window, CGL_KEY_F)) 
    {
      CGL_texture_bind(tex1, 2); CGL_shader_set_uniform_int(present_shader, CGL_shader_get_uniform_location(present_shader, "u_tex"), 2);
    }
    CGL_gl_render_screen_quad();

    if (CGL_window_is_key_pressed(window, CGL_KEY_R)) 
    {
      CGL_shader_bind(compute_shader);
      CGL_ssbo_bind2(particle_ssbo, 2);
      glBindImageTexture(0, CGL_texture_get_internal_handle(tex0), 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
      glBindImageTexture(1, CGL_texture_get_internal_handle(tex1), 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
      CGL_shader_set_uniform_int(compute_shader, CGL_shader_get_uniform_location(compute_shader, "u_mode"), 0);
      CGL_shader_compute_dispatch(compute_shader, SIZE / 16, SIZE / 16, 1);
      CGL_shader_set_uniform_int(compute_shader, CGL_shader_get_uniform_location(compute_shader, "u_mode"), 1);
      CGL_shader_compute_dispatch(compute_shader, NUM_PARTICLES / (16 * 16), 1, 1);
      glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT | GL_SHADER_STORAGE_BARRIER_BIT);
    }

    if (CGL_window_is_key_pressed(window, CGL_KEY_ESCAPE)) 
      break;

    CGL_window_swap_buffers(window);
  }

  CGL_texture_destroy(tex0);
  CGL_texture_destroy(tex1);
  CGL_ssbo_destroy(particle_ssbo);
  CGL_shader_destroy(compute_shader);
  CGL_shader_destroy(present_shader);
  CGL_framebuffer_destroy(main_framebuffer);
  CGL_widgets_shutdown();
  CGL_gl_shutdown();
  CGL_window_destroy(window);
  CGL_shutdown();
}

```

`examples/c/font_text_widgets.c`:

```c
/*
MIT License
Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_EXCLUDE_NETWORKING
#define CGL_EXCLUDE_SKY_RENDERER
#define CGL_EXCLUDE_PHONG_RENDERER
#define CGL_EXCLUDE_TILEMAP_RENDERER
#define CGL_IMPLEMENTATION
#include "cgl.h"

int main()
{
     srand((uint32_t)time(NULL));
    if(!CGL_init()) return -1;
    CGL_window* main_window = CGL_window_create(640, 480, "Hello Font Widgets");
    if(!main_window) return -1;
    CGL_window_make_context_current(main_window);
    if(!CGL_gl_init()) return -1;
    CGL_widgets_init();
    CGL_framebuffer* default_framebuffer = CGL_framebuffer_create_from_default(main_window);   
    if(!CGL_text_init()) return EXIT_FAILURE;
    // Load Font file
    CGL_font* font = CGL_font_load("font.otf"); // you can replace this with any otf/ttf font
    // Build the font atlas and bake font bitmaps
    if(!CGL_font_build_atlas(font, 1024, 1024, 48)) {CGL_LOG("Error in building font atlas\n"); return EXIT_FAILURE;}
    while(!CGL_window_should_close(main_window))
    { 
        CGL_framebuffer_bind(default_framebuffer);
        CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);
        CGL_widgets_begin();
        CGL_widgets_add_string_with_font("Jaysmito Mukherjee!", font, -0.7f, -0.5f, 1.4f);
        CGL_widgets_end();
        CGL_window_poll_events(main_window);
        CGL_window_swap_buffers(main_window);
        if(CGL_window_get_key(main_window, CGL_KEY_ESCAPE) == CGL_PRESS) break;
    }
    CGL_font_destory(font);
    // CGL_texture_destroy(tex);
    CGL_widgets_shutdown();
    CGL_framebuffer_destroy(default_framebuffer);
    CGL_gl_shutdown();
    CGL_window_destroy(main_window);
    CGL_text_shutdown();
    CGL_shutdown();
    return 0;
}

```

`examples/c/game_of_life.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_EXCLUDE_AUDIO
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_EXCLUDE_NETWORKING
#define CGL_IMPLEMENTATION
#include "cgl.h"

#define MAIN_FRAME_BUFFER_SIZE  700


static struct
{
    CGL_float scale_x;
    CGL_float scale_y;
    CGL_float offset_x;
    CGL_float offset_y;
    CGL_tilemap* tilemap;
} tilemap_data;

#define TILE_COUNT_X 35
#define TILE_COUNT_Y 35

#define ID(x, y) ((x) + (y) * TILE_COUNT_X)

static CGL_int hovered_tile_x = -1, hovered_tile_y = -1;
static CGL_ubyte b0[TILE_COUNT_X][TILE_COUNT_Y], b1[TILE_COUNT_X][TILE_COUNT_Y];
static CGL_ubyte *board, *board_next;
static CGL_vec3 colors[] = {
    {0.0f, 0.0f, 0.0f},
    {1.0f, 0.0f, 0.0f},
    {0.0f, 1.0f, 0.0f}
};


void upload_tilemap()
{
    for(int i = 0 ; i < TILE_COUNT_X; i++)
        for(int j = 0 ; j < TILE_COUNT_Y; j++)
            CGL_tilemap_set_tile_color(tilemap_data.tilemap, i, j, colors[board[ID(i, j)]].x, colors[board[ID(i, j)]].y, colors[board[ID(i, j)]].z);
}

CGL_ubyte sample_from_board(int i, int j)
{
    CGL_ubyte val = board[ID(i, j)]; if(val == 1) val = 0; return val;
}

CGL_ubyte get_neighbour_count(int x, int y)
{
    CGL_int count = 0, val = 0, spx = 0, spy = 0;
    for(int i = -1 ; i <= 1 ; i ++) for(int j = -1 ; j <= 1 ; j ++)
    {
        spx = x + i; spy = y + j;
        if(i == 0 && j == 0) continue;
        if (spx < 0) spx = TILE_COUNT_X - 1;
        if (spx >= TILE_COUNT_X) spx = 0;
        if (spy < 0) spy = TILE_COUNT_Y - 1;
        if (spy >= TILE_COUNT_Y) spy = 0;
        val = (CGL_int)sample_from_board(spx, spy);
        if(val == 2) count ++;
    }
    return (CGL_ubyte)count;
}

void update_board()
{
    CGL_ubyte val = 0, nc;
    for(int i = 0 ; i < TILE_COUNT_X ; i ++) for(int j = 0 ; j < TILE_COUNT_Y ; j ++)
    {
        val = sample_from_board(i, j);
        nc = get_neighbour_count(i, j);
        if(val == 0 && nc == 3) board_next[ID(i, j)] = 2;
        else
        {
            if(nc < 2 || nc > 3) board_next[ID(i, j)] = 0;
            else board_next[ID(i, j)] = val;
        }
    }
}

int main()
{
    srand((uint32_t)time(NULL));
    if(!CGL_init()) return -1;
    CGL_window* main_window = CGL_window_create(700, 700, "Conway's Game of Life - Jaysmito Mukherjee");
    if(!main_window) return -1;
    CGL_window_make_context_current(main_window);
    if(!CGL_gl_init()) return -1;
    CGL_framebuffer* default_framebuffer = CGL_framebuffer_create_from_default(main_window);   
    tilemap_data.offset_x = 0.0f; tilemap_data.offset_y = 0.0f;
    tilemap_data.scale_x = 1.0f; tilemap_data.scale_y = 1.0f;
    tilemap_data.tilemap = CGL_tilemap_create(TILE_COUNT_X, TILE_COUNT_Y, 700 / TILE_COUNT_X, 700 / TILE_COUNT_Y, 0);
    board = (CGL_ubyte*)b0;
    board_next = (CGL_ubyte*)b1;
    CGL_bool playing = false;
    CGL_float last_board_update = CGL_utils_get_time();
    CGL_float board_update_interval = 0.3f;
    while(!CGL_window_should_close(main_window))
    { 
        {
            CGL_framebuffer_bind(default_framebuffer);
            CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);
            CGL_tilemap_render(tilemap_data.tilemap, tilemap_data.scale_x, tilemap_data.scale_y, tilemap_data.offset_x, tilemap_data.offset_y, NULL);
        }

        CGL_window_poll_events(main_window);


        if(CGL_utils_get_time() - last_board_update > board_update_interval) 
        {
            if(playing) {last_board_update = CGL_utils_get_time(); update_board(); }
        }
        else memcpy(board_next, board, sizeof(CGL_ubyte) * TILE_COUNT_X * TILE_COUNT_Y);
        CGL_double mx = 0.0, my = 0.0;
        CGL_window_get_mouse_position(main_window, &mx, &my);
        hovered_tile_x = (int)(mx / (700.0 / TILE_COUNT_X));
        hovered_tile_y = (int)((700.0 - my) / (700.0 / TILE_COUNT_Y));
        if(CGL_window_get_mouse_button(main_window, CGL_MOUSE_BUTTON_LEFT) == CGL_PRESS) board_next[ID(hovered_tile_x, hovered_tile_y)] = 2;
        if(CGL_window_get_mouse_button(main_window, CGL_MOUSE_BUTTON_RIGHT) == CGL_PRESS) board_next[ID(hovered_tile_x, hovered_tile_y)] = 0;
        { CGL_ubyte* temp = (CGL_ubyte*)board; board = board_next; board_next = temp; }

        upload_tilemap();

        CGL_window_swap_buffers(main_window);
        if(CGL_window_get_key(main_window, CGL_KEY_SPACE) == CGL_PRESS) playing = true;
        if(CGL_window_get_key(main_window, CGL_KEY_ENTER) == CGL_PRESS) playing = false;
        if(CGL_window_get_key(main_window, CGL_KEY_ESCAPE) == CGL_PRESS) break;
    }

    CGL_tilemap_destroy(tilemap_data.tilemap);

    CGL_framebuffer_destroy(default_framebuffer);
    CGL_gl_shutdown();
    CGL_window_destroy(main_window);
    CGL_shutdown();
    return 0;
}

```

`examples/c/generic_mxn_matrix.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#define CGL_EXCLUDE_TEXT_RENDER
#include "cgl.h"



int main()
{
    CGL_init();

    CGL_matrix* mat = CGL_matrix_identity(4, 3);
    CGL_info("Original Matrix");
    CGL_matrix_print(mat);

    CGL_matrix* mat2 = CGL_matrix_submatrix(mat, 0, 0, 3, 3);
    CGL_info("Submatrix");
    CGL_matrix_print(mat2);

    CGL_matrix_set_elem(mat2, 0, 0, 6.0f);
    CGL_info("Submatrix after setting element");
    CGL_matrix_print(mat2);

    CGL_matrix* mat5 = CGL_matrix_copy(mat2);
    CGL_info("Copy of submatrix");
    CGL_matrix_print(mat5);

    CGL_matrix* mat6 = CGL_matrix_transpose(mat2);
    CGL_info("Transpose of submatrix");
    CGL_matrix_print(mat6);    

    CGL_matrix* mat3 = CGL_matrix_mul(mat5, mat6);
    CGL_info("Matrix multiplication");
    CGL_matrix_print(mat3);

    CGL_matrix* mat4 = CGL_matrix_inverse(mat2);
    CGL_info("Inverse of submatrix");
    CGL_matrix_print(mat4);

    CGL_matrix* mat7 = CGL_matrix_mul(mat2, mat4);
    CGL_info("Matrix multiplication");
    CGL_matrix_print(mat7);

    CGL_matrix_destroy(mat);
    CGL_matrix_destroy(mat2);
    CGL_matrix_destroy(mat3);
    CGL_matrix_destroy(mat4);
    CGL_matrix_destroy(mat5);
    CGL_matrix_destroy(mat6);
    CGL_matrix_destroy(mat7);
    CGL_shutdown();
    return 0;
}

```

`examples/c/hashing_data.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#include "cgl.h"

int main()
{
    char buffer[1024];
    const char* data = "Hello World!";
    size_t size = strlen(data);
    printf("CRC32: %d\n", CGL_utils_crc32(data, size));
    printf("CRC64: %llu\n", CGL_utils_crc64(data, size));
    printf("SFH  : %d\n", CGL_utils_super_fast_hash(data, size));
    CGL_utils_rot13(data, buffer);
    printf("ROT13: %s\n", buffer);
    return 0;
}

```

`examples/c/hello_cube.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_EXCLUDE_NETWORKING
#define CGL_EXCLUDE_AUDIO
#define CGL_IMPLEMENTATION
#include "cgl.h"


const CGL_byte* DIFFUSE_VERTEX_SHADER_SOURCE = "#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 normal;\n"
"layout (location = 2) in vec4 texcoord;\n"
"\n"
"out vec3 Position;\n"
"out vec3 Normal;\n"
"out vec3 Color;\n"
"out vec2 TexCoord;\n"
"\n"
"uniform mat4 view_proj;\n"
"\n"
"void main()\n"
"{\n"
"   vec3 pos = position.xyz;\n"
"	gl_Position = view_proj * vec4(pos, 1.0f);\n"
"	Position = position.xyz;\n"
"	Normal = normal.xyz;\n"
"	TexCoord = texcoord.xy;\n"
"   Color = vec3(0.4f);\n"
"   Color = Normal * 0.5f + vec3(0.5f);"
"}";

const CGL_byte* DIFFUSE_FRAGMENT_SHADER_SOURCE = "#version 430 core\n"
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Position;\n"
"in vec3 Normal;\n"
"in vec3 Color;\n"
"in vec2 TexCoord;\n"
"\n"
"uniform vec3 u_light_pos;\n"
"\n"
"void main()\n"
"{\n"
"	vec3 object_color = Color;\n"
"	vec3 light_color = vec3(1.0f, 1.0f, 1.0f);\n"
"	vec3 light_dir = normalize(u_light_pos - Position);\n"
"	float diffuse = max(dot(-Normal, light_dir), 0.0f) + 0.18f;\n"
"	vec3 result = (diffuse * light_color) * object_color;\n"
"	FragColor = vec4(result, 1.0f);\n"
"}";



CGL_int main()
{
    if (!CGL_init()) return 1;
    CGL_window* window = CGL_window_create(600, 600, "Hello Cube!");
    CGL_window_make_context_current(window);
    if(!CGL_gl_init()) return 1;
    CGL_framebuffer* framebuffer = CGL_framebuffer_create_from_default(window);

    CGL_shader* diffuse_shader = CGL_shader_create(DIFFUSE_VERTEX_SHADER_SOURCE, DIFFUSE_FRAGMENT_SHADER_SOURCE, NULL);

    CGL_mesh_cpu* base_mesh = CGL_mesh_cpu_cube(false);
    CGL_mesh_cpu_recalculate_normals(base_mesh);
    CGL_mesh_gpu* base_mesh_gpu = CGL_mesh_gpu_create();
    CGL_mesh_gpu_upload(base_mesh_gpu, base_mesh, true);
    CGL_mesh_cpu_destroy(base_mesh);


    CGL_mat4 perspective = CGL_mat4_perspective(CGL_PI_2 * 0.5f, 1.0f, 0.01f, 100.0f); // create a perspective matrix
    CGL_mat4 view = CGL_mat4_look_at(CGL_vec3_init(0.0f, 0.0f, 8.0f), CGL_vec3_init(0.0f, -1.5f, 0.0f), CGL_vec3_init(0.0f, 1.0f, 0.0f)); // create a view matrix

    glEnable(GL_DEPTH_TEST);

    while(!CGL_window_should_close(window))
    {
        CGL_framebuffer_bind(framebuffer);
        CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);

        CGL_mat4 view_proj = CGL_mat4_mul(perspective, view);

        view = CGL_mat4_look_at(CGL_vec3_init(8.0f * sinf(CGL_utils_get_time()), 5.0f, 8.0f * cosf(CGL_utils_get_time())), CGL_vec3_init(0.0f, 0.0f, 0.0f), CGL_vec3_init(0.0f, 1.0f, 0.0f));

        CGL_shader_bind(diffuse_shader);
        CGL_shader_set_uniform_mat4(diffuse_shader, CGL_shader_get_uniform_location(diffuse_shader, "view_proj"), &view_proj);
        CGL_shader_set_uniform_vec3v(diffuse_shader, CGL_shader_get_uniform_location(diffuse_shader, "u_light_pos"), 5.0f, 5.0f, 5.0f);
        CGL_mesh_gpu_render(base_mesh_gpu);
        
        
        CGL_window_swap_buffers(window); 
        CGL_window_poll_events(window);
        if(CGL_window_get_key(window, CGL_KEY_ESCAPE) == CGL_PRESS) break;
    }

    CGL_mesh_gpu_destroy(base_mesh_gpu);
    CGL_shader_destroy(diffuse_shader);
    CGL_framebuffer_destroy(framebuffer);
    CGL_gl_shutdown();
    CGL_window_destroy(window);
    CGL_shutdown();
    return 0;
}

```

`examples/c/identicons.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_EXCLUDE_AUDIO
#define CGL_EXCLUDE_NETWORKING
#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#include "cgl.h"

static CGL_byte text_buffer[1024];
static CGL_int current_text_cursor = 0;
static CGL_int max_text_length = (CGL_int)(1.6f / 0.05f);

void key_callback(CGL_window* window, CGL_int key, CGL_int scancode, CGL_int action, CGL_int mods)
{
    (void)window; (void)scancode; (void)mods;
    if(action == CGL_RELEASE)
    {
        if(((key >= CGL_KEY_A && key <= CGL_KEY_Z) || (key >= CGL_KEY_0 && key <= CGL_KEY_9) || key == CGL_KEY_SPACE) && current_text_cursor <= max_text_length)
        {
            text_buffer[current_text_cursor++] = (CGL_byte)key;
            text_buffer[current_text_cursor] = '\0';
        }
        else if(key == CGL_KEY_BACKSPACE && current_text_cursor > 0)
            text_buffer[--current_text_cursor] = '\0';
    }
}

// extract 0s and 1s from the hash to the output buffer
static CGL_void calculate_hash_binary(CGL_uint hash, CGL_byte* hash_binary)
{
    CGL_byte* hash_bytes = (CGL_byte*)&hash;
    for(CGL_int i = 0, j = 0; i < 4; i++)
        for(CGL_int k = 0; k < 8; k++, j++)
            hash_binary[j] = (hash_bytes[i] >> k) & 1;
}

void update_tilemap(CGL_tilemap* tilemap)
{
    CGL_uint hash = CGL_utils_super_fast_hash(text_buffer, (CGL_int)strlen(text_buffer));
    CGL_byte hash_binary[32]; calculate_hash_binary(hash, hash_binary);
    CGL_ubyte* hash_bytes = (CGL_ubyte*)&hash; CGL_int hash_index = 0;
    CGL_int ri = hash_bytes[3], gi = hash_bytes[2], bi = hash_bytes[1];
    CGL_float r = (CGL_float)ri / 255.0f, g = (CGL_float)gi / 255.0f, b = (CGL_float)bi / 255.0f;
    for(CGL_int y = 0; y < 7 ; y++) for(CGL_int x = 0; x < 7; x++)
    {
        if(x == 0 || x == 6 || y == 0 || y == 6) { CGL_tilemap_set_tile_color(tilemap, x, y, 0.9f, 0.9f, 0.9f); continue; }
        if(x > 3) continue; // only the left half of the tilemap is used
        if(hash_binary[hash_index++]) { CGL_tilemap_set_tile_color(tilemap, x, y, r, g, b); CGL_tilemap_set_tile_color(tilemap, 6 - x, y, r, g, b); }
        else { CGL_tilemap_set_tile_color(tilemap, x, y, 0.9f, 0.9f, 0.9f); CGL_tilemap_set_tile_color(tilemap, 6 - x, y, 0.9f, 0.9f, 0.9f); }
    }
    CGL_tilemap_upload(tilemap);
}

int main()
{
    if(!CGL_init()) return -1;
    CGL_window* main_window = CGL_window_create(700, 700, "GitHub Identicons - Jaysmito Mukherjee");
    if(!main_window) return -1;
    CGL_window_make_context_current(main_window);
    CGL_window_set_key_callback(main_window, key_callback);
    if(!CGL_gl_init()) return -1;
    CGL_widgets_init();
    CGL_framebuffer* default_framebuffer = CGL_framebuffer_create_from_default(main_window);   
    CGL_tilemap* tilemap = CGL_tilemap_create(7, 7, 50, 50, 0);
    text_buffer[current_text_cursor] = '\0';
    CGL_tilemap_set_auto_upload(tilemap, CGL_FALSE);
    while(!CGL_window_should_close(main_window))
    { 
        CGL_window_set_size(main_window, 700, 700);
        update_tilemap(tilemap);
        CGL_framebuffer_bind(default_framebuffer);
        CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);
        CGL_tilemap_render(tilemap, 1.0f, 1.0f, (700 - 50 * 7) * 0.5f, 700 - 50 * 7 - 200, NULL);
        CGL_widgets_begin();
        CGL_byte* buffer = strlen(text_buffer) ? text_buffer : "Type Text";
        CGL_float length = (CGL_int)strlen(buffer) * 0.05f;
        if(!strlen(text_buffer)) CGL_widgets_set_fill_colorf(0.4f, 0.4f, 0.4f, 1.0f);
        else CGL_widgets_set_fill_colorf(0.9f, 0.9f, 0.9f, 1.0f);
        CGL_widgets_add_string(buffer, -length * 0.5f, 0.6f, length, 0.15f);
        CGL_widgets_end();
        CGL_window_poll_events(main_window);
        CGL_window_swap_buffers(main_window);
        
        if(CGL_window_get_key(main_window, CGL_KEY_ESCAPE) == CGL_PRESS) break;
    }
    CGL_tilemap_destroy(tilemap);
    CGL_framebuffer_destroy(default_framebuffer);
    CGL_widgets_shutdown();
    CGL_gl_shutdown();
    CGL_window_destroy(main_window);
    CGL_shutdown();
    return 0;
}

```

`examples/c/interactive_2d_triangulation.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/


#define CGL_EXCLUDE_NETWORKING
#define CGL_EXCLUDE_AUDIO
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#include "cgl.h"

#define POINT_RADIUS 0.05f
#define POINT_COUNT 1000

#ifdef CGL_WASM
#include <emscripten/emscripten.h>
#include <emscripten/html5.h>
#else 
#define EM_BOOL int
#endif

static struct
{
    CGL_vec2 points[POINT_COUNT];
    CGL_int triangles[POINT_COUNT * 3];
    CGL_window* window;
    CGL_framebuffer* framebuffer;
    CGL_int window_height;
    CGL_int window_width;
    CGL_int points_count;
    CGL_int triangle_count;
    CGL_int selected_point;
} g_context;

CGL_bool init()
{
    srand((uint32_t)time(NULL));
    if(!CGL_init()) return CGL_FALSE;
    g_context.window_width = g_context.window_height = 700;    
    g_context.window = CGL_window_create(g_context.window_width, g_context.window_height, "Triangulation Demo - Jaysmito Mukherjee");
    CGL_window_make_context_current(g_context.window);
    if(!CGL_gl_init()) return CGL_FALSE;   
    g_context.framebuffer = CGL_framebuffer_create_from_default(g_context.window);
    g_context.triangle_count = 0;
    g_context.points_count = 0;
    g_context.selected_point = -1;
    CGL_widgets_init();
    return CGL_TRUE;
}

void cleanup()
{
    CGL_widgets_shutdown();
    CGL_framebuffer_destroy(g_context.framebuffer);
    CGL_gl_shutdown();
    CGL_window_destroy(g_context.window);
    CGL_shutdown();
}

EM_BOOL loop(double time, void* userData)
{
    (void)time;
    (void)userData;

    CGL_window_set_size(g_context.window, g_context.window_width, g_context.window_height);

    CGL_framebuffer_bind(g_context.framebuffer);
    CGL_gl_clear(0.0f, 0.0f, 0.0f, 1.0f);

    CGL_widgets_begin();
    CGL_widgets_set_fill_colorf(0.8f, 0.8f, 0.8f, 1.0f);
    for(CGL_int i = 0; i < g_context.points_count; i++) {
        CGL_vec2 p = g_context.points[i];
        CGL_widgets_add_circle2fr(p.x, p.y, POINT_RADIUS, 8);
    }

    CGL_widgets_set_stroke_thicnkess(0.01f);
    CGL_widgets_set_stroke_colorf(0.5f, 0.5f, 0.5f, 1.0f);

    for(CGL_int i = 0 ; i < g_context.triangle_count;i++) {
        CGL_vec2 p1 = g_context.points[g_context.triangles[i * 3 + 0]];
        CGL_vec2 p2 = g_context.points[g_context.triangles[i * 3 + 1]];
        CGL_vec2 p3 = g_context.points[g_context.triangles[i * 3 + 2]];
        CGL_widgets_add_line2f(p1.x, p1.y, p2.x, p2.y);
        CGL_widgets_add_line2f(p2.x, p2.y, p3.x, p3.y);
        CGL_widgets_add_line2f(p3.x, p3.y, p1.x, p1.y);
    }

    CGL_widgets_set_stroke_colorf(0.5f, 0.3f, 0.3f, 1.0f);
    CGL_triangulate_points_incremental(g_context.points, g_context.points_count, g_context.triangles, &g_context.triangle_count);

    CGL_widgets_end();        

    CGL_bool mslft = (CGL_window_get_mouse_button(g_context.window, CGL_MOUSE_BUTTON_LEFT) == CGL_PRESS);
    CGL_bool msrht = (CGL_window_get_mouse_button(g_context.window, CGL_MOUSE_BUTTON_RIGHT) == CGL_PRESS);
    if(mslft || msrht)
    {
        CGL_double mx = 0.0, my = 0.0; CGL_bool caught = false;
        CGL_window_get_mouse_position(g_context.window, &mx, &my);
        mx = (mx / (CGL_double)g_context.window_width) * 2.0 - 1.0;
        my = (1.0 - my / (CGL_double)g_context.window_height) * 2.0 - 1.0;
        g_context.selected_point = -1;
        for(CGL_int i = 0; i < g_context.points_count; i++)
        {
            CGL_vec2 p = g_context.points[i]; CGL_float tx = (CGL_float)(p.x - mx), ty = (CGL_float)(p.y - my);
            if(sqrtf(tx * tx + ty * ty) < POINT_RADIUS) { g_context.selected_point = i; caught = true; break;}
        }
        if(caught)
        {
            if(mslft) {g_context.points[g_context.selected_point].x = (CGL_float)mx; g_context.points[g_context.selected_point].y = (CGL_float)my;}
            if(msrht) {for(CGL_int i = g_context.selected_point; i < g_context.points_count - 1; i++)g_context.points[i] = g_context.points[i + 1];g_context.points_count--;}
        }
        else if(mslft)
        {
            g_context.points[g_context.points_count].x = (CGL_float)mx; g_context.points[g_context.points_count].y = (CGL_float)my;
            g_context.selected_point = g_context.points_count; g_context.points_count++;
        }
    }

    CGL_window_swap_buffers(g_context.window);
    CGL_window_poll_events(g_context.window);

    return !CGL_window_should_close(g_context.window);
}

int main()
{
    if(!init()) return EXIT_FAILURE;

#ifdef CGL_WASM
    emscripten_request_animation_frame_loop(loop, NULL);
#else
    while (!CGL_window_should_close(g_context.window)) {
        loop(0, NULL);
    }
    cleanup();
#endif
    return EXIT_SUCCESS;
}

```

`examples/c/interactive_a_star_path_finding.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/


#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#include "cgl.h"

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

#define MAIN_FRAME_BUFFER_WIDTH     700
#define MAIN_FRAME_BUFFER_HEIGHT    700
#define TILE_SIZE                   14
#define TILE_MAP_SIZE               (700 / TILE_SIZE)
#define TILE_EMPTY_ID               0
#define TILE_START_POS_ID           1
#define TILE_END_POS_ID             2
#define TILE_WALL_ID                3
#define TILE_PATH_ID                4

static CGL_int grid[TILE_MAP_SIZE * TILE_MAP_SIZE] = {0};
static CGL_int start_pos[2] = {0};
static CGL_int end_pos[2] = {TILE_MAP_SIZE - 1, TILE_MAP_SIZE - 1};
static CGL_path_finding_a_star_context* path_finding_context = NULL;

void set_tilemap_from_ai_vector(CGL_tilemap* tilemap, CGL_int* data) // set tilemap from ai vector
{
    CGL_tilemap_set_auto_upload(tilemap, CGL_FALSE); // disable auto upload
    CGL_vec3 n_color = CGL_vec3_init(0.0f, 0.0f, 0.0f); // create color
    for(CGL_int y = 0 ; y < TILE_MAP_SIZE; y++) for(CGL_int x = 0 ; x < TILE_MAP_SIZE; x++) // iterate through all pixels
    {
        switch(data[y * TILE_MAP_SIZE + x])
        {
            case TILE_EMPTY_ID: n_color = CGL_vec3_init(0.1f, 0.1f, 0.1f); break; // set color to black
            case TILE_START_POS_ID: n_color = CGL_vec3_init(0.0f, 0.7f, 0.0f); break; // set color to green
            case TILE_END_POS_ID: n_color = CGL_vec3_init(0.7f, 0.0f, 0.0f); break; // set color to red
            case TILE_WALL_ID: n_color = CGL_vec3_init(0.7f, 0.7f, 0.7f); break; // set color to white
            case TILE_PATH_ID: n_color = CGL_vec3_init(0.0f, 0.0f, 0.7f); break; // set color to blue
        }
        CGL_tilemap_set_tile_color(tilemap, x, y, n_color.x, n_color.y, n_color.z); // set tile color
    }
    CGL_tilemap_upload(tilemap); // upload tilemap
    CGL_tilemap_set_auto_upload(tilemap, CGL_TRUE); // enable auto upload
}

CGL_bool node_equals(void* user_data, CGL_path_finding_node* node1, CGL_path_finding_node* node2)
{
    CGL_int* data1 = (CGL_int*)node1->data_ptr, *data2 = (CGL_int*)node2->data_ptr;
    return *data1 == *data2;
}

CGL_float heuristic(void* user_data, CGL_path_finding_node* node)
{
    CGL_int* data = (CGL_int*)node->data_ptr;
    CGL_int x = *data % TILE_MAP_SIZE, y = *data / TILE_MAP_SIZE;
    return (CGL_float)abs(x - end_pos[0]) + abs(y - end_pos[1]);
    //return (CGL_float)0.0f;
}

CGL_float cost(void* user_data, CGL_path_finding_node* start_node, CGL_path_finding_node* end_node)
{
    CGL_int* start_data = (CGL_int*)start_node->data_ptr, *end_data = (CGL_int*)end_node->data_ptr;
    CGL_int start_x = *start_data % TILE_MAP_SIZE, start_y = *start_data / TILE_MAP_SIZE;
    CGL_int end_x = *end_data % TILE_MAP_SIZE, end_y = *end_data / TILE_MAP_SIZE;
    return (CGL_float)abs(start_x - end_x) + abs(start_y - end_y);
}

CGL_int add_node(CGL_int x, CGL_int y)
{
    CGL_int id = y * TILE_MAP_SIZE + x;
    CGL_path_finding_node node; CGL_path_finding_node_init(&node, &id); node.is_open = CGL_TRUE;
    return CGL_path_finding_a_star_add_node(path_finding_context, node, node_equals);
}

CGL_int get_neighbours(void* user_data, CGL_path_finding_node* node, CGL_int* neighbours_out)
{
    CGL_int* data = (CGL_int*)node->data_ptr;
    CGL_int nx = *data % TILE_MAP_SIZE, ny = *data / TILE_MAP_SIZE, k = 0;
    for(CGL_int i = -1; i <= 1; i++) for(CGL_int j = -1; j <= 1; j++) 
    {
        if(i == 0 && j == 0) continue; // skip current node (itself)
        if(i == -1 && j == -1) continue; // skip top left 
        if(i == 1 && j == -1) continue; // skip top right
        if(i == -1 && j == 1) continue; // skip bottom left
        if(i == 1 && j == 1) continue; // skip bottom right
        CGL_int x = nx + i, y = ny + j; // get neighbour position
        if(x < 0 || x >= TILE_MAP_SIZE || y < 0 || y >= TILE_MAP_SIZE || grid[y * TILE_MAP_SIZE + x] == TILE_WALL_ID) continue; // skip if out of bounds or wall
        neighbours_out[k++] = add_node(x, y); // add neighbour
    }
    return k;
}

void update_path()
{
    CGL_int stnid = start_pos[1] * TILE_MAP_SIZE + start_pos[0], endid = end_pos[1] * TILE_MAP_SIZE + end_pos[0];
    CGL_path_finding_node start_node; CGL_path_finding_node_init(&start_node, &stnid); start_node.is_open = CGL_TRUE;
    CGL_path_finding_node end_node; CGL_path_finding_node_init(&end_node, &endid); end_node.is_open = CGL_TRUE;
    if(!CGL_path_finding_a_star_find_path(path_finding_context, start_node, end_node, heuristic, cost, get_neighbours, node_equals, NULL)) CGL_warn("Path not found!");
}

int main()
{
    srand((uint32_t)time(NULL)); // seed random number generator
    if(!CGL_init()) return -1; // initialize CGL
    CGL_window* main_window = CGL_window_create(MAIN_FRAME_BUFFER_WIDTH, MAIN_FRAME_BUFFER_HEIGHT, "A Star Path Finding - Jaysmito Mukherjee"); // create window
    if(!main_window) return -1; CGL_window_make_context_current(main_window); // make window context current
    if(!CGL_gl_init()) return -1; // initialize OpenGL
    CGL_framebuffer* default_framebuffer = CGL_framebuffer_create_from_default(main_window); // create framebuffer from default window
    CGL_tilemap* tilemap = CGL_tilemap_create(TILE_MAP_SIZE, TILE_MAP_SIZE, TILE_SIZE, TILE_SIZE, 1);
    CGL_widgets_init(); // initialize widgets
    path_finding_context = CGL_path_finding_a_star_context_create(TILE_MAP_SIZE * TILE_MAP_SIZE, CGL_TRUE, sizeof(CGL_int));
    while(!CGL_window_should_close(main_window)) // main loop
    { 
        CGL_window_set_size(main_window, MAIN_FRAME_BUFFER_WIDTH, MAIN_FRAME_BUFFER_HEIGHT); // set window size
        CGL_framebuffer_bind(default_framebuffer); // bind framebuffer
        CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f); // clear the screen
        if(CGL_window_is_key_pressed(main_window, CGL_KEY_F)) update_path(); CGL_int pos_id = 0;
        CGL_path_finding_a_star_reorder_path(path_finding_context);
        set_tilemap_from_ai_vector(tilemap, grid);
        while(CGL_path_finding_a_star_next_in_path(path_finding_context, &pos_id)) 
        {
            CGL_int x = pos_id % TILE_MAP_SIZE, y = pos_id / TILE_MAP_SIZE;
            CGL_tilemap_set_tile_color(tilemap, x, y, 0.0f, 0.0f, 1.0f);
        }
        CGL_tilemap_set_tile_color(tilemap, start_pos[0], start_pos[1], 0.0f, 1.0f, 0.0f); 
        CGL_tilemap_set_tile_color(tilemap, end_pos[0], end_pos[1], 1.0f, 0.0f, 0.0f);
        CGL_tilemap_render(tilemap, 1.0f, 1.0f, 0.0f, 0.0f, NULL); // render tilemap
        CGL_double mx = 0.0, my = 0.0; CGL_window_get_mouse_position(main_window, &mx, &my); my = MAIN_FRAME_BUFFER_HEIGHT - my; // get mouse position
        if(CGL_window_get_mouse_button(main_window, CGL_MOUSE_BUTTON_LEFT) == CGL_PRESS) 
        {
            CGL_path_finding_a_star_clear_path(path_finding_context);
            CGL_int x = (CGL_int)(TILE_MAP_SIZE * mx / 700), y = (CGL_int)(TILE_MAP_SIZE * my / 700); // get the tilemap coordinates
            grid[y * TILE_MAP_SIZE + x] = TILE_WALL_ID; // set the input vector
            if(CGL_window_is_key_pressed(main_window, CGL_KEY_S)) { start_pos[0] = x; start_pos[1] = y; } // set start position
            if(CGL_window_is_key_pressed(main_window, CGL_KEY_E)) { end_pos[0] = x; end_pos[1] = y; } // set end position
        }
        else if(CGL_window_get_mouse_button(main_window, CGL_MOUSE_BUTTON_RIGHT) == CGL_PRESS) 
        {
            CGL_path_finding_a_star_clear_path(path_finding_context);
            CGL_int x = (CGL_int)(TILE_MAP_SIZE * mx / 700), y = (CGL_int)(TILE_MAP_SIZE * my / 700); // get the tilemap coordinates
            grid[y * TILE_MAP_SIZE + x] = TILE_EMPTY_ID; // set the input vector
        }
        CGL_window_poll_events(main_window); CGL_window_swap_buffers(main_window); // swap buffers
        if(CGL_window_is_key_pressed(main_window, CGL_KEY_C)) { memset(grid, 0, sizeof(grid)); set_tilemap_from_ai_vector(tilemap, grid); } // clear the grid
        if(CGL_window_get_key(main_window, CGL_KEY_ESCAPE) == CGL_PRESS) break; // if the escape key is pressed, break the loop
    }
    CGL_tilemap_destroy(tilemap); // destroy the tilemap 
    CGL_framebuffer_destroy(default_framebuffer); // destroy the framebuffer
    CGL_widgets_shutdown(); // shutdown widgets
    CGL_gl_shutdown(); // shutdown OpenGL
    CGL_window_destroy(main_window); // destroy the window
    CGL_shutdown(); // shutdown CGL
    return EXIT_SUCCESS; // exit successfully
}

```

`examples/c/interactive_content_aware_crop.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_EXCLUDE_AUDIO
#define CGL_EXCLUDE_NETWORKING
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_IMPLEMENTATION
#include "cgl.h"

#ifndef CGL_WASM
#include "omp.h"
#endif

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "stb_image_write.h"


#define WINDOW_SIZE	800

#define SQ(x) ((x) * (x))

#define PREF(name, line) { \
	CGL_float start_time##__LINE__ = CGL_utils_get_time(); \
	line; \
	CGL_float end_time##__LINE__ = CGL_utils_get_time(); \
	CGL_info("%s: %f", name, end_time##__LINE__ - start_time##__LINE__); \
}

typedef struct
{
	CGL_int width;
    CGL_int height;
	CGL_float aspect_ratio;
    CGL_ubyte* data;
    CGL_texture* texture;
} ci_Image;


ci_Image ci_load_image(const char* filename)
{
	ci_Image image = {0};
	stbi_set_flip_vertically_on_load(CGL_TRUE);
	image.data = stbi_load(filename, &image.width, &image.height, NULL, 3);
	if (!image.data)
	{
		CGL_error("Failed to load image: %s", filename);
		return image;
	}
    CGL_image image_data = {0};
    image_data.width = image.width;
    image_data.height = image.height;
    image_data.data = image.data;
    image_data.channels = 3;
    image_data.bytes_per_channel = 8;
    image.texture = CGL_texture_create(&image_data);
	image.aspect_ratio = (CGL_float)image.width / (CGL_float)image.height;
	return image;
}

ci_Image ci_blank_image(CGL_int width, CGL_int height)
{
	ci_Image image = {0};
	image.width = width;
	image.height = height;
	image.data = (CGL_ubyte*)CGL_malloc(width * height * 3 * 4);
	if (!image.data)
	{
		CGL_error("Failed to allocate memory for image");
		return image;
	}
	memset(image.data, 0, width * height * 3 * 4);
	CGL_image image_data = {0};
	image_data.width = image.width;
	image_data.height = image.height;
	image_data.data = image.data;
	image_data.channels = 3;
	image_data.bytes_per_channel = 8;
	image.texture = CGL_texture_create(&image_data);
	image.aspect_ratio = (CGL_float)image.width / (CGL_float)image.height;
	return image;
}

void ci_upload_image(ci_Image* image)
{
	CGL_texture_set_data(image->texture, image->data);
}

void ci_recreate_texture(ci_Image* image)
{
	CGL_image image_data = {0};
	image_data.width = image->width;
	image_data.height = image->height;
	image_data.data = image->data;
	image_data.channels = 3;
	image_data.bytes_per_channel = 8;
	CGL_texture_destroy(image->texture);
	image->texture = CGL_texture_create(&image_data);
}

void ci_save_image(const char* filename, ci_Image image)
{
	stbi_write_png(filename, image.width, image.height, 3, image.data, image.width * 3);
}

void ci_free_image(ci_Image image)
{
	CGL_free(image.data);
	CGL_texture_destroy(image.texture);
}

CGL_void resize_normal(ci_Image* image, ci_Image* original_image, CGL_int target_width, CGL_int target_height);
typedef CGL_void(*ci_resize_func)(ci_Image*, ci_Image*, CGL_int, CGL_int);


#ifdef CGL_WASM
#include <emscripten/emscripten.h>
#include <emscripten/html5.h>
#define TMP_BUFFER_SIZE 3000
#else 
#define TMP_BUFFER_SIZE 6000
#define EM_BOOL int
#endif

struct {
    CGL_window* window;
    CGL_framebuffer* framebuffer;
    ci_Image original;
    ci_Image resized;
    ci_resize_func resize_func;
    CGL_int current;
    CGL_bool loaded;
} g_state;


CGL_void resize_normal(ci_Image* image, ci_Image* original_image, CGL_int target_width, CGL_int target_height)
{
	CGL_int new_size = target_width * target_height * 3;
	static CGL_ubyte tmp_buffer[6000 * 6000 * 3] = {0};

	CGL_ubyte* new_data = &tmp_buffer[0];

	#pragma omp parallel for collapse(2)
	for (CGL_int y = 0; y < target_height; y++)
	{
		for (CGL_int x = 0; x < target_width; x++)
		{
			CGL_float target_tx = (CGL_float)x / (CGL_float)target_width;
			CGL_float target_ty = (CGL_float)y / (CGL_float)target_height;

			CGL_int source_x = (CGL_int)(target_tx * original_image->width);
			CGL_int source_y = (CGL_int)(target_ty * original_image->height);


			CGL_ubyte* source_pixel = &original_image->data[(source_y * original_image->width  + source_x) * 3];

			new_data[(y * target_width + x) * 3 + 0] = source_pixel[0];
			new_data[(y * target_width + x) * 3 + 1] = source_pixel[1];
			new_data[(y * target_width + x) * 3 + 2] = source_pixel[2];
		}
	}

	memcpy(image->data, new_data, new_size);
	image->width = target_width;
	image->height = target_height;
	image->aspect_ratio = (CGL_float)target_width / (CGL_float)target_height;
	ci_recreate_texture(image);
}



CGL_float* ci_calculate_energy_map(ci_Image* image, CGL_float* energy_map, CGL_bool h_or_v)
{

	#pragma omp parallel for collapse(2)
	for (CGL_int y = 0; y < image->height; y++)
	{
		for (CGL_int x = 0; x < image->width; x++)
		{
			CGL_int left_x = x - 1;
			CGL_int right_x = x + 1;
			CGL_int up_y = y - 1;
			CGL_int down_y = y + 1;

			if (left_x < 0) left_x = 0;
			if (right_x >= image->width) right_x = image->width - 1;
			if (up_y < 0) up_y = 0;
			if (down_y >= image->height) down_y = image->height - 1;

			CGL_ubyte* left_pixel = NULL;
			CGL_ubyte* right_pixel = NULL;
			CGL_ubyte* center_pixel = NULL;

			if (h_or_v)
			{
				left_pixel = &image->data[(y * image->width + left_x) * 3];
				right_pixel = &image->data[(y * image->width + right_x) * 3];
				center_pixel = &image->data[(y * image->width + x) * 3];
			}
			else
			{
				left_pixel = &image->data[(up_y * image->width + x) * 3];
				right_pixel = &image->data[(down_y * image->width + x) * 3];
				center_pixel = &image->data[(y * image->width + x) * 3];
			}


			CGL_float lR = (CGL_float)left_pixel[0];
			CGL_float lG = (CGL_float)left_pixel[1];
			CGL_float lB = (CGL_float)left_pixel[2];

			CGL_float rR = (CGL_float)right_pixel[0];
			CGL_float rG = (CGL_float)right_pixel[1];
			CGL_float rB = (CGL_float)right_pixel[2];

			CGL_float mR = (CGL_float)center_pixel[0];
			CGL_float mG = (CGL_float)center_pixel[1];
			CGL_float mB = (CGL_float)center_pixel[2];

			CGL_float lumL = 0.299f * lR + 0.587f * lG + 0.114f * lB;
			CGL_float lumR = 0.299f * rR + 0.587f * rG + 0.114f * rB;
			CGL_float lumM = 0.299f * mR + 0.587f * mG + 0.114f * mB;

			CGL_float x_energy = sqrtf(
				SQ(lR - mR) + SQ(lG - mG) + SQ(lB - mB) +
				SQ(rR - mR) + SQ(rG - mG) + SQ(rB - mB)
			);
			x_energy += sqrtf(
				SQ(lumL - lumM) + SQ(lumR - lumM)
			);

			// for border pixels make energe very high
			if (x == 0 || x == image->width - 1 || y == 0 || y == image->height - 1)
			{
				x_energy = 10.0;
			}

			energy_map[y * image->width + x] = x_energy;
		}
	}

	return energy_map;
}

CGL_float* ci_calculate_h_energy_map(ci_Image* image) {
	static CGL_float energy_map[TMP_BUFFER_SIZE * TMP_BUFFER_SIZE] = { 0 };
	return ci_calculate_energy_map(image, energy_map, CGL_TRUE);
}

CGL_float* ci_calculate_v_energy_map(ci_Image* image)
{
	static CGL_float energy_map[TMP_BUFFER_SIZE * TMP_BUFFER_SIZE] = { 0 };
	return ci_calculate_energy_map(image, energy_map, CGL_FALSE);
}


CGL_int* ci_calculate_seam_map(CGL_float* energy_map, CGL_int* seam, CGL_int width, CGL_int height, CGL_bool h_or_v)
{
	
	#define SAMPLE_EMAP(x, y)  h_or_v ? energy_map[(y) * width + x] : energy_map[(x) * width + y] 
	#define UPDATE_EMAP(x, y, value)  { if (h_or_v) energy_map[(y) * width + x] = value; else energy_map[(x) * width + y] = value; }

	#pragma omp parallel for collapse(2)
	for (CGL_int i = 1; i < (h_or_v ? height : width); i++)
	{
		for (CGL_int j = 0; j < (h_or_v ? width : height); j++)
		{
			CGL_float prev_row_left = SAMPLE_EMAP(CGL_utils_clamp(j - 1, 0, width - 1), i - 1);
			CGL_float prev_row_center = SAMPLE_EMAP(j, i - 1);
			CGL_float prev_row_right = SAMPLE_EMAP(CGL_utils_clamp(j + 1, 0, width - 1), i - 1);


			CGL_float current_energy = SAMPLE_EMAP(j, i);

			CGL_float min_energy = CGL_utils_min(CGL_utils_min(prev_row_left, prev_row_center), prev_row_right);
			current_energy += min_energy;
			UPDATE_EMAP(j, i, current_energy);

		}
	}

	CGL_float min_energy = FLT_MAX;
	CGL_int min_energy_index = 0;

	// find min energy in last row or column depending on h_or_v
	for (CGL_int i = 0; i < (h_or_v ? width : height); i++)
	{
		CGL_float current_energy = SAMPLE_EMAP(i, (h_or_v ? height : width) - 1);
		if (current_energy < min_energy)
		{
			min_energy = current_energy;
			min_energy_index = i;
		}
	}

	// backtrace seam
	CGL_int current_index = min_energy_index;
	for (CGL_int i = (h_or_v ? height : width) - 1; i >= 0; i--)
	{
		seam[i] = current_index;
		CGL_float left_energy = FLT_MAX;
		CGL_float center_energy = FLT_MAX;
		CGL_float right_energy = FLT_MAX;
		if (current_index > 0) left_energy = SAMPLE_EMAP(current_index - 1, i);
		center_energy = SAMPLE_EMAP(current_index, i);
		if (current_index < (h_or_v ? width : height) - 1) right_energy = SAMPLE_EMAP(current_index + 1, i);
		CGL_float min_energy2 = CGL_utils_min(CGL_utils_min(left_energy, center_energy), right_energy);
		if (min_energy2 == left_energy) current_index--;
		else if (min_energy2 == right_energy) current_index++;
	}

	return seam;
}

CGL_int* ci_calculate_h_seam_map(CGL_float* energy_map, CGL_int width, CGL_int height)
{
	static CGL_int seam[6000] = { 0 };
	return ci_calculate_seam_map(energy_map, seam, width, height, CGL_TRUE);
}

CGL_int* ci_calculate_v_seam_map(CGL_float* energy_map, CGL_int width, CGL_int height)
{
	static CGL_int seam[6000] = { 0 };
	return ci_calculate_seam_map(energy_map, seam, width, height, CGL_FALSE);
}

CGL_void resize_ci(ci_Image* image, ci_Image* original_image, CGL_int target_width, CGL_int target_height)
{
	(void)original_image;
	// NOTE: This is not at all a good idea to recalculate the energy maps every step, ideally reuse
	//       the energy maps and update them as needed. But for the sake of simplicity I did not do that here
	CGL_float* h_energy_map = ci_calculate_h_energy_map(image);
	CGL_float* v_energy_map = ci_calculate_v_energy_map(image);

	CGL_int* h_seam_map = ci_calculate_h_seam_map(h_energy_map, image->width, image->height);
	CGL_int* v_seam_map = ci_calculate_v_seam_map(v_energy_map, image->width, image->height);

	static CGL_byte new_data[6000 * 6000 * 3] = { 0 };

	CGL_int new_width = target_width == image->width ? image->width : (target_width < image->width ? image->width - 1 : image->width + 1);
	CGL_int new_height = target_height == image->height ? image->height : (target_height < image->height ? image->height - 1 : image->height + 1);

	CGL_bool add_h_seam = new_width > image->width;
	CGL_bool add_v_seam = new_height > image->height;
	CGL_bool remove_h_seam = new_width < image->width;
	CGL_bool remove_v_seam = new_height < image->height;

	// loop through each row and remove the seam
	// if new width is smaller than original width, remove vertical seam
	// if new height is smaller than original height, remove horizontal seam
#ifndef CGL_WASM
	#pragma omp parallel for collapse(2)
#endif
	for (CGL_int i = 0; i < new_height; i++)
	{
		CGL_int h_seam = h_seam_map[i];
		for (CGL_int j = 0; j < new_width; j++)
		{
			CGL_int v_seam = v_seam_map[j];

			CGL_int tj = j;
			CGL_int ti = i;

			CGL_int source_x = tj;
			CGL_int source_y = ti;

			if (remove_h_seam && h_seam <= tj) source_x++;
			if (remove_v_seam && v_seam <= ti) source_y++;

			if (add_h_seam && h_seam < tj) source_x--;
			if (add_v_seam && v_seam < ti) source_y--;

			CGL_int source_index = (source_y * image->width + source_x) * 3;
			CGL_int dest_index = (ti * new_width + tj) * 3;

			CGL_ubyte pr = image->data[source_index + 0], pg = image->data[source_index + 1], pb = image->data[source_index + 2];

			if (add_h_seam) {
				// if its the seam then interpolate between the neighbour pixels
				if (h_seam == tj)
				{
					CGL_int left_index = (source_y * image->width + source_x - 1) * 3;
					CGL_int right_index = (source_y * image->width + source_x) * 3;

					CGL_ubyte lr = image->data[left_index + 0], lg = image->data[left_index + 1], lb = image->data[left_index + 2];
					CGL_ubyte rr = image->data[right_index + 0], rg = image->data[right_index + 1], rb = image->data[right_index + 2];

					pr = (lr + rr) / 2;
					pg = (lg + rg) / 2;
					pb = (lb + rb) / 2;
				}
			}
			if (add_v_seam) {
				// if its the seam then interpolate between the neighbour pixels
				if (v_seam == ti)
				{
					CGL_int top_index = ((source_y - 1) * image->width + source_x) * 3;
					CGL_int bottom_index = ((source_y) * image->width + source_x) * 3;

					CGL_ubyte tr = image->data[top_index + 0], tg = image->data[top_index + 1], tb = image->data[top_index + 2];
					CGL_ubyte br = image->data[bottom_index + 0], bg = image->data[bottom_index + 1], bb = image->data[bottom_index + 2];

					pr = (tr + br) / 2;
					pg = (tg + bg) / 2;
					pb = (tb + bb) / 2;
				}
			}

			new_data[dest_index + 0] = pr;
			new_data[dest_index + 1] = pg;
			new_data[dest_index + 2] = pb;
		}
	}

	memcpy(image->data, new_data, new_width * new_height * 3);
	image->width = new_width;
	image->height = new_height;
	image->aspect_ratio = (CGL_float)image->width / (CGL_float)image->height;
	ci_recreate_texture(image);
}


// a drag and drop callback
CGL_void CGL_window_drop_callback(CGL_window* window, const CGL_byte** paths, CGL_int count)
{
    (void)window;
	if (count > 0)
	{
		if (g_state.original.data)
		{
			ci_free_image(g_state.original);
			ci_free_image(g_state.resized);

			g_state.loaded = CGL_FALSE;
		}

		g_state.original = ci_load_image(paths[0]);
		g_state.resized = ci_blank_image(g_state.original.width, g_state.original.height);
		memcpy(g_state.resized.data, g_state.original.data, g_state.original.width * g_state.original.height * 3);
		ci_upload_image(&g_state.resized);

		g_state.current = 1;
		g_state.loaded = CGL_TRUE;
		CGL_info("Loaded image: %s", paths[0]);
	}
}

CGL_bool init()
{
    if (!CGL_init()) return CGL_FALSE;
    g_state.window = CGL_window_create(WINDOW_SIZE, WINDOW_SIZE, "Content Aware Image Resize - Jaysmito Mukherjee");
    if (!g_state.window) return CGL_FALSE;
    CGL_window_make_context_current(g_state.window);
    if (!CGL_gl_init()) return CGL_FALSE;

    g_state.framebuffer = CGL_framebuffer_create_from_default(g_state.window);
    CGL_window_set_drag_n_drop_callback(g_state.window, CGL_window_drop_callback);

    g_state.resize_func = resize_ci;
    g_state.current = 1;
    g_state.loaded = CGL_FALSE;

    CGL_widgets_init();
    return CGL_TRUE;
}

void cleanup()
{
    if (g_state.loaded) {
        ci_free_image(g_state.original);
        ci_free_image(g_state.resized);
    }
    CGL_framebuffer_destroy(g_state.framebuffer);
    CGL_widgets_shutdown();
    CGL_gl_shutdown();
    CGL_window_destroy(g_state.window);
    CGL_shutdown();
}

EM_BOOL loop(double time, void* userData)
{
    (void)time;
    (void)userData;
    
    CGL_window_set_size(g_state.window, WINDOW_SIZE, WINDOW_SIZE);

    CGL_int delta = 1;
    // W + up arrow or down arrow to change width
    if (CGL_window_is_key_pressed(g_state.window, CGL_KEY_W) && CGL_window_is_key_pressed(g_state.window, CGL_KEY_UP)) {
        PREF("Resize", g_state.resize_func(&g_state.resized, &g_state.original, g_state.resized.width + delta, g_state.resized.height));
    }
    else if (CGL_window_is_key_pressed(g_state.window, CGL_KEY_W) && CGL_window_is_key_pressed(g_state.window, CGL_KEY_DOWN)) {
        PREF("Resize", g_state.resize_func(&g_state.resized, &g_state.original, g_state.resized.width - delta, g_state.resized.height));
    }

    // H + up arrow or down arrow to change height
    if (CGL_window_is_key_pressed(g_state.window, CGL_KEY_H) && CGL_window_is_key_pressed(g_state.window, CGL_KEY_UP)) {
        PREF("Resize", g_state.resize_func(&g_state.resized, &g_state.original, g_state.resized.width, g_state.resized.height + delta));
    }
    else if (CGL_window_is_key_pressed(g_state.window, CGL_KEY_H) && CGL_window_is_key_pressed(g_state.window, CGL_KEY_DOWN)) {
        PREF("Resize", g_state.resize_func(&g_state.resized, &g_state.original, g_state.resized.width, g_state.resized.height - delta));
    }

    CGL_framebuffer_bind(g_state.framebuffer);
    CGL_gl_clear(0.1f, 0.1f, 0.1f, 1.0f);

    CGL_widgets_begin();

    if (g_state.loaded)
    {
        ci_Image* image = g_state.current == 0 ? &g_state.original : &g_state.resized;

        CGL_widgets_set_texture(image->texture);

        CGL_float width = 1.0f, height = 1.0f, offset_x = 0.0f, offset_y = 0.0f;
        if ( image->aspect_ratio > 1.0)
        {
            height = 1.0f / image->aspect_ratio;
            offset_y = (1.0f - height) / 2.0f;
        }
        else
        {
            width = image->aspect_ratio;
            offset_x = (1.0f - width) / 2.0f;
        }

        offset_x = offset_x * 2.0f - 1.0f;
        offset_y = offset_y * 2.0f - 1.0f;

        height *= 2.0f;
        width *= 2.0f;

        CGL_widgets_add_rect2f(offset_x, offset_y, width, height);

        // Set texture details as titile of the window
        static CGL_byte title[256];
        sprintf(title, "Content Aware Image Resize - [Image : %dx%d] [%s] - Jaysmito Mukherjee", image->width, image->height, g_state.current == 0 ? "Original" : "Resized");
        CGL_window_set_title(g_state.window, title);
    }
    else {
        CGL_window_set_title(g_state.window, "Content Aware Image Resize - Jaysmito Mukherjee");
    }

    if (CGL_window_is_key_pressed(g_state.window, CGL_KEY_O)) {
        g_state.current = 0;
    } else if (CGL_window_is_key_pressed(g_state.window, CGL_KEY_R)) {
        g_state.current = 1;
    }

    // reset on space
    if (CGL_window_is_key_pressed(g_state.window, CGL_KEY_SPACE)) {
        g_state.resize_func = resize_normal;
        memcpy(g_state.resized.data, g_state.original.data, g_state.original.width * g_state.original.height * 3);
        g_state.resized.width = g_state.original.width;
        g_state.resized.height = g_state.original.height;
        ci_upload_image(&g_state.resized);
    }

    CGL_widgets_end();

    CGL_window_swap_buffers(g_state.window);
    CGL_window_poll_events(g_state.window);

    return !CGL_window_should_close(g_state.window);
}

int main()
{
    if (!init()) return 1;

#ifdef CGL_WASM
    emscripten_request_animation_frame_loop(loop, NULL);
#else
    while (!CGL_window_should_close(g_state.window)) {
        loop(0, NULL);
    }
    cleanup();
#endif

    return 0;
}

```

`examples/c/interactive_linear_regression.c`:

```c
/*
MIT License
Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_EXCLUDE_NETWORKING
#define CGL_LOGGING_ENABLED
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_EXCLUDE_AUDIO
#define CGL_IMPLEMENTATION
#include "cgl.h"

#ifdef CGL_WASM
#include <emscripten/emscripten.h>
#include <emscripten/html5.h>
#else 
#define EM_BOOL int
#endif

#define POINT_RADIUS 0.02f
#define POINT_COUNT 1000
#define CURVE_SAMPLE_POINTS 1000

static struct
{
    CGL_vec2 points[POINT_COUNT]; // points to be used for linear regression
    CGL_window* window; // window object
    CGL_framebuffer* framebuffer; // framebuffer object
    CGL_int points_count; // number of points 
    CGL_int selected_point; // selected point for dragging and deleting
    CGL_linear_regression_context* lr_context; // linear regression context
    CGL_float curr_time;
    CGL_int frame_count;
} g_context; // global context

// this function will be provided to the linear regression context to sample the data
// this will be used to train the linear regression model using gradient descent
CGL_float sample_function(CGL_void* user_data, CGL_float* input, CGL_float* output, CGL_int id)
{ 
    (void)user_data; 
    (void)output;
    if(id < 0 || id >= g_context.points_count) return 0.0f; // invalid id
    memcpy(input, &g_context.points[id].x, sizeof(CGL_float)); // copy the x value of the point 
    // *input = g_context.points[id].x; // we can also do this here as we have only one input variable
    return g_context.points[id].y; // return the y value of the point
}

CGL_bool init()
{
    srand((uint32_t)time(NULL));
    if(!CGL_init()) return CGL_FALSE;
    
    g_context.window = CGL_window_create(700, 700, "Linear Regression - Jaysmito Mukherjee");
    if(!g_context.window) return CGL_FALSE;
    
    CGL_window_make_context_current(g_context.window);
    if(!CGL_gl_init()) return CGL_FALSE;
    
    g_context.framebuffer = CGL_framebuffer_create_from_default(g_context.window);
    g_context.points_count = 0;
    g_context.selected_point = -1;
    g_context.frame_count = 0;
    g_context.curr_time = CGL_utils_get_time();
    
    CGL_widgets_init();
    
    g_context.lr_context = CGL_linear_regression_context_create(1);
    CGL_linear_regression_randomize_coefficents(g_context.lr_context, -0.5f, 0.5f);
    
    return CGL_TRUE;
}

void cleanup()
{
    CGL_linear_regression_context_destroy(g_context.lr_context);
    CGL_widgets_shutdown();
    CGL_framebuffer_destroy(g_context.framebuffer);
    CGL_gl_shutdown();
    CGL_window_destroy(g_context.window);
    CGL_shutdown();
}

EM_BOOL loop(double time, void* userData)
{
    (void)time;
    (void)userData;
    
    g_context.frame_count++;
    g_context.curr_time = CGL_utils_get_time();
    
    CGL_window_set_size(g_context.window, 700, 700);
    CGL_framebuffer_bind(g_context.framebuffer);
    CGL_gl_clear(0.0f, 0.0f, 0.0f, 1.0f);
    
    CGL_widgets_begin();
    
    // Draw axes
    CGL_widgets_set_stroke_thicnkess(0.01f);
    CGL_widgets_set_stroke_colorf(0.5f, 0.7f, 0.5f, 1.0f);
    CGL_widgets_add_line2f(-1.0f, 0.0f, 1.0f, 0.0f);
    CGL_widgets_add_line2f(0.0f, -1.0f, 0.0f, 1.0f);
    
    // Draw points
    CGL_widgets_set_fill_colorf(0.8f, 0.8f, 0.8f, 1.0f);
    for(CGL_int i = 0; i < g_context.points_count; i++) {
        CGL_vec2 p = g_context.points[i];
        CGL_widgets_add_circle2fr(p.x, p.y, POINT_RADIUS, 8);
    }
    
    // Draw regression curve
    CGL_widgets_set_stroke_colorf(0.7f, 0.5f, 0.5f, 1.0f);
    CGL_widgets_set_stroke_thicnkess(0.005f);
    CGL_vec2 prev_point = CGL_vec2_init(0.0f, 0.0f);
    
    for(CGL_int i = 0; i < CURVE_SAMPLE_POINTS + 10; i++)
    {
        CGL_float x = -1.0f + (2.0f / (CGL_float)CURVE_SAMPLE_POINTS) * (CGL_float)i;
        CGL_float y = CGL_linear_regression_evaluate(g_context.lr_context, &x, NULL);
        if(i % (CGL_int)(CURVE_SAMPLE_POINTS * 0.1f) == 0)
            CGL_widgets_add_circle2fr(x, y, POINT_RADIUS * 0.5f, 4);
        if(i > 0)
            CGL_widgets_add_line2f(prev_point.x, prev_point.y, x, y);
        prev_point = CGL_vec2_init(x, y);
    }
    
    CGL_widgets_end();
    
    // Handle input
    if(CGL_window_is_key_pressed(g_context.window, CGL_KEY_R))
        CGL_linear_regression_randomize_coefficents(g_context.lr_context, -0.5f, 0.5f);
    if(CGL_window_is_key_pressed(g_context.window, CGL_KEY_C))
        g_context.points_count = 0;
    
    // Handle mouse input
    CGL_bool mslft = (CGL_window_get_mouse_button(g_context.window, CGL_MOUSE_BUTTON_LEFT) == CGL_PRESS);
    CGL_bool msrht = (CGL_window_get_mouse_button(g_context.window, CGL_MOUSE_BUTTON_RIGHT) == CGL_PRESS);
    
    if(mslft || msrht)
    {
        CGL_double mx = 0.0, my = 0.0; CGL_bool caught = false;
        CGL_window_get_mouse_position(g_context.window, &mx, &my);
        mx = (mx / 700.0) * 2.0 - 1.0; my = (1.0 - my / 700.0) * 2.0 - 1.0;
        g_context.selected_point = -1;
        for(CGL_int i = 0; i < g_context.points_count; i++)
        {
            CGL_vec2 p = g_context.points[i]; CGL_float tx = (CGL_float)(p.x - mx), ty = (CGL_float)(p.y - my);
            if(sqrtf(tx * tx + ty * ty) < POINT_RADIUS) { g_context.selected_point = i; caught = true; break;}
        }
        if(caught)
        {
            if(mslft) {g_context.points[g_context.selected_point].x = (CGL_float)mx; g_context.points[g_context.selected_point].y = (CGL_float)my;}
            if(msrht) {for(CGL_int i = g_context.selected_point; i < g_context.points_count - 1; i++)g_context.points[i] = g_context.points[i + 1];g_context.points_count--;}
        }
        else if(mslft)
        {
            g_context.points[g_context.points_count].x = (CGL_float)mx; g_context.points[g_context.points_count].y = (CGL_float)my;
            g_context.selected_point = g_context.points_count; g_context.points_count++;
        }
    }
    
    if(g_context.points_count > 0)
        CGL_linear_regression_train(g_context.lr_context, sample_function, NULL, g_context.points_count, 0.01f, 10);
    
    CGL_window_swap_buffers(g_context.window);
    CGL_window_poll_events(g_context.window);
    
    return !CGL_window_should_close(g_context.window);
}

int main()
{
    if(!init()) return EXIT_FAILURE;

#ifdef CGL_WASM
    CGL_info("Running in WASM mode");
    emscripten_request_animation_frame_loop(loop, NULL);
#else
    while (!CGL_window_should_close(g_context.window)) {
        loop(0, NULL);
    }
    cleanup();
#endif

    return EXIT_SUCCESS;
}

```

`examples/c/interactive_polynomial_regression.c`:

```c
/*
MIT License
Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_EXCLUDE_NETWORKING
#define CGL_LOGGING_ENABLED
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_IMPLEMENTATION
#include "cgl.h"

#ifdef CGL_WASM
#include <emscripten/emscripten.h>
#include <emscripten/html5.h>
#else 
#define EM_BOOL int
#endif

#define POINT_RADIUS 0.02f
#define POINT_COUNT 1000
#define CURVE_SAMPLE_POINTS 1000

static struct
{
    CGL_vec2 points[POINT_COUNT]; // points to be used for linear regression
    CGL_window* window; // window object
    CGL_framebuffer* framebuffer; // framebuffer object
    CGL_int points_count; // number of points 
    CGL_int selected_point; // selected point for dragging and deleting
    CGL_linear_regression_context* lr_context; // linear regression context
    CGL_float curr_time; // current time
    CGL_int frame_count; // frame count
} g_context; // global context

// this function will be provided to the linear regression context to sample the data
// this will be used to train the linear regression model using gradient descent
CGL_float sample_function(CGL_void* user_data, CGL_float* input, CGL_float* output, CGL_int id)
{
    (void)user_data; (void)output;
    if(id < 0 || id >= g_context.points_count) return 0.0f; // invalid id
    input[0] = g_context.points[id].x;
    input[1] = input[0] * input[0];
    input[2] = input[1] * input[0];
    input[3] = input[2] * input[0];
    input[4] = input[3] * input[0];
    return g_context.points[id].y; // return the y value of the point
}

CGL_bool init()
{
    srand((uint32_t)time(NULL)); // seed the random number generator
    if(!CGL_init()) return CGL_FALSE; // initialize CGL (required for setting up internals of CGL)
    g_context.window = CGL_window_create(700, 700, "Polynomial Regression - Jaysmito Mukherjee"); // create the window
    CGL_window_make_context_current(g_context.window); // make the opengl context for the window current
    if(!CGL_gl_init()) return CGL_FALSE; // initialize cgl opengl module    
    g_context.framebuffer = CGL_framebuffer_create_from_default(g_context.window); // load the default framebuffer (0) into CGL_framebuffer object
    g_context.points_count = 0; g_context.selected_point = -1; // initialize the number of points to 0 and selected point to -1
    CGL_widgets_init(); // initialize the widgets module
    g_context.curr_time = CGL_utils_get_time(); // get the current time
    g_context.frame_count = 0; // initialize the frame count
    g_context.lr_context = CGL_linear_regression_context_create(5); CGL_linear_regression_randomize_coefficents(g_context.lr_context, -0.5f, 0.5f);
    return CGL_TRUE;
}

void cleanup()
{
    CGL_linear_regression_context_destroy(g_context.lr_context); // destroy the linear regression context
    CGL_widgets_shutdown();
    CGL_framebuffer_destroy(g_context.framebuffer); // destory framebuffer object
    CGL_gl_shutdown(); // shutdown cgl opengl module
    CGL_window_destroy(g_context.window); // destroy window
    CGL_shutdown(); // shutdown cgl and clean up resources allocated by CGL internally (if any)
}

EM_BOOL loop(double time, void* userData)
{
    (void)time;
    (void)userData;

    g_context.frame_count++; g_context.curr_time = CGL_utils_get_time();
    CGL_window_set_size(g_context.window, 700, 700); // set window size
    CGL_framebuffer_bind(g_context.framebuffer); // bind default framebuffer and also adjust viewport size and offset
    CGL_gl_clear(0.0f, 0.0f, 0.0f, 1.0f); // clear screen with a dark gray color        
    CGL_widgets_begin(); // begin drawing widgets
    CGL_widgets_set_stroke_thicnkess(0.01f);
    CGL_widgets_set_stroke_colorf(0.5f, 0.7f, 0.5f, 1.0f);
    CGL_widgets_add_line2f(-1.0f, 0.0f, 1.0f, 0.0f); // x axis
    CGL_widgets_add_line2f(0.0f, -1.0f, 0.0f, 1.0f); // y axis
    CGL_widgets_set_fill_colorf(0.8f, 0.8f, 0.8f, 1.0f); // set the fill color to light gray
    // draw the points as circles
    for(CGL_int i = 0; i < g_context.points_count; i++) { CGL_vec2 p = g_context.points[i]; CGL_widgets_add_circle2fr(p.x, p.y, POINT_RADIUS, 8); }
    CGL_widgets_set_stroke_colorf(0.7f, 0.5f, 0.5f, 1.0f); // set the stroke color to slight red
    CGL_widgets_set_stroke_thicnkess(0.005f); // set the stroke thickness to 0.005 to draw the curve
    CGL_vec2 prev_point = CGL_vec2_init(0.0f, 0.0f);  // initialize the previous point to 0, 0
    for(CGL_int i = 0; i < CURVE_SAMPLE_POINTS + 10 ; i++) // draw the curve +10 points to make sure the curve is drawn completely
    {
        CGL_float x = -1.0f + (2.0f / (CGL_float)CURVE_SAMPLE_POINTS) * (CGL_float)i; // calculate the x value for the point
        CGL_float y = CGL_linear_regression_evaluate(g_context.lr_context, (CGL_float[]){x, x * x, x * x * x, x * x * x * x, x * x * x * x * x}, NULL); // evaluate the linear regression model at the x value
        if(i % (CGL_int)(CURVE_SAMPLE_POINTS * 0.1f) == 0) CGL_widgets_add_circle2fr(x, y, POINT_RADIUS * 0.5f, 4); // draw a small circle at every 10% of the curve (to prevent clutter)
        if(i > 0) CGL_widgets_add_line2f(prev_point.x, prev_point.y, x, y); // draw a line from the previous point to the current point to draw the curve
        prev_point = CGL_vec2_init(x, y); // set the previous point to the current point
    }
    // train the linear regression model if there are more than 0 points as 0 points will cause coeeficents to be blow up
    // NOTE : increase the max iterations to 1000 or more to get faster convergence, here it is set to 10 to make the training slower
    //        so that the user can see the training process in action as the line slowly converges to the points
    if(g_context.points_count > 0) CGL_linear_regression_train(g_context.lr_context, sample_function, NULL, g_context.points_count, 0.01f, 200); 
    CGL_widgets_end(); // end the widgets frame
    if(CGL_window_is_key_pressed(g_context.window, CGL_KEY_R)) CGL_linear_regression_randomize_coefficents(g_context.lr_context, -0.5f, 0.5f); // randomize the coeeficents if R is pressed
    if(CGL_window_is_key_pressed(g_context.window, CGL_KEY_C)) g_context.points_count = 0; // clear the points if C is pressed
    CGL_bool mslft = (CGL_window_get_mouse_button(g_context.window, CGL_MOUSE_BUTTON_LEFT) == CGL_PRESS), msrht = (CGL_window_get_mouse_button(g_context.window, CGL_MOUSE_BUTTON_RIGHT) == CGL_PRESS);
    if(mslft || msrht)
    {
        CGL_double mx = 0.0, my = 0.0; CGL_bool caught = false;
        CGL_window_get_mouse_position(g_context.window, &mx, &my);
        mx = (mx / 700.0) * 2.0 - 1.0; my = (1.0 - my / 700.0) * 2.0 - 1.0;
        g_context.selected_point = -1;
        for(CGL_int i = 0; i < g_context.points_count; i++)
        {
            CGL_vec2 p = g_context.points[i]; CGL_float tx = (CGL_float)(p.x - mx), ty = (CGL_float)(p.y - my);
            if(sqrtf(tx * tx + ty * ty) < POINT_RADIUS) { g_context.selected_point = i; caught = true; break;}
        }
        if(caught)
        {
            if(mslft) {g_context.points[g_context.selected_point].x = (CGL_float)mx; g_context.points[g_context.selected_point].y = (CGL_float)my;}
            if(msrht) {for(CGL_int i = g_context.selected_point; i < g_context.points_count - 1; i++)g_context.points[i] = g_context.points[i + 1];g_context.points_count--;}
        }
        else if(mslft)
        {
            g_context.points[g_context.points_count].x = (CGL_float)mx; g_context.points[g_context.points_count].y = (CGL_float)my;
            g_context.selected_point = g_context.points_count; g_context.points_count++;
        }
    }
    CGL_window_swap_buffers(g_context.window); // swap framebuffers
    CGL_window_poll_events(g_context.window); // poll events (if this is not called every frame window will stop responding)

    return !CGL_window_should_close(g_context.window);
}

int main()
{
    if(!init()) return EXIT_FAILURE;

#ifdef CGL_WASM
    CGL_info("Running in WASM mode");
    emscripten_request_animation_frame_loop(loop, NULL);
#else
    while (!CGL_window_should_close(g_context.window)) {
        loop(0, NULL);
    }
    cleanup();
#endif

    return EXIT_SUCCESS;
}

```

`examples/c/julia_set_viewer.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/


#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#define CGL_EXCLUDE_NETWORKING
#define CGL_EXCLUDE_RAY_CASTER
#define CGL_EXCLUDE_NODE_EDITOR
#include "cgl.h"

static const char* PASS_THROUGH_VERTEX_SHADER_SOURCE = "#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 normal;\n"
"layout (location = 2) in vec4 texcoord;\n"
"\n"
"out vec3 Position;\n"
"out vec2 TexCoord;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = vec4(position.xyz, 1.0f);\n"
"	Position = position.xyz;\n"
"	TexCoord = texcoord.xy;\n"
"}";

static const char* PASS_THROUGH_FRAGMENT_SHADER_SOURCE = "#version 430 core\n"
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Position;\n"
"in vec2 TexCoord;\n"
"\n"
"uniform sampler2D u_tex;\n"
"\n"
"// Black Box From https://github.com/armory3d/armory/blob/master/Shaders/std/tonemap.glsl\n"
"vec3 acesFilm(const vec3 x) {\n"
"    const float a = 2.51;\n"
"    const float b = 0.03;\n"
"    const float c = 2.43;\n"
"    const float d = 0.59;\n"
"    const float e = 0.14;\n"
"    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	vec3 color = texture(u_tex, vec2(TexCoord.y, 1.0f - TexCoord.x)).rgb;\n"
"	color = acesFilm(color);\n"
"   color = pow(color, vec3(1.0f / 2.2f));\n"
"	FragColor = vec4(color, 1.0f);\n"
"}";

static const char* JULIA_COMPUTE_SHADER = "#version 430 core\n"
"\n"
"layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;\n"
"\n"
"layout(rgba32f, binding = 0) uniform image2D output_tex;\n"
"\n"
"uniform double sc_size;\n"
"uniform double sc_res;\n"
"uniform double sc_ofx;\n"
"uniform double sc_ofy;\n"
"uniform double c_x;\n"
"uniform double c_y;\n"
"\n"
"#define MAX_ITER 500\n"
"#define BAIL_RADIUS 2.0\n"
"\n"
"void main()\n"
"{\n"
"   ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);\n"
"   dvec2 psc = vec2(pixel) / sc_res * sc_size + dvec2(sc_ofx, sc_ofy);\n"
"   dvec2 c = dvec2(c_x, c_y);\n"
"   dvec2 z = psc;\n"
"   int i = 0;\n"
"   for (; i < MAX_ITER; i++)\n"
"   {\n"
"       z = dvec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n"
"       if (z.x * z.x + z.y * z.y > BAIL_RADIUS) break;\n"
"   }\n"
"   float log_zn = float(log(float(z.x * z.x + z.y * z.y)) / 2.0);\n"
"   float nu = log(log_zn / log(float(BAIL_RADIUS))) / log(2.0f);\n"
"   float iter = float(i) + 1.0 - nu;\n"
"   float r = sqrt(iter / float(MAX_ITER));\n"
"   float g = iter / float(MAX_ITER);\n"
"   float b = sqrt(sqrt(iter / float(MAX_ITER)));\n"
"   imageStore(output_tex, pixel, vec4(r, g, b, 1.0f));\n"
"   // represent c with a small red circle of radius r\n"
"   float radius = 0.01f;\n"
"   if (length(psc - c) < radius) imageStore(output_tex, pixel, vec4(1.0f, 0.0f, 0.0f, 1.0f));\n"
"}\n";


#define MAP_RESOLUTION 700

static CGL_framebuffer* default_framebuffer = NULL;
static CGL_texture *output_tex = NULL;
static CGL_shader *output_tex_compute_shader = NULL, *present_shader = NULL;
static CGL_bloom *bloom = NULL;
static CGL_double scale, offset_x, offset_y, c_x, c_y;


int main()
{
    srand((uint32_t)time(NULL));
    CGL_init();
    CGL_window* window = CGL_window_create(700, 700, "Julia Set - Jaysmito Mukherjee");
    if(!window) return 1;
    CGL_window_make_context_current(window);
    CGL_gl_init();
    CGL_widgets_init();

    default_framebuffer = CGL_framebuffer_create_from_default(window);
    output_tex = CGL_texture_create_blank(MAP_RESOLUTION, MAP_RESOLUTION, GL_RGBA, GL_RGBA32F, GL_FLOAT);

    present_shader = CGL_shader_create(PASS_THROUGH_VERTEX_SHADER_SOURCE, PASS_THROUGH_FRAGMENT_SHADER_SOURCE, NULL);
    output_tex_compute_shader = CGL_shader_compute_create(JULIA_COMPUTE_SHADER, NULL);

    bloom = CGL_bloom_create(MAP_RESOLUTION, MAP_RESOLUTION, 3);

    scale = 1.0; offset_x = 0.0; offset_y = 0.0; c_x = -0.8; c_y = 0.156;

    CGL_float curr_time = CGL_utils_get_time();
    CGL_float prev_time = CGL_utils_get_time();
    CGL_float time = 0.0f, frame_time = 0.0f, delta_time = 0.0f;
    CGL_int frames = 0, fps = 0;

    while(!CGL_window_should_close(window))
    {
        CGL_window_set_size(window, 700, 700); // force window size to be 600x600

        curr_time = CGL_utils_get_time();
        delta_time = curr_time - prev_time;
        prev_time = curr_time;
        time += delta_time; frame_time += delta_time;
        frames++; if(frame_time >= 1.0f) { fps = frames; frames = 0; frame_time = 0.0f; }
        
        glBindImageTexture(0, output_tex->handle, 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
        CGL_shader_bind(output_tex_compute_shader);
        CGL_shader_set_uniform_double(output_tex_compute_shader, CGL_shader_get_uniform_location(output_tex_compute_shader, "sc_size"), 1.0 / scale);
        CGL_shader_set_uniform_double(output_tex_compute_shader, CGL_shader_get_uniform_location(output_tex_compute_shader, "sc_res"), (CGL_double)MAP_RESOLUTION);
        CGL_shader_set_uniform_double(output_tex_compute_shader, CGL_shader_get_uniform_location(output_tex_compute_shader, "sc_ofx"), offset_x);
        CGL_shader_set_uniform_double(output_tex_compute_shader, CGL_shader_get_uniform_location(output_tex_compute_shader, "sc_ofy"), offset_y);
        CGL_shader_set_uniform_double(output_tex_compute_shader, CGL_shader_get_uniform_location(output_tex_compute_shader, "c_x"), c_x);
        CGL_shader_set_uniform_double(output_tex_compute_shader, CGL_shader_get_uniform_location(output_tex_compute_shader, "c_y"), c_y);
        CGL_shader_compute_dispatch(output_tex_compute_shader, MAP_RESOLUTION / 16 + 1, MAP_RESOLUTION / 16 + 1, 1);
        glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT | GL_SHADER_STORAGE_BARRIER_BIT);

        //CGL_bloom_apply(bloom, output_tex);

        CGL_framebuffer_bind(default_framebuffer);
        CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);
        CGL_shader_bind(present_shader);
        CGL_texture_bind(output_tex, 0);
        CGL_shader_set_uniform_int(present_shader, CGL_shader_get_uniform_location(present_shader, "u_tex"), 0);
        CGL_gl_render_screen_quad();

        glDisable(GL_DEPTH_TEST);

        CGL_widgets_begin();
        
        CGL_widgets_set_fill_colorf(0.4f, 0.4f, 0.4f, 1.0f);

        static CGL_byte buffer[256];
        sprintf(buffer, "Frame Time: %f", delta_time);
        CGL_widgets_add_string(buffer, -1.0f, 0.975f, 0.5f, 0.025f);
        sprintf(buffer, "Framerate : %d", fps);
        CGL_widgets_add_string(buffer, -1.0f, 0.950f, 0.5f, 0.025f);
        sprintf(buffer, "Scale : %lf", scale);
        CGL_widgets_add_string(buffer, -1.0f, 0.925f, 0.5f, 0.025f);  
        sprintf(buffer, "Resolution: %dx%d", MAP_RESOLUTION, MAP_RESOLUTION);
        CGL_widgets_add_string(buffer, -1.0f, 0.900f, 0.5f, 0.025f);
        sprintf(buffer, "Offset X: %lf", offset_x);
        CGL_widgets_add_string(buffer, -1.0f, 0.875f, 0.5f, 0.025f);
        sprintf(buffer, "Offset Y: %lf", offset_y);
        CGL_widgets_add_string(buffer, -1.0f, 0.850f, 0.5f, 0.025f);
        sprintf(buffer, "C : (%lf, %lf)", c_x, c_y);
        CGL_widgets_add_string(buffer, -1.0f, 0.825f, 0.5f, 0.025f);


        CGL_widgets_end();

        CGL_window_poll_events(window);
        CGL_window_swap_buffers(window);


        if(CGL_window_get_key(window, CGL_KEY_C) == CGL_PRESS)
        {
            if(CGL_window_get_key(window, CGL_KEY_UP) == CGL_PRESS) c_y += 0.003f / scale;
            if(CGL_window_get_key(window, CGL_KEY_DOWN) == CGL_PRESS) c_y -= 0.003f / scale;
            if(CGL_window_get_key(window, CGL_KEY_LEFT) == CGL_PRESS) c_x += 0.003f / scale;
            if(CGL_window_get_key(window, CGL_KEY_RIGHT) == CGL_PRESS) c_x -= 0.003f / scale;
        }
        else if(CGL_window_get_key(window, CGL_KEY_S) == CGL_PRESS)
        {
            if(CGL_window_get_key(window, CGL_KEY_UP) == CGL_PRESS) scale *= 1.005f;
            if(CGL_window_get_key(window, CGL_KEY_DOWN) == CGL_PRESS) scale *= 0.995f;
        }
        else
        {
            if(CGL_window_get_key(window, CGL_KEY_UP) == CGL_PRESS) offset_y += 0.01f / scale;
            if(CGL_window_get_key(window, CGL_KEY_DOWN) == CGL_PRESS) offset_y -= 0.01f / scale;
            if(CGL_window_get_key(window, CGL_KEY_LEFT) == CGL_PRESS) offset_x += 0.01f / scale;
            if(CGL_window_get_key(window, CGL_KEY_RIGHT) == CGL_PRESS) offset_x -= 0.01f / scale;
        }


    }


    CGL_texture_destroy(output_tex);
    CGL_shader_destroy(output_tex_compute_shader);
    CGL_shader_destroy(present_shader);
    CGL_framebuffer_destroy(default_framebuffer);
    CGL_bloom_destroy(bloom);
    CGL_widgets_shutdown();
    CGL_gl_shutdown();
    CGL_window_destroy(window);    
    CGL_shutdown();
    return 0;
}

```

`examples/c/l_systems_viewer.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#include "cgl.h"

#define MAIN_FRAME_BUFFER_SIZE  700

typedef struct {
    CGL_vec2 position;
    CGL_float rotation;
    CGL_float line_size;
} turtle_state;


static struct {
    CGL_byte rules[256][256];
    CGL_byte rules_sizes[256];
    CGL_byte actions[256]; 
    CGL_byte axiom[256]; // null terminated string
    CGL_vec2 start_position;
    CGL_int rule_count;
    CGL_float angle;
    CGL_int iterations;
    CGL_float length_factor;
} l_system_data;

static CGL_byte lsbuffa[1024 * 1024], lsbuffb[1024 * 1024];
static CGL_byte *current_ls_buff, *next_ls_buff;
static turtle_state turtle_stack[1024 * 1024];
static CGL_int turtle_stack_top = -1;
static CGL_vec4 lines_data[1024 * 1024];
static CGL_int lines_count = 0;

// void add_line(CGL_float sx, CGL_float sy, CGL_float ex, CGL_float ey)
// {
//     lines_data[lines_count++] = CGL_vec4_init(sx, sy, ex, ey);
// }

void add_line(CGL_vec2 start_p, CGL_vec2 end_p)
{
    lines_data[lines_count++] = CGL_vec4_init(start_p.x, start_p.y, end_p.x, end_p.y);
}

void log_l_system_data()
{
    CGL_info("Angle: %f", l_system_data.angle);
    CGL_info("Iterations: %d", l_system_data.iterations);
    CGL_info("Length Factor: %f", l_system_data.length_factor);
    CGL_info("Axiom: %s", l_system_data.axiom);
    CGL_info("Start Position: (%f, %f)", l_system_data.start_position.x, l_system_data.start_position.y);
    CGL_info("Rules: ");
    for(CGL_int i = 0; i < 256; i++) if(l_system_data.rules[i][0] != 0) CGL_info("%c -> %s", i, l_system_data.rules[i]);
    CGL_info("Actions: ");
    for(CGL_int i = 0; i < 256; i++) if(l_system_data.actions[i] != 0) CGL_info("%c -> %d", i, l_system_data.actions[i]);
}

bool parse_parameter(const CGL_byte* line, CGL_byte* tbuffer, CGL_int* val)
{
    tbuffer[0] = '\0'; line++; // skip the ':'
    while(*line != ' ') { if(*line == 0) return false; *tbuffer++ = *line++; }
    *tbuffer = '\0'; *val = atoi(line); return true;
}

void parse_settings_file(const CGL_byte* path)
{
    memset(&l_system_data, 0, sizeof(l_system_data));
    FILE* file = fopen(path, "r");
    if(!file) { CGL_warn("Failed to load file %s", path); return; }
    CGL_info("Parsing file %s", path);
    CGL_byte line[1024], tbuffer[1024];
    CGL_int param_val = 0;
    CGL_byte parser_mode = 0; // 0 - parameters, 1 - rules, 2 - action
    while(fgets(line, 1024, file) != NULL)
    {
        if(line[0] == '#' || strlen(line) < 3) continue; // skip comment
        if(parser_mode == 0) 
        {
            if(line[0] == ':') // parse parameter
            {
                if(!parse_parameter(line, tbuffer, &param_val)) { CGL_warn("Error while parsing line %s", line); continue; }
                if(strcmp(tbuffer, "ANGLE") == 0) l_system_data.angle = CGL_deg_to_rad((CGL_float)param_val * 0.001f);
                else if(strcmp(tbuffer, "ITERATIONS") == 0) l_system_data.iterations = param_val;
                else if(strcmp(tbuffer, "LENGTH_FACTOR") == 0) l_system_data.length_factor = (CGL_float)param_val * 0.001f;
                else if(strcmp(tbuffer, "START_X") == 0) l_system_data.start_position.x = (CGL_float)param_val * 0.001f;
                else if(strcmp(tbuffer, "START_Y") == 0) l_system_data.start_position.y = (CGL_float)param_val * 0.001f;
                else if(strcmp(tbuffer, "AXIOM") == 0) { CGL_byte* ln = line + 6; CGL_byte* ax = l_system_data.axiom; while(*ln != '\n' && *ln != '\0') *ax++ = *ln++; *ax = '\0'; }
                else if(strcmp(tbuffer, "RULES") == 0) parser_mode = 1;
                else if(strcmp(tbuffer, "ACTIONS") == 0) parser_mode = 2;
                else CGL_warn("Unknown parameter %s", tbuffer);
            }
        }
        else
        {
            if (parser_mode == 1)
            {
                CGL_byte* ln = line; CGL_int rl_id = 0, ind = (CGL_byte)*ln++; ln++;
                while(*ln != '\n' && *ln != '\0') l_system_data.rules[ind][rl_id++] = *ln++; l_system_data.rules[ind][rl_id] = '\0';
                l_system_data.rules_sizes[ind] = rl_id; l_system_data.rule_count++;
            }
            else if (parser_mode == 2) l_system_data.actions[*line] = atoi(line + 2);
            param_val--; if(param_val == 0) parser_mode = 0;
        }
    }
    fclose(file);
    CGL_info("Parsing complete");
    CGL_info("----------------------------");
    log_l_system_data();
    CGL_info("----------------------------");
}



void drag_n_drop_callback(CGL_window* window, const CGL_byte** paths, CGL_int count)
{
    if(count > 0) parse_settings_file(paths[0]);
}

void generate_l_system_txt()
{
    CGL_int current_ls_buff_len = (CGL_int)strlen(current_ls_buff), next_ls_buff_len = 0;
    for(CGL_int i = 0 ; i < current_ls_buff_len ; i++)
    {
        CGL_byte input = current_ls_buff[i];
        CGL_byte* rule = l_system_data.rules[input];
        CGL_int rule_len = l_system_data.rules_sizes[input];
        if(rule_len == 0) next_ls_buff[next_ls_buff_len++] = input;
        else for(CGL_int j = 0; j < rule_len; j++) next_ls_buff[next_ls_buff_len++] = rule[j];
    }
    next_ls_buff[next_ls_buff_len] = '\0';
    CGL_byte* temp = current_ls_buff; current_ls_buff = next_ls_buff; next_ls_buff = temp;
}


void draw_system()
{
    turtle_stack_top = -1; lines_count = 0;
    turtle_state current_state;
    current_state.position = l_system_data.start_position;
    current_state.rotation = 0.0f;
    current_state.line_size = 0.2f;
    CGL_int current_ls_buff_len = (CGL_int)strlen(current_ls_buff);
    CGL_vec2 new_pos;
    for(CGL_int i = 0 ; i < current_ls_buff_len ; i++)
    {
        switch (l_system_data.actions[current_ls_buff[i]])
        {
        case 1:
            new_pos = CGL_vec2_add_(CGL_vec2_scale_(CGL_vec2_from_angle(current_state.rotation + CGL_PI_2), current_state.line_size), current_state.position);
            add_line(current_state.position, new_pos);
            current_state.position = new_pos;
            current_state.line_size *= l_system_data.length_factor;
            break;
        case 2:
            current_state.rotation += l_system_data.angle;
            break;
        case 3:
            current_state.rotation -= l_system_data.angle;
            break;
        case 4:
            turtle_stack[++turtle_stack_top] = current_state;
            break;
        case 5:
            current_state = turtle_stack[turtle_stack_top--];
            break;        
        default:
            break;
        }
    }
}

void generate_system()
{
    strcpy(current_ls_buff, l_system_data.axiom);
    for(CGL_int i = 0; i < l_system_data.iterations; i++) generate_l_system_txt();
    draw_system();
}

int main()
{
    srand((uint32_t)time(NULL));
    if(!CGL_init()) return -1;
    CGL_window* main_window = CGL_window_create(700, 700, "L Systems - Jaysmito Mukherjee");
    if(!main_window) return -1;
    CGL_window_make_context_current(main_window);
    CGL_window_set_drag_n_drop_callback(main_window, drag_n_drop_callback);
    if(!CGL_gl_init()) return -1;
    CGL_widgets_init();
    CGL_framebuffer* default_framebuffer = CGL_framebuffer_create_from_default(main_window);   
    current_ls_buff = lsbuffa; next_ls_buff = lsbuffb;
    while(!CGL_window_should_close(main_window))
    { 
        CGL_window_set_size(main_window, MAIN_FRAME_BUFFER_SIZE, MAIN_FRAME_BUFFER_SIZE);

        {
            CGL_framebuffer_bind(default_framebuffer);
            CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);

            CGL_widgets_begin();

            CGL_widgets_set_fill_colorf(0.7f, 0.2f, 0.7f, 1.0f);
            CGL_widgets_set_stroke_thicnkess(0.01f);
            for(CGL_int i = 0; i < lines_count; i++)
                CGL_widgets_add_line2f(lines_data[i].x, lines_data[i].y, lines_data[i].z, lines_data[i].w);

            static CGL_byte buff[1024];
            sprintf(buff, "Iterations: %d", l_system_data.iterations);
            CGL_widgets_add_string(buff, -1.0f, 0.9f, 1.0f, 0.1f);
            sprintf(buff, "Lines: %d", lines_count);
            CGL_widgets_add_string(buff, -1.0f, 0.8f, 1.0f, 0.1f);

            CGL_widgets_end();
        }

        CGL_window_poll_events(main_window);
        CGL_window_swap_buffers(main_window);

        if(CGL_window_is_key_pressed(main_window, CGL_KEY_I))
        {
            if(CGL_window_is_key_pressed(main_window, CGL_KEY_UP)) {l_system_data.iterations++; CGL_utils_sleep(200);}
            if(CGL_window_is_key_pressed(main_window, CGL_KEY_DOWN)) {l_system_data.iterations--; CGL_utils_sleep(200);}
        }
        l_system_data.iterations = CGL_utils_max(1, l_system_data.iterations);
        if(CGL_window_is_key_pressed(main_window, CGL_KEY_SPACE)) {generate_system(); CGL_utils_sleep(200);}


        if(CGL_window_get_key(main_window, CGL_KEY_ESCAPE) == CGL_PRESS) break;
    }

    CGL_widgets_shutdown();
    CGL_framebuffer_destroy(default_framebuffer);
    CGL_gl_shutdown();
    CGL_window_destroy(main_window);
    CGL_shutdown();
    return 0;
}

// Example L-system File
/*

# L-System Bushes
# Written by Paul Bourke
# Source: http://paulbourke.net/fractals/lsys/
:ANGLE 25700
# length factor will be divided by 1000 to convert to float
:LENGTH_FACTOR 850
:AXIOM Y
# star x and y will be divided by 1000 to convert to float
# coodinate system is (-1.0, -1.0) to (1.0, 1.0)
:START_X 0
:START_Y -1000
:ITERATIONS 4
# Actions are the character followed by command
# commands are:
# 1 - move forward
# 2 - rotate left
# 3 - rotate right
# 4 - push
# 5 - pop
:ACTIONS 5
F 1
+ 2
- 3
[ 4
] 5
:RULES 2
X X[-FFF][+FFF]FX
Y YFX[+Y][-Y]


*/

```

`examples/c/lorenz_system_simulation.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#define CGL_EXCLUDE_NETWORKING
#define CGL_EXCLUDE_RAY_CASTER
#define CGL_EXCLUDE_NODE_EDITOR
#define CGL_EXCLUDE_WIDGETS
#define CGL_EXCLUDE_AUDIO
#define CGL_TRAIL_MAX_POINTS 4096
#include "cgl.h"


static const char* PASS_THROUGH_VERTEX_SHADER_SOURCE = "#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 normal;\n"
"layout (location = 2) in vec4 texcoord;\n"
"\n"
"out vec3 Position;\n"
"out vec2 TexCoord;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = vec4(position.xyz, 1.0f);\n"
"	Position = position.xyz;\n"
"	TexCoord = texcoord.xy;\n"
"}";

static const char* PASS_THROUGH_FRAGMENT_SHADER_SOURCE = "#version 430 core\n"
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Position;\n"
"in vec2 TexCoord;\n"
"\n"
"uniform sampler2D u_tex;\n"
"\n"
"// Black Box From https://github.com/armory3d/armory/blob/master/Shaders/std/tonemap.glsl\n"
"vec3 acesFilm(const vec3 x) {\n"
"    const float a = 2.51;\n"
"    const float b = 0.03;\n"
"    const float c = 2.43;\n"
"    const float d = 0.59;\n"
"    const float e = 0.14;\n"
"    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	vec3 color = texture(u_tex, vec2(TexCoord.y, 1.0f - TexCoord.x)).rgb;\n"
"	color = acesFilm(color);\n"
"   color = pow(color, vec3(1.0f / 2.2f));\n"
"	FragColor = vec4(color, 1.0f);\n"
"}";


static const char* TRAIL_VERTEX_SHADER = "#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n" // w is lifespan
"layout (location = 1) in vec4 normal;\n" // w is distance
"layout (location = 2) in vec4 texcoord;\n" // zw is reserved for future use
"\n"
"out vec3 Position;\n"
"out vec2 TexCoord;\n"
"out float Distance;\n"
"out float Life;\n"
"\n"
"uniform mat4 projection;\n"
"uniform mat4 view;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = projection * view * vec4(position.xyz, 1.0f);\n"
"	Position = position.xyz;\n"
"	TexCoord = texcoord.xy;\n"
"   Distance = normal.w;\n"
"   Life = position.w;\n"
"}\n";

static const char* TRAIL_FRAGMENT_SHADER = "#version 430 core\n"
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Position;\n"
"in vec2 TexCoord;\n"
"in float Distance;\n"
"in float Life;\n"
"\n"
"uniform vec3 color;\n"
"uniform float total_length;\n"
"uniform vec3 colors[10];\n"
"\n"
"void main()\n"
"{\n"
"   vec3 col = vec3(1.2, 1, 0);"
"   if      (Life < 2.0f * 1.0f)  col = colors[0];\n"
"   else if (Life < 2.0f * 2.0f)  col = colors[1];\n"
"   else if (Life < 2.0f * 3.0f)  col = colors[2];\n"
"   else if (Life < 2.0f * 4.0f)  col = colors[3];\n"
"   else if (Life < 2.0f * 5.0f)  col = colors[4];\n"
"   else if (Life < 2.0f * 6.0f)  col = colors[5];\n"
"   else if (Life < 2.0f * 7.0f)  col = colors[6];\n"
"   else if (Life < 2.0f * 8.0f)  col = colors[7];\n"
"   else if (Life < 2.0f * 9.0f)  col = colors[8];\n"
"   else if (Life < 2.0f * 10.0f) col = colors[9];\n"
"   col = col * 1.2f;\n"
"	FragColor = vec4(mix(col, vec3(0.0f), (20.0f - Life) / 20.0f), 1.0f);\n"
"}\n";

bool point_function(CGL_trail* trail, CGL_trail_point* point)
{
    point->thickness = 0.05f + 0.4f * fabsf(sinf(CGL_utils_get_time() + point->distance)) * (trail->length - point->distance) / trail->length;
    return false;
}


// Learn More About Lorenz System Here: https://en.wikipedia.org/wiki/Lorenz_system
CGL_vec3 lorenz_system_new_pos(CGL_vec3 prev_pos, CGL_float dt)
{
    float sigma = 10.0f;
    float rho = 28.0f;
    float beta = 8.0f / 3.0f;

    CGL_float dx = sigma * (prev_pos.y - prev_pos.x);
    CGL_float dy = prev_pos.x * (rho - prev_pos.z) - prev_pos.y;
    CGL_float dz = prev_pos.x * prev_pos.y - beta * prev_pos.z;

    CGL_vec3 new_pos = prev_pos;
    new_pos.x += dx * dt;
    new_pos.y += dy * dt;
    new_pos.z += dz * dt;

    return new_pos;
}

int main()
{
    srand((uint32_t)time(NULL));
    CGL_init();
    CGL_window* window = CGL_window_create(600, 600, "Lorenz system - Jaysmito Mukherjee");
    if(!window) return 1;
    CGL_window_make_context_current(window);
    CGL_gl_init();
    CGL_framebuffer* default_framebuffer = CGL_framebuffer_create_from_default(window);
    CGL_framebuffer* bloom_framebuffer = CGL_framebuffer_create(600, 600);
 
    CGL_shader* present_shader = CGL_shader_create(PASS_THROUGH_VERTEX_SHADER_SOURCE, PASS_THROUGH_FRAGMENT_SHADER_SOURCE, NULL);
    CGL_shader* trail_shader = CGL_shader_create(TRAIL_VERTEX_SHADER, TRAIL_FRAGMENT_SHADER, NULL);

    CGL_mat4 projection = CGL_mat4_perspective(CGL_deg_to_rad(45.0f), 1.0f, 0.01f, 100.0f);
    CGL_mat4 view = CGL_mat4_identity();
    CGL_bloom* bloom = CGL_bloom_create(600, 600, 3);
    CGL_float start_time = CGL_utils_get_time();
    CGL_float prev_time = start_time;

    CGL_trail* trail = CGL_trail_create();
    CGL_trail_set_min_points_distance(trail, 0.01f);
    CGL_trail_set_resolution(trail, 32);
    CGL_trail_set_point_update_function(trail, point_function);

    CGL_vec3 position = CGL_vec3_init(0.01f, 0.0f, 0.0f);
    CGL_vec3 ptmp = CGL_vec3_init(0.01f, 0.0f, 0.0f);

    CGL_vec3 colors[10];

    // colors of rainbow (i guess)
    colors[9] = CGL_vec3_init(1.0f, 0.0f, 0.0f);
    colors[8] = CGL_vec3_init(1.0f, 0.5f, 0.0f);
    colors[7] = CGL_vec3_init(1.0f, 1.0f, 0.0f);
    colors[6] = CGL_vec3_init(0.0f, 1.0f, 0.0f);
    colors[5] = CGL_vec3_init(0.0f, 0.0f, 1.0f);
    colors[4] = CGL_vec3_init(0.5f, 0.0f, 1.0f);
    colors[3] = CGL_vec3_init(1.0f, 0.0f, 1.0f);
    colors[2] = CGL_vec3_init(1.0f, 0.0f, 0.5f);
    colors[1] = CGL_vec3_init(1.0f, 0.0f, 0.0f);
    colors[0] = CGL_vec3_init(1.0f, 0.0f, 0.0f);


    

    while(!CGL_window_should_close(window))
    {
        CGL_float time = CGL_utils_get_time();
        CGL_float delta_time = time - prev_time;
        prev_time = time;
        CGL_window_set_size(window, 600, 600); // force window size to be 600x600

        ptmp = position;
        CGL_vec3_normalize(ptmp);
        ptmp = CGL_vec3_scale(ptmp, 4.0f);
        ptmp = CGL_vec3_sub(position, ptmp);

        position = lorenz_system_new_pos(position, delta_time * 0.3f);

        view = CGL_mat4_look_at(CGL_vec3_init(65.0f, 0.0f, 45.0f), position, CGL_vec3_init(0.0f, 1.0f, 0.0f));

        {
            CGL_trail_add_point(trail, position, 20.0f, 0.05f);
            CGL_trail_update(trail, delta_time);
            CGL_trail_bake_mesh(trail);
        }
        
        glEnable(GL_DEPTH_TEST);
        glDepthFunc(GL_LESS);
        CGL_framebuffer_bind(bloom_framebuffer);
        CGL_gl_clear(0.0f, 0.0f, 0.0f, 1.0f);
        CGL_shader_bind(trail_shader);
        for (int i = 0; i < 10; i++)
        {
            static char bufft[32];
            sprintf(bufft, "colors[%d]", i);
            CGL_shader_set_uniform_vec3v(trail_shader, CGL_shader_get_uniform_location(trail_shader, bufft), colors[i].x, colors[i].y, colors[i].z);
        }
        CGL_trail_render(trail, &view, &projection, trail_shader);



        CGL_bloom_apply(bloom, CGL_framebuffer_get_color_texture(bloom_framebuffer));

        CGL_framebuffer_bind(default_framebuffer);
        CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);
        CGL_shader_bind(present_shader);
        CGL_texture_bind(CGL_framebuffer_get_color_texture(bloom_framebuffer), 0);
        CGL_shader_set_uniform_int(present_shader, CGL_shader_get_uniform_location(present_shader, "u_tex"), 0);
        CGL_gl_render_screen_quad();

        CGL_window_poll_events(window);
        CGL_window_swap_buffers(window);

        if(CGL_window_is_key_pressed(window, CGL_KEY_SPACE))
        {
            //for (int i = 0; i < 10; i++) colors[i] = CGL_vec3_init(rand() % 1000 / 1000.0f, rand() % 1000 / 1000.0f, rand() % 1000 / 1000.0f);
            position = CGL_vec3_init(0.01f, 0.0f, 0.0f);
            CGL_trail_clear(trail);
        }
    }


    CGL_trail_destroy(trail);
    CGL_shader_destroy(trail_shader);
    CGL_shader_destroy(present_shader);
    CGL_framebuffer_destroy(default_framebuffer);
    CGL_framebuffer_destroy(bloom_framebuffer);
    CGL_bloom_destroy(bloom);
    CGL_gl_shutdown();
    CGL_window_destroy(window);    
    CGL_shutdown();
    return 0;
}

```

`examples/c/mandelbrot_set_viewer.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#define CGL_EXCLUDE_NETWORKING
#define CGL_EXCLUDE_RAY_CASTER
#define CGL_EXCLUDE_NODE_EDITOR
#define CGL_EXCLUDE_WIDGETS
#define CGL_EXCLUDE_AUDIO
#define CGL_TRAIL_MAX_POINTS 4096
#include "cgl.h"


static const char* PASS_THROUGH_VERTEX_SHADER_SOURCE = "#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 normal;\n"
"layout (location = 2) in vec4 texcoord;\n"
"\n"
"out vec3 Position;\n"
"out vec2 TexCoord;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = vec4(position.xyz, 1.0f);\n"
"	Position = position.xyz;\n"
"	TexCoord = vec2(position.xy);\n"
"}";

static const char* PASS_THROUGH_FRAGMENT_SHADER_SOURCE = "#version 430 core\n"
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Position;\n"
"in vec2 TexCoord;\n"
"\n"
"uniform float u_scale;\n"
"uniform vec2 u_offset;\n"
"\n"
"// Black Box From https://github.com/armory3d/armory/blob/master/Shaders/std/tonemap.glsl\n"
"vec3 acesFilm(const vec3 x) {\n"
"    const float a = 2.51;\n"
"    const float b = 0.03;\n"
"    const float c = 2.43;\n"
"    const float d = 0.59;\n"
"    const float e = 0.14;\n"
"    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n"
"}\n"
"\n"
"#define MAX_ITER 250\n"
"#define BAIL_RADIUS 100.0\n"
"\n"
"float magnitude(vec2 z)\n"
"{\n"
"    return z.x * z.x + z.y * z.y;\n"
"}\n"
"\n"
"vec2 multiply(vec2 a, vec2 b)\n"
"{\n"
"    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n"
"}\n"
"\n"
"vec3 get_color()\n"
"{\n"
"    vec2 C = (TexCoord.xy * u_scale) + u_offset;\n"
"    vec2 Z = vec2(0.0, 0.0);\n"
"    int i = 0;\n"
"    for(; i < MAX_ITER; i++)\n"
"    {\n"
"        Z = multiply(Z, Z) + C;\n"
"        if(magnitude(Z) > BAIL_RADIUS) break;\n"
"    }\n"
"    float log_zn = log(magnitude(Z)) / 2.0;\n"
"    float nu = log(log_zn / log(BAIL_RADIUS)) / log(2.0);\n"
"    float iter = float(i) + 1.0 - nu;\n"
"    float r = sqrt(iter / float(MAX_ITER));\n"
"    float g = iter / float(MAX_ITER);\n"
"    float b = sqrt(sqrt(iter / float(MAX_ITER)));\n"
"    return vec3(r, g, b);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	vec3 color = get_color();\n"
"	color = acesFilm(color);\n"
"   color = pow(color, vec3(1.0f / 2.2f));\n"
"	FragColor = vec4(color, 1.0f);\n"
"}";


int main()
{
    srand((uint32_t)time(NULL));
    CGL_init();
    CGL_window* window = CGL_window_create(600, 600, "Mandelbrot Set - Jaysmito Mukherjee");
    if(!window) return 1;
    CGL_window_make_context_current(window);
    CGL_gl_init();
    CGL_framebuffer* default_framebuffer = CGL_framebuffer_create_from_default(window);
 
    CGL_shader* present_shader = CGL_shader_create(PASS_THROUGH_VERTEX_SHADER_SOURCE, PASS_THROUGH_FRAGMENT_SHADER_SOURCE, NULL);

    CGL_float offset_x = 0.0f;
    CGL_float offset_y = 0.0f;
    CGL_float scale = 1.0f;

    while(!CGL_window_should_close(window))
    {
        CGL_window_set_size(window, 700, 700); // force window size to be 700x700

        CGL_framebuffer_bind(default_framebuffer);
        CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);
        CGL_shader_bind(present_shader);
        CGL_shader_set_uniform_vec2v(present_shader, CGL_shader_get_uniform_location(present_shader, "u_offset"), offset_x, offset_y);
        CGL_shader_set_uniform_float(present_shader, CGL_shader_get_uniform_location(present_shader, "u_scale"), scale);
        CGL_gl_render_screen_quad();

        CGL_window_poll_events(window);
        CGL_window_swap_buffers(window);

        CGL_float scale_f = CGL_utils_max(scale, 0.00001f);
        if(CGL_window_is_key_pressed(window, CGL_KEY_LEFT)) offset_x -= 0.01f * scale_f;
        if(CGL_window_is_key_pressed(window, CGL_KEY_RIGHT)) offset_x += 0.01f * scale_f;
        if(CGL_window_is_key_pressed(window, CGL_KEY_UP)) offset_y += 0.01f * scale_f;
        if(CGL_window_is_key_pressed(window, CGL_KEY_DOWN)) offset_y -= 0.01f * scale_f;
        if(CGL_window_is_key_pressed(window, CGL_KEY_EQUAL)) scale /= 1.01f;
        if(CGL_window_is_key_pressed(window, CGL_KEY_MINUS)) scale *= 1.01f;
    }


    CGL_shader_destroy(present_shader);
    CGL_framebuffer_destroy(default_framebuffer);
    CGL_gl_shutdown();
    CGL_window_destroy(window);    
    CGL_shutdown();
    return 0;
}

```

`examples/c/mandelbrot_set_viewer_high_precesion.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/


#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#define CGL_EXCLUDE_NETWORKING
#define CGL_EXCLUDE_RAY_CASTER
#define CGL_EXCLUDE_NODE_EDITOR
#include "cgl.h"

static const char* PASS_THROUGH_VERTEX_SHADER_SOURCE = "#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 normal;\n"
"layout (location = 2) in vec4 texcoord;\n"
"\n"
"out vec3 Position;\n"
"out vec2 TexCoord;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = vec4(position.xyz, 1.0f);\n"
"	Position = position.xyz;\n"
"	TexCoord = texcoord.xy;\n"
"}";

static const char* PASS_THROUGH_FRAGMENT_SHADER_SOURCE = "#version 430 core\n"
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Position;\n"
"in vec2 TexCoord;\n"
"\n"
"uniform sampler2D u_tex;\n"
"\n"
"// Black Box From https://github.com/armory3d/armory/blob/master/Shaders/std/tonemap.glsl\n"
"vec3 acesFilm(const vec3 x) {\n"
"    const float a = 2.51;\n"
"    const float b = 0.03;\n"
"    const float c = 2.43;\n"
"    const float d = 0.59;\n"
"    const float e = 0.14;\n"
"    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	vec3 color = texture(u_tex, vec2(TexCoord.y, 1.0f - TexCoord.x)).rgb;\n"
"	color = acesFilm(color);\n"
"   color = pow(color, vec3(1.0f / 2.2f));\n"
"	FragColor = vec4(color, 1.0f);\n"
"}";

static const char* JULIA_COMPUTE_SHADER = "#version 430 core\n"
"\n"
"layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;\n"
"\n"
"layout(rgba32f, binding = 0) uniform image2D output_tex;\n"
"\n"
"uniform double sc_size;\n"
"uniform double sc_res;\n"
"uniform double sc_ofx;\n"
"uniform double sc_ofy;\n"
"uniform int mode;\n"
"\n"
"#define MAX_ITER 1000\n"
"#define BAIL_RADIUS 2.0\n"
"\n"
"void main()\n"
"{\n"
"   ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);\n"
"   dvec2 psc = vec2(pixel) / sc_res * sc_size + dvec2(sc_ofx, sc_ofy);\n"
"   dvec2 c = psc;\n"
"   dvec2 z = dvec2(0.0, 0.0);\n"
"   int i = 0;\n"
"   for (; i < MAX_ITER; i++)\n"
"   {\n"
"       z = dvec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n"
"       if (z.x * z.x + z.y * z.y > BAIL_RADIUS)\n"
"           break;\n"
"   }\n"
"   float log_zn = float(log(float(z.x * z.x + z.y * z.y)) / 2.0);\n"
"   float nu = log(log_zn / log(float(BAIL_RADIUS))) / log(2.0f);\n"
"   float iter = float(i) + 1.0 - nu;\n"
"   float r = sqrt(iter / float(MAX_ITER));\n"
"   float g = iter / float(MAX_ITER);\n"
"   float b = sqrt(sqrt(iter / float(MAX_ITER)));\n"
"   imageStore(output_tex, pixel, vec4(r, g, b, 1.0f));\n"
"}\n";


#define MAP_RESOLUTION 700

static CGL_framebuffer* default_framebuffer = NULL;
static CGL_texture *output_tex = NULL;
static CGL_shader *output_tex_compute_shader = NULL, *present_shader = NULL;
static CGL_bloom *bloom = NULL;
static CGL_double scale, offset_x, offset_y;


void update_simulation()
{
    glBindImageTexture(0, output_tex->handle, 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);

    CGL_shader_bind(output_tex_compute_shader);
    CGL_shader_set_uniform_double(output_tex_compute_shader, CGL_shader_get_uniform_location(output_tex_compute_shader, "sc_size"), 1.0 / scale);
    CGL_shader_set_uniform_double(output_tex_compute_shader, CGL_shader_get_uniform_location(output_tex_compute_shader, "sc_res"), (CGL_double)MAP_RESOLUTION);
    CGL_shader_set_uniform_double(output_tex_compute_shader, CGL_shader_get_uniform_location(output_tex_compute_shader, "sc_ofx"), offset_x);
    CGL_shader_set_uniform_double(output_tex_compute_shader, CGL_shader_get_uniform_location(output_tex_compute_shader, "sc_ofy"), offset_y);
    CGL_shader_compute_dispatch(output_tex_compute_shader, MAP_RESOLUTION / 16 + 1, MAP_RESOLUTION / 16 + 1, 1);
    glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT | GL_SHADER_STORAGE_BARRIER_BIT);
}

int main()
{
    srand((uint32_t)time(NULL));
    CGL_init();
    CGL_window* window = CGL_window_create(700, 700, "Julia Set - Jaysmito Mukherjee");
    if(!window) return 1;
    CGL_window_make_context_current(window);
    CGL_gl_init();
    CGL_widgets_init();

    default_framebuffer = CGL_framebuffer_create_from_default(window);
    output_tex = CGL_texture_create_blank(MAP_RESOLUTION, MAP_RESOLUTION, GL_RGBA, GL_RGBA32F, GL_FLOAT);

    present_shader = CGL_shader_create(PASS_THROUGH_VERTEX_SHADER_SOURCE, PASS_THROUGH_FRAGMENT_SHADER_SOURCE, NULL);
    output_tex_compute_shader = CGL_shader_compute_create(JULIA_COMPUTE_SHADER, NULL);

    bloom = CGL_bloom_create(MAP_RESOLUTION, MAP_RESOLUTION, 3);

    scale = 1.0; offset_x = 0.0; offset_y = 0.0;

    CGL_float curr_time = CGL_utils_get_time();
    CGL_float prev_time = CGL_utils_get_time();
    CGL_float time = 0.0f, frame_time = 0.0f, delta_time = 0.0f;
    CGL_int frames = 0, fps = 0;

    while(!CGL_window_should_close(window))
    {
        CGL_window_set_size(window, 700, 700); // force window size to be 600x600

        curr_time = CGL_utils_get_time();
        delta_time = curr_time - prev_time;
        prev_time = curr_time;
        time += delta_time; frame_time += delta_time;
        frames++; if(frame_time >= 1.0f) { fps = frames; frames = 0; frame_time = 0.0f; }
        
        update_simulation();

        //CGL_bloom_apply(bloom, output_tex);

        CGL_framebuffer_bind(default_framebuffer);
        CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);
        CGL_shader_bind(present_shader);
        CGL_texture_bind(output_tex, 0);
        CGL_shader_set_uniform_int(present_shader, CGL_shader_get_uniform_location(present_shader, "u_tex"), 0);
        CGL_gl_render_screen_quad();

        glDisable(GL_DEPTH_TEST);

        CGL_widgets_begin();
        
        CGL_widgets_set_fill_colorf(0.0f, 0.0f, 0.0f, 1.0f);

        static CGL_byte buffer[256];
        sprintf(buffer, "Frame Time: %f", delta_time);
        CGL_widgets_add_string(buffer, -1.0f, 0.975f, 0.5f, 0.025f);
        sprintf(buffer, "Framerate : %d", fps);
        CGL_widgets_add_string(buffer, -1.0f, 0.950f, 0.5f, 0.025f);
        sprintf(buffer, "Scale : %lf", scale);
        CGL_widgets_add_string(buffer, -1.0f, 0.925f, 0.5f, 0.025f);  
        sprintf(buffer, "Resolution: %dx%d", MAP_RESOLUTION, MAP_RESOLUTION);
        CGL_widgets_add_string(buffer, -1.0f, 0.900f, 0.5f, 0.025f);
        sprintf(buffer, "Offset X: %lf", offset_x);
        CGL_widgets_add_string(buffer, -1.0f, 0.875f, 0.5f, 0.025f);
        sprintf(buffer, "Offset Y: %lf", offset_y);
        CGL_widgets_add_string(buffer, -1.0f, 0.850f, 0.5f, 0.025f);


        CGL_widgets_end();

        CGL_window_poll_events(window);
        CGL_window_swap_buffers(window);


        if(CGL_window_get_key(window, CGL_KEY_R) == CGL_PRESS)
        {
//            if(CGL_window_get_key(window, CGL_KEY_UP) == CGL_PRESS) dir_randomness += 0.01f;
//            if(CGL_window_get_key(window, CGL_KEY_DOWN) == CGL_PRESS) dir_randomness -= 0.01f;
        }
        else if(CGL_window_get_key(window, CGL_KEY_S) == CGL_PRESS)
        {
            if(CGL_window_get_key(window, CGL_KEY_UP) == CGL_PRESS) scale *= 1.005f;
            if(CGL_window_get_key(window, CGL_KEY_DOWN) == CGL_PRESS) scale *= 0.995f;
        }
        else
        {
            if(CGL_window_get_key(window, CGL_KEY_UP) == CGL_PRESS) offset_y += 0.01f / scale;
            if(CGL_window_get_key(window, CGL_KEY_DOWN) == CGL_PRESS) offset_y -= 0.01f / scale;
            if(CGL_window_get_key(window, CGL_KEY_LEFT) == CGL_PRESS) offset_x += 0.01f / scale;
            if(CGL_window_get_key(window, CGL_KEY_RIGHT) == CGL_PRESS) offset_x -= 0.01f / scale;
        }


    }


    CGL_texture_destroy(output_tex);
    CGL_shader_destroy(output_tex_compute_shader);
    CGL_shader_destroy(present_shader);
    CGL_framebuffer_destroy(default_framebuffer);
    CGL_bloom_destroy(bloom);
    CGL_widgets_shutdown();
    CGL_gl_shutdown();
    CGL_window_destroy(window);    
    CGL_shutdown();
    return 0;
}

```

`examples/c/marching_squares.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_IMPLEMENTATION
#include "cgl.h"

static CGL_window* window;
static CGL_shape shapes[1000];
static int shape_count;
static CGL_vec2 mpos;
static CGL_vec2 spheres[16];

const char* __VS_S = "#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 normal;\n"
"layout (location = 2) in vec4 texcoord;\n"
"\n"
"out vec2 Position;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = vec4(position.xy, 0.0f, 1.0f);\n"
"	Position = position.xy;\n"
"}";

const char* __FS_S = "#version 430 core\n"
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec2 Position;\n"
"\n"
"uniform vec2 c_pos;\n"
"\n"
"void main()\n"
"{\n"
"	vec4 color = vec4(1.0f, 1.0f, 1.0f , 1.0f);\n"
"	FragColor = color;\n"
"}";


float value_func(float x, float y, float r)
{
    //if((x * x + y * y) > (r * r)) return 0.0f;
    return r / (x * x + y * y);
}

bool sample_function(CGL_vec2 pos, float* value, void* user_data)
{
    float v = 0.0f;
    for (int i = 0; i < 32; i++)
    {
        float x = pos.x - spheres[i].x;
        float y = pos.y - spheres[i].y;
        v += value_func(x, y, 0.35f);
    }
    float sigma = 0.5f;
    if(CGL_window_get_mouse_button(window, CGL_MOUSE_BUTTON_LEFT) == CGL_PRESS) sigma = 2.0f;
    v += value_func(pos.x - mpos.x, pos.y - mpos.y, sigma);
    if(value) *value = v;
    return v > 45.0f;
}

int main(int argc, char** argv, char** envp)
{
    srand((uint32_t)time(NULL));
    CGL_init();
    window = CGL_window_create(700, 700, "CGL Square Marching - Jaysmito Mukherjee");
    if(window == NULL) return false; 
    CGL_window_make_context_current(window); 
    CGL_gl_init();
    CGL_widgets_init();
    CGL_framebuffer* default_framebuffer = CGL_framebuffer_create_from_default(window);
    CGL_shader* shd = CGL_shader_create(__VS_S, __FS_S, NULL);

    for(int i = 0; i < 32; i++)
    {
        spheres[i].x = CGL_utils_random_float() * 2.0f - 1.0f;
        spheres[i].y = CGL_utils_random_float() * 2.0f - 1.0f;
    }

    CGL_square_marcher* marcher = CGL_square_marcher_create();
    CGL_mesh_gpu* mesh = CGL_mesh_gpu_create();
    CGL_vec2 start = CGL_vec2_init(-1.0f, -1.0f);
    CGL_vec2 end = CGL_vec2_init(1.0f, 1.0f);

    while(!CGL_window_should_close(window)) 
    {
        int wx, wy;
        CGL_window_get_framebuffer_size(window, &wx, &wy);
        CGL_vec2 window_size = CGL_vec2_init((float)wx, (float)wy);
        double mx, my;
        CGL_window_get_mouse_position(window, &mx, &my);
        mpos = CGL_vec2_init((float)mx / window_size.x * 2.0f - 1.0f, (float)(1.0f - my / window_size.y) * 2.0f - 1.0f);

        CGL_framebuffer_bind(default_framebuffer);
        CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);


        CGL_widgets_begin();

   
        CGL_mesh_cpu* temp = CGL_square_marcher_generate_mesh(marcher, sample_function, start, end, 256, 256);
        CGL_widgets_end();
        if(temp)
        {
            CGL_mesh_gpu_upload(mesh, temp, false);
            CGL_mesh_cpu_destroy(temp);
        }
        

        CGL_shader_bind(shd);
        CGL_mesh_gpu_render(mesh);
        
        if(CGL_window_get_key(window, CGL_KEY_I) == CGL_PRESS) CGL_square_marcher_enable_interpolation(marcher, true);
        if(CGL_window_get_key(window, CGL_KEY_J) == CGL_PRESS) CGL_square_marcher_enable_interpolation(marcher, false);
        if(CGL_window_get_key(window, CGL_KEY_SPACE) == CGL_PRESS) 
        {
            for(int i = 0; i < 32; i++)
            {
                spheres[i].x = CGL_utils_random_float() * 2.0f - 1.0f;
                spheres[i].y = CGL_utils_random_float() * 2.0f - 1.0f;
            }
        }

        if(CGL_window_get_key(window, CGL_KEY_ESCAPE) == CGL_PRESS) break;

        CGL_window_swap_buffers(window);
        CGL_window_poll_events(window);
    }


    CGL_shader_destroy(shd);
    CGL_mesh_gpu_destroy(mesh);
    CGL_framebuffer_destroy(default_framebuffer);
    CGL_widgets_shutdown();
    CGL_gl_shutdown();
    CGL_window_destroy(window);
    CGL_shutdown();
    return EXIT_SUCCESS;
}

```

`examples/c/markov_text_generation.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_IMPLEMENTATION
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_EXCLUDE_NETWORKING
#define CGL_LOG printf
#include "cgl.h"


int main(int argc, char** argv)
{
    if (argc != 4)
    {
        printf("Invalid number of arguments\n");
        return -1;
    }
    // for random output on every run
    srand((uint32_t)time(NULL));


    // constants
    size_t trainer_data_size = 0;
    size_t n_gram_size = 4;


    char* trainer_data = CGL_utils_read_file(argv[1], &trainer_data_size);
    trainer_data_size = strlen(trainer_data);
    printf("trainer_data_size: %zu\n", trainer_data_size);

    // setup context
    printf("Creating Markov Context ... ");
    CGL_markov* mk = CGL_markov_create(n_gram_size, 1);
    CGL_markov_token_function_ngram_text_context* ng_ctx = CGL_markov_token_function_ngram_text_context_create(n_gram_size);
    printf("Done\n");

    // train and build data table
    printf("Training Markov Chains ... ");
    CGL_markov_train(mk, ng_ctx, trainer_data, trainer_data_size, CGL_markov_token_function_ngram_text);
    printf("Done\n");

    // free ngram context (only required for training)
    CGL_markov_token_function_ngram_text_context_destroy(ng_ctx);

    // prepare for generation
    size_t count = atoi(argv[2]);
    static char temp_buffer[4096];
    memset(temp_buffer, 0, sizeof(temp_buffer));
    static char temp_buffer2[4];
    memset(temp_buffer2, 0, sizeof(temp_buffer2));
    sprintf(temp_buffer, argv[3]);

    const char* key = temp_buffer + (strlen(argv[3]) == n_gram_size ? 0 : (strlen(argv[3]) - n_gram_size));

    // generate data
    printf("Generating Text ... ");
    while((count--) > 0 && CGL_markov_generate(mk, key++, temp_buffer2)) strcat(temp_buffer, temp_buffer2);
    printf("Done\n");
    printf("Generated text is : \n%s", temp_buffer);

    // destroy context
    CGL_markov_destroy(mk);
    CGL_free(trainer_data);

    return 0;
}

```

`examples/c/menger_sponge_fractal.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#define CGL_EXCLUDE_NETWORKING
#define CGL_EXCLUDE_AUDIO
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_EXCLUDE_RAY_CASTER
#define CGL_EXCLUDE_NODE_EDITOR
#include "cgl.h"

#ifdef CGL_WASM
#include <emscripten/emscripten.h>
#include <emscripten/html5.h>
#else 
#define EM_BOOL int
#endif

static const char* PASS_THROUGH_VERTEX_SHADER_SOURCE = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
"in vec4 position;\n"
"in vec4 normal;\n"
"in vec4 texcoord;\n"
#else
"#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 normal;\n"
"layout (location = 2) in vec4 texcoord;\n"
#endif
"\n"
"out vec3 Position;\n"
"out vec2 TexCoord;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = vec4(position.xyz, 1.0f);\n"
"	Position = position.xyz;\n"
"	TexCoord = texcoord.xy;\n"
"}";

static const char* PASS_THROUGH_FRAGMENT_SHADER_SOURCE = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
#else
"#version 430 core\n"
#endif
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Position;\n"
"in vec2 TexCoord;\n"
"\n"
"uniform sampler2D u_tex;\n"
"\n"
"// Black Box From https://github.com/armory3d/armory/blob/master/Shaders/std/tonemap.glsl\n"
"vec3 acesFilm(const vec3 x) {\n"
"    const float a = 2.51;\n"
"    const float b = 0.03;\n"
"    const float c = 2.43;\n"
"    const float d = 0.59;\n"
"    const float e = 0.14;\n"
"    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	vec3 color = texture(u_tex, vec2(TexCoord.y, 1.0f - TexCoord.x)).rgb;\n"
"	color = acesFilm(color);\n"
"   color = pow(color, vec3(1.0f / 2.2f));\n"
"	FragColor = vec4(color, 1.0f);\n"
"}";

const CGL_byte* DIFFUSE_VERTEX_SHADER_SOURCE = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
"\n"
"in vec4 position;\n"
"in vec4 normal;\n"
"in vec4 texcoord;\n"
#else
"#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 normal;\n"
"layout (location = 2) in vec4 texcoord;\n"
#endif
"\n"
"out vec3 Position;\n"
"out vec3 Normal;\n"
"out vec3 Color;\n"
"out vec2 TexCoord;\n"
"\n"
"uniform mat4 view_proj;\n"
"uniform float u_scale;\n"
"\n"
"void main()\n"
"{\n"
"   vec3 pos = position.xyz * u_scale;\n"
"	gl_Position = view_proj * vec4(pos, 1.0f);\n"
"	Position = position.xyz;\n"
"	Normal = normal.xyz;\n"
"	TexCoord = texcoord.xy;\n"
"   Color = vec3(0.4f);\n"
"   Color = Normal * 0.5f + vec3(0.5f);"
"   float scale_factor = u_scale;\n"
"   if(pos.x >= scale_factor || pos.y >= scale_factor || pos.z >= scale_factor || pos.x <= -scale_factor || pos.y <= -scale_factor || pos.z <= -scale_factor)\n"
"   {\n"
"       Color = vec3(1.0f);\n"
"   }\n"
"   Color *= 0.6f;\n"
"}";

const CGL_byte* DIFFUSE_FRAGMENT_SHADER_SOURCE = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
#else
"#version 430 core\n"
#endif
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Position;\n"
"in vec3 Normal;\n"
"in vec3 Color;\n"
"in vec2 TexCoord;\n"
"\n"
"uniform vec3 u_light_pos;\n"
"\n"
"void main()\n"
"{\n"
"	vec3 object_color = Color;\n"
"	vec3 light_color = vec3(1.0f, 1.0f, 1.0f);\n"
"	vec3 light_dir = normalize(u_light_pos - Position);\n"
"	float diffuse = max(dot(Normal, light_dir), 0.0f) + 0.18f;\n"
"	vec3 result = (diffuse * light_color) * object_color;\n"
"	FragColor = vec4(result, 1.0f);\n"
"}";


// Game state structure
struct {
    CGL_window* window;
    CGL_framebuffer *default_framebuffer, *bloom_framebuffer;
    CGL_shader *present_shader, *diffuse_shader;
    CGL_mesh_gpu *mesh;
    CGL_float curr_time;
    CGL_float prev_time;
    CGL_float delta_time;
    CGL_float time;
    CGL_float frame_time;
    CGL_float obj_scale;
    CGL_int frames;
    CGL_int fps;
    CGL_int subdiv_level;
    CGL_bool inverted_menger;
    CGL_mat4 projection;
    CGL_mat4 view;
#ifndef CGL_WASM
    CGL_bloom* bloom;
#endif
} g_State;

CGL_mesh_cpu* generate_menger_unit(CGL_mesh_cpu* base_mesh, CGL_bool invert)
{
    CGL_mesh_cpu* mesh_cpu = CGL_mesh_cpu_create(base_mesh->vertex_count_used * 27, base_mesh->index_count_used * 27);
    for(int x = 0 ; x < 3 ; x++)
    {
        for(int y = 0 ; y < 3 ; y++)
        {
            for(CGL_int z = 0; z < 3; z++)
            {
                CGL_bool cond = abs(x - 1) +  abs(y - 1) + abs(z - 1) > 1;
                if(invert ? !cond : cond) CGL_mesh_cpu_add_mesh(mesh_cpu, base_mesh);
                CGL_mesh_cpu_offset_vertices(mesh_cpu, CGL_vec3_init(0.0f, 0.0f, 2.0f));
            }
            CGL_mesh_cpu_offset_vertices(mesh_cpu, CGL_vec3_init(0.0f, 2.0f, -3.0f * 2.0f));
        }
        CGL_mesh_cpu_offset_vertices(mesh_cpu, CGL_vec3_init(2.0f, -3.0f * 2.0f, 0.0f));
    }
    CGL_mesh_cpu_offset_vertices(mesh_cpu, CGL_vec3_init(-4.0f, 2.0f, 2.0f));
    return mesh_cpu;
}

CGL_mesh_gpu* generate_menger_item(CGL_int sub_div, CGL_bool invert)
{
    CGL_info("Generating menger sponge with %d subdivisions ...", sub_div);
    //CGL_mesh_cpu* base_mesh = CGL_mesh_cpu_cube(false);
    CGL_mesh_cpu* base_mesh = CGL_mesh_cpu_cube(false);
    for(int i = 0 ; i < sub_div ; i++)
    {
        CGL_info("Subdividing %d/%d", i + 1, sub_div);
        CGL_mesh_cpu* mesh_cpu = generate_menger_unit(base_mesh, invert);
        CGL_mesh_cpu_destroy(base_mesh);
        base_mesh = mesh_cpu;
        CGL_mesh_cpu_scale_vertices(base_mesh, 1.0f / 3.0f);
    }
    CGL_info("Recalculating normals ...");
    CGL_mesh_cpu_recalculate_normals(base_mesh);
    CGL_info("Uploading to GPU ...");
    CGL_mesh_gpu* mesh_gpu = CGL_mesh_gpu_create();
    CGL_mesh_gpu_upload(mesh_gpu, base_mesh, false);
    CGL_mesh_cpu_destroy(base_mesh);
    CGL_info("Done");
    return mesh_gpu;    
}

CGL_bool init()
{
    srand((uint32_t)time(NULL));
    if(!CGL_init()) return CGL_FALSE;
    
    g_State.window = CGL_window_create(700, 700, "Meneger Sponge Fractal - Jaysmito Mukherjee");
    if(!g_State.window) return CGL_FALSE;
    
    CGL_window_make_context_current(g_State.window);
    if(!CGL_gl_init()) return CGL_FALSE;
    CGL_widgets_init();

    g_State.default_framebuffer = CGL_framebuffer_create_from_default(g_State.window);
    g_State.bloom_framebuffer = CGL_framebuffer_create_basic(700, 700);

    g_State.present_shader = CGL_shader_create(PASS_THROUGH_VERTEX_SHADER_SOURCE, PASS_THROUGH_FRAGMENT_SHADER_SOURCE, NULL);
    g_State.diffuse_shader = CGL_shader_create(DIFFUSE_VERTEX_SHADER_SOURCE, DIFFUSE_FRAGMENT_SHADER_SOURCE, NULL);

    g_State.mesh = generate_menger_item(0, false);

#ifndef CGL_WASM
    g_State.bloom = CGL_bloom_create(700, 700, 3);
    CGL_bloom_set_threshold(g_State.bloom, 1.0f);
    CGL_bloom_set_offset(g_State.bloom, 3.0f, 3.0f);
#endif

    // Initialize state variables
    g_State.curr_time = CGL_utils_get_time();
    g_State.prev_time = CGL_utils_get_time();
    g_State.delta_time = 0.0f;
    g_State.time = 0.0f;
    g_State.frame_time = 0.0f;
    g_State.obj_scale = 3.0f;
    g_State.frames = 0;
    g_State.fps = 0;
    g_State.subdiv_level = 0;
    g_State.inverted_menger = false;
    
    g_State.projection = CGL_mat4_perspective(CGL_deg_to_rad(45.0f), 1.0f, 0.01f, 100.0f);
    g_State.view = CGL_mat4_identity();

    return CGL_TRUE;
}

void cleanup()
{
#ifndef CGL_WASM
    CGL_bloom_destroy(g_State.bloom);
#endif
    CGL_shader_destroy(g_State.diffuse_shader);
    CGL_shader_destroy(g_State.present_shader);
    CGL_mesh_gpu_destroy(g_State.mesh);
    CGL_framebuffer_destroy(g_State.bloom_framebuffer);
    CGL_framebuffer_destroy(g_State.default_framebuffer);
    CGL_widgets_shutdown();
    CGL_gl_shutdown();
    CGL_window_destroy(g_State.window);    
    CGL_shutdown();
}

EM_BOOL loop(double time, void* userData)
{
    (void)time;
    (void)userData;

    CGL_window_set_size(g_State.window, 700, 700);

    CGL_vec3 camera_position = CGL_vec3_init(sinf(g_State.time * 0.3f) * 20.0f, 
        (cosf(g_State.time * 0.3f) + sinf(g_State.time * 0.3f)) / 1.414f * 20.0f, 
        cosf(g_State.time * 0.3f) * 20.0f);
    g_State.view = CGL_mat4_look_at(camera_position, CGL_vec3_init(0.0f, 0.0f, 0.0f), CGL_vec3_init(0.0f, 1.0f, 0.0f));
    g_State.view = CGL_mat4_mul(g_State.projection, g_State.view);

    g_State.curr_time = CGL_utils_get_time();
    g_State.delta_time = g_State.curr_time - g_State.prev_time;
    g_State.prev_time = g_State.curr_time;
    g_State.time += g_State.delta_time;
    g_State.frame_time += g_State.delta_time;
    g_State.frames++;
    if(g_State.frame_time >= 1.0f) { 
        g_State.fps = g_State.frames; 
        g_State.frames = 0; 
        g_State.frame_time = 0.0f; 
    }

    static CGL_bool prev_inv = false;
    static CGL_int prev_subdiv = 0;
    if(g_State.inverted_menger != prev_inv || g_State.subdiv_level != prev_subdiv)
    {
        CGL_mesh_gpu_destroy(g_State.mesh);
        g_State.mesh = generate_menger_item(g_State.subdiv_level, g_State.inverted_menger);
        prev_inv = g_State.inverted_menger;
        prev_subdiv = g_State.subdiv_level;
    }

    // Render scene
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LESS);

    // ... rest of rendering code ...
    CGL_framebuffer_bind(g_State.bloom_framebuffer);
    CGL_gl_clear(0.0f, 0.0f, 0.0f, 1.0f);
    CGL_shader_bind(g_State.diffuse_shader);
    CGL_shader_set_uniform_mat4(g_State.diffuse_shader, CGL_shader_get_uniform_location(g_State.diffuse_shader, "view_proj"), &g_State.view);
    CGL_shader_set_uniform_vec3v(g_State.diffuse_shader, CGL_shader_get_uniform_location(g_State.diffuse_shader, "u_light_pos"), camera_position.x, camera_position.y, camera_position.z);
    CGL_shader_set_uniform_float(g_State.diffuse_shader, CGL_shader_get_uniform_location(g_State.diffuse_shader, "u_scale"), g_State.obj_scale);
    CGL_mesh_gpu_render(g_State.mesh);

#ifndef CGL_WASM
    CGL_bloom_apply(g_State.bloom, CGL_framebuffer_get_color_texture(g_State.bloom_framebuffer));
#endif

    // ... rest of rendering and UI code ...
    CGL_framebuffer_bind(g_State.default_framebuffer);
    CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);
    CGL_shader_bind(g_State.present_shader);
    CGL_texture_bind(CGL_framebuffer_get_color_texture(g_State.bloom_framebuffer), 0);
    CGL_shader_set_uniform_int(g_State.present_shader, CGL_shader_get_uniform_location(g_State.present_shader, "u_tex"), 0);
    CGL_gl_render_screen_quad();

    // Handle input and UI
    if(CGL_window_is_key_pressed(g_State.window, CGL_KEY_UP)) { g_State.subdiv_level++; CGL_utils_sleep(300); }
    if(CGL_window_is_key_pressed(g_State.window, CGL_KEY_DOWN)) { g_State.subdiv_level--; CGL_utils_sleep(300); }
    g_State.subdiv_level = CGL_utils_clamp(g_State.subdiv_level, 0, 8);

    if(CGL_window_is_key_pressed(g_State.window, CGL_KEY_SPACE)) { g_State.inverted_menger = !g_State.inverted_menger; CGL_utils_sleep(100); }

    if(CGL_window_is_key_pressed(g_State.window, CGL_KEY_RIGHT)) { g_State.obj_scale += 0.01f;}
    if(CGL_window_is_key_pressed(g_State.window, CGL_KEY_LEFT)) { g_State.obj_scale -= 0.01f;}
    g_State.obj_scale = CGL_utils_clamp(g_State.obj_scale, 0.01f, 10.0f);

    CGL_window_poll_events(g_State.window);
    CGL_window_swap_buffers(g_State.window);

    return !CGL_window_should_close(g_State.window);
}

int main()
{
    if(!init()) return 1;

#ifdef CGL_WASM
    CGL_info("Running in WASM mode");
    emscripten_request_animation_frame_loop(loop, NULL);
#else
    while (!CGL_window_should_close(g_State.window)) {
        loop(0, NULL);
    }
    cleanup();
#endif

    return 0;
}

```

`examples/c/neopeed.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/


#define CGL_LOGGING_ENABLED
#define CGL_EXCLUDE_AUDIO
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_EXCLUDE_NETWORKING
#define CGL_IMPLEMENTATION
#include "cgl.h"

#ifdef CGL_WASM
#include <emscripten/emscripten.h>
#include <emscripten/html5.h>
#else
#define EM_BOOL int
#endif

static const char* VS_diffuse = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
"\n"
"in vec4 aPos;\n"
"in vec4 aNormal;\n"
"in vec4 aTexCoords;\n"
#else
"#version 430 core\n"
"layout(location = 0) in vec4 aPos;\n"
"layout(location = 1) in vec4 aNormal;\n"
"layout(location = 2) in vec4 aTexCoords;\n"
#endif
"\n"
"out vec3 FragPos;\n"
"out vec3 Normal;\n"
"out vec2 TexCoords;\n"
"\n"
"uniform mat4 model;\n"
"uniform mat4 view;\n"
"uniform mat4 projection;\n"
"\n"
"void main()\n"
"{\n"
"    mat4 model_view = view * model;\n"
"    FragPos = vec3(model * aPos);\n"
"    Normal = mat3(transpose(inverse(model_view))) * aNormal.xyz;\n"
"    TexCoords = aTexCoords.xy;\n"
"    gl_Position = projection * model_view * vec4(aPos.xyz, 1.0f);\n"
"}\n";

static const char* FS_diffuse = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
#else
"#version 430 core\n"
#endif
"in vec3 FragPos;\n"
"in vec3 Normal;\n"
"in vec2 TexCoords;\n"
"\n"
"layout(location = 0) out vec4 FragColor;\n"
"layout(location = 1) out vec4 AlbedoOut;\n"
"layout(location = 2) out vec4 NormalOut;\n"
"\n"
"uniform vec3 lightPos;\n"
"uniform vec3 objectColor;\n"
"\n"
"void main()\n"
"{\n"
"    //FragColor = vec4(1.0);return;\n"
"    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n"
"    vec3 objectColor = pow(objectColor, vec3(2.2f));\n"
"\n"
"    vec3 ambient = 0.1f * lightColor;\n"
"\n"
"    vec3 norm = normalize(Normal);\n"
"    vec3 lightDir = normalize(lightPos - FragPos);\n"
"    float diff = max(dot(norm, lightDir), 0.0);\n"
"    vec3 diffuse = diff * lightColor;\n"
"\n"
"    vec3 result = (ambient + diffuse) * objectColor;\n"
"    FragColor = vec4(result, 1.0);\n"
"    AlbedoOut = vec4(objectColor, 1.0);\n"
"    NormalOut = vec4(norm, 1.0);\n"
"}\n";

static const char* VS_presentation = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
"\n"
"in vec4 aPos;\n"
"in vec4 aNormal;\n"
"in vec4 aTexCoords;\n"
#else
"#version 430 core\n"
"layout(location = 0) in vec4 aPos;\n"
"layout(location = 1) in vec4 aNormal;\n"
"layout(location = 2) in vec4 aTexCoords;\n"
#endif
"\n"
"out vec2 TexCoords;\n"
"\n"
"void main()\n"
"{\n"
"    TexCoords = aTexCoords.xy;\n"
"    gl_Position = vec4(aPos.xy, 0.1f, 1.0f);\n"
"}\n";

static const char* FS_presentation = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
#else
"#version 430 core\n"
#endif
"in vec2 TexCoords;\n"
"\n"
"vec3 aces_tonemap(vec3 x){	\n"
"	const float a = 2.51f;\n"
"    const float b = 0.03f;\n"
"    const float c = 2.43f;\n"
"    const float d = 0.59f;\n"
"    const float e = 0.14f;\n"
"    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0f, 1.0f);\n"
"}\n"
"\n"
"out vec4 FragColor;\n"
"\n"
"uniform sampler2D texture_scene;\n"
"\n"
"void main()\n"
"{\n"
"    vec2 uv = vec2(TexCoords.y, 1.0f - TexCoords.x);\n"
"    vec3 scene = texture(texture_scene, uv).rgb;\n"
"    scene = aces_tonemap(scene);\n"
"    FragColor = vec4(scene, 1.0);\n"
"}\n";

#define OBJ_TYPE_ENEMY 1
#define OBJ_TYPE_SCORE 2

typedef struct
{
    CGL_vec3 position;
    CGL_vec3 color;
    CGL_int type;
    CGL_bool set;
}  interactable_object;

static struct
{
    interactable_object objects[100];
    CGL_mesh_gpu* model;
    CGL_shader* diffuse_shader;
    CGL_shader* presentation_shader;
} g_resources;

static struct {
    CGL_window* window;
    CGL_framebuffer* default_framebuffer;
    CGL_framebuffer* g_buffer;
    
    CGL_mat4 projection;
    CGL_mat4 view;
    CGL_float player_x;
    CGL_float player_y;
    CGL_float prev_time;
    CGL_float curr_time;
    CGL_float start_time;
    CGL_float delta_time;
    CGL_float last_add_time;
    CGL_int score;
    CGL_float intensity;

#ifndef CGL_WASM
    CGL_bloom* bloom;
#endif
} g_state;

static CGL_float distance_traveled = 0.0f;
static CGL_float game_speed = 0.05f;
static CGL_int frame_number = 0;

void load_resources()
{
    for(int i = 0 ; i < 100 ; i++) g_resources.objects[i].set = false;

    CGL_mesh_cpu* model_cpu = CGL_mesh_cpu_cube(false);
    CGL_mesh_cpu_recalculate_normals(model_cpu);
    g_resources.model = CGL_mesh_gpu_create();
    CGL_mesh_gpu_upload(g_resources.model, model_cpu, true);
    CGL_mesh_cpu_destroy(model_cpu);

    // load the shaders
    g_resources.diffuse_shader = CGL_shader_create(VS_diffuse, FS_diffuse, NULL);
    g_resources.presentation_shader = CGL_shader_create(VS_presentation, FS_presentation, NULL);
}

void free_resources()
{
    CGL_mesh_gpu_destroy(g_resources.model);
    // free the shaders
    CGL_shader_destroy(g_resources.diffuse_shader);
    CGL_shader_destroy(g_resources.presentation_shader);
}

void add_object()
{
    int type = CGL_utils_random_int(0, 100);
    for(int i = 0 ; i < 100 ; i++)
    {
        if(!g_resources.objects[i].set)
        {
            g_resources.objects[i].set = true;
            g_resources.objects[i].position = CGL_vec3_init(CGL_utils_random_float() * 6.0f - 3.0f, 0.5f, -100.0f);
            if(type % 5 == 0) g_resources.objects[i].color = CGL_vec3_init(1.2f, CGL_utils_random_float() * 0.3f + 0.3f,  CGL_utils_random_float() * 0.3f + 0.3f); // enemy
            else g_resources.objects[i].color = CGL_vec3_init(CGL_utils_random_float() * 0.3f + 0.3f,  CGL_utils_random_float() * 0.3f + 0.3f, 1.2f); // score
            g_resources.objects[i].type = type;
            return;
        }
    }
}

CGL_int update_objects(float player_x)
{
    for(int i = 0 ; i < 100 ; i++)
    {
        g_resources.objects[i].position.z += game_speed;
        if(g_resources.objects[i].set) if(g_resources.objects[i].position.z > 10) g_resources.objects[i].set = false;
        if(!g_resources.objects[i].set) continue;
        if(g_resources.objects[i].position.z > -1.0f && fabsf(g_resources.objects[i].position.x - player_x) < 1.9f)
        {
            g_resources.objects[i].set = false;
            return g_resources.objects[i].type;
        }
    }
    return -1;
}

void render_objects()
{    
    CGL_mat4 model = CGL_mat4_identity();
    CGL_mat4 temp = CGL_mat4_identity();
    for(int i = 0 ; i < 100 ; i++)
    {
        if(!g_resources.objects[i].set) continue;
        model = CGL_mat4_translate(g_resources.objects[i].position.x, g_resources.objects[i].position.y, g_resources.objects[i].position.z);
        temp = CGL_mat4_scale(0.5f, 0.5f, 0.5f);
        model = CGL_mat4_mul(model, temp);
        CGL_shader_set_uniform_mat4(g_resources.diffuse_shader, CGL_shader_get_uniform_location(g_resources.diffuse_shader, "model"), &model);
        CGL_shader_set_uniform_vec3v(g_resources.diffuse_shader, CGL_shader_get_uniform_location(g_resources.diffuse_shader, "objectColor"), g_resources.objects[i].color.x, g_resources.objects[i].color.y, g_resources.objects[i].color.z);
        CGL_mesh_gpu_render(g_resources.model);
    }
}

void clear_all()
{
    for(int i = 0 ; i < 100 ; i++) g_resources.objects[i].set = false;    
}

void init()
{
    srand((uint32_t)time(NULL));
    CGL_init();
    g_state.window = CGL_window_create(700, 700, "Neopeed - Jaysmito Mukherjee");
    CGL_window_make_context_current(g_state.window);
    CGL_gl_init();
    g_state.default_framebuffer = CGL_framebuffer_create_from_default(g_state.window);   
    g_state.g_buffer = CGL_framebuffer_create_basic(700, 700);
#ifndef CGL_WASM
    CGL_framebuffer_add_color_attachment(g_state.g_buffer, CGL_texture_create_blank(700, 700, GL_RGBA, GL_RGBA, GL_FLOAT));
    CGL_framebuffer_add_color_attachment(g_state.g_buffer, CGL_texture_create_blank(700, 700, GL_RGBA, GL_RGBA, GL_FLOAT));
#endif
    CGL_widgets_init();

#ifndef CGL_WASM
    CGL_toon_post_processor_init();
    g_state.bloom = CGL_bloom_create(700, 700, 3);
    CGL_bloom_set_offset(g_state.bloom, 10.0f, 8.0f);
#endif

    g_state.intensity = 1.15f;
    g_state.player_x = 0.0f;
    g_state.player_y = 0.0f;
    g_state.curr_time = CGL_utils_get_time();
    g_state.prev_time = g_state.curr_time;
    g_state.start_time = g_state.curr_time;
    g_state.delta_time = 0.0f;
    g_state.last_add_time = g_state.curr_time;
    g_state.score = 0;

    load_resources();
}

void cleanup()
{
    free_resources();
#ifndef CGL_WASM
    CGL_bloom_destroy(g_state.bloom);
    CGL_toon_post_processor_shutdown();
#endif
    CGL_widgets_shutdown();
    CGL_framebuffer_destroy(g_state.g_buffer);
    CGL_framebuffer_destroy(g_state.default_framebuffer);
    CGL_gl_shutdown();
    CGL_window_destroy(g_state.window);
    CGL_shutdown();
}

void loop()
{
    g_state.curr_time = CGL_utils_get_time();
    g_state.delta_time = g_state.curr_time - g_state.prev_time;
    g_state.prev_time = g_state.curr_time;
    frame_number++;

    CGL_int wx, wy;
    CGL_window_get_framebuffer_size(g_state.window, &wx, &wy);
    g_state.projection = CGL_mat4_perspective(CGL_deg_to_rad(45.0f), (CGL_float)wx/wy, 0.01f, 100.0f);
    g_state.view = CGL_mat4_look_at(CGL_vec3_init(0.0f, 8.0f, 12.0f), CGL_vec3_init(g_state.player_x, 0.5f, -3.0f + g_state.player_y), CGL_vec3_init(0.0f, 1.0f, 0.0f));

    // Update game state
    distance_traveled += game_speed;
    CGL_float tt = (g_state.curr_time - g_state.start_time - 0.2f) / (1.38f - 0.2f);
    game_speed = powf((0.2f + (1.38f - 0.2f) * 2.0f * atanf(tt * CGL_PI * 0.5f) / CGL_PI) * 0.5f, 1.5f);
    if(g_state.score < 0) game_speed = 0.0f;
    if((g_state.curr_time - g_state.last_add_time) >= 0.5f) { add_object(); g_state.last_add_time = g_state.curr_time; }
    CGL_int obj_type = update_objects(g_state.player_x);
    if(obj_type >= 0)
    {
        if(obj_type % 5 == 0) g_state.score -= (CGL_int)(distance_traveled * 0.1f);
        else g_state.score += 10;
    }
    // scene render pass
    {
        // setup pipeline
        glEnable(GL_DEPTH_TEST);
        glDepthFunc(GL_LESS);
        glDisable(GL_BLEND);
        CGL_framebuffer_bind(g_state.g_buffer);
        CGL_gl_clear(0.0f, 0.0f, 0.0f, 1.0f);
        CGL_shader_bind(g_resources.diffuse_shader);            
        CGL_shader_set_uniform_mat4(g_resources.diffuse_shader, CGL_shader_get_uniform_location(g_resources.diffuse_shader, "projection"), &g_state.projection);
        CGL_shader_set_uniform_mat4(g_resources.diffuse_shader, CGL_shader_get_uniform_location(g_resources.diffuse_shader, "view"), &g_state.view);
        CGL_shader_set_uniform_vec3v(g_resources.diffuse_shader, CGL_shader_get_uniform_location(g_resources.diffuse_shader, "lightPos"), 0.0f, 3.0f, 5.0f); // global light
        // render ground
        CGL_mat4 model = CGL_mat4_scale(5.0f, 1.0f, 1000.0f);
        CGL_mat4 temp = CGL_mat4_translate(0.0f, -1.0f, 0.0f);
        model = CGL_mat4_mul(model, temp);
        CGL_shader_set_uniform_mat4(g_resources.diffuse_shader, CGL_shader_get_uniform_location(g_resources.diffuse_shader, "model"), &model);
        CGL_shader_set_uniform_vec3v(g_resources.diffuse_shader, CGL_shader_get_uniform_location(g_resources.diffuse_shader, "objectColor"), 0.5f * g_state.intensity, 0.5f * g_state.intensity, 0.5f * g_state.intensity);
        CGL_mesh_gpu_render(g_resources.model);
        // render side walls
        for (int i = 0; i < 25 ;i++)
        {
            CGL_float zdist = i * 10.0f - distance_traveled;
            zdist = -(zdist - floorf(zdist / 250.0f) * 250.0f);
            zdist += 10.0f;
            CGL_float tmp = -i * 10.0f;
            CGL_float height = sinf(tmp * 0.05f) * sinf(tmp * 0.05f) * 3.0f + 1.5f;

            CGL_shader_set_uniform_vec3v(g_resources.diffuse_shader, CGL_shader_get_uniform_location(g_resources.diffuse_shader, "objectColor"), 0.5f * g_state.intensity, 0.5f * g_state.intensity, 0.5f * g_state.intensity);                
            model = CGL_mat4_translate(-5.5f, -1.0f, zdist);
            temp = CGL_mat4_scale(1.0f, height, 1.0f);
            model = CGL_mat4_mul(model, temp);
            CGL_shader_set_uniform_mat4(g_resources.diffuse_shader, CGL_shader_get_uniform_location(g_resources.diffuse_shader, "model"), &model);
            CGL_mesh_gpu_render(g_resources.model);

            model = CGL_mat4_translate(5.5f, -1.0f, zdist);
            temp = CGL_mat4_scale(1.0f, height, 1.0f);
            model = CGL_mat4_mul(model, temp);
            CGL_shader_set_uniform_mat4(g_resources.diffuse_shader, CGL_shader_get_uniform_location(g_resources.diffuse_shader, "model"), &model);
            CGL_mesh_gpu_render(g_resources.model);

            CGL_shader_set_uniform_vec3v(g_resources.diffuse_shader, CGL_shader_get_uniform_location(g_resources.diffuse_shader, "objectColor"), 1.2f * g_state.intensity, 1.0f * g_state.intensity, 0.3f * g_state.intensity);
            model =  CGL_mat4_translate(5.5f, height, zdist); 
            temp = CGL_mat4_scale(0.2f, 0.2f, 0.2f);
            model = CGL_mat4_mul(model, temp);
            CGL_shader_set_uniform_mat4(g_resources.diffuse_shader, CGL_shader_get_uniform_location(g_resources.diffuse_shader, "model"), &model);
            CGL_mesh_gpu_render(g_resources.model);

            model =  CGL_mat4_translate(-5.5f, height, zdist); 
            temp = CGL_mat4_scale(0.2f, 0.2f, 0.2f);
            model = CGL_mat4_mul(model, temp);
            CGL_shader_set_uniform_mat4(g_resources.diffuse_shader, CGL_shader_get_uniform_location(g_resources.diffuse_shader, "model"), &model);
            CGL_mesh_gpu_render(g_resources.model);

        }

        render_objects();

        // render the player
        model = CGL_mat4_translate(g_state.player_x, 0.5f, 0.0f);
        CGL_shader_set_uniform_mat4(g_resources.diffuse_shader, CGL_shader_get_uniform_location(g_resources.diffuse_shader, "model"), &model);
        CGL_shader_set_uniform_vec3v(g_resources.diffuse_shader, CGL_shader_get_uniform_location(g_resources.diffuse_shader, "objectColor"), 0.2f * g_state.intensity, 1.0f * g_state.intensity, 0.2f * g_state.intensity);
        CGL_mesh_gpu_render(g_resources.model);
    }
    // post process pass
    {
#ifndef CGL_WASM
        CGL_toon_post_processor_process_shades(CGL_framebuffer_get_color_attachment(g_state.g_buffer, 0), CGL_framebuffer_get_color_attachment(g_state.g_buffer, 0), CGL_framebuffer_get_color_attachment(g_state.g_buffer, 1), 3);
        CGL_toon_post_processor_process_outline(CGL_framebuffer_get_color_attachment(g_state.g_buffer, 0), CGL_framebuffer_get_color_attachment(g_state.g_buffer, 0), CGL_framebuffer_get_color_attachment(g_state.g_buffer, 2), CGL_framebuffer_get_depth_texture(g_state.g_buffer), 0.5f);
        CGL_bloom_apply(g_state.bloom, CGL_framebuffer_get_color_attachment(g_state.g_buffer, 0));
#endif
    }
    // presentation pass
    {
        glDisable(GL_DEPTH_TEST);
        glEnable(GL_BLEND);
        CGL_framebuffer_bind(g_state.default_framebuffer);
        CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);
        CGL_shader_bind(g_resources.presentation_shader);
        CGL_texture_bind(CGL_framebuffer_get_color_attachment(g_state.g_buffer, 0), 0);
        CGL_shader_set_uniform_int(g_resources.presentation_shader, CGL_shader_get_uniform_location(g_resources.presentation_shader, "texture_scene"), 0);
        CGL_gl_render_screen_quad();
        CGL_widgets_begin();
        CGL_widgets_set_fill_colorf(0.8f, 0.8f, 0.6f, 1.0f);
        static char buffer[256];
        if(g_state.score >= 0)
        {
            sprintf(buffer, "Distance : %d", (CGL_int)(distance_traveled * 0.1f));
            CGL_widgets_add_string(buffer, -1.0f, 0.9f, 1.0f, 0.1f);
            sprintf(buffer, "Score : %d", g_state.score);
            CGL_widgets_add_string(buffer, -1.0f, 0.8f, 1.0f, 0.1f);
        }
        else
        {
            CGL_widgets_set_fill_colorf(0.9f, 0.2f, 0.2f, 1.0f);
            sprintf(buffer, "Game Over");
            CGL_widgets_add_string(buffer, -0.7f, 0.0f, 1.4f, 0.5f);
            sprintf(buffer, "Distance : %d", (CGL_int)(distance_traveled * 0.1f));
            CGL_widgets_add_string(buffer, -0.6f, -0.7f, 1.2f, 0.3f);
        }
        CGL_widgets_end();
    }
    CGL_window_poll_events(g_state.window);
    CGL_window_swap_buffers(g_state.window);        
    if(g_state.score >=0)
    {
        if(CGL_window_get_key(g_state.window, CGL_KEY_UP) == CGL_PRESS) g_state.player_y -= 5.3f * g_state.delta_time;
        if(CGL_window_get_key(g_state.window, CGL_KEY_DOWN) == CGL_PRESS) g_state.player_y += 5.3f * g_state.delta_time;
        g_state.player_y = CGL_utils_clamp(g_state.player_y, -3.5f, 3.5f);
        if(CGL_window_get_key(g_state.window, CGL_KEY_LEFT) == CGL_PRESS) g_state.player_x += 8.25f * g_state.delta_time;
        if(CGL_window_get_key(g_state.window, CGL_KEY_RIGHT) == CGL_PRESS) g_state.player_x -= 8.25f * g_state.delta_time;
        g_state.player_x = CGL_utils_clamp(g_state.player_x, -3.5f, 3.5f);
        g_state.intensity = CGL_utils_max(0.0f, g_state.intensity);
    }
    else
    {
        if(CGL_window_get_key(g_state.window, CGL_KEY_R) == CGL_PRESS)
        {
            clear_all();
            g_state.start_time = g_state.curr_time;
            distance_traveled = 0.0f;
            g_state.score = 0;
        }
    }
    if(CGL_window_get_key(g_state.window, CGL_KEY_ESCAPE) == CGL_PRESS) return;
}

#ifdef __EMSCRIPTEN__
EMSCRIPTEN_KEEPALIVE
#endif
int main()
{
    init();

#ifdef __EMSCRIPTEN__
    emscripten_set_main_loop(loop, 0, 1);
#else
    while(!CGL_window_should_close(g_state.window))
    {
        loop();
        if(CGL_window_get_key(g_state.window, CGL_KEY_ESCAPE) == CGL_PRESS) break;
    }
#endif
    cleanup();
    return 0;
}

```

`examples/c/newton_equation_root_appximator.c`:

```c
/*
MIT License
Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_EXCLUDE_NETWORKING
#define CGL_LOGGING_ENABLED
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_EXCLUDE_AUDIO
#define CGL_IMPLEMENTATION
#include "cgl.h"

#ifdef CGL_WASM
#include <emscripten/emscripten.h>
#include <emscripten/html5.h>
#else 
#define EM_BOOL int
#endif

#define EPSILON 0.001f
#define POINT_RADIUS 0.02f
#define CURVE_SAMPLE_POINTS 1000

static struct
{
	CGL_window* window; // window object
	CGL_framebuffer* framebuffer; // framebuffer object
	CGL_float eq_corfficients[12];
	CGL_bool is_solving;
	CGL_float past_sample_points[CURVE_SAMPLE_POINTS][2];
	CGL_int past_sample_points_count;
	CGL_float current_point;
	CGL_float current_point_percent;
	CGL_float next_point;
} g_context; // global context

CGL_float plot_function(float x)
{
	CGL_float y = 0.0f;
	for(CGL_int i = 0; i < 4; i++) y += g_context.eq_corfficients[i] * powf(x * 1.0f, (CGL_float)i);
	return y * 0.2f;
}

CGL_void calculate_next_point()
{
	CGL_float x = g_context.current_point;
	CGL_float y = plot_function(x);
	CGL_float y0 = plot_function(x - EPSILON);
	CGL_float y1 = plot_function(x + EPSILON);
	CGL_float slope = (y1 - y0) / (2.0f * EPSILON);
	g_context.next_point = x - y / slope;
}

CGL_bool init()
{
	srand((uint32_t)time(NULL));
	if(!CGL_init()) return CGL_FALSE;
	g_context.window = CGL_window_create(700, 700, "Newton's Approximate Solver - Jaysmito Mukherjee");
	CGL_window_make_context_current(g_context.window);
	if(!CGL_gl_init()) return CGL_FALSE;
	g_context.framebuffer = CGL_framebuffer_create_from_default(g_context.window);
	g_context.is_solving = false;
	g_context.past_sample_points_count = 0;
	g_context.current_point = 0.0f;
	g_context.current_point_percent = 0.0f;
	CGL_widgets_init();
	return CGL_TRUE;
}

void cleanup()
{
	CGL_widgets_shutdown();
	CGL_framebuffer_destroy(g_context.framebuffer);
	CGL_gl_shutdown();
	CGL_window_destroy(g_context.window);
	CGL_shutdown();
}

EM_BOOL loop(double time, void* userData)
{
	(void)time;
	(void)userData;

	CGL_window_set_size(g_context.window, 700, 700);
	CGL_framebuffer_bind(g_context.framebuffer);
	CGL_gl_clear(0.0f, 0.0f, 0.0f, 1.0f);

	CGL_widgets_begin();
	CGL_widgets_set_stroke_thicnkess(0.01f);
	CGL_widgets_set_stroke_colorf(0.5f, 0.7f, 0.5f, 1.0f);
	CGL_widgets_add_line2f(-1.0f, 0.0f, 1.0f, 0.0f); // x axis
	CGL_widgets_add_line2f(0.0f, -1.0f, 0.0f, 1.0f); // y axis
	if(g_context.is_solving)
	{
		g_context.current_point_percent += 0.01f;
		// draw the past sample points and tangent lines
		for (CGL_int i = 0 ; i < g_context.past_sample_points_count ; i++)
		{
			CGL_widgets_set_fill_colorf(0.8f, 0.5f, 0.6f, 1.0f);  
			CGL_widgets_add_circle2fr(g_context.past_sample_points[i][0], plot_function(g_context.past_sample_points[i][0]), POINT_RADIUS * 0.7f, 8);
			CGL_widgets_add_circle2fr(g_context.past_sample_points[i][0], 0.0f, POINT_RADIUS * 0.7f, 8);
			CGL_widgets_set_stroke_colorf(0.5f, 0.9f, 0.9f, 1.0f); CGL_widgets_set_stroke_thicnkess(0.004f);
			CGL_widgets_add_line2f(g_context.past_sample_points[i][0], plot_function(g_context.past_sample_points[i][0]), g_context.past_sample_points[i][0], 0.0f);
			CGL_widgets_set_stroke_colorf(0.8f, 0.8f, 0.5f, 1.0f); CGL_widgets_set_stroke_thicnkess(0.005f);
			CGL_widgets_add_line2f(g_context.past_sample_points[i][0], plot_function(g_context.past_sample_points[i][0]), g_context.past_sample_points[i][1], 0.0f);
		}
		// draw the current point
		CGL_widgets_set_fill_colorf(0.5f, 0.5f, 0.8f, 1.0f);
		CGL_widgets_add_circle2fr(g_context.current_point, plot_function(g_context.current_point), POINT_RADIUS, 8);
		CGL_widgets_add_circle2fr(g_context.current_point, 0.0f, POINT_RADIUS, 8);
		CGL_widgets_set_stroke_colorf(0.8f, 0.8f, 0.8f, 1.0f); CGL_widgets_set_stroke_thicnkess(0.006f);
		CGL_widgets_add_line2f(g_context.current_point, 0.0f, g_context.current_point, plot_function(g_context.current_point));
		// animate the current tangent line
		CGL_widgets_set_stroke_colorf(0.5f, 0.8f, 0.8f, 1.0f); CGL_widgets_set_stroke_thicnkess(0.01f); 
		CGL_vec3 start = CGL_vec3_init(g_context.current_point, plot_function(g_context.current_point), 0.0f);
		CGL_vec3 end_original = CGL_vec3_init(g_context.next_point, 0.0f, 0.0f);
		CGL_vec3 end = CGL_vec3_lerp(start, end_original, g_context.current_point_percent);
		CGL_widgets_add_line(start, end);
		if(g_context.current_point_percent >= 1.0f)
		{
			g_context.past_sample_points[g_context.past_sample_points_count][0] = g_context.current_point;
			g_context.past_sample_points[g_context.past_sample_points_count++][1] = g_context.next_point;
			g_context.current_point = g_context.next_point;
			g_context.current_point_percent = 0.0f;
			calculate_next_point();
		}
	}
	CGL_widgets_set_fill_colorf(0.8f, 0.8f, 0.8f, 1.0f); // set the fill color to light gray
	CGL_widgets_set_stroke_colorf(0.7f, 0.5f, 0.5f, 1.0f); // set the stroke color to slight red
	CGL_widgets_set_stroke_thicnkess(0.005f); // set the stroke thickness to 0.005 to draw the curve
	CGL_vec2 prev_point = CGL_vec2_init(0.0f, 0.0f);  // initialize the previous point to 0, 0
	for(CGL_int i = 0; i < CURVE_SAMPLE_POINTS + 10 ; i++) // draw the curve +10 points to make sure the curve is drawn completely
	{
		CGL_float x = -1.0f + (2.0f / (CGL_float)CURVE_SAMPLE_POINTS) * (CGL_float)i; // calculate the x value for the point
		CGL_float y = plot_function(x); // evaluate the plot function at the x value
		//CGL_float y = CGL_linear_regression_evaluate(g_context.lr_context, &x, NULL); // evaluate the linear regression model at the x value
		if(i % (CGL_int)(CURVE_SAMPLE_POINTS * 0.1f) == 0) CGL_widgets_add_circle2fr(x, y, POINT_RADIUS * 0.5f, 4); // draw a small circle at every 10% of the curve (to prevent clutter)
		if(i > 0) CGL_widgets_add_line2f(prev_point.x, prev_point.y, x, y); // draw a line from the previous point to the current point to draw the curve
		prev_point = CGL_vec2_init(x, y); // set the previous point to the current point
	}
	CGL_widgets_end();

	if(CGL_window_is_key_pressed(g_context.window, CGL_KEY_R)) {
		g_context.is_solving = false;
		for (CGL_int i = 0; i < 12; i++)
			g_context.eq_corfficients[i] = CGL_utils_random_float_in_range(-4.0f, 4.0f);
		CGL_utils_sleep(100);
	}
	if(CGL_window_is_key_pressed(g_context.window, CGL_KEY_S)) {
		g_context.past_sample_points_count = 0;
		g_context.current_point = CGL_utils_random_float_in_range(-1.0f, 1.0f);
		g_context.current_point_percent = 0.0f;
		calculate_next_point();
		g_context.is_solving = true;
		CGL_utils_sleep(100);
	}

	CGL_window_swap_buffers(g_context.window);
	CGL_window_poll_events(g_context.window);

	return !CGL_window_should_close(g_context.window);
}

int main()
{
	if(!init()) return 1;

#ifdef CGL_WASM
	CGL_info("Running in WASM mode");
	emscripten_request_animation_frame_loop(loop, NULL);
#else
	while (!CGL_window_should_close(g_context.window)) {
		loop(0, NULL);
	}
	cleanup();
#endif

	return 0;
}

```

`examples/c/noise_generator.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#define CGL_EXCLUDE_NETWORKING
#define CGL_EXCLUDE_RAY_CASTER
#define CGL_EXCLUDE_AUDIO
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_EXCLUDE_NODE_EDITOR
#include "cgl.h"

#ifdef CGL_WASM
#include <emscripten/emscripten.h>
#include <emscripten/html5.h>
#else 
#define EM_BOOL int
#endif

static const char* PASS_THROUGH_VERTEX_SHADER_SOURCE = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
"\n"
"in vec4 position;\n"
"in vec4 normal;\n"
"in vec4 texcoord;\n"
#else
"#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 normal;\n"
"layout (location = 2) in vec4 texcoord;\n"
#endif
"\n"
"out vec3 Position;\n"
"out vec2 TexCoord;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = vec4(position.xyz, 1.0f);\n"
"	Position = position.xyz;\n"
"	TexCoord = texcoord.xy;\n"
"}";

static const char* PASS_THROUGH_FRAGMENT_SHADER_SOURCE = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
#else
"#version 430 core\n"
#endif
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Position;\n"
"in vec2 TexCoord;\n"
"\n"
"uniform sampler2D u_tex;\n"
"\n"
"// Black Box From https://github.com/armory3d/armory/blob/master/Shaders/std/tonemap.glsl\n"
"vec3 acesFilm(const vec3 x) {\n"
"    const float a = 2.51;\n"
"    const float b = 0.03;\n"
"    const float c = 2.43;\n"
"    const float d = 0.59;\n"
"    const float e = 0.14;\n"
"    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	vec3 color = texture(u_tex, vec2(TexCoord.y, 1.0f - TexCoord.x)).rgb;\n"
//"	color = acesFilm(color);\n"
//"   color = pow(color, vec3(1.0f / 2.2f));\n"
"	FragColor = vec4(color, 1.0f);\n"
"}";


#define MAP_RESOLUTION 256

// Game state structure
struct {
    CGL_window* window;
    CGL_framebuffer* default_framebuffer;
    CGL_texture* output_tex;
    CGL_shader* present_shader;
    CGL_noise_params np;
    CGL_float scale;
    CGL_float offset_x;
    CGL_float offset_y;
    CGL_float texture_data_local[MAP_RESOLUTION * MAP_RESOLUTION * 4];
    CGL_float prev_time;
    CGL_float curr_time;
    CGL_float delta_time;
    CGL_float frame_time;
    CGL_int frames;
    CGL_int fps;
} g_State;

CGL_float noise(CGL_float x, CGL_float y)
{
    return CGL_noise_get(&g_State.np, x, y, 0.0f);
}

CGL_bool init()
{
    srand((uint32_t)time(NULL));
    if (!CGL_init()) return CGL_FALSE;

    g_State.window = CGL_window_create(700, 700, "Perlin Noise - Jaysmito Mukherjee");
    if (!g_State.window) return CGL_FALSE;

    CGL_window_make_context_current(g_State.window);
    if (!CGL_gl_init()) return CGL_FALSE;

    CGL_widgets_init();
    CGL_noise_init();
    CGL_noise_params_default(&g_State.np);
    g_State.np.octaves = 8;

    g_State.default_framebuffer = CGL_framebuffer_create_from_default(g_State.window);
    g_State.output_tex = CGL_texture_create_blank(MAP_RESOLUTION, MAP_RESOLUTION, GL_RGBA, GL_RGBA32F, GL_FLOAT);
    g_State.present_shader = CGL_shader_create(PASS_THROUGH_VERTEX_SHADER_SOURCE, PASS_THROUGH_FRAGMENT_SHADER_SOURCE, NULL);

    g_State.scale = 1.0f;
    g_State.offset_x = 0.0f;
    g_State.offset_y = 0.0f;
    g_State.prev_time = CGL_utils_get_time();
    g_State.frames = 0;
    g_State.fps = 0;
    g_State.frame_time = 0.0f;

    return CGL_TRUE;
}

void cleanup()
{
    CGL_texture_destroy(g_State.output_tex);
    CGL_shader_destroy(g_State.present_shader);
    CGL_framebuffer_destroy(g_State.default_framebuffer);
    CGL_noise_shutdown();
    CGL_widgets_shutdown();
    CGL_gl_shutdown();
    CGL_window_destroy(g_State.window);
    CGL_shutdown();
}

EM_BOOL loop(double time, void* userData)
{
    (void)time;
    (void)userData;

    CGL_window_set_size(g_State.window, 700, 700);

    g_State.curr_time = CGL_utils_get_time();
    g_State.delta_time = g_State.curr_time - g_State.prev_time;
    g_State.prev_time = g_State.curr_time;
    g_State.frame_time += g_State.delta_time;
    g_State.frames++;
    
    if (g_State.frame_time >= 1.0f) {
        g_State.fps = g_State.frames;
        g_State.frames = 0;
        g_State.frame_time = 0.0f;
    }

    // Update noise texture
    for (CGL_int i = 0; i < MAP_RESOLUTION; i++) {
        for (CGL_int j = 0; j < MAP_RESOLUTION; j++) {
            CGL_float u = (CGL_float)j / (CGL_float)MAP_RESOLUTION;
            CGL_float v = (CGL_float)i / (CGL_float)MAP_RESOLUTION;
            CGL_float x = u * g_State.scale + g_State.offset_x;
            CGL_float y = v * g_State.scale + g_State.offset_y;
            CGL_float ns = noise(x, y);
            CGL_float r = ns * 0.5f + 0.5f;
            g_State.texture_data_local[(i * MAP_RESOLUTION + j) * 4 + 0] = r;
            g_State.texture_data_local[(i * MAP_RESOLUTION + j) * 4 + 1] = r;
            g_State.texture_data_local[(i * MAP_RESOLUTION + j) * 4 + 2] = r;
            g_State.texture_data_local[(i * MAP_RESOLUTION + j) * 4 + 3] = 1.0f;
        }
    }
    CGL_texture_set_data(g_State.output_tex, g_State.texture_data_local);

    // Render
    CGL_framebuffer_bind(g_State.default_framebuffer);
    CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);
    CGL_shader_bind(g_State.present_shader);
    CGL_texture_bind(g_State.output_tex, 0);
    CGL_shader_set_uniform_int(g_State.present_shader, CGL_shader_get_uniform_location(g_State.present_shader, "u_tex"), 0);
    CGL_gl_render_screen_quad();

    // UI rendering
    glDisable(GL_DEPTH_TEST);
    CGL_widgets_begin();
    CGL_widgets_set_fill_colorf(0.0f, 0.0f, 0.0f, 1.0f);

    static CGL_byte buffer[256];
    sprintf(buffer, "Frame Time: %f", g_State.delta_time);
    CGL_widgets_add_string(buffer, -1.0f, 0.975f, 0.5f, 0.025f);
    sprintf(buffer, "Framerate : %d", g_State.fps);
    CGL_widgets_add_string(buffer, -1.0f, 0.950f, 0.5f, 0.025f);
    sprintf(buffer, "Scale : %f", g_State.scale);
    CGL_widgets_add_string(buffer, -1.0f, 0.925f, 0.5f, 0.025f);
    sprintf(buffer, "Resolution: %dx%d", MAP_RESOLUTION, MAP_RESOLUTION);
    CGL_widgets_add_string(buffer, -1.0f, 0.900f, 0.5f, 0.025f);
    sprintf(buffer, "Offset X: %f", g_State.offset_x);
    CGL_widgets_add_string(buffer, -1.0f, 0.875f, 0.5f, 0.025f);
    sprintf(buffer, "Offset Y: %f", g_State.offset_y);
    CGL_widgets_add_string(buffer, -1.0f, 0.850f, 0.5f, 0.025f);

    CGL_widgets_end();

    // Handle input
    if (CGL_window_get_key(g_State.window, CGL_KEY_T) == CGL_PRESS)
        for (CGL_int i = 0; i < CGL_NOISE_TYPE_COUNT; i++)
            if (CGL_window_is_key_pressed(g_State.window, CGL_KEY_0 + i))
                g_State.np.type = i;

    if (CGL_window_get_key(g_State.window, CGL_KEY_F) == CGL_PRESS)
        for (CGL_int i = 0; i < CGL_NOISE_FRACTAL_TYPE_COUNT; i++)
            if (CGL_window_is_key_pressed(g_State.window, CGL_KEY_0 + i))
                g_State.np.fractal_type = i;

    if (CGL_window_get_key(g_State.window, CGL_KEY_S) == CGL_PRESS) {
        if (CGL_window_get_key(g_State.window, CGL_KEY_UP) == CGL_PRESS) g_State.scale *= 1.02f;
        if (CGL_window_get_key(g_State.window, CGL_KEY_DOWN) == CGL_PRESS) g_State.scale *= 0.98f;
    } else {
        if (CGL_window_get_key(g_State.window, CGL_KEY_UP) == CGL_PRESS) g_State.offset_y += 0.1f;
        if (CGL_window_get_key(g_State.window, CGL_KEY_DOWN) == CGL_PRESS) g_State.offset_y -= 0.1f;
        if (CGL_window_get_key(g_State.window, CGL_KEY_LEFT) == CGL_PRESS) g_State.offset_x += 0.1f;
        if (CGL_window_get_key(g_State.window, CGL_KEY_RIGHT) == CGL_PRESS) g_State.offset_x -= 0.1f;
    }

    CGL_window_poll_events(g_State.window);
    CGL_window_swap_buffers(g_State.window);

    return !CGL_window_should_close(g_State.window);
}

int main()
{
    if (!init()) return 1;

#ifdef CGL_WASM
    CGL_info("Running in WASM mode");
    emscripten_request_animation_frame_loop(loop, NULL);
#else
    while (!CGL_window_should_close(g_State.window)) {
        loop(0, NULL);
    }
    cleanup();
#endif

    return 0;
}

```

`examples/c/one_million_particles_01.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#define CGL_EXCLUDE_NETWORKING
#define CGL_EXCLUDE_RAY_CASTER
#define CGL_EXCLUDE_NODE_EDITOR
#include "cgl.h"

static const char* PASS_THROUGH_VERTEX_SHADER_SOURCE = "#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 normal;\n"
"layout (location = 2) in vec4 texcoord;\n"
"\n"
"out vec3 Position;\n"
"out vec2 TexCoord;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = vec4(position.xyz, 1.0f);\n"
"	Position = position.xyz;\n"
"	TexCoord = texcoord.xy;\n"
"}";

static const char* PASS_THROUGH_FRAGMENT_SHADER_SOURCE = "#version 430 core\n"
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Position;\n"
"in vec2 TexCoord;\n"
"\n"
"uniform sampler2D u_tex;\n"
"\n"
"// Black Box From https://github.com/armory3d/armory/blob/master/Shaders/std/tonemap.glsl\n"
"vec3 acesFilm(const vec3 x) {\n"
"    const float a = 2.51;\n"
"    const float b = 0.03;\n"
"    const float c = 2.43;\n"
"    const float d = 0.59;\n"
"    const float e = 0.14;\n"
"    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	vec3 color = texture(u_tex, vec2(TexCoord.y, 1.0f - TexCoord.x)).rgb;\n"
"	color = acesFilm(color);\n"
"   color = pow(color, vec3(1.0f / 2.2f));\n"
"	FragColor = vec4(color, 1.0f);\n"
"}";


static const char* PARTICLE_VERTEX_SHADER = "#version 430 core\n"
"\n"
"out vec3 Color;\n"
"\n"
"struct Particle\n"
"{\n"
"	vec4 position;\n"
"	vec4 velocity;\n"
"	vec4 color;\n"
"	vec4 colori;\n"
"};\n"
"\n"
"uniform mat4 view_proj;\n"
"\n"
"// vertices for a pyramid \n"
"const vec3 VERTICES[4] = vec3[4](\n"
"   vec3(0.5f, -0.5f, -1.732f * 0.5f),\n"
"   vec3(0.0f, 0.5f, 0.0f),\n"
"   vec3( 0.5f, -0.5f, 1.732f * 0.5f),\n"
"   vec3(-1.0f, -0.5f, 0.0f)\n"
");\n"
"\n"
"const int INDICES[12] = int[12](\n"
"   0, 1, 2,\n"
"   0, 1, 3,\n"
"   0, 2, 3,\n"
"   1, 2, 3\n"
");\n"
"\n"
"\n"
"layout (std430, binding = 0) buffer Particles\n"
"{\n"
"	Particle particles[];\n"
"};\n"
"\n"
"void main()\n"
"{\n"
"   int particle_index = gl_VertexID / 12;\n"
"   int index = gl_VertexID % 12;\n"
"   vec3 vertex = VERTICES[INDICES[index]];\n"
"   float distance = length(particles[particle_index].position.xyz);\n"
"   distance = clamp(7.5f - distance, 0.0f, 7.5f) / 7.5f;\n"
"   distance = pow(distance, 1.0f) + 0.4f;\n"
"   vertex = particles[particle_index].position.xyz + vertex * distance * 0.07f;\n"
"	gl_Position = view_proj * vec4(vertex, 1.0f);\n"
"   Color = particles[particle_index].color.xyz;\n"
"}\n";

static const char* PARTICLE_FRAGMENT_SHADER = "#version 430 core\n"
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Color;\n"
"\n"
"void main()\n"
"{\n"
"	FragColor = vec4(Color, 1.0f);\n"
"}\n";

static const char* PARTICLE_COMPUTE_SHADER = "#version 430 core\n"
"\n"
"layout (local_size_x = 100, local_size_y = 1, local_size_z = 1) in;\n"
"\n"
"struct Particle\n"
"{\n"
"	vec4 position;\n"
"	vec4 velocity;\n"
"	vec4 color;\n"
"	vec4 colori;\n"
"};\n"
"\n"
"layout (std430, binding = 0) buffer Particles\n"
"{\n"
"	Particle particles[];\n"
"};\n"
"\n"
"uniform float delta_time;\n"
"uniform int mode;\n"
"uniform vec3 seed = vec3(0.0f);\n"
"\n"
"float rand(vec2 co)\n"
"{\n"
"    co += seed.xy;\n"
"    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n"
"}\n"
"\n"
"vec3 hash( vec3 p )\n"
"{\n"
"   p += seed;\n"
"	p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n"
"			  dot(p,vec3(269.5,183.3,246.1)),\n"
"			  dot(p,vec3(113.5,271.9,124.6)));\n"
"\n"
"	return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n"
"}\n"
"\n"
"// return value noise (in x) and its derivatives (in yzw)\n"
"vec4 noised( in vec3 x )\n"
"{\n"
"    // grid\n"
"    vec3 i = floor(x);\n"
"    vec3 w = fract(x);\n"
"    \n"
"    #if 1\n"
"    // quintic interpolant\n"
"    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n"
"    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n"
"    #else\n"
"    // cubic interpolant\n"
"    vec3 u = w*w*(3.0-2.0*w);\n"
"    vec3 du = 6.0*w*(1.0-w);\n"
"    #endif    \n"
"    \n"
"    // gradients\n"
"    vec3 ga = hash( i+vec3(0.0,0.0,0.0) );\n"
"    vec3 gb = hash( i+vec3(1.0,0.0,0.0) );\n"
"    vec3 gc = hash( i+vec3(0.0,1.0,0.0) );\n"
"    vec3 gd = hash( i+vec3(1.0,1.0,0.0) );\n"
"    vec3 ge = hash( i+vec3(0.0,0.0,1.0) );\n"
"	vec3 gf = hash( i+vec3(1.0,0.0,1.0) );\n"
"    vec3 gg = hash( i+vec3(0.0,1.0,1.0) );\n"
"    vec3 gh = hash( i+vec3(1.0,1.0,1.0) );\n"
"    \n"
"    // projections\n"
"    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n"
"    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n"
"    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n"
"    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n"
"    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n"
"    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n"
"    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n"
"    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n"
"	\n"
"    // interpolations\n"
"    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\n"
"                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\n"
"                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\n"
"}\n"
"\n"
"\n"
"void initialize_particles()\n"
"{\n"
"	uint index = gl_GlobalInvocationID.x;\n"
"	Particle particle;\n"
"	particle.position = vec4(0.0f, 0.0f, 0.0f, 1.0f);\n"
"	particle.velocity = vec4(rand(vec2(index, 454.45f)) * 2.0f - 1.0f, rand(vec2(958.454f, index * 21.0f)) * 2.0f - 1.0f, rand(vec2(4.684 * index, 4568.41f)) * 2.0f - 1.0f, 0.0f);\n"
"   particle.velocity *= 0.8f * pow(noised(particle.velocity.xyz * 8.0f).x * 2.0f + 0.2f, 0.5f);\n"
"	particle.color = vec4(1.0f, 0.0f, 0.0f, 1.0f);\n"
"	particle.colori = normalize(particle.velocity) * 0.5f + vec4(0.5f);\n"
"	particles[index] = particle;\n"
"}\n"
"\n"
"void update_particles()\n"
"{\n"
"	uint index = gl_GlobalInvocationID.x;\n"
"	Particle particle = particles[index];\n"
"   vec4 total_noise = noised(particle.position.xyz * 0.7f);\n"
"   vec3 acceleration = total_noise.yzw;\n"
"	particle.position += particle.velocity * clamp(delta_time, 0.00f, 0.03f);\n"
"	particle.velocity += acceleration * 0.15f;\n"
"   float lntgh = length(particle.position.xyz);"
"   vec3 noise_at_pos = total_noise.xyz;\n"
"   total_noise.x *= 4.0f - 2.0f;"
"   if(lntgh > 7.0f + total_noise.x && lntgh < 7.05f + total_noise.x)\n"
"   {\n"
"       particle.velocity = 2.0f * normalize(vec4(-particle.position.xyz, 0.0f));\n"
"       particle.velocity *= 0.2f * vec4(noise_at_pos * 0.5f + vec3(0.5f), 1.0f);\n"
"       if(noise_at_pos.x > 0.0f)\n"
"       {\n"
"           particle.velocity *= 0.0f;\n"
"           particle.position = vec4(normalize(particle.position.xyz) * (7.06f + total_noise.x), 0.0f);\n"
"       }\n"
"       particle.velocity *= 5.0f;\n"
"   }\n"
"   else if(lntgh > 7.05f + noise_at_pos.x * 2.5f)\n"
"   {\n"
"       particle.velocity *= 0.0f;\n"
"       particle.position = vec4(normalize(particle.position.xyz) * (7.06f + total_noise.x), 0.0f);\n"
"   }\n"
"   vec3 central_color = vec3(255, 238, 0) / 256.0f;\n"
"   vec3 middle_color = vec3(255, 94, 0) / 256.0f;\n"
"   vec3 border_color = vec3(255, 30, 0) / 256.0f;\n"
"   float factor = pow(lntgh / 7.0f, 1.0f / 8.0f);\n"
"   vec3 color = mix(central_color, middle_color, factor);\n"
"   color = mix(color, border_color, pow(lntgh / 7.0f, 4.0f));\n"
"   particle.color =  vec4(color * (1.0f + pow(1.0f - lntgh / 7.0f, 4.0f)), 0.0f);\n"
"	particles[index] = particle;\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"   if(mode == 0) initialize_particles();\n"
"   else if(mode == 1) update_particles();\n"
"}\n";


#define PARTICLE_COUNT 1000000

int main()
{
    srand((uint32_t)time(NULL));
    CGL_init();
    CGL_window* window = CGL_window_create(700, 700, "Particles - Jaysmito Mukherjee");
    if(!window) return 1;
    CGL_window_make_context_current(window);
    CGL_gl_init();
    CGL_widgets_init();

    CGL_framebuffer* default_framebuffer = CGL_framebuffer_create_from_default(window);
    CGL_framebuffer* bloom_framebuffer = CGL_framebuffer_create(600, 600);

    CGL_shader* present_shader = CGL_shader_create(PASS_THROUGH_VERTEX_SHADER_SOURCE, PASS_THROUGH_FRAGMENT_SHADER_SOURCE, NULL);
    CGL_shader* particle_shader = CGL_shader_create(PARTICLE_VERTEX_SHADER, PARTICLE_FRAGMENT_SHADER, NULL);
    CGL_shader* particle_compute_shader = CGL_shader_compute_create(PARTICLE_COMPUTE_SHADER, NULL);

    CGL_bloom* bloom = CGL_bloom_create(600, 600, 3);

    CGL_ssbo* particle_ssbo = CGL_ssbo_create(0);
    CGL_ssbo_set_data(particle_ssbo, sizeof(CGL_float) * 12 * PARTICLE_COUNT, NULL, GL_DYNAMIC_DRAW);
    
    CGL_float curr_time = CGL_utils_get_time();
    CGL_float prev_time = CGL_utils_get_time();
    CGL_float time = 0.0f, frame_time = 0.0f;
    CGL_int frames = 0, fps = 0;


    CGL_bool started = false;

    CGL_mat4 view, projection;
    projection = CGL_mat4_perspective(CGL_deg_to_rad(45.0f), 1.0f, 0.01f, 100.0f);
    view = CGL_mat4_identity();

    CGL_shader_bind(particle_compute_shader);
    CGL_shader_set_uniform_int(particle_compute_shader, CGL_shader_get_uniform_location(particle_compute_shader, "mode"), 0);
    CGL_shader_compute_dispatch(particle_compute_shader, PARTICLE_COUNT / 100, 1, 1);

    while(!CGL_window_should_close(window))
    {
        CGL_window_set_size(window, 600, 600); // force window size to be 600x600

        curr_time = CGL_utils_get_time();
        CGL_float delta_time = curr_time - prev_time;
        //delta_time = CGL_utils_clamp(delta_time, 0.0f, 0.03f); // to avoid sudden jumps in time due to lag or things like window resizing
        prev_time = curr_time;
        time += delta_time; frame_time += delta_time;
        frames++;
        if(frame_time >= 1.0f) { fps = frames; frames = 0; frame_time = 0.0f; }
        

        view = CGL_mat4_look_at(CGL_vec3_init(15.0f * cosf(time), 15.0f, 15.0f*sinf(time)), CGL_vec3_init(0.0f, 0.0f, 0.0f), CGL_vec3_init(0.0f, 1.0f, 0.0f));
        view = CGL_mat4_mul(projection, view);

        CGL_shader_bind(particle_compute_shader);
        CGL_shader_set_uniform_int(particle_compute_shader, CGL_shader_get_uniform_location(particle_compute_shader, "mode"), 1);
        CGL_shader_set_uniform_float(particle_compute_shader, CGL_shader_get_uniform_location(particle_compute_shader, "delta_time"), delta_time);
        CGL_shader_compute_dispatch(particle_compute_shader, PARTICLE_COUNT / 100, 1, 1);


        glEnable(GL_DEPTH_TEST);
        glDepthFunc(GL_LESS);

        CGL_framebuffer_bind(bloom_framebuffer);
        CGL_gl_clear(0.0f, 0.0f, 0.0f, 1.0f);
        CGL_shader_bind(particle_shader);
        CGL_shader_set_uniform_mat4(particle_shader, CGL_shader_get_uniform_location(particle_shader, "view_proj"), &view);
        glDrawArrays(GL_TRIANGLES, 0, 12 * PARTICLE_COUNT);


        CGL_bloom_apply(bloom, CGL_framebuffer_get_color_texture(bloom_framebuffer));

        CGL_framebuffer_bind(default_framebuffer);
        CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);
        CGL_shader_bind(present_shader);
        CGL_texture_bind(CGL_framebuffer_get_color_texture(bloom_framebuffer), 0);
        CGL_shader_set_uniform_int(present_shader, CGL_shader_get_uniform_location(present_shader, "u_tex"), 0);
        CGL_gl_render_screen_quad();

        glDisable(GL_DEPTH_TEST);

        CGL_widgets_begin();
        
        CGL_widgets_set_fill_colorf(1.0f, 1.0f, 1.0f, 1.0f);
        CGL_widgets_set_stroke_colorf(1.0f, 1.0f, 1.0f, 1.0f);

        static CGL_byte buffer[256];
        sprintf(buffer, "Frame Time: %f", delta_time);
        CGL_widgets_add_string(buffer, -1.0f, 0.95f, 1.0f, 0.05f);
        sprintf(buffer, "Framerate : %d", fps);
        CGL_widgets_add_string(buffer, -1.0f, 0.9f, 1.0f, 0.05f);
        sprintf(buffer, "Particles : %d", PARTICLE_COUNT);
        CGL_widgets_add_string(buffer, -1.0f, 0.85f, 1.0f, 0.05f);  

        if(CGL_window_get_key(window, CGL_KEY_SPACE) == CGL_PRESS)
        {
            CGL_shader_bind(particle_compute_shader);
            CGL_shader_set_uniform_int(particle_compute_shader, CGL_shader_get_uniform_location(particle_compute_shader, "mode"), 0);
            CGL_shader_set_uniform_vec3v(particle_compute_shader, CGL_shader_get_uniform_location(particle_compute_shader, "seed"), CGL_utils_random_float() * 100.0f, CGL_utils_random_float() * 100.0f, CGL_utils_random_float() * 100.0f);
            CGL_shader_compute_dispatch(particle_compute_shader, PARTICLE_COUNT / 100, 1, 1);
        }
        



        CGL_widgets_end();

        CGL_window_poll_events(window);
        CGL_window_swap_buffers(window);

        if(!started) if(CGL_window_get_key(window, CGL_KEY_SPACE) == CGL_PRESS) started = true;
    }


    CGL_ssbo_destroy(particle_ssbo);
    CGL_shader_destroy(particle_compute_shader);
    CGL_shader_destroy(particle_shader);
    CGL_shader_destroy(present_shader);
    CGL_framebuffer_destroy(default_framebuffer);
    CGL_framebuffer_destroy(bloom_framebuffer);
    CGL_bloom_destroy(bloom);
    CGL_widgets_shutdown();
    CGL_gl_shutdown();
    CGL_window_destroy(window);    
    CGL_shutdown();
    return 0;
}

```

`examples/c/phong_renderer.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#include "cgl.h"


#define MAIN_FRAME_BUFFER_WIDTH  800
#define MAIN_FRAME_BUFFER_HEIGHT (int)(MAIN_FRAME_BUFFER_WIDTH * (9.0f / 16.0f))


CGL_camera* camera;
CGL_vec3 cam_pos;
CGL_vec3 cam_rot;

static struct {
    float delta_x;
    float delta_y;
    float prev_x;
    float prev_y;
} mouse_input;


void input_scroll_callback(CGL_window* window, double x, double y)
{
    CGL_vec3 delta = CGL_camera_get_front(camera);
    delta = CGL_vec3_scale(delta, (float)y);
    cam_pos = CGL_vec3_add(cam_pos, delta);
    CGL_camera_set_position(camera, cam_pos);
}

void input_mouse_pos_callback(CGL_window* window, double x, double y)
{
    mouse_input.delta_x = ((float)x - mouse_input.prev_x);
    mouse_input.delta_y = ((float)y - mouse_input.prev_y);
    mouse_input.prev_x = (float)x;
    mouse_input.prev_y = (float)y;
}

int main()
{
    srand((uint32_t)time(NULL));
    if(!CGL_init()) return -1;
    CGL_window* main_window = CGL_window_create(640, 480, "Hello World");
    if(!main_window) return -1;
    CGL_window_make_context_current(main_window);
    if(!CGL_gl_init()) return -1;
    CGL_framebuffer* default_framebuffer = CGL_framebuffer_create_from_default(main_window);   
    CGL_mesh_cpu* cpu_mesh = CGL_mesh_cpu_load_obj("a.obj");
    CGL_mesh_gpu* mesh = CGL_mesh_gpu_create();
    CGL_mesh_gpu_upload(mesh, cpu_mesh, true);
    CGL_mesh_cpu_destroy(cpu_mesh);
    mouse_input.delta_x = 0.0f;
    mouse_input.delta_y = 0.0f;
    mouse_input.prev_x = 0.0f;
    mouse_input.prev_y = 0.0f;
    camera = CGL_camera_create();
    CGL_window_set_mouse_scroll_callback(main_window, input_scroll_callback);
    CGL_window_set_mouse_position_callback(main_window, input_mouse_pos_callback);

    CGL_phong_pipeline* pipeline = CGL_phong_pipeline_create();
    CGL_phong_pipeline_add_light(pipeline, CGL_phong_light_directional(CGL_vec3_init(0, -1, 0), CGL_vec3_init(0.8f, 0.8f, 0.8f), 1.0f));

    CGL_phong_mat* material = CGL_phong_mat_create();
    CGL_phong_mat_set_diffuse_color(material, CGL_vec3_init(0.3f, 0.5f, 0.7f));
    CGL_phong_mat_set_specular_color(material, CGL_vec3_init(0.5f, 0.7f, 0.9f));
    CGL_mat4 model_matrix;
    model_matrix = CGL_mat4_translate(0.0f, 0.0f, 0.0f);

    CGL_window_resecure_callbacks(main_window);

    cam_pos = CGL_camera_get_position(camera);
    cam_rot = CGL_camera_get_rotation(camera);
    cam_pos.z += 3.0f;
    CGL_camera_set_position(camera, cam_pos);

    while(!CGL_window_should_close(main_window))
    { 
        model_matrix = CGL_mat4_translate(0, 0, 0);
        {
            CGL_framebuffer_bind(default_framebuffer);
            CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);
            int rx = 0, ry = 0;
            CGL_framebuffer_get_size(default_framebuffer, &rx, &ry);
            CGL_camera_set_aspect_ratio(camera, ((float)rx / ry));
            CGL_camera_recalculate_mat(camera);
            CGL_phong_render_begin(pipeline, camera);
            CGL_phong_render(mesh, &model_matrix, material, pipeline, camera);
            CGL_phong_render_end(pipeline, camera);
        }

        CGL_window_poll_events(main_window);

        CGL_window_swap_buffers(main_window);
        if(CGL_window_get_mouse_button(main_window, CGL_MOUSE_BUTTON_MIDDLE) == CGL_PRESS)
        {            
            CGL_vec3 right = CGL_camera_get_right(camera);
            right = CGL_vec3_scale(right, (0.05f * mouse_input.delta_x));
            CGL_vec3 up = CGL_camera_get_up(camera);
            up = CGL_vec3_scale(up, (-0.05f * mouse_input.delta_y));
            cam_pos = CGL_vec3_add(cam_pos, up);
            cam_pos = CGL_vec3_add(cam_pos, right);
            CGL_camera_set_position(camera, cam_pos);
        }
        mouse_input.delta_x = mouse_input.delta_y = 0.0f;
        if(CGL_window_get_key(main_window, CGL_KEY_ESCAPE) == CGL_PRESS) break;
    }

    CGL_phong_pipeline_destroy(pipeline);
    CGL_phong_mat_destroy(material);

    CGL_camera_destroy(camera);
    CGL_framebuffer_destroy(default_framebuffer);
    CGL_mesh_gpu_destroy(mesh);
    CGL_gl_shutdown();
    CGL_window_destroy(main_window);
    CGL_shutdown();
    return 0;
}

```

`examples/c/playing_audio.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#include "cgl.h"

static CGL_wav_file g_wav_file = {0};
static CGL_bool g_is_playing = false;
static CGL_bool g_is_loaded = false;

void on_drop_file(CGL_window* window, const CGL_byte** paths, CGL_int count)
{
    if(g_is_loaded) CGL_wav_file_destroy(&g_wav_file);
    g_is_loaded = false;
    if(!CGL_wav_file_load(&g_wav_file, paths[0]))
    {
        CGL_error("Failed to load wav file: %s", paths[0]);
        return;
    }
    else CGL_info("Loaded wav file: %s", paths[0]);
    g_is_loaded = true;
    g_is_playing = false;
}

int main()
{
    srand((uint32_t)time(NULL));
    CGL_init();
    CGL_window* window = CGL_window_create(600, 600, "Audio - Jaysmito Mukherjee");
    if(!window) return 1;
    CGL_window_make_context_current(window);
    CGL_gl_init();
    CGL_window_set_drag_n_drop_callback(window, on_drop_file);
    CGL_framebuffer* default_framebuffer = CGL_framebuffer_create_from_default(window);
    
    /*
    const CGL_byte* available_devices = CGL_audio_get_device_list();
    const CGL_byte* next_device = available_devices + 1;
    CGL_info("Available devices:");
    CGL_int ct = 1, len = 0;
    while(available_devices && *available_devices != '\0' && next_device && *next_device != '\0')
    {
        CGL_info("%d. %s", ct++, available_devices);
        len = strlen(available_devices);
        available_devices += len + 1;
        next_device += len + 2;
    }

   CGL_info("Default device : %s", CGL_audio_get_default_device());
    */

   CGL_audio_context* audio_context = CGL_audio_context_create(NULL);
   CGL_audio_make_context_current(audio_context);

   CGL_audio_source* audio_source = CGL_audio_source_create();
   CGL_audio_buffer* audio_buffer = CGL_audio_buffer_create();
    

    while(!CGL_window_should_close(window))
    {
        CGL_window_set_size(window, 600, 600); // force window size to be 600x600

        CGL_framebuffer_bind(default_framebuffer);
        CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);

        if(g_is_loaded && !g_is_playing)
        {
            if(CGL_audio_source_is_playing(audio_source)) CGL_audio_source_stop(audio_source);
            CGL_audio_buffer_set_data_from_wav_file(audio_buffer, &g_wav_file);
            CGL_audio_source_set_buffer(audio_source, audio_buffer);
            CGL_audio_source_play(audio_source);
            g_is_playing = true;
            CGL_info("Started Playing");
        }

        if(g_is_loaded && g_is_playing)
        {
            if(!CGL_audio_source_is_playing(audio_source))
            {
                CGL_info("Finished playing");
                CGL_wav_file_destroy(&g_wav_file);
                g_is_loaded = false;
                g_is_playing = false;
            }
        }

        CGL_window_poll_events(window);
        CGL_window_swap_buffers(window);
    }


    CGL_audio_buffer_destroy(audio_buffer);
    CGL_audio_source_destroy(audio_source);
    CGL_audio_make_context_current(NULL);
    CGL_audio_context_destroy(audio_context);
    if(g_is_loaded) CGL_wav_file_destroy(&g_wav_file);
    CGL_framebuffer_destroy(default_framebuffer);
    CGL_gl_shutdown();
    CGL_window_destroy(window);    
    CGL_shutdown();
    return 0;
}

```

`examples/c/pong_game.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



#define CGL_LOGGING_ENABLED
#define CGL_EXCLUDE_NETWORKING
#define CGL_IMPLEMENTATION
#include "cgl.h"

#define ASPECT_RATIO (16.0f / 9.0f)
#define HITTER_HEIGHT 0.3f
#define HITTER_WIDTH 0.05f
#define BORDER_THICKNESS 0.01f
#define COLOR_GREEN 0.1f, 0.8f, 0.1f
#define COLOR_RED 0.8f, 0.1f, 0.1f
#define COLOR_PURE_RED 1.0f, 0.0f, 0.0f
#define COLOR_WHITE 0.8f, 0.8f, 0.8f
#define PLAYER_SPEED 0.001f
#define BALL_RADIUS 0.03f
#define BORDER_COLOR COLOR_PURE_RED
#define HINT_LINE_COLOR 0.1f, 0.1f, 0.1f

const char* quad_shader_vertex_source = "#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 normal;\n"
"layout (location = 2) in vec4 texcoord;\n"
"\n"
"out vec2 TexCoord;\n"
"\n"
"uniform vec2 ustart;\n"
"uniform vec2 usize;\n"
"\n"
"void main()\n"
"{\n"
"    vec2 pos = position.xy * usize * 0.5f + ustart;\n"
"    gl_Position = vec4(pos, 0.0f, 1.0f);\n"
"    TexCoord = texcoord.xy;\n"
"}";

const char* quad_shader_fragment_source = "#version 430 core\n"
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec2 TexCoord;\n"
"\n"
"uniform vec3 ucolor;\n"
"uniform bool uiscolor;\n"
"uniform bool uiscircle;\n"
"uniform sampler2D utex;\n"
"\n"
"void main()\n"
"{\n"
"    if(uiscircle)\n"
"    {\n"
"        if(length(TexCoord*2.0f - vec2(1.0f)) > 1.0f) discard;\n"
"    }\n"
"    if(uiscolor)\n"
"        FragColor = vec4(ucolor, 1.0f);\n"
"    else\n"
"    {\n"
"        float factor = texture(utex, vec2(TexCoord.x, 1.0f - TexCoord.y)).r;\n"
"        if(factor < 0.5f) discard;\n"
"        FragColor = vec4(vec3(factor), 1.0f);\n"
"    }\n"
"}";

static struct
{
    int prev_window_height;
    int prev_window_width;
    CGL_window* main_window;
    CGL_framebuffer* main_framebuffer;
    CGL_mesh_gpu* quad_mesh;
    CGL_shader* quad_shader;
    int quad_shader_ustart;
    int quad_shader_usize;
    int quad_shader_ucolor;
    int quad_shader_utex;
    int quad_shader_uiscolor;
    int quad_shader_uiscircle;
} g_context;

static struct
{
    float player_height;
    float computer_height;
    float computer_speed;
    bool allow_input;
    bool is_over;
    bool is_game_won;
    int player_score;
    float ball_pos_x;
    float ball_pos_y;
    float ball_velocity_x;
    float ball_velocity_y;
    float total_time;
    float prev_time;
    float speed_factor;
    CGL_texture* you_win_text;
    CGL_texture* you_lose_text;
    CGL_texture* instruction_text;
} g_game;

void setup_quad_renderer()
{
    // setup mesh
    CGL_mesh_cpu* quad_mesh_cpu = CGL_mesh_cpu_quad(
        CGL_vec3_init(1.0f, 1.0f, 0.0f),
        CGL_vec3_init(1.0f, -1.0f, 0.0f),
        CGL_vec3_init(-1.0f, -1.0f, 0.0f),
        CGL_vec3_init(-1.0f, 1.0f, 0.0f)
    );
    g_context.quad_mesh = CGL_mesh_gpu_create();
    CGL_mesh_gpu_upload(g_context.quad_mesh, quad_mesh_cpu, true);
    CGL_mesh_cpu_destroy(quad_mesh_cpu);

    g_context.quad_shader = CGL_shader_create(quad_shader_vertex_source, quad_shader_fragment_source, NULL);
    g_context.quad_shader_ustart = CGL_shader_get_uniform_location(g_context.quad_shader, "ustart");
    g_context.quad_shader_usize = CGL_shader_get_uniform_location(g_context.quad_shader, "usize");
    g_context.quad_shader_ucolor = CGL_shader_get_uniform_location(g_context.quad_shader, "ucolor");
    g_context.quad_shader_utex = CGL_shader_get_uniform_location(g_context.quad_shader, "utex");
    g_context.quad_shader_uiscolor = CGL_shader_get_uniform_location(g_context.quad_shader, "uiscolor");
    g_context.quad_shader_uiscircle = CGL_shader_get_uniform_location(g_context.quad_shader, "uiscircle");
}

void render_quad(float start_x, float start_y, float size_x, float size_y, float color_r, float color_g, float color_b)
{
    CGL_shader_bind(g_context.quad_shader);
    CGL_shader_set_uniform_vec2v(g_context.quad_shader, g_context.quad_shader_ustart, start_x + size_x/2.0f, start_y + size_y/2.0f);
    CGL_shader_set_uniform_vec2v(g_context.quad_shader, g_context.quad_shader_usize, size_x, size_y);
    CGL_shader_set_uniform_vec3v(g_context.quad_shader, g_context.quad_shader_ucolor, color_r, color_g, color_b);
    CGL_shader_set_uniform_bool(g_context.quad_shader, g_context.quad_shader_uiscolor, true);
    CGL_shader_set_uniform_bool(g_context.quad_shader, g_context.quad_shader_uiscircle, false);
    CGL_mesh_gpu_render(g_context.quad_mesh);
}

void render_circle(float pos_x, float pos_y, float radius, float color_r, float color_g, float color_b)
{
    CGL_shader_bind(g_context.quad_shader);
    CGL_shader_set_uniform_vec2v(g_context.quad_shader, g_context.quad_shader_ustart, pos_x, pos_y);
    CGL_shader_set_uniform_vec2v(g_context.quad_shader, g_context.quad_shader_usize, radius * 2.0f, radius * 2.0f * ASPECT_RATIO);
    CGL_shader_set_uniform_vec3v(g_context.quad_shader, g_context.quad_shader_ucolor, color_r, color_g, color_b);
    CGL_shader_set_uniform_bool(g_context.quad_shader, g_context.quad_shader_uiscolor, true);
    CGL_shader_set_uniform_bool(g_context.quad_shader, g_context.quad_shader_uiscircle, true);
    CGL_mesh_gpu_render(g_context.quad_mesh);
}

void render_quad_texture(float start_x, float start_y, float size_x, float size_y, CGL_texture* texture)
{
    CGL_shader_bind(g_context.quad_shader);
    CGL_shader_set_uniform_vec2v(g_context.quad_shader, g_context.quad_shader_ustart, start_x + size_x/2.0f, start_y + size_y/2.0f);
    CGL_shader_set_uniform_vec2v(g_context.quad_shader, g_context.quad_shader_usize, size_x, size_y);
    CGL_texture_bind(texture, 0);
    CGL_shader_set_uniform_int(g_context.quad_shader, g_context.quad_shader_utex, 0);
    CGL_shader_set_uniform_bool(g_context.quad_shader, g_context.quad_shader_uiscircle, false);
    CGL_shader_set_uniform_bool(g_context.quad_shader, g_context.quad_shader_uiscolor, false);
    CGL_mesh_gpu_render(g_context.quad_mesh);
}

void bake_game_over_text()
{
    CGL_font* font = CGL_font_load("font.ttf");
    CGL_font_build_atlas(font, 1024, 1024, 72);
    g_game.you_lose_text = CGL_text_bake_to_texture("You Lose", strlen("You Lose"), font, NULL, NULL);
    g_game.you_win_text = CGL_text_bake_to_texture("You Win", strlen("You Win"), font, NULL, NULL);
    g_game.instruction_text = CGL_text_bake_to_texture("Press R to restart", strlen("Press R to restart"), font, NULL, NULL);
    CGL_font_destory(font);
}

void handle_player_input()
{
    if(g_game.is_over || !g_game.allow_input) return;
    if(CGL_window_get_key(g_context.main_window, CGL_KEY_UP) == CGL_PRESS) g_game.player_height += PLAYER_SPEED * CGL_utils_clamp(g_game.speed_factor * 0.5f, 1.0f, 100.0f);
    if(CGL_window_get_key(g_context.main_window, CGL_KEY_DOWN) == CGL_PRESS) g_game.player_height -= PLAYER_SPEED * CGL_utils_clamp(g_game.speed_factor * 0.5f, 1.0f, 100.0f);
    g_game.player_height = CGL_utils_clamp(g_game.player_height, -1.0f + HITTER_HEIGHT/2.0f, 1.0f - HITTER_HEIGHT/2.0f);
}


void update_computer()
{
    if(g_game.is_over || g_game.allow_input) return; // do not give computer move is ball is in player area or game is over
    
    // the aim here is not creating a perfect AI or algorithm to win every time
    // but a kind of bad/weak logic so that the player also has a chance of winning

    /*
    // This logic is likely never to loose
    if((g_game.ball_pos_y - g_game.computer_height) > (HITTER_HEIGHT / 2.0f) )
        g_game.computer_height += PLAYER_SPEED;
    if((g_game.ball_pos_y - g_game.computer_height) < (HITTER_HEIGHT / 2.0f) )
        g_game.computer_height -= PLAYER_SPEED;
    */

    if(rand() % 100 > 95) g_game.computer_speed = CGL_utils_random_float() * g_game.speed_factor;
    if((g_game.ball_pos_y - g_game.computer_height) > (HITTER_HEIGHT / 2.0f) )
        g_game.computer_height += PLAYER_SPEED * g_game.computer_speed;
    if((g_game.ball_pos_y - g_game.computer_height) < (HITTER_HEIGHT / 2.0f) )
        g_game.computer_height -= PLAYER_SPEED * g_game.computer_speed;

    g_game.computer_height = CGL_utils_clamp(g_game.computer_height, -1.0f + HITTER_HEIGHT/2.0f, 1.0f - HITTER_HEIGHT/2.0f);
}

void update_ball()
{
    if(g_game.is_over) return;
    float curr_time = CGL_utils_get_time();
    float delta_time = CGL_utils_clamp(curr_time - g_game.prev_time, 0.0f, 0.2f);
    g_game.prev_time = curr_time;
    g_game.total_time += delta_time;
    g_game.speed_factor = 1.0f + 0.25f * logf(g_game.total_time + 1.0f) + 0.0002f * powf(logf(powf(g_game.total_time + 1, 2.0f)), 5.0f);
    g_game.speed_factor = CGL_utils_clamp(g_game.speed_factor, 0.5f, 10.0f);

    // now to make things insteresting ball speed should rise with time

    g_game.ball_pos_x += g_game.ball_velocity_x * delta_time * g_game.speed_factor;
    g_game.ball_pos_y += g_game.ball_velocity_y * delta_time * g_game.speed_factor;

    // allow player input only if ball is in player side
    g_game.allow_input = (g_game.ball_pos_x >= 0.0f);

    // handle collisions
    if(g_game.ball_pos_y <= (-1.0f + BALL_RADIUS + BORDER_THICKNESS))
        g_game.ball_velocity_y = (float)fabs(g_game.ball_velocity_y);
    if(g_game.ball_pos_y >= (1.0f - BALL_RADIUS - BORDER_THICKNESS))
        g_game.ball_velocity_y = -1.0f * (float)fabs(g_game.ball_velocity_y);
    if(g_game.ball_pos_x >= (1.0f - BALL_RADIUS - HITTER_WIDTH))
        g_game.ball_velocity_x = -1.0f * (float)fabs(g_game.ball_velocity_x);
    if(g_game.ball_pos_x <= (-1.0f + BALL_RADIUS + HITTER_WIDTH))
        g_game.ball_velocity_x = (float)fabs(g_game.ball_velocity_x);
    if ((g_game.ball_pos_y <= (-1.0f + BALL_RADIUS + BORDER_THICKNESS)) || (g_game.ball_pos_y >= (1.0f - BALL_RADIUS - BORDER_THICKNESS)) || (g_game.ball_pos_x >= (1.0f - BALL_RADIUS - HITTER_WIDTH)) || (g_game.ball_pos_x <= (-1.0f + BALL_RADIUS + HITTER_WIDTH)))
        if(rand() % 1000 > 980) 
            g_game.total_time = 0.0f;
}


void check_is_game_over()
{
    if(g_game.ball_pos_x >= (1.0f - BALL_RADIUS - HITTER_WIDTH))
    {
        if(fabs(g_game.ball_pos_y - g_game.player_height) >= (1.25f * HITTER_HEIGHT / 2.0f))
        {
            g_game.is_game_won = false;
            g_game.is_over = true;
        }
    }
        
    if(g_game.ball_pos_x <= (-1.0f + BALL_RADIUS + HITTER_WIDTH))
    {
        if(fabs(g_game.ball_pos_y - g_game.computer_height) >= (1.25f * HITTER_HEIGHT / 2.0f))
        {
            g_game.is_game_won = true;
            g_game.is_over = true;
        }
    }        
}


void reset_game()
{
    g_game.is_over = false;
    g_game.is_game_won = false;
    g_game.player_height = 0.0f;
    g_game.computer_height = 0.0f;
    g_game.computer_speed = CGL_utils_random_float();
    g_game.allow_input = true;
    g_game.ball_pos_x = 0.0f;
    g_game.ball_pos_y = 0.0f;
    g_game.ball_velocity_x = (CGL_utils_random_float() * 2.0f - 1.0f) * 0.4f;
    g_game.ball_velocity_y = (CGL_utils_random_float() * 2.0f - 1.0f) * 0.4f;
    g_game.prev_time = 0.0f;
    g_game.total_time = 0.0f;
    g_game.speed_factor = 1.0f;
}

int main()
{
    // setup cgl
    srand((uint32_t)time(NULL));    
    if(!CGL_init()) return EXIT_FAILURE;

    // setup window
    g_context.prev_window_height = (int)(640 / ASPECT_RATIO);
    g_context.prev_window_width = 640;
    g_context.main_window = CGL_window_create(g_context.prev_window_width, g_context.prev_window_height, "Pong -Jaysmito Mukherjee");
    if(!g_context.main_window) return EXIT_FAILURE;
    CGL_window_make_context_current(g_context.main_window);

    // setup opengl (glad)
    if(!CGL_gl_init()) return EXIT_FAILURE;

    // intialize CGL text
    if(!CGL_text_init()) return EXIT_FAILURE;

    bake_game_over_text();

    setup_quad_renderer();

    // pepare framebuffer
    g_context.main_framebuffer = CGL_framebuffer_create_from_default(g_context.main_window);

    reset_game();

    // main loop
    while(!CGL_window_should_close(g_context.main_window))
    {
        // render
        CGL_framebuffer_bind(g_context.main_framebuffer);
        CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);

        if(!g_game.is_over)
        {
            // highlight which side can move
            if(g_game.allow_input) render_quad(0.0f, -1.0f, 1.0f, 2.0f, 0.4f, 0.4f, 0.4f);
            else render_quad(-1.0f, -1.0f, 1.0f, 2.0f, 0.4f, 0.4f, 0.4f);

            // render hint if H is pressed
            // hint is a line showint the current position y of ball
            if(CGL_window_get_key(g_context.main_window, CGL_KEY_H) == CGL_PRESS) render_quad(-1.0f, g_game.ball_pos_y - BORDER_THICKNESS / 2.0f, 2.0f, BORDER_THICKNESS, HINT_LINE_COLOR);
        }

        // render board border
        render_quad(-1.0f, -1.0f, 2.0f, BORDER_THICKNESS, BORDER_COLOR); // bottom
        render_quad(-1.0f, 1.0f - BORDER_THICKNESS, 2.0f, BORDER_THICKNESS, BORDER_COLOR); // top
        render_quad(-1.0f, -1.0f, BORDER_THICKNESS/ASPECT_RATIO, 2.0f, BORDER_COLOR); // left
        render_quad(1.0f - BORDER_THICKNESS/ASPECT_RATIO, -1.0f, BORDER_THICKNESS, 2.0f, BORDER_COLOR); // right

        // render area seperator
        render_quad(-BORDER_THICKNESS/ASPECT_RATIO*0.5f, -1.0f, BORDER_THICKNESS/ASPECT_RATIO, 2.0f, COLOR_WHITE);

        // render player hitter
        render_quad(1.0f - HITTER_WIDTH, g_game.player_height - HITTER_HEIGHT / 2.0f, HITTER_WIDTH, HITTER_HEIGHT, COLOR_GREEN);
        // render computer hitter
        render_quad(-1.0f, g_game.computer_height - HITTER_HEIGHT / 2.0f, HITTER_WIDTH, HITTER_HEIGHT, COLOR_RED);

        // render ball
        render_circle(g_game.ball_pos_x, g_game.ball_pos_y, BALL_RADIUS, COLOR_WHITE);

        if(g_game.is_over)
        {
            // render the text info
            render_quad_texture(-0.5f, -0.3f, 1.0f, 0.7f, g_game.is_game_won ? g_game.you_win_text : g_game.you_lose_text);
            render_quad_texture(-0.5f, -0.7f, 1.0f, 0.125f, g_game.instruction_text);

            // reset the game on pressing R
            if(CGL_window_get_key(g_context.main_window, CGL_KEY_R) == CGL_PRESS) reset_game();
        }

        // seap buffer
        CGL_window_swap_buffers(g_context.main_window);
        // poll the events
        CGL_window_poll_events(g_context.main_window);

        // handle input and update g_game.player_height
        handle_player_input();

        // update computer move
        update_computer();
    
        // update ball position and velocity
        update_ball();

        // check if game over codition is met and decide whether game is won or lost by user
        check_is_game_over();

        // force window to stay in ASPECT_RATIO
        CGL_window_get_size(g_context.main_window, &g_context.prev_window_width, &g_context.prev_window_height);
        g_context.prev_window_width = (int)(g_context.prev_window_height * ASPECT_RATIO);
        CGL_window_set_size(g_context.main_window, g_context.prev_window_width, g_context.prev_window_height);

        // quit if escape is pressed (just a convinience)
        if(CGL_window_get_key(g_context.main_window, CGL_KEY_ESCAPE) == CGL_PRESS) break;
    }

    // cleanup
    CGL_texture_destroy(g_game.you_lose_text);
    CGL_texture_destroy(g_game.you_win_text);
    CGL_texture_destroy(g_game.instruction_text);

    CGL_text_shutdown();
    CGL_framebuffer_destroy(g_context.main_framebuffer);
    CGL_mesh_gpu_destroy(g_context.quad_mesh);
    CGL_shader_destroy(g_context.quad_shader);
    CGL_gl_shutdown();
    CGL_window_destroy(g_context.main_window);
    CGL_shutdown();
    return EXIT_SUCCESS;
}

```

`examples/c/procedural_sky.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#include "cgl.h"


#define MAIN_FRAME_BUFFER_WIDTH  800
#define MAIN_FRAME_BUFFER_HEIGHT (int)(MAIN_FRAME_BUFFER_WIDTH * (9.0f / 16.0f))


CGL_camera* camera;
CGL_vec3 cam_pos;
CGL_vec3 cam_rot;

static struct {
    float delta_x;
    float delta_y;
    float prev_x;
    float prev_y;
} mouse_input;


void input_scroll_callback(CGL_window* window, double x, double y)
{
    CGL_vec3 delta = CGL_camera_get_front(camera);
    delta = CGL_vec3_scale(delta, (float)y);
    cam_pos = CGL_vec3_add(cam_pos, delta);
    CGL_camera_set_position(camera, cam_pos);
}

void input_mouse_pos_callback(CGL_window* window, double x, double y)
{
    mouse_input.delta_x = ((float)x - mouse_input.prev_x);
    mouse_input.delta_y = ((float)y - mouse_input.prev_y);
    mouse_input.prev_x = (float)x;
    mouse_input.prev_y = (float)y;
}

int main()
{
    srand((uint32_t)time(NULL));
    if(!CGL_init()) return -1;
    CGL_window* main_window = CGL_window_create(640, 480, "Hello World");
    if(!main_window) return -1;
    CGL_window_make_context_current(main_window);
    if(!CGL_gl_init()) return -1;
    CGL_framebuffer* default_framebuffer = CGL_framebuffer_create_from_default(main_window);   
    
    CGL_mesh_cpu* cpu_mesh = CGL_mesh_cpu_load_obj("a.obj");
    CGL_mesh_gpu* mesh = CGL_mesh_gpu_create();
    CGL_mesh_gpu_upload(mesh, cpu_mesh, true);
    CGL_mesh_cpu_destroy(cpu_mesh);
    mouse_input.delta_x = 0.0f;
    mouse_input.delta_y = 0.0f;
    mouse_input.prev_x = 0.0f;
    mouse_input.prev_y = 0.0f;
    camera = CGL_camera_create();
    CGL_window_set_mouse_scroll_callback(main_window, input_scroll_callback);
    CGL_window_set_mouse_position_callback(main_window, input_mouse_pos_callback);

    CGL_sky* sky = CGL_sky_create();


    CGL_phong_pipeline* pipeline = CGL_phong_pipeline_create();
    CGL_phong_pipeline_add_light(pipeline, CGL_phong_light_directional(CGL_vec3_init(0, -1, 0), CGL_vec3_init(0.8f, 0.8f, 0.8f), 1.0f));

    CGL_phong_mat* material = CGL_phong_mat_create();
    CGL_phong_mat_set_diffuse_color(material, CGL_vec3_init(0.3f, 0.5f, 0.7f));
    CGL_phong_mat_set_specular_color(material, CGL_vec3_init(0.5f, 0.7f, 0.9f));
    CGL_mat4 model_matrix;
    model_matrix = CGL_mat4_translate(0.0f, 0.0f, 0.0f);

    CGL_window_resecure_callbacks(main_window);

    cam_pos = CGL_camera_get_position(camera);
    cam_rot = CGL_camera_get_rotation(camera);
    cam_pos.z += 3.0f;
    CGL_camera_set_position(camera, cam_pos);

    while(!CGL_window_should_close(main_window))
    { 
        model_matrix = CGL_mat4_translate(0, 0, 0);
        {
            CGL_framebuffer_bind(default_framebuffer);
            CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);

            int rx = 0, ry = 0;
            CGL_framebuffer_get_size(default_framebuffer, &rx, &ry);
            CGL_camera_set_aspect_ratio(camera, ((float)rx / ry));
            CGL_camera_recalculate_mat(camera);

            CGL_sky_render(sky, camera);

            CGL_phong_render_begin(pipeline, camera);
            CGL_phong_render(mesh, &model_matrix, material, pipeline, camera);
            CGL_phong_render_end(pipeline, camera);

        }

        CGL_window_poll_events(main_window);

        CGL_window_swap_buffers(main_window);
        if(CGL_window_get_mouse_button(main_window, CGL_MOUSE_BUTTON_MIDDLE) == CGL_PRESS)
        {            
            CGL_vec3 right = CGL_camera_get_right(camera);
            right = CGL_vec3_scale(right, (0.05f * mouse_input.delta_x));
            CGL_vec3 up = CGL_camera_get_up(camera);
            up = CGL_vec3_scale(up, (-0.05f * mouse_input.delta_y));
            cam_pos = CGL_vec3_add(cam_pos, up);
            cam_pos = CGL_vec3_add(cam_pos, right);
            CGL_camera_set_position(camera, cam_pos);
        }
        else if(CGL_window_get_mouse_button(main_window, CGL_MOUSE_BUTTON_RIGHT) == CGL_PRESS)
        {
            cam_rot.y += 0.005f * mouse_input.delta_x;
            cam_rot.z += 0.005f * mouse_input.delta_y;
            CGL_camera_set_rotation(camera, cam_rot);
        }

        if(CGL_window_get_key(main_window, CGL_KEY_B) == CGL_PRESS) CGL_sky_use_skybox(sky);
        if(CGL_window_get_key(main_window, CGL_KEY_S) == CGL_PRESS) CGL_sky_use_skysphere(sky);

        CGL_sky_procedural_set_time(sky, sinf(CGL_utils_get_time()*0.05f)*10.0f);

        mouse_input.delta_x = mouse_input.delta_y = 0.0f;
        if(CGL_window_get_key(main_window, CGL_KEY_ESCAPE) == CGL_PRESS) break;
    }

    CGL_sky_destroy(sky);

    CGL_phong_pipeline_destroy(pipeline);
    CGL_phong_mat_destroy(material);

    CGL_camera_destroy(camera);
    CGL_framebuffer_destroy(default_framebuffer);
    CGL_mesh_gpu_destroy(mesh);
    CGL_gl_shutdown();
    CGL_window_destroy(main_window);
    CGL_shutdown();
    return 0;
}

```

`examples/c/procedural_symmetric_design.c`:

```c
/*
MIT License
Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_EXCLUDE_NETWORKING
#define CGL_LOGGING_ENABLED
#define CGL_EXCLUDE_AUDIO
#define CGL_IMPLEMENTATION
#include "cgl.h"

static const char* PASS_THROUGH_VERTEX_SHADER_SOURCE = "#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 normal;\n"
"layout (location = 2) in vec4 texcoord;\n"
"\n"
"out vec3 Position;\n"
"out vec2 TexCoord;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = vec4(position.xyz, 1.0f);\n"
"	Position = position.xyz;\n"
"	TexCoord = texcoord.xy;\n"
"}";

static const char* PASS_THROUGH_FRAGMENT_SHADER_SOURCE = "#version 430 core\n"
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Position;\n"
"in vec2 TexCoord;\n"
"\n"
"uniform sampler2D u_tex;\n"
"\n"
"// Black Box From https://github.com/armory3d/armory/blob/master/Shaders/std/tonemap.glsl\n"
"vec3 acesFilm(const vec3 x) {\n"
"    const float a = 2.51;\n"
"    const float b = 0.03;\n"
"    const float c = 2.43;\n"
"    const float d = 0.59;\n"
"    const float e = 0.14;\n"
"    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	vec3 color = texture(u_tex, vec2(TexCoord.y, 1.0f - TexCoord.x)).rgb;\n"
"	color = acesFilm(color);\n"
"   color = pow(color, vec3(1.0f / 2.2f));\n"
"	FragColor = vec4(color, 1.0f);\n"
//"	FragColor = vec4(TexCoord, 0.0f, 1.0f);\n"
"}";


static const char* DRAW_COMPUTE_SHADER = "#version 430 core\n"
"\n"
"layout(local_size_x = 16, local_size_y = 16) in;\n"
"\n"
"layout(rgba32f, binding = 0) uniform image2D o_tex;\n"
"\n"
"uniform int u_mode;"
"uniform float u_brush_radius;\n"
"uniform vec2 u_splat_pt;\n"
"uniform vec3 u_brush_color;\n"
"\n"
"void apply_splat()\n"
"{\n"
"    vec2 UV = vec2(gl_GlobalInvocationID.xy) / vec2(imageSize(o_tex));\n"
"    vec2 p = UV - (u_splat_pt * 0.5f + vec2(0.5f));\n"
"    vec3 splat = exp(-dot(p, p) / (0.01f * u_brush_radius)) * u_brush_color;\n"
"    vec3 base = imageLoad(o_tex, ivec2(gl_GlobalInvocationID.xy)).rgb;\n"
"    imageStore(o_tex, ivec2(gl_GlobalInvocationID.xy), vec4(base + splat, 1.0f));\n"
"}\n"
"\n"
"void clear_splat()\n"
"{\n"
"    imageStore(o_tex, ivec2(gl_GlobalInvocationID.xy), vec4(0.0f, 0.0f, 0.0f, 1.0f));\n"
"}\n"
"\n"
"void diff_splat()\n"
"{\n"
"    vec2 UV = vec2(gl_GlobalInvocationID.xy) / vec2(imageSize(o_tex));\n"  
"    vec3 base = imageLoad(o_tex, ivec2(gl_GlobalInvocationID.xy)).rgb;\n"
"    imageStore(o_tex, ivec2(gl_GlobalInvocationID.xy), vec4(base * 0.9f, 1.0f));\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"    if(u_mode == 0) apply_splat();\n"
"    else if(u_mode == 1) clear_splat();\n"
"    else if(u_mode == 2) diff_splat();\n"
"}\n";

#define DISPATCH_ON_MODE(mode) \
{ \
    CGL_shader_bind(draw_compute_shader); \
    CGL_shader_set_uniform_int(draw_compute_shader, CGL_shader_get_uniform_location(draw_compute_shader, "u_mode"), mode); \
    CGL_shader_compute_dispatch(draw_compute_shader, 1024 / 16, 1024 / 16, 1); \
} 

#define RANDOM_POINT_COUNT 3

typedef struct
{
    CGL_vec2 pos;
    CGL_vec2 vel;
    CGL_vec2 acc;
    CGL_float radius;
} random_point;

CGL_vec3 calculate_color(CGL_float amt, CGL_float mx, CGL_float my)
{
	CGL_float r = 0.0f, g = 0.0f, b = 0.0f;
    r = CGL_noise_perlin(mx, my, 0.0f + amt) * 0.5f + 0.5f;
    g = CGL_noise_perlin(mx, my, 1.0f + amt) * 0.5f + 0.5f;
    b = CGL_noise_perlin(mx, my, 2.0f + amt) * 0.5f + 0.5f;
	return CGL_vec3_init(r, g, b);
}

CGL_float draw_for_point(CGL_shader* shader, CGL_float px, CGL_float py, CGL_float amt, CGL_float radius)
{
    CGL_vec3 draw_brush_color = calculate_color(amt, px, py);
    CGL_shader_set_uniform_vec2v(shader, CGL_shader_get_uniform_location(shader, "u_splat_pt"), (float)px, (float)py);
    CGL_shader_set_uniform_vec3v(shader, CGL_shader_get_uniform_location(shader, "u_brush_color"), draw_brush_color.x, draw_brush_color.y, draw_brush_color.z);
    CGL_shader_set_uniform_float(shader, CGL_shader_get_uniform_location(shader, "u_brush_radius"), radius);
    CGL_shader_compute_dispatch(shader, 1024 / 16, 1024 / 16, 1);
    return amt;
}

CGL_float draw_symmetrical_for_point(CGL_shader* shader, CGL_int symmetry_count, CGL_float px, CGL_float py, CGL_float amt, CGL_float radius)
{
    CGL_float px2 = 0.0f, py2 = 0.0f, angle = CGL_2PI / (CGL_float)symmetry_count;
    for (CGL_int i = 0; i < symmetry_count; i++)
    {
        px2 = (CGL_float)(px * cosf(angle * i) - py * sinf(angle * i));
        py2 = (CGL_float)(px * sinf(angle * i) + py * cosf(angle * i));
        draw_for_point(shader, px2, py2, amt, radius);
        draw_for_point(shader, px2, -py2, amt, radius);
    }
}

CGL_void update_random_points(random_point* pnts)
{
    // each point will get attracted to the other points
    for (CGL_int i = 0; i < RANDOM_POINT_COUNT; i++)
    {
        pnts[i].acc.x = pnts[i].acc.y = 0.0f;
        for (CGL_int j = 0; j < RANDOM_POINT_COUNT; j++)
        {
			if (i == j) continue;
			CGL_float dx = pnts[j].pos.x - pnts[i].pos.x;
			CGL_float dy = pnts[j].pos.y - pnts[i].pos.y;
			CGL_float dist = sqrtf(dx * dx + dy * dy);
			CGL_float force = 0.0f;
			if (dist < 0.01f) force = 0.0f;
			else force = 0.0001f / dist;
			pnts[i].acc.x += force * dx;
			pnts[i].acc.y += force * dy;
		}
        pnts[i].acc.x *= 2.0f; pnts[i].acc.y *= 2.0f;
        // add some noise to the acceleration
        pnts[i].acc.x += CGL_utils_random_float_in_range(-0.1f, 0.1f) * 4.0f;
        pnts[i].acc.y += CGL_utils_random_float_in_range(-0.1f, 0.1f) * 4.0f;
    }

    for (CGL_int i = 0; i < RANDOM_POINT_COUNT; i++)
    {
		pnts[i].pos.x += pnts[i].vel.x * 0.1f; pnts[i].pos.y += pnts[i].vel.y * 0.1f;
		pnts[i].vel.x += pnts[i].acc.x * 0.1f; pnts[i].vel.y += pnts[i].acc.y * 0.1f;
        pnts[i].vel.x = pnts[i].vel.x * 0.98f; pnts[i].vel.y = pnts[i].vel.y * 0.98f;
		if (pnts[i].pos.x < -1.0f || pnts[i].pos.x > 1.0f) pnts[i].vel.x *= -1.0f;
		if (pnts[i].pos.y < -1.0f || pnts[i].pos.y > 1.0f) pnts[i].vel.y *= -1.0f;
        pnts[i].pos.x = CGL_utils_clamp(pnts[i].pos.x, -0.9999f, 0.9999f);
        pnts[i].pos.y = CGL_utils_clamp(pnts[i].pos.y, -0.9999f, 0.9999f);
	}
}

int main()
{
    srand((uint32_t)time(NULL));
    CGL_init();
    CGL_window* window = CGL_window_create(700, 700, "Procedural Symmetrical Designer - Jaysmito Mukherjee");
    CGL_window_make_context_current(window); 
    CGL_gl_init();
    CGL_widgets_init();
    CGL_noise_init();
    if(window == NULL) return false; 
    CGL_framebuffer* default_framebuffer = CGL_framebuffer_create_from_default(window);
    CGL_shader* present_shader = CGL_shader_create(PASS_THROUGH_VERTEX_SHADER_SOURCE, PASS_THROUGH_FRAGMENT_SHADER_SOURCE, NULL);
    CGL_shader* draw_compute_shader = CGL_shader_compute_create(DRAW_COMPUTE_SHADER, NULL);
    CGL_texture* o_tex = CGL_texture_create_blank(1024, 1024, GL_RGBA, GL_RGBA32F, GL_FLOAT);
    CGL_int symmetry_count = 6;
    CGL_float draw_brush_radius = 0.02f, drawn_strokes_amount = 0.0f;

    random_point random_points[RANDOM_POINT_COUNT];

    for (CGL_int i = 0; i < RANDOM_POINT_COUNT; i++)
    {
        random_points[i].pos = CGL_utils_random_vec2(CGL_vec2_init(-1.0f, -1.0f), CGL_vec2_init(1.0f, 1.0f));
        random_points[i].vel = CGL_vec2_init(0.0f, 0.0f);
        random_points[i].acc = CGL_vec2_init(0.0f, 0.0f);
        random_points[i].radius = CGL_utils_random_float_in_range(0.01f, 0.005f);
    }

    while(!CGL_window_should_close(window)) 
    {
        CGL_window_set_size(window, 700, 700);
        CGL_framebuffer_bind(default_framebuffer);
        CGL_gl_clear(0.002f, 0.002f, 0.002f, 1.0f);

        if (CGL_window_get_mouse_button(window, CGL_MOUSE_BUTTON_LEFT) == CGL_PRESS)
        {
            glBindImageTexture(0, CGL_texture_get_internal_handle(o_tex), 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);

            double mouse_x, mouse_y;
            CGL_window_get_mouse_position(window, &mouse_x, &mouse_y);
            mouse_x = 1.0f - mouse_x / 700.0f; mouse_y = 1.0f - mouse_y / 700.0f;
            CGL_float px = (CGL_float)mouse_x * 2.0f - 1.0f, py = (CGL_float)mouse_y * 2.0f - 1.0f;
            CGL_shader_bind(draw_compute_shader);
            CGL_shader_set_uniform_int(draw_compute_shader, CGL_shader_get_uniform_location(draw_compute_shader, "u_mode"), 0);
            draw_symmetrical_for_point(draw_compute_shader, symmetry_count, px, py, drawn_strokes_amount, draw_brush_radius);
            drawn_strokes_amount += 0.01f;
        }

        update_random_points(random_points);

        if (CGL_window_is_key_pressed(window, CGL_KEY_R))
        {
            for (CGL_int i = 0; i < RANDOM_POINT_COUNT; i++)
            {
                CGL_shader_bind(draw_compute_shader);
                CGL_shader_set_uniform_int(draw_compute_shader, CGL_shader_get_uniform_location(draw_compute_shader, "u_mode"), 0);
                draw_symmetrical_for_point(draw_compute_shader, symmetry_count, random_points[i].pos.x, random_points[i].pos.y, drawn_strokes_amount, draw_brush_radius);
                //draw_for_point(draw_compute_shader, random_points[i].pos.x, random_points[i].pos.y, drawn_strokes_amount, random_points[i].radius);
                drawn_strokes_amount += 0.01f;
            }
        }

        CGL_shader_bind(present_shader);
        CGL_shader_set_uniform_int(present_shader, CGL_shader_get_uniform_location(present_shader, "u_tex"), CGL_texture_bind(o_tex, 0));
        CGL_gl_render_screen_quad();
    
        if (CGL_window_is_key_pressed(window, CGL_KEY_C)) DISPATCH_ON_MODE(1);
        if (CGL_window_is_key_pressed(window, CGL_KEY_D)) DISPATCH_ON_MODE(2);

        if (CGL_window_is_key_pressed(window, CGL_KEY_ESCAPE)) break;

        CGL_window_swap_buffers(window);
        CGL_window_poll_events(window);
    }

    CGL_texture_destroy(o_tex);
    CGL_shader_destroy(draw_compute_shader);
    CGL_shader_destroy(present_shader);
    CGL_framebuffer_destroy(default_framebuffer);
    CGL_noise_shutdown();
    CGL_widgets_shutdown();
    CGL_gl_shutdown();
    CGL_window_destroy(window);
    CGL_shutdown();
    return EXIT_SUCCESS;
}

```

`examples/c/realtime_volumetric_clouds.c`:

```c
/*
MIT License
Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_EXCLUDE_NETWORKING
#define CGL_EXCLUDE_SKY_RENDERER
#define CGL_EXCLUDE_PHONG_RENDERER
#define CGL_EXCLUDE_TILEMAP_RENDERER
#define CGL_IMPLEMENTATION
#include "cgl.h"


// set this to 0 to disable the ui and remove nuklear dependency
#define GUI_DEBUG 1

#if GUI_DEBUG
#pragma warning(push, 0)
#define NK_INCLUDE_FIXED_TYPES
#define NK_INCLUDE_STANDARD_IO
#define NK_INCLUDE_STANDARD_VARARGS
#define NK_INCLUDE_DEFAULT_ALLOCATOR
#define NK_INCLUDE_VERTEX_BUFFER_OUTPUT
#define NK_INCLUDE_FONT_BAKING
#define NK_INCLUDE_DEFAULT_FONT
#define NK_IMPLEMENTATION
#define NK_GLFW_GL3_IMPLEMENTATION
#define NK_KEYSTATE_BASED_INPUT
#include "nuklear.h"
#include "nuklear_glfw_gl4.h"
#pragma warning(pop)
#endif


#define SIZEX          1366
#define SIZEY          768

static const char* DIFFUSE_VERTEX_SHADER_SOURCE = 
  "#version 430 core\n"
  "\n"
  "layout (location = 0) in vec4 position;\n"
  "layout (location = 1) in vec4 normal;\n"
  "layout (location = 2) in vec4 texcoord;\n"
  "\n"
  "out vec2 v_texcoord;\n"
  "out vec3 v_normal;\n"
  "out vec3 v_position;\n"
  "\n"
  "uniform mat4 u_model;\n"
  "uniform mat4 u_view;\n"
  "uniform mat4 u_projection;\n"
  "uniform mat4 u_viewProjection;\n"
  "\n"
  "void main() {\n"
  "  v_texcoord = texcoord.xy;\n"
  "  v_normal = (u_model * normal).xyz;\n"
  "  v_position = (u_model * position).xyz;\n"
  "  gl_Position =  u_viewProjection * u_model * position;\n"
  "}\n";

static const char* DIFFUSE_FRAGMENT_SHADER_SOURCE = 
  "#version 430 core\n"
  "\n"
  "in vec2 v_texcoord;\n"
  "in vec3 v_normal;\n"
  "in vec3 v_position;\n"
  "\n"
  "out vec4 frag_color;\n"
  "\n"
  "uniform vec3 u_lightPos;\n"
  "uniform vec3 u_lightColor;\n"
  "uniform vec3 u_objectColor;\n"
  "\n"
  "vec3 aces(vec3 x) {\n"
  "  const float a = 2.51;\n"
  "  const float b = 0.03;\n"
  "  const float c = 2.43;\n"
  "  const float d = 0.59;\n"
  "  const float e = 0.14;\n"
  "  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n"
  "}\n"
  "\n"
  "float exponentialToLinear(float depth)\n"
  "{\n"
  "    float z = depth * 2.0 - 1.0;\n"
  "    return (2.0 * 0.1f * 100.0f) / (100.0f + 0.1f - z * (100.0f - 0.1f));\n"
  "}\n"
  "\n"
  "void main() {\n"
  " vec3 N = normalize(v_normal);\n"
  " vec3 L = normalize(u_lightPos - v_position);\n"
  " float NdotL = max(dot(N, L), 0.0);\n"
  " vec3 diffuse = u_lightColor * NdotL;\n"
  " vec3 ambient = vec3(0.1f, 0.1f, 0.1f);\n"
  " vec3 col = (ambient + diffuse) * u_objectColor;\n"
  //" col = aces(col);\n"
  //" col = pow(col, vec3(1.0f / 2.2f));\n"
  " frag_color = vec4(col, 1.0);\n"
  "}\n";

static const char* PRESENT_VERTEX_SHADER_SOURCE = 
  "#version 430 core\n"
  "\n"
  "layout (location = 0) in vec4 position;\n"
  "layout (location = 1) in vec4 normal;\n"
  "layout (location = 2) in vec4 texcoord;\n"
  "\n"
  "out vec2 v_texcoord;\n"
  "\n"
  "void main() {\n"
  "  v_texcoord = vec2(1.0 - texcoord.y, 1.0 - texcoord.x);\n"
  "  gl_Position = position;\n"
  "}\n";

static const char* PRESENT_FRAGMENT_SHADER_SOURCE =
  "#version 430 core\n"
  "\n"
  "in vec2 v_texcoord;\n"
  "\n"
  "out vec4 fragColor;\n"
  "\n"
  "uniform sampler2D u_texture;\n"
  "uniform sampler3D u_noiseTexture3d128;\n"
  "uniform sampler3D u_noiseTexture3d32;\n"
  "uniform sampler2D u_noiseTexture2d128;\n"
  "uniform float u_time;\n"
  "uniform float u_aspectRatio;\n"
  "uniform int u_vizMode;\n"
  "uniform int u_channel;\n"
  "uniform float u_slice;\n"
  "uniform float u_scale = 1.0f;\n"
  "uniform vec3 u_offset = vec3(0.0f, 0.0f, 0.0f);\n"
  "\n"
  "void main() {\n"
  " // if vizmode != 0 adjust the texcoord according to aspect ratio\n"
  " vec2 texcoord = v_texcoord;\n"
  " if (u_vizMode != 0) {\n"
  "   texcoord.x *= u_aspectRatio;\n"
  " }\n"
  "\n"
  " if (texcoord.x < 0.0f || texcoord.x > 1.0f || texcoord.y < 0.0f || texcoord.y > 1.0f) {\n"
  "   fragColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);\n"
  "   return;\n"
  " }\n"
  "\n"
  " if (u_vizMode == 0) {\n"
  "   fragColor = texture(u_texture, texcoord);\n"
  " } else if (u_vizMode == 1) {\n"
  "   vec4 col = texture(u_noiseTexture3d128, u_scale * ( u_offset + vec3(texcoord, u_slice)));\n"
  "   fragColor = vec4(vec3(col[u_channel]), 1.0f);\n"
  " } else if (u_vizMode == 2) {\n"
  "   vec4 col = texture(u_noiseTexture3d32, u_scale * ( u_offset + vec3(texcoord, u_slice)));\n"
  "   fragColor = vec4(vec3(col[u_channel]), 1.0f);\n"
  " } else if (u_vizMode == 3) {\n"
  "   vec4 col = texture(u_noiseTexture2d128, u_scale * ( u_offset.xy + vec2(texcoord)));\n"
  "   fragColor = vec4(vec3(col[u_channel]), 1.0f);\n"
  " } else {\n"
  "   fragColor = vec4(1.0f, 0.0f, 0.0f, 1.0f);\n"
  " }\n"
  "}\n";

static const char* CLOUDS_VERTEX_SHADER_SOURCE = 
  "#version 430 core\n"
  "\n"
  "layout (location = 0) in vec4 position;\n"
  "layout (location = 1) in vec4 normal;\n"
  "layout (location = 2) in vec4 texcoord;\n"
  "\n"
  "out vec2 v_texcoord;\n"
  "out vec3 v_normal;\n"
  "out vec3 v_position;\n"
  "out vec3 v_viewVector;\n"
  "\n"
  "uniform mat4 u_projection;\n"
  "uniform mat4 u_view;\n"
  "\n"
  "void main() {\n"
  "  vec2 uv = vec2(1.0 - texcoord.y, 1.0 - texcoord.x);\n"
  "  v_texcoord = uv;\n"
  "  vec3 viewVector = (inverse(u_projection) * vec4(uv * 2.0 - 1.0, 1.0, 1.0)).xyz;\n"
  "  v_viewVector = (inverse(u_view) * vec4(viewVector, 0.0)).xyz;\n"
  "  gl_Position = vec4(position.xy, 0.0, 1.0);\n"
  "}\n";

static const char* CLOUDS_FRAGMENT_SHADER_SOURCE = 
  "#version 430 core\n"
  "\n"
  "out vec4 fragColor;\n"
  "\n"
  "in vec2 v_texcoord;\n"
  "in vec3 v_viewVector;\n"
  "\n"
  "uniform sampler2D u_texture;\n"
  "uniform sampler2D u_depth;\n"
  "uniform sampler3D u_shapeNoise;\n"
  "uniform sampler3D u_detailNoise;\n"
  "uniform sampler2D u_curlNoise;\n"
  "\n"
  "uniform int u_numSteps;\n"
  "uniform int u_numLightSteps;\n"
  "\n"
  "uniform float u_lightAbsorptionThroughCloud;\n"
  "uniform float u_lightAbsorptionTowardsSun;\n"
  "uniform float u_densityFactor;\n"
  "uniform float u_scale;\n"
  "uniform float u_threshold;\n"
  "uniform float u_time;\n"
  "uniform float u_far;\n"
  "uniform float u_near;\n"
  "uniform float u_heightFactor;\n"
  "uniform float u_detailScale;\n"
  "uniform float u_animationSpeed;\n"
  "\n"
  "uniform vec3 u_offset;\n"
  "uniform vec3 u_detailOffset;\n"
  "uniform vec3 u_cameraPos;\n"
  "uniform vec3 u_lightPos;\n"
  "uniform vec3 u_lightColor;\n"
  "uniform vec3 u_cloudBoundsMin;\n"
  "uniform vec3 u_cloudBoundsMax;\n"
  "\n"
  "uniform vec4 u_shapeNoiseWeights;\n"
  "uniform vec4 u_detailNoiseWeights;\n"
  "uniform vec4 u_phaseParams;\n"
  "\n"
  "#define saturate(x) clamp(x, 0.0, 1.0)\n"
  "\n"
  "float remap01(float v, float low, float high) \n"
  "{\n"
  "    return (v-low)/(high-low);\n"
  "}\n"
  "\n"
  "vec2 rayBoxDst(vec3 boundsMin, vec3 boundsMax, vec3 rayOrigin, vec3 rayDir) \n"
  "{\n"
  "    vec3 t0 = (boundsMin - rayOrigin) / rayDir;\n"
  "    vec3 t1 = (boundsMax - rayOrigin) / rayDir;\n"
  "    vec3 tmin = min(t0, t1);\n"
  "    vec3 tmax = max(t0, t1);\n"
  "    \n"
  "    float dstA = max(max(tmin.x, tmin.y), tmin.z);\n"
  "    float dstB = min(tmax.x, min(tmax.y, tmax.z));\n"
  "\n"
  "    // CASE 1: ray intersects box from outside (0 <= dstA <= dstB)\n"
  "    // dstA is dst to nearest intersection, dstB dst to far intersection\n"
  "\n"
  "    // CASE 2: ray intersects box from inside (dstA < 0 < dstB)\n"
  "    // dstA is the dst to intersection behind the ray, dstB is dst to forward intersection\n"
  "\n"
  "    // CASE 3: ray misses box (dstA > dstB)\n"
  "\n"
  "    float dstToBox = max(0.0, dstA);\n"
  "    float dstInsideBox = max(0.0, dstB - dstToBox);\n"
  "    return vec2(dstToBox, dstInsideBox);\n"
  "}\n"
  "\n"
  "float exponentialToLinear(float depth)\n"
  "{\n"
  "    float z = depth * 2.0 - 1.0;\n"
  "    return (2.0 * u_near * u_far) / (u_far + u_near - z * (u_far - u_near));\n"
  "}\n"
  "\n"
  "\n"
  "float sampleDensity(vec3 pos)\n"
  "{\n"
  "    vec3 shapeAnimOffset = vec3(u_time, 0.0, 0.0) * u_animationSpeed;\n"
  "    vec3 detailAnimOffset = vec3(u_time, 0.0, 0.0) * u_animationSpeed * 1.3;\n"
  "\n"
  "    vec3 uvw = (pos + u_offset + shapeAnimOffset) * u_scale;\n"
  "\n"
  "    float heightPercent = (pos.y - u_cloudBoundsMin.y) / (u_cloudBoundsMax.y - u_cloudBoundsMin.y);\n"
  "    const float gMin = 0.4, gMax = 0.6;\n"
  "    float heightGrad = saturate(remap01(heightPercent, 0.0, gMin)) * saturate(remap01(heightPercent, 1.0, gMax));\n"
  "    heightGrad = pow(heightGrad, u_heightFactor);\n"
  "\n"
  "    vec4 normalizedNoiseWeights = u_shapeNoiseWeights / dot(u_shapeNoiseWeights, vec4(1.0));\n"
  "    float density = dot(texture(u_shapeNoise, uvw * 0.03), normalizedNoiseWeights) * heightGrad;\n"
  "    density = density - u_threshold;\n"
  "    density = max(0.0, density);\n"
  "\n"
  "    if (density > 0.0f)\n"
  "    {\n"
  "        vec3 detailuvw = (pos + u_detailOffset + detailAnimOffset) * u_detailScale;\n"
  "        vec4 normalizedDetailWeights = u_detailNoiseWeights / dot(u_detailNoiseWeights, vec4(1.0));\n"
  "        float detail = dot(texture(u_detailNoise, detailuvw * 0.03), normalizedDetailWeights);\n"
  "\n"
  "        float oneMinusDetail = 1.0 - detail;\n"
  "        density = density * oneMinusDetail * oneMinusDetail * oneMinusDetail;\n"
  "    }\n"
  "\n"
  "    return density * u_densityFactor;\n"
  "}\n"
  "\n"
  "\n"
  "// Henyey-Greenstein phase function\n"
  "float hg(float a, float g)\n"
  "{\n"
  "    float g2 = g * g;\n"
  "    float denom = pow(1.0 + g2 - 2.0 * g * a, 1.5) * 4.0 * 3.14159;\n"
  "    return (1.0 - g2) / denom;\n"
  "}\n"
  "\n"
  "\n"
  "float phase(in vec3 rayDir, in vec3 pos)\n"
  "{\n"
  "    vec3 lightDir = normalize(u_lightPos - pos);\n"
  "    float cosAngle = dot(rayDir, lightDir);\n"
  "\n"
  "    float blend = 0.5f;\n"
  "\n"
  "    float hgBlend = hg(cosAngle, u_phaseParams.x) * (1.0 - blend) + hg(cosAngle, -u_phaseParams.y) * blend;\n"
  "    return u_phaseParams.z + hgBlend * u_phaseParams.w;\n"
  "}\n"
  "\n"
  "float lightmarch(vec3 pos)\n"
  "{\n"
  "    vec3 dirToLight = normalize(u_lightPos - pos);\n"
  "\n"
  "    vec2 dst = rayBoxDst(u_cloudBoundsMin, u_cloudBoundsMax, pos, dirToLight);\n"
  "    float dstToBox = dst.x;\n"
  "    float dstInsideBox = dst.y;\n"
  "\n"
  "    float dstStep = dstInsideBox / float(u_numLightSteps);\n"
  "    float totalDensity = 0.0;\n"
  "\n"
  "    for (int i = 0; i < u_numLightSteps; i++)\n"
  "    {\n"
  "        vec3 rayPos = pos + dirToLight * (dstToBox + dstStep * float(i));\n"
  "        totalDensity += sampleDensity(rayPos) * dstStep; \n"
  "    }\n"
  "\n"
  "    float transmittance = exp(-totalDensity * u_lightAbsorptionTowardsSun);\n"
  "    return transmittance;\n"
  "}\n"
  "\n"
  "\n"
  "void main()\n"
  "{\n"
  "    vec3 color = texture(u_texture, v_texcoord).rgb;\n"
  "    float depth = exponentialToLinear(texture(u_depth, v_texcoord).r);\n"
  "\n"
  "    vec3 rayOrigin = u_cameraPos;\n"
  "    vec3 rayDir = normalize(v_viewVector);\n"
  "\n"
  "    vec2 dst = rayBoxDst(u_cloudBoundsMin, u_cloudBoundsMax, rayOrigin, rayDir);\n"
  "    float dstToBox = dst.x;\n"
  "    float dstInsideBox = dst.y;\n"
  "\n"
  "    float dstTraveled = 0.0;\n"
  "    float dstStep = dstInsideBox / float(u_numSteps);\n"
  "    float dstLimit = min(depth - dstToBox, dstInsideBox);\n"
  "\n"
  "    vec3 rayPos = vec3(0.0);\n"
  "    float transmittance = 1.0f;\n"
  "    vec3 lightEnergy = vec3(0.0);\n"
  "    float phaseValue = 0.0;\n"
  "\n"
  "    while (dstTraveled < dstLimit)\n"
  "    {\n"
  "        rayPos = rayOrigin + rayDir * (dstToBox + dstTraveled);\n"
  "        phaseValue = phase(rayDir, rayPos);\n"
  "\n"
  "        float density = sampleDensity(rayPos);\n"
  "\n"
  "        if (density > 0.0) \n"
  "        {\n"
  "            float lightTransmittance = lightmarch(rayPos);\n"
  "\n"
  "            lightEnergy += density * dstStep * transmittance * lightTransmittance * phaseValue;\n"
  "            transmittance *= exp(-density * dstStep * u_lightAbsorptionThroughCloud);\n"
  "\n"
  "            if (transmittance < 0.01) \n"
  "            {\n"
  "                break;\n"
  "            }\n"
  "        }\n"
  "\n"
  "        dstTraveled += dstStep;\n"
  "    }\n"
  "\n"
  "    color = color * transmittance + lightEnergy * u_lightColor;\n"
  "\n"
  "    fragColor = vec4(color, 1.0);\n"
  "}\n";


static const char* CLOUDS_COMPUTE_SHADER_SOURCE = 
  "#version 430 core\n"
  "\n"
  "layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;\n"
  "\n"
  "layout(rgba32f, binding = 0) uniform image3D u_3d128;\n"
  "layout(rgba32f, binding = 1) uniform image3D u_3d32;\n"
  "layout(rgba32f, binding = 2) uniform image2D u_2d128;\n"
  "\n"
  "uniform int u_mode;\n"
  "uniform int u_width;\n"
  "uniform int u_height;\n"
  "uniform int u_depth;\n"
  "uniform float u_startingScale;\n"
  "\n"
  "#define MOD3 vec3(.1031,.11369,.13787)\n"
  "\n"
  "vec3 hash33(vec3 p3)\n"
  "{\n"
  "	p3 = fract(p3 * MOD3);\n"
  "    p3 += dot(p3, p3.yxz+19.19);\n"
  "    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n"
  "}\n"
  "\n"
  "ivec3 wrapNeghbour(ivec3 v, int numCells, inout vec3 boxOffset)\n"
  "{\n"
  "	for (int i = 0 ; i < 3 ; i++)\n"
  "	{\n"
  "		if (v[i] < 0)\n"
  "		{\n"
  "			v[i] += numCells;\n"
  "			boxOffset[i] = -1.0;\n"
  "		}\n"
  "		else if (v[i] >= numCells)\n"
  "		{\n"
  "			v[i] -= numCells;\n"
  "			boxOffset[i] = 1.0;\n"
  "		}\n"
  "		else \n"
  "		{\n"
  "			boxOffset[i] = 0.0;\n"
  "		}\n"
  "	}\n"
  "\n"
  "	return ivec3(mod(v.x, numCells), mod(v.y, numCells), mod(v.z, numCells));\n"
  "}\n"
  "\n"
  "// From: https://www.shadertoy.com/view/3d3fWN\n"
  "float worley(vec3 p, float scale){\n"
  "\n"
  "    vec3 id = floor(p*scale);\n"
  "    vec3 fd = fract(p*scale);\n"
  "\n"
  "    float n = 0.;\n"
  "\n"
  "    float minimalDist = 1.;\n"
  "\n"
  "    for(float x = -1.; x <=1.; x++){\n"
  "        for(float y = -1.; y <=1.; y++){\n"
  "            for(float z = -1.; z <=1.; z++){\n"
  "\n"
  "                vec3 coord = vec3(x,y,z);\n"
  "                vec3 rId = hash33(mod(id+coord,scale))*0.5+0.5;\n"
  "\n"
  "                vec3 r = coord + rId - fd; \n"
  "\n"
  "                float d = dot(r,r);\n"
  "\n"
  "                if(d < minimalDist){\n"
  "                    minimalDist = d;\n"
  "                }\n"
  "\n"
  "            }//z\n"
  "        }//y\n"
  "    }//x\n"
  "    \n"
  "    return sqrt(minimalDist);\n"
  "}\n"
  "\n"
  "\n"
  "float perlin_noise(vec3 p)\n"
  "{\n"
  "    vec3 pi = floor(p);\n"
  "    vec3 pf = p - pi;\n"
  "    \n"
  "    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n"
  "    \n"
  "    return 	mix(\n"
  "        		mix(\n"
  "                	mix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n"
  "                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n"
  "                       	w.x),\n"
  "                	mix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n"
  "                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n"
  "                       	w.x),\n"
  "                	w.z),\n"
  "        		mix(\n"
  "                    mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n"
  "                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n"
  "                       	w.x),\n"
  "                   	mix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n"
  "                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n"
  "                       	w.x),\n"
  "                	w.z),\n"
  "    			w.y);\n"
  "}\n"
  "\n"
  "vec4 worley3CH(vec3 uv)\n"
  "{\n"
  "    float worleyNoise0 = 1.0 - worley(uv * float(u_startingScale), 4);\n"
  "    float worleyNoise1 = 1.0 - worley(uv * float(u_startingScale), 8);\n"
  "    float worleyNoise2 = 1.0 - worley(uv * float(u_startingScale), 16);\n"
  "    float worleyNoise3 = 1.0 - worley(uv * float(u_startingScale), 32);\n"
  "\n"
  "    float worleyFBM0 = worleyNoise0*0.625f + worleyNoise1*0.25f + worleyNoise2*0.125f;\n"
  "	float worleyFBM1 = worleyNoise1*0.625f + worleyNoise2*0.25f + worleyNoise3*0.125f;\n"
  "	float worleyFBM2 = worleyNoise2*0.75f + worleyNoise3*0.25f; \n"
  "\n"
  "\n"
  "    vec4 color = vec4(\n"
  "        worleyFBM0,\n"
  "        worleyFBM1,\n"
  "        worleyFBM2,\n"
  "        worleyNoise0\n"
  "    );\n"
  "\n"
  "    return color;\n"
  "}\n"
  "\n"
  "\n"
  "//----------------------------------------------------------------------------------------\n"
  "vec3 HashALU(in vec3 p, in float numCells)\n"
  "{\n"
  "	// This is tiling part, adjusts with the scale\n"
  "	p = mod(p, numCells);\n"
  "	\n"
  "    p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n"
  "			  dot(p,vec3(269.5,183.3,246.1)),\n"
  "			  dot(p,vec3(113.5,271.9,124.6)));\n"
  "\n"
  "	return -1.0 + fract(sin(p)*43758.5453123) * 2.0;\n"
  "}\n"
  "\n"
  "#define Hash HashALU\n"
  "\n"
  "//----------------------------------------------------------------------------------------\n"
  "float TileableNoise(in vec3 p, in float numCells )\n"
  "{\n"
  "	vec3 f, i;\n"
  "	\n"
  "	p *= numCells;\n"
  "\n"
  "	\n"
  "	f = fract(p);		// Separate integer from fractional\n"
  "    i = floor(p);\n"
  "	\n"
  "    vec3 u = f*f*(3.0-2.0*f); // Cosine interpolation approximation\n"
  "\n"
  "    return mix( mix( mix( dot( Hash( i + vec3(0.0,0.0,0.0), numCells ), f - vec3(0.0,0.0,0.0) ), \n"
  "                          dot( Hash( i + vec3(1.0,0.0,0.0), numCells ), f - vec3(1.0,0.0,0.0) ), u.x),\n"
  "                     mix( dot( Hash( i + vec3(0.0,1.0,0.0), numCells ), f - vec3(0.0,1.0,0.0) ), \n"
  "                          dot( Hash( i + vec3(1.0,1.0,0.0), numCells ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n"
  "                mix( mix( dot( Hash( i + vec3(0.0,0.0,1.0), numCells ), f - vec3(0.0,0.0,1.0) ), \n"
  "                          dot( Hash( i + vec3(1.0,0.0,1.0), numCells ), f - vec3(1.0,0.0,1.0) ), u.x),\n"
  "                     mix( dot( Hash( i + vec3(0.0,1.0,1.0), numCells ), f - vec3(0.0,1.0,1.0) ), \n"
  "                          dot( Hash( i + vec3(1.0,1.0,1.0), numCells ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n"
  "}\n"
  "\n"
  "float TileableNoiseFBM(in vec3 p, float numCells, int octaves)\n"
  "{\n"
  "	float f = 0.0;\n"
  "    \n"
  "	// Change starting scale to any integer value...\n"
  "    p = mod(p, vec3(numCells));\n"
  "	float amp = 0.5;\n"
  "    float sum = 0.0;\n"
  "	\n"
  "	for (int i = 0; i < octaves; i++)\n"
  "	{\n"
  "		f += TileableNoise(p, numCells) * amp;\n"
  "        sum += amp;\n"
  "		amp *= 0.5;\n"
  "\n"
  "		// numCells must be multiplied by an integer value...\n"
  "		numCells *= 2.0;\n"
  "	}\n"
  "\n"
  "	return f / sum;\n"
  "}\n"
  "\n"
  "vec3 snoiseVec3( vec3 x )\n"
  "{\n"
  "  float numCells = 6.0;\n"
  "  int octaves = 3;\n"
  "   \n"
  "  float s  = TileableNoiseFBM(vec3( x ), numCells, octaves);\n"
  "  float s1 = TileableNoiseFBM(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ), numCells, octaves);\n"
  "  float s2 = TileableNoiseFBM(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ), numCells, octaves);\n"
  "  vec3 c = vec3( s , s1 , s2 );\n"
  "  return c;\n"
  "\n"
  "}\n"
  "\n"
  "vec3 curlNoise(vec3 p)\n"
  "{\n"
  "  const float e = .1;\n"
  "  vec3 dx = vec3( e   , 0.0 , 0.0 );\n"
  "  vec3 dy = vec3( 0.0 , e   , 0.0 );\n"
  "  vec3 dz = vec3( 0.0 , 0.0 , e   );\n"
  "\n"
  "  vec3 p_x0 = snoiseVec3( p - dx );\n"
  "  vec3 p_x1 = snoiseVec3( p + dx );\n"
  "  vec3 p_y0 = snoiseVec3( p - dy );\n"
  "  vec3 p_y1 = snoiseVec3( p + dy );\n"
  "  vec3 p_z0 = snoiseVec3( p - dz );\n"
  "  vec3 p_z1 = snoiseVec3( p + dz );\n"
  "\n"
  "  float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\n"
  "  float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\n"
  "  float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\n"
  "\n"
  "  const float divisor = 1.0 / ( 2.0 * e );\n"
  "  return normalize( vec3( x , y , z ) * divisor );\n"
  "}\n"
  "\n"
  "\n"
  "void gen3d128() {\n"
  "    ivec3 coord = ivec3(gl_GlobalInvocationID.xyz);\n"
  "    vec3 uv = vec3(coord) / vec3(u_width, u_height, u_depth);\n"
  "\n"
  "    vec4 color = worley3CH(uv);\n"
  "    color.gba = color.rgb;\n"
  "    color.r = perlin_noise(uv * u_startingScale) * 0.5 + 0.5 + color.g;\n"
  "    \n"
  "    imageStore(u_3d128, coord, color);\n"
  "}\n"
  "\n"
  "void gen3d32() {\n"
  "    ivec3 coord = ivec3(gl_GlobalInvocationID.xyz);\n"
  "    vec3 uv = vec3(coord) / vec3(u_width, u_height, u_depth);\n"
  "\n"
  "    imageStore(u_3d32, coord, worley3CH(uv));\n"
  "}\n"
  "\n"
  "void gen2d128() {\n"
  "    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);\n"
  "    vec2 uv = vec2(coord) / vec2(u_width, u_height);\n"
  "\n"
  "    vec4 color =  vec4(curlNoise(vec3(uv, 0.0)), 1.0);\n"
  "\n"
  "    imageStore(u_2d128, coord, color);\n"
  "}\n"
  "\n"
  "\n"
  "void main() {\n"
  "    if (u_mode == 0) {\n"
  "        gen3d128();\n"
  "    } else if (u_mode == 1) {\n"
  "        gen3d32();\n"
  "    } else if (u_mode == 2) {\n"
  "        gen2d128();\n"
  "    }\n"
  "}\n";

static struct 
{
  struct 
  {
    CGL_window* window;
    CGL_framebuffer* framebuffer;
    CGL_shader* presentShader;
    CGL_float time;
    CGL_float deltaTime;
    CGL_int frame;

    CGL_int vizMode;
    CGL_int vizChannel;
    CGL_float vizSlice;
    CGL_float vizScale;
    CGL_vec3 vizOffset;
  } core;


  struct 
  {
    CGL_mesh_gpu* cube;
    CGL_mesh_gpu* sphere;
    CGL_shader* diffuseShader;
    CGL_framebuffer* framebuffer;
    CGL_mat4 modelMat;

    struct 
    {
      CGL_vec3 position;
      CGL_vec3 color;
    } light;

    struct 
    {
      CGL_float fov;
      CGL_float aspect;
      CGL_float nearV;
      CGL_float farV;
      CGL_vec3 position;
      CGL_vec3 target;
      CGL_mat4 viewMat;
      CGL_mat4 projectionMat;
      CGL_mat4 viewProjectionMat;
      float moveSpeed;
    } camera;
  } scene;


  struct 
  {
    CGL_framebuffer* framebuffer;
    CGL_shader* shader;

    CGL_shader* noiseShader;

    CGL_texture* noiseTexture3d128;
    CGL_texture* noiseTexture3d32;
    CGL_texture* noiseTexture2d128;

    CGL_float noiseStartingScale[3];
    CGL_float noiseScaleFactor[3];

    CGL_vec3 boundsMin;
    CGL_vec3 boundsMax;
    CGL_vec4 phaseParams;

    CGL_float lightAbsorptionThroughSun;
    CGL_float lightAbsorptionThroughCloud;

    CGL_float densityFactor;
    CGL_float scale;
    CGL_float threshold;
    CGL_vec3 offset;
    CGL_float heightFactor;
    CGL_vec4 shapeNoiseWeights;

    CGL_float detailScale;
    CGL_vec3 detailOffset;
    CGL_vec4 detailNoiseWeights;

    CGL_float animationSpeed;

    CGL_int numSteps;    
    CGL_int numLightSteps;    

  } cloud;

  struct 
  {
    CGL_vec2 mousePos;
    CGL_vec2 mouseDelta;

    struct 
    {
      CGL_bool left;
      CGL_bool right;
      CGL_bool middle;
    } mouseButton;
  } input;

#if GUI_DEBUG

  struct 
  {
    struct nk_context* ctx;
    struct nk_colorf bg;
    struct nk_glfw glfw;
  } nuklearData;

#endif

} g_Context;

void setup_camera()
{
  CGL_int width, height;
  CGL_window_get_size(g_Context.core.window, &width, &height);
  g_Context.scene.camera.aspect = (float)width / (float)height;
  g_Context.scene.camera.fov = CGL_deg_to_rad(60.0f);
  g_Context.scene.camera.nearV = 0.1f;
  g_Context.scene.camera.farV = 100.0f;

  g_Context.scene.camera.moveSpeed = 8.0f;
}

void calculate_camera()
{
  g_Context.scene.camera.viewMat = CGL_mat4_look_at(g_Context.scene.camera.position, g_Context.scene.camera.target, CGL_vec3_init(0.0001f, 1.001f, 0.0001f));
  g_Context.scene.camera.projectionMat = CGL_mat4_perspective(g_Context.scene.camera.fov, g_Context.scene.camera.aspect, g_Context.scene.camera.nearV, g_Context.scene.camera.farV);
  g_Context.scene.camera.viewProjectionMat = CGL_mat4_mul(g_Context.scene.camera.projectionMat, g_Context.scene.camera.viewMat);
}

void generate_noise_data()
{
  CGL_info("Generating noise data...");

  CGL_float startTime = CGL_utils_get_time();

  glBindImageTexture(0, CGL_texture_get_internal_handle(g_Context.cloud.noiseTexture3d128), 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
  glBindImageTexture(1, CGL_texture_get_internal_handle(g_Context.cloud.noiseTexture3d32), 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
  glBindImageTexture(2, CGL_texture_get_internal_handle(g_Context.cloud.noiseTexture2d128), 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);


  // the 128x128x128 4-channel perlin worley noise
  CGL_shader_bind(g_Context.cloud.noiseShader);
  CGL_shader_set_uniform_int(g_Context.cloud.noiseShader, CGL_shader_get_uniform_location(g_Context.cloud.noiseShader, "u_mode"), 0);
  CGL_shader_set_uniform_int(g_Context.cloud.noiseShader, CGL_shader_get_uniform_location(g_Context.cloud.noiseShader, "u_width"), 128);
  CGL_shader_set_uniform_int(g_Context.cloud.noiseShader, CGL_shader_get_uniform_location(g_Context.cloud.noiseShader, "u_height"), 128);
  CGL_shader_set_uniform_int(g_Context.cloud.noiseShader, CGL_shader_get_uniform_location(g_Context.cloud.noiseShader, "u_depth"), 128);
  CGL_shader_set_uniform_float(g_Context.cloud.noiseShader, CGL_shader_get_uniform_location(g_Context.cloud.noiseShader, "u_startingScale"), g_Context.cloud.noiseStartingScale[0]);
  CGL_shader_set_uniform_float(g_Context.cloud.noiseShader, CGL_shader_get_uniform_location(g_Context.cloud.noiseShader, "u_scaleFactor"), g_Context.cloud.noiseScaleFactor[0]);
  CGL_shader_compute_dispatch(g_Context.cloud.noiseShader, 128 / 16, 128 / 16, 128);



  // the 32x32x32 4-channel worley noise (here its 64)
  CGL_shader_bind(g_Context.cloud.noiseShader);
  CGL_shader_set_uniform_int(g_Context.cloud.noiseShader, CGL_shader_get_uniform_location(g_Context.cloud.noiseShader, "u_mode"), 1);
  CGL_shader_set_uniform_int(g_Context.cloud.noiseShader, CGL_shader_get_uniform_location(g_Context.cloud.noiseShader, "u_width"), 64);
  CGL_shader_set_uniform_int(g_Context.cloud.noiseShader, CGL_shader_get_uniform_location(g_Context.cloud.noiseShader, "u_height"), 64);
  CGL_shader_set_uniform_int(g_Context.cloud.noiseShader, CGL_shader_get_uniform_location(g_Context.cloud.noiseShader, "u_depth"), 64);
  CGL_shader_set_uniform_float(g_Context.cloud.noiseShader, CGL_shader_get_uniform_location(g_Context.cloud.noiseShader, "u_startingScale"), g_Context.cloud.noiseStartingScale[1]);
  CGL_shader_set_uniform_float(g_Context.cloud.noiseShader, CGL_shader_get_uniform_location(g_Context.cloud.noiseShader, "u_scaleFactor"), g_Context.cloud.noiseScaleFactor[1]);
  CGL_shader_compute_dispatch(g_Context.cloud.noiseShader, 64 / 16, 64 / 16, 64);

  // the 128x128 2-channel curl noise
  CGL_shader_bind(g_Context.cloud.noiseShader);
  CGL_shader_set_uniform_int(g_Context.cloud.noiseShader, CGL_shader_get_uniform_location(g_Context.cloud.noiseShader, "u_mode"), 2);
  CGL_shader_set_uniform_int(g_Context.cloud.noiseShader, CGL_shader_get_uniform_location(g_Context.cloud.noiseShader, "u_width"), 128);
  CGL_shader_set_uniform_int(g_Context.cloud.noiseShader, CGL_shader_get_uniform_location(g_Context.cloud.noiseShader, "u_height"), 128);
  CGL_shader_set_uniform_float(g_Context.cloud.noiseShader, CGL_shader_get_uniform_location(g_Context.cloud.noiseShader, "u_startingScale"), g_Context.cloud.noiseStartingScale[2]);
  CGL_shader_set_uniform_float(g_Context.cloud.noiseShader, CGL_shader_get_uniform_location(g_Context.cloud.noiseShader, "u_scaleFactor"), g_Context.cloud.noiseScaleFactor[2]);
  CGL_shader_compute_dispatch(g_Context.cloud.noiseShader, 128 / 16, 128 / 16, 1);


  
  CGL_float endTime = CGL_utils_get_time();
  CGL_info("Noise data generated in %f seconds", endTime - startTime);
}

void setup_scene() 
{
  // Setup Meshes
  CGL_mesh_cpu* cube = CGL_mesh_cpu_cube(false);
  CGL_mesh_cpu_recalculate_normals(cube);

  CGL_mesh_cpu* sphere = CGL_mesh_cpu_sphere(32, 32);
  CGL_mesh_cpu_recalculate_normals(sphere);

  g_Context.scene.cube = CGL_mesh_gpu_create();
  CGL_mesh_gpu_upload(g_Context.scene.cube, cube, true);
  CGL_mesh_cpu_destroy(cube);

  g_Context.scene.sphere = CGL_mesh_gpu_create();
  CGL_mesh_gpu_upload(g_Context.scene.sphere, sphere, true);
  CGL_mesh_cpu_destroy(sphere);

  // Setup Framebuffer
  g_Context.scene.framebuffer = CGL_framebuffer_create(SIZEX, SIZEY);
  g_Context.cloud.framebuffer = CGL_framebuffer_create(SIZEX, SIZEY);

  // Setup Shaders
  g_Context.scene.diffuseShader = CGL_shader_create(DIFFUSE_VERTEX_SHADER_SOURCE, DIFFUSE_FRAGMENT_SHADER_SOURCE, NULL);
  g_Context.core.presentShader = CGL_shader_create(PRESENT_VERTEX_SHADER_SOURCE, PRESENT_FRAGMENT_SHADER_SOURCE, NULL);



  // Setup Light
  g_Context.scene.light.position = CGL_vec3_init(10.0f, 10.0f, 10.0f);
  g_Context.scene.light.color = CGL_vec3_init(1.0f, 1.0f, 1.0f);  

  // Setup Camera
  g_Context.scene.camera.position = CGL_vec3_init(8.0f, 8.0f, 8.0f);
  g_Context.scene.camera.target = CGL_vec3_init(0.0f, 1.0f, 0.0f);
  setup_camera();
  calculate_camera();

  // Setup Clouds
  // g_Context.cloud.noiseShader = CGL_shader_compute_create_from_files("compute.glsl", NULL);
  g_Context.cloud.noiseShader = CGL_shader_compute_create(CLOUDS_COMPUTE_SHADER_SOURCE, NULL);

  // CGL_byte* cloudFragShaderSource = CGL_utils_read_file("frag.glsl", NULL);
  // g_Context.cloud.shader = CGL_shader_create(CLOUDS_VERTEX_SHADER_SOURCE, cloudFragShaderSource, NULL);
  // CGL_free(cloudFragShaderSource);
  g_Context.cloud.shader = CGL_shader_create(CLOUDS_VERTEX_SHADER_SOURCE, CLOUDS_FRAGMENT_SHADER_SOURCE, NULL);

  g_Context.cloud.noiseTexture3d128 = CGL_texture_create_3d(128, 128, 128, GL_RGBA, GL_RGBA32F, GL_FLOAT);
  g_Context.cloud.noiseTexture3d32 = CGL_texture_create_3d(64, 64, 64, GL_RGBA, GL_RGBA32F, GL_FLOAT);
  g_Context.cloud.noiseTexture2d128 = CGL_texture_create_blank(128, 128, GL_RGBA, GL_RGBA32F, GL_FLOAT);  
  g_Context.core.vizChannel = 0;
  g_Context.core.vizMode = 0;

  generate_noise_data();
}

void update_camera()
{
  if (g_Context.input.mouseButton.middle)
  {
    CGL_vec3 cameraFront = CGL_vec3_normalize_(CGL_vec3_sub(g_Context.scene.camera.target, g_Context.scene.camera.position));
    CGL_vec3 cameraLeft = CGL_vec3_normalize_(CGL_vec3_cross_(cameraFront, CGL_vec3_init(0.0001f, 1.0001f, 0.0001f)));
    CGL_vec3 cameraUp = CGL_vec3_normalize_(CGL_vec3_cross_(cameraLeft, cameraFront));

    g_Context.scene.camera.position = CGL_vec3_sub_(g_Context.scene.camera.position, CGL_vec3_scale_(cameraLeft, g_Context.input.mouseDelta.x * g_Context.scene.camera.moveSpeed ));

    if (CGL_window_is_key_pressed(g_Context.core.window, CGL_KEY_LEFT_SHIFT))
      g_Context.scene.camera.position = CGL_vec3_add_(g_Context.scene.camera.position, CGL_vec3_scale_(cameraFront, g_Context.input.mouseDelta.y * g_Context.scene.camera.moveSpeed ));
    else 
      g_Context.scene.camera.position = CGL_vec3_sub_(g_Context.scene.camera.position, CGL_vec3_scale_(cameraUp, g_Context.input.mouseDelta.y * g_Context.scene.camera.moveSpeed ));

    calculate_camera();
  }

}

#if 0
// This part is just for auto shader reloading during development
void reload_cloud_shader()
{
  static CGL_uint lastHashFrag = 0, lastHashCompute = 0;

  CGL_sizei fileSize = 0;
  CGL_byte* cloudShaderSource = CGL_utils_read_file("frag.glsl", &fileSize);
  if (fileSize > 0)
  {
    CGL_uint hash = CGL_utils_super_fast_hash(cloudShaderSource, fileSize);
    if (hash != lastHashFrag)
    {
      CGL_shader* shader = CGL_shader_create(CLOUDS_VERTEX_SHADER_SOURCE, cloudShaderSource, NULL);
      if (shader) 
      {
        CGL_shader_destroy(g_Context.cloud.shader); 
        g_Context.cloud.shader = shader;
        CGL_info("Clouds fragment shader reloaded");
      }
      else 
      {
        CGL_warn("Cloud fragment shader reload failed");
      }
      lastHashFrag = hash;
    }
    CGL_free(cloudShaderSource);
  }

  cloudShaderSource = CGL_utils_read_file("compute.glsl", &fileSize);
  if (fileSize > 0)
  {
    CGL_uint hash = CGL_utils_super_fast_hash(cloudShaderSource, fileSize);
    if (hash != lastHashCompute)
    {
      CGL_shader* shader = CGL_shader_compute_create(cloudShaderSource, NULL);
      if (shader) 
      {
        CGL_shader_destroy(g_Context.cloud.noiseShader);
        g_Context.cloud.noiseShader = shader;
        CGL_info("Clouds compute shader reloaded");
        generate_noise_data();
      }
      else 
      {
        CGL_warn("Cloud compute shader reload failed");
      }
      lastHashCompute = hash;
    }
    CGL_free(cloudShaderSource);
  }

}
#endif

void update_scene()
{
  g_Context.scene.light.position.x = 10.0f * cosf(g_Context.core.time);
  g_Context.scene.light.position.z = 10.0f * sinf(g_Context.core.time);

  #if 0
  if(g_Context.core.frame % 60 == 0)
    reload_cloud_shader();
  #endif

  update_camera();
  
  
  {
    for (CGL_int i = CGL_KEY_0; i <= CGL_KEY_4; i++)
    {
      if (CGL_window_is_key_pressed(g_Context.core.window, i))
      {
        CGL_int ind = i - CGL_KEY_0 - 1;
        if (CGL_window_is_key_pressed(g_Context.core.window, CGL_KEY_M)) 
          g_Context.core.vizMode = ind;
        else if (CGL_window_is_key_pressed(g_Context.core.window, CGL_KEY_C))
          g_Context.core.vizChannel = ind;
        break;
      }
    }
  }

}

void render_object()
{
  CGL_shader_bind(g_Context.scene.diffuseShader);
  CGL_shader_set_uniform_vec3(g_Context.scene.diffuseShader, CGL_shader_get_uniform_location(g_Context.scene.diffuseShader, "u_lightPos"), &g_Context.scene.light.position);
  CGL_shader_set_uniform_vec3(g_Context.scene.diffuseShader, CGL_shader_get_uniform_location(g_Context.scene.diffuseShader, "u_lightColor"), &g_Context.scene.light.color);

  // Render Cube
  CGL_shader_set_uniform_mat4(g_Context.scene.diffuseShader, CGL_shader_get_uniform_location(g_Context.scene.diffuseShader, "u_view"), &g_Context.scene.camera.viewMat);
  CGL_shader_set_uniform_mat4(g_Context.scene.diffuseShader, CGL_shader_get_uniform_location(g_Context.scene.diffuseShader, "u_projection"), &g_Context.scene.camera.projectionMat);
  CGL_shader_set_uniform_mat4(g_Context.scene.diffuseShader, CGL_shader_get_uniform_location(g_Context.scene.diffuseShader, "u_viewProjection"), &g_Context.scene.camera.viewProjectionMat);

  g_Context.scene.modelMat = CGL_mat4_translate(0.0f, -0.1f, 0.0f);
  g_Context.scene.modelMat = CGL_mat4_mul(g_Context.scene.modelMat, CGL_mat4_scale(8.0f, 0.2f, 8.0f));
  CGL_shader_set_uniform_mat4(g_Context.scene.diffuseShader, CGL_shader_get_uniform_location(g_Context.scene.diffuseShader, "u_model"), &g_Context.scene.modelMat);
  CGL_shader_set_uniform_vec3v(g_Context.scene.diffuseShader, CGL_shader_get_uniform_location(g_Context.scene.diffuseShader, "u_objectColor"), 0.55f, 0.55f, 0.3f);
  CGL_mesh_gpu_render(g_Context.scene.cube);

  g_Context.scene.modelMat = CGL_mat4_translate(0.5f, 0.6f, 0.0f);
  g_Context.scene.modelMat = CGL_mat4_mul(g_Context.scene.modelMat, CGL_mat4_scale(0.6f, 0.6f, 0.6f));
  g_Context.scene.modelMat = CGL_mat4_mul(g_Context.scene.modelMat, CGL_mat4_rotate_y(CGL_PI * 0.25f));
  CGL_shader_set_uniform_mat4(g_Context.scene.diffuseShader, CGL_shader_get_uniform_location(g_Context.scene.diffuseShader, "u_model"), &g_Context.scene.modelMat);
  CGL_shader_set_uniform_vec3v(g_Context.scene.diffuseShader, CGL_shader_get_uniform_location(g_Context.scene.diffuseShader, "u_objectColor"), 0.6f, 0.2f, 0.1f);
  CGL_mesh_gpu_render(g_Context.scene.cube);

  g_Context.scene.modelMat = CGL_mat4_translate(-3.5f, 0.6f, 2.8f);
  g_Context.scene.modelMat = CGL_mat4_mul(g_Context.scene.modelMat, CGL_mat4_scale(0.5f, 2.8f, 0.5f));
  g_Context.scene.modelMat = CGL_mat4_mul(g_Context.scene.modelMat, CGL_mat4_rotate_y(CGL_PI * 0.25f));
  CGL_shader_set_uniform_mat4(g_Context.scene.diffuseShader, CGL_shader_get_uniform_location(g_Context.scene.diffuseShader, "u_model"), &g_Context.scene.modelMat);
  CGL_shader_set_uniform_vec3v(g_Context.scene.diffuseShader, CGL_shader_get_uniform_location(g_Context.scene.diffuseShader, "u_objectColor"), 0.1f, 0.6f, 0.2f);
  CGL_mesh_gpu_render(g_Context.scene.cube);

  g_Context.scene.modelMat = CGL_mat4_translate(2.0f, 1.0f, 3.0f);
  g_Context.scene.modelMat = CGL_mat4_mul(g_Context.scene.modelMat, CGL_mat4_scale(0.8f, 0.8f, 0.8f));
  CGL_shader_set_uniform_mat4(g_Context.scene.diffuseShader, CGL_shader_get_uniform_location(g_Context.scene.diffuseShader, "u_model"), &g_Context.scene.modelMat);
  CGL_shader_set_uniform_vec3v(g_Context.scene.diffuseShader, CGL_shader_get_uniform_location(g_Context.scene.diffuseShader, "u_objectColor"), 0.2f, 0.2f, 0.6f);
  CGL_mesh_gpu_render(g_Context.scene.cube);
}

void render_cloud()
{
  CGL_shader_bind(g_Context.cloud.shader);
  
  CGL_texture_bind(CGL_framebuffer_get_color_texture(g_Context.scene.framebuffer), 1);
  CGL_shader_set_uniform_int(g_Context.cloud.shader, CGL_shader_get_uniform_location(g_Context.cloud.shader, "u_texture"), 1);
  
  CGL_texture_bind(CGL_framebuffer_get_depth_texture(g_Context.scene.framebuffer), 2);
  CGL_shader_set_uniform_int(g_Context.cloud.shader, CGL_shader_get_uniform_location(g_Context.cloud.shader, "u_depth"), 2);

  CGL_texture_bind(g_Context.cloud.noiseTexture3d128, 3);
  CGL_shader_set_uniform_int(g_Context.cloud.shader, CGL_shader_get_uniform_location(g_Context.cloud.shader, "u_shapeNoise"), 3);

  CGL_texture_bind(g_Context.cloud.noiseTexture3d32, 4);
  CGL_shader_set_uniform_int(g_Context.cloud.shader, CGL_shader_get_uniform_location(g_Context.cloud.shader, "u_detailNoise"), 4);

  CGL_texture_bind(g_Context.cloud.noiseTexture2d128, 5);
  CGL_shader_set_uniform_int(g_Context.cloud.shader, CGL_shader_get_uniform_location(g_Context.cloud.shader, "u_curlNoise"), 5);

  CGL_shader_set_uniform_float(g_Context.cloud.shader, CGL_shader_get_uniform_location(g_Context.cloud.shader, "u_far"), g_Context.scene.camera.farV);
  CGL_shader_set_uniform_float(g_Context.cloud.shader, CGL_shader_get_uniform_location(g_Context.cloud.shader, "u_near"), g_Context.scene.camera.nearV);
  CGL_shader_set_uniform_vec3(g_Context.cloud.shader, CGL_shader_get_uniform_location(g_Context.cloud.shader, "u_cameraPos"), &g_Context.scene.camera.position);
  CGL_shader_set_uniform_vec3(g_Context.cloud.shader, CGL_shader_get_uniform_location(g_Context.cloud.shader, "u_lightPos"), &g_Context.scene.light.position);
  CGL_shader_set_uniform_vec3(g_Context.cloud.shader, CGL_shader_get_uniform_location(g_Context.cloud.shader, "u_lightColor"), &g_Context.scene.light.color);

  CGL_shader_set_uniform_mat4(g_Context.cloud.shader, CGL_shader_get_uniform_location(g_Context.cloud.shader, "u_projection"), &g_Context.scene.camera.projectionMat);
  CGL_shader_set_uniform_mat4(g_Context.cloud.shader, CGL_shader_get_uniform_location(g_Context.cloud.shader, "u_view"), &g_Context.scene.camera.viewMat);


  CGL_shader_set_uniform_vec3(g_Context.cloud.shader, CGL_shader_get_uniform_location(g_Context.cloud.shader, "u_cloudBoundsMin"), &g_Context.cloud.boundsMin);
  CGL_shader_set_uniform_vec3(g_Context.cloud.shader, CGL_shader_get_uniform_location(g_Context.cloud.shader, "u_cloudBoundsMax"), &g_Context.cloud.boundsMax);
  CGL_shader_set_uniform_vec4(g_Context.cloud.shader, CGL_shader_get_uniform_location(g_Context.cloud.shader, "u_phaseParams"), &g_Context.cloud.phaseParams);
  CGL_shader_set_uniform_float(g_Context.cloud.shader, CGL_shader_get_uniform_location(g_Context.cloud.shader, "u_lightAbsorptionThroughSun"), g_Context.cloud.lightAbsorptionThroughSun);
  CGL_shader_set_uniform_float(g_Context.cloud.shader, CGL_shader_get_uniform_location(g_Context.cloud.shader, "u_lightAbsorptionThroughCloud"), g_Context.cloud.lightAbsorptionThroughCloud);  
  CGL_shader_set_uniform_float(g_Context.cloud.shader, CGL_shader_get_uniform_location(g_Context.cloud.shader, "u_densityFactor"), g_Context.cloud.densityFactor);
  CGL_shader_set_uniform_float(g_Context.cloud.shader, CGL_shader_get_uniform_location(g_Context.cloud.shader, "u_scale"), g_Context.cloud.scale);
  CGL_shader_set_uniform_float(g_Context.cloud.shader, CGL_shader_get_uniform_location(g_Context.cloud.shader, "u_time"), g_Context.core.time);
  CGL_shader_set_uniform_vec3(g_Context.cloud.shader, CGL_shader_get_uniform_location(g_Context.cloud.shader, "u_offset"), &g_Context.cloud.offset);
  CGL_shader_set_uniform_float(g_Context.cloud.shader, CGL_shader_get_uniform_location(g_Context.cloud.shader, "u_threshold"), g_Context.cloud.threshold);
  CGL_shader_set_uniform_float(g_Context.cloud.shader, CGL_shader_get_uniform_location(g_Context.cloud.shader, "u_heightFactor"), g_Context.cloud.heightFactor);
  CGL_shader_set_uniform_vec4(g_Context.cloud.shader, CGL_shader_get_uniform_location(g_Context.cloud.shader, "u_shapeNoiseWeights"), &g_Context.cloud.shapeNoiseWeights);

  CGL_shader_set_uniform_float(g_Context.cloud.shader, CGL_shader_get_uniform_location(g_Context.cloud.shader, "u_detailScale"), g_Context.cloud.detailScale);
  CGL_shader_set_uniform_vec3(g_Context.cloud.shader, CGL_shader_get_uniform_location(g_Context.cloud.shader, "u_detailOffset"), &g_Context.cloud.detailOffset);
  CGL_shader_set_uniform_vec4(g_Context.cloud.shader, CGL_shader_get_uniform_location(g_Context.cloud.shader, "u_detailNoiseWeights"), &g_Context.cloud.detailNoiseWeights);

  CGL_shader_set_uniform_float(g_Context.cloud.shader, CGL_shader_get_uniform_location(g_Context.cloud.shader, "u_animationSpeed"), g_Context.cloud.animationSpeed);

  CGL_shader_set_uniform_int(g_Context.cloud.shader, CGL_shader_get_uniform_location(g_Context.cloud.shader, "u_numSteps"), g_Context.cloud.numSteps);
  CGL_shader_set_uniform_int(g_Context.cloud.shader, CGL_shader_get_uniform_location(g_Context.cloud.shader, "u_numLightSteps"), g_Context.cloud.numLightSteps);


  CGL_gl_render_screen_quad();
}

void render_present()
{
  CGL_shader_bind(g_Context.core.presentShader);
    
  CGL_texture_bind(CGL_framebuffer_get_color_texture(g_Context.cloud.framebuffer), 1);
  CGL_shader_set_uniform_int(g_Context.core.presentShader, CGL_shader_get_uniform_location(g_Context.core.presentShader, "u_texture"), 1);

  CGL_texture_bind(g_Context.cloud.noiseTexture3d128, 2);
  CGL_shader_set_uniform_int(g_Context.core.presentShader, CGL_shader_get_uniform_location(g_Context.core.presentShader, "u_noiseTexture3d128"), 2);

  CGL_texture_bind(g_Context.cloud.noiseTexture3d32, 3);
  CGL_shader_set_uniform_int(g_Context.core.presentShader, CGL_shader_get_uniform_location(g_Context.core.presentShader, "u_noiseTexture3d32"), 3);

  CGL_texture_bind(g_Context.cloud.noiseTexture2d128, 4);
  CGL_shader_set_uniform_int(g_Context.core.presentShader, CGL_shader_get_uniform_location(g_Context.core.presentShader, "u_noiseTexture2d128"), 4);

  CGL_shader_set_uniform_int(g_Context.core.presentShader, CGL_shader_get_uniform_location(g_Context.core.presentShader, "u_vizMode"), g_Context.core.vizMode);
  CGL_shader_set_uniform_int(g_Context.core.presentShader, CGL_shader_get_uniform_location(g_Context.core.presentShader, "u_channel"), g_Context.core.vizChannel);
  CGL_shader_set_uniform_float(g_Context.core.presentShader, CGL_shader_get_uniform_location(g_Context.core.presentShader, "u_time"), g_Context.core.time);
  CGL_shader_set_uniform_float(g_Context.core.presentShader, CGL_shader_get_uniform_location(g_Context.core.presentShader, "u_aspectRatio"), g_Context.scene.camera.aspect);
  CGL_shader_set_uniform_float(g_Context.core.presentShader, CGL_shader_get_uniform_location(g_Context.core.presentShader, "u_slice"), g_Context.core.vizSlice);
  CGL_shader_set_uniform_float(g_Context.core.presentShader, CGL_shader_get_uniform_location(g_Context.core.presentShader, "u_scale"), g_Context.core.vizScale);
  CGL_shader_set_uniform_vec3(g_Context.core.presentShader, CGL_shader_get_uniform_location(g_Context.core.presentShader, "u_offset"), &g_Context.core.vizOffset);
  CGL_gl_render_screen_quad();
}

void render_scene()
{
  glEnable(GL_DEPTH_TEST);
  glDepthMask(GL_TRUE);
  glDepthFunc(GL_LESS);

  CGL_framebuffer_bind(g_Context.scene.framebuffer);
  CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);  
  render_object();
  
  CGL_framebuffer_bind( g_Context.cloud.framebuffer );
  CGL_gl_clear(0.0f, 0.0f, 0.0f, 1.0f);
  render_cloud();

  CGL_framebuffer_bind( g_Context.core.framebuffer );
  CGL_gl_clear(0.0f, 0.0f, 0.0f, 1.0f);
  render_present();
}

#if GUI_DEBUG

void render_nuklear()
{
  struct nk_context *ctx = g_Context.nuklearData.ctx;
  if (nk_begin(ctx, "Settings", nk_rect(50, 50, 230, 250),
    NK_WINDOW_BORDER|NK_WINDOW_MOVABLE|NK_WINDOW_SCALABLE|
    NK_WINDOW_MINIMIZABLE|NK_WINDOW_TITLE))

  static int settingsTab = 0;
  static const char* settingsTabNames[] = {"Vizualization", "Cloud Noise", "Cloud Settings"};
  static int settingsTabCount = sizeof(settingsTabNames) / sizeof(settingsTabNames[0]);

  nk_layout_row_dynamic(ctx, 25, 1);
  settingsTab = nk_combo(ctx, settingsTabNames, settingsTabCount, settingsTab, 30, nk_vec2(200,200));

  nk_layout_row_dynamic(ctx, 5, 1);
  nk_label(ctx, "", NK_TEXT_LEFT);
  // Vizualization
  if (settingsTab == 0)  
  {
    
    // a combo box for viz mode with label
    {
      static const char *items[] = {"Color", "Shape Noise", "Detail Noise", "Curl Noise"};
      static int selected = 0;
      //nk_layout_row(ctx, NK_DYNAMIC, 25, 2, (float[]){0.35f, 0.65f});
      nk_layout_row_dynamic(ctx, 25, 2);
      nk_label(ctx, "Viz Mode", NK_TEXT_LEFT);
      selected = nk_combo(ctx, items, sizeof(items) / sizeof(items[0]), selected, 25, nk_vec2(200,200));
      g_Context.core.vizMode = selected;
    }

    if (g_Context.core.vizMode != 0)
    {
      // a combo box for viz channel with label
      {
        static const char *items[] = {"Red", "Green", "Blue", "Alpha"};
        static int selected = 0;
        //nk_layout_row(ctx, NK_DYNAMIC, 25, 2, (float[]){0.35f, 0.65f});
        nk_layout_row_dynamic(ctx, 25, 2);
        nk_label(ctx, "Viz Channel", NK_TEXT_LEFT);
        selected = nk_combo(ctx, items, sizeof(items) / sizeof(items[0]), selected, 25, nk_vec2(200,200));
        g_Context.core.vizChannel = selected;
      }

      // Viz Slice
      {
        nk_layout_row_dynamic(ctx, 25, 2);
        nk_label(ctx, "Viz Slice", NK_TEXT_LEFT);
        nk_slider_float(ctx, 0.0f, &g_Context.core.vizSlice, 1.0f, 0.01f);
      }

      // Viz Scale
      {
        nk_layout_row_dynamic(ctx, 25, 2);
        nk_label(ctx, "Viz Scale", NK_TEXT_LEFT);
        nk_slider_float(ctx, 1.0f, &g_Context.core.vizScale, 20.0f, 0.01f);
      }

      // Viz Offset
      {
        nk_layout_row_dynamic(ctx, 25, 4);
        nk_label(ctx, "Viz Offset", NK_TEXT_LEFT);
        nk_property_float(ctx, "X:", -10.0f, &g_Context.core.vizOffset.x, 10.0f, 0.01f, 0.01f);
        nk_property_float(ctx, "Y:", -10.0f, &g_Context.core.vizOffset.y, 10.0f, 0.01f, 0.01f);
        nk_property_float(ctx, "Z:", -10.0f, &g_Context.core.vizOffset.z, 10.0f, 0.01f, 0.01f);
      }

    }

  }
  // Cloud Noise
  else if (settingsTab == 1)
  {

    static int noiseTexture = 0;
    // a combo box for noise texture
    {
      static const char *items[] = {"Shape Noise", "Detail Noise", "Curl Noise"};
      nk_layout_row_dynamic(ctx, 25, 2);
      nk_label(ctx, "Texture", NK_TEXT_LEFT);
      noiseTexture = nk_combo(ctx, items, sizeof(items) / sizeof(items[0]), noiseTexture, 25, nk_vec2(200,200));
    }

    bool hasNoiseChanged = false;

    // the starting scale
    {
      nk_layout_row_dynamic(ctx, 25, 2);
      nk_label(ctx, "Starting Scale", NK_TEXT_LEFT);
      CGL_int tmp = (CGL_int)g_Context.cloud.noiseStartingScale[noiseTexture];
      hasNoiseChanged = nk_slider_int(ctx,  0, &tmp, 20, 1) || hasNoiseChanged;
      g_Context.cloud.noiseStartingScale[noiseTexture] = (float)tmp;

    }


    if(hasNoiseChanged) 
    {
      generate_noise_data();
    }

  }
  // Cloud Settings
  else if (settingsTab == 2)
  {
    // clouds bounds min
    {
      nk_layout_row_dynamic(ctx, 25, 4);
      nk_label(ctx, "Bounds Min", NK_TEXT_LEFT);
      nk_property_float(ctx, "X Max:", -100.0f, &g_Context.cloud.boundsMin.x, 100.0f, 0.1f, 0.01f);
      nk_property_float(ctx, "Y Max:", -100.0f, &g_Context.cloud.boundsMin.y, 100.0f, 0.1f, 0.01f);
      nk_property_float(ctx, "Z Max:", -100.0f, &g_Context.cloud.boundsMin.z, 100.0f, 0.1f, 0.01f);
    }

    // clouds bounds max
    {
      nk_layout_row_dynamic(ctx, 25, 4);
      nk_label(ctx, "Bounds Max", NK_TEXT_LEFT);
      nk_property_float(ctx, "X Min:", -100.0f, &g_Context.cloud.boundsMax.x, 100.0f, 0.01f, 0.01f);
      nk_property_float(ctx, "Y Min:", -100.0f, &g_Context.cloud.boundsMax.y, 100.0f, 0.01f, 0.01f);
      nk_property_float(ctx, "Z Min:", -100.0f, &g_Context.cloud.boundsMax.z, 100.0f, 0.01f, 0.01f);
    }

    // light absorption through sun
    {
      nk_layout_row_dynamic(ctx, 25, 2);
      nk_label(ctx, "Light Absorption Through Sun", NK_TEXT_LEFT);
      nk_slider_float(ctx, 0.0f, &g_Context.cloud.lightAbsorptionThroughSun, 1.0f, 0.01f);
    }

    // light absorption through cloud
    {
      nk_layout_row_dynamic(ctx, 25, 2);
      nk_label(ctx, "Light Absorption Through Cloud", NK_TEXT_LEFT);
      nk_slider_float(ctx, 0.0f, &g_Context.cloud.lightAbsorptionThroughCloud, 1.0f, 0.01f);
    }

    // phase params
    {
      nk_layout_row_dynamic(ctx, 25, 1);
      nk_label(ctx, "Phase Params", NK_TEXT_LEFT);
      nk_layout_row_dynamic(ctx, 25, 4);
      nk_slider_float(ctx, 0.0f, &g_Context.cloud.phaseParams.x, 1.0f, 0.01f);
      nk_slider_float(ctx, 0.0f, &g_Context.cloud.phaseParams.y, 1.0f, 0.01f);
      nk_slider_float(ctx, 0.0f, &g_Context.cloud.phaseParams.z, 1.0f, 0.01f);
      nk_slider_float(ctx, 0.0f, &g_Context.cloud.phaseParams.w, 1.0f, 0.01f);
    }

    // density factor
    {
      nk_layout_row_dynamic(ctx, 25, 2);
      nk_label(ctx, "Density Factor", NK_TEXT_LEFT);
      nk_slider_float(ctx, 0.0f, &g_Context.cloud.densityFactor, 500.0f, 0.01f);
    }

    // threshold
    {
      nk_layout_row_dynamic(ctx, 25, 2);
      nk_label(ctx, "Threshold", NK_TEXT_LEFT);
      nk_slider_float(ctx, 0.0f, &g_Context.cloud.threshold, 2.0f, 0.0001f);
    }

    // height factor
    {
      nk_layout_row_dynamic(ctx, 25, 2);
      nk_label(ctx, "Height Factor", NK_TEXT_LEFT);
      nk_slider_float(ctx, 0.0f, &g_Context.cloud.heightFactor, 10.0f, 0.01f);
    }

    // shape noise weights
    {
      nk_layout_row_dynamic(ctx, 25, 1);
      nk_label(ctx, "Shape Noise Weights", NK_TEXT_LEFT);
      nk_layout_row_dynamic(ctx, 25, 4);
      nk_slider_float(ctx, 0.0f, &g_Context.cloud.shapeNoiseWeights.x, 1.0f, 0.01f);
      nk_slider_float(ctx, 0.0f, &g_Context.cloud.shapeNoiseWeights.y, 1.0f, 0.01f);
      nk_slider_float(ctx, 0.0f, &g_Context.cloud.shapeNoiseWeights.z, 1.0f, 0.01f);
      nk_slider_float(ctx, 0.0f, &g_Context.cloud.shapeNoiseWeights.w, 1.0f, 0.01f);
    }

    // scale
    {
      nk_layout_row_dynamic(ctx, 25, 2);
      nk_label(ctx, "Scale", NK_TEXT_LEFT);
      nk_slider_float(ctx, 0.0f, &g_Context.cloud.scale, 5.0f, 0.01f);
    }

    // offset
    {
      nk_layout_row_dynamic(ctx, 25, 4);
      nk_label(ctx, "Offset", NK_TEXT_LEFT);
      nk_property_float(ctx, "Xo:", -100.0f, &g_Context.cloud.offset.x, 100.0f, 0.01f, 0.01f);
      nk_property_float(ctx, "Yo:", -100.0f, &g_Context.cloud.offset.y, 100.0f, 0.01f, 0.01f);
      nk_property_float(ctx, "Zo:", -100.0f, &g_Context.cloud.offset.z, 100.0f, 0.01f, 0.01f);
    }

    // detail scale
    {
      nk_layout_row_dynamic(ctx, 25, 2);
      nk_label(ctx, "Detail Scale", NK_TEXT_LEFT);
      nk_slider_float(ctx, 0.0f, &g_Context.cloud.detailScale, 5.0f, 0.01f);
    }

    // detail offset
    {
      nk_layout_row_dynamic(ctx, 25, 4);
      nk_label(ctx, "Detail Offset", NK_TEXT_LEFT);
      nk_property_float(ctx, "Xd:", -100.0f, &g_Context.cloud.detailOffset.x, 100.0f, 0.01f, 0.01f);
      nk_property_float(ctx, "Yd:", -100.0f, &g_Context.cloud.detailOffset.y, 100.0f, 0.01f, 0.01f);
      nk_property_float(ctx, "Zd:", -100.0f, &g_Context.cloud.detailOffset.z, 100.0f, 0.01f, 0.01f);
    }

    // detail noise weights
    {
      nk_layout_row_dynamic(ctx, 25, 1);
      nk_label(ctx, "Detail Noise Weights", NK_TEXT_LEFT);
      nk_layout_row_dynamic(ctx, 25, 4);
      nk_slider_float(ctx, 0.0f, &g_Context.cloud.detailNoiseWeights.x, 1.0f, 0.01f);
      nk_slider_float(ctx, 0.0f, &g_Context.cloud.detailNoiseWeights.y, 1.0f, 0.01f);
      nk_slider_float(ctx, 0.0f, &g_Context.cloud.detailNoiseWeights.z, 1.0f, 0.01f);
      nk_slider_float(ctx, 0.0f, &g_Context.cloud.detailNoiseWeights.w, 1.0f, 0.01f);
    }

    // animation speed
    {
      nk_layout_row_dynamic(ctx, 25, 2);
      nk_label(ctx, "Animation Speed", NK_TEXT_LEFT);
      nk_slider_float(ctx, 0.0f, &g_Context.cloud.animationSpeed, 1.0f, 0.01f);
    }

    // num steps
    {
      nk_layout_row_dynamic(ctx, 25, 2);
      nk_label(ctx, "Num Steps", NK_TEXT_LEFT);
      nk_slider_int(ctx, 0, &g_Context.cloud.numSteps, 200, 1);
    }

    // num light steps
    {
      nk_layout_row_dynamic(ctx, 25, 2);
      nk_label(ctx, "Num Light Steps", NK_TEXT_LEFT);
      nk_slider_int(ctx, 0, &g_Context.cloud.numLightSteps, 50, 1);
    }
    
  }
  nk_end(ctx);
}

#endif

void free_scene()
{
  CGL_mesh_gpu_destroy(g_Context.scene.cube);
  CGL_mesh_gpu_destroy(g_Context.scene.sphere);
  CGL_shader_destroy(g_Context.scene.diffuseShader);
  CGL_shader_destroy(g_Context.core.presentShader);
  CGL_shader_destroy(g_Context.cloud.noiseShader);
  CGL_texture_destroy(g_Context.cloud.noiseTexture3d128);
  CGL_texture_destroy(g_Context.cloud.noiseTexture3d32);
  CGL_texture_destroy(g_Context.cloud.noiseTexture2d128);
  CGL_shader_destroy(g_Context.cloud.shader);
  CGL_framebuffer_destroy(g_Context.scene.framebuffer);
  CGL_framebuffer_destroy(g_Context.cloud.framebuffer);
}

void initialize_stuff()
{
  g_Context.core.framebuffer = CGL_framebuffer_create_from_default(g_Context.core.window);
  g_Context.input.mouseDelta = CGL_vec2_init(0.0f, 0.0f);
  g_Context.input.mousePos = CGL_vec2_init(0.0f, 0.0f);
  g_Context.core.frame = 0;
  g_Context.core.vizMode = 0;
  g_Context.core.vizChannel = 0;
  g_Context.core.vizSlice = 0.0f;
  g_Context.core.vizScale = 1.0f;
  g_Context.core.vizOffset = CGL_vec3_init(0.0f, 0.0f, 0.0f);
  g_Context.cloud.lightAbsorptionThroughSun = 1.0f;
  g_Context.cloud.lightAbsorptionThroughCloud = 1.0f;
  g_Context.cloud.boundsMin = CGL_vec3_init(-6.0f, -1.0f, -6.0f);
  g_Context.cloud.boundsMax = CGL_vec3_init(6.0f, 5.0f, 6.0f);
  g_Context.cloud.phaseParams = CGL_vec4_init(1.0f, 1.0f, 1.0f, 1.0f);
  g_Context.cloud.densityFactor = 64.0f;
  g_Context.cloud.scale = 1.0f;
  g_Context.cloud.offset = CGL_vec3_init(0.0f, 0.0f, 0.0f);
  g_Context.cloud.threshold = 0.65f;
  g_Context.cloud.heightFactor = 2.0f;
  g_Context.cloud.shapeNoiseWeights = CGL_vec4_init(1.0f, 1.0f, 1.0f, 1.0f);
  g_Context.cloud.noiseScaleFactor[0] = g_Context.cloud.noiseScaleFactor[1] = g_Context.cloud.noiseScaleFactor[2] = 2.0f;
  g_Context.cloud.noiseStartingScale[0] = g_Context.cloud.noiseStartingScale[1] = g_Context.cloud.noiseStartingScale[2] = 2.0f;
  g_Context.cloud.detailScale = 1.0f;
  g_Context.cloud.detailOffset = CGL_vec3_init(0.0f, 0.0f, 0.0f);
  g_Context.cloud.detailNoiseWeights = CGL_vec4_init(1.0f, 1.0f, 1.0f, 1.0f);
  g_Context.cloud.animationSpeed = 0.1f;
  g_Context.cloud.numSteps = 100;
  g_Context.cloud.numLightSteps = 20;
}

int main() 
{
  // Initialize stuff
  CGL_init();
  g_Context.core.window  = CGL_window_create(SIZEX, SIZEY, "Clouds - Jaysmito Mukherjee");
  CGL_window_make_context_current( g_Context.core.window );
  CGL_gl_init();
  CGL_widgets_init();

#if GUI_DEBUG

  g_Context.nuklearData.ctx = nk_glfw3_init(&g_Context.nuklearData.glfw, CGL_window_get_glfw_handle(g_Context.core.window), NK_GLFW3_INSTALL_CALLBACKS);
  {
    struct nk_font_atlas *atlas;
    nk_glfw3_font_stash_begin(&g_Context.nuklearData.glfw, &atlas);
    nk_glfw3_font_stash_end(&g_Context.nuklearData.glfw);
  }

#endif

  // Allocate resoruces
  initialize_stuff();
  setup_scene();

  CGL_float prev_time = CGL_utils_get_time();


  while(!CGL_window_should_close(g_Context.core.window)) 
  {
    g_Context.core.time = CGL_utils_get_time();
    g_Context.core.deltaTime = g_Context.core.time - prev_time;
    prev_time = g_Context.core.time;

    g_Context.core.frame += 1;

    CGL_int width, height;
    CGL_window_get_size(g_Context.core.window, &width, &height);

    CGL_double xpos, ypos;
    CGL_window_get_mouse_position(g_Context.core.window, &xpos, &ypos);
    CGL_vec2 mousePos = CGL_vec2_init((CGL_float)xpos, SIZEY - (CGL_float)ypos);
    mousePos = CGL_vec2_div_(mousePos, CGL_vec2_init((CGL_float)width, (CGL_float)height));
    mousePos = CGL_vec2_add_(CGL_vec2_mul_(mousePos, CGL_vec2_init(2.0f, 2.0f)), CGL_vec2_init(-1.0f, -1.0f));

    g_Context.input.mouseDelta = CGL_vec2_sub(mousePos, g_Context.input.mousePos);
    g_Context.input.mousePos = mousePos;

    g_Context.input.mouseButton.left = CGL_window_get_mouse_button(g_Context.core.window, CGL_MOUSE_BUTTON_LEFT) == CGL_PRESS;
    g_Context.input.mouseButton.right = CGL_window_get_mouse_button(g_Context.core.window, CGL_MOUSE_BUTTON_RIGHT) == CGL_PRESS;
    g_Context.input.mouseButton.middle = CGL_window_get_mouse_button(g_Context.core.window, CGL_MOUSE_BUTTON_MIDDLE) == CGL_PRESS;


    
    CGL_window_set_size(g_Context.core.window, SIZEX, SIZEY);
    CGL_window_poll_events(g_Context.core.window);

   
    update_scene();
    render_scene();    

#if GUI_DEBUG
    
    CGL_framebuffer_bind( g_Context.core.framebuffer );
    nk_glfw3_new_frame(&g_Context.nuklearData.glfw);
    render_nuklear();
    nk_glfw3_render(&g_Context.nuklearData.glfw, NK_ANTI_ALIASING_ON, 1024 * 512, 1024 * 128);

#endif

    if (CGL_window_is_key_pressed(g_Context.core.window, CGL_KEY_G))
      generate_noise_data();

    if (CGL_window_is_key_pressed(g_Context.core.window, CGL_KEY_ESCAPE)) 
      break;

    CGL_window_swap_buffers(g_Context.core.window);
  }

  free_scene();

#if GUI_DEBUG
    nk_glfw3_shutdown(&g_Context.nuklearData.glfw);
#endif

  // Free resources and shutdown
  CGL_framebuffer_destroy( g_Context.core.framebuffer );
  CGL_widgets_shutdown();
  CGL_gl_shutdown();
  CGL_window_destroy( g_Context.core.window );
  CGL_shutdown();
}

```

`examples/c/sierpinski_tirangle.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_EXCLUDE_NETWORKING
#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#include "cgl.h"

typedef struct
{
    CGL_double x;
    CGL_double y;
} CGL_dvec2;

#define CGL_dvec2_init(x, y) (CGL_dvec2){x, y}

static struct
{
    CGL_window* window; // the main window
    CGL_int window_height;
    CGL_int window_width;
    CGL_framebuffer* framebuffer;
    CGL_double scale;
    CGL_dvec2 offset;
} g_context;

static CGL_dvec2 triangle_vertices[3] = {
    -0.5, 0.0,
    0.5, 0.0,
    0.0, 0.87
};

CGL_dvec2 next_point_sierpinski(CGL_dvec2 prev_point)
{
    CGL_float random = CGL_utils_random_float();
    CGL_dvec2 next_point = CGL_dvec2_init(0.0, 0.0);
    CGL_dvec2 vert = triangle_vertices[rand() % 3];
    vert.x *= g_context.scale;
    vert.y *= g_context.scale;
    next_point.x = (prev_point.x + vert.x) * 0.5;
    next_point.y = (prev_point.y + vert.y) * 0.5;
    return next_point;    
}

int main()
{
    srand((uint32_t)time(NULL));
    if(!CGL_init()) return EXIT_FAILURE; // initialize CGL (required for setting up internals of CGL)
    g_context.window_height = g_context.window_width = 700;
    g_context.window = CGL_window_create(g_context.window_width, g_context.window_height, "Sierpinski Triangle - Jaysmito Mukherjee"); // create the window
    CGL_window_make_context_current(g_context.window); // make the opengl context for the window current
    if(!CGL_gl_init()) return EXIT_FAILURE; // initialize cgl opengl module    
    g_context.framebuffer = CGL_framebuffer_create_from_default(g_context.window); // load the default framebuffer (0) into CGL_framebuffer object
    if(!CGL_widgets_init()) return EXIT_FAILURE; 

    CGL_float prev_time = CGL_utils_get_time(), curr_time = 0.0f, delta_time = 0.0f, frame_time = 0.0f;
    CGL_int frame_count = 0, frame_rate = 60;

    CGL_dvec2 turtle_position = CGL_dvec2_init(0.0f, 0.0f);
    CGL_float point_size = 0.01f;

    g_context.offset.y = -0.87 * 0.5;
    g_context.offset.x = 0.0;
    g_context.scale = 1.0;

    // the main loop
    while(!CGL_window_should_close(g_context.window)) // run till the close button is clicked
    {
        curr_time = CGL_utils_get_time();
        delta_time = curr_time - prev_time; prev_time = curr_time; frame_time += delta_time; frame_count++;
        if(frame_time >= 1.0f) { frame_rate = frame_count; frame_time = 0.0f; frame_count = 0; }

        CGL_window_set_size(g_context.window, g_context.window_width, g_context.window_height); // set the window size
        // rendering
        CGL_framebuffer_bind(g_context.framebuffer); // bind default framebuffer and also adjust viewport size and offset

        CGL_widgets_begin();

        CGL_widgets_set_fill_colorf(0.8f, 0.8f, 0.8f, 1.0f);

        for(CGL_sizei i = 0; i < 50000; i++)
        {
            turtle_position = next_point_sierpinski(turtle_position);        
            CGL_widgets_add_rect2f((CGL_float)(turtle_position.x + g_context.offset.x * g_context.scale), (CGL_float)(turtle_position.y  + g_context.offset.y * g_context.scale), point_size, point_size);
        }
        
        CGL_widgets_end();
        


        CGL_bool tmp = false, tmp2 = false;
        if(tmp = CGL_window_is_key_pressed(g_context.window, CGL_KEY_W)) g_context.scale *= 1.01; tmp2 |= tmp;
        if(tmp = CGL_window_is_key_pressed(g_context.window, CGL_KEY_S)) g_context.scale *= 0.99; tmp2 |= tmp;
        if(tmp = CGL_window_is_key_pressed(g_context.window, CGL_KEY_LEFT)) g_context.offset.x -= 0.005; tmp2 |= tmp;
        if(tmp = CGL_window_is_key_pressed(g_context.window, CGL_KEY_RIGHT)) g_context.offset.x += 0.005; tmp2 |= tmp;
        if(tmp = CGL_window_is_key_pressed(g_context.window, CGL_KEY_UP)) g_context.offset.y += 0.005; tmp2 |= tmp;
        if(tmp = CGL_window_is_key_pressed(g_context.window, CGL_KEY_DOWN)) g_context.offset.y -= 0.005; tmp2 |= tmp;

        CGL_window_swap_buffers(g_context.window); // swap framebuffers
        CGL_window_poll_events(g_context.window); // poll events (if this is not called every frame window will stop responding)

        if(tmp2) CGL_gl_clear(0.0f, 0.0f, 0.0f, 1.0f); // clear screen with a dark gray color

        if(CGL_window_get_key(g_context.window, CGL_KEY_ESCAPE) == CGL_PRESS) break; // quit on pressing escape
    }

    // cleanup
    CGL_widgets_shutdown();
    CGL_framebuffer_destroy(g_context.framebuffer); // destory framebuffer object
    CGL_gl_shutdown(); // shutdown cgl opengl module
    CGL_window_destroy(g_context.window); // destroy window
    CGL_shutdown(); // shutdown cgl and clean up resources allocated by CGL internally (if any)
    return EXIT_SUCCESS;
}

```

`examples/c/simple_quad_tree.c`:

```c
/*
MIT License
Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_EXCLUDE_NETWORKING
#define CGL_LOGGING_ENABLED
#define CGL_EXCLUDE_AUDIO
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_IMPLEMENTATION
#include "cgl.h"

#ifdef CGL_WASM
#include <emscripten/emscripten.h>
#include <emscripten/html5.h>
#else
#define EM_BOOL int
#endif

#define MAX_POINTS 1000
#define POINT_SIZE 0.01f

CGL_sizei selected_points[MAX_POINTS];
CGL_vec2 points_clone[MAX_POINTS];
CGL_vec2 points[MAX_POINTS];
CGL_vec2 mouse_selector_size;
CGL_nd_tree* quad_tree;
CGL_sizei selected_points_count = 0;
CGL_float selector_aabb_min[2], selector_aabb_max[2];
CGL_int mode = 0;

static struct
{
    CGL_window* window; // the main window
    int window_height;
    int window_width;
    CGL_framebuffer* framebuffer;
} g_context;

CGL_void init_points()
{
    for (int i = 0; i < MAX_POINTS; i++)
    {
		points[i].x = CGL_utils_random_float_in_range(-1.0f, 1.0f);
		points[i].y = CGL_utils_random_float_in_range(-1.0f, 1.0f);
	}
    memcpy(points_clone, points, sizeof(points));
}

CGL_void update_points(CGL_float dt, CGL_float tm)
{
    (void)dt;

    for (CGL_sizei i = 0; i < MAX_POINTS; i++)
    {
		points[i].y = points_clone[i].y + sinf(points[i].y - points_clone[i].y + tm + i) * 0.1f;
        points[i].x = points_clone[i].x + cosf(points[i].x - points_clone[i].x + tm + i) * 0.1f;
        if(mode == 0) CGL_quad_tree_add(quad_tree, points[i].x, points[i].y, &i);
	}
}

CGL_void render_points()
{
    for (int i = 0; i < MAX_POINTS; i++)
    {
        CGL_widgets_add_rect2f(points[i].x, points[i].y, POINT_SIZE, POINT_SIZE);
    }
}

CGL_void render_quad_tree()
{
    // NOTE: this is only for debugging purposes and
    //       the cgl_nd_tree data ideally should not be accessed directly
    for (CGL_sizei i = 0; i < (CGL_sizei)quad_tree->nodes_bank_size; i++)
    {
        if (quad_tree->aabb_intersects_aabb_function(2, quad_tree->nodes_bank[i].aabb_min, quad_tree->nodes_bank[i].aabb_max, selector_aabb_min, selector_aabb_max )) CGL_widgets_set_stroke_colorf(0.4f, 0.4f, 0.6f, 0.6f);
        else CGL_widgets_set_stroke_colorf(0.4f, 0.4f, 0.4f, 0.6f);
        CGL_widgets_add_rect2f(
            quad_tree->nodes_bank[i].aabb_min[0],
			quad_tree->nodes_bank[i].aabb_min[1],
            quad_tree->nodes_bank[i].aabb_max[0] - quad_tree->nodes_bank[i].aabb_min[0],
            quad_tree->nodes_bank[i].aabb_max[1] - quad_tree->nodes_bank[i].aabb_min[1]
        );
    }
}

CGL_bool init()
{
    CGL_init();
    mouse_selector_size = CGL_vec2_init(0.369f, 0.214f);
    g_context.window_height = g_context.window_width = 700;
    g_context.window = CGL_window_create(g_context.window_width, g_context.window_height, "Quad Tree - Jaysmito Mukherjee"); // create the window
    if (g_context.window == NULL) return false; // window creation failed
    CGL_window_make_context_current(g_context.window); // make the opengl context for the window current
    if (!CGL_gl_init()) return EXIT_FAILURE; // initialize cgl opengl module    
    g_context.framebuffer = CGL_framebuffer_create_from_default(g_context.window); // load the default framebuffer (0) into CGL_framebuffer object
    if (g_context.framebuffer == NULL) return false; // failed
    if (!CGL_widgets_init()) return EXIT_FAILURE;

    init_points();

    quad_tree = CGL_quad_tree_create(sizeof(CGL_sizei), 128, 100000, 100000, true);

    return CGL_TRUE;
}

void cleanup()
{
    CGL_nd_tree_destroy(quad_tree);
    CGL_widgets_shutdown();
    CGL_framebuffer_destroy(g_context.framebuffer); // destory framebuffer object
    CGL_gl_shutdown(); // shutdown cgl opengl module
    CGL_window_destroy(g_context.window); // destroy window
    CGL_shutdown();
}

EM_BOOL loop(double time, void* userData)
{
    (void)time;
    (void)userData;

    static CGL_int frame_rate = 0, frames = 0;
    static CGL_float timer = 0.0f, time_last = 0.0, time_now = 0.0f;

    CGL_double mdx, mdy; CGL_window_get_mouse_position(g_context.window, &mdx, &mdy);
    CGL_float mx = (CGL_float)mdx / (CGL_float)g_context.window_width * 2.0f - 1.0f;
    CGL_float my = (1.0f - (CGL_float)mdy / (CGL_float)g_context.window_height) * 2.0f - 1.0f;
    time_now = CGL_utils_get_time(); timer += time_now - time_last; time_last = time_now; frames++;
    if (timer > 1.0f) { frame_rate = frames; frames = 0; timer = 0.0f; }

    CGL_window_set_size(g_context.window, g_context.window_width, g_context.window_height); // set window size
    CGL_framebuffer_bind(g_context.framebuffer); // bind default framebuffer and also adjust viewport size and offset
    CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f); // clear screen with a dark gray color

    if(mode == 0) CGL_quad_tree_reset(quad_tree, -1.0f, -1.0f, 1.0f, 1.0f, 12, 6, CGL_window_is_key_pressed(g_context.window, CGL_KEY_F));

    update_points(0.001f, CGL_utils_get_time());

    CGL_widgets_begin();

    CGL_widgets_set_fill_mode(true);
    CGL_widgets_set_fill_colorf(0.6f, 0.6f, 0.6f, 1.0f);
    render_points();

    // selected_points_count = CGL_quad_tree_get_items_in_range(quad_tree, mx - mouse_selector_size.x / 2.0f, my - mouse_selector_size.y / 2.0f, mouse_selector_size.x, mouse_selector_size.y, selected_points, MAX_POINTS);
    selector_aabb_min[0] = mx - mouse_selector_size.x / 2.0f; selector_aabb_min[1] = my - mouse_selector_size.y / 2.0f;
    selector_aabb_max[0] = mx + mouse_selector_size.x / 2.0f; selector_aabb_max[1] = my + mouse_selector_size.y / 2.0f;
    if (mode == 0) selected_points_count = CGL_nd_tree_get_items_in_range(quad_tree, selector_aabb_min, selector_aabb_max, selected_points, MAX_POINTS);

    CGL_widgets_set_fill_colorf(0.0f, 0.8f, 0.0f, 1.0f);
    if (mode == 0) { for (CGL_sizei i = 0; i < selected_points_count; i++) CGL_widgets_add_rect2f(points[selected_points[i]].x, points[selected_points[i]].y, POINT_SIZE, POINT_SIZE); }
    else if(mode == 1)
    {
        for (CGL_int i = 0; i < MAX_POINTS; i++) 
            if (CGL_aabb_contains_point_2d(2, selector_aabb_min, selector_aabb_max, (CGL_float*)&points[i]))
                CGL_widgets_add_rect2f(points[i].x, points[i].y, POINT_SIZE, POINT_SIZE);
    }

    CGL_widgets_set_fill_mode(false);
    CGL_widgets_set_stroke_thickness(0.005f);
    CGL_widgets_set_stroke_colorf(0.0f, 0.8f, 0.0f, 1.0f);
    CGL_widgets_add_rect2f(mx - mouse_selector_size.x / 2.0f, my - mouse_selector_size.y / 2.0f, mouse_selector_size.x, mouse_selector_size.y);

    CGL_widgets_set_stroke_thickness(0.005f);
    if(mode == 0 && CGL_window_is_key_pressed(g_context.window, CGL_KEY_Q)) render_quad_tree();

    static CGL_byte frame_rate_string[32];
    sprintf(frame_rate_string, "FPS: %d", frame_rate);
    CGL_widgets_add_string(frame_rate_string, -0.99f, 0.90f, 0.2f, 0.05f);
    CGL_widgets_add_string(mode == 0 ? "QT" : "NM", -0.99f, 0.80f, 0.1f, 0.05f);

    CGL_widgets_end();

    if (CGL_window_is_key_pressed(g_context.window, CGL_KEY_SPACE))
    {
        mode = (mode + 1) % 2;
        CGL_utils_sleep(100);
    }

    CGL_window_swap_buffers(g_context.window); // swap framebuffers
    CGL_window_poll_events(g_context.window); // poll events (if this is not called every frame window will stop responding)

    if (CGL_window_get_key(g_context.window, CGL_KEY_ESCAPE) == CGL_PRESS) return CGL_FALSE; // quit on pressing escape

    return !CGL_window_should_close(g_context.window);
}

int main()
{
    if(!init()) return 1;
#ifdef CGL_WASM
    emscripten_request_animation_frame_loop(loop, NULL);
#else
    while(!CGL_window_should_close(g_context.window)) loop(0, NULL);
    cleanup();
#endif
    return 0;
}

```

`examples/c/simple_ssl_tcp_client.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#include "cgl.h"


int main()
{
    if(!CGL_net_init()) return EXIT_FAILURE;

    static bool result = false;
    static size_t length = 0;
    static char buffer[1024 * 1024]; // 1 MB buffer to recieve page
    static char* request_text = "GET /index.html HTTP/1.1\r\nHost: www.example.com\r\n\r\n";

    CGL_net_addrinfo* infos = CGL_net_addrinfo_query("www.example.com", "443", NULL);
    CGL_LOG("CGL_net_addrinfo* infos = CGL_net_addrinfo_query(\"example.com\", \"443\", NULL);\n");

    CGL_net_socket* socket = CGL_net_socket_create();
    CGL_LOG("CGL_net_socket* socket = CGL_net_socket_create();\n");

    result = CGL_net_socket_connect(socket, infos);
    CGL_LOG("CGL_net_socket_connect(socket, infos) --> %d\n", result);

    CGL_net_ssl_socket* ssl_socket = CGL_net_ssl_socket_create(socket);
    CGL_LOG("CGL_net_ssl_socket* ssl_socket = CGL_net_ssl_socket_create(socket);\n");

    // result = CGL_net_socket_send(socket, request_text, strlen(request_text), &length);
    // CGL_LOG("CGL_net_socket_send(socket, request_text, strlen(request_text), &length) --> %d\n", result);

    result = CGL_net_ssl_socket_send(ssl_socket, request_text, strlen(request_text), &length);
    CGL_LOG("CGL_net_ssl_socket_send(ssl_socket, request_text, strlen(request_text), &length) --> %d\n", result);

    CGL_LOG("Attempted to send %zu bytes\n", strlen(request_text));
    CGL_LOG("Sent %zu bytes\n", length);
    

    // result = CGL_net_socket_recv(socket, buffer, 512, &length);
    // CGL_LOG("CGL_net_socket_recv(socket, buffer, sizeof(buffer), &length) --> %d\n", result);

    result = CGL_net_ssl_socket_recv(ssl_socket, buffer, 512, &length);
    CGL_LOG("CGL_net_ssl_socket_recv(ssl_socket, buffer, sizeof(buffer), &length) --> %d\n", result);

    CGL_LOG("Recived %zu bytes\n", length);
    CGL_LOG("Recived Data : \n-----------------------------\n%s\n----------------------\n", buffer);

    CGL_net_addrinfo_destroy(infos);
    CGL_LOG("CGL_net_addrinfo_destroy(infos);\n");

    // CGL_net_socket_close(socket);
    // CGL_LOG("CGL_net_socket_close(socket);\n");   

    CGL_net_ssl_socket_destroy(ssl_socket); // automatically destorys internal raw socket
    CGL_LOG("CGL_net_ssl_socket_destroy(ssl_socket);\n");
        
    CGL_net_shutdown();
    CGL_LOG("CGL_net_shutdown();\n");

    return EXIT_SUCCESS;
}

```

`examples/c/simple_tcp_client.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#include "cgl.h"

int main()
{
    if(!CGL_net_init()) return EXIT_FAILURE;

    static bool result = false;
    static size_t length = 0;
    static char buffer[1024 * 1024]; // 1 MB buffer to recieve page
    static char* request_text = "GET /index.html HTTP/1.1\r\nHost: www.example.com\r\n\r\n";

    CGL_net_addrinfo* infos = CGL_net_addrinfo_query("www.example.com", "http", NULL);
    CGL_LOG("CGL_net_addrinfo* infos = CGL_net_addrinfo_query(\"example.com\", \"http\", NULL);\n");

    CGL_net_socket* socket = CGL_net_socket_create();
    CGL_LOG("CGL_net_socket* socket = CGL_net_socket_create();\n");

    result = CGL_net_socket_connect(socket, infos);
    CGL_LOG("CGL_net_socket_connect(socket, infos) --> %d\n", result);

    result = CGL_net_socket_send(socket, request_text, strlen(request_text), &length);
    CGL_LOG("CGL_net_socket_send(socket, request_text, strlen(request_text), &length) --> %d\n", result);

    CGL_LOG("Attempted to send %zu bytes\n", strlen(request_text));
    CGL_LOG("Send %zu bytes\n", length);

    result = CGL_net_socket_recv(socket, buffer, 512, &length);
    CGL_LOG("CGL_net_socket_recv(socket, buffer, sizeof(buffer), &length) --> %d\n", result);

    CGL_LOG("Recived %zu bytes\n", length);
    CGL_LOG("Recived Data : \n-----------------------------\n%s\n----------------------\n", buffer);

    CGL_net_addrinfo_destroy(infos);
    CGL_LOG("CGL_net_addrinfo_destroy(infos);\n");

    CGL_net_socket_close(socket);
    CGL_LOG("CGL_net_socket_close(socket);\n");   


    CGL_net_shutdown();
    CGL_LOG("CGL_net_shutdown();\n");

    return EXIT_SUCCESS;
}

```

`examples/c/single_pendlum.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_EXCLUDE_NETWORKING
#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#include "cgl.h"


static const char* PASS_THROUGH_VERTEX_SHADER_SOURCE = "#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 normal;\n"
"layout (location = 2) in vec4 texcoord;\n"
"\n"
"out vec3 Position;\n"
"out vec2 TexCoord;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = vec4(position.xyz, 1.0f);\n"
"	Position = position.xyz;\n"
"	TexCoord = texcoord.xy;\n"
"}";

static const char* PASS_THROUGH_FRAGMENT_SHADER_SOURCE = "#version 430 core\n"
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Position;\n"
"in vec2 TexCoord;\n"
"\n"
"uniform sampler2D u_tex;\n"
"\n"
"// Black Box From https://github.com/armory3d/armory/blob/master/Shaders/std/tonemap.glsl\n"
"vec3 acesFilm(const vec3 x) {\n"
"    const float a = 2.51;\n"
"    const float b = 0.03;\n"
"    const float c = 2.43;\n"
"    const float d = 0.59;\n"
"    const float e = 0.14;\n"
"    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	vec3 color = texture(u_tex, vec2(TexCoord.y, 1.0f - TexCoord.x)).rgb;\n"
"	color = acesFilm(color);\n"
"   color = pow(color, vec3(1.0f / 2.2f));\n"
"	FragColor = vec4(color, 1.0f);\n"
"}";

static const char* COMPUTE_SHADER_SOURCE = "#version 430 core\n"
"\n"
"layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;\n"
"\n"
"layout(rgba32f, binding = 0) uniform image2D output_tex;\n"
"\n"
"uniform int mode;"
"uniform vec2 mass_pos;"
"uniform vec2 fixed_pos;"
"uniform vec4 pre_color;"
"\n"
"bool lies_on_line(vec2 p)\n"
"{\n"
"   vec2 v = p - mass_pos;\n"
"   vec2 u = fixed_pos - mass_pos;\n"
"   float dot = v.x * u.x + v.y * u.y;\n"
"   float len_sq = u.x * u.x + u.y * u.y;\n"
"   float param = dot / len_sq;\n"
"   vec2 p2 = mass_pos + param * u;\n"
"   return length(p - p2) < 0.0001f;\n"
"}\n"
"\n"
"vec4 box_blur_filter(ivec2 coord)\n"
"{\n"
"   vec4 sum = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n"
"   for(int i = -1; i <= 1; i++)\n"
"   {\n"
"       for(int j = 0; j <= 1; j++)\n"
"       {\n"
"           sum += imageLoad(output_tex, coord + ivec2(i, j));\n"
"       }\n"
"   }\n"
"   return sum / 6.0f;\n"
"}\n"
"\n"
"void initialize()\n"
"{\n"
"   ivec2 coord = ivec2(gl_GlobalInvocationID.xy);\n"
"   imageStore(output_tex, coord, vec4(0.0f, 0.0f, 0.0f, 1.0f));\n"
"}\n"
"\n"
"void update()\n"
"{\n"
"   ivec2 coord = ivec2(gl_GlobalInvocationID.xy);\n"
"   vec4 color = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n"
"   vec2 nuv = vec2(imageSize(output_tex).x - coord.x, coord.y) / vec2(imageSize(output_tex)) * 2.0f - vec2(1.0f);\n"
"   nuv.x = nuv.x;\n"
"   // set color to pre_color with a radius of 0.01 exponentially decaying\n"
"   color = mix(box_blur_filter(coord), vec4(vec3(0.0f), 1.0f), 0.001f);\n"
"   float factor = exp(-0.5f * length(nuv - mass_pos) / 0.002f);\n"
"   color = mix(color, 2.0f * pre_color, factor);\n"
"   if(lies_on_line(nuv)) color = 0.9f * vec4(vec3(1.0f) - pre_color.xyz, 1.0f) * exp(-0.5f * length(nuv - fixed_pos) / 0.2f);\n"
"   color.a = 1.0f;\n"
"   imageStore(output_tex, coord, color);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"   if(mode == 0) initialize();\n"
"   if(mode == 1) update();\n"
"}\n";


static struct
{
    CGL_window* window; // the main window
    int window_height;
    int window_width;
    CGL_framebuffer* framebuffer;
} g_context;

int main()
{
    srand((uint32_t)time(NULL));
    if(!CGL_init()) return EXIT_FAILURE; // initialize CGL (required for setting up internals of CGL)
    g_context.window_width = g_context.window_height = 700;    
    g_context.window = CGL_window_create(g_context.window_width, g_context.window_height, "Single Pendulum - Jaysmito Mukherjee"); // create the window
    CGL_window_make_context_current(g_context.window); // make the opengl context for the window current
    if(!CGL_gl_init()) return EXIT_FAILURE; // initialize cgl opengl module    
    g_context.framebuffer = CGL_framebuffer_create_from_default(g_context.window); // load the default framebuffer (0) into CGL_framebuffer object
    CGL_noise_init();
    CGL_bool is_physics_on = true;
    CGL_vec2 mass_pos = CGL_vec2_init(0.0f, 0.0f), fixed_pos = CGL_vec2_init(0.0f, 1.0f), mass_vel = CGL_vec2_init(0.0f, 0.0f), mass_acc = CGL_vec2_init(0.0f, 0.0f), mass_force = CGL_vec2_init(0.0f, 0.0f);
    CGL_float mass_val = 1.0f, acc_due_to_gravity = 5.0f, spring_constant = 1.0f, damping_constant = 0.1f, time_step = 0.01f, curr_time;
    CGL_texture* out_tex = CGL_texture_create_blank(700, 700, GL_RGBA, GL_RGBA32F, GL_FLOAT);
    CGL_shader* present_shader = CGL_shader_create(PASS_THROUGH_VERTEX_SHADER_SOURCE, PASS_THROUGH_FRAGMENT_SHADER_SOURCE, NULL);
    CGL_shader* draw_shader = CGL_shader_compute_create(COMPUTE_SHADER_SOURCE, NULL);
    CGL_vec3 color = CGL_vec3_init(0.0f, 1.0f, 1.0f);
    glBindImageTexture(0, out_tex->handle, 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
    CGL_shader_bind(draw_shader);
    CGL_shader_set_uniform_int(draw_shader, CGL_shader_get_uniform_location(draw_shader, "mode"), 0);
    CGL_shader_compute_dispatch(draw_shader, 700 / 16 + 1, 700 / 16 + 1, 1);
    // the main loop
    while(!CGL_window_should_close(g_context.window)) // run till the close button is clicked
    {
        curr_time = CGL_utils_get_time();
        CGL_window_set_size(g_context.window, g_context.window_width, g_context.window_height); // set window size
        CGL_framebuffer_bind(g_context.framebuffer); // bind default framebuffer and also adjust viewport size and offset
        CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f); // clear screen with a dark gray color
        if(is_physics_on)
        {
            CGL_double mx = 0.0, my = 0.0; CGL_float weight = mass_val * acc_due_to_gravity * -1.0f;
            CGL_vec2 dir_tension = CGL_vec2_normalize_(CGL_vec2_sub_(fixed_pos, mass_pos));
            mass_force.x = 0.0f; mass_force.y = weight; mass_acc = CGL_vec2_scale_(mass_force, 1.0f / mass_val);
            mass_vel = CGL_vec2_add_(mass_vel, CGL_vec2_scale_(mass_acc, time_step));
            mass_vel = CGL_vec2_sub_(mass_vel, CGL_vec2_scale_(dir_tension, CGL_vec2_dot(mass_vel, dir_tension)));
            mass_pos = CGL_vec2_add(mass_pos, CGL_vec2_scale_(mass_vel, time_step));
            mass_vel = CGL_vec2_scale(mass_vel, 0.999f);
            
            color.x = CGL_noise_opensimplex2s(mass_pos.x, mass_pos.y, 0.0f + curr_time) * 0.5f + 0.5f;
            color.y = CGL_noise_opensimplex2s(mass_pos.x, mass_pos.y, 1.0f + curr_time) * 0.5f + 0.5f;
            color.z = CGL_noise_opensimplex2s(mass_pos.x, mass_pos.y, 2.0f + curr_time) * 0.5f + 0.5f;
            if(CGL_window_get_mouse_button(g_context.window, CGL_MOUSE_BUTTON_LEFT) == CGL_PRESS)
            {
                CGL_window_get_mouse_position(g_context.window, &mx, &my);
                mx = (1.0f - mx / (CGL_double)g_context.window_width) * 2.0 - 1.0; my = (1.0 - my / (CGL_double)g_context.window_height) * 2.0 - 1.0;
                CGL_vec2 dir = CGL_vec2_init((CGL_float)mx, (CGL_float)my - 1.0f);
                CGL_vec2_normalize(dir); CGL_float angle = copysignf(CGL_vec2_angle_between(dir, CGL_vec2_init(0.0f, -1.0f)), dir.x) + CGL_PI_2;
                mass_vel = CGL_vec2_scale(mass_vel, 0.0f); mass_pos = CGL_vec2_init(cosf(angle), 1.0f - sinf(angle));
                glBindImageTexture(0, out_tex->handle, 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
                CGL_shader_bind(draw_shader);
                CGL_shader_set_uniform_int(draw_shader, CGL_shader_get_uniform_location(draw_shader, "mode"), 0);
                CGL_shader_compute_dispatch(draw_shader, 700 / 16 + 1, 700 / 16 + 1, 1);
            }
        }
        glBindImageTexture(0, out_tex->handle, 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
        CGL_shader_bind(draw_shader);
        CGL_shader_set_uniform_int(draw_shader, CGL_shader_get_uniform_location(draw_shader, "mode"), 1);
        CGL_shader_set_uniform_vec2v(draw_shader, CGL_shader_get_uniform_location(draw_shader, "fixed_pos"), fixed_pos.x, fixed_pos.y);
        CGL_shader_set_uniform_vec2v(draw_shader, CGL_shader_get_uniform_location(draw_shader, "mass_pos"), mass_pos.x, mass_pos.y);
        CGL_shader_set_uniform_vec4v(draw_shader, CGL_shader_get_uniform_location(draw_shader, "pre_color"), color.x, color.y, color.z, 1.0f);
        CGL_shader_compute_dispatch(draw_shader, 700 / 16 + 1, 700 / 16 + 1, 1);
        CGL_shader_bind(present_shader);
        CGL_texture_bind(out_tex, 5);
        CGL_shader_set_uniform_int(present_shader, CGL_shader_get_uniform_location(present_shader, "u_tex"), 5);
        CGL_gl_render_screen_quad();
        CGL_window_swap_buffers(g_context.window); // swap framebuffers
        CGL_window_poll_events(g_context.window); // poll events (if this is not called every frame window will stop responding)
        if(CGL_window_get_key(g_context.window, CGL_KEY_ESCAPE) == CGL_PRESS) break; // quit on pressing escape
        if(CGL_window_get_key(g_context.window, CGL_KEY_SPACE) == CGL_PRESS) is_physics_on = true;
        if(CGL_window_get_key(g_context.window, CGL_KEY_ENTER) == CGL_PRESS) is_physics_on = false;
    }

    // cleanup
    CGL_noise_shutdown();
    CGL_shader_destroy(present_shader);
    CGL_shader_destroy(draw_shader);
    CGL_texture_destroy(out_tex);
    CGL_framebuffer_destroy(g_context.framebuffer); // destory framebuffer object
    CGL_gl_shutdown(); // shutdown cgl opengl module
    CGL_window_destroy(g_context.window); // destroy window
    CGL_shutdown(); // shutdown cgl and clean up resources allocated by CGL internally (if any)
    return EXIT_SUCCESS;
}

```

`examples/c/slime_mould_sim.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#define CGL_EXCLUDE_NETWORKING
#define CGL_EXCLUDE_RAY_CASTER
#define CGL_EXCLUDE_NODE_EDITOR
#include "cgl.h"

static const char* PASS_THROUGH_VERTEX_SHADER_SOURCE = "#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 normal;\n"
"layout (location = 2) in vec4 texcoord;\n"
"\n"
"out vec3 Position;\n"
"out vec2 TexCoord;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = vec4(position.xyz, 1.0f);\n"
"	Position = position.xyz;\n"
"	TexCoord = texcoord.xy;\n"
"}";

static const char* PASS_THROUGH_FRAGMENT_SHADER_SOURCE = "#version 430 core\n"
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Position;\n"
"in vec2 TexCoord;\n"
"\n"
"uniform sampler2D u_tex;\n"
"\n"
"// Black Box From https://github.com/armory3d/armory/blob/master/Shaders/std/tonemap.glsl\n"
"vec3 acesFilm(const vec3 x) {\n"
"    const float a = 2.51;\n"
"    const float b = 0.03;\n"
"    const float c = 2.43;\n"
"    const float d = 0.59;\n"
"    const float e = 0.14;\n"
"    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	vec3 color = texture(u_tex, vec2(TexCoord.y, 1.0f - TexCoord.x)).rgb;\n"
"	color = acesFilm(color);\n"
"   color = pow(color, vec3(1.0f / 2.2f));\n"
"	FragColor = vec4(color, 1.0f);\n"
"}";

static const char* PARTICLE_COMPUTE_SHADER = "#version 430 core\n"
"\n"
"layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;\n"
"\n"
"layout(rgba32f, binding = 0) uniform image2D trail_map;\n"
"\n"
"struct Particle\n"
"{\n"
"	vec4 position_dir;\n"
"	vec4 extra0;\n"
"};\n"
"\n"
"layout (std430, binding = 1) buffer Particles\n"
"{\n"
"	Particle particles[];\n"
"};\n"
"\n"
"uniform float delta_time;\n"
"uniform float velocity;\n"
"uniform float sensor_fov;\n"
"uniform float sensor_length;\n"
"uniform float sensor_size;\n"
"uniform float dir_randomness;\n"
"uniform int mode;\n"
"uniform vec3 seed = vec3(0.0f);\n"
"uniform vec2 map_size;\n"
"\n"
"\n"
"// Hash function www.cs.ubc.ca/~rbridson/docs/schechter-sca08-turbulence.pdf\n"
"uint hash(uint state)\n"
"{\n"
"    state ^= 2747636419u;\n"
"    state *= 2654435769u;\n"
"    state ^= state >> 16;\n"
"    state *= 2654435769u;\n"
"    state ^= state >> 16;\n"
"    state *= 2654435769u;\n"
"    return state;\n"
"}\n"
"\n"
"float rand(vec2 co)\n"
"{\n"
"    co += seed.xy;\n"
"    return hash(uint(co.x + co.y)) / 4294967295.0f;\n"
"}\n"
"\n"
"void initialize()\n"
"{\n"
"   uint index = gl_GlobalInvocationID.x;\n"
"   Particle particle;\n"
"   particle.position_dir = vec4(rand(vec2(index, 451.54f)) * 2.0f - 1.0f, rand(vec2(1865.54f, index)) * 2.0f - 1.0f, rand(vec2(1865.54f, index)) * 2.0f - 1.0f, rand(vec2(1865.54f, index)) * 2.0f - 1.0f);\n"
"   particle.position_dir.xy = normalize(particle.position_dir.xy) * rand(vec2(index, index)) * 0.3f;\n"
"   particle.position_dir.wz = normalize(particle.position_dir.wz);\n"
"   particle.extra0 = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n"
"   float rand_f = rand(vec2(hash(index), hash(-index)));\n"
"   if (rand_f < 0.3f) particle.extra0.xyz = vec3(1.5f, 0.0f, 0.0f);\n"
"   else if (rand_f < 0.6f) particle.extra0.xyz = vec3(0.0f, 1.5f, 0.0f);\n"
"   else particle.extra0.xyz = vec3(0.0f, 0.0f, 1.5f);\n"
"   particle.extra0.xyz = vec3(rand(vec2(index, 154)), rand(vec2(465, index)), rand(vec2(index, index)));\n"
"   particles[index] = particle;\n"
"}\n"
"\n"
"float get_sensor(vec2 position, vec2 direction, vec3 mask)\n"
"{\n"
"   vec2 pos = position + direction * sensor_length;\n"
"   float sensor_data = 0.0f;\n"
"   ivec2 pos_on_map = ivec2((pos * 0.5f + vec2(0.5f)) * map_size);\n"
"   int sensor_size_i = int(sensor_size);\n"
"   mask = mask * 2.0f - vec3(1.0f);\n"
"   for(int i = -sensor_size_i; i <= sensor_size_i; ++i)\n"
"   {\n"
"       for(int j = -sensor_size_i; j <= sensor_size_i; ++j)\n"
"       {\n"
"          sensor_data = dot(imageLoad(trail_map, pos_on_map + ivec2(i, j)).rgb, mask);\n"
"       }\n"
"   }\n"
"   return sensor_data;\n"
"}\n"
"\n"
"vec2 get_new_direction(vec2 direction, vec2 position, vec3 mask)\n"
"{\n"
"   vec3 sensor_data = vec3(0.0f);\n"
"   vec2 dir1 = direction;\n"
"   vec2 dir0 = vec2(dir1.x * cos(-sensor_fov / 2.0f) - dir1.y * sin(-sensor_fov / 2.0f), dir1.x * sin(-sensor_fov / 2.0f) + dir1.y * cos(-sensor_fov / 2.0f));\n"
"   vec2 dir2 = vec2(dir1.x * cos(sensor_fov / 2.0f) - dir1.y * sin(sensor_fov / 2.0f), dir1.x * sin(sensor_fov / 2.0f) + dir1.y * cos(sensor_fov / 2.0f));\n"
"   sensor_data.x = get_sensor(position, dir0, mask);\n"
"   sensor_data.y = get_sensor(position, dir1, mask);\n"
"   sensor_data.z = get_sensor(position, dir2, mask);\n"
"   if(sensor_data.x > sensor_data.y && sensor_data.x > sensor_data.z) return dir0;\n"
"   if(sensor_data.y > sensor_data.x && sensor_data.y > sensor_data.z) return dir1;\n"
"   if(sensor_data.z > sensor_data.x && sensor_data.z > sensor_data.y) return dir2;\n"
"   return direction;\n"
"}\n"
"\n"
"void update_pt()\n"
"{\n"
"   uint index = gl_GlobalInvocationID.x;\n"
"   Particle particle = particles[index];\n"
"   vec2 position = particle.position_dir.xy;\n"
"   vec2 direction = particle.position_dir.zw;\n"
"   position += direction * delta_time;\n"
"   if (position.x > 1.0f || position.x < -1.0f) direction.x *= -1.0f;\n"
"   if (position.y > 1.0f || position.y < -1.0f) direction.y *= -1.0f;\n"
"   direction = get_new_direction(direction, position, particle.extra0.xyz);\n"
"   position.x = clamp(position.x, -1.0f, 1.0f);\n"
"   position.y = clamp(position.y, -1.0f, 1.0f);\n"
"   vec2 rand_dir = vec2(rand(vec2(index, 451.54f)) * 2.0f - 1.0f, rand(vec2(1865.54f, index)) * 2.0f - 1.0f);"
"   direction = normalize(mix(direction, rand_dir, dir_randomness));\n"
"   particle.position_dir = vec4(position, direction);\n"
"   particles[index] = particle;\n"
"   ivec2 pixel = ivec2((position.xy * 0.5f + vec2(0.5f)) * map_size);\n"
"   imageStore(trail_map, pixel, vec4(particle.extra0.xyz, 1.0f));\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"   if (mode == 0) initialize();\n"
"   else update_pt();\n"
"}\n";

static const char* TRAIL_MAP_COMPUTE_SHADER = "#version 430 core\n"
"\n"
"layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;\n"
"\n"
"layout(rgba32f, binding = 0) uniform image2D trail_map;\n"
"layout(rgba32f, binding = 1) uniform image2D trail_mapo;\n"
"\n"
"struct Particle\n"
"{\n"
"	vec4 position_dir;\n"
"	vec4 extra0;\n"
"};\n"
"\n"
"layout (std430, binding = 0) buffer Particles\n"
"{\n"
"	Particle particles[];\n"
"};\n"
"\n"
"uniform float delta_time;\n"
"uniform int mode;\n"
"uniform vec3 seed = vec3(0.0f);\n"
"\n"
"void initialize()\n"
"{\n"
"   ivec2 index = ivec2(gl_GlobalInvocationID.xy);\n"
"   imageStore(trail_map, index, vec4(0.0f, 0.0f, 0.0f, 1.0f));\n"
"}\n"
"\n"
"vec4 blur_filter(ivec2 uv)\n"
"{\n"
"   vec4 color = vec4(0.0f);\n"
"   for (int i = -2; i <= 2; i++)\n"
"       for (int j = -2; j <= 2; j++)\n"
"           color += imageLoad(trail_map, uv + ivec2(i, j));\n"
"   return color / 25.0f;\n"
"}\n"
"\n"
"void update_tm()\n"
"{\n"
"   ivec2 index = ivec2(gl_GlobalInvocationID.xy);\n"
"   vec4 color = blur_filter(index);\n"
"   color = mix(color, vec4(0.0f), delta_time * 8.0f);\n"
"   imageStore(trail_map, index, color);\n"
"   imageStore(trail_mapo, index, color);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"    if (mode == 0) initialize();\n"
"    else if (mode == 1) update_tm();\n"
"}\n";


#define PARTICLE_COUNT 10000
#define MAP_RESOLUTION 700

static CGL_framebuffer* default_framebuffer = NULL;
static CGL_texture *trail_map = NULL, *trail_mapo = NULL;
static CGL_shader *particle_compute_shader = NULL, *trail_map_compute_shader = NULL, *present_shader = NULL;
static CGL_bloom *bloom = NULL;
static CGL_ssbo *particle_ssbo = NULL;
static CGL_float delta_time = 0.0f, dir_randomness = 0.05f, sensor_length = 0.01f, sensor_angle = CGL_PI_2, sensor_size = 0.0f;

void reset_simulation()
{
    glBindImageTexture(0, trail_map->handle, 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);

    CGL_shader_bind(particle_compute_shader);
    CGL_shader_set_uniform_int(particle_compute_shader, CGL_shader_get_uniform_location(particle_compute_shader, "mode"), 0);
    CGL_shader_set_uniform_vec3v(particle_compute_shader, CGL_shader_get_uniform_location(particle_compute_shader, "seed"), CGL_utils_random_float() * 100.0f, CGL_utils_random_float() * 100.0f, CGL_utils_random_float() * 100.0f);
    CGL_shader_compute_dispatch(particle_compute_shader, PARTICLE_COUNT / 256 + 1, 1, 1);
    glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT | GL_SHADER_STORAGE_BARRIER_BIT);

    CGL_shader_bind(trail_map_compute_shader);
    CGL_shader_set_uniform_int(trail_map_compute_shader, CGL_shader_get_uniform_location(trail_map_compute_shader, "mode"), 0);
    CGL_shader_set_uniform_vec3v(trail_map_compute_shader, CGL_shader_get_uniform_location(trail_map_compute_shader, "seed"), CGL_utils_random_float() * 100.0f, CGL_utils_random_float() * 100.0f, CGL_utils_random_float() * 100.0f);
    CGL_shader_compute_dispatch(trail_map_compute_shader, MAP_RESOLUTION / 16 + 1, MAP_RESOLUTION / 16 + 1, 1);
    glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT | GL_SHADER_STORAGE_BARRIER_BIT);
}

void update_simulation()
{
    glBindImageTexture(0, trail_map->handle, 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
    glBindImageTexture(1, trail_mapo->handle, 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);

    CGL_ssbo_bind(particle_ssbo);

    CGL_shader_bind(particle_compute_shader);
    CGL_shader_set_uniform_int(particle_compute_shader, CGL_shader_get_uniform_location(particle_compute_shader, "mode"), 1);
    CGL_shader_set_uniform_float(particle_compute_shader, CGL_shader_get_uniform_location(particle_compute_shader, "delta_time"), delta_time);
    CGL_shader_set_uniform_float(particle_compute_shader, CGL_shader_get_uniform_location(particle_compute_shader, "sensor_fov"), sensor_angle);
    CGL_shader_set_uniform_float(particle_compute_shader, CGL_shader_get_uniform_location(particle_compute_shader, "sensor_length"), sensor_length);
    CGL_shader_set_uniform_float(particle_compute_shader, CGL_shader_get_uniform_location(particle_compute_shader, "sensor_size"), sensor_size);
    CGL_shader_set_uniform_float(particle_compute_shader, CGL_shader_get_uniform_location(particle_compute_shader, "velocity"), 0.3f);
    CGL_shader_set_uniform_float(particle_compute_shader, CGL_shader_get_uniform_location(particle_compute_shader, "dir_randomness"), dir_randomness);
    CGL_shader_set_uniform_vec2v(particle_compute_shader, CGL_shader_get_uniform_location(particle_compute_shader, "map_size"), MAP_RESOLUTION, MAP_RESOLUTION);
    CGL_shader_compute_dispatch(particle_compute_shader, PARTICLE_COUNT / 256 + 1, 1, 1);
    glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT | GL_SHADER_STORAGE_BARRIER_BIT);

    CGL_shader_bind(trail_map_compute_shader);
    CGL_shader_set_uniform_int(trail_map_compute_shader, CGL_shader_get_uniform_location(trail_map_compute_shader, "mode"), 1);
    CGL_shader_set_uniform_float(trail_map_compute_shader, CGL_shader_get_uniform_location(trail_map_compute_shader, "delta_time"), delta_time);
    CGL_shader_compute_dispatch(trail_map_compute_shader, MAP_RESOLUTION / 16 + 1, MAP_RESOLUTION / 16 + 1, 1);
    glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT | GL_SHADER_STORAGE_BARRIER_BIT);
}

int main()
{
    srand((uint32_t)time(NULL));
    CGL_init();
    CGL_window* window = CGL_window_create(700, 700, "Slime Sim - Jaysmito Mukherjee");
    if(!window) return 1;
    CGL_window_make_context_current(window);
    CGL_gl_init();
    CGL_widgets_init();

    default_framebuffer = CGL_framebuffer_create_from_default(window);
    trail_map = CGL_texture_create_blank(MAP_RESOLUTION, MAP_RESOLUTION, GL_RGBA, GL_RGBA32F, GL_FLOAT);
    trail_mapo = CGL_texture_create_blank(MAP_RESOLUTION, MAP_RESOLUTION, GL_RGBA, GL_RGBA32F, GL_FLOAT);

    present_shader = CGL_shader_create(PASS_THROUGH_VERTEX_SHADER_SOURCE, PASS_THROUGH_FRAGMENT_SHADER_SOURCE, NULL);
    particle_compute_shader = CGL_shader_compute_create(PARTICLE_COMPUTE_SHADER, NULL);
    trail_map_compute_shader = CGL_shader_compute_create(TRAIL_MAP_COMPUTE_SHADER, NULL);

    bloom = CGL_bloom_create(700, 700, 3);

    particle_ssbo = CGL_ssbo_create(1);
    CGL_ssbo_set_data(particle_ssbo, sizeof(CGL_float) * 8 * PARTICLE_COUNT, NULL, GL_DYNAMIC_DRAW);
    
    CGL_float curr_time = CGL_utils_get_time();
    CGL_float prev_time = CGL_utils_get_time();
    CGL_float time = 0.0f, frame_time = 0.0f;
    CGL_int frames = 0, fps = 0;


    reset_simulation();

    while(!CGL_window_should_close(window))
    {
        CGL_window_set_size(window, 700, 700); // force window size to be 600x600

        curr_time = CGL_utils_get_time();
        delta_time = curr_time - prev_time;
        prev_time = curr_time;
        time += delta_time; frame_time += delta_time;
        frames++;
        if(frame_time >= 1.0f) { fps = frames; frames = 0; frame_time = 0.0f; }
        
        update_simulation();

        CGL_bloom_apply(bloom, trail_mapo);

        CGL_framebuffer_bind(default_framebuffer);
        CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);
        CGL_shader_bind(present_shader);
        CGL_texture_bind(trail_mapo, 0);
        CGL_shader_set_uniform_int(present_shader, CGL_shader_get_uniform_location(present_shader, "u_tex"), 0);
        CGL_gl_render_screen_quad();

        glDisable(GL_DEPTH_TEST);

        CGL_widgets_begin();
        
        CGL_widgets_set_fill_colorf(1.0f, 1.0f, 1.0f, 1.0f);
        CGL_widgets_set_stroke_colorf(1.0f, 1.0f, 1.0f, 1.0f);

        static CGL_byte buffer[256];
        sprintf(buffer, "Frame Time: %f", delta_time);
        CGL_widgets_add_string(buffer, -1.0f, 0.975f, 0.5f, 0.025f);
        sprintf(buffer, "Framerate : %d", fps);
        CGL_widgets_add_string(buffer, -1.0f, 0.950f, 0.5f, 0.025f);
        sprintf(buffer, "Particles : %d", PARTICLE_COUNT);
        CGL_widgets_add_string(buffer, -1.0f, 0.925f, 0.5f, 0.025f);  
        sprintf(buffer, "Resolution: %dx%d", MAP_RESOLUTION, MAP_RESOLUTION);
        CGL_widgets_add_string(buffer, -1.0f, 0.900f, 0.5f, 0.025f);
        sprintf(buffer, "Randomness: %f", dir_randomness);
        CGL_widgets_add_string(buffer, -1.0f, 0.875f, 0.5f, 0.025f);
        sprintf(buffer, "Sensor Length: %f", sensor_length);
        CGL_widgets_add_string(buffer, -1.0f, 0.850f, 0.5f, 0.025f);
        sprintf(buffer, "Sensor Angle: %d", (CGL_int)CGL_rad_to_deg(sensor_angle));
        CGL_widgets_add_string(buffer, -1.0f, 0.825f, 0.5f, 0.025f);
        sprintf(buffer, "Sensor Spread: %d", (CGL_int)sensor_size);
        CGL_widgets_add_string(buffer, -1.0f, 0.800f, 0.5f, 0.025f);


        CGL_widgets_end();

        CGL_window_poll_events(window);
        CGL_window_swap_buffers(window);

        if(CGL_window_get_key(window, CGL_KEY_SPACE) == CGL_PRESS) reset_simulation();

        if(CGL_window_get_key(window, CGL_KEY_R) == CGL_PRESS)
        {
            if(CGL_window_get_key(window, CGL_KEY_UP) == CGL_PRESS) dir_randomness += 0.01f;
            if(CGL_window_get_key(window, CGL_KEY_DOWN) == CGL_PRESS) dir_randomness -= 0.01f;
        }

        if(CGL_window_get_key(window, CGL_KEY_L) == CGL_PRESS)
        {
            if(CGL_window_get_key(window, CGL_KEY_UP) == CGL_PRESS) sensor_length += 0.001f;
            if(CGL_window_get_key(window, CGL_KEY_DOWN) == CGL_PRESS) sensor_length -= 0.001f;
        }

        if(CGL_window_get_key(window, CGL_KEY_A) == CGL_PRESS)
        {
            if(CGL_window_get_key(window, CGL_KEY_UP) == CGL_PRESS) sensor_angle += 0.01f;
            if(CGL_window_get_key(window, CGL_KEY_DOWN) == CGL_PRESS) sensor_angle -= 0.01f;
        }
        
        if(CGL_window_get_key(window, CGL_KEY_Z) == CGL_PRESS)
        {
            if(CGL_window_get_key(window, CGL_KEY_UP) == CGL_PRESS) sensor_size += 0.1f;
            if(CGL_window_get_key(window, CGL_KEY_DOWN) == CGL_PRESS) sensor_size -= 0.1f;
        }

    }


    CGL_texture_destroy(trail_map);
    CGL_texture_destroy(trail_mapo);
    CGL_ssbo_destroy(particle_ssbo);
    CGL_shader_destroy(particle_compute_shader);
    CGL_shader_destroy(trail_map_compute_shader);
    CGL_shader_destroy(present_shader);
    CGL_framebuffer_destroy(default_framebuffer);
    CGL_bloom_destroy(bloom);
    CGL_widgets_shutdown();
    CGL_gl_shutdown();
    CGL_window_destroy(window);    
    CGL_shutdown();
    return 0;
}

```

`examples/c/sudoku_game.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/




#define CGL_EXCLUDE_NETWORKING
#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#include "cgl.h"

#define ASPECT_RATIO 1.0f // an aspect ratio on 1.0 will be needed since our sudoku game board will be a square
#define BORDER_WIDTH 0.01f
#define FIXED_COLOR "0.9f, 0.9f, 0.9f"
#define CORRECT_COLOR "0.01f, 0.5f, 0.1f"
#define WRONG_COLOR "0.5f, 0.1f, 0.01f"

static const char* quad_mesh_vertex_shader_source = 
"#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 normal;\n"
"layout (location = 2) in vec4 texcoord;\n"
"\n"
"out vec2 TexCoord;\n"
"\n"
"uniform vec2 ustart;\n"
"uniform vec2 usize;\n"
"\n"
"void main()\n"
"{\n"
"   vec2 pos = position.xy * usize * 0.5f + ustart;\n"
"   gl_Position = vec4(pos, 0.0f, 1.0f);\n"
"   TexCoord = texcoord.xy;\n"
"}\n"
"\n";

static const char* quad_mesh_fragment_shader_source = 
"#version 430 core\n"
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec2 TexCoord;\n"
"\n"
"uniform vec3 ucolor;\n"
"uniform bool uiscolor;\n"
"uniform sampler2D utex;\n"
"\n"
"void main()\n"
"{\n"
"   if(uiscolor)\n"
"       FragColor = vec4(ucolor, 1.0f);\n"
"   else\n"
"       FragColor = texture(utex, TexCoord);\n"
"}\n"
"\n";

static const char* board_vertex_shader_source = 
"#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 normal;\n"
"layout (location = 2) in vec4 texcoord;\n"
"\n"
"out vec2 TexCoord;\n"
"flat out int InstanceID;\n"
"\n"
"uniform float uborder_width;\n"
"\n"
"void main()\n"
"{\n"
"   float offset_x  = float(mod(gl_InstanceID, 9));\n"
"   float offset_y  = float(gl_InstanceID / 9);\n"
"   float usize  = (2.0f - 10.0f * uborder_width) / 9.0f;\n"
"   offset_x = -1.0f + uborder_width + (usize + uborder_width) * offset_x + usize * 0.5f;\n"
"   offset_y = -1.0f + uborder_width + (usize + uborder_width) * offset_y + usize * 0.5f;\n"
"   vec2 pos = position.xy * usize * 0.5f + vec2(offset_x, offset_y);\n"
"   gl_Position = vec4(pos, 0.0f, 1.0f);\n"
"   TexCoord = texcoord.xy;\n"
"   InstanceID = gl_InstanceID;\n"
"}\n"
"\n";

static const char* board_fragment_shader_source = 
"#version 430 core\n"
"\n"
"out vec4 FragColor;\n"
"out int MousePickID0;\n"
"\n"
"in vec2 TexCoord;\n"
"flat in int InstanceID;\n"
"\n"
"struct TileData{vec4 a; vec4 b;};\n"
"\n"
"layout (std430, binding = 0) buffer BoardData\n"
"{\n"
"   TileData texture_offset_size[81];\n"
"};\n"
"\n"
"uniform sampler2D ufont_atlas;\n"
"uniform int uselected_tile;\n"
"uniform int uhovered_tile;\n"
"uniform bool uischeckon;\n"
"\n"
"void main()\n"
"{\n"
"   vec4 data = texture_offset_size[InstanceID].a;\n"
"   vec4 data2 = texture_offset_size[InstanceID].b;\n"
"   vec2 offset = data.xy;\n"
"   vec2 size = data.zw;\n"
"   vec3 backgroud_color = vec3(0.5f);\n"
"   if(uhovered_tile >= 0 && InstanceID == uhovered_tile) backgroud_color = vec3(0.4f);\n"
"   if(InstanceID == uselected_tile) backgroud_color = vec3(0.3f);\n"
"   vec2 texCoord = TexCoord;\n"
"   float factor = texture(ufont_atlas, (vec2(texCoord.x, 1.0f - texCoord.y)) * size + offset).r;\n"
"   vec3 text_color = vec3(0.1f);\n"
"   if(uischeckon)\n"
"   {\n"
"      if(data2.y < 0.5f) text_color = vec3(" WRONG_COLOR ");\n"
"      if(data2.y > 0.5f) text_color = vec3(" CORRECT_COLOR ");\n"
"   }\n"
"   if(data2.x > 0.5f) text_color = vec3(" FIXED_COLOR ");\n"
"   if((factor < 0.5f) || (size.x <= 0.01f))\n"
"      FragColor = vec4(backgroud_color, 1.0f);\n"
"   else\n"
"      FragColor = vec4(text_color, 1.0f);\n"
"   MousePickID0 = InstanceID;\n"
"}\n"
"\n";

struct char10
{
    char d[11];
};

// this will store the gobal application data like window context, mesh handles for renderer, etc.
static struct
{
    CGL_window* window; // the main window
    int window_height;
    int window_width;

    CGL_framebuffer* main_framebuffer;
    CGL_framebuffer* framebuffer;

    CGL_mesh_gpu* quad_mesh;
    CGL_shader* quad_shader;
    int quad_shader_ustart;
    int quad_shader_usize;
    int quad_shader_ucolor;
    int quad_shader_uiscolor;
    int quad_shader_utex;

    CGL_shader* board_shader;
    int board_shader_uborder_width;
    int board_shader_ufont_atlas;
    int board_shader_uselected_tile;
    int board_shader_uhovered_tile;
    int board_shader_uischeckon;
    CGL_ssbo* board_data_ssbo;
    CGL_font* font;
    CGL_texture* you_won_text;
    CGL_texture* instruction_text;

    bool is_check_on;
    bool is_input_allowed;
    int selected_tile;
    int hovered_tile;
    char board_solved[81];
    char board_original[81];
    char board[81];
    bool is_over;

    struct char10 board_gen[81];
    char priority_list[81];
} g_context;

int board_gen_priority_list_sort_comp(const void* el1, const void* el2)
{
    struct char10* elem1 = (struct char10*)el1;
    struct char10* elem2 = (struct char10*)el2;
    if(elem2->d[0] > elem1->d[0]) return -1;
    if(elem2->d[0] < elem1->d[0]) return 1;
    return 0;
}

// i am using selection sort here but it could have been something better like quick sort or merge sort
// but in this case since it is going to run only once every game that too on a very small array so it
// does not matter much
void board_gen_update_priority_list()
{
    int i, j, index;
    for(i = 0 ; i < 81 - 1 ; i ++)
    {
        index = i;
        for(j = i + 1 ; j < 81 ; j++)
            if(board_gen_priority_list_sort_comp(&g_context.board_gen[g_context.priority_list[j]], &g_context.board_gen[g_context.priority_list[index]]) < 0)
                index = j;
        if(index != i)
        {
            char temp = g_context.priority_list[i];
            g_context.priority_list[i] = g_context.priority_list[index];
            g_context.priority_list[index] = temp;
        }
    }
}

void board_gen_collapse_item(int index);

void board_gen_remove_item(int index, char item_val_to_remove)
{
    if(g_context.board_gen[index].d[0] > 1 && g_context.board_gen[index].d[item_val_to_remove] == 1)
    {
        g_context.board_gen[index].d[0] -= 1;
        g_context.board_gen[index].d[item_val_to_remove] = 0;
        if(g_context.board_gen[index].d[0] == 1) board_gen_collapse_item(index);
    }
}

void board_gen_collapse_item(int selected_item)
{
    // get board index of the selected item
    int board_index_x = selected_item % 9;
    int board_index_y = selected_item / 9;
    struct char10* item = &g_context.board_gen[selected_item];
    char item_val_to_remove = -1;
    // select item value to collapse to
    for(int i = 1 ; i < 10 ; i++) 
    {
        if(item->d[i] == 1)
        {
            item->d[i] = 0;
            item_val_to_remove = (char)i;
            item->d[10] = item_val_to_remove;
            break;
        }
    }
    memset(item->d + 1, 0, 9);
    item->d[item_val_to_remove] = 1;
    item->d[0] = 1;
    
    // update the entropies of related items
    // CGL_LOG("Remove %d from Col : %d Row : %d\n", item_val_to_remove, board_index_x, (8 - board_index_y));
    for(int i = 0 ; i < 9 ; i++)
    {        
        board_gen_remove_item(i * 9 + board_index_x, item_val_to_remove); // in the same column
        board_gen_remove_item(board_index_y * 9 + i, item_val_to_remove); // in the same row
    }

    // now in the same 3 x 3 square
    int board_3x3_begin_x = board_index_x - (board_index_x % 3);
    int board_3x3_begin_y = board_index_y - (board_index_y % 3);
    for(int i = board_3x3_begin_y ; i < board_3x3_begin_y + 3 ; i++)
        for(int j = board_3x3_begin_x ; j < board_3x3_begin_x + 3 ; j++)
            board_gen_remove_item(i * 9 + j, item_val_to_remove);            

}

bool board_gen_solve_step()
{
    // first sort the priority list to find item with lowest entropy
    board_gen_update_priority_list(); 

    // then get the range of indices where we have our items with lowest entropy
    int lowest_start = -1;
    int lowest_end = -1;
    char lowest_val = 10;
    for(int i = 0 ; i < 81 ; i++)
    {
        char v = g_context.board_gen[g_context.priority_list[i]].d[0];
        if( v > 1 )
        {
            if(lowest_start == -1 ) {lowest_val = v; lowest_start = i;}
            if(v > lowest_val && lowest_end == -1 ) lowest_end = i - 1;
        }
    }
    if(lowest_end == -1) lowest_end = 81 - 1;
    if(lowest_start == -1) return true; // if all are having 1 entropy then the board is already solved

    // then randomly select a item with lowest entropy to collapse it
    int selected_item = g_context.priority_list[CGL_utils_random_int(lowest_start, lowest_end)];
    board_gen_collapse_item(selected_item);

    return false;
}

void generate_board()
{
    for(int i = 0 ; i < 81 ; i++)
    {
        for(int j = 0 ; j < 10 ; j++)
            g_context.board_gen[i].d[j] = 1;
        g_context.board_gen[i].d[0] = 9;
        g_context.board_gen[i].d[10] = -1;
        g_context.priority_list[i] = (char)i;
    }

    while(!board_gen_solve_step());

    // now copy generated board to board_solved
    for(int i = 0 ; i < 81 ; i++)
        g_context.board_solved[i] = g_context.board_gen[i].d[10];    
}

void upload_board_piece(int peice_index)
{
    CGL_vec4 offset[2];
    offset[0] = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
    offset[1] = CGL_vec4_init(0.0f, 0.0f, 0.0f, 0.0f);
    CGL_font_character* characters = CGL_font_get_characters(g_context.font);
    CGL_font_character* character = &characters[g_context.board[peice_index] + 48];
    if(g_context.board[peice_index] > 0) offset[0] = CGL_vec4_init(character->normalized_offset.x, character->normalized_offset.y, character->normalized_size.x, character->normalized_size.y);
    if(g_context.board_original[peice_index] > 0) offset[1].x = 1.0f;
    if(g_context.board_solved[peice_index] == g_context.board[peice_index]) offset[1].y = 1.0f;
    CGL_ssbo_set_sub_data(g_context.board_data_ssbo, sizeof(CGL_vec4) * 2 * peice_index, sizeof(CGL_vec4) * 2, offset, false);
}

void upload_board()
{
    for(int i = 0 ; i < 81 ; i ++)
        upload_board_piece(i);
}

void reset_game();

void key_callback(CGL_window* window, int key, int scancode, int action, int mods)
{
    int selected_tile_x = g_context.selected_tile % 9;
    int selected_tile_y = g_context.selected_tile / 9;

    if(key == CGL_KEY_R && action == CGL_PRESS) reset_game();

    if(!g_context.is_input_allowed) return;

    if(action == CGL_PRESS)
    {
        if(key == CGL_KEY_UP) selected_tile_y = CGL_utils_clamp(selected_tile_y + 1, 0, 8);
        if(key == CGL_KEY_DOWN) selected_tile_y = CGL_utils_clamp(selected_tile_y - 1, 0, 8);
        if(key == CGL_KEY_RIGHT) selected_tile_x = CGL_utils_clamp(selected_tile_x + 1, 0, 8);
        if(key == CGL_KEY_LEFT) selected_tile_x = CGL_utils_clamp(selected_tile_x - 1, 0, 8);
        g_context.selected_tile = selected_tile_y * 9 + selected_tile_x;


        if(g_context.board_original[g_context.selected_tile] == -1)
        {
            if(key >= CGL_KEY_1 && key <= CGL_KEY_9) g_context.board[g_context.selected_tile] = key - CGL_KEY_0;
            if(key >= CGL_KEY_KP_1 && key <= CGL_KEY_KP_9) g_context.board[g_context.selected_tile] = key - CGL_KEY_KP_0;
            if(key == CGL_KEY_DELETE) g_context.board[g_context.selected_tile] = -1;
            upload_board_piece(g_context.selected_tile);
        }

        if(key == CGL_KEY_C) g_context.is_check_on = true;

        if(key == CGL_KEY_S) // auto solve selected tile
        {
            g_context.board[g_context.selected_tile] = g_context.board_solved[g_context.selected_tile];
            upload_board_piece(g_context.selected_tile);
        }
        if(key == CGL_KEY_A) // auto solve random tile
        {
            int r = CGL_utils_random_int(0, 80);
            g_context.board[r] = g_context.board_solved[r];
            upload_board_piece(r);
        }
        if(key == CGL_KEY_F) // auto solve first unsolved tile tile
        {
            for(int i = 0 ; i < 81 ; i++)
            {
                if(g_context.board[i] == -1)
                {
                    g_context.board[i] = g_context.board_solved[i];
                    upload_board_piece(i);
                    break;
                }
            }
        }
    }
    else if(action == CGL_RELEASE)
    {
        if(key == CGL_KEY_C) g_context.is_check_on = false;        
    }
}


bool setup_window()
{
    g_context.window_height = 400;
    g_context.window_width = (int)(g_context.window_height * ASPECT_RATIO);
    g_context.window = CGL_window_create(g_context.window_width, g_context.window_height, "Sudoku - Jaysmito Mukherjee"); // create the window
    if(g_context.window == NULL) return false; // window creation failed
    CGL_window_make_context_current(g_context.window); // make the opengl context for the window current
    CGL_window_set_key_callback(g_context.window, key_callback);
    return true; // window was successfully created
}

bool setup_framebuffer()
{
    g_context.framebuffer = CGL_framebuffer_create_from_default(g_context.window); // load the default framebuffer (0) into CGL_framebuffer object
    if(g_context.framebuffer == NULL) return false; // failed

    g_context.main_framebuffer = CGL_framebuffer_create(1024, 1024); // for the main rendering
    if(!g_context.main_framebuffer) return false;

    return true; // success
}

bool setup_quad_renderer()
{
    // create a unit quad covering entire drawing area
    CGL_mesh_cpu* quad_mesh_cpu = CGL_mesh_cpu_quad(
        CGL_vec3_init(1.0f, 1.0f, 0.0f),            
        CGL_vec3_init(1.0f, -1.0f, 0.0f),            
        CGL_vec3_init(-1.0f, -1.0f, 0.0f),            
        CGL_vec3_init(-1.0f, 1.0f, 0.0f)
    );
    g_context.quad_mesh = CGL_mesh_gpu_create(); // create the gpu mesh
    if(!g_context.quad_mesh) return false; // failed
    CGL_mesh_gpu_upload(g_context.quad_mesh, quad_mesh_cpu, true); // upload quad mesh data to the gpu mesh
    CGL_mesh_cpu_destroy(quad_mesh_cpu); // free the quad mesh data from cpu as we no longer need it

    g_context.quad_shader = CGL_shader_create(quad_mesh_vertex_shader_source, quad_mesh_fragment_shader_source, NULL); // create the shader
    // load the uiform locations
    g_context.quad_shader_usize = CGL_shader_get_uniform_location(g_context.quad_shader, "usize");
    g_context.quad_shader_ustart = CGL_shader_get_uniform_location(g_context.quad_shader, "ustart");
    g_context.quad_shader_ucolor = CGL_shader_get_uniform_location(g_context.quad_shader, "ucolor");
    g_context.quad_shader_uiscolor = CGL_shader_get_uniform_location(g_context.quad_shader, "uiscolor");
    g_context.quad_shader_utex = CGL_shader_get_uniform_location(g_context.quad_shader, "utex");
    
    return true; // success
}

void render_quad(float start_x, float start_y, float size_x, float size_y, float color_r, float color_g, float color_b)
{
    CGL_shader_bind(g_context.quad_shader); // bind the quad shader
    // set the uniforms
    CGL_shader_set_uniform_vec2v(g_context.quad_shader, g_context.quad_shader_ustart, start_x + size_x / 2.0f, start_y + size_y / 2.0f);
    CGL_shader_set_uniform_vec2v(g_context.quad_shader, g_context.quad_shader_usize, size_x, size_y);
    CGL_shader_set_uniform_vec3v(g_context.quad_shader, g_context.quad_shader_ucolor, color_r, color_g, color_b);
    CGL_shader_set_uniform_bool(g_context.quad_shader, g_context.quad_shader_uiscolor, true);
    CGL_mesh_gpu_render(g_context.quad_mesh); // render the quad mesh
}

void render_quad_texture(float start_x, float start_y, float size_x, float size_y, CGL_texture* texture)
{
    CGL_shader_bind(g_context.quad_shader); // bind the quad shader
    // set the uniforms
    CGL_shader_set_uniform_vec2v(g_context.quad_shader, g_context.quad_shader_ustart, start_x + size_x / 2.0f, start_y + size_y / 2.0f);
    CGL_shader_set_uniform_vec2v(g_context.quad_shader, g_context.quad_shader_usize, size_x, size_y);
    CGL_shader_set_uniform_bool(g_context.quad_shader, g_context.quad_shader_uiscolor, false);
    CGL_texture_bind(texture, 0);
    CGL_shader_set_uniform_int(g_context.quad_shader, g_context.quad_shader_utex, 0);
    CGL_mesh_gpu_render(g_context.quad_mesh); // render the quad mesh
}

bool setup_board_renderer()
{
    g_context.font = CGL_font_load("font.ttf"); // load font from file
    if(!g_context.font) return false; // failed
    if(!CGL_font_build_atlas(g_context.font, 1024, 1024, 56)) return false; // build and rastarize the font atlas
    
    g_context.you_won_text = CGL_text_bake_to_texture("You Won!", strlen("You Won!"), g_context.font, NULL, NULL);
    g_context.instruction_text = CGL_text_bake_to_texture("Press R to restart", strlen("Press R to restart"), g_context.font, NULL, NULL);

    g_context.board_shader = CGL_shader_create(board_vertex_shader_source, board_fragment_shader_source, NULL); // setup board shader
    // load up unifrom locations
    g_context.board_shader_uborder_width = CGL_shader_get_uniform_location(g_context.board_shader, "uborder_width");
    g_context.board_shader_ufont_atlas = CGL_shader_get_uniform_location(g_context.board_shader, "ufont_atlas");
    g_context.board_shader_uhovered_tile = CGL_shader_get_uniform_location(g_context.board_shader, "uhovered_tile");
    g_context.board_shader_uselected_tile = CGL_shader_get_uniform_location(g_context.board_shader, "uselected_tile");
    g_context.board_shader_uischeckon = CGL_shader_get_uniform_location(g_context.board_shader, "uischeckon");

    g_context.board_data_ssbo = CGL_ssbo_create(0); // create ssbo board data
    CGL_ssbo_set_data(g_context.board_data_ssbo, sizeof(CGL_vec4) * 2 * 81, NULL, false); // upload fresh data

    return true;
}

void render_board()
{
    CGL_shader_bind(g_context.board_shader); // bind the board shader
    // set the unifroms
    CGL_shader_set_uniform_float(g_context.board_shader, g_context.board_shader_uborder_width, BORDER_WIDTH);
    CGL_texture_bind(CGL_font_get_atlas(g_context.font), 0);
    CGL_shader_set_uniform_int(g_context.board_shader, g_context.board_shader_ufont_atlas, 0);
    CGL_shader_set_uniform_int(g_context.board_shader, g_context.board_shader_uselected_tile, g_context.selected_tile);
    CGL_shader_set_uniform_int(g_context.board_shader, g_context.board_shader_uhovered_tile, g_context.hovered_tile);
    CGL_shader_set_uniform_bool(g_context.board_shader, g_context.board_shader_uischeckon, g_context.is_check_on);
    CGL_mesh_gpu_render_instanced(g_context.quad_mesh, 81); // we need 81 quads for the entire sudoku board
}

void reset_game()
{
    g_context.is_over = false; 
    g_context.is_check_on = false;
    g_context.is_input_allowed = true;
    g_context.hovered_tile = -1;
    g_context.selected_tile = 4 * 9 + 4;
    memset(g_context.board, -1, sizeof(g_context.board));
    
    // this only generates the solved board
    generate_board();

    // now lets generate unsolvd board
    for(int i = 0 ; i < 9 ; i+= 3)
    {
        for(int j = 0 ; j < 9 ; j+= 3)
        {
            int ind_x = CGL_utils_random_int(i, i + 2);
            int ind_y = CGL_utils_random_int(j, j + 2);
            int ind = ind_y * 9 + ind_x;
            g_context.board[ind] = g_context.board_solved[ind];
        }
    }
           
    memcpy(g_context.board_original, g_context.board, sizeof(g_context.board));
    upload_board();
}

int main()
{
    srand((uint32_t)time(NULL));
    if(!CGL_init()) return EXIT_FAILURE; // initialize CGL (required for setting up internals of CGL)
    if(!setup_window()) return EXIT_FAILURE; //setup window
    if(!CGL_gl_init()) return EXIT_FAILURE; // initialize cgl opengl module    
    if(!CGL_text_init()) return EXIT_FAILURE; // initialize cgl text/font module
    if(!setup_framebuffer()) return EXIT_FAILURE; //setup framebuffer
    if(!setup_quad_renderer()) return EXIT_FAILURE; // setup up the mechanism for rendering quads
    if(!setup_board_renderer()) return EXIT_FAILURE; // setup the mechanism to render the 9x9 sudoku board
    reset_game(); // reset game data

    const float board_tile_size = (2.0f - 10.0f * BORDER_WIDTH) / 9.0f;

    // the main loop
    while(!CGL_window_should_close(g_context.window)) // run till the close button is clicked
    {
        // rendering
        CGL_framebuffer_bind(g_context.main_framebuffer); // bind main framebuffer and also adjust viewport size and offset
        CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f); // clear screen with a dark gray color

        // render the borders
        for(int i = 0 ; i <= 9 ; i+=3)
        {
            render_quad(-1.0f, -1.0f + i * (BORDER_WIDTH + board_tile_size), 2.0f, BORDER_WIDTH, 1.0f, 1.0f, 1.0f);
            render_quad(-1.0f + i * (BORDER_WIDTH + board_tile_size), -1.0f, BORDER_WIDTH, 2.0f, 1.0f, 1.0f, 1.0f);
        }

        // render the board
        render_board();

        if(g_context.is_over)
        {
            // you can optionaly enable it but i am disabling it as i dont want to add more code just for rendering this text!
            // render_quad_texture(-0.5f, -0.5f, 1.0f, 1.0f, g_context.you_won_text);
            // render_quad_texture(-0.5f, -0.8f, 1.0f, 0.15f, g_context.instruction_text);
        }

        CGL_framebuffer_bind(g_context.framebuffer); // bind default framebuffer and also adjust viewport size and offset
        CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f); // clear screen with a dark gray color
        render_quad_texture(-1.0f, -1.0f, 2.0f, 2.0f, CGL_framebuffer_get_color_texture(g_context.main_framebuffer));

        CGL_window_swap_buffers(g_context.window); // swap framebuffers
        CGL_window_poll_events(g_context.window); // poll events (if this is not called every frame window will stop responding)

        double mouse_x_pos = 0.0, mouse_y_pos = 0.0;
        CGL_window_get_mouse_position(g_context.window, &mouse_x_pos, &mouse_y_pos);
        g_context.hovered_tile = -1; //  reset hovered tile
        if(mouse_x_pos > 0.0 && mouse_y_pos > 0.0 && mouse_x_pos < g_context.window_width && mouse_y_pos < g_context.window_height)
        {
            int mouse_pick_id = CGL_framebuffer_get_mouse_pick_id(g_context.main_framebuffer, (int)CGL_utils_clamp(mouse_x_pos / g_context.window_width * 1024.0, 0.0, 1024.0), (int)CGL_utils_clamp(mouse_y_pos / g_context.window_height * 1024.0, 0.0, 1024.0), 0);
            if(mouse_pick_id >= 0 && mouse_pick_id < 81) g_context.hovered_tile = mouse_pick_id; // set hovered tile
        }
        // select tile if clicked
        if(g_context.hovered_tile >= 0 && CGL_window_get_mouse_button(g_context.window, CGL_MOUSE_BUTTON_LEFT) == CGL_PRESS) g_context.selected_tile = g_context.hovered_tile;

        if(memcmp(g_context.board, g_context.board_solved, sizeof(g_context.board)) == 0)
        {
            g_context.is_input_allowed = false;
            g_context.is_over = true;
            g_context.is_check_on = true;
        }

        // make sure window aspect ratio is constant
        int new_window_height = 0, new_window_width = 0;
        CGL_window_get_size(g_context.window, &new_window_width, &new_window_height); // get new size
        if(new_window_height != g_context.window_height) new_window_width = (int)(new_window_height * ASPECT_RATIO); // height is changed so width is corrected
        else if(new_window_width != g_context.window_width) new_window_height = (int)(new_window_width / ASPECT_RATIO); // width is changed so height is corrected
        g_context.window_height = new_window_height; // update the context
        g_context.window_width = new_window_width; // update the context
        CGL_window_set_size(g_context.window, g_context.window_width, g_context.window_height); // set the corrected sizes (NOTE: its not ideal to do it every frame but it wont be that big of a performance issue in this case)
                
        if(CGL_window_get_key(g_context.window, CGL_KEY_ESCAPE) == CGL_PRESS) break; // quit on pressing escape
    }

    // cleanup
    CGL_texture_destroy(g_context.you_won_text); // destroy the texture
    CGL_texture_destroy(g_context.instruction_text); // destroy the texture
    CGL_font_destory(g_context.font); // destroy the font
    CGL_shader_destroy(g_context.board_shader); // destory board shader
    CGL_mesh_gpu_destroy(g_context.quad_mesh); // destory quad mesh
    CGL_shader_destroy(g_context.quad_shader); // destory quad shader
    CGL_framebuffer_destroy(g_context.main_framebuffer); // destory framebuffer object
    CGL_framebuffer_destroy(g_context.framebuffer); // destory framebuffer object
    CGL_text_shutdown(); // shutdown cgl text module
    CGL_gl_shutdown(); // shutdown cgl opengl module
    CGL_window_destroy(g_context.window); // destroy window
    CGL_shutdown(); // shutdown cgl and clean up resources allocated by CGL internally (if any)
    return EXIT_SUCCESS;
}


```

`examples/c/text_widgets_example.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_IMPLEMENTATION
#include "cgl.h"


int main()
{
    srand((uint32_t)time(NULL));
    CGL_init();
    CGL_window* window = CGL_window_create(640, 320, "CGL Text Widgets - Jaysmito Mukherjee");
    CGL_window_make_context_current(window); 
    CGL_gl_init();
    CGL_widgets_init();
    if(window == NULL) return false; 
    CGL_framebuffer* framebuffer = CGL_framebuffer_create_from_default(window);


    while(!CGL_window_should_close(window)) 
    {
        CGL_framebuffer_bind(framebuffer);
        CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);

        CGL_widgets_begin();
        CGL_widgets_add_string("C G L", -0.5f, -0.5f, 1.0f, 1.0f);
        CGL_widgets_end();

        CGL_window_swap_buffers(window);
        CGL_window_poll_events(window);
    }

    
    CGL_framebuffer_destroy(framebuffer);
    CGL_widgets_shutdown();
    CGL_gl_shutdown();
    CGL_window_destroy(window);
    CGL_shutdown();
    return EXIT_SUCCESS;
}

```

`examples/c/texture_widgets.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_EXCLUDE_NETWORKING
#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#include "cgl.h"

static struct
{
    CGL_window* window; // the main window
    int window_height;
    int window_width;
    CGL_framebuffer* framebuffer;
} g_context;

int main()
{
    srand((uint32_t)time(NULL));
    if(!CGL_init()) return EXIT_FAILURE; // initialize CGL (required for setting up internals of CGL)
    g_context.window_height = 600;
    g_context.window_width = 600;
    g_context.window = CGL_window_create(g_context.window_width, g_context.window_height, "Tests - Jaysmito Mukherjee"); // create the window
    if(g_context.window == NULL) return false; // window creation failed
    CGL_window_make_context_current(g_context.window); // make the opengl context for the window current
    if(!CGL_gl_init()) return EXIT_FAILURE; // initialize cgl opengl module    
    g_context.framebuffer = CGL_framebuffer_create_from_default(g_context.window); // load the default framebuffer (0) into CGL_framebuffer object
    if(g_context.framebuffer == NULL) return false; // failed
    if(!CGL_widgets_init()) return EXIT_FAILURE; 

    CGL_framebuffer* fbo = CGL_framebuffer_create(g_context.window_width, g_context.window_height);

    // the main loop
    while(!CGL_window_should_close(g_context.window)) // run till the close button is clicked
    {
        CGL_window_set_size(g_context.window, g_context.window_width, g_context.window_height); // set window size
        // rendering
        CGL_framebuffer_bind(fbo); // bind default framebuffer and also adjust viewport size and offset
        CGL_gl_clear(0.1f, 0.2f, 0.1f, 1.0f); // clear screen with a dark gray color

        CGL_widgets_begin();
        
        float offx = -0.4f;
        float offy = -0.4f;
        srand(42);
        
        for(;offx <= 0.4 ; offx += 0.1f, offy += 0.1f)
        {
            CGL_color color = CGL_utils_random_color();
            CGL_widgets_set_fill_colorf(color.x, color.y, color.z, 1.0f);
            CGL_widgets_add_triangle(   
                CGL_vec3_init(-0.5f + offx, -0.5f + offy, 0.0f),
                CGL_vec3_init( 0.5f + offx, -0.5f + offy, 0.0f),
                CGL_vec3_init( 0.0f + offx,  0.5f + offy, 0.0f)
                );
        }
        CGL_widgets_flush();
        CGL_framebuffer_bind(g_context.framebuffer); // bind default framebuffer and also adjust viewport size and offset
        CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f); // clear screen with a dark gray color        
        CGL_widgets_set_texture(CGL_framebuffer_get_color_texture(fbo));
        CGL_widgets_set_texture_coordinate_so(1.0f, 1.0f, 0.5f, 0.0f); CGL_widgets_add_rect2f(0.0f, 0.0f, 1.0f, 1.0f);
        CGL_widgets_set_texture_coordinate_so(1.0f, 1.0f, 0.0f, 0.5f); CGL_widgets_add_rect2f(-1.0f, -1.0f, 1.0f, 1.0f);
        CGL_widgets_end();
        CGL_window_swap_buffers(g_context.window); // swap framebuffers
        CGL_window_poll_events(g_context.window); // poll events (if this is not called every frame window will stop responding)
        if(CGL_window_get_key(g_context.window, CGL_KEY_ESCAPE) == CGL_PRESS) break; // quit on pressing escape
    }
    // cleanup
    CGL_widgets_shutdown(); // shutdown cgl widgets module
    CGL_framebuffer_destroy(g_context.framebuffer); // destory framebuffer object
    CGL_framebuffer_destroy(fbo); // destory framebuffer object
    CGL_gl_shutdown(); // shutdown cgl opengl module
    CGL_window_destroy(g_context.window); // destroy window
    CGL_shutdown(); // shutdown cgl and clean up resources allocated by CGL internally (if any)
    return EXIT_SUCCESS;
}

```

`examples/c/toon_post_processor.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#include "cgl.h"

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

#include <glm/glm.hpp>
#include <glm/gtc/type_ptr.hpp>

static const char* VS_diffuse = "#version 430 core\n"
"layout(location = 0) in vec4 aPos;\n"
"layout(location = 1) in vec4 aNormal;\n"
"layout(location = 2) in vec4 aTexCoords;\n"
"\n"
"out vec3 FragPos;\n"
"out vec3 Normal;\n"
"out vec2 TexCoords;\n"
"\n"
"uniform mat4 model;\n"
"uniform mat4 view;\n"
"uniform mat4 projection;\n"
"\n"
"void main()\n"
"{\n"
"    mat4 model_view = view * model;\n"
"    FragPos = vec3(model * aPos);\n"
"    Normal = mat3(transpose(inverse(model_view))) * aNormal.xyz;\n"
"    TexCoords = aTexCoords.xy;\n"
"    gl_Position = projection * model_view * vec4(aPos.xyz, 1.0f);\n"
"}\n";

static const char* FS_diffuse = "#version 430 core\n"
"in vec3 FragPos;\n"
"in vec3 Normal;\n"
"in vec2 TexCoords;\n"
"\n"
"layout(location = 0) out vec4 FragColor;\n"
"layout(location = 1) out vec4 AlbedoOut;\n"
"layout(location = 2) out vec4 NormalOut;\n"
"\n"
"uniform vec3 lightPos;\n"
"\n"
"uniform sampler2D texture_diffuse;\n"
"\n"
"void main()\n"
"{\n"
"    //FragColor = vec4(1.0);return;\n"
"    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n"
"    vec3 objectColor = pow(texture(texture_diffuse, TexCoords).rgb, vec3(2.2f));\n"
"\n"
"    vec3 ambient = 0.1f * lightColor;\n"
"\n"
"    vec3 norm = normalize(Normal);\n"
"    vec3 lightDir = normalize(lightPos - FragPos);\n"
"    float diff = max(dot(norm, lightDir), 0.0);\n"
"    vec3 diffuse = diff * lightColor;\n"
"\n"
"    vec3 result = (ambient + diffuse) * objectColor;\n"
"    FragColor = vec4(result, 1.0);\n"
"    AlbedoOut = vec4(objectColor, 1.0);\n"
"    NormalOut = vec4(norm, 1.0);\n"
"}\n";

static const char* VS_presentation = "#version 430 core\n"
"layout(location = 0) in vec4 aPos;\n"
"layout(location = 1) in vec4 aNormal;\n"
"layout(location = 2) in vec4 aTexCoords;\n"
"\n"
"out vec2 TexCoords;\n"
"\n"
"void main()\n"
"{\n"
"    TexCoords = aTexCoords.xy;\n"
"    gl_Position = vec4(aPos.xy, 0.0f, 1.0f);\n"
"}\n";

static const char* FS_presentation = "#version 430 core\n"
"in vec2 TexCoords;\n"
"\n"
"// Filmic Tonemapping Operators http://filmicworlds.com/blog/filmic-tonemapping-operators/\n"
"vec3 filmic(vec3 x) {\n"
"  vec3 X = max(vec3(0.0), x - 0.004);\n"
"  vec3 result = (X * (6.2 * X + 0.5)) / (X * (6.2 * X + 1.7) + 0.06);\n"
"  return pow(result, vec3(2.2));\n"
"}\n"
"out vec4 FragColor;\n"
"\n"
"uniform sampler2D texture_scene;\n"
"\n"
"void main()\n"
"{\n"
"    vec2 uv = vec2(TexCoords.y, 1.0f - TexCoords.x);\n"
"    vec3 scene = texture(texture_scene, uv).rgb;\n"
"    scene = filmic(scene);\n"
"    FragColor = vec4(scene, 1.0);\n"
"}\n";

static struct
{
    CGL_texture* tex[3];
    CGL_mesh_gpu* model[3];
    CGL_int selected_model;
    CGL_shader* diffuse_shader;
    CGL_shader* presentation_shader;
} g_resources;

CGL_texture* load_texture(const char* filename)
{
    CGL_image img = {0};
    img.bytes_per_channel = 8;
    stbi_set_flip_vertically_on_load(true);
    img.data = stbi_load(filename, &img.width, &img.height, &img.channels, 0);
    if (!img.data)
    {
        CGL_error("Failed to load image: %s", filename);
        return NULL;
    }
    CGL_texture* tex = CGL_texture_create(&img);
    stbi_image_free(img.data);
    return tex;
}

void load_resources()
{
    // NOTE: I dont own the models so I cant redistribute them so if you are trying to run this example you will have to find your own models and textures to use

    // load the bulbasaur model
    g_resources.tex[0] = load_texture("./assets/bulba.jpg");
    CGL_mesh_cpu* bulba_model_cpu = CGL_mesh_cpu_load_obj("./assets/bulba.obj");
    g_resources.model[0] = CGL_mesh_gpu_create();
    CGL_mesh_gpu_upload(g_resources.model[0], bulba_model_cpu, true);
    CGL_mesh_cpu_destroy(bulba_model_cpu);

    // load the charmander model
    g_resources.tex[1] = load_texture("./assets/charm.jpg");
    CGL_mesh_cpu* charm_model_cpu = CGL_mesh_cpu_load_obj("./assets/charm.obj");
    g_resources.model[1] = CGL_mesh_gpu_create();
    CGL_mesh_gpu_upload(g_resources.model[1], charm_model_cpu, true);
    CGL_mesh_cpu_destroy(charm_model_cpu);

    // load the squirtle model
    g_resources.tex[2] = load_texture("./assets/squirt.jpg");
    CGL_mesh_cpu* squirt_model_cpu = CGL_mesh_cpu_load_obj("./assets/squirt.obj");
    g_resources.model[2] = CGL_mesh_gpu_create();
    CGL_mesh_gpu_upload(g_resources.model[2], squirt_model_cpu, true);
    CGL_mesh_cpu_destroy(squirt_model_cpu);

    // load the shaders
    g_resources.diffuse_shader = CGL_shader_create(VS_diffuse, FS_diffuse, NULL);
    g_resources.presentation_shader = CGL_shader_create(VS_presentation, FS_presentation, NULL);

    g_resources.selected_model = 0;

}

void free_resources()
{
    // free the models and textures
    for (int i = 0; i < 3; ++i)
    {
        CGL_texture_destroy(g_resources.tex[i]);
        CGL_mesh_gpu_destroy(g_resources.model[i]);
    }

    // free the shaders
    CGL_shader_destroy(g_resources.diffuse_shader);
    CGL_shader_destroy(g_resources.presentation_shader);
}

void print_mat4(const char* name, float* m)
{
    printf("%s = \n\t", name);
    for (int i = 0; i < 16; i++)
    {
        printf("%f ", m[i]);
        if ((i+1) % 4 == 0) printf("\n\t");
    }
    printf("\n");
}

int main()
{
    srand((uint32_t)time(NULL));
    if(!CGL_init()) return -1;
    CGL_window* main_window = CGL_window_create(512, 512, "Toon Shading - Jaysmito Mukherjee");
    if(!main_window) return -1;
    CGL_window_make_context_current(main_window);
    if(!CGL_gl_init()) return -1;
    CGL_framebuffer* default_framebuffer = CGL_framebuffer_create_from_default(main_window);   
    CGL_framebuffer* g_buffer = CGL_framebuffer_create_basic(512, 512);
    CGL_framebuffer_add_color_attachment(g_buffer, CGL_texture_create_blank(512, 512, GL_RGBA, GL_RGBA, GL_FLOAT)); // for albedo
    CGL_framebuffer_add_color_attachment(g_buffer, CGL_texture_create_blank(512, 512, GL_RGBA, GL_RGBA, GL_FLOAT)); // for normal
    CGL_toon_post_processor_init();

    CGL_bool toon_shading = false;
    CGL_float outline_width = 1.0f;
    CGL_int shades = 4;
    CGL_mat4 projection = CGL_mat4_perspective(CGL_deg_to_rad(45.0f), 1.0f, 0.01f, 100.0f);
    CGL_mat4 view = CGL_mat4_look_at(CGL_vec3_init(0.0f, 5.0f, 10.0f), CGL_vec3_init(0.0f, 1.5f, 0.0f), CGL_vec3_init(0.0f, 1.0f, 0.0f));
    CGL_mat4 model = CGL_mat4_identity();

    load_resources();

    while(!CGL_window_should_close(main_window))
    { 
        CGL_window_set_size(main_window, 512, 512); // force window size to be 512x512

        
        CGL_mat4 temp;
        model = CGL_mat4_identity();
        temp = CGL_mat4_translate(0.3f, 0.1f, 0.0f);
        model = CGL_mat4_mul(temp, model);
        temp = CGL_mat4_rotate_y( (CGL_PI * (CGL_utils_get_time() * -0.5f)) );
        model = CGL_mat4_mul(temp, model);
        temp = CGL_mat4_scale(0.1f, 0.1f, 0.1f);
        model = CGL_mat4_mul(temp, model);

        // scene render pass
        {
            glEnable(GL_DEPTH_TEST);
            glDepthFunc(GL_LESS);
            glDisable(GL_BLEND);
            CGL_framebuffer_bind(g_buffer);
            CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);
            CGL_shader_bind(g_resources.diffuse_shader);
            CGL_shader_set_uniform_mat4(g_resources.diffuse_shader, CGL_shader_get_uniform_location(g_resources.diffuse_shader, "projection"), &projection);
            CGL_shader_set_uniform_mat4(g_resources.diffuse_shader, CGL_shader_get_uniform_location(g_resources.diffuse_shader, "view"), &view);
            CGL_shader_set_uniform_mat4(g_resources.diffuse_shader, CGL_shader_get_uniform_location(g_resources.diffuse_shader, "model"), &model);
            CGL_shader_set_uniform_vec3v(g_resources.diffuse_shader, CGL_shader_get_uniform_location(g_resources.diffuse_shader, "lightPos"), 0.0f, 3.0f, 5.0f);
            CGL_texture_bind(g_resources.tex[g_resources.selected_model], 0);
            CGL_shader_set_uniform_int(g_resources.diffuse_shader, CGL_shader_get_uniform_location(g_resources.diffuse_shader, "texture_diffuse"), 0);
            CGL_mesh_gpu_render(g_resources.model[g_resources.selected_model]);           
        }

        // toon shading pass
        if(toon_shading)
        {
            CGL_toon_post_processor_process_shades(CGL_framebuffer_get_color_attachment(g_buffer, 0), CGL_framebuffer_get_color_attachment(g_buffer, 0), CGL_framebuffer_get_color_attachment(g_buffer, 1), shades);
            CGL_toon_post_processor_process_outline(CGL_framebuffer_get_color_attachment(g_buffer, 0), CGL_framebuffer_get_color_attachment(g_buffer, 0), CGL_framebuffer_get_color_attachment(g_buffer, 2), CGL_framebuffer_get_depth_texture(g_buffer), outline_width);
        }

        // presentation pass
        {
            CGL_framebuffer_bind(default_framebuffer);
            CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);
            CGL_shader_bind(g_resources.presentation_shader);
            CGL_texture_bind(CGL_framebuffer_get_color_attachment(g_buffer, 0), 0);
            CGL_shader_set_uniform_int(g_resources.presentation_shader, CGL_shader_get_uniform_location(g_resources.presentation_shader, "texture_scene"), 0);
            CGL_gl_render_screen_quad();
        }

        CGL_window_poll_events(main_window);
        CGL_window_swap_buffers(main_window);
        
        if(CGL_window_get_key(main_window, CGL_KEY_1) == CGL_PRESS) g_resources.selected_model = 0;
        if(CGL_window_get_key(main_window, CGL_KEY_2) == CGL_PRESS) g_resources.selected_model = 1;
        if(CGL_window_get_key(main_window, CGL_KEY_3) == CGL_PRESS) g_resources.selected_model = 2;
        if(CGL_window_get_key(main_window, CGL_KEY_T) == CGL_PRESS) toon_shading = true;
        if(CGL_window_get_key(main_window, CGL_KEY_D) == CGL_PRESS) toon_shading = false;
        if(CGL_window_get_key(main_window, CGL_KEY_UP) == CGL_PRESS) outline_width += 0.01f;
        if(CGL_window_get_key(main_window, CGL_KEY_DOWN) == CGL_PRESS) outline_width -= 0.01f;
        for(int i = 0; i < 10; i++) if(CGL_window_get_key(main_window, CGL_KEY_KP_0 + i) == CGL_PRESS) shades = i;
        if(CGL_window_get_key(main_window, CGL_KEY_ESCAPE) == CGL_PRESS) break;
    }

    free_resources();

    CGL_toon_post_processor_shutdown();
    CGL_framebuffer_destroy(g_buffer);
    CGL_framebuffer_destroy(default_framebuffer);
    CGL_gl_shutdown();
    CGL_window_destroy(main_window);
    CGL_shutdown();
    return 0;
}

```

`examples/c/trail_renderer.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#define CGL_EXCLUDE_NETWORKING
#define CGL_EXCLUDE_RAY_CASTER
#define CGL_EXCLUDE_NODE_EDITOR
#define CGL_EXCLUDE_WIDGETS
#define CGL_EXCLUDE_AUDIO
#define CGL_EXCLUDE_TEXT_RENDER
#include "cgl.h"

#ifdef CGL_WASM
#include <emscripten/emscripten.h>
#include <emscripten/html5.h>
#else
#define EM_BOOL int
#endif

#define TRAIL_COUNT 16

static const char* PASS_THROUGH_VERTEX_SHADER_SOURCE = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
"in vec4 position;\n"
"in vec4 normal;\n"
"in vec4 texcoord;\n"
#else
"#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n"
"layout (location = 1) in vec4 normal;\n"
"layout (location = 2) in vec4 texcoord;\n"
#endif
"\n"
"out vec3 Position;\n"
"out vec2 TexCoord;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = vec4(position.xyz, 1.0f);\n"
"	Position = position.xyz;\n"
"	TexCoord = texcoord.xy;\n"
"}";

static const char* PASS_THROUGH_FRAGMENT_SHADER_SOURCE =
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"precision highp int;\n"
#else
"#version 430 core\n"
#endif
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Position;\n"
"in vec2 TexCoord;\n"
"\n"
"uniform sampler2D u_tex;\n"
"\n"
"// Black Box From https://github.com/armory3d/armory/blob/master/Shaders/std/tonemap.glsl\n"
"vec3 acesFilm(const vec3 x) {\n"
"    const float a = 2.51;\n"
"    const float b = 0.03;\n"
"    const float c = 2.43;\n"
"    const float d = 0.59;\n"
"    const float e = 0.14;\n"
"    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	vec3 color = texture(u_tex, vec2(TexCoord.y, 1.0f - TexCoord.x)).rgb;\n"
"	color = acesFilm(color);\n"
"   color = pow(color, vec3(1.0f / 2.2f));\n"
"	FragColor = vec4(color, 1.0f);\n"
"}";


static const char* TRAIL_VERTEX_SHADER = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
"\n"
"in vec4 position;\n"
"in vec4 normal;\n"
"in vec4 texcoord;\n"
#else
"#version 430 core\n"
"\n"
"layout (location = 0) in vec4 position;\n" // w is lifespan
"layout (location = 1) in vec4 normal;\n" // w is distance
"layout (location = 2) in vec4 texcoord;\n" // zw is reserved for future use
#endif
"\n"
"out vec3 Position;\n"
"out vec2 TexCoord;\n"
"out float Distance;\n"
"out float Life;\n"
"\n"
"uniform mat4 projection;\n"
"uniform mat4 view;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = projection * view * vec4(position.xyz, 1.0f);\n"
"	Position = position.xyz;\n"
"	TexCoord = texcoord.xy;\n"
"   Distance = normal.w;\n"
"   Life = position.w;\n"
"}\n";

static const char* TRAIL_FRAGMENT_SHADER = 
#ifdef CGL_WASM
"#version 300 es\n"
"precision highp float;\n"
#else
"#version 430 core\n"
#endif
"\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 Position;\n"
"in vec2 TexCoord;\n"
"in float Distance;\n"
"in float Life;\n"
"\n"
"uniform vec3 color;\n"
"uniform float total_length;\n"
"\n"
"void main()\n"
"{\n"
"	FragColor = vec4(mix(color, vec3(0.0f), (10.0f - Life) / 10.0f), 1.0f);\n"
"}\n";

bool point_function(CGL_trail* trail, CGL_trail_point* point)
{
    point->thickness = 0.1f * (trail->length - point->distance) / trail->length;
    return false;
}

static struct {
    CGL_window* window;
    CGL_framebuffer* default_framebuffer;
    CGL_framebuffer* bloom_framebuffer;
    CGL_shader* present_shader;
    CGL_shader* trail_shader;
    CGL_trail* trail[TRAIL_COUNT];
    CGL_vec3 trail_color[TRAIL_COUNT];
    CGL_float start_time;
    CGL_mat4 projection;
    CGL_mat4 view;
    CGL_vec3 trail_tip_pos[TRAIL_COUNT];
    CGL_vec3 trail_tip_pos_tar[TRAIL_COUNT];
    CGL_vec3 trail_tip_pos_trpt[TRAIL_COUNT * 2];
    CGL_float trail_tip_pos_thresh[TRAIL_COUNT];

#ifndef CGL_WASM
    CGL_bloom* bloom;
#endif
} g_State;

bool init()
{
    srand((uint32_t)time(NULL));
    if(!CGL_init()) return false;
    g_State.window = CGL_window_create(600, 600, "Trails - Jaysmito Mukherjee");
    if(!g_State.window) return false;
    CGL_window_make_context_current(g_State.window);
    CGL_gl_init();
    g_State.default_framebuffer = CGL_framebuffer_create_from_default(g_State.window);
    g_State.bloom_framebuffer = CGL_framebuffer_create_basic(600, 600);
    g_State.present_shader = CGL_shader_create(PASS_THROUGH_VERTEX_SHADER_SOURCE, PASS_THROUGH_FRAGMENT_SHADER_SOURCE, NULL);
    g_State.trail_shader = CGL_shader_create(TRAIL_VERTEX_SHADER, TRAIL_FRAGMENT_SHADER, NULL);
    g_State.projection = CGL_mat4_perspective(CGL_deg_to_rad(45.0f), 1.0f, 0.01f, 100.0f);
    g_State.view = CGL_mat4_identity();
    g_State.start_time = CGL_utils_get_time();
#ifndef CGL_WASM
    g_State.bloom = CGL_bloom_create(600, 600, 3);
#endif

    for(int i = 0; i < TRAIL_COUNT; i++)
    {
        g_State.trail[i] = CGL_trail_create();
        CGL_trail_set_min_points_distance(g_State.trail[i], 0.01f);
        CGL_trail_set_resolution(g_State.trail[i], 32);
        CGL_trail_set_point_update_function(g_State.trail[i], point_function);
    }

    CGL_float max_ar = 3.0f;
    CGL_float min_ar = -3.0f;
    for(int i = 0; i < TRAIL_COUNT; i++) { g_State.trail_tip_pos[i] = CGL_vec3_init(CGL_utils_random_float() * (max_ar - min_ar) + min_ar, CGL_utils_random_float() * (max_ar - min_ar) + min_ar, CGL_utils_random_float() * (max_ar - min_ar) + min_ar); g_State.trail_tip_pos_tar[i] = CGL_vec3_init(CGL_utils_random_float() * (max_ar - min_ar) + min_ar, CGL_utils_random_float() * (max_ar - min_ar) + min_ar, CGL_utils_random_float() * (max_ar - min_ar) + min_ar); g_State.trail_tip_pos_thresh[i] = 0.0f; }
    for(int i = 0; i < TRAIL_COUNT; i++) { g_State.trail_tip_pos_tar[i] = CGL_vec3_init(CGL_utils_random_float() * (max_ar - min_ar) + min_ar, CGL_utils_random_float() * (max_ar - min_ar) + min_ar, CGL_utils_random_float() * (max_ar - min_ar) + min_ar); g_State.trail_tip_pos_thresh[i] = 0.0f; }
    
    for(int i = 0; i < TRAIL_COUNT; i++) g_State.trail_color[i] = CGL_vec3_init(CGL_utils_random_float() * 0.8f , CGL_utils_random_float() * 0.5f + 0.5f, CGL_utils_random_float() * 0.8f);

    return true;
}

void cleanup()
{
    for(int i = 0; i < TRAIL_COUNT; i++) CGL_trail_destroy(g_State.trail[i]);
    CGL_shader_destroy(g_State.trail_shader);
    CGL_shader_destroy(g_State.present_shader);
    CGL_framebuffer_destroy(g_State.default_framebuffer);
    CGL_framebuffer_destroy(g_State.bloom_framebuffer);
#ifndef CGL_WASM
    CGL_bloom_destroy(g_State.bloom);
#endif
    CGL_gl_shutdown();
    CGL_window_destroy(g_State.window);
    CGL_shutdown();
}

EM_BOOL loop(double time, void* userData)
{
    (void)time;
    (void)userData;

    CGL_float current_time = CGL_utils_get_time() - g_State.start_time;
    CGL_window_set_size(g_State.window, 600, 600); // force window size to be 600x600

    g_State.view = CGL_mat4_look_at(CGL_vec3_init(cosf(current_time*0.5f) * 8.0f, 8.0f, sinf(current_time*0.5f) *  8.0f), CGL_vec3_init(0.0f, 0.0f, 0.0f), CGL_vec3_init(0.0f, 1.0f, 0.0f));

    for(int i = 0; i < TRAIL_COUNT; i++)
    {
        // walk a random path within -1.0f to 1.0f
        CGL_vec3 v = CGL_vec3_init(0.0f, 0.0f, 0.0f);
        v.x = CGL_float_cubic_lerp(g_State.trail_tip_pos[i].x, g_State.trail_tip_pos_tar[i].x, g_State.trail_tip_pos_trpt[i * 2].x, g_State.trail_tip_pos_trpt[i*2+1].x, g_State.trail_tip_pos_thresh[i]);
        v.y = CGL_float_cubic_lerp(g_State.trail_tip_pos[i].y, g_State.trail_tip_pos_tar[i].y, g_State.trail_tip_pos_trpt[i * 2].y, g_State.trail_tip_pos_trpt[i*2+1].y, g_State.trail_tip_pos_thresh[i]);
        v.z = CGL_float_cubic_lerp(g_State.trail_tip_pos[i].z, g_State.trail_tip_pos_tar[i].z, g_State.trail_tip_pos_trpt[i * 2].z, g_State.trail_tip_pos_trpt[i*2+1].z, g_State.trail_tip_pos_thresh[i]);
        g_State.trail_tip_pos_thresh[i] += 0.005f;
        if(g_State.trail_tip_pos_thresh[i] >= 1.0f) {g_State.trail_tip_pos_thresh[i] = 0.0f;g_State.trail_tip_pos[i] = g_State.trail_tip_pos_tar[i]; g_State.trail_tip_pos_tar[i] = CGL_vec3_init(CGL_utils_random_float() * (3.0f - (-3.0f)) + (-3.0f), CGL_utils_random_float() * (3.0f - (-3.0f)) + (-3.0f), CGL_utils_random_float() * (3.0f - (-3.0f)) + (-3.0f)); }
        CGL_trail_add_point(g_State.trail[i], v, 10.0f, 0.05f);
        CGL_trail_update(g_State.trail[i], 0.1f);
        CGL_trail_bake_mesh(g_State.trail[i]);
    }
    
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LESS);
    CGL_framebuffer_bind(g_State.bloom_framebuffer);
    CGL_gl_clear(0.0f, 0.0f, 0.0f, 1.0f);
    CGL_shader_bind(g_State.trail_shader);
    for(CGL_int i = 0; i < TRAIL_COUNT; i++)
    {
        CGL_shader_set_uniform_vec3v(g_State.trail_shader, CGL_shader_get_uniform_location(g_State.trail_shader, "color"), g_State.trail_color[i].x, g_State.trail_color[i].y, g_State.trail_color[i].z);
        CGL_trail_render(g_State.trail[i], &g_State.view, &g_State.projection, g_State.trail_shader);
    }

#ifndef CGL_WASM
    CGL_bloom_apply(g_State.bloom, CGL_framebuffer_get_color_texture(g_State.bloom_framebuffer));
#endif

    CGL_framebuffer_bind(g_State.default_framebuffer);
    CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);
    CGL_shader_bind(g_State.present_shader);
    CGL_texture_bind(CGL_framebuffer_get_color_texture(g_State.bloom_framebuffer), 0);
    CGL_shader_set_uniform_int(g_State.present_shader, CGL_shader_get_uniform_location(g_State.present_shader, "u_tex"), 0);
    CGL_gl_render_screen_quad();

    CGL_window_poll_events(g_State.window);
    CGL_window_swap_buffers(g_State.window);

    return true;
}

int main()
{
    if(!init()) return 1;
#ifdef CGL_WASM
    emscripten_request_animation_frame_loop(loop, NULL);
#else
    while(!CGL_window_should_close(g_State.window)) {
        if(!loop(0, NULL)) break;
    }
#endif
    return 0;
}

```

`examples/c/using_advanced_logger.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_IMPLEMENTATION
#include "cgl.h"


int main()
{
    srand((uint32_t)time(NULL));
    CGL_init();
    CGL_info("This is a info!");
    CGL_warn("This is a warning!");
    CGL_error("This is a error!");
    CGL_trace("This is a trace!");

    CGL_logger_attach_log_file("./log.txt");
    CGL_logger_attach_log_file("./log2.txt");

    CGL_info("This is a info!");
    CGL_warn("This is a warning!");
    CGL_error("This is a error!");
    CGL_trace("This is a trace!");

    CGL_shutdown();
    return EXIT_SUCCESS;
}

```

`examples/c/using_hashtable.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#include "cgl.h"



int main()
{
    char buffer[1024];
    CGL_hashtable* table = CGL_hashtable_create(100, 0, 10);

    CGL_hashtable_set_int(table, "age", 16);
    CGL_hashtable_set_int(table, "marks", 99);
    CGL_hashtable_set_int(table, "id", 4484);
    CGL_hashtable_set_float(table, "weight", 68.4877f);
    int t = CGL_HASHTABLE_ENTRY_STATIC_VALUE_SIZE;
    CGL_hashtable_set_string(table, "name", "Andrew");

    printf("ID : %d\n", CGL_hashtable_get_int(table, "id"));
    printf("Weight : %f\n", CGL_hashtable_get_float(table, "weight"));
    CGL_hashtable_get(table, "name", buffer);
    printf("Name : %s\n", buffer);
    printf("Marks : %d\n", CGL_hashtable_get_int(table, "marks"));
    printf("Age : %d\n", CGL_hashtable_get_int(table, "age"));


    printf("name %s.\n", (CGL_hashtable_exists(table, "name") ? "exists" : "does not exist"));
    printf("year %s.\n", (CGL_hashtable_exists(table, "year") ? "exists" : "does not exist"));
    CGL_hashtable_remove(table, "name");
    printf("name %s.\n", (CGL_hashtable_exists(table, "name") ? "exists" : "does not exist"));
    printf("age %s.\n", (CGL_hashtable_exists(table, "age") ? "exists" : "does not exist"));
    CGL_hashtable_remove(table, "name");

    CGL_hashtable_iterator* iterator = CGL_hashtable_iterator_create(table);

    printf("Entries :- \n");
    while(CGL_hashtable_iterator_next(iterator, buffer, NULL, NULL))
        printf("Key : %s\n", buffer);

    CGL_hashtable_iterator_destroy(iterator);

    CGL_hashtable_destroy(table);

    printf("End\n");

    return 0;
}

```

`examples/c/using_hashtable_iterator.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define CGL_LOGGING_ENABLED
#define CGL_IMPLEMENTATION
#include "cgl.h"

int main()
{
    char buffer[1024];
    CGL_hashtable* table = CGL_hashtable_create(1, 0);
    int idata = 0;
    float fdata = 0.0f;
    CGL_hashtable_set_string(table, "Name", "Jaysmito");
    CGL_hashtable_set_int(table, "Age", 18);
    CGL_hashtable_set_float(table, "Float Data", 54584.4584f);

    // print 
    printf("Age : %d\n", CGL_hashtable_get_int(table, "Age"));
    printf("Float Data : %f\n", CGL_hashtable_get_float(table, "Float Data"));
    CGL_hashtable_get(table, "Name", buffer);
    printf("Name : %s\n", buffer);
    CGL_hashtable_set_string(table, "Name", "Jack");
    CGL_hashtable_get(table, "Name", buffer);
    printf("Name 2 : %s\n", buffer);
    
    CGL_hashtable_iterator* iterator = CGL_hashtable_iterator_create(table);

    size_t sz = 0;
    while(CGL_hashtable_iterator_next(iterator, buffer, NULL, &sz))
        CGL_LOG("Key : %s\t\tValue Size: %zu\n", buffer, sz);

    CGL_hashtable_iterator_destroy(iterator);   
    CGL_hashtable_destroy(table);

    
    
    return 0;
}

```

`examples/c/vector_field_visualizer.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/


#define CGL_LOGGING_ENABLED
#define CGL_EXCLUDE_TEXT_RENDER
#define CGL_IMPLEMENTATION
#include "cgl.h"

#define VECTOR_FIELD_SIZE 35

static const CGL_byte* PASS_THROUGH_VS = "#version 430 core\n"
"layout(location = 0) in vec4 position;\n"
"layout(location = 1) in vec4 normal;\n"
"layout(location = 1) in vec4 tex_coords;\n"
""
"void main()\n"
"{\n"
"    gl_Position = vec4(position.x, position.y, 0.0, 1.0);\n"
"}\n";

static const CGL_byte* PASS_THROUGH_FS = "#version 430 core\n"
"out vec4 color;\n"
""
"uniform sampler2D vec_field;\n"
"uniform int mode;\n"
""
"void main()\n"
"{\n"
"   vec2 uv = gl_FragCoord.xy / 700.0;\n"
"   if(mode == 1) color = vec4(texture(vec_field, uv).xy, 0.0f, 1.0);\n"
"   else if(mode == 2) color = vec4(texture(vec_field, uv).zzz, 1.0);\n"
"   else if(mode == 3) color = vec4(texture(vec_field, uv).www, 1.0);\n"
"   else color = vec4(texture(vec_field, uv).xyz, 1.0);\n"
"}\n";

static const CGL_byte* COMPUTE_SHADER = "#version 430 core\n"
"\n"
"#define VEC_FIELD_SIZE 35\n"
"\n"
"\n"
"layout (local_size_x = 16, local_size_y = 16) in;\n"
"\n"
"layout (rgba32f, binding = 0) uniform image2D vec_field_tex;\n"
"\n"
"layout(std430, binding=0) readonly buffer VecField\n"
"{\n"
"    vec4 vec_field[];\n"
"};\n"
"\n"
"uniform int mode = 0; \n"
"\n"
"void interpolate_vec_field()\n"
"{\n"
"    vec2 uv = gl_GlobalInvocationID.xy / 700.0f;\n"
"    ivec2 iuv0 = ivec2(uv * VEC_FIELD_SIZE);\n"
"    vec2 color = vec_field[iuv0.x + iuv0.y * VEC_FIELD_SIZE].xy;\n"
"    color = (color + vec2(1.0f)) * 0.5f;\n"
"    imageStore(vec_field_tex, ivec2(gl_GlobalInvocationID.xy), vec4(color, 0.0f, 1.0));\n"
"}\n"
"\n"
"void calculate_divergence()\n"
"{\n"
"    vec2 uv = gl_GlobalInvocationID.xy / 700.0f;\n"
"    ivec2 iuv0 = ivec2(uv * VEC_FIELD_SIZE);\n"
"    vec2 samplex0 = vec_field[iuv0.x - 1 + iuv0.y * VEC_FIELD_SIZE].xy;\n"
"    vec2 samplex1 = vec_field[iuv0.x + 1 + iuv0.y * VEC_FIELD_SIZE].xy;\n"
"    vec2 sampley0 = vec_field[iuv0.x + (iuv0.y - 1) * VEC_FIELD_SIZE].xy;\n"
"    vec2 sampley1 = vec_field[iuv0.x + (iuv0.y + 1) * VEC_FIELD_SIZE].xy;\n"
"    float div = (samplex1.x - samplex0.x + sampley1.y - sampley0.y) * 0.5f;\n"
"    vec4 color = imageLoad(vec_field_tex, ivec2(gl_GlobalInvocationID.xy));\n"
"    imageStore(vec_field_tex, ivec2(gl_GlobalInvocationID.xy), vec4(color.xy, div, 1.0f));\n"
"}\n"
"\n"
"void calculate_curl()\n"
"{\n"
"    // This is just a test, it's not correct\n"
"    // actual implementaion is TODO\n"
"    vec2 uv = gl_GlobalInvocationID.xy / 700.0f;\n"
"    ivec2 iuv0 = ivec2(uv * VEC_FIELD_SIZE);\n"
"    vec2 samplex0 = vec_field[iuv0.x - 1 + iuv0.y * VEC_FIELD_SIZE].xy;\n"
"    vec2 samplex1 = vec_field[iuv0.x + 1 + iuv0.y * VEC_FIELD_SIZE].xy;\n"
"    vec2 sampley0 = vec_field[iuv0.x + (iuv0.y - 1) * VEC_FIELD_SIZE].xy;\n"
"    vec2 sampley1 = vec_field[iuv0.x + (iuv0.y + 1) * VEC_FIELD_SIZE].xy;\n"
"    float curl = (samplex1.y - samplex0.y - sampley1.x + sampley0.x) * 0.5f;\n"
"    vec4 color = imageLoad(vec_field_tex, ivec2(gl_GlobalInvocationID.xy));\n"
"    imageStore(vec_field_tex, ivec2(gl_GlobalInvocationID.xy), vec4(color.xyz, curl));\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"    if(mode == 0) interpolate_vec_field();\n"
"    else if(mode == 1) calculate_divergence();\n"
"    else if(mode == 2) calculate_curl();\n"
"}";

static CGL_window* window = NULL;
static CGL_vec4 vec_field[VECTOR_FIELD_SIZE * VECTOR_FIELD_SIZE];
static CGL_bool comb_mode = false;
static CGL_float brush_size = 0.3f;
static CGL_float brush_strength = 0.5f;
static CGL_shader *compute = NULL, *display_shader = NULL;
static CGL_texture* vec_field_tex = NULL;
static CGL_ssbo* vec_field_ssbo = NULL;


void add_line_custom(CGL_float start_x, CGL_float start_y, CGL_float end_x, CGL_float end_y, CGL_float thickness)
{
    CGL_vec3 start = CGL_vec3_init(start_x, start_y, 0.0f);
    CGL_vec3 end = CGL_vec3_init(end_x, end_y, 0.0f);

    CGL_vec3 a, b, c, d;

    CGL_float original_slope = (end.y - start.y) / (end.x - start.x);
    CGL_float perp_slope = -1.0f / original_slope;
    CGL_float angle = atanf(perp_slope);
    CGL_float r = thickness / 2.0f;

    a = CGL_vec3_init(start.x + r * cosf(angle), start.y + r * sinf(angle), start.z);
    b = CGL_vec3_init(start.x - r * cosf(angle), start.y - r * sinf(angle), start.z);

    r = r * 0.1f;

    c = CGL_vec3_init(end.x - r * cosf(angle), end.y - r * sinf(angle), end.z);
    d = CGL_vec3_init(end.x + r * cosf(angle), end.y + r * sinf(angle), end.z);

    CGL_widgets_add_quad(a, b, c, d);
}

void randomize_vec_field()
{
    for(int i = 0; i < VECTOR_FIELD_SIZE; i++)
    {
        for(int j = 0; j < VECTOR_FIELD_SIZE; j++)
        {
            vec_field[i * VECTOR_FIELD_SIZE + j] = CGL_vec4_init(CGL_utils_random_float(), CGL_utils_random_float(), -1.0f + 2.0f * (CGL_float)j / VECTOR_FIELD_SIZE, -1.0f + 2.0f * (CGL_float)i / VECTOR_FIELD_SIZE);
            CGL_vec2_normalize(vec_field[i * VECTOR_FIELD_SIZE + j]);
        }
    }
}

void apply_comb_brush()
{
    CGL_double mx, my;
    CGL_window_get_mouse_position(window, &mx, &my);
    my = 700.0 - my;
    CGL_float x = -1.0f + 2.0f * (CGL_float)mx / 700.0f;
    CGL_float y = -1.0f + 2.0f * (CGL_float)my / 700.0f;

    static CGL_float last_x = 0.0f;
    static CGL_float last_y = 0.0f;

    CGL_float dx = x - last_x;
    CGL_float dy = y - last_y;

    dx = CGL_utils_clamp(dx, -0.1f, 0.1f);
    dy = CGL_utils_clamp(dy, -0.1f, 0.1f);
    CGL_vec2 dir = CGL_vec2_init(dx, dy);
    CGL_float delt_len = CGL_vec2_length(dir);
    CGL_vec2_normalize(dir);

    if(CGL_window_get_mouse_button(window, CGL_MOUSE_BUTTON_LEFT) == CGL_PRESS && delt_len > 0.0001f)
    {

        for(CGL_int i = 0; i < VECTOR_FIELD_SIZE; i++)
        {
            for(CGL_int j = 0; j < VECTOR_FIELD_SIZE; j++)
            {
                CGL_float dist = sqrtf((vec_field[i * VECTOR_FIELD_SIZE + j].z - x) * (vec_field[i * VECTOR_FIELD_SIZE + j].z - x) + (vec_field[i * VECTOR_FIELD_SIZE + j].w - y) * (vec_field[i * VECTOR_FIELD_SIZE + j].w - y));
                if(dist < brush_size)
                {
                    CGL_float strength = brush_strength * (1.0f - dist / brush_size);
                    CGL_vec2 a = CGL_vec2_init(vec_field[i * VECTOR_FIELD_SIZE + j].x, vec_field[i * VECTOR_FIELD_SIZE + j].y);
                    CGL_vec2 dir_s = CGL_vec2_scale(dir, brush_strength * powf(1.0f - dist / brush_size, 4.0f));
                    CGL_vec2 b = CGL_vec2_lerp(a, dir_s, 0.5f);
                    CGL_vec2_normalize(b);
                    vec_field[i * VECTOR_FIELD_SIZE + j].x = b.x;
                    vec_field[i * VECTOR_FIELD_SIZE + j].y = b.y;
                 //   CGL_info("vec[%d][%d] = (%f, %f)", i, j, vec_field[i * VECTOR_FIELD_SIZE + j].x, vec_field[i * VECTOR_FIELD_SIZE + j].y);
                }
            }
        }
    
    }

    last_x = x;
    last_y = y;
}

void randomize_charge_based_vec_field()
{
    static CGL_vec3 points[64];
    CGL_int num_points = CGL_utils_random_int(2, 64);
    for(CGL_int i = 0; i < num_points; i++) points[i] = CGL_vec3_init(CGL_utils_random_float() * 2.0f - 1.0f, CGL_utils_random_float() * 2.0f - 1.0f, CGL_utils_random_float() * 20.0f - 10.0f);

    for(CGL_int i = 0 ; i < VECTOR_FIELD_SIZE; i++)
    {
        for(CGL_int j = 0 ; j < VECTOR_FIELD_SIZE; j++)
        {
            CGL_vec2 force = CGL_vec2_init(0.0f, 0.0f);
            CGL_float x = -1.0f + 2.0f * (CGL_float)j / VECTOR_FIELD_SIZE;
            CGL_float y = -1.0f + 2.0f * (CGL_float)i / VECTOR_FIELD_SIZE;
            
            for(CGL_int k = 0; k < num_points; k++)
            {
                CGL_vec2 dir = CGL_vec2_init(points[k].x - x, points[k].y - y);
                CGL_float dist = CGL_vec2_length(dir);
                CGL_vec2_normalize(dir);
                CGL_vec2 force_dir = CGL_vec2_scale(dir, points[k].z / (dist * dist));
                force = CGL_vec2_add(force, force_dir);
            }
            CGL_vec2_normalize(force);

            vec_field[i * VECTOR_FIELD_SIZE + j].x = force.x;
            vec_field[i * VECTOR_FIELD_SIZE + j].y = force.y;
        }
    }

}

int main(int argc, char** argv, char** envp)
{
    srand((uint32_t)time(NULL));
    CGL_init();
    window = CGL_window_create(700, 700, "CGL Vector Field Visualizer - Jaysmito Mukherjee");
    if(window == NULL) return false; 
    CGL_window_make_context_current(window); 
    CGL_gl_init();
    CGL_widgets_init();
    CGL_framebuffer* default_framebuffer = CGL_framebuffer_create_from_default(window);

    compute = CGL_shader_compute_create(COMPUTE_SHADER, NULL);
    display_shader = CGL_shader_create(PASS_THROUGH_VS, PASS_THROUGH_FS, NULL);
    vec_field_tex = CGL_texture_create_blank(700, 700, GL_RGBA, GL_RGBA32F, GL_FLOAT);
    vec_field_ssbo = CGL_ssbo_create(0);


    randomize_vec_field();

    CGL_float last_time = CGL_utils_get_time();
    CGL_float curr_time = CGL_utils_get_time();
    CGL_float delta_time = 0.0f;

    CGL_int mode = 1;

    while(!CGL_window_should_close(window)) 
    {
        CGL_window_set_size(window, 700, 700); // force window size to be 700x700

        curr_time = CGL_utils_get_time();
        delta_time = curr_time - last_time;
        last_time = curr_time;

        CGL_ssbo_set_data(vec_field_ssbo, sizeof(vec_field), vec_field, false);

        CGL_shader_bind(compute);
        glBindImageTexture(0, vec_field_tex->handle, 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
        
        CGL_shader_set_uniform_int(compute, CGL_shader_get_uniform_location(compute, "mode"), 0);
        CGL_shader_compute_dispatch(compute, 700 / 16 + 1, 700 / 16 + 1, 1);
        glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);

        CGL_shader_set_uniform_int(compute, CGL_shader_get_uniform_location(compute, "mode"), 1);
        CGL_shader_compute_dispatch(compute, 700 / 16 + 1, 700 / 16 + 1, 1);
        glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);

        CGL_shader_set_uniform_int(compute, CGL_shader_get_uniform_location(compute, "mode"), 2);
        CGL_shader_compute_dispatch(compute, 700 / 16 + 1, 700 / 16 + 1, 1);
        glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);

        CGL_framebuffer_bind(default_framebuffer);
        CGL_gl_clear(0.2f, 0.2f, 0.2f, 1.0f);

        CGL_shader_bind(display_shader);
        CGL_texture_bind(vec_field_tex, 4);
        CGL_shader_set_uniform_int(display_shader, CGL_shader_get_uniform_location(display_shader, "vec_field"), 4);
        CGL_shader_set_uniform_int(display_shader, CGL_shader_get_uniform_location(display_shader, "mode"), mode);
        CGL_gl_render_screen_quad();

        CGL_widgets_begin();

        CGL_widgets_set_fill_colorf(0.0f, 0.0f, 1.0f, 1.0f);
        for(int i = 0; i < VECTOR_FIELD_SIZE * VECTOR_FIELD_SIZE; i++) add_line_custom(vec_field[i].z, vec_field[i].w, vec_field[i].z + 0.05f * vec_field[i].x, vec_field[i].w + 0.05f * vec_field[i].y, 0.02f);

        CGL_widgets_set_fill_colorf(1.0f, 1.0f, 1.0f, 1.0f);
        static CGL_byte buffer[1000];
        sprintf(buffer, "Frame Time: %f", delta_time);
        CGL_widgets_add_string(buffer, -1.0f, 0.95f, 0.5f, 0.05f);
        sprintf(buffer, "Brush Mode: %s", comb_mode ? "On" : "Off");
        CGL_widgets_add_string(buffer, -1.0f, 0.90f, 0.5f, 0.05f);
        sprintf(buffer, "Brush Size: %f", brush_size);
        CGL_widgets_add_string(buffer, -1.0f, 0.85f, 0.7f, 0.05f);
        sprintf(buffer, "Brush Strength: %f", brush_strength);
        CGL_widgets_add_string(buffer, -1.0f, 0.80f, 0.7f, 0.05f);
        sprintf(buffer, "Mode: %s", mode == 1 ? "Field" : (mode == 2 ? "Divergence" : (mode == 3 ? "Curl" : "All"))); // this is dirty but it works for now so ...
        CGL_widgets_add_string(buffer, -1.0f, 0.75f, 0.7f, 0.05f);

        CGL_widgets_end();

        if(CGL_window_get_key(window, CGL_KEY_ESCAPE) == CGL_PRESS) break;
        if(CGL_window_get_key(window, CGL_KEY_R) == CGL_PRESS) randomize_vec_field();
        if(CGL_window_get_key(window, CGL_KEY_C) == CGL_PRESS) comb_mode = true;
        if(CGL_window_get_key(window, CGL_KEY_V) == CGL_PRESS) comb_mode = false;
        if(CGL_window_get_key(window, CGL_KEY_LEFT_SHIFT) == CGL_PRESS)
        {
            if(CGL_window_get_key(window, CGL_KEY_UP) == CGL_PRESS) brush_size += delta_time;
            if(CGL_window_get_key(window, CGL_KEY_DOWN) == CGL_PRESS) brush_size -= delta_time;
            if(CGL_window_get_key(window, CGL_KEY_LEFT) == CGL_PRESS) brush_strength -= delta_time;
            if(CGL_window_get_key(window, CGL_KEY_RIGHT) == CGL_PRESS) brush_strength += delta_time;
            brush_size = CGL_utils_clamp(brush_size, 0.01f, 10.0f);
        }
        if(CGL_window_get_key(window, CGL_KEY_G) == CGL_PRESS) randomize_charge_based_vec_field();
        if(CGL_window_get_key(window, CGL_KEY_1) == CGL_PRESS) mode = 1;
        if(CGL_window_get_key(window, CGL_KEY_2) == CGL_PRESS) mode = 2;
        if(CGL_window_get_key(window, CGL_KEY_3) == CGL_PRESS) mode = 3;

        if(comb_mode) apply_comb_brush();

        CGL_window_swap_buffers(window);
        CGL_window_poll_events(window);
    }

    CGL_ssbo_destroy(vec_field_ssbo);
    CGL_texture_destroy(vec_field_tex);
    CGL_shader_destroy(compute);
    CGL_shader_destroy(display_shader);
    CGL_framebuffer_destroy(default_framebuffer);
    CGL_widgets_shutdown();
    CGL_gl_shutdown();
    CGL_window_destroy(window);
    CGL_shutdown();
    return EXIT_SUCCESS;
}

```

`examples/python/3d_ai_hands.py`:

```py
"""
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""
import cgl
import math
import cv2
import mediapipe as mp
import OpenGL.GL as gl
import musicalbeeps



VERTEX_SHADER_SOURCE = """
#version 430 core

layout (location = 0) in vec4 position;
layout (location = 1) in vec4 normal;
layout (location = 2) in vec4 texcoord;

out vec4 Position;
out vec4 Normal;

uniform mat4 model;
uniform mat4 view_proj;

void main()
{
    mat4 mvp = view_proj * model;
    Normal = normal;
    Position = model * position;
    gl_Position = mvp * position;
}
"""

FRAGMENT_SHADER_SOURCE = """
#version 430 core

in vec4 Position;
in vec4 Normal;

out vec4 FragColor;

void main()
{
    const vec3 lightPos = vec3(5.0, 5.0, 5.0);
    const vec3 lightColor = vec3(0.85, 1.0, 0.6);
    vec3 normal = normalize(Normal.xyz);
    vec3 lightDir = normalize(lightPos - Position.xyz);
    float diff = max(dot(normal, lightDir), 0.0) + 0.2;
    vec3 diffuse = diff * lightColor;
    FragColor = vec4(diffuse, 1.0);
}

"""


class HandDataProcessor:
    def __init__(self):
        self.detector = mp.solutions.hands.Hands()
        self.results = None
        self.landmark_points = []
        self.left_hand_landmarks = []
        self.right_hand_landmarks = []
        self.left_hand_world_landmarks = []
        self.right_hand_world_landmarks = []
        self.both_hands = False
        self.left_hand = False
        self.right_hand = False
    
    def process(self, frame):
        self.results = self.detector.process(frame)
        right_hand_index = left_hand_index = -1

        self.left_hand = self.right_hand = self.both_hands = False
        self.landmark_points = []
        self.left_hand_landmarks = []
        self.right_hand_landmarks = []
        self.left_hand_world_landmarks = []
        self.right_hand_world_landmarks = []

        if self.results.multi_hand_landmarks is None:
            return False

        for clasf in self.results.multi_handedness:
            if clasf.classification[0].label == "Right":
                right_hand_index = clasf.classification[0].index
            elif clasf.classification[0].label == "Left":
                left_hand_index = clasf.classification[0].index

        self.left_hand = left_hand_index != -1
        self.right_hand = right_hand_index != -1
        self.both_hands = self.left_hand and self.right_hand

        if self.left_hand:
            for lm in self.results.multi_hand_landmarks[left_hand_index].landmark:
                self.left_hand_landmarks.append((lm.x, lm.y, lm.z))
                self.landmark_points.append((lm.x, lm.y, lm.z))
            
            for lm in self.results.multi_hand_world_landmarks[left_hand_index].landmark:
                self.left_hand_world_landmarks.append((lm.x, lm.y, lm.z))
        
        if self.right_hand:
            if right_hand_index >= len(self.results.multi_hand_landmarks):
                right_hand_index = 0

            for lm in self.results.multi_hand_landmarks[right_hand_index].landmark:
                self.right_hand_landmarks.append((lm.x, lm.y, lm.z))
                self.landmark_points.append((lm.x, lm.y, lm.z))
            
            for lm in self.results.multi_hand_world_landmarks[right_hand_index].landmark:
                self.right_hand_world_landmarks.append((lm.x, lm.y, lm.z))


        return True

def draw_hand_landmarks(handler, size, px, py, psx, psy):
    # red for left hand
    cgl.widgets.set_fill_colorf(1.0, 0.0, 0.0, 1.0)
    cgl.widgets.add_rect2f(px, py, size, size)
    
    if handler.left_hand:
        for lm in handler.left_hand_landmarks:
            x, y = lm[0], 1.0 - lm[1]
            cgl.widgets.add_rect2f(px + x * psx, py + y * psy, size, size)
    
    # blue for right hand
    cgl.widgets.set_fill_colorf(0.0, 0.0, 1.0, 1.0)
    if handler.right_hand:
        for lm in handler.right_hand_landmarks:
            x, y = lm[0], 1.0 - lm[1]
            cgl.widgets.add_rect2f(px + x * psx, py + y * psy, size, size)

def draw_box(msh, shd, x, y, z, size):
    model = cgl.mat4_translate(x, y, z)
    model = cgl.mat4_mul(model, cgl.mat4_scale(size, size, size))
    shd.set_uniform_mat4("model", model)
    msh.render()

cam = cv2.VideoCapture(0)
cgl.init()
w = cgl.window(750, 750, "ASCII Video  - Jaysmito Mukherjee")
w.make_context_current()

cgl.gl_init()
cgl.widgets.init()
cgl.text_init()

fb = cgl.framebuffer_create_from_default(w)
tex = cgl.texture_create_blank(cam.get(3), cam.get(4), gl.GL_BGR, gl.GL_RGB8, gl.GL_UNSIGNED_BYTE)
dummy_tex = cgl.texture_create_blank(5, 5, gl.GL_RGB, gl.GL_RGB8, gl.GL_UNSIGNED_BYTE)
dummy_tex.set_data(bytes([255 for i in range(0, 10 * 10 * 3)]))
hand_data_processor = HandDataProcessor()
proj = cgl.mat4_perspective(cgl.deg_to_rad(45), 1.0, 0.1, 100.0)
shd = cgl.shader()
shd.load(VERTEX_SHADER_SOURCE, FRAGMENT_SHADER_SOURCE)
cube_cpu = cgl.mesh_cpu_cube(False)
cube_cpu.recalculate_normals()
cube_gpu = cgl.mesh_gpu()
cube_gpu.upload_mesh_cpu(cube_cpu)
cube_cpu.destroy()
music_player = musicalbeeps.Player(volume = 1.0, mute_output = False)


frame_count = 0 

while not w.should_close():
    frame_count += 1

    w.set_size(600, 600)
    fb.bind()
    cgl.gl_clear(0.02, 0.02, 0.02, 1.0)

    ret, frame = cam.read()
    frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    frame = cv2.flip(frame, 1)
    flippedFrame = cv2.flip(frame, 0)
    tex.set_data(bytes(flippedFrame))

    # process hands data every few frames
    if frame_count % 5 == 0:
        hand_data_processor.process(frame)


    view = cgl.mat4_look_at(cgl.vec3(0, 10, -5.01), cgl.vec3(0, 0, 0), cgl.vec3(0, 1, 0))
    view_proj = cgl.mat4_mul(proj, view)
    model = cgl.mat4_identity()
    gl.glEnable(gl.GL_DEPTH_TEST) 
    gl.glDepthFunc(gl.GL_LESS)
    shd.bind()
    shd.set_uniform_mat4("view_proj", view_proj)

    if hand_data_processor.right_hand:
        lm = hand_data_processor.right_hand_landmarks[0]
        x, z = lm[0] * 2.0 - 1.0, lm[1] * 2.0 - 1.0
        draw_box(cube_gpu, shd, x * 3, 0, z * 3, 0.1)
        
        for lm in hand_data_processor.right_hand_landmarks:
            x, z = lm[0], lm[1]
            x, z = x * 2 - 1, z * 2 - 1
            draw_box(cube_gpu, shd, x * 3, 0, z * 3, 0.1)

    # music_player.play_note("A", 0.1)

    gl.glDisable(gl.GL_DEPTH_TEST) 
    cgl.widgets.begin()
    
    cgl.widgets.set_texture(tex)
    cgl.widgets.add_rect2f(0.6, 0.6, 0.4, 0.4)
    
#    cgl.widgets.flush()
    
    cgl.widgets.set_texture(dummy_tex)
    draw_hand_landmarks(hand_data_processor, 0.01, 0.6, 0.6, 0.4, 0.4)

    cgl.widgets.end()

    w.swap_buffers()
    w.poll_events()

cam.release() 
cube_gpu.destroy()
shd.destroy()
dummy_tex.destroy()  
tex.destroy()
fb.destroy()
cgl.text_shutdown()
cgl.widgets.shutdown()
cgl.gl_shutdown()
w.destroy()
cgl.shutdown()
```

`examples/python/ascii_video.py`:

```py
"""
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""
import cgl
import cv2
import OpenGL.GL as gl
cam = cv2.VideoCapture(0)
# ascii_density = "N@#W$9876543210?!abc;:+=-,._ "
ascii_density = "N@#W$9876543210?!abc;:+=-,._      "
ascii_resolution = 64
cgl.init()
w = cgl.window(750, 750, "ASCII Video  - Jaysmito Mukherjee")
w.make_context_current()
cgl.gl_init()
cgl.widgets.init()
cgl.text_init()
fb = cgl.framebuffer_create_from_default(w)
tex = cgl.texture_create_blank(ascii_resolution, ascii_resolution, gl.GL_BGR, gl.GL_RGB, gl.GL_UNSIGNED_BYTE)
# source: https://www.fontsquirrel.com/fonts/download/camingocode
fnt = cgl.font()
fnt.load("font.ttf")
fnt.build_atlas(1024, 1024, 48)
while not w.should_close():
    w.set_size(750, 750)
    fb.bind()
    cgl.gl_clear(0.02, 0.02, 0.02, 1.0)
    cgl.widgets.begin()
    ret, frame = cam.read()
    frame = cv2.resize(frame, (ascii_resolution, ascii_resolution))
    tex.set_data(bytes(frame))

    cgl.widgets.set_texture(tex)
    # cgl.widgets.add_rect2f(-0.5, -0.5, 1.0, 1.0)
    for py_i in range(ascii_resolution):
        for px_i in range(ascii_resolution):
            rgb = cgl.vec3(frame[py_i, px_i, 0], frame[py_i, px_i, 1], frame[py_i, px_i, 2])
            rgb = rgb / cgl.vec3(256, 256, 256)
            pixel_lum = 0.2126 * rgb.x + 0.7152 * rgb.y + 0.0722 * rgb.z
            # pixel_lum = rgb.dot(cgl.vec3(0, 1, 0))
            pixel_lum = int(pixel_lum*len(ascii_density))
            pos_x = px_i / ascii_resolution * 2 - 1
            pos_y = (1.0 - py_i / ascii_resolution) * 2 - 1
            size_x = 1.0 / ascii_resolution
            # i did this to filter out the background in my case
            if rgb.z < 0.3:
                pixel_lum = 0
            cgl.widgets.set_fill_colorf(rgb.x, rgb.y, rgb.z, 1.0)
            cgl.widgets.add_string_with_font(ascii_density[len(ascii_density) - 1 - pixel_lum], fnt, pos_x, pos_y, size_x, 1.0)
            
    cgl.widgets.end()
    w.swap_buffers()
    w.poll_events()
cam.release()   
fnt.destroy()
tex.destroy()
fb.destroy()
cgl.text_shutdown()
cgl.widgets.shutdown()
cgl.gl_shutdown()
w.destroy()
cgl.shutdown()

```

`examples/python/chrome_dino.py`:

```py
"""
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""
import cgl
import random
cgl.init()
w = cgl.window(512, 512, "Dino--  - Jaysmito Mukherjee")
w.make_context_current()
cgl.gl_init()
cgl.widgets.init()
fb = cgl.framebuffer_create_from_default(w)
FRONT_COLOR, BACK_COLOR = cgl.vec4(0, 0, 0, 1), cgl.vec4(0.9, 0.9, 0.9, 1)
player_height, player_pos, player_vel, enemies, co, game_over = 0.2, 0, 0, [], 0, False
while not w.should_close():
    w.set_size(512, 512)
    fb.bind()
    cgl.gl_clear(0.2, 0.2, 0.2, 1.0)
    cgl.widgets.begin()
    cgl.widgets.set_fill_color(BACK_COLOR)
    cgl.widgets.add_rect2f(-1, -1, 2, 2)
    cgl.widgets.set_fill_color(FRONT_COLOR)
    cgl.widgets.add_rect2f(-1, -0.5, 2, 0.02)
    cgl.widgets.add_rect2f(-0.9, -0.5 + player_pos, 0.05, player_height)
    for enemy in enemies:
        enemy.x = enemy.x - (0.001 if not game_over else 0)
        cgl.widgets.add_rect2f(enemy.x, enemy.y, enemy.z, enemy.w)
        if cgl.aabb_intersects_aabb(cgl.vec2(-0.9, -0.5 + player_pos), cgl.vec2(-0.85, -0.5 + player_pos + player_height), cgl.vec2(enemy.x, enemy.y), cgl.vec2(enemy.x + enemy.z, enemy.y + enemy.w)):
            game_over = True
    cgl.widgets.add_string(str(co // 100), -0.2, 0.5, 0.4, 0.3)
    cgl.widgets.end()
    if player_pos > 0:
        player_pos = player_pos + player_vel * 0.001
        player_pos = 0 if player_pos <= 0 else player_pos
        player_vel -= 0.98 * 0.02
    if w.is_key_pressed(cgl.KEY_SPACE) and player_pos <= 0 and not game_over:
        player_pos = 0.01
        player_vel = 4.2
    if w.is_key_pressed(cgl.KEY_ENTER) and game_over:
        game_over = False
        enemies = []
        co = 0
    player_height = 0.1 if w.is_key_pressed(cgl.KEY_DOWN) and not player_pos > 0 else 0.2
    if not game_over:
        co += 1
    if co % 1700 == 0:
        en_id = random.randint(0, 4)
        if en_id == 0:
            enemies.append(cgl.vec4(1, -0.5, 0.05, 0.15))
            enemies.append(cgl.vec4(1.06, -0.5, 0.05, 0.15))
            enemies.append(cgl.vec4(1.12, -0.5, 0.05, 0.15))
        elif en_id == 1:
            enemies.append(cgl.vec4(1, -0.5, 0.05, 0.15))
            enemies.append(cgl.vec4(1.06, -0.5, 0.05, 0.15))
        elif en_id == 2:
            enemies.append(cgl.vec4(1, -0.5, 0.05, 0.18))
        elif en_id == 3:
            enemies.append(cgl.vec4(1, -0.35, 0.05, 0.05))    
    w.swap_buffers()
    w.poll_events()
fb.destroy()
cgl.widgets.shutdown()
cgl.gl_shutdown()
w.destroy()
cgl.shutdown()

```

`examples/python/cube_waves.py`:

```py
"""
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""
import cgl
import math
import OpenGL.GL as gl

VERTEX_SHADER_SOURCE = """
#version 430 core

layout (location = 0) in vec4 position;
layout (location = 1) in vec4 normal;
layout (location = 2) in vec4 texcoord;

out vec4 Position;
out vec4 Normal;

uniform mat4 model;
uniform mat4 view_proj;

void main()
{
    mat4 mvp = view_proj * model;
    Normal = normal;
    Position = model * position;
    gl_Position = mvp * position;
}
"""

FRAGMENT_SHADER_SOURCE = """
#version 430 core

in vec4 Position;
in vec4 Normal;

out vec4 FragColor;

void main()
{
    const vec3 lightPos = vec3(30.0, 20.0, -10.0);
    const vec3 lightColor = vec3(0.85, 1.0, 0.6);
    vec3 normal = normalize(Normal.xyz);
    vec3 lightDir = normalize(lightPos - Position.xyz);
    float diff = max(dot(normal, lightDir), 0.0) + 0.2;
    vec3 diffuse = diff * lightColor;
    FragColor = vec4(diffuse, 1.0);
}

"""

cgl.init()
w = cgl.window(750, 750, "Cube Waves  - Jaysmito Mukherjee")
w.make_context_current()
cgl.gl_init()
cgl.widgets.init()
fb = cgl.framebuffer_create_from_default(w)

proj = cgl.mat4_perspective(cgl.deg_to_rad(45), 1.0, 0.1, 100.0)

shd = cgl.shader()
shd.load(VERTEX_SHADER_SOURCE, FRAGMENT_SHADER_SOURCE)

cube_cpu = cgl.mesh_cpu_cube(False)
cube_cpu.recalculate_normals()
cube_gpu = cgl.mesh_gpu()
cube_gpu.upload_mesh_cpu(cube_cpu)
cube_cpu.destroy()

RESOLUTION = 17

while not w.should_close():
    w.set_size(750, 750)
    fb.bind()
    
    # cgl.gl_clear(0.02, 0.02, 0.02, 1.0)
    cgl.gl_clear(1.02, 1.02, 1.02, 1.0)

    view = cgl.mat4_look_at(cgl.vec3(25 * math.cos(cgl.utils_get_time() * 0.1), 25, 25 * math.sin(cgl.utils_get_time() * 0.1)), cgl.vec3(0, 0, 0), cgl.vec3(0, 1, 0))
    view_proj = cgl.mat4_mul(proj, view)
    model = cgl.mat4_identity()

    gl.glEnable(gl.GL_DEPTH_TEST) 
    gl.glDepthFunc(gl.GL_LESS)
    shd.bind()
    shd.set_uniform_mat4("view_proj", view_proj)
    for px in range(RESOLUTION):
        for pz in range(RESOLUTION):
            pos_x = px - RESOLUTION / 2 * 1.0
            pos_z = pz - RESOLUTION / 2 * 1.0
            rad = math.sqrt(pos_x * pos_x + pos_z * pos_z) 
            model = cgl.mat4_translate(pos_x, 0, pos_z)
            scale_y = math.sin(cgl.utils_get_time() * 1.5 + rad * 0.3) ** 2 * 4 + 1
            model = cgl.mat4_mul(model, cgl.mat4_scale(0.5, scale_y, 0.5))
            shd.set_uniform_mat4("model", model)
            cube_gpu.render()

    w.swap_buffers()
    w.poll_events()

cube_gpu.destroy()
shd.destroy()
fb.destroy()
cgl.widgets.shutdown()
cgl.gl_shutdown()
w.destroy()
cgl.shutdown()

```

`examples/python/curve_editor.py`:

```py
"""
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""
import cgl
import math

cgl.init()
w = cgl.window(512, 512, "Curve Editor")
w.make_context_current()
cgl.gl_init()
cgl.widgets.init()
fb = cgl.framebuffer_create_from_default(w)

selected_point = 0
line_resolution = 10
frame_number = 0
points = [
    cgl.vec2(-0.8, 0.0),
    cgl.vec2(0.8, 0.0),
    cgl.vec2(0.0, 0.5),
    cgl.vec2(0.0, -0.5)
]

while not w.should_close():
    frame_number += 1
    w.set_size(512, 512)
    fb.bind()
    cgl.gl_clear(0.2, 0.2, 0.2, 1.0)


    cgl.widgets.begin()

    for i in range(0, 4):
        point = points[i]
        cgl.widgets.set_fill_colorf(0.9, 0.8, 0.2)
        if i == selected_point:
            cgl.widgets.add_circle2f(point.x, point.y, 0.06)
        if i < 2:
            cgl.widgets.set_fill_colorf(0.2, 0.8, 0.2)
        else:
            cgl.widgets.set_fill_colorf(0.8, 0.2, 0.2)
        cgl.widgets.add_circle2f(point.x, point.y, 0.05)
    
    cgl.widgets.set_stroke_colorf(0.8, 0.7, 0.3)
    cgl.widgets.set_stroke_thickness(0.01)
    cgl.widgets.add_cubic_bazier2v(points[0], points[1], points[2], points[3], line_resolution)
    cgl.widgets.add_cubic_bazier_points2v(points[0], points[1], points[2], points[3], line_resolution)

    cgl.widgets.set_fill_colorf(0.8, 0.8, 0.8)
    cgl.widgets.add_string(f"Line Resolution: {line_resolution}", -1.0, 0.9, 1.0, 0.1)
    
    if w.is_key_pressed(cgl.KEY_UP):
        line_resolution += 1
        cgl.utils_sleep(0.5)
    
    if w.is_key_pressed(cgl.KEY_DOWN):
        line_resolution -= 1
        cgl.utils_sleep(0.5)    

    mpx, mpy = w.get_cursor_pos()
    mpx = mpx / 512.0 * 2.0 - 1.0
    mpy = 2.0 - mpy / 512.0 * 2.0 - 1.0
    selected_point = -1
    for i in range(0, 4):
        point = points[i]
        if math.sqrt((point.x - mpx) ** 2 + (point.y - mpy) ** 2) < 0.1:
            selected_point = i
            break
    
    if selected_point != -1:
        if w.get_mouse_button(cgl.MOUSE_BUTTON_LEFT) == cgl.PRESS:
            points[selected_point] = cgl.vec2(mpx, mpy)
    
    cgl.widgets.end()

    w.swap_buffers()
    w.poll_events()

fb.destroy()
cgl.widgets.shutdown()
cgl.gl_shutdown()
w.destroy()
cgl.shutdown()

```

`examples/python/snake_game.py`:

```py
"""
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""
import cgl
import random

def upload_tilemap(tilemap, grid):
    for i in range(0, 32):
        for j in range(0, 32):
            (r, g, b) = (0, 0, 0)
            if grid[i][j] == 0:
                (r, g, b) = (0.2, 0.2, 0.2)
            elif grid[i][j] == 1:
                (r, g, b) = (0.1, 0.1, 0.8)
            elif grid[i][j] == 2:
                (r, g, b) = (0.8, 0.1, 0.1)
            tilemap.set_tile_color(i, j, r, g, b)
    tilemap.upload()

class Snake:
    def __init__(self, position, direction):
        self.direction = direction
        self.pieces = [position]
    
    def move(self, fruit_pos = (-1, -1)):
        head = self.pieces[0]
        new_head = (head[0] + self.direction[0], head[1] + self.direction[1])
        if new_head in self.pieces:
            return 2
        last_piece = self.pieces[-1]
        for i in range(len(self.pieces) - 1, 0, -1):
            self.pieces[i] = self.pieces[i - 1]
        self.pieces[0] = new_head
        if new_head == fruit_pos:
            self.pieces.append(last_piece)
            return 1
        return 0
    
    def update_grid(self, grid):
        board_dim = len(grid)
        for piece in self.pieces:
            if piece[0] < 0 or piece[0] >= board_dim or piece[1] < 0 or piece[1] >= board_dim:
                return False
            grid[piece[0]][piece[1]] = 1
        return True
        
    def set_direction(self, direction):
        self.direction = direction

cgl.init()
w = cgl.window(512, 512, "Dino--  - Jaysmito Mukherjee")
w.make_context_current()
cgl.gl_init()
cgl.widgets.init()
fb = cgl.framebuffer_create_from_default(w)

tilemap = cgl.tilemap(32, 32, 16, 16, 0)
tilemap.set_auto_upload(False)
snake = Snake((16, 16), (1, 0))

prev_time, curr_time = cgl.utils_get_time(), 0

snake_move_time, snake_move_time_default = 0.1, 0.1

fruit_pos = (random.randint(0, 31), random.randint(0, 31))
game_runnning = True
while not w.should_close():
    curr_time = cgl.utils_get_time()
    delta_time = curr_time - prev_time
    prev_time = curr_time
    snake_move_time -= delta_time
    w.set_size(512, 512)
    fb.bind()
    cgl.gl_clear(0.2, 0.2, 0.2, 1.0)
    grid = [[0 for i in range(32)] for j in range(32)]


    if snake_move_time <= 0 and game_runnning:
        result = snake.move(fruit_pos)
        if result == 1:
            fruit_pos = (random.randint(0, 31), random.randint(0, 31))
            snake_move_time_default -= 0.005
            if snake_move_time_default <= 0.05:
                snake_move_time_default = 0.05
        elif result == 2:
            game_runnning = False
        snake_move_time = snake_move_time_default
    
    game_runnning = game_runnning and snake.update_grid(grid)
    grid[fruit_pos[0]][fruit_pos[1]] = 2
    
    if w.is_key_pressed(cgl.KEY_UP):
        snake.set_direction((0, 1))
    elif w.is_key_pressed(cgl.KEY_DOWN):
        snake.set_direction((0, -1))
    elif w.is_key_pressed(cgl.KEY_LEFT):
        snake.set_direction((-1, 0))
    elif w.is_key_pressed(cgl.KEY_RIGHT):
        snake.set_direction((1, 0))    

    upload_tilemap(tilemap, grid)

    tilemap.render(1.0, 1.0, 0, 0)


    cgl.widgets.begin()

    if not game_runnning:
        cgl.widgets.add_string("Game Over", -0.7, -0.2, 1.4, 0.4)
    # cgl.widgets.add_rect2f(0, 0, 1, 1)

    cgl.widgets.end()
    w.swap_buffers()
    w.poll_events()


fb.destroy()
cgl.widgets.shutdown()
cgl.gl_shutdown()
w.destroy()
cgl.shutdown()

```

`examples/python/tesseract.py`:

```py
"""
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""
import cgl
import math
import OpenGL.GL as gl

DIFF_VERT = """
#version 430 core

layout (location = 0) in vec4 position;
layout (location = 1) in vec4 normal;
layout (location = 2) in vec4 texcoord;

out vec4 Position;
out vec4 Normal;
out vec4 Texcoord;

uniform bool is_present;
uniform bool render_face;
uniform vec3 fc[4];
uniform mat4 model;
uniform mat4 view_proj;

void main()
{
    mat4 mvp = view_proj * model;
    Normal = normal;
    Texcoord = texcoord;
    if (render_face)
    {
        if (gl_VertexID < 3)       gl_Position = view_proj * vec4(fc[gl_VertexID], 1.0);
        else if (gl_VertexID == 3) gl_Position = view_proj * vec4(fc[0], 1.0);
        else if (gl_VertexID == 4) gl_Position = view_proj * vec4(fc[2], 1.0);
        else if (gl_VertexID == 5) gl_Position = view_proj * vec4(fc[3], 1.0);
    }
    else
        gl_Position = mvp * position;
    Position =  gl_Position;
}
"""

DIFF_FRAG = """
#version 430 core

in vec4 Position;
in vec4 Normal;
in vec4 Texcoord;

uniform bool render_face;
uniform bool is_present;
uniform bool outer_face;
uniform float time;
uniform sampler2D tex;
out vec4 FragColor;

vec2 hash( vec2 p ) // replace this by something better
{
	p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );
	return -1.0 + 2.0*fract(sin(p)*43758.5453123);
}

float noise( in vec2 p )
{
    const float K1 = 0.366025404; // (sqrt(3)-1)/2;
    const float K2 = 0.211324865; // (3-sqrt(3))/6;

	vec2  i = floor( p + (p.x+p.y)*K1 );
    vec2  a = p - i + (i.x+i.y)*K2;
    float m = step(a.y,a.x); 
    vec2  o = vec2(m,1.0-m);
    vec2  b = a - o + K2;
	vec2  c = a - 1.0 + 2.0*K2;
    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );
	vec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));
    return dot( n, vec3(70.0) );
}

void main()
{
    if (render_face)
    {
        float ns =  ( noise(Position.xy + time * 0.3) +  noise(Position.yz + time * 0.3) +  noise(Position.zx + time * 0.3) );
        ns = pow(ns, 4) + 0.8;
        if (outer_face) { FragColor = vec4(0.4 * ns, 0.6 * ns, 0.8 * ns, 0.5); }
        else            { FragColor = vec4(0.4 * ns, 0.8 * ns, 0.6 * ns, 0.2); }
    }
    else FragColor = vec4(1.0, 1.0, 1.0, 1.0);
}

"""

cgl.init()
w = cgl.window(700, 700, "Tesseract - Jaysmito Mukherjee")
w.make_context_current()
cgl.gl_init()
fb = cgl.framebuffer_create_from_default(w)
fb2 = cgl.framebuffer_create(700, 700)

point_shd = cgl.shader()
point_shd.load(DIFF_VERT, DIFF_FRAG)

proj = cgl.mat4_perspective(math.pi / 4.0, 1.0, 0.1, 100.0)
view = cgl.mat4_look_at(cgl.vec3(0.0, 8.0, 8.0), cgl.vec3(0.0, 0.0, 0.0), cgl.vec3(0.0, 1.0, 0.0))
view_proj = cgl.mat4_mul(proj, view)

sph_cp = cgl.mesh_cpu_sphere(8, 8)
sph = cgl.mesh_gpu()
sph.upload_mesh_cpu(sph_cp)
sph_cp.destroy()

d = 3.0 
c = 0.5

# 16 vertices of a hypercube
points = [
    cgl.vec4(-1.0, -1.0, -1.0, 1.0),
    cgl.vec4(-1.0, -1.0,  1.0, 1.0),
    cgl.vec4(-1.0,  1.0, -1.0, 1.0),
    cgl.vec4(-1.0,  1.0,  1.0, 1.0),
    cgl.vec4( 1.0, -1.0, -1.0, 1.0),
    cgl.vec4( 1.0, -1.0,  1.0, 1.0),
    cgl.vec4( 1.0,  1.0, -1.0, 1.0),
    cgl.vec4( 1.0,  1.0,  1.0, 1.0),
    cgl.vec4(-1.0, -1.0, -1.0, -1.0),
    cgl.vec4(-1.0, -1.0,  1.0, -1.0),
    cgl.vec4(-1.0,  1.0, -1.0, -1.0),
    cgl.vec4(-1.0,  1.0,  1.0, -1.0),
    cgl.vec4( 1.0, -1.0, -1.0, -1.0),
    cgl.vec4( 1.0, -1.0,  1.0, -1.0),
    cgl.vec4( 1.0,  1.0, -1.0, -1.0),
    cgl.vec4( 1.0,  1.0,  1.0, -1.0),
]

projected_points = [cgl.vec3() for i in range(0, len(points))]

def render_point(px, py, pz, sc = 0.1):
    model = cgl.mat4_translate(px, py, pz)
    model = cgl.mat4_mul(model, cgl.mat4_scale(sc, sc, sc))
    point_shd.bind()
    point_shd.set_uniform_bool("render_face", False)
    point_shd.set_uniform_mat4("model", model)
    point_shd.set_uniform_mat4("view_proj", view_proj)
    sph.render()

def get_4d_rot_mat(theta, a, b):
    mat = cgl.matrix(4, 4)
    mat.load_identity()
    mat[a, a] = mat[b, b] = math.cos(theta)
    mat[a, b] = math.sin(theta)
    mat[b, a] = -math.sin(theta)
    return mat

# this function has not yet been ported (as of 25-04-2023)
def mul_mat4_vec4(m4, v4):
    v = cgl.vec4()
    for i in range(0, 4):
        for j in range(0, 4):
            v[i] += m4[i, j] * v4[j]
    return v

def update_points():
    for i in range(0, len(points)):
        pc = points[i]
        mat = get_4d_rot_mat(0.01, 0, 3)
        points[i] = mul_mat4_vec4(mat, pc)       

def render_face(pa: cgl.vec3, pb: cgl.vec3, pc: cgl.vec3, pd: cgl.vec3):
    point_shd.bind()
    point_shd.set_uniform_mat4("view_proj", view_proj)
    point_shd.set_uniform_bool("render_face", True)
    point_shd.set_uniform_vec3("fc[0]", pa)
    point_shd.set_uniform_vec3("fc[1]", pb)
    point_shd.set_uniform_vec3("fc[2]", pc)
    point_shd.set_uniform_vec3("fc[3]", pd)
    cgl.gl_render_screen_quad()   

while not w.should_close():
    w.set_size(700, 700)
    update_points()
    fb.bind()
    cgl.gl_clear(0.06, 0.06, 0.06, 1.0)
    view = cgl.mat4_look_at(cgl.vec3(0.0, 8.0, 8.0), cgl.vec3(0.0, 0.0, 0.0), cgl.vec3(0.0, 1.0, 0.0))
    view_proj = cgl.mat4_mul(proj, view)
    gl.glEnable(gl.GL_DEPTH_TEST)
    gl.glEnable(gl.GL_BLEND)
    gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)
    view = cgl.mat4_look_at(cgl.vec3(math.sin(cgl.utils_get_time() * 0.3) * 8.0, 8.0, math.cos(cgl.utils_get_time() * 0.3) *  8.0), cgl.vec3(0.0, 0.0, 0.0), cgl.vec3(0.0, 1.0, 0.0))
    view_proj = cgl.mat4_mul(proj, view)
    point_shd.bind()
    for i in range(0, len(points)):
        # project the 4D point to 3D
        po = points[i]
        p = cgl.vec4()
        p.x = (d - c) * po.x / (d - po.w)
        p.y = (d - c) * po.y / (d - po.w)
        p.z = (d - c) * po.z / (d - po.w)
        p.w = po.w
        projected_points[i] = cgl.vec3(p.x, p.y, p.z)
        render_point(p.x, p.y, p.z)
    # render the faces
    point_shd.bind()
    point_shd.set_uniform_float("time", cgl.utils_get_time())
    point_shd.set_uniform_bool("outer_face", True)
    render_face(projected_points[0], projected_points[1], projected_points[3], projected_points[2])
    render_face(projected_points[0], projected_points[1], projected_points[5], projected_points[4])
    render_face(projected_points[0], projected_points[2], projected_points[6], projected_points[4])
    render_face(projected_points[1], projected_points[3], projected_points[7], projected_points[5])
    render_face(projected_points[2], projected_points[3], projected_points[7], projected_points[6])
    render_face(projected_points[4], projected_points[5], projected_points[7], projected_points[6])
    point_shd.bind()
    point_shd.set_uniform_bool("outer_face", False)
    render_face(projected_points[8], projected_points[9], projected_points[11], projected_points[10])
    render_face(projected_points[8], projected_points[9], projected_points[13], projected_points[12])
    render_face(projected_points[8], projected_points[10], projected_points[14], projected_points[12])
    render_face(projected_points[9], projected_points[11], projected_points[15], projected_points[13])
    render_face(projected_points[10], projected_points[11], projected_points[15], projected_points[14])
    render_face(projected_points[12], projected_points[13], projected_points[15], projected_points[14])
    if w.is_key_pressed(cgl.KEY_ESCAPE):
        break
    w.swap_buffers()
    w.poll_events()
point_shd.destroy()
sph.destroy()
fb2.destroy()
fb.destroy()
cgl.gl_shutdown()
w.destroy()
cgl.shutdown()

```

`examples/rust/curve_editor.rs`:

```rs
//! The Curve Editor Example

/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

use cgl_rs::math::Vector2;
use cgl_rs::graphics::widgets as widgets;

fn main() {

    // Initialze CGL Core
    cgl_rs::init().expect("Failed to initialize CGL");

    {

        // Create the window
        let window = cgl_rs::Window::new("Curve Editor [cgl-rs] - Jaysmito Mukherjee", 512, 512).expect("Failed to create window");
        window.make_context_current();

        // Initialize CGL Graphics
        cgl_rs::graphics::init().expect("Failed to initialize CGL Graphics");

        // Initialize CGL Widgets
        widgets::init().expect("Failed to initialize CGL Widgets");

        let framebuffer = cgl_rs::graphics::Framebuffer::from_default(&window).expect("Failed to create framebuffer");
        let (mut selected_point, mut line_resolution) = (0i32, 10i32);
        let mut points =vec![
            Vector2::new(-0.8, 0.0),
            Vector2::new(0.8, 0.0),
            Vector2::new(0.0, 0.5),
            Vector2::new(0.0, -0.5)
        ];

        while !window.should_close() {
            window.set_size(512, 512);

            framebuffer.bind();

            cgl_rs::graphics::clear(0.2, 0.2, 0.2, 0.2);

            widgets::begin();

            for i in 0..4 {
                let ref point = points[i];
                widgets::set_fill_colorf(0.9, 0.8, 0.2, 1.0);
                if i as i32 == selected_point {
                    widgets::add_circle2f(point.x, point.y, 0.06);
                }
                if i < 2 {
                    widgets::set_fill_colorf(0.2, 0.8, 0.2, 1.0);
                }
                else {
                    widgets::set_fill_colorf(0.8, 0.2, 0.2, 1.0);
                }
                widgets::add_circle2f(point.x, point.y, 0.05);
            }

            widgets::set_stroke_colorf(0.8, 0.7, 0.3, 1.0);
            widgets::set_stroke_thickness(0.01);

            widgets::add_cubic_bazier2v(points[0], points[1], points[2], points[3], line_resolution);
            widgets::add_cubic_bazier_points2v(points[0], points[1], points[2], points[3], line_resolution);


            widgets::set_fill_colorf(0.8, 0.8, 0.8, 1.0);
            widgets::add_string(format!("Line Resolution: {}", line_resolution).as_str(), -1.0, 0.9, 1.0, 0.1);

            if window.is_key_pressed(cgl_rs::Key::Up) {
                line_resolution += 1;
                cgl_rs::utils::sleep(250);
            }
            else if window.is_key_pressed(cgl_rs::Key::Down) {
                line_resolution -= 1;
                cgl_rs::utils::sleep(250);
            }

            let (mut mpx, mut  mpy) = window.get_mouse_position();
            mpx = mpx / 512.0 * 2.0 - 1.0;
            mpy = 2.0 - mpy / 512.0 * 2.0 - 1.0;
            selected_point = -1;

            for i in 0..4 {
                let ref point = points[i];
                if ((point.x - mpx as f32).powf(2.0) + (point.y - mpy as f32).powf(2.0)).sqrt() < 0.1 {
                    selected_point = i as i32;
                    break;
                }
            }

            if selected_point != -1 {
                if window.get_mouse_button(cgl_rs::MouseButton::Left) == cgl_rs::Action::Press {
                    points[selected_point as usize] = Vector2::new(mpx as f32, mpy as f32);
                }
            }

            widgets::end();

            window.swap_buffers();
            window.poll_events();

        }

        widgets::shutdown();
        cgl_rs::graphics::shutdown();
    }

    cgl_rs::shutdown();
}
```

`examples/rust/dijkstra_visualizer.rs`:

```rs
// This is is just for convenience
use cgl_rs::math::Vector2;

// The main data structure to hold the actual grraph
// and perform the search on it
struct Graph {
    points      : Vec<cgl_rs::math::Vector2>, // The points
    connections : Vec<(usize, usize)>, // The connections
    radius      : f32, // The radius of the points for rendeing and mouse interaction
                       // for now it's a constant, but it could be a parameter
}

impl Graph { 

    // Create a new empty graph
    pub fn new() -> Self {
        Self {
            points          : Vec::new(),
            connections     : Vec::new(),
            radius          : 0.05,
        }
    }


    // Get the index of the point under a given position
    // This is primarily used for mouse interaction
    pub fn get_point_under_cursor(&self, cursor: cgl_rs::math::Vector2) -> Option<usize> {
        for (index, point) in self.points.iter().enumerate() { // loop over all points
            // check if the distance between the point and the cursor is less than 1.5 times the radius
            // this is to make the interaction easier with a bit of a margin
            if (*point - cursor).length() < self.radius * 1.5 { 
                return Some(index);
            }
        }

        // if no point is under the cursor return None
        None
    }


    // Get the point at a given index
    pub fn point(&self, index: usize) -> &cgl_rs::math::Vector2 {
        &self.points[index]
    }

    // clear the graph
    // clear all points and connections
    pub fn clear(&mut self) {
        self.points.clear(); // clear all points
        self.connections.clear(); // clear all connections
    }

    // add a point to the graph
    // for now it just appends the point to the list of points
    // but it can also ddo some other logic like checking if the point already exists
    // it returns the index of the point
    pub fn add_point(&mut self, point: cgl_rs::math::Vector2) -> usize {
        self.points.push(point); // add the point to the list of points
        self.points.len() - 1 // return the index of the point to be used later
    }

    // remove a point from the graph at a given index
    pub fn remove_point(&mut self, index: usize) {
        self.points.remove(index); // remove the point at the given index

        // remove all connections that are connected to the point
        self.connections.retain(|(a, b)| *a != index && *b != index);

        // update the indices of the connections
        // This is necessary because the indices of the points have changed
        // so the indices of the connections should be updated
        for (a, b) in self.connections.iter_mut() {
            if *a > index { // if the index of the first point is greater than the index of the removed point
                *a -= 1;
            }
            if *b > index { // if the index of the second point is greater than the index of the removed point
                *b -= 1;
            }
        }
    }

    // add a connection between two points
    pub fn add_connection(&mut self, a: usize, b: usize) {
        // check if connection already exists
        for (a_, b_) in self.connections.iter() { // loop over all connections
            if (a == *a_ && b == *b_) || (a == *b_ && b == *a_) { // if the connection already exists
                return; // do nothing if it already exists, maybe return an error or something
            }
        }

        // add the connection if it doesn't exist
        self.connections.push((a, b));
    }


    // this is a function to get all the neighbours of a point
    // this is needed as we arent storing the points in a real graph like
    // datastructure with links between them but rather as a list of points
    // and a list of connections so that its easier and faster to render them
    pub fn get_neighbours(&self, index: usize) -> Vec<(usize, f32)> {
        let mut result = Vec::new(); // the result vector to hold the neighbours
        for connection in self.connections.iter() {
            if connection.0 == index  { // if the second point of the connection is the point we are looking for
                result.push((connection.1, (self.points[connection.1] - self.points[index]).length()));
            }
            else if connection.1 == index  { // if the first point of the connection is the point we are looking for
                result.push((connection.0, (self.points[connection.0] - self.points[index]).length()));
            }            
        }

        // return the result
        result
    }

    // The acutal implementation of the Dijkstra algorithm
    pub fn calculate_path(&self, start: usize, end: usize) -> Vec<usize> {

        // Initialize the data structures needed for the algorithm
        let mut path = Vec::new();
        let mut visited = vec![false; self.points.len()];
        let mut distance = vec![std::f32::INFINITY; self.points.len()];
        let mut previous = vec![None; self.points.len()];

        // NOTE: In this implementation we are not really intersted in preprocesing the graph
        //       but rather just to find the shortest path between two points in the graph
        
        // the current is referring to the current point we are visiting
        let mut current = start;
        distance[current] = 0.0; // the distance to the start point is 0 all other points are infinity initially


        loop { // loop until we visit all points (we break the loop when we visit the end point or when no more points are left explicitly)
            // get the neighbours of the current point
            let neighbours = self.get_neighbours(current);

            // loop over all neighbours
            for (neighbour, weight) in neighbours {
                if !visited[neighbour] { // if the neighbour is not visited
                    let new_distance = distance[current] + weight; // calculate the distance to the neighbour from the start point
                    if new_distance < distance[neighbour] { 
                        // if the new distance is less than the current distance to the neighbour
                        // we found a shorter path to the neighbour so we update the distance and the previous point
                        distance[neighbour] = new_distance;
                        previous[neighbour] = Some(current);
                    }
                }
            }

            // mark the current point as visited
            visited[current] = true;

            // if we visited the end point we break the loop
            // as we have found the shortest path
            if current == end {
                break;
            }

            // find the neighbour with min distance that is not visited
            let mut min_distance = std::f32::INFINITY;
            let mut next = None;
            for (index, dist) in distance.iter().enumerate() {
                if !visited[index] && *dist < min_distance {
                    min_distance = *dist;
                    next = Some(index);
                }
            }

            // if there is no more points to visit we break the loop
            if next.is_none() {
                break;
            }

            // set the next point to be the current point
            current = next.unwrap();
        }

        // We have found the shortest path
        // Now we need to reconstruct the path

        // We start from the end point and go back to the start point
        let mut current = end;
        while let Some(prev) = previous[current] {
            path.push(current);
            current = prev;
        }
        // add the start point to the path
        path.push(start);

        path.reverse(); // reverse the path so it goes from the start to the end
        path       
    }

}

fn main() {
    // Initialize the logger
    cgl_rs::init().expect("Failed to initialize logger");

    // Create a window
    let window = cgl_rs::Window::new("Dijkstra Visualizer - Jaysmito Mukherjee", 800, 800).expect("Failed to create window");
    window.make_context_current(); // This must be called before initializing the graphics or it will crash

    // Initialize the graphics and widgets
    cgl_rs::graphics::init().expect("Failed to initialize graphics");
    cgl_rs::graphics::widgets::init().expect("Failed to initialize widgets");

    // get a reference to the window framebuffer
    let main_framebuffer = cgl_rs::graphics::Framebuffer::from_default(&window).expect("Failed to create main framebuffer");

    // Initialize the variables
    let mut graph = Graph::new();
    let mut has_released_since_last_press = true; // A flag to check if the mouse button has been released since the last press
    let mut active_point = None; // The point that is currently being dragged
    let mut last_two_points = (None, None); // The last two points that were clicked (to connect them)
    // The start and end points of the path
    let mut start_point = None;
    let mut end_point = None; 

    while !window.should_close() { 
        window.set_size(800, 800); // Forcing window size to 800x800

        main_framebuffer.bind(); // Bind the main framebuffer
        cgl_rs::graphics::clear(0.2, 0.2, 0.2, 1.0); // Clear the screen with a gray color
        cgl_rs::graphics::widgets::begin(); 

        //  Draw connections first at the bottom layer
        cgl_rs::graphics::widgets::set_stroke_colorf(0.4, 0.4, 0.4, 1.0);
        cgl_rs::graphics::widgets::set_stroke_thickness(0.01);
        for (a, b) in graph.connections.iter() {
            let point_a = graph.point(*a);
            let point_b = graph.point(*b);
            cgl_rs::graphics::widgets::add_line2f(point_a.x, point_a.y, point_b.x, point_b.y);
        }
        
        // now draw the path if a start and end point are selected
        cgl_rs::graphics::widgets::set_stroke_colorf(0.8, 0.4, 0.4, 1.0);
        if start_point.is_some() && end_point.is_some() {
            let path = graph.calculate_path(start_point.unwrap(), end_point.unwrap());
            for i in 0..path.len() - 1 {
                let point_a = graph.point(path[i]);
                let point_b = graph.point(path[i + 1]);
                cgl_rs::graphics::widgets::add_line2f(point_a.x, point_a.y, point_b.x, point_b.y);
            }
        }

        // draw the points
        cgl_rs::graphics::widgets::set_fill_colorf(0.4, 0.4, 0.4, 1.0);
        for point in graph.points() {
            cgl_rs::graphics::widgets::add_circle2f(point.x, point.y, graph.radius);
        }
        
        // highlight the selected points
        cgl_rs::graphics::widgets::set_fill_colorf(0.1, 0.1, 0.1, 1.0);
        if let Some(index) = last_two_points.0 {
            let point = graph.point(index);
            cgl_rs::graphics::widgets::add_circle2f(point.x, point.y, graph.radius * 0.9);
        }
        if let Some(index) = last_two_points.1 {
            let point = graph.point(index);
            cgl_rs::graphics::widgets::add_circle2f(point.x, point.y, graph.radius * 0.9);
        }
        
        // highlight the start and end points
        cgl_rs::graphics::widgets::set_fill_colorf(0.2, 0.6, 0.2, 1.0);
        if let Some(index) = start_point {
            let point = graph.point(index);
            cgl_rs::graphics::widgets::add_circle2f(point.x, point.y, graph.radius * 0.5);
        }
        cgl_rs::graphics::widgets::set_fill_colorf(0.6, 0.2, 0.2, 1.0);
        if let Some(index) = end_point {
            let point = graph.point(index);
            cgl_rs::graphics::widgets::add_circle2f(point.x, point.y, graph.radius * 0.5);
        }


        cgl_rs::graphics::widgets::end();


        
        window.swap_buffers();
        window.poll_events();



        // The input
        if window.is_mouse_button_pressed(cgl_rs::MouseButton::Left) {
            // Transform the mouse position to a eassier to deal with space
            let (x, y) = window.get_mouse_position();
            let (x, y) = (x as f32, y as f32);
            let point = cgl_rs::math::Vector2::new(x, y) / 800.0 * 2.0 - Vector2::new(1.0, 1.0); // here 800 is window size so keep that in mind i changing that
            let point = Vector2::new(point.x, -point.y);
            
            if active_point.is_none() { // if no points being dragged now
                active_point = graph.get_point_under_cursor(point); // check iff clicking a poiunt so pick it up for dagging
                if active_point.is_some() && last_two_points.0 != active_point { // update last 2 selected points appropiately
                    last_two_points.1 = last_two_points.0;
                    last_two_points.0 = active_point;
                }
            }

            if active_point.is_some() { // if there is a point being dragged
                // move the points with the mouse
                graph.point_mut(active_point.unwrap()).x = point.x;
                graph.point_mut(active_point.unwrap()).y = point.y;
            }
            else if has_released_since_last_press {
                graph.add_point(point); // if new click add a new point to graph at the location
            }

            has_released_since_last_press = false;
        } 
        else {
            has_released_since_last_press = true;
            active_point = None;
        }

        // to delete a point
        if window.is_mouse_button_pressed(cgl_rs::MouseButton::Right) && has_released_since_last_press {
            let (x, y) = window.get_mouse_position();
            let (x, y) = (x as f32, y as f32);
            let point = cgl_rs::math::Vector2::new(x, y) / 800.0 * 2.0 - Vector2::new(1.0, 1.0);
            let point = Vector2::new(point.x, -point.y);
            if let Some(index) = graph.get_point_under_cursor(point) {
                graph.remove_point(index);
                last_two_points = (None, None);
                if start_point == Some(index) {
                    start_point = None;
                }
                if end_point == Some(index) {
                    end_point = None;
                }

                if start_point.is_some() && start_point.unwrap() > index {
                    start_point = Some(start_point.unwrap() - 1);
                }
                if end_point.is_some() && end_point.unwrap() > index {
                    end_point = Some(end_point.unwrap() - 1);
                }

            }
        }

        if window.is_key_pressed(cgl_rs::Key::L) && has_released_since_last_press {
            if let (Some(a), Some(b)) = (last_two_points.0, last_two_points.1) {
                graph.add_connection(a, b);
            }
        }

        if window.is_key_pressed(cgl_rs::Key::S) && has_released_since_last_press {
            if let Some(index) = last_two_points.0 {
                start_point = Some(index);
            }
        }

        if window.is_key_pressed(cgl_rs::Key::E) && has_released_since_last_press {
            if let Some(index) = last_two_points.0 {
                end_point = Some(index);
            }
        }

        if window.is_key_pressed(cgl_rs::Key::C) && has_released_since_last_press {
            graph.clear();
            active_point = None;
            last_two_points = (None, None);
            start_point = None;
            end_point = None;
        }

        if window.is_key_pressed(cgl_rs::Key::Escape) {
            break;
        }


    }

    drop(main_framebuffer); // This one is not really necessary, but it's good practice to drop resources before shutting down
    cgl_rs::graphics::widgets::shutdown();
    cgl_rs::graphics::shutdown();
    drop(window); // This one is necessary, because the window must be dropped before shutting down
    cgl_rs::shutdown();
}

```

`examples/rust/simple_window.rs`:

```rs
fn on_window_event(_window: &cgl_rs::Window, event: &cgl_rs::Event) -> bool {
    match event {
        cgl_rs::Event::WindowClose => {
            println!("Window Close Event");
            true
        },
        cgl_rs::Event::FramebufferSize(width, height) => {
            println!("Window Resize Event: {}x{}", width, height);
            false
        },   
        cgl_rs::Event::DragNDrop(paths) => {
            println!("Drag and Drop Event: {:?}", paths);
            false
        },
        _ => {false}
    }
}

fn main() {
    cgl_rs::init().expect("Failed to initialize CGL");
    {
        // new scope so the window is dropped before shutdown
        let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
        window.register_for_events();
        window.attach_event_handler("my_event_handler", &on_window_event);
        while !window.should_close() {
            if window.is_key_pressed(cgl_rs::Key::Escape) {
                break;
            }

            window.poll_events();
            window.swap_buffers();
        }
    }
    cgl_rs::shutdown();
}
```

`python_wrapper/MANIFEST.in`:

```in
include README.md
include LICENSE

# Cython sources
recursive-include . *.pyx *.pxd

# ImGui sources
recursive-include ./lib *.lib *.a
recursive-include ./include *.h
```

`python_wrapper/cgl_wrapper.pyx`:

```pyx
from libcpp cimport bool
from libc.stdint cimport uint8_t, uint16_t, uint32_t, uint64_t, int8_t, int16_t, int32_t, int64_t, uintptr_t, intptr_t
cimport libc.stdlib as stdlib
cimport libc.math as math
import copy
from typing import Callable
from PIL import Image
import PIL
import os
import random

# CGL typedefs of standard types

cdef extern from "cgl.h":
    ctypedef unsigned char CGL_ubyte;
    ctypedef unsigned short CGL_ushort;
    ctypedef unsigned int CGL_uint;
    ctypedef unsigned long CGL_ulong;
    ctypedef unsigned long long CGL_ulonglong;
    ctypedef char CGL_byte;
    ctypedef short CGL_short;
    ctypedef int CGL_int;
    ctypedef long CGL_long;
    ctypedef long long CGL_longlong;
    ctypedef float CGL_float;
    ctypedef double CGL_double;
    ctypedef long double CGL_longdouble;
    ctypedef uint64_t CGL_sizei;
    ctypedef bool CGL_bool;
    ctypedef void CGL_void;
    ctypedef CGL_int GLint;
    ctypedef CGL_uint GLuint;


    CGL_bool CGL_init()
    void CGL_shutdown()

    void CGL_utils_sleep(const CGL_sizei milliseconds)
    CGL_byte* CGL_utils_read_file(const char* path, CGL_sizei* size)
    CGL_sizei CGL_utils_get_file_size(const CGL_byte* path)
    CGL_bool CGL_utils_append_file(const CGL_byte* path, const CGL_byte* data, size_t size)
    CGL_bool CGL_utils_write_file(const CGL_byte* path, const CGL_byte* data, size_t size)
    CGL_float CGL_utils_get_time()
    void CGL_utils_get_timestamp(char* buffer)
    CGL_bool CGL_utils_is_little_endian()
    CGL_sizei CGL_utils_get_random_with_probability(CGL_float* probabilities, CGL_sizei count)
    void CGL_utils_reverse_bytes(void* data, size_t size)
    void CGL_utils_little_endian_to_current(void* data, size_t size)
    void CGL_utils_big_endian_to_current(void* data, size_t size)
    void CGL_utils_fast_srand(CGL_int seed)
    CGL_int CGL_utils_fast_rand()
    CGL_ulong CGL_utils_xorshf96()
    void CGL_utils_srand31(CGL_uint seed)
    CGL_uint CGL_utils_rand31()

    CGL_float CGL_utils_sigmoid(CGL_float x)
    CGL_float CGL_utils_sigmoid_derivative(CGL_float x)
    CGL_float CGL_utils_relu(CGL_float x)
    CGL_float CGL_utils_relu_derivative(CGL_float x)
    CGL_float CGL_utils_tanh(CGL_float x)
    CGL_float CGL_utils_tanh_derivative(CGL_float x)
    CGL_float CGL_utils_step(CGL_float x)
    CGL_float CGL_utils_step_derivative(CGL_float x)
    CGL_float CGL_utils_relu_leaky(CGL_float x)
    CGL_float CGL_utils_relu_leaky_derivative(CGL_float x)
    CGL_float CGL_utils_relu_smooth(CGL_float x)
    CGL_float CGL_utils_relu_smooth_derivative(CGL_float x)

    void CGL_console_set_color(uint8_t color)
    void CGL_printf_red(const char* format, ...)
    void CGL_printf_green(const char* format, ...)
    void CGL_printf_gray(const char* format, ...)
    void CGL_printf_blue(const char* format, ...)
    void CGL_console_progress_bar(CGL_float progress, CGL_int width, CGL_byte* prefix, CGL_byte* suffix, CGL_byte complete_char, CGL_byte incomplete_char)

    cdef struct CGL_logger_context:
        pass

    void CGL_logger_init(bool enable_console_logging);
    void CGL_logger_shutdown();
    bool CGL_logger_attach_log_file(const char* path);
    bool CGL_logger_detach_log_file(const char* path);
    void CGL_logger_flush();
    void CGL_logger_disable_console_logging();
    void CGL_logger_enable_console_logging();
    void CGL_logger_log(CGL_int level, const char* log_format, ...);

    uint32_t CGL_utils_crc32(const void* data, size_t size)
    uint64_t CGL_utils_crc64(const void* data, size_t size)
    void CGL_utils_rot13(const char* data_in, char* data_out)
    uint32_t CGL_utils_super_fast_hash(const void* data, size_t size)

    cdef struct CGL_vec2:
        CGL_float x
        CGL_float y

    cdef struct CGL_vec3:
        CGL_float x
        CGL_float y
        CGL_float z

    cdef struct CGL_vec4:
        CGL_float x
        CGL_float y
        CGL_float z
        CGL_float w
    ctypedef CGL_vec4 CGL_color

    cdef struct CGL_ivec4:
        CGL_int x
        CGL_int y
        CGL_int z
        CGL_int w

    cdef struct CGL_mat3:
        CGL_float m[9]

    cdef struct CGL_mat4:
        CGL_float m[16]

    cdef struct CGL_quat:
        CGL_float x
        CGL_float y
        CGL_float z
        CGL_float w

    cdef CGL_float CGL_float_quadratic_lerp(CGL_float a, CGL_float b, CGL_float c, CGL_float t)
    cdef CGL_float CGL_float_cubic_lerp(CGL_float a, CGL_float b, CGL_float c, CGL_float d, CGL_float t)

    # cdef enum GLenum:
    #     pass
    ctypedef CGL_uint GLenum

    CGL_vec2 CGL_vec2_triple_product(CGL_vec2 a, CGL_vec2 b, CGL_vec2 c)
    CGL_vec3 CGL_vec3_reflect(CGL_vec3 a, CGL_vec3 n)
    CGL_vec3 CGL_vec3_rotate_about_axis(CGL_vec3 v, CGL_vec3 axis, CGL_float theta)
    CGL_vec3 CGL_vec3_triple_product(CGL_vec3 a, CGL_vec3 b, CGL_vec3 c)
    void CGL_vec3_calculate_orthonormal_basis_from_one_vector(CGL_vec3 a, CGL_vec3* pb, CGL_vec3* pc)
    CGL_vec4 CGL_vec4_triple_product(CGL_vec4 a, CGL_vec4 b, CGL_vec4 c)

    CGL_mat4 CGL_mat4_mul(CGL_mat4 a, CGL_mat4 b)
    CGL_float CGL_mat4_det(CGL_mat4 m)
    CGL_float CGL_mat4_det_by_lu(CGL_mat4 m)
    CGL_float CGL_mat4_det_by_gauss(CGL_mat4 m)
    CGL_vec4 CGL_mat4_mul_vec4(CGL_mat4 m, CGL_vec4 v)
    CGL_mat4 CGL_mat4_inverse(CGL_mat4 m)
    CGL_mat4 CGL_mat4_transpose(CGL_mat4 m)
    CGL_mat4 CGL_mat4_adjoint(CGL_mat4 m)
    CGL_mat4 CGL_mat4_gauss_elim(CGL_mat4 m)
    CGL_int CGL_mat4_rank(CGL_mat4 m)
    CGL_float CGL_mat4_trace(CGL_mat4 m)
    CGL_mat3 CGL_mat4_to_mat3(CGL_mat4 m)
    CGL_mat4 CGL_mat4_from_mat3(CGL_mat3 m)
    CGL_mat4 CGL_mat4_rotate_about_axis(CGL_vec3 axis, CGL_float angle)
    CGL_mat4 CGL_mat4_look_at(CGL_vec3 eye, CGL_vec3 target, CGL_vec3 up)
    CGL_mat4 CGL_mat4_lerp(CGL_mat4 a, CGL_mat4 b, CGL_float t)
    void CGL_mat4_decompose_lu(CGL_mat4 m, CGL_mat4* l, CGL_mat4* u)
    
    CGL_mat4 CGL_mat4_perspective(CGL_float fov, CGL_float aspect, CGL_float near, CGL_float far)
    CGL_mat4 CGL_mat4_orthographic(CGL_float left, CGL_float right, CGL_float bottom, CGL_float top, CGL_float near, CGL_float far)
    CGL_mat4 CGL_mat4_zero()
    CGL_mat4 CGL_mat4_identity()
    CGL_mat4 CGL_mat4_scale(CGL_float x, CGL_float y, CGL_float z)
    CGL_mat4 CGL_mat4_translate(CGL_float x, CGL_float y, CGL_float z)
    CGL_mat4 CGL_mat4_rotate_x(CGL_float angle)
    CGL_mat4 CGL_mat4_rotate_y(CGL_float angle)
    CGL_mat4 CGL_mat4_rotate_z(CGL_float angle)

    cdef struct CGL_shape:
        CGL_vec3* vertices
        CGL_vec3 position
        CGL_vec3 rotation
        CGL_vec3 scale
        size_t vertices_count

    void CGL_shape_init(CGL_shape* shape, size_t vertices_count)
    void CGL_shape_destroy(CGL_shape* shape)

    cdef struct CGL_transform:
        CGL_vec4 position
        CGL_vec4 rotation
        CGL_vec4 scale
        CGL_mat4 matrix
        CGL_transform* parent
    
    
    bool CGL_sat_collision_overlap_on_axis(CGL_shape* a, CGL_shape* b, CGL_vec2 axis, float* overlap_amount)
    bool CGL_sat_collision_detect(CGL_shape* a, CGL_shape* b, CGL_vec2* n_vector)
    void CGL_sat_collision_calculate_axes(CGL_shape* shape, CGL_vec2* axes, CGL_int* axes_count)
    CGL_bool CGL_utils_is_point_in_triangle(CGL_vec2 p, CGL_vec2 a, CGL_vec2 b, CGL_vec2 c)
    CGL_bool CGL_utils_is_point_in_circle(CGL_vec2 p, CGL_float r)
    CGL_bool CGL_utils_calculate_circumcircle(CGL_vec2 a, CGL_vec2 b, CGL_vec2 c, CGL_vec2* center, CGL_float* radius)
    CGL_bool CGL_utils_calculate_super_triangle(CGL_vec2* points, CGL_int points_count, CGL_vec2* a, CGL_vec2* b, CGL_vec2* c, CGL_float padding)
    CGL_bool CGL_utils_calculate_bounding_square(CGL_vec2* points, CGL_int points_count, CGL_vec2* a, CGL_vec2* b, CGL_vec2* c, CGL_vec2* d, CGL_float padding)
    CGL_bool CGL_utils_calculate_bounding_box(CGL_vec2* points, CGL_int points_count, CGL_vec2* a, CGL_vec2* b, CGL_vec2* c, CGL_vec2* d, CGL_float padding)
    CGL_float CGL_utils_random_gaussian(CGL_float mean, CGL_float std_dev)
    CGL_vec3 CGL_gjk_shape_default_support(CGL_shape* a, CGL_vec3 d)
    CGL_vec3 CGL_gjk_default_support(CGL_shape* a, CGL_shape* b, CGL_vec3 d)
    CGL_bool CGL_gjk_check_collision_2d(CGL_shape* a, CGL_shape* b, CGL_vec3* simplex_out)
    CGL_vec3 CGL_gjk_epa_2d(CGL_shape* a, CGL_shape* b, CGL_vec3* simplex)
    CGL_bool CGL_aabb_contains_point(CGL_vec2 aabb_min, CGL_vec2 aabb_max, CGL_vec2 point)
    CGL_bool CGL_aabb_intersects_aabb(CGL_vec2 aabb_min, CGL_vec2 aabb_max, CGL_vec2 aabb_min2, CGL_vec2 aabb_max2)
    CGL_bool CGL_triangulate_points_incremental(CGL_vec2* points, CGL_int points_count, CGL_int* triangles_out, CGL_int* triangles_count_out)


    CGL_transform CGL_transform_create_empty()
    CGL_transform CGL_transform_create(CGL_vec3 position, CGL_vec3 rotation, CGL_vec3 scale)
    CGL_transform CGL_transform_create_from_matrix(CGL_mat4 matrix)
    CGL_transform* CGL_transform_set_position(CGL_transform* transform, CGL_vec3 position)
    CGL_transform* CGL_transform_set_rotation(CGL_transform* transform, CGL_vec3 rotation)
    CGL_transform* CGL_transform_set_scale(CGL_transform* transform, CGL_vec3 scale)
    CGL_transform* CGL_transform_set_parent(CGL_transform* transform, CGL_transform* parent)
    CGL_transform* CGL_transform_update(CGL_transform* transform)
    CGL_transform* CGL_transform_update_matrix_local(CGL_transform* transform)
    CGL_mat4 CGL_transform_get_matrix(CGL_transform* transform)
    CGL_mat4* CGL_transform_get_matrix_ptr(CGL_transform* transform)

    cdef struct CGL_window:
        pass
    
    cdef struct GLFWwindow:
        pass
    
    ctypedef void(*CGL_window_key_callback)(CGL_window* window, CGL_int key, CGL_int scancode, CGL_int action, CGL_int mods)
    ctypedef void(*CGL_window_mouse_button_callback)(CGL_window* window, CGL_int button, CGL_int action, CGL_int mods)
    ctypedef void(*CGL_window_mouse_position_callback)(CGL_window* window, double xpos, double ypos)
    ctypedef void(*CGL_window_mouse_scroll_callback)(CGL_window* window, double xoffset, double yoffset)
    ctypedef void(*CGL_window_framebuffer_size_callback)(CGL_window* window, CGL_int width, CGL_int height)
    ctypedef void(*CGL_window_close_callback)(CGL_window* window)
    ctypedef void(*CGL_window_drag_n_drop_callback)(CGL_window* window, const CGL_byte** paths, CGL_int count)

    CGL_window* CGL_window_create(CGL_int width, CGL_int height, const char* title)
    CGL_window* CGL_window_create_undecorated(CGL_int width, CGL_int height, const char* title)
    void CGL_window_destroy(CGL_window* window)
    void CGL_window_poll_events(CGL_window* window)
    void CGL_window_swap_buffers(CGL_window* window)
    bool CGL_window_should_close(CGL_window* window)
    void CGL_window_set_title(CGL_window* window, const char* title)
    void CGL_window_set_size(CGL_window* window, CGL_int width, CGL_int height)
    void CGL_window_set_position(CGL_window* window, CGL_int x, CGL_int y)
    void CGL_window_set_hidden(CGL_window* window, bool hidden)
    void CGL_window_set_user_data(CGL_window* window, void* user_data)
    void* CGL_window_get_user_data(CGL_window* window)
    void CGL_window_get_size(CGL_window* window, CGL_int* width, CGL_int* height)
    void CGL_window_get_position(CGL_window* window, CGL_int* x, CGL_int* y)
    void CGL_window_get_framebuffer_size(CGL_window* window, CGL_int* width, CGL_int* height)
    void CGL_window_set_key_callback(CGL_window* window, CGL_window_key_callback callback)
    void CGL_window_set_mouse_button_callback(CGL_window* window, CGL_window_mouse_button_callback callback)
    void CGL_window_set_mouse_position_callback(CGL_window* window, CGL_window_mouse_position_callback callback)
    void CGL_window_set_mouse_scroll_callback(CGL_window* window, CGL_window_mouse_scroll_callback callback)
    void CGL_window_set_framebuffer_size_callback(CGL_window* window, CGL_window_framebuffer_size_callback callback)
    void CGL_window_set_close_callback(CGL_window* window, CGL_window_close_callback callback)
    void CGL_window_set_drag_n_drop_callback(CGL_window* window, CGL_window_drag_n_drop_callback callback)
    void CGL_window_resecure_callbacks(CGL_window* window)
    void CGL_window_make_context_current(CGL_window* window)
    GLFWwindow* CGL_window_get_glfw_handle(CGL_window* window)
    CGL_int CGL_window_get_key(CGL_window* window, CGL_int key)
    CGL_bool CGL_window_is_key_pressed(CGL_window* window, CGL_int key)
    CGL_int CGL_window_get_mouse_button(CGL_window* window, CGL_int button)
    void CGL_window_get_mouse_position(CGL_window* window, double* xpos, double* ypos)

    cdef struct CGL_image:
        void* data
        CGL_int height
        CGL_int width
        CGL_int bytes_per_channel
        CGL_int channels

    cdef struct CGL_texture:
        pass
    
    cdef struct CGL_framebuffer:
        pass
    
    cdef struct CGL_shader:
        pass
    
    cdef struct CGL_mesh_gpu:
        pass

    cdef struct CGL_mesh_vertex:
        CGL_vec4 position
        CGL_vec4 normal
        CGL_vec4 texture_coordinates
        CGL_vec4 bone_wieghts
        CGL_ivec4 bone_ids
    
    cdef struct CGL_mesh_cpu:
        CGL_sizei index_count
        CGL_sizei index_count_used
        CGL_uint* indices
        CGL_sizei vertex_count
        CGL_sizei vertex_count_used
        CGL_mesh_vertex* vertices
        
    
    cdef struct CGL_ssbo:
        pass
    
    cdef struct CGL_ubo:
        pass
    
    CGL_mesh_cpu* CGL_mesh_cpu_create(size_t vertex_count, size_t index_count)
    CGL_mesh_cpu* CGL_mesh_cpu_recalculate_normals(CGL_mesh_cpu* mesh)
    CGL_mesh_cpu* CGL_mesh_cpu_load_obj(const char* path)
    CGL_mesh_cpu* CGL_mesh_cpu_triangle(CGL_vec3 a, CGL_vec3 b, CGL_vec3 c)
    CGL_mesh_cpu* CGL_mesh_cpu_plane(CGL_vec3 front, CGL_vec3 right, CGL_int resolution, CGL_float scale)
    CGL_mesh_cpu* CGL_mesh_cpu_quad(CGL_vec3 a, CGL_vec3 b, CGL_vec3 c, CGL_vec3 d)
    CGL_mesh_cpu* CGL_mesh_cpu_cube(CGL_bool use_3d_tex_coords)
    CGL_mesh_cpu* CGL_mesh_cpu_sphere(CGL_int res_u, CGL_int res_v)
    CGL_mesh_cpu* CGL_mesh_cpu_create_cylinder(CGL_vec3 start, CGL_vec3 end, CGL_float radius0, CGL_float radius1, CGL_int resolution)
    CGL_mesh_cpu* CGL_mesh_cpu_add_mesh(CGL_mesh_cpu* mesh, CGL_mesh_cpu* mesh_other)
    CGL_mesh_cpu* CGL_mesh_cpu_add_cube(CGL_mesh_cpu* mesh, CGL_bool use_3d_tex_coords)
    CGL_mesh_cpu* CGL_mesh_cpu_add_triangle(CGL_mesh_cpu* mesh, CGL_vec3 a, CGL_vec3 b, CGL_vec3 c)
    CGL_mesh_cpu* CGL_mesh_cpu_add_quad(CGL_mesh_cpu* mesh, CGL_vec3 a, CGL_vec3 b, CGL_vec3 c, CGL_vec3 d)
    CGL_mesh_cpu* CGL_mesh_cpu_add_sphere(CGL_mesh_cpu* mesh, CGL_int res_u, CGL_int res_v)
    CGL_mesh_cpu* CGL_mesh_cpu_add_cylinder(CGL_mesh_cpu* mesh, CGL_vec3 start, CGL_vec3 end, CGL_float radius0, CGL_float radius1, CGL_int resolution)
    CGL_mesh_cpu* CGL_mesh_cpu_offset_vertices(CGL_mesh_cpu* mesh, CGL_vec3 offset)
    CGL_mesh_cpu* CGL_mesh_cpu_scale_vertices(CGL_mesh_cpu* mesh, CGL_float scale)
    CGL_mesh_cpu* CGL_mesh_cpu_rotate_vertices(CGL_mesh_cpu* mesh, CGL_quat rotation)
    CGL_mesh_cpu* CGL_mesh_cpu_transform_vertices(CGL_mesh_cpu* mesh, CGL_mat4 transform)
    void CGL_mesh_cpu_generate_c_initialization_code(CGL_mesh_cpu* mesh, char* buffer, const char* function_name)
    void CGL_mesh_cpu_destroy(CGL_mesh_cpu* mesh)

    CGL_texture* CGL_texture_create(CGL_image* image)
    CGL_texture* CGL_texture_create_blank(CGL_int width, CGL_int height, GLenum format, GLenum internal_format, GLenum type)
    CGL_texture* CGL_texture_create_array(CGL_int width, CGL_int height, CGL_int layers, GLenum format, GLenum internal_format, GLenum type)
    CGL_texture* CGL_texture_create_3d(CGL_int width, CGL_int height, CGL_int depth, GLenum format, GLenum internal_format, GLenum type)
    CGL_texture* CGL_texture_create_cubemap()
    void CGL_texture_cubemap_set_face(CGL_texture* texture, CGL_int face, CGL_image* image)
    void CGL_texture_array_set_layer_data(CGL_texture* texture, CGL_int layer, void* data)
    void CGL_texture_destroy(CGL_texture* texture)
    void CGL_texture_bind(CGL_texture* texture, CGL_int unit)
    void CGL_texture_set_data(CGL_texture* texture, void* data)
    void CGL_texture_set_sub_data(CGL_texture* texture, size_t offset_x, size_t offset_y, size_t size_x, size_t size_y,  void* data)
    void CGL_texture_set_pixel_data(CGL_texture* texture, int x, int y, void* data)
    void CGL_texture_set_user_data(CGL_texture* texture, void* user_data)
    void* CGL_texture_get_user_data(CGL_texture* texture)
    CGL_uint CGL_texture_get_internal_handle(CGL_texture* texture)
    void CGL_texture_get_size(CGL_texture* texture, CGL_int* width, CGL_int* height)
    void CGL_texture_set_scaling_method(CGL_texture* texture, GLint method)
    void CGL_texture_set_wrapping_method(CGL_texture* texture, GLint method)

    CGL_framebuffer* CGL_framebuffer_create_from_default(CGL_window* window)
    CGL_framebuffer* CGL_framebuffer_create(CGL_int width, CGL_int height)
    CGL_framebuffer* CGL_framebuffer_create_basic(CGL_int width, CGL_int height)
    void CGL_framebuffer_add_color_attachment(CGL_framebuffer* framebuffer, CGL_texture* texture)
    void CGL_framebuffer_destroy(CGL_framebuffer* framebuffer)
    CGL_texture* CGL_framebuffer_get_color_attachment(CGL_framebuffer* framebuffer, CGL_int index)
    void CGL_framebuffer_bind(CGL_framebuffer* framebuffer)
    void CGL_framebuffer_get_size(CGL_framebuffer* framebuffer, CGL_int* width, CGL_int* height)
    void CGL_framebuffer_set_user_data(CGL_framebuffer* framebuffer, void* user_data)
    void* CGL_framebuffer_get_user_data(CGL_framebuffer* framebuffer)
    void CGL_framebuffer_read_pixels(CGL_framebuffer* framebuffer, CGL_int x, CGL_int y, CGL_int width, CGL_int height, void* pixels)
    CGL_int CGL_framebuffer_get_mouse_pick_id(CGL_framebuffer* framebuffer, CGL_int x, CGL_int y, CGL_int index)
    CGL_texture* CGL_framebuffer_get_color_texture(CGL_framebuffer* framebuffer)
    CGL_texture* CGL_framebuffer_get_depth_texture(CGL_framebuffer* framebuffer)


    void CGL_gl_clear(CGL_float r, CGL_float g, CGL_float b, CGL_float a)
    bool CGL_gl_init()
    void CGL_gl_shutdown()
    void CGL_gl_render_screen_quad()

    
    CGL_mesh_gpu* CGL_mesh_gpu_create()
    void CGL_mesh_gpu_destroy(CGL_mesh_gpu* mesh)
    void CGL_mesh_gpu_render(CGL_mesh_gpu* mesh)
    void CGL_mesh_gpu_render_instanced(CGL_mesh_gpu* mesh, uint32_t count)
    void CGL_mesh_gpu_set_user_data(CGL_mesh_gpu* mesh, void* user_data) 
    void* CGL_mesh_gpu_get_user_data(CGL_mesh_gpu* mesh)
    void CGL_mesh_gpu_upload(CGL_mesh_gpu* mesh, CGL_mesh_cpu* mesh_cpu, bool static_draw)

    CGL_shader* CGL_shader_create(const char* vertex_shader_source, const char* fragment_shader_source, char** error)
    CGL_shader* CGL_shader_compute_create(const char* compute_shader_source, char** error)
    CGL_shader* CGL_shader_create_from_files(const char* vertex_shader_file, const char* fragment_shader_file, char** error)
    CGL_shader* CGL_shader_compute_create_from_files(const char* compute_shader_file, char** error)
    void CGL_shader_destroy(CGL_shader* shader)
    void CGL_shader_bind(CGL_shader* shader)
    int CGL_shader_get_uniform_location(CGL_shader* shader, const char* name)
    void CGL_shader_set_uniform_mat4(CGL_shader* shader, CGL_int location, CGL_mat4* matrix)
    void CGL_shader_set_uniform_vec4(CGL_shader* shader, CGL_int location, CGL_vec4* vector)
    void CGL_shader_set_uniform_vec3(CGL_shader* shader, CGL_int location, CGL_vec3* vector)
    void CGL_shader_set_uniform_vec2(CGL_shader* shader, CGL_int location, CGL_vec2* vector)
    void CGL_shader_set_uniform_int(CGL_shader* shader, CGL_int location, CGL_int value)
    void CGL_shader_set_uniform_bool(CGL_shader* shader, CGL_int location, bool value)
    void CGL_shader_set_uniform_float(CGL_shader* shader, CGL_int location, CGL_float value)
    void CGL_shader_set_uniform_double(CGL_shader* shader, CGL_int location, CGL_double value)
    void CGL_shader_set_uniform_vec2v(CGL_shader* shader, CGL_int location, CGL_float x, CGL_float y)
    void CGL_shader_set_uniform_vec3v(CGL_shader* shader, CGL_int location, CGL_float x, CGL_float y, CGL_float z)
    void CGL_shader_set_uniform_vec4v(CGL_shader* shader, CGL_int location, CGL_float x, CGL_float y, CGL_float z, CGL_float w)
    void CGL_shader_set_uniform_ivec2v(CGL_shader* shader, CGL_int location, CGL_int x, CGL_int y)
    void CGL_shader_set_uniform_ivec3v(CGL_shader* shader, CGL_int location, CGL_int x, CGL_int y, CGL_int z)
    void CGL_shader_set_uniform_ivec4v(CGL_shader* shader, CGL_int location, CGL_int x, CGL_int y, CGL_int z, CGL_int w)
    void CGL_shader_set_user_data(CGL_shader* shader, void* user_data)
    void* CGL_shader_get_user_data(CGL_shader* shader)
    void CGL_shader_compute_dispatch(CGL_shader* shader, CGL_int x, CGL_int y, CGL_int z)

    CGL_ssbo* CGL_ssbo_create(uint32_t binding)
    void CGL_ssbo_destroy(CGL_ssbo* ssbo)
    void CGL_ssbo_bind(CGL_ssbo* ssbo)
    void CGL_ssbo_bind2(CGL_ssbo* ssbo, uint32_t binding)
    void CGL_ssbo_set_data(CGL_ssbo* ssbo, size_t size, void* data, bool static_draw)
    void CGL_ssbo_set_sub_data(CGL_ssbo* ssbo, size_t offset, size_t size, void* data, bool static_draw)
    void CGL_ssbo_get_data(CGL_ssbo* ssbo, size_t* size, void* data)
    void CGL_ssbo_get_sub_data(CGL_ssbo* ssbo, size_t offset, size_t size, void* data)
    void CGL_ssbo_set_user_data(CGL_ssbo* ssbo, void* user_data)
    void* CGL_ssbo_get_user_data(CGL_ssbo* ssbo)
    size_t CGL_ssbo_get_size(CGL_ssbo* ssbo)
    void CGL_ssbo_copy(CGL_ssbo* dst, CGL_ssbo* src, size_t src_offset, size_t dst_offset, size_t size)

    CGL_ubo* CGL_ubo_create()
    void CGL_ubo_destroy(CGL_ubo* ubo)
    void CGL_ubo_bind(CGL_ubo* ubo, CGL_shader* shader, const CGL_byte* name, uint32_t binding)
    void CGL_ubo_set_data(CGL_ubo* ubo, size_t size, void* data, bool static_draw)
    void CGL_ubo_set_sub_data(CGL_ubo* ubo, size_t offset, size_t size, void* data, bool static_draw)
    void CGL_ubo_get_data(CGL_ubo* ubo, size_t* size, void* data)
    void CGL_ubo_get_sub_data(CGL_ubo* ubo, size_t offset, size_t size, void* data)
    void CGL_ubo_set_user_data(CGL_ubo* ubo, void* user_data)
    void* CGL_ubo_get_user_data(CGL_ubo* ubo)
    size_t CGL_ubo_get_size(CGL_ubo* ubo)

    cdef struct CGL_tilemap:
        pass
    
    cdef struct CGL_tile:
        pass
    
    CGL_tilemap* CGL_tilemap_create(uint32_t tile_count_x, uint32_t tile_count_y, uint32_t tile_size_x, uint32_t tile_size_y, uint32_t ssbo_binding)
    void CGL_tilemap_destroy(CGL_tilemap* tilemap)
    void CGL_tilemap_set_auto_upload(CGL_tilemap* tilemap, bool value)
    bool CGL_tilemap_get_auto_upload(CGL_tilemap* tilemap)
    bool CGL_tilemap_upload(CGL_tilemap* tilemap)
    void CGL_tilemap_set_tile_color(CGL_tilemap* tilemap, uint32_t tile_x, uint32_t tile_y, CGL_float r, CGL_float g, CGL_float b)
    void CGL_tilemap_set_tile_texture_from_array(CGL_tilemap* tilemap, uint32_t tile_x, uint32_t tile_y, uint32_t texture_index)
    void CGL_tilemap_set_tile_texture_from_tileset(CGL_tilemap* tilemap, uint32_t tile_x, uint32_t tile_y, CGL_float texture_x_min, CGL_float texture_y_min, CGL_float texture_x_max, CGL_float texture_y_max)
    void CGL_tilemap_set_all_tile_color(CGL_tilemap* tilemap, CGL_float r, CGL_float g, CGL_float b)
    void CGL_tilemap_set_all_tile_texture_from_array(CGL_tilemap* tilemap, uint32_t texture_index)
    void CGL_tilemap_set_all_tile_texture_from_tileset(CGL_tilemap* tilemap, CGL_float texture_x_min, CGL_float texture_y_min, CGL_float texture_x_max, CGL_float texture_y_max)
    void CGL_tilemap_clear_tile(CGL_tilemap* tilemap, uint32_t tile_x, uint32_t tile_y)
    void CGL_tilemap_clear_all_tile(CGL_tilemap* tilemap)
    void CGL_tilemap_render(CGL_tilemap* tilemap, CGL_float scale_x, CGL_float scale_y, CGL_float offset_x, CGL_float offset_y, CGL_texture* texture)
    void CGL_tilemap_reset(CGL_tilemap* tilemap)

    cdef struct CGL_font_character:
        CGL_vec2 size
        CGL_vec2 normalized_size
        CGL_vec2 offset
        CGL_vec2 normalized_offset
        CGL_vec2 bearing
        CGL_vec2 bearing_normalized
        CGL_vec2 advance
        CGL_vec2 advance_normalized
        unsigned char* bitmap
        char ch
    
    cdef struct CGL_font:
        pass
    
    CGL_bool CGL_text_init()
    CGL_void CGL_text_shutdown()
    CGL_font* CGL_font_load(const char* path)
    CGL_font* CGL_font_load_from_memory(const char* data, CGL_sizei size)
    CGL_void CGL_font_destory(CGL_font* font)
    CGL_texture* CGL_font_get_atlas(CGL_font* font)
    CGL_bool CGL_font_build_atlas(CGL_font* font, size_t width, size_t height, size_t font_size)
    CGL_font_character* CGL_font_get_characters(CGL_font* font)
    CGL_texture* CGL_text_bake_to_texture(const char* string, size_t string_length, CGL_font* font, size_t* width, size_t* height)

    cdef struct CGL_widgets_context:
        pass    
    
    CGL_widgets_context* CGL_widgets_context_create(size_t max_vertices, size_t max_indices)
    void CGL_widgets_context_destory(CGL_widgets_context* context)
    CGL_widgets_context* CGL_window_get_current_context()
    CGL_bool CGL_widgets_init()
    void CGL_widgets_shutdown()
    void CGL_window_set_current_context(CGL_widgets_context* context)
    CGL_bool CGL_widgets_begin()
    CGL_bool CGL_widgets_begin_int(CGL_float scale_x, CGL_float scale_y, CGL_float offset_x, CGL_float offset_y)
    CGL_bool CGL_widgets_end()
    CGL_bool CGL_widgets_flush()
    CGL_bool CGL_widgets_flush_if_required()
    void CGL_widgets_add_vertex(CGL_mesh_vertex* vertex)
    void CGL_widgets_add_mesh(CGL_mesh_cpu* mesh)
    void CGL_widgets_add_vertex_p(CGL_vec3 position)
    void CGL_widgets_add_vertex_p3f(CGL_float pos_x, CGL_float pos_y, CGL_float pos_z)
    void CGL_widgets_add_vertex_pt(CGL_vec3 position, CGL_vec2 tex_coord)
    void CGL_widgets_add_vertex_p3ft(CGL_float pos_x, CGL_float pos_y, CGL_float pos_z, CGL_vec2 tex_coord)
    void CGL_widgets_add_vertex_pt2f(CGL_vec3 position, CGL_float tex_x, CGL_float tex_y)
    void CGL_widgets_add_vertex_p3ft2f(CGL_float pos_x, CGL_float pos_y, CGL_float pos_z, CGL_float tex_x, CGL_float tex_y)
    void CGL_widgets_set_stroke_color(CGL_color color)
    void CGL_widgets_set_stroke_colorf(CGL_float r, CGL_float g, CGL_float b, CGL_float a)
    void CGL_widgets_set_stroke_thicnkess(CGL_float thickness)
    void CGL_widgets_set_fill_color(CGL_color color)
    void CGL_widgets_set_fill_colorf(CGL_float r, CGL_float g, CGL_float b, CGL_float a)
    void CGL_widgets_set_fill_mode(CGL_bool is_enabled)
    void CGL_widgets_set_projection_matrix(CGL_mat4* matrix)
    void CGL_widgets_enable_diffuse_shading(CGL_vec3 light_position, CGL_vec3 light_color)
    void CGL_widgets_disable_diffuse_shading()
    void CGL_widgets_set_view_matrix(CGL_mat4* matrix)
    void CGL_widgets_set_model_matrix(CGL_mat4* matrix)
    void CGL_widgets_set_texture(CGL_texture* texture)
    void CGL_widgets_set_font_texture(CGL_texture* texture)
    void CGL_widgets_set_mask(CGL_vec4 mask)
void CGL_widgets_set_maskf(CGL_float min_x, CGL_float min_y, CGL_float max_x, CGL_float max_y)
    void CGL_widgets_set_texture_coordinate_so(CGL_float scale_x, CGL_float scale_y, CGL_float offset_x, CGL_float offset_y)
    void CGL_widgets_apply_transformations_on_cpu()
    void CGL_widgets_apply_transformations_on_gpu()
    void CGL_widgets_add_triangle(CGL_vec3 a, CGL_vec3 b, CGL_vec3 c)
    void CGL_widgets_add_quad(CGL_vec3 a, CGL_vec3 b, CGL_vec3 c, CGL_vec3 d)
    void CGL_widgets_add_quad_8f(CGL_float ax, CGL_float ay, CGL_float bx, CGL_float by, CGL_float cx, CGL_float cy, CGL_float dx, CGL_float dy)
    void CGL_widgets_add_line(CGL_vec3 start, CGL_vec3 end)
    void CGL_widgets_add_line2f(CGL_float start_x, CGL_float start_y, CGL_float end_x, CGL_float end_y)
    void CGL_widgets_add_rect(CGL_vec3 start, CGL_vec2 size)
    void CGL_widgets_add_rect2f(CGL_float start_x, CGL_float start_y, CGL_float size_x, CGL_float size_y)
    void CGL_widgets_add_circle(CGL_vec3 position, CGL_float radius)
    void CGL_widgets_add_circle2f(CGL_float pos_x, CGL_float pos_y, CGL_float radius)
    void CGL_widgets_add_circler(CGL_vec3 position, CGL_float radius, CGL_int res)
    void CGL_widgets_add_circle2fr(CGL_float pos_x, CGL_float pos_y, CGL_float radius, CGL_int res)
    void CGL_widgets_add_oval(CGL_vec3 position, CGL_vec2 radius)
    void CGL_widgets_add_oval2f(CGL_float pos_x, CGL_float pos_y, CGL_float radius_x, CGL_float radius_y)
    void CGL_widgets_add_arc2f(CGL_float pos_x, CGL_float pos_y, CGL_float radius, CGL_float start_angle, CGL_float end_angle, CGL_int resolution)
    CGL_bool CGL_widgets_add_character(char c, CGL_float x, CGL_float y, CGL_float sx, CGL_float sy)
    CGL_bool CGL_widgets_add_string(const char* str, CGL_float x, CGL_float y, CGL_float sx, CGL_float sy)
    void CGL_widgets_add_cubic_bazier(CGL_vec3 start, CGL_vec3 end, CGL_vec3 control_1, CGL_vec3 control_2, CGL_int resolution)
    void CGL_widgets_add_cubic_bazier2v(CGL_vec2 start, CGL_vec2 end, CGL_vec2 control_1, CGL_vec2 control_2, CGL_int resolution)
    void CGL_widgets_add_cubic_bazier2f(CGL_float start_x, CGL_float start_y, CGL_float end_x, CGL_float end_y, CGL_float control_1_x, CGL_float control_1_y, CGL_float control_2_x, CGL_float control_2_y, CGL_int resolution)
    void CGL_widgets_add_cubic_bazier_points(CGL_vec3 start, CGL_vec3 end, CGL_vec3 control_1, CGL_vec3 control_2, CGL_int resolution)
    void CGL_widgets_add_cubic_bazier_points2v(CGL_vec2 start, CGL_vec2 end, CGL_vec2 control_1, CGL_vec2 control_2, CGL_int resolution)
    void CGL_widgets_add_cubic_bazier_points2f(CGL_float start_x, CGL_float start_y, CGL_float end_x, CGL_float end_y, CGL_float control_1_x, CGL_float control_1_y, CGL_float control_2_x, CGL_float control_2_y, CGL_int resolution)
    void CGL_widgets_add_plot_function(CGL_float start_x, CGL_float start_y, CGL_float size_x, CGL_float size_y, CGL_float(*func_to_plot)(CGL_float), CGL_int num_samples, CGL_float x_min, CGL_float x_max, CGL_float y_min, CGL_float y_max, CGL_float plot_thickness, CGL_vec3 plot_color, CGL_bool draw_axes, CGL_float axes_thickness, CGL_vec3 axes_color)
    void CGL_widgets_add_plot_array(CGL_float start_x, CGL_float start_y, CGL_float size_x, CGL_float size_y, CGL_vec2* values, CGL_sizei count, CGL_float marker_size, CGL_vec3 marker_color, CGL_bool draw_axes, CGL_float axes_thickness, CGL_vec3 axes_color)
    void CGL_widgets_add_plot_pie_chart(CGL_float start_x, CGL_float start_y, CGL_float radius, CGL_float* values, CGL_vec3* colors, CGL_sizei count, CGL_int resolution)
    void CGL_widgets_add_bar_graph(CGL_float start_x, CGL_float start_y, CGL_float size_x, CGL_float size_y, CGL_float* values, CGL_vec3* colors, CGL_sizei count, CGL_bool draw_axes, CGL_float axes_thickness, CGL_vec3 axes_color, CGL_bool vertical)

    
    void CGL_widgets_add_shape_out_line(CGL_shape* shape)
    CGL_float CGL_widgets_add_string_with_font(const char* str, CGL_font* font, CGL_float x, CGL_float y, CGL_float sx, CGL_float scale_y)

    cdef struct CGL_matrix:
        pass
    
    # we use this as this is also in the build lib
    ctypedef CGL_float CGL_MATRIX_DATA_TYPE
    
    CGL_matrix* CGL_matrix_create(CGL_int m, CGL_int n)
    CGL_void CGL_matrix_destroy(CGL_matrix* m)
    CGL_matrix* CGL_matrix_create_from_array(CGL_MATRIX_DATA_TYPE* array, CGL_int m, CGL_int n)
    CGL_matrix* CGL_matrix_add_to(CGL_matrix* a, CGL_matrix* b, CGL_matrix* out)
    CGL_matrix* CGL_matrix_add(CGL_matrix* a, CGL_matrix* b)
    CGL_matrix* CGL_matrix_sub_to(CGL_matrix* a, CGL_matrix* b, CGL_matrix* out)
    CGL_matrix* CGL_matrix_sub(CGL_matrix* a, CGL_matrix* b)
    CGL_matrix* CGL_matrix_elem_mul_to(CGL_matrix* a, CGL_matrix* b, CGL_matrix* out)
    CGL_matrix* CGL_matrix_elem_mul(CGL_matrix* a, CGL_matrix* b)
    CGL_matrix* CGL_matrix_mul_to(CGL_matrix* a, CGL_matrix* b, CGL_matrix* out)
    CGL_matrix* CGL_matrix_mul(CGL_matrix* a, CGL_matrix* b)
    CGL_matrix* CGL_matrix_transpose_to(CGL_matrix* m, CGL_matrix* out)
    CGL_matrix* CGL_matrix_transpose(CGL_matrix* m)
    CGL_matrix* CGL_matrix_identity_to(CGL_int m, CGL_int n, CGL_matrix* out)
    CGL_matrix* CGL_matrix_identity(CGL_int m, CGL_int n)
    CGL_matrix* CGL_matrix_scale_to(CGL_matrix* m, CGL_MATRIX_DATA_TYPE s)
    CGL_matrix* CGL_matrix_scale(CGL_matrix* m, CGL_MATRIX_DATA_TYPE s)
    CGL_MATRIX_DATA_TYPE CGL_matrix_get_elem(CGL_matrix* m, CGL_int i, CGL_int j)
    CGL_bool CGL_matrix_set_elem(CGL_matrix* m, CGL_int i, CGL_int j, CGL_MATRIX_DATA_TYPE value)
    CGL_bool CGL_matrix_set_row(CGL_matrix* m, CGL_int i, CGL_MATRIX_DATA_TYPE* row)
    CGL_bool CGL_matrix_set_col(CGL_matrix* m, CGL_int j, CGL_MATRIX_DATA_TYPE* col)
    CGL_bool CGL_matrix_get_row(CGL_matrix* m, CGL_int i, CGL_MATRIX_DATA_TYPE* out)
    CGL_bool CGL_matrix_get_col(CGL_matrix* m, CGL_int j, CGL_MATRIX_DATA_TYPE* out)
    CGL_matrix* CGL_matrix_row_to_matrix_to(CGL_MATRIX_DATA_TYPE* row, CGL_int n, CGL_matrix* out)
    CGL_matrix* CGL_matrix_row_to_matrix(CGL_MATRIX_DATA_TYPE* row, CGL_int n)
    CGL_matrix* CGL_matrix_col_to_matrix_to(CGL_MATRIX_DATA_TYPE* col, CGL_int n, CGL_matrix* out)
    CGL_matrix* CGL_matrix_col_to_matrix(CGL_MATRIX_DATA_TYPE* col, CGL_int n)
    CGL_bool CGL_matrix_is_square(CGL_matrix* m)
    CGL_bool CGL_matrix_is_symmetric(CGL_matrix* m)
    CGL_bool CGL_matrix_is_orthogonal(CGL_matrix* m)
    CGL_bool CGL_matrix_is_diagonal(CGL_matrix* m)
    CGL_bool CGL_matrix_is_identity(CGL_matrix* m)
    CGL_bool CGL_matrix_is_zero(CGL_matrix* m)
    CGL_bool CGL_matrix_is_equal(CGL_matrix* a, CGL_matrix* b)
    CGL_MATRIX_DATA_TYPE CGL_matrix_trace(CGL_matrix* m)
    CGL_MATRIX_DATA_TYPE CGL_matrix_determinant(CGL_matrix* m)
    CGL_matrix* CGL_matrix_inverse_to(CGL_matrix* m, CGL_matrix* out)
    CGL_matrix* CGL_matrix_inverse(CGL_matrix* m)
    CGL_matrix* CGL_matrix_copy_to(CGL_matrix* m, CGL_matrix* out)
    CGL_matrix* CGL_matrix_copy(CGL_matrix* m)
    CGL_bool CGL_matrix_print(CGL_matrix* m)
    CGL_matrix* CGL_matrix_gauss_jordan_to(CGL_matrix* m, CGL_matrix* out)
    CGL_matrix* CGL_matrix_gauss_jordan(CGL_matrix* m)
    CGL_matrix* CGL_matrix_submatrix_to(CGL_matrix* mat, CGL_int i, CGL_int j, CGL_int m, CGL_int n, CGL_matrix* out)
    CGL_matrix* CGL_matrix_submatrix(CGL_matrix* mat, CGL_int i, CGL_int j, CGL_int m, CGL_int n)
    CGL_matrix* CGL_matrix_minor_to(CGL_matrix* mat, CGL_int i, CGL_int j, CGL_matrix* out)
    CGL_matrix* CGL_matrix_minor(CGL_matrix* mat, CGL_int i, CGL_int j)
    CGL_matrix* CGL_matrix_adjugate_to(CGL_matrix* m, CGL_matrix* out)
    CGL_matrix* CGL_matrix_adjugate(CGL_matrix* m)
    CGL_matrix* CGL_matrix_transpose_inplace(CGL_matrix* m)
    CGL_float CGL_matrix_sum_of_row(CGL_matrix* m, CGL_int i)
    CGL_float CGL_matrix_sum_of_col(CGL_matrix* m, CGL_int j)
    CGL_float CGL_matrix_product_of_row(CGL_matrix* m, CGL_int i)
    CGL_float CGL_matrix_product_of_col(CGL_matrix* m, CGL_int j)
    CGL_matrix* CGL_matrix_make_zero(CGL_matrix* m)

    cdef struct CGL_bloom:
        pass

    
    CGL_bloom* CGL_bloom_create(CGL_int width, CGL_int height, CGL_int iterations)
    void CGL_bloom_destroy(CGL_bloom* bloom)
    void CGL_bloom_set_threshold(CGL_bloom* bloom, CGL_float val)
    float CGL_bloom_get_threshold(CGL_bloom* bloom)
    void CGL_bloom_set_knee(CGL_bloom* bloom, CGL_float val)
    float CGL_bloom_get_knee(CGL_bloom* bloom)
    void CGL_bloom_set_offset(CGL_bloom* bloom, CGL_float x, CGL_float y)
    void CGL_bloom_apply(CGL_bloom* bloom, CGL_texture* tex)
    void CGL_bloom_apply2(CGL_bloom* bloom, CGL_texture* tex_src, CGL_texture* tex_dst)
    int CGL_bloom_get_iterations(CGL_bloom* bloom)
    CGL_texture* CGL_bloom_get_lod_texture(CGL_bloom* bloom, CGL_int index)
    CGL_texture* CGL_bloom_get_prefiltered_texture(CGL_bloom* bloom)

    ctypedef CGL_float CGL_noise_data_type

    cdef struct CGL_noise_params:
        CGL_int type
        CGL_int fractal_type
        CGL_int octaves
        CGL_noise_data_type frequency
        CGL_noise_data_type lacunarity
        CGL_noise_data_type gain
        CGL_noise_data_type weighted_strength
        CGL_noise_data_type ping_pong_strength

    void CGL_noise_init()
    void CGL_noise_shutdown()
    CGL_noise_data_type CGL_noise_perlin(CGL_noise_data_type x, CGL_noise_data_type y, CGL_noise_data_type z)
    CGL_noise_data_type CGL_noise_opensimplex(CGL_noise_data_type x, CGL_noise_data_type y, CGL_noise_data_type z)
    CGL_noise_data_type CGL_noise_opensimplex2s(CGL_noise_data_type x, CGL_noise_data_type y, CGL_noise_data_type z)
    CGL_noise_data_type CGL_noise_value(CGL_noise_data_type x, CGL_noise_data_type y, CGL_noise_data_type z)
    CGL_noise_data_type CGL_noise_valuecubic(CGL_noise_data_type x, CGL_noise_data_type y, CGL_noise_data_type z)
    CGL_noise_data_type CGL_noise_worley(CGL_noise_data_type x, CGL_noise_data_type y, CGL_noise_data_type z)
    void CGL_noise_params_default(CGL_noise_params* params)
    CGL_noise_data_type CGL_noise_get(CGL_noise_params* params, CGL_noise_data_type x, CGL_noise_data_type y, CGL_noise_data_type z)



CGL_TRUE = 1
CGL_FALSE = 0

def clear_console():
    os.system('cls' if os.name == 'nt' else 'clear')

def free(ptr):
    stdlib.free(<void*>ptr)

def init() -> bool:
    return CGL_init()

def shutdown():
    CGL_shutdown()

def utils_sleep(milliseconds: int):
    CGL_utils_sleep(milliseconds)

def utils_read_file(path: str) -> bytes:
    cdef CGL_sizei size
    cdef CGL_byte* data = CGL_utils_read_file(path.encode(), &size)
    if data is NULL:
        raise MemoryError()
    result = copy.deepcopy(data[:size])
    with nogil:
        stdlib.free(data)
    return result

def utils_get_file_size(path: str) -> int:
    return CGL_utils_get_file_size(path.encode())

def utils_append_file(path: str, data: bytes) -> bool:
    return CGL_utils_append_file(path.encode(), data, len(data))

def utils_write_file(path : str, data : bytes) -> bool:
    return CGL_utils_write_file(path.encode(), data, len(data))

def utils_get_time() -> float:
    return CGL_utils_get_time()

def utils_get_timestamp() -> str:
    cdef CGL_byte buffer[128]
    CGL_utils_get_timestamp(buffer)
    return buffer.decode()

def utils_is_little_endian() -> bool:
    return CGL_utils_is_little_endian()

def utils_is_big_endian() -> bool:
    return not CGL_utils_is_little_endian()

def utils_get_random_with_probability(probabilities) -> int:
    cdef CGL_float* c_probabilities
    c_probabilities = <CGL_float*>stdlib.malloc(len(probabilities) * sizeof(CGL_float))
    if c_probabilities is NULL:
        raise MemoryError()
    for i in range(len(probabilities)):
        c_probabilities[i] = probabilities[i]
    result = CGL_utils_get_random_with_probability(c_probabilities, len(probabilities))
    with nogil:
        stdlib.free(c_probabilities)
    return result

def utils_reverse_bytes(data: bytes):
    CGL_utils_reverse_bytes(<void*>data, len(data))

def utils_little_endian_to_current(data : bytes):
    CGL_utils_little_endian_to_current(<void*>data, len(data))

def utils_big_endian_to_current(data : bytes):
    CGL_utils_big_endian_to_current(<void*>data, len(data))

def utils_fast_srand(seed: int):
    CGL_utils_fast_srand(seed)

def utils_fast_rand() -> int:
    return CGL_utils_fast_rand()

def utils_xorshf96() -> int:
    return CGL_utils_xorshf96()

def utils_srand31(seed: int):
    CGL_utils_srand31(seed)

def utils_rand31() -> int:
    return CGL_utils_rand31()

def utils_sigmoid(x: float) -> float:
    CGL_utils_sigmoid(x)

def utils_sigmoid_derivative(x: float) -> float:
    CGL_utils_sigmoid_derivative(x)

def utils_relu(x: float) -> float:
    CGL_utils_relu(x)

def utils_relu_derivative(x: float) -> float:
    CGL_utils_relu_derivative(x)

def utils_tanh(x: float) -> float:
    CGL_utils_tanh(x)

def utils_tanh_derivative(x: float) -> float:
    CGL_utils_tanh_derivative(x)

def utils_step(x: float) -> float:
    CGL_utils_step(x)

def utils_step_derivative(x: float) -> float:
    CGL_utils_step_derivative(x)

def utils_relu_leaky(x: float) -> float:
    CGL_utils_relu_leaky(x)

def utils_relu_leaky_derivative(x: float) -> float:
    CGL_utils_relu_leaky_derivative(x)

def utils_relu_smooth(x: float) -> float:
    CGL_utils_relu_smooth(x)

def utils_relu_smooth_derivative(x: float) -> float:
    CGL_utils_relu_smooth_derivative(x)


CONSOLE_COLOR_RESET = 0
CONSOLE_COLOR_RED = 1
CONSOLE_COLOR_GREEN = 2
CONSOLE_COLOR_GRAY = 3
CONSOLE_COLOR_BLUE = 4

def console_set_color(color: int):
    if color < 0 or color > 4:
        raise ValueError()
    CGL_console_set_color(color)

def printf_red(format: str):
    CGL_printf_red(format.encode())

def printf_green(format: str):
    CGL_printf_green(format.encode())

def printf_gray(format: str):
    CGL_printf_gray(format.encode())

def printf_blue(format: str):
    CGL_printf_blue(format.encode())

def console_progress_bar(progress: float, width: int, prefix: str, suffix: str, complete_char: str = "#", incomplete_char: str = "_"):
    CGL_console_progress_bar(progress, width, prefix.encode(), suffix.encode(), complete_char[0], incomplete_char[0])

LOG_LEVEL_TRACE        = 0
LOG_LEVEL_INFO         = 1
LOG_LEVEL_WARN         = 2
LOG_LEVEL_ERROR        = 3 
LOG_LEVEL_INTERNAL     = 4 
LOGGER_MAX_LOG_FILES   = 32
LOGGER_LOG_BUFFER_SIZE = (1024 * 4)


def logger_init(enable_console_logging: bool):
    CGL_logger_init(enable_console_logging)

def logger_shutdown():
    CGL_logger_shutdown()

def logger_attach_log_file(path: str) -> bool:
    return CGL_logger_attach_log_file(path.encode())

def logger_detach_log_file(path: str) -> bool:
    return CGL_logger_detach_log_file(path.encode())

def logger_flush():
    CGL_logger_flush()
    
def logger_disable_console_logging():
    CGL_logger_disable_console_logging()

def logger_enable_console_logging():
    CGL_logger_enable_console_logging()

def logger_log(level: int, log_format: str):
    CGL_logger_log(level, log_format.encode())

def log_trace(log_format: str):
    CGL_logger_log(LOG_LEVEL_TRACE, log_format.encode())

def log_info(log_format: str):
    CGL_logger_log(LOG_LEVEL_INFO, log_format.encode())

def log_warn(log_format: str):
    CGL_logger_log(LOG_LEVEL_WARN, log_format.encode())

def log_error(log_format: str):
    CGL_logger_log(LOG_LEVEL_ERROR, log_format.encode())

def log_internal(log_format: str):
    CGL_logger_log(LOG_LEVEL_INTERNAL, log_format.encode())

def utils_crc32(data: bytes) -> int:
    return CGL_utils_crc32(<void*>data, len(data))

def utils_crc64(data: bytes) -> int:
    return CGL_utils_crc64(<void*>data, len(data))

def utils_rot13(data: bytes) -> bytes:
    result = bytes(len(data))
    CGL_utils_rot13(<char*>data, <char*>result)
    return result

def utils_super_fast_hash(data: bytes) -> int:
    return CGL_utils_super_fast_hash(<void*>data, len(data))


PI = (3.14159265358979323846)
TWO_PI = (6.28318530717958647692)
PI_2 = (1.57079632679489661923)
E = (2.71828182845904523536)
SQRT2 = (1.41421356237309504880)
SQRT3 = (1.73205080756887729352)
SQRT5 = (2.23606797749978969640)
SQRT6 = (2.44948974278317809820)
SQRT7 = (2.64575131106459059050)
SQRT8 = (2.82842712474619009760)

def deg_to_rad(deg):
    return ((deg) * (PI / 180.0))

def rad_to_deg(rad):
    return ((rad) * (180.0 / PI))

def float_lerp(a: float, b: float, t: float):
    return ((a) + ((b) - (a)) * (t))

def float_quadratic_lerp(a: float, b: float, c: float, t: float) -> float:
    return CGL_float_quadratic_lerp(a, b, c, t)

def float_cubic_lerp(a: float, b: float, c: float, d: float, t: float) -> float:
    return CGL_float_cubic_lerp(a, b, c, d, t)

cdef class vec2:
    cdef CGL_vec2 c_vec2

    def __init__(self, x: float = 0.0, y: float = 0.0):
        self.c_vec2 = CGL_vec2(x, y)
    
    def __repr__(self):
        return f"vec2({self.x}, {self.y})"
    
    def __str__(self):
        return f"vec2({self.x}, {self.y})"

    def __bytes__(self):
        return bytes(self.c_vec2)
    
    def __len__(self):
        return 2
    
    def __getitem__(self, index: int):
        if index == 0:
            return self.c_vec2.x
        elif index == 1:
            return self.c_vec2.y
        else:
            raise IndexError()
    
    def __setitem__(self, index: int, value: int):
        if index == 0:
            self.c_vec2.x = value
        elif index == 1:
            self.c_vec2.y = value
        else:
            raise IndexError()
    
    def __eq__(self, other: vec2):
        return self.c_vec2.x == other.c_vec2.x and self.c_vec2.y == other.c_vec2.y
    
    def __ne__(self, other: vec2):
        return self.c_vec2.x != other.c_vec2.x or self.c_vec2.y != other.c_vec2.y
    
    def __hash__(self):
        return hash((self.c_vec2.x, self.c_vec2.y))
    
    def __getattr__(self, name: str):
        if name == "x":
            return self.c_vec2.x
        elif name == "y":
            return self.c_vec2.y
        else:
            raise AttributeError()
    
    def __setattr__(self, name: str, value):
        if name == "x":
            self.c_vec2.x = value
        elif name == "y":
            self.c_vec2.y = value
        else:
            raise AttributeError()
    
    def __add__(self, other: vec2):
        return vec2(self.x + other.x, self.y + other.y)
    
    def __sub__(self, other: vec2):
        return vec2(self.x - other.x, self.y - other.y)
    
    def __mul__(self, other: vec2):
        return vec2(self.x * other.x, self.y * other.y)
    
    def __truediv__(self, other: vec2):
        return vec2(self.x / other.x, self.y / other.y)
    
    def __floordiv__(self, other: vec2):
        return vec2(self.x // other.x, self.y // other.y)
    
    def dot(self, other: vec2):
        return (self.x * other.x) + (self.y * other.y)
    
    def cross(self, other: vec2):
        return (self.x * other.y) - (self.y * other.x)
    
    def length(self):
        return math.sqrt((self.x * self.x) + (self.y * self.y))
    
    def length_squared(self):
        return (self.x * self.x) + (self.y * self.y)
    
    def normalized(self):
        length = self.length()
        return vec2(self.x / length, self.y / length)
    
def vec2_triple_product(a: vec2, b: vec2, c: vec2) -> vec2:
    cdef CGL_vec2 obj = vec2(CGL_vec2_triple_product(a.c_vec2, b.c_vec2, c.c_vec2))
    return vec2(obj.x, obj.y)


cdef class vec3:
    cdef CGL_vec3 c_vec3

    def __init__(self, x: float = 0.0, y: float = 0.0, z: float = 0.0):
        self.c_vec3 = CGL_vec3(x, y, z)
    
    def __repr__(self):
        return f"vec3({self.x}, {self.y}, {self.z})"
    
    def __str__(self):
        return f"vec3({self.x}, {self.y}, {self.z})"

    def __bytes__(self):
        return bytes(self.c_vec3)
    
    def __len__(self):
        return 3
    
    def __getitem__(self, index: int):
        if index == 0:
            return self.c_vec3.x
        elif index == 1:
            return self.c_vec3.y
        elif index == 2:
            return self.c_vec3.z
        else:
            raise IndexError()
    
    def __setitem__(self, index: int, value: int):
        if index == 0:
            self.c_vec3.x = value
        elif index == 1:
            self.c_vec3.y = value
        elif index == 2:
            self.c_vec3.z = value
        else:
            raise IndexError()
    
    def __eq__(self, other: vec3):
        return self.c_vec3.x == other.c_vec3.x and self.c_vec3.y == other.c_vec3.y and self.c_vec3.z == other.c_vec3.z
    
    def __ne__(self, other: vec3):
        return self.c_vec3.x != other.c_vec3.x or self.c_vec3.y != other.c_vec3.y or self.c_vec3.z != other.c_vec3.z
    
    
    def __hash__(self):
        return hash((self.c_vec3.x, self.c_vec3.y, self.c_vec3.z))
    
    def __getattr__(self, name: str):
        if name == "x":
            return self.c_vec3.x
        elif name == "y":
            return self.c_vec3.y
        elif name == "z":
            return self.c_vec3.z
        else:
            raise AttributeError()
    
    def __setattr__(self, name: str, value):
        if name == "x":
            self.c_vec3.x = value
        elif name == "y":
            self.c_vec3.y = value
        elif name == "z":
            self.c_vec3.z = value
        else:
            raise AttributeError()
    
    def __add__(self, other: vec3):
        return vec3(self.x + other.x, self.y + other.y, self.z + other.z)
    
    def __sub__(self, other: vec3):
        return vec3(self.x - other.x, self.y - other.y, self.z - other.z)
    
    def __mul__(self, other: vec3):
        return vec3(self.x * other.x, self.y * other.y, self.z * other.z)
    
    def __truediv__(self, other: vec3):
        return vec3(self.x / other.x, self.y / other.y, self.z / other.z)
    
    def __floordiv__(self, other: vec3):
        return vec3(self.x // other.x, self.y // other.y, self.z // other.z)
    
    def dot(self, other: vec3):
        return (self.x * other.x) + (self.y * other.y) + (self.z * other.z)
    
    def cross(self, other: vec3):
        return vec3((self.y * other.z) - (self.z * other.y), (self.z * other.x) - (self.x * other.z), (self.x * other.y) - (self.y * other.x))
    
    def length(self):
        return math.sqrt((self.x * self.x) + (self.y * self.y) + (self.z * self.z))
    
    def length_squared(self):
        return (self.x * self.x) + (self.y * self.y) + (self.z * self.z)
    
    def normalized(self):
        cdef float length = self.length()
        return vec3(self.x / length, self.y / length, self.z / length)
    
def vec3_reflect(a: vec3, n: vec3) -> vec3:
    cdef CGL_vec3 obj = vec3(CGL_vec3_reflect(a.c_vec3, n.c_vec3))
    return vec3(obj.x, obj.y, obj.z)

def vec3_rotate_about_axis(v: vec3, axis: vec3, theta: float) -> vec3:
    cdef CGL_vec3 obj = vec3(CGL_vec3_rotate_about_axis(v.c_vec3, axis.c_vec3, theta))
    return vec3(obj.x, obj.y, obj.z)

def vec3_triple_product(a: vec3, b: vec3, c: vec3) -> vec3:
    cdef CGL_vec3 obj = vec3(CGL_vec3_triple_product(a.c_vec3, b.c_vec3, c.c_vec3))
    return vec3(obj.x, obj.y, obj.z)

cdef class vec4:
    cdef CGL_vec4 c_vec4

    def __init__(self, x: float = 0.0, y: float = 0.0, z: float = 0.0, w: float = 0.0):
        self.c_vec4 = CGL_vec4(x, y, z, w)
    
    def __repr__(self):
        return f"vec4({self.x}, {self.y}, {self.z}, {self.w})"
    
    def __str__(self):
        return f"vec4({self.x}, {self.y}, {self.z}, {self.w})"

    def __bytes__(self):
        return bytes(self.c_vec4)
    
    def __len__(self):
        return 4
    
    def __getitem__(self, index: int):
        if index == 0:
            return self.c_vec4.x
        elif index == 1:
            return self.c_vec4.y
        elif index == 2:
            return self.c_vec4.z
        elif index == 3:
            return self.c_vec4.w
        else:
            raise IndexError()
    
    def __setitem__(self, index: int, value: int):
        if index == 0:
            self.c_vec4.x = value
        elif index == 1:
            self.c_vec4.y = value
        elif index == 2:
            self.c_vec4.z = value
        elif index == 3:
            self.c_vec4.w = value
        else:
            raise IndexError()
    
    def __eq__(self, other: vec4):
        return self.c_vec4.x == other.c_vec4.x and self.c_vec4.y == other.c_vec4.y and self.c_vec4.z == other.c_vec4.z and self.c_vec4.w == other.c_vec4.w
    
    def __ne__(self, other: vec4):
        return self.c_vec4.x != other.c_vec4.x or self.c_vec4.y != other.c_vec4.y or self.c_vec4.z != other.c_vec4.z or self.c_vec4.w != other.c_vec4.w
    
    def __hash__(self):
        return hash((self.c_vec4.x, self.c_vec4.y, self.c_vec4.z, self.c_vec4.w))
    
    def __getattr__(self, name: str):
        if name == "x":
            return self.c_vec4.x
        elif name == "y":
            return self.c_vec4.y
        elif name == "z":
            return self.c_vec4.z
        elif name == "w":
            return self.c_vec4.w
        else:
            raise AttributeError()
    
    def __setattr__(self, name: str, value):
        if name == "x":
            self.c_vec4.x = value
        elif name == "y":
            self.c_vec4.y = value
        elif name == "z":
            self.c_vec4.z = value
        elif name == "w":
            self.c_vec4.w = value
        else:
            raise AttributeError()
    
    def __add__(self, other: vec4):
        return vec4(self.x + other.x, self.y + other.y, self.z + other.z, self.w + other.w)
    
    def __sub__(self, other: vec4):
        return vec4(self.x - other.x, self.y - other.y, self.z - other.z, self.w - other.w)
    
    def __mul__(self, other: vec4):
        return vec4(self.x * other.x, self.y * other.y, self.z * other.z, self.w * other.w)
    
    def __truediv__(self, other: vec4):
        return vec4(self.x / other.x, self.y / other.y, self.z / other.z, self.w / other.w)
    
    def __floordiv__(self, other: vec3):
        return vec4(self.x // other.x, self.y // other.y, self.z // other.z, self.w // other.w)
    
    def dot(self, other: vec3):
        return (self.x * other.x) + (self.y * other.y) + (self.z * other.z) + (self.w * other.w)
    
    def cross(self, other: vec3):
        return vec4(self.y * other.z - self.z * other.y, self.z * other.x - self.x * other.z, self.x * other.y - self.y * other.x, 0.0)
    
    def length(self):
        return math.sqrt(self.length_squared())
    
    def length_squared(self):
        return (self.x * self.x) + (self.y * self.y) + (self.z * self.z) + (self.w * self.w)

    def normalized(self):
        length = self.length()
        return vec4(self.x / length, self.y / length, self.z / length, self.w / length)

def vec4_triple_product(a: vec4, b: vec4, c: vec4) -> vec4:
    cdef CGL_vec4 obj = vec4(CGL_vec4_triple_product(a.c_vec4, b.c_vec4, c.c_vec4))
    return vec4(obj.x, obj.y, obj.z, obj.w)

cdef class ivec4:
    cdef CGL_ivec4 c_ivec4

    def __init__(self, x: int = 0, y: int = 0, z: int = 0, w: int = 0):
        self.c_ivec4 = CGL_ivec4(x, y, z, w)
    
    def __repr__(self):
        return f"ivec4({self.c_ivec4.x}, {self.c_ivec4.y}, {self.c_ivec4.z}, {self.c_ivec4.w})"

    def __str__(self): 
        return f"ivec4({self.c_ivec4.x}, {self.c_ivec4.y}, {self.c_ivec4.z}, {self.c_ivec4.w})"
    
    def __getitem__(self, index: int):
        if index == 0:
            return self.c_ivec4.x
        elif index == 1:
            return self.c_ivec4.y
        elif index == 2:
            return self.c_ivec4.z
        elif index == 3:
            return self.c_ivec4.w
        else:
            raise IndexError()
    
    def __setitem__(self, index: int, value: int):
        if index == 0:
            self.c_ivec4.x = value
        elif index == 1:
            self.c_ivec4.y = value
        elif index == 2:
            self.c_ivec4.z = value
        elif index == 3:
            self.c_ivec4.w = value
        else:
            raise IndexError()
    
    def __hash__(self):
        return hash((self.c_ivec4.x, self.c_ivec4.y, self.c_ivec4.z, self.c_ivec4.w))
    
    def __getattr__(self, name: str):
        if name == "x":
            return self.c_ivec4.x
        elif name == "y":
            return self.c_ivec4.y
        elif name == "z":
            return self.c_ivec4.z
        elif name == "w":
            return self.c_ivec4.w
        else:
            raise AttributeError()
    
    def __setattr__(self, name: str, value: int):   
        if name == "x":
            self.c_ivec4.x = value
        elif name == "y":
            self.c_ivec4.y = value
        elif name == "z":
            self.c_ivec4.z = value
        elif name == "w":
            self.c_ivec4.w = value
        else:
            raise AttributeError()

cdef class mat4:
    cdef CGL_mat4 c_mat4

    def __init__(self):
        self.c_mat4 = CGL_mat4()
    
    def __repr__(self):
        result = "mat4x4(\n"
        for i in range(4):
            result += "    "
            for j in range(4):
                result += f"{self.c_mat4.m[i * 4 + j]}, "
            result += "\n"
        result += ")"
        return result
    
    def __str__(self):
        result = "mat4x4(\n"
        for i in range(4):
            result += "    "
            for j in range(4):
                result += f"{self.c_mat4.m[i * 4 + j]}, "
            result += "\n"
        result += ")"
        return result
    
    cdef set_c_mat4(self, c_mat4: CGL_mat4):
        self.c_mat4 = c_mat4
    
    def __mul__(self, other: mat4):
        return mat4_mul(self, other)
    
    def __hash__(self):
        return hash((self.c_mat4.m[0], self.c_mat4.m[1], self.c_mat4.m[2], self.c_mat4.m[3], self.c_mat4.m[4], self.c_mat4.m[5], self.c_mat4.m[6], self.c_mat4.m[7], self.c_mat4.m[8], self.c_mat4.m[9], self.c_mat4.m[10], self.c_mat4.m[11], self.c_mat4.m[12], self.c_mat4.m[13], self.c_mat4.m[14], self.c_mat4.m[15]))

def mat4_mul(a: mat4, b: mat4) -> mat4:
    cdef CGL_mat4 obj = CGL_mat4_mul(a.c_mat4, b.c_mat4)
    result = mat4()
    result.set_c_mat4(obj)
    return result
    
def mat4_det(m: mat4) -> float:
    return CGL_mat4_det(m.c_mat4)
    
def mat4_det_by_lu(m: mat4) -> float:
    return CGL_mat4_det_by_lu(m.c_mat4)
    
def mat4_det_by_gauss(m: mat4) -> float:
    return CGL_mat4_det_by_gauss(m.c_mat4)
    
def mat4_mul_vec4(m: mat4, v: vec4) -> vec4:
    cdef CGL_vec4 obj = CGL_mat4_mul_vec4(m.c_mat4, v.c_vec4)
    return vec4(obj.x, obj.y, obj.z, obj.w)
    
def mat4_inverse(m: mat4) -> mat4:
    cdef CGL_mat4 obj = CGL_mat4_inverse(m.c_mat4)
    result = mat4()
    result.set_c_mat4(obj)
    return result
    
def mat4_transpose(m: mat4) -> mat4:
    cdef CGL_mat4 obj = CGL_mat4_transpose(m.c_mat4)
    result = mat4()
    result.set_c_mat4(obj)
    return result
    
def mat4_adjoint(m: mat4) -> mat4:
    cdef CGL_mat4 obj = CGL_mat4_adjoint(m.c_mat4)
    result = mat4()
    result.set_c_mat4(obj)
    return result
    
def mat4_gauss_elim(m: mat4) -> mat4:
    cdef CGL_mat4 obj = CGL_mat4_gauss_elim(m.c_mat4)
    result = mat4()
    result.set_c_mat4(obj)
    return result
    
def mat4_rank(m: mat4) -> int:
    return CGL_mat4_rank(m.c_mat4)

def mat4_trace(m: mat4) -> float:
    return CGL_mat4_trace(m.c_mat4)
    
def mat4_rotate_about_axis(axis: vec3, angle: float) -> mat4:
    cdef CGL_mat4 obj = CGL_mat4_rotate_about_axis(axis.c_vec3, angle)
    result = mat4()
    result.set_c_mat4(obj)
    return result
    
def mat4_look_at(eye: vec3, target: vec3, up: vec3) -> mat4:
    cdef CGL_mat4 obj = CGL_mat4_look_at(eye.c_vec3, target.c_vec3, up.c_vec3)
    result = mat4()
    result.set_c_mat4(obj)
    return result
    
def mat4_lerp(a: mat4, b: mat4, t: float) -> mat4:
    cdef CGL_mat4 obj = CGL_mat4_lerp(a.c_mat4, b.c_mat4, t)
    result = mat4()
    result.set_c_mat4(obj)
    return result
    
def mat4_decompose_lu(m: mat4, l: mat4, u: mat4):
    cdef CGL_mat4 l_obj = CGL_mat4()
    cdef CGL_mat4 u_obj = CGL_mat4()
    CGL_mat4_decompose_lu(m.c_mat4, &l_obj, &u_obj)
    l = mat4()
    u = mat4()
    l.set_c_mat4(l_obj)
    u.set_c_mat4(u_obj)
    return (l, u)

def mat4_perspective(fov: float, aspect: float, near: float, far: float) -> mat4:
    cdef CGL_mat4 obj = CGL_mat4_perspective(fov, aspect, near, far)
    result = mat4()
    result.set_c_mat4(obj)
    return result

def mat4_orthographic(left: float, right: float, bottom: float, top: float, near: float, far: float) -> mat4:
    cdef CGL_mat4 obj = CGL_mat4_orthographic(left, right, bottom, top, near, far)
    result = mat4()
    result.set_c_mat4(obj)
    return result

def mat4_zero() -> mat4:
    cdef CGL_mat4 obj = CGL_mat4_zero()
    result = mat4()
    result.set_c_mat4(obj)
    return result

def mat4_identity() -> mat4:
    cdef CGL_mat4 obj = CGL_mat4_identity()
    result = mat4()
    result.set_c_mat4(obj)
    return result


def mat4_scale(x: float, y: float, z: float) -> mat4:
    cdef CGL_mat4 obj = CGL_mat4_scale(x, y, z)
    result = mat4()
    result.set_c_mat4(obj)
    return result

def mat4_translate(x: float, y: float, z: float) -> mat4:
    cdef CGL_mat4 obj = CGL_mat4_translate(x, y, z)
    result = mat4()
    result.set_c_mat4(obj)
    return result

def mat4_rotate_x(angle: float) -> mat4:
    cdef CGL_mat4 obj = CGL_mat4_rotate_x(angle)
    result = mat4()
    result.set_c_mat4(obj)
    return result

def mat4_rotate_y(angle: float) -> mat4:
    cdef CGL_mat4 obj = CGL_mat4_rotate_y(angle)
    result = mat4()
    result.set_c_mat4(obj)
    return result

def mat4_rotate_z(angle: float) -> mat4:
    cdef CGL_mat4 obj = CGL_mat4_rotate_z(angle)
    result = mat4()
    result.set_c_mat4(obj)
    return result


cdef class transform:
    cdef CGL_transform c_transform

    @property
    def position(self) -> vec3:
        return vec3(self.c_transform.position.x, self.c_transform.position.y, self.c_transform.position.z)
    
    @position.setter
    def position(self, value: vec3):
        self.c_transform.position.x = value.x
        self.c_transform.position.y = value.y
        self.c_transform.position.z = value.z
        self.c_transform.position.w = 1.0
    
    @property
    def rotation(self) -> vec3:
        return vec3(self.c_transform.rotation.x, self.c_transform.rotation.y, self.c_transform.rotation.z)
    
    @rotation.setter
    def rotation(self, value: vec3):
        self.c_transform.rotation.x = value.x
        self.c_transform.rotation.y = value.y
        self.c_transform.rotation.z = value.z
        self.c_transform.rotation.w = 0.0
    
    @property
    def scale(self) -> vec3:
        return vec3(self.c_transform.scale.x, self.c_transform.scale.y, self.c_transform.scale.z)
    
    @scale.setter
    def scale(self, value: vec3):
        self.c_transform.scale.x = value.x
        self.c_transform.scale.y = value.y
        self.c_transform.scale.z = value.z
        self.c_transform.scale.w = 1.0
    
    @property
    def matrix(self) -> mat4:
        return mat4(self.c_transform.matrix)
    
    @matrix.setter
    def matrix(self, value: mat4):
        self.c_transform.matrix = value.c_mat4


    def __cinit__(self):
        self.c_transform = CGL_transform_create_empty()

    def __init__(self, position: vec3 = None, rotation: vec3 = None, scale: vec3 = None):
        if position is None:
            position = vec3()
        if rotation is None:
            rotation = vec3()
        if scale is None:
            scale = vec3(1.0, 1.0, 1.0)
        self.c_transform = CGL_transform_create(position.c_vec3, rotation.c_vec3, scale.c_vec3)

    def __hash__(self):
        return hash((self.position, self.rotation, self.scale))
    
    def __repr__(self):
        return f"transform(position={self.position}, rotation={self.rotation}, scale={self.scale})"
    
    def __eq__(self, other):
        if isinstance(other, transform):
            return self.position == other.position and self.rotation == other.rotation and self.scale == other.scale
        return False

    def __str__(self):
        return f"transform(position={self.position}, rotation={self.rotation}, scale={self.scale})"

    def load_matrix(self, m: mat4):
        self.c_transform = CGL_transform_create_from_matrix(m.c_mat4)

    def set_parent(self, parent: transform):
        self.c_transform.parent = &parent.c_transform
    
    def update(self):
        CGL_transform_update(&self.c_transform)
        

cdef class matrix:
    cdef int m
    cdef int n
    cdef CGL_matrix* c_matrix
    
    @property
    def size(self) -> tuple:
        return (self.m, self.n)
    
    @property
    def trace(self) -> float:
        return CGL_matrix_trace(self.c_matrix)
    
    @property
    def determinant(self) -> float:
        return CGL_matrix_determinant(self.c_matrix)
    
    @property
    def inverse(self) -> matrix:
        return self.calc_inverse()
    
    @property
    def transpose(self) -> matrix:
        return self.calc_transpose()
    
    @property
    def adjugate(self) -> matrix:
        return self.calc_adjugate()

    def __init__(self, m: int, n: int):
        self.c_matrix = CGL_matrix_create(m, n)
        self.m = m
        self.n = n
    
    def __dealloc__(self):
        CGL_matrix_destroy(self.c_matrix)
    
    def load_array(self, array: list, m: int, n: int):
        CGL_matrix_destroy(self.c_matrix)
        cdef float* array_ptr = <float*> stdlib.malloc(m * n * sizeof(float))
        for i in range(m * n):
            array_ptr[i] = array[i]
        self.c_matrix = CGL_matrix_create_from_array(array_ptr, m, n)
        stdlib.free(array_ptr)
    
    def __add__(self: matrix, other: matrix):
        if self.size != other.size:
            raise ValueError("Matrices must have the same size")
        result = matrix(self.m, self.n)
        CGL_matrix_add_to(self.c_matrix, other.c_matrix, result.c_matrix)
        return result
    
    def __sub__(self: matrix, other: matrix):
        if self.size != other.size:
            raise ValueError("Matrices must have the same size")
        result = matrix(self.m, self.n)
        CGL_matrix_sub_to(self.c_matrix, other.c_matrix, result.c_matrix)
        return result
    
    def __mul__(self: matrix, other: matrix):
        if self.n != other.m:
            raise ValueError("Matrices must have the same size")
        result = matrix(self.m, other.n)
        CGL_matrix_mul_to(self.c_matrix, other.c_matrix, result.c_matrix)
        return result
    
    def scaled(self: matrix, other: float):
        result = matrix(self.m, self.n)
        for i in range(self.m):
            for j in range(self.n):
                result[i, j] = self[i, j] * other
        return result
    
    def scale(self: matrix, other: float):
        CGL_matrix_scale_to(self.c_matrix, other)

    def calc_transpose(self: matrix) -> matrix:
        result = matrix(self.n, self.m)
        CGL_matrix_transpose_to(self.c_matrix, result.c_matrix)
        return result

    def transpose_inplace(self: matrix):
        CGL_matrix_transpose_inplace(self.c_matrix)

    def load_identity(self: matrix):
        CGL_matrix_identity_to(self.m, self.n, self.c_matrix)

    def __getitem__(self: matrix, key: tuple):
        if len(key) != 2:
            raise ValueError("Matrix index must be a tuple of 2 integers")
        return CGL_matrix_get_elem(self.c_matrix, key[0], key[1])
    
    def __setitem__(self: matrix, key: tuple, value: float):
        if len(key) != 2:
            raise ValueError("Matrix index must be a tuple of 2 integers")
        CGL_matrix_set_elem(self.c_matrix, key[0], key[1], value)
    
    def __repr__(self: matrix):
        result = "matrix(\n"
        for i in range(self.m):
            result += "    ["
            for j in range(self.n):
                result += f"{self[i, j]}"
                if j != self.n - 1:
                    result += ", "
            result += "]\n"
        result += ")"
        return result
    
    def __str__(self):
        result = "matrix(\n"
        for i in range(self.m):
            result += "    ["
            for j in range(self.n):
                result += f"{self[i, j]}"
                if j != self.n - 1:
                    result += ", "
            result += "]\n"
        result += ")"
        return result
    
    def set_row(self: matrix, row: int, values: list):
        if len(values) != self.n:
            raise ValueError("Values must have the same size as the matrix")
        cdef float* values_ptr = <float*> stdlib.malloc(self.n * sizeof(float))
        for i in range(self.n):
            values_ptr[i] = values[i]
        CGL_matrix_set_row(self.c_matrix, row, values_ptr)
        stdlib.free(values_ptr)

    def __eq__(self: matrix, other: matrix) -> bool:
        return CGL_matrix_is_equal(self.c_matrix, other.c_matrix)

    def get_row(self: matrix, row: int) -> list:
        cdef float* values_ptr = <float*> stdlib.malloc(self.n * sizeof(float))
        CGL_matrix_get_row(self.c_matrix, row, values_ptr)
        result = []
        for i in range(self.n):
            result.append(values_ptr[i])
        stdlib.free(values_ptr)
        return result
    
    def set_column(self: matrix, column: int, values: list):
        if len(values) != self.m:
            raise ValueError("Values must have the same size as the matrix")
        cdef float* values_ptr = <float*> stdlib.malloc(self.m * sizeof(float))
        for i in range(self.m):
            values_ptr[i] = values[i]
        CGL_matrix_set_col(self.c_matrix, column, values_ptr)
        stdlib.free(values_ptr)
    
    def get_column(self: matrix, column: int) -> list:
        cdef float* values_ptr = <float*> stdlib.malloc(self.m * sizeof(float))
        CGL_matrix_get_col(self.c_matrix, column, values_ptr)
        result = []
        for i in range(self.m):
            result.append(values_ptr[i])
        stdlib.free(values_ptr)
        return result
    
    def is_square(self: matrix) -> bool:
        return CGL_matrix_is_square(self.c_matrix)
    
    def is_symmetric(self: matrix) -> bool:
        return CGL_matrix_is_symmetric(self.c_matrix)
    
    def is_ortho(self: matrix) -> bool:
        return CGL_matrix_is_orthogonal(self.c_matrix)

    def is_identity(self: matrix) -> bool:
        return CGL_matrix_is_identity(self.c_matrix)
    
    def is_zero(self: matrix) -> bool:
        return CGL_matrix_is_zero(self.c_matrix)

    def calc_inverse(self: matrix) -> matrix:
        if not self.is_square():
            raise ValueError("Matrix must be square")
        result = matrix(self.m, self.n)
        CGL_matrix_inverse_to(self.c_matrix, result.c_matrix)
        return result
    
    def clone(self: matrix) -> matrix:
        result = matrix(self.m, self.n)
        CGL_matrix_copy_to(self.c_matrix, result.c_matrix)
        return result
    
    def print_mat(self: matrix):
        CGL_matrix_print(self.c_matrix)
    
    def gaus_jordan(self: matrix) -> matrix:
        if not self.is_square():
            raise ValueError("Matrix must be square")
        result = matrix(self.m, self.n)
        CGL_matrix_gauss_jordan_to(self.c_matrix, result.c_matrix)
        return result
    
    def submatrix(self: matrix, row: int, column: int, m: int, n: int) -> matrix:
        if row + m > self.m or column + n > self.n:
            raise ValueError("Submatrix must be inside the matrix")
        result = matrix(m, n)
        CGL_matrix_submatrix_to(self.c_matrix, row, column, m, n, result.c_matrix)
        return result

    def calc_adjugate(self: matrix) -> matrix:
        if not self.is_square():
            raise ValueError("Matrix must be square")
        result = matrix(self.m, self.n)
        CGL_matrix_adjugate_to(self.c_matrix, result.c_matrix)
        return result
    
    def make_zero(self: matrix):
        CGL_matrix_make_zero(self.c_matrix)
    
    def randomize(self: matrix, mian: float, maax: float):
        for i in range(self.m):
            for j in range(self.n):
                self[i, j] = random.uniform(mian, maax)

KEY_UNKNOWN            = -1
KEY_SPACE              = 32
KEY_APOSTROPHE         = 39 
KEY_COMMA              = 44 
KEY_MINUS              = 45 
KEY_PERIOD             = 46 
KEY_SLASH              = 47 
KEY_0                  = 48
KEY_1                  = 49
KEY_2                  = 50
KEY_3                  = 51
KEY_4                  = 52
KEY_5                  = 53
KEY_6                  = 54
KEY_7                  = 55
KEY_8                  = 56
KEY_9                  = 57
KEY_SEMICOLON          = 59  
KEY_EQUAL              = 61  
KEY_A                  = 65
KEY_B                  = 66
KEY_C                  = 67
KEY_D                  = 68
KEY_E                  = 69
KEY_F                  = 70
KEY_G                  = 71
KEY_H                  = 72
KEY_I                  = 73
KEY_J                  = 74
KEY_K                  = 75
KEY_L                  = 76
KEY_M                  = 77
KEY_N                  = 78
KEY_O                  = 79
KEY_P                  = 80
KEY_Q                  = 81
KEY_R                  = 82
KEY_S                  = 83
KEY_T                  = 84
KEY_U                  = 85
KEY_V                  = 86
KEY_W                  = 87
KEY_X                  = 88
KEY_Y                  = 89
KEY_Z                  = 90
KEY_LEFT_BRACKET       = 91  
KEY_BACKSLASH          = 92  
KEY_RIGHT_BRACKET      = 93  
KEY_GRAVE_ACCENT       = 96  
KEY_WORLD_1            = 161 
KEY_WORLD_2            = 162 
KEY_ESCAPE             = 256
KEY_ENTER              = 257
KEY_TAB                = 258
KEY_BACKSPACE          = 259
KEY_INSERT             = 260
KEY_DELETE             = 261
KEY_RIGHT              = 262
KEY_LEFT               = 263
KEY_DOWN               = 264
KEY_UP                 = 265
KEY_PAGE_UP            = 266
KEY_PAGE_DOWN          = 267
KEY_HOME               = 268
KEY_END                = 269
KEY_CAPS_LOCK          = 280
KEY_SCROLL_LOCK        = 281
KEY_NUM_LOCK           = 282
KEY_PRINT_SCREEN       = 283
KEY_PAUSE              = 284
KEY_F1                 = 290
KEY_F2                 = 291
KEY_F3                 = 292
KEY_F4                 = 293
KEY_F5                 = 294
KEY_F6                 = 295
KEY_F7                 = 296
KEY_F8                 = 297
KEY_F9                 = 298
KEY_F10                = 299
KEY_F11                = 300
KEY_F12                = 301
KEY_F13                = 302
KEY_F14                = 303
KEY_F15                = 304
KEY_F16                = 305
KEY_F17                = 306
KEY_F18                = 307
KEY_F19                = 308
KEY_F20                = 309
KEY_F21                = 310
KEY_F22                = 311
KEY_F23                = 312
KEY_F24                = 313
KEY_F25                = 314
KEY_KP_0               = 320
KEY_KP_1               = 321
KEY_KP_2               = 322
KEY_KP_3               = 323
KEY_KP_4               = 324
KEY_KP_5               = 325
KEY_KP_6               = 326
KEY_KP_7               = 327
KEY_KP_8               = 328
KEY_KP_9               = 329
KEY_KP_DECIMAL         = 330
KEY_KP_DIVIDE          = 331
KEY_KP_MULTIPLY        = 332
KEY_KP_SUBTRACT        = 333
KEY_KP_ADD             = 334
KEY_KP_ENTER           = 335
KEY_KP_EQUAL           = 336
KEY_LEFT_SHIFT         = 340
KEY_LEFT_CONTROL       = 341
KEY_LEFT_ALT           = 342
KEY_LEFT_SUPER         = 343
KEY_RIGHT_SHIFT        = 344
KEY_RIGHT_CONTROL      = 345
KEY_RIGHT_ALT          = 346
KEY_RIGHT_SUPER        = 347
KEY_MENU               = 348
MOUSE_BUTTON_1         = 0
MOUSE_BUTTON_2         = 1
MOUSE_BUTTON_3         = 2
MOUSE_BUTTON_4         = 3
MOUSE_BUTTON_5         = 4
MOUSE_BUTTON_6         = 5
MOUSE_BUTTON_7         = 6
MOUSE_BUTTON_8         = 7
MOUSE_BUTTON_LAST      = MOUSE_BUTTON_8
MOUSE_BUTTON_LEFT      = MOUSE_BUTTON_1
MOUSE_BUTTON_RIGHT     = MOUSE_BUTTON_2
MOUSE_BUTTON_MIDDLE    = MOUSE_BUTTON_3
RELEASE                = 0
PRESS                  = 1
REPEAT                 = 2

__WINDOW_TABLE = {}

cdef void __pass_through_window_close_callback(CGL_window* window):
    window_object = __WINDOW_TABLE[CGL_utils_super_fast_hash(<void*>window, sizeof(CGL_window*))]    
    window_object.close_callback(window_object)

cdef void __pass_through_window_key_callback(CGL_window* window, int key, int scancode, int action, int mods):
    window_object = __WINDOW_TABLE[CGL_utils_super_fast_hash(<void*>window, sizeof(CGL_window*))]    
    window_object.key_callback(window_object, key, scancode, action, mods)

cdef void __pass_through_window_mouse_button_callback(CGL_window* window, int button, int action, int mods):
    window_object = __WINDOW_TABLE[CGL_utils_super_fast_hash(<void*>window, sizeof(CGL_window*))]    
    window_object.mouse_button_callback(window_object, button, action, mods)

cdef void __pass_through_window_mouse_position_callback(CGL_window* window, double xpos, double ypos):
    window_object = __WINDOW_TABLE[CGL_utils_super_fast_hash(<void*>window, sizeof(CGL_window*))]    
    window_object.mouse_position_callback(window_object, xpos, ypos)

cdef void __pass_through_window_mouse_scroll_callback(CGL_window* window, double xoffset, double yoffset):
    window_object = __WINDOW_TABLE[CGL_utils_super_fast_hash(<void*>window, sizeof(CGL_window*))]    
    window_object.mouse_scroll_callback(window_object, xoffset, yoffset)

cdef void __pass_through_window_framebuffer_size_callback(CGL_window* window, int width, int height):
    window_object = __WINDOW_TABLE[CGL_utils_super_fast_hash(<void*>window, sizeof(CGL_window*))]    
    window_object.framebuffer_size_callback(window_object, width, height)

cdef void __pass_through_window_drag_n_drop_callback(CGL_window* window, const char** paths, int count):
    window_object = __WINDOW_TABLE[CGL_utils_super_fast_hash(<void*>window, sizeof(CGL_window*))]    
    path_list = []
    for i in range(count):
        path_list.append(paths[i].decode('utf-8'))
    window_object.drag_n_drop_callback(window_object, path_list)
    
cdef class window:
    cdef CGL_window* c_window
    cdef bool is_decorated
    cdef bool has_been_destroyed
    cdef str title
    cdef object key_callback
    cdef object mouse_button_callback
    cdef object mouse_position_callback
    cdef object mouse_scroll_callback
    cdef object framebuffer_size_callback
    cdef object close_callback
    cdef object drag_n_drop_callback

    @property
    def close_callback(self):
        return self.close_callback
    
    @property
    def key_callback(self):
        return self.key_callback
    
    @property
    def mouse_button_callback(self):
        return self.mouse_button_callback
    
    @property
    def mouse_position_callback(self):
        return self.mouse_position_callback
    
    @property
    def mouse_scroll_callback(self):
        return self.mouse_scroll_callback
    
    @property
    def framebuffer_size_callback(self):
        return self.framebuffer_size_callback
    
    @property
    def drag_n_drop_callback(self):
        return self.drag_n_drop_callback
    
    @property
    def width(self) -> int:
        return self.get_size()[0]
    
    @property
    def height(self) -> int:
        return self.get_size()[1]
    
    @property
    def x(self) -> int:
        return self.get_position()[0]
    
    @property
    def y(self) -> int:
        return self.get_position()[1]

    
    def __init__(self, width: int, height: int, title: str = "CGL Window", decorated: bool = True):
        self.is_decorated = decorated
        self.title = title
        if decorated:
            self.c_window = CGL_window_create(width, height, title.encode('utf-8'))
        else:
            self.c_window = CGL_window_create_undecorated(width, height, title.encode('utf-8'))
        if self.c_window == NULL:
            raise RuntimeError("Failed to create window")
        self.has_been_destroyed = False
        __WINDOW_TABLE[self.get_id()] = self
        
    def __dealloc__(self):
        self.destroy()
    
    def __hash__(self) -> int:
        return self.get_id()
    
    def destroy(self):
        if self.has_been_destroyed:
            return
        __WINDOW_TABLE.pop(self.get_id())
        CGL_window_destroy(self.c_window)
        self.has_been_destroyed = True
    
    def get_id(self) -> int:
        return CGL_utils_super_fast_hash(<void*>self.c_window, sizeof(CGL_window*))

    def poll_events(self):
        CGL_window_poll_events(self.c_window)
    
    def should_close(self) -> bool:
        return CGL_window_should_close(self.c_window)
    
    def swap_buffers(self):
        CGL_window_swap_buffers(self.c_window)
    
    def set_title(self, title: str):
        CGL_window_set_title(self.c_window, title.encode('utf-8'))
    
    def set_size(self, width: int, height: int):
        CGL_window_set_size(self.c_window, width, height)
    
    def set_position(self, x: int, y: int):
        CGL_window_set_position(self.c_window, x, y)
    
    def set_hidden(self, hidden: bool):
        CGL_window_set_hidden(self.c_window, hidden)
    
    def set_user_data(self, data: object):
        CGL_window_set_user_data(self.c_window, <void*>data)
    
    def get_user_data(self) -> object:
        return <object>CGL_window_get_user_data(self.c_window)
    
    def get_size(self) -> tuple:
        cdef int width, height
        CGL_window_get_size(self.c_window, &width, &height)
        return (width, height)
    
    def set_close_callback(self, callback: Callable):
        self.close_callback = callback
        CGL_window_set_close_callback(self.c_window, __pass_through_window_close_callback)
    
    def set_key_callback(self, callback: Callable):
        self.key_callback = callback
        CGL_window_set_key_callback(self.c_window, __pass_through_window_key_callback)
    
    def set_mouse_button_callback(self, callback: Callable):
        self.mouse_button_callback = callback
        CGL_window_set_mouse_button_callback(self.c_window, __pass_through_window_mouse_button_callback)
    
    def set_mouse_position_callback(self, callback: Callable):
        self.mouse_position_callback = callback
        CGL_window_set_mouse_position_callback(self.c_window, __pass_through_window_mouse_position_callback)
    
    def set_mouse_scroll_callback(self, callback: Callable):
        self.mouse_scroll_callback = callback
        CGL_window_set_mouse_scroll_callback(self.c_window, __pass_through_window_mouse_scroll_callback)
    
    def set_framebuffer_size_callback(self, callback: Callable):
        self.framebuffer_size_callback = callback
        CGL_window_set_framebuffer_size_callback(self.c_window, __pass_through_window_framebuffer_size_callback)
    
    def set_drag_n_drop_callback(self, callback: Callable):
        self.drag_n_drop_callback = callback
        CGL_window_set_drag_n_drop_callback(self.c_window, __pass_through_window_drag_n_drop_callback)

    def get_position(self) -> tuple:
        cdef int x, y
        CGL_window_get_position(self.c_window, &x, &y)
        return (x, y)
    
    def get_framebuffer_size(self) -> tuple:
        cdef int width, height
        CGL_window_get_framebuffer_size(self.c_window, &width, &height)
        return (width, height)

    def resecure_callbaks(self):
        CGL_window_resecure_callbacks(self.c_window)
    
    def make_context_current(self):
        CGL_window_make_context_current(self.c_window)
    
    def get_glfw_handle(self) -> object:
        return <object>CGL_window_get_glfw_handle(self.c_window)
    
    def get_key(self, key: int) -> int:
        return CGL_window_get_key(self.c_window, key)
    
    def is_key_pressed(self, key: int) -> bool:
        return CGL_window_is_key_pressed(self.c_window, key)

    def get_mouse_button(self, button: int) -> int:
        return CGL_window_get_mouse_button(self.c_window, button)
    
    def get_cursor_pos(self) -> tuple:
        cdef double x, y
        CGL_window_get_mouse_position(self.c_window, &x, &y)
        return (x, y)
    
    def __repr__(self):
        return f"window({self.width}, {self.height}, {self.title})"
    
    def __str__(self):
        return f"window({self.width}, {self.height}, {self.title})"
    
cdef class image:
    cdef CGL_image c_image
    cdef object image_data

    @property
    def width(self) -> int:
        return self.c_image.width
    
    @property
    def height(self) -> int:
        return self.c_image.height
    
    @property
    def channels(self) -> int:
        return self.c_image.channels
    
    @property
    def data(self) -> object:
        return self.image_data

    def __init__(self):
        self.c_image = CGL_image()
    
    def __hash__(self):
        return hash(self.image_data)
    
    def __repr__(self):
        return f"image({self.width}, {self.height}, {self.channels})"
    
    def __str__(self):
        return f"image({self.width}, {self.height}, {self.channels})"
    
    def load_image(self, path: str):
        img = PIL.Image.open(path)
        self.c_image.width = img.width
        self.c_image.height = img.height
        self.c_image.channels = 3
        self.c_image.bytes_per_channel = 8
        self.image_data = img.tobytes()
        self.c_image.data = <void*>self.image_data

cdef class mesh_vertex:
    cdef CGL_mesh_vertex c_vertex

    @property
    def position(self) -> vec4:
        return vec4(self.c_vertex.position.x, self.c_vertex.position.y, self.c_vertex.position.z, self.c_vertex.position.w)
    
    @position.setter
    def position(self, value: vec4):
        self.c_vertex.position.x = value.x
        self.c_vertex.position.y = value.y
        self.c_vertex.position.z = value.z
        self.c_vertex.position.w = value.w
    
    @property
    def normal(self) -> vec4:
        return vec4(self.c_vertex.normal.x, self.c_vertex.normal.y, self.c_vertex.normal.z, self.c_vertex.normal.w)
    
    @normal.setter
    def normal(self, value: vec4):
        self.c_vertex.normal.x = value.x
        self.c_vertex.normal.y = value.y
        self.c_vertex.normal.z = value.z
        self.c_vertex.normal.w = value.w
    
    @property
    def texture_coordinates(self) -> vec4:
        return vec4(self.c_vertex.texture_coordinates.x, self.c_vertex.texture_coordinates.y, self.c_vertex.texture_coordinates.z, self.c_vertex.texture_coordinates.w)
    
    @texture_coordinates.setter
    def texture_coordinates(self, value: vec4):
        self.c_vertex.texture_coordinates.x = value.x
        self.c_vertex.texture_coordinates.y = value.y
        self.c_vertex.texture_coordinates.z = value.z
        self.c_vertex.texture_coordinates.w = value.w
    
    @property
    def bone_wieghts(self) -> vec4:
        return vec4(self.c_vertex.bone_wieghts.x, self.c_vertex.bone_wieghts.y, self.c_vertex.bone_wieghts.z, self.c_vertex.bone_wieghts.w)
    
    @bone_wieghts.setter
    def bone_wieghts(self, value: vec4):
        self.c_vertex.bone_wieghts.x = value.x
        self.c_vertex.bone_wieghts.y = value.y
        self.c_vertex.bone_wieghts.z = value.z
        self.c_vertex.bone_wieghts.w = value.w
    
    @property
    def bone_ids(self) -> ivec4:
        return ivec4(self.c_vertex.bone_ids.x, self.c_vertex.bone_ids.y, self.c_vertex.bone_ids.z, self.c_vertex.bone_ids.w)
    
    @bone_ids.setter
    def bone_ids(self, value: ivec4):
        self.c_vertex.bone_ids.x = value.x
        self.c_vertex.bone_ids.y = value.y
        self.c_vertex.bone_ids.z = value.z
        self.c_vertex.bone_ids.w = value.w
    
    def __init__(self, c_vertex = None):
        if c_vertex is not None:
            self.c_vertex = c_vertex
        else:
            self.c_vertex = CGL_mesh_vertex()
    
    def __hash__(self):
        return hash((self.position, self.normal, self.texture_coordinates, self.bone_wieghts, self.bone_ids))
    
    def __repr__(self):
        return f"mesh_vertex({self.position}, {self.normal}, {self.texture_coordinates}, {self.bone_wieghts}, {self.bone_ids})"
    
    def __str__(self):
        return f"mesh_vertex({self.position}, {self.normal}, {self.texture_coordinates}, {self.bone_wieghts}, {self.bone_ids})"
    

cdef class mesh_cpu:
    cdef CGL_mesh_cpu* c_mesh
    cdef bool has_been_destroyed

    @property
    def index_count(self) -> int:
        return self.c_mesh.index_count

    @property
    def index_count_used(self) -> int:
        return self.c_mesh.index_count_used
    
    @property
    def indices(self) -> list:
        return [self.c_mesh.indices[i] for i in range(self.index_count_used)]
    
    @indices.setter
    def indices(self, value: list):
        if len(value) > self.index_count:
            raise ValueError("The number of indices is greater than the maximum number of indices")
        self.c_mesh.index_count_used = len(value)
        for i in range(self.index_count_used):
            self.c_mesh.indices[i] = value[i]
    
    @property
    def vertex_count(self) -> int:
        return self.c_mesh.vertex_count
    
    @property
    def vertex_count_used(self) -> int:
        return self.c_mesh.vertex_count_used
    
    @property
    def vertices(self) -> list:
        return [mesh_vertex(self.c_mesh.vertices[i]) for i in range(self.vertex_count_used)]

    def __init__(self):
        self.c_mesh = NULL
        self.has_been_destroyed = True
    
    def __dealloc__(self):
        self.destroy()
    
    def __hash__(self):
        return <int><CGL_ulong>self.c_mesh
    
    def __repr__(self):
        return f"mesh_cpu({self.index_count}, {self.index_count_used}, {self.vertex_count}, {self.vertex_count_used})"
    
    def __str__(self):
        return f"mesh_cpu({self.index_count}, {self.index_count_used}, {self.vertex_count}, {self.vertex_count_used})"

    cdef set_c_mesh(self, CGL_mesh_cpu* c_mesh):
        if not self.has_been_destroyed:
            self.destroy()
        self.c_mesh = c_mesh
        self.has_been_destroyed = False

    def destroy(self):
        if not self.has_been_destroyed:
            self.has_been_destroyed = True
            CGL_mesh_cpu_destroy(self.c_mesh)

    def recalculate_normals(self):
        CGL_mesh_cpu_recalculate_normals(self.c_mesh)

    def load_obj(self, path: str):
        self.c_mesh = CGL_mesh_cpu_load_obj(path.encode("utf-8"))
        if self.c_mesh == NULL:
            raise RuntimeError("Failed to load mesh from obj file")
        self.has_been_destroyed = False
    
    def add_mesh(self, mesh: mesh_cpu):
        CGL_mesh_cpu_add_mesh(self.c_mesh, mesh.c_mesh)
    
    def add_cube(self, use_texture_coordinates: bool = True):
        CGL_mesh_cpu_add_cube(self.c_mesh, use_texture_coordinates)
    
    def add_triangle(self, a: vec3, b: vec3, c: vec3):
        CGL_mesh_cpu_add_triangle(self.c_mesh, a.c_vec3, b.c_vec3, c.c_vec3)
    
    def add_quad(self, a: vec3, b: vec3, c: vec3, d: vec3):
        CGL_mesh_cpu_add_quad(self.c_mesh, a.c_vec3, b.c_vec3, c.c_vec3, d.c_vec3)
    
    def add_sphere(self, res_u: int, res_v: int):
        CGL_mesh_cpu_add_sphere(self.c_mesh, res_u, res_v)

    def add_cylinder(self, start: vec3, end: vec3, radius0: float, radius1: float, res: int):
        CGL_mesh_cpu_add_cylinder(self.c_mesh, start.c_vec3, end.c_vec3, radius0, radius1, res)

    def offset_vetices(self, offset: vec3):
        CGL_mesh_cpu_offset_vertices(self.c_mesh, offset.c_vec3)
    
    def scale_vertices(self, scale: float):
        CGL_mesh_cpu_scale_vertices(self.c_mesh, scale)
    
    # def rotate_vertices(self, rotation: quat):
    #     CGL_mesh_cpu_rotate_vertices(self.c_mesh, rotation.c_quat)
    
    def transform_vertices(self, transform: mat4):
        CGL_mesh_cpu_transform_vertices(self.c_mesh, transform.c_mat4)
    
    def get_c_initialization_code(self, function_name: str = "load_object") -> str:
        cdef CGL_byte* buff = <CGL_byte*>stdlib.malloc(1024 * 1024 * 4)
        CGL_mesh_cpu_generate_c_initialization_code(self.c_mesh, buff, function_name.encode("utf-8"))
        byts = <bytes>buff
        result = copy.deepcopy(byts)
        stdlib.free(buff)
        return result.decode("utf-8")


def mesh_cpu_create(index_count: int, vertex_count: int) -> mesh_cpu:
    cdef CGL_mesh_cpu* c_mesh = CGL_mesh_cpu_create(index_count, vertex_count)
    if c_mesh == NULL:
        raise RuntimeError("Failed to create mesh")
    res = mesh_cpu()
    res.set_c_mesh(c_mesh)
    return res

def mesh_cpu_load_obj(path: str) -> mesh_cpu:
    cdef CGL_mesh_cpu* c_mesh = CGL_mesh_cpu_load_obj(path.encode("utf-8"))
    if c_mesh == NULL:
        raise RuntimeError("Failed to load mesh from obj file")
    res = mesh_cpu()
    res.set_c_mesh(c_mesh)
    return res

def mesh_cpu_triangle(a: vec3, b: vec3, c: vec3) -> mesh_cpu:
    cdef CGL_mesh_cpu* c_mesh = CGL_mesh_cpu_triangle(a.c_vec3, b.c_vec3, c.c_vec3)
    if c_mesh == NULL:
        raise RuntimeError("Failed to create triangle mesh")
    res = mesh_cpu()
    res.set_c_mesh(c_mesh)
    return res

def mesh_cpu_quad(a: vec3, b: vec3, c: vec3, d: vec3) -> mesh_cpu:
    cdef CGL_mesh_cpu* c_mesh = CGL_mesh_cpu_quad(a.c_vec3, b.c_vec3, c.c_vec3, d.c_vec3)
    if c_mesh == NULL:
        raise RuntimeError("Failed to create quad mesh")
    res = mesh_cpu()
    res.set_c_mesh(c_mesh)
    return res

def mesh_cpu_plane(front: vec3, right: vec3, resolution: int, scale: float) -> mesh_cpu:
    cdef CGL_mesh_cpu* c_mesh = CGL_mesh_cpu_plane(front.c_vec3, right.c_vec3, resolution, scale)
    if c_mesh == NULL:
        raise RuntimeError("Failed to create plane mesh")
    res = mesh_cpu()
    res.set_c_mesh(c_mesh)
    return res

def mesh_cpu_cube(use_3d_tex_coords: bool) -> mesh_cpu:
    cdef CGL_mesh_cpu* c_mesh = CGL_mesh_cpu_cube(use_3d_tex_coords)
    if c_mesh == NULL:
        raise RuntimeError("Failed to create cube mesh")
    res = mesh_cpu()
    res.set_c_mesh(c_mesh)
    return res

def mesh_cpu_sphere(res_u: int, res_v: int) -> mesh_cpu:
    cdef CGL_mesh_cpu* c_mesh = CGL_mesh_cpu_sphere(res_u, res_v)
    if c_mesh == NULL:
        raise RuntimeError("Failed to create sphere mesh")
    res = mesh_cpu()
    res.set_c_mesh(c_mesh)
    return res

def mesh_cpu_cylinder(start: vec3, end: vec3, radius0: float, radius1: float, resolution: int) -> mesh_cpu:
    cdef CGL_mesh_cpu* c_mesh = CGL_mesh_cpu_create_cylinder(start.c_vec3, end.c_vec3, radius0, radius1, resolution)
    if c_mesh == NULL:
        raise RuntimeError("Failed to create cylinder mesh")
    res = mesh_cpu()
    res.set_c_mesh(c_mesh)
    return res

CUBEMAP_POSITIVE_X = 0x8515 
CUBEMAP_NEGATIVE_X = 0x8516 
CUBEMAP_POSITIVE_Y = 0x8517 
CUBEMAP_NEGATIVE_Y = 0x8518 
CUBEMAP_POSITIVE_Z = 0x8519 
CUBEMAP_NEGATIVE_Z = 0x851A 

cdef class texture:
    cdef CGL_texture* c_texture
    cdef bool has_been_destroyed
    
    @property
    def width(self):
        return self.get_size()[0]
    
    @property
    def height(self):
        return self.get_size()[1]

    def __init__(self):
        self.c_texture = NULL
        self.has_been_destroyed = True
    
    def __dealloc__(self):
        self.destroy()
    
    def __hash__(self):
        return self.get_internal_handle()
    
    def __repr__(self):
        return f"texture({self.get_internal_handle()})"
    
    def __eq__(self, other):
        if isinstance(other, texture):
            return self.get_internal_handle() == other.get_internal_handle()
        return False
    
    def __str__(self):
        return f"texture({self.get_internal_handle()})"
    
    cdef set_c_texture(self, CGL_texture* c_texture):
        if not self.has_been_destroyed:
            self.destroy()
        self.c_texture = c_texture
        self.has_been_destroyed = False       
    
    def destroy(self):
        if not self.has_been_destroyed:
            CGL_texture_destroy(self.c_texture)
            self.has_been_destroyed = True
    
    def load_image(self, image: image):
        self.c_texture = CGL_texture_create(&image.c_image)
        if self.c_texture == NULL:
            raise RuntimeError("Failed to create texture from image")
        self.has_been_destroyed = False
    
    def bind(self, slot: int):
        CGL_texture_bind(self.c_texture, slot)
    
    def cubemap_set_face(self, face: int, image: image):
        CGL_texture_cubemap_set_face(self.c_texture, face, &image.c_image)
    
    def array_set_layer_data(self, layer: int, data: bytes):
        CGL_texture_array_set_layer_data(self.c_texture, layer, <void*>data)
    
    def set_data(self, data: bytes):
        CGL_texture_set_data(self.c_texture, <void*>data)
    
    def set_sub_data(self, x: int, y: int, width: int, height: int, data: bytes):
        CGL_texture_set_sub_data(self.c_texture, x, y, width, height, <void*>data)
    
    def set_pixel_data(self, x: int, y: int, data: bytes):
        CGL_texture_set_pixel_data(self.c_texture, x, y, <void*>data)
    
    def set_user_data(self, data: object):
        CGL_texture_set_user_data(self.c_texture, <void*>data)
    
    def get_user_data(self) -> object:
        return <object>CGL_texture_get_user_data(self.c_texture)
    
    def get_internal_handle(self) -> int:
        return CGL_texture_get_internal_handle(self.c_texture)
    
    def get_size(self) -> tuple:
        cdef CGL_int width
        cdef CGL_int height
        CGL_texture_get_size(self.c_texture, &width, &height)
        return (width, height)

    def set_scaling_method(self, scaling_method: int):
        CGL_texture_set_scaling_method(self.c_texture, scaling_method)
    
    def set_wrapping_method(self, wrapping_method: int):
        CGL_texture_set_wrapping_method(self.c_texture, wrapping_method)
    


def texture_create_from_image(image: image) -> texture:
    cdef CGL_texture* c_texture = CGL_texture_create(&image.c_image)
    if c_texture == NULL:
        raise RuntimeError("Failed to create texture from image")
    res = texture()
    res.set_c_texture(c_texture)
    return res

def texture_create_blank(width: int, height: int, formatf: GLenum, internal_format: GLenum, typef: GLenum) -> texture:
    cdef CGL_texture* c_texture = CGL_texture_create_blank(width, height, formatf, internal_format, typef)
    if c_texture == NULL:
        raise RuntimeError("Failed to create blank texture")
    res = texture()
    res.set_c_texture(c_texture)
    return res

def texture_create_array(width: int, height: int, depth: int, formatf: GLenum, internal_format: GLenum, typef: GLenum) -> texture:
    cdef CGL_texture* c_texture = CGL_texture_create_array(width, height, depth, formatf, internal_format, typef)
    if c_texture == NULL:
        raise RuntimeError("Failed to create texture array")
    res = texture()
    res.set_c_texture(c_texture)
    return res

def texture_creae_3d(width: int, height: int, depth: int, formatf: GLenum, internal_format: GLenum, typef: GLenum) -> texture:
    cdef CGL_texture* c_texture = CGL_texture_create_3d(width, height, depth, formatf, internal_format, typef)
    if c_texture == NULL:
        raise RuntimeError("Failed to create 3d texture")
    res = texture()
    res.set_c_texture(c_texture)
    return res

def texture_create_cubemap() -> texture:
    cdef CGL_texture* c_texture = CGL_texture_create_cubemap()
    if c_texture == NULL:
        raise RuntimeError("Failed to create cubemap texture")
    res = texture()
    res.set_c_texture(c_texture)
    return res

cdef class framebuffer:
    cdef CGL_framebuffer* c_framebuffer
    cdef bool has_been_destroyed

    def __init__(self):
        self.c_framebuffer = NULL
        self.has_been_destroyed = True
    
    def __dealloc__(self):
        self.destroy()
    
    def __repr__(self):
        return f"framebuffer({self.get_id()})"
    
    def __str__(self):
        return f"framebuffer({self.get_id()})"
    
    def __hash__(self):
        return self.get_id()

    def destroy(self):
        if not self.has_been_destroyed:
            CGL_framebuffer_destroy(self.c_framebuffer)
            self.has_been_destroyed = True
    
    def get_id(self) -> int:
        return CGL_utils_super_fast_hash(&self.c_framebuffer, sizeof(CGL_framebuffer*))
    
    cdef set_c_framebuffer(self, CGL_framebuffer* c_framebuffer):
        if not self.has_been_destroyed:
            self.destroy()
        self.c_framebuffer = c_framebuffer
        self.has_been_destroyed = False
    
    def add_color_attachment(self, tex: texture):
        texture.has_been_destroyed = True # as this is managed by the framebuffer
        CGL_framebuffer_add_color_attachment(self.c_framebuffer, tex.c_texture)
    
    def get_color_attacment(self, index: int) -> texture:
        cdef CGL_texture* c_texture = CGL_framebuffer_get_color_attachment(self.c_framebuffer, index)
        if c_texture == NULL:
            raise RuntimeError("Failed to get color attachment")
        res = texture()
        res.set_c_texture(c_texture)
        res.has_been_destroyed = True # as this is managed by the framebuffer
        return res
    
    def bind(self):
        CGL_framebuffer_bind(self.c_framebuffer)

    def set_user_data(self, data: object):
        CGL_framebuffer_set_user_data(self.c_framebuffer, <void*>data)
    
    def get_user_data(self) -> object:
        return <object>CGL_framebuffer_get_user_data(self.c_framebuffer)
    
    def read_pixels(self, x: int, y: int, width: int, height: int) -> bytes:
        cdef CGL_int size = width * height * 4
        cdef void* data = stdlib.malloc(size)
        CGL_framebuffer_read_pixels(self.c_framebuffer, x, y, width, height, data)
        temp = <bytes>data
        res = copy.deepcopy(temp)
        stdlib.free(data)
        return res

    def get_mouse_pick_id(self, x: int, y: int, index: int) -> int:
        return CGL_framebuffer_get_mouse_pick_id(self.c_framebuffer, x, y, index)
    
    def get_color_texture(self) -> texture:
        cdef CGL_texture* c_texture = CGL_framebuffer_get_color_texture(self.c_framebuffer)
        if c_texture == NULL:
            raise RuntimeError("Failed to get color texture")
        res = texture()
        res.set_c_texture(c_texture)
        res.has_been_destroyed = True # as this is managed by the framebuffer
        return res

    def get_depth_texture(self) -> texture:
        cdef CGL_texture* c_texture = CGL_framebuffer_get_depth_texture(self.c_framebuffer)
        if c_texture == NULL:
            raise RuntimeError("Failed to get depth texture")
        res = texture()
        res.set_c_texture(c_texture)
        res.has_been_destroyed = True # as this is managed by the framebuffer
        return res

def framebuffer_create_from_default(wnd: window) -> framebuffer:
    cdef CGL_framebuffer* c_framebuffer = CGL_framebuffer_create_from_default(wnd.c_window)
    if c_framebuffer == NULL:
        raise RuntimeError("Failed to create framebuffer from default")
    res = framebuffer()
    res.set_c_framebuffer(c_framebuffer)
    return res

def framebuffer_create(width: int, height: int) -> framebuffer:
    cdef CGL_framebuffer* c_framebuffer = CGL_framebuffer_create(width, height)
    if c_framebuffer == NULL:
        raise RuntimeError("Failed to create framebuffer")
    res = framebuffer()
    res.set_c_framebuffer(c_framebuffer)
    return res

def framebuffer_create_basic(width: int, height: int) -> framebuffer:
    cdef CGL_framebuffer* c_framebuffer = CGL_framebuffer_create_basic(width, height)
    if c_framebuffer == NULL:
        raise RuntimeError("Failed to create basic framebuffer")
    res = framebuffer()
    res.set_c_framebuffer(c_framebuffer)
    return res

def gl_clear(r: float, g: float, b: float, a: float):
    CGL_gl_clear(r, g, b, a)

def gl_init() -> bool:
    return CGL_gl_init()

def gl_shutdown():
    CGL_gl_shutdown()

def gl_render_screen_quad():
    CGL_gl_render_screen_quad()

cdef class mesh_gpu:
    cdef CGL_mesh_gpu* c_mesh
    cdef bool has_been_destroyed
    cdef str name

    @property
    def name(self):
        return self.name

    def __init__(self, name: str = "GPU Mesh"):
        self.c_mesh = CGL_mesh_gpu_create()
        self.has_been_destroyed = False
        self.name = name
    
    def __dealloc__(self):
        self.destroy()
    
    def __repr__(self):
        return f"mesh_gpu({self.name})"
    
    def __str__(self):  
        return f"mesh_gpu({self.name})"
    
    def __hash__(self):
        return self.get_id()
    
    def destroy(self):
        if not self.has_been_destroyed:
            CGL_mesh_gpu_destroy(self.c_mesh)
            self.has_been_destroyed = True
    
    cdef set_c_mesh(self, CGL_mesh_gpu* c_mesh):
        if not self.has_been_destroyed:
            self.destroy()
        self.c_mesh = c_mesh
        self.has_been_destroyed = False
    
    def get_id(self) -> int:
        return CGL_utils_super_fast_hash(&self.c_mesh, sizeof(CGL_mesh_gpu*))
    
    def render(self):
        CGL_mesh_gpu_render(self.c_mesh)
    
    def render_instanced(self, count: int):
        CGL_mesh_gpu_render_instanced(self.c_mesh, count)
    
    def set_user_data(self, data: object):
        CGL_mesh_gpu_set_user_data(self.c_mesh, <void*>data)
    
    def get_user_data(self) -> object:
        return <object>CGL_mesh_gpu_get_user_data(self.c_mesh)
    
    def upload_mesh_cpu(self, mesh: mesh_cpu, static_draw: bool = True):
        CGL_mesh_gpu_upload(self.c_mesh, mesh.c_mesh, static_draw)
    

cdef class shader:
    cdef CGL_shader* c_shader
    cdef bool has_been_destroyed
    cdef str name
    cdef dict uniform_map

    @property
    def name(self):
        return self.name

    def __init__(self, name: str = "Shader"):
        self.has_been_destroyed = True
        self.name = name
        self.uniform_map = {}
    
    def __dealloc__(self):
        self.destroy()
    
    def __repr__(self):
        return f"shader({self.name})"
    
    def __str__(self):  
        return f"shader({self.name})"
    
    def __hash__(self):
        return self.get_id()
    
    def destroy(self):
        if not self.has_been_destroyed:
            CGL_shader_destroy(self.c_shader)
            self.has_been_destroyed = True
        self.uniform_map = {}
    
    cdef set_c_shader(self, CGL_shader* c_shader):
        if not self.has_been_destroyed:
            self.destroy()
        self.c_shader = c_shader
        self.has_been_destroyed = False
    
    def get_id(self) -> int:
        return CGL_utils_super_fast_hash(&self.c_shader, sizeof(CGL_shader*))
    
    def set_user_data(self, data: object):
        CGL_shader_set_user_data(self.c_shader, <void*>data)
    
    def get_user_data(self) -> object:
        return <object>CGL_shader_get_user_data(self.c_shader)
    
    def load_from_file(self, vertex_shader_path: str, fragment_shader_path: str) -> bool:
        cdef CGL_shader* c_shader = CGL_shader_create_from_files(vertex_shader_path.encode("utf-8"), fragment_shader_path.encode("utf-8"), NULL)
        if c_shader == NULL:
            raise RuntimeError("Failed to create shader")
        self.set_c_shader(c_shader)
        has_been_destroyed = False
        return True
    
    def load(self, vertex_shader_source: str, fragment_shader_source: str) -> bool:
        cdef CGL_shader* c_shader = CGL_shader_create(vertex_shader_source.encode("utf-8"), fragment_shader_source.encode("utf-8"), NULL)
        if c_shader == NULL:
            raise RuntimeError("Failed to create shader")
        self.set_c_shader(c_shader)
        has_been_destroyed = False
        return True
    
    def load_compute_from_file(self, compute_shader_path: str) -> bool:
        cdef CGL_shader* c_shader = CGL_shader_compute_create_from_files(compute_shader_path.encode("utf-8"), NULL)
        if c_shader == NULL:
            raise RuntimeError("Failed to create shader")
        self.set_c_shader(c_shader)
        has_been_destroyed = False
        return True
    
    def load_compute(self, compute_shader_source: str) -> bool:
        cdef CGL_shader* c_shader = CGL_shader_compute_create(compute_shader_source.encode("utf-8"), NULL)
        if c_shader == NULL:
            raise RuntimeError("Failed to create shader")
        self.set_c_shader(c_shader)
        has_been_destroyed = False
        return True

    def bind(self):
        CGL_shader_bind(self.c_shader)
    
    def get_uniform_location(self, name: str) -> int:
        if name in self.uniform_map:
            return self.uniform_map[name]
        cdef int location = CGL_shader_get_uniform_location(self.c_shader, name.encode("utf-8"))
        self.uniform_map[name] = location
        return location
    
    def set_uniform_mat4(self, name: str, mat: mat4):
        CGL_shader_set_uniform_mat4(self.c_shader, self.get_uniform_location(name), &mat.c_mat4)
    
    def set_uniform_vec4(self, name: str, vec: vec4):
        CGL_shader_set_uniform_vec4(self.c_shader, self.get_uniform_location(name), &vec.c_vec4)
    
    def set_uniform_vec3(self, name: str, vec: vec3):
        CGL_shader_set_uniform_vec3(self.c_shader, self.get_uniform_location(name), &vec.c_vec3)
    
    def set_uniform_vec2(self, name: str, vec: vec2):
        CGL_shader_set_uniform_vec2(self.c_shader, self.get_uniform_location(name), &vec.c_vec2)    
    
    def set_uniform_float(self, name: str, value: float):
        CGL_shader_set_uniform_float(self.c_shader, self.get_uniform_location(name), value)
    
    def set_uniform_int(self, name: str, value: int):
        CGL_shader_set_uniform_int(self.c_shader, self.get_uniform_location(name), value)
    
    def set_uniform_bool(self, name: str, value: bool):
        CGL_shader_set_uniform_bool(self.c_shader, self.get_uniform_location(name), value)
    
    def set_uniform_doublt(self, name: str, value: double):
        CGL_shader_set_uniform_double(self.c_shader, self.get_uniform_location(name), value)
    
    def set_uniform_vec2v(self, name: str, x: float, y: float):
        CGL_shader_set_uniform_vec2v(self.c_shader, self.get_uniform_location(name), x, y)
    
    def set_uniform_vec3v(self, name: str, x: float, y: float, z: float):
        CGL_shader_set_uniform_vec3v(self.c_shader, self.get_uniform_location(name), x, y, z)
    
    def set_uniform_vec4v(self, name: str, x: float, y: float, z: float, w: float):
        CGL_shader_set_uniform_vec4v(self.c_shader, self.get_uniform_location(name), x, y, z, w)
    
    def set_uniform_ivec2v(self, name: str, x: int, y: int):
        CGL_shader_set_uniform_ivec2v(self.c_shader, self.get_uniform_location(name), x, y)
    
    def set_uniform_ivec3v(self, name: str, x: int, y: int, z: int):
        CGL_shader_set_uniform_ivec3v(self.c_shader, self.get_uniform_location(name), x, y, z)
    
    def set_uniform_ivec4v(self, name: str, x: int, y: int, z: int, w: int):
        CGL_shader_set_uniform_ivec4v(self.c_shader, self.get_uniform_location(name), x, y, z, w)   
    
    def compute_dispatch(self, x: int, y: int, z: int):
        CGL_shader_compute_dispatch(self.c_shader, x, y, z)

cdef class ssbo:
    cdef CGL_ssbo* c_ssbo
    cdef bool has_been_destroyed

    @property
    def size(self) -> int:
        return CGL_ssbo_get_size(self.c_ssbo)

    def __init__(self):
        self.c_ssbo = CGL_ssbo_create(0)
        self.has_been_destroyed = False
    
    def __dealloc__(self):
        if not self.has_been_destroyed:
            self.destroy()

    def __repr__(self):
        return f"ssbo({self.get_id()})"
    
    def __str__(self):
        return f"ssbo({self.get_id()})"
    
    def __hash__(self):
        return self.get_id()
    
    def bind(self):
        CGL_ssbo_bind(self.c_ssbo)
    
    def bind_base(self, index: int):
        CGL_ssbo_bind2(self.c_ssbo, index)
    
    def set_data(self, data: bytes, static_draw: bool = True):
        CGL_ssbo_set_data(self.c_ssbo, len(data), <void*>data,  static_draw)
    
    def set_sub_data(self, data: bytes, offset: int, static_draw: bool = True):
        CGL_ssbo_set_sub_data(self.c_ssbo, offset, len(data), <void*>data, static_draw)

    def get_data(self, max_size = 100000000) -> bytes:
        cdef size_t size
        cdef void* buff = stdlib.malloc(max_size)
        CGL_ssbo_get_data(self.c_ssbo, &size, buff)
        byts = <bytes>buff
        result = copy.deepcopy(byts)
        stdlib.free(buff)
        return result
    
    def get_sub_data(self, offset: int, size) -> bytes:
        cdef void* buff = stdlib.malloc(size)
        CGL_ssbo_get_sub_data(self.c_ssbo, offset, size, buff)
        byts = <bytes>buff
        result = copy.deepcopy(byts)
        stdlib.free(buff)
        return result
    
    def get_size(self) -> int:
        return CGL_ssbo_get_size(self.c_ssbo)
    
    def set_user_data(self, data):
        CGL_ssbo_set_user_data(self.c_ssbo, <void*>data)
    
    def get_user_data(self) -> object:
        return <object>CGL_ssbo_get_user_data(self.c_ssbo)

    def get_id(self) -> int:
        return CGL_utils_super_fast_hash(&self.c_ssbo, sizeof(CGL_ssbo*))
    

    def destroy(self):
        if not self.has_been_destroyed:
            CGL_ssbo_destroy(self.c_ssbo)
            self.has_been_destroyed = True
    
def ssbo_copy(dst: ssbo, src: ssbo, src_offset: int, dst_offset: int, size: int):
    CGL_ssbo_copy(dst.c_ssbo, src.c_ssbo, src_offset, dst_offset, size)

cdef class ubo:
    cdef CGL_ubo* c_ubo
    cdef bool has_been_destroyed

    @property
    def size(self) -> int:
        return CGL_ubo_get_size(self.c_ubo)
    
    def __init__(self):
        self.c_ubo = CGL_ubo_create()
        self.has_been_destroyed = False
    
    def __dealloc__(self):
        self.destroy()
    
    def __repr__(self):
        return f"ubo({self.get_id()})"
    
    def __str__(self):
        return f"ubo({self.get_id()})"
    
    def __hash__(self):
        return self.get_id()
    
    def destroy(self):
        if not self.has_been_destroyed:
            CGL_ubo_destroy(self.c_ubo)
            self.has_been_destroyed = True

    def bind(self, shd: shader, name: str, binding: int):
        CGL_ubo_bind(self.c_ubo, shd.c_shader, name.encode("utf-8"), binding)
    
    def set_data(self, data: bytes, static_draw: bool = True):
        CGL_ubo_set_data(self.c_ubo, len(data), <void*>data, static_draw)
    
    def set_sub_data(self, offset: int, data: bytes, static_draw: bool = True):
        CGL_ubo_set_sub_data(self.c_ubo, offset, len(data), <void*>data, static_draw)
    
    def get_data(self, max_size: int = 100000000) -> bytes:
        cdef size_t size
        cdef void* buff = stdlib.malloc(max_size)
        CGL_ubo_get_data(self.c_ubo, &size, buff)
        byts = <bytes>buff
        result = copy.deepcopy(byts)
        stdlib.free(buff)
        return result
    
    def get_sub_data(self, offset: int, size: int) -> bytes:
        cdef void* buff = stdlib.malloc(size)
        CGL_ubo_get_sub_data(self.c_ubo, offset, size, buff)
        byts = <bytes>buff
        result = copy.deepcopy(byts)
        stdlib.free(buff)
        return result
    
    def get_size(self) -> int:
        return CGL_ubo_get_size(self.c_ubo)
    
    def set_user_data(self, data: object):
        CGL_ubo_set_user_data(self.c_ubo, <void*>data)
    
    def get_user_data(self) -> object:
        return <object>CGL_ubo_get_user_data(self.c_ubo)
    
    def get_id(self) -> int:
        return CGL_utils_super_fast_hash(&self.c_ubo, sizeof(CGL_ubo*))


cdef class shape:
    cdef CGL_shape c_shape

    @property
    def vertices_count(self) -> int:
        return self.c_shape.vertices_count
    
    @property
    def vertices(self) -> list:
        result = []
        for i in range(self.vertices_count):
            result.append(vec3(self.c_shape.vertices[i].x, self.c_shape.vertices[i].y, self.c_shape.vertices[i].z))
        return result
    
    @property
    def position(self) -> vec3:
        return vec3(self.c_shape.position.x, self.c_shape.position.y, self.c_shape.position.z)
    
    @position.setter
    def position(self, value: vec3):
        self.c_shape.position.x = value.x
        self.c_shape.position.y = value.y
        self.c_shape.position.z = value.z
    
    @property
    def rotation(self) -> vec3:
        return vec3(self.c_shape.rotation.x, self.c_shape.rotation.y, self.c_shape.rotation.z)
    
    @rotation.setter
    def rotation(self, value: vec3):
        self.c_shape.rotation.x = value.x
        self.c_shape.rotation.y = value.y
        self.c_shape.rotation.z = value.z
    
    @property
    def scale(self) -> vec3:
        return vec3(self.c_shape.scale.x, self.c_shape.scale.y, self.c_shape.scale.z)
    
    @scale.setter
    def scale(self, value: vec3):
        self.c_shape.scale.x = value.x
        self.c_shape.scale.y = value.y
        self.c_shape.scale.z = value.z

    def __init__(self, vertices_count: int):
        CGL_shape_init(&self.c_shape, vertices_count)
    
    def __dealloc__(self):
        CGL_shape_destroy(&self.c_shape)
    
    def __repr__(self):
        return f"shape({self.vertices_count}, {self.position}, {self.rotation}, {self.scale})"
    
    def __str__(self):
        return f"shape({self.vertices_count}, {self.position}, {self.rotation}, {self.scale})"
    
    def __getitem__(self, index: int) -> vec3:
        return vec3(self.c_shape.vertices[index].x, self.c_shape.vertices[index].y, self.c_shape.vertices[index].z)
    
    def __setitem__(self, index: int, value: vec3):
        self.c_shape.vertices[index].x = value.x
        self.c_shape.vertices[index].y = value.y
        self.c_shape.vertices[index].z = value.z
    
    def __len__(self):
        return self.vertices_count

def sat_collison_overlap_on_axis(a: shape, b: shape, axis: vec2) -> (bool, float):
    cdef float overlap_amount
    result = CGL_sat_collision_overlap_on_axis(&a.c_shape, &b.c_shape, axis.c_vec2, &overlap_amount)
    return (result, overlap_amount)

def  sat_collision_detect(a: shape, b: shape) -> tuple:
    n_vector = vec2(0, 0)
    result = CGL_sat_collision_detect(&a.c_shape, &b.c_shape, &n_vector.c_vec2)
    return (result, n_vector)

def sat_collision_calculate_axes(a: shape, max_axes: int = 10000) -> list:
    cdef int axes_count
    cdef CGL_vec2* axes = <CGL_vec2*>stdlib.malloc(max_axes * sizeof(CGL_vec2))
    CGL_sat_collision_calculate_axes(&a.c_shape, axes, &axes_count)
    result = []
    for i in range(axes_count):
        result.append(vec2(axes[i].x, axes[i].y))
    stdlib.free(axes)
    return result

def is_point_in_circle(point: vec2, circle_radius: float) -> bool:
    return CGL_utils_is_point_in_circle(point.c_vec2, circle_radius)

def is_point_in_triangle(point: vec2, a: vec2, b: vec2, c: vec2) -> bool:
    return CGL_utils_is_point_in_triangle(point.c_vec2, a.c_vec2, b.c_vec2, c.c_vec2)

def calculate_circumcircle(a: vec2, b: vec2, c: vec2) -> tuple:
    center = vec2(0, 0)
    cdef float f_radius = 0
    CGL_utils_calculate_circumcircle(a.c_vec2, b.c_vec2, c.c_vec2, &center.c_vec2, &f_radius)
    return (center, f_radius)

def calculate_super_triangle(vertices: list, padding: float) -> tuple:
    cdef CGL_vec2* c_vertices = <CGL_vec2*>stdlib.malloc(len(vertices) * sizeof(CGL_vec2))
    for i in range(len(vertices)):
        c_vertices[i].x = vertices[i].x
        c_vertices[i].y = vertices[i].y
    r_a = vec2(0, 0)
    r_b = vec2(0, 0)
    r_c = vec2(0, 0)
    CGL_utils_calculate_super_triangle(c_vertices, len(vertices), &r_a.c_vec2, &r_b.c_vec2, &r_c.c_vec2, padding)
    stdlib.free(c_vertices)
    return (r_a, r_b, r_c)

def calculate_bounding_square(vertices: list, padding: float) -> tuple:
    cdef CGL_vec2* c_vertices = <CGL_vec2*>stdlib.malloc(len(vertices) * sizeof(CGL_vec2))
    for i in range(len(vertices)):
        c_vertices[i].x = vertices[i].x
        c_vertices[i].y = vertices[i].y
    r_a = vec2(0, 0)
    r_b = vec2(0, 0)
    r_c = vec2(0, 0)
    r_d = vec2(0, 0)
    CGL_utils_calculate_bounding_square(c_vertices, len(vertices), &r_a.c_vec2, &r_b.c_vec2, &r_c.c_vec2, &r_d.c_vec2, padding)
    stdlib.free(c_vertices)
    return (r_a, r_b, r_c, r_d)

def calculate_bounding_box(vertices: list, padding: float) -> tuple:
    cdef CGL_vec2* c_vertices = <CGL_vec2*>stdlib.malloc(len(vertices) * sizeof(CGL_vec2))
    for i in range(len(vertices)):
        c_vertices[i].x = vertices[i].x
        c_vertices[i].y = vertices[i].y
    r_a = vec2(0, 0)
    r_b = vec2(0, 0)
    r_c = vec2(0, 0)
    r_d = vec2(0, 0)
    CGL_utils_calculate_bounding_box(c_vertices, len(vertices), &r_a.c_vec2, &r_b.c_vec2, &r_c.c_vec2, &r_d.c_vec2, padding)
    stdlib.free(c_vertices)
    return (r_a, r_b, r_c, r_d)

def random_gaussian(mean: float, std_dev: float) -> float:
    return CGL_utils_random_gaussian(mean, std_dev)

def gjk_shape_default_support(a: shape, d: vec3) -> vec3:
    return CGL_gjk_shape_default_support(&a.c_shape, d.c_vec3)

def gjk_default_support(a: shape, b: shape, d: vec3) -> vec3:
    return CGL_gjk_default_support(&a.c_shape, &b.c_shape, d.c_vec3)

def gjk_check_collision_2d(a: shape, b: shape) -> tuple:
    cdef CGL_vec3* simplex_out_ptr = <CGL_vec3*>stdlib.malloc(sizeof(CGL_vec3) * 3)
    result = CGL_gjk_check_collision_2d(&a.c_shape, &b.c_shape, simplex_out_ptr)
    simplex_out = []
    for i in range(3):
        simplex_out.append(vec3(simplex_out_ptr[i].x, simplex_out_ptr[i].y, simplex_out_ptr[i].z))
    stdlib.free(simplex_out_ptr)
    return (result, simplex_out)

def gjk_epa_2d(a: shape, b: shape, simplex: list) ->  vec3:
    cdef CGL_vec3* simplex_ptr = <CGL_vec3*>stdlib.malloc(sizeof(CGL_vec3) * 3)
    for i in range(3):
        simplex_ptr[i].x = simplex[i].x
        simplex_ptr[i].y = simplex[i].y
        simplex_ptr[i].z = simplex[i].z
    result = CGL_gjk_epa_2d(&a.c_shape, &b.c_shape, simplex_ptr)
    stdlib.free(simplex_ptr)
    return vec3(result.x, result.y, result.z)

def aabb_contains_point(aabb_min: vec2, aabb_max: vec2, point: vec2) -> bool:
    return CGL_aabb_contains_point(aabb_min.c_vec2, aabb_max.c_vec2, point.c_vec2)

def aabb_intersects_aabb(aabb_min_a: vec2, aabb_max_a: vec2, aabb_min_b: vec2, aabb_max_b: vec2) -> bool:
    return CGL_aabb_intersects_aabb(aabb_min_a.c_vec2, aabb_max_a.c_vec2, aabb_min_b.c_vec2, aabb_max_b.c_vec2)

def triangulate_points_incremental(points: list) -> list:
    cdef CGL_vec2* c_points = <CGL_vec2*>stdlib.malloc(len(points) * sizeof(CGL_vec2))
    for i in range(len(points)):
        c_points[i].x = points[i].x
        c_points[i].y = points[i].y
    cdef int* c_indices = <int*>stdlib.malloc(len(points) * sizeof(int) * 3)
    cdef int c_num_indices = 0
    CGL_triangulate_points_incremental(c_points, len(points), c_indices, &c_num_indices)
    indices = []
    for i in range(c_num_indices / 3):
        indices.append((c_indices[i * 3], c_indices[i * 3 + 1], c_indices[i * 3 + 2]))
    stdlib.free(c_points)
    stdlib.free(c_indices)
    return indices

BLOOM_SHADER_MODE_PREFILTER    = 0
BLOOM_SHADER_MODE_DOWNSAMPLE   = 1
BLOOM_SHADER_MODE_UPSAMPLE     = 2
BLOOM_SHADER_MODE_COMPOSITE    = 3

cdef class bloom:
    cdef CGL_bloom* c_bloom
    cdef int width
    cdef int height
    cdef int iterations

    @property
    def width(self):
        return self.width
    
    @property
    def height(self):
        return self.height
    
    @property
    def iterations(self):
        return self.iterations
    

    @property
    def threshold(self):
        return CGL_bloom_get_threshold(self.c_bloom)
    
    @threshold.setter
    def threshold(self, threshold: float):
        CGL_bloom_set_threshold(self.c_bloom, threshold)
    
    @property
    def knee(self):
        return CGL_bloom_get_knee(self.c_bloom)
    
    @knee.setter
    def knee(self, knee: float):
        CGL_bloom_set_knee(self.c_bloom, knee)

    def __init__(self, width: int, height: int, iterations: int):
        self.c_bloom = CGL_bloom_create(width, height, iterations)
        self.width = width
        self.height = height
        self.iterations = iterations
    
    def __dealloc__(self):
        CGL_bloom_destroy(self.c_bloom)
    
    def __repr__(self):
        return f"bloom({self.width}, {self.height}, {self.iterations})"
    
    def __str__(self):
        return f"bloom({self.width}, {self.height}, {self.iterations})"
    
    def __hash__(self):
        return CGL_utils_super_fast_hash(<void*>self.c_bloom, sizeof(CGL_bloom*))

    def set_threshold(self, threshold: float):
        CGL_bloom_set_threshold(self.c_bloom, threshold)
    
    def get_threshold(self) -> float:
        return CGL_bloom_get_threshold(self.c_bloom)
    
    def set_knee(self, knee: float):
        CGL_bloom_set_knee(self.c_bloom, knee)
    
    def get_knee(self) -> float:
        return CGL_bloom_get_knee(self.c_bloom)
    
    def set_offset(self, offset_x: float, offset_y: float):
        CGL_bloom_set_offset(self.c_bloom, offset_x, offset_y)

    def apply(self, tex: texture):
        CGL_bloom_apply(self.c_bloom, tex.c_texture)
    
    def apply2(self, texture_src: texture, texture_dst: texture):
        CGL_bloom_apply2(self.c_bloom, texture_src.c_texture, texture_dst.c_texture)
    
    def get_lod_texture(self, lod: int) -> texture:
        result = texture()
        result.set_c_texture(CGL_bloom_get_lod_texture(self.c_bloom, lod))
        # this is a hack to prevent the texture from 
        # being destroyed when the result goes out of scope
        # as this texture object is managed by the bloom object
        result.has_been_destroyed = True
        return result
    
    def get_prefiltered_texture(self) -> texture:
        result = texture()
        result.set_c_texture(CGL_bloom_get_prefiltered_texture(self.c_bloom))
        # this is a hack to prevent the texture from 
        # being destroyed when the result goes out of scope
        # as this texture object is managed by the bloom object
        result.has_been_destroyed = True
        return result
    
cdef class tilemap:
    cdef CGL_tilemap* c_tilemap
    cdef int tile_count_x
    cdef int tile_count_y
    cdef int tile_size_x
    cdef int tile_size_y
    cdef int ssbo_binding

    @property
    def tile_count_x(self):
        return self.tile_count_x
    
    @property
    def tile_count_y(self):
        return self.tile_count_y
    
    @property
    def tile_size_x(self):
        return self.tile_size_x
    
    @property
    def tile_size_y(self):
        return self.tile_size_y
    
    @property
    def ssbo_binding(self):
        return self.ssbo_binding
    
    @property
    def auto_upload(self):
        return self.get_auto_upload()

    @auto_upload.setter
    def auto_upload(self, auto_upload: bool):
        self.set_auto_upload(auto_upload)

    def __init__(self, tile_count_x: int, tile_count_y: int, tile_size_x: int, tile_size_y: int, ssbo_binding: int):
        self.c_tilemap = CGL_tilemap_create(tile_count_x, tile_count_y, tile_size_x, tile_size_y, ssbo_binding)
        self.tile_count_x = tile_count_x
        self.tile_count_y = tile_count_y
        self.tile_size_x = tile_size_x
        self.tile_size_y = tile_size_y
        self.ssbo_binding = ssbo_binding
    
    def __dealloc__(self):
        CGL_tilemap_destroy(self.c_tilemap)
    
    def __repr__(self):
        return f"tilemap({self.tile_count_x}, {self.tile_count_y}, {self.tile_size_x}, {self.tile_size_y}, {self.ssbo_binding})"
    
    def __str__(self):
        return f"tilemap({self.tile_count_x}, {self.tile_count_y}, {self.tile_size_x}, {self.tile_size_y}, {self.ssbo_binding})"
    
    def __hash__(self):
        return CGL_utils_super_fast_hash(<void*>self.c_tilemap, sizeof(CGL_tilemap*))
    
    def set_auto_upload(self, auto_upload: bool):
        CGL_tilemap_set_auto_upload(self.c_tilemap, auto_upload)
    
    def get_auto_upload(self) -> bool:
        return CGL_tilemap_get_auto_upload(self.c_tilemap)
    
    def upload(self):
        CGL_tilemap_upload(self.c_tilemap)
    
    def set_tile_color(self, tile_x: int, tile_y: int, r: float, g: float, b: float):
        CGL_tilemap_set_tile_color(self.c_tilemap, tile_x, tile_y, r, g, b)
    
    def set_tile_texture_from_array(self, tile_x: int, tile_y: int, texture_index: int):
        CGL_tilemap_set_tile_texture_from_array(self.c_tilemap, tile_x, tile_y, texture_index)
    
    def set_tile_texture_from_tileset(self, tile_x: int, tile_y: int, texture_x_min: float, texture_y_min: float, texture_x_max: float, texture_y_max: float):
        CGL_tilemap_set_tile_texture_from_tileset(self.c_tilemap, tile_x, tile_y, texture_x_min, texture_y_min, texture_x_max, texture_y_max)
    
    def set_all_tile_color(self, r: float, g: float, b: float):
        CGL_tilemap_set_all_tile_color(self.c_tilemap, r, g, b)
    
    def set_all_tile_texture_from_array(self, texture_index: int):
        CGL_tilemap_set_all_tile_texture_from_array(self.c_tilemap, texture_index)

    def set_all_tile_texture_from_tileset(self, texture_x_min: float, texture_y_min: float, texture_x_max: float, texture_y_max: float):
        CGL_tilemap_set_all_tile_texture_from_tileset(self.c_tilemap, texture_x_min, texture_y_min, texture_x_max, texture_y_max)
    
    def clear_tile(self, tile_x: int, tile_y: int):
        CGL_tilemap_clear_tile(self.c_tilemap, tile_x, tile_y)
    
    def clear_all_tile(self):
        CGL_tilemap_clear_all_tile(self.c_tilemap)
    
    def render(self, scale_x: float, scale_y: float, offset_x: float, offset_y: float, tex: texture = None):
        cdef CGL_texture* c_tex = NULL
        if tex is not None:
            c_tex = tex.c_texture
        CGL_tilemap_render(self.c_tilemap, scale_x, scale_y, offset_x, offset_y, c_tex)
    
    def reset(self):
        CGL_tilemap_reset(self.c_tilemap)
    
cdef class font_character:
    cdef CGL_font_character c_font_character

    @property
    def size(self) -> vec2:
        return vec2(self.c_font_character.size.x, self.c_font_character.size.y)
    
    @property
    def bearing(self) -> vec2:
        return vec2(self.c_font_character.bearing.x, self.c_font_character.bearing.y)
    
    @property
    def advance(self) -> vec2:
        return vec2(self.c_font_character.advance.x, self.c_font_character.advance.y)
    
    @property
    def normalized_size(self) -> vec2:
        return vec2(self.c_font_character.normalized_size.x, self.c_font_character.normalized_size.y)
    
    @property
    def normalized_offset(self) -> vec2:
        return vec2(self.c_font_character.normalized_offset.x, self.c_font_character.normalized_offset.y)
    
    @property
    def bearing_normalized(self) -> vec2:
        return vec2(self.c_font_character.bearing_normalized.x, self.c_font_character.bearing_normalized.y)

    @property
    def advance_normalized(self) -> vec2:
        return vec2(self.c_font_character.advance_normalized.x, self.c_font_character.advance_normalized.y)
    
    @property
    def character(self) -> char:
        return self.c_font_character.ch
    
    def __init__(self, CGL_font_character c_font_character):
        self.c_font_character = c_font_character
    
    def __repr__(self):
        return f"font_character({self.c_font_character})"
    
    def __str__(self):
        return f"font_character({self.c_font_character})"
    
    def __hash__(self):
        return self.c_font_character.ch
    
cdef class font:
    cdef CGL_font* c_font
    cdef bool has_been_destroyed
    cdef str meta_data

    def __init__(self):
        self.c_font = NULL
        self.has_been_destroyed = True
        self.meta_data = "not_loaded"
    
    def __dealloc__(self):
        self.destroy()
    
    def destroy(self):
        if not self.has_been_destroyed:
            CGL_font_destory(self.c_font)
            self.has_been_destroyed = True
        self.meta_data = "not_loaded"
    
    
    def load_from_memory(self, data: bytes):
        self.has_been_destroyed = False
        self.c_font = CGL_font_load_from_memory(data, len(data))
        self.meta_data = "memory_font"
    
    def load(self, path: str):
        self.has_been_destroyed = False
        self.c_font = CGL_font_load(path.encode("utf-8"))
        self.meta_data = str(f"file_font{path}")
    
    def get_atlas(self) -> texture:
        result = texture()
        result.set_c_texture(CGL_font_get_atlas(self.c_font))
        result.has_been_destroyed = True
        return result
    
    def build_atlas(self, width: int, height: int, font_size: int) -> bool:
        return CGL_font_build_atlas(self.c_font, width, height, font_size)
    
    def bake_to_texture(self, strng: str) -> tuple:
        result_tex = texture()
        cdef size_t width
        cdef size_t height
        result_tex.set_c_texture(CGL_text_bake_to_texture(strng.encode("utf-8"), len(strng), self.c_font, &width, &height))
        return (result_tex, width, height)
    
    def get_characters(self):
        cdef CGL_font_character* c_font_characters
        cdef list result = []
        c_font_characters = CGL_font_get_characters(self.c_font)
        for i in range(127):
            result.append(font_character(c_font_characters[i]))
        return result


def text_init() -> bool:
    return CGL_text_init()

def text_shutdown():
    CGL_text_shutdown()

   
cdef class widgets:

    def __init__(self):
        raise RuntimeError("widgets is a static class")

    @staticmethod
    def create_context(max_vertices: int, max_indices: int) -> object:
        return <object>CGL_widgets_context_create(max_vertices, max_indices)
    
    @staticmethod
    def destroy_context(ctx: object):
        CGL_widgets_context_destory(<CGL_widgets_context*>ctx)
    
    @staticmethod
    def get_current_context() -> object:
        # NOTE: this is a type in the original C code,
        #       not some kind of a bug here
        #       and will be later fixed
        return <object>CGL_window_get_current_context()
    
    @staticmethod
    def set_current_context(ctx: object):
        # NOTE: this is a type in the original C code,
        #       not some kind of a bug here
        #       and will be later fixed
        CGL_window_set_current_context(<CGL_widgets_context*>ctx)
    
    @staticmethod
    def init():
        CGL_widgets_init()
    
    @staticmethod
    def shutdown():
        CGL_widgets_shutdown()
    
    @staticmethod
    def begin():
        CGL_widgets_begin()
    
    @staticmethod
    def begin_int(scale_x: float, scale_y: float, offset_x: float, offset_y: float):
        CGL_widgets_begin_int(scale_x, scale_y, offset_x, offset_y)

    @staticmethod
    def end():
        CGL_widgets_end()

    @staticmethod
    def flush():
        CGL_widgets_flush()
    
    @staticmethod
    def flush_if_required():
        CGL_widgets_flush_if_required()
    
    @staticmethod
    def add_vertex(v: mesh_vertex):
        CGL_widgets_add_vertex(&v.c_vertex)
    
    @staticmethod
    def add_mesh(m: mesh_cpu):
        CGL_widgets_add_mesh(m.c_mesh)
    
    @staticmethod
    def add_vertex_p(v: vec3):
        CGL_widgets_add_vertex_p(v.c_vec3)
    
    @staticmethod
    def add_vertex_p3f(x: float, y: float, z: float):
        CGL_widgets_add_vertex_p3f(x, y, z)
    
    @staticmethod
    def add_vertex_pt(v: vec3, t: vec2):
        CGL_widgets_add_vertex_pt(v.c_vec3, t.c_vec2)
    
    @staticmethod
    def add_vertex_p3ft(x: float, y: float, z: float, t: vec2):
        CGL_widgets_add_vertex_p3ft(x, y, z, t.c_vec2)
    
    @staticmethod
    def add_vertex_pt2f(v: vec3, t0: float, t1: float):
        CGL_widgets_add_vertex_pt2f(v.c_vec3, t0, t1)
    
    @staticmethod
    def add_vertex_p3ft2f(x: float, y: float, z: float, u: float, v: float):
        CGL_widgets_add_vertex_p3ft2f(x, y, z, u, v)
    
    @staticmethod
    def set_stroke_color(c: vec4):
        CGL_widgets_set_stroke_color(c.c_vec4)
    
    @staticmethod
    def set_stroke_colorf(r: float, g: float, b: float, a: float = 1.0):
        CGL_widgets_set_stroke_colorf(r, g, b, a)

    @staticmethod
    def set_stroke_thickness(t: float):
        CGL_widgets_set_stroke_thicnkess(t)
    
    @staticmethod
    def set_fill_color(c: vec4):
        CGL_widgets_set_fill_color(c.c_vec4)
    
    @staticmethod
    def set_fill_colorf(r: float, g: float, b: float, a: float = 1.0):
        CGL_widgets_set_fill_colorf(r, g, b, a)
    
    @staticmethod
    def set_fill_mode(enebled: bool):
        CGL_widgets_set_fill_mode(enebled)
    
    @staticmethod
    def set_projection_matrix(m: mat4):
        CGL_widgets_set_projection_matrix(&m.c_mat4)
    
    @staticmethod
    def enable_diffuse_shading(light_pos: vec3, light_color: vec3):
        CGL_widgets_enable_diffuse_shading(light_pos.c_vec3, light_color.c_vec3)
    
    @staticmethod
    def disable_diffuse_shading():
        CGL_widgets_disable_diffuse_shading()
    
    @staticmethod
    def set_view_matrix(m: mat4):
        CGL_widgets_set_view_matrix(&m.c_mat4)
    
    @staticmethod
    def set_model_matrix(m: mat4):
        CGL_widgets_set_model_matrix(&m.c_mat4)
    
    @staticmethod
    def set_texture(tex: texture):
        if tex is None:
            CGL_widgets_set_texture(NULL)
        else:
            CGL_widgets_set_texture(tex.c_texture)
    
    @staticmethod
    def set_mask(mask: vec4):
        CGL_widgets_set_mask(mask.c_vec4)
    
    def set_maskf(min_x: float, min_y: float, max_x: float, max_y: float):
        CGL_widgets_set_maskf(min_x, min_y, max_x, max_y)

    @staticmethod
    def set_font_texture(tex: texture):
        CGL_widgets_set_font_texture(tex.c_texture)
    
    @staticmethod
    def set_texture_coordinate_so(scale_x: float, scale_y: float, offset_x: float, offset_y: float):
        CGL_widgets_set_texture_coordinate_so(scale_x, scale_y, offset_x, offset_y)
    
    @staticmethod
    def apply_transformations_on_cpu():
        CGL_widgets_apply_transformations_on_cpu()
    
    @staticmethod
    def apply_transformations_on_gpu():
        CGL_widgets_apply_transformations_on_gpu()
    
    @staticmethod
    def add_triangle(a: vec3, b: vec3, c: vec3):
        CGL_widgets_add_triangle(a.c_vec3, b.c_vec3, c.c_vec3)
    
    @staticmethod
    def add_quad(a: vec3, b: vec3, c: vec3, d: vec3):
        CGL_widgets_add_quad(a.c_vec3, b.c_vec3, c.c_vec3, d.c_vec3)
    
    @staticmethod
    def add_quad_8f(a_x: float, a_y: float, b_x: float, b_y: float, c_x: float, c_y: float, d_x: float, d_y: float):
        CGL_widgets_add_quad_8f(a_x, a_y, b_x, b_y, c_x, c_y, d_x, d_y)
    
    @staticmethod
    def add_line(start: vec3, end: vec3):
        CGL_widgets_add_line(start.c_vec3, end.c_vec3)
    
    @staticmethod
    def add_line2f(start_x: float, start_y: float, end_x: float, end_y: float):
        CGL_widgets_add_line2f(start_x, start_y, end_x, end_y)
    
    @staticmethod
    def add_rect(start: vec3, size: vec2):
        CGL_widgets_add_rect(start.c_vec3, size.c_vec2)
    
    @staticmethod
    def add_rect2f(start_x: float, start_y: float, size_x: float, size_y: float):
        CGL_widgets_add_rect2f(start_x, start_y, size_x, size_y)
    
    @staticmethod
    def add_circle(position: vec3, radius: float):
        CGL_widgets_add_circle(position.c_vec3, radius)
    
    @staticmethod
    def add_circle2f(position_x: float, position_y: float, radius: float):
        CGL_widgets_add_circle2f(position_x, position_y, radius)
    
    @staticmethod
    def add_circler(position: vec3, radius: float, segments: int):
        CGL_widgets_add_circler(position.c_vec3, radius, segments)
    
    @staticmethod
    def add_circler2fr(position_x: float, position_y: float, radius: float, segments: int):
        CGL_widgets_add_circle2fr(position_x, position_y, radius, segments)
    
    @staticmethod
    def add_oval(position: vec3, radius: vec2):
        CGL_widgets_add_oval(position.c_vec3, radius.c_vec2)
    
    @staticmethod
    def add_oval2f(position_x: float, position_y: float, radius_x: float, radius_y: float):
        CGL_widgets_add_oval2f(position_x, position_y, radius_x, radius_y)
    
    @staticmethod
    def add_arc2f(position_x: float, position_y: float, radius: float, start_angle: float, end_angle: float, segments: int):
        CGL_widgets_add_arc2f(position_x, position_y, radius, start_angle, end_angle, segments)
    
    @staticmethod
    def add_character(ch: str, x: float, y: float, sx: float, sy: float) -> bool:
        return CGL_widgets_add_character(ch[0], x, y, sx, sy)
    
    @staticmethod
    def add_string(st: str, x: float, y: float, sx: float, sy: float) -> bool:
        return CGL_widgets_add_string(st.encode('utf-8'), x, y, sx, sy)

    @staticmethod
    def add_cubic_bazier(start: vec3, end: vec3, control_1: vec3, control_2: vec3, res: int):
        CGL_widgets_add_cubic_bazier(start.c_vec3, end.c_vec3, control_1.c_vec3, control_2.c_vec3, res)
    
    @staticmethod
    def add_cubic_bazier2v(start: vec2, end: vec2, control_1: vec2, control_2: vec2, res: int):
        CGL_widgets_add_cubic_bazier2v(start.c_vec2, end.c_vec2, control_1.c_vec2, control_2.c_vec2, res)

    @staticmethod
    def add_cubic_bazier2f(start_x: float, start_y: float, end_x: float, end_y: float, control_1_x: float, control_1_y: float, control_2_x: float, control_2_y: float, res: int):
        CGL_widgets_add_cubic_bazier2f(start_x, start_y, end_x, end_y, control_1_x, control_1_y, control_2_x, control_2_y, res)
    
    @staticmethod
    def add_cubic_bazier_points(start: vec3, end: vec3, control_1: vec3, control_2: vec3, res: int):
        CGL_widgets_add_cubic_bazier_points(start.c_vec3, end.c_vec3, control_1.c_vec3, control_2.c_vec3, res)
    
    @staticmethod
    def add_cubic_bazier_points2v(start: vec2, end: vec2, control_1: vec2, control_2: vec2, res: int):
        CGL_widgets_add_cubic_bazier_points2v(start.c_vec2, end.c_vec2, control_1.c_vec2, control_2.c_vec2, res)
    
    @staticmethod
    def add_cubic_bazier_points2f(start_x: float, start_y: float, end_x: float, end_y: float, control_1_x: float, control_1_y: float, control_2_x: float, control_2_y: float, res: int):
        CGL_widgets_add_cubic_bazier_points2f(start_x, start_y, end_x, end_y, control_1_x, control_1_y, control_2_x, control_2_y, res)

    @staticmethod
    def add_shape_out_line(shape: shape):
        CGL_widgets_add_shape_out_line(&shape.c_shape)
    
    @staticmethod
    def add_string_with_font(st: str, font: font, x: float, y: float, sx: float, scale_y: float) -> float:
        return CGL_widgets_add_string_with_font(st.encode('utf-8'), font.c_font, x, y, sx, scale_y)

NOISE_TYPE_PERLIN        = 0
NOISE_TYPE_OPENSIMPLEX   = 1
NOISE_TYPE_OPENSIMPLEX2S = 2
NOISE_TYPE_VALUE         = 3
NOISE_TYPE_VALUECUBIC    = 4
NOISE_TYPE_WORLEY        = 5
NOISE_TYPE_COUNT         = 6

NOISE_FRACTAL_TYPE_NONE     = 0
NOISE_FRACTAL_TYPE_FBM      = 1
NOISE_FRACTAL_TYPE_BILLOW   = 2
NOISE_FRACTAL_TYPE_RIGID    = 3
NOISE_FRACTAL_TYPE_PINGPONG = 4
NOISE_FRACTAL_TYPE_COUNT    = 5

cdef class noise_params:
    cdef CGL_noise_params c_noise_params

    @property
    def type(self) -> int:
        return self.c_noise_params.type
    
    @type.setter
    def type(self, value: int):
        self.c_noise_params.type = value
    
    @property
    def fractal_type(self) -> int:
        return self.c_noise_params.fractal_type
    
    @fractal_type.setter
    def fractal_type(self, value: int):
        self.c_noise_params.fractal_type = value
    
    @property
    def octaves(self) -> int:
        return self.c_noise_params.octaves

    @octaves.setter
    def octaves(self, value: int):
        self.c_noise_params.octaves = value
    
    @property
    def lacunarity(self) -> float:
        return self.c_noise_params.lacunarity
    
    @lacunarity.setter
    def lacunarity(self, value: float):
        self.c_noise_params.lacunarity = value
    
    @property
    def gain(self) -> float:
        return self.c_noise_params.gain
    
    @gain.setter
    def gain(self, value: float):
        self.c_noise_params.gain = value
    
    @property
    def frequency(self) -> float:
        return self.c_noise_params.frequency
    
    @frequency.setter
    def frequency(self, value: float):
        self.c_noise_params.frequency = value
    
    @property
    def weighted_strength(self) -> float:
        return self.c_noise_params.weighted_strength
    
    @weighted_strength.setter
    def weighted_strength(self, value: float):
        self.c_noise_params.weighted_strength = value
    
    @property
    def ping_pong_strength(self) -> float:
        return self.c_noise_params.ping_pong_strength
    
    @ping_pong_strength.setter
    def ping_pong_strength(self, value: float):
        self.c_noise_params.ping_pong_strength = value
    
    def __init__(self):
        self.c_noise_params = CGL_noise_params()
        CGL_noise_params_default(&self.c_noise_params)
    
    def __repr__(self):
        return f"noise_params(type={self.type}, fractal_type={self.fractal_type}, octaves={self.octaves}, lacunarity={self.lacunarity}, gain={self.gain}, frequency={self.frequency}, weighted_strength={self.weighted_strength}, ping_pong_strength={self.ping_pong_strength})"
    
    def __str__(self):
        return f"noise_params(type={self.type}, fractal_type={self.fractal_type}, octaves={self.octaves}, lacunarity={self.lacunarity}, gain={self.gain}, frequency={self.frequency}, weighted_strength={self.weighted_strength}, ping_pong_strength={self.ping_pong_strength})"

def noise_init():
    CGL_noise_init()

def noise_shutdown():
    CGL_noise_shutdown()

def noise_get(x: float, y: float, z: float, np: noise_params = noise_params() ) -> float:
    return CGL_noise_get(&np.c_noise_params, x, y, z)

def noise_perlin(x: float, y: float, z: float) -> float:
    return CGL_noise_perlin(x, y, z)

def noise_opensimplex(x: float, y: float, z: float) -> float:
    return CGL_noise_opensimplex(x, y, z)

def noise_opensimplex2s(x: float, y: float, z: float) -> float:
    return CGL_noise_opensimplex2s(x, y, z)

def noise_value(x: float, y: float, z: float) -> float:
    return CGL_noise_value(x, y, z)

def noise_valuecubic(x: float, y: float, z: float) -> float:
    return CGL_noise_valuecubic(x, y, z)

def noise_worley(x: float, y: float, z: float) -> float:
    return CGL_noise_worley(x, y, z)

    
```

`python_wrapper/pyproject.toml`:

```toml
[build-system]
requires = [
    "Cython",
    "PyOpenGL",
    "glfw",
    "wheel",
    "setuptools",
]
build-backend = "setuptools.build_meta"
```

`python_wrapper/setup.py`:

```py
from distutils.core import setup
from distutils.extension import Extension
from Cython.Build import cythonize
from setuptools import setup, find_packages
import sys
import os
import platform
import sysconfig

def get_extra_link_args():
    if platform.system() == 'Windows':
        return []
    else:
        return ["-Wl,-rpath=$ORIGIN/lib/."]

requirements = ["PyOpenGL", "glfw", "Cython", "Pillow"] 

version = '0.0.10'

readme = 'Coming Soon ...'

required_libraries = ['cgl', 'glfw3', 'glad', 'freetype']

if platform.system() == 'Windows':
    required_libraries.append('user32')
    required_libraries.append('Gdi32')
    required_libraries.append('Shell32')

# link to gl library on linux
if platform.system() == 'Linux':
    required_libraries.append('GL')

extension = Extension(
    name="cgl",
    sources=["cgl_wrapper.pyx"],
    libraries=required_libraries,
    library_dirs=["lib"],
    define_macros=[("CGL_EXCLUDE_AUDIO", None), ("CGL_EXCLUDE_NETWORKING", None), ("CGL_LOGGING_ENABLED", None)],
    include_dirs=["include", "include/glad/include", "include/glfw/include", "include/freetype/include"],
    extra_link_args=get_extra_link_args(),
)

setup(
    name = 'cgl-py',
    author = 'Jaysmito Mukherjee',
    author_email = 'jaysmito101@gmail.com',
    url = 'https://github.com/Jaysmito101/cgl',
    project_urls = {
        'Documentation': 'https://www.libcgl.tech/',
        'Issue tracker': 'https://github.com/Jaysmito101/cgl/issues',
    },
    version = version,
    packages = find_packages(),
    license = 'MIT',
    description = 'A Python Wrapper for CGL',
    long_description = readme,
    long_description_content_type = 'text/markdown',
    ext_modules=cythonize([extension]),
    include_package_data = True,
    install_requires = requirements,
    python_requires='>=3.6.0',
    package_data={
        "cgl-py": [
            "include/**.h",
            "include/**.hpp",
            "lib/**.lib",
        ]    
    },
    classifiers=[
        'Development Status :: 3 - Alpha',
        'License :: OSI Approved :: MIT License',
        'Intended Audience :: Developers',
        'Natural Language :: English',
        'Operating System :: OS Independent',
        'Programming Language :: Python :: 3.6',
        'Programming Language :: Python :: 3.8',
        'Programming Language :: Python :: 3.9',
        'Programming Language :: Python :: 3.10',
        'Topic :: Office/Business :: Financial',
        'Topic :: Software Development :: Libraries',
        'Topic :: Software Development :: Libraries :: Python Modules',
        'Topic :: Utilities',
        'Typing :: Typed',
    ],
)

```

`rust_wrapper/Cargo.toml`:

```toml
[workspace]

members = [
    "sandbox", # The sandbox crate is the main binary
    "cgl-rs", # The cgl-rs crate is a library
]
```

`rust_wrapper/cgl-rs/Cargo.toml`:

```toml
[package]
name = "cgl-rs"
version = "0.1.6"
edition = "2021"
authors = ["Jaysmito Mukherjee <jaysmito101@gmail.com>"]
description = "CGL is a multipurpose library mainly for recreational coding / demo scenes / prototyping / small games / experimentation."
repository = "https://github.com/Jaysmito101/cgl"
license = "MIT"
keywords = ["cgl", "opengl", "2d", "3d", "gamedev"]
build = "./src/build.rs"
readme = "README.md"

[dependencies]
libc = "0.2.0"
```

`rust_wrapper/cgl-rs/lib/cgl_wrapper.c`:

```c
/*
MIT License

Copyright (c) 2023 Jaysmito Mukherjee (jaysmito101@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

// Many of CGL's features are implemented using macros.
// Thus to make them available in the wrapper, here
// we create proxy functions that call the macros.

#define CGL_EXCLUDE_NETWORKING
#define CGL_LOGGING_ENABLED
#define CGL_EXCLUDE_AUDIO
#define CGL_IMPLEMENTATION
#include "cgl.h"


CGL_bool CGL_utils_is_point_in_rect_MACRO(CGL_float px, CGL_float py, CGL_float x, CGL_float y, CGL_float sx, CGL_float sy, CGL_float scx, CGL_float scy) {
    return CGL_utils_is_point_in_rect(px, py, x, y, sx, sy, scx, scy);
}

CGL_float CGL_utils_random_float_MACRO() 
{
    return CGL_utils_random_float();
}

CGL_float CGL_utils_random_float_in_range_MACRO(CGL_float min, CGL_float max) 
{
    return CGL_utils_random_float_in_range(min, max);
}

CGL_int CGL_utils_random_int_MACRO(CGL_int min, CGL_int max) 
{
    return CGL_utils_random_int(min, max);
}

CGL_bool CGL_utils_random_bool_MACRO()
{
    return CGL_utils_random_bool();
}

CGL_vec2 CGL_utils_random_vec2_MACRO(CGL_vec2 min, CGL_vec2 max) 
{
    return CGL_utils_random_vec2(min, max);
}

CGL_vec3 CGL_utils_random_vec3_MACRO(CGL_vec3 min, CGL_vec3 max) 
{
    return CGL_utils_random_vec3(min, max);
}

CGL_vec4 CGL_utils_random_vec4_MACRO(CGL_vec4 min, CGL_vec4 max) 
{
    return CGL_utils_random_vec4(min, max);
}

CGL_color CGL_utils_random_color_MACRO() 
{
    return CGL_utils_random_color();
}

CGL_mat4 CGL_mat4_zero_MACRO()
{
    return CGL_mat4_zero();
}

CGL_mat4 CGL_mat4_identity_MACRO()
{
    return CGL_mat4_identity();
}

CGL_mat4 CGL_mat4_scale_MACRO(CGL_float sx, CGL_float sy, CGL_float sz)
{
    return CGL_mat4_scale(sx, sy, sz);
}

CGL_mat4 CGL_mat4_translate_MACRO(CGL_float tx, CGL_float ty, CGL_float tz)
{
    return CGL_mat4_translate(tx, ty, tz);
}

CGL_mat4 CGL_mat4_rotate_x_MACRO(CGL_float angle)
{
    return CGL_mat4_rotate_x(angle);
}

CGL_mat4 CGL_mat4_rotate_y_MACRO(CGL_float angle)
{
    return CGL_mat4_rotate_y(angle);
}

CGL_mat4 CGL_mat4_rotate_z_MACRO(CGL_float angle)
{
    return CGL_mat4_rotate_z(angle);
}

CGL_mat4 CGL_mat4_perspective_MACRO(CGL_float fov, CGL_float aspect, CGL_float near_, CGL_float far_)
{
    return CGL_mat4_perspective(fov, aspect, near_, far_);
}

CGL_mat4 CGL_mat4_orthographic_MACRO(CGL_float left, CGL_float right, CGL_float bottom, CGL_float top, CGL_float near_, CGL_float far_)
{
    return CGL_mat4_orthographic(left, right, bottom, top, near_, far_);
}

CGL_void CGL_mat4_log_MACRO(CGL_mat4 mat)
{
    CGL_mat4_log(mat);
}
```

`rust_wrapper/cgl-rs/src/build.rs`:

```rs
use std::path::Path;
use std::env;

fn main() {
    let dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    
    
    match env::consts::OS {
        "windows" => {
            println!("cargo:rustc-link-search={}", Path::new(&dir).join("lib").join("windows").display());
            println!("cargo:rustc-link-lib=user32");
            println!("cargo:rustc-link-lib=kernel32");
            println!("cargo:rustc-link-lib=gdi32");
            println!("cargo:rustc-link-lib=shell32");
        },
        "linux" => {
            println!("cargo:rustc-link-search=native={}", Path::new(&dir).join("lib").join("linux").display());
        },
        _ => {
            panic!("Unsupported OS")
        }
    }

    println!("cargo:rustc-link-lib=static=cgl");    
    println!("cargo:rustc-link-lib=static=glfw3");
    println!("cargo:rustc-link-lib=static=glad");
    println!("cargo:rustc-link-lib=static=freetype");
    
}
```

`rust_wrapper/cgl-rs/src/graphics.rs`:

```rs
//! The CGL Graphics Module

#![allow(non_camel_case_types)]

use std::result;
use libc::{c_void, c_int, c_float};

mod framebuffer;
pub use framebuffer::*;

mod texture;
pub use texture::*;

mod shader;
pub use shader::*;

mod ssbo;
pub use ssbo::*;

mod mesh;
pub use mesh::*;

mod bloom;
pub use bloom::*;

mod tilemap;
pub use tilemap::*;

pub mod text;

pub mod widgets;

extern {
    fn CGL_gl_init() -> c_int;
    fn CGL_gl_shutdown() -> c_void;
    fn CGL_gl_clear(r: c_float, g: c_float, b: c_float, a: c_float) -> c_void;
    fn CGL_gl_render_screen_quad() -> c_void;
}


/// Initializes the CGL Graphics Module.
///
/// Note: This method should only be called after there exists a valid OpenGL context.
/// 
/// # Returns
///
/// Returns `Ok(())` if the initialization was successful, otherwise returns `Err(())`.
/// 
/// # Example
/// 
/// ```
/// cgl_rs::init().expect("Failed to initialize CGL");
/// let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
/// window.make_context_current();
/// cgl_rs::graphics::init().expect("Failed to initialize CGL Graphics Module");
/// // ...
/// cgl_rs::graphics::shutdown();
/// window.destroy();
/// cgl_rs::shutdown();
/// ```
pub fn init() -> result::Result<(), ()> {
    unsafe {
        let result = CGL_gl_init();
        if result == 0 {
            Err(())
        } else {
            Ok(())
        }   
    }
}

/// Shuts down the CGL Graphics Module.
/// 
/// This function should be called before cgl_rs::shutdown().
/// 
/// # Example
/// 
/// ```
/// cgl_rs::init().expect("Failed to initialize CGL");
/// let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
/// cgl_rs::graphics::init().expect("Failed to initialize CGL Graphics Module");
/// // ...
/// cgl_rs::graphics::shutdown();
/// window.destroy();
/// cgl_rs::shutdown();
pub fn shutdown() -> () {
    unsafe {
        CGL_gl_shutdown();
    }
}



/// Clears the screen with the specified color.
///
/// # Arguments
///
/// * `r` - The red component of the color, in the range [0.0, 1.0].
/// * `g` - The green component of the color, in the range [0.0, 1.0].
/// * `b` - The blue component of the color, in the range [0.0, 1.0].
/// * `a` - The alpha component of the color, in the range [0.0, 1.0].
///
/// # Example
///
/// ```
/// cgl_rs::init().expect("Failed to initialize CGL");
/// let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
/// cgl_rs::graphics::init().expect("Failed to initialize CGL Graphics Module");
/// cgl_rs::graphics::clear(0.0, 0.0, 0.0, 1.0); // Clears the screen to black
/// // ...
/// cgl_rs::graphics::shutdown();
/// window.destroy();
/// cgl_rs::shutdown();
/// ```
pub fn clear(r: f32, g: f32, b: f32, a: f32) -> () {
    unsafe {
        CGL_gl_clear(r, g, b, a);
    }
}

/// Renders a screen quad.
///
/// # Example
///
/// ```
/// cgl_rs::init().expect("Failed to initialize CGL");
/// let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
/// cgl_rs::graphics::init().expect("Failed to initialize CGL Graphics Module");
/// cgl_rs::graphics::render_screen_quad(); // Renders a screen quad
/// // ...
/// cgl_rs::graphics::shutdown();
/// window.destroy();
/// cgl_rs::shutdown();
/// ```
pub fn render_screen_quad() -> () {
    unsafe {
        CGL_gl_render_screen_quad();
    }
}
```

`rust_wrapper/cgl-rs/src/graphics/bloom.rs`:

```rs
//! This provices CGL's Bloom post-processing effect (based on Unity's Bloom effect)

#![allow(non_camel_case_types)]
use libc::{c_void, c_int, c_float};

use crate::graphics::texture::{Texture, CGL_texture};

/// The internal handle used by CGL
#[repr(C)]
pub(crate) struct CGL_bloom {
    _private: c_void
}

extern {
    fn CGL_bloom_create(width: c_int, height: c_int, iterations: c_int) -> *mut CGL_bloom;
    fn CGL_bloom_destroy(bloom: *mut CGL_bloom) -> c_void;
    fn CGL_bloom_set_threshold(bloom: *mut CGL_bloom, val: c_float) -> c_void;
    fn CGL_bloom_get_threshold(bloom: *mut CGL_bloom) -> c_float;
    fn CGL_bloom_set_knee(bloom: *mut CGL_bloom, val: c_float) -> c_void;
    fn CGL_bloom_get_knee(bloom: *mut CGL_bloom) -> c_float;
    fn CGL_bloom_set_offset(bloom: *mut CGL_bloom, x: c_float, y: c_float) -> c_void;
    fn CGL_bloom_apply(bloom: *mut CGL_bloom, tex: *mut CGL_texture) -> c_void;
    fn CGL_bloom_apply2(bloom: *mut CGL_bloom, tex_src: *mut CGL_texture, tex_dst: *mut CGL_texture) -> c_void;
    fn CGL_bloom_get_iterations(bloom: *mut CGL_bloom) -> c_int;
    fn CGL_bloom_get_lod_texture(bloom: *mut CGL_bloom, index: c_int) -> *mut CGL_texture;
    fn CGL_bloom_get_prefiltered_texture(bloom: *mut CGL_bloom) -> *mut CGL_texture;
}

/// The Bloom Object
#[repr(C)]
pub struct Bloom {
    pub(crate) handle: *mut CGL_bloom,
    pub(crate) has_been_destroyed: bool
}

impl Bloom {
    /// Creates a new Bloom object with the specified width, height, and number of iterations.
    /// 
    /// # Arguments
    /// 
    /// * `width` - The width of the Bloom effect.
    /// * `height` - The height of the Bloom effect.
    /// * `iterations` - The number of iterations to apply the Bloom effect.
    /// 
    /// # Returns
    /// 
    /// Returns a new Bloom object if successful, otherwise returns an error message.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let bloom = cgl_rs::graphics::Bloom::new(800, 600, 3).unwrap();
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn new(width: i32, height: i32, iterations: i32) -> Result<Bloom, &'static str> {
        unsafe {
            let handle = CGL_bloom_create(width, height, iterations);
            if handle.is_null() {
                Err("Failed to create Bloom")
            } else {
                Ok(Bloom {
                    handle,
                    has_been_destroyed: false
                })
            }
        }
    }

    

    /// Destroys the texture and frees its resources. If the texture has already been destroyed, this method does nothing.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let mut bloom = cgl_rs::graphics::Bloom::new(800, 600, 3).unwrap();
    ///     bloom.destroy(); // optional
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    pub fn destroy(&mut self) {
        if !self.has_been_destroyed {
            unsafe {
                CGL_bloom_destroy(self.handle);
            }
            self.has_been_destroyed = true;
        }
    }


    /// Sets the threshold value for the Bloom effect.
    /// 
    /// # Arguments
    /// 
    /// * `val` - The threshold value to set.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let bloom = cgl_rs::graphics::Bloom::new(800, 600, 3).unwrap();
    ///    bloom.set_threshold(0.5);
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_threshold(&self, val: f32) {
        unsafe {
            CGL_bloom_set_threshold(self.handle, val);
        }
    }

    /// Gets the threshold value for the Bloom effect.
    /// 
    /// # Returns
    /// 
    /// Returns the current threshold value.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let bloom = cgl_rs::graphics::Bloom::new(800, 600, 3).unwrap();
    ///    let threshold = bloom.get_threshold();
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn get_threshold(&self) -> f32 {
        unsafe {
            CGL_bloom_get_threshold(self.handle)
        }
    }

    /// Sets the knee value for the Bloom effect.
    /// 
    /// # Arguments
    /// 
    /// * `val` - The knee value to set.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let bloom = cgl_rs::graphics::Bloom::new(800, 600, 3).unwrap();
    ///    bloom.set_knee(0.5);
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_knee(&self, val: f32) {
        unsafe {
            CGL_bloom_set_knee(self.handle, val);
        }
    }

    /// Gets the knee value for the Bloom effect.
    /// 
    /// # Returns
    /// 
    /// Returns the current knee value.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let bloom = cgl_rs::graphics::Bloom::new(800, 600, 3).unwrap();
    ///    let knee = bloom.get_knee();
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn get_knee(&self) -> f32 {
        unsafe {
            CGL_bloom_get_knee(self.handle)
        }
    }

    /// Sets the offset values for the Bloom effect.
    /// 
    /// # Arguments
    /// 
    /// * `x` - The x offset value to set.
    /// * `y` - The y offset value to set.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let bloom = cgl_rs::graphics::Bloom::new(800, 600, 3).unwrap();
    ///    bloom.set_offset(0.5, 0.5);
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_offset(&self, x: f32, y: f32) {
        unsafe {
            CGL_bloom_set_offset(self.handle, x, y);
        }
    }


    /// Applies the Bloom effect to a texture.
    /// 
    /// # Arguments
    /// 
    /// * `tex` - The texture to apply the Bloom effect to.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let bloom = cgl_rs::graphics::Bloom::new(800, 600, 3).unwrap();
    ///    let texture = cgl_rs::graphics::Texture::dummy2(600, 600).unwrap();
    ///    bloom.apply(&texture);
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn apply(&self, tex: &Texture) {
        unsafe {
            CGL_bloom_apply(self.handle, tex.handle);
        }
    }

    /// Applies the Bloom effect to a source texture and writes the result to a destination texture.
    /// 
    /// # Arguments
    /// 
    /// * `tex_src` - The source texture to apply the Bloom effect to.
    /// * `tex_dst` - The destination texture to write the result to.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let bloom = cgl_rs::graphics::Bloom::new(800, 600, 3).unwrap();
    ///    let texture_src = cgl_rs::graphics::Texture::dummy2(600, 600).unwrap();
    ///    let texture_dst = cgl_rs::graphics::Texture::dummy2(600, 600).unwrap();
    ///    bloom.apply2(&texture_src, &texture_dst);
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn apply2(&self, tex_src: &Texture, tex_dst: &Texture) {
        unsafe {
            CGL_bloom_apply2(self.handle, tex_src.handle, tex_dst.handle);
        }
    }

    /// Gets the value of the number of iterations for the Bloom effect.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let bloom = cgl_rs::graphics::Bloom::new(800, 600, 3).unwrap();
    ///    let iterations = bloom.get_iterations();
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn get_iterations(&self) -> i32 {
        unsafe {
            CGL_bloom_get_iterations(self.handle)
        }
    }

    /// Gets the texture for a specific level of detail (LOD) for the Bloom effect.
    /// 
    /// This texture is owned and managed by the Bloom effect and should not be destroyed manually.
    /// 
    /// # Arguments
    /// 
    /// * `index` - The index of the LOD texture to retrieve.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let bloom = cgl_rs::graphics::Bloom::new(800, 600, 3).unwrap();
    ///    let lod_texture = bloom.get_lod_texture(0);
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn get_lod_texture(&self, index: i32) -> Result<Texture, &'static str> {
        unsafe {
            let handle = CGL_bloom_get_lod_texture(self.handle, index);
            if handle.is_null() {
                Err("Failed to get LOD texture")
            } else {
                Ok(Texture {
                    handle,
                    has_been_destroyed: true
                })
            }
        }
    }

    /// Gets the prefiltered texture for the Bloom effect.
    /// 
    /// This texture is owned and managed by the Bloom effect and should not be destroyed manually.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let bloom = cgl_rs::graphics::Bloom::new(800, 600, 3).unwrap();
    ///    let prefiltered_texture = bloom.get_prefiltered_texture();
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn get_prefiltered_texture(&self) -> Result<Texture, &'static str> {
        unsafe {
            let handle = CGL_bloom_get_prefiltered_texture(self.handle);
            if handle.is_null() {
                Err("Failed to get prefiltered texture")
            } else {
                Ok(Texture {
                    handle,
                    has_been_destroyed: true
                })
            }
        }
    }
}


impl Drop for Bloom {
    fn drop(&mut self) {
        self.destroy();
    }
}

impl Clone for Bloom {
    fn clone(&self) -> Self {
        Bloom {
            handle: self.handle.clone(),
            has_been_destroyed: true
        }
    }
}
```

`rust_wrapper/cgl-rs/src/graphics/framebuffer.rs`:

```rs
//! The framebuffer module for CGL

#![allow(non_camel_case_types)]
use libc::{c_void, c_int};

/// The internal window handle used by CGL
#[repr(C)]
pub(crate) struct CGL_framebuffer {
    _private: c_void
}

extern {
    fn CGL_framebuffer_create_from_default(window: *mut crate::window::CGL_window) -> *mut CGL_framebuffer;
    fn CGL_framebuffer_create(width: c_int, height: c_int) -> *mut CGL_framebuffer;
    fn CGL_framebuffer_create_basic(width: c_int, height: c_int) -> *mut CGL_framebuffer;
    fn CGL_framebuffer_add_color_attachment(framebuffer: *mut CGL_framebuffer, texture: *mut super::texture::CGL_texture) -> ();
    fn CGL_framebuffer_destroy(framebuffer: *mut CGL_framebuffer) -> ();
    fn CGL_framebuffer_get_color_attachment(framebuffer: *mut CGL_framebuffer, index: c_int) -> *mut super::texture::CGL_texture;
    fn CGL_framebuffer_bind(framebuffer: *mut CGL_framebuffer) -> ();
    fn CGL_framebuffer_get_size(framebuffer: *mut CGL_framebuffer, width: *mut c_int, height: *mut c_int) -> ();
    fn CGL_framebuffer_set_user_data(framebuffer: *mut CGL_framebuffer, user_data: *mut c_void) -> ();
    fn CGL_framebuffer_get_user_data(framebuffer: *mut CGL_framebuffer) -> *mut c_void;
    fn CGL_framebuffer_read_pixels(framebuffer: *mut CGL_framebuffer, x: c_int, y: c_int, width: c_int, height: c_int, pixels: *mut c_void) -> ();
    fn CGL_framebuffer_get_mouse_pick_id(framebuffer: *mut CGL_framebuffer, x: c_int, y: c_int, index: c_int) -> c_int;
    fn CGL_framebuffer_get_color_texture(framebuffer: *mut CGL_framebuffer) -> *mut super::texture::CGL_texture;
    fn CGL_framebuffer_get_depth_texture(framebuffer: *mut CGL_framebuffer) -> *mut super::texture::CGL_texture;
}


/// A framebuffer object that can be used for offscreen rendering.
#[derive(Debug)]
pub struct Framebuffer {
    pub(crate) handle: *mut CGL_framebuffer,
    pub(crate) has_been_destroyed: bool
}


impl Framebuffer {

    /// Creates a new framebuffer object from the default window.
    ///
    /// # Arguments
    ///
    /// * `window` - A reference to the window object to create the framebuffer from.
    ///
    /// # Returns
    ///
    /// Returns a `Result` containing the newly created `Framebuffer` object or an error message if the creation failed.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window =  cgl_rs::Window::new("Hello World", 600, 800).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let framebuffer = cgl_rs::graphics::Framebuffer::from_default(&window).unwrap();
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    pub fn from_default(window: &crate::window::Window) -> Result<Framebuffer, &'static str> {
        unsafe {
            let result = CGL_framebuffer_create_from_default(window.get_cgl_handle());
            if result.is_null() {
                Err("Failed to create framebuffer from default")
            } else {
                Ok(Framebuffer {
                    handle: result,
                    has_been_destroyed: false
                })
            }
        }
    }

    /// Creates a new framebuffer object with the specified width and height.
    ///
    /// # Arguments
    ///
    /// * `width` - The width of the framebuffer.
    /// * `height` - The height of the framebuffer.
    ///
    /// # Returns
    ///
    /// Returns a `Result` containing the newly created `Framebuffer` object or an error message if the creation failed.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window =  cgl_rs::Window::new("Hello World", 600, 800).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let framebuffer = cgl_rs::graphics::Framebuffer::new(800, 600).unwrap();
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn new(width: i32, height: i32) -> Result<Framebuffer, &'static str> {
        unsafe {
            let result = CGL_framebuffer_create(width, height);
            if result.is_null() {
                Err("Failed to create framebuffer")
            } else {
                Ok(Framebuffer {
                    handle: result,
                    has_been_destroyed: false
                })
            }
        }
    }

    /// Creates a new basic framebuffer object with the specified width and height.
    ///
    /// # Arguments
    ///
    /// * `width` - The width of the framebuffer.
    /// * `height` - The height of the framebuffer.
    ///
    /// # Returns
    ///
    /// Returns a `Result` containing the newly created `Framebuffer` object or an error message if the creation failed.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window =  cgl_rs::Window::new("Hello World", 600, 800).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let framebuffer = cgl_rs::graphics::Framebuffer::new_basic(800, 600).unwrap();
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn new_basic(width: i32, height: i32) -> Result<Framebuffer, &'static str> {
        unsafe {
            let result = CGL_framebuffer_create_basic(width, height);
            if result.is_null() {
                Err("Failed to create framebuffer")
            } else {
                Ok(Framebuffer {
                    handle: result,
                    has_been_destroyed: false
                })
            }
        }
    }

    /// Destroys the framebuffer object.
    /// 
    /// Note: This function is called automatically when the framebuffer object goes out of scope.
    ///       But this can also be called manually to destroy the framebuffer object before it goes out of scope.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window =  cgl_rs::Window::new("Hello World", 600, 800).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let mut framebuffer = cgl_rs::graphics::Framebuffer::new(800, 600).unwrap();
    ///     framebuffer.destroy(); // This is not necessary, but can be called manually.
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn destroy(&mut self) {
        if !self.has_been_destroyed {
            unsafe {
                CGL_framebuffer_destroy(self.handle);
            }
            self.has_been_destroyed = true;
        }
    }

    /// Adds a color attachment to the framebuffer object.
    ///
    /// Note: The texture object passed in will be destroyed automatically after being added to the framebuffer object.
    ///       So even if you clone the parent texture 
    ///
    /// # Arguments
    ///
    /// * `texture` - The texture object to be added as a color attachment to the framebuffer object.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window =  cgl_rs::Window::new("Hello World", 600, 800).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let mut framebuffer = cgl_rs::graphics::Framebuffer::new(800, 600).unwrap();
    ///     let texture = cgl_rs::graphics::Texture::dummy().unwrap();
    ///     framebuffer.add_color_attachment(texture);
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn add_color_attachment(&mut self, mut texture: crate::graphics::texture::Texture) {
        texture.has_been_destroyed = true;
        unsafe {
            CGL_framebuffer_add_color_attachment(self.handle, texture.handle);
        }
    }

    /// Gets the color attachment at the specified index.
    ///
    /// # Arguments
    ///
    /// * `index` - The index of the color attachment to retrieve.
    ///
    /// # Returns
    ///
    /// Returns `Some(Texture)` if the color attachment exists, otherwise returns `None`.
    /// This returned texture object is managed by the framebuffer object and will be 
    /// destroyed automatically when the framebuffer object is destroyed.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window =  cgl_rs::Window::new("Hello World", 600, 800).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let mut framebuffer = cgl_rs::graphics::Framebuffer::new_basic(800, 600).unwrap();
    ///     let texture = cgl_rs::graphics::Texture::dummy().unwrap();
    ///     framebuffer.add_color_attachment(texture);
    ///     let color_attachment = framebuffer.get_color_atttachment(0);
    ///     assert!(color_attachment.is_some());
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn get_color_atttachment(&self, index: i32) -> Option<crate::graphics::texture::Texture> {
        unsafe {
            let result = CGL_framebuffer_get_color_attachment(self.handle, index);
            if result.is_null() {
                None
            } else {
                Some(crate::graphics::texture::Texture {
                    handle: result,
                    has_been_destroyed: true
                })
            }
        }
    }


    /// Binds the framebuffer object for rendering.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window =  cgl_rs::Window::new("Hello World", 600, 800).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let mut framebuffer = cgl_rs::graphics::Framebuffer::new(800, 600).unwrap();
    ///     framebuffer.bind();
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn bind(&self) {
        unsafe {
            CGL_framebuffer_bind(self.handle);
        }
    }


    // Gets the size of the framebuffer object.
    ///
    /// # Returns
    ///
    /// Returns a tuple containing the width and height of the framebuffer object.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window =  cgl_rs::Window::new("Hello World", 600, 800).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let framebuffer = cgl_rs::graphics::Framebuffer::new(800, 600).unwrap();
    ///     let (width, height) = framebuffer.get_size();
    ///     assert_eq!(width, 800);
    ///     assert_eq!(height, 600);
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn get_size(&self) -> (i32, i32) {
        unsafe {
            let mut width = 0;
            let mut height = 0;
            CGL_framebuffer_get_size(self.handle, &mut width, &mut height);
            (width, height)
        }
    }

    /// Reads the pixels from the framebuffer object.
    ///
    /// Note: This function currently has some issues and may crash the program.
    /// 
    /// # Arguments
    ///
    /// * `x` - The x coordinate of the lower left corner of the rectangle of pixels to read.
    /// * `y` - The y coordinate of the lower left corner of the rectangle of pixels to read.
    /// * `width` - The width of the rectangle of pixels to read.
    /// * `height` - The height of the rectangle of pixels to read.
    /// 
    ///
    /// # Returns
    ///
    /// Returns a vector of bytes containing the pixel data.
    ///
    /// # Example
    ///
    /// ```no_run
    /// cgl_rs::init();
    /// let mut window =  cgl_rs::Window::new("Hello World", 600, 800).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let framebuffer = cgl_rs::graphics::Framebuffer::new(800, 600).unwrap();
    ///     let pixels = framebuffer.read_pixels(0, 0, 100, 100);
    ///     assert_eq!(pixels.len(), 100 * 100 * 4 * 4);
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn read_pixels(&self, x: i32, y: i32, width: i32, height: i32) -> Vec<u8> {
        unsafe {
            let mut buffer = Vec::with_capacity((width * height * 4) as usize);
            buffer.set_len((width * height * 4 * 4) as usize);
            CGL_framebuffer_read_pixels(self.handle, x, y, width, height, buffer.as_mut_ptr() as *mut std::ffi::c_void);
            buffer          
        }
    }


    /// Gets the mouse pick ID at the specified screen coordinates and index.
    ///
    /// # Arguments
    ///
    /// * `x` - The x coordinate of the screen position to check.
    /// * `y` - The y coordinate of the screen position to check.
    /// * `index` - The index of the mouse pick ID to retrieve.
    ///
    /// # Returns
    ///
    /// Returns the mouse pick ID at the specified screen coordinates and index.
    ///
    /// # Safety
    ///
    /// This function is marked as unsafe because it directly calls an unsafe C function.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window =  cgl_rs::Window::new("Hello World", 600, 800).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let framebuffer = cgl_rs::graphics::Framebuffer::new(800, 600).unwrap();
    ///     let mouse_pick_id = framebuffer.get_mouse_pick_id(400, 300, 0);
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn get_mouse_pick_id(&self, x: i32, y: i32, index: i32) -> i32 {
        unsafe {
            CGL_framebuffer_get_mouse_pick_id(self.handle, x, y, index)
        }
    }

    /// Gets the color texture of the framebuffer.
    ///
    /// # Returns
    ///
    /// Returns a `Texture` object representing the color texture of the framebuffer.
    ///
    /// # Safety
    ///
    /// This function is marked as unsafe because it directly calls an unsafe C function.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window =  cgl_rs::Window::new("Hello World", 600, 800).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let framebuffer = cgl_rs::graphics::Framebuffer::new(800, 600).unwrap();
    ///    let texture = framebuffer.get_color_texture();
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn get_color_texture(&self) -> crate::graphics::Texture {
        unsafe {
            let handle = CGL_framebuffer_get_color_texture(self.handle);
            crate::graphics::Texture {
                handle,
                has_been_destroyed: true
            }
        }
    }

    /// Gets the depth texture of the framebuffer.
    ///
    /// # Returns
    ///
    /// Returns a `Texture` object representing the depth texture of the framebuffer.
    ///
    /// # Safety
    ///
    /// This function is marked as unsafe because it directly calls an unsafe C function.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window =  cgl_rs::Window::new("Hello World", 600, 800).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let framebuffer = cgl_rs::graphics::Framebuffer::new(800, 600).unwrap();
    ///     let depth_texture = framebuffer.get_depth_texture();
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn get_depth_texture(&self) -> crate::graphics::Texture {
        unsafe {
            let handle = CGL_framebuffer_get_depth_texture(self.handle);
            crate::graphics::Texture {
                handle,
                has_been_destroyed: true
            }
        }
    }
}

impl std::ops::Drop for Framebuffer {
    fn drop(&mut self) {
        self.destroy();
    }
}


impl Clone for Framebuffer {
    /// Clones the framebuffer object.
    ///
    /// NOTE: The new instance will have the same handle, `has_been_destroyed` flag.
    ///       This means that the new instance will not be able to receive events nor will the internal window handle be
    ///       destroyed when the new instance is dropped. The internal window handle will be destroyed when the original
    ///       instance is dropped.
    /// 
    /// 
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window =  cgl_rs::Window::new("Hello World", 600, 800).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let framebuffer = cgl_rs::graphics::Framebuffer::new(800, 600).unwrap();
    ///     let cloned_framebuffer = framebuffer.clone();
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    fn clone(&self) -> Self {
        Framebuffer {
            handle: self.handle.clone(),
            has_been_destroyed: true
        }
    }
}
```

`rust_wrapper/cgl-rs/src/graphics/mesh.rs`:

```rs
//! The Mesh (CPU & GPU) module for CGL

#![allow(non_camel_case_types)]
use libc::{c_void, c_int, size_t, c_char, c_float};

use crate::math::{IVector4, Vector4, Vector3, Matrix4x4};

/// The internal handle used by CGL
#[repr(C)]
pub(crate) struct CGL_mesh_gpu {
    _private: c_void
}

/// The Mesh Vertex Structure
#[repr(C)] #[derive(Copy, Clone)]
pub struct MeshVertex {
    pub position: Vector4,
    pub normal: Vector4,
    pub texture_coordinates: Vector4,
    pub bone_weights: Vector4,
    pub bone_ids: IVector4
}

/// The Mesh Structure
#[repr(C)] #[derive(Debug)]
pub struct MeshCPU_C {
    pub(crate) index_count: usize,
    pub(crate) index_count_used: usize,
    pub(crate) indices: *mut u32,
    pub(crate) vertex_count: usize,
    pub(crate) vertex_count_used: usize,
    pub(crate) vertices: *mut MeshVertex
}

pub struct MeshCPU {
    pub(crate) handle: *mut MeshCPU_C,
    pub(crate) has_been_destroyed: bool
}

pub struct MeshGPU {
    pub(crate) handle: *mut CGL_mesh_gpu,
    pub(crate) has_been_destroyed: bool
}


extern {
    fn CGL_mesh_cpu_create(vertex_count: size_t, index_count: size_t) -> *mut MeshCPU_C;
    fn CGL_mesh_cpu_recalculate_normals(mesh: *mut MeshCPU_C) -> *mut MeshCPU_C;
    fn CGL_mesh_cpu_load_obj(path: *const c_char) -> *mut MeshCPU_C;
    fn CGL_mesh_cpu_triangle(a: Vector3, b: Vector3, c: Vector3) -> *mut MeshCPU_C;
    fn CGL_mesh_cpu_plane(front: Vector3, right: Vector3, resolution: c_int, scale: c_float) -> *mut MeshCPU_C;
    fn CGL_mesh_cpu_quad(a: Vector3, b: Vector3, c: Vector3, d: Vector3) -> *mut MeshCPU_C;
    fn CGL_mesh_cpu_cube(use_3d_tex_coords: c_int) -> *mut MeshCPU_C;
    fn CGL_mesh_cpu_sphere(res_u: c_int, res_v: c_int) -> *mut MeshCPU_C;
    fn CGL_mesh_cpu_create_cylinder(start: Vector3, end: Vector3, radius0: c_float, radius1: c_float, resolution: c_int) -> *mut MeshCPU_C;
    fn CGL_mesh_cpu_add_mesh(mesh: *mut MeshCPU_C, mesh_other: *mut MeshCPU_C) -> *mut MeshCPU_C;
    fn CGL_mesh_cpu_add_cube(mesh: *mut MeshCPU_C, use_3d_tex_coords: c_int) -> *mut MeshCPU_C;
    fn CGL_mesh_cpu_add_triangle(mesh: *mut MeshCPU_C, a: Vector3, b: Vector3, c: Vector3) -> *mut MeshCPU_C;
    fn CGL_mesh_cpu_add_quad(mesh: *mut MeshCPU_C, a: Vector3, b: Vector3, c: Vector3, d: Vector3) -> *mut MeshCPU_C;
    fn CGL_mesh_cpu_add_sphere(mesh: *mut MeshCPU_C, res_u: c_int, res_v: c_int) -> *mut MeshCPU_C;
    fn CGL_mesh_cpu_add_cylinder(mesh: *mut MeshCPU_C, start: Vector3, end: Vector3, radius0: f32, radius1: f32, resolution: c_int) -> *mut MeshCPU_C;
    fn CGL_mesh_cpu_offset_vertices(mesh: *mut MeshCPU_C, offset: Vector3) -> *mut MeshCPU_C;
    fn CGL_mesh_cpu_scale_vertices(mesh: *mut MeshCPU_C, scale: c_float) -> *mut MeshCPU_C;
    // fn CGL_mesh_cpu_rotate_vertices(mesh: *mut MeshCPU_C, CGL_quat rotation) -> *mut MeshCPU_C; // for future
    fn CGL_mesh_cpu_transform_vertices(mesh: *mut MeshCPU_C, transform: &Matrix4x4) -> *mut MeshCPU_C;
    fn CGL_mesh_cpu_destroy(mesh: *mut MeshCPU_C) -> c_void;

    fn CGL_mesh_gpu_create() -> *mut CGL_mesh_gpu; // create mesh (gpu)
    fn CGL_mesh_gpu_destroy(mesh: *mut CGL_mesh_gpu); // destroy mesh (gpu)
    fn CGL_mesh_gpu_render(mesh: *mut CGL_mesh_gpu); // render mesh (gpu)
    fn CGL_mesh_gpu_render_instanced(mesh: *mut CGL_mesh_gpu, count: u32); // render mesh instanced (gpu)
    fn CGL_mesh_gpu_set_user_data(mesh: *mut CGL_mesh_gpu, user_data: *mut std::os::raw::c_void); // set mesh user data
    fn CGL_mesh_gpu_get_user_data(mesh: *mut CGL_mesh_gpu) -> *mut std::os::raw::c_void; // get mesh user data
    fn CGL_mesh_gpu_upload(mesh: *mut CGL_mesh_gpu, mesh_cpu: *mut MeshCPU_C, static_draw: c_int); // upload mesh from (cpu) to (gpu)
}

impl MeshVertex {
    /// Creates a new `MeshVertex` object with default values.
    /// 
    /// # Examples
    /// 
    /// ```
    /// let vertex = cgl_rs::graphics::MeshVertex::new();
    /// ```
    pub fn new() -> MeshVertex {
        MeshVertex {
            position: Vector4::new(0.0, 0.0, 0.0, 0.0),
            normal: Vector4::new(0.0, 0.0, 0.0, 0.0),
            texture_coordinates: Vector4::new(0.0, 0.0, 0.0, 0.0),
            bone_weights: Vector4::new(0.0, 0.0, 0.0, 0.0),
            bone_ids: IVector4::new(0, 0, 0, 0)
        }
    }
}

impl MeshCPU {

    fn from_handle(handle: *mut MeshCPU_C) -> Result<MeshCPU, &'static str> {
        if handle.is_null() {
            Err("Failed to create MeshCPU_C")
        } else {
            Ok(MeshCPU {
                handle: handle,
                has_been_destroyed: false
            })
        }
    }

    /// Create a new MeshCPU object with the given vertex and index count
    /// 
    /// # Arguments
    /// 
    /// * `vertex_count` - The number of vertices in the mesh
    /// * `index_count` - The number of indices in the mesh
    /// 
    /// # Returns
    /// 
    /// * `Result<MeshCPU, &'static str>` - The new MeshCPU object, or an error message
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// {
    ///     let mesh = cgl_rs::graphics::MeshCPU::new(3, 3).unwrap();
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn new(vertex_count: usize, index_count: usize) -> Result<MeshCPU, &'static str> {
        MeshCPU::from_handle(unsafe { CGL_mesh_cpu_create(vertex_count, index_count) })
    }

    /// Loads a mesh from an OBJ file
    /// 
    /// # Arguments
    /// 
    /// * `path` - The path to the OBJ file
    /// 
    /// # Returns
    /// 
    /// * `Result<MeshCPU, &'static str>` - The loaded MeshCPU object, or an error message
    /// 
    /// # Example
    /// 
    /// ```no_run
    /// cgl_rs::init();
    /// {
    ///     let mesh = cgl_rs::graphics::MeshCPU::load_obj("path/to/mesh.obj").unwrap();
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn load_obj(path: &str) -> Result<MeshCPU, &'static str> {
        let c_path = std::ffi::CString::new(path).unwrap();
        MeshCPU::from_handle(unsafe { CGL_mesh_cpu_load_obj(c_path.as_ptr()) })
    }

    /// Creates a new MeshCPU object with a single triangle
    /// 
    /// # Arguments
    /// 
    /// * `a` - The first vertex of the triangle
    /// * `b` - The second vertex of the triangle
    /// * `c` - The third vertex of the triangle
    /// 
    /// # Returns
    /// 
    /// * `Result<MeshCPU, &'static str>` - The new MeshCPU object, or an error message
    /// 
    /// # Example
    /// 
    /// ```
    /// use cgl_rs::math::*;
    /// cgl_rs::init();
    /// {
    ///     let mesh = cgl_rs::graphics::MeshCPU::triangle(
    ///         Vector3::new(0.0, 0.0, 0.0),
    ///         Vector3::new(1.0, 0.0, 0.0),
    ///         Vector3::new(0.0, 1.0, 0.0)
    ///     ).unwrap();
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn triangle(a: Vector3, b: Vector3, c: Vector3) -> Result<MeshCPU, &'static str> {
        MeshCPU::from_handle(unsafe { CGL_mesh_cpu_triangle(a, b, c) })
    }

    /// Creates a new MeshCPU object representing a plane with the given front and right vectors, resolution, and scale.
    ///
    /// # Arguments
    ///
    /// * `front` - The front vector of the plane
    /// * `right` - The right vector of the plane
    /// * `resolution` - The number of subdivisions along each axis of the plane
    /// * `scale` - The scale of the plane
    ///
    /// # Returns
    ///
    /// * `Result<MeshCPU, &'static str>` - The new MeshCPU object, or an error message
    ///
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::*;
    /// cgl_rs::init();
    /// {
    ///    let mesh = cgl_rs::graphics::MeshCPU::plane(
    ///       Vector3::new(0.0, 0.0, 1.0),
    ///       Vector3::new(1.0, 0.0, 0.0),
    ///       10,
    ///       1.0
    ///    ).unwrap();
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn plane(front: Vector3, right: Vector3, resolution: i32, scale: f32) -> Result<MeshCPU, &'static str> {
        MeshCPU::from_handle(unsafe { CGL_mesh_cpu_plane(front, right, resolution, scale) })
    }

    /// Creates a new MeshCPU object representing a quad with the given vertices.
    ///
    /// # Arguments
    ///
    /// * `a` - The first vertex of the quad
    /// * `b` - The second vertex of the quad
    /// * `c` - The third vertex of the quad
    /// * `d` - The fourth vertex of the quad
    ///
    /// # Returns
    ///
    /// * `Result<MeshCPU, &'static str>` - The new MeshCPU object, or an error message
    ///
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::*;
    /// cgl_rs::init();
    /// {
    ///    let mesh = cgl_rs::graphics::MeshCPU::quad(
    ///       Vector3::new(-1.0, -1.0, 0.0),
    ///       Vector3::new(1.0, -1.0, 0.0),
    ///       Vector3::new(1.0, 1.0, 0.0),
    ///       Vector3::new(-1.0, 1.0, 0.0)
    ///    ).unwrap();
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn quad(a: Vector3, b: Vector3, c: Vector3, d: Vector3) -> Result<MeshCPU, &'static str> {
        MeshCPU::from_handle(unsafe { CGL_mesh_cpu_quad(a, b, c, d) })
    }

    /// Creates a new MeshCPU object representing a cube.
    ///
    /// # Arguments
    ///
    /// * `use_3d_tex_coords` - Whether to use 3D texture coordinates
    ///
    /// # Returns
    ///
    /// * `Result<MeshCPU, &'static str>` - The new MeshCPU object, or an error message
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///    let mesh = cgl_rs::graphics::MeshCPU::cube(true).unwrap();
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn cube(use_3d_tex_coords: bool) -> Result<MeshCPU, &'static str> {
        MeshCPU::from_handle(unsafe { CGL_mesh_cpu_cube(use_3d_tex_coords as i32) })
    }

    /// Creates a new MeshCPU object representing a sphere.
    ///
    /// # Arguments
    ///
    /// * `res_u` - The number of subdivisions along the u-axis of the sphere
    /// * `res_v` - The number of subdivisions along the v-axis of the sphere
    ///
    /// # Returns
    ///
    /// * `Result<MeshCPU, &'static str>` - The new MeshCPU object, or an error message
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///    let mesh = cgl_rs::graphics::MeshCPU::sphere(10, 10).unwrap();
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn sphere(res_u: i32, res_v: i32) -> Result<MeshCPU, &'static str> {
        MeshCPU::from_handle(unsafe { CGL_mesh_cpu_sphere(res_u, res_v) })
    }

    /// Creates a new MeshCPU object representing a cylinder.
    ///
    /// # Arguments
    ///
    /// * `start` - The start position of the cylinder
    /// * `end` - The end position of the cylinder
    /// * `radius0` - The radius of the cylinder at the start position
    /// * `radius1` - The radius of the cylinder at the end position
    /// * `resolution` - The number of subdivisions around the cylinder
    ///
    /// # Returns
    ///
    /// * `Result<MeshCPU, &'static str>` - The new MeshCPU object, or an error message
    ///
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::*;
    /// cgl_rs::init();
    /// {
    ///    let mesh = cgl_rs::graphics::MeshCPU::cylinder(
    ///       Vector3::new(0.0, 0.0, 0.0),
    ///       Vector3::new(0.0, 1.0, 0.0),
    ///       1.0,
    ///       1.0,
    ///       10
    ///    ).unwrap();
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn cylinder(start: Vector3, end: Vector3, radius0: f32, radius1: f32, resolution: i32) -> Result<MeshCPU, &'static str> {
        MeshCPU::from_handle(unsafe { CGL_mesh_cpu_create_cylinder(start, end, radius0, radius1, resolution) })
    }

    /// Adds the vertices and indices of another MeshCPU object to this MeshCPU object.
    ///
    /// # Arguments
    ///
    /// * `other` - The MeshCPU object to add to this MeshCPU object
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///    let mesh1 = cgl_rs::graphics::MeshCPU::new(100, 100).unwrap();
    ///    let mesh2 = cgl_rs::graphics::MeshCPU::sphere(3, 3).unwrap();
    ///    mesh1.add_mesh(&mesh2);
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn add_mesh(&self, other: &MeshCPU) {
        unsafe {
            CGL_mesh_cpu_add_mesh(self.handle, other.handle);
        }
    }

    /// Adds the vertices and indices of a cube to this MeshCPU object.
    ///
    /// # Arguments
    ///
    /// * `use_3d_tex_coords` - Whether or not to use 3D texture coordinates
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///    let mesh = cgl_rs::graphics::MeshCPU::new(100, 100).unwrap();
    ///    mesh.add_cube(true);
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn add_cube(&self, use_3d_tex_coords: bool) {
        unsafe {
            CGL_mesh_cpu_add_cube(self.handle, use_3d_tex_coords as i32);
        }
    }

    /// Adds the vertices and indices of a sphere to this MeshCPU object.
    ///
    /// # Arguments
    ///
    /// * `res_u` - The number of subdivisions along the u-axis of the sphere
    /// * `res_v` - The number of subdivisions along the v-axis of the sphere
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///    let mesh = cgl_rs::graphics::MeshCPU::new(100, 100).unwrap();
    ///    mesh.add_sphere(2, 2);
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn add_sphere(&self, res_u: i32, res_v: i32) {
        unsafe {
            CGL_mesh_cpu_add_sphere(self.handle, res_u, res_v);
        }
    }

    /// Adds a triangle to this MeshCPU object.
    ///
    /// # Arguments
    ///
    /// * `a` - The first vertex of the triangle
    /// * `b` - The second vertex of the triangle
    /// * `c` - The third vertex of the triangle
    ///
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::*;
    /// cgl_rs::init();
    /// {
    ///    let mesh = cgl_rs::graphics::MeshCPU::new(100, 100).unwrap();
    ///    mesh.add_triangle(Vector3::new(0.0, 0.0, 0.0), Vector3::new(1.0, 0.0, 0.0), Vector3::new(0.0, 1.0, 0.0));
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn add_triangle(&self, a: Vector3, b: Vector3, c: Vector3) {
        unsafe {
            CGL_mesh_cpu_add_triangle(self.handle, a, b, c);
        }
    }

    /// Adds a quad to this MeshCPU object.
    ///
    /// # Arguments
    ///
    /// * `a` - The first vertex of the quad
    /// * `b` - The second vertex of the quad
    /// * `c` - The third vertex of the quad
    /// * `d` - The fourth vertex of the quad
    ///
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::*;
    /// cgl_rs::init();
    /// {
    ///    let mesh = cgl_rs::graphics::MeshCPU::new(100, 100).unwrap();
    ///    mesh.add_quad(Vector3::new(0.0, 0.0, 0.0), Vector3::new(1.0, 0.0, 0.0), Vector3::new(1.0, 1.0, 0.0), Vector3::new(0.0, 1.0, 0.0));
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn add_quad(&self, a: Vector3, b: Vector3, c: Vector3, d: Vector3) {
        unsafe {
            CGL_mesh_cpu_add_quad(self.handle, a, b, c, d);
        }
    }

    // Adds a cylinder to this MeshCPU object.
    ///
    /// # Arguments
    ///
    /// * `start` - The starting point of the cylinder
    /// * `end` - The ending point of the cylinder
    /// * `radius0` - The radius of the cylinder at the starting point
    /// * `radius1` - The radius of the cylinder at the ending point
    /// * `resolution` - The number of subdivisions around the circumference of the cylinder
    ///
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::*;
    /// cgl_rs::init();
    /// {
    ///    let mesh = cgl_rs::graphics::MeshCPU::new(100, 100).unwrap();
    ///    mesh.add_cylinder(Vector3::new(0.0, 0.0, 0.0), Vector3::new(0.0, 1.0, 0.0), 0.5, 0.5, 10);
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn add_cylinder(&self, start: Vector3, end: Vector3, radius0: f32, radius1: f32, resolution: i32) {
        unsafe {
            CGL_mesh_cpu_add_cylinder(self.handle, start, end, radius0, radius1, resolution);
        }
    }

    // Offsets the vertices of this MeshCPU object by a given vector.
    ///
    /// # Arguments
    ///
    /// * `offset` - The vector by which to offset the vertices
    ///
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::*;
    /// cgl_rs::init();
    /// {
    ///    let mesh = cgl_rs::graphics::MeshCPU::new(100, 100).unwrap();
    ///    mesh.offset_vertices(Vector3::new(1.0, 0.0, 0.0));
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn offset_vertices(&self, offset: Vector3) {
        unsafe {
            CGL_mesh_cpu_offset_vertices(self.handle, offset);
        }
    }

    // Scales the vertices of this MeshCPU object by a given factor.
    ///
    /// # Arguments
    ///
    /// * `scale` - The factor by which to scale the vertices
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///    let mesh = cgl_rs::graphics::MeshCPU::new(100, 100).unwrap();
    ///    mesh.scale_vertices(2.0);
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn scale_vertices(&self, scale: f32) {
        unsafe {
            CGL_mesh_cpu_scale_vertices(self.handle, scale);
        }
    }

    // Transforms the vertices of this MeshCPU object by a given transformation matrix.
    ///
    /// # Arguments
    ///
    /// * `transform` - The transformation matrix by which to transform the vertices
    ///
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::*;
    /// cgl_rs::init();
    /// {
    ///    let mesh = cgl_rs::graphics::MeshCPU::new(100, 100).unwrap();
    ///    let transform = Matrix4x4::identity();
    ///    mesh.transform_vertices(&transform);
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn transform_vertices(&self, transform: &Matrix4x4) {
        unsafe {
            CGL_mesh_cpu_transform_vertices(self.handle, transform);
        }
    }

    /// Destroy the MeshCPU object
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// {
    ///    let mut mesh = cgl_rs::graphics::MeshCPU::new(3, 3).unwrap();
    ///    mesh.destroy(); // or just let the mesh go out of scope
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn destroy(&mut self) {
        if !self.has_been_destroyed {
            unsafe {
                CGL_mesh_cpu_destroy(self.handle);
            }
            self.has_been_destroyed = true;
        }
    }

    /// Recalculates the normals of the mesh
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// {
    ///     let mesh = cgl_rs::graphics::MeshCPU::new(3, 3).unwrap();
    ///     mesh.recalculate_normals();
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn recalculate_normals(&self) {
        unsafe {
            CGL_mesh_cpu_recalculate_normals(self.handle);
        }
    }


    // Get the vertex at the specified index.
    ///
    /// # Arguments
    ///
    /// * `index` - The index of the vertex to retrieve
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     let mesh = cgl_rs::graphics::MeshCPU::new(3, 3).unwrap();
    ///     let vertex = mesh.get_vertex(0);
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn get_vertex(&self, index: usize) -> &MeshVertex {
        unsafe {
            let vertex_array = self.handle.as_ref().unwrap().vertices;
            vertex_array.offset(index as isize).as_ref().unwrap()
        }
    }

    // Set the vertex at the specified index.
    ///
    /// # Arguments
    ///
    /// * `index` - The index of the vertex to set
    /// * `vertex` - The vertex to set
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     let mesh = cgl_rs::graphics::MeshCPU::new(3, 3).unwrap();
    ///     let vertex = cgl_rs::graphics::MeshVertex::new();
    ///     mesh.set_vertex(0, &vertex);
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_vertex(&self, index: usize, vertex: &MeshVertex) {
        unsafe {
            let vertex_array = self.handle.as_ref().unwrap().vertices;
            let vertex_ptr = vertex_array.offset(index as isize);
            *vertex_ptr = *vertex;
        }
    }

    // Get the index at the specified index.
    ///
    /// # Arguments
    ///
    /// * `index` - The index of the index to retrieve
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     let mesh = cgl_rs::graphics::MeshCPU::new(3, 3).unwrap();
    ///     let index = mesh.get_index(0);
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn get_index(&self, index: usize) -> u32 {
        unsafe {
            let index_array = self.handle.as_ref().unwrap().indices;
            *index_array.offset(index as isize)
        }
    }

    // Set the index at the specified index.
    ///
    /// # Arguments
    ///
    /// * `index` - The index of the index to set
    /// * `value` - The value to set
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     let mesh = cgl_rs::graphics::MeshCPU::new(3, 3).unwrap();
    ///     mesh.set_index(0, 1);
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_index(&self, index: usize, value: u32) {
        unsafe {
            let index_array = self.handle.as_ref().unwrap().indices;
            let index_ptr = index_array.offset(index as isize);
            *index_ptr = value;
        }
    }


}

impl Drop for MeshCPU {
    fn drop(&mut self) {
        self.destroy();
    }
}

impl Clone for MeshCPU {
    fn clone(&self) -> Self {
        MeshCPU {
            handle: self.handle.clone(),
            has_been_destroyed: true
        }
    }
}


impl MeshGPU {

    /// Creates a new MeshGPU instance.
    ///
    /// # Returns
    ///
    /// Returns a `Result` containing a `MeshGPU` instance if successful, or a `&'static str` error message if unsuccessful.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::window::Window::new("Test Window", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let mesh = cgl_rs::graphics::MeshGPU::new().unwrap();
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn new() -> Result<MeshGPU, &'static str> {
        let handle = unsafe {
            CGL_mesh_gpu_create()
        };
        if handle.is_null() {
            Err("Failed to create MeshGPU")
        } else {
            Ok(MeshGPU {
                handle: handle,
                has_been_destroyed: false
            })
        }
    }


    /// Renders the mesh using the GPU.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::window::Window::new("Test Window", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let mesh = cgl_rs::graphics::MeshGPU::new().unwrap();
    ///     mesh.render();
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn render(&self) {
        unsafe {
            CGL_mesh_gpu_render(self.handle);
        }
    }

    /// Renders the mesh using the GPU with instancing.
    ///
    /// * `instance_count` - The number of instances to render.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::window::Window::new("Test Window", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let mesh = cgl_rs::graphics::MeshGPU::new().unwrap();
    ///     mesh.render_instanced(10);
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn render_instanced(&self, instance_count: u32) {
        unsafe {
            CGL_mesh_gpu_render_instanced(self.handle, instance_count);
        }
    }

    /// Uploads the mesh data to the GPU.
    ///
    /// * `mesh_cpu` - The mesh data to upload.
    /// * `static_draw` - Whether the mesh data is static or dynamic.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::window::Window::new("Test Window", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let mut mesh_cpu = cgl_rs::graphics::MeshCPU::new(3, 3).unwrap();
    ///     let mut mesh_gpu = cgl_rs::graphics::MeshGPU::new().unwrap();
    ///     mesh_gpu.upload(&mesh_cpu, true);
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn upload(&mut self, mesh_cpu: &MeshCPU, static_draw: bool) {
        unsafe {
            CGL_mesh_gpu_upload(self.handle, mesh_cpu.handle, static_draw as i32);
        }
    }

    /// Destroys the mesh GPU handle if it has not already been destroyed.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::window::Window::new("Test Window", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let mut mesh = cgl_rs::graphics::MeshGPU::new().unwrap();
    ///     mesh.destroy();
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn destroy(&mut self) {
        if !self.has_been_destroyed {
            unsafe {
                CGL_mesh_gpu_destroy(self.handle);
            }
            self.has_been_destroyed = true;
        }
    }

}

impl Drop for MeshGPU {
    fn drop(&mut self) {
        self.destroy();
    }
}

impl Clone for MeshGPU {
    fn clone(&self) -> Self {
        MeshGPU {
            handle: self.handle.clone(),
            has_been_destroyed: true
        }
    }
}
```

`rust_wrapper/cgl-rs/src/graphics/shader.rs`:

```rs
//! The Shader module for CGL

#![allow(non_camel_case_types)]
use libc::{c_void, c_int, c_char, c_float, c_double};

/// The internal window handle used by CGL
#[repr(C)]
pub(crate) struct CGL_shader {
    _private: c_void
}

extern {
   fn CGL_shader_create(vertex_shader_source: *const c_char, fragment_shader_source: *const c_char, error: *mut *mut c_char) -> *mut CGL_shader;
   fn CGL_shader_compute_create(compute_shader_source: *const c_char, error: *mut *mut c_char) -> *mut CGL_shader;
   fn CGL_shader_create_from_files(vertex_shader_file: *const c_char, fragment_shader_file: *const c_char, error: *mut *mut c_char) -> *mut CGL_shader;
   fn CGL_shader_compute_create_from_files(compute_shader_file: *const c_char, error: *mut *mut c_char) -> *mut CGL_shader;
   fn CGL_shader_destroy(shader: *mut CGL_shader) -> ();
   fn CGL_shader_bind(shader: *mut CGL_shader) -> ();
   fn CGL_shader_get_uniform_location(shader: *mut CGL_shader, name: *const c_char) -> c_int;
   fn CGL_shader_set_uniform_mat4(shader: *mut CGL_shader, location: c_int, matrix: *const crate::math::Matrix4x4) -> ();
   fn CGL_shader_set_uniform_vec4(shader: *mut CGL_shader, location: c_int, vector: *const crate::math::Vector4) -> ();
   fn CGL_shader_set_uniform_vec3(shader: *mut CGL_shader, location: c_int, vector: *const crate::math::Vector3) -> ();
   fn CGL_shader_set_uniform_vec2(shader: *mut CGL_shader, location: c_int, vector: *const crate::math::Vector2) -> ();
   fn CGL_shader_set_uniform_int(shader: *mut CGL_shader, location: c_int, value: c_int) -> ();
   fn CGL_shader_set_uniform_bool(shader: *mut CGL_shader, location: c_int, value: c_int) -> ();
   fn CGL_shader_set_uniform_float(shader: *mut CGL_shader, location: c_int, value: c_float) -> ();
   fn CGL_shader_set_uniform_double(shader: *mut CGL_shader, location: c_int, value: c_double) -> ();
   fn CGL_shader_set_uniform_vec2v(shader: *mut CGL_shader, location: c_int, x: c_float, y: c_float) -> ();
   fn CGL_shader_set_uniform_vec3v(shader: *mut CGL_shader, location: c_int, x: c_float, y: c_float, z: c_float) -> ();
   fn CGL_shader_set_uniform_vec4v(shader: *mut CGL_shader, location: c_int, x: c_float, y: c_float, z: c_float, w: c_float) -> ();
   fn CGL_shader_set_uniform_ivec2v(shader: *mut CGL_shader, location: c_int, x: c_int, y: c_int) -> ();
   fn CGL_shader_set_uniform_ivec3v(shader: *mut CGL_shader, location: c_int, x: c_int, y: c_int, z: c_int) -> ();
   fn CGL_shader_set_uniform_ivec4v(shader: *mut CGL_shader, location: c_int, x: c_int, y: c_int, z: c_int, w: c_int) -> ();
   fn CGL_shader_set_user_data(shader: *mut CGL_shader, user_data: *mut c_void) -> ();
   fn CGL_shader_get_user_data(shader: *mut CGL_shader) -> *mut c_void;
   fn CGL_shader_compute_dispatch(shader: *mut CGL_shader, x: c_int, y: c_int, z: c_int) -> ();
}

/// A shader object
#[derive(Debug)]
pub struct Shader {
    handle: *mut CGL_shader,
    has_been_destroyed: bool,
    uniform_locations: std::collections::HashMap<String, i32>
}


const BASIC_VERTEX_SHADER: &str = r#"#version 430 core

layout (location = 0) in vec3 aPos;

void main()
{
    gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);
}
"#;

const BASIC_FRAGMENT_SHADER: &str = r#"#version 430 core

out vec4 FragColor;

void main()
{
    FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);
}
"#;

const BASIC_COMPUTE_SHADER: &str = r#"#version 430 core

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

void main()
{
    // Do nothing
}
"#;

impl Shader {

    /// Creates a new shader object from the provided vertex and fragment shader source code.
    ///
    /// # Arguments
    ///
    /// * `vertex_shader_source` - The source code for the vertex shader.
    /// * `fragment_shader_source` - The source code for the fragment shader.
    ///
    /// # Returns
    ///
    /// Returns a `Result` containing the newly created `Shader` object if successful, or a `String` containing an error message if unsuccessful.
    ///
    /// # Example
    ///
    /// ```no_run
    /// let vertex_shader_source = r#"#version 430 core
    ///
    ///     layout (location = 0) in vec3 aPos;
    ///
    ///     void main()
    ///     {
    ///         gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);
    ///     }
    /// "#;
    ///
    /// let fragment_shader_source = r#"#version 430 core
    ///
    ///     out vec4 FragColor;
    ///
    ///     void main()
    ///     {
    ///         FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);
    ///     }
    /// "#;
    ///
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello World", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let shader = cgl_rs::graphics::Shader::from_source(vertex_shader_source, fragment_shader_source).unwrap();
    ///    // Do stuff with the shader
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn from_source(vertex_shader_source: &str, fragment_shader_source: &str) -> Result<Shader, String> {
        let mut error_string_ptr: *mut c_char = std::ptr::null_mut();
        let error_string_ptr_ptr: *mut *mut c_char = &mut error_string_ptr;
        let handle = unsafe {
            let vertex_shader_source_c = std::ffi::CString::new(vertex_shader_source).unwrap();
            let fragment_shader_source_c = std::ffi::CString::new(fragment_shader_source).unwrap();
            CGL_shader_create(vertex_shader_source_c.as_ptr(), fragment_shader_source_c.as_ptr(), error_string_ptr_ptr)
        };
        if handle.is_null() {
            let error_string = unsafe { std::ffi::CStr::from_ptr(*error_string_ptr_ptr) };
            let error_string = error_string.to_str().unwrap();
            unsafe { libc::free(error_string_ptr as *mut c_void) };
            return Err(error_string.to_string());
        }
        Ok(Shader {
            handle,
            has_been_destroyed: false,
            uniform_locations: std::collections::HashMap::new()
        })
    }

    /// Creates a new shader object from the provided vertex and fragment shader source files.
    ///
    /// # Arguments
    ///
    /// * `vertex_shader_path` - The path to the file containing the source code for the vertex shader.
    /// * `fragment_shader_path` - The path to the file containing the source code for the fragment shader.
    ///
    /// # Returns
    ///
    /// Returns a `Result` containing the newly created `Shader` object if successful, or a `String` containing an error message if unsuccessful.
    ///
    /// # Example
    ///
    /// ```no_run
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello World", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let shader = cgl_rs::graphics::Shader::from_files("path/to/vertex_shader.glsl", "path/to/fragment_shader.glsl").unwrap();
    ///    // Do stuff with the shader
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn from_files(vertex_shader_path: &str, fragment_shader_path: &str) -> Result<Shader, String> {
        let mut error_string_ptr: *mut c_char = std::ptr::null_mut();
        let error_string_ptr_ptr: *mut *mut c_char = &mut error_string_ptr;
        let handle = unsafe {
            let vertex_shader_path_c = std::ffi::CString::new(vertex_shader_path).unwrap();
            let fragment_shader_path_c = std::ffi::CString::new(fragment_shader_path).unwrap();
            CGL_shader_create_from_files(vertex_shader_path_c.as_ptr(), fragment_shader_path_c.as_ptr(), error_string_ptr_ptr)
        };
        if handle.is_null() {
            let error_string = unsafe { std::ffi::CStr::from_ptr(*error_string_ptr_ptr) };
            let error_string = error_string.to_str().unwrap();
            unsafe { libc::free(error_string_ptr as *mut c_void) };
            return Err(error_string.to_string());
        }
        Ok(Shader {
            handle,
            has_been_destroyed: false,
            uniform_locations: std::collections::HashMap::new()
        })
    }

    /// Creates a new compute shader object from the provided compute shader source code.
    ///
    /// # Arguments
    ///
    /// * `compute_shader_source` - The source code for the compute shader.
    ///
    /// # Returns
    ///
    /// Returns a `Result` containing the newly created `Shader` object if successful, or a `String` containing an error message if unsuccessful.
    ///
    /// # Example
    ///
    /// ```no_run
    /// let compute_shader_source = r#"#version 430 core
    /// 
    ///    layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
    /// 
    ///    void main()
    ///    {
    ///       // Do stuff
    ///    }
    /// "#;
    /// 
    /// 
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello World", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let shader = cgl_rs::graphics::Shader::compute_from_source("path/to/compute_shader.glsl").unwrap();
    ///    // Do stuff with the shader
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn compute_from_source(compute_shader_source: &str) -> Result<Shader, String> {
        let mut error_string_ptr: *mut c_char = std::ptr::null_mut();
        let error_string_ptr_ptr: *mut *mut c_char = &mut error_string_ptr;
        let handle = unsafe {
            let compute_shader_source_c = std::ffi::CString::new(compute_shader_source).unwrap();
            CGL_shader_compute_create(compute_shader_source_c.as_ptr(), error_string_ptr_ptr)
        };
        if handle.is_null() {
            let error_string = unsafe { std::ffi::CStr::from_ptr(*error_string_ptr_ptr) };
            let error_string = error_string.to_str().unwrap();
            unsafe { libc::free(error_string_ptr as *mut c_void) };
            return Err(error_string.to_string());
        }
        Ok(Shader {
            handle,
            has_been_destroyed: false,
            uniform_locations: std::collections::HashMap::new()
        })
    }

    /// Creates a new compute shader object from the provided compute shader file.
    ///
    /// # Arguments
    ///
    /// * `compute_shader_path` - The path to the compute shader file.
    ///
    /// # Returns
    ///
    /// Returns a `Result` containing the newly created `Shader` object if successful, or a `String` containing an error message if unsuccessful.
    ///
    /// # Example
    ///
    /// ```no_run
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello World", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let shader = cgl_rs::graphics::Shader::compute_from_files("path/to/compute_shader.glsl").unwrap();
    ///    // Do stuff with the shader
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn compute_from_files(compute_shader_path: &str) -> Result<Shader, String> {
        let mut error_string_ptr: *mut c_char = std::ptr::null_mut();
        let error_string_ptr_ptr: *mut *mut c_char = &mut error_string_ptr;
        let handle = unsafe {
            let compute_shader_path_c = std::ffi::CString::new(compute_shader_path).unwrap();
            CGL_shader_compute_create_from_files(compute_shader_path_c.as_ptr(), error_string_ptr_ptr)
        };
        if handle.is_null() {
            let error_string = unsafe { std::ffi::CStr::from_ptr(*error_string_ptr_ptr) };
            let error_string = error_string.to_str().unwrap();
            unsafe { libc::free(error_string_ptr as *mut c_void) };
            return Err(error_string.to_string());
        }
        Ok(Shader {
            handle,
            has_been_destroyed: false,
            uniform_locations: std::collections::HashMap::new()
        })
    }

    /// Creates a basic compute shader object with a simple compute shader.
    ///
    /// # Returns
    ///
    /// Returns a `Result` containing the newly created `Shader` object if successful, or a `String` containing an error message if unsuccessful.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello World", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let shader = cgl_rs::graphics::Shader::create_dummy_compute().unwrap();
    ///    // Do stuff with the shader
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn create_dummy_compute() -> Result<Shader, String> {
        Shader::compute_from_source(BASIC_COMPUTE_SHADER)
    }

    /// Creates a basic shader object with a simple vertex and fragment shader.
    ///
    /// # Returns
    ///
    /// Returns a `Result` containing the newly created `Shader` object if successful, or a `String` containing an error message if unsuccessful.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello World", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let shader = cgl_rs::graphics::Shader::create_dummy().unwrap();
    ///    // Do stuff with the shader
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn create_dummy() -> Result<Shader, String> {
        Shader::from_source(BASIC_VERTEX_SHADER, BASIC_FRAGMENT_SHADER)
    }

    /// Destroys the shader object.
    ///
    /// # Remarks
    ///
    /// This function destroys the shader object and frees any resources associated with it. If the shader object has already been destroyed, this function does nothing.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello World", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let mut shader = cgl_rs::graphics::Shader::create_dummy().unwrap();
    ///    // Do stuff with the shader
    ///    shader.destroy();
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn destroy(&mut self) {
        if !self.has_been_destroyed {
            unsafe {
                CGL_shader_destroy(self.handle);
            }
            self.has_been_destroyed = true;
        }
    }


    /// Retrieves the location of0 a uniform variable in the shader program.
    ///
    /// # Arguments
    ///
    /// * `uniform_name` - A string slice containing the name of the uniform variable.
    ///
    /// # Returns
    ///
    /// Returns an `i32` representing the location of the uniform variable in the shader program.
    ///
    /// # Remarks
    ///
    /// This function caches the uniform location for future use, so it is more efficient to call this function once and store the result than to call it repeatedly.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello World", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let mut shader = cgl_rs::graphics::Shader::create_dummy().unwrap();
    ///     let uniform_location = shader.get_uniform_location("uniform_name");
    ///     // Do stuff with the uniform location
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn get_uniform_location(&mut self, uniform_name: &str) -> i32 {
        if self.uniform_locations.contains_key(uniform_name) {
            return self.uniform_locations[uniform_name];
        }
        let uniform_name_c = std::ffi::CString::new(uniform_name).unwrap();
        let location = unsafe {
            CGL_shader_get_uniform_location(self.handle, uniform_name_c.as_ptr()) as i32
        };
        self.uniform_locations.insert(uniform_name.to_string(), location);
        location
    }


    
    /// Sets the value of a uniform variable of type Vector2 in the shader program.
    ///
    /// # Arguments
    ///
    /// * `uniform_name` - A string slice containing the name of the uniform variable.
    /// * `value` - A reference to a Vector2 containing the value to set.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello World", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let mut shader = cgl_rs::graphics::Shader::create_dummy().unwrap();
    ///     let vec2 = cgl_rs::math::Vector2::new(1.0, 2.0);
    ///     shader.set_vec2("uniform_name", &vec2);
    ///     // Do stuff with the uniform variable
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_vec2(&mut self, uniform_name: &str, value: &crate::math::Vector2) {
        let location = self.get_uniform_location(uniform_name);
        unsafe {
            CGL_shader_set_uniform_vec2(self.handle, location, value);
        }
    }
    
    /// Sets the value of a uniform variable of type Vector3 in the shader program.
    ///
    /// # Arguments
    ///
    /// * `uniform_name` - A string slice containing the name of the uniform variable.
    /// * `value` - A reference to a Vector3 containing the value to set.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello World", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let mut shader = cgl_rs::graphics::Shader::create_dummy().unwrap();
    ///     let vec3 = cgl_rs::math::Vector3::new(1.0, 2.0, 3.0);
    ///     shader.set_vec3("uniform_name", &vec3);
    ///     // Do stuff with the uniform variable
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_vec3(&mut self, uniform_name: &str, value: &crate::math::Vector3) {
        let location = self.get_uniform_location(uniform_name);
        unsafe {
            CGL_shader_set_uniform_vec3(self.handle, location, value);
        }
    }
    
    /// Sets the value of a uniform variable of type Vector4 in the shader program.
    ///
    /// # Arguments
    ///
    /// * `uniform_name` - A string slice containing the name of the uniform variable.
    /// * `value` - A reference to a Vector4 containing the value to set.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello World", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let mut shader = cgl_rs::graphics::Shader::create_dummy().unwrap();
    ///     let vec4 = cgl_rs::math::Vector4::new(1.0, 2.0, 3.0, 4.0);
    ///     shader.set_vec4("uniform_name", &vec4);
    ///     // Do stuff with the uniform variable
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_vec4(&mut self, uniform_name: &str, value: &crate::math::Vector4) {
        let location = self.get_uniform_location(uniform_name);
        unsafe {
            CGL_shader_set_uniform_vec4(self.handle, location, value);
        }
    }
    
    /// Sets the value of a uniform variable of type Matrix4x4 in the shader program.
    ///
    /// # Arguments
    ///
    /// * `uniform_name` - A string slice containing the name of the uniform variable.
    /// * `value` - A reference to a Matrix4x4 containing the value to set.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello World", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let mut shader = cgl_rs::graphics::Shader::create_dummy().unwrap();
    ///     let mat4 = cgl_rs::math::Matrix4x4::identity();
    ///     shader.set_mat4("uniform_name", &mat4);
    ///     // Do stuff with the uniform variable
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_mat4(&mut self, uniform_name: &str, value: &crate::math::Matrix4x4) {
        let location = self.get_uniform_location(uniform_name);
        unsafe {
            CGL_shader_set_uniform_mat4(self.handle, location, value);
        }
    }
    
    /// Sets the value of a uniform variable of type i32 in the shader program.
    ///
    /// # Arguments
    ///
    /// * `uniform_name` - A string slice containing the name of the uniform variable.
    /// * `value` - An i32 value containing the value to set.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello World", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let mut shader = cgl_rs::graphics::Shader::create_dummy().unwrap();
    ///     shader.set_int("uniform_name", 42);
    ///     // Do stuff with the uniform variable
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_int(&mut self, uniform_name: &str, value: i32) {
        let location = self.get_uniform_location(uniform_name);
        unsafe {
            CGL_shader_set_uniform_int(self.handle, location, value);
        }
    }

    /// Sets the value of a uniform variable of type bool in the shader program.
    ///
    /// # Arguments
    ///
    /// * `uniform_name` - A string slice containing the name of the uniform variable.
    /// * `value` - A boolean value containing the value to set.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello World", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let mut shader = cgl_rs::graphics::Shader::create_dummy().unwrap();
    ///     shader.set_bool("uniform_name", true);
    ///     // Do stuff with the uniform variable
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_bool(&mut self, uniform_name: &str, value: bool) {
        let location = self.get_uniform_location(uniform_name);
        unsafe {
            CGL_shader_set_uniform_bool(self.handle, location, value as i32);
        }
    }

    /// Sets the value of a uniform variable of type float in the shader program.
    ///
    /// # Arguments
    ///
    /// * `uniform_name` - A string slice containing the name of the uniform variable.
    /// * `value` - A f32 value containing the value to set.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello World", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let mut shader = cgl_rs::graphics::Shader::create_dummy().unwrap();
    ///     shader.set_float("uniform_name", 3.14);
    ///     // Do stuff with the uniform variable
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_float(&mut self, uniform_name: &str, value: f32) {
        let location = self.get_uniform_location(uniform_name);
        unsafe {
            CGL_shader_set_uniform_float(self.handle, location, value);
        }
    }

    /// Sets the value of a uniform variable of type double in the shader program.
    /// 
    /// # Arguments
    /// 
    /// * `uniform_name` - A string slice containing the name of the uniform variable.
    /// * `value` - A f64 value containing the value to set.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello World", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let mut shader = cgl_rs::graphics::Shader::create_dummy().unwrap();
    ///    shader.set_double("uniform_name", 3.14);
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_double(&mut self, uniform_name: &str, value: f64) {
        let location = self.get_uniform_location(uniform_name);
        unsafe {
            CGL_shader_set_uniform_double(self.handle, location, value);
        }
    }


    /// Sets the value of a uniform variable of type vec2 in the shader program.
    ///
    /// # Arguments
    ///
    /// * `uniform_name` - A string slice containing the name of the uniform variable.
    /// * `x` - A f32 value containing the x component of the vector.
    /// * `y` - A f32 value containing the y component of the vector.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello World", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let mut shader = cgl_rs::graphics::Shader::create_dummy().unwrap();
    ///     shader.set_vec2v("uniform_name", 1.0, 2.0);
    ///     // Do stuff with the uniform variable
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_vec2v(&mut self, uniform_name: &str, x: f32, y: f32) {
        let location = self.get_uniform_location(uniform_name);
        unsafe {
            CGL_shader_set_uniform_vec2v(self.handle, location, x, y);
        }
    }

    /// Sets the value of a uniform variable of type vec3 in the shader program.
    ///
    /// # Arguments
    ///
    /// * `uniform_name` - A string slice containing the name of the uniform variable.
    /// * `x` - A f32 value containing the x component of the vector.
    /// * `y` - A f32 value containing the y component of the vector.
    /// * `z` - A f32 value containing the z component of the vector.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello World", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let mut shader = cgl_rs::graphics::Shader::create_dummy().unwrap();
    ///     shader.set_vec3v("uniform_name", 1.0, 2.0, 3.0);
    ///     // Do stuff with the uniform variable
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_vec3v(&mut self, uniform_name: &str, x: f32, y: f32, z: f32) {
        let location = self.get_uniform_location(uniform_name);
        unsafe {
            CGL_shader_set_uniform_vec3v(self.handle, location, x, y, z);
        }
    }

    /// Sets the value of a uniform variable of type vec4 in the shader program.
    ///
    /// # Arguments
    ///
    /// * `uniform_name` - A string slice containing the name of the uniform variable.
    /// * `x` - A f32 value containing the x component of the vector.
    /// * `y` - A f32 value containing the y component of the vector.
    /// * `z` - A f32 value containing the z component of the vector.
    /// * `w` - A f32 value containing the w component of the vector.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello World", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let mut shader = cgl_rs::graphics::Shader::create_dummy().unwrap();
    ///     shader.set_vec4v("uniform_name", 1.0, 2.0, 3.0, 4.0);
    ///     // Do stuff with the uniform variable
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_vec4v(&mut self, uniform_name: &str, x: f32, y: f32, z: f32, w: f32) {
        let location = self.get_uniform_location(uniform_name);
        unsafe {
            CGL_shader_set_uniform_vec4v(self.handle, location, x, y, z, w);
        }
    }

    /// Sets the value of a uniform variable of type ivec2 in the shader program.
    ///
    /// # Arguments
    ///
    /// * `uniform_name` - A string slice containing the name of the uniform variable.
    /// * `x` - An i32 value containing the x component of the vector.
    /// * `y` - An i32 value containing the y component of the vector.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello World", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let mut shader = cgl_rs::graphics::Shader::create_dummy().unwrap();
    ///     shader.set_ivec2v("uniform_name", 1, 2);
    ///     // Do stuff with the uniform variable
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_ivec2v(&mut self, uniform_name: &str, x: i32, y: i32) {
        let location = self.get_uniform_location(uniform_name);
        unsafe {
            CGL_shader_set_uniform_ivec2v(self.handle, location, x, y);
        }
    }

    /// Sets the value of a uniform variable of type ivec3 in the shader program.
    ///
    /// # Arguments
    ///
    /// * `uniform_name` - A string slice containing the name of the uniform variable.
    /// * `x` - An i32 value containing the x component of the vector.
    /// * `y` - An i32 value containing the y component of the vector.
    /// * `z` - An i32 value containing the z component of the vector.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello World", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let mut shader = cgl_rs::graphics::Shader::create_dummy().unwrap();
    ///     shader.set_ivec3v("uniform_name", 1, 2, 3);
    ///     // Do stuff with the uniform variable
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_ivec3v(&mut self, uniform_name: &str, x: i32, y: i32, z: i32) {
        let location = self.get_uniform_location(uniform_name);
        unsafe {
            CGL_shader_set_uniform_ivec3v(self.handle, location, x, y, z);
        }
    }

    /// Sets the value of a uniform variable of type ivec4 in the shader program.
    ///
    /// # Arguments
    ///
    /// * `uniform_name` - A string slice containing the name of the uniform variable.
    /// * `x` - An i32 value containing the x component of the vector.
    /// * `y` - An i32 value containing the y component of the vector.
    /// * `z` - An i32 value containing the z component of the vector.
    /// * `w` - An i32 value containing the w component of the vector.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello World", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let mut shader = cgl_rs::graphics::Shader::create_dummy().unwrap();
    ///     shader.set_ivec4v("uniform_name", 1, 2, 3, 4);
    ///     // Do stuff with the uniform variable
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_ivec4v(&mut self, uniform_name: &str, x: i32, y: i32, z: i32, w: i32) {
        let location = self.get_uniform_location(uniform_name);
        unsafe {
            CGL_shader_set_uniform_ivec4v(self.handle, location, x, y, z, w);
        }
    }

    /// Dispatches a compute shader with the specified number of work groups.
    ///
    /// # Arguments
    ///
    /// * `x` - An i32 value containing the number of work groups in the x dimension.
    /// * `y` - An i32 value containing the number of work groups in the y dimension.
    /// * `z` - An i32 value containing the number of work groups in the z dimension.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello World", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let shader = cgl_rs::graphics::Shader::create_dummy_compute().unwrap();
    ///     shader.dispatch(1, 1, 1);
    ///     // Do stuff with the compute shader
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn dispatch(&self, x: i32, y: i32, z: i32) {
        unsafe {
            CGL_shader_compute_dispatch(self.handle, x, y, z);
        }
    }
}

impl Drop for Shader {
    fn drop(&mut self) {
        self.destroy();
    }
}


impl Clone for Shader {
    /// Clones the shader object.
    ///
    /// NOTE: The new instance will have the same handle, `has_been_destroyed` flag.
    ///       This means that the new instance will not be able to receive events nor will the internal window handle be
    ///       destroyed when the new instance is dropped. The internal window handle will be destroyed when the original
    ///       instance is dropped.
    /// 
    /// 
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window =  cgl_rs::Window::new("Hello World", 600, 800).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let shader = cgl_rs::graphics::Shader::create_dummy().unwrap();
    ///     let shader2 = shader.clone();
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    fn clone(&self) -> Self {
        Shader {
            handle: self.handle.clone(),
            has_been_destroyed: true,
            uniform_locations: self.uniform_locations.clone()
        }
    }
}
```

`rust_wrapper/cgl-rs/src/graphics/ssbo.rs`:

```rs
//! The SSBO module for CGL

#![allow(non_camel_case_types)]
use libc::{c_void, c_int, size_t};

/// The internal handle used by CGL
#[repr(C)]
pub(crate) struct CGL_ssbo {
    _private: c_void
}


/// The Shader Storage Buffer Object
pub struct ShaderStorageBufferObject {
    pub(crate) handle: *mut CGL_ssbo,
    pub(crate) has_been_destroyed: bool
}

// This is just an alias for ShaderStorageBufferObject
pub type SSBO = ShaderStorageBufferObject; 


extern {
    fn CGL_ssbo_create(binding: u32) -> *mut CGL_ssbo;
    fn CGL_ssbo_destroy(ssbo: *mut CGL_ssbo);
    fn CGL_ssbo_bind(ssbo: *mut CGL_ssbo);
    fn CGL_ssbo_bind2(ssbo: *mut CGL_ssbo, binding: u32);
    fn CGL_ssbo_set_data(ssbo: *mut CGL_ssbo, size: size_t, data: *mut c_void, static_draw: c_int);
    fn CGL_ssbo_set_sub_data(ssbo: *mut CGL_ssbo, offset: size_t, size: size_t, data: *mut c_void, static_draw: c_int);
    fn CGL_ssbo_get_data(ssbo: *mut CGL_ssbo, size: *mut size_t, data: *mut c_void);
    fn CGL_ssbo_get_sub_data(ssbo: *mut CGL_ssbo, offset: size_t, size: size_t, data: *mut c_void);
    fn CGL_ssbo_set_user_data(ssbo: *mut CGL_ssbo, user_data: *mut c_void);
    fn CGL_ssbo_get_user_data(ssbo: *mut CGL_ssbo) -> *mut c_void;
    fn CGL_ssbo_get_size(ssbo: *mut CGL_ssbo) -> size_t;
    fn CGL_ssbo_copy(dst: *mut CGL_ssbo, src: *mut CGL_ssbo, src_offset: size_t, dst_offset: size_t, size: size_t);
}



impl ShaderStorageBufferObject {

    /// Creates a new Shader Storage Buffer Object with the specified binding.
    /// 
    /// # Arguments
    /// 
    /// * `binding` - The binding point for the SSBO.
    /// 
    /// # Returns
    /// 
    /// A new instance of `ShaderStorageBufferObject` with the specified binding, or `Err(())` if the creation failed.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let mut ssbo = cgl_rs::graphics::ShaderStorageBufferObject::new(0).unwrap();
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn new(binding: u32) -> Result<ShaderStorageBufferObject, ()> {
        let handle = unsafe { CGL_ssbo_create(binding) };
        if handle.is_null() {
            Err(())
        } else {
            Ok(ShaderStorageBufferObject {
                handle,
                has_been_destroyed: false
            })
        }
    }

    /// Creates a new Shader Storage Buffer Object with the specified binding and sets its data to the provided byte slice.
    /// 
    /// # Arguments
    /// 
    /// * `data` - The byte slice containing the data to be set.
    /// * `binding` - The binding point for the SSBO.
    /// 
    /// # Returns
    /// 
    /// A new instance of `ShaderStorageBufferObject` with the specified binding and data, or `Err(())` if the creation failed.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let data = vec![0u8; 1024];
    ///     let ssbo = cgl_rs::graphics::ShaderStorageBufferObject::from(&data, 0).unwrap();
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn from(data: &[u8], binding: u32) -> Result<ShaderStorageBufferObject, ()> {
        let mut ssbo = ShaderStorageBufferObject::new(binding)?;
        ssbo.set_data(data.len(), data.as_ptr() as *mut u8, false);
        Ok(ssbo)
    }
   
    /// Destroys the ssbo and frees its resources. If it has already been destroyed, this method does nothing.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let mut texture = cgl_rs::graphics::Texture::dummy().unwrap();
    ///     texture.destroy(); // optional
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn destroy(&mut self) {
        if !self.has_been_destroyed {
            unsafe {
                CGL_ssbo_destroy(self.handle);
            }
            self.has_been_destroyed = true;
        }
    }

    /// Binds the Shader Storage Buffer Object to the current context.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let ssbo = cgl_rs::graphics::ShaderStorageBufferObject::new(0).unwrap();
    ///   ssbo.bind();
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn bind(&self) {
        unsafe {
            CGL_ssbo_bind(self.handle);
        }
    }
    

    /// Binds the Shader Storage Buffer (Base)  to the specified binding point.
    /// 
    /// # Arguments
    /// 
    /// * `binding` - The binding point to bind the Shader Storage Buffer Object to.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let mut ssbo = cgl_rs::graphics::ShaderStorageBufferObject::new(0).unwrap();
    ///    ssbo.bind2(1);
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn bind2(&mut self, binding: u32) {
        unsafe {
            CGL_ssbo_bind2(self.handle, binding);
        }
    }

    /// Sets the data of the Shader Storage Buffer Object.
    /// This also allocates the memory on the GPU if necessary.
    /// 
    /// If you only want to update a part of the data, use `set_sub_data` instead.
    /// 
    /// # Arguments
    /// 
    /// * `size` - The size of the data in bytes.
    /// * `data` - A pointer to the data.
    /// * `static_draw` - A flag indicating whether the data is static or not.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let mut ssbo = cgl_rs::graphics::ShaderStorageBufferObject::new(0).unwrap();
    ///    let data: [u8; 4] = [0, 1, 2, 3];
    ///    ssbo.set_data(data.len(), data.as_ptr() as *mut u8, true);
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    /// 
    /// # See also
    /// 
    /// * `set_sub_data`
    pub fn set_data(&mut self, size: usize, data: *mut u8, static_draw: bool) {
        unsafe {
            CGL_ssbo_set_data(self.handle, size, data as *mut c_void, static_draw as c_int);
        }
    }

    /// Sets a portion of the data of the Shader Storage Buffer Object.
    /// 
    /// Note: This does not allocate the memory on the GPU if necessary. 
    ///       So, if the data is not allocated on the GPU, this method will do nothing.
    ///       To allocate the memory on the GPU, use `set_data` instead.
    /// 
    /// # Arguments
    /// 
    /// * `offset` - The offset in bytes from the beginning of the buffer where the data should be written.
    /// * `size` - The size of the data in bytes.
    /// * `data` - A pointer to the data.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let mut ssbo = cgl_rs::graphics::ShaderStorageBufferObject::new(0).unwrap();
    ///    let data: [u8; 4] = [0, 1, 2, 3];
    ///    ssbo.set_data(data.len(), data.as_ptr() as *mut u8, true);
    ///    let sub_data: [u8; 2] = [4, 5];
    ///   ssbo.set_sub_data(2, sub_data.len(), sub_data.as_ptr() as *mut u8);
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    /// 
    /// # See also
    /// 
    /// * `set_data`
    pub fn set_sub_data(&mut self, offset: usize, size: usize, data: *mut u8) {
        unsafe {
            CGL_ssbo_set_sub_data(self.handle, offset, size, data as *mut c_void, false as c_int);
        }
    }

    /// Gets the entire data of the Shader Storage Buffer Object.
    /// 
    /// If you only want to get a part of the data, use `get_sub_data` instead.
    /// 
    /// # Returns
    /// 
    /// A vector containing the data of the Shader Storage Buffer Object.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let mut ssbo = cgl_rs::graphics::ShaderStorageBufferObject::new(0).unwrap();
    ///     let data: [u8; 4] = [0, 1, 2, 3];
    ///     ssbo.set_data(data.len(), data.as_ptr() as *mut u8, true);
    ///     let retrieved_data = ssbo.get_data();
    ///     assert_eq!(data, retrieved_data.as_slice());
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    /// 
    /// # See also
    /// 
    /// * `get_sub_data`
    pub fn get_data(&self) -> Vec<u8> {
        unsafe {
            let mut size: usize = CGL_ssbo_get_size(self.handle);
            let mut data: Vec<u8> = Vec::with_capacity(size);
            CGL_ssbo_get_data(self.handle, &mut size, data.as_mut_ptr() as *mut c_void);
            data.set_len(size);
            data
        }
    }

    /// Gets a part of the data of the Shader Storage Buffer Object.
    /// 
    /// If you want to get the entire data, use `get_data` instead.
    /// 
    /// # Arguments
    /// 
    /// * `offset` - The offset in bytes from the beginning of the buffer where the data should be read.
    /// * `size` - The size of the data in bytes.
    /// 
    /// # Returns
    /// 
    /// A vector containing the requested part of the data of the Shader Storage Buffer Object.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let mut ssbo = cgl_rs::graphics::ShaderStorageBufferObject::new(0).unwrap();
    ///     let data: [u8; 4] = [0, 1, 2, 3];
    ///     ssbo.set_data(data.len(), data.as_ptr() as *mut u8, true);
    ///     let retrieved_data = ssbo.get_sub_data(1, 2);
    ///     assert_eq!(&data[1..3], retrieved_data.as_slice());
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    /// 
    /// # See also
    /// 
    /// * `get_data`
    pub fn get_sub_data(&self, offset: usize, size: usize) -> Vec<u8> {
        unsafe {
            let mut data: Vec<u8> = Vec::with_capacity(size);
            CGL_ssbo_get_sub_data(self.handle, offset, size, data.as_mut_ptr() as *mut c_void);
            data.set_len(size);
            data
        }
    }

    /// Gets the size of the Shader Storage Buffer Object.
    /// 
    /// # Returns
    /// 
    /// The size of the Shader Storage Buffer Object in bytes.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let mut ssbo = cgl_rs::graphics::ShaderStorageBufferObject::new(0).unwrap();
    ///    let data: [u8; 4] = [0, 1, 2, 3];
    ///    ssbo.set_data(data.len(), data.as_ptr() as *mut u8, true);
    ///    assert_eq!(data.len(), ssbo.size());
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn size(&self) -> usize {
        unsafe {
            CGL_ssbo_get_size(self.handle) as usize
        }
    }

    /// Copies a part of the data of the Shader Storage Buffer Object to another Shader Storage Buffer Object.
    /// 
    /// Note: This does not allocate the memory if the destination buffer is not big enough.
    ///       In such a case nothing will happen.
    /// 
    /// # Arguments
    /// 
    /// * `other` - The destination Shader Storage Buffer Object.
    /// * `src_offset` - The offset in bytes from the beginning of the source buffer where the data should be read.
    /// * `dst_offset` - The offset in bytes from the beginning of the destination buffer where the data should be written.
    /// * `size` - The size of the data in bytes.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let mut ssbo1 = cgl_rs::graphics::ShaderStorageBufferObject::new(0).unwrap();
    ///     let mut ssbo2 = cgl_rs::graphics::ShaderStorageBufferObject::new(0).unwrap();
    ///     let data: [u8; 4] = [0, 1, 2, 3];
    ///     let data2: [u8; 2] = [4, 5];
    ///     ssbo1.set_data(data.len(), data.as_ptr() as *mut u8, true);
    ///     ssbo2.set_data(data2.len(), data2.as_ptr() as *mut u8, true);
    ///     ssbo1.copy_to(&ssbo2, 1, 0, 2);
    ///     let retrieved_data = ssbo2.get_data();
    ///     assert_eq!(&data[1..3], retrieved_data.as_slice());
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn copy_to(&self, other: &ShaderStorageBufferObject, src_offset: usize, dst_offset: usize, size: usize) {
        unsafe {
            CGL_ssbo_copy(other.handle, self.handle, src_offset, dst_offset, size);
        }
    }

    /// Copies the entire data of the Shader Storage Buffer Object to another Shader Storage Buffer Object.
    /// 
    /// Note: This does not allocate the memory if the destination buffer is not big enough.
    ///       In such a case nothing will happen.
    /// 
    /// # Arguments
    /// 
    /// * `other` - The destination Shader Storage Buffer Object.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let mut ssbo1 = cgl_rs::graphics::ShaderStorageBufferObject::new(0).unwrap();
    ///     let mut ssbo2 = cgl_rs::graphics::ShaderStorageBufferObject::new(0).unwrap();
    ///     let data: [u8; 4] = [0, 1, 2, 3];
    ///     let data2: [u8; 4] = [4, 5, 6, 7];
    ///     ssbo1.set_data(data.len(), data.as_ptr() as *mut u8, true);
    ///     ssbo2.set_data(data2.len(), data2.as_ptr() as *mut u8, true);
    ///     ssbo1.copy_whole_to(&ssbo2);
    ///     let retrieved_data = ssbo2.get_data();
    ///     assert_eq!(data, retrieved_data.as_slice());
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn copy_whole_to(&self, other: &ShaderStorageBufferObject) {
        unsafe {
            CGL_ssbo_copy(other.handle, self.handle, 0, 0, self.size());
        }
    }


}

impl Drop for ShaderStorageBufferObject {
    fn drop(&mut self) {
        self.destroy();
    }
}


impl Clone for ShaderStorageBufferObject {
    /// Clones the ssbo.
    /// 
    /// NOTE: The new instance will have the same handle, `has_been_destroyed` flag.
    ///       This means that the new instance will not be able to receive events nor will the internal window handle be
    ///       destroyed when the new instance is dropped. The internal window handle will be destroyed when the original
    ///       instance is dropped.
    /// 
    /// 
    /// # Returns
    /// 
    /// A new instance of `ShaderStorageBufferObject` with the same handle as the original ssbo.
    fn clone(&self) -> Self {
        ShaderStorageBufferObject {
            handle: self.handle.clone(),
            has_been_destroyed: true
        }
    }
}
```

`rust_wrapper/cgl-rs/src/graphics/text.rs`:

```rs
//! The text module contains the text rendering, font loading functionality of CGL

#![allow(non_camel_case_types)]
use libc::{c_void, c_int, c_char, size_t, c_uchar};

use crate::graphics::texture::{Texture,  CGL_texture};
use crate::math::Vector2;

// The internal font handle
#[repr(C)]
pub(crate) struct CGL_font {
    _private: c_void
}

/// The Font Character struct contains all the information about a character in a font
#[repr(C)] #[derive(Copy, Clone)]
pub struct FontCharacter {
    pub size: Vector2,
    pub normalized_size: Vector2,
    pub offset: Vector2,
    pub normalized_offset: Vector2,
    pub bearing: Vector2,
    pub bearing_normalized: Vector2,
    pub(crate) bitmap: *mut c_uchar,
    pub ch: c_char
}


extern {
    fn CGL_text_init() -> c_int;
    fn CGL_text_shutdown() -> c_void;
    fn CGL_font_load(path: *const c_char) -> *mut CGL_font;
    fn CGL_font_load_from_memory(data: *const c_char, size: size_t) -> *mut CGL_font;
    fn CGL_font_destory(font: *mut CGL_font) -> c_void;
    fn CGL_font_get_atlas(font: *mut CGL_font) -> *mut CGL_texture;
    fn CGL_font_build_atlas(font: *mut CGL_font, width: size_t, height: size_t, font_size: size_t) -> c_int;
    fn CGL_font_get_characters(font: *mut CGL_font) -> *mut FontCharacter;
    fn CGL_text_bake_to_texture(string: *const c_char, string_length: size_t, font: *mut CGL_font, width: *mut size_t, height: *mut size_t) -> *mut CGL_texture;
}

/// Initialized the text module
/// 
/// Note: This function must be called before any other text functions
/// 
/// # Example
/// 
/// ```
/// cgl_rs::init();
/// let mut window = cgl_rs::Window::new("CGL Window", 800, 600).unwrap();
/// cgl_rs::graphics::init();
/// cgl_rs::graphics::text::init();
/// // Do stuff
/// cgl_rs::graphics::text::shutdown();
/// cgl_rs::graphics::shutdown();
/// window.destroy();
/// cgl_rs::shutdown();
/// ```
pub fn init() {
    unsafe {
        CGL_text_init();
    }
}

/// Shuts down the text module
/// 
/// Note: This function must be called after all other text functions have been called
/// 
/// # Example
/// 
/// ```
/// cgl_rs::init();
/// let mut window = cgl_rs::Window::new("CGL Window", 800, 600).unwrap();
/// cgl_rs::graphics::init();
/// cgl_rs::graphics::text::init();
/// // Do stuff
/// cgl_rs::graphics::text::shutdown();
/// cgl_rs::graphics::shutdown();
/// window.destroy();
/// cgl_rs::shutdown();
/// ```
pub fn shutdown() {
    unsafe {
        CGL_text_shutdown();
    }
}

/// The public font object
pub struct Font {
    pub(crate) handle: *mut CGL_font,
    pub(crate) has_been_destroyed: bool
}

impl std::ops::Index<u8> for Font {
    type Output = FontCharacter;

    /// Indexes the font's characters by their ASCII value.
    ///
    /// # Arguments
    ///
    /// * `index` - An `i8` representing the ASCII value of the character to retrieve.
    ///
    /// # Returns
    ///
    /// Returns a reference to the `FontCharacter` object corresponding to the given ASCII value.
    ///
    /// # Safety
    ///
    /// This function is marked as unsafe because it dereferences a raw pointer returned by the `CGL_font_get_characters` function.
    ///
    /// # Example
    /// 
    /// ```no_run
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("CGL Window", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// cgl_rs::graphics::text::init();
    /// let font = cgl_rs::graphics::text::Font::load("path/to/font.ttf").unwrap();
    /// let character = font[b'c'];
    /// cgl_rs::graphics::text::shutdown();
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    fn index(&self, index: u8) -> &Self::Output {
        unsafe {
            &*CGL_font_get_characters(self.handle).offset(index as isize)
        }
    }
}

impl Font {

    /// Loads a font from a file path
    ///
    /// # Arguments
    ///
    /// * `path` - A string slice that holds the path to the font file
    ///
    /// # Returns
    ///
    /// Returns a `Result` containing a `Font` object if the font was loaded successfully, or an error message if it failed to load.
    ///
    /// # Example
    ///
    /// ```no_run
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("CGL Window", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// cgl_rs::graphics::text::init();
    /// {
    ///     let font = cgl_rs::graphics::text::Font::load("path/to/font.ttf").unwrap();
    /// }
    /// cgl_rs::graphics::text::shutdown();
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn load(path: &str) -> Result<Font, &'static str> {
        let c_path = std::ffi::CString::new(path).unwrap();
        let handle = unsafe { CGL_font_load(c_path.as_ptr()) };
        if handle.is_null() {
            Err("Failed to load font")
        } else {
            Ok(Font {
                handle,
                has_been_destroyed: false
            })
        }
    }

    /// Loads a font from memory
    ///
    /// # Arguments
    ///
    /// * `data` - A pointer to the font data in memory
    /// * `size` - The size of the font data in bytes
    ///
    /// # Returns
    ///
    /// Returns a `Result` containing a `Font` object if the font was loaded successfully, or an error message if it failed to load.
    ///
    /// # Example
    ///
    /// ```no_run
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("CGL Window", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// cgl_rs::graphics::text::init();
    /// {
    ///     // let font_data = include_bytes!("path/to/font.ttf");
    ///     // let font = cgl_rs::graphics::text::Font::load_from_memory(font_data.as_ptr(), font_data.len()).unwrap();
    /// }
    /// cgl_rs::graphics::text::shutdown();
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn load_from_memory(data: *const u8, size: usize) -> Result<Font, &'static str> {
        let handle = unsafe { CGL_font_load_from_memory(data as *const c_char, size) };
        if handle.is_null() {
            Err("Failed to load font")
        } else {
            Ok(Font {
                handle,
                has_been_destroyed: false
            })
        }
    }

    /// Destroys the font object and frees any resources associated with it.
    ///
    /// # Example
    ///
    /// ```no_run
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("CGL Window", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// cgl_rs::graphics::text::init();
    /// {
    ///     let mut font = cgl_rs::graphics::text::Font::load("path/to/font.ttf").unwrap();
    ///     // Use the font...
    ///     font.destroy(); // Or, just let the font go out of scope and it will be destroyed automatically.
    /// }
    /// cgl_rs::graphics::text::shutdown();
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn destroy(&mut self) {
        if !self.has_been_destroyed {
            unsafe {
                CGL_font_destory(self.handle);
            }
            self.has_been_destroyed = true;
        }
    }

    /// Returns the texture atlas for the font. This function must be called after `build_atlas` has been called.
    /// 
    /// Note: This atlas texture is managed by the font object and will be destroyed when the font object is destroyed.
    ///
    /// # Returns
    ///
    /// Returns a `Texture` object representing the texture atlas for the font.
    ///
    /// # Example
    ///
    /// ```no_run
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("CGL Window", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// cgl_rs::graphics::text::init();
    /// {
    ///     let font = cgl_rs::graphics::text::Font::load("path/to/font.ttf").unwrap();
    ///     font.build_atlas(512, 512, 32).unwrap();
    ///     let texture = font.get_atlas();
    ///     // Use the texture...
    /// }
    /// cgl_rs::graphics::text::shutdown();
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn get_atlas(&self) -> Texture {
        let handle = unsafe { CGL_font_get_atlas(self.handle) };
        Texture {
            handle,
            has_been_destroyed: true
        }
    }

    /// Builds the texture atlas for the font. This function must be called before any text can be rendered with the font.
    ///
    /// # Arguments
    ///
    /// * `width` - The width of the texture atlas in pixels.
    /// * `height` - The height of the texture atlas in pixels.
    /// * `font_size` - The size of the font in pixels.
    ///
    /// # Returns
    ///
    /// Returns `Ok(())` if the texture atlas was built successfully, otherwise returns an error message.
    ///
    /// # Example
    ///
    /// ```no_run
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("CGL Window", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// cgl_rs::graphics::text::init();
    /// {
    ///     let font = cgl_rs::graphics::text::Font::load("path/to/font.ttf").unwrap();
    ///     font.build_atlas(512, 512, 32).unwrap();
    ///     // Use the font...
    /// }
    /// cgl_rs::graphics::text::shutdown();
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn build_atlas(&self, width: usize, height: usize, font_size: usize) -> Result<(), &'static str> {
        let result = unsafe { CGL_font_build_atlas(self.handle, width, height, font_size) };
        if result != 0 {
            Ok(())
        } else {
            Err("Failed to build font atlas")
        }
    }
}

impl Drop for Font {
    fn drop(&mut self) {
        self.destroy();
    }
}

impl Clone for Font {
    fn clone(&self) -> Self {
        Font {
            handle: self.handle.clone(),
            has_been_destroyed: true
        }
    }
}

/// Bakes the given text into a texture using the specified font and font size.
/// 
/// Note: This texture is not managed by the font object and the ownership of the texture is passed to the caller.
///
/// # Arguments
///
/// * `font` - The font to use for rendering the text.
/// * `text` - The text to render.
///
/// # Returns
///
/// Returns a tuple containing the resulting `Texture` object, as well as the width and height of the texture in pixels.
///
/// # Example
///
/// ```no_run
/// cgl_rs::init();
/// let mut window = cgl_rs::Window::new("CGL Window", 800, 600).unwrap();
/// cgl_rs::graphics::init();
/// cgl_rs::graphics::text::init();
/// {
///     let font = cgl_rs::graphics::text::Font::load("path/to/font.ttf").unwrap();
///     let (texture, width, height) = cgl_rs::graphics::text::bake_to_texture(&font, "Hello, world!").unwrap();
///     // Use the texture...
/// }
/// cgl_rs::graphics::text::shutdown();
/// cgl_rs::graphics::shutdown();
/// window.destroy();
/// cgl_rs::shutdown();
/// ```
pub fn bake_to_texture(font: &Font, text: &str) -> Result<(Texture, u32, u32), &'static str> {
    let mut width_sz: size_t = 0;
    let mut height_sz: size_t = 0;
    let width_ptr = &mut width_sz as *mut size_t;
    let height_ptr = &mut height_sz as *mut size_t;
    let string_in_c = std::ffi::CString::new(text).unwrap();
    let handle = unsafe { CGL_text_bake_to_texture(string_in_c.as_ptr(), text.len(), font.handle, width_ptr, height_ptr) };
    if handle.is_null() {
        Err("Failed to bake text to texture")
    } else {
        Ok((Texture {
            handle,
            has_been_destroyed: false
        }, width_sz as u32, height_sz as u32))
    }
}
```

`rust_wrapper/cgl-rs/src/graphics/texture.rs`:

```rs
//! The txture module of CGL

#![allow(non_camel_case_types)]
use libc::{c_void, c_int, c_uint, size_t};

/// The internal handle used by CGL
#[repr(C)]
pub(crate) struct CGL_texture {
    _private: c_void
}

/// The texture format used by CGL
/// These are reflections of OpenGL's enum values
/// You can also use the _i version of methods to pass integers directly instead of enums
pub enum TextureFormat {
    RED     = 0x1903,
    GREEN   = 0x1904,
    BLUE    = 0x1905,
    ALPHA   = 0x1906,
    RGB     = 0x1907,
    RGBA    = 0x1908,
    BGR     = 0x80E0,
    BGRA    = 0x80E1
}

/// The texture internal format used by CGL
/// These are reflections of OpenGL's enum values
/// You can also use the _i version of methods to pass integers directly instead of enums
pub enum TextureInternalFormat {
    RGBA32F             = 0x8814,
    RGB32F              = 0x8815,
    RGBA16F             = 0x881A,
    RGB16F              = 0x881B,
    RGBA32UI            = 0x8D70,
    RGB32UI             = 0x8D71,
    RGBA16UI            = 0x8D76,
    RGB16UI             = 0x8D77,
    RGBA8UI             = 0x8D7C,
    RGB8UI              = 0x8D7D,
    RGBA32I             = 0x8D82,
    RGB32I              = 0x8D83,
    RGBA16I             = 0x8D88,
    RGB16I              = 0x8D89,
    RGBA8I              = 0x8D8E,
    RGB8I               = 0x8D8F,
    RED_INTEGER         = 0x8D94,
    GREEN_INTEGER       = 0x8D95,
    BLUE_INTEGER        = 0x8D96,
    RGB_INTEGER         = 0x8D98,
    RGBA_INTEGER        = 0x8D99,
    BGR_INTEGER         = 0x8D9A,
    BGRA_INTEGER        = 0x8D9B
}


/// The texture data type used by CGL
/// These are reflections of OpenGL's enum values
/// You can also use the _i version of methods to pass integers directly instead of enums
pub enum TextureDataType {
    BYTE              = 0x1400,
    UNSIGNED_BYTE     = 0x1401,
    SHORT             = 0x1402,
    UNSIGNED_SHORT    = 0x1403,
    INT               = 0x1404,
    UNSIGNED_INT      = 0x1405,
    FLOAT             = 0x1406
}

/// The texture scaling mode used by CGL
/// These are reflections of OpenGL's enum values
/// You can also use the _i version of methods to pass integers directly instead of enums
pub enum TextureScalingMode {
    NEAREST                 = 0x2600,
    LINEAR                  = 0x2601,
    NEAREST_MIPMAP_NEAREST  = 0x2700,
    LINEAR_MIPMAP_NEAREST   = 0x2701,
    NEAREST_MIPMAP_LINEAR   = 0x2702,
    LINEAR_MIPMAP_LINEAR    = 0x2703
}


/// The texture wrapping mode used by CGL
/// These are reflections of OpenGL's enum values
/// You can also use the _i version of methods to pass integers directly instead of enums
pub enum TextureWrappingMode {
    REPEAT              = 0x2901,
    MIRRORED_REPEAT     = 0x8370,
    CLAMP_TO_EDGE       = 0x812F,
    CLAMP_TO_BORDER     = 0x812D
}

/// The texture object
pub struct Texture {
    pub(crate) handle: *mut CGL_texture,
    pub(crate) has_been_destroyed: bool
}


#[repr(C)]
pub(crate) struct CGL_image {
    pub(crate) data: *mut c_void,
    pub(crate) height: c_int,
    pub(crate) width: c_int,
    pub(crate) bytes_per_channel: c_int,
    pub(crate) channels: c_int
}

extern {
    fn CGL_texture_create(image: *mut CGL_image) -> *mut CGL_texture;
    fn CGL_texture_create_blank(width: c_int, height: c_int, format: c_uint, internal_format: c_uint, data_type: c_uint) -> *mut CGL_texture;
    fn CGL_texture_create_array(width: c_int, height: c_int, layers: c_int, format: c_uint, internal_format: c_uint, data_type: c_uint) -> *mut CGL_texture;
    fn CGL_texture_create_3d(width: c_int, height: c_int, depth: c_int, format: c_uint, internal_format: c_uint, data_type: c_uint) -> *mut CGL_texture;
    fn CGL_texture_create_cubemap() -> *mut CGL_texture;
    fn CGL_texture_cubemap_set_face(texture: *mut CGL_texture, face: c_int, image: *mut CGL_image);
    fn CGL_texture_array_set_layer_data(texture: *mut CGL_texture, layer: c_int, data: *mut c_void);
    fn CGL_texture_destroy(texture: *mut CGL_texture);
    fn CGL_texture_bind(texture: *mut CGL_texture, unit: c_int) -> c_int;
    fn CGL_texture_set_data(texture: *mut CGL_texture, data: *mut c_void);
    fn CGL_texture_set_sub_data(texture: *mut CGL_texture, offset_x: size_t, offset_y: size_t, size_x: size_t, size_y: size_t, data: *mut c_void);
    fn CGL_texture_set_pixel_data(texture: *mut CGL_texture, x: c_int, y: c_int, data: *mut c_void);
    fn CGL_texture_set_user_data(texture: *mut CGL_texture, user_data: *mut c_void);
    fn CGL_texture_get_user_data(texture: *mut CGL_texture) -> *mut c_void;
    fn CGL_texture_get_internal_handle(texture: *mut CGL_texture) -> c_uint;
    fn CGL_texture_get_size(texture: *mut CGL_texture, width: *mut c_int, height: *mut c_int);
    fn CGL_texture_set_scaling_method(texture: *mut CGL_texture, method: c_int);
    fn CGL_texture_set_wrapping_method(texture: *mut CGL_texture, method: c_int);
}



impl Texture {
    
     /// Creates a new blank texture with the specified dimensions and format.
    /// 
    /// # Arguments
    /// 
    /// * `width` - The width of the texture in pixels.
    /// * `height` - The height of the texture in pixels.
    /// * `format` - The format of the texture data.
    /// * `internal_format` - The internal format of the texture data.
    /// * `data_type` - The data type of the texture data.
    /// 
    /// # Returns
    /// 
    /// A `Result` containing the newly created `Texture` if successful, or an error message if creation failed.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let texture = cgl_rs::graphics::Texture::blank_i(256, 256, cgl_rs::graphics::TextureFormat::RGBA as u32, cgl_rs::graphics::TextureInternalFormat::RGBA8UI as u32, cgl_rs::graphics::TextureDataType::UNSIGNED_BYTE as u32).unwrap();
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn blank_i(width: i32, height: i32, format: u32, internal_format: u32, data_type: u32) -> Result<Texture, &'static str> {
        let handle = unsafe {
            CGL_texture_create_blank(width, height, format as c_uint, internal_format as c_uint, data_type as c_uint)
        };
        if handle.is_null() {
            Err("Failed to create texture")
        } else {
            Ok(Texture {
                handle,
                has_been_destroyed: false
            })
        }
    }

    /// Creates a new blank texture with the specified dimensions and format.
    /// 
    /// # Arguments
    /// 
    /// * `width` - The width of the texture in pixels.
    /// * `height` - The height of the texture in pixels.
    /// * `format` - The format of the texture data.
    /// * `internal_format` - The internal format of the texture data.
    /// * `data_type` - The data type of the texture data.
    /// 
    /// # Returns
    /// 
    /// A `Result` containing the newly created `Texture` if successful, or an error message if creation failed.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let texture = cgl_rs::graphics::Texture::blank(256, 256, cgl_rs::graphics::TextureFormat::RGBA, cgl_rs::graphics::TextureInternalFormat::RGBA8UI, cgl_rs::graphics::TextureDataType::UNSIGNED_BYTE).unwrap();
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    pub fn blank(width: i32, height: i32, format: TextureFormat, internal_format: TextureInternalFormat, data_type: TextureDataType) -> Result<Texture, &'static str> {
        Texture::blank_i(width, height, format as u32, internal_format as u32, data_type as u32)
    }

    /// Creates a new dummy texture with a single pixel.
    /// 
    /// # Returns
    /// 
    /// A `Result` containing the newly created `Texture` if successful, or an error message if creation failed.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let texture = cgl_rs::graphics::Texture::dummy().unwrap();
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    pub fn dummy() -> Result<Texture, &'static str> {
        Texture::blank(1, 1, TextureFormat::RGBA, TextureInternalFormat::RGBA8UI, TextureDataType::UNSIGNED_BYTE)
    }

    /// Creates a new dummy texture with the specified dimensions.
    /// 
    /// # Arguments
    /// 
    /// * `width` - The width of the texture in pixels.
    /// * `height` - The height of the texture in pixels.
    /// 
    /// # Returns
    /// 
    /// A `Result` containing the newly created `Texture` if successful, or an error message if creation failed.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let texture = cgl_rs::graphics::Texture::dummy2(256, 256).unwrap();
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    pub fn dummy2(width: i32, height: i32) -> Result<Texture, &'static str> {
        Texture::blank(width, height, TextureFormat::RGBA, TextureInternalFormat::RGBA8UI, TextureDataType::UNSIGNED_BYTE)
    }

    /// Creates a new texture array with the specified dimensions and format.
    /// 
    /// # Arguments
    /// 
    /// * `width` - The width of the texture in pixels.
    /// * `height` - The height of the texture in pixels.
    /// * `depth` - The depth of the texture array.
    /// * `format` - The format of the texture data.
    /// * `internal_format` - The internal format of the texture data.
    /// * `data_type` - The data type of the texture data.
    /// 
    /// # Returns
    /// 
    /// A `Result` containing the newly created `Texture` if successful, or an error message if creation failed.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let texture = cgl_rs::graphics::Texture::array_i(256, 256, 6, cgl_rs::graphics::TextureFormat::RGBA as u32, cgl_rs::graphics::TextureInternalFormat::RGBA8UI as u32, cgl_rs::graphics::TextureDataType::UNSIGNED_BYTE as u32).unwrap();
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    pub fn array_i(width: i32, height: i32, depth: i32, format: u32, internal_format: u32, data_type: u32) -> Result<Texture, &'static str> {
        let handle = unsafe {
            CGL_texture_create_array(width, height, depth, format as c_uint, internal_format as c_uint, data_type as c_uint)
        };
        if handle.is_null() {
            Err("Failed to create texture")
        } else {
            Ok(Texture {
                handle,
                has_been_destroyed: false
            })
        }
    }

    // Creates a new texture array with the specified dimensions and format.
    /// 
    /// # Arguments
    /// 
    /// * `width` - The width of the texture in pixels.
    /// * `height` - The height of the texture in pixels.
    /// * `depth` - The depth of the texture array.
    /// * `format` - The format of the texture data.
    /// * `internal_format` - The internal format of the texture data.
    /// * `data_type` - The data type of the texture data.
    /// 
    /// # Returns
    /// 
    /// A `Result` containing the newly created `Texture` if successful, or an error message if creation failed.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let texture = cgl_rs::graphics::Texture::array(256, 256, 6, cgl_rs::graphics::TextureFormat::RGBA, cgl_rs::graphics::TextureInternalFormat::RGBA8UI, cgl_rs::graphics::TextureDataType::UNSIGNED_BYTE).unwrap();
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    pub fn array(width: i32, height: i32, depth: i32, format: TextureFormat, internal_format: TextureInternalFormat, data_type: TextureDataType) -> Result<Texture, &'static str> {
        Texture::array_i(width, height, depth, format as u32, internal_format as u32, data_type as u32)
    }

    /// Creates a new cubemap texture.
    /// 
    /// # Returns
    /// 
    /// A `Result` containing the newly created `Texture` if successful, or an error message if creation failed.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let texture = cgl_rs::graphics::Texture::cubemap().unwrap();
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    pub fn cubemap() -> Result<Texture, &'static str> {
        let handle = unsafe {
            CGL_texture_create_cubemap()
        };
        if handle.is_null() {
            Err("Failed to create texture")
        } else {
            Ok(Texture {
                handle,
                has_been_destroyed: false
            })
        }
    }

    // TODO : Implement cubemap_set_face

    /// Sets the data for a single layer of a texture array.
    /// 
    /// # Arguments
    /// 
    /// * `layer` - The index of the layer to set the data for.
    /// * `data` - A slice containing the data to set for the layer.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let mut texture = cgl_rs::graphics::Texture::array(256, 256, 6, cgl_rs::graphics::TextureFormat::RGBA, cgl_rs::graphics::TextureInternalFormat::RGBA8UI, cgl_rs::graphics::TextureDataType::UNSIGNED_BYTE).unwrap();
    ///     let data = vec![0u8; 256 * 256 * 4];
    ///     texture.array_set_layer_data(0, &data);
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    pub fn array_set_layer_data(&self, layer: i32, data: &[u8]) {
        unsafe {
            CGL_texture_array_set_layer_data(self.handle, layer, data.as_ptr() as *mut c_void);
        }
    }

    /// Binds the texture to a texture unit.
    /// 
    /// # Arguments
    /// 
    /// * `unit` - The texture unit to bind the texture to.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let texture = cgl_rs::graphics::Texture::dummy().unwrap();
    ///     texture.bind(0);
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    pub fn bind(&self, unit: u32) {
        unsafe {
            CGL_texture_bind(self.handle, unit as i32);
        }
    }

    /// Sets the data for the texture.
    /// 
    /// # Arguments
    /// 
    /// * `data` - A slice containing the data to set for the texture.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let mut texture = cgl_rs::graphics::Texture::dummy2(256, 256).unwrap();
    ///     let data = vec![0u8; 256 * 256 * 4];
    ///     texture.set_data(data.as_ptr());
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    pub fn set_data(&self, data: *const u8) {
        unsafe {
            CGL_texture_set_data(self.handle, data as *mut c_void);
        }
    }

    /// Sets a rectangular subregion of the texture with new data.
    ///
    /// # Arguments
    ///
    /// * `x` - The x-coordinate of the lower left corner of the subregion.
    /// * `y` - The y-coordinate of the lower left corner of the subregion.
    /// * `width` - The width of the subregion.
    /// * `height` - The height of the subregion.
    /// * `data` - A slice containing the new data to set for the subregion.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let mut texture = cgl_rs::graphics::Texture::dummy2(256, 256).unwrap();
    ///     let data = vec![255u8; 100 * 100 * 4];
    ///     texture.set_sub_data(0, 0, 100, 100, data.as_ptr());
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_sub_data(&self, x: usize, y: usize, width: usize, height: usize, data: *const u8) {
        unsafe {
            CGL_texture_set_sub_data(self.handle, x, y, width, height, data as *mut c_void);
        }
    }

    /// Returns the internal OpenGL handle of the texture.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let texture = cgl_rs::graphics::Texture::dummy().unwrap();
    ///     let handle = texture.get_internal_gl_handle();
    ///     println!("Internal OpenGL handle: {}", handle);
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn get_internal_gl_handle(&self) -> u32 {
        unsafe {
            CGL_texture_get_internal_handle(self.handle) as u32
        }
    }

    /// Sets the scaling method of the texture.
    ///
    /// # Arguments
    ///
    /// * `method` - The scaling method to use for the texture.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let mut texture = cgl_rs::graphics::Texture::dummy2(256, 256).unwrap();
    ///     texture.set_scaling_method_i(1);
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_scaling_method_i(&self, method: i32) {
        unsafe {
            CGL_texture_set_scaling_method(self.handle, method as i32);
        }
    }

    // Sets the scaling method of the texture.
    ///
    /// # Arguments
    ///
    /// * `method` - The scaling method to use for the texture.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let mut texture = cgl_rs::graphics::Texture::dummy2(256, 256).unwrap();
    ///     texture.set_scaling_method(cgl_rs::graphics::TextureScalingMode::LINEAR);
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_scaling_method(&self, method: TextureScalingMode) {
        self.set_scaling_method_i(method as i32);
    }

    /// Sets the wrapping method of the texture.
    ///
    /// # Arguments
    ///
    /// * `method` - The wrapping method to use for the texture.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let mut texture = cgl_rs::graphics::Texture::dummy2(256, 256).unwrap();
    ///    texture.set_wrapping_method_i(1);
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_wrapping_method_i(&self, method: i32) {
        unsafe {
            CGL_texture_set_wrapping_method(self.handle, method as i32);
        }
    }

    /// Sets the wrapping method of the texture.
    ///
    /// # Arguments
    ///
    /// * `method` - The wrapping method to use for the texture.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let mut texture = cgl_rs::graphics::Texture::dummy2(256, 256).unwrap();
    ///    texture.set_wrapping_method(cgl_rs::graphics::TextureWrappingMode::CLAMP_TO_EDGE);
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_wrapping_method(&self, method: TextureWrappingMode) {
        self.set_wrapping_method_i(method as i32);
    }


    /// Destroys the texture and frees its resources. If the texture has already been destroyed, this method does nothing.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let mut texture = cgl_rs::graphics::Texture::dummy().unwrap();
    ///     texture.destroy(); // optional
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    pub fn destroy(&mut self) {
        if !self.has_been_destroyed {
            unsafe {
                CGL_texture_destroy(self.handle);
            }
            self.has_been_destroyed = true;
        }
    }

}

impl Drop for Texture {
    fn drop(&mut self) {
        self.destroy();
    }
}


impl Clone for Texture {
    /// Clones the texture.
    /// 
    /// NOTE: The new instance will have the same handle, `has_been_destroyed` flag.
    ///       This means that the new instance will not be able to receive events nor will the internal window handle be
    ///       destroyed when the new instance is dropped. The internal window handle will be destroyed when the original
    ///       instance is dropped.
    /// 
    /// 
    /// # Returns
    /// 
    /// A new instance of `Texture` with the same handle as the original texture.
    fn clone(&self) -> Self {
        Texture {
            handle: self.handle.clone(),
            has_been_destroyed: true
        }
    }
}
```

`rust_wrapper/cgl-rs/src/graphics/tilemap.rs`:

```rs
//! The Tilemap module provides a way to render tilemaps to the screen.

#![allow(non_camel_case_types)]
use libc::{c_void, c_int, c_uint, c_float};


use crate::graphics::{Texture, CGL_texture};

/// The internal handle used by CGL
#[repr(C)]
pub(crate) struct CGL_tilemap {
    _private: c_void
}

extern {
    fn CGL_tilemap_create(tile_count_x: c_uint, tile_count_y: c_uint, tile_size_x: c_uint, tile_size_y: c_uint, ssbo_binding: c_uint) -> *mut CGL_tilemap;
    fn CGL_tilemap_destroy(tilemap: *mut CGL_tilemap) -> c_void;
    fn CGL_tilemap_set_auto_upload(tilemap: *mut CGL_tilemap, value: c_int) -> c_void;
    fn CGL_tilemap_get_auto_upload(tilemap: *mut CGL_tilemap) -> c_int;
    fn CGL_tilemap_upload(tilemap: *mut CGL_tilemap) -> c_int;
    fn CGL_tilemap_set_tile_color(tilemap: *mut CGL_tilemap, tile_x: c_uint, tile_y: c_uint, r: c_float, g: c_float, b: c_float) -> c_void;
    fn CGL_tilemap_set_tile_texture_from_array(tilemap: *mut CGL_tilemap, tile_x: c_uint, tile_y: c_uint, texture_index: c_uint) -> c_void;
    fn CGL_tilemap_set_tile_texture_from_tileset(tilemap: *mut CGL_tilemap, tile_x: c_uint, tile_y: c_uint, texture_x_min: c_float, texture_y_min: c_float, texture_x_max: c_float, texture_y_max: c_float) -> c_void;
    fn CGL_tilemap_set_all_tile_color(tilemap: *mut CGL_tilemap, r: c_float, g: c_float, b: c_float) -> c_void;
    fn CGL_tilemap_set_all_tile_texture_from_array(tilemap: *mut CGL_tilemap, texture_index: c_uint) -> c_void;
    fn CGL_tilemap_set_all_tile_texture_from_tileset(tilemap: *mut CGL_tilemap, texture_x_min: c_float, texture_y_min: c_float, texture_x_max: c_float, texture_y_max: c_float) -> c_void;
    fn CGL_tilemap_clear_tile(tilemap: *mut CGL_tilemap, tile_x: c_uint, tile_y: c_uint) -> c_void;
    fn CGL_tilemap_clear_all_tile(tilemap: *mut CGL_tilemap) -> c_void;
    fn CGL_tilemap_render(tilemap: *mut CGL_tilemap, scale_x: c_float, scale_y: c_float, offset_x: c_float, offset_y: c_float, texture: *mut CGL_texture) -> c_void;
    fn CGL_tilemap_reset(tilemap: *mut CGL_tilemap) -> c_void;
}

/// The Tilemap Object
#[repr(C)]
pub struct Tilemap {
    pub(crate) handle: *mut CGL_tilemap,
    pub(crate) has_been_destroyed: bool
}

impl Tilemap {


    /// Creates a new Tilemap object with the specified dimensions and SSBO binding.
    ///
    /// # Arguments
    ///
    /// * `tile_count_x` - The number of tiles in the x direction.
    /// * `tile_count_y` - The number of tiles in the y direction.
    /// * `tile_size_x` - The width of each tile in pixels.
    /// * `tile_size_y` - The height of each tile in pixels.
    /// * `ssbo_binding` - The SSBO binding index to use for the tilemap.
    ///
    /// # Returns
    ///
    /// A `Result` containing the new `Tilemap` object if successful, or an error message if creation failed.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("CGL Window", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///     let tilemap = cgl_rs::graphics::Tilemap::new(10, 10, 32, 32, 0).unwrap();
    ///     // Do stuff with tilemap
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn new(tile_count_x: u32, tile_count_y: u32, tile_size_x: u32, tile_size_y: u32, ssbo_binding: u32) -> Result<Tilemap, &'static str> {
        let handle = unsafe {
            CGL_tilemap_create(tile_count_x, tile_count_y, tile_size_x, tile_size_y, ssbo_binding)
        };
        if handle.is_null() {
            Err("Failed to create tilemap")
        } else {
            Ok(Tilemap {
                handle,
                has_been_destroyed: false
            })
        }
    }

    /// Sets whether the tilemap should automatically upload changes to the GPU.
    ///
    /// # Arguments
    ///
    /// * `value` - A boolean value indicating whether the tilemap should automatically upload changes to the GPU.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("CGL Window", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let tilemap = cgl_rs::graphics::Tilemap::new(10, 10, 32, 32, 0).unwrap();
    ///    tilemap.set_auto_upload(false);
    ///    // Do stuff with tilemap
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_auto_upload(&self, value: bool) {
        unsafe {
            CGL_tilemap_set_auto_upload(self.handle, value as c_int);
        }
    }

    /// Returns whether the tilemap is set to automatically upload changes to the GPU.
    ///
    /// # Returns
    ///
    /// A boolean value indicating whether the tilemap is set to automatically upload changes to the GPU.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("CGL Window", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let tilemap = cgl_rs::graphics::Tilemap::new(10, 10, 32, 32, 0).unwrap();
    ///    let auto_upload = tilemap.get_auto_upload();
    ///    // Do stuff with tilemap
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn get_auto_upload(&self) -> bool {
        unsafe {
            CGL_tilemap_get_auto_upload(self.handle) != 0
        }
    }

    /// Uploads any changes made to the tilemap to the GPU. 
    /// This can be slow, so it is recommended to set auto upload to false
    /// and manually call this function when needed for large tilemaps.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("CGL Window", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let tilemap = cgl_rs::graphics::Tilemap::new(10, 10, 32, 32, 0).unwrap();
    ///    tilemap.set_auto_upload(false);
    ///    tilemap.set_tile_color(0, 0, 1.0, 0.0, 0.0, 1.0);
    ///    tilemap.upload();
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn upload(&self) {
        unsafe {
            CGL_tilemap_upload(self.handle);
        }
    }

    /// Sets the color of a specific tile in the tilemap.
    ///
    /// # Arguments
    ///
    /// * `tile_x` - The x-coordinate of the tile to set the color of.
    /// * `tile_y` - The y-coordinate of the tile to set the color of.
    /// * `r` - The red component of the color to set.
    /// * `g` - The green component of the color to set.
    /// * `b` - The blue component of the color to set.
    /// * `_a` - The alpha component of the color to set. This is currently unused.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("CGL Window", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let tilemap = cgl_rs::graphics::Tilemap::new(10, 10, 32, 32, 0).unwrap();
    ///    tilemap.set_tile_color(0, 0, 1.0, 0.0, 0.0, 1.0);
    ///    // Do stuff with tilemap
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_tile_color(&self, tile_x: u32, tile_y: u32, r: f32, g: f32, b: f32, _a: f32) {
        unsafe {
            CGL_tilemap_set_tile_color(self.handle, tile_x, tile_y, r, g, b);
        }
    }

    /// Sets the texture of a specific tile in the tilemap using an array of textures.
    ///
    /// # Arguments
    ///
    /// * `tile_x` - The x-coordinate of the tile to set the texture of.
    /// * `tile_y` - The y-coordinate of the tile to set the texture of.
    /// * `texture_index` - The index of the texture to set.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("CGL Window", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let tilemap = cgl_rs::graphics::Tilemap::new(10, 10, 32, 32, 0).unwrap();
    ///    tilemap.set_tile_texture_from_array(0, 0, 1);
    ///    // Do stuff with tilemap
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_tile_texture_from_array(&self, tile_x: u32, tile_y: u32, texture_index: u32) {
        unsafe {
            CGL_tilemap_set_tile_texture_from_array(self.handle, tile_x, tile_y, texture_index);
        }
    }

    /// Sets the texture of a specific tile in the tilemap using a tileset.
    ///
    /// # Arguments
    ///
    /// * `tile_x` - The x-coordinate of the tile to set the texture of.
    /// * `tile_y` - The y-coordinate of the tile to set the texture of.
    /// * `texture_x_min` - The minimum x-coordinate of the texture in the tileset.
    /// * `texture_y_min` - The minimum y-coordinate of the texture in the tileset.
    /// * `texture_x_max` - The maximum x-coordinate of the texture in the tileset.
    /// * `texture_y_max` - The maximum y-coordinate of the texture in the tileset.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("CGL Window", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let tilemap = cgl_rs::graphics::Tilemap::new(10, 10, 32, 32, 0).unwrap();
    ///    tilemap.set_tile_texture_from_tileset(0, 0, 0.0, 0.0, 1.0, 1.0);
    ///    // Do stuff with tilemap
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_tile_texture_from_tileset(&self, tile_x: u32, tile_y: u32, texture_x_min: f32, texture_y_min: f32, texture_x_max: f32, texture_y_max: f32) {
        unsafe {
            CGL_tilemap_set_tile_texture_from_tileset(self.handle, tile_x, tile_y, texture_x_min, texture_y_min, texture_x_max, texture_y_max);
        }
    }

    
    /// Sets the color of all tiles in the tilemap.
    ///
    /// # Arguments
    ///
    /// * `r` - The red component of the color.
    /// * `g` - The green component of the color.
    /// * `b` - The blue component of the color.
    /// * `_a` - The alpha component of the color (currently unused).
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("CGL Window", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let tilemap = cgl_rs::graphics::Tilemap::new(10, 10, 32, 32, 0).unwrap();
    ///    tilemap.set_all_tile_color(1.0, 0.0, 0.0, 1.0);
    ///    // Do stuff with tilemap
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_all_tile_color(&self, r: f32, g: f32, b: f32, _a: f32) {
        unsafe {
            CGL_tilemap_set_all_tile_color(self.handle, r, g, b);
        }
    }

    /// Sets the texture of all tiles in the tilemap using an array of texture indices.
    ///
    /// # Arguments
    ///
    /// * `texture_index` - The index of the texture to set for all tiles.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("CGL Window", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let tilemap = cgl_rs::graphics::Tilemap::new(10, 10, 32, 32, 0).unwrap();
    ///    tilemap.set_all_tile_texture_from_array(0);
    ///    // Do stuff with tilemap
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_all_tile_texture_from_array(&self, texture_index: u32) {
        unsafe {
            CGL_tilemap_set_all_tile_texture_from_array(self.handle, texture_index);
        }
    }

    /// Sets the texture of all tiles in the tilemap using a tileset.
    ///
    /// # Arguments
    ///
    /// * `texture_x_min` - The minimum x-coordinate of the texture in the tileset.
    /// * `texture_y_min` - The minimum y-coordinate of the texture in the tileset.
    /// * `texture_x_max` - The maximum x-coordinate of the texture in the tileset.
    /// * `texture_y_max` - The maximum y-coordinate of the texture in the tileset.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("CGL Window", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let tilemap = cgl_rs::graphics::Tilemap::new(10, 10, 32, 32, 0).unwrap();
    ///    tilemap.set_all_tile_texture_from_tileset(0.0, 0.0, 1.0, 1.0);
    ///    // Do stuff with tilemap
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_all_tile_texture_from_tileset(&self, texture_x_min: f32, texture_y_min: f32, texture_x_max: f32, texture_y_max: f32) {
        unsafe {
            CGL_tilemap_set_all_tile_texture_from_tileset(self.handle, texture_x_min, texture_y_min, texture_x_max, texture_y_max);
        }
    }

    /// Clears the tile at the specified position.
    ///
    /// # Arguments
    ///
    /// * `tile_x` - The x-coordinate of the tile to clear.
    /// * `tile_y` - The y-coordinate of the tile to clear.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("CGL Window", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let tilemap = cgl_rs::graphics::Tilemap::new(10, 10, 32, 32, 0).unwrap();
    ///    tilemap.clear_tile(0, 0);
    ///    // Do stuff with tilemap
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn clear_tile(&self, tile_x: u32, tile_y: u32) {
        unsafe {
            CGL_tilemap_clear_tile(self.handle, tile_x, tile_y);
        }
    }

    /// Clears all tiles in the tilemap.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("CGL Window", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let tilemap = cgl_rs::graphics::Tilemap::new(10, 10, 32, 32, 0).unwrap();
    ///    tilemap.clear_all_tile();
    ///    // Do stuff with tilemap
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn clear_all_tile(&self) {
        unsafe {
            CGL_tilemap_clear_all_tile(self.handle);
        }
    }

    /// Renders the tilemap to the screen.
    ///
    /// # Arguments
    ///
    /// * `scale_x` - The x-axis scale factor.
    /// * `scale_y` - The y-axis scale factor.
    /// * `offset_x` - The x-axis offset.
    /// * `offset_y` - The y-axis offset.
    /// * `texture` - The texture to use for rendering (optional).
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("CGL Window", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let mut tilemap = cgl_rs::graphics::Tilemap::new(10, 10, 32, 32, 0).unwrap();
    ///    let mut texture = cgl_rs::graphics::Texture::dummy().unwrap();
    ///    tilemap.set_all_tile_texture_from_tileset(0.0, 0.0, 1.0, 1.0);
    ///    tilemap.render(1.0, 1.0, 0.0, 0.0, Some(&mut texture));
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn render(&self, scale_x: f32, scale_y: f32, offset_x: f32, offset_y: f32, texture: Option<&mut Texture>) {
        unsafe {
            let texture_handle = match texture {
                Some(texture) => texture.handle,
                None => std::ptr::null_mut()
            };
            CGL_tilemap_render(self.handle, scale_x, scale_y, offset_x, offset_y, texture_handle);
        }
    }

    /// Destroys the tilemap object.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("Hello, World!", 800, 600).unwrap();
    /// cgl_rs::graphics::init();
    /// {
    ///    let mut tilemap = cgl_rs::graphics::Tilemap::new(10, 10, 32, 32, 0).unwrap();
    ///    tilemap.destroy(); // Or, just let the tilemap go out of scope.
    /// }
    /// cgl_rs::graphics::shutdown();
    /// window.destroy();
    /// cgl_rs::shutdown();
    /// ```
    pub fn destroy(&mut self) {
        if !self.has_been_destroyed {
            unsafe {
                CGL_tilemap_destroy(self.handle);
            }
            self.has_been_destroyed = true;
        }
    }

}


impl Drop for Tilemap {
    fn drop(&mut self) {
        self.destroy();
    }
}

impl Clone for Tilemap {
    fn clone(&self) -> Self {
        Tilemap {
            handle: self.handle.clone(),
            has_been_destroyed: true
        }
    }
}
```

`rust_wrapper/cgl-rs/src/graphics/widgets.rs`:

```rs
//! The CGL Widgets Module. This is powered by th epowerful cgl widgets batch renderer.

#![allow(non_camel_case_types)]


use std::ffi::{c_void, c_float, c_int, c_char};


use crate::math::{Vector2, Vector3, Vector4, Matrix4x4};
use crate::graphics::{Texture, CGL_texture, MeshCPU_C, text::CGL_font, text::Font};

/*

/// This functionality is not yet available from Rust side.
/// You can still create the defualt context using CGL_init and use all widgets functionality.

#[repr(C)]
pub(crate) struct CGL_widgets_context {
    _private: c_void
}

/// The CGL Widgets Context.
#[repr(C)]
pub struct WidgetsContext {
    handle: *mut CGL_widgets_context,
    has_been_destroyed: bool
}

*/

extern {
    /*
    fn CGL_widgets_context_create(max_vertices: size_t, max_indices: size_t) -> *mut CGL_widgets_context;
    fn CGL_widgets_context_destroy(context: *mut CGL_widgets_context) -> c_void;
    fn CGL_window_get_current_context() -> *mut CGL_widgets_context; // This is a typo from the original CGL code. It should be CGL_widgets_context_get_current_context.
    fn CGL_window_set_current_context(context: *mut WidgetsContext) -> c_void; // This is a typo from the original CGL code. It should be CGL_widgets_context_set_current_context.
    */

    fn CGL_widgets_init() -> c_int;
    fn CGL_widgets_shutdown() -> c_void;
    fn CGL_widgets_begin() -> c_int;
    fn CGL_widgets_begin_int(scale_x: c_float, scale_y: c_float, offset_x: c_float, offset_y: c_float) -> c_int;
    fn CGL_widgets_end() -> c_int;
    fn CGL_widgets_flush() -> c_int;
    fn CGL_widgets_flush_if_required() -> c_int;
    fn CGL_widgets_add_mesh(mesh: *mut MeshCPU_C) -> c_void;

    fn CGL_widgets_add_vertex_p(position: Vector3) -> c_void;
    fn CGL_widgets_add_vertex_p3f(pos_x: c_float, pos_y: c_float, pos_z: c_float) -> c_void;
    fn CGL_widgets_add_vertex_pt(position: Vector3, tex_coord: Vector2) -> c_void;
    fn CGL_widgets_add_vertex_p3ft(pos_x: c_float, pos_y: c_float, pos_z: c_float, tex_coord: Vector2) -> c_void;
    fn CGL_widgets_add_vertex_pt2f(position: Vector3, tex_x: c_float, tex_y: c_float) -> c_void;
    fn CGL_widgets_add_vertex_p3ft2f(pos_x: c_float, pos_y: c_float, pos_z: c_float, tex_x: c_float, tex_y: c_float) -> c_void;
    
    fn CGL_widgets_set_stroke_color(color: Vector4) -> c_void;
    fn CGL_widgets_set_stroke_colorf(r: c_float, g: c_float, b: c_float, a: c_float) -> c_void;
    fn CGL_widgets_set_mask(mask: Vector4) -> c_void;
    fn CGL_widgets_set_maskf(min_x: c_float, min_y: c_float, max_x: c_float, max_y: c_float) -> c_void;
    fn CGL_widgets_set_stroke_thicnkess(thickness: c_float) -> c_void;
    fn CGL_widgets_set_fill_color(color: Vector4) -> c_void;
    fn CGL_widgets_set_fill_colorf(r: c_float, g: c_float, b: c_float, a: c_float) -> c_void;
    fn CGL_widgets_set_fill_mode(is_enabled: c_int) -> c_void;
    
    fn CGL_widgets_enable_diffuse_shading(light_position: Vector3, light_color: Vector3) -> c_void;
    fn CGL_widgets_disable_diffuse_shading() -> c_void;
    
    fn CGL_widgets_set_projection_matrix(matrix: *mut Matrix4x4) -> c_void;
    fn CGL_widgets_set_view_matrix(matrix: *mut Matrix4x4) -> c_void;
    fn CGL_widgets_set_model_matrix(matrix: *mut Matrix4x4) -> c_void;

    fn CGL_widgets_set_texture(texture: *mut CGL_texture) -> c_void;
    fn CGL_widgets_set_font_texture(texture: *mut CGL_texture) -> c_void;
    fn CGL_widgets_set_texture_coordinate_so(scale_x: c_float, scale_y: c_float, offset_x: c_float, offset_y: c_float) -> c_void;
    
    fn CGL_widgets_apply_transformations_on_cpu() -> c_void;
    fn CGL_widgets_apply_transformations_on_gpu() -> c_void;

    fn CGL_widgets_add_triangle(a: Vector3, b: Vector3, c: Vector3) -> c_void;
    fn CGL_widgets_add_quad(a: Vector3, b: Vector3, c: Vector3, d: Vector3) -> c_void;
    fn CGL_widgets_add_quad_8f(ax: c_float, ay: c_float, bx: c_float, by: c_float, cx: c_float, cy: c_float, dx: c_float, dy: c_float) -> c_void;
    fn CGL_widgets_add_line(start: Vector3, end: Vector3) -> c_void;
    fn CGL_widgets_add_line2f(start_x: c_float, start_y: c_float, end_x: c_float, end_y: c_float) -> c_void;
    fn CGL_widgets_add_rect(start: Vector3, size: Vector2) -> c_void;
    fn CGL_widgets_add_rect2f(start_x: c_float, start_y: c_float, size_x: c_float, size_y: c_float) -> c_void;
    fn CGL_widgets_add_rounded_rect2f(start_x: c_float, start_y: c_float, size_x: c_float, size_y: c_float, radius: c_float, res: c_int) -> c_void;
    fn CGL_widgets_add_circle(position: Vector3, radius: c_float) -> c_void;
    fn CGL_widgets_add_circle2f(pos_x: c_float, pos_y: c_float, radius: c_float) -> c_void;
    fn CGL_widgets_add_circler(position: Vector3, radius: c_float, res: c_int) -> c_void;
    fn CGL_widgets_add_circle2fr(pos_x: c_float, pos_y: c_float, radius: c_float, res: c_int) -> c_void;
    fn CGL_widgets_add_oval(position: Vector3, radius: Vector2) -> c_void;
    fn CGL_widgets_add_oval2f(pos_x: c_float, pos_y: c_float, radius_x: c_float, radius_y: c_float) -> c_void;
    fn CGL_widgets_add_oval2fr(pos_x: c_float, pos_y: c_float, radiusx: c_float, radiusy: c_float, resolution: c_int) -> c_void;
    fn CGL_widgets_add_arc2f(pos_x: c_float, pos_y: c_float, radius: c_float, start_angle: c_float, end_angle: c_float, resolution: c_int) -> c_void;
    fn CGL_widgets_add_character(c: c_char, x: c_float, y: c_float, sx: c_float, sy: c_float) -> c_int;
    fn CGL_widgets_add_string(str: *const c_char, x: c_float, y: c_float, sx: c_float, sy: c_float) -> c_int;
    fn CGL_widgets_add_string_with_font(str: *const c_char, font: *mut CGL_font, x: c_float, y: c_float, sx: c_float, scale_y: c_float) -> c_float;
    fn CGL_widgets_add_cubic_bazier(start: Vector3, end: Vector3, control_1: Vector3, control_2: Vector3, resolution: c_int) -> c_void;
    fn CGL_widgets_add_cubic_bazier2v(start: Vector2, end: Vector2, control_1: Vector2, control_2: Vector2, resolution: c_int) -> c_void;
    fn CGL_widgets_add_cubic_bazier2f(start_x: c_float, start_y: c_float, end_x: c_float, end_y: c_float, control_1_x: c_float, control_1_y: c_float, control_2_x: c_float, control_2_y: c_float, resolution: c_int) -> c_void;
    fn CGL_widgets_add_cubic_bazier_points(start: Vector3, end: Vector3, control_1: Vector3, control_2: Vector3, resolution: c_int) -> c_void;
    
    fn CGL_widgets_add_cubic_bazier_points2v(start: Vector2, end: Vector2, control_1: Vector2, control_2: Vector2, resolution: c_int) -> c_void;
    fn CGL_widgets_add_cubic_bazier_points2f(start_x: c_float, start_y: c_float, end_x: c_float, end_y: c_float, control_1_x: c_float, control_1_y: c_float, control_2_x: c_float, control_2_y: c_float, resolution: c_int) -> c_void;
    

    // For future ...
    // fn CGL_widgets_add_plot_array(start_x: c_float, start_y: c_float, size_x: c_float, size_y: c_float, values: *mut Vector2, count: c_int, marker_size: c_float, marker_color: Vector3, draw_axes: c_int, axes_thickness: c_float, axes_color: Vector3) -> c_void;
    // fn CGL_widgets_add_plot_pie_chart(start_x: c_float, start_y: c_float, radius: c_float, values: *mut c_float, colors: *mut Vector3, count: c_int, resolution: c_int) -> c_void;
    // fn CGL_widgets_add_bar_graph(start_x: c_float, start_y: c_float, size_x: c_float, size_y: c_float, values: *mut c_float, colors: *mut Vector3, count: c_int, draw_axes: c_int, axes_thickness: c_float, axes_color: Vector3, vertical: c_int) -> c_void;
    // fn CGL_widgets_add_plot_function(start_x: c_float, start_y: c_float, size_x: c_float, size_y: c_float, func_to_plot: fn(CGL_float) -> CGL_float, num_samples: c_int, x_min: c_float, x_max: c_float, y_min: c_float, y_max: c_float, plot_thickness: c_float, plot_color: Vector3, draw_axes: c_int, axes_thickness: c_float, axes_color: Vector3) -> c_void;
    // fn CGL_widgets_add_shape_out_line(shape: *mut CGL_shape) -> c_void; // TODO: Implement shape 

}    

/// Initializes the CGL widgets
/// 
/// # Returns
/// 
/// Returns `Ok(())` if the initialization was successful, otherwise returns `Err("Failed to initialize CGL widgets")`
/// 
/// # Example
/// 
/// ```
/// cgl_rs::init();
/// let mut window = cgl_rs::Window::new("CGL Window", 800, 600).unwrap();
/// cgl_rs::graphics::init();
/// cgl_rs::graphics::widgets::init();
/// // do stuff
/// cgl_rs::graphics::widgets::shutdown();
/// cgl_rs::graphics::shutdown();
/// window.destroy();
/// cgl_rs::shutdown();
/// ```
pub fn init() -> Result<(), &'static str> {
    unsafe {
        if CGL_widgets_init() == 0 {
            return Err("Failed to initialize CGL widgets");
        }
    }
    Ok(())
}


/// Shuts down the CGL widgets
/// 
/// # Example
/// 
/// ```
/// cgl_rs::init();
/// let mut window = cgl_rs::Window::new("CGL Window", 800, 600).unwrap();
/// cgl_rs::graphics::init();
/// cgl_rs::graphics::widgets::init();
/// // do stuff
/// cgl_rs::graphics::widgets::shutdown();
/// cgl_rs::graphics::shutdown();
/// window.destroy();
/// cgl_rs::shutdown();
/// ```
pub fn shutdown() {
    unsafe {
        CGL_widgets_shutdown();
    }
}



/// Begins a new CGL frame
/// 
/// # Returns
/// 
/// Returns `true` if the frame was successfully created, otherwise returns `false`
/// 
/// # Example
/// 
/// ```
/// cgl_rs::init();
/// let mut window = cgl_rs::Window::new("CGL Window", 800, 600).unwrap();
/// cgl_rs::graphics::init();
/// cgl_rs::graphics::widgets::init();
/// 
/// while !window.should_close() {
///     // bind framebuffers, etc.
///     cgl_rs::graphics::widgets::begin(); // you could also check if the function returns true
///         // draw widgets here
///     cgl_rs::graphics::widgets::end();
///     // update window, swap buffers, etc.
///     break; // for testing purposes
/// }
/// 
/// cgl_rs::graphics::widgets::shutdown();
/// cgl_rs::graphics::shutdown();
/// window.destroy();
/// cgl_rs::shutdown();
/// ```
pub fn begin() -> bool {
    unsafe {
        CGL_widgets_begin() == 1
    }
}


/// Begins a new CGL frame with a global scale and offset.
/// 
/// # Arguments
/// 
/// * `scale_x` - The horizontal scaling factor
/// * `scale_y` - The vertical scaling factor
/// * `offset_x` - The horizontal offset
/// * `offset_y` - The vertical offset
/// 
/// # Returns
/// 
/// Returns `true` if the frame was successfully created, otherwise returns `false`
/// 
/// # Example
/// 
/// ```
/// cgl_rs::init();
/// let mut window = cgl_rs::Window::new("CGL Window", 800, 600).unwrap();
/// cgl_rs::graphics::init();
/// cgl_rs::graphics::widgets::init();
/// 
/// while !window.should_close() {
///     // bind framebuffers, etc.
///     cgl_rs::graphics::widgets::begin_int(2.0, 2.0, 0.0, 0.0); // you could also check if the function returns true
///         // draw widgets here
///     cgl_rs::graphics::widgets::end();
///     // update window, swap buffers, etc.
///     break; // for testing purposes
/// }
/// 
/// cgl_rs::graphics::widgets::shutdown();
/// cgl_rs::graphics::shutdown();
/// window.destroy();
/// cgl_rs::shutdown();
/// ```
pub fn begin_int(scale_x: f32, scale_y: f32, offset_x: f32, offset_y: f32) -> bool {
    unsafe {
        CGL_widgets_begin_int(scale_x, scale_y, offset_x, offset_y) == 1
    }    
}

/// Ends the current CGL frame
/// 
/// # Returns
/// 
/// Returns `true` if the frame was successfully ended, otherwise returns `false`
/// 
/// # Example
/// 
/// ```
/// cgl_rs::init();
/// let mut window = cgl_rs::Window::new("CGL Window", 800, 600).unwrap();
/// cgl_rs::graphics::init();
/// cgl_rs::graphics::widgets::init();
/// 
/// while !window.should_close() {
///     // bind framebuffers, etc.
///     cgl_rs::graphics::widgets::begin();
///         // draw widgets here
///     cgl_rs::graphics::widgets::end(); // you could also check if the function returns true
///     // update window, swap buffers, etc.
///     break; // for testing purposes
/// }
/// 
/// cgl_rs::graphics::widgets::shutdown();
/// cgl_rs::graphics::shutdown();
/// window.destroy();
/// cgl_rs::shutdown();
/// ```
pub fn end() -> bool {
    unsafe {
        CGL_widgets_end() == 1
    }
}


/// Flushes all the vertices added to the current batch.
/// 
/// # Returns
/// 
/// Returns `true` if the vertices were successfully flushed, otherwise returns `false`
/// 
/// # Example
/// 
/// ```
/// cgl_rs::init();
/// let mut window = cgl_rs::Window::new("CGL Window", 800, 600).unwrap();
/// cgl_rs::graphics::init();
/// cgl_rs::graphics::widgets::init();
/// 
/// while !window.should_close() {
///     // bind framebuffers, etc.
///     cgl_rs::graphics::widgets::begin();
///         // draw widgets here
///     cgl_rs::graphics::widgets::flush(); // you could also check if the function returns true
///     cgl_rs::graphics::widgets::end();
///     // update window, swap buffers, etc.
///     break; // for testing purposes
/// }
/// 
/// cgl_rs::graphics::widgets::shutdown();
/// cgl_rs::graphics::shutdown();
/// window.destroy();
/// cgl_rs::shutdown();
/// ```
pub fn flush() -> bool {
    unsafe {
        CGL_widgets_flush() == 1
    }
}



/// Flushes all the vertices added to the current batch if required.
/// 
/// # Returns
/// 
/// Returns `true` if the vertices were successfully flushed, otherwise returns `false`
/// 
/// # Example
/// 
/// ```
/// cgl_rs::init();
/// let mut window = cgl_rs::Window::new("CGL Window", 800, 600).unwrap();
/// cgl_rs::graphics::init();
/// cgl_rs::graphics::widgets::init();
/// 
/// while !window.should_close() {
///     // bind framebuffers, etc.
///     cgl_rs::graphics::widgets::begin();
///         // draw widgets here
///     cgl_rs::graphics::widgets::flush_if_required(); // you could also check if the function returns true
///     cgl_rs::graphics::widgets::end();
///     // update window, swap buffers, etc.
///     break; // for testing purposes
/// }
/// 
/// cgl_rs::graphics::widgets::shutdown();
/// cgl_rs::graphics::shutdown();
/// window.destroy();
/// cgl_rs::shutdown();
/// ```
pub fn flush_if_required() -> bool {
    unsafe {
        CGL_widgets_flush_if_required() == 1
    }
}

/// Adds a vertex with the given position to the current batch.
/// 
/// # Arguments
/// 
/// * `position` - A `Vector3` representing the position of the vertex.
pub fn add_vertex_p(position: Vector3) {
    unsafe {
        CGL_widgets_add_vertex_p(position);
    }
}

/// Adds a vertex with the given position to the current batch.
/// 
/// # Arguments
/// 
/// * `x` - A `f32` representing the x-coordinate of the position of the vertex.
/// * `y` - A `f32` representing the y-coordinate of the position of the vertex.
/// * `z` - A `f32` representing the z-coordinate of the position of the vertex.
pub fn add_vertex_p3f(x: f32, y: f32, z: f32) {
    unsafe {
        CGL_widgets_add_vertex_p3f(x, y, z);
    }
}

/// Adds a vertex with the given position and texture coordinate to the current batch.
/// 
/// # Arguments
/// 
/// * `position` - A `Vector3` representing the position of the vertex.
/// * `tex_coord` - A `Vector2` representing the texture coordinate of the vertex.
pub fn add_vertex_pt(position: Vector3, tex_coord: Vector2) {
    unsafe {
        CGL_widgets_add_vertex_pt(position, tex_coord);
    }
}

/// Adds a vertex with the given position and texture coordinate to the current batch.
/// 
/// # Arguments
/// 
/// * `pos_x` - A `f32` representing the x-coordinate of the position of the vertex.
/// * `pos_y` - A `f32` representing the y-coordinate of the position of the vertex.
/// * `pos_z` - A `f32` representing the z-coordinate of the position of the vertex.
/// * `tex_coord` - A `Vector2` representing the texture coordinate of the vertex.
pub fn  add_vertex_p3ft(pos_x: f32, pos_y: f32, pos_z: f32, tex_coord: Vector2) {
    unsafe {
        CGL_widgets_add_vertex_p3ft(pos_x, pos_y, pos_z, tex_coord);
    }
}

/// Adds a vertex with the given position and texture coordinate to the current batch.
/// 
/// # Arguments
/// 
/// * `position` - A `Vector3` representing the position of the vertex.
/// * `tex_coord_x` - A `f32` representing the x-coordinate of the texture coordinate of the vertex.
/// * `tex_coord_y` - A `f32` representing the y-coordinate of the texture coordinate of the vertex.
pub fn add_vertex_pt2f(position: Vector3, tex_coord_x: f32, tex_coord_y: f32) {
    unsafe {
        CGL_widgets_add_vertex_pt2f(position, tex_coord_x, tex_coord_y);
    }
}

/// Adds a vertex with the given position and texture coordinate to the current batch.
/// 
/// # Arguments
/// 
/// * `pos_x` - A `f32` representing the x-coordinate of the position of the vertex.
/// * `pos_y` - A `f32` representing the y-coordinate of the position of the vertex.
/// * `pos_z` - A `f32` representing the z-coordinate of the position of the vertex.
/// * `tex_coord_x` - A `f32` representing the x-coordinate of the texture coordinate of the vertex.
/// * `tex_coord_y` - A `f32` representing the y-coordinate of the texture coordinate of the vertex.
pub fn add_vertex_p3ft2f(pos_x: f32, pos_y: f32, pos_z: f32, tex_coord_x: f32, tex_coord_y: f32) {
    unsafe {
        CGL_widgets_add_vertex_p3ft2f(pos_x, pos_y, pos_z, tex_coord_x, tex_coord_y);
    }
}


/// Sets the stroke color for the current frame.
/// 
/// # Arguments
/// 
/// * `color` - A `Vector4` representing the color of the stroke.
pub fn set_stroke_color(color: Vector4) {
    unsafe {
        CGL_widgets_set_stroke_color(color);
    }
}

/// Sets the stroke color for the current frame.
/// 
/// # Arguments
/// 
/// * `r` - A `f32` representing the red component of the stroke color.
/// * `g` - A `f32` representing the green component of the stroke color.
/// * `b` - A `f32` representing the blue component of the stroke color.
/// * `a` - A `f32` representing the alpha component of the stroke color.
pub fn set_stroke_colorf(r: f32, g: f32, b: f32, a: f32) {
    unsafe {
        CGL_widgets_set_stroke_colorf(r, g, b, a);
    }
}

/// Sets the fill color for the current frame.
/// 
/// # Arguments
/// 
/// * `color` - A `Vector4` representing the color of the fill.
pub fn set_fill_color(color: Vector4) {
    unsafe {
        CGL_widgets_set_fill_color(color);
    }
}

/// Sets the fill color for the current frame.
/// 
/// # Arguments
/// 
/// * `r` - A `f32` representing the red component of the fill color.
/// * `g` - A `f32` representing the green component of the fill color.
/// * `b` - A `f32` representing the blue component of the fill color.
/// * `a` - A `f32` representing the alpha component of the fill color.
pub fn set_fill_colorf(r: f32, g: f32, b: f32, a: f32) {
    unsafe {
        CGL_widgets_set_fill_colorf(r, g, b, a);
    }
}

/// Sets the mask rendering mask for the current frame.
/// 
/// 
/// # Arguments
/// 
/// * `mask` - A `Vector4` representing the color of the mask. 
///            The mask is in the format (start_x, start_y, end_x, end_y)
pub fn set_mask(mask: Vector4) {
    unsafe {
        CGL_widgets_set_mask(mask);
    }
}

/// Sets the mask rendering mask for the current frame.
/// 
/// # Arguments
/// 
/// * `r` - A `f32` representing the red component of the mask color.
/// * `g` - A `f32` representing the green component of the mask color.
/// * `b` - A `f32` representing the blue component of the mask color.
/// * `a` - A `f32` representing the alpha component of the mask color.
pub fn set_maskf(r: f32, g: f32, b: f32, a: f32) {
    unsafe {
        CGL_widgets_set_maskf(r, g, b, a);
    }
}

/// Sets the stroke thickness for the current frame.
/// 
/// # Arguments
/// 
/// * `thickness` - A `f32` representing the thickness of the stroke.
pub fn set_stroke_thickness(thickness: f32) {
    unsafe {
        CGL_widgets_set_stroke_thicnkess(thickness);
    }
}

/// Sets the fill mode for the current frame.
/// 
/// # Arguments
/// 
/// * `mode` - A `bool` representing the fill mode. `true` for fill, `false` for wireframe.
pub fn set_fill_mode(mode: bool) {
    unsafe {
        CGL_widgets_set_fill_mode(mode as i32);
    }
}

/// Enables diffuse shading for the current frame.
/// 
/// # Arguments
/// 
/// * `light_pos` - A `Vector3` representing the position of the light source.
/// * `light_color` - A `Vector3` representing the color of the light source.
pub fn enable_diffuse_shading(light_pos: Vector3, light_color: Vector3) {
    unsafe {
        CGL_widgets_enable_diffuse_shading(light_pos, light_color);
    }
}

/// Disables diffuse shading for the current frame.
pub fn disable_diffuse_shading() {
    unsafe {
        CGL_widgets_disable_diffuse_shading();
    }
}

/// Sets the projection matrix for the current frame.
/// 
/// # Arguments
/// 
/// * `matrix` - A reference to a `Matrix4x4` representing the projection matrix.
pub fn set_projection_matrix(matrix: &Matrix4x4) {
    unsafe {
        CGL_widgets_set_projection_matrix(matrix as *const Matrix4x4 as *mut Matrix4x4);
    }
}

/// Sets the view matrix for the current frame.
/// 
/// # Arguments
/// 
/// * `matrix` - A reference to a `Matrix4x4` representing the view matrix.
pub fn set_view_matrix(matrix: &Matrix4x4) {
    unsafe {
        CGL_widgets_set_view_matrix(matrix as *const Matrix4x4 as *mut Matrix4x4);
    }
}

/// Sets the model matrix for the current frame.
/// 
/// # Arguments
/// 
/// * `matrix` - A reference to a `Matrix4x4` representing the model matrix.
pub fn set_model_matrix(matrix: &Matrix4x4) {
    unsafe {
        CGL_widgets_set_model_matrix(matrix as *const Matrix4x4 as *mut Matrix4x4);
    }
}

/// Sets the texture for the current frame.
/// 
/// # Arguments
/// 
/// * `texture` - A reference to a `Texture` representing the texture to be set.
pub fn set_texture(texture: &Texture) {
    unsafe {
        CGL_widgets_set_texture(texture.handle);
    }
}

/// Sets the font texture for the current frame.
/// 
/// # Arguments
/// 
/// * `texture` - A reference to a `Texture` representing the font texture to be set.
pub fn set_font_texture(texture: &Texture) {
    unsafe {
        CGL_widgets_set_font_texture(texture.handle);
    }
}

/// Sets the texture coordinate scale and offset for the current frame.
/// 
/// # Arguments
/// 
/// * `scale_x` - A `f32` representing the scale factor for the x-coordinate.
/// * `scale_y` - A `f32` representing the scale factor for the y-coordinate.
/// * `offset_x` - A `f32` representing the offset for the x-coordinate.
/// * `offset_y` - A `f32` representing the offset for the y-coordinate.
pub fn set_texture_coordinate_so(scale_x: f32, scale_y: f32, offset_x: f32, offset_y: f32) {
    unsafe {
        CGL_widgets_set_texture_coordinate_so(scale_x, scale_y, offset_x, offset_y);
    }
}



/// This enables the transformation application on the CPU.
/// 
/// Enabling this will slow down the rendering process.
/// 
/// Also, this is currently a bit glitchy.
pub fn apply_transformations_on_cpu() {
    unsafe {
        CGL_widgets_apply_transformations_on_cpu();
    }
}

/// This enables the transformation application on the GPU.
/// 
/// This is the default setting.
pub fn apply_transformations_on_gpu() {
    unsafe {
        CGL_widgets_apply_transformations_on_gpu();
    }
}

/// Adds a triangle to the current frame.
/// 
/// # Arguments
/// 
/// * `a` - A `Vector3` representing the first vertex of the triangle.
/// * `b` - A `Vector3` representing the second vertex of the triangle.
/// * `c` - A `Vector3` representing the third vertex of the triangle.
pub fn add_triangle(a: Vector3, b: Vector3, c: Vector3) {
    unsafe {
        CGL_widgets_add_triangle(a, b, c);
    }
}

/// Adds a quad to the current frame.
/// 
/// # Arguments
/// 
/// * `a` - A `Vector3` representing the first vertex of the quad.
/// * `b` - A `Vector3` representing the second vertex of the quad.
/// * `c` - A `Vector3` representing the third vertex of the quad.
/// * `d` - A `Vector3` representing the fourth vertex of the quad.
pub fn add_quad(a: Vector3, b: Vector3, c: Vector3, d: Vector3) {
    unsafe {
        CGL_widgets_add_quad(a, b, c, d);
    }
}

/// Adds a quad to the current frame.
/// 
/// # Arguments
/// 
/// * `ax` - A `f32` representing the x-coordinate of the first vertex of the quad.
/// * `ay` - A `f32` representing the y-coordinate of the first vertex of the quad.
/// * `bx` - A `f32` representing the x-coordinate of the second vertex of the quad.
/// * `by` - A `f32` representing the y-coordinate of the second vertex of the quad.
/// * `cx` - A `f32` representing the x-coordinate of the third vertex of the quad.
/// * `cy` - A `f32` representing the y-coordinate of the third vertex of the quad.
/// * `dx` - A `f32` representing the x-coordinate of the fourth vertex of the quad.
/// * `dy` - A `f32` representing the y-coordinate of the fourth vertex of the quad.
pub fn add_quad_8f(ax: f32, ay: f32, bx: f32, by: f32, cx: f32, cy: f32, dx: f32, dy: f32) {
    unsafe {
        CGL_widgets_add_quad_8f(ax, ay, bx, by, cx, cy, dx, dy);
    }
}

/// Adds a line to the current frame.
/// 
/// # Arguments
/// 
/// * `start` - A `Vector3` representing the starting point of the line.
/// * `end` - A `Vector3` representing the ending point of the line.
pub fn add_line(start: Vector3, end: Vector3) {
    unsafe {
        CGL_widgets_add_line(start, end);
    }
}

/// Adds a line to the current frame.
/// 
/// # Arguments
/// 
/// * `start_x` - A `f32` representing the x-coordinate of the starting point of the line.
/// * `start_y` - A `f32` representing the y-coordinate of the starting point of the line.
/// * `end_x` - A `f32` representing the x-coordinate of the ending point of the line.
/// * `end_y` - A `f32` representing the y-coordinate of the ending point of the line.
pub fn add_line2f(start_x: f32, start_y: f32, end_x: f32, end_y: f32) {
    unsafe {
        CGL_widgets_add_line2f(start_x, start_y, end_x, end_y);
    }
}

/// Adds a rectangle to the current frame.
/// 
/// # Arguments
/// 
/// * `start` - A `Vector3` representing the starting point of the rectangle.
/// * `size` - A `Vector2` representing the size of the rectangle.
pub fn add_rect(start: Vector3, size: Vector2) {
    unsafe {
        CGL_widgets_add_rect(start, size);
    }
}

/// Adds a rectangle to the current frame.
/// 
/// # Arguments
/// 
/// * `start_x` - A `f32` representing the x-coordinate of the starting point of the rectangle.
/// * `start_y` - A `f32` representing the y-coordinate of the starting point of the rectangle.
/// * `size_x` - A `f32` representing the width of the rectangle.
/// * `size_y` - A `f32` representing the height of the rectangle.
pub fn add_rect2f(start_x: f32, start_y: f32, size_x: f32, size_y: f32) {
    unsafe {
        CGL_widgets_add_rect2f(start_x, start_y, size_x, size_y);
    }
}

/// Adds a rounded rectangle to the current frame.
/// 
/// # Arguments
/// 
/// * `start_x` - A `f32` representing the x-coordinate of the starting point of the rectangle.
/// * `start_y` - A `f32` representing the y-coordinate of the starting point of the rectangle.
/// * `size_x` - A `f32` representing the width of the rectangle.
/// * `size_y` - A `f32` representing the height of the rectangle.
/// * `radius` - A `f32` representing the radius of the corners of the rectangle.
/// * `res` - An `i32` representing the number of segments used to approximate the corners of the rectangle.
pub fn add_rounded_rect2f(start_x: f32, start_y: f32, size_x: f32, size_y: f32, radius: f32, res: i32) {
    unsafe {
        CGL_widgets_add_rounded_rect2f(start_x, start_y, size_x, size_y, radius, res);
    }
}

/// Adds a circle to the current frame.
/// 
/// # Arguments
/// 
/// * `position` - A `Vector3` representing the position of the center of the circle.
/// * `radius` - A `f32` representing the radius of the circle.
pub fn add_circle(position: Vector3, radius: f32) {
    unsafe {
        CGL_widgets_add_circle(position, radius);
    }
}

/// Adds a circle to the current frame.
/// 
/// # Arguments
/// 
/// * `pos_x` - A `f32` representing the x-coordinate of the center of the circle.
/// * `pos_y` - A `f32` representing the y-coordinate of the center of the circle.
/// * `radius` - A `f32` representing the radius of the circle.
pub fn add_circle2f(pos_x: f32, pos_y: f32, radius: f32) {
    unsafe {
        CGL_widgets_add_circle2f(pos_x, pos_y, radius);
    }
}

/// Adds a circle to the current frame.
/// 
/// # Arguments
/// 
/// * `position` - A `Vector3` representing the position of the center of the circle.
/// * `radius` - A `f32` representing the radius of the circle.
/// * `res` - An `i32` representing the number of segments used to approximate the circle.
pub fn add_circler(position: Vector3, radius: f32, res: i32) {
    unsafe {
        CGL_widgets_add_circler(position, radius, res);
    }
}

/// Adds a circle to the current frame.
/// 
/// # Arguments
/// 
/// * `pos_x` - A `f32` representing the x-coordinate of the center of the circle.
/// * `pos_y` - A `f32` representing the y-coordinate of the center of the circle.
/// * `radius` - A `f32` representing the radius of the circle.
/// * `res` - An `i32` representing the number of segments used to approximate the circle.
pub fn add_circle2fr(pos_x: f32, pos_y: f32, radius: f32, res: i32) {
    unsafe {
        CGL_widgets_add_circle2fr(pos_x, pos_y, radius, res);
    }
}

/// Adds an oval to the current frame.
/// 
/// # Arguments
/// 
/// * `position` - A `Vector3` representing the position of the center of the oval.
/// * `radius` - A `Vector2` representing the radii of the oval.
pub fn add_oval(position: Vector3, radius: Vector2) {
    unsafe {
        CGL_widgets_add_oval(position, radius);
    }
}

/// Adds an oval to the current frame.
/// 
/// # Arguments
/// 
/// * `pos_x` - A `f32` representing the x-coordinate of the center of the oval.
/// * `pos_y` - A `f32` representing the y-coordinate of the center of the oval.
/// * `radius_x` - A `f32` representing the x-radius of the oval.
/// * `radius_y` - A `f32` representing the y-radius of the oval.
pub fn add_oval2f(pos_x: f32, pos_y: f32, radius_x: f32, radius_y: f32) {
    unsafe {
        CGL_widgets_add_oval2f(pos_x, pos_y, radius_x, radius_y);
    }
}


/// Adds an oval to the current frame.
/// 
/// # Arguments
/// 
/// * `pos_x` - A `f32` representing the x-coordinate of the center of the oval.
/// * `pos_y` - A `f32` representing the y-coordinate of the center of the oval.
/// * `radiusx` - A `f32` representing the x-radius of the oval.
/// * `radiusy` - A `f32` representing the y-radius of the oval.
/// * `resolution` - An `i32` representing the number of segments used to approximate the oval.
pub fn add_oval2fr(pos_x: f32, pos_y: f32, radiusx: f32, radiusy: f32, resolution: i32) {
    unsafe {
        CGL_widgets_add_oval2fr(pos_x, pos_y, radiusx, radiusy, resolution);
    }
}

/// Adds an arc to the current frame.
/// 
/// # Arguments
/// 
/// * `pos_x` - A `f32` representing the x-coordinate of the center of the arc.
/// * `pos_y` - A `f32` representing the y-coordinate of the center of the arc.
/// * `radius` - A `f32` representing the radius of the arc.
/// * `start_angle` - A `f32` representing the starting angle of the arc in radians.
/// * `end_angle` - A `f32` representing the ending angle of the arc in radians.
/// * `resolution` - An `i32` representing the number of segments used to approximate the arc.
pub fn add_arc2f(pos_x: f32, pos_y: f32, radius: f32, start_angle: f32, end_angle: f32, resolution: i32) {
    unsafe {
        CGL_widgets_add_arc2f(pos_x, pos_y, radius, start_angle, end_angle, resolution);
    }
}

/// Adds a character to the current frame.
/// 
/// # Arguments
/// 
/// * `c` - A `char` representing the character to add.
/// * `x` - A `f32` representing the x-coordinate of the starting point of the character.
/// * `y` - A `f32` representing the y-coordinate of the starting point of the character.
/// * `sx` - A `f32` representing the x-scale of the character.
/// * `sy` - A `f32` representing the y-scale of the character.
/// 
/// # Returns
/// 
/// An `i32` representing the width of the character.
pub fn add_character(c: char, x: f32, y: f32, sx: f32, sy: f32) -> i32 {
    unsafe {
        CGL_widgets_add_character(c as c_char, x, y, sx, sy)
    }
}

/// Adds a string to the current frame.
/// 
/// # Arguments
/// 
/// * `str` - A `&str` representing the string to add.
/// * `x` - A `f32` representing the x-coordinate of the starting point of the string.
/// * `y` - A `f32` representing the y-coordinate of the starting point of the string.
/// * `sx` - A `f32` representing the x-scale of the string.
/// * `sy` - A `f32` representing the y-scale of the string.
/// 
/// # Returns
/// 
/// An `i32` representing the width of the string.
pub fn add_string(str_value: &str, x: f32, y: f32, sx: f32, sy: f32) -> i32 {
    unsafe {
        let string_c =  std::ffi::CString::new(str_value).unwrap();
        CGL_widgets_add_string( string_c.as_ptr() as *const c_char, x, y, sx, sy)
    }
}

/// Adds a string to the current frame with a specified font.
/// 
/// # Arguments
/// 
/// * `str` - A `&str` representing the string to add.
/// * `font` - A `*mut CGL_font` representing the font to use.
/// * `x` - A `f32` representing the x-coordinate of the starting point of the string.
/// * `y` - A `f32` representing the y-coordinate of the starting point of the string.
/// * `sx` - A `f32` representing the x-scale of the string.
/// * `scale_y` - A `f32` representing the y-scale of the string.
/// 
/// # Returns
/// 
/// A `f32` representing the width of the string.
pub fn add_string_with_font(str_value: &str, font: &Font, x: f32, y: f32, sx: f32, scale_y: f32) -> f32 {
    unsafe {
        let string_c =  std::ffi::CString::new(str_value).unwrap();
        CGL_widgets_add_string_with_font(string_c.as_ptr() as *const c_char, font.handle, x, y, sx, scale_y)
    }
}

/// Adds a cubic bezier curve to the current frame.
/// 
/// # Arguments
/// 
/// * `start` - A `Vector3` representing the starting point of the curve.
/// * `end` - A `Vector3` representing the ending point of the curve.
/// * `control_1` - A `Vector3` representing the first control point of the curve.
/// * `control_2` - A `Vector3` representing the second control point of the curve.
/// * `resolution` - An `i32` representing the number of segments used to approximate the curve.
pub fn add_cubic_bazier(start: Vector3, end: Vector3, control_1: Vector3, control_2: Vector3, resolution: i32) {
    unsafe {
        CGL_widgets_add_cubic_bazier(start, end, control_1, control_2, resolution);
    }
}

/// Adds a cubic bezier curve to the current frame.
/// 
/// # Arguments
/// 
/// * `start` - A `Vector2` representing the starting point of the curve.
/// * `end` - A `Vector2` representing the ending point of the curve.
/// * `control_1` - A `Vector2` representing the first control point of the curve.
/// * `control_2` - A `Vector2` representing the second control point of the curve.
/// * `resolution` - An `i32` representing the number of segments used to approximate the curve.
pub fn add_cubic_bazier2v(start: Vector2, end: Vector2, control_1: Vector2, control_2: Vector2, resolution: i32) {
    unsafe {
        CGL_widgets_add_cubic_bazier2v(start, end, control_1, control_2, resolution);
    }
}

/// Adds a cubic bezier curve to the current frame.
/// 
/// # Arguments
/// 
/// * `start_x` - A `f32` representing the x-coordinate of the starting point of the curve.
/// * `start_y` - A `f32` representing the y-coordinate of the starting point of the curve.
/// * `end_x` - A `f32` representing the x-coordinate of the ending point of the curve.
/// * `end_y` - A `f32` representing the y-coordinate of the ending point of the curve.
/// * `control_1_x` - A `f32` representing the x-coordinate of the first control point of the curve.
/// * `control_1_y` - A `f32` representing the y-coordinate of the first control point of the curve.
/// * `control_2_x` - A `f32` representing the x-coordinate of the second control point of the curve.
/// * `control_2_y` - A `f32` representing the y-coordinate of the second control point of the curve.
/// * `resolution` - An `i32` representing the number of segments used to approximate the curve.
pub fn add_cubic_bazier2f(start_x: f32, start_y: f32, end_x: f32, end_y: f32, control_1_x: f32, control_1_y: f32, control_2_x: f32, control_2_y: f32, resolution: i32) {
    unsafe {
        CGL_widgets_add_cubic_bazier2f(start_x, start_y, end_x, end_y, control_1_x, control_1_y, control_2_x, control_2_y, resolution);
    }
}

/// Adds a cubic bezier curve to the current frame using points.
/// 
/// # Arguments
/// 
/// * `start` - A `Vector3` representing the starting point of the curve.
/// * `end` - A `Vector3` representing the ending point of the curve.
/// * `control_1` - A `Vector3` representing the first control point of the curve.
/// * `control_2` - A `Vector3` representing the second control point of the curve.
/// * `resolution` - An `i32` representing the number of segments used to approximate the curve.
pub fn add_cubic_bazier_points(start: Vector3, end: Vector3, control_1: Vector3, control_2: Vector3, resolution: i32) {
    unsafe {
        CGL_widgets_add_cubic_bazier_points(start, end, control_1, control_2, resolution);
    }
}


// Adds a cubic bezier curve to the current frame using 2D vectors as points.
/// 
/// # Arguments
/// 
/// * `start` - A `Vector2` representing the starting point of the curve.
/// * `end` - A `Vector2` representing the ending point of the curve.
/// * `control_1` - A `Vector2` representing the first control point of the curve.
/// * `control_2` - A `Vector2` representing the second control point of the curve.
/// * `resolution` - An `i32` representing the number of segments used to approximate the curve.
pub fn add_cubic_bazier_points2v(start: Vector2, end: Vector2, control_1: Vector2, control_2: Vector2, resolution: i32) {
    unsafe {
        CGL_widgets_add_cubic_bazier_points2v(start, end, control_1, control_2, resolution);
    }
}

```

`rust_wrapper/cgl-rs/src/lib.rs`:

```rs
#![allow(dead_code)]


//! The CGL Library
//! 
//! CGL is a library for creating cross-platform graphical applications and mainly creative coding.
//! 
//! 
//! You can find the CGL main repository at : <https://github.com/Jaysmito101/cgl>
//! 
//! Also You can find a huge collections of creative coding projects, simultions, games made at : <https://github.com/Jaysmito101/cgl/tree/main/examples>

use std::result;
use libc::{c_void, c_int};



mod macros;

pub mod utils;
pub mod math;
pub mod graphics;
pub mod logger;
pub mod noise;
// pub use logger::*;
pub mod window;
pub use window::*;

extern {
    fn CGL_init() -> c_int;
    fn CGL_shutdown() -> c_void;
}


/// Initializes the CGL library.
/// 
/// This function must be called before any other CGL functions are called.
///
/// # Returns
///
/// Returns `Ok(())` if the initialization was successful, otherwise returns `Err(())`.
pub fn init() -> result::Result<(), ()> {
    unsafe {
        let result = CGL_init();
        if result == 0 {
            Err(())
        } else {
            Ok(())
        }   
    }
}


/// Shuts down the CGL library.
///
/// This function should be called when the CGL library is no longer needed.
pub fn shutdown() -> () {
    unsafe {
        CGL_shutdown();
    }
}
```

`rust_wrapper/cgl-rs/src/logger.rs`:

```rs
//! This module contains functions for logging.

#![allow(non_camel_case_types)]
use libc::{c_void, c_int, c_char, c_float, c_uchar};


/// A struct representing a logger context (internal use only, c side)
#[repr(C)]
pub struct CGL_logger_context {
    _private: c_void
}

extern {
    fn CGL_console_set_color(color: c_uchar) -> c_void;

    fn CGL_printf_red(log_format: *const c_char, ...) -> c_void;
    fn CGL_printf_green(log_format: *const c_char, ...) -> c_void;
    fn CGL_printf_gray(log_format: *const c_char, ...) -> c_void;
    fn CGL_printf_blue(log_format: *const c_char, ...) -> c_void;
    fn CGL_console_progress_bar(progress: c_float, width: c_int, prefix: *const c_char, suffix: *const c_char, complete_char: c_char, incomplete_char: c_char) -> c_void;

    
    fn CGL_logger_init(enable_console_logging: c_int) -> c_void;
    fn CGL_logger_shutdown() -> c_void;
    fn CGL_logger_get_context() -> *const CGL_logger_context;
    fn CGL_logger_set_context(context: *const CGL_logger_context) -> c_void;
    fn CGL_logger_attach_log_file(log_file_path: *const c_char) -> c_int;
    fn CGL_logger_detach_log_file(log_file_path: *const c_char) -> c_int;
    fn CGL_logger_flush() -> c_void;
    fn CGL_logger_disable_console_logging() -> c_void;
    fn CGL_logger_enable_console_logging() -> c_void;
    fn CGL_logger_log(level: c_int, log_format: *const c_char, ...) -> c_void;    
}


/// An enum representing console colors.
#[repr(C)] #[derive(Debug)]
pub enum ConsoleColor {
    Reset = 0,
    Red   = 1,
    Green = 2,
    Gray  = 3,
    Blue  = 4
}

/// An enum representing log levels.
#[repr(C)] #[derive(Debug)]
pub enum LogLevel {
    Trace    = 0,
    Info     = 1,
    Warning  = 2,
    Error    = 3,
    Internal = 4
}

/// This is a temporary thing. This has already been implemented in the c side.
/// Just the API is not public yet, so I'm using this for now.
static mut AUTO_FLUSH_ON_LOG: bool = false;


/// Initializes the logger.
///
/// NOTE: This is automatically called when you call cgl_rs::init().
///       So it's not necessary to call this function manually, unless you are 
///       doing something special, like creating a seperate context for some dll or stuff.
/// 
/// # Arguments
///
/// * `enable_console_logging` - A boolean value indicating whether to enable console logging or not.
///
/// # Example
///
/// ```
/// cgl_rs::logger::init(true);
/// // ...
/// cgl_rs::logger::shutdown();
/// ```
pub fn init(enable_console_logging: bool) -> () {
    unsafe {
        CGL_logger_init(enable_console_logging as c_int);
    }
}

/// Shuts down the logger.
///
/// NOTE: This is automatically called when you call cgl_rs::shutdown().
/// 
/// # Example
///
/// ```
/// cgl_rs::logger::init(true);
/// // ...
/// cgl_rs::logger::shutdown();
/// ```
pub fn shutdown() -> () {
    unsafe {
        CGL_logger_shutdown();
    }
}

/// Returns a pointer to the logger context.
///
/// # Safety
///
/// This function is unsafe because it returns a raw pointer to the logger context.
///
/// # Example
///
/// ```
/// cgl_rs::logger::init(true);
/// let context = cgl_rs::logger::get_context();
/// // ...
/// cgl_rs::logger::shutdown();
/// ```
pub fn get_context() -> *const CGL_logger_context {
    unsafe {
        CGL_logger_get_context()
    }
}

/// Sets the logger context.
/// 
/// # Safety
/// 
/// This function is unsafe because it takes a raw pointer to the logger context.
/// 
/// # Arguments
/// 
/// * `context` - A raw pointer to the logger context.
/// 
/// # Example
/// 
/// ```
/// cgl_rs::logger::init(true);
/// let context = cgl_rs::logger::get_context();
/// cgl_rs::logger::set_context(context);
/// // ...
/// cgl_rs::logger::shutdown();
/// ```
pub fn set_context(context: *const CGL_logger_context) -> () {
    unsafe {
        CGL_logger_set_context(context);
    }
}


/// Attaches a log file to the logger. If the log file already exists, it will be appended to, otherwise it will be created.
/// Also note that there is a limit of 32 (may change in the future) log files that can be attached at the same time.
///
/// # Arguments
///
/// * `log_file_path` - A string slice containing the path to the log file.
///
/// # Returns
///
/// A boolean value indicating whether the log file was successfully attached or not.
///
/// # Example
///
/// ```
/// cgl_rs::logger::init(true);
/// let log_file_path = "log.txt";
/// let attached = cgl_rs::logger::attach_log_file(log_file_path);
/// // ...
/// cgl_rs::logger::shutdown();
/// ```
pub fn attach_log_file(log_file_path: &str) -> bool {
    let c_log_file_path = std::ffi::CString::new(log_file_path).unwrap();
    unsafe {
        CGL_logger_attach_log_file(c_log_file_path.as_ptr()) != 0
    }
}

/// Detaches a log file from the logger.
///
/// # Arguments
///
/// * `log_file_path` - A string slice containing the path to the log file.
///
/// # Returns
///
/// A boolean value indicating whether the log file was successfully detached or not.
///
/// # Example
///
/// ```
/// cgl_rs::logger::init(true);
/// let log_file_path = "log.txt";
/// cgl_rs::logger::attach_log_file(log_file_path);
/// let detached = cgl_rs::logger::detach_log_file(log_file_path);
/// // ...
/// cgl_rs::logger::shutdown();
/// ```
pub fn detach_log_file(log_file_path: &str) -> bool {
    let c_log_file_path = std::ffi::CString::new(log_file_path).unwrap();
    unsafe {
        CGL_logger_detach_log_file(c_log_file_path.as_ptr()) != 0
    }
}

/// Flushes all log messages to their respective log files.
///
/// # Example
///
/// ```
/// cgl_rs::logger::init(true);
/// // ...
/// cgl_rs::logger::flush();
/// // ...
/// cgl_rs::logger::shutdown();
/// ```
pub fn flush() -> () {
    unsafe {
        CGL_logger_flush();
    }
}
/// Disables console logging.
///
/// # Example
///
/// ```
/// cgl_rs::logger::init(true);
/// cgl_rs::logger::disable_console_logging();
/// // ...
/// cgl_rs::logger::shutdown();
/// ```
pub fn disable_console_logging() -> () {
    unsafe {
        CGL_logger_disable_console_logging();
    }
}

/// Enables console logging.
///
/// # Example
///
/// ```
/// cgl_rs::logger::init(true);
/// cgl_rs::logger::enable_console_logging();
/// // ...
/// cgl_rs::logger::shutdown();
/// ```
pub fn enable_console_logging() -> () {
    unsafe {
        CGL_logger_enable_console_logging();
    }
}

/// Sets whether the logger should automatically flush all log messages to their respective log files after each log message.
///
/// # Arguments
///
/// * `auto_flush_on_log` - A boolean value indicating whether the logger should automatically flush all log messages to their respective log files after each log message.
///
/// # Example
///
/// ```
/// cgl_rs::logger::init(true);
/// cgl_rs::logger::set_auto_flush_on_log(true);
/// // ...
/// cgl_rs::logger::shutdown();
/// ```
pub fn set_auto_flush_on_log(auto_flush_on_log: bool) -> () {
    unsafe {
        AUTO_FLUSH_ON_LOG = auto_flush_on_log;
    }
}


/// Logs a message with the specified log level.
///
/// # Arguments
///
/// * `level` - The log level of the message.
/// * `message` - A string slice containing the message to log.
///
/// # Example
///
/// ```
/// cgl_rs::logger::init(true);
/// cgl_rs::logger::log(cgl_rs::logger::LogLevel::Info, "This is an info message.");
/// // ...
/// cgl_rs::logger::shutdown();
/// ```
pub fn log(level: LogLevel, message: &str) -> () {
    let c_message = std::ffi::CString::new(message).unwrap();
    unsafe {
        CGL_logger_log(level as c_int, c_message.as_ptr());

        if AUTO_FLUSH_ON_LOG {
            flush();
        }
    }
}

/// Logs a trace message with the specified format string and arguments.
///
/// # Arguments
///
/// * `format` - A format string for the trace message.
/// * `args` - Arguments to be formatted into the trace message.
///
/// # Example
///
/// ```
/// cgl_rs::logger::init(true);
/// cgl_rs::log_trace!("This is a trace message with an argument: {}", 42);
/// // ...
/// cgl_rs::logger::shutdown();
/// ```
#[macro_export]
macro_rules! log_trace {
    ($($arg:tt)*) => ($crate::logger::log($crate::logger::LogLevel::Trace, &format!($($arg)*)));
}

/// Logs a warning message with the specified format string and arguments.
///
/// # Arguments
///
/// * `format` - A format string for the warning message.
/// * `args` - Arguments to be formatted into the warning message.
///
/// # Example
///
/// ```
/// cgl_rs::logger::init(true);
/// cgl_rs::log_warning!("This is a warning message with an argument: {}", 42);
/// // ...
/// cgl_rs::logger::shutdown();
/// ```
#[macro_export]
macro_rules! log_warning {
    ($($arg:tt)*) => ($crate::logger::log($crate::logger::LogLevel::Warning, &format!($($arg)*)));
}


/// Logs an error message with the specified format string and arguments.
/// 
/// # Arguments
/// 
/// * `format` - A format string for the error message.
/// * `args` - Arguments to be formatted into the error message.
/// 
/// # Example
/// 
/// ```
/// cgl_rs::logger::init(true);
/// cgl_rs::log_error!("This is an error message with an argument: {}", 42);
/// // ...
/// cgl_rs::logger::shutdown();
/// ```
#[macro_export]
macro_rules! log_error {
    ($($arg:tt)*) => ($crate::logger::log($crate::logger::LogLevel::Error, &format!($($arg)*)));
}


/// Logs an info message with the specified format string and arguments.
///
/// # Arguments
///
/// * `format` - A format string for the info message.
/// * `args` - Arguments to be formatted into the info message.
///
/// # Example
///
/// ```
/// cgl_rs::logger::init(true);
/// cgl_rs::log_info!("This is an info message with an argument: {}", 42);
/// // ...
/// cgl_rs::logger::shutdown();
/// ```
#[macro_export]
macro_rules! log_info {
    ($($arg:tt)*) => ($crate::logger::log($crate::logger::LogLevel::Info, &format!($($arg)*)));
}
```

`rust_wrapper/cgl-rs/src/macros.rs`:

```rs
//! This contains the macros used in the CGL library.

// The vector macros

macro_rules! impl_vector_binary_ops {
    ($vector:ident, $n:expr) => {
        // Implementation of addition
        impl std::ops::Add<$vector> for $vector {
            type Output = $vector;

            fn add(self, rhs: $vector) -> $vector {
                let mut result = $vector::zero();
                for i in 0..$n {
                    result[i] = self[i] + rhs[i];
                }
                result
            }
        }

        // Implementation of multiplication
        impl std::ops::Mul<$vector> for $vector {
            type Output = $vector;

            fn mul(self, rhs: $vector) -> $vector {
                let mut result = $vector::zero();
                for i in 0..$n {
                    result[i] = self[i] * rhs[i];
                }
                result
            }
        }

        // Implementation of scalar multiplication
        impl std::ops::Mul<f32> for $vector {
            type Output = $vector;

            fn mul(self, rhs: f32) -> $vector {
                let mut result = $vector::zero();
                for i in 0..$n {
                    result[i] = self[i] * rhs;
                }
                result
            }
        }

        // Implementation of subtraction
        impl std::ops::Sub<$vector> for $vector {
            type Output = $vector;

            fn sub(self, rhs: $vector) -> $vector {
                let mut result = $vector::zero();
                for i in 0..$n {
                    result[i] = self[i] - rhs[i];
                }
                result
            }
        }

        // Implementation of division
        impl std::ops::Div<$vector> for $vector {
            type Output = $vector;

            fn div(self, rhs: $vector) -> $vector {
                let mut result = $vector::zero();
                for i in 0..$n {
                    result[i] = self[i] / rhs[i];
                }
                result
            }
        }

        // Implementation of scalar division
        impl std::ops::Div<f32> for $vector {
            type Output = $vector;

            fn div(self, rhs: f32) -> $vector {
                let mut result = $vector::zero();
                for i in 0..$n {
                    result[i] = self[i] / rhs;
                }
                result
            }
        }

        // Implementation of negation
        impl std::ops::Neg for $vector {
            type Output = $vector;

            fn neg(self) -> $vector {
                let mut result = $vector::zero();
                for i in 0..$n {
                    result[i] = -self[i];
                }
                result
            }
        }
    };
}

pub(crate) use impl_vector_binary_ops;
```

`rust_wrapper/cgl-rs/src/math.rs`:

```rs
//! Math Library of CGL

#![allow(non_camel_case_types)]

pub mod activations;
pub mod constants;

mod vector;
pub use self::vector::*;

mod matrix;
pub use self::matrix::*;
```

`rust_wrapper/cgl-rs/src/math/activations.rs`:

```rs
//! Some popular activation functions and their derivatives.

#![allow(non_camel_case_types)]
use libc::c_float;

extern {

    // the activation functions
    fn CGL_utils_sigmoid(x: c_float) -> c_float;
    fn CGL_utils_sigmoid_derivative(x: c_float) -> c_float;
    fn CGL_utils_relu(x: c_float) -> c_float;
    fn CGL_utils_relu_derivative(x: c_float) -> c_float;
    fn CGL_utils_tanh(x: c_float) -> c_float;
    fn CGL_utils_tanh_derivative(x: c_float) -> c_float;
    fn CGL_utils_step(x: c_float) -> c_float;
    fn CGL_utils_step_derivative(x: c_float) -> c_float;
    fn CGL_utils_relu_leaky(x: c_float) -> c_float;
    fn CGL_utils_relu_leaky_derivative(x: c_float) -> c_float;
    fn CGL_utils_relu_smooth(x: c_float) -> c_float;
    fn CGL_utils_relu_smooth_derivative(x: c_float) -> c_float;
}


/// Calculates the sigmoid activation function for a given input.
///
/// # Arguments
///
/// * `x` - A 32-bit float input value.
///
/// # Example
///
/// ```
/// let x = 0.5;
/// let result = cgl_rs::math::activations::sigmoid(x);
/// println!("sigmoid({}) = {}", x, result);
/// ```
pub fn sigmoid(x: f32) -> f32  {
    unsafe {
        CGL_utils_sigmoid(x as c_float) as f32
    }
}

/// Calculates the derivative of the sigmoid activation function for a given input.
///
/// # Arguments
///
/// * `x` - A 32-bit float input value.
///
/// # Example
///
/// ```
/// let x = 0.5;
/// let result = cgl_rs::math::activations::sigmoid_derivative(x);
/// println!("sigmoid_derivative({}) = {}", x, result);
/// ```
pub fn sigmoid_derivative(x: f32) -> f32  {
    unsafe {
        CGL_utils_sigmoid_derivative(x as c_float) as f32
    }
}

/// Calculates the ReLU activation function for a given input.
///
/// # Arguments
///
/// * `x` - A 32-bit float input value.
///
/// # Example
///
/// ```
/// let x = 0.5;
/// let result = cgl_rs::math::activations::relu(x);
/// println!("relu({}) = {}", x, result);
/// ```
pub fn relu(x: f32) -> f32  {
    unsafe {
        CGL_utils_relu(x as c_float) as f32
    }
}

/// Calculates the derivative of the ReLU activation function for a given input.
///
/// # Arguments
///
/// * `x` - A 32-bit float input value.
///
/// # Example
///
/// ```
/// let x = 0.5;
/// let result = cgl_rs::math::activations::relu_derivative(x);
/// println!("relu_derivative({}) = {}", x, result);
/// ```
pub fn relu_derivative(x: f32) -> f32  {
    unsafe {
        CGL_utils_relu_derivative(x as c_float) as f32
    }
}

/// Calculates the hyperbolic tangent activation function for a given input.
///
/// # Arguments
///
/// * `x` - A 32-bit float input value.
///
/// # Example
///
/// ```
/// let x = 0.5;
/// let result = cgl_rs::math::activations::tanh(x);
/// println!("tanh({}) = {}", x, result);
/// ```
pub fn tanh(x: f32) -> f32  {
    unsafe {
        CGL_utils_tanh(x as c_float) as f32
    }
}

/// Calculates the derivative of the hyperbolic tangent activation function for a given input.
///
/// # Arguments
///
/// * `x` - A 32-bit float input value.
///
/// # Example
///
/// ```
/// let x = 0.5;
/// let result = cgl_rs::math::activations::tanh_derivative(x);
/// println!("tanh_derivative({}) = {}", x, result);
/// ```
pub fn tanh_derivative(x: f32) -> f32  {
    unsafe {
        CGL_utils_tanh_derivative(x as c_float) as f32
    }
}

/// Calculates the step activation function for a given input.
///
/// # Arguments
///
/// * `x` - A 32-bit float input value.
///
/// # Example
///
/// ```
/// let x = 0.5;
/// let result = cgl_rs::math::activations::step(x);
/// println!("step({}) = {}", x, result);
/// ```
pub fn step(x: f32) -> f32  {
    unsafe {
        CGL_utils_step(x as c_float) as f32
    }
}

/// Calculates the derivative of the step activation function for a given input.
///
/// # Arguments
///
/// * `x` - A 32-bit float input value.
///
/// # Example
///
/// ```
/// let x = 0.5;
/// let result = cgl_rs::math::activations::step_derivative(x);
/// println!("step_derivative({}) = {}", x, result);
/// ```
pub fn step_derivative(x: f32) -> f32  {
    unsafe {
        CGL_utils_step_derivative(x as c_float) as f32
    }
}

/// Calculates the leaky ReLU activation function for a given input.
///
/// # Arguments
///
/// * `x` - A 32-bit float input value.
///
/// # Example
///
/// ```
/// let x = 0.5;
/// let result = cgl_rs::math::activations::relu_leaky(x);
/// println!("relu_leaky({}) = {}", x, result);
/// ```
pub fn relu_leaky(x: f32) -> f32  {
    unsafe {
        CGL_utils_relu_leaky(x as c_float) as f32
    }
}

/// Calculates the derivative of the leaky ReLU activation function for a given input.
///
/// # Arguments
///
/// * `x` - A 32-bit float input value.
///
/// # Example
///
/// ```
/// let x = 0.5;
/// let result = cgl_rs::math::activations::relu_leaky_derivative(x);
/// println!("relu_leaky_derivative({}) = {}", x, result);
/// ```
pub fn relu_leaky_derivative(x: f32) -> f32  {
    unsafe {
        CGL_utils_relu_leaky_derivative(x as c_float) as f32
    }
}

/// Calculates the smooth ReLU activation function for a given input.
///
/// # Arguments
///
/// * `x` - A 32-bit float input value.
///
/// # Example
///
/// ```
/// let x = 0.5;
/// let result = cgl_rs::math::activations::relu_smooth(x);
/// println!("relu_smooth({}) = {}", x, result);
/// ```
pub fn relu_smooth(x: f32) -> f32  {
    unsafe {
        CGL_utils_relu_smooth(x as c_float) as f32
    }
}

/// Calculates the derivative of the smooth ReLU activation function for a given input.
///
/// # Arguments
///
/// * `x` - A 32-bit float input value.
///
/// # Example
///
/// ```
/// let x = 0.5;
/// let result = cgl_rs::math::activations::relu_smooth_derivative(x);
/// println!("relu_smooth_derivative({}) = {}", x, result);
/// ```
pub fn relu_smooth_derivative(x: f32) -> f32  {
    unsafe {
        CGL_utils_relu_smooth_derivative(x as c_float) as f32
    }
}

```

`rust_wrapper/cgl-rs/src/math/constants.rs`:

```rs
//! The CGL Math Constants

#![allow(non_camel_case_types)]

pub const PI: f32 = 3.14159265358979323846264338327950288;
pub const PI2: f32 = 6.28318530717958647692528676655900576;
pub const PI_2: f32 = 1.57079632679489661923132169163975144;
pub const E: f32 = 2.71828182845904523536028747135266250;
pub const SQRT_2: f32 = 1.41421356237309504880168872420969808;
pub const SQRT_3: f32 = 1.73205080756887729352744634150587236;
pub const SQRT_5: f32 = 2.23606797749978969640917366873127623;
pub const SQRT_6: f32 = 2.44948974278317809819728407470589139;
pub const SQRT_7: f32 = 2.64575131106459059050161575363926042;

```

`rust_wrapper/cgl-rs/src/math/matrix.rs`:

```rs
//! Matrix math module. Includes a 4x4 matrix struct and associated methods.
//! NOTE: These matrix library is for graphics programming with OpenGL.
//!       For linear algebra, check the cgl_rs::math::linalg module.

use super::{Vector3, Vector4};


/// A 3x3 matrix struct used for graphics programming with OpenGL.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct Matrix3x3 {
    m: [f32; 9]
}

/// A 4x4 matrix struct used for graphics programming with OpenGL.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct Matrix4x4 {
    m: [f32; 16]
}


extern {
    fn CGL_mat3_det(m: &Matrix3x3) -> f32;
    fn CGL_mat3_transpose(m: &Matrix3x3) -> Matrix3x3;
    fn CGL_mat3_trace(m: &Matrix3x3) -> f32;

    fn CGL_mat4_zero_MACRO() -> Matrix4x4;
    fn CGL_mat4_identity_MACRO() -> Matrix4x4;
    fn CGL_mat4_scale_MACRO(x: f32, y: f32, z: f32) -> Matrix4x4;
    fn CGL_mat4_translate_MACRO(x: f32, y: f32, z: f32) -> Matrix4x4;
    fn CGL_mat4_rotate_x_MACRO(angle: f32) -> Matrix4x4;
    fn CGL_mat4_rotate_y_MACRO(angle: f32) -> Matrix4x4;
    fn CGL_mat4_rotate_z_MACRO(angle: f32) -> Matrix4x4;
    fn CGL_mat4_perspective_MACRO(fov: f32, aspect: f32, near: f32, far: f32) -> Matrix4x4;
    fn CGL_mat4_orthographic_MACRO(left: f32, right: f32, bottom: f32, top: f32, near: f32, far: f32) -> Matrix4x4;

    fn CGL_mat4_mul(a: &Matrix4x4, b: &Matrix4x4) -> Matrix4x4;
    fn CGL_mat4_det(m: &Matrix4x4) -> f32;
    fn CGL_mat4_det_by_lu(m: &Matrix4x4) -> f32;
    fn CGL_mat4_det_by_gauss(m: &Matrix4x4) -> f32;
    fn CGL_mat4_mul_vec4(m: &Matrix4x4, v: &Vector4) -> Vector4;
    fn CGL_mat4_inverse(m: &Matrix4x4) -> Matrix4x4;
    fn CGL_mat4_transpose(m: &Matrix4x4) -> Matrix4x4;
    fn CGL_mat4_adjoint(m: &Matrix4x4) -> Matrix4x4;
    fn CGL_mat4_gauss_elim(m: &Matrix4x4) -> Matrix4x4;
    fn CGL_mat4_rank(m: &Matrix4x4) -> i32;
    fn CGL_mat4_trace(m: &Matrix4x4) -> f32;
    fn CGL_mat4_to_mat3(m: &Matrix4x4) -> Matrix3x3;
    fn CGL_mat4_from_mat3(m: &Matrix3x3) -> Matrix4x4;
    fn CGL_mat4_rotate_about_axis(axis: &Vector3, angle: f32) -> Matrix4x4;
    fn CGL_mat4_look_at(eye: Vector3, target: Vector3, up: Vector3) -> Matrix4x4;
    fn CGL_mat4_lerp(a: &Matrix4x4, b: &Matrix4x4, t: f32) -> Matrix4x4;
    fn CGL_mat4_decompose_lu(m: &Matrix4x4, l: *mut Matrix4x4, u: *mut Matrix4x4) -> std::ffi::c_void;
}


impl std::ops::Add<Matrix3x3> for Matrix3x3 {
    type Output = Matrix3x3;

    fn add(self, rhs: Matrix3x3) -> Matrix3x3 {
        Matrix3x3 {
            m: [
                self.m[0] + rhs.m[0], self.m[1] + rhs.m[1], self.m[2] + rhs.m[2],
                self.m[3] + rhs.m[3], self.m[4] + rhs.m[4], self.m[5] + rhs.m[5],
                self.m[6] + rhs.m[6], self.m[7] + rhs.m[7], self.m[8] + rhs.m[8]
            ]
        }
    }
}

impl std::ops::Sub<Matrix3x3> for Matrix3x3 {
    type Output = Matrix3x3;

    fn sub(self, rhs: Matrix3x3) -> Matrix3x3 {
        Matrix3x3 {
            m: [
                self.m[0] - rhs.m[0], self.m[1] - rhs.m[1], self.m[2] - rhs.m[2],
                self.m[3] - rhs.m[3], self.m[4] - rhs.m[4], self.m[5] - rhs.m[5],
                self.m[6] - rhs.m[6], self.m[7] - rhs.m[7], self.m[8] - rhs.m[8]
            ]
        }
    }
}

impl std::ops::Mul<f32> for Matrix3x3 {
    type Output = Matrix3x3;

    fn mul(self, rhs: f32) -> Matrix3x3 {
        Matrix3x3 {
            m: [
                self.m[0] * rhs, self.m[1] * rhs, self.m[2] * rhs,
                self.m[3] * rhs, self.m[4] * rhs, self.m[5] * rhs,
                self.m[6] * rhs, self.m[7] * rhs, self.m[8] * rhs
            ]
        }
    }
}

impl std::fmt::Display for Matrix3x3 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{{\n\t[{}, {}, {}]\n\t[{}, {}, {}]\n\t[{}, {}, {}]\n}}",
            self.m[0], self.m[3], self.m[6],
            self.m[1], self.m[4], self.m[7],
            self.m[2], self.m[5], self.m[8]
        )
    }
}

impl Matrix3x3 {
    /// Creates a new 3x3 matrix.
    /// 
    /// # Arguments
    /// 
    /// m0 ... m8: The values of the matrix.
    /// 
    /// # Returns
    /// 
    /// A new 3x3 matrix.
    /// 
    /// # Example
    /// 
    /// ```
    /// use cgl_rs::math::Matrix3x3;
    /// 
    /// let m = Matrix3x3::new(
    ///    1.0, 0.0, 0.0,
    ///    0.0, 1.0, 0.0,
    ///    0.0, 0.0, 1.0
    /// );
    /// ```
    pub fn new(
        m0: f32, m1: f32, m2: f32,
        m3: f32, m4: f32, m5: f32,
        m6: f32, m7: f32, m8: f32
    ) -> Matrix3x3 {
        Matrix3x3 {
            m: [
                m0, m3, m6,
                m1, m4, m7,
                m2, m5, m8
            ]
        }
    }


    /// Creates a new 3x3 matrix with all elements set to zero.
    ///
    /// # Returns
    ///
    /// A new 3x3 matrix with all elements set to zero.
    ///
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::Matrix3x3;
    ///
    /// let m = Matrix3x3::zero();
    /// ```
    pub fn zero() -> Matrix3x3 {
        Matrix3x3 {
            m: [0.0; 9]
        }
    }



    /// Creates a new 3x3 identity matrix.
    ///
    /// # Returns
    ///
    /// A new 3x3 identity matrix.
    ///
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::Matrix3x3;
    ///
    /// let m = Matrix3x3::identity();
    /// ```
    pub fn identity() -> Matrix3x3 {
        Matrix3x3::new(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0, 
            0.0, 0.0, 1.0
        )
    }


    /// Transposes the matrix.
    ///
    /// # Returns
    ///
    /// A new 3x3 matrix that is the transpose of the original matrix.
    ///
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::Matrix3x3;
    ///
    /// let m = Matrix3x3::new(
    ///     1.0, 2.0, 3.0,
    ///     4.0, 5.0, 6.0,
    ///     7.0, 8.0, 9.0
    /// );
    ///
    /// let m_transpose = m.transpose();
    /// ```
    pub fn transpose(&self) -> Matrix3x3 {
        unsafe {
            CGL_mat3_transpose(self)
        }
    }

    /// Calculates the trace of the matrix.
    ///
    /// # Returns
    ///
    /// The sum of the diagonal elements of the matrix.
    ///
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::Matrix3x3;
    ///
    /// let m = Matrix3x3::new(
    ///     1.0, 2.0, 3.0,
    ///     4.0, 5.0, 6.0,
    ///     7.0, 8.0, 9.0
    /// );
    ///
    /// let trace = m.trace();
    /// ```
    pub fn trace(&self) -> f32 {
        unsafe {
            CGL_mat3_trace(self) as f32
        }
    }

    /// Calculates the determinant of the matrix.
    ///
    /// # Returns
    ///
    /// The determinant of the matrix.
    ///
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::Matrix3x3;
    ///
    /// let m = Matrix3x3::new(
    ///     1.0, 2.0, 3.0,
    ///     4.0, 5.0, 6.0,
    ///     7.0, 8.0, 9.0
    /// );
    ///
    /// let det = m.determinant();
    /// ```
    pub fn determinant(&self) -> f32 {
        unsafe {
            CGL_mat3_det(self) as f32
        }
    }

}


impl std::ops::Add<Matrix4x4> for Matrix4x4 {
    type Output = Matrix4x4;

    fn add(self, rhs: Matrix4x4) -> Matrix4x4 {
        Matrix4x4 {
            m: [
                self.m[0] + rhs.m[0], self.m[1] + rhs.m[1], self.m[2] + rhs.m[2], self.m[3] + rhs.m[3],
                self.m[4] + rhs.m[4], self.m[5] + rhs.m[5], self.m[6] + rhs.m[6], self.m[7] + rhs.m[7],
                self.m[8] + rhs.m[8], self.m[9] + rhs.m[9], self.m[10] + rhs.m[10], self.m[11] + rhs.m[11],
                self.m[12] + rhs.m[12], self.m[13] + rhs.m[13], self.m[14] + rhs.m[14], self.m[15] + rhs.m[15]
            ]
        }
    }
}

impl std::ops::Sub<Matrix4x4> for Matrix4x4 {
    type Output = Matrix4x4;

    fn sub(self, rhs: Matrix4x4) -> Matrix4x4 {
        Matrix4x4 {
            m: [
                self.m[0] - rhs.m[0], self.m[1] - rhs.m[1], self.m[2] - rhs.m[2], self.m[3] - rhs.m[3],
                self.m[4] - rhs.m[4], self.m[5] - rhs.m[5], self.m[6] - rhs.m[6], self.m[7] - rhs.m[7],
                self.m[8] - rhs.m[8], self.m[9] - rhs.m[9], self.m[10] - rhs.m[10], self.m[11] - rhs.m[11],
                self.m[12] - rhs.m[12], self.m[13] - rhs.m[13], self.m[14] - rhs.m[14], self.m[15] - rhs.m[15]
            ]
        }
    }
}

impl std::ops::Mul<f32> for Matrix4x4 {
    type Output = Matrix4x4;

    fn mul(self, rhs: f32) -> Matrix4x4 {
        Matrix4x4 {
            m: [
                self.m[0] * rhs, self.m[1] * rhs, self.m[2] * rhs, self.m[3] * rhs,
                self.m[4] * rhs, self.m[5] * rhs, self.m[6] * rhs, self.m[7] * rhs,
                self.m[8] * rhs, self.m[9] * rhs, self.m[10] * rhs, self.m[11] * rhs,
                self.m[12] * rhs, self.m[13] * rhs, self.m[14] * rhs, self.m[15] * rhs
            ]
        }
    }
}

impl std::fmt::Display for Matrix4x4 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{{\n\t[{}, {}, {}, {}]\n\t[{}, {}, {}, {}]\n\t[{}, {}, {}, {}]\n\t[{}, {}, {}, {}]\n}}",
            self.m[0], self.m[1], self.m[2], self.m[3],
            self.m[4], self.m[5], self.m[6], self.m[7],
            self.m[8], self.m[9], self.m[10], self.m[11],
            self.m[12], self.m[13], self.m[14], self.m[15]
        )
    }
}

impl Matrix4x4 {

    /// Creates a new matrix with the given values.
    /// 
    /// # Arguments
    /// 
    /// * `m00 .. m33` - The values of the matrix.
    /// 
    /// # Returns
    /// 
    /// A new identity matrix.
    /// 
    /// # Example
    /// 
    /// ```
    /// use cgl_rs::math::Matrix4x4;
    /// 
    /// let m = Matrix4x4::new(
    ///    1.0, 0.0, 0.0, 0.0,
    ///    0.0, 1.0, 0.0, 0.0,
    ///    0.0, 0.0, 1.0, 0.0,
    ///    0.0, 0.0, 0.0, 1.0
    /// );
    /// 
    /// println!("{}", m);
    /// ```
    pub fn new(
        m00: f32, m01: f32, m02: f32, m03: f32,
        m10: f32, m11: f32, m12: f32, m13: f32,
        m20: f32, m21: f32, m22: f32, m23: f32,
        m30: f32, m31: f32, m32: f32, m33: f32 
    ) -> Matrix4x4 {
        Matrix4x4 {
            m: [
                m00, m10, m20, m30,
                m01, m11, m21, m31,
                m02, m12, m22, m32,
                m03, m13, m23, m33
            ]
        }
    }

    /// Creates a new 4x4 matrix from a 3x3 matrix.
    ///
    /// # Arguments
    ///
    /// * `m` - The 3x3 matrix to convert to a 4x4 matrix.
    ///
    /// # Returns
    ///
    /// A new 4x4 matrix with the same values as the input 3x3 matrix, with the fourth row and column set to zero.
    ///
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::{Matrix3x3, Matrix4x4};
    ///
    /// let m3 = Matrix3x3::new(
    ///     1.0, 2.0, 3.0,
    ///     4.0, 5.0, 6.0,
    ///     7.0, 8.0, 9.0
    /// );
    ///
    /// let m4 = Matrix4x4::from_mat3(&m3);
    /// ```
    pub fn from_mat3(m: &Matrix3x3) -> Matrix4x4 {
        unsafe {
            CGL_mat4_from_mat3(&m) as Matrix4x4
        }
    }

    /// Returns a new matrix with all elements set to zero.
    ///
    /// # Returns
    ///
    /// A new matrix with all elements set to zero.
    ///
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::Matrix4x4;
    ///
    /// let m = Matrix4x4::zero();
    /// ```
    pub fn zero() -> Matrix4x4 {
        unsafe {
            CGL_mat4_zero_MACRO() as Matrix4x4
        }
    }


    /// Returns a new identity matrix.
    ///
    /// # Returns
    ///
    /// A new identity matrix.
    ///
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::Matrix4x4;
    ///
    /// let m = Matrix4x4::identity();
    /// ```
    pub fn identity() -> Matrix4x4 {
        unsafe {
            CGL_mat4_identity_MACRO() as Matrix4x4
        }
    }


    /// Returns a new scaling matrix.
    ///
    /// # Arguments
    ///
    /// * `x` - The scaling factor along the x-axis.
    /// * `y` - The scaling factor along the y-axis.
    /// * `z` - The scaling factor along the z-axis.
    ///
    /// # Returns
    ///
    /// A new scaling matrix.
    ///
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::Matrix4x4;
    ///
    /// let m = Matrix4x4::scale(2.0, 3.0, 4.0);
    /// ```
    pub fn scale(x: f32, y: f32, z: f32) -> Matrix4x4 {
        unsafe {
            CGL_mat4_scale_MACRO(x, y, z) as Matrix4x4
        }
    }


    /// Returns a new translation matrix.
    ///
    /// # Arguments
    ///
    /// * `x` - The translation along the x-axis.
    /// * `y` - The translation along the y-axis.
    /// * `z` - The translation along the z-axis.
    ///
    /// # Returns
    ///
    /// A new translation matrix.
    /// 
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::Matrix4x4;
    ///
    /// let m = Matrix4x4::translate(1.0, 2.0, 3.0);
    /// ```
    pub fn translate(x: f32, y: f32, z: f32) -> Matrix4x4 {
        unsafe {
            CGL_mat4_translate_MACRO(x, y, z) as Matrix4x4
        }
    }


    /// Returns a new rotation matrix around the x-axis.
    ///
    /// # Arguments
    ///
    /// * `angle` - The angle of rotation in radians.
    ///
    /// # Returns
    ///
    /// A new rotation matrix around the x-axis.
    ///
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::Matrix4x4;
    ///
    /// let m = Matrix4x4::rotate_x(0.5);
    /// ```
    pub fn rotate_x(angle: f32) -> Matrix4x4 {
        unsafe {
            CGL_mat4_rotate_x_MACRO(angle) as Matrix4x4
        }
    }

    /// Returns a new rotation matrix around the y-axis.
    ///
    /// # Arguments
    ///
    /// * `angle` - The angle of rotation in radians.
    ///
    /// # Returns
    ///
    /// A new rotation matrix around the y-axis.
    ///
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::Matrix4x4;
    ///
    /// let m = Matrix4x4::rotate_y(0.5);
    /// ```
    pub fn rotate_y(angle: f32) -> Matrix4x4 {
        unsafe {
            CGL_mat4_rotate_y_MACRO(angle) as Matrix4x4
        }
    }


    /// Returns a new rotation matrix around the z-axis.
    ///
    /// # Arguments
    ///
    /// * `angle` - The angle of rotation in radians.
    ///
    /// # Returns
    ///
    /// A new rotation matrix around the z-axis.
    ///
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::Matrix4x4;
    ///
    /// let m = Matrix4x4::rotate_z(0.5);
    /// ```
    pub fn rotate_z(angle: f32) -> Matrix4x4 {
        unsafe {
            CGL_mat4_rotate_z_MACRO(angle) as Matrix4x4
        }
    }


    /// Returns a new rotation matrix that rotates around the given axis by the specified angle.
    ///
    /// # Arguments
    ///
    /// * `axis` - The axis to rotate around.
    /// * `angle` - The angle of rotation in radians.
    ///
    /// # Returns
    ///
    /// A new rotation matrix that rotates around the given axis by the specified angle.
    /// 
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::{Matrix4x4, Vector3};
    ///
    /// let axis = Vector3::new(1.0, 0.0, 0.0);
    /// let m = Matrix4x4::rotate_about_axis(&axis, 0.5);
    /// ```
    pub fn rotate_about_axis(axis: &Vector3, angle: f32) -> Matrix4x4 {
        unsafe {
            CGL_mat4_rotate_about_axis(axis, angle) as Matrix4x4
        }
    }





    /// Returns a new perspective projection matrix.
    ///
    /// # Arguments
    ///
    /// * `fov` - The field of view angle in radians.
    /// * `aspect` - The aspect ratio of the projection.
    /// * `near` - The distance to the near clipping plane.
    /// * `far` - The distance to the far clipping plane.
    ///
    /// # Returns
    ///
    /// A new perspective projection matrix.
    ///
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::Matrix4x4;
    /// 
    /// let m = Matrix4x4::perspective(cgl_rs::math::constants::PI_2, 16.0/9.0, 0.1, 100.0);
    /// ```
    pub fn perspective(fov: f32, aspect: f32, near: f32, far: f32) -> Matrix4x4 {
        unsafe {
            CGL_mat4_perspective_MACRO(fov, aspect, near, far) as Matrix4x4
        }
    }


    /// Returns a new orthographic projection matrix.
    ///
    /// # Arguments
    ///
    /// * `left` - The coordinate for the left vertical clipping plane.
    /// * `right` - The coordinate for the right vertical clipping plane.
    /// * `bottom` - The coordinate for the bottom horizontal clipping plane.
    /// * `top` - The coordinate for the top horizontal clipping plane.
    /// * `near` - The distance to the near clipping plane.
    /// * `far` - The distance to the far clipping plane.
    ///
    /// # Returns
    ///
    /// A new orthographic projection matrix.
    ///
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::Matrix4x4;
    ///
    /// let m = Matrix4x4::orthographic(-1.0, 1.0, -1.0, 1.0, 0.1, 100.0);
    /// ```
    pub fn orthographic(left: f32, right: f32, bottom: f32, top: f32, near: f32, far: f32) -> Matrix4x4 {
        unsafe {
            CGL_mat4_orthographic_MACRO(left, right, bottom, top, near, far) as Matrix4x4
        }
    }


    /// Returns a new view matrix that looks from the eye position towards the target position.
    ///
    /// # Arguments
    ///
    /// * `eye` - The position of the camera.
    /// * `target` - The position to look at.
    /// * `up` - The up direction of the camera.
    ///
    /// # Returns
    ///
    /// A new view matrix.
    ///
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::{Matrix4x4, Vector3};
    ///
    /// let mat = Matrix4x4::look_at(
    ///    Vector3::new(0.0, 0.0, 0.0),
    ///    Vector3::new(0.0, 0.0, -1.0),
    ///    Vector3::new(0.0, 1.0, 0.0)
    /// );
    /// ```
    pub fn look_at(eye: Vector3, target: Vector3, up: Vector3) -> Matrix4x4 {
        unsafe {
            CGL_mat4_look_at(eye, target, up) as Matrix4x4
        }
    }

    /// Multiplies this matrix by another matrix and returns the result.
    ///
    /// # Arguments
    ///
    /// * `other` - The matrix to multiply by.
    ///
    /// # Returns
    ///
    /// The resulting matrix of the multiplication.
    ///
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::Matrix4x4;
    ///
    /// let m1 = Matrix4x4::identity();
    /// let m2 = Matrix4x4::rotate_z(0.5);
    /// let m3 = m1.mul(&m2);
    /// ```
    pub fn mul(&self, other: &Matrix4x4) -> Matrix4x4 {
        unsafe {
            CGL_mat4_mul(self, other) as Matrix4x4
        }
    }

    /// Calculates the determinant of this matrix.
    ///
    /// # Returns
    ///
    /// The determinant of this matrix.
    ///
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::Matrix4x4;
    ///
    /// let m = Matrix4x4::identity();
    /// let det = m.determinant();
    /// ```
    pub fn determinant(&self) -> f32 {
        unsafe {
            CGL_mat4_det(self)
        }
    }

    /// Multiplies this matrix by a vector and returns the result.
    ///
    /// # Arguments
    ///
    /// * `other` - The vector to multiply by.
    ///
    /// # Returns
    ///
    /// The resulting vector of the multiplication.
    ///
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::{Matrix4x4, Vector4};
    ///
    /// let m = Matrix4x4::identity();
    /// let v = Vector4::new(1.0, 2.0, 3.0, 1.0);
    /// let result = m.mul_vec4(&v);
    /// ```
    pub fn mul_vec4(&self, other: &Vector4) -> Vector4 {
        unsafe {
            CGL_mat4_mul_vec4(self, other) as Vector4
        }
    }

    /// Calculates the inverse of this matrix.
    ///
    /// # Returns
    ///
    /// The inverse of this matrix.
    ///
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::Matrix4x4;
    ///
    /// let m = Matrix4x4::identity();
    /// let inv = m.inverse();
    /// ```
    pub fn inverse(&self) -> Matrix4x4 {
        unsafe {
            CGL_mat4_inverse(self) as Matrix4x4
        }
    }

    /// Transposes this matrix.
    ///
    /// # Returns
    ///
    /// The transposed matrix.
    ///
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::Matrix4x4;
    ///
    /// let m = Matrix4x4::identity();
    /// let transposed = m.transpose();
    /// ```
    pub fn transpose(&self) -> Matrix4x4 {
        unsafe {
            CGL_mat4_transpose(self) as Matrix4x4
        }
    }

    /// Calculates the adjoint of this matrix.
    ///
    /// # Returns
    ///
    /// The adjoint of this matrix.
    ///
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::Matrix4x4;
    ///
    /// let m = Matrix4x4::identity();
    /// let adj = m.adjoint();
    /// ```
    pub fn adjoint(&self) -> Matrix4x4 {
        unsafe {
            CGL_mat4_adjoint(self) as Matrix4x4
        }
    }


    /// Performs Gaussian elimination on this matrix.
    ///
    /// # Returns
    ///
    /// The matrix in row echelon form.
    ///
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::Matrix4x4;
    ///
    /// let m = Matrix4x4::identity();
    /// let row_echelon = m.gaussian_elimination();
    /// ```
    pub fn gaussian_elimination(&self) -> Matrix4x4 {
        unsafe {
            CGL_mat4_gauss_elim(self) as Matrix4x4
        }
    }

    /// Calculates the rank of this matrix.
    ///
    /// # Returns
    ///
    /// The rank of this matrix.
    ///
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::Matrix4x4;
    ///
    /// let m = Matrix4x4::identity();
    /// let rank = m.rank();
    /// ```
    pub fn rank(&self) -> i32 {
        unsafe {
            CGL_mat4_rank(self)
        }
    }

    /// Calculates the trace of this matrix.
    ///
    /// # Returns
    ///
    /// The trace of this matrix.
    ///
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::Matrix4x4;
    ///
    /// let m = Matrix4x4::identity();
    /// let trace = m.trace();
    /// ```
    pub fn trace(&self) -> f32 {
        unsafe {
            CGL_mat4_trace(self)
        }
    }

    /// Converts this Matrix4x4 to a Matrix3x3 by discarding the last row and column.
    ///
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::{Matrix3x3, Matrix4x4};
    ///
    /// let m = Matrix4x4::identity();
    /// let m3 = m.to_mat3();
    /// ```
    pub fn to_mat3(&self) -> Matrix3x3 {
        unsafe {
            CGL_mat4_to_mat3(self) as Matrix3x3
        }
    }

    /// Decomposes this matrix into lower and upper triangular matrices using LU decomposition.
    ///
    /// # Returns
    ///
    /// A tuple containing the lower and upper triangular matrices.
    ///
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::Matrix4x4;
    ///
    /// let m = Matrix4x4::identity();
    /// let (l, u) = m.decompose_lu();
    /// ```
    pub fn decompose_lu(&self) -> (Matrix4x4, Matrix4x4) {
        unsafe {
            let mut l = Matrix4x4::identity();
            let mut u = Matrix4x4::identity();
            CGL_mat4_decompose_lu(self, &mut l, &mut u);
            (l, u)
        }
    }

    /// Performs a linear interpolation between this matrix and another matrix.
    ///
    /// # Arguments
    ///
    /// * `other` - The other matrix to interpolate with.
    /// * `t` - The interpolation factor. Should be between 0.0 and 1.0.
    ///
    /// # Returns
    ///
    /// The interpolated matrix.
    ///
    /// # Example
    ///
    /// ```
    /// use cgl_rs::math::Matrix4x4;
    ///
    /// let m1 = Matrix4x4::identity();
    /// let m2 = Matrix4x4::scale(1.0, 2.0, 3.0);
    /// let m3 = m1.lerp(&m2, 0.5);
    /// ```
    pub fn lerp(&self, other: &Matrix4x4, t: f32) -> Matrix4x4 {
        unsafe {
            CGL_mat4_lerp(self, other, t) as Matrix4x4
        }
    }


}
```

`rust_wrapper/cgl-rs/src/math/vector.rs`:

```rs
//! Vector math module. Includes vector structs and functions.


/// A 2-dimensional vector with `x` and `y` components.
#[derive(Debug, Copy, Clone, PartialEq)] #[repr(C)]
pub struct Vector2 {
    pub x: f32,
    pub y: f32,
}

/// A 3-dimensional vector with `x`, `y` and `z` components.
#[derive(Debug, Copy, Clone, PartialEq)] #[repr(C)]
pub struct Vector3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}

/// A 4-dimensional vector with `x`, `y`, `z` and `w` components.
#[derive(Debug, Copy, Clone, PartialEq)] #[repr(C)]
pub struct Vector4 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}

/// A 4-dimensional vector with `x`, `y`, `z` and `w` components, all of which are `i32`.
#[derive(Debug, Copy, Clone, PartialEq)] #[repr(C)]
pub struct IVector4 {
    pub x: i32,
    pub y: i32,
    pub z: i32,
    pub w: i32
}

/// Allows indexing into a `Vector2` by `usize` index.
impl std::ops::Index<usize> for Vector2 {
    type Output = f32;
    
    /// Returns a reference to the `f32` value at the given index.
    ///
    /// # Arguments
    ///
    /// * `index` - The index of the value to retrieve. Must be `0` or `1`.
    ///
    /// # Returns
    ///
    /// A reference to the `f32` value at the given index.
    ///
    /// # Panics
    ///
    /// Panics if the index is not `0` or `1`.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::Vector2;
    /// let vec = Vector2::new(1.0, 2.0);
    /// assert_eq!(vec[0], 1.0);
    /// assert_eq!(vec[1], 2.0);
    /// ```
    fn index(&self, index: usize) -> &f32 {
        match index {
            0 => &self.x,
            1 => &self.y,
            _ => panic!("Index out of bounds for Vector2"),
        }
        
    }
}

/// Allows mutable indexing into a `Vector2` by `usize` index.
impl std::ops::IndexMut<usize> for Vector2 {
    
    /// Returns a mutable reference to the `f32` value at the given index.
    ///
    /// # Arguments
    ///
    /// * `index` - The index of the value to retrieve. Must be `0` or `1`.
    ///
    /// # Returns
    ///
    /// A mutable reference to the `f32` value at the given index.
    ///
    /// # Panics
    ///
    /// Panics if the index is not `0` or `1`.
    /// 
    /// # Examples
    /// 
    /// ```
    /// use cgl_rs::math::Vector2;
    /// let mut vec = Vector2::new(1.0, 2.0);
    /// vec[0] = 3.0;
    /// assert_eq!(vec.x, 3.0);
    /// ```
    fn index_mut(&mut self, index: usize) -> &mut f32 {
        match index {
            0 => &mut self.x,
            1 => &mut self.y,
            _ => panic!("Index out of bounds for Vector2"),
        }
    }
}

impl std::fmt::Display for Vector2 {
        
        /// Formats the vector as a string.
        /// 
        /// # Arguments
        /// 
        /// * `f` - The formatter to use.
        /// 
        /// # Returns
        /// 
        /// A string representation of the vector.
        /// 
        /// # Examples
        /// 
        /// ```
        /// use cgl_rs::math::Vector2;
        /// let vec = Vector2::new(1.0, 2.0);
        /// ```
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            write!(f, "Vector2({}, {})", self.x, self.y)
        }
}

crate::macros::impl_vector_binary_ops!(Vector2, 2);

impl Vector2 {
    
    /// Creates a new `Vector2` with the given `x` and `y` components.
    /// 
    /// # Arguments
    /// 
    /// * `x` - The `x` component of the vector.
    /// * `y` - The `y` component of the vector.
    /// 
    /// # Returns
    /// 
    /// A new `Vector2` with the given `x` and `y` components.
    /// 
    /// # Examples
    /// 
    /// ```
    /// use cgl_rs::math::Vector2;
    /// 
    /// let vec = Vector2::new(1.0, 2.0);
    /// ```
    pub fn new(x: f32, y: f32) -> Vector2 {
        Vector2 { x: x, y: y }
    }
    
    /// Creates a new `Vector2` with `x` and `y` components set to `0.0`.
    ///
    /// # Returns
    ///
    /// A new `Vector2` with `x` and `y` components set to `0.0`.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::Vector2;
    ///
    /// let vec = Vector2::zero();
    /// ```
    pub fn zero() -> Vector2 {
        Vector2 { x: (0.0), y: (0.0) }
    }
    
    /// Creates a new `Vector2` with `x` and `y` components set to `1.0`.
    ///
    /// # Returns
    ///
    /// A new `Vector2` with `x` and `y` components set to `1.0`.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::Vector2;
    ///
    /// let vec = Vector2::one();
    /// ```
    pub fn one() -> Vector2 {
        Vector2 { x: (1.0), y: (1.0) }
    }


    /// Calculates the dot product of this vector and another vector.
    ///
    /// # Arguments
    ///
    /// * `other` - The other vector to calculate the dot product with.
    ///
    /// # Returns
    ///
    /// The dot product of this vector and the other vector.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::Vector2;
    ///
    /// let vec1 = Vector2::new(1.0, 2.0);
    /// let vec2 = Vector2::new(3.0, 4.0);
    /// let dot_product = vec1.dot(&vec2);
    /// ```
    pub fn dot(&self, other: &Vector2) -> f32 {
        self.x * other.x + self.y * other.y
    }

    /// Calculates the cross product of this vector and another vector.
    /// 
    /// # Arguments
    /// 
    /// * `other` - The other vector to calculate the cross product with.
    /// 
    /// # Returns
    /// 
    /// The cross product of this vector and the other vector.
    /// 
    /// # Examples
    /// 
    /// ```
    /// use cgl_rs::math::Vector2;
    /// 
    /// let vec1 = Vector2::new(1.0, 2.0);
    /// let vec2 = Vector2::new(3.0, 4.0);
    /// let cross_product = vec1.cross(&vec2);
    /// ```
    pub fn cross(&self, other: &Vector2) -> f32 {
        self.x * other.y - self.y * other.x
    }

    /// Calculates the length of this vector.
    ///
    /// # Returns
    ///
    /// The length of this vector.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::Vector2;
    ///
    /// let vec = Vector2::new(3.0, 4.0);
    /// let length = vec.length();
    /// ```
    pub fn length(&self) -> f32 {
        (self.x * self.x + self.y * self.y).sqrt()
    }

    /// Rotates this vector about the origin by the given angle (in radians).
    ///
    /// # Arguments
    ///
    /// * `angle` - The angle (in radians) to rotate this vector by.
    ///
    /// # Returns
    ///
    /// A new `Vector2` representing the result of rotating this vector about the origin by the given angle.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::Vector2;
    ///
    /// let vec = Vector2::new(1.0, 0.0);
    /// let rotated_vec = vec.rotate_about_origin(std::f32::consts::PI / 2.0);
    /// ```
    pub fn rotate_about_origin(&self, angle: f32) -> Vector2 {
        let cos = angle.cos();
        let sin = angle.sin();
        Vector2::new(self.x * cos - self.y * sin, self.x * sin + self.y * cos)
    }

    /// Creates a new `Vector2` from the given angle (in radians).
    ///
    /// # Arguments
    ///
    /// * `angle` - The angle (in radians) to create the vector from.
    ///
    /// # Returns
    ///
    /// A new `Vector2` representing the given angle.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::Vector2;
    ///
    /// let vec = Vector2::from_angle(std::f32::consts::PI / 4.0);
    /// ```
    pub fn from_angle(angle: f32) -> Vector2 {
        Vector2::new(angle.cos(), angle.sin())
    }

    /// Calculates the angle (in radians) between this vector and the positive x-axis.
    ///
    /// # Returns
    ///
    /// The angle (in radians) between this vector and the positive x-axis.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::Vector2;
    ///
    /// let vec = Vector2::new(1.0, 1.0);
    /// let angle = vec.angle();
    /// ```
    pub fn angle(&self) -> f32 {
        self.y.atan2(self.x)
    }
    
    /// Calculates the angle (in radians) between this vector and another vector.
    ///
    /// # Arguments
    ///
    /// * `other` - The other vector to calculate the angle between.
    ///
    /// # Returns
    ///
    /// The angle (in radians) between this vector and the other vector.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::Vector2;
    ///
    /// let vec1 = Vector2::new(1.0, 0.0);
    /// let vec2 = Vector2::new(0.0, 1.0);
    /// let angle = vec1.angle_between(&vec2);
    /// ```
    pub fn angle_between(&self, other: &Vector2) -> f32 {
        let dot = self.dot(other);
        let det = self.x * other.y - self.y * other.x;
        det.atan2(dot)
    }

    /// Normalizes this vector in place.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::Vector2;
    ///
    /// let mut vec = Vector2::new(3.0, 4.0);
    /// vec.normalize();
    /// ```
    /// 
    /// # See also
    /// 
    /// * [`normalized`](#method.normalized)
    pub fn normalize(&mut self) {
        let length = self.length();
        self.x /= length;
        self.y /= length;
    }

    /// Returns a new normalized `Vector2` representing this vector.
    ///
    /// # Returns
    ///
    /// A new `Vector2` representing this vector, normalized.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::Vector2;
    ///
    /// let vec = Vector2::new(3.0, 4.0);
    /// let normalized_vec = vec.normalized();
    /// ```
    /// 
    /// # See also
    /// 
    /// * [`normalize`](#method.normalize)
    pub fn normalized(&self) -> Vector2 {
        let length = self.length();
        Vector2::new(self.x / length, self.y / length)
    }

    /// Returns a new `Vector2` that is perpendicular to this vector.
    ///
    /// # Returns
    ///
    /// A new `Vector2` that is perpendicular to this vector.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::Vector2;
    ///
    /// let vec = Vector2::new(1.0, 2.0);
    /// let perp_vec = vec.perpendicular();
    /// ```
    ///
    /// # See also
    ///
    /// * [`dot`](#method.dot)
    /// * [`angle_between`](#method.angle_between)
    pub fn perpendicular(&self) -> Vector2 {
        Vector2::new(-self.y, self.x)
    }

    /// Returns the reflection of this vector off a surface with the given normal.
    ///
    /// # Arguments
    ///
    /// * `normal` - The normal of the surface being reflected off of.
    ///
    /// # Returns
    ///
    /// The reflection of this vector off the surface with the given normal.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::Vector2;
    ///
    /// let vec = Vector2::new(1.0, 2.0);
    /// let normal = Vector2::new(0.0, 1.0);
    /// let reflected_vec = vec.reflect(&normal);
    /// ```
    pub fn reflect(&self, normal: &Vector2) -> Vector2 {
        let dot = self.dot(normal);
        Vector2::new(self.x - 2.0 * dot * normal.x, self.y - 2.0 * dot * normal.y)
    }
    
}


/// Allows indexing into a `Vector2`.
impl std::ops::Index<usize> for Vector3 {
    type Output = f32;

    /// Returns a reference to the element at the given index.
    ///
    /// # Arguments
    ///
    /// * `index` - The index of the element to return.
    ///
    /// # Panics
    ///
    /// Panics if the index is out of bounds for a `Vector3`.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::Vector3;
    ///
    /// let vec = Vector3::new(1.0, 2.0, 3.0);
    /// assert_eq!(vec[0], 1.0);
    /// assert_eq!(vec[1], 2.0);
    /// assert_eq!(vec[2], 3.0);
    /// ```
    fn index(&self, index: usize) -> &f32 {
        match index {
            0 => &self.x,
            1 => &self.y,
            2 => &self.z,
            _ => panic!("Index out of bounds for Vector3"),
        }
    }
}

/// Allows indexing into a `Vector3` mutably.
impl std::ops::IndexMut<usize> for Vector3 {
    /// Allows mutable indexing into a `Vector3`.
    ///
    /// # Arguments
    ///
    /// * `index` - The index of the element to return.
    ///
    /// # Panics
    ///
    /// Panics if the index is out of bounds for a `Vector3`.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::Vector3;
    ///
    /// let mut vec = Vector3::new(1.0, 2.0, 3.0);
    /// vec[0] = 4.0;
    /// vec[1] = 5.0;
    /// vec[2] = 6.0;
    /// ```
    fn index_mut(&mut self, index: usize) -> &mut f32 {
        match index {
            0 => &mut self.x,
            1 => &mut self.y,
            2 => &mut self.z,
            _ => panic!("Index out of bounds for Vector3"),
        }
    }
}

crate::macros::impl_vector_binary_ops!(Vector3, 3);

impl Vector3 {
    /// Creates a new `Vector3` with the given `x`, `y`, and `z` components.
    ///
    /// # Arguments
    ///
    /// * `x` - The `x` component of the new vector.
    /// * `y` - The `y` component of the new vector.
    /// * `z` - The `z` component of the new vector.
    ///
    /// # Returns
    ///
    /// A new `Vector3` with the given `x`, `y`, and `z` components.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::Vector3;
    ///
    /// let vec = Vector3::new(1.0, 2.0, 3.0);
    /// ```
    pub fn new(x: f32, y: f32, z: f32) -> Vector3 {
        Vector3 { x, y, z }
    }

    /// Creates a new `Vector3` from a `Vector2` and a `z` component.
    ///
    /// # Arguments
    ///
    /// * `vec` - The `Vector2` to use for the `x` and `y` components of the new vector.
    /// * `z` - The `z` component of the new vector.
    ///
    /// # Returns
    ///
    /// A new `Vector3` with the `x` and `y` components taken from `vec` and the `z` component set to `z`.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::{Vector2, Vector3};
    ///
    /// let vec2 = Vector2::new(1.0, 2.0);
    /// let vec3 = Vector3::from_vec2(vec2, 3.0);
    /// assert_eq!(vec3.x, 1.0);
    /// assert_eq!(vec3.y, 2.0);
    /// assert_eq!(vec3.z, 3.0);
    /// ```
    pub fn from_vec2(vec: Vector2, z: f32) -> Vector3 {
        Vector3::new(vec.x, vec.y, z)
    }

    /// Returns a new `Vector3` with all components set to zero.
    ///
    /// # Returns
    ///
    /// A new `Vector3` with all components set to zero.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::Vector3;
    ///
    /// let vec = Vector3::zero();
    /// assert_eq!(vec.x, 0.0);
    /// assert_eq!(vec.y, 0.0);
    /// assert_eq!(vec.z, 0.0);
    /// ```
    pub fn zero() -> Vector3 {
        Vector3::new(0.0, 0.0, 0.0)
    }

    /// Returns a new `Vector3` with all components set to one.
    ///
    /// # Returns
    ///
    /// A new `Vector3` with all components set to one.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::Vector3;
    ///
    /// let vec = Vector3::one();
    /// assert_eq!(vec.x, 1.0);
    /// assert_eq!(vec.y, 1.0);
    /// assert_eq!(vec.z, 1.0);
    /// ```
    pub fn one() -> Vector3 {
        Vector3::new(1.0, 1.0, 1.0)
    }

    /// Computes the dot product of two `Vector3`s.
    ///
    /// # Arguments
    ///
    /// * `other` - The other `Vector3` to compute the dot product with.
    ///
    /// # Returns
    ///
    /// The dot product of the two `Vector3`s.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::Vector3;
    ///
    /// let vec1 = Vector3::new(1.0, 2.0, 3.0);
    /// let vec2 = Vector3::new(4.0, 5.0, 6.0);
    /// let dot_product = vec1.dot(vec2);
    /// assert_eq!(dot_product, 32.0);
    /// ```
    pub fn dot(&self, other: Vector3) -> f32 {
        self.x * other.x + self.y * other.y + self.z * other.z
    }

    /// Computes the cross product of two `Vector3`s.
    ///
    /// # Arguments
    ///
    /// * `other` - The other `Vector3` to compute the cross product with.
    ///
    /// # Returns
    ///
    /// The cross product of the two `Vector3`s.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::Vector3;
    ///
    /// let vec1 = Vector3::new(1.0, 2.0, 3.0);
    /// let vec2 = Vector3::new(4.0, 5.0, 6.0);
    /// let cross_product = vec1.cross(vec2);
    /// assert_eq!(cross_product.x, -3.0);
    /// assert_eq!(cross_product.y, 6.0);
    /// assert_eq!(cross_product.z, -3.0);
    /// ```
    pub fn cross(&self, other: Vector3) -> Vector3 {
        Vector3::new(
            self.y * other.z - self.z * other.y,
            -(self.x * other.z - self.z * other.x),
            self.x * other.y - self.y * other.x,
        )
    }

    // Computes the length of the `Vector3`.
    //
    // # Returns
    //
    // The length of the `Vector3`.
    //
    // # Examples
    //
    // ```
    // use cgl_rs::math::Vector3;
    //
    // let vec = Vector3::new(1.0, 2.0, 2.0);
    // let length = vec.length();
    // assert_eq!(length, 3.0);
    // ```
    pub fn length(&self) -> f32 {
        (self.x * self.x + self.y * self.y + self.z * self.z).sqrt()
    }

    /// Normalizes the `Vector3` in place.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::Vector3;
    ///
    /// let mut vec = Vector3::new(1.0, 2.0, 2.0);
    /// vec.normalize();
    /// assert_eq!(vec.length(), 1.0);
    /// ```
    pub fn normalize(&mut self) {
        let length = self.length();
        self.x /= length;
        self.y /= length;
        self.z /= length;
    }

    /// Returns a new `Vector3` that is the normalized version of this `Vector3`.
    ///
    /// # Returns
    ///
    /// A new `Vector3` that is the normalized version of this `Vector3`.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::Vector3;
    ///
    /// let vec = Vector3::new(1.0, 2.0, 2.0);
    /// let normalized_vec = vec.normalized();
    /// assert_eq!(normalized_vec.length(), 1.0);
    /// ```
    pub fn normalized(&self) -> Vector3 {
        let length = self.length();
        Vector3::new(self.x / length, self.y / length, self.z / length)
    }

    /// Returns a new `Vector2` containing the `x` and `y` components of this `Vector3`.
    ///
    /// # Returns
    ///
    /// A new `Vector2` containing the `x` and `y` components of this `Vector3`.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::{Vector2, Vector3};
    ///
    /// let vec = Vector3::new(1.0, 2.0, 3.0);
    /// let vec2 = vec.xy();
    /// assert_eq!(vec2.x, 1.0);
    /// assert_eq!(vec2.y, 2.0);
    /// ```
    pub fn xy(&self) -> Vector2 {
        Vector2::new(self.x, self.y)
    }

    /// Returns a new `Vector2` containing the `x` and `z` components of this `Vector3`.
    ///
    /// # Returns
    ///
    /// A new `Vector2` containing the `x` and `z` components of this `Vector3`.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::{Vector2, Vector3};
    ///
    /// let vec = Vector3::new(1.0, 2.0, 3.0);
    /// let vec2 = vec.xz();
    /// assert_eq!(vec2.x, 1.0);
    /// assert_eq!(vec2.y, 3.0);
    /// ```
    pub fn xz(&self) -> Vector2 {
        Vector2::new(self.x, self.z)
    }

    /// Returns a new `Vector2` containing the `y` and `z` components of this `Vector3`.
    ///
    /// # Returns
    ///
    /// A new `Vector2` containing the `y` and `z` components of this `Vector3`.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::{Vector2, Vector3};
    ///
    /// let vec = Vector3::new(1.0, 2.0, 3.0);
    /// let vec2 = vec.yz();
    /// assert_eq!(vec2.x, 2.0);
    /// assert_eq!(vec2.y, 3.0);
    /// ```
    pub fn yz(&self) -> Vector2 {
        Vector2::new(self.y, self.z)
    }

    /// Returns the angle between this `Vector3` and another `Vector3`.
    ///
    /// # Arguments
    ///
    /// * `other` - The other `Vector3` to calculate the angle with.
    ///
    /// # Returns
    ///
    /// The angle between this `Vector3` and `other` in radians.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::Vector3;
    ///
    /// let vec1 = Vector3::new(1.0, 0.0, 0.0);
    /// let vec2 = Vector3::new(0.0, 1.0, 0.0);
    /// let angle = vec1.angle_between(vec2);
    /// assert_eq!(angle, std::f32::consts::FRAC_PI_2);
    /// ```
    pub fn angle_between(&self, other: Vector3) -> f32 {
        let dot = self.dot(other);
        let length = self.length() * other.length();
        dot.acos() / length
    }

    /// Calculates the reflection of this `Vector3` off a surface with the given `normal`.
    ///
    /// # Arguments
    ///
    /// * `normal` - The normal of the surface to reflect off of.
    ///
    /// # Returns
    ///
    /// The reflection of this `Vector3` off the surface with the given `normal`.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::Vector3;
    ///
    /// let vec = Vector3::new(1.0, 1.0, 0.0);
    /// let normal = Vector3::new(0.0, 1.0, 0.0);
    /// let reflected = vec.reflect(normal);
    /// assert_eq!(reflected, Vector3::new(1.0, -1.0, 0.0));
    /// ```
    pub fn reflect(&self, normal: Vector3) -> Vector3 {
        *self - normal * 2.0 * self.dot(normal)
    }

    /// Rotates this `Vector3` about the given `axis` by the given `angle` in radians.
    ///
    /// # Arguments
    ///
    /// * `axis` - The axis to rotate about.
    /// * `angle` - The angle to rotate by in radians.
    ///
    /// # Returns
    ///
    /// The rotated `Vector3`.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::Vector3;
    ///
    /// let vec = Vector3::new(1.0, 0.0, 0.0);
    /// let axis = Vector3::new(0.0, 0.0, 1.0);
    /// let angle = std::f32::consts::FRAC_PI_2;
    /// let rotated = vec.rotate_about_axis(axis, angle);
    /// assert_eq!(rotated, Vector3::new(0.0, 1.0, 0.0));
    /// ```
    pub fn rotate_about_axis(&self, axis: Vector3, angle: f32) -> Vector3 {
        let cos = angle.cos();
        let sin = angle.sin();
        let one_minus_cos = 1.0 - cos;

        let mut x = self.x * (cos + axis.x * axis.x * one_minus_cos)
            + self.y * (axis.x * axis.y * one_minus_cos - axis.z * sin)
            + self.z * (axis.x * axis.z * one_minus_cos + axis.y * sin);
        let mut y = self.x * (axis.y * axis.x * one_minus_cos + axis.z * sin)
            + self.y * (cos + axis.y * axis.y * one_minus_cos)
            + self.z * (axis.y * axis.z * one_minus_cos - axis.x * sin);
        let mut z = self.x * (axis.z * axis.x * one_minus_cos - axis.y * sin)
            + self.y * (axis.z * axis.y * one_minus_cos + axis.x * sin)
            + self.z * (cos + axis.z * axis.z * one_minus_cos);

        if x.abs() < 0.000001 {
            x = 0.0;
        }
        if y.abs() < 0.000001 {
            y = 0.0;
        }
        if z.abs() < 0.000001 {
            z = 0.0;
        }

        Vector3::new(x, y, z)
    }

}


impl std::ops::Index<usize> for Vector4 {
    type Output = f32;

    // Returns a reference to the element at the given `index` of this `Vector4`.
        ///
        /// # Arguments
        ///
        /// * `index` - The index of the element to retrieve.
        ///
        /// # Panics
        ///
        /// Panics if `index` is greater than or equal to 4.
        ///
        /// # Examples
        ///
        /// ```
        /// use cgl_rs::math::Vector4;
        ///
        /// let vec = Vector4::new(1.0, 2.0, 3.0, 4.0);
        /// assert_eq!(vec[0], 1.0);
        /// assert_eq!(vec[1], 2.0);
        /// assert_eq!(vec[2], 3.0);
        /// assert_eq!(vec[3], 4.0);
        /// ```
        fn index(&self, index: usize) -> &Self::Output {
            match index {
                0 => &self.x,
                1 => &self.y,
                2 => &self.z,
                3 => &self.w,
                _ => panic!("Index out of bounds for Vector4"),
            }
        }
}

impl std::ops::IndexMut<usize> for Vector4 {
    /// Returns a mutable reference to the element at the given `index` of this `Vector4`.
    ///
    /// # Arguments
    ///
    /// * `index` - The index of the element to retrieve.
    ///
    /// # Panics
    ///
    /// Panics if `index` is greater than or equal to 4.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::Vector4;
    ///
    /// let mut vec = Vector4::new(1.0, 2.0, 3.0, 4.0);
    /// vec[0] = 5.0;
    /// assert_eq!(vec[0], 5.0);
    /// ```
    fn index_mut(&mut self, index: usize) -> &mut Self::Output {
        match index {
            0 => &mut self.x,
            1 => &mut self.y,
            2 => &mut self.z,
            3 => &mut self.w,
            _ => panic!("Index out of bounds for Vector4"),
        }
    }
}

crate::macros::impl_vector_binary_ops!(Vector4, 4);

impl Vector4 {

    /// Creates a new `Vector4` with the given `x`, `y`, `z`, and `w` components.
    ///
    /// # Arguments
    ///
    /// * `x` - The `x` component of the new `Vector4`.
    /// * `y` - The `y` component of the new `Vector4`.
    /// * `z` - The `z` component of the new `Vector4`.
    /// * `w` - The `w` component of the new `Vector4`.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::Vector4;
    ///
    /// let vec = Vector4::new(1.0, 2.0, 3.0, 4.0);
    /// assert_eq!(vec.x, 1.0);
    /// assert_eq!(vec.y, 2.0);
    /// assert_eq!(vec.z, 3.0);
    /// assert_eq!(vec.w, 4.0);
    /// ```
    pub fn new(x: f32, y: f32, z: f32, w: f32) -> Vector4 {
        Vector4 { x, y, z, w }
    }


    /// Creates a new `Vector4` from a `Vector3` and a `w` component.
    ///
    /// # Arguments
    ///
    /// * `vec` - The `Vector3` to use as the `x`, `y`, and `z` components of the new `Vector4`.
    /// * `w` - The `w` component of the new `Vector4`.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::{Vector3, Vector4};
    ///
    /// let vec3 = Vector3::new(1.0, 2.0, 3.0);
    /// let vec4 = Vector4::from_vec3(vec3, 4.0);
    /// assert_eq!(vec4.x, 1.0);
    /// assert_eq!(vec4.y, 2.0);
    /// assert_eq!(vec4.z, 3.0);
    /// assert_eq!(vec4.w, 4.0);
    /// ```
    pub fn from_vec3(vec: Vector3, w: f32) -> Vector4 {
        Vector4::new(vec.x, vec.y, vec.z, w)
    }

    /// Creates a new `Vector4` from a `Vector2`, `z`, and `w` components.
    ///
    /// # Arguments
    ///
    /// * `vec` - The `Vector2` to use as the `x` and `y` components of the new `Vector4`.
    /// * `z` - The `z` component of the new `Vector4`.
    /// * `w` - The `w` component of the new `Vector4`.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::{Vector2, Vector4};
    ///
    /// let vec2 = Vector2::new(1.0, 2.0);
    /// let vec4 = Vector4::from_vec2(vec2, 3.0, 4.0);
    /// assert_eq!(vec4.x, 1.0);
    /// assert_eq!(vec4.y, 2.0);
    /// assert_eq!(vec4.z, 3.0);
    /// assert_eq!(vec4.w, 4.0);
    /// ```
    pub fn from_vec2(vec: Vector2, z: f32, w: f32) -> Vector4 {
        Vector4::new(vec.x, vec.y, z, w)
    }


    /// Returns a new `Vector4` with all components set to `0.0`.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::Vector4;
    ///
    /// let vec = Vector4::zero();
    /// assert_eq!(vec.x, 0.0);
    /// assert_eq!(vec.y, 0.0);
    /// assert_eq!(vec.z, 0.0);
    /// assert_eq!(vec.w, 0.0);
    /// ```
    pub fn zero() -> Vector4 {
        Vector4::new(0.0, 0.0, 0.0, 0.0)
    }

    /// Returns a new `Vector4` with all components set to `1.0`.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::Vector4;
    ///
    /// let vec = Vector4::one();
    /// assert_eq!(vec.x, 1.0);
    /// assert_eq!(vec.y, 1.0);
    /// assert_eq!(vec.z, 1.0);
    /// assert_eq!(vec.w, 1.0);
    /// ```
    pub fn one() -> Vector4 {
        Vector4::new(1.0, 1.0, 1.0, 1.0)
    }


    /// Extracts the `x`, `y`, and `z` components of the `Vector4` as a new `Vector3`.
    /// 
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::{Vector3, Vector4};
    ///
    /// let vec4 = Vector4::new(1.0, 2.0, 3.0, 4.0);
    /// let vec3 = vec4.xyz();
    /// assert_eq!(vec3.x, 1.0);
    /// assert_eq!(vec3.y, 2.0);
    /// assert_eq!(vec3.z, 3.0);
    /// ```
    pub fn xyz(&self) -> Vector3 {
        Vector3::new(self.x, self.y, self.z)
    }



}


impl std::ops::Index<usize> for IVector4 {
    type Output = i32;

    // Returns a reference to the element at the given `index` of this `Vector4`.
        ///
        /// # Arguments
        ///
        /// * `index` - The index of the element to retrieve.
        ///
        /// # Panics
        ///
        /// Panics if `index` is greater than or equal to 4.
        ///
        /// # Examples
        ///
        /// ```
        /// use cgl_rs::math::IVector4;
        ///
        /// let vec = IVector4::new(1, 2, 3, 4);
        /// assert_eq!(vec[0], 1);
        /// assert_eq!(vec[1], 2);
        /// assert_eq!(vec[2], 3);
        /// assert_eq!(vec[3], 4);
        /// ```
        fn index(&self, index: usize) -> &Self::Output {
            match index {
                0 => &self.x,
                1 => &self.y,
                2 => &self.z,
                3 => &self.w,
                _ => panic!("Index out of bounds for IVector4"),
            }
        }
}

impl std::ops::IndexMut<usize> for IVector4 {
    /// Returns a mutable reference to the element at the given `index` of this `Vector4`.
    ///
    /// # Arguments
    ///
    /// * `index` - The index of the element to retrieve.
    ///
    /// # Panics
    ///
    /// Panics if `index` is greater than or equal to 4.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::IVector4;
    ///
    /// let mut vec = IVector4::new(1, 2, 3, 4);
    /// vec[0] = 5;
    /// assert_eq!(vec[0], 5);
    /// ```
    fn index_mut(&mut self, index: usize) -> &mut Self::Output {
        match index {
            0 => &mut self.x,
            1 => &mut self.y,
            2 => &mut self.z,
            3 => &mut self.w,
            _ => panic!("Index out of bounds for IVector4"),
        }
    }
}


impl IVector4 {
    /// Creates a new `IVector4` with the given `x`, `y`, `z`, and `w` components.
    ///
    /// # Arguments
    ///
    /// * `x` - The `x` component of the vector.
    /// * `y` - The `y` component of the vector.
    /// * `z` - The `z` component of the vector.
    /// * `w` - The `w` component of the vector.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::IVector4;
    ///
    /// let vec = IVector4::new(1, 2, 3, 4);
    /// assert_eq!(vec.x, 1);
    /// assert_eq!(vec.y, 2);
    /// assert_eq!(vec.z, 3);
    /// assert_eq!(vec.w, 4);
    /// ```
    pub fn new(x: i32, y: i32, z: i32, w: i32) -> IVector4 {
        IVector4 { x, y, z, w }
    }

    /// Returns a new `IVector4` with all components set to 0.
    ///
    /// # Examples
    ///
    /// ```
    /// use cgl_rs::math::IVector4;
    ///
    /// let vec = IVector4::zero();
    /// assert_eq!(vec.x, 0);
    /// assert_eq!(vec.y, 0);
    /// assert_eq!(vec.z, 0);
    /// assert_eq!(vec.w, 0);
    /// ```
    pub fn zero() -> IVector4 {
        IVector4::new(0, 0, 0, 0)
    }
}
```

`rust_wrapper/cgl-rs/src/noise.rs`:

```rs
//! The CGL Noise Module.

#![allow(non_camel_case_types)]

/// This is a controllable parameter of CGL library
/// But as of now, it cannot be controlled from Rust
pub type NoiseDataType = f32;

/// The type of noise to generate.
pub enum NoiseType {
    Perlin          = 0,
    OpenSimplex     = 1,
    OpenSimplex2S   = 2,
    Value           = 3,
    ValueCubic      = 4,
    Worley          = 5
}

/// The type of fractal to use when generating noise.
pub enum FractalType {
    None            = 0,
    FBM             = 1,
    Billow          = 2,
    Rigid           = 3,
    PingPong        = 4
}

#[repr(C)] #[derive(Debug, Copy, Clone)]
pub struct NoiseParams {
    pub type_id: i32,
    pub fractal_type: i32,
    pub octaves: i32,
    pub frequency: NoiseDataType,
    pub lacunarity: NoiseDataType,
    pub gain: NoiseDataType,
    pub weighted_strength: NoiseDataType,
    pub ping_pong_strength: NoiseDataType
}

extern {
    fn CGL_noise_init();
    fn CGL_noise_shutdown();
    fn CGL_noise_perlin(x: NoiseDataType, y: NoiseDataType, z: NoiseDataType) -> NoiseDataType;
    fn CGL_noise_opensimplex(x: NoiseDataType, y: NoiseDataType, z: NoiseDataType) -> NoiseDataType;
    fn CGL_noise_opensimplex2s(x: NoiseDataType, y: NoiseDataType, z: NoiseDataType) -> NoiseDataType;
    fn CGL_noise_value(x: NoiseDataType, y: NoiseDataType, z: NoiseDataType) -> NoiseDataType;
    fn CGL_noise_valuecubic(x: NoiseDataType, y: NoiseDataType, z: NoiseDataType) -> NoiseDataType;
    fn CGL_noise_worley(x: NoiseDataType, y: NoiseDataType, z: NoiseDataType) -> NoiseDataType;
    fn CGL_noise_params_default(params: *mut NoiseParams);
    fn CGL_noise_get(params: *const NoiseParams, x: NoiseDataType, y: NoiseDataType, z: NoiseDataType) -> NoiseDataType;
}

impl NoiseParams {
    /// Creates a new `NoiseParams` instance with default values.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::noise::init();
    /// let params = cgl_rs::noise::NoiseParams::new();
    /// cgl_rs::noise::shutdown();
    /// ```
    pub fn new() -> Self {
        let params = NoiseParams {
            type_id: 0,
            fractal_type: 0,
            octaves: 0,
            frequency: 0.0,
            lacunarity: 0.0,
            gain: 0.0,
            weighted_strength: 0.0,
            ping_pong_strength: 0.0
        };
        unsafe {
            CGL_noise_params_default(&params as *const NoiseParams as *mut NoiseParams);
        }
        params
    }

    /// Sets the type of noise to generate.
    /// 
    /// # Example
    /// ```
    /// cgl_rs::noise::init();
    /// let mut params = cgl_rs::noise::NoiseParams::new();
    /// params.set_type(cgl_rs::noise::NoiseType::Perlin);
    /// cgl_rs::noise::shutdown();
    /// ````
    pub fn set_type(&mut self, noise_type: NoiseType) {
        self.type_id = noise_type as i32;
    }

    /// Sets the type of fractal to use when generating noise.
    /// 
    /// # Example
    /// ```
    /// cgl_rs::noise::init();
    /// let mut params = cgl_rs::noise::NoiseParams::new();
    /// params.set_fractal_type(cgl_rs::noise::FractalType::FBM);
    /// cgl_rs::noise::shutdown();
    /// ```
    pub fn set_fractal_type(&mut self, fractal_type: FractalType) {
        self.fractal_type = fractal_type as i32;
    }

    /// Sets the number of octaves to use when generating noise.
    /// 
    /// # Example
    /// ```
    /// cgl_rs::noise::init();
    /// let mut params = cgl_rs::noise::NoiseParams::new();
    /// params.set_octaves(4);
    /// cgl_rs::noise::shutdown();
    /// ```
    pub fn set_octaves(&mut self, octaves: i32) {
        self.octaves = octaves;
    }

    /// Sets the frequency of the noise.
    /// 
    /// # Example
    /// ```
    /// cgl_rs::noise::init();
    /// let mut params = cgl_rs::noise::NoiseParams::new();
    /// params.set_frequency(0.01);
    /// cgl_rs::noise::shutdown();
    /// ```
    pub fn set_frequency(&mut self, frequency: NoiseDataType) {
        self.frequency = frequency;
    }

    /// Sets the lacunarity of the noise.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::noise::init();
    /// let mut params = cgl_rs::noise::NoiseParams::new();
    /// params.set_lacunarity(2.0);
    /// cgl_rs::noise::shutdown();
    /// ```
    pub fn set_lacunarity(&mut self, lacunarity: NoiseDataType) {
        self.lacunarity = lacunarity;
    }

    /// Sets the gain of the noise.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::noise::init();
    /// let mut params = cgl_rs::noise::NoiseParams::new();
    /// params.set_gain(0.5);
    /// cgl_rs::noise::shutdown();
    /// ```
    pub fn set_gain(&mut self, gain: NoiseDataType) {
        self.gain = gain;
    }

    /// Sets the weighted strength of the noise.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::noise::init();
    /// let mut params = cgl_rs::noise::NoiseParams::new();
    /// params.set_weighted_strength(0.5);
    /// cgl_rs::noise::shutdown();
    /// ```
    pub fn set_weighted_strength(&mut self, weighted_strength: NoiseDataType) {
        self.weighted_strength = weighted_strength;
    }

    /// Sets the ping pong strength of the noise.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::noise::init();
    /// let mut params = cgl_rs::noise::NoiseParams::new();
    /// params.set_ping_pong_strength(0.5);
    /// cgl_rs::noise::shutdown();
    /// ```
    pub fn set_ping_pong_strength(&mut self, ping_pong_strength: NoiseDataType) {
        self.ping_pong_strength = ping_pong_strength;
    }

    /// Gets the type of noise being generated.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::noise::init();
    /// let params = cgl_rs::noise::NoiseParams::new();
    /// let noise_type = params.get_type();
    /// cgl_rs::noise::shutdown();
    /// ```
    pub fn get_type(&self) -> NoiseType {
        match self.type_id {
            0 => NoiseType::Perlin,
            1 => NoiseType::OpenSimplex,
            2 => NoiseType::OpenSimplex2S,
            3 => NoiseType::Value,
            4 => NoiseType::ValueCubic,
            5 => NoiseType::Worley,
            _ => panic!("Invalid noise type")
        }
    }

    /// Gets the type of fractal being used to generate noise.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::noise::init();
    /// let params = cgl_rs::noise::NoiseParams::new();
    /// let fractal_type = params.get_fractal_type();
    /// cgl_rs::noise::shutdown();
    /// ```
    pub fn get_fractal_type(&self) -> FractalType {
        match self.fractal_type {
            0 => FractalType::None,
            1 => FractalType::FBM,
            2 => FractalType::Billow,
            3 => FractalType::Rigid,
            4 => FractalType::PingPong,
            _ => panic!("Invalid fractal type")
        }
    }

    /// Gets the number of octaves being used to generate noise.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::noise::init();
    /// let params = cgl_rs::noise::NoiseParams::new();
    /// let octaves = params.get_octaves();
    /// cgl_rs::noise::shutdown();
    /// ```
    pub fn get_octaves(&self) -> i32 {
        self.octaves
    }

    /// Gets the frequency of the noise.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::noise::init();
    /// let params = cgl_rs::noise::NoiseParams::new();
    /// let frequency = params.get_frequency();
    /// cgl_rs::noise::shutdown();
    /// ```
    pub fn get_frequency(&self) -> NoiseDataType {
        self.frequency
    }

    /// Gets the lacunarity of the noise.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::noise::init();
    /// let params = cgl_rs::noise::NoiseParams::new();
    /// let lacunarity = params.get_lacunarity();
    /// cgl_rs::noise::shutdown();
    /// ```
    pub fn get_lacunarity(&self) -> NoiseDataType {
        self.lacunarity
    }

    /// Gets the gain of the noise.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::noise::init();
    /// let params = cgl_rs::noise::NoiseParams::new();
    /// let gain = params.get_gain();
    /// cgl_rs::noise::shutdown();
    /// ```
    pub fn get_gain(&self) -> NoiseDataType {
        self.gain
    }

    /// Gets the weighted strength of the noise.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::noise::init();
    /// let params = cgl_rs::noise::NoiseParams::new();
    /// let weighted_strength = params.get_weighted_strength();
    /// cgl_rs::noise::shutdown();
    /// ```
    pub fn get_weighted_strength(&self) -> NoiseDataType {
        self.weighted_strength
    }

    /// Gets the ping pong strength of the noise.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::noise::init();
    /// let params = cgl_rs::noise::NoiseParams::new();
    /// let ping_pong_strength = params.get_ping_pong_strength();
    /// cgl_rs::noise::shutdown();
    /// ```
    pub fn get_ping_pong_strength(&self) -> NoiseDataType {
        self.ping_pong_strength
    }

    /// Generates noise using the current parameters.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::noise::init();
    /// let mut params = cgl_rs::noise::NoiseParams::new();
    /// let noise = params.get_noise(0.0, 0.0, 0.0);
    /// cgl_rs::noise::shutdown();
    /// ```
    /// 
    /// # See also
    /// 
    /// * cgl_rs::noise::get
    pub fn get_noise(&self, x: NoiseDataType, y: NoiseDataType, z: NoiseDataType) -> NoiseDataType {
        unsafe {
            CGL_noise_get(self as *const NoiseParams as *mut NoiseParams, x, y, z)
        }
    }

}
/// Initializes the noise library.
/// 
/// This function must be called before any other noise functions are used.
/// 
/// # Example
/// 
/// ```
/// cgl_rs::noise::init();
/// // Use noise functions here
/// cgl_rs::noise::shutdown();
/// ```
pub fn init() {
    unsafe {
        CGL_noise_init();
    }
}

/// Shuts down the noise library.
/// 
/// This function must be called when the noise library is no longer needed.
/// 
/// # Example
/// 
/// ```
/// cgl_rs::noise::init();
/// // Use noise functions here
/// cgl_rs::noise::shutdown();
/// ```
pub fn shutdown() {
    unsafe {
        CGL_noise_shutdown();
    }
}


/// Gets the perlin noise value at the given coordinates.
/// 
/// # Example
/// 
/// ```
/// cgl_rs::noise::init();
/// let noise = cgl_rs::noise::perlin(0.0, 0.0, 0.0);
/// cgl_rs::noise::shutdown();
/// ```
pub fn perlin(x: NoiseDataType, y: NoiseDataType, z: NoiseDataType) -> NoiseDataType {
    unsafe {
        CGL_noise_perlin(x, y, z)
    }
}


/// Gets the opensimplex noise value at the given coordinates.
/// 
/// # Example
/// 
/// ```
/// cgl_rs::noise::init();
/// let noise = cgl_rs::noise::opensimplex(0.0, 0.0, 0.0);
/// cgl_rs::noise::shutdown();
/// ```
pub fn opensimplex(x: NoiseDataType, y: NoiseDataType, z: NoiseDataType) -> NoiseDataType {
    unsafe {
        CGL_noise_opensimplex(x, y, z)
    }
}

/// Gets the opensimplex2s noise value at the given coordinates.
/// 
/// # Example
/// 
/// ```
/// cgl_rs::noise::init();
/// let noise = cgl_rs::noise::opensimplex2s(0.0, 0.0, 0.0);
/// cgl_rs::noise::shutdown();
/// ```
pub fn opensimplex2s(x: NoiseDataType, y: NoiseDataType, z: NoiseDataType) -> NoiseDataType {
    unsafe {
        CGL_noise_opensimplex2s(x, y, z)
    }
}

/// Gets the value noise value at the given coordinates.
/// 
/// # Example
/// 
/// ```
/// cgl_rs::noise::init();
/// let noise = cgl_rs::noise::value(0.0, 0.0, 0.0);
/// cgl_rs::noise::shutdown();
/// ```
pub fn value(x: NoiseDataType, y: NoiseDataType, z: NoiseDataType) -> NoiseDataType {
    unsafe {
        CGL_noise_value(x, y, z)
    }
}


/// Gets the valuecubic noise value at the given coordinates.
/// 
/// # Example
/// 
/// ```
/// cgl_rs::noise::init();
/// let noise = cgl_rs::noise::valuecubic(0.0, 0.0, 0.0);
/// cgl_rs::noise::shutdown();
/// ```
pub fn valuecubic(x: NoiseDataType, y: NoiseDataType, z: NoiseDataType) -> NoiseDataType {
    unsafe {
        CGL_noise_valuecubic(x, y, z)
    }
}


/// Gets the worley noise value at the given coordinates.
/// 
/// # Example
/// 
/// ```
/// cgl_rs::noise::init();
/// let noise = cgl_rs::noise::worley(0.0, 0.0, 0.0);
/// cgl_rs::noise::shutdown();
/// ```
pub fn worley(x: NoiseDataType, y: NoiseDataType, z: NoiseDataType) -> NoiseDataType {
    unsafe {
        CGL_noise_worley(x, y, z)
    }
}

/// Generates noise with the given NoiseParams and x, y, and z coordinates.
/// 
/// # Example
/// 
/// ```
/// cgl_rs::noise::init();
/// let mut params = cgl_rs::noise::NoiseParams::new();
/// let noise = cgl_rs::noise::get(&params, 0.0, 0.0, 0.0);
/// cgl_rs::noise::shutdown();
/// ```
/// 
/// # See also
/// 
/// * cgl_rs::noise::NoiseParams::get_noise
pub fn get(params: &NoiseParams, x: NoiseDataType, y: NoiseDataType, z: NoiseDataType) -> NoiseDataType {
    unsafe {
        CGL_noise_get(params as *const NoiseParams, x, y, z)
    }
}

```

`rust_wrapper/cgl-rs/src/utils.rs`:

```rs
//! This module contains CGL utility functions, as well some miscellaneous functions.

#![allow(non_camel_case_types)]
use std::{ops::{Add, Sub, Mul, Div}, ffi::CString};

use libc::{c_void, c_int, c_char, c_float, size_t};

extern {
    fn CGL_utils_sleep(milis: size_t) -> c_void;
    fn CGL_utils_read_file(path: *const c_char, size: *mut size_t) -> *mut c_char;
    fn CGL_utils_get_file_size(path: *const c_char) -> size_t;
    fn CGL_utils_append_file(path: *const c_char, data: *const c_char, size: size_t) -> c_int;
    fn CGL_utils_write_file(path: *const c_char, data: *const c_char, size: size_t) -> c_int;
    fn CGL_utils_get_time() -> c_float;
    fn CGL_utils_get_timestamp(buffer: *mut c_char) -> c_void;
    fn CGL_utils_is_little_endian() -> c_int;
    fn CGL_utils_get_random_with_probability(probabilities: *mut c_float, count: size_t) -> size_t;
    fn CGL_utils_reverse_bytes(data: *mut c_void, size: size_t) -> c_void;
    fn CGL_utils_little_endian_to_current(data: *mut c_void, size: size_t) -> c_void;
    fn CGL_utils_big_endian_to_current(data: *mut c_void, size: size_t) -> c_void;
    fn CGL_utils_fast_srand(seed: c_int) -> c_void;
    fn CGL_utils_fast_rand() -> c_int;
    fn CGL_utils_xorshf96() -> u64;
    fn CGL_utils_srand31(seed: u32) -> c_void;
    fn CGL_utils_rand31() -> u32;

    fn CGL_utils_crc32(data: *const c_void, size: size_t) -> u32;
    fn CGL_utils_crc64(data: *const c_void, size: size_t) -> u64;
    fn CGL_utils_rot13(data_in: *const c_char, data_out: *mut c_char) -> c_void;
    fn CGL_utils_super_fast_hash(data: *const c_void, size: size_t) -> u32;

    /// These are originally CGL Macros but have been proxied here as functions.
    fn CGL_utils_random_float_MACRO() -> c_float;
    fn CGL_utils_random_float_in_range_MACRO(min_val: c_float, max_val: c_float) -> c_float;
    fn CGL_utils_random_int_MACRO(min_val: c_int, max_val: c_int) -> c_int;
    fn CGL_utils_random_bool_MACRO() -> c_int;
}


/// Suspends the current thread for the specified amount of time.
///
/// # Arguments
///
/// * `milis` - The amount of time to sleep, in milliseconds.
/// 
/// # Example
/// 
/// ```
/// cgl_rs::utils::sleep(1000);
/// ```
pub fn sleep(milis: size_t) -> () {
    unsafe {
        CGL_utils_sleep(milis);
    }
}


/// Reads the contents of a file and returns it as a vector of bytes.
///
/// # Arguments
///
/// * `path` - The path to the file to read.
/// * `size` - A pointer to a size_t variable that will be set to the size of the file.
///
/// # Example
///
/// ```
/// let (size, contents) = cgl_rs::utils::read_file("log.txt");
/// ```
pub fn read_file(path: &str) -> (usize, Vec<i8>) {
    unsafe {
        let mut size: size_t = 0;
        let path = std::ffi::CString::new(path).unwrap();
        let data = CGL_utils_read_file(path.as_ptr(), &mut size);
        let mut vec = Vec::new();
        for i in 0..size {
            vec.push(*data.offset(i as isize));
        }
        libc::free(data as *mut c_void);
        (size as usize, vec)
    }
}


/// Reads the contents of a file and returns it as a string.
///
/// # Arguments
///
/// * `path` - The path to the file to read.
///
/// # Example
///
/// ```
/// let contents = cgl_rs::utils::read_file_as_string("log.txt");
/// ```
pub fn read_file_as_string(path: &str) -> String {
    let (size, data) = read_file(path);
    let mut string = String::new();
    for i in 0..size {
        string.push(data[i] as u8 as char);
    }
    string
}

/// Returns the size of a file in bytes.
///
/// # Arguments
///
/// * `path` - The path to the file to get the size of.
///
/// # Example
///
/// ```no_run
/// let path = "path/to/file";
/// let size = cgl_rs::utils::get_file_size(path);
/// ```
pub fn get_file_size(path: &str) -> usize {
    unsafe {
        let path = std::ffi::CString::new(path).unwrap();
        CGL_utils_get_file_size(path.as_ptr()) as usize
    }
}


// Appends data to a file.
///
/// # Arguments
///
/// * `path` - The path to the file to append data to.
/// * `data` - A slice of bytes to append to the file.
/// * `size` - The size of the data slice.
///
/// # Example
///
/// ```
/// let data = [1, 2, 3];
/// let success = cgl_rs::utils::append_file("log.txt", &data, 3);
/// ```
pub fn append_file(path: &str, data: &[u8], size: usize) -> bool {
    unsafe {
        let path = std::ffi::CString::new(path).unwrap();
        CGL_utils_write_file(path.as_ptr(), data.as_ptr() as *const c_char, size as size_t) != 0
    }
}


/// Appends a string to a file.
///
/// # Arguments
///
/// * `path` - The path to the file to append the string to.
/// * `data` - The string to append to the file.
///
/// # Example
///
/// ```
/// let success = cgl_rs::utils::append_string_to_file("log.txt", "Hello, world!");
/// ```
pub fn append_string_to_file(path: &str, data: &str) -> bool {
    append_file(path, data.as_bytes(), data.len())
}


// Writes data to a file.
///
/// # Arguments
///
/// * `path` - The path to the file to write data to.
/// * `data` - A slice of bytes to write to the file.
/// * `size` - The size of the data slice.
///
/// # Example
///
/// ```
/// let data = [1, 2, 3];
/// let success = cgl_rs::utils::write_file("log.txt", &data, 3);
/// ```
pub fn write_file(path: &str, data: &[u8], size: usize) -> bool {
    unsafe {
        let path = std::ffi::CString::new(path).unwrap();
        CGL_utils_write_file(path.as_ptr(), data.as_ptr() as *const c_char, size as size_t) != 0
    }
}

/// Writes a string to a file.
///
/// # Arguments
///
/// * `path` - The path to the file to write the string to.
/// * `data` - The string to write to the file.
///
/// # Example
///
/// ```
/// let success = cgl_rs::utils::write_string_to_file("log.txt", "Hello, world!");
/// ```
pub fn write_string_to_file(path: &str, data: &str) -> bool {
    write_file(path, data.as_bytes(), data.len())
}

/// Returns the time in seconds since the program started.
///
/// # Returns
///
/// * A `f32` representing the current time in seconds.
///
/// # Example
///
/// ```
/// let time = cgl_rs::utils::get_time();
/// ```
pub fn get_time() -> f32 {
    unsafe {
        CGL_utils_get_time() as f32
    }
}

/// Returns a string representing the current timestamp.
///
/// # Returns
///
/// * A `String` representing the current timestamp.
///
/// # Example
///
/// ```
/// let timestamp = cgl_rs::utils::get_timestamp();
/// ```
pub fn get_timestamp() -> String {
    unsafe {
        let mut buffer = [0 as c_char; 128];
        CGL_utils_get_timestamp(buffer.as_mut_ptr());
        std::ffi::CStr::from_ptr(buffer.as_ptr()).to_str().unwrap().to_string()
    }
}

/// Returns a boolean indicating whether the system is little-endian or not.
///
/// # Returns
///
/// * A `bool` indicating whether the system is little-endian or not.
///
/// # Example
///
/// ```
/// let is_little_endian = cgl_rs::utils::is_little_endian();
/// ```
pub fn is_little_endian() -> bool {
    unsafe {
        CGL_utils_is_little_endian() != 0
    }
}

/// Returns a random index from the given slice of probabilities, where the probability of each index being chosen is proportional to its value in the slice.
///
/// # Arguments
///
/// * `probabilities` - A mutable slice of `f32` values representing the probabilities of each index being chosen.
///
/// # Returns
///
/// * A `usize` representing the randomly chosen index.
///
/// # Example
///
/// ```
/// let mut probabilities = vec![0.1, 0.2, 0.3, 0.4];
/// let index = cgl_rs::utils::get_random_with_probability(&mut probabilities);
/// ```
pub fn get_random_with_probability(probabilities: &mut [f32]) -> usize {
    unsafe {
        CGL_utils_get_random_with_probability(probabilities.as_mut_ptr(), probabilities.len() as size_t)
    }
}

///
/// Reverses the order of bytes in the given slice of `u8` values.
///
/// # Arguments
///
/// * `data` - A mutable slice of `u8` values to reverse.
///
/// # Example
///
/// ```
/// let mut data = vec![0x12, 0x34, 0x56, 0x78];
/// cgl_rs::utils::reverse_bytes(&mut data);
/// assert_eq!(data, vec![0x78, 0x56, 0x34, 0x12]);
/// ```
pub fn reverse_bytes(data: &mut [u8]) -> () {
    unsafe {
        CGL_utils_reverse_bytes(data.as_mut_ptr() as *mut c_void, data.len() as size_t);
    }
}

/// Converts a slice of `u8` values from little-endian byte order to the system's native byte order.
///
/// # Arguments
///
/// * `data` - A mutable slice of `u8` values to convert.
///
/// # Example
///
/// ```
/// let mut data = vec![0x78, 0x56, 0x34, 0x12];
/// cgl_rs::utils::little_endian_to_current(&mut data);
/// ```
pub fn little_endian_to_current(data: &mut [u8]) -> () {
    unsafe {
        CGL_utils_little_endian_to_current(data.as_mut_ptr() as *mut c_void, data.len() as size_t);
    }
}

/// Converts a slice of `u8` values from big-endian byte order to the system's native byte order.
///
/// # Arguments
///
/// * `data` - A mutable slice of `u8` values to convert.
///
/// # Example
///
/// ```
/// let mut data = vec![0x12, 0x34, 0x56, 0x78];
/// cgl_rs::utils::big_endian_to_current(&mut data);
/// ```
pub fn big_endian_to_current(data: &mut [u8]) -> () {
    unsafe {
        CGL_utils_big_endian_to_current(data.as_mut_ptr() as *mut c_void, data.len() as size_t);
    }
}

/// Sets the seed for the fast random number generator.
///
/// # Arguments
///
/// * `seed` - An `i32` representing the seed value to set.
///
/// # Example
///
/// ```
/// cgl_rs::utils::fast_srand(42);
/// ```
pub fn fast_srand(seed: i32) -> () {
    unsafe {
        CGL_utils_fast_srand(seed);
    }
}

/// Generates a fast random number.
///
/// # Returns
///
/// An `i32` representing the generated random number.
///
/// # Example
///
/// ```
/// let random_number = cgl_rs::utils::fast_rand();
/// ```
pub fn fast_rand() -> i32 {
    unsafe {
        CGL_utils_fast_rand()
    }
}

/// Generates a fast random number using the xorshf96 algorithm.
/// 
/// # Returns
/// 
/// A `u64` representing the generated random number.
/// 
/// # Example
/// 
/// ```
/// let random_number = cgl_rs::utils::xorshf96();
/// ```
pub fn xorshf96() -> u64 {
    unsafe {
        CGL_utils_xorshf96()
    }
}



/// Sets the seed for the rand31 random number generator.
///
/// # Arguments
///
/// * `seed` - A `u32` representing the seed value to set.
///
/// # Example
///
/// ```
/// cgl_rs::utils::srand31(42);
/// ```
pub fn srand31(seed: u32) -> () {
    unsafe {
        CGL_utils_srand31(seed);
    }
}

/// Generates a random number using the rand31 algorithm.
///
/// # Returns
///
/// A `u32` representing the generated random number.
///
/// # Example
///
/// ```
/// let random_number = cgl_rs::utils::rand31();
/// ```
pub fn rand31() -> u32 {
    unsafe {
        CGL_utils_rand31()
    }
}


/// Linearly interpolates between two values.
///
/// # Arguments
///
/// * `a` - A value of type `T` representing the start value.
/// * `b` - A value of type `T` representing the end value.
/// * `t` - A value of type `T` representing the interpolation factor.
///
/// # Returns
///
/// A value of type `T` representing the interpolated value.
///
/// # Example
///
/// ```
/// let a = 0f32;
/// let b = 10f32;
/// let t = 0.5f32;
/// let result = cgl_rs::utils::lerp(a, b, t);
/// ```
pub fn lerp<T: Copy + Add<Output = T> + Sub<Output = T> + Mul<Output = T>>(a: T, b: T, t: T) -> T {
    a + (b - a) * t
}



/// Maps a value from one range to another.
///
/// # Arguments
///
/// * `value` - A value of type `T` representing the value to map.
/// * `start1` - A value of type `T` representing the start of the input range.
/// * `stop1` - A value of type `T` representing the end of the input range.
/// * `start2` - A value of type `T` representing the start of the output range.
/// * `stop2` - A value of type `T` representing the end of the output range.
///
/// # Returns
///
/// A value of type `T` representing the mapped value.
///
/// # Example
///
/// ```
/// let value = 5;
/// let start1 = 0;
/// let stop1 = 10;
/// let start2 = 0;
/// let stop2 = 100;
/// let result = cgl_rs::utils::map(value, start1, stop1, start2, stop2);
/// ```
pub fn map<T: Copy + Add<Output = T> + Sub<Output = T> + Mul<Output = T> + Div<Output = T>>(value: T, start1: T, stop1: T, start2: T, stop2: T) -> T {
    start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1))
}

/// Calculates the CRC32 checksum of the given data.
/// 
/// The C implementation is based on linux's crc32 implementation.
///
/// # Arguments
///
/// * `data` - A slice of bytes representing the data to calculate the checksum for.
///
/// # Returns
///
/// A `u32` representing the calculated CRC32 checksum.
///
/// # Example
///
/// ```
/// let data = b"hello world";
/// let crc32_checksum = cgl_rs::utils::crc32(data);
/// assert_eq!(crc32_checksum, 222957957);
/// ```
pub fn crc32(data: &[u8]) -> u32 {
    unsafe {
        CGL_utils_crc32(data.as_ptr() as *const c_void, data.len() as size_t) as u32
    }
}

// Calculates the CRC64 checksum of the given data.
///
/// The C implementation is based on linux's crc64 implementation.
/// 
/// # Arguments
///
/// * `data` - A slice of bytes representing the data to calculate the checksum for.
///
/// # Returns
///
/// A `u64` representing the calculated CRC64 checksum.
///
/// # Example
///
/// ```
/// let data = b"hello world";
/// let crc64_checksum = cgl_rs::utils::crc64(data);
/// assert_eq!(crc64_checksum, 14017174577685478301);
/// ```
pub fn crc64(data: &[u8]) -> u64 {
    unsafe {
        CGL_utils_crc64(data.as_ptr() as *const c_void, data.len() as size_t) as u64
    }
}

/// Applies the ROT13 substitution cipher to the given string.
///
/// # Arguments
///
/// * `data` - A string slice representing the data to apply the ROT13 cipher to.
///
/// # Returns
///
/// A `String` representing the result of applying the ROT13 cipher to the input string.
///
/// # Safety
///
/// This function is marked as unsafe because it calls an external C function that takes a raw pointer as an argument.
///
/// # Example
///
/// ```
/// let data = "hello world";
/// let result = cgl_rs::utils::rot13(data);
/// assert_eq!(result, "uryyb jbeyq\0");
/// ```
pub fn rot13(data: &str) -> String {
    unsafe {
        let mut result = vec![0u8; data.len() + 1];
        let c_str_data = CString::new(data).unwrap();
        CGL_utils_rot13(c_str_data.as_ptr(), result.as_mut_ptr() as *mut c_char);
        String::from_utf8_unchecked(result)
    }
}

/// Calculates the SuperFastHash of the given data.
/// 
/// This algorithm is from http://www.azillionmonkeys.com/qed/hash.html
/// 
/// # Arguments
/// 
/// * `data` - A slice of bytes representing the data to calculate the SuperFastHash for.
/// 
/// # Returns
/// 
/// A `u32` representing the calculated SuperFastHash.
/// 
/// # Example
/// 
/// ```
/// let data = b"hello world";
/// let super_fast_hash = cgl_rs::utils::super_fast_hash(data);
/// assert_eq!(super_fast_hash, 2794219650);
/// ```
pub fn super_fast_hash(data: &[u8]) -> u32 {
    unsafe {
        CGL_utils_super_fast_hash(data.as_ptr() as *const c_void, data.len() as size_t) as u32
    }
}


/// Generates a random floating-point number between 0 and 1.
///
/// # Returns
///
/// A `f32` representing the generated random number.
///
/// # Example
///
/// ```
/// let random_number = cgl_rs::utils::random_float();
/// ```
pub fn random_float() -> f32 {
    unsafe {
        CGL_utils_random_float_MACRO()
    }
}

/// Generates a random floating-point number within the given range.
///
/// # Arguments
///
/// * `min` - A `f32` representing the minimum value of the range.
/// * `max` - A `f32` representing the maximum value of the range.
///
/// # Returns
///
/// A `f32` representing the generated random number within the given range.
///
/// # Example
///
/// ```
/// let random_number = cgl_rs::utils::random_float_range(0.0, 1.0);
/// ```
pub fn random_float_range(min: f32, max: f32) -> f32 {
    unsafe {
        CGL_utils_random_float_in_range_MACRO(min as f32, max as f32) as f32
    }
}

/// Generates a random integer within the given range.
///
/// # Arguments
///
/// * `min_value` - An `i32` representing the minimum value of the range.
/// * `max_value` - An `i32` representing the maximum value of the range.
///
/// # Returns
///
/// An `i32` representing the generated random number within the given range.
///
/// # Example
///
/// ```
/// let random_number = cgl_rs::utils::random_int(0, 10);
/// ```
pub fn random_int(min_value: i32, max_value: i32) -> i32 {
    unsafe {
        CGL_utils_random_int_MACRO(min_value as i32, max_value as i32) as i32
    }
}
```

`rust_wrapper/cgl-rs/src/window.rs`:

```rs
//! The window manager module is responsible for creating and managing windows. It is also responsible for handling input events and passing them to the appropriate window.

#![allow(non_camel_case_types)]
use libc::{c_void, c_int, c_char, c_double};

/// The internal window handle used by CGL
#[repr(C)]
pub(crate) struct CGL_window {
    pub(crate) _private: c_void
}

/// The internal window handle used by GLFW
#[repr(C)]
pub struct GLFWwindow {
    _private: c_void
}

type CGL_window_key_callback = extern "C" fn(window: *mut CGL_window, key: c_int, scancode: c_int, action: c_int, mods: c_int) -> c_void;
type CGL_window_mouse_button_callback = extern "C" fn(window: *mut CGL_window, button: c_int, action: c_int, mods: c_int) -> c_void;
type CGL_window_mouse_position_callback = extern "C" fn(window: *mut CGL_window, x: c_double, y: c_double) -> c_void;
type CGL_window_mouse_scroll_callback = extern "C" fn(window: *mut CGL_window, x: c_double, y: c_double) -> c_void;
type CGL_window_framebuffer_size_callback = extern "C" fn(window: *mut CGL_window, width: c_int, height: c_int) -> c_void;
type CGL_window_close_callback = extern "C" fn(window: *mut CGL_window) -> c_void;
type CGL_window_drag_n_drop_callback = extern "C" fn(window: *mut CGL_window, paths: *const *const c_char, count: c_int) -> c_void;




extern {
    fn CGL_window_create(width: c_int, height: c_int, title: *const c_char) -> *mut CGL_window;
    fn CGL_window_create_undecorated(width: c_int, height: c_int, title: *const c_char) -> *mut CGL_window;
    fn CGL_window_destroy(window: *mut CGL_window) -> c_void;
    fn CGL_window_poll_events(window: *mut CGL_window) -> c_void;
    fn CGL_window_swap_buffers(window: *mut CGL_window) -> c_void;
    fn CGL_window_should_close(window: *mut CGL_window) -> c_int;
    fn CGL_window_set_title(window: *mut CGL_window, title: *const c_char) -> c_void;
    fn CGL_window_set_size(window: *mut CGL_window, width: c_int, height: c_int) -> c_void;
    fn CGL_window_set_position(window: *mut CGL_window, x: c_int, y: c_int) -> c_void;
    fn CGL_window_set_hidden(window: *mut CGL_window, hidden: c_int) -> c_void;
    fn CGL_window_set_user_data(window: *mut CGL_window, user_data: *mut c_void) -> c_void;
    fn CGL_window_get_user_data(window: *mut CGL_window) -> *mut c_void;
    fn CGL_window_get_size(window: *mut CGL_window, width: *mut c_int, height: *mut c_int) -> c_void;
    fn CGL_window_get_position(window: *mut CGL_window, x: *mut c_int, y: *mut c_int) -> c_void;
    fn CGL_window_get_framebuffer_size(window: *mut CGL_window, width: *mut c_int, height: *mut c_int) -> c_void;
    
    fn CGL_window_set_key_callback(window: *mut CGL_window, callback: CGL_window_key_callback) -> c_void;
    fn CGL_window_set_mouse_button_callback(window: *mut CGL_window, callback: CGL_window_mouse_button_callback) -> c_void;
    fn CGL_window_set_mouse_position_callback(window: *mut CGL_window, callback: CGL_window_mouse_position_callback) -> c_void;
    fn CGL_window_set_mouse_scroll_callback(window: *mut CGL_window, callback: CGL_window_mouse_scroll_callback) -> c_void;
    fn CGL_window_set_framebuffer_size_callback(window: *mut CGL_window, callback: CGL_window_framebuffer_size_callback) -> c_void;
    fn CGL_window_set_close_callback(window: *mut CGL_window, callback: CGL_window_close_callback) -> c_void;
    fn CGL_window_set_drag_n_drop_callback(window: *mut CGL_window, callback: CGL_window_drag_n_drop_callback) -> c_void;

    fn CGL_window_resecure_callbacks(window: *mut CGL_window) -> c_void;
    fn CGL_window_make_context_current(window: *mut CGL_window) -> c_void;
    fn CGL_window_get_glfw_handle(window: *mut CGL_window) -> *mut GLFWwindow;

    fn CGL_window_get_key(window: *mut CGL_window, key: c_int) -> c_int;
    fn CGL_window_is_key_pressed(window: *mut CGL_window, key: c_int) -> c_int;
    fn CGL_window_get_mouse_button(window: *mut CGL_window, button: c_int) -> c_int;
    fn CGL_window_get_mouse_position(window: *mut CGL_window, x: *mut c_double, y: *mut c_double) -> c_void;

    fn CGL_utils_sleep(duration: usize) -> c_void; // temporary
}


/// Represents a keyboard key, with each variant corresponding to a specific key code.
#[repr(C)] #[derive(Debug)]
pub enum Key {
    Unknown            = -1,
    Space              = 32,
    Apostrophe         = 39,
    Comma              = 44,
    Minus              = 45,
    Period             = 46,
    Slash              = 47,
    K0                 = 48,
    K1                 = 49,
    K2                 = 50,
    K3                 = 51,
    K4                 = 52,
    K5                 = 53,
    K6                 = 54,
    K7                 = 55,
    K8                 = 56,
    K9                 = 57,
    Semicolon          = 59,
    Equal              = 61,
    A                  = 65,
    B                  = 66,
    C                  = 67,
    D                  = 68,
    E                  = 69,
    F                  = 70,
    G                  = 71,
    H                  = 72,
    I                  = 73,
    J                  = 74,
    K                  = 75,
    L                  = 76,
    M                  = 77,
    N                  = 78,
    O                  = 79,
    P                  = 80,
    Q                  = 81,
    R                  = 82,
    S                  = 83,
    T                  = 84,
    U                  = 85,
    V                  = 86,
    W                  = 87,
    X                  = 88,
    Y                  = 89,
    Z                  = 90,
    LeftBracket        = 91,
    Backslash          = 92,
    RightBracket       = 93,
    GraveAccent        = 96,
    Escape             = 256,
    Enter              = 257,
    Tab                = 258,
    Backspace          = 259,
    Insert             = 260,
    Delete             = 261,
    Right              = 262,
    Left               = 263,
    Down               = 264,
    Up                 = 265,
    PageUp             = 266,
    PageDown           = 267,
    Home               = 268,
    End                = 269,
    CapsLock           = 280,
    ScrollLock         = 281,
    NumLock            = 282,
    PrintScreen        = 283,
    Pause              = 284,
    F1                 = 290,
    F2                 = 291,
    F3                 = 292,
    F4                 = 293,
    F5                 = 294,
    F6                 = 295,
    F7                 = 296,
    F8                 = 297,
    F9                 = 298,
    F10                = 299,
    F11                = 300,
    F12                = 301,
    F13                = 302,
    F14                = 303,
    F15                = 304,
    F16                = 305,
    F17                = 306,
    F18                = 307,
    F19                = 308,
    F20                = 309,
    F21                = 310,
    F22                = 311,
    F23                = 312,
    F24                = 313,
    F25                = 314,
    KeyPad0            = 320,
    KeyPad1            = 321,
    KeyPad2            = 322,
    KeyPad3            = 323,
    KeyPad4            = 324,
    KeyPad5            = 325,
    KeyPad6            = 326,
    KeyPad7            = 327,
    KeyPad8            = 328,
    KeyPad9            = 329,
    KeyPadDecimal      = 330,
    KeyPadDivide       = 331,
    KeyPadMultiply     = 332,
    KeyPadSubtract     = 333,
    KeyPadAdd          = 334,
    KeyPadEnter        = 335,
    KeyPadEqual        = 336,
    LeftShift          = 340,
    LeftControl        = 341,
    LeftAlt            = 342,
    LeftSuper          = 343,
    RightShift         = 344,
    RightControl       = 345,
    RightAlt           = 346,
    RightSuper         = 347,
    Menu               = 348
}

/// Represents a mouse button, with each variant corresponding to a specific button code.
#[derive(Debug)]
pub enum MouseButton {
    Left       = 0,
    Right      = 1,
    Middle     = 2,
    B4         = 3,
    B5         = 4,
    B6         = 5,
    B7         = 6,
    B8         = 7,
    Last       = 8
}

/// Represents an action, with each variant corresponding to a specific action code.
#[derive(Debug, PartialEq)]
pub enum Action {
    Release        = 0,
    Press          = 1,
    Repeat         = 2
}

/// Represents an event that can be received by a window, with each variant corresponding to a specific type of event.
#[derive(Debug)]
pub enum Event {
    Key(Key, Action, i32, i32),
    MouseButton(MouseButton, Action, i32),
    MousePosition(f64, f64),
    MouseScroll(f64, f64),
    FramebufferSize(i32, i32),
    WindowClose,
    DragNDrop(Vec<String>)
}

/// Represents a function that handles a window event.
/// Takes a reference to the window and the event, and returns a boolean indicating whether the event was handled successfully.
/// If this function returns false, the event will be passed to the next handler in the chain, or if there are no more handlers, the event will be ignored.
/// If this function returns true, the event will not be passed to any more handlers.
pub type EventFunction = dyn Fn(&Window, &Event) -> bool;

/// Represents a window, with a handle to the underlying CGL window and a flag indicating whether it has been destroyed.
pub struct Window {
    handle: *mut CGL_window,
    has_been_destroyed: bool,
    event_handlers: std::collections::HashMap<String, Box<EventFunction>>
}

const MAX_ACTIVE_WINDOWS: usize = 1024;
static mut ACTIVE_WINDOWS: [*const Window; MAX_ACTIVE_WINDOWS] = [0 as *const Window; MAX_ACTIVE_WINDOWS];

// this is just a temporary hack, will be replaced with a proper solution later
extern "C" fn fn_returning_c_void() -> c_void {
    unsafe { CGL_utils_sleep(1) }
}

fn cgl_window_i32_to_action(action: i32) -> Action {
    match action {
        0 => Action::Release,
        1 => Action::Press,
        2 => Action::Repeat,
        _ => panic!("Invalid action code")
    }
}

fn cgl_window_i32_to_key(key: i32) -> Key {
    match key {
        32 => Key::Space,
        39 => Key::Apostrophe,
        44 => Key::Comma,
        45 => Key::Minus,
        46 => Key::Period,
        47 => Key::Slash,
        48 => Key::K0,
        49 => Key::K1,
        50 => Key::K2,
        51 => Key::K3,
        52 => Key::K4,
        53 => Key::K5,
        54 => Key::K6,
        55 => Key::K7,
        56 => Key::K8,
        57 => Key::K9,
        59 => Key::Semicolon,
        61 => Key::Equal,
        65 => Key::A,
        66 => Key::B,
        67 => Key::C,
        68 => Key::D,
        69 => Key::E,
        70 => Key::F,
        71 => Key::G,
        72 => Key::H,
        73 => Key::I,
        74 => Key::J,
        75 => Key::K,
        76 => Key::L,
        77 => Key::M,
        78 => Key::N,
        79 => Key::O,
        80 => Key::P,
        81 => Key::Q,
        82 => Key::R,
        83 => Key::S,
        84 => Key::T,
        85 => Key::U,
        86 => Key::V,
        87 => Key::W,
        88 => Key::X,
        89 => Key::Y,
        90 => Key::Z,
        91 => Key::LeftBracket,
        92 => Key::Backslash,
        93 => Key::RightBracket,
        96 => Key::GraveAccent,
        256 => Key::Escape,
        257 => Key::Enter,
        258 => Key::Tab,
        259 => Key::Backspace,
        260 => Key::Insert,
        261 => Key::Delete,
        262 => Key::Right,
        263 => Key::Left,
        264 => Key::Down,
        265 => Key::Up,
        266 => Key::PageUp,
        267 => Key::PageDown,
        268 => Key::Home,
        269 => Key::End,
        280 => Key::CapsLock,
        281 => Key::ScrollLock,
        282 => Key::NumLock,
        283 => Key::PrintScreen,
        284 => Key::Pause,
        290 => Key::F1,
        291 => Key::F2,
        292 => Key::F3,
        293 => Key::F4,
        294 => Key::F5,
        295 => Key::F6,
        296 => Key::F7,
        297 => Key::F8,
        298 => Key::F9,
        299 => Key::F10,
        300 => Key::F11,
        301 => Key::F12,
        302 => Key::F13,
        303 => Key::F14,
        304 => Key::F15,
        305 => Key::F16,
        306 => Key::F17,
        307 => Key::F18,
        308 => Key::F19,
        309 => Key::F20,
        310 => Key::F21,
        311 => Key::F22,
        312 => Key::F23,
        313 => Key::F24,
        314 => Key::F25,
        320 => Key::KeyPad0,
        321 => Key::KeyPad1,
        322 => Key::KeyPad2,
        323 => Key::KeyPad3,
        324 => Key::KeyPad4,
        325 => Key::KeyPad5,
        326 => Key::KeyPad6,
        327 => Key::KeyPad7,
        328 => Key::KeyPad8,
        329 => Key::KeyPad9,
        330 => Key::KeyPadDecimal,
        331 => Key::KeyPadDivide,
        332 => Key::KeyPadMultiply,
        333 => Key::KeyPadSubtract,
        334 => Key::KeyPadAdd,
        335 => Key::KeyPadEnter,
        336 => Key::KeyPadEqual,
        340 => Key::LeftShift,
        341 => Key::LeftControl,
        342 => Key::LeftAlt,
        343 => Key::LeftSuper,
        344 => Key::RightShift,
        345 => Key::RightControl,
        346 => Key::RightAlt,
        347 => Key::RightSuper,
        348 => Key::Menu,
        _ => panic!("Invalid key code")
    }
}

fn cgl_window_i32_to_mouse_button(button: i32) -> MouseButton {
    match button {
        0 => MouseButton::Left,
        1 => MouseButton::Right,
        2 => MouseButton::Middle,
        3 => MouseButton::B4,
        4 => MouseButton::B5,
        5 => MouseButton::B6,
        6 => MouseButton::B7,
        7 => MouseButton::B8,
        _ => panic!("Invalid mouse button code")
    }
}

fn cgl_window_dispatch_event(window: *mut CGL_window, event: Event) {
    unsafe {
        let window_id = (window as usize) % MAX_ACTIVE_WINDOWS;
        if ACTIVE_WINDOWS[window_id].is_null() {
            return;
        }
        let window = &*ACTIVE_WINDOWS[window_id];
        for (_, handler) in &window.event_handlers {
            if handler(window, &event) {
                break;
            }
        }
    }    
}

extern "C" fn cgl_window_key_callback(window: *mut CGL_window, key: i32, scancode: i32, action: i32, mods: i32) -> c_void {
    cgl_window_dispatch_event(window, Event::Key(cgl_window_i32_to_key(key), cgl_window_i32_to_action(action), scancode, mods));
    fn_returning_c_void()
}

extern "C" fn cgl_window_mouse_button_callback(window: *mut CGL_window, button: i32, action: i32, mods: i32) -> c_void {
    cgl_window_dispatch_event(window, Event::MouseButton(cgl_window_i32_to_mouse_button(button), cgl_window_i32_to_action(action), mods));
    fn_returning_c_void()
}

extern "C" fn cgl_window_mouse_position_callback(window: *mut CGL_window, xpos: f64, ypos: f64) -> c_void {
    cgl_window_dispatch_event(window, Event::MousePosition(xpos, ypos));
    fn_returning_c_void()
}

extern "C" fn cgl_window_mouse_scroll_callback(window: *mut CGL_window, xoffset: f64, yoffset: f64) -> c_void {
    cgl_window_dispatch_event(window, Event::MouseScroll(xoffset, yoffset));
    fn_returning_c_void()
}

extern "C" fn cgl_window_framebuffer_size_callback(window: *mut CGL_window, width: i32, height: i32) -> c_void {
    cgl_window_dispatch_event(window, Event::FramebufferSize(width, height));
    fn_returning_c_void()
}

extern "C" fn cgl_window_close_callback(window: *mut CGL_window) -> c_void {
    cgl_window_dispatch_event(window, Event::WindowClose);
    fn_returning_c_void()
}

extern "C" fn cgl_window_drag_n_drop_callback(window: *mut CGL_window, paths: *const *const c_char, count: i32) -> c_void {
    let mut paths_vec = Vec::new();
    for i in 0..count {
        unsafe {
            let path = std::ffi::CStr::from_ptr(*paths.offset(i as isize)).to_str().unwrap();
            paths_vec.push(path.to_string());
        }
    }
    cgl_window_dispatch_event(window, Event::DragNDrop(paths_vec));
    fn_returning_c_void()
}

impl Window {
    /// Creates a new window with the given title, width, and height.
    ///
    /// # Arguments
    ///
    /// * `title` - The title of the window.
    /// * `width` - The width of the window.
    /// * `height` - The height of the window.
    ///
    /// # Returns
    ///
    /// Returns a `Result` containing the created `Window` if successful, or an error message if the window creation failed.
    ///
    /// # Panics
    ///
    /// Panics if the width or height is not positive.
    ///
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    /// window.destroy(); // we must destroy the window before shutting down
    /// cgl_rs::shutdown();
    /// ```
    pub fn new(title: &str, width: i32, height: i32) -> Result<Window, &'static str> {
        assert!(width > 0 && height > 0, "Window dimensions must be positive");
        let title = std::ffi::CString::new(title).unwrap();
        let handle = unsafe {
            let created_window = CGL_window_create(width, height, title.as_ptr());
            created_window
        };
        if handle.is_null() {
            Err("Failed to create window")
        } else {
            unsafe { CGL_window_make_context_current(handle); }
            Ok(Window {
                handle: handle,
                has_been_destroyed: false,
                event_handlers: std::collections::HashMap::new()
            })
        }
    }

    /// Creates a new undecorated window with the given title, width, and height.
    ///
    /// An undecorated window is a window without any borders or title bar.
    ///
    /// # Arguments
    ///
    /// * `title` - The title of the window.
    /// * `width` - The width of the window.
    /// * `height` - The height of the window.
    ///
    /// # Returns
    ///
    /// Returns a `Result` containing the created `Window` if successful, or an error message if the window creation failed.
    ///
    /// # Panics
    ///
    /// Panics if the width or height is not positive.
    ///
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     let mut window = cgl_rs::Window::new_undecorated("My Window", 800, 600).unwrap();
    ///     // window.destroy(); // optional
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn new_undecorated(title: &str, width: i32, height: i32) -> Result<Window, &'static str> {
        assert!(width > 0 && height > 0, "Window dimensions must be positive");
        let title = std::ffi::CString::new(title).unwrap();
        let handle = unsafe {
            let created_window = CGL_window_create_undecorated(width, height, title.as_ptr());
            created_window
        };
        if handle.is_null() {
            Err("Failed to create window")
        } else {
            unsafe { CGL_window_make_context_current(handle); }
            Ok(Window {
                handle: handle,
                has_been_destroyed: false,
                event_handlers: std::collections::HashMap::new()
            })
        }
    }

    /// Destroys the window, freeing any resources associated with it.
    ///
    /// NOTE: This is called automatically when the `Window` goes out of scope, so it is not necessary to call this manually.
    ///       However, it is safe to call this multiple times, and the subsequent calls will have no effect.
    ///       But one thing to be noted is that this function must be called before `cgl_rs::shutdown()` is called.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     window.destroy(); // optional
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn destroy(&mut self) {
        if !self.has_been_destroyed {
            unsafe {
                CGL_window_destroy(self.handle);
                ACTIVE_WINDOWS[(self.handle as usize) % MAX_ACTIVE_WINDOWS] = 0 as *const Window;
                self.has_been_destroyed = true;
            }
        }
    }


    /// Registers the window to receive events by setting the appropriate callbacks.
    ///
    /// This function should be called after creating the window and before entering the event loop.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     window.register_for_events();
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn register_for_events(&self) {
        unsafe {
            let window_id = (self.handle as usize) % MAX_ACTIVE_WINDOWS;
            ACTIVE_WINDOWS[window_id] = self as *const Window;
            CGL_window_set_key_callback(self.handle, cgl_window_key_callback);
            CGL_window_set_mouse_button_callback(self.handle, cgl_window_mouse_button_callback);
            CGL_window_set_mouse_position_callback(self.handle, cgl_window_mouse_position_callback);
            CGL_window_set_mouse_scroll_callback(self.handle, cgl_window_mouse_scroll_callback);
            CGL_window_set_framebuffer_size_callback(self.handle, cgl_window_framebuffer_size_callback);
            CGL_window_set_close_callback(self.handle, cgl_window_close_callback);
            CGL_window_set_drag_n_drop_callback(self.handle, cgl_window_drag_n_drop_callback);   
        }
    }


    /// Attaches an named event handler to the window.
    ///
    /// The `name` parameter is a string that identifies the event handler. This can be any string that is unique to the event handler.
    ///
    /// The `handler` parameter is a reference to a function that will be called when the event occurs. The function must have the following signature:
    ///
    /// ```no_run
    /// fn my_event_handler(window: &cgl_rs::Window, event: &cgl_rs::Event) {
    ///     println!("Event occurred!");
    /// }
    ///
    /// ```
    /// # Example
    ///
    /// ```no_run
    /// cgl_rs::init();
    /// {
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///
    ///     // window.attach_event_handler("my_event", &my_event_handler);
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn attach_event_handler(&mut self, name: &str, handler: &'static EventFunction) {
        self.event_handlers.insert(name.to_string(), Box::new(handler));
    }


    /// Detaches a named event handler from the window.
    ///
    /// The `name` parameter is a string that identifies the event handler. This should be the same string that was used to attach the event handler.
    ///
    /// # Example
    ///
    /// ```no_run
    /// cgl_rs::init();
    /// {
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     
    ///     window.detach_event_handler("my_event");
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn detach_event_handler(&mut self, name: &str) {
        self.event_handlers.remove(name);
    }

    /// Polls for events on the window.
    ///
    /// This function should be called in a loop to continuously poll for events on the window.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///
    ///     while true {
    ///         window.poll_events();
    ///         // Handle events here
    ///         // ...
    ///         break; // break out of the loop for testing purposes
    ///     }
    ///
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn poll_events(&self) {
        unsafe {
            CGL_window_poll_events(self.handle);
        }
    }

    /// Swaps the front and back buffers of the window.
    ///
    /// This function should be called after rendering to the back buffer to display the rendered image on the screen.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///
    ///     while true {
    ///         window.swap_buffers();
    ///         // Handle events here
    ///         // ...
    ///         break; // break out of the loop for testing purposes
    ///     }
    ///
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn swap_buffers(&self) {
        unsafe {
            CGL_window_swap_buffers(self.handle);
        }
    }

    /// Returns whether or not the window should be closed.
    ///
    /// This function should be called in a loop to continuously check if the window should be closed.
    ///
    /// # Returns
    ///
    /// A boolean value indicating whether or not the window should be closed.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///
    ///     while !window.should_close() {
    ///         // ...
    ///         break; // break out of the loop for testing purposes
    ///     }
    ///
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn should_close(&self) -> bool {
        unsafe {
            CGL_window_should_close(self.handle) != 0
        } 
    }

    /// Sets the title of the window.
    ///
    /// # Arguments
    ///
    /// * `title` - A string slice containing the new title of the window.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     window.set_title("New Title");
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_title(&self, title: &str) {
        let title = std::ffi::CString::new(title).unwrap();
        unsafe {
            CGL_window_set_title(self.handle, title.as_ptr());
        }
    }
    
    /// Sets the size of the window.
    ///
    /// # Arguments
    ///
    /// * `width` - The new width of the window.
    /// * `height` - The new height of the window.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     window.set_size(1024, 768);
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_size(&self, width: i32, height: i32) {
        unsafe {
            CGL_window_set_size(self.handle, width, height);
        }
    }

    /// Sets the position of the window.
    ///
    /// # Arguments
    ///
    /// * `x` - The new x position of the window.
    /// * `y` - The new y position of the window.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     window.set_position(100, 100);
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_position(&self, x: i32, y: i32) {
        unsafe {
            CGL_window_set_position(self.handle, x, y);
        }
    }

    /// Sets the visibility of the window.
    ///
    /// # Arguments
    ///
    /// * `hidden` - A boolean indicating whether the window should be hidden or not.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     window.set_hidden(true);
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_hidden(&mut self, hidden: bool) {
        unsafe {
            CGL_window_set_hidden(self.handle, hidden as i32);
        }
    }

    /// Sets the user data associated with the window.
    ///
    /// # Arguments
    ///
    /// * `user_data` - A pointer to the user data to associate with the window.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     let user_data = Box::into_raw(Box::new(42));
    ///     window.set_user_data(user_data);
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_user_data<T>(&self, user_data: *mut T) {
        unsafe {
            CGL_window_set_user_data(self.handle, user_data as *mut c_void);
        }
    }

    /// Gets the user data associated with the window.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     let user_data = Box::into_raw(Box::new(42));
    ///     window.set_user_data(user_data);
    ///     let retrieved_user_data = window.get_user_data();
    ///     assert_eq!(retrieved_user_data, user_data);
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn get_user_data<T>(&self) -> *mut T {
        unsafe {
            CGL_window_get_user_data(self.handle) as *mut T
        }
    }

    /// Gets the size of the window.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     let (width, height) = window.get_size();
    ///     assert_eq!(width, 800);
    ///     assert_eq!(height, 600);
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn get_size(&self) -> (i32, i32) {
        unsafe {
            let (mut width, mut height) = (0, 0);
            CGL_window_get_size(self.handle, &mut width, &mut height);
            (width, height)
        }
    }

    // Gets the position of the window.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     let (x, y) = window.get_position();
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn get_position(&self) -> (i32, i32) {
        unsafe {
            let (mut x, mut y) = (0, 0);
            CGL_window_get_position(self.handle, &mut x, &mut y);
            (x, y)
        }
    }

    // Gets the size of the framebuffer of the window.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     let (width, height) = window.get_framebuffer_size();
    ///     assert_eq!(width, 800);
    ///     assert_eq!(height, 600);
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn get_framebuffer_size(&self) -> (i32, i32) {
        unsafe {
            let (mut width, mut height) = (0, 0);
            CGL_window_get_framebuffer_size(self.handle, &mut width, &mut height);
            (width, height)
        }
    }

    /// Rescues the callbacks of the window.
    /// This is usefule whn usiong cgl::window along with any third party library
    /// that internally uses glfw with cgl::window.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     window.rescure_callbacks();
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn rescure_callbacks(&self) {
        unsafe {
            CGL_window_resecure_callbacks(self.handle);
        }
    }


    /// Makes the OpenGL context of the window current.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     window.make_context_current();
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn make_context_current(&self) {
        unsafe {
            CGL_window_make_context_current(self.handle);
        }
    }

    // Gets the GLFW handle of the window.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     let handle = window.get_glfw_handle();
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn get_glfw_handle(&self) -> *mut GLFWwindow {
        unsafe {
            CGL_window_get_glfw_handle(self.handle)
        }
    }

    // Gets the state of a keyboard key of the window.
    ///
    /// # Arguments
    ///
    /// * `key` - A `Key` enum value representing the key to get the state of.
    ///
    /// # Returns
    ///
    /// An `Action` enum value representing the state of the key.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     let action = window.get_key(cgl_rs::Key::A);
    ///     match action {
    ///         cgl_rs::Action::Release => println!("Key A was released"),
    ///         cgl_rs::Action::Press => println!("Key A was pressed"),
    ///         cgl_rs::Action::Repeat => println!("Key A was repeated"),
    ///     }
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn get_key(&self, key: Key) -> Action {
        unsafe {
            cgl_window_i32_to_action(CGL_window_get_key(self.handle, key as i32))
        }
    }

    /// Checks if a keyboard key of the window is pressed.
    /// 
    /// # Arguments
    /// 
    /// * `key` - A `Key` enum value representing the key to check.
    /// 
    /// # Returns
    /// 
    /// A `bool` value representing if the key is pressed.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     if window.is_key_pressed(cgl_rs::Key::A) {
    ///         println!("Key A is pressed");
    ///     }
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn is_key_pressed(&self, key: Key) -> bool {
        unsafe {
            CGL_window_is_key_pressed(self.handle, key as i32) == 1
        }
    }

    /// Gets the state of a mouse button of the window.
    /// 
    /// # Arguments
    ///
    /// * `button` - A `MouseButton` enum value representing the mouse button to get the state of.
    /// 
    /// # Returns
    /// 
    /// An `Action` enum value representing the state of the mouse button.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     let action = window.get_mouse_button(cgl_rs::MouseButton::Left);
    ///     match action {
    ///        cgl_rs::Action::Release => println!("Left mouse button was released"),
    ///        cgl_rs::Action::Press => println!("Left mouse button was pressed"),
    ///        cgl_rs::Action::Repeat => println!("Left mouse button was repeated"),
    ///     }
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn get_mouse_button(&self, button: MouseButton) -> Action {
        unsafe {
            cgl_window_i32_to_action(CGL_window_get_mouse_button(self.handle, button as i32))               
        }
    }

    /// Checks if a mouse button of the window is pressed.
    /// 
    /// # Arguments
    ///
    /// * `button` - A `MouseButton` enum value representing the mouse button to check.
    /// 
    /// # Returns
    /// 
    /// A `bool` value representing if the mouse button is pressed.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     if window.is_mouse_button_pressed(cgl_rs::MouseButton::Left) {
    ///         println!("Left mouse button is pressed");
    ///     }
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn is_mouse_button_pressed(&self, button: MouseButton) -> bool {
        match self.get_mouse_button(button) {
            Action::Press => true,
            _ => false
        }
    }

    /// Gets the position of the mouse cursor relative to the top-left corner of the window.
    /// 
    /// # Returns
    /// 
    /// A tuple containing the x and y coordinates of the mouse cursor.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     let (x, y) = window.get_mouse_position();
    ///     println!("Mouse position: ({}, {})", x, y);
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn get_mouse_position(&self) -> (f64, f64) {
        unsafe {
            let (mut x, mut y) = (0.0, 0.0);
            CGL_window_get_mouse_position(self.handle, &mut x, &mut y);
            (x, y)
        }
    }

    /// Gets the internal handle of the window.
    /// 
    /// # Returns
    /// 
    /// A pointer to the internal handle of the window.
    pub(crate) fn get_cgl_handle(&self) -> *mut CGL_window {
        self.handle
    }

}

impl Drop for Window {
    fn drop(&mut self) {
        self.destroy();
    }
}

impl Clone for Window {
    /// Clones the current window instance.
    /// 
    /// NOTE: The new instance will have the same handle, `has_been_destroyed` flag and empty `event_handlers` map.
    ///       This means that the new instance will not be able to receive events nor will the internal window handle be
    ///       destroyed when the new instance is dropped. The internal window handle will be destroyed when the original
    ///       instance is dropped.
    /// 
    /// # Returns
    /// 
    /// A new `Window` instance with the same handle, `has_been_destroyed` flag and empty `event_handlers` map.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     let mut window_clone = window.clone();
    /// }
    /// cgl_rs::shutdown();
    fn clone(&self) -> Self {
        Window {
            handle: self.handle,
            has_been_destroyed: true,
            event_handlers: std::collections::HashMap::new()
        }
    }
}
```

`rust_wrapper/cgl-rs/src/window_manager.rs`:

```rs
//! The window manager module is responsible for creating and managing windows. It is also responsible for handling input events and passing them to the appropriate window.

#![allow(non_camel_case_types)]
use libc::{c_void, c_int, c_char, c_double};

/// The internal window handle used by CGL
#[repr(C)]
struct CGL_window {
    _private: c_void
}

/// The internal window handle used by GLFW
#[repr(C)]
pub struct GLFWwindow {
    _private: c_void
}

type CGL_window_key_callback = extern "C" fn(window: *mut CGL_window, key: c_int, scancode: c_int, action: c_int, mods: c_int) -> c_void;
type CGL_window_mouse_button_callback = extern "C" fn(window: *mut CGL_window, button: c_int, action: c_int, mods: c_int) -> c_void;
type CGL_window_mouse_position_callback = extern "C" fn(window: *mut CGL_window, x: c_double, y: c_double) -> c_void;
type CGL_window_mouse_scroll_callback = extern "C" fn(window: *mut CGL_window, x: c_double, y: c_double) -> c_void;
type CGL_window_framebuffer_size_callback = extern "C" fn(window: *mut CGL_window, width: c_int, height: c_int) -> c_void;
type CGL_window_close_callback = extern "C" fn(window: *mut CGL_window) -> c_void;
type CGL_window_drag_n_drop_callback = extern "C" fn(window: *mut CGL_window, paths: *const *const c_char, count: c_int) -> c_void;




extern {
    fn CGL_window_create(width: c_int, height: c_int, title: *const c_char) -> *mut CGL_window;
    fn CGL_window_create_undecorated(width: c_int, height: c_int, title: *const c_char) -> *mut CGL_window;
    fn CGL_window_destroy(window: *mut CGL_window) -> c_void;
    fn CGL_window_poll_events(window: *mut CGL_window) -> c_void;
    fn CGL_window_swap_buffers(window: *mut CGL_window) -> c_void;
    fn CGL_window_should_close(window: *mut CGL_window) -> c_int;
    fn CGL_window_set_title(window: *mut CGL_window, title: *const c_char) -> c_void;
    fn CGL_window_set_size(window: *mut CGL_window, width: c_int, height: c_int) -> c_void;
    fn CGL_window_set_position(window: *mut CGL_window, x: c_int, y: c_int) -> c_void;
    fn CGL_window_set_hidden(window: *mut CGL_window, hidden: c_int) -> c_void;
    fn CGL_window_set_user_data(window: *mut CGL_window, user_data: *mut c_void) -> c_void;
    fn CGL_window_get_user_data(window: *mut CGL_window) -> *mut c_void;
    fn CGL_window_get_size(window: *mut CGL_window, width: *mut c_int, height: *mut c_int) -> c_void;
    fn CGL_window_get_position(window: *mut CGL_window, x: *mut c_int, y: *mut c_int) -> c_void;
    fn CGL_window_get_framebuffer_size(window: *mut CGL_window, width: *mut c_int, height: *mut c_int) -> c_void;
    
    fn CGL_window_set_key_callback(window: *mut CGL_window, callback: CGL_window_key_callback) -> c_void;
    fn CGL_window_set_mouse_button_callback(window: *mut CGL_window, callback: CGL_window_mouse_button_callback) -> c_void;
    fn CGL_window_set_mouse_position_callback(window: *mut CGL_window, callback: CGL_window_mouse_position_callback) -> c_void;
    fn CGL_window_set_mouse_scroll_callback(window: *mut CGL_window, callback: CGL_window_mouse_scroll_callback) -> c_void;
    fn CGL_window_set_framebuffer_size_callback(window: *mut CGL_window, callback: CGL_window_framebuffer_size_callback) -> c_void;
    fn CGL_window_set_close_callback(window: *mut CGL_window, callback: CGL_window_close_callback) -> c_void;
    fn CGL_window_set_drag_n_drop_callback(window: *mut CGL_window, callback: CGL_window_drag_n_drop_callback) -> c_void;

    fn CGL_window_resecure_callbacks(window: *mut CGL_window) -> c_void;
    fn CGL_window_make_context_current(window: *mut CGL_window) -> c_void;
    fn CGL_window_get_glfw_handle(window: *mut CGL_window) -> *mut GLFWwindow;

    fn CGL_window_get_key(window: *mut CGL_window, key: c_int) -> c_int;
    fn CGL_window_is_key_pressed(window: *mut CGL_window, key: c_int) -> c_int;
    fn CGL_window_get_mouse_button(window: *mut CGL_window, button: c_int) -> c_int;
    fn CGL_window_get_mouse_position(window: *mut CGL_window, x: *mut c_double, y: *mut c_double) -> c_void;

    fn CGL_utils_sleep(duration: usize) -> c_void; // temporary
}


/// Represents a keyboard key, with each variant corresponding to a specific key code.
#[repr(C)] #[derive(Debug)]
pub enum Key {
    Unknown            = -1,
    Space              = 32,
    Apostrophe         = 39,
    Comma              = 44,
    Minus              = 45,
    Period             = 46,
    Slash              = 47,
    K0                 = 48,
    K1                 = 49,
    K2                 = 50,
    K3                 = 51,
    K4                 = 52,
    K5                 = 53,
    K6                 = 54,
    K7                 = 55,
    K8                 = 56,
    K9                 = 57,
    Semicolon          = 59,
    Equal              = 61,
    A                  = 65,
    B                  = 66,
    C                  = 67,
    D                  = 68,
    E                  = 69,
    F                  = 70,
    G                  = 71,
    H                  = 72,
    I                  = 73,
    J                  = 74,
    K                  = 75,
    L                  = 76,
    M                  = 77,
    N                  = 78,
    O                  = 79,
    P                  = 80,
    Q                  = 81,
    R                  = 82,
    S                  = 83,
    T                  = 84,
    U                  = 85,
    V                  = 86,
    W                  = 87,
    X                  = 88,
    Y                  = 89,
    Z                  = 90,
    LeftBracket        = 91,
    Backslash          = 92,
    RightBracket       = 93,
    GraveAccent        = 96,
    Escape             = 256,
    Enter              = 257,
    Tab                = 258,
    Backspace          = 259,
    Insert             = 260,
    Delete             = 261,
    Right              = 262,
    Left               = 263,
    Down               = 264,
    Up                 = 265,
    PageUp             = 266,
    PageDown           = 267,
    Home               = 268,
    End                = 269,
    CapsLock           = 280,
    ScrollLock         = 281,
    NumLock            = 282,
    PrintScreen        = 283,
    Pause              = 284,
    F1                 = 290,
    F2                 = 291,
    F3                 = 292,
    F4                 = 293,
    F5                 = 294,
    F6                 = 295,
    F7                 = 296,
    F8                 = 297,
    F9                 = 298,
    F10                = 299,
    F11                = 300,
    F12                = 301,
    F13                = 302,
    F14                = 303,
    F15                = 304,
    F16                = 305,
    F17                = 306,
    F18                = 307,
    F19                = 308,
    F20                = 309,
    F21                = 310,
    F22                = 311,
    F23                = 312,
    F24                = 313,
    F25                = 314,
    KeyPad0            = 320,
    KeyPad1            = 321,
    KeyPad2            = 322,
    KeyPad3            = 323,
    KeyPad4            = 324,
    KeyPad5            = 325,
    KeyPad6            = 326,
    KeyPad7            = 327,
    KeyPad8            = 328,
    KeyPad9            = 329,
    KeyPadDecimal      = 330,
    KeyPadDivide       = 331,
    KeyPadMultiply     = 332,
    KeyPadSubtract     = 333,
    KeyPadAdd          = 334,
    KeyPadEnter        = 335,
    KeyPadEqual        = 336,
    LeftShift          = 340,
    LeftControl        = 341,
    LeftAlt            = 342,
    LeftSuper          = 343,
    RightShift         = 344,
    RightControl       = 345,
    RightAlt           = 346,
    RightSuper         = 347,
    Menu               = 348
}

/// Represents a mouse button, with each variant corresponding to a specific button code.
#[derive(Debug)]
pub enum MouseButton {
    Left       = 0,
    Right      = 1,
    Middle     = 2,
    B4         = 3,
    B5         = 4,
    B6         = 5,
    B7         = 6,
    B8         = 7,
    Last       = 8
}

/// Represents an action, with each variant corresponding to a specific action code.
#[derive(Debug)]
pub enum Action {
    Release        = 0,
    Press          = 1,
    Repeat         = 2
}

/// Represents an event that can be received by a window, with each variant corresponding to a specific type of event.
#[derive(Debug)]
pub enum Event {
    Key(Key, Action, i32, i32),
    MouseButton(MouseButton, Action, i32),
    MousePosition(f64, f64),
    MouseScroll(f64, f64),
    FramebufferSize(i32, i32),
    WindowClose,
    DragNDrop(Vec<String>)
}

/// Represents a function that handles a window event.
/// Takes a reference to the window and the event, and returns a boolean indicating whether the event was handled successfully.
/// If this function returns false, the event will be passed to the next handler in the chain, or if there are no more handlers, the event will be ignored.
/// If this function returns true, the event will not be passed to any more handlers.
pub type EventFunction = dyn Fn(&Window, &Event) -> bool;

/// Represents a window, with a handle to the underlying CGL window and a flag indicating whether it has been destroyed.
pub struct Window {
    handle: *mut CGL_window,
    has_been_destroyed: bool,
    event_handlers: std::collections::HashMap<String, Box<EventFunction>>
}

const MAX_ACTIVE_WINDOWS: usize = 1024;
static mut ACTIVE_WINDOWS: [*const Window; MAX_ACTIVE_WINDOWS] = [0 as *const Window; MAX_ACTIVE_WINDOWS];

// this is just a temporary hack, will be replaced with a proper solution later
extern "C" fn fn_returning_c_void() -> c_void {
    unsafe { CGL_utils_sleep(1) }
}

fn cgl_window_i32_to_action(action: i32) -> Action {
    match action {
        0 => Action::Release,
        1 => Action::Press,
        2 => Action::Repeat,
        _ => panic!("Invalid action code")
    }
}

fn cgl_window_i32_to_key(key: i32) -> Key {
    match key {
        32 => Key::Space,
        39 => Key::Apostrophe,
        44 => Key::Comma,
        45 => Key::Minus,
        46 => Key::Period,
        47 => Key::Slash,
        48 => Key::K0,
        49 => Key::K1,
        50 => Key::K2,
        51 => Key::K3,
        52 => Key::K4,
        53 => Key::K5,
        54 => Key::K6,
        55 => Key::K7,
        56 => Key::K8,
        57 => Key::K9,
        59 => Key::Semicolon,
        61 => Key::Equal,
        65 => Key::A,
        66 => Key::B,
        67 => Key::C,
        68 => Key::D,
        69 => Key::E,
        70 => Key::F,
        71 => Key::G,
        72 => Key::H,
        73 => Key::I,
        74 => Key::J,
        75 => Key::K,
        76 => Key::L,
        77 => Key::M,
        78 => Key::N,
        79 => Key::O,
        80 => Key::P,
        81 => Key::Q,
        82 => Key::R,
        83 => Key::S,
        84 => Key::T,
        85 => Key::U,
        86 => Key::V,
        87 => Key::W,
        88 => Key::X,
        89 => Key::Y,
        90 => Key::Z,
        91 => Key::LeftBracket,
        92 => Key::Backslash,
        93 => Key::RightBracket,
        96 => Key::GraveAccent,
        256 => Key::Escape,
        257 => Key::Enter,
        258 => Key::Tab,
        259 => Key::Backspace,
        260 => Key::Insert,
        261 => Key::Delete,
        262 => Key::Right,
        263 => Key::Left,
        264 => Key::Down,
        265 => Key::Up,
        266 => Key::PageUp,
        267 => Key::PageDown,
        268 => Key::Home,
        269 => Key::End,
        280 => Key::CapsLock,
        281 => Key::ScrollLock,
        282 => Key::NumLock,
        283 => Key::PrintScreen,
        284 => Key::Pause,
        290 => Key::F1,
        291 => Key::F2,
        292 => Key::F3,
        293 => Key::F4,
        294 => Key::F5,
        295 => Key::F6,
        296 => Key::F7,
        297 => Key::F8,
        298 => Key::F9,
        299 => Key::F10,
        300 => Key::F11,
        301 => Key::F12,
        302 => Key::F13,
        303 => Key::F14,
        304 => Key::F15,
        305 => Key::F16,
        306 => Key::F17,
        307 => Key::F18,
        308 => Key::F19,
        309 => Key::F20,
        310 => Key::F21,
        311 => Key::F22,
        312 => Key::F23,
        313 => Key::F24,
        314 => Key::F25,
        320 => Key::KeyPad0,
        321 => Key::KeyPad1,
        322 => Key::KeyPad2,
        323 => Key::KeyPad3,
        324 => Key::KeyPad4,
        325 => Key::KeyPad5,
        326 => Key::KeyPad6,
        327 => Key::KeyPad7,
        328 => Key::KeyPad8,
        329 => Key::KeyPad9,
        330 => Key::KeyPadDecimal,
        331 => Key::KeyPadDivide,
        332 => Key::KeyPadMultiply,
        333 => Key::KeyPadSubtract,
        334 => Key::KeyPadAdd,
        335 => Key::KeyPadEnter,
        336 => Key::KeyPadEqual,
        340 => Key::LeftShift,
        341 => Key::LeftControl,
        342 => Key::LeftAlt,
        343 => Key::LeftSuper,
        344 => Key::RightShift,
        345 => Key::RightControl,
        346 => Key::RightAlt,
        347 => Key::RightSuper,
        348 => Key::Menu,
        _ => panic!("Invalid key code")
    }
}

fn cgl_window_i32_to_mouse_button(button: i32) -> MouseButton {
    match button {
        0 => MouseButton::Left,
        1 => MouseButton::Right,
        2 => MouseButton::Middle,
        3 => MouseButton::B4,
        4 => MouseButton::B5,
        5 => MouseButton::B6,
        6 => MouseButton::B7,
        7 => MouseButton::B8,
        _ => panic!("Invalid mouse button code")
    }
}

fn cgl_window_dispatch_event(window: *mut CGL_window, event: Event) {
    unsafe {
        let window_id = (window as usize) % MAX_ACTIVE_WINDOWS;
        if ACTIVE_WINDOWS[window_id].is_null() {
            return;
        }
        let window = &*ACTIVE_WINDOWS[window_id];
        for (_, handler) in &window.event_handlers {
            if handler(window, &event) {
                break;
            }
        }
    }    
}

extern "C" fn cgl_window_key_callback(window: *mut CGL_window, key: i32, scancode: i32, action: i32, mods: i32) -> c_void {
    cgl_window_dispatch_event(window, Event::Key(cgl_window_i32_to_key(key), cgl_window_i32_to_action(action), scancode, mods));
    fn_returning_c_void()
}

extern "C" fn cgl_window_mouse_button_callback(window: *mut CGL_window, button: i32, action: i32, mods: i32) -> c_void {
    cgl_window_dispatch_event(window, Event::MouseButton(cgl_window_i32_to_mouse_button(button), cgl_window_i32_to_action(action), mods));
    fn_returning_c_void()
}

extern "C" fn cgl_window_mouse_position_callback(window: *mut CGL_window, xpos: f64, ypos: f64) -> c_void {
    cgl_window_dispatch_event(window, Event::MousePosition(xpos, ypos));
    fn_returning_c_void()
}

extern "C" fn cgl_window_mouse_scroll_callback(window: *mut CGL_window, xoffset: f64, yoffset: f64) -> c_void {
    cgl_window_dispatch_event(window, Event::MouseScroll(xoffset, yoffset));
    fn_returning_c_void()
}

extern "C" fn cgl_window_framebuffer_size_callback(window: *mut CGL_window, width: i32, height: i32) -> c_void {
    cgl_window_dispatch_event(window, Event::FramebufferSize(width, height));
    fn_returning_c_void()
}

extern "C" fn cgl_window_close_callback(window: *mut CGL_window) -> c_void {
    cgl_window_dispatch_event(window, Event::WindowClose);
    fn_returning_c_void()
}

extern "C" fn cgl_window_drag_n_drop_callback(window: *mut CGL_window, paths: *const *const c_char, count: i32) -> c_void {
    let mut paths_vec = Vec::new();
    for i in 0..count {
        unsafe {
            let path = std::ffi::CStr::from_ptr(*paths.offset(i as isize)).to_str().unwrap();
            paths_vec.push(path.to_string());
        }
    }
    cgl_window_dispatch_event(window, Event::DragNDrop(paths_vec));
    fn_returning_c_void()
}

impl Window {
    /// Creates a new window with the given title, width, and height.
    ///
    /// # Arguments
    ///
    /// * `title` - The title of the window.
    /// * `width` - The width of the window.
    /// * `height` - The height of the window.
    ///
    /// # Returns
    ///
    /// Returns a `Result` containing the created `Window` if successful, or an error message if the window creation failed.
    ///
    /// # Panics
    ///
    /// Panics if the width or height is not positive.
    ///
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    /// window.destroy(); // we must destroy the window before shutting down
    /// cgl_rs::shutdown();
    /// ```
    pub fn new(title: &str, width: i32, height: i32) -> Result<Window, &'static str> {
        assert!(width > 0 && height > 0, "Window dimensions must be positive");
        let title = std::ffi::CString::new(title).unwrap();
        let handle = unsafe {
            let created_window = CGL_window_create(width, height, title.as_ptr());
            created_window
        };
        if handle.is_null() {
            Err("Failed to create window")
        } else {
            Ok(Window {
                handle: handle,
                has_been_destroyed: false,
                event_handlers: std::collections::HashMap::new()
            })
        }
    }

    /// Creates a new undecorated window with the given title, width, and height.
    ///
    /// An undecorated window is a window without any borders or title bar.
    ///
    /// # Arguments
    ///
    /// * `title` - The title of the window.
    /// * `width` - The width of the window.
    /// * `height` - The height of the window.
    ///
    /// # Returns
    ///
    /// Returns a `Result` containing the created `Window` if successful, or an error message if the window creation failed.
    ///
    /// # Panics
    ///
    /// Panics if the width or height is not positive.
    ///
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     let mut window = cgl_rs::Window::new_undecorated("My Window", 800, 600).unwrap();
    ///     // window.destroy(); // optional
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn new_undecorated(title: &str, width: i32, height: i32) -> Result<Window, &'static str> {
        assert!(width > 0 && height > 0, "Window dimensions must be positive");
        let title = std::ffi::CString::new(title).unwrap();
        let handle = unsafe {
            let created_window = CGL_window_create_undecorated(width, height, title.as_ptr());
            created_window
        };
        if handle.is_null() {
            Err("Failed to create window")
        } else {
            Ok(Window {
                handle: handle,
                has_been_destroyed: false,
                event_handlers: std::collections::HashMap::new()
            })
        }
    }

    /// Destroys the window, freeing any resources associated with it.
    ///
    /// NOTE: This is called automatically when the `Window` goes out of scope, so it is not necessary to call this manually.
    ///       However, it is safe to call this multiple times, and the subsequent calls will have no effect.
    ///       But one thing to be noted is that this function must be called before `cgl_rs::shutdown()` is called.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     window.destroy(); // optional
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn destroy(&mut self) {
        if !self.has_been_destroyed {
            unsafe {
                CGL_window_destroy(self.handle);
                ACTIVE_WINDOWS[(self.handle as usize) % MAX_ACTIVE_WINDOWS] = 0 as *const Window;
                self.has_been_destroyed = true;
            }
        }
    }


    /// Registers the window to receive events by setting the appropriate callbacks.
    ///
    /// This function should be called after creating the window and before entering the event loop.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     window.register_for_events();
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn register_for_events(&self) {
        unsafe {
            let window_id = (self.handle as usize) % MAX_ACTIVE_WINDOWS;
            ACTIVE_WINDOWS[window_id] = self as *const Window;
            CGL_window_set_key_callback(self.handle, cgl_window_key_callback);
            CGL_window_set_mouse_button_callback(self.handle, cgl_window_mouse_button_callback);
            CGL_window_set_mouse_position_callback(self.handle, cgl_window_mouse_position_callback);
            CGL_window_set_mouse_scroll_callback(self.handle, cgl_window_mouse_scroll_callback);
            CGL_window_set_framebuffer_size_callback(self.handle, cgl_window_framebuffer_size_callback);
            CGL_window_set_close_callback(self.handle, cgl_window_close_callback);
            CGL_window_set_drag_n_drop_callback(self.handle, cgl_window_drag_n_drop_callback);   
        }
    }


    /// Attaches an named event handler to the window.
    ///
    /// The `name` parameter is a string that identifies the event handler. This can be any string that is unique to the event handler.
    ///
    /// The `handler` parameter is a reference to a function that will be called when the event occurs. The function must have the following signature:
    ///
    /// ```norun
    /// fn my_event_handler(window: &Window, event: &Event) {
    ///     println!("Event occurred!");
    /// }
    /// ```
    ///
    /// # Example
    ///
    /// ```norun
    /// cgl_rs::init();
    /// {
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///
    ///     window.attach_event_handler("my_event", &my_event_handler);
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn attach_event_handler(&mut self, name: &str, handler: &'static EventFunction) {
        self.event_handlers.insert(name.to_string(), Box::new(handler));
    }


    /// Detaches a named event handler from the window.
    ///
    /// The `name` parameter is a string that identifies the event handler. This should be the same string that was used to attach the event handler.
    ///
    /// # Example
    ///
    /// ```norun
    /// cgl_rs::init();
    /// {
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     
    ///     window.detach_event_handler("my_event");
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn detach_event_handler(&mut self, name: &str) {
        self.event_handlers.remove(name);
    }

    /// Polls for events on the window.
    ///
    /// This function should be called in a loop to continuously poll for events on the window.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///
    ///     while true {
    ///         window.poll_events();
    ///         // Handle events here
    ///         // ...
    ///         break; // break out of the loop for testing purposes
    ///     }
    ///
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn poll_events(&self) {
        unsafe {
            CGL_window_poll_events(self.handle);
        }
    }

    /// Swaps the front and back buffers of the window.
    ///
    /// This function should be called after rendering to the back buffer to display the rendered image on the screen.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///
    ///     while true {
    ///         window.swap_buffers();
    ///         // Handle events here
    ///         // ...
    ///         break; // break out of the loop for testing purposes
    ///     }
    ///
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn swap_buffers(&self) {
        unsafe {
            CGL_window_swap_buffers(self.handle);
        }
    }

    /// Returns whether or not the window should be closed.
    ///
    /// This function should be called in a loop to continuously check if the window should be closed.
    ///
    /// # Returns
    ///
    /// A boolean value indicating whether or not the window should be closed.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///
    ///     while !window.should_close() {
    ///         // ...
    ///         break; // break out of the loop for testing purposes
    ///     }
    ///
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn should_close(&self) -> bool {
        unsafe {
            CGL_window_should_close(self.handle) != 0
        } 
    }

    /// Sets the title of the window.
    ///
    /// # Arguments
    ///
    /// * `title` - A string slice containing the new title of the window.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     window.set_title("New Title");
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_title(&mut self, title: &str) {
        let title = std::ffi::CString::new(title).unwrap();
        unsafe {
            CGL_window_set_title(self.handle, title.as_ptr());
        }
    }
    
    /// Sets the size of the window.
    ///
    /// # Arguments
    ///
    /// * `width` - The new width of the window.
    /// * `height` - The new height of the window.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     window.set_size(1024, 768);
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_size(&mut self, width: i32, height: i32) {
        unsafe {
            CGL_window_set_size(self.handle, width, height);
        }
    }

    /// Sets the position of the window.
    ///
    /// # Arguments
    ///
    /// * `x` - The new x position of the window.
    /// * `y` - The new y position of the window.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     window.set_position(100, 100);
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_position(&mut self, x: i32, y: i32) {
        unsafe {
            CGL_window_set_position(self.handle, x, y);
        }
    }

    /// Sets the visibility of the window.
    ///
    /// # Arguments
    ///
    /// * `hidden` - A boolean indicating whether the window should be hidden or not.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     window.set_hidden(true);
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_hidden(&mut self, hidden: bool) {
        unsafe {
            CGL_window_set_hidden(self.handle, hidden as i32);
        }
    }

    /// Sets the user data associated with the window.
    ///
    /// # Arguments
    ///
    /// * `user_data` - A pointer to the user data to associate with the window.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     let user_data = Box::into_raw(Box::new(42));
    ///     window.set_user_data(user_data);
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn set_user_data<T>(&mut self, user_data: *mut T) {
        unsafe {
            CGL_window_set_user_data(self.handle, user_data as *mut c_void);
        }
    }

    /// Gets the user data associated with the window.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     let user_data = Box::into_raw(Box::new(42));
    ///     window.set_user_data(user_data);
    ///     let retrieved_user_data = window.get_user_data();
    ///     assert_eq!(retrieved_user_data, user_data);
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn get_user_data<T>(&self) -> *mut T {
        unsafe {
            CGL_window_get_user_data(self.handle) as *mut T
        }
    }

    /// Gets the size of the window.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     let (width, height) = window.get_size();
    ///     assert_eq!(width, 800);
    ///     assert_eq!(height, 600);
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn get_size(&self) -> (i32, i32) {
        unsafe {
            let (mut width, mut height) = (0, 0);
            CGL_window_get_size(self.handle, &mut width, &mut height);
            (width, height)
        }
    }

    // Gets the position of the window.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     let (x, y) = window.get_position();
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn get_position(&self) -> (i32, i32) {
        unsafe {
            let (mut x, mut y) = (0, 0);
            CGL_window_get_position(self.handle, &mut x, &mut y);
            (x, y)
        }
    }

    // Gets the size of the framebuffer of the window.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     let (width, height) = window.get_framebuffer_size();
    ///     assert_eq!(width, 800);
    ///     assert_eq!(height, 600);
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn get_framebuffer_size(&self) -> (i32, i32) {
        unsafe {
            let (mut width, mut height) = (0, 0);
            CGL_window_get_framebuffer_size(self.handle, &mut width, &mut height);
            (width, height)
        }
    }

    /// Rescues the callbacks of the window.
    /// This is usefule whn usiong cgl::window along with any third party library
    /// that internally uses glfw with cgl::window.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     window.rescure_callbacks();
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn rescure_callbacks(&mut self) {
        unsafe {
            CGL_window_resecure_callbacks(self.handle);
        }
    }


    /// Makes the OpenGL context of the window current.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     window.make_context_current();
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn make_context_current(&mut self) {
        unsafe {
            CGL_window_make_context_current(self.handle);
        }
    }

    // Gets the GLFW handle of the window.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     let handle = window.get_glfw_handle();
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn get_glfw_handle(&self) -> *mut GLFWwindow {
        unsafe {
            CGL_window_get_glfw_handle(self.handle)
        }
    }

    // Gets the state of a keyboard key of the window.
    ///
    /// # Arguments
    ///
    /// * `key` - A `Key` enum value representing the key to get the state of.
    ///
    /// # Returns
    ///
    /// An `Action` enum value representing the state of the key.
    ///
    /// # Example
    ///
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     let action = window.get_key(cgl_rs::Key::A);
    ///     match action {
    ///         cgl_rs::Action::Release => println!("Key A was released"),
    ///         cgl_rs::Action::Press => println!("Key A was pressed"),
    ///         cgl_rs::Action::Repeat => println!("Key A was repeated"),
    ///     }
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn get_key(&self, key: Key) -> Action {
        unsafe {
            cgl_window_i32_to_action(CGL_window_get_key(self.handle, key as i32))
        }
    }

    /// Checks if a keyboard key of the window is pressed.
    /// 
    /// # Arguments
    /// 
    /// * `key` - A `Key` enum value representing the key to check.
    /// 
    /// # Returns
    /// 
    /// A `bool` value representing if the key is pressed.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     if window.is_key_pressed(cgl_rs::Key::A) {
    ///         println!("Key A is pressed");
    ///     }
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn is_key_pressed(&self, key: Key) -> bool {
        unsafe {
            CGL_window_is_key_pressed(self.handle, key as i32) == 1
        }
    }

    /// Gets the state of a mouse button of the window.
    /// 
    /// # Arguments
    ///
    /// * `button` - A `MouseButton` enum value representing the mouse button to get the state of.
    /// 
    /// # Returns
    /// 
    /// An `Action` enum value representing the state of the mouse button.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     let action = window.get_mouse_button(cgl_rs::MouseButton::Left);
    ///     match action {
    ///        cgl_rs::Action::Release => println!("Left mouse button was released"),
    ///        cgl_rs::Action::Press => println!("Left mouse button was pressed"),
    ///        cgl_rs::Action::Repeat => println!("Left mouse button was repeated"),
    ///     }
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn get_mouse_button(&self, button: MouseButton) -> Action {
        unsafe {
            cgl_window_i32_to_action(CGL_window_get_mouse_button(self.handle, button as i32))               
        }
    }

    /// Checks if a mouse button of the window is pressed.
    /// 
    /// # Arguments
    ///
    /// * `button` - A `MouseButton` enum value representing the mouse button to check.
    /// 
    /// # Returns
    /// 
    /// A `bool` value representing if the mouse button is pressed.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     if window.is_mouse_button_pressed(cgl_rs::MouseButton::Left) {
    ///         println!("Left mouse button is pressed");
    ///     }
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn is_mouse_button_pressed(&self, button: MouseButton) -> bool {
        match self.get_mouse_button(button) {
            Action::Press => true,
            _ => false
        }
    }

    /// Gets the position of the mouse cursor relative to the top-left corner of the window.
    /// 
    /// # Returns
    /// 
    /// A tuple containing the x and y coordinates of the mouse cursor.
    /// 
    /// # Example
    /// 
    /// ```
    /// cgl_rs::init();
    /// {
    ///     // window inside scope so that it is dropped before shutdown is called
    ///     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    ///     let (x, y) = window.get_mouse_position();
    ///     println!("Mouse position: ({}, {})", x, y);
    /// }
    /// cgl_rs::shutdown();
    /// ```
    pub fn get_mouse_position(&self) -> (f64, f64) {
        unsafe {
            let (mut x, mut y) = (0.0, 0.0);
            CGL_window_get_mouse_position(self.handle, &mut x, &mut y);
            (x, y)
        }
    }



}

impl Drop for Window {
    fn drop(&mut self) {
        self.destroy();
    }
}
```

`rust_wrapper/sandbox/Cargo.toml`:

```toml
[package]
name = "sandbox"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
cgl-rs = {path = "../cgl-rs"}

```

`rust_wrapper/sandbox/src/main.rs`:

```rs
fn on_window_event(_window: &cgl_rs::Window, event: &cgl_rs::Event) -> bool {
    match event {
        cgl_rs::Event::WindowClose => {
            println!("Window Close Event");
            true
        },
        cgl_rs::Event::FramebufferSize(width, height) => {
            println!("Window Resize Event: {}x{}", width, height);
            false
        },   
        cgl_rs::Event::DragNDrop(paths) => {
            println!("Drag and Drop Event: {:?}", paths);
            false
        },
        _ => {false}
    }
}

fn main() {
    cgl_rs::init().expect("Failed to initialize CGL");

    let ma = cgl_rs::math::Matrix4x4::scale(5.0, 6.0, 7.0);
    println!("Matrix A: {}", ma);

    // {
    //     // new scope so the window is dropped before shutdown
    //     let mut window = cgl_rs::Window::new("My Window", 800, 600).unwrap();
    //     window.register_for_events();
    //     window.attach_event_handler("my_event_handler", &on_window_event);
    //     while !window.should_close() {
    //         if window.is_key_pressed(cgl_rs::Key::Escape) {
    //             break;
    //         }

    //         window.poll_events();
    //         window.swap_buffers();
    //     }
    // }
    cgl_rs::shutdown();
}
```