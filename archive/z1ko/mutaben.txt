Project Path: arc_z1ko_mutaben_ktplou1u

Source Tree:

```txt
arc_z1ko_mutaben_ktplou1u
├── README.md
├── banner.png
├── bexpr.py
├── fibonacci.py
├── generator.py
├── main.py
├── mutator.py
├── old.py
├── service.py
├── test.py
└── utils.py

```

`README.md`:

```md

# Mutaben - Mixed Boolean Arithmetic Generator

![Banner](banner.png)

## Work in progress

MBA expression are defined as the mixture usage of bitwise operations (∨, ∧, ⊕, ¬) and integer arithmetic operations(+, −,×).

```

`bexpr.py`:

```py

import numpy as np
import utils

# Funzione comoda per valutare combinazioni affini
def evaluate_affine(vars, terms, offset):
    result = sum(map(lambda term: term[0] * term[1].func(vars), terms)) + offset
    return result


# Rappresenta una generica espressione booleana
class BExpr:
    def __init__(self, text, func, size = 2) -> None:
        self.text = text
        self.func = func
        self.size = size


# Rappresenta una espressione in mixed-boolean-arithmetic   
class MBAExpr:
    def __init__(self) -> None:
        self.elements = []

    def add_term(self, coef: int, expr: BExpr):
        self.elements.append((coef, expr))

    # Visualizza la MBA in un formato leggibile
    def print(self):
        print("{ ", end='')
        for (coef, expr) in self.elements:
            #sign = '-' if coef < 0 else '+'
            #print(f"{sign} {abs(coef)} * ({expr.text}) ", end='')
            print(f"({coef}, {expr.text}), ", end='')
        print("}")

    # Valuta la MBA date le variabili
    def evaluate(self, vars):
        res = 0
        for coef, expr in self.elements:
            assert(expr.size == len(vars))
            res += coef * expr.func(vars)
        return res

    # Controlla che la MBA sia un'identità uguale a 0
    def is_zero_identity(self):
        _, bexpr = self.elements[0]
        for bits in utils.get_bits_seq(pow(2, bexpr.size)):
            if not self.evaluate(bits) == 0:
                return False

        for _ in range(100):
            vars = np.random.randint(10000, size=2)
            if self.evaluate(vars) != 0:
                return False

        return True

    # Controlla che la MBA si comporti come expr
    def is_mutation(self, expr: BExpr):
        _, bexpr = self.elements[0]
        for bits in utils.get_bits_seq(pow(2, bexpr.size)):

            eval1 = self.evaluate(bits)
            eval2 = expr.func(bits)

            #print(f"Evaluate: {eval1} vs {eval2}")
            if eval1 != eval2:
                return False

        # Controllo stocastico
        for _ in range(100):
            vars = np.random.randint(10000, size=2)
            if self.evaluate(vars) != expr.func(vars):
                return False

        return True

    # Controlla che la MBA si comporto come una combinazione affine
    def is_mutation_affine(self, terms, offset):

        _, bexpr = self.elements[0]
        for bits in utils.get_bits_seq(pow(2, bexpr.size)):

            eval1 = self.evaluate(bits)
            eval2 = evaluate_affine(bits, terms, offset)

            #print(f"Evaluate for (x: {bits[0]}, y: {bits[1]}) -> {eval1} vs {eval2}")
            if eval1 != eval2:
                return False

        # Controllo stocastico
        for _ in range(100):
            vars = np.random.randint(10000, size=2)

            eval1 = self.evaluate(vars)
            eval2 = evaluate_affine(vars, terms, offset)

            #print(f"Evaluate for (x: {vars[0]}, y: {vars[1]}) -> {eval1} vs {eval2}")
            if eval1 != eval2:
                return False
        
        return True
    
    # Ritorna una versione in stringa della mba
    def as_string(self):
        result = ""
        for i, (coef, expr) in enumerate(self.elements):
            if i != 0:
                result += " + "
            result += f"({coef}) * ({expr.text})"
        return result

```

`fibonacci.py`:

```py


def gcd_normal(a, b):
    while a != b:
        if a > b:
            a = a - b
        else:
            b = b - a
    return a

def gcd_mutated(x, y):
    while x != y:
        if x > y:
            x = (2) * (x) + (-12) * (y) + (29) * (x & y) + (-11) * (x | (~y)) + (3) * (x ^ y) + (2) * ((~x) & (~y)) + (9) * (~x) + (8) * (~y) + (7) * ((~x) ^ (~y)) + (8) * (1)
        else:
            y = (-7) * (y) + (15) * (x & y) + (-1) * (x | (~y)) + (6) * (x ^ y) + (8) * (~x) + (1) * ((~x) ^ (~y)) + (7) * (1)
    return x


print(gcd_normal(128, 62))
print(gcd_mutated(128, 62))
```

`generator.py`:

```py

import sympy as sp
import numpy as np

from pprint import pprint

from bexpr import BExpr, MBAExpr
import utils

class MBAGenerator:
    def __init__(self, exprs) -> None:
        self.exprs = exprs

    # Genera matrice A di analisi
    def matrix(self):
        result = []
        for bexp in self.exprs:
            R = []
            for bits in utils.get_bits_seq(pow(2, bexp.size)):
                R.append(bexp.func(bits))
            result.append(R)

        return sp.Matrix(result) \
            .transpose()

    # Genera array di mba che rappresentano un'identità
    def identities(self, max_coeff = 10, count = 4, check_identity = False):
        res = []

        A = self.matrix()
        kernel_basis = A.nullspace()
        for _ in range(count):
            mba = MBAExpr()
            
            # Crea combinazione lineare delle colonne del kernel
            # per generare diverse versioni valide della MBA
            coefs = np.random.randint(max_coeff, size=len(kernel_basis))
            gmask = np.random.randint(2, size=len(kernel_basis))
            combination = kernel_basis[0]
            for i, (coeff, generator) in enumerate(zip(coefs, kernel_basis)):
                if i != 0 and gmask[i] != 0:
                    combination += coeff * generator
            
            # Utilizza la combinazione per selezionare solo le espressioni
            # con un coefficente diverso da zero
            for i, bexp in enumerate(self.exprs):
                coeff = combination[i]
                if coeff != 0:
                    mba.add_term(coeff, bexp)

            # Test sulle possibili combinazioni booleane di input
            # se queste sono corrette allora anche le combinazioni
            # a più bit lo sono
            if check_identity:
                assert(mba.is_zero_identity())
            
            res.append(mba)
        return res

    # Genera delle MBA che si comportano allo stesso modo rispetto 
    # ad una generica funzione booleana
    def mutate(self, expr: BExpr):
        A = self.matrix()

        # Genera vettore binario di risposta all'input
        b = sp.zeros(pow(2,expr.size), 1)
        for i, bits in enumerate(utils.get_bits_seq(pow(2, expr.size))):
            b[i] = expr.func(bits)

        # Genera simboli per ogni espressioni booleana utilizzabile
        symbols = []
        for i in range(len(self.exprs)):
            symbols.append(sp.symbols("e%d" % i))

        # Risolve sistema indeterminato, ottenendo uno spazio delle soluzioni
        solution = sp.linsolve((A, b), symbols).args[0]
        
        # Ottiene soluzione randomica
        coef = np.random.randint(10, size=len(self.exprs))
        subs = [ ("e%d" % i, coef[i]) for i in range(len(self.exprs))]
        solution = solution.subs(subs)
        #print(solution)

        # Genera MBA
        mba = MBAExpr()
        for i, bexp in enumerate(self.exprs):
            coeff = solution[i]
            if coeff != 0:
                mba.add_term(coeff, bexp)

        assert(mba.is_mutation(expr))
        return mba

    # Genera una MBA che simula una combinazione affine
    def mutate_affine(self, terms, offset):
        A = self.matrix()

        # Genera vettore binario di risposta all'input
        # NB: L'algoritmo è diverso da quello presentato nel paper, qui viene direttamente
        # sommato il valore di offset e non sottratto, non ho idea del perché
        b = sp.zeros(pow(2, terms[0][1].size), 1)
        for i, bits in enumerate(utils.get_bits_seq(pow(2, terms[0][1].size))):
            b[i] = sum(map(lambda term: term[0] * term[1].func(bits), terms)) + offset

        # Genera simboli per ogni espressioni booleana utilizzabile
        symbols = []
        for i in range(len(self.exprs)):
            symbols.append(sp.symbols("e%d" % i))

        # Risolve sistema indeterminato, ottenendo uno spazio delle soluzioni
        solution = sp.linsolve((A, b), symbols).args[0]

        coef = np.random.randint(10, size=len(self.exprs))
        subs = [ ("e%d" % i, coef[i]) for i in range(len(self.exprs))]
        solution = solution.subs(subs)

        mba = MBAExpr()
        for i, bexp in enumerate(self.exprs):
            coeff = solution[i]
            if coeff != 0:
                mba.add_term(coeff, bexp)

        assert(mba.is_mutation_affine(terms, offset))
        return mba
```

`main.py`:

```py

from generator import MBAGenerator
from bexpr import BExpr

# TODO: Trova un modo per inserirle dinamicamente
EXPRS = [
    BExpr("x",       lambda vars: vars[0]),
    BExpr("y",       lambda vars: vars[1]),
    BExpr("x & y",   lambda vars: vars[0] & vars[1]),
    BExpr("x | ~y",  lambda vars: vars[0] | ~vars[1]),
    BExpr("x ^ y",   lambda vars: vars[0] ^ vars[1]),
    BExpr("~x & ~y", lambda vars: ~vars[0] & ~vars[1]),
    BExpr("~x",      lambda vars: ~vars[0]),
    BExpr("~y",      lambda vars: ~vars[1]),
    BExpr("~x ^ ~y", lambda vars: ~vars[0] ^ ~vars[1]),
    BExpr("1",       lambda vars: -1)
]

if __name__ == "__main__":
    gen = MBAGenerator(EXPRS)

    count = int(input("Quante identità MBA vuoi generare? "))
    maxcf = int(input("Quale valore massimo dei coef. vuoi usare? "))

    identities = gen.identities(count=count, max_coeff=maxcf, check_identity=True)
    for i, identity in enumerate(identities):
        print("%03s | " % i, end='')
        identity.print()



```

`mutator.py`:

```py

import re
import numpy as np
from generator import MBAGenerator
from bexpr import BExpr, evaluate_affine

class Mutator:
    def __init__(self, exprs) -> None:
        self.generator = MBAGenerator(exprs)

        # TODO: Make more versatile
        self.x = BExpr("x", lambda vars: vars[0])
        self.y = BExpr("y", lambda vars: vars[1])


    # Returns a muated version of the affine expr. provided
    # works only for x and y
    def rewrite(self, expr_string: str) -> str:

        vars = { }
        offset = 0

        expr_string = expr_string.strip().replace(" ", "")
        matches = re.findall("([+-]*)([0-9]*)([a-z]{0,1})", expr_string)        
        for i in range(len(matches) - 1):
            m_sign, m_coef, m_var = matches[i]

            # Skip empty matches
            if m_sign == '' and m_coef == '' and m_var == '':
                continue

            sign = 1 if m_sign != '-' else -1
            coef = 1 if m_coef == ''  else int(m_coef)

            # Offset
            if m_var == '':
                offset += sign * coef
                continue

            if not m_var in vars:
                vars[m_var] = 0
        
            vars[m_var] += sign * coef

        terms = [
            (vars['x'], self.x),
            (vars['y'], self.y)
        ]

        mba = self.generator.mutate_affine(terms, offset)
        return mba


```

`old.py`:

```py

import sympy as sp
import numpy as np

import random as rnd
from pprint import pprint

# Genera bits da un intero
def get_bits(value, bitsize = 2):
    result = []
    for i in range(bitsize):
        result.append((value >> i) & 0b1)
    return list(reversed(result))

# Genera matrice A da una serie di espressioni booleane e un numero di variabili
def gen_A(bexprs, vars_num = 2):
    A = []
    for bexp in bexprs:
        R = []
        for bits in [ get_bits(i) for i in range(0, pow(2, vars_num))]:
            R.append(bexp[0](bits))
        A.append(R)
    return sp.Matrix(A).transpose()


def calculate(MBA, bits):
    res = 0
    for (coeff, bexp) in MBA:
        res += coeff * bexp[0](bits)
    return res

def mba_print(MBA):
    for (coeff, bexp) in MBA:
        sign = '-' if coeff < 0 else '+'
        print(f"{sign} {abs(coeff)} * ({bexp[1]}) ", end='')

# Controlla che la MBA sia un'identità
def assert_identity(MBA):
    for bits in [ get_bits(i) for i in range(pow(2, VARS_NUM))]:
        assert(calculate(MBA, bits) == 0)

# Estrae termini dalla MBA
def extract(MBA, terms):
    sol = []
    eeq = []
    for (coeff, bexp) in MBA:
        found = False
        for term in terms:
            if bexp[1] == term[1] and coeff == term[0]:
                found = True
                break

        if found:
            sol.append((-coeff, bexp))
        else:
            eeq.append((coeff, bexp))

    return sol, eeq


# Numero di variabili
VARS_NUM = 2
# Numero di espressioni booleane
BEXP_NUM = 4

BEXPS = [
    (lambda vars: vars[0], "x"), # Identità di x
    (lambda vars: vars[1], "y"), # Identità di y
    (lambda vars: vars[0] & vars[1],   "x & y"),
    (lambda vars: vars[0] | ~vars[1],  "x | ~y"),
    (lambda vars: vars[0] ^ vars[1],   "x ^ y"),
    (lambda vars: ~vars[0] & ~vars[1], "~x & ~y"),
    (lambda vars: ~vars[0], "~x"),
    (lambda vars: ~vars[1], "~y"),
    (lambda vars: ~vars[0] ^ ~vars[1], "~x ^ ~y"),
    (lambda vars: 1, "1")
]

A = gen_A(BEXPS)
pprint(A)

# ============================================================
# IDENTITA'

print("Identità trovate:")
for generator in A.nullspace():
    
    MBA = []
    for i, bexp in enumerate(BEXPS):
        coeff = generator[(i, 0)]
        if coeff != 0:
            MBA.append((coeff, bexp))

    assert_identity(MBA)

    print("\t0 == ", end='')
    mba_print(MBA)
    print("")

    vars, terms = extract(MBA, [(-1, "x"), (-1, "y")])
    if len(vars) == 2:
        print("\tRegola di riscrittura per x + y: ", end='')
        mba_print(terms)
        print("")


exit(0)

# ============================================================
# ESPRESSIONI LOGICHE GENERICHE

# Funzione logica da rappresentare come MBA lineare
f = (lambda vars: ~(vars[0] & ~vars[1]) | (~vars[0] ^ vars[1]), "~(x & ~y) | (~x ^ y)")

# Ottiene rappresentazione binaria della funzione f
# F = [
#   f(00)
#   f(01)
#   f(10)
#   f(11)
# ]
F = sp.zeros(pow(2, VARS_NUM), 1)
for input in range(pow(2, VARS_NUM)):
    F[input] = (f[0])(get_bits(input))
#pprint(F)

#x = A.LDLsolve(F)
#pprint(x)
#exit(0)

# Pseudo inversa
K = A.pinv()

# Controlla che esistano soluzioni
assert(A * K * F == F)

w = sp.Matrix(8, 1, [0, 1, 0, 1, 0, 1, 0, 1])
x = K * F + (sp.eye(8, 8) - K * A) * w
# pprint(x)

# Ottiene una forma migliore della MBA
g = sp.gcd([ e for e in x[:, 0]])
x = x * (1 / g)
# pprint(x)

MBA = []
for i, bexp in enumerate(BEXPS):
    coeff = x[(i, 0)]
    if coeff != 0:
        MBA.append((coeff, bexp))

# Visualizza MBA

print("Conversione di funzioni logiche:")
print(f"\t[ {f[1]} ] <=> [ ", end='')
for (coeff, bexp) in MBA:
    sign = '-' if coeff < 0 else '+'
    print(f"{sign} {abs(coeff)} * ({bexp[1]}) ", end='')
print("]")


# Controlla che il risultato sia uguale per f è la mba lineare
for bits in [ get_bits(i) for i in range(pow(2, VARS_NUM))]:
    res1 = f[0](bits)
    res2 = calculate(MBA, bits)
    if res1 != res2:
        print(f"Failed check at {bits}, f = {res1}, mba = {res2}")
        exit(-1)

# Controlla per valori superiori a 2
for i in range(100):
    values = np.random.randint(1, 100, 2)
    # print(f"check {values}")
    assert(f[0](values) == calculate(MBA, values))

# ============================================================
# ESPRESSIONI AFFINI GENERICHE
```

`service.py`:

```py

import re
import numpy as np
from generator import MBAGenerator
from bexpr import BExpr, evaluate_affine
from mutator import Mutator

# TODO: Trova un modo per inserirle dinamicamente
EXPRS = [
    BExpr("x",              lambda vars: vars[0]),
    BExpr("y",              lambda vars: vars[1]),
    BExpr("x & y",          lambda vars: vars[0] & vars[1]),
    BExpr("x | (~y)",       lambda vars: vars[0] | ~vars[1]),
    BExpr("x ^ y",          lambda vars: vars[0] ^ vars[1]),
    BExpr("(~x) & (~y)",    lambda vars: ~vars[0] & ~vars[1]),
    BExpr("~x",             lambda vars: ~vars[0]),
    BExpr("~y",             lambda vars: ~vars[1]),
    BExpr("(~x) ^ (~y)",    lambda vars: ~vars[0] ^ ~vars[1]),
    BExpr("1",              lambda vars: 1)
]


if __name__ == "__main__":
    mutator = Mutator(EXPRS)

    expr_text = input("Inserisci la combinazione affine di x e y da mutare:\n\n\t")
    count = int(input("\nQuante vuoi crearne? "))

    print("\nEspressione MBA generate:\n")
    for i in range(count):

        mba = mutator.rewrite(expr_text)
        print(mba.as_string())

```

`test.py`:

```py

import unittest as ut
import numpy as np
import sympy as sp

from generator import MBAGenerator
from bexpr import BExpr, evaluate_affine

# Test boolean expression used in the generator
EXPRS = [
    BExpr("x",       lambda vars:  vars[0]),
    BExpr("y",       lambda vars:  vars[1]),
    BExpr("x & y",   lambda vars:  vars[0] &  vars[1]),
    BExpr("x | ~y",  lambda vars:  vars[0] | ~vars[1]),
    BExpr("x ^ y",   lambda vars:  vars[0] ^  vars[1]),
    BExpr("~x & ~y", lambda vars: ~vars[0] & ~vars[1]),
    BExpr("~x",      lambda vars: ~vars[0]),
    BExpr("~y",      lambda vars: ~vars[1]),
    BExpr("~x ^ ~y", lambda vars: ~vars[0] ^ ~vars[1]),
    BExpr("1",       lambda vars: 1)
]

class TestLibrary(ut.TestCase):

    # Controlla che le identità generate siano corrette
    def test_generator_identities(self):
        
        GEN_MAX_COEFF = 100000
        GEN_MBA_COUNT = 10
        RNG_STO_COUNT = 100
        RNG_MAX_INPUT = 10000
        
        generator = MBAGenerator(EXPRS)
        for identity in generator.identities(max_coeff=GEN_MAX_COEFF, count=GEN_MBA_COUNT, check_identity=False):
            self.assertTrue(identity.is_zero_identity())

            # Controllo stocastico con valori interi
            for _ in range(RNG_STO_COUNT):
                vars = np.random.randint(RNG_MAX_INPUT, size=2)
                self.assertEqual(0, identity.evaluate(vars))


    # Controlla che le mutazioni siano corrette
    def test_generator_mutate(self):
        generator = MBAGenerator(EXPRS)

        expr = BExpr("...", lambda bits: (~bits[0] & ~bits[1]) | (bits[0] & bits[1]))
        for i in range(10):
            mba = generator.mutate(expr)
            self.assertTrue(mba.is_mutation(expr))


    # Controlla che le mutazioni di combinazioni lineari siano corrette
    def test_generator_mutate_linear(self):
        generator = MBAGenerator(EXPRS)
        terms = [
            (4, BExpr("", lambda vars:  vars[0] ^ ~vars[1])),
            (6, BExpr("", lambda vars: ~vars[0] |  vars[1])),
            (9, BExpr("", lambda vars: ~vars[0] & ~vars[1]))
        ]
    
        for i in range(100):
            mba = generator.mutate_affine(terms, 0)
            mba.print()

            vars = np.random.randint(0, 1001, size=2)
            self.assertTrue(mba.evaluate(vars) == evaluate_affine(vars, terms, 0))

    
    # Controllo mutazione su somme semplice di variabili
    def test_generator_mutate_linear_simple(self):
        generator = MBAGenerator(EXPRS)
        terms = [
            (1, BExpr("x", lambda vars: vars[0])),
            (1, BExpr("y", lambda vars: vars[1])),
        ]

        for i in range(100):
            mba = generator.mutate_affine(terms, 0)
            mba.print()

            vars = np.random.randint(0, 1001, size=2)
            self.assertTrue(mba.evaluate(vars) == vars[0] + vars[1])





if __name__ == "__main__":
    ut.main()
```

`utils.py`:

```py

# Ritorna un array con i bit del valore in input
def get_bits(value, bitsize = 2):
    result = []
    for i in range(bitsize):
        result.append((value >> i) & 0b1)
    return list(reversed(result))

# Ritorna una sequenza di 'count' array di bit in ordine incrementale
def get_bits_seq(count):
    return [ get_bits(i) for i in range(count) ]
```